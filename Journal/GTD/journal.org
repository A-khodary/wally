#+LATEX_HEADER: \usepackage[boxed, lined]{algorithm2e}
# #+LATEX_HEADER: \usepackage{minted}
# #+LATEX_HEADER: \usepackage{float}
#+PORPERTY: RANDOM

# freemind
# .sdcv_history
# agenda
# obj

* Journal
** TASK

- [X] 处理邮递三方
- [X] 制连接线
- [ ] SLAM matlab 仿真
- [ ] 论文 outlier 剔除
- [X] 大脑疲劳时如何放松
- [ ] 淘宝上买元器件

** INBOX
# 存放当日能够在一刻钟之内处理完成的事务

** JOURNAL

[07:50]
早起六点闹铃响起的时候，想接着小憩五分钟，却被震天的呼噜扰得不得安宁。
不知梦里还是窗外同时传来猫叫春的声音。真是喧嚣的清晨。
腿部还在发酸，空气也是中度污染，不想跑步，赖床到六点半。起床之后，冲一
杯咖啡，捧起 Kindle，开始阅读。早上安静的时光真好啊。
一边阅读，一边做笔记，纸和笔弥补了 Kindle 在做笔记上的不足。很快一个小
时便过去了。
七点半，开始做冥想，这回感觉好多了。
接下来完成布置的任务。

*** GRATITUDE

1. 清晨享受阅读

*** 读书笔记: Kindle 摘录是不够的
** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

** 2016

- [X] +dota2+
- [X] fcitx
- [X] +vim+

*** list

- [ ] <算法导论>
- [ ] makeups
- [ ] UTG 线

*** NEXT 使用 blender 制作 Mecanum 轮
- State "NEXT"       from "TODO"       [2016-01-30 六 15:46]
**** DONE 准备
- State "DONE"       from "TODO"       [2016-01-30 六 15:18]
- [X] blender + dae
- [X] 文献
- [X] matlab
- [X] wine + CAJ + FoxitReader
- [X] blender 本地教程

*** NEXT Thesis
- State "NEXT"       from "TODO"       [2016-01-30 六 15:46]
**** DONE preperation
- State "DONE"       from "TODO"       [2016-01-30 六 15:18]
- [X] workspace
- [X] texlive
- [X] emacs + auctex
- [X] wine + CAJ

*** NEXT Gazebo sim
- State "NEXT"       from "TODO"       [2016-01-30 六 20:18]
**** DONE preparation
- State "DONE"       from "TODO"       [2016-01-30 六 20:18]
- [X] gazebo models
- [X] gazebo doc

*** NEXT imusim
- State "NEXT"       from "TODO"       [2016-01-30 六 15:46]
**** DONE preperation
- State "DONE"       from "TODO"       [2016-01-30 六 15:24]
- [X] source code
- [X] matlab
- [X] book

*** NEXT algorithms
- State "NEXT"       from "TODO"       [2016-01-30 六 15:46]
**** DONE preperation
- State "DONE"       from "TODO"       [2016-01-30 六 15:26]
- [X] book in papaer

*** NEXT PF
- State "NEXT"       from "TODO"       [2016-01-30 六 15:46]
**** DONE preparation
- State "DONE"       from "TODO"       [2016-01-30 六 15:38]
- [X] blog
- [X] source
- [X] math textbook

*** NEXT SLAM sim
- State "NEXT"       from "TODO"       [2016-01-30 六 15:46]
**** DONE preparation
- State "DONE"       from "TODO"       [2016-01-30 六 15:28]
- [X] source code
- [X] matlab

*** NEXT SLAM python 2d
- State "NEXT"       from "TODO"       [2016-01-30 六 15:46]
**** DONE preperation
- State "DONE"       from "TODO"       [2016-01-30 六 15:27]
- [X] 视频
- [X] 源码
*** NEXT es tools
- State "NEXT"       from "TODO"       [2016-01-30 六 19:59]
**** DONE preparation
- State "DONE"       from "TODO"       [2016-01-30 六 19:59]
- [X] avr
- [X] arduino
- [X] cross-tool

*** TODO Deutsch

**** TODO preparation

- [ ] VM
- [ ] video course
- [ ] movie
- [ ] audio  & article slown genmen

*** TODO PCL

**** DONE preparation

- State "DONE"       from "TODO"       [2016-02-06 六 16:46]
- [X] lib
- [X] rospack
- [X] doc/ref
- [X] qtcreator

**** pcltk
*** matplotlib

** 99 B
*** TODO nmap

- https://nmap.org/
- http://jingyan.baidu.com/article/47a29f24312010c0142399f1.html

*** TODO wireshark

- http://jingyan.baidu.com/article/d71306350f213b13fdf475b9.html
- http://blog.jobbole.com/70907/
- http://www.douban.com/note/328099725/?type=like

*** 雅可比矩阵

[[~/Wally/Reference/Wikipedia/Jacobian.pdf][Jacobian.pdf]]

*** 维基百科保存页面

1. 使用 pandoc 转换为 Wikipedia 页面为 org-mode 笔记

   - 图片链接不是完整路径，因而需要额外处理
   - 冗余的链接，如 [[编辑]] 等
   - 多余的符号 =\\= 等等

2. 使用 wkhtmltopdf 转换为 Wikipedia 页面为 PDF，效果非常理想，没有多
   余的 css/Layout

*** 百度云 Wine 安装出错，不再使用
*** MATLAB IDE doc

MATLAB 2014a 的 doc 命令是在新窗口中打开帮助文档，这样很人性化，因为命
令窗口一般只占窗口的很小一部分。

** 98 B
- [ ] 将所有传感器（3+1）及电源板和主板连接好，先不拆线，以在本周内完
  成测试
- [ ] 设置主机板的静态IP
- [ ] 研究 Hokuyo 如何设置独立的 ID，这样便与USB连接顺序无关
- [ ] 数据关联与增广部分 Matlab 代码仔细阅读
- [ ] 论文的 EKF-SLAM 部分（一次搞定）

*** Python IDE                                                        :ide:

<2016-03-02 三 10:11>
#+BEGIN_SRC org
还是使用 Emacs， Python 毕竟不是像 C++ 那么变态。
#+END_SRC


**** [[http://www.ahlinux.com/python/10190.html][提供给开发者 10 款最好的 Python IDE]]

Python 非常易学，强大的编程语言。Python
包括高效高级的数据结构，提供简单且高效的面向对象编程。Python
的学习过程少不了 IDE 或

Python 非常易学，强大的编程语言。Python
包括高效高级的数据结构，提供简单且高效的面向对象编程。

Python 的学习过程少不了 IDE
或者代码编辑器，或者集成的开发编辑器（IDE）。这些 Python
开发工具帮助开发者加快使用 Python
开发的速度，提高效率。高效的代码编辑器或者 IDE
应该会提供插件，工具等能帮助开发者高效开发的特性。

这篇文章收集了一些对开发者非常有帮助的，最好的 12 款 Python
IDEs。如果你有其他更好的推荐，请在评论和大家分享一下：）

**** 1.Vim

#+DOWNLOADED: http://www.ahlinux.com/uploadfile/2014/1129/20141129044713679.jpg @ 2016-03-01 11:13:49
 [[~/Wally/Journal/Figure/.org-download/Journal/20141129044713679_2016-03-01_11:13:48.jpg]]

Vim 可以说是 Python 最好的 IDE。Vim 是高级文本编辑器，旨在提供实际的
Unix 编辑器‘Vi'功能，支持更多更完善的特性集。Vim
不需要花费太多的学习时间，一旦你需要一个无缝的编程体验，那么就会把 Vim
集成到你的工作流中。

**** 3.Sublime Text

#+DOWNLOADED: http://www.ahlinux.com/uploadfile/2014/1129/20141129044713314.jpg @ 2016-03-01 11:14:04
 [[~/Wally/Journal/Figure/.org-download/Journal/20141129044713314_2016-03-01_11:14:04.jpg]]

Sublime Text
是开发者中最流行的编辑器之一，多功能，支持多种语言，而且在开发者社区非常受欢迎。Sublime
有自己的包管理器，开发者可以使用TA来安装组件，插件和额外的样式，所有这些都能提升你的编码体验。

**** 4.Emacs

#+DOWNLOADED: http://www.ahlinux.com/uploadfile/2014/1129/20141129044713810.jpg @ 2016-03-01 11:14:12
 [[~/Wally/Journal/Figure/.org-download/Journal/20141129044713810_2016-03-01_11:14:12.jpg]]

GNU Emacs 是可扩展，自定义的文本编辑器，甚至是更多的功能。Emacs 的核心是
Emacs Lisp 解析器，但是支持文本编辑。如果你已经使用过 Vim，可以尝试一下
Emacs。

**** 2.Eclipse with PyDev

#+DOWNLOADED: http://www.ahlinux.com/uploadfile/2014/1129/20141129044713480.jpg @ 2016-03-01 11:13:59
 [[~/Wally/Journal/Figure/.org-download/Journal/20141129044713480_2016-03-01_11:13:59.jpg]]

Eclipse 是非常流行的 IDE，而且已经有了很久的历史。Eclipse with Pydev
允许开发者创建有用和交互式的 Web 应用。PyDev 是 Eclipse 开发 Python 的
IDE，支持 Python，Jython和 IronPython 的开发。

**** 5.[[http://komodoide.com/komodo-edit/][Komodo Edit]]

#+DOWNLOADED: http://www.ahlinux.com/uploadfile/2014/1129/20141129044714584.jpg @ 2016-03-01 11:20:28
 [[~/Wally/Journal/Figure/.org-download/Journal/20141129044714584_2016-03-01_11:20:28.jpg]]

Komodo Edit 是非常干净，专业的 Python IDE。

<2016-03-02 三 09:52>
#+BEGIN_SRC org
  Komodo Edit 开源免费，但只提供基本的编辑等功能，像调试等功能需要用专业
  版的 Komodo IDE
#+END_SRC

**** 6.[[https://www.jetbrains.com/pycharm/][PyCharm]]                                                   :pycharm:

#+DOWNLOADED: http://www.ahlinux.com/uploadfile/2014/1129/20141129044714347.jpg @ 2016-03-01 11:14:18
 [[~/Wally/Journal/Figure/.org-download/Journal/20141129044714347_2016-03-01_11:14:18.jpg]]

PyCharm 是 JetBrains 开发的 Python
IDE。PyCharm用于一般IDE具备的功能，比如，
调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制......另外，PyCharm还提供了一些很好的功能用于
Django开发，同时支持Google App Engine，更酷的是，PyCharm支持IronPython！

***** [[https://www.jetbrains.com/pycharm/help/tutorial-using-emacs-as-an-external-editor-in-pycharm.html][Tutorial: Using Emacs as an External Editor in PyCharm]]      :emacs:

<2016-03-02 三 09:59>
#+BEGIN_SRC org
官方教程
使用 Emacs 作为外部编辑器？意义何在？自动补全功能在 Emacs 中能够继承么？
#+END_SRC

***** [[http://stackshare.io/stackups/emacs-vs-pycharm][PyCharm vs. Emacs]]                                           :emacs:

<2016-03-02 三 10:07>
#+BEGIN_SRC org
PyCharm 似乎没有 Emacs 按键配置方案。
所以还是 Emacs
#+END_SRC


**** 7.Wing

#+DOWNLOADED: http://www.ahlinux.com/uploadfile/2014/1129/20141129044715419.jpg @ 2016-03-01 11:14:29
 [[~/Wally/Journal/Figure/.org-download/Journal/20141129044715419_2016-03-01_11:14:29.jpg]]

Wingware 的 Python IDE 兼容 Python 2.x 和 3.x，可以结合 Django,
matplotlib, Zope, Plone, App Engine, PyQt, PySide, wxPython, PyGTK,
Tkinter, mod_wsgi, pygame, Maya, MotionBuilder, NUKE, Blender 和其他
Python 框架使用。Wing 支持测试驱动开发，集成了单元测试，nose 和 Django
框架的执行和调试功能。Wing IDE 启动和运行的速度都非常快，支持 Windows,
Linux, OS X 和 Python versi。

**** 8.PyScripter                                             :pyscripter:

- [[https://github.com/pyscripter/pyscripter][Github]]

#+DOWNLOADED: http://www.ahlinux.com/uploadfile/2014/1129/20141129044715385.jpg @ 2016-03-01 11:14:38
 [[~/Wally/Journal/Figure/.org-download/Journal/20141129044715385_2016-03-01_11:14:38.jpg]]

PyScripter 是款免费开源的 Python 集成开发环境（IDE）。

**** 9.The Eric Python IDE

#+DOWNLOADED: http://www.ahlinux.com/uploadfile/2014/1129/20141129044716754.jpg @ 2016-03-01 11:14:46
 [[~/Wally/Journal/Figure/.org-download/Journal/20141129044716754_2016-03-01_11:14:46.jpg]]

Eric 是全功能的 Python 和 Ruby 编辑器和 IDE，是使用 Python 编写的。Eric
基于跨平台的 GUI 工具包 Qt，集成了高度灵活的 Scintilla 编辑器控件。Eric
包括一个插件系统，允许简单的对 IDE 进行功能性扩展。

**** 10. [[http://www.iep-project.org/about.html][Interactive Editor for Python]]

#+DOWNLOADED: http://www.ahlinux.com/uploadfile/2014/1129/20141129044717696.jpg @ 2016-03-01 11:15:04
 [[~/Wally/Journal/Figure/.org-download/Journal/20141129044717696_2016-03-01_11:15:04.jpg]]

IEP 是跨平台的 Python IDE，旨在提供简单高效的 Python
开发环境。包括两个重要的组件：编辑器和
Shell，并且提供插件工具集从各个方面来提高开发人员的效率。

*** 利用 org-mode 对博客等添加笔记

格式：

Org-mode 时间戳
#+BEGIN_SRC org
  commenting...
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun wally-comment()
    """add comment to org-mode note converted from web"""
    (interactive)
    (org-date-from-calendar)
    (insert "  ")
    (wally-insert-current-time)
    (insert "\n#+BEGIN_SRC org\n#\n#+END_SRC")
    (org-edit-special)
    )
#+END_SRC

*好二，用 yasnippet 呀*

#+BEGIN_SRC snippet
  # -*- mode: snippet; require-final-newline: nil -*-
  # name: wally-c:org-comment
  # key: c
  # binding: direct-keybinding
  # --
  <`(insert (format-time-string "%Y-%m-%d %a %H:%M"))`>
  ,#+BEGIN_SRC org
  `(org-edit-special)`
  ,#+END_SRC
#+END_SRC

<2016-03-01 二 12:58>
#+BEGIN_SRC org
  测试 OK
#+END_SRC

*** org 时间戳

- [[http://www.cnblogs.com/holbrook/archive/2012/04/14/2447754.html][Emacs学习笔记(10):Org-mode,最强的任务管理利器，没有之一]]

Org-mode中的任务还可以设置计划时间（SCHEDULED）和截止时间（DEADLINE），方便任务的管理和排程。

**** 时间戳

在Org-mode中，将带有日期和时间信息的特定格式的字符串称为时间戳。时间戳使用”<
>“进行标记，比如：

#+BEGIN_EXAMPLE
    <2005-10-01 Tue>
    <2003-09-16 Tue 09:39>
    <2003-09-16 Tue 12:00-12:30>
#+END_EXAMPLE

时间戳分为两种，上面的例子中的时间戳都标记了一个”时间点“，另外一种时间戳标记重复出现的多个时间点。
使用时间点+ 间隔（ 天（d）、周（w）、月（m）或者年（y））来表示。比如：

#+BEGIN_EXAMPLE
     <2007-05-16 Wed 12:30 +1w>
#+END_EXAMPLE

表示从2007-05-16 12:30开始，每周重复一次。

时间戳可以放在标题或正文的任何部分。

输入时间戳时，可以手工输入符合格式的标记，也可以使用快捷键 C-c .
来创建。

如果要快速输入日期无需选择，可以直接用C-c <。

C-c > 可以查看日历。

如果仅仅想输入一个日期/时间，与任务没有任何关系，可以用C-c !。

S-left|S-right 以天为单位调整时间戳时间 S-up|S-down
调整光标所在时间单位；如果光标在时间戳之外，调整时间戳类型（是否在日程表中显示）
S-LEFT/ 将光标处理的时间戳改变一天。 RIGHT
───────────────────────────────────────────────────────────────────────────
S-UP/
改变时间戳中光标下的项。光标可以处在年、月、日、时或者分之上。当时间戳包含一个时间段时，如
“15:30-16:30”，修改第一个时间，会自动同时修改第 DOWN
二个时间，以保持时间段长度不变。想修改时间段长度，可以修改第二个时间。
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

时间/日期段

两个时间戳用‘--'连接起来就定义了一个时间段：

#+BEGIN_EXAMPLE
      <2004-08-23 Mon>--<2004-08-26 Thu>
#+END_EXAMPLE

连续使用C-c . 可以创建时间段

C-c C-y 计算时间段的间隔

**** 计划时间和截止时间

Org-mode可以为任务设定一个计划时间(SCHEDULED), 输入 C-c C-s，就可以设
定光标所在位置所属的任务的计划时间。 而 C-c C-d是输入截止时间（DEADLINE）。

** 97 C

- [ ] PF 与 PF-SLAM sim

*** [[/enjoyyl/article/details/44830519][MATLAB 路径设置]]                                             :path:blog:

**** Matlab的搜索路径

*搜索路径* （search path）或者路径是文件系统中所有文件夹的子集。Matlab
搜索路径来高效的定位文件，且可以访问搜索路径里的任意文件。

搜索路径里文件夹的 *顺序* 很重要。当同名的文件出现在搜索路径上的多个文
件夹时，Matlab使用最靠近搜索路径顶部（top）的文件夹里的那个文件。

Matlab共有两种搜索路径

-  MATLAB提供的文件夹或者其它MathWorks产品
    这些文件夹在 “*matlabroot/toolbox*“下, 使用 =matlabroot=
   可以查看该根目录.

-  MATLAB用户路径（userpath）
    用户路径文件夹是存储那些MATLAB在启动时添加到搜索路径的文件.

你可以把你要运行的文件夹添加到搜索路径. 类, 包, 和私有文件夹不再搜索路径上.

**** MATLAB搜索路径的添加

可以使用MATLAB图形交互界面添加, 也可以使用命令添加.

***** 使用图形用户界面添加搜索路径

对于MATLAB2013及以上版本, 添加搜索路径的按钮在, *Home*
选项卡下的”Environment”下, 即下图中的*Set Path*

 [[http://img.blog.csdn.net/20150402122057683]]

打开*Set Path*对话框, 如下:

 [[http://img.blog.csdn.net/20150402122945257]]

按照下图所示,
可以添加”DeepLearnToolbox-master”文件夹及其子文件夹到搜索路径.
 [[http://img.blog.csdn.net/20150402123107753]]

下图给出了添加后的结果:
 [[http://img.blog.csdn.net/20150402123235406]]

***** 使用命令添加搜索路径

主要使用 =aadpath=, 命令. 下面举例说明几个函数.
假设要添加”D:\Workspace\Matlab\DL\DeepLearnToolbox-master”文件夹及其子文件夹到搜索路径,
其目录结构如下图
 [[http://img.blog.csdn.net/20150402111443417]]

addpath即(Add folders to search path), 完成往搜索路径里添加文件的功能.
使用下面的命令仅仅将”DeepLearnToolbox-master”文件夹添加进搜索路径,
并未添加其子文件夹.

#+BEGIN_EXAMPLE
    addpath('D:\Workspace\Matlab\DL\DeepLearnToolbox-master');
#+END_EXAMPLE

如果想将该路径添加到搜索路径 *后*, 那么可以使用下面的命令

#+BEGIN_EXAMPLE
    addpath('D:\Workspace\Matlab\DL\DeepLearnToolbox-master','-end');
#+END_EXAMPLE

****** 添加绝对路径

如上图所示, “DeepLearnToolbox-master”文件夹的子文件夹较多,
如果一一列举出来相当麻烦. 所以我们使用 =genpath= 自动生成路径, 如下

#+BEGIN_EXAMPLE
    genpath('D:\Workspace\Matlab\DL\DeepLearnToolbox-master')
#+END_EXAMPLE

结果输出:

#+BEGIN_QUOTE
  ans =

  D:\Workspace\Matlab\DL\DeepLearnToolbox-master;D:\Workspace\Matlab\DL\DeepLearnToolbox-master\CAE;D:\Workspace\Matlab\DL\DeepLearnToolbox-master\CNN;D:\Workspace\Matlab\DL\DeepLearnToolbox-master\DBN;D:\Workspace\Matlab\DL\DeepLearnToolbox-master\NN;D:\Workspace\Matlab\DL\DeepLearnToolbox-master\SAE;D:\Workspace\Matlab\DL\DeepLearnToolbox-master\data;D:\Workspace\Matlab\DL\DeepLearnToolbox-master\tests;D:\Workspace\Matlab\DL\DeepLearnToolbox-master\util;
#+END_QUOTE

可以看出, genpath命令生成了
“DeepLearnToolbox-master”文件夹及其子文件夹的所有路径.
 所以将
“DeepLearnToolbox-master”文件夹及其子文件夹添加到搜索路径的命令是:

#+BEGIN_EXAMPLE
    addpath(genpath('D:\Workspace\Matlab\DL\DeepLearnToolbox-master'));
#+END_EXAMPLE

这样, 你就可以在任何地方, 访问”DeepLearnToolbox-master”里的任意资源了,
这就是绝对路径的好处.

****** 添加相对路径

也许你看到了 “DeepLearnToolbox-master”文件夹中的”README.md”文件,
是的这是一个使用说明文件, “DeepLearnToolbox-master”是一个MATLAB版工具箱,
“README.md”文件就是介绍其功能及使用的.
也许你会看到文件”README.md”里说使用下面的命令添加搜索路径.

#+BEGIN_EXAMPLE
    addpath(genpath('DeepLearnToolbox'));
#+END_EXAMPLE

是的, 那么会有什么不同呢? 我们把*当前工作路径切换到”DL”文件夹下* (注意,
之前我们并没有强调, 那是因为不需要, 但现在需要了, 否则,
下面的命令将返回空, 这是因为MATLAB找不到”DeepLearnToolbox-master”文件夹)
, 然后在MATLAB命令窗口输入=genpath('DeepLearnToolbox')=, 发现返回值是:

#+BEGIN_QUOTE
  ans =

  DeepLearnToolbox-master;DeepLearnToolbox-master\CAE;DeepLearnToolbox-master\CNN;DeepLearnToolbox-master\DBN;DeepLearnToolbox-master\NN;DeepLearnToolbox-master\SAE;DeepLearnToolbox-master\data;DeepLearnToolbox-master\tests;DeepLearnToolbox-master\util;
#+END_QUOTE

可以看到路径个数一样, 只是”变短了”. 是的, 这是 *相对路径*
(是相对于”DL”文件夹所在路径而言的, 而之前那个是绝对路径),
所以如果访问和使用”DeepLearnToolbox-master”工具包中的任意资源的话,
要把当前工作路径切换到”DL”文件夹下. 比如,
你想运行”DeepLearnToolbox-master”中”tests”下的测试示例,
那么你需要在把当前工作路径切换到”DL”文件夹下(而不是”tests”文件夹下),
否则, 会找不到调用的其它资源.

**** MATLAB搜索路径的移除

使用MATLAB图形用户界面操作, 很容易移除路径, 这里不介绍.
MATLAB也提供了=rmpath=用于移除搜索路径.下面做一下简介:

***** 移除单个路径

如果仅仅想移除单个路径, 如:”DeepLearnToolbox-master”文件夹.

-  对于*绝对路径*, 那么只需输入下面的命令

#+BEGIN_EXAMPLE
    rmpath('D:\Workspace\Matlab\DL\DeepLearnToolbox-master')
#+END_EXAMPLE

-  对于 *相对路径*, 那么需输入下面的命令, 否则, 提示找不到.

#+BEGIN_EXAMPLE
    rmpath('DeepLearnToolbox-master')
#+END_EXAMPLE

***** 移除多个路径

如果想移除多个搜索路径呢,
如:”DeepLearnToolbox-master”文件夹及其子文件夹, 这里依然借助=genpath=.

-  对于*绝对路径*, 那么只需输入下面的命令

#+BEGIN_EXAMPLE
    rmpath(genpath('D:\Workspace\Matlab\DL\DeepLearnToolbox-master'))
#+END_EXAMPLE

-  对于*相对路径*, 那么需输入下面的命令

#+BEGIN_EXAMPLE
    rmpath(genpath('DeepLearnToolbox-master'))
#+END_EXAMPLE

***** 还有一种方法

修改*pathdef.m*文件！

到你的MATLAB安装目录中依次找到=toolbox -> local -> pathdef.m=文件，如下：
 [[http://img.blog.csdn.net/20160115095621182]]

直接删除你不要的路径即可。

这种方法在下面这种情况下很有帮助：当你打开MATLAB窗口时，命令窗口提示一堆Warning，说某某路径不存在或者不是路径（”*Warning:
Name is nonexistent or not a directory:* “），如下图所示：
 [[http://img.blog.csdn.net/20160115095014761]]

这往往是由于你移动了文件夹或者重命名了文件夹而致（比如我删除了*sd*显著性检测文件夹），而这个时候你打开=Set Path=（=Home -> Set Path=）窗口并没有看到这些路径，是不是很奇怪，其实不奇怪，路径不存在添加进去也没有，所以就不添加了。

解决办法就是修改上述*pathdef.m*文件，打开后，你会发现文件里依然保留着那些不存在的路径，删掉即可；当然也可以把文件夹命名回来，或移动回来。

哈哈，就这些吧！

*** Matlab 引号

Matlab 中的字符和字符串都使用单引号.

**** 字符串中的单引号
**** Matlab字符串单引号处理

Matlab，从一个txt文本文件中提取字符串，发现提取的字符串带单引号，以前
还没有注意这个问题，带了单引号的字符串不能获取长度。

#+BEGIN_EXAMPLE
c = 'th=1.14789,'
#+END_EXAMPLE

字符串定义方式：

没有单引号
#+BEGIN_EXAMPLE
>> a='sdafas'
a =sdafas
#+END_EXAMPLE

带单引号 (*三个单引号*)
#+BEGIN_EXAMPLE
>> a='''sdafas'''
a ='sdafas'
#+END_EXAMPLE

带双引号
#+BEGIN_EXAMPLE
>> a='"sdafas"'
a ="sdafas"
#+END_EXAMPLE

去除单引号
#+BEGIN_EXAMPLE
c = ['th=1.14789,']
u = cellstr(S)
c=char(c)
c =th=1.14789,
#+END_EXAMPLE

后面用字符串处理函数就ok了。

*** [[http://wiki.ros.org/hokuyo3d][ros-indigo-hokuyo3d]]                                          :hokuyo3d:
Released Continuous integration Documented

ROS driver for HOKUYO 3D sensor

-  Maintainer status: developed
-  Maintainer: Atsushi Watanabe <atsushi.w AT atr DOT jp>
-  Author: Atsushi Watanabe <atsushi.w AT atr DOT jp>
-  License: BSD
-  Source: git
   [[https://github.com/at-wat/hokuyo3d][https://github.com/at-wat/hokuyo3d.git]]
   (branch: indigo-devel)

 *EXPERIMENTAL*: This status indicates that this software is
 experimental code at best. There are known issues and missing
 functionality. The APIs are completely unstable and likely to
 change. Use in production systems is not recommended. All code starts
 at this level. For more information see the ROS-Industrial software
 status [[/Industrial/Software_Status][page]].

**** Supported Hardware

This driver should work with *VSSP 1.0/1.1-compliant HOKUYO 3D-LIDARs.*

**** ROS API

***** hokuyo3d

=hokuyo3d= is a driver for VSSP 1.0/1.1 (Volumetric Scanning Sensor
Protocol) compliant Hokuyo 3D LIDARs.

****** Published Topics

=~/hokuyo_cloud=
([[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]])

-  Output of measured point cloud in [[/PointCloud][PointCloud]] message
   type which contains all multi echos with intensity. Published on
   demand.

=~/hokuyo_cloud2=
([[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud2.html][sensor_msgs/PointCloud2]])

-  Output of measured point cloud in [[/PointCloud2][PointCloud2]]
   message type which contains all multi echos with intensity. Published
   on demand.

=~/imu=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Imu.html][sensor_msgs/Imu]])

-  Output of embedded 6D gyro and accelerometer data.

=~/mag=
([[http://docs.ros.org/api/sensor_msgs/html/msg/MagneticField.html][sensor_msgs/MagneticField]])

-  Output of embedded 3D magnetic field vector.

****** Parameters

=~ip= (=string=, default: "192.168.0.10")

-  IP address of the sensor.

=~port= (=int=, default: 10940)

-  TCP Port of the sensor.

=~interlace= (=int=, default: 4)

-  Interlace setting of laser scanning. One means no interlace.

=~frame_id= (=string=, default: "hokuyo3d")

-  The TF frame ID in which point clouds will be returned.

=~range_min= (=float=, default: 0.0)

-  Points within range_min are dropped. This parameter is useful to
   remove ghost points nearby for early development version of this 3D
   sensors.

=~output_cycle= (=string=, default: "field")

-  Specifies timing of point cloud output. "frame": outputs for each
   interlace cycle (several fields), "field": one horizontal scan (tens
   of lines), "line": one vertical scan

** 96 D
*** NAT                                        :nat:网络地址转换:公网:内网:

在计算机网络中， *网络地址转换* （英语：Network Address Translation，缩写
为NAT），也叫做网络掩蔽或者IP掩蔽（IP masquerading），是一种在IP封包通
过路由器或防火墙时重写源IP地址或目的IP地址的技术。这种技术被普遍使用在
*有多台主机但只通过一个公有IP地址访问因特网的私有网络中* 。

NAT 是作为一种解决IPv4地址短缺以避免保留IP地址困难的方案而流行起来的。
网络地址转换在很多国家都有很广泛的使用。

公网、内网是两种Internet的接入方式。

内网接入方式：上网的计算机得到的IP地址是Inetnet上的保留地址，保留地址有如下3种形式：
+ 10.x.x.x
+ 172.16.x.x至172.31.x.x
+ 192.168.x.x

_内网的计算机以NAT（网络地址转换）协议，通过一个公共的网关访问Internet。_

=内网的计算机可向Internet上的其他计算机发送连接请求，但Internet上其他
的计算机无法向内网的计算机发送连接请求。=

公网接入方式：上网的计算机得到的IP地址是Inetnet上的非保留地址。公网的
计算机和Internet上的其他计算机可随意互相访问。

NAT（Network Address Translator）是网络地址转换，它实现内网的IP地址与
公网的地址之间的相互转换，将大量的内网IP地址转换为一个或少量的公网IP地
址，减少对公网IP地址的占用。NAT的最典型应用是：在一个局域网内，只需要
一台计算机连接上Internet，就可以利用NAT共享Internet连接，使局域网内其
他计算机也可以上网。使用NAT协议，局域网内的计算机可以访问Internet上的
计算机，但Internet上的计算机无法访问局域网内的计算机。

*** NEXT XX-net                                    :xxnet:翻墙:switchomega:
:LOGBOOK:
- State "NEXT"       from ""           [2016-03-03 四 12:09] \\
  掌握了基本使用，接下来需要配置 appid （否则看视频受限制），但不急
:END:

**** Reference
- [[https://github.com/XX-net/XX-Net][GitHub]]
- [[https://github.com/XX-net/XX-Net/wiki/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3][Document]]
- [[https://github.com/FelisCatus/SwitchyOmega][GitHub:SwitchOmega]]

**** 缘由

购买的 VPN 失效，非常影响学习工作，烦心。

使用 Google 镜像，功能有限，而且慢、不稳定。

*** Voronoi                          :voronoi:voro:维诺图:泰森多边形

**** Reference

- [[http://emuch.net/html/201207/4675940.html][小木虫]]
- [[http://www.in.tum.de/fileadmin/user_upload/Lehrstuehle/Lehrstuhl_XV/Teaching/Applets/applets/vis/voronoi/Fortune.html]]
- [[http://mathworld.wolfram.com/VoronoiDiagram.html][mathworld]]

**** [[http://www.cnblogs.com/Seiyagoo/p/3339886.html][Voronoi Diagram--维诺图]]

***** Voronoi图定义

任意两点p 和q 之间的欧氏距离，记作 dist(p, q) 。就平面情况而言，我们有

#+BEGIN_EXAMPLE
dist(p, q) = (px-qx)2+ (py-qy)2
#+END_EXAMPLE

设P := {p1, ..., pn}为平面上任意 n个互异的点；这些点也就是基点。按照我
们的定义，所谓P对应的Voronoi图，就是平面的一个子区域划分------整个平面
因此被划分为n个单元（cell ），它们具有这样的性质：

任一点q位于点pi 所对应的单元中，当且仅当对于任何的pj∈Pj,
j≠i,都有dist(q, pi)<dist(q, pj)。我们将与P对应的Voronoi图记作Vor(P)。

“Vor(P)
”或者“Voronoi图”所指示的仅仅只是组成该子区域划分的边和顶点。在Vor(P)中，与基点pi
相对应的单元记作V (pi)------称作与pi 相对应的Voronoi单元（Voronoi
cell）。上图是Voronoi图，下图的蓝色点围成的区域（凸包）是它对应的
Delaunay三角剖分。


#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/26154830-6aa16b0c2d834d3f831e91ee01199471.jpg @ 2016-03-03 14:53:05
 [[~/Wally/Journal/Figure/.org-download/Journal/26154830-6aa16b0c2d834d3f831e91ee01199471_2016-03-03_14:53:05.jpg]]

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/26154809-262b7630cca4415a9e841953a302243b.jpg @ 2016-03-03 14:52:28
 [[~/Wally/Journal/Figure/.org-download/Journal/26154809-262b7630cca4415a9e841953a302243b_2016-03-03_14:52:28.jpg]]

任给平面上两点p 和q ，所谓 p 和q 的平分线（bisector），就是线段
pq的垂直平分线。该平分线将平面划分为两张半平面（half-plane）。点 p
所在的那张开半平面记作 h(p, q) ，点 q 所在的那张开半平面记作 h(q, p)
。请注意，r ∈ h(p, q) 当且仅当 dist(r, p) < dist(r, q)
。据此，可以得出如下观察结论：

  V (pi) = ∩h(pi, pj) ,1≤j≤n, j≠ i

也就是说，V
(pi)是(n-1)张半平面的公共交集；它也是一个（不见得有界的）开的凸多边形（convex
polygon）子区域.

很显然，Voronoi顶点到相邻的三个site距离相等；Voronoi边上任意一点到相邻
的两个site距离相等；

对于任何点q，我们将以q为中心、内部不含P中任何基点的最大圆，称作q关于P的最大空圆（largestempty
circle ），记作Cp(q)。以下定理指出了Voronoi图的顶点及边所具有的特征：

对于任一点集P 所对应的Voronoi图Vor(P) ，下列命题成立：\\
1) 点q 是Vor(P)
的一个顶点，当且仅当在其最大空圆Cp(q)的边界上，至少有三个基点；
(Voronoi顶点是三个site的外接圆的圆心)\\
2) pi 和pj 之间的平分线确定了Vor (P)
的一条边，当且仅当在这条线上存在一个点 q，Cp(q)的边界经过pi
和pj，但不经过其它站点。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225148-43427baf0b2a43fcb83eaf32ea407433.jpg @ 2016-03-03 14:53:54
 [[~/Wally/Journal/Figure/.org-download/Journal/25225148-43427baf0b2a43fcb83eaf32ea407433_2016-03-03_14:53:54.jpg]]

***** 构造Voronoi图

构造Voronoi图有四种算法：定义法（Intersect of
Halfplanes）、增量（incremental）算法、分治法、plane sweep算法；

1、plane sweep（平面扫描）算法又名Fortune算法，它主要由两部分组成：sweep
line（扫描线）和beach line（海滩线）；

Fortune算法建立在点、线之间的距离关系上，如下图所示，平面上任意一点到一个点p的距离与到一条直线l的距离相等，这样的点有很多，它们构成的轨迹就是抛物线，点p就是抛物线的焦点，直线l就是抛物线的准线；

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225203-a4d8601e3b484f5a9c8f8f4c7c926506.jpg @ 2016-03-03 14:54:11
 [[~/Wally/Journal/Figure/.org-download/Journal/25225203-a4d8601e3b484f5a9c8f8f4c7c926506_2016-03-03_14:54:11.jpg]]

2、回到Fortune算法，这个固定点p就是一个site，l就是sweep line；

sweep line自上而下扫描，平面区域任何点到site与sweep
line距离相等的点构成一条抛物线（site就是抛物线的焦点），则n个site的抛物线相交的若干段抛物线弧构成beach
line，如下图的蓝色抛物线弧集合；

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225218-1f755c87f04b4970a86c99a85d03df4d.jpg @ 2016-03-03 14:54:40
 [[~/Wally/Journal/Figure/.org-download/Journal/25225218-1f755c87f04b4970a86c99a85d03df4d_2016-03-03_14:54:40.jpg]]

抛物线之间的交点称为断点（break point），每个断点都落在某条Voronoi
边上。这并非巧合，随着扫描线自上而下扫过整个平面，所有断点的轨迹合起来恰好就是待构造的Voronoi图；（几何证明：断点到相邻的两个site距离总是相等，这个关系随着sweep
line的扫描一直不变，则断点的运动轨迹就是这两个site的垂直平分线，也即Voronoi
边，两条Voronoi 边相交又产生Voronoi 顶点）

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225242-cbcc75751eff45898334f2f3aea5525c.jpg @ 2016-03-03 14:55:01
 [[~/Wally/Journal/Figure/.org-download/Journal/25225242-cbcc75751eff45898334f2f3aea5525c_2016-03-03_14:55:01.jpg]]

beach line上方的Voronoi 顶点和Voronoi 边已确定，将不会再变化。beach
line（曲线）和它上方的直线构成当前的Voronoi 边，最后随着sweep
line的移动而beach line也在不断下移，变为最终的Voronoi 边； （海滩线沿x
方向单调------即，它与任一垂线相交而且仅相交于一点。）



beach line属性

1、随着sweep line下降，break points跟踪Voronoi边；一个新的break
point（新弧形成或者两个break point融合为一体）产生一条新的边；

2、两个break point相遇产生voronoi顶点

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225309-40f6b465a6b2453d91c60b805818ae38.jpg @ 2016-03-03 14:55:32
 [[~/Wally/Journal/Figure/.org-download/Journal/25225309-40f6b465a6b2453d91c60b805818ae38_2016-03-03_14:55:32.jpg]]



3、为了确定Voronoi 边和Voronoi 顶点，我们需要维护beach
line这个结构，但是随着l
的运动它会持续不断地更新。那么，应该如何表示beach line结构呢？

所谓beach
line的组合结构发生变化，指的是其上出现了新的抛物线弧，或原有的某段抛物线弧收缩成一个点并进而消失。在这个算法中，产生新弧，称为site
event；旧弧消失，称为circle event。



两类事件site event和circle event：

1）、site event

sweep
line扫到某个site，设为p，在此瞬间，站点p对应于一条宽度为零的退化抛物线------亦即，将该新站点p与扫描线l联接起来的垂直线段。随着扫描线继续下移，这个宽度为0的抛物线将逐渐伸展开来。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225355-4711d3791a6c4cdc8bdae5bc738cbf82.jpg @ 2016-03-03 14:55:39
 [[~/Wally/Journal/Figure/.org-download/Journal/25225355-4711d3791a6c4cdc8bdae5bc738cbf82_2016-03-03_14:55:39.jpg]]

site
event发生后引起的变化：因为沿海滩线上各个断点的运动轨迹，就勾勒出了Voronoi
图的各边。所以每发生一次site事件，就会生成两个新的断点，此后它们会逐渐地勾勒出同一条新边。

那为什么是同一条新边呢？实际上，在刚刚诞生的那一瞬间，这两个断点相互重合，然后才会各自朝相反的方向运动，而且它们所勾勒的都是同一条边（同break
point定义处的几何证明）。在一开始，这条边与Voronoi图位于扫描线之上的其它部分并不相联。随着这条边的不断生长，直到后来它们与其它边相遇，此时它才会与Voronoi图的其它部分联接起来。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225413-3220930b83d345a4bfa8475ae4653b77.jpg @ 2016-03-03 14:55:44
 [[~/Wally/Journal/Figure/.org-download/Journal/25225413-3220930b83d345a4bfa8475ae4653b77_2016-03-03_14:55:44.jpg]]

定理：只有在发生某个site事件时，海滩线上才会有新的弧出现。



2）、circle event

发生于原有的某段弧收缩为一点并即将消失时，假设三段连续的弧α 、α '和α
''，这三段弧必然分别对应于三个不同基点pi 、pj和pk
，就在α'即将消失的那一刻，这三个基点所对应的抛物线将相交于同一点q
。此时点q 到扫描线l 与到这三个基点等距离。亦即，存在一个以q
为中心、穿过pi、pj和pk 的圆，且该圆在最低点处与l
相切。该圆的内部不可能有任何基点------否则，q 到该基点将比到l
更近，而这却与“q 位于海滩线上”的事实不合。因此，点q
必是Voronoi图的一个顶点。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225426-f631bdb745e541b1bd6559a78da57640.jpg @ 2016-03-03 14:55:51
 [[~/Wally/Journal/Figure/.org-download/Journal/25225426-f631bdb745e541b1bd6559a78da57640_2016-03-03_14:55:51.jpg]]



若海滩线上有某段弧消失，并因而有两段弧汇合起来，则相应地在Voronoi图中肯定也会有两条边汇合起来（成为一条新的边）。海滩线上依次首尾相联的任何三段弧，其对应的三个基点都会确定一个外接圆；当扫描线触及某个这类外接圆的最低点时，也就发生了一次圆事件（circle
event ）

定理：海滩线上已有的弧，只有在经过某次圆事件之后，才有可能消失。



简单点说，site event发生时，beach
line会产生一条新弧，同时就会有一条新边出现并朝两端生长，慢慢形成新的Voronoi边；circle
event发生时，会有两条正在生长的Voronoi边汇合起来，并在接合处形成一个Voronoi
顶点，同时中间的旧弧消失。



4、异常情况

a false alarm：We may have stored a circle event in the event list, but
it maybe that it never happens

There are two reasons for false alarms: site events and othercircle
events

我们存储了circle event，但它可能永远不会发生，真是一个美丽的错误...
在site event和circle event发生时，都会有可能误报情况。



1）、site event：circle event发生时产生的最大空心圆内部还有其他site。

如下面三个图例，p2、p3、p4组成的外接圆，确定了一个circle
event，外接圆y坐标最小的点（图中最低的小红点）将进入PQ，但是在sweep
line碰到它之前，先扫描到了site
p7，这样一来将产生新弧，破坏了原来的<p2,p3,p4>三元组。发生circle
event时，并不知道这是一个false
alarm，所以直到碰到该外接圆内部存在site。这时需要把这个circle
event去掉，也即删除原先进入PQ中的最低点。也说明了这个外接圆的圆心不是Voronoi顶点，属于误报。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225451-7d94d8afc8444cbea2fea6ed2b107079.jpg @ 2016-03-03 14:56:02
 [[~/Wally/Journal/Figure/.org-download/Journal/25225451-7d94d8afc8444cbea2fea6ed2b107079_2016-03-03_14:56:01.jpg]]

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225504-7fcdd7ef130446a59dee1c0e5e2b675c.jpg @ 2016-03-03 14:56:12
 [[~/Wally/Journal/Figure/.org-download/Journal/25225504-7fcdd7ef130446a59dee1c0e5e2b675c_2016-03-03_14:56:12.jpg]]

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225521-e7d1f4e99092443c82a8fae5ec9c4133.jpg @ 2016-03-03 14:56:14
 [[~/Wally/Journal/Figure/.org-download/Journal/25225521-e7d1f4e99092443c82a8fae5ec9c4133_2016-03-03_14:56:14.jpg]]



2）、circle
event：该事件还没有来得及真正发生，这一邻接弧三元组就已经消失了。

如下面三个图例，<p2,p3,p4>三元组先产生外接圆，第一个小红点进入PQ，当sweep
line扫描到p1时，<p1,p2,p3>三元组也产生外接圆，第二个小红点进入PQ；但是，当sweep
line扫描到第一个小红点时，它从PQ出队，随着sweep
line下移，α3消失，<α2,α3,α4>合并为<α2,α4>破坏了原来的三元组，则<p1,p2,p3>无法形成Voronoi顶点，也即这个circle
event属于误报。需要删除PQ中第二个小红点。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225609-6fe127e007194bf481cd59f1835d9188.jpg @ 2016-03-03 14:56:15
 [[~/Wally/Journal/Figure/.org-download/Journal/25225609-6fe127e007194bf481cd59f1835d9188_2016-03-03_14:56:15.jpg]]

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225616-604e0450623e4ba9aa70dd9911404f00.jpg @ 2016-03-03 14:56:15
 [[~/Wally/Journal/Figure/.org-download/Journal/25225616-604e0450623e4ba9aa70dd9911404f00_2016-03-03_14:56:15.jpg]]

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225624-1ca29f44f06d4396996ab5e72adcbf59.jpg @ 2016-03-03 14:56:16
 [[~/Wally/Journal/Figure/.org-download/Journal/25225624-1ca29f44f06d4396996ab5e72adcbf59_2016-03-03_14:56:16.jpg]]

图像说明： bayanbox.ir/id/3367913281004602743?download


[[http://www.cise.ufl.edu/~sitharam/COURSES/CG/kreveldmorevoronoi.pdf]]

***** 相关数据结构

构建Voronoi图需要三个数据结构，分别是平衡二叉树AVL，优先队列PQ和双向边链表DCEL。

1、beach line数据结构AVL：记录beach line的状态，包括break points, and
the arcs currently on beach line

一个叶子结点表示一段弧，因为每个弧都一 一对应一个site，所以用site
number来存储；

非叶子结点则表示两条弧的交点即断点，用两条弧对应的site对存储；因为弧和断点都是不断变化的，所以都用固定的site
number来表示。



此例中AVL中的p1、p2表示原图的site p1和site
p2对应的弧，<p1,p2>表示两弧的交点即断点，其实AVL树就是site和break
point的中序遍历。



若按照这样的方式来表示beach
line，每遇到一个新的site，都可以在O(logn)时间内，沿beach
line找出位于该site上方的那段弧：在查找过程中，在每个内部节点处，只要将其对应断点的x坐标，与新site的x坐标做一比较。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225712-6b8ca04d1a57468291eca243c8f1437b.jpg @ 2016-03-03 14:56:52
 [[~/Wally/Journal/Figure/.org-download/Journal/25225712-6b8ca04d1a57468291eca243c8f1437b_2016-03-03_14:56:52.jpg]]



为了处理false alarm的第二种情况，T
的一片叶子若对应于某段弧α，则为它配备一个指针，指向PQ中的一个（事件）节点------具体说，就是（在将来可能）导致α
消失的那个圆事件所对应的节点。若没有导致α消失的圆事件，或者还没有发现这样一个事件，则该指针被置为nil。



最后，每个内部节点v 也配有一个指针，指向与当前Voronoi
图对应的双向链接边表DCEL中的某条半边（half-edge
）------更确切地说，此时与 v 相对应的断点，正在勾勒出的一条
Voronoi边，而v 的指针就指向这条边所对应的那条半边。



处理：新的site产生一条新弧，对应的旧弧被删除（DS中对应AVL某叶子节点被删除）；同时，该旧弧指向的event也将被删除（DS对应PQ中删除一个元素）；



添加弧操作：replacing the leaf with a sub-tree

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225724-384b5b4223d641928e32265811556e7f.jpg @ 2016-03-03 14:56:53
 [[~/Wally/Journal/Figure/.org-download/Journal/25225724-384b5b4223d641928e32265811556e7f_2016-03-03_14:56:53.jpg]]



删除弧操作：deleting a leaf from the tree

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225733-cb04d0d5bf2a4b49afb52d64c88b9c1b.jpg @ 2016-03-03 14:56:54
 [[~/Wally/Journal/Figure/.org-download/Journal/25225733-cb04d0d5bf2a4b49afb52d64c88b9c1b_2016-03-03_14:56:54.jpg]]





2、事件队列PQ：Event queue（on decreasing y-coordinate）

记录扫描线当前状态的结构。存储已确定即将发生的events。对于site
event，在sweep line开始扫描之前就可以全部送入PQ；

对于circle event,不仅要记录该外接圆的最低点（外接圆与sweep
line的切点），还要设置一个指针指向AVL中的某片叶子------这片叶子所对应的，就是在该事件发生时即将随之消失的那段弧。



如果某三个site形成的外接圆，该圆对应的纵坐标最小的点（即未来的切点）在sweep
line的下面，则为circle
event；并将该点入优先队列；并且这三个连续的sites与该切点互相链接对方。对于false
alarm的第一种情况还需处理。



处理：sweep
line扫描到切点，三条弧变成两条弧，形成Voronoi顶点；删除三条弧中间的那条，对应DS则为删除叶子节点，并在PQ中删除该节点指向的event（若有，即为一个false
alarm），同时将合并后的两条弧分别与原先三条弧的左右两侧各一条弧结合，形成两个新的三元组，将两新三元组对应的两切点加入PQ，并做指针链接；





3、双向边链表（DCEL）：记录Voronoi状态，包含half-edges,
edges（一对half-edge）, vertices and cellrecords（A chain of
counter-clockwisehalf-edges）



At the leaves of the tree, a pointer to the circle event is stored, if
the arc defines a circle event. If not, pointer is set to NULL. By
maintaining this pointer, we do not have to perform any search after
encountering false events.

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225746-8cf044f7bf7a43459f82c7d15aeea0b2.jpg @ 2016-03-03 14:56:55
 [[~/Wally/Journal/Figure/.org-download/Journal/25225746-8cf044f7bf7a43459f82c7d15aeea0b2_2016-03-03_14:56:55.jpg]]







***** 算法伪码



算法 VORONOID IAGRAM (P)\\
 输入：平面点集 P := {p1, ..., pn)\\
 输出：以双向链接边表 D 表示的（限制在一个足够大的包围框之内的）Voronoi
图Vor(P)\\
 1.初始化事件队列Q ：将所有的基点事件插入其中\\
  初始化状态结构T ：将其置空\\
  初始化双向链接边表D ：将其置空\\
 2. while ( Q 非空)\\
 3. do 将y- 坐标最大的事件从 Q 中取出\\
 4. if ( 这是一个发生于基点 pi 处的基点事件)\\
 5. then HANDLESITE EVENT(pi)\\
 6. else HANDLECIRCLE EVENT(γ)\\
  (* 这里的γ是T 的一匹叶子，它对应于那段即将消失的弧 *)\\
 7.(* 仍然存在于 T 中的那些内部节点，对应于 Voronoi 图的单向无穷边 *)\\
  计算出一个包围框，其尺寸之大，应足以容下Voronoi 图中的所有顶点\\
  通过对双向链接边表的适当调整，将这些单向无穷边都联接到这个包围框上\\
 8.遍历双向链接边表中的所有半边增加相应的单元记录\\
 设置好指向这些单元的指针，以及由这些单元发出的（指向对应各边的）指针



处理两类事件的子程序分别如下：\\
 算法 HANDLESITE EVENT(pi)

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225758-7c1139b0d8da4c58af2da4a57cdf1d54.jpg @ 2016-03-03 14:56:56
 [[~/Wally/Journal/Figure/.org-download/Journal/25225758-7c1139b0d8da4c58af2da4a57cdf1d54_2016-03-03_14:56:56.jpg]]



算法 HANDLECIRCLE EVENT(γ)\\
1.将（对应于即将消失的弧α的那匹）叶子γ，从T 删除掉\\
 检查相关的内部节点，更新其中表示有关断点的基点对信息\\
 若有必要，须对T 做调整，以使之重新平衡\\
 在Q 中，删除所有与α相关的圆事件\\
 (* 在T 中，γ的前驱与后继节点配有相应的指针 *)\\
 (* 借助这些指针，就可以找出这些事件 *)\\
 （α在其中居中的那个圆事件，此刻正在接受处理，并已经从Q 被删除掉了）\\
2. 更新存储当前Voronoi图的双向链接边表D ：\\

对应于该事件的圆心生成一个Voronoi顶点记录，并将该记录插入双向链接边表；\\

对应于海滩线上新生出的断点,并生成两个半边记录，正确地设置好它们相互之间的指针；\\
 将这三个新记录，与同样终止于该Voronoi顶点的其它半边链接起来\\
3. (* 此前与α紧邻于左侧的那段弧，现可能在某个新的邻接弧三元组中居中
*)\\
 检查该邻接弧三元组所对应的两个断点是否汇合为一点\\
 果真如此，则\\
 将对应的圆事件插入到事件队列Q 中，并\\
 在Q 中该节点和 T 中与之对应的节点之间设置指针，使它们相互指向对方\\
 (* 此前与α紧邻于右侧的那段弧，现也可能在某个新的邻接弧三元组中居中
*)\\
 对该弧，做类似的处理。

***** 算法复杂度



给定由平面上任意n 个基点构成的一个集合，其对应的
Voronoi图可以采用扫描线算法，在
O(nlogn)时间内、使用O(n)空间构造出来。因为Voronoi图可以归约为n个实数的排序问题，则最好时间复杂度为O(nlogn)，即sweep
line算法是最优的。

定义法：O(n\^2logn)，增量算法：O(n\^2)，分治法：O(nlogn)，sweep
line算法：O(nlogn)。

***** 参考

sweep line作者主页：[[http://ect.bell-labs.com/who/sjf/]]

数据结构说明：[[http://www.cescg.org/CESCG99/RCuk/]]

可视化界面演示：

[[http://www.in.tum.de/fileadmin/user_upload/Lehrstuehle/Lehrstuhl_XV/Teaching/Applets/applets/vis/voronoi/Fortune.html]]

*** 在 word 中使用 LaTeX 公式                                    :word:latex:
**** [[https://www.zhihu.com/question/20541531][LaTeX vs Word : 所谓优雅，唯技熟尔（知乎）]]

神圣的战争有几种：Emacs vs. Vim，LaTeX vs. Word， CLI vs. GUI。

不过对于我来说，这几种战争都跟我没关系，尤其是LaTeX和Word，我都用。

LaTeX和Word完全不是一个类型的排版工具，但是目的一样：*排版*。

LaTeX是仿照Scribe语言（见
[[//link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Scribe_%2528markup_language%2529][http://en.wikipedia.org/wiki/Scribe\_%28markup\_language%29// ]]）而进行
设计的，而Word在最早的时候是字处理软件，实现的只有基本的一些排版功能，
后来才越做越庞大的。

*所谓优雅，唯技熟尔。* 实际上不熟练LaTeX排出来的数学公式也会很难看的，
而熟悉Word的也可以把Word文档做的不输LaTeX生成的。我自己就伪造像LaTeX生
成的Word文档，当然我最终生成pdf了，这是个值得炫耀的showcase。Word和
LaTeX在大部分的功能上旗鼓相当，只有少部分差距较大。

每当我打开一个Word窗口的时候，我都会在心中吼一句：“又是一个全新的挑
战！”

在我的眼里，这两个工具对于我自己来说，命令行的LaTeX和WYSIWYG的Word的差
异已经不是那么重要了。我的答案没有图。

这里开始介绍Word和LaTeX的一些相同点，重点嘛，在Word上面，顺带介绍一些
TeX的基本命令：

-  文档处理速度。Word在处理文档的时候，小文档可以快速打开，大文档呢，
  含有大量图或者文本的文档处理就相当慢了，有时候会打不开。LaTeX本身不
  是直接预览的，所以大小文档都是一个样，编译速度稳定。这个时候，需要将
  Word文档分割成小文档，见
  [[//link.zhihu.com/?target=http%3A//office.microsoft.com/zh-cn/word-help/combine-or-split-subdocuments-HP005186930.aspx][http://office.microsoft.com/zh-cn/word-help/combine-or-split-subdocuments-HP005186930.aspx]]
  。 而LaTeX呢，用\input或者\include来做是最常用的办法。

-  页面布局：文字方向。Word支持几种方向：水平，垂直，旋转90度，旋转270
  度，对汉字旋转270度。在加上对bidirection的支持，能够实现很多方向。而
  这一点对于一般的排版也就足够了。过时的Omega/Aleph引擎可以支持32种方
  向，不过太多了，Word没必要全部实现。日本的pTeX/e(u)pTeX/upTeX呢，支
  持三种方向：bidirection的支持，\yoto（横），\tate（纵）和\dtou（直排，
  方向向上）。LuaTeX支持四种书写方式：TLT（水平左到右），TRT（水平右到
  左），RTT（垂直上到下，水平右到左）和LTL（垂直上到下，水平左到右）。
  pdfTeX和XeTeX的方向支持：bidirection的支持，水平方向。综合考评，Word
  的文字方向还是够用的，虽然不如Omega这种变态的TeX引擎那么多。*值得说
  的一点*是：Word的中在多方向排版中，对西文和汉字的基线对齐方式是采取
  的方式不如LaTeX便捷，有些字体即使基线对齐字体看着也不是对齐的，LaTeX
  可以很好地指定baseline shift。

-  页面布局：页边距，纸张方向，纸张大小。在Word中对于这几项的设定，很
  容易，看着示意图来进行调整。LaTeX下面对于这些的设定，大多可以使用梅
  木秀雄的geometry包进行调整，而对于KOMA-Script和memoir等专业文档类，
  这些文档类内建了相应的接口。而在TeX底层，调节这些尺寸的命令为：
  \hoffset，\voffset，\vsize，\topskip，\pagegoal，\pagedepth，
  \pageshrink，\pagestretch和\maxdepth。这些TeX命令不仅有不可变化的尺
  寸，如\hoffset，同样也有\pageshrink这样可以变化的尺寸。这些命令保证
  了TeX页面输出的质量。

-  页面布局：水印，页面颜色，页面边框。这几项在Word中设定简单。在LaTeX
  中，这些都需使用第三方宏包来实现，即watermark（水印），pagecolor（页
  面颜色），fancybox（页面边框）。其实这些功能算是花边功能，我自己用的
  不是很多。

-  字体：Bold，Italic，Underline。这几个，Word做的都很直接，尤其是
  Underline这一项比LaTeX下面的uline包等要省事很多。先说说Word的，这几
  项对于西文字体没话说，前两项对于成套的西文字体会自动选择Bold和Italic
  对应的字体，但是对于中文字体来说，这两项被乱用了，中文字体成套的都价
  格不菲，很多人在Win下或者Mac下都使用本地的几个字体，这些字体很少成套，
  这就造成一个问题，你点击Bold或者Italic他不会切换到相应字体，而是采取
  了伪粗和伪Italic的形式，这就难看了，除非必要，请不要乱用这两个按钮。

-  字体：kerning，OpenType。kerning在TeX中是使用\kern来实现的，当你输
  入\LaTeX这个命令的时候，大写字母E与T以及X之间就是有kerning的，更高级
  的设定可以使用microtype包。Word呢，哪有那么二啊，当然有kerning，鼠标
  右击“字体->高级”就能看到了。对于OpenType，也出现在字体的高级选项中，
  支持ligature和相应的数字样式。我猜测一些语言支持的选项自动被使用了，
  比如我在测试部分藏文的时候，正常显示。在现行的TeX引擎中，pdfTeX不支
  持OpenType，需要转换，XeTeX内建了一个支持OpenType的库，而LuaTeX则使
  用fontforge进行字体处理。不过TeX引擎里面的库基本上是开源的，对于某些
  特殊语言的支持不足，我在测试藏文的就发现部分显示不正常（日本学者指出
  大约有30处毛病），同时这些库也导致了XeTeX/LuaTeX程序显得有些臃肿。微
  软的Uniscribe库很稳定，我觉得设计一个调用这个库的引擎会有很好的效果。
  OpenType是解决已知语言排版的一个很好的工具，但是对于一些比较复杂的，
  比如古希腊语以及一些冷门语言，OpenType不是终极解决之道。这些冷门语言
  在TeX/LaTeX中的处理简单许多，日本的文科学者作了很足的功夫（见
  [[//link.zhihu.com/?target=http%3A//www2.tba.t-com.ne.jp/ing/language.html][http://www2.tba.t-com.ne.jp/ing/language.html//]]）。 还有一些西方学者
  用LaTeX来排梵文/巴利文文献。这类冷门的语言，还是珍爱生命，远离Word吧。

-  字体：尺寸。Word对于一个给定的字体可以指定一个尺寸，但是，大小必须
  介于0pt--1584pt之间。而TeX现在的设计，是0pt--2048pt之间。就实用性来
  说，而这这个区别不大。一个值得说的是MM（Multi   Master）字体，这种字
  体有点TrueType Collection，内含不同磅重的字体。好像Word不支持，在
  XeTeX/LuaTeX下面支持良好。这个字体在使用的时候，设定不同的字体尺寸会
  指定到不同磅重的字体上面去。

-  字体：简转繁，繁转简。Word中对应的转换应该是内建的，因为很多字体都
  没有trad和smpl这两个feature，如果是OpenType字体，Word直接调用这两个
  feature来转换会省事些。LaTeX中，可以直接调用这两个feature来进行处理。
  如果实在不行，可以写给perl脚本进行预处理嘛。

-  引用：交叉引用。Word下面的引用工作需要做很多，幸好有个好的GUI进行呈
  现，进行交叉引用不那么麻烦。而LaTeX下面就是基本功能了，不过LaTeX下面
  的引用，除了用来对付文献之外，还可以对付whatsits，这些就属于比较hack
  的东西了，比如，判断一个确定的公式是否在某一页。

-  引用：目录。Word的目录制作，感觉和LaTeX方式一致，就是标记section，
  标记subsection，标记subsubsection等等等。Word需要在一篇文档的相关操
  作的最后进行目录的操作，而LaTeX呢，在你输入\section等命令的时候就可
  以了，再设定一下\tableofcontentsd的位置就可以坐享其成了，LaTeX更新目
  录需要生成两次。

-  邮件合并。Word里面的邮件合并在初学的时候需要操作几次才能够掌握。
  LaTeX下面直接写一个迭代就可以了。说个稍微有意思的东西，在网络编程里
  面写一个接口调用LaTeX来生成一些pdf版本的邮件不是很麻烦的。数据批处理，
  除了用那些pdf库外，用LaTeX也是个好办法，首先是格式可以保证，其次可以
  处理一些汉字字体不能显示的问题，经济。

-  审阅。Word的审阅和pdf的审阅很相似，而这都很直观。这一点，LaTeX本身
  得生成pdf才能做到，也就是说LaTeX源码纯文字的做审阅几乎不可能。一个曲
  线的办法是，使用svn或者git之类的管理工具。

-  段落：首字下沉。这个在Word中调节是很直观的。但是我个人觉得这个用到
  中文中也勉强可以，但是字体不能那么死板。LaTeX下面使用lettrine包就可
  以了，这个包的文档给的示例还是很好看的。再强调一遍，*中文状态下请慎
  用*。

-  段落：river。这个涉及到Word对英文词的断词算法，说实话，没TeX高明。
  LaTeX下可以控制断词来产生river，一些出版社有意使用这种形式。LaTeX下
  不控制就默认对的齐齐的。另外，对于断词算法，还有过一些扩展，比如针对
  一些德语旧书里面的，不是断词而是控制字母之间的距离的扩展。这些扩展在
  现在的TeX中不是很常见。

-  段落：断行禁则，孤行控制。Word的断行禁则可以自己进行设置，指定标点
  神马的。但是标点压缩未见得很好玩，我记得Word下面的一些日文禁则倒是有，
  但是标点压缩很糟糕，导致不能符合JIS标准。在LaTeX下，CCT、CJK和xeCJK
  的标点压缩都是使用宏来实现的，pTeX系列是使用jfm来实现的，LuaTeX-ja是
  使用lua脚本实现的。而禁则的实现，是使用了TeX中的相关penalty。孤行控
  制不用多说了吧，避免单字成行，也是使用了penalty。

-  页眉，页码，页脚。这几项，Word直接插入，但是样式简单单一。而LaTeX需
  要繁琐地指定一些高度。但是从效果上来看，LaTeX可选的样式太多了。页眉
  页脚在LaTeX下面的定制需要使用fancyhdr，如果是KOMA-Script，有内建选项。

-  超链接，书签。Word实现的超链接还OK，但是和pdf中变化多端的超链接来比
  较，是在没有多少出彩之处。LaTeX依靠的是pdf这颗大树。在LaTeX下实现超
  链接和书签，直接使用hyperref就行了。

-  表格。表格这个东西还是Word比较好用，有一次我就用LaTeX连续敲&敲到手
  抽筋。TeX有一个排表格算法，在命令上，可以使用\halign和\valign等命令
  制作表格。LaTeX中制作表格是比较上层的命令，包很多，tabu，tabularx，
  booktabs等。

-  数学排版。可能这是争议比较大的地方，现在的情况是，Word和TeX互相影响
  （我不清楚是否和Lamport在微软有关）。Word2007之后，支持LaTeX语法标记
  的数学输入，并且很重要的是微软给OpenType添加了一个math表，随后XeTeX
  的开发跟进，也支持了微软的这个表，现在LuaTeX也是支持的，在不远的将来，
  TeX的数学排版将直接使用Unicode编码。就基础性的数学排版而言，两者现在
  基本上没区别，除了TeX的数学字体多一些。我做过一个TeX风格的数学字体，
  偏Times风格可以用于Word，现在没时间弄了。TeX的优势是历史比较长，文档
  相当丰富。而Word的数学排版呢，受限于字体和格式，兼容性陷阱谁掉进去都
  不容易爬出来。如果Word能够解决这一点，那就很无敌了。但是Word这个东西
  做到和TeX高度兼容，开发者得付出相当大的努力了。*TeX不是排版之王，好
  的排版效果和坏的排版效果都是人控制的，人造的，当你到一定水平之后，工
  具就是//Das Ding// /für mich/（康德语）*。

-  编程。Word编程：域代码，VBA。TeX编程：TeX宏，perl代码，lua代码，
  python代码。哪个好玩？


写到这里，我觉得我应该写完了，对于排版，都是工具，别一味抬高哪个，别一
味贬低哪个。当一个用户被LaTeX的数学排版吸引的时候，可能会丢掉Word，但
是等你了解LaTeX一些深层次的概念的时候，你会发现Word也不是那么糟糕么，
XD。

对于Word的使用，我给出下列建议：

1. 先输入文字（可使用记事本，Vim，Emacs等完成），输入完成后在统一修改版式，边写边改效率低。
2. 插图的位置选放可以在版式修改之后进行，也可以在修改版式期间进行。
3. 目录什么的，要时常更新。
4. 我没有更多的建议。
**** [[http://texpoint.necula.org/][TeXPoint]]                                                   :texpoint:

<2016-03-03 四 15:43>
#+BEGIN_SRC org
最后更新时间为 2010 年，应该已经很古老了，不用考虑
#+END_SRC

**** [[http://blog.sina.com.cn/s/blog_84024a4a01017ukv.html][使用 mathtype 渲染]]                                         :mathtype:

<2016-03-03 四 15:42>
#+BEGIN_SRC org
这个可以尝试下
#+END_SRC

**** [[https://sourceforge.net/projects/texsword/][TeXsword]]                                                   :texsword:

- [[http://blog.csdn.net/lzuacm/article/details/17287385][Word插入Latex公式的几种方式]]

<2016-03-03 四 15:44>
#+BEGIN_SRC org
SourceForge 项目，最近更新时间为2014/01
#+END_SRC

**** [[http://elevatorlady.ca/][Aurora]]                                                       :aurora:

在MS Word中插入LaTeX数学公式网上一般推荐用Aurora，不过这个软件并不免费，
而且好久没更新了，不兼容最新的MikTex.

<2016-03-03 四 15:46>
#+BEGIN_SRC org
优先尝试这个，只是需要破解。
Word 需要安装 VB 和宏的支持
在 MS 2010 中运行 LaTeX 出错
百度云保存了破解版
#+END_SRC

*** dpkg warnning
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-03-03 四 16:09] \\
  Does not matter
:END:

[[http://www.2cto.com/os/201305/207615.html][误删dpkg的/var/lib/dpkg/info文件夹的解决办法]] 方法可以借鉴, 也许可以解
决问题, 但不用操之过急.这个问题还没有影响到使用.

#+BEGIN_EXAMPLE
  dpkg：警告：无法找到软件包 software-center 的文件名列表文件，现假定该软件包目前没有任何文件被安装在系统里。
  dpkg：警告：无法找到软件包 python-markupsafe 的文件名列表文件，现假定该软件包目前没有任何文件被安装在系统里。
  dpkg：警告：无法找到软件包 youtube-dl 的文件名列表文件，现假定该软件包目前没有任何文件被安装在系统里。
  dpkg：警告：无法找到软件包 python-oneconf 的文件名列表文件，现假定该软件包目前没有任何文件被安装在系统里。
#+END_EXAMPLE

** 95 B
*** DONE 测试卡片电脑连接 IMU
:LOGBOOK:
- State "DONE"       from "NEXT"       [2016-03-04 五 15:51]
- State "NEXT"       from ""           [2016-03-04 五 10:13] \\
  阅读手册，直接通过串口连接 IMU
CLOCK: [2016-03-04 五 09:40]--[2016-03-04 五 10:13] =>  0:33
:END:

1. 安装 ros-indigo-microstrain-3dmgx2-imu OK

2. 测试连接

   1) 卡片电脑，无 /dev/ttyUSB0
   2) 台式机，有 /dev/ttyUSB0, 说明 IMU 连线不存在问题, ROS 节点读取数
      据亦OK
   3) 使用 usb-serial 转接
      - 驱动预安装，OK
        #+BEGIN_EXAMPLE
        Bus 002 Device 002: ID 1a86:7523 QinHeng Electronics HL-340 USB-Serial adapter
        #+END_EXAMPLE
      - 连接 IMU，读出 /dev/ttyUSB0 !!!
   4) OK

3. 测试 ROS 节点，OK

   - IMU 初始化大约需要 20s

4. 关闭节点以及 Ros master 后，IMU 显示依然在读取数据？？

   - 原因是切换到后台后 使用 kill 关闭，可能导致不完全
   - 在前台关闭则没有出现类似情况
   - 切换到前台关闭也 OK

5. 通过串口直接连接IMU

   查看串口设备
   #+BEGIN_EXAMPLE
   dmesg | grep ttyS*
   #+END_EXAMPLE

   经测为 ttyS1

   通过远程连接有如下 warning

   #+BEGIN_EXAMPLE
     [ WARN] [1457077522.141754754]: Exception thrown while trying to get the IMU reading. This sometimes happens due to a communication glitch, or if another process is trying to access the IMU port. You may try 'lsof|grep /dev/ttyS1' to see if other processes have the port open. invalid checksum.
     Make sure the IMU sensor is connected to this computer. (in microstrain_3dmgx2_imu::IMU:receive)
   #+END_EXAMPLE

*** NEXT ttyUSB 是什么？以及 IMU 手册阅读
:LOGBOOK:
- State "NEXT"       from "TODO"       [2016-03-04 五 10:50] \\
  没有搞明白
CLOCK: [2016-03-04 五 10:24]--[2016-03-04 五 10:50] =>  0:26
:END:

**** tty

***** [[https://www.rfc1149.net/blog/2013/03/05/what-is-the-difference-between-devttyusbx-and-devttyacmx/][What is the difference between /dev/ttyUSB and /dev/ttyACM?]]

Have you ever wondered why some USB devices used =/dev/ttyUSB0= (or 1,
or /n/) and others=/dev/ttyACM0= (or 1, or /n/) when they are plugged
into the host computer, while they seem to be acting as
[[https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter][UART]]
devices ([[https://en.wikipedia.org/wiki/RS-232][RS-232]]-like) over USB
in both cases? Have you wondered why example USB firmwares for
microcontrollers always end up with names such as =/dev/ttyACM0= and
never as =/dev/ttyUSB0=?

/Warning: this is a Linux specific post, although it also contains
genuine pieces of USB culture./

****** What does =ttyACM= mean?

The [[http://www.usb.org/][USB implementors forum]] organization has
described how devices conforming to the
[[https://en.wikipedia.org/wiki/USB_communications_device_class][Communications
Device Class (CDC)]] should present themselves to the USB host. The USB
implementors forum also specified how CDC subclasses should act,
including for those devices intended to talk with each other over the
[[https://en.wikipedia.org/wiki/Public_switched_telephone_network][public
switched telephone network (PSTN)]]. Those are known as
[[https://en.wikipedia.org/wiki/Modem][modems]] because the data goes
through a modulation operation on the sending side, which transforms the
bits into analog signals that can be carried over phone wires, and then
through a demodulation operation on the receiving side to convert the
analog signal back into the original bits.

To discuss with the modem, the host USB driver must use one of the
existing control models. For example, the /direct line control model/
controls how data is exchanged between the host and the modem through an
audio class interface, with the host taking charge of the modulation,
demodulation, data compression (such as V.42bis) and error correction
(such as V.42). This model is used by some
[[https://en.wikipedia.org/wiki/Softmodem][USB soft modems]], which are
very cheap because they mostly contain a
[[https://en.wikipedia.org/wiki/Digital_Signal_Processing][DSP]] chip
and some amplification and line adaptation layers.

Another control model, aptly named */abstract control model/* or ACM, lets
the modem hardware perform the analog functions, and require that it
supports the
[[https://en.wikibooks.org/wiki/Serial_Programming/Modems_and_AT_Commands][ITU
V.250]] (also known as Hayes in its former life) command set, either in
the data stream or as a separate control stream through the
communication class interface. When the commands are multiplexed with
the data in the data stream, an
[[https://en.wikipedia.org/wiki/Time_Independent_Escape_Sequence][escape
sequence]] such as Hayes 302 (also known as “1 sec +++ 1 sec”) or TIES
(that nobody remembers) must allow the host to put the modem into
command mode.

When developping on a USB-enabled embedded microcontroller that needs to
exchange data with a computer over USB, it is tempting to use a
standardized way of communication which is well supported by virtually
every operating system. This is why most people choose to implement
CDC/PSTN with ACM (did you notice that the Linux kernel driver for
=/dev/ttyACM0= is named =cdc_acm=?) because it is the simplest way to
exchange raw data.

But what about the mandatory V.250 command set? It is almost never
implemented in such devices, but since the host has no reason to
spontaneously generate V.250 commands by itself, the device will never
have to answer them. Pretending the embedded device is a modem is the
simplest way to communicate with it, even though it will probably never
perform any modulation or demodulation task. Linux will not know that
the device is lying, and will have it show up as =/dev/ttyS0=.

****** What does =ttyUSB= mean?

Sometimes, the embedded microcontroller does not come with a hardware
USB interface. While it is possible to use a
[[http://www.obdev.at/products/vusb/index.html][software-only USB
stack]], the additional constraints put onto the CPU and the usually
small storage size often lead board designers to include a dedicated
UART to USB bridge. Several vendors, such as
[[http://www.ftdichip.com/][FTDI]] or
[[http://www.prolific.com.tw/US/][Prolific]] sell dedicated chips for a
few euros.

Those vendors opted not to lie to the host computer in having the chips
announce themselves as USB modems when they were not. Each vendor
defined its own (usually proprietary) protocols, with commands allowing
to control functions of the chips such as setting the baud rate or
controlling additional signals used to implement
[[https://en.wikipedia.org/wiki/Flow_control_(data)#Hardware_flow_control][hardware
flow control]].

When it is practical to do so, Linux groups devices with similar
functionalities under the same default device or interface names. For
example, the UARTs present on your computer (if any) will be named
=/dev/ttyS0= and =/dev/ttyS1= even if one of them is a legacy
[[https://en.wikipedia.org/wiki/16550_UART][16550]] chip and the other
one is a
[[http://www.maximintegrated.com/datasheet/index.mvp/id/1731][MAX3100]]
[[https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus][SPI]]-controlled
UART. Similarly, the devices offering UART-over-USB functionalities are
named =/dev/ttyUSB0=, =/dev/ttyUSB1=, and so on, even though they are in
fact using distinct device drivers.

****** Conclusion

So, when you see a =/dev/ttyACM0= popping up, you can try to send it the
escape sequence followed by AT commands, but there is a good chance that
the device only pretends to be a modem and will happily send those
characters to the core application without even considering intercepting
them. If it is a =/dev/ttyS0=, do not try, unless the device behind the
USB-UART bridge understands those command by itself (this is the case
for the
[[http://www.digi.com/products/wireless-wired-embedded-solutions/zigbee-rf-modules/point-multipoint-rfmodules/xbee-series1-module][XBee]]
chip).

*** TCB UTM30LX-EW 连接测试
:LOGBOOK:
- State "TCB"        from "NEXT"       [2016-03-04 五 14:50] \\
  下一步通过文件自动配置网络，而不是使用GUI手动配置
- State "NEXT"       from ""           [2016-03-04 五 11:50] \\
  暂时没有成功
CLOCK: [2016-03-04 五 11:03]--[2016-03-04 五 11:49] =>  0:46
:END:

http://answers.ros.org/question/212527/hokuyo-utm-30lx-ew-laser-scanner-problems-to-detect/

卡片电脑未关闭系统直接断电(误操作)后，再上电，电脑直接启动，未短路触发。

1. 安装 urg_node, OK
2. ping not ok
3. IP 配置


*配置的是 eth0 的 IP，掩码和路由，与 wlan0 无关（独立）*

- IP: 192.168.0.15
- Mask: 255.255.255.0
- GateWay： 192.168.0.1

通过GUI配置有线网络连接 OK

**** [[http://wiki.ros.org/urg_node][urg_node]]                                                   :urg_node:

***** Package Summary

Released No API documentation

urg_node

-  Maintainer status: maintained
-  Maintainer: Chad Rockey <chadrockey AT gmail DOT com>
-  Author: Chad Rockey <chadrockey AT gmail DOT com>
-  License: BSD

****** Supported Hardware

This driver should work with any SCIP 2.2 or earlier compliant laser
range-finders.

****** API Stability

The ROS API of this driver should be considered stable.

****** Parameter Ranges

The UTM-30LX laser can report corrupt data and even crash if settings
with an excessive data rate are requested. The following settings are
known to work:

*Intensity mode off*:

-  =cluster=: 1
-  =skip=: 1
-  =intensity=: false
-  =min_ang=: -2.2689
-  =max_ang=: 2.2689

*Intensity mode on*:

-  =cluster=: 1
-  =skip=: 1
-  =intensity=: true
-  =min_ang=: -1.047
-  =max_ang=: 1.047

******* Allow Unsafe Settings Option

Allow Unsafe Settings Option is not available, please consider using the
legacy [[/hokuyo_node][hokuyo_node]] for UTM-30LX with certain
configurations. (Or provide a
[[https://github.com/ros-drivers/urg_node/issues/3][pull request to
urg_node]] to add support for unsafe_settings.)

****** ROS API

******* hokuyo_node

=hokuyo_node= is a driver for SCIP 2.2 and earlier compliant Hokuyo
laser range-finders.Hokuyo scans are taken in a counter-clockwise
direction. Angles are measured counter clockwise with 0 pointing
directly forward.

******** Published Topics

=scan=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  Traditional single return output. This is the most compatible topic
   and represents output from a laser scanner that is not providing
   multiple returns per beam. This topic is not present for multi-echo
   laserscanners in multi-echo modes.

=echoes=
([[http://docs.ros.org/api/sensor_msgs/html/msg/MultiEchoLaserScan.html][sensor_msgs/MultiEchoLaserScan]])

-  Output of a laser scanner capable of multiple returns per beam. This
   is the topic that is designed to give the most information to users
   of [[/LaserScans][LaserScans]]. sensor_msgs/MultiEchoLaserScan is
   not required to be used by clients. This topic is not present for
   single echo laserscanners or multi-echo laserscanners in single echo
   mode.

=first=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  Output of the first return from a multi echo laser scanner. This
   topic represents the first return (distance closest to the laser
   scanner). It is typically published by a support library that
   converts sensor_msgs/MultiEchoLaserScans into
   sensor_msgs/LaserScans.

=last=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  Output of the last return from a multi echo laser scanner. This topic
   represents the last return (distance furthest from the laser
   scanner). It is typically published by a support library that
   converts sensor_msgs/MultiEchoLaserScans into
   sensor_msgs/LaserScans.

=most_intense=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  Output of the most intense return from a multi echo laser scanner.
   This topic represents the most intense return (brightest value). It
   is typically published by a support library that converts
   sensor_msgs/MultiEchoLaserScans into sensor_msgs/LaserScans.

=diagnostics=
([[http://docs.ros.org/api/diagnostic_msgs/html/msg/DiagnosticStatus.html][diagnostic_msgs/DiagnosticStatus]])

-  Diagnostic status information.

******** Parameters

=~ip_address= (=string=, default: "")

-  Location of the device on the network (only valid for ethernet
   devices). If this is left blank or is the empty string, the driver
   assumes the device is serial and will only attempt to connect using
   the '~serial_port' and '~serial_baud' parameters. Hokuyo factory IP
   addresses default to "192.168.0.10".

=~ip_port= (=int=, default: 10940)

-  IP port number. (1 to 65535)

=~serial_port= (=string=, default: /dev/ttyACM0)

-  This represents the serial port device (COM4, /dev/tty/USB0).

=~serial_baud= (=int=, default: 115200)

-  Data transfer rate for a serial device (9600, 115200, and so on)

=~frame_id= (=string=, default: laser)

-  The frame in which laser scans will be returned. This frame should be
   at the optical center of the laser, with the x-axis along the zero
   degree ray, and the y-axis along the 90 degree ray.

=~calibrate_time= (=bool=, default: false)

-  Whether the node should calibrate the device's time offset on
   startup. If true, the node will exchange of series of messages with
   the device in order to determine the time delay in the connection.
   This calibration step is necessary to produce accurate timestamps on
   scans.

=~time_offset= (=double=, default: 0.0)

-  A manually calibrated offset (in seconds) to add to the timestamp
   before publication of a message.

=~publish_intensity= (=bool=, default: false)

-  If true, the laser will publish intensity. If false, the laser will
   not publish intensity to save bandwidth. Should be implemented in
   hardware if possible, but otherwise may be implemented in software.

=~publish_multiecho= (=bool=, default: false)

-  If true, a multiecho laserscanner will publish
   sensor_msgs/MultiEchoLaserScan. If false, the laser will publish
   sensor_msgs/LaserScan. (If supported by the hardware; otherwise,
   please use a support library to convert
   [[/MultiEchoLaserScans][MultiEchoLaserScans]] to
   [[/LaserScans][LaserScans]].) This parameter is only valid for
   multiecho laserscanners.

=~angle_min= (=double=, default: -&pi)

-  Controls the angle of the first range measurement in radians. (If
   supported by the hardware; it is not recommended to implement this
   feature in software.)

=~angle_max= (=double=, default: &pi)

-  Controls the angle of the last range measurement in radians. (If
   supported by the hardware; it is not recommended to implement this
   feature in software.)

=~cluster= (=int=, default: 1)

-  The number of adjacent range measurements to cluster into a single
   reading; the shortest reading from the cluster is reported. (If
   supported by the hardware; it is not recommended to implement this
   feature in software.)

=~skip= (=int=, default: 0)

-  The number of input messages to skip between each output message. The
   device will publish 1 message for every N skipped messages. Example:
   if skip is set to '2', the device will publish 1 message and then
   'drop' the following 2 message - a 66.7% reduction in output rate.
   (If supported by the hardware; it is not recommended to implement
   this feature in software.)

=~diagnostics_tolerance= (=double=, default: 0.05)

-  Fractional percent tolerance for published scan frequency to vary
   from expected. 0.05 is 5%, so for 40Hz it means acceptable limits
   between 38Hz and 42Hz.

=~diagnostics_window_time= (=double=, default: 5.0)

-  Number of seconds in which to consider published data to determine
   publish frequency for diagnostics.

****** Command-Line Tools

The =getID= program can be used to get information about a hokuyo laser
scanner. Each of them can be invoked in a human readable way:

#+BEGIN_EXAMPLE
    $ rosrun hokuyo_node getID /dev/ttyACM0
    Device at /dev/ttyACM0 has ID H0807228
#+END_EXAMPLE

or in a script friendly way:

#+BEGIN_EXAMPLE
    $ rosrun hokuyo_node getID /dev/ttyACM0 --
    H0807228
#+END_EXAMPLE

If they fail to connect to the device they will retry for about ten
seconds before giving up.

****** Using udev to Give Hokuyos Consistent Device Names

The =getID= program can be used to get the hardware ID of a Hokuyo
device given its port. Combined with udev, this allows a consistent
device name to be given to each device, even if the order in which they
are plugged in varies. On the PR2 we use the following udev rule:

#+BEGIN_EXAMPLE
    SUBSYSTEMS=="usb", KERNEL=="ttyACM[0-9]*", ACTION=="add", ATTRS{idVendor}=="15d1", ATTRS{idProduct}=="0000", MODE="666", PROGRAM="/opt/ros/hydro/lib/urg_node/getID /dev/%k q", SYMLINK+="sensors/hokuyo_%c", GROUP="dialout"
#+END_EXAMPLE

This udev rule sets up a device name that is based on the Hokuyo's
hardware ID. The PR2 then has a symlink to that name that gets changed
if the Hokuyo is replaced:

#+BEGIN_EXAMPLE
    $ ls -l /etc/ros/sensors/base_hokuyo
    lrwxrwxrwx 1 root root 28 2010-01-12 15:53 /etc/ros/sensors/base_hokuyo -> /dev/sensors/hokuyo_H0902620
    $ ls -l /dev/sensors/hokuyo_H0902620
    lrwxrwxrwx 1 root root 10 2010-04-12 12:34 /dev/sensors/hokuyo_H0902620 -> ../ttyACM1
#+END_EXAMPLE

Wiki: urg_node (last edited 2014-08-13 21:36:19 by
[[/ChadRockey][ChadRockey]])

Except where otherwise noted, the ROS wiki is licensed under the\\
[[http://creativecommons.org/licenses/by/3.0/][Creative Commons
Attribution 3.0]] |
[[https://plus.google.com/113789706402978299308][Find us on Google+]]

--------------

[[/custom/images/brought_by_horiz.png]]

*** TCB 在Emacs使用文件管理器打开目录，而不是 Emacs 本身
:LOGBOOK:
- State "Tcb"        from "TODO"       [2016-03-04 五 11:59] \\
  没事可以折腾
:END:

[[~/Document]]

https://github.com/jixiuf/org-mode-files/blob/master/emacs/open-with.org
也许可以参考

C-u C-u C-x C-o 无效

其实没有必要，也没有意义。

*** DONE 远程连接 ROS
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-03-04 五 15:34]
- State "TODO"       from ""           [2016-03-04 五 15:01]
:END:

1. 为从机设置 ROS_MASTER_URI

   #+BEGIN_EXAMPLE
   export ROS_MASTER_URI=http://192.168.1.3:11311
   #+END_EXAMPLE

2. 分别为主机和从机设置  ROS_IP

   #+BEGIN_EXAMPLE
   export ROS_IP=`hostname -I`
   #+END_EXAMPLE

   或者直接写入 .bashrc

3. 谁主谁从?

   *配置好的为主*

*** org-todo 快捷绑定到 M-t

使用 org-clock-in/out 不如使用 org-todo

M-t 默认绑定到 org-transpose-word

#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map "\M-t" nil)
  (define-key org-mode-map "\M-t" 'org-todo)
#+END_SRC

*** DONE 配置 hokuyo ID
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-03-04 五 18:34]
- State "TODO"       from ""           [2016-03-04 五 17:20]
:END:

http://wiki.ros.org/urg_node
http://wiki.ros.org/hokuyo_node

测试 urg_node 页面上的 udev 规则, 没有成功.

测试 hokuyo_node 页面上的 udev 规则,  OK

#+BEGIN_EXAMPLE
  ll@ll-OEM:~$ ls -l /dev/ttyACM*
  crw-rw-rw- 1 root dialout 166, 0  3月  4 18:32 /dev/ttyACM0
  crw-rw-rw- 1 root dialout 166, 1  3月  4 18:32 /dev/ttyACM1
  ll@ll-OEM:~$ ls -l /dev/sensors/
  总用量 0
  lrwxrwxrwx 1 root root 10  3月  4 18:32 hokuyo_H1004293 -> ../ttyACM0
  lrwxrwxrwx 1 root root 10  3月  4 18:32 hokuyo_H1007634 -> ../ttyACM1
#+END_EXAMPLE

udev 规则

#+BEGIN_EXAMPLE
ll@ll-OEM:~$ cat /etc/udev/rules.d/hokuyo.rules
KERNEL=="ttyACM[0-9]*", ACTION=="add", ATTRS{idVendor}=="15d1", MODE="0666", GROUP="dialout", PROGRAM="/opt/ros/indigo/env.sh rosrun hokuyo_node getID %N q", SYMLINK+="sensors/hokuyo_%c"
#+END_EXAMPLE

/修改 ROS 版本/

*** [[http://blog.csdn.net/laiqun_ai/article/details/8224555][Linux 下查看串口号]]

- 查看串口是否可用，可以对串口发送数据比如对com1口，

  #+BEGIN_EXAMPLE
  echo lyjie126 > /dev/ttyS0
  #+END_EXAMPLE

- 查看串口名称使用

  #+BEGIN_EXAMPLE
  ls -l /dev/ttyS*
  #+END_EXAMPLE

  一般情况下串口的名称全部在dev下面，如果你没有外插串口卡的话默认是dev
  下的ttyS* ,一般ttyS0对应com1，ttyS1对应com2，当然也不一定是必然的；

- 查看串口驱动

  #+BEGIN_EXAMPLE
  cat /proc/tty/drivers/serial
  #+END_EXAMPLE

- 查看串口设备
  #+BEGIN_EXAMPLE
  dmesg | grep ttyS*
  #+END_EXAMPLE


Q: 我新查了一个扩展串口卡，但是不能用，不知道为什么！！！
A: 首先看下说明书，驱动安装好后正常是什么设备号？然后安装驱动，驱动如
果安装成功一般就会有设备号了就可以用了。

Q: 使用dmesg | grep ttyS* 是可以看见新增串口的，分别是ttyS5和ttyS6，中
断号都是20，按照说明安装驱动了也，什么是设备号？
A: 那就是 ttyS5 ttyS6，这个2个设备号就是对应的串口设备号

** 94 C

** 93 B

- [X] 精简连线

** 92

- [ ] SINS sim
- [ ] IMU Thesis

* Week
