#+LATEX_HEADER: \usepackage[boxed, lined]{algorithm2e}
# #+LATEX_HEADER: \usepackage{minted}
# #+LATEX_HEADER: \usepackage{float}

# freemind
# .sdcv_history
# agenda
# obj


- [ ] Prime: PCL
- [ ] Project: IMU
- [ ] Progress: Deutsch
- [ ] Thesis: Outliers

* Objective
** month

+ [ ] 写完大论文初稿
+ [ ] 完成一篇小论文
+ [ ] IMUtoolbox / PythonSLAM / TimBailey

** week

+ [ ] EK-SLAM & Gazebo Sim & Thesis
+ [ ] PF

** 2016/01/11

+ [X] freemind
+ [X] wally & julie
+ [X] software
+ [X] ROS opencv

** 2016/01/01
+ [X] wally gazebo 仿真实现三维建模
+ [X] 小车测试 Hector SLAM
** 2016/01/02
+ [X] 理解 Hector SLAM 中 map/odom/base_footprint 的配置（仿真中即可）
+ [X] 绪论 SLAM 部分
** 2016/01/03
+ [X] gazebo worlds
+ [X] 使用小车采集数据实现三维建模（保存数据，不用实时）
+ [ ] 使用 Raspberry 采集数据
+ [X] 理解 Hector SLAM 的 base_stablized 坐标配置
** 2016/01/04
+ [X] 采集小车本身的数据
+ [X] IMU 积分算法
+ [X] 完成论文定位部分
** 2016/01/05

+ [X] laser_filter/laser_assembler/PLC
+ [ ] Samba 配置
+ [X] 推导 PF，莫放拦路虎
+ [X] 特征地图论文

** 2016/01/06
+ [X] PCL
+ [ ] SLAM 论文部分
** 2016/01/07
+ [X] 考虑电池和电路板
+ [X] PCD
+ [X] SLAM 论文部分
** 2016/01/08
+ [X] 考虑学报
+ [X] PF SLAM
+ [X] Gazebo sim
* Journal

** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

** EmacsWiki

- [[http://www.emacswiki.org/emacs/PhpMode][phpmode]]
- [[http://www.emacswiki.org/emacs/ArduinoSupport][ArduinoSupport]]
- [[http://www.emacswiki.org/emacs/AutoComplete][AutoComplete]]
- [[http://www.emacswiki.org/emacs/ArtistMode][ArtistMode]]
- [[http://www.emacswiki.org/emacs/ProgrammingWithPythonModeDotEl][ProgrammingWithPythonModeDotEl]]
- [[http://www.emacswiki.org/emacs/PythonProgrammingInEmacs][PythonProgrammingInEmacs]]
- [[http://www.emacswiki.org/emacs/EasyPG][EasyPG]]
- [[http://www.emacswiki.org/emacs/ThumbsMode][ThumbsMode]]
- [[http://www.emacswiki.org/emacs/XKeymacs][XKeymacs]]
- [[http://www.emacswiki.org/emacs/MakefileMode][MakefileMode]]
- [[http://www.emacswiki.org/emacs/DeletingWhitespace][DeletingWhitespace]]
- [[http://www.emacswiki.org/emacs/Edit_with_Emacs][Emacs]]
- [[http://www.emacswiki.org/emacs/CopyWithoutSelection][CopyWithoutSelection]]
- [[http://www.emacswiki.org/emacs/ModeLine][ModeLine]]

** wiki 代理

从该IP地址段106.187.32.0/20的账户创建已被Jimmy-abot禁止，而这也包括了
您的IP地址（106.187.44.23）。

Jimmy-abot给出的原因是

Banned proxys.svg您正在使用的IP地址已经被封禁，因我们相信其被用作代理。


问题是： 没法登录！！！

* totar
** [[http://blog.chinaunix.net/uid-20804763-id-68083.html][LaTeX命令速查手册]]    :blog:

分类：

+---------------------------------+
|TeX各版本概述及基本约定，特殊字符|
+---------------------------------+

tex提供300多条基本排版命令
由D.E.Knuth1978年开发
plain tex：在tex基础上新定义600多条复合命令
AMS-TEX：美国数学会开发（amsmath宏包）排版的数学公式
LATEX：L.Lamport（1985）编写，适合排版普通文章和书籍
LATEX2e：可加载amsmath宏包，目前最流行的TEX宏包
版本：LATEX2.09-->LATEX2e-->LATEX3（开发中）
中文排版：
CCT：科学院张林波
TY（天元）：华师大肖刚、陈志杰教授开发
CJK：德国W.Lemberg开发，处理中日韩三国文字。
发行版CTEX：集成了CCT，TY，CJK的MikTEX系统。
ChinaTEX:内容涵盖MiKTeX系统及中文支持、常用外围软件、TeX\LaTeX文档和模板选萃等

TeX中的长度
mm毫米
cm厘米
in英寸＝2.54cm＝72.27pt
pt点
em大写字母M的宽度
ex小写字母x的高度

弹性长度：根据需要自动伸缩
正常值plus伸展值minus收缩值
实际长度可超过正常值和伸展值之和，但不能小于正常值和收缩值之差

\documentclass[11pt]{article}%11pt字体，普通文章
%导言区，全局命令
\usepackage{CJK}%使用CJK宏包
\begin{document}%主环境
\begin{CJK}{GBK}{song}%汉字必须放入CJK环境
%其它字体:song,kai,fs,hei,li,you
%CJK的两种环境CJK和CJK*
%GBK是采用的字符集：GB，GBK，Bg5，Gbt
Hi,This is my first \LaTeX file
祝贺你，MikTex和CJK安装成功了
\end{CJK}
\ent{document}

CJK和CJK*环境之间的切换
\CJKspace和\CJKnospace


\CJKtilde 重新定义～的长度


基本约定
分组｛......｝
注释符：%
西文标点后要加空格
各种环境的开始和结束命令最好独占一行
换行:连续两个回车，一个仅为空格


输入特殊字符
前加\的有：#$%{}~_\^&
\=\textbackslash
｜,<,>＝$|$,$<$,$>$,$*$(中间星）
*＝*上面星
特殊符号\s \p \dag \ddag \copyrigh版权号，\pounds 磅

\TeX \LaTeX \LaTeXe \AmS-\LaTeX(最后这个要amsmath宏包）

单引号：`'(1键前面的）
双引号：``"

+------------------------------+
|段落、行距、水平间距、缩进命令|
+------------------------------+


强制分行：\\或\\*[和下行间距离]、\newline
建议分行：\linebreak[0-4，数越大建议力度越大]
\linebreak增加字间距，强制换行
\nolinebreak［n］建议不分行
\mbox｛内容｝内容保持在同一行

分段：\par，或两个回车
分页：自动分页
强制分页：\newpage
建议分页：\pagebreak［n］，\nopagebreak［n］

增加当前页高度有时可以避免难看的分页
\enlargethispage｛尺寸｝可增加的最大高度
\enlargethispage*｛尺寸｝指定增加高度

水平间距：
\quad 插入空白相当于当前字体大小
\qquad＝\quad×2
\ ，＝\quad×3/18
~=???好象比\ 小
\hspace{宽度大小}，\hspace*{宽度大小}
\hfill弹性长度：hspace{\hfill}插入空白，撑满整行
\hphantom{文本内容},占据文本内容的宽度
\vphantom[文本内容},\phantom{文本内容}

导引线：\dotfill，\hrulefill

垂直间距：
\vspace{高度}和\vspace*{高度}
\vfill：相当于\vspace{\fill}
\smallskip:-->\vspace{\smallskipamount}
\medskip:-->\vspace{\medskipamount}
\bigskip:-->\vspace{\bigskipamount}

段落首行缩进：
\setlength{\parindent}{2em},2个M
\setlength{\parindent}{0pt},首行不缩进
\CJKindent:两个汉字
\indent与\noindent
每节的第一段首行不会自动缩进
\hspane{\parindent}
在导言区加入：\usepackage{indentfirst}

段落间距：\lineskip+\parskip
可用\setlength修改以上值

行距：
\baselineskip：相邻两行基线间距离
\baselinestretch：伸展因子
修改改变行距：\renewcommand{\baselinestretch}[1.2]
放在\begin{document}之后，字体尺寸改变时才生效




+----------------------------------+
|西文字体属性、及中文字体属性、命令|
+----------------------------------+
字体有5种属性
族：
\rmfamily：罗马字体
\sffamily：无衬线字体
\ttfamily：打字机字体
形状：（shape）直立斜
\upshape：直立
\itshape：意大利斜体
\slshape：斜体
\scshape：小体大写
系列：（series）宽度黑度
\mdseries：中等权重（黑）
\bfseries：粗体

\normalfont：默认字体，中等权重直立罗马字体
西文尺寸：10pt，11pt，12pt
\em强调，一般为斜体
以上命令称为声明（无参数）

每一声明对应字体命令
命令只对其参数中的文本起作用
族：
\testrm{},\testsf{},\testtt{}
形状
\textup{},\textit{},\textsl{},\textsc{}
系列
\textmd{}，\textbf{}
默认值：\textnormal{}
强调：\emph{}

定义了基本尺寸后，可使用下面的声明来改变字体
\tiny  5pt
\scriptsize 7pt
\footnotesize 8pt
\small  9pt
\normalsize 10pt
\large  12pt
\Large  14.4pt
\LARGE  17.28pt
\huge  20.74pt
\Huge  24.88pt
以上尺寸是基本尺寸为10pt时的大小

所有西文字体命令对中文同样起作用
italic和slanted斜体对中文一样

中文书籍基本字号为5号约等于11pt

使用GBK编码时，可同时输入简繁体。

自定义字体大小
\fontsize{字体尺寸}{行距}后面须加上\selectfont才生效
可得到任意大小汉字，西文最大不能超\Huge
行距通常为字体大小的1.2-1.5倍
例：\fontsize{12pt}{\baselineskip}\selectfont
\usepackage{type1cm}任意大小西文

行距：\linespread{1.3}产生1.5倍行距，1.6产生双倍行距，效果夸张，不适合出版
用下面方法：\setlength{\baselineskip}{1.5\baselineskip}{......}



正文中更换字体：\CJKfamily{字体族}

为方便，作以下自定义
\newcommand*{\SONG}{\CJKfamily{song}}
\newcommand*{\HEI}{\CJKfamily{hei}}
\newcommand*{\KAI}{\CJKfamily{kai}}
\newcommand*{\FS}{\CJKfamily{fs}}
\newcommand*{\LI}{\CJKfamily{li}}
\newcommand*{\YOU}{\CJKfamily{YOU}}

引用更改为宋体：\SONG 正文



文本居中
文本默认为左对齐
单行文本居中命令
\centerline{....}
多行使用\begin{center}环境
居中声明：\centering（不建议使用）

+------------+
|参考文献环境|
+------------+
\begin{thebibliography}{编号样本}
\bibitem[记号]{引用标志} 文献条目
 .
 .
 .
\bibitem[记号]{引用标志} 文献条目
\end{thebibliography}

\bibitem[省略为方括号数字]{不可省由字母，数字和，号外符号组成，各个文献互不相
同} 文献条目
编号样本，指定记号的宽度，一般为数字

引用文献时用\cite{引用标志1，引用标志2}

调节各文献间距离
\setlength{\itemsep}{高度}

标题缺省为左对齐Reference
（\Large\bfseries）
由\refname值确定
书籍参考文献标题由\bibname值确定

文献条目包含：作者，标题，出版社，年代，版本，页码
一行放不下，后面自动缩进，距离为“编号样本”宽度

+----------+
| 脚    注 |
+----------+
\footnote{脚注内容}
article文档，整篇同一编号
book和report文档，每章统一编号

+----------------+
| 文档类别、章节 |
+----------------+

\documentclass[可选项]{article,book,report,letter,只能选一种}
article 短篇文章
report 长篇报告，可分章
book （书）可含chapter，奇偶页采用不同处理
可选项对整篇文档起作用，使用多个选项互不排斥，用逗号分隔
基本字体：10pt，11pt，12pt
纸张大小：letterpaper，a4paper，a5paper...
排版方向：portrait（竖向），landscape（横向）
标题页：titlepage，notitlepage
final和draft

指定纸张大小（只有latex2e中使用）
letterpaper（11*8.5in）
legalpaper（14*8.5in）
executivepaper（10.5*7.25in）
a4paper（29.7*21cm）
a5paper（21*14.8cm）
b5paper（25*17.6cm）
默认值是letterpaper，美国信纸尺寸，纵向
landscape 横向


章节命令：
\part,\chapter,\section,\subsection,\subsubsection,\paragraph,\subparagraph
\命令[短标题]{标题},用于显示在目录和页眉
\命令*{标题}
层次号：book中\part为-1（article中为0），\chapter为0，....
book类
\part，\chapter独立编号，只出现在奇数页，\part独占一页
\section，\subsection 关联编号
article类
\part，\section独立编号
\subsection，\subsubsection 关联编号
星号章节不参加自动编号
\part和\chapter标题占两行

标题中文化
\renewcommand{\partname}{}
\renewcommand{\thepart}{第\，\Roman{part}}\,篇}

修改编号最深层次
\setcounter{secnumberdepth}{数}
secnumberdepth，book类-2～5，缺省为2，-2时取消编号
article类-1～5，缺省为3

自动编号章节对应计数器
part，chapter，section，bsection,subsubsection,paragraph,subparagraph
修改计数器值：
\setcounter{计数器名}{数}

 TeX的版式首先是文件版式, 也就是我们接触的第一个最最最
简单的TeX文档中的第一句:
       \documentstyle[选项1,选项2,...]{格式}
其中的[]及选项是可选的, 而{格式}是必需的. LaTeX有以下几种
格式: article(文章), report(报告), book(书), letter(信件).
CCT对前面三种进行了汉化, 分别是carticle, creport和cbook.
常用的选项有
  10pt/11pt/12pt: 定义基准字号, 缺省10pt.
  twoside: 两面印刷格式, 因奇偶页装订位置不同而异, 缺省为
           单页.
  twocolumn: 双栏排版, 缺省为单栏.
  titlepage: 仅在article格式使用, 它是\maketile产生一个单
             独的文章题目页, 同时abstract也产生单独页
  leqno: 使公式标号出现在左边, 缺省在右
  fleqn: 公式左对齐, 缺省中间对齐
  thesis: 专用于毕业论文排版
  IEEE: 专向IEEE类杂志投稿的格式
  IFTHEN: 排版计算机程序

\columnsep 指定两栏间距
\columnseprule 两栏间竖线宽度，默认为0。
\mathindent 选择fleqn时 左边界的缩进量

以上参数修改用\setlength{\mathindent}{2.5cm}


    LaTeX的一个页面有页眉(head, 通常是杂志名, 卷号, 当前
章节名等), 主体(body, 正文, 包括脚注及图表), 页脚(通常是
页码, 如果页码放在页眉处, 则页脚可能是空的). 我们用下面的
指令控制页版面:
        \pagestyle{参数}
参数可以是
  plain: 页码在页脚居中, 页眉空白, 为article, report的缺省
  empty: 页眉页脚都空白
  heading: 页脚为空, 页眉为正文的章节信息及页码
  myheadings: 自定义页眉, 内容由
     \markboth{left_head}{right_head}   (双面twoside排版)
   或\markright{right_head}             (单面排版)
    \pagestyle是对全文有效的, 而如果要定义某页的页面格式,
则可用\thispagestyle, 用法同上, 下一页自动恢复原设置.

    这里提到页码, 我们经常会修改页码的表现格式, 可能用阿
拉伯数字或罗马数字等, 则修改\pagenumbering{参数}, 这里参
数可以是arabic(阿拉伯数字), roman(小写罗马数字: i, ii, iii,)
Roman(大写罗马数字: I, II, III,), alph(小写英文: a, b, c,),
Alph(大写英文: A, B, C). 如果需要更改某页的页码, 则用修改
计数器命令: \setcounter{page}{数字}, 这里page是页码计数器.

+----------------+
|*修改版面的命令*|
+----------------+


TeX中还经常会在\documentstyle和\begin{document}之间
常用到很多修改版面尺寸的命令. 如未指明, 这些命令的格式都
是用\para_name=newvalue的格式.
  \texwidth, \texheight 主要正文body的宽度和高度, 不包括页眉页脚
  \oddsidemargin, \evensidemargin 奇数/偶数页, 纸张左边缘
    到页body左边缘的距离减去一英寸
  \topmargin 纸张上边缘到页眉或body(无页眉时)的距离减去一
    英寸
  \marginparwidth 页边注(marginnote)的宽度
  \marginparsep 正文边缘到页边注边缘的距离
  \headheight 页眉高度
  \headsep 页眉底部到页主体顶部的距离
  \footheight 页脚高度
  \footskip 页正文最后一行底到页脚底的距离
(建议, 总把
\oddsizemargin（奇数页的左边界）
\evensidemargin（偶数页的左边界）
\topmargin（从上页边到页眉的距离）
设为0cm;
如果没用页眉, 将
\headheight（页眉高度）,
headsep（页眉基线到正文顶部的距离）
设为0cm;
如果没用页脚, 将
\footheight（已过时latex2e中已被去掉）,
\footskip（正文底部到页脚底部的距离）设为0cm,
这样便于在输出时直接利用驱动程序的功能控制版心的位置.)

\columnsep 双栏article中, 左右栏间空白的距离
\columnseprule 双栏article中, 左右栏间分隔线的宽度, 缺省 为零, 即没有线
以下参数的修改可以在\begin{document}的前面和后面:
  \parskip 段落之间除了空出正常行距外额外空出的距离
  \parindent 段首空白的长度
  \footnotesep 两个注脚之间的距离
  \baselineskip 正文中前一行底和第二行底的距离, 会因字号的
    改变自动改变.
    另外, 定义行距还有一个特殊的参数, 那是\baselinestretch,
它是用在\begin{document}前的全局变量, 修改格式如
\renewcommand\baselinestretch{倍数}    缺省时为1.0, 因此
LaTeX中最小行距是\baselineskip乘上\baselinestretch得到的.

+----------------+
| 文档标题、摘要 |
+----------------+

\title{标题可有\\换行}
\author{作者名可用and分开}
\date{日期可选，无命令自动当天日期，空白选项不显示}
\thanks{}可出现\maketitle以上任何位置，或几个\thanks
\maketitle
LaTex用特定字体、号居中输出

自定义标题环境
\begin{titlepage}
\end{titlepage}
生成标题独占一页，并重置页码计数器

摘要环境
\begi{abstract}
...
\end{abstract}

book类没有摘要
摘要标题中文化
\renewcommand{abstractname}{摘\qquad 要}


** http://www.dll-files.com/    :blog:

** [[http://emuch.net/html/200711/641492.html][回复评审意见必说的话]]    :blog:

很多人都遇到过回复审稿人意见的时候。本人曾经因为回复审稿意见不合适而导致拒稿，相当的惨哪！！后来发现回复审稿意见时，除了写清修改内容外，还有一些话是必须要写的。对审稿人的意见提出不同的看法也应该讲究一定的技巧。由于这些话的英文都不难写，所以我直接写成中文表述，觉得有用的虫友自己翻译吧。
      首先，不论审稿人提了什么意见，你在回复的时候，第一句话一定要说：“谢谢您的建议，您的所有建议都非常的重要，它们对我的论文写作和科研工作都具有重要的指导意义！！”
      其次，在回复信的结尾最好写上“再次谢谢您的建议，希望能够从您哪里学到更多的知识。”这句话最好用黑体，要显眼。
      再次，如果审稿人提的意见你暂时无法做到（比如，要你增加实验或改进实验等）。那么，为了论文尽快发表，你必须拒绝这样的要求。但是，你不要摆出一大堆理由来证明这个意见是不好实现的。你应该说：“谢谢您的建议，它非常的重要，由于您的建议，我发现了我目前工作中的不足之处，我会在以后的工作中按照您的建议提高科研水平，取得更多成绩！”这样就委婉的拒绝了评审意见，又让评审人觉得你很看重他的意见。
       第四，如果审稿人的意见明显有问题。那么没办法了，你必须据理力争。但是，你一定不能说：“审稿人先生，我认为你的意见是错的！”你不必对他的意见发表任何的评论，只需要列出你的理由和证据就可以了，结尾也不要强调你的观点是正确的。简单说就是“既不说你对，也不说我对，证据说话”。
       第五，如果审稿人的评价比较傲慢，而且有失公平。那么，不用客气，直接写信给编辑，痛批审稿人。（我就遇到过这样的情况，痛批后反而被录用。）

** [[http://blog.sina.com.cn/s/blog_49956eee0102vora.html][给国外教授发邮件的礼貌用语]]    :blog:

感谢读者是邮件开场白的好办法。感谢您的读者能让对方感到高兴，特别是之后你有事相求的情况下会很有帮助。



Thank you for contacting us.如果有人写信来询问公司的服务，就可以使用这句句子开头。向他们对公司的兴趣表示感谢。



Thank you for your prompt reply.当别人很快就回复了你的邮件，一定记得要感谢他们。如果回复并不及时，只要将“prompt”除去即可，你还可以说，“Thank you for getting back to me.”



Thank you for providing the requested information.如果你询问某人一些信息，他们花了点时间才发送给你，那就用这句句子表示你仍然对他们的付出表示感激。



Thank you for all your assistance.如果有人给了你特别的帮助，那一定要感谢他们！如果你想对他们表示特别的感激，就用这个句子，“I truly appreciate … your help in resolving the problem.”Thank you raising your concerns.





在邮件的结尾



在邮件开头表示感谢一般是表示对对方过去付出的感谢，而在邮件结尾处表示感谢是对将来的帮助表示感谢。事先表示感谢，能让对方在行动时更主动更乐意。



Thank you for your kind cooperation.如果你需要读者帮助你做某事，那就先得表示感谢。



Thank you for your attention to this matter.与以上的类似，本句包含了你对对方将来可能的帮助表示感谢。



Thank you for your understanding.如果你写到任何会对读者产生负面影响的内容那就使用这句句子吧。



Thank you for your consideration.如果您是在寻求机会或是福利，就用这封邮件结尾。



Thank you again for everything you've done.这句句子可以用在结尾，和以上有所不同。如果你在邮件开头已经谢过了读者，你就可以使用这句话，但是因为他们的帮助，你可以着重再次感谢你们的付出。

** [[http://zhan.renren.com/leadessay?gid=3602888497999762196&checked=true][给国外教授发邮件会用到的礼貌用语]]    :blog:

1. I am writing to confirm /enquire/inform you...
我写信时要确认/询问/通知你。。。

2. I am writing to follow up on our earlier decision on the marketing campaign in Q2.
我写信来追踪我们之前对于第二季度营销活动的决定。

3. With reference to our telephone conversation today...
关于我们今天在电话中的谈话。。。

4. In my previous e-mail on October 5...
先前在10月5日所写的信。。。

5. As I mentioned earlier about...
如我先前所提及关于。。。

6. as indicated in my previous e-mail...
如我在先前的信中所提出。。。

7. As we discussed on the phone...
如我们上次在电话中的讨论。。。

8. from our decision at the previous meeting...
如我们在上次会议中的决定。。。

9. as you requested/per your requirement...
按照你的要求。。。

10.In reply to your e-mail dated April 1，we decided...
回答你在4月1日写的信，我们决定。。。

11.This is in response to your e-mail today.
这是针对你今天早上来信的回复。

12. As mentioned before, we deem this product has strong unique selling points in china.
如先前所述，我们认为这个产品在中国有强有力且独一无二的销售点。

13. As a follow-up to our phone conversation yesterday, I wanted to get back to you about the pending issues of our agreement.
追踪我们昨天在电话中所谈，我想答复你我们合约的一些待解决的议题。

14. I received your voice message regarding the subject. I’m wondering if you can elaborate i.e. provide more details.
我收到你关于这个主题的留言。我想你是否可以再详尽说明，也就是再提供多一点细节。

15. Please be advised/informed that...
请被告知。。。

16. Please note that...
请注意。。。

17. We would like to inform you that...
我们想要通知你。。。

18. I am convinced that...
我确信。。。

19. We agree with you on...
我们同意你在。。。

20. With effect from 4 Oct., 2008...
从2008年10月4日开始生效。。。

21. We will have a meeting scheduled as noted below...
我们将举行一个会议，时间表如下。

22. Be assured that individual statistics are not disclosed and this is for internal use only.
请确保个人信息不会外泄且只供内部使用。

23. I am delighted to tell you that...
我很高兴地告诉你。。。

24. We are pleased to learn that...
我们很高兴得知。。。

25. We wish to notify you that...
我们希望通知你。。。

26. Congratulation on your...
恭喜您关于。。。

27. I am fine with the proposal.
我对这份提桉没意见。

28.I am pleased to inform you that you have been accepted to join the workshop scheduled for 22-24 Nov,2008.
我很高兴地告诉你，你已经被同意参加2008年11月22-24日的研讨会。

29. We are sorry to inform you that...
我们很抱歉地通知你。。。

30. I’m afraid I have some bad news.
我恐怕要带来一些坏消息。

31. There are a number of issues with our new system.
我们的新系统有些问题。

32. Due to circumstances beyond our control...
由于情况超出我们所能控制。。。

33. I don’t feel too optimistic about...
我觉得不太乐观关于。。。

34. It would be difficult for us to accept...
我们很难接受。。。

35. Unfortunately I have to say that, since receiving your enquiries on the subject, our view has not changed.
很不幸地，我必须这么说，自从收到你关于这个主题的询问，我们的看法都没有改变。

36. We would be grateful if you could...
我们会很感激如果你可以。。。

37. I could appreciate it if you could...
我会很感激如果你可以。。。

38. Would you please send us…?
可否请你寄给我们…？

39. We need your help.
我们需要你的帮助。

40. We seek your assistance to cascade/reply this message to your staff.
我们请求你的帮助，将此信息传达给你们的员工。

41. We look forward to your clarification.
我们期待你的澄清。

42.Your prompt attention to this matter will be appreciated.
您能立即注意此事，我们将非常感激。

43. I would really appreciate meeting up if you can spare the time. Please let me know what suits you best.
如果您能抽出时间，我希望能与你见面，请让我知道您最适合的时间。

44.Please give us your preliminary thoughts about this.
请让我知道你对于这件事情初步的想法。

45. Would you please reply to this e-mail if you plan to attend?
请您回信如果您计划参加？

46.Please advise if you agree with this approach.
请告知是否你同意这个方法。

47. Could you please let me know the status of this project?
请让我知道这个计划的进度？

48. If possible, I hope to receive a copy of your proposal when it is finished.
如果可能，当你完成提桉，我希望能收到一份复本。

49. I would appreciate it very much if you would send me your reply by next Monday.
如果能在下周一前收到您的答复，我将非常感激。

50. Hope this is OK with you. If not, let me know by e-mail ASAP.
希望您对此没有问题，如果不行，请利用电子邮件尽快让我知道。

51. Could you please send me your replies to the above questions by the end of June?
请您在6月份前答复我上述问题好吗？

52. May I have your reply by April 1, if possible?
如果可能，我可否在4月1日前收到您的答复？

53. If you wish, we would be happy to...
如果你希望，我们很乐意。。。

54. Please let me know if there’s anything I can do to help.
请让我知道任何我可以帮得上忙的地方。

55.If there’s anything else I can do for you on/regarding this matter, please feel free to contact me at any time.
对于这件事，如果还有任何我能帮得上忙的地方，请不要客气，随时与我联络。

56.If you want additional recommendations on this, please let us know and we can try to see if this is possible.如果关于此事你需要额外的建议，请让我们知道，我们会尝试看看是否可能。

57. I’m just writing to remind you of...
我只是写信来提醒您。。。

58. May we remind you that...?
我们想要提醒您。。。

59. I am enclosing...
我附上。。。

60. Please find enclosed...
请查阅附件。。。

61. Attached hereto...
附件是关于。。。

62. Attached please find the most up-to-date information on/regarding/concerning…
附上关于某某的最新资料…

63. Attached please find the draft product plan for your review and comment.
附上产品计划书的草稿，请审查及评价。

64. If you have any further questions, please feel free to contact me.
如果你有任何问题，请不要客气与我联络。

65. I hope my clarification has been helpful.
希望我的说明是有帮助的。

66. Please feel free to call me at any time, I will continually provide full support.
请随时跟我联络，我会持续地提供全程支援。

67. Please let me know if this is suitable.
请让我知道这是否恰当。

68. Looking forward to seeing you soon.
期待很快能见到你。

69. We look forward to hearing from you soon.
我们期待很快能得到您的回复。

70. Hope this is clear and we are happy to discuss this further if necessary.
希望上述说明很清楚，如有必要，我们很乐意再进一步讨论。

71. I look forward to receiving your reply soon.
我期待很快能收到你的回复。

72. Looking forward to receiving your comments in due course.
期待在预期的时间收到你的反馈。

73. I’ll keep you posted.
我会与你保持联络。

74. Please keep me informed on the matter.
请随时让我知道这件事的发展。

75. For any comments/suggestions, please contact Nadia at 2552-7482.
任何评价或建议，请打电话2552-7482联络Nadia。

76. I would like to apologize for...
我想就。。。道歉。。。

77. I apologize for the delay in...
对于。。。的耽搁，我深感抱歉。

78. We are sorry for any inconvenience caused.
对于产生任何不便，我们感到抱歉。

79. I am sorry for any inconvenience this has caused you.
对于造成你的任何不便，我感到抱歉。

80. I’m sorry about last time.
关于上次的事我很抱歉。

81.We apologize for not replying you earlier.
对于未能早一点回信给你，我们感到抱歉。

82. I’m really sorry about this.
关于这件事，我真的很抱歉。

83. Sorry, I’m late in replying to your e-mail dated Monday, April 1.
抱歉，太迟回您在4月1日（星期一）发给我的邮件。

84. We apologize for the delay and hope that it doesn’t inconvenience you too much.
我们为耽搁道歉，希望不会给您带来太多的不便。

85.Hoping that this will not cause you too much trouble.
希望不会为您带来太多的麻烦。

86.Sorry if my voice message is not clear enough.
如果我的电话留言不够清楚,我深感抱歉.

87. Thank you for your help.
谢谢你的帮助。

88. I appreciate very much that you...
我非常感激你。。。

89. I truly appreciate it.
我真的很感激。

90. Thank you for your participation.
谢谢你的参加。

91. Thank you so much for inviting me.
非常感谢你要请我。

92.Congratulations to all of you and thanks for your efforts.
恭喜各位并谢谢各位的努力。

93. Your understanding and cooperation is greatly/highly appreciated.
很感激你的理解及合作。

94. Your prompt response will be most appreciated.
很感激你快速的答复。

95. Once again, thank you all for your commitment and support.
再一次感谢你的承诺及支持。

96. Thanks for your input/clarification/message.
谢谢你的投入/澄清/信息。
97. Any comments will be much appreciated.
对于您的任何建议，我将非常感激。

98. Thank you very much for everything you’ve done for me.
谢谢你为我做的一切。

99. I would appreciate your kindest understanding with/regarding this matter.
我很感激你对这件事情的理解。

100. Please convey my thanks to all the staff involved, they certainly did an excellent job.
请表达我的谢意给那些有关的同仁，他们真的干得很好











** SDK    :blog:
软件开发工具包（Software Development Kit, SDK）一般是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等创建应用软件的开发工具的集合。

它或许只是简单的为某个程序设计语言提供应用程序接口的一些文件，但也可能包括能与某种嵌入式系统通讯的复杂的硬件。一般的工具包括用于调试和其他用途的实用工具。SDK还经常包括示例代码、支持性的技术注解或者其他的为基本参考资料澄清疑点的支持文档。

软件工程师通常从目标系统开发者那里获得软件开发包。为了鼓励开发者使用其系统或者语言，许多SDK是免费提供的。SDK经常可以直接从互联网下载。有时也被作为营销手段。例如，甲产品或许会免费提供构件SDK以鼓励人们使用它，从而会吸引更多人由于能免费为其编程而购买其构件。

SDK可能附带了使其不能在不兼容的许可证下开发软件的许可证。例如一个专有的SDK可能与自由软件开发抵触。而GPL能使SDK与专有软件开发近乎不兼容。LGPL下的SDK则没有这个问题。

举例
Microsoft的DirectX SDK
iOS的iOS软件开发工具包
Sun Microsystems的Java SDK
构件工具包
英特尔AMT的SDK
Google的Android SDK

** 缩写词索引    :blog:

** [[http://blog.sina.com.cn/s/blog_7ca994b80101b08l.html][TTL电平与RS232电平]]    :blog:

之前一直没把他们当回事，真正到用的时候才知道，理解他们很重要。
什么是TTL电平、CMOS电平、RS232电平？它们有什么区别呢？一般说来，CMOS电平比TTL电平有着更高的噪声容限。

  （一）、TTL电平标准
输出 L： <0.8V ； H：>2.4V。
输入 L： <1.2V ； H：>2.0V
TTL器件输出低电平要小于0.8V，高电平要大于2.4V。输入，低于1.2V就认为是0，高于2.0就认为是1。于是TTL电平的输入低电平的噪声容限就只有(0.8-0)/2=0.4V，高电平的噪声容限为(5-2.4)/2=1.3V。

  （二）、CMOS电平标准

输出 L： <0.1*Vcc ； H：>0.9*Vcc。
输入 L： <0.3*Vcc ； H：>0.7*Vcc.
由于CMOS电源采用12V，则输入低于3.6V为低电平，噪声容限为1.8V，高于3.5V为高电平，噪声容限高为1.8V。比TTL有更高的噪声容限。

   （三）、RS232标准

逻辑1的电平为-3～-15V，逻辑0的电平为+3～+15V，注意电平的定义反相了一次。

** [[http://blog.csdn.net/yhf19881015/article/details/9048165][非常全的linux面试笔试题及参考答案]]    :blog:


[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

linux开发/（23）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/yhf19881015/article/category/1192537][作者同类文章]]/X/

求职专题/（9）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/yhf19881015/article/category/1588327][作者同类文章]]/X/

一．填空题：\
 1.
在[[http://www.linux521.com/2009/system/][Linux系统]]中,以 文件 方式访问设备
.\
 2. Linux内核引导时,从文件/etc/fstab 中读取要加载的文件系统.\
 3. Linux文件系统中每个文件用 i节点来标识.\
 4. 全部磁盘块由四个部分组成,分别为引导块 、专用块 、 i节点表块
和数据存储块.\
 5. 链接分为： 硬链接 和 符号链接 .\
 6. 超级块包含了i节点表 和 空闲块表等重要的文件系统信息.\
 7.
某文件的权限为：d-rw-_r--_r--,用数值形式表示该权限,则该八进制数为： 644 ,该文件属性是 目录 .\
 8. 前台起动的进程使用 Ctrl c 终止.\
 9.
静态路由设定后,若网络拓扑结构发生变化,需由系统管理员修改路由的设置.\
 10. 网络管理的重要任务是： 控制 和 监控 .\
 11.
安装Linux系统对硬盘分区时,[[http://www.linux521.com/bixu.GIF]]有两种分区类型： 文件系统分区
和 交换分区 .\
 13.
编写的Shell程序运行前[[http://www.linux521.com/bixu.GIF]]赋予该脚本文件 执行 权限.\
 14.
系统管理的任务之一是能够在 分布式 环境中实现对程序和数据的[[http://www.linux521.com/2009/security/][安全]]保护、备份、恢复和更新.\
 15. 系统交换分区是作为系统虚拟存储器 的一块区域.\
 16. 内核分为 进程管理系统 、 内存管理系统 、 I/O管理系统
和文件管理系统 等四个子系统.\
 17. 内核配置是系统管理员在改变系统配置 硬件 时要进行的重要操作.\
 18.
在安装Linux系统中,使用netconfig程序对网络进行配置,该安装程序会一步步提示用户输入主机名、域名、域名服务器、IP地址、 网关地址
和 子网掩码 等必要信息.\
 19. 唯一标识每一个用户的是用户 ID 和用户名.\
 20 . RIP 协议是最为普遍的一种内部协议,一般称为动态路由信息协议.\
 21.
在Linux系统中所有内容都被表示为文件,组织文件的各种方法称为 文件系统 .\
 22. DHCP可以实现动态 IP 地址分配.\
 23. 系统网络管理员的管理对象是服务器、 用户 和服务器的进程
以及系统的各种资源.\
 24.
网络管理通常由监测、传输和管理三部分组成,其中管理部分是整个网络管理的中心.\
 25. 当想删除本系统用不上的 设备驱动程序
时[[http://www.linux521.com/bixu.GIF]]编译内核,当内核不支持系统上的
设备驱动程序 时,[[http://www.linux521.com/bixu.GIF]]对内核 升级 .\
 26 Ping命令可以测试网络中本机系统是否能到达 一台远程主机
,[[http://www.linux521.com/suoyi.GIF]]常常用于测试网络的 连通性 .\
 27. vi编辑器具有两种工作模式： 命令模式 和 输入模式 .\

28. 可以用ls
&ndash;al命令来观察文件的权限,每个文件的权限都用10位表示,并分为四段,其中第一段占
1 位,表示 文件类型 ,第二段占3位,表示 文件所有者 对该文件的权限.

29.
进程与程序的区别在于其动态性,动态的产生和终止,从产生到终止进程可以具有的基本状态为：
运行态 、 就绪态 和 等待态（阻塞态） .\
 30.
DNS实际上是分布在internet上的主机信息的[[http://www.linux521.com/2009/database/][数据库]],其作用是实现
IP地址和主机名 之间的转换.\
 31.
Apache是实现WWW服务器功能的应用程序,即通常所说的浏览web服务器,在服务器端
为用户提供浏览 web服务 的就是apache应用程序.\
 32. 在Linux系统上做备份可以有两种类型：系统备份 和 用户备份
.其中前者是指对 操作系统 的备份,后者是指对 应用程序和用户文件的备份.\
 33. CD-ROM标准的文件系统类型是 iso9660 .\
 34. 当lilo.conf配置完毕后,使之生效,应运行的命令及参数是 lilo .\
 35. 在使用ls命令时,用八进制形式显示非打印字符应使用参数 -b .\
 36. Linux使用支持Windows 9.x/2000长文件名的文件系统的类型是 vfat .\
 37. 设定限制用户使用磁盘空间的命令是 quota .\
 38 在Linux系统中,用来存放系统所需要的配置文件和子目录的目录是 /etc .\
 39. 硬连接只能建立对 文件 链接.符号链接可以跨不同文件系统创建.\
 40. 套接字文件的属性位是 s .\
 41. 结束后台进程的命令是 kill .\
 42. 进程的运行有两种方式,即 独立运行和使用父进程运行 .\
 43. Links分为 硬链接和符号链接 .\
 44. 在超级用户下显示Linux系统中正在运行的全部进程,应使用的命令及参数是
ps -aux .\
 45. 管道文件的属性位是 p .\
 46. 将前一个命令的标准输出作为后一个命令的标准输入,称之为 管道 .\
 47. 为脚本程序指定执行权的命令及参数是 chmod a x filename .\
 48. 进行远程登录的命令是 telnet .\

49.
欲发送10个分组报文测试与主机abc.tuu.edu.cn的连通性,应使用的命令和参数是：
ping abc.tuu.edu.cn &ndash;c 10 .\
 50. DNS服务器的进程命名为named,当其启动时,自动装载 /etc目录下的
named.conf 文件中定义的DNS分区数据库文件.\
 51. Apache服务器进程配置文件是 httpd.conf .52.在
Linux系统中,压缩文件后生成后缀为.gz文件的命令是 gzip .\
 53. 在用vi编辑文件时,将文件内容存入test.txt文件中,应在命令模式下键入
：w test.txt .\
 54 可以在标准输出上显示整年日历的命令及参数是 cal -y .\
 55.
在shell编程时,使用方括号表示测试条件的规则是：方括号两边[[http://www.linux521.com/bixu.GIF]]有
空格 .\
 56.
检查已安装的文件系统/dev/had5是否正常,若检查有错,则自动修复,其命令及参数是
fsck &ndash;a /dev/had5 .\
 57. 在Windows9.x环境下共享Unix/Linux中的用户目录的一个工具是
Samba服务器 .\
 58.
系统管理员的职责是进行系统资源管理、系统性能管理、设备管理、安全管理和
系统性能监测 .\
 59
在Linux系统中,测试DNS服务器是否能够正确解析域名的的客户端命令,使用命令
nslookup .\
 60. 在Linux系统下,第二个IDE通道的硬盘（从盘）被标识为 hdb .\
 61. 当系统管理员需升级内核版本和改变系统硬件配置时,应 重新编译内核 .\
 62. 如果只是要修改系统的IP地址,应修改 /etc/rc.d/rc.inet1 配置文件.\
 63.
当LAN内没有条件建立DNS服务器,但又想让局域网内的用户可以使用计算机名互相访问时,应配置
/etc/hosts 文件.\
 64. 在vi编辑环境下,使用 Esc键 进行模式转换.\
 65. Slackware Linux 9.0通常使用 ext3 文件系统,系统的全部磁盘块由 四
部分组成.\
 66.
将/home/stud1/wang目录做归档压缩,压缩后生成wang.tar.gz文件,并将此文件保存到/home目录下,实现此任务的tar命令格式
tar zcvf /home/wang.tar.gz /home/stud1/wang .\

67. 管道就是将前一个命令的 标准输出 作为后一个命令的 标准输入 .\
 68. 在使用手工的方法配置网络时,可通过修改 /etc/HOSTNAME
文件来改变主机名,若要配置该计算机的域名解析客户端,需配置
/etc/resolv.conf 文件.\
 69. 启动进程有手动启动和调度启动两种方法,其中调度启动常用的命令为 at 、
batch 和 crontab .\
 70. test.bns.com.cn的域名是 bns.com.cn ,如果要配置一域名服务器,应在
named.conf 文件中定义DNS数据库的工作目录.\
 71. Sendmail邮件系统使用的两个主要协议是： SMTP 和 POP
,前者用来发送邮件,后者用来接收邮件.\
 72. DHCP是动态主机配置协议的简称,其作用是：为网络中的主机分配IP地址 .\
 73. 目前代理服务器使用的软件包有很多种,教材中使用的是 squid .\
 74. rm命令可删除文件或目录,其主要差别就是是否使用递归开关 -r或-R .\
 75. mv 命令可以移动文件和目录,还可以为文件和目录重新命名.\
 76.
路由选择协议（RIP）的跳数表示到达目的地之前[[http://www.linux521.com/bixu.GIF]]通过的
网关 数,RIP接受的最长距离是 15跳 .\
 77. ping命令用于测试网络的连通性,ping命令通过 ICMP
协议（internet控制信息协议）来实现.\
 78. nfs 协议用于实现Unix（/linux）主机之间的文件系统共享.\
 79. 在Linux操作系统中,设备都是通过特殊的 文件 来访问.\
 80. shell不仅是 用户命令的解释器 ,它同时也是一种功能强大的编程语言.
bash是Linux的缺省shell.\
 81. 用 〉;〉; 符号将输出重定向内容附加在原文的后面.\
 82. 增加一个用户的命令是：adduser 或useradd .\
 83 进行字符串查找,使用grep命令.\
 84. 使用 * 每次匹配若干个字符.\
 85. /sbin 目录用来存放系统管理员使用的管理程序.

\

二．单项选择题:\

1. 下面的网络协议中,面向连接的的协议是： A .\
 A 传输控制协议 B 用户数据报协议 C 网际协议 D 网际控制报文协议\
 2. 在/etc/fstab文件中指定的文件系统加载参数中, D
参数一般用于CD-ROM等移动设备.\
 A defaults B sw C rw和ro D noauto\
 3. Linux文件权限一共10位长度,分成四段,第三段表示的内容是 C .\
 A 文件类型 B 文件所有者的权限 \
 C 文件所有者所在组的权限 D 其他用户的权限\
 4. 终止一个前台进程可能用到的命令和操作 B .\
 A kill B 〈CTRL〉; C C shut down D halt\
 5．在使用mkdir命令创建新的目录时,在其父目录不存在时先创建父目录的选项是
D .\
 A -m B -d C -f D -p\
 6. 下面关于i节点描述错误的是
A .（inode是一种数据结构,vfs中描述文件的相关参数？？）\
 A i节点和文件是一一对应的\
 B i节点能描述文件占用的块数\
 C i节点描述了文件大小和指向数据块的指针\
 D 通过i节点实现文件的逻辑结构和物理结构的转换\
 7. 一个文件名字为rr.Z,可以用来解压缩的命令是： D .\
 A tar B gzip C compress D uncompress\
 8. 具有很多C语言的功能,又称过滤器的是 C .\
 A csh\
 B tcsh\
 C awk　　（awk详解）\
 D sed\
 9. 一台主机要实现通过局域网与另一个局域网通信,需要做的工作是 C .A
配置域名服务器\
 B 定义一条本机指向所在网络的路由\
 C 定义一条本机指向所在网络网关的路由\
 D 定义一条本机指向目标网络网关的路由\
 10. 建立动态路由需要用到的文件有 D .\
 A /etc/hosts B /etc/HOSTNAME C /etc/resolv.conf D /etc/gateways\
 11.
局域网的网络地址192.168.1.0/24,局域网络连接其它网络的网关地址是192.168.1.1.主机192.168.1.20访问172.16.1.0/24网络时,其路由设置正确的是
B .\

A route add &ndash;net 192.168.1.0 gw 192.168.1.1 netmask 255.255.255.0
metric 1\
 B route add &ndash;net 172.16.1.0 gw 192.168.1.1 netmask
255.255.255.255 metric 1\
 C route add &ndash;net 172.16.1.0 gw 172.16.1.1 netmask 255.255.255.0
metric 1\
 D route add default 192.168.1.0 netmask 172.168.1.1 metric 1\
 12. 下列提法中,不属于ifconfig命令作用范围的是 D .\
 A 配置本地回环地址 B 配置网卡的IP地址\
 C 激活网络适配器 D 加载网卡到内核中\
 13. 下列关于链接描述,错误的是 B .\
 A 硬链接就是让链接文件的i节点号指向被链接文件的i节点\
 B 硬链接和符号连接都是产生一个新的i节点\
 C 链接分为硬链接和符号链接 D 硬连接不能链接目录文件\
 14.
在局域网络内的某台主机用ping命令测试网络连接时发现网络内部的主机都可以连同,而不能与公网连通,问题可能是
C.\
 A 主机IP设置有误\
 B 没有设置连接局域网的网关\
 C 局域网的网关或主机的网关设置有误\
 D 局域网DNS服务器设置有误\
 15. 下列文件中,包含了主机名到IP地址的映射关系的文件是： B .\
 A /etc/HOSTNAME B /etc/hosts C /etc/resolv.conf D /etc/networks\
 16. 不需要编译内核的情况是 D .\
 A 删除系统不用的设备驱动程序时 B 升级内核时\
 C 添加新硬件时 D 将网卡激活\
 17. 在shell中变量的赋值有四种方法,其中,采用name=12的方法称 A .\
 A 直接赋值 B使用read命令\
 C 使用命令行参数 D使用命令的输出\
 18. D 命令可以从文本文件的每一行中截取指定内容的数据.\
 A cp B dd C fmt D cut\
 19. 下列不是Linux系统进程类型的是 D .\
 A 交互进程 B 批处理进程 C 守护进程 D 就绪进程（进程状态）\
 20．配置Apache 1.3.19服务器需要修改的配置文件为___A______\

A httpd.conf B access.conf C srm.conf D named.conf\
 21. 内核不包括的子系统是 D .\
 A 进程管理系统 B 内存管理系统 C I/O管理系统 D硬件管理系统\
 22． 在日常管理中,通常CPU会影响系统性能的情况是： A .\
 A CPU已满负荷地运转 B CPU的运行效率为30%\
 C CPU的运行效率为50% D CPU的运行效率为80%\
 23． 若一台计算机的内存为128MB,则交换分区的大小通常是 C .\
 A 64MB B 128MB C 256MB D 512MB\
 24．
在安装Linux的过程中的第五步是让用户选择安装方式,如果用户希望安装部分组件（软件程序）,并在选择好后让系统自动安装,应该选择的选项是
D .\
 A full B expert C newbie D menu\
 25．
Linux有三个查看文件的命令,若希望在查看文件内容过程中可以用光标上下移动来查看文件内容,应使用
C 命令.\
 A cat B more C less D menu\
 26． 下列信息是某系统用ps &ndash;ef命令列出的正在运行的进程, D
进程是运行Internet超级服务器,它负责监听Internet
sockets上的连接,并调用合适的服务器来处理接收的信息.\
 A root 1 4.0 0.0 344 204? S 17:09 0:00 init \
 B root 2 0.0 0.1 2916 1520? S 17:09 0:00 /sbin/getty \
 C root 3 0.0 0.2 1364 632? S 17:09 0:00 /usr/sbin/syslogd \
 D root 4 0.0 1344 1204? S 17:09 0:10 /usr/sbin/inetd \
 27．在TCP/IP模型中,应用层包含了所有的高层协议,在下列的一些应用协议中, B
是能够实现本地与远程主机之间的文件传输工作.\
 A telnet B FTP C SNMP D NFS \

28．当我们与某远程网络连接不上时,就需要跟踪路由查看,以便了解在网络的什么位置出现了问题,满足该目的的命令是
C .\
 A ping B ifconfig C traceroute D netstat\
 29．对名为fido的文件用chmod 551 fido 进行了修改,则它的许可权是 D .\

A -rwxr-xr-x B -rwxr--r-- C -r--r--r-- D -r-xr-x-x\
 30．
在i节点表中的磁盘地址表中,若一个文件的长度是从磁盘地址表的第1块到第11块,则该文件共占有
B 块号.\
 A 256 B 266 C 11 D 256&times;10\
 (??)31． 用ls &ndash;al 命令列出下面的文件列表, D 文件是符号连接文件.\
 A -rw-rw-rw- 2 hel-s users 56 Sep 09 11:05 hello\
 B -rwxrwxrwx 2 hel-s users 56 Sep 09 11:05 goodbey\
 C drwxr--r-- 1 hel users 1024 Sep 10 08:10 zhangD lrwxr--r-- 1 hel
users 2024 Sep 12 08:12 cheng\
 32． DNS域名系统主要负责主机名和 A 之间的解析.\
 A IP地址 B MAC地址 C 网络地址 D 主机别名\
 33． WWW服务器是在Internet上使用最为广泛,它采用的是 B 结构.\
 A 服务器/工作站 B B/S C 集中式 D 分布式\
 34．Linux系统通过 C 命令给其他用户发消息.\
 A less B mesg y C write D echo to[ 注：mesg [y|n] 所有使用者
决定是否允许其他人传讯息到自己的终端机介面 ]\
\
\
 35．NFS是 C 系统.\
 A 文件 B 磁盘 C 网络文件 D 操作\
 36． B 命令可以在Linux的安全系统中完成文件向磁带备份的工作.\
 A cp B tr C dir D cpio[注：如果用 echo /home/wally/Program/phantomjs/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/texlive/2015/bin/x86_64-linux:/opt/crosstool-ng/bin:/home/wally/.x-tools/arm-wally-linux-gnueabi/bin:/usr/local/libexec/emacs/24.5/x86_64-unknown-linux-gnu 或者 echo
_LIBRARY_PATH
等类似的命令来显示路径信息的话,我们看到的将会是一大堆用冒号连接在一起的路径,
tr 命令可以把这些冒号转换为回车,这样,这些路径就具有很好的可读性了：\
 echo /home/wally/Program/phantomjs/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/texlive/2015/bin/x86_64-linux:/opt/crosstool-ng/bin:/home/wally/.x-tools/arm-wally-linux-gnueabi/bin:/usr/local/libexec/emacs/24.5/x86_64-unknown-linux-gnu | tr &quot;:&quot; &quot;&#92;n&quot;]\

37．Linux文件系统的文件都按其作用分门别类地放在相关的目录中,对于外部设备文件,一般应将其放在
C 目录中.\
 A /bin B /etc C /dev D /lib \
 38．在重新启动Linux系统的同时把内存中的信息写入硬盘,应使用 D
命令实现.\

A # reboot B # halt C # reboot D # shutdown &ndash;r now\
 39．网络管理具备以下几大功能：配置管理、 A
、性能管理、安全管理和计费管理等.\
 A 故障管理 B 日常备份管理 C 升级管理 D 发送邮件\
 40．关于代理服务器的论述,正确的是 A .\
 A 使用internet上已有的公开代理服务器,只需配置客户端.\
 B 代理服务器只能代理客户端http的请求.\
 C 设置好的代理服务器可以被网络上任何主机使用.\
 D 使用代理服务器的客户端没有自己的ip地址.\
 41.关闭linux系统（不重新启动）可使用命令 B .\
 A Ctrl Alt Del B halt C shutdown -r now D reboot\
 42．实现从IP地址到以太网MAC地址转换的命令为： C .\
 A ping B ifconfig C arp D traceroute\
 43．在vi编辑器中的命令模式下,键入 B 可在光标当前所在行下添加一新行.\
 A 〈a〉; B 〈o〉; C 〈I〉; D A\
 44．在vi编辑器中的命令模式下,删除当前光标处的字符使用 A 命令.\
 A 〈x〉; B 〈d〉;〈w〉; C 〈D〉; D 〈d〉;〈d〉;\
 45．在vi编辑器中的命令模式下,重复上一次对编辑的文本进行的操作,可使用 C
命令.\
 A 上箭头 B 下箭头 C 〈.〉; D 〈*〉;\
 46．用命令ls -al显示出文件ff的描述如下所示,由此可知文件ff的类型为 A .\
 -rwxr-xr-- 1 root root 599 Cec 10 17:12 ff\
 A 普通文件 B 硬链接 C 目录 D 符号链接\
 47．删除文件命令为： D .\
 A mkdir B rmdir C mv D rm\
 48．在下列的名称中,不属于DNS服务器类型的是：____C_____\
 A Primary Master Server B Secondary Master Server\
 C samba D Cache_only Server\
 49．网络管理员对WWW服务器进行访问、控制存取和运行等控制,这些控制可在 A
文件中体现.\
 A httpd.conf B lilo.conf C inetd.conf D resolv.conf\

50．邮件转发代理也称邮件转发服务器,它可以使用SMTP协议,也可以使用 C
协议. \
 A FTP B TCP C UUCP D POP\

51．启动samba服务器进程,可以有两种方式：独立启动方式和父进程启动方式,其中前者是在
C 文件中以独立进程方式启动.\
 A /usr/sbin/smbd B /usr/sbin/nmbd C rc.samba D /etc/inetd.conf\

52．DHCP是动态主机配置协议的简称,其作用是可以使网络管理员通过一台服务器来管理一个网络系统,自动地为一个网络中的主机分配___D______地址.\
 A 网络 B MAC C TCP D IP\
 53．为了保证在启动服务器时自动启动DHCP进程,应将
A文件中的dhcpd=no改为dhcpd=yes. \
 A rc.inet1 B lilo.conf C inetd.conf D httpd.conf[注：
英文原义：RC中文释义：含有程序（应用程序甚至操作系统）启动指令的脚本文件注解：这一文件在操作系统启动时会自动执行,它含有要运行的指令（命令或其它脚本）列表.]\
 54．对文件进行归档的命令为 D .\
 A dd B cpio C gzip D tar\
 55．改变文件所有者的命令为 C .\
 A chmod B touch C chown D cat\
 56．在给定文件中查找与设定条件相符字符串的命令为： A .\
 A grep B gzip C find D sort\
 57．建立一个新文件可以使用的命令为 D .\
 A chmod B more C cp D touch(指令改变档案的时间记录.)\
 58．在下列命令中,不能显示文本文件内容的命令是： D . \
 A more B less C tail D join\
 59．在使用匿名登录ftp时,用户名为 B .\
 A users B anonymous C root D guest\
 60．在实际操作中,想了解命令logname 的用法,可以键入 D 得到帮助.\
 A logname --man B logname/？ C help logname D logname --help\
 61．如果LILO被安装在MBR,使用 A 命令即可卸载LILO.\
 A lilo &ndash;u B lilo &ndash;c C lilo &ndash;v D lilo -V\

62．当用命令ls
&ndash;al查看文件和目录时,欲观看卷过屏幕的内容,应使用组合键 D .\
 A Shift Home B Ctrl PgUp C Alt PgDn D Shift PgUp\
 63．mc是UNIX风格操作系统的 C .\
 A 文件编辑器/程序编译器 B 配置网络的窗口工具 \
 C 目录浏览器/文件管理器 D Samba服务器管理工具\
 64．i节点是一个 D 长的表,表中包含了文件的相关信息.A 8字节 B 16字节 C
32字节 D 64字节\
 65．文件权限读、写、执行的三种标志符号依次是 A .\
 A rwx B xrw C rdx D srw\
 66．Linux 文件名的长度不得超过 C 个字符.\
 A 64 B 128 C 256 D 512\
 67．进程有三种状态： C .\
 A 准备态、执行态和退出态 B 精确态、模糊态和随机态\
 C 运行态、就绪态和等待态 D 手工态、自动态和自由态\
 68． 从后台启动进程,应在命令的结尾加上符号 A .\
 A &amp; B @ C # D $\
 69． B 不是邮件系统的组成部分.\
 A 用户代理 B 代理服务器 C 传输代理 D 投递代理\

70．在Shell脚本中,用来读取文件内各个域的内容并将其赋值给Shell变量的命令是
D .\
 A fold B join C tr D read\
 71．crontab文件由六个域组成,每个域之间用空格分割,其排列如下： B .\
 A MIN HOUR DAY MONTH YEAR COMMAND\
 B MIN HOUR DAY MONTH DAYOFWEEK COMMAND\
 C COMMAND HOUR DAY MONTH DAYOFWEEK \
 D COMMAND YEAR MONTH DAY HOUR MINcrontab命令：实现程序定时运行\
 72．用ftp进行文件传输时,有两种模式： C .\
 A Word和binary B .txt和Word Document \
 C ASCII和binary D ASCII和Rich Text Format\

73．某文件的组外成员的权限为只读；所有者有全部权限；组内的权限为读与写,则该文件的权限为
D .\
 A 467 B 674 C 476 D 764\
 74．在DNS系统测试时,设named进程号是53,命令 D 通知进程重读配置文件.\

A kill &ndash;USR2 53 B kill &ndash;USR1 53 C kill -INT 63 D kill
&ndash;HUP 53\
 75．Apache服务器默认的接听连接端口号是 C .\
 A 1024 B 800 C 80 (http)D 8\
 76．PHP和MySQL的联合使用解决了 C .\
 A 在Proxy上处理数据库的访问问题 B 在WWW服务器上处理黑客的非法访问问题\
 C 在WWW服务器上处理数据库的访问问题\
 D 在Sendmail邮件系统上处理数据库的访问问题\
 77．OpenSSL是一个 A .\
 A 加密软件 B 邮件系统 C 数据库管理系统 D 嵌入式脚本编程语言\
 78．Samba服务器的配置文件是 D .\
 A httpd.conf B inetd.conf C rc.samba D smb.conf\
 79．关于DNS服务器,叙述正确的是 D .\
 A DNS服务器配置不需要配置客户端\
 B 建立某个分区的DNS服务器时只需要建立一个主DNS服务器\
 C 主DNS服务器需要启动named进程,而辅DNS服务器不需要\
 D DNS服务器的root.cache文件包含了根名字服务器的有关信息\
 80．退出交互模式的shell,应键入 C .\
 A 〈Esc〉; B \^q C exit D quit\
 81．将Windows C:盘(hda1)安装在Linux文件系统的/winsys目录下,命令是 B .\
 A root@l04.edu.cn:~#mount dev/had1 /winsys \
 B root@l04.edu.cn:~#mount /dev/had1 /winsys\
 C root@l04.edu.cn:~#mount /dev/had1 winsys\
 D root@l04.edu.cn:~#mount dev/had1 winsys\

82．设超级用户root当前所在目录为：/usr/local,键入cd命令后,用户当前所在目录为
B .\
 A /home B /root C /home/root D /usr/local\
 83．字符设备文件类型的标志是 B .\
 A p B c C s D l\
 84．将光盘CD-ROM（hdc）安装到文件系统的/mnt/cdrom目录下的命令是 C .\

A mount /mnt/cdrom B mount /mnt/cdrom /dev/hdc\
 C mount /dev/hdc /mnt/cdrom D mount /dev/hdc\
 85．将光盘/dev/hdc卸载的命令是 C .\
 A umount /dev/hdc B unmount /dev/hdc\
 C umount /mnt/cdrom /dev/hdc D unmount /mnt/cdrom /dev/hdc\
 86．在/home/stud1/wang目录下有一文件file,使用 D
可实现在后台执行命令,此命令将file文件中的内容输出到file.copy文件中.\
 A cat file 〉;file.copy B cat 〉;file.copy C cat file file.copy &amp; D
cat file 〉;file.copy &amp;\
 87．在DNS配置文件中,用于表示某主机别名的是： B .\
 A NS B CNAME C NAME D CN\
 88．可以完成主机名与IP地址的正向解析和反向解析任务的命令是： A .\
 A nslookup B arp C ifconfig D dnslook\
 89．下列变量名中有效的shell变量名是： C .\
 A -2-time B _2 C trust_no_1 D 2004file\
 90．qmail是 B .\
 A 收取邮件的协议 B 邮件服务器的一种 C 发送邮件的协议 D 邮件队列\

92．已知某用户stud1,其用户目录为/home/stud1.分页显示当前目录下的所有文件的文件或目录名、用户组、用户、文件大小、文件或目录权限、文件创建时间等信息的命令是
D .\
 A more ls &ndash;al B more &ndash;al ls C more 〈 ls &ndash;al D ls
&ndash;al | more \
 93．关于进程调度命令, B 是不正确的.at--定期执行程序的调度命令\
 A 当日晚11点执行clear命令,使用at命令：at 23:00 today clearB
每年1月1日早上6点执行date命令,使用at命令：at 6am Jan 1 date\
 C 每日晚11点执行date命令,crontab文件中应为：0 23 * * * date\
 D 每小时执行一次clear命令,crontab文件中应为：0 */1 * * * clear\

94．系统中有用户user1和user2,同属于users组.在user1用户目录下有一文件file1,它拥有644的权限,如果user2用户想修改user1用户目录下的file1文件,应拥有
B 权限.\

A 744 B 664 C 646 D 746\
 95．如果想配置一台匿名ftp服务器,应修改 C 文件.\
 A /etc/gateway B /etc/ftpservers C /etc/ftpusers D /etc/inetd.conf\
 96．Samba服务器的进程由B 两部分组成 .\
 A named和sendmail B smbd和nmbd C bootp和dhcpd D httpd和squid\
 97．要配置NFS服务器,在服务器端主要配置 C 文件.\
 A /etc/rc.d/rc.inet1 B /etc/rc.d/rc.M C /etc/exports D /etc/rc.d/rc.S\
 98．为保证在启动服务器时自动启动DHCP进程,应对 B 文件进行编辑.\
 A /etc/rc.d/rc.inet2 B /etc/rc.d/rc.inet1 C /etc/dhcpd.conf D
/etc/rc.d/rc.S\
 99．在配置代理服务器时,若设置代理服务器的工作缓存为64MB,配置行应为 D
.\
 A cache 64MB B cache_dir ufs /usr/local/squid/cache 10000 16 256\
 C cache_ mgr 64MB D cache_ mem 64MB\

100．安全管理涉及的问题包括保证网络管理工作可靠进行的安全问题和保护网络用户及网络管理对象问题.
C 属于安全管理的内容.\
 A 配置设备的工作参数 B 收集与网络性能有关的数据 \
 C 控制和维护访问权限 D 监测故障\
 101．以下命令对中,正确的是： B .\
 A ls和sl B cat和tac C more和erom D
exit和tixecat是显示文件夹的命令,这个大家都知道,tac是cat的倒写,意思也和它是相反的.cat是从第一行显示到[[http://www.linux521.com/zuihou.GIF]]一行,而tac是从[[http://www.linux521.com/zuihou.GIF]]一行显示到第一行,而rev
则是从[[http://www.linux521.com/zuihou.GIF]]一个字符显示到第一个字符\
 102． B 命令是在vi编辑器中执行存盘退出.\
 A :q B ZZ C :q! D :WQ\
 103．下列关于/etc/fstab文件描述,正确的是 D .\
 A fstab文件只能描述属于linux的文件系统 B
CD_ROM和软盘[[http://www.linux521.com/bixu.GIF]]是自动加载的\
 C fstab文件中描述的文件系统不能被卸载 D
启动时按fstab文件描述内容加载文件系统\
 104．通过文件名存取文件时,文件系统内部的操作过程是通过 C .\

A 文件在目录中查找文件数据存取位置.B
文件名直接找到文件的数据,进行存取操作.\
 C 文件名在目录中查找对应的I节点,通过I节点存取文件数据.\
 D
文件名在中查找对应的超级块,在超级块查找对应i节点,通过i节点存取文件数据\
 105．Linux将存储设备和输入/输出设备均看做文件来操作, C
不是以文件的形式出现.\
 A 目录 B 软链接 C i节点表 D 网络适配器\
 106．关于i节点和超级块,下列论述不正确的是 B .\
 A i节点是一个长度固定的表 B 超级块在文件系统的个数是唯一的\
 C i节点包含了描述一个文件所必需的全部信息\
 D 超级块记录了i节点表和空闲块表信息在磁盘中存放的位置\
 107． D 设备是字符设备.\
 A hdc B fd0 C hda1 D tty1(A,B,C为块设备)\
 108． B 目录存放着Linux的源代码.\
 A /etc B /usr/src C /usr D /home\
 109．关于文件系统的安装和卸载,下面描述正确的是 A .\
 A 如果光盘未经卸载,光驱是打不开的 B 安装文件系统的安装点只能是/mnt下\
 C 不管光驱中是否有光盘,系统都可以安装CD-ROM设备\
 D mount /dev/fd0 /floppy 此命令中目录/floppy是自动生成的\
 110． B 不是进程和程序的区别.\
 A 程序是一组有序的静态指令,进程是一次程序的执行过程\
 B 程序只能在前台运行,而进程可以在前台或后台运行\
 C 程序可以长期保存,进程是暂时的\
 D 程序没有状态,而进程是有状态的\

111．文件exer1的访问权限为rw-r--r--,现要增加所有用户的执行权限和同组用户的写权限,下列命令正确的是
A .\
 A chmod a x g w exer1 B chmod 765 exer1\
 C chmod o x exer1 D chmod g w exer1\
 112．有关归档和压缩命令,下面描述正确的是 C .\

A 用uncompress命令解压缩由compress命令生成的后缀为.zip的压缩文件\
 B unzip命令和gzip命令可以解压缩相同类型的文件\
 C tar归档且压缩的文件可以由gzip命令解压缩\
 D tar命令归档后的文件也是一种压缩文件\
 113．不是shell具有的功能和特点的是 C .\
 A 管道 B 输入输出重定向 C 执行后台进程 D 处理程序命令\
 114．下列对shell变量FRUIT操作,正确的是： C .\
 A 为变量赋值：=apple B 显示变量的值：fruit=apple\
 C 显示变量的值：echo  D 判断变量是否有值：[ -f  ]\
 三．简答题：\

1．简述Linux文件系统通过i节点把文件的逻辑结构和物理结构转换的工作过程.\
 参考答案：\
 Linux通过i节点表将文件的逻辑结构和物理结构进行转换.\
 i
节点是一个64字节长的表,表中包含了文件的相关信息,其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息.在i节点表中最重要
的内容是磁盘地址表.在磁盘地址表中有13个块号,文件将以块号在磁盘地址表中出现的顺序依次读取相应的块.Linux文件系统通过把i节点和文件名进行
连接,当需要读取该文件时,文件系统在当前目录表中查找该文件名对应的项,由此得到该文件相对应的i节点号,通过该i节点的磁盘地址表把分散存放的文件物
理块连接成文件的逻辑结构.2．简述进程的启动、终止的方式以及如何进行进程的查看.\
 参考答案：\
 在Linux中启动一个进程有手工启动和调度启动两种方式：\
 （1）手工启动\
 用户在输入端发出命令,直接启动一个进程的启动方式.可以分为：\

①前台启动：直接在SHELL中输入命令进行启动.\
 ②后台启动：启动一个目前并不紧急的进程,如打印进程.\
 （2）调度启动\

系统管理员根据系统资源和进程占用资源的情况,事先进行调度安排,指定任务运行的时间和场合,到时候系统会自动完成该任务.\
 经常使用的进程调度命令为：at、batch、crontab.\
 3. 简述DNS进行域名解析的过程.\
 参考答案：\

[[http://www.linux521.com/shouxian.GIF]],客户端发出DNS请求翻译IP地址或主机名.DNS服务器在收到客户机的请求后：\

（1）检查DNS服务器的缓存,若查到请求的地址或名字,即向客户机发出应答信息；\

（2）若没有查到,则在数据库中查找,若查到请求的地址或名字,即向客户机发出应答信息；\

（3）若没有查到,则将请求发给根域DNS服务器,并依序从根域查找顶级域,由顶级查找二级域,二级域查找三级,直至找到要解析的地址或名字,即向客户机所在网络的DNS服务器发出应答信息,DNS服务器收到应答后现在缓存中存储,然后,将解析结果发给客户机.\

（4）若没有找到,则返回错误信息.4．系统管理员的职责包括那些？管理的对象是什么？\
 参考答案：\

系统管理员的职责是进行系统资源管理、设备管理、系统性能管理、安全管理和系统性能监测.管理的对象是服务器、用户、服务器的进程及系统的各种资源等.\
 5．简述安装Slackware Linux系统的过程.\
 参考答案： \
 （1）对硬盘重新分区. （2）启动Linux系统（用光盘、软盘等）.\
 （3）建立Linux主分区和交换分区.（4）用setup命令安装Linux系统.\
 （5）格式化Linux主分区和交换分区（6）安装Linux软件包\

（7）安装完毕,建立从硬盘启动Linux系统的LILO启动程序,或者制作一张启动Linux系统的软盘.重新启动Linux系统.\

6．什么是静态路由,其特点是什么？什么是动态路由,其特点是什么？\
 参考答案：\

静态路由是由系统管理员设计与构建的路由表规定的路由.适用于网关数量有限的场合,且网络拓朴结构不经常变化的网络.其缺点是不能动态地适用网络状况的变化,当网络状况变化后[[http://www.linux521.com/bixu.GIF]]由网络管理员修改路由表.\

动态路由是由路由选择协议而动态构建的,路由协议之间通过交换各自所拥有的路由信息实时更新路由表的内容.动态路由可以自动学习网络的拓朴结构,并更新路由表.其缺点是路由广播更新信息将占据大量的网络带宽.\
 87．进程的查看和调度分别使用什么命令？\
 参考答案：\
 进程查看的命令是ps和top.\
 进程调度的命令有at,crontab,batch,kill.\
 8．当文件系统受到破坏时,如何检查和修复系统？\
 参考答案：\

成功修复文件系统的前提是要有两个以上的主文件系统,并保证在修复之前[[http://www.linux521.com/shouxian.GIF]]卸载将被修复的文件系统.\

使用命令fsck对受到破坏的文件系统进行修复.fsck检查文件系统分为5步,每一步检查系统不同部分的连接特性并对上一步进行验证和修改.在执行
fsck命令时,检查[[http://www.linux521.com/shouxian.GIF]]从超级块开始,然后是分配的磁盘块、路径名、目录的连接性、链接数目以及空闲块链表、i-node.\
 9．解释i节点在文件系统中的作用.\
 参考答案：\

在linux文件系统中,是以块为单位存储信息的,为了找到某一个文件在存储空间中存放的位置,用i节点对一个文件进行索引.I节点包含了描述一个文件所[[http://www.linux521.com/bixu.GIF]]的全部信息.[[http://www.linux521.com/suoyi.GIF]]i节点是文件系统管理的一个数据结构.\
 10．什么是符号链接,什么是硬链接？符号链接与硬链接的区别是什么？\

参考答案：\
 链接分硬链接和符号链接.\

符号链接可以建立对于文件和目录的链接.符号链接可以跨文件系统,即可以跨磁盘分区.符号链接的文件类型位是l,链接文件具有新的i节点.\

硬链接不可以跨文件系统.它只能建立对文件的链接,硬链接的文件类型位是－,且硬链接文件的i节点同被链接文件的i节点相同.\

11．在对linux系统分区进行格式化时需要对磁盘簇（或i节点密度）的大小进行选择,请说明选择的原则.\
 参考答案：\

磁盘簇（或i节点密度）是文件系统调度文件的基本单元.磁盘簇的大小,直接影响系统调度磁盘空间效率.当磁盘分区较大时,磁盘簇也应选得大些；当分区较小时,磁盘簇应选得小些.通常使用经验值.\
 12．简述网络文件系统NFS,并说明其作用.\
 参考答案：\

网络文件系统是应用层的一种应用服务,它主要应用于Linux和Linux系统、Linux和Unix系统之间的文件或目录的共享.对于用户而言可以通过
NFS方便的访问远地的文件系统,使之成为本地文件系统的一部分.采用NFS之后省去了登录的过程,方便了用户访问系统资源.13．某/etc
/fstab文件中的某行如下：

\
 /dev/had5 /mnt/dosdata msdos defaults,usrquota 1 2\
 请解释其含义.\
 参考答案:\
 （1）第一列：将被加载的文件系统名；（2）第二列：该文件系统的安装点；\
 （3）第三列：文件系统的类型；（4）第四列：设置参数；\
 （5）第五列：供备份程序确定上次备份距现在的天数；\
 （6）第六列：在系统引导时检测文件系统的顺序.\
 14．Apache服务器的配置文件httpd.conf中有很多内容,请解释如下配置项：\
 （1）MaxKeepAliveRequests 200 （2）UserDir public_html\

  3）DefaultType text/plain （4）AddLanguare en.en\
 （5）DocumentRoot/usr/local/httpd/htdocs\
 （6）AddType application/x-httpd-php.php.php.php4\
 参考答案:\

（1）允许每次连接的最大请求数目,此为200；（2）设定用户放置网页的目录；\
 （3）设置服务器对于不认识的文件类型的预设格式；\

（4）设置可传送语言的文件给浏览器；（5）该目录为Apache放置网页的地方；\
 （6）服务器选择使用php4.\

15．某Linux主机的/etc/rc.d/rc.inet1文件中有如下语句,请修正错误,并解释其内容.\
 /etc/rc.d/rc.inet1：\
 &hellip;&hellip;\
 ROUTE add &ndash;net default gw 192.168.0.101 netmask 255.255.0.0
metric 1\
 ROUTE add &ndash;net 192.168.1.0 gw 192.168.0.250 netmask 255.255.0.0
metric 1\
 参考答案:\
 修正错误:\
 （1）ROUTE应改为小写：route；（2）netmask 255.255.0.0应改为:netmask
255.255.255.0；\
 （3）缺省路由的子网掩码应改为:netmask 0.0.0.0；\

（4）缺省路由[[http://www.linux521.com/bixu.GIF]]在[[http://www.linux521.com/zuihou.GIF]]设定,否则其后的路由将无效.\
 解释内容:\
 （1）route：建立静态路由表的命令；（2）add：增加一条新路由；\
 （3）-net 192.168.1.0：到达一个目标网络的网络地址；\
 （4）default：建立一条缺省路由；（5）gw 192.168.0.101：网关地址；\
 （6）metric
1：到达目标网络经过的路由器数（跳数）.16．试解释apache服务器以下配置的含义： \
 （1）port 1080 （2）UserDir userdoc\
 （3）DocumentRoot /home/htdocs\
 （4）〈Directory /home/htdocs/inside〉;\
 Options Indexes FollowSymLinks\
 AllowOverride None\
 Order deny,allow\
 deny from all\
 allow from 192.168.1.5\
 〈/Directory〉;\
 （5）Server Type Standlone\

Apache服务器配置行含义如下： \
 （1）将apache服务器的端口号设定为1080；\
 （2）设定用户网页目录为userdoc；\
 （3）设定apache服务器的网页根目录:/home/htdocs；\

（4）在此apache服务器上设定一个目录/home/htdocs/inside,且此目录只允许IP地址为192.168.1.5的主机访问；\
 （5）定义apache服务器以独立进程的方式运行.\

17．简述使用ftp进行文件传输时的两种登录方式？它们的区别是什么？常用的ftp文件传输命令是什么？ \
 参考答案：\

（1）ftp有两种登录方式：匿名登录和授权登录.使用匿名登录时,用户名为：anonymous,密码为：任何合法email地址；使用授权登录时,用户名为用户在远程系统中的用户帐号,密码为用户在远程系统中的用户密码.\

区别：使用匿名登录只能访问ftp目录下的资源,默认配置下只能下载；而授权登录访问的权限大于匿名登录,且上载、下载均可.\

（2）ftp文件传输有两种文件传输模式：ASCII模式和binary模式.ASCII模式用来传输文本文件,其他文件的传输使用binary模式.\

（3）常用的ftp文件传输命令为：bin、asc、put、get、mput、mget、prompt、bye\: openFile: invalid argument (File name too long)

** [[http://blog.csdn.net/kof2001kop/article/details/7425186][在函数内定义“局部函数”]]    :blog:



[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

c++/（9）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/kof2001kop/article/category/1071916][作者同类文章]]/X/

版权声明：本文为博主原创文章，未经博主允许不得转载。

 在函数里也能定义函数？呵呵，这当然是不能的，但函数对象却是可以的。如果用旧的方法去定义一个函数对象，那就还要自己先编写一个函数类，这样还不够方便。


但C++11发布后，在函数内简便地定义“函数”（其实是函数对象）就成为了可能：

#+BEGIN_EXAMPLE
    #include <iostream>

    int main()
    {
        auto a = [](){std::cout << "Lambda is flexible!";};
        a();    //MinGW或VC10.0通过编译，显示结果：Lambda is flexible!
        return 0;
    }
#+END_EXAMPLE



上面代码中的auto并不是旧标准中自动变量的意思（自动分配和自动释放空间），它在C++11中赋予了新的功能：当变量被声明时，从变量的初始化值中推出并指定变量的类型。Lambda由于产生的是无名的函数对象，所以它并不能直接在函数中被调用。但如果“把这无名的函数对象起个别名”，那么就可以通过别名来调用了。


不得不承认，新的标准C++11的确使C++的用法更灵活了，或者说能把繁杂的代码简化了。

** [[http://wiki.dzsc.com/info/7158.html][PCI总线]]    :blog:

PCI（Peripheral Component Interconnect）总线总线 的供应商是一种同步的
独立于处理器的32位或64位局部总线。从结构上看，PCI是在CPUCPU 的供应商和
原来的系统总线之间插入的一级总线，具体由一个桥接电路实现对这一层的管理，
并实现上下之间的接口以协调数据的传送。从1992年创立规范到如今，PCI总线
已成为了计算机的一种标准总线。 目录PCI总线的基本概念PCI总线的结构PCI总
线的特点PCI总线的主要功能PCI总线与VL-BUS的比较PCI总线

PCI总线的基本概念　　不同于ISA总线，PCI总线的地址总线与数据总线是分时复用的。这样做的好处是，一方面可以节省接插件的管脚数，另一方面便于实现突发数据传输。在做数据传输时，由一个PCI设备做发起者(主控，Initiator或Master)，而另一个PCI设备做目标(从设备，Target或Slave)。总线上的所有时序的产生与控制，都由Master来发起。PCI总线在同一时刻只能供一对设备完成传输，这就要求有一个仲裁机构(Arbiter)，来决定在谁有权力拿到总线的主控权。　　当PCI总线进行操作时，发起者(Master)先置REQ#，当得到仲裁器(Arbiter)的许可时(GNT#)，会将FRAME#置低，并在AD总线上放置Slave地址，同时C/BE#放置命令信号，说明接下来的传输类型。所有PCI总线上设备都需对此地址译码，被选中的设备要置DEVSEL#以声明自己被选中。然后当IRDY#与TRDY#都置低时，可以传输数据。当Master数据传输结束前，将FRAME#置高以标明只剩最后一组数据要传输，并在传完数据后放开IRDY#以释放总线控制权。　　这里我们可以看出，PCI总线的传输是很高效的，发出一组地址后，理想状态下可以连续发数据，峰值速率为132MB/s。实际上，目前流行的33M@32bit北桥芯片一般可以做到100MB/s的连续传输。
PCI总线的结构　　图1 为1 个典型的 PC I 多总线系统结构图。PCI总线的结构　　其主要 特点如下:　　( 1 ) PC I 规则支持多总线结构。 在整个系统中, 存 在着3种不同的总线:　　①HO ST B u s 为整个系统中最基本设备之间高性 能的连接, 它一般是 I T EL X 86 类型总线。　　②PC I B u s 为系统高性能局部总线, 各种高性能 外设连于其上, 增强系统功能。　　③L EGA CY B u s 为传统的性能较低的总线, 如 ISA 、 ISA 、 CA 总线。　　( 2) 整个系统可以分为多个层次, 不同的总线通过桥路 (BR I GE ) 相连, 桥路的主要功能是在2 种不同的 D 信号环境间进行转换, 使不同总线间的数据传输可以 顺畅进行。　　( 3 ) 在每条总线上接有各自的总线设备 (M A S2 T ER、 R GET M EM O R Y、 R GET I O ) , 这些设 TA TA 中断确认周期 ( in terrup t acknow ledge cycle ) 3 cycle ) 、 备增强系统功能, 整个总线系统为各设备之间可靠的 数据传输提供保障。
PCI总线的特点　　①突出的性能。 总线宽度 32 位, 可升级至 64 位, 支 持突发工作方式, 同步操作时最大频率 33M H z, 数据 最大传输率 132 bp s ( 32 位 ) 或 264M bp s ( 64 位 ) 。 满足 M 了当前对 PC 机传输速度的要求。　　②良好的兼容性。 I 总线部件和插板接口是相 PC 互独立的处理器, 所有目前和将来不同结构的处理器 都可以被很好地支持。　　③即插即用。 I 设备都包含存有设备具体信息 PC 的寄存器, 这些信息可以使得系统 B I S 和操作系统 O 层的软件可以自动配置 PC I 总线部件 和插板。　　④低成本。 采用最优化的芯片, 多路 复用体系减少了管脚个数和 PC I 部件, 基于 ISA 、 ISA 、 CA 的扩展板也可以 E M 在 PC I 总线上工作, 减少了用户开发费 用。　　⑤多主能力。 支持任何 PC I 主设备 和从设备之间点对点的访问。　　⑥定义了313V 和5V 2种信号环境, 5 313V 的组件技术可以使电压平滑过渡。　　⑦高速缓存 (Cache) 支持。
PCI总线的主要功能　　（1） 最大数据传输速率133MB/s　　（2） 总线时钟频率33.3MHz/66MHz　　（3） 支持10 台外设　　（4） 时钟同步方式　　（5） 与CPU 及时钟频率无关　　（6） 总线宽度 32 位（5V）/64 位（3.3V）　　（7） 能自动识别外设　　PCI （Peripheral Component Interconnect）总线是一种高性能局部总线，是为了满足外设间以及外设与主机间高速数据传输而提出来的。在数字图形、图像和语音处理，以及高速实时数据采集与处理等对数据传输率要求较高的应用中，采用PCI总线来进行数据传输，可以解决原有的标准总线数据传输率低带来的瓶颈问题。
PCI总线与VL-BUS的比较　　随着GUI(Graphical User Interface)、多媒体等技术在PC机上的应用,传统的PC总线(如ISA、ISA、EMCA)由于其带宽的限制,已不能满足系统工作的要求。为此,在90年代初,由视频电子标准协会(VESA)和ITEL分别提出了VL-BUS和PCI(PeripheralN Component Interconnect)这2种先进的局部总线规范。它们都为系统提供了一个高速的数据传输通道,系统的各设备可直接或间接地连接其上,设备间通过局部总线可以完成数据的快速传送,从而很好地解决了数据传输的瓶颈问题。　　2种局部总线相比,PCI总线由于是针对整个系统,而不象VL-BUS主要是针对图形加速,它可以带相对较多的负载且运行更为可靠;支持即插即用的结构;采用多路复用技术等一系列优点更受到了众多厂家的支持,成为市场的主流。目前PC机市场绝大多数的Pentium机都以PCI为系统总线。

** [[http://blog.chinaunix.net/uid-20671509-id-1580312.html][存储器分类]]    :blog:

1．按存储介质分
（1）半导体存储器。存储元件由半导体器件组成的叫半导体存储器。其优点是体积小、功耗低、存取时间短。其缺点是当电源消失时，所存信息也随即丢失，是一种易失性存储器。
半导体存储器又可按其材料的不同，
分为双极型（TTL）半导体存储器和MOS半导体存储器两种。
前者具有高速的特点，而后者具有高集成度的特点，并且制造简单、成本低廉，
功耗小、故MOS半导体存储器被广泛应用。
（2）磁表面存储器。磁表面存储器是在金属或塑料基体的表面上涂一层磁性材料作为记录介质，工作时磁层随载磁体高速运转，用磁头在磁层上进行读写操作，故称为磁表面存储器。
按载磁体形状的不同，可分为磁盘、磁带和磁鼓。现代计算机已很少采用磁鼓。由于用具有矩形磁滞回线特性的材料作磁表面物质，它们按其剩磁状态的不同而区分“0”或“1”，而且剩磁状态不会轻易丢失，故这类存储器具有非易失性的特点。
（3）光盘存储器。光盘存储器是应用激光在记录介质(磁光材料)上进行读写的存储器，具有非易失性的特点。光盘记录密度高、耐用性好、可靠性高和可互换性强等。

2．按存取方式分类
按存取方式可把存储器分为随机存储器、只读存储器、顺序存储器和直接存取存储器四类。
（1）随机存储器RAM(Random Access Memory)。RAM是一种可读写存储器，
其特点是存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。计算机系统中的主存都采用这种随机存储器。由于存储信息原理的不同，
RAM又分为静态RAM
(以触发器原理寄存信息)和动态RAM(以电容充放电原理寄存信息)。
（2）只读存储器ROM(Read only
Memory)。只读存储器是能对其存储的内容读出，而不能对其重新写入的存储器。这种存储器一旦存入了原始信息后，在程序执行过程中，只能将内部信息读出，而不能随意重新写入新的信息去改变原始信息。因此，通常用它存放固定不变的程序、常数以及汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。
只读存储器分为掩膜型只读存储器MROM（Masked
ROM）、可编程只读存储器PROM(Programmable
ROM)、可擦除可编程只读存储器EPROM(Erasable Programmable
ROM)、用电可擦除可编程的只读存储器EEPROM(Electrically Erasable
Programmable ROM)。以及近年来出现了的快擦型存储器Flash
Memory，它具有EEPROM的特点，而速度比EEPROM快得多。
（3）串行访问存储器。如果对存储单元进行读写操作时，需按其物理位置的先后顺序寻找地址，则这种存储器叫做串行访问存储器。显然这种存储器由于信息所在位置不同，使得读写时间均不相同。如磁带存储器，不论信息处在哪个位置，读写时必须从其介质的始端开始按顺序寻找，故这类串行访问的存储器又叫顺序存取存储器。还有一种属于部分串行访问的存储器，如磁盘。在对磁盘读写时，首先直接指出该存储器中的某个小区域(磁道)，然后再顺序寻访，直至找到位置。故其前段是直接访问，后段是串行访问，也称其为半顺序存取存储器。

一、RAM(Random Access Memory，随机存取存储器)
RAM的特点是：电脑开机时，操作系统和应用程序的所有正在运行的数据和程序都会放置其中，并且随时可以对存放在里面的数据进行修改和存取。它的工作需要由持续的电力提供，一旦系统断电，存放在里面的所有数据和程序都会自动清空掉，并且再也无法恢复。

根据组成元件的不同，RAM内存又分为以下十八种：

01.DRAM（Dynamic RAM，动态随机存取存储器）
这是最普通的RAM，一个电子管与一个电容器组成一个位存储单元，DRAM将每个内存位作为一个电荷保存在位存储单元中，用电容的充放电来做储存动作，但因电容本身有漏电问题，因此必须每几微秒就要刷新一次，否则数据会丢失。存取时间和放电时间一致，约为2~4ms。因为成本比较便宜，通常都用作计算机内的主存储器。

02.SRAM（Static RAM，静态随机存取存储器）
静态，指的是内存里面的数据可以长驻其中而不需要随时进行存取。每6颗电子管组成一个位存储单元，因为没有电容器，因此无须不断充电即可正常运作，因此它可以比一般的动态随机处理内存处理速度更快更稳定，往往用来做高速缓存。

03.VRAM（Video RAM，视频内存）

它的主要功能是将显卡的视频数据输出到数模转换器中，有效降低绘图显示芯片的工作负担。它采用双数据口设计，其中一个数据口是并行式的数据输出入口，另一个是串行式的数据输出口。多用于高级显卡中的高档内存。

04.FPM DRAM（Fast Page Mode DRAM，快速页切换模式动态随机存取存储器）
改良版的DRAM，大多数为72Pin或30Pin的模块。传统的DRAM在存取一个BIT的数据时，必须送出行地址和列地址各一次才能读写数据。而FRM
DRAM在触发了行地址后，如果CPU需要的地址在同一行内，则可以连续输出列地址而不必再输出行地址了。由于一般的程序和数据在内存中排列的地址是连续的，这种情况下输出行地址后连续输出列地址就可以得到所需要的数据。FPM将记忆体内部隔成许多页数Pages，从512B到数KB不等，在读取一连续区域内的数据时，就可以通过快速页切换模式来直接读取各page内的资料，从而大大提高读取速度。在96年以前，在486时代和PENTIUM时代的初期，
FPM DRAM被大量使用。

05.EDO DRAM（Extended Data Out DRAM，延伸数据输出动态随机存取存储器）
这是继FPM之后出现的一种存储器，一般为72Pin、168Pin的模块。它不需要像FPM
DRAM那样在存取每一BIT
数据时必须输出行地址和列地址并使其稳定一段时间，然后才能读写有效的数据，而下一个BIT的地址必须等待这次读写操作完成才能输出。因此它可以大大缩短等待输出地址的时间，其存取速度一般比FPM模式快15%左右。它一般应用于中档以下的Pentium主板标准内存，后期的486系统开始支持EDO
DRAM，到96年后期，EDO DRAM开始执行。。

06.BEDO DRAM（Burst Extended Data Out
DRAM，爆发式延伸数据输出动态随机存取存储器）
这是改良型的EDO
DRAM，是由美光公司提出的，它在芯片上增加了一个地址计数器来追踪下一个地址。它是突发式的读取方式，也就是当一个数据地址被送出后，剩下的三个数据每一个都只需要一个周期就能读取，因此一次可以存取多组数据，速度比EDO
DRAM快。但支持BEDO
DRAM内存的主板可谓少之又少，只有极少几款提供支持（如VIA APOLLO
VP2），因此很快就被DRAM取代了。

07.MDRAM（Multi-Bank DRAM，多插槽动态随机存取存储器）
MoSys公司提出的一种内存规格，其内部分成数个类别不同的小储存库
(BANK)，也即由数个属立的小单位矩阵所构成，每个储存库之间以高于外部的资料速度相互连接，一般应用于高速显示卡或加速卡中，也有少数主机板用于L2高速缓存中。

08.WRAM（Window RAM，窗口随机存取存储器）
韩国Samsung公司开发的内存模式，是VRAM内存的改良版，不同之处是它的控制线路有一、二十组的输入/输出控制器，并采用EDO的资料存取模式,因此速度相对较快，另外还提供了区块搬移功能（BitBlt），可应用于专业绘图工作上。

09.RDRAM（Rambus DRAM，高频动态随机存取存储器）
Rambus公司独立设计完成的一种内存模式，速度一般可以达到500~530MB/s，是DRAM的10倍以上。但使用该内存后内存控制器需要作相当大的改变，因此它们一般应用于专业的图形加速适配卡或者电视游戏机的视频内存中。

10.SDRAM（Synchronous DRAM，同步动态随机存取存储器）
这是一种与CPU实现外频Clock同步的内存模式，一般都采用168Pin的内存模组，工作电压为3.3V。
所谓clock同步是指内存能够与CPU同步存取资料，这样可以取消等待周期，减少数据传输的延迟，因此可提升计算机的性能和效率。

11.SGRAM（Synchronous Graphics RAM，同步绘图随机存取存储器）
SDRAM的改良版，它以区块Block，即每32bit为基本存取单位，个别地取回或修改存取的资料，减少内存整体读写的次数，另外还针对绘图需要而增加了绘图控制器，并提供区块搬移功能（BitBlt），效率明显高于SDRAM。

12.SB SRAM（Synchronous Burst SRAM，同步爆发式静态随机存取存储器）
一般的SRAM是非同步的，为了适应CPU越来越快的速度，需要使它的工作时脉变得与系统同步，这就是SB
SRAM产生的原因。

13.PB SRAM（Pipeline Burst SRAM，管线爆发式静态随机存取存储器）
CPU外频速度的迅猛提升对与其相搭配的内存提出了更高的要求，管线爆发式SRAM取代同步爆发式SRAM成为必然的选择，因为它可以有效地延长存取时脉，从而有效提高访问速度。

14.DDR SDRAM（Double Data Rate二倍速率同步动态随机存取存储器）
作为SDRAM的换代产品，它具有两大特点：其一，速度比SDRAM有一倍的提高；其二，采用了DLL（Delay
Locked
Loop：延时锁定回路）提供一个数据滤波信号。这是目前内存市场上的主流模式。

15.SLDRAM （Synchronize Link，同步链环动态随机存取存储器）
这是一种扩展型SDRAM结构内存，在增加了更先进同步电路的同时，还改进了逻辑控制电路，不过由于技术显示，投入实用的难度不小。

16.CDRAM（CACHED DRAM，同步缓存动态随机存取存储器）
这是三菱电气公司首先研制的专利技术，它是在DRAM芯片的外部插针和内部DRAM之间插入一个SRAM作为二级CACHE使用。当前，几乎所有的CPU都装有一级CACHE来提高效率，随着CPU时钟频率的成倍提高，CACHE不被选中对系统性能产生的影响将会越来越大，而CACHE
DRAM所提供的二级CACHE正好用以补充CPU一级CACHE之不足，因此能极大地提高CPU效率。

17.DDRII (Double Data Rate Synchronous
DRAM，第二代同步双倍速率动态随机存取存储器)
DDRII
是DDR原有的SLDRAM联盟于1999年解散后将既有的研发成果与DDR整合之后的未来新标准。DDRII的详细规格目前尚未确定。

18.DRDRAM (Direct Rambus DRAM)
是下一代的主流内存标准之一，由Rambus
公司所设计发展出来，是将所有的接脚都连结到一个共同的Bus，这样不但可以减少控制器的体积，已可以增加资料传送的效率。

二、ROM(READ Only Memory，只读存储器)

ROM是线路最简单半导体电路，通过掩模工艺，一次性制造，在元件正常工作的情况下，其中的代码与数据将永久保存，并且不能够进行修改。一般应用于PC系统的程序码、主机板上的
BIOS (基本输入/输出系统Basic Input/Output
System)等。它的读取速度比RAM慢很多。

根据组成元件的不同，ROM内存又分为以下五种：

1.MASK ROM（掩模型只读存储器）
制造商为了大量生产ROM内存，需要先制作一颗有原始数据的ROM或EPROM作为样本，然后再大量复制，这一样本就是MASK
ROM，而烧录在MASK ROM中的资料永远无法做修改。它的成本比较低。

2.PROM（Programmable ROM，可编程只读存储器）
这是一种可以用刻录机将资料写入的ROM内存，但只能写入一次，所以也被称为“一次可编程只读存储器”(One
Time Progarmming
ROM，OTP-ROM)。PROM在出厂时，存储的内容全为1，用户可以根据需要将其中的某些单元写入数据0(部分的PROM在出厂时数据全为0，则用户可以将其中的部分单元写入1)，
以实现对其“编程”的目的。

3.EPROM（Erasable Programmable，可擦可编程只读存储器）
这是一种具有可擦除功能，擦除后即可进行再编程的ROM内存，写入前必须先把里面的内容用紫外线照射它的IC卡上的透明视窗的方式来清除掉。这一类芯片比较容易识别，其封装中包含有“石英玻璃窗”，一个编程后的EPROM芯片的“石英玻璃窗”一般使用黑色不干胶纸盖住，
以防止遭到阳光直射。

4.EEPROM（Electrically Erasable Programmable，电可擦可编程只读存储器）
功能与使用方式与EPROM一样，不同之处是清除数据的方式，它是以约20V的电压来进行清除的。另外它还可以用电信号进行数据写入。这类ROM内存多应用于即插即用（PnP）接口中。

5.Flash Memory（快闪存储器）
这是一种可以直接在主机板上修改内容而不需要将IC拔下的内存，当电源关掉后储存在里面的资料并不会流失掉，在写入资料时必须先将原本的资料清除掉，然后才能再写入新的资料，缺点为写入资料的速度太慢。

** [[http://lovelace.blog.51cto.com/1028430/1211373][shell 学习之for语句]]    :blog:

一、for语法
for 变量 in 列表；do
    循环体
done
二、常见用法
1、for用来遍历目录

1
2
3
4
5
6
7
8
9
10
#!/bin/bash
#Version:0.1
#Author:lovelace
#pragram:This scripts is print all files in directory
#difine an varibale
DIR="/home/scripts/51cto"
#All files in directory traversal
for f in $(ls $DIR);do
echo $f
done

输出结果为：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
[root@lovelace for]# ./dir.sh
1.sh
2curl.sh
adduer.sh
aliquot.sh
argument.sh
argusum.sh
curl.sh
dd.sh
dirper.sh
info.sh
info.tt
ipcheck.sh
jugement.sh
netcard.sh
sum.sh
test.sh
The
Frist
week
The
Third
week

2、for ((初始条件;终止条件;异动项））
do
   命令区域
done

1
2
3
4
5
6
7
8
9
10
11
12
#!/bin/bash
#Version:0.1
#Author:lovelace
#pragram:This pragram is and the sum from 1 to 100
#define an integer
declare -i i
#loops
for ((i=1;i<=10;i=i+1))
do
let sum+=1
done
echo "The result is:" $sum

输出结果为：
1
2
[root@lovelace for]# ./sorsum.sh
The result is: 10
3、for 无穷循环
    for ((;1;));do
      命令区域
     done


1
2
3
4
5
[root@lovelace for]# cat forover.sh
#!/bin/bash
for ((;1;));do
echo "forever..."
done
输出结果：
1
2
3
4
5
6
7
8
[root@lovelace for]# ./forover.sh
forever...
forever...
forever...
forever...
forever...
forever...
forever...
三、关于break和continue

break、continue 一样可以运用在for while until select这4中循环中，
break :退出循环  提前退出
continue:提前进入下一轮循环 ,continue后面的语句将不再执行
示例（计算1到100内能被3整除的数之和）：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
#!/bin/bash
#Verson:0.1
#Auther:lovelace
#Pragram:This pragram is calculation from 1 to 100 aliquot 3 sum
#
declare -i i=0
declare -i sum=0
#use loop traverse from 1 to 100
while [ $i -lt 100 ];do
let i++
#jugement aliqotu 3 or not
if [ $(($i%3))  -eq 0 ];then
let sum+=i
else
continue
fi
done
#print sum
echo "from 1 to 100 aliquot 3 sum is $sum"
输出结果为：
1
2
[root@lovelace for]# ./three.sh
from 1 to 100 aliquot 3 sum is 1683
四、再次重提如何生成列表
如何生成列表：
1、整数列表
     {1..100}  生存1到100的列表
2、seq
    seq 10 1到10
    seq 5 10 5到10
    seq 5 10 2 返回列表为6 8 10
3、`ls /etc`

生成列表不单单只有我们列出的这些，实际案例上需要灵活运用
示例：（分别显示当前系统上所有默认shell中为bash的用户和默认为nologin的用户）
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
[root@lovelace for]# cat checkbash.sh
#!/bin/bash
#Version:0.1
#Author:lovelace
#pragram:This scripts is check user bash and print it
#取出使用bash的用户个数
bashline=`grep 'bash$' /etc/passwd | wc -l`
#取出使用nologin的用户个数
nologinline=`grep 'nologin$' /etc/passwd | wc -l`
#取出bash用户列表
bashuser=`grep 'bash$' /etc/passwd | cut -d: -f1`
#取出nologin用户列表
nologin=`grep 'nologin$' /etc/passwd | cut -d: -f1`
#遍历使用bash的用户并打印出来
for x in  $bashuser;do
echo "bash users is:$x"
done
#遍历使用nologin的用户并打印出来
for y in  $nologin;do
echo "nologin users is:$y"
done
#结果如下
[root@lovelace for]# ./checkbash.sh
bash users is:root
bash users is:nick
bash users is:kale
bash users is:user2
bash users is:user3
bash users is:user4
bash users is:user5
bash users is:user6
bash users is:user7
bash users is:user8
bash users is:user9
bash users is:user10
bash users is:mark
bash users is:lovelace
bash users is:lovetest
nologin users is:bin
nologin users is:daemon
nologin users is:adm
nologin users is:lp
nologin users is:mail
nologin users is:uucp
nologin users is:operator
nologin users is:games
nologin users is:gopher
nologin users is:ftp
nologin users is:nobody
nologin users is:nscd
nologin users is:vcsa
nologin users is:pcap
nologin users is:ntp
nologin users is:dbus
nologin users is:avahi
nologin users is:rpc
nologin users is:mailnull
nologin users is:smmsp
nologin users is:sshd
nologin users is:oprofile
nologin users is:rpcuser
nologin users is:nfsnobody
nologin users is:xfs
nologin users is:haldaemon
nologin users is:avahi-autoipd
nologin users is:gdm
nologin users is:sabayon
nologin users is:jack

** [[http://www.blogbus.com/fbirdzp-logs/37423250.html][Apr 3, 2009Linux用户命令行字符环境变量]]    :blog:

   用户登录Linux系统的字符界面后，就会出现"#"或"$"等命令提示符，比如"[root@pxe
   root]# “、"[oracle@db1 ~]$”或是 “-bash-3.00#”等等。

   通过设置环境变量PS1、PS2、PS3以及PS4来自定义用户命令行的字符显示。如果要长期永久性修改提示符，可以将修改提示符的命令添加到$HOME/.profile或$HOME/.bash_profile文件中。

   *1. PS1*

   PS1是主提示符变量,也是默认提示符变量。默认值"\s-\v\$“，显示shell类型和版本。
   基本上通过设置PS1来定义命令行提示字符即可，最常用的需求就是显示登录的用户名、主目录、主机名等等，举个例子如下：

   --------------

   显示用户名，主机名和动态显示当前目录
   -bash-3.00# export PS1="[\u@\h \w]"
   [root@MagicLinux ~]cd /etc
   [root@MagicLinux /etc]

   注意：如果当前目录是用户的HOME目录，则显示＂~＂

   --------------

   PS1变量可以使用的参数值有如下：

   | \d                                                      | \H                                                                         | \h                                                      | \t                                     | \T                     | \A                             | \u                   | \v               | \w                                     | \W                                                       | \#                 | \$                                                      | \[        | \]        | \!                           |
   | 代表日期，格式为weekday month date，例如："Mon Aug 1"   | 完整的主机名称。例如：我的机器名称为：fc4.linux，则这个名称就是fc4.linux   | 仅取主机的第一个名字，如上例，则为fc4，.linux则被省略   | 显示时间为24小时格式，如：HH：MM：SS   | 显示时间为12小时格式   | 显示时间为24小时格式：HH：MM   | 当前用户的账号名称   | BASH的版本信息   | 完整的工作目录名称。家目录会以 ~代替   | 利用basename取得工作目录名称，所以只会列出最后一个目录   | 下达的第几个命令   | 提示字符，如果是root时，提示符为：# ，普通用户则为：$   | 字符"["   | 字符"]"   | 命令行动态统计历史命令次数   |

   *2. PS2*

   PS2是副提示符变量，默认值是''> ''。
   PS2一般使用于命令行里较长命令的换行提示信息，比如：

   --------------

   默认设置
   -bash-3.00# rpm -q gcc make binutils openmotif setarch compat-db
   compat-gcc \
   > compat-gcc-c++ compat-libstdc++ compat-libstdc++-devel

   自定义设置
   -bash-3.00# export PS2="PS2 => "
   -bash-3.00# rpm -q gcc make binutils openmotif setarch compat-db
   compat-gcc \
   PS2 => compat-gcc-c++ compat-libstdc++ compat-libstdc++-devel

   --------------

   *3. PS3，PS4*

   这两个环境变量可能用得不多，不研究了。如果有兴趣，可以学习bash里面的简介。

   PS3  The value of this parameter is used as the prompt for the
   select command (see SHELL GRAMMAR above).
   PS4  The value of this parameter is expanded as with PS1 and the
   value is printed before  each  command  bash displays  during an
   execution trace.  The first character of PS4 is replicated multiple
   times, as neces-sary, to indicate multiple levels of indirection.
   The default is ''+ ''.

** [[http://blog.csdn.net/flowingflying/article/details/5069646][Linux Bash Shell学习（九）：流程控制------if/else]]    :blog:



[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

Linux/（83）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/flowingflying/article/category/526791][作者同类文章]]/X/

读书笔记/（147）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/flowingflying/article/category/520736][作者同类文章]]/X/

版权声明：本文为博主原创文章，未经博主允许不得转载。

本文也即《Learning the bash Shell》3rd Edition的第五章Flow
Control之读书笔记，但我们将不限于此。flow
control是任何编程语言中很常用的部分，也包括了bash。在这里，我们将学习他们。

if/else是通过判断选择执行或者执行部分代码，可以根据变量、文件名、命令是否执行成功等很多条件进行判断，他的格式如下：

#+BEGIN_QUOTE
  *if* /condition/
   *then*
     /statements/
   [*elif* /condition/
     *then* /statements./ ..]
   [*else*
     /statements/ ]
   *fi*
#+END_QUOTE

和
C程序不一样，bash的判断不是通过boolean，而是通过statement，也就是执行命令后的最终状态（exit
status）。所有的Linux命令，无论你是代码是C还是脚本，执行完，都返回一个整数通知他的调用这，这就是exit
status，通常0表示OK，其他（1-255）表示错误。这只是通常的情况，例如diff，0表示你no
difference，1表示difference，2表示错误。if判断statements的最后一个的exit
status，通常我们只放一个statement，如果为0，表示true，否则表示false。

执行下一条命令会冲掉原来exit
status。可以使用$?来查看上一命令执行的结果。例如我们希望用一个新的cd命令来替代原来在linux
kernel中已将编译的cd命令，由于function是优先于built-in命令，所以调用时，将调用我们的function。下面有一个例子，function
pushd，在stack中键入cd的dirname路径名，并执行跳到该路径下。

#+BEGIN_QUOTE
  cd ( )
   {

  #由于我们已经定义了具有更高优先级别的function，如果希望调用原来built-in的命令，需要再前面加上builtin。
     *builtin* cd "$@"
     #$?是上一command的返回值，即builtin cd
  "$@"的值，并记录在result里面。
     result=*$?
  *   echo "$OLDPWD --> $PWD"

  #返回result的值。我们需要注意shell中的返回和在其他程序，例如C语言中的返回是不一样的，只代表最后的exit
  statue，而不是所谓的返回值，虽然也用到了return。如何没有最后的reture，例如后面的push_func，exit
  status就是最后执行的command的exit status
     *return*   $result
   }

  push_func( )
   {
     dirname=$1
     #如果dirname为null，退出funcuntion，如cd dirname成功，push the
  directory ，否则显示still in
  $PWD，cd使用function的cd函数，其优先级别高于已在内核编译了的cd
     *if* cd ${dirname:?"missing directory name."}
     *then
  *   mystack="$dirname ${mystack:-$OLDPWD }"
     echo $mystack
     *else*
     echo still in $PWD.
     *fi
  * }

  push_func $1
#+END_QUOTE

/*条件结合*/

和C语言一样，可以进行条件结合，使用&&，||，以及！三种方式，表示“和”，“或”，与”非“，格式如下：if
/statement1/ *&&* /statement2，/ if /statement1/ *||* /statement2/ ，if
*！* /statement1/ 。

exit status不是判断的唯一值，可以使用[...]和[[...]]。

/*字符串比较*/

字符串比较是放置在[...]中，有以下的几种：

- str1 = str2，字符串1匹配字符串2
- str1 != str2，字符串1不匹配字符串2
- str1 > str2，字符串1大于字符串2
- str1 < str2，字符串1小于字符串2
- -n str，字符串不为null，长度大于零
- -z str，字符串为null，长度为零

*需要注意<和>符号和重定向符号相似，为了避免歧义和错误，使用if [ /$a/
/> /$b/ ] 的方式* 。仍然上面的例子，我们增加pop_func来操作stack:

#+BEGIN_QUOTE
    pop_func()
      {
       mystack=${mystack#* }
       #下面请至于[ ...
  ]，即[后面有一个空格，]前面有一空格，另外$mystack用双引号，表示这代表的是一个字符串。注意到then不放在下一行，与if放在用一行，用;来隔开。
       if *[ -n "$mystack" ];* then
       cd ${mystack%% *}
       echo "$PWD", stack is [$mystack]
       else
     echo "stack empty, still in $PWD."
     fi
      }
#+END_QUOTE

例如，我们要求命令带有参数，除了使用{1?"<message"}以外，下面给出更可读的方式：

#+BEGIN_QUOTE
  if [ -z "$1" ]; then
     echo 'usage: c filename [-N]'
     *exit* 1
   fi
#+END_QUOTE

在这里exit表示结束，退出，执行的结果为失败，非零。

/*文件属性比较*/

文件属性比较是另一个常用的条件判断类型。

- *-a*   /file/ ：file 存在
- *-d* /file/ ：file存在并是一个目录
- *-e* /file/ ：file 存在，同- a
- *-f* /file/ ：file
   存在并且是一个常规的文件（不是目录或者其他特殊类型文件）
- *-r* /file/ ：有读的权限
- *-s* /file/ ：文件存在且不为空
- *-w* /file/ ：有写的权限
- *-x* /file/ ：有执行的权限，或者对于目录有search的权限
- *-N* /file/ ：在上次读取后，文件有改动
- *-O* /file/ ：own所属的文件
- *-G* /file/ ：group所属的文件
- /file1/ *// -nt* /file2/ ：file1 比 file2 更新，以最后更新时间为准
- /file1/ *-ot* /file2/ ：file1 比 file2 更旧 ，以最后更新时间为准

这些在[ ... ]中的条件判断是可以多个结合起来，例如if [ condition ] &&
[ condition ]; then，当然也可以if command && [ condition ];
then，不在类推。尤其我们可以进行复制的条件判断。另外还可以使用*-a*
和*-o*
，等同于C语言中的&和|的逻辑计算复符号，他们和&&即||相似。当他们用在condition里面。

在上面push_func的例子中，除了判断是否参数之外，增加判断是否是目录名，如下：

#+BEGIN_QUOTE
    if *[ -n "$dirname" ] &&[ -d "$dirname" ]*
     then
     cd $dirname
     mystack="$dirname ${mystack:-$OLDPWD }"
     echo $mystack
     else
     echo still in $PWD.
     fi
#+END_QUOTE

我们在增加一个判断，当时目录名的时候，在检查是否可以进行查看或操作。使用if
[ -n "$dirname" ] &&[ *-d "$dirname" -a -x "$dirname"*
]，但是这种写法很难阅读，我们需要将两个前后判断括起来，( -d "$dirname" )
-a ( -x "$dirname" )。但是（是个特殊符合，需使用/(的方式，即为：if [ -n
"$dirname" ] &&*[ /( -d "$dirname" /) -a /( -x "$dirname" /) ]* 。

/*整数比较*/

>或者<或者=是用于字符串的比较，如果用于整数比较，使用：

- -lt，小于
- -le，小于等于
- -eq，等于
- -ge，大于等于
- -gt，大于
- -ne，不等于

** [[http://www.cnblogs.com/chengmo/archive/2010/10/01/1839942.html][linux shell 逻辑运算符、逻辑表达式详解]]    :blog:

shell的逻辑运算符
涉及有以下几种类型，因此只要适当选择，可以解决我们很多复杂的判断，达到事半功倍效果。



*一、逻辑运算符*







| *逻辑卷标*   | 1.                                 | -f                                                  | -d                           | -b                              | -c                                  | -S                                   | -L                                        | -e                           | 2.                       | -G                                  | -O                                  | -p                                                                        | 3.                       | -r                     | -w                         | -x                       | -s                         | -u                             | -g                             | -k                                   | 4.                                                          | -nt                        | -ot                        | -ef                                                      | 5.                            | &&                  | ||                 |
| *表示意思*   | *关于档案与目录的侦测逻辑卷标！*   | 常用！侦测『档案』是否存在 eg: if [ -f filename ]   | 常用！侦测『目录』是否存在   | 侦测是否为一个『 block 档案』   | 侦测是否为一个『 character 档案』   | 侦测是否为一个『 socket 标签档案』   | 侦测是否为一个『 symbolic link 的档案』   | 侦测『某个东西』是否存在！   | *关于程序的逻辑卷标！*   | 侦测是否由 GID 所执行的程序所拥有   | 侦测是否由 UID 所执行的程序所拥有   | 侦测是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！）   | *关于档案的属性侦测！*   | 侦测是否为可读的属性   | 侦测是否为可以写入的属性   | 侦测是否为可执行的属性   | 侦测是否为『非空白档案』   | 侦测是否具有『 SUID 』的属性   | 侦测是否具有『 SGID 』的属性   | 侦测是否具有『 sticky bit 』的属性   | *两个档案之间的判断与比较* ；例如[ test file1 -nt file2 ]   | 第一个档案比第二个档案新   | 第一个档案比第二个档案旧   | 第一个档案与第二个档案为同一个档案（ link 之类的档案）   | 逻辑的『和(and)』『或(or)』   | 逻辑的 AND 的意思   | 逻辑的 OR 的意思   |





| 运算符号   | =                                                         | !=                                                          | <                                                    | >                                                    | -eq                     | -ne                       | -lt                     | -gt                     | -le                           | -ge                           | -a                                            | -o                                         | -z         | -n           |
| 代表意义   | 等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串   | 不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串   | 小于 应用于：整型比较 在[] 中，不能使用 表示字符串   | 大于 应用于：整型比较 在[] 中，不能使用 表示字符串   | 等于 应用于：整型比较   | 不等于 应用于：整型比较   | 小于 应用于：整型比较   | 大于 应用于：整型比较   | 小于或等于 应用于：整型比较   | 大于或等于 应用于：整型比较   | 双方都成立（and） 逻辑表达式 --a 逻辑表达式   | 单方成立（or） 逻辑表达式 --o 逻辑表达式   | 空字符串   | 非空字符串   |



*二、逻辑表达式*

**

- *test 命令*

#+BEGIN_QUOTE
  *使用方法：*test EXPRESSION

  如：

  [root@localhost ~]# test 1 = 1 && echo 'ok'
  ok

  [root@localhost ~]# test -d /etc/ && echo 'ok'
  ok

  [root@localhost ~]# test 1 -eq 1 && echo 'ok'
  ok



  [root@localhost ~]# if test 1 = 1 ; then echo 'ok'; fi
  ok
#+END_QUOTE



#+BEGIN_QUOTE
  *注意：所有字符 与逻辑运算符直接用“空格”分开，不能连到一起。*
#+END_QUOTE



- *精简表达式*

#+BEGIN_QUOTE

  -  *[] 表达式*

  [root@localhost ~]# [ 1 -eq 1 ] && echo 'ok'
  ok

  [root@localhost ~]# [ 2 < 1 ] && echo 'ok'
  -bash: 2: No such file or directory


  [root@localhost ~]# [ 2 \< 1 ] && echo 'ok'

  [root@localhost ~]# [ 2 -gt 1 -a 3 -lt 4 ] && echo 'ok'

  ok

  [root@localhost ~]# [ 2 -gt 1 && 3 -lt 4 ] && echo 'ok'
  -bash: [: missing `]'

  注意：在[]
  表达式中，常见的>,<需要加转义字符，表示字符串大小比较，以acill码
  位置作为比较。 不直接支持<>运算符，还有逻辑运算符|| && 它需要用-a[and]
  --o[or]表示
#+END_QUOTE



#+BEGIN_QUOTE




  -  *[[]] 表达式*

  [root@localhost ~]# [ 1 -eq 1 ] && echo 'ok'
  ok

  [root@localhost ~]$ [[ 2 < 3 ]] && echo 'ok'
  ok

  [root@localhost ~]$ [[ 2 < 3 && 4 > 5 ]] && echo 'ok'
  ok
#+END_QUOTE

#+BEGIN_QUOTE
  注意：[[]]
  运算符只是[]运算符的扩充。能够支持<,>符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：||
  &&


#+END_QUOTE



*三、性能比较*

bash的条件表达式中有三个几乎等效的符号和命令：test，[]和[[]]。通常，大家习惯用if
[];then这样的形式。而[[]]的出现，根据ABS所说，是为了兼容><之类的运算符。以下是比较它们性能，发现[[]]是最快的。


$ time (for m in {1..100000}; do test -d .;done;)
real  0m0.658s
user  0m0.558s
sys  0m0.100s


$ time (for m in {1..100000}; do [ -d . ];done;)
real  0m0.609s
user  0m0.524s
sys  0m0.085s


$ time (for m in {1..100000}; do [[ -d . ]];done;)
real  0m0.311s
user  0m0.275s
sys  0m0.036s


不考虑对低版本bash和对sh的兼容的情况下，用[[]]是兼容性强，而且性能比较快，在做条件运算时候，可以使用该运算符。

** [[http://www.cppblog.com/amazon/archive/2010/01/10/105358.html][makefile和make规则]]    :blog:

首先介绍make实用程序的语法和常用选项，然后细剖makefile文件的组成。

*make命令*

[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]make [选项] [目标] [宏定义]
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]通过命令行参数中的target，可指定make要编译的目标，并且允许同时定义编译多个目标，操作时按照从左向右的顺序依次编译target选项中指定的目标文件。如果命令行中没有指定目标，则系统默认target指向描述文件中第一个目标文件。
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-d 显示调试信息
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-n 不运行任何makefile文件，只打印需要执行的命令
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-p 输出所有宏定义和目标文件描述
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-s 静止状态下运行，不显示任何命令行信息
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-f file 通知make程序从file中读取内部依赖说明，缺省情况下会读取makefile或者Makefile文件处理，文件名-表示读取标准输入，在Linux中，GNU make工具在当前工作目录中按照GNUmakefile、makefile、Makefile的顺序搜索makefile文件
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]

注意：在源文件没有被修改的情况下，运行make命令会生成一条消息，说源文件的可执行文件是最新的，不需要用make命令重新编译和链接。要强制再创建可执行代码，需要改变源文件的上次更新时间，可以使用touch命令，然后再次运行make命令。

[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]touch [选项] 文件或目录
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-r 文件或目录 把指定文件或目录的日期时间，设成和参考文件或目录的日期时间相同
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-d 日期时间
使用指定的日期时间，而非现在的时间


*makefile规则*

make程序基于文件之间的依赖性，需要建立的目标文件，以及建立目标文件时要执行的命令，以上所有被称为规则，存放在文件makefile中。定制规则的语法如下：
*目标列表 : 关联性列表
<TAB>命令列表
*注意：
1.可以在关联性列表和命令列表中使用shell文件名模式匹配字符，例如?、*、[]等等。
2.如果目标的命令列表中某个命令前面带有@，那么当make程序执行时，该命令是不会有反应的，在程序运行完毕之后，所有前面带@的命令按照反序执行。可以通过执行make
-n命令显示这些命令以供查看。
3.如果目标的命令列表中某个命令前面带有-，说明如果该命令执行有误，会跳过该命令并继续执行。

make程序使用makefile中的规则决定程序中需要重新编译的文件，并再次链接生成可执行代码。如果源文件上修改的时间戳比目标文件上的时间戳更新，那么make重新编译build中包含的源文件。例如，如果修改了一个.h头文件，make程序就会重新编译所有包含该头文件的源文件，前提是头文件在这些源文件的目标文件的关联性列表中；再如某.c源文件被修改，那么该源文件被重新编译，生成对应的新的目标文件。
myprog : foo.o bar.o
  gcc --o myprog foo.o bar.o
foo.o : foo.c foo.h bar.h
  gcc --o foo.o --c foo.c
bar.o : bar.c bar.h
  gcc --o bar.o --c bar.c
上述规则中，只要目标文件比冒号后面的文件任何一个旧，将会执行下一行的命令；但是在检查foo.o和bar.o的时间之前，会往下查找那些把foo.o和bar.o作为目标文件的规则；以此类推，并最终回到myprog规则。
如何得到每个C文件的输出规则呢？可使用-M和-MM编译选项。注意：使用-M和-MM编译选项时，仅在shell中输出规则信息，不能用于产生可执行文件，即不能写成gcc
-o hello -M hello.c这样的形式。
*gcc --M hello.c*
//输出hello.c和该文件中所有<>和””包含的头文件
*gcc --MM hello.c*  //仅输出hello.c和该文件中所有””包含的头文件

*后缀（隐含）规则*

make
-p命令显示了所有后缀规则列表。为了建立一个目标，make使用程序会遍历一连串的依赖关系，从而决定从何处开始建立。如果没有找到目标文件，make程序按照优先顺序查找源文件，首先查找.c、.f或.s后缀的文件，然后再查找SCCS（带.c~后缀）文件，如果没有找到任何一个源文件，make程序就会报告一个异常。
make程序知道调用gcc -c xxx.c -o
xxx.o的预定义命令，而且还知道目标文件通常和源文件是相同的，这种功能称作标准依赖性，所以foo.o
: foo.c foo.h bar.h这样的语句可以简写成foo.o : foo.h
bar.h。同时，如果把生成foo.o和bar.o的命令从规则中删除，make将自动查找它的隐含规则（gcc
-M/MM输出的代码），然后找到一个适当的命令，命令中会使用一些变量，并且按照一定步骤设定。
因此，上述makefile的内容可以根据后缀规则简写成：
myprog : foo.o bar.o
  gcc --o myprog foo.o bar.o
foo.o : foo.h bar.h
bar.o : bar.h

*宏定义（变量）*

makefile中的变量定义可以存储文件名列表、可执行文件名以及编译器标识等，主要是使用如下方法：

[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]VAR=name 变量定义
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]define VAR
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]] name
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]endef 同上
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]$(VAR) 使用变量，如果变量名为单字符，可以不使用圆括号或花括号
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]${VAR} 同上
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]$@ 当前目标文件
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]$* 删除了后缀的目标名
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]$< 依赖列表中，比当前目标更新的当前依赖名称（即第一个依赖文件）
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]$\^ 整个依赖列表
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]$? 依赖列表中，比当前目标更新的当前依赖列表
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]CFLAGS 通常默认值是-O，但是可以被修改

未使用后缀规则的makefile文件变成如下：
OBJS=foo.o bar.o
SOURCES=foo.c bar.c
HEADERS=foo.h bar.h
CC=gcc
CFLAGS=-Wall -O -g
myprog : $(OBJS)
  $(CC) $\^ -o $@
foo.o : foo.c foo.h bar.h
  $(CC) $(CFLAGS) --c $< -o $@
bar.o : bar.c bar.h
  $(CC) $(CFLAGS) --c $< -o $@
而使用了后缀规则的makefile文件变成如下：
OBJS=foo.o bar.o
SOURCES=foo.c bar.c
HEADERS=foo.h bar.h
CC=gcc
myprog : $(OBJS)
  $(CC) S\^ -o $@
foo.o : foo.h bar.h
bar.o : bar.h

*虚目标
*
假设一个项目最后需要产生两个可执行文件exec1和exec2，但两个文件是相互独立的，此时可使用假想目的all来达到效果。
all : exec1 exec2
all文件并不存在，make总是会假设它需要被生成，因此会检查它的依靠文件exec1和exec2是否需要更新，当把它的依靠文件更新后，就会执行它的规则里的命令行，但是在规则里没有哪个命令作用于名为all的实际文件，所以该规则并不真正改变all的状态。
注意下面的语句用法，这些语句可以添加到makefile文件后：
myprog.tar : makefile $(SOURCES) $(HEADERS)
  tar -cvf $@ S\^
clean :
  rm *.o
当make命令不带参数执行时，最后两个目标myprog.tar和clean的命令不会执行，因为这些文件没有依赖文件。将这两个目标作为参数传递给make命令，可以调用与目标关联的命令。例如：执行make
myprog.tar命令会执行tar -cvf myprog.tar makefile foo.c bar.c foo.h
bar.h语句，而执行make clean命令会执行clean *.o语句。

下面给出一个较完整的makefile文件：
---------------------------------------------------------
#Updated makefile that uses some built-in macros and
[[mailto:#@-preceded][#@-preceded]] commands
define CC
  gcc
endef
OPTIONS=-03
OBJECTS=main.o input.o compute.o
SOURCES=main.c input.c compute.c
HEADERS=main.h input.h compute.h
complete : power
  @echo "Build complete"
power : $(OBJECTS)
  $(CC) $(OPTIONS) -o $@ $\^ -lm
  @echo "The executable is in the 'power' file"
main.o : main.h input.h compute.h
compute.o : compute.h
input.o : input.h
power.tar : makefile $(HEADERS) $(SOURCES)
  tar -cvf $@ $\^
clean :
  rm -f *.o
-----------------------------------------------------
执行结果为：
-----------------------------------------------------
$ make
gcc -c main.c -o main.o
gcc -c input.c -o input.o
gcc -c compute.c -o compute.o
gcc -o3 -o power main.o input.o compute.o -lm
The executable is in the 'power' file
Build complete
$ make power.tar
tar -cvf power.tar makefile main.h input.h compute.h main.c input.c
compute.c
makefile
main.h
input.h
compute.h
main.c
input.c
compute.c
$ make clean
rm -f *.o
------------------------------------------------------

** [[http://blog.csdn.net/adaptiver/article/details/7240364][Bash shell中的位置参数$#,$*,$@,$0,$1,$2...及特殊参数$?,$-等的含义]]    :blog:


[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

linux命令/（21）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/adaptiver/article/category/862986][作者同类文章]]/X/

 [[http://hi.baidu.com/lolorosa/blog/item/5775a608bd670d33b0351da7.html]]

$# 是传给脚本的参数个数

$@ 是传给脚本的所有参数的列表

$0 是脚本本身的名字

$1是传递给该shell脚本的第一个参数

$2是传递给该shell脚本的第二个参数

在Bash shell中经常会见到一些比较特殊的符号，本人现收集与此，以供查阅：

 位置参数：
 详见ABS(Advanced Bash
Shell)中文翻译版103页第9章第一节内部变量，当然英文版ABS都一样啦

 $0, $1, $2,等等...
 位置参数,从命令行传递给脚本,或者是传递给函数.或者赋职给一个变量.
 (具体见Example 4-5 和Example 11-15)
 $0表示当前执行的进程名,script
本身的名字,或者在正则表达式中表示整行输出

 $#
 命令行或者是位置参数的个数.(见Example 33-2)
 $*
 所有的位置参数,被作为一个单词.
 注意:"$*"必须被""引用.
 $@

与$*同义,但是每个参数都是一个独立的""引用字串,这就意味着参数被完整地传递,

并没有被解释和扩展.这也意味着,每个参数列表中的每个参数都被当成一个独立的单词.
 注意:"$@"必须被""引用.



其他的特殊参数
 $-
 传递给脚本的falg(使用set 命令).参考Example 11-15.
 注意:这起初是ksh 的特征,后来被引进到Bash 中,但不幸的是,在Bash
中它看上去也不

能可靠的工作.使用它的一个可能的方法就是让这个脚本进行自我测试(查看是否是交
 互的).
 $!
 在后台运行的最后的工作的PID(进程ID).
 $_
 保存之前执行的命令的最后一个参数.
 $?
 命令,函数或者脚本本身的退出状态(见Example 23-7)

用于检查上一个命令,函数或者脚本执行是否正确。（在Linux中，命令退出状态为0表示该命令正确执行，任何非0值表示命令出错。）
 $$
 脚本自身的进程ID.这个变量经常用来构造一个"unique"的临时文件名.
 (参考Example A-13,Example 29-6,Example 12-28 和Example 11-25).
 这通常比调用mktemp 来得简单.
 注意事项:
 [1] 当前运行的脚本的PID 为$$.
 [2]
"argument"和"parameter"这两个单词经常不加区分的使用.在这整本书中,这两个
 单词的意思完全相同.(在翻译的时候就未加区分,统统翻译成参数)

 退出和返回
 退出状态(exit status)
 函数返回一个被称为退出状态的值. 退出状态可以由return 来指定statement,
否则函数的
 退出状态是函数最后一个执行命令的退出状态(0 表示成功,非0 表示出错代码).
退出状态
 (exit status)可以在脚本中由$? 引用. 这个机制使脚本函数也可以像C
函数一样有一个"
 返回值".
 return
 终止一个函数.return
命令[1]可选地带一个整数参数,这个整数作为函数的"返回值"返回
 给调用此函数的脚本,并且这个值也被赋给变量$?.

 while true可以写为while :



 Example 23-7 两个数中的最大者
 ###################Start Script#################
 1 #!/bin/bash
 2 # max.sh: 两个整数中的最大者.
 3
 4 E_PARAM_ERR=-198 # 如果传给函数的参数少于2 个时的返回值.
 5 EQUAL=-199 # 如果两个整数值相等的返回值.
 6 # 任一个传给函数的参数值溢出
 7 #
 8
 9 max2 () # 返回两个整数的较大值.
 10 { # 注意: 参与比较的数必须小于257.
 11 if [ -z "$2" ]
 12 then
 13 return $E_PARAM_ERR
 14 fi
 15
 16 if [ "$1" -eq "$2" ]
 17 then
 18 return $EQUAL
 19 else
 20 if [ "$1" -gt "$2" ]
 21 then
 22 return $1
 23 else
 24 return $2
 25 fi
 26 fi
 27 }
 28
 29 max2 33 34
 30 return_val=$?
 31
 32 if [ "$return_val" -eq $E_PARAM_ERR ]
 33 then
 34 echo "Need to pass two parameters to the function."
 35 elif [ "$return_val" -eq $EQUAL ]
 36 then
 37 echo "The two numbers are equal."
 38 else
 39 echo "The larger of the two numbers is $return_val."
 40 fi
 41
 42
 43 exit 0
 44
 45 # 练习 (容易):
 46 # ---------------
 47 # 把这个脚本转化成交互式的脚本,
 48 #+ 也就是说,让脚本可以要求调用者输入两个整数.
 #####################End Script##################

** [[http://blog.163.com/redzang@yeah/blog/static/64918585201201474716158/][grep、egrep和fgrep命令--Linux文件内容查询命令  ]]    :blog:

1.命令功能：

       grep命令用来在文本文件中查找指定模式的词或短语，并在标准输出上显示包括给定字符串模式的所有行；

       egrep命令等同于grep -E，可以使用扩展的字符串模式进行搜索；

       fgrep命令等同于grep -F，是快速搜索命令，它检索固定字符串，但不识别正则表达式。

2.一般格式：

grep [选项] [查找模式] [文件名1，文件名2，……]

    fgrep [选项] [查找模式] [文件名1，文件名2，……]

        egrep [选项] [查找模式] [文件名1，文件名2，……]

3.常用选项：

- E 每个模式作为一个扩展的正则表达式对待。

- F 每个模式作为一组固定字符串对待（以新行分隔），而不作为正则表达式。

- b在输出的每一行前显示包含匹配字符串的行在文件中的字节偏移量。

- c 只显示匹配行的数量。

- i 比较时不区分大小写。

- h 在查找多个文件时，指示grep不要将文件名加入到输出之前。

- l 显示首次匹配串所在的文件名并用换行符将其隔开。当在某文件中多次出现匹配串时，不重复显示此文件名。

- n 在输出前加上匹配串所在行的行号（文件首行行号为1）。

- v 只显示不包含匹配串的行。

- x 只显示整行严格匹配的行。

- e expression 指定检索使用的模式。用于防止以“-”开头的模式被解释为命令选项。

- f expfile 从expfile文件中获取要搜索的模式，一个模式占一行

 4.注意以下方面：

在命令后键入搜索的模式，再键入要搜索的文件。其中，文件名列表中也可以使用特殊字符，如“*”等，用来生成文件名列表。如果想在搜索的模式中包含有空格的字符串，可以用单引号把要搜索的模式括起来，用来表明搜索的模式是由包含空格的字符串组成。否则，Shell将把空格认为是命令行参数的定界符，而grep命令将把搜索模式中的单词解释为文件名列表中的一部分。在下面的例子中，grep命令在文件example中搜索模式“text file”。

$ grep ’text file’ example

用户可以在命令行上用Shell特殊字符来生成将要搜索的文件名列表。在下面的例子中，特殊字符“*”用来生成一个文件名列表，该列表包含当前目录下所有的文件。该命令将搜索出当前目录下所有文件中与模式匹配的行。

$ grep data *

特殊字符在搜索一组指定的文件时非常有用。例如，如果想搜索所有的C程序源文件中特定的模式，您可以用“*.c”来指定文件名列表。假设用户的 C程序中包含一些不必要的转向语句（goto语句），想要找到这些语句，可以用如下的命令来搜索并显示所有包含goto语句的代码行：

$ grep goto *.c

用户可以在命令行上键入搜索模式，也可以使用-f选项从指定文件中读取要搜索的模式。在文件中，每个搜索模式占一行。如果经常要搜索一组常见字符串时，这个功能非常有用。在下面的例子中，用户要在文件exam中搜索字符串“editor”和“create”，就把要搜索的模式放置在文件mypats中，然后，grep命令从文件mypats中读取要搜索的模式。

$ cat mypats

editor

create

$ grep -f mypats exam

** [[http://tommy9394.com/blog/linux/linux-command/41.html][Linux中的crond指令用法]]    :blog:

cron是一個linux下的定時執行工具，可以在無需人工干預的情況下運行作業。由於Cron 是Linux的內置服務，但它不自動起來，可以用以下的方法啟動、關閉這個服務:


/sbin/service crond start //啟動服務
/sbin/service crond stop //關閉服務
/sbin/service crond restart //重啟服務
/sbin/service crond reload //重新載入配置
1
2
3
4
/sbin/service crond start //啟動服務
/sbin/service crond stop //關閉服務
/sbin/service crond restart //重啟服務
/sbin/service crond reload //重新載入配置
1.crontab指令選項:


-u 指定一個用戶,
-l 列出某個用戶的任務計劃,
-r 刪除某個用戶的任務,
-e 編輯某個用戶的任務
1
2
3
4
-u 指定一個用戶,
-l 列出某個用戶的任務計劃,
-r 刪除某個用戶的任務,
-e 編輯某個用戶的任務
2.cron文件語法:


分     小時   日       月       星期     命令
0-59   0-23   1-31   1-12     0-6     command     (取值範圍,0表示週日一般一行對應一個任務)
3.記住幾個特殊符號的含義:
「*」代表取值範圍內的數字,
「/」代表」每」,
「-」代表從某個數字到某個數字,
「,」分開幾個離散的數字
1
2
3
4
5
6
7
分     小時   日       月       星期     命令
0-59   0-23   1-31   1-12     0-6     command     (取值範圍,0表示週日一般一行對應一個任務)
3.記住幾個特殊符號的含義:
「*」代表取值範圍內的數字,
「/」代表」每」,
「-」代表從某個數字到某個數字,
「,」分開幾個離散的數字
任務調度設置文件的寫法
可用crontab -e命令來編輯,編輯的是/var/spool/cron下對應用戶的cron文件,也可以直接修改/etc/crontab文件
具體格式如下：


Minute Hour Day Month Dayofweek   command
分鐘     小時   天     月       天每星期       命令
每個字段代表的含義如下：
Minute             每個小時的第幾分鐘執行該任務
Hour               每天的第幾個小時執行該任務
Day                 每月的第幾天執行該任務
Month             每年的第幾個月執行該任務
DayOfWeek     每週的第幾天執行該任務
Command       指定要執行的程序
1
2
3
4
5
6
7
8
9
Minute Hour Day Month Dayofweek   command
分鐘     小時   天     月       天每星期       命令
每個字段代表的含義如下：
Minute             每個小時的第幾分鐘執行該任務
Hour               每天的第幾個小時執行該任務
Day                 每月的第幾天執行該任務
Month             每年的第幾個月執行該任務
DayOfWeek     每週的第幾天執行該任務
Command       指定要執行的程序
在這些字段裡，除了「Command」是每次都必須指定的字段以外，其它字段皆為可選字段，可視需要決定。對於不指定的字段，要用「*」來填補其位置。
舉例如下：


5       *       *           *     *     ls             指定每小時的第5分鐘執行一次ls命令
30     5       *           *     *     ls             指定每天的 5:30 執行ls命令
30     7       8         *     *     ls             指定每月8號的7：30分執行ls命令
30     5       8         6     *     ls             指定每年的6月8日5：30執行ls命令
30     6       *           *     0     ls             指定每星期日的6:30執行ls命令[註：0表示星期天，1表示星期1，以此類推，也可以用英文來表示，sun表示星期天，mon表示星期一等。]
30     3     10,20     *     *     ls     每月10號及20號的3：30執行ls命令[註：「，」用來連接多個不連續的時段]
25     8-11 *           *     *     ls       每天8-11點的第25分鐘執行ls命令[註：「-」用來連接連續的時段]
*/15   *       *           *     *     ls         每15分鐘執行一次ls命令 [即每個小時的第0 15 30 45 60分鐘執行ls命令 ]
30   6     */10         *     *     ls       每個月中，每隔10天6:30執行一次ls命令[即每月的1、11、21、31日是的6：30執行一次ls命令。 ]
每天7：50以root 身份執行/etc/cron.daily目錄中的所有可執行文件
50   7       *             *     *     root     run-parts     /etc/cron.daily   [ 註：run-parts參數表示，執行後面目錄中的所有可執行文件。
添加後保存的路徑是/var/spool/cron,可以用vi查看修改，這個不難
1
2
3
4
5
6
7
8
9
10
11
12
5       *       *           *     *     ls             指定每小時的第5分鐘執行一次ls命令
30     5       *           *     *     ls             指定每天的 5:30 執行ls命令
30     7       8         *     *     ls             指定每月8號的7：30分執行ls命令
30     5       8         6     *     ls             指定每年的6月8日5：30執行ls命令
30     6       *           *     0     ls             指定每星期日的6:30執行ls命令[註：0表示星期天，1表示星期1，以此類推，也可以用英文來表示，sun表示星期天，mon表示星期一等。]
30     3     10,20     *     *     ls     每月10號及20號的3：30執行ls命令[註：「，」用來連接多個不連續的時段]
25     8-11 *           *     *     ls       每天8-11點的第25分鐘執行ls命令[註：「-」用來連接連續的時段]
*/15   *       *           *     *     ls         每15分鐘執行一次ls命令 [即每個小時的第0 15 30 45 60分鐘執行ls命令 ]
30   6     */10         *     *     ls       每個月中，每隔10天6:30執行一次ls命令[即每月的1、11、21、31日是的6：30執行一次ls命令。 ]
每天7：50以root 身份執行/etc/cron.daily目錄中的所有可執行文件
50   7       *             *     *     root     run-parts     /etc/cron.daily   [ 註：run-parts參數表示，執行後面目錄中的所有可執行文件。
添加後保存的路徑是/var/spool/cron,可以用vi查看修改，這個不難
添加時間同步的
做任務計劃。


 * */1 * * * /usr/bin/rdate -s time-b.nist.gov
 * */1 * * * /usr/sbin/ntpdate time.windows.com
1
2
 * */1 * * * /usr/bin/rdate -s time-b.nist.gov
 * */1 * * * /usr/sbin/ntpdate time.windows.com
加入這兩句。
vps 和實際主機的時鐘頻率是不一樣的，所以必須得計劃同步，這個是一小時同步一次。
當出現問題，用這兩個就可以了
rdate -s stdtime.gov.hk
hwclock –systohc

Tags: Cron, crond, Linux

** [[http://blog.csdn.net/hguisu/article/details/7470695][C语言中的宏定义]]    :blog:



[[http://blog.csdn.net/hguisu/article/category/1080443][作者同类文章]]/X/

版权声明：本文为博主原创文章，未经博主允许不得转载。

***

1. 简单宏定义

简单的宏定义有如下格式：

[#define指令（简单的宏）]　　#define  标识符替换列表

替换列表是一系列的C语言记号，包括标识符、关键字、数、字符常量、字符串字面量、运算符和标点符号。当预处理器遇到一个宏定义时，会做一个
“标识符”代表“替换列表”的记录。在文件后面的内容中，不管标识符在任何位置出现，预处理器都会用替换列表代替它。

| 不要在宏定义中放置任何额外的符号，否则它们会被作为替换列表的一部分。一种常见的错误是在宏定义中使用 = ：                                                                                            |
|                                                                                                                                                                                                    |
| #+BEGIN_EXAMPLE                                                                                                                                                                                    |
|     #define N = 100       /*** WRONG ***/                                                                                                                                                          |
|     int a[N];            /* 会成为 int a[= 100]; */                                                                                                                                                |
| #+END_EXAMPLE                                                                                                                                                                                      |
|                                                                                                                                                                                                    |
| 在上面的例子中，我们（错误地）把N定义成一对记号（= 和100）。                                                                                                                                       |
|                                                                                                                                                                                                    |
| 在宏定义的末尾使用分号结尾是另一个常见错误：                                                                                                                                                       |
|                                                                                                                                                                                                    |
| #+BEGIN_EXAMPLE                                                                                                                                                                                    |
|     #define N 100;       /*** WRONG ***/                                                                                                                                                           |
|     int a[N];            /*    become int a[100;]; */                                                                                                                                              |
| #+END_EXAMPLE                                                                                                                                                                                      |
|                                                                                                                                                                                                    |
| 这里N被定义为100和;两个记号。                                                                                                                                                                      |
|                                                                                                                                                                                                    |
| 在一个宏定义中，编译器可以检测到绝大多数由多余符号所导致的错误。但不幸的是，编译器会将每一处使用这个宏的地方标为错误，而不会直接找到错误的根源------宏定义本身，因为宏定义已经被预处理器删除了。   |

简单的宏主要用来定义那些被Kernighan和Ritchie称为“明示常量”（manifest
constant）的东西。使用宏，我们可以给数值、字符和字符串命名。

#+BEGIN_EXAMPLE
    #define STE_LEN 80

    #defineTRUE     1

    #defineFALSE    0

    #definePI        3.14159

    #defineCR        '\r'

    #defineEOS       '\0'
#+END_EXAMPLE

使用#define来为常量命名有许多显著的优点：

1)
、 程序会更易读。一个认真选择的名字可以帮助读者理解常量的意义。否则，程序将包含大量的“魔法数”，使读者难以理解。

2)
、 程序会更易于修改。我们仅需要改变一个宏定义，就可以改变整个程序中出现的所有该常量的值。“硬编码的”常量会更难于修改，特别是有时候当他们以稍微不同的形式出现时。（例如，如果一个程序包含一个长度为100的数组，它可能会包含一个从0到99的循环。如果我们只是试图找到所有程序中出现的100，那么就会漏掉99。）

3)
、可以帮助避免前后不一致或键盘输入错误。假如数值常量3.14159在程序中大量出现，它可能会被意外地写成3.1416或3.14195。

虽然简单的宏常用于定义常量名，但是它们还有其他应用。

4)
、可以对C语法做小的修改。实际上，我们可以通过定义宏的方式给C语言符号添加别名，从而改变C语言的语法。例如，对于习惯使用Pascal的begin和end（而不是C语言的{和}）的程序员，可以定义下面的宏：

#+BEGIN_EXAMPLE
    #define BEGIN  {

    #define END    }
#+END_EXAMPLE

我们甚至可以发明自己的语言。例如，我们可以创建一个LOOP“语句”，来实现一个无限循环：

#define LOOP  for (;;)

当然，改变C语言的语法通常不是个好主意，因为它会使程序很难被其他程序员所理解。

5) 、对类型重命名。在5.2节中，我们通过重命名int创建了一个Boolean类型：

#+BEGIN_EXAMPLE
    #define BOOL int
#+END_EXAMPLE

虽然有些程序员会使用宏定义的方式来实现此目的，但类型定义（7.6节）仍然是定义新类型的最佳方法。

6)
、控制条件编译。如将在14.4节中看到的那样，宏在控制条件编译中起重要的作用。例如，在程序中出现的宏定义可能表明需要将程序在“调试模式”下进行编译，来使用额外的语句输出调试信息：

#+BEGIN_EXAMPLE
    #define DEBUG
#+END_EXAMPLE

这里顺便提一下，如上面的例子所示，宏定义中的替换列表为空是合法的。

当宏作为常量使用时，C程序员习惯在名字中只使用大写字母。但是并没有如何将用于其他目的的宏大写的统一做法。由于宏（特别是带参数的宏）可能是程序中错误的来源，所以一些程序员更喜欢使用大写字母来引起注意。其他人则倾向于小写，即按照Kernighan和Ritchie编写的/The
C Programming Language/一书中的样式。

***

2. 带参数的宏

带参数的宏定义有如下格式：

[#define指令---带参数的宏]　　#define 标识符（/x/_{1},
/x/_{2},...,/x_{n}/）替换列表

其中/x/_{1},
/x/_{2},...,/x_{n}/是标识符（宏的参数）。这些参数可以在替换列表中根据需要出现任意次。

| 在宏的名字和左括号之间必须没有空格。如果有空格，预处理器会认为是在定义一个简单的宏，其中（/x/_{1},/x/_{2},...,/x_{n}/）是替换列表的一部分。   |

当预处理器遇到一个带参数的宏，会将定义存储起来以便后面使用。在后面的程序中，如果任何地方出现了标识符（/y/_{1},/y/_{2},...,/y_{n}/）格式的宏调用（其中/y/_{1},/y/_{2},...,/y_{n}/是一系列标记），预处理器会使用替换列表替代，并使用/y/_{1}替换/x/_{1}，/y/_{2}替换/x/_{2}，依此类推。

例如，假定我们定义了如下的宏：

#+BEGIN_EXAMPLE
    #define MAX(x,y)    ((x)>(y) ? (x) :(y))

    #define IS_EVEN(n)   ((n)%2==0)
#+END_EXAMPLE

现在如果后面的程序中有如下语句：

#+BEGIN_EXAMPLE
    i = MAX(j+k, m-n);

    if (IS_EVEN(i)) i++;
#+END_EXAMPLE

预处理器会将这些行替换为

#+BEGIN_EXAMPLE
    i = ((j+k)>(m-n)?(j+k):(m-n));
    if (((i)%2==0)) i++;
#+END_EXAMPLE

如这个例子所显示的，带参数的宏经常用来作为一些简单的函数使用。MAX类似一个从两个值中选取较大的值的函数。IS_EVEN则类似于另一种函数，该函数当参数为偶数时返回1，否则返回0。

下面的例子是一个更复杂的宏：

#+BEGIN_EXAMPLE
    #define TOUPPER(c)('a'<=(c)&&(c)<='z'?(c)-'a'+'A':(c))
#+END_EXAMPLE

这个宏检测一个字符c是否在'a'与'z'之间。如果在的话，这个宏会用'c'减去'a'再加上'A'，来计算出c所对应的大写字母。如果c不在这个范围，就保留原来的c。像这样的字符处理的宏非常有用，所以C语言库在<ctype.h>（23.4节）中提供了大量的类似的宏。其中之一就是toupper，与我们上面的TOUPPER例子作用一致（但会更高效，可移植性也更好）。

带参数的宏可以包含空的参数列表，如下例所示：

#+BEGIN_EXAMPLE
    #define getchar() getc(stdin)
#+END_EXAMPLE

空的参数列表不是一定确实需要，但可以使getchar更像一个函数。（没错，这就是<stdio.h>中的getchar，getchar的确就是个宏，不是函数------虽然它的功能像个函数。）

  *使用带参数的宏替代实际的函数的优点*：

1) 、
程序可能会稍微快些。一个函数调用在执行时通常会有些额外开销------存储上下文信息、复制参数的值等。而一个宏的调用则没有这些运行开销。

2) 、
宏会更“通用”。与函数的参数不同，宏的参数没有类型。因此，只要预处理后的程序依然是合法的，宏可以接受任何类型的参数。例如，我们可以使用MAX宏从两个数中选出较大的一个，数的类型可以是int，long
int，float，double等等。

 *但是带参数的宏也有一些缺点。*

1) 、
编译后的代码通常会变大。每一处宏调用都会导致插入宏的替换列表，由此导致程序的源代码增加（因此编译后的代码变大）。宏使用得越频繁，这种效果就越明显。当宏调用嵌套时，这个问题会相互叠加从而使程序更加复杂。思考一下，如果我们用MAX宏来找出3个数中最大的数会怎样？

#+BEGIN_EXAMPLE
    n = MAX(i, MAX(j,k));
#+END_EXAMPLE

下面是预处理后的这条语句：

#+BEGIN_EXAMPLE
    n=((i)>(((j)>(k)?(j):(k)))?(i):(((j)>(k)?(j):(k))));
#+END_EXAMPLE

2)
、宏参数没有类型检查。当一个函数被调用时，编译器会检查每一个参数来确认它们是否是正确的类型。如果不是，或者将参数转换成正确的类型，或者由编译器产生一个出错信息。预处理器不会检查宏参数的类型，也不会进行类型转换。

3)
、无法用一个指针来指向一个宏。如在17.7节中将看到的，C语言允许指针指向函数。这一概念在特定的编程条件下非常有用。宏会在预处理过程中被删除，所以不存在类似的“指向宏的指针”。因此，宏不能用于处理这些情况。

4)
、宏可能会不止一次地计算它的参数。函数对它的参数只会计算一次，而宏可能会计算两次甚至更多次。如果参数有副作用，多次计算参数的值可能会产生意外的结果。考虑下面的例子，其中MAX的一个参数有副作用：

#+BEGIN_EXAMPLE
    n = MAX(i++, j);
#+END_EXAMPLE

下面是这条语句在预处理之后的结果：

#+BEGIN_EXAMPLE
    n =((i++)>(j)?(i++):(j));
#+END_EXAMPLE

如果i大于j，那么i可能会被（错误地）增加了两次，同时n可能被赋予了错误的值。

| 由于多次计算宏的参数而导致的错误可能非常难于发现，因为宏调用和函数调用看起来是一样的。更糟糕的是，这类宏可能在大多数情况下正常工作，仅在特定参数有副作用时失效。为了自保护，最好避免使用带有副作用的参数。   |

带参数的宏不仅适用于模拟函数调用。他们特别经常被作为模板，来处理我们经常要重复书写的代码段。如果我们已经写烦了语句

#+BEGIN_EXAMPLE
    printf("%d"\n, x);
#+END_EXAMPLE

因为每次要显示一个整数x都要使用它。我们可以定义下面的宏，使显示整数变得简单些：

#+BEGIN_EXAMPLE
    #define PRINT_INT(x)    printf("%d\n", x)
#+END_EXAMPLE

一旦定义了PRINT_INT，预处理器会将这行

#+BEGIN_EXAMPLE
    PRINT_INT(i/j);
    //转换为
    printf("%d\n", i/j);
#+END_EXAMPLE

***

3. #运算符


 宏定义可以包含两个运算符：#和##。*编译器不会识别这两种运算符相反，它们会在预处理时被执行*。

#运算符将一个宏的参数转换为字符串字面量*(*字符串字面量（string
literal）是指双引号引住的一系列字符，双引号中可以没有字符，可以只有一个字符，也可以有很多个字符),，
简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号. 它仅允许出现在带参数的宏的替换列表中。（一些C程序员将#操作理解为“stringization（字符串化）”；其他人则认为这实在是对英语的滥用。）用比较官方的话说就是将语言符号(Token)转化为字符串。


#运算符有大量的用途，这里只来讨论其中的一种。假设我们决定在调试过程中使用PRINT_INT宏作为一个便捷的方法，来输出一个整型变量或表达式的值。#运算符可以使PRINT_INT为每个输出的值添加标签。下面是改进后的PRINT_INT：

#+BEGIN_EXAMPLE
    #define PRINT_INT(x) printf(#x " = %d\n", x)
#+END_EXAMPLE

x之前的#运算符通知预处理器根据PRINT_INT的参数创建一个字符串字面量。因此，调用

#+BEGIN_EXAMPLE
    PRINT_INT(i/j);
    //会变为
    printf("i/j" " = %d\n", i/j);
#+END_EXAMPLE

在C语言中相邻的字符串字面量会被合并，因此上边的语句等价于：

#+BEGIN_EXAMPLE
    printf("i/j = %d\n", i/j);
#+END_EXAMPLE

当程序执行时，printf函数会同时显示表达式i/j和它的值。例如，如果i是11，j是2的话，输出为

i/j = 5

TIPI例子：

#+BEGIN_EXAMPLE
    #define STR(x) #x

    int main(int argc char** argv)
    {
        printf("%s\n", STR(It's a long string)); // 输出 It's a long str
        return 0;
    }
#+END_EXAMPLE

***

4. ##运算符


 在C语言的宏中，"##"被称为 连接符（concatenator），*它是一种预处理运算符*，
用来把两个语言符号(Token)组合成单个语言符号。
这里的语言符号不一定是宏的变量。并且双井号不能作为第一个或最后一个元素存在.

##运算符可以将两个记号（例如标识符）“粘”在一起，成为一个记号。（无需惊讶，##运算符被称为“记号粘合”。）如果其中一个操作数是宏参数，“粘合”会在当形式参数被相应的实际参数替换后发生。考虑下面的宏：

如下例子:当MK_ID被调用时（比如MK_ID(1)），预处理器首先使用自变量（这个例子中是1）替换参数n。接着，预处理器将i和1连接成为一个记号（i1）。下面的声明使用MK_ID创建了3个标识符：

#+BEGIN_EXAMPLE
    #define MK_ID(n) i##n
    int MK_ID(1), MK_ID(2), MK_ID(3);
    //预处理后声明变为：
    int i1, i2, i3;
#+END_EXAMPLE


##运算符不属于预处理器经常使用的特性。实际上，想找到一些使用它的情况是比较困难的。为了找到一个有实际意义的##的应用，我们来重新思考前面提到过的MAX宏。如我们所见，当MAX的参数有副作用时会无法正常工作。一种解决方法是用MAX宏来写一个max函数。遗憾的是，往往一个max函数是不够的。我们可能需要一个实际参数是int值的max函数，还需要参数为float值的max函数，等等。除了实际参数的类型和返回值的类型之外，这些函数都一样。因此，这样定义每一个函数似乎是个很蠢的做法。


 解决的办法是定义一个宏，并使它展开后成为max函数的定义。宏会有唯一的参数type，它表示形式参数和返回值的类型。这里还有个问题，如果我们是用宏来创建多个max函数，程序将无法编译。（C语言不允许在同一文件中出现两个同名的函数。）为了解决这个问题，我们是用##运算符为每个版本的max函数构造不同的名字。下面的例子：请注意宏的定义中是如何将type和_max相连来形成新函数名的。假如我们需要一个针对float值的max函数。

#+BEGIN_EXAMPLE
    #define GENERIC_MAX (type)           \
    type type##_max(type x,  type y)    \
    {                                      \
      return x > y ? x :y;              \
    }
    GENERIC_MAX(float)
#+END_EXAMPLE

//预处理器会将这行展开为下面的代码：
 float float_max(float x, float y) { return x > y ? x :y; }

再如：

#+BEGIN_EXAMPLE
    #define PHP_FUNCTION            ZEND_FUNCTION
    #define ZEND_FUNCTION(name)             ZEND_NAMED_FUNCTION(ZEND_FN(name))
    #define ZEND_FN(name) zif_##name
    #define ZEND_NAMED_FUNCTION(name)       void name(INTERNAL_FUNCTION_PARAMETERS)
    #define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value, zval **return_value_ptr, \
    zval *this_ptr, int return_value_used TSRMLS_DC

    PHP_FUNCTION(count);
#+END_EXAMPLE


 //  预处理器处理以后， PHP_FUCNTION(count);就展开为如下代码

#+BEGIN_EXAMPLE
    void zif_count(int ht, zval *return_value, zval **return_value_ptr,
            zval *this_ptr, int return_value_used TSRMLS_DC)
#+END_EXAMPLE

宏ZEND_FN(name)中有一个"##"，它的作用一如之前所说，是一个连接符，将zif和宏的变量name的值连接起来。
以这种连接的方式以基础，多次使用这种宏形式，可以将它当作一个代码生成器，这样可以在一定程度上减少代码密度，
我们也可以将它理解为一种代码重用的手段，间接地减少不小心所造成的错误。

***

5. 宏的通用属性

现在我们已经讨论过简单的宏和带参数的宏了，我们来看一下它们都需要遵守的规则。
 1)
、宏的替换列表可以包含对另一个宏的调用。例如，我们可以用宏PI来定义宏TWO_PI：
 #definePI      3.14159
 #defineTWO_PI  (2*PI)

当预处理器在后面的程序中遇到TWO_PI时，会将它替换成（2*PI）。接着，预处理器会重新检查替换列表，看它是否包含其他宏的调用（在这个例子中，调用了宏PI）。预处理器会不断重新检查替换列表，直到将所有的宏名字都替换掉为止。


 2)
、预处理器只会替换完整的记号，而不会替换记号的片断。因此，预处理器会忽略嵌在标识符名、字符常量、字符串字面量之中的宏名。例如，假设程序含有如下代码行：

#+BEGIN_EXAMPLE
    #define SIZE 256
    int BUFFER_SIZE;
    if (BUFFER_SIZE> SIZE)
       puts("Error ： SIZEexceeded");
    //预处理后，这些代码行会变为：
    int BUFFER_SIZE;
    if (BUFFER_SIZE> 256)
      puts("Error ：SIZEexceeded");
#+END_EXAMPLE

标识符BUFFER_ZISE和字符串"Error:SIZE
exceeded"没有被预处理影响，虽然它们都包含SIZE。

3)
、一个宏定义的作用范围通常到出现这个宏的文件末尾。由于宏是由预处理器处理的，他们不遵从通常的范围规则。一个定义在函数中的宏并不是仅在函数内起作用，而是作用到文件末尾。

4)
、宏不可以被定义两遍，除非新的定义与旧的定义是一样的。小的间隔上的差异是允许的，但是宏的替换列表（和参数，如果有的话）中的记号都必须一致。

5) 、宏可以使用#undef指令“取消定义”。#undef指令有如下形式：
 [#undef指令]　　#undef  标识符
 其中标识符是一个宏名。例如，指令
 #undef N

会删除宏N当前的定义。（如果N没有被定义成一个宏，#undef指令没有任何作用。）#undef指令的一个用途是取消一个宏的现有定义，以便于重新给出新的定义。

***

6. 宏定义中圆括号


在我们前面定义的宏的替换列表中有大量的圆括号。确实需要它们吗？答案是绝对需要。如果我们少用几个圆括号，宏可能有时会得到意料之外的------而且是不希望有的结果。*对于在一个宏定义中哪里要加圆括号有两条规则要遵守：*

首先，如果宏的替换列表中有运算符，那么始终要将替换列表放在括号中：

#define TWO_PI (2*3.14159)
 其次，如果宏有参数，每次参数在替换列表中出现时都要放在圆括号中：
 #define SCALE(x) ((x)*10)

没有括号的话，我们将无法确保编译器会将替换列表和参数作为完整的表达式。编译器可能会不按我们期望的方式应用运算符的优先级和结合性规则。

为了展示为替换列表添加圆括号的重要性，考虑下面的宏定义，其中的替换列表没有添加圆括号：
 #define TWO_PI 2*3.14159
   /* 需要给替换列表加圆括号 */
 在预处理时，语句
 conversion_factor = 360/TWO_PI;
 //变为
 conversion_factor = 360/2*3.14159;
 除法会在乘法之前执行，产生的结果并不是期望的结果。

当宏有参数时，仅给替换列表添加圆括号是不够的。参数的每一次出现都要添加圆括号。例如，假设SCALE定义如下：
 #define SCALE(x) (x*10)   /* 需要给x添加括号 */
 在预处理过程中，语句
 j = SCALE(i+1);
 变为
 j = (i+1*10);
 由于乘法的优先级比加法高，这条语句等价于
 j = i+10;
 当然，我们希望的是
 j = (i+1)*10;

在宏定义中缺少圆括号会导致C语言中最让人讨厌的错误。程序通常仍然可以编译通过，而且宏似乎也可以工作，仅在少数情况下会出错。

***

7. 创建较长的宏

**** 1. 较长的宏中的逗号运算符


在创建较长的宏时，逗号运算符会十分有用。特别是可以使用逗号运算符来使替换列表包含一系列表达式。例如，下面的宏会读入一个字符串，再把字符串显示出来：

#define ECHO(s) (get(s), puts(s))


gets函数和puts函数的调用都是表达式，因此使用逗号运算符连接它们是合法的。我们甚至可以把ECHO宏当作一个函数来使用：
 ECHO(str);   /* 替换为 (gets(str), puts(str)); */

除了使用逗号运算符，我们也许还可以将gets函数和puts函数的调用放在大括号中形成复合语句：
 #define ECHO(s)  { gets(s);  puts(s);  }
 遗憾的是，这种方式并不奏效。假如我们将ECHO宏用于下面的if语句：

#+BEGIN_EXAMPLE
    if (echo_flag)
      ECHO(str);
    else
      gets(str);
    //将ECHO宏替换会得到下面的结果：
    if (echo_flag)
      { gets(str); puts(str);  };
    else
      gets(str);
#+END_EXAMPLE


 编译器会将头两行作为完整的if语句：

#+BEGIN_EXAMPLE
    if (echo_flag)
      { gets(str);  puts(str);  }
#+END_EXAMPLE


编译器会将跟在后面的分号作为空语句，并且对else子句产生出错信息，因为它不属于任何if语句。我们可以通过记住永远不要在ECHO宏后面加分号来解决这个问题。但是这样做会使程序看起来有些怪异。逗号运算符可以解决ECHO宏的问题，但并不能解决所有宏的问题。假如一个宏需要包含一系列的语句，而不仅仅是一系列的表达式，这时逗号运算符就起不到帮助的作用了。因为它只能连接表达式，不能连接语句。解决的方法是将语句放在do循环中，并将条件设置为假：

**** *2. 宏定义中的do-while循环do *

do循环必须始终随跟着一个分号，因此我们不会遇到在if语句中使用宏那样的问题了。为了看到这个技巧（嗯，应该说是技术）的实际作用，让我们将它用于ECHO宏中：

#+BEGIN_EXAMPLE
    #define ECHO(s)       \
          do{           \
               gets (s) ;      \
               puts (s) ;      \
          } while  (0)
#+END_EXAMPLE

当使用ECHO宏时，一定要加分号：
 ECHO(str);
   /* becomes do {  gets(str); puts(str); } while (0);  */
 为什么在宏定义时需要使用do-while语句呢?
我们知道do-while循环语句是先执行循环体再判断条件是否成立，
所以说至少会执行一次。当使用do{
}while(0)时由于条件肯定为false，代码也肯定只

 执行一次， 肯定只执行一次的代码为什么要放在do-while语句里呢?
这种方式适用于宏定义中存在多语句的情况。 如下所示代码：

#+BEGIN_EXAMPLE
    #define TEST(a, b)  a++;b++;

    if (expr)
        TEST(a, b);
    else
        do_else();
    代码进行预处理后，会变成：
    if (expr)
        a++;b++;
    else
        do_else();
#+END_EXAMPLE




这样if-else的结构就被破坏了if后面有两个语句，这样是无法编译通过的，那为什么非要do-while而不是简单的用{}括起来呢。
这样也能保证if后面只有一个语句。例如上面的例子，在调用宏TEST的时候后面加了一个分号，
虽然这个分号可有可无， 但是出于习惯我们一般都会写上。
那如果是把宏里的代码用{}括起来，加上最后的那个分号。 还是不能通过编译。
所以一般的多表达式宏定义中都采用do-while(0)的方式。

**** *3. "空操作"的定义*


了解了do-while循环在宏中的作用，再来看"空操作"的定义。在PHP源码中，由于PHP需要考虑到平台的移植性和不同的系统配置，
所以需要在某些时候把一些宏的操作定义为空操作。例如在sapi\thttpd\thttpd.c

文件中的VEC_FREE():

#+BEGIN_EXAMPLE
    #ifdef SERIALIZE_HEADERS
        # define VEC_FREE() smart_str_free(&vec_str)
    #else
        # define VEC_FREE() do {} while (0)
    #endif
#+END_EXAMPLE



这里涉及到条件编译，在定义了SERIALIZE_HEADERS宏的时候将VEC_FREE()定义为如上的内容，而没有定义时，
不需要做任何操作，所以后面的宏将VEC_FREE()定义为一个空操作，不做任何操作，通

 常这样来保证一致性， 或者充分利用系统提供的功能。

有时也会使用如下的方式来定义“空操作”，这里的空操作和上面的还是不一样，例如很常见的Debug日志打印宏：

#+BEGIN_EXAMPLE
    #ifdef DEBUG
    #   define LOG_MSG printf
    #else
    #   define LOG_MSG(...)
    #endif
#+END_EXAMPLE



在编译时如果定义了DEBUG则将LOG_MSG当做printf使用，而不需要调试，正式发布时则将LOG_MSG()宏定义为空，
由于宏是在预编译阶段进行处理的，所以上面的宏相当于从代码中删除了。


上面提到了两种将宏定义为空的定义方式，看上去一样，实际上只要明白了宏都只是简单的代码替换就知道该如何选择了。

***

8. 预定义宏

在C语言中预定义了一些有用的宏，*见*表预定义宏**。这些宏主要是提供当前编译的信息。宏__LINE__和__STDC__是整型常量，其他3个宏是字符串字面量。
 *表预定义宏:*
 __LINE__      被编译的文件的行数
 __FILE__      被编译的文件的名字
 __DATE__    编译的日期（格式"Mmm dd yyyy"）
 __TIME__    编译的时间（格式"hh:mm:ss"）
 __STDC__  如果编译器接受标准C，那么值为1



1)、 __DATE__宏和__TIME__宏指明程序编译的时间。例如，假设程序以下面的语句开始：

printf("Wacky Windows (c) 1996 Wacky Software, Inc.\n");

printf("Compiled on %s at %s\n", __DATE__,__TIME__);

 每次程序开始执行，程序都会显示下面两行：
 Wacky Windows (c) 1996 Wacky Software, Inc.
 Compiled on Dec 23 1996 at 22:18:48
 这样的信息可以帮助区分同一个程序的不同版本。

2)、我们可以使用__LINE__宏和__FILE__宏来找到错误。考虑下面这个检测被零除的除法的发生位置的问题。当一个C程序因为被零除而导致中止时，通常没有信息指明哪条除法运算导致错误。下面的宏可以帮助我们查明错误的根源：
 #define CHECK_ZERO(divisor)  \
   if (divisor == 0)  \
     printf("*** Attempt to divide byzero on line %d  "  \
             "of file %s  ***\n",__LINE__, __FILE__)
 CHECK_ZERO宏应该在除法运算前被调用：
 CHECK_ZERO(j);
 k = i / j;
 如果j是0，会显示出如下形式的信息：
 *** Attempt to divide by zero on line 9 of file FOO.c ***

类似这样的错误检测的宏非常有用。实际上，C语言库提供了一个通用的、用于错误检测的宏------assert宏
  再如：
 #line 838 "Zend/zend_language_scanner.c"

 #line预处理用于改变当前的行号（__LINE__）和文件名（__FILE__）。
如上所示代码，将当前的行号改变为838，文件名Zend/zend_language_scanner.c
它的作用体现在编译器的编写中，我们知道

 编译器对C 源码编译过程中会产生一些中间文件，通过这条指令，
可以保证文件名是固定的，不会被这些中间文件代替，有利于进行调试分析。



***

9. C语言中常用的宏

*01: 防止一个头文件被重复包含*

 #ifndef COMDEF_H
 #define COMDEF_H
 //头文件内容
 #endif
 *02: 重新定义一些类型*

防止由于各种平台和编译器的不同,而产生的类型字节数差异,方便移植。

typedef  unsigned char      boolean;     /* Boolean value type. */
 typedef  unsigned long int  uint32;      /* Unsigned 32 bit value */
 typedef  unsigned short     uint16;      /* Unsigned 16 bit value */
 typedef  unsigned char      uint8;       /* Unsigned 8  bit value */
 typedef  signed long int    int32;       /* Signed 32 bit value */
 typedef  signed short       int16;       /* Signed 16 bit value */
 typedef  signed char        int8;        /* Signed 8  bit value */

 //下面的不建议使用
 typedef  unsigned char     byte;         /* Unsigned 8  bit value type.
*/
 typedef  unsigned short    word;         /* Unsinged 16 bit value type.
*/
 typedef  unsigned long     dword;        /* Unsigned 32 bit value type.
*/
 typedef  unsigned char     uint1;        /* Unsigned 8  bit value type.
*/
 typedef  unsigned short    uint2;        /* Unsigned 16 bit value type.
*/
 typedef  unsigned long     uint4;        /* Unsigned 32 bit value type.
*/
 typedef  signed char       int1;         /* Signed 8  bit value type.
*/
 typedef  signed short      int2;         /* Signed 16 bit value type.
*/
 typedef  long int          int4;         /* Signed 32 bit value type.
*/
 typedef  signed long       sint31;       /* Signed 32 bit value */
 typedef  signed short      sint15;       /* Signed 16 bit value */
 typedef  signed char       sint7;        /* Signed 8  bit value */

 *03: 得到指定地址上的一个字节或字*
 #define  MEM_B(x) (*((byte *)(x)))
 #define  MEM_W(x) (*((word *)(x)))

*04: 求最大值和最小值*

#define  MAX(x,y) (((x)>(y)) ? (x) : (y))
 #define  MIN(x,y) (((x) < (y)) ? (x) : (y))

*05: 得到一个field在结构体(struct)中的偏移量*

#define FPOS(type,field) ((dword)&((type *)0)->field)

*06: 得到一个结构体中field所占用的字节数*
 #define FSIZ(type,field) sizeof(((type *)0)->field)

*07: 按照LSB格式把两个字节转化为一个Word*

#define FLIPW(ray) ((((word)(ray)[0]) * 256) + (ray)[1])

*08: 按照LSB格式把一个Word转化为两个字节*
 #define FLOPW(ray,val) (ray)[0] = ((val)/256); (ray)[1] = ((val) &
0xFF)

*09: 得到一个变量的地址（word宽度）*

#define B_PTR(var)  ((byte *) (void *) &(var))
 #define W_PTR(var)  ((word *) (void *) &(var))

 *10: 得到一个字的高位和低位字节*
 #define WORD_LO(xxx)  ((byte) ((word)(xxx) & 255))
 #define WORD_HI(xxx)  ((byte) ((word)(xxx) >> 8))

 *11: 返回一个比X大的最接近的8的倍数*
 #define RND8(x) ((((x) + 7)/8) * 8

*12: 将一个字母转换为大写*

#define UPCASE(c) (((c)>='a' && (c) <= 'z') ? ((c) -- 0×20) : (c))

*13: 判断字符是不是10进值的数字*

#define  DECCHK(c) ((c)>='0' && (c)<='9')

*14: 判断字符是不是16进值的数字*

#define HEXCHK(c) (((c) >= '0' && (c)<='9') ((c)>='A' && (c)<= 'F') \
 ((c)>='a' && (c)<='f'))

 *15: 防止溢出的一个方法*
 #define INC_SAT(val) (val=((val)+1>(val)) ? (val)+1 : (val))

 *16: 返回数组元素的个数*
 #define ARR_SIZE(a)  (sizeof((a))/sizeof((a[0])))

 *17: 返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2\^n)*
 #define MOD_BY_POWER_OF_TWO( val, mod_by ) ((dword)(val) &
(dword)((mod_by)-1))

 *18: 对于IO空间映射在存储空间的结构,输入输出处理*
 #define inp(port) (*((volatile byte *)(port)))
 #define inpw(port) (*((volatile word *)(port)))
 #define inpdw(port) (*((volatile dword *)(port)))
 #define outp(port,val) (*((volatile byte *)(port))=((byte)(val)))
 #define outpw(port, val) (*((volatile word *)(port))=((word)(val)))
 #define outpdw(port, val) (*((volatile dword
*)(port))=((dword)(val)))

 *19: 使用一些宏跟踪调试*
 ANSI标准说明了五个预定义的宏名。它们是：
 __LINE__
 __FILE__
 __DATE__
 __TIME__
 __STDC__

 C++中还定义了 __cplusplus

如果编译器不是标准的,则可能仅支持以上宏名中的几个,或根本不支持。记住编译程序也许还提供其它预定义的宏名。
 __LINE__ 及 __FILE__
宏指示，#line指令可以改变它的值，简单的讲，编译时，它们包含程序的当前行数和文件名。
 __DATE__
宏指令含有形式为月/日/年的串,表示源文件被翻译到代码时的日期。
 __TIME__ 宏指令包含程序编译的时间。时间用字符串表示，其形式为：
分：秒
 __STDC__
宏指令的意义是编译时定义的。一般来讲，如果__STDC__已经定义，编译器将仅接受不包含任何非标准扩展的标准C/C++代码。如果实现是标准的,则宏__STDC__含有十进制常量1。如果它含有任何其它数,则实现是非标准的。
 __cplusplus
与标准c++一致的编译器把它定义为一个包含至少6为的数值。与标准c++不一致的编译器将使用具有5位或更少的数值。

 可以定义宏,例如:当定义了_DEBUG,输出数据信息和所在文件所在行
 #ifdef _DEBUG
 #define DEBUGMSG(msg,date)
printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)
 #else
 #define DEBUGMSG(msg,date)
 #endif
 *20： 宏定义防止错误使用小括号包含。*
 例如：
 有问题的定义：#define DUMP_WRITE(addr,nr) {memcpy(bufp,addr,nr); bufp
+= nr;}
 应该使用的定义： #difne DO(a,b) do{a+b;a++;}while(0)
 例如：

#+BEGIN_EXAMPLE
    if(addr)
        DUMP_WRITE(addr,nr);
    else
        do_somethong_else();
    //宏展开以后变成这样:
    if(addr)
        {memcpy(bufp,addr,nr); bufp += nr;};
    else
        do_something_else();
#+END_EXAMPLE


 gcc
在碰到else前面的“；”时就认为if语句已经结束，因而后面的else不在if语句中。而采用do{}
while(0)的定义，在任何情况下都没有问题。而改为 #difne DO(a,b)
do{a+b;a++;}while(0) 的定义则在任何情况下都不会出错。

** [[http://www.cnblogs.com/pharen/archive/2012/02/06/2340257.html][C语言的布尔类型]]    :blog:

在C语言标准(C89)没有定义布尔类型，所以C语言判断真假时以0为假，非0为真。所以我们通常使用逻辑变量的做法：

#+BEGIN_EXAMPLE
    //定义一个int类型变量，当变量值为0时表示false，值为1时表示trueint flag;flag = 0;//......flag = 1;if( flag ){//......}
#+END_EXAMPLE



但这种做法不直观，而且没有明确flag一定是布尔值。所以我们又借助C语言的宏定义：

#+BEGIN_EXAMPLE
    //宏定义布尔类型#define BOOL int#define TRUE 1#define FALSE 0//定义一个布尔变量BOOL flag = FALSE;
#+END_EXAMPLE



这种方法虽然直观，但依然是换汤不换药，变量flag在编译器看来依然是int类型。

新版本总会改进一些不好的地方，所以在最新的C语言标准(C99)解决了布尔类型的问题。C99提供了_Bool
型，所以布尔类型可以声明为 _Bool flag。

_Bool依然仍是整数类型，但与一般整型不同的是，_Bool变量只能赋值为0或1，非0的值都会被存储为1。

C99还提供了一个头文件 <stdbool.h>
定义了bool代表_Bool，true代表1，false代表0。只要导入 stdbool.h
，就能非常方便的操作布尔类型了。

#+BEGIN_EXAMPLE
    //导入 stdbool.h 来使用布尔类型#include <stdbool.h>#include <stdio.h>//计算n!,n的值在main中定义int main(void){    int n = 10;    //计算叠乘数    int sum = 1; //用来存放叠乘的结果    bool flag = false;    //叠乘标记        int num = n;    //循环次数    while( !flag )    {        sum = sum * (num--);        //当num=1时结束循环        if( num == 1)        {            flag = true;        }    }    printf ("%d的叠乘值为 %d \n", n, sum);    return 0;}
#+END_EXAMPLE

** 回车与换行    :blog:

符号    ASCII码      意义
\n        10        换行NL
\r        13        回车CR

回车 \r 本义是光标重新回到本行开头，r的英文return，控制字符可以写成CR，即Carriage Return
换行 \n 本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成LF，即Line Feed

换行好理解，就是跳到下一行嘛

回车嘛

在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。
于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。
这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。
后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。
Unix系统里，每行结尾只有“<换行>”，即“\n”；Windows系统里面，每行结尾是“<换行><回车 >”，即“\n\r”；Mac系统里，每行结尾是“<回车>”(新的OSX的结尾同Unix）。一个直接后果是，Unix/Mac系统下的文件在Windows里打开 的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。

** *(int*)0=0    :blog:

*（int *）0 = 0
C语言中(int *)表示将操作对象强制类型转换为int *类，即整形指针，这里是将0转换为int *，所以返回值还是0，不过类型发生了强制转换，成为int *型。你可以这样想象，有一个指向NULL的int *指针，和这个地方的(int *)0是等价的，因为当行ansi/iso-c99标准规定NULL指针为0x00000000，即内存中的“第0号地址”。


故意引发CPU异常,进入操作系统SEH处理。


0地址是linux系统内核特别定义的一个地址，专门指向空指针，用来捕捉空指针读写的错误。

** [[http://www.cnblogs.com/charley_yang/archive/2010/12/15/1907384.html][]]    :blog:

** [[http://www.cnblogs.com/charley_yang/archive/2010/12/15/1907384.html][C++ typedef用法小结 （※不能不看※）]]    :blog:

Posted on 2010-12-15 23:47
[[http://www.cnblogs.com/charley_yang/][charley_yang]] 阅读(...)
评论(...) [[http://i.cnblogs.com/EditPosts.aspx?postid=1907384][编辑]]
[[#][收藏]]

*第一、四个用途*

*用途一：*

定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。比如：
char* pa, pb; //
这多数不符合我们的意图，它只声明了一个指向字符变量的指针，
// 和一个字符变量；
以下则可行：
typedef char* PCHAR; // 一般用大写
PCHAR pa, pb; // 可行，同时声明了两个指向字符变量的指针
虽然：
char *pa, *pb;
也可行，但相对来说没有用typedef的形式直观，尤其在需要大量指针的地方，typedef的方式更省事。

*用途二：*

用在旧的C的代码中（具体多旧没有查），帮助struct。以前的代码中，声明struct新对象时，必须要带上struct，即形式为：
struct 结构名 对象名，如：
struct tagPOINT1
{
int x;
int y;
};
struct tagPOINT1 p1;

而在C++中，则可以直接写：结构名 对象名，即：
tagPOINT1 p1;

估计某人觉得经常多写一个struct太麻烦了，于是就发明了：
typedef struct tagPOINT
{
int x;
int y;
}POINT;

POINT p1; //
这样就比原来的方式少写了一个struct，比较省事，尤其在大量使用的时候

或许，在C++中，typedef的这种用途二不是很大，但是理解了它，对掌握以前的旧代码还是有帮助的，毕竟我们在项目中有可能会遇到较早些年代遗留下来的代码。

*用途三：*

用typedef来定义与平台无关的类型。
比如定义一个叫 REAL
的浮点类型，在目标平台一上，让它表示最高精度的类型为：
typedef long double REAL;
在不支持 long double 的平台二上，改为：
typedef double REAL;
在连 double 都不支持的平台三上，改为：
typedef float REAL;
也就是说，当跨平台时，只要改下 typedef
本身就行，不用对其他源码做任何修改。
标准库就广泛使用了这个技巧，比如size_t。
另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健（虽然用宏有时也可以完成以上的用途）。

*用途四：*

为复杂的声明定义一个新的简单的别名。方法是：在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例：

1. 原声明：int *(*a[5])(int, char*);
变量名为a，直接用一个新别名pFun替换a就可以了：
typedef int *(*pFun)(int, char*);
原声明的最简化版：
pFun a[5];

2. 原声明：void (*b[10]) (void (*)());
变量名为b，先替换右边部分括号里的，pFunParam为别名一：
typedef void (*pFunParam)();
再替换左边的变量b，pFunx为别名二：
typedef void (*pFunx)(pFunParam);
原声明的最简化版：
pFunx b[10];

3. 原声明：doube(*)() (*e)[9];
变量名为e，先替换左边部分，pFuny为别名一：
typedef double(*pFuny)();
再替换右边的变量e，pFunParamy为别名二
typedef pFuny (*pFunParamy)[9];
原声明的最简化版：
pFunParamy e;

理解复杂声明可用的“右左法则”：
从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：
int (*func)(int *p);
首先找到变量名func，外面有一对圆括号，而且左边是一个*号，这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明(*func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int*类型的形参，返回值类型是int。
int (*func[5])(int *);
func右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的*不是修饰func，而是修饰func[5]的，原因是[]运算符优先级比*高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指针，它指向的函数具有int*类型的形参，返回值类型为int。

也可以记住2个模式：
type (*)(....)函数指针
type (*)[]数组指针

*第二、两大陷阱*

*陷阱一：*

记住，typedef是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。比如：
先定义：
typedef char* PSTR;
然后：
int mystrcmp(const PSTR, const PSTR);

const PSTR实际上相当于const char*吗？不是的，它实际上相当于char*
const。
原因在于const给予了整个指针本身以常量性，也就是形成了常量指针char*
const。
简单来说，记住当const和typedef一起出现时，typedef不会是简单的字符串替换就行。

*陷阱二：*

typedef在语法上是一个存储类的关键字（如auto、extern、mutable、static、register等一样），虽然它并不真正影响对象的存储特性，如：
typedef static int INT2; //不可行
编译将失败，会提示“指定了一个以上的存储类”。

*以上资料出自：*[[http://blog.sina.com.cn/s/blog_4826f7970100074k.html]]
作者：赤龙

*第三、typedef 与 #define的区别*

案例一：

通常讲，typedef要比#define要好，特别是在有指针的场合。请看例子：

typedef char *pStr1;

#define pStr2 char *;

pStr1 s1, s2;

pStr2 s3, s4;

在上述的变量定义中，s1、s2、s3都被定义为char
*，而s4则定义成了char，不是我们所预期的指针变量，根本原因就在于#define只是简单的字符串替换而typedef则是为一个类型起新名字。

案例二：

下面的代码中编译器会报一个错误，你知道是哪个语句错了吗？

typedef char * pStr;

char string[4] = "abc";

const char *p1 = string;

const pStr p2 = string;

p1++;

p2++;

是p2++出错了。这个问题再一次提醒我们：typedef和#define不同，它不是简单的文本替换。上述代码中const
pStr p2并不等于const char * p2。const pStr p2和const long
x本质上没有区别，都是对变量进行只读限制，只不过此处变量p2的数据类型是我们自己定义的而不是系统固有类型而已。因此，const
pStr p2的含义是：限定数据类型为char *的变量p2为只读，因此p2++错误。

*第四部分资料：使用 typedef 抑制劣质代码*

作者：Danny Kalev
编译：MTT 工作室

原文出处：Using typedef to Curb Miscreant Code

*摘要：*Typedef
声明有助于创建平台无关类型，甚至能隐藏复杂和难以理解的语法。不管怎样，使用
typedef 能为代码带来意想不到的好处，通过本文你可以学习用 typedef
避免缺欠，从而使代码更健壮。

typedef 声明，简称 typedef，为现有类型创建一个新的名字。比如人们常常使用
typedef 来编写更美观和可读的代码。所谓美观，意指 typedef
能隐藏笨拙的语法构造以及平台相关的数据类型，从而增强可移植性和以及未来的可维护性。本文下面将竭尽全力来揭示
typedef 强大功能以及如何避免一些常见的陷阱。

Q：如何创建平台无关的数据类型，隐藏笨拙且难以理解的语法?

A： 使用 typedefs 为现有类型创建同义字。

*定义易于记忆的类型名*
typedef
使用最多的地方是创建易于记忆的类型名，用它来归档程序员的意图。类型出现在所声明的变量名字中，位于
''typedef'' 关键字右边。例如：

#+BEGIN_EXAMPLE
    typedef int size;
#+END_EXAMPLE

此声明定义了一个 int 的同义字，名字为 size。注意 typedef
并不创建新的类型。它仅仅为现有类型添加一个同义字。你可以在任何需要 int
的上下文中使用 size：

#+BEGIN_EXAMPLE
    void measure(size * psz); size array[4];size len = file.getlength();std::vector <size> vs;
#+END_EXAMPLE

typedef
还可以掩饰符合类型，如指针和数组。例如，你不用象下面这样重复定义有 81
个字符元素的数组：

#+BEGIN_EXAMPLE
    char line[81];char text[81];
#+END_EXAMPLE

定义一个 typedef，每当要用到相同类型和大小的数组时，可以这样：

#+BEGIN_EXAMPLE
    typedef char Line[81]; Line text, secondline;getline(text);
#+END_EXAMPLE

同样，可以象下面这样隐藏指针语法：

#+BEGIN_EXAMPLE
    typedef char * pstr;int mystrcmp(pstr, pstr);
#+END_EXAMPLE

这里将带我们到达第一个 typedef 陷阱。标准函数 strcmp()有两个‘const char
*'类型的参数。因此，它可能会误导人们象下面这样声明 mystrcmp()：

#+BEGIN_EXAMPLE
    int mystrcmp(const pstr, const pstr);
#+END_EXAMPLE

这是错误的，按照顺序，‘const pstr'被解释为‘char * const'（一个指向 char
的常量指针），而不是‘const char *'（指向常量 char
的指针）。这个问题很容易解决：

#+BEGIN_EXAMPLE
    typedef const char * cpstr; int mystrcmp(cpstr, cpstr); // 现在是正确的
#+END_EXAMPLE

*记住：*不管什么时候，只要为指针声明 typedef，那么都要在最终的 typedef
名称中加一个 const，以使得该指针本身是常量，而不是对象。

*代码简化*
上面讨论的 typedef 行为有点像 #define
宏，用其实际类型替代同义字。不同点是 typedef
在编译时被解释，因此让编译器来应付超越预处理器能力的文本替换。例如：

#+BEGIN_EXAMPLE
    typedef int (*PF) (const char *, const char *);
#+END_EXAMPLE

这个声明引入了 PF 类型作为函数指针的同义字，该函数有两个 const char *
类型的参数以及一个 int
类型的返回值。如果要使用下列形式的函数声明，那么上述这个 typedef
是不可或缺的：

#+BEGIN_EXAMPLE
    PF Register(PF pf);
#+END_EXAMPLE

Register() 的参数是一个 PF
类型的回调函数，返回某个函数的地址，其署名与先前注册的名字相同。做一次深呼吸。下面我展示一下如果不用
typedef，我们是如何实现这个声明的：

#+BEGIN_EXAMPLE
    int (*Register (int (*pf)(const char *, const char *))) (const char *, const char *);
#+END_EXAMPLE

很少有程序员理解它是什么意思，更不用说这种费解的代码所带来的出错风险了。显然，这里使用
typedef
不是一种特权，而是一种必需。持怀疑态度的人可能会问：“OK，有人还会写这样的代码吗？”，快速浏览一下揭示
*//* signal()函数的头文件 <csinal>，一个有同样接口的函数。

*typedef 和存储类关键字（storage class specifier）*
这种说法是不是有点令人惊讶，typedef 就像
auto，extern，mutable，static，和 register
一样，是一个存储类关键字。这并是说 typedef
会真正影响对象的存储特性；它只是说在语句构成上，typedef 声明看起来象
static，extern 等类型的变量声明。下面将带到第二个陷阱：

#+BEGIN_EXAMPLE
    typedef register int FAST_COUNTER; // 错误
#+END_EXAMPLE

编译通不过。问题出在你不能在声明中有多个存储类关键字。因为符号 typedef
已经占据了存储类关键字的位置，在 typedef 声明中不能用
register（或任何其它存储类关键字）。

*促进跨平台开发*
typedef
有另外一个重要的用途，那就是定义机器无关的类型，例如，你可以定义一个叫
REAL 的浮点类型，在目标机器上它可以i获得最高的精度：

#+BEGIN_EXAMPLE
    typedef long double REAL;
#+END_EXAMPLE

在不支持 long double 的机器上，该 typedef 看起来会是下面这样：

#+BEGIN_EXAMPLE
    typedef double REAL;
#+END_EXAMPLE

并且，在连 double 都不支持的机器上，该 typedef 看起来会是这样： 、

#+BEGIN_EXAMPLE
    typedef float REAL;
#+END_EXAMPLE

你不用对源代码做任何修改，便可以在每一种平台上编译这个使用 REAL
类型的应用程序。唯一要改的是 typedef
本身。在大多数情况下，甚至这个微小的变动完全都可以通过奇妙的条件编译来自动实现。不是吗?
标准库广泛地使用 typedef 来创建这样的平台无关类型：size_t，ptrdiff 和
fpos_t 就是其中的例子。此外，象 std::string 和 std::ofstream 这样的
typedef
还隐藏了长长的，难以理解的模板特化语法，例如：basic_string<char,
char_traits<char>，allocator<char>> 和 basic_ofstream<char,
char_traits<char>>。

** [[http://www.cnblogs.com/dc10101/archive/2007/08/22/865556.html][static的作用]]    :blog:



在C语言中，static的字面意思很容易把我们导入歧途，其实它的作用有三条。

（1）先来介绍它的第一条也是最重要的一条：隐藏。

当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。为理解这句话，我举例来说明。我们要同时编译两个源文件，一个是a.c，另一个是main.c。

下面是a.c的内容

char a = 'A'; // global variable
 void msg()
 {
  printf("Hello\n");
 }



下面是main.c的内容

int main(void)
 {
  extern char a; // extern variable must be declared before use
  printf("%c ", a);
  (void)msg();
  return 0;
 }



程序的运行结果是：

A Hello

你可能会问：为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。

如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。Static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用。

（2）static的第二个作用是保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见，但我还是举一个例子。

#include <stdio.h>

 int fun(void){
  static int count = 10; // 事实上此赋值语句从来没有执行过
  return count--;
 }

 int count = 1;

 int main(void)
 {
  printf("global\t\tlocal static\n");
  for(; count <= 10; ++count)
  printf("%d\t\t%d\n", count, fun());

  return 0;
 }



程序的运行结果是：

global  local static

1  10

2  9

3  8

4  7

5  6

6  5

7  4

8   3

9  2

10  1



（3）static的第三个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加'\0'太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是'\0'。不妨做个小实验验证一下。

#include <stdio.h>

 int a;

 int main(void)
 {
  int i;
  static char str[10];

  printf("integer: %d; string: (begin)%s(end)", a, str);

  return 0;
 }

程序的运行结果如下

integer: 0; string: (begin)(end)

最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。

** [[http://www.cnblogs.com/wanghetao/archive/2012/04/04/2431760.html][sizeof和sizeof(string)的问题]]    :blog:

今天看《程序员面试宝典》一书（为了应付将要到来的微软笔试），看到了sizeof(string)这个问题。在Dev
C++上测试的结果是4，很不明白。上网搜了一下，得到如下结果：

string strArr1[]={"Trend", "Micro", "Soft"};

sizeof(strArr1)=12



转自：[[http://apps.hi.baidu.com/share/detail/30398570]]

关于sizeof(string)，今天看那本面试宝典的时候看到这个表达式，有点吃惊，书上写着sizeof(string)=4;当时很纳闷，难道分配4个字节大小的内存给string吗？查阅了相关资料得出结论：string的实现在各库中可能有所不同，但是在同一库中相同一点是，无论你的string里放多长的字符串，它的sizeof()都是固定的，字符串所占的空间是从堆中动态分配的，与sizeof()无关。

sizeof(string)=4可能是最典型的实现之一，不过也有sizeof()为12、32字节的库实现。
但是VC6.0测试后sizeof(string)=16.还是跟编译器有关

#include<iostream>
using namespace std;
void main(void)
{
string a[] = {"aaaaa","bbbb","ccc"};
int x = sizeof(a);
int y = sizeof(string);
cout << x << endl;
cout << y << endl;
}

运行结果：

[[file:///C:/DOCUME~1/stoneboy/LOCALS~1/Temp/B59W8R[2QW0H)63MOX0[8UU.jpg]]

关于sizeof更多的用法摘自：[[http://hi.baidu.com/haijiaoshu/blog/item/a269f527706b910a908f9d5b.html]]

1、什么是sizeof

  首先看一下sizeof在msdn上的定义：

  The sizeof keyword gives the amount of storage, in bytes, associated
with a variable or a type (including aggregate types). This keyword
returns a value of type size_t.


看到return这个字眼，是不是想到了函数？错了，sizeof不是一个函数，你见过给一个函数传参数，而不加括号的吗？sizeof可以，所以sizeof不是函数。网上有人说sizeof是一元操作符，但是我并不这么认为，因为sizeof更像一个特殊的宏，它是在编译阶段求值的。举个例子：



cout<<sizeof(int)<<endl; // 32位机上int长度为4

cout<<sizeof(1==2)<<endl; // == 操作符返回bool类型，相当于
cout<<sizeof(bool)<<endl;

  在编译阶段已经被翻译为：

cout<<4<<endl;

cout<<1<<endl;

  这里有个陷阱，看下面的程序：

int a = 0;

cout<<sizeof(a=3)<<endl;

cout<<a<<endl;


输出为什么是4，0而不是期望中的4，3？？？就在于sizeof在编译阶段处理的特性。由于sizeof不能被编译成机器码，所以sizeof作用范围内，也就是()里面的内容也不能被编译，而是被替换成类型。=操作符返回左操作数的类型，所以a=3相当于int，而代码也被替换为：

int a = 0;

cout<<4<<endl;

cout<<a<<endl;


所以，sizeof是不可能支持链式表达式的，这也是和一元操作符不一样的地方。


结论：不要把sizeof当成函数，也不要看作一元操作符，把他当成一个特殊的编译预处理。

2、sizeof的用法

  sizeof有两种用法：



  （1）sizeof(object)

  也就是对对象使用sizeof，也可以写成sizeof object 的形式。例如：

  （2）sizeof(typename)

  也就是对类型使用sizeof，注意这种情况下写成sizeof
typename是非法的。下面举几个例子说明一下：



int i = 2;

cout<<sizeof(i)<<endl; // sizeof(object)的用法，合理

cout<<sizeof i<<endl; // sizeof object的用法，合理

cout<<sizeof 2<<endl; // 2被解析成int类型的object, sizeof
object的用法，合理

cout<<sizeof(2)<<endl; // 2被解析成int类型的object,
sizeof(object)的用法，合理

cout<<sizeof(int)<<endl;// sizeof(typename)的用法，合理

cout<<sizeof int<<endl; // 错误！对于操作符，一定要加()

  可以看出，加()是永远正确的选择。

  结论：不论sizeof要对谁取值，最好都加上()。

3、数据类型的sizeof

（1）C++固有数据类型

  32位C++中的基本数据类型，也就char,short int(short),int,long
int(long),float,double, long double

大小分别是：1，2，4，4，4，8, 10。

  考虑下面的代码：

cout<<sizeof(unsigned int) == sizeof(int)<<endl; // 相等，输出 1

  unsigned影响的只是最高位bit的意义，数据长度不会被改变的。

  结论：unsigned不能影响sizeof的取值。

（2）自定义数据类型

  typedef可以用来定义C++自定义类型。考虑下面的问题：

typedef short WORD;

typedef long DWORD;

cout<<(sizeof(short) == sizeof(WORD))<<endl; // 相等，输出1

cout<<(sizeof(long) == sizeof(DWORD))<<endl; // 相等，输出1

  结论：自定义类型的sizeof取值等同于它的类型原形。

（3）函数类型

  考虑下面的问题：

int f1(){return 0;};

double f2(){return 0.0;}

void f3(){}

cout<<sizeof(f1())<<endl; // f1()返回值为int，因此被认为是int

cout<<sizeof(f2())<<endl; // f2()返回值为double，因此被认为是double

cout<<sizeof(f3())<<endl; // 错误！无法对void类型使用sizeof

cout<<sizeof(f1)<<endl;  // 错误！无法对函数指针使用sizeof

cout<<sizeof*f2<<endl;  //
*f2，和f2()等价，因为可以看作object，所以括号不是必要的。被认为是double

  结论：对函数使用sizeof，在编译阶段会被函数返回值的类型取代，

4、指针问题

  考虑下面问题：



cout<<sizeof(string*)<<endl; // 4

cout<<sizeof(int*)<<endl; // 4

cout<<sizof(char****)<<endl; // 4


可以看到，不管是什么类型的指针，大小都是4的，因为指针就是32位的物理地址。

  结论：只要是指针，大小就是4。（64位机上要变成8也不一定）。


顺便唧唧歪歪几句，C++中的指针表示实际内存的地址。和C不一样的是，C++中取消了模式之分，也就是不再有small,middle,big,取而代之的是统一的flat。flat模式采用32位实地址寻址，而不再是c中的
segment:offset模式。举个例子，假如有一个指向地址
f000:8888的指针，如果是C类型则是8888(16位,
只存储位移，省略段)，far类型的C指针是f0008888(32位，高位保留段地址，地位保留位移),C++类型的指针是f8888(32位，相当于段地址*16
+ 位移，但寻址范围要更大)。

5、数组问题

  考虑下面问题：

char a[] = "abcdef";

int b[20] = {3, 4};

char c[2][3] = {"aa", "bb"};



cout<<sizeof(a)<<endl; // 7

cout<<sizeof(b)<<endl; // 20*4=80

cout<<sizeof(c)<<endl; // 6




数组a的大小在定义时未指定，编译时给它分配的空间是按照初始化的值确定的，也就是7。c是多维数组，占用的空间大小是各维数的乘积，也就是6。可以看出，数组的大小就是他在编译时被分配的空间，也就是各维数的乘积*数组元素的大小。

  结论：数组的大小是各维数的乘积*数组元素的大小。

  这里有一个陷阱：

int *d = new int[10];

cout<<sizeof(d)<<endl; // 4


d是我们常说的动态数组，但是他实质上还是一个指针，所以sizeof(d)的值是4。

  再考虑下面的问题：

double* (*a)[3][6];



cout<<sizeof(a)<<endl;  // 4

cout<<sizeof(*a)<<endl;  // 72

cout<<sizeof(**a)<<endl; // 24

cout<<sizeof(***a)<<endl; // 4

cout<<sizeof(****a)<<endl; // 8

  a是一个很奇怪的定义，他表示一个指向
double*[3][6]类型数组的指针。既然是指针，所以sizeof(a)就是4。


既然a是执行double*[3][6]类型的指针，*a就表示一个double*[3][6]的多维数组类型，因此sizeof(*a)=3*6*sizeof(double*)=72。同样的，**a表示一个double*[6]类型的数组，所以sizeof(**a)=6*sizeof(double*)=24。***a就表示其中的一个元素，也就是double*了，所以sizeof(***a)=4。至于****a，就是一个double了，所以sizeof(****a)=sizeof(double)=8。

6、向函数传递数组的问题。

  考虑下面的问题：

#include <iostream>

using namespace std;

int Sum(int i[])

{

int sumofi = 0;

for (int j = 0; j < sizeof(i)/sizeof(int); j++) //实际上，sizeof(i) = 4

{

  sumofi += i[j];

}

return sumofi;

}

int main()

{

int allAges[6] = {21, 22, 22, 19, 34, 12};

cout<<Sum(allAges)<<endl;

system("pause");

return 0;

}


Sum的本意是用sizeof得到数组的大小，然后求和。但是实际上，传入自函数Sum的，只是一个int
类型的指针，所以sizeof(i)=4，而不是24，所以会产生错误的结果。解决这个问题的方法使是用指针或者引用。

  使用指针的情况：

int Sum(int (*i)[6])

{

int sumofi = 0;

for (int j = 0; j < sizeof(*i)/sizeof(int); j++) //sizeof(*i) = 24

{

  sumofi += (*i)[j];

}

return sumofi;

}

int main()

{

int allAges[] = {21, 22, 22, 19, 34, 12};

cout<<Sum(&allAges)<<endl;

system("pause");

return 0;

}

  在这个Sum里，i是一个指向i[6]类型的指针，注意，这里不能用int Sum(int
(*i)[])声明函数，而是必须指明要传入的数组的大小，不然sizeof(*i)无法计算。但是在这种情况下，再通过sizeof来计算数组大小已经没有意义了，因为此时大小是指定为6的。

使用引用的情况和指针相似：

int Sum(int (&i)[6])

{

int sumofi = 0;

for (int j = 0; j < sizeof(i)/sizeof(int); j++)

{

  sumofi += i[j];

}

return sumofi;

}

int main()

{

int allAges[] = {21, 22, 22, 19, 34, 12};

cout<<Sum(allAges)<<endl;

system("pause");

return 0;

}


这种情况下sizeof的计算同样无意义，所以用数组做参数，而且需要遍历的时候，函数应该有一个参数来说明数组的大小，而数组的大小在数组定义的作用域内通过sizeof求值。因此上面的函数正确形式应该是：

#include <iostream>

using namespace std;

int Sum(int *i, unsigned int n)

{

int sumofi = 0;

for (int j = 0; j < n; j++)

{

  sumofi += i[j];

}

return sumofi;

}

int main()

{

int allAges[] = {21, 22, 22, 19, 34, 12};

cout<<Sum(i, sizeof(allAges)/sizeof(int))<<endl;

system("pause");

return 0;

}

7、字符串的sizeof和strlen

  考虑下面的问题：

char a[] = "abcdef";

char b[20] = "abcdef";

string s = "abcdef";

cout<<strlen(a)<<endl;  // 6，字符串长度

cout<<sizeof(a)<<endl;  // 7，字符串容量

cout<<strlen(b)<<endl;  // 6，字符串长度

cout<<sizeof(b)<<endl;  // 20，字符串容量

cout<<sizeof(s)<<endl;  // 12,
这里不代表字符串的长度，而是string类的大小

cout<<strlen(s)<<endl;  // 错误！s不是一个字符指针。

a[1] = '\0';

cout<<strlen(a)<<endl;  // 1

cout<<sizeof(a)<<endl;  // 7，sizeof是恒定的


strlen是寻找从指定地址开始，到出现的第一个0之间的字符个数，他是在运行阶段执行的，而sizeof是得到数据的大小，在这里是得到字符串的容量。所以对同一个对象而言，sizeof的值是恒定的。string是C++类型的字符串，他是一个类，所以sizeof(s)表示的并不是字符串的长度，而是类string的大小。strlen(s)根本就是错误的，因为strlen的参数是一个字符指针，如果想用strlen得到s字符串的长度，应该使用sizeof(s.c_str())，因为string的成员函数c_str()返回的是字符串的首地址。实际上，string类提供了自己的成员函数来得到字符串的容量和长度，分别是Capacity()和Length()。string封装了常用了字符串操作，所以在C++开发过程中，最好使用string代替C类型的字符串。

8、从union的sizeof问题看cpu的对界

  考虑下面问题：（默认对齐方式）

union u

{

  double a;

  int b;

};

union u2

{

  char a[13];

  int b;

};

union u3

{

  char a[13];

  char b;

};

cout<<sizeof(u)<<endl;  // 8

cout<<sizeof(u2)<<endl;  // 16

cout<<sizeof(u3)<<endl;  // 13


都知道union的大小取决于它所有的成员中，占用空间最大的一个成员的大小。所以对于u来说，大小就是最大的double类型成员a了，所以sizeof(u)=sizeof(double)=8。但是对于u2和u3，最大的空间都是char[13]类型的数组，为什么u3的大小是13，而u2是16呢？关键在于u2中的成员int
b。由于int类型成员的存在，使u2的对齐方式变成4，也就是说，u2的大小必须在4的对界上，所以占用的空间变成了16（最接近13的对界）。


结论：复合数据类型，如union，struct，class的对齐方式为成员中对齐方式最大的成员的对齐方式。


顺便提一下CPU对界问题，32的C++采用8位对界来提高运行速度，所以编译器会尽量把数据放在它的对界上以提高内存命中率。对界是可以更改的，使用#pragma
pack(x)宏可以改变编译器的对界方式，默认是8。C++固有类型的对界取编译器对界方式与自身大小中较小的一个。例如，指定编译器按2对界，int类型的大小是4，则int的对界为2和4中较小的2。在默认的对界方式下，因为几乎所有的数据类型都不大于默认的对界方式8（除了long
double），所以所有的固有类型的对界方式可以认为就是类型自身的大小。更改一下上面的程序：

#pragma pack(2)

union u2

{

  char a[13];

  int b;

};

union u3

{

  char a[13];

  char b;

};

#pragma pack(8)

cout<<sizeof(u2)<<endl;  // 14

cout<<sizeof(u3)<<endl;  // 13


由于手动更改对界方式为2，所以int的对界也变成了2，u2的对界取成员中最大的对界，也是2了，所以此时sizeof(u2)=14。

  结论：C++固有类型的对界取编译器对界方式与自身大小中较小的一个。

9、struct的sizeof问题


因为对齐问题使结构体的sizeof变得比较复杂，看下面的例子：(默认对齐方式下)

struct s1

{

  char a;

  double b;

  int c;

  char d;

};

struct s2

{

  char a;

  char b;

  int c;

  double d;

};

cout<<sizeof(s1)<<endl; // 24

cout<<sizeof(s2)<<endl; // 16


同样是两个char类型，一个int类型，一个double类型，但是因为对界问题，导致他们的大小不同。计算结构体大小可以采用元素摆放法，我举例子说明一下：首先，CPU判断结构体的对界，根据上一节的结论，s1和s2的对界都取最大的元素类型，也就是double类型的对界8。然后开始摆放每个元素。


对于s1，首先把a放到8的对界，假定是0，此时下一个空闲的地址是1，但是下一个元素d是double类型，要放到8的对界上，离1最接近的地址是8了，所以d被放在了8，此时下一个空闲地址变成了16，下一个元素c的对界是4，16可以满足，所以c放在了16，此时下一个空闲地址变成了20，下一个元素d需要对界1，也正好落在对界上，所以d放在了20，结构体在地址21处结束。由于s1的大小需要是8的倍数，所以21-23的空间被保留，s1的大小变成了24。


对于s2，首先把a放到8的对界，假定是0，此时下一个空闲地址是1，下一个元素的对界也是1，所以b摆放在1，下一个空闲地址变成了2；下一个元素c的对界是4，所以取离2最近的地址4摆放c，下一个空闲地址变成了8，下一个元素d的对界是8，所以d摆放在8，所有元素摆放完毕，结构体在15处结束，占用总空间为16，正好是8的倍数。


这里有个陷阱，对于结构体中的结构体成员，不要认为它的对齐方式就是他的大小，看下面的例子：

struct s1

{

  char a[8];

};

struct s2

{

  double d;

};

struct s3

{

  s1 s;

  char a;

};

struct s4

{

  s2 s;

  char a;

};

cout<<sizeof(s1)<<endl; // 8

cout<<sizeof(s2)<<endl; // 8

cout<<sizeof(s3)<<endl; // 9

cout<<sizeof(s4)<<endl; // 16;


s1和s2大小虽然都是8，但是s1的对齐方式是1，s2是8（double），所以在s3和s4中才有这样的差异。


所以，在自己定义结构体的时候，如果空间紧张的话，最好考虑对齐因素来排列结构体里的元素。

10、不要让double干扰你的位域


在结构体和类中，可以使用位域来规定某个成员所能占用的空间，所以使用位域能在一定程度上节省结构体占用的空间。不过考虑下面的代码：

struct s1

{

  int i: 8;

  int j: 4;

  double b;

  int a:3;

};

struct s2

{

  int i;

  int j;

  double b;

  int a;

};

struct s3

{

  int i;

  int j;

  int a;

  double b;

};

struct s4

{

  int i: 8;

  int j: 4;

  int a:3;

  double b;

};

cout<<sizeof(s1)<<endl;  // 24

cout<<sizeof(s2)<<endl;  // 24

cout<<sizeof(s3)<<endl;  // 24

cout<<sizeof(s4)<<endl;  // 16


可以看到，有double存在会干涉到位域（sizeof的算法参考上一节），所以使用位域的的时候，最好把float类型和double类型放在程序的开始或者最后。

** [[http://www.cnblogs.com/chenyuming507950417/archive/2012/01/05/2313647.html][C++关键字mutable]]    :blog:

Mutable

（1）mutable的意思是“可变的，易变的”，跟C++中的const是反义词。

（2）在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中

实例说明：

#+BEGIN_EXAMPLE
    #include <iostream>using namespace std;class TestMutable{public:    TestMutable(){i=0;}    int Output() const    {        return i++; //error C2166: l-value specifies const object    }private:    int i;};int main(){   TestMutable testMutable;   cout<<testMutable.Output()<<endl;   return 0;}
#+END_EXAMPLE

显然i++在const修饰的函数里是编译通不过的。

#+BEGIN_EXAMPLE
    #include <iostream>using namespace std;class TestMutable{public:    TestMutable(){i=0;}    int Output() const    {        return i++;     }private:    mutable int i;};int main(){   TestMutable testMutable;   cout<<testMutable.Output()<<endl;   return 0;}
#+END_EXAMPLE

在 int i 前面加上
mutable上面就能编译通过了，马上可以看出关键字mutable的作用了。

** PID    :blog:

PID调节器。工程上常常用在闭环系统中加入PID环节，对系统的传递函数进行修正，以快速的跟踪变化，消除稳态误差。

PID调节器中的P为比例环节，起放大作用。I为积分环节，可以消灭稳态误差。D为微分环节，可以加快系统的反应。

直流电机中加入PID调节器，可以实现快速启动。当系统中突发干扰、负载变化或者使用者主动调速是，PID环节可以帮助电机缩减过渡时间、进入新的稳定状态。




** [[http://andyhuzhill.github.io/html/shaolu.html][Linux系统下烧录单片机]]    :blog:


有些人说Linux下怎么开发单片机程 序？
我们学得都是在Windows下的开发工具和烧录工具。其实这
只是中国的情况，中国大都是用Windows系统的。所以我们也只接
触到Windows下的开发工具。在国外，许多大牛是不用Windows的。那么，他们如果要做单片机怎么办？肯定没问题的，Linux也有许多的单片机和嵌入式的开发工具。下面，我以51系列单片机为例，介绍一下怎么使用Linux系统玩单片机。



首先，说一下我的硬件和软件情况。

硬件：

一台笔记本、 一个51单片机开发板
（这个在网上有很多卖，也就150左右的价格） 。单片机芯片有两块
：一块是Atmel的AT89S52，
另一块是STC的STC89C52RC 。USB转串口线一根（串口通信和STC下载用）。USBISP下载线一根（AT89S52下载用）。

软件：

操作系统：Ubuntu
11.04 （内核2.6.38-10-generic）、 sdcc(单片机C语言编译器)、 avrdude（AT单片机下载程序）、gSTCISP(STC单片机下载程序) 、objcopy（GUN 开
发工具里的 ，应该默认Linux都会安装）



操作系统的安装就不讲了。

SDCC可以在网上下到源代码然后编译
安装。/*SDCC也有Windows版本，不过我这只讲Linux下的东西，如果有兴趣请自己百度Google一下*/

不过这样很麻烦，而且不一定安装的上。我们的ubuntu 有超级牛力（不知道这个？在终端下输入apt-get就知道啦。）直接在终端下输入以下命令：

sudo apt-get install sdcc sdcc-doc

先讲AT89S52的下载

首先是安装AT89S52的下载软件 ，还是用ubuntu的超级牛力：


 sudo apt-get install gcc-avr binutils-avr avrdude avr-libc



 然后编辑avrdude.conf 以使得avrdude可以下载51的单片机



sudo gedit /etc/avrdude.conf



在最后面加入AT89s52的相关信息(这是Joy Shukla写的)





/#------------------------------------------------------------
 # Below chips by added by me .. Joy
Shukla([[mailto:joy_shukla@yahoo.in][joy_shukla@yahoo.in]])
 # these chips can be programmed with my usbasp programmer(changed
atmega8 program)
 # after adding avrdude support in this file ..
 #------------------------------------------------------------

 #------------------------------------------------------------
 # AT89S52
 #------------------------------------------------------------
 part
 id = "8052";
 desc = "AT89S52";
 signature = 0x1E 0x52 0x06;
 chip_erase_delay = 20000;
 pgm_enable = "1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1",
 "x x x x x x x x x x x x x x x x";

 chip_erase = "1 0 1 0 1 1 0 0 1 0 0 x x x x x",
 "x x x x x x x x x x x x x x x x";

 timeout = 200;
 stabdelay = 100;
 cmdexedelay = 25;
 synchloops = 32;
 bytedelay = 0;
 pollindex = 3;
 pollvalue = 0x53;
 predelay = 1;
 postdelay = 1;
 pollmethod = 0;

 memory "flash"
 size = 8192;
 paged = no;
 min_write_delay = 4000;
 max_write_delay = 9000;
 readback_p1 = 0xff;
 readback_p2 = 0xff;
 read = " 0 0 1 0 0 0 0 0",
 " x x x a12 a11 a10 a9 a8",
 " a7 a6 a5 a4 a3 a2 a1 a0",
 " o o o o o o o o";

 write = " 0 1 0 0 0 0 0 0",
 " x x x a12 a11 a10 a9 a8",
 " a7 a6 a5 a4 a3 a2 a1 a0",
 " i i i i i i i i";
 mode = 0x21;
 delay = 12;
 ;

 memory "signature"
 size = 3;
 read = "0 0 1 0 1 0 0 0 x x x 0 0 0 a1 a0",
 "0 0 0 0 0 0 0 0 o o o o o o o o";
 ;
 ;
 #------------------------------------------------------------/

然后保存
 现在就可以烧录AT89S52的单片机了,

 用命令

 sudo avrdude -p 8052 -c usbasp -e -U flash:w:'跑马灯.hex'

就可以烧录了 你可以把命令中的”跑马灯.hex”换 成你自己的程序。

如果觉得 命令太长 太难记， 那么推荐你使用 makefile来自动完成。

我是这样做的

在工作目录下建立一个makefile， 内容如下：



###########内容开始#############

main：

sdcc liushui.c #注意 这一行以及一下每行开头都是一个Tab

packihx liushui.ihx>liushui.hex #SDCC默认的输出格式是ihx 我
们把它转换成hex

sudo avrdude -p 8052 -c usbasp -e -U flash:w:liushui.hex
#这就是烧录的语句，其实最后的格式是ihx也可以烧录的

##########内容结束###############

保存之后 在工作目录下只要输入一句 make 就 可以完成 编译 烧录
一步到位了。

/*当然你得保障程序能正常编译，下载 器和单片机都连接好了*/



接下来讲讲如何烧录STC单片机

STC的程序编写 不用我说了
。它的下载是用gSTCISP 貌似是一个中国人写的，还是图形界面的。

[[http://forum.ubuntu.org.cn/download/file.php?id=104628&sid=767b624faf73a36c71fcd4f8111773ef][gSTCISP]] [[http://forum.ubuntu.org.cn/download/file.php?id=104628&sid=767b624faf73a36c71fcd4f8111773ef][下
载地址]]如下

[[http://forum.ubuntu.org.cn/download/file.php?id=104628&sid=767b624faf73a36c71fcd4f8111773e]]

gSTCISP下载要求的格式是bin 我 在网上也没找到所谓的Hex2bin 程序 ，不过
发现用 objcopy 也 可以把 hex文件转化为bin'文件，姑且我就先这么用了。

生成hex文件后，用如下命令将hex转化为bin

objcopy -I ihex -O binary liushui.hex liushui.bin # I 和O 都 是大写

 然后 打开gSTCISP （我直接把它cp到了/usr/bin，
就可以直接在提示符下输入gSTCISP运行了）

  选择port（端 口） 我的是/dev/ttyUSB0 然后选择文件
选择刚刚生成的bin文件 点击DownLoad

  好像STC的 是要先断电再上电的时候 就能把程序写入单片机了

当你看到Program OK Have already encrypt.就说明你烧录成功啦。




写在最后：

我其实也是一个小菜鸟，这其实只是我的一次笔记而已。而且有些地方还写得很罗嗦。高手可以直接略过啦。使用Linux 做
单片机可以不用学怎么去用鼠标操纵不同图形界面的IDE（集成开发环
境），只需考虑自己要做的程序，然后记住需要的编译选项，而且SDCC是windows
Linux通用的，在linux写的代码，makefile 在windows下甚至可以不用改
或者改动少许就能使用。而且Linux不用去装什么下载线驱动，我的usbisp下载线
和usb转串口下载线都是直接插上就可以下载了。


** [[http://www.cnblogs.com/MuyouSome/p/3175806.html][时钟周期、振荡周期、机器周期、CPU周期、状态周期、指令周期、总线周期、任务周期]]    :blog:

   [[http://blog.csdn.net/yangtalent1206/article/details/5853017]]

计算机系统有一系列的“周期”概念，区别、联系地理解这些概念至关重要。以下对*时钟周期、振荡周期、机器周期、CPU周期、状态周期、指令周期、总线周期、任务周期*进行简单介绍。

*周期*

在电子技术中，脉冲信号是一个按一定电压幅度，一定时间间隔连续发出的脉冲信号。脉冲信号之间的时间间隔称为周期；而将在单位时间（如1秒）内所产生的脉冲个数称为频率。频率是描述周期性循环信号（包括脉冲信号）在单位时间内所出现的脉冲数量多少的计量名称；频率的标准计量单位是Hz（赫）。电脑中的系统时钟就是一个典型的频率相当精确和稳定的脉冲信号发生器。



*时钟周期*

时钟周期，一般也称振荡周期（如果晶振的输出没有经过分频就直接作为cpu的工作时钟，则时钟周期就等于振荡周期），即CPU的晶振的工作频率的倒数，是计算机中最基本的、最小的时间单位。通常成为节拍脉冲或者T周期。对于单片机时钟周期，时钟周期是单片机的基本时间单位，*两个振荡周期(时钟周期)组成一个状态周期。*



*振荡周期*（oscillating period）

在衰减振荡中，两个相邻同方向峰值之间的时间称为振荡周期Tp，振荡频率2π/Tp。在相同衰减比下，振荡周期越短或振荡频率越高，则回复时间越短，因此振荡周期(频率)反映系统响应快慢的指标。



*机器周期*

机器周期，一般也叫CPU周期。在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段（如，取指令、存储器读、存储器写等），每一阶段完成一项工作（称为一个基本操作）。完成一个基本操作所需要的时间称为机器周期。一般情况下，一个机器周期由若干个S周期（状态周期）组成。



*CPU周期*

又称机器周期，CPU周期定义为从内存读取一条指令字的最短时间。一个指令周期常由若干CPU周期构成。



*状态周期*

在8051单片机中把一个时钟周期定义为一个节拍（用P表示），二个节拍定义为一个状态周期（用S表示）。

8051系列单片机的一个机器周期同6个S周期（状态周期）组成。一个机器周期包含6个状态周期（S1-S6）,而一个状态周期又包含两个时钟振荡周期（简称时钟周期）。例：8051单片机的机器周期由6个状态周期组成，也就是说一个机器周期=6个状态周期=12个时钟周期。



*指令周期*

指令周期是执行一条指令所需要的时间，即CPU从内存取出一条指令并执行这条指令的时间总和。一般由若干个机器周期组成，从取指令、分析指令到执行完所需的全部时间。指令不同，所需的机器周期数也不同。对于一些简单的的单字节指令，在取指令周期中，指令取出到指令寄存器后，立即译码执行，不再需要其它的机器周期。对于一些比较复杂的指令，例如转移指令、乘法指令，则需要两个或者两个以上的机器周期。通常含一个机器周期的指令称为单周期指令，包含两个机器周期的指令称为双周期指令。



*总线周期*

总线周期通常指的使通过总线完成一次内存读写操作或完成一次输入输出设备的读写操作所必须的时间。由于存储器和I/O端口是挂接在总线上的，CPU对存储器和I/O接口的访问，是通过总线实现的。通常把CPU通过总线对微处理器外部（存储器或I/O接口）进行一次访问所需时间称为一个总线周期。一个总线周期一般包含4个时钟周期，这4个时钟周期分别称4个状态即T1状态、T2状态、T3状态和T4状态。



*任务周期*


周期任务是指计算机系统按一定周期达到并请求运行，每次请求称为任务的一个任务实例，任务实例所属任务的起始时刻称为该任务实例的到达时刻，任务实例被置为就绪态的时刻称为该任务实例的释放时刻。

** [[http://www.crifan.com/try_use_doxygen_to_generate_doc_for_python/][]]    :blog:

** [[http://blog.csdn.net/czyt1988/article/details/8901191][C++标准注释原则 - 基于doxygen的C++注释]]    :blog:



*** 标注总述

下载国外的源代码，往往能看到附带的说明文档，文档都有详细的说明，大部分文档都可以通过doxygen这个跨平台软件生成，doxygen并不能随便读取你的C++的注释,必须按照一定的规则才能生成，所以在编写代码时，一定要按照标准写注释，否则会为以后带来许多麻烦

下面介绍C++的标注写法，c++不推荐c语言式的/*
*/风格注释，这里，除了文件头使用这种注释外其余到使用C++风格的注释。

先看看总述：



文件头：

#+BEGIN_EXAMPLE
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    /*!
    * \file Ctext.h
    * \brief 概述
    *
    *详细概述
    *
    * \author 作者名字
    * \version 版本号(maj.min，主版本.分版本格式)
    * \date 日期
    */
#+END_EXAMPLE



命名空间：

#+BEGIN_EXAMPLE
    /// \brief 命名空间的简单概述
    ///
    ///命名空间的详细概述
    namespace text
    {
     ……
    }
#+END_EXAMPLE



 类说明：

#+BEGIN_EXAMPLE
    /// \brief Ctext的doxygen测试
    ///
    /// 作doxygen测试用
    class Ctext
    {
    }
#+END_EXAMPLE



 函数标注
    方法1：

#+BEGIN_EXAMPLE
        /// \brief 函数简要说明-测试函数
        /// \param n1 参数1
        /// \param c2 参数2
        /// \return 返回说明
        bool text(int n1,Ctext c2);
#+END_EXAMPLE

   方法2：

#+BEGIN_EXAMPLE
        /// \brief 函数简要说明-测试函数
        ///
        /// 函数详细说明，这里写函数的详细说明信息，说明可以换行
        /// ，如这里所示，同时需要注意的是详细说明和简要说明之间必须空一行
        /// ，详细说明之前不需要任何标识符
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        /// \return 返回说明
        /// \see text
        bool text2(int n1,Ctext c2);
#+END_EXAMPLE



 变量及枚举


#+BEGIN_EXAMPLE
       int m_a;     ///< 成员变量1m_a说明
        double m_b; ///< 成员变量2m_b说明


        /// \brief 成员变量m_c简要说明
        ///
        /// 成员变量m_c的详细说明，这里可以对变量进行
        ///详细的说明和描述，具体方法和函数的标注是一样的
        float m_c;


        /// \brief xxx枚举变量的简要说明
        ///
        /// xxx枚举变量的详细说明--枚举变量的详细说明和函数的详细说明
        ///的写法是一致的。每个枚举变量下可以进行单独说明
        enum{
            em_1,///< 枚举值1的说明
            em_2,///< 枚举值2的说明
            em_3 ///< 枚举值3的说明
        };
#+END_EXAMPLE




*** 1.文件头说明

文件头说明按照如下格式写

#+BEGIN_EXAMPLE
    /*!
    * \file Ctext.h
    * \brief 概述
    *
    *详细概述
    *
    * \author 作者,包含email等
    * \version 版本号(maj.min，主版本.分版本格式)
    * \date 日期
    */
#+END_EXAMPLE


 上注释等下于下面这种写法

#+BEGIN_EXAMPLE
    /*!
     \file Ctext.h
    \brief 概述
    详细概述
    \author 作者,包含email等
    \version 版本号(maj.min，主版本.分版本格式)
    \date 日期
    */
#+END_EXAMPLE




对于vs编译器可能中间那行*号比较麻烦，可以不写，对于Qt这种要去掉中间的*号反而是件麻烦事就不用去掉
 用doxygen生成注释如下效果

[[http://img.blog.csdn.net/20130508165355086]]



[[http://img.blog.csdn.net/20130508165557535]]

*** 2. 命名空间

***

命名空间说明如下写

#+BEGIN_EXAMPLE
    /// \brief 命名空间的简单概述
    ///
    ///命名空间的详细概述
    namespace text
    {

    }
#+END_EXAMPLE


 doxygen的说明写法都是类似于

#+BEGIN_EXAMPLE
    /// \brief
    ///
    ///
#+END_EXAMPLE


 以下将会见到很多这样的写法
 上注释的doxygen效果如下
 [[http://img.blog.csdn.net/20130508165701768]]


*** 3. 类说明


 类的注释和函数一样，


#+BEGIN_EXAMPLE
    /// \brief Ctext的doxygen测试
    ///
    /// 作doxygen测试用
    class Ctext
    {
    }
#+END_EXAMPLE


 上注释用doxygen生成文档效果如下：
 [[http://img.blog.csdn.net/20130508165756125]]

[[http://img.blog.csdn.net/20130508165806875]]




*** 4.函数注释原则

函数详细注释位于头文件，cpp文件只对函数做简明注释
 cpp文件不做///的注释，否则会和头文件重叠

**** 4.1 函数简要说明

注释方法1：

#+BEGIN_EXAMPLE
        /// \brief 函数简要说明-测试函数
        /// \param n1 参数1
        /// \param c2 参数2
        /// \return 返回说明
        bool text(int n1,Ctext c2);
#+END_EXAMPLE


 简要注释此注释会让doxygen生成函数简要说明和参数说明
 生成结果如：
 [[http://img.blog.csdn.net/20130508165935341]]


**** 4.2 函数简要说明+详细说明



#+BEGIN_EXAMPLE
        /// \brief 函数简要说明-测试函数
        ///
        /// 函数详细说明，这里写函数的详细说明信息，说明可以换行
        /// ，如这里所示，同时需要注意的是详细说明和简要说明之间必须空一行
        /// ，详细说明之前不需要任何标识符
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        /// \return 返回说明
        bool text2(int n1,Ctext c2);
#+END_EXAMPLE


 上注释用doxygen生成文档效果如下：
 [[http://img.blog.csdn.net/20130508170015199]]



**** 4.3 不带简要说明的函数标注

#+BEGIN_EXAMPLE
        /// 函数说明-测试函数
        ///
        /// 函数详细说明，这里写函数的详细说明信息，说明可以换行
        /// ，如这里所示，同时需要注意的是详细说明和简要说明之间必须空一行
        /// ，详细说明之前不需要任何标识符
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        /// \return 返回说明
        bool text3(int n1,Ctext c2);
#+END_EXAMPLE


 上注释用doxygen生成文档效果如下：
 [[http://img.blog.csdn.net/20130508170100995]]
 这里没有说明
 [[http://img.blog.csdn.net/20130508170122338]]



**** 4.4 带参见的写法

#+BEGIN_EXAMPLE
        /// \brief 函数说明-测试函数4
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        /// \return 返回说明
        /// \see text3 text2 text
        bool text4(int n1,Ctext c2);
#+END_EXAMPLE


 上注释用doxygen生成文档效果如下：
 [[http://img.blog.csdn.net/20130508170203321]]


 \see 上可以带中文等说明，doxygen会自动识别代码里存在的函数


*** 5.变量注释


 变量注释用///< 对变量进行说明，对于详细信息可以加\brief


#+BEGIN_EXAMPLE
        int m_a;     ///< 成员变量1m_a说明
        double m_b; ///< 成员变量2m_b说明

        /// \brief 成员变量m_c简要说明
        ///
        /// 成员变量m_c的详细说明，这里可以对变量进行
        ///详细的说明和描述，具体方法和函数的标注是一样的
        float m_c;
#+END_EXAMPLE



如果变量需要详细说明的可已按照m_c的写法写，*注意，m_b和m_c之间一定需要空行*，否则会导致m_b的简述消失
 上注释用doxygen生成文档的具体效果如下
 [[http://img.blog.csdn.net/20130508170247054]]

 [[http://img.blog.csdn.net/20130508170321178]]



*** 6.枚举


 枚举变量的标注方法如下


#+BEGIN_EXAMPLE
        /// \brief xxx枚举变量的简要说明
        ///
        /// xxx枚举变量的详细说明--枚举变量的详细说明和函数的详细说明
        ///的写法是一致的。每个枚举变量下可以进行单独说明
        enum{
            em_1,///< 枚举值1的说明
            em_2,///< 枚举值2的说明
            em_3 ///< 枚举值3的说明
        };
#+END_EXAMPLE




枚举的总体说明和函数的写法一致，每个枚举变量的说明和变量的说明写法一致
 上注释用doxygen生成效果如下：

 [[http://img.blog.csdn.net/20130508170401801]]

[[http://img.blog.csdn.net/20130508170410863]]





*** 7.doxygen的设置和中文问题



**** 7.1 生成私有成员


 如果想生成私有成员（doxygen默认不生成私有成员），可以如下设置
 选择Expert标签的Build项，勾选EXTRACT_PRIVATE即可


**** 7.2 中文问题

中文有时候是乱码
 对于vs2010的文档，默认是gb2312，可以设置
 Expert标签的Project项目的DOXYFILE_ENCODING 为 GB18030
 INPUT_ENCODING 为 GB18030

另外Project项目的生成语言（OUTPUT_LANGUAGE）选择Chinese



对于其他的代码文件如果中文乱码，可以用文本编辑器转换代码文本编码为UTF-8带BOM的（注意这有可能影响代码，所以转换编码时要备份），再进行导出。
 [[http://img.blog.csdn.net/20130508170446847]]



[[http://img.blog.csdn.net/20130508170504659]]



*** 8.vs2008、vs2010 及以上IDE的快速标注方法

vs2010 等编译器并不能像Qt
Creator那样生成上述标注样式，但是可以集成到vs的工具栏里，集成方法如下图所示：

[[http://img.blog.csdn.net/20130508212959822]]

这样在标注时可以直接从工具箱拖曳了，非常方便





*** 附：

Ctext.h


#+BEGIN_EXAMPLE
    /*!
    * \file Ctext.h
    * \brief 概述
    *
    *详细概述
    *
    * \author 作者,包含email等
    * \version 版本号(maj.min，主版本.分版本格式)
    * \date 日期
    */

    #pragma once
    /// \brief 命名空间的简单概述
    ///
    ///命名空间的详细概述
    namespace text
    {

    }

    /// \brief Ctext的doxygen测试
    ///
    /// 作doxygen测试用
    class Ctext
    {
    public:
        Ctext(void);
        ~Ctext(void);
        /// \brief 函数简要说明-测试函数
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        ///    \return 返回说明
        bool text(int n1,Ctext c2);
        /// \brief 函数简要说明-测试函数
        ///
        /// 函数详细说明，这里写函数的详细说明信息，说明可以换行
        /// ，如这里所示，同时需要注意的是详细说明和简要说明之间必须空一行
        /// ，详细说明之前不需要任何标识符
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        ///    \return 返回说明
        bool text2(int n1,Ctext c2);
        /// 函数说明-测试函数
        ///
        /// 函数详细说明，这里写函数的详细说明信息，说明可以换行
        /// ，如这里所示，同时需要注意的是详细说明和简要说明之间必须空一行
        /// ，详细说明之前不需要任何标识符
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        ///    \return 返回说明
        bool text3(int n1,Ctext c2);
        /// \brief 函数说明-测试函数4
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        ///    \return 返回说明
        /// \see text3 text2 text
        bool text4(int n1,Ctext c2);

        int m_a;     ///< 成员变量1m_a说明
        double m_b; ///< 成员变量2m_b说明

        /// \brief 成员变量m_c简要说明
        ///
        /// 成员变量m_c的详细说明，这里可以对变量进行
        ///详细的说明和描述，具体方法和函数的标注是一样的
        float m_c;

        /// \brief xxx枚举变量的简要说明
        ///
        /// xxx枚举变量的详细说明--枚举变量的详细说明和函数的详细说明
        ///的写法是一致的。每个枚举变量下可以进行单独说明
        enum{
            em_1,///< 枚举值1的说明
            em_2,///< 枚举值2的说明
            em_3 ///< 枚举值3的说明
        };
    };
#+END_EXAMPLE



另外可看看这篇文章里面的注释：
http://blog.csdn.net/czyt1988/article/details/21743595

** [[http://www.douban.com/group/topic/40892505/][python安装模块的多种方法。]]    :blog:

1、自己写的模块，可以直接添加到路径下。这样就可以直接调用。
import sys
sys.path.append("/home/username/")

2、单文件模块

直接把文件拷贝到$python_dir/lib

3、网上下载的第三方库，一般解压后，找setup.py文件
运行python setup.py install

4、 egg文件

1) 下载ez_setup.py,运行python ez_setup

2) easy_install *.egg

5、pip安装方法

Pip 是安装python包的工具，提供了安装包，列出已经安装的包，升级包以及卸载包的功能。

Pip 是对easy_install的取代，提供了和easy_install相同的查找包的功能，因此可以使用easy_install安装的包也同样可以使用pip进行安装。



安装Pip

Pip的安装可以通过源代码包，easy_install或者脚本。

下面介绍一下各种安装方法：

源代码方式：

$ wget https://pypi.python.org/packages/source/p/pip/pip-1.2.1.tar.gz （替换为最新的包）
$ tar xzf pip-1.2.1.tar.gz
$ cd pip-1.2.1.tar.gz
$ python setup.py install

easy_install:

$ easy_install pip

get_pip.py 脚本：

$ curl -0 https://raw.github.com/pypa/pip/master/contrib/get-pip.py

$ sudo python get-pip.py



OK, 下面来看一下Pip的使用

安装package

$ pip install Markdown

列出安装的packages

$ pip freeze

安装特定版本的package

通过使用==, >=, <=, >, <来指定一个版本号。

$ pip install 'Markdown<2.0'

$ pip install 'Markdown>2.0,<2.0.3'

升级包

升级包到当前最新的版本，可以使用-U 或者 --upgrade

$ pip install -U Markdown

卸载包

$ pip uninstall Markdown

查询包

pip search "Markdown"

6、特殊库的安装（一个科学计算库Enthought Python Distribution的安装）

Enthought Python Distribution在ubuntu下安装的测试，应一个网友的请求，问怎么安装这个库，从官方网站上下载了一个文件

epd_free-7.3-2-rh5-x86.sh，遮个文件是sh 格式的文件，用sudo bash epd_free-7.3-2-rh5-x86.sh 运行这个文件，出现很多权限的阅读，点回车，不要连续点

需要点一次看一下，最后出现一个同一不同一它的版权声明，输入"yes",再下来是让选择安装的目录，点回车，就安装在当前目录下。

这样就安装好了。

当前目录下输入

>>> ipython --pylab

就出来

Python 2.7.3 (default, Apr 20 2012, 22:44:07)
Type "copyright", "credits" or "license" for more information.

IPython 0.12.1 -- An enhanced Interactive Python.
? -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help -> Python's own help system.
object? -> Details about 'object', use 'object??' for extra details.

Welcome to pylab, a matplotlib-based Python environment [backend: TkAgg].
For more information, type 'help(pylab)'.

再这样调用。这个库由于我工作上用不上，所以也不需要进一步的研究。

In [1]: from scipy import *

In [2]: a=zeros(1000)

In 3]: a[:100]=1

In [4: b=fft(a)

In [5]: plot(abs(b))


7、windows平台下，可以找对应python版本的exe安装包。

比喻：python2.7.3下 MySQL-python-1.2.3.win32-py2.7.exe

或 MySQL-python-1.2.3.win-amd64-py2.7.exe

** [[http://www.iplaysoft.com/top10-programming-fonts.html][10大最适合编程的字体推荐下载，让代码看起来更美更舒服！]]    :blog:



[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/10fonts.jpg]]


现在有事没事就喜欢写写代码的人越来越多了，对于成天盯着屏幕工作的开发人员来说，编程代码可能是每天见得最多的东西了。可是绝大部分人都一直使用编辑器默认的字体，其实，换一套适合自己的[[http://www.iplaysoft.com/top10-programming-fonts.html][编程字体]]不仅能让代码看得更舒服，甚至还能提高工作效率的！


如果你有想过换一种*编程字体*，却不知道哪里找合适的，那么看看异次元软件世界为您推荐的[[http://www.iplaysoft.com/top10-programming-fonts.html][10款最适合编程的字体]]吧，这些字体能让你的代码瞬间“优雅”起来！换一种字体，换一番心情嘛。当然，除了编程之外，经常需要编辑英文文档的朋友同样适用......

**** 前言：


下面字体的排序是作者的主观感受，每个人的喜好都不一样。建议您都试试，按照自己的喜好来选择。另外，还在使用
[[http://www.iplaysoft.com/winxp-sp3-vol.html][Windows XP]]
的同学，如果您希望显示到如截图中清晰的字体效果，则必须安装微软的[[http://dl.iplaysoft.com/files/1090.html][ClearType设置程序]]对清晰度进行设置。

**** 10. Courier

也叫Courier
New，这大概是我们最熟悉的[[http://www.iplaysoft.com/top10-programming-fonts.html][字体]]了，基本上所有系统都有。很不幸，很多终端和编辑器都默认使用此种字体，虽然不会影响使用，但它太无趣了。如果你正在使用这种字体，建议调大一点，并打开系统的
anti-aliasing (抗锯齿) 设置。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image001.png]]

[[http://dl.iplaysoft.com/files/1079.html][下载 Courier New 字体]]

**** 9. Andale Mono

比Courier稍好，也是常见的默认[[http://www.iplaysoft.com/top10-programming-fonts.html][字体]]。我感觉字母太宽了，字符间距也比较蠢。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image002.png]]

[[http://dl.iplaysoft.com/files/1080.html][下载 Andale Mono 字体]]

**** 8. Monaco

Mac的默认字体，好像也只有Mac上有。小字号的时候表现不错，而且再大些也不寒碜。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image003.png]]

[[http://dl.iplaysoft.com/files/1081.html][下载 Monaco 字体]]

**** 7. Profont

与Monaco类似的位图字体，你能够在Mac,
Windows和Linux上面使用。小字号的时候表现好。非Mac平台上Monaco的最佳替代。喜欢小字号且不怕眼睛疲劳的同学可以考虑。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image004.png]]

[[http://dl.iplaysoft.com/files/1082.html][下载 Profont 字体]]

**** 6. Monofur

独特的等宽字体，各种字号下都表现不错，但是需要设置anti-aliasing。怀旧而且喜欢与众不同的人推荐。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image005.png]]

[[http://dl.iplaysoft.com/files/1083.html][下载 Monofur 字体]]

**** 5. Proggy

干净的等宽字体，好像很受Windows用户欢迎，但在Mac上也不错。使用时，字号可以小一点，无需anti-aliasing。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image006.png]]

[[http://dl.iplaysoft.com/files/1084.html][下载 Proggy 字体]]

**** 4. Droid Sans Mono

开源[[http://www.iplaysoft.com/top10-programming-fonts.html][字体]]，可以在这里下载，适合手机屏幕。是等宽字体中最突出的一个。可惜0和O区别不大。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image007.png]]

[[http://dl.iplaysoft.com/files/1085.html][下载 Droid Sans Mono 字体]]

**** 3. Deja Vu Sans Mono

我最喜欢的免费字体系列，以Vera为基础，但是比后者提供更多字符了。适于任何字号，需要anti-aliasing。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image008.png]]

[[http://dl.iplaysoft.com/files/1086.html][下载 Deja Vu Sans Mono 字体]]

**** 2. Consolas + 中文雅黑混合版

Consolas
是商业字体，专门为微软设计，微软不少产品上都有，所以很可能你的系统上已经有了。需要anti-aliasing。如果不是商业的，我可能就把它放第一了。Consolas仅含英文字母部分，这里提供的是雅黑中文+Consolas英文的混合体，即使代码里有中文注释显示效果也能很好的！

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image009.png]]

[[http://www.iplaysoft.com/consolas.html][下载 Consolas 雅黑字体]]

**** 1. Inconsolata

我最喜欢的等宽字体，免费。我遇到它之后，很快就把原来的默认字体Deja Vu
Sans
Mono抛弃了。真正适合任何字号的好[[http://www.iplaysoft.com/top10-programming-fonts.html][字体]]。感谢它的创造者Raph
Levien！

** [[http://www.cnblogs.com/awpatp/archive/2011/02/27/1966380.html][Foo, Bar是什么意思？]]    :blog:

有些朋友问：foo, bar是什么意思, 为什么C++书籍中老见到这个词。



我google了一下，
发现没有很好的中文答案。这个问题，在维基百科上有很好的回答。在这里翻译给大家。



译文：

术语*foobar*, *foo*, *bar*, *baz*
和*qux*经常在计算机编程或计算机相关的文档中被用作[[http://en.wikipedia.org/wiki/Placeholder_name][占位符]]的名字。当变量，函数，或命令本身不太重要的时候，*foobar*,
*foo*, *bar*, *baz*
和*qux*就被用来充当这些实体的名字，这样做的目的仅仅是阐述一个概念，说明一个想法。这些术语本身相对于使用的场景来说没有任何意义。Foobar经常被单独使用；而当需要多个实体举例的时候，foo，bar，和baz则经常被按顺序使用。

** [[http://net.pku.edu.cn/~yhf/tutorial/awk_manual.html][Unix awk使用手册]]    :blog:

作者的话：

《UNIX AWK使用手册》是我几个月前的作品了，回过头来看，这
篇文章实在是很粗燥，因当时我写作并上传这个作品时实在是太
忙了，没有对文章的质量进行很好的检查，心里老觉得有愧于网
友的厚爱，于是趁闲赶忙重写一遍，虽然不一定会有很大的改观
，但质量是肯定要好一点的，唯如此，我的良心上才好受一点，
呶，下面就是我的修改稿，各位老友请与第一版相比一下，看是
否有所进步！

这次改写仍然保留了原有的风格：正文由浅入深，文后附上了大
量的相关资料，这样做的原因是为了满足各种用户的需求，这在
第一版中已经说过了。这次主要的改变是在内容上，加入了很多
新内容，并增加了示例，以帮助读者理解其中的内容，附录也补
充了许多新的资料。当然读者要真正地掌握awk，仅仅读了本文
是不够的，还必须有上机实习这一步。值得提醒大家的是，awk
有很多版本，并且各个版本之间存在着一些差别，因此，在使用
awk以前最好参考一下你使用的系统的联机帮助。

什么是awk?

你可能对UNIX比较熟悉，但你可能对awk很陌生，这一点也不奇
怪，的确，与其优秀的功能相比，awk还远没达到它应有的知名
度。awk是什么？与其它大多数UNIX命令不同的是，从名字上看
，我们不可能知道awk的功能：它既不是具有独立意义的英文单
词，也不是几个相关单词的缩写。事实上，awk是三个人名的缩
写，他们是：Aho、(Peter)Weinberg和(Brain)Kernighan。正是
这三个人创造了awk---一个优秀的样式扫描与处理工具。

AWK的功能是什么？与sed和grep很相似，awk是一种样式扫描与
处理工具。但其功能却大大强于sed和grep。 awk提供了极其强
大的功能：它几乎可以完成grep和sed所能完成的全部工作，同
时，它还可以可以进行样式装入、流控制、数学运算符、进程控
制语句甚至于内置的变量和函数。它具备了一个完整的语言所应
具有的几乎所有精美特性。实际上，awk的确拥有自己的语言：
awk程序设计语言，awk的三位创建者已将它正式定义为：样式扫
描和处理语言。

为什么使用awk?

即使如此，你也许仍然会问，我为什么要使用awk?

使用awk的第一个理由是基于文本的样式扫描和处理是我们经常
做的工作，awk所做的工作有些象数据库，但与数据库不同的是
，它处理的是文本文件，这些文件没有专门的存储格式，普通的
人们就能编辑、阅读、理解和处理它们。而数据库文件往往具有
特殊的存储格式，这使得它们必须用数据库处理程序来处理它们
。既然这种类似于数据库的处理工作我们经常会遇到，我们就应
当找到处理它们的简便易行的方法，UNIX有很多这方面的工具，
例如sed 、grep、sort以及find等等，awk是其中十分优秀的一
种。

使用awk的第二个理由是awk是一个简单的工具，当然这是相对于
其强大的功能来说的。的确，UNIX有许多优秀的工具，例如UNIX
天然的开发工具C语言及其延续C++就非常的优秀。但相对于它们
来说，awk完成同样的功能要方便和简捷得多。这首先是因为awk
提供了适应多种需要的解决方案：从解决简单问题的awk命令行
到复杂而精巧的awk程序设计语言，这样做的好处是，你可以不
必用复杂的方法去解决本来很简单的问题。例如，你可以用一个
命令行解决简单的问题，而C不行，即使一个再简单的程序，C语
言也必须经过编写、编译的全过程。其次，awk本身是解释执行
的，这就使得awk程序不必经过编译的过程，同时，这也使得它
与shell script程序能够很好的契合。最后，awk本身较C语言简
单，虽然awk吸收了C语言很多优秀的成分，熟悉C语言会对学习
awk有很大的帮助，但 awk本身不须要会使用C语言——一种功能强
大但需要大量时间学习才能掌握其技巧的开发工具。

使用awk的第三个理由是awk是一个容易获得的工具。与C和C++语
言不同，awk只有一个文件(/bin/awk)，而且几乎每个版本的
UNIX都提供各自版本的awk，你完全不必费心去想如何获得awk。
但C语言却不是这样，虽然C语言是UNIX天然的开发工具，但这个
开发工具却是单独发行的，换言之，你必须为你的UNIX版本的C
语言开发工具单独付费（当然使用D版者除外），获得并安装它
，然后你才可以使用它。

基于以上理由，再加上awk强大的功能，我们有理由说，如果你
要处理与文本样式扫描相关的工作，awk应该是你的第一选择。
在这里有一个可遵循的一般原则：如果你用普通的shell工具或
shell script有困难的话，试试awk,如果awk仍不能解决问题，
则便用C语言，如果C语言仍然失败，则移至C++。

awk的调用方式

前面曾经说过，awk提供了适应多种需要的不同解决方案，它们
是：

一、 awk命令行，你可以象使用普通UNIX命令一样使用awk，在
命令行中你也可以使用awk程序设计语言，虽然awk支持多行的录
入，但是录入长长的命令行并保证其正确无误却是一件令人头疼
的事，因此，这种方法一般只用于解决简单的问题。当然，你也
可以在shell script程序中引用awk命令行甚至awk程序脚本。

二、使用-f选项调用awk程序。awk允许将一段awk程序写入一个
文本文件，然后在awk命令行中用-f选项调用并执行这段程序。
具体的方法我们将在后面的awk语法中讲到。

三、利用命令解释器调用awk程序：利用UNIX支持的命令解释器
功能，我们可以将一段awk程序写入文本文件，然后在它的第一
行加上:
#!/bin/awk -f
并赋予这个文本文件以执行的权限。这样做之后，你就可以在命
令行中用类似于下面这样的方式调用并执行这段awk程序了。

$awk脚本文本名待处理文件

awk的语法：

与其它UNIX命令一样，awk拥有自己的语法：

awk [ -F re] [parameter...] ['prog'] [-f progfile]
[in_file...]

参数说明：

-F re:允许awk更改其字段分隔符。

parameter: 该参数帮助为不同的变量赋值。

'prog': awk的程序语句段。这个语句段必须用单拓号：'和'括
起，以防被shell解释。这个程序语句段的标准形式为：

'pattern {action}'

其中pattern参数可以是egrep正则表达式中的任何一个，它可以
使用语法/re/再加上一些样式匹配技巧构成。与sed类似，你也
可以使用","分开两样式以选择某个范围。关于匹配的细节，你
可以参考附录，如果仍不懂的话，找本UNIX书学学grep和sed（
本人是在学习ed时掌握匹配技术的）。 action参数总是被大括
号包围，它由一系统awk语句组成，各语句之间用";"分隔。awk
解释它们，并在pattern给定的样式匹配的记录上执行其操作。
与shell类似，你也可以使用“#”作为注释符，它使“#”到行尾的
内容成为注释，在解释执行时，它们将被忽略。你可以省略
pattern和 action之一，但不能两者同时省略，当省略pattern
时没有样式匹配，表示对所有行（记录）均执行操作，省略
action时执行缺省的操作——在标准输出上显示。

-f progfile:允许awk调用并执行progfile指定有程序文件。
progfile是一个文本文件，他必须符合awk的语法。

in_file:awk的输入文件，awk允许对多个输入文件进行处理。值
得注意的是awk不修改输入文件。如果未指定输入文件，awk将接
受标准输入，并将结果显示在标准输出上。awk支持输入输出重
定向。

awk的记录、字段与内置变量：

前面说过，awk处理的工作与数据库的处理方式有相同之处，其
相同处之一就是awk支持对记录和字段的处理，其中对字段的处
理是grep和sed不能实现的，这也是awk优于二者的原因之一。在
awk中，缺省的情况下总是将文本文件中的一行视为一个记录，
而将一行中的某一部分作为记录中的一个字段。为了操作这些不
同的字段，awk借用shell的方法，用$1,$2,$3...这样的方式来
顺序地表示行（记录）中的不同字段。特殊地，awk用$0表示整
个行（记录）。不同的字段之间是用称作分隔符的字符分隔开的
。系统默认的分隔符是空格。awk允许在命令行中用-F re的形式
来改变这个分隔符。事实上，awk用一个内置的变量FS来记忆这
个分隔符。awk中有好几个这样的内置变量，例如，记录分隔符
变量RS、当前工作的记录数NR等等，本文后面的附表列出了全部
的内置变量。这些内置的变量可以在awk程序中引用或修改，例
如，你可以利用NR变量在模式匹配中指定工作范围，也可以通过
修改记录分隔符RS让一个特殊字符而不是换行符作为记录的分隔
符。

例:显示文本文件myfile中第七行到第十五行中以字符%分隔的第
一字段，第三字段和第七字段：

awk -F % 'NR==7,NR==15 {printf $1 $3 $7}'

awk的内置函数

awk 之所以成为一种优秀的程序设计语言的原因之一是它吸收了
某些优秀的程序设计语言（例如C）语言的许多优点。这些优点
之一就是内置函数的使用，awk定义并支持了一系列的内置函数
，由于这些函数的使用，使得awk提供的功能更为完善和强大，
例如，awk使用了一系列的字符串处理内置函数(这些函数看起来
与C 语言的字符串处理函数相似，其使用方式与C语言中的函数
也相差无几)，正是由于这些内置函数的使用，使awk处理字符串
的功能更加强大。本文后面的附录中列有一般的awk所提供的内
置函数，这些内置函数也许与你的awk版本有些出入，因此，在
使用之前，最好参考一下你的系统中的联机帮助。

作为内置函数的一个例子，我们将在这里介绍awk的printf函数
，这个函数使得awk与c语言的输出相一致。实际上，awk中有许
多引用形式都是从C语言借用过来的。如果你熟悉C语言，你也许
会记得其中的printf函数，它提供的强大格式输出功能曾经带我
们许多的方便。幸运的是，我们在awk中又和它重逢了。awk中
printf几乎与C语言中一模一样，如果你熟悉C语言的话，你完全
可以照C语言的模式使用awk中的printf。因此在这里，我们只给
出一个例子，如果你不熟悉的话，请随便找一本C语言的入门书
翻翻。

例:显示文件myfile中的行号和第3字段：

$awk '{printf"%03d%s\n",NR,$1}' myfile

在命令行使用awk

按照顺序，我们应当讲解awk程序设计的内容了，但在讲解之前
，我们将用一些例子来对前面的知识进行回顾，这些例子都是在
命令行中使用的，由此我们可以知道在命令行中使用awk是多么
的方便。这样做的原因一方面是为下面的内容作铺垫，另一方面
是介绍一些解决简单问题的方法，我们完全没有必要用复杂的方
法来解决简单的问题----既然awk提供了较为简单的方法的话。

例：显示文本文件mydoc匹配（含有）字符串"sun"的所有行。

$awk '/sun/{print}' mydoc

由于显示整个记录（全行）是awk的缺省动作，因此可以省略
action项。

$awk '/sun/' mydoc

例：下面是一个较为复杂的匹配的示例：

$awk '/[Ss]un/,/[Mm]oon/ {print}' myfile

它将显示第一个匹配Sun或sun的行与第一个匹配Moon或moon的行
之间的行，并显示到标准输出上。

例：下面的示例显示了内置变量和内置函数length（）的使用：

$awk 'length($0)>80 {print NR}' myfile

该命令行将显示文本myfile中所有超过80个字符的行号，在这里
，用$0表示整个记录（行），同时，内置变量NR不使用标志符
'$'。

例：作为一个较为实际的例子，我们假设要对UNIX中的用户进行
安全性检查，方法是考察/etc下的passwd文件，检查其中的
passwd字段（第二字段）是否为"*"，如不为"*"，则表示该用户
没有设置密码，显示出这些用户名（第一字段）。我们可以用如
下语句实现：

#awk -F: '$2=="" {printf("%s no password!\n",$1' /etc/
passwd

在这个示例中，passwd文件的字段分隔符是“：”，因此，必须用
-F：来更改默认的字段分隔符，这个示例中也涉及到了内置函数
printf的使用。

awk的变量

如同其它程序设计语言一样，awk允许在程序语言中设置变量，
事实上，提供变量的功能是程序设计语言的其本要求，不提供变
量的程序设计语言本人还从未见过。

awk 提供两种变量，一种是awk内置的变量，这前面我们已经讲
过，需要着重指出的是，与后面提到的其它变量不同的是，在
awk程序中引用内置变量不需要使用标志符"$"（回忆一下前面讲
过的NR的使用）。awk提供的另一种变量是自定义变量。awk允许
用户在awk程序语句中定义并调用自已的变量。当然这种变量不
能与内置变量及其它awk保留字相同，在awk中引用自定义变量必
须在它前面加上标志符"$"。与C语言不同的是，awk中不需要对
变量进行初始化， awk根据其在awk中第一次出现的形式和上下
文确定其具体的数据类型。当变量类型不确定时，awk默认其为
字符串类型。这里有一个技巧：如果你要让你的 awk程序知道你
所使用的变量的明确类型，你应当在在程序中给它赋初值。在后
面的实例中，我们将用到这一技巧。

运算与判断：

作为一种程序设计语言所应具有的特点之一，awk支持多种运算
，这些运算与C语言提供的几本相同：如+、-、*、/、%等等，同
时，awk也支持C语言中类似++、--、+=、-=、=+、=-之类的功能
，这给熟悉C语言的使用者编写awk程序带来了极大的方便。作为
对运算功能的一种扩展，awk还提供了一系列内置的运算函数（
如log、sqr、cos、sin等等）和一些用于对字符串进行操作（运
算）的函数（如length、substr等等）。这些函数的引用大大的
提高了awk的运算功能。

作为对条件转移指令的一部分，关系判断是每种程序设计语言都
具备的功能，awk也不例外。 awk中允许进行多种测试，如常用
的==（等于）、！=（不等于）、>（大于）、<（小于）、>=（
大于等于）、>=（小于等于）等等，同时，作为样式匹配，还提
供了~（匹配于）和！~（不匹配于）判断。

作为对测试的一种扩充，awk也支持用逻辑运算符:!(非)、&&（
与）、||（或）和括号（）进行多重判断，这大大增强了awk的
功能。本文的附录中列出了awk所允许的运算、判断以及操作符
的优先级。

awk的流程控制

流程控制语句是任何程序设计语言都不能缺少的部分。任何好的
语言都有一些执行流程控制的语句。awk提供的完备的流程控制
语句类似于C语言，这给我们编程带来了极大的方便。

1、BEGIN和END:

在awk 中两个特别的表达式，BEGIN和END，这两者都可用于
pattern中（参考前面的awk语法），提供BEGIN和END的作用是给
程序赋予初始状态和在程序结束之后执行一些扫尾的工作。任何
在BEGIN之后列出的操作（在{}内）将在awk开始扫描输入之前执
行，而END之后列出的操作将在扫描完全部的输入之后执行。因
此，通常使用BEGIN来显示变量和预置（初始化）变量，使用END
来输出最终结果。

例：累计销售文件xs中的销售金额（假设销售金额在记录的第三
字段）：

$awk
>'BEGIN { FS=":";print "统计销售金额";total=0}
>{print $3;total=total+$3;}
>END {printf "销售金额总计：%.2f",total}' sx
（注：>是shell提供的第二提示符，如要在shell程序awk语句和
awk语言中换行，则需在行尾加反斜杠\）

在这里，BEGIN预置了内部变量FS（字段分隔符）和自定义变量
total,同时在扫描之前显示出输出行头。而END则在扫描完成后
打印出总合计。

2、流程控制语句
awk提供了完备的流程控制语句，其用法与C语言类似。下面我们
一一加以说明：

2.1、if...else语句:

格式：
if(表达式)
语句1
else
语句2

格式中"语句1"可以是多个语句，如果你为了方便awk判断也方便
你自已阅读，你最好将多个语句用{}括起来。awk分枝结构允许
嵌套，其格式为：

if(表达式1）
{if(表达式2）
语句1
else
语句2
}
语句3
else {if(表达式3)
语句4
else
语句5
}
语句6

当然实际操作过程中你可能不会用到如此复杂的分枝结构，这里
只是为了给出其样式罢了。

2.2、while语句

格式为:

while(表达式)
语句

2.3、do-while语句

格式为:

do
{
语句
}while(条件判断语句）

2.4、for语句

格式为：

for(初始表达式;终止条件;步长表达式)
{语句}

在awk 的 while、do-while和for语句中允许使用
break,continue语句来控制流程走向，也允许使用exit这样的语
句来退出。break 中断当前正在执行的循环并跳到循环外执行下
一条语句。continue从当前位置跳到循环开始处执行。对于exit
的执行有两种情况：当exit语句不在 END中时，任何操作中的
exit命令表现得如同到了文件尾，所有模式或操作执行将停止，
END模式中的操作被执行。而出现在END中的exit将导致程序终止
。

例：为了

awk中的自定义函数

定义和调用用户自己的函数是几乎每个高级语言都具有的功能，
awk也不例外，但原始的awk并不提供函数功能，只有在nawk或较
新的awk版本中才可以增加函数。

函数的使用包含两部分：函数的定义与函数调用。其中函数定义
又包括要执行的代码（函数本身）和从主程序代码传递到该函数
的临时调用。

awk函数的定义方法如下：

function 函数名(参数表){
函数体
}

在gawk中允许将function省略为func，但其它版本的awk不允许
。函数名必须是一个合法的标志符，参数表中可以不提供参数（
但在调用函数时函数名后的一对括号仍然是不可缺少的），也可
以提供一个或多个参数。与C语言相似，awk的参数也是通过值来
传递的。

在awk 中调用函数比较简单，其方法与C语言相似，但awk比C语
言更为灵活，它不执行参数有效性检查。换句话说，在你调用函
数时，可以列出比函数预计（函数定义中规定）的多或少的参数
，多余的参数会被awk所忽略，而不足的参数，awk将它们置为缺
省值0或空字符串，具体置为何值，将取决于参数的使用方式。

awk函数有两种返回方式：隐式返回和显式返回。当awk执行到函
数的结尾时，它自动地返回到调用程序，这是函数是隐式返回的
。如果需要在结束之前退出函数，可以明确地使用返回语句提前
退出。方法是在函数中使用形如：return 返回值格式的语句。

例：下面的例子演示了函数的使用。在这个示例中，定义了一个
名为print_header的函数，该函数调用了两个参数FileName和
PageNum， FileName参数传给函数当前使用的文件名，PageNum
参数是当前页的页号。这个函数的功能是打印（显示）出当前文
件的文件名，和当前页的页号。完成这个功能后，这个函数将返
回下一页的页号。

nawk
>'BEGIN{pageno=1;file=FILENAME
>pageno=print_header(file，pageno)；#调用函数
print_header
>printf("当前页页号是：%d\n",pageno);
>}

>#定义函数print_header
>function print_header(FileName,PageNum){
>printf("%s %d\n",FileName,PageNum); >PageNum++;return
PageNUm;
>}
>}' myfile

执行这个程序将显示如下内容：

myfile 1
当前页页号是：2

awk高级输入输出

1.读取下一条记录：

awk的next语句导致awk读取下一个记录并完成模式匹配，然后立
即执行相应的操作。通常它用匹配的模式执行操作中的代码。
next导致这个记录的任何额外匹配模式被忽略。

2.简单地读取一条记录

awk 的 getline语句用于简单地读取一条记录。如果用户有一个
数据记录类似两个物理记录，那么getline将尤其有用。它完成
一般字段的分离(设置字段变量$0 FNR NF NR)。如果成功则返回
1，失败则返回0（到达文件尾）。如果需简单地读取一个文件，
则可以编写以下代码：

例：示例getline的使用

{while(getline==1)
{
#process the inputted fields
}
}

也可以使getline保存输入数据在一个字段中，而不是通过使用
getline variable的形式处理一般字段。当使用这种方式时，NF
被置成0，FNR和NR被增值。

用户也可以使用getline<"filename"方式从一个给定的文件中输
入数据，而不是从命令行所列内容输入数据。此时，getline将
完成一般字段分离（设置字段变量$0和NF)。如果文件不存在，
返回-1,成功，返回1,返回0表示失败。用户可以从给定文件中读
取数据到一个变量中，也可以用stdin(标准输入设备）或一个包
含这个文件名的变量代替filename。值得注意的是当使用这种方
式时不修改FNR和NR。

另一种使用getline语句的方法是从UNIX命令接受输入，例如下
面的例子:

例：示例从UNIX命令接受输入

{while("who -u"|getline)
{
#process each line from the who command
}
}

当然，也可以使用如下形式:

"command" | getline variable

3.关闭文件:

awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的
close语句。

close("filename")

filename可以是getline打开的文件（也可以是stdin,包含文件
名的变量或者getline使用的确切命令）。或一个输出文件（可
以是stdout，包含文件名的变量或使用管道的确切命令）。

4.输出到一个文件:

awk中允许用如下方式将结果输出到一个文件：

printf("hello word!\n")>"datafile"
或
printf("hello word!\n")>>"datafile"

5.输出到一个命令

awk中允许用如下方式将结果输出到一个命令：

printf("hello word!\n")|"sort-t','"

awk与shell script混合编程

因为awk可以作为一个shell命令使用，因此awk能与shell批处理
程序很好的融合在一起，这给实现awk与shell程序的混合编程提
供了可能。实现混合编程的关键是awk与shell script之间的对
话，换言之，就是awk与shell script之间的信息交流:awk从
shell script中获取所需的信息（通常是变量的值）、在awk中
执行shell命令行、shell script将命令执行的结果送给awk处理
以及shell script读取awk的执行结果等等。

1.awk读取Shell script程序变量

在awk中我们可以通过“'$变量名'”的方式读取sell scrpit程序
中的变量。

例：在下面的示例中，我们将读取sell scrpit程序中的变量
Name，该变量存放的是文本myfile的撰写者，awk将打印出这个
人名。

$cat writename
:
# @(#)
#
.
.
.
Name="张三" nawk 'BEGIN {name="'Name'";\ printf("\t%s\t
撰写者%s\n",FILENAME,name");}\
{...}END{...}' myfile
.
.
.

2.将shell命令的执行结果送给awk处理

作为信息传送的一种方法，我们可以将一条shell命令的结果通
过管道线（|）传递给awk处理：

例：示例awk处理shell命令的执行结果

$who -u | awk '{printf("%s正在执行%s\n",$2,$1)}'

该命令将打印出注册终端正在执行的程序名。

3.shell script程序读awk的执行结果

为了实现shell script程序读取awk执行的结果，我们可以采取
一些特殊的方法，例如我们可以用变量名=`awk语句`的形式将
awk执行的结果存放入一个 shell script变量。当然也可以用管
道线的方法将awk执行结果传递给shell script程序处理。

例：作为传送消息的机制之一，UNIX提供了一个向其所有用户传
送消息的命令wall（意思是write to all写给所有用户），该命
令允许向所有工作中的用户（终端）发送消息。为此，我们可以
通过一段shell批处理程序wall.shell来模拟这一程序（事实上
比较老的版本中wall就是一段shell批处理程序：

$cat wall.shell
:
# @(#) wall.shell:发送消息给每个已注册终端
#
cat >/tmp/$$
#用户录入消息文本 who -u | awk '{print $2}' | while read
tty
do
cat /tmp/$$>$tty
done

在这个程序里，awk接受who -u命令的执行结果，该命令打印出
所有已注册终端的信息，其中第二个字段是已注册终端的设备名
，因此用awk命令析出该设备名，然后用while read tty语句循
环读出这些文件名到变量（shell script变量）tty中，作为信
息传送的终结地址。

4.在awk中执行shell命令行----嵌入函数system()

system()是一个不适合字符或数字类型的嵌入函数，该函数的功
能是处理作为参数传递给它的字符串。system对这个参数的处理
就是将其作为命令处理，也就是说将其当作命令行一样加以执行
。这使得用户在自己的awk程序需要时可以灵活地执行命令或脚
本。

例：下面的程序将使用system嵌入函数打印用户编制好的报表文
件，这个文件存放在名为myreport.txt的文件中。为简约起见，
我们只列出了其END部分：

.
.
.
END {close("myreport.txt");system("lp myreport.txt");}

在这个示例中，我们首先使用close语句关闭了文件
myreport.txt文件，然后使用system嵌入函数将myreport.txt送
入打印机打印。

写到这里，我不得不跟朋友们说再见了，实在地说，这些内容仍
然是awk的初步知识，电脑永远是前进的科学，awk也不例外，本
篇所能做的只是在你前行的漫漫长途中铺平一段小小开端，剩下
的路还得靠你自己去走。老实说，如果本文真能给你前行的路上
带来些许的方便，那本人就知足了！

如对本篇有任何疑问，请E-mail To:Chizlong@yeah.net或到主
页http://chizling.yeah.net中留言。

附录：

1.awk的常规表达式元字符

\ 换码序列
^ 在字符串的开头开始匹配
$ 在字符串的结尾开始匹配
. 与任何单个字符串匹配
[ABC] 与[]内的任一字符匹配
[A-Ca-c] 与A-C及a-c范围内的字符匹配（按字母表顺序）
[^ABC] 与除[]内的所有字符以外的任一字符匹配
Desk|Chair 与Desk和Chair中的任一个匹配
[ABC][DEF] 关联。与A、B、C中的任一字符匹配，且其后要跟D
、E、F中的任一个字符。
 * 与A、B或C中任一个出现0次或多次的字符相匹配
+ 与A、B或C中任何一个出现1次或多次的字符相匹配
？与一个空串或A、B或C在任何一个字符相匹配
（Blue|Black）berry 合并常规表达式，与Blueberry或
Blackberry相匹配

2.awk算术运算符

运算符用途
------------------
x^y x的y次幂
x**y 同上
x%y 计算x/y的余数（求模）
x+y x加y
x-y x减y
x*y x乘y
x/y x除y
-y 负y(y的开关符号);也称一目减
++y y加1后使用y(前置加）
y++ 使用y值后加1（后缀加）
--y y减1后使用y(前置减）
y-- 使用后y减1(后缀减）
x=y 将y的值赋给x
x+=y 将x+y的值赋给x
x-=y 将x-y的值赋给x
x*=y 将x*y的值赋给x
x/=y 将x/y的值赋给x x%=y 将x%y的值赋给x
x^=y 将x^y的值赋给x
x**=y 将x**y的值赋给x

3.awk允许的测试：

操作符含义

x==y x等于y
x!=y x不等于y
x>y x大于y
x>=y x大于或等于y
x<y x小于y
x<=y x小于或等于y?
x~re x匹配正则表达式re?
x!~re x不匹配正则表达式re?

4.awk的操作符(按优先级升序排列)

= 、+=、 -=、 *= 、/= 、 %=
||
&&
> >= < <= == != ~ !~
xy (字符串连结，'x''y'变成"xy"）
+ -
 * / %
++ --

5.awk内置变量（预定义变量）

说明：表中v项表示第一个支持变量的工具（下同）：A=awk，N=
nawk,P=POSIX awk,G=gawk

V 变量含义缺省值
--------------------------------------------------------
N ARGC 命令行参数个数
G ARGIND 当前被处理文件的ARGV标志符
N ARGV 命令行参数数组
G CONVFMT 数字转换格式 %.6g
P ENVIRON UNIX环境变量
N ERRNO UNIX系统错误消息
G FIELDWIDTHS 输入字段宽度的空白分隔字符串
A FILENAME 当前输入文件的名字
P FNR 当前记录数
A FS 输入字段分隔符空格
G IGNORECASE 控制大小写敏感0（大小写敏感）
A NF 当前记录中的字段个数
A NR 已经读出的记录数
A OFMT 数字的输出格式 %.6g
A OFS 输出字段分隔符空格
A ORS 输出的记录分隔符新行
A RS 输入的记录他隔符新行
N RSTART 被匹配函数匹配的字符串首
N RLENGTH 被匹配函数匹配的字符串长度
N SUBSEP 下标分隔符 "\034"

6.awk的内置函数

V 函数用途或返回值
------------------------------------------------
N gsub(reg,string,target) 每次常规表达式reg匹配时替换
target中的string
N index(search,string) 返回string中search串的位置
A length(string) 求串string中的字符个数
N match(string,reg) 返回常规表达式reg匹配的string中的位
置
N printf(format,variable) 格式化输出，按format提供的格式
输出变量variable。
N split(string,store,delim) 根据分界符delim,分解string为
store的数组元素
N sprintf(format,variable) 返回一个包含基于format的格式
化数据，variables是要放到串中的数据
G strftime(format,timestamp) 返回一个基于format的日期或
者时间串，timestmp是systime()函数返回的时间
N sub(reg,string,target) 第一次当常规表达式reg匹配，替换
target串中的字符串
A substr(string,position,len) 返回一个以position开始len
个字符的子串
P totower(string) 返回string中对应的小写字符
P toupper(string) 返回string中对应的大写字符
A atan(x,y) x的余切(弧度)
N cos(x) x的余弦(弧度)
A exp(x) e的x幂
A int(x) x的整数部分
A log(x) x的自然对数值
N rand() 0-1之间的随机数
N sin(x) x的正弦(弧度)
A sqrt(x) x的平方根
A srand(x) 初始化随机数发生器。如果忽略x，则使用system()
G system() 返回自1970年1月1日以来经过的时间（按秒计算）

参考资料

1、《精通UNIX》（《Understanding UNIX》[美]Stan
Kelly-Bootle 著李永峰等译电子工业出版社)
2、《unix使用指南》（第2版）（Using UNIX（Second Edition
）Steve Moritsugu等原著张拥军、韩柯、原小玲等译电子工业
出版社出版、发行）
3、unix 联机手册:sco OpenSrever 5.05版.
4、感谢无名的网路资源提供者，由于你们辛勤而无私的劳动，
INTERNET才如此精彩！


** [[http://coolshell.cn/articles/9070.html][AWK 简明教程]]    :blog:


[[http://coolshell.cn//wp-content/uploads/2013/02/awk.jpg]]有一些网友看了前两天的《[[http://coolshell.cn/articles/8883.html][Linux下应该知道的技巧]]》希望我能教教他们用awk和sed，所以，出现了这篇文章。我估计这些80后的年轻朋友可能对awk/sed这类上古神器有点陌生了，所以需要我这个老家伙来炒炒冷饭。*况且，AWK是贝尔实验室1977年搞出来的文本出现神器，今年是蛇年，是AWK的本命年，而且年纪和我相仿，所以非常有必要为他写篇文章*。

之所以叫AWK是因为其取了三位创始人 [[http://en.wikipedia.org/wiki/Alfred_Aho][Alfred
Aho]]，[[http://en.wikipedia.org/wiki/Peter_J._Weinberger][Peter
Weinberger]], 和 [[http://en.wikipedia.org/wiki/Brian_Kernighan][Brian
Kernighan]] 的Family
Name的首字符。要学AWK，就得提一提AWK的一本相当经典的书《[[http://plan9.bell-labs.com/cm/cs/awkbook/][The
AWK Programming
Language]]》，它在[[http://book.douban.com/subject/1876898/][豆瓣上的评分]]是9.4分！在[[http://www.amazon.cn/mn/detailApp/?asin=020107981X][亚马逊上居然卖1022.30元]]。

我在这里的教程并不想面面俱到，本文和我之前的[[http://coolshell.cn/articles/8460.html][Go语言简介]]一样，全是示例，基本无废话。

*我只想达到两个目的：*

*1）你可以在乘坐公交地铁上下班，或是在坐马桶拉大便时读完（保证是一泡大便的工夫）。*

*2）我只想让这篇博文像一个火辣的脱衣舞女挑起你的兴趣，然后还要你自己去下工夫去撸。*

废话少说，我们开始脱吧（注：这里只是topless）。

**** 起步上台

我从netstat命令中提取了如下信息作为用例：

#+BEGIN_EXAMPLE
    $ cat netstat.txt
    Proto Recv-Q Send-Q Local-Address          Foreign-Address             State
    tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
    tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
    tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
    tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT
    tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED
    tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED
    tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT
    tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
    tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1
    tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED
    tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT
    tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK
    tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED
    tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2
    tcp        0      0 :::22                  :::*                        LISTEN
#+END_EXAMPLE

下面是最简单最常用的awk示例，其输出第1列和第4例，

- 其中单引号中的被大括号括着的就是awk的语句，注意，其只能被单引号包含。
- 其中的$1..$n表示第几例。注：$0表示整个行。

#+BEGIN_EXAMPLE
    $ awk '{print $1, $4}' netstat.txt
    Proto Local-Address
    tcp 0.0.0.0:3306
    tcp 0.0.0.0:80
    tcp 127.0.0.1:9000
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp :::22
#+END_EXAMPLE

我们再来看看awk的格式化输出，和C语言的printf没什么两样：

#+BEGIN_EXAMPLE
    $ awk '{printf "%-8s %-8s %-8s %-18s %-22s %-15s\n",$1,$2,$3,$4,$5,$6}' netstat.txt
    Proto    Recv-Q   Send-Q   Local-Address      Foreign-Address        State
    tcp      0        0        0.0.0.0:3306       0.0.0.0:*              LISTEN
    tcp      0        0        0.0.0.0:80         0.0.0.0:*              LISTEN
    tcp      0        0        127.0.0.1:9000     0.0.0.0:*              LISTEN
    tcp      0        0        coolshell.cn:80    124.205.5.146:18245    TIME_WAIT
    tcp      0        0        coolshell.cn:80    61.140.101.185:37538   FIN_WAIT2
    tcp      0        0        coolshell.cn:80    110.194.134.189:1032   ESTABLISHED
    tcp      0        0        coolshell.cn:80    123.169.124.111:49809  ESTABLISHED
    tcp      0        0        coolshell.cn:80    116.234.127.77:11502   FIN_WAIT2
    tcp      0        0        coolshell.cn:80    123.169.124.111:49829  ESTABLISHED
    tcp      0        0        coolshell.cn:80    183.60.215.36:36970    TIME_WAIT
    tcp      0        4166     coolshell.cn:80    61.148.242.38:30901    ESTABLISHED
    tcp      0        1        coolshell.cn:80    124.152.181.209:26825  FIN_WAIT1
    tcp      0        0        coolshell.cn:80    110.194.134.189:4796   ESTABLISHED
    tcp      0        0        coolshell.cn:80    183.60.212.163:51082   TIME_WAIT
    tcp      0        1        coolshell.cn:80    208.115.113.92:50601   LAST_ACK
    tcp      0        0        coolshell.cn:80    123.169.124.111:49840  ESTABLISHED
    tcp      0        0        coolshell.cn:80    117.136.20.85:50025    FIN_WAIT2
    tcp      0        0        :::22              :::*                   LISTEN
#+END_EXAMPLE

**** 脱掉外套

***** 过滤记录

我们再来看看如何过滤记录（下面过滤条件为：第三列的值为0 &&
第6列的值为LISTEN）

#+BEGIN_EXAMPLE
    $ awk '$3==0 && $6=="LISTEN" ' netstat.txt
    tcp        0      0 0.0.0.0:3306               0.0.0.0:*              LISTEN
    tcp        0      0 0.0.0.0:80                 0.0.0.0:*              LISTEN
    tcp        0      0 127.0.0.1:9000             0.0.0.0:*              LISTEN
    tcp        0      0 :::22                      :::*                   LISTEN
#+END_EXAMPLE

其中的“==”为比较运算符。其他比较运算符：!=, >, <, >=, <=

我们来看看各种过滤记录的方式：

#+BEGIN_EXAMPLE
    $ awk ' $3>0 {print $0}' netstat.txt
    Proto Recv-Q Send-Q Local-Address          Foreign-Address             State
    tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
    tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1
    tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK
#+END_EXAMPLE

如果我们需要表头的话，我们可以引入内建变量NR：

#+BEGIN_EXAMPLE
    $ awk '$3==0 && $6=="LISTEN" || NR==1 ' netstat.txt
    Proto Recv-Q Send-Q Local-Address          Foreign-Address             State
    tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
    tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
    tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
    tcp        0      0 :::22                  :::*                        LISTEN
#+END_EXAMPLE

再加上格式化输出：

#+BEGIN_EXAMPLE
    $ awk '$3==0 && $6=="LISTEN" || NR==1 {printf "%-20s %-20s %s\n",$4,$5,$6}' netstat.txt
    Local-Address        Foreign-Address      State
    0.0.0.0:3306         0.0.0.0:*            LISTEN
    0.0.0.0:80           0.0.0.0:*            LISTEN
    127.0.0.1:9000       0.0.0.0:*            LISTEN
    :::22                :::*                 LISTEN
#+END_EXAMPLE

***** *内建变量*

说到了内建变量，我们可以来看看awk的一些内建变量：

| $0                                         | $1~$n                                 | FS                               | NF                                   | NR                                                                              | FNR                                                      | RS                                | OFS                             | ORS                              | FILENAME             |
| 当前记录（这个变量中存放着整个行的内容）   | 当前记录的第n个字段，字段间由FS分隔   | 输入字段分隔符 默认是空格或Tab   | 当前记录中的字段个数，就是有多少列   | 已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。   | 当前记录数，与NR不同的是，这个值会是各个文件自己的行号   | 输入的记录分隔符， 默认为换行符   | 输出字段分隔符， 默认也是空格   | 输出的记录分隔符，默认为换行符   | 当前输入文件的名字   |

怎么使用呢，比如：我们如果要输出行号：

#+BEGIN_EXAMPLE
    $ awk '$3==0 && $6=="ESTABLISHED" || NR==1 {printf "%02s %s %-20s %-20s %s\n",NR, FNR, $4,$5,$6}' netstat.txt
    01 1 Local-Address        Foreign-Address      State
    07 7 coolshell.cn:80      110.194.134.189:1032 ESTABLISHED
    08 8 coolshell.cn:80      123.169.124.111:49809 ESTABLISHED
    10 10 coolshell.cn:80      123.169.124.111:49829 ESTABLISHED
    14 14 coolshell.cn:80      110.194.134.189:4796 ESTABLISHED
    17 17 coolshell.cn:80      123.169.124.111:49840 ESTABLISHED
#+END_EXAMPLE

***** *指定分隔符*

#+BEGIN_EXAMPLE
    $  awk  'BEGIN{FS=":"} {print $1,$3,$6}' /etc/passwd
    root 0 /root
    bin 1 /bin
    daemon 2 /sbin
    adm 3 /var/adm
    lp 4 /var/spool/lpd
    sync 5 /sbin
    shutdown 6 /sbin
    halt 7 /sbin
#+END_EXAMPLE

上面的命令也等价于：（-F的意思就是指定分隔符）

#+BEGIN_EXAMPLE
    $ awk  -F: '{print $1,$3,$6}' /etc/passwd
#+END_EXAMPLE

注：如果你要指定多个分隔符，你可以这样来：

#+BEGIN_EXAMPLE
    awk -F '[;:]'
#+END_EXAMPLE

再来看一个以\t作为分隔符输出的例子（下面使用了/etc/passwd文件，这个文件是以:分隔的）：

#+BEGIN_EXAMPLE
    $ awk  -F: '{print $1,$3,$6}' OFS="\t" /etc/passwd
    root    0       /root
    bin     1       /bin
    daemon  2       /sbin
    adm     3       /var/adm
    lp      4       /var/spool/lpd
    sync    5       /sbin
#+END_EXAMPLE

**** 脱掉衬衫

***** 字符串匹配

我们再来看几个字符串匹配的示例：

#+BEGIN_EXAMPLE
    $ awk '$6 ~ /FIN/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
    1       Local-Address   Foreign-Address State
    6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2
    9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2
    13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1
    18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2

    $ $ awk '$6 ~ /WAIT/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
    1       Local-Address   Foreign-Address State
    5       coolshell.cn:80 124.205.5.146:18245     TIME_WAIT
    6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2
    9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2
    11      coolshell.cn:80 183.60.215.36:36970     TIME_WAIT
    13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1
    15      coolshell.cn:80 183.60.212.163:51082    TIME_WAIT
    18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2
#+END_EXAMPLE

上面的第一个示例匹配FIN状态， 第二个示例匹配WAIT字样的状态。其实 ~
表示模式开始。/ /中是模式。这就是一个正则表达式的匹配。

其实awk可以像grep一样的去匹配第一行，就像这样：

#+BEGIN_EXAMPLE
    $ awk '/LISTEN/' netstat.txt
    tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN
    tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN
    tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN
    tcp        0      0 :::22                   :::*                    LISTEN
#+END_EXAMPLE

我们可以使用 “/FIN|TIME/” 来匹配 FIN 或者 TIME :

#+BEGIN_EXAMPLE
    $ awk '$6 ~ /FIN|TIME/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
    1       Local-Address   Foreign-Address State
    5       coolshell.cn:80 124.205.5.146:18245     TIME_WAIT
    6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2
    9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2
    11      coolshell.cn:80 183.60.215.36:36970     TIME_WAIT
    13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1
    15      coolshell.cn:80 183.60.212.163:51082    TIME_WAIT
    18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2
#+END_EXAMPLE

再来看看模式取反的例子：

#+BEGIN_EXAMPLE
    $ awk '$6 !~ /WAIT/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
    1       Local-Address   Foreign-Address State
    2       0.0.0.0:3306    0.0.0.0:*       LISTEN
    3       0.0.0.0:80      0.0.0.0:*       LISTEN
    4       127.0.0.1:9000  0.0.0.0:*       LISTEN
    7       coolshell.cn:80 110.194.134.189:1032    ESTABLISHED
    8       coolshell.cn:80 123.169.124.111:49809   ESTABLISHED
    10      coolshell.cn:80 123.169.124.111:49829   ESTABLISHED
    12      coolshell.cn:80 61.148.242.38:30901     ESTABLISHED
    14      coolshell.cn:80 110.194.134.189:4796    ESTABLISHED
    16      coolshell.cn:80 208.115.113.92:50601    LAST_ACK
    17      coolshell.cn:80 123.169.124.111:49840   ESTABLISHED
    19      :::22   :::*    LISTEN
#+END_EXAMPLE

或是：

#+BEGIN_EXAMPLE
    awk '!/WAIT/' netstat.txt
#+END_EXAMPLE

*折分文件*

awk拆分文件很简单，使用重定向就好了。下面这个例子，是按第6例分隔文件，相当的简单（其中的NR!=1表示不处理表头）。

#+BEGIN_EXAMPLE
    $ awk 'NR!=1{print > $6}' netstat.txt

    $ ls
    ESTABLISHED  FIN_WAIT1  FIN_WAIT2  LAST_ACK  LISTEN  netstat.txt  TIME_WAIT

    $ cat ESTABLISHED
    tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED
    tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
    tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED

    $ cat FIN_WAIT1
    tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1

    $ cat FIN_WAIT2
    tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2

    $ cat LAST_ACK
    tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK

    $ cat LISTEN
    tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
    tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
    tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
    tcp        0      0 :::22                  :::*                        LISTEN

    $ cat TIME_WAIT
    tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT
    tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT
    tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT
#+END_EXAMPLE

你也可以把指定的列输出到文件：

#+BEGIN_EXAMPLE
    awk 'NR!=1{print $4,$5 > $6}' netstat.txt
#+END_EXAMPLE

再复杂一点：（注意其中的if-else-if语句，可见awk其实是个脚本解释器）

#+BEGIN_EXAMPLE
    $ awk 'NR!=1{if($6 ~ /TIME|ESTABLISHED/) print > "1.txt";
    else if($6 ~ /LISTEN/) print > "2.txt";
    else print > "3.txt" }' netstat.txt

    $ ls ?.txt
    1.txt  2.txt  3.txt

    $ cat 1.txt
    tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT
    tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED
    tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT
    tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
    tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED
    tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT
    tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED

    $ cat 2.txt
    tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
    tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
    tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
    tcp        0      0 :::22                  :::*                        LISTEN

    $ cat 3.txt
    tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2
    tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1
    tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK
    tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2
#+END_EXAMPLE

***** 统计

下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。

#+BEGIN_EXAMPLE
    $ ls -l  *.cpp *.c *.h | awk '{sum+=$5} END {print sum}'
    2511401
#+END_EXAMPLE

我们再来看一个统计各个connection状态的用法：（我们可以看到一些编程的影子了，大家都是程序员我就不解释了。注意其中的数组的用法）

#+BEGIN_EXAMPLE
    $ awk 'NR!=1{a[$6]++;} END {for (i in a) print i ", " a[i];}' netstat.txt
    TIME_WAIT, 3
    FIN_WAIT1, 1
    ESTABLISHED, 6
    FIN_WAIT2, 3
    LAST_ACK, 1
    LISTEN, 4
#+END_EXAMPLE

再来看看统计每个用户的进程的占了多少内存（注：sum的RSS那一列）

#+BEGIN_EXAMPLE
    $ ps aux | awk 'NR!=1{a[$1]+=$6;} END { for(i in a) print i ", " a[i]"KB";}'
    dbus, 540KB
    mysql, 99928KB
    www, 3264924KB
    root, 63644KB
    hchen, 6020KB
#+END_EXAMPLE

**** 脱掉内衣

***** awk脚本

在上面我们可以看到一个END关键字。END的意思是“处理完所有的行的标识”，即然说到了END就有必要介绍一下BEGIN，这两个关键字意味着执行前和执行后的意思，语法如下：

- BEGIN{ 这里面放的是执行前的语句 }
- END {这里面放的是处理完所有的行后要执行的语句 }
- {这里面放的是处理每一行时要执行的语句}

为了说清楚这个事，我们来看看下面的示例：

假设有这么一个文件（学生成绩表）：

#+BEGIN_EXAMPLE
    $ cat score.txt
    Marry   2143 78 84 77
    Jack    2321 66 78 45
    Tom     2122 48 77 71
    Mike    2537 87 97 95
    Bob     2415 40 57 62
#+END_EXAMPLE

我们的awk脚本如下（我没有写有命令行上是因为命令行上不易读，另外也在介绍另一种用法）：

#+BEGIN_EXAMPLE
    $ cat cal.awk
    #!/bin/awk -f
    #运行前
    BEGIN {
        math = 0
        english = 0
        computer = 0

        printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"
        printf "---------------------------------------------\n"
    }
    #运行中
    {
        math+=$3
        english+=$4
        computer+=$5
        printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5
    }
    #运行后
    END {
        printf "---------------------------------------------\n"
        printf "  TOTAL:%10d %8d %8d \n", math, english, computer
        printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR
    }
#+END_EXAMPLE

我们来看一下执行结果：（也可以这样运行 ./cal.awk score.txt）

#+BEGIN_EXAMPLE
    $ awk -f cal.awk score.txt
    NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL
    ---------------------------------------------
    Marry  2143     78       84       77      239
    Jack   2321     66       78       45      189
    Tom    2122     48       77       71      196
    Mike   2537     87       97       95      279
    Bob    2415     40       57       62      159
    ---------------------------------------------
      TOTAL:       319      393      350
    AVERAGE:     63.80    78.60    70.00
#+END_EXAMPLE

***** 环境变量

即然说到了脚本，我们来看看怎么和环境变量交互：（使用-v参数和ENVIRON，使用ENVIRON的环境变量需要export）

#+BEGIN_EXAMPLE
    $ x=5

    $ y=10
    $ export y

    $ echo $x $y
    5 10

    $ awk -v val=$x '{print $1, $2, $3, $4+val, $5+ENVIRON["y"]}' OFS="\t" score.txt
    Marry   2143    78      89      87
    Jack    2321    66      83      55
    Tom     2122    48      82      81
    Mike    2537    87      102     105
    Bob     2415    40      62      72
#+END_EXAMPLE

**** 几个花活

最后，我们再来看几个小例子：

#+BEGIN_EXAMPLE
    #从file文件中找出长度大于80的行
    awk 'length>80' file

    #按连接数查看客户端IP
    netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr

    #打印99乘法表
    seq 9 | sed 'H;g' | awk -v RS='' '{for(i=1;i<=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")}'
#+END_EXAMPLE

**** 自己撸吧

关于其中的一些知识点可以参看[[http://www.gnu.org/software/gawk/manual/gawk.html][gawk的手册]]：

- 内建变量，参看：[[http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din-Variables]]
- 流控方面，参看：[[http://www.gnu.org/software/gawk/manual/gawk.html#Statements]]
- 内建函数，参看：[[http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din]]
- 正则表达式，参看：[[http://www.gnu.org/software/gawk/manual/gawk.html#Regexp]]

** [[http://no001.blog.51cto.com/1142339/389798/][QT_BEGIN_NAMESPACE、QT_END_NAMESPACE 等问题]]    :blog:

#ifndef WINDOW_H
#define WINDOW_H

#include <QSystemTrayIcon>
#include <QDialog>

QT_BEGIN_NAMESPACE
class QAction;
class QCheckBox;
class QComboBox;
class QGroupBox;
class QLabel;
class QLineEdit;
class QMenu;
class QPushButton;
class QSpinBox;
class QTextEdit;
QT_END_NAMESPACE

//! [0]
class Window : public QDialog
{
Q_OBJECT

public:
Window();
……

｝

问题：
1、QT_BEGIN_NAMESPACE、QT_END_NAMESPACE作用是什么
2、这样引入类有什么好处
3、为什么这两个类要通过include引入
#include <QSystemTrayIcon>
#include <QDialog>

1、It is possible to compile whole Qt inside a user-defined namespace.
See configure options for more details. These macros expand as:

Qt Code:
# define QT_BEGIN_NAMESPACE namespace QT_NAMESPACE {
# define QT_END_NAMESPACE }
参考资料：
http://www.qtcentre.org/threads/15946-What-s-effect-of-QT_BEGIN_NAMESPACE-Thanks

2、3
在头文件中尽量引入较少的其它头文件，可以加快编译速度；

要include QSystemTrayIcon是因为在
void iconActivated(QSystemTrayIcon::ActivationReason reason);
这个函数申明的时候需要QSystemTrayIcon类下的变量，其他的用
class QAction;
class QCheckBox;
...
是因为在头文件里面只有这些类的指针申明，并没有真正实例化，在这个头文件对应的cpp文件里面应该会
#include <QAction>
#include <QCheckBox>
...
在cpp文件里面才会正真实例化这些类。
其 实直接在头文件里面#include <QAction> #include <QCheckBox>也是可以的，像它这样做，好像是可以降低各个文件编译时的关联度，不会在改动了一下部分类的时候，引发其他大量文件的 重新编译，在做小工程的时候没什么区别，但是做大了，编译一次需要好几个小时的时候，这样做的优势就显现出来了

** [[http://blog.sina.com.cn/s/blog_674b5aae0100nqpt.html][atoll()函数使用注意事项及分析]]    :blog:

atoll是c99标准加入的函数，在编译的时候可能要打开C99标准的编译选项
-std=c99。

另外，必须包含stdlib.h头文件，否则会出错。

☞ C程序代码如下所示：

#include <stdio.h>

#include <stdlib.h> // 声明atoll函数
 int main()
 {
  char tempbuf[]="430007020001";
  long long unit;

 unit=atoll(tempbuf);
    printf("%lld\n", unit);

 return 0;
 }

编译：
 gcc -S -o test.s test.c



☞ 编译器产生的汇编代码是这样的：

Assembly code

 call atoll ;调用atoll。返回值的低32位保存在eax，高32位保存在edx
  addl $16, %esp ; 调整栈指针，与本题无

     movl % eax, -32(%
ebp); 把eax里保存的低32位保存到局部变量unit的低32位

     movl % edx, -28(%
ebp); 把edx里保存的高32位保存到局部变量unit的高32位

☞ 而如果把#include
<stdlib.h>删掉，也就是不声明atoll函数，编译器产生的汇编代码就变成了这样：

Assembly code

 call atoll
  addl $16, %esp

 cltd ; AT&T汇编里的cltd指令相当于cdq指令，作用是把eax的32位整数扩展为64位，高32位用eax的符号位填充保存到edx

       movl % eax, -32(% ebp);

       movl % edx, -28(% ebp);



☞ 从汇编代码可以看出：

有atoll声明的时候，编译器知道atoll的返回值是64位，所以直接把edx:eax里面保存的64位返回值赋值给unit。

而没有atoll声明的时候，编译器认为atoll的返回值是32位，于是多了一条关键的cltd指令。真正调用atoll的时候，atoll也会把返回值保存在edx:eax；但是main里面不知道，通过cltd指令，用eax的扩展把edx里面保存的有用的高32位覆盖掉了。



☞ 不添加和添加输出结果对比：

   不添加头文件时，输出510290401，显然是错误的；

   添加头文件后，输出430007020001，正确。

** [[http://blog.sina.com.cn/s/blog_6f4e385c0101ksu0.html][gcc头文件搜索路径]]    :blog:


*** [[http://blog.csdn.net/yasi_xi/article/details/8833094][查看gcc/g++默认include路径]]

*`gcc -print-prog-name=cc1plus` -v
*

*`g++ -print-prog-name=cc1plus` -v*

*
*

-
    :: 本文介绍在linux中头文件的搜索路径，也就是说你通过include指定的头文件，linux下的gcc编译器它是怎么找到它的呢。在此之前，先了解一个基本概念。


   头文件是一种文本文件，使用文本编辑器将代码编写好之后，以扩展名.h保存就行了。头文件中一般放一些重复使用的代码，例如函数声明、变量声明、常数定
   义、宏的定义等等。当使用＃include语句将头文件引用时，相当于将头文件中所有内容，复制到＃include处。#include有两种写法形式，
   分别是：

   #include <> ： 直接到系统指定的某些目录中去找某些头文件。

   #include “” ：
   先到源文件所在文件夹去找，然后再到系统指定的某些目录中去找某些头文件。




   #include文件可能会带来一个问题就是重复应用，如a.h引用的一个函数是某种实现，而b.h引用的这个函数却是另外一种实现，这样在编译的时候将会出现错误。所以，为了避免因为重复引用而导致的编译错误，头文件常具有：

   #ifndef  LABEL

   #define  LABEL

     //代码部分

   #endif

   的格式。其中LABEL为一个唯一的标号，命名规则跟变量的命名规则一样。常根据它所在的头文件名来命名，例如，如果头文件的文件名叫做hardware.h，那么可以这样使用：

   #ifndef  __HARDWARE_H__

   #define  __HARDWARE_H__

     //代码部分

   #endif

   这样写的意思就是，如果没有定义__HARDWARE_H__，则定义__HARDWARE_H__，并编译下面的代码部分，直到遇到#endif。这样当重复引用时，由于__HARDWARE_H__已经被定义，则下面的代码部分就不会被编译了，这样就避免了重复定义。




   一句话，头文件事实上只是把一些常用的命令集成在里面，你要用到哪方面的命令就载入哪个头文件就可以了。



     gcc寻找头文件的路径(按照1->2->3的顺序)

     1.
   在gcc编译源文件的时候，通过参数-I指定头文件的搜索路径，如果指定路径有多个路径时，则按照指定路径的顺序搜索头文件。命令形式如：“gcc
   -I /path/where/theheadfile/in
   sourcefile.c“，这里源文件的路径可以是绝对路径，也可以是相对路径。eg：

   设当前路径为/root/test，include_test.c如果要包含头文件“include/include_test.h“，有两种方法：

   1) include_test.c中#include “include/include_test.h”或者#include
   "/root/test/include/include_test.h"，然后gcc include_test.c即可

   2) include_test.c中#include 或者#include ，然后gcc --I include
   include_test.c也可



     2.
   通过查找gcc的环境变量C_INCLUDE_PATH/CPLUS_INCLUDE_PATH/OBJC_INCLUDE_PATH来搜索头文件位置。



     3. 再找内定目录搜索，分别是

   /usr/include

   /usr/local/include

   /usr/lib/gcc-lib/i386-linux/2.95.2/include

   最后一行是gcc程序的库文件地址，各个用户的系统上可能不一样。

     gcc在默认情况下，都会指定到/usr/include文件夹寻找头文件。


   gcc还有一个参数：-nostdinc，它使编译器不再系统缺省的头文件目录里面找头文件，一般和-I联合使用，明确限定头文件的位置。在编译驱动模块
   时，由于非凡的需求必须强制GCC不搜索系统默认路径，也就是不搜索/usr/include要用参数-nostdinc，还要自己用-I参数来指定内核
   头文件路径，这个时候必须在Makefile中指定。


      4.
   当#include使用相对路径的时候，gcc最终会根据上面这些路径，来最终构建出头文件的位置。如#include
   就是包含文件/usr/include/sys/types.h

** [[http://blog.csdn.net/mfc11/article/details/6591134][关于qt中的tr（）函数]]    :blog:



在论坛中漂，经常遇到有人遇到tr相关的问题。用tr的有两类人：

- (1)因为发现中文老出问题，然后搜索，发现很多人用tr，于是他也开始用tr
- (2)另一类人，确实是出于国际化的需要，将需要在界面上显示的文件都用tr包起来，这有分两种：

   -  (2a)
      用tr包住英文(最最推荐的用法，源码英文，然后提供英文到其他语言的翻译包)
   -  (2b) 用tr包住中文(源码用中文，然后提供中文到其他语言的翻译包)

*注意哦，如果你正在用tr包裹中文字符，却不属于(2b)，那么，这是个信号：*

- 你在误用tr
- 你需要的是QString，而不是tr

*如果你确实属于(2b)，请做好心理准备，你可能还会遇到很多困难,请考虑*[[http://blog.csdn.net/dbzhang800/archive/2011/04/19/6334852.aspx][Qt国际化（源码含中文时）的点滴分析]]*
*

*tr 是做什么的？下面二者的区别是什么？*

#+BEGIN_EXAMPLE
    QString text1 = QObject::tr("hello");
     QString text2 = QString("hello");
#+END_EXAMPLE

tr是用来实现国际化，如果你为这个程序提供了中文翻译包(其中hello被翻译成中文"你好")，那么text1的内容将是中文"你好"；如果你为程序提供且使用日文翻译包，那么text1的内容将是日文。

tr是经过多级函数调用才实现了翻译操作，是有代价的，所以不该用的时候最好不要用。

*** 关注的对象

本文关注的是tr或translate中包含中文字符串的情况：

- =QObject::tr()=

- =QCoreApplication::translate()=

- =QTextCodec::setCodecForTr=

这个问题本多少可说的。因为涉及到的编码问题和[[http://hi.baidu.com/cyclone/blog/item/9d7293130e5a498d6538dbf1.html][QString
与中文问题]]中是完全一样的，只不过一个是用的setCodecForCStrings一个用的是setCodecForTr。

**** 简单回顾QString的中文问题

- QString 采用的unicode，在中文支持上不存在任何问题
- ="我是中文"= 这是传统的 =const char *= 的窄字符串

- 当将窄字符串赋值到QString时，我们需要告诉它我们的窄串采用的何种编码(gbk?、utf-8?)
- 究竟何种编码主要取决于我们的源代码文件的编码(windows上一般是gbk，其他平台一般utf-8)

例子：

#+BEGIN_EXAMPLE
    QString s1 = "我是中文";
    QString s2("我是中文");
    QString s3;
    s3 = "我是中文"
#+END_EXAMPLE

- s1、s2 用的是QString的构造函数=QString ( const char * str )=

- s3
   用的是QString的赋值操作符 =QString & operator= ( const char * str)=

如果不指定编码，s1,s2,s3将全部都是(国内大多数人所称的)乱码。因为QString将这些=const char *=按照latin1来解释的，而不是用户期待的gbk或utf8。

#+BEGIN_EXAMPLE
    QTextCodec::setCodecForCStrings(QTextCodec::codecForName("GB2312"));
    QTextCodec::setCodecForCStrings(QTextCodec::codecForName("UTF-8"))
#+END_EXAMPLE

这两条语句中的一条可以解决问题，至于如何选择，此处不再重复。

*** QObject::tr

说实话，在tr中使用中文不是个好主意。不过既然总有人用（无论是(1)还是(2b)），而且总有人遇到问题，所以还是简单整理一下吧。

相比=QCoreApplication::translate=，大家用tr应该用的很多了，尽管不少人不清楚tr究竟是做什么的=^_^=





#+BEGIN_EXAMPLE
    tr("我是中文");
#+END_EXAMPLE

这调用的是下面这个函数(至少我们可这么认为是)。

#+BEGIN_EXAMPLE
    QString QObject::tr ( const char * sourceText, const char * disambiguation = 0, int n = -1 )
#+END_EXAMPLE

与QString("我是中文")完全一样，你必须告诉tr这个窄字符串是何种编码？你不告诉它，它就用latin1。于是所谓的乱码问题就出来了。

如何告诉tr你写的这几个汉字在磁盘中保存的是何种编码呢？这正是

#+BEGIN_EXAMPLE
    QTextCodec::setCodecForTr(QTextCodec::codecForName("GB2312"));
    QTextCodec::setCodecForTr(QTextCodec::codecForName("UTF-8"));
#+END_EXAMPLE

所做的。这两个选择的原则，由于和前文完全一样，此处也不再重复。

如果你的编码采用的utf8，可以直接使用trUtf8而不必设置setCodecForTr。

如果你只关心乱码问题，到此为止就可以了(下面不再关注编码)。如果想对tr进一步了解，不妨。。继续。。



*** QCoreApplication::translate

我们知道tr是用于实现程序的国际化(或者说多语言翻译)，看Qt相关资料的话，我们知道实现该功能的还有下面这个函数：

#+BEGIN_EXAMPLE
    QString QCoreApplication::translate ( const char * context, const char * sourceText, const char * disambiguation, Encoding encoding, int n )
#+END_EXAMPLE

其实，这个才是真正进行翻译操作的函数，前面我们提到的tr最终是通过调用该函数来实现翻译功能的(稍后我们会看tr是如何调用translate的)。

对tr和这个函数，manual中都有比较详尽的解释。我们这儿简单看一下它的这几个参数：

- context 上下文，一般就是需要翻译的字符串所在的类的名字
- sourceText 需要翻译的字符串。(我们关注的编码其实就是它的编码)
- disambiguation
   消除歧义用的。(比如我们的类内出现两处"close"，一处含义是关闭，另一处含义是亲密的。显然需要让翻译人员知道这点区别)
- encoding 指定编码。它有两个值

   -  CodecForTr 使用setCodecForTr()设置的编码来解释 sourceText

   -  UnicodeUTF8 使用utf8编码来解释 sourceText
   -  其实这两个分别对应tr和trUtf8

- n 处理单复数(对中文来说，不存在这个问题)

*** tr与translate

这两个函数的说明，一个在QObject的manual，另一个在QCoreApplication的manual中。

介绍一下tr与translate的关系。前面提到了，tr调用的是translate。如果仅仅这样一说，没有证据，还真难以让大家相信。好吧，继续

**** tr 在何处定义

你可能说：这不废话吗，manual中写得明白的，它是QObject的静态成员函数。而且还有源码为证：

#+BEGIN_EXAMPLE
    //来自 src/corelib/kernel/qobject.h
    #ifdef qdoc
    static QString tr(const char *sourceText, const char *comment = 0, int n = -1);
    static QString trUtf8(const char *sourceText, const char *comment = 0, int n = -1);
    #endif
#+END_EXAMPLE

嘿嘿，差点就被骗了，发现没：它们被预处理语句包住了。

这说明了什么呢？说明了这段代码*仅仅是*用来生成Qt那漂亮的文档的(qdoc3从代码中抽取信息，生成一系列的html格式的manual)。

啊，也就是说，这是假的。那么真正的定义呢？？在一个大家都很熟悉的地方,猜猜看？

这就是

#+BEGIN_EXAMPLE
    Q_OBJECT
#+END_EXAMPLE

该宏的定义在src/corelib/kernel/qobjectdefs.h中

#+BEGIN_EXAMPLE
    #define Q_OBJECT \
     public: \
     Q_OBJECT_CHECK \
     static const QMetaObject staticMetaObject; \
     Q_OBJECT_GETSTATICMETAOBJECT \
     virtual const QMetaObject *metaObject() const; \
     virtual void *qt_metacast(const char *); \
     QT_TR_FUNCTIONS \
     virtual int qt_metacall(QMetaObject::Call, int, void **); \
     private:
#+END_EXAMPLE



其中的宏QT_TR_FUNCTIONS

#+BEGIN_EXAMPLE
    #  define QT_TR_FUNCTIONS \
     static inline QString tr(const char *s, const char *c = 0) \
     { return staticMetaObject.tr(s, c); } \
     static inline QString trUtf8(const char *s, const char *c = 0) \
     { return staticMetaObject.trUtf8(s, c); } \
     static inline QString tr(const char *s, const char *c, int n) \
     { return staticMetaObject.tr(s, c, n); } \
     static inline QString trUtf8(const char *s, const char *c, int n) \
     { return staticMetaObject.trUtf8(s, c, n); }
#+END_EXAMPLE

现在看到：tr调用的是 staticMetaObject对象的tr函数，staticMetaObject
的定义在moc生成的 xxx.moc 或 moc_xxx.cpp 文件内(你随时可以验证的)。

staticMetaObject 是一个 QMetaObject 类的实例，我们继续看一下该类的源码：

#+BEGIN_EXAMPLE
    /*!
     \internal
    */
     QString QMetaObject::tr(const char *s, const char *c) const
     {
     return QCoreApplication::translate(d.stringdata, s, c, QCoreApplication::CodecForTr);
     }
     /*!
     \internal
    */
    QString QMetaObject::trUtf8(const char *s, const char *c) const
    {
    return QCoreApplication::translate(d.stringdata, s, c, QCoreApplication::UnicodeUTF8);
#+END_EXAMPLE

}

** [[http://blog.sina.com.cn/s/blog_ad91f9bc01018as9.html][QT的安装及环境配置]]    :blog:



QT的安装及环境配置

一、windows的下QT的安装及环境配置

（一）从框架安装程序中安装

步骤：

准备：下载QT库，下载指定版本的MINGW，QT IDE

1、下载QT安装文件如：qt-win-opensoure-4.6.4-mingw.exe

2、下载MINGW：mingw 或者 dev-cpp

3、下载QTIDE：QTCreator

3、执行安装MINGW(至少安gcc complier、g++ complier、MinGw Make)

4、执行安装QTIDE:QtCreator

5、安装QT库：qt-win-opensoure-4.5.2-mingw.exe

6、编译QT debug库。QT库安装后有一个QT Build Debug libraries快捷方式。

7、手动配置环境变量(一般在WINDOWS下可略过此步,但最好配置一下)

8、安装完QT库以后，一般会有一个QT command prompt 的快捷方式，它可以

打开一个控制台，并且能够自动设置（使用MinGw编译器编译QT程序所需要的)

环境变量，在这个窗口中，就可以运行qmake以及make命令来编译QT应用程序。

9、QTIDE(QtCreator的配置)，

主要设置：

1) QT版本设置：tools>options>build&run>Qt version

在这里添加QT库的（安装目录下的）qmake

如：C:\Qt\4.6.4\bin\qmake.exe

[[http://photo.blog.sina.com.cn/showpic.html#blogid=ad91f9bc01018as9&url=http://s10.sinaimg.cn/orignal/ad91f9bcxd10bcda20f79][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]



2) 编译器及调试器设置：tools>options>build&run>Tool Chains

首先添加MINGW

在Complier path添加g++目录(mingw安装目录中的)

如：C:\MINGW\bin\g++.exe

[[http://photo.blog.sina.com.cn/showpic.html#blogid=ad91f9bc01018as9&url=http://s8.sinaimg.cn/orignal/ad91f9bcxd10bcef38907][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]



（二）使用SDK安装

安装完成，设置环境变量及QTIDE设置

（三）使用源代码安装

1、安装MINGW

2、安装QTIDE：QtCreator

3、下载并解压缩QT源代码到指定目录，如：C:\QT\QTSRC

4、编译源代码：如果编译不成功，则设置MINGW环境变量，及加入到PATH中

进入命令窗口

进入解压目录：

//运行configure进行配置生成makefile 这里同时编译debug版本(调试程序用)和

release版（运行程序使用）

C:\QT\QTSRC>configure -debug-and-release

//运行MINGW的make工具(mingw32-make) 进行编译

C:\QT\QTSRC>mingw32-make

编译成功后，便可使用，无需安装。

5、环境变量的设置。

6、Qt Creator的配置





二、X11平台下安装

（一）SDK安装

安装完以后需要配置环境变量。



（二）编译源代码安装

1、下载所需要的版本QT库源代码。

2、解压缩源代码到指定目录

3、切换工作目录到源代码解压缩目录。

4、生成平台相关qmake>makefile

运行./configure（使用绝对路径，或者相对路径），可加参数

(最好先使用make clean将以前有可能已经编译的清除掉)

./configure -prefix=安装目录 //编译完成后，使用make install时，安装到哪个

目录

5、执行make 编译

make [all] //编译debug 与release版，默认只编译release

6、安装QT

make install 默认安装到/usr/local下(如果configure -prefix指定，则安装到指定

目录)

7、设置环境变量

8、验证安装

qmake -v

9、删除本次安装时使用的编译过的文件及配置文件等

make clean

10、可提前安装QTIDE，都完成安装后设置QTIDE的选项(编译器及调试器的

路径设置g++ gdb)

三、环境变量的配置

² WINDOWS平台

1、可以使用我的电脑属性右键设置。永久有效

QTDIR=QT安装目录

MINGW=MINGW安装目录

PATH附加上%QTDIR%\bin;%MINGW%\bin;

QMAKESPEC=win32-g++

2、也可以使用进入DOS窗口，使用CMD命令设置，但只对本窗口有效

设置：进入CMD

C:>set QTDIR=QT安装目录

set MINGW=MINGW安装目录

set PATH=%QTDIR%\BIN;%MINGW%\bin;%PATH%

set QMAKESPEC=win32-g++





² X11平台

1、如果使用的Shell是bash、ksh、zsh、sh

将下列内容写入到~/.bash_profile(或者~/.profile)加入以下内容

#QT Settings

export QTDIR=QT安装目录

export PATH=$QTDIR/bin:$PATH

export LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH

export MANPATH=$QTDIR/doc/man:$MANPATH

#End QT Settings

#为批注。

2、如果使用的Shell是CSH 或者TCSH

将下列代码加入到/etc/csh.login

#QT Settings

setenv PATH QT安装目录/bin:$PATH

#End QT Settings



注1：所有目录，最好不带有空格和中文。gcc是GNU c编译器， g++是GNU c++编译器

注2：默认只编译release(用于运行QT程序)，不编译debug(用于调试QT程序)

解决：

在WINDOWS，

使用QT框架安装完以后，有一个QT Build Debug Libraries快捷方式(进行编译)

指向QT安装目录\bin\qtvars.bat文件

使用QT源代码编译时，指定configure -debug-and-release

在X11下，make时，加上选项 make all



附件：QT安装目录\bin\qtvars.bat文件 DOS下编译Debug Libraries

@echo off

rem

rem This file is generated

rem



echo Setting up a MinGW/Qt only environment...

echo -- QTDIR set to C:\Qt\4.6.4

echo -- PATH set to C:\Qt\4.6.4\bin

echo -- Adding C:\MinGW\\bin to PATH

echo -- Adding %SystemRoot%\System32 to PATH

echo -- QMAKESPEC set to win32-g++



set QTDIR=C:\Qt\4.6.4

set PATH=C:\Qt\4.6.4\bin

set PATH=%PATH%;C:\MinGW\\bin

set PATH=%PATH%;%SystemRoot%\System32

set QMAKESPEC=win32-g++



if not "%1"=="compile_debug" goto END

cd %QTDIR%

echo This will configure and compile qt in debug.

echo The release libraries will not be recompiled.

pause

configure -plugin-sql-sqlite -plugin-sql-odbc -qt-libpng -qt-libjpeg

cd %QTDIR%\src

qmake

mingw32-make debug

:END

** [[http://blog.csdn.net/lincyang/article/details/5779464][关于qt :: error: collect2: ld returned 1 exit status的错误]]    :blog:

刚才遇到的这个问题，在网上搜索了一下，

有说之前的程序已经运行了，有说pro文件有问题的，

我找了一会，发现我在头文件中定义了两个slots，

在cPP文件中没有实现。

见nokia论坛

Another reason might be that your source is incomplete and calls method DECLARATIONS that get called but the method IMPLEMENTATIONS are missing.

Declaration is the stuff that you usually put in a header file (method signature without body)
Implementation is the signature with body.

Usually if you look in the linker output, you can find which implementation the linker is missing.

click the "Compile Output" view (Alt+4) to see more detailed info.

这样，我找到了这个低级错误~~~

** [[http://blog.csdn.net/wh_19910525/article/details/8128916][如何在windows下使用git及github仓库管理项目]]    :blog:


*第一，下载并安装git*


目前windows版本的git有几种实现，但我们选择msysgit发行版，这是目前做得*兼容性最好的*。

下载地址：[[http://code.google.com/p/msysgit/downloads/list]]

使用默认配置安装Git。这个不用多说，一路Next就可以，如果对各种选项不熟悉，建议使用默认配置，没问题的。



*第二，创建github账号*

***** 什么是Git和GitHub

*Git* ---The stupid content tracker,
傻瓜内容跟踪器，是一个由Linux内核开发者Linus为了更好地管理Linux内核开发而创立的*分布式版本控制软件*。

*GitHub* ---
学生做版本控制最讨厌的就是找服务器，配置太麻烦了。*GitHub这个网站为每个用户提供服务器托管其Git代码库，免费空间为300M*。注册GitHub后你就会有0.3G的免费空间，不过*只能创建公开项目*。

***** 为什么不选CVS或SVN

- Git提交/克隆/pull/push的速度更快
- Git的*绝大多数操作都可以在本地完成，不需要频繁连接服务器*。

--------------

***** 注册GitHub账号

- *GitHub网址在[[https://github.com/][这里]]*
- 点击上方导航条的[[https://github.com/plans][Signup and
   Pricing]]即可进入注册界面， 选择注册免费账户

[[http://oncoding.in/wp-content/uploads/2011/10/9cccbccb8c60.jpg][[[http://www.kuqin.com/upimg/allimg/111113/2304132200-1.jpg]]]]



- *GitHub选择的默认通信方式是SSH*，所以要先在Git里面生成SHH
   Key，打开Git Bash在其中输入如下命令：

*ssh-keygen -t rsa -C "3sdfsf80@xinlang.com"*

之后会让你选择是否对存放SSH
Key的文件夹进行加密，一般都不需要的。*一路回车，就OK了。*

- 在c盘，*当前用户*文件夹下，有个.ssh 文件夹，在里边 找到
   id_rsa.pub文件，用记事本打开，复制其中的全部内容。
- 登陆你的GitHub账户，依次点击/Account Settings/ > /SSH Public Keys/ >
   /Add another public key/，把id_rsa.pub中的内容拷贝进去 。
- 至此，基本的设置已经完成了。

成了。

--------------

***** 测试你的Git

- 经过上述配置，*你的Gti应该可以通过SSH连接GitHub服务器了，让我们来测试下*，输入如下命令：

[[http://oncoding.in/wp-content/uploads/2011/10/1.jpg][[[http://www.kuqin.com/upimg/allimg/111113/23041312D-3.jpg]]]]

- 会给你这样的提示：

[[http://oncoding.in/wp-content/uploads/2011/10/2.jpg][[[http://www.kuqin.com/upimg/allimg/111113/230413I29-4.jpg]]]]

- 输入yes，会显示：

[[http://oncoding.in/wp-content/uploads/2011/10/3.jpg][[[http://www.kuqin.com/upimg/allimg/111113/2304135U1-5.jpg]]]]

- 到这里，说明你的SSH运转良好。

如果提示你的密钥不正确，那么你需要重新确认上一步的操作是否完整无误。



*第三，建立本地git仓库*



首先，git要求使用者必须提供自己的身份标识，为此我们需要在git
bash中执行以下命令：

 *git config --global user.name  'aa.Tessst'
 git config --global user.email  fsc@sina.com*

 其次，选择git仓库目录

 我们*假设将git仓库目录放在D盘的OPENSource目录下*，可以通过在git
bash中执行以下命令完成：

 cd /d
 mkdir OPENSource

 注：git bash支持大多linux bash终端命令，你可以自己尝试更多终端操作。



最后，建立项目并初始化git仓库


我们的第一个项目是一个使用Python语言将XML文件转换成Python字典，通过执行以下命令完成此步骤：

 mkdir Python-XML2Dict
 cd Python-XML2Dict
 *git init


执行此操作后，git将在Python-XML2Dict目录下创建一个隐藏目录（.git），这个目录就是git用来管理软件版本的仓库。*


*第四，使用git管理项目*

  此步 和 在linux 上 使用 git 的 方法一样，具体参考 我的 其他 博文！



*第五，将项目提交到github管理，[[http://blog.csdn.net/wh_19910525/article/details/7438183][gitpush]]*

如果 *第二步 测试无错*，那么 经过 以下两步
就可以将本地的文件提交到github仓库了。

1、登录GitHub后，你可以在右上边靠中那里找到一个按钮“creat a New
Repository”，点击过后，*填入项目名称*、说明等
过后就可以创建了，然后会出现一个提示页面，记下类似*
git@github.com:XXX/XXX.git* 的地址，这个就是你这个项目的地址了。



2、

#+BEGIN_EXAMPLE
    1 git remote add origin git@github.com:XXX/XXX.git
    2 git push -u origin master //把本地 master 分支 推送到 服务器的master分支上，如果服务器没有此分支，就 新建 此分支。这也是 在服务器上新建分支的一种方法
#+END_EXAMPLE



这个=git@github.com:XXX/XXX.git=就是上面创建项目是生成的地址。现在打开你的项目网址，你就可以发现你的代码已经展示出来了。



*第六，直接 用 git pull 将项目 从 github 上 同步 下来
*

有两种方法：

*1、当git clone之后，直接git pull它会自动匹配一个正确的remote url*

是因为在config文件中配置了以下内容：

#+BEGIN_EXAMPLE
    1 [branch "master"]
    2     remote = origin
    3     merge = refs/heads/master
#+END_EXAMPLE

表明：

1.git处于master这个branch下时，默认的remote就是origin；

2.当在master这个brach下，使用指定remote和merge的git
pull时，使用默认的remote和merge。



*2、但是对于自己建的项目*，*并没有这块内容，需要自己配置*。

#+BEGIN_EXAMPLE
    1 git remote add -f origin login@git.sv.gnu.org:/srv/git/project.git  //若是 执行过 第五步，那么 这一句 就 不用了
    2 git config branch.master.remote origin  //这一步 设置： 把 master 分支上 的 默认服务器地址 设为 origin指向的地址
    3 git config branch.master.merge refs/heads/master   //这一步 设置：如果当前分支是 master 分支，那么 git pull之后，直接 把 “从 origin 下载 下来的 code合并到 master分支上“

    或者加上--global选项，对于全部项目都使用该配置。
#+END_EXAMPLE



建议：用第二种 方法，因为 如果 是 git clone的 项目，当 执行 git push
时，因为 *在 git  config里 url  是 只读方式*

[remote "origin"]
    fetch = +refs/heads/*:refs/remotes/origin/*
   * url = git://github.com/xxx/xxx.git*
 //*git@github.com:XXX/XXX.git 这才是 读写方式*


---------------------------------



如果提交了敏感信息，比如代码中设置的自己的密码什么的忘删除就上传上去了怎么办？

有两个方法：

1、重新修改本地代码，然后提交到服务器（覆盖），

2、直接登录 github
删除之前的项目。删除项目需要在GitHub网站上右上方找到*admin*按钮，进去后右边最下面有个删除的按钮，这样就可以删除了。



--------------------------



若是一个项目就托管在 GitHub 上。你可以把它的 URL
分享给每位对此项目感兴趣的人。本例的 URL 是
=http://github.com/testinguser/iphone_project=。而在项目页面的摘要部分，你会发现有两个
Git URL 地址，见 右图：

[[http://git-scm.com/figures/18333fig0408-tn.png]]


   右图的 摘要中的公共 URL 和私有 URL

Public Clone URL 是一个公开的，只读的 Git
URL，任何人都可以通过它克隆该项目。可以随意散播这个
URL，比如发布到个人网站之类的地方等等。

Your Clone URL 是一个基于 SSH 协议的可读可写 URL，只有使用与上传的 SSH
公钥对应的密钥来连接时，才能通过它进行读写操作。其他用户访问该项目页面时只能看到之前那个公共的
URL，看不到这个私有的 URL。

** [[http://jandan.net/2013/12/20/robots-drc.html][DARPA 机器人挑战赛里的机器人    :blog:
]]

DARPPA机器人挑战赛(DRC)是是机器人领域的一项重大赛事，由DARPA(国防高等研究计划署)举办。今年的DRC大赛预计会相当混乱。DRC每两年举办一次，由美国国防部赞助，比赛希望能甄选出可在福岛核电站这种人类密集，人类无法接近的危害发生地担负现场急救任务的机器人。就现在看来，比赛还遥遥无期，全球各个机器人团队正在研发和测试他们的机器人，还停留在模拟软件阶段。DRC的初赛是VRC，虚拟机器人挑战赛，今年夏天已经结束，并没有多少人知道这个赛事。只有通过VRC赛事的团队才有获得使用一台Atlas机器人的资格(由波士顿动力公司研发，DARPA提供研发经费)。DRC比赛将于12月20日举行到21日，机器人物理能力测试将在佛罗里达州的霍姆斯特德－迈阿密赛道进行。

再强调一次，这种比赛是场灾难。超过12台机器人将自主寻路跨越障碍，完成跨越崎岖路段的挑战，以及驾驶北极星越野车这种疯狂任务，让机器人进行这种比赛会成功么？答案是：一定会失败。机器人的下场可以预见：电机失效、制动失灵、即使有电脑控制机器人也会脱离目标或退出比赛。

有了这些可能性，DRC大赛更加激动人心。会有机器人完成所有的八项挑战么？比赛会因失控草草结束么？DARPA不担心比赛失控，仅仅一年后就会进行决赛——表现最佳的团队会进入2014年12月的决赛，全面升级的机器人们将挑战更变态的任务，赢取200万美元大奖。

在测试结果的搞笑视频还没有出来之前，我们先看看这些参加DRC大赛的机器人。



DARPA 机器人挑战赛里的机器人
THOR 和 THOR-OP


弗吉尼亞理工学院暨州立大学派出的还是两台机器人。一台叫做THOR(图中左边那台，全称Tactical Hazardous Operations Robot战略危害作业机器人)是首发选手，相比大多数人形机器，THOR更接近人类肌肉活动和稳定性，用于进行高风险的危险作业，此类作业的报酬也相当可观。THOR具有复杂的弹性制动联轴装置，可以像人类一样抬腿走路，行进中出现错误也可以通过对应动作来恢复步姿。THOR-OR(Open Platform开阔地带作业机器人)作为候补选手，比THOR机器人更小，步姿也更像本田开发的机器人Asimo，是民用CHARLI-2人形机器的更新版。DARPA此前提到要进行爬梯等特技动作实验，在THOR-OP身上并没有看出对应的设计。

但是就在刚刚过去的11月，机器人和机器实验室(RoMeLa)的负责人Dennis Hong认为THOR还没有完成对抗测试。THOR-OP的研制略显匆忙只能作为后备方案，Hong希望能打进八强，为的是可以获得政府的项目资助。机器人大赛的规则十分复杂，但是THOR-OP并不是Hong团队的唯一希望。不论是不是DARPA赞助的比赛，只要有比赛，明年Hong的实验室还要参加。Hong将在2014年机器人大赛决赛上放出THOR放手一搏，这周的机器人比赛里他们会派出大个头机器人，让大家过瘾。“THOR和THOR-OP我们都会带去参加迈阿密的比赛，”Hong说，“赛场上THOR会告诉人们：‘我叫THOR，明年我还会来的！’”



DARPA 机器人挑战赛里的机器人
THOR


尽管今年DRC上THOR出师不利，但是THOR会像克里斯汀U+2022贝尔一样重新崛起，2014年2月THOR将入选美国海军作为消防机器人服役。早在DARPA宣布进行机器人挑战赛之前，美国海军和Hong的RoMeLa实验室就签订了合作跳跃，美国海军要求RoMeLa研发出舰载消防机器人，今年11月装备于已经退役的U.S.S Shadwell试验舰进行实舰演习，不过由于种种原因被延后至2014年2月进行。



DARPA 机器人挑战赛里的机器人
THOR-OP


本该作为候补选手无缘竞赛的THOR-OP有望完成DRC比赛的大多数挑战，例如开门、和拧阀门，其他的任务会也许会交给其他机器人。“我们也许不会参加驾驶越野车的挑战。”Hong说。就算THOR-OP比THOR要矮1英尺(约1.49米高)，但是由于无法灵活更换部件，所以不适合进行驾驶测试。



DARPA 机器人挑战赛里的机器人
CHIMP


卡内基梅隆大学(CMU)有数次赢得DARPA机器人挑战赛的经历，该大学的自寻路机器人Chevy Tahoe驾驶汽车赢得了2007机器人城市挑战。这次他们的Tartan Rescue团队计划用一台和猩猩长的差不多的机器人(重400磅)，在机器人的手臂和腿上装备有坦克履带，这台机器人将成功迈过终点线。CHIMP(卡内基梅隆大学高级智能移动平台)站起来进入多任务模式时，算上“小腿”部分，有1.57米高。不过滚动行进模式依靠履带控制方向、调整位置，需要跨越较长障碍物和清除障碍时会转换成四足模式。CMU国家机器人工程中心总指挥Tony Stenz说：“CHIMP不会像所有两足机器人一样费力用两足站立保持平衡，我们有四条腿，用不着保持平衡，机器人只需要改变形态，四条腿的结构会让它稳稳的。”



DARPA 机器人挑战赛里的机器人
CHIMP


顾名思义，CHIMP(猩猩)配备了两条强壮到不成比例的前肢(和其他机器人相比)，完全伸展情况下翼展达到2.54米，CHIMP并不需要将实时视频传送给开发者——这样对带宽和信号强度需求会超过DARPA的许可，Tony Stenz说：“CHIMP机器人会生成周边环境的彩色3D模型”，使用者可以远控制摄像头焦距，还可以旋转摄像头获得更好的视野，这样可以更好的发布和修改指令。



DARPA 机器人挑战赛里的机器人
Valkyrie


NASA派出了两个机器人进入DRC，一个是约翰逊航天中心的Valkyrie机器人，还有一个是喷气推动实验室的RoboSmian机器人，前者在上周电子工程杂志IEEE Spectrum发布的深度披露视频中大出风头。Valkyrie机器人高1.88米，外层纤维完全包裹了整个躯体，和其他光秃秃的机器人形成了鲜明反差。阵列摄像头是Valkyrie最大的亮点，装载于头部、躯干、脚上、膝盖和手臂。约翰逊航天中心此前在国际空间站测试过机器人宇航员和机器人宇航员2号，这次他们也将把Valkyrie送上去，这对提升Valkyrie的操作能力有非常大的优势。但是也有团队领队质疑Valkyrie看上去连“最基本”的移动能力都没有。

RoboSimian

和它的竞争对手也是NASA制造的兄弟机器人大为不同，可以说，RoboSiiman是本届DRC上最不像人的人形机器人，身上多处裸露，制造它的喷气推动实验室(JPL)形容它长得像猩猩，然而这种猩猩是不存在的。四肢节点众多，灵活度很高，这点类似灵长类。关节均匀分布，可以重合折叠在一起，操作部分的运动角度也绝不像猩猩。RoboSimian运用了双侧半球兑成的设计，也即没有头部或脸部——遍布全身上下的摄像头可以让RoboSimian迅速改变运动方向，无需旋转镜头方向。可不转身进行逆向运动，可以迅速回到原位。这或许也让这台230磅机器人在2014年决赛上多少有些把握。RoboSmian的开发者针对此次DRC比赛专门设计了同方向配备6镜头。即便如此，JPL的机器人还是和其他机器人的视角大为不同。“我们没有用激光雷达”JPL机器人车辆和操控小组的总监Brett Kennedy说，“机器人主要依赖摄像头，自带电源和电池包的大部分电量都是供给摄像头。”火星探测车就没有用上激光雷达技术，这是出于距离遥远能源是最宝贵的，RoboSimian总有一天也会以某种形式登上火星的。

DRC-Hubo

Hubo机器人开发出来已经有些年头了，身材比例像小孩，两足小心行走的姿势让人想起了本田开发的Asimo机器人。“它的个头和力气都和一个10岁小男孩相若，”Drexel实验室的Paul Oh说，“你不会让一个10岁小孩去灾难现场的，你要的是20多个消防员汉子。”DRC-Hubo就可以满足这种需求——比之前的型号高30厘米左右，重20%。但即使这样(只有130磅)，壮汉还是可以背起它，机器人就能更接近事发地点，然后利用自供电独自到达危险地点。Oh先生说，栓机器人的背带是为猎鹿和其他狩猎活动准备的。在疯狂的DRC大赛中，装卸操作对重型机器人是致命的，即便在机器人众多的DRC场面里，Hubo也属于非常超现实的风格，同时也非常聪明，相信在不久的将来如果能解决电池供电问题，Hubo就能投放市场。Hubo团队在参赛前就拥有七台Hubo机器人，Drexel实验室和佐治亚理工大学在训练这批机器人军团的同时，可以开发更强力的机器人。Drexel实验室会带两台相同的Hubo参加迈阿密物理特性测试，所有比赛环节会由两台机器人分工完成。但是如果某一台机器人当机了，Oh希望另一台可以加载响应的控制程序并完成比赛。

DRC-Hubo

为了应对比赛的操控环节，DRC-Hubo对手臂部分进行了修改，机器人的灵活度比之前有所提高。“是不是看上去有点吓人？”Drexel团队的Paul Oh说，“以前Hubo有个挺欢乐的帽子，我们把它取掉了。” Hubo的脑袋瘦瘦长长像个竹竿，在越野车驾驶环节有较大的视野优势。

HRP-2-Based Robot
毋庸置疑DRC中最神秘的机器人，模型机由日本Schaft公司负责制造，目前还没有名字。装备水冷电机、急速放电电池短时间放出的强大电流可以提供超强动力。Schaft的职员前东京大学机器人开发部研究员公布了一段机器人推行其他机器人的视频。

和机器人的表现无关，Google去年收购了这家机器人公司。世界最大的公司加入到了机器人比赛中。

Atlas
前面提到的机器人全部由Track A比赛团队制造，每个团队负责研发各自的控制软件和硬件(DARPA全程提供总共400万美元的资助。)Track B比赛的参赛者只是负责软件开发，DARPA会给每个团队一部配置相同的Atlas机器人，这个闪闪发光的Atlas是波士顿动力开发的超强机器人。

Atlas更为大家所知是一次在日本的演示，演示过程中机器人被摄像头搬到，自己摔了一跤。在另一个视频里，Atlas被一个小东西绊倒了。讽刺的是，生产Atlas的公司就是生产著名的踢不倒机器狗的公司。Atals并不像众多TrackA参赛团队担心的那样拥有牛逼的平衡能力(参加Track A比赛的团队最后要和Track B团队的Atlas机器人进行物理特性测试的比赛。)

过了这周末，Atlas机器人就会更出名了，Atlas将加入Google的机器人大军，波士顿动力未向外界公布Google收购公司的价格，即便考虑到波士顿动力与DARPA的签约在收购之前，公众还是会更关注Atlas机器人在DRC上的表现，机器人大赛也会为Google的无人驾驶项目铺路。这次Google也会举办一个类似DRC的比赛，不过赛程更长。不管最终是机器人奴役人类还是服务人类，不管机器人会不会摔跤或是会不会摔坏，我们明年再看吧。

** [[http://tieba.baidu.com/p/1184618169][Linux系统备份的两种办法]]    :blog:

经听到很多人抱怨 Linux 下没有 ghost 这样“方便”的备份工具。这是一种普遍的误解，其实 Linux 下是可以用 ghost for Linux 的，但因为有更好的办法，所以 ghost 在 Linux 下用得少，知名度不高。

现在以我的系统为例，介绍两种 Linux 下最常见最实用的系统备份方案。我的系统是 Gentoo Linux，sda1 30GB，挂载为 /，sda2 400GB，挂载为 /home, sda3 100GB，格式化为 ext4，空闲。

*** dd
dd 是最强劲有力、稳定可靠的备份工具。

备份：当前系统下，

~ % sudo dd if=/dev/sda1 of=~/gentoo_$(date +"%Y-%m-%d").backup

还原：其它 Linux 系统或者 LiveCD/LiveUSB 下，

~ % sudo dd if=gentoo_*.backup of=/dev/sda1

如果要改变根分区的位置，比如说把根分区移动到 sda5，那麽还需要调整一下：

~ % sudo resize2fs -f /dev/sda5
~ % sudo e2fsck -f /dev/sda5

然后修改恢复出来的 /etc/fstab 文件。

请注意 sda5 的容量必须大于 sda1.

dd 备份简单快速，是速度优先的最好选择，但所需要的磁盘空间比较大。

*** tar + xz
tar 用于打包，xz 用于压缩。

备份：当前系统下，

~ % cd /

/ % sudo tar Jcpvf ~/gentoo_amd64_$(date +"%Y-%m-%d").tar.xz --exclude=./usr/portage/distfiles --exclude=./home --exclude=./lost+found --exclude=./sys --exclude=./proc .

其中，--exclude= 参数列出了不需要备份的目录，可以根据实际情况自行调整。

还原：其它 Linux 系统或者 LiveCD/LiveUSB 下，

~ % sudo mkfs.ext4 /dev/sda1

~ % sudo mount -v /dev/sda1 /mnt

~ % sudo cd /mnt/

~ % sudo tar xpvf gentoo_amd64_*.tar.xz

~ % sudo mkdir -pv home sys proc usr/portage/distfiles

~ % cd && sudo umount -v /mnt

如果移动了根分区，则需要修改还原出来的 /etc/fstab 文件

tar+xz 压缩打包备份的优点，在于极高的压缩率，可以大大减少备份文件的大小。我的备份以前的 / 分区有 11G 大小，而备份出来的 .tar.xz 文件，只有 2.1G，压缩比为超过了 5:1. 但这带来一个问题：备份耗时漫长。比如说我这次 11G 的压缩备份就花了 2 小时。幸好还原速度还可以，只需要 8 分钟。此外，如果你 man 一下 tar，就会发现这种做法其实十分灵活好用。

我就介绍这两种办法，欢迎纠正和补充。

** [[http://www.2cto.com/os/201301/182484.html][linux下更改文件的默认打开方式]]    :blog:



在Gnome的文件管理器(nautilus)里，双击一个文件的时候，系统会自动调用相应 的程序去打开这个文件。在Nautilus里通过右键菜单固然可以修改默认的打开方式，但是缺乏灵活性和可操作性，比如，不能删除一些候选的打开方式，不 能批量增加一些打开方式等等。  www.2cto.com

GNMOE的打开方式的配置方式涉及到以下几个目录和文件：
/usr/share/applications
~/.local/share/applications
/usr/share/applications/mimeinfo.cache
~/.local/share/applications/mimeinfo.cache
去这几个目录看一下，就会发现很多以.desktop为后缀的文件。
你可以手动修正部分打开方式错误的
如  www.2cto.com
vi preferred-web-browser.desktop
[Desktop Entry]
Version=1.0
Encoding=UTF-8
Type=ApplicationExec=/usr/local/softbase/firefox/firefox
TryExec=/usr/local/softbase/firefox/firefox
Name=Preferred Web Browser
GenericName=Web Browser
Comment=Browse the Web
Icon=redhat-web-browser.png
Terminal=false
X-Panel-Monitor=true
NoDisplay=true
修改完成后，就可以解决打开方式命令行参数错误的问题，然后右键选择默认打开方式即可
从总体上讲/usr/share/applications/defaults.list保存了全局的打开方式;
~/.local/share/applications/ 目录下保存了个人的打开方式【候选方式以及个性打开方式】;当两着不一致是，优先采用局部的个人设置。
  www.2cto.com
cd ~/.local/share/applications
删除无用的打开方式，候选打开方式里面就不会再有
如rm -rf wine*    即可【此时立即生效，所有wine相关的候选菜单不会再有
vi mimeapps.list 处理当前右键菜单以及默认打开方式【立即生效】
rm -rf  ~/.local/share/applications/mimeinfo.cache 【或者先察看下】
/usr/share/applications

这两个分别是局部的desktop项和全局的desktop项
/usr/share/applications/mimeinfo.cache
~/.local/share/applications/mimeinfo.cache
这两个分别是全局的和局部的打开方式缓存,想删除某种打开方式，或者修改默认的打开方式，在这里删除或改变顺序即可。

/usr/share/applications/defaults.list的结构 是这样的一种形式
程序的类型/文件类型=打开这个文件的项;[项2;]…[项n;]
候选打开方式可以有好几种中间用；隔开，不留其余字符
要修改一个文件的打开方式，需要先确定这个文件的类型
以纯文本文件为例 类型是plain 打开方式默认为vim.desktop候选的是firefox.desktop
text/plain=vim.desktop;firefox.desktop
可以直接编辑
~/.local/share/applications/defaults.list

编辑完之后，手工修改
/usr/share/applications/mimeinfo.cache
~/.local/share/applications/mimeinfo.cache

这两个cache文件。

下面看一下*.desktop文件的结构
[Desktop Entry]
Encoding=UTF-8 //字符编码
Name=vim　　//现实的名字
MimeType=text/plain; //类型
Exec=vim %f //运行的程序 %f表示一个参数
Type=Application　//类型

** [[http://www.2cto.com/os/201306/222522.html][交换ctrl和caps lock]]    :blog:

交换ctrl和caps lock

因为ctrl键在笔记本键盘的左下角，对于经常使用ctrl键的人来说是个痛苦的事情。在网上搜了下有几种交换键位的方法，在这里记录一下。

第一种方法是使用xmodmap。建立一个新文件~/.Xmodmap，添加以下内容：

remove Lock = Caps_Lock
remove Control = Control_L
keysym Control_L = Caps_Lock
keysym Caps_Lock = Control_L
add Lock = Caps_Lock
add Control = Control_L
然后执行

xmodmap ~/.Xmodmap 2>/dev/null
就行了。如果不想每次启动都手动输入命令，可以把命令写到~/.xinitrc中。注意如果把命令写到~/.bashrc中，每次新开一个终端或tab上述命令都会被执行一次，这样键位又换回来了。

另一种方法是使用setxkbmap命令。只需执行下面的命令：

setxkbmap -option ctrl:swapcaps
就行了。而且可以把命令放到~/.bashrc中，重复执行并不影响。

(2012.07.02更新)在gnome中可以通过图形界面选项调整。打开 系统 -> 首选项 -> 键盘 -> 布局 -> 选项… -> Ctrl key position，选择”Swap Ctrl and CapsLock”即可。

除了交换ctrl和caps lock外也有和alt互换的，这样就可以用两个拇指分别按ctrl和alt(交换右ctrl和alt)：

remove mod1 = Alt_R
remove Control = Control_R
keysym Control_R = Alt_R
keysym Alt_R = Control_R
add mod1 = Alt_R
add Control = Control_R
为什么会想到要交换ctrl键呢？因为某天在网上闲逛的时候，无意中看到这篇文章，顿时热血沸腾，心想左手vim右手emacs是多么拉风的事情。为了表明自己学习的决心，装上emacs的同时也把相伴5年的vim给卸了。磕磕碰地碰用了几个星期，最深的感触是左手小指太辛苦了，即使是把ctrl和caps lock交换，一天下来小指也是又累又痛，于是又灰溜溜地用回vim了。想学习emacs的朋友如果觉得没有动力的话可以看看上面提到的文章，一直在用vim的或者没用过这两者的也建议尝试一下，说不定你就爱上它了。即使可能被吓退，但是相信会从学习过程中收获不少，例如可以在vim里模拟几个emacs移动定位的快捷键，对于输入法切换或输入括号和引号等成对出现的字符时就很方便：

" emacs-style key bindings
inoremap <C-a> <C-o>^
inoremap <C-b> <left>
inoremap <C-d> <del>
inoremap <C-e> <C-o>$
inoremap <C-f> <right>
inoremap <C-g> <esc>
inoremap <C-k> <C-o>D
inoremap <C-n> <down>
inoremap <C-p> <up>
inoremap <C-t> <esc>xpi
inoremap <C-y> <esc>pa
更夸张一点的还把右ctrl和enter给换了，毕竟在emacs中用ctrl的时候很多，而且enter可以用ctrl-m和ctrl-j代替，这样两只手的小指可以左右开弓。

** [[http://bbs.mydigit.cn/simple/?t523987.html][ HDMI、DVI和VGA之间的区别 ]]    :blog:

目前在高清设备中，主要的接口有DVI、HDMI、VGA接口，其中VGA传输的是模拟视频信号，DVI传播的是数字视频信号，HDMI可以同时传输数字视频信号和数字音频信号。在现在的计算机和电视等设备中，我们经常可以看到这三种接口，很多用户存在疑问，这三种接口之间有什么区别呢?
DVI接口是在1999年推出的接口标准。DVI接口的传输信号采用全数字格式，与之对应的是采用模拟信号的VGA接口。VGA和DVI的区别，首先VGA模拟信号的传输比较麻烦，首先是将电脑内的数字信号转换为模拟信号，将信号发送到LCD显示器，由显示器再将该模拟信号转换为数字信号，形成画面展示在大家面前。正因为如此，中间的信号丢失严重，虽然可以通过软件的方法修复部分画面，但是随着显示器的分辨率越高画面就会越模糊。一般模拟信号在超过1280×1024分辨率以上的情况下就会出现明显的误差，分辨率越高越严重。
VGA接口应用范围非常广泛，是三种接口中最先推出的标准，VGA(Video Graphics Array)接口，也叫D-Sub接口。虽然液晶显示器可以直接接收数字信号，但很多低端产品为了与VGA接口显卡相匹配，因而采用VGA接口。VGA接口是一种D型接口，上面共有15针空，分成三排，每排五个。VGA接口是显卡上应用最为广泛的接口类型，绝大多数的显卡都带有此种接口。
HDMI (High-Definition Multimedia Interface) ，常被称作高清晰度多媒体接口，是终结以往影音分离传输的全新接口，其最大传输速度可达5Gb/s，除影像数据外，更可同时传输高达8声道的音讯信号。这种非压缩式的数字数据传输，可有效降低数/类转换所造成的信号干扰与衰减。HDMI是首个支持在单线缆上传输，不经过压缩的全数字高清晰度、多声道音频和智能格式与控制命令数据的数字接口。HDMI接口由Silicon Image美国晶像公司倡导，联合索尼、日立、松下、飞利浦、汤姆逊、东芝等八家著名的消费类电子制造商联合成立的工作组共同开发的。HDMI最早的接口规范HDMI1.0于2002年12月公布，目前的最高版本是于今年6月发布的HDMI1.3规范。
HDMI源于DVI接口技术，它们主要是以美国晶像公司的TMDS信号传输技术为核心，这也就是为何HDMI接口和DVI接口能够通过转接头相互转换的原因。美国晶像公司是HDMI八个发起者中唯一的集成电路设计制造公司，是高速串行数据传输技术领域的领导厂商。
目前的高端显卡上一般有VGA、DVI、HDMI接口，一般的显示卡VGA、DVI接口；目前生产的大屏幕LED显示器上有VGA、HDMI接口（如三星24寸），中型LED显示器有VGA、DVI接口（比如三星21寸），选购连接线前请注意观察显示卡和显示器接口的匹配，接口型号不同时，可以选择转接线。

** [[https://wiki.archlinux.org/index.php/Xinitrc][xinitrc]]    :blog:

The =~/.xinitrc= file is a shell script read by =xinit= and by its
front-end =startx=. It is mainly used to execute
[[/index.php/Desktop_environment][desktop environments]],
[[/index.php/Window_manager][window managers]] and other programs when
starting the X server (e.g., starting daemons and setting environment
variables). The =xinit= program starts the
[[/index.php/X_Window_System][X Window System]] server and works as
first client program on systems that are not using a
[[/index.php/Display_manager][display manager]].

One of the main functions of =~/.xinitrc= is to dictate which client for
the X Window System is invoked with =startx= or =xinit= programs on a
per-user basis. There exists numerous additional specifications and
commands that may also be added to =~/.xinitrc= as you further customize
your system.

Most DMs also source the similar [[/index.php/Xprofile][xprofile]]
before xinit.

*** Contents

- [[#Installation][1 Installation]]
- [[#Configuration][2 Configuration]]
- [[#Autostart_X_at_login][3 Autostart X at login]]

   -  [[#Automatic_login_to_the_virtual_console][3.1 Automatic login to
      the virtual console]]

- [[#Tips_and_tricks][4 Tips and tricks]]

   -  [[#Override_xinitrc_from_command_line][4.1 Override xinitrc from
      command line]]
   -  [[#Making_a_DE.2FWM_choice][4.2 Making a DE/WM choice]]
   -  [[#Starting_applications_without_a_window_manager][4.3 Starting
      applications without a window manager]]

*** Installation

[[/index.php/Install][Install]]
[[https://www.archlinux.org/packages/?name=xorg-xinit][xorg-xinit]],
which provides both /xinit/ and /startx/.

*** Configuration

If =.xinitrc= is present in a user's home directory, /startx/ and
/xinit/ execute it. Otherwise /startx/ will run the default
=/etc/X11/xinit/xinitrc=.

*Note:* /Xinit/ has its own default behaviour instead of executing the
file. See =man 1 xinit= for details.

This default xinitrc will start a basic environment with
[[/index.php/Twm][Twm]],
[[https://www.archlinux.org/packages/?name=xorg-xclock][xorg-xclock]]
and [[/index.php/Xterm][Xterm]] (assuming that the necessary packages
are installed). Therefore, to start a different window manager or
desktop environment, first create a copy of the default =xinitrc= in
home directory:

#+BEGIN_EXAMPLE
    $ cp /etc/X11/xinit/xinitrc ~/.xinitrc
#+END_EXAMPLE

The reason of doing this (instead of creating one from scratch) is to
preserve some desired default behaviour in the original file, such as
sourcing shell scripts from =/etc/X11/xinit/xinitrc.d=. Scripts in this
directory without =.sh= extension are not sourced:
[[https://bugs.archlinux.org/task/41471][FS#41471]]. As such, replace
=/etc/X11/xinit/xinitrc.d/?*.sh= with =/etc/X11/xinit/xinitrc.d/?*=.
[[https://bbs.archlinux.org/viewtopic.php?pid=1514318#p1514318][[1]]]

Append desired commands and /remove/comment the conflicting lines/.
Remember, lines following =exec= would be ignored. For example, to start
[[/index.php/Openbox#Standalone][openbox]]:

#+BEGIN_EXAMPLE
    ~/.xinitrc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    ...

    if [ -d /etc/X11/xinit/xinitrc.d ] ; then
        for f in /etc/X11/xinit/xinitrc.d/?* ; do
            [ -x "$f" ] && . "$f"
        done
        unset f
    fi

    # twm &
    # xclock -geometry 50x50-1+1 &
    # xterm -geometry 80x50+494+51 &
    # xterm -geometry 80x20+494-0 &
    # exec xterm -geometry 80x66+0+0 -name login

    ## some applications that should be run in the background
    xscreensaver &
    xsetroot -cursor_name left_ptr &

    exec openbox-session
#+END_EXAMPLE

*Note:* At the very least, ensure that the /if block/ in the example
above is present in your =.xinitrc= file to ensure that the scripts in
=/etc/X11/xinit/xinitrc.d= are sourced.

Long-running programs started before the window manager, such as a
screensaver and wallpaper application, must either fork themselves or be
run in the background by appending an =&= sign. Otherwise, the script
would halt and wait for each program to exit before executing the window
manager or desktop environment. Note that some programs should instead
not be forked, to avoid race bugs, as is the case of
[[/index.php/Xrdb][xrdb]]. Prepending =exec= will replace the script
process with the window manager process, so that X does not exit even if
this process forks to the background.

To now run Xorg as a regular user, issue:

#+BEGIN_EXAMPLE
    $ startx
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    $ xinit -- :1 -nolisten tcp vt$XDG_VTNR
#+END_EXAMPLE

Your window manager (or desktop environment) of choice should now start
correctly.

To quit X, run your window manager's exit function (assuming it has
one). If it lacks such functionality, run:

#+BEGIN_EXAMPLE
    $ pkill -15 Xorg
#+END_EXAMPLE

*Note:* /pkill/ will kill all running X instances. To specifically kill
the window manager on the current VT, use:

#+BEGIN_EXAMPLE
    WM_PID=$(xprop -id $(xprop -root _NET_SUPPORTING_WM_CHECK \
    | awk -F'#' '{ print $2 }') _NET_WM_PID \
    | awk -F' = ' '{ print $2 }')

    kill -15 $WM_PID
#+END_EXAMPLE

The program =xprop= is provided by the package
[[https://www.archlinux.org/packages/?name=xorg-xprop][xorg-xprop]] in
the [[/index.php/Official_repositories][official repositories]].

*Note:*

- The above commands run [[/index.php/Xorg][Xorg]] on the same virtual
   terminal the user is logged in to.
   [[http://blog.falconindy.com/articles/back-to-basics-with-x-and-systemd.html][[2]]]
   This maintains an authenticated session with =logind=, and prevents
   bypassing the screen locker by switching terminals.
- You have to specify =vt$XDG_VTNR= as command line option for /xinit/
   in order to
   [[/index.php/General_troubleshooting#Session_permissions][preserve
   session permissions]].
- /xinit/ does not handle multiple sessions when already logged-in into
   a different virtual terminal. For that you must specify the session
   by appending =-- :session_no=. If X is already running, then you
   should start with :1 or more.
- By default, due to permissions on console devices, the X display
   needs to be on the same tty where the login occurred. This is handled
   by the default =/etc/X11/xinit/xserverrc=. See
   [[/index.php/General_troubleshooting#Session_permissions][General
   troubleshooting#Session permissions]] for details.
- If you wish to have the X display on a separate console from the one
   where the server is invoked, you can do so by using the X server
   wrapper provided by =/usr/lib/systemd/systemd-multi-seat-x=. For
   convenience, /startx/ can be set up to use this wrapper by modifying
   your =~/.xserverrc=.
- If you choose to use /xinit/ instead of /startx/, you are responsible
   for passing =-nolisten tcp= and ensuring the session does not break
   by starting X on a different tty.
- If X terminates with error message "SocketCreateListener() failed",
   you may need to delete socket files in =/tmp/.X11-unix=. This may
   happen if you have previously run Xorg as root (e.g. to generate an
   =xorg.conf=, as below).

*** Autostart X at login

*Note:* These solutions run X on the same tty used to login, which is
required in order to maintain the login session.

For [[/index.php/Bash][Bash]], add the following to the bottom of
=~/.bash_profile=. If the file does not exist, copy a skeleton version
from =/etc/skel/.bash_profile=. For [[/index.php/Zsh][Zsh]], add it to
=~/.zlogin= (or =~/.zprofile=) instead.

#+BEGIN_EXAMPLE
    [[ -z $DISPLAY && $XDG_VTNR -eq 1 ]] && exec startx
#+END_EXAMPLE

*Note:*

- You can replace the =-eq 1= comparison with one like =-le 3= (for vt1
   to vt3) if you want to use graphical logins on more than one VT.
- X must always be run on the same tty where the login occurred, to
   preserve the logind session. This is handled by the default
   =/etc/X11/xinit/xserverrc=.
- =xinit= may be faster than =startx=, but needs additional parameter
   such as =-nolisten tcp=.
- If you would like to remain logged in when the X session ends, remove
   =exec=.

See also [[/index.php/Fish#Start_X_at_login][Fish#Start X at login]] and
[[/index.php/Systemd/User#Automatic_login_into_Xorg_without_display_manager][Systemd/User#Automatic
login into Xorg without display manager]].

**** Automatic login to the virtual console

This method can be combined with
[[/index.php/Automatic_login_to_virtual_console][automatic login to
virtual console]].

*** Tips and tricks

**** Override xinitrc from command line

If you have a working =~/.xinitrc=, but just want to try other WM/DE,
you can run it by issuing /startx/ followed by the path to the window
manager:

#+BEGIN_EXAMPLE
    $ startx /full/path/to/window-manager
#+END_EXAMPLE

If the window manager takes arguments, they need to be enquoted to be
recognized as part of the first parameter of /startx/:

#+BEGIN_EXAMPLE
    $ startx "/full/path/to/window-manager --key value"
#+END_EXAMPLE

Note that the full path is *required*. Optionally, you can also override
=/etc/X11/xinit/xserverrc= file (which stores the default X server
options) with custom options by appending them after =--=, e.g.:

#+BEGIN_EXAMPLE
    $ startx /usr/bin/enlightenment -- -nolisten tcp -br +bs -dpi 96 vt$XDG_VTNR
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    $ xinit /usr/bin/enlightenment -- -nolisten tcp -br +bs -dpi 96 vt$XDG_VTNR
#+END_EXAMPLE

See also =man startx=.

*Tip:* This can be used even to start a regular GUI programs but without
any of the window manager features. See also
[[#Starting_applications_without_a_window_manager][#Starting
applications without a window manager]] and
[[/index.php/Running_program_in_separate_X_display][Running program in
separate X display]].

**** Making a DE/WM choice

If you are frequently switching between different DEs/WMs, it is
recommended to either use a [[/index.php/Display_manager][Display
manager]] or add code to =.xinitrc=. The code described next consists of
a simple few lines, which will take the argument and load the desired
desktop environment or window manager.

The following example =~/.xinitrc= shows how to start a particular DE/WM
with an argument:

#+BEGIN_EXAMPLE
    ~/.xinitrc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    ...

    # Here Xfce is kept as default
    session=${1:-xfce}

    case $session in
        awesome           ) exec awesome;;
        bspwm             ) exec bspwm;;
        catwm             ) exec catwm;;
        cinnamon          ) exec cinnamon-session;;
        dwm               ) exec dwm;;
        enlightenment     ) exec enlightenment_start;;
        ede               ) exec startede;;
        fluxbox           ) exec startfluxbox;;
        gnome             ) exec gnome-session;;
        gnome-classic     ) exec gnome-session --session=gnome-classic;;
        i3|i3wm           ) exec i3;;
        icewm             ) exec icewm-session;;
        jwm               ) exec jwm;;
        kde               ) exec startkde;;
        mate              ) exec mate-session;;
        monster|monsterwm ) exec monsterwm;;
        notion            ) exec notion;;
        openbox           ) exec openbox-session;;
        unity             ) exec unity;;
        xfce|xfce4        ) exec startxfce4;;
        xmonad            ) exec xmonad;;
        # No known session, try to run it as command
        *) exec $1;;
    esac
#+END_EXAMPLE

Then copy the =/etc/X11/xinit/xserverrc= file to your home directory:

#+BEGIN_EXAMPLE
    $ cp /etc/X11/xinit/xserverrc ~/.xserverrc
#+END_EXAMPLE

After that, you can easily start a particular DE/WM by passing an
argument, e.g.:

#+BEGIN_EXAMPLE
    $ xinit
    $ xinit gnome
    $ xinit kde
    $ xinit wmaker
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    $ startx
    $ startx ~/.xinitrc gnome
    $ startx ~/.xinitrc kde
    $ startx ~/.xinitrc wmaker
#+END_EXAMPLE

**** Starting applications without a window manager

It is possible to start only specific applications without a window
manager, although most likely this is only useful with a single
application shown in full-screen mode. For example:

#+BEGIN_EXAMPLE
    ~/.xinitrc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    ...

    exec chromium
#+END_EXAMPLE

With this method you need to set each application window's geometry
through its own configuration files, if possible at all.

*Tip:* This method can be useful to launch graphical games, especially
on systems where excluding the memory or CPU usage of a window manager
or desktop environment, and possible accessory applications, can help
improve the game's execution performance.

See also
[[/index.php/Display_manager#Starting_applications_without_a_window_manager][Display
manager#Starting applications without a window manager]].

** [[https://wiki.archlinux.org/index.php/Xmodmap][xmodmap]]    :blog:


*Note:* /xmodmap/ settings are reset by /setxkbmap/, which not only
alters the alphanumeric keys to the values given in the map, but also
resets all other keys to the startup default.
[[http://wiki.linuxquestions.org/wiki/Configuring_keyboards][[1]]]

/xmodmap/ is a utility for modifying keymaps and pointer button mappings
in [[/index.php/Xorg][Xorg]].

/xmodmap/ is not directly related to
[[/index.php/X_KeyBoard_extension][X KeyBoard extension]] (XKB), as it
uses different (pre-XKB) ideas on how /keycodes/ are processed within X.
Generally, it is only recommended for the simplest tasks. See
[[/index.php/X_KeyBoard_extension][X KeyBoard extension]] for advanced
layout configuration.

*** Contents

- [[#Introduction][1 Introduction]]
- [[#Installation][2 Installation]]
- [[#Keymap_table][3 Keymap table]]
- [[#Custom_table][4 Custom table]]

   -  [[#Activating_the_custom_table][4.1 Activating the custom table]]
   -  [[#Test_changes][4.2 Test changes]]

- [[#Modifier_keys][5 Modifier keys]]
- [[#Reverse_scrolling][6 Reverse scrolling]]
- [[#Templates][7 Templates]]

   -  [[#Spanish][7.1 Spanish]]
   -  [[#Turn_CapsLock_into_Control.2C_and_LeftControl_into_Hyper][7.2
      Turn CapsLock into Control, and LeftControl into Hyper]]
   -  [[#Switch_every_number_key_N_with_Shift-N_and_vice-versa.2C_for_Croatian_layout][7.3
      Switch every number key N with Shift-N and vice-versa, for
      Croatian layout]]

- [[#See_also][8 See also]]

*** Introduction

There are two types of keyboard values in [[/index.php/Xorg][Xorg]]:
/keycodes/ and /keysyms/.

-  keycode  :: The /keycode/ is the numeric representation received by
   the kernel when a key or a mouse button is pressed.
-  keysym :: The /keysym/ is the value assigned to the /keycode/. For
   example, pressing =A= generates the =keycode 73=, which is mapped to
   the =keysym 0×61=, which matches =A= in the
   [[https://en.wikipedia.org/wiki/ASCII][ASCII table]].
   The /keysyms/ are managed by [[/index.php/Xorg][Xorg]] in a table of
   /keycodes/ defining the /keycode/-/keysym/ relations, which is called
   the [[#Keymap_table][keymap table]]. This can be shown by running
   =xmodmap=.

*** Installation

/xmodmap/ can be [[/index.php/Pacman][installed]] through the
[[https://www.archlinux.org/packages/?name=xorg-xmodmap][xorg-xmodmap]]
package from the [[/index.php/Official_repositories][official
repositories]].

Optionally, install
[[https://www.archlinux.org/packages/?name=xkeycaps][xkeycaps]], which
is a graphical front-end to /xmodmap/.

*** Keymap table

Print the current keymap table formatted into expressions:

#+BEGIN_EXAMPLE
    $ xmodmap -pke
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [...]
    keycode  57 = n N
    [...]
#+END_EXAMPLE

Each /keycode/ is followed by the /keysym/ it is mapped to. The above
example indicates that the /keycode/ =57= is mapped to the lowercase
=n=, while the uppercase =N= is mapped to /keycode/ =57= plus =Shift=.

Each /keysym/ column in the table corresponds to a particular
combination of modifier keys:

1. =Key=
2. =Shift+Key=
3. =mode_switch+Key=
4. =mode_switch+Shift+Key=
5. =AltGr+Key=
6. =AltGr+Shift+Key=

Not all /keysyms/ have to be set, but to assign only a latter /keysym/,
use the =NoSymbol= value.

To see which /keycode/ corresponds to a key, see
[[/index.php/Extra_keyboard_keys#In_Xorg][Extra keyboard keys#In Xorg]]
for details on the /xev/ utility.

*Tip:* There are predefined descriptive /keysyms/ for multimedia keys,
e.g. =XF86AudioMute= or =XF86Mail=. These /keysyms/ can be found in
=/usr/include/X11/XF86keysym.h=. Many multimedia programs are designed
to work with these /keysyms/ out-of-the-box, without the need to
configure any third-party application.

Note that xmodmap is influenced by xkbd settings, so all eight keysym
are available for the us(intl) xkbd layout but not for the default us
(it is missing the ralt_switch symbol defined in level3). To have all 8
keysyms available you should configure the /(intl)/ variant of the
keyboard from xorg.conf or add, using us layout as an example,
=setxkbmap -layout 'us(intl)'= before calling xmodmap.

*** Custom table

To create a key map (i.e. =~/.Xmodmap=):

#+BEGIN_EXAMPLE
    $ xmodmap -pke > ~/.Xmodmap
#+END_EXAMPLE

To test the changes:

#+BEGIN_EXAMPLE
    $ xmodmap ~/.Xmodmap
#+END_EXAMPLE

**** Activating the custom table

With [[/index.php/GDM][GDM]], [[/index.php/XDM][XDM]],
[[/index.php/KDM][KDM]] or [[/index.php/LightDM][LightDM]] there is no
need to source =~/.Xmodmap=. For [[/index.php/Startx][startx]], use:

#+BEGIN_EXAMPLE
    ~/.xinitrc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    if [ -s ~/.Xmodmap ]; then
        xmodmap ~/.Xmodmap
    fi
#+END_EXAMPLE

Alternatively, edit the global startup script =/etc/X11/xinit/xinitrc=.

**** Test changes

To make temporary changes:

#+BEGIN_EXAMPLE
    $ xmodmap -e "keycode  46 = l L l L lstroke Lstroke lstroke"
    $ xmodmap -e "keysym a = e E"
#+END_EXAMPLE

*** Modifier keys

/xmodmap/ can also be used to override
[[https://en.wikipedia.org/wiki/Modifier_key][modifier keys]], e.g. to
swap =Control= and =Super= (the
[[https://en.wikipedia.org/wiki/Windows_key][Windows keys]]).

Before assignment the modifier keys need to be empty. =!= is a comment,
so only the modifiers =Control= and =Mod4= get cleared in the following
example. Then the /keysyms/ =Control_L=, =Control_R=, =Super_L= and
=Super_R= are assigned to the opposite modifier. Assigning both left and
right to the same modifier means that both keys are treated the same
way.

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [...]
    !clear Shift
    !clear Lock
    clear Control
    !clear Mod1
    !clear Mod2
    !clear Mod3
    clear Mod4
    !clear Mod5
    !add Shift   = Shift_L Shift_R
    !add Lock    = Caps_Lock
    add Control = Super_L Super_R
    !add Mod1    = Alt_L Alt_R
    !add Mod2    = Mode_switch
    !add Mod3    =
    add Mod4    = Control_L Control_R
    !add Mod5    =
#+END_EXAMPLE

*Note:* The example assumes that the =Control_L= and =Control_R= keysyms
were assigned to the =Control= modifier, and =Super_L= and =Super_R=
keysyms to the =Mod4= modifier. If you get the following error message
=X Error of failed request:  BadValue (integer parameter out of range for operation)=,
you will need to adapt accordingly. Running =xmodmap= produces a list of
modifiers and keys that are assigned to them.

The following example modifies =CapsLock= to =Control=, and
=Shift+CapsLock= to =CapsLock=:

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    clear lock
    clear control
    add control = Caps_Lock Control_L Control_R
    keycode 66 = Control_L Caps_Lock NoSymbol NoSymbol
#+END_EXAMPLE

*** Reverse scrolling

The
[[http://who-t.blogspot.com/2011/09/natural-scrolling-in-synaptics-driver.html][natural
scrolling]] feature available in OS X Lion (mimicking smartphone or
tablet scrolling) can be
[[https://bbs.archlinux.org/viewtopic.php?id=126258][replicated]] with
/xmodmap/. Since the synaptics driver uses the buttons 4/5/6/7 for
up/down/left/right scrolling, you simply need to swap the order of how
the buttons are declared in =~/.Xmodmap=:

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    pointer = 1 2 3 5 4 7 6 8 9 10 11 12
#+END_EXAMPLE

Then update /xmodmap/:

#+BEGIN_EXAMPLE
    $ xmodmap ~/.Xmodmap
#+END_EXAMPLE

*** Templates

**** Spanish

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    keycode  24 = a A aacute Aacute ae AE ae
    keycode  26 = e E eacute Eacute EuroSign cent EuroSign
    keycode  30 = u U uacute Uacute downarrow uparrow downarrow
    keycode  31 = i I iacute Iacute rightarrow idotless rightarrow
    keycode  32 = o O oacute Oacute oslash Oslash oslash
    keycode  57 = n N ntilde Ntilde n N n
    keycode  58 = comma question comma questiondown dead_acute dead_doubleacute dead_acute
    keycode  61 = exclam section exclamdown section dead_belowdot dead_abovedot dead_belowdot
    !Maps the Mode key to the Alt key
    keycode 64 = Mode_switch
#+END_EXAMPLE

**** Turn CapsLock into Control, and LeftControl into Hyper

Laptop users may prefer having =CapsLock= as =Control=. The =Left Hyper=
key can be used as a modifier.

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    clear      lock
    clear   control
    clear      mod1
    clear      mod2
    clear      mod3
    clear      mod4
    clear      mod5
    keycode      37 = Hyper_L
    keycode      66 = Control_L
    add     control = Control_L Control_R
    add        mod1 = Alt_L Alt_R Meta_L
    add        mod2 = Num_Lock
    add        mod3 = Hyper_L
    add        mod4 = Super_L Super_R
    add        mod5 = Mode_switch ISO_Level3_Shift
#+END_EXAMPLE

**** Switch every number key N with Shift-N and vice-versa, for Croatian
layout

Should work fine for layouts similar to Croatian as well.

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    keycode 10 = exclam 1 1 exclam asciitilde dead_tilde asciitilde
    keycode 11 = quotedbl 2 2 quotedbl dead_caron caron dead_caron
    keycode 12 = numbersign 3 3 numbersign asciicircum dead_circumflex asciicircum
    keycode 13 = dollar 4 4 dollar dead_breve breve dead_breve
    keycode 14 = percent 5 5 percent degree dead_abovering degree
    keycode 15 = ampersand 6 6 ampersand dead_ogonek ogonek dead_ogonek
    keycode 16 = slash 7 7 slash grave dead_grave grave
    keycode 17 = parenleft 8 8 parenleft dead_abovedot abovedot dead_abovedot
    keycode 18 = parenright 9 9 parenright dead_acute apostrophe dead_acute
    keycode 19 = equal 0 0 equal dead_doubleacute doubleacute dead_doubleacute
#+END_EXAMPLE

*** See also

- [[http://www.x.org/archive/current/doc/man/man1/xmodmap.1.xhtml][Current
   man page]] at X.Org Foundation
- [[http://cweiske.de/howto/xmodmap/allinone.html][Multimediakeys with
   .Xmodmap HOWTO]] by Christian Weiske
- [[http://dev-loki.blogspot.com/2006/04/mapping-unsupported-keys-with-xmodmap.html][Mapping
   unsupported keys with xmodmap]] by Pascal Bleser
- [[http://wiki.linuxquestions.org/wiki/List_of_Keysyms_Recognised_by_Xmodmap][List
   of Keysyms Recognised by Xmodmap]] on
   [[http://linuxquestions.org][LinuxQuestions]]

** [[http://blog.sina.com.cn/s/blog_578fb7710101m90d.html][ubuntu安装fcitx五笔拼音输入法 ]]    :blog:

根据网络资料整理，参考：
http://gongstring.iteye.com/blog/1392151
http://cyanman.blog.163.com/blog/static/1525020820111196433790/

第一步：缷载ibus
sudo apt-get remove ibus
重启ubuntu

第二步：安装fcitx五笔拼音
sudo add-apt-repository ppa:wengxt/fcitx-nightly
sudo apt-get update
sudo apt-get install im-switch fcitx
sudo apt-get install fcitx-table-wbpy
sudo im-switch -s fcitx
im-switch -s fcitx
重启ubuntu

其它参考：
     1，不希望使用一大堆用不着的输入法，可以关闭它：
        $sudo gedit /usr/share/fcitx/data/tabels.conf
     把里面不要的输入法整段删除，至于双拼可以在下面说的config 里关闭
     2，在打字时要输入,.号经常按不出来，可以这样：
     ~/.fcitx 目录下有一个 config 文件（启动至少一次fcitx 才会自动建立）可以配置翻页键把里面的 ,. 二个删除，不然在出联想时打不出,. 号
     3，不想让它一直显示在那，可以这样：
     ~/.fcitx 目录下有一个 config 文件可以配置 代码:
     主窗口隐藏模式=1
     4，在英文local 下 fcitx 打出的字全方块，可以这样：
     修改上面说的这个config 里的 代码:
     显示字体(中)=字体名
     5，使用ctrl+左shift键可以切换输入方案
     6，其它应用技巧可以到fcitx的主页下载其最新版的使用说明书（pdf文档）。
中文简繁转换：ctrl+shift+f

** [[http://blog.csdn.net/mdx20072419/article/details/8060432][sudo: no valid sudoers sources found, quitting]]    :blog:

我的环境实在VMwa 下装了一个Ubuntu，今天在Ubuntu添加了一个用户，

adduser mdx



添加用户成功，可是我在使用sudo安装软件的时候提示：

[[mailto:mdx@ubuntu:/home/farsight$][mdx@ubuntu:/home/farsight$]] sudo
apt-get install ssh
 [sudo] password for mdx:
 mdx is not in the sudoers file.  This incident will be reported.

上网查了一些解决办法，千篇一律：

1>、进入超级用户模式。 2>、添加文件的写权限。也就是输入命令"chmod 0777
/etc/sudoers"。

 3>、编辑/etc/sudoers文件，找到这一行："root ALL=(ALL)
ALL"在这一行下面添加"xxx ALL=(ALL)
ALL"(这里的xxx是你的用户名，我这里是mdx)，然后保存退出。

本以为大功告成，可是再次使用sudo时，又出现了另一个问题：

sudo: /etc/sudoers is mode 0777, should be 0440

sudo: no valid sudoers sources found, quitting



这让给我很纠结，想用sudo去更改权限，sudo还不能用，想su切换到root用户，可是我的root没设密码，还没激活。

参考了一些资料，最终解决，先把解决办法共享一下：

重启Ubuntu，按F12进入Recovery mode

在Recovery Menu选择root

这样就可以使用root用户了，然后把/etc/sudoers属性改回来 "chmod 0440
/etc/sudoers"。

That's OK！

这里你也可以给root设置密码，激活root

** [[http://tieba.baidu.com/p/3006415003?bd_source_light=1563095][玩ubuntu系统修改sudoers 错误了，没用visudo]]    :blog:

1.错误提示：sudo: no valid sudoers sources found,quitting
解决办法：(1)重启系统，选择(recovery mode/恢复模式)引导项;
(2)在Recovery Menu页面选择root后回车;
(3)设置或者撤销/etc/sudoers文件的权限,命令如下：
chmod u-w /etc/sudoers
chmod 440 /etc/sudoers
2、错误提示：chomd :changing permissions of 'sudoers' :Read-only file system解决办法：利用 mount 指令解决 Read-only file system的问题 mount -o remount rw /
3.修改 /etc/sudoers 时，用 sudo visudo 命令修改，就不用先改权限了。修改后按Ctrl+x，选择Y，输入文件名，回车；

** [[http://blog.csdn.net/hustrains/article/details/8652098][ubuntu如何设置默认程序打开方式]]    :blog:

1   简单的方法：
右键点击所需要的开的文件，选择“属性” ，“打开方式” 即可以选择默认打开的程序，这是最简便的设定方法！！

2  复杂一点的方法：
从总体上讲

/etc/gnome/defaults.list 保存了全局的打开方式

/.local/share/applications/mimeapps.list 保存了个人的打开方式

当两着不一致是，优先采用局部的个人设置。

例如，ubuntu12.04下视频文件默认是用电影播放机打开的，如果你想要改成用smplayer来打开的话，可以按照以下步聚来进行：

1.进入/etc/gnome目录
  命令 ：cd /etc/gnome

2.复制要改变打开方式的那些内容行到mimeapps.list文件
 命令 grep “totem” defaults.list >> ~/.local/share/applications/mimeapps.list

3.进入~/.local/share/applications目录
 命令 cd ~/.local/share/applications

4.编缉mimeapps.list文件
 命令： sudo vim mimeapps.list

5.在vim中执行
 命令：%s/totem/smplayer/g

6.然后执行保存
 命令：wq

7.完成

想要改其它类型的可照此类推，比如我就把音频文件换成了audacious来打开，文本文件用gvim来默认打开。

** [[http://54rd.net/html/2015/server_0122/30.html][ubuntu分屏终端terminator好用的快捷键]]    :blog:

在ubuntu下的默认终端为terminal，但terminator会更好用一些，操作设置会更方便。使用常用快捷键：新增标签页：Ctrl
+ Shift + T 关闭标签页：Ctrl + Shift + W 左右分屏：Ctrl + Shift + E
上下分屏：Ctrl + Shi

在ubuntu下的默认终端为terminal，但terminator会更好用一些，操作设置会更方便。
 安装命令直接使用apt-get安装：


$sudo apt-get install terminator


 安装完成后，可以根据自己喜好修改颜色，可支持横竖切屏，支持多标签。

 [[http://54rd.net/uploadfile/2015/0122/20150122020858396.png]]

 使用常用快捷键：

 新增标签页：Ctrl + Shift + T
 关闭标签页：Ctrl + Shift + W
 左右分屏：Ctrl + Shift + E
 上下分屏：Ctrl + Shift + O
 复制：Ctrl + Shift + C
 粘贴：Ctrl + Shift + V
 清屏幕：Ctrl + Shift + G

** [[https://www.haskell.org/cabal/][The Haskell Cabal]]    :blog:

Cabal is a system for building and packaging Haskell libraries and programs. It defines a common interface for package authors and distributors to easily build their applications in a portable way. Cabal is part of a larger infrastructure for distributing, organizing, and cataloging Haskell libraries and programs.

Specifically, the Cabal describes what a Haskell package is, how these packages interact with the language, and what Haskell implementations must to do to support packages. The Cabal also specifies some infrastructure (code) that makes it easy for tool authors to build and distribute conforming packages.

The Cabal is only one contribution to the larger goal. In particular, the Cabal says nothing about more global issues such as how authors decide where in the module name space their library should live; how users can find a package they want; how orphan packages find new owners; and so on.

** [[http://blog.csdn.net/wudiyi815/article/details/7473097][ Linux查看端口使用状态、关闭端口方法]]    :blog:

前提：首先你必须知道，端口不是独立存在的，它是依附于进程的。某个进程开启，那么它对应的端口就开启了，进程关闭，则该端口也就关闭了。下次若某个进程再次开启，则相应的端口也再次开启。而不要纯粹的理解为关闭掉某个端口，不过可以禁用某个端口。

1. 可以通过"netstat -anp" 来查看哪些端口被打开。
（注：加参数'-n'会将应用程序转为端口显示，即数字格式的地址，如：nfs->2049, ftp->21，因此可以开启两个终端，一一对应一下程序所对应的端口号）
2. 然后可以通过"lsof -i:$PORT"查看应用该端口的程序（$PORT指对应的端口号）。或者你也可以查看文件/etc/services，从里面可以找出端口所对应的服务。
（注：有些端口通过netstat查不出来，更可靠的方法是"sudo nmap -sT -O localhost"）
3. 若要关闭某个端口，则可以：
1)通过iptables工具将该端口禁掉，如：
"sudo iptables -A INPUT -p tcp --dport $PORT -j DROP"
"sudo iptables -A OUTPUT -p tcp --dport $PORT -j DROP"
2)或者关掉对应的应用程序，则端口就自然关闭了，如：
"kill -9 PID" (PID：进程号)
如：    通过"netstat -anp | grep ssh"
有显示：    tcp 0 127.0.0.1:2121 0.0.0.0:* LISTEN 7546/ssh
则：    "kill -9 7546"

（可通过"chkconfig"查看系统服务的开启状态）

** [[http://www.cnblogs.com/benio/archive/2010/09/15/1826728.html][Linux查看程序端口占用情况]]    :blog:

今天发现服务器上Tomcat 8080端口起不来，老提示端口已经被占用。

使用命令：

ps -aux | grep tomcat

发现并没有8080端口的Tomcat进程。

使用命令：netstat --apn

查看所有的进程和端口使用情况。发现下面的进程列表，其中最后一栏是PID/Program
name

[[http://www.blogjava.net/images/blogjava_net/hankchen/WindowsLiveWriter/Linux_7E54/clip_image002_2.jpg][[[http://www.blogjava.net/images/blogjava_net/hankchen/WindowsLiveWriter/Linux_7E54/clip_image002_thumb.jpg]]]]

发现8080端口被PID为9658的Java进程占用。

进一步使用命令：ps -aux | grep java，或者直接：ps -aux | grep pid 查看

[[http://www.blogjava.net/images/blogjava_net/hankchen/WindowsLiveWriter/Linux_7E54/clip_image004_2.jpg][[[http://www.blogjava.net/images/blogjava_net/hankchen/WindowsLiveWriter/Linux_7E54/clip_image004_thumb.jpg]]]]

就可以明确知道8080端口是被哪个程序占用了！然后判断是否使用KILL命令干掉！


方法二：直接使用 netstat   -anp   |   grep portno
即：netstat --apn | grep 8080

** [[http://www.ibm.com/developerworks/cn/linux/l-roadmap/part8/][ Windows 到 Linux 之旅: 第 8 部分. 备份与恢复]]    :blog:

/Linux 备份与恢复速成指南/

IBM 电子商务架构师 Chris Walden 将通过他在 developerWorks
上发表的九篇系列文章来指导您如何在 Linux 环境中运用您的 Windows
操作技巧。本部分将考察 Linux
系统上的内容，同时在考虑到恢复和安全的情况下，计划并实现常规备份。

[[#authorN1001C][Chris Walden]]
([[mailto:cmwalden@us.ibm.com?subject=第%208%20部分.%20备份与恢复][cmwalden@us.ibm.com]]),
电子商务架构师

[[#close][关闭 [x]]]

Chris Walden 是德克萨斯州奥斯汀的 IBM Developer Relations Technical
Consulting（也称为
/[[http://www.ibm.com/developerworks/linux/library/i-slayers.html?S_TACT=105AGX52&S_CMP=cn-a-l][dragonslayers]]/）的一名电子商务架构师，该公司为
IBM 商业伙伴提供教育、实现和咨询。他致力于 Linux
相关工作，一有机会就向身边的人宣传 Linux
的种种好处。除了完成他的架构师的职责之外，他还精通 Linux
基础设施服务器的各个领域，包括混合平台用户环境下的文件、打印以及其他应用服务等。Chris
有 10 年的计算机行业经验，从现场支持到 Web
应用开发和顾问，各个领域他都曾涉足。您可以通过电子邮件
[[mailto:cmwalden@us.ibm.com][cmwalden@us.ibm.com]] 与 Chris 联系。




2004 年 1 月 01 日

- [[#toggle][[[//www.ibm.com/i/c.gif]]]]内容

   -  [[#IDAULSY][确定策略]]
   -  [[#IDACMSY][确定要备份的内容]]
   -  [[#IDAPNSY][备份工具]]
   -  [[#IDA0VOY][dump 和 restore]]
   -  [[#IDAYXOY][使用 dump 执行备份]]
   -  [[#IDAC0OY][使用 restore 来执行还原]]
   -  [[#IDAC3OY][dump 与 tar]]
   -  [[#IDAB4OY][其他工具]]
   -  [[#IDAG5OY][商业化备份产品]]
   -  [[#IDAEBPY][前瞻和回顾]]
   -  [[#resources][参考资料]]
   -  [[#icomments][评论]]

Linux
是一个稳定而可靠的环境。但是任何计算系统都有无法预料的事件，比如硬件故障。拥有关键配置信息的可靠备份是任何负责任的管理计划的组成部分。在
Linux
中可以通过各种各样的方法来执行备份。所涉及的技术从非常简单的脚本驱动的方法，到精心设计的商业化软件。备份可以保存到远程网络设备、磁带驱动器和其他可移动媒体上。备份可以是基于文件的或基于驱动器映像的。可用的选项很多，您可以混合搭配这些技术，为您的环境设计理想的备份计划。

*** 确定策略

可以采用许多不同的方法来备份系统。欲了解关于这方面的一些信息，您可以阅读本文结尾处
[[#resources][参考资料]] 中列出的“Introduction to Backing Up and
Restoring Data”一文。

所备份的内容很大程度上取决于您备份它们的理由。您是否试图从严重的故障（比如硬盘驱动器问题）中恢复？您是否想归档以便能在需要时恢复旧的文件？您计划从一个冷系统和还原着手，还是从一个预加载的备用系统着手？

--------------

[[#ibm-pcon][回页首]]

*** 确定要备份的内容

在备份和还原系统时，Linux 基于文件的性质成了一个极大的优点。在 Windows
系统中，注册表与系统是非常相关的。配置和软件安装不仅仅是将文件放到系统上。因此，还原系统就需要有能够处理
Windows 这种特性的软件。在 Linux
中，情况就不一样了。配置文件是基于文本的，并且除了直接处理硬件时以外，它们在很大程度上是与系统无关的。硬件驱动程序的现代方法是，使它们以动态加载的模块的形式可用，这样内核就变得更加与系统无关。不同于让备份必须处理操作系统如何安装到系统和硬件上的复杂细节，Linux
备份处理的是文件的打包和解包。

一般情况下，以下这些目录是需要备份的：

- */etc*

   包含所有核心配置文件。这其中包括网络配置、系统名称、防火墙规则、用户、组，以及其他全局系统项。
- */var*
    包含系统守护进程（服务）所使用的信息，包括 DNS 配置、DHCP
   租期、邮件缓冲文件、HTTP 服务器文件、db2 实例配置，等等。
- */home*

   包含所有用户的默认用户主目录。这包括他们的个人设置、已下载的文件和用户不希望失去的其他信息。
- */root*
    是根（root）用户的主目录。
- */opt*
    是安装许多非系统文件的地方。IBM 软件就安装在这里。OpenOffice、JDK
   和其他软件在默认情况下也安装在这里。

有些目录是应该考虑 /不/备份的。

- */proc*

   应该永远不要备份这个目录。它不是一个真实的文件系统，而是运行内核和环境的虚拟化视图。它包括诸如
   /proc/kcore
   这样的文件，这个文件是整个运行内存的虚拟视图。备份这些文件只是在浪费资源。
- */dev*
    包含硬件设备的文件表示。如果计划还原到一个空白的系统，那就可以备份
   /dev。然而，如果计划还原到一个已安装的 Linux 系统，那么备份 /dev
   是没有必要的。

其他目录包含系统文件和已安装的包。在服务器环境中，这其中的许多信息都不是自定义的。大多数自定义都发生在
/etc 和/home 目录中。不过出于完整性的考虑，您可能希望备份它们。

在生产环境中，我希望确保数据不会丢失，因而我会备份除 /proc
目录之外的整个系统。如果最担心用户和配置，我会仅备份 /etc、/var、/home
和 /root 目录。

--------------

[[#ibm-pcon][回页首]]

*** 备份工具

正如前面提到过的， Linux
备份在很大程度上就是打包和解包文件。这允许使用现有的系统实用工具和脚本来执行备份，而不必购买商业化的软件包。在许多情况下，这类备份将是足够的，并且为管理员提供了极大的控制能力。备份脚本可以使用
=cron= 命令来自动化，这个命令控制 Linux 中预定的事件。

**** tar

=tar= 是一个已移植到 Linux 中的经典 UNIX 命令。 =tar= 是 *t*ape
*ar*chive（磁带归档）的缩写，最初设计用于将文件打包到磁带上。如果您下载过
Linux 源代码，或许已经碰到过 tar
文件。这是一个基于文件的命令，它本质上是连续地、首尾相连地堆放文件。

使用 =tar=
可以打包整个目录树，这使得它特别适合用于备份。归档文件可以全部还原，或从中展开单独的文件和目录。备份可以保存到基于文件的设备或磁带设备上。文件可以在还原时重定向，以便将它们重新放到一个与最初保存它们的目录（或系统）不同的目录（或系统）。
=tar= 是与文件系统无关的。它可以使用在 ext2、ext3、 jfs、Reiser
和其他文件系统上。

使用 =tar= 非常类似于使用诸如 PKZip
这样的文件实用工具。只需将它指向一个目的（可以是文件或设备），然后指定您想要打包的文件。您可以通过标准的压缩类型来动态压缩归档文件，或指定一个自己选择的外部压缩程序。要通过
bzip2 压缩或解压缩文件，可使用 = tar -z= 命令。

要使用 = tar= 来把除 /proc 目录之外的整个文件系统备份到 SCSI 磁带设备：

#+BEGIN_EXAMPLE
    tar -cpf /dev/st0 / --exclude=/proc
#+END_EXAMPLE

在上面的例子中， =-c= 开关表示归档文件正在被创建。 =-p=
开关表示我们希望保留文件许可权限，这对良好的备份来说是很关键的。 =-f=
开关指向该归档文件的文件名。在本例中，我们使用的是原始磁带设备
/dev/st0。/
表示我们想要备份的内容。既然我们想要备份整个系统，因此把这个开关指定为根（root）。当把
=tar= 指向一个目录（以 / 结尾）时，它会自动递归。最后，我们排除了 /proc
目录，因为它没有包含需要保存的任何内容。如果单盒磁带容纳不下这个备份，我们需要添加
=-M= 开关（本例中没有显示）以进行多卷备份。

*** 以防万一

不要忘了 Linux 是区分大小写的。例如， =tar=
命令应该总是以小写的形式执行。命令行开关可以是大写、小写或大小写的混合。例如，
=-t= 和 =-T=
执行不同的功能。文件或目录名称可以混合使用大小写，而且就像命令和命令行开关一样，是区分大小写的。

要还原一个或多个文件，可以使用带提取开关（ =-x= ）的 =tar= 命令：

#+BEGIN_EXAMPLE
    tar -xpf /dev/st0 -C /
#+END_EXAMPLE

这里的 =-f= 开关同样指向归档文件， =-p= 开关表明我们想要还原归档的权限。
=-x= 开关表明从归档中提取文件。 =-C /= 表明我们想要让还原从 / 开始。
=tar= 通常还原到运行这个命令的目录。 =-C= 开关使我们的当前目录不再相关。

您可能会经常使用的另外两个 =tar= 命令是 =-t= 和 =-d= 开关。 =-t=
开关列出某个归档文件的内容。 =-d=
开关将归档文件的内容与系统上的当前文件作比较。

为便于操作和编辑，您可以将想要归档的文件和目录放进一个文本文件中，然后在命令行通过
=-T=
开关引用这个文本文件。这些文件和目录可以与命令行上列出的其他目录结合起来。下面的命令行备份
MyFiles 中列出的所有文件和目录、/ 根目录和 /tmp 目录中的所有 iso 文件。

#+BEGIN_EXAMPLE
    tar -cpf /dev/st0 -T MyFiles /root /tmp/*.iso
#+END_EXAMPLE

文件列表只是一个文本文件，其中列出文件或目录。下面是一个例子：

#+BEGIN_EXAMPLE
    /etc


    /var


    /home


    /usr/local


    /opt
#+END_EXAMPLE

请注意 =tar -T= （或 =files-from=
）命令不能接受通配符。文件必须明确地列出。上面的例子展示了一种单独地引用文件的方法。您还可以执行脚本来搜索系统，然后建立一个列表。下面就是这样一个脚本的例子：

#+BEGIN_EXAMPLE
    #!/bin/sh


    cat MyFiles > TempList


    find /usr/share -iname *.png >> TempList


    find /tmp -iname *.iso >> TempList


    tar -cpzMf /dev/st0 -T TempList
#+END_EXAMPLE

上面的脚本首先将 MyFiles 中的所有现有文件列表复制到
TempList。然后它执行两个 =find=
命令来搜索文件系统中匹配某个模式的文件，并将它们附加到
TempList。第一次是搜索 /usr/share 目录树中以 =.png=
结尾的所有文件。第二次是搜索 /tmp 目录树中以 =.iso=
结尾的所有文件。在建立好列表之后， =tar= 然后在文件设备 /dev/st0
（第一个 SCSI 磁带设备）上创建 一个新的归档文件，该文件使用 g *z*ip
格式来压缩，并保留所有文件权限。该归档文件将跨越多个卷。要归档的文件的名称将从
TempList 文件中提取。

还可以使用脚本来执行更精细的操作，比如增量备份。Gerhard Mourani 在他的
/Securing and Optimizing Linux/
一书中给出了一个优秀的脚本，您可在本文结尾处的
[[#resources][参考资料]]中找到关于这本书的信息。

也可以编写脚本来还原文件，虽然还原通常是手动进行的。正如上面提到过的，用于提取文件的
=-x= 开关代替了 =-c=
开关。可以还原整个归档文件，或者还原指定的个别文件或者目录。使用通配符来引用归档文件中的文件是可以的。还可以使用开关来转储和还原。

--------------

[[#ibm-pcon][回页首]]

*** dump 和 restore

=dump= 可以执行类似 =tar= 的功能。然而， =dump=
倾向于考虑文件系统而不是个别的文件。下面是引自 dump
手册文件中的内容：“dump 检查 ext2
文件系统上的文件，并确定哪些文件需要备份。这些文件将出于安全保护而被复制到给定的磁盘、磁带或其他存储媒体上......大于输出媒体容量的转储将被划分到多个卷。在大多数媒体上，容量是通过一直写入直至返回一个
end-of-media 标记来确定的。”

配合 =dump= 的程序是 =restore= ，它用于从转储映像还原文件。

=restore=
命令执行转储的逆向功能。可以首先还原文件系统的完全备份，而后续的增量备份可以在已还原的完全备份之上覆盖。可以从完全或部分备份中还原单独的文件或者目录树。

=dump= 和 =restore=
都能在网络上运行，因此您可以通过远程设备进行备份或还原。 =dump= 和
=restore= 使用磁带驱动器和提供广泛选项的文件设备。然而，两者都仅限用于
ext2 和 ext3 文件系统。如果使用的是 JFS、Reiser
或者其他文件系统，您将需要其他的实用工具，比如 =tar= 。

--------------

[[#ibm-pcon][回页首]]

*** 使用 dump 执行备份

使用 =dump= 执行备份是相当简单的。下面的命令执行一个完全 Linux
备份，它把所有 ext2 和 ext3 文件系统备份到一个 SCSI 磁带设备。

#+BEGIN_EXAMPLE
    dump 0f /dev/nst0 /boot


    dump 0f /dev/nst0 /
#+END_EXAMPLE

在这个例子中，系统中有两个文件系统。一个用于 /boot，另一个用于 */*
，这是常见的配置。它们必须在执行备份时单独地引用。 /dev/nst0 引用第一个
SCSI
磁带驱动器，不过是以非重绕的模式引用。这样确保各个卷在磁带上一个接一个地排列。

=dump= 的一个有趣特性是其内置的增量备份功能。在上面的例子中， *0* 表示 0
级或基本级备份。这是完全系统备份，您要定期执行以保存整个系统。对于后续的备份，您可以使用其他数字（1-9）来代替
0，以改变备份级别。1 级备份会保存自从执行 0
级备份以来更改过的所有文件。2 级备份会保存自从执行 1
级备份以来更改过的所有文件，以此类推。使用 =tar=
和脚本可以执行相同的功能，但要求脚本创建人员提供一种机制来确定上次备份是何时执行的。
=dump=
具有它自己的机制，即它在执行备份时会输出一个更新文件（/etc/dumpupdates）。这个更新文件将在每次执行
0 级备份时被重设。后续级别的备份会保留它们的标记，直至执行另一次 0
级备份。如果您在执行基于磁带的备份， =dump= 会自动跟踪多个卷。

*** 跳过文件

标记将被 =dump= 跳过的文件和目录是可以做到的。实现此目的的命令是
=chattr= ，它改变 ext2 和 ext3 文件系统上的扩展属性。

chattr +d <filename>

上面的命令向文件添加一个标记，让 =dump= 在执行备份时跳过该文件。

--------------

[[#ibm-pcon][回页首]]

*** 使用 restore 来执行还原

要还原使用 =dump= 保存的信息，可以使用 =restore= 命令。像 =tar= 一样，
=dump= 能够列出（ =-t= ）归档文件的内容，并与当前文件作比较（ =-C=
）。使用 =dump=
時必须小心的地方是还原数据。有两种非常不同的还原方法，您必须使用正确的方法才能获得可预测的结果。

**** 重建 (-r)

记住，在设计 =dump=
时考虑得更多的是文件系统，而不是单独的文件。因此，存在两种不同的文件还原风格。要重建一个文件系统，可使用
=-r=
命令行开关。设计重建的目的是为了能在空文件系统上操作，并将它还原为已保存的状态。在执行重建之前，您应该已经创建、格式化和装载（mount）了该文件系统。不应该对包含文件的文件系统执行重建。

下面是使用上面执行的转储来执行完全重建的例子。

#+BEGIN_EXAMPLE
    restore -rf /dev/nst0
#+END_EXAMPLE

上面这个命令需要针对要还原的每个文件系统分别执行。

在需要的时候，可以重复这个过程来添加增量备份。

**** 提取 (-x)

如果需要使用单独的文件而不是使用整个文件系统，您必须使用 =-x=
开关来提取它们。例如，要仅从我们的磁带备份中提取 /etc
目录，可使用以下命令：

#+BEGIN_EXAMPLE
    restore -xf /dev/nst0 /etc
#+END_EXAMPLE

**** 交互式还原 (-i)

=restore= 提供的另外一个特性是交互式模式。使用命令：

#+BEGIN_EXAMPLE
    restore -if /dev/nst0
#+END_EXAMPLE

将把您置于交互式 shell
中，同时还显示了包含在该归档文件中的项。键入“help”将会显示一个命令列表。然后您就可以浏览并选择希望提取的项。务必记住，您提取的任何文件都将进入当前目录。

--------------

[[#ibm-pcon][回页首]]

*** dump 与 tar

=dump= 和 =tar= 都有一批拥护者。两者都各有优点和缺点。如果您运行的是除
ext2 或 ext3 之外的任何文件系统，那么 =dump=
就对您不可用。然而如果不是这种情况，那么只需最少的脚本就能运行 =dump=
，并且 =dump= 还具有可用于帮助还原的交互式模式。

我倾向于使用 =tar=
，因为我喜欢编写脚本来获得额外的控制级别。此外还有用于操作 .tar
文件的多平台工具。

--------------

[[#ibm-pcon][回页首]]

*** 其他工具

在 Linux
中，任何能够复制文件的程序都可以用来执行某种程度的备份。有人就使用
=cpio= 和 =dd= 来执行备份 。 =cpio= 是又一个与 =tar=
差不多的打包实用工具，但使用得不太普遍。 =dd=
是一个文件系统复制实用工具，它产生文件系统的二进制副本。 =dd =
还可用于产生硬盘驱动器的映像，类似于使用诸如 Symantec 的 Ghost
这样的产品。然而， =dd=
不是基于文件的，因此您只能使用它来将数据还原到完全相同的硬盘驱动器分区。

--------------

[[#ibm-pcon][回页首]]

*** 商业化备份产品

可用于 Linux
的商业化备份产品有很多。商业化产品一般提供了便利的界面和报告系统，而在使用诸如
=dump= 和 =tar=
这样的工具时，您必须自食其力。商业化产品很广泛，通常提供大量的特性。使用商业软件包的最大好处是，有一个预先建立的用于处理备份的策略，您可以立即投入工作。商业化的开发人员已经犯了您即将要犯的许多错误，他们的智慧的代价相比于丢失您的宝贵数据来说是廉价的。

**** Tivoli Storage Manager

Tivoli Storage Manager 或许是现在可用于 Linux
的最好的商业化备份和存储管理实用工具。Tivoli Storage Manager
服务器可运行在多种平台上，包括
Linux，而客户机则可以运行在更多种类的平台上。

本质上，Storage Manager
服务器是通过适合于备份该环境的设备来配置的。要参与备份的任何系统都要加载一个与服务器通信的客户机。备份可以按计划执行、通过
Tivoli Storage Manager 客户机界面手动执行，或者使用基于 Web
的界面远程执行。

TSM
基于策略的性质意味着无需经常调整文件列表，就能够为备份行为定义中心规则。此外，IBM
Tivoli Storage Resource Manager
还能够识别、评估、控制和预测企业存储资产的利用情况，能够检测潜在的问题并自动应用自修复调整。更多细节请参见
Tivoli Web 站点（参见 [[#resources][参考资料]]中的链接）。

****** 图 1. Tivoli Storage Manager 菜单

[[tivsm0.jpg]]

然后备份和还原就通过远程设备来处理 *。*

****** 图 2. Tivoli Storage Manager 界面

[[tivsm1.jpg]]

--------------

[[#ibm-pcon][回页首]]

*** 前瞻和回顾

拥有良好备份的第一步是拥有计划。首先知道您需要保存的数据以及需要什么恢复策略，然后使用最适合该策略的工具。

Linux 附带了一些现成的（out of the box）有用备份工具。其中两个最常用的是
=tar= 和 =dump/restore=
。两者都能执行完全系统备份。使用创造性的脚本，您能够设计一个自定义的方案来本地和远程地备份系统。

然而，编写自己的备份脚本可能是一项繁重的任务，对于复杂的企业来说更是如此。诸如
Tivoli Storage Manager
这样的商业化软件降低了学习难度，并允许您立即控制自己的备份，但是您可能必须调整自己的策略来适应这些工具的功能。

*** 参考资料

- 您可以参阅本文在 developerWorks 全球站点上的
   [[http://www.ibm.com/developerworks/library/l-roadmap8/index.html?S_TACT=105AGX52&S_CMP=cn-a-l][英文原文]].
- 阅读 [[/developerworks/cn/linux/l-roadmap/index.html][Windows 到
   Linux 之旅系列文章]]的其他部分（ /developerWorks/，2003 年 11 月）。
- [[http://www.seifried.org/lasg/backups/][Linux Administrator's
   Security Guide]]是一个安全指南，其中有一个非常优秀的小节讨论了 Linux
   备份和恢复实践。
- [[http://www.tldp.org/REF/INTRO/Backup-INTRO/index.html][Introduction
   to Backing Up and Restoring
   Data]]是一篇与操作系统或系统体系结构无关的概述。作者在本文中探讨了备份技术以及如何为备份制定计划。
- [[http://www.tldp.org/LDP/lame/LAME/linux-admin-made-easy/index.html][Linux
   Administration Made Easy]]是一篇较旧的参考资料，但是仍然有用，因为
   Linux 的一般过程和技术仍然保持一致。
- [[http://www.tldp.org/LDP/sag/index.html][The Linux System
   Administrator's Guide]]为初学者介绍了 Linux 系统的系统管理。
- /Securing and Optimizing Linux - A Hands on Guide/ (Red Hat Edition)
   一书的
   [[http://pierre.mit.edu/compfac/linux/Securing-Optimizing-Linux-RH-Edition-v%201.3/backup-rest.html][第
   7 章“备份和还原”]]是另一份不错的指南，其中包括一个脚本，用于执行基于
   =tar= 的增量备份。
- [[http://www.taobackup.com/][The TAO of
   Backup]]是对备份哲学的有趣展示，以哲学的形式呈现出来。虽然它和一款商业化的产品相关，但是这段信息写得非常好。
- IBM /developerWorks/教程“
   [[http://www.ibm.com/developerworks/cn/views/linux/tutorials.jsp?cv_doc_id=84954][Linux
   机器备份]]”指导您完成创建和贯彻备份策略的过程。
- 在 CD 上存储数据和其他内容很容易：在 IBM /developerWorks/文章“
   [[/developerworks/cn/linux/l-cdburn/index.html][在 Linux 上烧录
   CD]]”中学习如何做到这点。
- 如果正在从 Windows 环境转换到 Linux 环境，您还需要阅读
   [[/developerworks/cn/linux/l-faq/index.html][Linux 用户技术 FAQ]]。
- The Tivoli Storage Manager 被评为
   [[http://www.linuxjournal.com/article.php?sid=6678][LinuxWorld 2003
   最佳存储解决方案]]。从 IBM 站点的 Linux 专区了解更多关于
   [[http://www.ibm.com/linux/solutions/tivolistormanaglinuxsolution.shtml][Tivoli
   Storage Manager for Linux]]的信息。
- [[http://www.ibm.com/software/tivoli/][Tivoli 产品页]] 包含关于
   Tivoli 的更多信息，包括安全和隐私特性。
- “Linux 文档计划”中
   [[http://tldp.org/LDP/intro-linux/html/sect_03_04.html][/Introduction
   to Linux/的第 3 章]]讨论了文件权限和安全。
- 在 /developerWorks/Linux 专区可以找到更多
   [[/developerworks/cn/linux/index.html][为 Linux
   开发者准备的参考资料]]。

** [[http://www.ibm.com/developerworks/cn/linux/l-ipc/][深刻理解Linux进程间通信（IPC）]]    :blog:

一个大型的应用系统，往往需要众多进程协作，进程（Linux进程概念见附1）间通信的重要性显而易见。本系列文章阐述了Linux环境下的几种主要进程间通信手段，并针对每个通信手段关键技术环节给出详细实例。为达到阐明问题的目的，本文还对某些通信手段的内部实现机制进行了分析。

[[#authorN10017][郑彦兴]]
([[mailto:mlinux@163.com?subject=深刻理解Linux进程间通信（IPC）][mlinux@163.com]])国防科大计算机学院

[[#close][关闭 [x]]]

郑彦兴，男，现攻读国防科大计算机学院网络方向博士学位。您可以通过电子邮件
[[mailto:mlinux@163.com?cc=][mlinux@163.com]]和他联系。




2002 年 12 月 11 日

- [[#toggle][[[//www.ibm.com/i/c.gif]]]]内容

   -  [[#N1002F][序]]
   -  [[#resources][参考资料]]
   -  [[#icomments][评论]]

*** 序

linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的。而对Unix发展做出重大贡献的两大主力AT&T的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心）在进程间通信方面的侧重点有所不同。前者对Unix早期的进程间通信手段进行了系统的改进和扩充，形成了“system
V
IPC”，通信进程局限在单个计算机内；后者则跳过了该限制，形成了基于套接口（socket）的进程间通信机制。Linux则把两者继承了下来，如图示：

******

[[1.gif]]

其中，最初Unix IPC包括：管道、FIFO、信号；System V IPC包括：System
V消息队列、System V信号灯、System V共享内存区；Posix IPC包括：
Posix消息队列、Posix信号灯、Posix共享内存区。有两点需要简单说明一下：1）由于Unix版本的多样性，电子电气工程协会（IEEE）开发了一个独立的Unix标准，这个新的ANSI
Unix标准被称为计算机环境的可移植性操作系统界面（PSOIX）。现有大部分Unix和流行版本都是遵循POSIX标准的，而Linux从一开始就遵循POSIX标准；2）BSD并不是没有涉足单机内的进程间通信（socket本身就可以用于单机内的进程间通信）。事实上，很多Unix版本的单机IPC留有BSD的痕迹，如4.4BSD支持的匿名内存映射、4.3+BSD对可靠信号语义的实现等等。

图一给出了linux
所支持的各种IPC手段，在本文接下来的讨论中，为了避免概念上的混淆，在尽可能少提及Unix的各个版本的情况下，所有问题的讨论最终都会归结到Linux环境下的进程间通信上来。并且，对于Linux所支持通信手段的不同实现版本（如对于共享内存来说，有Posix共享内存区以及System
V共享内存区两个实现版本），将主要介绍Posix API。

linux下进程间通信的几种主要手段简介：

1. 管道（Pipe）及有名管道（named
   pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
2. 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；
3. 报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system
   V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
5. 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
6. 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System
   V的变种都支持套接字。

下面将对上述通信机制做具体阐述。

附1：参考文献[2]中对linux环境下的进程进行了概括说明：

一般来说，linux下的进程包含以下几个关键要素：

- 有一段可执行程序；
- 有专用的系统堆栈空间；
- 内核中有它的控制块（进程控制块），描述进程所占用的资源，这样，进程才能接受内核的调度；
- 具有独立的存储空间

进程和线程有时候并不完全区分，而往往根据上下文理解其含义。

*** 参考资料

- UNIX环境高级编程，作者：W.Richard
   Stevens，译者：尤晋元等，机械工业出版社。具有丰富的编程实例，以及关键函数伴随Unix的发展历程。
- linux内核源代码情景分析（上、下），毛德操、胡希明著，浙江大学出版社，提供了对linux内核非常好的分析，同时，对一些关键概念的背景进行了详细的说明。
- UNIX网络编程第二卷：进程间通信，作者：W.Richard
   Stevens，译者：杨继张，清华大学出版社。一本比较全面阐述Unix环境下进程间通信的书（没有信号和套接口，套接口在第一卷中）。

** [[http://www.cnblogs.com/dolphinX/p/3460545.html][简单理解Socket]]    :blog:

**** 题外话

前几天和朋友聊天，朋友问我怎么最近不写博客了，一个是因为最近在忙着公司使用的一些控件的开发，浏览器兼容性搞死人；但主要是因为这段时间一直在看html5的东西，看到web
socket时觉得很有意思，动手写几个demo，但web
socket需要特定的服务器支持，由于标准制定工作还没完成，所以没有多少主流的服务器支持，自己在网上下载了几个实现，包括php的、C#的、甚至Node.js的，但一个是协议变化比较大，很多代码已经过时了，再就是有一些支持最新的标准，但是我想稍微改造一下，看人家源代码的时候云里雾里，看看别人的代码行数也不多，决定自己实现一个。

悲剧由此开始，虽然哥们儿国内非知名工科大学毕业，但好歹也是科班CS出身，但大学得过且过，什么TCP/IP协议，什么socket了都没概念。为了做出一个简单的支持广播的websocket
server，在网上找了很多相关代码，左抄一句，右抄一句，弄了一个星期竟然还是漏洞百出，调试不起来，只好从头来过了，先补一些基本知识，然后再一步步根据原理实现，今天终于实现了绝大部分功能，由此真的感受到了，搞计算机必须得有理论指导实践，否则只能像个没头苍蝇到处乱撞。

**** TCP/IP

要想理解socket首先得熟悉一下TCP/IP协议族， TCP/IP（Transmission Control
Protocol/Internet
Protocol）即传输控制协议/网间协议，定义了主机如何连入因特网及数据如何再它们之间传输的标准，

从字面意思来看TCP/IP是TCP和IP协议的合称，但实际上TCP/IP协议是指因特网整个TCP/IP协议族。不同于ISO模型的七个分层，TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中

应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等

传输层：TCP，UDP

网络层：IP，ICMP，OSPF，EIGRP，IGMP

数据链路层：SLIP，CSLIP，PPP，MTU

每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的

[[http://images.cnitblog.com/blog/349217/201312/05230830-04807bb739954461a8bfc7513707f253.jpg]]
[[http://images.cnitblog.com/blog/349217/201312/05230857-f49d5855f1e14a23a186737e0bec8a0f.gif]]

估计有兴趣打开此文的同学都对此有一定了解了，加上我也是一知半解，所以就不详细解释，有兴趣同学可以上网上搜一下资料

[[http://zh.wikipedia.org/wiki/TCP/IP][维基百科]][[http://zh.wikipedia.org/wiki/TCP/IP][
]]

[[http://baike.baidu.com/link?url=KJleEWJUBxe3XaxEaTU1lcQrg9qYN7FYzuPhoWVyoPFNk79NIURxAO6HSWC1MfrCU1Dh7QRsNDWOaZ-4bg5HRa][百度百科]]

在TCP/IP协议中两个因特网主机通过两个路由器和对应的层连接。各主机上的应用通过一些数据通道相互执行读取操作

[[http://images.cnitblog.com/blog/349217/201312/05221430-6bd4ce2a2cf7434ca9216c0a5b6a0985.png]]

**** socket

我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。

能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。

[[http://images.cnitblog.com/blog/349217/201312/05225723-2ffa89aad91f46099afa530ef8660b20.jpg]]

socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种"打开---读/写---关闭"模式的实现，服务器和客户端各自维护一个"文件"，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。

**** socket通信流程

socket是"打开---读/写---关闭"模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的

[[http://images.cnitblog.com/blog/349217/201312/05232335-fb19fc7527e944d4845ef40831da4ec2.png]]

服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket

服务器为socket绑定ip地址和端口号

服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开

客户端创建socket

客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket

服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入*阻塞*状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求

客户端连接成功，向服务器发送连接状态信息

服务器accept方法返回，连接成功

客户端向socket写入信息

服务器读取信息

客户端关闭

服务器端关闭

**** 三次握手

在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接

[[http://images.cnitblog.com/blog/349217/201312/05234233-eed6ddcba93c42be8847e98d6da62802.jpg]]

第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号/*Synchronize
Sequence Numbers*/），syn=j，客户端进入SYN_SEND状态等待服务器确认

第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态

第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手

定睛一看，服务器socket与客户端socket建立连接的部分其实就是大名鼎鼎的三次握手

[[http://images.cnitblog.com/blog/349217/201312/05234946-b80841921eae4d2ab983f26ed9023768.png]]

 *socket编程API*

前面提到socket是"打开---读/写---关闭"模式的实现，简单了解一下socket提供了哪些API供应用程序使用，还是以TCP协议为例，看看Unix下的socket
API，其它语言都很类似（PHP甚至名字都几乎一样），这里我就简单解释一下方法作用和参数，具体使用有兴趣同学可以看看博客参考中的链接或者上网搜索

#+BEGIN_EXAMPLE
    int socket(int domain, int type, int protocol);
#+END_EXAMPLE

根据指定的地址族、数据类型和协议来分配一个socket的描述字及其所用的资源。

domain:协议族，常用的有AF_INET、AF_INET6、AF_LOCAL、AF_ROUTE其中AF_INET代表使用ipv4地址

type:socket类型，常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等

protocol:协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等

#+BEGIN_EXAMPLE
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_EXAMPLE

把一个地址族中的特定地址赋给socket

sockfd:socket描述字，也就是socket引用

addr:要绑定给sockfd的协议地址

addrlen:地址的长度

/通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。/

#+BEGIN_EXAMPLE
    int listen(int sockfd, int backlog);
#+END_EXAMPLE

监听socket

sockfd:要监听的socket描述字

backlog:相应socket可以排队的最大连接个数

#+BEGIN_EXAMPLE
    int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_EXAMPLE

连接某个socket

sockfd:客户端的socket描述字

addr:服务器的socket地址

addrlen:socket地址的长度

#+BEGIN_EXAMPLE
    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
#+END_EXAMPLE

 TCP服务器监听到客户端请求之后，调用accept()函数取接收请求

sockfd:服务器的socket描述字

addr:客户端的socket地址

addrlen:socket地址的长度

#+BEGIN_EXAMPLE
    ssize_t read(int fd, void *buf, size_t count);
#+END_EXAMPLE

读取socket内容

fd:socket描述字

buf：缓冲区

count：缓冲区长度

#+BEGIN_EXAMPLE
    ssize_t write(int fd, const void *buf, size_t count);
#+END_EXAMPLE

向socket写入内容，其实就是发送内容

fd:socket描述字

buf：缓冲区

count：缓冲区长度

#+BEGIN_EXAMPLE
    int close(int fd);
#+END_EXAMPLE

socket标记为以关闭
，使相应socket描述字的引用计数-1，当引用计数为0的时候，触发TCP客户端向服务器发送终止连接请求。

**** 参考

[[http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html][Linux
Socket编程（不限Linux）]]

[[http://goodcandle.cnblogs.com/archive/2005/12/10/294652.aspx][揭开Socket编程的面纱
]]

PS.
有同学看完后发现没有demo示例，参考中的示例已经很不错了，我就不班门弄斧了，而且我用C#实现了一个websocket
server，接下来的博客中会有介绍。另外由于刚刚实际接触socket，文中谬误较多，还望大家批评指正，文章内容主要参考上面两个博文，图片全部来源于网络，在百度图片搜索得来，无法注明第一源地址，如有版权问题请站内信联系，第一时间处理。

** [[http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html][Linux Socket 编程（不限Linux）]]    :blog:

2010-12-12 21:58 by 吴秦, ... 阅读, ... 评论, [[#][收藏]],
[[http://i.cnblogs.com/EditPosts.aspx?postid=1903949][编辑]]

“一切皆Socket！”

话虽些许夸张，但是事实也是，现在的网络编程几乎都是用的socket。

------有感于实际编程和开源项目研究。

我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket的基本函数，这些都是本文想介绍的。本文的主要内容如下：

- 1、网络中进程之间如何通信？
- 2、Socket是什么？
- 3、socket的基本操作

   -  3.1、socket()函数
   -  3.2、bind()函数
   -  3.3、listen()、connect()函数
   -  3.4、accept()函数
   -  3.5、read()、write()函数等
   -  3.6、close()函数

- 4、socket中TCP的三次握手建立连接详解
- 5、socket中TCP的四次握手释放连接详解
- 6、一个例子（实践一下）
- 7、留下一个问题，欢迎大家回帖回答！！！

*** 1、网络中进程之间如何通信？

本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：

- 消息传递（管道、FIFO、消息队列）
- 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）
- 共享内存（匿名的和具名的）
- 远程过程调用（Solaris门和Sun RPC）

但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“*ip地址*”可以唯一标识网络中的主机，而传输层的“*协议+端口*”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。

使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX
BSD的套接字（socket）和UNIX System
V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。

*** 2、什么是Socket？

上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open
--> 读写write/read -->
关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。

#+BEGIN_QUOTE
  *** socket一词的起源

  在组网领域的首次使用是在1970年2月12日发布的文献[[http://datatracker.ietf.org/doc/rfc33/][IETF
  RFC33]]中发现的，撰写者为Stephen Carr、Steve Crocker和Vint
  Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”
#+END_QUOTE

*** 3、socket的基本操作

既然socket是“open---write/read---close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。

**** 3.1、socket()函数

#+BEGIN_EXAMPLE
    int socket(int domain, int type, int protocol);
#+END_EXAMPLE

socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而*socket()*用于创建一个socket描述符（socket
descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。

正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：

- domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。
- type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。
- protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。

注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。

当我们调用*socket*创建一个socket时，返回的socket描述字它存在于协议族（address
family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。

**** 3.2、bind()函数

正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。

#+BEGIN_EXAMPLE
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_EXAMPLE

函数的三个参数分别为：

- sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。
- addr：一个const struct sockaddr
   *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：

   #+BEGIN_EXAMPLE
       struct sockaddr_in {
           sa_family_t    sin_family; /* address family: AF_INET */
           in_port_t      sin_port;   /* port in network byte order */
           struct in_addr sin_addr;   /* internet address */
       };

       /* Internet address. */
       struct in_addr {
           uint32_t       s_addr;     /* address in network byte order */
       };
   #+END_EXAMPLE

   ipv6对应的是：

   #+BEGIN_EXAMPLE
       struct sockaddr_in6 {
           sa_family_t     sin6_family;   /* AF_INET6 */
           in_port_t       sin6_port;     /* port number */
           uint32_t        sin6_flowinfo; /* IPv6 flow information */
           struct in6_addr sin6_addr;     /* IPv6 address */
           uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */
       };

       struct in6_addr {
           unsigned char   s6_addr[16];   /* IPv6 address */
       };
   #+END_EXAMPLE

   Unix域对应的是：

   #+BEGIN_EXAMPLE
       #define UNIX_PATH_MAX    108

       struct sockaddr_un {
           sa_family_t sun_family;               /* AF_UNIX */
           char        sun_path[UNIX_PATH_MAX];  /* pathname */
       };
   #+END_EXAMPLE

- addrlen：对应的是地址的长度。

通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。

#+BEGIN_QUOTE
  *** 网络字节序与主机字节序

  *主机字节序*就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：

  　　a)
  Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。

  　　b)
  Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。

  *网络字节序*：4个字节的32
  bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。*由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。*字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。

  所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。
#+END_QUOTE

**** 3.3、listen()、connect()函数

如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。

#+BEGIN_EXAMPLE
    int listen(int sockfd, int backlog);
    int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_EXAMPLE

listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。

connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。

**** 3.4、accept()函数

TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。

#+BEGIN_EXAMPLE
    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
#+END_EXAMPLE

accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct
sockaddr
*的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。

注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。

**** 3.5、read()、write()等函数

万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：

- read()/write()
- recv()/send()
- readv()/writev()
- recvmsg()/sendmsg()
- recvfrom()/sendto()

我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：

#+BEGIN_EXAMPLE
           #include <unistd.h>

           ssize_t read(int fd, void *buf, size_t count);
           ssize_t write(int fd, const void *buf, size_t count);

           #include <sys/types.h>
           #include <sys/socket.h>

           ssize_t send(int sockfd, const void *buf, size_t len, int flags);
           ssize_t recv(int sockfd, void *buf, size_t len, int flags);

           ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                          const struct sockaddr *dest_addr, socklen_t addrlen);
           ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                            struct sockaddr *src_addr, socklen_t *addrlen);

           ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
           ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
#+END_EXAMPLE

read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。

write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。
在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。

其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。

**** 3.6、close()函数

在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。

#+BEGIN_EXAMPLE
    #include <unistd.h>
    int close(int fd);
#+END_EXAMPLE

close一个TCP
socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。

注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。

*** 4、socket中TCP的三次握手建立连接详解

我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：

- 客户端向服务器发送一个SYN J
- 服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1
- 客户端再想服务器发一个确认ACK K+1

只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：

[[http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png][[[http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157476286.png]]]]

图1、socket中发送的TCP三次握手

从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN
J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN
J包，调用accept函数接收请求向客户端发送SYN K ，ACK
J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK
J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK
K+1时，accept返回，至此三次握手完毕，连接建立。

#+BEGIN_QUOTE
  总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。
#+END_QUOTE

*** 5、socket中TCP的四次握手释放连接详解

上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：

[[http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png][[[http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157494693.png]]]]

图2、socket中发送的TCP四次握手

图示过程如下：

- 某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；
- 另一端接收到FIN
   M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；
- 一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN
   N；
- 接收到这个FIN的源发送端TCP对它进行确认。

这样每个方向上都有一个FIN和ACK。

*** 6、一个例子（实践一下）

说了这么多了，动手实践一下。下面编写一个简单的服务器、客户端（使用TCP）------服务器端一直监听本机的6666号端口，如果收到连接请求，将接收请求并接收客户端发来的消息；客户端与服务器端建立连接并发送一条消息。

服务器端代码：

[[http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif]][[http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif]]服务器端

#+BEGIN_EXAMPLE
    #include<stdio.h>#include<stdlib.h>#include<string.h>#include<errno.h>#include<sys/types.h>#include<sys/socket.h>#include<netinet/in.h>#define MAXLINE 4096int main(int argc, char** argv){    int    listenfd, connfd;    struct sockaddr_in     servaddr;    char    buff[4096];    int     n;    if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ){    printf("create socket error: %s(errno: %d)\n",strerror(errno),errno);    exit(0);    }    memset(&servaddr, 0, sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);    servaddr.sin_port = htons(6666);    if( bind(listenfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) == -1){    printf("bind socket error: %s(errno: %d)\n",strerror(errno),errno);    exit(0);    }    if( listen(listenfd, 10) == -1){    printf("listen socket error: %s(errno: %d)\n",strerror(errno),errno);    exit(0);    }    printf("======waiting for client's request======\n");    while(1){    if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1){        printf("accept socket error: %s(errno: %d)",strerror(errno),errno);        continue;    }    n = recv(connfd, buff, MAXLINE, 0);    buff[n] = '\0';    printf("recv msg from client: %s\n", buff);    close(connfd);    }    close(listenfd);}
#+END_EXAMPLE

客户端代码：

[[http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif]][[http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif]]客户端

#+BEGIN_EXAMPLE
    #include<stdio.h>#include<stdlib.h>#include<string.h>#include<errno.h>#include<sys/types.h>#include<sys/socket.h>#include<netinet/in.h>#define MAXLINE 4096int main(int argc, char** argv){    int    sockfd, n;    char    recvline[4096], sendline[4096];    struct sockaddr_in    servaddr;    if( argc != 2){    printf("usage: ./client <ipaddress>\n");    exit(0);    }    if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){    printf("create socket error: %s(errno: %d)\n", strerror(errno),errno);    exit(0);    }    memset(&servaddr, 0, sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_port = htons(6666);    if( inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0){    printf("inet_pton error for %s\n",argv[1]);    exit(0);    }    if( connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0){    printf("connect error: %s(errno: %d)\n",strerror(errno),errno);    exit(0);    }    printf("send msg to server: \n");    fgets(sendline, 4096, stdin);    if( send(sockfd, sendline, strlen(sendline), 0) < 0)    {    printf("send msg error: %s(errno: %d)\n", strerror(errno), errno);    exit(0);    }    close(sockfd);    exit(0);}
#+END_EXAMPLE

当然上面的代码很简单，也有很多缺点，这就只是简单的演示socket的基本函数使用。其实不管有多复杂的网络程序，都使用的这些基本函数。上面的服务器使用的是迭代模式的，即只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力是很弱的，现实中的服务器都需要有并发处理能力！为了需要并发处理，服务器需要fork()一个新的进程或者线程去处理请求等。

*** 7、动动手

留下一个问题，欢迎大家回帖回答！！！是否熟悉Linux下网络编程？如熟悉，编写如下程序完成如下功能：

服务器端：

接收地址192.168.100.2的客户端信息，如信息为“Client
Query”，则打印“Receive Query”

客户端：

向地址192.168.100.168的服务器端顺序发送信息“Client Query test”，“Cleint
Query”，“Client Query Quit”，然后退出。

题目中出现的ip地址可以根据实际情况定。

------本文只是介绍了简单的socket编程。

更为复杂的需要自己继续深入。

***** [[http://www.cnblogs.com/skynet/archive/2010/12/04/1881236.html][（unix
domain
socket）使用udp发送>=128K的消息会报ENOBUFS的错误]]（一个实际socket编程中遇到的问题，希望对你有帮助）

** [[http://ditaa.sourceforge.net/#download][DIagrams Through Ascii Art]]    :blog:


ditaa is a small command-line utility written in Java, that can convert
diagrams drawn using ascii art ('drawings' that contain characters that
resemble lines like =| / - =), into proper bitmap graphics. This is best
illustrated by the following example -- which also illustrates the
benefits of using ditaa in comparison to other methods :)

| #+BEGIN_EXAMPLE                               | After conversion using ditaa, the above file becomes:\\   |
|         +--------+   +-------+    +-------+   | [[images/first.png]]                                      |
|         |        | --+ ditaa +--> |       |   |                                                           |
|         |  Text  |   +-------+    |diagram|   |                                                           |
|         |Document|   |!magic!|    |       |   |                                                           |
|         |     {d}|   |       |    |       |   |                                                           |
|         +---+----+   +-------+    +-------+   |                                                           |
|             :                         ^       |                                                           |
|             |       Lots of work      |       |                                                           |
|             +-------------------------+       |                                                           |
| #+END_EXAMPLE                                 |                                                           |


ditaa interprets ascci art as a series of open and closed shapes, but it
also uses special markup syntax to increase the possibilities of shapes
and symbols that can be rendered.

ditaa is open source and free software (/free/ as in free speech), since
it is released under the GPL license.

**** BUT WHY? Does this thing have any /real/ use?

There are several reasons why I did this:

1. Simply for *hack value*. I wanted to know if/how it could be done and
   how easily.
2. *Aesthetic reasons and legacy formats:* there are several old FAQs
   with ascii diagrams lying out there. At this time and age ascii
   diagrams make my eyes hurt due to their ugliness. ditaa can be used
   to convert them to something nicer. Although ditaa would not be able
   to convert all of them (due to differences in drawing 'style' in each
   case), it could prove useful in the effort of modernising some of
   those documents without too much effort. I also know a lot of people
   that can make an ascii diagram easily, but when it gets to using a
   diagram program, they don't do very well. Maybe this utility could
   help them make good-looking diagrams easily/quickly.
3. *Embedding diagrams to text-only formats:* There is a number of
   formats that are text-based (html, docbook, LaTeX, programming
   language comments), but when rendered by other software (browsers,
   interpreters, the javadoc tool etc), they can contain images as part
   of their content. If ditaa was intergrated with those tools (and I'm
   planning to do the javadoc bit myself soon), then you would have
   readable/editable diagrams within the text format itself, something
   that would make things much easier. ditaa syntax can currently be
   embedded to [[#html_mode][HTML]].
4. *Reusability of "code":* Suppose you make a diagram in ascii art and
   you render it with version 0.6b of ditaa. You keep the ascii diagram,
   and then version 0.8 comes out, which features some new cool effects.
   You re-render your old diagram with the new version of ditaa, and it
   looks better, with zero effort! In that sense ditaa is a diagram
   markup language, with very loose syntax.

*** Download

(((-[[#intro][intro]]-))) (((-[[#download][download]]-)))
(((-[[#usage][usage and syntax]]-))) (((-[[#friends][friends]]-)))
(((-[[#contact][contact]]-)))

The latest version of ditaa can be obtained from its
[[http://sourceforge.net/projects/ditaa/][SourceForge project page]].

You can checkout the code using:

 =svn co https://ditaa.svn.sourceforge.net/svnroot/ditaa ditaa=

You can also [[http://ditaa.svn.sourceforge.net/viewvc/ditaa/][browse
the code online]].

*** Usage and syntax

(((-[[#intro][intro]]-))) (((-[[#download][download]]-)))
(((-[[#usage][usage and syntax]]-))) (((-[[#friends][friends]]-)))
(((-[[#contact][contact]]-)))

**** Command line

You need the latest Java runtimes (JRE) to use ditaa. The best
anti-aliasing can be achieved using Java 1.5 or higher.

To start from the command line, type (where XXX is the version number):

#+BEGIN_EXAMPLE
    java -jar ditaaXXX.jar
#+END_EXAMPLE

You will be presented with the command-line options help:

#+BEGIN_EXAMPLE
     -A,--no-antialias          Turns anti-aliasing off.
     -d,--debug                 Renders the debug grid over the resulting
                                image.
     -E,--no-separation         Prevents the separation of common edges of
                                shapes. You can see the difference below:
#+END_EXAMPLE

| #+BEGIN_EXAMPLE                | Before processing        |
|     +---------+                | Common edge\\            |
|     | cBLU    |                | separation (default)     |
|     |         |                | No separation\\          |
|     |    +----+                | (with the =-E= option)   |
|     |    |cPNK|                |                          |
|     |    |    |                |                          |
|     +----+----+                |                          |
|                                |                          |
| #+END_EXAMPLE                  |                          |
|                                |                          |
| [[images/separation.png]]      |                          |
| [[images/no_separation.png]]   |                          |

#+BEGIN_EXAMPLE
     -e,--encoding <ENCODING>   The encoding of the input file.
     -h,--html                  In this case the input is an HTML file. The
                                contents of the <pre class="textdiagram"> tags
                                are rendered as diagrams and saved in the
                                images directory and a new HTML file is
                                produced with the appropriate <img> tags.
                                See the HTML section.
        --help                  Prints usage help.
     -o,--overwrite             If the filename of the destination image
                                already exists, an alternative name is chosen.
                                If the overwrite option is selected, the image
                                file is instead overwriten.
     -r,--round-corners         Causes all corners to be rendered as round
                                corners.
     -s,--scale <SCALE>         A natural number that determines the size of
                                the rendered image. The units are fractions of
                                the default size (2.5 renders 1.5 times bigger
                                than the default).
     -S,--no-shadows            Turns off the drop-shadow effect.
     -t,--tabs <TABS>           Tabs are normally interpreted as 8 spaces but
                                it is possible to change that using this
                                option. It is not advisable to use tabs in
                                your diagrams.
     -v,--verbose               Makes ditaa more verbose.
#+END_EXAMPLE

***** Syntax

****** Round corners

If you use / and \ to connect corners, they are rendered as round
corners:

| #+BEGIN_EXAMPLE               | Before processing   |
|     /--+                      | Rendered            |
|     |  |                      |                     |
|     +--/                      |                     |
|                               |                     |
| #+END_EXAMPLE                 |                     |
|                               |                     |
| [[images/round_corner.png]]   |                     |

****** Color

Color codes can be used to add color to the diagrams. The syntax of
color codes is

#+BEGIN_EXAMPLE
    cXXX
#+END_EXAMPLE

where XXX is a hex number. The first digit of the number represents the
red compoment of the color, the second digit represents green and the
third blue (good ol' RGB). See below for an example of use of color
codes:

| #+BEGIN_EXAMPLE        | Before processing   |
|     /----\ /----\      | Rendered            |
|     |c33F| |cC02|      |                     |
|     |    | |    |      |                     |
|     \----/ \----/      |                     |
|                        |                     |
|     /----\ /----\      |                     |
|     |c1FF| |c1AB|      |                     |
|     |    | |    |      |                     |
|     \----/ \----/      |                     |
|                        |                     |
| #+END_EXAMPLE          |                     |
|                        |                     |
| [[images/color.png]]   |                     |

This can become a bit tedious after a while, so there are (only some for
now) human readable color codes provided:

| #+BEGIN_EXAMPLE                     | Before processing   |
|     Color codes                     | Rendered            |
|     /-------------+-------------\   |                     |
|     |cRED RED     |cBLU BLU     |   |                     |
|     +-------------+-------------+   |                     |
|     |cGRE GRE     |cPNK PNK     |   |                     |
|     +-------------+-------------+   |                     |
|     |cBLK BLK     |cYEL YEL     |   |                     |
|     \-------------+-------------/   |                     |
| #+END_EXAMPLE                       |                     |
|                                     |                     |
| [[images/color_codes.png]]          |                     |

As you can see above, if a colored shape contains any text, the color of
the text is adjusted according to the underlying color. If the undelying
color is dark, the text color is changed to white (from the default
black).

Note that color codes only apply if they are within closed shapes, and
they have no effect anywhere outside.

****** Tags

ditaa recognises some tags that change the way a rectangular shape is
rendered. All tags are between { and }. See the table below:

Name

Original

Rendered

Comment

Document

#+BEGIN_EXAMPLE
    +-----+
    |{d}  |
    |     |
    |     |
    +-----+

#+END_EXAMPLE

[[images/document.png]]

Symbol representing a document.

Storage

#+BEGIN_EXAMPLE
    +-----+
    |{s}  |
    |     |
    |     |
    +-----+

#+END_EXAMPLE

[[images/storage.png]]

Symbol representing a form of storage,
like a database or a hard disk.

Input/Output

#+BEGIN_EXAMPLE
    +-----+
    |{io} |
    |     |
    |     |
    +-----+

#+END_EXAMPLE

[[images/io.png]]

Symbol representing input/output.

****** Dashed lines

Any lines that contain either at least one *=* (for horizontal lines) or
at least one *:* (for vertical lines) are rendered as dashed lines. Only
one of those characters can make a whole line dashed, so this feature
"spreads". The rationale behind that is that you only have to change one
character to switch from normal to dashed (and vice versa), rather than
redrawing the whole line/shape. Special symbols (like document or
storage symbols) can also be dashed. See below:

| #+BEGIN_EXAMPLE              | Before processing   |
|     ----+  /----\  +----+    | Rendered            |
|         :  |    |  :    |    |                     |
|         |  |    |  |{s} |    |                     |
|         v  \-=--+  +----+    |                     |
| #+END_EXAMPLE                |                     |
|                              |                     |
| [[images/dashed_demo.png]]   |                     |

****** Point markers

If *** is encountered on a line (but not at the end of the line), it is
rendered as a special marker, called the point marker (this feature is
still experimental). See below:

| #+BEGIN_EXAMPLE               | Before processing   |
|     *----*                    | Rendered            |
|     |    |      /--*          |                     |
|     *    *      |             |                     |
|     |    |  -*--+             |                     |
|     *----*                    |                     |
| #+END_EXAMPLE                 |                     |
|                               |                     |
| [[images/point_marker.png]]   |                     |

****** Text handling

(This section is still being written)

If the pattern ' o XXXXX' is encountered, where XXXXX is any text, the
'o' is interpreted and rendered as a bullet point. Note that there must
be a space before the 'o' as well as after it. See below:

| #+BEGIN_EXAMPLE           | Before processing   |
|     /-----------------\   | Rendered            |
|     | Things to do    |   |                     |
|     | cGRE            |   |                     |
|     | o Cut the grass |   |                     |
|     | o Buy jam       |   |                     |
|     | o Fix car       |   |                     |
|     | o Make website  |   |                     |
|     \-----------------/   |                     |
| #+END_EXAMPLE             |                     |
|                           |                     |
| [[images/bullet.png]]     |                     |

****** HTML mode

When ditaa is run using the =--html= option, the input is an HTML file.
The contents of the =<pre     class="textdiagram">= tags are rendered as
diagrams and saved in the =images= directory and a new HTML file is
produced with the appropriate =<img>= tags.

If the =id= parameter is present in the =<pre>= tag, its value is used
as the filename of the rendered png. Otherwise a filename of the form
=ditaa_diagram_X.png= is used, where X is a number. Similarly, if there
is no output filename specified, the converted html file is named in the
form of =xxxx_processed.html=, where xxxx is the filename of the
original file.

In this mode, files that exist are not generated again, they are just
skipped. You can force overwrite of the files using the =--overwrite=
option.

**** Friends and relatives

(((-[[#intro][intro]]-))) (((-[[#download][download]]-)))
(((-[[#usage][usage and syntax]]-))) (((-[[#friends][friends]]-)))
(((-[[#contact][contact]]-)))

Here is a list of projects that are related to ditaa and add to its
functionality:

- Mikael Brännström's
   [[http://ditaa-addons.sourceforge.net/][ditaa-addons]] offers two
   very interesting pieces of functionality: The =Textdiagram= Javadoc
   taglet allows you to embedd ascii diagrams to Java comments and have
   them rendered as ditaa diagrams in the HTML output. The Ditaa Eps
   program allows you to render to EPS instead of PNG.
- Mathieu Lecarme's [[http://github.com/athoune/Ditaa-web/][ditaa-web]]
   allows you to install ditaa on your web server and use it as a
   webservice through a HTTP POST request.
- Bill Baker's [[http://ditaa.org/][ditaa.org]] allows you to run ditaa
   from the web.
- ditaa comes bundled within [[http://orgmode.org/][org-mode]], a major
   mode for emacs.
   [[http://doc.norang.ca/org-mode.html#sec-13.1][Here's]] an example of
   how you can use it.
- There is a [[http://www.dokuwiki.org/plugin:ditaa][plugin]] for
   [[http://www.dokuwiki.org][DocuWiki]] that allows you to render ditaa
   diagrams in the wiki pages. Written by Dennis Ploeger.

Here's a list of projects that are somehow related to ditaa, and could
prove useful/relevant while using it:

- Nadim Khemir's [[http://search.cpan.org/dist/App-Asciio/][asciio]]
   could be used for producing the ascii diagrams more easily. It would
   require some modifications to its default settings for the diagrams
   to render properly (specifically the characters used for corners
   should all be set to =+=). Here is a
   [[http://www.youtube.com/watch?v=IiOHYNHo_Nw][screencast]] of how
   asciio works.
- Markus Gebhard's [[http://www.jave.de/][JavE]] could be used for the
   same purpose, although I've never tried it.
- If you make sure to keep the lines straight,
   [[http://www.cinsk.org/emacs/emacs-artist.html][artist-mode]] for
   emacs can be used to produce ditaa-compatible diagrams.

** [[http://www.cnblogs.com/bayonetxxx/archive/2010/12/07/1898489.html][sudo apt-get 和dpkg命令大全]]    :blog:

一、APT的使用（Ubuntu Linux软件包管理工具一）
apt-cache search # ------(package 搜索包)
apt-cache show #------(package 获取包的相关信息，如说明、大小、版本等)
sudo apt-get install # ------(package 安装包)
sudo apt-get install # -----(package - - reinstall 重新安装包)
sudo apt-get -f install # -----(强制安装?#"-f = --fix-missing"当是修复安
装吧...)
sudo apt-get remove #-----(package 删除包)
sudo apt-get remove - - purge # ------(package 删除包，包括删除配置文件
等)
sudo apt-get autoremove --purge # ----(package 删除包及其依赖的软件包+配置文件等（只对6.10有效，强烈推荐）)
sudo apt-get update #------更新源
sudo apt-get upgrade #------更新已安装的包
sudo apt-get dist-upgrade # ---------升级系统
sudo apt-get dselect-upgrade #------使用 dselect 升级
apt-cache depends #-------(package 了解使用依赖)
apt-cache rdepends # ------(package 了解某个具体的依赖?#当是查看该包被哪些包依赖吧...)
sudo apt-get build-dep # ------(package 安装相关的编译环境)
apt-get source #------(package 下载该包的源代码)
sudo apt-get clean && sudo apt-get autoclean # --------清理下载文件的存
档 && 只清理过时的包
sudo apt-get check #-------检查是否有损坏的依赖


apt-get install 的用法
apt-get install <package>
下载 <package> 以及所有倚赖的包裹,同时进行包裹的安装或升级.如果某个包裹被设置了 hold (停止标志,就会被搁在一边(即不会被升级).更多 hold 细节请看下面.

apt-get remove [--purge] <package>
移除 <package> 以及任何倚赖这个包裹的其它包裹.--purge 指明这个包裹应该被完全清除 (purged) ,更多信息请看 dpkg -P .

apt-get update
升级来自 Debian 镜像的包裹列表,如果你想安装当天的任何软件,至少每天运行一次,而且每次修改了
/etc/apt/sources.list 后,必须执行.

apt-get upgrade [-u]
升级所以已经安装的包裹为最新可用版本.不会安装新的或移除老的包裹.如果一个包改变了倚赖关系而需要安装一个新的包裹,那么它将不会被升级,而是标志为 hold .apt-get update 不会升级被标志为 hold 的包裹 (这个也就是 hold 的意思).请看下文如何手动设置包裹为 hold .我建议同时使用 '-u' 选项,因为这样你就能看到哪些包裹将会被升级.

apt-get dist-upgrade [-u]
和 apt-get upgrade 类似,除了 dist-upgrade 会安装和移除包裹来满足倚赖关系.因此具有一定的危险性.

apt-cache search <pattern>
搜索满足 <pattern> 的包裹和描述.

apt-cache show <package>
显示 <package> 的完整的描述.

apt-cache showpkg <package>
显示 <package> 许多细节,以及和其它包裹的关系.

dselect, console-apt, aptitude, gnome-apt,是APT 的几个图形前端(其中一些在使用前得先安装).这里 dselect 无疑是最强大的,也是最古老,最难驾驭.

－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－

二、 DPKG的 用法（Ubuntu Linux软件包管理工具二）
dpkg -i <package.deb>
安装一个 Debian 包裹文件;如你手动下载的文件.

dpkg -c <package.deb>
列出 <package.deb> 的内容.

dpkg -I <package.deb>
从 <package.deb> 中提取包裹信息.

dpkg -r <package>
移除一个已安装的包裹.

dpkg -P <package>
完全清除一个已安装的包裹.和 remove 不同的是, remove 只是删掉数据和可执行
文件, purge 另外还删除所有的配制文件.

dpkg -L <package>
列出 <package> 安装的所有文件清单.同时请看 dpkg -c 来检查一个 .deb 文件
的内容.

dpkg -s <package>
显示已安装包裹的信息.同时请看 apt-cache 显示 Debian 存档中的包裹信息,以
及 dpkg -I 来显示从一个
.deb 文件中提取的包裹信息.

dpkg-reconfigure <package>
重新配制一个已经安装的包裹,如果它使用的是 debconf (debconf 为包裹安装提
供了一个统一的配制界面).你能够重新配制 debconf 它本身,如你想改变它的前端
或提问的优先权.例如,重新配制 debconf ,使用一个 dialog 前端,简单运行:

dpkg-reconfigure --frontend=dialog debconf (如果你安装时选错了,这里可以
改回来哟

echo "<package> hold" | dpkg --set-selections
设置 <package> 的状态为 hlod (命令行方式)

dpkg --get-selections "<package>"
取的 <package> 的当前状态 (命令行方式)

支持通配符,如:
Debian:~# dpkg --get-selections *wine*




备注：

－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－例如:
大家现在用的都是 gaim-0.58 + QQ-plugin,为了防止 gaim 被升级,我们可以采用
如下方法:

方法一:
Debian:~# echo "gaim hold" | dpkg --set-selections
然后用下面命令检查一下:
Debian:~# dpkg --get-selections "gaim"
gaim hold
现在的状态标志是 hold,就不能被升级了.

如果想恢复怎么办呢?
Debian:~# echo "gaim install" | dpkg --set-selections
Debian:~# dpkg --get-selections "gaim"
gaim install
这时状态标志又被重置为 install,可以继续升级了.

同志们会问,哪个这些状态标志都写在哪个文件中呢?
在 /var/lib/dpkg/status 里,你也可以通过修改这个文件实现 hold.

有时你会发现有的软件状态标志是 purge,不要奇怪.
如:事先已经安装了 amsn, 然后把它卸了.
apt-get remove --purge amsn
那么状态标志就从 install 变成 purge.

方法二:
在/etc/apt 下手动建一个 preferences 文件
内容：
Package: gaim
Pin: version 0.58*
保存
更详细内容请看:
http://linuxsir.com/bbs/showthread....&threadid=22601

dpkg -S <file>
在包裹数据库中查找 <file>,并告诉你哪个包裹包含了这个文件.(注:查找的是事
先已经安装的包裹)

从源码建立deb packages

apt-get source [-b] <package>
下载一个源码的包并解开。
你必须在你的/etc/apt/sources.list文件里写入一条 deb-src 的记录才能完成这
项工作。
如果你输入了一个-b参数，并且是以root的身份，deb包会被自动的创建。

apt-get build-dep <package>
自动下载并安装通过源码创建 <package> 时需要的包。
只有apt 0.5以上版本才支持这个功能。
现在woody和以上版本包含了这个功能。
如果你使有一个旧版本的apt，查找依赖性最简单的方法是查看源码包中
debian/control 这个文件，
注意这个路径是相对的，是包内的路径。

普通的用法，结合 apt-get source -b,例子 (as root)：

apt-get build-dep <package>
apt-get source -b <package>

会下载源码包，建立依赖性，然后尝试编译源码。

dpkg-source -x <package.dsc>
如果你手工下载了一个程序的源码包，其中包含了几个类
似 .orig.tar.gz , .dsc ,
以及 .diff.gz 之类的文件，
那么你就可以对 .dsc 文件使用这个命令来 unpack 源码包。

dpkg-buildpackage
从 Debian 源码树建立一个deb包。你必须在source tree的主目录才能生效。例
如：

dpkg-buildpackage -rfakeroot -uc -b

这里 '-rfakeroot' 指定命令使用 fakeroot 程序来模仿 root 权限 (来实现所有
者(ownership)目的)，
'-uc' 表示 "Don't cryptographically sign the changelog", '-b' 代表只建立
二进制包.

debuild
一个快速打包脚本类似 dpkg-buildpackage ,能自动的识别是否使用 fakeroot,
同时为你运行 lintian 和 gpg

修正倚赖关系

dpkg --configure --pending
如果dpkg在apt-get install upgrade dist-uptradeing 的时候出错退出，
尝试使用此命令来配置已经unpack的包。
然后再用 apt-get install ，upgrade, or dist-upgrade -f ，
然后再用 apt-get install, upgrade, or dist-upgrade.

可能会重复多次，这样通常可以解决大多数的依赖性问题。
(同时,如果提示由于某种原因需要某个特定的包裹,你可以常识安装或卸载这个包)

apt-get install -f
apt-get upgrade -f
apt-get dist-upgrade -f
尝试修正上述过程中出现依赖性关系
注意 apt-get install -f 不需要 <package> 作为参数。



－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
用apt-cdrom -d /media/cdrom0 add 加载光驱，

/dev/hdc /cdrom iso9660 user,noauto 0 0
用编辑器修改一下存盘，重启，应该可以了。
然后，apt-cdrom -d /cdrom add
apt-get install (你要装的软件名：《例如gcc》)
gcc相关的软件会自动装入。
昨天，刚试过，很爽。
注意：apt不会认你手动挂载的光驱，如果fstab中设置不对apt不会正常工作。

用apt-cdrom -d /media/cdrom0 add 加载光驱，
需要使用#mkdir /media/cdrom0 否则会错误提示说“无法读取文件系统挂载
点/media/cdrom的状态 -stat(2 没有那个文件或目录)”

** [[http://www.cnblogs.com/sld666666/archive/2010/06/25/1765510.html][利用Graphviz画结构图]]    :blog:

*** 1. Graphviz介绍

  Graphviz是大名鼎鼎的贝尔实验室的几位牛人开发的一个画图工具。

它的理念和一般的“所见即所得”的画图工具不一样，是“所想即所得”。

Graphviz提供了dot语言来编写绘图脚本。什么？！画个图也需要一个语言！！

不要急，dot语言是非常简单地，只要看了下面几个列子，就能使用了。



*** 2. Graphviz的几个例子


下面的几个例子都来自于官方文档。详情请见：[[http://www.graphviz.org/][Graphviz官网]].

**** 2.1 Fancy graph

#+BEGIN_EXAMPLE
     digraph G{

        size = "4, 4";//图片大小
        main[shape=box];/*形状*/

        main->parse;
        parse->execute;

        main->init[style = dotted];//虚线

        main->cleanup;

        execute->{make_string; printf}//连接两个

        init->make_string;

        edge[color = red]; // 连接线的颜色

        main->printf[style=bold, label="100 times"];//线的 label

        make_string[label = "make a\nstring"]// \n, 这个node的label，注意和上一行的区别

        node[shape = box, style = filled, color = ".7.3 1.0"];//一个node的属性

        execute->compare;
    }
#+END_EXAMPLE

从上面的代码可以看出，dot语言非常简单，就是一个纯描述性的语言而已。

大家可以把上面的代码和下图中的连接对应起来看。


[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/1.png][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/1_thumb.png]]]]

  <图1. Fancy graph>



**** 2.2 Polygon graph

#+BEGIN_EXAMPLE
     digraph G{
        size = "4, 4"
        a->b->c;
        b->d;

        a[shape = polygon, sides = 5, peripheries=3, color = lightblue, style = filled];
        //我的形状是多边形，有五条边，3条边框， 颜色的淡蓝色， 样式为填充
        c[shape = polygon, sides = 4, skew= 0.4, lable = "hello world"];
        //我的形状是4变形， 角的弯曲度0.4, 里面的内容为"hello world"
        d[shape = invtriange];
        //我是三角形
        e[shape = polygon, side = 4, distortion = .7];
        //我是梯形啊
    }
#+END_EXAMPLE





下面是对应的图片：


[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/polygon_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/polygon_thumb.jpg]]]]

#+BEGIN_QUOTE
    <图2. Polygon graph>
#+END_QUOTE

**** 2.3 连接点的方向

  我们可以用“n”,”ne”,”e”,””se”, “sw”,”w”,”nw”,

分别表示冲哪一个方向连接这个节点（图形）-“north, northeast......”

如：

#+BEGIN_EXAMPLE
     digraph G{
        //b->c[tailport = se];
        b->c:se;
    }
#+END_EXAMPLE





#+BEGIN_QUOTE

  [[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/se_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/se_thumb.jpg]]]]

    <图3. Se graph>


#+END_QUOTE

**** 2.4 数据结构图

  数据结构图是我们很容易用到的一类图形，一个简单地数据结构图代码如下：

#+BEGIN_EXAMPLE
     digraph g{
        node [shape = record,height=.1//我定义了我下面的样式;
        node0[label = "<f0> |<f1> G|<f2> "];
        //我是一个node,我有三个属性，第二个的名字为G，其他两个为空
            node1[label = "<f0> |<f1> E|<f2> "];
           node2[label = "<f0> |<f1> B|<f2> "];
           node3[label = "<f0> |<f1> F|<f2> "];
           node4[label = "<f0> |<f1> R|<f2> "];
           node5[label = "<f0> |<f1> H|<f2> "];
           node6[label = "<f0> |<f1> Y|<f2> "];
           node7[label = "<f0> |<f1> A|<f2> "];
           node8[label = "<f0> |<f1> C|<f2> "];

        "node0": f2->"node4":f1;
        //我的第三个属性连到node4的第二个属性
        "node0": f0->"node1":f1;
        "node1": f0->"node2":f1;
        "node1": f2->"node3":f1;
        "node2": f2->"node8":f1;
        "node2": f0->"node7":f1;
        "node4": f2->"node6":f1;
        "node4": f0->"node5":f1;
    }
#+END_EXAMPLE






[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/data_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/data_thumb.jpg]]]]

  <图4. Data graph>

**** 2.5 Hash table graph

#+BEGIN_EXAMPLE
     digraph g {
        nodesep = .05;
        rankdir = LR;

        node[shape = record, width = .1, height = .1];

        node0[label = "<f0> |<f1> |<f2> |<f3> |<f4> |<f5> |<f6> |", height = 2.5];
        //我是一个节点，我有7个属性
        node [width = 1.5];
        node1[label = "{<n> n14 | 719 |<p>}"];
        //我还是一个节点， 也定义了三个属性
        node2[label = "{<n> a1 | 719 |<p>}"];
        node3[label = "{<n> i9 | 512 |<p>}"];
        node4[label = "{<n> e5 | 632 |<p>}"];
        node5[label = "{<n> t20 | 959 |<p>}"];
        node6[label = "{<n> o15 | 794 |<p>}"];
        node7[label = "{<n> s19 | 659 |<p>}"];

        //好了，我开始连接了
        node0:f0->node1:n;
        node0:f1->node2:n;
        node0:f2->node3:n;
        node0:f5->node4:n;
        node0:f6->node5:n;
        node2:p->node6:n;
        node4:p->node7:n;
    }
#+END_EXAMPLE



这是一个简单地哈希表，如下图所示


[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/Hash_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/Hash_thumb.jpg]]]]

  <图5. Hash
table graph>





**** 2.6 Process grahp

下面画一个轻量级的流程图。

#+BEGIN_EXAMPLE
     digraph g {
        subgraph cluster0 {
            //我是一个子图，subgraph定义了我，
            node[style = filled, color = white];
            //我之内的节点都是这种样式
            style = filled;
            //我的样式是填充
            color = lightgrey;
            //我的颜色
            a0->a1->a2->a3;
            label = "prcess #1"
            //我的标题
        }

        subgraph cluster1 {
            //我也是一个子图
            node[style = filled];
            b0->b1->b2->b3;
            label = "process #2";
            color = blue;
        }

        //定义完毕之后，下面还是连接了
        start->a0;
        start->b0;
        a1->b3;
        b2->a3;
        a3->end;
        b3->end;

        start[shape=Mdiamond];
        end[shape=Msquare];
    }
#+END_EXAMPLE







结果输出图形如下：


[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/Process_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/Process_thumb.jpg]]]]

  <图6. Hash table graph>



*** 3. 小结


相信这几个列子下来，各位看官对graphviz也有了了解了吧，我个人用了一遍下来发现太爽了。

而对于dot语言，作为一个描述性的语言就非常简单了，
只要有编程基础的人，模仿几个列子下来

应该就能应用了。

** [[http://manpages.ubuntu.com/manpages/hardy/man1/pdfoutline.1.html][Ubuntu Manpage: pdfoutline - add outlines (aka bookmarks) to PDF files]]    :blog:

**** *NAME*

#+BEGIN_EXAMPLE
           pdfoutline - add outlines (aka bookmarks) to PDF files
#+END_EXAMPLE

**** *SYNOPSIS*

#+BEGIN_EXAMPLE
           pdfoutline input.pdf outlines.txt output.pdf
#+END_EXAMPLE

**** *DESCRIPTION*

#+BEGIN_EXAMPLE
           pdfoutline reads input file given as first argument, adds outlines from
           text file given as second argument, and saves result to file with  name
           given as third argument.

           File with outlines information should consist of lines in the following
           format:
                  <level> <page> Outline text

           <level> and <page> should be integers.  Each field should be  separated
           by  exactly one space symbol.  All values for <level> should be greater
           or equal than that of the first line.  Page numeration starts with 1.

           Outlines file can contain comments that start with # in  first  column.
           Comments and empty lines are ignored.
#+END_EXAMPLE

**** *OPTIONS*

#+BEGIN_EXAMPLE
           pdfoutline accepts no options.
#+END_EXAMPLE

**** *EXAMPLES*

#+BEGIN_EXAMPLE
           Here is example of outlines data file:
                  0 1 Document title
                  1 1 Chapter 1
                  2 1 Chapter 1.1
                  2 2 Chapter 1.2
                  1 3 Chapter 2

           Using this file will result in outlines like the following:
                  Document title
                  +-Chapter 1
                  | +-Chapter 1.1
                  | +-Chapter 1.2
                  +-Chapter 2
#+END_EXAMPLE

**** *AUTHOR*

#+BEGIN_EXAMPLE
           pdfoutline author is Eugeniy Meshcheryakov <eugen@debian.org>
           pdfoutline   is   part   of   fntsample   and  can  be  downoaded  from
           <http://sourceforge.net/projects/fntsample>.

                                      2007-10-27                     pdfoutline(1)
#+END_EXAMPLE

** [[http://linux-wiki.cn/wiki/zh-hans/%E8%A1%A5%E4%B8%81(patch)%E7%9A%84%E5%88%B6%E4%BD%9C%E4%B8%8E%E5%BA%94%E7%94%A8][补丁(patch)的制作与应用]]    :blog:

此页由Linux Wiki用户[[/wiki/User:Chenxing][Chenxing]]于2011年3月27日
(星期日) 18:51的最后更改。

**** 出自Linux Wiki

*提示：*此文已超过 4 年（1762
天）未更新，如发现内容过时或有误，欢迎改进:)

如果hack了开源代码，为了方便分享（如提交Bug）或自己留存使用，一般都要制作一个补丁（Patch）。在从源码安装软件时，也难免要应用些别人做好的补丁。本文介绍如何制作和应用补丁。^{[[#cite_note-0][[1]]]}

[[/wiki/File:Hint.gif][[[/images/7/7d/Hint.gif]]]]

*提示：*
本文目前的多数内容是对《Linux下patch的制作和应用》的修正、整理与重新排版。

| ** 目录                                                                    |
|                                                                            |
| -  [[#.E5.91.BD.E4.BB.A4.E7.AE.80.E4.BB.8B][1 命令简介]]                   |
|                                                                            |
|    -  [[#diff][1.1 diff]]                                                  |
|    -  [[#patch][1.2 patch]]                                                |
|    -  [[#.E5.BA.94.E7.94.A8][1.3 应用]]                                    |
|                                                                            |
| -  [[#patch.E6.96.87.E4.BB.B6.E6.9E.84.E6.88.90][2 patch文件构成]]         |
| -  [[#.E5.AE.9E.E4.BE.8B.E5.88.86.E6.9E.90][3 实例分析]]                   |
|                                                                            |
|    -  [[#.E5.8D.95.E6.96.87.E4.BB.B6.E8.A1.A5.E4.B8.81][3.1 单文件补丁]]   |
|    -  [[#.E6.96.87.E4.BB.B6.E5.A4.B9.E8.A1.A5.E4.B8.81][3.2 文件夹补丁]]   |
|                                                                            |
| -  [[#.E5.8F.82.E8.80.83.E8.B5.84.E6.96.99][4 参考资料]]                   |


*** 命令简介

用到的两个命令是diff和patch。

**** diff

*diff*可以比较两个东西，并可同时记录下二者的区别。制作补丁时的一般用法和常见选项为：

#+BEGIN_EXAMPLE
    diff 【选项】 源文件（夹） 目的文件（夹）
#+END_EXAMPLE

- -r :: 递归。设置后diff会将两个不同版本源代码目录中的所有对应文件全部都进行一次比较，包括子目录文件。
- -N :: 选项确保补丁文件将正确地处理已经创建或删除文件的情况。
- -u :: 输出每个修改前后的3行，也可以用-u5等指定输出更多上下文。
- -E, -b, -w, -B,
   --strip-trailing-cr :: 忽略各种空白，可参见文档，按需选用。

**** patch

*patch*的作用则是将diff记录的结果（即补丁）应用到相应文件（夹）上。最常见的用法为：

#+BEGIN_EXAMPLE
    patch -pNUM <patchfile>
#+END_EXAMPLE

- -p Num :: 忽略几层文件夹，随后详解。
- -E :: 选项说明如果发现了空文件，那么就删除它
- -R :: 取消打过的补丁。

为了解释 /-p/ 参数，需要看看如下patch文件片段：

#+BEGIN_EXAMPLE
    --- old/modules/pcitable       Mon Sep 27 11:03:56 1999
    +++ new/modules/pcitable       Tue Dec 19 20:05:41 2000
#+END_EXAMPLE

如果使用参数
*-p0*，那就表示从当前目录找一个叫做old的文件夹，再在它下面寻找
/modules/pcitable/ 文件来执行patch操作。
 而如果使用参数
*-p1*，那就表示忽略第一层目录（即不管old），从当前目录寻找 /modules/
的文件夹，再在它下面找pcitable。

**** 应用

利用以上命令，处理单个文件补丁的方法：

#+BEGIN_EXAMPLE
    # 产生补丁
    diff -uN from-file to-file >to-file.patch

    # 打补丁
    patch -p0 < to-file.patch

    # 取消补丁
    patch -RE -p0 < to-file.patch
#+END_EXAMPLE

对整个文件夹打补丁的情况：

#+BEGIN_EXAMPLE
    # 产生补丁
    diff -uNr  from-docu  to-docu  >to-docu.patch

    # 打补丁
    cd to-docu
    patch -p1 < to-docu.patch

    # 取消补丁
    patch -R -p1 <to-docu.patch
#+END_EXAMPLE

另外，使用版本控制工具时，可以直接用/svn diff/或/git diff/生成补丁文件。

值得一提的是，由于应用补丁时的目标代码和生成补丁时的代码未必相同，打补丁操作可能失败。补丁失败的文件会以.rej结尾，下面命令可以找出所有rej文件：

#+BEGIN_EXAMPLE
    find . -name '*.rej'
#+END_EXAMPLE

*** patch文件构成

补丁文件里到底存储了哪些信息呢？看看这个例子：

#+BEGIN_EXAMPLE
    --- test0       2006-08-18 09:12:01.000000000 +0800
    +++ test1       2006-08-18 09:13:09.000000000 +0800
    @@ -1,3 +1,4 @@
    +222222
     111111
    -111111
    +222222
     111111
#+END_EXAMPLE

- 补丁头 :: 补丁头是分别由---/+++开头的两行，用来表示要打补丁的文件。---开头表示旧文件，+++开头表示新文件。
- 一个补丁文件中的多个补丁 :: 一个补丁文件中可能包含以---/+++开头的很多节，每一节用来打一个补丁。所以在一个补丁文件中可以包含好多个补丁。
- 块 :: 块是补丁中要修改的地方。它通常由一部分不用修改的东西开始和结束。他们只是用来表示要修改的位置。他们通常以@@开始，结束于另一个块的开始或者一个新的补丁头。
- 块的缩进 :: 块会缩进一列，而这一列是用来表示这一行是要增加还是要删除的。
- 块的第一列 :: +号表示这一行是要加上的。-号表示这一行是要删除的。没有加号也没有减号表示这里只是引用的而不需要修改。

*** 实例分析

**** 单文件补丁

设当前目录有文件 *test0*：

#+BEGIN_EXAMPLE
    111111
    111111
    111111
#+END_EXAMPLE

和文件*test1*：

#+BEGIN_EXAMPLE
    222222
    111111
    222222
    111111
#+END_EXAMPLE

使用diff创建补丁*test1.patch*

#+BEGIN_EXAMPLE
    diff -uN test0 test1 > test1.patch
#+END_EXAMPLE

因为是单个文件，故不需要 -r 选项。此命令得到如下补丁：

#+BEGIN_EXAMPLE
    --- test0       2006-08-18 09:12:01.000000000 +0800
    +++ test1       2006-08-18 09:13:09.000000000 +0800
    @@ -1,3 +1,4 @@
    +222222
     111111
    -111111
    +222222
     111111
#+END_EXAMPLE

要应用补丁，只需：

#+BEGIN_EXAMPLE
    $ patch -p0 < test1.patch
    patching file test0
#+END_EXAMPLE

此时test0就和test1一样了。

如果要取消补丁做出的更改，恢复旧版本：

#+BEGIN_EXAMPLE
    $ patch -RE -p0 < test1.patch
    patching file test0
#+END_EXAMPLE

**** 文件夹补丁

设有如下环境：

#+BEGIN_EXAMPLE
    --prj0/
         test0
         prj0name
    --prj1/
         test1
         prj1name
#+END_EXAMPLE

/prj0/prj0name/内容为如下三行：

#+BEGIN_EXAMPLE
    --------
    prj0/prj0name
    --------
#+END_EXAMPLE

/prj1/prj1name/内容为如下三行：

#+BEGIN_EXAMPLE
    --------
    prj1/prj1name
    --------
#+END_EXAMPLE

用 /diff -uNr/ 创建补丁，

#+BEGIN_EXAMPLE
    diff -uNr prj0 prj1 > prj1.patch
#+END_EXAMPLE

得到的patch文件为：

#+BEGIN_EXAMPLE
    diff -uNr prj0/prj0name prj1/prj0name
    --- prj0/prj0name       2006-08-18 09:25:11.000000000 +0800
    +++ prj1/prj0name       1970-01-01 08:00:00.000000000 +0800
    @@ -1,3 +0,0 @@
    ---------
    -prj0/prj0name
    ---------
    diff -uNr prj0/prj1name prj1/prj1name
    --- prj0/prj1name       1970-01-01 08:00:00.000000000 +0800
    +++ prj1/prj1name       2006-08-18 09:26:36.000000000 +0800
    @@ -0,0 +1,3 @@
    +---------
    +prj1/prj1name
    +---------
    diff -uNr prj0/test0 prj1/test0
    --- prj0/test0  2006-08-18 09:23:53.000000000 +0800
    +++ prj1/test0  1970-01-01 08:00:00.000000000 +0800
    @@ -1,3 +0,0 @@
    -111111
    -111111
    -111111
    diff -uNr prj0/test1 prj1/test1
    --- prj0/test1  1970-01-01 08:00:00.000000000 +0800
    +++ prj1/test1  2006-08-18 09:26:00.000000000 +0800
    @@ -0,0 +1,4 @@
    +222222
    +111111
    +222222
    +111111
#+END_EXAMPLE

如果要应用此补丁，则：

#+BEGIN_EXAMPLE
    $ ls
    prj0  prj1  prj1.patch
    $ cd prj0
    $ patch -p1 < ../prj1.patch
    patching file prj0name
    patching file prj1name
    patching file test0
    patching file test1
#+END_EXAMPLE

此时可用[[/wiki/Ls][ls]]看到打补丁后的结果：

#+BEGIN_EXAMPLE
    $ ls
    prj1name  test1
#+END_EXAMPLE

类似的，如果要回滚补丁操作：

#+BEGIN_EXAMPLE
    $ patch -R -p1 < ../prj1.patch
    patching file prj0name
    patching file prj1name
    patching file test0
    patching file test1
    $ ls
    prj0name  test0
#+END_EXAMPLE

*** 参考资料

1. [[#cite_ref-0][↑]]
   [[http://www.cublog.cn/u/21948/showart_157145.html][Linux下patch的制作和应用]]

** [[http://tech.sina.com.cn/s/2012-03-16/14166844479.shtml#artibodyTitle][5款替代微软Visio的开源免费软件]]    :blog:

提到流程图和图表设计，自然会想到微软出品的Office Visio，它是一款强大的流程图设计工具。Visio并不在Office标准套装中，需要额外付费购买，这可能会带来某些不便。一方面，并不是所有人都负担得起，另外，如果是应急之需，临时购买恐怕也来不及了。

今天我们介绍几款免费的Visio替代软件，也许你对某些软件的名字感到陌生，现在我们逐一简要了解一下。

1、DIA Diagram Editor

Dia主界面Dia主界面
Dia被我们列在头一名，不仅是因为它功能强大和跨平台特性，也源于它原生支持简体中文界面。与Visio相比，Dia安装包仅不足20MB，可以放在网盘或U盘中随身携带。初用者可能觉得Dia用法比较繁琐而麻烦，但是无法否认，它仍然是综合性能最佳的免费替代方案。

Dia支持导出的流程图格式如下：EPS、SVG、DXF(Autocad格式)、CGM、WMF、PNG、JPEG、VDX(Microsoft Visio格式)。

优点：跨平台，支持简体中文界面

缺点：不易上手

下载：http://down.tech.sina.com.cn/content/41811.html

2、Open Office Draw

Open Office DrawOpen Office Draw
Linux用户对OpenOffice应该不会陌生，它是大名鼎鼎的开源办公套件，同时支持Windows和Mac。做为办公套件中的一部分，OpenOffice DRAW不仅免费提供，而且具备较为出色和相对完整的结构图表绘制功能，其最大绘图尺寸可达300cm x 300cm。绘图时产生的“对象”可以编组、分组、重组等操作，它也有些高级特性，例如支持渲染自定义贴图和模拟灯光效果，并能输出具备真实光感的高品质图形。OpenOffice DRAW支持大部分常见图像格式，我们还可以通过其内置的图形库获得大量免费图形素材。

优点：跨平台，简单易用

缺点：安装包较大

下载简体便携版：http://down.tech.sina.com.cn/content/37788.html

3、Inkscape

Inkscape主界面Inkscape主界面
又一款开源免费的矢量绘图软件，初看界面很像Photoshop，还是比较容易上手的，加上自带简体中文支持，对国人来说更是方便了。Inkscape支持节点编辑，可绘制复杂的路径和位图描摹。Inkscape比较突出的一大特点就是针对SVG的优化支持，它使用W3C标准的SVG文件格式，提供了众多高级特性，包括标记、克隆、Alpha融合、渐变、贴图，编组等等。

优点：跨平台，支持简体中文界面

缺点：流程图设计方面有待加强

下载：http://down.tech.sina.com.cn/content/16418.html

4、Graphviz

Graphviz绘制的复杂流程图Graphviz绘制的复杂流程图
Graphviz是大名鼎鼎的贝尔实验室的几位牛人开发的一个画图工具，历史比较久远了。它的软件设计理念和一般“所见即所得”的画图工具不一样，是“所想即所得”。Graphviz提供了DOT语言来编写绘图脚本。显然，这款软件并不适合一般用户，只适合那些对脚本语言代码较熟练的用户或是开发人员使用。

优点：使用脚本绘图，功能强大，支持SVG

缺点：无用户界面，不适合普通用户

下载：http://down.tech.sina.com.cn/content/53737.html

5、Kivio

Kivio主界面Kivio主界面
Kivio是开源办公套件KOffice的一部分，是一款强大的Linux图表和流程图绘制软件。它可以帮助你快速设计原型、线框图、流程图或是图表。Kivio有着与微软Visio类似的用户界面，但在用户界面上有所增强，允许使用分割窗格进行图形绘制。比较遗憾的是，Kivio目前只面向Linux用户。

其它功能：

支持使用Python脚本模板创作

与Dia模具兼容

优点：操作简单，界面清晰易懂

缺点：无Windows版本

下载：http://down.tech.sina.com.cn/content/35996.html

** [[][]]    :blog:

** [[http://www.seanet.com/~hgg9140/comp/diatut/all/all.html][Dia Tutorial]]    :blog:

Location: http://www.seanet.com/~hgg9140/comp/diatut/all/all.html
                                                      Dia Tuto

                                                    Dia Tutorial

                                                       [[http://www.lysator.liu.se/~alla/dia][Dia]]  [[http://www.gtk.org/][GTK+]]


           1. Copying

           Copyright (c) 2002 Harry George.

           Permission is granted to copy, distribute and/or modify this document under the terms of the
           GNU Free Documentation License, Version 1.1 or any later version published by the Free Software
           Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy
           of the license is included in the section entitled [[http://www.seanet.com/~hgg9140/comp/diatut/COPYING][GNU Free Documentation License]].

           2. Abstract

           This tutorial introduces [[http://www.lysator.liu.se/~alla/dia/][Dia]], the GTK-based GNU diagramming tool. We will install and configure
           the tool, then learn to use the basic shapes, then explore advanced features.

           3. Introduction

           From [[http://www.lysator.liu.se/~alla/dia/][Dia home]]:

               Welcome to Dia's homepage. Dia is a gtk+ based diagram creation program released under the
               GPL license.

               Dia is designed to be much like the commercial Windows program 'Visio'. It can be used to
               draw many different kinds of diagrams. It currently has special objects to help draw entity
               relationship diagrams, UML diagrams, flowcharts, network diagrams, and simple circuits. It
               is also possible to add support for new shapes by writing simple XML files, using a subset
               of SVG to draw the shape.

               It can load and save diagrams to a custom XML format (gzipped by default, to save space),
               can export diagrams to EPS or SVG formats and can print diagrams (including ones that span
               multiple pages).

           4. Installation

           See the current version's INSTALL file for requirements.

           To build dia, you need to install (in order):

             * From [[http://www.gtk.org/][GTK]]:
                 + glib
                 + gtk+
             * From: [[http://www.gnome.org][Gnome]] (optional):
                 + base libraries (installed in order per gnome instructions)
             * From [[http://www.lysator.liu.se/~alla/dia/][Dia]]:
                 + dia. If you installed gnome, configure with "--enable-gnome"

           Each of these is an autoconf-style install from sources. Binaries are available for some
           platforms. If you have a recent Linux installation, you may have all the pieces already.

           5. Basics

           5.1. Startup

           Once installed, the app is started with:

             dia

           This gives:

           mainwin.

           The first time up, you click File...Preferences and fill in personal choices. These are saved
           in your home dir as .dia/diarc. For example, I generally use the defaults except I make sure it
           is set to:

             * User Interface...
                 + Compress...no (so I can easily manipulate the UML models later. If I were worried about
                   space, I'd use "yes")
             * Grid lines...
                 + Visible...yes
                 + Snap to...yes

           After clicking OK on the preferences, you can make a diagram.

           5.2. New diagram

           Clicking File...New gives:

           newwin.p

           Right-clicking in that window gives a diagram-specific menu. From that select File...page
           setup:

           newpage.

           Typically:

             * Paper size: Use Letter for US printers.
             * Orientation: Use portrait for most web pages, and landscape for viewfoils
             * Margins: Leave as is. They resize for the paper size.
             * Scaling: Leave as Scale...100. However, we'll come back to this later.

           After clicking OK, the page setup goes away and you are ready to populate the diagram.

           5.3. Draw an Organization Chart

           An organization chart requires several boxes with text, some piped solid lines, and a few
           dashed lines. This can be done with the basic tools. So how do we use the basic tools?

           Notice the mainwindow's layout:

           layout.p

           If you hold the mouse over an icon, a tooltip will appear. If you click an icon, the tool is
           activated and any clicks in the diagram will provide a copy of that tool. After clicking and
           placing one or more copies of a shape, click the pointer tool (top left arrow icon) before
           attempting to move things around. (Otherwise you will get lots of unexpected shapes.)

           The easiest way to work is to:

            a. Select a shape
            b. Click approximately the right number of them onto your diagram.
            c. Label them (most shapes accept text labels).
            d. Move the shapes into place.
            e. Connect them with lines. Make sure the lines actually link to the shape handles.
            f. Label the lines as needed.
            g. Drag shapes and lines around as needed. Add connection points as needed to make tidy lines.
            h. Add/modify more shapes and lines as needed.

           For an org chart, we'll start with:

           org1.png

           That looks terrible. The text doesn't line up with the boxes, and the font is tacky. How can we
           fix it?

           5.4. Boxes and text

           We could use a box which knows about text, and resizes around text. The boxes in the Flowchart
           library (e.g., the square) can do this. We could even make our own shape which knows about
           text.

           But let's do it the hard way for now, with the basic box.

           First, get the font right. Select a text item. Right-click to get the menu, then
           Dialogs...Properties. Select Helvetica. Leave the size as is -- we can scale later. Do this for
           each text item.

           Next, carefully center the text in the box. Drag the box bigger if needed. Since the default is
           snap-to-grid, it will be difficult to align the text. So let's turn off snap-to-grid for a
           moment: With the pointer tool, click somewhere in the diagram (but not on a specific item), and
           type "g". Drag the text as needed, then type "g" again to toggle back to snap-to-grid.

           Ok, the text is the right font and is aligned nicely. Let's lock those box-and-text
           combinations together. Use the pointer to drag a selection box (dashed lines) around a
           box-and-text combo. Type "Ctl-G" to make them a group. Do this for each of the boxes.

           If you need to un-group a combo (e.g., to edit the text or realign), type "Ctl-U". For example,
           we notice misspellings, so we ungroup to fix those and then regroup.

           We now have:

           org2.png

           5.5. Lines

           Now we can draw some lines. We'll use the piped lines (90 degree turns). We draw them
           approximately from one item to the next, and then use the pointer to drag the ends directly to
           the handles at each end. The line end turns red when it locks in to a handle.

           We want to make the lines more interesting.

           In general, lines are controlled from the main window in several ways:

            a. Line color, via the foreground/background icon.
            b. Line width, via the vertical lines of varying width
            c. Line style (e.g., dotted, dashed), via the middle of the bottom row.
            d. Line end arrows, via the left and right ends of the bottom row.

           All of these apply to future lines. You can also modify an already-drawn line. Select it using
           the pointer. Right-click to get the diagram menu. Select Dialogs...properties. This brings up a
           dialog for changing any of the line's properties.

           Thus, to fix our current lines: For each line, select the line, right-click to get the menu,
           select Dialogs...Properties, and change the line width from 0.1 to 0.2. Change the System
           Architect-to-Project Manager line to dotted line. But the wide dots look odd, so we change to
           dashed lines. The dashes are too long, so we make the dash interval 0.5. The net effect is:

           org3.png

           Let's say the Systems Architect actually reports to the CIO (via a long chain of middle
           managers of course). We want to note that, but not over emphasize it. So we draw it in a thin
           line:

           org4.png

           Ugh. We want that line to go around the outside. But there aren't enough middle bending points
           in the line to do it. So we select the line and the middle-click, to get the add-segment
           dialog. After adding a segment or two, we can drag the line to make a nice connection:

           org5.png

           5.6. Saving

           Ok, the diagram looks pretty good. Time to save it. First, we want to save the intellectual
           content, so we can later modify it. Second, we want to export it as a specific graphic format.

           To save it, right-click for the menu, then File...Save. Insert the name, e.g., org.dia, and
           click OK. If you are saving a whole series of variants on the same file and need to save each
           to a separate file, use File...Save As. The file is saved in an XML format which is mostly
           Scalable Vector graphics (SVG). NOTE: Since we set Compress to No in the user preferences, we
           can examine the file in a text editor. Go take a look.

           To export a usable image, select File...Export, and then enter the name with an appropriate
           extension, e.g., org.png. Look at the extensions list for candidates. If you don't have a
           preference, we suggest png (Portable Network Graphics).

           A simple export may make a rather large image. If you look closely at the diagram window, you
           can see blue lines representing printable pages. Your diagram probably extends over several
           pages. So if you print out the diagram to a physical printer, you will need to tape the pieces
           together. This is not much of a concern for HTML, where the browser can pan back and forth over
           a large image. However, even for HTML a large image can be awkward.

           So here is the recommendation:

             * Build the diagram to any convenient size
             * Save it as is
             * Export it as is (full sized), for use in HTML links
             * Export another copy for directly embedding in an HTML page.

               Do this via File...Page setup...Scaling...Fit 1 by 1. This will show the scaling needed to
               fit the whole diagram on one page. But even that may be too large, so you can switch back
               to Scaling...Scale, and tweak the numbers until a convenient size is found for your HTML
               context.

           6. Advanced

           6.1. Layers

           6.1.1. Simple case

           Suppose we have four UML "class" objects, and want to draw a box around two of them. Doing so
           leaves the box on top and obstructs view of the two boxed classes. Putting the box in the
           background solves the problem.

           Putting an object in the background is done by first selecting it, and then:

            a. Long way: Right-click for menu...Objects...Send to back
            b. Shortcut: Ctl-B

           ../advan

           6.1.2. Full layering

           Now suppose we have a common background (e.g., project logo) and want to build our diagram on
           top of that. It is no longer convenient to do this object by object. Instead we want to
           establish the layers in advance and use them over time.

           If you are familiar with Gimp layers, you are in business -- it is the same mechanism.
           Otherwise, listen carefully.

           When you start a new diagram, after doing page setup, select right-click...Objects...layers.
           This gives:

           ../advan

           Click on the "new layer" icon (page with corner turned down), and you will get a "New layer".
           It is automatically placed above the Background layer. Click on the layer's name to select it.
           Once selected, you can move it relative to the other layers using the up and down arrows. Of
           course you should leave the Background layer at the bottom of the stack.

           Clicking on the eyeball next to a layer toggles whether or not it is visible in the diagram.
           Generally, you build each layer separately, with just it visible, but turn on all layers
           occasionally to check alignment.

           For our example, we put a text object which says "DRAFT" on the background layer. We make this
           text object grey using the color selector. Then we go to the new layer and make a diagram.
           Making both layers visible gives:

           ../advan

           6.2. Alignment

           Suppose we have several objects roughly aligned:

           ../advan

           We could very carefully drag them around to get them aligned. But a better approach is to use
           the alignment functions. Select the almost-vertically-aligned circles. Right-click to get the
           menu, then...Objects...Horizontal...center. This moves the objects horizontally until their
           centers are aligned vertically.

           Yes, it is a bit confusing: To align on a vertical axis, you have to select horizontal, because
           that is the axis on which the movement takes place.

           Similarly, to align objects along a single horizontal axis, you select
           Objects...Vertical...center. After aligning groups vertically and horizontally, we get:

           ../advan

           6.3. Selection

           The obvious ways to select are:

            a. With pointer, click on an item
            b. With pointer, and shift-button down, click on 1 or more items
            c. With pointer, drag dashed-line box around the items to be selected

           But you might want something fancier. In that case, Right-click to get the menu and then
           Select.... This gives the dialog:

           ../advan

           For example, applied to this diagram, after selecting the "A" object:

           ../advan

             * All: All boxes and lines are selected.

             * None: No boxes or lines are selected (e.g., A is also unselected)

             * Invert: Everything is selected except A

             * Connected: A and L1 and L3 are selected, because L1 and L2 are directly connected to A.

             * Transitive: A,B,C,D, and L1,L2,L3 are selected, because by following connections, you can
               reach each of these. E is left out because it cannot be reached.

             * Same Type: A,B,C,D,E are selected, because they are the same type of Dia object (i.e., all
               UML class objects).

           NOTE: If I ever figure out what the check boxes do, I'll let you know.

           6.4. Shape Libraries

           Dia comes with several shape libraries. It is also designed to allow you to add your own.

           These libraries are of course domain-specific, so their use should be described in other
           contexts (e.g., UML should be discussed in a tutorial on software engineering). Here we will
           concentrate on the mechanics of using the shape libraries.

           The libraries are saved in the share dir for wherever dia is installed. For example if which
           dia gives /usr/bin/dia, then we want to look at /usr/share.dia:

           /usr/share/dia/
             dia_logo.png         Dia's logo
             shapes/
               Flowchart/         objects, in paired files (icon and shape)
                 magdisk.xpm      icon
                 magdisk.shape    shape description
                 ...
             sheets/      object descriptions in various languages (XML)
               ER.sheet
               Flowchart.sheet
               UML.sheet
               ...

           For example, if we are interested in the Flowchart library, and specifically in the magnetic
           disk object, we find the magdisk.shape file:

           <?xml version="1.0"?>

           <shape xmlns="http://www.daa.com.au/~james/dia-shape-ns";
                  xmlns:svg="http://www.w3.org/TR/2000/03/WD-SVG-20000303/DTD/svg-20000303-stylable.dtd">;
             <name>Flowchart - Magnetic Disk</name>
             <description>Magnetic Disk</description>
             <icon>magdisk.xpm</icon>
             <connections>
               <point x="0"   y="2"/>
               <point x="2.5" y="0.4375"/>
               <point x="5"   y="0"/>
               <point x="7.5" y="0.4375"/>
               <point x="10"  y="0"/>
               <point x="0"   y="2.5"/>
               <point x="0"   y="7.5"/>
               <point x="0"   y="5"/>
               <point x="0"   y="10"/>
               <point x="10"  y="2.5"/>
               <point x="10"  y="5"/>
               <point x="10"  y="7.5"/>
               <point x="10"  y="10"/>
               <point x="2.5" y="11.5625"/>
               <point x="5"   y="12"/>
               <point x="7.5" y="11.5625"/>
             </connections>
             <textbox x1="0" y1="4" x2="10" y2="10"/>
             <svg:svg width="10" height="12">
               <svg:path d="M 0,2 c 2,-1.5 3,-2 5,-2 s 3,0.5 5,2 v 8
                            c -2,1.5 -3,2 -5,2 s -3,-0.5 -5,-2 v -8 z
                            M 0,2 c 2,1.5 3,2 5,2 s 3,-0.5 5,-2" style="fill: default"/>
             </svg:svg>
           </shape>

           Notice:

            a. The name value maps to the description lines in the Flowchart.sheet file

                   <object name="Flowchart - Magnetic Disk">
                     <description xml:lang="no">Magnetdisk</description>
                     <description xml:lang="fr">Disque Magn?tique</description>
                     <description xml:lang="de">Magnetdisk</description>
                     <description>Magnetic Disk</description>
                   </object>

               Thus, we get language-specific tooltips.

            b. The icon value is the file name of the icon shown on the main window.

            c. The shape is described by a Scalable Vector Graphics (svg) width/height and path.

            d. The location of connection points is given in the context of the width and height. You can
               add other connection points if you wish.

            e. The associated text field is also defined in the context of the width and height.
               Originally, it is under the magdisk object. You could move that to the middle of the
               magdisk object if you wished.

           You can make your own sheets/shapes by following the above patterns.

           Some shape libraries (e.g., UML) have associated processing and therefore are not just .shape
           files. To make your own library-with-processing requires going into the C code, and that is
           beyond the scope of this tutorial. (Perhaps embedded python will be supported in the future,
           simplifying even this adventure.)

           -----------------------------------------------------------------------------------------------
           Creator: [[mailto:hgg9140@seanet.com][Harry George]]
           Updated/Created: 2002-06-02

** [[http://www.cnblogs.com/xkfz007/articles/2182480.html][Linux 中将多个Word文档转换成PDF格式的方法及多个PDF文件的合并]]    :blog:

在Linux中常常涉及到多种文档格式，如doc、txt、html、rtf等等。为了方便文件传递，就可能需要在各种格式之间进行转换。OpenOffice.Org可以方便的打开多各文档格式并按需进行转换，但要一次处理大量文件或要编写脚本进行转换时，仅用OpenOffice就难以胜任了。
用unoconv就可以轻松地实现用OpenOffice可以打开的文档的转换.
首先下载安装unoconv采用下面任一种方法:
1)到 http://dag.wieers.com/home-made/unoconv/ 下载,再安装.
2) yum install unoconv

然后就可以用命令
unoconv -f pdf myDoc.doc
进行转换了.以上命令即会生成一个名为 myDoc.pdf 的 pdf 文件。

批量转换需要结合find命令或脚本使用，使用时需注意最好使用C/S模式以加快速度：
unoconv --listener &
unoconv -f pdf some-document.odt
unoconv -f doc other-document.odt
unoconv -f jpg some-image.png
unoconv -f xsl some-spreadsheet.csv

多个PDF文件的合并:
gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=out.pdf  *.pdf
就会生成一个名为out.pdf的文件.但要保证当前目录下没有out.pdf这个文件.


** [[http://www.zhixing123.cn/ubuntu/draw-figures-and-store-using-gnuplot.html][gnuplot绘制图像并保存]]    :blog:


对于在Linux下工作的人，如果你经常要画一些二维图和简单的三维图的话，那么，gnuplot无疑是一个非常好的选择，不仅图形漂亮，而且操作简单。当然如果需要质量更高的三维图，请用其他的一些专业绘图软件。建议大家学会使用gnuplot。这个小软件通常都是Redhat Linux自带的，但自带的版本是3.7的，建议将其升级到4.0，新版本具有很多新功能。最新版本可以到http://www.gnuplot.info/下载。
一些最基本的操作请大家看说明书。这里总结一下我在使用过程中遇到的一些问题以及解决的办法，目的是让那些以前不会的或不熟练的能快速入门，会画自己想要 的图，因为原来的说明书很长，较难有针对性地很快找到自己想要的信息。这里简单的总结不可能面面俱到，所以大家不要抱怨我写的不全，更全面的了解还是请看 说明书，网上的资料也多的是。其实这也是我们从网上一点一点搜集和摸索出来的。我相信看完后，应该平时最常见的问题基本上都能在这里找到答案。如果大家在 使用过程中摸索到了我没有写到的技巧和体会，或有其它建议，请大家提告诉我，以不断完善这篇总结，谢谢！
一、基础篇
在linux命令提示符下运行gnuplot命令启动，输入quit或q或exit退出。
1、plot命令
gnuplot> plot sin(x) with line linetype 3 linewidth 2 或
gnuplot> plot sin(x) w l lt 3 lw 2    %用线画，线的类型（包括颜色与虚线的类型）是3，线的宽度是2，对函数sin(x)作图
gnuplot> plot sin(x) with point pointtype 3 pointsize 2  或
gnuplot> plot sin(x) w p pt 3 ps 2    %用点画，点的类型（包括颜色与点的类型）是3，点的大小是2
gnuplot> plot sin(x) title ‘f(x)’ w lp lt 3 lw 2 pt 3 ps 2    %同时用点和线画，这里title ‘f(x)’表示图例上标’f(x)’，如果不用则用默认选项
gnuplot> plot sin(x)    %此时所有选项均用默认值。如果缺某一项则将用默认值
gnuplot> plot ‘a.dat’ u 2:3  w l lt 3 lw 2 %利用数据文件a.dat中的第二和第三列作图
顺便提一下，如这里最前面的两个例子所示，在gnuplot中，如果某两个词，按字母先后顺序，前面某几个字母相同，后面的不同，那么只要写到第一个不同的字母就可以了。如with，由于没有其它以w开头的词，因此可以用 w 代替，line也可以用 l 代替。
2、同时画多条曲线
gnuplot> plot sin(x) title ‘sin(x)’ w l lt 1 lw 2, cos(x) title ‘cos(x)’  w l lt 2 lw 2  ％两条曲线是用逗号隔开的。画多条曲线时，各曲线间均用逗号隔开就可以了。
以上例子中是对函数作图，如果对数据文件作图，将函数名称换为数据文件名即可，但要用单引号引起来。
3、关于图例的位置
默认位置在右上方。
gnuplot> set key left  %放在左边，有left 和right两个选项
gnuplot> set key bottom  %放在下边，只有这一个选项；默认在上边
gnuplot> set key outside  %放在外边，但只能在右面的外边
以上三个选项可以进行组合。如：
gnuplot> set key left bottom  %表示左下边
还可以直接用坐标精确表示图例的位置，如
gnuplot> set key 0.5,0.6  %将图例放在0.5,0.6的位置处
4、关于坐标轴
gnuplot> set xlabel ‘x’   %x轴标为‘x’
gnuplot> set ylabel ‘y’   %y轴标为’y’
gnuplot> set ylabel ‘DOS’ tc lt 3  %其中的tc lt 3表示’DOS’的颜色用第三种颜色。
gnuplot> set xtics 1.0    %x轴的主刻度的宽度为1.0，同样可以为y轴定义ytics
gnuplot> set mxtics 3    %x轴上每个主刻度中画3个分刻度，同样可以为y轴定义mytics
gnuplot> set border 3 lt 3 lw 2 %设为第三种边界，颜色类型为3，线宽为2
同样可以为上边的x轴（称为x2）和右边y（称为y2）轴进行设置，即x2tics，mx2tics，y2tics，my2tics。
gnuplot> set xtics nomirror
gnuplot> unset x2tics     %以上两条命令去掉上边x2轴的刻度
gnuplot> set ytics nomirror
gnuplot> unset y2tics     %以上两条命令去掉右边y轴的刻度
5、在图中插入文字
gnuplot> set label ‘sin(x)’ at 0.5,0.5  %在坐标（0.5,0.5）处加入字符串’sin(x)’。
在输出为.ps或.eps文件时，如果在set term 的语句中加入了enhanced选现，则可以插入上下标、希腊字母和特殊符号。上下标的插入和latex中的方法是一样的。
6、在图中添加直线和箭头
gnuplot> set arrow from 0.0,0.0 to 0.6,0.8    %从（0.0,0.0）到（0.6,0.8）画一个箭头
gnuplot> set arrow from 0.0,0.0 to 0.6,0.8 lt 3 lw 2   %这个箭头颜色类型为3，线宽类型为2
gnuplot> set arrow from 0.0,0.0 to 0.6,0.8 nohead lt 3 lw 2  %利用nohead可以去掉箭头的头部，这就是添加直线的方法。
注意，在gnuplot中，对于插入多个的label和arrow等等，系统会默认按先后顺序分别对各个label或arrow进行编号，从1开始。如果以后要去掉某个label或arrow，那么只要用unset命令将相应的去掉即可。如：
gnuplot> unset arrow 2
将去掉第二个箭头。
7、图的大小和位置
gnuplot>set size 0.5,0.5  %长宽均为默认宽度的一半，建议用这个取值，尤其是画成ps或eps图形的时候
gnuplot>set origin 0.0,0.5   %设定图的最左下角的那一点在图形面板中的位置。这里图将出现在左上角。
8、画三维图
gnuplot>splot ‘文件名’ u 2:4:5  %以第二和第四列作为x和y坐标，第五列为z坐标。
9．将图形输出到文件
在gnuplot中，输出文件的格式是由terminal来控制的。默认的情况下，都是输出到屏幕，即终端模式为X11。如果想输出到文件，则必须对 terminal进行设置。要了解有那些终端类型，可以输入 set terminal后回车，所有支持的终端模式（或文件格式）都列出来了。就我来说，输出文件的格式用得最多的是ps和eps文件。这在运行画图命令 plot或splot前必须先运行如下两条命令：
gnuplot>set term post eps color solid enh
gnuplot>set output ‘a.eps’
其中第一条命令为设置终端模式，post即为postscript模式，这是输出到ps或eps文件必须有的。后面的eps，color，solid以及 enh选项均可以有或没有，根据你的需要。eps表示输出为eps文件，没有就输出为ps文件；color表示输出图形为彩色，不用就会保存为黑白 的；solid表示输出图中的所有线都用实线，不用则除了第一条线为实线外，其它的均用不同的虚线；使用enh(enhanced)选项可以在图中插入上 下标、希腊字母和特殊符号，不用则不能实现这些功能。后面的选项可以根据自己的需要选择一个或几个。
第二条命令对output的设置表示要输出的文件的名字。但是请注意，运行完这条命令后，还仅仅是定义了输出文件的名字，实际上，图还没画到这个文件里去。因此运行这两条命令还只是进行了必须的设置。然后运行如下命令
gnuplot>plot sin(x) w l
或
gnuplot>replot（假如前面已经运行过plot或replot命令的话）
这时，图形就在上面指定的文件中了。
要输出为其它格式，同样要进行这样的设置，比如要输出为jpg格式，则在运行画图命令前先运行如下命令：
gnuplot>set term jpeg
gnuplot>set output ‘a.jpg’
如果要由其它模式再返回到输出到屏幕，则运行如下命令：
gnuplot>set term X11
二、提高篇
1、如何在同一张图里同时画多个图
gnuplot>set multiplot   %设置为多图模式
gnuplot>set origin 0.0,0.5   %设置第一个图的原点的位置
gnuplot>set size 0.5,0.5  %设置第一个图的大小
gnuplot>plot “a1.dat”
gnuplot>set origin 0.5,0.5   %设置第二个图的原点的位置
gnuplot>set size 0.5,0.5   %设置第二个图的大小
gnuplot>plot “a2.dat”
gnuplot>set origin 0.0,0.0   %设置第三个图的原点的位置
gnuplot>set size 0.5,0.5  %设置第三个图的大小
gnuplot>plot “a3.dat”
gnuplot>set origin 0.5,0.0   %设置第四个图的原点的位置
gnuplot>set size 0.5,0.5  %设置第四个图的大小
gnuplot>plot “a4.dat”
当然，如果后一个图中的某个量的设置和前一个的相同，那么后一个中的这个量的设置可以省略。例如上面对第二、第三和第四个图的大小的设置。前一个图中对某个量的设置也会在后一个图中起作用。如果要取消在后面图中的作用，必须用如下命令，如取消label，用
gnuplot>unset label
2、作二维图时，如何使两边坐标轴的单位长度等长
gnuplot> set size square    %使图形是方的
gnuplot> set size 0.5,0.5    %使图形是你要的大小
gnuplot> set xrange[-a:a]
gnuplot> set yrange[-a:a]    %两坐标轴刻度范围一样
gnuplot> plot ‘a.dat’
3、如何在同一张图里利用左右两边的y轴分别画图
gnuplot> set xtics nomirror   %去掉上面坐标轴x2的刻度
gnuplot> set ytics nomirror   %去掉右边坐标轴y2的刻度
gnuplot> set x2tics       %让上面坐标轴x2刻度自动产生
gnuplot> set y2tics     %让右边坐标轴y2的刻度自动产生
gnuplot> plot sin(x),cos(x) axes x1y2    %cos(x)用x1y2坐标，axes x1y2表示用x1y2坐标轴
gnuplot> plot sin(x),cos(x) axes x2y2     %cos(x)用x2y2坐标，axes x2y2表示用x2y2坐标轴
gnuplot> set x2range[-20:20]   %设定x2坐标的范围
gnuplot> replot
gnuplot> set xrange[-5:5]  %设定x坐标的范围
gnuplot> replot
gnuplot> set xlabel ‘x’
gnuplot> set x2label ‘t’
gnuplot> set ylabel ‘y’
gnuplot> set y2label ‘s’
gnuplot> replot
gnuplot> set title ‘The figure’
gnuplot> replot
gnuplot> set x2label ‘t’ textcolor lt 3    %textcolor lt 3或tc lt 3设置坐标轴名称的颜色
4、如何插入希腊字母和特殊符号
一般只能在ps和eps图中，且必须指定enhanced选项。在X11终端（即显示器）中无法显示。
gnuplot> set terminal postscript enhanced
然后希腊字母就可以通过{/Symbol a}输入。例如
gnuplot> set label ‘{/Symbol a}’
各种希腊字母与特殊符号的输入方法请见安装包中gnuplot-4.0.0/docs/psdoc目录下的ps_guide.ps文件。
另外还可参见：
http://t16web.lanl.gov/Kawano/gnuplot/label-e.html#4.3
5、gnuplot中如何插入Angstrom（埃）这个符号(A上面一个小圆圈)
脚本中在插入前先加入
gnuplot>set encoding iso_8859_1
这个命令，然后就可以通过“{\305}”加入了。如横坐标要标上“k(1/?)”：
gnuplot>set xlabel ‘k(1/{\305})
如果是multiplot模式，则这个命令必须放在
gnuplot>set multiplot
的前面。
如果后面还要插入别的转义字符，那么还要在插入字符后加入如下命令：
set encoding default
安装包中gnuplot-4.0.0/docs/psdoc/ps_guide.ps文件中的表中的‘E’代表那一列的所有符号都用这个方法输入。
6、gnuplot画等高线图
gnuplot>splot  ‘文件名.dat’  u 1:2:3  w  l   %做三维图
gnuplot>set dgrid3d 100,100 %设置三维图表面的网格的数目
gnuplot>replot
gnuplot>set contour    %设置画等高线
gnuplot>set cntrparam  levels  incremental -0.2,0.01,0.2   %设置等高线的疏密和范围，数据从   -0.2到0.2中间每隔0.01画一条线
gnuplot>unset surface   去掉上面的三维图形
最后用鼠标拽动图形，选择合理的角度即可。或者直接设置(0,0)的视角也可以：
gnuplot>set view 0,0
gnuplot>replot
这里注意，画三维图的数据文件必须是分块的，也就是x每变换一个值，y在其变化范围内变化一周，这样作为一块，然后再取一个x值，y再变化一周，作为下一数据块，等等。块与块之间用一空行格开。
7、如何画漂亮的pm3d图
gnuplot> set pm3d                %设置pm3d模式
gnuplot> set isosamples 50,50       %设置网格点
gnuplot> splot x**2+y**2          ％画三维图
gnuplot> splot x**2+y**2 w pm3d   ％画成pm3d模式，注意比较变化
gnuplot> set view 0,0              ％设置视角，（0，0）将投影到底面上去
gnuplot> splot x**2+y**2 w pm3d   ％重画，注意看变化
gnuplot> unset ztics               %把z轴上的数字给去掉
gnuplot> set isosamples 200,200     ％使网格变细
gnuplot> replot                   ％重画，注意看变化，主要是过渡更光滑
8、利用脚本文件避免重复输入
有时候对某个数据文件做好一张图后，下次可能还要利用这个数据文件作图，但某个或某些设置要作些细微变化。这时候，可以把第一次作图时的命令全部写到一个文件里，如a.plt，下次只要将相应的设置做修改后，用下面的命令就会自动运行文件所有的命令而最后得到你要的图：
gnuplot>load ‘a.plt’
作为一个例子，假设文件名为a.plt，里面的内容为：
set pm3d
set view 0,0
unset ztics
set isosamples 200,200
splot x**2+y**2 w pm3d
set term post color
set output ‘a.ps’
replot
那么启动gnuplot后，只要运行如下命令就可以了：
gnuplot>load ‘a.plt’
如果我们要得到的仅仅是.ps或.eps图，那也可以在linux命令提示符下直接运行如下命令：
[zxh@theory zxh]$gnuplot a.plt
9、在gnuplot模式下运行linux命令
在gnuplot提示符下也可以运行linux命令，但必须在相应的命令前面加上 ! 号。例如，假设很多参量都已经设置好了，但需要对某个数据文件a.dat进行修改后再画图，则可以用如下方式
gnuplot>!vi a.dat
通过这种方式，所有的linux命令都可以在gnuplot环境里运行。
另外，也可以在gnuplot的提示符后输入shell，暂时性退出gnuplot，进入linux环境，做完要做的事情后，运行exit命令，又回到gnuplot环境下。
gnuplot>shell
[zxh@theory zxh]$vi a.f
[zxh@theory zxh]$f77 a.f
[zxh@theory zxh]$a.out    (假设生成a.dat数据文件)
[zxh@theory zxh]$exit
gnuplot>plot ‘a.dat’

** [[http://blog.chinaunix.net/uid-488742-id-2113697.html][Ubuntu中安装PDF虚拟打印机 ]]    :blog:

为了保存一些网页文档，通常在WIN下我们都是利用MS Office自带的PDF打印机打印成PDF格式文档。
当然，在无所不能的Ubuntu下，也是有这样的工具的哦。尤其可以解决Linux和WIN下文档不兼容的问题。
用PDF格式互通文件该是非常不错的吧。
1. 安装cups 和cups-pdf
sudo apt-get install cups-pdf
2. 设置cups-pdf 的 backend root 权限
sudo chmod 4755 /usr/lib/cups/backend/cups-pdf
3.通过 系统-系统管理-打印 启动打印机配置向导
4.右键 “新建打印机” 图表-添加 开始添加打印机
5. 使用检测到的打印机 -选择 PDF Printer-前进
6. 制造商 选择 Generic-PostScript -前进
7. 添入打印机的名称。
8.完成。
现在你就可以用虚拟打印机将你需要的文档打印成PDF格式了。
PS:
sudo gedit /etc/cups/cups-pdf.conf
找到Out开头，就可以修改默认保存文件夹了。
其实gedit ，gThumb都能直接打印成PDF文档，但是打印网页什么的，还是安个虚拟打印机比较方便。而且这个只有几十K那么大！
实在是好东西。
还有，打印快捷键是Ctrl＋P

** [[https://app.yinxiang.com/Home.action#n=105bfce9-941a-454c-acc1-26d67434c546&b=f3a3ebdb-638e-4fde-8608-34ae1b790adc&ses=4&sh=1&sds=5&][如何把NH、KDH文件转换为PDF或者WORD文档]]    :blog:

在做毕业论文时不可避免的要下载中国期刊网上面的论文，这些文件又需要专门的阅读器，而大家更常用的文档格式是PDF或者WORD文档，不利于个人阅读，虽然CAJ浏览器可以把NH、KDH文件如何转成 txt格式，但是会出现乱码，并且不能转换图片；下面是转换这类文档的个人经验：
1. 转换成PDF文档
首先用高版本的CAJ浏览器打开文档，然后选择打印，在打开的“打印”设置窗口中将“打印机”栏中的“名称”设置为“*** PDF printer”字样，安装不同的PDF 阅读器，前面的单词不同，接下来设置打印属性，向平时打印一样，一般默认，最后点击“确定”，OK，耐心等待文档转换吧。
2. 转换成WORD文档
方法一
1、.若安装有PDF Professional，按照上述方法先转换成PDF文档，再把所得到的文件直接另存为WORD文档(.DOC)。
2.、若你的PDF阅读器不能把文档直接保存为WORD文档,使用第三方软件：PDF WORD 转换软件 如pdf2word和pdf to word
方法二
第一步：首先使用CAJ浏览器打开文档，接下来选择打印，在打开的“打印”设置窗口中将“打印机”栏中的“名称”设置为“Microsoft Office Document Image Writer”，确认后将该NH文件输出为MDI格式的虚拟打印文件。
提示：如果你在“名称”设置的下拉列表中没有找到“Microsoft Office Document Image Writer”项，那证明你在安装Office 2003的时候没有安装该组件，请使用Office 2003安装光盘中的“添加/删除组件”更新安装该组件。

第二步：运行Microsoft Office Document Imaging，并利用它来打开刚才保存的MDI文件，选择“工具→将文本发送到Word”菜单，并在弹出的窗口中勾选“在输出时保持图片版式不变”，确 认后系统提示“必须在执行此操作前重新运行OCR。这可能需要一些时间”，确认即可。

好象CAJ5.0以上版本可以转换为WORD文档,只是不可以转换图象，公式，图表，但是您可以用“复制图位”按钮，以图象方式复制到WORD文档.
CAJ支持另存为TXT，操作在“文件”选项里，但TXT为文本文件，不能保存图片，公式，图表等，可由TXT转为DOC后，通过“复制图位”按钮，以图象方式复制到WORD文档中去。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

方法四：
首先到中国知网（www.cnki.net） 下载CAJViewer阅读器，安装CAJViewer阅读器软件。运行CAJViewer阅读器并点击“文件”打开.CAJ、.NH、.KDH等格式文 件。接下来选择“文件→打印”菜单，在打开的“打印”设置窗口中将“打印机”栏中的“名称”设置为“Microsoft Office Document Image Writer”，确认后将.CAJ、.NH、.KDH等格式文件输出为MDI格式的虚拟打印文件。

（如果 你在“名称”设置的下拉列表中没有找到“Microsoft Office Document Image Writer”项，那证明你在安装Office 2003的时候没有安装该组件，请使用Office 2003安装光盘中的“添加/删除组件”更新安装该组件。）

运行Microsoft Office Document Imaging，并利用它来打开刚才保存的MDI文件，选择“工具→将文本发送到Word”菜单，并在弹出的窗口中勾选“在输出时保持图片版式不变”，确 认后系统提示“必须在执行此操作前重新运行OCR。这可能需要一些时间”，不用管它，点确认即可。
（目前，包括此工具在内的所有软件对PDF转DOC的识别率都不是特别完美，而且转换后会丢失原来的排版格式，所以大家在转换后还需要手工对其进行后期排版和校对工作。）

大功告成！补充一下，PDF格式文件也可以按照上面的方法转换成DOC格式文件。

还有一个方法如下所述：
首先用CAJViewer7.02版本阅读器打开nh文件，在你当前打开页的左上方有个保存为图片的按钮
， 把当前页面保存为图片。然后下载安装一个汉王6.0，安装好后打开。注意，此软件安装好后没有快捷方式，需要按照下面的步骤打开：开始--程序--汉王 ocr6.0--汉王ocr6.0.打开后按照下面的操作就可以识别图片，转换成文字。文件--打开图像--识别--开始识别--输出--到指定格式文 件，保存为txt文件就可以了。现在打开刚刚保存的文件，是不是看见文字转换好了！
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
百度知道的回答
如何将ＮＨ格式文件转为ＷＯＲＤ或文本文件？

我下载了一个ＮＨ格式的文件，现在想对其进行复制其中的一些内容．我从网上搜了一下，有的说先转成ＰＤＦ然后再编辑，也有的说从ＣＡＪ里可以识别后编辑．前一种方法，我从网上未找到相关软件，后一种方法我从ＣＡJ6.0中选中文字，右键文字识别，可识别不出来，一片空白．请大家帮帮忙．谢谢．
呵呵，自己找到答案了，
还是用的ＣＡＪ软件，7.0的，在http://www.cnki.net/software/xzydq.htm
这个网站上下的标准版的，呵呵，在线客服帮的忙．
看到许多人在找PDF转Word的软件，感觉大可不必，其实很多这类软件转换后是变成rtf格式，里边文字变得很小很难看，还得手动调字体，调格式。
    Word自身已经提供了任何文档文件转文字的功能，说白了就是Word自身的OCR工具。PDF、NH、CAJ等常用文档文件都可以通过此方法进行转换。以PDF为例，打开PDF文件后直接选择打印，打印机选择使用Microsoft Office Document Image Writer，这是Office自带的虚拟图像打印工具。确定之后自动存储为mdi文件。它默认会自动启动。此时可以继续另存为图片文件，用其他OCR工具识别，也可以在启动后的界面里直接选择工具－－将文本发送到word，选择一个存储的位置，确认后word会自动进行识别，稍等片刻一篇已经识别好的文本就出现了，并且文本字体十分清楚。相比其他识别工具，word的识别正确率非常高。
    当然，缺点是图片和表格框无法识别，但这也是其他软件的软肋，即便是rtf文件，表格也不那么正规。相比那么多的文本，这也不算什么了吧。
    除此以外，AutoCAD的打印以及其他程序都可以使用此功能

** [[http://blog.csdn.net/wangjunjun2008/article/details/21982843][tar 建立档案文件]]    :blog:

【语法】 tar [option] tarfile filename

【命令说明】

文件名必须紧跟在-f参数后,且作为参数的最后一项;

【参数说明】

-c 建立一个新的档案文件;

-f 指定档案文件名;

-r 往归档文件中追加文件;

-x 从档案文件中提取文件;

-v,-vv 显示进度信息;

-t 列出存档文件的信息(不提取);

-C 指定文件提取的目录;

-A 合并多个tar文件;

--totals 归档完成后,打印总归档字节数;

--delete 从归档文件中删除指定的文件;

--exclude 归档时,排除指定样式的文件;

-j 生成归档文件时,使用bunzip2格式进行压缩;

-z 生成归档文件时,使用gzip格式进行压缩;

--lzma 生成归档文件时,使用lzma格式进行压缩;

-a 生成归档文件时,根据扩展名自动进行压缩;



【一般用法】

#打tar包,名称为all.tar

$ tar -cvf all.tar *.text;

#追加文件b.doc

$ tar -rvf all.tar b.doc;

#列出归档文件中的内容

$ tar -tvf all.tar;

#提取归档文件中的全部文件

$ tar -xvf all.tar;

$ tar -xvf all.tar -C /opt/app/tool_dir;

#提取归档文件中的指定文件

$ tar -xvf all.tar file_one file_two

#合并两个tar文件

$ tar -Af file_one.tar file_two.tar

#删除指定的文件

$ tar -f all.tar --delete file_one file_two

#归档时,排除日志文件

$ tar -cf all.tar * --exclude ”*.log”





*gzip/gunzip 进行压缩/解压缩*

【语法】

gzip [options] file;

gunzip [options] file;

【命令说明】

gzip只能压缩单个文件,如果指定多个文件,则会生成多个单独的压缩文件;

gzip会在生成压缩文件后,删除源文件!!!!

gunzip会在解压缩完成后,删除源文件!!!

【参数说明】

-l,--list 列出压缩文件的属性信息;

--fast 指定最低压缩比;

--best 指定最高压缩比;

-n 指定压缩比(n为数字,且1<=n<=9);

-v 显示进度信息;





*bzip2/bunzip2 进行压缩/解压缩*

【语法】

bzip2 file;

bunzip2 file;

【命令说明】

bzip2通常能生成比gzip压缩比更高的文件;默认bzip2会删除源文件,可使用-k参数保留源文件;

【参数说明】

-k 保留源文件;

-n 指定压缩比(n为数字,且1<=n<=9);





*zip/unzip 进行压缩/解压缩*

【语法】 zip [options] file file dirs

【命令说明】

zip压缩/解压缩后,不会删除源文件;

【参数说明】

-r 递归;压缩目录时使用;

-l 列出压缩文件内容;

-d 从压缩文件中删除指定文件;

-u 更新压缩文件的内容;



【一般用法】

#压缩文件

$ zip all.zip file;

$ zip all.zip file_one file_two;

$ zip -r all.zip dir_name;

#更新压缩文件

$ zip all.zip -u log.text

#删除指定的内容

$ zip -d all.zip log.text;



#解压文件

$ unzip all.zip;

#列出压缩文件内容

$ unzip -l all.zip;

** [[http://www.lampweb.org/linux/3/18.html][patch 修补文件（给文件打补丁）]]    :blog:

*功能*：修补文件。使用补丁文件，对源文件进行更改。更改方式根据参数来设定。
倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行。如果配合修补文件的方式则能一次修补大批文件。

#+BEGIN_EXAMPLE
    语法：patch   [OPTION]   [ORIGFILE]  [PATCHFILE]
#+END_EXAMPLE



输入选项

-p NUM

--strip=NUM

去除相对路径层次的数目

-F LINES

--fuzz LINES

设置监别列数

-l

--ignore-whitespace

忽略修补数据与输入数据的跳格，空格字符

-c

--context

把修补数据解译成关联性的差异

-e

--ed

把修补数据解译成ed指令可用的叙述文件

-n

--normal

把修补数据解译成一般性的差异

-u

--unified

把修补数据解译成一致化的差异

-N

--forward

忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使用过

-R

--reverse

假设修补数据是由新旧文件交换位置而产生

-i PATCHFILE

--input=PATCHFILE

读取指定的修补文件

输出选项

-o FILE

--output=FILE

设置输出文件的名称，修补过的文件会以该名称存放

-r FILE

--reject-file=FILE

Output rejects to FILE

-D NAME

--ifdef=NAME

用指定的符号把改变的地方标示出来

-m

--merge

Merge using conflict markers instead of creating reject files

-E

--remove-empty-files

若修补过后输出的文件其内容是一片空白，则移除该文件

-Z

--set-utc

把修补过的文件更改，存取时间设为UTC

-T

--set-time

此参数的效果和指定"-Z"参数类似，但以本地时间为主



--quoting-style=WORD

使用WORD引述类型显示项目名称,可设定值有literal,shell,shell-always,c,escape

备份和版本控制选项

-b

--backup

备份每一个原始文件



--backup-if-mismatch

在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件



--no-backup-if-mismatch

在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件

-V STYLE

--version-control=STYLE

用"-b"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用"-z"参数变更，
当使用"-V"参数指定不同备份方式时，也会产生不同字尾的备份字符串

-B PREFIX

--prefix=PREFIX

设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称

-Y PREFIX

--basename-prefix=PREFIX

设置文件备份时，附加在文件基本名称开头的字首字符串

-z SUFFIX

--suffix=SUFFIX

此参数的效果和指定"-B"参数类似，差别在于修补作业使用的路径与文件名若为src/linux/fs/super.c，
加上"backup/"字符串后，文件super.c会备份于/src/linux/fs/backup目录里

-g NUM

--get=NUM

设置以RSC或SCCS控制修补作业

其他选项

-t

--batch

自动略过错误，不询问任何问题

-f

--force

此参数的效果和指定"-t"参数类似，但会假设修补数据的版本为新版本

-s

--quiet或--silent

不显示指令执行过程，除非发生错误



--verbose

显示详细的过程信息



--dry-run

实际上不改变任何文件；演示讲会发生什么



--posix

符合POSIX标准

-d DIR

--directory=DIR

先改变工作目录到指定的目录



--reject-format=FORMAT

Create 'context' or 'unified' rejects



--binary

以二进制方式读写数据



--read-only=BEHAVIOR

如何处理只读输入文件：“忽视”，他们是只读的，“警告”（默认），或“失败”



#+BEGIN_QUOTE

  -  patch 命令（默认）使用从标准输入读入的源文件 *< PATCHFILE*
     ，但是使用 -i  /PATCHFILE/ 设置。
  -  源文件包含由 diff 命令产生的差别列表（或者 diff
     列表）。差异列表是比较两个文件和构建关于如何纠正差别的指示信息的结果。
  -  差异列表有三种格式：正常、上下文或者是 ed 编辑器风格。patch
     命令确定差异列表格式，除非被 -c、-e 或 -n 标志否决。
  -  默认，/ORIGFILE/ 被/PATCHFILE/
     替换。若/ORIGFILE/（原始文件）不存在时，/PATCHFILE/（补丁文件）根据差别列表，创建
     /ORIGFILE/ 文件。
  -  指定 -b
     标志时，/ORIGFILE/（原始文件）会备份在自身的文件中，只是在文件名后附加了后缀
     .orig。使用 -o 标志也可以指定输出的目的地。
#+END_QUOTE

patch常用选项：
 -r
是一个递归选项，设置了这个选项，diff会将两个不同版本源代码目录中的所有对应文件全部都进行一次比较，包括子目录文件。
 -N 选项确保补丁文件将正确地处理已经创建或删除文件的情况。
 -u 选项以统一格式创建补丁文件，这种格式比缺省格式更紧凑些。
 -p0 选项从当前目录查找目的文件（夹）(直接使用补丁文件里面指定的路径)
 -p1
选项忽略掉第一层目录，从当前目录查找(去掉补丁文件指定路径最左的第1个'/'及前面所有内容)。
 -E  选项说明如果发现了空文件，那么就删除它
 -R
 选项说明在补丁文件中的“新”文件和“旧”文件现在要调换过来了（实际上就是给新版本打补丁，让它变成老版本）



**** svn生成补丁文件和打补丁文件

#+BEGIN_EXAMPLE
    生成补丁文件：
    svn diff > patchFile  整个工程的变动生成补丁
    或 svn diff file > patchFile  某个文件单独变动的补丁

    svn回滚：
    svn revert FILE   单个文件回滚
    svn revert DIR --depth=infinity   整个目录进行递归回滚

    打patch：
    patch -p0 < test.patch   -p0 选项要从当前目录查找目的文件

    patch -p1 < test.patch  -p1 选项要从当前目录查找目的文件，不包含patch中的最上级目录
    例如两个版本以a,b开头，而a,b并不是真正有效地代码路径，则这时候需要使用"-p1"参数。
    a/src/...
    b/src/...
#+END_EXAMPLE

** [[http://www.jincon.com/archives/248][linux系统下Imagemagick的convert图像处理常用命令详解]]    :blog:

[[http://www.jincon.com/tag/convert/][convert]] 是 [[http://www.jincon.com/tag/imagemagick/][imagemagick]] 软件包中的一个命令。它可以读取、转换、写入多种
格式的图片。图片切割、颜色替换、各种效果的应用，图片的旋转、组合，文本，
直线，多边形，椭圆，曲线，附加到图片伸展旋转。这里介绍几个简单的命令，
具体的用法请参考man手册或者其官方网站。在Ubuntu中用命令


#+BEGIN_EXAMPLE
    sudo apt-get install imagemagick(centos的yum 一下就OK了)
#+END_EXAMPLE



*Convert的resize命令：*

Convert的resize子命令应该是在ImageMagick中使用较多的命令，它实现了图片任意大小的缩放，唯一需要掌握的就是如何使用它的一些参数测试设定值：

此说明文件中所用的原始文件(src.jpg)，宽度：200，高度：150

命令格式： -resize widthxheight{%} {@} {!} {<} {>} {\^}

1.
默认时，宽度和高度表示要最终需要转换图像的最大尺寸，同时Convert会控制图片的宽和高，保证图片按比例进行缩放。

如：convert -resize 600×600 src.jpg dst.jpg

转换后的dst.jpg的图片大小(宽度为600，而高度已经按比例调整为450).

2.如果需要转换成600×600，而图片无需保持原有比例，可以在宽高后面加上一个感叹号!.

如：convert -resize 600×600! src.jpg dst.jpg

3.
只指定高度，图片会转换成指定的高度值，而宽度会按原始图片比例进行转换。

如：convert -resize 400 src.jpg dst.jpg

转换后的dst.jpg的图片大小(宽度为400，而高度已经按比例调整为300)，和例1有点类似。

4. 默认都是使用像素作为单位，也可以使用百分比来形象图片的缩放。

如：convert -resize 50%x100%! src.jpg dst.jpg 或者convert -resize
50%x100% src.jpg dst.jpg

此参数只会按你的比例计算后缩放，不保持原有比例。(结果尺寸为100×150)

5.使用 @ 来制定图片的像素个数。

如：convert -resize “10000@” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(115×86)，图片保持原有比例(115×86= 9080 <
10000)。

6.当原始文件大于指定的宽高时，才进行图片放大缩小，可使用>命令后缀。

如：convert -resize “100×50>” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(67×50)，图片保持原有比例。

如：convert -resize “100×50>!” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(100×50)，图片不保持原有比例。

7.当原始文件小于指定的宽高时，才进行图片放大转换，可使用<命令后缀。

如：convert -resize “100×500<” src.jpg dst.jpg 或者convert -resize
“100×100

此命令执行后，dst.jpg和src.jpg大小相同，因为原始图片宽比100大。

如：convert -resize “600×600<” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(600×450)，图片保持原有比例。

如：convert -resize “600×600

此命令执行后，dst.jpg图片大小为(600×600)，图片不保持原有比例。

8.使用\^命令后缀可以使用宽高中较小的那个值作为尺寸

如：convert -resize “300×300\^” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(400×300)，图片保持原有比例，(300:300 <
200:150，选择高作为最小尺寸)。

如：convert -resize “300×200\^” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(300×225)，图片保持原有比例，(300:200 >
200:150，选择宽作为最小尺寸)。

*Convert的quality 命令：*



#+BEGIN_EXAMPLE
    convert -resize -quality 50 1405407568-633.jpg 800.jpg
#+END_EXAMPLE





*Convert的sample命令 生成250x250缩略图：*

convert -sample 250x250 wgy.jpg sample.jpg

另外，你还可以加水印，就不再赘述了。命令行的强大之处还是在于其简洁、快速，更适用于批量处理。

附上一个简单的shell脚本，共大家修改和使用：

#+BEGIN_EXAMPLE
    #! /bin/sh
    for i in `ls *.jpg`;
    do
    convert -resize 50% "$i" "${i%.jpg}.png";
    done
#+END_EXAMPLE

** [[http://www.jincon.com/archives/249/][Linux使用imagemagick的convert命令压缩图片，节省服务器空间]]    :blog:

本人管的一台阿里云服务器由于空间的带宽才只有1MB，图片一多，网站打开就慢，真是蛋疼啊，在不增加带宽的情况只有通过系统让图片更小，这样可以加快速度了，真是人穷就没办法啊。而且压缩图片还可以节省服务器空间，相必也是极好极好的。

安装imagemagick



#+BEGIN_EXAMPLE
    sudo apt-get install imagemagick
#+END_EXAMPLE



imagemagick的命令convert可以完成此任务,其参数-resize用来改变图片尺寸,可以直接指定像素值,也可以指定缩放百分比。而如果想降低图片的质量,可以用convert的-quality参数,质量值为0-100之间的数值,数字越大,质量越好,一般指定70-80,基本上看不出前后的差别。

我们首先要获取图片，自然find命令：



#+BEGIN_EXAMPLE
    find ./ -regex '.*\(jpg\|JPG\|png\|jpeg\)' -size +500k
#+END_EXAMPLE



统计下数量可对：



#+BEGIN_EXAMPLE
    find ./ -regex '.*\(jpg\|JPG\|png\|jpeg\)' -size +500k | wc -l
#+END_EXAMPLE



执行convert 压缩：



#+BEGIN_EXAMPLE
    find ./ -regex '.*\(jpg\|JPG\|png\|jpeg\)' -size +500k -exec convert -resize 50%x50% {} {} \;
#+END_EXAMPLE



或者限定大小：



#+BEGIN_EXAMPLE
    find ./ -regex '.*\(jpg\|JPG\|png\|jpeg\)' -size +500k -exec convert -resize 800x800 {} {} \;
#+END_EXAMPLE



convert 是会自动按照最大尺寸等比例进行缩小的。

用规则表达式把jpg和JPG后缀图片一网打尽,{}代表查找到的文件,这里没有改变convert前后的文件名,最后是转义的分号表示一个迭代的处理完成。

缩小图片质量为50：



#+BEGIN_EXAMPLE
    convert -resize 800x800 -quality 50 1405407568-633.jpg 800.jpg
#+END_EXAMPLE



整合下命令我就不说了，呵呵。。。

加上shell脚本每天定时操作，哈哈，爽 的一塌糊涂。

** [[http://www.linux178.com/linux/sudo.html][]]    :blog:

** [[http://www.linux178.com/linux/sudo.html][sudo命令详解]]    :blog:

- 作者：斯巴达克斯
- 时间：January 4, 2014
- 分类：[[http://www.linux178.com/category/linux/][Linux]]

**** 1.sudo是什么？

sudo是一种权限管理机制，管理员可以授权于一些普通用户去执行一些root执行的操作，而不需要知道root的密码，它依赖于/etc/sudoers这个文件，可以授权于那个用户在那个主机上能够以管理员的身份执行什么样的管理命令，而且是有限的。这个文件相当于就是一个授权表。

**** 2./etc/sudoers 文件的语法

可以使用 man sudoers 来查看其帮助信息

由于这个文件是一个授权文件，那么其权限必定是很严格

#+BEGIN_EXAMPLE
    [root@Linux178 ~]# ll /etc/sudoers
    -r--r----- 1 root root 3381 Feb 23  2012 /etc/sudoers
    [root@Linux178 ~]#

    [root@Linux178 ~]# lsattr /etc/sudoers
    ------------- /etc/sudoers
    [root@Linux178 ~]#
#+END_EXAMPLE

看到这个文件的权限是root和root组
只有读的权限，那也就是，编辑这个文件是有单独的命令的
visudo（这个文件我们最好不要使用vim命令来打开），是因为一旦你的语法写错会造成严重的后果，这个工具会替你检查你写的语法,这个文件的语法遵循以下格式：

#+BEGIN_EXAMPLE
    who where whom command
#+END_EXAMPLE

说白了就是
那个用户在哪个主机以谁的身份执行那些命令，那么这个where,是指允许在那台主机ssh连接进来才能执行后面的命令，文件里面默认给root用户定义了一条规则，
看例子：

#+BEGIN_EXAMPLE
    root    ALL=(ALL)       ALL
#+END_EXAMPLE

root root用户
 ALL 所有的主机上都可以
 (ALL) 是以谁的身份来执行，ALL就代表root可以任何人的身份来执行命令
 ALL 所有的命令

那么整个一条规则就是root用户可以在任何主机以任何人的身份来执行所有的命令，也就是不限定。

再来看一条里面的规则：

#+BEGIN_EXAMPLE
    %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom
    jerry   192.168.100.0/24=(root) /usr/sbin/useradd
#+END_EXAMPLE

%users 就是代表users这个组里面的所有成员
 ALL 代表可以这所有的主机上
 = 后面没有括号，也就是代表默认是以root身份
 /sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom 可以执行挂载的命令

**** 3.查看用户可以执行的命令

已经授权的普通用户可以使用

#+BEGIN_EXAMPLE
    sudo -l
#+END_EXAMPLE

来查看自己可以执行那些命令

要执行命令要在执行命令之前加上 sudo
，然后输入用户自己的密码，这是因为要验证，执行命令的用户确实是该用户。

sudo命令还有这个机制，就是在你正确输入密码并成功执行命令的5分钟内，再执行命令是不需要输入密码的，过了5分钟，就需要再次验证该用户的自己的密码，当然也可以手动让该期限过期，看下面sudo命令的语法

**** 4.sudo命令语法

#+BEGIN_EXAMPLE
    sudo [-bhHpV][-s ][-u <用户>][指令]
    或
    sudo [-klv]
    参数
      -b  在后台执行指令。
      -h  显示帮助。
      -H  将HOME环境变量设为新身份的HOME环境变量。
      -k  结束密码的有效期限，也就是下次再执行sudo时便需要输入密码。
      -l  列出目前用户可执行与无法执行的指令。
      -p  改变询问密码的提示符号。
      -s  执行指定的shell。
      -u <用户>  以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份。
      -v  延长密码有效期限5分钟。
      -V  显示版本信息。
      -S   从标准输入流替代终端来获取密码
#+END_EXAMPLE

**** 5.场景

思考这么一个场景，看下面的规则

#+BEGIN_EXAMPLE
    jerry   192.168.100.0/24=(root) /usr/sbin/useradd
#+END_EXAMPLE

这里面我如果想很多台主机上登录并执行命令（但是并不是所有的主机上），那这里岂不是要写很多的主机在这里吗？
你执行useradd命令，但是这只是添加，不能为用户指定密码，那岂不是也不行？如果还有执行很多的命令，那是不是这里又要写很多的命令？

答案是否定的

sudo 是支持 主机别名、用户别名、whom别名（就是以谁的身份）、命令别名

有了别名，规则就变得很清爽，就是把同类的对象放到一个组里面，*组名必须全部大写*

*主机别名* 通过 Host_Alias 关键字来定义 例如下面的：

#+BEGIN_EXAMPLE
    # Host_Alias     FILESERVERS = 192.168.100.0/24, 127.0.0.1
#+END_EXAMPLE

*用户别名* 通过 User_Aliases 关键字来定义，例如下面的：

#+BEGIN_EXAMPLE
    # User_Alias ADMINS = jsmith, mikem
#+END_EXAMPLE

*whom别名*（就是以谁的身份） 通过 RunAs_Aliases 关键字来定义

#+BEGIN_EXAMPLE
    这个通常是root或者是ALL 就不用定义了。
#+END_EXAMPLE

*命令别名* 通过 Cmnd_Alias 关键字来定义，例如下面的：

#+BEGIN_EXAMPLE
    #Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig
#+END_EXAMPLE

**** 6.限定执行的命令

假设你允许一个普通用户执行passwd，那这就危险了，那么它是可以直接修改root的密码，这就有背于我们的初衷了，这就需要做限制了，如下设置：

#+BEGIN_EXAMPLE
    pete    127.0.0.1 = /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root
#+END_EXAMPLE

[A-Za-z]* 是一个正则表达式，代表是大小写字母组成的用户名

这一条就是限制pete这个用户，只能修改以字母组成的用户，而不能修改root的密码，!
就是代表不能执行此命令。

在某个命令之前加!,就代表该用户或组不能执行该命令

**** 7.设定那些命令执行的时候不需要输入密码

当然也是可以设置在执行某些命令的时候不用输入密码,例如：

#+BEGIN_EXAMPLE
    fred           ALL = (DB) NOPASSWD: ALL
#+END_EXAMPLE

这就代表这个fred用户执行所有的命令时不需要输入密码

再如：

#+BEGIN_EXAMPLE
    tom ALL = (root) PASSWD:/usr/sbin/useradd,/usr/sbin/usermod NOPASSWD:/usr/sbin/gourpadd
#+END_EXAMPLE

这一条就是代表tom这个用户在执行uesradd和usermod的时候是需要输入密码，而执行gourpadd时不需要

凡是 PASSWD
后面跟的命令都需要输入密码，而NOPASSWD后面的命令都不需要输入密码，前提是sudo记住密码的期限已过。

** [[http://os.51cto.com/art/201104/255359.htm][Linux文件分割与合并：split&cat]]    :blog:

Linux下文件分割可以通过split命令来实现，而用cat进行文件合并。而分割可以指定按行数分割和安大小分割两种模式。Linux下文件合并可以通过cat命令来实现，非常简单。

在Linux下用split进行文件分割：

模式一：指定分割后文件行数

对与txt文本文件，可以通过指定分割后文件的行数来进行文件分割。

命令：

split -l 300 large_file.txt new_file_prefix
模式二：指定分割后文件大小

对于可执行文件等二进制文件，则不能通过文件行数来进行文件分割，此时我们可以指定分割大小来分隔文件。

命令：

split -b 10m large_file.bin new_file_prefix
对二进制文件我们同样也可以按文件大小来分隔。

在Linux下用cat进行文件合并：

命令：

cat small_files* > large_file
Linx文件分割命令英文释义：

-, read standard input.

Mandatory arguments to long options are mandatory for short options too.

-a, --suffix-length=N

use suffixes of length N (default 2)

-b, --bytes=SIZE

put SIZE bytes per output file

-C, --line-bytes=SIZE

put at most SIZE bytes of lines per output file

-d, --numeric-suffixes

use numeric suffixes instead of alphabetic

-l, --lines=NUMBER

put NUMBER lines per output file

** [[http://www.cnblogs.com/Charles-Zhang-Blog/archive/2013/02/05/2892879.html][ubuntu下搭建nfs服务器]]    :blog:

*1.1 *搭建NFS服务器

 NFS（Network
FileSystem，网络文件系统）是由SUN公司发展，并于1984年推出的技术，用于在不同机器，不同操作系统之间通过网络互相分享各自的文件。NFS设计之初就是为了在不同的系统间使用，所以它的通讯协议设计与主机及操作系统无关。

NFS分服务器和客户机，当使用远端文件时只要用mount命令就可把远端NFS服务器上的文件系统挂载在本地文件系统之下，操作远程文件与操作本地文件没有不同。NFS服务器所共享文件或目录记录在/etc/exports文件中。

 嵌入式Linux开发中，会经常使用NFS，目标系统通常作为NFS客户机使用，Linux主机作为NFS服务器。在目标系统上通过NFS，将服务器的NFS共享目录挂载到本地，可以直接运行服务器上的文件。在调试系统驱动模块以及应用程序，NFS都是十分必要的，并且Linux还支持NFS根文件系统，能直接从远程NFS
root启动系统，这对嵌入式Linux根文件系统裁剪和集成也是十分有必要的。

安装nfs-kernel-server：

ky@ubuntu:~$ sudo apt-get install nfs-kernel-server

设置NFS-Server目录。修改/etc/exports文件，在其中增加NFS服务器目录。 一个NFS服务器可以共享多个NFS目录，在/etc/exports文件中，每个目录的设置独占一行，编写格式如下：

NFS共享目录路径 客户机IP或者名称(参数1,参数2,...,参数n)

 说明：

q NFS共享目录可以是主机的任何一个目录，为了方便使用，最好将权限设置为777。

q 客户机指的是可以访问共享目录的客户机的IP或者主机名，可以是指定的IP或者主机名。如果使用IP，可以使用通配符。假如指定IP为192.168.1.x的客户机可以访问，可以写成192.168.1.*，如果设置为*，则表示任何客户机都可以访问。

q 访问参数可以是一个，也可以是多个，用逗号分开。可能的参数和说明如 REF
_Ref286733518
\h 表 5.108D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F005200650066003200380036003700330033003500310038000000 所列。

表 STYLEREF 1 \s 5. SEQ 表 \* ARABIC \s 1 1 NFS设置参数和说明

| 参数   | ro         | rw         | sync                       | async                         | secure                                | insecure                    | wdelay                                          | no_wdelay                                                         | hide                            | no_hide              | subtree_check                                                    | no_subtree_check   | all_squash                                             | no_all_squash                  | root_squash                                                | no_root_squash                       | anonuid=xxx                                   | anongid=xxx                                   |
|        |            |            |                            |                               |                                       |                             |                                                 |                                                                    |                                 |                       |                                                                   |                      |                                                         |                                  |                                                             |                                        |                                               |                                               |
| 说明   | 只读访问   | 读写访问   | 所有数据在请求时写入共享   | nfs在写入数据前可以响应请求   | nfs通过1024以下的安全TCP/IP端口发送   | nfs通过1024以上的端口发送   | 如果多个用户要写入nfs目录，则归组写入（默认）   | 如果多个用户要写入nfs目录，则立即写入，当使用async时，无需此设置   | 在nfs共享目录中不共享其子目录   | 共享nfs目录的子目录   | 如果共享/usr/bin之类的子目录时，强制nfs检查父目录的权限（默认）   | 不检查父目录权限     | 共享文件的UID和GID映射匿名用户anonymous，适合公用目录   | 保留共享文件的UID和GID（默认）   | root用户的所有请求映射成如anonymous用户一样的权限（默认）   | root用户具有根目录的完全管理访问权限   | 指定nfs服务器/etc/passwd文件中匿名用户的UID   | 指定nfs服务器/etc/passwd文件中匿名用户的GID   |



假定NFS共享目录是/home/ky/nfs，允许所有客户机访问，/etc/exports文件可写为：

/home/ky/nfs *(rw,sync,no_subtree_check, no_root_squash)

启动NFS服务器。启动portmap（如果有必要）和nfs-kernel-server服务：

ky@ubuntu:~$ *sudo service portmap start*

ky@ubuntu:~$ *sudo service nfs-kernel-server start*

 本地验证NFS服务器。将NFS服务器目录挂载到本机另外一个目录下，可以看到挂载点目录下可以看到NFS服务器目录中的文件。

ky@ubuntu:~$ ls /home/ky/nfs/

aaaa

ky@ubuntu:~$ *sudo mount -t nfs 127.0.0.1:/home/ky/nfs /mnt*

ke@ubuntu:~$ ls /mnt

aaaa

ky@ubuntu:~$ sudo umount /mnt/

用开发板验证NFS服务器是否可用。启动开发板，进入系统，配置好开发板的IP地址后，用mount命令挂载NFS服务器的NFS目录：

target# *mount -t nfs 192.168.1.3:/home/ky/nfs /mnt -o nolock*

target# ls /mnt

kingyee

target# umount /mnt/

 挂载成功后，可以在开发板的/mnt目录下看到NFS服务器上的文件。

说明，使用开发板与虚拟机安装的客户系统进行NFS挂载，需要将虚拟网卡设置为Bridged模式，并建议使用静态IP地址。

 如果在使用中需要增加新的NFS共享目录，直接修改/etc/exports文件即可。修改该文件后，可以不用重启NFS服务，用exportfs命令读取/etc/exports文件，重新共享输出。exportfs命令语法如下：

 exportfs [-aruv]

 选项说明：

-a：全部挂载(或卸载) /etc/exports的设置；

-r：重新挂载/etc/exports的设置；

-u：卸载某一个目录；

-v：在输出的时候，把共享目录显示出来。

 如果NFS已经启动，修改了/etc/exports文件，执行如下命令，新的设置即可生效：

ky@ubuntu:~$ *exportfs -ra*

** [[http://yanue.net/post-117.html][]]    :blog:

** [[http://yanue.net/post-117.html][dia在Linux(ubuntu)下无法输入中文的解决办法]]    :blog:

// 发表于 2013-08-29 09:54 -
[[http://yanue.net/post-117.html#comments][// 0条评论]]   // 2966
次浏览   所属分类：[[http://yanue.net/topic/ubuntu.html][Ubuntu]]

我是执行一下命令安装的

#+BEGIN_EXAMPLE
    sudo apt-get install dia
#+END_EXAMPLE

打开软件后发现不能输入中文，网上搜索一圈后找到以下解决方案

#+BEGIN_EXAMPLE
     sudo vi /usr/bin/dia
#+END_EXAMPLE

然后把dia-gnome --integrated "$@"修改成

#+BEGIN_EXAMPLE
     dia-gnome  "$@"
#+END_EXAMPLE

重新启动dia，输入法选择系统默认（我的系统输入法是ibus），就可以输入中文了不过这样一改，工具条变成浮动的了

另外，发现windows下dia，默认也是不能输入中文的，

解决办法倒是简单些：dia的输入法菜单里选择“简单”，就可以输入中文了

xp系统搜狗输入法下测试成功

** [[http://hw1287789687.iteye.com/blog/1766217][linux shell 遍历指定目录下的所有文件夹]]    :blog:


在linux 中，如何遍历指定目录下的所有文件夹呢？

要求能搜索结果中包含隐藏文件夹

脚本名：ergodic_folder.sh

脚本内容：

#+BEGIN_EXAMPLE
    #!/bin/sh
    list_alldir(){
        for file2 in `ls -a $1`
        do
            if [ x"$file2" != x"." -a x"$file2" != x".." ];then
                if [ -d "$1/$file2" ];then
                    echo "$1/$file2"
                    list_alldir "$1/$file2"
                fi
            fi
        done
    }

    list_alldir ./test
#+END_EXAMPLE



测试如下：



[root@localhost whuang]# ./ergodic_folder.sh

./test/.abc

./test/.abc/.ccc

./test/bbb

** [[http://bashdb.sourceforge.net/bashdb-man.html][bash debugger script]]    :blog:

*** NAME

bashdb - bash debugger script

--------------

*** SYNOPSIS

*bashdb* [/options/] [--] /script-name/ [/script options/]

*bashdb* [/options/] -c /execution-string/

*bash --debugger* [/bash-options/...] /script-name/ [/script options/]

--------------

*** DESCRIPTION

=bashdb= is a bash script to which arranges for another bash script to
be debugged.

The debugger has a similar command interface as
[[http://sourceware.org/gdb/current/onlinedocs/gdb_toc.html][gdb]].

The way this script arranges debugging to occur is by including (or
actually "source"-ing) some debug-support code and then sourcing the
given script or command string.

One problem with sourcing a debugged script is that the program name
stored in $0 will be =bashdb= rather than the name of the script to be
debugged. The debugged script will appear in a call stack not as the top
item but as the item below =bashdb=. If this is of concern, use the last
form given above, =bash --debugger= /script-name/ [/script-options/].

If you used bashdb script and need to pass options to the script to be
debugged, add =--= before the script name. That will tell bashdb not to
try to process any further options.

See the reference manual [[http://bashdb.sourceforge.net/bashdb.html]]
for how to to call the debugger from inside your program or arrange for
the debugger to get called when your program is sent a signal.

--------------

*** OPTIONS

- *-h | --help* :: Print a usage message on standard error and exit
   with a return code of 100.

- *-A | --annotation /level/* :: Sets to output additional stack and
   status information which allows front-ends such as emacs to track
   what's going on without polling.

   This is needed in for regression testing. Using this option is
   equivalent to issuing:

   #+BEGIN_EXAMPLE
         set annotation LEVEL
   #+END_EXAMPLE

   inside the debugger.

- *-B | --basename* :: In places where a filename appears in debugger
   output give just the basename only. This is needed in for regression
   testing. Using this option is equivalent to issuing:

   #+BEGIN_EXAMPLE
         set basename on
   #+END_EXAMPLE

   inside the debugger.

- *-n | nx* :: Normally the debugger will read debugger commands in
   =~/.bashdbinit= if that file exists before accepting user
   interaction. =.bashdbinit= is analogus to Perl's =.perldb= or GNU
   gdb's =.gdbinit=: a user might want to create such a debugger profile
   to add various user-specific customizations.

   Using the =-n= option this initialization file will not be read. This
   is useful in regression testing or in tracking down a problem with
   one's =.bashdbinit= profile.

- *-c /command-string/* :: Instead of specifying the name of a script
   file, one can give an execution string that is to be debugged. Use
   this option to do that.

   If you invoke the debugger via =bash --debugger=, the filename that
   will appear in source listing or in a call stack trace will be the
   artifical name *BOGUS*.

- *-q | --quiet* :: Do not print introductory version and copyright
   information. This is again useful in regression testing where we
   don't want to include a changeable copyright date in the
   regression-test matching.

- *-x /debugger-cmdfile/* :: Run the debugger commands
   /debugger-cmdfile/ before accepting user input. These commands are
   read however after any =.bashdbinit= commands. Again this is useful
   running regression-testing debug scripts.

- *-L | --library /debugger-library/* :: The debugger needs to source
   or include a number of functions and these reside in a library. If
   this option is not given the default location of library is relative
   to the installed bashdb script: =../lib/bashdb=.

- *-T | --tempdir /temporary-file-directory/* :: The debugger needs to
   make use of some temporary filesystem storage to save persistent
   information across a subshell return or in order to evaluate an
   expression. The default directory is =/tmp= but you can use this
   option to set the directory where debugger temporary files will be
   created.

- *-t | --tty /tty-name/* :: Debugger output usually goes to a terminal
   rather than stdout or stdin which the debugged program may use.
   Determination of the tty or pseudo-tty is normally done
   automatically. However if you want to control where the debugger
   output goes, use this option.

- *-V | --version* :: Show version number and no-warranty and exit with
   return code 1.

- *-X | --trace* :: Similar to "=set -x=" line tracing except that by
   default the location of each line, the bash level, and subshell level
   are printed. You might be able to get something roughly similar if
   you set =PS4= as follows

   #+BEGIN_EXAMPLE
           export PS4='(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]}\n'
   #+END_EXAMPLE

   In contrast however to "=set -x=" tracing, indentation of the
   original program is also preserved in the source output. And if you
   interrupt the program with a break (a =SIGINT= signal), you will go
   into the debugger (assuming your program doesn't trap =SIGINT=).

--------------

*** BUGS

The =bashdb= script and =--debugger= option assume a version of bash
with debugging support. That is you can't debug bash scripts using the
standard-issue version 2.05b bash or earlier versions. In versions after
3.0, debugging should have been enabled when bash was built. (I think
this is usually the case though.) If you try to run the bashdb script on
such as shell, may get the message:

#+BEGIN_EXAMPLE
      Sorry, you need to use a debugger-enabled version of bash.
#+END_EXAMPLE

Debugging startup time can be slow especially on large bash scripts.
Scripts created by GNU autoconf are at thousands of lines line and it is
not uncommon for them to be tens of thousands of lines.

There is a provision to address this problem by including a fast
file-to-array read routine (readarray), but the bashdb package has to be
compiled in a special way which needs access to the bash source code and
objects.

Another reason of the debugger slowness is that the debugger has to
intercept every line and check to see if some action is to be taken for
this and this is all in bash code. A better and faster architecture
would be for the debugger to register a list of conditions or stopping
places inside the bash code itself and have it arrange to call the
debugger only when a condition requiring the debugger arises. Checks
would be faster as this would be done in C code and access to internal
structures would make this more efficient.

** [[http://www.douban.com/note/170604841/][linux 自动挂载 windows分区    :blog:
]]

  个人学习linux日志，高手绕过
    对于linux系统挂载windows分区是必须的，比如你u盘 fat32的或是ntfs的格式的。当然这个在ubuntu的我我文件管理器nautilus	会自动挂载。而对双系统用户你的windows在默认的情况下就不会被挂载。当然于是你打开音乐播放器放音乐之前还要打开nautilus 挂载下。如果我的启动是在命令行下 那好也要手动mount下。也有一种软件能够让你自动挂载windows  比如ntfs-config 和ivman 。ntfs-config就用过一次。就是有次重装之前，被ntfs-config 搞的 / 分区无法挂载（当时还不懂改fstab，汗 只好重装）。其实我们只需要手懂配置fstab来挂载linux分区。
      fstab 拆开下 filesystem  table 也就是 linux开机过程控制你要挂载的硬盘分区配置文件（并没说开机后不能用）。关于挂可以参考http://forum.ubuntu.org.cn/viewtopic.php?f=120&t=257333的内容。
     修改fstab内容是这样的    个人学习linux日志，高手绕过
    对于linux系统挂载windows分区是必须的，比如你u盘 fat32的或是ntfs的格式的。当然这个在ubuntu的我我文件管理器nautilus	会自动挂载。而对双系统用户你的windows在默认的情况下就不会被挂载。当然于是你打开音乐播放器放音乐之前还要打开nautilus 挂载下。如果我的启动是在命令行下 那好也要手动mount下。也有一种软件能够让你自动挂载windows  比如ntfs-config 和ivman 。ntfs-config就用过一次。就是有次重装之前，被ntfs-config 搞的 / 分区无法挂载（当时还不懂改fstab，汗 只好重装）。其实我们只需要手懂配置fstab来挂载linux分区。
      fstab 拆开下 filesystem  table 也就是 linux开机过程控制你要挂载的硬盘分区配置文件（并没说开机后不能用）。关于挂可以参考http://forum.ubuntu.org.cn/viewtopic.php?f=120&t=257333的内容。
     修改fstab内容是这样的
# <file system> <mount point>   <type>  <options>       <dump>  <pass>

 # / was on /dev/sda3 during installation
UUID=c5dc9d91-c74b-4d1f-a232-d3151fd57157    /               ext4    errors=remount-ro     0       1
或者是
/dev/sda3      /        ext4        errors=remount-ro     0       1
#的后的面的部分是给人看的，即后面的对已来说是只是乱码 ，前面是同过uuid 挂载面的则是 通过 分区编号
我们所要做的修改
首先对于linux读取 ntfs分区靠的是 ntfs-3g 所以首先检查下ntfs-3g 有没有安装   sudo  apt-get
install ntfs-3g （这个 一般都会安装 n年ubuntu 要手动装）ntfs-3g 参看 http://www.linuxsir.org/main/node/281
   其次查看你要挂分区的硬件号 或者uuid   一般来说你D盘是 /dev/sda5， E盘是/dev/sda6  一次向后 实在确定 可以先mount看下 看uuid
 sudo blkid
我的是/dev/sda1: LABEL="C" UUID="34C85D1DC85CDF24" TYPE="ntfs"
/dev/sda2: UUID="f17f1975-e0f7-489c-87a6-7393efa34355" TYPE="ext2"
/dev/sda3: UUID="c5dc9d91-c74b-4d1f-a232-d3151fd57157" TYPE="ext4"
/dev/sda5: LABEL="D" UUID="178D4B66B84A6E29" TYPE="ntfs"
/dev/sda6: LABEL="E" UUID="5E352DAE4AAB4664" TYPE="ntfs"
/dev/sda7: LABEL="F" UUID="D3F7A6DDFEB31F89" TYPE="ntfs"
/dev/sda8: UUID="f670f9ac-f2ae-4485-b8d1-d3b53e099962" TYPE="reiserfs"
/dev/sda9: UUID="37eefbed-32f7-4514-9154-9129747d0066" TYPE="swap"
/dev/sda10: UUID="e27b304b-78c7-4f05-a8c0-b9b73669bc9d" TYPE="ext4
或者 ls -al /dev/disk/by-uuid

建议用uuid。 因为uuid是 一个硬盘分区 全 中国 全世界 全宇宙的唯一标示符 ，当然uuid 不仅标示硬盘分区标示其他电脑设备 具体的 请google
  然后
1.对fstab 进行备份
cp  /etc/fstab  /etc/fstab.bak
这是一种习惯 修改错的话 cp回来覆盖就行了  比如这里 可以 cp /etc/fstab.bak  /etc/fstab  记不住 目录名 这个你可以搞笔记本 稍微记录下，注意多用神键 tab 键 在输入的时候自动补齐
2.设置你的挂载点 就是你要把文件挂载到哪里
比如我想把E盘的挂载到是 /home/fly/wp/E这个目录下
那么 我就先创键这个目录
mkdir   /home/fly/wp/E
也可以顺便多建几个 mkdir /home/fly/wp/C  /home/fly/wp/F  ……
修改
sudo vim fstab
在文件后 添加你要挂载分区的信息
<uuid  或 分区标号>       <挂载点>      <分区格式>       < 挂载参数 >   0  0
比如我要要挂载我的E盘
 那么 就是
UUID="5E352DAE4AAB4664"     /home/fly/wp/E     ntfs-3g      default  0   0
或者是
/dev/sda6         /home/fly/wp/E    ntfs-3g     default  0  0
  其中 第4 挂载参数 默人填 default 就行 如果需要更多的功能可以藏  这么填写  defaults,utf8,umask=000,uid=fly,gid=fly     （uid 后面的参数 是你用户名 gid后面的是你的用户组名，）gid ，uid 主要是为了你可能无法将文件删除近回收站  umask这个参是防止你不能读写文件  文件utf8 是考虑可能出现的乱码 ，
具体看uid和gid 可以参考http://blog.csdn.net/wl_haanel/article/details/4793176
umask 参考 http://www.linuxso.com/command/umask.html
utf8这个假如你的文件都去是乱的话可以改成

** [[http://wuchong.me/blog/2014/07/14/linux-boot-process/][Linux基础：启动流程]]    :blog:

计算机的启动是一个非常复杂的过程，从打开电源到桌面的显示，需要经过一系列不可或缺的过程，了解这些过程有助于我们更好地理解操作系统，也有助于我们修复系统可能出现的问题。

*** 0. 启动流程一览

我们先给出 Linux 启动流程的总览图，然后再每一个模块展开说明。

[[http://ww4.sinaimg.cn/large/81b78497jw1eic3rqn72tj20hf06774l.jpg]]

*** 1. BIOS

当我们按下电源按键后，计算机硬件会自动读取主板上的BIOS（Basic
Input/Output
System）来加载硬件信息以及硬件系统的自我测试。BIOS也是一套程序，它知道如何与硬件进行交互。BIOS首先会对硬件进行检查，判断计算机硬件是否能满足运行的基本条件，这叫做“硬件自检”（Power-On
Self-Test，简称 POST）。

硬件自检后，BIOS
会将控制权交给下一段启动程序。这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部存储设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot
Sequence）。

因此，BIOS按照”启动顺序”，把控制权转交给排在第一位的存储设备。

*** 2. MBR

系统读取位列第一的可启动存储设备。计算机先读取该设备的第一个扇区，也就是读取最前面的512个字节。这最前面的512个字节，就叫做”主引导记录”（Master
boot record，缩写为MBR）。MBR
只有512字节，放不了太多东西，它主要告诉计算机从该设备的哪一个分区（partition）来装载引导加载程序（boot
loader）。Boot Loader
储存有操作系统（OS）的相关信息，比如操作系统名称，操作系统内核（kernel）所在位置等。它的主要功能就是加载内核到内存中去执行。常用的
boot loader 有 GRUB 和 LILO 。

那我们经常说到的多操作系统是怎么回事呢？其实每个文件系统（或分区）的最前面会保留一个引导扇区（boot
selector），这个引导扇区可以安装 boot loader。这样我们在每个 boot loader
中对应不同的操作系统，在读取 MBR 的时候选择我们需要启动的 boot loader
即可。

*** 3. kernel

随后，boot loader
会帮助我们加载内核，内核就会开始检测硬件与加载驱动程序。没错，内核会以自己的功能重新检测一遍硬件，而不一定会使用
BIOS 检测到的硬件信息。也就是说，内核此时才开始接管 BIOS 后的工作。

Kernel
实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过
kernel 传达给硬件。

*** 4. init process

在内核加载完毕以后，此时内核会主动调用第一个进程，那就是
=/sbin/init=，它的作用就是初始化系统环境。使用=pstree=命令会发现init的进程编号（PID）是1，也就是说init是第一个运行的程序，其他所有进程都从它衍生，都是它的子进程。

许多程序需要开机启动。它们在Windows叫做”服务”（service），在 Linux
就叫做”守护进程”（daemon）。

init
进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动
Apache，用作桌面就不需要。Linux
允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（run
level）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。

基本上，依据有无网络与有无 X Window ，Linux 将 run level
划分为7个等级（0-6）。其中0是关机，1是单用户模式，6是重启。而
2-5，一般来说都是多用户模式。

Linux
在启动各个服务前会先执行一系列的初始脚本（rc.sysinit）。这些脚本执行如下功能：设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络......
之后会根据运行级别的不同，系统会运行 rc0.d 到 rc6.d
目录中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。rc*.d目录中存放的是该运行级别中需要执行的服务脚本的软链接文件（即快捷方式）。

除此之外，Linux
还会运行一些其他的初始脚本。运行完后，操作系统已经完全准备好了，只是，还没有人可以登录！！！init
会给出登录（login）对话框，或者是图形化的登录界面。

*** 5. login

输入用户名密码登录成功后，系统会为用户分配一个用户 ID（UID），和一个组
ID（GID）。这两个 ID
就好像身份证一样会一直伴随用户，用于检测用户执行程序时的身份验证。

当用户登录成功后，一个完整的操作系统就展现在用户的面前了。哈哈！

*** 总结

结合一开始给出的流程图，Linux 的启动流程可以概括为以下几个主要步骤：

1. 加载 BIOS 的硬件信息与硬件自检，并依据设置取得第一个可启动的设备；
2. 读取并执行第一个启动设备内的MBR的 boot loader；
3. 依据 boot loader 的设置加载内核，内核会开始检测硬件与加载驱动程序；
4. 在内核 Kernel 加载完毕后，Kernel 会主动调用 init 进程，而 init 会取得
   run-level 信息；
5. init 执行 rc.sysinit 初始化系统的操作环境（网络、时区等）；
6. init 启动 run-level 的各个服务；
7. 用户登录

要注意在一开始的流程图中 init
虽然只用了一个模块展现出来，但其实在启动过程中 init 占了很大的比重。

*** 参考文献

- [[http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html][Linux
   的启动流程]]
- [[http://www.ruanyifeng.com/blog/2013/02/booting.html][计算机是如何启动的？]]
- [[http://www.cnblogs.com/vamei/archive/2012/09/05/2672039.html][Linux开机启动
   (bootstrap)]]
- [[http://vbird.dic.ksu.edu.tw/linux_basic/linux_basic.php][鸟哥的Linux私房菜.基础学习篇]]

** [[http://www.cnblogs.com/hnrainll/archive/2011/06/08/2074976.html][关于Linux系统清理/tmp/文件夹的原理]]    :blog:

转自:[[http://www.opsers.org/base/clean-up-on-the-linux-system-tmp-folder-you-may-want-to-know.html]]

我们知道，在Linux系统中/tmp文件夹里面的文件会被清空，至于多长时间被清空，如何清空的，可能大家知识的就不多了，所以，今天我们就来剖析一个这两个问题。

****** 在RHEL\CentOS\Fedora\系统中(本次实验是在RHEL6中进行的)

先来看看tmpwatch这个命令，他的作用就是删除一段时间内不使用的文件（removes
files which haven't been accessed for a period of
time）。具体的用法就不多说了，有兴趣的自行研究。我们主要看看和这个命令相关的计划任务文件。
他就是/etc/cron.daily/tmpwatch，我们可以看一下这个文件里面的内容
#! /bin/sh
flags=-umc
/usr/sbin/tmpwatch "$flags" -x /tmp/.X11-unix -x /tmp/.XIM-unix \
  -x /tmp/.font-unix -x /tmp/.ICE-unix -x /tmp/.Test-unix \
  -X '/tmp/hsperfdata_*' 10d /tmp
/usr/sbin/tmpwatch "$flags" 30d /var/tmp
for d in /var/{cache/man,catman}/{cat?,X11R6/cat?,local/cat?}; do
  if [ -d "$d" ]; then
  /usr/sbin/tmpwatch "$flags" -f 30d "$d"
  fi
done

这个脚本大家仔细分析一下就明白了，第一行相当于一个标记（参数），第二行就是针对/tmp目录里面排除的目录，第三行，这是对这个/tmp目录的清理，下面的是针对其他目录的清理，就不说了。

我们就来看/usr/sbin/tmpwatch "$flags" 30d
/var/tmp这一行，关键的是这个30d，就是30天的意思，这个就决定了30天清理/tmp下不访问的文件。如果说，你想一天一清理的话，就把这个30d改成1d。这个你懂的......哈哈！

但有个问题需要注意，如果你设置更短的时间来清理的话，比如说是30分钟、10秒等等，你可以在这个文件中设置，但你会发现重新电脑，他不清理/tmp文件夹里面的内容，这是为什么呢？这就是tmpwatch他所在的位置决定的，他的上层目录是/etc/cron.daily/，而这个目录是第天执行一次计划任务，所以说，你设置了比一天更短的时间，他就不起作用了。这下明白了吧。
*所以结论是：在RHEL6中，系统自动清理/tmp文件夹的默认时限是30天*

****** 在Debian\Ubuntu系统中（Ubuntu10.10为实验环境）

在Ubuntu系统中，在/tmp文件夹里面的内容，每次开机都会被清空，如果不想让他自动清理的话，只需要更改rcS文件中的TMPTIME的值。
我们看如何来修改
sudo vi /etc/default/rcS
把
TMPTIME=0
修改成
TMPTIME=-1或者是无限大
改成这样的话，系统在重新启动的时候就不会清理你的/tmp目录了。
依些类推，如果说要限制多少时间来更改的话，就可以改成相应的数字（本人没有测试，我是这么理解的）

*所以结论是：在Ubuntu中，系统自动清理/tmp文件夹的时限默认每次启动*

** [[http://www.chinaunix.net/old_jh/4/438660.html][Linux的用户和用户组管理    :blog:
]]
Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。

实现用户账号的管理，要完成的工作主要有如下几个方面：
· 用户账号的添加、删除与修改。
· 用户口令的管理。
· 用户组的管理。


一、Linux系统用户账号的管理

用户账号的管理工作主要涉及到用户账号的添加、修改和删除。

添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。

1、添加新的用户账号使用useradd命令，其语法如下：


useradd 选项 用户名


其中各选项含义如下：

-c comment 指定一段注释性描述。

-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。

-g 用户组 指定用户所属的用户组。

-G 用户组，用户组 指定用户所属的附加组。

-s Shell文件 指定用户的登录Shell。

-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。

用户名 指定新账号的登录名。


2、例子说明

例1：


# useradd –d /usr/sam -m sam


此命令创建了一个用户sam，
其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam（/usr为默认的用户主目录所在的父目录）。


例2：


# useradd -s /bin/sh -g group –G adm,root gem


此命令新建了一个用户gem，该用户的登录Shell是/bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。
这里可能新建组：#groupadd group及groupadd adm　

增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。

Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。


3、删除帐号

如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。删除一个已有的用户账号使用userdel命令，其格式如下：


userdel 选项 用户名


常用的选项是-r，它的作用是把用户的主目录一起删除。

例如：


# userdel sam


此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。


4、修改帐号

修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。

修改已有用户的信息使用usermod命令，其格式如下：


usermod 选项 用户名


常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。另外，有些系统可以使用如下选项：


 -l 新用户名


这个选项指定一个新的账号，即将原来的用户名改为新的用户名。

例如：


# usermod -s /bin/ksh -d /home/z –g developer sam


此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。


5、用户口令的管理

用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。

指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：


passwd 选项 用户名


可使用的选项：

-l 锁定口令，即禁用账号。

-u 口令解锁。

-d 使账号无口令。

-f 强迫用户下次登录时修改口令。

如果默认用户名，则修改当前用户的口令。


例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：

$ passwd

Old password:******

New password:*******

Re-enter new password:*******


如果是超级用户，可以用下列形式指定任何用户的口令：

# passwd sam

New password:*******

Re-enter new password:*******


普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。

为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。

为用户指定空口令时，执行下列形式的命令：


# passwd -d sam


此命令将用户sam的口令删除，这样用户sam下一次登录时，系统就不再询问口令。

passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如：


# passwd -l sam



 wingger 回复于：2004-11-04 13:03:40

二、Linux系统用户组的管理

每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。
用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。

1、增加一个新的用户组使用groupadd命令。其格式如下：

groupadd 选项 用户组

可以使用的选项有：
-g GID 指定新用户组的组标识号（GID）。

-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。

例1：

# groupadd group1

此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。

例2：

#groupadd -g 101 group2

此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。

2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下：

groupdel 用户组

例如：

#groupdel group1

此命令从系统中删除组group1。

3、修改用户组的属性使用groupmod命令。其语法如下：

groupmod 选项 用户组

常用的选项有：
-g GID 为用户组指定新的组标识号。

-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。

-n新用户组 将用户组的名字改为新名字


例1：

# groupmod -g 102 group2

此命令将组group2的组标识号修改为102。

例2：

# groupmod –g 10000 -n group3 group2

此命令将组group2的标识号改为10000，组名修改为group3。

4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：

$ newgrp root

这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。

 wingger 回复于：2004-11-04 13:21:16

三、与用户账号有关的系统文件

完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。下面分别介绍这些文件的内容。

1、/etc/passwd文件是用户管理工作涉及的最重要的一个文件。Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。这个文件对所有用户都是可读的。它的内容类似下面的例子：

＃ cat /etc/passwd



root:x:0:0:Superuser:/:

daemon:x:1:1:System daemons:/etc:

bin:x:2:2:Owner of system commands:/bin:

sys:x:3:3:Owner of system files:/usr/sys:

adm:x:4:4:System accounting:/usr/adm:

uucp:x:5:5:UUCP administrator:/usr/lib/uucp:

auth:x:7:21:Authentication administrator:/tcb/files/auth:

cron:x:9:16:Cron daemon:/usr/spool/cron:

listen:x:37:4:Network daemon:/usr/net/nls:

lp:x:71:18:Printer administrator:/usr/spool/lp:

sam:x:200:50:Sam san:/usr/sam:/bin/sh


从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：


用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell


1）“用户名”是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。

2）“口令”一些系统中，存放着加密后的用户口令字。。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。

3）“用户标识号”是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。

通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。

4）“组标识号”字段记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。

5)“注释性描述”字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。

6)“主目录”，也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。

7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。

用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。


8)系统中有一类用户称为伪用户（psuedo users），这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下所示。

伪  用  户         含     义

 bin                        拥有可执行的用户命令文件

 sys                       拥有系统文件

 adm                     拥有帐户文件

 uucp                    UUCP使用

 lp                         lp或lpd子系统使用

 nobody                 NFS使用

 拥有帐户文件

除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。

由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。只有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。


2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生。它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用“:”隔开。这些字段是：


登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志


1）“登录名”是与/etc/passwd文件中的登录名相一致的用户账号
2）“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。
3）“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。
4）“最小时间间隔”指的是两次修改口令之间所需的最小天数。
5）“最大时间间隔”指的是口令保持有效的最大天数。
6）“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。
7）“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。
8）“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。

下面是/etc/shadow的一个例子：


＃ cat /etc/shadow



root:Dnakfw28zf38w:8764:0:168:7:::

daemon:*::0:0::::

bin:*::0:0::::

sys:*::0:0::::

adm:*::0:0::::

uucp:*::0:0::::

nuucp:*::0:0::::

auth:*::0:0::::

cron:*::0:0::::

listen:*::0:0::::

lp:*::0:0::::

sam:EkdiSECLWPdSa:9740:0:0::::



3、用户组的所有信息都存放在/etc/group文件中。

将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：


组名:口令:组标识号:组内用户列表


1）“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。
2）“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。
3）“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。
4）“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。

/etc/group文件的一个例子如下：

# cat /etc/group

root::0:root

bin::2:root,bin

sys::3:root,uucp

adm::4:root,adm

daemon::5:root,daemon

lp::7:root,lp

users::20:root,sam


 wingger 回复于：2004-11-04 13:31:28

四、添加量用户批

添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：

（1）先编辑一个文本用户文件，每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：

user001::600:100:user:/home/user001:/bin/bash

user002::601:100:user:/home/user002:/bin/bash

user003::602:100:user:/home/user003:/bin/bash

user004::603:100:user:/home/user004:/bin/bash

user005::604:100:user:/home/user005:/bin/bash

user006::605:100:user:/home/user006:/bin/bash


（2）以root身份执行命令/usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户：


# newusers < user.txt


然后可以执行命令vipw或vi /etc/passwd检查/etc/passwd文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。

（3）执行命令/usr/sbin/pwunconv，将/etc/shadow产生的shadow密码解码，然后回写到/etc/passwd中，并将/etc/shadow的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消shadow password功能。


# pwunconv


（4）编辑每个用户的密码对照文件，范例文件passwd.txt内容如下：

user001:密码

user002:密码

user003:密码

user004:密码

user005:密码

user006:密码


（5）以root身份执行命令/usr/sbin/chpasswd，创建用户密码，chpasswd会将经过/usr/bin/passwd命令编码过的密码写入/etc/passwd的密码栏。


# chpasswd < passwd.txt


（6）确定密码经编码写入/etc/passwd的密码栏后，执行命令/usr/sbin/pwconv将密码编码为shadow password，并将结果写入/etc/shadow。


# pwconv


这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。

 wingger 回复于：2004-11-04 13:39:12

五、赋予普通用户特殊权限

在Linux系统中，管理员往往不止一人，若每位管理员都用root身份进行管理工作，根本无法弄清楚谁该做什么。所以最好的方式是：管理员创建一些普通用户，分配一部分系统管理工作给他们。

我们不可以使用su让他们直接变成root，因为这些用户都必须知道root的密码，这种方法很不安全，而且也不符合我们的分工需求。一般的做法是利用权限的设置，依工作性质分类，让特殊身份的用户成为同一个工作组，并设置工作组权限。例如：要wwwadm这位用户负责管理网站数据，一般Apache Web Server的进程httpd的所有者是www，您可以设置用户wwwadm与www为同一工作组，并设置Apache默认存放网页目录/usr/local/httpd/htdocs的工作组权限为可读、可写、可执行，这样属于此工作组的每位用户就可以进行网页的管理了。

但这并不是最好的解决办法，例如管理员想授予一个普通用户关机的权限，这时使用上述的办法就不是很理想。这时您也许会想，我只让这个用户可以以root身份执行shutdown命令就行了。完全没错，可惜在通常的Linux系统中无法实现这一功能，不过已经有了工具可以实现这样的功能——sudo。

sudo通过维护一个特权到用户名映射的数据库将特权分配给不同的用户，这些特权可由数据库中所列的一些不同的命令来识别。为了获得某一特权项，有资格的用户只需简单地在命令行输入sudo与命令名之后，按照提示再次输入口令（用户自己的口令，不是root用户口令）。例如，sudo允许普通用户格式化磁盘，但是却没有赋予其他的root用户特权。

1、sudo工具由文件/etc/sudoers进行配置，该文件包含所有可以访问sudo工具的用户列表并定义了他们的特权。一个典型的/etc/sudoers条目如下：


liming ALL=(ALL) ALL


这个条目使得用户liming作为超级用户访问所有应用程序，如用户liming需要作为超级用户运行命令，他只需简单地在命令前加上前缀sudo。因此，要以root用户的身份执行命令format，liming可以输入如下命令：


# sudo /usr/sbin/useradd sam


注意：命令要写绝对路径，/usr/sbin默认不在普通用户的搜索路径中，或者加入此路径：PATH=$PATH:/usr/sbin;export PATH。另外，不同系统命令的路径不尽相同，可以使用命令“whereis 命令名”来查找其路径。

这时会显示下面的输出结果：

We trust you have received the usual lecture from the local System

Administrator. It usually boils down to these two things:

#1) Respect the privacy of others.

#2) Think before you type.

Password:


如果liming正确地输入了口令，命令useradd将会以root用户身份执行。

注意：配置文件/etc/sudoers必须使用命令 Visudo来编辑。

只要把相应的用户名、主机名和许可的命令列表以标准的格式加入到文件/etc/sudoers，并保存就可以生效，再看一个例子。

2、例子：管理员需要允许gem用户在主机sun上执行reboot和shutdown命令，在/etc/sudoers中加入：


gem sun=/usr/sbin/reboot，/usr/sbin/shutdown


注意：命令一定要使用绝对路径，以避免其他目录的同名命令被执行，从而造成安全隐患。

然后保存退出，gem用户想执行reboot命令时，只要在提示符下运行下列命令：


$ sudo /usr/sbin/reboot


输入正确的密码，就可以重启服务器了。

如果您想对一组用户进行定义，可以在组名前加上%，对其进行设置，如：


%cuug ALL=(ALL) ALL


3、另外，还可以利用别名来简化配置文件。别名类似组的概念，有用户别名、主机别名和命令别名。多个用户可以首先用一个别名来定义，然后在规定他们可以执行什么命令的时候使用别名就可以了，这个配置对所有用户都生效。主机别名和命令别名也是如此。注意使用前先要在/etc/sudoers中定义：User_Alias, Host_Alias, Cmnd_Alias项，在其后面加入相应的名称，也以逗号分隔开就可以了，举例如下：

Host_Alias SERVER=no1

User_Alias ADMINS=liming，gem

Cmnd_Alias SHUTDOWN=/usr/sbin/halt，/usr/sbin/shutdown，/usr/sbin/reboot

ADMINS SERVER=SHUTDOWN


4、再看这个例子：


ADMINS ALL=(ALL) NOPASSWD: ALL


表示允许ADMINS不用口令执行一切操作，其中“NOPASSWD:”项定义了用户执行操作时不需要输入口令。

5、sudo命令还可以加上一些参数，完成一些辅助的功能，如


$ sudo –l


会显示出类似这样的信息：

User liming may run the following commands on this host:

(root) /usr/sbin/reboot


说明root允许用户liming执行/usr/sbin/reboot命令。这个参数可以使用户查看自己目前可以在sudo中执行哪些命令。

6、在命令提示符下键入sudo命令会列出所有参数，其他一些参数如下：

-V 显示版本编号。

-h 显示sudo命令的使用参数。

-v 因为sudo在第一次执行时或是在N分钟内没有执行（N预设为5）会询问密码。这个参数是重新做一次确认，如果超过N分钟，也会问密码。

-k 将会强迫使用者在下一次执行sudo时询问密码（不论有没有超过N分钟）。

-b 将要执行的命令放在背景执行。

-p prompt 可以更改问密码的提示语，其中%u会替换为使用者的账号名称，%h会显示主机名称。

-u username/#uid 不加此参数，代表要以root的身份执行命令，而加了此参数，可以以username的身份执行命令（#uid为该username的UID）。

-s 执行环境变量中的 SHELL 所指定的 Shell ，或是 /etc/passwd 里所指定的 Shell。

-H 将环境变量中的HOME（宿主目录）指定为要变更身份的使用者的宿主目录。（如不加-u参数就是系统管理者root。）


 要以系统管理者身份（或以-u更改为其他人）执行的命令。

** [[http://www.cnblogs.com/sopost/archive/2013/01/09/2853200.html][Linux┊详解udev]]    :blog:

如果你使用Linux比较长时间了，那你就知道，在对待设备文件这块，Linux改变了几次策略。在Linux早期，设备文件仅仅是是一些带有适当的属性集的普通文件，它由mknod命令创建，文件存放在/dev目录下。后来，采用了devfs,
一个基于内核的动态设备文件系统，他首次出现在2.3.46内核中。Mandrake，Gentoo等Linux分发版本采用了这种方式。devfs创建
的设备文件是动态的。但是devfs有一些严重的限制，从2.6.13版本后移走了。目前取代他的便是文本要提到的udev－－一个用户空间程序。

目前很多的Linux分发版本采纳了udev的方式，因为它在Linux设备访问，特别是那些对设备有极端需求的站点(比如需要控制上千个硬盘)和热插拔设备(比如USB摄像头和MP3播放器)上解决了几个问题。下面我我们来看看如何管理udev设备。
实际上，对于那些为磁盘，终端设备等准备的标准配置文件而言，你不需要修改什么。但是，你需要了解udev配置来使用新的或者外来设备，如果不修改配置，
这些设备可能无法访问，或者说Linux可能会采用不恰当的名字，属组或权限来创建这些设备文件。你可能也想知道如何修改RS－232串口，音频设备等文件的属组或者权限。这点在实际的Linux实施中是会遇到的。

为什么使用udev

在此之前的设备文件管理方法(静态文件和devfs)有几个缺点：

*不确定的设备映射。特别是那些动态设备，比如USB设备，设备文件到实际设备的映射并不可靠和确定。举一个例子：如果你有两个USB打印机。一个可能称
为/dev/usb/lp0,另外一个便是/dev/usb/lp1。但是到底哪个是哪个并不清楚，lp0,lp1和实际的设备没有一一对应的关系，因为
他可能因为发现设备的顺序，打印机本身关闭等原因而导致这种映射并不确定。理想的方式应该是：两个打印机应该采用基于他们的序列号或者其他标识信息的唯一
设备文件来映射。但是静态文件和devfs都无法做到这点。

*没有足够的主/辅设备号。我们知道，每一个设备文件是有两个8位的数字：一个是主设备号
，另外一个是辅设备号来分配的。这两个8位的数字加上设备类型(块设备或者字符设备)来唯一标识一个设备。不幸的是，关联这些身边的的数字并不足够。

*/dev目录下文件太多。一个系统采用静态设备文件关联的方式，那么这个目录下的文件必然是足够多。而同时你又不知道在你的系统上到底有那些设备文件是激活的。

*命名不够灵活。尽管devfs解决了以前的一些问题，但是它自身又带来了一些问题。其中一个就是命名不够灵活；你别想非常简单的就能修改设备文件的名字。缺省的devfs命令机制本身也很奇怪，他需要修改大量的配置文件和程序。

*内核内存使用，devfs特有的另外一个问题是，作为内核驱动模块，devfs需要消耗大量的内存，特别当系统上有大量的设备时(比如上面我们提到的系统一个上有好几千磁盘时)

udev的目标是想解决上面提到的这些问题，他通采用用户空间(user-space)工具来管理/dev/目录树，他和文件系统分开。知道如何改变缺省配置能让你之大如何定制自己的系统，比如创建设备字符连接，改变设备文件属组，权限等。

udev配置文件

主要的udev配置文件是/etc/udev/udev.conf。这个文件通常很短，他可能只是包含几行#开头的注释，然后有几行选项：

udev_root=“/dev/”
udev_rules=“/etc/udev/rules.d/”
udev_log=“err“

上面的第二行非常重要，因为他表示udev规则存储的目录，这个目录存储的是以.rules结束的文件。每一个文件处理一系列规则来帮助udev分配名字给设备文件以保证能被内核识别。
你的/etc/udev/rules.d下面可能有好几个udev规则文件，这些文件一部分是udev包安装的，另外一部分则是可能是别的硬件或者软件包
生成的。比如在Fedora Core
5系统上，sane-backends包就会安装60-libsane.rules文件，另外initscripts包会安装60-net.rules文
件。这些规则文件的文件名通常是两个数字开头，它表示系统应用该规则的顺序。

规则文件里的规则有一系列的键/值对组成，键/值对之间用逗号(,)分割。每一个键或者是用户匹配键，或者是一个赋值键。匹配键确定规则是否被应用，而赋
值键表示分配某值给该键。这些值将影响udev创建的设备文件。赋值键可以处理一个多值列表。匹配键和赋值键操作符解释见下表：

udev 键/值对操作符

操作符  匹配或赋值  解释
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
==  匹配  相等比较
!=  匹配  不等比较
=  赋值
分配一个特定的值给该键，他可以覆盖之前的赋值。
+=  赋值  追加特定的值给已经存在的键
:=  赋值
分配一个特定的值给该键，后面的规则不可能覆盖它。

这有点类似我们常见的编程语言，比如C语言。只是这里的键一次可以处理多个值。有一些键在udev规则文件里经常出现，这些键的值可以使用通配符(*,?,甚至范围，比如[0-9])，这些常用键列举如下：

常用udev键
键  含义
ACTION
一个时间活动的名字，比如add，当设备增加的时候
KERNEL
在内核里看到的设备名字，比如sd*表示任意SCSI磁盘设备
DEVPATH  内核设备录进，比如/devices/*
SUBSYSTEM  子系统名字，比如sound,net
BUS  总线的名字，比如IDE,USB
DRIVER  设备驱动的名字，比如ide-cdrom
ID  独立于内核名字的设备名字
SYSFS{ value}  sysfs属性值，他可以表示任意
ENV{ key}  环境变量，可以表示任意
PROGRAM
可执行的外部程序，如果程序返回0值，该键则认为为真(true)
RESULT  上一个PROGRAM调用返回的标准输出。
NAME
根据这个规则创建的设备文件的文件名。注意：仅仅第一行的NAME描述是有效的，后面的均忽略。
如果你想使用使用两个以上的名字来访问一个设备的话，可以考虑SYMLINK键。
SYMLINK  根据规则创建的字符连接名
OWNER  设备文件的属组
GROUP  设备文件所在的组。
MODE  设备文件的权限，采用8进制
RUN  为设备而执行的程序列表
LABEL
在配置文件里为内部控制而采用的名字标签(下下面的GOTO服务)
GOTO
跳到匹配的规则（通过LABEL来标识），有点类似程序语言中的GOTO
IMPORT{ type}
导入一个文件或者一个程序执行后而生成的规则集到当前文件
WAIT_FOR_SYSFS
等待一个特定的设备文件的创建。主要是用作时序和依赖问题。
PTIONS  特定的选项： last_rule
对这类设备终端规则执行； ignore_device 忽略当前规则； ignore_remove
忽略接下来的并移走请求。all_partitions 为所有的磁盘分区创建设备文件。

我们给出一个列子来解释如何使用这些键。下面的例子来自Fedora Core
5系统的标准配置文件。



KERNEL=="*", OWNER="root" GROUP="root", MODE="0600"
KERNEL=="tty", NAME="%k", GROUP="tty", MODE="0666",
OPTIONS="last_rule"
KERNEL=="scd[0-9]*", SYMLINK+="cdrom cdrom-%k"
KERNEL=="hd[a-z]", BUS=="ide", SYSFS{removable}=="1",
  SYSFS{device/media}=="cdrom", SYMLINK+="cdrom cdrom-%k"
ACTION=="add", SUBSYSTEM=="scsi_device", RUN+="/sbin/modprobe
sg"上面的例子给出了5个规则，每一个都是KERNEL或者ACTION键开头：

*第一个规则是缺省的，他匹配任意被内核识别到的设备，然后设定这些设备的属组是root，组是root，访问权限模式是0600(-rw-------)。这也是一个安全的缺省设置保证所有的设备在默认情况下只有root可以读写

*第二个规则也是比较典型的规则了。它匹配终端设备(tty)，然后设置新的权限为0600，所在的组是tty。它也设置了一个特别的设备文件名:%K。在这里例子里，%k代表设备的内核名字。那也就意味着内核识别出这些设备是什么名字，就创建什么样的设备文件名。

*第三行开始的KERNEL==”scd[0-9]*”,表示 SCSI CD-ROM 驱动.
它创建一对设备符号连接：cdrom和cdrom-%k。

*第四行，开始的 KERNEL==”hd[a-z]“, 表示ATA
CDROM驱动器。这个规则创建和上面的规则相同的符号连接。ATA
CDROM驱动器需要sysfs值以来区别别的ATA设备，因为SCSI
CDROM可以被内核唯一识别。.

*第五行以 ACTION==”add”开始，它告诉udev增加 /sbin/modprobe sg
到命令列表，当任意SCSI设备增加到系统后，这些命令将执行。其效果就是计算机应该会增加sg内核模块来侦测新的SCSI设备。

当然，上面仅仅是一小部分例子，如果你的系统采用了udev方式，那你应该可以看到更多的规则。如果你想修改设备的权限或者创建信的符号连接，那么你需要熟读这些规则，特别是要仔细注意你修改的那些与之相关的设备。

修改你的udev配置

在修改udev配置之前，我们一定要仔细，通常的考虑是：你最好不要修改系统预置的那些规则，特别不要指定影响非常广泛的配置，比如上面例子中的第一行。不正确的配置可能会导致严重的系统问题或者系统根本就无法这个正确的访问设备。

而我们正确的做法应该是在/etc/udev/rules.d/下创建一个信的规则文件。确定你给出的文件的后缀是rules文件名给出的数字序列应该比
标准配置文件高。比如，你可以创建一个名为99-my-udev.rules的规则文件。在你的规则文件中，你可以指定任何你想修改的配置，比如，假设你
修改修改floppy设备的所在组，还准备创建一个信的符号连接/dev/floppy，那你可以这么写：

KERNEL==”fd[0-9]*“, GROUP=“users“,  SYMLINK+=“floppy“

有些发行版本，比如Fedora，采用了外部脚本来修改某些特定设备的属组，组关系和权限。因此上面的改动可能并不见得生效。如果你遇到了这个问题，你就需要跟踪和修改这个脚本来达到你的目的。或者你可以修改PROGRAM或RUN键的值来做到这点。

某些规则的修改可能需要更深的挖掘。比如，你可能想在一个设备上使用sysfs信息来唯一标识一个设备。这些信息最好通过udevinfo命令来获取。

$ udevinfo --a --p $(udevinfo --q path  --n
/dev/hda)上面的命令两次使用udevinfo：一次是返回sysfs设备路径(他通常和我们看到的Linux设备文件名所在路径－－/dev/hda－－不同)；第
二次才是查询这个设备路径，结果将是非常常的syfs信息汇总。你可以找到最够的信息来唯一标志你的设备，你可以采用适当的替换udev配置文件中的
SYSFS选项。下面的结果就是上面的命令输出



[root@localhost rules.d]# udevinfo -a -p $(udevinfo -q path
-n  /dev/hda1)
Udevinfo starts with the device specified by the devpath and then walks
up the chain of
parent devices. It prints for every device found,all possible attributes
in the udev rules
key format. A rule to match, can be composed by the attributes of the
device and the
attributes from one single parent device.

looking at device '/block/hda/hda1':
KERNEL=="hda1"  SUBSYSTEM=="block"  DRIVER==""
ATTR{stat}=="  1133  2268  2
4"  ATTR{size}=="208782"
ATTR{start}=="63"  ATTR{dev}=="3:1"  looking at parent
device '/block/hda':

KERNELS=="hda"  SUBSYSTEMS=="block"  DRIVERS==""
ATTRS{stat}=="28905 18814 1234781 302540 34087 133247 849708 981336 0
218340 1283968"
ATTRS{size}=="117210240"  ATTRS{removable}=="0"
ATTRS{range}=="64"  ATTRS{dev}=="3:0"

looking at parent device
'/devices/pci0000:00/0000:00:1f.1/ide0/0.0':

KERNELS=="0.0"  SUBSYSTEMS=="ide"  DRIVERS=="ide-disk"
ATTRS{modalias}=="ide:m-disk"  ATTRS{drivename}=="hda"
ATTRS{media}=="disk"
looking at parent device '/devices/pci0000:00/0000:00:1f.1/ide0':

KERNELS=="ide0"  SUBSYSTEMS==""  DRIVERS==""
looking at parent device '/devices/pci0000:00/0000:00:1f.1':
KERNELS=="0000:00:1f.1"  SUBSYSTEMS=="pci"
DRIVERS=="PIIX_IDE"
ATTRS{broken_parity_status}=="0"  ATTRS{enable}=="1"
ATTRS{modalias}=="pci:v00008086d000024CAsv0000144Dsd0000C009bc01sc01i8a"
ATTRS{local_cpus}=="1"  ATTRS{irq}=="11"
ATTRS{class}=="0x01018a"
ATTRS{subsystem_device}=="0xc009"
ATTRS{subsystem_vendor}=="0x144d"
ATTRS{device}=="0x24ca"  ATTRS{vendor}=="0x8086"
looking at parent device '/devices/pci0000:00':

KERNELS=="pci0000:00"  SUBSYSTEMS==""  DRIVERS==""
举一个例子：假设你想修改USB扫描仪的配置。通过一系列的尝试，你已经为这个扫描仪标识了Linux设备文件(每次打开扫描仪时，名字都会变)。你可以使
用上面的命令替换这个正确的Linux设备文件名，然后定位输出的采用SYSFS{idVendor}行和SYSFS{idProduct}行。最后你可
以使用这些信息来为这个扫描仪创建新的选项。

SYSFS{idVendor}=="0686",  SYSFS{idProduct}=="400e",
SYMLINK+="scanner", MODE="0664",
group="scanner"上面的例子表示将扫描仪的组设置为scanner，访问权限设置为0664,同时创建一个/dev/scanner的符号连接。

udev-FAQ

问：udev是什么? 它的目的何在?

答：udev是一种工具，它能够根据系统中的硬件设备的状态动态更新设备文件，包括设备文件的创建，删除等。设备文件通常放在/dev目录下。使用udev后，在/dev目录下就只包含系统中真正存在的设备。

问：udev支持什么内核？

答：udev只支持linux-2.6内核，因为udev严重依赖于sysfs文件系统提供的信息，而sysfs文件系统只在linux-2.6内核中才有。

问：udev是一个内核程序还是用户程序？

答：udev是一个用户程序(user-mode daemon)。

问：udev和devfs有什么差别？

答：udev能够实现所有devfs实现的功能。但udev运行在用户模式中，而devfs运行在内核模式中。据称：devfs具有一些不太容易解决的先天缺陷。

问：udev的配置文件放在哪里？

答：udev是一个用户模式程序。它的配置文件是/etc/udev/udev.conf。这个文件一般缺省有这样几项：

udev_root=”/dev” ; udev产生的设备文件的根目录是/dev
udev_db=”/dev/.udevdb” ; 通过udev产生的设备文件形成的数据库
udev_rules=”/etc/udev/rules.d” ;用于指导udev工作的规则所在目录。
udev_log=”err” ;当出现错误时，用syslog记录错误信息。

问：udev的工作过程是怎样的？

答：由于没有研究过udev的源程序，不敢贸然就说udev的工作过程。我只是通过一些网上的资料和udev的说明文档，大致猜测它的工作过程可能是这样的。

当内核检测到在系统中出现了新设备后，内核会在sysfs文件系统中为该新设备生成一项新的记录，一般sysfs文件系统会被mount到/sys目录中。新记录是以一个或多个文件或目录的方式来表示。每个文件都包含有特定的信息。(信息是如何表述的，还要另外研究？)

udev在系统中是以守护进程的方式udevd在运行，它通过某种途径(到底什么途径，目前还没搞懂。)检测到新设备的出现，通过查找设备对应的sysfs中的记录得到设备的一些信息。

udev会根据/etc/udev/udev.conf文件中的udev_rules指定的目录，逐个检查该目录下的文件，这个目录下的文件都是针对某类或某个设备应该施行什么措施的规则文件。udev读取文件是按照文件名的ASCII字母顺序来读取的，如果udev一旦找到了与新加入的设备匹配的规则，udev就会根据规则定义的措施对新设备进行配置。同时不再读后续的规则文件。

问：udev的规则文件的语法是怎样的？

答：udev的规则文件以行为单位，以”#”开头的行代表注释行。其余的每一行代表一个规则。每个规则分成一个或多个“匹配”和“赋值”部分。“匹配”部分用“匹配“专用的关键字来表示，相应的“赋值”部分用“赋值”专用的关键字来表示。“匹配”关键字包括：ACTION，KERNEL，BUS，SYSFS等等，“赋值”关键字包括：NAME，SYMLINK，OWNER等等。具体详细的描述可以阅读udev的man文档。

下面举个例子来说明一下，有这样一条规则：SUBSYSTEM==”net”, ACTION==”add”,
SYSFS{address}==”00:0d:87:f6:59:f3″, IMPORT=”/sbin/rename_netiface %k
eth0″
这个规则中的“匹配”部分有三项，分别是SUBSYSTEM，ACTION和SYSFS。而”赋值”部分有一项，是IMPORT。这个规则就是说，当系统中出现的新硬件属于net子系统范畴，系统对该硬件采取的动作是加入这个硬件，且这个硬件在SYSFS文件系统中的“address”信息等于“00：0d...”时，对这个硬件在udev层次施行的动作是调用外部程序/sbin/rename_netiface，传递的参数有两个，一个是“%k”，代表内核对该新设备定义的名称。另一个是”eth0“。
从上面这个例子中可以看出，udev的规则的写法比较灵活的，尤其在“匹配”部分中，可以通过诸如”*“,
”?“,[a-c],[1-9]等shell通配符来灵活匹配多个匹配项。具体的语法可以参考udev的man文档。

问：udev怎样做到不管设备连接的顺序而维持一个统一的设备名？

答：实际上，udev是通过对内核产生的设备名增加别名的方式来达到上述目的的。前面说过，udev是用户模式程序，不会更改内核的行为。因此，内核依然会我行我素地产生设备名如sda,sdb等。但是，udev可以根据设备的其他信息如总线（bus），生产商（vendor）等不同来区分不同的设备，并产生设备文件。udev只要为这个设备文件取一个固定的文件名就可以解决这个问题。在后续对设备的操作中，只要引用新的设备名就可以了。但为了保证最大限度的兼容，一般来说，新设备名总是作为一个对内核自动产生的设备名的符号链接（link）来使用的。

例如：内核产生了sda设备名，而根据信息，这个设备对应于是我的内置硬盘，那我就可以制定udev规则，让udev除了产生/dev/sda设备文件外，另外创建一个符号链接叫/dev/internalHD。这样，我在fstab文件中，就可以用/dev/internalHD来代替原来的/dev/sda了。下次，由于某些原因，这个硬盘在内核中变成了sdb设备名了，那也不用着急，udev还会自动产生/dev/internalHD这个链接，并指向正确的/dev/sdb设备。所有其他的文件像fstab等都不用修改。

问：怎样才能找到这些设备信息，并把他们放到udev的规则文件中来匹配呢？

答：这个问题比较难，网上资料不多，我只找到一篇文章来介绍如何写udev的规则。他的基本方法是通过udevinfo这个实用程序来找到那些可以作为规则文件里的匹配项的项目。有这样两种情况可以使用这个工具：

第一种情况是，当你把设备插入系统后，系统为设备产生了设备名（如/dev/sda）。那样的
话，你先用udevinfo -q path
-n/dev/sda，命令会产生一个该设备名对应的在sysfs下的路径，如/block/sda。然后，你再用udevinfo
-a
-p/sys/block/sda，这个命令会显示一堆信息，信息分成很多块。这些信息实际来自于操作系统维护的sysfs链表，不同的块对应不同的路径。你就可以用这些信息来作为udev规则文件中的匹配项。但需要注意的是，同一个规则只能使用同一块中显示的信息，不能跨块书写规则。

第二种情况是，不知道系统产生的设备名，那就只有到/sys目录下去逐个目录查找了，反复用udevinfo　-a
-p/sys/path...这个命令看信息，如果对应的信息是这个设备的，那就恭喜你。否则就再换个目录。当然，在这种情况下，成功的可能性比较小。

问: udev和devfs是什么关系
答:
udev完全在用户态(userspace)工作，利用设备加入或移除时内核所发送的hotplug事件(event)来工作。关于设备的详细信息是由内核输出(export)到位于/sys的sysfs文件系统的。所有的设备命名策略、权限控制和事件处理都是在用户态下完成的。与此相反，devfs是作为内核的一部分工作的。

问:
如果udev不能完成所有devfs的工作的话，为什么把devfs标记为OBSOLETE/removed?

答: 引用 Al Viro (Linux VFS 内核维护者):

-devfs所做的工作被确信可以在用户态来完成。
-devfs被加入内核之时，大家寄望它的质量可以迎头赶上。
-devfs被发现了一些可修复和无法修复的 bug。
-对于可修复的 bug，几个月前就已经被修复了，其维护者认为一切良好。
-对于后者，同样是相当常一段时间以来没有改观了。
-devfs的维护者和作者对它感到失望并且已经停止了对代码的维护工作。

问:
但是当一个并不存在的/dev节点被打开的时候，udev并不能如devfs一样自动加载驱动程序。
答:
的确如此，但Linux的设计是在设备被发现的时候加载模块，而不是当它被访问的时候。

问: 不过等等，我确实希望 udev
可以在不存在的节点被打开的时候自动加载驱动。这是我使用devfs的唯一原因了。给udev
增加这个功能吧。
答: 不，udev 是用来管理/dev 的，不是用来加载内核驱动的。

问: 嗨，求你们了。这不难做到的。
答:
这么个功能对于一个配置正确的计算机是多余的。系统中所有的设备都应该产生hotplug
事件、加载恰当的驱动，而 udev
将会注意到这点并且为它创建对应的设备节点。如果你不想让所有的设备驱动停留在内存之中，应该使用其它东西来管理你的模块(如脚本,
modules.conf, 等等) 这不是udev 的工作。

问: 但是我真的喜欢那个功能，还是加上吧
答:
devfs用的方法导致了大量无用的modprobe尝试，以此程序探测设备是否存在。每个试探性探测都新建一个运行
modprobe 的进程，而几乎所有这些都是无用的。

问: 我喜欢devfs的设备文件命名方式，udev 可以这样命名么?
答: 可以，udev 可以使用 /dev
的命名策略来创建节点。通过一个配置文件，可以把内核缺省的名字映射到 devfs
的名字。可以看看udev 中带的 udev.rules.devfs 文件。注意: devfs
的命名方式是不被建议并且不被官方支持的，因为它所用的简单枚举设备的方式在设备可能被随时加入或删除的情况下确实是一个比较笨的方法。这些编号代给你的将只有麻烦，而并不能用来确定设备。看看那个永久性磁盘
(persistentdisk)
的规则就知道如何在用户态下正确的做这件事，而不是傻傻地列出设备。

问: udev 可以为哪些设备创建节点?
答: 所有在 sysfs 中显示的设备都可以由 udev
来创建节点。如果内核中增加了其它设备的支持，udev
也就自动地可以为它们工作了。现在所有的块设备都在被支持之列，大部分的主字符设备也是被支持的。内核开发者们正致力于让所有的字符设备都被支持。可以到linux-kernel邮件列表上寻找补丁或是查看补丁的状态。

问: udev 是否会去掉匿名设备数量的限制?
答: udev 完全工作于用户态。如果内核支持了更多的匿名设备，udev就会支持。

问: udev 是否会支持符号链接?
答: udev 现在就支持符号链接，每个设备节点拥有多个符号链接也是被支持的。

问: udev如何处理/dev文件系统?
答: 建议使用一个每次启动系统的时候重新创建的 tmpfs 作为 /dev
的文件系统。不过实际上udev并不关心那种文件系统在被使用。

问: 在 init 运行之前，udev 如何处理设备?
答: udev 可以被放入 initramfs
之中，并在每个设备被发现的时候运行。也可以让udev
工作在一个真的根分区被加载之后根据 /sys 的内容创建的初始/dev目录之中。

问: 我是否可以利用 udev 在一个 USB 设备被加载的时候自动加载上这个设备?
答: 技术上讲是可以的，但是 udev 不是用于这个工作的。所有的主流发布版
(distro)都包含了 HAL ([[http://freedesktop.org/wiki/Software_2fhal]])
用于这个工作，它也是专门用于监视设备变更的，并且集成进入了桌面软件。

换个角度说，这可以简单的通过 fstab 来实现:/dev/disk/by-label/PENDRIVE
/media/PENDRIVE vfat user,noauto 0 0
这样，用户可以用如下命令来访问设备:
$mount /media/PENDRIVE
同样不需要管理员权限，但却拥有了设备的全部访问权限。使用永久性磁盘链接(label,
uuid) 将可以指定同一设备，无论其实际上的内核名字是什么。

问: 有什么我需要注意的安全问题么?
答:
当使用动态设备编号的时候，一个给定的主/从设备号可能在不同时间对应不同的设备，如果一个用户拥有对这个节点的访问权限，并且可以创建一个到这个节点的硬链接，他就可以如此得到一个这个设备节点的拷贝。当设备被移除之后，udev
删除了设备节点，但硬链接依然存在。如果这个设备节点之后被重新使用不同的访问权限被创建的时候，其硬链接仍然可以使用先前的访问权限来访问。(同样的问题也存在在使用
PAM 改变访问权限的 login 上。)

简单的解决方案就是通过把 /dev 放在 tmpfs
这样的单独的文件系统之上来防止建立硬链接。

** [[http://albertcn.blog.163.com/blog/static/2094201452013521105128316/#crayon-51c3bb178fb44797891969-7][texlive的中文问题  ]]    :blog:

采用ctex支持中文\usepackage{ctex}后，
执行xelatex时出如下错：
Invalid fontname `[SIMKAI.TTF]/ICU', contains '['

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! fontspec error: "font-not-found"
!
! The font "[SIMKAI.TTF]" cannot be found.
!
! See the fontspec documentation for further information.
!
! For immediate help type H &lt;return&gt;.
!...............................................

说明字体[SIMKAI.TTF]找不到。

texlive的ctex包的配置文件：(以mac为例，texlive为texlive2013，其它操作系统和版本类似)
/usr/local/texlive/2013/texmf-dist/tex/latex/ctex/fontset/ctex-xecjk-winfonts.def

解决方法：
1. 将Windows上的字体文件simxxx.ttf等拷贝到mac桌面上，双击安装字体
2. 列出中文字体sudo fc-list  :lang=zh-cn
/Library/Fonts/华文仿宋.ttf: STFangsong:style=常规体,標準體,Ordin?r,Normal,Regular,Normaali,Regolare,レギュラー,???,Regulier,Обычный
/Library/Fonts/楷体.ttc: STKaiti:style=常规体,標準體,Ordin?r,Normal,Regular,Normaali,Regolare,レギュラー,???,Regulier,Обычный
/System/Library/Fonts/STHeiti Medium.ttc: 黑体\-简,黑體\-簡,Heiti SC,黒体\-簡,Heiti\-??:style=中等,中黑,Medium,Halbfett,Normaali,Moyen,Medio,ミディアム,???,Médio,Средний,Normal,Media
/Library/Fonts/Microsoft/STHUPO.TTF: 华文琥珀,STHupo:style=Regular
/Library/Fonts/Microsoft/Kaiti.ttf: 楷体,KaiTi:style=Regular,Normal,oby?ejné,Standard,Κανονικ?,Normaali,Normál,Normale,Standaard,Normalny,Обычный,Normálne,Navadno,Arrunta
/Library/Fonts/楷体.ttc: 楷体\-简,楷體\-簡,Kaiti SC:style=常规体,標準體,Regular
/Library/Fonts/华文黑体.ttf: STHeiti:style=常规体,標準體,Ordin?r,Normal,Regular,Normaali,Regolare,レギュラー,???,Regulier,Обычный
/Library/Fonts/宋体.ttc: 宋体\-简,宋體\-簡,Songti SC:style=细体,細體,Light
/Library/Fonts/华文细黑.ttf: STHeiti:style=细体,細體,Mager,Fein,Light,Ohut,Fin,Leggero,ライト,???,Licht,Tynn,Leve,Светлый,Fina
/Library/Fonts/Hei.ttf: Hei:style=Regular
/Library/Fonts/Microsoft/STXINWEI.ttf: 华文新魏,STXinwei:style=Regular
/Library/Fonts/Kai.ttf: Kai:style=Regular
/Library/Fonts/Microsoft/STXINGKA.ttf: 华文行楷,STXingkai:style=Regular
/Library/Fonts/宋体.ttc: 宋体\-简,宋體\-簡,Songti SC:style=黑体,黑體,Black
/Library/Fonts/楷体.ttc: 楷体\-简,楷體\-簡,Kaiti SC:style=粗体,粗體,Bold
...


3. (可选)生成字体sudo fc-cache -fsv

4.修改texlive的ctex包的配置文件
将[SIMKAI.TTF]替换为第2步骤列出的楷体名字KaiTi即可
原文：
% ctex-xecjk-winfonts.def: Windows 的 xeCJK 字体设置，默认为六种中易字体
% vim:ft=tex

\setCJKmainfont[BoldFont={SimHei},ItalicFont={[SIMKAI.TTF]}]
  {SimSun}
\setCJKsansfont{SimHei}
\setCJKmonofont{[SIMFANG.TTF]}

\setCJKfamilyfont{zhsong}{SimSun}
\setCJKfamilyfont{zhhei}{SimHei}
\setCJKfamilyfont{zhkai}{[SIMKAI.TTF]}
\setCJKfamilyfont{zhfs}{[SIMFANG.TTF]}
% \setCJKfamilyfont{zhli}{LiSu}
% \setCJKfamilyfont{zhyou}{YouYuan}

\newcommand*{\songti}{\CJKfamily{zhsong}} % 宋体
\newcommand*{\heiti}{\CJKfamily{zhhei}}   % 黑体
\newcommand*{\kaishu}{\CJKfamily{zhkai}}  % 楷书
\newcommand*{\fangsong}{\CJKfamily{zhfs}} % 仿宋

修改后：
% ctex-xecjk-winfonts.def: Windows 的 xeCJK 字体设置，默认为六种中易字体
% vim:ft=tex

%\setCJKmainfont[BoldFont={SimHei},ItalicFont={[SIMKAI.TTF]}]
\setCJKmainfont[BoldFont={SimHei},ItalicFont={KaiTi}]
  {SimSun}
\setCJKsansfont{SimHei}
%\setCJKmonofont{[SIMFANG.TTF]}
\setCJKmonofont{FangSong}

\setCJKfamilyfont{zhsong}{SimSun}
\setCJKfamilyfont{zhhei}{SimHei}
%\setCJKfamilyfont{zhkai}{[SIMKAI.TTF]}
\setCJKfamilyfont{zhkai}{KaiTi}
%\setCJKfamilyfont{zhfs}{[SIMFANG.TTF]}
\setCJKfamilyfont{zhfs}{FangSong}
% \setCJKfamilyfont{zhli}{LiSu}
% \setCJKfamilyfont{zhyou}{YouYuan}

\newcommand*{\songti}{\CJKfamily{zhsong}} % 宋体
\newcommand*{\heiti}{\CJKfamily{zhhei}}   % 黑体
\newcommand*{\kaishu}{\CJKfamily{zhkai}}  % 楷书
\newcommand*{\fangsong}{\CJKfamily{zhfs}} % 仿宋

ok，可以支持ctex中文了。

** [[http://blog.sina.com.cn/s/blog_4d72d6e70100otue.html][使用Latex2Html (l2h)将Latex转为Html ]]    :blog:

使用Latex写论文时，有一个缺点是不方便协作修改，不能使用类似于word提供的修改跟踪等功能。虽然也有很多开源的工具提供了Latex文件编辑的跟踪功能，但总体都是在Latex源码上进行修改，不方便修改人（特别是当修改人不会使用Latex）使用。我们的原则是，既然是我们请别人修改论文，当然是让修改人轻松点，我们多劳动点了。最简单的办法是将latex转成Word了，然后把word文件交给审稿人了。
将latex转成word有很多方法。最简单最完全工作量也最大的一种是用word重新撰写一遍。当文档包含大量的公式，符号时，重写一遍的工作量是很大的，不太可行。还有一种方法是将latex生成为pdf，然后在pdf上copy text，然后手动粘贴图片。对于公式和符号等，也要重新写一边或者直接粘贴为图片。这种方法还有一个问题是会在原pdf每行末尾增加一个换行，看起来非常不爽。还有一种办法是采用一些latex转word或者rtf的工具，这些工具基本上需要花钱买，而且生成的格式也不是非常完美。
个人觉得将latex转成html，然后在将html粘贴到word中是一个比较好的解决方案。本文介绍如何使用开源工具latex2html(l2h)。之所以整理一下是因为这个工具配起来不是很容易，折腾我一个上午的时间。
前提：
（1）安装Miktex，GS, GSView, Netpbm（for windows, 我用的10.27，有更新的版本）.
（2）安装Perl，如ActivePerl等。
注意：这些文件都要建议安装在C盘，各安装目录名称中不要有空格。MikTex在默认安装的目录中有空格如MikTex 2.5，把空格去掉。之所以这样做是因为Latex2html比较土，不支持路径中的空格。
（3）下载Latex2html，我用的版本是2002
（4）把下载的安装包解压到C盘一个临时目录，如C:\temp
（5）修改文件prefs.pm:
123行：
$prefs('EXTRAPATH')='C:\\TEXUTILS\\GS5.50;C:\\TEXUTILS\\NETPBM\\BIN';
中修改为（1）中各应用程序可执行文件目录，如
$prefs{'EXTRAPATH'} = 'C:\\Texs\\Ghostgum\\gsview;C:\\Texs\\gs\\gs8.53\\bin;C:\\Texs\\GnuWin32\\bin;C:\\Texs\\MiKTeX2.5\\miktex\\bin';
129 行：
$prefs('PREFIX')= 'C:\\TEXUTILS\\L2H';
将改值修改为你打算安装Latex2Html到的目录
（6）运行Config.bat，检查各项是否正确。
（7）运行test.bat，看是否正常执行。正常执行完成后在tests目录下会生成l2htest目录及输出的html文件等。无误后点击install.bat，安装latex2html到（5）中配置的目录
（8）配置Latex2html，修改l2hconf.pm 文件。
line 52
@IMAGE_TYPES = qw(gif png);
line 290
$LOCAL_ICONS = 1;
line 553
$HTML_VERSION = '3.2,math';
line 567
$UNSEGMENT = 1;
line 767
$EXTRA_IMAGE_SCALE = 2;
（9）测试，如运行latex2html.bat c:\t\mytex.tex. 对于论文，通常使用下面命令（可将下面命令做成批处理，放到latex文件目录下）：
C:\Texs\l2h\bin\latex2html -split 0 -lcase_tags -nonavigation -notop_navigation -auto_prefix -noinfo -image_type png -show_section_numbers -noaddress -numbered_footnotes CTRanking_Dou.tex
配置到这里，一个简单的latex文件应该可以转成html了。但我的论文中有大量的figure，当时为了方便，这些figure被我统一放到tex文件下的一个figures目录中了。需要手动将figures目录copy到latex2html生成的目录，如CTRanking_Dou中，同时还需要把对应的cls文件也copy过去。此外，需要把latex生成的附属文件如aux,bib文件等也copy过去。这样才能保证能够正确的生成论文中的图像文件。
到这里基本上就okay了，不过生成的html文件还是有点小问题，如公式对应的图片左边和下边有黑边，subfigure序号有问题（所有subfigure被统一编号，而不是一个figure一编），不过总体说来，还算可以了。毕竟对latex修改完后，直接执行一个命令，一个html文件就生成了。然后copy到word中，就可以交给别人去修改了。
参考资料：http://www.mayer.dial.pipex.com/l2h.htm

** [[http://zhidao.baidu.com/link?url=81iKOAaTCNYG0-Wej-I2TwGNHmTBytvj7M6GeEpb1KdHWqUE1eqLyQtYcdZqjtnlc97r3bSZyg1ZEAOAsORhuox3q33i3PdbEug-d2AmX6u][如何把Latex自动转为Word]]    :blog:

论文给导师修改又产生了很多麻烦。PDF上直接加Note可读性很差。最好还是能尽量保持公式、图形、Reference的完整性，然后直接转成
Word，然后导师在Word上用审阅模式修改，我们自己在Latex对应修改。这样导师就不用面对丑陋的Latex源码了。
简单的说，我们可以这样做：
1）我们用Latex书写论文
2）我们转成Word给导师
3）导师使用Word的审阅功能，修改论文
4）我们对照修改的地方直接修改Latex
5）最后生成修改后的PDF。
这样我们方便，导师也方便。具体方式如下：
以Ubuntu的Linux系统如下：
1、安装Latex
sudo apt-get install texlive
2、安装latex2html
sudo apt-get install latex2html
3、把论文从Latex转换为html
latex2html -split +0 input.tex
(input.tex是我们的论文tex文件)
4、这时在当前目录下多出一个input目录，大家可以弄到Windows里。（相信大家都有一个Linux的远程机器）
5、这个目录就是所有的html文件，找到index.html，右键用Word打开。
6、在word里另存为.doc或者docx文件。
7、把word文档发给导师，等那些让人心惊肉跳的红字和note吧。。。
大功告成，这样比Acrobat
Pro转为word文档在格式上更加安全。所有公式、图片、表格、算法都会被变为图片或者相应格式，在word里显示没有任何问题。
(注意：使用这种办法，要求你的tex可以在latex编译出dvi没有问题，也就是说使用eps图片的没有问题，但是使用pdf，jpg图片格式的，由于使用pdflatex命令编译出PDF。这个方法就不行了，需要手动改一下html文件)。
（EPS图片问题，我一般使用ImageMagic去批处理的转jpg，pdf到eps，然后在tex文件里引用eps图片，这样就规避了无论用pdflatex或者latex都可以编译出正确的pdf和dvi，那么Latex2html就没有任何问题了）

** [[http://www.xuebuyuan.com/1673310.html][Latex之安装宏包]]    :blog:

2013年07月11日 ⁄ 综合 ⁄ 共 2898字 ⁄ 字号 [[javascript:doZoom(12)][小]]
[[javascript:doZoom(13)][中]] [[javascript:doZoom(18)][大]] ⁄ 评论关闭


宏包就是Latex发行版（TexLive、MikTex等）的插件功能，通过安装不同的宏包可以获得更多的功能。一般情况下，Latex的发行版都自带了一些宏包（多是[[http://ctan.org/][CTAN]]中的），以便于使用者快速的编译。这些宏包默认安装在texmf/tex/latex/下，这里texmf是“Tex
and MetaFont”的缩写，指代Latex发行版的目录树。以Windows
 7 下MikTex2.9为例，texmf=“D:\Program Files\MiKTeX
2.9\”。宏包的功能可以通过[[http://ctan.org/][CTAN]]的搜索功能查询到。


一个宏包往往包含一个文件或多个文件，这些文件利用Tex命令定义了新的命令，用来改变Latex默认的功能。这些文件主要有两种类型：clas文件，以.cls为后缀；类型文件，以.sty为后缀。其它类型的文件多是辅助文件。当编译一篇tex文档时，如果引用某个缺失的宏包时，编译[[http://www.xuebuyuan.com/][程序]]会报package
missing的错误。当然，这些宏包是可以更新的。一个Latex发行版理论上可以安装任意多的宏包，但是，一篇文档可以使用的宏包数目是受限制的。

     虽然　Latex发行版自带的宏包已经很多，并且自带的Package
Manager也能自动从CTAN上下载和安装宏包。但是，宏包的数量远比CTAN拥有的为多。所以，下面介绍下安装宏包的三种方式：

*1. 傻瓜式安装*


第一种方式比较简单，就是下载.cls或者.sty格式的文件，直接放在编译的目录下与主文件一起运行。这种方式简单易行，但是每次使用都要复制过去，更新也不易，如果使用几十个宏包，会使得编译目录里文件过多。只适合要使用期刊模板的情况。



*2. 自动安装*


目前，多数的Latex发行版都带有宏包管理器，如TexLive的tlmgr，MikTex的Package
Manager。对于TexLive，可以使用如下命令自动安装：

#+BEGIN_EXAMPLE
    tlmgr install <package1> <package2> ...
    tlmgr remove <package1> <package2> ...
#+END_EXAMPLE

对于MikTex，使用 Start -> All Programs -> MikTex ->
Settings(admin)，记得使用管理员模式来更改。



*3. 手动安装*


手动安装相对前两种方式要稍微复杂些。如果你下载的宏包里包含sty等格式的必需文件，说明宏包已经经过编译了，可以直接跳到第三步；如果没有，对于较复杂的包，一般包含五个步骤：

（a）*提取文件*：在下载的宏包里找到后缀名为.ins格式的文件，然后运行“latex
yourfilename.ins”命令或者用Latex发行版打开ins文件进行编译。此步骤可以从dtx格式的文件中提取制定的内容并生成需要的文件。

（b）*创建文档*：接着利用dtx文件创建说明文档，运行命令“latex
yourfilename.dtx”。此步骤可以创建一个dvi格式的说明文档，以说明该宏包的功能。

（c）*安装文件*：此步是最关键的一步，也是容易出错的一步。此步骤的作用是将生成的必需文件，如cls文件和sty文件放到合适的本地位置，以便Latex发行版能够找到。关键是如何定义合适的本地位置呢？在Tex及其衍生物中，所谓合适的本地位置，就是以TDS(Tex
Directory
Structure)规则组织的文件夹及其子文件夹，也就是一个自定义的目录。一般情况，这个自定义的目录最上层的名字为texmf-local或者texmf。在不同的发行版本下，具体也不一样：

- MacTex：Users/username/Library/texmf/.
- Unix-type Systems：~/texmf.
- MikTex：任意名字，但是子目录要满足一定的规则，具体规则在[[http://docs.miktex.org/manual/localadditions.html#id573803][这里]]。

TDS定义了不同类型的文件存放的位置不同。比如sty格式文件，一般放在texmf/tex/latex下不同的文件夹下，文件夹的名字即是宏包的名字。下面的表格中给出了文件存放的规则：

Where to put files from packages

Type

Directory (under =texmf/= or =texmf-local/=)

Description

.afm

fonts/afm//foundry///typeface/

Adobe Font Metrics for Type 1 fonts

.bst

bibtex/bst//packagename/

BibTeX style

.cls

tex/latex/base

Document class file

.dvi

doc

package documentation

.enc

fonts/enc

Font encoding

.fd

tex/latex/mfnfss

Font Definition files for METAFONT fonts

.fd

tex/latex/psnfss

Font Definition files for PostScript Type 1 fonts

.map

fonts/map/

Font mapping files

.mf

fonts/source/public//typeface/

METAFONT outline

.pdf

doc

package documentation

.pfb

fonts/type1//foundry///typeface/

PostScript Type 1 outline

.sty

tex/latex//packagename/

Style file: the normal package content

.tex

doc

TeX source for package documentation

.tex

tex/plain//packagename/

Plain TeX macro files

.tfm

fonts/tfm//foundry///typeface/

TeX Font Metrics for METAFONT and Type 1 fonts

.ttf

fonts/truetype//foundry///typeface/

TrueType font

.vf

fonts/vf//foundry///typeface/

TeX virtual fonts

others

tex/latex//packagename/

other types of file unless instructed otherwise

（d）*更新索引：*最后更新Latex发行版的索引文件，以便Latex发行版能找到新安装的宏包。不同的发行版使用了不同的索引器：

- teTeX, TeX Live, fpTeX：texhash.
- web2c: mktexlsr
- MacTeX: MacTeX appears to do this for you.
- MikTeX: initexmf --update-fndb；或者使用GUI，即Start -> All Programs
   -> MikTex -> Settings(admin)下第一个tab，点击“Refresh
   FNDB”按钮即可。

（e）*更新字体映射图：*如果一个宏包还顺带安装了一些字体，还应该更新字体的映射。详细方法参详[[http://www.tug.org/fonts/fontinstall.html][这里]]。

此外，还有一些老版本的宏包并没有参照TDS格式，因此只能使用前两种方式。



此文参考了Wikibooks[[http://en.wikibooks.org/wiki/LaTeX/Installing_Extra_Packages][Latex]]和[[http://tex.stackexchange.com/][stackexchange]]上的一些讨论。

** [[http://www.mjoldfield.com/atelier/2009/02/arduino-cli.html][Arduino from the command line]]    :blog:

*** Retirement

2013-05-19 : I've let this languish for too long, mainly because I don't
do much with Arduinos now. Happily Sudar Muthu has taken over
maintainance of the code. His github repository is
[[https://github.com/sudar/Arduino-Makefile/]]^{1} though by the magic
of github, the old URL continues to work.

Thanks to Sudar and everyone else who has helped for keeping this alive.

*** Update News

2012-09-17 : After letting this languish for many months there's now
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz][version
0.10.]]^{2} This:

- Supports the Leonardo board.
- Moves the board reset code to Perl (this means you'll need the
   Device::SerialPort module).
- Has new path handling code.

There are other small changes, for more details see the
[[https://github.com/mjoldfield/Arduino-Makefile/commits/master][commit
history.]]^{3}

The new path calculations mean that:

1. Few, if any, paths need to specified in project specific Makefiles.
2. Paths can be grabbed from the environment e.g. from .bashrc.
3. It should be easier to move projects between e.g. Mac & Linux.

However, you'll need to set up some new variables to make this work:

- ARDMK_DIR :: Things which are included in this distribution e.g.
   ard-parse-boards
- ARDUINO_DIR :: Things which are always in the Arduino distribution
   e.g. boards.txt, libraries, &c.
- AVR_TOOLS_DIR :: Things which might be bundled with the Arduino
   distribution, but might come from the system. Most of the toolchain
   is like this: on Linux it's supplied by the system.

Thanks to Dan Villiom Podlaski Christiansen, Tom Hall, Scott Howard,
Kalin Kozhuharov, Rickard Lindberg, Christopher Peplin, Marc
Plano-Lesay, Jared Szechy, and Matthias Urlichs for patches and
comments.

**** Github

You can now grab the source for this from
[[https://github.com/mjoldfield/Arduino-Makefile][github.]]^{4} Besides
my version there are several others under development which offer better
integration with the IDE, support for Microchip's ChipKIT boards, and
other delights.

*** Introduction

The [[http://www.arduino.cc/][Arduino]]^{5} has done much to popularize
microcontrollers for the casual tinkerer. Its success suggests that
there's considerable value in combining a standard microcontroller (the
ATmega) and a GCC based toolchain into an easily digesible package. For
myself, it's certainly easier to just install the latest release of the
Arduino software than worry about building my own cross-compilers,
particularly when it's all new to me and consequently somewhat
confusing.

After working through the toy tutorials though, I found myself wishing
that writing code for the Arduino were more like writing other C
programs. In my case, that means editing it with emacs then building it
with make. I must emphasize that I'm not criticizing the Arduino IDE:
there's nothing wrong with it beyond it not being emacs...

It turns out that others have been along this path before: in the past
the Arduino website had a hopeful sounding ‘Arduino from the Command
Line' article, but it's gone now. There is still
[[http://arduino.cc/en/Hacking/HomePage][some information]]^{6} though
it's more limited.

Without an official Makefile, I wrote my own. You might wonder why I
should embark on such a task. Well:

- I was keen that all of my objects and random other files were
   completely separate from the main Arduino stuff in the applet
   directory.
- Although I wanted to be able to build Arduino sketches, I also wanted
   a suitable jumping-off point for code which didn't use wiring. In
   other words, to regard the Arduino software as a convenient way to
   get the AVR GCC toolchain.
- Rather than dumping a big Makefile in each sketch directory, I wanted
   to have a few definitions in the directory which then included a
   large project-independent file from elsewhere.

Finally, one of the things I enjoy about writing code for
microcontrollers is the sense of continuity between the hardware
datasheets published by the chip manufacturer and the code I write (by
contrast if you're writing code on Linux there's a vast gulf between the
code executing printf and stuff appearing on the screen). Writing my own
Makefile seemed a good way to make sure I understood what was going on.

So to the Makefile. Obviously it owes a great debt to the people who
wrote the Makefile shipped with the Arduino IDE and here's the credit
list from that file:

#+BEGIN_EXAMPLE
    # Arduino 0011 Makefile
    # Arduino adaptation by mellis, eighthave, oli.keller
#+END_EXAMPLE

Thanks then to mellis, eighthavem and oli.keller.

*** Installation instructions

If you're using Debian or Ubuntu, then just grab the arduino-mk package.

You should then set up environment variables thus:

#+BEGIN_EXAMPLE
    ARDUINO_DIR   = /usr/share/arduino
    ARDMK_DIR     = /usr
    AVR_TOOLS_DIR = /usr
#+END_EXAMPLE

Otherwise, you'll need to download
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz][the
tarball containing the Makefile,]]^{7} unpack it, and then copy the
files somewhere sensible:

#+BEGIN_EXAMPLE
    $ wget http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz
    $ tar xzvf arduino-mk_0.10.tar.gz
    $ cp arduino-mk-0.10/arduino-mk/Arduino.mk /usr/local/arduino/Arduino.mk
    $ cp arduino-mk-0.10/bin/* /usr/local/bin
#+END_EXAMPLE

The next step is to set up environment variables which point to the
different files.

On the Mac you might want to set:

#+BEGIN_EXAMPLE
    ARDUINO_DIR   = /Applications/Arduino.app/Contents/Resources/Java
    ARDMK_DIR     = /usr/local
#+END_EXAMPLE

On Linux, where the toolchain is installed in /usr, you might prefer:

#+BEGIN_EXAMPLE
    ARDUINO_DIR   = /usr/share/arduino
    ARDMK_DIR     = /usr/local
    AVR_TOOLS_DIR = /usr
#+END_EXAMPLE

The final step is to create a small Makefile for the sketch you actually
want to build. Let's build the
[[http://arduino.cc/en/Tutorial/WebServer][WebServer example]]^{8} from
the Arduino distribution: it's a good example because software-wise it's
as complicated as the stardard examples get, but you can just plug the
hardware together.

Create a new directory and copy the WebServer.ino file into it.

*Note: If you're using version 1.0 of the Arduino software, you'll need
to make sure that the sketch's name ends in .ino and not .pde.*

Now this we'll add a Makefile:

#+BEGIN_EXAMPLE
    BOARD_TAG    = uno
    ARDUINO_PORT = /dev/cu.usb*

    ARDUINO_LIBS = Ethernet Ethernet/utility SPI

    include /usr/local/arduino/Arduino.mk
#+END_EXAMPLE

Hopefully these will be self-explanatory but in case they're not:

- BOARD_TAG :: A tag identifying which type of Arduino you're using.
   This only works in version 0.6 and later.
- ARDUINO_PORT :: The port where the Arduino can be found (only needed
   when uploading) If this expands to several ports, the first will be
   used.
- ARDUINO_LIBS :: A list of any libraries used by the sketch---we
   assume these are in $(ARDUINO_DIR)/hardware/libraries.

Until version 0.8 you had to specify a TARGET name which set the
basename for the executables. You still /can/ do this, but it's not
necessary: thanks to a patch from Daniele Vergini it now defaults to the
name of the current directory.

In the past, the following options were used, and indeed you can still
use them. However it's probably better to use set BOARD_TAG and let the
Makefile look up the values in boards.txt:

- MCU :: The target processor (atmega168 for the Duemilanove).
- F_CPU :: The target's clock speed (16000000 for the Duemilanove).
- AVRDUDE_ARD_PROGRAMMER :: The protocol avrdude speaks---defaults to
   stk500v1.
- AVRDUDE_ARD_BAUDRATE :: The rate at which we talk to the
   board---defaults to 19,200.

**** BOARD_TAG

Makefiles before version 0.5 had to specify which processor and speed
the target used. For standard boards, this information can be found in
the boards.txt file, so it seemed sensible to use that instead.

Now, one need only define BOARD_TAG to match the target hardware and it
should work. Internally the Makefile invokes ard-parse-boards---a small
Perl utility included with the software---which parses board.txt.

If you're not sure which board tag you need, ard-parse-board will dump a
full list:

#+BEGIN_EXAMPLE
    $ ard-parse-boards --boards
    Tag          Board Name
    atmega168    Arduino NG or older w/ ATmega168
    atmega328    Arduino Duemilanove or Nano w/ ATmega328
    atmega8      Arduino NG or older w/ ATmega8
    bt           Arduino BT w/ ATmega168
    bt328        Arduino BT w/ ATmega328
    diecimila    Arduino Diecimila, Duemilanove, or Nano w/ ATmega168
    fio          Arduino Fio
    lilypad      LilyPad Arduino w/ ATmega168
    lilypad328   LilyPad Arduino w/ ATmega328
    mega         Arduino Mega (ATmega1280)
    mega2560     Arduino Mega 2560
    mini         Arduino Mini
    pro          Arduino Pro or Pro Mini (3.3V, 8 MHz) w/ ATmega168
    pro328       Arduino Pro or Pro Mini (3.3V, 8 MHz) w/ ATmega328
    pro5v        Arduino Pro or Pro Mini (5V, 16 MHz) w/ ATmega168
    pro5v328     Arduino Pro or Pro Mini (5V, 16 MHz) w/ ATmega328
    uno          Arduino Uno
#+END_EXAMPLE

If you don't set it, BOARD_TAG defaults to uno.

You can, of course, continue to set F_CPU and MCU directly should you
prefer that.

**** ARDUINO_LIBS

Early (up to and including version 0.4) of this Makefile didn't really
support this (despite claims to the contrary). Happily various kind
people sorted out the problem, one of whom patched the Debian and Ubuntu
version.

In the official IDE, it's enough to select the library from a menu: this
puts the relevant #include into the Sketch and adds the necessarily
linker tweaks too.

In this Makefile, you'll need to both add the #include yourself and
append the directories which contain the library to the ARDUINO_LIBS
variable. Often these will both have the same name, though it's worth
noting that the #include refers to a single file, but the ARDUINO_LIBS
entry refers to an entire directory of source files.

However, care is needed if the library's source files aren't in a single
directory. For example, the webserver example uses the
[[http://www.arduino.cc/en/Reference/Ethernet][Ethernet library]]^{9}
and we needed to include both Ethernet and Ethernet/utility in
ARDUINO_LIBS.

If you omit the .../utility library, you'll get messy looking link
errors from the bowels of the Ethernet library. The SPI and Wire
libraries are like this too!

*** Building

If you're used to Unix then this is easy:

#+BEGIN_EXAMPLE
    $ make
    ...
#+END_EXAMPLE

The output is pretty verbose, but I think it should be obvious if it
worked. After building you'll see a new directory has been created which
contains all the object files: build-uno. Since version 0.10, if you
rebuild the software with a different BOARD_TAG, you'll get a different
directory name.

#+BEGIN_EXAMPLE
    $ $ ls -lR
    total 16
    -rw-r--r--   1 mjo  staff   263 12 Feb 11:06 Makefile
    -rw-r--r--   1 mjo  staff  2308 12 Feb 10:57 WebServer.ino
    drwxr-xr-x  28 mjo  staff   952 12 Feb 11:07 build-uno
#+END_EXAMPLE

**** build-uno

Let's peek inside the build-uno directory:

#+BEGIN_EXAMPLE
    $ ls -l build-uno
    total 2136
    -rw-r--r--  1 mjo  staff    2292 12 Feb 11:07 CDC.o
    -rw-r--r--  1 mjo  staff    2292 12 Feb 11:07 HID.o
    -rw-r--r--  1 mjo  staff   23452 12 Feb 11:07 HardwareSerial.o
    -rw-r--r--  1 mjo  staff   16008 12 Feb 11:07 IPAddress.o
    -rw-r--r--  1 mjo  staff   40012 12 Feb 11:07 Print.o
    -rw-r--r--  1 mjo  staff   21068 12 Feb 11:07 Stream.o
    -rw-r--r--  1 mjo  staff   16580 12 Feb 11:07 Tone.o
    -rw-r--r--  1 mjo  staff    2300 12 Feb 11:07 USBCore.o
    -rw-r--r--  1 mjo  staff    6048 12 Feb 11:06 WInterrupts.o
    -rw-r--r--  1 mjo  staff    7068 12 Feb 11:07 WMath.o
    -rw-r--r--  1 mjo  staff   79196 12 Feb 11:07 WString.o
    -rw-r--r--  1 mjo  staff    2329 12 Feb 10:57 WebServer.cpp
    -rw-r--r--  1 mjo  staff    1920 12 Feb 11:06 WebServer.d
    -rw-r--r--  1 mjo  staff   11324 12 Feb 11:06 WebServer.o
    -rwxr-xr-x  1 mjo  staff  193852 12 Feb 11:07 WebServer.elf
    -rw-r--r--  1 mjo  staff   28572 12 Feb 11:07 WebServer.hex
    -rw-r--r--  1 mjo  staff    1920 12 Feb 11:08 depends.mk
    -rw-r--r--  1 mjo  staff  541002 12 Feb 11:07 libcore.a
    drwxr-xr-x  4 mjo  staff     136 12 Feb 10:57 libs
    -rw-r--r--  1 mjo  staff    3616 12 Feb 11:07 main.o
    <-rw-r--r--  1 mjo  staff    5544 12 Feb 11:07 new.o
    -rw-r--r--  1 mjo  staff    9780 12 Feb 11:06 wiring.o
    -rw-r--r--  1 mjo  staff    7024 12 Feb 11:06 wiring_analog.o
    -rw-r--r--  1 mjo  staff    9704 12 Feb 11:06 wiring_digital.o
    -rw-r--r--  1 mjo  staff    7056 12 Feb 11:06 wiring_pulse.o
    -rw-r--r--  1 mjo  staff    5736 12 Feb 11:06 wiring_shift.o

    ./build-uno/libs:
    total 0
    drwxr-xr-x  9 mjo  staff  306 12 Feb 11:07 Ethernet
    drwxr-xr-x  3 mjo  staff  102 12 Feb 11:07 SPI

    ./build-uno/libs/Ethernet:
    total 392
    -rw-r--r--  1 mjo  staff  24836 12 Feb 11:07 Dhcp.o
    -rw-r--r--  1 mjo  staff  23112 12 Feb 11:07 Dns.o
    -rw-r--r--  1 mjo  staff  33008 12 Feb 11:07 Ethernet.o
    -rw-r--r--  1 mjo  staff  42000 12 Feb 11:07 EthernetClient.o
    -rw-r--r--  1 mjo  staff  19420 12 Feb 11:07 EthernetServer.o
    -rw-r--r--  1 mjo  staff  41244 12 Feb 11:07 EthernetUdp.o
    drwxr-xr-x  4 mjo  staff    136 12 Feb 11:07 utility

    ./build-uno/libs/Ethernet/utility:
    total 152
    -rw-r--r--  1 mjo  staff  40480 12 Feb 11:07 socket.o
    -rw-r--r--  1 mjo  staff  34840 12 Feb 11:07 w5100.o

    ./build-uno/libs/SPI:
    total 16
    -rw-r--r--  1 mjo  staff  6812 12 Feb 11:07 SPI.o
#+END_EXAMPLE

Most of the files in here are object files for the wiring library. What
about the others ?

- WebServer.cpp :: This is the .pde sketch file with a small main
   program prepended and a suitable #include prepended.
- WebServer.d :: This tracks the dependencies used by WebServer.pde
- WebServer.elf :: This is executable produced by the linker
- WebServer.hex :: This is a hex dump of (the code part) of the
   executable in a format understood by the Arduino's bootloader.
- WebServer.o :: The object file we got by compiling WebServer.cpp.
- depends.mk :: A single file containing all the dependency relations
   (it's the concatentation of all the .d files).
- libcore.a :: Rather than link all the system supplied objects
   directly, we build them into this library first, then link against
   it.

*** Uploading code

This is easy:

#+BEGIN_EXAMPLE
    $ make upload
#+END_EXAMPLE

*** Uploading via ISP

If you're using target hardware which doesn't have a bootloader then you
might want to use ISP to upload the code. Though you'll obviously need
some extra hardware to do this.

Assuming that avrdude supports your programmer though, you'll only need
to make a few changes to the Makefile to tell avrdude where it can find
the programmer and how to talk to it:

#+BEGIN_EXAMPLE
    ISP_PORT         = /dev/ttyACM0
    ISP_PROG         = -c stk500v2
#+END_EXAMPLE

Then to upload:

#+BEGIN_EXAMPLE
    $ make ispload
#+END_EXAMPLE

**** Fuses

You might need to change the fuse settings when programming, though some
care needs to be taken here or you might irreversibly damage the chip.

Normally the fuse settings are chosen from the boards.txt file to match
the value of BOARD_TAG (assuming you're running version 0.6 or higher),
but you can set them yourself:

#+BEGIN_EXAMPLE
    ISP_LOCK_FUSE_PRE  = 0x3f
    ISP_LOCK_FUSE_POST = 0xcf
    ISP_HIGH_FUSE      = 0xdf
    ISP_LOW_FUSE       = 0xff
    ISP_EXT_FUSE       = 0x01
#+END_EXAMPLE

*** Growing the project

There a couple of obvious things to do now. You might want to edit the
sketch. That's easy: just edit the .ino file and run make again.

Alternatively you might want to add some more source files to the
project. That's easy too: the Makefile understands C, C++ and assembler
files in the source directory (with .c, .cpp, and .s extensions).
Everything *should* just work.

*** Wiring-less development

Finally you might want to develop code which isn't linked against the
Wiring library. There's some scope for this: just set NO_CORE in the
Makefile e.g.

#+BEGIN_EXAMPLE
    NO_CORE = 1
#+END_EXAMPLE

*** Bugs and problems

- The Makefile isn't very elegant.
- When compiling the sketch file, the compiler actually sees the .cpp
   file derived from it. Accordingly the line numbers of any errors will
   be wrong (but not by that much).
- The Makefile doesn't do some of the things that the Makefile
   distributed with the Arduino software does e.g. generating COFF
   files. I worry that some of these might be important.
- This hasn't been used very much yet, even by me. I'm writing this now
   as much for my benefit as anyone else's, though I'd be delighted to
   know if anyone else finds it useful.

*** Changelog

**** 2010-05-21,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.3.tar.gz][version
0.3]]^{10}

- Tidied up the licensing, making it clear that it's released under
   LGPL 2.1.
- [[http://hands.com/~phil/][Philip Hands]]^{11} sent me some code to
   reset the Arduino by dropping DTR for 100ms, and I added it.
- Tweaked the Makefile to handle version 0018 of the Arduino software
   which now includes main.cpp. Accordingly we don't need to---and
   indeed must not---add main.cxx to the .pde sketch file. The paths
   seem to have changed a bit too.

**** 2010-05-24,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.4.tar.gz][version
0.4]]^{12}

- Tweaked rules for the reset target on Philip Hands' advice.

**** 2011-06-23,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.5.tar.gz][version
0.5]]^{13}

- Imported changes from Debian/Ubuntu, which incorporate a patch from
   Stefan Tomanek so that libraries would be compiled too.

Note: Many other people sent me similar patches, but I didn't get around
to using them. In the end, I took the patch from Debian and Ubuntu:
there seems merit in not forking the code and using a tested version.
So, thanks and apologies to Nick Andrew, Leandro Coletto Biazon, Thibaud
Chupin, Craig Hollabaugh, Johannes H. Jensen, Fabien Le Lez, Craig
Leres, and Mark Sproul.

**** 2011-06-23,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.6.tar.gz][version
0.6]]^{14}

- Added ard-parse-boards. Mark Sproul suggested doing something like
   this ages ago, but I've only recently looked at it in detail.
- Fabien Le Lez reported that one needs to link with -lc to avoid
   [[http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1290294587][linker
   errors.]]^{15}

**** Unreleased,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.7.tar.gz][version
0.7]]^{16}

- Added -lm to the linker options, and -F to stty.

**** 2012-02-12,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.8.tar.gz][version
0.8]]^{17}

- Patches for version 1.0 of the Arduino IDE. Older versions might
   still work, but I've not tested it.
- A change to the build process: rather than link all the system
   objects directly into the executable, bundle them in a library first.
   This should make the final executable smaller.
- If TARGET isn't explicitly set, default to the current directory
   name. Thanks to Daniele Vergini for this patch.
- Add support for .c files in system libraries: Dirk-Willem van Gulik
   and Evan Goldenberg both reported this and provided patches in the
   same spirit.
- Added a size target as suggested by Alex Satrapa.

**** Later versions

Please consult the
[[https://github.com/mjoldfield/Arduino-Makefile/commits/master][commit
history]]^{18} on github.

*** Similar work

It's not a derivative of this, but Alan Burlison has written
[[http://bleaklow.com/2010/06/04/a_makefile_for_arduino_sketches.html][a
similar thing.]]^{19}

Alan's Makefile was used in
[[http://pragprog.com/magazines/2011-04/advanced-arduino-hacking][a
Pragmatic Programmer's article.]]^{20}

Rei Vilo wrote to tell me that he's using the Makefile ina Xcode 4
template called [[http://embedxcode.weebly.com][embedXcode.]]^{21}
Apparently it supports many platforms and boards, including AVR-based
Arduino, AVR-based Wiring, PIC32-based chipKIT, MSP430-based LaunchPad
and ARM3-based Maple.

*** References

- 1. https://github.com/sudar/Arduino-Makefile/
- 2.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz
- 3. https://github.com/mjoldfield/Arduino-Makefile/commits/master
- 4. https://github.com/mjoldfield/Arduino-Makefile
- 5. http://www.arduino.cc/
- 6. http://arduino.cc/en/Hacking/HomePage
- 7.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz
- 8. http://arduino.cc/en/Tutorial/WebServer
- 9. http://www.arduino.cc/en/Reference/Ethernet
- 10.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.3.tar.gz
- 11. http://hands.com/~phil/
- 12.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.4.tar.gz
- 13.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.5.tar.gz
- 14.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.6.tar.gz
- 15. http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1290294587
- 16.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.7.tar.gz
- 17.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.8.tar.gz
- 18. https://github.com/mjoldfield/Arduino-Makefile/commits/master
- 19.
   http://bleaklow.com/2010/06/04/a_makefile_for_arduino_sketches.html
- 20. http://pragprog.com/magazines/2011-04/advanced-arduino-hacking
- 21. http://embedxcode.weebly.com

** [[https://truongtx.me/2013/03/10/ecb-emacs-code-browser/][Install and Config ECB on Emacs]]    :blog:

Install and Config ECB on Emacs

Introduction

ECB, stands for Emacs Code Browser, tranforms your emacs from a text editor to a real IDE for coding. Once activated, it can display many
useful information that help you program more effectively. The ECB’s informational windows can contain:

  * a directory tree,
  * a list of source files in the current directory,
  * a list of functions/classes/methods/… in the current file, (ECB uses the Semantic Bovinator, or Imenu, or etags, for getting this list
    so all languages supported by any of these tools are automatically supported by ECB too)
  * a history of recently visited files,
  * the Speedbar and
  * output from compilation (the “compilation” window) and other modes like help, grep, etc. or whatever the user defines to be displayed in
    that window.

For more information, please visit ECB Homepage.

Screenshot

Here is the ECB screenshot from my Emacs

ECB Scre

Installation

ECB requires CEDET version 1.0+, which is included in Emacs version 24.

You can install ECB manually by cloning the package and add it to your load-path. However, there is another convinience method, that is to
use package.el. If you haven’t known it yet, have a look at this post Emacs Package Manager. To install it, M-x and type in list-package
RET, C-s and search for ecb, RET and select Install. After that, add this to your .emacs or init.el file

;;; activate ecb
(require 'ecb)
(require 'ecb-autoloads)

Now, everything you need to run ECB is to type M-x ecb-activate RET and ECB is now ready for you to use. When you want to stop it, just
execute the command ecb-deactivate.

Some Basic Configurations

To set the layout for ECB, add this to your .emacs

(setq ecb-layout-name "layout-name")

Replace layout-name with the name of the layout you want. For a list of ECB layouts, follow this link ECB Layouts.

Show source files in directories buffer

(setq ecb-show-sources-in-directories-buffer 'always)

By default, ECB hides the compilation window. Everytime I compile, it displays the compilation message to the same window as the buffer that
I’m editing. This is really annoying because I want to see all the messages so that I can fix the error in my code easily. To keep a
persistent compile window in ECB, add this to your .emacs

(setq ecb-compile-window-height 12)

Some key bindings for quick interation with ECB, replace them with the key bindings that you want.

;;; activate and deactivate ecb
(global-set-key (kbd "C-x C-;") 'ecb-activate)
(global-set-key (kbd "C-x C-'") 'ecb-deactivate)
;;; show/hide ecb window
(global-set-key (kbd "C-;") 'ecb-show-ecb-windows)
(global-set-key (kbd "C-'") 'ecb-hide-ecb-windows)
;;; quick navigation between ecb windows
(global-set-key (kbd "C-)") 'ecb-goto-window-edit1)
(global-set-key (kbd "C-!") 'ecb-goto-window-directories)
(global-set-key (kbd "C-@") 'ecb-goto-window-sources)
(global-set-key (kbd "C-#") 'ecb-goto-window-methods)
(global-set-key (kbd "C-$") 'ecb-goto-window-compilation)

Some of My Functions

Personally, I don’t like those function ecb-deactivate, ecb-show-ecb-windows, ecb-hide-ecb-windows since I usually have to open multiple
windows in Emacs. When deactivate or hide ECB window, it does not automatically restore the window layout and switch to the buffer that I’m
editing. Similar problem happens when I try to show ecb window again. Because of that, I wrote those functions to replace the ECB built in
three functions ecb-deactivate, ecb-show-ecb-windows, ecb-hide-ecb-windows.

;;; replacement for built-in ecb-deactive, ecb-hide-ecb-windows and
;;; ecb-show-ecb-windows functions
;;; since they hide/deactive ecb but not restore the old windows for me
(defun tmtxt/ecb-deactivate ()
  "deactive ecb and then split emacs into 2 windows that contain 2 most recent buffers"
  (interactive)
  (ecb-deactivate)
  (split-window-right)
  (switch-to-next-buffer)
  (other-window 1))
(defun tmtxt/ecb-hide-ecb-windows ()
  "hide ecb and then split emacs into 2 windows that contain 2 most recent buffers"
  (interactive)
  (ecb-hide-ecb-windows)
  (split-window-right)
  (switch-to-next-buffer)
  (other-window 1))
(defun tmtxt/ecb-show-ecb-windows ()
  "show ecb windows and then delete all other windows except the current one"
  (interactive)
  (ecb-show-ecb-windows)
  (delete-other-windows))

After that, bind them with a key sequence for quick interaction with ECB

(global-set-key (kbd "C-x C-'") 'tmtxt/ecb-deactivate)
(global-set-key (kbd "C-;") 'tmtxt/ecb-show-ecb-windows)
(global-set-key (kbd "C-'") 'tmtxt/ecb-hide-ecb-windows)

** Github project & sourceforge project    :blog:
** [[http://www.educity.cn/help/510677.html][vim中执行shell命令小结]]    :blog:

vim中执行shell命令，有以下几种形式

1):!command

不退出vim，并执行shell命令command，将命令输出显示在vim的命令区域，不会改变当前编辑的文件的内容

例如:!ls -l

特别的可以运行:!bash来启动一个bash shell并执行命令，不需要退出vim

2):r !command

将shell命令command的结果插入到当前行的下一行

例如:r !date，读取系统时间并插入到当前行的下一行。

3):起始行号,结束行号 !command

将起始行号和结束行号指定的范围中的内容输入到shell命令command处理，并将处理结果替换起始行号和结束行号指定的范围中的内容

例如:62,72 !sort，将62行到72行的内容进行排序

可以只指定起始行，例如:62 !tr [a-z] [A-Z]，将62行的小写字母转为大写字母

当前光标所在行，除可以指定行号外，也可以用.表示，例如:. !tr [a-z] [A-Z]，将当前行的小写转为大写

4):起始行号,结束行号 w !command

将起始行号和结束行号所指定的范围的内容作为命令command的输入。不会改变当前编辑的文件的内容

例如:62,72 w !sort，将62行到72行的内容进行排序，但排序的结果并不会直接输出到当前编辑的文件中，而是显示在vim敲命令的区域

特殊的可以下面这么用:62 w !bash，将会把第62行的内容作为bash命令来执行并显示结果，而且不会改变当前编辑的文件的内容

同样的:. w !bash，将当前行的内容作为bash命令来执行

例如52行内容为ls -l

那么输入:52 w !bash就跟执行!ls -l是一样的效果，如果你用的shell是bash shell

如果输入的是:52 !bash，那么会把第52行的内容也就是ls -l作为命令执行，同时命令的输出结果会替换第52行的内容，注意其中的区别。
** [[http://blog.csdn.net/lcj_cjfykx/article/details/9091569][VIM选择文本块/复制/粘贴]]    :blog:


在正常模式下（按ESC进入）按键v进入可视化模式，然后按键盘左右键或h,l键即可实现文本的选择。
 其它相关命令：
 v：按字符选择。经常使用的模式，所以亲自尝试一下它。

 V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。


CTRL＋v：按块选择。非常强大，只在很少的编辑器中才有这样的功能。你可以选择一个矩形块，并且在这个矩形里面的文本会被高亮。


值得注意的是如果VIM中使用自动换行，那么直到你按ENTER换行前，VIM都会将你之前输入的内容视为一行而不是你看到的好几行，按块选择时就会按VIM中的行来选择块。


在选择模式的时候使用上面所述的方向键和命令（motion）。比如，vwww，会高亮光标前面的三个词。Vjj
将会高亮当前行以及下面两行。


================================================================
 ================================================================

原文：[[http://hi.baidu.com/shadouyou/blog/item/7ccb234e5a75d1cfd0c86a55.html][http://hi.baidu.com/shadouyou/blog/item/7ccb234e5a75d1cfd0c86a55.html
]]

vi编辑器有3种模式：命令模式、输入模式、末行模式。掌握这三种模式十分重要：


命令模式：vi启动后默认进入的是命令模式，从这个模式使用命令可以切换到另外两种模式，同时无论在任何模式下只要按一下[Esc]键都可以返回命令模式。在命令模式中输入字幕“i”就可以进入vi的输入模式编辑文件。


输入模式：在这个模式中我们可以编辑、修改、输入等编辑工作，在编辑器最后一行显示一个“--INSERT--”标志着vi进入了输入模式。当我们完成修改输入等操作的时候我们需要保存文件，这时我们需要先返回命令模式，在进入末行模式保存。


末行模式：在命令模式输入“：”即可进入该模式，在末行模式中有好多好用的命令。

 4.编辑操作
 　　进入输入模式命令
 　　i插入命令 a附加命令 o打开命令 c修改命令
 　　r取代命令 s替换命令 Esc退出命令

 　　输入模式的操作
 　　Home光标到行首
 　　End 光标到行尾
 　　Page Up和Page Down上下翻页
 　　Delect删除光标位置的字符

 　　删除操作(命令模式使用)
 　　x删除光标处的单个字符
 　　dd删除光标所在行
 　　dw删除当前字符到单词尾包括空格的所有字符
 　　#x例如3x删除光标处向右的三个字符
 　　#dd例如3dd从当前行开始向下删除三行文本

 　　撤销操作
 　　u命令取消最近一次的操作，可以使用多次来恢复原有的操作
 　　U取消所有操作
 　　Ctrl+R可以恢复对使用u命令的操作

 　　复制操作
 　　yy命令复制当前整行的内容到vi缓冲区

yw复制当前光标所在位置到单词尾字符的内容到vi缓存区，相当于复制一个单词
 　　y$复制光标所在位置到行尾内容到缓存区
 　　y\^复制光标所在位置到行首内容到缓存区
 　　#yy例如：5yy就是复制5行
 　　#yw例如：2yw就是复制两个单词


如果要复制第m行到第n行之间的内容，可以在末行模式中输入m，ny例如：3，5y复制第三行到第五行内容到缓存区。

 5.查找和替换
 　　vi的查找和替换功能主要在末行模式完成：

 　　至上而下的查找
 　　/ 要查找的字符窜，其中/代表从光标所在位置起开始查找，例如：/ work

 　　至下而上的查找
 　　？要查找的字符窜 例如：/ work

 　　替换
 　　:s/old/new用new替换行中首次出现的old
 　　: s/old/new/g 用new替换行中所有出现的old
 　　:#,# s/old/new/g用new替换从第＃行到第＃行中出现的old
 　　：% s/old/new/g用new替换整篇中出现的old


如果替换的范围较大时，在所有的命令尾加一个c命令，强制每个替换需要用户进行确认，例如:s/old/new/c
或s/old/new/gc

 　　6恢复文件
 　　vi在编辑某一个文件时，会生成一个临时文件，这个文件以 . 开头并以
.swp结尾。正常退出该文件自动删除，如果意外退出例如忽然断电，该文件不会删除，我们在下次编辑时可以选择一下命令处理：

 　　O只读打开，不改变文件内容
 　　E继续编辑文件，不恢复.swp文件保存的内容
 　　R将恢复上次编辑以后未保存文件内容
 　　Q退出vi
 　　D删除.swp文件
 　　或者使用vi －r 文件名来恢复未保存的内容

 在GUI下：
 （1）可按i进入插入模式
 （2）使用鼠标拖动反选要粘贴的内容，按鼠标左键复制选定块到缓冲区

（3）然后将光标移到要粘贴处，按鼠标中键（两键鼠标可同时按左右键），粘贴缓冲区内容。

 在纯文本终端下：
 （1）选定文本块，使用v进入可视模式；移动光标键选定内容
 （2）复制选定块到缓冲区，用y；复制整行，用yy
 （3）剪切选定块到缓冲区，用d；剪切整行用dd
 （4）粘贴缓冲区中的内容，用p

 在同一编辑窗打开第二个文件，用:sp [filename]
 在多个编辑文件之间切换，用Ctrl+w

 命令前面加数字表示重复次数，加字母表示使用的缓冲区名称。
 获取帮助，用:help [内容或命令]
** [[http://blog.csdn.net/yunjie2008/article/details/5684983][Programming in Emacs Lisp笔记（七）基础函数:car, cdr, cons]]    :blog:


基础函数:car, cdr, cons
Lisp中car，cdr和cons都是基础函数。cons用于构造lists，car和cdr用于分割lisp。

奇怪的命名
cons函数的名称并非没有含意：它是单词'construct'的缩写。car是短语'Contents
of the Address part of the Register'；cdr（'could-er'）是短语'Contents
of the Decrement part of the
Register'。这些短语说明了Lisp是在多么原始的机器上被开发的。

car和cdr
一个list的CAR是list中的第一个元素。(rose violet daisy
buttercup)的CAR就是rose。

执行下面的代码：

(car '(rose violet daisy buttercup))执行这个语句后，回显区将显示rose。
有一个更合理的car函数：first。

car并不从list移除第一个元素；它只返回第一个元素。car执行完后list并没有发生改变。car是一个无害的函数（'non-destructive'）。

CDR是list中的其余部分，cdr函数返回list中首元素后面的其它元素。因此'(rose
violet daisy buttercup)的CDR部分是(violet daisy buttercup)。

对：

(cdr '(rose violet daisy buttercup))求值将在回显区显示(violet daisy
butercup)
cdr也不从列表中移除元素。

附带说明一下：在这个例子中list前面加了单引号。如果不加，Lisp解释器把rose当作函数执行。在这个例子中我们并不需要那样。

cdr的一个更合理的名称是：rest。

当car和cdr应用于符号组成的列表时，比如(pine fir oak
maple)，函数car将返回列表中的pine元素，并且pine不会被括号包含。这个list的CDR也是一个list，(fir
oak maple)。

如果car和cdr应用于包含list的list，第一个元素也是list。car将返回list中的第一个list元素。

car和cdr是无害的，它们不修改list中的数据。这是非常重要的一点。

在第一章中曾说过：“在Lisp中某些原子类型，比如数组，可以被分隔成更小的部分；但这种机制与分割list的机制是不同的。这与Lisp的早期
概念有关，list中的原子是不可分隔的。”（car和cdr也并不修改list。）car和cdr是用于分割list的基础函数。但它们不能用于分割数
组或者访问数组中的一部分。数组被看作原子类型。另一个基础函数cons可以用于构造列表，但也不能用于数组。

cons
cons函数是构造list的函数。例：

(cons 'pine '(fir oak maple))执行时回显区将显示(pine fir oak
maple)。cons将新的元素放到列表的开头，它将新元素推入list中。***
构造一个listcons函数必须要有一个可以被插入的list参数。构造一个list时，至少要提供一个空的list。下面是一些构造list的语句：<src
lang="lisp">(cons 'buttercup ())  => (buttercup)(cons 'daisy
'(buttercup))  => (daisy buttercup)(cons 'violet '(daisy
buttercup))  => (violet daisy buttercup)(cons 'rose '(violet daisy
buttercup))  => (rose violet daisy
buttercup)</src>在第一个例子中，()是一个空的list并且用空list和buttercup构造了一个list。可以看到空list并没有显示在被构造的list中。
只能看到(buttercup)。空list不会被当作一个list元素，因为空list中没有任何元素。空list是不可见的。
检查list的长度：length
可以用函数length检查list中的元素数量：

(length '(buttercup))  => 1(length '(daisy buttercup))  =>
2(length (cons 'violet '(daisy buttercup)))  =>
3也可以将length应用于空list上：
(length ())  => 0当调用length函数而不传递参数给它时：

(length)你将得到一个错误信息：
Wrong number of arguments: #<subr length="">,
0</subr>这表示函数接收到了错误的参数个数，0，函数需要一定数量的参数。在这里length需要一个参数，参数应该是一个list。（一个list也是一个参数而不管list中有多少元素）
错误信息中的#是函数的名称。#

nthcdr
nthcdr是一个与cdr相关的函数。它用于多次获取list的CDR部分。

如果获取(pine fir oak maple)的CDR部分，将得到(fir oak
maple)。如果在这个结果上再重复操作将得到(oak
maple)。（如果你在原来的list上取CDR，将一直得到同样的结果，因为原来的list并没有被修改）如果继续下去，将得到一个空的list，这
时将不会显示为()，而是显示为nil。 例：

(cdr '(pine fir oak maple))  =>(fir oak maple)(cdr '(fir oak
maple))  => (oak maple)(cdr '(oak maple))  =>(maple)(cdr
'(maple))  => nil(cdr 'nil)  => nil(cdr ())  =>
nil或者用下面的方式：
(cdr (cdr '(pine fir oak maple)))  => (oak
maple)nthcdr函数与多次调用cdr类似。下面的例子中，参数2和一个list被传递给nthcdr，返回的值与原list相比，不含前面两个元素，相当于在list上执行了两次cdr。

(nthcdr 2 '(pine fir oak maple))  => (oak maple);; Leave the list as
it was.(nthcdr 0 '(pine fir oak maple))  => (pine fir oak maple);;
Return a copy without the first element.(nthcdr 1 '(pine fir oak
maple))  => (fir oak maple);; Return a copy of the list without three
elements.(nthcdr 3 '(pine fir oak maple))  => (maple);; Return a copy
lacking all four elements.(nthcdr 4 '(pine fir oak maple))  => nil;;
Return a copy lacking all elements.(nthcdr 5 '(pine fir oak maple))
=> nilnth
nthcdr重复取list的CDR部分。nth函数取nthcdr返回值的CAR部分。它返回list中的Nth元素。

如果nth没有被因为效率原因而用C定义，那么nth的定义将会是下面的样子：

(defun nth (n list)  "Returns the Nth element of LIST.N counts from
zero.  If LIST is not that long, nil is returned."  (car (nthcdr n
list)))（最初的nth在定义在Emacs
Lisp文件subr.el中，但后来在1980年被重新用C实现。）
元素计数从0开始而不是1。这就是说list的第一个元素CAR是第零个元素。

(nth 0 '("one" "two" "three"))  => "one"(nth 1 '("one" "two"
"three"))  =>
"two"注意：nth与nthcdr和cdr一样，也不修改原来的list，也是一个无害函数。
setcar
从命名上就可以猜想到，setcdr和setcar函数用于设置list的CAR或CDR部分为一个新值。与car和cdr不同，它们将修改原始的list。

例：

(setq animals '(antelope giraffe lion tiger))animals  => (antelope
giraffe lion tiger)(setcar animals 'hippopotamus)animals  =>
(hippopotamus giraffe lion
tiger)可以看到setcar函数并非像cons那样向list中添加元素；它将giraffe替换为hippopotamus；它修改了list。
setcdr
setcdr与setcar函数类似，它用于替换list中除首元素外的其它元素。

例：

(setq domesticated-animals '(horse cow sheep
goat))domesticated-animals  => (horse cow sheep goat)(setcdr
domesticated-animals '(cat dog))domesticated-animals  => (horse cat
dog)
** [[http://blog.csdn.net/csfreebird/article/details/7197392][Emacs CMake mode使用]]    :blog:




CMake mode for emacs
提供了一些好的功能，一直都没有注意到这个mode，今天正式开始使用。

首先，下载cmake-mode.el文件

﻿﻿[[http://www.cmake.org/CMakeDocs/cmake-mode.el]]



放到自己的emacs plugin目录下：

/opt/emacs_plugins/cmake-mode.el



然后在.emacs文件中设置如下：

#+BEGIN_EXAMPLE
    (setq load-path (cons (expand-file-name "/opt/emacs_plugins") load-path))
    (require 'cmake-mode)
    (setq auto-mode-alist
          (append '(("CMakeLists\\.txt\\'" . cmake-mode)
                    ("\\.cmake\\'" . cmake-mode))
                  auto-mode-alist))
#+END_EXAMPLE




重新启动Emacs后，打开我的CMake工程的CMakeLists.txt文件,里面command关键字都已经变成高亮。

M-x 执行 cmake-help-list-commands
后，可以看到所有当前CMake版本支持的命令。

将光标停在某个command（比如AUX_SOURCE_DIRECTORY)之上，运行cmake-help-command
会看到关于AUX_SOURCE_DIRECTORY command的详细介绍。
** [[http://blog.waterlin.org/articles/bind-emacs-org-mode-with-bibtex.html][Emacs Org Mode 与 BibTeX 的结合]]    :blog:

Filed Under
([[http://blog.waterlin.org/articles/category/%e6%8a%80%e6%9c%af][技术]])
by waterlin

[[http://blog.waterlin.org/articles/publish-org-files-to-html-project.html][Emacs
Org Mode
可以是一个优秀的笔记工具]]，可是，如果你想用它来写正式一点的论文，可以吗？当然可以了，你可以[[http://orgmode.org/worg/org-contrib/babel/languages/org-babel-doc-LaTeX.php][把
Org Mode 和 LaTeX 结合起来用]]，当然最重要的是要解决参考文献引用的问题。

整体的思路如下：

1. 先准备好你的 BibTeX 文件

   可以用 Emacs BibTeX Mode 或 JabRef
   之类的方式来生成这个文件，当然也可以用其它文献管理工具，只要它能导出
   BibTeX 文件即可。

2. 用 Emacs Org 建立工程并记笔记

   [[http://blog.waterlin.org/articles/publish-org-files-to-html-project.html][创建
   Org 工程]]的时候，和一般的工程没有任何区别。

3. 用 RefTeX 方式来插入 BibTeX 的记录

在这里，重点介绍一下第三个步骤，即如何在 Org Mode 里插入 BibTeX
记录。从官方的[[http://orgmode.org/worg/org-faq.php#sec-18_11_1][这篇参考文献]]里可以看出，我们可以用三种方法在
org 文件里引用 BibTeX 参考文献，从而插入 LaTeX 类的参考文献。

1). 最简单的办法，给所有的 Org 文件指定一个 BibTeX 文件，然后在 Org
文件里插入该 BibTeX 文件的参考文献记录

具体的办法，先把下面的代码放到 .emacs 里：

#+BEGIN_EXAMPLE
    (setq reftex-default-bibliography
          (quote
           ("default.bib" "~/org/notes/refer.bib")))
    (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
#+END_EXAMPLE

在这里，我指定的 BibTeX 文件为 *default.bib* 和 *~/org/notes/refer.bib*
。然后，可以在所有的 Org 文件里，通过命令 *C-c )* 或 *M-x
reftex-citation* 来进行参考文献的插入，根据提示进行相关操作即可。

2). 为特定的 Org 文件，指定特定的 BibTeX 文件

这个方法是
[[http://www.mfasold.net/blog/2009/02/using-emacs-org-mode-to-draft-papers/][Marios
Braindump 的博客里介绍的]]，具体方法如下：

先把下面的代码放到 .emacs 里：

#+BEGIN_EXAMPLE
    (defun org-mode-reftex-setup ()
      (load-library "reftex")
      (and (buffer-file-name)
           (file-exists-p (buffer-file-name))
           (reftex-parse-all))
      (define-key org-mode-map (kbd "C-c )") 'reftex-citation))
    (add-hook 'org-mode-hook 'org-mode-reftex-setup)
#+END_EXAMPLE

然后在你需要插入 BibTeX 参考文献的 Org
文件里，加入下面这段话（可以是任意位置）：

#+BEGIN_EXAMPLE
    \bibliographystyle{plain}
    \bibliography{BIB-NAME}
#+END_EXAMPLE

把上面的 BIB-NAME 换成你想指定的 BibTeX 文件，这样就可以对该 Org
文件指定特定的 BibTeX 文件，然后可以用 *C-c )* 或 *M-x reftex-citation*
来插入该 BibTeX 文件里的参考文献。

上面的代码会在 Emacs 启动的时候，要求你指定一个 master
文件，用来存储生成的 tex 文件。

3). 另外一种方法，实现为特定的 Org 文件指定特定 BibTeX 文件的功能

还有[[http://orgmode.org/worg/org-faq.php#sec-18_11_2][另外一种方法]]，可以实现第2种方法类似的功能，即为特定
Org 文件指定特定 BibTeX 文件的方法。把下面的代码放到 .emacs 文件里：

#+BEGIN_EXAMPLE
    (defun org-mode-article-modes ()
      (reftex-mode t)
      (and (buffer-file-name)
           (file-exists-p (buffer-file-name))
           (reftex-parse-all)))

    (add-hook 'org-mode-hook
              (lambda ()
                (if (member "REFTEX" org-todo-keywords-1)
                    (org-mode-article-modes))))
#+END_EXAMPLE

然后把下面这一行加到你需要插入 BibTeX 的 Org 文件的开头：

#+BEGIN_EXAMPLE
    #+TODO: TODO(t) STARTED(s) | DONE(d) DEFERRED(f) REFTEX
#+END_EXAMPLE

其它步骤与第2种方法类似。这种方法我没有仔细测试，有兴趣的 Emacser
们可以试试。

通过以上方法，就可以在用 Org Mode 打造的笔记本里，很方便地索引 BibTeX
里的参考文献了。

当然，如果你不喜欢用 Org Mode，也有其它用 Emacs
来写论文的思路，例如：Emacs + AucTeX + RefTeX + Outline-minor-mode
** [[http://hahack.com/tools/ispell-and-flyspell/][ispell与emacs的拼写检查]]    :blog:

介绍ispell以及emacs里的拼写检查功能。

*** 了解Ispell

**** Ispell vs Aspell

Ispell是Unix下的一个拼写检查工具，支持多种语言（见：[[http://lasr.cs.ucla.edu/geoff/ispell-dictionaries.html][ispell
dictionaries]]），并且提供很多接口，其中包括了Emacs。另外一个比较出名的拼写检查工具是Aspell，两者的区别是Aspell不仅为拼错的单词提供形近的单词列表，还同时提供读音相似的单词的建议，e.g.如果你拼了一个错词“trubble”，Ispell只会建议“rubble”，而Aspell还会建议“trouble”、“dribble”、
“rubble”之类的词。不过Aspell的这种匹配算法只能用在英语单词上，而且在速度上以及指令的简单程度上不及Ispell。我使用的是Ispell，Aspell的配置可以参考[[http://aspell.net/0.61/man-html/Using-Aspell-with-other-Applications.html#Using-Aspell-with-other-Applications][这里]]。

**** 安装和配置Ispell

Ubuntu安装Ispell：

| #+BEGIN_EXAMPLE                                                   |
|     1                                                             |
| #+END_EXAMPLE                                                     |
|                                                                   |
| #+BEGIN_EXAMPLE                                                   |
|     $ sudo apt-get install ispell iamerican dictionaries-common   |
| #+END_EXAMPLE                                                     |


Arch安装Ispell：

| #+BEGIN_EXAMPLE                         |
|     1                                   |
| #+END_EXAMPLE                           |
|                                         |
| #+BEGIN_EXAMPLE                         |
|     $ sudo pacman -S ispell aspell-en   |
| #+END_EXAMPLE                           |


你可以试着在shell里直接使用ispell命令对一份文件进行拼写检查：

| #+BEGIN_EXAMPLE     |
|     1               |
| #+END_EXAMPLE       |
|                     |
| #+BEGIN_EXAMPLE     |
|     $ ispell FILE   |
| #+END_EXAMPLE       |


注意上面的FILE得你自己指定一个文件，建议是一份有英文单词的文件。如果能输出检查结果，说明此时Ispell运作正常。

如果提示找不到default.hash，那可能是没有把iamerican设为预设辞典的原因，解决方法如下：

| #+BEGIN_EXAMPLE                                               |
|     1                                                         |
| #+END_EXAMPLE                                                 |
|                                                               |
| #+BEGIN_EXAMPLE                                               |
|     $ cd /usr/lib/ispell/ sudo cp iamerican.hash default.sh   |
| #+END_EXAMPLE                                                 |


*** Emacs中的拼写检查（使用Ispell）

有些编辑器可以自动对我们输入的英语单词进行拼写检查，甚至还能给出拼写建议（比如Microsoft
Word），Emacs当然也可以做到这个功能，甚至更加强大。不过，Emacs本身并不提供这个功能，幸运的是像Ispell和Aspell这样的拼写检查工具都提供了Emacs相应接口，因此，通过在Emacs中调用Ispell的命令，我们可以一边编辑文件一边进行拼写检查。

Ispell和Aspell现在在Emacs已经内置支持，通常不需要自己安装。如果你发现Emacs里确实没有Ispell的支持，或者你想升级到最新的ispell.el，那就请参见[[http://www.kdstevens.com/stevens/ispell-faq.html#install][这里]]。

**** ispell-minor-mode：实时拼写检查

要让Flyspell随时根据你的输入提示错误拼写，可以打开*ispell-minor-mode辅模式*。在ispell-minor-mode 模式下，
当你输完一个单词时，Ispell
会自动帮您在辞典里查询这个单词，如果找不到这个单词，它就会/哔/一声来提醒您。

要启动或关闭这模式，请键入指令：

| #+BEGIN_EXAMPLE                      |
|     1                                |
| #+END_EXAMPLE                        |
|                                      |
| #+BEGIN_EXAMPLE                      |
|     M-x ispell-minor-mode <Return>   |
| #+END_EXAMPLE                        |


**** ispell-buffer：全文拼写检查

在emas中，可以使用*ispell-buffe*r命令，对光标之后的单词逐个进行拼写检查：

| #+BEGIN_EXAMPLE                  |
|     1                            |
| #+END_EXAMPLE                    |
|                                  |
| #+BEGIN_EXAMPLE                  |
|     M-x ispell-buffer <Return>   |
| #+END_EXAMPLE                    |


如果全文拼写正确，就会提示检查完成。如果发现不认识的单词，此时ispell将会把光标定在该单词的位置，在文本的上方会显示修改建议，如图1：

[[/images/ispell-and-flyspell/Evrd5.png]]

此时ispell会等待用户的进一步的指令：

| 键盘指令   | C-h 或者 ?       | 空格               | a/A                                            | r/R            | i/I                      | u                                    | q/Q            |
| 功能       | 获得进一步帮助   | 忽略这个错误拼写   | 在全文中都忽略这个单词（只在这个缓冲区有效）   | 修改这个单词   | 将这个单词加入个人辞典   | 将这个单词以小写的形式加入个人辞典   | 退出单词检查   |

如果文档中有多处相同的拼写错误，可以使用“R”进入查询替换，输入要替换的单词，当查找到第二个匹配的单词时，按下“!”将自动将接下来所有的单词替换成正确的单词。

[[/images/ispell-and-flyspell/iqdSB.png]]

[[/images/ispell-and-flyspell/bmhjf.png]]

使用Ispell要注意以下两点：

1. *Ispell是根据你所指定的辞典里的单词来确定这个词是否拼写正确的*。换句话说，如果某个单词没有在选定的辞典里有定义的话，即使它的拼写是正确的，Ispell也会把它当成错误的拼写。如果光标不在文章开头的第一个位置，要进行全文检查的话就得先使用M-<将光标移动到文章开头。
2. *同一个单词的不同形式，比如复数、过去式、过去分词等，在进行拼写检查时需要分别进行*。比如，如果你把receive拼成了“recieve”，Ispell会把“recieved”当成另外一个单词，所以这个拼写检查器会把它当作另外一个拼写错误找出来。

**** C-r：递归编辑

我们经常会遇到这种情况：当我们在查找修改某段文本的时候，可能会意外发现当前的查找结果周围有个地方需要修改，但因为现在正在进行查找修改，如果不想中断当前的工作，我们就只好等着完成查找修改工作后再找到刚刚那个位置，但却记不起来在那里了。拼写检查也可以看成一类查找（对错误拼写的查找），为了解决这个问题，Emacs给我们提供了一个贴心的编辑方法------递归编辑。

什么是递归编辑呢？我们可以把递归编辑看成一种中断：当你在进行某个查找任务的时候，还能够暂时中断当前的查找工作，去进行其他的编辑工作，完成后再跑回刚刚的中断的地方，继续未完成的查找。这和“递归”有什么联系呢？这是因为，这种中断可以嵌套！你可以在查找单词A的时候中断A的查找，进入一个递归编辑，在这个位置开始对B进行查找，突然在某个B的查找位置你又看到周围有个单词C要修改，你又可以暂时中断对B的查找，而进入另一个递归编辑。等你修改完C后，你可以回到上一个查找的中断位置，继续对B进行查找。等你查找完B之后，你又可以回到再上一个查找的中断位置，继续对A进行查找。说起来很复杂，其实道理非常简单。我还是“一图以蔽之”吧：

[[/images/ispell-and-flyspell/Gmot9.png]]

使用方法：

| C-r            | C-M-c                        | C-] (命令：top-level)          |
| 进入递归编辑   | 结束递归编辑并继续拼写检查   | 结束递归编辑，并退出拼写检查   |

例如，在在修改“xmas”的时候，突然发现要修改“newyear.”

[[/images/ispell-and-flyspell/Y088c.png]]

C-r进入递归编辑，使用replace-string命令将“newyear.”改成“new year!”

[[/images/ispell-and-flyspell/N9Ow2.png]]

**** Ispell-word：检查单个单词

有时候我们拼写某个单词脑袋壳突然卡住了：“哎，这个词怎么拼啊？”或者“我好像拼得不对”。这时，我们可以利用Ispell来单独检查光标所在的这个单词，如果想对光标位置上的单词进行检查，请按下
=M-$=
（命令名是ispell-word）组合键，或者从【Spell】拼写菜单里选择执行“Check
Word”（检查单词）操作，Ispell将对那个单词进行检查，并给出检查结果。

| #+BEGIN_EXAMPLE                      |
|     1                                |
| #+END_EXAMPLE                        |
|                                      |
| #+BEGIN_EXAMPLE                      |
|     M-$ (M-x ispell-word <Return>)   |
| #+END_EXAMPLE                        |


[[/images/ispell-and-flyspell/SltMB.png]]

**** ispell-complete-word：单词补全

有时我们想不起来要怎么拼一个单词，这就到Ispell的单词补全功能大展身手的时候了。敲击ESC-tab（命令名是ispell-complete-word），将获得一个可供选择的列表。

| #+BEGIN_EXAMPLE                            |
|     1                                      |
| #+END_EXAMPLE                              |
|                                            |
| #+BEGIN_EXAMPLE                            |
|     ESC-tab（M-x ispell-complete-word ）   |
| #+END_EXAMPLE                              |


[[/images/ispell-and-flyspell/gCBFZ.png]]

**** ispell-kill-ispell：终止Ispell进程

只要启用了Ispell，它就将一直在后台运行等待再次启用。如果觉得它使得系统变慢了，可以输入
=M-x ispell-kill-ispell <Return>=
杀掉这个进程，或是从“Spell”菜单里选择执行“Kill
Process（终止进程）”操作。

| #+BEGIN_EXAMPLE               |
|     1                         |
| #+END_EXAMPLE                 |
|                               |
| #+BEGIN_EXAMPLE               |
|     M-x ispell-kill-ispell    |
| #+END_EXAMPLE                 |


*** Emacs中的高亮错误拼写

**** 什么是Flyspell

Flyspell是Ispell的增强工具，Ispell只能够在缓冲区里逐个提示错误的拼写，如果想要用下划线的形式标记出所有错误的拼写，可以使用Flyspell。这样的好处是你可以继续编辑你的文本，而不需要进入查找模式。很多高级的编辑器都是采用这样的方式来提醒用户可能存在的错误拼写。

**** flyspell-mode：实时高亮提醒错误拼写

要让Flyspell随时根据你的输入提示错误拼写，可以打开*flyspell-mode*模式：

| #+BEGIN_EXAMPLE          |
|     1                    |
| #+END_EXAMPLE            |
|                          |
| #+BEGIN_EXAMPLE          |
|     M-x flyspell-mode    |
| #+END_EXAMPLE            |


例如，打开Flyspell辅模式后，在缓冲区中输入“applle.”之后，Flyspell将对applle高亮显示。

[[/images/ispell-and-flyspell/2Awhx.png]]

flyspell-mode和ispell-minor-mode的区别主要是flyspell的错误拼写提醒方式是用下划线，而ispell-minor-mode则会在消息窗口进行提示，并/哔/一声进行提醒，有时候会让人厌烦（当然，可以通过设置关闭声音提醒）。因此，flyspell显得比较“安静”，因此更受人喜欢。

**** flyspell-buffer：查找错误拼写并高亮

如果只需要检查一下缓冲区现有的文本，可以使用*flyspell-buffer*：

| #+BEGIN_EXAMPLE            |
|     1                      |
| #+END_EXAMPLE              |
|                            |
| #+BEGIN_EXAMPLE            |
|     M-x flyspell-buffer    |
| #+END_EXAMPLE              |


[[/images/ispell-and-flyspell/1n2zn.png]]

flyspell-buffer和ispell-buffer的区别：*ispell-buffer是进入对错误拼写的查找，并逐个提示错误的拼写，而flyspell-buffer会在检查完所有拼写后，一次性将所有找到的错误以下划线的形式标记出来。*

要对Flysepll高亮的文本进行修改，可以将鼠标移到该单词上，点击 *鼠标中键 *，将弹出一个菜单。（什么？没有鼠标中键？听我的，你真的需要去买一个新鼠标了
:tounge:
）如果要在当前编辑的缓冲区中接受这个拼写，可以在弹出菜单中选择Accept(session)；如果要在本次Emacs运行期间打开的所有缓冲区中接受这个拼写，可以选择Accept(buffer)；如果要永久记住这个拼写，可以选择Save
this word。

还有一种专门为程序员提供的辅模式flyspell-prog-mode，Emacs将只在注释和字符串里高亮错误的拼写。

| #+BEGIN_EXAMPLE               |
|     1                         |
| #+END_EXAMPLE                 |
|                               |
| #+BEGIN_EXAMPLE               |
|     M-x flyspell-prog-mode    |
| #+END_EXAMPLE                 |


*** 其他定制

**** 让Emacs自动开启flyspell-mode

对于很多打字员来说，*flyspell-mode*是一个非常实用的辅模式，如果想要让Emacs启动时自动打开flyspell-mode，可以在.emacs文件里添加这一行：

| #+BEGIN_EXAMPLE                               |
|     1                                         |
| #+END_EXAMPLE                                 |
|                                               |
| #+BEGIN_EXAMPLE                               |
|     (setq-default flyspell-mode t) <Return>   |
| #+END_EXAMPLE                                 |


**** 选择Ispell预设辞典

如果你为Ispell安装了不止一个辞典，你可以设定Emacs，使之在开始载入某一文件时，便自
动选择所需的辞典（你可以选择好几个）。预设辞典(main dictionary)
即主要辞典，是与
Ispell一起发行的辞典。您可以选择您所需要的语言。第二个即是你的个人辞典(personal
dictionary)，你可以设定要
Ispell将您在主要辞典里所找不到的字放到这里。假如您要将
Ispell里的法文辞典设为预设辞典，并想用你主目录 (home directory)下的
‘.ispell-dico-perso' 文档作为个人辞典，可以在 ‘.emacs'
文档里加入下列指令：

| #+BEGIN_EXAMPLE                                                                                                                                               |
|     12345                                                                                                                                                     |
| #+END_EXAMPLE                                                                                                                                                 |
|                                                                                                                                                               |
| #+BEGIN_EXAMPLE                                                                                                                                               |
|     (setq sgml-mode-hook'(lambda () "Defauts for SGML mode."(setq ispell-personal-dictionary "~/.ispell-dico-perso")(ispell-change-dictionary "francais")))   |
| #+END_EXAMPLE                                                                                                                                                 |


**** 为特定文件设定个别的辞典

在每一个文档的结尾，只要将下列指令加入作为注释，你都可以指定您现行的文档要使用哪一辞典。
Ispell 开始拼字检查时即可应用所指定的辞典：

| #+BEGIN_EXAMPLE                                                                                |
|     12                                                                                         |
| #+END_EXAMPLE                                                                                  |
|                                                                                                |
| #+BEGIN_EXAMPLE                                                                                |
|     <!-- Local IspellDict: english --><!-- Local IspellPersDict: ~/emacs/.ispell-english -->   |
| #+END_EXAMPLE                                                                                  |


*** 本文参考资料

1. [[http://www.google.com.hk/url?sa=t&rct=j&q=Learning+GNU+Emacs&source=web&cd=1&ved=0CCwQFjAA&url=http%3A%2F%2Fbook.douban.com%2Fsubject%2F1431970%2F&ei=Npr1Ttv4OeaziQeg4KXuAw&usg=AFQjCNGR0JeJmtslTGgFcY3le75a1jIIhA&sig2=CvEr-ea6iU4hRy06oFG2Sg][Learning
   GNU Emacs, 3rd Edition(Debra Cameron, James Elliott, Marc Loy)]]
2. [[http://man.chinaunix.net/linux/how/LinuxDoc+Emacs+Ispell-HOWTO-5.html][LinuxDoc+Emacs+Ispell-HOWTO中文版(Philippe
   MARTIN, Sébastien Blondeel, 李安珊)]]
** [[http://m.oschina.net/blog/124113][]]    :blog:

使用iimage-mode可以在buffer里面显示图片，改了一个lisp函数来实现截屏、保存文件并插入到buffer中的功能。参考了这个： http://dreamrunner.org/wiki/public_html/Emacs/org-mode.html#sec-2-3


安装起来很简单：

安装scrot，会用这个工具来截图

创建一个文件夹 ~/.emacs.img ，截屏产生的图片会保存到这里

把下面的lisp放到emacs的配置文件中(我把截屏的快捷键绑定到了C-p上面)

;;;  image for org-mode
; 1. suspend current emacs window
; 2. call scrot to capture the screen and save as a file in $HOME/.emacs.img/
; 3. put the png file reference in current buffer, like this:  [[/home/path/.emacs.img/1q2w3e.png]]

(add-hook 'org-mode-hook 'iimage-mode) ; enable iimage-mode for org-mode
(defun my-screenshot ()
  "Take a screenshot into a unique-named file in the current buffer file
  directory and insert a link to this file."
  (interactive)
  (setq filename
    (concat (make-temp-name
         (concat  (getenv "HOME") "/.emacs.img/" ) ) ".png"))
  (suspend-frame)
  (call-process-shell-command "scrot" nil nil nil nil " -s " (concat
                                "\"" filename "\"" ))
  (insert (concat "[[" filename "]]"))
  (org-display-inline-images)
  )

(global-set-key (kbd "C-p") 'my-screenshot)
** [[http://blog.163.com/wobutianl@126/blog/static/1335848201293033635805/][emacs 计算器  ]]    :blog:


1. Quick Calculator模式

在Emacs23里，可以用命令M-x quick-calc或快捷键C-x * q来启动Quick Calculator模式。这是一个非常小巧的工具，启动后会在minibuffer里提示输入数学计算式，回车就显示结果。这个模式能非常方便地用来做一些基本的数学运算，比用系统自带的计算器来得方便、快捷一些。

用C-g可以退出Quick Calculator模式。

2. programmable calculator

在Emacs23里，用命令M-x Calc或是通过菜单”Tools –> Programmable Calculator“就可以启用programmable calculator模式。总的来说，programmable calculator模式可以有以下三方面的用途：

(1) 数学计算

如果要计算1 + 2的值，输入”1 回车 2 回车 +”即可。

(2) 在二进制、八进制、十进制与十六进制之间进行转换

输入”10 回车 d2″，这个d2会把窗口中的所有数字显示为二进制形式，所有的数字都会以”2#”开头，以表示它们是二进制形式。如果要重新用十进制显示，则输入”d0″即可。

同样，也可以用”d8″，”d6″来显示八进制和十六进制的格式。

如果要把1010这样的二进制数转成十进制数，则输入”2#1010 回车”，然后再输入”d0″就可以显示该数字的十进制格式。

同样，输入八进制数以”8#”开头，输入十六进制以”16#”开头。

(3) 温度单位转换

如果你想知道40 F°是多少C°，输入”40 回车 ut dF 回车 dC 回车”即可，这下就不会再为这些温度单位换算弄得晕头转向了吧！

如果要退出programmable calculator这个计算器，则输入”q”即可。

总的来说，这个programmable calculator风格有点怪异，不是太复杂的功能，还是不要用为好。
** [[http://blog.csdn.net/argansos/article/details/6867575][Eshell]]    :blog:

eshell 并不是一个真正的 shell，它只能在 emacs 上运行。尽管和 bash、zsh
相比,它的功能很有限，但对大多数人来说已经足够了。此外,由于 eshell 是 由
elisp 编写的，所以它还有其他 shell
所没有的一些特点，比如更强的扩展性和可以使用 emacs 函数。

1. alias

eshell 添加 alias 的方法和 bash 几乎是相同的，并且默认保存在
~/.eshell/alias。不同的是,eshell 中既可以使用外部命令，也可以使用 emacs
函数，比如:

#+BEGIN_EXAMPLE
    alias ll ls -al $*
    alias dl dpkg -l $1
    alias e find-file $1
    alias v view-file $1
    alias sai sudo aptitude install $1
#+END_EXAMPLE



2. histroy

bash 中有很多变量控制命令历史，比如: HISTCONTROL、HISTIGNORE 和
HISTFILESIZE。和它们相对应的 eshell
变量是 eshell-hist-ignoredups、eshell-input-filter
 和 eshell-history-size。eshell-hist-ignoredups
决定是否忽视重复的命令，eshell-history-size 控制历史文件的大小。
eshell-input-filter 的值其实是一个函数,我们每输入一条命令，这条命令会
作为参数传递给 eshell-input-filter，如果返回
t，这条命令才会被保存到历史中。它默认只过滤空白命令，如果要过滤
ls、cd、clear，可以这样修改:

#+BEGIN_EXAMPLE
    (defvar eshell-histignore
    '("\\`\\(ls\\|ll\\|cd\\|clear\\)\\'"
    "\\`\\s-*\\'"))
    (setq eshell-input-filter
    #'(lambda (str)
    (let ((regex eshell-histignore))
    (not
    (catch 'break
    (while regex
    (if (string-match (pop regex) str)
    (throw 'break t))))))))
#+END_EXAMPLE



3. completion

zsh 的补全据说非常强大，安装 bash-completion 后 bash
的补全也变得不错。eshell
的补全虽然没有前两者丰富，但却很灵活,自定义也很简单。eshell 的补全依靠
pcomplete，以定义上面的 sai 的补全函数为例。

首先获取当前符合名称的软件包的列表:

#+BEGIN_EXAMPLE
    (defun pcmpl-package-cache (name)
    "return a list of packages in cache"
    (unless (equal name "")
    (split-string (shell-command-to-string
    (concat "apt-cache pkgnames " name " 2> /dev/null")))))
#+END_EXAMPLE


 其次定义 sai 的补全函数:

#+BEGIN_EXAMPLE
    (defun pcomplete/sai ()
    "completion for `sai'"
    (while
    (pcomplete-here
    (pcmpl-package-cache (pcomplete-arg 'last)))))
#+END_EXAMPLE


 现在在 eshell 里就可以按 TAB 对 sai 进行软件包名字的补全了。
 eshell 的一些补全选项:

#+BEGIN_EXAMPLE
    (setq eshell-cmpl-ignore-case t      ; 补全时忽略大小写
    eshell-cmpl-cycle-completions nil) ; 不要循环补全
#+END_EXAMPLE


 4. cd path

在 bash 里我们可以通过 cd - 回到上一个目录，eshell
同样可以。不仅如此，cd -<number>会回到倒数第 number个目录。cd =<REGEXP>
会回到上一个满足 REGEXP 的目录。zsh 中有对路径的别名，cd~X可以进入 ~X
所指代的目录，当目录比较深或很常用时非常方便。这在 eshell
也可以方便地实现。

首先定义一个别名与路径的关联表:

#+BEGIN_EXAMPLE
    (defvar eshell-path-alist
    `(("e" . ,user-emacs-directory)
    ("t" . "/tmp/")
    ("document" . "~/Documents/")
    ("download" . "~/Downloads/")
    ("v" . "~/video/")
    ("p" . "~/Pictures/")))
#+END_EXAMPLE


 现在直接修改ehsell/cd是可行的，但另外定义一个函数更方便:

#+BEGIN_EXAMPLE
    (defun eshell/d (arg)
    (let ((path (cdr (assoc arg eshell-path-alist))))
    (eshell/cd path)))
#+END_EXAMPLE


 eshell /d 的补全函数也很容易:

#+BEGIN_EXAMPLE
    (defun pcomplete/d ()
    (pcomplete-here
    (mapcar #'car eshell-path-alist)))
#+END_EXAMPLE


 现在直接输入 d t 就可以进入 /tmp
** [[http://blog.csdn.net/yzzst/article/details/12045801][linux下apache 的安装，php安装过程]]    :blog:

linux下apache 的安装
1、进入work目录下:cd /usr/local/work
（如没有则自己新建，命令：mkdir /usr/local/work）

2、在work目录下从网站下载apache并解压：
wget http://dev.xiaonei.com/apache-mirror/httpd/httpd-2.0.63.tar.gz
解压：tar zxvf httpd-2.0.63.tar.gz

3、进入httpd-2.0.63目录：cd httpd-2.0.63

4、建立makefile，并将Apache安装到/usr/local/apache2目录下：
./configure -prefix=/usr/local/apache2 -enable-module=so   （/configure前有一个点“.”的）

5、开始编译：make

6、开始安装Apache到work目录中：
make install

7、至此Apache的安装工作完成，可以在每次启动系统时通过如下命令启动或重新启动Apache服务：
/usr/local/apache2/bin/apachectl start
/usr/local/apache2/bin/apachectl restart

8、打开浏览器,在地址栏输入“http://localhost”出现“It works!”或apache图标的漂亮界面，说明apache安装成功！




//////////////PHP 安装////


1.获取安装文件： http://www.php.net/downloads.php   http://cn2.php.net/distributions/php-5.5.4.tar.gz
wget http://cn2.php.net/distributions/php-5.5.4.tar.gz


获取安装php需要的支持文件：http://xmlsoft.org/sources/libxml2-2.9.1.tar.gz
wget http://xmlsoft.org/sources/libxml2-2.9.1.tar.gz


2.安装libxml2


 tar zxvf libxml2-2.9.1.tar.gz
 cd libxml2-2.9.1.
 ./configure --prefix=/usr/local/libxml2
 make
 make install




如果安装成功以后，在/usr/local/libxml2/目录下将生成bin、include、lib、man和share五个目录。在后面安装PHP5源代码包的配置时，会通过在configure命令的选项中加上"--with-libxml-dir=/usr/ local/libxml2"选项，用于指定安装libxml2库文件的位置。






3.安装php5




#tar zvxf php-5.5.4.tar.gz
#cd php-5.5.4
#./configure --prefix=/usr/local/php --with-apxs2=/usr/local/apache2/bin/apxs --with-libxml-dir=/usr/local/libxml2
#make
#make install


4.重新配置apache2让他支持php


配置 httpd.conf 让apache支持PHP：
# vi /usr/local/apache2/conf/httpd.conf


找到 AddType application/x-gzip .gz .tgz 在其下添加如下内容


     AddType application/x-httpd-php .php      (.前面有空格)


AddType application/x-httpd-php-source .phps        (.前面有空格)


然后CPOPY PHP的配置文件
cp php-5.5.4/php.ini.dist /usr/local/php/lib/php.ini


    （如果没有php.ini.dist 则把php.ini-development php.ini-production中的任何一个重命名为php.ini.dist即可。）


修改php.ini文件 增加 register_globals = On


重启apache
service apache restart


5.测试php是否成功安装


写一个php测试页info.php，放到apache2/htdocs中。


<?php


 phpinfo();


?>;


在浏览器中输入：服务器地址/info.php


如果能正常显示出php的信息，则说明Apche+Mysql+PHP安装成功！






今日编译apache时出错：//////////////////////////////////


#./configure --prefix……检查编辑环境时出现：


checking for APR... no
configure: error: APR not found .  Please read the documentation


解决办法：


1.下载所需软件包：


wget http://archive.apache.org/dist/apr/apr-1.4.5.tar.gz
wget http://archive.apache.org/dist/apr/apr-util-1.3.12.tar.gz
wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.10/pcre-8.10.zip
2.编译安装：


yum remove apr-util-devel apr apr-util-mysql apr-docs apr-devel apr-util apr-util-docs
具体步骤如下:


  a:解决apr not found问题>>>>>>


[root@xt test]# tar -zxf apr-1.4.5.tar.gz
[root@xt test]# cd  apr-1.4.5
[root@xt apr-1.4.5]# ./configure --prefix=/usr/local/apr
[root@xt apr-1.4.5]# make && make install

  b:解决APR-util not found问题>>>>


[root@xt test]# tar -zxf apr-util-1.3.12.tar.gz
[root@xt test]# cd apr-util-1.3.12
[root@xt apr-util-1.3.12]# ./configure --prefix=/usr/local/apr-util -with-apr=/usr/local/apr/bin/apr-1-config
[root@xt apr-util-1.3.12]# make && make install


  c:解决pcre问题>>>>>>>>>


[root@xt test]#unzip -o pcre-8.10.zip
[root@xt test]#cd pcre-8.10
[root@xt pcre-8.10]#./configure --prefix=/usr/local/pcre
[root@xt pcre-8.10]#make && make install
4.最后编译Apache时加上：


--with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util/ --with-pcre=/usr/local/pcre
** [[http://www.cam.hi-ho.ne.jp/oishi/indexen.html][XKeymacs]]    :blog:

XKeymacs is a keyboard utility to realize emacs like-useability on all
windows applications. With XKeymacs you can use emacs keybindings with
any windows application. You can create a keyboard macro and assign any
shortcut key too. You also get bash-like command completion in your DOS
shell. If you do not know Emacs, Xemacs, Mule or Meadow, you probably
want nothing to do with XKeymacs. I began to make XKeymacs because I
wanted to add C-t and C-l to Keymacs. Now that all the functions I want
are available, I think I will burnish XKeymacs by adding new functions
that users want and to fix bugs.
 Supported OS: Windows 95, 98, Me, NT 4.0, 2000, XP, 2003, Vista
(Internet Explorer 5.0 is required on Windows 95, 98 or NT 4.0.)

[[xkeymacs347.zip][xkeymacs347.zip (198,839 bytes)]]
 It includes xkeymacs.exe, xkeymacs.dll, [[readmeen.html][Readme.txt]],
[[readme.html][Readme_J.txt]], [[dot.xkeymacs]],
[[faqen.html][FAQ.txt]], [[faq.html][FAQ_J.txt]],
[[releaseen.html][release.txt]], [[release.html][release_J.txt]],
[[specen.html][spec.txt]] and [[spec.html][spec_J.txt]].


 [[xkeymacssrc347.zip][xkeymacssrc347.zip (181,788 bytes)]]
 It is the [[sourceen.html][source code]] of xkeymacs.exe and
xkeymacs.dll. You can compile them by using Microsoft Visual C++ 6.0.
 - You have to install
[[http://www.microsoft.com/msdownload/platformsdk/sdkupdate/][Microsoft
Platform Software Development Kit (SDK)]] and add include/lib directory
at the top of list on Directory tab in Options dialog of Microsoft
Visual C++ 6.0.

 [[xkeymacs347.msi][xkeymacs347.msi (246,272 bytes)]]
 It is installer of XKeymacs.
 [[xkeymacsins347.zip][xkeymacsins347.zip (218,445 bytes)]]
 It is the source of the installer. You can build them by Microsoft
Visual Studio Installer.

[[http://xkeymacs.sourceforge.net/archive/][Archive of old versions]]

[[xkeymacsen.png]]

[[http://lists.sourceforge.net/lists/listinfo/xkeymacs-support][Mailing
List]]
 Please tell me your impression, question, request, etc. I announce bug
information and new version release news on this ML.

Known Problems (or Specifications?!)

- C-l does not work well with someapplications.
- M-? by the Alt key is ignored with Microsoft Visual C++ or Netscape.
   (It works well if you retry.)
- C-r works as C-s with Internet Explorer if Find dialog does not
   appear.
- C-t, etc. do not work well with command prompt.
- C-k works as C-f on an edit box for a password.
- XKeymacs version 1.16 and later will be occured Invalid Page Fault
   error of Kernel32.dll on Windows 95.
    (But only the dialog pop up, OS and/or applications are never
   ABEND.)
- XKeymacs causes an application error when you shutdown Windows NT.
- XKeymacs conflicts with X-mouse of Tweak UI.
- XKeymacs conflicts with KbdAcc. (Acceleration does not work well in
   some case.)

Notes
 The xkeymacs.exe require the mfc42.dll and the msvcrt.dll. If your
system does not have these files, the xkeymacs.exe pop up an error
message. When an error message is poped up, you must get the mfc42.dll
(ex. from
[[http://www.vector.co.jp/soft/win95/util/se040499.html][here]]) and the
msvcrt.dll and put them in the directry which include the xkeymacs.exe.
** [[https://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/][Research Paper Management with Emacs, org-mode and RefTeX]]    :blog:

January 4, 2011

/Update 3-11-14: / **Nuno Salgueiro* *in the comments led me to a RefTeX
change that broke the “jump to this entry in notes.org” behavior (it
seems “reftex-citation” returns a list now, regardless if there is only
one entry). This can be fixed by changing (reftex-citation t) to (first
(reftex-citation t)).

/Update 1-19-11:/ I've added a screencast of me demonstrating how I use
this setup to work with my papers, I've also re-written the “Workflow”
section (due to the fact it was kind of confusing...) Hope this all
helps :]

/Update 4-27-12:/  *olberger* (in the comments section) has added, what
I consider, an incredibly clever and useful function to help when
writing papers. I've just finished tweaking it slightly for my purposes,
but please check out his post,
[[http://www-public.it-sudparis.eu/~berger_o/weblog/2012/03/23/how-to-manage-and-export-bibliographic-notesrefs-in-org-mode/][here]].
I'll be adding what I did to this post... when I get around to it.

My labmates and I have been searching for a while now for methods to
organize the mountain of research papers we collect as graduate
students. I've tried a handful of approaches, and was happy using
zim-wiki for a while, but entering info became a choir, and finding a
paper could sometimes be a hassle.

My recent attempts at working with lisp have led me to switch to emacs,
and in what seems to be a common occurrence, I wanted to do everything
in emacs. As silly as that sounds, I believe I've found my solution to
organize my papers through emacs.

Managing papers and references in emacs is nothing new, and I actually
followed a few guides on how other people used org-mode and reftex to do
so. Specifically this
[[http://www.mfasold.net/blog/2009/02/using-emacs-org-mode-to-draft-papers/][post]],
and this
[[http://article.gmane.org/gmane.emacs.orgmode/2406/match=bibliography][email]].
My hope with this initial post is to pull the bits together, show what I
built on top of them, and how I setup my org files to facilitate my
workflow. If you don't know how to use or don't know what emacs and
org-mode are, give a quick search--there is plenty of info out there.

***** *Setting up RefTeX*

First, we want to load to load RefTeX whenever we use org-mode. This is
well documented, and mine only differs in the citation formats I pass to
RefTex, and my additional key binding.

#+BEGIN_EXAMPLE
    (defun org-mode-reftex-setup ()
      (load-library "reftex")
      (and (buffer-file-name) (file-exists-p (buffer-file-name))
           (progn
         ;enable auto-revert-mode to update reftex when bibtex file changes on disk
         (global-auto-revert-mode t)
         (reftex-parse-all)
         ;add a custom reftex cite format to insert links
         (reftex-set-cite-format
          '((?b . "[[bib:%l][%l-bib]]")
            (?n . "[[notes:%l][%l-notes]]")
            (?p . "[[papers:%l][%l-paper]]")
            (?t . "%t")
            (?h . "** %t\n:PROPERTIES:\n:Custom_ID: %l\n:END:\n[[papers:%l][%l-paper]]")))))
      (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
      (define-key org-mode-map (kbd "C-c (") 'org-mode-reftex-search))

    (add-hook 'org-mode-hook 'org-mode-reftex-setup)
#+END_EXAMPLE

***** *Jump to Entry*

The other difference I added was the binding of  “C-c (” to
org-mode-reftex-search, which I defined earlier in my init.el. This is
the command that will jump to the entry in my org-mode file, and follows

#+BEGIN_EXAMPLE
    (defun org-mode-reftex-search ()
      ;;jump to the notes for the paper pointed to at from reftex search
      (interactive)
      (org-open-link-from-string (format "[[notes:%s]]" (reftex-citation t))))


    (defun org-mode-reftex-search ()
      ;;jump to the notes for the paper pointed to at from reftex search
      (interactive)
      (org-open-link-from-string (format "[[notes:%s]]" (first (reftex-citation t)))))
#+END_EXAMPLE

Simple. But I was happy with the results. /Update:/ changes in reftex
from initial authoring of this post have reftex-citation return a list.
An updated function to fix this has been added :P

***** *Making Org-mode work with you*

Lastly, org-mode needs a few things to pull all this together. The first
and most important is importing the bibtex file. RefTeX looks for a
LaTeX \bibliography tag anywhere in the file, I place mine as an
org-mode comment at the start of the file

#+BEGIN_EXAMPLE
    # \bibliography{~/research/refs.bib}
#+END_EXAMPLE

The other thing needed is link abbreviations. While you could hardcode
this into your citation formats, I prefer to put abbreviations in for
the citation formats, and define defaults elsewhere in my init.el

#+BEGIN_EXAMPLE
    (setq org-link-abbrev-alist
          '(("bib" . "~/research/refs.bib::%s")
        ("notes" . "~/research/org/notes.org::#%s")
        ("papers" . "~/research/papers/%s.pdf")))
#+END_EXAMPLE

These can be easily overridden in an org-mode file, which I actually do
for the org-mode file I store the actual entries in. If I left it as is,
following a “notes” link in this org-mode file would open the same file
in a new window and jump to the entry in that one. Not quite what we
want. This is where I override it in the local file by adding this to my
heading.

#+BEGIN_EXAMPLE
    #+LINK: notes #%s
#+END_EXAMPLE

Now, if I follow a “notes” link in the entries file, it jumps to that
entry in the same frame, while following a “notes” link in another
org-mode file (or using my new reftex search addition) will open this
file in a new frame and jump to the entry.

***** *Workflow*

My setup for this involves two main files: /refs.bib,/ the main bibtex
file, and /notes.org,/ the org-mode file I use to manage the papers and
store notes for each.

In /notes.org/ my overall workflow follows a typical org-mode
hierarchical layout, the key parent being “Papers” with each child
heading being either a category or an entry for a paper, each with the
appropriate or useful org-mode tags. Each paper headline corresponds to
that paper, and I write notes under these headlines about the paper.

The hierarchical layout has children inheriting parents tags which is
quite nifty. This is my initial lookup method when I'm looking for a
paper. For example, I want to find a paper that describes how to couple
EDOT using an iron catalyst, I can type “C-c \” to do a tag search, type
in one or all of the relevant keywords, and org-mode will show the
entries matching those tag[s]. I can then expand those entries, see what
notes I've written on the papers, and when I found the one I'm looking
for, I can open the link to the pdf I've placed there using “C-c C-o”.

When I find a new paper I need to add, I initially gather all the data I
need to use org-mode: the bibtex entry and the paper itself. I modify
the bibtex key to fit with my scheme (FirstAuthorYear) but you can use
whatever suites you best. I then save the paper using that bibtex key as
the filename in another folder.

Note: I manage my bibtex entries by first saving each new bibtex entry
as a separate file in a collective folder (due to the fact I usually
export them from the journal's website when I find the paper) and then I
concatenate all the files in that folder to make a new bibtex file using

#+BEGIN_EXAMPLE
    $ cat bibtex/*.bib > refs.bib
#+END_EXAMPLE

This feels a little messy, but the easiest solution I could think of;
I'm sure I could setup a command to do this for me from emacs, but this
is a low priority. The one problem with this is if you change the bibtex
file while org-mode is running, RefTeX will not see the changes. To do
so you need to enable “global-auto-revert-mode” in emacs. Supposedly,
this is automatically enabled in emacs 23, but it seems to be disabled
by default for me (23.2.1)

Adding a new headline in my /notes.org/ file is simplified by using
RefTex. I place my cursor on a new line and hit “C-c )” which is bound
to “reftex-citation”. The first prompt is for a citation format (if more
than one) and I have a few for different purposes. I hit ‘h' for
heading, which contains all the formatting for a barebones paper
headline. This puts a new entry with the title of the paper as the
headline, a propeties list with custom-id of the bibtex key (this allows
linking to this entry by it's bibtex key), and a body containing a link
to the pdf. After selecting the format, RefTeX prompts for a regex to
search the bibtex file with, presenting a list of matching entries.
Selecting the desired entry inserts the citation, in this case, the new
entry.

This is how we exploit RefTeX, we create custom citation formats that
are really org-mode tags and formattings. A few other formats I have are
all org-mode links: one that links to the entry in the bibtex file
itself, one that links to the pdf, and another that links to the entry
in the org-mode file. I use org-mode link abbreviations to get general
behavior that can be changed on a per-file basis.

Another option I recently added to this is a way to search for other
info I may not have placed in a tag, such as an author or journal name.
Here I shamelessly take adavtage of having reftex loaded again. I bound
this key to a custom command I made that will jump to the entry for the
bibtex entry you select from the reftex-citation prompt.

And that's that! So far, this is the most powerful approach I have
found, and I know I've spent less time searching than any other method
I've found. What's also great about this is that org-mode's exporting
allows me to export this as HTML to serve up on our group's website for
the rest of my group to use. An additional benefit is that because I'm
already gathering bibtex entries, when it comes time to write a paper, I
already have all my citation data, and I can easily search a key to
retrieve all my notes on that paper as well.

There are some weaknesses I'm still trying to work out, such as manually
scraping bibtex entries and making sure everything has the proper
filename. The problem really is that all the journals aren't consistent
with these things (some don't even provide bibtex export! Luckily,
there's bibutils to handle the conversions) and entries need to be
tweaked and/or pdf's named according to the key. Ideally, I would like
to find a database that I could script a tool against to scrape the data
I need and already name and places the files for me, but that is for
another day/entry

I've been trying to see about using attachments to handle the papers
instead, but I haven't been able to tweak it to my satisfaction just
yet. Still trying though. This should allow me to attach multiple files
for an entry (such as supporting info, etc)

** [[http://www.mfasold.net/blog/2009/02/using-emacs-org-mode-to-draft-papers/][Using Emacs Org-mode to Draft Papers]]    :blog:

Scientific papers are mostly written in
[[http://www.latex-project.org/][LaTeX,]] a markup language for
typesetting. With LaTeX, a document is programmed rather than edited in
a WYSIWYG-way. There is a great deal of specialized editors or editor
modes (e.g. [[http://www.gnu.org/software/auctex/][AucTeX]]) simplifying
the creation of LaTeX documents. In many cases, however, you just want
to quickly write down what's in your head instead of getting stuck in
the details of LaTeX markup. I found that Emacs
[[http://orgmode.org/][org-mode]] is very well suited to fill that gap.
You can efficiently draft a scientific document that can directly be
converted into LaTeX code which you can beautify later on. I'll show you
here how.

*Installation*

First, you have to install org-mode for Emacs as described
[[http://orgmode.org/manual/Installation.html#Installation][here]].
Org-mode is included in Emacs since version 22.1 and the latest version
can be obtained from the a git repository via

#+BEGIN_QUOTE
  =git clone git://repo.or.cz/org-mode.git=
#+END_QUOTE

Be sure to use the latest version for this tutorial as there really is
some active development going on and some of the features I use were
included just recently.

*The First Document*

Begin by opening a new files with a “.org” extension. Paste the
following lines into that document

#+BEGIN_QUOTE
  =The Impact of Beer Consumption on Scientific Collaboration #+AUTHOR: Mario Fasold * Introduction ** Previous Work Some studies relating scientific output and beer have previously been done. #+BEGIN_QUOTE In Europe, most alcohol is consumed as beer and, based on well known negative effects of alcohol consumption on cognitive performance, I predicted negative correlations between beer consumption and several measures of scientific performance. #+END_QUOTE ([[www.zoologie.upol.cz/osoby/Grim/Grim_Oikos_2008_on-line.pdf]]) * Results ** What beer should you drink + Becks + Czech Budweiser + Duff=
#+END_QUOTE

The first line contains the title of your document. It will be used by
each of the exporters, e.g. LaTeX or HTML. Note that there was a bug in
the latex exporter, leading to duplicated text after the
table-of-contents if the first line of the document was a headline.
Leaving the fist line empty is the suggested
[[http://www.mail-archive.com/emacs-orgmode@gnu.org/msg08440.html][workaround]]
here.

The export can be controlled by various parameters that can be set
anywhere in the org-document. The syntax is “#+OPTIONS: toc:nil”, for
example
([[http://www.gnu.org/software/emacs/manual/html_node/org/Export-options.html][available
options]]). Some export options that might be useful to create a paper
draft include
 = =

- #+AUTHOR: the author (default taken from user-full-name)
- #+DATE: A date, fixed, of a format string for format-time-string
- #+EMAIL: his/her email address (default from user-mail-address)

Using the very simple
[[http://orgmode.org/manual/Markup-rules.html][org-mode markup]], the
document then defines some sections, subsections, textblocks and
formulas. Note that only the first three outline levels (* -- ***) are
used for headlines by default. Using the markup you can easily define
lists, include other files, enter footnotes, define literal and source
code blocks (and even use Emacs font-lock for those areas) and more. For
example, a text literal is inserted via

#+BEGIN_QUOTE
  =#+BEGIN_EXAMPLE Some example from a text file. #+END_EXAMPLE=
#+END_QUOTE

and the following passes code directly into latex

#+BEGIN_QUOTE
  =#+BEGIN_LaTeX All lines between these markers are exported literally #+END_LaTeX=
#+END_QUOTE

Another honored mention be the org-tables mode which lets you create and
edit and tables in a dead-easy manner (try to swap a table column in
AucTeX...).

*Figures*

Papers and their drafts can't live without images in most cases. The
following syntax allows
[[http://thread.gmane.org/gmane.emacs.orgmode/8588/focus=9927][since
december]] to insert one

#+BEGIN_QUOTE
  =#+CAPTION: Degradation Plot #+ATTR_LaTeX: scale=0.75 #+LABEL: fig:degradation [[./images/DegradationPlot.png]]=
#+END_QUOTE

It's a little buggy still, for example, no underscores seem to be
allowed within filenames for now. For more complex cases, you can just
write the LaTeX-code (org-mode will recognize many identifiers):

#+BEGIN_QUOTE
  =\begin{figure}[!tpb] \centerline{ \includegraphics[scale=0.3]{images/BeerPlot} }\caption{This is plot looks like a beer.}\label{fig:Beer} \end{figure}=
#+END_QUOTE

*References*

You may also want to include references while drafting the paper.
Luckily, you can use RefTex-Mode (included in Emacs) to scan your
BibTeX-file (containing the bibliographies) and easily insert a
reference to an entry of that file. First, activate RefTex in org-mode
by inserting the following lines into .emacs:

#+BEGIN_QUOTE
  =(defun org-mode-reftex-setup () (load-library "reftex") (and (buffer-file-name) (file-exists-p (buffer-file-name)) (reftex-parse-all)) (define-key org-mode-map (kbd "C-c )") 'reftex-citation) ) (add-hook 'org-mode-hook 'org-mode-reftex-setup)=
#+END_QUOTE

Second, include the BibTeX-file by inserting

#+BEGIN_QUOTE
  =\bibliographystyle{plain} \bibliography{ProbePosition}=
#+END_QUOTE

at the end of your org-document. When you want to insert the reference
just invoke “C-c )”, enter a search term (e.g. auther name) and select
the right one from the search results. Note: When first opening the org
document, RefTeX will ask you to give him the name of the “master” which
is the .tex-file corresponding to your org-file.

You can also use org-mode to collect notes about all the publications
you are reading. Stick to
[[http://article.gmane.org/gmane.emacs.orgmode/2406/match=bibliography][this
description]] to find out how you could manage bibliographies and
PDF-documents in a nice way.

*Outlook*

Org-mode is a very versatile and extensible mode for Emacs. If Emacs is
considered an Operating System, consider Org-mode as the Emacs for that
system! I find org-mode particularly handy to draft papers. Include
images, formulas, tables and references with ease, without the hassle of
dealing with LaTeX markup.

Additionaly, you might use org-mode to organize related links, documents
and data. With
[[http://orgmode.org/worg/org-tutorials/org-R/org-R.php][org-R]] you can
even do any computations (e.g.statistics) and plots in-line using R --
no need to fragment your information! Also, expect to see nice features
appearing for org-mode frequently. I would be glad to hear how you use
org-mode to collect information and do science!

Ps. Someone even wrote his complete diploma thesis with org-mode. He
describes his experience
[[http://www.mail-archive.com/emacs-orgmode@gnu.org/msg04582.html][here]]
(his org-file is a good example, too).

** [[https://wiki.freebsdchina.org/doc/r/reference][利用 Emacs 的 org-mode 管理文献]]    :blog:

*** 利用 Emacs 的 org-mode 管理文献

俗话说，“好记性不如烂笔头”。文献管理，不仅对科研工作者，对普通的用户也是必需的。看过的文献，写写心得做做笔记，以后写文章旁征博引的时候就不至于心乱如麻。

已有一些开源的文献管理的工具广受欢迎，如 JabRef、docear
等。一些常见的工具软件，读者可参阅
[[http://zh.wikipedia.org/wiki/文献管理软件比较][文献管理软件比较]]。

这里，我介绍另外一种简便的方法：利用 Emacs 的 org-mode
管理文献。原因有二：（1）Emacs
是可以使用一生的编辑器；（2）org-mode是做笔记的强大工具。

本着简单为美，高效为目的的原则，充分利用已有资源，本 wiki 的方法（源自
[[http://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/]]）能够出色地完成文献管理的任务。

*** 利用 Google Scholar 导出 bibtex 文件

写科技文章，TeX 排版工具是必须掌握的。现在的国际会议和期刊，哪个不要求
TeX 排版？我们假定读者熟悉 TeX 排版，了解最简单的 Emacs 使用方法。

在 TeX 中，文献的索引来自独立文件 *.bib，它的格式必须通过 bibtex
的编译。[[https://wiki.freebsdchina.org/software/r/refdb][文献管理软件
RefDB]]介绍了如何从 RIS 格式转化为 bib 格式。RefDB
是图书馆时代的产物，随着 Google Scholar
的普及，我们有更便捷的文献管理方法。

Google Scholar 提供了搜索文献和导出其 bibtex
描述的强大功能，它在某种程度上替代了图书馆检索和某些专业数据库检索（如
PubMed
等），让更多的人能够方便地检索到文献。在知识共享的年代，我认为，Google
Scholar 是 Google 公司最伟大的产品之一。

*** 文献管理有哪些功能？

一个文献管理软件，必须具备以下几项功能。

1. bibtex 格式
2. 文章标题、作者、期刊名等关键词搜索
3. 链接到本地保存的文章（一般为 PDF 格式）
4. 做笔记（写文章的时候，笔记很重要）
5. 在 TeX 文档中利用 \cite{} 索引

*** 准备工作

我当前使用的 Emacs 版本是 GNU Emacs
24.3.1（在更低的版本上我没有试验过），自带了 RefTeX。

需要额外安装的是 /usr/ports/deskutils/org-mode.el。

建立目录 ~/reference，里面建立目录 ~/reference/papers。另外，

#+BEGIN_EXAMPLE
    IOU@~/reference$ touch notes.org
    IOU@~/reference$ touch reference.bib
#+END_EXAMPLE

要求 notes.org 文件的开头是

#+BEGIN_EXAMPLE
    # \bibliography{~/reference/reference.bib}
#+END_EXAMPLE

为了演示方便起见，reference.bib 里只有一篇文献

#+BEGIN_EXAMPLE
    @Article{     blei2012probabilistic,
      title     = {Probabilistic topic models},
      author    = {Blei, David M},
      journal   = {Communications of the ACM},
      volume    = {55},
      number    = {4},
      pages     = {77--84},
      year      = {2012},
      publisher = {ACM}
    }
#+END_EXAMPLE

该文章取名为 blei2012probabilistic.pdf，存放于 ~/reference/papers/ 下。

*** .emacs 里的一些设置

在 $HOME/.emacs 文件里，添加以下设置。

#+BEGIN_EXAMPLE
    ;; 定义 org-mode-reftex-search
    (defun org-mode-reftex-search ()
     ;; jump to the notes for the paper pointed to at from reftex search
     (interactive)
     (org-open-link-from-string (format "[[notes:%s]]" (reftex-citation t))))

    (setq org-link-abbrev-alist
     '(("bib" . "~/reference/reference.bib::%s")
       ("notes" . "~/reference/org/notes.org::#%s")
       ("papers" . "~/reference/papers/%s.pdf")))

    ;; 当使用 org-mode 时，自动调 RefTeX
    (defun org-mode-reftex-setup ()
      (load-library "reftex")
      (and (buffer-file-name) (file-exists-p (buffer-file-name))
           (progn
        ;; enable auto-revert-mode to update reftex when bibtex file changes on disk
        (global-auto-revert-mode t)
        (reftex-parse-all)
        ;; add a custom reftex cite format to insert links
        (reftex-set-cite-format
          '((?b . "[[bib:%l][%l-bib]]")
            (?c . "\\cite{%l}")
            (?n . "[[notes:%l][%l-notes]]")
            (?p . "[[papers:%l][%l-paper]]")
            (?t . "%t")
            (?h . "** %t\n:PROPERTIES:\n:Custom_ID: %l\n:END:\n[[papers:%l][%l-paper]]")))))
      (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
      ;; binding of  ”C-c (” to org-mode-reftex-search
      (define-key org-mode-map (kbd "C-c (") 'org-mode-reftex-search))

    (add-hook 'org-mode-hook 'org-mode-reftex-setup)
#+END_EXAMPLE

*** 如何使用 notes.org 来管理文献

org-mode 是利用 Emacs 做笔记的强大工具，可以直接生成 html、TeX、PDF
等文档。

- 用 emacs 打开 notes.org 文件，将光标放置于某空行，利用命令 “C-c )”
   来建立文献索引入口，可以是 bibtex 的入口，也可以是 PDF
   文件的入口，也可以是 \cite{}。
- 命令 ”C-c (“ 可进行正则表达式搜索
- 要打开入口，只需光标停留在入口上，键入 “C-c C-o” 命令即可。
- 利用命令 “C-c \” 来搜索关键词。

*** 效果图

[[https://wiki.freebsdchina.org/_detail/doc/r/reference.png?id=doc%3Ar%3Areference][[[https://wiki.freebsdchina.org/_media/doc/r/reference.png]]]]

** [[http://xb9he.bokee.com/6688578.html][LaTeX 的对参考文献的处理]]    :blog:


LaTeX 的对参考文献的处理实在是非常的方便，我用过几次，有些体会，写出来供大家
参考。当然，自己的功力还不够深，有些地方问题一解决就罢手了，没有细究。

    LaTeX 对参考文献的处理有这么一些优点：

1. 可以维护一个 bib 文件，在你的整个研究生涯可以只维护这样一个文件，就象一个数
据库，每个参考文献是一个记录，由一个唯一的 ID （例如下面的 MartinDSP00）描述。
比如我的 myreference.bib 文件里一条典型的文献是这样的：

@article{MartinDSP00,
     author = "A. Martin and M. Przybocki",
     title = "The {NIST} 1999 speaker recognition evaluation --- an overview",

     journal = "Digital Signal Processing",
     volume = "10",
     pages = "1--18",
     year = "2000",}

    其中 {NIST} 中的大括号不会被显示，它的作用是保证将来的生成的参考文献中 NIST
 四个字保持原样，不会被小写。

2. 需要引用文献的时候，在正文里加入：

\bibliographystyle{ieeetr}
\bibliography{myreference}

    就可以用 \cite{} 来引用文献库中的论文了，如 \cite{MartinDSP00}。上面第一行是
控制文献显示格式的，这个后面再讲。此时，myreference.bib 文件在正文 tex 文件的同
一目录下，以保证 LaTeX 可以找到该 bib 文件。

3. 编译正文之后，生成 aux 文件，然后用 bibtex 在当前目录生成 bbl 文件，再编译正
文两次，完整的 dvi 就生成了。这样，LaTeX 保证了所有用 \cite 引用到的文献都已被
列出，并且自动编号。同时，如果没有用 \nocite 命令，LaTeX 还保证所有列出的参考文
献都在正文中得到了引用。

4. 关于 bib 文件
    前面提到 bib 文件的维护问题。我一般不对里面的文献排序，如果文献比较多，需要
查找的话，可以通过查询关键字来实现。bib 文件把 @ 所定义的 entry 之外的所有东西
看作是注释。比如在上面 @article 的例子里，如果我在大括号之外写些东西的话，bibt
ex 是不会关心的，就当它不存在。所以我就把文献的关键字写在这里，将来通过搜索关键
字来查找某些文献。其实也可以搞一个临时的 LaTeX 文件，使用 \nocite{*} 命令，然后
编译成 dvi，这样就得到了一个 bib 文件中所有参考文献的列表，当然是可以按照作者名
字排序的。
    另外，很多 journal（学术期刊）或者 booktitle（国际会议）都是重复的，为了规范
化，可以定义缩写，如

@string(ICASSP = "Proc. of the International Conference on Acoustics, Speech,
and Signal Processing (ICASSP)")

    然后

    @conference{QL.ICA98,
     author = "Qi Li and Biing-Hwang Juang",
     title   = "Speaker Verification Using Verbal Information Verification for A
utomatic Enrollment",
     booktitle = ICASSP,
     year = "1998",}

    这样在执行 bibtex 之后，ICASSP 会被替换成它的全称。

5. bib 中的中文文献
    中文文献和英文的格式不同，并且使用全角的标点符号，有一点难办。我的解决办法是
这样的：

    @misc{Xie.1995,
     note = "谢锦辉，《隐 {Markov} 模型及其在语音处理中的应用》，华中理工大学出
版社，1995年4月",
     key = "Xie",}

    唯一的缺陷是参考文献中最后是以英文的 "." 而不是 "。" 结束的。还好我的中文文
献不多，无伤大雅，否则就手工修改一下 bbl 文件吧。

6. 关于参考文献的显示格式、排序，及其他
    前面提到参考文献的排序问题，以及引用序号是 LaTeX 提供的 ID 还是数字的问题。
其实不止这些，参考文献的显示格式也是可以定制的。参考文献以正文中引用顺序排序，
还是以文献第一作者的 last name 排序，是通过一些 bst 文件来控制的。而使用哪种 b
st 格式，可通过 bibliographystyle 命令控制。LaTeX 默认提供了这么几种格式，如：
plain、alpha、unsrt等。具体意义见相关文档，这些 bst 在 texmf\bibtex\bst\base 可
被找到。
    bst 控制的格式非常细致，除了上面讲过的排序方式等，还有：作者名字是否用缩写，
作者名字放在文献的起始还是结束，文章 title 要不要大小写（即 "Speaker Verificat
ion Using ..." 还是 "Speaker verification using "），title 用什么区分（用不用引
号括起来，用不用斜体等），刊物名字的格式（要不要全部大写，要不要粗体，要不要斜
体，要不要括起来），等等等等。打开 bst 文件看一下就知道，绝对是想要什么形式，就
可以得到什么形式。最关键的是，在文章定稿之后，完全可以用几个命令重新定义参考文
献的格式！

    给个例子：采用 IEEE 给出的 bst 格式（即 ieeetr.bst），声明：

\bibliographystyle{ieeetr}

    就可以使用了。最终格式是这样的（按正文引用顺序排序）：
    [4] D. A. Reynolds, "Comparison of background normalization
        methods for text-independent speaker verication," in
        EUROSPEECH, 1997.

7. 如何定制参考文献的显示格式
    其实 bst 文件有很多，总能找到自己需要的。如果这些还不能满足，可以通过生成自
己的 bst 文件来定制。这有两个方法，第一是手写（反正我是写不出来），第二是通过工
具。custom-bib 是一个定制 bst 文件的包，解压缩后用 LaTeX 编译其中的主 tex 文件
，便会进行交互式的 bst 定制过程，具体过程我就不讲了。把生成的自定义的 bst 放到
 LaTeX 相应目录下，刷新文件名数据库就可以使用了。

** [[http://www.latexstudio.net/archives/3516][org-mode的中文beamer幻灯片模板]]    :blog:

2015-04-09
分类：[[http://www.latexstudio.net/archives/category/tex-slides/beamer-theme-template][beamer]]
阅读(447) 评论(1)

org-mode 是 Emacs
的杀手级应用，使用它可以用来做很多事情，如GTD、做笔记等。它可以导出多种格式的文件，包括HTML、LaTeX、Freemind、DocBook等，因此，通过定制之后，编写一份org文件就等于同时编写（或者排版）了多种格式文件，而且每种格式的文件又可以各自拥有不同的排版效果。这正是
org-mode 精妙之处。

比如，我最喜欢的做法是先在 Emacs 里打开 evernote-mode 写一份 org-mode
的笔记，然后 =C-c C-e H= 导出成 HTML
代码，并发布到我的博客中或者加入到我的 wiki
里。如果有需要，我还可以 =C-c C-e l= 生成 LaTeX 代码并编译成 PDF 文件。

用 org-mode 制作 Beamer
幻灯片也很简单，官方已经给出了 [[http://orgmode.org/worg/org-tutorials/org-beamer/tutorial.html][详细的教程]] ，照着一步步做即可。官方的教程并没有针对中文进行定制，因此笔者写了一个org-mode的Beamer中文模板，这是在 [[http://orgmode.org/manual/Beamer-class-export.html#Beamer-class-export][Carsten
Dominik的例子]] 的基础上修改得到的。

*** 1 截图预览

[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2015/04/org-beamer-cn.png]]

*** 2 环境要求

1. Emacs
2. org-mode
3. TeXLive 或其他带有 Beamer 宏包的 LaTeX 系统
4. Adobe 字体

   -  Adobe Heiti Std
   -  Adobe Kaiti Std

*** 3 特点

1. 使用 “Darmstadt” 主题及 “Firebrick”配色方案；
2. 使用 listings
   宏包实现代码框。如果有中文内容，你可能需要使用逃逸字串(`')括住两边，否则会出现错位；
3. 使用xeCJK来处理中文，并使用 Adobe
   字体（[[http://ishare.iask.sina.com.cn/f/23186570.html][字体下载]]）。

*** 4 下载

- Github主页：[[http://wzpan.github.com/org-beamer-cn/][http://wzpan.github.io/org-beamer-cn/]]
- 克隆git仓库：git clone https://github.com/wzpan/org-beamer-cn.git
- zip压缩包：[[https://github.com/wzpan/org-beamer-cn/zipball/master]]
- tar.gz压缩包：[[https://github.com/wzpan/org-beamer-cn/tarball/master]]
- 本站下载：[[http://www.latexstudio.net/wp-content/uploads/2015/04/wzpan-org-beamer-cn-e5b5173.zip][wzpan-org-beamer-cn-e5b5173]]

*** 5 使用方法

- 用 Emacs 打开 *beamer.org* 文件， =M-x org-mode= 打开 org-mode；
- =C-c C-e l= 生成 beamer.tex 文件；
- 打开 *beamer.tex* 文件， =C-c C-c (M-x TeX-command-master)= 并选择使用 *XeLaTeX* 编译。完成后就可以得到幻灯片了。

*** 6 F&Q

- 两个“@”不能生成alert效果？

这个可能是 org-mode 本身的 bug，但可以通过修改
Emacs里的设置来解决。在 =(require 'org-latex)= 前加入这一段设置：

Lisp

(setq org-emphasis-alist (quote (("*" bold "<b>" "</b>") ("/" italic
"<i>" "</i>") ("_" underline "<span
style=\"text-decoration:underline;\">" "</span>") ("=" org-code "<code>"
"</code>" verbatim) ("~" org-verbatim "<code>" "</code>" verbatim) ("+"
(:strike-through t) "<del>" "</del>") ("@" org-warning "<b>" "</b>")))
org-export-latex-emphasis-alist (quote (("*" "\\textbf{%s}" nil) ("/"
"\\emph{%s}" nil) ("_" "\\underline{%s}" nil) ("+" "\\texttt{%s}" nil)
("=" "\\verb=%s=" nil) ("~" "\\verb~%s~" t) ("@" "\\alert{%s}" nil))))

| 1                                                                             |
| 2                                                                             |
| 3                                                                             |
| 4                                                                             |
| 5                                                                             |
| 6                                                                             |
| 7                                                                             |
| 8                                                                             |
| 9                                                                             |
| 10                                                                            |
| 11                                                                            |
| 12                                                                            |
| 13                                                                            |
| 14                                                                            |
| 15                                                                            |
| 16                                                                            |
| 17                                                                            |
| 18                                                                            |
| (setq org-emphasis-alist (quote (("*" bold "<b>" "</b>")                      |
|   ("/" italic "<i>" "</i>")                    |
|   ("_" underline "<span                       |
| style=\"text-decoration:underline;\">" "</span>")                             |
|   ("=" org-code "<code>" "</code>"             |
|   verbatim)                                                    |
|   ("~" org-verbatim "<code>" "</code>"         |
|   verbatim)                                                    |
|   ("+" (:strike-through t) "<del>" "</del>")   |
|   ("@" org-warning "<b>" "</b>")))             |
|  org-export-latex-emphasis-alist (quote                                  |
|   (("*" "\\textbf{%s}" nil)              |
|  ("/" "\\emph{%s}" nil)                |
|  ("_" "\\underline{%s}" nil)          |
|  ("+" "\\texttt{%s}" nil)              |
|  ("=" "\\verb=%s=" nil)                |
|  ("~" "\\verb~%s~" t)                  |
|  ("@" "\\alert{%s}" nil))))            |

选自：[[http://hahack.com/tools/org-beamer-cn/]]

** [[http://segmentfault.com/a/1190000002438813][Edit with Emacs]]    :blog:


[[/u/venmos][[[http://sfault-avatar.b0.upaiyun.com/243/840/2438401179-1030000000093355_big64]]
*venmos*]] ** 2014年12月22日 发布

- 推荐
   *0* 推荐
- 收藏
   *1* 收藏，*687* 浏览

如果你用习惯了Emacs编辑器并经常使用它纂写各种文字和代码的话,
再使用网站内置的文字编辑器是不是会让你发狂呢? 不过还好, 有一款叫做Edit
with Emacs的Chrome插件可以解决,
它可以让Chrome在外部调用Emacs进行文字编辑.

Edit with Emacs for Chrome
[[https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonikaiipfkggjbhkghgicgoh][]][[https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonikaiipfkggjbhkghgicgoh][https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonik...]]
 Edit-Server for Emacs
[[http://github.com/stsquad/emacs_chrome][]][[http://github.com/stsquad/emacs_chrome]]

使用Chrome安装for Chrome的插件,
之后从Github下载Edit-Server到Emacs的插件目录,
然后在Emacs的配置文件中写入:

#+BEGIN_EXAMPLE
    (add-to-list 'load-path "~/.emacs.d/edit-servers")
    (require 'edit-server)
    (when (require 'edit-server nil t)
      (setq edit-server-new-frame nil)
      (edit-server-start))
#+END_EXAMPLE

之后在网站的编辑框下方就会有一个紫色的=edit=小图标,
点击它Chrome就会在外部调用Emacs进行编辑了, 非常方便.

另外Edit with Emacs还有根据网站网址自动转换编辑模式的功能, 比如:

#+BEGIN_EXAMPLE
    lisp(setq edit-server-url-major-mode-alist
          '(("github\\.com" . markdown-mode)
                    ("segmentfault\\.com" . markdown-mode)
                    ))
#+END_EXAMPLE

如此添加之后,
当我们在Github或者Segmentfault网站调用Emacs进行编辑的时候Emacs会自动切换为Markdown-mode.

PS: Edit with Emacs的原理是在Emacs里开启一个服务, 默认监听=9292端口=.
然后Chrome将文字发送给Emacs进行处理,
Emacs保存时在将编辑结果返回给Chrome. 如果Edit with
Emacs在你的电脑上不能正常工作, 那么可以检查下=9292端口=是否被占用.
你可以修改Edit-Server的默认端口, 然后从Chrome插件的选项里做相应修改即可.

** [[http://www.zzbaike.com/wiki/Emacs/EDIFF#jump-to-nav][Emacs/EDIFF]]    :blog:


*** 软件概况

授权协议：免费软件

运行环境：Emacs

官方网站：[[http://www.dirfile.com/freeware/ediff.htm]]

软件下载：[[http://www.dirfile.com/freeware/ediff.htm][官方下载]]

*** 简介

Ediff是Emacs提供的一种实时浏览文件间不同(diff)的工具，它可以比较两个或
三个文件间的不同，分别表示为file-A, file-B 或 file-C，也可以比较两个或
三个emacs-buffer间的不同。Ediff的另一个强有力特性则是可以把正的比较的
文件合并成第三个文件。另外， Ediff还可以对目录进行操作。

Ediff浏览文件的差异是在Emacs的两个Buffer上进行，分别使用不同的颜色表示
所存在的差异，而且Ediff对差异区域的差异进行了“细化”，diff程序只进行
到“行”级别比较，而Ediff则是基于diff程序的输出上，对差异区域进行更细
致的比较，从而得到区域内“单词”级别上的差异比较。从而使比较文件间的细
致不同更加容易。

Ediff的更强功能：Ediff可以“忽略”某些细微的差别，例如有两个程序几乎相
同，但是其中都些变量的命名却不一样，如bar变量在另一个程序中却都foo，这
对程序而言是“相同”，如果用一般的diff程序来查看该两程序的差别，则这种
没有意义的变量名不同将充满了整个差异输出，从而不易找到真正的“程序不
同”，而使用Ediff则可以忽略这类不同，很容易就定位我们真正想要的差异。

Ediff的特点是它与[[/wiki/%E7%BC%96%E8%BE%91%E5%99%A8][编辑器]]（即
Emacs本身）集成在一起，所以在比较的过程可以方便的编辑被比较的文件。例
如语法高亮仍然有效。它还提供了对版本控制工具的支持，例如用
ediff-revision命令可以方便的比较不同版本之间的区别。

*** Ediff命令

- 比较两文件： ‘M-x ediff-files'‘M-x ediff'(以后略去M-x)比较两个
- Buffer： ‘ediff-buffers'比较三个文件： ediff-file3 ediff3比较三个
- Buffer： ediff-buffer3交互式使用一个patch： ediff-patch-file epatch

以上是一些主要的命令，这些命令在运行时可能会提示输入一些参数，如文件名
等，同时都能很智能地提供一些合适的默认值。

Ediff命令被执行后，进行所谓的‘Ediff Session'它接受一些Ediff命令以决定
Ediff的行为。具体的表现是Ediff另外建立一个窗口(称为“Quick Help
window”)，当聚焦在该窗口输入则被认为是Ediff命令，否则仍是一般的Emacs
编辑行为，即还可以实时的编辑你正在比较的文件或Buffer。

在“Quick Help window”上输入“？”使该窗口变大或是缩小，输入q并确认则
完成比较退出Ediff Session。

常用的Session Command：

**** 移动命令

- v ( V )

把文件-A，文件-B，文件-C(如果有)，同步向下(向上)滚动，

- < ( > )

把文件-A，文件-B，文件-C(如果有)，同步向左(向右)滚动，

- j

跳到差异区域，可以先加数值参数，如 ‘3j'则跳到第三个差异区域，‘j'则跳
到第一个差异区域，则‘-2j'跳到倒数第二个差异区域。跳到某区域后，再输入
的编辑命令就是针对该区域执行，即有一个“当前区域”的概念，而‘j'命令则
就是用于使用绝对参数设置当前活动区域。

- n (或 SPC 空格)

跳到下一个差异区域，并设其为当前区域，

- p (或 DEL)

跳到前一个差异区域，并设其为当前区域，

- ga ( gb gc )

根据光标在Buffer-A(或Buffer-B, Buffer-C)中的位置，设置一个离它们最近的
差异区域为当前活动区域

**** 编辑命令

- a

比较模式：把Buffer-A的内容复制到Buffer-B，可以使用‘rb'恢复Buffer-B的
内容，

合并模式： 把Buffer-A的内容复制到合并Buffer. 可以使用‘r'恢复旧内容，

- b

比较模式：把Buffer-B的内容复制到Buffer-A，可以使用‘ra'恢复Buffer-A的
内容，

合并模式： 把Buffer-B的内容复制到合并Buffer. 可以使用‘r'恢复旧内容，

- ra ( rb rc )

分别用于恢复 Buffer-A Buffer-B Buffer-C 差异区域中的被修改的内容。

**** 三方比较的编辑命令

- ab

把Buffer-A的内容复制到Buffer-B，可以使用‘rb'恢复Buffer-B的内容，

- ac

把Buffer-A的内容复制到Buffer-C，可以使用‘rc'恢复Buffer-C的内容，

- ba bc ca cb

分别把Buffer-B(C)的内容复制到相应的Buffer-ABC，同时仍可以使用‘ra(bc)'
恢复相应的被修改的内容。

**** Buffer属性设置命令

- A ( B C )

改变Buffer-A, buffer-B, buffer-C的只读属性，是Toggle命令。

** [[http://emacsblog.org/2007/02/18/emacs-key-bindings-in-ms-word/][Emacs Key Bindings in MS Word]]    :blog:

**** February 18th, 2007 by Ryan McGeary ·
[[http://emacsblog.org/2007/02/18/emacs-key-bindings-in-ms-word/#comments][189
Comments]]

Macosxhints.com points us to a way to
[[http://www.macosxhints.com/article.php?story=20070215034801484][enable
emacs key bindings in Microsoft Word]]. Just assign new shortcut keys to
each of these Word commands (instructions below):

| #+BEGIN_EXAMPLE         |
|     StartOfLine : C-a   |
|     EndOfLine   : C-e   |
|     LineUp      : C-p   |
|     LineDown    : C-n   |
|     CharLeft    : C-b   |
|     CharRight   : C-f   |
| #+END_EXAMPLE           |


Please feel free to suggest other emacs equivalent Word commands and
shortcuts in the comments.

*** Word 2004 for Mac

1. Tools > Customize > Customize Keyboard ...
2. Select “All Commands” in the Categories box.

1. Add new shortcut keys for each of the commands above.

*** Word 2002 (XP) for Windows

1. Tools > Customize ...
2. Click the “Keyboard ...” button.
3. Select “All Commands” in the Categories box.

1. Add new shortcut keys for each of the commands above.

/Note: On Windows, =C-p=, =C-n=, and =C-f= will probably conflict with
FilePrint, FileNew, and EditFind, so you may want to remove those
existing shortcut keys first./

** [[http://hints.macworld.com/article.php?story=20070215034801484][]]    :blog:

Emacs users get addicted to the standard key bindings (which are also
available in Cocoa apps). Microsoft Word doesn't support these by
default, but you can add them through customization. Here are the ones I
find most useful:

- StartOfLine: Control-A
- EndOfLine: Control-E
- LineUp: Control-P
- LineDown: Control-N
- CharLeft: Control-B
- CharRight: Control-F

To set these up in Word, go to Tools » Customize » Customize Keyboard.
From the Categories panel, choose All commands. Find each of the entries
in the above list, select the /Press new shortcut key/ box for each,
then type the shortcut as shown above and click Assign. (Word will tell
you if any of the shortcuts are currently assigned to other commands.)

The icing on the cake is to get Control-K working. You can do this with
a macro. Go to Tools » Macro » Macros. Set the macro name to /CtrlK/,
then click Create. When the macro window appears, add the following
lines just before the =End Sub= line:

#+BEGIN_EXAMPLE
        Selection.EndKey Unit:=wdLine, Extend:=wdExtend    Selection.Cut
#+END_EXAMPLE

Hit the W icon on the toolbar to save the macro and go back to Word. Now
go back to the Tools » Customize » Customize Keyboard window, choose
Macros from the Categories pane, and assign your new macro to Control-K.

** [[http://blog.useasp.net/archive/2014/07/18/emacs-temporary-files-and-backup-files-for-edited-file.aspx][Emacs的临时文件和备份文件]]    :blog:

Emacs在编辑文件的时候实际上并非对文件本身进行编辑，而是会将要编辑的文件内容拷贝到[[http://blog.useasp.net/tags/Emacs][Emacs]]的一个临时缓冲区（buffer）内，而我们编辑的时候，也只是对这个缓冲区的内容进行更改。为了便于在需要的时候能够方便的应对，Emacs会自动产生一些其他的辅助文件，其中最常见的有临时文件和备份文件。

[[http://blog.useasp.net/tags/临时文件][临时文件]](Auto-Save file)

Emacs的临时文件的文件名是使用“#”包围，这种文件一般是在Emacs中编辑时，emacs自动保存的文件，他在编辑文件的同一个目录内生成一个以=#file-name#=这样的文件，这个文件会在我们保存文件之后被emacs删除。这个文件的作用是为了防止在进行编辑的时候异常退出造成的损失。

#+BEGIN_EXAMPLE
    1. 在Emacs内使用[C-x,C-f]打开要编辑的文件(test-file.txt)
    2. 在打开的buffer中编辑内容
    3. Emacs自动侦测buffer是否更改，如果更改会自动Auto-Save
    4. 此时我们能够在编辑的文件同一目录下看到临时文件为:
        #test-file.txt#
    5. 使用[C-x,C-s]保存当前buffer
    6. 当前buffer中的内容被写入文件,#test-file.txt#消失——被Emacs自动删除
#+END_EXAMPLE

 如果你不想产生这个临时文件也是有办法的，就是关闭自动保存功能，在你启动的=.emacs=文件内添加下面这行

#+BEGIN_EXAMPLE
    (setq auto-save-default nil) ;; 默认值是t， 要关闭直接用nil更改默认值
#+END_EXAMPLE

 当然，一般是不建议关闭的，因为在异常退出之后，如果你想要恢复自己辛苦编辑的内容，它能帮上大忙，你只要在emacs内打开你要恢复的文件，然后在恢复即可。

#+BEGIN_EXAMPLE
    1. 打开要恢复的文件，如：test.txt
    2. [M-x]
    3. 输入:recover-file 回车
    4. 确认恢复
#+END_EXAMPLE

用起来还是不错的。



[[http://blog.useasp.net/tags/备份文件][备份文件]]（Backup files）

备份文件是在第一次保存的时候，如果保存的文件已经存在，Emacs会自动将当前已经存在的文件重命名作为备份文件，并将当前buffer的内容写入同名的文件中来替代原来的文件。而备份文件使用的是一个“～”作为后缀(如：=file-name~=)。大概的流程如下：

#+BEGIN_EXAMPLE
    1. 打开文件,如:MitchellChu.txt
    2. 编辑...（这涉及到临时文件的问题，忽略）
    3. 在emacs内发出保存指令
    4. emacs先将MitchellChu.txt保存为：MitchellChu.txt~
    5. 保存完成后，Emacs将当前buffer的内容写入MitchellChu.txt
    注意：此时的MitchellChu.txt已经不再是原来的那个文件，但所有连接到原来那个文件的，现在被这个新文件接管。
#+END_EXAMPLE

 当然，上面的这个流程是可以定制的，比如，我们可以要求emacs通过拷贝，而非重命名的方式来备份文件，在=.emacs=或者Emacs内设置个变量就成：

#+BEGIN_EXAMPLE
    ;; 在.emacs文件中添加下面这行表示使用拷贝模式
    (setq backup-by-copying t) ;; 默认是nil，开启之后使用拷贝模式

    ;;;;;;;;;;;;;;;
    ;; 如果是在Emacs中
    ;; 你可以通过直接设置这个变量的值来改变模式
    ;;;;;;;;;;;;;;;

    ;; [M-x]
    ;; set-variable
    ;; backup-by-copying
    ;; t
    ;; 回车，即可修改模式
#+END_EXAMPLE

 这里同上，还是建议不要修改这个值，因为重命名的方式Mitchell个人感觉要优于拷贝模式。

备份文件默认仅会发生在Emacs第一次写入的时候，即，开启Emacs之后，第一次打开文件并保存的时候，编辑期间多次保存并不能产生多次备份动作。然而，下次重新打开Emacs，再次执行同样的动作的时候，同样在第一次保存时，Emacs是会将上次的备份文件覆盖的（如果有）。这也许是你不想要的，这时候你可以通过设置，让每次的备份文件都不同。具体的操作涉及到比较多的参数，这个功能觉得没有太大用处的，这里就不赘述，如果感兴趣，可以参看：=version-control=。

** [[http://blog.sina.com.cn/s/blog_88b165d301017dc2.html][emacs 大小写转换]]    :blog:

- *从光标位置开始，处理单词后半部分*

1. capitalize-word (M-c) ;; 单词首字母转为大写
2. upcase-word (M-u)  ;; 整个单词转为大写
3. downcase-word (M-l)  ;; 整个单词转为小写（注意，这里是 META － l(*
   小写字母 L)）

- *从光标位置开始，处理单词前半部分*

1. negtive-argument; capitalize-word (M-- M-c) ;; 单词首字母转为大写
2. negtive-argument; upcase-word (M-- M-u)  ;; 整个单词转为大写
3. negtive-argument; downcase-word (M-- M-l)  ;; 整个单词转为小写

- *改变选定区域的大小写*



1. downcase-region (C-x C-l) ;; 选定区域全部改为小写
2. upcase-region (C-x C-u)  ;; 选定区域全部改为大写

** [[http://blog.sina.com.cn/s/blog_88b165d301017djg.html][emacs 矩形操作]]    :blog:

*** 原始矩形块模式

emacs以C-x
r开头的命令来进行矩形操作。先用C-space或者C-@设一个mark，移动光标到另一点，用以下命令进行列操作：

1. C-x r k 剪切一个矩形块
2. C-x r y 粘贴一个矩形块
3. C-x r o 插入一个矩形块
4. C-x r c 清除一个矩形块(使其变成空白)
5. C-x r t 在选定区域的所有列前插入样的字符



*** cua-mode支持的可视化块模式

除了emacs本身支持的列模式外，emacs还可以通过cua-mode支持一种可视化的列模式。在cua-mode下，按[C-return]会进入
cua
rectangle模式。在这个模式下可以通过鼠标点击确认起点，然后通过光标键来选中一个rect范围，这个rect会用另外的颜色显示出来。

直接输入字符: 在每行前(或后)都插入这个字符



1.  [M-a]: 将rect中的文字左对齐
2.  [M-b]: 用空格(tabs或者spaces)替换所有rect中的字符
3.  [M-c]: 去掉所有行左侧的空格
4.  [M-f]: 用单个字符替换所有rect中的字符(提示输入一个字符)
5.  [M-i]: 对每行中第一个找到的数字进行加1操作(自动把0x开头的当作十六进制数字)
6.  [M-k]: 剪切rect
7.  [M-l]: 把rect中的内容全部转换为小写
8.  [M-m]: 拷贝rect
9.  [M-n]: 用一串自增的数字替换rect中的每一行(这个功能可以用来给每行编号) ### 非常好用的功能
10. [M-o]: rect的内容右移，选中的rect用空格填充
11. [M-r]: 用字符串替换符满足正则表达式的字符串
12. [M-R]: 上下反转
13. [M-s]: 把rect中的每一行替换为一个字符串(提示输入)
14. [M-t]: 把rect整个替换为一个字符串(提示输入)
15. [M-u]: 把rect中的内容全部转换为大写
16. [M-|]: 对rect执行一个shell命令

** [[http://blog.csdn.net/pfanaya/article/details/7068710][Emacs Bookmark 书签]]    :blog:

*书到用时方恨少......掌握Emacs的最好办法就是使用，使用，再使用......哈哈......*

*转自：*[[http://www.ibm.com/developerworks/cn/education/aix/au-emacs4/section4.html]]



使用 Emacs 书签

Emacs 提供了保存缓冲区中位置的另一种工具。这些
Emacs /书签/ 的工作方式与寄存器相同，但是它们的标签可以超过一个字符长，而且它们比寄存器更为持久：如果保存了书签，那么您可以在两个不同的会话之间使用它们。它们将一直保留下来，直到您删除它们。正如它们的名称所表示的，对于保存您在缓冲区中的位置，以便您稍后可以返回到该位置（通常是在以后的
Emacs 会话期间），使用书签是非常方便的。

这个部分将向您介绍使用、设置、列出、保存和删除 Emacs 书签。

设置一个书签

对于保存光标位置，书签与寄存器是很相似的，不同之处在于书签能够保持到当前会话之外。对于标记您在文件中的位置，并在稍后返回到该位置，书签是非常方便的，您可以为很多文件设置书签，并且您可以在单个文件中设置很多书签。

要在当前缓冲区中，为您正在访问的文件的当前光标设置一个书签，可以运行 =bookmark-set= 功能，它与 =C-x r m= 进行了绑定。

这一命令后面紧跟您的书签的名称；在缺省情况下，它就是当前缓冲区的名称。

现在，尝试保存一些书签：

1. 启动 Emacs，并使光标定位于您的练习文件中的第 20 行：

   | #+BEGIN_EXAMPLE                    |
   |     $ emacs +20 practice.b         |
   |                                    |
   | #+END_EXAMPLE                      |




2. 键入 =C-x r m= 以便将这个光标作为书签保存。

3. 当 Emacs
   请求为这一书签提供相应的名称时，可以按 *Enter* 以使用该缓冲区的名称
   (practice.b)。

4. 键入 =M-<= 以移动到缓冲区的顶部。

5. 保存一个名为 top 的新书签：键入 =C-x r m top=。

列出您的书签

=bookmarks-bmenu-list= 功能可以列出一个由已设置的所有书签组成的菜单。通过键入 =C-x r l= 运行该功能，而您的会话应该与[[http://www.ibm.com/developerworks/cn/education/aix/au-emacs4/section4.html#fig5][图
5]] 中所示类似。


 *图 5. Emacs 的书签菜单*

[[http://www.ibm.com/developerworks/cn/education/aix/au-emacs4/image05.jpg]]

您可以通过按 *Enter* 从该列表中选择一个书签。Emacs
将在一个新的缓冲区（如果尚未在一个缓冲区中打开它）中访问该文件，并将其作为当前缓冲区，同时将光标移动到该书签的位置。

现在，尝试运行这一功能，并使用箭头键选择您的“top”书签。

跳转至一个书签

您可以通过直接/跳转/ 至某个书签来访问它，而无需从您的书签主列表中选择它。要跳转至某个特定的书签，可以使用 =bookmark-jump=功能，=C-x r b=。这一命令将移动到特定文件中的给定位置；如果尚未在缓冲区中打开这个带书签的文件，那么这一命令将打开它。

在迷你缓冲区中会提示您输入要跳转到的书签。这个提示使用了自动完成功能，所以您只需键入该书签名前面足够的字母，以使其能够区别于其他的书签即可，然后按 *Tab* 以选择该书签。

尝试跳转到您的 practice.b
书签：键入 =C-x r b prac=，按 *Tab* 键，然后按 *Enter*。

删除一个书签

当您使用一个现有书签的标签来设置新书签（请参见[[http://www.ibm.com/developerworks/cn/education/aix/au-emacs4/section4.html#seta][设置一个书签]]部分）时，您将使用新的书签取代原来的书签。这是一种“删除”书签的方式，即使用新的值来取代其原来的值。当您在阅读一个大文件时，如果您仅仅保留一个书签以标记您的位置，上述方法是很常见的，因为您每次设置该书签时都替换了它先前的值。

但是您可以同时删除一个书签，那么该标签不再指向任何文件中的任何位置。要实现这一点，可以运行 =bookmark-delete= 功能，并在被询问时，给出要进行删除的书签的名称。

尝试删除您的“top”书签：

1. 键入 =C-x bookmark-delete= 并按 *Enter*。

2. 当被询问时，给出要删除的书签的名称：键入 =top= 并按 *Enter*。

通过使用 =C-x r l= 调出书签列表，您可以验证已经删除了该书签。

保存您的书签

在 Emacs 的新版本中，一旦您生成了任何书签，那么您为当前 Emacs
会话所设置的书签将自动地保存到您的永久书签文件中。您的书签文件是您的
home 目录中的一个名为 .emac.bmk 的隐藏文件。

如果没有配置 Emacs
以使其自动保存您的书签，那么通过运行 =bookmark-save= 功能，可以将它们保存到您的
.emac.bmk 文件中。如果当您退出时没有保存任何新的书签，那么 Emacs
将询问您是否想要保存它们。

Emacs 书签命令表

[[http://www.ibm.com/developerworks/cn/education/aix/au-emacs4/section4.html#table4][表
4]] 列出了使用 Emacs
书签的各种命令和键，给出了它们的功能名，并描述了它们的含义。


 *表 4. 使用书签的 Emacs 命令*

键盘输入

功能

描述

=C-x r m Bookmark=

=bookmark-set=

设置一个名为 /Bookmark/ 的书签。

=C-x r l=

=bookmarks-bmenu-list=

列出所有已保存的书签。



=bookmark-delete=

删除一个书签。

=C-x r b Bookmark=

=bookmark-jump=

跳转至名为 /Bookmark/ 的书签中所设置的位置。

/未定义/

=bookmark-save=

将所有的书签保存到书签文件 ~/.emac.bmk 中。

** [[http://blog.chinaunix.net/uid-27091459-id-3359118.html][emacs-24.2 install]]    :blog:

when configure the emacs:  error like this!
You seem to be running X, but no X development libraries
were found. You should install the relevant development files for X
and for the toolkit you want, such as Gtk+, Lesstif or Motif. Also
make
sure you have development files for image handling, i.e.
tiff, gif, jpeg, png and xpm.
If you are sure you want Emacs compiled without X window support, pass
--without-x
to configure.

装GTK+等图形开发库
*sudo apt-get install libgtk2.0-dev
*
几个图像开发库
*sudo apt-get install libxpm-dev
sudo apt-get install libjpeg62-dev
sudo apt-get install libgif-dev
sudo apt-get install libtiff4-dev

*last one:
**sudo apt-get install libncurses5-dev

./configure
make
make install

run it in window
**emacs

run it without any window
emacs -nw

** [[http://c.biancheng.net/cpp/biancheng/view/2227.html][C++格式化输出，C++输出格式控制]]    :blog:

在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采取默认的格式，但有时希望数据按指定的格式输出，如要求以十六进制或八进制形式输出一个 整数，对输出的小数只保留两位小数等。有两种方法可以达到此目的。一种是我们已经介绍过的使用控制符的方法（详情请查看：C++输入cout与输出cin）；第2种是使用流对象的有关成员函数。分别叙述如下。
使用控制符控制输出格式

控制格式的使用方法这里不再赘述，仅举例说明，详情请查看：C++输入cout与输出cin。

[例13.2] 用控制符控制输出格式。
#include <iostream>
#include <iomanip>//不要忘记包含此头文件
using namespace std;
int main()
{
   int a;
   cout<<"input a:";
   cin>>a;
   cout<<"dec:"<<dec<<a<<endl;  //以十进制形式输出整数
   cout<<"hex:"<<hex<<a<<endl;  //以十六进制形式输出整数a
   cout<<"oct:"<<setbase(8)<<a<<endl;  //以八进制形式输出整数a
   char *pt="China";  //pt指向字符串"China"
   cout<<setw(10)<<pt<<endl;  //指定域宽为,输出字符串
   cout<<setfill('*')<<setw(10)<<pt<<endl;  //指定域宽,输出字符串,空白处以'*'填充
   double pi=22.0/7.0;  //计算pi值
   //按指数形式输出,8位小数
   cout<<setiosflags(ios::scientific)<<setprecision(8);
   cout<<"pi="<<pi<<endl;  //输出pi值
   cout<<"pi="<<setprecision(4)<<pi<<endl;  //改为位小数
   cout<<"pi="<<setiosflags(ios::fixed)<<pi<<endl;  //改为小数形式输出
   return 0;
}
运行结果如下：
input a:34↙(输入a的值)
dec:34                   (十进制形式)
hex:22                   (十六进制形式)
oct:42                   (八进制形式)
         China               (域宽为)
*****China               (域宽为,空白处以'*'填充)
pi=3.14285714e+00        (指数形式输出,8位小数)
pi=3.1429e+00            (指数形式输出,4位小数)
pi=3.143                 (小数形式输出,精度仍为)
用流对象的成员函数控制输出格式

除了可以用控制符来控制输出格式外，还可以通过调用流对象cout中用于控制输出格式的成员函数来控制输出格式。用于控制输出格式的常用的成员函数见表13.4。

表13.4 用于控输出格式的流成员函数
流成员函数	与之作用相同的控制符	作用
precision(n)	setprecision(n)	设置实数的精度为n位
width(n)	setw(n)	设置字段宽度为n位
fill(c)	setfill(c)	设置填充宇符c
setf()	setiosflags()	设置输出格式状态，括号中应给出格式状态，内容与控制符setiosflags括号中的内容相同，如表13.5所示
unsetf()	resetioflags()	终止已设置的输出格式状态，在括号中应指定内容
流成员函数setf和控制符setiosflags括号中的参数表示格式状态，它是通过格式标志来指定的。格式标志在类ios中被定义为枚举值。因此在引用这些格式标志时要在前面加上类名ios和域运算符“::”。格式标志见表13.5。

表13.5 设置格式状态的格式标志
格式标志	作用
ios::left	输出数据在本域宽范围内向左对齐
ios::right	输出数据在本域宽范围内向右对齐
ios::internal	数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充
ios::dec	设置整数的基数为10
ios::oct	设置整数的基数为8
ios::hex	设置整数的基数为16
ios::showbase	强制输出整数的基数(八进制数以0打头，十六进制数以0x打头)
ios::showpoint	强制输出浮点数的小点和尾数0
ios::uppercase	在以科学记数法格式E和以十六进制输出字母时以大写表示
ios::showpos	对正数显示“+”号
ios::scientific	浮点数以科学记数法格式输出
ios::fixed	浮点数以定点格式(小数形式)输出
ios::unitbuf	每次输出之后刷新所有的流
ios::stdio	每次输出之后清除stdout, stderr
[例13.3] 用流控制成员函数输出数据。
#include <iostream>
using namespace std;
int main( )
{
   int a=21
   cout.setf(ios::showbase);//显示基数符号(0x或)
   cout<<"dec:"<<a<<endl;         //默认以十进制形式输出a
   cout.unsetf(ios::dec);         //终止十进制的格式设置
   cout.setf(ios::hex);           //设置以十六进制输出的状态
   cout<<"hex:"<<a<<endl;         //以十六进制形式输出a
   cout.unsetf(ios::hex);         //终止十六进制的格式设置
   cout.setf(ios::oct);           //设置以八进制输出的状态
   cout<<"oct:"<<a<<endl;         //以八进制形式输出a
   cout.unseft(ios::oct);
   char *pt="China";              //pt指向字符串"China"
   cout.width(10);                //指定域宽为
   cout<<pt<<endl;                //输出字符串
   cout.width(10);                //指定域宽为
   cout.fill('*');                //指定空白处以'*'填充
   cout<<pt<<endl;                //输出字符串
   double pi=22.0/7.0;            //输出pi值
   cout.setf(ios::scientific);    //指定用科学记数法输出
   cout<<"pi=";                   //输出"pi="
   cout.width(14);                //指定域宽为
   cout<<pi<<endl;                //输出pi值
   cout.unsetf(ios::scientific); //终止科学记数法状态
   cout.setf(ios::fixed);        //指定用定点形式输出
   cout.width(12);               //指定域宽为
   cout.setf(ios::showpos);      //正数输出“+”号
   cout.setf(ios::internal);     //数符出现在左侧
   cout.precision(6);            //保留位小数
   cout<<pi<<endl;               //输出pi,注意数符“+”的位置
   return 0;
}
运行情况如下：
dec:21(十进制形式)
hex:0x15                 (十六进制形式,以x开头)
oct:025                  (八进制形式,以开头)
         China               (域宽为)
*****China               (域宽为,空白处以'*'填充)
pi=**3.142857e+00        (指数形式输出,域宽,默认位小数)
+***3.142857             (小数形式输出,精度为,最左侧输出数符“+”)

对程序的几点说明：
1) 成员函数width(n)和控制符setw(n)只对其后的第一个输出项有效。如：
    cout. width(6);
    cout <<20 <<3.14<<endl;
输出结果为 203.14

在输出第一个输出项20时，域宽为6，因此在20前面有4个空格，在输出3.14时，width (6)已不起作用，此时按系统默认的域宽输出（按数据实际长度输出）。如果要求在输出数据时都按指定的同一域宽n输出，不能只调用一次width(n)，而必须在输出每一项前都调用一次width(n>，上面的程序中就是这样做的。

2) 在表13.5中的输出格式状态分为5组，每一组中同时只能选用一种（例如dec、hex和oct中只能选一，它们是互相排斥的）。在用成员函数setf和控制符setiosflags设置输出格式状态后，如果想改设置为同组的另一状态，应当调用成员函数unsetf（对应于成员函数self）或resetiosflags（对应于控制符setiosflags），先终止原来设置的状态。然后再设置其他状态，大家可以从本程序中看到这点。程序在开始虽然没有用成员函数self和控制符setiosflags设置用dec输出格式状态，但系统默认指定为dec，因此要改变为hex或oct，也应当先用unsetf 函数终止原来设置。如果删去程序中的第7行和第10行，虽然在第8行和第11行中用成员函数setf设置了hex和oct格式，由于未终止dec格式，因此hex和oct的设置均不起作用，系统依然以十进制形式输出。

同理，程序倒数第8行的unsetf 函数的调用也是不可缺少的。

3) 用setf 函数设置格式状态时，可以包含两个或多个格式标志，由于这些格式标志在ios类中被定义为枚举值，每一个格式标志以一个二进位代表，因此可以用位或运算符“|”组合多个格式标志。如倒数第5、第6行可以用下面一行代替：
    cout.setf(ios::internal I ios::showpos);  //包含两个状态标志，用"|"组合

4) 可以看到：对输出格式的控制，既可以用控制符(如例13.2)，也可以用cout流的有关成员函数(如例13.3)，二者的作用是相同的。控制符是在头文件iomanip中定义的，因此用控制符时，必须包含iomanip头文件。cout流的成员函数是在头文件iostream 中定义的，因此只需包含头文件iostream，不必包含iomanip。许多程序人员感到使用控制符方便简单，可以在一个cout输出语句中连续使用多种控制符。

** [[http://bbs.ednchina.com/BLOG_ARTICLE_124613.HTM][]]    :blog:

** [[http://os.yesky.com/88/8733088.shtml][]]    :blog:

** [[http://os.yesky.com/88/8733088.shtml][Ubuntu系统上轻松截图的几种方法介绍]]    :blog:

相信大家对于屏幕截图(或称抓图)应该不会陌生，在Windows平台上，我们可以使用许多第三方的专业抓图软件如[[http://mydown.yesky.com/soft/multimedia/capture/446/401446.shtml][SnagIt]]等来实现抓取屏幕图像的功能。在
Ubuntu系统中，实现抓图功能的开源工具很多，用好这些工具可以让我们轻松获取任何所需的屏幕图像。本文介绍基于Ubuntu desktop 8.10(i386)，GNOME集成
桌面环境。

1.使用[[http://product.yesky.com/keyboard/][键盘]]快捷键抓图

在GNOME集成桌面环境下，我们可以使用键盘功能键Print Screen或Alt+Print Screen组合键来抓图，前者可以抓取整个屏幕的图像，而后者可以抓取当前
活动窗口的图像。例如抓取整个屏幕的图像，则按下Alt+Print Screen组合键，不一会儿将弹出“保存抓图”对话框(图1)，对话框中显示截图的文件名以及图像
存储的目标路径(这里我们使用默认存储路径)，如点击“复制到剪贴板”按钮则将截图复制到系统剪贴板中，在其他程序中使用时只要“粘贴”过去就可以了;如点
击“保存”按钮则将抓取的屏幕图像保存为文件，文件名由系统自动生成，如Screenshot.png。使用键盘快捷键来抓图，优点是快捷、方便，适用于只需要抓取全
屏或某个活动窗口图像的情况。

                                                                  Ubuntu

2.用gnome-screenshot抓图

GNOME集成桌面环境自带了抓图工具“抓图(gnome-screenshot)”。在菜单“[[http://search.yesky.com/search.do?wd=%25E5%25BA%2594%25E7%2594%25A8][应用]]程序”→“附件”下找到“抓图”项，单击该项则运行“抓图”程序(图2)。“抓图”程
序提供了抓取整个桌面或当前活动窗口图像的功能，可以设定抓取前的延迟时间。另外，抓图程序也支持一些简单的特效，如是否包括[[http://product.yesky.com/mouse/][鼠标]]箭头、窗口边框以及
是否带有阴影效果或方框。

                                                                  Ubuntu

需要指出的是，在GNOME集成桌面环境下，使用功能键Print Screen或组合键Alt+Print Screen来抓取屏幕图像，在后台调用的正是gnome-screenshot程序
。与用键盘快捷键抓图相比，“抓图”程序增加了一些特效功能，适合于对截图有特定需求的用户。

3.用GIMP自带的抓图功能抓图

GIMP是Linux平台上可与[[http://product.yesky.com/imagesoftware/adobe/][Adobe]] Photoshop媲美的图像处理软件，该软件也自带截图的功能。在系统菜单“应用程序→图形”下找到“GIMP图片编辑器”项，单击
该项运行GIMP程序。在打开的GIMP应用程序窗口的菜单“文件→Create”下找到“屏幕抓图”项，单击该项则出现“屏幕抓图”窗口(图3)。

                                                                  Ubuntu

使用GIMP的抓图工具可以抓取整个屏幕或当前活动窗口的图像或屏幕上的选定区域。当用户点击“抓取”按钮后，抓取的图像自动出现在GIMP图像编辑器中，
我们既可以利用GIMP强大的图像编辑功能直接对抓取的图像进行处理，也可以将抓取的图像以某种图像文件格式保存。

4.功能强大的KSnapshot

KSnapshot是KDE集成桌面环境自带的截图工具，不过在GNOME集成桌面环境下也可以安装和使用它。我们可以通过新立得软件包管理器或使用apt-get命令来
安装它。假设使用命令行方式来安装，打开一个GNOME终端窗口，在终端窗口中输入如下命令：

sudo apt-get install ksnapshot

命令执行后，将在线下载并安装KSnapshot。安装完毕后，在菜单“应用程序”→“图像”下找到“KSnapshot”项，点击该项则运行KSnapshot程序(如图4)。

                                                                  Ubuntu

KSnapshot功能非常强大，提供的截图模式有全屏(Full Screen)、光标下的窗体(Window under cursor)、任意区域(Region)和窗体部件(Section of
Window)四种。其中“光标下的窗体”抓取模式可以在不激活要抓取的窗体的情况下，只要将鼠标移动到该窗体的某个区域即可抓取该窗体。

在输出所抓取的图像方面，KSnapshot增加了复制到剪贴板和直接打印的功能。KSnapshot应该算得上是一款较为专业的抓图工具，使用KSnapshot几乎可以
轻松抓取屏幕上的任意图像，笔者推荐大家安装和使用这款软件。

** [[http://forum.nydus.co/forum.php?mod=viewthread&tid=4406&extra=page%3D1][Linux VPN设置教程]]    :blog:

| 注：由于桌面环境的不同，方法可能会有所差异                                                                                      |
| 1.在“系统设置”中找的“网络”                                                                                                      |
| [[static/image/common/none.gif]]                                                                                                |
| *图片1.png* /(105.53 KB, 下载次数: 9)/                                                                                          |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1MnxhNmQxMjQxNHwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:03 上传                                                                                                            |
|                                                                                                                                 |
| 2.打开“网络”，选择左下角的“+”                                                                                                   |
| [[static/image/common/none.gif]]                                                                                                |
| *图片2.png* /(42.26 KB, 下载次数: 2)/                                                                                           |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1M3wzNmRhNGVhNXwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:03 上传                                                                                                            |
|                                                                                                                                 |
| 3.点击“+”后选择“VPN”                                                                                                            |
| [[static/image/common/none.gif]]                                                                                                |
| *图片3.png* /(34.09 KB, 下载次数: 1)/                                                                                           |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1NHxjMDI2MzMyM3wxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:03 上传                                                                                                            |
|                                                                                                                                 |
| 4.选择“PPTP”                                                                                                                    |
| [[static/image/common/none.gif]]                                                                                                |
| *图片4.png* /(50.5 KB, 下载次数: 1)/                                                                                            |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1NXxiYjRlMTI1Y3wxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:04 上传                                                                                                            |
|                                                                                                                                 |
| 5.输入网关、用户名、密码                                                                                                        |
| [[static/image/common/none.gif]]                                                                                                |
| *图片5.png* /(58.87 KB, 下载次数: 1)/                                                                                           |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1NnxiMGNjMTZhMnwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:04 上传                                                                                                            |
|                                                                                                                                 |
| 6.选择右下角的“高级”                                                                                                            |
| [[static/image/common/none.gif]]                                                                                                |
| *图片6.png* /(43.03 KB, 下载次数: 2)/                                                                                           |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1N3wzYjZkYzExMXwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:04 上传                                                                                                            |
|                                                                                                                                 |
| 7.取消“EAP”，勾选“使用点到点加密（MPPE）”                                                                                       |
| [[static/image/common/none.gif]]                                                                                                |
| *图片7.png* /(63.88 KB, 下载次数: 2)/                                                                                           |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1OHxjZjM2Njk4ZnwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:04 上传                                                                                                            |
|                                                                                                                                 |
| 9.在右上角的网络图标找到“VPN”那栏，选择刚刚你配置的VPN的连接的名字，进行连接（注：不是所有的桌面环境都是这样的）                |
| 感谢用户秋月提供                                                                                                                |
| \\                                                                                                                              |

** [[http://blog.fens.me/ubuntu-vpn-pptp/][在Ubuntu上安装PPTP VPN服务]]    :blog:

此图完整的阐述了身为帝国平民的必备技能之一，VPN服务则是此种技能的技术实现，虚拟专用网络（Virtual Private Network ，简称VPN)指的是在公用网络上建立专用网络的技术。它涵盖了跨共享网络或公共网络的封装、加密和身份验证链接的专用网络的扩展。VPN主要采用了彩隧道技术、加解密技术、密钥管理技术和使用者与设备身份认证技术。
点对点隧道协议（PPTP）是VPN服务的一种最简单的实现协议，其它常见的VPN类型还有：使用IPsec的第2层隧道协议（L2TP/IPsec）、安全套接字隧道协议（SSL VPN）。本文主要讨论PPTP VPN服务在Ubuntu上的安装和配置。

A.使用apt源服务来安装PPTPD服务


sudo apt-get update
sudo apt-get install pptpd
B.安装完成之后编辑pptpd.conf配置文件


sudo vi /etc/pptpd.conf

#确保如下选项的配置
option /etc/ppp/pptpd-option                    #指定PPP选项文件的位置
debug                                           #启用调试模式
localip 192.168.0.1                             #VPN服务器的虚拟ip
remoteip 192.168.0.200-238,192.168.0.245        #分配给VPN客户端的虚拟ip
C.编辑PPP选项配置文件

sudo vi /etc/ppp/pptpd-options

#确保如下选项的配置
name pptpd                      #pptpd服务的名称
refuse-pap                      #拒绝pap身份认证模式
refuse-chap                     #拒绝chap身份认证模式
refuse-mschap                   #拒绝mschap身份认证模式
require-mschap-v2               #允许mschap-v2身份认证模式
require-mppe-128                #允许mppe 128位加密身份认证模式
ms-dns 8.8.8.8                  #使用Google DNS
ms-dns 8.8.4.4                  #使用Google DNS
proxyarp                        #arp代理
debug                           #调试模式
dump                            #服务启动时打印出所有配置信息
lock                            #锁定TTY设备
nobsdcomp                       #禁用BSD压缩模式
logfile /var/log/pptpd.log      #输出日志文件位置
D.编辑用户配置文件来添加用户

sudo vi /etc/ppp/chap-secrets

#格式：用户名   服务类型   密码   分配的ip地址
test    *    1234    *
#第一个*代表服务可以是PPTPD也可以是L2TPD，第二个*代表随机分配ip
E.重启PPTPD服务


sudo service pptpd restart
F.配置网络和路由规则 设置ipv4转发


sudo sed -i 's/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/g' /etc/sysctl.conf
sudo sysctl -p
设置iptables NAT转发

#注意这里eth0代表你的外网网卡，请用ifconfig查看或者咨询网络管理员
sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE
#如果上面的命令报错,那么可以尝试以下的命令，其中xxx.xxx.xxx.xxx代表你的VPS外网ip地址
sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j SNAT --to-source xxx.xxx.xxx.xxx
设置MTU来确保过大的包不会被丢弃（这个可以不做）


sudo iptables -I FORWARD -s 192.168.0.0/24 -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1300
iptables的设置重启之后会取消，所以可以将上面的命令加入到/etc/rc.local来确保每次重启都会执行设置。

G.至此设置全部完成，可以用任意一个客户端机器如MAC、PC或者手机来新建一个VPN连接使用用户test，密码1234进行测试。另外网上提供一种自动安装脚本，可以参见如下操作：


wget -c http://small-script.googlecode.com/files/debian-pptpd.tar.gz
tar -zxf debian-pptpd.tar.gz
sudo sh pptpd.sh
最后，如果想要实现更便利的用户管理，请参见在Ubuntu上安装FreeRADIUS服务。

** [[http://www.xp510.com/article/2564.html][关闭Win7 UAC教程]]    :blog:

相信每一个刚使用win7的人对于win7 UAC服务特别不舒服。每次操作时，都要等待一会，弹出来一个UAC提示。甚至很多人都开始对这个UAC反感。
 首先我们来讲一下UAC是什么？
UAC是User Account Control的缩写，也叫做用户帐户控制。从Windows Vista开始，微软为提高系统安全而引入的新技术。要求用户在执行，提供权限或管理员
密码，以此来提高系统的安全性。通过在这些操作启动前对其进行验证，UAC 可以帮助防止恶意软件和间谍软件在未经许可的情况下在计算机上进行安装或对计
算机进行更改。
下面我们以系统之家GHOST Win7_SP1纯净旗舰版V3.0为例，给大家讲解一下如何关闭win7 UAC服务。
1.点击windows 7开始按钮，在底下的输入框中输入MSCONFIG。之后，win7系统将弹出“系统配置”对话框。如下图：
\
2.选中“更改UAC设置”，并点击启动。弹出“用户账户控制设置”对话框。如下图：
 \
3.下拉到“从不通知”，然后点击确定，即可。这样，UAC的设置就完成了。
4.注意，关闭UAC要重启电脑才能生效。

好了，今天的教程关闭Win7 UAC到此为止。

** [[http://blog.csdn.net/zodiac1111/article/details/8193928][Linux下avr单片机开发环境]]    :blog:

*** 前提:环境

**** 软件:

***** 开发平台Linux(kernel 3.6):

终端使用=uname -a=命令查看:

#+BEGIN_EXAMPLE
    Linux localhost.localdomain 3.6.3-1.fc17.i686.PAE #1 SMP Mon Oct 22 15:48:37 UTC 2012 i686 i686 i386 GNU/Linux
#+END_EXAMPLE

***** Linux 发行版(Fedora)

终端使用=lsb_release -a=命令查看:

#+BEGIN_EXAMPLE
    LSB Version:    :core-4.1-ia32:core-4.1-noarch:cxx-4.1-ia32:cxx-4.1-noarch:desktop-4.1-ia32:desktop-4.1-noarch:languages-4.1-ia32:languages-4.1-noarch:printing-4.1-ia32:printing-4.1-noarch    Distributor ID: Fedora    Description:    Fedora release 17 (Beefy Miracle)    Release:    17    Codename:   BeefyMiracle
#+END_EXAMPLE

***** IDE 平台:

#+BEGIN_EXAMPLE
    Eclipse Platform
    Version: 4.2.1
    Build id: M20120914-1800
#+END_EXAMPLE

***** Eclipse 软件(插件)avr-eclipse:

#+BEGIN_EXAMPLE
    http://avr-eclipse.sourceforge.net
#+END_EXAMPLE

****** 下载软件:

******* Linux平台交叉编译avr程序交叉编译器:avr-gcc.

yum安装或者源代码编译

******* avr程序下载(烧写)软件:avrdude

网址[[http://savannah.nongnu.org/projects/avrdude/]]

**** 硬件:

***** 下载器:

****** USBasp,很早以前淘宝上买的[参考4]:

lsusb查看如下:

#+BEGIN_EXAMPLE
    Bus 003 Device 006: ID 16c0:05dc VOTI shared ID for use with libusb
#+END_EXAMPLE

这个好像只能下载(ISP).

****** AVR-JTAG-USB仿真器,也是很久以前买的[参考8]:

lsusb识别是usb转串,应该就是这样吧 = = .

#+BEGIN_EXAMPLE
    Bus 003 Device 012: ID 067b:2303 Prolific Technology, Inc. PL2303 Serial Port
#+END_EXAMPLE

除了下载功能以外,这个还能在线调试.

*以上两者任意一个都可以下载程序.*

***** 开发板:

一年多前淘宝买的开发板(ATmega128a)[参考5],原理图[参考6],扔那里也没怎么玩,最近来了兴致拿起来折腾折腾
:P .

*** 正文:搭建开发环境:在Linux在使用AVR-Eclipse中，AVR-GCC和AVRDUDE进行Atmel的AVR单片机开发.

[参考1]

**** 安装AVR-Eclipse

在Eclipse中单击帮助(Help)->安装新软件(Install New
Sofrware),之后将打开一个对话框.在对话框的顶部 Work with 文本框中粘贴
AVR-Eclipse 更新服务器的地址
([[http://avr-eclipse.sourceforge.net/updatesite/]]).如图:

[图:安装插件][[http://img.my.csdn.net/uploads/201211/17/1353137357_6721.png]]



安装好之后,点击窗口(Window)->首选项(Preferences)展开左边的AVR一栏.

[图:配置窗口]

[[http://img.my.csdn.net/uploads/201211/17/1353137381_2144.png]]



侧边栏 编程器配置(Programmer
COnfigurations)中点击添加(Add).左侧选择"USBasp,http://www.fishchl.de/usbasp"(*注意*:需要根据实际下载器硬件选择).

[图:下载器/编程器配置]

[[http://img.my.csdn.net/uploads/201211/17/1353137425_9540.png]]



同时,在项目-属性中也可以设置.

[图:项目属性中的设置(目标硬件设置等)]

[[http://img.my.csdn.net/uploads/201211/17/1353137470_4016.png]]

**** 使用

文件(File)->新建(New)->C语言项目(C Project).项目类型(Project
type)中选择AVR Cross Target Project -> Empty Project. 给项目名字.

下一步,点击高级设置(Advanced settings),选择之前配置文件.
就可以开始在Linux下进行单片机开发了.

编译完成后,点击avr菜单->上载项目到目标设备即可

[图:上载到设备(开发板)]

[[http://img.my.csdn.net/uploads/201211/17/1353137499_9855.png]]

环境详情参阅[参考1]

***** 可能遇到的问题:

****** 下载器(硬件)

1.
选择好适当的下载器.USBasp在Eclipse中工程项目的属性选项中,左侧Programmer
Hardwavr编程器硬件应该选择"USBasp".默认端口如果不是默认的=/dev/ttyUSB0=,必须填写正确的端口以覆盖配置.

2. 使用AVR JTAG USB仿真器时选择"Atmel JTAG
ICE(mk1)".因为默认端口(/dev/parport0)不是usb,可能会提示如下错误:

#+BEGIN_EXAMPLE
    avrdude: ser_open(): can't open device "/dev/parport0": No such file or directory
    avrdude: jtagmkI_close(): unsupported baudrate -1
#+END_EXAMPLE

所以默认端口必须覆盖,例如=/dev/ttyUSB0=.
测试可以下载,在线调试功能还在折腾中 :)

3. 总之:硬件和设置一定必须向配合.

****** 软件:linux设备文件权限

默认情况下普通用户是没有linux的设备文件的读写权限的.所以avarice可能会提示访问受限.

这时只要给avarice增加权限位即可.

1. 切换到root用户

2. chmod a+s /usr/bin/avrdude #赋予权限位

3. 切换回普通用户,继续操作即可.

*** 参考:

1. avr开发环境搭建教程(EN),本文主要就是参考/翻译它的.
   [[http://www.timteatro.net/2012/03/22/beginning-atmel-avr-development-in-linux-using-avr-eclipse-avr-gcc-and-avrdude/]]
2. Linux下avr-Eclipse环境(EN):[[http://awawa.hariko.com/eclipse_avr_en.html]]
3. avrdude
   命令说明(CN):[[http://blog.21ic.com/user1/69/archives/2005/1551.html]]
4. 淘宝上的USBasp下载器:[[http://tradearchive.taobao.com/trade/detail/tradeSnap.htm?spm=a1z09.2.9.147.BquMN6&tradeID=79509563401088]]
5. ATmega128a开发板淘宝:[[http://tradearchive.taobao.com/trade/detail/tradeSnap.htm?spm=a1z09.2.9.184.BquMN6&tradeID=79064532741088]]
6. 开发板原理图(DropBox),包括厂商提供的学习手册:[[https://www.dropbox.com/sh/hyh2zcqd3px6iml/tOYBevw_Co]]
7. 自制USBasp下载器(CN):[[http://www.amobbs.com/thread-723786-1-1.html]]
8. AVR-jtag
   usb仿真器(也可以用来下载):[[http://item.taobao.com/item.htm?spm=0.0.0.46.W1V8IW&id=2332186600]]

** [[http://blog.sina.com.cn/s/blog_605f124c0100dzsz.html][AT89S52最小系统和isp并口下载线]]    :blog:


一 最小系统

[[http://photo.blog.sina.com.cn/showpic.html#blogid=605f124c0100dzsz&url=http://s14.sinaimg.cn/orignal/605f124cx6b450b08fe8d&690][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]

小结：复位电路可以暂时省掉，在p1.0接发光二极管的阴极，阳极接5v高电平，确保最小系统可以用，用同学买的实验板下载一测试程序，让接P1.0的发光二极管闪起来。如果可以闪哪么最小系统搭建成功，再接上复位电路。

二 isp下载线

[[http://photo.blog.sina.com.cn/showpic.html#blogid=605f124c0100dzsz&url=http://s4.sinaimg.cn/orignal/605f124cx6b4528355423&690][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]

1、MOSI:数据串行输出 （S51 P1.5脚）， MISO:串行数据输入（S51 P1.6脚），
，SCK:同步控制时钟（S51
P1.7脚），RST接单片机复位脚（当有足够的高电平使S51处于复位状态，它就会开启读写程序功能），
LE:器件的锁存允许，OE:器件的输出允许

2、并口各针脚的功能。
2,3,4,5,6,7,8,9为数据口,可读可写;1,14,16,17为控制口,可读可写;10,11,12,13,15为状态口,只读.18-25接地。

3，目前电脑主要有三种类型的并口：Normal、EPP、ECP。

Normal口是一种低速的并口模式，适合将结果输出送到打印机上。又分为4bit、8bit、半8bit等几类。

EPP口(EnhancedParallelPort)：增强并行口。Intel、Xircom、Zenith和其它一些公司开发的，目的是在外部设备间进行双向通信。自1991年开始笔记本电脑率先配备有EPP口。

ECP口(ExtendedCapabilitiesPort)：扩展并行口。Intel和其它公司开发出EPP口的同时，Microsoft和Hewlett-Packard也开发了一种被称为ECP(扩展并行口)的接口规格。它具有和EPP一样高的速率和双向通信能力，但在多任务环境下，它能使用DMA(直接存储器访问)方式，所需缓冲区也不大。

<1>电脑bios设置：port设置Normal
address设置378（和下载软件对应即可如下图）[[http://photo.blog.sina.com.cn/showpic.html#blogid=605f124c0100dzsz&url=http://s10.sinaimg.cn/orignal/605f124cx6b453ba266a9&690][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]

<2>软件设置：我用的isp v1.3
主要是下载线配置文件根据上面的下载线电路原理图进行设置

;----------------------------EasyIsp-2的引脚定义-------------------------

[引脚控制]
 MOSI=2
 MISO=15
 SCK=5
 RST=16
 LE=17
 OE=1
 R1=3
 R2=4

[锁存控制(LE)]
 Enable=1
 Disable=1

 [输出控制(OE)]
 Enable=0
 Disable=1



;-------------------------------------说明--------------------------------
 ;  --引脚控制--
 ;
你可以定义下载线所使用的并口引脚，只要设置对应的引脚号即可。
 ;  MOSI:数据串行输出  MISO:串行数据输入  SCK:同步控制时钟
 ;  RST:复位  LE:器件的锁存允许  OE:器件的输出允许
 ;  R1,R2:保留为以后扩展用
 ;  注意:18-25引脚都接地
2,3,4,5,6,7,8,9为数据口,可读可写;1,14,16,17为控制
 ;  口,可读可写;10,11,12,13,15为状态口,只读.
 ;  如果引脚=0,表示该引脚无效,不作控制,例如74244的OE=0.
 ;
 ;  --锁存控制--
 ;  如果器件有LE,例如74373的LE,高电平有效低电平无效.所以可以Enable=1
 ;
Disable=0,如果Enable=1,Disable=1,表示LE引脚恒为高电平,Enable=0,Disable=0,
 ;  表示LE引脚恒为低电平
 ;
 ;  --输出控制--

 三 联机 下载

不知道是电源不稳定还是下载线过长（有1.0米）isplay v1.3无法检测到器件
但是可以进行读写擦除 跑马灯根据下载的程序闪起来 还是很爽的 呵呵！

** [[http://www.cnblogs.com/zcshan/archive/2010/12/03/com.html][并口、串口、COM口区别]]    :blog:


并口的工作模式：

1：SPP（Standard Parallel
Port）称为标准并口，它是最早出现的并口工作模式，几乎所有使用并口的外设都支持该模式。

2：EPP（Enhanced Parallel Port）称为增强型高速并口，它是在SPP
的基础上发展起来的新型工作模式，也是现在应用最多的并口工作模式，目前市面上的大多数打印机、扫描仪都支持EPP
模式。

3：ECP（ExtendedCapability
Port）即扩充功能并口，它是目前比较先进的并口工作模式，但兼容性问题也比较多，除非您的外设支持ECP
模式，否则不要选择该模式。



串口叫做[[http://baike.baidu.com/view/161117.htm][串行接口]]，也称串行通信接口，即COM口。按电气标准及协议来分包括[[http://baike.baidu.com/view/112004.htm][RS-232]]-C、[[http://baike.baidu.com/view/1940451.htm][RS-422]]、[[http://baike.baidu.com/view/196467.htm][RS485]]、[[http://baike.baidu.com/view/854.htm][USB]]等。
RS-232-C、RS-422与RS-485标准只对接口的电气特性做出规定，不涉及接插件、电缆或协议。USB是近几年发展起来的新型接口标准，主要应用于高速数据传输领域。


[[http://imgsrc.baidu.com/baike/pic/item/1899a23ed1770ae9828b13f2.jpg][[[http://images.cnblogs.com/cnblogs_com/zcshan/1899a23ed1770ae9828b13f2.jpg]]]]

RS-232-C：也称标准串口，是目前最常用的一种串行通讯接口。它是在1970年由美国电子工业协会（EIA）联合贝尔系统、
调制解调器厂家及计算机终端生产厂家共同制定的用于串行通讯的标
准。它的全名是“数据终端设备（DTE）和数据通讯设备（DCE）之间
串行二进制数据交换接口技术标准”。传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座。后来的PC上使用简化了的9芯D型插座。现在应用中25芯插头座已很少采用。现在的[[http://baike.baidu.com/view/2358.htm][电脑]]一般有两个串行口：COM1和COM2，你到计算机后面能看到9针D形接口就是了。现在有很多手机数据线或者物流接收器都采用COM口与计算机相连。

RS-422：为改进RS-232通信距离短、速率低的缺点，RS-422定义了一种平衡通信接口，将传输速率提高到10Mb/s，传输距离延长到4000英尺（速率低于100kb/s时），并允许在一条平衡总线上连接最多10个接收器。RS-422是一种单机发送、多机接收的单向、平衡传输规范，被命名为TIA/EIA-422-A标准。

RS-485：为扩展应用范围，EIA又于1983年在RS-422基础上制定了RS-485标准，增加了多点、双向通信能力，即允许多个发送器连接到同一条总线上，同时增加了发送器的驱动能力和冲突保护特性，扩展了总线共模范围，后命名为TIA/EIA-485-A标准。

Universal Serial
Bus（[[http://baike.baidu.com/view/474321.htm][通用串行总线]])简称USB，是目前电脑上应用较广泛的接口规范，由Intel、Microsoft、Compaq、IBM、NEC、Northern
Telcom等几家大厂商发起的新型外设接口标准。USB接口是电脑主板上的一种四针接口，其中中间两个针传输数据，两边两个针给外设供电。USB接口速度快、连接简单、不需要外接电源，传输速度12Mbps，最新USB2.0可达480Mbps；电缆最大长度5米，USB电缆有4条线，2条信号线，2条电源线，可提供5伏特电源，USB电缆还分屏蔽和非屏蔽两种，屏蔽电缆传输速度可达12Mbps，价格较贵，非屏蔽电缆速度为1.5Mbps，但价格便宜；USB通过串联方式最多可串接127个设备；支持热插拔。

RJ-45接口是以太网最为常用的接口，RJ45是一个常用名称，指的是由IEC
(60)603-7标准化，使用由国际性的接插件标准定义的8个位置(8针)的模块化插孔或者插头。



串口与并口的区别：

串口形容一下就是
一条车道，而并口就是有8个车道同一时刻能传送8位（一个字节）数据。

但是并不是并口快，由于8位通道之间的互相干扰。传输时速度就受到了限制。而且当传输出错时，要同时重新传8个位的数据。串口没有干扰，传输出错后重发一位就可以了。所以要比并口快。串口硬盘就是这样被人们重视的。



交换机的串口:

交换机的串口的英文就是trunk;是用来做下一跳路由转换用的.每个VLAN只有通过与TRUNK的路由指向后才能上外网

** [[http://www.waveshare.net/txt/AVR_ISP_Interface.htm][AVR ISP接口定义]]    :blog:

AVR的ISP接口是如何定义的？

大部分AVR MCU的ISP数据端口亦为 SCK、MOSI、MISO引脚（如Attiny13/24/2313，Atmega48/88/168，Atmega16/32/162，Atmega8515/8535等），如下：

ISP下载器   AVR端口                  备注
   端口
   MISO       MISO
   VCC        VCC
   SCK        SCK
   MOSI       MOSI
  RESET      RESET
   GND        GND

少部分AVRMCU的ISP数据端口则不是使用这些接口，而是：SCK、PDI、PDO引脚（如ATmega64/128/1281等），如下：

ISP下载器   AVR端口                  备注
   端口
   MISO       PDO
   VCC        VCC
   SCK        SCK
   MOSI       PDI
  RESET      RESET
   GND        GND

以上仅例举出常用的AVR型号的连接方式，若您使用的AVR型号没有被列举到，请查看相关型号的PDF文档，里面的编程章节将有介绍使用ISP时，需连接哪些引脚
。

下面是标准的接口排列：

[10-pin]
ATMEL指定的ISP_10PIN标准接口

[6-pin_]
ATMEL指定的ISP_6PIN标准接口


** [[http://www.dianziaihaozhe.com/ziliao/929/][三极管8050和8550对管的参数]]    :blog:



浏览发布时间 2009-03-13

三极管805

图１　8050和8550[[http://www.dianziaihaozhe.com/mulu/zhuanti/sjg/][三极管]]TO-92封装外形和引脚排列

三极管805

图２　8050和8550三极管SOT-23封装外形和引脚排列

8050和8550三极管在电路应用中经常作为对管来使用，当然很多时候也作为单管应用。8050 为硅材料NPN型三极管；8550 为硅材料PNP型三极管。

8050S 8550S S8050 S8550 参数：
耗散功率0.625W（贴片：0.3W）
集电极电流0.5A
集电极--基极电压40V
集电极--发射极击穿电压25V
特征频率fT 最小150MHZ 典型值产家的目录没给出
按三极管后缀号分为 B C D档贴片为 L H档
放大倍数B85-160 C120-200 D160-300 L100-200 H200-350

C8050 C8550 参数：
耗散功率1W
集电极电流1.5A
集电极--基极电压40V
集电极--发射极击穿电压25V
特征频率fT 最小100MHZ 典型190MHZ
放大倍数：按三极管后缀号分为 B C D档
放大倍数B：85-160 C：120-200 D：160-300

8050SS 8550SS 参数：
耗散功率﻿: 1W(TA=25℃) 2W(TC=25℃)
集电极电流1.5A
集电极--基极电压40V
集电极--发射极击穿电压25V
特征频率fT 最小100MHZ
放大倍数：按三极管后缀号分为 B C D D3 共4档
放大倍数 B：85-160 C：120-200 D：160-300 D3:300-400
引脚排列有EBC ECB两种

SS8050 SS8550 参数：
耗散功率﻿: 1W(TA=25℃) 2W(TC=25℃)
集电极电流1.5A
集电极--基极电压40V
集电极--发射极击穿电压25V
特征频率fT 最小100MHZ
放大倍数：按三极管后缀号分为 B C D 共3档
放大倍数 B：85-160 C：120-200 D：160-300
引脚排列多为EBC

UTC的 S8050 S8550 引脚排列有EBC
8050S 8550S 引脚排列有ECB
这种管子很少见
参数：
耗散功率1W
集电极电流0.7A
集电极--基极电压30V
集电极--发射极击穿电压20V
特征频率fT 最小100MHZ 典型产家的目录没给出
放大倍数：按三极管后缀号分为C D E档
C：120-200 D：160-300 E：280-400

NEC的8050
最大集电极电流(A):0.5 A;
直流电增益:10 to 60;
功耗:625 mW;
最大集电极-发射极电压（VCEO）:25;
频率:150 MHz .

其它的8050
PE8050 硅 NPN 30V 1.5A 1.1W
MC8050 硅 NPN 25V 700mA 200mW 150MHz
CS8050 硅 NPN 25V 1.5A FT=190 *K
3DG8050 硅 NPN 25V 1.5A FT=190 *K
2SC8050 硅 NPN 25V 1.5A FT=190 *K

值得注意的是，在代换相应的8050或8550三极管时，除了型号匹配，放大倍数也是很重要的参数。

** [[http://www.51hei.com/dianzi/300.html][晶振的作用与原理]]    :blog:


     每个单片机系统里都有晶振，全程是叫晶体震荡器，在单片机系统里晶振的作用非常大，他结合单片机内部的电路，产生单片机所必须的时钟频率，单片
机的一切指令的执行都是建立在这个基础上的，晶振的提供的时钟频率越高，那单片机的运行速度也就越快。

晶振用一种能把电能和机械能相互转化的晶体在共振的状态下工作，以提供稳定，精确的单频振荡。在通常工作条件下，普通的晶振频率绝对精度可达百万分之
五十。高级的精度更高。有些晶振还可以由外加电压在一定范围内调整频率，称为压控振荡器（VCO）。

晶振的作用是为系统提供基本的时钟信号。通常一个系统共用一个晶振，便于各部分保持同步。有些通讯系统的基频和射频使用不同的晶振，而通过电子调整频
率的方法保持同步。

晶振通常与锁相环电路配合使用，以提供系统所需的时钟频率。如果不同子系统需要不同频率的时钟信号，可以用与同一个晶振相连的不同锁相环来提供。

    晶振一般采用如图1a的电容三端式(考毕兹) 交流等效振荡电路；实际的晶振交流等效电路如图1b，其中Cv是用来调节振荡频率，一般用变容二极管加上不
同的反偏电压来实现，这也是压控作用的机理；把晶体的等效电路代替晶体后如图1c。其中Co，C1，L1，RR是晶体的等效电路。

                                                                  [200712]

  分析整个振荡槽路可知，利用Cv来改变频率是有限的：决定振荡频率的整个槽路电容C=Cbe,Cce,Cv三个电容串联后和Co并联再和C1串联。可以看出：C1越小，
Co越大，Cv变化时对整个槽路电容的作用就越小。因而能“压控”的频率范围也越小。实际上，由于C1很小(1E-15量级)，Co不能忽略(1E-12量级，几PF)。所以，
Cv变大时，降低槽路频率的作用越来越小，Cv变小时，升高槽路频率的作用却越来越大。这一方面引起压控特性的非线性，压控范围越大，非线性就越厉害；另
一方面，分给振荡的反馈电压(Cbe上的电压)却越来越小，最后导致停振。采用泛音次数越高的晶振，其等效电容C1就越小；因此频率的变化范围也就越小。

   微控制器的时钟源可以分为两类：基于机械谐振器件的时钟源，如晶振、陶瓷谐振槽路；RC（电阻、电容）振荡器。一种是皮尔斯振荡器配置，适用于晶振
和陶瓷谐振槽路。另一种为简单的分立RC振荡器。

  用万用表测量晶体振荡器是否工作的方法：测量两个引脚电压是否是芯片工作电压的一半，比如工作电压是51单片机的+5V则是否是2.5V左右。另外如果用镊
子碰晶体另外一个脚，这个电压有明显变化，证明是起振了的。

  晶振的类型有SMD和DIP型，即贴片和插脚型。

 先说DIP：常用尺寸有HC-49U/T，HC-49S，UM-1，UM-5，这些都是MHZ单位的。

  再说SMD：有0705，0603，0503，0302，这里面又分四个焊点和二个焊点的，对我们公司来说默认的是四个焊点的，两个焊点的材料要求进口，周期长，一般
说两个焊点的做不了。

** [[http://blog.csdn.net/muge0913/article/details/6741064][VCC,VDD,VEE,VSS,VPP 表示的意义]]    :blog:

VCC,VDD,VEE,VSS,VPP 表示的意义

*版本一：*

简单说来，可以这样理解：

一、解释

VCC：C=circuit 表示电路的意思, 即接入电路的电压；
 VDD：D=device 表示器件的意思, 即器件内部的工作电压；
 VSS：S=series 表示公共连接的意思，通常指电路公共接地端电压；
 VEE：负电压供电；
 VPP：编程/擦除电压。

二、说明

1、对于数字电路来说，VCC是电路的供电电压,VDD是芯片的工作电压（通常Vcc>Vdd），VSS是接地点。
 2、有些IC既有VDD引脚又有VCC引脚，说明这种器件自身带有电压转换功能。

3、在场效应管（或COMS器件）中，VDD为漏极，VSS为源极，VDD和VSS指的是元件引脚，而不表示供电电压。

*版本二：*

VPP：编程/擦除电压。
 VEE：负电压供电；场效应管的源极（S）
 VSS:地或电源负极

VCC：电源电压（双极器件）；电源电压（74系列数字电路）；声控载波（Voice Controlled Carrier)

VDD:电源电压（单极器件）；电源电压（4000系列数字电 路）；漏极电压（场效应管）

*版本三：*

通常VCC和VDD为电源正，而VEE和VSS为电源负或者地。
 VSS表示连接到场效应管的源极（S）的电源。
 VDD表示连接到场效应管的漏极（D）的电源。
 VEE表示连接到三极管发射极（E）的电源。
 VCC表示连接到三极管集电极（C）的电源。
 它们是这样得名的：

VCC、VDD、VEE、VSS是指芯片、分解电路的电源集结点，详细接电源的极性需视器件材料而定。 VCC一般是指直接连接到集成或分解电路内部的三极管C极，VEE是指连接到集成或分解电路内部三极管的E极。 同样，VDD、VSS就是指连接到集成内部、分解电路的场效应管的D和S极。 例如是采用P沟E/DMOS工艺制成的集成，那么它的VDD就应接电源的负，而VSS应接正电源。

*版本四：*

Vcc和Vee出现在双极型晶体管电路中，和集电极(collector)发射极(emitter)有关，所以一正一负。

Vdd,Vss在MOS电路中出现，和漏级(Drain)，源极(Source)有关，也是一正一负。

Vcc和Vdd是器件的电源端。Vcc是双极器件的正，Vdd多半是单级器件的正（例如：二极管）。下标可以理解为NPN晶体管的集电极C，和PMOS
or
NMOS场效应管的漏极D。同样你可在电路图中看见Vee和Vss，含义一样。因为主流芯片结构是硅NPN所以Vcc通常是正。如果用PNP结构Vcc就为负了。建议选用芯片时一定要看清电气参数。
 单片机中Vpp多数定义为编程电压，有的资料上把Vddf为Flash供电的外部电压



*总结：这四个版本从两个方面讲了VCC、VDD、VEE、VSS、VPP之间的区别，前两个版本一个方面，后两个版本一个方面，互相补充。*

** [[http://www.cnblogs.com/lds85930/archive/2007/09/19/897912.html][二进制、八进制、十进制、十六进制之间转换]]    :blog:

一、 十进制与二进制之间的转换
 （1） 十进制转换为二进制，分为整数部分和小数部分
 ① 整数部分

方法：除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。下面举例：
 例：将十进制的168转换为二进制

 得出结果 将十进制的168转换为二进制，（10101000）2
 分析:第一步，将168除以2,商84,余数为0。
 第二步，将商84除以2，商42余数为0。
 第三步，将商42除以2，商21余数为0。
 第四步，将商21除以2，商10余数为1。
 第五步，将商10除以2，商5余数为0。
 第六步，将商5除以2，商2余数为1。
 第七步，将商2除以2，商1余数为0。
 第八步，将商1除以2，商0余数为1。

第九步，读数，因为最后一位是经过多次除以2才得到的，因此它是最高位，读数字从最后的余数向前读，即10101000

 （2） 小数部分

方法：乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，剩下的小数部分又乘以2，一直取到小数部分

为零为止。如果永远不能为零，就同十进制数的四舍五入一样，按照要求保留多少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向入一位。换句话说就是0舍1入。读数要从前面的整数读到后面的整数，下面举例：
 例1：将0.125换算为二进制

 得出结果：将0.125换算为二进制（0.001）2
 分析：第一步，将0.125乘以2，得0.25,则整数部分为0,小数部分为0.25;
 第二步, 将小数部分0.25乘以2,得0.5,则整数部分为0,小数部分为0.5;
 第三步, 将小数部分0.5乘以2,得1.0,则整数部分为1,小数部分为0.0;
 第四步,读数,从第一位读起,读到最后一位,即为0.001。


 例2,将0.45转换为二进制（保留到小数点第四位）



大家从上面步骤可以看出，当第五次做乘法时候，得到的结果是0.4，那么小数部分继续乘以2，得0.8，0.8又乘以2的，到1.6这样一直乘下去，最后不可能得到小数部分为零，因此，这个时候只好学习十进制的方法进行四舍五入了，但是二进制只有0和1两个，于是就出现0舍1入。这个也是计算机在转换中会产生误差，但是由于保留位数很多，精度很高，所以可以忽略不计。
 那么，我们可以得出结果将0.45转换为二进制约等于0.0111
 上面介绍的方法是十进制转换为为二进制的方法，需要大家注意的是：
 1） 十进制转换为二进制，需要分成整数和小数两个部分分别转换
 2） 当转换整数时，用的除2取余法，而转换小数时候，用的是乘2取整法
 3） 注意他们的读数方向

因此，我们从上面的方法，我们可以得出十进制数168.125转换为二进制为10101000.001,或者十进制数转换为二进制数约等于10101000.0111。

 （3） 二进制转换为十进制 不分整数和小数部分

方法：按权相加法，即将二进制每位上的数乘以权，然后相加之和即是十进制数。例
 将二进制数101.101转换为十进制数。

 得出结果：（101.101）2=(5.625)10
 大家在做二进制转换成十进制需要注意的是
 1） 要知道二进制每位的权值
 2） 要能求出每位的值


 二、 二进制与八进制之间的转换

首先，我们需要了解一个数学关系，即23=8，24=16，而八进制和十六进制是用这

关系衍生而来的，即用三位二进制表示一位八进制，用四位二进制表示一位十六进制数。

接着，记住4个数字8、4、2、1（23=8、22=4、21=2、20=1）。现在我们来练习二进制与八进制之间的转换。
 （1） 二进制转换为八进制

方法：取三合一法，即从二进制的小数点为分界点，向左（向右）每三位取成一位，接着将这三位二进制按权相加，得到的数就是一位八位二进制数，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的八进制数。如果向左（向右）取三位后，取到最高（最低）位时候，如果无法凑足三位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足三位。例
 ①将二进制数101110.101转换为八进制

 得到结果：将101110.101转换为八进制为56.5

 ② 将二进制数1101.1转换为八进制

 得到结果：将1101.1转换为八进制为15.4

 （2） 将八进制转换为二进制

方法：取一分三法，即将一位八进制数分解成三位二进制数，用三位二进制按权相加去凑这位八进制数，小数点位置照旧。例：
 ① 将八进制数67.54转换为二进制

 因此，将八进制数67.54转换为二进制数为110111.101100，即110111.1011
 大家从上面这道题可以看出，计算八进制转换为二进制
 首先，将八进制按照从左到右，每位展开为三位，小数点位置不变
 然后，按每位展开为22，21，20（即4、2、1）三位去做凑数，即a×22+ b×21
+c×20=该位上的数（a=1或者a=0，b=1或者b=0，c=1或者c=0）,将abc排列就是该位的二进制数
 接着，将每位上转换成二进制数按顺序排列
 最后，就得到了八进制转换成二进制的数字。
 以上的方法就是二进制与八进制的互换，大家在做题的时候需要注意的是
 1） 他们之间的互换是以一位与三位转换，这个有别于二进制与十进制转换
 2）
大家在做添0和去0的时候要注意，是在小数点最左边或者小数点的最右边（即整数的最高位和小数的最低位）才能添0或者去0，否则将产生错误

 三、 二进制与十六进制的转换

方法：与二进制与八进制转换相似，只不过是一位（十六）与四位（二进制）的转换，下面具体讲解
 （1） 二进制转换为十六进制

方法：取四合一法，即从二进制的小数点为分界点，向左（向右）每四位取成一位，接着将这四位二进制按权相加，得到的数就是一位十六位二进制数，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的十六进制数。如果向左（向右）取四位后，取到最高（最低）位时候，如果无法凑足四位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足四位。
 ①例：将二进制11101001.1011转换为十六进制

 得到结果：将二进制11101001.1011转换为十六进制为E9.B


 ② 例：将101011.101转换为十六进制

 因此得到结果：将二进制101011.101转换为十六进制为2B.A



 (2)将十六进制转换为二进制

方法：取一分四法，即将一位十六进制数分解成四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧。
 ①将十六进制6E.2转换为二进制数

 因此得到结果：将十六进制6E.2转换为二进制为01101110.0010即110110.001

 四、八进制与十六进制的转换

方法：一般不能互相直接转换，一般是将八进制（或十六进制）转换为二进制，然后再将二进制转换为十六进制（或八进制），小数点位置不变。那么相应的转换请参照上面二进制与八进制的转换和二进制与十六进制的转


 五、八进制与十进制的转换
 （1）八进制转换为十进制

方法：按权相加法，即将八进制每位上的数乘以位权，然后相加之和即是十进制数。
 例：①将八进制数67.35转换为十进制

 （2）十进制转换为八进制
 十进制转换成八进制有两种方法：
 1）间接法：先将十进制转换成二进制，然后将二进制又转换成八进制

2）直接法：前面我们讲过，八进制是由二进制衍生而来的，因此我们可以采用与十进制转换为二进制相类似的方法，还是整数部分的转换和小数部分的转换，下面来具体讲解一下：
 ①整数部分

方法：除8取余法，即每次将整数部分除以8，余数为该位权上的数，而商继续除以8，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。
 ②小数部分

方法：乘8取整法，即将小数部分乘以8，然后取整数部分，剩下的小数部分继续乘以8，然后取整数部分，剩下的小数部分又乘以8，一直取到小数部分为零为止。如果永远不能为零，就同十进制数的四舍五入一样，暂取个名字叫3舍4入。
 例：将十进制数796.703125转换为八进制数
 解：先将这个数字分为整数部分796和小数部分0.703125
 整数部分

 小数部分

 因此，得到结果十进制796.703125转换八进制为1434.55

上面的方法大家可以验证一下，你可以先将十进制转换，然后在转换为八进制，这样看得到的结果是否一样

 六、十六进制与十进制的转换

十六进制与八进制有很多相似之处，大家可以参照上面八进制与十进制的转换自己试试这两个进制之间的转换。
 通过上面对各种进制之间的转换，我们可以将前面的转换图重新完善一下：



本文介绍了二进制、十进制、八进制、十六进制四种进制之间相互的转换，大家在转换的时候要注意转换的方法，以及步骤，特别是十进制转换为期于三种进制之间，要分为整数部分和小数部分，最后就是小数点的位置。但是要保证考试中不出现错误还是需要大家经常练习，这样才能熟能生巧。

** [[http://www.cnblogs.com/gmh915/archive/2010/06/11/1756067.html][指针函数与函数指针的区别]]    :blog:



一、

在学习arm过程中发现这“指针函数”与“函数指针”容易搞错，所以今天，我自己想一次把它搞清楚，找了一些资料，首先它们之间的定义：

1、指针函数是指带指针的函数，即本质是一个函数。函数返回类型是某一类型的指针

  类型标识符  *函数名(参数表)

  int *f(x，y);



首先它是一个函数，只不过这个函数的返回值是一个地址值。函数返回值必须用同类型的指针变量来接受，也就是说，指针函数一定有函数返回值，而且，在主调函数中，函数返回值必须赋给同类型的指针变量。

表示：

float *fun();

float *p;

p = fun(a);

注意指针函数与函数指针表示方法的不同，千万不要混淆。最简单的辨别方式就是看函数名前面的指针*号有没有被括号（）包含，如果被包含就是函数指针，反之则是指针函数。

来讲详细一些吧！请看下面

 指针函数：
 当一个函数声明其返回值为一个指针时，实际上就是返回一个地址给调用函数，以用于需要指针或地址的表达式中。
 格式：
 类型说明符 * 函数名(参数)
 当然了，由于返回的是一个地址，所以类型说明符一般都是int。
 例如：int *GetDate();
 int * aaa(int,int);
 函数返回的是一个地址值，经常使用在返回数组的某一元素地址上。

 int * GetDate(int wk,int dy);

 main()
 {
 int wk,dy;
 do
 {
 printf(Enter week(1-5)day(1-7)\n);
 scanf(%d%d,&wk,&dy);
 }
 while(wk<1||wk>5||dy<1||dy>7);
 printf(%d\n,*GetDate(wk,dy));
 }

 int * GetDate(int wk,int dy)
 {
 static int calendar[5][7]=
 {
 {1,2,3,4,5,6,7},
 {8,9,10,11,12,13,14},
 {15,16,17,18,19,20,21},
 {22,23,24,25,26,27,28},
 {29,30,31,-1}
 };
 return &calendar[wk-1][dy-1];
 }
 程序应该是很好理解的，子函数返回的是数组某元素的地址。输出的是这个地址里的值。







2、函数指针是指向函数的指针变量，即本质是一个指针变量。

int (*f) (int x); /* 声明一个函数指针 */

f=func; /* 将func函数的首地址赋给指针f */



指向函数的指针包含了函数的地址，可以通过它来调用函数。声明格式如下：
 类型说明符 (*函数名)(参数)
 其实这里不能称为函数名，应该叫做指针的变量名。这个特殊的指针指向一个返回整型值的函数。指针的声明笔削和它指向函数的声明保持一致。
 指针名和指针运算符外面的括号改变了默认的运算符优先级。如果没有圆括号，就变成了一个返回整型指针的函数的原型声明。
 例如：
 void (*fptr)();
 把函数的地址赋值给函数指针，可以采用下面两种形式：
 fptr=&Function;
 fptr=Function;
 取地址运算符&不是必需的，因为单单一个函数标识符就标号表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。
 可以采用如下两种方式来通过指针调用函数：
 x=(*fptr)();
 x=fptr();
 第二种格式看上去和函数调用无异。但是有些程序员倾向于使用第一种格式，因为它明确指出是通过指针而非函数名来调用函数的。下面举一个例子：

 void (*funcp)();
 void FileFunc(),EditFunc();

 main()
 {
 funcp=FileFunc;
 (*funcp)();
 funcp=EditFunc;
 (*funcp)();
 }

 void FileFunc()
 {
 printf(FileFunc\n);
 }

 void EditFunc()
 {
 printf(EditFunc\n);
 }

 程序输出为：
 FileFunc
 EditFunc



主要的区别是一个是指针变量，一个是函数。在使用是必要要搞清楚才能正确使用



二、指针的指针
 指针的指针看上去有些令人费解。它们的声明有两个星号。例如：
 char ** cp;
 如果有三个星号，那就是指针的指针的指针，四个星号就是指针的指针的指针的指针，依次类推。当你熟悉了简单的例子以后，就可以应付复杂的情况了。当然，实际程序中，一般也只用到
二级指针，三个星号不常见，更别说四个星号了。
 指针的指针需要用到指针的地址。
 char c='A';
 char *p=&c;
 char **cp=&p;
 通过指针的指针，不仅可以访问它指向的指针，还可以访问它指向的指针所指向的数据。下面就是几个这样的例子：
 char *p1=*cp;
 char c1=**cp;
 你可能想知道这样的结构有什么用。利用指针的指针可以允许被调用函数修改局部指针变量和处理指针数组。

 void FindCredit(int **);

 main()
 {
 int vals[]={7,6,5,-4,3,2,1,0};
 int *fp=vals;
 FindCredit(&fp);
 printf(%d\n,*fp);
 }

 void FindCredit(int ** fpp)
 {
 while(**fpp!=0)
 if(**fpp<0) break;
 else (*fpp)++;
 }

 首先用一个数组的地址初始化指针fp，然后把该指针的地址作为实参传递给函数FindCredit()。FindCredit()函数通过表达式**fpp间接地得到数组中的数据。为遍历数组以找到一个负值，FindCredit()函数进行自增运算的对象是调用者的指向数组的指针，而不是它自己的指向调用者指针的指针。语句(*fpp)++就是对形参指针指向的指针进行自增运算的。但是因为*运算符高于++运算符，所以圆括号在这里是必须的，如果没有圆括号，那么++运算符将作用于二重指针fpp上。

三、指向指针数组的指针
 指针的指针另一用法旧处理指针数组。有些程序员喜欢用指针数组来代替多维数组，一个常见的用法就是处理字符串。

 char *Names[]=
 {
 Bill,
 Sam,
 Jim,
 Paul,
 Charles,
 0
 };

 main()
 {
 char **nm=Names;
 while(*nm!=0) printf(%s\n,*nm++);
 }

 先用字符型指针数组Names的地址来初始化指针nm。每次printf()的调用都首先传递指针nm指向的字符型指针，然后对nm进行自增运算使其指向数组的下一个元素(还是指针)。注意完成上述认为的语法为*nm++，它首先取得指针指向的内容，然后使指针自增。
 注意数组中的最后一个元素被初始化为0，while循环以次来判断是否到了数组末尾。具有零值的指针常常被用做循环数组的终止符。程序员称零值指针为空指针(NULL)。采用空指针作为终止符，在树种增删元素时，就不必改动遍历数组的代码，因为此时数组仍然以空指针作为结束。

** [[http://blog.csdn.net/jiangwei0910410003/article/details/38269117][数据结构和算法设计专题之---判断单链表中是否有环，环的长度，环的入口节点]]    :blog:

题目：

给定一个单链表，只给出头指针head：

*1、如何判断是否存在环？
 2、如何知道环的长度？
 3、如何找出环的连接点在哪里？
 4、带环链表的长度是多少？*

 解法：

1、对于问题1，使用追赶的方法，设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。

2、对于问题2，记录下问题1的碰撞点p，slow、fast从该点开始，再次碰撞所走过的操作数就是环的长度s。

3、问题3：有定理：*碰撞点p到连接点的距离=头指针到连接点的距离*，因此，分别从碰撞点、头指针开始走，相遇的那个点就是连接点。(证明在后面附注)

4、问题3中已经求出连接点距离头指针的长度，加上问题2中求出的环的长度，二者之和就是带环单链表的长度



判断是否存在环的程序：

#+BEGIN_EXAMPLE
    bool IsExitsLoop(slist *head)
    {
        slist *slow = head, *fast = head;
        while ( fast && fast->next )
        {
            slow = slow->next;
            fast = fast->next->next;
            if ( slow == fast ) break;
        }
        return !(fast == NULL || fast->next == NULL);
    }
#+END_EXAMPLE


 寻找环连接点（入口点）的程序：

#+BEGIN_EXAMPLE
    slist* FindLoopPort(slist *head)
    {
        slist *slow = head, *fast = head;
        while ( fast && fast->next )
        {
            slow = slow->next;
            fast = fast->next->next;
            if ( slow == fast ) break;
        }
        if (fast == NULL || fast->next == NULL)
            return NULL;
        slow = head;
        while (slow != fast)
        {
             slow = slow->next;
             fast = fast->next;
        }
        return slow;
    }
#+END_EXAMPLE



亦可以用类似与hash表的方法，即设立一个数组，将链表结点中的值做数组下标，当赋值冲突时就是环的接入点



证明题：

对于一个顺时针的环，有P,Q两点，且两点相距为N,同时，P每向前移动一步，Q就向前以东两步，已知环的周长是L,问P,Q两点相遇在哪点上？如下图所示：P点是环的入口点

[[http://img.blog.csdn.net/20140729143710703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center]]

假设P,Q两点相遇时，P点移动的距离是X,则有以下等式：

X-N = 2*X - L;

=>X= L-N

那么我可以从上图看到相遇点离入口点的距离为：L-(L-N)=N



综上所述：

假设单链表的总长度为L，头结点到环入口的距离为a，环入口到快慢指针相遇的结点距离为x，环的长度为r，慢指针总共走了s步，则快指针走了2s步。另外，快指针要追上慢指针的话快指针至少要在环里面转了一圈多(假设转了n圈加x的距离)，得到以下关系：
     s = a + x
     2s = a + nr + x
     =>a + x = nr
     =>a = nr - x

由上式可知：若在头结点和相遇结点分别设一指针，同步(单步)前进，则最后一定相遇在环入口结点

通过上面的证明题发现数学知识在编程世界中真的很重要呀~~



总结：我们看到这里面有一个核心的地方就是第一个问题，判断有没有环的情况，采用了两个指针：快指针和慢指针，这个在处理一些链表的问题中尤其重要，比如下面的两道关于链表的题目：

*第一题：已知单链表的头指针，查找到倒数第K个节点*

这道题的通俗的解法就是先遍历一边链表，得到链表的长度N,然后再从头开始遍历N-K个节点即可

但是现在如果要求只遍历一遍链表的话，该怎么操作呢？

这时候就可以借助快指针和慢指针了

我们定义一个快指针P和慢指针Q,先让P指针走到K个节点位置，然后Q指针从头指针开始和P一起移动，当P移动到尾部的时候，那么此时Q节点所在的位置就是倒数第K个节点。



*第二题：已知单链表的头结点，查找到链表的中间节点*

这道题的通俗的解法和上面的方法一样，就是先遍历一边链表，得到链表的长度N，然后再次遍历N/2个节点即可

但是现在同样的如果要求之遍历一边链表的话，该怎么操作呢？

这时候我们同样可以借助快指针和慢指针了

我们定义一个快指针P和慢指针Q,P和Q同时从头指针出发，快指针P每次移动两步，慢指针每次移动一步，当快指针P到尾部的时候，慢指针Q所在的位置就是中间节点的位置。



通过上面的两道题目我们可以看到快慢指针的在解决单链表的相关问题上还是很有用的~~



下面在来看一下还有一个技巧就是在解决第二道题目的时候，那个求环的入口节点，这个当时真的是没有任何头绪，所以这时候就要求我们又很好的数学功底了，能够发现相关的规律，然后总结出定理，这样就可以将问题简化了。

** [[http://blog.csdn.net/guoyong10721073/article/details/8144401][判断一个单向链表中是否有环]]    :blog:

**** 写一段代码判断一个单向链表中是否有环

#+BEGIN_EXAMPLE
    思路：
    用两个指针，pSlow，pFast，就是一个慢一个快
    慢的一次跳一步，
    快的一次跳两步，
    什么时候快的追上慢的了就表示有环（pSlow == pFast ）。
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    实现如下：
#+END_EXAMPLE

#+BEGIN_EXAMPLE
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    struct  listtype
    {
        int data;
        struct listtype * next;
    }list;

    int find_cicle(list *head)
    {
         list *pFast=head;
         list *pSlow=head;
         if (pFast==NULL)
         {
              return -1;
          }
         while(pFast && pFast->next)
        {
            pFast=pFast->next->next;
            pSlow=pSlow->next;
            if (pFast==pSlow)
           {
               return 1;
            }
         }
         return 0
    }
#+END_EXAMPLE


调用函数返回值为1时，表示单向链表有环；

#+BEGIN_EXAMPLE
    调用函数返回值为-1时，表示测试的单向链表为空；
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    调用函数返回值为0时，表示单向链表无环；
#+END_EXAMPLE

** [[http://blog.sina.com.cn/s/blog_5420e000010185o2.html][conflicting types for xx错误]]    :blog:

编译libvmi 0.8版本时，出现以下错误：

libtool: compile:  gcc -DHAVE_CONFIG_H -I. -I.. -I..
-fvisibility=hidden -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include
-g -O2 -MT libvmi_la-pretty_print.lo -MD -MP -MF
.deps/libvmi_la-pretty_print.Tpo -c pretty_print.c  -fPIC -DPIC -o
.libs/libvmi_la-pretty_print.o

pretty_print.c:31: error: conflicting types for ‘vmi_print_hex'

libvmi.h:749: note: previous declaration of ‘vmi_print_hex' was here

make[3]: *** [libvmi_la-pretty_print.lo] Fehler 1

make[3]: Leaving directory `/usr/local/src/libvmi-0.8/libvmi'

make[2]: *** [all-recursive] Fehler 1

make[2]: Leaving directory `/usr/local/src/libvmi-0.8/libvmi'

make[1]: *** [all-recursive] Fehler 1

make[1]: Leaving directory `/usr/local/src/libvmi-0.8'

make: *** [all] Fehler 2

解决方案：

将*libvmi/libvmi.h:void vmi_print_hex (unsigned char *data, unsigned
long length);和*

*libvmi/pretty_print.c:void vmi_print_hex (unsigned char *data,
size_t length)*

*中的数据类型改为一致的即可。*

*见其论坛：[[https://groups.google.com/forum/?fromgroups#!topic/vmitools/w76m93KevFg]]*



*常见此类问题的原因如下（引）*

错误：
test.c:22: error: conflicting types for 'urlencode'
 test.c:18: error: previous implicit declaration of 'urlencode' was here



原因一：
 原来是因为没有先做函数声明，而函数位于main()之后。
 在main函数前声明了函数原型后，一切ok.



原因二：

头文件的被循环引用，在引用时考虑清楚包含顺序



原因三：

头文件声明和定义参数稍有不同

例：

 头文件中声明 void Hanlder(const char * buf);

 在定义时写作 void Hanlder(char * buf);

这是就会发生conflicting types for 错误问题

** [[http://blog.chinaunix.net/uid-21411227-id-1826747.html][gcc及其选项详解]]    :blog:

*1.简介：*

gcc是gnu旗舰产品,目前基本上就是和unix捆绑在一起分发的。这个东西功能强大,但是有多达上千个选项,其用户手册也有将近一万行.虽然其中的多数选项平时很少用到.但是不管装软件还是写程序,往往都会用到gcc.下面我就gcc最最常用的几个选项做一个简要的说明,如果你想对gcc有一个全面的了解,比如你想知道在其他非x86平台上gcc是如何工作的话,你可以用命令：man
gcc;

gcc  [-c|-S|-E] [-std=standard]

  [-g] [-pg] [-Olevel]

  [-Wwarn...] [-pedantic]

  [-Idir...] [-Ldir...]

  [-Dmacro[=defn]...] [-Umacro]

  [-foption...] [-mmachine-option...]

  [-o outfile] infile...

-c  编译为目标文件，不连接库

-S  编译为汇编代码

-E   预处理.预处理之后的代码将送往标准输出

-Wwarn... 设置警告,可以设置的警告开关很多,通常用-Wall开启所有的警告

-Olevel  设置优化级别,level可以是0,1,2,3或者s,默认-O0,即不进行优化。.

-Dname=definition...
在命令行上定义宏,有两种方式,-Dname或者-Dname=definition.在命令行上设置宏定义的目的主要是为了在调试的时候设定一些开关,
而在发布的时候再关闭或者打开这些开关即可,当然宏定义也用来对代码进行有选择地编译.另外也还有其他的一些作用.

-Uname  取消宏定义name,作用和上面的正好相反.

-Idir...
把dir加到头文件的搜索路径中,而且gcc会在搜索标准头文件之前先搜索dir.

-llibrary
在连接的时候搜索library库，库是一些archieve文件--其成员是目标文件.如果有文件引用library,library在命令行的位置应该在那个文件之后,因此,*越底层的库越要放在后面.*比如如果你要连接pcap库,那么你就需要使用-lpcap对源文件进行编译.

-Ldir...
把dir加到库文件的搜索路径中,而且gcc会在搜索标准库文件之前先搜索dir.

-pthread
通过pthreads库加入对多线程的支持,这为预处理和连接设置了标志.pthread是POSIX指定的标准线程库.

-std=standard
设置采用的标准,该选项是针对C语言的,比如-std=c99表示编译器遵循C99标准.该选项较少使用.而且有时反而会把你搞糊涂.

-o outfile  指定输出文件的文件名,默认为a.out

-mmachine-option...  指定所用的平台.



---------------------------------------------------------------------------------------

*2.gcc常用选项总结* **

*2.1* *常规选项* **

1、没有任何选项：gcc  helloworld.c

结果会在与helloworld.c相同的目录下产生一个a.out的可执行文件。

*2、-o选项，指定输出文件名：*gcc -o helloworld helloworld.c

-o意思是Output即需要指定输出的可执行文件的名称。这里的名称为helloworld。

*3、-c选项，只编译，不汇编连接：*gcc -c helloworld.c

-c意思就是Compile，产生一个叫helloworld.o的目标文件

4、-S选项，产生汇编源文件：gcc -S helloworld.c

-S意思就是aSsemble，产生一个叫helloworld.s的汇编源文件

5、-E选项，预处理C源文件：gcc -E helloworld.c

-E意思就是prEprocess。输出不是送到一个文件而是标准输出。当然可以对它进行重定向：

gcc -E helloworld.c > helloworld.txt

*2.2* *优化选项* **

1) -O选项，基本优化：gcc -O helloworld.c

-O意思就是Optimize，产生一个经过优化的叫作a.out的可执行文件。也可以同时使用-o选项，以指定输出文件名。如：

gcc -O -o test helloworld.c

即会产生一个叫test的经过优化的可执行文件。

2) -O2选项，最大优化：gcc -O2 helloworld.c

产生一个经过最大优化的叫作a.out的可执行文件。

*2.3* *调试选项* **

*1) -g选项，产生供gdb调试用的可执行文件：gcc -g helloworld.c*

产生一个叫作a.out的可执行文件，大小明显比只用-o选项编译汇编连接后的文件大。

2) -pg选项，产生供gprof剖析用的可执行文件：gcc -pg helloworld.c

产生一个叫作a.out的执行文件，大小明显比用-g选项后产生的文件还大。





------------------------------------------------------------------------------------

*3. Gcc的错误类型及对策* **

 Gcc编译器如果发现源程序中有错误，就无法继续进行，也无法生成最终的可执行文件。为了便于修改，gcc给出错误资讯，我们必须对这些错误资讯逐个进行分析、处理，并修改相应的语言，才能保证源代码的正确编译连接。gcc给出的错误资讯一般可以分为四大类，下面我们分别讨论其产生的原因和对策。

*第一类∶C语法错误* **

*错误资讯∶文件source.c中第n行有语法错误(syntex
errror)。*这种类型的错误，一般都是C语言的语法错误，应该仔细检查源代码文件中第n行及该行之前的程序，有时也需要对该文件所包含的头文件进行检查。有些情况下，一个很简单的语法错误，gcc会给出一大堆错误，我们最主要的是要保持清醒的头脑，不要被其吓倒，必要的时候再参考一下C语言的基本教材。

*第二类∶头文件错误* **

错误资讯∶找不到头文件head.h(Can not find include file
head.h)。这类错误是源代码文件中的包含头文件有问题，可能的原因有头文件名错误、指定的头文件所在目录名错误等，也可能是错误地使用了双引号和尖括号。

*第三类∶档案库错误* **

错误资讯∶连接程序找不到所需的函数库，例如∶

ld: -lm: No such file or directory

这类错误是与目标文件相连接的函数库有错误，可能的原因是函数库名错误、指定的函数库所在目录名称错误等，检查的方法是使用find命令在可能的目录中寻找相应的函数库名，确定档案库及目录的名称并修改程序中及编译选项中的名称。

*第四类∶未定义符号* **

错误资讯∶有未定义的符号(Undefined
symbol)。这类错误是在连接过程中出现的，可能有两种原因∶*一是*使用者自己定义的函数或者全局变量所在源代码文件，没有被编译、连接，或者干脆还没有定义，这需要使用者根据实际情况修改源程序，给出全局变量或者函数的定义体；*二是*未定义的符号是一个标准的库函数，在源程序中使用了该库函数，而连接过程中还没有给定相应的函数库的名称，或者是该档案库的目录名称有问题，这时需要使用档案库维护命令ar检查我们需要的库函数到底位于哪一个函数库中，确定之后，修改gcc连接选项中的-l和-L项。

排除编译、连接过程中的错误，应该说这只是程序设计中最简单、最基本的一个步骤，可以说只是开了个头。这个过程中的错误，只是我们在使用C语言描述一个算法中所产生的错误，是比较容易排除的。我们写一个程序，到编译、连接通过为止，应该说刚刚开始，程序在运行过程中所出现的问题，是算法设计有问题，说得更玄点是对问题的认识和理解不够，还需要更加深入地测试、调试和修改。一个程序，稍为复杂的程序，往往要经过多次的编译、连接和测试、修改。

** [[http://blog.csdn.net/wae_gossip/article/details/8102614][ GetMemory(),运行Test 函数会有什么样的结果？]]    :blog:

题目：void GetMemory(char *p)
{
p = (char *)malloc(100);
}
void Test(void)
{
char *str = NULL;
GetMemory(str);
strcpy(str, "hello world");
printf(str);
}
请问运行Test 函数会有什么样的结果？
分析：程序崩溃。因为GetMemory 并不能传递动态内存，Test 函数中的 str 一直都是 NULL。strcpy(str, "hello world");将使程序崩溃。

题目：char *GetMemory(void)
{
char p[] = "hello world";
return p;
}
void Test(void)
{
char *str = NULL;
str = GetMemory();
printf(str);
}
请问运行Test 函数会有什么样的结果？
分析：可能是乱码。因为GetMemory 返回的是指向“栈内存”的指针，该指针的地址不是 NULL，但其原来的内容已经被清除，新内容不可知。

题目：void GetMemory(char **p, int num)
{
*p = (char *)malloc(num);
}
void Test(void)
{
char *str = NULL;
GetMemory(&str, 100);
strcpy(str, "hello");
printf(str);
}
请问运行Test 函数会有什么样的结果？
分析：
（1）能够输出hello
（2）内存泄漏

题目：void Test(void)
{
char *str = (char *) malloc(100);
strcpy(str, “hello”);
free(str);
if(str != NULL)
{
strcpy(str, “world”);
printf(str);
}
}
请问运行Test 函数会有什么样的结果？
分析：
篡改动态内存区的内容，后果难以预料，非常危险。
因为free(str);之后，str 成为野指针，if(str != NULL)语句不起作用。

** [[http://blog.csdn.net/hairetz/article/details/4141043][堆和栈的区别]]    :blog:

一、预备知识—程序的内存分配
  一个由C/C++编译的程序占用的内存分为以下几个部分
  1、栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。其
  操作方式类似于数据结构中的栈。
  2、堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回
  收   。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。
  3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的
  全局变量和静态变量在一块区域，   未初始化的全局变量和未初始化的静态变量在相邻的另
  一块区域。   -   程序结束后由系统释放。
  4、文字常量区   —常量字符串就是放在这里的。   程序结束后由系统释放
  5、程序代码区—存放函数体的二进制代码。


  二、例子程序
  这是一个前辈写的，非常详细
  //main.cpp
  int   a   =   0;   全局初始化区
  char   *p1;   全局未初始化区
  main()
  {
  int   b;   栈
  char   s[]   =   "abc";   栈
  char   *p2;   栈
  char   *p3   =   "123456";   123456/0在常量区，p3在栈上。
  static   int   c   =0；   全局（静态）初始化区
  p1   =   (char   *)malloc(10);
  p2   =   (char   *)malloc(20);
  分配得来得10和20字节的区域就在堆区。
  strcpy(p1,   "123456");   123456/0放在常量区，编译器可能会将它与p3所指向的"123456"
  优化成一个地方。
  }


  二、堆和栈的理论知识
  2.1申请方式
  stack:
  由系统自动分配。   例如，声明在函数中一个局部变量   int   b;   系统自动在栈中为b开辟空
  间
  heap:
  需要程序员自己申请，并指明大小，在c中malloc函数
  如p1   =   (char   *)malloc(10);
  在C++中用new运算符
  如p2   =   new   char[10];
  但是注意p1、p2本身是在栈中的。


  2.2
  申请后系统的响应
  栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢
  出。
  堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
  会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表
  中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的
  首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。
  另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部
  分重新放入空闲链表中。

  2.3申请大小的限制
  栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意
  思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有
  的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将
  提示overflow。因此，能从栈获得的空间较小。
  堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储
  的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小
  受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。



  2.4申请效率的比较：
  栈由系统自动分配，速度较快。但程序员是无法控制的。
  堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
  另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是
  直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。


  2.5堆和栈中的存储内容
  栈：   在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可
  执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈
  的，然后是函数中的局部变量。注意静态变量是不入栈的。
  当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地
  址，也就是主函数中的下一条指令，程序由该点继续运行。
  堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

  2.6存取效率的比较

  char   s1[]   =   "aaaaaaaaaaaaaaa";
  char   *s2   =   "bbbbbbbbbbbbbbbbb";
  aaaaaaaaaaa是在运行时刻赋值的；
  而bbbbbbbbbbb是在编译时就确定的；
  但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。
  比如：
  #include
  void   main()
  {
  char   a   =   1;
  char   c[]   =   "1234567890";
  char   *p   ="1234567890";
  a   =   c[1];
  a   =   p[1];
  return;
  }
  对应的汇编代码
  10:   a   =   c[1];
  00401067   8A   4D   F1   mov   cl,byte   ptr   [ebp-0Fh]
  0040106A   88   4D   FC   mov   byte   ptr   [ebp-4],cl
  11:   a   =   p[1];
  0040106D   8B   55   EC   mov   edx,dword   ptr   [ebp-14h]
  00401070   8A   42   01   mov   al,byte   ptr   [edx+1]
  00401073   88   45   FC   mov   byte   ptr   [ebp-4],al
  第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到
  edx中，再根据edx读取字符，显然慢了。


  2.7小结：
  堆和栈的区别可以用如下的比喻来看出：
  使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就
  走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自
  由度小。
  使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由
  度大。

** [[http://www.cnblogs.com/sunnyjones/archive/2008/10/31/1323438.html][在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”]]    :blog:

首先，作为extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。
通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数

extern "C"是连接申明(linkage declaration),被extern "C"修饰的变量和函数是按照C语言方式编译和连接的,来看看C++中对类似C的函数是怎样编译的：

作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：

void foo( int x, int y );



该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。

_foo_int_int 这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。

同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以"."来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。

未加extern "C"声明时的连接方式

假设在C++中，模块A的头文件如下：

// 模块A头文件  moduleA.h

#ifndef MODULE_A_H

#define MODULE_A_H

int foo( int x, int y );

#endif

在模块B中引用该函数：

// 模块B实现文件  moduleB.cpp

＃i nclude "moduleA.h"

foo(2,3);

    实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.obj中寻找_foo_int_int这样的符号！

加extern "C"声明后的编译和连接方式

加extern "C"声明后，模块A的头文件变为：

// 模块A头文件  moduleA.h

#ifndef MODULE_A_H

#define MODULE_A_H

extern "C" int foo( int x, int y );

#endif

在模块B的实现文件中仍然调用foo( 2,3 )，其结果是：

（1）模块A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用了C语言的方式；

（2）连接器在为模块B的目标代码寻找foo(2,3)调用时，寻找的是未经修改的符号名_foo。

如果在模块A中函数声明了foo为extern "C"类型，而模块B中包含的是extern int foo( int x, int y ) ，则模块B找不到模块A中的函数；反之亦然。

所以，可以用一句话概括extern “C”这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）：实现C++与C及其它语言的混合编程。

明白了C++中extern "C"的设立动机，我们下面来具体分析extern "C"通常的使用技巧：

extern "C"的惯用法

（1）在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理：

extern "C"

{

＃i nclude "cExample.h"

}

而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern "C"声明，在.c文件中包含了extern "C"时会出现编译语法错误。

C++引用C函数例子工程中包含的三个文件的源代码如下：

/* c语言头文件：cExample.h */

#ifndef C_EXAMPLE_H

#define C_EXAMPLE_H

extern int add(int x,int y);

#endif

/* c语言实现文件：cExample.c */

＃i nclude "cExample.h"

int add( int x, int y )

{

return x + y;

}

// c++实现文件，调用add：cppFile.cpp

extern "C"

{

＃i nclude "cExample.h"

}

int main(int argc, char* argv[])

{

add(2,3);

return 0;

}

如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern "C" {  }。

（2）在C中引用C++语言中的函数和变量时，C++的头文件需添加extern "C"，但是在C语言中不能直接引用声明了extern "C"的该头文件，应该仅将C文件中将C++中定义的extern "C"函数声明为extern类型。

C引用C++函数例子工程中包含的三个文件的源代码如下：

//C++头文件 cppExample.h

#ifndef CPP_EXAMPLE_H

#define CPP_EXAMPLE_H

extern "C" int add( int x, int y );

#endif

//C++实现文件 cppExample.cpp

＃i nclude "cppExample.h"

int add( int x, int y )

{

return x + y;

}

/* C实现文件 cFile.c

/* 这样会编译出错：＃i nclude "cExample.h" */

extern int add( int x, int y );

int main( int argc, char* argv[] )

{

add( 2, 3 );

return 0;

}

** [[http://blog.csdn.net/azhang00000/article/details/5357134][写出float x 与“零值”比较的if语句------一道面试题分析]]    :blog:

写出float  x 与“零值”比较的if语句

请写出 float x 与“零值”比较的 if 语句：
*const float EPSINON = 0.00001;*
*if ((x >= - EPSINON) && (x <= EPSINON)*
不可将浮点变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”此类形式。

EPSINON应该是一个很小的值吧
因为计算机在处理浮点数的时候是有误差的，所以判断两个浮点数是不是相同，是要判断是不是落在同一个区间的，这个区间就是
[-EPSINON,EPSINON]
EPSINON一般很小，10的-6次方以下吧，具体的好像不确定的，和机器有关

出处：[[http://topic.csdn.net/t/20041126/10/3590118.html]]

*[结论]
*浮点数等值比较使用下式：
#include
#include
fabs(a - b) < FLT_EPSILON

三个EPSILON：
FLT_EPSILON
DBL_EPSILON
LDBL_EPSILON


*为什么浮点数不能直接作“等值比较”？*
在以前看书或看文章就知道有这件事了。知道是因为“精度”，但一直没有真正想过问题的严重性。
今天在易自考www.ezikao.com.cn看到一个帖子，顺便搜索了一下，测试结果让我信服了这条规则：
易自考帖子：[[http://www.ezikao.com.cn/bbs_disp.asp?boardid=47&id=79506]]

以下内容引用自林锐《高质量C/C++代码编写指南》

#+BEGIN_QUOTE
  4.3.3 浮点变量与零值比较
  ? 【规则4-3-3】不可将浮点变量用“==”或“！=”与任何数字比较。
  千万要留意，无论是float还是double类型的变量，都有精度限制。所以一定要避免将浮点变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”形式。
  假设浮点变量的名字为x，应当将
  if (x == 0.0) // 隐含错误的比较
  转化为
  if ((x>=-EPSINON) && (x<=EPSINON))
  其中EPSINON是允许的误差（即精度）。
#+END_QUOTE




最好定义一个符号常量来做。#define EPSINON 1e-6


我想是因为浮点数表示范围大，如果一个数已经很小的时候，就可以认为是0了，epsinon嘛，limit，极限什么的。
也可以想一下，0.9无限循环不是等于1吗？
如果正好某个值等于0.9循环，浮点数只能给出一个“确定”的值，那就会“做错题”。

我想原理大约是这样的。具体的嘛，我还没有弄清楚 ：）

再经过搜索后，写下如下一段话：


好了，终于找到不完整的答案了。反正我是绝不会再将浮点数直接比较了：
参见帖子：http://blog.joycode.com/joe/archive/2004/12/07/40592.aspx

我参照这篇文章写了这个例子：
#include <stdio.h>
#include <stdlib.h>

main()
{
  float d1, d2, d3, d4;

  d1 = 194268.02;
  d2 = 194268;
  d4 = 0.02;

  d3 = d1 - d2;
  if (d3 > d4)
  printf(">0.02/n");
  else if (d3 < d4)
  printf("<0.02/n");
  else
  printf("=0.02/n");

  printf("%f - %f = %f /n", d1,d2,d3);

  system("pause");
}

*请看结果：*
<0.02
194268.015625 - 194268.000000 = 0.015625

即：194268.02 - 194268.0 不等于 0.02!
存进去的数居然会变！怕了吧？

4个变量改成double型的，再测试：
*这是结果*
<0.02
194268.020000 - 194268.000000 = 0.020000
明明是0.02啊，怎么还是小于？
这次没有改我存的数了吧？WHY？

我说，我怕了，以后我再不敢用浮点数直接作相等比较了！

还是那句话：*浮点数都是有精度限制的。*
所以你存的数，不一定就是你要的数。

虽然这件事很值得郁闷，不过我还是很高兴又知道了点东西。


*2005.10.10 晚继续更新*
关于EPSINON，可不是能随便定义的！
而且应该能想到，double和float的EPSINON是不同的。
定义成什么呢？不必你去定义了，ANSI C已经定义了这些常量：
载入头文件
#include
就可以引用

FLT_EPSILON
DBL_EPSILON
LDBL_EPSILON

几个常量了。

** [[http://blog.chinaunix.net/uid-23860671-id-150499.html][常指针和指向常量的指针 ]]    :blog:

1 常量指针！如 int b, c; int * const a = &b;
表示a是一个常量指针它指向变量b的内存。但是因为是常量指针所以不能再用a指向其他变量，如 a = &c; 错误！可以修改指向内存的值，如:*a = 20; BTW 常量指针声明的时候必须向我那样赋初值。

2 指向常量的指针！如 int b, c; int const *a; a = &b; a = &c;
都可以，唯独它指向的内存不能被修改。如：*a=20;这是违法的！错误！

这就是主要区别！

BTW 还有一个记住他们不同形式的技巧！看const关键字，他后面的不可修改，如int * const a = &b; 后面是a,则说明a不能修改！
int const * a = &b;后面是*a则说明*a不可被修改！

在好多书上或MSDN是经常用 const int a=5;
int b=6;
const int *p=&b;
其实 const int* 和int const* 一样，就是常指针 也就是它所指向的数据（在这是int）是常量，它自己的数据类型是const int*
还有const int *p=&b;是可以的 虽然b不是常量。
但是  const int a=6;
      int *p=&a;
会报错，因为它消除了a的const属性
**********************************************

*******我们可以总结一下********
1.  对于常量（符号常量）和常指针、常引用常对象声明都是一样的
定义格式： const 数据类型  常量名=常量值；
或  数据类型 const 常量名=常量值；

例如：const int a=7; 或 int const a=7;（符号常量）
  int b=5;
 const int *p=&b;  或 int const *p=&b;(常指针）
const int &m=b;（常引用）
const Point pt; 或 Point const pt; //常对象不能更新
常指针和常引用在功能上有所限制，就是不能通过他们更改其指向的变量的数据（值）

2. 指针常量
定义格式： 数据类型 *const 指针常量=常量值；
如char ch,*const pch=&ch;(我是一步完成的，你也可以分开）
也就是说这个指针本身是个常量，不可改变，即它所指向的地址是固定的。但，ch是可以改变的。

补充：
如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &引用名=目标变量名；
例1
int a ;
const int &ra=a;
ra=1; //错误
a=1; //正确
例2
string foo( );
void bar(string & s);
那么下面的表达式将是非法的：
bar(foo( ));
bar("hello world");
原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。
引用型参数应该在能被定义为const的情况下，尽量定义为const 。

** How to reduce PDF file size in Linux    :blog:


Using a single line of GhostScript command on my Ubuntu’s terminal, I was able to reduce the size of a  PDF file from 6 MB to approximately 1 MB:

gs -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -sOutputFile=output.pdf input.pdf

You can also use the following parameters for -dPDFSETTINGS instead of /screen:

/screen – Lowest quality, lowest size
/ebook – Moderate quality
/printer – Good quality
/prepress – Best quality, highest size

** [[http://seisman.info/merge-multiple-pdfs.html][Linux下合并PDF]]    :blog:

***** Contents

- [[#cpdf][cpdf]]
- [[#pdfunite][pdfunite]]
- [[#pdfjam][pdfjam]]
- [[#pdftk][pdftk]]
- [[#gs][gs]]
- [[#id3][参考]]
- [[#id4][修订历史]]

经常需要将多个PDF合并为一个文件，这里收集了网上给出的一些方案，并总结一下。

*推荐使用cpdf*

*** [[#id5][cpdf]]

[[http://community.coherentpdf.com/][cpdf]]全称是Coherent PDF Command
Line Tools，是一个强大的PDF处理工具。PDF合并只是它的一个功能之一。

#+BEGIN_EXAMPLE
    cpdf input1.pdf input2.pdf -o output.pdf
#+END_EXAMPLE

*** [[#id6][pdfunite]]

=pdfunite=
是[[http://poppler.freedesktop.org][Poppler]]提供的一个工具，一般系统都已经安装了Poppler，所以这个工具在Linux下是很常见的。

#+BEGIN_EXAMPLE
    pdfunite input1.pdf input2.pdf input3.pdf output.pdf
#+END_EXAMPLE

该命令用法简单，没有多余的选项，需要注意的是该命令的最后一个PDF文件为输出文件名。

*** [[#id7][pdfjam]]

如果你安装了TeXLive，并且安装了[[http://www.ctan.org/tex-archive/macros/latex/contrib/pdfpages/][pdfpage]]包，则其中包含了
=pdfjam= 工具。

#+BEGIN_EXAMPLE
    pdfjam input1.pdf input2.pdf input3.pdf -o output.pdf
#+END_EXAMPLE

该命令的选项很多，可以通过 =pdfjam --help= 查看。

=pdfjoin= 是 =pdfjam= 的一个封装，也可以直接使用:

#+BEGIN_EXAMPLE
    pdfjoin a.pdf b.pdf
#+END_EXAMPLE

*** [[#id8][pdftk]]

[[https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/][pdftk]]是专门用于处理PDF文档的一套工具。在大多数发行版中都可以直接安装使用。

#+BEGIN_EXAMPLE
    pdftk input1.pdf input2.pdf input3.pdf cat output output.pdf
#+END_EXAMPLE

pdftk的选项很多，用法复杂，可以参考[[http://seisman.info/introduction-to-pdftk.html][PDF合并和分割工具---PDFtk]] 。

*** [[#id9][gs]]

[[http://www.ghostscript.com][GhostScript]]不仅可以用于处理PS，也可以用于处理PDF文档。

#+BEGIN_EXAMPLE
    gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=out.pdf in1.pdf in2.pdf
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -dPDFSETTINGS=/prepress -sOutputFile=out.pdf in1.pdf in2.pdf
#+END_EXAMPLE

*** [[#id10][参考]]

- [[https://blog.dbrgn.ch/2013/8/14/merge-multiple-pdfs/]]
- [[http://stackoverflow.com/questions/2507766/merge-convert-multiple-pdf-files-into-one-pdf]]

** [[http://www.33lc.com/article/4013.html][Win7系统下硬盘安装Ubuntu 12.04双系统]]    :blog:



作者:佚名　来源:本站整理　发布时间:2012-08-24 14:26:46

本教程讲的是Win7下硬盘安装Ubuntu12.04双系统的方法。大家都知道，安装了双系统就有多种选择，这样不会疲劳，自己也可以随心所欲的看想要用哪个
系统~。好处肯定是有的，那么下面绿茶小编带大家去看看要怎么安装。

第一步、准备工作(在win7下操作完成)

1.下载镜像文件

                          +-------------------------------------------------------------------------------------+
                          |Ubuntu 64位(乌班图系统) v12.04.1 官方原版iso镜像 |http://www.33lc.com/soft/18055.html|
                          |-------------------------------------------------+-----------------------------------|
                          |Ubuntu(乌班图系统) v12.04.1 官方原版iso镜像      |http://www.33lc.com/soft/18053.html|
                          +-------------------------------------------------------------------------------------+

2.下载并安装easybcd。easybcd是一款很优秀的系统引导软件，功能强大，最关键的是傻瓜式一站式简易操作，极其适合新手使用!

3.腾出一个空盘，点击右键格式化之后把它删除(这个盘最好是在硬盘的后面，因为Windows系统不能识别Linux系统分区，如果将ubuntu装在D盘，将D盘删
除并建立Linux系统分区后，原来的E盘就会变成D盘，安装在E盘的软件会出现系统注册表路径不对称，要重新安装一遍软件)。网上很多说使用磁盘压缩功能以
整理出空白分区，这个方法也可行，但这个盘要保证有10G空间以上比较稳妥。

4.安装好easybcd2.1.2后，启动软件：

                                                                  Win7系

按照上图的序号依次点击“Add New Entry”——“Neo Grub”——“Install”，点到“Install”后出面下面的界面，再点“Configure”。

                                                                  Win7系

点击“Configure”按钮后，会出现一个记事本文件，将下面的代码粘贴到文件尾部：

title Install Ubuntu 12.04 LTS

root (hd0,6)

kernel (hd0,6)/vmlinuz boot=casper iso-scan/filename=/ubuntu-12.04-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8

initrd (hd0,6)/initrd.lz

如下图：

                                                                  Win7系

特别说明：

上图代码中“ubuntu-12.04-desktop-amd64.iso”为你下载的ubuntu 12.04系统镜像文件名，这个文件名是可以修改的，但修改的名字一定要与写入的代码名
字一致，否则将无法引导安装;

(hd0,6) 表示磁盘分区，hd(0,0), hd(0,1), hd(0,2), hd(0,3)表示主分区，(hd0,4)以后的表示逻辑分区，现在我只有一个主分区C盘，则(hd0,0)表示C盘
，(hd0,4)表示D盘，(hd0,5)表示E盘，(hd0,6)表示F盘，我的镜像就是放在F盘里，请把(hd0,6)改成自己对应的分区)

5.将下载的镜像文件放到(hd0,N)盘的根目录下，并确保文件名与上面写入的代码的文件名一致为ubuntu-12.04-desktop-amd64.iso，然后用WinRAR解压缩
软件将iso打开，将casper文件夹目录下的vmlinuz和 initrd.lz解压并复制到(hd0,N)盘根目录下。准备工作至此已全部完成!!!

** [[http://jingyan.baidu.com/article/f96699bb8b38e0894e3c1bef.html][]]    :blog:

百度经验:jingyan.baidu.com

工具/原料

  * JDK 1.7 安装包

百度经验:jingyan.baidu.com

步骤/方法

 1. 1

    想要成功配置Java的环境变量，那肯定就要安装JDK，才能开始配置的。

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=1][步骤阅读]]
 2. 2

    安装JDK 向导进行相关参数设置。如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=2][步骤阅读]]
    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=3][步骤阅读]]
 3. 3

    正在安装程序的相关功能，如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=4][步骤阅读]]
 4. 4

    选择安装的路径，可以自定义，也可以默认路径。如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=5][步骤阅读]]
 5. 5

    成功安装之后，进行测试是否真的成功安装，点击【开始】----【运行】----输入 CMD，在命令提示符里面输入“Java -version”并按回车键，出现下图，
    即为安装成功。如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=6][步骤阅读]]
    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=7][步骤阅读]]
    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=8][步骤阅读]]
 6. 6

    下面开始配置环境变量，右击【我的电脑】---【属性】-----【高级】---【环境变量】，如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=9][步骤阅读]]
 7. 7

    选择【新建系统变量】--弹出“新建系统变量”对话框，在“变量名”文本框输入“JAVA_HOME”,在“变量值”文本框输入JDK的安装路径（也就是步骤5的文件夹路
    径），单击“确定”按钮，如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=10][步骤阅读]]
 8. 8

    在“系统变量”选项区域中查看PATH变量，如果不存在，则新建变量 PATH，否则选中该变量，单击“编辑”按钮，在“变量值”文本框的起始位置添加
    “%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;”或者是直接“%JAVA_HOME%\bin;”，单击确定按钮，如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=11][步骤阅读]]
 9. 9

    在“系统变量”选项区域中查看CLASSPATH 变量，如果不存在，则新建变量CLASSPATH，否则选中该变量，单击“编辑”按钮，在“变量值”文本框的起始位置添
    加“.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;”。如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=12][步骤阅读]]
10. 10

    现在测试环境变量的配置成功与否。在DOS命令行窗口输入“JAVAC”，输出帮助信息即为配置正确。如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=13][步骤阅读]]
    END

** [[http://www.ctex.org/documents/latex/graphics/node59.html][在页眉和页脚使用图形]]    :blog:



在页眉和页脚使用图形的一个最容易的方法是使用 fancyhdr（它是旧的
fancyheadings 的增强版本）。 fancyhdr 的用法和宏包说明详见文献 [[[http://www.ctex.org/documents/latex/graphics/node119.html#fancyhdr][12]]]
。在 L^ATEX 文档中，页眉由左、中、右三部分组成。  \fancyhead 命令指
定了页眉的形式和内容，并以 L,C,R  区分左、中、右区域。例如：

\pagestyle{fancy}
\fancyhead[C]{我的文档}

使得页眉的中间部分印出`` 我的文档''，而

\pagestyle{fancy}
\fancyhead[L,R]{\textbf{Confidential}}

使得页眉的左右都印出``Confidential''。如果没有指定 L,C,R 中的任何一
个，那么由 \fancyhead 定义的内容将在三个区域中都会印出。相似地，\
fancyfoot 则用来定义页脚的左、中、右三个区域。可以利用 fancyhdr 宏
包中的命令来在页眉和页脚上使用图形。例如，在用第 [[http://www.ctex.org/documents/latex/graphics/node58.html#sec:defps][15.1]] 节的方法将
 EPS 文件 file.eps 分为 file.h 和 file.ps 后，下面的命令

\documentclass{article}
\usepackage{fancyhdr,graphicx}
\renewcommand{\headheight}{0.6in}% must be large enough for graphic
\renewcommand{\textheight}{7.5in}

% Define PostScript graphics command
\special{header=file.h}

% Save graphics in LaTeX box
\newsavebox{\mygraphic}
\sbox{\mygraphic}{\includegraphics[totalheight=0.5in]{file.ps}}
\pagestyle{fancy}
\fancyhead{} % clear all header fields
\fancyhead[L]{\usebox{\mygraphic}}
\fancyfoot{} % clear all footer fields
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\begin{document}
  ...
\end{document}

将图形放置在每一使用 ``fancy'' 风格页的左上角，并且下面有一条宽为
 0.5pt  的横线。此外，每页的页角的中央放置页码，但它的上方没有横线
。这些设置不会影响 ``plain'' 风格的页面。当使用 [twoside] 排版选项
时，经常希望在奇数页和偶数页设置不同页眉和页脚，这时可使用  O,E 选
项来区分奇数页和偶数页。如果没有给出  O,E 选项，则页眉和页脚的命令
会应用到所有的页面中，无论是奇数页还是偶数页。例如：

\pagestyle{fancy}
\fancyhead[LE]{我的文章}
\fancyhead[RO]{我的名字}
\fancyfoot[C]{\thepage}

在偶数页的左上角放置我的文章，在奇数页的右上角放置我的名字，页脚的
中央则放置页码。而命令

\pagestyle{fancy}
\fancyhead[LE,RO]{\usebox{\mygraphic}}
\fancyfoot[C]{\thepage}

使得偶数页的左上角和奇数页的右上角印出图形。 \fancyhead 命令只对那
些页面式样为 ``fancy'' 的页面起作用。即使用 \pagestyle{fancy} 将文
档的页面式样设置为 ``fancy'' 式样，一些页面，如封面，目录和每章的第
一页仍为缺省的 ``plain'' 式样。改变 Plain'' 页面式样的缺省设置可用
\fancypagestyle 命令来实现。例如将下面的命令加到上面的例子中可使得
封面，目录等的页眉上也将会有图形印出。

\fancypagestyle{plain}{%
  \fancyhead{} % clear all header fields
  \fancyhead[L]{\usebox{\mygraphic}}
  \fancyfoot{} % clear all footer fields
  \fancyfoot[C]{\thepage}
  \renewcommand{\headrulewidth}{0.5pt}
  \renewcommand{\footrulewidth}{0pt}}

当使用 [twoside] 排版选项时，将上面的

\fancyhead[L]{\usebox{\mygraphic}}

替换为

\fancyhead[LE,RO]{\usebox{\mygraphic}}

则在每一页的页眉上都放置上图形。

** [[http://jingyan.baidu.com/article/2f9b480db035e141cb6cc23e.html][9个 SSH常用命令选项]]    :blog:

*** SSH 是什么

SSH（全称 Secure
Shell)是一种加密的网络协议。使用该协议的数据将被加密，如果在传输中间数据泄漏，也可以确保没有人能读取出有用信息。要使用
SSH，目标机器应该安装 SSH 服务端应用程序，因为 SSH
是基于客户-服务模式的。 当你想安全的远程连接到主机，可中间的网络（比如因特网）并不安全，通常这种情况下就会使用
SSH。

安装 SSH

如果碰巧你的机器没装，我们可以手工来安装一下。最简单的方式就是使用 Linux
包管理器。

基于 Debian / Ubuntu 的系统 :

安装 ssh-client

$ sudo apt-get install openssh-client

安装 ssh-server

$ sudo apt-get install openssh-server

基于 RedHat / CentOS 的系统 :

# yum install openssh-server openssh-clients

SSH 一旦安装上，我们就可以在终端下输入 ssh 来检查下安装的是否正常。

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

*** 使用 SSH

提供了许多可使用的选项。这篇文章会介绍一些我们在日常操作中经常使用的选项。

1. 无选项参数运行 SSH

通常使用 SSH 的方式就是不加任何选项参数,仅仅输入 "ssh"。下面是示例：

$ ssh 192.168.0.103

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

第一次连接目标主机时，ssh
会让你确认目标主机的真实性。如果你回答的是 NO，SSH
将不会继续连接，只有回答 Yes才会继续。

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

下一次再登陆此主机时，SSH
就不会提示确认消息了。对此主机的真实验证信息已经默认保存在每个用户的
/home/user/.ssh 文件里。

2. 指定登陆用户

默认的，ssh 会尝试用当前用户作为用户名来连接。在上面的示例命令中，ssh
会尝试用用户名叫 pungki 的用户身份来登入服务器，这是因为用户 pungki
正在客户机上使用 ssh 客户端软件。

假如目标主机上没有叫 pungki
的用户呢？这时你就必须提供一个目标主机上存在的用户名。从一开始就要指定用户名的，可以使用
-l 选项参数。

$ ssh -l leni 192.168.0.103

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

我们也可以这样输入：

$ ssh leni@192.168.0.0103

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

3. 指定端口

SSH 默认使用的端口号是 22。大多现代的 Linux 系统 22
端口都是开放的。如果你运行 ssh 程序而没有指定端口号，它直接就是通过 22
端口发送请求的。

一些系统管理员会改变 SSH 的默认端口号。让我们试试，现在端口号是
1234.要连上那主机，就要使用 **-p* 选项，后面在加上 SSH 端口号。

$ ssh 192.168.0.103 -p 1234

要改变端口号，我们需要修改 /etc/ssh/ssh_config 文件，找到此行：

Port 22

把它换成其他的端口号，比如上面示例的 1234 端口，然后重启 SSH 服务。

4.对所有数据请求压缩

有了这个选项，所有通过 SSH
发送或接收的数据将会被压缩，并且任然是加密的。要使用 SSH
的压缩功能，使用 -C 选项。

$ ssh -C 192.168.0.103

如果你的连网速度很慢的话，比如用 modem
上网，这个选项非常有用。但如果你使用的是像 LAN
或其它更高级网络的话，压缩反而会降低你的传输速度。可以使用 -o 选项加上压缩级别参数来控制压缩的级别，但这个选项仅仅只在
SSH-1 下起作用。

5. 指定一个加密算法

SSH 提供了一些可用的加密算法。可以在 */etc/ssh/ssh_config or
~/.ssh/config * 文件中看到（如果存在的话）。

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

让我们试试比如你想使用 blowfish 算法来加密你的 SSH
会话，那么你只要把这一行加入你的/etc/ssh/ssh_config or
~/.ssh/config 文件就可以：

Cipher blowfish

默认的，SSH 会使用 3des 算法。

6. 打开调试模式

因为某些原因，我们想要追踪调试我们建立的 SSH 连接情况。SSH
提供的 -v 选项参数正是为此而设的。

$ ssh -v 192.168.0.103

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

7. 绑定源地址

如果你的客户端有多于两个以上的 IP 地址，你就不可能分得清楚在使用哪一个
IP 连接到 SSH 服务器。

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

为了解决这种情况，我们可以使用 -b 选项来指定一个IP 地址。这个 IP
将会被使用做建立连接的源地址。

$ ssh -b 192.168.0.200 -l leni 192.168.0.103

服务端，我们可以使用 netstat 命令来检查到服务的连接是否建立。可以看到 IP
为 192.168.0.200 的连接已经建立。

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

8. 使用其他配置文件

默认情况下，ssh
会使用位于 /etc/ssh/ssh_config 的配置文件。这个配置文件作用于系统的所有用户。但你想要为特定的用户指定特殊的设置的话，可以把配置放入 ~/.ssh/config 文件中。如果此文件不存在，可以手工创建一个。

下面是一个通用 ssh_config 文件配置的例子。这配置文件位于 /home/pungki 目录下。

Host 192.168.0.*
ForwardX11 yes
PasswordAuthentication yes
ConnectTimeout 10
Ciphers
aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc
Protocol 2
HashKnownHosts yes

要使用指定的配置文件，可以使用 -F 选项。

$ ssh -F /home/pungki/my_ssh_config 192.168.0.101

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

9. 使用 SSH X11 Forwarding

某些时候，你可能想把服务端的 X11 应用程序显示到客户端计算机上，SSH
提供了 -X 选项。但要启用这功能，我们需要做些准备，下面是它的设置：

在服务器端，你需要使 /etc/ssh/ssh_config 文件中的行设置成 ForwardX11
yes 或者 X11Forwad yes，以启用 X11 Forwarding，重启 SSH 服务程序。

然后在客户端，输入 ssh -X user@host:

$ ssh -X leni@192.168.0.101

一旦登陆，可以输入：

$ echo $DISPLAY

来检查，你应该可以看到向如下所示的

localhost:10:0

随后就可以运行应用了，仅仅只能输入应用程序的命令。让我们试试，比如想运行
xclock 程序，输入：

$ xclock

它就运行起来了，xclock
确实是运行在远端系统的，但它在你的本地系统里显示了。

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

** [[http://blog.csdn.net/reyleon/article/details/14000997][shuf 命令： 随机排序文件]]    :blog:


 有时候我们需要将文本的顺序打乱，也就是随机排序，我以前的做法是写个shell，利用
bash 里的内置变量 $RANDOM 进行排序，然后打印。代码如下：

#+BEGIN_EXAMPLE
     while read line;do echo $RANDOM $line; done < file | sort -n | sed 's/[^ ]\+ //'
#+END_EXAMPLE

    这里取了个巧而已。虽然也能实现需求，但是如果遇到大文件，本身 shell
的效率是很低的。偶然得知系统本身有一个命令是专职干这事儿的，那就是 shuf
命令，那效率，是杠杠滴啊。简单介绍下：

    1. 这个命令属于 coreutils 包，如果系统没有此命令，请 yum install
coreutils 进行安装。
     2. 它也能够接受标准输入，即管道
     参数：
         -n 最多显示多少行
          -o 将随机排序后的输出写到一个文件中
     更多信息请参考man页。



另外，今天发现用 *sort
-R*也可以随机排序，只是效率比shuf稍微慢一点儿！man sort 的解释如下：

#+BEGIN_EXAMPLE
           -R, --random-sort
                  sort by random hash of keys
#+END_EXAMPLE




2013.11.13 更新

1. 在centos 5.5下，sort版本为sort (GNU coreutils) 5.97，没有-R选项

2. 在centos 6.4下，sort版本为sort (GNU coreutils) 8.4，有-R选项。

3. shuf 和 sort命令同属于coreutils 包。

** [[http://blog.csdn.net/hansel/article/details/8736775][ Bash shell 的算术运算有四种方式]]    :blog:

Bash shell 的算术运算有四种方式:
1：使用 expr 外部程式

加法 r=`expr 4 + 5`
echo $r
注意! '4' '+' '5' 这三者之间要有空白
r=`expr 4 * 5` #错误
乘法 r=`expr 4 \* 5`

2：使用 $(( ))
r=$(( 4 + 5 ))
echo $r

3：使用 $[ ]

r=$[ 4 + 5 ]
echo $r

乘法
r=`expr 4 \* 5`
r=$(( 4 * 5 ))
r=$[ 4 * 5 ]
echo $r

除法
r=`expr 40 / 5`
r=$(( 40 / 5 ))
r=$[ 40 / 5 ]
echo $r

减法
r=`expr 40 - 5`
r=$(( 40 - 5 ))
r=$[ 40 - 5 ]
echo $r

求余数
r=$[ 100 % 43 ]
echo $r

乘幂 (如 2 的 3 次方)
r=$(( 2 ** 3 ))
r=$[ 2 ** 3 ]
echo $r
注：expr 没有乘幂

4：使用let 命令

变量和运算符直接不能有空格，否则要用引号括起。

加法：
n=10
let n=n+1
echo $n #n=11

乘法：
let m=n*10
echo $m

除法：
let r=m/10
echo $r

求余数：
let r=m%7
echo $r

乘幂：
let r=m**2
echo $r

虽然Bash shell 有四种算术运算方法，但并不是每一种都是跨平台的，建议使用expr。
另外，我们在 script 中经常有加1操作，以下四法皆可：
m=$[ m + 1]
m=`expr $m + 1`
m=$(($m + 1))
let m=m+1

** [[http://blog.csdn.net/jianchi88/article/details/7212370][Linux设备驱动--块设备（一）之概念和框架]]    :blog:



*基本概念 *

 *块设备（blockdevice）*

--- 是一种具有一定结构的*随机存取*设备，对这种设备的读写是按*块*进行的，他使用*缓冲*区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或者从设备一次性读到缓冲区。

*字符设备（Character device）*

---是一个*顺序的数据流*设备，对这种设备的读写是按*字符*进行的，而且这些字符是连续地形成一个数据流。他不具备缓冲区，所以对这种设备的读写*是实时的*。



*扇区(Sectors)：*任何块设备硬件对数据处理的基本单位。通常，1个扇区的大小为512byte。（对设备而言）

*块
(Blocks)：*由Linux制定对内核或文件系统等数据处理的基本单位。通常，1个块由1个或多个扇区组成。（对Linux操作系统而言）

*段(Segments)：*由若干个相邻的块组成。是Linux内存管理机制中一个内存页或者内存页的一部分。

页、段、块、扇区之间的关系图如下：

[[http://hi.csdn.net/attachment/201201/20/0_13270444482t2H.gif]]



*块设备驱动整体框架*

[[http://hi.csdn.net/attachment/201201/20/0_1327044749MMUm.gif]]

 块设备的应用在Linux中是一个完整的子系统。

在Linux中，驱动对块设备的输入或输出(I/O)操作，都会向块设备发出一个请求，在驱动中用*request结构体*描述。但对于一些磁盘设备而言请求的速度很慢，这时候内核就提供一种队列的机制把这些*I/O请求*添加到队列中（即：请求队列），在驱动中用*request_queue结构体*描述。在向块设备提交这些请求前内核会先执行请求的合并和排序预操作，以提高访问的效率，然后再由内核中的*I/O调度程序子系统*来负责提交
I/O 请求，
调度程序将磁盘资源分配给系统中所有挂起的块 I/O 请求，其工作是管理块设备的请求队列，*决定队列中的请求的排列顺序以及什么时候派发请求到设备*。

由通用块层(Generic Block
Layer)负责维持一个I/O请求在上层文件系统与底层物理磁盘之间的关系。在通用块层中，*通常用一个bio结构体来对应一个I/O请求*。

Linux提供了一个*gendisk数据结构体*，用来表示一个独立的磁盘设备或分区，用于对底层物理磁盘进行访问。在gendisk中有一个类似字符设备中file_operations的硬件操作结构指针，是*block_device_operations结构体*。

当多个请求提交给块设备时，执行效率依赖于请求的顺序。如果所有的请求是同一个方向（如：写数据），执行效率是最大的。内核在调用块设备驱动程序例程处理请求之前，先收集I/O请求并将请求排序，然后，*将连续扇区操作的多个请求进行合并以提高执行效率（内核算法会自己做，不用你管）*，对I/O请求排序的算法称为*电梯算法*（elevator
algorithm）。电梯算法在I/O调度层完成。内核提供了不同类型的电梯算法，电梯算法有

1 noop（实现简单的FIFO，基本的直接合并与排序）,
 2 anticipatory（延迟I/O请求，进行临界区的优化排序），
 3 Deadline（针对anticipatory缺点进行改善，降低延迟时间）,
 4 Cfq（均匀分配I/O带宽，公平机制）

PS：其实IO调度层（包括请求合并排序算法）是不需要用户管的，内核已经做好

*相关数据结构*

block_device:  描述一个分区或整个磁盘对内核的一个块设备实例
 gendisk:   描述一个通用硬盘（generic hard disk）对象。
 hd_struct:  描述分区应有的分区信息
 bio:
描述块数据传送时怎样完成填充或读取块给driver
 request:  描述向内核请求一个列表准备做队列处理。
 request_queue:  描述内核申请request资源建立请求链表并填写BIO形成队列。


** 百度云浏览PDF

使用网页版百度云浏览PDF效果挺不错的。

** org-mode evernote    :blog:

- why
  - 使用org-mode记笔记绝对要比evernote的编辑方便得多
  - org-mode支持babel、LaTeX等
  - 使用evernote阅读与同步则要比emacs友好得多
  - 顺便解决了本地HTML保存到EVERNOTE的问题
- how
  - org-mode记笔记
  - 使用org-ehtml和emacs-web-server，在浏览器端打开org文件
  - 使用悦读保存到Evernote中，不要使用剪藏，效果不好
- problems
  - 访问太慢，不知为何
  - 不支持图片

* Week
** 2016/01/21
*** openwrt                                                :openwrt:路由器:

- [[https://zh.wikipedia.org/wiki/OpenWrt][Wiki]]
- [[https://openwrt.org/][Homepage]]
- [[http://post.smzdm.com/p/99210/][树莓派&OpenWrt]]


1. what?

   基于 Linux 的开源路由器(应用于嵌入式的 Linux 发行版本)

2. history

   2003年底推出WRT-54G，是一款基于MIPS架构的无线路由器，并且使用
   802.11g标准使得带宽在理论上能够达到54M，在当时是一次巨大的成长。
   WRT-54G操作系统以Linux取代vXworks，哥伦比亚大学法学院教授Eben
   Moglen向Linksys提出开源要求。2003年7月，Linksys迫于压力，开源了
   WRT54G的firmware，不久sveasoft公司开发了Alchemy。从此无线路由器进入
   了可以刷机的时代。

3. application

   - 用于脱机离线下载。
   - VPN服务器。
   - SSH服务器。
   - Shadowsocks配合Pdnsd、Chinadns、Dnscrypt软件智能突破网络审查。
   - 动态DDNS。
   - 单线多拨及带宽叠加。
   - QOS智能限速（从石像鬼中提取）。
   - 远程视频监控。

*** tag 分类

标签的性质
1. 对象本身（普通）
2. 对象属性（普通）
3. 对象组件（普通）
4. 对象范畴 ： 大写
5. GTD 标签 ： 下划线开头的标签为特殊标签

需要定点提前准备东西的任务，打上 _preparation 的标签

** 2016/01/20
*** dpkg error                                                      :error:

https://www.ubuntu.org.cn/viewtopic.php?f=86&t=54689&p=2260127

1. error
   #+BEGIN_EXAMPLE
     ImportError: No module named 'ConfigParser'
     dpkg: 处理软件包 python-markupsafe (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     dpkg: 依赖关系问题使得 python-mako 的配置工作不能继续：
      python-mako 依赖于 python-markupsafe；然而：
       软件包 python-markupsafe 尚未配置。

     dpkg: 处理软件包 python-mako (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 依赖关系问题使得 gobject-introspection 的配置工作不能继续：
      gobject-introspection 依赖于 python-mako；然而：
       软件包 python-mako 尚未配置。

     dpkg: 处理软件包 gobject-introspection (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 依赖关系问题使得 libgirepository1.0-dev 的配置工作不能继续：
      libgirepository1.0-dev 依赖于 gobject-introspection (= 1.42.0-2.2)；然而：
       软件包 gobject-introspection 尚未配置。

     dpkg: 处理软件包 libgirepository1.0-dev (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 依赖关系问题使得 libpeas-dev 的配置工作不能继续：
      libpeas-dev 依赖于 libgirepository1.0因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
                               因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
                   由于已经达到 MaxReports 限制，没有写入 apport 报告。
                                                                       由于已经达到 MaxReports 限制，没有写入 apport 报告。
                                           由于已经达到 MaxReports 限制，没有写入 apport 报告。
               -dev (>= 0.10.1)；然而：
       软件包 libgirepository1.0-dev 尚未配置。

     dpkg: 处理软件包 libpeas-dev (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 处理软件包 python-oneconf (--configure)时出错：
      该软件包正处于非常不稳定的状态；
     您最好在配置它之前，先重新安装它
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     dpkg: 处理软件包 python-markupsafe (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     正在设置 python-oneconf (0.3.7.15.04.1) ...
     Traceback (most recent call last):
       File "/usr/bin/pycompile", line 35, in <module>
         from debpython.version import SUPPORTED, debsorted, vrepr, \
       File "/usr/share/python/debpython/version.py", line 24, in <module>
         from ConfigParser import SafeConfigParser
     ImportError: No module named 'ConfigParser'
     dpkg: 处理软件包 python-oneconf (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     dpkg: 依赖关系问题使得 software-center 的配置工作不能继续：
      software-center 依赖于 python-oneconf (>= 0.3) | oneconf (<< 0.3)；然而：
       软件包 python-oneconf 尚未配置。
     系统中 oneconf 的版本为 0.3.7.15.04.1。

     dpkg: 处理软件包 software-center (--configure)时出错：
      依赖关系问题 - 仍未被配置
     正在设置 youtube-dl (2015.02.28-1) ...
     因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
                                                                         Traceback (most recent call last):
       File "/usr/bin/pycompile", line 35, in <module>
         from debpython.version import SUPPORTED, debsorted, vrepr, \
       File "/usr/share/python/debpython/version.py", line 24, in <module>
         from ConfigParser import SafeConfigParser
     ImportError: No module named 'ConfigParser'
     dpkg: 处理软件包 youtube-dl (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     由于已经达到 MaxReports 限制，没有写入 apport 报告。
                                                         在处理时有错误发生：
      python-markupsafe
      python-oneconf
      software-center
      youtube-dl

   #+END_EXAMPLE

2. solution 1

   #+BEGIN_EXAMPLE
   sudo apt-get remove -f
   #+END_EXAMPLE

   无效

3. 终极暴力解法

   删除 */var/lib/dpkg/status* 中有关那个软件的安装信息
   和 */var/lib/dpkg/info* 目录下那个软件包的几个文件
   这个应该是 =终极方法= ，不过， *使用之前注意备份就是了*

   #+BEGIN_EXAMPLE
     wally@ info $ ls | grep youtube-dl
     youtube-dl.conffiles
     youtube-dl.list
     youtube-dl.md5sums
     youtube-dl.postinst
     youtube-dl.prerm
     wally@ info $ sudo find . -name "youtube-dl.*" -exec mv {} {}.20160120.1.bak \;
     wally@ info $ ls | grep youtube-dl
     youtube-dl.conffiles.20160120.1.bak
     youtube-dl.list.20160120.1.bak
     youtube-dl.md5sums.20160120.1.bak
     youtube-dl.postinst.20160120.1.bak
     youtube-dl.prerm.20160120.1.bak
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
      $ sudo apt-get -f install
     正在读取软件包列表... 完成
     正在分析软件包的依赖关系树
     正在读取状态信息... 完成
     下列软件包是自动安装的并且现在不需要了：
       libffi-dev linux-headers-3.19.0-15 linux-headers-3.19.0-15-generic linux-image-3.19.0-15-generic linux-image-extra-3.19.0-15-generic
     使用'apt-get autoremove'来卸载它(它们)。
     升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。
     有 4 个软件包没有被完全安装或卸载。
     解压缩后会消耗掉 0 B 的额外空间。
     正在设置 python-markupsafe (0.23-1) ...
     正在设置 python-oneconf (0.3.7.15.04.1) ...
     正在设置 software-center (13.10-0ubuntu6.1) ...
     正在设置 youtube-dl (2015.02.28-1) ...
   #+END_EXAMPLE

   测试 OK

*** [[http://askubuntu.com/questions/144905/virtualbox-windows-key-pass-through-to-gnome][VirtualBox 解除 win 键占用]]

1. 出发点

   使用 Ubuntu 时要经常使用 Win + Num 组合键在 Emacs，shell, Chrome 等
   窗口之间切换。当切换到虚拟机时，该组合键失效。

   Win+1 EmacS
   Win+2 Shell
   Win+3 Chrome
   Win+4 File
   Win+5 VirtualBox

   补充： 还有 Alt+Tab 键

2. 设置

   #+BEGIN_EXAMPLE
     Open the VirtualBox Manager window, and go to "File" menu,
     "Preferences" (Ctrl-G).
     Under "Input", uncheck the box labeled "Auto Capture
     Keyboard". There is no need to restart the VM if it's running, so
     this can be changed "on the fly".
   #+END_EXAMPLE

   #+DOWNLOADED: file:///home/wally/Desktop/2016-01-20%2015:12:44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png @ 2016-01-20 15:13:10
   [[~/Wally/Journal/Figure/.org-download/Tasks/2016-01-20%2015:12:44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2016-01-20_15:13:10.png]]

   Note: 在 Virtual Box 的管理窗口中，而不是虚拟机窗口中。

3. 测试 OK

*** .build 文件夹                                                   :trick:

1. 出发点

   从源码编译安装的软件或库一般都完成后删除。这样节省存储空间，并不是
   最优的。

   因为有的时候需要使用 make 的其他选项
   - 最常用的是 unintall (dpkg 对源码安装的软件无效)
   - 其次，make doc, 比如 PCL 库的 doxygen 文档

2. trick

   建立 $HOME/.build 目录，用来
   1) 临时存放源码
   2) 暂存编译安装信息
   3) 定期确认并清理

*** HTML 参考文档                                                   :trick:

1. 出发点

   PDF 是我最喜欢的文档格式，可视化良好，恰到好处的可编辑功能。

   HTML 文件是 Doxygen 生成文档可视化最好的格式，但在线看往往不方便，
   也不能使用 org-mode 建立链接或索引。

2. 在 Referece/HTML 文件夹下保存所有 HTML 格式的参考文档

*** org-tag-view

搜索标签常用。

绑定在 C-c a m 太慢

#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "<f12>") 'org-tags-view)
#+END_SRC
** 2016/01/18
*** blender

- [[https://www.blender.org/manual/zh.cn/getting_started/index.html][Blender 官方入门教材（中文）]]
- [[https://zh.wikibooks.org/zh-cn/Blender_3D%EF%B8%B0%E5%BE%9E%E5%85%A5%E9%96%80%E5%88%B0%E7%B2%BE%E9%80%9A][Blender 3D︰从入门到精通(wikibook)]]
- [[http://wiki.blender.org/][Homepage]]

*** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

*** PCL

#+include: ~/Wally/Project/pcl_tutorials

http://www.pointclouds.org/documentation/tutorials/

**** [[http://www.pointclouds.org/documentation/tutorials/basic_structures.php#basic-structures][Basic Structure]]

*PointCloud*

- width
- height
- points
- is_dense
- sensor_origin
- senor_orientation

To simplify development, the PointCloud class contains a number of
helper member functions. For example, users don’t have to check if
height equals 1 or not in their code in order to see if a dataset is
organized or not, but instead use *PointCloud()*:

#+BEGIN_SRC cpp
if (!cloud.isOrganized ())
#+END_SRC

***** writing point cloud data to PCD files

#+include: ~/Wally/Project/pcl_tutorials/src/pcd_write.cpp

头文件位置 =/usr/include/pcd-1.7/pc/=

#+BEGIN_SRC cpp
#include <pcl-1.7/pcl/io/pcd_io.h>
#include <pcl-1.7/pcl/point_types.h>
#+END_SRC

创建 link

#+BEGIN_EXAMPLE
 ~ $ ls -l /usr/include/pcl
lrwxrwxrwx 1 root root 24  1月  7 09:53 /usr/include/pcl -> /usr/include/pcl-1.7/pcl
#+END_EXAMPLE

***** CMakeLists.txt

#+include: ~/Wally/Project/pcl_tutorials/CMakeLists.txt

**** [[http://www.pointclouds.org/documentation/tutorials/voxel_grid.php#voxelgrid][Downsampling a PointCloud using a VoxelGrid filter]]


- *downsample*: reduce the number of points
- using a *voxelized grid* approach

#+include: ~/Wally/Project/pcl_tutorials/src/voxel_grid.cpp

**** Merging PCDs
***** concatenate the points of two points clouds

http://pointclouds.org/documentation/tutorials/concatenate_clouds.php

#+include: ~/Wally/Project/pcl_tutorials/src/concatenate_clouds.cpp

** 2016/01/17
*** scratch                                                       :scratch:

**** intro                                                         :intro:

Scratch是麻省理工大学媒体实验室终身幼稚园组开发的一套电脑程序开发平台，
旨在让程序设计语言初学者不需先学习语言语法便能设计创作产品。开发者期望
通过学习Scratch，启发和激励用户在愉快的环境下通过实验（如设计交互故事）
去学习程序设计、数学和计算知识，同时获得创造性的思考，系统推理，和协同
工作的体验。

Scratch 开发平台可安装在Mac OS X、Windows、Linux的平台上；自2.0之后，
换用Actionscript编制，Scratch运行于浏览器。Scratch源码开放给非商业性质
用途使用。


#+DOWNLOADED: https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Scratchcat.svg/180px-Scratchcat.svg.png @ 2016-01-18 11:17:22
 [[~/Wally/Journal/Figure/.org-download/Journal/180px-Scratchcat.svg_2016-01-18_11:17:21.png]]

**** keyword                                                     :keyword:

scratch, MIT, 教育软件， 跨平台， 开源

**** reference                                                  :homepage:

- [[https://zh.wikipedia.org/wiki/Scratch%E8%AF%AD%E8%A8%80][Wikipedia: scratch 语言]]
- [[https://scratch.mit.edu/][Homepage]]
- [[http://cacm.acm.org/magazines/2009/11/48421-scratch-programming-for-all/fulltext][Scratch: Programming for All]]

*** godot                                                           :godot:

**** reference                                                  :homepage:

- [[http://www.godotengine.org/projects/godot-engine][Homepage]]
- [[https://github.com/godotengine/godot][Github]]

**** intro                                                         :intro:

Godot is a fully featured, open source, MIT licensed, game engine. It
focuses on having great tools, and a visual oriented workflow that can
export to PC, Mobile and Web platforms with no hassle. The editor,
language and APIs are feature rich, yet simple to learn, allowing you
to become productive in a matter of hours.

[[/home/wally/Wally/Journal/Figure/scrot/32504Cqi.png]]


开源游戏引擎

*** ccmake intro                                             :ccmake:intro:

- [[http://blog.csdn.net/arackethis/article/details/42155589][CMake 和 CCMake 的区别]]

CCMake is the GUI for manipulating files generated by / used by the
cmake system.

- ccmake is curses (terminal handling library) interface to CMake.

- cmake is the CLI (Command Line Interface)
*** metapost

http://www.ctex.org/documents/shredder/metapost.html

http://www.ctex.org/documents/shredder/metapostexample.html

*** emacs gif                                                         :gif:

**** record gif

- [[http://emacs.stackexchange.com/questions/798/recording-a-gif-screencast-of-emacs][stackexchange:Recording a GIF screencast of Emacs ]]
- [[https://github.com/Malabarba/camcorder.el][Github: camcorder.el]]


1. To use it, simply call *M-x camcorder-record*
2. A new smaller frame will popup and recording starts.
3. When you’re finished, hit *F12*.

View screencasts are generated in *ogv* format, and you can even pause
the recording with *F11*! You can also convert the .ogv file to a gif
by issuing the command *M-x camcorder-convert-to-gif*

后台程序

1. 录制
   - recordmydesktop
   - ffmpeg
   - mplayer & imagemagick

2. 转换
   - ffmpeg
   - mplayer & imagemagick

**** view gif

- https://github.com/Fuco1/org-inline-image

#+BEGIN_SRC emacs-lisp
  (require 'org-inline-image)
#+END_SRC

not work 没细看

*** blender dae

**** solutions

http://blender.stackexchange.com/questions/160/can-blender-export-to-the-collada-format

***** ppa

https://launchpad.net/~irie/+archive/blender

#+BEGIN_EXAMPLE
  Installing from the PPA:
  Add the PPA: ppa:irie/blender (sudo add-apt-repository ppa:irie/blender)
  Update your sources (Ubuntu Software Center does this automatically, but you will need to do it manually if adding from the command line). (sudo apt-get update)
  Install blender (this package is 2.6x from git) (sudo apt-get install blender)
#+END_EXAMPLE

http://askubuntu.com/questions/169542/how-do-i-install-the-latest-blender-3d-builds-from-a-ppa

#+BEGIN_EXAMPLE
And now that Irie PPA is not updated anymore, to get the latest version (updated weekly), you can use this instead:

sudo add-apt-repository ppa:thomas-schiex/blender
sudo apt-get update
sudo apt-get install blender
#+END_EXAMPLE

***** plugin

http://sourceforge.net/projects/colladablender/

the above link points to a blender 2.49 script. it will not work with recent Blender versions!

***** compile

#+BEGIN_EXAMPLE
 WITH_OPENCOLLADA                 ON
#+END_EXAMPLE

****** git clone

https://developer.blender.org/diffusion/B/

#+BEGIN_EXAMPLE
# read-only access
git clone git://git.blender.org/blender.git

# read/write access
git clone git@git.blender.org:blender.git

cd blender
git submodule update --init --recursive
git submodule foreach git checkout master
git submodule foreach git pull --rebase origin master
#+END_EXAMPLE

****** build

http://wiki.blender.org/index.php/Dev:Doc/Building_Blender

ccmake

#+BEGIN_EXAMPLE
  home/wally/Download/blender/source/blender/imbuf/intern/openexr/openexr_api.cpp
  fatal error: ImfMultiView.h: 没有那个文件或目录
   #include <ImfMultiView.h>
#+END_EXAMPLE

- openexr :: command-line tools and docs for the OpenEXR image format
- openexr-viewers :: viewer for images in the OpenEXR format

apt-get 方式安装相应软件后依然存在错误。


https://github.com/openexr/openexr

装这个更加烦人，编译半天一堆错误。

**** test

#+BEGIN_EXAMPLE
fake_module: addon missing 'bl_info' gives bad performance!: '/usr/share/blender/scripts/addons/colladaExport14.py'
#+END_EXAMPLE

**** plugin


***** 配置数据路径

https://www.blender.org/manual/zh.cn/getting_started/installing_blender/directorylayout.html

Blender使用了三种不同的文件夹，它们是跟操作系统有关系的。

- 本地 :: 配置和运行时数据位置（只供自己绑定使用）

- 用户 :: 配置文件位置（通常情况下在用户的家文件夹下）

- 系统 :: 系统级安装后的运行时数据位置（可能是只读的）。

系统级安装 *系统* 和 *用户* 文件夹都是需要的。

如果是本地解压Blender的发行版，这些用户配置数据和运行时数据都在一个子
文件夹下面，允许Blender的多个版本共存而且不会有冲突，可以忽略

*用户* 和 *系统* 文件。

注解

注解：你有可能需要确保你的文件管理器中，显示隐藏文件的选项已经被勾选。

****** 基于不同平台的路径

下面是各个系统的默认文件夹位置：

******* Linux

- 本地 ::
  #+BEGIN_EXAMPLE
      ./2.76/
  #+END_EXAMPLE

- 用户 ::
  #+BEGIN_EXAMPLE
      $HOME/.config/blender/2.76/
  #+END_EXAMPLE

  # $ ls .config/blender/2.72/
  # config  scripts

- 系统 ::
  #+BEGIN_EXAMPLE
      /usr/share/blender/2.76/
  #+END_EXAMPLE

注解

该路径./2.76/是相对于Blender可执行文件以及用于自包含官方blender.org构建发布软件包。

注解

The *USER* path will use =$XDG_CONFIG_HOME= if its set:

#+BEGIN_EXAMPLE
    $XDG_CONFIG_HOME/blender/2.76/
#+END_EXAMPLE

******* Mac OSX

- 本地 :: #+BEGIN_EXAMPLE
       ./2.76/
   #+END_EXAMPLE

- 用户 :: #+BEGIN_EXAMPLE
       /Users/$USER/Library/Application Support/Blender/2.76/
   #+END_EXAMPLE

- 系统 :: #+BEGIN_EXAMPLE
       /Library/Application Support/Blender/2.76/
   #+END_EXAMPLE

注解

OSX 存储blender二进制文件，放在 ‘./blender.app/Contents/MacOS/blender
‘，所以数据及配置的本地路径是:

#+BEGIN_EXAMPLE
    ./blender.app/Contents/MacOS/2.76/
#+END_EXAMPLE

******* MS-Windows

- 本地 :: #+BEGIN_EXAMPLE
       .\2.76\.
   #+END_EXAMPLE

- 用户 :: #+BEGIN_EXAMPLE
       C:\Documents and Settings\$USERNAME\AppData\Roaming\Blender Foundation\Blender\2.76\
   #+END_EXAMPLE

- 系统 :: #+BEGIN_EXAMPLE
       C:\Documents and Settings\All Users\AppData\Roaming\Blender Foundation\Blender\2.76\
   #+END_EXAMPLE

****** 路径布局

下面的路径布局是以上的文件夹描述规范。

‘./Config/startup.blend ‘ 可能在哪里 ~/.blender/[[#id1][|例如
BLENDER_VERSION|]]/config/startup.blend。

- =./autosave/ ...= :: 自动保存混合文件位置。* Windows
   只，临时目录用于其他 systems.*

   搜索顺序: =LOCAL, USER=.

- =./config/ ...= :: 默认值与会话信息。

   搜索顺序: =LOCAL, USER=.

- =./config/startup.blend= :: 载入初始文件和用户设置

- =./config/userpref.blend= :: 载入初始文件和用户设置

- =./config/bookmarks.txt= :: 在文件选择器中隐藏系统书签

- =./config/recent-files.txt= :: 在文件管理器中隐藏最近查看的路径

- =./datafiles/ ...= :: 运行时文件

   搜索顺序: =LOCAL, USER, SYSTEM=.

- =./datafiles/locale/{language}/= :: 用户界面翻译的静态预编译的语言文件。

- =./datafiles/icons/*.png= :: Blender用户界面的图标主题。*
   不目前可选的主题 preferences.*

- =./datafiles/brushicons/*.png= :: 对于每个画笔的图像。

- =./scripts/ ...= :: Python 脚本的用户界面和工具。

   搜索顺序: =LOCAL, USER, SYSTEM=.

- =./scripts/addons/*.py= :: Python
   加载项在用户首选项，可以使包括导入/导出格式支持、
   渲染引擎集成和许多方便实用。

- =./scripts/addons/modules/*.py= :: 模块的加载项的使用 (添加到 Python
   的 sys.path)。

- =./scripts/addons_contrib/*.py= :: 另一个加载项目录是用于社区维护的插件
   (必须手动创建)。

- =./scripts/addons_contrib/modules/*.py= :: 对 addons_contrib 的模块
   (添加到 Python 的 sys.path) 的使用。

- =./scripts/modules/*.py= :: 包含我们的核心 API 和其他脚本到效用函数的
   Python 模块导入 (添加到 Python 的 ‘sys.path ‘)。

- =./scripts/startup/*.py= :: 在启动时将自动导入的脚本。

- =./scripts/presets/{preset}/*.py= :: 预设用于存储用户定义设置布、
   呈现格式等。

- =./scripts/templates/*.py= :: 可以从访问的示例脚本:
   文本空间标题-->--> 脚本模板的文本。

- =./python/ ...= :: 捆绑的 Python 发行版，不仅是必要的系统安装的
   Python 时缺席或不兼容。

   搜索顺序: =LOCAL, SYSTEM=.


***** 插件--NGENNGT翻译

https://www.blender.org/manual/zh.cn/advanced/scripting/python/add_ons.html

/插件/ 是对扩展Blender功能的脚本的通用术语。在 /用户设置/ 窗口的 /插件/
标签页找到这些脚本，在该标签页下可以搜索、安装、启用和禁用 插件。

****** 搜索

Blender自带一些好用的插件，你可以自行启用。不过你也可以添加你自己的或者从网上找到的有趣插件。


#+DOWNLOADED: https://www.blender.org/manual/zh.cn/_images/user_prefs-addons_tab.png @ 2016-01-18 11:47:34
 [[~/Wally/Journal/Figure/.org-download/Journal/user_prefs-addons_tab_2016-01-18_11:47:33.png]]

用户设置窗口中的插件标签页

[[http://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts][脚本目录]]
提供了Blender自带插件索引，同时也列出了许多外部插件。

****** 启用和禁用

如图所示，勾选或取消勾选插件右侧的复选框即可启用或禁用该插件。


#+DOWNLOADED: https://www.blender.org/manual/zh.cn/_images/Extensions-Python-Addons-EnabledAddOn.jpg @ 2016-01-18 11:47:56
 [[~/Wally/Journal/Figure/.org-download/Journal/Extensions-Python-Addons-EnabledAddOn_2016-01-18_11:47:55.jpg]]

启用插件

启用插件功能可以即时生效。 如果启用后插件未激活， 可以在 [[../../../interface/window_system/console_window.html][/控制台窗口/]]
查看发生的错误。

单击插件左侧的箭头可以查看更多信息，如插件存放位置、描述和文档链接，你
还可以通过“报告Bug”按钮报告该插件的bug。


小技巧

保存插件设置

如果想要插件随Blender打开同时启用，你需要 /保存用户设置/ 。

****** 安装第三方插件

对于网络下载的或你自己的插件，需要单击 /从文件安装.../ 并选择 .zip 或
.py文件安装后，才能在插件列表中显示该插件。

或者你还可以手动安装插件，这在开发自己的插件过程中很有用。

直接将文件移动或链接至 =../scripts/addons= 文件夹(你的Blender文件夹配
置路径).

[[/home/wally/Wally/Journal/Figure/scrot/2380aff.png]]

****** 文件位置

关于Blender目录信息详见 [[../../../getting_started/installing_blender/directorylayout.html][/配置& 数据路径/]]。

你还可以新建个人插件目录，并在 /用户设置/ 中的 /文件/
面板配置该路径。新建一个个人脚本文件夹：

- 新建一个空文件夹 (如'script_addon_2-7x')

- 在该文件夹下添加一个 ‘addons'
   文件夹，只有这样命名Blender才能正确识别。

- 将你的新插件置于该 ‘addons' 文件夹。

- 打开 /用户设置/ 的 /文件/ 面板。

- 在 /脚本/ 路径中选择你的脚本文件夹路径 (如 ‘script_addon_2-7x')。

****** 开发指南

如果你是一个脚本开发人员，你可能对 [[http://wiki.blender.org/index.php/Dev:2.5/Py/Scripts/Guidelines/Addons][插件开发指南]] 感兴趣。

**
*** Linux
**** [[https://mp.weixin.qq.com/mp/appmsg/show?__biz=MzA3MzAwMjAxMQ==&appmsgid=10000009&itemidx=1&sign=c926ff23def356a4a0f2ed7141c466d6&scene=1&srcid=0118jxrIABVW8XwWSGpkpoJd&pass_ticket=8B57gmAPihhXDqY3DNHOKiG9154WT42aR6KFVbb%2FAFpL7bBsnVOOoPubYSkLb3iH][当你想放弃时，看看这幅漫画！]] :责任:

[[/home/wally/Wally/Journal/Figure/scrot/32504b9n.png]]

这篇东西转自一位有思想的研究生！她看到这篇漫画，觉得很不错，我看后也觉
得值得我们思考，尤其是当我们抱怨时！

[[/home/wally/Wally/Journal/Figure/scrot/32504oHu.png]]

第一幅漫画中，每个人都背负着一个沉重的十字架，在缓慢而艰难地前行！

[[/home/wally/Wally/Journal/Figure/scrot/325041R0.png]]

途中，有一个人忽然停了下来。他在想着什么！

[[/home/wally/Wally/Journal/Figure/scrot/32504nbD.png]]

他想，上帝啊，这个十字架太沉重了，我可以把十字架砍掉一块！

[[/home/wally/Wally/Journal/Figure/scrot/325040lJ.png]]

于是他动手砍了起来！

[[/home/wally/Wally/Journal/Figure/scrot/32504BwP.png]]

砍掉之后走起来，的确是轻松了很多，他的步伐也不由得加快了。

[[/home/wally/Wally/Journal/Figure/scrot/32504oOi.png]]

就这样走啊走啊！走着走着，他觉得肩上的十字架还是很沉，很重！

[[/home/wally/Wally/Journal/Figure/scrot/325041Yo.png]]

他祈求道，上帝啊，请你让我再砍掉一截吧，我会走得更轻松！

[[/home/wally/Wally/Journal/Figure/scrot/32504Cju.png]]

于是，他又砍掉了一截！感谢上帝，这样一来，他感到轻松多了！

[[/home/wally/Wally/Journal/Figure/scrot/32504Pt0.png]]

如此，他毫不费力地就走到了队伍的最前面。当其他人在吃力地负重前行时，他
却轻松地哼起了小曲！

[[/home/wally/Wally/Journal/Figure/scrot/32504B3D.png]]

啊哈!谁料，前边忽然出现了一个又深又宽的沟壑！沟上没有桥，周围
也没有路。也没有蜘蛛侠或者超人出来解救他…

[[/home/wally/Wally/Journal/Figure/scrot/32504bLQ.png]]

后面的人都慢慢地赶上来了，他们用自己背负的十字架搭在沟上，做成桥，从容
不迫地跨越了沟壑。

[[/home/wally/Wally/Journal/Figure/scrot/32504oVW.png]]

他也想如法炮制。只可惜啊，他的十字架之前已经被砍掉了长长的一大截，根本
无法做成桥帮助他跨越沟壑！

[[/home/wally/Wally/Journal/Figure/scrot/325041fc.png]]

于是，当其他人都在朝着目标继续前进时，他却只能停在原地，垂头丧气，追悔
莫及……

每个人都背负着属于自己的十字架，的确是这样，漫画中的每个人，都是背负着
属于自己的十字架，而当沟壑出现时，他们也只能利用自己背负的十字架去跨越
沟壑，继续前进。

所以：在人生的道路上，有些黑暗，只能自己穿越；有些痛苦，只能自己体验；
有些孤独，也只能自己品尝……人生是没有捷径的！

**** [[http://daily.zhihu.com/story/4573178?utm_campaign=in_app_share&utm_medium=Android&utm_source=Weixin&from=timeline&isappinstalled=0][哪些习惯能让生活变得简洁高效？]] :知乎:习惯：极简主义:

个人现状是处在三条规则，距离一条规则完全保持简约的生活方式还要努力几年时间。

***** 让生活变得简洁而高效只需要一条规则

就是照管好自己，保持一种简约的生活方式, 控制好自己的内心，从加法生活过
度到减法生活。

***** 如果觉得这一点说的太简单，就可以扩展成三条

*第一条：应用好 80/20原则*

把这个法则用在生活的各个方向中，把时间和精力放到自己擅长事情和主要目标
上，比如工作、家庭、友情、爱好、情绪，提高生活的质量和稳定

*第二条：做好精力管理，保持稳定而规律的生活方式：*

应该根据自己的精力进行安排和调整生活，周期性地补充精力，来平衡精力消耗。
需要对你的精力进行海战略性的规划和应用，并把它当成一种习惯。

人们的精力有4种来源，身体的、情感的、思想的和精神的，这4种精力资源需要
在消耗和储备之间取得平衡才能保证不会枯竭。


*第三条、 控制过度消费和物质过剩*

最初从减少选择开始，然后是学会丢东西，最成功的一次是用几个月时间丢掉了
50种不同类型的东西，包括当时的工作和26斤体重，整个生活立刻就简单了很多，
但距离断舍离的要求还有差距：

断舍离”是指：

断 = 不买、不收取不需要的东西

舍 = 处理掉堆放在家里没用的东西

离 = 舍弃对物质的迷恋，让自己处于宽敞舒适，自由自在的空间。


选择物品时不是“能不能用”，而是“我要不要用”。

扩展阅读：

- [[http://www.read.org.cn/html/1386-reduce-the-choice-to-let-you-save-time.html][减少选择让你节省时间]]
- 《丢掉50样东西，找回100分人生》读书笔记
   --[[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200035644&itemidx=1&sign=6f0cd694354b3f75b757e41bc93b767b][warfalcon]]
- 进阶时看《断舍离》 [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000734&itemidx=1&sign=31ac402a40a351bf6823237d2d020057][warfalcon]]


***** 觉得这三条还是太难，那继续扩展成九条

只要减少这九类时间黑洞，生活中就会简约高效


*1、减少网络黑洞时间：*

每个人都离不网络，而网络上的无效时间黑洞是最多的：

不看新闻：

- *时间管理之新闻阅读*[[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000055&itemidx=1&uin=MjU4MjUyNzM2MA%3D%3D&key=79cf83ea5128c3e59a05178691cc0d51487d45a3b3704ccaa2340ff568d898b089e6e31cf75c6a261042289e859b66c0&devicetype=android-10&version=25000338&lang=zh_CN&pass_ticket=1V0MbhKBMhjP%2BE4eiEonppyltegkgcZRy%2F%2FCxeKJlauehqow4jLPOnbhMpyI0xCB#wechat_webview_type=1#wechat_redirect&From=test][warfalcon]]**
- 你是在掌控新闻还是被新闻所掌控？
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200791870&itemidx=1&sign=77679932e20ecb28fa3ae6c26f653caf&scene=4&uin=MjU4MjUyNzM2MA%3D%3D&key=79cf83ea5128c3e59a05178691cc0d51487d45a3b3704ccaa2340ff568d898b089e6e31cf75c6a261042289e859b66c0&devicetype=android-10&version=25000338&lang=zh_CN&pass_ticket=1V0MbhKBMhjP%2BE4eiEonppyltegkgcZRy%2F%2FCxeKJlauehqow4jLPOnbhMpyI0xCB#wechat_webview_type=1#wechat_redirect&uin=MjU4MjUyNzM2MA%3D%3D&key=79cf83ea5128c3e59a05178691cc0d51487d45a3b3704ccaa2340ff568d898b089e6e31cf75c6a261042289e859b66c0&devicetype=android-10&version=25000338&lang=zh_CN&pass_ticket=1V0MbhKBMhjP%2BE4eiEonppyltegkgcZRy%2F%2FCxeKJlauehqow4jLPOnbhMpyI0xCB#wechat_webview_type=1#wechat_redirect&uin=MjU4MjUyNzM2MA%3D%3D&key=79cf83ea5128c3e59a05178691cc0d51487d45a3b3704ccaa2340ff568d898b089e6e31cf75c6a261042289e859b66c0&devicetype=android-10&version=25000338&lang=zh_CN&pass_ticket=1V0MbhKBMhjP%2BE4eiEonppyltegkgcZRy%2F%2FCxeKJlauehqow4jLPOnbhMpyI0xCB#wechat_webview_type=1#wechat_redirect&From=test][warfalcon]]
- 为什么你不应该读新闻
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200781923&itemidx=1&sign=96c0608f4ab861aac6271cf737d334ae][warfalcon]]

微信篇：

- 除非工作需求，否则每天集中查看三到四次微信，每次10分钟集中回复。
- 关闭微信朋友圈
- 定期退出无用的微信群
- 取消和关闭所有微信通知，否则微信的通知会不断的弹出信息来干扰和打断你

QQ篇：

1. 除非工作需求，否则一、二天登陆一次QQ
2. 定期评估并退出QQ群
3. 并关闭各种广告及提示。

邮件篇：
*[[http://www.read.org.cn/html/1986-shi-jian-guan-li-zhi-jian-chu-li-1-hai-liang-jian-chu-li.html][时间管理之邮件处理（1）海量邮件处理]]
*

*2、减少请求黑洞：*

学会拒绝工作和生活中各种要求，能减少大量的时间

要根据实际情况对要求做出判断。收到一个任务之后，应该问问自己：我必须马
上处理这个要求吗？我遇到最坏的情况就是每一项任务都是紧急的，需要立刻完
成。因为紧急任务一多，就会发现一整天都在不停地从一个工作转移到另一个工
作，最终一事无成。

对于别人的紧急要求，别立刻接受，而是提出一个近期内更合理的时间，以便完
成他/她手中的工作后处理新要求。然后将这个要求同其他相同的要求合并进行
批量处理。

*扩展阅读：*

- [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000492&itemidx=1&sign=94c0656089fbaf9a6b751a5bbab54b4b][warfalcon]]
- [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000495&itemidx=1&sign=b1adeb2d5aac7069cce791cda2bb5726][warfalcon]]


*3、减少选择黑洞*

我们必须控制过量选择，只把精力和时间放在生活中最重要的选项上，放弃一些
不重要的选择机会。千万别过于追求完美，做选择时要考虑好时间成本和机会成
本，而且一旦选择之后，别浪费精力去为其它放弃的选择而后悔。减少跟他人的
比较。

最好建立一个自己做选择的框架，在面临一些人生中的重大问题时可以更好的选
择和权衡。

扩展阅读：

- 控制过多的选择
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000177&itemidx=1&uin=MjU4MjUyNzM2MA%3D%3D][warfalcon]]
- 针对大量选择时的最优策略
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000738&itemidx=1&sign=b1ce75ef1000a3b70e770060e32d3b99][warfalcon]]
- [[http://www.zhihu.com/question/19591602/answer/36731615][如何做选择才不会后悔？ - warfalcon 的回答]]


*4、减少负面情绪黑洞*

能正确面对恐惧、焦虑、抱怨等负面情绪，

扩展阅读：

- [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000759&itemidx=1&sign=27c1add809978d24c929c82738753a76][warfalcon]]
- [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201278840&itemidx=1&sign=a31cc5b12cf9be442ee1d07338376f3e#rd][warfalcon]]

5、减少注意力黑洞

- 如何集中自己的注意力
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000066&itemidx=1&uin=MjU4MjUyNzM2MA%3D%3D][warfalcon]]
- 观察自己的呼吸
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=203934058&itemidx=1&sign=e240a22c7e63853168c863c30c912577#rd][warfalcon]]
- 集中注意力的入门方法
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200983071&itemidx=1&sign=5ea7109a5848631609a7e0c81dc19983#rd][warfalcon]]
- 从管理时间转向管理注意力
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201082765&itemidx=1&sign=de78e74517d821092b5cd062d42f293e][warfalcon]]
- 集中注意力的十大秘诀
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201401194&itemidx=1&sign=9570baf0bb1fbc52c2c6ece7a4cb2add#rd][warfalcon]]
- 写给注意力严重不集中人士的生活建议
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=205820380&itemidx=1&sign=b5f6285133b0e65cea78336124a128c0#rd][warfalcon]]
- 学会在网络上控制你的注意力
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000685&itemidx=1&sign=09a1c1c940c29b1af205784d0159ce2f][warfalcon]]
- 学会在网络上控制你的注意力
   （2）[[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000688&itemidx=1&sign=be90345c551fa4c16c3aa91200e2685f&][warfalcon]]
- 用清理桌面物品来集中注意力：我常用的一种方法把笔记本关机，然后用笔
  记本清洁工具，把键盘、屏幕好好擦一下，然后看到焕然一新的笔记本心情大
  好。

6、减少交际黑洞

7、减少沟通黑洞

工作篇：

学会开会：*只去参加必要的会议*
[[http://www.zhihu.com/question/20291195/answer/15595509][开高效率的会议，有哪些好的经验？
- warfalcon 的回答]]

学会授权和培养新人：

- [[http://www.read.org.cn/html/1563-monkey.html][《别让猴子跳回背上》读书笔记]]
- 快速培养新人的四个方法
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=202558668&itemidx=1&sign=62f0f7914474712f96af84ea8f66b269#rd][warfalcon]]

生活篇：


8、减少拖延黑洞

扩展阅读：

- 我的战拖策略
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200321752&itemidx=1&sign=e15045518f8cb1f89109961166752b6b][warfalcon]]
- 战拖小技巧
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=202225151&itemidx=1&sign=6fffbbd02142e150a56636f1f8d88a8d][warfalcon]]
- 《一分钟能做什么？》60招对抗拖延
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=202103054&itemidx=1&sign=9f9ca10919eededa948ae6395d01db77#rd][warfalcon]]
- [[http://www.read.org.cn/html/2322-tuo-la-yi-dian-ye-wu-fang-zhong-de-jie-gou-hua-tuo-yan.html?From=test][《拖拉一点也无妨》中的结构化拖延]]
- 告别拖延症的7个信条
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201182906&itemidx=1&sign=89d62d5852b848338ebb20cc62068595#rd][warfalcon]]
- 对抗的拖延两种方法
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=205332382&itemidx=2&sign=4880ef380f52f401332ada12fdf28a71#rd][warfalcon]]
- 《战胜拖延症》笔记
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200233145&itemidx=1&sign=f64af36f8c909993966140447c54003c][warfalcon]]
- 对抗睡前拖延
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201089296&itemidx=1&sign=03827fccc3ecf45edb9946bca9ed239b][warfalcon]]
- 拖延处理技巧汇编
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000048&itemidx=1&uin=MjU4MjUyNzM2MA%3D%3D][warfalcon]]
- 《拖延心理学》中的12条应对技巧
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000365&itemidx=1&sign=2f8da62dc06a8be12691f8dd6a995a63][warfalcon]]


9、

***** 觉得这九条做到有些困难，那继续扩展成81条

1. 整理好办公桌 [[http://mp.weixin.qq.com/s?__biz=MjM5NjA3OTM0MA==&mid=204814936&idx=1&sn=fdc5f29e094ac9bc4b91a1c13f160296#rd][warfalcon]]

2. 每周提前做好下一周的规划和时间安排：[[http://www.zhihu.com/question/27783349/answer/38065315][如何让星期天的晚上过得更有意
   义？-warfalcon 的回答]]

3. 不整理名片，直接扫描，用名片全能王，直接扫描一下，大多数名片都能自
   动提取并识别，然后有时间的时候统一处理一下，一张名片只需要20、30秒
   就能处理完。

4. 问自己，如果我不做这件事情的话. 是否会出现极其严重的后果呢？”如果
   答案是否定的话. 我就会取消这件任务。

5. 提早1小时出门，在途中确认每天日程表

6. 多利用录音来取代手写的备忘录，用来记录各种想法和点子

7. 练就3分钟内长话短说的功夫

8. 工作日的时候，每天5点钟起床（晚上早些上床睡觉）。

9. 早上起床的时候做几个简单的体操，加上几个深呼吸，可以上大脑马上清醒

10. 午饭吃得很少，这样下午就不会感到困倦。

11. 用消噪耳机把公共场所变成书房

12. 读书的时候，我只会用很少时间，只了解书的要点内容。

13. 不要太相信记忆力，要勤做笔记，记录下来的东西要定期整理，消化。

14. 学习开会，要有重点，会后会把会议要点记录在一张A4纸上.

15. 不把日程表排满任务，每天留出三十分钟给自己，去跟自己约个会。在这段
    时间里，可以思考自己现在处于什么状态，思考将来需要一步步完成些什么，
    对未来进行长期的展望。

16. 放弃所有的“等待时间”。如果我不得不等待的时候，我将其看成是放松自
    我的机会，或者我也可以利用这段时间来做一些我平时不会做的事情。

17. 只要你多花一点心思，把自己的生活设计的更加有趣更加迷人，就能让你的
    生活丰富起来

18. 把你经常用的固定句式进行自定义加入词库中，比如搜狗输入法里面就有批
    量造词，把地址、邮箱、问候语、公文格式之类做成短语，打字速度会马上
    提高很多

19. 每天都会浏览一下自己的人生目标，并确保自己每天都会做一些事情来推进
    自己的人生目标。

20. 把目标可视化，设成手机壁纸或桌面壁纸，每天会重复提醒自己。

21. 即便是在做一些最不起眼的工作的时候，我都会想着自己的长期目标。

22. 尽量只做A级活动，少做B、C级活动。

23. 在开始一个大型项目的时候，我会首先从那些最重要的部分开始，并经常发
    现其他部分其实并不重要。

24. 首先做重要的事情。

25. 每当完成一些比较重要的任务之后，给自己放个假，或者是给自己一些特殊
    的奖励。

26. 集中精力处理那些能够带来长期收益的事情.

27. 一次只集中精力处理一件事情。

28. 坚持一件件完成'事务清单”上的工作。

29，把自己的大部分想法记录下来。

30. 用早晨的时间做一些比较有创造性的工作，然后利用下午的时间召开会议
    （如果有必要的话）。

31. 为自己和其他人设定最后期限。

32. 在每次跟人讨论的时候都会积极聆听。

33. 尽量不浪费其他人的时间（除非是一些对我真正重要的事情）。

34. 尽量把一些事情委托给他人完成。

35. 请专家来帮助我完成一些专业性的问题。

36. 请人帮助我处理所有常规性工作。

37. 尽量减少纸面工作。

39. 每份文件我只处理一次。

40. 把自己的桌面整理干净. 并把最重要的工作放到办公桌中央。

41，为所有的文件准备了专门的地方（这样我就不用再花时间到处找它们）。

42. 每个月会专门抽出三小时时间来处理琐碎事情。

43. 周末的时候尽量不考虑工作。

44. 经常让自己放松，什么都不做。

45. 我意识到迟早有一天，我会用一些时间来应付一些自己无法控制的事悄. 我
    不会为此感到厌烦。

46. 不断问自己，“我现在最应该做什么事情？”

47. 利用思维导图把握总体结构

48. 不要长时间连续学习: 每个人的精力是有限，并一定长时间学习效果就好

49. 花钱上课，强迫自己学习

50. 寻找学习伙伴，避免半途而废

51，冬天把空调设定在20℃

52. 利用腹式呼吸消除杂念

53. 马上实践学过的知识

54. 阅读中有30%～50%都是没用的

55. 给大脑0.5～9小时来处理信息，再回顾才会有新收获，不要在难点上停留

56. 倾听微弱的声音能提高注意力，每天练习3分钟

57. 每天做件不愿做的事

58. 自我讲授，像老师教学一样把资料概述出来，疑点会变得清晰

59. 大脑更喜欢图像

60. 技能不是持久的，不练习，它每天都在退步

61. 把问题用另一个角度重复一遍

62. 画效率/时间曲线表

63. 每天花10分钟写随笔，不要停顿

64. 不要压制欲望，化解它

65. 微笑释放的化学物质对紧张和愤怒极有效

66. 总是全力以赴，因为你最好的一面每段时间都不一样

67. 从别人的错误中学习，脑中犯的错越多现实中越少

68. 每天运动一刻钟

69. 区分抱怨，停止抱怨

70. 一年是很长的时间，重复就是力量

71. 每工作90~120分钟便需要休整，再全力以赴

72. 问自己，愿用2小时把事情做到80%还是4小时做到100%？它需要做到完美吗？

73. 为每页笔记作出简要总结，方便日后抓住重心

74. 整出条理可按时间、地点、连续统（难~易）、种类和字母排序

75. 觉得再难的，只要你能静下心来反复练习，就会有进步。

76. 找办法督促自己执行任务

77. 不要服用不必要的维生素和补充品。

78. 每年性生活高潮的次数越多、质量越高，你就越年轻。

79. 坚持每天吃早餐。

80. 低卡路里、高营养价值、均衡饮食。

81. 固定的睡眠时间能帮助你保持年轻。女性每晚睡眠时间7小时，男性8小时。

-------------------------------------------------------------------------------------------------------
觉得这81条也还是有问题，那继续扩展成6561条：
-------------------------------------------------------------------------------------------------------

这个版本可以直接关注我的微信、知乎、Blog和豆瓣，写了8年快完成1/3
了，还有 2/3 估计在我死之前还是很有希望的。

***** 对这么多的技巧应该如何吸收和整理？

*去“做”，但不要期待任何 “结果”。*

第一步分类。把不同的技巧，按用处或类型，从新整理一下。放上关键字，收藏
起来。

第二步删除。对你帮忙不大或暂时用不了的技巧。

*第三步挑出少数几条实践。* 选择一些能解决你当前问题的技巧，从现在开始
尝试。可以列个清单。

第四步记录。每尝试完一条之后，记录一下心得，想想是否有可以改变的地方或
者直接放弃。

第五步总结。积累5-10条实用小技巧之后，写篇文章总结一下，找机会分享出来，
你会发现在写的时间，会考虑一些以前想不到的问题，分享也能让你印象更深刻。

**** [[https://mp.weixin.qq.com/s?__biz=MzA3MjM2MzYzOQ==&mid=402437707&idx=1&sn=02c915a39a2124790476688c0bde69d9&scene=1&srcid=0115wtZqKbY2mdXhwAlhVlmz&pass_ticket=8B57gmAPihhXDqY3DNHOKiG9154WT42aR6KFVbb%2FAFpL7bBsnVOOoPubYSkLb3iH#rd][孩纸，事情不象你想的那么简单]] :行动:

文：雾满拦江

（01）

明朝时，有个叫李晟的人，他心怀大志，胸有奇谋，痴迷军事器械研究，发明了
许多先进武器，战车连弩什么的。朝廷是非常重视这类科学家的，立即传令工部，
照着李晟的图纸打造弓弩战车。

战车连弩很快打造出来了，可是怎么看都有点不对------车装配不起来，弓弩拉
不动。都是废品，根本没法儿用。

李晟以坐废钱粮之罪，贬。

好多年后，李晟再次卷土重来，给朝廷呈上他最新研究出来的战甲。朝廷仍然一
如既往的重视，立命工部铸造。

但这次，工部多了个心眼，铸造新式兵甲可以，但要求李晟本人，要先行试用。

试用就试用，等兵甲造出来，往李晟身上一扣，就听哐的一声巨响，李晟被他自
己研究出来的兵甲，死死的扣在了地下，怎么用力都爬不出来。

原来，李晟研究的兵甲，防御力量绝对没的说，刀砍不入水泼不进，就是忽略了
人体的承受重量。这兵甲一旦穿在身上，就被压得趴在地上，根本爬不动......

（02）

纪大烟袋纪晓岚，写了本《阅微草堂笔记》，书中提到一个怪人刘羽冲：

刘羽冲，沧州人。他也是个喜欢琢磨事儿的人。有一次，他无意中得到本古兵书，
潜心研读多年，终于破关而出。言称其可统兵十万众。恰逢当地闹土匪，刘羽冲
主动担纲领队，率乡勇出击土匪。一触即溃，如果不是刘羽冲逃得还算快，铁定
被土匪捉去了。

从此刘羽冲不言兵事。

又不久，他又得到了一本古水利书，再次潜心研读多年，终于破关而出，自谓可
使千里成沃壤。游说于州官。州官也是位富创新精神的冒险家，遂大胆采用刘羽
冲先生的方法，开渠治水。岂料沟渎初成，大水狂涌而入，州郡之人，几为鱼鳖。

连续的失败，让刘羽冲陷入忧伤之中。他每天独自徘徊在台阶下，不时的自言自
语：噫吁戏，古人都是王八蛋，净写假书把我骗。都怪老子太犯贱，连续上当没
咒念......

（03）

晚清年间，倡导洋务。有下有个蒋老汉，是个创新型的实干家。他在报纸上看到
洋人的火轮船，顿发宏愿，要亲手制造一艘。

制造一艘铁甲战船，那要花老钱了。蒋老汉舍得投入，他花光家产，负债累累，
凑足了材料，然后拎只小铁锤上阵了：叮哩当啷，哐哐咣咣，不眠不休的苦战了
不知几多日月，最终是功夫不负苦心人，一艘华丽的铁甲船，终于成功的制造出
来了。

铁船下水之日，三乡五里的人全都跑来看热闹，被蒋老汉的创意深深的折服：看
看人家，你看看人家，敢想敢干敢冒险，真是了不起......哎哟，那是怎么回事？

没怎么回事，就是蒋老汉研究出来的铁甲船，一碰到水，就听咕嘟咕嘟，瞬间就
沉没了。

造了这么多日子的铁甲船，刚刚见水就沉了，这未免......蒋老汉呆立水边，茫
然失措。

一个看热闹的人告诉他：老蒋呀，你的创新精神，是好的，是应该受到鼓励和支
持的。可是这世上的事儿，不是你胆肥儿就能干明白的。单说这铁甲船，在洋人
那里都是个超复杂的问题，要学好多好多的知识，才可以......

原来是这样啊，蒋老汉毅然发了狠，要送儿子去西洋，学习制造铁甲船。

蒋老汉把儿子送去了西洋，可是这个儿子学了半天，还是没弄会如何制造铁甲船。
他毕业归国，去北大当了校长，专门告诉孩子们：骚年，这个做事呢，不象你们
想的辣么简单，真的不象，就比如说咱爹......

这位校长，叫蒋梦麟。

（04）

前段时间，一位当父亲的在我微信里留言，说了这么件事：

他的儿子，大学毕业了，雄心勃勃，要开工办厂。

可是，这家人父亲没开过厂，爷爷没经过商，祖上十八代都是凡人，你个熊孩子
开口就要开厂，你懂得厂门该向哪儿开吗？

孩子才不管，在家里大吵大闹，要家里拿五十万创业基金出来。

钱是有，可五十万，足以让这家人抽筋剥皮了，毕竟是工薪阶层......可这苦情，
根本不能跟读了书的孩子讲。这孩子读书读得已经不会说人话了，开口就骂：五
十万你都拿不出来，活这辈子还不如条狗，现在赚钱这么容易，狗汪汪两声都能
赚五十万......

家里被这孩子闹得乌烟瘴气，最后老伴屈服了，瞒着他给了孩子存折。

不出所料，孩子拿到钱，立即就消失了。不久有债主找上门来，厂子没见到，据
来人说孩子还在外边欠下一百来万......此时家人心急如焚，到处找孩子，最终
在家网吧，成功的把那熊孩子找回来。那孩子回来时梗着脖子，一脸的不服不忿，
此后爹妈做牛做马还债，这孩子就呆坐在沙发上看电视，还不能问他怎么欠下人
家的钱，一问这孩子就疯起来......

那位父亲问：你说我儿子，这书他究竟是怎么读的呢？读到最后，连事情看着容
易做起来难，这么简单个道理，他都不懂了呢？

（05）

前段时间，我的几个写字吃饭的朋友，聚一起喝酒，一边喝一边愤慨：唉，什么
世道，这人都是瞎了眼吗？你看那个谁，那个谁，还有那个谁谁谁，他们写的东
西，叫什么玩艺儿呀？烂到家的文章，根本看不下去，可是他们都红了，还大红
大紫，这可真是日了狗了。

咱们也要红！

咱们几个的才华，比他们强上几百倍，想红不过是分分钟的事儿！

而且，咱们是个团队，随便扔过去一个，都把他们砸趴下的那种。咱们几个合写
一个微信公众号，大家轮流上，每天一篇原创，最多不出半个月，准保大火。火
了后咱们就那啥......那啥......

干啦！

然后他们就真的开了个公众号，联手上，一共五个人，每五天轮一圈，每天一篇
原创文章。

头两圈，大家严肃认真，克尽职守。

到了第三圈，有位老兄讨个巧，他没写文章，顺手把他早年写的诗，发上去凑个
数。

他的想法是，我就今天偷个懒，有你们四个人的原创撑着呢，整体质量也不会下
降，等我哪天灵感来了，写篇涨粉的......

不曾想，另外几个老兄，也是这种想法。只是不好意思，见这老兄先行下了手，
大家心里再无顾忌。

从此这个公众号，发的时候随便抄几句，或者干脆停发，就这样过了段时间，这
个公众号，大家就很少登录了。

团队合作，怎么想都是极完美的，但当真做起来，却发现总会有意想不到的事情
发生，让我们心中美好愿望，最终沦为空想。

------人世间的事儿，怎么用脑子想，怎么合理。只有等做起来时，才会发现，
想象中的逻辑与现实，往往不在一个频道上。

（06）

一个人，做事越少，怨愤之气就越重。

*做事少的人，会把所有的事情，想得极简单。*

做事如此简单，可证自己的智商，那可不是一般的高。自己这么高的智商，却混
不出个模样来，可证这世道是多么的昏黑阴暗。世道如此不公，让自己满腔宏愿，
无由抒展，这种情况下的人，想不悲愤，真的很难。

*但这几个故事，告诉我们，人间事儿，真的没有简单可言------如果有，那一
定是你以旁观者的角度，看别人做事。*

明朝的李晟，清朝的刘羽冲、蒋老汉，都是认真做事之人。只不过，他们所做的，
是自己不熟悉的领域，不知道一项研究，要经过无数次试错，才会稍有点眉目的。
比如爱迪生，他为了寻找最合适的电灯丝，先后试验了上万种材料。在这个过程
中，所谓做事，不过是不停的试错，把所有的错误都找出来，就知道对的方案
了------但明李晟，清刘羽种和蒋梦麟的父亲，都只有一次试错的机会，一次不
对，人生成本耗尽，就玩不下去了。

人是没有预知能力的------许多人看到这句话，会频繁点头，但当轮到他们自己，
却往往忘了这点。那个非要开工办厂的孩子，和五个合开微信公众号的老兄，就
是不知道一件事情做起来，会有无数的枝节问题需要解决。这些问题和困难，只
有做了之后才知道。

不知道事情会遇到什么问题，不清楚事情的枝节，只看到事情的头和尾，这就是
许多人，把没做过的事情，想得过于简单的原因。

（07）

人生就是这样，除非在你自己的主场，所有的因素完全可控，这时候你才敢说胜
劵在握。

余者，你必须准备支付试错成本。

台湾有个歌星，曾讲述他服兵役时，如其所愿的被安排去歌唱，他雄心勃勃，以
为自己是偶像，铁定是赢得满堂喝彩。岂料真要演出时，惊发现还需要他自己搭
舞台，可他只会唱，从未搭过舞台，顿时傻了眼。这时候他的同伴们立即取出携
带的简易工具，噼哩啪啦搭个台子，自己走上去引吭高歌，让这位大歌星看得直
眨巴眼。

没有亲手做过的事儿，之所以想得容易，就是不知道还需要自己搭台。嚷着开厂
的孩子不知道这个，生生被人骗成狗。我那几个写字的朋友，他们根本没有与人
合作过，心里想的简单，以为人人都会出工卖力，替自己搭台。但等真做起来，
才发现人性还有偷懒搭便车的一面，台子还得你自己搭。只会唱戏不会搭台，这
戏你就唱不了。

想象中的逻辑，完全构建在别人都是无生命的劳作单元、心甘情愿替自己搭台的
基础之上。想象中的别人，都是没有私欲的，对自己是绝对顺从的。就跟电视剧
里演的一样。电视剧中，所有人都是主角的奴隶，就算是对手，也是以其拙劣映
衬主角的高智商。而电视剧是典型的想象思维，符合人类的主观想象------唯独
与现实不太贴边。

（08）

许多人喜欢指点别人，却最痛恨别人指点自己。

指点他人时，个个都是高手，从未做过实事的孩子，敢怒斥辛苦的父亲笨。等轮
到他来做，才知道这世上最笨的，就是他自己。

事非经过不知难。事情也只有做，才会在一次次试错后，走向成功------这是尽
人皆知的大道理。

但，没人告诉过你，你需要为每次试错，支付多少。

哪怕最简单的事儿，流程都复杂到超出你的预期。而每个环节的支出，加起来更
是个惊人的数字。以为五十万就能开个厂的孩子，需要有人告诉他，胼手胝足用
自己的努力来开厂的人，会发现自己付出的远不止这些。以为自己能力具备只差
钱的人，多半是把事情想简单了。

*永远要记住，想象最容易，做事最艰难，想象的逻辑与现实，始终有一条不可
逾越的鸿沟。*

真要想做成事，还要避免那种一次性就把人打入失败深渊的成本付出，适当的方
法有许多，比如你可以：

------先要知道自己这事儿没做过，许多细节不知道。这话说着简单，但没做过
事儿的人，会拼死的抬杠，死活不肯承认这点。

------承认你没做过的，必有你不明白的，这就可以了。

------从学徒做起。现在没有学徒制了，没有也不要紧，你可以找个正经做事的
人，到他身边，帮忙也好求聘也好，以员工的身份，踏实的观察，学习。这世上，
老板是最苦鳖的人，做梦都盼着个懂事明理的孩子，帮自己一把。如果你是这样
的人，就会获得具体实践的机会。

------事情做起来，慢慢你就知道什么叫资源了，你会认识越来越多做事的人，
知道每一个流程细节，能正确估算一件事的成本投入。

------等到你知道如何做事，懂得如何做成事，这时候你用不着逼家里拿钱成就
你的梦想，许多人自然就来找你了。当然，在你不会做事，还蠢透天的时候，也
会有许多人来找你，但这时候来的都是骗子。除非你成为做事的人，同类型的人
才会出现在你身边。

*事情是用来做的，不是说的。*

没做过事儿的人，往往会趾高气昂指点江山。而做事之人，莫不是低调谦
和------不是做事者人品好，而是他知道做事之难，再不敢摇头晃尾胡言乱语而
已。

让我们开始吧，先把心沉下，承认自己确实没有做过这件事。学习，询问，倾听，
学习的过程中，难免因为犯错而遭到斥责羞辱，如果你是玻璃心，明明什么都不
懂，还想让人拿爷供着，那就需要认真思考一下自己了。

要记住，这世上有两种人，一类是不做事，只管趾高气昂嘲笑别人，却荒废了自
己事业的蠢人。另一类是低调隐忍，任人嘲笑但逐步成就事业的人。你选择什么，
就会得到什么。你的人生你做主，荒废或是成就，取决于你内心深处的愿望。

**** [[http://m.wufazhuce.com/question/2016-01-03?from=timeline&isappinstalled=1][什么才是真正的成长？]] :一个:成长:

毛头子问：经常看到很多人说“成长”，感觉仿佛只要懂得了某个道理，就是一
种成长，成长就是不断地明白道理的过程，是这样么？


@曲玮玮 答毛头子：

真正的成长，就是不再急于成长。

有一类问题似乎很受欢迎------“哪些道理让你相见恨晚？”“你的每日私人成
长暗器是什么？”“哪些习惯能让生活变得更好？”

大家忙着收藏，忙着把一眼扫过去瞬间读完的道理抄在小本儿上，忙着赶紧找到
填补袖口破洞的补丁，忙着大彻大悟，忙着醍醐灌顶，即刻见疗效。

这些简洁的人生道理总是高赞。因为不需大费周章就能把几行金玉良言背下来，
产生自己手持武林秘籍行走江湖畅通无阻的幻象。

可是，你以为那些道理，作者栽跟头之前从没听说过吗？它们是治病的药丸，不
是预防针。只有跌了跟头后混合苦水服下去，才能缓解跌打损伤，从此溶进血液
里内化，终身傍身。在你经历到这些之前，它们只是粘在衣服上供你摘取的小处
方纸片。

当你真的成熟，慢慢不会再把“每天进步一点点”挂在嘴边。不会只对可以量化
的努力成果情有独钟，不会执念于“少吃一顿肉必然体重掉两斤，多做两道题考
试加五分”。没必要咬牙给自己设定
KPI。生活又不是大妈坐小板凳上织毛衣，一切所见即所得。

和我一样，很多写小说出身的人做自媒体，从前的创作是“背向”读者，所谓的
“成长”更多来源于自我省察。开了公众号之后，一切数据都转向阅读量与粉丝
数。有了可量化的数据之后，旁人哪里顾得上你内在的进步呢，只会忙不迭问你，
“最近粉丝涨了多少？”

或许世俗对成长与成功都有一套冷冰冰的评价体系，你要忍受层层标尺在身上测
量的尴尬，挺直腰板儿，心中另有一套无形的标尺。

时间本身是没有标度的，是人类为了有所区分与回顾，把连贯的时间分割成块。
又到年底，以前也执念于写一年总结，这一年看了多少书和电影，输出了多少万
字，把量的积累看作成长之一。也渴望从每段经历里萃取几滴人生精华敷在脸上，
希望每次摸爬滚打都能换来可视化的成长。

今年我依然会写总结，但不再有此心态。

生活不仅不是织毛衣，甚至连“蜗牛爬金字塔”都不是。没有任何人向你拍胸脯
保证，你所做的一切努力都指向前方。

有人用了错误的健身方式，辛苦流汗，却把自己严重拉伤。一些连续创业者总是
急于标榜自己在失败中得到多少宝贵的经验，却不会勇于承认，自己消耗了多少
资源和好年华。

你只是旅人走在陌生丛林里，天高地暗，薄雾微茫。你可能离星辰大海越来越近，
可能跋涉一天依然绕回原点，甚至努力一番仍向后退。

罗曼·罗兰说，“看清这个世界，然后爱它。”真正的成长，大概是你看透一切
之后，放下“你要去相信，没有到不了的明天”这种鸡汤执念，放下自欺欺人，
依然往前奔跑，无畏无惧。

初中时看《老友记》，看他们每天坐在同一张沙发上一本正经瞎扯淡，端着咖啡
杯消磨时间，乐此不疲地制造笑料，心里都在替他们着急，这些人什么时候能长
大啊。那些闲扯淡和玩填字游戏的时间，用来报个技能班学个编程该多好。

今年又重温了一遍。第一季穿着婚纱一惊一乍、被宠坏了的姑娘
Rachel，成了某时尚公司主管。吊儿郎当玩世不恭的
Chandler，重新找到了所爱的职业，也成了充满责任感的丈夫。

电视剧里从来没有从天而降一场惊人的变故，让每个人瞬间遭受锤炼，一夜之间
沧桑得判若两人。他们也没有合上书本后一拍大腿，顿悟真理从此铠甲傍身。

我只是在陪他们傻笑，替他们尴尬之余，年复一年，发现他们慢慢成长为另一种
样子。Joey
依然行为低幼，Monica
依然强迫症，Phoebe依然鬼马。十年过去，这些点缀人性的漂亮羽毛依然在他们
头顶随风飘，但是人生已经有了更厚重的根基底座，再也不是二十出头受了惊吓
随时地动山摇世界崩塌的小孩子。

急什么呢。

我很喜欢一句话，叫“但行好事，莫问前程”。

并非要你放下功名尘土无欲无求，只是不带着强烈的结果导向去做事，不是把一
串葡萄放进榨汁机就马上求一杯饱满的果汁。

我们坚持一件事情，并非因为这样做了会有效果，而是坚信，这样做是对的。哈
维尔说。

只顾笃定往前走便是，胸中自有云月。
**** [[https://mp.weixin.qq.com/s?__biz=MzI0OTEzNzY3NA==&mid=402189489&idx=4&sn=52e6a4a3f19737ffb0f786bc26b0482b&scene=1&srcid=0118goA5DF1wmTRug9ZOpCti&pass_ticket=8B57gmAPihhXDqY3DNHOKiG9154WT42aR6KFVbb%2FAFpL7bBsnVOOoPubYSkLb3iH#rd][韩寒：长跑就是长跑，人生就是人生]]

很多人在长跑的时候喜欢思考人生，但对我来说，长跑就是长跑，人生就是人生，
我在长跑时考虑最多的时候是我的表情。

要知道我小时候一直是长跑队的，也拿了不少学校和区里的长跑比赛第一名。

其实我很早的时候是长跑的，如果我真的好好练的话，我的长跑应该可以到进国
家队的水平的。

我进高中是体育特招，长跑特招，我以前跑步是跑不快的，因为我的好朋友跑的
很慢，每次在体育课的时候我得跟他们做伴，他们跑得慢我也得跑得慢，有一次
误打误撞参加学校的800米和1500米比赛，第一次跑就两个比赛都破了校记录10
多秒，而且当中还停过，跑两圈以后，我以为到终点了，我跟同学们在欢呼拥抱
了，但是我们的跑道是250米一圈的。同学们给我欢呼完以后说哥们儿还有一圈，
然后我又追上去，还破记录，还拿的第一。

后来参加区里面长跑的比赛，8000米的也都很轻松地赢了，我自己从来都不训练。
跑8000米的时候，在街道上警察还带错路，我当时跑在第一，后来警察转身对我
说，哥们儿不好意思，我开错路了，然后又回到那条路上，等于我比人家多跑了
几百米，后来还赢了很多，体育特招进了市重点以后，学校里和松江区的、包括
跟体校在一起的只要是长距离的跑步的比赛，我都能赢，而且都能有很大的一个
领先的优势。而且我从来都不训练。

上学时别人说我是跑步天才，我觉的算不上，因为毕竟区或者是市一级的比赛还
是比较低的，但是如果我经过一些训练或者是怎么样的话，我相信我的长跑肯定
应该是挺好的。当然你不一定在世界上争得什么荣誉。

我当时穿篮球鞋在跑步，因为那个时候我爸爸一个月给我四五百块钱，我在外面
寄宿，我积攒了几个月之后终于有买球鞋的钱了，但是我想来想去，当时是灌篮
高手，爱面子，参加比赛就穿着很重的篮球鞋，如果有很轻的跑鞋的话，一定会
跑得更快。

可能是我的腿脚的形状比较适合长跑，耐力会比较好一些。我不会游泳，我很喜
欢骑自行车，当然不一定是奥运会的比赛，是好玩，参加一下。

但始终有一个问题困扰着我，那就是我的比赛照片实在是太难看了，每一张都是
面目狰狞，鼻孔放大，舌头外甩，眉头紧皱。而那些照片都被放在所有学生都能
看见的学校形象展示玻璃橱窗里，导致有一些女生看见我会说，哟，你真人没那
么丑嘛。

于是，长大以后，我选择了一个至少看起来比较酷的运动：赛车。最关键是，无
论我的表情是啥样，再也没有人能看见我的脸。我有头盔，而且选择了黑色的玻
璃镜片。

我对长跑没有眷恋，我抛弃了它整整十年。但跑步让我感触很深，因为这是唯一
一个我没能找到起点在哪里的比赛。

现在我三十多岁了，我又开始长跑。不为别的，不为思索，不为感悟，只为了自
己的身体。硬要我说出些什么，我只能说这是一个忆苦思甜的运动。

人在坐着的时候常常会想如果我能躺着那该多好；躺着的时候常常会想如果旁边
有一盘水果那该多好；吃到了水果常常会想如果有个人在边上给我按摩那该多好。
只有在长跑的时候我会想如果我能坐着那该多好。

**** [[http://www.cnblogs.com/skyseraph/archive/2010/10/30/1865280.html][完全用Linux工作-王垠]] :linux:

注：本文是清华“牛仔”王垠的“成名作”，在网上引起很大的争议。对他崇拜
地五体投地者有，对他嗤之以鼻者也有，总之成了一年多以前Linux

爱好者的圈子里的一个很有意思的现象。之后他对这篇文章进行了很大的修改，
已经没有了原来那种意气风发。现存的版本如白开水一般无味，请参见：
[[http://learn.tsinghua.edu.cn/homepage/2001315450/]]


尽管他原来的观点有所偏激，但我还是很欣赏他原来的风格。

***** “UNIX 是简单的，你不需要成为天才也能理解这种简单。”

由于GNU/Linux这个词太长，下面如果没有特别指明，“Linux”就是指“GNU/Linux”。

在这个年代，恐怕没有人需要我来介绍 Linux 是什么了吧？如果你觉得“Linux
只不过是跟 DOS
差不多的东西”，那你恐怕很久在山洞里没见天日了吧？请问问你旁边的 Linux
用户，Linux 到底是个什么地位？

那为什么我还要写一篇这样的文章？因为，我发现还有很多人不不理解 Linux 和
UNIX，虽然他们也在用它，但是他们有时会问：“为什么 Linux 不能像 Windows
那样 ......？”，“怎么Redhat Linux不能 mount NTFS
分区！”，“Linux下用什么整理硬盘？”，“什么时候OpenOffice才能完全兼容Word文件啊？”，“现在还有什么Windows能干的事情Linux干不了的？”......

他们有40G的硬盘，却只为 Linux
分配了2G空间，有时还抱怨“这个东西怎么占这么多硬盘！” 似乎
Windows该占用大部分硬盘。他们把重要的数据装在Windows的分区，似乎信不过
Linux。他们总是到处寻找新奇的，好看的GUI程序，对命令行的东西一概不屑一顾。他们对Drag&Drop，菜单配置，自动升级非常感兴趣。他们如果找到一个很像
Windows 程序的 Linux 程序，一定会很高兴的说：“哈哈！Linux
也能......了！”
如果Linux在某种测试中胜过Windows，他们会高兴得跳起来。他们没有办法用Linux解决问题的时候，甚至用Wine来运行Windows程序。有时实在没办法，只好重起到
Windows，或者干脆省得麻烦，在 Windows 下装一个 VMWare 虚拟一个 Linux
玩。

你支持 Linux，你喜欢
Linux，你能从中感觉到快乐，这非常好。你现在只需要明白的是：Linux
从来就不是一个玩具，它是天才UNIX的后代。UNIX
是自晶体管发明以来最伟大的发明，它从诞生那一天开始就比 Windows
的设计出色。Linux 并不需要追赶
Windows，不需要打垮微软，它的最终目标是改变整个计算机世界，还人们自由，给人们乐趣和方便。其它UNIX很多都已经败在Linux脚下，更何况
Windows！

你如果出现了以上的情况，说明你的思想受到了 Windows
的某种潜移默化的影响和误导。你没有能够从本质上理解存在于 Linux 身上的
UNIX 思想。UNIX的设计者 Dennis Ritchie 说：“Unix is simple. It just
takes a genius to understand its simplicity.”
但是我不这么认为，因为我不是一个天才，但是我却勇敢的把Windows完全删除掉，半年之后我体会到了
UNIX 的思想和好处。因为我相信这样的信念：“Windows 能办到的事 Linux
一定能办到，而且办的更好。”

这小节开头的话应该改成：“Unix 是简单的，但是在这个冲斥着 Windows
错误观念的世界，你需要信念和勇气才能理解它的简单！”
我下面就告诉你一些我理解到的东西。

***** 微软的地位

微软的名声在欧洲和美国的大学里，特别是在计算机系里之坏，大家可能有所耳闻。我认识的
MIT，Stanford
的教授，贝尔实验室的专家，甚至一个欧洲小国的高中计算机老师都绝口不提微软的名字。在他们眼里，微软只是一个没有真技术，专靠在落后国家商业宣传和垄断经营的小公司。这个“小”并不是说它人少，钱少，而是说它先进技术少。

我上次和王益合作写了一个算法演示程序，那个算法是贝尔实验室一位科学家Steven
Fortune很天才的发明，为了程序能够被身边大多数人使用，我们选择了 VC+MFC
作为平台。我在分析算法时还得到 Fortune
很热情的鼓励，寄给我一份资料，还多次回信耐心的给我讲解了很多细节。但是程序完成之后，我把样品发给
Fortune，他回信说：“对不起。我机器上没有 MFC。”
话说的很客气，但是我已经感觉到了他对 Windows 的不屑。然后我把 MFC
静态编译进程序再发给他，他就没有再回信了。他显然不是瞧不起我，而是确实有难处。

你能感觉到这位科学家对微软和 Windows
是什么态度了吧？不是反感，而是他心里根本没有 Windows
这个东西！微软在高科技领域没有发展，那么它怎么生存呢？到发展中国家去发展一下，他们的人民还对电脑一无所知，我说不定甚至可以打入大学的计算机系呢。我送他们软件，我捐钱盖大楼，我出钱找图灵奖获得者来演讲，让他们觉得我们都是科学家！

好了，现在全国的大学包括清华，几乎所有人机器必装盗版 Win2000，Office
XP，学校的选课系统是非IE不能正确浏览，论文用 Word
编辑，演示用ppt做，email 的通知附件是 doc 文件，你不用 Word 打不开，连
863 项目都用 VC
写程序了。我很久以前就看到一份报纸说，“微软为什么不严厉打击盗版？”
这篇文章说，微软非但不打击中国的盗版行为，而且有放任之趋势。放长线吊大鱼，“以后我要你们加倍的来还我！”
确实如此，它的目的快实现了。

***** Windows 笼罩下的中国计算机教育

说句丢脸的话，比尔盖茨很久以前是我的偶像...... //blush

在中国，比尔盖茨被很多人奉为神圣，“少年电脑天才”，甚至有的人提到他的名字就做出“抱拳对天”的姿势。很多人谈到微软的“新技术”，“高科技”
都是眉飞色舞。各种“VC编程圣经”，“深入了解 Visual
C++”之类的书，在开头几页都会出现非常肉麻的字眼，“在那团团的混沌中，一个开天辟地的精灵，Windows
1.0，诞生了......”

微软的软件被这么多人盗用，那么人们是怎样使用这些盗版程序的呢？先看看电脑培训班，教的都是一些
DOS 命令，打字，Windows 基本操作，Word
文档处理，PowerPoint，高级班可能有 Excel，Access......
参加各种微软认证考试，MCSE，MSDE
的人络绎不绝。考试辅导班都贴出了“280元，考过为止”之类的字样。考试参考资料更是昂贵，有些电脑书店整整两书架都是“Microsoft
Press”的东西。我有个同学参加认证考试，每门考试都要200多元。而且你一次考不过可以再考，又要交钱。他后来还津津乐道跟我说，看我，花了XXXX(一个四位数)元考过了微软认证，得到一张比尔盖茨亲笔签名的证书和价值6000元的
Windows XP 内部发行版。

“电脑要从娃娃抓起”，我们再来看看娃娃们学的是什么。大部分家长给孩子买了电脑之后，他们首先就会装一个盗版的
Windows，然后买来盗版的游戏开始玩。如果哪个孩子会用 Delphi
编程序，那可不得了。报社记者，电视台争相报导，说，某某学校的初中生某某，在别人都还在玩电脑游戏这种“初级阶段”的时候就已经用
Delphi 写程序了。镜头还瞄准了他显示器上面的像框中的比尔盖茨头像！

我刚进入大学计算机系时还不懂得什么是操作系统，因为我以前只用过“中华学习机”。看到新入学的同学们各个谈论的都是
“Windows 95”，“VC”......
我简直觉得我落后了好几十年一样，整个一土人，根本跟他们答不上话。好不容易找到一个比较熟的同学问了一下：“你们天天谈论的瘟95是什么啊？”答：“win95就是一个操作系统，跟DOS是一类。”“朵死是什么？”
“你连DOS都不知道是什么？别在计算机系混了。”
学校上课当然不讲VC编程之类的东西，但是上 Pascal
的老师有一次就说：“嗨，我们学校真是落后。现在别人都用 C, C++，甚至 VC
了，我们还在讲
Pascal。不知道什么时候才能有VC课啊。你们出去也是要用VC的，只好自学了。”
于是，有些同学很多时候上课都捧着一本很重的“Windows
编程大全”之类的书，根本没有听课。吃饭时就念念有词的跟我说，“代码的优化是无止境的”，“匈牙利命名法真是伟大的发明”
...... 这就是中国很多大学计算机系的情况。

感觉到无知了？这不是偶然的，而是微软长久以来埋下的伏笔。它要让无知的大家都把它奉为神圣，它要让支持UNIX，Xwindow的人一旦说
UNIX 好，Xwindow 好的时候，都被一群人围着说教：“这个 Windows
也能做到”，“你对 Windows 有偏见”，“微软才是主流啊”，“你敢瞧不起
win2k？”，“.NET
就是世界潮流”，“微软的毕竟是新技术”，“有钱就是有技术”......
甚至在一番论战比较后败下来还是要说：“Windows
性能差点，但是易用性强”，“Windows
是老百姓用的，要求别那么高”，“微软那么有钱，以后想超过 UNIX
还不容易吗？”......

***** 发达国家的计算机教育

我前段时间在 USENET 发文问有关 Scheme
语言的问题时，认识了一位丹麦人。他解决了我所有的问题，并且建议我阅读一些很“深奥”的有关程序语言语法，文法的书，他告诉我很多网站可以学习
LISP，Scheme，人工智能，算法。他叫我看 Jonathan Rees 的论文 "Syntactic
Closures"。他还打包给我寄过来一份 MIT 的 "How to Design
Programs"。他说他在自己的 PC 机上装的是 Linux，他用 Emacs 编辑，运行
Scheme 程序。他对 Emacs
的了解和爱好真是使人惊讶。他大学本科毕业时做的毕业设计是一个 Scheme
解释器。这对于我来说是望尘末及了。

他是那么的不厌其烦，我的每一个问题他都详细的回答。我有时都觉得过于详细了，怎么这么耐心啊？我觉得他似乎是我的高中老师。他是什么样的人呢？我好奇的打听了他的情况。原来，她是丹麦一所普通高中的计算机老师，而且是个女老师！

她说她在高中里讲授程序设计和算法，计算机语言文法。她说用
Scheme，她的学生不用再为内存泄漏等程序语言本身的问题而烦恼，而专注于问题和算法本身。有利于培养学生解决问题的能力，特别是用计算机解决数学问题的能力。

天哪！为什么欧洲出现那么多数学家，几何学家？你看看别人重视的是什么！我们的计算机教育如果继续这样下去，只会沿着弯路越走越远！

***** 微软和它的朋友们的如意算盘

下面来看看微软的收入是怎么来的。首先，Windows 98系列操作系统，一个就是
100 多美元，每次升级又是几乎同样的价钱。Windows NT
还要贵几倍，而且有用户数目限制，5个用户的，10个用户的......
以后如果要增加用户数目还要按比例付钱。这个奇怪的现象被通用汽车公司的总裁比喻为：“你买的微软牌汽车最开头只有一个座位，每加一个座位你得向汽车公司付钱，每开100英里要大修一次，每过一年要换一次引擎。”

花了如此多钱买来的操作系统就能用了吗？它竟然连压缩程序都没有提供！你装上
Windows 之后一般第一件事就是去下载一个 WinZip 吧，“只要 29
美元”。Windows 会中病毒啊，马上花 70 美元买一个 Norton AntiVirus
吧。还有黑客呢？再买一个 Norton Internet Security 好了，100
美元。系统需要优化，磁盘需要整理，买一个 Norton System Works
是你最佳的解决方案，100美元。

可是你现在还是不能干正事啊！你想要一个 Word, PowerPoint？那就买一套
Office XP 吧，一起买便宜些，9.90。

那些程序不会用啊！那些菜单怎么设置，到底有什么功能啊？看“帮助”也学不会。买本书看看吧，我推荐“Special
Edition Using Microsoft Office
XP”，不贵，.99。这本书里面大部分是屏幕抓图，还是买一本旧的比较划算，.85。

你如果只是当个秘书，上面的差不多还凑合了。可是你有更高的追求，你想成为
Windows 程序员。首先买一个 Visual Studio.NET
吧，要不然怎么编译程序。4.95。

为了紧跟微软动向，世界潮流，不能不注册个 MSDN
什么的吧？这个贵一点，不过物有所值啊，,799。

嗯，你现在已经是上层阶级，白领人士了。你现在可以像这样“自由”的，“安全”的生活了：

***** 什么是 Windows 能干而 Linux 干不了的事情？

“Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”

有个朋友看我半年没有用 Windows，有时就会问我：“你只用
Linux，有没有发现有些 Windows 能处理的事情 Linux 干不了？”

我回答说：“Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”

Windows 能做的有益的事情 Linux 都能做

Windows 下的某些功能确实是我们需要的，那么 Linux
的开发者们和用户也需要这种功能，他们就会去实现这种功能，而且比Windows
的方式好得多。由于大多数科学家，工程师用的都是 Linux 或者某种商业 UNIX,
所以几乎所有商业的科学工程程序，比如Matlab, Mathematica, AutoCAD,
Candence的，Synopsys的，Avant! 的......全都是先有 UNIX
的版本(包括Linux)，然后再考虑移植给 Windows，甚至根本不移植给
Windows，因为 Windows
的机器一般没有足够的能力运行这样的程序。你不要以为只有 Windows 才有
PSpice, UNIX 的 HSpice
要好得多，而且可以运行在大型主机上。当然它们不是免费的，但是它们值那个价钱。

但是 Windows 下有些东西在 Linux
下没有很相似的，或者你找到很多类似的，但是它们每一个比起 Windows
的那个程序都要差很多，那么原因有两种可能性：

1. 有一个完全类似的程序，但是由于它乍一看不漂亮，被你忽略了。

而其它程序虽然看起来很漂亮，但是它们是一些初学编程的人写的。现在由于
Gtk+, Qt 的诞生，Linux
下开发图形界面程序极其简单，很多初中生甚至小学生都可以随手编出一些漂亮不中用的程序。如果你整天寻找这样的程序挑来挑去，永远也找不到你满意的。

我曾经也犯过这样的错误，优秀的 FVWM, lftp, Mutt, wget
都被我忽略过！当我找回它们的时候，我是那么的羞愧不已，它们现在都是我的朋友
:) 用这些程序你可以改变它们的一切，我第一次看到 FVWM
觉得它只不过是一个有很厚很难看边框的东西。可是现在，我的同学看到 FVWM
都说：“哇！真漂亮。”

2. 有另一种完全不同的方式可以达到相同的目的，甚至更好。

很多人很关心 Open Office, Star Office, AbiWord, ...
他们多么盼望有一天某一个 Linux 程序能够完全兼容的打开一个复杂的 doc
文档。但是你永远也不可能有那一天。为什么呢？因为微软为了占有市场，必定不会让其它系统的程序能够完全兼容它的文档格式！它一定会不断变化
doc 文档的内部结构，隐藏一些秘密，让其它公司的程序打开 doc
文档时总是有某种问题，从而你必需购买 Microsoft Office 和Windows。

你应该想一下，那么多的高智商的大学教授，科学家，学生，他们用的都是
Linux 或者其它类型的 UNIX，他们没有 Word
可用，怎么处理文档呢？这么多年没有一个像 Open Office
的程序出现，难道大家没有办法写文档吗？

显然不是这样。你看看那些高水平的学术杂志，论文，那些大学教授的网页，那些漂亮的PDF幻灯片，它们是什么做的？原来
UNIX 用户早就有非常方便的 troff, LaTeX, SGML
等东西可以处理文档，而且它们比起 Word 都要高明的多。Word
显然被这些大拿忽略了，以至于很久以来没有人想在 Linux 下开发一个类似 Word
的程序，除非某些公司想抢微软的饭碗。

很多人留着 Windows 在硬盘上的原因无非是为了用 Word 和
PowerPoint。你待会儿可以看看我的TeX网页，你就会知道为什么我可以完全离开
Windows.

***** Windows 能做的那些没用的事情 Linux 永远做不好

1. 电脑游戏

有些人说 Linux 下不能玩 Windows 下所能得到的所有游戏。的确，Linux
下虽然也有少量的游戏，比如 Quake。但是它没有 Counter Strike, 没有 Star
Craft, ......

并不是说电脑游戏不该玩，但是应该适可而止。电脑是用来处理事务，帮助你学习，解决问题的工具，而不是一个玩具！整天沉迷于电脑游戏中，而不出去感觉外面的世界，你会变得越来越冷酷，越来越缺乏人情味。你与真实的世界越来越远。

你可以在 CS 里杀人，你可以在 Tomb Raider 里探险，你甚至可以在 Tony
Hawk's Pro Skaters 里滑板...... 但是 It's not
real！你虽然有很高的“反恐技巧”，但是遇到歹徒的时候，你是那么的怯懦；你虽然控制
Laura 伸手敏捷，但是你打篮球的时候怎么总是被人断球？你虽然可以轻易的在
THPS 里作出一个 "360 kickflip to hangten grind to
fakie"，但是你踩在自己的滑板上的时候还不会 ollie！

说回来，如果你偶尔玩一下电脑游戏未尝不可。但是世界上有远比 Windows
+ PC 更好的游戏方式。Sony 的 PlayStation2, SEGA 的 DreamCast, Nintendo
的 N64，Namco 的街机......每一个都比 Windows
游戏精彩，每一个都有如此高的3D性能，以至于 Pentium4, Itanium + GForce4
都无法与它们比美！

Linux
的用户们都是关心解决世界的关键问题的份子，他们哪里有时间用自己的机器来玩游戏啊？他们每天用Linux高效的做完自己的工作就到阳光下享受自然去了。要玩游戏也是玩一些类似推箱子，贪吃蛇之类的智力小游戏。所以，你知道为什么
Linux 几乎没有游戏了吧？:)

2. “整理硬盘，优化系统”

这是一个非常有意思的话题，仅次于有关“病毒”的话题。相信很多 Windows
用户都有整理硬盘的经历。在很多 Windows
用户眼里，“硬盘用久了，会出现碎片，速度会减慢，需要一个程序来整理，整理硬盘的时候不要做其它工作”，这好像是天经地义的事情。

我也曾经津津有味的看着 Norton Defrag
一点一点的把我的硬盘排序，调整，用图形的方式显示出来，然后报告：“100%
没有碎片。你的硬盘现在已经达到最佳状态。”
我现在才发觉我那时是多么的幼稚。

Linux 和 UNIX
用户似乎从来没有“整理硬盘”这种说法呢？你觉得很奇怪吗？如果你觉得很奇怪，那说明你的思想在某种程度上被微软的垃圾程序禁锢了。你需要明白，UNIX
的大型主机很多必须是一天24小时，一年365又1/4天不停运转的，要是每个星期都要整理一次硬盘，在整理的时候几乎不能干任何事情，那是绝对行不通的！

Linux 机器根本不用整理硬盘，这就是为什么没有看到过 Linux
用户整理硬盘。Linux 的文件系统是比 Windows 的 FAT, FAT32, NTFS
高明得多的文件系统，它们不但可以对文件设置权限，实施完全的保护，而且可以“越用越整齐”，“越用碎片越少”！你应该把文件大部分放在
Linux 的分区，而不是 Windows 分区，因为它比 Windows 分区可靠得多。

还有更滑稽的事情就是有很多“Norton System Doctor”，“Windows
优化大师”，“超级兔仔注册表魔法”
之类的程序存在，而且价格昂贵。似乎一个操作系统本来应该有很多问题，需要别的厂商做程序来“优化”它，而且为了得到优化，你需要付钱！这些问题
Linux 根本就没有，所以不需要什么优化。Linux 内核本身就是高度优化的。

3. IDE

有些人在抱怨为什么 Linux 没有一个良好的 IDE 开发环境。Linux
现在已经有一些 IDE 了，但是总是有很多问题。你是不是正在寻找，正在期望
Linux
某一天可以有一个VC那样的开发环境？你有没有发现你正在进入微软给你设下的怪圈？你为什么一定要用
IDE？你说：“IDE 开发迅速，调试方便，适合大型程序......”
那说明微软的程序在你脑子里已经比较根深蒂固，你需要好好清醒一下了，看看我来告诉你。

高明的 UNIX 程序员不用 IDE，IDE 从来就是给初级 Windows 程序员用的。

你看看大型的 UNIX 程序，包括 Linux 内核，各种网络服务程序，Xwindow
程序在内，哪一个是 IDE 搞出来的？我们实验室的 EDA 程序也没有一个是 IDE
弄的，我还知道 Candence, Synopsys，Mentor 的高性能的图形界面 EDA
程序也都不是 IDE 写的。你信不信，微软的人在写 Windows
本身的时候也根本不用 IDE！

有一次某杂志采访一些出名的 Linux 内核程序员，包括 Linus
在内，没有一个人用 IDE，有的人用 VIM，有的用 Emacs，只有 Linus 说“GNU
Emacs is evil”，但是其实他用的是一种跟 Emacs 有同样键绑定功能的
MicroEmacs。大家都是用编辑器编辑了程序文件，然后用 make
这样的自动工具调用 gcc 编译器完成编译工作的。

我以前也编过 Windows 程序：应用程序，驱动程序。但是我没有用 VC 的
IDE。Linux 教育了我，我会在命令行调用 CL，我知道 CL 才是 VC
的编译器。我可以在 cygwin 的 Makefile 里使用 CL。我还知道 CL
的参数都有什么用处。但是这些不是一个从一开头就用 IDE
的人能很快理解到的。

我相信: IDE is evil。我有一些用 Windows 的 IDE
写程序的朋友，他们对那套东西已经很精通了。但是我却惊奇的发现，他们竟然把编译器和汇编器的概念都分不清楚，甚至有的人连“编辑器”和“编译器”都搞混淆了！他们只知道在一个窗口里输入了代码，点击一个按钮就可以编译程序，但是这里面到底是怎么工作的，他们不知道！他们被盖在上面的窗口挡住了视线，甚至会以为那个按钮就是编译器！

他们对那些 IDE
的热键背的滚瓜烂熟，但是我却看到他们在一个函数一个函数的把别人的 ANSI
风格的代码变成 VC 的风格。想想这件事在 VIM
里有多么简单，一瞬间就可以搞定。

为什么 UNIX 程序员不用 IDE？明白了这个道理你就能体会到 UNIX
的设计思想了。首先，一个 IDE
集成了编辑器，编译器，汇编器，调试器，跟踪器......
这个编辑器功能肯定比不上 VIM 或 Emacs，编译器比不上 GCC，汇编器比不上
as，调试器比不上 gdb, ddd, 跟踪器比不上 strace, ltrace,
truss。你得到的是一套整合的低能的程序。如果你对调试器的功能不满意，你只好换用另外一套
IDE，但是这套 IDE 的热键，菜单，编辑器功能，按钮......
跟原来那个有很大不同。你不得不花很多时间来熟悉新的环境，而不能保持原来的某些东西。

而在 UNIX 下就不一样了。你可以用你最喜欢的 VIM 编辑程序，你在 VIM
里可以调用 GNU make，make 可以调用 gcc, ld, ... 实际上 make
能帮你很多忙。make 的出错信息可以被 VIM 捕获，VIM
能帮你在源程序里定位。你如果喜欢 icc, 你可以让 make 用 icc 而不是
gcc。你如果觉得 gdb 跟踪变量时比较麻烦，你可以用 ddd
来显示各种数据结构之间的关系。你还可以在 Emacs 里调用
gdb，那样就可以同步显示源代码了。而且 VIM 和 Emacs
还可以编辑很多其它东西，比如信件，LaTeX 文档，HTML，配置文件......
你不用另外找一个什么编辑器来干这些杂活了。很多程序比如 Mutt, tin
都可以在内部使用 VIM，这样就更方便了。

4. 释放内存

我在 Windows
下做过的一件最傻的事情莫过于“释放内存”了。有一天我看到一个 Windows
程序说：“这个程序可以帮你把大量内存释放出来给一个很大的程序用。”我试了一下，居然一下把我的
64M 内存释放出来
48M！我高兴极了。现在想一想，那是多么傻的事情，那么多的内存留着干什么？不用白不用啊！一个操作系统，居然还需要别人写的程序来释放内存，那是什么样的操作系统？

在 Linux 下用 free
命令，你会发现你的内存几乎每时每刻都快要被用完。那是因为 Linux
把大部分内存用来作为磁盘缓冲了。Linux 有比 Windows
先进的磁盘缓冲技术。你有没有发现你往硬盘写数据的时候，很快就完成了？那是因为
Linux
在内存里有很多磁盘缓冲区，你要写到硬盘上的数据先被写到了这些内存里，然后
Linux 就告诉你“拷贝完成”，当你马上又想删除刚才写入的某些数据时，Linux
只是把数据从内存里移除，然后报告“删除完成”。在一定的间隔时间后，Linux
才把数据写回硬盘，这样不但高效，避免了多次硬盘操作，而且减少了文件的不连续，也就是减少了“碎片”。Windows
当然也有磁盘缓冲，但是由于它内存管理的低效率，它不敢把大量内存都用来作为磁盘缓冲，因为它没有能力在用的时候随时把内存收回来。

***** Linux 能干的高级的事情 Windows 都干不了

当然有很多事情是Linux/UNIX的专利了。因为 Windows 只能装在 PC
机上，好像以前也有 Alpha 可以使用 Windows NT，但是就是没见到有人用。PC
机的能力是很低的，像我们编程序处理 NP-Hard 问题的人，用 Windows
的机器显然速度不够，而且有时一个问题算上几天甚至几个星期，Windows
机器是以“死机”著称的，我们怎么能放心？

所以几乎所有科学计算程序，EDA 程序，高性能图像处理程序都不是 Windows
的。他们有时也会移植一些给 Windows，但是常常降低那些程序的能力。你比较过
Windows 版本的 Mathematica 和 Linux 的有什么区别吗？

IBM 制造的最大的并行计算机有 8000 多个处理器，Windows
不可能有能力管理这么多处理器，它用的是什么操作系统？答案是 Linux。

《[[http://fifid.com/site_search?cx=003017831450918707819%3Ae2pgfm8nybw&cof=FORID%3A10&ie=UTF-8&q=%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7][泰坦尼克号]]》电影里的三维动画，那么细腻逼真，Windows机器能做出来吗？不行。那也是
Linux 机器做的。

民航总局用来训练地情人员的虚拟现实训练设备，Windows
当然无能为力。那都是商业的 IRIX 机器。

UNIX 是最早支持 TCP/IP
网络协议的系统。它上面有很多可以互相协作的网络服务程序，它们经过多年的使用和修订，已经达到比较完善的程度。而就在1997年，微软的比尔盖茨还在扬言：“Internet
是没有前途的。”
微软的这个“远见卓识”大家应该都已见识，它后来加上的网络服务程序IIS漏洞之多，让公安部都频频发出警报，大家也是见识了的。

其实你知道了，Windows 没有一样有用的事情能比 UNIX 干的更好。

***** Linux 干不了的有用的事情 Windows 照样干不了

当然 Linux 不是万能的。它也有不能干的事情，电脑也有干不了的事情。但是
Linux 干不了的事情，Windows
肯定也干不了。这些事情就是我们需要探索，需要努力的事情了。在你探索的过程中，Linux
必定是你的好伙伴。

Windows 的流毒

不要用 Windows 的方式来思考问题

什么？你早就知道 Windows
是垃圾？噢！你怎么不早说呢！害我废话这么多。嘿嘿。

“好了。你知道 Windows 是垃圾，你现在用什么？”

“Linux + Xwindow”

“那我问你，Xwindow 是什么样的？”

“不就是跟 Windows 差不多吗？只不过 'Start' 按钮比较方，而且上面不是一个
Windows
标志，而是一个脚丫子。点击一下居然还有很漂亮的中文菜单。我喜欢！”

“你知道什么是‘根窗口'吗？”

“不知道。从来没听说过呢？”

“根窗口就是遮盖整个屏幕的那个最大的窗口。”

“哪儿有什么窗口啊！我没有看到呢？”

你发现了问题吗？这些 Linux 用户说是在用 Linux 和 Xwindow，但是他们对
Linux 和 Xwindow 几乎完全不了解。很多人用了那么久 Xwindow
都不知道根窗口是什么东西，不知道其实按钮也是窗口，不知道窗口管理器和
Gnome，KDE
有什么关系，大家都以为窗口上面的按钮是程序自己放上去的，不知道窗口的“class
name”，“resource name”是什么东西。他们被遮在 Linux
之上的一层一层的包装迷惑了！

当我告诉一个既能用 Windows 又能用 Linux Qt 编程的朋友 Xwindow
的“中键粘贴”是怎么回事时，他大吃一惊，说：“Xwindow
怎么这么落后啊！居然请求剪贴板的东西时还要联系剪贴内容的所有者自己来转换格式！你看看
Windows 的剪贴板......” 经过一顿饭的友好的讨论之后，他不得不称认，这个
Xwindow 用了几十年的方法比 Windows 的剪贴板要合理的多。

后来又有一次，我告诉他每个 Xwindow 的按钮都是一个窗口。他说：“不会吧～
这样效率一定很低。你看看 Windows 的按钮 ......”
又是一顿饭之后，他说：“哎呀。不得不承认 Xwindow 的方式是良好的设计。”

现在很多人已经把能够利用别人的库写出一个好看的程序作为自己编程水平的象征。在这个“图形化”，“可视化”
的年代，你如果还在用 troff, LaTeX 写文档，你还在用 VIM 自己编辑 HTML，用
Mutt 处理邮件，你还在用文本模式的 gdb 调试程序，你还在用 Xlib 写程序,
你还在用 tin 上 USENET，你还在自己写 Makefile，写机器代码，你还在玩
Clossal Cave 这样的字符模式冒险游戏，那你就是老古董，不合时宜，变态。

其实这种思想是错误的。虽然你是一个坚决的 Linux 支持者，但是你的思想是
Windows
的思想。你认为图形界面，菜单，按钮就可以解决一切问题，就可以给你高效方便。你要做坚决的
GUI 派而不是 CLI 派 ......
你还是没能摆脱微软给你的潜移默化的东西。你其实离不开 Windows
那样的环境，你害怕符号，你迟早会删掉自己的 Linux。

***** GUI vs. CLI

UNIX 和 Xwindow 是一家

大家看到这个标题是不是热血沸腾？两派大虾都可以围攻我了：

GUI派用户：“哇！我一看你这小子就是 CLI 的。要不然自己写什么
Makefile？用什么 Mutt？”

CLI派用户：“切～ 你还用 X！高手都不用 X。你是 GUI 那边的。”

可怜的我：“555～～你们都不要我～～ GUI 和 CLI 就那么水火不容吗？”

计算机界这样的门派之分还很多。很有特点的就是 CLI 和 GUI 了。CLI (Command
LIne) 的狂热份子声称永远不用 X。我上次在实验室看到一个同学用一个
SecureCRT 登录到 Sun 机器，然后用一个 vanilla vi
编辑程序，我建议他启动一个 GVIM 过来显示在 Exceed
上可以有语法加亮。但是他坚决反对，说：“高手不用X。你想想，要是我在一个很慢的网络连接怎么用
X？而且好多服务器没有装 X 程序。”

但是我们实验室的网速可够快，Windows 机器都有 Exceed 啊，而且 Sun
机器有全套 X 客户程序包括 GVIM。他说他是 CLI 的坚决拥护者，但是他却在用
Windows，他后来打开了好几个
SecureCRT，每次从文本框输入地址，用户名和密码，从下拉菜单选择
"SSH2"，然后点击“Connnect”。他还不断的夸SecureCRT是“网络管理员投票选出的最受欢迎的登录方式”。老天，SecureCRT
本身就是个 GUI 啊，他其实是一个 GUI。

你说我是 GUI 的？我虽然很少在 console 下工作。但是我对 bash, VIM
很熟悉，我可以让 bash 按照我的键绑定方式来工作。我可以在 rxvt 里使用
Mutt 来收发 email。我的每个桌面上都常常堆放着一打不同大小的 rxvt。我用
VIM 编辑 LaTeX。我自己写 Makefile 来维护 LaTeX 文档。我有时用 mpg321
来放 mp3。我上BBS用的我自己写的 expect 脚本，定义了很多热键，我只要
Ctrl-H 就可以随机变化我的签名档和说明档。我的 expect
脚本有高级的自动回复功能，甚至可以以假乱真，让你看不出其实我不在，你有可能跟我的机器人聊上10分种才发现那不是我
:p 好了，CLI 派的朋友可以收我做盟友了 :)

你说我是 CLI 的老古董？我的 FVWM
被我配置为可以“手写操作”，我只要画一个"r"就可以启动 rxvt，我只要画一个
"U" 就可以启动 GVIM，...... 我用 GVIM 语法加亮模式编辑程序，我用 Mozilla
浏览网页，...... GUI 派的现在好像认我做朋友了 :)

好了。CLI
派的朋友，虽然我很喜欢命令行，但是我有时在屏幕上左右画一下就可以执行:

Module FvwmConsole -terminal rxvt -geometry 45x5-0+0 \

-bg gold -fg midnightblue \

-fn "-adobe-courier-medium-r-*-*-14-*-*-*-*-*-*-*"

你是不是现在又想把我逐出师门？

GUI 派的朋友，虽然我很喜欢窗口。但是我可以在 FvwmConsole 里输入：

All (rxvt) MoveToDesk

把我所有的 rxvt 移动到我现在工作的桌面。“这家伙，怎么这么快就叛变了！”

其实何必分什么 GUI 和 CLI，UNIX 和 Xwindow
都是工业标准，它们从设计那天开始就有非常灵活的用法，各个程序，不管是 GUI
还是命令行的都可以互相协作。UNIX 和 X
是一家，何必搞的那么偏激，非此即彼？你从我上面的行为可以看出 GUI 和 CLI
的模糊界线吗？你说我是“花心大萝卜”？花心就花心。hengheng :P

UNIX 的真谛何在？

***** 让聪明人干任何他们想干的事情。

UNIX 的一个特点就是非常高的灵活性，Xwindow
也具有这种灵活性。这种灵活性体现在哪里呢？

UNIX
的程序一般都有很多参数，不管你现在用的着用不着，总有人需要某些参数。它们的行为很多都可以用配置文件来改变。比如
GNU bash, 通常缺省的命令行输入方式是 Emacs 方式，但是只要我编辑一个
.inputrc 文件，就可以把它变成 vi
的输入方式，而且我还可以自己绑定键序列到某些操作。我可以用 shopt
来设置它的很多特点，比如是否进行通配符扩展，是否可以把一个变量当作一个目录来cd，是否可以自动纠正某些明显的目录名打字错误
......

UNIX
程序设计的思想是提供给用户“机制”，而不限制用户制定“政策”。这是一个重要的尊重用户的作法。

我们再来看看 Xwindow。Xwindow
是一个出色的设计，它把显示服务器和客户程序分开。一个显示上既可以显示本机上的程序，也可以显示别的机器上的
X
程序，而它们都遵守你的窗口管理器的统一指挥，它们之间可以方便的传送剪贴版数据，各种事件
...... 比如有时我的 XFree86 上会出现四个不同机器上的
XTerm，两个不同机器上的 GVIM，...... 它们统一受本机上的 FVWM 指挥。

Xwindow 程序都具有很多很多命令行参数和 resource
参数。你可以随意的在命令行或者 .Xdefaults
文件设置所有的颜色，字体，尺寸...... 而且如果你用 xrdb 把 .Xdefaults
导入到根窗口，那么其它机器上没有经过配置的同样的程序，显示到你的机器上的时候也会遵守同样的外观规定。

Xwindow 的窗口具有 Property,
也就是一些可以自己定义的共享数据(原子)。正是因为这些 Property
的存在，使得 Xwindow 具有无比强大的生命力。X
的窗口管理器和其它客户程序之间并没有统一的协议，但是后来出现了
ICCCM(客户程序间通信规范)，这个规范就是通过 property
定义的。现在又有人定义了一套“扩展的窗口协议(EWM Hints)”，使得 Xwindow
可以具有某些 Windows
的特征，比如一个工具条程序可以告诉窗口管理器：“这个屏幕下面被我占据了24个像素的空间，你最大化程序的时候不要越过这个界线。”

一个强大的窗口管理程序比如
FVWM，它收到这样的提示时，可以答应工具条程序的这个要求，也可以不答应。一切选择的权力在于谁？当然是用户了！一切窗口乖乖听话，FVWM
给予用户最大的尊重。

你想想，是不是有些 Windows 程序常常弹出一个窗口要你选择 "Yes or
No"？你不点击它它就不下去。你觉不觉得你的程序在侵犯你的尊严？你是一个人，一个智慧的生物，怎能受到一个程序如此的待遇？

还有就是很多 Windows
程序把人当成傻瓜，而它是“智能程序”。比如，有一个程序就是喜欢把你的每句话第一个字母都变成大写，我不说它是谁了，你遇到的时候就知道了。如果连“一句话开头一个字母要大写”这么明显的问题都需要程序帮你纠正的话，人脑还用来干什么？况且如果你故意想要不大写的话，那就更麻烦了，我楞是没有从它那一大堆菜单里找到怎么关闭这个愚蠢的选项。

***** 只有符号才能完全操纵计算机。

我们来说说很多初学 Linux 的用户。虽然他们在用
Linux，但是他们打心眼儿里是觉得 Windows 的工作方式好，他们希望 Linux
有一天能“像Windows那样”。你说：“我鼠标一点，我菜单一拉，......
就可以完成我的操作。” 但是我要告诉你：“Linux 从来没有摹仿
Windows，将来也不会。Linux 从诞生之日起，它的工作方式就比 Windows
的先进。Linux 属于能勇敢面对符号的人。只有符号才能完全操纵计算机。”

看看优秀的 UNIX 程序，XFree86, FVWM, VIM, Emacs, proftpd, Mutt, wget,
tin, ...
没有一个不是用配置文件来设置选项的。为什么这些程序没有方便的菜单可以用来配置？难道它们的设计者就那么低能，连个图形配置界面也写不出来？

当然不是。因为图形界面配置方式的能力是极其有限的，而配置文件和程序语言的表达能力却是无限的。用图形界面配置这些程序的话，如果你想达到配置文件的效果，你需要成百上千的菜单，checkbox,
radio button, ...
到时候你根本没办法找到你需要修改的地方了！而各个程序的配置文件的语法都有很多相似之处，一般就是一些命令，设置一些变量，参数，......
一旦用会了一个，其它的也就容易理解了。如果你用惯了 awk, sed,
Perl，你会觉得那才是真正的自动化啊。

鼠标虽然是很好的工具，但是它的表达能力是有限的。你不可能光用鼠标就让电脑完全明白你的意思，它毕竟只有3个按钮。看看我的MetaPost页你就能体会到鼠标的这一弱点。所以我们虽然很喜欢鼠标，但是却不能完全依赖它。

***** 各个小程序的完美配合

这就是UNIX最重要的特点了，它就是UNIX设计的思想。让每个程序只具有一项专门的能力，然后让它们合作。Xwindow也继承了这种好传统。

这恐怕就是Windows和其它操作系统望尘末及的地方了。UNIX
程序设计之统一，配合之完美，真使我难以置信！shell, grep, find, awk, sed,
make, Perl, Emacs, vi, tin, Mutt, ...
它们是那么的具有一致性！你一旦学会了 sed
的正则表达式，其它程序基本上都能用了。你一旦学会了 vi 和 VIM,
你会发现它的操作是那么的有规律性，似乎vi的设计者在几十年前就已经设计好了
VIM 在今天的完美而统一的操作方式！而且vi的操作还体现在 Mutt, tin
等很多程序中。你甚至可以把 bash 设置为 vi
的输入方式来输入命令行，我就是这么做的。一个程序可以调用另外一个程序来得到数据，可以把数据交给它处理后返回来，可以在自己的窗口里“嵌入”另外一个程序。

在 Windows 和其它非 UNIX 操作系统中，这种合作是非常困难的。我曾经在
Windows 下使用 Perl来进行一些自动工作。但是 Windows
的文件操作，管道是如此的不稳定，程序之间基本不能合作。你别想在 Visual
Studio 窗口里面嵌入 UltraEdit 编辑器，你别想用一个 expect 脚本来控制
telnet 到水木清华BBS，这就是为什么 helloooo 诞生在 Linux 而不是
Windows。我曾经试图从 Windows + Exceed + SecureCRT ssh 登录到 Sun
机器，然后通过 ssh 的隧道(X11 tunnel)把 X 程序传到 Exceed
上运行，但是搞了两天都没有成功！而在 Linux
下这个事情根本就是不用怎么配置的，OpenSSH 和 XFree86
本来就是完美结合，只要打开 ssh 的 "forward X11" 选项就什么都搞定了。

Windows
的程序都是大而全，大而杂，所有的电子邮件程序都需要自己提供编辑器，自己发送和收取邮件，自己显示邮件的附件。每一个BBS程序都提供自己的Virtual
Terminal, 自己的通讯代码。每一个 IDE
都自己提供编辑器，编译器，汇编器，调试器。人们为了使用一种新的程序，需要适应所有这些它提供的界面，而不能使用自己喜欢的编辑器的键绑定，菜单组织......
不能 DIY！

你要知道，最高级的电脑是定做的，自己想要什么什么CPU，什么主板，多少内存，什么硬盘，键盘，鼠标，显示器都是自己选择的。最高级的滑板，自己想要什么牌子的版面，什么牌子的沙，什么桥，什么轮子，什么轴承，也都是自己选的。最高级的乒乓球拍，木板，胶皮，海绵，胶水都是可以自己选择......
而用 Windows
程序，你得到的是大杂烩，就像你去买“品牌机”，只有那么几种配置，而且附带很多你不需要的软件和服务；就像你去买组装好的滑板，你想要大一点的轮子和窄一点的板子，但是你没有这种选择余地！Windows
程序就相当于最廉价，最次的滑板。但是它却会花你更多的钱，因为一旦一个部件坏了，或者你不喜欢了，你不能另外找一个好的换掉它，你必需重新买全套配件！

而 UNIX 和 Xwindow 就是高档的“组装货”。比如我用 Mutt 的时候，我可以用
VIM 也可以用 pico 来编辑邮件，我可以用 ImageMagick 也可以用 xv
来显示附件里的图片，我可以用 lynx 把 HTML
附件转成文本嵌入窗口中，我也可以把 HTML 附件交给 Mozilla
图形显示。我可以让 GnuPG 帮我把邮件进行数字签名和加密，我也可以用其它
PGP 程序。我想让 Postfix 而不是 sendmail 帮我发出邮件，我想让 fetchmail
帮我收邮件，转发给 postfix，然后被我自己写的Perl过滤器处理......
这一切我都可以办到！我可以选择我最喜欢的专门的程序来完成专门的工作，然后把它们结合在一起，我也可以分别得到它们的好处。

***** 结论

我写这么多的目的是什么？我希望喜欢 Linux 的朋友，完全清除微软和 Windows
灌输在你脑子里的谬论，别再相信它们所谓的“新技术”，别再追赶
Windows，因为追赶 Windows
＝倒退。马克思有一个思想很重要，“新生事物并不一定是在最近出现的。”
UNIX，Xwindow, TeX 虽然都比 Windows
先出现，但是它们才是先进生产力的代表。我们要清楚的认识到什么才是真正的现代化，什么才是真正的自动化。

勇敢的拿起像 bash, FVWM, TeX, VIM, Emacs, Mutt, lftp ......
这样强大的程序，勇敢的面对符号。不要再埋怨“Linux 为什么不能像 Windows
那样”，不要再浪费时间试用这样那样的程序，不要再忙着升级。需要改变的是你自己，而不是
Linux 和 Xwindow，Linux
现在就可以成为你的好朋友。你需要认识它，了解它，信任它，才能完全的靠它来高效的工作，省出时间来处理世界上更加值得处理的事情。

***** 附录: 我用来处理日常事务的 Linux 程序

好了好了。我知道你发现自己应该转向
Linux，你很后悔当初为什么中了微软的邪。但是不要着急。因为这些东西本来只是工具，它们是用来完成你的主要任务的辅助而已。你以前选错了工具，这不要紧。你还是拥有你自己原来的专业技能，那才是最重要的。工具的东西只有慢慢适应转换，不能一蹴而就，否则你会感到非常没意思，甚至放弃。

这里给出一些推荐使用的可以处理一般事情的程序。至于你的专业上要用到的科学和工程软件比如
Matlab, Mathematica, Maple, HSpice, Design Compiler, ......
还有其它物理上的，化学上的，生物上的 ...... 都必然有 Linux 和 UNIX
的版本。当然他们很多不是免费的，不要总是觉得什么都应该免费，它们是经过很多人辛勤劳动的产物，是可靠的程序，他们物有所值。

下面列出我常用的一些 Linux
程序。一个列表里可能有很多，那是为了方便你来选择，我列出了比较信得过的。但其实很多只有第一个是我真正在用的。我不喜欢试用程序。


- Shell: bash。我使用 bash 的 vi 命令行方式。

- 编辑器： VIM, Emacs

- 程序开发： GCC, make, ld, Scheme48, j2sdk, Perl, Python, Tcl/Tk ...

- 论文，幻灯工具：LaTeX, ConTeXt

- 绘图工具：MetaPost。这个语言太强了，以至于我只用它了。你不熟悉的话可
  以用dia 来画一些流程图之类的图片。

- 图像处理：ImageMagick。其中的 import 程序可以屏幕抓图，convert程序可
  以转换图像格式，display可以显示图片和简单编辑(缩放，换质量，转格式，
  简单绘图，简单虑镜)。通常我就这么点需要。如果你要更强大的图像工具可
  以用Gimp, 它几乎和 Photoshop 差不多。

- 自动管理工具：make。我可以用make来自动编译程序，自动编译文档，自动更
  新插图......全自动，而且不会重复劳动。

- 加密程序：GnuPG。我的 PGP 密钥就是它搞出来的，我用了 2048 位加密。

- 打包，压缩程序。什么都有: tar, gzip, bzip2, zip, rar, ...

- 虚拟光驱程序。Linux 不需要虚拟光驱程序，直接 mount 就行了。

- ftp 服务器：proftpd, vsftpd

- WWW 服务器：apache。(我一般没有开)

- ftp 客户程序：lftp

- 自动下载工具：wget

- 虚拟终端：rxvt, xterm, gnome-terminal, mlterm, ...

- X server: XFree86

- 窗口管理器：FVWM。编译加入了 libstroke。

- 中文输入：XSIM。被我修改过以适应 FVWM 的需要。另外推荐你还可以用SCIM。

- email 处理：Mutt + Postfix + fetchmail

- 看 PDF, PS, DJVU 文件：Acrobat Reader, xpdf, GhostScript, gv,djvu工
  具包和 netscape 插件。

- 看CAJ文档。我从来不看CAJ之类的文档，如果找不到PDF或PS，直接去图书馆借最好。

- 看网页：Mozilla, Phoenix, lynx。Mozilla-Xft 的显示效果比 IE好很多。

- 英汉字典：IBM智能词典，星际译王。

- 编辑网页：我用 VIM 直接写HTML。你如果想要图形方式的可以用其它的比如
  screem, BlueFish。

- 登录其它 UNIX, Linux 机器：openSSH, telnet。 openSSH 还可以把其它机
  器的 X 程序通过 ssh 加密的隧道传到我机器上显示。

- 上BBS：rxvt(或任何一种终端) + telnet + chatbot(helloooo机器人的程序)

- QQ, ICQ: 我没有 QQ 或 ICQ。不过你可以用 Gaim, 它同时支持 QQ, ICQ 和
  很多其它的即时通信方式。ICQ 用户也可以用 Licq。

- 放录像：MPlayer, RealPlayer。MPlayer 太好了，直接就可以放 VCD,
  DVD,divx, wma, wmv ... 用 Windows 的同学都很羡慕我，说 Windows要放这
  个需要大堆插件。rm 最好还是用 realplayer 放，它也是免费的。

- 放音乐： xmms(mp3,ogg都可以), mpg321(放mp3), ogg123(放ogg).

- 看 Word 文档。请 Word 用户把文档全部转为 PDF 或 PS 再给我，文档里没
  有特殊的格式就用文本文件，要不我就不看 :P

- 其它程序：还有很多我需要用而你不一定用得着的。比如，Doctor
  Scheme,Scheme48, Scsh, ...这些程序只有 Doctor Scheme有Windows版本。
  还有很多幕后工作但是你一般不察觉的：xinetd, telnetd,sshd, crond,
  atd, lpd, ... 他们都比 Windows 的对应者强的多。
**** 心灵鸡汤

有只黄鼠狼，在养鸡场的山崖顶上立了块碑，上面写着：“摆脱禁锢，不勇敢跳
下去，你怎么知道自己不是一只老鹰？”于是，它每天就在崖底等着吃摔死的鸡。
——这个故事告诉我们，阅读心灵鸡汤时需要智商，大多鸡汤都是黄鼠狼写的。

原来鸡汤是这样熬成的！

* Previsous
** w2
*** 2016/01/16
**** irc                                                             :irc:

[[/home/wally/Wally/Journal/Figure/scrot/30980jYW.png]]

***** what?

- [[http://baike.baidu.com/link?url=jB5JRb4FBbjGCs8fKheTymXOqf6zMaalCSvNR7_lkkrsjRbrgKPKS3a7jLchJcJ2x2OQMt4J4TuYSkzb_kZb2sdoG0dAMnLrVcXd1Nooo7y][百度百科]]

IRC是Internet Relay Chat 的英文缩写，中文一般称为互联网中继聊天。

它是多用户、多频道的讨论系统，许多用户可以在一个频道内就某一话题进行交
谈或私谈，每个用户都有一个不同的昵称。IRC允许任意的因特网用户之间做即
时的交谈。

IRC用户使用特定的用户端聊天软件连接到IRC服务器，通过服务器中继与其他连
接到这一服务器上的用户交流，所以IRC的中文名为“因特网中继聊天”。

***** features

- [[http://www.zhihu.com/question/24851247][知乎：为什么现如今还有人使用 IRC 聊天交流？
]]


- IRC 协议简单，开源实现多，本来就备受开发者青睐；
- 因此，其第三方机器人程序非常众多，开源实现库一抓一大把，任何想做多人同用机器人的开发者，都可以轻易上手，几乎每种语言都有一个实现，不必去望洋兴叹。
- IRC 不用登录，不用注册；但如果你注册了，就可以强制把占用自己唯一ID 的人踢下线。
- IRC 也可以私聊。
- IRC 也有特殊权限。
- IRC 是开源社区会议标准；
- 因此，IRC 在开源社区用得比较多；
- 因此，许多开源世界的技术大牛混在那里。

***** 客户端

- [[http://wiki.ubuntu.org.cn/IRC%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%89%E5%93%AA%E4%BA%9B][Ubuntu Forum: IRC 客户端有哪些]]

****** 网络浏览器

Firefox插件

- [[https://addons.mozilla.org/en-US/firefox/addon/16][火狐插件ChatZilla]]

****** 网页

- [[http://webchat.freenode.net/]] Freenode封了Mibbit后自己搞定HTML版本
- [[https://irc.gitter.im/]] Beta，兼容lynx
- [[https://kiwiirc.com/client]] 神抛弃老旧Opera后的选择

****** QT

- [[/Quassel][Quassel]] 配合KDE功能强悍
- [[https://konversation.kde.org/][Konversation]] KDE的默认客户端
- [[http://www.kvirc.net/][KVIrc]]

****** GTK

- [[/IRC@Pidgin][Pidgin]]
- [[/Xchat][xchat]]

****** CLI

- [[http://irssi.org/][irssi]] CLI界面IRC工具
- [[http://www.gnu.org/software/emacs/][ERC]] 神的工具，神的ERC *Emacs IRC*

**** ERC                                                         :erc:irc:

- [[~/Wally/Reference/Manual/ERCManual.pdf][ERCManual.pdf]]
- [[http://www.emacswiki.org/emacs/ERC][EmacsWiki:ERC]]


ERC is part of the GNU project. It is included with recent versions of
GNU Emacs.

ERC is included in released versions of GNU Emacs since v22.3.

使用： M-x erc

**** blender

https://zh.wikibooks.org/zh-cn/Blender_3D%EF%B8%B0%E5%BE%9E%E5%85%A5%E9%96%80%E5%88%B0%E7%B2%BE%E9%80%9A

http://wiki.blender.org/

**** matlab 启动错误

#+BEGIN_EXAMPLE
  Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar
#+END_EXAMPLE

[[http://askubuntu.com/questions/615644/after-upgrading-ubuntu-14-10-to-15-04-i-am-no-longer-able-to-open-matlab-2013a/617059#617059][Ubuntu fomula]]

This package is responsible for application menu support for Java
swing applications, and seems to be the cause for the segfault.

#+BEGIN_EXAMPLE
sudo apt-get remove jayatana
#+END_EXAMPLE

没有解决问题。

[[http://www.mathworks.com/matlabcentral/answers/50971-matlab-r2012b-java-exception-error-starting-desktop][Mathworks]]

以超级用户身份执行 matlab, 解决问题, 不明所以。

#+BEGIN_EXAMPLE
Same thing happens to me on a macbook. Same exception, exception disappears when starting matlab using sudo.
#+END_EXAMPLE

Most likely you don't have write permissions on your preferences
directory. You can determine the location of the MATLAB preferences
folder by running the PREFDIR command at the MATLAB prompt.

If for some reason you're unable to fix the permissions, you can try
changing the prefs directory location:
http://www.mathworks.com/support/solutions/en/data/1-37KDWN/

In Matlab.
#+BEGIN_EXAMPLE
>> prefdir

ans =

/home/wally/.matlab/R2014a
#+END_EXAMPLE

#+BEGIN_EXAMPLE
   ls -l .matlab/R2014a/
  总用量 1536
  -rw-r--r-- 1 root root     12  1月 15 10:58 cwdhistory.m
  -rw-r--r-- 1 root root    512  1月 15 11:04 History.xml
  -rw-r--r-- 1 root root   6070  1月 15 11:03 MATLABDesktop.xml
  -rw-r--r-- 1 root root   6092  1月 15 10:58 MATLABDesktop.xml.prev
  -rw-r--r-- 1 root root    429  1月 15 10:57 matlab.prf
  -rw-r--r-- 1 root root   8864  1月 15 11:02 matlab.settings
  -rw-r--r-- 1 root root    201  1月 10 14:03 shortcuts_2.xml
  -rw-r--r-- 1 root root 553920  1月 10 14:03 toolbox_cache-8.3.0-2211579006-glnxa64.xml
  -rw-r--r-- 1 root root 970053  1月 15 10:58 toolbox_cache-8.3.0-903067591-glnxa64.xml
#+END_EXAMPLE
所有者为 root 用户。。。


问题找到了。但是不想修改 predir ，因为麻烦。折衷使用超级用户权限运行
matlab

Note: 在终端使用 C-c 结束 Matlab，反应慢，在 GUI 上点击关闭按钮。

**** mark-ring list ?

因为经常需要转换任务，所以可能会忘记之前的任务。

org-mark-ring-push

#+BEGIN_EXAMPLE
org-mark-ring-push is an interactive Lisp function in `org.el'.

It is bound to C-c %, C-c 4.

(org-mark-ring-push &optional POS BUFFER)

Put the current position or POS into the mark ring and rotate it.
#+END_EXAMPLE

org-mark-ring-goto

#+BEGIN_EXAMPLE
org-mark-ring-goto is an interactive Lisp function in `org.el'.

It is bound to C-c 5.

(org-mark-ring-goto &optional N)

Jump to the previous position in the mark ring.
With prefix arg N, jump back that many stored positions.  When
called several times in succession, walk through the entire ring.
Org-mode commands jumping to a different position in the current file,
or to another Org-mode file, automatically push the old position
onto the ring.
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-<f1>") 'org-mark-ring-push)
  (global-set-key (kbd "C-<f2>") 'org-mark-ring-goto)
#+END_SRC

**** wine 百度云

不行，别折腾

**** sdl                                                             :sdl:

***** sdl

[[https://www.libsdl.org/][Homepage]]

Simple DirectMedia Layer is a cross-platform development library
designed to provide low level access to audio, keyboard, mouse,
joystick, and graphics hardware via OpenGL and Direct3D.

****** install                                                 :install:

#+BEGIN_EXAMPLE
 $ sudo apt-get install  libsdl2-2.0-0
#+END_EXAMPLE

***** sdl_image                                               :sdl_image:

- [[http://www.libsdl.org/projects/SDL_image/][Homepage]]
- [[http://jcatki.no-ip.org:8080/SDL_image/][Document]]


SDL_image is an *image loading library* that is used with the SDL
library, and almost as portable. It allows a programmer to use
multiple image formats without having to code all the loading and
conversion algorithms themselves.

****** install                                                 :install:

#+BEGIN_EXAMPLE
 $ sudo apt-get install libsdl-image1.2
#+END_EXAMPLE

**** 学习时不要听 Eason 的歌

听 Eason 的歌太容易入神。

听一些舒缓的轻音乐。

*** 2016/01/14
**** supply

***** connector

输入： KF128-2
输出：5557 https://item.taobao.com/item.htm?id=41139630227&ali_refid=a3_430582_1006:1104098595:N:%E6%8F%92%E6%8B%94%E5%BC%8F%E6%8E%A5%E7%BA%BF%E7%AB%AF%E5%AD%90:cd6bd631faf7c8d74c8748dd98c47073&ali_trackid=1_cd6bd631faf7c8d74c8748dd98c47073&spm=a230r.1.14.3.Ozxn0o#detail

***** protector

电容：100uF/A

[[/home/wally/Wally/Journal/Figure/scrot/3098085D.png]]

二极管：


开关电源？

***** ref

[[https://app.yinxiang.com/shard/s52/nl/11551545/273c7e8c-dacd-4f22-a004-bb30aec5d710/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D152408a07ab%3AS%3Df5af2039594c32603700a7a7b6d115dc][直插式电阻电容封装与尺寸图解]]

[[https://app.yinxiang.com/shard/s52/nl/11551545/96b290e4-eb4d-4148-b51a-72fa4469c77e/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D152408b2f28%3AS%3D9a57fbc29200b7dff1aed88c48aa5ab2][Protel中Cap,Cap2，Cap Pol的区别]]

**** irc

[[/home/wally/Wally/Journal/Figure/scrot/30980jYW.png]]

*** 2016/01/13
**** cedet

使用 git 版的 cedet, 在 load 配置文件时与内置 cedet 矛盾

#+BEGIN_EXAMPLE
error:Cannot unload builtin CEDET since it is already loaded
#+END_EXAMPLE

解决： 将 cedet 的加载配置放在前面

*每次折腾 Emacs C++ IDE 都好烦人！！！*

**** emacs clang

#+BEGIN_SRC emacs-lisp
  (setq company-backends (delete 'company-semantic company-backends))
  (define-key c-mode-map (kbd "C-<tab>") 'company-complete)
  (define-key c++-mode-map (kbd "C-<tab>" 'company-complete)
#+END_SRC

**** wordpress

***** reference

- [[https://cn.wordpress.org/][Homepage]]
- [[https://github.com/wordpress/wordpress][Github]]
- [[https://github.com/punchagan/org2blog][org2blog]]

***** [[http://www.trinea.cn/other/choice-between-wordpress-and-github-page/][WordPress VS GitHub Page]]

****** WordPress和github page的选择和搭建

搭建博客时对wordpress和github page进行了简单的对比，最终选择了wp。

这里就简单对比下wp和gp的优缺点及搭建过程简介。主要比较方面包括*搭建复
杂度、对域名空间要求、写博客的便捷程度、开放性（主题、工具插件）、访问
速度、SEO优化、迁移成本

****** ps: 下面介绍中github page使用octopress博客框架

首先如果希望能以独立域名访问，域名的注册是必不可少的，可选择[[http://www.net.cn/domain/][万网]] 或 [[http://www.west263.cn/services/domain/][西部
数码]]等

*a. 搭建复杂度*

wp近乎傻瓜式；github较复杂，需要安装不少软件，而且还可能有莫名的错误，
需随时google解决结果：wp胜出，当然喜欢折腾或是对ruby相当熟悉的话可能差
别不是很明显。


*b. 对域名空间要求*

wp需要自己购买虚拟主机，低配大约在100-200RMB/Y，主机需要有lamp的环境运
行wp，不过现在的linux虚拟主机一般都提供此环境；

github page的一大优点就是不需要虚拟主机，它是可以发布到githubpage上的。

结果：github page免费优势明显

*c. 写博客的便捷程度*

wp需要打开后台，在后台撰写文章，即时写当然是需要联网的。wp的强大插件使
得博客文字样式可以很丰富
githubpage支持本地编写、本地预览，满意后再发布，并且支持markdown语法所
以对于不少程序员可能会比较方便。文本中直接编写极客的感觉*\_*

结果：对于不同人群各有优劣吧


*d. 开放性（主题、工具插件）*

wp的主题和插件是无比丰富的，这是选择wp的一大原因之一，不过插件多同时也
带来了另一个问题就是质量良莠不齐，选择相当麻烦费事，org~，之后会分享自
己装的觉得还不错的插件。

octopress相当来说发展没多久，插件方面没怎么调查，不过主题是标准的程序
员黑，自己改css相当费事

结果：wp胜出

*e、访问速度*

wp的访问速度与虚拟空间地址有关，不过我挂在朋友的购买的国外虚拟空间上速
度感觉也还不错

github的访问速度感觉与其他国外网站比还是较慢的，这几天刚好因为抢票插件
被封

结果：看具体虚拟空间的选择


*f、SEO优化*

wp不少插件提供seo优化功能，但也需要发博客时自己填写不少信息比较麻烦

githubpage搜索引擎优化就不需要自己做了，并且github在google上权重肯定相
当高，所以优势明显

结果：github page胜出

*g、迁移成本*

wp的迁移需要将网站目录迁移、数据库备份后再导入即可octopress的迁移也还
好，就算不利用githubpage的话，自己有一套ruby和nginx的环境的话也是可以
很方便重新部署的

结果：旗鼓相当

我比较在乎开放性（主题、工具插件）、写博客的便捷程度、访问速度、迁移成
本四点。尤其对第一点比较看重，所以选择了wp，不过比较插件真是差点被折腾
死||\_||，在wordpress和github

page的搭建中有自己安装的比较好的插件.

*PS：搭建过程*

wordpress搭建：下载 [[http://cn.wordpress.org/][最新wordpress包]] ，解压上传。直接访问index.php，按
照提示填写数据库信息即可（可以自己将个数据库）。

githubpage博客搭建参考[[http://www.hopes4.me/post/2012-02-29-introduce-octopress-on-github][在github上用octopress搭建博客]]， 关于ruby的安装可
参考 [[http://blog.sina.com.cn/s/blog_6b59aaa701017sff.html][Ruby在windows下的安装]]。

**** gtags

http://tuhdo.github.io/c-ide.html#orgheadline37

GNU Global has an environment variable named *GTAGSLIBPATH*. This
variable holds GTAGS database of _external libraries_ that your project
depends on but not inside your project. For example, your project may
rely on *system headers* such as stdio.h, stdlib.h… but these headers
are internal to your project.

However, remember that you can *only jump to tag definitions* of
external dependencies, and nothing else (such as files or
references).

But, again, once you are inside the external
library, you can start jumping around sicne it becomes your current
project.

#+BEGIN_EXAMPLE
export GTAGSLIBPATH=$HOME/.gtags/
#+END_EXAMPLE

**** xsel                                                           :xsel:

Manipulate the X selection

sudo apt-get install xsel

***** option

+ -b, --clipboard       Operate on the CLIPBOARD selection
+ -o, --output          Write the selection to standard output
+ -i, --input           Read standard input into the selection

***** usage

1. 复制内容到剪贴板中

   #+BEGIN_EXAMPLE
   cat file | xsel -i -b
   #+END_EXAMPLE

2. 取出剪贴板内容

   #+BEGIN_EXAMPLE
   xsel -o -b
   #+END_EXAMPLE

**** /usr/local 空间不足

/usr/local 挂载的分区大小为20G，完全不够用

移动 /usr/local/MATLAB 并建立软链接后，MATLAB 启动不了

以同样的方式处理 texlive 暂时没有问题

*** 2016/01/12
**** latex2html                                         :latex:latex2html:

***** reference

- https://www.ctan.org/pkg/latex2html?lang=en
- https://www.ctan.org/tex-archive/support/latex2html
- [[~/Wally/Reference/Manual/LaTeX2HtmlManual.pdf][LaTeX2HtmlManual.pdf]]

***** install                                                   :install:

#+BEGIN_EXAMPLE
$ ./configure & make & sudo make install
#+END_EXAMPLE

**** sdcv history                                                   :sdcv:

*$(HOME)/.sdcv_history*

**** fcitx 启动不了

#+BEGIN_EXAMPLE
  $ fcitx &


  (INFO-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/addon.c:151) 加载附加组件配置文件: fcitx-vk.conf
  (WARN-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/addon.c:298) 禁用插件 fcitx-ipc，依赖 fcitx-dbus 无法满足。
  (ERROR-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/frontend.c:565) 无可用前端
  (ERROR-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/instance.c:437) Exiting.
#+END_EXAMPLE

- 原因： 配置错误
- 解决：删除配置文件

  #+BEGIN_EXAMPLE
     mv ~/.config/fcitx ~/.config/fcitx.bak
  #+END_EXAMPLE

- 暴力解决(不推荐)

  #+BEGIN_EXAMPLE
    $ sudo dpkg -P fcitc*
    $ sudo apt-get install fcitx
  #+END_EXAMPLE

**** fcitx 切换输入法与 xmodmap 冲突

使用 gnome-tweak 解决

**** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

**** make -jn

多线程编译

用于多cpu的系统编译，n一般是cpu个数的2倍。

*** 2016/01/11
**** bash completion

#+BEGIN_EXAMPLE
For auto-completion, do not forget to install 'ct-ng.comp' into
your bash completion directory (usually /etc/bash_completion.d)
#+END_EXAMPLE

*/etc/bash_completion.d*

**** gazebo & ros jade

- [[http://answers.ros.org/question/217970/ros-jade-and-gazebo-50-migration-problem/][Q&A: ros jade and gazebo 5.0 migration problem]]

#+BEGIN_EXAMPLE
/opt/ros/jade/lib/gazebo_ros/gzclient: 17: .: Can't open /usr/share/gazebo//setup.sh
[gazebo_gui-3] process has died [pid 2459, exit code 2, cmd /opt/ros/jade/lib/gazebo_ros/gzclient __name:=gazebo_gui __log:=/home/wally/.ros/log/4fb3d678-b80e-11e5-9dba-002186ef9d91/gazebo_gui-3.log].
log file: /home/wally/.ros/log/4fb3d678-b80e-11e5-9dba-002186ef9d91/gazebo_gui-3*.log
#+END_EXAMPLE

*installing the gazebo5 package seems to have solved the
problem*.

**** softwares
***** octave
   http://mirrors.ustc.edu.cn/gnu/octave/
   https://coderwall.com/p/wo***kw/ubuntu-installing-octave-fortran-***error

***** briss

***** latex2html
https://www.ctan.org/pkg/latex2html?lang=en

***** xmradio
vlc
sourcecode

***** foxitreader

**** Foxit Reader                                            :foxitreader:

***** Linux 版安装

1. 官网下载：https://www.foxitsoftware.com/products/pdf-reader/
2. .run 可执行文件，安装至 /opt 下
3. 界面较 Windows 版，简化过多，功能不全，体验不好

*还是使用 wine foxitreader 习惯*

**** python install                                              :install:

- https://www.python.org/downloads/

version 3.5


READEM

#+BEGIN_EXAMPLE
  On Unix, Linux, BSD, OSX, and Cygwin:

      ./configure
      make
      make test
      sudo make install
#+END_EXAMPLE

***** 修改软链

#+BEGIN_EXAMPLE
  wally@ Python-3.5.1 $ python  --version
  Python 2.7.9
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/py
  pydoc3             python3            python3.5-config   python3.5m-config  pyvenv
  pydoc3.5           python3.5          python3.5m         python3-config     pyvenv-3.5
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/py
  pydoc3             python3            python3.5-config   python3.5m-config  pyvenv
  pydoc3.5           python3.5          python3.5m         python3-config     pyvenv-3.5
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/python /usr/bin/python
  [sudo] password for wally:
  ln: 无法创建符号链接"/usr/bin/python": 文件已存在
  wally@ Python-3.5.1 $ ls -l /usr/bin/python
  lrwxrwxrwx 1 root root 9  1月  9 16:07 /usr/bin/python -> python2.7
  wally@ Python-3.5.1 $ sudo rm /usr/bin/python
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/python3 /usr/bin/python
  wally@ Python-3.5.1 $ python --version
  Python 3.5.1
#+END_EXAMPLE

**** [[http://www.cnblogs.com/yejianfei/p/3351626.html][Linux的压缩与解压]]

***** zip格式                                                       :zip:

#+BEGIN_EXAMPLE
    压缩： zip -r [目标文件名].zip [原文件/目录名]
    解压： unzip [原文件名].zip
#+END_EXAMPLE

注：-r参数代表递归

***** tar格式（该格式仅仅打包，不压缩）                             :tar:

#+BEGIN_EXAMPLE
    打包：tar -cvf [目标文件名].tar [原文件名/目录名]
    解包：tar -xvf [原文件名].tar
#+END_EXAMPLE

注：c参数代表create（创建），x参数代表extract（解包），v参数代表
verbose（详细信息），f参数代表filename（文件名），所以f后必须接文件名。

***** tar.gz格式                                                     :gz:

方式一：利用前面已经打包好的tar文件，直接用压缩命令。

#+BEGIN_EXAMPLE
    压缩：gzip [原文件名].tar
    解压：gunzip [原文件名].tar.gz
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -zcvf [目标文件名].tar.gz [原文件名/目录名]
    解压并解包： tar -zxvf [原文件名].tar.gz
#+END_EXAMPLE

注：z代表用gzip算法来压缩/解压。

***** tar.bz2格式                                                   :bz2:

方式一：利用已经打包好的tar文件，直接执行压缩命令：

#+BEGIN_EXAMPLE
    压缩：bzip2 [原文件名].tar
    解压：bunzip2 [原文件名].tar.bz2
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -jcvf [目标文件名].tar.bz2 [原文件名/目录名]
    解压并解包： tar -jxvf [原文件名].tar.bz2
#+END_EXAMPLE

注：小写j代表用bzip2算法来压缩/解压。

***** tar.xz格式                                                     :xz:

方式一：利用已经打包好的tar文件，直接用压缩命令：

#+BEGIN_EXAMPLE
    压缩：xz [原文件名].tar
    解压：unxz [原文件名].tar.xz
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -Jcvf [目标文件名].tar.xz [原文件名/目录名]
    解压并解包： tar -Jxvf [原文件名].tar.xz
#+END_EXAMPLE

注：大写J代表用xz算法来压缩/解压。

***** tar.Z格式（已过时）

方式一：利用已经打包好的tar文件，直接用压缩命令：

#+BEGIN_EXAMPLE
    压缩：compress [原文件名].tar
    解压：uncompress [原文件名].tar.Z
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -Zcvf [目标文件名].tar.Z [原文件名/目录名]
    解压并解包： tar -Zxvf [原文件名].tar.Z
#+END_EXAMPLE

注：大写Z代表用ncompress算法来压缩/解压。另，ncompress是早期Unix系统的压缩格式，但由于ncompress的压缩率太低，现已过时。

***** jar格式                                                       :jar:

#+BEGIN_EXAMPLE
    压缩：jar -cvf [目标文件名].jar [原文件名/目录名]
    解压：jar -xvf [原文件名].jar
#+END_EXAMPLE

注：如果是打包的是Java类库，并且该类库中存在主类，那么需要写一个META-INF/MANIFEST.MF配置文件，内容如下：

#+BEGIN_EXAMPLE
    Manifest-Version: 1.0
    Created-By: 1.6.0_27 (Sun Microsystems Inc.)
    Main-class: the_name_of_the_main_class_should_be_put_here
#+END_EXAMPLE

然后用如下命令打包：

#+BEGIN_EXAMPLE
    jar -cvfm [目标文件名].jar META-INF/MANIFEST.MF [原文件名/目录名]
#+END_EXAMPLE

这样以后就能用“java -jar [文件名].jar”命令直接运行主类中的public static
void main方法了。

***** 7z格式                                                         :7z:

#+BEGIN_EXAMPLE
    压缩：7z a [目标文件名].7z [原文件名/目录名]
    解压：7z x [原文件名].7z
#+END_EXAMPLE

注：这个7z解压命令支持rar格式，即：

#+BEGIN_EXAMPLE
    7z x [原文件名].rar
#+END_EXAMPLE

**** freemind                                           :freemind:mindmap:

***** [[http://www.douban.com/group/topic/19280450/][思维导图软件]]

思维导图，又叫心智图。它的创始人是”大脑先生”托尼•巴赞（Tony Buzan）。

思维导图是一种将放射性思考具体化的方法。我们知道放射性思考是人类大脑的
自然思考方式，每一种进入大脑的信息，不论是感觉、记忆或是想法——包括文字、
数字、符码、食物、香气、线条、颜色、意象、节奏、音符等，都可以成为一个
思考中心，并由此中心向外发散出成千上万的关节点，每一个关节点代表与中心
主题的一个连结，而每一个连结又可以成为另一个中心主题，再向外发散出成千
上万的关节点，而这些关节的连结可以视为您的记忆，也就是您的个人数据库。

几款高级思维导图软件

1. PersonalBrain http://personalbrain.evget.com/

   目前比较流行的思维导图软件，使用简单方便，有专业版和普通版区别，专
   业版收费，界面很漂亮，蓝色的皮肤有点像宇宙的感觉，每个元素有上级、
   下级、同级3个节点，提供注释、备注等功能。

2. MindMapper http://www.mindmapper.com/

   它严格地遵守托尼巴贡的制图法则，关键字都是放在延伸手臂上。能够提供
   xml的输出 能与微软办公软件沟通，还有最妙的时间线进度。 快捷键是最好
   用的，无需点鼠标就可以建立新节点。

3. ThinkMap SDK http://www.thinkmap.com/

   软件介面非产酷，强大的数据库功能，3d树形网络,有很好的API开发接口。
   就是价格太贵。

4. FreeMind

   FreeMind是一款跨平台的、基于GPL协议的自由软件，用Java编写，是一个用
   来绘制思维导图的软件。其产生的文件格式后缀为.mm 。可用来做笔记，脑
   图记录，脑力激汤等。　

5. Xmind http://www.xmind.net/

   XMind是一款易用性很强的软件，通过XMind可以随时开展头脑风暴，帮助人
   们快速理清思路。XMind 绘制的思维导图、鱼骨图、二维图、树形图、逻辑
   图、组织结构图等以结构化的方式来展示具 LOGO

6. mindmanager http://www.evget.com/zh-CN/product/1069/feature.aspx

   mindmanager由美国Mindjet公司开发，界面可视化，有着直观、友好的用户
   界面和丰富的功能，　可使使用者有序地组织思维、资源和项目进程，同时
   它是高效的项目管理软件，能很好提高项目组的工作效率和小组成员之间的
   协作性。它作为一个组织资源和管理项目的方法，可从思维导图的核心分枝
   派生出各种关联的想法和信息。

***** [[http://xbeta.info/xmind-freemind.htm][XMind vs FreeMind]] :xmind:

思维导图类软件中，最有影响力的开源免费软件是 FreeMind 和XMind。

FreeMind历史悠久，当属经典；XMind作为后起之秀，大有赶超之势。同作为免费、开源的思维导图解决方案，应如何选择/结合两款软件？

本文的分析基于Windows平台下的 FreeMind 0.90 RC3 和 XMind 3.03，结合笔
者的使用经验，也包括XMind开发者所提供的信息。基本结论是： *总体看，
XMind已超越 FreeMind；个别方面，FreeMind 值得 XMind 学习*

****** XMind 与 FreeMind 的相同/相通之处

- 都是免费、开源、基于 Java。
- 都满足绘制思维导图的基本甚至高级功能。
- 相通之处：XMind 可以导入/导出 FreeMind 格式；反之不能。

****** XMind 与 FreeMind 比较

1. XMind: 更丰富的结构且支持混用

   FreeMind：只支持一种逻辑图（水平）结构。

   XMind：在逻辑图之外，还支持组织结构图（竖直）、树状图（水平+竖直）、
   思维导图（辐射）、鱼骨图、二维图（表格）。不仅如此，还能在一个文档
   中组合使用多种表达形式。实用举例：整个项目管理用逻辑图，人员安排部
   分用组织结构图，风险及应对采用鱼骨图，进度部分用二维图。

2. XMind: 支持自由节点因而支持多图

   FreeMind：只能有一棵树，即：根节点唯一，其他节点必须直接或间接放在
   根节点下。

   XMind：允许在主树之外创建自由节点（应用举例：把“文档作者/创建日期”作
   为自由节点，补充思维导图信息）；由于自由节点也是可以增加子节点的，
   所以可产生第二棵、第N棵新树。

3. FreeMind: 根节点仍可以插入父节点

   需求：在绘完的导图上再加一层。比如，最初建立了“唐诗”导图，现在要
   扩展到“唐宋文学”，即“唐诗”根节点要降至二级节点。

   XMind：顶级的自由节点之间是可以互为子节点的，但原来的根节点（XMind
   称为中心主题）则不能拖到其他节点上。满足上述需求，就要新建文档，以
   “唐宋文学”为根节点，然后导入或粘贴原有内容。\\

    FreeMind：支持根节点上插入“父节点”。

   建议：XMind的“根节点”比FreeMind减少了一份特殊性，即允许其他节点独
   立于此；但仍包留了另一份特殊性，不能成为其他节点的子节点。从使用角
   度，建议取消此限制，即：任何节点本身是一样的，彼此之间为父子关
   系。------或许有技术限制，但节点/层级的平等灵活是XML的精神。

4. XMind 支持附件, FreeMind 全为链接

   FreeMind：可以有超链接到外部文档和图片，也可以显示外部的图片。但这
   些资源都只是.mm文件中的链接url，并非素材本身。即，.mm是纯文本的xml，
   包括 FreeMind的图标也是以ID数字标示。

   XMind：支持上述链接方式，也支持（默认）把该文档及图片引入XMind文件
   作为附件，形成完整的资料包。.xmind 格式与OOo文档一样，实质是 xml＋
   素材的zip包。展开后的内容举例如下：

   #+BEGIN_EXAMPLE
     attachments\
     attachments\4hm2upmpscpth85latqpd49biq.png
     attachments\179ekuhhgn9g866cg5a26b78fh.pdf
     META-INF\
     META-INF\manifest.xml
     Thumbnails\
     Thumbnails\thumbnail.jpg
     content.xml
     meta.xml
     styles.xml
   #+END_EXAMPLE

5. 发布思维导图方面，XMind 要向 FreeMind 学习

   1) 能导出哪些格式

      - XMind 免费版：FreeMind、html、图片（bmp/jpg/gif/png）、纯文本
      - XMind Pro：以上 + MindManager、pdf（普通/思维图）、ppt/doc/rtf
      - FreeMind：各种html、flash、pdf、OpenOffice文档、png/jpg、
        svg/twiki等格式

   2) 我关注的导出格式、比较、说明

      - 静态图片：思维导“图”当然要能导出静态图片，这是最低需求。实在
        不能导出，截屏亦可。只是内容太多超过一屏时，截屏就不太方便了。
        图片可用于网页发布，也可用于其他文档（pdf/office）。格式方面，
        强烈不推荐bmp/jpg，推荐png/gif格式，[[http://blog.sina.com.cn/s/blog_46dac66f010004ox.html][原因见此]]。这方面，XMind与
        FreeMind持平。

      - pdf文档发布：相比图片的优点是，放大后文字仍然清晰。如果内容太
        多，导出一页的pdf发给别人，无论用于打印还是放大查看，都比图片
        的效果好很多。对比结果：XMindPro（未用过）＞ FreeMind（够用）
        ＞ XMind（无）-- 广义html导出：FreeMind 遥遥领先，详细见下。

      - 广义html导出的详细比较

        结论：广义html/flash式导出，目的是在线发布后，仍保留折叠/展开
        动态效果，及链接功能。这方面，FreeMind遥遥领先，远胜 XMind。

        XMind：导出的html包括图片和节点文字。但图与文字无链接；文字层
        级也不能折叠；图片默认为jpg，强烈建议换为png。

        FreeMind：可采用不同技术进行导出，每种导出效果都非常好。
        FreeMind导出html的格式有：

        - html：纯文字方式，节点保留原有格式，层级关系可折叠展开，url链接有效。
        - xhtml（javascript）：效果同上，只是改用js实现。
        - xhtml（可点击map图片）：除了上述文字内容外，还附有图片，并且点击图片的节点可跳转到对应的文字。
        - java applet：功能保留最多的方式。在浏览器中的使用效果近乎在 FreeMind中打开 .mm文件。
        - flash：点击可折叠/展开，链接url有显示但无法点击。

6. FreeMind节点支持html代码

   FreeMind：节点支持html代码，实现文字格式化、换行、分段、图像链接、
   表格。（此外，还支持LaTex代码）

    XMind：不能对部分文字分别设定格式，可以shift+enter换行。

7. XMind 具有更好的可持续性

   FreeMind作为经典开源软件，虽在持续更新中，但新功能进展并不多。而同
   作为开源软件的XMind，不仅因为后发优势拥有了更多功能。并且，作为有商
   业公司支持的开源产品，新功能的开发会更加活跃------这并非迷信商业，
   而是实际情况，包括两个开发团队的成员也有此认识。

    另外，XMind还提供了更强大的Pro版，可以满足个人和企业的更高需求，并
   能提供可靠的技术支持。

8. XMind 更美观，FreeMind 更快速省资源

   无论用户界面还是思维导图文件，XMind 都更加美观。而 FreeMind更加简约，
   占用资源更少，启动和运行速度更快。各取所需即可。

9. 其他差异

   FreeMind 可以导入目录结构，相当于变成了资源管理器；XMind不能。

   在节点输入较多文字的过程中，XMind的输入框会阶梯式不断加大，而
   FreeMind会保持同样大小（只显示最右侧部分）。

   XMind的节点可以添加标签，以进行过滤筛选；而FreeMind可以根据节点文字
   进行过滤显示。

    注意：XMind导入.mm时，无法识别包含html代码的节点。

****** 结论：软件选择建议

大多数人普通用户：XMind。理由：支持逻辑图、二维图等多种表达形式并可混
用，更加美观、支持附件。

*Geek或偏执者：FreeMind。理由：更节约资源，界面更简朴。*

自主网络发布：FreeMind。理由：强大灵活的html导出功能。

不执着于软件，仅执着于最优效果：主用 XMind 辅用FreeMind。即仅在自主网
络发布时另存为FreeMind格式，再用FreeMind导出为html。

***** freemind

+ [[http://freemind.sourceforge.net/wiki/index.php/Main_Page][Homepage]]

****** install                                                 :install:

新得立 version 0.9

beta: 1.1

http://freemind.sourceforge.net/wiki/index.php/Download

http://www.getdeb.net/app/Freemind -> 软件中心

不支持的软件源，安装过程中需要 “修复”。。。

还是源码 -> ant (java 版 make)

#+BEGIN_EXAMPLE
java.io.IOException: Cannot run program "/home/wally/Download/freemind/check_for_duplicate_resources.sh": error=13, 权限不够
#+END_EXAMPLE

sudo 和切换为 root 用户，也不行？

还是 apt-get 方式

****** usage

用起来体验不错。
**** org export to freemind                             :freemind:mindmap:

#+BEGIN_EXAMPLE
- State "DONE"       from "ABORT"      [2016-01-11 一 10:20] \\
  重新安装系统后编译Emacs，解决问题
- State "ABORT"      from "TODO"       [2015-11-23 一 19:26] \\
  不需要的东西不要瞎折腾, 放弃也是一种智慧
#+END_EXAMPLE


#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "~/.emacs.d/src/org-mode/contrib/lisp"))
  (require 'ox-freemind)
  (setq org-freemind-pretty-output t)
  (setq org-freemind-section-format 'note)
#+END_SRC

(void-function libxml-parse-xml-region) 暂时解决不了。。。

-> 重新编译安装Emacs??? 不要鲁莽！！！

*org-freemind-export-to-freemind*

**** desktop重命名                                               :desktop:

- http://blog.csdn.net/manmaximus/article/details/3567919

- why: 重命名桌面文件夹，桌面所在文件夹是“桌面”，习惯了用终端进行操
  作，但是在终端打中文比较麻烦

- 配置文件: *~/.config/user-dirs.dirs*

  #+BEGIN_EXAMPLE
    # This file is written by xdg-user-dirs-update
    # If you want to change or add directories, just edit the line you're
    # interested in. All local changes will be retained on the next run
    # Format is XDG_xxx_DIR="$HOME/yyy", where yyy is a shell-escaped
    # homedir-relative path, or XDG_xxx_DIR="/yyy", where /yyy is an
    # absolute path. No other format is supported.
    #
    XDG_DESKTOP_DIR="$HOME/Desktop"
    XDG_DOWNLOAD_DIR="$HOME/Download"
    XDG_TEMPLATES_DIR="$HOME/模板"
    XDG_PUBLICSHARE_DIR="$HOME/Share"
    XDG_DOCUMENTS_DIR="$HOME/Document"
    XDG_MUSIC_DIR="$HOME/Audio"
    XDG_PICTURES_DIR="$HOME/Picture"
    XDG_VIDEOS_DIR="$HOME/Video"
  #+END_EXAMPLE

**** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

**** emacs matlab                                                 :matlab:

***** matlab-emacs

中止的项目

#+BEGIN_SRC emacs-lisp
  (autoload 'matlab-mode "matlab" "Enter MATLAB mode." t)
  (setq auto-mode-alist (cons '("\\.m\\'" . matlab-mode) auto-mode-alist))
  (autoload 'matlab-shell "matlab" "Interactive MATLAB mode." t)
#+END_SRC

***** matlab-mode

https://github.com/pronobis/matlab-mode

****** configure

+ [[http://www.emacswiki.org/emacs/MatlabMode][EmacsWiki]]

#+BEGIN_SRC emacs-lisp
  (autoload 'matlab-mode "matlab" "Matlab Editing Mode" t)
  (add-to-list
   'auto-mode-alist
   '("\\.m$" . matlab-mode))
  (setq matlab-indent-function t)
  (setq matlab-shell-command "matlab")
#+END_SRC

****** usage

- *matlab shell* 后台运行 matlab (Note: 不会启动 GUI，但会短暂地弹出一
  个窗口)
- 只能运行，不支持调试，调试还是使用 Matlab GUI

***** matlab IDE 支持 Emacs 基本的编辑快捷键，所以可能不需要集成在 Emacs 中

** w1
*** 2016/01/10
**** index

关于建立索引的想法

1. 索引类似书后面的 index
2. 按字母顺序排列
3. 不使用标题，因为不需要继承标签
4. 使用无序列表
5. 可以包含简要的笔记内容和链接等

**** 手机 VPN

不用下载客户端，直接使用配置中的VPN

**** 交换 CapsLock 和 Ctrl 键
***** reference

- http://tuhdo.github.io/emacs-tutor.html
- http://www.kodiva.com/post/swapping-caps-lock-and-control-keys
-
  http://askubuntu.com/questions/412576/swap-caps-lock-and-ctrl-in-ubuntu-13-10/412622#412622

***** windows: 通过修改注册表

In our opinion this is the best way to swap the control and caps lock
keys in Windows because you don't have to rely on any external program
and the registry edit works 100% perfectly (for the paranoid).

Why should one bother changing the caps lock and control keys, what's
wrong with the control key where it is? After extensive testing, our
conclusion is that - if you use the control key a lot (like in Emacs or
Vim), then you should definitely swap the control and caps lock keys as
it's extremely ergo-dynamic to have the control key in the home row.

1. Click Start -> Run

2. Type: regedit, and click OK

3. Go to: HKEY_LOCAL_MACHINE -> System -> CurrentControlSet -> Control
   -> KeyBoard Layout

   Note: *KeyBoard Layout*, and not KeyBoard Layouts

4. Right-click: Keyboard Layout, and select New -> Binary value

5. Rename: New Value #1 -> Scancode Map

6. Right click: Scancode Map -> Modify
   #+BEGIN_EXAMPLE
     0000  00 00 00 00 00 00 00 00
     0008  03 00 00 00 1d 00 3a 00
     0010  3a 00 1d 00 00 00 00 00
     0018
   #+END_EXAMPLE

7. Close regedit and restart your computer

***** Linux

1. Put this in your shell init file (.bashrc, .zshrc…):

   #+BEGIN_EXAMPLE
   /usr/bin/setxkbmap -option "ctrl:swapcaps"
   #+END_EXAMPLE

2. xmodmap

3. gnome-tweak-tool(Ubuntu)

   First, install gnome-tweak-tool using sudo apt-get install
   gnome-tweak-tool from a console.

   Then, run it using the command gnome-tweak-tool, or by typing
   "Tweak Tool" into the dash at the top-left.

   From this tool, choose the "Typing" tab on the left. Then, from the
   dropdown next to "Ctrl key position" on the right, choose "Swap
   Ctrl and Caps Lock". This should swap those two keys.
**** org-mobile

+ http://darksun.blog.51cto.com/3874064/1302920

***** 下载 MobileOrg

豌豆荚上的 MobileOrg 版本低。

google play 在手机上安装后打开无反应！！！

https://github.com/matburt/mobileorg-android  源码不会编译，android 平
台。似乎不再更新了，最后一次提交是两年前。

Google 搜索关键字 "MobileOrg apk": [[http://www.appdownloader.net/Android/App/602857/com.matburt.mobileorg/Download][Down MobileOrg Apk 0.9.13]]

***** 配置 Emacs org

org-mobile-push C-c C-x RET p

#+BEGIN_SRC emacs-lisp
  (require 'org-mobile)
  (require 'org-id)
  (setq org-mobile-directory (expand-file-name "~/Share/Dropbox/MobileOrg"))
  (setq org-directory "~/Wally/Journal/GTD")
  (setq org-mobile-files '("~/Wally/Journal/GTD/task.org"))
  (setq org-mobile-inbox-for-pull "~/Wally/Journal/GTD/mobile.org")
#+END_SRC

****** error

#+BEGIN_EXAMPLE
(void-function org-id-get)
#+END_EXAMPLE

(require 'org-id)

***** 使用小结

#+BEGIN_EXAMPLE
  C-c C-x RET p (translated from C-c C-x <return> p) runs the command
  org-mobile-push, which is an interactive Lisp function in
  `org-mobile.el'.

  It is bound to <menu-bar> <Org> <MobileOrg> <Push Files and Views>,
  C-c C-x RET p.

  (org-mobile-push)

#+END_EXAMPLE

可以更新任务状态，但是更新的内容只是同步到了 mobile.org, 而没有改变对
应的 task.org
**** software
***** 新得立
***** Ubuntu Windows 双系统，硬盘安装

****** windows 配置

1. 下载镜像文件
   - Ubuntu 64位(乌班图系统) v12.04.1 官方原版iso镜像：http://www.33lc.com/soft/18055.html
   - Ubuntu(乌班图系统) v12.04.1 官方原版iso镜像： http://www.33lc.com/soft/18053.html

2. 下载并安装easybcd。

   easybcd是一款很优秀的系统引导软件，功能强大，最关键的是傻瓜式一站式
   简易操作，极其适合新手使用!

3. 新建分区

   腾出一个空盘，点击右键格式化之后把它删除(这个盘最好是在硬盘的后面，
   因为Windows系统不能识别Linux系统分区，如果将ubuntu装在D盘，将D盘删
   除并建立Linux系统分区后，原来的E盘就会变成D盘，安装在E盘的软件会出
   现系统注册表路径不对称，要重新安装一遍软件)。网上很多说使用磁盘压缩
   功能以整理出空白分区，这个方法也可行，但这个盘要保证有10G空间以上比
   较稳妥。

4. 安装好easybcd2.1.2后，启动软件

   #+DOWNLOADED: http://www.33lc.com/article/UploadPic/2012-8/20128241427190206.jpg @ 2016-01-10 14:16:48

   [[~/Wally/Journal/Figure/.org-download/Journal/20128241427190206_2016-01-10_14:16:48.jpg]]

   按照上图的序号依次点击“Add New Entry”——“Neo Grub”——“Install”，
   点到“Install”后出面下面的界面，再点“Configure”。

   点击“Configure”按钮后，会出现一个记事本文件，将下面的代码粘贴到文
   件尾部：

   #+BEGIN_EXAMPLE
     title Install Ubuntu 12.04 LTS
     root (hd0,6)
     kernel (hd0,6)/vmlinuz boot=casper iso-scan/filename=/ubuntu-12.04-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8
     initrd (hd0,6)/initrd.lz
   #+END_EXAMPLE

   上图代码中“ubuntu-12.04-desktop-amd64.iso”为你下载的ubuntu 12.04
   系统镜像文件名，这个文件名是可以修改的，但修改的名字一定要与写入的
   代码名字一致，否则将无法引导安装;

   (hd0,6) 表示磁盘分区，hd(0,0), hd(0,1), hd(0,2), hd(0,3)表示主分区，
   (hd0,4)以后的表示逻辑分区，现在我只有一个主分区C盘，则(hd0,0)表示C
   盘，(hd0,4)表示D盘，(hd0,5)表示E盘，(hd0,6)表示F盘，我的镜像就是放
   在F盘里，请把(hd0,6)改成自己对应的分区)

5. 将下载的镜像文件放到(hd0,N)盘的根目录下，并确保文件名与上面写入的代
   码的文件名一致为ubuntu-12.04-desktop-amd64.iso，然后用WinRAR解压缩
   软件将iso打开，将casper文件夹目录下的vmlinuz和 initrd.lz解压并复制
   到(hd0,N)盘根目录下。准备工作至此已全部完成!!!

****** Ubuntu 安装

1. sudo umount /isodevice

2. /usr/local 或 /opt 可以单独挂载一个分区

****** Windows 下删除 Ubuntu 分区导致系统无法启动（引导程序失败） :grub:

- [[http://zhidao.baidu.com/question/495728786.html?fr=ala&word=grub%20rescue%E5%88%A0%E9%99%A4ubuntu&device=mobile&ssid=0&from=2001a&uid=0&pu=usm@0][百度知道]]

装了ubuntu后，会默认从Ubuntu的Grub菜单引导系统，Win8的MBR被替换为Grub
来引导。

于是，你删除了Ubuntu，也就是删除了Grub的文件。但是，你的引导扇区的启动
参数还是指向了Grub，于是就grun rescue了。。。

*解决方法*

用PE启动，打开WinPM或者DiskGen，找到一个叫重建主引导记录（MBR）的东西，
重建一下就好了，记得把Windows分区设置为活动！

***** [[http://seisman.info/install-texlive-under-linux.html][Linux下安装TeXLive 2015]]
****** [[#id8][依赖包]]

- 安装过程中需要调用Perl的模块 =Digest::MD5= 来检测ISO文件的完整性；
- 升级过程中界面需要调用Perl的模块 =Tk= ；

CentOS:

#+BEGIN_EXAMPLE
    $ sudo yum install perl-Digest-MD5 perl-Tk
#+END_EXAMPLE

Ubuntu:

#+BEGIN_EXAMPLE
    $ sudo apt-get install libdigest-perl-md5-perl perl-tk
#+END_EXAMPLE

****** [[#id9][安装]]

******* [[#id10][下载]]

下载地址：

- 官方镜像:
   [[http://mirrors.ctan.org/systems/texlive/Images/texlive2015.iso]]
- USTC镜像：
   [[http://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/texlive2015.iso]]

Linux下可以用wget、axel，windows下可以用迅雷，怎么快怎么来。

******* [[#id11][挂载ISO镜像]]

 #+BEGIN_EXAMPLE
     $ su
     # mount -o loop texlive2015.iso  /mnt/
     # cd /mnt
     # ./install-tl
 #+END_EXAMPLE


出现选项后，输入 =I=
直接安装（也可以更改选项）。不出意外的话，5分钟应该就OK了，然后退出root用户。

******* [[#id12][环境变量]]

在当前用户的 =~/.bashrc= 中加入如下语句：

 #+BEGIN_EXAMPLE
     # TeX Live 2015
     export MANPATH=${MANPATH}:/usr/local/texlive/2015/texmf-dist/doc/man
     export INFOPATH=${INFOPATH}:/usr/local/texlive/2015/texmf-dist/doc/info
     export PATH=${PATH}:/usr/local/texlive/2015/bin/x86_64-linux
 #+END_EXAMPLE


******* [[#id13][卸载ISO镜像]]

 #+BEGIN_EXAMPLE
     1
     2
 #+END_EXAMPLE

 #+BEGIN_EXAMPLE
     $ cd
     $ sudo umount /mnt/
 #+END_EXAMPLE

****** [[#id14][更新TeXLive]]

可以使用如下命令更新TeXLive宏包：


 #+BEGIN_EXAMPLE
     $ su
     # 更新TeXLive包管理器tlmgr
     # tlmgr update --self
     # 更新TeXLive的全部包
     # tlmgr update --all
 #+END_EXAMPLE


默认情况下，会自动搜索合适的镜像来更新，也可以使用 =--repository=
选项指定了要使用哪一个CTAN镜像。

比如USTC镜像:

#+BEGIN_EXAMPLE
    # tlmgr update --self --repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet/
    # tlmgr update --all --repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet/
#+END_EXAMPLE

比如阿里云镜像:

#+BEGIN_EXAMPLE
    # tlmgr update --self --repository http://mirrors.aliyun.com/CTAN/systems/texlive/tlnet/
    # tlmgr update --all --repository http://mirrors.aliyun.com/CTAN/systems/texlive/tlnet/
#+END_EXAMPLE

如果希望在图形界面下升级，可以使用如下命令调出tlmgr的中文图形界面：

 #+BEGIN_EXAMPLE
     $ su
     # tlmgr --gui --gui-lang zh_CN
 #+END_EXAMPLE

****** [[#id15][安装额外的字体]]

TeXLive 2015在使用xeLaTeX处理中文时，有自己的默认字体。大多数Linux发行版下，都使用自带的Fandol字体。

如果想要使用Windows字体，可以将字体文件复制到 =~/.fonts=
目录下，并在tex源码中指定字体选项即可。

*.local/share/fonts 文件夹*

****** [[#id16][修订历史]]

- 2013-07-11：初稿；
- 2014-07-06：修改为TeXLive2014，并删除中文字体部分；
- 2015-03-08：新增“安装依赖”；
- 2015-03-15：使用命令行更新包；
- 2015-03-20：指定更新源以及GUI更新；
- 2015-06-13：更新至TeXLive 2015；

So what do you think? Did I miss something? Is any part unclear? Leave
your comments below.

[[http://seisman.info/install-texlive-under-linux.html#disqus_thread][Comments]]

Please enable JavaScript to view the
[[http://disqus.com/?ref_noscript][comments powered by Disqus.]]

[[http://disqus.com][comments powered by Disqus]]

--------------

****** Related Posts:

- [[http://seisman.info/terms-about-tex.html][与TeX相关的一些名词]]
- [[http://seisman.info/perl-plenv.html][Perl多版本共存之plenv]]
- [[http://seisman.info/install-gmt5-under-linux.html][GMT 5.1.2在Linux下的安装]]
- [[http://seisman.info/mini-template-for-xeCJK.html][使用xeCJK解决中文问题的最小模板]]
- [[http://seisman.info/install-gmt5-under-windows.html][GMT 5.1.2在Windows下的安装]]

***** [[http://ergoemacs.org/emacs/building_emacs_on_linux.html][How to Build Emacs on Linux]] :install:

This page shows you how to compile/build latest version of publically
released version of emacs on Linux. It should work for building any
emacs version. I assume you are on Ubuntu Linux.

If you want to build latest development version, see:
[[building_emacs_from_git_repository.html][How to Build Emacs from git
Repository]].

****** Summary

Here's summary of what to do.

① Install essential build tools and dependency first:

#+BEGIN_EXAMPLE
    # install essential build tools
    sudo apt-get install build-essential
#+END_EXAMPLE

② Download emacs dependencies:

#+BEGIN_EXAMPLE
    # get all dependencies of a previous emacs version
    sudo apt-get build-dep emacs24
#+END_EXAMPLE

③ Download emacs source code from [[http://ftp.gnu.org/gnu/emacs/]],
then cd to the emacs source directory.

④ Compile emacs:

#+BEGIN_EXAMPLE
    cd ‹source dir name›
    ./configure
    make
    sudo make install # optional. This basically copy the binary to /usr/local/bin
#+END_EXAMPLE

Following is detailed explanation.

--------------

****** Check Prepared Emacs Packages

On Ubuntu, typically you install by =sudo apt-get install emacs24=,
where the “emacs24” may be other version.

To search for emacs, do: =apt-cache search emacs | grep emacs=.

When emacs has a new version, Ubuntu Linux typically takes half a year
to a year to have a prepared package.

Or, you build it yourself. It's easy.

****** Download Emacs Source Code

Download emacs source code here: [[http://ftp.gnu.org/gnu/emacs/]]

****** Compile Steps

To compile programs on unix, typically the steps are:

#+BEGIN_EXAMPLE
    cd ‹source dir name›
    ./configure
    make
    sudo make install # optional. This basically copy the binary to /usr/local/bin
#+END_EXAMPLE

In the source dir, there's usually a README or INSTALL file.

However, you'll probably fail in the configure step, because emacs
requires lots other libraries, also, you might be missing build tools.

Here's some sample output of failure:

#+BEGIN_EXAMPLE
    checking for libXaw... configure: error: No X toolkit could be found.
    If you are sure you want Emacs compiled without an X toolkit, pass
      --with-x-toolkit=no
    to configure.  Otherwise, install the development libraries for the toolkit
    that you want to use (⁖ Gtk+) and re-run configure.
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    configure: error: The following required libraries were not found:
        libXpm libjpeg libpng libgif/libungif libtiff
    Maybe some development libraries/packages are missing?
    If you don't want to link with them give
        --with-xpm=no --with-jpeg=no --with-png=no --with-gif=no --with-tiff=no
    as options to configure
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    configure: error: The required function `tputs' was not found in any library.
    These libraries were tried: libncurses, libterminfo, libtermcap, libcurses.
    Please try installing whichever of these libraries is most appropriate
    for your system, together with its header files.
    For example, a libncurses-dev(el) or similar package.
#+END_EXAMPLE

You can type =./configure --help= to see the options it supports. See
its output here: [[linux_compile_emacs_24_config_help_output.txt]].

****** Install Basic Build Tools

#+BEGIN_EXAMPLE
    # install basic build tools
    sudo apt-get install build-essential
#+END_EXAMPLE

To see info about the package, do:

- =apt-cache showpkg build-essential=
- =apt-cache show build-essential=

****** Dependencies

You'll need to install some 30 dependent libraries. The trick is to know
which are they. Took me a couple hours to find out the hard way.

The easiest way is to install all dependencies of a previous version of
the package, like this:

#+BEGIN_EXAMPLE
    sudo apt-get build-dep emacs24
#+END_EXAMPLE

This will install all packages emacs24 depends on.

Here's the output on my machine for emacs23:

#+BEGIN_EXAMPLE
    The following NEW packages will be installed:
      autoconf automake autotools-dev bsd-mailx diffstat imagemagick libasound2-dev libdatrie-dev
      libdbus-1-dev libgconf2-dev libgpm-dev libgtk2.0-dev liblockfile-dev liblqr-1-0 libm17n-dev
      libmagickcore3 libmagickwand3 libncurses5-dev libotf-dev librsvg2-dev libthai-dev libtinfo-dev
      libxml2-dev postfix quilt sharutils texinfo xaw3dg xaw3dg-dev xutils-dev
    0 upgraded, 30 newly installed, 0 to remove and 4 not upgraded.
    Need to get 12.4 MB of archives.
    After this operation, 49.5 MB of additional disk space will be used.
#+END_EXAMPLE

You can see the full bash output here:
[[linux_compile_emacs_23_dependencies.txt]]

****** config, make

=make distclean= to clear files created by configure.

Once you have all the dependencies, you can now run =./configure= and
=make= again.

Here's a sample successful output:

- [[linux_compile_emacs_24_config_success_output.txt]]
- [[linux_compile_emacs_24_make_success_output.txt]]

After successful “make”, you should have a binary at =src/emacs= in the
current dir. You can test run it by =src/emacs &=.

Optionally, you can do =sudo make install=, which will basically copy
the binary to =/user/loca/bin/=, and copy various elisp files, info
files, man pages, etc, into various Linux default dirs.

***** steam                                                       :steam:
****** dota 全屏

http://jingyan.baidu.com/article/e75057f2dca190ebc91a893e.html

全屏问题，选项里设置视频，全屏模式

****** error

http://askubuntu.com/questions/614422/problem-with-installing-steam-on-ubuntu-15-04

#+BEGIN_EXAMPLE
$ steam
Running Steam on ubuntu 15.04 64-bit
STEAM_RUNTIME is enabled automatically
Installing breakpad exception handler for appid(steam)/version(0_client)
libGL error: unable to load driver: r600_dri.so
libGL error: driver pointer missing
libGL error: failed to load driver: r600
libGL error: unable to load driver: swrast_dri.so
libGL error: failed to load driver: swrast
#+END_EXAMPLE

***** [[http://lanbing510.info/2014/12/03/Linux-Matlab.html][Matlab 安装]] :install:

1. 从[[http://pan.baidu.com/s/1o6qKdxo#path=%252Fmatlab][这里]]下载Matlab2014的Linux版本及破解文件。

   - note: 两个 rar 文件，只需使用 unrar 解压其中一个即可，会自动解压
     另外一个。

2. 下载完成后将iso文件挂载到Linux进行安装。

   #+BEGIN_EXAMPLE
    sudo mkdir /media/matlab
    mount -o loop [path][filename].iso /media/matlab
    cd /media/matlab
    sudo ./install
   #+END_EXAMPLE

  - ./install 触发的是 GUI 方式，而不是命令行方式

3. 安装过程中使用readme.txt中的序列号。

4. 破解

   1) 安装完成后使用crack下的 license进行激活；

   2) 将crack文件夹下的libmwservices.so copy到 /usr/local/MATLAB/R2014A/bin/glnxa64。

5. 完成安装，命令行下使用sudo matlab即可启动使用。

***** git 安装                                                  :install:

https://github.com/git/git

from INSTALL(file)

#+BEGIN_EXAMPLE
Alternatively you can use autoconf generated ./configure script to
set up install paths (via config.mak.autogen), so you can write instead

        $ make configure ;# as yourself
        $ ./configure --prefix=/usr ;# as yourself
        $ make all doc ;# as yourself
        # make install install-doc install-html;# as root
#+END_EXAMPLE

顺便解决了 magit 因为 git 版本低的 bug

***** pandoc 安装                                               :install:

- https://github.com/jgm/pandoc


1. apt-get

   #+BEGIN_EXAMPLE
     :~$ apt-cache search pandoc
     doconce - document once, include anywhere
     gitit - Wiki engine backed by a git or darcs filestore
     libghc-citeproc-hs-data - Haskell support for Citation Style Language - data files
     libghc-citeproc-hs-dev - Haskell support for Citation Style Language
     libghc-citeproc-hs-doc - Haskell support for Citation Style Language; documentation
     libghc-citeproc-hs-prof - Haskell support for Citation Style Language; profiling libraries
     libghc-gitit-dev - Wiki engine backed by a git or darcs filestore
     libghc-gitit-doc - Wiki engine backed by a git or darcs filestore; documentation
     libghc-gitit-prof - Wiki engine backed by a git or darcs filestore; profiling libraries
     libghc-pandoc-citeproc-data - Pandoc support for Citation Style Language - data files
     libghc-pandoc-citeproc-dev - support for using pandoc with citeproc
     libghc-pandoc-citeproc-doc - support for using pandoc with citeproc; documentation
     libghc-pandoc-citeproc-prof - support for using pandoc with citeproc; profiling libraries
     libghc-pandoc-dev - general markup converter - libraries
     libghc-pandoc-doc - general markup converter - library documentation
     libghc-pandoc-prof - general markup converter - profiling libraries
     libghc-pandoc-types-dev - Haskell data types to represent structured documents
     libghc-pandoc-types-doc - Haskell data types to represent structured documents; documentation
     libghc-pandoc-types-prof - Haskell data types to represent structured documents; profiling libraries
     libghc-yesod-markdown-dev - tools for using Markdown in a Yesod application
     libghc-yesod-markdown-doc - tools for using Markdown in a Yesod application; documentation
     libghc-yesod-markdown-prof - tools for using Markdown in a Yesod application; profiling libraries
     pandoc - general markup converter
     pandoc-citeproc - Pandoc support for Citation Style Language - tools
     pandoc-data - general markup converter - data files
     python-pandocfilters - python bindings for Pandoc's filters
     python3-pandocfilters - python3 bindings for Pandoc's filters
     wally@wally:~$ sudo apt-get install pandoc
     [sudo] password for wally:
     正在读取软件包列表... 完成
     正在分析软件包的依赖关系树
     正在读取状态信息... 完成
     将会安装下列额外的软件包：
       liblua5.1-0 pandoc-data
     建议安装的软件包：
       texlive-latex-recommended texlive-xetex texlive-luatex pandoc-citeproc etoolbox
     下列【新】软件包将被安装：
       liblua5.1-0 pandoc pandoc-data
     升级了 0 个软件包，新安装了 3 个软件包，要卸载 0 个软件包，有 256 个软件包未被升级。
     需要下载 4,519 kB 的软件包。
     解压缩后会消耗掉 38.9 MB 的额外空间。
   #+END_EXAMPLE

2. source code

   + git clone git://github.com/jgm/pandoc
   + cd pandoc
   + git submodule update --init
   + cabal install --force --enable-tests
   + cabal test

注：
- 使用 cabal

- Make sure the `$CABALDIR/bin` directory is in your path.

  #+BEGIN_EXAMPLE
  export PATH=~/.cabal/bin:$PATH
  #+END_EXAMPLE

- *没有必要使用源码方式*

***** dropbox 安装

- 下载(64bit for Ubuntu): https://www.dropbox.com/zh_CN/install?os=lnx

- dpkg install
  #+BEGIN_EXAMPLE
    $ sudo dpkg -i dropbox_2015.10.28_amd64.deb
    正在选中未选择的软件包 dropbox。
    (正在读取数据库 ... 系统当前共安装有 241104 个文件和目录。)
    正准备解包 dropbox_2015.10.28_amd64.deb  ...
    正在解包 dropbox (2015.10.28) ...
    正在设置 dropbox (2015.10.28) ...
    Please restart all running instances of Nautilus, or you will experience problems. i.e. nautilus --quit
    Dropbox installation successfully completed! You can start Dropbox from your applications menu.
    正在处理用于 gnome-menus (3.10.1-0ubuntu5) 的触发器 ...
    正在处理用于 desktop-file-utils (0.22-1ubuntu3) 的触发器 ...
    正在处理用于 bamfdaemon (0.5.1+15.04.20150202-0ubuntu1) 的触发器 ...
    Rebuilding /usr/share/applications/bamf-2.index...
    正在处理用于 mime-support (3.58ubuntu1) 的触发器 ...
    正在处理用于 hicolor-icon-theme (0.14-0ubuntu1) 的触发器 ...
    正在处理用于 man-db (2.7.0.2-5) 的触发器 ...
  #+END_EXAMPLE

*** 2016/01/08
**** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

**** gazebo

- ROS 建模

**** smartparens

- [[https://github.com/Fuco1/smartparens][Github]]
- [[https://github.com/Fuco1/smartparens/wiki][Wiki]]
- https://ebzzry.github.io/emacs-pairs.html

***** add pairs
1. global
  #+BEGIN_EXAMPLE
    (sp-pair "\{" "\}") ;; latex literal brackets (included by default)
    (sp-pair "<#" "#>")
    (sp-pair "$" "$")   ;; latex inline math mode. Pairs can have same opening and closing string
  #+END_EXAMPLE
2. local
   #+BEGIN_EXAMPLE
   (sp-local-pair 'LaTeX-mode "\\\\left(" "\\\\right)" :insert "C-b l" :trigger "\\\\l(")
   #+END_EXAMPLE

3. :wrap
   #+BEGIN_EXAMPLE
     (sp-pair "(" ")" :wrap "C-(")
   #+END_EXAMPLE

***** remove pairs
#+BEGIN_EXAMPLE
  ;; the second argument is the closing delimiter, so you need to skip it with nil
  (sp-pair "\{" nil :actions :rem)
  (sp-pair "'" nil :actions :rem)
#+END_EXAMPLE

***** wrapping

https://github.com/Fuco1/smartparens/wiki/Wrapping

#+BEGIN_SRC emacs-lisp
  (sp-local-pair 'org-mode "*" "*"
                 :wrap "*")
  (sp-local-pair 'org-mode "=" "="
                 :wrap "=")
  (sp-local-pair 'org-mode "/" "/"
                 :wrap "/")
  (sp-local-pair 'org-mode "\left(" "\n\\right)"
                 :trigger "\l(")
  (sp-local-pair 'org-mode "\left[" "\n\\right]"
                 :trigger "\l[")
  (sp-local-pair 'org-mode "\left{" "\n\\right}"
                 :trigger "\l{")
  (sp-local-pair 'org-mode "\\[" "\\]"
                 :trigger "\\[")
#+END_SRC

E=mc^2

**** wrap-region

+ [[https://github.com/rejeep/wrap-region.el][GitHub]]

Wrap Region is a minor mode for Emacs that wraps a region with
punctuations. For "tagged" markup modes, such as HTML and XML, it wraps
with tags.

***** Installation

I recommend installing via ELPA, but manual installation is simple as
well:

#+BEGIN_EXAMPLE
    (add-to-list 'load-path "/path/to/wrap-region")
    (require 'wrap-region)
#+END_EXAMPLE

***** Usage

Start =wrap-region-mode= using.

#+BEGIN_EXAMPLE
    (wrap-region-mode t)
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    M-x wrap-region-mode
#+END_EXAMPLE

Now try selecting a region and press any of the following keys: ="=,
='=, =(=, ={=, =[=.

The above are the default wrappers. You can add more yourself:

#+BEGIN_EXAMPLE
    (wrap-region-add-wrapper "$" "$")
    (wrap-region-add-wrapper "{-" "-}" "#")
    (wrap-region-add-wrapper "/" "/" nil 'ruby-mode)
    (wrap-region-add-wrapper "/* " " */" "#" '(java-mode javascript-mode css-mode))
    (wrap-region-add-wrapper "`" "`" nil '(markdown-mode ruby-mode))
#+END_EXAMPLE

The same can be done with:

#+BEGIN_EXAMPLE
    (wrap-region-add-wrappers
     '(("$" "$")
       ("{-" "-}" "#")
       ("/" "/" nil ruby-mode)
       ("/* " " */" "#" (java-mode javascript-mode css-mode))
       ("`" "`" nil (markdown-mode ruby-mode))))
#+END_EXAMPLE

For more information, see comments in =wrap-region.el=.

***** Except modes

In some modes, such as =calc-mode= and =dired-mode=, you don't want to
have wrap region active since the key bindings will conflict. Wrap
region stores a list of modes (see =wrap-region-except-modes=) in which
wrap region will be inactive.

Some modes are added to the except list by default. See the list with:

#+BEGIN_EXAMPLE
    (describe-variable 'wrap-region-except-modes)
#+END_EXAMPLE

To add a new mode, do this:

#+BEGIN_EXAMPLE
    (add-to-list 'wrap-region-except-modes 'conflicting-mode)
#+END_EXAMPLE

***** customize

****** wrap-region-add-wrapper

(wrap-region-add-wrapper LEFT RIGHT &optional KEY MODE-OR-MODES)

Add new LEFT and RIGHT wrapper.

Optional KEY is the trigger key and MODE-OR-MODES is a single
mode or multiple modes that the wrapper should trigger in.

****** global minor mode

#+BEGIN_SRC emacs-lisp
  (require 'wrap-region)
  (wrap-region-global-mode t)
#+END_SRC

****** org-mode

#+BEGIN_SRC emacs-lisp
  (wrap-region-add-wrappers
   '(("*" "*" "*" org-mode)
     ("=" "=" "=" org-mode)
     ("/" "/" "/" org-mode)
     ("$" "$" "$" org-mode)))
#+END_SRC

***** smartparens 可以替代，而且似乎更强大，同类产品只择其一

**** Eason

从2015年8月16日在微信上分享《天下无双》到12月31的《七百年后》，前前后
后一共听Eason四个半月，按发布顺序以每周一张的速度认真听了不下十五张专
辑。Eason 在我的心中已经封神。

今天一如继往听Eason的专辑《上五楼的快活》，2009年的国语专，主打“台风”。
然而对我来说，真的是一种忍受，根本不想再听第二遍。接着又看了其后几张专
辑的评论，仍然不尽如人意。进一步地关注了知乎上一些关于 Eason、Jay 和王
力宏等人的对比，问答间充斥着所谓“真粉“的武断式的论点。这为单纯的喜欢
陡然增加了嘈杂的因素---我知道这是该离开一段时间了。2016年听的Eason的首
张专辑没给我带来惊艳，反而让我畏缩了：我会有一天突然不喜欢我一直热爱的
东西么？这一时期的例子还有跑步。如果是真的的，那简直太可怕了。

等我回归 Eason 的时候，我就知道我会一直热爱自己所喜爱的事物的。此刻随
机循环着收藏的Eason单曲。

**** osrf

http://www.osrfoundation.org/

Open Source Robotics Foundation

**** 软件源配置

*/etc/apt/sources.list.d*

#+BEGIN_EXAMPLE
   $ ls /etc/apt/sources.list.d
  dartsim-ppa-trusty.list              libccd-debs-ppa-trusty.list
  dartsim-ppa-trusty.list.save         libccd-debs-ppa-trusty.list.save
  dropbox.list.save                    lotem-rime-trusty.list
  fcitx-team-nightly-trusty.list       lotem-rime-trusty.list.save
  fcitx-team-nightly-trusty.list.save  mc3man-trusty-media-trusty.list
  fcl-debs-ppa-trusty.list             mc3man-trusty-media-trusty.list.save
  fcl-debs-ppa-trusty.list.save        ros-latest.list
  gazebo-latest.list                   ros-latest.list.save
  gazebo-latest.list.save              timxx-xmradio-trusty.list
  gazebo-stable.list                   timxx-xmradio-trusty.list.save
  gazebo-stable.list.save              wengxt-fcitx-nightly-trusty.list
  gophers-go-trusty.list               wengxt-fcitx-nightly-trusty.list.save
  gophers-go-trusty.list.save
#+END_EXAMPLE

**** 新得立

#+BEGIN_EXAMPLE
E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。
#+END_EXAMPLE

后台调用 apt-get 解决依赖问题。

安装 gazebo6, OK

安装 ros-jade, 删除 gazebo6, 安装了 gazebo5

用不着参考安装指导完全使用命令行方式安装。
*可以增加了 source （软件源） 之后使用新得立安装*

*抽象出做的内容，方法只是表象*

**** ros matlab

http://jp.mathworks.com/hardware-support/robot-operating-system.html?requestedDomain=www.mathworks.com

http://www.ros.org/news/2014/01/mathworks-releases-robot-operating-system-ros-support-from-matlab.html

**** openni

**** ros jade

1. xacro
   #+BEGIN_EXAMPLE
     inconsistent namespace redefinitions for xmlns:xacro:
      old: http://ros.org/wiki/xacro
      new: http://wiki.ros.org/xacro (/home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/mecanum.xacro)
     xacro.py is deprecated; please use xacro instead
   #+END_EXAMPLE

2. CMakeLists.txt 链接依然是 indigo

   重新 catkin_init_workspace

**** 根目录空间不足

#+BEGIN_EXAMPLE
卷文件系统根目录仅剩余856M的硬盘空间
#+END_EXAMPLE

- 增加主分区容量，可以使用U盘启动ubuntu，然后用gparted调整
- 在分一个区，挂接到/var, /opt, 然后把已有文件copy过去就行
- 系统应该有个叫baobab的图形界面程序，点开看看/分区都有哪些东西占地方咯
- apt-get autoclean看看把安装软件下载的缓存清理掉
**** Linux 建立无线局域网与如何连接

http://ubuntuhandbook.org/index.php/2014/09/3-ways-create-wifi-hotspot-ubuntu/

http://roylez.herokuapp.com/2011/08/11/hostapd.html

**** Emacs 简体繁体转换

https://groups.google.com/forum/#!topic/cn.bbs.comp.emacs/0nNRwGaN1X8


#+BEGIN_QUOTE
似乎还没人写过，我觉得意义不大，
这种转换造成的问题比起的作用更多，
很多错别字或者读不通的文章都是这种转换造成的，
比如这句话：“国”字的繁体是“國”，
转成繁体后变成了：“國”字的繁體是“國”，意思完全不对了。
其实繁体的文章又不是读不懂，转换它干嘛？多此一举。
#+END_QUOTE

1. 使用 hanconvert ，失败 https://github.com/monkey413/tongwen-emacs

2. 使用谷歌翻译(网页版)

*** 2016/01/07
**** routine

1. 表格 or 格式化文本?

   后者

2. elisp+keybinding or yasnippet

   yasnippet

   - 可以有默认值
   - 必要的时候可以使用 elisp 函数

3. snippet

   #+BEGIN_SRC snippet
     # -*- mode: snippet; require-final-newline: nil -*-
     # name: rt:RoutinesExpandingForOrg-agenda
     # key: rt
     # binding: direct-keybinding
     # --
     睡眠:${1:1:00}
     起床:${2:7:00}
     跑步:${3:5K}
     吉它:${4:0.5h}
     读书:${5:0.5h}
     Friends:${6:S01E01}
     Dota:${7:45m}
     早餐:${8:1}
     锻炼:${9:0+0}
     牛奶:${10:1}
   #+END_SRC

**** doxygen API

1. PDF vs HTML

   更喜欢 PDF，可以标注、搜索方便等

2. API vs Source Code

   更喜欢后者！

**** IDE
***** Emacs VS Vim

Emacs 更熟悉

Vim 慢慢来

***** IDE & project
***** 目标

- [ ] 头文件与源文件之间跳转
- [ ] 浏览Linux内核树
- [ ] 交互式大纲显示文件结构
- [ ] 以文件浏览器形式显示静态大纲树
- [ ] 符号引用
- [ ] 代码补全
- [ ] 头文件补全
- [ ] 在底部显示函数接口和变量定义
- [ ] 跳转到当前函数头
- [ ] 编译支持
- [ ] 编译输出
- [ ] GDB调试
- [ ] 查看手册

***** 头文件与源文件之间跳转

**** usb camera                                           :camera:web_cam:

#+BEGIN_EXAMPLE
   ~ $ fswebcam --no-banner -r 640x480 demo.jpg
  --- Opening /dev/video0...
  Trying source module v4l2...
  /dev/video0 opened.
  No input was specified, using the first.
  --- Capturing frame...
  Captured frame in 0.00 seconds.
  --- Processing captured image...
  Disabling banner.
  Writing JPEG image to 'demo.jpg'.
#+END_EXAMPLE
***** /dev/vedio*

/dev/video0

#+BEGIN_EXAMPLE
$ lsusb
Bus 001 Device 006: ID 1e4e:0102 Cubeternet GL-UPC822 UVC WebCam
#+END_EXAMPLE


***** fswebcam: Small and simple webcam software for *nix      :fswebcam:

- [[http://manpages.ubuntu.com/manpages/lucid/man1/fswebcam.1.html][Ubuntu manpages]]
- [[https://github.com/fsphil/fswebcam][github]]
- [[http://www.firestorm.cx/fswebcam/][Homepage]]
- http://www.bkjia.com/Linuxjc/992291.html

****** man                                                         :man:
******* NAME


fswebcam - Small and simple webcam for *nix.

******* SYNOPSIS


fswebcam [<options>] <filename> [[<options>] <filename> ... ]

******* DESCRIPTION


fswebcam  is  a  small  and  simple webcam app for *nix. It can capture
images  from  a  number  of  different  sources  and   perform   simple
manipulation  on  the  captured image. The image can be saved as one or
more PNG or JPEG files.

The PNG or JPEG image can be sent to stdio using the filename "-".  The
output filename is formatted by strftime.

******* CONFIGURATION

******** Configuration File

Config  files  use the long version of options without the "--" prefix.
Comments start with a # symbol at the beginning of the line.

******** General Options
-?, --help
       Show a usage summary.

-c, --config
       Load  options  from  a  file.  You can load more than one config
       file, and can mix them with command-line arguments.

       Note: This option can not be used from  within  a  configuration
       file.

-q, --quiet
       Hides all messages except errors.

-v, --verbose
       Print extra information during the capture process.

--version
       Print the version number and exit.

-l, --loop <frequency>
       Continually capture images. The time between images is specified
       in seconds.

       Default behaviour is to capture a single image and exit.

       Note: The time to capture the next image is calculated  relative
       to  the epoch, so an image will not be captured immediately when
       the program is first started.

--offset <seconds>
       Sets the offset to use when calculating when the next  image  is
       due in loop mode. Value can be positive or negative.

-b, --background
       Run  in  the background. In this mode stdout and console logging
       are unavailable.

--pid <filename>
       Saves the PID of the background process to the  specified  file.
       Ignored when not using background mode.

--log [file/syslog:]<filename>
       Redirect log messages to a file or syslog. For example

       --log output.log
       --log file:output.log
       --log syslog

--gmt  Use  GMT instead of the local timezone when formatting text with
       strftime.

******** Capture Options
-d, --device [<prefix>:]<device name>
       Set the source or device to use. The source module  is  selected
       automatically unless specified in the prefix.

       Default is /dev/video0.

       Available source modules, in order of preference:

       V4L2 - Capture images from a V4L2 compatible video device.
       V4L1 - Capture images from a V4L1 compatible video device.
       FILE - Capture an image from a JPEG or PNG image file.
       RAW - Reads images straight from a device or file.
       TEST - Draws colour bars.

-i, --input <input number or name>
       Set  the  input  to  use. You may select an input by either it’s
       number or name.

       Default is "0".

--list-inputs
       List available inputs for the selected source or device.

       fswebcam -d v4l2:/dev/video1 --list-inputs

-t, --tuner <tuner number>
       Set the tuner to use.

-f, --frequency <frequency>
       Set the frequency of the selected input or tuner. The value  may
       be read as KHz or MHz depending on the input or tuner.

-p, --palette <name>
       Try  to use the specified image format when capturing the image.

       Default is to select one automatically.

       Supported formats:

       PNG
       JPEG
       MJPEG
       RGB32
       RGB24
       BGR32
       BGR24
       YUYV
       UYVY
       YUV420P
       BAYER
       RGB565
       RGB555
       GREY

-r, --resolution <dimensions>
       Set the image resolution of the source  or  device.  The  actual
       resolution  used  may  differ  if  the  source  or device cannot
       capture at the specified resolution.

       Default is "384x288".

--list-framesizes
       Lists the supported resolutions for the selected source.

--list-framerates
       Lists the supported frame rates  for  the  selected  source  and
       resolution.

-F, --frames <number>
       Set the number of frames to capture. More frames mean less noise
       in the final image, however capture times  will  be  longer  and
       moving objects may appear blurred.

       Default is "1".

-S, --skip <number>
       Set  the number of frames to skip. These frames will be captured
       but won’t be use. Use this option if your camera sends some  bad
       or corrupt frames when it first starts capturing.

       Default is "0".

-D, --delay <delay>
       Inserts  a  delay after the source or device has been opened and
       initialised, and before the capture begins.  Some  devices  need
       this  delay to let the image settle after a setting has changed.
       The delay time is specified in seconds.

-R, --read
       Use read() to capture images. This can be slower but more stable
       with some devices.

       Default  is  to  use mmap(), falling back on read() if mmap() is
       unavailable.

-s, --set <name=value>
       Set a control. These are used by the source modules  to  control
       image or device parameters. Numeric values can be expressed as a
       percentage of there  maximum  range  or  a  literal  value,  for
       example:

       --set brightness=50% --set framerate=5

       Non-numeric controls are also supported:

       --set lights=on

       V4L2  features  a  type  of  control  called  a  ’button’. These
       controls do not take any  value,  but  trigger  an  action.  For
       example:

       --set "Restore Factory Settings"

       Control names and values are not case sensitive.

       Note:  Available  controls  will  vary  depending  in the source
       module  and  devices  used.  For  more   information   see   the
       --list-controls option.

--list-controls
       List  available  controls  and  their  current  values  for  the
       selected source module and device. For example:

       fswebcam -d v4l2:/dev/video2 --list-controls

******** Output Options
These options are performed in the order they  appear  on  the  command
line,  only  effecting  images  output  later  on the command line. For
example:

       fswebcam -r 640x480 output1.jpeg --scale 320x240 output2.jpeg

       Will  create  two  images,  "output1.jpeg"  containing  a   full
       resolution   copy  of  the  captured  image  and  "output2.jpeg"
       containing the same captured image but scaled to half the  size.

--no-banner
       Disable the banner.

--top-banner
       Position the banner at the top of the image.

--bottom-banner
       Position the banner at the bottom of the image.

       This is the default.

--banner-colour <#AARRGGBB>
       Set  the  colour  of  the banner. Uses the web-style hexadecimal
       format (#RRGGBB) to describe the  colour,  and  can  support  an
       alpha channel (#AARRGGBB). Examples:

       "#FF0000" is pure red.
       "#80000000" is semi-transparent black.
       "#FF000000" is invisible (alpha channel is at maximum).
       Default is "#40263A93".

--line-colour <#AARRGGBB>
       Set the colour of the divider line. See --banner-colour for more
       information.

       Default is "#00FF0000".

--text-colour <#AARRGGBB>
       Set the  colour  of  the  text.  See  --banner-colour  for  more
       information.

       Default is "#00FFFFFF".

--font <[file or font name]:[font size]>
       Set  the  font  used  in the banner. If no path is specified the
       path in the GDFONTPATH environment variable is searched for  the
       font.

       If no font size is specified the default of "10" will be used.

       Default is "luxisr:10".

--no-shadow
       Disable the text shadow.

--shadow
       Enable the text shadow.

       This is the default behaviour.

--title <text>
       Set the main text, located in the top left of the banner.

--no-title
       Clear the main text.

--subtitle <text>
       Set  the  sub-title  text,  located  in  the  bottom left of the
       banner.

--no-subtitle
       Clear the sub-title text.

--timestamp <text>
       Set the timestamp text, located in the top right of the  banner.
       This string is formatted by strftime.

       Default is "%Y-%m-%d %H:%M (%Z)".

--no-timestamp
       Clear the timestamp text.

--info <text>
       Set the info text, located in the bottom right of the banner.

--no-info
       Clear the info text.

--underlay <filename>
       Load  a PNG image and overlay it on the image, below the banner.
       The image is aligned to the top left.

       Note: The underlay is only applied when saving an image  and  is
       not modified by any of the image options or effects.

--no-underlay
       Clear the underlay image.

--overlay <filename>
       Load a PNG image and overlay on the image, above the banner. The
       image is aligned to the top left.

       Note: The overlay is only applied when saving an  image  and  is
       not modified by any of the image options or effects.

--no-overlay
       Remove the overlay image.

--jpeg <factor>
       Set JPEG as the output image format. The compression factor is a
       value between 0 and 95, or -1 for automatic.

       This is the default format, with a factor of "-1".

--png <factor>
       Set PNG as the output image format. The compression  factor  can
       be a value between 0 and 9, or -1 for automatic.

--save <filename>
       Saves the image to the specified filename.

       Note:  This isn’t necessary on the command-line where a filename
       alone is enough to save an image.

--revert
       Revert to the  original  captured  image  and  resolution.  This
       undoes all previous effects on the image.

       Note:  This  only reverts the image itself, and not options such
       as font, colours and overlay.

--flip <direction[,direction]>
       Flips the image. Direction can be  (h)orizontal  or  (v)ertical.
       Example:

       --flip h    Flips the image horizontally.
       --flip h,v  Flips the image both horizontally and vertically.

--crop <dimensions[,offset]>
       Crop  the  image.  With  no  offset the cropped area will be the
       center of the image. Example:

       --crop 320x240    Crops the center 320x240 area of the image.
       --crop 10x10,0x0  Crops the 10x10 area at the top left corner of
       the image.

--scale <dimensions>
       Scale the image.

       Example:  "--scale  640x480"  scales  the  image  up  or down to
       640x480.

       Note: The aspect ratio of the image is not maintained.

--rotate <angle>
       Rotate the image in right angles (90, 180 and 270 degrees).

       Note: Rotating the  image  90  or  270  degrees  will  swap  the
       dimensions.

--deinterlace
       Apply a simple deinterlacer to the image.

--invert
       Invert all the colours in the image, creating a negative.

--exec <command>
       Executes  the  specified  command  and  waits for it to complete
       before continuing. The command line is formatted by strftime.

******* SIGNALS

SIGHUP This causes fswebcam to reload it’s configuration.

SIGUSR1
       Causes fswebcam to capture an image immediately without  waiting
       on the timer in loop mode.

****** help                                                       :help:

#+BEGIN_EXAMPLE
   ~ $ fswebcam --help
  Usage: fswebcam [<options>] <filename> [[<options>] <filename> ... ]

   Options:

   -?, --help                   Display this help page and exit.
   -c, --config <filename>      Load configuration from file.
   -q, --quiet                  Hides all messages except for errors.
   -v, --verbose                Displays extra messages while capturing
       --version                Displays the version and exits.
   -l, --loop <seconds>         Run in loop mode.
   -b, --background             Run in the background.
   -o, --output <filename>      Output the log to a file.
   -d, --device <name>          Sets the source to use.
   -i, --input <number/name>    Selects the input to use.
   -t, --tuner <number>         Selects the tuner to use.
   -f, --frequency <number>     Selects the frequency use.
   -p, --palette <name>         Selects the palette format to use.
   -D, --delay <number>         Sets the pre-capture delay time. (seconds)
   -r, --resolution <size>      Sets the capture resolution.
       --fps <framerate>        Sets the capture frame rate.
   -F, --frames <number>        Sets the number of frames to capture.
   -S, --skip <number>          Sets the number of frames to skip.
       --dumpframe <filename>   Dump a raw frame to file.
   -s, --set <name>=<value>     Sets a control value.
       --revert                 Restores original captured image.
       --flip <direction>       Flips the image. (h, v)
       --crop <size>[,<offset>] Crop a part of the image.
       --scale <size>           Scales the image.
       --rotate <angle>         Rotates the image in right angles.
       --deinterlace            Reduces interlace artifacts.
       --invert                 Inverts the images colours.
       --greyscale              Removes colour from the image.
       --swapchannels <c1c2>    Swap channels c1 and c2.
       --no-banner              Hides the banner.
       --top-banner             Puts the banner at the top.
       --bottom-banner          Puts the banner at the bottom. (Default)
       --banner-colour <colour> Sets the banner colour. (#AARRGGBB)
       --line-colour <colour>   Sets the banner line colour.
       --text-colour <colour>   Sets the text colour.
       --font <[name][:size]>   Sets the font and/or size.
       --no-shadow              Disables the text shadow.
       --shadow                 Enables the text shadow.
       --title <text>           Sets the main title. (top left)
       --no-title               Clears the main title.
       --subtitle <text>        Sets the sub-title. (bottom left)
       --no-subtitle            Clears the sub-title.
       --timestamp <format>     Sets the timestamp format. (top right)
       --no-timestamp           Clears the timestamp.
       --gmt                    Use GMT instead of local timezone.
       --info <text>            Sets the info text. (bottom right)
       --no-info                Clears the info text.
       --underlay <PNG image>   Sets the underlay image.
       --no-underlay            Clears the underlay.
       --overlay <PNG image>    Sets the overlay image.
       --no-overlay             Clears the overlay.
       --jpeg <factor>          Outputs a JPEG image. (-1, 0 - 95)
       --png <factor>           Outputs a PNG image. (-1, 0 - 10)
       --save <filename>        Save image to file.
       --exec <command>         Execute a command and wait for it to complete.

#+END_EXAMPLE

***** uvc                                                           :uvc:

USB Video Class (UVC)

**** usb_cam

- http://wiki.ros.org/usb_cam

A ROS Driver for V4L USB Cameras

***** usb_cam_node

The =usb_cam_node= interfaces with standard USB cameras (e.g. the
Logitech Quickcam) using libusb_cam and publishes images as
sensor_msgs::Image. Uses the [[/image_transport][image_transport]]
library to allow compressed image transport.

****** Published Topics

=~<camera_name>/image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

- The image

****** Parameters

=~video_device= (=string=, default: ="/dev/video0"=)

- The device the camera is on.

=~image_width= (=integer=, default: =640=)

- Image width

=~image_height= (=integer=, default: =480=)

- Image height

=~pixel_format= (=string=, default: ="mjpeg"=)

- Possible values are mjpeg, yuyv, uyvy

=~io_method= (=string=, default: ="mmap"=)

- Possible values are mmap, read, userptr

=~camera_frame_id= (=string=, default: ="head_camera"=)

- The camera's tf frame

=~framerate= (=integer=, default: =30=)

- The required framerate

=~contrast= (=integer=, default: =32=)

- Contrast of video image (0-255)

=~brightness= (=integer=, default: =32=)

- Brightness of video image (0-255)

=~saturation= (=integer=, default: =32=)

- Saturation of video image (0-255)

=~sharpness= (=integer=, default: =22=)

- Sharpness of video image (0-255)

=~autofocus= (=boolean=, default: =false=)

- Enable camera's autofocus

=~focus= (=integer=, default: =51=)

- If autofocus is disabled, the focus of the camera (0=at infinity)

=~camera_info_url= (=string=, default: ==)

- An url to the camera calibration file that will be read by the
   [[/CameraInfoManager][CameraInfoManager]] class

=~camera_name= (=string=, default: =head_camera=)

- The camera name. This must match the name in the camera calibration

****** Related packages

[[/gencam_cu][gencam_cu]] - supports image capture from usb cameras
using OpenCV
**** 电源

- UTM

  [[/home/ben/Wally/Journal//Figure/scrot/151903Kb.png]]

- Microstrain

  [[/home/ben/Wally/Journal//Figure/scrot/15190EVh.png]]

- raspberry

  5V 1.2A
  - GPIO ： 50mA
  - HDMI : 50mA
  - Camera: 250mA
  - keyboard/mice: 100mA~1000mA

- LMS 291

  [[/home/ben/Wally/Journal//Figure/scrot/15190Rfn.png]]

Power

12*3 + 5*0.08 < 40W

https://e2e.ti.com/blogs_/b/powerhouse/archive/2015/09/16/high-density-pcb-layout-of-dc-dc-converters-part-2



***** 纹波

纹波(ripple)是由于直流稳定电源的电压波动而造成的一种现象，因为直流稳定电源一般
是由交流电源经整流稳压等环节而形成的，这就不可避免地在直流稳定量中多少
带有一些交流成份，这种叠加在直流稳定量上的交流分量就称之为纹波。纹波的
成分较为复杂，它的形态一般为频率高于工频的类似正弦波的谐波，另一种则是
宽度很窄的脉冲波。
**** latex 梯度                                                     :梯度:

\nabla

**** image_view

Released Continuous integration Documented

A simple viewer for ROS image topics. Includes a specialized viewer for
stereo + disparity images.

***** Usage

****** Viewing a single image topic

#+BEGIN_EXAMPLE
    image_view image:=<image topic> [image transport type]
#+END_EXAMPLE

For example, to view raw images on the topic =/camera/image=, use:

#+BEGIN_EXAMPLE
    image_view image:=/camera/image
#+END_EXAMPLE

You may save the current image by left-clicking on the display window.
By default, images will be saved as =frame0000.jpg=, =frame0001.jpg=,
.... }}}

If you want to view a compressed image stream (usually a good idea over
wireless!) using the capabilities of
[[/image_transport][image_transport]], specify the transport type as a
command-line argument. For example, if
[[/theora_image_transport][theora_image_transport]] is built on the
publisher's side, you can use =theora= transport:

#+BEGIN_EXAMPLE
    image_view image:=/camera/image theora
#+END_EXAMPLE

Note that this is merely shorthand equivalent to setting the
=~image_transport= parameter:

#+BEGIN_EXAMPLE
    image_view image:=/camera/image _image_transport:=theora
#+END_EXAMPLE

****** Viewing stereo images

#+BEGIN_EXAMPLE
    stereo_view stereo:=<stereo namespace> image:=<image topic identifier>
#+END_EXAMPLE

For example, to view stereo image pairs on topics
=/my_stereo_cam/left/image_rect_color= and
=/my_stereo_cam/right/image_rect_color=, use:

#+BEGIN_EXAMPLE
    stereo_view stereo:=/my_stereo_cam image:=image_rect_color
#+END_EXAMPLE

=stereo_view= also shows the disparity image computed from the stereo
pair, color-mapped for clarity.

You may save the current image pair by left-clicking on either display
window. By default, images will be saved as =left0000.jpg=,
=right0000.jpg=, =left0001.jpg=, =right0001.jpg=....

***** Nodes

****** image_view

Simple image viewer for ROS topics.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

- The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

- Whether the window should autosize itself to the image or be
   resizeable by the user.

=~filename_format= (=string=, default: ="frame%04i.jpg"=)

- printf-style format for saved image names. Use to control name,
   location and format of saved images.

=~image_transport= (=string=, default: ="raw"=)

- Transport used for the image stream. =image_view= allows you to
   specify this as a simple command-line argument for convenience.

=~window_name= (=string=, default: name of the image topic)

- The name of the display window.

****** stereo_view

Viewer for stereo images. Shows the left/right image pair and the
disparity image (color-mapped) computed from them.
******* Subscribed Topics

=<stereo>/left/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

- The left image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/right/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

- The right image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/disparity=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

- The disparity image computed from the left/right stereo pair.

******* Parameters

=~autosize= (=bool=, default: true)

- Whether the windows should autosize to the image or be resizeable by
   the user.

=~filename_format= (=string=, default: ="%s%04i.jpg"=)

- printf-style format for saved image names. Use to control name,
   location and format of saved images. The string argument is ="left"=
   or ="right"=.

=~image_transport= (=string=, default: ="raw"=)

- Transport used for the image streams.

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div
  class="version diamondback electric fuerte groovy hydro indigo jade">
#+END_HTML

#+BEGIN_HTML
  <div id="image_view.2BAC8-diamondback.content" dir="ltr" lang="en">
#+END_HTML

#+BEGIN_HTML
  <div class="table-of-contents">
#+END_HTML

Contents

1. [[#image_view.2BAC8-diamondback.Usage][Usage]]

   1. [[#image_view.2BAC8-diamondback.Viewing_a_single_image_topic][Viewing
      a single image topic]]
   2. [[#image_view.2BAC8-diamondback.Viewing_stereo_images][Viewing
      stereo images]]

2. [[#image_view.2BAC8-diamondback.Nodes][Nodes]]

   1. [[#image_view.2BAC8-diamondback.image_view][image_view]]
   2. [[#image_view.2BAC8-diamondback.disparity_view][disparity_view]]
   3. [[#image_view.2BAC8-diamondback.stereo_view][stereo_view]]

3. [[#image_view.2BAC8-diamondback.Nodelets][Nodelets]]

   1. [[#image_view.2BAC8-diamondback.image_view.2BAC8-image][image_view/image]]
   2. [[#image_view.2BAC8-diamondback.image_view.2BAC8-disparity][image_view/disparity]]

4. [[#image_view.2BAC8-diamondback.Tools][Tools]]

   1. [[#image_view.2BAC8-diamondback.image_saver][image_saver]]
   2. [[#image_view.2BAC8-diamondback.extract_images][extract_images]]
   3. [[#image_view.2BAC8-diamondback.video_recorder][video_recorder]]

#+BEGIN_HTML
  </div>
#+END_HTML

***** Usage

****** Viewing a single image topic

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=<image topic> [image transport type]
#+END_EXAMPLE

For example, to view raw images on the topic =/camera/image=, use:

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=/camera/image
#+END_EXAMPLE

You may save the current image by right-clicking on the display window.
By default, images will be saved as =frame0000.jpg=, =frame0001.jpg=,
....

If you want to view a compressed image stream (usually a good idea over
wireless!) using the capabilities of
[[/image_transport][image_transport]], specify the transport type as a
command-line argument. For example, if
[[/theora_image_transport][theora_image_transport]] is built on the
publisher's side, you can use =theora= transport:

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=/camera/image theora
#+END_EXAMPLE

Note that this is merely shorthand equivalent to setting the
=~image_transport= parameter:

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=/camera/image _image_transport:=theora
#+END_EXAMPLE

****** Viewing stereo images

#+BEGIN_EXAMPLE
    rosrun image_view stereo_view stereo:=<stereo namespace> image:=<image topic identifier>
#+END_EXAMPLE

For example, to view stereo image pairs on topics
=/my_stereo_cam/left/image_rect_color= and
=/my_stereo_cam/right/image_rect_color=, use:

#+BEGIN_EXAMPLE
    rosrun image_view stereo_view stereo:=/my_stereo_cam image:=image_rect_color
#+END_EXAMPLE

=stereo_view= also shows the disparity image computed from the stereo
pair, color-mapped for clarity.

You may save the current image pair by right-clicking on any display
window. By default, images will be saved as =left0000.jpg=,
=right0000.jpg=, =disp0000.jpg=, =left0001.jpg=, =right0001.jpg=,
=disp0001.jpg=.... As with =image_view=, you can specify an image
transport to use for the left and right image as an optional argument.

***** Nodes

****** image_view

Simple image viewer for ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topics.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

- The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

- Whether the window should autosize itself to the image or be
   resizeable by the user.

=~filename_format= (=string=, default: ="frame%04i.jpg"=)

- printf-style format for saved image names. Use to control name,
   location and format of saved images.

=~image_transport= (=string=, default: ="raw"=)

- Transport used for the image stream. =image_view= allows you to
   specify this as a simple command-line argument for convenience.

=~window_name= (=string=, default: name of the image topic)

- The name of the display window.

****** disparity_view

Simple viewer for
[[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]]
topics. Color-maps the disparity image for visualization.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

- The disparity image topic. Should be remapped to the name of the real
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

- Whether the window should autosize itself to the image or be
   resizeable by the user.

=~window_name= (=string=, default: name of the image topic)

- The name of the display window.

****** stereo_view

Viewer for stereo images. Shows the synchronized left/right image pair
and the disparity image (color-mapped) computed from them.
******* Subscribed Topics

=<stereo>/left/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

- The left image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/right/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

- The right image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/disparity=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

- The disparity image computed from the left/right stereo pair.

******* Parameters

=~autosize= (=bool=, default: true)

- Whether the windows should autosize to the image or be resizeable by
   the user.

=~filename_format= (=string=, default: ="%s%04i.jpg"=)

- printf-style format for saved image names. Use to control name,
   location and format of saved images. The string argument is ="left"=
   or ="right"=.

=~image_transport= (=string=, default: ="raw"=)

- Transport used for the image streams.

=~approximate_sync= (=bool=, default: false)

- Whether to use approximate synchronization. Set to true if the left
   and right cameras do not produce exactly synced timestamps.

=~queue_size= (=int=, default: 5)

- Size of message queue for each synchronized topic. You may need to
   raise this if disparity processing takes too long, or if there are
   significant network delays.

***** Nodelets

****** image_view/image

Nodelet version of image_view. Brings up a display window for a
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

- The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

- Whether the window should autosize itself to the image or be
   resizeable by the user.

=~filename_format= (=string=, default: ="frame%04i.jpg"=)

- printf-style format for saved image names. Use to control name,
   location and format of saved images.

=~image_transport= (=string=, default: ="raw"=)

- Transport used for the image stream. =image_view= allows you to
   specify this as a simple command-line argument for convenience.

=~window_name= (=string=, default: name of the image topic)

- The name of the display window.

****** image_view/disparity

Nodelet version of disparity_view. Brings up a display window for a
[[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]]
topic, color-mapped for visualization.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

- The disparity image topic. Should be remapped to the name of the real
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

- Whether the window should autosize itself to the image or be
   resizeable by the user.

=~window_name= (=string=, default: name of the image topic)

- The name of the display window.

#+BEGIN_HTML
  <div class="version hydro_and_newer">
#+END_HTML

***** Tools

****** image_saver

This tool allows you to save images as jpg/png file from streaming (ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic) to a file.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

- The image topic. Should be remapped to the name of the real image
   topic.

******* Services

=save=
([[http://docs.ros.org/api/std_srvs/html/srv/Empty.html][std_srvs/Empty]])

- Save images, you need to set save_all_images to false

******* Parameters

=~filename_format= (=string=, default: =left%04d.%s=)

- File name for saved images, you can use '%04i' for sequence number,
   and '%s' for default file format, you can use 'jpg' ,'png', 'pgm' as
   filename suffixes.

=~encoding= (=string=, default: 'bgr8')

- Encoding type of input image topic.

=~save_all_image= (=bool=, default: true)

- If you set false, images are only saved when 'save' service is called

****** extract_images

This tool also allows you to save images as jpg/png file from streaming
(ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic) to a file. =image_saver= node provide very similar
functionalities, such as providing service call to trigger the node to
save images, save images other than Jpeg format, etc.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

- The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~filename_format= (=string=, default: =frame%04d.jpg=)

- File name for saved images, you must add use '%04i' for sequence
   number.

=~sec_per_frame= (=double=, default: '0.1')

- set sec per frame value.

****** video_recorder

This tool allows you to record a video stream (ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic) to a file. It relies on
[[http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videowriter][OpenCV's
VideoWriter class]]. With the default options, it encodes the video as
MPG, encapsulated in a AVI container at 15 fps, and produces a file
called =output.avi= in the current directory.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

- The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~filename= (=string=, default: =output.avi=)

- Path and name of the output video.

=~fps= (=int=, default: 15)

- Framerate of the video.

=~codec= (=string=, default: =MJPG=)

- The [[http://www.fourcc.org/codecs.php][FOURCC]] identifier of the
   codec.

=~encoding= (=string=, default: =bgr8=)

- The image color space of the video.
*** 2016/01/06
**** vtk: Visualization Toolkit

The *Visualization Toolkit* (VTK) is an *open-source*, freely available
software system for _3D computer graphics, image processing, and
visualization._ It consists of =a C++ class library= and several
interpreted =interface= layers including Tcl/Tk, Java, and
*Python*. Kitware, whose team created and continues to extend the
toolkit, offers professional support and consulting services for
VTK. VTK supports a wide variety of *visualization algorithms* including
scalar, vector, tensor, texture, and volumetric methods, as well as
advanced modeling techniques such as implicit modeling, polygon
reduction, mesh smoothing, cutting, contouring, and Delaunay
triangulation. VTK has an extensive information visualization
framework and a suite of 3D interaction widgets. The toolkit supports
parallel processing and integrates with various databases on GUI
toolkits such as *Qt and Tk*. VTK is *cross-platform* and runs on Linux,
Windows, Mac, and Unix platforms.

**** org-download

- https://github.com/abo-abo/org-download


#+BEGIN_SRC emacs-lisp
  (require 'org-download)
  (setq org-download-method 'directory)
  (setq-default org-download-image-dir
                (concat (getenv "JOURNAL-WS") "/Figure/.org-download")) ; org-down 文件命名有时会比较丑，所以放在隐藏文件夹下
  (setq org-download-heading-lvl nil)
  (setq org-download-timestamp "_%Y-%m-%d_%H:%M:%S")
  ;; (define-key org-mode-map "\C-c\M-s" 'org-download-screenshot)
  (define-key org-mode-map "\C-c\M-y" 'org-download-yank)
  (setq org-download-backend "wget \"%s\" -O \"%s\"")
#+END_SRC

1. 从 chrome 中拖拽不管用

   委曲求全： 右键图片，复制图片网址， *org-download-image*

   #+BEGIN_EXAMPLE
     org-download-image is an interactive compiled Lisp function in
     `org-download.el'.

     (org-download-image LINK)

     Save image at address LINK to `org-download--dir'.
   #+END_EXAMPLE

2. 从 Firefox 中拖拽起作用
3. 从系统的文件管理器中拖拽起作用

*** 2016/01/04
**** chrome 下载文件命名编码

1. why?

   百度云打包下载的压缩文件命名正确，解压后出现乱码

2. 设置 chrome 字体编码

   http://jingyan.baidu.com/article/e52e36154b3ff640c70c515f.html
   http://www.tuicool.com/articles/VjInAf

   扳手-------->Settings（设置）-------->ShowAdvance Settings（显示高
   级设置）-------->Web Content（网页内容）-------->Customizefonts（自
   定义字体）-------->Encoding（编码）

3. 不是 chrome 的问题，是百度云的问题，没解决，不重要

   http://www.zhihu.com/question/28144692

**** RS232                                                         :rs232:
***** RS-232 Wiki


*RS-232* 是美国[[/wiki/%E7%94%B5%E5%AD%90%E5%B7%A5%E4%B8%9A%E8%81%94%E7%9B%9F][电子工业联盟]]（EIA）制定的串行数据通信的接口标准。它被广
泛用于计算机串行接口外设连接。


它規定連接[[/wiki/%E9%9B%BB%E7%BA%9C][電纜]]和[[/wiki/%E6%A9%9F%E6%A2%B0][機械]]、[[/wiki/%E9%9B%BB%E6%B0%A3][電氣]]特性、信號功能及傳送過程。其他常用電氣標準還有
[[/wiki/EIA-422][EIA-RS-422-A]]、[[/w/index.php?title=EIA-423&action=edit&redlink=1][EIA-RS-423A]]、[[/wiki/RS-485][EIA-RS-485]]。

由於RS-232-C的重大影響，即使自IBM [[/wiki/PC/AT][PC/AT ]]開始改用9針連接器起，目前已幾
乎不再使用RS-232中規定的25針連接器，但大多數人仍然普遍使用RS-232C來代
表此一介面。

****** 标准的细节

在RS-232标准中，字符是以一序列的位元串来一个接一个的[[/w/index.php?title=%E4%B8%B2%E5%88%97&action=edit&redlink=1][串列]]（serial）方式
傳輸，優點是傳輸線少，配線簡單，傳送距離可以較遠。最常用的编码格式是异
步起停（asynchronous start-stop）格式，它使用一个起始位元后面紧跟7或8
个数据位元（bit），然后是可选的奇偶校验位元，最后是一或两个停止位元。
所以发送一个字符至少需要10位元，带来的一个好的效果是使全部的传输速率，
发送信号的速率以10划分。一个最平常的代替异步起停方式的是使用[[/wiki/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6][高级数据链
路控制]]协议（HDLC）。

在RS-232标准中定义了逻辑一和逻辑零电压级数，以及标准的传输速率和连接器
类型。信号大小在正的和负的3－15v之间。RS-232规定接近零的电平是无效的，
逻辑一规定为负电平，有效负电平的信号状态称为传号marking，它的功能意义
为OFF，逻辑零规定为正电平，有效正电平的信号状态称为空号spacing，它的功
能意义为ON。根据设备供电电源的不同，±5、±10、±12和±15这样的电平都
是可能的。


******* 连接器

RS-232設計之初是用來連接數據機做傳輸之用，也因此它的腳位意義通常也和數
據機傳輸有關。RS-232的设备可以分为数据终端设备（DTE，Data Terminal
Equipment, For example, PC）和数据通信设备（DCE，Data Communication
Equipment）两类，这种分类定义了不同的线路用来发送和接受信号。一般来说，
计算机和终端设备有DTE连接器，调制解调器和打印机有DCE连接器。但是这么说
并不是总是严格正确的，用配线分接器测试连接，或者用试误法来判断电缆是否
工作，常常需要参考相关的文件说明。

RS-232指定了20个不同的信号连接，由25个D-sub（微型D类）管脚构成的DB-25
连接器。

很多设备只是用了其中的一小部分管脚，出于节省资金和空间的考虑不少机器采
用较小的连接器，特别是9管脚的D-sub或者是 *DB-9* 型连接器被广泛使用绝大
多数自IBM的AT机之后的PC机和其他许多设备上。DB-25 和 DB-9 型的连接器在大部
分设备上是雌型，但不是所有的都是这样。

下表中列出的是被较多使用的RS-232中的信号和管脚分配：

#+BEGIN_EXAMPLE
               DE-9 Male（Pin Side）                   DE-9 Female (Pin Side）
                 -------------                          -------------
                 \ 1 2 3 4 5 /                          \ 5 4 3 2 1 /
                  \ 6 7 8 9 /                            \ 9 8 7 6 /
                   ---------                              ---------
#+END_EXAMPLE

| 信号                | DB-25 | DE-9 | EIA/TIA 561 | Yost |
|---------------------+-------+------+-------------+------|
| 公共接地            |     7 |    5 |           4 |  4,5 |
| 发送数据（TD、TXD） |     2 |    3 |           6 |    3 |
| 接受数据（RD、RXD） |     3 |    2 |           5 |    6 |
| 数据终端准备（DTR） |    20 |    4 |           3 |    2 |
| 数据准备好（DSR）   |     6 |    6 |           1 |    7 |
| 请求发送（RTS）     |     4 |    7 |           8 |    1 |
| 清除发送（CTS）     |     5 |    8 |           7 |    8 |
| 数据载波检测（DCD） |     8 |    1 |           2 |    7 |
| 振铃指示（RI）      |    22 |    9 |           1 |   － |

| 腳位 | 簡寫 | 意義                | 說明                           |
|------+------+---------------------+--------------------------------|
| Pin1 | CD   | Carrier Detect      | 數據機通知電腦有載波被偵測到。 |
| Pin2 | RXD  | Receiver            | 接收資料。                     |
| Pin3 | TXD  | Transmit            | 傳送資料。                     |
| Pin4 | DTR  | Data Terminal Ready | 電腦告訴數據機可以進行傳輸。   |
| Pin5 | GND  | Ground              | 地線。                         |
| Pin6 | DSR  | Data Set Ready      | 數據機告訴電腦一切準備就緒。   |
| Pin7 | RTS  | Request To Send     | 電腦要求數據機將資料送出。     |
| Pin8 | CTS  | Clear To Send       | 數據機通知電腦可以傳資料過來。 |
| Pin9 | RI   | Ring Indicator      | 數據機通知電腦有電話進來。     |

TXD DTE->DCE DTE SEND DATA

RXD DCE->DTE DTE RECEIVE DATA

RTS DTE->DCE DTE REQUEST SEND

CTS DCE->DTE ACK TO DTE'S RTS

DSR DCE->DTE DCE IS READY

GND

DCD DCE->DTE DC DETECTED

DTR DTE->DCE DTE IS READY

RI DCE->DTE RING INDICATION

信号的标注是从DTE设备的角度出发的，TD、DTR和RTS信号是由DTE产生的，RD、DSR、CTS、DCD和RI信号是由DCE产生的。接地信号是所有连接都公共的，在Yost的标准中接地信号外部有两个管脚事实上是同一个信号。如果两个通信设备的距离相差的很远或者是有两个不同的供电系统供电，那么地信号在两个设备间会不一样，从而导致通信失败，跟踪描述这样的情形是很困难的。

******* 设置

串行通信在软件设置里需要做多项设置，最常见的设置包括[[/wiki/%E6%B3%A2%E7%89%B9%E7%8E%87][波特率]]（Baud）、奇偶校验（Parity
Check）和停止位（Stop Bit）。

- 波特率（又称[[/wiki/%E9%AE%91%E7%8E%87][鮑率]]）：是指从一设备发到另一设备的波特率，即每秒钟多少符號。典型的波特率是300,
   1200, 2400, 9600, 19200,
   115200等。一般通信两端设备都要设为相同的波特率，但有些设备也可设置为自动检测波特率。

- 奇偶校验（Parity：是用来验证数据的正确性。奇偶校验一般不使用，如果使用，那么既可以做奇校验（Odd
   Parity）也可以做偶校验（Even
   Parity）。奇偶校验是通过修改每一发送字节（也可以限制发送的字节）来工作的。如果不作奇偶校验，那么数据是不会被改变的。在偶校验中，因为奇偶校验位会被相应的置1或0（一般是最高位或最低位），所以数据会被改变以使得所有传送的数位（含字符的各数位和校验位）中“1”的个数为偶数；在奇校验中，所有传送的数位（含字符的各数位和校验位）中“1”的个数为奇数。奇偶校验可以用于接受方检查传输是否发送生错误------如果某一字节中“1”的个数发生了错误，那么这个字节在传输中一定有错误发生。如果奇偶校验是正确的，那么要么没有发生错误要么发生了偶数个的错误。如果使用者選擇資料長度為8位元，則因為沒有多餘的位元可被用來作為同位元，因此就叫做「非奇偶校验（Non
   Parity）」。

- 停止位：是在每个字节传输之后发送的，它用来帮助接受信号方硬件重同步。

RS-232在傳送資料時，並不需要另外使用一條傳輸線來傳送同步訊號，就能正確
的將資料順利傳送到對方，因此叫做「非同步傳輸」，簡稱UART（Universal
Asynchronous Receiver Transmitter），不過必須在每一筆資料的前後都加上
同步訊號，把同步訊號與資料混和之後，使用同一條傳輸線來傳輸。

在串行通信软件设置中D/P/S是常规的符号表示。8/N/1（非常普遍）表明8bit数
据，没有奇偶校验，1bit停止位。数据位可以设置为5、6、7或者8位元（不可以
大於8或小於5），奇偶校验位可以设置为无（N）、奇（O）或者偶（E），奇偶
校验可以使用数据中的位元（bit），所以8/E/1就表示一共8位数据位，其中一
位用来做奇偶校验位。停止位可以是1、1.5或者2位的（1.5是用在波特率为
60wpm的电传打字机上的）。


- 流量控制：当需要发送[[/wiki/%E6%8F%A1%E6%89%8B%E4%BF%A1%E5%8F%B7][握手信号]]或数据完整性检测时需要制定其他设置。公用的组合有RTS/CTS,
   DTR/DSR或者XON/XOFF（实际中不使用连接器管脚而在数据流内插入特殊字符）。

****** 類似規範

- [[/wiki/%E5%9B%BD%E9%99%85%E7%94%B5%E4%BF%A1%E8%81%94%E7%9B%9F%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84][ITU-T]]（前CCITT）的對應規範，用語不同，但電氣規格幾乎相同

   -  ITU-T V.28

- 具有相似的通信目的，但功能與電氣規範不同

   -  [[/wiki/RS-422][RS-422]]
   -  [[/w/index.php?title=RS-423&action=edit&redlink=1][RS-423]]
   -  [[/wiki/RS-449][RS-449]]
   -  [[/wiki/RS-485][RS-485]]

****** 外部連結

- [[http://www.zywyn.com.tw/index.php][RS-232 professional maker (ZYWYN.com）]]
- [[http://www.camiresearch.com/Data_Com_Basics/RS232_standard.html][RS-232 tutorial]]
- [[http://www.yost.com/Computers/RJ45-serial/][Yost Serial Device Wiring Standard]]
- [[http://www.acumeninstruments.com/Support/documentation/SerialPortBasics/index.shtml][Serial Port Basics]]
- [[http://www.lammertbies.nl/comm/info/RS-232.html][RS232 serial port info]]
- [[http://www.tronisoft.com/rs232info/ASCII_serial_port_crib_sheets.pdf][Printable ASCII Serial Port Crib Sheets]]

***** RS232

- http://c.biancheng.net/cpp/html/1919.html

标准串口，在物理结构上分为 9 针的和 9 孔的，习惯上我们也称之为公头和母
头

[[/home/ben/Wally/Journal//Figure/scrot/2983mBR.png]]

RS232 接口一共有 9 个引脚，分别定义是：1、载波检测 DCD；2、接收数据
RXD；3、发送数据 TXD；4、数据终端准备好 DTR；5、信号地线 SG；6、数据准
备好 DSR；7、请求发送 RTS；8、清除发送 CTS；9、振铃提示 RI。我们要让这
个串口和我们单片机进行通信，我们只需要关心其中的 2 脚 RXD、3 脚 TXD 和
5 脚 GND 即可。

虽然这三个引脚的名字和我们单片机上的串口名字一样，但是却不能直接和单片
机对连通信，这是为什么呢？随着我们了解的内容越来越多，我们得慢慢知道，
不是所有的电路都是 5V 代表高电平而 0V 代表低电平的。对于 RS232 标准来
说，它是个反逻辑，也叫做负逻辑。为何叫负逻辑？它的 TXD 和 RXD 的电
压，-3V～-15V 电压代表是 1，+3～+15V 电压代表是 0。低电平代表的是 1，
而高电平代表的是 0，所以称之为负逻辑。因此电脑的 9 针 RS232串口是不能
和单片机直接连接的，需要用一个电平转换芯片 MAX232 来完成.

[[/home/ben/Wally/Journal//Figure/scrot/2983zLX.png]]

 RS232 串口和 UART 串口，它们的协议类型是一样的，只是电平标准不同而已，
 而 MAX232 这个芯片起到的就是中间人的作用，它把 UART 电平转换成 RS232
 电平，也把 RS232 电平转换成 UART 电平，从而实现标准 RS232接口和单片机
 UART 之间的通信连接。

***** RS485                                                       :rs485:
****** EIA-485 wiki                                               :wiki:

*EIA-485*（过去叫做*RS-485*或者*RS485*）是隶属于[[/wiki/OSI%E6%A8%A1%E5%9E%8B][OSI模型]][[/wiki/%E7%89%A9%E7%90%86%E5%B1%82][物理层]]的电气特
性规定为2线，[[/wiki/%E5%8D%8A%E9%9B%99%E5%B7%A5][半双工]]，多点通信的标准。它的电气特性和[[/wiki/RS-232][RS-232]]不大一样。用
缆线两端的[[/wiki/%E7%94%B5%E5%8E%8B][电压]]差值来表示传递信号，1极的电压标识为逻辑1，另一段标识为逻
辑0。两端的电压差最小为0.2V以上时有效，任何不大于12V或者不小于－7V的差
值对接受端都被认为是正确的。

EIA-485仅仅规定了接受端和发送端的电气特性。它没有规定或推荐任何数据协
议。EIA-485可以应用于配置便宜的[[/wiki/%E5%B9%BF%E5%9F%9F%E7%BD%91][广域网]]和采用单机发送，多机接受通信链接。
它提供高速的数据通信速率（10m时35[[/w/index.php?title=Bitrate&action=edit&redlink=1][Mbit/s]]；1200m时100[[/w/index.php?title=Bitrate&action=edit&redlink=1][kbit/s]]1200m）。

EIA-485和[[/wiki/EIA-422][EIA-422]]一样使用双绞线进行高电压差分平衡传输，它可以进行大面积
长距离传输（超过4000[[http://zh.wikipedia.org/wiki/%E8%8B%B1%E5%B0%BA][英尺]]，1200米）。

和EIA-422相对照的是，EIA-422采用不可转换的单发送端，EIA-485的发送端需
要设置为发送模式，这使得EIA-485可以使用双线模式实现真正的多点双向通信。

EIA-485推荐使用在点对点网络中，线型、总线型，不能是星型、环型网络。理
想情况下EIA-485需要2个终接电阻，其阻值要求等于传输电缆的特性阻抗。没有
特性阻抗的话，当所有的设备都静止或者没有能量的时候就会产生噪声，而且线
移需要双端的电压差。没有终接电阻的话，会使得较快速的发送端产生多个数据
信号的边缘，这其中的一些是不正确的。之所以不能使用星型或者环型的拓扑结
构是由于这些结构有不必要的反映，过低或者过高的终接电阻可以产生电磁干扰。

EIA-485在使用四线时可以和EIA-422一样实现[[/wiki/%E5%85%A8%E9%9B%99%E5%B7%A5][全双工]]。EIA-485可以实现真正的
多点通信，在许多情况下并没有什么用处。在某些限制条件下，EIA-485和
EIA-422可以实现相互的连接。

******* 比较

下面的表格列出了RS-485的一些特性和引脚的分配以及和[[/wiki/RS-232][RS-232]]的比较：

| EIA-485                    | [[/wiki/RS-232][RS-232]]                    | [[/w/index.php?title=D-subminiature&action=edit&redlink=1][DB-25]] | [[/w/index.php?title=D-subminiature&action=edit&redlink=1][DE-9]] | [[/w/index.php?title=RJ-50&action=edit&redlink=1][RJ-50]] |
|----------------------------+---------------------------+-------+------+-------|
| Common Ground              | Carrier Detect（DCD）     |     8 |    1 |    10 |
| Clear To Send +（CTS+）    | Received Data (RD)        |     3 |    2 |     9 |
| Ready To Send +（RTS+）    | Transmitted Data (TD)     |     2 |    3 |     8 |
| Received Data +（RxD+）    | Data Terminal Ready (DTR) |    20 |    4 |     7 |
| Received Data -（RxD-）    | Common Ground             |     7 |    5 |     6 |
| Clear To Send -（CTS-）    | Data Set Ready (DSR)      |     6 |    6 |     5 |
| Ready To Send -（RTS-）    | Request To Send (RTS)     |     4 |    7 |     4 |
| Transmitted Data +（TxD+） | Clear To Send (CTS)       |     5 |    8 |     3 |
| Transmitted Data -（TxD-） | Ring Indicator (RI)       |    22 |    9 |     2 |

**** Navigator

***** note

1. STM32 主控
2. 模块化： 每一个模块通过 CAN 或 UART 可以发送命令或接收数据
3. 可编程！！！
4. 有内部使用的CAN控制器
5. 使用CAN

***** 需要用它干嘛？

1. 获取编码器数据用于计算位置
2. 发送控制指令
3. 指令的封装？？ ROS how?

***** 暂时没有能力做这件事情。。。。

***** 复制到 Reference 目录下新建的 Product 文件夹下

**** auctex 按键绑定移植到 org 中

C-c C-f 前缀

#+BEGIN_EXAMPLE
  C-a                          \mathcal{ }
  C-b        \textbf{ }         \mathbf{ }
  C-c        \textsc{ }
  C-e          \emph{ }
  C-f        \textsf{ }         \mathsf{ }
  TAB        \textit{ }         \mathit{ }
  RET        \textmd{ }
  C-n    \textnormal{ }     \mathnormal{ }
  C-r        \textrm{ }         \mathrm{ }
  C-s        \textsl{ }         \mathbb{ }
  C-t        \texttt{ }         \mathtt{ }
  C-u        \textup{ }
  C-d  -- delete font
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  ;; (mapc (lambda(key-macro)
  ;;         (define-key org-mode-map (format "\C-cf%s" (car key-macro)) '(insert (cdr key-macro))))
  ;;       '(("i" "\\mathit{}")            ; note: escapte needed
  ;;         ("I" "\\textit{}")
  ;;         ("b" "\\mathbf{}")
  ;;         ("B" "\\textbf{}")))

  (define-key org-mode-map "\C-cfi" '(insert "\\mathbf{}"))
#+END_SRC

1. 不能使用 C-c C-f 作为前缀，因为已经绑定了
2. 不如使用 yasnippet

#+BEGIN_EXAMPLE
# -*- mode: snippet; require-final-newline: nil -*-
# name: mb:latex-mathbf
# key: mb
# binding: direct-keybinding
# --
\mathbf{$0}
#+END_EXAMPLE

**** IMU

project imutb simulation

*** 2016/01/03
**** BBDB: 通讯录管理
***** Reference

- [[http://savannah.nongnu.org/projects/bbdb/][Homepage]]
- [[http://bbdb.sourceforge.net/][Sourceforge(旧的项目主页)]]
- [[http://www.emacswiki.org/emacs/CategoryBbdb][EmacsWiki: Bddb category]]
- [[https://github.com/emacs-china/hello-emacs/blob/master/bbdb%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.org][Github 上的中文教程]]

***** Intro

BBDB is the Insidious =Big Brother Database= for GNU Emacs. It provides
_an address book for email and snail mail addresses, phone numbers and
the like_. It can be linked with various Emacs mail clients (Message
and Mail mode, Rmail, Gnus, MH-E, and VM). BBDB is fully customizable.

#+BEGIN_QUOTE
big brother DB, 用来管理数据的，比如mailing address book等等，和Gnus搭
配着用。Zawinski写的。

BBDB我主要是用来做通讯录管理， 它与gnus发邮件互通， 效果十分好。

BBDB里， 头像支持图片。 然后写一小段lisp代码， 它BBDB的数据转成vCard通
讯录格式， 定期同步到手机上。

#+END_QUOTE
***** 概念

- [[http://baike.baidu.com/link?url=WuKUitPM002pg1xs8GguhXm4nV8pqZcnY47opo6WmnfAz3QmGv3nMdJ3kDst5yP8_dv2pe3sBv7_dkCoopOFmK][vCard]]: 电子名片
- csv：网络交易平台商品信息数据包

***** 安装

1. 源码方式
2. Melpa

   #+BEGIN_EXAMPLE
     I bbdb               20151114.... available  melpa      The Insidious Big Brother Database for GNU Emacs
     I bbdb-android       20150705.... available  melpa      Android phone contacts import/export for BBDB
     I bbdb-china         20150615.... available  melpa      BBDB utils, which let Chinese BBDB users feel easy
     I bbdb-vcard         20150713.... available  melpa      vCard import/export for BBDB
   #+END_EXAMPLE

***** 使用

1. M-x bbdb-xxxx
2. M-x bbdb-vcard-xxx

***** bbdb简单使用教程

#  Github 上使用 org-mode 写的教程，相当不错

****** 配置

最简单的配置方法就是将下面的语句放入Emacs初始化文件中

#+BEGIN_SRC emacs-lisp
  (require 'bbdb)
  (bbdb-initialize)
#+END_SRC

这里的`bbdb-initialize'会初始化bbdb,并开启最基本的查询/维护记录功能.

除了最基本的查询/维护记录功能外,bbdb还有一些与其他package联合使用的特性,要开启这些特性,则需要在调用`bbdb-initialize'时传入其他的参数.

`bbdb-initialize'可以接收一系列的symbol作为参数,这些symbol决定了bbdb初始化时会开启与哪些package交互的特性. 这些symbol的说明如下表所示:
#+NAME: bbdb-initialize参数说明
| symbol  | meaning                                                               |
|---------+-----------------------------------------------------------------------|
| gnus    | Gnus mail/news reader. *should probably also pass the message symbol* |
| mh-e    | MH-E mail reader.                                                     |
| rmail   | Rmail mail reader.                                                    |
| vm      | VM mail reader.                                                       |
| mail    | Mail (M-x mail).                                                      |
| message | Message mode.                                                         |
| anniv   | Anniversaries in Emacs diary.                                         |
| sc      | Supercite.                                                            |
| pgp     | PGP support:                                                          |

******* 为其他package增加BBDB支持
bbdb提供了一系列的`bbdb-insinuate-xxxx'函数来为xxxx package提供BBDB的支持. 这些函数为package增加了默认的快捷键,并且配置这些package当收到新message时,通知bbdb.

例如:为了給gnus增加bbdb的支持,我们可以添加下面的语句到Emacs初始化文件中
#+BEGIN_SRC emacs-lisp
  (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)
#+END_SRC
****** BBDB基础
******* BBDB数据库结构
BBDB数据库由一系列的记录组成,每条记录对应一个联系人或组织. 每条记录由多种域组成,每种域对应联系人/组织的一个属性.

BBDB内置支持一些类型的域:
| type        | Description                              | Notes                                           |
|-------------+------------------------------------------+-------------------------------------------------|
| NAME        | 联系人的名称,若该记录表示一个组织,则为空         | 一条记录只能有一个该类型的域,一个域只能有一个值 |
| orgnization | 联系人所在的组织,可以为空                     | 一条记录只能有一个该类型的域,一个域只能有一个值 |
| AKA         | 联系人的别名                                | 一个域可以有多个值,以逗号分隔                  |
| mail        | 联系人的email地址                           | 一个域可以有多个值,以逗号分隔                  |
| Phone       | 联系人的电话                                | 一条记录可以有多个该类型的域,一个域只能有一个值 |
| address     | 联系人的地址                                | 一条记录可以有多个该类型的域,一个域只能有一个值 |
| Notes       | 其他说明                                   |  一条记录可以有多个该类型的域,一个域只能有一个值 |
******** 自定义类型
除了上面BBDB内置的域类型,我们还可以自定一些域类型. BBDB处理大多数自定义类型的域时,与Notes类型域一样,但是对有一些特殊名称的域类型,BBDB会进行特殊处理:
+ aka :: 用于存储指定记录的non-primary names
+ finger-host :: Address used in place of the listed net address for fingering the entity indicated by the record
+ gnus-score :: Gnus scoring adjustment for this person.
+ mail-alias :: Value used instead of name for completion
+ mail-name ::  Used for the storage of non-default names to be used in the reporting of new mail by Reportmail.
+ mark-char :: The field containing the character to be used for marking a given poster in the Gnus Summary Buffer
+ tex-name :: The value of this field is used in place of the name field when printing the database using bbdb-print
+ www :: This field contains the URL associated with the BBDB record.
******* BBDB相关命令
******** 搜索记录
********* bbdb

执行该命令后,输入一个正则表达式,则bbdb会列出任何域中的值符合该正则表达式的记录

********* bbdb-search-name/bbdb-search-organization/bbdb-search-address/bbdb-search-mail/bbdb-search-notes/bbdb-search-phone

执行该命令后,输入一个正则表达式,则bbdb会列出指定域中的值符合该正则表达式的记录

********* bbdb-timestamp-older

执行该命令后,输入一个`yyyy-mm-dd'格式的日期,则bbdb会列出在指定日期之前修改过的记录

********* bbdb-timestamp-newer

执行该命令后,输入一个`yyyy-mm-dd'格式的日期,则bbdb会列出在指定日期之后修改过的记录

********* bbdb-creation-older

执行该命令后,输入一个`yyyy-mm-dd'格式的日期,则bbdb会列出在指定日期之前创建的记录

********* bbdb-creation-newer

执行该命令后,输入一个`yyyy-mm-dd'格式的日期,则bbdb会列出在指定日期之后创建的记录

********* bbdb-creation-no-change

执行该命令后,bbdb会列出自创建以来,从未修改过的记录

******** 增加记录
********* bbdb-create

执行该命令后,bbdb会以此提示输入各个内置域的相关信息,然后根据这些相关信息新建一条记录

********* bbdb-snarf

该命令可以根据一定规则将选中的字符串转换成bbdb格式的记录. 默认的转换规则由变量`bbdb-snarf-rule-default'决定. 详细参见`bbdb-snarf-rule-alist'

******* BBDB Mode使用说明
使用BBDB的查询命令后,会弹出一个名为`*BBDB*'的buffer,该buffer处于bbdb mode下.

bbdb mode下拥有许多维护BBDB记录的各种命令,常用的命令有:

******** e (bbdb-edit-field)

修改记录中当前域的值

******** ; (bbdb-edit-foo)

若不带前置参数执行该命令,则修改`(car bbdb-edit-foo)'所表示的域(默认为notes)

若代前置参数执行该命令,则修改`(cdr bbdb-edit-foo)'所表示的域(默认为current-fields)

******** d / C-k (bbdb-delete-field-or-record)

删除光标所在的域,若光标所处的域为bbdb记录的第一个行,则会提示删除整个记录.

This may also be applied to multiple records at once by *.

******** i (bbdb-insert-field)

为当前记录添加新域,该新域的类型可以是BBDB的内置类型,也可以是新的用户自定义类型.

******** C-x C-t (bbdb-transpose-fields)

交换光标所在的field与上一行field的位置

若带参数0执行该命令,则光标所在的域与mark标记的域进行交换

With non-zero numeric argument ARG, the previous field is moved past ARG fields.

交换的field必须在同一条记录中,且具有相同的类型

******** n (bbdb-next-record)/ p (bbdb-prev-record)

移动到下一个/上一个记录,若带前缀参数N,则下移/上移N条记录

******** t (bbdb-toggle-records-layout)


切换是否显示记录中具体域的说明.

若带参数0调用该函数,则强制光标所在记录不显示记录域说明,此时,所有的域信息都压缩到一行内显示.

当待其他参数调用该函数时,则强制光标所在记录显示记录中的域说明时,此时,当前记录使用多行样式显示.

若使用`*t'而不是`t',则buffer内所有的记录都同时切换显示样式

******** T (bbdb-display-record-completely)

谢换是否展示当前记录的所有域,这时平时隐藏不显示的`creation-date'和`timestamp'都会显示出来.

******** o (bbdb-omit-record)

隐藏当前记录,但并不会将当前记录从BBDB数据库中删除掉.

若带参数N执行该命令,则会隐藏下面N条记录,N可以为负数

******** m (bbdb-mail)

发送电子邮件給当前的联系人. 默认邮件地址为记录中的第一个email地址.

若带参数N调用该函数,则表示邮件地址使用记录周公的第N个email地址

若使用`*m'而不是`m',则表示給该buffer中的所有联系人发送电子邮件

******** s /C-x C-s (bbdb-save)

保存BBDB数据库到文件中

******** M-d (bbdb-dial)

该命令会尝试着去拨打光标所在的数字. 若光标处于一条记录的开头,则会拨打第一个phone域.

具体原理不明...

******** q (quit-window)

退出bbdb窗口,但不会kill bbdb buffer

******** ? (bbdb-help)

在minibuffer中显示简易帮助信息

******** h (bbdb-info)

显示bbdb的info文档

若bbdb的info文档没有安装在标准的info目录下,可以通过设置`bbdb-info-file'变量来明确指明bbdb info文件的路径

******** (bbdb-print)

将BBDB记录导出到Tex文件中.

******** c (bbdb-create)

创建新记录保存新的联系人信息

******** C (bbdb-copy-records-as-kill)

将当前记录拷贝到kill ring中

若使用`* C'则拷贝buffer中的所有记录到kill ring中

******** b (bbdb)

重新查询bbdb数据库

******** / m (bbdb-search-mail)

搜索mail域

******** / a (bbdb-search-address)

搜索address域

******** / c (bbdb-search-changed)

搜索至上次保存后,改变过的bbdb记录

******** / d (bbdb-search-duplicates)

搜索具有相同域的记录

******** / n (bbdb-search-name)

搜索name域

******** / o (bbdb-search-organization)

搜索organization域

******** / p (bbdb-search-phone)

搜索phone域

******** / x (bbdb-search-xfields)

搜索xfield域(该域存什么?我也不知道...)

******** * (bbdb-do-all-records)

该命令用于修改紧接之后的命令的作用域,让其作用于buffer中的所有记录.(Command prefix for operating on all records currently displayed.)

但只对某些特定的命令有效

****** 配置

******* 配置项
+ bbdb-file

  bbdb数据库的存储路径,默认为`~/.bbdb'

+ bbdb-default-area-code

  当输入新电话好吗时,使用的默认区号.

  该变量的值也会影响到拨打电话时的行为

+ bbdb-address-format-list

  用于编辑/显示BBDB地址信息时的规则列表.

+ bbdb-continental-postcode-regexp

  该正则表达式决定了BBDB的address是否为欧洲格式的地址.

  若address域的值匹配该正则表达式,则表示该address为欧洲格式的地址,否则认为是美国格式的地址

+ bbdb-case-fold-search

  当使用bbdb系列的搜索命令进行搜索时,是否大小写敏感

+ bbdb-auto-revert

  若在Emacs中没有修改bbdb buffer中的信息,而此时,bbdb-file发生了改变,则自动重新加载bbdb-file的新内容

+ bbdb-pop-up-layout

  pop-up BBDB buffer时使用的默认布局(mail,news...). 默认为'pop-up-multi-line

+ bbdb-pop-up-window-size

  pop-up BBDB buffer时的高度.

  若为整数N,则表示高度为N行

  若为一个介于0到1之间的小数N,则拆分拥有最高高度的window,并且BBDB buffer占据N倍的高度

  若为t,则表示使用 `display-buffer'/`pop-to-buffer' 创建BBDB window??(貌似会占据next-window来显示BBDB buffer)

+ bbdb-completion-list

  控制`bbdb-complete-mail'的补全方式. 该函数用于在mail buffer中补全联系人信息

  该值可以为一个symbol list,用来指明补全哪些域的值. 这些symbol可以是:

  - fl-name :: first and last name

  - lf-name :: last and first name

  - organization ::

  - aka ::

  - mail :: all email address of each record

  - primary :: first email address of each record

  该值也可以为t,表示所有上面symbol的集合

  若该值为nil,则表示不提供补全

+ bbdb-complete-mail-allow-cycling

  当调用`bbdb-complete-mail'补全email地址时,是否允许循环展示补全项

+ bbdb-user-mail-address

  该变量的值为一个正则表达式,该正则表达式用于标识某email地址是否是用户自己的email地址.

  多数BBDB的命令根据变量`bbdb-message-headers'从消息中抽取出发送方和接收方的email地址. 但若发送方的email地址匹配上了`bbdb-user-mail-address-re',则该email地址依然被认为是接收方的email地址.

  改变量的默认值为`(user-login-name)'

+ bbdb-add-mails

  该变量指明了当收到某个联系人从新的email地址发来的消息后,是否增加该新email到联系人信息中.

  可选值有:

  - t :: 自动添加该新的email地址

  - query :: 询问用户是否添加该新的email地址

  - nil :: 忽略新的email地址

  - 数字N :: 在N秒内,BBDB显示该新的email地址,但只在当前session有效

  - 函数fn :: 使用record和新email地址作为参数来调用fn,fn需要返回t,'query,nil或一个数字

  - 正则表达式re :: 若新的email地址符合该正则,则忽略该新的email地址,否则询问用户是否添加该email地址

+ bbdb-new-mails-primary

  为联系人新增email地址时,该新email地址是否作为primary mail address(即该新email地址排在其他email地址的前面).

  可选值为:

  - t :: 让该新增的email地址自动称为primary mail address

  - query :: 询问用户是否作为primary mail address

  - nil :: 不作为primary mail address,会将新email地址放到列表最后面.

  - 函数fn :: 该函数接收两个参数:record和新email地址. 该函数需要返回t,'query或nil

  - 正则表达式re :: 若新email地址匹配该re,则不作为primary mail address,否则询问用户是否作为primary mail address

+ bbdb-ignore-redundant-mails

  当增加新mail地址时,若联系人中的旧mail地址是新mail地址的更一般形式(例如,已有的mail地址为darksun@baz.com,而新mail地址为darksun@foo.baz.com)时,是否覆盖原mail地址.

  可选的值为为:

  - t :: 自动忽略新email地址

  - query :: 询问用户是否忽略新email地址

  - nil :: 使用新email地址,覆盖原email地址

  - 数字N :: 在接下来的N秒内,保留新email地址

  - 函数fn :: fn接收两个参数:record及新email地址,fn需要返回t,'query,nil或数字

  - 正则表达式re :: 符合该正则表达式的email地址会替代原email地址,否则询问用户是否忽略新email地址

+ bbdb-check-auto-save-file

  若值为t,则BBDB会检查它的auto-save file,若auto-save file比`bbdb-file'要新,则BBDB会恢复auto-save file

+ bbdb-ignore-message-alist

  描述哪些message不允许触发自动新建BBDB联系人记录.

+ bbdb-accept-message-alist

  描述哪些message允许触发自动新建BBDB联系人记录.

+ bbdb-mua-auto-update-p

  决定了`bbdb-mua-auto-update'如何自动更新BBDB记录. 可选值:

  - nil :: 什么也不做

  - search :: 搜索匹配ADDRESS的记录

  - update :: 搜索匹配ADDRESS的记录,如有必要,会更新name和mail域

  - query :: 搜索匹配ADDRESS的记录,若记录不存在,提示用户是否创建新记录

  - create :: 搜索匹配ADDRESS的记录,若记录不存在,则创建新记录

  - t :: 搜索匹配ADDRESS的记录,若记录不存在,则创建新记录

  - 函数fn :: bbdb调用该函数,该函数需要返回nil,search,update,query,create或t

******* hooks

| hook                             | 调用hook的时机                                     | 调用hook时的参数                       | 其他说明                                                          |
|----------------------------------+----------------------------------------------------+----------------------------------------+-------------------------------------------------------------------|
| bbdb-display-hook                | 展示*BBDB* buffer后                                |                                        |                                                                   |
| bbdb-create-hook                 | 在BBDB创建新联系人记录前                           | 新增的record                           | bbdb-change-hook也会被触发                                        |
| bbdb-change-hook                 | *BBDB* buffer发生改变前                            | 修改的record                           |                                                                   |
| bbdb-mode-hook                   | 进入bbdb mode后                                    |                                        |                                                                   |
| bbdb-notice-record-hook          | 当发现message中的email地址包含在某个联系人记录中后 | 包含message中email的联系人记录         | 若某message中包含同一联系人的多个email地址,该hook也只会被触发一次 |
| bbdb-notice-mail-hook            | 当发现message中的email地址包含在某个联系人记录中后 | 包含message中email的联系人记录         | 若某message中包含同一联系人的多个email地址,该hook也会被触发多次   |
| bbdb-after-read-db-hook          | 当`bbdb-file'被读取之后                            |                                        | 当BBDB buffer revert之后还会再次触发该hook                        |
| bbdb-initialize-hook             | BBDB的初始化函数`bbdb-initialize'被调用之后        |                                        |                                                                   |
| bbdb-canonicalize-mail-functioin | 当BBDB notice a message后                          | message中的corresponding email address | 该函数用于对message中的对应email地址作一次转换,转换后的结果才拿来与BBDB中的记录进行对比,或添加入BBDB. 若该函数返回nil,则BBDB认为该message中无email address |

****** 其他
******* 函数
******** (bbdb-display-records records )

在bbdb buffer中显示records中的记录

******** (bbdb-record-field RECORD FIELD)

返回记录中的指定域的值. 域的说明为:
| firstname    | Return the first name of RECORD                   |
| lastname     | Return the last name of RECORD                    |
| name         | Return the full name of RECORD (first name first) |
| name-lf      | Return the full name of RECORD (last name first)  |
| affix        | Return the list of affixes                        |
| organization | Return the list of organizations                  |
| aka          | Return the list of AKAs                           |
| aka-all      | Return the list of AKAs plus mail-akas.           |
| mail         | Return the list of email addresses                |
| mail-aka     | Return the list of name parts in mail addresses   |
| mail-canon   | Return the list of canonical mail addresses.      |
| phone        | Return the list of phone numbers                  |
| address      | Return the list of addresses                      |
| xfields      | Return the list of all xfields                    |
| 其他         | 指定label的xfields                                   |

******** (bbdb-get-records PROMPT)

若在*BBDB* buffer中,则返回光标所在的记录,若在其他buffer中,则询问用户想要返回哪个记录

******** (bbdb-update-records ADDRESS-LIST &optional UPDATE-P SORT)

返回匹配ADDRESS-LIST的BBDB记录列表

其中ADDRESS-LIST是一个由email地址组成的列表


参数UPDATE-P的可选值为:

+ nil :: 使用变量`bbdb/MUA-update-records-p'中的值, 若该值依然为nil,则`bbdb-update-records'返回nil

+ search :: 搜索匹配ADDRESS的记录

+ update :: 搜索匹配ADDRESS的记录,如有必要,会更新name和mail域

+ query :: 搜索匹配ADDRESS的记录,若记录不存在,提示用户是否创建新记录

+ create :: 搜索匹配ADDRESS的记录,若记录不存在,则创建新记录

+ t :: 搜索匹配ADDRESS的记录,若记录不存在,则创建新记录

+ 函数fn :: bbdb调用该函数,该函数需要返回search,update,query,create或t

若参数SORT为非nil,则返回的记录列表中的记录会经过`bbdb-record-lessp'排序;若SORT为nil,则记录的顺序与参数ADDRESS-LIST中的邮件地址的顺序对应.

******** (bbdb-get-mail-aliases)

返回BBDB中使用的mail aliases列表

******** (bbdb-search-read &optional FIELD)

提示用户输入一个正则表达式re,并从BBDB数据库中搜索出指定的FIELD符合该re的记录

******** (bbdb-search RECORDS &optional NAME-RE ORG-RE MAIL-RE XFIELD-RE PHONE-RE ADDRESS-RE)

从RECORDS中搜索出符合指定域的指定正则表达式的记录. 其中

+ NAME-RE匹配FIRST_LAST,LAST_FIRST和AKA域

+ XFIELD-RE匹配xfiled notes域

+ XFIELD-RE也以格式为(LABEL . RE)表示label为xfield的正则表达式,其中若LABEL为`*'则表示任一个xfield

******** (bbdb-display-records-with-layout RECORDS LAYOUT)

使用LAYOUT形式来展示RECORDS,其中LAYOUT参见`bbdb-layout-alist'中的值

******** (bbdb-pop-up-window &optional SELECT HORIZ-P)

******** (bbdb-display-records RECORDS &optional LAYOUT APPEND SELECT HORIZ-P)

使用LAYOUT形式来显示RECORDS

若参数APPEND为非nil,则会在当前已经显示的记录后,再多显示这些RECORDS;若APPEND为nil,则会用RECORDS的显示结果代替已有的显示结果

参数SELECT与参数HORIZ-P的意义参见`bbdb-pop-up-window'

******** (bbdb-display-record RECORD LAYOUT NUMBER)

在当前buffer的光标所在处,插入格式化好的RECORD表示文本.

LAYOUT是`bbdb-layout-alist'中描述的layout符号,若为nil则表示`bbdb-layout'

NUMBER is the number of RECORD among the displayed records.

******** (bbdb-read-record &optional FIRST-AND-LAST)

提示用户输入联系人信息,并创建一个新的BBDB联系人记录.

*但该函数不会将新产生的BBDB记录存入数据库,也不会更新BBDB hashtable*

*该函数会检查新输入的联系人是否和已存在的联系人记录相冲突*

******** (bbdb-read-string PROMPT &optional INIT COLLECTION REQUIRE-MATCH)

读取用户输入的字符串,会取出字符串中的空格和text properties

参数PROMPT为提示说明

参数INIT为预设值,当编辑已存在记录时常用到

参数COLLECTION与REQUIRE-MATCH的意义与`completing-read'中的意义一致

******** (bbdb-record-set-field RECORD FIELD VALUE &optional MERGE CHECK)

设置RECORD中的FIELD域的值为VALUE.

该函数的返回值为VALUE

若参数MERGE为非nil,则将参数VALUE合并到FIELD的当前值中

若参数CHECK为非nil,则会检查FIELD是否能够存储VALUE

*该函数会更新bbdb hashtable,但不会保存RECORD到bbdb数据库中*. 一般使用函数`bbdb-change-record'来保存RECORD到bbdb数据库中.

其中参数FIELD的说明,参见`bbdb-record-field'中的FIELD说明

******** (bbdb-change-record RECORD &optional NEED-TO-SORT NEW)

该函数保存RECORD到BBDB数据库中,若参数RECORD中的值与BBDB数据库中的值相比发生了变化,则该函数返回RECORD,否则该函数返回nil

当RECORD中的联系人名称发生改变,或RECORD为新建的联系人记录时,NEED-TO-SORT参数需要为t

当RECORD为新建的联系人记录时,参数NEW需要为t. 若RECORD为新建联系人记录则该RECORD会自动更新入BBDB hashtable,否则需要手工更新BBDB hashtable

******** (bbdb-current-record &optional FULL)

返回光标所处的RECORD

若参数FULL为非nil,则返回包含RECORD和显示格式(layout)的一个list
#+BEGIN_SRC emacs-lisp
  (bbdb-current-record t)
  ;; ([nil "darksun" nil nil nil (["home" "(+86)15820984397"] ["work" "(0794)6593346"]) nil nil ((creation-date . "2015-03-30 09:46:57 +0000") (timestamp . "2015-03-30 13:17:00 +0000")) ["darksun" "darksun" nil nil "darksun" #<marker at 64 in bbdb>]] multi-line #<marker at 1 in *BBDB*>)
  (bbdb-current-record)
  ;; [nil "darksun" nil nil nil (["home" "(+86)15820984397"] ["work" "(0794)6593346"]) nil nil ((creation-date . "2015-03-30 09:46:57 +0000") (timestamp . "2015-03-30 13:17:00 +0000")) ["darksun" "darksun" nil nil "darksun" #<marker at 64 in bbdb>]]

#+END_SRC

******** (bbdb-current-field)

返回光标所处的当前域
#+BEGIN_SRC emacs-lisp
  (bbdb-current-field)
  ;; (name "darksun")
#+END_SRC

******** bbdb-record-set-xxx系列函数

置record中指定field的值

******* 变量
******** bbdb-records

该变量的值为当前bbdb buffer中的record列表

******** bbdb-search-invert

若值为t,则会反转`bbdb-search'的搜索结果
****** FAQ

******* 如何修改BBDB创建联系人的流程

使用`bbdb-create'新建联系人时,会以此提示你输入一系列的联系人的信息,包括姓名,所属机构,电子邮件,地址,电话,备注. 但若想让BBDB在创建联系人时也提示你输入其他额外的信息该如何作呢?

下面是一个例子,它让`bbdb-create'新建联系人时,还会提示你输入生日信息:
#+BEGIN_SRC emacs-lisp
  (defun bbdb-read-record-advise-function(record)
    "提示存储生日,QQ,微信号"
    (bbdb-record-set-field record 'birthdate
                           (bbdb-read-string "Birthdate (YYYY.MM.DD): "))
    (bbdb-record-set-field record 'QQ
                           (bbdb-read-string "QQ:"))
    (bbdb-record-set-field record 'WeChat
                           (bbdb-read-string "WeChat:"))
    record)

  (advice-add 'bbdb-read-record :filter-return #'bbdb-read-record-advise-function)

#+END_SRC

******* 如何将bbdb中保存的联系人信息导入到手机中

最简单的方法,就是使用"bbdb-to-outlook.el"将bbdb导出为.csv文件. 然后在手机上导入该.csv文件

1. 加载"bbdb-to-outlook.el"
2. 使用`bbdb'显示bbdb联系人信息
3. 键入`O'会运行`bbdb-to-outlook'命令,输入保存的csv文件路径即可.

**** ROS
- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html

**** org-preview-latex-fragment 与 minted 宏包冲突

- http://orgmode.org/worg/org-tutorials/org-latex-preview.html
- http://tex.stackexchange.com/questions/162767/can-not-preview-latex-equation-in-org-mode-dvipng-and-imagemagick-both-failed

#+BEGIN_QUOTE
But if you have set up preview to use the dvipng method, you are in
trouble: that method calls latex directly, the call is hardwired and
it does not use the -shell-escape option. LaTeX refuses to run the
external program that minted used, no DVI file is produced and dvipng
cannot produce a PNG file
#+END_QUOTE

上述问题并没有好的解决方法

*latex preview 要比 minted 使用的多，所以优先考虑前者*

dvipng 没有错误，但不会生成公式图片

imagemagick 产生错误信息，

#+BEGIN_EXAMPLE
(error "PDF file /tmp/orgtex31149_Wk.pdf wasn't produced")
#+END_EXAMPLE

查看 log =/tmp/orgtex12345abc.log=

#+BEGIN_EXAMPLE
l.4 \usepackage
               [utf8]{inputenc}
?
! Emergency stop.
 ...

l.4 \usepackage
               [utf8]{inputenc}
Pass the -shell-escape flag to LaTeX. Refer to the minted.sty documentation for
 more information.
#+END_EXAMPLE




解决方式： 注释掉 org 文件头部包含的 minted 宏包

#+BEGIN_EXAMPLE
#+LATEX_HEADER: \usepackage{minted}
#+END_EXAMPLE

Note:

1. org-toogle-latex-preview
   #+BEGIN_EXAMPLE
     `org-preview-latex-fragment' is an obsolete command (as of 24.4); use `org-toggle-latex-fragment' instead.
   #+END_EXAMPLE
2. imagemagick 产生 A4 的图片，太大了，没有 dvipng 方便

**** Using rosed to edit files in ROS

*Description:* This tutorial shows how to use [[/rosbash][rosed]] to
make editing easier.

***** Using rosed

=rosed= is part of the [[/rosbash][rosbash]] suite. It allows you to
directly edit a file within a package by using the package name rather
than having to type the entire path to the package.

Usage:

#+BEGIN_EXAMPLE
    $ rosed [package_name] [filename]
#+END_EXAMPLE

Example:

#+BEGIN_EXAMPLE
    $ rosed roscpp Logger.msg
#+END_EXAMPLE

This example demonstrates how you would edit the Logger.msg file within
the roscpp package.

If this example doesn't work is probably because you don't have the
=vim= editor installed. Please refer to
[[/ROS/Tutorials/UsingRosEd#Editor][Editor]] section. If you don't know
how to get out of vim, [[http://kb.iu.edu/data/afcz.html][click here]].

If the filename is not uniquely defined within the package, a menu will
prompt you to choose which of the possible files you want to edit.

***** Using rosed with tab completion

This way you can easily see and optionally edit all files from a package
without knowing its exact name.

Usage:

#+BEGIN_EXAMPLE
    $ rosed [package_name] <tab><tab>
#+END_EXAMPLE

Example:

#+BEGIN_EXAMPLE
    $ rosed roscpp <tab><tab>
#+END_EXAMPLE


#+BEGIN_EXAMPLE
  Empty.srv                   package.xml
  GetLoggers.srv              roscpp-msg-extras.cmake
  Logger.msg                  roscpp-msg-paths.cmake
  SetLoggerLevel.srv          roscpp.cmake
  genmsg_cpp.py               roscppConfig-version.cmake
  gensrv_cpp.py               roscppConfig.cmake
  msg_gen.py
#+END_EXAMPLE

***** Editor

The default editor for rosed is =vim=. The more beginner-friendly editor
=nano= is included with the default Ubuntu install. You can use it by
editing your ~/.bashrc file to include:

#+BEGIN_EXAMPLE
    export EDITOR='nano -w'
#+END_EXAMPLE

To set the default editor to =emacs= you can edit your ~/.bashrc file to
include:

#+BEGIN_EXAMPLE
    export EDITOR='emacs -nw'
#+END_EXAMPLE

/*NOTE:*/ /changes in .bashrc will only take effect for new terminals.
Terminals that are already open will not see the new environmental
variable./

Open a new terminal and see if =EDITOR= is defined:

#+BEGIN_EXAMPLE
    $ echo $EDITOR
#+END_EXAMPLE


#+BEGIN_EXAMPLE
    nano -w
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    emacs -nw
#+END_EXAMPLE

**** cdlatex-math-symbol

1. cdlatex-math-symbol
   #+BEGIN_EXAMPLE
     ` runs the command cdlatex-math-symbol, which is an interactive Lisp
     function in `cdlatex.el'.

     It is bound to `, <menu-bar> <Org> <LaTeX> <Insert math symbol>.

     (cdlatex-math-symbol)

     Read a char from keyboard and insert corresponding math char.
     The combinations are defined in `cdlatex-math-symbol-alist'.  If not in a LaTeX
     math environment, you also get a pair of dollars.
   #+END_EXAMPLE

2. cdlatex-math-symbol-alist

   #+BEGIN_EXAMPLE
     cdlatex-math-symbol-alist is a variable defined in `cdlatex.el'.
     Its value is nil

     Documentation:
     Key characters and math symbols for fast access with the prefix key.
     First element is a character, followed by a number of strings attached to
     this key.  When the string contains a question mark, this is where the
     cursor will be positioned after insertion of the string into the buffer.
     See `cdlatex-math-symbol-alist-default' for an example.  Any entry defined
     here will replace the corresponding entry of the default list.  The
     defaults implement 3 levels of symbols so far: Level 1 for greek letters
     and standard symbols, level 2 for variations of level 1, and level 3 for
     functions and opperators.
   #+END_EXAMPLE

3. cdlatex-math-symbol-alist-default

   #+BEGIN_EXAMPLE
     Default for cdlatex-math-symbol-alist.

     Value: ((97
       ("\\alpha"))
      (65
       ("\\forall" "\\aleph"))
      (98
       ("\\beta"))
      (66
       (""))
      (99
       ("" "" "\\cos"))
      (67
       ("" "" "\\arccos"))
      (100
       ("\\delta" "\\partial"))
      (68
       ("\\Delta" "\\nabla"))
      (101
       ("\\epsilon" "\\varepsilon" "\\exp"))
      (69
       ("\\exists" "" "\\ln"))
      (102
       ("\\phi" "\\varphi"))
      (70
       (""))
      (103
       ("\\gamma" "" "\\lg"))
      (71
       ("\\Gamma" "" "10^{?}"))
      (104
       ("\\eta" "\\hbar"))
      (72
       (""))
      (105
       ("\\in" "\\imath"))
      (73
       ("" "\\Im"))
      (106
       ("" "\\jmath"))
      (74
       (""))
      (107
       ("\\kappa"))
      (75
       (""))
      (108
       ("\\lambda" "\\ell" "\\log"))
      (76
       ("\\Lambda"))
      (109
       ("\\mu"))
      (77
       (""))
      (110
       ("\\nu" "" "\\ln"))
      (78
       ("\\nabla" "" "\\exp"))
      (111
       ("\\omega"))
      (79
       ("\\Omega" "\\mho"))
      (112
       ("\\pi" "\\varpi"))
      (80
       ("\\Pi"))
      (113
       ("\\theta" "\\vartheta"))
      (81
       ("\\Theta"))
      (114
       ("\\rho" "\\varrho"))
      (82
       ("" "\\Re"))
      (115
       ("\\sigma" "\\varsigma" "\\sin"))
      (83
       ("\\Sigma" "" "\\arcsin"))
      (116
       ("\\tau" "" "\\tan"))
      (84
       ("" "" "\\arctan"))
      (117
       ("\\upsilon"))
      (85
       ("\\Upsilon"))
      (118
       ("\\vee"))
      (86
       ("\\Phi"))
      (119
       ("\\xi"))
      (87
       ("\\Xi"))
      (120
       ("\\chi"))
      (88
       (""))
      (121
       ("\\psi"))
      (89
       ("\\Psi"))
      (122
       ("\\zeta"))
      (90
       (""))
      (32
       (""))
      (48
       ("\\emptyset"))
      (49
       (""))
      (50
       (""))
      (51
       (""))
      (52
       (""))
      (53
       (""))
      (54
       (""))
      (55
       (""))
      (56
       ("\\infty"))
      (57
       (""))
      (33
       ("\\neg"))
      (64
       (""))
      (35
       (""))
      (36
       (""))
      (37
       (""))
      (94
       ("\\uparrow"))
      (38
       ("\\wedge"))
      (63
       (""))
      (126
       ("\\approx" "\\simeq"))
      (95
       ("\\downarrow"))
      (43
       ("\\cup"))
      (45
       ("\\leftrightarrow" "\\longleftrightarrow"))
      (42
       ("\\times"))
      (47
       ("\\not"))
      (124
       ("\\mapsto" "\\longmapsto"))
      (92
       ("\\setminus"))
      (34
       (""))
      (61
       ("\\Leftrightarrow" "\\Longleftrightarrow"))
      (40
       ("\\langle"))
      (41
       ("\\rangle"))
      (91
       ("\\Leftarrow" "\\Longleftarrow"))
      (93
       ("\\Rightarrow" "\\Longrightarrow"))
      (123
       ("\\subset"))
      (125
       ("\\supset"))
      (60
       ("\\leftarrow" "\\longleftarrow" "\\min"))
      (62
       ("\\rightarrow" "\\longrightarrow" "\\max"))
      (96
       (""))
      (39
       ("\\prime"))
      (46
       ("\\cdot")))
   #+END_EXAMPLE

4. 层次

   + 这个很好用啊

   + 在默认值的基础上修改
     #+BEGIN_EXAMPLE
     (65 ("\\forall" "\\aleph"))
     #+END_EXAMPLE

   + 层次问题
     - 第一层： 希腊字母和标准符号
     - 第二层： 第一层的变种
     - 第三层： 数学函数与操作
     - 第四层： =自定义= (太深了，还是第一层)

*** 2016/01/02
**** Emacs VCF 手机备份文件
**** 整理 Chrome 收藏夹
:LOGBOOK:
CLOCK: [2016-01-02 六 10:53]--[2016-01-02 六 13:05] =>  2:12
:END:

1. 使用 Chrome 书签保存常用网页
2. 书签栏上仅显示常用网址，即每天都需要打开的网页，以及 INBOX 和 INDEX
   两个文件夹
3. INBOX 用于保存有待处理的网页
4. INDEX 用于分类收藏网址
   - ROS： ROS 相关常用网址
   - Google: Google相关网址
   - Cloud： 云存储网址
   - BUAA：校园相关
   - Community: 社区
   - Forum: 论坛
   - Guide：教程
   - Blog：博客
   - Manual：手册
   - Homepage: 项目主页
   - Resource: 资源
   - Github： Github 上的资源
   - Course: 课程
   - Project: 课题相关

**** Can we make a love heart with LaTeX

+
  http://tex.stackexchange.com/questions/139733/can-we-make-a-love-heart-with-latex

[[/home/ben/Wally/Journal//Figure/scrot/2959ite.png]]

**** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html

**** 像ROS，图片链接不是完整路径，可以改
**** VirtualBox USB 支持

- [[http://www.cnblogs.com/ericsun/archive/2013/06/10/3130679.html][在Ubuntu12.04 上为Virtualbox 启用USB 设备支持]]


众所周知,VirtualBox使用宿主机的USB设备需要安装扩展包。根据自己的vbox的
版本，到vbox官网下载对应的扩展包。比如我的vbox 是4.1.12的，对应扩展包
地址是：[[http://download.virtualbox.org/virtualbox/4.1.12/Oracle_VM_VirtualBox_Extension_Pack-4.1.12-77245.vbox-extpack][http://download.virtualbox.org/virtualbox-extpack]]

下载完毕后，在“管理”菜单下的“全局设定”里的“扩展”标签下，加入、启
用即可。

如图：

[[http://static.xiazhengxin.name/img/install_vbox_ext_package.png]]

之后，打开虚拟系统设置，在“USB设备”标签下，勾选上"启用USB控制器"以及
"2.0控制器"增加对USB2.0的支持。

如图：
 [[http://static.xiazhengxin.name/img/enable_USB2_controller.png]]

按说这个时候已经搞定了。可是在USB列表里面却没有任何USB设备。这是为什么
呢？谷歌了一下，找到了一篇文章(具体地址已经无法回忆起来了，囧)，解释了
一下原因。

*原来是vbox 所在的用户组比如要包括当前用户才行。*

查看当前用户名：

#+BEGIN_EXAMPLE
sharl@sharl-laptop:~$ whoami
sharl
#+END_EXAMPLE


查看vbox 所在的组：

#+BEGIN_EXAMPLE
sharl@sharl-laptop:~$ cat /etc/group | grep vbox
vboxusers:x:125:sharl
#+END_EXAMPLE

将当前用户加入vbox组：

#+BEGIN_EXAMPLE
usermod -a -G vboxusers sharl
#+END_EXAMPLE

即可。

此时，重启系统。再次打开虚拟机，果然，USB设备都已经被识别、访问到了。
这些，在“设备”菜单下就可以看到。

如图：

[[http://static.xiazhengxin.name/img/add_USB_device_to_vbox_from_list.png]]

添加后，虚拟机系统果然发现了新硬件，按照一般步骤，安装驱动即可正常使用。

**** Running 64bit Matlab on 32bit host OS

-
  http://neuro.debian.net/blog/2013/2013-05-31_matlab_64bit_on_32bit.html


Note

- Debian 下32位系统使用64位 Matlab, Ubuntu 下不一定能用。
- 不要再 Linux 下折腾 Matlab
- 装系统要装64位的

Some of you have experienced problems due the recent move of Mathworks
to drop 32-bit Linux builds of their products (i.e. Matlab R2013a and
co.). Please note that this is not the first time Mathworks values its
own costs higher than the benefits of a few scientists. In 1998
PowerPC builds for Macs were abandoned, causing a furious reaction of
the community.

Luckily, users of the fresh Debian stable release wheezy (or more
recent variants of Debian and its derivatives) who still need a 32bit
OS on 64bit-capable hardware can take advantage of the new multiarch
support. Multiarch allows for multiple architecturesi to co-exist on a
hardware/kernel that is capable of supporting both (e.g. i386 and
amd64).

Below we describe how you can use multiarch support and in few simple
steps that prepare your existing 32bit user-land for running 64bit
Matlab.

Procedure
1. [2-10 min] Install 64-bit kernel and reboot:

   #+BEGIN_EXAMPLE
   sudo apt-get install linux-image-amd64
   #+END_EXAMPLE

2. [1-3 min] Enable multi-arch support for amd64 architecture:

   #+BEGIN_EXAMPLE
   sudo dpkg --add-architecture amd64
   sudo apt-get update
   #+END_EXAMPLE

3. [1-5 min] Install 64bit libraries (and compilers) needed for
   matlab:
   #+BEGIN_EXAMPLE
     sudo apt-get install libstdc++6:amd64 zlib1g:amd64 libncurses5:amd64 \
     libxp6:amd64 libstdc++6-4.4-dev:amd64 libxt6:amd64 libxmu6:amd64 libxtst6:amd64 \
     g++:amd64 gcc:amd64 binutils:amd64
   #+END_EXAMPLE

Now your 64bit matlab (which you hopefully “registered” with
matlab-support) is ready to run.

**** [[http://lanbing510.info/2014/12/03/Linux-Matlab.html][Linux下Matlab的安装及配置使用]]

1. 从[[http://pan.baidu.com/s/1o6qKdxo#path=%252Fmatlab][这里]]下载Matlab2014的Linux版本及破解文件。

2. 下载完成后将iso文件挂载到Linux进行安装。

   #+BEGIN_EXAMPLE
    sudo mkdir /media/matlab
    mount -o loop [path][filename].iso /media/matlab
    cd /media/matlab
    sudo ./install
   #+END_EXAMPLE

3. 安装过程中使用readme.txt中的序列号。

4. 破解

   1) 安装完成后使用crack下的 license进行激活；

   2) 将crack文件夹下的libmwservices.so copy到 /usr/local/MATLAB/R2014A/bin/glnxa64。

5. 完成安装，命令行下使用sudo matlab即可启动使用。

**** yasnippet elisp code

Emacs-Lisp code can be embedded inside the template, written inside back-quotes (`). The lisp forms are evaluated when the snippet is being expanded. The evaluation is done in the same buffer as the snippet being expanded.

Here's an example for c-mode` to calculate the header file guard
dynamically:

#+BEGIN_EXAMPLE
  #ifndef ${1:_`(upcase (file-name-nondirectory (file-name-sans-extension (buffer-file-name))))`_H_}
  #define $1

  $0

  #endif /* $1 */
#+END_EXAMPLE

**** date

(insert (format-time-string "%y-%m-%d-%H-%M"))16-01-02-16-10

**** TODO org-preview-latex-fragment

$\mathbf{x}=(x, y, \theta)$
