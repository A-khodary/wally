#+LATEX_HEADER: \usepackage[boxed, lined]{algorithm2e}
# #+LATEX_HEADER: \usepackage{minted}
# #+LATEX_HEADER: \usepackage{float}

# freemind
# .sdcv_history
# agenda
# obj


- [ ] Prime: PCL
- [ ] Project: IMU
- [ ] Progress: Deutsch
- [ ] Thesis: Outliers

* Objective
** month

+ [ ] 写完大论文初稿
+ [ ] 完成一篇小论文
+ [ ] IMUtoolbox / PythonSLAM / TimBailey

** week

+ [ ] EK-SLAM & Gazebo Sim & Thesis
+ [ ] PF

** 2016/01/11

+ [X] freemind
+ [X] wally & julie
+ [X] software
+ [X] ROS opencv

** 2016/01/01
+ [X] wally gazebo 仿真实现三维建模
+ [X] 小车测试 Hector SLAM
** 2016/01/02
+ [X] 理解 Hector SLAM 中 map/odom/base_footprint 的配置（仿真中即可）
+ [X] 绪论 SLAM 部分
** 2016/01/03
+ [X] gazebo worlds
+ [X] 使用小车采集数据实现三维建模（保存数据，不用实时）
+ [ ] 使用 Raspberry 采集数据
+ [X] 理解 Hector SLAM 的 base_stablized 坐标配置
** 2016/01/04
+ [X] 采集小车本身的数据
+ [X] IMU 积分算法
+ [X] 完成论文定位部分
** 2016/01/05

+ [X] laser_filter/laser_assembler/PLC
+ [ ] Samba 配置
+ [X] 推导 PF，莫放拦路虎
+ [X] 特征地图论文

** 2016/01/06
+ [X] PCL
+ [ ] SLAM 论文部分
** 2016/01/07
+ [X] 考虑电池和电路板
+ [X] PCD
+ [X] SLAM 论文部分
** 2016/01/08
+ [X] 考虑学报
+ [X] PF SLAM
+ [X] Gazebo sim
* Journal

** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

** 2016/01/22 summary
** catkin error

#+BEGIN_EXAMPLE
$ catkin_create_pkg pcltk pcl_convention pcl_ros roscpp sensor_msgs
ImportError: No module named 'catkin_pkg'
#+END_EXAMPLE

原因： 更新了 Python 的版本
解决： 将 /usr/bin/python 软链指向 python2.7 (即安装 ros 时的版本)

http://answers.ros.org/question/204024/no-module-named-catkin_pkgpackage-on-catkin_make-w-hydro/

** 笔记文本中的特殊条目使用尖括号括起                                :trick_:

like this

#+BEGIN_EXAMPLE
  - initialize the PRIME pcltk with <Reference> <Note> <TODOs> and <ChangeLogs>
#+END_EXAMPLE

** pdf-tools installation                                           :install:

通过 Emacs 编译

#+BEGIN_EXAMPLE
(pdf-tool-install)
#+END_EXAMPLE

问题： 包依赖解决不了，有未发现的包
解决： 修改了 python 的软链至2.7

安装其他东西时也会出现这种问题，不知为何 “dpkg 的依赖会与 python 版本
相关”

** LVDS                                                               :lvds:
*** reference

- [[http://baike.baidu.com/link?url=7BVzHvPMvlyCuLejyh7jlEETSqpq5XaLJBMeVHm3y3KJLh1glCgN_C6yh5k5ZfsqbV4_LGc-khKBCYBLxxKhs_][百度百科]]
- [[http://ieeexplore.ieee.org/xpl/login.jsp?reload=true&tp=&arnumber=503756&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D503756][IEEE 标准]]

*** Lvds :: Low-Voltage Differential Signaling  低电压差分信号

LVDS接口是 *LCD Panel* 通用的接口标准，大多用在7寸以上尺寸的显示屏上。

1994年由美国国家半导体公司提出的一种 *信号传输模式* ，是一种 *电平标
准*  ，LVDS接口又称 *RS-644总线接口* ，是20世纪90年代才出现的一种数据
传输和接口技术。

LVDS即低电压差分信号，这种技术的核心是采用极低的电压摆幅高速差动传输数
据，可以实现点对点或一点对多点的连接，具有低功耗、低误码率、低串扰和低
辐射等特点，其传输介质可以是铜质的PCB连线，也可以是平衡电缆。LVDS在对
信号完整性、低抖动及共模特性要求较高的系统中得到了越来越广泛的应用。


LVDS可采 用CMOS、GaAs或其他技术实现，其供电电压可以从+5V到+3.3V，甚至
更低；其传输介质可以是PCB连线，也可以是特制的电缆。标准推荐的最高数据
传输速率是 *655Mbps* ，而理论上，在一个无衰耗的传输线上，LVDS的最高传
输速率可达 *1.923Gbps*




#+DOWNLOADED: http://h.hiphotos.baidu.com/baike/c0%3Dbaike180%2C5%2C5%2C180%2C60/sign=ae3fe7ee80025aafc73f76999a84c001/b21c8701a18b87d658530a31050828381f30fd8f.jpg @ 2016-01-22 17:18:24
 [[~/Wally/Journal/Figure/.org-download/Journal/b21c8701a18b87d658530a31050828381f30fd8f_2016-01-22_17:18:22.jpg]]

*** advantages

它在提供高数据传输率的同时会有很低的功耗，另外它还有许多其他的优势：

1、低至2V的电源电压兼容性
2、低噪声
3、高噪声抑制能力
4、可靠的信号传输
5、能够集成到系统级IC内
6、使用LVDS技术的的产品数据速率可以从几百Mbps到2Gbps。
7、它是电流驱动的，通过在接收端放置一个负载而得到电压，当电流正向流动，接收端输出为1，反之为0。
8、它的摆幅为250mv-450mv。
9、此技术基于ANSI/TIA/EIA-644LVDS接口标准。

*** LDVS vs HDMI                                                     :hdmi:

- http://www.dxdlw.com/ShowPost.asp?ThreadID=32129
- [[http://zhidao.baidu.com/link?url=ySZsKDG86GR8sONJOFXdH3UkWrHfYOz55TvqjnQmcOwooJlcEeianKLdXYnyWhC9t8SvgojaANRK9X4wrwLO7a][百度知道]]


简单的说HDMI外部设备的连接,LVDS 是用在显示器内部连接.

HDMI (High-Definition Multimedia Interface)，即高清晰度多媒体接口,HDMI
Cable就是連接Maind board HDMI 與外接高清晰度多媒体的線材，而LVDS cable
只是鏈接Maind board 與LCD之間的Cable


HDMI与LVD是两种不同的产品，根本就没有什么相同的地方。


在DisplayPort之前，数字多媒体接口标准经历了多次纷争，逐渐形成了外部连
接(*Box-to-Box*)与内部连接(*Chip-to-Chip*)两块相互独立的阵地。在外部连接方
面，PC已有DVI；而CE方面也有方兴未艾的HDMI；至于内部连接则是约定俗成的
标准——LVDS。


LVDS是低压差分信号，是一种信号传输技术，由美国国家半导体发起的一种信号
传输方式标准。

HDMI是一种接口传输标准，HDMI里面有4对LVDS线，分别传送R、G、B&CLK信号，

DP也是一样，只是HDMI和DP的电平不一样而已。

如果要做DP和HDMI的转换只要做一个电平转换电路只可，RGB&CLK单向，DDC要双
向。当然速率要够高！


目前为止，所有带有HDMI接口的显示器，都是将HDMI信号转换成LVDS给显示屏的。


HDMI： High Definition Multimedia Interface， 这是一种接口技术，主要就
是为了解决接口兼容性的问题；

LVDS： Low-Voltage Differential Signaling 低压差分信号，它虽然也是一种
接口，但更多指的是电气特性方面，解决的也主要是高速传输中出现的问题（噪
音、可靠性、传输速率、时延等）。

两者属于不同层面上的应用。HDMI中包含LVDS总线。

*** 接口定义

20 pin

** OEM                                                                 :oem:

- [[http://baike.baidu.com/link?url=2x-R9VFDZry92QIJt8tJf_8MHWEPCPJoSr896CF-wOjrT4iqAnMZLDMS_7BZcL8SpFknWXC0mG1tXU7Ald5Kzm2SZgwiS8YmuEz-ECQa1IX4fNEUy87w2mluErPkO8ob][百度百科]]

OEM生产，也称为定点生产，俗称代工（生产），基本含义为品牌生产者不直接
生产产品，而是利用自己掌握的关键的核心技术负责设计和开发新产品，控制销
售渠道，具体的加工任务通过合同订购的方式委托同类产品的其他厂家生产。

「原厂委托制造」OEM（Original Equipment Manufacturer）是受托厂商按来样
厂商之需求与授权，按照厂家特定的条件而生产。所有的设计图等都完全依照来
样厂商的设计来进行制造加工。

** Evernote 笔记清空

不要统一使用 Evernote 收藏所有笔记。

人是统一的，工具是分布的。

*** 分类
** 一个

我知道在我将命运的改变希冀在幸运上的时候，我就是一个失败者。 by 乔诗伟
*** 文字

- [[http://wufazhuce.com/one/vol.713?from=timeline&isappinstalled=1][VOL.713]]

  有些人恐惧父母离去，或者江郎才尽还有衰老。我比较恐惧的是怕以后会埋怨
  自己，就是在力所能及时没有努力做一件事，当没有机会再去做时，会责备年
  轻的自己。 by 李娜

- [[http://m.wufazhuce.com/one/2012-10-23][VOL.16]]

  爱是看到你就开心，跟你睡在一起就满足。by 小饭

- [[http://m.wufazhuce.com/one/2012-10-24][VOL.17]]

  不主动的人是好人的概率大于坏人。by 何禾

- [[http://m.wufazhuce.com/one/2012-11-23][VOL.47]]

 世界上最强有力的人就是那最孤立的人。by 胡适

- [[http://m.wufazhuce.com/one/2013-02-02][VOL.118]]

  没有以前的过去，就不会成就现在的自己。by 萧敬腾

- [[http://m.wufazhuce.com/one/2013-02-21][VOL.137]]

  人生唯一可以肯定的失败和最大的悲哀，莫过于从不敢冒险。by 肯恩·格林伍德

- [[http://m.wufazhuce.com/one/2013-03-01][VOL.145]]

  生活总在不经意的时候泼你满头满脸的狗血，没关系，我还是会回你一个血色狰狞的笑。by Double青

- [[http://m.wufazhuce.com/one/2013-03-18][VOL.162]]

  孤独有时是最好的交际。by 约翰·弥尔顿

- [[http://m.wufazhuce.com/one/2013-03-21][VOL.165]]

  孤独是我们自找的，因为我们太珍惜自我。by 宗萨蒋扬钦哲

- [[http://m.wufazhuce.com/one/2013-04-04][VOL.179]]

  不乱于心，不困于情，不畏将来，不念过往，如此，安好。by 丰子恺

- VO[[http://m.wufazhuce.com/one/2013-04-05][L.180]]

  你知道，有些鸟儿是注定不会被关在牢笼里的，它们的每一片羽毛都闪耀着自由的光辉。from《肖申克的救赎》

- [[http://m.wufazhuce.com/one/2013-04-11][VOL.186]]

  一个人拥有此生此世是不够的，他还应该拥有诗意的世界。by 王小波

- [[http://m.wufazhuce.com/one/2013-04-21][VOL.196]]

  梦里出现的人，醒来时就该去见他，生活就是那么简单。 from 《新桥恋人》

- [[http://m.wufazhuce.com/one/2013-04-23][VOL.198]]

  爱情就像一条河，谁不是摸着石头过河呢。from《致我们终将逝去的青春》

- [[http://m.wufazhuce.com/one/2013-04-24][VOL.199]]

  每一个不曾起舞的日子，都是对生命的辜负。by 尼采

- [[http://m.wufazhuce.com/one/2013-04-30][VOL.205]]

  逻辑会把你从A带到B，想象力能带你去任何地方。by 爱因斯坦

- [[http://m.wufazhuce.com/one/2013-05-04][VOL.209]]

  我们一路奋战，不是为了改变世界，而是不让世界改变我们。from 《熔炉》

- [[http://m.wufazhuce.com/one/2013-05-23][VOL.228]]

  不能忍受无聊的一代人，将是平庸的一代人。by 罗素

- [[http://m.wufazhuce.com/one/2013-05-27][VOL.232]]

  人一切的痛苦，本质上都是对自己的无能的愤怒。by 王小波

- [[http://m.wufazhuce.com/one/2013-06-05][VOL.241]]

  我们都生活在阴沟里，但仍有人仰望星空。by 王尔德

- [[http://m.wufazhuce.com/one/2013-06-06][VOL.242]]

  我在人生道路上迷失了方向。from《火影忍者》

- [[http://m.wufazhuce.com/one/2013-06-13][VOL.249]]

  人的自由并不仅仅在于做他愿意做的事，而在于永远不做他不愿意做的事。by
  卢梭

- [[http://m.wufazhuce.com/one/2014-12-19][VOL.803]]

  爱任何事物的方法，就是要意识到你可能会失去它。by G.K.切斯特顿

- [[http://m.wufazhuce.com/one/2014-12-22][VOL.806]]

  我避开无事时过分热络的友谊，这使我少些负担和承诺。我不多说无谓的闲言，
  这使我觉得清畅。我尽可能不去缅怀往事，因为来时的路不可能回头。我当心
  地去爱别人，因为比较不会泛滥。我爱哭的时候便哭，想笑的时候便笑，只要
  这一切出于自然。 from 《送你一匹马

- [[http://m.wufazhuce.com/one/2014-12-25][VOL.809]]

  人世就是这样，会静静地突然想到忽略了极熟的东西。我有个朋友一天忽然说，
  好久没有吃醋了，当即到小铺里买了一瓶山西老陈醋，坐在街边喝，喝得眼泪
  流出来。by 阿城

- [[http://m.wufazhuce.com/one/2014-12-26][VOL.810]]

  人不曾老去，直到悔恨取代了梦想。by 约翰·巴里摩

- [[http://m.wufazhuce.com/one/2014-12-27][VOL.811]]

  我曾赤诚天真地爱过你，除了伤心难过，一无所得。若干年后我想起，能够说
  出“我曾赤诚天真地爱过一个人”，这是一生之中，我最为安慰的事情。 by
  葛婉仪

- [[http://m.wufazhuce.com/one/2014-12-28][VOL.812]]

  不在任何东西面前失去自我，哪怕是教条，哪怕是别人的目光，哪怕是爱情。
  from《成为简·奥斯汀》

- [[http://m.wufazhuce.com/one/2014-12-29][VOL.813]]

  没有什么比时间更具有说服力了，因为时间无需通知我们就可以改变一切。
  from 余华《活着》

- [[http://m.wufazhuce.com/one/2015-01-04][VOL.819]]

  这城市真他妈痛苦，但她越痛苦我就越爱她。活着，是主旋律，我们像一粒石
  子，打磨着这个世界，也被这个世界打磨。认真活着，吃饭，喝茶，做爱，做
  爱做的事，永远选择难走的路。by Aly Song

- [[http://m.wufazhuce.com/one/2015-01-06][VOL.821]]

  所有你乐于挥霍的时间都不能算作是浪费。by 约翰·列侬

- [[http://m.wufazhuce.com/one/2015-01-07][VOL.822]]

  当时间到来，我们不得不挥手告别熟悉的世界，告别我们深知的一切，告别认
  为会永不抛弃我们的人，当这些改变最终发生的时候，当熟悉远离而陌生来临
  的时候，我们所能做到的，就是说声“你好，欢迎”。from 《绝望的主妇》

- [[http://m.wufazhuce.com/one/2015-01-12][VOL.827]]

  你在乎谁，你说了算。谁在乎你，你说了不算，时间说了算。by 郑执

- [[http://m.wufazhuce.com/one/2015-01-13][VOL.828]]

  需要很多力量，很多傲气，或者很多爱，才能相信人的行动是有价值的，相信
  生命胜过死亡。by 西蒙娜·德·波伏娃

- [[http://m.wufazhuce.com/one/2015-01-14][VOL.829]]

  等你发现时间是贼了，它早已偷光你的选择。by 李宗盛

- [[http://m.wufazhuce.com/one/2015-01-15][VOL.830]]

  每个人都有自己的世界，这个世界不是你想进就能进来的。进不来的就别硬闯
  了，还不如客客气气的当个客人，敲门敲不开就算了，可能别处更适合你。by
  痞人日记

- VO[[http://m.wufazhuce.com/one/2015-01-18][L.833]]

  有一个可以想念的人，就是幸福。from 《情书》

- [[http://m.wufazhuce.com/one/2015-01-22][VOL.837]]

  不管全世界所有人怎么说，我都认为自己的感受才是正确的。无论别人怎么看，
  我绝不打乱自己的节奏。喜欢的事自然可以坚持，不喜欢怎么也长久不了。by
  村上春树

- [[http://m.wufazhuce.com/one/2015-01-25][VOL.840]]

  要想面对一个新的开始，一个人必须有梦想、有希望、有对未来的憧憬。如果
  没有这些，就不叫新的开始，而叫逃亡。from 玛丽亚·杜埃尼亚斯《时间的针
  脚》

- [[http://m.wufazhuce.com/one/2015-01-28][VOL.843]]

  我爱你，不光因为你的样子，还因为，和你在一起时，我的样子。 by 罗伊·
  克利夫特

- [[http://m.wufazhuce.com/one/2015-02-05][VOL.851]]

  你最愿意做的那件事，才是你真正的天赋所在。by 摩西奶奶

- [[http://m.wufazhuce.com/one/2015-02-06][VOL.852]]

  每个人的心里，有多么长的一个清单，这些清单里写着多少美好的事，可是，
  它们总是被推迟，被搁置，在时间的阁楼上腐烂。为什么勇气的问题总是被误
  以为是时间的问题，而那些沉重、抑郁的、不得已的，总是被叫做生活本身。
  from《被搁置的生活》

- [[http://m.wufazhuce.com/one/2015-02-08][VOL.854]]

  我只是你生活里的一个影子，你却在我的生命里占有重要地位。如果我只是个
  单纯的过客，为何要让我闯入你的生活？我千百次想过要离开你，但仅凭一己
  之力我做不到。from《偷影子的人》

- [[http://m.wufazhuce.com/one/2015-02-10][VOL.856]]

  那些可以轻而易举伤害我们的人，那些一再以痛楚和挫败试探我们的人，那些
  举起旗子引导我们走入迷途深林的人，那些在削弱我们的力量的人，那些让我
  们深深触动和粉碎自我的人，他们才是生命中最有力量的老师。by 安妮宝贝

- VO[[http://m.wufazhuce.com/one/2015-02-11][L.857]]

  有时候，你对人生所有的规划，抵不过命运一次不怀好意的安排。by 扶南

- [[http://m.wufazhuce.com/one/2015-02-12][VOL.858]]

  那些固然很好，可我不想要，你不必劝；这些我不喜欢，但你心仪，我绝不出
  言扫兴。 by 八月长安

- [[http://m.wufazhuce.com/one/2015-02-13][VOL.859]]

  正如故乡是用来怀念的，青春是用来追忆的，当你怀揣着它时，它一文不值，
  只有将它耗尽后再回过头看，一切才有意义，爱过我们的人和伤害过我们的人，
  都是我们青春存在的意义。from 《致我们终将逝去的青春》

- [[http://m.wufazhuce.com/one/2015-02-16][VOL.862]]

  切记不要与自身的平凡为敌，也没有必要把自己变得不像自己。by 许钧

- [[http://m.wufazhuce.com/one/2015-02-18][VOL.864]]

  在我生命中曾有过那么一个时刻，那时我多年轻啊，早上睁开眼睛，会想，这
  是一个开始，未来的一切都会更好，这是所有幸福的开始。现在我才明白，其
  实那就是幸福了。from 《时时刻刻》

- [[http://m.wufazhuce.com/one/2015-02-25][VOL.871]]

  以前总是担心自己长大后会怎么样。赚多少钱。会不会有一天出人头地。有时
  候你最是盼星星盼月亮的事儿就是不会发生，可意想不到的那些却自然而然地
  来了。我说不清楚为什么，你遇见过千百个人，而他们只不过是匆匆过客。接
  着你就邂逅了那么一个人，改变了你的生命直到永远。from《爱情与灵药》

- [[http://m.wufazhuce.com/one/2015-03-02][VOL.876]]

  答案在最需要的时候总是不肯出现，而很多时候唯一可能的答案却是，你必须
  耐心等待。by 若泽·萨拉马戈

- [[http://m.wufazhuce.com/one/2015-03-03][VOL.877]]

  如今我终于明白，会说话并不是件必须的事情。生活之海，长风击浪固然风流，
  在水下深潜也是件美妙的事情。一直很怀念自己口不能言一个人沉在水底的青
  春岁月，后悔太早挣扎着想浮上来。from《坦白书》

- [[http://m.wufazhuce.com/one/2015-03-06][VOL.880]]

  完美和不完美都是我，对自己，我总是说Yes。by 凯特·布兰切特

- [[http://m.wufazhuce.com/one/2015-03-09][VOL.883]]

  我愿意深深地扎入生活，吮尽生活的骨髓，过得扎实，简单，把一切不属于生
  活的内容剔除得干净利落，把生活逼到绝处，简单最基本的形式，简单，简单，
  再简单。 from《瓦尔登湖》

- [[http://m.wufazhuce.com/one/2015-03-14][VOL.888]]

  让我们决定彼此靠近的，是表面的阳光；但让我们决定彼此亲近的，却是内心
  的脆弱。 by 里则林

- [[http://m.wufazhuce.com/one/2015-03-16][VOL.890]]

  有些人快乐地施与，这快乐就是他们的回报。有些人痛苦地施与，这痛苦就是
  他们的洗礼。 from 纪伯伦《先知》

- [[http://m.wufazhuce.com/one/2015-03-17][VOL.891]]

  在隆冬，我终于知道，我身上有一个不可战胜的夏天。 by 加缪

- [[http://m.wufazhuce.com/one/2015-03-18][VOL.892]]

  有人说：真正的爱情，背后没有秘密。说这话的人，既不明白爱情，也不明白
  秘密。from《北京乐与路》

- [[http://m.wufazhuce.com/one/2015-03-23][VOL.897]]

  如果一艘船不知道该驶去哪个港口，那么任何方向吹来的风都不会是顺风。
  from 《塔木德》

- [[http://m.wufazhuce.com/one/2015-03-24][VOL.898]]

  除掉睡眠，人的一辈子只有一万多天。人与人的不同在于：你是真的活了一万
  多天，还是仅仅生活了一天，却重复了一万多次。 by 费尔南多·佩索阿

- [[http://m.wufazhuce.com/one/2015-03-25][VOL.899]]

  读一些无用的书，做一些无用的事，花一些无用的时间，都是为了在一切已知
  之外，保留一个超越自己的机会，人生中一些很了不起的变化，就是来自这种
  时刻。by 梁文道

- [[http://m.wufazhuce.com/one/2015-03-27][VOL.901]]

  任何不能杀了我的，只会令我更强。by 尼采

- [[http://m.wufazhuce.com/one/2015-03-28][VOL.902]]

  我要在你身上做，春天对樱桃树做的事。by 聂鲁达

- [[http://m.wufazhuce.com/one/2015-04-03][VOL.908]]

  我们称之为路的，其实不过是彷徨。by 卡夫卡

- [[http://m.wufazhuce.com/one/2015-04-04][VOL.909]]

  你若咬定了人只活一次，便更没有随波逐流的理由。By 帕蒂·史密斯

- [[http://m.wufazhuce.com/one/2015-04-07][VOL.912]]

  一个人对幸福的全部的感受，就蕴藏在一个吻和一次散步，就在对晚餐和读一
  本书的期待之中。 by 迈克尔·坎宁安

- [[http://m.wufazhuce.com/one/2015-04-11][VOL.916]]

  一个人至少拥有一个梦想，有一个理由去坚强。心若没有栖息的地方，到哪里
  都是在流浪。 by三毛

- [[http://m.wufazhuce.com/one/2015-04-12][VOL.917]]

  痛苦这东西，天生应该用来藏在心底，悲伤天生是要被努力节制的，受到的伤
  害和欺骗总得去原谅，满不在乎的人不是无情的人。最安静与最孤独的成长，
  也是能使人踏实、自信、强大、善良的，大不了，吐吐舌头而已。from 李娟
  《我的阿勒泰》

- [[http://m.wufazhuce.com/one/2015-04-13][VOL.918]]

  所谓幸福，是在于认识一个人的界限而爱这个界限。 from 《约翰·克里斯朵
  夫》

- [[http://m.wufazhuce.com/one/2015-04-20][VOL.925]]

  诚实的生活方式，其实是按照自己身体的意愿行事，饿的时候才吃饭，爱的时
  候不必撒谎。from《霍乱时期的爱情》

- [[http://m.wufazhuce.com/one/2015-04-22][VOL.927]]

  现在过的每一天，都是余生中最年轻的一天。 by 佚名

- [[http://m.wufazhuce.com/one/2015-04-26][VOL.931]]

  上学后，人们问我长大了要做什么，我写下“快乐”。他们告诉我，我理解错
  了题目，我告诉他们，他们理解错了人生。 by 约翰·列侬

- [[http://m.wufazhuce.com/one/2015-04-29][VOL.934]]

  人就是这样，一旦有了信仰，他就有决心与毅力去浪费时光。from《推拿》

- [[http://m.wufazhuce.com/one/2015-04-30][VOL.935]]

  命运是任何人也无法改变的，但他可以决定是等死还是面对。 from 《幽灵公
  主》

- [[http://m.wufazhuce.com/one/2015-05-01][VOL.936]]

  我们花了很多时间来找寻最便捷的沟通方式，却忘了面对面的一个眼神一句话
  才是最贴心的交流。 from 《不过，一场生活》

- [[http://m.wufazhuce.com/one/2015-05-04][VOL.939]]

  那些无足轻重的人，那些听任自己变得无足轻重的人，在世界上没有位置。
  from《河湾》

- [[http://m.wufazhuce.com/one/2015-05-05][VOL.940]]

  我不知将去向何方，但我已在路上。by宫崎骏

- [[http://m.wufazhuce.com/one/2015-05-06][VOL.941]]

  有时我想，所有人都是一样的。在各自粉饰的外表下都有千疮百孔的人生和一
  个暗黑的深渊。如果了知这些，不会觉得自己特别，也不会觉得自己无辜。
  from 安妮宝贝《一封信》

- [[http://m.wufazhuce.com/one/2015-05-12][VOL.947]]

  大部分人在二三十岁就已经死去了，因为过了这个年龄，他们只是自己的影子，
  此后的余生则是在模仿自己中度过，更机械，更装腔作势地重复他们在有生之
  年的所作所为，所思所想，所爱所恨。 by 罗曼·罗兰

- [[http://m.wufazhuce.com/one/2015-05-14][VOL.949]]

  我不想再拘泥于一种颜色了，而是想去了解更多的颜色。from《暗杀教室》

- [[http://m.wufazhuce.com/one/2015-05-15][VOL.950]]

  在有生的瞬间能遇到你，竟花光所有运气。 from 《明年今日

- [[http://m.wufazhuce.com/one/2015-05-17][VOL.952]]

  别跟我说人生海海，我只想认识你，然后留下一段热泪盈眶的回忆。 from
  《向阳处的她》

- VO[[http://m.wufazhuce.com/one/2015-05-18][L.953]]

  时常想到过去的自己，羞耻到无法自拔。所以顺带着，便原谅了很多人。仿佛
  原谅了他们，也就原谅了过去的那个自己。by 自由极光

- [[http://m.wufazhuce.com/one/2015-05-19][VOL.954]]

  你始终不明白，一万个美丽的未来，抵不上一个温暖的现在。 from《关于现
  在关于未来》

- [[http://m.wufazhuce.com/one/2015-05-20][VOL.955]]

  醉过才知酒浓，爱过才知情重。你不能做我的诗，正如我不能做你的梦。
  from 胡适《梦与诗》

- [[http://m.wufazhuce.com/one/2015-05-21][VOL.956]]

  真正的输家是那些害怕失败，连尝试都不敢尝试的人。from《阳光小美女》

- [[http://m.wufazhuce.com/one/2015-05-22][VOL.957]]

  仰望星空，我想知道：有人正从世界的某个地方朝我走来吗？ 像光那样，从
  一颗星达到另外一颗星。by 几米

- VO[[http://m.wufazhuce.com/one/2015-05-23][L.958]]

  一个不成熟男子的标志是他愿意为某种事业英勇地死去，一个成熟男子的标志
  是他愿意为某种事业卑贱地活着。 from 《麦田守望者》

- [[http://m.wufazhuce.com/one/2015-05-25][VOL.960]]

  所有你们不相信的事情我都要一一地去做一遍，亲自体验一下不可理喻的成功，
  或早已注定的失败。 from《坦白书》

- [[http://m.wufazhuce.com/one/2015-05-29][VOL.964]]

  再好的朋友也应该保持一点距离，因为人最应该学会相处的那个人不是别人，
  而是自己。 by 王乌乌

- [[http://m.wufazhuce.com/one/2015-05-30][VOL.965]]

  喜欢你的理由，因为是你，那就是你。除了这个还有别的理由吗？如果我能知
  道原因的话就好了，那就能找到不喜欢你的办法了。 from 《请回答1997》

- [[http://m.wufazhuce.com/one/2015-06-04][VOL.970]]

  时间也许不会给你答案，但一定会让你忘记曾经问过什么。by 飞行官小北

- VO[[http://m.wufazhuce.com/one/2015-06-09][L.975]]

  你是你自己的裁决者。你过去和现在做得有多好，由你自己说了算。别人永远
  不能审判你，就算是神。 from 《与神对话》

- [[http://m.wufazhuce.com/one/2015-06-10][VOL.976]]

  人生不仅要能享受那些成功时刻让人激情澎湃的成名天下扬，也要能承受之前
  若干年漫长岁月里寂寞冷淡带来的寒窗无人问。by 暖小团

- [[http://m.wufazhuce.com/one/2015-06-12][VOL.978]]

  爱上一个人，会亢奋，爱着一个人，会沉溺，爱错一个人，会痛，而爱过的那
  个人，最有理由去遗忘。by 王云超

- [[http://m.wufazhuce.com/one/2015-06-14][VOL.980]]

  很奇怪，我们不屑与他人为伍，却害怕自己与众不同。 by 保罗·柯艾略

- [[http://m.wufazhuce.com/one/2015-06-17][VOL.983]]

  我想当一个人的时候，我就失去了我自己。在你什么都不想要的时候，一切如
  期而至。from《执者失之》

- VO[[http://m.wufazhuce.com/one/2015-06-20][L.986]]

  没有任何一种逃避能得到赞赏，喜欢就去追，饿了就吃饭，管它失败或是发胖。
  by 长期新新

- [[http://m.wufazhuce.com/one/2015-06-22][VOL.988]]

  先变成更喜欢的自己，然后遇到一个不需要取悦的人。 from 卢思浩 《愿有
  人陪你颠沛流离》

- [[http://m.wufazhuce.com/one/2015-06-28][VOL.994]]

  美貌、青春、财富、甚至爱情本身，都不能让深得上帝恩宠的人免于焦虑和痛
  苦，远离哀愁，也无法让他们避免失去自己最爱的东西。因为，一生中，有些
  雨必然得下。from 《小妇人》

- [[http://m.wufazhuce.com/one/2015-07-01][VOL.997]]

  并不顾忌表达不开心，才算得上真的过得开心。 by 方慧

- [[http://m.wufazhuce.com/one/2015-07-03][VOL.999]]

  一件事无论太晚或者太早，都不会阻拦你成为你想成为的那个人，这个过程没
  有时间的期限，只要你想，随时都可以开始。from 《返老还童》

- [[http://m.wufazhuce.com/one/2015-07-05][VOL.1001]]

  我为自己分分秒秒地疏漏万物向时间致歉。我为将新欢视为初恋向旧爱致歉。
  from 辛波斯卡《在一颗小星星下》

- [[http://m.wufazhuce.com/one/2015-07-06][VOL.1002]]

  你曾经是一整个时代，事实上你永远是，那段生命历程永远属于你，为你发光，
  但我不再怀有难抑的热情、倾注我所有梦想地，想去征服你。 by 贾彬彬

- [[http://m.wufazhuce.com/one/2015-07-07][VOL.1003]]

  当我对所有事情都厌倦的时候，我就会想到你，想到你在世界某个地方生活着、
  存在着，我就愿意去承受一切。你的存在对我很重要。 from 《美国往事》

- [[http://m.wufazhuce.com/one/2015-07-08][VOL.1004]]

  用笔写一句我爱你，胜过一万个微信表情。 from ONE BOX 《无用之诗》

- [[http://m.wufazhuce.com/one/2015-07-12][VOL.1008]]

  最美的不是下雨天，是曾与你躲过雨的屋檐。by 方文山

- [[http://m.wufazhuce.com/one/2015-07-13][VOL.1009]]

  任性的人大多都幸福，所以才敢挥霍无度。 by 刘同

- [[http://m.wufazhuce.com/one/2015-07-15][VOL.1011]]

  你不珍惜那个人，命运就会给他安排更好的人。 by 苑子豪

- [[http://m.wufazhuce.com/one/2015-07-18][VOL.1014]]

  我们都爱过注定不会爱我们的人，这没什么，因为总有那么一天，我们会突然
  发现原来自己这么多年不过是钻牛角尖而已，我们对往事的种种不忿，只是觉
  得自己受了委屈。 by 王云超

- [[http://m.wufazhuce.com/one/2015-07-19][VOL.1015]]

  和朋友最舒服的相处模式不是无话不说，而是可以不说话。 by 姬霄

- [[http://m.wufazhuce.com/one/2015-07-20][VOL.1016]]

  高兴就又跑又跳，悲伤就又哭又喊，那是上野动物园猴子干的事。笑在脸上，
  哭在心里，说出心里相反的语言，做出心里相反的脸色，这才叫人哪。by 小
  津安二郎

- [[http://m.wufazhuce.com/one/2015-07-22][VOL.1018]]

  有时想想，独居斗室和天涯浪迹好像是一件事情，身处寂寞和身处喧嚣其实也
  没什么两样，身外的整个世界都是镜子，我们必须自己认得自己。 from 马良
  《人间卧底》

- [[http://m.wufazhuce.com/one/2015-07-24][VOL.1020]]

  一个人做的梦，就只能是个梦；一群人怀着同一个梦想，便是真实。 by 约翰·列
  侬

- [[http://m.wufazhuce.com/one/2015-07-28][VOL.1024]]

  分别是，从此就一个人站在茫茫人群中，一个人站在世界上。我的每句话、每
  件事，都不能再说给你听。 by 苏更生

- [[http://m.wufazhuce.com/one/2015-07-30][VOL.1026]]

  我们每个人好像一直都在跑，却总觉得自己把心和最后一点安全感落在了千里
  之遥的家乡。by 暖小团

- [[http://m.wufazhuce.com/one/2015-07-31][VOL.1027]]

  我要一步一步往上爬，在最高点乘着叶片往前飞。小小的天流过的泪和汗，总
  有一天我有属于我的天。 from 周杰伦《蜗牛》

- [[http://m.wufazhuce.com/one/2015-08-01][VOL.1028]]

  只恨我当时年纪小，看不懂她那小小花招背后的一片柔情。 from《小王子》

- [[http://m.wufazhuce.com/one/2015-08-02][VOL.1029]]

  当所有等待都变成曾经，我会说好多精彩的故事给你听。from 《远行》

- [[http://m.wufazhuce.com/one/2015-08-05][VOL.1032]]

  我曾听人说过，当你不能够再拥有，你唯一可以做的，就是令自己不要忘记。
  from 《东邪西毒》

- [[http://m.wufazhuce.com/one/2015-08-06][VOL.1033]]

  人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以自始至终陪
  着走完。当陪你的人要下车时，即使不舍也该心存感激，然后挥手道别。by
  宫崎骏

- [[http://m.wufazhuce.com/one/2015-08-09][VOL.1036]]

  你最可爱，我说时来不及思索，但思索之后，还是这样说。 by 普希金

- [[http://m.wufazhuce.com/one/2015-08-11][VOL.1038]]

  成熟意味着看到差异，但又意识到差异并不重要。 by 特德·姜

- [[http://m.wufazhuce.com/one/2015-08-15][VOL.1042]]

  我是你夜里的太阳，也是你，影子里的悲伤。by 陈绮贞

- [[http://m.wufazhuce.com/one/2015-08-16][VOL.1043]]

  我不知道世间有什么是确定不变的，我只知道，只要一看到星星，我就会开始
  做梦。 by 文森特·梵高

- [[http://m.wufazhuce.com/one/2015-08-19][VOL.1046]]

  幸运的人会知道，幸运并不是富贵成功，抑或毫无痛苦地快乐着，而是无论喜
  怒哀乐，都被爱着。by 熊德启

- [[http://m.wufazhuce.com/one/2014-09-08][VOL.701]]

  所有的悲伤，总会留下一丝欢乐的线索。所有的遗憾，总会留下一处完美的角
  落。我在冰封的深海，找寻希望的缺口。却在午夜惊醒时，蓦然瞥见绝美的月
  光。from 《缺口》

- [[http://m.wufazhuce.com/one/2014-09-13][VOL.706]]

  生命中总会有那么一段时光，充满不安，可是除了勇敢面对，我们别无选择。
  by 佚名

- [[http://m.wufazhuce.com/one/2014-09-15][VOL.708]]

  希望死后的墓志铭可以有底气刻上：一生努力，一生被爱。想要的都拥有，得
  不到的都释怀。by 八月长安

- [[http://m.wufazhuce.com/one/2014-09-17][VOL.710]]

  心里有个人放在那里，是件收藏，如此才填充了生命的空白，太阳尚远，但必
  有太阳。from 七堇年《蓝颜》

- [[http://m.wufazhuce.com/one/2014-09-19][VOL.712]]

  秋天该很好，你若尚在场。from 张国荣《春夏秋冬》

- [[http://m.wufazhuce.com/one/2014-09-20][VOL.713]]

  有些人恐惧父母离去，或者江郎才尽还有衰老。我比较恐惧的是怕以后会埋怨
  自己，就是在力所能及时没有努力做一件事，当没有机会再去做时，会责备年
  轻的自己。 by 李娜

- [[http://m.wufazhuce.com/one/2014-09-22][VOL.715]]

  来年陌生的，是昨日最亲的某某。by 黄伟文

- [[http://m.wufazhuce.com/one/2014-09-24][VOL.717]]

  用我一生，再换你十年天真无邪。by 南派三叔

- [[http://m.wufazhuce.com/one/2014-09-26][VOL.719]]

  某天，你无端想起一个人，她曾让你对明天有所期许，但却完全没有出现在你
  的明天里。from《再见金华站》

- [[http://m.wufazhuce.com/one/2014-09-27][VOL.720]]

  越是低谷的时候，越能看出一个人的本质。最差的结果无非是失败，有人等着
  失败，有人骂着失败，有人尽了力仍然失败。在这样的环境里，心态就是每个
  人自身的光，你颓唐就是颓唐，你顽强就是顽强。 by 刘同

- [[http://m.wufazhuce.com/one/2014-10-01][VOL.724]]

  在这世上，有些东西是石头无法刻成的，在我们心里，有一块地方是无法锁住
  的，那块地方叫做希望。from 《肖申克的救赎》

- [[http://m.wufazhuce.com/one/2014-10-03][VOL.726]]

  从今以后，别再过你应该过的人生，去过你想过的人生吧！by 梭罗

- [[http://m.wufazhuce.com/one/2014-10-08][VOL.731]]

  无论你怎么与他人控制距离，你依然会失去控制，因为这个世界上总有人能让
  你乖乖交心和伤心。from 韩寒《告白与告别》

- [[http://m.wufazhuce.com/one/2014-10-10][VOL.733]]

  人总是在接近幸福时倍感幸福，在幸福进行时却患得患失。by 张爱玲

- [[http://m.wufazhuce.com/one/2014-10-14][VOL.737]]

  我知道这世上有人在等我，尽管我不知道他是谁。但是因为这样，我每天都非
  常快乐。from《返老还童》

- [[http://m.wufazhuce.com/one/2014-10-20][VOL.743]]

  一个人逛街，一个人吃饭，一个人旅行，一个人做很多事。一个人的日子固然
  寂寞，但更多时候是因寂寞而快乐。极致的幸福，存在于孤独的深海。在这样
  日复一日的生活里，我逐渐与自己达成和解。from《然后，我就一个人了》

- [[http://m.wufazhuce.com/one/2014-10-21][VOL.744]]

  相聚离开都有时候，没有什么会永垂不朽。by 林夕

- [[http://m.wufazhuce.com/one/2014-10-25][VOL.748]]

  你连想改变别人的念头都不要有。要学习太阳一样，只是发出光和热，每个人
  接收阳光的反应有所不同，有人觉得刺眼有人觉得温暖，有人甚至躲开阳光。
  种子破土发芽前没有任何的迹象，是因为没到那个时间点。只有自己才是自己
  的拯救者。 by 荣格

- [[http://m.wufazhuce.com/one/2014-10-27][VOL.750]]

  生活不可能像你想象得那么好，但也不会像你想象得那么糟。我觉得人的脆弱
  和坚强都超乎自己的想象。有时，我可能脆弱得一句话就泪流满面；有时，也
  发现自己咬着牙走了很长的路。by 莫泊桑

- [[http://m.wufazhuce.com/one/2014-10-29][VOL.752]]

  世界上最厉害的本领是什么？是以愉悦的心情老去，是在想工作的时候能选择
  休息，是在想说话的时候保持沉默，是在失望的时候又燃起希望。from 《使
  者》

- [[http://m.wufazhuce.com/one/2014-10-30][VOL.753]]

  努力想得到什么东西，其实只要沉着镇静、实事求是，就可以轻易地、神不知
  鬼不觉地达到目的。而如果过于使劲，闹得太凶，太幼稚，太没有经验，就哭
  啊，抓啊，拉啊，像一个小孩扯桌布，结果却是一无所获，只不过把桌上的好
  东西都扯到地上，永远也得不到了。by 卡夫卡

- [[http://m.wufazhuce.com/one/2014-11-01][VOL.755]]

  我喜欢你，我不难过；我希望你也喜欢我，我才难过。 by 八月长安

- [[http://m.wufazhuce.com/one/2014-11-02][VOL.756]]

  所有的大人都曾经是小孩，虽然，只有少数的人记得。from 《小王子》

- [[http://m.wufazhuce.com/one/2014-11-04][VOL.758]]

  小孩子才问你为什么不理我了，是不是不喜欢我了，成年人都是默契地相互疏
  远。by 玍几

- [[http://m.wufazhuce.com/one/2014-11-07][VOL.761]]

  世间最痛苦之事，莫过于泯然众人，默默无闻。by 佚名

- VO[[http://m.wufazhuce.com/one/2014-11-08][L.762]]

  决定去做一件事情，或是去养成一种习惯，甚至是去爱一个人；开始这些事情
  最好的时机，一般都是——此时此刻。 by 里则林

- [[http://m.wufazhuce.com/one/2014-11-10][VOL.764]]

  我一生中最幸运的两件事，一件是时间终于将我对你的爱消耗殆尽。一件是很
  久很久以前有一天，遇见你。by 顾漫

- [[http://m.wufazhuce.com/one/2014-11-11][VOL.765]]

  我只愿蓬勃生活在此时此刻，无所谓去哪，无所谓见谁，那些我将要去的地方，
  都是我从未谋面的故乡；那些我将要见的人，都会成为我的朋友。我不能选择
  怎么生，怎么死，但我能决定怎么爱，怎么活。from《黄金时代》

- [[http://m.wufazhuce.com/one/2014-11-13][VOL.767]]

  每个优秀的人都有一段沉默的时光。那一段时光是付出了很多努力，忍受孤独
  和寂寞，不抱怨不诉苦，日后说起时，连自己都能被感动的日子。from《关于
  这个世界，你不快乐什么》

- [[http://m.wufazhuce.com/one/2014-11-15][VOL.769]]

  仰望星空时，我们知道这些星星距离我们成百上千光年，有些甚至已经不存在
  了。它们的光花了很长很长时间才到达地球，而在此期间，他们本身已经消失
  或爆炸瓦解成红矮星了。这些事实会让人觉得自己很渺小，如果生活中遇到了
  困难，不妨想想这些，你就会明白什么叫微不足道。 by 马克·哈登

- [[http://m.wufazhuce.com/one/2014-11-16][VOL.770]]

  每个人在他的人生发轫之初，总有一段时光，没有什么可留恋，只有抑制不住
  的梦想，没有什么可凭仗，只有他的好身体，没有地方可去，只想到处流浪。
  by E·B·怀特

- [[http://m.wufazhuce.com/one/2014-11-18][VOL.772]]

  你曾经对我说你永远爱着我。爱情这东西我明白，但永远是什么？from《恋曲
  1980》

- [[http://m.wufazhuce.com/one/2014-11-19][VOL.773]]

  我一直以为最糟糕的情况是你离开我，其实最令我难过的，是你不快乐。from
  《怪物旅社》

- [[http://m.wufazhuce.com/one/2014-11-20][VOL.774]]

  那些与你毫无关系的人，就是毫无关系的，永远是毫无关系的。从认识的第一
  天开始，其实你就知道。就算是笑得甜甜蜜蜜，就算是有过无关痒痛的来往，
  就算你努力经营这段关系。而那些与你有关的，就是与你有关的，是逃也逃不
  掉的，就算你们只见过三次，就算你们三年彼此才搭理一次，就算是你简直想
  不起他或者她的样子，就算是你们隔着十万八千里。from《送你一颗子弹》

- [[http://m.wufazhuce.com/one/2014-11-21][VOL.775]]

  如果别人让你感到不满或者不快，或者他们的行为不如意，你需要理解，不是
  每个人都像你这样，受到了良好的教育。by 菲茨杰拉德

- [[http://m.wufazhuce.com/one/2014-11-30][VOL.784]]

  生活总是让我们遍体鳞伤，但到后来，那些受伤的地方一定会变成我们最强壮
  的地方。from 《老人与海》

- [[http://m.wufazhuce.com/one/2014-12-05][VOL.789]]

  我生命里最大的突破之一，就是我不再为别人对我的看法而担忧。此后，我真
  的能自由地去做我认为对自己最好的事。只有在我们不需要外来的赞许时，才
  会变得自由。by 罗伊·马丁纳

- [[http://m.wufazhuce.com/one/2014-12-07][VOL.791]]

  脚步不能达到的地方，眼光可以到达；眼光不能到达的地方，精神可以飞到。
  from《悲惨世界》

- [[http://m.wufazhuce.com/one/2014-12-08][VOL.792]]

  人在面临幸福时会突然变得胆怯，抓住幸福其实比忍受痛苦更需要勇气。
  from《下妻物语》

- [[http://m.wufazhuce.com/one/2014-12-11][VOL.795]]

  没人能挽留你在这个世界，就像没人能阻止你来到这个世界。如果非要说害怕
  什么，我只是害怕上帝丢给我太多理想，却忘了给我完成理想的时间。
  from《站在两个世界的边缘》

- [[http://m.wufazhuce.com/one/2014-12-14][VOL.798]]

  对相爱的人来说，对方的心才是最好的房子。by 村上春树

- [[http://m.wufazhuce.com/one/2014-12-15][VOL.799]]

  过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写
  作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以。by 陈素
  封

- [[http://m.wufazhuce.com/one/2014-02-22][VOL.503]]

  人生的一大挑战是，在一个丧失自我的世界中保持自我。 by 佚名

- [[http://m.wufazhuce.com/one/2014-02-23][VOL.504]]

  恋爱有时真的很随机，早点晚点多爱点少爱点勇敢点怂点，一念之差就是另一
  个不同的人生。by 赵小姐失眠中

- [[http://m.wufazhuce.com/one/2014-02-24][VOL.505]]

  你走，我不送你。你来，无论多大风多大雨，我要去接你。by 梁实秋

- [[http://m.wufazhuce.com/one/2014-02-25][VOL.506]]

  杯中的水是亮闪闪的，海里的水是黑沉沉的。小道理可用文字说清楚，大道理
  却只有伟大的沉默。by 泰戈尔

- [[http://m.wufazhuce.com/one/2014-02-28][VOL.509]]

  被爱的人也许不知道，他的一句晚安可媲美满天星光。by 十三空

- [[http://m.wufazhuce.com/one/2014-03-05][VOL.514]]

  这世界不会被那些作恶多端的人毁灭，而是冷眼旁观、选择保持缄默的人。by
  爱因斯坦

- [[http://m.wufazhuce.com/one/2014-03-06][VOL.515]]

  听到一些事，明明不相干的，也会在心中拐好几个弯，想到你。by 张爱玲

- [[http://m.wufazhuce.com/one/2014-03-09][VOL.518]]

  如果当初我勇敢，结局是不是不一样。如果当时你坚持，回忆会不会不一般。
  最终我还是没说，你还是忽略。by 岩井俊二

- [[http://m.wufazhuce.com/one/2014-03-11][VOL.520]]

  如果你要驯服一个人，就要冒着掉眼泪的危险。from《小王子》

- [[http://m.wufazhuce.com/one/2014-03-18][VOL.527]]

  我离你很远，我没有什么可以跟你说的，可是我就在这里，而且我知道你在那
  里。by 米兰·昆德拉

- [[http://m.wufazhuce.com/one/2014-03-21][VOL.530]]

  世界那么微妙，有那么多种不可思议，你却把自己定义在那里，杀死了所有的
  可能性。by 仲尼Johnny

- [[http://m.wufazhuce.com/one/2014-03-25][VOL.534]]

  我觉得生命是最重要的，所以在我心里，没有事情是解决不了的。不是每一个
  人都可以幸运的过自己理想中的生活，有楼有车当然好了，没有难道哭吗？所
  以呢，我们一定要享受我们所过的生活。from《新不了情》

- [[http://m.wufazhuce.com/one/2014-03-27][VOL.536]]

  没有玩具的孩子最落寞，可是没有梦的男人是什么。from《关于男人》

- [[http://m.wufazhuce.com/one/2014-03-29][VOL.538]]

  我们都是白痴，才会这样钻牛角尖。不管是什么狗屁事，我们总是，总是，总
  是忘不了我们那点叫人作呕的、微不足道的自我。 by 塞林格

- [[http://m.wufazhuce.com/one/2014-03-30][VOL.539]]

  当我们相信自己对这个世界已经相当重要的时候，其实这个世界才刚准备原谅
  我们的幼稚。from 《青春梦工场》

- [[http://m.wufazhuce.com/one/2014-03-31][VOL.540]]

  我爱你不是因为你是谁，而是我在你面前可以是谁。from 《剪刀手爱德华》

- [[http://m.wufazhuce.com/one/2014-04-03][VOL.543]]

  生为冰山，就该淡淡地爱海流、爱风，并且在偶然接触时，全心全意地爱另一
  块冰山。from 王小波《似水柔情》

- [[http://m.wufazhuce.com/one/2014-04-05][VOL.545]]

  你一直是我生命中永远都不可能重复的一场遭遇。 by 安·兰德

- [[http://m.wufazhuce.com/one/2014-04-06][VOL.546]]

  但凡未得到，但凡是过去，总是最登对 。from《似是故人来》

- [[http://m.wufazhuce.com/one/2014-04-12][VOL.552]]

  我所认为最深沉的爱，莫过于分开以后，我将自己，活成了你的样子。 from
  《这个杀手不太冷》

- [[http://m.wufazhuce.com/one/2014-04-13][VOL.553]]

  人，要么庸俗，要么孤独。by 叔本华

- [[http://m.wufazhuce.com/one/2014-04-14][VOL.554]]

  人不只有一种颜色，有很多种颜色，真正的颜色，自己的颜色，谁也不知道。
  多姿多彩就行，请多姿多彩地活下去吧。from 《意外的幸运签》

- [[http://m.wufazhuce.com/one/2014-04-26][VOL.566]]

  如果有天我们湮没在人潮之中，庸碌一生，那是因为我们没有努力要活得丰盛。
  by 黄碧云

- [[http://m.wufazhuce.com/one/2014-04-29][VOL.569]]

  我为你翻山越岭，却无心看风景。by 林夕

- [[http://m.wufazhuce.com/one/2014-05-03][VOL.573]]

  生命里面很多事情，沉重婉转至不可说。我想你明白。正如我想我明白你。
  by 黄碧云

- [[http://m.wufazhuce.com/one/2014-05-10][VOL.580]]

  一生至少该有一次，为了某个人而忘了自己，不求有结果，不求同行，不求曾
  经拥有，甚至不求你爱我，只求在我最美的年华里，遇到你。 by 徐志摩

- VO[[http://m.wufazhuce.com/one/2014-05-13][L.583]]

  那一年我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还
  想在一瞬间变成天上半明半暗的云。by 王小波

- [[http://m.wufazhuce.com/one/2014-05-19][VOL.589]]

  你们必须努力寻找自己的声音，因为你越迟开始寻找，找到的可能性就越小。
  from 《死亡诗社》

- [[http://m.wufazhuce.com/one/2014-05-24][VOL.594]]

  你是什么人便会遇上什么人；你是什么人便会选择什么人。总是挂在嘴上的人
  生，就是你的人生，人总是很容易被自己说出的话所催眠。我多怕你总是挂在
  嘴上的许多抱怨，将会成为你所有的人生。 by 竹久梦二

- [[http://m.wufazhuce.com/one/2014-05-26][VOL.596]]

  做你最喜欢的，其他都他妈是扯淡。from 《阳光小美女》

- [[http://m.wufazhuce.com/one/2014-05-30][VOL.600]]

  我们听过无数的道理，却仍旧过不好这一生。from《后会无期》

- [[http://m.wufazhuce.com/one/2013-11-12][VOL.401]]

  记得是最好的原谅，原谅是最美的遗忘。by 迟遇

- [[http://m.wufazhuce.com/one/2013-11-13][VOL.402]]

  生活总会给你答案，但不会马上把一切都告诉你。by 马德

- [[http://m.wufazhuce.com/one/2013-11-18][VOL.407]]

  相呴以湿，相濡以沫，不若相忘于江湖。from 《庄子》

- VO[[http://m.wufazhuce.com/one/2013-11-20][L.409]]

  大部分的痛苦，都是不肯离场的结果，没有命定的不幸，只有死不放手的执着。
  by 素黑

- [[http://m.wufazhuce.com/one/2013-11-23][VOL.412]]

  我们领教了世界是何等凶顽，同时又得知世界也可以变得温存和美好。 by 村
  上春树

- [[http://m.wufazhuce.com/one/2013-11-24][VOL.413]]

  我越是逃离，却越是靠近你，我越是背过脸，却越是看见你。我是一座孤岛，
  处在相思之水中，四面八方，隔绝我通向你。一千零一面镜子，转映着你的容
  颜，我从你开始，我在你结束。 by 埃姆朗·萨罗希

- [[http://m.wufazhuce.com/one/2013-11-25][VOL.414]]

  你从远方来，我到远方去，遥远的路程经过这里。天空一无所有，为何给我安
  慰？from 海子《黑夜的献诗》

- [[http://m.wufazhuce.com/one/2013-11-27][VOL.416]]

  我还年轻，我渴望上路。from 杰克·凯鲁亚克《在路上》

- [[http://m.wufazhuce.com/one/2013-11-28][VOL.417]]

  我理解的爱情，似乎要有些惊心动魄伤筋动骨的东西。如果没有痛感，而只有
  快感，那就是成年人的一种两性关系而已。from《1980年代的爱情》

- [[http://m.wufazhuce.com/one/2013-12-02][VOL.421]]

  不能一直踮着脚爱一个人，重心不稳，撑不了太久的。by 颜茹玉

- [[http://m.wufazhuce.com/one/2013-12-04][VOL.423]]

  永远不要认为我们可以逃避，我们的每一步都决定着最后的结局，我们的脚正
  在走向我们自己选定的终点。by 米兰·昆德拉

- [[http://m.wufazhuce.com/one/2013-12-14][VOL.433]]

  世上只有一种真正的英雄主义，那就是认清生活的真相后依然热爱生活。by
  罗曼·罗兰

- VO[[http://m.wufazhuce.com/one/2013-12-15][L.434]]

  每个人都有属于自己的一片森林，也许我们从来不曾走过，但它一直在那里，
  总会在那里。迷失的人迷失了，相逢的人会再相逢。from《挪威的森林》

- [[http://m.wufazhuce.com/one/2013-12-19][VOL.438]]

  人啊，根据重新振作的方法，大概可以分为两种：一种是看着比自己卑微的东
  西，找寻垫底的借以自慰；另一种是看着比自己伟大的东西，狠狠地踢醒毫无
  气度的自己。from《银魂》

- [[http://m.wufazhuce.com/one/2013-12-20][VOL.439]]

  一个彻底诚实的人是从不面对选择的，那条路永远会清楚无二地呈现在你面前，
  这和你的憧憬无关，就像你是一棵苹果树，你憧憬结橘子，但是你还是诚实地
  结出苹果一样。by 顾城

- [[http://m.wufazhuce.com/one/2013-12-26][VOL.445]]

  真爱的第一个征兆，在男孩身上是胆怯，在女孩身上是大胆。from《悲惨世界》

- [[http://m.wufazhuce.com/one/2013-12-28][VOL.447]]

  如果我们不争取，如果我们不配拥有未来，我们就得永远活在现状。或者更糟，
  得活在过去。我想爱的用意大概就在这里，爱是争取未来的方式。 by 格里高
  利·大卫·罗伯兹

- [[http://m.wufazhuce.com/one/2014-01-05][VOL.455]]

  长长的路上我想我们是朋友，如果有期待我想最好是不说。from 阿信《纯真》

- [[http://m.wufazhuce.com/one/2014-01-06][VOL.456]]

  当你在深夜醒来，发现自己因为想念某人而胸口发疼，你，把它叫做什么？
  from 《冷山》

- [[http://m.wufazhuce.com/one/2014-01-12][VOL.462]]

  你和那些好东西，总有一天会相遇。by 环玥

- [[http://m.wufazhuce.com/one/2014-01-23][VOL.473]]

  你的过去我不愿过问，那是你的事情。你的未来我希望参与，这是我的荣幸。
  from《神探夏洛克》

- [[http://m.wufazhuce.com/one/2014-01-28][VOL.478]]

  什么是爱？这其实很简单。凡是提高、充实、丰富我们生活的东西就是爱。通
  向一切高度和深度的东西就是爱。by 卡夫卡

- [[http://m.wufazhuce.com/one/2014-02-03][VOL.484]]

  两条道路分散在树林里，而我选择的那条更少人迹，从此决定了我人生的迥异。
  by 罗伯特·弗罗斯特

- [[http://m.wufazhuce.com/one/2014-02-05][VOL.486]]

  爱一个人最好的方式，是经营好自己，给对方一个优质的爱人。by 苏岑

- [[http://m.wufazhuce.com/one/2014-02-10][VOL.491]]

  陆上的人喜欢寻根究底，虚度很多的光阴。冬天忧虑夏天的迟来，夏天担心冬
  天的将至。所以你们不停到处去追求一个遥不可及、四季如夏的地方——我并不
  羡慕。from《海上钢琴师》

- [[http://m.wufazhuce.com/one/2014-02-09][VOL.490]]

  长日尽处，我站在你的面前，你将看到我的伤痕，知道我曾经受伤，也曾经痊
  愈。 by 泰戈尔

- [[http://m.wufazhuce.com/one/2014-02-15][VOL.496]]

  我一直在想，我到底是喜欢你， 还是需要一个影子，放在心里，让我喜欢。
  by 佚名

- [[http://m.wufazhuce.com/one/2014-02-18][VOL.499]]

  似水流年才是一个人的一切,其余的全是片刻的欢娱和不幸。by 王小波

- [[http://m.wufazhuce.com/one/2013-10-02][VOL.360]]

  人一生会遇到约2920万人，两个人相爱的概率是0.000049，所以你不爱我，我
  不怪你。by 佚名

- [[http://m.wufazhuce.com/one/2013-10-06][VOL.364]]

  没有足够的勇气去冒险的人，人生将一事无成。by 拳王阿里

- [[http://m.wufazhuce.com/one/2013-10-11][VOL.369]]

  等一个不爱你的人，就像在机场等一艘船。by 佚名

- [[http://m.wufazhuce.com/one/2013-10-13][VOL.371]]

  我常常思考为何鸟儿拥有整片天空，却老是停留在一个地方。然后我问了自己
  同样的问题。by Harun Yahya

- [[http://m.wufazhuce.com/one/2013-10-14][VOL.372]]

  真实的世界使我感兴趣，因为它是可塑的。by 纪德

- [[http://m.wufazhuce.com/one/2013-10-16][VOL.374]]

  旅行是消除无知和仇恨的最好方法。by 马克·吐温

- [[http://m.wufazhuce.com/one/2013-10-17][VOL.375]]

  什么都无法舍弃的人，什么都无法改变。from《进击的巨人》

- [[http://m.wufazhuce.com/one/2013-10-20][VOL.378]]

  有些人能清楚地听到自己内心深处的声音，并以此行事。这些人要么变成了疯
  子，要么成为传奇。from 《燃情岁月》

- [[http://m.wufazhuce.com/one/2013-10-21][VOL.379]]

  我们要不就让自己悲伤，要不就让自己强大，其所需要的工作量是一样的。by
  卡洛斯·卡斯塔尼达

- [[http://m.wufazhuce.com/one/2013-10-22][VOL.380]]

  什么叫多余？夏天的棉袄，冬天的蒲扇，还有等我已经心冷后你的殷勤。by
  李碧华

- [[http://m.wufazhuce.com/one/2013-10-28][VOL.386]]

  希望是件好东西，也许是世上最好的东西。好东西从来不会流逝。from 《肖
  申克的救赎》

- [[http://m.wufazhuce.com/one/2013-10-30][VOL.388]]

  哪里会有人喜欢孤独，不过是不喜欢失望罢了。 by 村上春树

- VO[[http://m.wufazhuce.com/one/2013-10-31][L.389]]

  世界以痛吻我，要我报之以歌。by 泰戈尔

- [[http://m.wufazhuce.com/one/2013-11-02][VOL.391]]

  每个人都会死，但不是每个人都真正活过。from 《勇敢的心》

- [[http://m.wufazhuce.com/one/2013-11-06][VOL.395]]

  我什么也没忘，但有些事只适合收藏。by 史铁生

- [[http://m.wufazhuce.com/one/2013-11-11][VOL.400]]

  “大丈夫何患无妻。”by「一个」工作室

- [[http://m.wufazhuce.com/one/2013-08-07][VOL.304]]

  忠诚的意义在于我们不应该忘记爱过的每一个人。from 《忠犬八公》

- [[http://m.wufazhuce.com/one/2013-08-09][VOL.306]]

  我不想谋生，我想生活。by 奥斯卡·王尔德

- [[http://m.wufazhuce.com/one/2013-08-10][VOL.307]]

  有一天你会遇到一个彩虹般绚丽的人，从此以后，其他人就不过是匆匆浮云。
  from《怦然心动》

- [[http://m.wufazhuce.com/one/2013-08-15][VOL.312]]

  每个人都有失恋的时候，而每一次我失恋，我都会去跑步。from《重庆森林》

- [[http://m.wufazhuce.com/one/2013-08-18][VOL.315]]

  每天呆在这里，会把这里当成是全世界，不再追寻，不再拥有。你得离开一阵
  子。from 《天堂电影院》

- [[http://m.wufazhuce.com/one/2013-08-19][VOL.316]]

  人如果总逃避的话，眼神会先于生命失去光彩的。from 《尽管如此，也要活
  下去》

- VO[[http://m.wufazhuce.com/one/2013-08-23][L.320]]

  虽然花会零落，但会重开。from《一生所爱》

- [[http://m.wufazhuce.com/one/2013-08-24][VOL.321]]

  你们一直抱怨这个地方，但是你们却没有勇气走出这里。from《飞越疯人院》

- [[http://m.wufazhuce.com/one/2013-08-25][VOL.322]]

  活着就意味必须要做点什么，请好好努力。from 村上春树《地下》

- [[http://m.wufazhuce.com/one/2013-08-27][VOL.324]]

  我一点都不遗憾没有在最好的时光遇到你，因为遇到你之后最好的时光才开始。
  by 杜小明

- [[http://m.wufazhuce.com/one/2013-08-28][VOL.325]]

  25岁的我，也许什么也没有，但命运就在我手中。by 马克·塞雷纳

- [[http://m.wufazhuce.com/one/2013-08-29][VOL.326]]

  有时候，一个人的业余活动也许比他的职业还更重要。by 胡适

- [[http://m.wufazhuce.com/one/2013-08-30][VOL.327]]

  我想在大地上画满窗子，让所有习惯黑暗的眼睛都习惯光明。by 顾城

- [[http://m.wufazhuce.com/one/2013-09-02][VOL.330]]

  时间是亳不留情的，它真使人在自己制造的镜子里照见自己的真相。by 季羡
  林

- [[http://m.wufazhuce.com/one/2013-09-05][VOL.333]]

  你不能把这个世界，让给你所鄙视的人。from 安·兰德《源泉》

- [[http://m.wufazhuce.com/one/2013-09-07][VOL.335]]

  我们能做的，仅仅是在这条路上走得更远，绝不能回头。天堂未必在前方，但
  地狱一定在身后。by 程浩

- [[http://m.wufazhuce.com/one/2013-09-09][VOL.337]]

  决定我们成为什么样人的，不是我们的能力，而是我们的选择。from《哈利波
  特》

- [[http://m.wufazhuce.com/one/2013-09-10][VOL.338]]

  不要和总是不接电话的人交朋友。by 丁丁张

- [[http://m.wufazhuce.com/one/2013-09-11][VOL.339]]

  所有的光鲜亮丽都敌不过时间，并且一去不复返。from《了不起的盖茨比》

- [[http://m.wufazhuce.com/one/2013-09-15][VOL.343]]

  爱是想触碰又收回手。from 塞林格《破碎故事之心》

- [[http://m.wufazhuce.com/one/2013-09-17][VOL.345]]

  生命里的VIP，总是让你甘愿把自己的原则一再打折。by 一蚊丁

- [[http://m.wufazhuce.com/one/2013-09-19][VOL.347]]

  真的，单单你的名字就够我爱一世了。by 王小波

- [[http://m.wufazhuce.com/one/2013-09-22][VOL.350]]

  这个世界上唯有两样东西能让我们的心灵感到深深的震撼：一是我们头顶上灿
  烂的星云，二是我们心中崇高的道德法则。by 康德

- VOL.1092

  深思熟虑的结果往往就是说不清楚。by 王小波

- VOL.1093

  我们无法做到完美，所以我评价一个人就看他在做不可能完成的事情时，失败
  得有多精彩。 by 威廉·福克纳

- VOL.1101

  我觉得我爱了你了，从此以后，不管什么时候我都不能对你无动于衷。by 王
  小波

- VOL.1090

  当对幸福的憧憬过于急切，那痛苦就在人的心灵深处升起。 by 加缪

- VOL.1093

  我们无法做到完美，所以我评价一个人就看他在做不可能完成的事情时，失败
  得有多精彩。 by 威廉·福克纳

- VOL.1090

  我们都是白痴，才会这样钻牛角尖 。不管是什么狗屁事，我们总是，总是，
  总是忘不了我们那点叫人作呕的、微不足道的自我。 by 塞林格

- VOL.1086

  世界让我挫败，我还舍不得离开。from 《奥丽芙·基特里奇》

- VOL.1090

  当对幸福的憧憬过于急切，那痛苦就在人的心灵深处升起。 by 加缪

- VOL.1075

  人生何必如初见，但求相看两不厌。by 蔡康永

- VOL.1081Almost

  男女之间不可能存在友谊，有的只是爱恨情仇。 by 王尔德



*** 文章

- [[http://wufazhuce.com/one/vol.774?from=timeline&isappinstalled=1#articulo][奔跑的时光]]
- [[http://hanhan.qq.com/hanhan/one/one372m.htm?from=timeline&isappinstalled=1#page1][我想笑着说说三小姐的故事]]
- [[http://hanhan.qq.com/hanhan/one/one383m.htm?from=timeline&isappinstalled=1#page1][关于理想的课堂作文]]
- [[http://wufazhuce.com/one/vol.539?from=timeline&isappinstalled=1#articulo][青春不是一块遮羞布]]
- [[http://wufazhuce.com/one/vol.538?from=timeline&isappinstalled=1#articulo][名字和名字刻在一起]]
- [[http://hanhan.qq.com/hanhan/one/one354m.htm?from=timeline&isappinstalled=1#page1][红灯须硬闯，马路要横穿]]
- [[http://hanhan.qq.com/hanhan/one/one397m.htm?from=timeline&isappinstalled=1#page1][我和邵毛毛的日与夜]]
- [[http://hanhan.qq.com/hanhan/one/one409m.htm?from=timeline&isappinstalled=1#page1][第一首歌：《我就是我》]]
- [[http://wufazhuce.com/one/vol.513?from=timeline&isappinstalled=1#articulo][跑步少女]]
- [[http://wufazhuce.com/one/vol.533?from=timeline&isappinstalled=1#articulo][鲸]]
- [[http://hanhan.qq.com/hanhan/one/one429m.htm?from=timeline&isappinstalled=1#page1][九月十三]]
- [[http://hanhan.qq.com/hanhan/one/one425m.htm?from=timeline&isappinstalled=1#page1][温柔的风穿堂过]]
- [[http://wufazhuce.com/one/vol.494?from=timeline&isappinstalled=1#articulo][你是我从池子里钓起来的云]]
- [[http://wufazhuce.com/one/vol.439?from=timeline&isappinstalled=1#articulo][当全世界叫你怂包的时候]]
- [[http://wufazhuce.com/one/vol.471?from=timeline&isappinstalled=1#articulo][过去分词]]
- [[http://hanhan.qq.com/hanhan/one/one377m.htm?from=timeline&isappinstalled=1#page1][大海]]
- [[][]]
- [[][]]

*** 问答

- [[贴插件][com/one/vol.536?from=timeline&isappinstalled=1#cuestion][是不是不努力看起来更潇洒？]]
- [[http://wufazhuce- [[http://hanhan.qq.com/hanhan/one/one409m.htm?from=timeline&isappinstalled=1#page2][如何提高当众表白的成功率？有什么需要注意的地方呢？]]
- [[][]]
- [[][]]
- [[][]]
- [[][]]
- [[][]]
- [[][]]
- [[][]]
- [[][]]
- [[][]]
- [[][]]
]]

** EmacsWiki

- [[http://www.emacswiki.org/emacs/PhpMode][phpmode]]
- [[http://www.emacswiki.org/emacs/ArduinoSupport][ArduinoSupport]]
- [[http://www.emacswiki.org/emacs/AutoComplete][AutoComplete]]
- [[http://www.emacswiki.org/emacs/ArtistMode][ArtistMode]]
- [[http://www.emacswiki.org/emacs/ProgrammingWithPythonModeDotEl][ProgrammingWithPythonModeDotEl]]
- [[http://www.emacswiki.org/emacs/PythonProgrammingInEmacs][PythonProgrammingInEmacs]]
- [[http://www.emacswiki.org/emacs/EasyPG][EasyPG]]
- [[http://www.emacswiki.org/emacs/ThumbsMode][ThumbsMode]]
- [[http://www.emacswiki.org/emacs/XKeymacs][XKeymacs]]
- [[http://www.emacswiki.org/emacs/MakefileMode][MakefileMode]]
- [[http://www.emacswiki.org/emacs/DeletingWhitespace][DeletingWhitespace]]
- [[http://www.emacswiki.org/emacs/Edit_with_Emacs][Emacs]]
- [[http://www.emacswiki.org/emacs/CopyWithoutSelection][CopyWithoutSelection]]
- [[http://www.emacswiki.org/emacs/ModeLine][ModeLine]]

** robocup                                                         :robocup:

机器人世界杯（RoboCup）是一个国际合作项目，为促进人工智能、机器人和相
关领域。它为人工智能机器人研究提供了广泛的技术标准问题，能够被综合和检
验。该机器人项目的最终目标是:到2050年，开发完全自主仿人机器人队，能赢
得对人类足球世界冠军队。为了真正作为一个团队进行机器人足球比赛，必须包
含各种技术，包括：智能体自主设计、多智能体协作、策略获取、实时推理、机
器人和传感器融合。机器人世界杯中还提供了软件平台进行软件方面在机器人世
界杯中的研究。

目前共有三个全球性的机器人比赛联盟， 分别是以亚太地区为主的“国际奥林
匹克机器人大赛”（WRO， World Robot Olympiad）、总部位于美国的“第一乐
高联盟”（FLL，FIRST Lego League）， 与近来相当受人瞩目的机器人世界杯
足球赛。

其中机器人世界杯系列活动是一项综合教育与科技的国际性活动， 亦是学术成
分最高的赛事。

机器人世界杯的概念是于1993年提出的，经过2年的可行性考察，于1995年8月，
组织委员会正式宣布将举行世界性的机器人交流和机器人足球赛。1997年7月，
首届机器人世界杯大赛在日本名古屋举行。随后，法国巴黎、瑞典斯德哥尔摩，
澳大利亚墨尔本和美国西雅图都分别成功地举办国际机器人世界杯赛事，每年的
活动都吸引了大量的科技工作人员和对机器人感兴趣的人士参与。

RCJ是全球各地区，及国际机器人科技教育专家为青少年朋友提供的一个以教育
和科技结合在一起的竞赛项目，亦可说是以体育竞赛为主体的科技研究交流赛。
青少年足球赛结合机械设计、程式撰写，发展青少年无限创意和潜能，使机器人
能在场上进行比赛，从活动中探讨对科学知识的实践与了解。 先后已有法国、
瑞典、德国、英国、澳洲、加拿大、美国、日本、意大利、以及其他二十多个国
家举办。

目前中国大陆、德国、日本、伊朗、韩国、美国、台湾、香港以及澳门皆投入机
器人世界杯比赛行列。

RoboCup比赛项目
+ 机器人足球
  - 仿真组
    - 仿真2D组
    - 仿真3D组
  - 小型组 - 相关视频
  - 中型组
  - 标准平台组 - 相关视频
  - 类人组 - 相关视频
+ 机器人救援
  - 救援仿真组
  - 救援机器人
+ 家用机器人
+ 初级组（青少年机器人世界杯）
  - 中小学舞蹈
  - 中小学足球
  - 中小学救援

** wiki 代理

从该IP地址段106.187.32.0/20的账户创建已被Jimmy-abot禁止，而这也包括了
您的IP地址（106.187.44.23）。

Jimmy-abot给出的原因是

Banned proxys.svg您正在使用的IP地址已经被封禁，因我们相信其被用作代理。


问题是： 没法登录！！！

** knowledge

** 英文月份缩写

*1-12月份英文简写,后面必须加点*

|-----------+------|
| January   | Jan. |
| February  | Feb. |
| March     | Mar. |
| April     | Apr. |
| May       | May  |
| June      | Jun. |
| July      | Jul. |
| August    | Aug. |
| September | Sep. |
| October   | Oct. |
| November  | Nov. |
| December  | Dec. |
|-----------+------|

** [[http://blog.chinaunix.net/uid-25148547-id-138696.html][Protel中Cap,Cap2，Cap Pol的区别]]

# 序号	英文简写	元件英文名	元件中文名

|----+--------------+---------------------------------------+----------------------------------------------------|
|  1 | Res semi     | Semiconductor Resistor                | 半导体电阻                                         |
|  2 | Cap semi     | Semiconductor Capacitor               | 半导体电容器                                       |
|  3 | Cap Var      | Variable or                           | Adjustable Capacitor       可变或可调电容          |
|  4 | Cap Pol1     | Polarized Capacitor                   | (Radial)   极化电容（径向）                        |
|  5 | Cap Pol2     | Polarized Capacitor                   | (Axial)    极化电容（轴向）                        |
|  6 | Cap          | Capacitor                             | 电容（径向）                                       |
|  7 | Cap Pol3     | Polarized Capacitor                   | (Surface Mount)    极化电容（表面贴装）            |
|  8 | Cap Feed     | Feed-Through                          | Capacitor 馈通电容                                 |
|  9 | Cap2         | Capacitor                             | 电容                                               |
| 10 | Res Varistor | Varistor (Voltage-Sensitive Resistor) | 压敏电阻（电压敏感电阻）                           |
| 11 | Res Tap      | Tapped Resistor                       | 抽头电阻                                           |
| 12 | Res Thermal  | Thermal Resistor                      | 热敏电阻                                           |
| 13 | Rpot         | Potentiometer Resistor                | （侧调或顶调）电位器                               |
| 14 | Rpot SM      | Square Trimming                       | Potentiometer （顶调）方形电位器                   |
| 15 | Res Bridge   | Resistor Bridge                       | 电阻桥                                             |
| 16 | Bridge1      | Full Wave Diode Bridge                | 整流桥                                             |
| 17 | Bridge2      | Bridge Rectifier                      | 整流桥集成组件（比1封装较大）                      |
| 18 | Res Adj      | Variable Resistor                     | 可变电阻                                           |
| 19 | Res3         | Resistor                              | IPC的高密度贴片电阻                                |
| 20 | D Tunnel2    | Tunnel Diode                          | - Dependent Source Model  隧道二极管 - 依赖源模型  |
| 21 | D Varactor   | Variable Capacitance Diode            | 变容二极管                                         |
| 22 | D Schottky   | Schottky Diode                        | 肖特基二极管                                       |
| 23 | Diode 1N5402 | 3 Amp                                 | General Purpose Rectifier        3放大器通用整流器 |
|----+--------------+---------------------------------------+----------------------------------------------------|

其中，cap，cap2，cap pol1和cap pol2分别如下图所示


#+DOWNLOADED: http://blog.chinaunix.net/attachment/201102/25/25148547_1298643961S8lR.jpg @ 2016-01-23 00:11:22
 [[~/Wally/Journal/Figure/.org-download/Journal/25148547_1298643961S8lR_2016-01-23_00:11:22.jpg]]

其中，径向型电容如下图所示：


#+DOWNLOADED: http://blog.chinaunix.net/attachment/201102/25/25148547_1298604806OTrm.jpg @ 2016-01-23 00:11:45
 [[~/Wally/Journal/Figure/.org-download/Journal/25148547_1298604806OTrm_2016-01-23_00:11:45.jpg]]


轴向型电容如下所示：


#+DOWNLOADED: http://blog.chinaunix.net/attachment/201102/25/25148547_1298604874zIM5.jpg @ 2016-01-23 00:12:05
 [[~/Wally/Journal/Figure/.org-download/Journal/25148547_1298604874zIM5_2016-01-23_00:12:05.jpg]]

有极性电阻为电解电容，无极性电阻为普通电容，电解电容的容量一般比普通电
容的大，在滤波时电解电容用于滤低频，普通电容用于滤高频。

**

** fd
** [[http://blog.jobbole.com/49800/][Bash One-Liners Explained（一）：文件处理]]

原文出处：[[http://www.catonmat.net/series/bash-one-liners-explained][Peteris Krumins]]
译文出处：[[http://kodango.com/bash-one-liners-explained-part-one][团子的小窝]]

[[http://www.catonmat.net/series/bash-one-liners-explained][*BashOne-Liners Explained*]] 是一系列介绍 Bash 命令技巧的文章，由国外牛
人 [[http://www.catonmat.net/][Peteris Krumins]] 撰写。凭借扎实的功底和丰富的经验，作者总结了许多快
速解决问题的技巧，并且每一条都只要用简洁的一行Bash 命令就可以完成，同
时每一行命令文中都给出了非常详尽的解释。

Peteris Krumins是一位高产的博主，在他的博客上有很多非常精彩的文章，推
荐大家有机会都可以去好好读一读。例如，大家耳熟能详的
[[http://www.catonmat.net/series/awk-one-liners-explained][Awk
One-Liners
Explained]]、[[http://www.catonmat.net/series/sed-one-liners-explained][Sed
One-Liners Explained]]
等等。后者我也曾经在博客上分享过[[http://kodango.com/sed1line-notes][一篇笔记]]。

回到正题，虽然这一系列文章不难，但是还是可以从中学到很多细节的知识，相
信这些肯定会对许多初学者有所帮助，所以我打算将这一系列翻译成中文，分享
给大家。为了同原文保持一致，这一系列文章最终会分成以下五篇：

1. [[http://blog.jobbole.com/49800/][Bash One-Liners Explained 译文（一）: 文件处理]]；
2. [[http://blog.jobbole.com/49843/][Bash One-Liners Explained   译文（二）: 操作字符串]]；
3. Bash One-Liners Explained 译文（三）: 漫谈重定向；
4. Bash One-Liners Explained 译文（四）: 历史命令；
5. Bash One-Liners Explained 译文（五）: 命令行跳转；

本系列的文章同其它系列一样，最终都可以在连载页面找到，有兴趣的同学可以
随意翻翻，看看有没有一些对你有价值的文章，大家一起交流学习。

*** 清空文件内容

#+BEGIN_EXAMPLE
    $ > file
#+END_EXAMPLE

这一行命令用到了输出重定向操作符=>=。输出重定向发生时，文件会被打开准
备写入。如果此时文件不存在则先创建，存在则将其大小截取为0。这里我们并
没有重定向写任何内容到文件中，所以文件依然保持为空。

如果你想替换文件的内容，或者创建一个包含指定内容的文件，可以运行下面的
命令：

#+BEGIN_EXAMPLE
    $ echo "some string" > file
#+END_EXAMPLE

*** 追加内容到文件

#+BEGIN_EXAMPLE
    $ echo "foo bar baz" >> file
#+END_EXAMPLE

这一行命令用到了另外一个输出重定向操作符=>>=，该操作符将内容追加到文件。
同样地，如果文件不存在则先创建它。追加的内容之后，紧跟着换行符。如果你
不想要追加换行符，在执行=echo=命令时可以指定=-n=选项：

#+BEGIN_EXAMPLE
    $ echo -n "foo bar baz" >> file
#+END_EXAMPLE

*** 读取文件的首行并赋值给变量

#+BEGIN_EXAMPLE
    $ read -r line < file
#+END_EXAMPLE

这一行命令用到了 Bash 的内置命令 =read= ，和输入重定向操作符 =<= 。
=read= 命令从标准输入中读取一行，并将内容保存到变量 =line= 中。在这里，
=-r= 选项保证读入的内容是原始的内容，意味着反斜杠转义的行为不会发生。输入重定向
操作符 =< file= 打开并读取文件 =file= ，然后将它作为=read=命令的标准输入。


记住，=read=命令会删除包含在=IFS=变量中出现的所有字符，IFS 的全称是
Internal Field Separator，Bash 根据 IFS
中定义的字符来分隔单词。在这里，=read=命令读入的行被分隔成多个单词。默认情况下，=IFS=包含空格，制表符和回车，这意味着开头和结尾的空格和制表符都会被删除。如果你想保留这些符号，可以通过设置=IFS=为空来完成：

#+BEGIN_EXAMPLE
    $ IFS= read -r line < file
#+END_EXAMPLE

IFS
的变化仅会影响当前的命令，这行命令可以保证读入原始的首行内容到变量=line=中，同时行首与行尾的空白字符被保留。

另外一种读取文件首行内容，并赋值给变量的方法是:

#+BEGIN_EXAMPLE
    $ line=$(head -1 file)
#+END_EXAMPLE

这里用到了命令替换操作符=$(...)=，它运行括号里的命令并且将输出返回。
这个例子中，命令是=head -1 file=，输出的内容是文件的首行。输入然后通过等号赋值给变量=line=。=$(...)=的等价写法是=`...`=，所以也可以换成下面这样：

#+BEGIN_EXAMPLE
    $ line=`head -1 file`
#+END_EXAMPLE

不过，在 Bash
中=$(...)=用法更加推荐，因为它看起来更加整洁，并且容易嵌套使用。

*** TODO 依次读入文件每一行
- State "TODO"       from ""           [2016-01-23 六 01:20] \\
  == 加空格
#+BEGIN_EXAMPLE
    $ while read -r line; do
        # do something with $line
    done < file
#+END_EXAMPLE

这是一种正确的读取文件内容的做法，=read=命令放在=while=循环中。当=read=命令遇到文件结尾时（EOF），它会返回一个正值，导致循环判断失败终止。

记住，=read=命令会删除首尾多余的空白字符，所以如果你想保留，请设置 IFS
为空值:

#+BEGIN_EXAMPLE
    $ while IFS= read -r line; do
        # do something with $line
    done < file
#+END_EXAMPLE

如果你不想将=< file=放在最后，可以通过管道将文件的内容输入到 while
循环中：

#+BEGIN_EXAMPLE
    $ cat file | while IFS= read -r line; do
        # do something with $line
    done
#+END_EXAMPLE

*** 5. 随机读取一行并赋值给变量

#+BEGIN_EXAMPLE
    $ read -r random_line < <(shuf file)
#+END_EXAMPLE

Bash
中并没有提供一种直接的方法来随机读取文件的某一行内容，所以这里需要利用外部程序。在最新的一些
Linux 系统上，GNU Coreutils 包中提供的=shuf=命令可以满足我们的需求。

这一行命令中用到了进程替换（[[http://tldp.org/LDP/abs/html/process-sub.html][process
substitution]]）操作符=<(...)=。进程替换操作会创建一个匿名的管道文件，并将进程命令的标准输出连接到管道的写一端。然后
Bash
开始执行进程替换中的命令，然后将整个进程替换的表达式替换成匿名管道的文件名。

当 Bash
看到=<(shuf file)=时，它首先打开一个特殊的文件=/dev/fd/n=，这里的=n=是一个空闲的文件描述符，然后执行=shuf file=命令，将标准输出连接到=/dev/fd/n=，并且替换=<(shuf file)=
为=/dev/fd/n=，因此实际的命令会变成:

#+BEGIN_EXAMPLE
    $ read -r random_line < /dev/fd/n
#+END_EXAMPLE

结果会读取洗牌后的文件的第一行内容。

另外一种做法是，使用 GNU sort 命令，它提供的=-R=选项可以随机排序文件：

#+BEGIN_EXAMPLE
    $ read -r random_line < <(sort -R file
#+END_EXAMPLE

或者，同前面一样，将结果赋值给变量：

#+BEGIN_EXAMPLE
    $ random_line=$(sort -R file | head -1)
#+END_EXAMPLE

这里，我们首先通过=sort -R=随机排序文件，然后通过=head -1=
读取文件的第一行。

*** 6. 读取文件首行前三个字段并赋值给变量

#+BEGIN_EXAMPLE
    $ while read -r field1 field2 field3 throwaway; do
        # do something with $field1, $field2, and $field3
    done < file
#+END_EXAMPLE

如果在=read=命令中指定多个变量名，它会将读入的内容分隔成多个字段，然后依次赋值给对应的变量，第一个字段赋值给第一个变量，第二个字段赋值给第二个变量，等等，最后将剩余的所有字段赋值给最后一个变量。这也是为什么，在上面的例子中，我们加了一个=throwaway=变量，否则的话，当文件的一行大于三个字段时，第三个变量的内容会包含所有剩余的字段。

有时候，为了书写方便，可以简单地用=_=来替换=throwaway=变量：

#+BEGIN_EXAMPLE
    $ while read -r field1 field2 field3 _; do
        # do something with $field1, $field2, and $field3
    done < file
#+END_EXAMPLE

又或者，如果你的文件确实只有三个字段，那可以忽略它：

#+BEGIN_EXAMPLE
    $ while read -r field1 field2 field3; do
        # do something with $field1, $field2, and $field3
    done < file
#+END_EXAMPLE

下面是一个例子，假如你想知道一个文件到底包含多少行，多少个单词以及多少个字节。当你执行=wc=命令时，你会得到3个数字加上文件名，文件名在最后：

#+BEGIN_EXAMPLE
    $ cat file-with-5-lines
    x 1
    x 2
    x 3
    x 4
    x 5

    $ wc file-with-5-lines
     5 10 20 file-with-5-lines
#+END_EXAMPLE

所以，这个文件包含5行，10个单词，以及20个字符。我们接下来，可以通过=read=命令将这些信息保存到变量中：

#+BEGIN_EXAMPLE
    $ read lines words chars _ < <(wc file-with-5-lines)

    $ echo $lines
    5
    $ echo $words
    10
    $ echo $chars
    20
#+END_EXAMPLE

类似地，你也可以使用
[[http://linux.die.net/abs-guide/x15683.html][here-strings]]
将字符串分隔并保存到变量中。假设你有一个字符串变量=$info=，内容为="20 packets in 10 seconds"=，然后你想要将从中获取=20=和=10=。在不久之前，我是这样来完成的：

#+BEGIN_EXAMPLE
    $ packets=$(echo $info | awk '{ print $1 }')
    $ time=$(echo $info | awk '{ print $4 }')
#+END_EXAMPLE

 

然而，得益于=read=命令的强大和对 Bash 的了解，我们可以这样做：

#+BEGIN_EXAMPLE
    $ read packets _ _ time _ <<< "$info"
#+END_EXAMPLE

这里，=<<<= 就是 here-string 的语法，它允许你直接传递字符串给标准输入。

*** 7. 保存文件的大小到变量

#+BEGIN_EXAMPLE
    $ size=$(wc -c < file)
#+END_EXAMPLE

这一行命令中用到了第3点中介绍的命令替换操作=$(...)=，它运行里面的命令并将结果获取回来。在这个例子中，命令是=wc -c < file=，它输出文件的字节数。这个结果最终会赋值给变量=size=。

*** 8. 从文件路径中获取文件名

假设，你有一个文件，它的路径为=/path/to/file.ext=，然后你要从中获取文件名，在这里是=file.ext=。你要怎么做？
一个好的方法是通过参数展开（[[http://tldp.org/LDP/abs/html/parameter-substitution.html][parameter
expansion]]）功能：

#+BEGIN_EXAMPLE
    $ filename=${path##*/}
#+END_EXAMPLE

这一行命令使用了参数展开的语法：=${var##pattern}=，它从=$var=字符串开始处开始匹配=pattern=。如果能够匹配成功，将最长匹配的内容删除后再返回。

在这个例子中，匹配的模式是=*/=，它尝试匹配=/path/to/file.ext=的开始部分，正如前面所说，这里是贪婪匹配，所以它能够匹配到最后一个斜杠为止，即匹配的内容是=/path/to/=。所以当把匹配的内容删除后，返回的内容就是文件名=file.ext=。

*** 9. 从文件路径中获取目录名

和上面一样类似，这次你要从路径=/path/to/file.txt=中获取目录名=/path/to=。你可以继续通过参数展开功能来完成这个任务：

#+BEGIN_EXAMPLE
    $ dirname=${path%/*}
#+END_EXAMPLE

这次的用法是=${var%pattern}=，它从=$var=的结尾处匹配=/*=。如果能够成功匹配，将最短匹配的内容删除再返回。

在这个例子中，匹配的模式是=/*=，它能够匹配=/file.ext=部分，删除这部分内容后返回的就是目录名称。

*** 10. 快速拷贝文件

假设你要将文件=/path/to/fil=拷贝到=/path/to/file_copy=，一般情况下，大多数人会这么来写：

#+BEGIN_EXAMPLE
    $ cp /path/to/file /path/to/file_copy
#+END_EXAMPLE

不过，你可以利用括号展开（[[http://wiki.bash-hackers.org/syntax/expansion/brace][brace
expansion]]）={...}=功能:

#+BEGIN_EXAMPLE
    $ cp /path/to/file{,_copy}
#+END_EXAMPLE

括号展开可以生成任意字符串的组合，在这个例子中，=/path/to/file{,_copy}=最终生成=/path/to/file /path/to/file_copy=。所以上面这行命令最终发型成:

#+BEGIN_EXAMPLE
    $ cp /path/to/file /path/to/file_copy
#+END_EXAMPLE

类似地，你可以执行下面的命令快速的移动文件：

#+BEGIN_EXAMPLE
    $ mv /path/to/file{,_old}
#+END_EXAMPLE

这行命令展开后就变成了：

#+BEGIN_EXAMPLE
    $ mv /path/to/file /path/to/file_old
#+END_EXAMPLE


** TODO [[http://blog.csdn.net/xiaoweiboy/article/details/6714199][单片机I/O口推挽输出与开漏输出的区别]]
- State "TODO"       from ""           [2016-01-23 六 01:19] \\
  图

推挽输出:可以输出高,低电平,连接数字器件;

开漏输出:输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行.
适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内).

推挽结构一般是指两个三极管分别受两互补信号的控制,总是在一个三极管导通
的时候另一个截止.

我们先来说说集电极开路输出的结构。集电极开路输出的结构如图1所示，右边
的那个三极管集电极什么都不接，所以叫做集电极开路（左边的三极管为反相之
用，使输入为“0”时，输出也为“0”）。对于图1，当左端的输入为“0”时，
前面的三极管截止（即集电极C跟发射极E之间相当于断开），所以5V电源通过1K
电阻加到右边的三极管上，右边的三极管导通（即相当于一个开关闭合）；当左
端的输入为“1”时，前面的三极管导通，而后面的三极管截止（相当于开关断
开）。


[[http://www.eetop.cn/blog/attachments/2006/11/20061121_db31d8cfd1b54c04acd481b012275d2b.jpg]]


我们将图1简化成图2的样子。图2中的开关受软件控制，“1”时断开，“0”时闭合。很明显可以看出，当开关闭合时，输出直接接地，所以输出电平为0。而当开关断开时，则输出端悬空了，即高阻态。这时电平状态未知，如果后面一个电阻负载（即使很轻的负载）到地，那么输出端的电平就被这个负载拉到低电平了，所以这个电路是不能输出高电平的。

再看图三。图三中那个1K的电阻即是上拉电阻。如果开关闭合，则有电流从1K电阻及开关上流过，但由于开关闭[[http://hi.baidu.com/tracyao/blog/item/file::;][其它]]三个口带内部上拉），当我们要使用输入功能时，只要将输出口设置为1即可，这样就相当于那个开关断开，而对于P0口来说，就是高阻态了。

对于漏极开路（OD）输出，跟集电极开路输出是十分类似的。将上面的三极管换成场效应管即可。这样集电极就变成了漏极，OC就变成了OD，原理分析是一样的。

另一种输出结构是推挽输出。推挽输出的结构就是把上面的上拉电阻也换成一个开关，当要输出高电平时，上面的开关通，下面的开关断；而要输出低电平时，则刚好相反。比起OC或者OD来说，这样的推挽结构高、低电平驱动能力都很强。如果两个输出不同电平的输出口接在一起的话，就会产生很大的电流，有可能将输出口烧坏。而上面说的OC或OD输出则不会有这样的情况，因为上拉电阻提供的电流比较小。如果是推挽输出的要设置为高阻态时，则两个开关必须同时断开（或者在输出口上使用一个传输门），这样可作为输入状态，AVR单片机的一些IO口就是这种结构。

 

开漏电路特点及应用

      在电路设计时我们常常遇到开漏（open drain）和开集（open
collector）的概念。

　　所谓开漏电路概念中提到的“漏”就是指MOSFET的漏极。同理，开集电路中的“集”就是指三极管的集电极。开漏电路就是指以MOSFET的漏极为输出的电路。一般的用法是会在漏极外部的电路添加上拉电阻。完整的开漏电路应该由开漏器件和开漏上拉电阻组成。如图1所示：  

[[http://www.cheluck.com/Article/UploadFiles/200706/20070614000913601.jpg][[[http://img.blog.163.com/photo/CWrVHp5T2Rn_gMeauvIbwA==/5385742204382260745.jpg]]]]

                                图1

 组成开漏形式的电路有以下几个特点：
        1.
利用外部电路的驱动能力，减少IC内部的驱动（或驱动比芯片电源电压高的负载）。当IC内部MOSFET导通时，驱动电流是从外部的VCC流经R
pull-up ，MOSFET到GND。IC内部仅需很下的栅极驱动电流。如图1。

2. 可以将多个开漏输出的Pin，连接到一条线上。形成 “与逻辑”
关系。如图1，当PIN\_A、PIN\_B、PIN\_C任意一个变低后，开漏线上的逻辑就为0了。这也是I2C，SMBus等总线判断总线占用状态的原理。如果作为输出必须接上拉电阻。接容性负载时，下降延是芯片内的晶体管，是有源驱动，速度较快；上升延是无源的外接电阻，速度慢。如果要求速度高电阻选择要小，功耗会大。所以负载电阻的选择要兼顾功耗和速度。
        3. 可以利用改变上拉电源的电压，改变传输电平。如图2,
IC的逻辑电平由电源Vcc1决定，而输出高电平则由Vcc2（上拉电阻的电源电压）决定。这样我们就可以用低电平逻辑控制输出高电平逻辑了（这样你就可以进行任意电平的转换）。（例如加上上拉电阻就可以提供TTL/CMOS电平输出等。）

[[http://www.cheluck.com/Article/UploadFiles/200706/20070614000913790.jpg][[[http://img.blog.163.com/photo/EIqHbVf0m6bd6V2z3VX4iA==/5385742204382260744.jpg]]]]

      图2

4.
开漏Pin不连接外部的上拉电阻，则只能输出低电平(因此对于经典的51单片机的P0口而言，要想做输入输出功能必须加外部上拉电阻，否则无法输出高电平逻辑)。一般来说，开漏是用来连接不同电平的器件，匹配电平用的。
        5.
标准的开漏脚一般只有输出的能力。添加其它的判断电路，才能具备双向输入、输出的能力。

      
 6.正常的CMOS输出级是上、下两个管子，把上面的管子去掉就是OPEN-DRAIN了。这种输出的主要目的有两个：电平转换、线与。

7.线与功能主要用于有多个电路对同一信号进行拉低操作的场合，如果本电路不想拉低，就输出高电平，因为OPEN-DRAIN上面的管子被拿掉，高电平是靠外接的上拉电阻实现的。（而正常的CMOS输出级，如果出现一个输出为高另外一个为低时，等于电源短路。）

8.OPEN-DRAIN提供了灵活的输出方式，但是也有其弱点，就是带来上升沿的延时。因为上升沿是通过外接上拉无源电阻对负载充电，所以当电阻选择小时延时就小，但功耗大；反之延时大功耗小。所以如果对延时有要求，则建议用下降沿输出。

应用中需注意：
              1.  
开漏和开集的原理类似，在许多应用中我们利用开集电路代替开漏电路。例如，某输入Pin要求由开漏电路驱动。则我们常见的驱动方式是利用一个三极管组成开集电路来驱动它，即方便又节省成本。如图3。

[[http://www.cheluck.com/Article/UploadFiles/200706/20070614000913809.jpg][[[http://img.blog.163.com/photo/X_TpSikFBZLkYIzLqNZR1A==/5385742204382260743.jpg]]]]

              2. 上拉电阻R
pull-up的阻值决定了逻辑电平转换的沿的速度。阻值越大，速度越低功耗越小。反之亦然。

   
Push-Pull输出就是一般所说的推挽输出，在CMOS电路里面应该较CMOS输出更合适，因为在CMOS里面的push－pull输出能力不可能做得双极那么大。输出能力看IC内部输出极N管P管的面积。和开漏输出相比，push－pull的高低电平由IC的电源低定，不能简单的做逻辑操作等。push－pull是现在CMOS电路里面用得最多的输出级设计方式。

当然open
drain也不是没有代价，这就是输出的驱动能力很差。输出的驱动能力很差的说法不准确，驱动能力取决于IC中的末级晶体管功率。OD只是带来上升沿的延时，因为上升沿是通过外接上拉无源电阻对负载充电的，当电阻选择小时延时就小、但功耗大，反之延时大功耗小。OPEN
DRAIN提供了灵活的输出方式，但也是有代价的，如果对延时有要求，建议用下降沿输出。

电阻小延时小的前提条件是电阻选择的原则应在末级晶体管功耗允许范围内，有经验的设计者在使用逻辑芯片时，不会选择1欧姆的电阻作为上拉电阻。在脉冲的上升沿电源通过上拉无源电阻对负载充电，显然电阻越小上升时间越短，在脉冲的下降沿，除了负载通过有源晶体管放电外，电源也通过上拉电阻和导通的晶体管对地
形成通路，带来的问题是芯片的功耗和耗电问题。电阻影响上升沿，不影响下降沿。如果使用中不关心上升沿，上拉电阻就可选择尽可能的大点，以减少对地通路的
电流。如果对上升沿时间要求较高，电阻大小的选择应以芯片功耗为参考。

** fd
** [[http://kodango.com/shell-script-style][Shell 编码风格]]

[[http://wiki.bash-hackers.org/scripting/style][Scripting with style]] 是少见的一篇介绍 Shell 编码风格的文章，相信对大多
数运维人员有用，现在将译文献上。

*** 缩进准则

我一般使用2个空格来缩进（尽管大多人使用4个空格），原因是：

-  输入简单快速；
-  没有输入一个Tab键，避免不同环境下显示的差异问题；
-  缩进的效果已经足够，并且没有浪费太多的空间；

#+BEGIN_QUOTE
  译者注：本人也是使用4个空格，如果你也与本文作者的风格不一样，下面说到2个空格的地方请自觉替换成你实际使用的空格数。个人认为，缩进只是一个个人的风格，只要不影响可读性即可。
#+END_QUOTE

顺便说一句，尽量不要使用Tab键，它们容易带来麻烦，我只能想到一种情况下它是有用的：here
document中的缩进。

**** 分隔长行

如果需要分隔过长的代码，你可以使用下面的任意一种方法：

1） 使用与命令宽度相同的缩进

#+BEGIN_EXAMPLE
    activate some_very_long_option \
             some_other_option
#+END_EXAMPLE

2） 使用2个空格缩进

#+BEGIN_EXAMPLE
    activate some_very_long_option \
      some_other_option
#+END_EXAMPLE

从个人的角度来说，除非有特别的需要，我更倾向于第一种形式，因为它突出“上下两行的内容是一起的”这一联系。

**** 分离复合命令

#+BEGIN_QUOTE
  译者注：其实这里的复合命令就是指块语句，例如for/while循环,
  if分支结构等等。
#+END_QUOTE

#+BEGIN_EXAMPLE
    HEAD_KEYWORD parameters; BODY_BEGIN
      BODY_COMMANDS
    BODY_END
#+END_EXAMPLE

我习惯于：

-  将HEAD\_KEYWORD和初始化命令或者参数放在第一行；
-  将BODY\_BEGIN同样放在第一行；
-  复合命令中的BODY部分以2个空格缩进；
-  BODY\_END部分独立一行放在最后；

1）if/then/elif/else分支语句

#+BEGIN_EXAMPLE
    if ...; then
      ...
    elif ...; then
      ...
    else
      ...
    fi
#+END_EXAMPLE

2）for循环

#+BEGIN_EXAMPLE
    for f in /etc/*; do
      ...
    done
#+END_EXAMPLE

3） while/until循环

#+BEGIN_EXAMPLE
    while [[ $answer != [YyNn] ]]; do
      ...
    done
#+END_EXAMPLE

4） case分支语句

#+BEGIN_EXAMPLE
    case $input in
      hello)
        echo "You said hello"
      ;;
      bye)
        echo "You said bye"
        if foo; then
          bar
        fi
      ;;
      *)
        echo "You said something weird..."
      ;;
    esac
#+END_EXAMPLE

几点注意的地方：

-  如果不是100%需要，匹配部分左右的括号不需要写（*译者注：例如写成hello)而不是(hello)*）；
-  匹配模式与分支的终止符号;;位于同一缩进级别
-  分支内部的命令多缩进一层；
-  尽管是可选的，这里还是把最后一个分支的终止符号也写上了；

*** 语法和编码指引

**** 晦涩的语法结构

我们都喜欢一些晦涩的语法结构，因为它们很简洁。但是如果不是100%需要用到，尽量不要使用它们，否则大多数人无法理解你的代码。

所以有有时候，我们需要在代码的智能，效率与可读性之间找到一个平衡点。

如果你一定要使用这种语法结构，记得在用的地方写上一小段注释。

#+BEGIN_QUOTE
  译者注：Shell提供的一些语法糖很难理解，但是有非常简洁实用，本人也很喜欢用，这样可以省下一大堆精力，而且用熟了也没有什么难以理解的，但是作者说的也有道理，这一点就仁者见仁，智者见智了
#+END_QUOTE

**** 变量名

因为所有保留的变量名都是大写的，最安全的方法是仅使用小写字母作为变量名，例如读入用户的输入、循环变量等等......：

-  变量名尽量选择小写字母；
-  如果你使用大写的变量名，不要使用保留的变量名（一份不完全的列表参见[[http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08][SUS]]）；
-  如果你使用大写的变量名，最后在变量名前面加一个独特的前缀（例如下面例子中的MY\_）；

下面是一个例子：

#+BEGIN_EXAMPLE
    #!/bin/bash

    # the prefix 'MY_'
    MY_LOG_DIRECTORY=/var/adm/

    for file in "$MY_LOG_DIRECTORY"/*; do
      echo "Found Logfile: $file"
    done
#+END_EXAMPLE

**** 变量初始化

正如C语言一样，最好的处理是在变量声明的时候初始化。

用户可以将一个变量以环境变量的形式传递到脚本中。如果你盲目地假定你使用的所有变量都是未初始化的，其它人可以以环境变量的形式劫持一个变量。

#+BEGIN_QUOTE
  译者注：一个例子说明这一点：

  #+BEGIN_EXAMPLE
      $ cat b.sh

      if [ -z "$var" ]; then
          echo "$var is not set"
          var=1
      fi

      echo "Now, var is equals to $var"
      var=2 sh b.sh
      Now, var is equals to 2
  #+END_EXAMPLE
#+END_QUOTE

解决这个问题的方法很简单，将变量初始化：

#+BEGIN_EXAMPLE
    my_input=""
    my_array=()
    my_number=0
#+END_EXAMPLE

**** 参数展开

除非你知道自己做的事情，*请在参数展开的地方使用双引号*

当然，也有一些地方并不需要使用双引号，例如：

-  [[ ]]测试表达式内部是不会展开的；
-  在case $WORD in语法中WORD也不会展开的；
-  在变量赋值var=$WORD的地方也是不会展开的

但是在这些地方使用引号并不会出错，如果你习惯于在每个可能展开参数的地方使用引号，你写得代码会很安全。

如果你要传递一个参数作为一个单词列表，你可以不使用引号，例如：

#+BEGIN_EXAMPLE
    list="one two three"

    # you MUST NOT quote $list here
    for word in $list; do
      ...
    done
#+END_EXAMPLE

**** 函数名称

函数名称应该采用小写的形式，并且有一个很好的意义。函数名称应该容易让人理解，比如f1这个名称虽然容易输入但是对调试和其它人阅读代码造成了很大的困难，它说明不了任何东西。好的函数名称可以帮助说明代码，而不需要额外的注释。

一个或多或少有趣的是：如果你无意这样做，不要把函数名称命名为常见的命令名，新手往往比较容易将脚本或者函数名命名成test，这样就和UNIX的test命令冲突了。

除非绝对必要，仅使用字母、数字和下划线作为函数名称。+/bin/ls也是一个合法的Bash函数名称。+

#+BEGIN_QUOTE
  译者注：/bin/ls不是一个合法的函数名称。
#+END_QUOTE

**** 命令替换

正如文章[[http://wiki.bash-hackers.org/syntax/expansion/cmdsubst][the
article about command substitution [Bash Hackers
Wiki]]]中提及的，你应该使用$( .. )形式。

不过，如果可移植性是一个问题，你可能必须使用反引号的形式`...`。

在任何情况，如果其它展开或者单词分隔并不是你期望的，你应该将命令替换用双引号引起来。

**** Eval命令

正如Greg据说的：“If eval is the answer, surely you are asking the wrong
question.”。

避免它，除非绝对必要：

-  eval can be your neckshot（可能是你的麻烦？）
-  很有可能有其它的方法来实现你需要的；
-  如果可能，重新思考下脚本的工作过程，当eval的使用不可避免的时候；
-  如果你实在需要使用，小心慎用；

*** 脚本的基本结构

一个脚本的基本结构是这样的：

#+BEGIN_EXAMPLE
    #!SHEBANG

    CONFIGURATION_VARIABLES

    FUNCTION_DEFINITIONS

    MAIN_CODE
#+END_EXAMPLE

**** Shebang

如果可能，请不要忘记shebang。

请小心使用/bin/sh作为shebang，在Linux系统中，/bin/sh就是Bash这是一个错误的观点。

于我而言，shebang有两个目的：

-  说明直接执行时以哪个解释器来执行；
-  明确该脚本应该以哪个解释器来执行；

**** 配置变量

在这里，我将这一类变量------可以被用户更改的------叫做配置变量。

让这类变量容易找到，一般放在脚本的头部，给它们有意义的名称并且加上注释说明。正如上面说的，仅当你知道你为什么这么做的时候，才用大写的变量名形式，否则小写形式更加安全。

**** 函数定义

所有函数定义应该在脚本主要代码执行之前，这样可以给人全局的印象，并且确保所有函数在使用之前它是已知的。

你应该使用可移植性高的函数定义形式，即不带function关键字的形式。

*** 脚本行为和健壮性

-  当脚本检测到问题时尽早退出，以免执行潜在的问题；
-  如果你需要用到的命令可能并没有安装在系统上，在脚本执行的时候最好检查命令是否存在并且提醒用户缺少什么；
-  采用有意义的脚本返回值，例如0代码成功，1代码错误或者失败；

*** 其它

**** 输出内容

-  if the script is interactive, if it works for you and if you think
   this is a nice feature, you can try to
   [[http://wiki.bash-hackers.org/snipplets/screen_saverestore][save the
   terminal content and restore it]] after
   execution；（译者注：不理解这一点是什么意思）
-  在屏幕中输出简单易理解的消息；
-  使用颜色或者特别的前缀区分错误和警告信息；
-  输出正常的内容到STDOUT，而输出错误、警告或者诊断的信息到STDERR；
-  在日志文件中输出所有详细的信息；

**** 输入

不要盲目地假设任何事情，如果你希望用户输入一个数字，请在脚本中主动检查它是否真得是一个数字，检查头部是否包含0，等等。我们都应该知道这一点，用户仅仅是用户而不是程序员，他们会做他们想要的，而不是程序想要的。

** [[http://teliute.org/linux/abs-3.9.1/unofficialst.html][非官方的Shell脚本编写风格]]

-  习惯性的注释你的代码.
   这可以让别人更容易看懂(或者感激)你的代码(译者注: 犯错时,
   别人也会靠注释找到你), 而且也更便于维护.

   | #+BEGIN_EXAMPLE                                                                              |
   |       1 PASS="$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}"                                      |
   |       2 # 去年你写下这段代码的时候, 你非常了解这段代码的含义, 但现在它对你来说完全是个谜.    |
   |       3 # (摘自Antek Sawicki的"pw.sh"脚本.)                                                  |
   | #+END_EXAMPLE                                                                                |


   给脚本和函数加上描述性的头信息.

   | #+BEGIN_EXAMPLE                                                         |
   |       1 #!/bin/bash                                                     |
   |       2                                                                 |
   |       3 #************************************************#              |
   |       4 #                   xyz.sh                       #              |
   |       5 #           written by Bozo Bozeman              #              |
   |       6 #                July 05, 2001                   #              |
   |       7 #                                                #              |
   |       8 #           Clean up project files.              #              |
   |       9 #************************************************#              |
   |      10                                                                 |
   |      11 E_BADDIR=65                       # 没有这个目录.               |
   |      12 projectdir=/home/bozo/projects    # 想要清除的目录.             |
   |      13                                                                 |
   |      14 # --------------------------------------------------------- #   |
   |      15 # cleanup_pfiles ()                                         #   |
   |      16 # 删除指定目录中的所有文件.                                 #   |
   |      17 # Parameter: $target_directory                              #   |
   |      18 # 返回值: 0表示成功, 失败返回$E_BADDIR.                     #   |
   |      19 # --------------------------------------------------------- #   |
   |      20 cleanup_pfiles ()                                               |
   |      21 {                                                               |
   |      22   if [ ! -d "$1" ]  # Test if target directory exists.          |
   |      23   then                                                          |
   |      24     echo "$1 is not a directory."                               |
   |      25     return $E_BADDIR                                            |
   |      26   fi                                                            |
   |      27                                                                 |
   |      28   rm -f "$1"/*                                                  |
   |      29   return 0   # Success.                                         |
   |      30 }                                                               |
   |      31                                                                 |
   |      32 cleanup_pfiles $projectdir                                      |
   |      33                                                                 |
   |      34 exit 0                                                          |
   | #+END_EXAMPLE                                                           |


   在脚本开头添加任何注释之前,
   一定要确保/#!/bin/bash/放在脚本第一行的开头.

-  避免使用"魔法数字", [[#FTN.AEN15556][[1]]] 也就是,
   避免"写死的"字符常量. 可以使用有意义的变量名来代替.
   这使得脚本更易于理解, 并且允许在不破坏应用的情况下进行修改和更新.

   | #+BEGIN_EXAMPLE                                                       |
   |       1 if [ -f /var/log/messages ]                                   |
   |       2 then                                                          |
   |       3   ...                                                         |
   |       4 fi                                                            |
   |       5 # 一年以后, 你决定修改这个脚本, 让它来检查/var/log/syslog.    |
   |       6 # 到时候你就必须一行一行的手动修改这个脚本,                   |
   |       7 # 并且寄希望于没有遗漏的地方.                                 |
   |       8                                                               |
   |       9 # 更好的办法是:                                               |
   |      10 LOGFILE=/var/log/messages  # 只需要改动一行就行了.            |
   |      11 if [ -f "$LOGFILE" ]                                          |
   |      12 then                                                          |
   |      13   ...                                                         |
   |      14 fi                                                            |
   | #+END_EXAMPLE                                                         |


-  给变量和函数起一些有意义的名字.

   | #+BEGIN_EXAMPLE                                                                   |
   |       1 fl=`ls -al $dirname`                 # 含义模糊.                          |
   |       2 file_listing=`ls -al $dirname`       # 更好的名字.                        |
   |       3                                                                           |
   |       4                                                                           |
   |       5 MAXVAL=10   # 使用变量来代替脚本常量, 并且在脚本中都是用这个变量.         |
   |       6 while [ "$index" -le "$MAXVAL" ]                                          |
   |       7 ...                                                                       |
   |       8                                                                           |
   |       9                                                                           |
   |      10 E_NOTFOUND=75                        #  错误码使用大写,                   |
   |      11                                      #+ 并且命名的时候用"E_"作为前缀.     |
   |      12 if [ ! -e "$filename" ]                                                   |
   |      13 then                                                                      |
   |      14   echo "File $filename not found."                                        |
   |      15   exit $E_NOTFOUND                                                        |
   |      16 fi                                                                        |
   |      17                                                                           |
   |      18                                                                           |
   |      19 MAIL_DIRECTORY=/var/spool/mail/bozo  # 环境变量名使用大写.                |
   |      20 export MAIL_DIRECTORY                                                     |
   |      21                                                                           |
   |      22                                                                           |
   |      23 GetAnswer ()                         # 函数名采用大小写混合的方式.        |
   |      24 {                                                                         |
   |      25   prompt=$1                                                               |
   |      26   echo -n $prompt                                                         |
   |      27   read answer                                                             |
   |      28   return $answer                                                          |
   |      29 }                                                                         |
   |      30                                                                           |
   |      31 GetAnswer "What is your favorite number? "                                |
   |      32 favorite_number=$?                                                        |
   |      33 echo $favorite_number                                                     |
   |      34                                                                           |
   |      35                                                                           |
   |      36 _uservariable=23                     # 语法上可以这么起名, 但是不推荐.    |
   |      37 # 用户定义的变量名最好不要以下划线开头.                                   |
   |      38 # 因为以下划线开头的变量, 一般都保留, 作为系统变量.                       |
   | #+END_EXAMPLE                                                                     |


-  [[exit-status.html#EXITCOMMANDREF][退出码]]最好也采用具有系统性的或有意义的命名方式.

   | #+BEGIN_EXAMPLE              |
   |       1 E_WRONG_ARGS=65      |
   |       2 ...                  |
   |       3 ...                  |
   |       4 exit $E_WRONG_ARGS   |
   | #+END_EXAMPLE                |


   也请参考[[exitcodes.html][Appendix D]].

   /最后/, 我们建议采用=/usr/include/sysexits.h=中的定义作为退出码,
   虽然这些定义主要用于C/C++编程语言.

-  在脚本调用中使用标准化的参数标志. /最后/, 我们建议使用下面的参数集.

   | #+BEGIN_EXAMPLE                                                        |
   |       1 -a      全部: 返回全部信息(包括隐藏的文件信息).                |
   |       2 -b      摘要: 缩减版本, 通常用于其它版本. 通常用于其它脚本.    |
   |       3 -c      拷贝, 连接, 等等.                                      |
   |       4 -d      日常的: 使用全天的信息,                                |
   |       5         而不仅仅是特定用户或特定实例的信息.                    |
   |       6 -e      扩展/详细描述: (通常不包括隐藏文件信息).               |
   |       7 -h      帮助: 详细的使用方法, 附加信息, 讨论, 帮助.            |
   |       8         也请参考-V.                                            |
   |       9 -l      打印出脚本的输出记录.                                  |
   |      10 -m      手册: 显示基本命令的man页.                             |
   |      11 -n      数字: 仅使用数字数据.                                  |
   |      12 -r      递归: 这个目录中所有的文件(也包含所有子目录).          |
   |      13 -s      安装&文件维护: 这个脚本的配置文件.                     |
   |      14 -u      用法: 列出脚本的调用方法.                              |
   |      15 -v      详细信息: 只读输出, 或多或少的会做一些格式化.          |
   |      16 -V      版本/许可/版权Copy(right|left)/捐助(邮件列表).         |
   | #+END_EXAMPLE                                                          |


   也请参考[[standard-options.html][Section F.1]].

-  将一个复杂脚本分割成一些简单的模块. 使用合适的函数来实现模块的功能.
   请参考[[bashver2.html#EX79][例子 34-4]].

-  如果有更简单的结构可以使用的话, 就不要使用复杂的结构.

   | #+BEGIN_EXAMPLE                            |
   |       1 COMMAND                            |
   |       2 if [ $? -eq 0 ]                    |
   |       3 ...                                |
   |       4 # 多余, 而且不好理解.              |
   |       5                                    |
   |       6 if COMMAND                         |
   |       7 ...                                |
   |       8 # 更简练(可能会损失一些可读性).    |
   | #+END_EXAMPLE                              |


|     | //                                                                                                                                                                                        |
|     | /... 当我阅读UNIX中Bourne shell (/bin/sh)部分的源代码时. 我被震惊了, 有多少简单的算法被恶心的编码风格弄得令人看不懂, 并且因此变得没用. 我问我自己, "有人会对这种代码感到骄傲和自豪么?"/   |
|     | /Landon Noll/                                                                                                                                                                             |

*** 注意事项

| [[unofficialst.html#AEN15556][[1]]]   | 在这种上下文中所说的"魔法数字"与用来指明文件类型的[[sha-bang.html#MAGNUMREF][魔法数字]], 在含义上完全不同.   |

** [[http://www.linuxidc.com/Linux/2013-06/85747.htm][用GParted-LiveCD进行Ubuntu分区大小的调整]]

一、准备

1、下载最新版本的gparted镜像文件：点击这里。

2、将gparted镜像文件刻录成光盘或压制在U盘上制成LiveUSB

3、虽说是无损调整，但为了安全起见(万一停电咋办？)，建议备份重要数据到移动硬盘上

4、在BIOS中，将启动顺序设置为首先光驱启动(如果是用LiveUSB，应设为USB-HDD)

二、调整分区

1、将光盘放入光驱(如果是用LiveUSB，插上U盘)，重启电脑

2、进入gparted启动界面，直接选Defalt settings

3、第二个界面继续按回车

4、接下来选语言，输入“26”回车(就是简体中文，尽管汉化不全)

5、接着提示将要进入X-Windows界面，回车

6、进入gparted，就会发现和瘟到死的PQ相似的界面，实际操作也是一样的，而且也支持瘟到死分区的调整

7、点击你要腾出空间的分区，弹出右键菜单选择“Resize/Move”

8、用鼠标托动或数字精确调整要释放的空间大小，若要释放在分区头部拉左侧的控制条(输入第一行数值)，若要释放在分区尾部拉右侧的控制条(输入第三行数值),调整好之后点“更改大小/移动”按钮。

9、点击欲扩大容量的分区，弹出右键菜单选择“Resize/Move”

10、按照第8步的方法操作，只是现在变成扩大分区容量而已

11、点击“Edit”菜单，选择“Apply All Operations”

12、再次确认要调整分区容量后，gparted开始调整分区，完成后点“Close”按钮

13、点“gparted”菜单，选“Quit”关闭gparted窗口，再双击左上角的“Exit”按钮退出gparted系统

14、在弹出的窗口中选“Reboot”重启电脑，退出时系统会提示你取出光盘

三、可能存在的问题

可能会发生swap分区丢失的情况，可在终端中用“free -m”命令查看swap分区是否激活(是否显示容量)，如果未激活，可用“sudo mkswap /dev/sdaX”命令(X为swap分区的编号)进行激活，并将激活所得的UUID码替换掉“/etc/fstab”文件(需要管理员权限)中原来 swap分区的UUID编码，重启后即可自动激活挂载

警告：对swap分区的激活操作及对fstab文件的修改应谨慎，必需仔细核对修改的值

** [[http://www.linuxidc.com/Linux/2010-05/26118.htm][Ubuntu下硬盘安装Windows 7]]

此前在Ubuntu下用virtualbox装了份Windows 7，确实比以往的Windows好用许多。于是花了点时间把机子上原来与Ubuntu并存的Windows XP升级成Windows 7。

所需工具、文件
Windows 7安装镜像;
我下载的是7600.16385.090713-1255_x64fre_client_zh-cn_Retail_Ultimate-GRMCULXFRER_CN_DVD.iso,3.1G。
Grub4Dos
用于引导Windows安装，后来听说Grub2也行，还要更方便一些，但我没可能再装一遍，以下还是以grub4dos为例;
EasyBCD
用于在Windows安装完成后找回启动Ubuntu的菜单.

备份MBR
$ sudo dd if=/dev/sda of=/backup/mbr.img bs=512 count=1

至关重要。Ubuntu的安装过程会保留Windows启动项，但Windows的安装过程却很霸道，安装后需导入MBR才能找回Ubuntu启动项。
Windows下无法访问Ubuntu里的文件，所以需要把这个备份文件复制到Windows文件系统下，或则先用U盘备份。

挂载Windows 7 ISO
$ sudo mount /iso/7600.16385.090713-1255_x64fre_client_zh-cn_Retail_Ultimate-GRMCULXFRER_CN_DVD.iso /mnt -o loop
即把Windows 7 ISO挂载到/mnt，打开这个目录，把里边的所有文件复制到一个NTFS分区的根目录下——不能是将用于安装Windows 7的分区，亦即，需要预先准备两个Windows分区。

我这里因为原本就是Windows与Ubuntu并存，Windows下有C、D、E盘，C盘准备用来安装Windows 7，以上安装文件就复制到了E盘根目录下。

添加启动菜单
打开载下来的Grub4dos.zip，把其中的grub.exe解压出来。
修改/boot/grub/menu.lst,添加如下几行

title grub4dos
root (hd0,3)
kernel /home/grub.exe
boot

第二行的0,3需根据实际情况修改，可查看menu.lst里原有的部分，找到Ubuntu的选项复制成一样的即可。
如我原有启动项第一项是:

title Ubuntu 9.10, kernel 2.6.31-16-generic
root (hd0,3)

第三行的/home/grub.exe需修改成刚解压出的grub.exe所在路径。

重启安装
重启，在操作系统选单里选择grub4dos，屏幕一闪再度进入操作系统选单，按c进入命令行grub>，依次输入以下指令：

grub>find --set-root /bootmgr
grub>chainloader /bootmgr
grub>boot

随即进入Windows 7安装引导界面，一路装下去即可。

恢复MBR
Windows安装完成后，多系统选单不见了，此时需要恢复MBR。我安装前在网上找到的几篇文章里有指明，可以在Windows下以如下指令恢复：
echo c:\"linux.lnx"=linux >> boot.ini
遗憾的是Windows 7里好像根本就没有boot.ini，试了一下，此法无效。

无奈只好用下了一份easyBCD，安装之后运行，添加LINUX启动项。C盘下会生成c:\nst\nst_linux.mbr文件，删除之，把此前备份的mbr.img复制到这个位置，重命名为nst_linux.mbr。

重启在多系统选单选择linux选项，即可看见原来的Ubuntu多系统选单。进入Ubuntu之后，再彻底还原MBR。
$ sudo dd if=/backup/mbr.img of=/dev/sda bs=446 count=1

** [[http://purpletulipdyc.blog.sohu.com/259698858.html][LaTeX 引用多个参考文献]]

如果在文章中出现连续引用多个参考文献的情况，希望显示的格式为 [1-9]
在文章的导言区加
\usepackage{cite}

在文章正文中需要引用参考文献的地方使用：
\cite{liu2012, wen13,wang2010VTC,shen2008ICC,Alex2007ICC}

** [[http://blog.csdn.net/hansoft/article/details/1502859][emacs encoding,font]]

*** encoding

如果emacs识别的编码是错误的，可以用C-x <RET> r CODING-SYSTEM来重新指定

emacs在内部使用它自己的coding system，在读入文件时把该文件使用的coding
system转换为内部使用的coding sytem，在写入文件时把内部使用的coding
system转换为该文件使用的coding system。

*** 字体

emacs用fontset指定字体。一个fontset对一组script分别指定字体。用create-fontset-from-fontset-spec来创建fontset：

#+BEGIN_EXAMPLE
    (create-fontset-from-fontset-spec  (concat   "-outline-Courier New-normal-r-*-*-18-*-*-*-c-*-fontset-gbk,"   "han:-outline-新宋体-normal-r-*-*-18-*-*-*-c-*-iso10646-1"))
#+END_EXAMPLE

fontset-gbk就是新创建的fontset的名字，当一个frame使用该fontset作为其font属性，该frame的default
font name就是用iso8859-1替换该fontset名字而得到的字体名。

han是一个script
name，为了向后兼容，也可以使用charset名，emacs通过变量charset-script-alist来映射charset到script

用set-fontset-font来增加或修改某个fontset，如：

(set-fontset-font "fontset-gbk" 'han
"-outline-新宋体-normal-r-/-/-18-/-/-/-c-/-iso10646-1")

最后用

(set-default-font "fontset-gbk")

来指定使用该fontset

**** tips

(frame-parameter <frame>
'font)得到指定<frame>的fontset名，若<frame>为nil则为当前选择的frame

*** language environment

对于像unicode这种国际化的编码，某些字符是多个script共用的(比如中、日、韩在unicode里就共用了一些字符)，如果判断这种字符的所属的script有误，就会出现不期望的结果：

在LC\_CTYPE为非中文locale的情况下，使用UTF-8 language
environment，打开一个包含“笔记”两字的utf-8编码的文件，“笔”字将会显示为一个方框(在没有安装日文字体的情况下)。

这个“笔”字就被emacs判断为日语的字符，而我们没有日文字体，所以就显示为了一个方框。

你必须告诉把你的语言信息告诉emacs，这可以通过以下方式：

-  locale：设置LC\_CTYPE=zh\_CN就能解决上面的问题
-  emacs的language
   environment：如果你不想改变locale，可以改变emacs的language
   environment，事实上language
   environment就是为此目的设立的，改变locale的方法实际上也是间接改变language
   environment---当没有指定language
   enviroment时，emacs会根据当前的locale推测一个language
   environment，这在LC\_CTYPE=zh\_CN的locale下推测的结果是Chinese-GB，正是我们想要设置的。

    

language environment还给一些编码相关的变量设置默认值，比较重要的有：

-  优先编码列表
   当读入一个文件时，以该列表的顺序来识别文件的编码，用prefer-coding-system在该列表首插入一个编码
-  default-buffer-file-coding-system 新建文件的默认编码

    

C-h L来查看当前或其他language environment的信息，使用M-x
set-lanaguage-environment来修改。

C-h C查看指定的coding system，如果不指定参数则显示当前所有的coding
system设置，包括优先编码列表

**** troubles

在en\_US.UTF-8下推测的language
environment是UTF-8，按理说这时相关的编码变量应该也被设置为UTF-8 language
environment设置的默认值，不过在我的环境下这些变量的值似乎和UTF-8
language environment无关，于是不得不在.emacs下明确设置一下：

#+BEGIN_EXAMPLE
      (if (equal current-language-environment "UTF-8")       (prefer-coding-system 'gb2312)    (prefer-coding-system 'Utf-8)       )      )   )   (add-hook 'set-language-environment-hook 'utf8gbk)   (set-lanaguage-environment 'UTF-8)
#+END_EXAMPLE

在UTF-8这个language
environment下，emacs并不能自动识别gbk编码的文件，因为其缺省设置的优先编码列表没有gbk，上面的lisp对UTF-8
language
environment做了定制，之所以又加了一次utf-8编码是因为希望在UTF-8这个language
environment下首选的编码是utf-8。

*** tips

用C-u C-x =(describe char)查看buffer中某个字符的信息

** [[https://blogs.cs.st-andrews.ac.uk/jfdm/2013/04/04/documenting-python-using-doxygen/][Documenting Python using Doxygen]]

April 4th, 2013
[[https://blogs.cs.st-andrews.ac.uk/jfdm/author/jfdm/][jfdm]]
[[#respond][Leave a comment]] [[#comments][Go to comments]]

On and off I have been developing a little Python module to provide
KP-ABE and CP-ABE functionality to developers. One important aspect is
that of documentation. Any decent project needs to provide both User and
Developer documentation. User documentation is outward facing and tells
users how to use the project, and Developer documentation is inward
facing and tells developers how the project is structured. Developer
documentation is also know as reference documentation. Interestingly,
user documentation can be further divided into two groups: User---for
when the user is just a ‘plain-dumb-user'; and Dev-User---when the
project produces something for use by other developers i.e. an library.
Often Dev-User documentation is just reference documentation. This post
is concerned with reference documentation.

For documenting API's and libraries different languages have different
tools:

-  Java has
   [[http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html][Javadoc]],
   and [[http://www.stack.nl/~dimitri/doxygen/][Doxygen]]
-  Python has [[http://epydoc.sourceforge.net/][epydoc]],
   [[https://pypi.python.org/pypi/pydoctor/0.4][pydoctor]],
   [[http://pydoc.org/][pydoc]], [[http://sphinx-doc.org/][sphinx]], and
   Doxygen
-  C has ...
   [[https://developer.gnome.org/gtk-doc-manual/stable/][gtk-doc]],...,
   and Doxygen
-  For design there is always plantuml.

For user documentation, which is not generally tied to a specific
programming language there are different formats:

-  LaTeX
-  Sphinx
-  ASCIIDOC
-  Markdown
-  reST
-  DocBook

For developer facing documentation, one can use a combination of the
above tools. Especially, when producing UML diagrams.

When I develop code I try to use doxygen everywhere I go, Doxygen is
cross language and provides a nice means to produce: End-User,
Developer-User, and Developer documentation in HTML, MAN Pages, LaTeX,
RTF, and XML; and across multiple languages. This is handed is you are
dropping down into C. Moreover, doxygen has built in support for LaTeX
formula within documentation. Furthermore, recent versions of doxygen
allow for the use of Markdown, and inclusion of Markdown formatted
files. It is essentially the SwissArmy Knife of documentation.

However, when developing in Python the preferred documentation tool is
sphinx, and relies on reST mark up in python ‘docstrings', and other
files to produce both reference documentation, and user documentation. I
find the approach messy, especially reST.

Helaas, Doxygen doesn't want to play nice, and prefers to have its
documentation place in special comment blocks above method definitions
i.e.

#+BEGIN_EXAMPLE
    ##
    # Print message to STDOUT
    # @param msg The message to be printed
    #
    def print_message(msg):
        print(msg);
#+END_EXAMPLE

and not in docstrings. Luckily there is the
[[http://code.foosel.org/doxypy][doxypy]] filter that allows one to tell
doxygen to look in docstrings. Thus, the above snippet can now become:

#+BEGIN_EXAMPLE
    def print_message(msg):
    """ Print message to STDOUT
    @param msg The message to be printed.
    """
        print(msg);
#+END_EXAMPLE

To get python and doxygen working nicely together, aside from the
standard settings, the following configuration settings are also
recommended/required:

#+BEGIN_EXAMPLE
    INPUT_FILTER = "python /path/to/doxypy.py"
    FILTER_SOURCE_FILES = YES
    HIDE_UNDOC_RELATIONS = NO
    OPTIMIZE_OUTPUT_JAVA = YES
    JAVADOC_AUTOBRIEF = YES
    MULTILINE_CPP_IS_BRIEF = YES
    DETAILS_AT_TOP = YES
    EXTRACT_ALL = YES
    EXTRACT_STATIC = YES
    SHOW_DIRECTORIES = YES
    SOURCE_BROWSER = YES
    ALPHABETICAL_INDEX = YES
    COLS_IN_ALPHA_INDEX = 8
    TOC_EXPAND = YES
    DISABLE_INDEX = YES
    GENERATE_TREEVIEW = YES
#+END_EXAMPLE

Of note, with the latest version of Doxygen you can reference a markdown
file as the mainpage.

For an example python project that uses Doxygen, see
[[https://github.com/jfdm/pyPEBEL][pyPEBEL]].

References:

-  [[http://engtech.wordpress.com/2007/03/20/automatic_documentation_python_doxygen/][Automatic
   Documentation of Python Code using Doxygen]]
-  [[http://www.joshuascotton.com/main/archives/64][Creating
   Documentation from Python Source Files with Doxygen and doxypy]]
-  [[http://notemagnet.blogspot.co.uk/2009/10/using-doxypy-for-python-code.html][Using
   doxypy for Python code documentation]]
-  [[http://stackoverflow.com/a/13442157][Use the Readme MD file as main
   page in Doxygen]]

** [[http://noalgo.info/790.html][C++11多线程]]

*** 多线程

C++11中使用多线程非常简单，直接使用头文件thread中的thread类型即可创建一个线程，具体例子如下所示，该程序是一个多线程版本的Hello
World程序。
 注意，这里使用了C++11中的lambda匿名函数，如果对此不是很了解，请先阅读
[[http://noalgo.info/787.html][C++11中的lambda表达式]]。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    using namespace std;

    int main()
    {
      //线程函数无参数
        thread t([](){ cout << "Hello World!" << endl; });
        t.join(); //t1线程调用t2.join()，表示t1要等到t2结束后才能继续执行
    }
#+END_EXAMPLE

这里涉及到多线程环境中父子线程的关系问题。一般操作系统中，当主线程执行完毕退出时，无论子线程是否执行完毕，所有的子线程都会终止。而当子线程先退出时，无论是执行完毕正常退出还是以其他方式异常终止，线程均会进入终止态（僵死态），此时线程分配的系统资源还没有释放，线程仍作为一个线程实体存在于操作系统中。如果我们就这样不管这个子线程，那么它占用的系统资源（如动态申请的内存、打开的文件等）将一直被占据，造成资源的浪费。此时可以通过定义以下两种父子线程关系进行解决：

-  可会和（joinable）：主线程必须显示等待子线程，只有子线程结束后，主线程才继续执行后面的操作。
-  相分离（detached）：父子线程分离，主线程无须等待子线程完成，子线程一旦进入终止态后系统立即销毁线程以及回收资源。

以上的线程函数是无参数的，C++中还可以方便地给线程函数传递参数.

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    using namespace std;

    int main()
    {
        //线程函数带参数，传值
        thread t([](string s){ cout << s << endl; }, "Hello World!");
        t.join();
    }
#+END_EXAMPLE

以上带参数的线程函数是按值传递的，如果需要按引用传递，则使用方法稍微有点不同。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    using namespace std;

    int main()
    {
        int i = 0;
        //线程函数带参数，传引用
        thread t([](int &x){ cout << x++ << endl; }, ref(i)); //需要使用std::ref
        t.join();
        cout << i << endl;
    }
#+END_EXAMPLE

thread头文件的this\_thread命名空间定义了几个有用的函数：

-  get\_id：返回当前的线程id。
-  yield：在处于等待状态时，可以让调度器先运行其他可用的线程。
-  sleep\_for：阻塞当前线程，时间不少于参数指定的时间。
-  sleep\_util：阻塞当前线程，时间为参数指定的时间。

简单的使用方法如下：

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    using namespace std;

    void f()
    {
        cout << "Thread ID: " << this_thread::get_id() << endl;
        this_thread::sleep_for(chrono::seconds(3));
    }

    int main()
    {
        thread t(f);
        t.join();
    }
#+END_EXAMPLE

*** 互斥锁

多线程编程一般避免不了同步的问题，C++11这里也提供了非常方便的方法来进行解决。标准中提供了一下四种互斥锁，分别是：

-  Mutex：基本的Mutex类，提供了核心函数lock()和unlock()。
-  Recursive\_mutex：递归Mutex类，允许在同一个线程中对一个互斥量的多次请求。一般在项目模块分工中可以使用，这样即使其他人使用了同样的锁也不会导致死锁。
-  Timed\_mutex：定时递归Mutex类，除了递归，还可以在某个时间段里或者某个时刻到达之间获取该互斥量。当一个线程在临界区操作的时间非常长，可以用定时锁指定时间。
-  Recursive\_timed\_mutex：定时递归Mutex类，综合timed\_mutex和recuseive\_mutex。

下面是一个使用基本锁的小例子，该程序会按顺序输出5对enter和leave，分别对应5个线程。如果注释掉函数f中mt的lock和unlock函数，则线程没有同步，此时先输出5句enter，然后5s后再输出5句leave。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    #include <mutex>
    #include <vector>
    using namespace std;

    mutex mt;

    void f()
    {
        mt.lock();
        cout << "Enter Critical Section" << endl;
        this_thread::sleep_for(chrono::seconds(5));
        cout << "Leave Critical Section" << endl;
        mt.unlock();
    }

    int main()
    {
        vector<thread> v(5);
        for (auto &i : v) i = thread(f);
        for (auto &i : v) i.join();
    }
#+END_EXAMPLE

*** 条件变量

条件变量condition\_variable也可以进行线程之间的通信，当一个线程要等待另一个线程完成某个操作时，可以使用条件变量进行实现。条件变量可以将一个或多个线程进入阻塞状态，直到收到另外一个线程的通知，或者超时才能退出阻塞状态。

一个线程等待某个条件满足，其首先获得一个unique\_lock锁。该锁将会传递给wait()方法，然后wait()方法会释放互斥量并将该线程暂停，直到条件变量得到相应的信号。当接受到信号，线程被唤醒后，该锁就又被重新获得了。

另外一个线程发送信号使得条件满足。其通过调用notify\_one()来发送通知，会将处于阻塞状态的等待该条件获得信号的线程中的某一个线程（任意一个线程）恢复执行；还可以通过调用notify\_all()将等待该条件的所以线程唤醒。

下面是一个使用条件变量的简单例子。该程序中f1等待某个条件，该条件在f2输出并且睡眠2s后才得到满足，之后f1才能够进行输出。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <mutex>
    #include <thread>
    #include <condition_variable>
    using namespace std;

    mutex mt;
    condition_variable cv;

    void f1()
    {
        unique_lock<mutex> lock(mt);
        cv.wait(lock);
        cout << "F1 says Hi" << endl;
    }

    void f2()
    {
        cout << "F2 says Hi" << endl;
        this_thread::sleep_for(chrono::seconds(2));
        cv.notify_all();
    }

    int main()
    {
        thread t1(f1);
        this_thread::sleep_for(chrono::seconds(2));
        thread t2(f2);
        t1.join(), t2.join();
    }
#+END_EXAMPLE

*** Future

C++11中的future是标准库提供的一种用于获取异步操作的结果的机制，其可以调用一个函数，然后转而做其他的事情，让函数自己在一边执行，当需要的时候再回过头来获取该函数计算的结果。另外，其还可以延迟异步操作中异常(Exception)的抛出。
 下面是一个简单的例子。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <future>
    using namespace std;

    int main()
    {
        future<int> f = async([]()->int { return 42; });
        this_thread::sleep_for(chrono::seconds(2));
        cout << "The answer to life the universe and everything is: " << f.get() << endl;
    }
#+END_EXAMPLE

** [[http://blog.csdn.net/xiaoyangger/article/details/7879579][USBASP vs USBISP]]

1. USBISP与USBASP分别是2个德国人的设计,在硬件上基本兼容,但内核软件有不同,尽管低层USB都采用开源代码,但上层支持协议不同.USBISP是STK500v2 conpatible (direct from AVR-Studio useable) 的,直接在AVR STUDIO中支持和使用.而USBASP需要使用专用的编程软件.另外ASPISP的更新比USBASP快.

2、这两者硬件电路相同，固件程序不同；

3、两者使用的烧录软件不同，USBISP是模拟STK500下载线，所以可以使用AVR Stduio开发环境来下载烧录程序；而USBASP不能用AVR Stduio，但是现在网上很多支持USBASP的软件，比如PROGISP,AVR flater等。

4.USBISP与并口ISP(STK200/STK300)的比较
并口ISP(STK200/STK300)下载线需要PC带真正的LPT口,在ICC、CVAVR、BASCOM-AVR中可以直接使用。
USBISP使用USB口，只能在AVR STUDIO中使用（其它支持的不稳定）
USBISP速度稍为慢一点（M8模拟USB）

** [[http://blog.csdn.net/yimiyangguang1314/article/details/6449589][lsusb]]

插入usb鼠标后执行lsusb的输出内容如下:
-----------------------------------------
Bus 005 Device 001: ID 0000:0000
Bus 001 Device 001: ID 0000:0000
Bus 004 Device 001: ID 0000:0000
Bus 003 Device 001: ID 0000:0000
Bus 002 Device 006: ID 15d9:0a37
Bus 002 Device 001: ID 0000:0000

内容解读:
-----------------------------------------
Bus 005
    表示第五个usb主控制器(机器上总共有5个usb主控制器 -- 可以通过命令lspci | grep USB查看)

Device 006
    表示系统给usb鼠标分配的设备号(devnum)，同时也可以看到该鼠标是插入到了第二个usb主控制器
    006        usb_device.devnum
    /sys/devices/pci0000:00/0000:00:1d.1/usb2/2-2/devnum

ID 15d9:0a37
    表示usb设备的ID(这个ID由芯片制造商设置，可以唯一表示该设备)
    15d9    usb_device_descriptor.idVendor
    0a37    usb_device_descriptor.idProduct
    /sys/devices/pci0000:00/0000:00:1d.1/usb2/2-2/idVendor

Bus 002 Device 006: ID 15d9:0a37
Bus 002 Device 001: ID 0000:0000
    表示002号usb主控制器上接入了两个设备:
    一个是usb根Hub -- 001
    一个是usb鼠标   -- 006





说明：

lsusb命令是一个学习USB驱动开发，认识USB设备的助手，推荐大家使用，如果您的开发板中或者产品中没有lsusb命令可以自己移植一个，放到文件系统里面.

** [[http://python.jobbole.com/81129/][详解Python中的下划线]]

2015/03/13 · [[http://python.jobbole.com/category/basic/][基础知识]] ·
[[http://python.jobbole.com/tag/python/][Python]],
[[http://python.jobbole.com/tag/%e4%b8%8b%e5%88%92%e7%ba%bf/][下划线]]

分享到： [[http://www.jiathis.com/share?uid=1745061][]]

本文由 [[http://python.jobbole.com][伯乐在线]] -
[[http://www.jobbole.com/members/pyper][PyPer]]
翻译，[[http://www.jobbole.com/members/xianhu][xianhu]]
校稿。未经许可，禁止转载！
英文出处：[[http://shahriar.svbtle.com/underscores-in-python][shahriar.svbtle.com]]。欢迎加入[[http://group.jobbole.com/category/feedback/trans-team/][翻译组]]。

本文将讨论Python中下划线（\_）字符的使用方法。我们将会看到，正如Python中的很多事情，下划线的不同用法大多数（并非所有）只是常用惯例而已。

*** 单下划线（\_）

通常情况下，会在以下3种场景中使用：

1、*在解释器中*：在这种情况下，“\_”代表交互式解释器会话中上一条执行的语句的结果。这种用法首先被标准CPython解释器采用，然后其他类型的解释器也先后采用。

Python

>>> \_ Traceback (most recent call last): File "<stdin>", line 1, in
<module> NameError: name '\_' is not defined >>> 42 >>> \_ 42 >>>
'alright!' if \_ else ':(' 'alright!' >>> \_ 'alright!'

| 1    | >>> \_ Traceback (most recent call last):   |
| 2    | File "<stdin>", line 1, in <module>         |
| 3    | NameError: name '\_' is not defined         |
| 4    | >>> 42                                      |
| 5    | >>> \_                                      |
| 6    | 42                                          |
| 7    | >>> 'alright!' if \_ else ':('              |
| 8    | 'alright!'                                  |
| 9    | >>> \_                                      |
| 10   | 'alright!'                                  |

2、*作为一个名称*：这与上面一点稍微有些联系，此时“\_”作为临时性的名称使用。这样，当其他人阅读你的代码时将会知道，你分配了一个特定的名称，但是并不会在后面再次用到该名称。例如，下面的例子中，你可能对循环计数中的实际值并不感兴趣，此时就可以使用“\_”。

Python

n = 42 for \_ in range(n): do\_something()

| 1   | n = 42                |
| 2   | for \_ in range(n):   |
| 3   |     do\_something()   |

3、*国际化*：也许你也曾看到”\_“会被作为一个函数来使用。这种情况下，它通常用于实现国际化和本地化字符串之间翻译查找的函数名称，这似乎源自并遵循相应的C约定。例如，在[[https://docs.djangoproject.com/en/dev/topics/i18n/translation/][Django文档“转换”章节]]中，你将能看到如下代码：

Python

from django.utils.translation import ugettext as \_ from django.http
import HttpResponse def my\_view(request): output = \_("Welcome to my
site.") return HttpResponse(output)

| 1   | from django.utils.translation import ugettext as \_   |
| 2   | from django.http import HttpResponse                  |
| 3   | def my\_view(request):                                |
| 4   | output = \_("Welcome to my site.")                    |
| 5   | return HttpResponse(output)                           |

可以发现，场景二和场景三中的使用方法可能会相互冲突，所以我们需要避免在使用“\_”作为国际化查找转换功能的代码块中同时使用“\_”作为临时名称。

*** 名称前的单下划线（如：\_shahriar）

程序员使用名称前的单下划线，用于指定该名称属性为“私有”。这有点类似于惯例，为了使其他人（或你自己）使用这些代码时将会知道以“\_”开头的名称只供内部使用。正如Python文档中所述：

以下划线“\_”为前缀的名称（如\_spam）应该被视为API中非公开的部分（不管是函数、方法还是数据成员）。此时，应该将它们看作是一种实现细节，在修改它们时无需对外部通知。

正如上面所说，这确实类似一种惯例，因为它对解释器来说确实有一定的意义，如果你写了代码“from
<模块/包名> import
*”，那么以“\_”开头的名称都不会被导入，除非模块或包中的“\_\_all\_\_”列表显式地包含了它们。了解更多请查看“[[http://shahriar.svbtle.com/importing-star-in-python][Importing* in Python]]”。

*** 名称前的双下划线（如：\_\_shahriar）

名称（具体为一个方法名）前双下划线（\_\_）的用法并不是一种惯例，对解释器来说它有特定的意义。Python中的这种用法是为了避免与子类定义的名称冲突。Python文档指出，“\_\_spam”这种形式（至少两个前导下划线，最多一个后续下划线）的任何标识符将会被“\_classname\_\_spam”这种形式原文取代，在这里“classname”是去掉前导下划线的当前类名。例如下面的例子：

Python

>>> class A(object): ... def \_internal\_use(self): ... pass ... def
\_\_method\_name(self): ... pass ... >>> dir(A())
['\_A\_\_method\_name', ..., '\_internal\_use']

| 1   | >>> class A(object):                              |
| 2   | ... def \_internal\_use(self):                    |
| 3   | ... pass                                          |
| 4   | ... def \_\_method\_name(self):                   |
| 5   | ... pass                                          |
| 6   | ...                                               |
| 7   | >>> dir(A())                                      |
| 8   | ['\_A\_\_method\_name', ..., '\_internal\_use']   |

正如所预料的，“\_internal\_use”并未改变，而“\_\_method\_name”却被变成了“\_ClassName\_\_method\_name”。此时，如果你创建A的一个子类B，那么你将不能轻易地覆写A中的方法“\_\_method\_name”。

Python

>>> class B(A): ... def \_\_method\_name(self): ... pass ... >>>
dir(B()) ['\_A\_\_method\_name', '\_B\_\_method\_name', ...,
'\_internal\_use']

| 1   | >>> class B(A):                                                          |
| 2   | ... def \_\_method\_name(self):                                          |
| 3   | ... pass                                                                 |
| 4   | ...                                                                      |
| 5   | >>> dir(B())                                                             |
| 6   | ['\_A\_\_method\_name', '\_B\_\_method\_name', ..., '\_internal\_use']   |

这里的功能几乎和Java中的final方法和C++类中标准方法（非虚方法）一样。

*** 名称前后的双下划线（如：\_\_init\_\_）

这种用法表示Python中特殊的方法名。其实，这只是一种惯例，对Python系统来说，这将确保不会与用户自定义的名称冲突。通常，你将会覆写这些方法，并在里面实现你所需要的功能，以便Python调用它们。例如，当定义一个类时，你经常会覆写“\_\_init\_\_”方法。

虽然你也可以编写自己的特殊方法名，但不要这样做。

Python

>>> class C(object): ... def \_\_mine\_\_(self): ... pass ... >>> dir(C)
... [..., '\_\_mine\_\_', ...]

| 1   | >>> class C(object):             |
| 2   | ... def \_\_mine\_\_(self):      |
| 3   | ... pass                         |
| 4   | ...                              |
| 5   | >>> dir(C)                       |
| 6   | ... [..., '\_\_mine\_\_', ...]   |

其实，很容易摆脱这种类型的命名，而只让Python内部定义的特殊名称遵循这种约定。

** [[http://www.cnblogs.com/dartagnan/archive/2013/04/25/3042417.html][termios属性设置 tcsetattr设置]]

终端I/O有两种不同的工作方式：

1. 规范方式输入处理。在这种方式中，终端输入以行为单位进行处理。对于每个读要求，终端驱动程序最多返回一行。
2. 非规范方式输入处理。输入字符不以行为单位进行装配。

如果不作特殊处理，则默认方式是规范方式。

V7和BSD类的终端驱动程序支持三种终端输入方式：

1. 精细加工方式(输入装配成行，并对特殊字符进行处理)；
2. 原始方式(输入不装配成行，也不对特殊字符进行处理)；
3. cbreak方式(输入不装配成行，但对某些特殊字符进行处理)。

 

*** 2.termios结构

*[c-sharp]* [[http://blog.csdn.net/jibcy/article/details/7351669][view
plain]][[http://blog.csdn.net/jibcy/article/details/7351669][copy]]

 

1. struct termios {  
2.     tcflag\_t c\_iflag; /* Input modes */  
3.     tcflag\_t c\_oflag; /* Output modes */  
4.     tcflag\_t c\_cflag; /* Control modes */  
5.     tcflag\_t c\_lflag; /* Local modes */  
6.     cc\_t c\_cc[NCCS]; /* Control characters */  
7. };  

*[c-sharp]* [[http://blog.csdn.net/jibcy/article/details/7351669][view
plain]][[http://blog.csdn.net/jibcy/article/details/7351669][copy]]

 

1. struct termios {  
2.     tcflag\_t c\_iflag; /* Input modes */  
3.     tcflag\_t c\_oflag; /* Output modes */  
4.     tcflag\_t c\_cflag; /* Control modes */  
5.     tcflag\_t c\_lflag; /* Local modes */  
6.     cc\_t c\_cc[NCCS]; /* Control characters */  
7. };  

各个字段的选项如下(不是所有UNIX系统都支持)：

******* c\_iflag：

-  BRKINT：接到BREAK时产生SIGINT；
-  ICRNL：将输入的CR转换为NL；
-  IGNBRK：忽略BREAK条件；
-  IGNCR：忽略CR；
-  IGNPAR：忽略奇偶错字符；
-  IMAXBEL：在输入队列空时振铃；
-  INLCR：将输入的NL转换为CR；
-  INPCK：打开输入奇偶校验；
-  ISTRIP：剥除输入字符的第8位；
-  IUCLC：将输入的大写字符转换成小写字符(仅SVR4)；
-  IXANY：使任一字符都重新起动输出；
-  IXOFF：使起动/停止输入控制流起作用；
-  IXON：使起动/停止输出控制流起作用；
-  PARMRK：标记奇偶错；

******* c\_oflag：

-  BSDLY：退格延迟屏蔽(仅SVR4)；
-  CRDLY：CR延迟屏蔽(仅SVR4)；
-  FFDLY：换页延迟屏蔽(仅SVR4)；
-  NLDLY：NL延迟屏蔽(仅SVR4)；
-  OCRNL：将输出的CR转换为NL(仅SVR4)；
-  OFDEL：填充符为DEL，否则为NUL(仅SVR4)；
-  OFILL：对于延迟使用填充符(仅SVR4)；
-  OLCUC：将输出的小写字符转换为大写字符(仅SVR4)；
-  ONLCR：将NL转换为CR-NL；
-  ONLRET：NL执行CR功能(仅SVR4)；
-  ONOCR：在0列不输出CR(仅SVR4)；
-  ONOEOT：在输出中删除EOT字符(仅4.3+BSD)；
-  OPOST：执行输出处理；
-  OXTABS：将制表符扩充为空格(仅4.3+BSD)；
-  TABDLY：水平制表符延迟屏蔽(仅SVR4)；
-  VTDLY：垂直制表符延迟屏蔽(仅SVR4)；

******* c\_cflag：

-  CCTS\_OFLOW：输出的CTS流控制(仅4.3+BSD)；
-  CIGNORE：忽略控制标志(仅4.3+BSD)；
-  CLOCAL：忽略解制解调器状态行；
-  CREAD：启用接收装置；
-  CRTS\_IFLOW：输入的RTS流控制(仅4.3+BSD)；
-  CSIZE：字符大小屏蔽；
-  CSTOPB：送两个停止位，否则为1位；
-  HUPCL：最后关闭时断开；
-  MDMBUF：经载波的流控输出(仅4.3+BSD)；
-  PARENB：进行奇偶校；
-  PARODD：奇校，否则为偶校；

******* c\_lflag：

-  ALTWERASE：使用替换WERASE算法(仅4.3+BSD)；
-  ECHO：进行回送；
-  ECHOCTL：回送控制字符为\^(char)；
-  ECHOE：可见擦除符；
-  ECHOK：回送kill符；
-  ECHOKE：kill的可见擦除；
-  ECHONL：回送NL；
-  ECHOPRT：硬拷贝的可见擦除方式；
-  FLUSHO：刷清输出；
-  ICANON：规范输入；
-  IEXTEN：使扩充的输入字符处理起作用；
-  ISIG：使终端产生的信号起作用；
-  NOFLSH：在中断或退出键后不刷清；
-  NOKERNINFO：STATUS不使内核输出(仅4.3+BSD)；
-  PENDIN：重新打印；
-  TOSTOP：对于后台输出发送SIGTTOU；
-  XCASE：规范大/小写表示(仅SVR4)；

所有列出的选择标志(除屏蔽标志外)都用一或多位表示，而屏蔽标志则定义多位。屏蔽标志有一个定义名，每个值也有一个名字。例如，为了设置字符长度，首先用字符长度屏蔽标志CSIZE将表示字符长度的位清0，然后设置下列值之一：CS5、CS6、CS7或CS8。由SVR4支持的6个延迟值也有屏蔽标志：BSDLY、CRDLY、FFDLY、NLDLY、TABDLY和VTDLY。

各个标志的含义如下：

-  ALTWERASE：(c\_lflag,
   4.3+BSD)此标志设置时，若输入了WERASE字符，则使用一个替换的字擦除算法。它不是向后移动到前一个白空字符为止，而是向后移动到第一个非字母、数字符为止。
-  BRKINT：(c\_iflag,
   POSIX.1)若此标志设置，而IGNBRK未设置，则在接到BREAK时，输入、输出队列被刷清，并产生一个SIGINT信号。如果此终端设备是一个控制终端，则将此信号送给前台进程组各进程。如果IGNBRK和BRKINT都没有设置，但是设置了PARMRK，则BREAK被读作为三个字节序列/377，/0和/0，如果PARMRK也没有设置，则BREAK被读作为单个字符/0。
-  BSDLY：(c\_oflag, SVR4)退格延迟屏蔽，此屏蔽的值是BS0或BS1。
-  CCTS\_OFLOW：(c\_cflag, 4.3+BSD)输出的CTS流控制。
-  CIGNORE：(c\_cflag, 4.3+BSD)忽略控制标志。
-  CLOCAL：(c\_cflag,
   POSIX.1)如若设置，则忽略调制解调器状态线。这通常意味着该设备是本地连接的。若此标志未设置，则打开一个终端设备常常会阻塞到调制解调器回应。
-  CRDLY：(c\_oflag, SVR4)回车延迟屏蔽。此屏蔽的值是CR0、CR1、CR2和CR3。
-  CREAD：(c\_cflag, POSIX.1)如若设置，则接收装置被启用，可以接收字符。
-  CRTS\_IFLOW：(c\_cflag, 4.3+BSD)输入的RTS流控制。
-  CSIZE：(c\_cflag,
   POSIX.1)此字段是一个屏蔽标志，它指明发送和接收的每个字节的位数。此长度不包括可能有的奇偶校验位。由此屏蔽定义的字段值是CS5、CS6、CS7和CS8，分别表示每个字节包含5、6、7和8位。
-  CSTOPB：(c\_cflag,
   POSIX.1)如若设置，则使用两位作为停止位，否则只使用一位作为停止位。
-  ECHO：(c\_lflag,
   POSIX.1)如若设置，则将输入字符回送到终端设备。在规范方式和非规范方式下都可以回送字符。
-  ECHOCTL：(c\_lflag, SVR4和4.3+BSD)如若设置并且ECHO也设置，则除ASCII
   TAB、ASCII
   NL、START和STOP字符外，其他ASCII控制符(ASCII字符集中的0～037)都被回送为\^X，其中，X是相应控制字符代码值加0100所构成的字符。这就意味着ASCII
   Ctrl-A字符(01)被回送为\^A。ASCII
   DELETE字符(0177)则回送为\^?。如若此标志未设置，则ASCII控制字符按其原样回送。如同ECHO标志，在规范方式和非规范方式下此标志对控制字符回送都起作用。应当了解的是：某些系统回送EOF字符产生的作用有所不同，其原因是EOF的典型值是Ctrl-D，而这是ASCII
   EOT字符，它可能使某些终端挂断。
-  ECHOE：(c\_lflag,
   POSIX.1)如若设置并且ICANON也设置，则ERASE字符从显示中擦除当前行中的最后一个字符。这通常是在终端驱动程序中写三个字符序列：退格，空格，退格实现的。如若支持WERASE字符，则ECHOE用一个或若干个上述三字符序列擦除前一个字。如若支持ECHOPRT标志，则在这里所说明的ECHOE动作假定ECHOPRT标志没有设置。
-  ECHOK：(c\_lflag,
   POSIX.1)如若设置并且ICANON也设置，则KILL字符从显示中擦除当前行，或者输出NL字符(用以强调已擦除整个行)。如若支持ECHOKE标志，则这里的说明假定ECHOKE标志没有设置。
-  ECHOKE：(c\_lflag,
   SVR4和4.3+BSD)如若设置并且ICANON也设置，则回送KILL字符的方式是擦去行中的每一个字符。擦除每个字符的方法则由ECHOE和ECHOPRT标志选择。
-  ECHONL：(c\_lflag,
   POSIX.1)如若设置并且ICANON也设置，即使没有设置ECHO也回送NL字符。
-  ECHOPRT：(c\_lflag,
   SVR4和4.3+BSD)如若设置并且ICANON和ECHO也都设置，则ERASE字符(以及WERASE字符，若受到支持)使所有正被擦除的字符按它们被擦除的方式打印。在硬拷贝终端上这常常是有用的，这样可以确切地看到哪些字符正被擦去。
-  FFDLY：(c\_oflag, SVR4)换页延迟屏蔽。此屏蔽标志值是FF0或FF1。
-  FLUSHO：(c\_lflag,
   SVR4和4.3+BSD)如若设置，则刷清输出。当键入DISCARD字符时设置此标志，当键入另一个DISCARD字符时，此标志被清除。设置或清除此终端标志也可设置或清除此条件。
-  HUPCL：(c\_cflag,
   POSIX.1)如若设置，则当最后一个进程关闭此设备时，调制解调器控制线降至低电平(也就是调制解调器的连接断开)。
-  ICANON：(c\_lflag,
   POSIX.1)如若设置，则按规范方式工作。这使下列字符起作用：EOF、EOL、EOL2、ERASE、KILL、REPRINT、STATUS和WERASE。输入字符被装配成行。如果不以规范方式工作，则读请求直接从输入队列取字符。在至少接到MIN个字节或已超过TIME值之前，read将不返回。
-  ICRNL：(c\_iflag,
   POSIX.1)如若设置并且IGNCR未设置，即将接收到的CR字符转换成一个NL字符。
-  IEXTEN：(c\_lflag,
   POSIX.1)如若设置，则识别并处理扩充的、实现定义的特殊字符。
-  IGNBRK：(c\_iflag,
   POSIX.1)在设置时，忽略输入中的BREAK条件。关于BREAK条件是产生信号还是被读作为数据，请见BRKINT。
-  IGNCR：(c\_iflag,
   POSIX.1)如若设置，忽略接收到的CR字符。若此标志未设置，而设置了ICRNL标志则将接收到的CR字符转换成一个NL字符。
-  IGNPAR：(c\_iflag,
   POSIX.1)在设置时，忽略带有结构错误(非BREAK)或奇偶错的输入字节。
-  IMAXBEL：(c\_iflag, SVR4和4.3+BSD)当输入队列满时响铃。
-  INLCR：(c\_iflag, POSIX.1)如若设置，则接收到的NL字符转换成CR字符。
-  INPCK：(c\_iflag,
   POSIX.1)当设置时，使输入奇偶校验起作用。如若未设置INPCK，则使输入奇偶校验不起作用。奇偶“产生和检测”和“输入奇偶性检验”是不同的两件事。奇偶位的产生和检测是由PARENB标志控制的。设置该标志后使串行界面的设备驱动程序对输出字符产生奇偶位，对输入字符则验证其奇偶性。标志PARODD决定该奇偶性应当是奇还是偶。如果一个其奇偶性为错的字符已经来到，则检查INPCK标志的状态。若此标志已设置，则检查IGNPAR标志(以决定是否应忽略带奇偶错的输入字节)，若不应忽略此输入字节，则检查PARMRK标志以决定向读进程应传送那种字符。
-  ISIG：(c\_lflag,
   POSIX.1)如若设置，则判别输入字符是否是要产生终端信号的特殊字符(INTR，QUIT，SUSP和DSUSP)，若是，则产生相应信号。
-  ISTRIP：(c\_iflag,
   POSIX.1)当设置时，有效输入字节被剥离为7位。当此标志未设置时，则保留全部8位。
-  IUCLC：(c\_iflag, SVR4)将输入的大写字符映射为小写字符。
-  IXANY：(c\_iflag, SVR4和4.3+BSD)使任一字符都能重新起动输出。
-  IXOFF：(c\_iflag,
   POSIX.1)如若设置，则使起动-停止输入控制起作用。当终端驱动程序发现输入队列将要填满时，输出一个STOP字符。此字符应当由发送数据的设备识别，并使该设备暂停。此后，当已对输入队列中的字符进行了处理后，该终端驱动程序将输出一个START字符，使该设备恢复发送数据。
-  IXON：(c\_iflag,
   POSIX.1)如若设置，则使起动-停止输出控制起作用。当终端驱动程序接收到一个STOP字符时，输出暂停。在输出暂停时，下一个START字符恢复输出。如若未设置此标志，则START和STOP字符由进程读作为一般字符。
-  MDMBUF：(c\_cflag, 4.3+BSD)按照调制解调器的载波标志进行输出流控制。
-  NLDLY：(c\_oflag, SVR4)新行延迟屏蔽。此屏蔽的值是NL0和NL1。
-  NOFLSH：(c\_lflag,
   POSIX.1)按系统默认，当终端驱动程序产生SIGINT和SIGQUIT信号时，输入、出队列都被刷新。另外，当它产生SIGSUSP信号时，输入队列被刷新。如若设置了NOFLSH标志，则在这些信号产生时，不对输入、出队列进行刷新。
-  NOKERNINFO：(c\_lflag,
   4.3+BSD)当设置时，此标志阻止STATUS字符使前台进程组的状态信息显示在终端上。但是不论本标志是否设置，STATUS字符使SIGINFO信号送至前台进程组中的所有进程。
-  OCRNL：(c\_oflag, SVR4)如若设置，将输出的CR字符映照为NL。
-  OFDEL：(c\_oflag, SVR4)如若设置，则输出填充字符是ASCII
   DEL，否则它是ASCII NUL，见OFILL标志。
-  OFILL：(c\_oflag, SVR4)如若设置，则为实现延迟，发送填充字符(ASCII
   DEL或ASCII
   NUL，见OFDEL标志)，而不使用时间延迟。见6个延迟屏蔽：BSDLY，CRDLY，FFDLY，NLDLY，TABDLY以及VTDLY。
-  OLCUC：(c\_oflag, SVR4)如若设置，将小写字符映射为大写。
-  ONLCR：(c\_oflag, SVR4和4.3+BSD)如若设置，将输出的NL字符映照为CR-NL。
-  ONLRET：(c\_oflag, SVR4)如若设置，则输出的NL字符将执行回车功能。
-  ONOCR：(c\_oflag, SVR4)如若设置，则在0列不输出CR。
-  ONOEOT：(c\_oflag,
   4.3+BSD)如若设置，则在输出中删除EOT字符(\^D)。在将Ctrl-D解释为挂断的终端上这可能是需要的。
-  OPOST：(c\_oflag, POSIX.1)如若设置，则进行实现定义的输出处理。
-  OXTABS：(c\_oflag,
   4.3+BSD)如若设置，制表符在输出中被扩展为空格。这与将水平制表延迟(TABDLY)设置为XTABS或TAB3产生同样效果。
-  PARENB：(c\_cflag,
   POSIX.1)如若设置，则对输出字符产生奇偶位，对输入字符则执行奇偶性检验。若PARODD已设置，则奇偶校验是奇校验，否则是偶校验。也见INPCK、IGNPAR和PARMRK标志部分。
-  PARMRK：(c\_iflag,
   POSIX.1)，当设置时，并且IGNPAR未设置，则结构性错(非BREAK)和奇偶错的字节由进程读作为三个字符序列/377,
   /0和X，其中X是接收到的具有错误的字节。如若ISTRIP未设置，则一个有效的/377被传送给进程时为/377，/377。如若IGNPAR和PARMRK都未设置，则结构性错和奇偶错的字节都被读作为一个字符/0。
-  PARODD：(c\_cflag,
   POSIX.1)如若设置，则输出和输入字符的奇偶性都是奇，否则为偶。注意，PARENB标志控制奇偶性的产生和检测。
-  PENDIN：(c\_lflag,
   SVR4和4.3+BSD)如若设置，则在下一个字符输入时，尚未读的任何输入都由系统重新打印。这一动作与键入REPRINT字符时的作用相类似。
-  TABDLY：(c\_oflag,
   SVR4)水平制表延迟屏蔽。此屏蔽的值是TAB0、TAB1、TAB2或TAB3。XTABS的值等于TAB3。此值使系统将制表符扩展成空格。系统假定制表符所扩展的空格数到屏幕上最近一个8的倍数处为止。不能更改此假定。
-  TOSTOP：(c\_lflag,
   POSIX.1)如若设置，并且该实现支持作业控制，则将信号SIGTTOU送到试图与控制终端的一个后台进程的进程组。按默认，此信号暂停该进程组中所有进程。如果写控制终端的进程忽略或阻塞此信号，则终端驱动程序不产生此信号。
-  VTDLY：(c\_oflag, SVR4)垂直制表延迟屏蔽。此屏蔽的值是VT0或VT1。
-  XCASE：(c\_lflag,
   SVR4)如若设置，并且ICANON也设置，则认为终端是大写终端，所以输入都变换为小写。为了输入一个大写字符，在其前加一个/。与之类似，输出一个大写字符也在其前加一个/(这一标志已经过时，现在几乎所有终端都支持大、小写字符)。

 

*** 3.终端特殊输入字符

POSIX.1定义了11个在输入时作特殊处理的字符。SVR4另外加了6个特殊字符，4.3+BSD则加了7个。见下表：

字符

说明

c\_cc下标

起作用，由：

典型值

POSIX.1

SVR4

4.3+BSD

字段

标志

扩充

CR

回车

不能更改

c\_lflag

ICANON

/r

YES

 

 

DISCARD

擦除输出

VDISCARD

c\_lflag

IEXTEN

\^O

 

YES

YES

DSUSP

延迟挂起(SIGTSTP)

VDUSP

c\_lflag

ISIG

\^Y

 

YES

YES

EOF

文件结束

VEOF

c\_lflag

ICANON

\^D

YES

 

 

EOL

行结束

VEOL

c\_lflag

ICANON

 

YES

 

 

EOL2

替换的行结束

VEOL2

c\_lflag

ICANON

 

 

YES

YES

ERASE

擦除字符

VERASE

c\_lflag

ICANON

\^H

YES

 

 

INTR

中断信号(SIGINT)

VINTR

c\_lflag

ISIG

\^?, \^C

YES

 

 

KILL

擦行

VKILL

c\_lflag

ICANON

\^U

YES

 

 

LNEXT

下一个字列字符

VLNEXT

c\_lflag

IEXTEN

\^V

 

YES

YES

NL

新行

不能更改

c\_lflag

ICANON

/n

YES

 

 

QUIT

退出信号(SIGQUIT)

VQUIT

c\_lflag

ISIG

\^/

YES

 

 

REPRINT

再打印全部输入

VREPRINT

c\_lflag

ICANON

\^R

 

YES

YES

START

恢复输出

VSTART

c\_lflag

IXON/IXOFF

\^Q

YES

 

 

STATUS

状态要求

VSTATUS

c\_lflag

ICANON

\^T

 

 

YES

STOP

停止输出

VSTOP

c\_lflag

IXON/IXOFF

\^S

YES

 

 

SUSP

挂起信号(SIGTSTP)

VSUSP

c\_lflag

ISIG

\^Z

YES

 

 

WERASE

擦除字

VWERASE

c\_lflag

ICANON

\^W

 

YES

YES

我们称这些字符为特殊输入字符，但是其中有两个字符，STOP和START(Ctrl-S和Ctrl-Q)在输出时也对它们进行特殊处理。这些字符中的大多数在被终端驱动程序识别并进行特殊处理后都被丢弃，并不将它们传送给执行读终端操作的进程。例外的字符是新行符(NL，EOL，EOL2)和回车符(CR)。详细说明如下：

-  CR：POSIX.1的回车符，不能更改此字符。以规范方式进行输入时识别此字符。当设置了ICANON(规范方式)和ICRNL(将CR映照为NL)以及没有设置IGNCR(忽略CR)时，将CR转换成NL，并产生与NL符相同的作用。此字符返回给读进程(多半是在转换成NL后)。
-  DISCARD：SVR4和4.3+BSD的删除符。在扩充方式下(IEXTEN)，在输入中识别此字符。在输入另一个删除符之前或删除条件被清除之前(见FLUSHO选择项)此字符使后续输出都被删除。在处理后此字符即被删除，不送向读进程。
-  DSUSP：SVR4和4.3+BSD的延迟-挂起作业控制字符。在扩充方式下，若作业控制被挂起并且ISIG标志被设置，则在输入中识别此字符。与SUSP字符的相同处是：延迟-挂起字符产生SIGTSTP信号，它被送至前台进程组中的所有进程。但是并不是键入此字符时，而是在一个进程读控制终端时，此延迟-挂起字符才送向进程组。在处理后，此字符即被删除，不送向读进程。
-  EOF：POSIX.1的文件结束符。以规范方式进行输入时识别此字符。当键入此字符时，等待被读的所有字节都立即传送给读进程。如果没有字节等待读，则返回0。在行首输入一个EOF符是向程序指示文件结束的正常方式。在处理后，此字符即被删除，不送向读进程。
-  EOL：POSIX.1附加的行定界符，与NL作用相同。以规范方式进行输入时识别此字符。通常不使用此字符。此字符返回给读进程。
-  EOL2：SVR4和4.3+BSD的附加行定界符，与NL作用相同。以规范方式输入时识别此字符。通常不使用此字符，此字符返回给读进程。
-  ERASE：POSIX.1的擦除字符(退格)。以规范方式输入时识别此字符。它擦除行中的前一个字符，但不会超越行首字符擦除上一行中的字符。在处理后此字符即被擦除，不送向读进程。
-  INTR：POSIX.1的中断字符。若设置了ISIG标志，则在输入中识别此字符。它产生SIGINT信号，该信号被送至前台进程组中的所有进程。在处理后，此字符即被删除，不送向读进程。
-  KILL：POSIX.1的kill(杀死)字符。以规范方式输入时识别此字符。它擦除整个1行。在处理后，此字符即被删除，不送向读进程。
-  LNEXT：SVR4和4.3+BSD的“字面上-下一个”字符。以规范方式输入时识别此字符，它使下一个字符的任何特殊含意都被忽略。这对本节提及的所有特殊字符都起作用。使用这一字符可向程序键入任何字符。在处理后，LNEXT字符即被删除，但输入的下一个字符则被传送给读进程。
-  NL：POSIX.1的新行字符，它也被称为行定界符。不能更改此字符。以规范方式输入时识别此字符。此字符返回给读进程。
-  QUIT：POSIX.1的退出字符。若设置了ISIG标志，则在输入中识别此字符。它产生SIGQUIT信号，该信号又被送至前台进程组中的所有进程。在处理后，此字符即被删除，不送向读进程。
-  REPRINT：SVR4和4.3+BSD的再打印字符。以扩充规范方式(设置了IEXTEN和ICANON标志)进行输入时识别此字符。它使所有未读的输入被输出(再回送)。在处理后，此字符即被删除，不送向读进程。
-  START：POSIX.1的起动字符。若设置了IXON标志则在输入中识别此字符；若设置IXOFF标志，则作为输出自动产生此字符。在IXON已设置时接收到的START字符使停止的输出(由以前输入的STOP字符造成)重新起动。在此情形下，在处理后，此字符即被删除，不送向读进程。在IXOFF标志设置时，若输入不会使输入缓存溢出，则终端驱动程序自动地产生一START字符以恢复以前被停止的输入。
-  STATUS：4.3+BSD的状态-要求字符。以扩充、规范方式进行输入时识别此字符。它产生SIGINFO信号，该信号又被送至前台进程组中的所有进程。另外，如果没有设置NOKERNINFO标志，则有关前台进程组的状态信息也显示在终端上。在处理后，此字符即被删除，不送向读进程。
-  STOP：POSIX.1的停止字符。若设置了IXON标志，则在输入中识别此字符；若IXOFF标志已设置则作为输出自动产生此字符。在IXON已设置时接收到STOP字符则停止输出。在此情形下，在处理后删除此字符，不送向读进程。当输入一个START字符后，停止的输出重新起动。在IXOFF设置时，终端驱动程序自动地产生一个STOP字符以防止输入缓存溢出。
-  SUSP：POSIX.1的挂起作业控制字符。若支持作业控制并且ISIG标志已设置，则在输入中识别此字符。它产生SIGTSTP信号，该信号又被送至前台进程组的所有进程。在处理后，此字符即被删除，不送向读进程。
-  WERASE：SVR4和4.3+BSD的字擦除字符。以扩充、规范方式进行输入时识别此字符。它使前一个字被擦除。首先，它向后跳过任一白空字符(空格或制表符)，然后向后越过前一记号，使光标处在前一个记号的第一个字符位置上。通常，前一个记号在碰到一个白空字符时即终止。但是，可用设置ALTWERASE标志来改变这一点。此标志使前一个记号在碰到第一个非字母、数字符时即终止。在处理后，此字符即被删除，不送向读进程。

需要为终端设备定义的另一个“字符”是BREAK。BREAK实际上并不是一个字符，而是在异步串行数据传送时发生的一个条件。

在POSIX.1的11个特殊字符中，可将其中9个更改为几乎任何值。不能更改的两个特殊字符是新行符和回车符(/n和/r)，有些实现也不允许更改STOP和START字符。为了进行修改，只要更改termios结构中c\_cc数组的相应项，该数组中的元素都用名字作为下标进行引用，每个名字都以字母V开头。

POSIX.1可选地允许禁止使用这些字符。若\_POSIX\_VDISABLE有效，则\_POSIX\_VDISABLE的值可存放在c\_cc数组的相应项中以禁止使用该特殊字符。可以用pathconf和fpathconf函数查询此特征。

 

*** 4.POSIX终端I/O函数

| tcgetattr         | 取属性(termios结构)；     |
| tcsetattr         | 设置属性(termios结构)；   |
| cfgetispeed       | 得到输入速度；            |
| cfgetospeed       | 得到输出速度；            |
| cfsetispeed       | 设置输入速度；            |
| cfsetospeed       | 设置输出速度；            |
| tcdrain           | 等待所有输出都被传输；    |
| tcflow            | 挂起传输或接收；          |
| tcflush           | 刷清未决输入和/或输出；   |
| tcsendbreak       | 送BREAK字符；             |
| tcgetpgrp         | 得到前台进程组ID；        |
| tcsetpgrp         | 设置前台进程组ID；        |

 

*** 5.tcgetattr和tcsetattr

#+BEGIN_EXAMPLE
    #include <termios.h> int tcgetattr(int filedes, struct termios *termptr); int tcsetattr(int filedes, int opt, const struct termios *termptr); 两个函数返回：若成功则为0，若出错则为-1
#+END_EXAMPLE

这两个函数都有一个指向termios结构的指针作为其参数，它们返回当前终端的属性，或者设置该终端的属性。因为这两个函数只对终端设备进行操作，所以若filedes并不引用一个终端设备则出错返回，errno设置为ENOTTY。

tcsetattr的参数opt使我们可以指定在什么时候新的终端属性才起作用。opt可以指定为下列常数中的一个：

-  TCSANOW：更改立即发生；
-  TCSADRAIN：发送了所有输出后更改才发生。若更改输出参数则应使用此选择项。
-  TCSAFLUSH：发送了所有输出后更改才发生。更进一步，在更改发生时未读的所有输入数据都被删除(刷清)。

tcsetattr函数的返回值易于产生混淆。如果它执行了任意一种所要求的动作，即使未能执行所有要求的动作，它也返回0(表示成功)。如果该函数返回0，则我们有责任检查该函数是否执行了所有要求的动作。这就意味着，在调用tcsetattr设置所希望的属性后，需调用tcgetattr，然后将实际终端属性与所希望的属性相比较，以检测两者是否有区别。

 

*** 6.波特率函数

波特率(baud
rate)是一个历史沿用的术语，现在它指的是“位/每秒”。虽然大多数终端设备对输入和输出使用同一波特率，但是只要硬件许可，可以将它们设置为两个不同值。

#+BEGIN_EXAMPLE
    #include <termios.h> speed_t cfgetispeed(const struct termios *termptr); speed_t cfgetospeed(const struct termios *termptr); 两个函数返回：波特率值 int cfsetispeed(struct termios *termptr, speed_t speed); int cfsetospeed(struct termios *termptr, speed_t speed); 两个函数返回：若成功为0，出错为-1
#+END_EXAMPLE

两个cfget函数的返回值，以及两个cfset函数的speed参数都是下列常数之一：B50、B75、B110、B134、B150、B200、B300、B600、B1200、B1800、B2400、B4800、B9600、B19200或B38400。常数B0表示“挂断”。在调用tcsetattr时将输出波特率指定为B0，则调制解调器的控制线就不再起作用。

使用这些函数时，应当理解输入、输出波特率是存放在termios结构中的。在调用任一cfget函数之前，先要用tcgetattr获得设备的termios结构。与此类似，在调用任一cfset函数后，应将波特率设置到termios结构中。为使这种更改影响到设备，应当调用tcsetattr函数。如果所设置的波特率有错，则在调用tcsetattr之前，不会发现这种错误。

 

*** 7.行控制函数

#+BEGIN_EXAMPLE
    #include <termios.h> int tcdrain(int filedes); int tcflow(int filedes, int action); int tcflush(int filedes, int queue); int tcsendbreak(int filedes, int duration); 四个函数返回：若成功则为0，若出错则为-1
#+END_EXAMPLE

其中，参数filedes引用一个终端设备，否则出错返回，errno设置为ENOTTY。

tcdrain函数等待所有输出都被发送。

tcflow用于对输入和输出流控制进行控制。action参数应当是下列四个值之一：

-  TCOOFF：输出被挂起；
-  TCOON：以前被挂起的输出被重新起动；
-  TCIOFF：系统发送一个STOP字符。这将使终端设备暂停发送数据；
-  TCION：系统发送一个START字符。这将使终端恢复发送数据。

tcflush函数刷清(抛弃)输入缓存(终端驱动程序已接收到，但用户程序尚未读)或输出缓存(用户程序已经写，但尚未发送)。queue参数应当是下列三个常数之一：

-  TCIFLUSH：刷清输入队列；
-  TCOFLUSH：刷清输出队列；
-  TCIOFLUSH：刷清输入、输出队列；

tcsendbreak函数在一个指定的时间区间内发送连续的0位流。若duration参数为0，则此种发送延续0.25~
0.5秒之间。POSIX.1说明若duration非0，则发送时间依赖于实现。

 

*** 8.终端标识函数

POSIX.1提供了一个运行时函数，可被调用来决定控制终端的名字:

#+BEGIN_EXAMPLE
    #include <stdio.h> char * ctermid(char *ptr);
#+END_EXAMPLE

如果ptr是非空，则它被认为是一个指针，指向长度至少为L\_ctermid字节的数组，进程的控制终端名存放在该数组中。常数L\_ctermid定义在<stdio.h>中。若ptr是一个空指针，则该函数为数组(通常作为静态变量)分配空间。同样，进程的控制终端名存放在该数组中。

在这两种情况中，该数组的起始地址被作为函数值返回。因为大多数UNIX系统都使用/dev/tty作为控制终端名，所以此函数的主要作用是帮助提高向其他操作系统的可移植性。

其他终端标识函数还有：

#+BEGIN_EXAMPLE
    #include <unistd.h> int isatty(int filedes); 返回：若为终端设备则为1(真)，否则为0(假) char *ttyname(int filedes); 返回：指向终端路径名的指针，若出错则为NULL
#+END_EXAMPLE

如果文件描述符引用一个终端设备，则isatty返回真，而ttyname则返回在该文件描述符上打开的终端设备的路径名。

 

*** 9.规范方式

规范方式发一个读请求，当一行已经输入后，终端驱动程序即返回。许多条件造成读返回：

-  所要求的字节数已读到时读即返回。无需读一个完整的行。如果读了部分行，那么也不会丢失任何信息―下一次读从前一次读的停止处开始。
-  当读到一个行定界符时，读返回。在规范方式中，下列字符被解释为“行结束”：NL、EOL、EOL2和EOF。另外，如若已设置ICRNL，但未设置IGNCR，则CR字符的作用与NL字符一样，所以它也终止一行。在这五个行定界符中，其中只有一个EOF符在终端驱动程序对其进行处理后即被删除。其他四个字符则作为该行的最后一个字符返回调用者。
-  如果捕捉到信号而且该函数并不自动再起动，则读也返回。

 

*** 10.非规范方式

将termios结构中c\_lflag字段的ICANON标志关闭就使终端处于非规范方式。在非规范方式中，输入数据不装配成行，不处理下列特殊字符：ERASE、KILL、EOF、NL、EOL、EOL2、CR、REPRINT、STATUS和WERASE。

在非规范方式下，由于不是每次返回一行，解决读的方法是：当已读了指定量的数据后，或者已经过了给定量的时间后，即通知系统返回。

这种技术使用termios结构中c\_cc数组的两个变量：MIN和TIME。c\_cc数组中的这两个元素的下标名为：VMIN和VTIME。

MIN说明一个read返回前的最小字节数。TIME说明等待数据到达的分秒数(秒的1/10为分秒)。有下列四种情形：

-  *情形A：MIN > 0, TIME >
   0*。TIME说明一个字节间的计时器，在接到第一个字节时才起动它。在该计时器超时之前，若已接到MIN个字节，则read返回MIN个字节。如果在接到MIN个字节之前，该计时器已超时，则read返回已接收到的字节(因为只有在接到第一个字节时才起动，所以在计时器超时时，至少返回1个字节)。在这种情形中，在接到第一个字节之前，调用者阻塞。如果在调用read时数据已经可用，则这如同在read后，数据立即被接收到一样。
-  *情形B：MIN > 0 , TIME = =
   0*。已经接到了MIN个字节时，read才返回。这可以造成read无限期的阻塞。
-  *情形C：MIN = = 0，TIME >
   0*。TIME指定了一个调用read时起动的读计时器。(与情形A相比较，两者是不同的)。在接到1个字节或者该计时器超时时，read即返回。如果是计时器超时，则read返回0。
-  *情形D ：MIN = = 0，TIME = =
   0*。如果有数据可用，则read最多返回所要求的字节数。如果无数据可用，则read立即返回0。

在所有这些情形中，MIN只是最小值。如果程序要求的数据多于MIN个字节，那么它可能能接收到所要求的字节数。这也适用于MIN
= = 0的情形A和B。

 

*** 11.break方式和raw方式

对cbreak方式的定义是：

-  非规范方式。这种方式不对某些输入特殊字符进行处理。这种方式仍对信号进行处理，所以用户可以键入任一终端产生的信号。调用者应当捕捉这些信号，否则这种信号就可能终止程序，并且终端将仍处于cbreak方式。作为一般规则，在编写更改终端方式的程序时，应当捕捉大多数信号，以便在程序终止前恢复终端方式；
-  关闭回送(ECHO)标志；
-  每次输入一个字节。为此将MIN设置为1，将TIME设置为0。至少有一个字节可用时，read再返回。

对原始方式的定义是：

-  非规范方式。另外，还关闭了对信号产生字符(ISIG)和扩充输入字符的处理(IEXTEN)。关闭BRKINT，这样就使BREAK字符不再产生信号；
-  关闭回送(ECHO)标志；
-  关闭ICRNL、INPCK、ISTRIP和IXON标志。于是：不再将输入的CR字符变换为NL(ICRNL)、使输入奇偶校验不起作用(INPCK)、不再剥离输入字节的第8位(ISTRIP)、不进行输出流控制(IXON)；
-  8位字符(CS8)，不产生奇偶位，不进行奇偶性检测(PARENB)；
-  禁止所有输出处理(OPOST)；
-  每次输入一个字节(MIN = 1，TIME = 0)。

 

*** 12.终端窗口

内核为每个终端和伪终端保存一个winsize结构：

*[c-sharp]* [[http://blog.csdn.net/jibcy/article/details/7351669][view
plain]][[http://blog.csdn.net/jibcy/article/details/7351669][copy]]

 

1. struct winsize {  
2.     unsigned short ws\_row; /* rows, in characters */  
3.     unsigned short ws\_col; /* columns, in character */  
4.     unsigned short ws\_xpixel; /* horizontal size, pixels */  
5.     unsigned short ws\_ypixel; /* vertical size, pixels */  
6. };  

*[c-sharp]* [[http://blog.csdn.net/jibcy/article/details/7351669][view
plain]][[http://blog.csdn.net/jibcy/article/details/7351669][copy]]

 

1. struct winsize {  
2.     unsigned short ws\_row; /* rows, in characters */  
3.     unsigned short ws\_col; /* columns, in character */  
4.     unsigned short ws\_xpixel; /* horizontal size, pixels */  
5.     unsigned short ws\_ypixel; /* vertical size, pixels */  
6. };  

此结构的作用是：

1. 用ioctl的TIOCGWINSZ命令可以取此结构的当前值。
2. 用ioctl的TIOCSWINSZ命令可以将此结构的新值存放到内核中。如果此新值与存放在内核中的当前值不同，则向前台进程组发送SIGWINCH信号。此信号的系统默认动作是忽略。
3. 除了存放此结构的当前值以及在此值改变时产生一个信号以外，内核对该结构不进行任何其他操作。对结构中的值进行解释完全是应用程序的工作。

提供这种功能的目的是，当窗口大小发生变化时通知应用程序(例如vi编辑程序)。应用程序接到此信号后，它可以取得窗口大小的新值，然后重绘屏幕。

** [[http://www.latexstudio.net/archives/3516][]]

** [[http://www.latexstudio.net/archives/3516][org-mode的中文beamer幻灯片模板]]

2015-04-09
分类：[[http://www.latexstudio.net/archives/category/tex-slides/beamer-theme-template][beamer]]
阅读(444) 评论(1)

org-mode 是 Emacs
的杀手级应用，使用它可以用来做很多事情，如GTD、做笔记等。它可以导出多种格式的文件，包括HTML、LaTeX、Freemind、DocBook等，因此，通过定制之后，编写一份org文件就等于同时编写（或者排版）了多种格式文件，而且每种格式的文件又可以各自拥有不同的排版效果。这正是
org-mode 精妙之处。

比如，我最喜欢的做法是先在 Emacs 里打开 evernote-mode 写一份 org-mode
的笔记，然后 =C-c C-e H= 导出成 HTML
代码，并发布到我的博客中或者加入到我的 wiki
里。如果有需要，我还可以 =C-c C-e l= 生成 LaTeX 代码并编译成 PDF 文件。

用 org-mode 制作 Beamer
幻灯片也很简单，官方已经给出了 [[http://orgmode.org/worg/org-tutorials/org-beamer/tutorial.html][详细的教程]] ，照着一步步做即可。官方的教程并没有针对中文进行定制，因此笔者写了一个org-mode的Beamer中文模板，这是在 [[http://orgmode.org/manual/Beamer-class-export.html#Beamer-class-export][Carsten
Dominik的例子]] 的基础上修改得到的。

*** 1 截图预览

[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2015/04/org-beamer-cn.png]]

*** 2 环境要求

1. Emacs
2. org-mode
3. TeXLive 或其他带有 Beamer 宏包的 LaTeX 系统
4. Adobe 字体

   -  Adobe Heiti Std
   -  Adobe Kaiti Std

*** 3 特点

1. 使用 “Darmstadt” 主题及 “Firebrick”配色方案；
2. 使用 listings
   宏包实现代码框。如果有中文内容，你可能需要使用逃逸字串(`')括住两边，否则会出现错位；
3. 使用xeCJK来处理中文，并使用 Adobe
   字体（[[http://ishare.iask.sina.com.cn/f/23186570.html][字体下载]]）。

*** 4 下载

-  Github主页：[[http://wzpan.github.com/org-beamer-cn/][http://wzpan.github.io/org-beamer-cn/]]
-  克隆git仓库：git clone https://github.com/wzpan/org-beamer-cn.git
-  zip压缩包：[[https://github.com/wzpan/org-beamer-cn/zipball/master][https://github.com/wzpan/org-beamer-cn/zipball/master]]
-  tar.gz压缩包：[[https://github.com/wzpan/org-beamer-cn/tarball/master][https://github.com/wzpan/org-beamer-cn/tarball/master]]
-  本站下载：[[http://www.latexstudio.net/wp-content/uploads/2015/04/wzpan-org-beamer-cn-e5b5173.zip][wzpan-org-beamer-cn-e5b5173]]

*** 5 使用方法

-  用 Emacs 打开 *beamer.org* 文件， =M-x org-mode= 打开 org-mode；
-  =C-c C-e l= 生成 beamer.tex 文件；
-  打开 *beamer.tex* 文件， =C-c C-c (M-x TeX-command-master)= 并选择使用 *XeLaTeX* 编译。完成后就可以得到幻灯片了。

*** 6 F&Q

-  两个“@”不能生成alert效果？

这个可能是 org-mode 本身的 bug，但可以通过修改
Emacs里的设置来解决。在 =(require 'org-latex)= 前加入这一段设置：

Lisp

(setq org-emphasis-alist (quote (("*" bold "<b>" "</b>") ("/" italic
"<i>" "</i>") ("\_" underline "<span
style=\"text-decoration:underline;\">" "</span>") ("=" org-code "<code>"
"</code>" verbatim) ("~" org-verbatim "<code>" "</code>" verbatim) ("+"
(:strike-through t) "<del>" "</del>") ("@" org-warning "<b>" "</b>")))
org-export-latex-emphasis-alist (quote (("*" "\\textbf{%s}" nil) ("/"
"\\emph{%s}" nil) ("\_" "\\underline{%s}" nil) ("+" "\\texttt{%s}" nil)
("=" "\\verb=%s=" nil) ("~" "\\verb~%s~" t) ("@" "\\alert{%s}" nil))))

| 1    | (setq org-emphasis-alist (quote (("*" bold "<b>" "</b>")                      |
| 2    |                                  ("/" italic "<i>" "</i>")                    |
| 3    |                                  ("\_" underline "<span                       |
| 4    | style=\"text-decoration:underline;\">" "</span>")                             |
| 5    |                                  ("=" org-code "<code>" "</code>"             |
| 6    |                  verbatim)                                                    |
| 7    |                                  ("~" org-verbatim "<code>" "</code>"         |
| 8    |                  verbatim)                                                    |
| 9    |                                  ("+" (:strike-through t) "<del>" "</del>")   |
| 10   |                                  ("@" org-warning "<b>" "</b>")))             |
| 11   |       org-export-latex-emphasis-alist (quote                                  |
| 12   |                                        (("*" "\\textbf{%s}" nil)              |
| 13   |                                         ("/" "\\emph{%s}" nil)                |
| 14   |                                         ("\_" "\\underline{%s}" nil)          |
| 15   |                                         ("+" "\\texttt{%s}" nil)              |
| 16   |                                         ("=" "\\verb=%s=" nil)                |
| 17   |                                         ("~" "\\verb~%s~" t)                  |
| 18   |                                         ("@" "\\alert{%s}" nil))))            |

** [[http://linuxcommand.org/man_pages/pdfinfo1.html][pdfinfo]]

*** NAME

#+BEGIN_EXAMPLE
           pdfinfo - Portable Document Format (PDF) document information extractor
           (version 3.01)

#+END_EXAMPLE

*** SYNOPSIS

#+BEGIN_EXAMPLE
           pdfinfo [options] [PDF-file]

#+END_EXAMPLE

*** DESCRIPTION

#+BEGIN_EXAMPLE
           Pdfinfo prints the contents of the ´Info’ dictionary (plus  some  other
           useful information) from a Portable Document Format (PDF) file.

           The ´Info’ dictionary contains the following values:

                  title
                  subject
                  keywords
                  author
                  creator
                  producer
                  creation date
                  modification date

           In addition, the following information is printed:

                  tagged (yes/no)
                  page count
                  encrypted flag (yes/no)
                  print and copy permissions (if encrypted)
                  page size
                  file size
                  linearized (yes/no)
                  PDF version
                  metadata (only if requested)

#+END_EXAMPLE

*** CONFIGURATION FILE

#+BEGIN_EXAMPLE
           Pdfinfo  reads a configuration file at startup.  It first tries to find
           the user’s private config file, ~/.xpdfrc.  If that doesn’t  exist,  it
           looks  for  a  system-wide config file, typically /etc/xpdfrc (but this
           location can be changed when pdfinfo is built).  See the xpdfrc(5)  man
           page for details.

#+END_EXAMPLE

*** OPTIONS

#+BEGIN_EXAMPLE
           Many  of  the following options can be set with configuration file com-
           mands.  These are listed in square brackets with the description of the
           corresponding command line option.

           -f number
                  Specifies  the  first  page  to  examine.  If multiple pages are
                  requested using the "-f" and "-l"  options,  the  size  of  each
                  requested  page  (and,  optionally,  the bounding boxes for each
                  requested page) are printed.  Otherwise, only page one is  exam-
                  ined.

           -l number
                  Specifies the last page to examine.

           -box   Prints the page box bounding boxes: MediaBox, CropBox, BleedBox,
                  TrimBox, and ArtBox.

           -meta  Prints document-level metadata.  (This is the "Metadata"  stream
                  from the PDF file’s Catalog object.)

           -enc encoding-name
                  Sets  the  encoding  to  use for text output.  The encoding-name
                  must be defined with the  unicodeMap  command  (see  xpdfrc(5)).
                  This defaults to "Latin1" (which is a built-in encoding).  [con-
                  fig file: textEncoding]

           -opw password
                  Specify the owner password for the  PDF  file.   Providing  this
                  will bypass all security restrictions.

           -upw password
                  Specify the user password for the PDF file.

           -cfg config-file
                  Read config-file in place of ~/.xpdfrc or the system-wide config
                  file.

           -v     Print copyright and version information.

           -h     Print usage information.  (-help and --help are equivalent.)

#+END_EXAMPLE

*** EXIT CODES

#+BEGIN_EXAMPLE
           The Xpdf tools use the following exit codes:

           0      No error.

           1      Error opening a PDF file.

           2      Error opening an output file.

           3      Error related to PDF permissions.

           99     Other error.

#+END_EXAMPLE

*** AUTHOR

#+BEGIN_EXAMPLE
           The pdfinfo software and documentation are copyright 1996-2005 Glyph  &
           Cog, LLC.

#+END_EXAMPLE

*** SEE ALSO

#+BEGIN_EXAMPLE
           xpdf(1),  pdftops(1),  pdftotext(1),  pdffonts(1),  pdftoppm(1), pdfim-
           ages(1), xpdfrc(5)
           http://www.foolabs.com/xpdf/



                                    17 August 2005                      pdfinfo(1)
#+END_EXAMPLE

--------------

Man(1) output converted with
[[http://www.oac.uci.edu/indiv/ehood/man2html.html][man2html]]

** [[http://www.cnblogs.com/fhefh/archive/2011/04/22/2024857.html][linux bash shell之declare]]

/declare/或/typeset/内建命令(它们是完全相同的)可以用来限定变量的属性.这是在某些编程语言中使用的定义类型不严格的方式。命令*declare*是bash版本2之后才有的。命令*typeset*也可以在ksh脚本中运行。

*declare/typeset 选项*

-  -r =只读= :: | #+BEGIN_EXAMPLE            |
                |        1 declare -r var1   |
                | #+END_EXAMPLE              |


   (=declare -r var1=与=readonly var1=作用相同)

   这大致和C的*const*限定词相同.一个试图改变只读变量值的操作将会引起错误信息而失败.

-  -i =整数= :: | #+BEGIN_EXAMPLE                                                                        |
                |        1 declare -i number                                                             |
                |        2 # 脚本余下的部分会把"number"当作整数看待.                                     |
                |        3                                                                               |
                |        4 number=3                                                                      |
                |        5 echo "Number = $number"     # Number = 3                                      |
                |        6                                                                               |
                |        7 number=three                                                                  |
                |        8 echo "Number = $number"     # Number = 0                                      |
                |        9 # 脚本尝试把字符串"three"作为整数来求值(译者注：当然会失败，所以出现值为0).   |
                | #+END_EXAMPLE                                                                          |


   某些算术计算允许在被声明为整数的变量中完成，而不需要特别使用expr或let来完成。

   | #+BEGIN_EXAMPLE                          |
   |        1 n=6/3                           |
   |        2 echo "n = $n"       # n = 6/3   |
   |        3                                 |
   |        4 declare -i n                    |
   |        5 n=6/3                           |
   |        6 echo "n = $n"       # n = 2     |
   | #+END_EXAMPLE                            |


-  -a =数组= :: | #+BEGIN_EXAMPLE               |
                |        1 declare -a indices   |
                | #+END_EXAMPLE                 |


   变量=indices=会被当作数组.

-  -f =函数= :: | #+BEGIN_EXAMPLE       |
                |        1 declare -f   |
                | #+END_EXAMPLE         |


   在脚本中没有带任何参数的=declare -f= 会列出所有在此脚本前面已定义的函数出来。

   | #+BEGIN_EXAMPLE                     |
   |        1 declare -f function_name   |
   | #+END_EXAMPLE                       |


   而=declare -f function_name=则只会列出指定的函数.

-  -x export :: | #+BEGIN_EXAMPLE            |
                |        1 declare -x var3   |
                | #+END_EXAMPLE              |


   这样将声明一个变量作为脚本的环境变量而被导出。

-  -x var=$value :: | #+BEGIN_EXAMPLE                |
                    |        1 declare -x var3=373   |
                    | #+END_EXAMPLE                  |


   *declare*命令允许在声明变量类型的时候同时给变量赋值。

--------------

*例子 9-21. 用*declare来声明变量类型**

| #+BEGIN_EXAMPLE                                                              |
|        1 #!/bin/bash                                                         |
|        2                                                                     |
|        3 func1 ()                                                            |
|        4 {                                                                   |
|        5 echo This is a function.                                            |
|        6 }                                                                   |
|        7                                                                     |
|        8 declare -f        # 列出上面的函数.                                 |
|        9                                                                     |
|       10 echo                                                                |
|       11                                                                     |
|       12 declare -i var1   # var1是一个整数.                                 |
|       13 var1=2367                                                           |
|       14 echo "var1 declared as $var1"                                       |
|       15 var1=var1+1       # 整数声明后，不需要使用'let'.                    |
|       16 echo "var1 incremented by 1 is $var1."                              |
|       17 # 试图将已声明为整数的变量的值更改为浮点值.                         |
|       18 echo "Attempting to change var1 to floating point value, 2367.1."   |
|       19 var1=2367.1       # 引起一个错误信息，此变量的值保持原样.           |
|       20 echo "var1 is still $var1"                                          |
|       21                                                                     |
|       22 echo                                                                |
|       23                                                                     |
|       24 declare -r var2=13.36         # 'declare'允许设置变量的属性，       |
|       25                               #+ 同时也给变量赋值.                  |
|       26 echo "var2 declared as $var2" # 试图更改只读变量的值.               |
|       27 var2=13.37                    # 引起错误，并且从脚本退出.           |
|       28                                                                     |
|       29 echo "var2 is still $var2"    # 这行不会被执行.                     |
|       30                                                                     |
|       31 exit 0                        # 脚本不会从这儿退出.                 |
| #+END_EXAMPLE                                                                |

** [[/a/1190000002539169][玩转Bash变量]]

[[/u/spacewander][[[http://sfault-avatar.b0.upaiyun.com/411/132/411132166-5646f64876acf_big64]]
*spacewander*]] ** 2015年02月05日 发布

-  推荐
   *3* 推荐
-  收藏
   *17* 收藏，*4k* 浏览

PS :
注意本文讨论的是Bash，而不一定是/bin/sh所链接的那个shell。这里出现的所有代码片段，默认在顶上都添加了=#!/bin/bash=。

*** 一门自带混淆的语言

#+BEGIN_EXAMPLE
    while (( $# )); do
        case $1 in
            -a*)
                # Error checking
                [[ ${1#-a} ]] || { echo "bash: ${FUNCNAME[0]}: \`$1': missing"\
                    "number specifier" 1>&2; return 1; }
                printf %d "${1#-a}" &> /dev/null || { echo "bash:"\
                    "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2
                return 1; }
                # Assign array of -aN elements
                [[ "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) &&
                    shift $((${1#-a} + 2)) || { echo "bash: ${FUNCNAME[0]}:"\
                    "\`$1${2+ }$2': missing argument(s)" 1>&2; return 1; }
                ;;
            -v)
                # Assign single value
                [[ "$2" ]] && unset -v "$2" && eval $2=\"\$3\" &&
                    shift 3 || { echo "bash: ${FUNCNAME[0]}: $1: missing"\
                    "argument(s)" 1>&2; return 1; }
                ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2
                return 1 ;;
        esac
    done
#+END_EXAMPLE

如果你觉得阅读上面的Bash代码，就像阅读段子一样顺畅，那么是时候关掉这个页面，去做别的更有意义的行为，比如去喝个水什么的。

如果你觉得上面的Bash代码犹如鬼画符，并且实际生活中不得不面对它，那么就看下去吧。

*** Bash变量操作

正式开始正文内容。

想要在一篇文章里，讲述要看懂开篇代码所需的所有知识点，这是不自量力的行为。因此，本文将讲且仅讲Bash中操作变量的方法。所以，即使你看完了这篇文章，你多半还是看不懂开篇的代码。

不过看完这篇文章之后，你对Bash的变量操作会有更为深入的认识。而且更重要的是，Bash之于你，不再是怎么也看不清摸不透。下一次要写脚本的时候，你也将更加坚定地下定决心
------ 人生苦短，我用Python/Ruby。

**** 严格意义上的Bash变量类型

Bash变量只有两种类型，字符串和数组。不过从严格意义上，Bash没有变量类型。Bash中的变量，在运行的时候会被展开成其对应的值（字符串）。你可以把它看做C/C++中的宏定义，或者一些模板语言中的占位符。

一般情况下，变量通过===赋值，注意===两边不要留空格。有些好孩子，已经养成了符号两端留空格的习惯，结果当开始写Bash的时候，他们抓狂了。

要想访问变量，只需在变量名前面添加=$=，解释器就会对它进行展开。如果该变量并不存在，解释器会把它展开成“”。

#+BEGIN_EXAMPLE
    me=spacewander
    echo $me
    echo $who
#+END_EXAMPLE

**** 来自命令行的你

作为脚本语言，第一要义当然是要随时随地获取到命令行输入啦。

在Bash中，使用=$1=可以获取命令行输入的第一个参数，=$2=可以获取命令行输入的第2个参数，=$3=可以获取命令行输入的第......
 你看，$1到$10000的用法就这么交代完了。Bash还是挺有逻辑的嘛。

顺便一提，=$0=获取的脚本的名字（其实就是其他语言中的第0个参数），=$@=获取所有的参数，=$#=获取参数的数目。记住=@=和=#=这两个符号，在Bash这一神秘的符文体系中，前者表示全部参数，后者表示参数的数目。

**** 展开，然后Bomb！

假如Bash变量中含有空白字符，或者含有特殊字符，比如=*=，展开后会污染到外面的字符串，结果就是*Bomb*。
 比如

#+BEGIN_EXAMPLE
    Oops='*'
    # '*'解释成所有匹配的文件名
    echo $Oops
    # 所以需要加双引号括起来
    echo "$Oops"
    # 加单引号会怎样呢？
    echo '$Oops'
#+END_EXAMPLE

上面的代码值得一试。

另外一种Bomb的可能是，变量后面需要接其它字符串，比如=$FRUITs=。如果想让解释器识别成=$FRUIT=变量，而不是=$FRUITs=，需要用花括号括起来，像=${FRUIT}s=

**** 数组和关联数组

Bash中可以使用两种容器。
 一种是数组，另一种是关联数组，类似于其他语言中的Map/Hash/Dict。
 声明数组的常用语法： =declare -a ARY=或者=ARY=(1 2 3)=
 声明关联数组的唯一语法： =declare -A MAP=

赋值的语法：

直接=ARY[N]=VALUE=，N可以是数字索引也可以是键。关联数组可以使用=MAP=([x]=a [y]=b)=进行多项赋值，注意这是赋值的语句而不是声明。

亲测数组中的索引不一定要按顺序来，你可以先给2和3上的元素赋值。（同样算是弱类型的Javascript也支持这种无厘头赋值，这算通病么？）

往现有数组批量添加元素：

#+BEGIN_EXAMPLE
    ARY+=(a b c)
    MAP+=([a]=1 [b]=2)
#+END_EXAMPLE

取值：

#+BEGIN_EXAMPLE
    ${ARY[INDEX]}
    ${MAP[KEY]}
#+END_EXAMPLE

注意花括号的使用

=${A[@]}= 展开成所有的变量，而获取数组长度使用 =${#A[@]}=

切片：
=${ARY[@]:N:M}= N是offset而M是length

返回索引，相当于keys()：
=${!MAP[@]}=

试试下面的代码：

#+BEGIN_EXAMPLE
    declare -a ARY
    declare -A MAP
    MAP+=([a]=1 [b]=2)
    ARY+=(a b c)

    echo ${ARY[1]}
    echo ${MAP[a]}
    echo "${ARY[@]}"
    echo "${MAP[@]}"
    echo "${ARY[@]:0:1}"
    echo ${#ARY[@]}
    echo "${!MAP[@]}"

    ARY[4]=a
    echo ${ARY[@]}
    echo ${ARY[3]}
#+END_EXAMPLE

**** 变量（字符串）变换

Bash中的变量变换，大体是${变量[操作符]}的形式

***** 大小写变换

#+BEGIN_EXAMPLE
    HI=HellO

    echo "$HI" # HellO
    echo ${HI^} # HellO
    echo ${HI^^} # HELLO
    echo ${HI,} # hellO
    echo ${HI,,} # hello
    echo ${HI~} # hellO
    echo ${HI~~} #hELLo
#+END_EXAMPLE

=^=大写，=,=小写， =~=大小写切换
 重复一次只修改首字母，重复两次则应用于所有字母。

混着用会怎样？
=echo ${HI^,^} # HellO=
 看来是不行的×\_×

***** 移除匹配的字符串

=%xx= 从后往前，开始匹配，移除匹配的内容
=%%xx= 跟上面的差不多，不过这是贪婪匹配
=#xx= 从前往后，开始匹配，移除匹配的内容
=##xx= 跟上面的差不多，不过这是贪婪匹配

这个比较难理解，不过看下面几个例子应该能明白了。

#+BEGIN_EXAMPLE
    FILENAME=/home/spacewander/param.sh
    echo ${FILENAME%/*} # /home/spacewander
    echo ${FILENAME%%/*} #
    echo ${FILENAME#*/} # home/spacewander/param.sh
    echo ${FILENAME##*/} # param.sh
#+END_EXAMPLE

***** 查找并替换

=/MATCH/VALUE= 替换第一个匹配的内容。
=//MATCH/VALUE= 替换匹配的内容

#+BEGIN_EXAMPLE
    echo ${FILENAME/home/office} # /office/spacewander/param.sh
    echo ${FILENAME//s/S} # /home/Spacewander/param.Sh
#+END_EXAMPLE

**** 其它字符串操作

获取变量（字符串）长度：=${#FILENAME}=

字符串切片：跟数组切片是同样的语法，=${STR:offset:len}=

#+BEGIN_EXAMPLE
    TEXT=这个程序充满了BUG!
    echo ${TEXT:0:8}
    echo ${TEXT:4}

    # 你还可以使用负数作为offset，这时候就是从后往前算起。注意负数要用括号括起来，避免冲突。
    echo ${TEXT:(-4)}
#+END_EXAMPLE

**** 关于变量，其它的内容

Bash中有一项特性，你可以方便地检查某个变量是否设置了，如果没有设置，就赋予一个默认值。尤其在处理环境变量的时候，这项特性会让你感到欣慰。

语法是=${VAR:=VALUE}=或者=${VAR:=VALUE}=。此外，还有一个相似的语法，=${VAR:=VALUE}=和=${VAR：=VALUE}=。

下面展示下两者的区别

#+BEGIN_EXAMPLE
    # expand to default variable
    echo ${NULL-"Not null"} # Not null
    echo ${NULL} #

    # set default variable
    echo ${NIL="Not nil"} # Not nil
    echo ${NIL} # Not nil
#+END_EXAMPLE

可以看出，前者只是当变量不存在时，展开成指定的值。而后者在变量不存在时，将变量的值设置为指定值。

最后介绍一个，当目标变量不存在时，指定报错信息的语法。

#+BEGIN_EXAMPLE
    echo ${TARGET?Not Found} # 当$TARGET不存在时，显示TARGET: Not Found，并结束程序。
#+END_EXAMPLE

** [[http://orgmode.org/manual/Creating-timestamps.html][Creating timestamps]]


For Org mode to recognize timestamps, they need to be in the specific
format. All commands listed below produce timestamps in the correct
format.

C-c .     (=org-time-stamp=)

Prompt for a date and insert a corresponding timestamp. When the cursor
is at an existing timestamp in the buffer, the command is used to modify
this timestamp instead of inserting a new one. When this command is used
twice in succession, a time range is inserted.

C-c !     (=org-time-stamp-inactive=)

Like C-c ., but insert an inactive timestamp that will not cause an
agenda entry.

C-u C-c .

C-u C-c !

Like C-c . and C-c !, but use the alternative format which contains date
and time. The default time can be rounded to multiples of 5 minutes, see
the option =org-time-stamp-rounding-minutes=.

C-c C-c

Normalize timestamp, insert/fix day name if missing or wrong.

C-c <     (=org-date-from-calendar=)

Insert a timestamp corresponding to the cursor date in the Calendar.

C-c >     (=org-goto-calendar=)

Access the Emacs calendar for the current date. If there is a timestamp
in the current line, go to the corresponding date instead.

C-c C-o     (=org-open-at-point=)

Access the agenda for the date given by the timestamp or -range at point
(see
[[Weekly_002fdaily-agenda.html#Weekly_002fdaily-agenda][Weekly/daily
agenda]]).

S-<left>     (=org-timestamp-down-day=)

S-<right>     (=org-timestamp-up-day=)

Change date at cursor by one day. These key bindings conflict with
shift-selection and related modes (see
[[Conflicts.html#Conflicts][Conflicts]]).

S-<up>     (=org-timestamp-up=)

S-<down>     (=org-timestamp-down-down=)

Change the item under the cursor in a timestamp. The cursor can be on a
year, month, day, hour or minute. When the timestamp contains a time
range like ‘15:30-16:30', modifying the first time will also shift the
second, shifting the time block with constant length. To change the
length, modify the second time. Note that if the cursor is in a headline
and not at a timestamp, these same keys modify the priority of an item.
(see [[Priorities.html#Priorities][Priorities]]). The key bindings also
conflict with shift-selection and related modes (see
[[Conflicts.html#Conflicts][Conflicts]]).

C-c C-y     (=org-evaluate-time-range=)

Evaluate a time range by computing the difference between start and end.
With a prefix argument, insert result after the time range (in a table:
into the following column).

** [[https://wiki.freebsdchina.org/doc/r/reference][利用 Emacs 的 org-mode 管理文献]]

俗话说，“好记性不如烂笔头”。文献管理，不仅对科研工作者，对普通的用户也是必需的。看过的文献，写写心得做做笔记，以后写文章旁征博引的时候就不至于心乱如麻。

已有一些开源的文献管理的工具广受欢迎，如 JabRef、docear
等。一些常见的工具软件，读者可参阅
[[http://zh.wikipedia.org/wiki/文献管理软件比较][文献管理软件比较]]。

这里，我介绍另外一种简便的方法：利用 Emacs 的 org-mode
管理文献。原因有二：（1）Emacs
是可以使用一生的编辑器；（2）org-mode是做笔记的强大工具。

本着简单为美，高效为目的的原则，充分利用已有资源，本 wiki 的方法（源自
[[http://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/][http://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/]]）能够出色地完成文献管理的任务。

*** 利用 Google Scholar 导出 bibtex 文件

写科技文章，TeX 排版工具是必须掌握的。现在的国际会议和期刊，哪个不要求
TeX 排版？我们假定读者熟悉 TeX 排版，了解最简单的 Emacs 使用方法。

在 TeX 中，文献的索引来自独立文件 *.bib，它的格式必须通过 bibtex
的编译。[[https://wiki.freebsdchina.org/software/r/refdb][文献管理软件
RefDB]]介绍了如何从 RIS 格式转化为 bib 格式。RefDB
是图书馆时代的产物，随着 Google Scholar
的普及，我们有更便捷的文献管理方法。

Google Scholar 提供了搜索文献和导出其 bibtex
描述的强大功能，它在某种程度上替代了图书馆检索和某些专业数据库检索（如
PubMed
等），让更多的人能够方便地检索到文献。在知识共享的年代，我认为，Google
Scholar 是 Google 公司最伟大的产品之一。

*** 文献管理有哪些功能？

一个文献管理软件，必须具备以下几项功能。

1. bibtex 格式
2. 文章标题、作者、期刊名等关键词搜索
3. 链接到本地保存的文章（一般为 PDF 格式）
4. 做笔记（写文章的时候，笔记很重要）
5. 在 TeX 文档中利用 \cite{} 索引

*** 准备工作

我当前使用的 Emacs 版本是 GNU Emacs
24.3.1（在更低的版本上我没有试验过），自带了 RefTeX。

需要额外安装的是 /usr/ports/deskutils/org-mode.el。

建立目录 ~/reference，里面建立目录 ~/reference/papers。另外，

#+BEGIN_EXAMPLE
    IOU@~/reference$ touch notes.org
    IOU@~/reference$ touch reference.bib
#+END_EXAMPLE

要求 notes.org 文件的开头是

#+BEGIN_EXAMPLE
    # \bibliography{~/reference/reference.bib}
#+END_EXAMPLE

为了演示方便起见，reference.bib 里只有一篇文献

#+BEGIN_EXAMPLE
    @Article{     blei2012probabilistic,
      title     = {Probabilistic topic models},
      author    = {Blei, David M},
      journal   = {Communications of the ACM},
      volume    = {55},
      number    = {4},
      pages     = {77--84},
      year      = {2012},
      publisher = {ACM}
    }
#+END_EXAMPLE

该文章取名为 blei2012probabilistic.pdf，存放于 ~/reference/papers/ 下。

*** .emacs 里的一些设置

在 $HOME/.emacs 文件里，添加以下设置。

#+BEGIN_EXAMPLE
    ;; 定义 org-mode-reftex-search
    (defun org-mode-reftex-search ()
     ;; jump to the notes for the paper pointed to at from reftex search
     (interactive)
     (org-open-link-from-string (format "[[notes:%s]]" (reftex-citation t))))

    (setq org-link-abbrev-alist
     '(("bib" . "~/reference/reference.bib::%s")
       ("notes" . "~/reference/org/notes.org::#%s")
       ("papers" . "~/reference/papers/%s.pdf")))

    ;; 当使用 org-mode 时，自动调 RefTeX
    (defun org-mode-reftex-setup ()
      (load-library "reftex")
      (and (buffer-file-name) (file-exists-p (buffer-file-name))
           (progn
        ;; enable auto-revert-mode to update reftex when bibtex file changes on disk
        (global-auto-revert-mode t)
        (reftex-parse-all)
        ;; add a custom reftex cite format to insert links
        (reftex-set-cite-format
          '((?b . "[[bib:%l][%l-bib]]")
            (?c . "\\cite{%l}")
            (?n . "[[notes:%l][%l-notes]]")
            (?p . "[[papers:%l][%l-paper]]")
            (?t . "%t")
            (?h . "** %t\n:PROPERTIES:\n:Custom_ID: %l\n:END:\n[[papers:%l][%l-paper]]")))))
      (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
      ;; binding of  ”C-c (” to org-mode-reftex-search
      (define-key org-mode-map (kbd "C-c (") 'org-mode-reftex-search))

    (add-hook 'org-mode-hook 'org-mode-reftex-setup)
#+END_EXAMPLE

*** 如何使用 notes.org 来管理文献

org-mode 是利用 Emacs 做笔记的强大工具，可以直接生成 html、TeX、PDF
等文档。

-  用 emacs 打开 notes.org 文件，将光标放置于某空行，利用命令 “C-c )”
   来建立文献索引入口，可以是 bibtex 的入口，也可以是 PDF
   文件的入口，也可以是 \cite{}。
-  命令 ”C-c (“ 可进行正则表达式搜索
-  要打开入口，只需光标停留在入口上，键入 “C-c C-o” 命令即可。
-  利用命令 “C-c \” 来搜索关键词。

*** 效果图

[[https://wiki.freebsdchina.org/_detail/doc/r/reference.png?id=doc%3Ar%3Areference][[[https://wiki.freebsdchina.org/_media/doc/r/reference.png]]]]

** [[http://hyry.dip.jp/tech/slice/slice.html/35][IPython Notebook简介1]]

作者 : [[/tech/default/userpage.html/1][RY]]    标签:
[[/tech/default/tag.html/43][cython]]
[[/tech/default/tag.html/150][ipython-notebook]]

IPython
notebook目前已经成为用Python做教学、计算、科研的一个重要工具。本文介绍IPython
notebook的一些基本用法，以及如何使用它调试Cython程序。

IPython
Notebook使用浏览器作为界面，向后台的IPython服务器发送请求，并显示结果。在浏览器的界面中使用单元(Cell)保存各种信息。Cell有多种类型，经常使用的有表示格式化文本的[[http://daringfireball.net/projects/markdown/][Markdown]]单元，和表示代码的Code单元。

每个代码单元都有一个输出区域，在Code单元中输入代码，按 Shift-Enter
将运行此代码，代码中最后一个表达式的值将输出区域显示。如果希望屏蔽输出，可以在最后一条语句之后添加一个分号：”;”。此外，代码中还可以使用print语句在输出区域中显示信息。

在Markdown单元中还可以直接使用Html和Javascript。

*** 数学公式[[#id1][¶]]

在Markdown单元中可以使用LaTeX表示数学公式，例如[[/tech/static/math/ae8e52c9ff91d739a507e91fb1b70c27cf2af9a8.png]]。数学公式的显示使用MathJax，缺省情况下，MathJax从网络上下载，如果希望离线使用它，需要在IPython
Notebook中输入如下代码，把MathJax安装到本地磁盘中：

#+BEGIN_EXAMPLE
    from IPython.external.mathjax import install_mathjax
    install_mathjax()
#+END_EXAMPLE

Code单元的输出也可以显示为数学公式，例如在单元中输入如下代码，将显示为数学公式：

#+BEGIN_EXAMPLE
    from IPython.display import Latex
    Latex(r"$\sqrt{x^2+y^2}$")
#+END_EXAMPLE

[[/tech/static/math/8e7330cd9a445a585420f18a9d11cd97487620fb.png]]

SymPy的表达式也可以显示为LaTex，例如：

#+BEGIN_EXAMPLE
    %load_ext sympyprinting
    from sympy import *
    x, y = symbols("x,y")
    sqrt(x**2+y**2)
#+END_EXAMPLE

[[/tech/static/math/e8fc92a726c6078a31066d0d8c90589f872b4927.png]]

以%开头的为IPython的命令(Magic
Command)，这里通过%load\_ext命令载入sympyprinting扩展插件，载入此插件之后，所有的SymPy表达式都显示为数学公式。

*** 各种显示[[#id2][¶]]

IPython.display模块中提供了许多显示Python返回值的类，例如下面的代码用Image类显示”python.png”图片，缺省路径为Notebook文件所在的目录：

#+BEGIN_EXAMPLE
    from IPython.display import Image
    Image(filename="python.png")
#+END_EXAMPLE

Image还可以用来显示表示图像的字符串。例如下面的代码通过cv2的imencode()将NumPy数组转换为一个表示PNG图像数据的数组，然后将此数组转换为字符串之后通过Image()将显示为图像：

#+BEGIN_EXAMPLE
    import cv2
    import numpy as np
    from IPython.display import Image
    img = np.random.randint(0,255,(250,250,3))
    cv2.blur(img, (11,11), img)
    r, dat = cv2.imencode(".png",img)
    Image(dat.tostring())
#+END_EXAMPLE

[[/tech/static/uploads/attachs.file/bb/attachs.file.bb603f00e2af3231.6f70656e63765f696d6167652e706e67.png]]

此外，还可以通过HTML和Javascript将Python代码的输出显示为Html，或者作为Javascript运行。

#+BEGIN_EXAMPLE
    from IPython.display import Javascript
    Javascript("alert('ok')")
#+END_EXAMPLE

将在浏览器中运行Javascript代码。

*** Magic命令[[#magic][¶]]

IPython中Magic命令有两种执行方式，以%开始的命令被称为行命令，它只对单行有效，以%%开头的为单元命令，它放在单元的第一行，对整个单元有效。例如*timeit*命令可以快速测试代码的执行效率，它可以作为行命令或者单元命令。

#+BEGIN_EXAMPLE
    %timeit 1 + 1
    %timeit 1.0 + 1.0
    %timeit "1" + "1"
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    10000000 loops, best of 3: 52 ns per loop
    10000000 loops, best of 3: 53.4 ns per loop
    10000000 loops, best of 3: 50.9 ns per loop
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    %%timeit
    s = 0
    for i in xrange(100):
        s += i
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    100000 loops, best of 3: 11 us per loop
#+END_EXAMPLE

每个Magic命令都可以指定参数，可以输入=timeit?=查看其帮助文档。下面让我们看看一些常用的Magic命令。

*%pylab*命令将载入numpy和pylab，并且将这两个模块中的名字载入到全局名字空间中。缺省参数时，它使用matplotlib的缺省界面库显示图表，如果带*inline*参数则将图表作为图像插入到Notebook中。使用界面库显示图像时可以使用交互工具，而将图表直接插入到Notebook中则有利于编写文档。

下面的例子，=plot=和=random=是从pylab和numpy中载入的。

#+BEGIN_EXAMPLE
    %pylab inline
    plot(random.randn(100));
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    Welcome to pylab, a matplotlib-based Python environment [backend: module://IPython.zmq.pylab.backend_inline].
    For more information, type 'help(pylab)'.
#+END_EXAMPLE

[[/tech/static/uploads/attachs.file/ae/attachs.file.ae67551cd095fdb0.70796c61625f696d672e706e67.png]]

*%load*可以从文件或者网址载入代码到一个新的单元中，例如下面载入某个matplotlib的示例程序，并执行：

#+BEGIN_EXAMPLE
    %load http://matplotlib.org/mpl_examples/pylab_examples/histogram_demo.py
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    #!/usr/bin/env python
    import numpy as np
    import matplotlib.mlab as mlab
    import matplotlib.pyplot as plt

    mu, sigma = 100, 15
    x = mu + sigma*np.random.randn(10000)

    # the histogram of the data
    n, bins, patches = plt.hist(x, 50, normed=1, facecolor='green', alpha=0.75)

    # add a 'best fit' line
    y = mlab.normpdf( bins, mu, sigma)
    l = plt.plot(bins, y, 'r--', linewidth=1)

    plt.xlabel('Smarts')
    plt.ylabel('Probability')
    plt.title(r'$\mathrm{Histogram\ of\ IQ:}\ \mu=100,\ \sigma=15$')
    plt.axis([40, 160, 0, 0.03])
    plt.grid(True)

    plt.show()
#+END_EXAMPLE

[[/tech/static/uploads/attachs.file/b0/attachs.file.b0e4f94453ee2ff0.686973745f696d672e706e67.png]]

*%prun*用于代码的执行性能分析，可以作为行命令和单元命令使用。下面的程序分析=numpy.linalg.det()=的性能：

#+BEGIN_EXAMPLE
    %%prun
    for i in xrange(100):
        linalg.det(random.rand(10,10))
#+END_EXAMPLE

其输出如下：

#+BEGIN_EXAMPLE
    3402 function calls in 0.096 seconds

    Ordered by: internal time

    ncalls  tottime  percall  cumtime  percall filename:lineno(function)
       100    0.032    0.000    0.091    0.001 linalg.py:1560(slogdet)
       300    0.022    0.000    0.022    0.000 {method 'reduce' of 'numpy.ufunc' objects}
       200    0.011    0.000    0.012    0.000 numeric.py:167(asarray)
       100    0.006    0.000    0.006    0.000 linalg.py:84(_realType)
       100    0.005    0.000    0.005    0.000 linalg.py:151(_assertRank2)
       ...
#+END_EXAMPLE

*%load\_ext*载入IPython的扩展模块，通过它可以载入更多的Magic命令。下面我们载入*cythonmagic*模块，并使用*%%cython*命令编译一个高效的频率统计函数=count()=。

#+BEGIN_EXAMPLE
    %load_ext cythonmagic
#+END_EXAMPLE

*** 测试Cython代码[[#cython][¶]]

Cython的代码基本和Python的代码类似，但是可以使用类型声明，Cython可以使用这些类型声明产生更高效的C语言代码，并编译成Python的扩展模块。使用*%%cython*命令简化了编译扩展模块的过程，它会自动创建C语言程序，编译并载入。由于扩展模块无法卸载，因此IPython采用的策略是每次编译不同的代码都会产生一个全新的扩展模块。方便我们不退出Python环境即可运行新的代码。

#+BEGIN_EXAMPLE
    %%cython
    def count(list data):
        cdef:
            dict result = {}
            int i, length = len(data)
            object item

        for i in range(length):
            item = data[i]
            if item in result:
                (<list> result[item]).append(i)
            else:
                result[item] = [i]
        return result
#+END_EXAMPLE

下面是=count()=的Python版本。

#+BEGIN_EXAMPLE
    from collections import defaultdict
    def countpy(data):
        result = defaultdict(list)
        for i,item in enumerate(data):
            result[item].append(i)
        return result
#+END_EXAMPLE

先测试二者的结果是否相同：

#+BEGIN_EXAMPLE
    import random
    data = [random.randint(0,100) for _ in xrange(10000)]
    count(data) == countpy(data)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    True
#+END_EXAMPLE

然后测试它们的执行速度，可以看出Cython版本比Python的要快2倍多。在这个测试中，Cython程序也同样使用列表和字典等对象，但是由于可以直接调用Python的C
API，因此Cython版本的效率能提高几倍。如果只是单纯的数值运算，Cython能将程序提升到与C语言相近的速度。

#+BEGIN_EXAMPLE
    %timeit countpy(data)
    %timeit count(data)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    100 loops, best of 3: 4.52 ms per loop
    1000 loops, best of 3: 1.8 ms per loop
#+END_EXAMPLE

** [[http://my.oschina.net/jayzonex/blog/13579?fromerr=1K6znGs4][74HC573锁存器用法]]

[[http://www.oschina.net/search?scope=blog&q=74HC573][74HC573]]
[[http://www.oschina.net/search?scope=blog&q=%E9%94%81%E5%AD%98%E5%99%A8][锁存器]]

锁存器 介绍

如果单片机的总线接口只作一种用途，不需要接锁存器；如果单片机的总线接口要作两种用途，就要用两个锁存器。例如：一个口要控制两个
LED，对第一个 LED
送数据时，“打开”第一个锁存器而“锁住”第二个锁存器，使第二个 LED
上的数据不变。对第二个 LED
送数据时，“打开”第二个锁存器而“锁住”第一个锁存器，使第一个 LED
上的数据不变。如果单片机的一个口要做三种用途，则可用三个锁存器，操作过程相似。然而在实际应用中，我们并不这样做，只用一个锁存器就可以了，并用一根
I/O 口线作为对锁存器的控制之用（接 74373
的ＬＥ，而ＯＥ可恒接地）。所以，就这一种用法而言，可以把锁存器视为单片机的
I/O 口的扩展器。
 更多信息请看 http://baike.baidu.com/view/629932.htm?fr=ala0\_1\_1
 74hc573 引脚图

[[http://my.oschina.net/uploads/space/2011/0224/141233_KOut_105484.jpg]]
   
 1脚是输出使能
 11脚是锁存使能
 D是输入
 Q是输出
 Ｈ是高电平，L是低
 /OE是1脚 LE是11脚
 /OE 接低电平，使芯片内部数据保持器输出端与芯片8位输出端之间连通。
 LE
端的作用是通过高低电平控制8位输入与内部数据保持器输入端的连通与断开。
 当 LE = 0 时，P0端口的8位数据线与74HC573内部数据保持器的输入端断开。
 当 LE = 1 时，P0端口的8位数据线与74HC573内部数据保持器的输入端连通

** [[http://blog.sina.com.cn/s/blog_57132a730100phfw.html][定义自己的浮动体]]

对于浮动体的认识，很多初学者觉得比较困难，主要是平时接触不到这个概念。
浮动体可以比作是一个可以在文章里移动的盒子，不同的盒子里面放的东西略有差异。为什么移动？这个问题很多朋友询问，说简单点，就是为了排版的美观。为什么浮动（移动）了就可以排版得美观了。
    在使用字处理软件排版时，使用者可以让图形准确出现在放置的位置。但是，因为这些图形不能被分割开来，所以经常会导致糟糕的分页，将大片的空白留在页面下方。为得到专家级的排版效果，作者不得不手工调整图形的位置。这种工作是非常乏味的，尤其是几乎每次修改文档都得这样做一次。
    为了既能得到专家级的排版效果，又不必手工做调整图形位置的乏味的工作， LATEX 提供了一个浮动图形机制来自动将图形放置到合适的位置。这一机制是非常有效的。不过，它也会给那些习惯于手工调整图形的新手带来麻烦。
---选自《latex插图指南》
另外，它还有其他好处：
1.在浮动环境中，图片或者表格等等需要浮动的内容可以自动编号。
2.浮动体内容可以被引用和放入目录中。
3.排版更加美观。

如何创建一个自己的浮动环境呢？
如下示例：
documentclass[12pt]{article}
usepackage{float}
newfloat{Eq}{H}{eqn}
begin{document}
begin{Eq}
begin{equation}
y=f(x)
end{equation}
caption{my first equation}
end{Eq}
begin{Eq}
begin{equation}
y=f(x) end{equation}
caption{my second equation}
end{Eq}
listof{Eq}{list of  equations}

end{document}

** [[http://linuxtools-rst.readthedocs.org/zh_CN/latest/tool/crontab.html][crontab 定时任务[[#crontab][¶]]]]

通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell
script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。

*** 19.1. 命令格式[[#id2][¶]]

crontab [-u user] [ -e | -l | -r ]

*** 19.2. 命令参数[[#id3][¶]]

-  -u user：用来设定某个用户的crontab服务；
-  file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。
-  -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。
-  -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。
-  -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。
-  -i：在删除用户的crontab文件时给确认提示。

*** 19.3. crontab的文件格式[[#id4][¶]]

分 时 日 月 星期 要运行的命令

-  第1列分钟1～59
-  第2列小时1～23（0表示子夜）
-  第3列日1～31
-  第4列月1～12
-  第5列星期0～6（0表示星期天）
-  第6列要运行的命令

*** 19.4. 常用方法[[#id5][¶]]

**** 创建一个新的crontab文件[[#id6][¶]]

向cron进程提交一个crontab文件之前，首先要设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。9
9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$HOME目录下的.
profile文件，在其中加入这样一行:

#+BEGIN_EXAMPLE
    EDITOR=vi; export EDITOR
#+END_EXAMPLE

然后保存并退出。不妨创建一个名为<user>
cron的文件，其中<user>是用户名，例如，
davecron。在该文件中加入如下的内容。

#+BEGIN_EXAMPLE
    # (put your own initials here)echo the date to the console every
    # 15minutes between 6pm and 6am
    0,15,30,45 18-06 * * * /bin/echo 'date' > /dev/console
#+END_EXAMPLE

保存并退出。注意前面5个域用空格分隔。

在上面的例子中，系统将每隔1
5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数:

#+BEGIN_EXAMPLE
    $ crontab davecron
#+END_EXAMPLE

现在该文件已经提交给cron进程，它将每隔1
5分钟运行一次。同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。

**** 列出crontab文件[[#id7][¶]]

使用-l参数列出crontab文件:

#+BEGIN_EXAMPLE
    $ crontab -l
    0,15,30,45,18-06 * * * /bin/echo `date` > dev/tty1
#+END_EXAMPLE

可以使用这种方法在$HOME目录中对crontab文件做一备份:

#+BEGIN_EXAMPLE
    $ crontab -l > $HOME/mycron
#+END_EXAMPLE

这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。

**** 编辑crontab文件[[#id8][¶]]

如果希望添加、删除或编辑crontab文件中的条目，而EDITOR环境变量又设置为vi，那么就可以用vi来编辑crontab文件:

#+BEGIN_EXAMPLE
    $ crontab -e
#+END_EXAMPLE

可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时，
cron会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。
我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：

#+BEGIN_EXAMPLE
    # DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month
    30 3 1,7,14,21,26 * * /bin/find -name 'core' -exec rm {} \;
#+END_EXAMPLE

保存并退出。

注解

最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的定时作业。

**** 删除crontab文件[[#id9][¶]]

#+BEGIN_EXAMPLE
    $crontab -r
#+END_EXAMPLE

*** 19.5. 使用实例[[#id10][¶]]

**** 实例1：每1分钟执行一次myCommand[[#mycommand][¶]]

#+BEGIN_EXAMPLE
    * * * * * myCommand
#+END_EXAMPLE

**** 实例2：每小时的第3和第15分钟执行[[#id11][¶]]

#+BEGIN_EXAMPLE
    3,15 * * * * myCommand
#+END_EXAMPLE

**** 实例3：在上午8点到11点的第3和第15分钟执行[[#id12][¶]]

#+BEGIN_EXAMPLE
    3,15 8-11 * * * myCommand
#+END_EXAMPLE

**** 实例4：每隔两天的上午8点到11点的第3和第15分钟执行[[#id13][¶]]

#+BEGIN_EXAMPLE
    3,15 8-11 */2  *  * myCommand
#+END_EXAMPLE

**** 实例5：每周一上午8点到11点的第3和第15分钟执行[[#id14][¶]]

#+BEGIN_EXAMPLE
    3,15 8-11 * * 1 myCommand
#+END_EXAMPLE

**** 实例6：每晚的21:30重启smb[[#smb][¶]]

#+BEGIN_EXAMPLE
    30 21 * * * /etc/init.d/smb restart
#+END_EXAMPLE

**** 实例7：每月1、10、22日的4 : 45重启smb[[#id15][¶]]

#+BEGIN_EXAMPLE
    45 4 1,10,22 * * /etc/init.d/smb restart
#+END_EXAMPLE

**** 实例8：每周六、周日的1 : 10重启smb[[#id16][¶]]

#+BEGIN_EXAMPLE
    10 1 * * 6,0 /etc/init.d/smb restart
#+END_EXAMPLE

**** 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb[[#id17][¶]]

#+BEGIN_EXAMPLE
    0,30 18-23 * * * /etc/init.d/smb restart
#+END_EXAMPLE

**** 实例10：每星期六的晚上11 : 00 pm重启smb[[#pmsmb][¶]]

#+BEGIN_EXAMPLE
    0 23 * * 6 /etc/init.d/smb restart
#+END_EXAMPLE

**** 实例11：每一小时重启smb[[#id18][¶]]

#+BEGIN_EXAMPLE
    * */1 * * * /etc/init.d/smb restart
#+END_EXAMPLE

**** 实例12：晚上11点到早上7点之间，每隔一小时重启smb[[#id19][¶]]

#+BEGIN_EXAMPLE
    * 23-7/1 * * * /etc/init.d/smb restart
#+END_EXAMPLE

*** 19.6. 使用注意事项[[#id20][¶]]

**** 注意环境变量问题[[#id21][¶]]

有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。

在crontab文件中定义多个调度任务时，需要特别注环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。

不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：

1. 脚本中涉及文件路径时写全局路径；

2. 脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如:

   #+BEGIN_EXAMPLE
       cat start_cbp.sh
       !/bin/sh
       source /etc/profile
       export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf
       /usr/local/jboss-4.0.5/bin/run.sh -c mev &
   #+END_EXAMPLE

3）当手动执行脚本OK，但是crontab死活不执行时,很可能是环境变量惹的祸，可尝试在crontab中直接引入环境变量解决问题。如:

#+BEGIN_EXAMPLE
    0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh
#+END_EXAMPLE

**** 注意清理系统用户的邮件日志[[#id22][¶]]

每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。
例如，可以在crontab文件中设置如下形式，忽略日志输出:

#+BEGIN_EXAMPLE
    0 */3 * * * /usr/local/apache2/apachectl restart >/dev/null 2>&1
#+END_EXAMPLE

“/dev/null
2>&1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。

**** 系统级任务调度与用户级任务调度[[#id23][¶]]

系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过”crontab
--uroot
--e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。

**** 其他注意事项[[#id24][¶]]

新创建的cron
job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。

当crontab失效时，可以尝试/etc/init.d/crond
restart解决问题。或者查看日志看某个job有没有执行/报错tail -f
/var/log/cron。

千万别乱运行crontab
-r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。

在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date
‘+%Y%m%d'在crontab里是不会执行的，应该换成date ‘+%Y%m%d'。

更新系统时间时区后需要重启cron,在ubuntu中服务名为cron:

#+BEGIN_EXAMPLE
    $service cron restart
#+END_EXAMPLE

ubuntu下启动、停止与重启cron:

#+BEGIN_EXAMPLE
    $sudo /etc/init.d/cron start
    $sudo /etc/init.d/cron stop
    $sudo /etc/init.d/cron restart
#+END_EXAMPLE

** [[http://www.cnblogs.com/rollenholt/archive/2012/04/23/2466179.html][关于python文件操作]]

2012-04-23 11:28 by Rollen Holt, ... 阅读, ... 评论, [[#][收藏]],
[[http://i.cnblogs.com/EditPosts.aspx?postid=2466179][编辑]]

总是记不住API。昨晚写的时候用到了这些，但是没记住，于是就索性整理一下吧：

*python中对文件、文件夹**（文件操作函数）**的操作需要涉及到os模块和shutil模块。*

得到当前工作目录，即当前Python脚本工作的目录路径: *os.getcwd()*

返回指定目录下的所有文件和目录名:*os.listdir()*

函数用来删除一个文件:*os.remove()*

删除多个目录：*os.removedirs（r“c：\python”）*

检验给出的路径是否是一个文件：*os.path.isfile()*

检验给出的路径是否是一个目录：*os.path.isdir()*

判断是否是绝对路径：*os.path.isabs()*

检验给出的路径是否真地存:*os.path.exists()*

返回一个路径的目录名和文件名:*os.path.split()  *   eg
os.path.split('/home/swaroop/byte/code/poem.txt')
结果：('/home/swaroop/byte/code', 'poem.txt') 

分离扩展名：*os.path.splitext()*

获取路径名：*os.path.dirname()*

获取文件名：*os.path.basename()*

运行shell命令: *os.system()*

读取和设置环境变量:*os.getenv() 与os.putenv()*

给出当前平台使用的行终止符:*os.linesep    *Windows使用'\r\n'，Linux使用'\n'而Mac使用'\r'

指示你正在使用的平台：*os.name *     
对于Windows，它是'nt'，而对于Linux/Unix用户，它是'posix'

重命名：*os.rename（old， new）*

创建多级目录：*os.makedirs（r“c：\python\test”）*

创建单个目录：*os.mkdir（“test”）*

获取文件属性：*os.stat（file）*

修改文件权限与时间戳：*os.chmod（file）*

终止当前进程：*os.exit（）*

获取文件大小：*os.path.getsize（filename）*

*文件操作：*
*os.mknod("test.txt") *       创建空文件
*fp = open("test.txt",w)  *   直接打开一个文件，如果文件不存在则创建文件

关于open 模式：

w     以写方式打开，
a     以追加模式打开 (从 EOF 开始, 必要时创建新文件)
r+     以读写模式打开
w+     以读写模式打开 (参见 w )
a+     以读写模式打开 (参见 a )
rb     以二进制读模式打开
wb     以二进制写模式打开 (参见 w )
ab     以二进制追加模式打开 (参见 a )
rb+    以二进制读写模式打开 (参见 r+ )
wb+    以二进制读写模式打开 (参见 w+ )
ab+    以二进制读写模式打开 (参见 a+ )

 

*fp.read([size])  *                   #size为读取的长度，以byte为单位

*fp.readline([size])  *              
#读一行，如果定义了size，有可能返回的只是一行的一部分

*fp.readlines([size])   *            
#把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。

*fp.write(str)  / /*                  
#把str写到文件中，write()并不会在str后加上一个换行符

*fp.writelines(seq)    *       
#把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。

*fp.close()   *                    
#关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 
如果一个文件在关闭后还对其进行操作会产生ValueError

*fp.flush()   *                                  
#把缓冲区的内容写入硬盘

*fp.fileno()    *                                 
#返回一个长整型的”文件标签“

*fp.isatty()    *                                 
#文件是否是一个终端设备文件（unix系统中的）

*fp.tell()*                                        
#返回文件操作标记的当前位置，以文件的开头为原点

*fp.next()    *                                  
#返回下一行，并将文件操作标记位移到下一行。把一个file用于for ... in
file这样的语句时，就是调用next()函数来实现遍历的。

*fp.seek(offset[,whence])  *           
#将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。

*fp.truncate([size])   *                   
#把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。

 

*目录操作：*
*os.mkdir("file")     *              创建目录
复制文件：
*shutil.copyfile("oldfile","newfile") *     
oldfile和newfile都只能是文件
*shutil.copy("oldfile","newfile")   *        
oldfile只能是文件夹，newfile可以是文件，也可以是目标目录
复制文件夹：
*shutil.copytree("olddir","newdir") *      
olddir和newdir都只能是目录，且newdir必须不存在
重命名文件（目录）
*os.rename("oldname","newname") *      文件或目录都是使用这条命令
移动文件（目录）
*shutil.move("oldpos","newpos")   *
删除文件
*os.remove("file")*
删除目录
*os.rmdir("dir")*只能删除空目录
*shutil.rmtree("dir")  *  空目录、有内容的目录都可以删
转换目录
*os.chdir("path")   *换路径

 

*相关例子 *

* 1 *将文件夹下所有图片名称加上'\_fc'

*/python代码:/*

# -*- coding:utf-8 -*-
import re
import os
import time
#str.split(string)分割字符串
#'连接符'.join(list) 将列表组成字符串
def change\_name(path):
    global i
    if not os.path.isdir(path) and not os.path.isfile(path):
        return False
    if os.path.isfile(path):
        file\_path = os.path.split(path) #分割出目录与文件
        lists = file\_path[1].split('.') #分割出文件与文件扩展名
        file\_ext = lists[-1] #取出后缀名(列表切片操作)
        img\_ext = ['bmp','jpeg','gif','psd','png','jpg']
        if file\_ext in img\_ext:
            os.rename(path,file\_path[0]+'/'+lists[0]+'\_fc.'+file\_ext)
            i+=1 #注意这里的i是一个陷阱
        #或者
        #img\_ext = 'bmp|jpeg|gif|psd|png|jpg'
        #if file\_ext in img\_ext:
        #    print('ok---'+file\_ext)
    elif os.path.isdir(path):
        for x in os.listdir(path):
           
change\_name(os.path.join(path,x)) #os.path.join()在路径处理上很有用

img\_dir = 'D:\\xx\\xx\\images'
img\_dir = img\_dir.replace('\\','/')
start = time.time()
i = 0
change\_name(img\_dir)
c = time.time() - start
print('程序运行耗时:%0.2f'%(c))
print('总共处理了 %s 张图片'%(i))

输出结果：

程序运行耗时:0.11
总共处理了 109 张图片

** [[http://www.wklken.me/posts/2015/03/03/python-base-datetime.html#1-datetime][Python-基础-时间日期处理小结]]

好久没写文了, 继续清理笔记, 都是一些小结之类的,
源码分析以及在做系统中一些细节难点等, 后续逐步发

另外打个广告, [[http://www.itianpin.com/join][甜品礼物]], 坐标深圳,
有兴趣的同学可以给我发邮件, 非python职位会转到对应同事:)

#+BEGIN_EXAMPLE
          _       _       _   _
         | |     | |     | | (_)
       __| | __ _| |_ ___| |_ _ _ __ ___   ___
      / _` |/ _` | __/ _ \ __| | '_ ` _ \ / _ \
     | (_| | (_| | ||  __/ |_| | | | | | |  __/
      \__,_|\__,_|\__\___|\__|_|_| |_| |_|\___|
#+END_EXAMPLE

--------------

原则, 以=datetime=为中心, 起点或中转, 转化为目标对象,
涵盖了大多数业务场景中需要的日期转换处理

步骤:

#+BEGIN_EXAMPLE
    1. 掌握几种对象及其关系
    2. 了解每类对象的基本操作方法
    3. 通过转化关系转化
#+END_EXAMPLE

*** 涉及对象

**** 1. datetime

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> now = datetime.datetime.now()
    >>> now
    datetime.datetime(2015, 1, 12, 23, 9, 12, 946118)
    >>> type(now)
    <type 'datetime.datetime'>
#+END_EXAMPLE

**** 2. timestamp

#+BEGIN_EXAMPLE
    >>> import time
    >>> time.time()
    1421075455.568243
#+END_EXAMPLE

**** 3. time tuple

#+BEGIN_EXAMPLE
    >>> import time
    >>> time.localtime()
    time.struct_time(tm_year=2015, tm_mon=1, tm_mday=12, tm_hour=23, tm_min=10, tm_sec=30, tm_wday=0, tm_yday=12, tm_isdst=0)
#+END_EXAMPLE

**** 4. string

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    '2015-01-12 23:13:08'
#+END_EXAMPLE

**** 5. date

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().date()
    datetime.date(2015, 1, 12)
#+END_EXAMPLE

*** datetime基本操作

***** 1. 获取当前datetime

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now()
    datetime.datetime(2015, 1, 12, 23, 26, 24, 475680)
#+END_EXAMPLE

***** 2. 获取当天date

#+BEGIN_EXAMPLE
    >>> datetime.date.today()
    datetime.date(2015, 1, 12)
#+END_EXAMPLE

***** 3. 获取明天/前N天

明天

#+BEGIN_EXAMPLE
    >>> datetime.date.today() + datetime.timedelta(days=1)
    datetime.date(2015, 1, 13)
#+END_EXAMPLE

三天前

#+BEGIN_EXAMPLE
    >>> datetime.datetime.now()
    datetime.datetime(2015, 1, 12, 23, 38, 55, 492226)
    >>> datetime.datetime.now() - datetime.timedelta(days=3)
    datetime.datetime(2015, 1, 9, 23, 38, 57, 59363)
#+END_EXAMPLE

***** 4. 获取当天开始和结束时间(00:00:00 23:59:59)

#+BEGIN_EXAMPLE
    >>> datetime.datetime.combine(datetime.date.today(), datetime.time.min)
    datetime.datetime(2015, 1, 12, 0, 0)
    >>> datetime.datetime.combine(datetime.date.today(), datetime.time.max)
    datetime.datetime(2015, 1, 12, 23, 59, 59, 999999)
#+END_EXAMPLE

***** 5. 获取两个datetime的时间差

#+BEGIN_EXAMPLE
    >>> (datetime.datetime(2015,1,13,12,0,0) - datetime.datetime.now()).total_seconds()
    44747.768075
#+END_EXAMPLE

***** 6. 获取本周/本月/上月最后一天

本周

#+BEGIN_EXAMPLE
    >>> today = datetime.date.today()
    >>> today
    datetime.date(2015, 1, 12)
    >>> sunday = today + datetime.timedelta(6 - today.weekday())
    >>> sunday
    datetime.date(2015, 1, 18)
#+END_EXAMPLE

本月

#+BEGIN_EXAMPLE
    >>> import calendar
    >>> today = datetime.date.today()
    >>> _, last_day_num = calendar.monthrange(today.year, today.month)
    >>> last_day = datetime.date(today.year, today.month, last_day_num)
    >>> last_day
    datetime.date(2015, 1, 31)
#+END_EXAMPLE

获取上个月的最后一天(可能跨年)

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> today = datetime.date.today()
    >>> first = datetime.date(day=1, month=today.month, year=today.year)
    >>> lastMonth = first - datetime.timedelta(days=1)
#+END_EXAMPLE

*** 关系转换

几个关系之间的转化

=Datetime Object / String / timestamp / time tuple=

*** 关系转换例子

***** datetime <=> string

datetime -> string

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    '2015-01-12 23:13:08'
#+END_EXAMPLE

string -> datetime

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.strptime("2014-12-31 18:20:10", "%Y-%m-%d %H:%M:%S")
    datetime.datetime(2014, 12, 31, 18, 20, 10)
#+END_EXAMPLE

--------------

***** datetime <=> timetuple

datetime -> timetuple

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().timetuple()
    time.struct_time(tm_year=2015, tm_mon=1, tm_mday=12, tm_hour=23, tm_min=17, tm_sec=59, tm_wday=0, tm_yday=12, tm_isdst=-1)
#+END_EXAMPLE

timetuple -> datetime

#+BEGIN_EXAMPLE
    timetuple => timestamp => datetime [看后面datetime<=>timestamp]
#+END_EXAMPLE

--------------

***** datetime <=> date

datetime -> date

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().date()
    datetime.date(2015, 1, 12)
#+END_EXAMPLE

date -> datetime

#+BEGIN_EXAMPLE
    >>> datetime.date.today()
    datetime.date(2015, 1, 12)
    >>> today = datetime.date.today()
    >>> datetime.datetime.combine(today, datetime.time())
    datetime.datetime(2015, 1, 12, 0, 0)
    >>> datetime.datetime.combine(today, datetime.time.min)
    datetime.datetime(2015, 1, 12, 0, 0)
#+END_EXAMPLE

--------------

***** datetime <=> timestamp

datetime -> timestamp

#+BEGIN_EXAMPLE
    >>> now = datetime.datetime.now()
    >>> timestamp = time.mktime(now.timetuple())
    >>> timestamp
    1421077403.0
#+END_EXAMPLE

timestamp -> datetime

#+BEGIN_EXAMPLE
    >>> datetime.datetime.fromtimestamp(1421077403.0)
    datetime.datetime(2015, 1, 12, 23, 43, 23)
#+END_EXAMPLE

** [[http://www.cyberciti.biz/howto/question/general/linux-unix-list-common-environment-variables.php][Linux/UNIX list of common environment variables]]

Environment variables are a variable key pair stored in the shell's
environment space. Here is a list of common environment variables:

| *Variable*          | *Description*                                                                          |
| HISTFILE            | The name of the file in which command history is saved                                 |
| HISTFILESIZE        | The maximum number of lines contained in the history file                              |
| HOSTNAME            | The system's host name                                                                 |
| LD\_LIBRARY\_PATH   | It is a colon-separated set of directories where libraries should be searched for      |
| PS1                 | Your default (first) shell prompt                                                      |
| USER                | Current logged in user's name.                                                         |
| PATH                | Colon separated list of directories to search for binaries.                            |
| DISPLAY             | Network name of the X11 display to connect to, if available.                           |
| SHELL               | The current shell.                                                                     |
| TERM                | The name of the user's terminal. Used to determine the capabilities of the terminal.   |
| TERMCAP             | Database entry of the terminal escape codes to perform various terminal functions.     |
| OSTYPE              | Type of operating system.                                                              |
| MACHTYPE            | The CPU architecture that the system is running on.                                    |
| EDITOR              | The user's preferred text editor.                                                      |
| PAGER               | The user's preferred text pager.                                                       |
| MANPATH             | Colon separated list of directories to search for manual pages.                        |

** [[http://www.programgo.com/article/30302508918/][树莓派(raspberry pi) 系统在SD卡上安装Linux]]

*标签*:
[[/tag/android/748055864/;jsessionid=EFDE80EBE83A01CC45841A76E59F8D40][android系统手机的sd卡分区教程]]  
[[/tag/android/610167617/;jsessionid=EFDE80EBE83A01CC45841A76E59F8D40][raspberry
pi android]]  
[[/tag/android/877413287/;jsessionid=EFDE80EBE83A01CC45841A76E59F8D40][android系统sd卡分区教程]]  

*转自*:
[[http://blog.csdn.net/berryreload/article/details/7983713][http://blog.csdn.net/berryreload/article/details/7983713]]

刚刚拿到一只Simon同学出借的树莓派(raspberry pi)
，准备一张4GB的SD卡，准备跑一下Linux。

在Windows 7上用
工具 [[https://launchpad.net/win32-image-writer/+download][Win32DiskImager]]写入img到SD卡上，报错，失败。

好在俺有Linux vmware虚拟机，在虚拟机上搞，执行命令 sudo dd bs=1M
if=2012-12-16-wheezy-raspbian.img  of=/dev/sdb

tips:

错误：接电启动树莓派，派上只有红色的Power灯亮，HDMI电视机上没有输出。

原因：在Linux上执行dd命令的时候，应该是把操作系统镜像写到SD卡（硬盘上），而不是写到某个硬盘分区上。of=/dev/sdb
误写成of=/dev/sdb1了。

当时写完后，我还纳闷呢，怎么Linux
 fdisk上这个SD卡还显示只有一个vfat分区，而不是多个Linux分区呢。

解决办法：首先fdisk /dev/sdb，删除vfat分区；然后执行dd命令写入镜像  sudo
dd bs=1M if=2012-12-16-wheezy-raspbian.img of=/dev/sdb

#Raspian安装Chrome
1,wget http://goo.gl/go5yx -O install.sh
2,chmod a+x install.sh
3,./install.sh
4,chrome -disable-ipv6 & (& for running at background)
5,error loading libsmime3.so->try sudo apt-get update then redo step 3
#Raspian安装中文输入法SCIM (Smart Common Input Method)
1,sudo apt-get install scim-pinyin
2,if some packages can't be downloaded, try sudo apt-get update
---fix-missing
3,run scim and it will run wihle booting.
#切换到root
$ sudo -s

** [[http://jingyan.eeboard.com/article/14464][不同操作环境下如何将Raspbian安装到SD卡]]

作者： [[/user/349428][wuxingxing]]

上传时间为： 2012-09-06 11:13 PM

[[http://jingyan.eeboard.com/assets/img/watch-icon.png]]

[[http://jingyan.eeboard.com/assets/img/like-icon.png]]

[[http://jingyan.eeboard.com/assets/img/comment-icon.png]]

-  [[/category/17][树莓派]]

•

-  [[/tags/raspberry%20pi][]]

   * raspberry pi

-  [[/login?referer=http://jingyan.eeboard.com/article/14464][]]
-  [[/login?referer=http://jingyan.eeboard.com/article/14464][]]
-  分享
-  [[javascript:;][]]
   返回
   顶部

Raspberry Pi
已经出了一段时间，有相当多的方法将Raspbian安装到你的SD卡。无论你使用Windows，Mac
OS
X或Linux，这篇文章的目的，我们将用非常通用的方法来教你实现它。具体而言，我们将使用dd工具来实现。

      一、如果你使用的是Mac

为了简单起见，我们建议您先清除您的下载文件夹，然后再开始。Raspbian.zip文件可以从这个[[http://uk.rs-online.com/web/generalDisplay.html?id=raspberrypi][网址]]下载。一旦你解压映像软件文件后，你需要一个终端应用程序。假设你使用的是OS
X
10.7或更高版本，可以从应用程序启动它，一旦终端应用程序的启动运行，通过“cd〜/下载”命令来打开你的下载文件夹：

你现在应该有至少两个文件在您的下载文件夹中。通过键入"ls”来验证“img”文件和"zip”文件是否存在。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/raspbian-1/][[[http://www.eeboard.com/wp-content/uploads/2012/09/Raspbian-1.png]]]]

接下来让我们看看如何将镜像文件文件放到SD卡。首先，在插入SD卡之前我们需要了解设备的使用情况。

在终端应用程序中键入：“df-h”。您应该会看到一些像这样的输出：

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-2/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-2.jpg]]]]

现在，插入你的SD卡并重新运行上面的命令，并注意新的“/
dev/disk1s1”行。这个方便的 - 你需要将其转换为一个原始磁盘的名称。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-3/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-3.jpg]]]]

接下来，我们需要卸载该卷，“DD”工具可以将镜像写入SD卡。这可以通过“sudo
diskutil unmount/ dev/disk1s1”命令。你会得到提示输入系统密码，输入即可。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-4/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-4.jpg]]]]

您现在应该看到最后一行的“卸载卷XXX”，“XXX”是你的卡的名称。现在，我们终于可以将Raspbian.img文件写到SD卡上了。
现在是时候进行转换。无论你的磁盘命名如何（例如，/
dev/disk1s1），去掉“s1”，在“disk”前面加“r”，变成了“/ dev/rdisk1”。
所以，举例来说，“/ dev/disk1s1”=“/ dev/rdisk1”。

然后键入以下内容：“sudo dd bs=1m if=2012-06-15-wheezy-raspbian.img
of=/dev/ YOURDISKNAME"。替换为您的实际原始磁盘名称。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-5/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-5.jpg]]]]

这将需要一段时间来完成。我们可以用“dd”命令，通过将磁盘镜像拖到桌面垃圾箱进行SD卡的安全卸载。这样我们的准备工作就完成了！

二、如果你用的是Linux

无论你使用的是Linux发行版，请确保有“dd”的工具。 我们在这里假设：
1）有sudo的配置，并熟悉它。 2）安装了fdisk。

我们在Ubuntu进行了测试。从[[http://www.raspberrypi.org/downloads][这个位置]]下载Raspbian.zip文件压缩到你主目录并解压。

启动你的Linux机器上的终端，通过“cd”命令访问你的主目录。键入“unzip
imagename.zip”，您刚刚下载的镜像取代“imagename”。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-6/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-6.jpg]]]]

接下来，我们需要确定您的SD卡目前正在使用的设备名称。插入您的SD卡，输入“sudo
fdisk-L”。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-7/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-7.jpg]]]]

请注意上图中列出的设备

我们的设备是“sdb”，15.9GB的空间。请记下“/ dev /
sdb”下面列出的设备，为了安全写入镜像你要卸载他们。我们看到“/
dev/sdb1”和“/ dev/sdb2”，所以我们运行： sudo umount/ dev/sdb1

sudo umount / dev/sdb2

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-8/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-8.jpg]]]]

现在用“dd”工具来写入我们镜像。键入“sudo dd bs
=1M=2012-08-16-wheezy-raspbian.img of= / dev /
sdb”。和上面Mac环境下一样，这将需要几分钟的时间才能完成。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-9/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-9.jpg]]]]

如果你看到如上图所示，那就成功了！

三、在 Windows环境下

先在Windows系统里安装Win32DiskImager应用程序，Win32DiskImager你可以在[[http://www.softpedia.com/get/CD-DVD-Tools/Data-CD-DVD-Burning/Win32-Disk-Imager.shtml][这里]]或[[https://launchpad.net/win32-image-writer][这里]]下载。下载好以后我们继续下载Raspbian镜像，从[[http://www.raspberrypi.org/downloads][这个地方]]下载。

Win32DiskImager和Raspbian下载完成后，我们需要解压缩。为了方便，将这两个文件放到桌面上或一个文件夹里。接着将win32diskimager-binary.zip和2012-08-16-wheezy-raspbian.zip两个文件解压缩。

然后将SD卡插入读卡连接到电脑，双击Win32DiskImager。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-10/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-10.jpg]]]]

Win32DiskImager加载的时候你会看到一个错误（在Windows 7环境下），如下图：

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-11/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-11.jpg]]]]

单击“确定”，应用程序将继续加载。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-12/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-12.jpg]]]]

点击蓝色的文件夹图标，选择Raspbian镜像文件，并确保列出的设备名称与SD卡驱动器盘符相同。

打开你的镜像文件，单击“Write”，“Yes”确认，然后稍等一会。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-13/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-13.jpg]]]]

当镜像写好后，会弹出下图窗口，接下来你就可以安全退出你的SD卡了。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-14/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-14.jpg]]]]

如果你在你的SD卡在写镜像的过程中卡住了，你可以来[[http://elinux.org/RPi_Easy_SD_Card_Setup][这里]]寻求解决办法。


** [[https://linuxtoy.org/archives/cv.html][cv: 显示 cp、mv等命令的进度]]

2014-07-14 By [[https://linuxtoy.org/author/toy.html][toy]] Posted in
[[https://linuxtoy.org/category/apps.html][Apps]] Edit on
[[https://github.com/xuxiaodong/linuxtoy.org/blob/master/content/cv.md][GitHub]]

在 Linux 系统中，大多数命令从来都是信奉“沉默是金”的准则，所以当我们利用
=cp=
复制文件的时候并不能看到所谓的进度条。如果你在意这一点，那么不妨来用用
[[https://github.com/Xfennec/cv][cv]]。

[[https://linuxtoy.org/img/2014/07/cv.png]]

cv 是 Coreutils
Viewer，它能够显示传输数据的进度，包括百分比、大小、以及速率等信息。cv
支持 coreutils 中的基本命令，比如 cp、mv、rm、dd、tar 等等。

cv 的源代码可从 [[https://github.com/Xfennec/cv][GitHub]]
获取，需要自行编译。

** [[http://blog.csdn.net/shendayjy/article/details/10281131][ubuntu 桌面重命名]]

刚安装上Ubuntu8.04的时候，不懂得怎么修改Firefox下载文件保存的位置，默认是在桌面。但下载下来要在终端上使用文件就必须进入桌面。但桌面所在文件夹是“桌面”，习惯了用终端进行操作，但是在终端打中文比较麻烦，尤其是刚开始，自己的Ubuntu连汉语输入都还没有，所以我就想把此文件夹重命名为“Desktop”但是注销之后桌面文件夹就被默认为用户文件夹maximus了，用户目录下的所有文件及文件夹都跑到桌面了，很郁闷。Google了一下，发现桌面的文件夹是可以任意设置的，修改
/home/maximus(我的用户名)/.config/user-dirs.dirs里面的
XDG_DESKTOP_DIR="$HOME/Desktop" 这一项就好了
例如XDG_DESKTOP_DIR="$HOME/Desktop" 这个就是把用户的桌面设置在Desktop文件夹下
要把桌面设置在“视频”文件夹下就可以这样修改：
XDG_DESKTOP_DIR="$HOME/视频"
其他的各个项也都可以类似的设置。

** [[http://blog.chinaunix.net/uid-20804763-id-68083.html][LaTeX命令速查手册]]

分类：

+---------------------------------+
|TeX各版本概述及基本约定，特殊字符|
+---------------------------------+
 
tex提供300多条基本排版命令
由D.E.Knuth1978年开发
plain tex：在tex基础上新定义600多条复合命令
AMS-TEX：美国数学会开发（amsmath宏包）排版的数学公式
LATEX：L.Lamport（1985）编写，适合排版普通文章和书籍
LATEX2e：可加载amsmath宏包，目前最流行的TEX宏包
版本：LATEX2.09-->LATEX2e-->LATEX3（开发中）
中文排版：
CCT：科学院张林波
TY（天元）：华师大肖刚、陈志杰教授开发
CJK：德国W.Lemberg开发，处理中日韩三国文字。
发行版CTEX：集成了CCT，TY，CJK的MikTEX系统。
ChinaTEX:内容涵盖MiKTeX系统及中文支持、常用外围软件、TeX\LaTeX文档和模板选萃等
 
TeX中的长度
mm毫米
cm厘米
in英寸＝2.54cm＝72.27pt
pt点
em大写字母M的宽度
ex小写字母x的高度
 
弹性长度：根据需要自动伸缩
正常值plus伸展值minus收缩值
实际长度可超过正常值和伸展值之和，但不能小于正常值和收缩值之差
 
\documentclass[11pt]{article}%11pt字体，普通文章
%导言区，全局命令
\usepackage{CJK}%使用CJK宏包
\begin{document}%主环境
\begin{CJK}{GBK}{song}%汉字必须放入CJK环境
%其它字体:song,kai,fs,hei,li,you
%CJK的两种环境CJK和CJK*
%GBK是采用的字符集：GB，GBK，Bg5，Gbt
Hi,This is my first \LaTeX file
祝贺你，MikTex和CJK安装成功了
\end{CJK}
\ent{document}
 
CJK和CJK*环境之间的切换
\CJKspace和\CJKnospace
 
 
\CJKtilde 重新定义～的长度
 
 
基本约定
分组｛......｝
注释符：%
西文标点后要加空格
各种环境的开始和结束命令最好独占一行
换行:连续两个回车，一个仅为空格
 
 
输入特殊字符
前加\的有：#$%{}~\_\^&
\=\textbackslash
｜,<,>＝$|$,$<$,$>$,$*$(中间星）
*＝*上面星
特殊符号\s \p \dag \ddag \copyrigh版权号，\pounds 磅
 
\TeX \LaTeX \LaTeXe \AmS-\LaTeX(最后这个要amsmath宏包）
 
单引号：`'(1键前面的）
双引号：``"
 
+------------------------------+
|段落、行距、水平间距、缩进命令|
+------------------------------+
 
 
强制分行：\\或\\*[和下行间距离]、\newline
建议分行：\linebreak[0-4，数越大建议力度越大]
\linebreak增加字间距，强制换行
\nolinebreak［n］建议不分行
\mbox｛内容｝内容保持在同一行
 
分段：\par，或两个回车
分页：自动分页
强制分页：\newpage
建议分页：\pagebreak［n］，\nopagebreak［n］
 
增加当前页高度有时可以避免难看的分页
\enlargethispage｛尺寸｝可增加的最大高度
\enlargethispage*｛尺寸｝指定增加高度
 
水平间距：
\quad 插入空白相当于当前字体大小
\qquad＝\quad×2
\ ，＝\quad×3/18
~=???好象比\ 小
\hspace{宽度大小}，\hspace*{宽度大小}
\hfill弹性长度：hspace{\hfill}插入空白，撑满整行
\hphantom{文本内容},占据文本内容的宽度
\vphantom[文本内容},\phantom{文本内容}
 
导引线：\dotfill，\hrulefill
 
垂直间距：
\vspace{高度}和\vspace*{高度}
\vfill：相当于\vspace{\fill}
\smallskip:-->\vspace{\smallskipamount}
\medskip:-->\vspace{\medskipamount}
\bigskip:-->\vspace{\bigskipamount}
 
段落首行缩进：
\setlength{\parindent}{2em},2个M
\setlength{\parindent}{0pt},首行不缩进
\CJKindent:两个汉字
\indent与\noindent
每节的第一段首行不会自动缩进
\hspane{\parindent}
在导言区加入：\usepackage{indentfirst}
 
段落间距：\lineskip+\parskip
可用\setlength修改以上值
 
行距：
\baselineskip：相邻两行基线间距离
\baselinestretch：伸展因子
修改改变行距：\renewcommand{\baselinestretch}[1.2]
放在\begin{document}之后，字体尺寸改变时才生效
 
 
 
 
+----------------------------------+
|西文字体属性、及中文字体属性、命令|
+----------------------------------+
字体有5种属性
族：
\rmfamily：罗马字体
\sffamily：无衬线字体
\ttfamily：打字机字体
形状：（shape）直立斜
\upshape：直立
\itshape：意大利斜体
\slshape：斜体
\scshape：小体大写
系列：（series）宽度黑度
\mdseries：中等权重（黑）
\bfseries：粗体
 
\normalfont：默认字体，中等权重直立罗马字体
西文尺寸：10pt，11pt，12pt
\em强调，一般为斜体
以上命令称为声明（无参数）
 
每一声明对应字体命令
命令只对其参数中的文本起作用
族：
\testrm{},\testsf{},\testtt{}
形状
\textup{},\textit{},\textsl{},\textsc{}
系列
\textmd{}，\textbf{}
默认值：\textnormal{}
强调：\emph{}
 
定义了基本尺寸后，可使用下面的声明来改变字体
\tiny  5pt
\scriptsize 7pt
\footnotesize 8pt
\small  9pt
\normalsize 10pt
\large  12pt
\Large  14.4pt
\LARGE  17.28pt
\huge  20.74pt
\Huge  24.88pt
以上尺寸是基本尺寸为10pt时的大小
 
所有西文字体命令对中文同样起作用
italic和slanted斜体对中文一样
 
中文书籍基本字号为5号约等于11pt
 
使用GBK编码时，可同时输入简繁体。
 
自定义字体大小
\fontsize{字体尺寸}{行距}后面须加上\selectfont才生效
可得到任意大小汉字，西文最大不能超\Huge
行距通常为字体大小的1.2-1.5倍
例：\fontsize{12pt}{\baselineskip}\selectfont
\usepackage{type1cm}任意大小西文
 
行距：\linespread{1.3}产生1.5倍行距，1.6产生双倍行距，效果夸张，不适合出版
用下面方法：\setlength{\baselineskip}{1.5\baselineskip}{......}
 
 
 
正文中更换字体：\CJKfamily{字体族}
 
为方便，作以下自定义
\newcommand*{\SONG}{\CJKfamily{song}}
\newcommand*{\HEI}{\CJKfamily{hei}}
\newcommand*{\KAI}{\CJKfamily{kai}}
\newcommand*{\FS}{\CJKfamily{fs}}
\newcommand*{\LI}{\CJKfamily{li}}
\newcommand*{\YOU}{\CJKfamily{YOU}}
 
引用更改为宋体：\SONG 正文
 
 
 
文本居中
文本默认为左对齐
单行文本居中命令
\centerline{....}
多行使用\begin{center}环境
居中声明：\centering（不建议使用）
 
+------------+
|参考文献环境|
+------------+
\begin{thebibliography}{编号样本}
\bibitem[记号]{引用标志} 文献条目
 .
 .
 .
\bibitem[记号]{引用标志} 文献条目
\end{thebibliography}
 
\bibitem[省略为方括号数字]{不可省由字母，数字和，号外符号组成，各个文献互不相
同} 文献条目
编号样本，指定记号的宽度，一般为数字
 
引用文献时用\cite{引用标志1，引用标志2}
 
调节各文献间距离
\setlength{\itemsep}{高度}
 
标题缺省为左对齐Reference
（\Large\bfseries）
由\refname值确定
书籍参考文献标题由\bibname值确定
 
文献条目包含：作者，标题，出版社，年代，版本，页码
一行放不下，后面自动缩进，距离为“编号样本”宽度
 
+----------+
| 脚    注 |
+----------+
\footnote{脚注内容}
article文档，整篇同一编号
book和report文档，每章统一编号
 
+----------------+
| 文档类别、章节 |
+----------------+
 
\documentclass[可选项]{article,book,report,letter,只能选一种}
article 短篇文章
report 长篇报告，可分章
book （书）可含chapter，奇偶页采用不同处理
可选项对整篇文档起作用，使用多个选项互不排斥，用逗号分隔
基本字体：10pt，11pt，12pt
纸张大小：letterpaper，a4paper，a5paper...
排版方向：portrait（竖向），landscape（横向）
标题页：titlepage，notitlepage
final和draft
 
指定纸张大小（只有latex2e中使用）
letterpaper（11*8.5in）
legalpaper（14*8.5in）
executivepaper（10.5*7.25in）
a4paper（29.7*21cm）
a5paper（21*14.8cm）
b5paper（25*17.6cm）
默认值是letterpaper，美国信纸尺寸，纵向
landscape 横向
 
 
章节命令：
\part,\chapter,\section,\subsection,\subsubsection,\paragraph,\subparagraph
\命令[短标题]{标题},用于显示在目录和页眉
\命令*{标题}
层次号：book中\part为-1（article中为0），\chapter为0，....
book类
\part，\chapter独立编号，只出现在奇数页，\part独占一页
\section，\subsection 关联编号
article类
\part，\section独立编号
\subsection，\subsubsection 关联编号
星号章节不参加自动编号
\part和\chapter标题占两行
 
标题中文化
\renewcommand{\partname}{}
\renewcommand{\thepart}{第\，\Roman{part}}\,篇}
 
修改编号最深层次
\setcounter{secnumberdepth}{数}
secnumberdepth，book类-2～5，缺省为2，-2时取消编号
article类-1～5，缺省为3
 
自动编号章节对应计数器
part，chapter，section，bsection,subsubsection,paragraph,subparagraph
修改计数器值：
\setcounter{计数器名}{数}
 
 TeX的版式首先是文件版式, 也就是我们接触的第一个最最最
简单的TeX文档中的第一句:
       \documentstyle[选项1,选项2,...]{格式}
其中的[]及选项是可选的, 而{格式}是必需的. LaTeX有以下几种
格式: article(文章), report(报告), book(书), letter(信件).
CCT对前面三种进行了汉化, 分别是carticle, creport和cbook.
常用的选项有
  10pt/11pt/12pt: 定义基准字号, 缺省10pt.
  twoside: 两面印刷格式, 因奇偶页装订位置不同而异, 缺省为
           单页.
  twocolumn: 双栏排版, 缺省为单栏.
  titlepage: 仅在article格式使用, 它是\maketile产生一个单
             独的文章题目页, 同时abstract也产生单独页
  leqno: 使公式标号出现在左边, 缺省在右
  fleqn: 公式左对齐, 缺省中间对齐
  thesis: 专用于毕业论文排版
  IEEE: 专向IEEE类杂志投稿的格式
  IFTHEN: 排版计算机程序
 
\columnsep 指定两栏间距
\columnseprule 两栏间竖线宽度，默认为0。
\mathindent 选择fleqn时 左边界的缩进量
 
以上参数修改用\setlength{\mathindent}{2.5cm}
 
 
    LaTeX的一个页面有页眉(head, 通常是杂志名, 卷号, 当前
章节名等), 主体(body, 正文, 包括脚注及图表), 页脚(通常是
页码, 如果页码放在页眉处, 则页脚可能是空的). 我们用下面的
指令控制页版面:
        \pagestyle{参数}
参数可以是
  plain: 页码在页脚居中, 页眉空白, 为article, report的缺省
  empty: 页眉页脚都空白
  heading: 页脚为空, 页眉为正文的章节信息及页码
  myheadings: 自定义页眉, 内容由
     \markboth{left\_head}{right\_head}   (双面twoside排版)
   或\markright{right\_head}             (单面排版)
    \pagestyle是对全文有效的, 而如果要定义某页的页面格式,
则可用\thispagestyle, 用法同上, 下一页自动恢复原设置.
 
    这里提到页码, 我们经常会修改页码的表现格式, 可能用阿
拉伯数字或罗马数字等, 则修改\pagenumbering{参数}, 这里参
数可以是arabic(阿拉伯数字), roman(小写罗马数字: i, ii, iii,)
Roman(大写罗马数字: I, II, III,), alph(小写英文: a, b, c,),
Alph(大写英文: A, B, C). 如果需要更改某页的页码, 则用修改
计数器命令: \setcounter{page}{数字}, 这里page是页码计数器.
 
+----------------+
|*修改版面的命令*|
+----------------+
 
 
TeX中还经常会在\documentstyle和\begin{document}之间
常用到很多修改版面尺寸的命令. 如未指明, 这些命令的格式都
是用\para\_name=newvalue的格式.
  \texwidth, \texheight 主要正文body的宽度和高度, 不包括页眉页脚
  \oddsidemargin, \evensidemargin 奇数/偶数页, 纸张左边缘
    到页body左边缘的距离减去一英寸
  \topmargin 纸张上边缘到页眉或body(无页眉时)的距离减去一
    英寸
  \marginparwidth 页边注(marginnote)的宽度
  \marginparsep 正文边缘到页边注边缘的距离
  \headheight 页眉高度
  \headsep 页眉底部到页主体顶部的距离
  \footheight 页脚高度
  \footskip 页正文最后一行底到页脚底的距离
(建议, 总把
\oddsizemargin（奇数页的左边界）
\evensidemargin（偶数页的左边界）
\topmargin（从上页边到页眉的距离）
设为0cm;
如果没用页眉, 将
\headheight（页眉高度）,
headsep（页眉基线到正文顶部的距离）
设为0cm;
如果没用页脚, 将
\footheight（已过时latex2e中已被去掉）,
\footskip（正文底部到页脚底部的距离）设为0cm,
这样便于在输出时直接利用驱动程序的功能控制版心的位置.)
 
\columnsep 双栏article中, 左右栏间空白的距离
\columnseprule 双栏article中, 左右栏间分隔线的宽度, 缺省 为零, 即没有线
以下参数的修改可以在\begin{document}的前面和后面:
  \parskip 段落之间除了空出正常行距外额外空出的距离
  \parindent 段首空白的长度
  \footnotesep 两个注脚之间的距离
  \baselineskip 正文中前一行底和第二行底的距离, 会因字号的
    改变自动改变.
    另外, 定义行距还有一个特殊的参数, 那是\baselinestretch,
它是用在\begin{document}前的全局变量, 修改格式如
\renewcommand\baselinestretch{倍数}    缺省时为1.0, 因此
LaTeX中最小行距是\baselineskip乘上\baselinestretch得到的.
 
+----------------+
| 文档标题、摘要 |
+----------------+
 
\title{标题可有\\换行}
\author{作者名可用and分开}
\date{日期可选，无命令自动当天日期，空白选项不显示}
\thanks{}可出现\maketitle以上任何位置，或几个\thanks
\maketitle
LaTex用特定字体、号居中输出
 
自定义标题环境
\begin{titlepage}
\end{titlepage}
生成标题独占一页，并重置页码计数器
 
摘要环境
\begi{abstract}
...
\end{abstract}
 
book类没有摘要
摘要标题中文化
\renewcommand{abstractname}{摘\qquad 要}

** [[http://www.jiancool.com/article/62041508632/][TTL]]
LS型TTL负载
其中“L”表示低功耗,“S”表示肖特基技术

       肖特基（Schottky）二极管是一种快恢复二极管,它属一种低功耗、超高速半导体器件。其显著的特点为反向恢复时间极短（可以小到几纳秒），正向导通压降仅0.4V左右。肖特基（Schottky）二极管多用作高频、低压、大电流整流二极管、续流二极管、保护二极管，也有用在微波通信等电路中作整流二极管、小信号检波二极管使用。常用在彩电的二次电源整流,高频电源整流中。

TTL(逻辑门电路)

全称Transistor-Transistor Logic,即BJT-BJT逻辑门电路，是数字电子技术中常用的一种逻辑门电路，应用较早，技术已比较成熟。TTL主要有BJT（Bipolar Junction Transistor 即双极结型晶体管，晶体三极管）和电阻构成，具有速度快的特点。最早的TTL门电路是74系列，后来出现了74H系列，74L系列，74LS,74AS,74ALS等系列。但是由于TTL功耗大等缺点，正逐渐被CMOS电路取代。

TTL电平信号:

        TTL电平信号被利用的最多是因为通常数据表示采用二进制规定，+5V等价于逻辑“1”，0V等价于逻辑“0”，这被称做TTL（晶体管-晶体管逻辑电平）信号系统，这是计算机处理器控制的设备内部各部分之间通信的标准技术。
       TTL电平信号对于计算机处理器控制的设备内部的数据传输是很理想的，首先计算机处理器控制的设备内部的数据传输对于电源的要求不高以及热损耗也较低，另外TTL电平信号直接与集成电路连接而不需要价格昂贵的线路驱动器以及接收器电路；再者，计算机处理器控制的设备内部的数据传输是在高速下进行的，而TTL接口的操作恰能满足这个要求。TTL型通信大多数情况下，是采用并行数据传输方式，而并行数据传输对于超过10英尺的距离就不适合了。这是由于可靠性和成本两面的原因。因为在并行接口中存在着偏相和不对称的问题，这些问题对可靠性均有影响。
        TTL输出高电平>2.4V，输出低电平<0.4V。在室温下，一般输出高电平是3.5V，输出低电平是0.2V。最小输入高电平和低电平：输入高电平>=2.0V，输入低电平<=0.8V，噪声容限是0.4V。
TTL门电路是双极型集成电路，与分立元件相比，具有速度快、可靠性高和微型化等优点。

** [[http://people.ubuntu.com/~happyaron/ubuntu-docs/precise-html/nautilus-bookmarks-edit.html][编辑文件夹书签]]

您的书签列在文件管理器的书签菜单中。

*** 删除书签：

1. 依次单击书签 ▸ 编辑书签。

2. 在编辑书签窗口中，选中要删除的书签，然后单击删除。

3. 单击关闭。

*** 添加书签：

1. 打开要对其添加书签的文件夹(或位置)。

2. 依次单击书签 ▸ 添加书签。

*** 重命名书签：

1. 依次单击书签 ▸ 编辑书签。

2. 在编辑书签窗口中，选中要重命名的书签。

3. 在名称文本框中，为该书签输入新名称。

   重命名书签不会重命名文件夹。如果有指向位置不同的两个不同文件夹的书签，但书签和相应文件夹的名称都相同，则两个书签的名称会相同，而且不能将两者区分开。这种情况下，让书签的名称不同于所指向的文件夹的名称会很有用。

** [[https://help.github.com/articles/caching-your-github-password-in-git/][Caching your GitHub password in Git]]

-  [[#platform-mac][mac]]
-  [[#platform-windows][windows]]
-  [[#platform-linux][linux]]
-  [[#platform-all][all]]

If you're [[/articles/which-remote-url-should-i-use][cloning GitHub
repositories using HTTPS]], you can use a /credential helper/ to tell
Git to remember your GitHub username and password every time it talks to
GitHub.

If you clone GitHub repositories using SSH, then you authenticate using
SSH keys instead of a username and password. For help setting up an SSH
connection, see [[/articles/generating-an-ssh-key][Generating an SSH
Key]].

*Tips:*

-  You need Git *1.7.10* or newer to use the credential helper.
-  If you installed Git using [[http://brew.sh/][Homebrew]], the
   osxkeychain helper may already be installed.

Install the osxkeychain credential helper and tell Git to use it.

1. Find out if the osxkeychain credential helper is already installed by
   trying to run it:

   #+BEGIN_EXAMPLE
       git credential-osxkeychain
       # Test for the cred helper
       Usage: git credential-osxkeychain <get|store|erase>
   #+END_EXAMPLE

2. If the osxkeychain helper isn't installed, download it with curl:

   #+BEGIN_EXAMPLE
       git credential-osxkeychain
       # Test for the cred helper
       git: 'credential-osxkeychain' is not a git command. See 'git --help'.
       curl -s -O \
       https://github-media-downloads.s3.amazonaws.com/osx/git-credential-osxkeychain
       # Download the helper
       chmod u+x git-credential-osxkeychain
       # Fix the permissions on the file so it can be run
   #+END_EXAMPLE

3. Install the helper into the same directory where Git itself is
   installed:

   #+BEGIN_EXAMPLE
       sudo mv git-credential-osxkeychain \
       "$(dirname $(which git))/git-credential-osxkeychain"
       # Move the helper to the path where git is installed
       Password: [enter your password]
   #+END_EXAMPLE

4. Tell Git to use osxkeychain using the global =credential.helper=
   config:

   #+BEGIN_EXAMPLE
       git config --global credential.helper osxkeychain
       # Set git to use the osxkeychain credential helper
   #+END_EXAMPLE

The next time you clone an HTTPS URL that requires a password, you'll be
prompted for your username and password, and to grant access to the OSX
keychain. After you've done this, the username and password are stored
in your keychain and you won't be required to type them in to Git again.

*Tip:* You need Git *1.7.10* or newer to use the credential helper.

The credential helper is included with GitHub Desktop. The app also
provides a Git shell so you won't ever need to install and configure Git
manually. For more information, see
"[[/desktop/guides/getting-started/][Getting Started with GitHub
Desktop]]."

If you prefer working with the command line, you can also install a
native Git shell, such as [[https://msysgit.github.io/][msysgit]]. With
msysgit, running the following in the command line will store your
credentials:

#+BEGIN_EXAMPLE
    git config --global credential.helper wincred
#+END_EXAMPLE

*Tip:* You need Git *1.7.10* or newer to use the credential helper.

Turn on the credential helper so that Git will save your password in
memory for some time. By default, Git will cache your password for 15
minutes.

1. In Terminal, enter the following:

   #+BEGIN_EXAMPLE
       git config --global credential.helper cache
       # Set git to use the credential memory cache
   #+END_EXAMPLE

2. To change the default password cache timeout, enter the following:

   #+BEGIN_EXAMPLE
       git config --global credential.helper 'cache --timeout=3600'
       # Set the cache to timeout after 1 hour (setting is in seconds)
   #+END_EXAMPLE

*Tip:* You need Git *1.7.10* or newer to use the credential helper.

Turn on the credential helper so that Git will save your password in
memory for some time. By default, Git will cache your password for 15
minutes.

1. On the command line, enter the following:

   #+BEGIN_EXAMPLE
       git config --global credential.helper cache
       # Set git to use the credential memory cache
   #+END_EXAMPLE

2. To change the default password cache timeout, enter the following:

   #+BEGIN_EXAMPLE
       git config --global credential.helper 'cache --timeout=3600'
       # Set the cache to timeout after 1 hour (setting is in seconds)
   #+END_EXAMPLE

** [[http://blog.csdn.net/lithocntlor/article/details/7713511][JTag, JLink及OpenJtag的比较]]

标签： [[http://www.csdn.net/tag/%e5%b7%a5%e5%85%b7][工具]]

2012-07-03 23:37 2876人阅读 [[#comments][评论]](0)
[[javascript:void(0);][收藏]] [[#report][举报]]

[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

ARM+Linux/（7）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/lithocntlor/article/category/1172508][作者同类文章]]/X/

版权声明：本文为博主原创文章，未经博主允许不得转载。

**** 简介

#+BEGIN_QUOTE
  本文简单介绍了JTag,
  JLink及OpenJTag的用途，以及区别。同时也介绍了开发机没有并口时，该选择何种工具进行烧写。所有资料均从网上搜罗而来。
#+END_QUOTE

**** 一. JTag

#+BEGIN_QUOTE
  JTag(Joint Test Action Group) 是IEEE1149.1 （Standard Access Port and
  Boundary-Scan Architecture)标准.
  它最初用来以边界扫描的方式测试印刷电路板，当然它现在仍然这一方面广泛使用。
  JTag的用途：
  1. 边界扫描测试
#+END_QUOTE

#+BEGIN_QUOTE
  2. 往Flash烧写程序和数据： 可以烧写Nor Falsh 和 Nand Falsh
  3. 调试ARM裸机程序，不能调试嵌入式Linux程序
  JTag的接口：
  JTag接口并没有统一的标准。ARM处理器通常使用2＊10针（部分使用2＊7针）的JTag接口。
  JTag连接Host的一端通常为并口。一般笔记本及台式机都很少有并口接口，而且市面上买到的USB转并口并不能用于JTag，USB转并口主要是给老式打印机使用的。这就使得我们很难使用JTag以及笔记本进行烧写。另外的一个缺点是并口JTag的速率非常低。
  JTag的替代品： 
  Serial Wire Debug（SWD）。
#+END_QUOTE

**** 二. JLink

#+BEGIN_QUOTE
  JLink是Segger的产品，[[http://www.segger.com/jlink.html][http://www.segger.com/jlink.html]]。它是USB接口转到JTag接口的适配器（adaptor)，并不是真正意义上的仿真器。它采用标准的14针或者20针的Jtag接口与开发板相连。它支持多种CPU内核（ARM7，
  ARM9，Cortex etc.）。对ARM而言，它可能是最受欢迎的适配器。
  JLink的功能：
  1. 往Flash烧写程序：不支持烧写NAND Flash
  参见[[http://www.segger2.com/index.php?page=Thread&threadID=144][http://www.segger2.com/index.php?page=Thread&threadID=144]]
  2. 支持Windows, Linux以及Mac： 但是Linux及Mac仅支持JLink Commander,
  Command Line GdbServer, 以及shared library。
  3. 支持多种调试协议： 如GDB， RDI 等
  4. USB转串口功能
  JLink的接口：
  USB接口，JLink的价格也比较低（当然是山寨的）。
#+END_QUOTE

**** 三. OpenJTag

#+BEGIN_QUOTE
  OpenJTag是一个开源项目（包含软件和硬件），采用GNU GPL
  license： [[http://www.openjtag.org/][http://www.openjtag.org/]]。同样它也是一个USB接口转JTag接口的适配器，同样不是真正意义上的仿真器。
  OpenJTag的功能：
  1. 往Flash烧写程序： 支持NOR Flash 和 NAND Flash
  2. 支持Windows以及Linux
  3. 能够用在支持GDB调试协议的工具上： 如IAR， Eclipse，
  但不能用在支持RDI调试协议的工具上： 如ADS
  4. USB转串口功能
  OpenJtag的接口：
  USB接口，但是他的价格要比JLink高一些。
#+END_QUOTE


** [[http://www.cnblogs.com/youtherhome/archive/2013/03/17/2964195.html][Linux C++的多线程编程]]

**** *1. 引言*

　　*线程（thread）*技术早在60年代就被提出，但真正应用多线程到操作系统中去，是在80年代中期，solaris是这方面的佼佼者。传统的Unix也支持线程的概念，但是在一个*进程（process）*中只允许有一个线程，这样多线程就意味着多进程。现在，多线程技术已经被许多操作系统所支持，包括Windows/NT，当然，也包括Linux。
　　为什么有了进程的概念后，还要再引入线程呢？使用多线程到底有哪些好处？什么的系统应该选用多线程？我们首先必须回答这些问题。
　　使用多线程的理由之一是和进程相比，它是一种非常"节俭"的多任务操作方式。我们知道，在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。
　　使用多线程的理由之二是线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。
　　除了以上所说的优点外，不和进程比较，多线程程序作为一种多任务、并发的工作方式，当然有以下的优点：
　　1)
提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time
consuming）置于一个新的线程，可以避免这种尴尬的情况。
　　2)
使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。
　　3)
改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。
　　下面我们先来尝试编写一个简单的多线程程序。

 

**** *2. 简单的多线程编程*

　　Linux系统下的多线程遵循POSIX线程接口，称为*pthread*。编写Linux下的多线程程序，需要使用头文件pthread.h，连接时需要使用库libpthread.a。顺便说一下，Linux下pthread的实现是通过系统调用clone()来实现的。clone()是Linux所特有的系统调用，它的使用方式类似fork，关于clone()的详细情况，有兴趣的读者可以去查看有关文档说明。下面我们展示一个最简单的多线程程序threads.cpp。 

#+BEGIN_EXAMPLE
    //Threads.cpp
    #include <iostream>
    #include <unistd.h>
    #include <pthread.h>
    using namespace std;

    void *thread(void *ptr)
    {
        for(int i = 0;i < 3;i++) {
            sleep(1);
            cout << "This is a pthread." << endl;
        }
        return 0;
    }

    int main() {
        pthread_t id;
        int ret = pthread_create(&id, NULL, thread, NULL);
        if(ret) {
            cout << "Create pthread error!" << endl;
            return 1;
        }
        for(int i = 0;i < 3;i++) {
            cout <<  "This is the main process." << endl;
            sleep(1);
        }
        pthread_join(id, NULL);
        return 0;
    }
#+END_EXAMPLE

　　我们编译并运行此程序，可以得到如下结果：
　　This is the main process.
　　This is a pthread.
　　This is the main process.
　　This is the main process.
　　This is a pthread.
　　This is a pthread.
　　再次运行，我们可能得到如下结果：
　　This is a pthread.
　　This is the main process.
　　This is a pthread.
　　This is the main process.
　　This is a pthread.
　　This is the main process.

　　前后两次结果不一样，这是两个线程争夺CPU资源的结果。上面的示例中，我们使用到了两个函数，pthread\_create和pthread\_join，并声明了一个pthread\_t型的变量。
　　pthread\_t在头文件/usr/include/bits/pthreadtypes.h中定义：

#+BEGIN_EXAMPLE
    typedef unsigned long int pthread_t;
#+END_EXAMPLE

　　它是一个线程的标识符。函数pthread\_create用来创建一个线程，它的原型为：

#+BEGIN_EXAMPLE
    extern int pthread_create __P ((pthread_t *__thread, __const pthread_attr_t *__attr,
    void *(*__start_routine) (void *), void *__arg));
#+END_EXAMPLE

　　第一个参数为指向线程标识符的指针，第二个参数用来设置线程属性，第三个参数是线程运行函数的起始地址，最后一个参数是运行函数的参数。这里，我们的函数thread不需要参数，所以最后一个参数设为空指针。第二个参数我们也设为空指针，这样将生成默认属性的线程。对线程属性的设定和修改我们将在下一节阐述。当创建线程成功时，函数返回0，若不为0则说明创建线程失败，常见的错误返回代码为EAGAIN和EINVAL。前者表示系统限制创建新的线程，例如线程数目过多了；后者表示第二个参数代表的线程属性值非法。创建线程成功后，新创建的线程则运行参数三和参数四确定的函数，原来的线程则继续运行下一行代码。
　　函数pthread\_join用来等待一个线程的结束。函数原型为：

#+BEGIN_EXAMPLE
    extern int pthread_join __P ((pthread_t __th, void **__thread_return));
#+END_EXAMPLE

　　第一个参数为被等待的线程标识符，第二个参数为一个用户定义的指针，它可以用来存储被等待线程的返回值。这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回。一个线程的结束有两种途径，一种是象我们上面的例子一样，函数结束了，调用它的线程也就结束了；另一种方式是通过函数pthread\_exit来实现。它的函数原型为：

#+BEGIN_EXAMPLE
    extern void pthread_exit __P ((void *__retval)) __attribute__ ((__noreturn__));
#+END_EXAMPLE

　　唯一的参数是函数的返回代码，只要pthread\_join中的第二个参数thread\_return不是NULL，这个值将被传递给thread\_return。最后要说明的是，一个线程不能被多个线程等待，否则第一个接收到信号的线程成功返回，其余调用pthread\_join的线程则返回错误代码ESRCH。
　　在这一节里，我们编写了一个最简单的线程，并掌握了最常用的三个函数pthread\_create，pthread\_join和pthread\_exit。下面，我们来了解线程的一些常用属性以及如何设置这些属性。

 

**** *3. 修改线程的属性*

　　在上一节的例子里，我们用pthread\_create函数创建了一个线程，在这个线程中，我们使用了默认参数，即将该函数的第二个参数设为NULL。的确，对大多数程序来说，使用默认属性就够了，但我们还是有必要来了解一下线程的有关属性。
　　属性结构为pthread\_attr\_t，它同样在头文件/usr/include/pthread.h中定义，喜欢追根问底的人可以自己去查看。属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread\_attr\_init，这个函数必须在pthread\_create函数之前调用。属性对象主要包括是否绑定、是否分离、堆栈地址、堆栈大小、优先级。默认的属性为非绑定、非分离、缺省1M的堆栈、与父进程同样级别的优先级。
　　关于线程的绑定，牵涉到另外一个概念：轻进程（LWP：Light Weight
Process）。轻进程可以理解为内核线程，它位于用户层和系统层之间。系统对线程资源的分配、对线程的控制是通过轻进程来实现的，一个轻进程可以控制一个或多个线程。默认状况下，启动多少轻进程、哪些轻进程来控制哪些线程是由系统来控制的，这种状况即称为非绑定的。绑定状况下，则顾名思义，即某个线程固定的"绑"在一个轻进程之上。被绑定的线程具有较高的响应速度，这是因为CPU时间片的调度是面向轻进程的，绑定的线程可以保证在需要的时候它总有一个轻进程可用。通过设置被绑定的轻进程的优先级和调度级可以使得绑定的线程满足诸如实时反应之类的要求。
　　设置线程绑定状态的函数为pthread\_attr\_setscope，它有两个参数，第一个是指向属性结构的指针，第二个是绑定类型，它有两个取值：PTHREAD\_SCOPE\_SYSTEM（绑定的）和PTHREAD\_SCOPE\_PROCESS（非绑定的）。下面的代码即创建了一个绑定的线程。

 

#+BEGIN_EXAMPLE
    #include <pthread.h>
    pthread_attr_t attr;
    pthread_t tid;
    /*初始化属性值，均设为默认值*/
    pthread_attr_init(&attr);
    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
    pthread_create(&tid, &attr, (void *) my_function, NULL);
#+END_EXAMPLE

 

　　线程的分离状态决定一个线程以什么样的方式来终止自己。在上面的例子中，我们采用了线程的默认属性，即为非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread\_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。设置线程分离状态的函数为pthread\_attr\_setdetachstate（pthread\_attr\_t
*attr, int
detachstate）。第二个参数可选为PTHREAD\_CREATE\_DETACHED（分离线程）和
PTHREAD
\_CREATE\_JOINABLE（非分离线程）。这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread\_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread\_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread\_cond\_timewait函数，让这个线程等待一会儿，留出足够的时间让函数pthread\_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait（）之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。

　　另外一个可能常用的属性是线程的优先级，它存放在结构sched\_param中。用函数pthread\_attr\_getschedparam和函数pthread\_attr\_setschedparam进行存放，一般说来，我们总是先取优先级，对取得的值修改后再存放回去。下面即是一段简单的例子。

#+BEGIN_EXAMPLE
    #include <pthread.h>
    #include <sched.h>
    pthread_attr_t attr;
    pthread_t tid;
    sched_param param;
    int newprio=20;
    pthread_attr_init(&amp;attr);
    pthread_attr_getschedparam(&attr, &param);
    param.sched_priority=newprio;
    pthread_attr_setschedparam(&attr, &param);
    pthread_create(&tid, &attr, (void *)myfunction, myarg);
#+END_EXAMPLE

 

*4. 线程的数据处理*
　　和进程相比，线程的最大优点之一是数据的共享性，各个进程共享父进程处沿袭的数据段，可以方便的获得、修改数据。但这也给多线程编程带来了许多问题。我们必须当心有多个不同的进程访问相同的变量。许多函数是不可重入的，即同时不能运行一个函数的多个拷贝（除非使用不同的数据段）。在函数中声明的静态变量常常带来问题，函数的返回值也会有问题。因为如果返回的是函数内部静态声明的空间的地址，则在一个线程调用该函数得到地址后使用该地址指向的数据时，别的线程可能调用此函数并修改了这一段数据。在进程中共享的变量必须用关键字volatile来定义，这是为了防止编译器在优化时（如gcc中使用-OX参数）改变它们的使用方式。为了保护变量，我们必须使用信号量、互斥等方法来保证我们对变量的正确使用。下面，我们就逐步介绍处理线程数据时的有关知识。
   
*　　4.1 线程数据
*　　在单线程的程序里，有两种基本的数据：全局变量和局部变量。但在多线程程序里，还有第三种数据类型：线程数据（TSD:
Thread-Specific
Data）。它和全局变量很象，在线程内部，各个函数可以象使用全局变量一样调用它，但它对线程外部的其它线程是不可见的。这种数据的必要性是显而易见的。例如我们常见的变量errno，它返回标准的出错信息。它显然不能是一个局部变量，几乎每个函数都应该可以调用它；但它又不能是一个全局变量，否则在A线程里输出的很可能是B线程的出错信息。要实现诸如此类的变量，我们就必须使用线程数据。我们为每个线程数据创建一个键，它和这个键相关联，在各个线程里，都使用这个键来指代线程数据，但在不同的线程里，这个键代表的数据是不同的，在同一个线程里，它代表同样的数据内容。
　　和线程数据相关的函数主要有4个：创建一个键；为一个键指定线程数据；从一个键读取线程数据；删除键。
　　创建键的函数原型为：

#+BEGIN_EXAMPLE
    extern int pthread_key_create __P ((pthread_key_t *__key,void (*__destr_function) (void *)));
#+END_EXAMPLE

　　第一个参数为指向一个键值的指针，第二个参数指明了一个destructor函数，如果这个参数不为空，那么当每个线程结束时，系统将调用这个函数来释放绑定在这个键上的内存块。这个函数常和函数pthread\_once
((pthread\_once\_t*once\_control, void (*initroutine)
(void)))一起使用，为了让这个键只被创建一次。函数pthread\_once声明一个初始化函数，第一次调用pthread\_once时它执行这个函数，以后的调用将被它忽略。

　　在下面的例子中，我们创建一个键，并将它和某个数据相关联。我们要定义一个函数createWindow，这个函数定义一个图形窗口（数据类型为Fl\_Window
*，这是图形界面开发工具FLTK中的数据类型）。由于各个线程都会调用这个函数，所以我们使用线程数据。

#+BEGIN_EXAMPLE
    /* 声明一个键*/
    pthread_key_t myWinKey;
    /* 函数 createWindow */
    void createWindow ( void ) {
        Fl_Window * win;
        static pthread_once_t once= PTHREAD_ONCE_INIT;
        /* 调用函数createMyKey，创建键*/
        pthread_once ( & once, createMyKey) ;
        /*win指向一个新建立的窗口*/
        win=new Fl_Window( 0, 0, 100, 100, "MyWindow");
        /* 对此窗口作一些可能的设置工作，如大小、位置、名称等*/
        setWindow(win);
        /* 将窗口指针值绑定在键myWinKey上*/
        pthread_setpecific ( myWinKey, win);
    }

    /* 函数 createMyKey，创建一个键，并指定了destructor */
    void createMyKey ( void ) {
        pthread_keycreate(&myWinKey, freeWinKey);
    }

    /* 函数 freeWinKey，释放空间*/
    void freeWinKey ( Fl_Window * win){
        delete win;
    }
#+END_EXAMPLE

　　这样，在不同的线程中调用函数createMyWin，都可以得到在线程内部均可见的窗口变量，这个变量通过函数pthread\_getspecific得到。在上面的例子中，我们已经使用了函数pthread\_setspecific来将线程数据和一个键绑定在一起。这两个函数的原型如下：

#+BEGIN_EXAMPLE
    extern int pthread_setspecific __P ((pthread_key_t __key,__const void *__pointer));
    extern void *pthread_getspecific __P ((pthread_key_t __key));
#+END_EXAMPLE

　　这两个函数的参数意义和使用方法是显而易见的。要注意的是，用pthread\_setspecific为一个键指定新的线程数据时，必须自己释放原有的线程数据以回收空间。这个过程函数pthread\_key\_delete用来删除一个键，这个键占用的内存将被释放，但同样要注意的是，它只释放键占用的内存，并不释放该键关联的线程数据所占用的内存资源，而且它也不会触发函数pthread\_key\_create中定义的destructor函数。线程数据的释放必须在释放键之前完成。

 

*　　4.2 互斥锁
*　　互斥锁用来保证一段时间内只有一个线程在执行一段代码。必要性显而易见：假设各个线程向同一个文件顺序写入数据，最后得到的结果一定是灾难性的。
　　我们先看下面一段代码。这是一个读/写程序，它们公用一个缓冲区，并且我们假定一个缓冲区只能保存一条信息。即缓冲区只有两个状态：有信息或没有信息。

#+BEGIN_EXAMPLE
    void reader_function ( void );
    void writer_function ( void );
    char buffer;
    int buffer_has_item=0;
    pthread_mutex_t mutex;
    struct timespec delay;

    void main ( void ){
        pthread_t reader;
        /* 定义延迟时间*/
        delay.tv_sec = 2;
        delay.tv_nec = 0;
        /* 用默认属性初始化一个互斥锁对象*/
        pthread_mutex_init (&mutex,NULL);
        pthread_create(&reader, pthread_attr_default, (void *)&reader_function), NULL);
        writer_function( );
    }

    void writer_function (void){
        while(1){
            /* 锁定互斥锁*/
            pthread_mutex_lock (&mutex);
            if (buffer_has_item==0){
                buffer=make_new_item( );
                buffer_has_item=1;
            }
            /* 打开互斥锁*/
            pthread_mutex_unlock(&mutex);
            pthread_delay_np(&delay);
        }
    }

    void reader_function(void){
        while(1){
            pthread_mutex_lock(&mutex);
            if(buffer_has_item==1){
                consume_item(buffer);
                buffer_has_item=0;
            }
            pthread_mutex_unlock(&mutex);
            pthread_delay_np(&delay);
        }
    }
#+END_EXAMPLE

　　这里声明了互斥锁变量mutex，结构pthread\_mutex\_t为不公开的数据类型，其中包含一个系统分配的属性对象。函数pthread\_mutex\_init用来生成一个互斥锁。NULL参数表明使用默认属性。如果需要声明特定属性的互斥锁，须调用函数pthread\_mutexattr\_init。函数pthread\_mutexattr\_setpshared和函数pthread\_mutexattr\_settype用来设置互斥锁属性。前一个函数设置属性pshared，它有两个取值，PTHREAD\_PROCESS\_PRIVATE和PTHREAD\_PROCESS\_SHARED。前者用来不同进程中的线程同步，后者用于同步本进程的不同线程。在上面的例子中，我们使用的是默认属性PTHREAD\_PROCESS\_
PRIVATE。后者用来设置互斥锁类型，可选的类型有PTHREAD\_MUTEX\_NORMAL、PTHREAD\_MUTEX\_ERRORCHECK、PTHREAD\_MUTEX\_RECURSIVE和PTHREAD
\_MUTEX\_DEFAULT。它们分别定义了不同的上锁、解锁机制，一般情况下，选用最后一个默认属性。
　　pthread\_mutex\_lock声明开始用互斥锁上锁，此后的代码直至调用pthread\_mutex\_unlock为止，均被上锁，即同一时间只能被一个线程调用执行。当一个线程执行到pthread\_mutex\_lock处时，如果该锁此时被另一个线程使用，那此线程被阻塞，即程序将等待到另一个线程释放此互斥锁。在上面的例子中，我们使用了pthread\_delay\_np函数，让线程睡眠一段时间，就是为了防止一个线程始终占据此函数。
　　上面的例子非常简单，就不再介绍了，需要提出的是在使用互斥锁的过程中很有可能会出现死锁：两个线程试图同时占用两个资源，并按不同的次序锁定相应的互斥锁，例如两个线程都需要锁定互斥锁1和互斥锁2，a线程先锁定互斥锁1，b线程先锁定互斥锁2，这时就出现了死锁。此时我们可以使用函数pthread\_mutex\_trylock，它是函数pthread\_mutex\_lock的非阻塞版本，当它发现死锁不可避免时，它会返回相应的信息，程序员可以针对死锁做出相应的处理。另外不同的互斥锁类型对死锁的处理不一样，但最主要的还是要程序员自己在程序设计注意这一点。

*　　4.3 条件变量
*　　前一节中我们讲述了如何使用互斥锁来实现线程间数据的共享和通信，互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其它的某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线承间的同步。
　　条件变量的结构为pthread\_cond\_t，函数pthread\_cond\_init（）被用来初始化一个条件变量。它的原型为：

#+BEGIN_EXAMPLE
    extern int pthread_cond_init __P ((pthread_cond_t *__cond,__const pthread_condattr_t *__cond_attr));
#+END_EXAMPLE

　　其中cond是一个指向结构pthread\_cond\_t的指针，cond\_attr是一个指向结构pthread\_condattr\_t的指针。结构pthread\_condattr\_t是条件变量的属性结构，和互斥锁一样我们可以用它来设置条件变量是进程内可用还是进程间可用，默认值是PTHREAD\_
PROCESS\_PRIVATE，即此条件变量被同一进程内的各个线程使用。注意初始化条件变量只有未被使用时才能重新初始化或被释放。释放一个条件变量的函数为pthread\_cond\_
destroy（pthread\_cond\_t cond）。　
　　函数pthread\_cond\_wait（）使线程阻塞在一个条件变量上。

　　它的函数原型为：

#+BEGIN_EXAMPLE
    extern int pthread_cond_wait __P ((pthread_cond_t *__cond,
    pthread_mutex_t *__mutex));
#+END_EXAMPLE

　　线程解开mutex指向的锁并被条件变量cond阻塞。线程可以被函数pthread\_cond\_signal和函数pthread\_cond\_broadcast唤醒，但是要注意的是，条件变量只是起阻塞和唤醒线程的作用，具体的判断条件还需用户给出，例如一个变量是否为0等等，这一点我们从后面的例子中可以看到。线程被唤醒后，它将重新检查判断条件是否满足，如果还不满足，一般说来线程应该仍阻塞在这里，被等待被下一次唤醒。这个过程一般用while语句实现。
　　另一个用来阻塞线程的函数是pthread\_cond\_timedwait()，它的原型为：

#+BEGIN_EXAMPLE
    extern int pthread_cond_timedwait __P ((pthread_cond_t *__cond,
    pthread_mutex_t *__mutex, __const struct timespec *__abstime));
#+END_EXAMPLE

　　它比函数pthread\_cond\_wait()多了一个时间参数，经历abstime段时间后，即使条件变量不满足，阻塞也被解除。
　　函数pthread\_cond\_signal()的原型为：
　　extern int pthread\_cond\_signal \_\_P ((pthread\_cond\_t
*\_\_cond));
　　它用来释放被阻塞在条件变量cond上的一个线程。多个线程阻塞在此条件变量上时，哪一个线程被唤醒是由线程的调度策略所决定的。要注意的是，必须用保护条件变量的互斥锁来保护这个函数，否则条件满足信号又可能在测试条件和调用pthread\_cond\_wait函数之间被发出，从而造成无限制的等待。下面是使用函数pthread\_cond\_wait()和函数

#+BEGIN_EXAMPLE
    pthread_cond_signal()的一个简单的例子。
    pthread_mutex_t count_lock;
    pthread_cond_t count_nonzero;
    unsigned count;
    decrement_count () {
        pthread_mutex_lock (&count_lock);
        while(count==0)
            pthread_cond_wait( &count_nonzero, &count_lock);
        count=count -1;
        pthread_mutex_unlock (&count_lock);
    }

    increment_count(){
        pthread_mutex_lock(&count_lock);
        if(count==0)
            pthread_cond_signal(&count_nonzero);
        count=count+1;
        pthread_mutex_unlock(&count_lock);
    }
#+END_EXAMPLE

　　count值为0时，decrement函数在pthread\_cond\_wait处被阻塞，并打开互斥锁count\_lock。此时，当调用到函数increment\_count时，pthread\_cond\_signal（）函数改变条件变量，告知decrement\_count（）停止阻塞。读者可以试着让两个线程分别运行这两个函数，看看会出现什么样的结果。
　　函数pthread\_cond\_broadcast（pthread\_cond\_t
*cond）用来唤醒所有被阻塞在条件变量cond上的线程。这些线程被唤醒后将再次竞争相应的互斥锁，所以必须小心使用这个函数。

 

*　　4.4 信号量*
　　信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。当公共资源增加时，调用函数sem\_post（）增加信号量。只有当信号量值大于０时，才能使用公共资源，使用后，函数sem\_wait（）减少信号量。函数sem\_trywait（）和函数pthread\_
mutex\_trylock（）起同样的作用，它是函数sem\_wait（）的非阻塞版本。下面我们逐个介绍和信号量有关的一些函数，它们都在头文件/usr/include/semaphore.h中定义。
　　信号量的数据类型为结构sem\_t，它本质上是一个长整型的数。函数sem\_init（）用来初始化一个信号量。它的原型为：
　　extern int sem\_init \_\_P ((sem\_t *\_\_sem, int \_\_pshared,
unsigned int \_\_value));
　　sem为指向信号量结构的一个指针；pshared不为０时此信号量在进程间共享，否则只能为当前进程的所有线程共享；value给出了信号量的初始值。
　　函数sem\_post( sem\_t *sem
)用来增加信号量的值。当有线程阻塞在这个信号量上时，调用这个函数会使其中的一个线程不在阻塞，选择机制同样是由线程的调度策略决定的。
　　函数sem\_wait( sem\_t *sem
)被用来阻塞当前线程直到信号量sem的值大于0，解除阻塞后将sem的值减一，表明公共资源经使用后减少。函数sem\_trywait
( sem\_t *sem
)是函数sem\_wait（）的非阻塞版本，它直接将信号量sem的值减一。
　　函数sem\_destroy(sem\_t *sem)用来释放信号量sem。
　　下面我们来看一个使用信号量的例子。在这个例子中，一共有4个线程，其中两个线程负责从文件读取数据到公共的缓冲区，另两个线程从缓冲区读取数据作不同的处理（加和乘运算）。

#+BEGIN_EXAMPLE
    /* File sem.c */
    #include <stdio.h>
    #include <pthread.h>
    #include <semaphore.h>
    #define MAXSTACK 100
    int stack[MAXSTACK][2];
    int size=0;
    sem_t sem;

    /* 从文件1.dat读取数据，每读一次，信号量加一*/
    void ReadData1(void){
        FILE *fp=fopen("1.dat","r");
        while(!feof(fp)){
            fscanf(fp,"%d %d",&stack[size][0],&stack[size][1]);
            sem_post(&sem);
            ++size;
        }
        fclose(fp);
    }

    /*从文件2.dat读取数据*/
    void ReadData2(void){
        FILE *fp=fopen("2.dat","r");
        while(!feof(fp)){
            fscanf(fp,"%d %d",&stack[size][0],&stack[size][1]);
            sem_post(&sem);
            ++size;
        }
        fclose(fp);
    }
    /*阻塞等待缓冲区有数据，读取数据后，释放空间，继续等待*/
    void HandleData1(void){
        while(1){
            sem_wait(&sem);
            printf("Plus:%d+%d=%d\n",stack[size][0],stack[size][1],
            stack[size][0]+stack[size][1]);
            --size;
        }
    }

    void HandleData2(void){
        while(1){
            sem_wait(&sem);
            printf("Multiply:%d*%d=%d\n",stack[size][0],stack[size][1],
            stack[size][0]*stack[size][1]);
            --size;
        }
    }

    int main(void){
        pthread_t t1,t2,t3,t4;
        sem_init(&sem,0,0);
        pthread_create(&t1,NULL,(void *)HandleData1,NULL);
        pthread_create(&t2,NULL,(void *)HandleData2,NULL);
        pthread_create(&t3,NULL,(void *)ReadData1,NULL);
        pthread_create(&t4,NULL,(void *)ReadData2,NULL);
        /* 防止程序过早退出，让它在此无限期等待*/
        pthread_join(t1,NULL);
    }
#+END_EXAMPLE

　　在Linux下，我们用命令gcc -lpthread sem.c -o sem生成可执行文件sem。
我们事先编辑好数据文件1.dat和2.dat，假设它们的内容分别为1 2 3 4 5 6 7 8
9 10和 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 ，我们运行sem，得到如下的结果：
　　Multiply:-1*-2=2
　　Plus:-1+-2=-3
　　Multiply:9*10=90
　　Plus:-9+-10=-19
　　Multiply:-7*-8=56
　　Plus:-5+-6=-11
　　Multiply:-3*-4=12
　　Plus:9+10=19
　　Plus:7+8=15
　　Plus:5+6=11

　　从中我们可以看出各个线程间的竞争关系。而数值并未按我们原先的顺序显示出来这是由于size这个数值被各个线程任意修改的缘故。这也往往是多线程编程要注意的问题。

*5. 小结*

　　多线程编程是一个很有意思也很有用的技术，使用多线程技术的网络蚂蚁是目前最常用的下载工具之一，使用多线程技术的grep比单线程的grep要快上几倍，类似的例子还有很多。希望大家能用多线程技术写出高效实用的好程序来。

** [[http://www.cnblogs.com/finlay/p/pthread_create%e6%9c%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e5%bc%95%e7%94%a8.html][编译Linux程序出现“对‘pthread\_create'未定义的引用”]]

2013-08-06 17:06 by Finlay Liu, ... 阅读, ... 评论, [[#][收藏]],
[[http://i.cnblogs.com/EditPosts.aspx?postid=3240910][编辑]]

　　在学习Linux程序设计POXIS线程的时候，编译一个段简单的代码，就出现下面的错误：

#+BEGIN_EXAMPLE
    1 /tmp/cc2FQJTh.o：在函数‘main’中：
    2 1-thread.c:(.text+0x29)：对‘pthread_create’未定义的引用
    3 1-thread.c:(.text+0x67)：对‘pthread_join’未定义的引用
    4 collect2: 错误： ld 返回 1
#+END_EXAMPLE

　　可是在我的代码中已经包含了pthread.h，这是什么回事呢，百度一下，*发现网上大部分的解决办法是在gcc编译命令加上选项：lpthread。*

#+BEGIN_EXAMPLE
    1 gcc -o pthread -lpthread pthread.c
#+END_EXAMPLE

　　但我照着网上的方法试试，发现还是不行，错误提示与原来相同。后来才发现是我自己错了，我是在目标代码文件前加上-lpthread。但实际的做法应该是在代码文件后面添加次选项。

#+BEGIN_EXAMPLE
    1 finlay@finlay-Lenovo-G470:~/文档/程序设计/Linux程序设计/12章$ gcc 1-thread.c -lpthread
    2 #成功！
    3 finlay@finlay-Lenovo-G470:~/文档/程序设计/Linux程序设计/12章$ gcc -lpthread -Wall 1-thread.c
    4 #失败！
    5 /tmp/ccE6dosW.o：在函数‘main’中：
    6 1-thread.c:(.text+0x29)：对‘pthread_create’未定义的引用
    7 1-thread.c:(.text+0x67)：对‘pthread_join’未定义的引用
    8 collect2: 错误： ld 返回 1
#+END_EXAMPLE

　　但是还有一个什么有趣的现象，如下：

#+BEGIN_EXAMPLE
    1 finlay@finlay-Lenovo-G470:~/文档/程序设计/Linux程序设计/12章$ gcc -pthread 1-thread.c
    2 #成功！
    3 finlay@finlay-Lenovo-G470:~/文档/程序设计/Linux程序设计/12章$ gcc -lpthread 1-thread.c
    4 #失败！
    5 /tmp/ccbr6m7v.o：在函数‘main’中：
    6 1-thread.c:(.text+0x29)：对‘pthread_create’未定义的引用
    7 1-thread.c:(.text+0x67)：对‘pthread_join’未定义的引用
    8 collect2: 错误： ld 返回 1
#+END_EXAMPLE

　　那么，-pthread与-lpthread的区别是什么呢？我们可以在verbose模式下执行一下对应的gcc命令行看出来。下面是老式的直接加
-lpthread 链接选项的输出结果：

#+BEGIN_EXAMPLE
    $ gcc -v -c x.c
    ...
    /usr/lib/gcc/i486-linux-gnu/4.2.4/cc1 -quiet -v x.c -quiet -dumpbase x.c
    -mtune=generic -auxbase x -version -fstack-protector -fstack-protector -o /tmp/cch4ASTF.s
    ...
    as --traditional-format -V -Qy -o x.o /tmp/cch4ASTF.s
    ...
    $ gcc -v x.o -ox -lpthread
    ...
     /usr/lib/gcc/i486-linux-gnu/4.2.4/collect2 --eh-frame-hdr -m elf_i386 --hash-style=both
    -dynamic-linker /lib/ld-linux.so.2 -ox
    /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crt1.o
    /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crti.o
    /usr/lib/gcc/i486-linux-gnu/4.2.4/crtbegin.o
    -L/opt/intel/Compiler/11.1/046/tbb/ia32/cc4.1.0_libc2.4_kernel2.6.16.21/lib/../lib
    -L/usr/lib/gcc/i486-linux-gnu/4.2.4
    -L/usr/lib/gcc/i486-linux-gnu/4.2.4
    -L/usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib
    -L/lib/../lib
    -L/usr/lib/../lib
    -L/opt/intel/Compiler/11.1/046/lib/ia32
    -L/opt/intel/Compiler/11.1/046/tbb/ia32/cc4.1.0_libc2.4_kernel2.6.16.21/lib
    -L/usr/lib/gcc/i486-linux-gnu/4.2.4/../../..
    x.o -lpthread -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc
    --as-needed -lgcc_s --no-as-needed
    /usr/lib/gcc/i486-linux-gnu/4.2.4/crtend.o /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crtn.o
#+END_EXAMPLE

　　下面是在编译和链接时分别指定 -pthread 选项的输出结果：

#+BEGIN_EXAMPLE
     1 $ gcc -v -pthread -c x.c
     2 ...
     3 /usr/lib/gcc/i486-linux-gnu/4.2.4/cc1 -quiet -v <strong>-D_REENTRANT</strong>
     4  x.c -quiet -dumpbase x.c
     5 -mtune=generic -auxbase x -version -fstack-protector -fstack-protector -o /tmp/cc205IQf.s
     6 ...
     7 as --traditional-format -V -Qy -o x.o /tmp/cc205IQf.s
     8 ...
     9 $ gcc -v x.o -ox -pthread
    10 /usr/lib/gcc/i486-linux-gnu/4.2.4/collect2 --eh-frame-hdr -m elf_i386 --hash-style=both
    11 -dynamic-linker /lib/ld-linux.so.2 -ox
    12 /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crt1.o
    13 /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crti.o
    14 /usr/lib/gcc/i486-linux-gnu/4.2.4/crtbegin.o
    15 -L/opt/intel/Compiler/11.1/046/tbb/ia32/cc4.1.0_libc2.4_kernel2.6.16.21/lib/../lib
    16 -L/usr/lib/gcc/i486-linux-gnu/4.2.4
    17 -L/usr/lib/gcc/i486-linux-gnu/4.2.4
    18 -L/usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib
    19 -L/lib/../lib
    20 -L/usr/lib/../lib
    21 -L/opt/intel/Compiler/11.1/046/lib/ia32
    22 -L/opt/intel/Compiler/11.1/046/tbb/ia32/cc4.1.0_libc2.4_kernel2.6.16.21/lib
    23 -L/usr/lib/gcc/i486-linux-gnu/4.2.4/../../..
    24 x.o -lgcc --as-needed -lgcc_s --no-as-needed <strong>-lpthread</strong>
    25  -lc -lgcc
    26 --as-needed -lgcc_s --no-as-needed
    27 /usr/lib/gcc/i486-linux-gnu/4.2.4/crtend.o /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crtn.o
#+END_EXAMPLE

　　所以可见编译选项中指定 -pthread
会附加一个宏定义 *-D\_REENTRANT* ，该宏会导致 libc
头文件选择那些thread-safe的实现；链接选项中指定 -pthread 则同 -lpthread
一样，只表示链接 POSIX thread 库。由于 libc 用于适应 thread-safe
的宏定义可能变化，因此在编译和链接时都使用 -pthread 选项而不是传统的
-lpthread 能够保持向后兼容，并提高命令行的一致性。


** [[http://xg1990.com/blog/archives/87][Linux/Ubuntu下Octopress博客搭建过程]]

Posted on
[[http://xg1990.com/blog/archives/date/2012/03/13][2012年3月13日]] in
[[http://xg1990.com/blog/archives/category/tips][技术]]

总算搭好了这个静态博客，之前尝试了Jekyll与Jekyllbootstrap，还是不够给力，总是出现各种莫名的问题，总结下这个博客的搭建过程(Linux/Ubuntu
环境)：

**** 安装前准备

(这部分内容来自
http://gujiaxi.github.com/blog/2012/02/15/how-to-install-octopress-on-ubuntu-11-dot-04-and-deploy-on-github/)

配置前需要=curl=,=git=两个工具，安装之

sudo apt-get install curl git-core

| 1   | sudo apt-get install curl git-core   |

先确保ubuntu源中的=ruby=,=rubygem=已经卸载,如果没有，使用=sudo apt-get remove=命令卸载之

安装RVM(Ruby Version Manager)

bash -s stable &lt; &lt;(curl -s
https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer)

| 1   | bash -s stable &lt; &lt;(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer)   |

将rvm指令变成shell function

echo &#039;[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; .
&quot;$HOME/.rvm/scripts/rvm&quot;&#039;&gt;&gt;~/.bashrc

| 1   | echo &#039;[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; . &quot;$HOME/.rvm/scripts/rvm&quot;&#039;&gt;&gt;~/.bashrc   |

完毕之后重启终端，运行

type rvm | head -1

| 1   | type rvm | head -1   |

应该就能看到=rvm is a function=，说明安装成功

然后，在rvm下安装Ruby 1.9.2, RubyGems

rvm pkg install openssl rvm pkg install zlib rvm install 1.9.2 rvm use
1.9.2 rvm rubygems latest

| 1   | rvm pkg install openssl   |
| 2   | rvm pkg install zlib      |
| 3   | rvm install 1.9.2         |
| 4   | rvm use 1.9.2             |
| 5   | rvm rubygems latest       |

即可

**** 配置octopress

(这部分内容来自
http://gujiaxi.github.com/blog/2012/02/15/how-to-install-octopress-on-ubuntu-11-dot-04-and-deploy-on-github/)

下载octopress

git clone https://github.com/imathis/octopress.git octopress

| 1   | git clone https://github.com/imathis/octopress.git octopress   |

这里下载到了本地文件夹octopress ，然后依次执行

cd octopress gem install bundler bundle install rake install

| 1   | cd octopress          |
| 2   | gem install bundler   |
| 3   | bundle install        |
| 4   | rake install          |

然后就基本配置好了

添加 \(LaTeX\)

支持

(这部分内容来自
http://luikore.github.com/2011/09/good-things-learned-from-octopress/)

这里有个非常给力的 \(LaTeX\)

,排出来的公式还能够继续被识别为文字，比那些通过生成png实现的公式强多了

安装插件

gem install kramdown

| 1   | gem install kramdown   |

修改octopress目录下的\_config.yml，将其中的

markdown: rdiscount

| 1   | markdown: rdiscount   |

改为

markdown: kramdown

| 1   | markdown: kramdown   |

然后修改octopress/source/\_includes/custom/head.html
 向其中添加

&lt;!-- mathjax config similar to math.stackexchange --&gt; &lt;script
type=&quot;text/x-mathjax-config&quot;&gt; MathJax.Hub.Config({ jax:
[&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;], tex2jax: {
inlineMath: [ [&#039;$&#039;, &#039;$&#039;] ], displayMath: [
[&#039;$\$&#039;, &#039;$\$&#039;]], processEscapes: true, skipTags:
[&#039;script&#039;, &#039;noscript&#039;, &#039;style&#039;,
&#039;textarea&#039;, &#039;pre&#039;, &#039;code&#039;] },
messageStyle: &quot;none&quot;, &quot;HTML-CSS&quot;: { preferredFont:
&quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] }
}); &lt;/script&gt; &lt;script
src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS\_HTML&quot;
type=&quot;text/javascript&quot;&gt;&lt;/script&gt;

| 1    | &lt;!-- mathjax config similar to math.stackexchange --&gt;                                                                                            |
| 2    | &lt;script type=&quot;text/x-mathjax-config&quot;&gt;                                                                                                  |
| 3    | MathJax.Hub.Config({                                                                                                                                   |
| 4    |   jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],                                                                                           |
| 5    |   tex2jax: {                                                                                                                                           |
| 6    |     inlineMath: [ [&#039;$&#039;, &#039;$&#039;] ],                                                                                                    |
| 7    |     displayMath: [ [&#039;$\$&#039;, &#039;$\$&#039;]],                                                                                                |
| 8    |     processEscapes: true,                                                                                                                              |
| 9    |     skipTags: [&#039;script&#039;, &#039;noscript&#039;, &#039;style&#039;, &#039;textarea&#039;, &#039;pre&#039;, &#039;code&#039;]                   |
| 10   |   },                                                                                                                                                   |
| 11   |   messageStyle: &quot;none&quot;,                                                                                                                      |
| 12   |   &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] }                                         |
| 13   | });                                                                                                                                                    |
| 14   | &lt;/script&gt;                                                                                                                                        |
| 15   | &lt;script src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS\_HTML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;   |

但是此时右键单击公式会出现bug，解决办法是修改octopress/sass/base/\_theme.scss如下所示比如

body - &gt; div + &gt; div#main background: $sidebar-bg border-bottom:
1px solid $page-border-bottom &gt; div background: $main-bg
border-right: 1px solid $sidebar-border

| 1   | body                                           |
| 2   | - &gt; div                                     |
| 3   | + &gt; div#main                                |
| 4   | background: $sidebar-bg                        |
| 5   | border-bottom: 1px solid $page-border-bottom   |
| 6   | &gt; div                                       |
| 7   | background: $main-bg                           |
| 8   | border-right: 1px solid $sidebar-border        |

 

**** 调整样式

最后，我觉得octopress的段距与行高太大了，
 修改octopress/source/stylesheets/screen.css，
 找到
 =p,blockquote,ul,ol{margin-bottom:0.5em}=
 与
 =body{line-height:1.1em;color:#222}=
 修改到合适的值即可

** [[http://blog.csdn.net/zd0303/article/details/7536967][Matlab中巧用LaTex]]

Matlab作为数据计算和处理的数学语言(软件)，而LaTex作为出版界的重要排版语言(软件)，尤其是对数学公式的排版功能特别强。在Matlab中有两种方法使用LaTeX：1）对Matlab生成的图形标注时，2）Matlab的计算结果转化成LaTeX格式。

1）  对Matlab生成的图形标注

Matlab图形中title、xlabel、ylabel、zlabel、textbox和legend等的Interpreter属性有三个属性：latex
、tex、none。默认为tex。(注：LaTeX是一套以TeX描述的宏软件。LaTeX有很多预设的模版、样式。它比TeX更为结构化，如包含了供建立索引、表格、列表等的宏和公用软件。利用这种格式，即使用户没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，对于生成复杂表格和数学公式，这一点表现得尤为突出)。

为方便利用LaTeX的命令，需要在把Matlab图形中title、xlabel、ylabel、zlabel、textbox和legend等的Interpreter属性设定为latex。首先，在Matlab中使用LaTeX语言的格式有三种：

1、\( LaTeX命令\)

2、$ LaTeX命令$

3、$$ LaTeX命令$$

以Matlab图形中的textbox属性为例，首先在图形中输入一个双重积分，然后输入一个Schrodinger方程。命令为：

x=0:0.2:2*pi;

y=sin(x);
 My\_paper\_figure(x,y)
 text('Interpreter','latex','String','$\rightarrow\phi
+\sin(x)$','Position',[2.2 sin(2)],'FontSize',20);
 %在坐标(2.2,sin(2)处输出-->)
 输出结果为

[[http://img.my.csdn.net/uploads/201211/02/1351820919_3763.jpg]]

当然也可以使用\(
\)命令。以此类推也可以对title、xlabel、ylabel、zlabel和legend等使用LaTeX命令，如：

xlabel({'∫x0∫ydF(u,v)'},'Interpreter','latex')

至于LaTeX命令使用方法可以参考[[http://www.sciencenet.cn/m/user_content.aspx?id=246649][LaTeX教程]]。

2）把Matlab的计算结果转化成Latex格式

    对于Matlab计算出的符号运算结果，可以通过latex()函数转化成LeTeX命令格式。由于latex()函数只对符号表达式进行转换，对于数值结果一定要通过sym()函数转化成符号结果。所以，为防止对数值结果转化出错，可同时使用latex()和sym()函数：latex(sym(s));
其中s代表符号表达式。

例如：syms a b c

s=a/b+c

使用latex(s)后转化为LeTeX命令：

{\frac {a}{b}}+c

附：数学符号和希腊字母的命令及其符号

 

[[http://blog.sciencenet.cn/upload/blog/images/2010/4/20104894349872.JPG]]

3）把Matlab的分析图片结果转化成Latex使用的.eps格式，以便使用latex进行编辑使用。

可以使用Latex Markup，将M-file转换成 text-file。

cell ->Insert text parkup ->Latex Markup

在编辑完M-file文件后，点击Publish 图标“[[http://write.blog.csdn.net/postedit/7537099]][[http://write.blog.csdn.net/postedit/7537099]]”的倒三角号，选择"Edit
M-File Con gurations" 窗口.

[[http://write.blog.csdn.net/postedit/7537099]][[http://write.blog.csdn.net/postedit/7537099]]

然后在"Publish settings"的对话框中，选择“Output file format”
中的“latex”选项，点击“Save as”即可。


** [[http://yaxin-cn.github.io/Python/classmethod-and-staticmethod-in-python.html][Python中的类方法和静态方法]]

*** 2014-12-22

Python类中有两个特殊的修饰符@classmethod和@staticmethod(即类方法和静态方法),
想要理解需要先理解类属性和实例属性的感念

*** 类属性和实例属性

看下面的代码

#+BEGIN_EXAMPLE
    >>> class TestProperty(object):
    ...     class_property = "class property"
    ...
    ...     def __init__(self):
    ...         self.instance_property = "instance property"
    >>>
    >>> test_property = TestProperty()
    >>> # 实例可以访问实例属性和类属性
    >>> print test_property.class_property
    class property
    >>> print test_property.instance_property
    instance property
    >>> # 类可以访问类属性
    >>> print TestProperty.class_property
    class property
    >>> # 但不可以访问实例属性
    >>> print TestProperty.instance_property
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    AttributeError: type object 'TestProperty' has no attribute 'instance_property'
    >>> # 注意下面的报错
    >>> del test_property.class_property
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    AttributeError: class_property
#+END_EXAMPLE

总结起来就是:

1. *实例属性*的初始化在=__init__=构造器方法中进行(当然也可以通过其它方法赋值)
2. *类实例*可以访问实例属性和类属性
3. 通过类本身则能访问类属性,无法访问实例属性
4. 类属性与类实例没有任何关系
5. 类属性其实就是其它语言中的静态变量(变量前加static)
6. 为什么要有类属性, 一句话*命名空间*

*** 类方法和静态方法

#+BEGIN_EXAMPLE
    >>> class TestMethod(object):
    ...     class_property = "class property"
    ...     def __init__(self):
    ...         self.instance_property = "instance property"
    ...     def instance_method(self, arvg):
    ...         print "instance_method(%s, %s)" % (self, arvg)
    ...         print "instance property: ", self.instance_property
    ...     @classmethod
    ...     def class_method(cls, arvg):
    ...         print "class_method(%s, %s)" % (cls, arvg)
    ...         print "class property: ", cls.class_property
    ...     @staticmethod
    ...     def static_method(arvg):
    ...         print "static_method(%s)" % arvg
    ...
    >>>
    >>> test_method = TestMethod()
    >>> # 执行普通方法, 打印出实例的内存地址和实例属性
    >>> test_method.instance_method("Hello")
    instance_method(<__main__.TestMethod object at 0x7fd8fc56eb90>, Hello)
    instance property:  instance property
    >>> # 执行类方法
    >>> # 通过实例访问, 打印出类本身和类属性
    >>> test_method.class_method("Hello")
    class_method(<class '__main__.TestMethod'>, Hello)
    class property:  class property
    >>> # 通过类直接访问, 同上
    >>> TestMethod.class_method("Hello")
    class_method(<class '__main__.TestMethod'>, Hello)
    class property:  class property
    >>> # 执行静态方法
    >>> # 通过实例访问, 打印出静态方法本身
    >>> test_method.static_method("Hello")
    static_method(Hello)
    >>> # 通过类直接访问, 同上
    >>> TestMethod.static_method("Hello")
    static_method(Hello)
#+END_EXAMPLE

可以看出类方法中=cls=代表的是类本身,
如果将类方法中的访问类属性的cls去掉, 则会报出/NameError/的错误

#+BEGIN_EXAMPLE
    >>> class TestMethod(object):
    ...     class_property = "class property"
    ...     @classmethod
    ...     def class_method(cls, arvg):
    ...         print "class property: ", cls.class_property
    ...
    >>> TestMethod.class_method("Hello")
    class property:
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 5, in class_method
    NameError: global name 'class_property' is not defined
#+END_EXAMPLE

1. *类方法是为了访问类属性更加方便*
2. 类方法和静态方法可以通过类和实例来访问,效果是相同的
3. 静态方法跟普通函数没有什么区别

可以通过在实例方法中直接通过=TestMethod.class_property=来访问,
但是这样不方便也不好维护(如果类名称改了,就会出错),
也可以使用=self.class_property=来访问, 但注意,
实例本身获取的并不应该是类属性即=TestMethod.class_property=,
只是因为实例中并没有=class_property=这个变量,
而是通过查找类属性,发现有同名变量,然后打印出来,通过上面无法实例无法删除类属性是可以看出来的.
当然,如果不信,可以看下面的例子

#+BEGIN_EXAMPLE
    >>> class TestMethod(object):
    ...     class_property = "class property"
    ...     def __init__(self):
    ...         pass
    ...
    >>> test_method = TestMethod()
    >>> id(test_method.class_property)
    140488040794968
    >>> id(TestMethod.class_property)
    140488040794968
    >>> print test_method.class_property
    class property
    >>> test_method.class_property = test_method.class_property + "!!!"
    >>> print test_method.class_property
    class property!!!
    >>> print TestMethod.class_property
    class property
    >>> id(test_method.class_property)
    140488040795080
    >>> id(TestMethod.class_property)
    140488040794968
#+END_EXAMPLE

** http://www.emacswiki.org/emacs/DeletingWhitespace

** [[http://www.cnblogs.com/emouse/p/3483774.html][Altium Designer 13 安装完整元件库]]

Altium Designer更新的非常快，都快赶上chrome了，13出来没多久14又出来了，之前一直用AD9.4，算是10之前的最后一个版本，也是很经典的一个版本。安装新版本后看到在目录结构上有些编号，元件库和示例文件从原来的安装根目录调整到C:\Users\Public\Documents\Altium\AD13文件夹中，而且元件库也默认只安装了一部分，包含常用的库和FPGA库，如下图所示。



更多的库可以在线下载（需要自己申请账号）http://designcontent.live.altium.com/#UnifiedComponents 也可以通过之前老版本的安装包再安装。

通过之前的老版本安装的方式也很简单，在老的安装包中元件库是单独存在的，在安装的时候会跟着一起安装，因此可以使用之前的安装包安装。

我用的是AD9.4的安装包，安装路径如下I:\AltiumDesignerSummer9Build9.4.0.20159\Setup\Board Level Libraries 点击Setup.exe即可安装，注意安装的目录，安装完成后即可得到老版本中完整的元件库。


** [[https://linuxtoy.org/archives/top-5-screen-recorder-for-linux.html][Linux 下值得使用的 5 个屏幕录像软件]]

2008-06-23 By [[https://linuxtoy.org/author/toy.html][toy]] Posted in
[[https://linuxtoy.org/category/tools.html][Tools]] Tagged as
[[https://linuxtoy.org/tag/screen-recorder.html][screen recorder]]
[[https://linuxtoy.org/tag/top-5.html][top 5]] Edit on
[[https://github.com/xuxiaodong/linuxtoy.org/blob/master/content/top-5-screen-recorder-for-linux.md][GitHub]]

在很多时候，我们需要将在 Linux
桌面上的操作过程录制下来，比如制作屏幕演示、视频教学等。这里将介绍在
Linux 下值得使用的 5 个屏幕录像软件，包括
Istanbul、Wink、Xvidcap、Vnc2swf、Recordmydesktop，希望对有此需求的朋友提供参考。

1. *[[http://linuxtoy.org/archives/istanbul.html][Istanbul]]* 使用
   Istanbul，你可以将 Linux 屏幕上的一切操作过程录制下来。Istanbul
   既能够按照你的需要录制全屏、区域或者窗口，也可以录制声音和鼠标指针，最终会生成
   Ogg Theora 格式的视频文件。
2. *[[http://linuxtoy.org/archives/wink.html][Wink]]* Wink 是录制 Flash
   视频演示的极好工具，除支持 Linux 平台外，也能够在 Windows
   系统上运行。你可以使用 Wink 为所录制的文件添加文字说明和声音旁白。
3. *[[http://linuxtoy.org/archives/xvidcap.html][Xvidcap]]* Xvidcap
   支持生成 avi、mpeg、asf、flv、swf、mov
   等视频格式，可以应用在各种场合。录制的区域也可以随意选择，显得非常方便。
4. *[[http://linuxtoy.org/archives/vnc2swf.html][Vnc2swf]]* Vnc2swf 是继
   Wink 外适合在 Linux 中使用的另一个 Flash 录制工具，但比 Wink
   稍微要难用点，而且也没有 Wink 功能全面。
5. *[[http://linuxtoy.org/archives/recordmydesktop.html][Recordmydesktop]]*
   Recordmydesktop
   功能主要有：可录制全屏、窗口，也可以录制选择的区域；除了能够录制视频的基本功能之外，还能够录制音频；有一些录制的参数可以调整；生成的视频格式为
   ogg。它默认提供 GTK+ 界面，另外也有一个适合 KDE 桌面环境的
   [[http://linuxtoy.org/archives/rekordmydesktop.html][reKordmydesktop]]。

** [[http://blog.useasp.net/archive/2014/09/05/rst-file-restructuredtext-markup-syntax-quikstart.aspx][reStructuredText(.rst)语法规则快速入门]]


这几天写了个[[http://blog.useasp.net/tags/Python][Python]]的模块，用Markdown写个个README，传到GitHub，感觉效果还不错，就难抑冲动，打了个包，也想放到PyPI上，结果放上去，发现README变成了源代码。一查，才发现PyPI竟然不支持Markdown格式的README文件，好像支持的README要reStructuredText格式的，对菜鸟的我来说这是个坑啊，好不容易在Emacs下用Markdown用的有点熟路了，结果发现却不被支持。只好重新看看reStructuredText的语法了，因此，也就有了此篇reStructuredText语法快速入门。

先文绉绉的来一段[[http://blog.useasp.net/tags/reStructuredText][reStructuredText]]的介绍吧：

reStructuredText是一种轻量级的文本标记语言，直译为：重构建的文本，为Python中Docutils项目的一部分。其一般保存的文件以.rst为后缀。在必要的时候，.rst文件可以被转化成PDF或者HTML格式，也可以有Sphinx转化为LaTex,man等格式，现在被广泛的用于程序的文档撰写。

 好了，时间无多，直接正题：

reStructuredText大致分章节，段落，块和列表这几种内容。而在这其中reStructuredText最主要用得到的标记也就是：

-  [[#title][标题]]
-  [[#paragraph][段落]]
-  [[#list][列表]]
-  [[#table][表格]]
-  [[#block][块（如：代码块）]]
-  [[#style][样式]]

下面一一介绍：

 

 

*标题（Title）*

来看看标题的实例：

#+BEGIN_EXAMPLE
    ===================
    这就是一个标题
    ===================

    ----------------
    这也是一个章节标题
    ----------------
#+END_EXAMPLE

怎么样，看起来不难吧，你只要按这个写法，就能被reStructuredText认识，并被解释为章节标题。reStructuredText可用于作为标题修饰的字符有很多很多：

#+BEGIN_EXAMPLE
    ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~
#+END_EXAMPLE

只要你想，上面的任意一个都可以用来作为标题的修饰符，当然，reStructuredText也是有推荐的，它推荐下面这些字符：

#+BEGIN_EXAMPLE
    = - ` : . ' " ~ ^ _ * + #
#+END_EXAMPLE

这些字符是上面一堆字符中稍微看起来不会那么奇怪的一部分，当然，个人建议不要那么花哨，尽量用这两个中的一个：

#+BEGIN_EXAMPLE
    = -
#+END_EXAMPLE

上面实例的写法也许有点复杂，.rst文件中，你还可以只给出下半部分的字符即可：

#+BEGIN_EXAMPLE
    这个标题和上面的一样
    ===================
#+END_EXAMPLE

TIPS：作为修饰的字符长度要大于等于文字长度。另外，标题是能够嵌套的。

 

*段落（Paragraphs）*

段落一般隶属于某个章节中，是一块左对齐并且没有其他元素体标记的块。在.rst文件中，段落和其他内容的分割是靠空行来完成，如果段落相较于其他的段落有缩进，reStructuredText会解析为引用段落，样式上有些不同。

#+BEGIN_EXAMPLE
    这里是一段reStructuredText的内容，它可以很长很长。。。。最后，末尾留出空行表示是本段落的结束即可。


    这里是另外一段reStructuredText的内容，这段内容和上一段之间，乃至后面的其他内容之间都要留出空行进行分割。

        这个也是段落，当时由于缩进了，会变成引用段落。显示和直接的段落有点不同
#+END_EXAMPLE

 

*列表(List)*

列表在HTML中被分为两种，一个是有序列表（Enumerated
Lists），一种是无序列表（Bullet
Lists），在reStructuredText中，我们也能找到这两种列表，还有一种称为定义列表（Definition
Lists），这和HTML中的DL一样，在.[[http://blog.useasp.net/tags/rst文件][rst文件]]中可以支持嵌套列表。

/无序列表/要求文本块是以下面这些字符开始，并且后面紧跟空格，而后跟列表项的内容，其中列表项比趋势左对齐并且有与列表对应的缩进。

#+BEGIN_EXAMPLE
    * + - • ‣ ⁃
#+END_EXAMPLE

还是那句话，用最常用的几个字符就好，不用那么花哨。下面是示例：

#+BEGIN_EXAMPLE
    - 这里是列表的第一个列表项

    - 这是第二个列表项

    - 这是第三个列表项

      - 这是缩进的第一个列表项
        注意，这里的缩进要和当前列表项的缩进同步。

    - 第一级的第四个列表项

    - 列表项之间要用个空格来分割。
#+END_EXAMPLE

/有序列表/在格式上和无序列表差不多，但是在使用的前缀修饰符上，使用的不是无序列表那种字符，而是可排序的字符，可以识别的有下面这些：

#+BEGIN_EXAMPLE
    arabic numerals: 1, 2, 3, ... (no upper limit).
    uppercase alphabet characters: A, B, C, ..., Z.
    lower-case alphabet characters: a, b, c, ..., z.
    uppercase Roman numerals: I, II, III, IV, ..., MMMMCMXCIX (4999).
    lowercase Roman numerals: i, ii, iii, iv, ..., mmmmcmxcix (4999).
#+END_EXAMPLE

如果你不想使用这些，在你标明第一个条目的序号字符后，第二个开始你还可以使用"#"号来让reStructuredText自动生成需要的序号（Docutils
>= 0.3.8）。

#+BEGIN_EXAMPLE
    1. 第一项
        巴拉巴拉好多内容在这里。。。

    #. 第二项

        a. 第二项的第一小项

        #. 第二项的第二小项

    #. 第三项
#+END_EXAMPLE

 /定义列表/：每个定义列表项里面包含术语（term），分类器（classifiers，可选），
定义（definition）。术语是一行文字或者短语，分类器跟在术语后面，用“ ：
”(空格，冒号，空格）分隔。定义是相对于术语缩进后的一个块。定义中可以包含多个段落或者其他的内容元素。术语和定义之间可以没有空行，但是在定义列表前后必须要有空行的存在。下面是示例：

#+BEGIN_EXAMPLE
    术语1
        术语1的定义

    术语 2
        术语2的定义,这是第一段

        术语2的定义，第二段

    术语 3 : 分类器
        术语3的定义


    术语 4 : 分类器1 : 分类器2
        术语4的定义
#+END_EXAMPLE

 TIPS：在reStructuredText中，还有两种列表，一种是字段列表（Field
Lists），一种是选项列表（Option
Lists）。由于是rst的[[http://blog.useasp.net/tags/语法教程][语法入门教程]]，这里不做深入介绍

 

 *表格(Table)*

reStructuredText提供两种表格：网格表格（Grid Tables）， 简单表格（Simple
Tables）。

/ 网格表/中，共使用的符号有：

#+BEGIN_EXAMPLE
    - = | +
#+END_EXAMPLE

“-” 用来分隔行， “=“ 用来分隔表头和表体行，"|"
用来分隔列，而"+"用来表示行和列相交的节点，如下面的例子：

#+BEGIN_EXAMPLE
    +------------------------+------------+----------+----------+
    | Header row, column 1   | Header 2   | Header 3 | Header 4 |
    | (header rows optional) |            |          |          |
    +========================+============+==========+==========+
    | body row 1, column 1   | column 2   | column 3 | column 4 |
    +------------------------+------------+----------+----------+
    | body row 2             | Cells may span columns.          |
    +------------------------+------------+---------------------+
    | body row 3             | Cells may  | - Table cells       |
    +------------------------+ span rows. | - contain           |
    | body row 4             |            | - body elements.    |
    +------------------------+------------+---------------------+

    来自docutils的帮助文档.
#+END_EXAMPLE

 TIPS：表头行是可选的，如果你不需要，就可以不用"="来分割了。

 

/简单表格/：这种表格比网格表来说简单许多，一般用于简单的数据展示。其用于修饰的字符也仅两个而已：

#+BEGIN_EXAMPLE
    = -
#+END_EXAMPLE

一般用"="就能完成简单表格的绘制，如果有表头，同样需要用"="将它和表体(body)内容分开，否则会被视为无表头数据。

#+BEGIN_EXAMPLE
    基本形式
    ========

    `下面这种是最简单的表格形式，当然你也可以去掉表头展示。`

    =====  =====  =======
      A      B    A and B
    =====  =====  =======
    False  False  False
    True   False  False
    False  True   False
    True   True   True
    =====  =====  =======

    表内嵌入
    ========

    `下面这种简单表内有列表`

    =====  =====
    col 1  col 2
    =====  =====
    1      Second column of row 1.
    2      Second column of row 2.
           Second line of paragraph.
    3      - Second column of row 3.

           - Second item in bullet
             list (row 3, column 2).
    \      Row 4; column 1 will be empty.
    =====  =====

    表头合并
    ========

    `表头进行分类合并`

    =====  =====  ======
       Inputs     Output
    ------------  ------
      A      B    A or B
    =====  =====  ======
    False  False  False A
    True   False  True
    False  True   True
    True   True   True
    =====  =====  ======
#+END_EXAMPLE

 TIPS：列需要和"="左对齐，不然可能会导致出错；如果碰到第一列为空时，需要使用"\"来转义，不然会被视为是上一行的延续；网格表和简单表中，简单表比较适合展现简单的数据，这些数据本身不需要太复杂的展现形式，而一旦碰到需要和并单元格这类的复杂操作，可能网格表会更加适合。

表格中还有更复杂的表格形式，比如：CSV表格，列表表格。这些复杂的格式就留给有兴趣的朋友深入吧。

 

*块（Blocks）*

块在reStructuredText中的表现方式也有好几种，但是最常见的是文字块(Literal
Blocks)。这种块的表达非常简单，就是在前面内容结束之后，用两个冒号" ::
"(空格[Optional]，冒号，冒号）来分割，并在之后紧接着插入空行，而后放入块的内容，块内容要相对之前的内容有缩进。

#+BEGIN_EXAMPLE
    这里是块之前的的内容。。。::

       这里是块的内容。前面有缩进，空行，和::分隔符。
        此处内容会被一直视为块内容

        空行也不能阻断块内容。。

    但是，当内容像这样，不再和块内容一样缩进时，块内容就自动的结束了。
#+END_EXAMPLE

这是块的最简单方式，一般我们编写的代码块就是用这种方式表现（如下），
除此之外，.rst还有引用文字块(Quoted Literal Blocks)，行块（Line
Blocks），块引用（Block Quotes）等。

#+BEGIN_EXAMPLE
    下面是我们的测试代码：

    ::

        for i in [1,2,3,4,5]:
            print i
        # 代码块测试

    很简单的代码块测试。
#+END_EXAMPLE

 更多的块内容，请参阅官方帮助文档。

 

*样式(Style)*

reStructuredText中支持对文本进行样式控制，比如：粗体(Strong)，斜体(Italic)，等宽字体(Monospace)，引用( interpreted
text)。

#+BEGIN_EXAMPLE
    .. Strong Emphasis

    This is **Strong Text**. HTML tag is strong.粗体

    .. Italic, Emphasis

    This is *Emphasis* Text.这个HTML使用em， 斜体

    .. Interpreted Text

    This is `Interpreted Text`. 注意，这个HTML一般用<cite>表示

    .. Inline Literals

    This is ``Inline Literals``. HTML tag is <tt>. 等宽字体.
#+END_EXAMPLE

 

来点补充，如果你需要在文档中插入超链接，那么你可以像下面这样：

#+BEGIN_EXAMPLE
    我这里是一个 链接_.

    .. _链接: http://blog.useasp.net
#+END_EXAMPLE

这种方式要求定义链接，而后引用链接。而且链接要有空格分隔前面的文字。这种方式略嫌麻烦，你可以用更加简化的方式------个人比较推荐：

#+BEGIN_EXAMPLE
    这里同样是一个 `链接<http://blog.useasp.net>`_，不需要特别设置。
#+END_EXAMPLE

TIPS：
我们会发现，两个处理连接的时候，都需要在链接文字前面要空格与前面进行分割，这个在英文当中比较好处理，因为单个词之间有空格，而在中文中，字之间没有空格，如果加入空格，在显示时会有空格，影响观感，为此，如果在中文中使用，需要考虑好。

到此为止，reStructuredText这个[[http://blog.useasp.net/tags/标记语言][标记语言]]的基本用法已经展现完毕，进入实战吧，骚年！

 

参考文献：

1.
[[http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html][reStructuredText
Markup Specification]] (本文有些例子是来源于此页面)

2.
在线reStructuredText编辑器，[[http://rst.ninjs.org/][编辑器1]]，[[https://www.notex.ch/][编辑器2]]

** [[http://blog.csdn.net/zd0303/article/details/7775657][PDF文档的矢量图提取详解]]

标签：
[[http://www.csdn.net/tag/%e6%96%87%e6%a1%a3][文档]][[http://www.csdn.net/tag/postscript][postscript]][[http://www.csdn.net/tag/%e8%af%ad%e8%a8%80][语言]][[http://www.csdn.net/tag/adobe][adobe]][[http://www.csdn.net/tag/%e5%9b%be%e5%bd%a2][图形]][[http://www.csdn.net/tag/google][google]]

2012-07-23 15:34 7180人阅读 [[#comments][评论]](2)
[[javascript:void(0);][收藏]] [[#report][举报]]

[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

计算机/（12）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/zd0303/article/category/855208][作者同类文章]]/X/

在做软件的时候，经常需要用到一些LOGO图片。如何从素材文档中提取出高分辨率、背景透明的LOGO是我一直关注的问题。对于素材文档是JPG、BMP等点阵格式的图片，那没有办法，只能老老实实地抠出来。不过很多LOGO图片，一般是PDF格式或EPS格式的文档的。假如这些文档中的LOGO是以矢量图的形式存在的话，就可以从这些文档中提取出任意分辨率的LOGO了。本文以ST的LOGO为例，说明提取的过程。

 

*1. PDF文档里面的矢量图*

     
PDF文件很常用，很早就知道，PDF里面的文字一般是用矢量的方式保存的。直到最近，才发现原来PDF除了能贴点阵图之外，还可以存矢量图（比较孤陋寡闻，呵呵）。举例说明PDF里面的矢量图。下图是ST公司的某芯片手册PDF文档里面的LOGO放大到1200%的效果，依然平滑，没有锯齿。很明显，这个LOGO就是矢量图。

 [[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/ST_LOGO.JPG]]

 

*2. EPS文档*

     
以前没有怎么接触过EPS文档。前一阵提取一个LOGO，同时有PDF和EPS两种格式，但是EPS格式的文档用Photoshop却死活打不开。于是没有管它。后来google了一下，大致了解了一下EPS文档格式：

 

      eps 文件是封装的PostScript（Encapsulated
PostScript）格式。PostScript语言是Adobe
公司设计用于向任何支持PostScript语言的打印机打印文件的页面描述语言。除了它是被优化用于纸张上打印文字和图像之外，它像Basjc
语言、C语言或任何其它编程语言一样。当你在
PostScript打印机上工作并告诉文字处理器（或任何其它的应用程序）打印页面时，计算机就会用PostScript语言编写一个程序描述该页面，并将这个程序传送给打印机。打印机实际上其中装有一台功能齐全的计算机和PostScript
语言解释器执行这个程序，将图形画在内存中的虚拟纸张上，然后将其打印到纸上。

      
直到今天才无意中发现，原来PDF文档可以导出为EPS格式，然后用Photoshop打开这个EPS文件，就可以获得任意分辨率的图片。下面介绍这个提取过程。

 

*3. 提取过程详解*

     
首先要说一下用到的辅助工具：PDF编辑器。因为一般PDF是以页面的形式存在的，如果直接导出到EPS文件，那么在用Photoshop打开EPS文件的时候，由于使用的分辨率很高，会占用大量内存。因此，需要用PDF编辑器把想要的LOGO复制出来，其余的“咔嚓”掉。我使用的PDF编辑器是Foxit
PDF Editor，下面以此为例说明。

 

      *第一步：在Foxit PDF
Editor中打开想要提取的PDF文件，选定矢量图，然后复制。*

 

[[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/1.JPG]]

 

      *第二步：在Foxit PDF
Editor中新建PDF文档，要注意文档页面尽量小，恰好装下这个图片就好了。这里选择宽80，高60。*

 

 [[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/2.JPG]]

      选择“粘贴”之后，图片就被复制到新建的PDF文档里面了。

 [[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/3.JPG]]

     
稍微发挥一下技巧，会发现其实复制的内容并不是全都有用的：Ctrl+A全选，将选择的内容移动到灰色区域，发现刚才把多余的白色背景也拷贝了进来。

 [[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/4.JPG]]

 

       单击白色背景区域将其选择，按DEL键删除，变成了这个样子：

[[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/5.JPG]]

 

      全选图形，将它放回文档的页面区域即可。最后保存该PDF文档。

 

      *第三步：由PDF导出EPS文档。*

      使用Acrobat 8
Professional打开刚才生成的PDF文档，选择“文件(F)”-->“导出(T)”-->“PostScript”-->“内嵌式PostScript”将其导出到EPS文件（至于什么版本的Acrobat有这个功能，我没有研究过，反正Acrobat
8 Professional可以）。

 

      *第四步：使用Photoshop将EPS矢量图打开。*

     
这是最后一步，也是体会收获喜悦的一步，因为在这里你可以设置图片为任意大的分辨率。

 [[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/6.JPG]]

 

     
点“确定”之后，得到的就是一个背景透明的高分辨率的图片了。补充一下，此时的图片已经是点阵图了，也就是说，如果你在这里放大，就会失真了。

[[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/7.JPG]]

 

     
好了，大功告成。这个时候，只需要保存好EPS文件，以后再用到这个图片的时候，用Photoshop打开它，便可以得到任意你想要的分辨率图片了。

** [[http://blog.163.com/brave_smile_heart/blog/static/1872381712012619113640957/][openocd 命令行烧写ARM裸机程序 problems and solutions  ]]

摘要：  以前是用RVDS 的IDE来烧写调试ARM程序的，不过RVDS虽然是集成化的调试工具调试起来方便，但是有的时候只知其一，不知其二，只知道按部就班的来点击按钮，忽略了一些本质性的东西。而且RVDS还有一个不好的地方是它只能在windows平台下运行，不支持Linux OS。为了便于学习Linux，使用Openocd会是个不错的选择，可以学习gnu 汇编，Makefile编写，工具链命令行使用。   如果这些命令搞熟悉了，你还可以利用Qt 来做个自己的图形化界面烧写调试工具。（不过这只是个壳子而已，精髓在于openocd ，所以如果有时间你还可以分析一下Openocd的源码，因为它是开源的，开源的东西就是好，它可以满足你的好奇心，虽然有些时候不是我们在玩代码而是代码在玩我们，(*^__^*) ）。好了，废话不多说了。现列出我碰到的一些问题以及其解决办法，与诸位共享。
目录：
1.前提条件
2.执行的命令
3.执行命令时会遇到的问题
详细： details
1.前提条件
前提是你安装好了openocd .  并且Openocd的配置文件也准备好。运行起。
2.命令搞起 ：
2.1 运行ｏｐｅｎｏｃｄ．ｃｆｇ配置文件．　　　
首先我修改了samsung_s3c6410.cfg文件
在samsung_s3c6410.cfg中添加了如下语句
set _NANDNAME $_CHIPNAME.nand
nand device $_NANDNAME s3c6410 $_TARGETNAME
#openocd -f jlink.cfg -f samsung_s3c6410.cfg
运行如下：　
openocd 命令行烧写ARM裸机程序   problems and solutions - Melchior - Melchiors Home
以为ｏｐｅｎｏｃｄ不支持ｓ３ｃ６４１０的ｎａｎｄ擦写功能。于是看了/board/mini6410.cfg中有段内容如下：　

targets
nand device $_CHIPNAME.flash s3c6400 $_CHIPNAME.cpu
明明是６４１０，为什么要写成6400呢 ，不管了 ，于是试着修改samsung_s3c6410.cfg文件为
set _NANDNAME $_CHIPNAME.nand
nand device $_NANDNAME s3c6400 $_TARGETNAME

结果就ok 了  。
2.2 上面一步就完成jlink识别ARM的工作了。而且建立了telnet 服务器端口号 。现在我们要通过telnet与之建立通信 ，好能来使用openocd
#telnet localhost 4444(telnet端口号设置为4444)
openocd 命令行烧写ARM裸机程序   problems and solutions - Melchior - Melchiors Home
> halt
target state: halted
target halted in ARM state due to debug-request, current mode: Supervisor
cpsr: 0x000001d3 pc: 0x00000030
> nand probe 0
NAND flash device 'K9GAG08 2GB NAND 3.3V x8 MLC 2b/cell (Samsung)' found
> nand erase 0 0 0x100000（注：这个值应该是板子nand flash块的整数倍，0x100000为1M空间，足矣）

s3c2440_read_block_data: reading data: 0x8b94260, 0xbfe53d7a, 6
erased blocks 0 to 1 on NAND flash device #0 'K9GAG08 2GB NAND 3.3V x8 MLC 2b/cell'
> nand write 0 led.bin 0
couldn't open led.bin
failed to open 'led.bin' for read access
in procedure 'nand'

solution: 无法读取led.bin，那我们就改为绝对路径来试试  ：　
> nand write 0 /home/melchior/arm-work/1th_led/led.bin 0
> reset
JTAG tap: s3c6410.etb tap/device found: 0x2b900f0f (mfg: 0x787, part: 0xb900, ver: 0x2)
JTAG tap: s3c6410.cpu tap/device found: 0x07b76f0f (mfg: 0x787, part: 0x7b76, ver: 0x0)
found ARM1176

这样就ｏｋ了，ＡＲＭ板子上的ｌｅｄ就亮起来了　。　　

** [[http://forum.ubuntu.org.cn/viewtopic.php?f=97&t=327501][Linux系统下去烧录单片机]]

怎样在Linux系统下去烧录单片机51,avr,pic,fpga等实现实时控制子系统


｛编辑器｝：
首先介绍一下编辑器，emacs,vi,geany,等通用编辑器，（本人用终端的nano编辑器），把源代码编辑好之后进入以下环节。
二进制和hex编辑器有 beav, bless, bvi,lfhex等是不错的bin和hex文件的编辑器。
｛编译器｝:
其次是用软件把源代码编译成微控制器可以识别的代码，这里必须用的就是sdcc编译器(Small Device C Compiler)和gcc,gcc-avr，gcc-m68x,等。
＊SDCC 是小型器件c编译器，集成和优化的ANSI- C编译器目标是可以对英特尔8051，maxium,80DS390，Zilog公司的Z80和摩托罗拉68HC08微控制器。工作是支持 Microchip的PIC16和PIC18系列的进展。SDCC是自由开放源码软件，在GNU通用公共许可证（GPL）发布。
编程的语言以c和汇编为主。
＊gcc就太熟悉了。


还有一些专门针对固定器件的编译器：
01. mcu8051 ide, ASEM51(汇编），UISP, as31, dis51,等是专门针对51系列单片机的编译软件；
02. avra,avarice,arduino ide 等是专业针对avr系列进行编译的软件；
03, pikdev, piklab,gputil(兼容MPASM）等软件是专业针对microchip公司的pic和dspic系列的芯片进行编译和反编译的软件。
04. a56, crasm, biuntils-m68hc1x等是专业针对motorola, freescale 的 编译软件。
05，z80asm , z80dasm是专业针对zilog的 z80器件进行编译的软件。
等等... ... 很有很多

｛烧录软件｝和｛jtag在线调试｝


把编译的代码可以直接烧录到芯片中，这个是开发的必经之路。必须确定烧录硬件的可行性和正确性等，然后进行烧录。


01， 51系列的ASEM51支持的最多，http://plit.de/asem-51/derivat.htm， 几乎支持所有厂家的8051各个型号芯片。用BOOT-51写入到eeprom.
这个软件也是教程最完善的一个。
02.MCU 8051 这个IDE包含模拟仿真器，源代码编辑器，汇编器，硬件编程器和许多其他工具。是工具最全的51开发环境。
http://mcu8051ide.sourceforge.net/
03.s51dude,是一个专业的，基于终端的针对AT89S8252，AT89s53的isp烧录软件，usbtiny.
http://gd.tuwien.ac.at/opsys/linux/debi ... s/s51dude/
04.uisp, 是一个专业的，基于终端的针对AT89S518252，AT89s52的isp烧录软件,
http://www.nongnu.org/uisp/
05,usbprog,是一个针对usb转rs 232 的一个烧录软件，主要应用到avr 和 arm的固件烧录,（有一个固定的硬件）。
http://www2.embedded-projects.net/index.php?page_id=165
06，arduino是一个有专业电路板（arduino电路板）的avr 的集成开发环境（有一个固定硬件）。
http://www.arduino.cc/
07，avrp是一个针对flash和eeprom的烧录软件，应用到avr 8位系列的单片机和 at89系列的单片机。
http://www.colargol.tihlde.hist.no/~jonah/el/avrp.html
08，avrprog是一个针对atmel公司的avr系列的isp烧录软件，基于通过pc的并口转串口器件的烧录。
http://sourceforge.net/projects/avrprog/
09，avrdude是一个针对avr的isp烧录软件，针对rom和eeprom,基于终端操作。
http://www.nongnu.org/avrdude/
10，gdb avr, 是一个源代码调试软件，基于avr.
http://packages.debian.org/search?keywords=gdb-avr
11. picp,是一个比MPlab要快的软件，支持PICSTAR，Warp-13 or JuPic等编程器。
http://pp06.sourceforge.net/picp.html
12，pikdev是一个集成开发环境，同时支持并口，串口和usb全系列编程器进行烧录pic和dspic全系列的芯片。（piklab是基于pikdev开发的）。
http://pikdev.free.fr/


13，ARM和FPGA等一些支持jtag的芯片可以直接用openOCD, openwince-jtag, urjtag进行调试。
http://openocd.berlios.de/web/
http://urjtag.org/
14，TI系列的就可以用TI CCS 5.0.2 进行开发， 详细可见:TI CCS 5.0.1 支持linux
下载地址:http://processors.wiki.ti.com/index.php/Category:Code_Composer_Studio_v5


｛仿真软件和仿真器｝：同时可以用相关的专业软件进行仿真。
比如emu8051可以仿真51系列，gnusim8085是intel 8085的ide软件，simulavr，avarice可以仿真avr系列，gpsim,simulpic,nitpic等针对microchip公司的pic和dspic系列， softgen,是专业针对arm和dsp等进行嵌入仿真的软件，spim是mips R2000/R3000系列的仿真，coldfire是freescalecoldfire 5206仿真器， freeHDL是VHDL 在linux 环境下的仿真软件，verilator是一个verilog的仿真软件，sdcc-ucsim是一个MCS51 family, HC08 and Z80通用的仿真软件，
｛基础电路设计｝
qucs是一个不错的基础电路设计和仿真软件。
kicad是一个支持3d仿真的pcb设计软件，　包括原理图和元件库等。也可以选择eagle, geda, pcb等开源pcb软件。


总结：


到此，相信电子爱好者，同时也是Linux和开源铁杆用户们，可以尽情的去开发

** [[http://www.uzzf.com/soft/63096.html][电脑录音软件]]


Wondershare Streaming Audio Recorder 是一款易于使用的程序，可让您录制某网站上播放的歌曲或任何网页的背景音乐。本程序通过使用虚拟声卡，能够检测任何流音频。它可以记录在线音乐商店和在线广播电台的音频信号。即使是受到 DRM 保护的音乐文件，它也能轻松捕捉到。

您可以编辑和自定义录制好的文件，也可调整采样率和伴音通道等设置。音频文件可录制成高保真 MP3、WMA 和 WAV 等其他常见音频格式。此外，您还可在便携式设备上保存文件，如 iPod、iPhone 和 PSP 等。

借助 Wondershare Streaming Audio Recorder，您可随心所欲地录制音乐。

** http://www.dll-files.com/

** [[http://blog.csdn.net/yuzhongchun/article/details/11537829][Arduino的数据类型]]


2013-09-10 20:27 3611人阅读 [[#comments][评论]](0)
[[javascript:void(0);][收藏]] [[#report][举报]]

[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

Arduino/（2）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/yuzhongchun/article/category/1616091][作者同类文章]]/X/

| 数据类型        | 字节   | 范围                           | 备注                                          |
| void            |        |                                | 只用作函数声明，表示没有返回值                |
| boolean         |        | true,false                     | 每一个布尔变量占一个字节的内存                |
| char            | 1      | -128~127                       |                                               |
| unsigned char   | 1      | 0~255                          |                                               |
| byte            | 1      | 0~255                          |                                               |
| int             | 2      | -32768~32767                   | 在Arduino Due上是4个字节                      |
| unsigned int    | 2      | 0~65535                        |                                               |
| word            | 2      | 0~65535                        |                                               |
| long            | 4      | -2147483648~2147483647         |                                               |
| unsigned long   | 4      | 0~2\^32-1                      |                                               |
| short           | 2      | -32768~32767                   |                                               |
| float           | 4      | -3.4028235E+38~3.4028235E+38   | 只有6~7位小数精度                             |
| double          | 4      |                                | 在Arduino Due上有8个字节，其余的跟float一样   |
| string          |        |                                | 相当于char类型的数组                          |
| String          |        |                                | object                                        |
| array           |        |                                | 数组                                          |

参考：[[http://arduino.cc/en/Reference/HomePage][http://arduino.cc/en/Reference/HomePage]]

** [[http://blog.csdn.net/huang_xw/article/details/8760403][【C++11】新特性------auto的使用]]

C++11中引入的auto主要有两种用途：自动类型推断和返回值占位。auto在C++98中的标识临时变量的语义，由于使用极少且多余，在C++11中已被删除。前后两个标准的auto，完全是两个概念。

*** 1. 自动类型推断

   
auto自动类型推断，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推断，可以大大简化我们的编程工作。下面是一些使用auto的例子。

#+BEGIN_EXAMPLE
    #include <vector>
    #include <map>

    using namespace std;

    int main(int argc, char *argv[], char *env[])
    {
    //  auto a;                 // 错误，没有初始化表达式，无法推断出a的类型
    //  auto int a = 10;        // 错误，auto临时变量的语义在C++11中已不存在, 这是旧标准的用法。

        // 1. 自动帮助推导类型
        auto a = 10;
        auto c = 'A';
        auto s("hello");

        // 2. 类型冗长
        map<int, map<int,int> > map_;
        map<int, map<int,int>>::const_iterator itr1 = map_.begin();
        const auto itr2 = map_.begin();
        auto ptr = []()
        {
            std::cout << "hello world" << std::endl;
        };

        return 0;
    };

    // 3. 使用模板技术时，如果某个变量的类型依赖于模板参数，
    // 不使用auto将很难确定变量的类型（使用auto后，将由编译器自动进行确定）。
    template <class T, class U>
    void Multiply(T t, U u)
    {
        auto v = t * u;
    }
#+END_EXAMPLE

*** 2. 返回值占位

#+BEGIN_EXAMPLE
    template <typename T1, typename T2>
    auto compose(T1 t1, T2 t2) -> decltype(t1 + t2)
    {
       return t1+t2;
    }
    auto v = compose(2, 3.14); // v's type is double
#+END_EXAMPLE

*** 3.使用注意事项

①我们可以使用valatile，pointer（*），reference（&），rvalue
reference（&&） 来修饰auto

#+BEGIN_EXAMPLE
    auto k = 5;
    auto* pK = new auto(k);
    auto** ppK = new auto(&k);
    const auto n = 6;
#+END_EXAMPLE

②用auto声明的变量必须初始化

#+BEGIN_EXAMPLE
    auto m; // m should be intialized
#+END_EXAMPLE

③auto不能与其他类型组合连用

#+BEGIN_EXAMPLE
    auto int p; // 这是旧auto的做法。
#+END_EXAMPLE

④函数和模板参数不能被声明为auto

#+BEGIN_EXAMPLE
    void MyFunction(auto parameter){} // no auto as method argument

    template<auto T> // utter nonsense - not allowed
    void Fun(T t){}
#+END_EXAMPLE

⑤定义在堆上的变量，使用了auto的表达式必须被初始化

#+BEGIN_EXAMPLE
    int* p = new auto(0); //fine
    int* pp = new auto(); // should be initialized

    auto x = new auto(); // Hmmm ... no intializer

    auto* y = new auto(9); // Fine. Here y is a int*
    auto z = new auto(9); //Fine. Here z is a int* (It is not just an int)
#+END_EXAMPLE

⑥以为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid

#+BEGIN_EXAMPLE
    int value = 123;
    auto x2 = (auto)value; // no casting using auto

    auto x3 = static_cast<auto>(value); // same as above
#+END_EXAMPLE

⑦定义在一个auto序列的变量必须始终推导成同一类型

#+BEGIN_EXAMPLE
    auto x1 = 5, x2 = 5.0, x3='r';  // This is too much....we cannot combine like this
#+END_EXAMPLE

⑧auto不能自动推导成CV-qualifiers（constant & volatile
qualifiers），除非被声明为引用类型

#+BEGIN_EXAMPLE
    const int i = 99;
    auto j = i;       // j is int, rather than const int
    j = 100           // Fine. As j is not constant

    // Now let us try to have reference
    auto& k = i;      // Now k is const int&
    k = 100;          // Error. k is constant

    // Similarly with volatile qualifer
#+END_EXAMPLE

⑨auto会退化成指向数组的指针，除非被声明为引用

#+BEGIN_EXAMPLE
    int a[9];
    auto j = a;
    cout<<typeid(j).name()<<endl; // This will print int*

    auto& k = a;
    cout<<typeid(k).name()<<endl; // This will print int [9]
#+END_EXAMPLE

** [[http://www.cnblogs.com/pmars/archive/2012/10/16/2725511.html][c和c++中NULL和0的区别]]

1,什么是空指针常量（null pointer constant）?

[6.3.2.3-3] An integer constant expression with the value 0, or such an
expression cast to type void *, is called a null pointer constant.

这里告诉我们：0、0L、'\0'、3 - 3、0 * 17 （它们都是“integer constant
expression”）以及 (void*)0 （tyc：
我觉得(void*)0应该算是一个空指针吧，更恰当一点）等都是空指针常量（注意
(char*) 0
不叫空指针常量，只是一个空指针值）。至于系统选取哪种形式作为空指针常量使用，则是实现相关的。一般的
C 系统选择 (void*)0 或者 0 的居多（也有个别的选择 0L）；至于 C++
系统，由于存在严格的类型转化的要求，void* 不能象 C
中那样自由转换为其它指针类型，所以通常选 0 作为空指针常量（tyc:
C++标准推荐），而不选择 (void*)0。

 

2,什么是空指针（null pointer）?

[6.3.2.3-3] If a null pointer constant is converted to a pointer type,
the resulting pointer, called a null pointer, is guaranteed to compare
unequal to a pointer to any object or function.

因此，如果 p 是一个指针变量，则 p = 0;、p = 0L;、p = '\0';、p = 3 -
3;、p = 0 * 17; 中的任何一种赋值操作之后（对于 C 来说还可以是 p =
(void*)0;）， p
都成为一个空指针，由系统保证空指针不指向任何实际的对象或者函数。反过来说，任何对象或者函数的地址都不可能是空指针。（tyc:
比如这里的(void*)0就是一个空指针。把它理解为null pointer还是null pointer
constant会有微秒的不同，当然也不是紧要了）

 

3,什么是 NULL？

[6.3.2.3-Footnote] The macro NULL is defined in <stddef.h> (and other
headers) as a null pointer constant

即 NULL
是一个标准规定的宏定义，用来表示空指针常量。因此，除了上面的各种赋值方式之外，还可以用
p = NULL; 来使 p 成为一个空指针。（tyc：很多系统中的实现：#define NULL
(void*)0，与这里的“a null pointer constant”并不是完全一致的）

 

4,空指针（null pointer）指向了内存的什么地方（空指针的内部实现）？

标准并没有对空指针指向内存中的什么地方这一个问题作出规定，也就是说用哪个具体的地址值（0x0
地址还是某一特定地址）表示空指针取决于系统的实现。我们常见的空指针一般指向
0 地址，即空指针的内部用全 0 来表示（zero null
pointer，零空指针）；也有一些系统用一些特殊的地址值或者特殊的方式表示空指针（nonzero
null pointer，非零空指针），具体请参见C FAQ。

 

幸运的是，在实际编程中不需要了解在我们的系统上空指针到底是一个 zero null
pointer 还是 nonzero null
pointer，我们只需要了解一个指针是否是空指针就可以了------编译器会自动实现其中的转换，为我们屏蔽其中的实现细节。注意：不要把空指针的内部表示等同于整数
0 的对象表示------如上所述，有时它们是不同的。

 

5,如何判断一个指针是否是一个空指针？

这可以通过与空指针常量或者其它的空指针的比较来实现（注意与空指针的内部表示无关）。例如，假设
p 是一个指针变量，q 是一个同类型的空指针，要检查 p
是否是一个空指针，可以采用下列任意形式之一------它们在实现的功能上都是等价的，所不同的只是风格的差别。

 

指针变量 p 是空指针的判断：

if ( p == 0 )

if ( p == '\0' )

if ( p == 3 - 3 )

if ( p == NULL )  /* 使用 NULL 必须包含相应的标准库的头文件 */

if ( NULL == p )

if ( !p )

if ( p == q )

...

指针变量 p 不是空指针的判断：

if ( p != 0 )

if ( p != '\0' )

if ( p != 3 - 3 )

if ( p != NULL )  /* 使用 NULL 必须包含相应的标准库的头文件 */

if ( NULL != p )

if ( p )

if ( p != q )

...

6,可以用 memset 函数来得到一个空指针吗？

这个问题等同于：如果 p 是一个指针变量，那么

memset( &p, 0, sizeof(p) ); 和 p = 0;

是等价的吗？

答案是否定的，虽然在大多数系统上是等价的，但是因为有的系统存在着“非零空指针”
（nonzero null
pointer），所以这时两者不等价。由于这个原因，要注意当想将指针设置为空指针的时候不应该使用
memset，而应该用空指针常量或空指针对指针变量赋值或者初始化的方法。

 

7,可以定义自己的 NULL 的实现吗？兼答"NULL 的值可以是 1、2、3
等值吗？"类似问题

[7.1.3-2] If the program declares or defines an identifier in a context
in which it is reserved (other than as allowed by 7.1.4), or defines a
reserved identifier as a macro name, the behavior is undefined.

NULL 是标准库中的一个符合上述条件的 reserved identifier
（保留标识符）。所以，如果包含了相应的标准头文件而引入了 NULL
的话，则再在程序中重新定义 NULL
为不同的内容是非法的，其行为是未定义的。也就是说，如果是符合标准的程序，其
NULL 的值只能是 0，不可能是除 0 之外的其它值，比如 1、2、3 等。

 

8,malloc 函数在分配内存失败时返回 0 还是 NULL？

malloc 函数是标准 C
规定的库函数。在标准中明确规定了在其内存分配失败时返回的是一个 “null
pointer”（空指针）：

[7.20.3-1] If the space cannot be allocated, a null pointer is returned.

对于空指针值，一般的文档（比如 man）中倾向于用 NULL 表示，而没有直接说成
0。但是我们应该清楚：对于指针类型来说，返回 NULL 和 返回 0
是完全等价的，因为 NULL 和 0 都表示 “null
pointer”（空指针）。（tyc：一般系统中手册中都返回NULL，那我们就用NULL吧）

另外，附C FAQ上关于null pointer的解释：C FAQ：null pointer

 

参考：

[[http://topic.csdn.net/u/20121009/09/947a37cc-cb05-4f42-b889-a26e7253325e.html][NULL与0是否有区别？？（CSDN）]]

[[http://wenku.baidu.com/view/250567c08bd63186bcebbcc0.html][c和c++中NULL和0的区别（文库）]]

** [[http://bbs.21ic.com/icview-292853-1-1.html][卡尔曼滤波器]]

一片绿油油的草地上有一条曲折的小径，通向一棵大树。一个要求被提出：从起点沿着小径走到树下。

“很简单。” A说，于是他丝毫不差地沿着小径走到了树下。

现在，难度被增加了：蒙上眼。

“也不难，我当过特种兵。” B说，于是他歪歪扭扭地走到了树 ………. 旁。“唉，好久不练，生疏了。”

“看我的，我有 DIY 的 GPS！” C说，于是他像个醉汉似地走到了树………. 旁。“唉，这个 GPS 软件没做好，漂移太大。”

“我来试试。” 旁边一人拿过 GPS,  蒙上眼，居然沿着小径走到了树下。

“这么厉害！你是什么人?”

“卡尔曼 ! ”

“卡尔曼？！你是卡尔曼？”众人大吃一惊。

“我是说这个 GPS 卡而慢。”

** http://www.emacswiki.org/emacs/BasicNarrowing

** [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Narrowing.html][Narrowing]]

/Narrowing/ means focusing in on some portion of the buffer, making the
rest temporarily inaccessible. The portion which you can still get to is
called the /accessible portion/. Canceling the narrowing, which makes
the entire buffer once again accessible, is called /widening/. The
bounds of narrowing in effect in a buffer are called the buffer's
/restriction/.

Narrowing can make it easier to concentrate on a single subroutine or
paragraph by eliminating clutter. It can also be used to limit the range
of operation of a replace command or repeating keyboard macro.

-  C-x n n :: Narrow down to between point and mark
   (=narrow-to-region=).

-  C-x n w :: Widen to make the entire buffer accessible again
   (=widen=).

-  C-x n p :: Narrow down to the current page (=narrow-to-page=).

-  C-x n d :: Narrow down to the current defun (=narrow-to-defun=).

When you have narrowed down to a part of the buffer, that part appears
to be all there is. You can't see the rest, you can't move into it
(motion commands won't go outside the accessible part), you can't change
it in any way. However, it is not gone, and if you save the file all the
inaccessible text will be saved. The word ‘Narrow' appears in the mode
line whenever narrowing is in effect.

The primary narrowing command is C-x n n (=narrow-to-region=). It sets
the current buffer's restrictions so that the text in the current region
remains accessible, but all text before the region or after the region
is inaccessible. Point and mark do not change.

Alternatively, use C-x n p (=narrow-to-page=) to narrow down to the
current page. See [[Pages.html#Pages][Pages]], for the definition of a
page. C-x n d (=narrow-to-defun=) narrows down to the defun containing
point (see [[Defuns.html#Defuns][Defuns]]).

The way to cancel narrowing is to widen with C-x n w (=widen=). This
makes all text in the buffer accessible again.

You can get information on what part of the buffer you are narrowed down
to using the C-x = command. See
[[Position-Info.html#Position-Info][Position Info]].

Because narrowing can easily confuse users who do not understand it,
=narrow-to-region= is normally a disabled command. Attempting to use
this command asks for confirmation and gives you the option of enabling
it; if you enable the command, confirmation will no longer be required
for it. See [[Disabling.html#Disabling][Disabling]].

** [[http://blog.csdn.net/augusdi/article/details/11773943][C++11中的匿名函数(lambda函数,lambda表达式)]]


[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

C++ AMP/（74）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/Augusdi/article/category/686039][作者同类文章]]/X/

这篇文章是根据维基百科整理来的,原文请看:[[http://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B][http://en.wikipedia.org/wiki/Anonymous\_function#C.2B.2B]]

　　C++11提供了对匿名函数的支持,称为Lambda函数(也叫Lambda表达式).
Lambda表达式具体形式如下:

　　　　[capture](parameters)->return-type{body}

　　如果没有参数,空的圆括号()可以省略.返回值也可以省略,如果函数体只由一条return语句组成或返回类型为void的话.形如:

　　 　 [capture](parameters){body}

　　下面举了几个Lambda函数的例子:  　　　　

#+BEGIN_EXAMPLE
    [](int x, int y) { return x + y; } // 隐式返回类型
    [](int& x) { ++x; }   // 没有return语句 -> lambda 函数的返回类型是'void'
    []() { ++global_x; }  // 没有参数,仅访问某个全局变量
    []{ ++global_x; }     // 与上一个相同,省略了()
#+END_EXAMPLE

　　可以像下面这样显示指定返回类型:  

#+BEGIN_EXAMPLE
    [](int x, int y) -> int { int z = x + y; return z; }
#+END_EXAMPLE

　　在这个例子中创建了一个临时变量z来存储中间值.
和普通函数一样,这个中间值不会保存到下次调用.
什么也不返回的Lambda函数可以省略返回类型, 而不需要使用 -> void 形式.
　　Lambda函数可以引用在它之外声明的变量. 这些变量的集合叫做一个闭包.
闭包被定义在Lambda表达式声明中的方括号[]内.
这个机制允许这些变量被按值或按引用捕获.下面这些例子就是:  

#+BEGIN_EXAMPLE
    []        //未定义变量.试图在Lambda内使用任何外部变量都是错误的.
    [x, &y]   //x 按值捕获, y 按引用捕获.
    [&]       //用到的任何外部变量都隐式按引用捕获
    [=]       //用到的任何外部变量都隐式按值捕获
    [&, x]    //x显式地按值捕获. 其它变量按引用捕获
    [=, &z]   //z按引用捕获. 其它变量按值捕获
#+END_EXAMPLE

　　接下来的两个例子演示了Lambda表达式的用法.  

[[][[[http://common.cnblogs.com/images/copycode.gif]]]]

#+BEGIN_EXAMPLE
    std::vector<int> some_list;
    int total = 0;
    for (int i=0;i<5;++i) some_list.push_back(i);
    std::for_each(begin(some_list), end(some_list), [&total](int x)
    {
        total += x;
    });
#+END_EXAMPLE

[[][[[http://common.cnblogs.com/images/copycode.gif]]]]

　　此例计算list中所有元素的总和. 变量total被存为lambda函数闭包的一部分.
因为它是栈变量(局部变量)total的引用,所以可以改变它的值.  

[[][[[http://common.cnblogs.com/images/copycode.gif]]]]

#+BEGIN_EXAMPLE
    std::vector<int> some_list;
      int total = 0;
      int value = 5;
      std::for_each(begin(some_list), end(some_list), [&, value, this](int x)
      {
        total += x * value * this->some_func();
      });
#+END_EXAMPLE

[[][[[http://common.cnblogs.com/images/copycode.gif]]]]

　　此例中total会存为引用, value则会存一份值拷贝. 对this的捕获比较特殊,
它只能按值捕获.
this只有当包含它的最靠近它的函数不是静态成员函数时才能被捕获.对protect和priviate成员来说,
这个lambda函数与创建它的成员函数有相同的访问控制.
如果this被捕获了,不管是显式还隐式的,那么它的类的作用域对Lambda函数就是可见的.
访问this的成员不必使用this->语法,可以直接访问.
　　不同编译器的具体实现可以有所不同,但期望的结果是:按引用捕获的任何变量,lambda函数实际存储的应该是这些变量在创建这个lambda函数的函数的栈指针,而不是lambda函数本身栈变量的引用.
不管怎样, 因为大数lambda函数都很小且在局部作用中,
与候选的内联函数很类似, 所以按引用捕获的那些变量不需要额外的存储空间.
　　如果一个闭包含有局部变量的引用,在超出创建它的作用域之外的地方被使用的话,这种行为是未定义的!
　　lambda函数是一个依赖于实现的函数对象类型,这个类型的名字只有编译器知道.
如果用户想把lambda函数做为一个参数来传递,
那么形参的类型必须是模板类型或者必须能创建一个std::function类似的对象去捕获lambda函数.使用
auto关键字可以帮助存储lambda函数,  

#+BEGIN_EXAMPLE
    auto my_lambda_func = [&](int x) { /*...*/ };
    auto my_onheap_lambda_func = new auto([=](int x) { /*...*/ });
#+END_EXAMPLE

　　这里有一个例子,
把匿名函数存储在变量,数组或vector中,并把它们当做命名参数来传递 

[[][[[http://common.cnblogs.com/images/copycode.gif]]]]

#+BEGIN_EXAMPLE
    #include<functional>
    #include<vector>
    #include<iostream>
    double eval(std::function<double(double)> f, double x = 2.0){return f(x);}
    int main()
    {
         std::function<double(double)> f0    = [](double x){return 1;};
         auto                          f1    = [](double x){return x;};
         decltype(f0)                  fa[3] = {f0,f1,[](double x){return x*x;}};
         std::vector<decltype(f0)>     fv    = {f0,f1};
         fv.push_back                  ([](double x){return x*x;});
         for(int i=0;i<fv.size();i++)  std::cout << fv[i](2.0) << "\n";
         for(int i=0;i<3;i++)          std::cout << fa[i](2.0) << "\n";
         for(auto &f : fv)             std::cout << f(2.0) << "\n";
         for(auto &f : fa)             std::cout << f(2.0) << "\n";
         std::cout << eval(f0) << "\n";
         std::cout << eval(f1) << "\n";
         return 0;
    }
#+END_EXAMPLE

[[][[[http://common.cnblogs.com/images/copycode.gif]]]]

　　一个没有指定任何捕获的lambda函数,可以显式转换成一个具有相同声明形式函数指针.所以,像下面这样做是合法的:
 

#+BEGIN_EXAMPLE
    auto a_lambda_func = [](int x) { /*...*/ };
    void(*func_ptr)(int) = a_lambda_func;
    func_ptr(4); //calls the lambda.
#+END_EXAMPLE

** http://www.cplusplus.com/reference/sstream/stringstream/

** http://www.cplusplus.com/reference/cassert/assert/

** [[http://blog.csdn.net/sndaxdrs/article/details/6175701][shared\_ptr]]

标签：
[[http://www.csdn.net/tag/iterator][iterator]][[http://www.csdn.net/tag/%e5%ad%98%e5%82%a8][存储]][[http://www.csdn.net/tag/vector][vector]][[http://www.csdn.net/tag/string][string]][[http://www.csdn.net/tag/class][class]][[http://www.csdn.net/tag/%e6%96%87%e6%a1%a3][文档]]

2011-02-09 16:22 29225人阅读 [[#comments][评论]](7)
[[javascript:void(0);][收藏]] [[#report][举报]]

 

shared\_ptr是一个最像指针的"智能指针"，是boost.smart\_ptr库中最有价值、最重要的组成部分，也是最有用的，Boost库的许多组件--甚至还包括其他一些领域的智能指针都使用了shared\_ptr。抱歉，我实在想不出什么更恰当的词汇来形容它在软件开发中的重要性。再强调一遍，shared\_ptr非常有价值、非常重要、非常有用。

 

shared\_ptr与scoped\_ptr一样包装了new操作符在堆上分配的动态对象，但它实现的是引用计数型的智能指针
，可以被自由地拷贝和赋值，在任意的地方共享它，当没有代码使用（引用计数为0）它时才删除被包装的动态分配的对象。shared\_ptr也可以安全地放到标准容器中，并弥补了auto\_ptr因为转移语义而不能把指针作为STL容器元素的缺陷。

在C++历史上曾经出现过无数的引用计数型智能指针实现，但没有一个比得上boost::shared\_ptr，在过去、现在和将来，它都是最好的。

*1.  shared\_ptr的线程安全性*

 

   shared\_ptr 本身不是 100%
线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是，因为
shared\_ptr 有两个数据成员，读写操作不能原子化。根据文档，shared\_ptr
的线程安全级别和内建类型、标准库容器、string 一样，即：

-  一个 shared\_ptr 实体可被多个线程同时读取；
-  两个的 shared\_ptr 实体可以被两个线程同时写入，“析构”算写操作；
-  如果要从多个线程读写同一个 shared\_ptr 对象，那么需要加锁。

 

*2.  shared\_ptr用法*

 

*示例一：*

**

shared\_ptr<int> sp(new int(10)); //一个指向整数的shared\_ptr
assert(sp.unique()); //现在shared\_ptr是指针的唯一持有者
shared\_ptr<int> sp2 = sp; //第二个shared\_ptr,拷贝构造函数 assert(sp ==
sp2 && sp.use\_count() == 2);
//两个shared\_ptr相等,指向同一个对象,引用计数为2 *sp2 = 100;
//使用解引用操作符修改被指对象 assert(*sp == 100);
//另一个shared\_ptr也同时被修改 sp.reset(); //停止shared\_ptr的使用
assert(!sp); //sp不再持有任何指针(空指针)

 

*示例二：*

class shared //一个拥有shared\_ptr的类 { private: shared\_ptr<int> p;
//shared\_ptr成员变量 public: shared(shared\_ptr<int> p\_):p(p\_){}
//构造函数初始化shared\_ptr void print()
//输出shared\_ptr的引用计数和指向的值 { cout << "count:" <<
p.use\_count() << "v =" <<*p << endl; } }; void
print\_func(shared\_ptr<int> p) //使用shared\_ptr作为函数参数 {
//同样输出shared\_ptr的引用计数和指向的值 cout << "count:" <<
p.use\_count() << " v=" <<*p << endl; } int main() { shared\_ptr<int>
p(new int(100)); shared s1(p), s2(p); //构造两个自定义类 s1.print();
s2.print(); *p = 20; //修改shared\_ptr所指的值 print\_func(p);
s1.print(); }

*3. 应用于标准容器*

**

**

**

有两种方式可以将shared\_ptr应用于标准容器（或者容器适配器等其他容器）。

一种用法是将容器作为shared\_ptr管理的对象，如shared\_ptr<list<T>
>，使容器可以被安全地共享，用法与普通shared\_ptr没有区别，我们不再讨论。

另一种用法是将shared\_ptr作为容器的元素，如vector<shared\_ptr<T>
>，因为shared\_ptr支持拷贝语义和比较操作，符合标准容器对元素的要求，所以可以实现在容器中安全地容纳元素的指针而不是拷贝。

标准容器不能容纳auto\_ptr，这是C++标准特别规定的（读者永远也不要有这种想法）。标准容器也不能容纳scoped\_ptr，因为scoped\_ptr不能拷贝和赋值。标准容器可以容纳原始指针，但这就丧失了容器的许多好处，因为标准容器无法自动管理类型为指针的元素，必须编写额外的大量代码来保证指针最终被正确删除，这通常很麻烦很难实现。

存储shared\_ptr的容器与存储原始指针的容器功能几乎一样，但shared\_ptr为程序员做了指针的管理工作，可以任意使用shared\_ptr而不用担心资源泄漏。

 

 

下面的代码示范了将shared\_ptr应用于标准容器的用法：

#include <boost/make\_shared.hpp> int main() { typedef
vector<shared\_ptr<int> > vs; //一个持有shared\_ptr的标准容器类型 vs
v(10); //声明一个拥有10个元素的容器，元素被初始化为空指针 int i = 0; for
(vs::iterator pos = v.begin(); pos != v.end(); ++pos) { (*pos) =
make\_shared<int>(++i); //使用工厂函数赋值 cout << *(*pos) << ", ";
//输出值 } cout << endl; shared\_ptr<int> p = v[9]; *p = 100; cout <<
*v[9] << endl; }

 

 

这段代码需要注意的是迭代器和operator[]的用法，因为容器内存储的是shared\_ptr，我们必须对迭代器pos使用一次解引用操作符*以获得shared\_ptr，然后再对shared\_ptr使用解引用操作符*才能操作真正的值。*(*pos)也可以直接写成**pos，但前者更清晰，后者很容易让人迷惑。vector的operator[]用法与迭代器类似，也需要使用*获取真正的值。

** [[https://linux.cn/article-4016-1.html][如何清理 Ubuntu 14.04 的最近打开文件历史列表]]
要从dash搜索删除历史记录，请遵循以下程序。

转到系统设置（System Settings）并打开安全与隐私（Security & Privacy）。


在文件与应用（Files and Applications）标签下，点击清除用户数据（Clear Usage Data）。


你也可以关闭“记录文件与应用使用（Record file and Application usage）
以阻止系统记录你当前使用的文件和应用。






** [[http://www.latexstudio.net/archives/328][LaTeX技巧703：minted包使用环境的搭建]]

2014-02-03
分类：[[http://www.latexstudio.net/archives/category/tex-design/tex-code-design][代码输出]]
阅读(463) 评论(2)

pymentize是用来做高亮显示非常好的库，minted恰恰使用这一语法高亮库来实现代码的高亮显示，其效果做得也非常不错。下面介绍其环境的搭建过程。

[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/OLUjl.png][[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/OLUjl.png]]]]

【*安装Python环境*】

首先，安装python，推荐版本2.7，因为python软件包的管理工具setuptools只支持到2.7版本，python环境安装完毕，在操作系统的path增加环境变量：C:\Python27\Scripts\;C:\Python27\。新版的python的目录结构稍有变化，用户根据自己的实际安装路径来配置环境变量。

【*安装软件包工具*】

python环境安装好以后，可以到[[https://pypi.python.org/pypi/setuptools][https://pypi.python.org/pypi/setuptools]]下载包管理工具，可以下载.py脚本，也可以下载exe安装文件，下面是.exe安装文件的安装过程：

[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/easy-install1.png][[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/easy-install1.png]]]]

【*安装pygmentize库*】

安装好setuptool以后，可以利用命令行工具来安装相关的软件和库，这时之前设置的环境变量就会发挥其作用了。安装过程如下图所示：

输入：easy\_install Pygments 即可！

[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/easy-install.png][[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/easy-install.png]]]]

*【安装验证】*

在命令行下使用pygmentize命令来测试安装是否正常。

【*代码测试*】

TeXlive新版已包含了minted宏包，若是您的系统没有安装此包，可以到[[http://code.google.com/p/minted/][http://code.google.com/p/minted/]]或者[[http://www.ctan.org/tex-archive/macros/latex/contrib/minted/][ctan]]下载安装。宏包安装完毕，可以用下面的代码来测试宏包是否可以正常使用。需要注意的是，运行的时候需要加一个参数即：-shell-escape
，如若是使用pdflatex编译，即：pdflatex -shell-escape  filename

测试代码如下：

TeX

\documentclass{article} \usepackage{minted} \begin{document}
\begin{minted}{c} int main() { printf("hello, world"); return 0; }
\end{minted} \end{document}

| 1    | \documentclass{article}   |
| 2    | \usepackage{minted}       |
| 3    | \begin{document}          |
| 4    | \begin{minted}{c}         |
| 5    | int main() {              |
| 6    | printf("hello, world");   |
| 7    | return 0;                 |
| 8    | }                         |
| 9    | \end{minted}              |
| 10   | \end{document}            |

效果图：

[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/minted.png][[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/minted.png]]]]

** [[http://blog.csdn.net/u013453604/article/details/45324121][用minted宏包在TeXWorks中插入代码高亮]]

标签：
[[http://www.csdn.net/tag/texlive][texlive]][[http://www.csdn.net/tag/texworks][texworks]][[http://www.csdn.net/tag/minted][minted]][[http://www.csdn.net/tag/Pygments][Pygments]][[http://www.csdn.net/tag/%e8%af%ad%e6%b3%95%e9%ab%98%e4%ba%ae][语法高亮]]

2015-04-28 00:43 219人阅读 [[#comments][评论]](0)
[[javascript:void(0);][收藏]] [[#report][举报]]

[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

存档/（10）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/u013453604/article/category/3149871][作者同类文章]]/X/

模式识别/（1）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/u013453604/article/category/2148725][作者同类文章]]/X/

版权声明：本文为博主原创文章，未经博主允许不得转载。

安装texlive时没有用自带的Texworks编辑器的请看这篇文章

（[[http://blog.csdn.net/gogdizzy/article/details/9136239][http://blog.csdn.net/gogdizzy/article/details/9136239]]）这是WinEdt编辑器下的操作。

一. minted宏包的使用

#+BEGIN_EXAMPLE
    \documentclass[CJK]{cctart}
    \usepackage{minted}
    \begin{document}
    \begin{minted}{c++}
    int main() {
        printf("hello, world");
        return 0;
    }
    \end{minted}
    \end{document}
#+END_EXAMPLE

效果如下
 [[http://img.blog.csdn.net/20150427235430332]]

二.使用过程遇到的报错

1. 安装texlive，选择自带的Texworks编辑器，最近的新版本都自带了minted宏包
2. 安装Python，在这里下载（[[https://www.python.org/downloads/][https://www.python.org/downloads/]]）
    并为Python设置好环境变量，这个自行百度，就是把
    D:\Python34\;D:\Python34\Scripts;加到系统环境变量path里面
3. 安装Pygments

   可以看我这个笔记，[[http://blog.csdn.net/u013453604/article/details/45319379][windows下用easy\_install安装Pygments]]
    完了之后运行上面给出的代码还得报错，提示说“minted Error: You must
   invoke LaTeX with the =-shell-escape= flag”这时得启用shell escape
4. 启用shell escape

   我是TeXWorks所以很简单，“编辑器”->”首选项”->”排版”在“处理工具”那一栏的右边点加号，新建一个XeLatex+shellescape的配置，可以参照列表里的XeLatex配置，“程序”填xelates.exe，加入三个参数synctexoption，−−shell−escape，
   fullname，点击确定保存。如图所示
    [[http://img.blog.csdn.net/20150428001226422]]
    然后编译的时候选择新建的这个工具，如图
    [[http://img.blog.csdn.net/20150428002055045]]
    如果你的是WinEdt编辑器，请参照这篇启用shell escape

   （[[http://blog.csdn.net/gogdizzy/article/details/9136239][http://blog.csdn.net/gogdizzy/article/details/9136239]]）

   也可以参考国外官网论坛的帖子[[http://tex.stackexchange.com/questions/99475/how-to-invoke-latex-with-the-shell-escape-flag-in-texmakerx][How
   to invoke latex with the -shell-escape flag in TeXMakerX?]]
5. 注意\begin{minted}{c++} 这句中的c是小写的
6. minted支持300中语言的高亮，Pygments语法高亮工具提供了不同的高亮风格，具体配置见[[http://get-software.net/macros/latex/contrib/minted/minted.pdf][minted参考文档]]

   还有博客[[http://havee.me/internet/2013-08/support-pygments-in-jekyll.html][Jekyll
   中的语法高亮：Pygments]]

二.其他语法高亮方案

1. listings
    listings 是专用于代码排版的
   LaTeX宏包，可对关键词、注释和字符串等使用不同的字体和颜色或颜色，也可以为代码添加边框、背景等风格。
    但是这种方法相对于minted来说稍显麻烦，语法高亮需要自己设置。
    下面给出一份用于排版 C 语言 HelloWorld 程序代码的完整的 LaTeX 文档：

#+BEGIN_EXAMPLE
    \documentclass{ article}
    \usepackage{ listings}
    \begin{ document}
    \begin{ lstlisting}[ language=C]
    int main(int argc, char ** argv)
    {
    printf("Hello world! \n");
    return 0;
    }
    \end{ lstlisting}
    \end{ document}
#+END_EXAMPLE

注意，要使用 listings 宏包提供的语法高亮，需要 xcolor 宏包支持。

** [[http://doc-snapshots.qt.io/4.8/assistant-manual.html][The One-Minute Guide to Using Qt Assistant]]

Once you have installed Qt, /Qt Assistant/ should be ready to run:

-  On Windows, /Qt Assistant/ is available as a menu option on the Qt
   menu.
-  On Mac OS X, /Qt Assistant/ is installed in the
   /Developer/Applications/Qt directory.
-  On Unix/Linux, open a terminal, type =assistant= and press *Enter*.

When you start up /Qt Assistant/, you will be presented with a standard
main window application, with a menu bar and toolbar. Below these, on
the left hand side are navigation windows called /Contents/, /Index/ and
/Bookmarks/. On the right, taking up most of the space, is the
/Documentation/ window. By default, /Qt Assistant/ loads the Qt
reference documentation along with the manuals of other Qt tools, like
/Qt Designer/ or /Qt Linguist/.

/Qt Assistant/ works in a similar way to a Web browser. If you click
hyperlinks (cross-references), the /Documentation/ window will present
the relevant page. You can bookmark pages of particular interest and you
can click the *Previous* and *Next* toolbar buttons to navigate within
the pages you have visited.

Although /Qt Assistant/ can be used just like a Web browser to navigate
through the documentation, /Qt Assistant/ offers a powerful means of
navigation that Web browsers do not provide. /Qt Assistant/ uses an
advanced full text search engine to index all the pages in each
compressed help file so that you can search for particular words and
phrases.

To perform an index search, click the *Index* tab on the Sidebar (or
press *Alt+I*). In the *'Look For'* line edit enter a word; e.g.,
'homedirpath'. As you type, words are found and highlighted in a list
beneath the line edit. If the highlighted text matches what you're
looking for, double click it, (or press *Enter*) and the /Documentation/
window will display the relevant page. You rarely have to type in the
whole word before /Qt Assistant/ finds a match. Note that for some words
there may be more than one possible page that is relevant.

/Qt Assistant/ also provides full text searching for finding specific
words in the documentation. To activate the full text search, either
press *(Alt+S)* or click on the *Search* tab in the /Documentation/
window. Then enter the term you're looking for and hit the *Search*
button. All documents containing the specified term will then be listed
in the list box below.

[[assistant-details.html][Qt Assistant in More Detail]]

© 2015 The Qt Company Ltd. Documentation contributions included herein
are the copyrights of their respective owners.

The documentation provided herein is licensed under the terms of the
[[http://www.gnu.org/licenses/fdl.html][GNU Free Documentation License
version 1.3]] as published by the Free Software Foundation.

** [[http://www.asciima.com/][ASCII码表详解]]


ASCII码表

ASCII码大致可以分作三部分组成。

[[http://www.asciima.com/ascii/2.html][第一部分是：ASCII非打印控制字符]]
 [[http://www.asciima.com/ascii/3.html][第二部分是：ASCII打印字符]]；
 [[http://www.asciima.com/ascii/4.html][第三部分是：扩展ASCII打印字符]]

**** 第一部分：ASCII非打印控制字符表

ASCII表上的数字0--31分配给了控制字符，用于控制像打印机等一些外围设备。例如，12代表换页/新页功能。此命令指示打印机跳到下一页的开头。（参详ASCII码表中0-31）

**** 第二部分：ASCII打印字符

数字 32--126
分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。数字127代表
DELETE 命令。（参详ASCII码表中32-127）

*ASCII码表 0-127*

| Bin        | Dec   | Hex   | 缩写/字符                     | 解释           |
| 00000000   | 0     | 00    | NUL(null)                     | 空字符         |
| 00000001   | 1     | 01    | SOH(start of headling)        | 标题开始       |
| 00000010   | 2     | 02    | STX (start of text)           | 正文开始       |
| 00000011   | 3     | 03    | ETX (end of text)             | 正文结束       |
| 00000100   | 4     | 04    | EOT (end of transmission)     | 传输结束       |
| 00000101   | 5     | 05    | ENQ (enquiry)                 | 请求           |
| 00000110   | 6     | 06    | ACK (acknowledge)             | 收到通知       |
| 00000111   | 7     | 07    | BEL (bell)                    | 响铃           |
| 00001000   | 8     | 08    | BS (backspace)                | 退格           |
| 00001001   | 9     | 09    | HT (horizontal tab)           | 水平制表符     |
| 00001010   | 10    | 0A    | LF (NL line feed, new line)   | 换行键         |
| 00001011   | 11    | 0B    | VT (vertical tab)             | 垂直制表符     |
| 00001100   | 12    | 0C    | FF (NP form feed, new page)   | 换页键         |
| 00001101   | 13    | 0D    | CR (carriage return)          | 回车键         |
| 00001110   | 14    | 0E    | SO (shift out)                | 不用切换       |
| 00001111   | 15    | 0F    | SI (shift in)                 | 启用切换       |
| 00010000   | 16    | 10    | DLE (data link escape)        | 数据链路转义   |
| 00010001   | 17    | 11    | DC1 (device control 1)        | 设备控制1      |
| 00010010   | 18    | 12    | DC2 (device control 2)        | 设备控制2      |
| 00010011   | 19    | 13    | DC3 (device control 3)        | 设备控制3      |
| 00010100   | 20    | 14    | DC4 (device control 4)        | 设备控制4      |
| 00010101   | 21    | 15    | NAK (negative acknowledge)    | 拒绝接收       |
| 00010110   | 22    | 16    | SYN (synchronous idle)        | 同步空闲       |
| 00010111   | 23    | 17    | ETB (end of trans. block)     | 传输块结束     |
| 00011000   | 24    | 18    | CAN (cancel)                  | 取消           |
| 00011001   | 25    | 19    | EM (end of medium)            | 介质中断       |
| 00011010   | 26    | 1A    | SUB (substitute)              | 替补           |
| 00011011   | 27    | 1B    | ESC (escape)                  | 溢出           |
| 00011100   | 28    | 1C    | FS (file separator)           | 文件分割符     |
| 00011101   | 29    | 1D    | GS (group separator)          | 分组符         |
| 00011110   | 30    | 1E    | RS (record separator)         | 记录分离符     |
| 00011111   | 31    | 1F    | US (unit separator)           | 单元分隔符     |
| 00100000   | 32    | 20    | (space)                       | 空格           |
| 00100001   | 33    | 21    | !                             |                |
| 00100010   | 34    | 22    | "                             |                |
| 00100011   | 35    | 23    | #                             |                |
| 00100100   | 36    | 24    | $                             |                |
| 00100101   | 37    | 25    | %                             |                |
| 00100110   | 38    | 26    | &                             |                |
| 00100111   | 39    | 27    | '                             |                |
| 00101000   | 40    | 28    | (                             |                |
| 00101001   | 41    | 29    | )                             |                |
| 00101010   | 42    | 2A    | *                             |                |
| 00101011   | 43    | 2B    | +                             |                |
| 00101100   | 44    | 2C    | ,                             |                |
| 00101101   | 45    | 2D    | -                             |                |
| 00101110   | 46    | 2E    | .                             |                |
| 00101111   | 47    | 2F    | /                             |                |
| 00110000   | 48    | 30    | 0                             |                |
| 00110001   | 49    | 31    | 1                             |                |
| 00110010   | 50    | 32    | 2                             |                |
| 00110011   | 51    | 33    | 3                             |                |
| 00110100   | 52    | 34    | 4                             |                |
| 00110101   | 53    | 35    | 5                             |                |
| 00110110   | 54    | 36    | 6                             |                |
| 00110111   | 55    | 37    | 7                             |                |
| 00111000   | 56    | 38    | 8                             |                |
| 00111001   | 57    | 39    | 9                             |                |
| 00111010   | 58    | 3A    | :                             |                |
| 00111011   | 59    | 3B    | ;                             |                |
| 00111100   | 60    | 3C    | <                             |                |
| 00111101   | 61    | 3D    | =                             |                |
| 00111110   | 62    | 3E    | >                             |                |
| 00111111   | 63    | 3F    | ?                             |                |
| 01000000   | 64    | 40    | @                             |                |
| 01000001   | 65    | 41    | A                             |                |
| 01000010   | 66    | 42    | B                             |                |
| 01000011   | 67    | 43    | C                             |                |
| 01000100   | 68    | 44    | D                             |                |
| 01000101   | 69    | 45    | E                             |                |
| 01000110   | 70    | 46    | F                             |                |
| 01000111   | 71    | 47    | G                             |                |
| 01001000   | 72    | 48    | H                             |                |
| 01001001   | 73    | 49    | I                             |                |
| 01001010   | 74    | 4A    | J                             |                |
| 01001011   | 75    | 4B    | K                             |                |
| 01001100   | 76    | 4C    | L                             |                |
| 01001101   | 77    | 4D    | M                             |                |
| 01001110   | 78    | 4E    | N                             |                |
| 01001111   | 79    | 4F    | O                             |                |
| 01010000   | 80    | 50    | P                             |                |
| 01010001   | 81    | 51    | Q                             |                |
| 01010010   | 82    | 52    | R                             |                |
| 01010011   | 83    | 53    | S                             |                |
| 01010100   | 84    | 54    | T                             |                |
| 01010101   | 85    | 55    | U                             |                |
| 01010110   | 86    | 56    | V                             |                |
| 01010111   | 87    | 57    | W                             |                |
| 01011000   | 88    | 58    | X                             |                |
| 01011001   | 89    | 59    | Y                             |                |
| 01011010   | 90    | 5A    | Z                             |                |
| 01011011   | 91    | 5B    | [                             |                |
| 01011100   | 92    | 5C    | \                             |                |
| 01011101   | 93    | 5D    | ]                             |                |
| 01011110   | 94    | 5E    | \^                            |                |
| 01011111   | 95    | 5F    | \_                            |                |
| 01100000   | 96    | 60    | `                             |                |
| 01100001   | 97    | 61    | a                             |                |
| 01100010   | 98    | 62    | b                             |                |
| 01100011   | 99    | 63    | c                             |                |
| 01100100   | 100   | 64    | d                             |                |
| 01100101   | 101   | 65    | e                             |                |
| 01100110   | 102   | 66    | f                             |                |
| 01100111   | 103   | 67    | g                             |                |
| 01101000   | 104   | 68    | h                             |                |
| 01101001   | 105   | 69    | i                             |                |
| 01101010   | 106   | 6A    | j                             |                |
| 01101011   | 107   | 6B    | k                             |                |
| 01101100   | 108   | 6C    | l                             |                |
| 01101101   | 109   | 6D    | m                             |                |
| 01101110   | 110   | 6E    | n                             |                |
| 01101111   | 111   | 6F    | o                             |                |
| 01110000   | 112   | 70    | p                             |                |
| 01110001   | 113   | 71    | q                             |                |
| 01110010   | 114   | 72    | r                             |                |
| 01110011   | 115   | 73    | s                             |                |
| 01110100   | 116   | 74    | t                             |                |
| 01110101   | 117   | 75    | u                             |                |
| 01110110   | 118   | 76    | v                             |                |
| 01110111   | 119   | 77    | w                             |                |
| 01111000   | 120   | 78    | x                             |                |
| 01111001   | 121   | 79    | y                             |                |
| 01111010   | 122   | 7A    | z                             |                |
| 01111011   | 123   | 7B    | {                             |                |
| 01111100   | 124   | 7C    | |                             |                |
| 01111101   | 125   | 7D    | }                             |                |
| 01111110   | 126   | 7E    | ~                             |                |
| 01111111   | 127   | 7F    | DEL (delete)                  | 删除           |

**** 第三部分：扩展ASCII打印字符

扩展的ASCII字符满足了对更多字符的需求。扩展的ASCII包含ASCII中已有的128个字符（数字0--32显示在下图中），又增加了128个字符，总共是256个。即使有了这些更多的字符，许多语言还是包含无法压缩到256个字符中的符号。因此，出现了一些ASCII的变体来囊括地区性字符和符号。例如，许多软件程序把ASCII表（又称作ISO8859-1）用于北美、西欧、澳大利亚和非洲的语言。

[[http://www.asciima.com/img/ascii127-255.jpg]]

**
* Week
** 2016/01/21
*** openwrt                                                :openwrt:路由器:

- [[https://zh.wikipedia.org/wiki/OpenWrt][Wiki]]
- [[https://openwrt.org/][Homepage]]
- [[http://post.smzdm.com/p/99210/][树莓派&OpenWrt]]


1. what?

   基于 Linux 的开源路由器(应用于嵌入式的 Linux 发行版本)

2. history

   2003年底推出WRT-54G，是一款基于MIPS架构的无线路由器，并且使用
   802.11g标准使得带宽在理论上能够达到54M，在当时是一次巨大的成长。
   WRT-54G操作系统以Linux取代vXworks，哥伦比亚大学法学院教授Eben
   Moglen向Linksys提出开源要求。2003年7月，Linksys迫于压力，开源了
   WRT54G的firmware，不久sveasoft公司开发了Alchemy。从此无线路由器进入
   了可以刷机的时代。

3. application

   - 用于脱机离线下载。
   - VPN服务器。
   - SSH服务器。
   - Shadowsocks配合Pdnsd、Chinadns、Dnscrypt软件智能突破网络审查。
   - 动态DDNS。
   - 单线多拨及带宽叠加。
   - QOS智能限速（从石像鬼中提取）。
   - 远程视频监控。

*** tag 分类

标签的性质
1. 对象本身（普通）
2. 对象属性（普通）
3. 对象组件（普通）
4. 对象范畴 ： 大写
5. GTD 标签 ： 下划线开头的标签为特殊标签

需要定点提前准备东西的任务，打上 _preparation 的标签

** 2016/01/20
*** dpkg error                                                      :error:

https://www.ubuntu.org.cn/viewtopic.php?f=86&t=54689&p=2260127

1. error
   #+BEGIN_EXAMPLE
     ImportError: No module named 'ConfigParser'
     dpkg: 处理软件包 python-markupsafe (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     dpkg: 依赖关系问题使得 python-mako 的配置工作不能继续：
      python-mako 依赖于 python-markupsafe；然而：
       软件包 python-markupsafe 尚未配置。

     dpkg: 处理软件包 python-mako (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 依赖关系问题使得 gobject-introspection 的配置工作不能继续：
      gobject-introspection 依赖于 python-mako；然而：
       软件包 python-mako 尚未配置。

     dpkg: 处理软件包 gobject-introspection (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 依赖关系问题使得 libgirepository1.0-dev 的配置工作不能继续：
      libgirepository1.0-dev 依赖于 gobject-introspection (= 1.42.0-2.2)；然而：
       软件包 gobject-introspection 尚未配置。

     dpkg: 处理软件包 libgirepository1.0-dev (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 依赖关系问题使得 libpeas-dev 的配置工作不能继续：
      libpeas-dev 依赖于 libgirepository1.0因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
                               因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
                   由于已经达到 MaxReports 限制，没有写入 apport 报告。
                                                                       由于已经达到 MaxReports 限制，没有写入 apport 报告。
                                           由于已经达到 MaxReports 限制，没有写入 apport 报告。
               -dev (>= 0.10.1)；然而：
       软件包 libgirepository1.0-dev 尚未配置。

     dpkg: 处理软件包 libpeas-dev (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 处理软件包 python-oneconf (--configure)时出错：
      该软件包正处于非常不稳定的状态；
     您最好在配置它之前，先重新安装它
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     dpkg: 处理软件包 python-markupsafe (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     正在设置 python-oneconf (0.3.7.15.04.1) ...
     Traceback (most recent call last):
       File "/usr/bin/pycompile", line 35, in <module>
         from debpython.version import SUPPORTED, debsorted, vrepr, \
       File "/usr/share/python/debpython/version.py", line 24, in <module>
         from ConfigParser import SafeConfigParser
     ImportError: No module named 'ConfigParser'
     dpkg: 处理软件包 python-oneconf (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     dpkg: 依赖关系问题使得 software-center 的配置工作不能继续：
      software-center 依赖于 python-oneconf (>= 0.3) | oneconf (<< 0.3)；然而：
       软件包 python-oneconf 尚未配置。
     系统中 oneconf 的版本为 0.3.7.15.04.1。

     dpkg: 处理软件包 software-center (--configure)时出错：
      依赖关系问题 - 仍未被配置
     正在设置 youtube-dl (2015.02.28-1) ...
     因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
                                                                         Traceback (most recent call last):
       File "/usr/bin/pycompile", line 35, in <module>
         from debpython.version import SUPPORTED, debsorted, vrepr, \
       File "/usr/share/python/debpython/version.py", line 24, in <module>
         from ConfigParser import SafeConfigParser
     ImportError: No module named 'ConfigParser'
     dpkg: 处理软件包 youtube-dl (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     由于已经达到 MaxReports 限制，没有写入 apport 报告。
                                                         在处理时有错误发生：
      python-markupsafe
      python-oneconf
      software-center
      youtube-dl

   #+END_EXAMPLE

2. solution 1

   #+BEGIN_EXAMPLE
   sudo apt-get remove -f
   #+END_EXAMPLE

   无效

3. 终极暴力解法

   删除 */var/lib/dpkg/status* 中有关那个软件的安装信息
   和 */var/lib/dpkg/info* 目录下那个软件包的几个文件
   这个应该是 =终极方法= ，不过， *使用之前注意备份就是了*

   #+BEGIN_EXAMPLE
     wally@ info $ ls | grep youtube-dl
     youtube-dl.conffiles
     youtube-dl.list
     youtube-dl.md5sums
     youtube-dl.postinst
     youtube-dl.prerm
     wally@ info $ sudo find . -name "youtube-dl.*" -exec mv {} {}.20160120.1.bak \;
     wally@ info $ ls | grep youtube-dl
     youtube-dl.conffiles.20160120.1.bak
     youtube-dl.list.20160120.1.bak
     youtube-dl.md5sums.20160120.1.bak
     youtube-dl.postinst.20160120.1.bak
     youtube-dl.prerm.20160120.1.bak
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
      $ sudo apt-get -f install
     正在读取软件包列表... 完成
     正在分析软件包的依赖关系树
     正在读取状态信息... 完成
     下列软件包是自动安装的并且现在不需要了：
       libffi-dev linux-headers-3.19.0-15 linux-headers-3.19.0-15-generic linux-image-3.19.0-15-generic linux-image-extra-3.19.0-15-generic
     使用'apt-get autoremove'来卸载它(它们)。
     升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。
     有 4 个软件包没有被完全安装或卸载。
     解压缩后会消耗掉 0 B 的额外空间。
     正在设置 python-markupsafe (0.23-1) ...
     正在设置 python-oneconf (0.3.7.15.04.1) ...
     正在设置 software-center (13.10-0ubuntu6.1) ...
     正在设置 youtube-dl (2015.02.28-1) ...
   #+END_EXAMPLE

   测试 OK

*** [[http://askubuntu.com/questions/144905/virtualbox-windows-key-pass-through-to-gnome][VirtualBox 解除 win 键占用]]

1. 出发点

   使用 Ubuntu 时要经常使用 Win + Num 组合键在 Emacs，shell, Chrome 等
   窗口之间切换。当切换到虚拟机时，该组合键失效。

   Win+1 EmacS
   Win+2 Shell
   Win+3 Chrome
   Win+4 File
   Win+5 VirtualBox

   补充： 还有 Alt+Tab 键

2. 设置

   #+BEGIN_EXAMPLE
     Open the VirtualBox Manager window, and go to "File" menu,
     "Preferences" (Ctrl-G).
     Under "Input", uncheck the box labeled "Auto Capture
     Keyboard". There is no need to restart the VM if it's running, so
     this can be changed "on the fly".
   #+END_EXAMPLE

   #+DOWNLOADED: file:///home/wally/Desktop/2016-01-20%2015:12:44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png @ 2016-01-20 15:13:10
   [[~/Wally/Journal/Figure/.org-download/Tasks/2016-01-20%2015:12:44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2016-01-20_15:13:10.png]]

   Note: 在 Virtual Box 的管理窗口中，而不是虚拟机窗口中。

3. 测试 OK

*** .build 文件夹                                                   :trick:

1. 出发点

   从源码编译安装的软件或库一般都完成后删除。这样节省存储空间，并不是
   最优的。

   因为有的时候需要使用 make 的其他选项
   - 最常用的是 unintall (dpkg 对源码安装的软件无效)
   - 其次，make doc, 比如 PCL 库的 doxygen 文档

2. trick

   建立 $HOME/.build 目录，用来
   1) 临时存放源码
   2) 暂存编译安装信息
   3) 定期确认并清理

*** HTML 参考文档                                                   :trick:

1. 出发点

   PDF 是我最喜欢的文档格式，可视化良好，恰到好处的可编辑功能。

   HTML 文件是 Doxygen 生成文档可视化最好的格式，但在线看往往不方便，
   也不能使用 org-mode 建立链接或索引。

2. 在 Referece/HTML 文件夹下保存所有 HTML 格式的参考文档

*** org-tag-view

搜索标签常用。

绑定在 C-c a m 太慢

#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "<f12>") 'org-tags-view)
#+END_SRC
** 2016/01/18
*** blender

- [[https://www.blender.org/manual/zh.cn/getting_started/index.html][Blender 官方入门教材（中文）]]
- [[https://zh.wikibooks.org/zh-cn/Blender_3D%EF%B8%B0%E5%BE%9E%E5%85%A5%E9%96%80%E5%88%B0%E7%B2%BE%E9%80%9A][Blender 3D︰从入门到精通(wikibook)]]
- [[http://wiki.blender.org/][Homepage]]

*** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

*** PCL

#+include: ~/Wally/Project/pcl_tutorials

http://www.pointclouds.org/documentation/tutorials/

**** [[http://www.pointclouds.org/documentation/tutorials/basic_structures.php#basic-structures][Basic Structure]]

*PointCloud*

- width
- height
- points
- is_dense
- sensor_origin
- senor_orientation

To simplify development, the PointCloud class contains a number of
helper member functions. For example, users don’t have to check if
height equals 1 or not in their code in order to see if a dataset is
organized or not, but instead use *PointCloud()*:

#+BEGIN_SRC cpp
if (!cloud.isOrganized ())
#+END_SRC

***** writing point cloud data to PCD files

#+include: ~/Wally/Project/pcl_tutorials/src/pcd_write.cpp

头文件位置 =/usr/include/pcd-1.7/pc/=

#+BEGIN_SRC cpp
#include <pcl-1.7/pcl/io/pcd_io.h>
#include <pcl-1.7/pcl/point_types.h>
#+END_SRC

创建 link

#+BEGIN_EXAMPLE
 ~ $ ls -l /usr/include/pcl
lrwxrwxrwx 1 root root 24  1月  7 09:53 /usr/include/pcl -> /usr/include/pcl-1.7/pcl
#+END_EXAMPLE

***** CMakeLists.txt

#+include: ~/Wally/Project/pcl_tutorials/CMakeLists.txt

**** [[http://www.pointclouds.org/documentation/tutorials/voxel_grid.php#voxelgrid][Downsampling a PointCloud using a VoxelGrid filter]]


- *downsample*: reduce the number of points
- using a *voxelized grid* approach

#+include: ~/Wally/Project/pcl_tutorials/src/voxel_grid.cpp

**** Merging PCDs
***** concatenate the points of two points clouds

http://pointclouds.org/documentation/tutorials/concatenate_clouds.php

#+include: ~/Wally/Project/pcl_tutorials/src/concatenate_clouds.cpp

** 2016/01/17
*** scratch                                                       :scratch:

**** intro                                                         :intro:

Scratch是麻省理工大学媒体实验室终身幼稚园组开发的一套电脑程序开发平台，
旨在让程序设计语言初学者不需先学习语言语法便能设计创作产品。开发者期望
通过学习Scratch，启发和激励用户在愉快的环境下通过实验（如设计交互故事）
去学习程序设计、数学和计算知识，同时获得创造性的思考，系统推理，和协同
工作的体验。

Scratch 开发平台可安装在Mac OS X、Windows、Linux的平台上；自2.0之后，
换用Actionscript编制，Scratch运行于浏览器。Scratch源码开放给非商业性质
用途使用。


#+DOWNLOADED: https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Scratchcat.svg/180px-Scratchcat.svg.png @ 2016-01-18 11:17:22
 [[~/Wally/Journal/Figure/.org-download/Journal/180px-Scratchcat.svg_2016-01-18_11:17:21.png]]

**** keyword                                                     :keyword:

scratch, MIT, 教育软件， 跨平台， 开源

**** reference                                                  :homepage:

- [[https://zh.wikipedia.org/wiki/Scratch%E8%AF%AD%E8%A8%80][Wikipedia: scratch 语言]]
- [[https://scratch.mit.edu/][Homepage]]
- [[http://cacm.acm.org/magazines/2009/11/48421-scratch-programming-for-all/fulltext][Scratch: Programming for All]]

*** godot                                                           :godot:

**** reference                                                  :homepage:

- [[http://www.godotengine.org/projects/godot-engine][Homepage]]
- [[https://github.com/godotengine/godot][Github]]

**** intro                                                         :intro:

Godot is a fully featured, open source, MIT licensed, game engine. It
focuses on having great tools, and a visual oriented workflow that can
export to PC, Mobile and Web platforms with no hassle. The editor,
language and APIs are feature rich, yet simple to learn, allowing you
to become productive in a matter of hours.

[[/home/wally/Wally/Journal/Figure/scrot/32504Cqi.png]]


开源游戏引擎

*** ccmake intro                                             :ccmake:intro:

- [[http://blog.csdn.net/arackethis/article/details/42155589][CMake 和 CCMake 的区别]]

CCMake is the GUI for manipulating files generated by / used by the
cmake system.

- ccmake is curses (terminal handling library) interface to CMake.

- cmake is the CLI (Command Line Interface)
*** metapost

http://www.ctex.org/documents/shredder/metapost.html

http://www.ctex.org/documents/shredder/metapostexample.html

*** emacs gif                                                         :gif:

**** record gif

- [[http://emacs.stackexchange.com/questions/798/recording-a-gif-screencast-of-emacs][stackexchange:Recording a GIF screencast of Emacs ]]
- [[https://github.com/Malabarba/camcorder.el][Github: camcorder.el]]


1. To use it, simply call *M-x camcorder-record*
2. A new smaller frame will popup and recording starts.
3. When you’re finished, hit *F12*.

View screencasts are generated in *ogv* format, and you can even pause
the recording with *F11*! You can also convert the .ogv file to a gif
by issuing the command *M-x camcorder-convert-to-gif*

后台程序

1. 录制
   - recordmydesktop
   - ffmpeg
   - mplayer & imagemagick

2. 转换
   - ffmpeg
   - mplayer & imagemagick

**** view gif

- https://github.com/Fuco1/org-inline-image

#+BEGIN_SRC emacs-lisp
  (require 'org-inline-image)
#+END_SRC

not work 没细看

*** blender dae

**** solutions

http://blender.stackexchange.com/questions/160/can-blender-export-to-the-collada-format

***** ppa

https://launchpad.net/~irie/+archive/blender

#+BEGIN_EXAMPLE
  Installing from the PPA:
  Add the PPA: ppa:irie/blender (sudo add-apt-repository ppa:irie/blender)
  Update your sources (Ubuntu Software Center does this automatically, but you will need to do it manually if adding from the command line). (sudo apt-get update)
  Install blender (this package is 2.6x from git) (sudo apt-get install blender)
#+END_EXAMPLE

http://askubuntu.com/questions/169542/how-do-i-install-the-latest-blender-3d-builds-from-a-ppa

#+BEGIN_EXAMPLE
And now that Irie PPA is not updated anymore, to get the latest version (updated weekly), you can use this instead:

sudo add-apt-repository ppa:thomas-schiex/blender
sudo apt-get update
sudo apt-get install blender
#+END_EXAMPLE

***** plugin

http://sourceforge.net/projects/colladablender/

the above link points to a blender 2.49 script. it will not work with recent Blender versions!

***** compile

#+BEGIN_EXAMPLE
 WITH_OPENCOLLADA                 ON
#+END_EXAMPLE

****** git clone

https://developer.blender.org/diffusion/B/

#+BEGIN_EXAMPLE
# read-only access
git clone git://git.blender.org/blender.git

# read/write access
git clone git@git.blender.org:blender.git

cd blender
git submodule update --init --recursive
git submodule foreach git checkout master
git submodule foreach git pull --rebase origin master
#+END_EXAMPLE

****** build

http://wiki.blender.org/index.php/Dev:Doc/Building_Blender

ccmake

#+BEGIN_EXAMPLE
  home/wally/Download/blender/source/blender/imbuf/intern/openexr/openexr_api.cpp
  fatal error: ImfMultiView.h: 没有那个文件或目录
   #include <ImfMultiView.h>
#+END_EXAMPLE

- openexr :: command-line tools and docs for the OpenEXR image format
- openexr-viewers :: viewer for images in the OpenEXR format

apt-get 方式安装相应软件后依然存在错误。


https://github.com/openexr/openexr

装这个更加烦人，编译半天一堆错误。

**** test

#+BEGIN_EXAMPLE
fake_module: addon missing 'bl_info' gives bad performance!: '/usr/share/blender/scripts/addons/colladaExport14.py'
#+END_EXAMPLE

**** plugin


***** 配置数据路径[[#configuration-and-data-paths][¶]]

https://www.blender.org/manual/zh.cn/getting_started/installing_blender/directorylayout.html

Blender使用了三种不同的文件夹，它们是跟操作系统有关系的。

- 本地 :: 配置和运行时数据位置（只供自己绑定使用）

- 用户 :: 配置文件位置（通常情况下在用户的家文件夹下）

- 系统 :: 系统级安装后的运行时数据位置（可能是只读的）。

系统级安装 *系统* 和 *用户* 文件夹都是需要的。

如果是本地解压Blender的发行版，这些用户配置数据和运行时数据都在一个子
文件夹下面，允许Blender的多个版本共存而且不会有冲突，可以忽略

*用户* 和 *系统* 文件。

注解

注解：你有可能需要确保你的文件管理器中，显示隐藏文件的选项已经被勾选。

****** 基于不同平台的路径[[#platform-dependant-paths][¶]]

下面是各个系统的默认文件夹位置：

******* Linux[[#linux][¶]]

- 本地 ::
  #+BEGIN_EXAMPLE
      ./2.76/
  #+END_EXAMPLE

- 用户 ::
  #+BEGIN_EXAMPLE
      $HOME/.config/blender/2.76/
  #+END_EXAMPLE

  # $ ls .config/blender/2.72/
  # config  scripts

- 系统 ::
  #+BEGIN_EXAMPLE
      /usr/share/blender/2.76/
  #+END_EXAMPLE

注解

该路径./2.76/是相对于Blender可执行文件以及用于自包含官方blender.org构建发布软件包。

注解

The *USER* path will use =$XDG_CONFIG_HOME= if its set:

#+BEGIN_EXAMPLE
    $XDG_CONFIG_HOME/blender/2.76/
#+END_EXAMPLE

******* Mac OSX[[#mac-osx][¶]]

-  本地 :: #+BEGIN_EXAMPLE
       ./2.76/
   #+END_EXAMPLE

-  用户 :: #+BEGIN_EXAMPLE
       /Users/$USER/Library/Application Support/Blender/2.76/
   #+END_EXAMPLE

-  系统 :: #+BEGIN_EXAMPLE
       /Library/Application Support/Blender/2.76/
   #+END_EXAMPLE

注解

OSX 存储blender二进制文件，放在 ‘./blender.app/Contents/MacOS/blender
‘，所以数据及配置的本地路径是:

#+BEGIN_EXAMPLE
    ./blender.app/Contents/MacOS/2.76/
#+END_EXAMPLE

******* MS-Windows[[#ms-windows][¶]]

-  本地 :: #+BEGIN_EXAMPLE
       .\2.76\.
   #+END_EXAMPLE

-  用户 :: #+BEGIN_EXAMPLE
       C:\Documents and Settings\$USERNAME\AppData\Roaming\Blender Foundation\Blender\2.76\
   #+END_EXAMPLE

-  系统 :: #+BEGIN_EXAMPLE
       C:\Documents and Settings\All Users\AppData\Roaming\Blender Foundation\Blender\2.76\
   #+END_EXAMPLE

****** 路径布局[[#path-layout][¶]]

下面的路径布局是以上的文件夹描述规范。

‘./Config/startup.blend ‘ 可能在哪里 ~/.blender/[[#id1][|例如
BLENDER_VERSION|]]/config/startup.blend。

-  =./autosave/ ...= :: 自动保存混合文件位置。* Windows
   只，临时目录用于其他 systems.*

   搜索顺序: =LOCAL, USER=.

-  =./config/ ...= :: 默认值与会话信息。

   搜索顺序: =LOCAL, USER=.

-  =./config/startup.blend= :: 载入初始文件和用户设置

-  =./config/userpref.blend= :: 载入初始文件和用户设置

-  =./config/bookmarks.txt= :: 在文件选择器中隐藏系统书签

-  =./config/recent-files.txt= :: 在文件管理器中隐藏最近查看的路径

-  =./datafiles/ ...= :: 运行时文件

   搜索顺序: =LOCAL, USER, SYSTEM=.

-  =./datafiles/locale/{language}/= :: 用户界面翻译的静态预编译的语言文件。

-  =./datafiles/icons/*.png= :: Blender用户界面的图标主题。*
   不目前可选的主题 preferences.*

-  =./datafiles/brushicons/*.png= :: 对于每个画笔的图像。

-  =./scripts/ ...= :: Python 脚本的用户界面和工具。

   搜索顺序: =LOCAL, USER, SYSTEM=.

-  =./scripts/addons/*.py= :: Python
   加载项在用户首选项，可以使包括导入/导出格式支持、
   渲染引擎集成和许多方便实用。

-  =./scripts/addons/modules/*.py= :: 模块的加载项的使用 (添加到 Python
   的 sys.path)。

-  =./scripts/addons_contrib/*.py= :: 另一个加载项目录是用于社区维护的插件
   (必须手动创建)。

-  =./scripts/addons_contrib/modules/*.py= :: 对 addons_contrib 的模块
   (添加到 Python 的 sys.path) 的使用。

-  =./scripts/modules/*.py= :: 包含我们的核心 API 和其他脚本到效用函数的
   Python 模块导入 (添加到 Python 的 ‘sys.path ‘)。

-  =./scripts/startup/*.py= :: 在启动时将自动导入的脚本。

-  =./scripts/presets/{preset}/*.py= :: 预设用于存储用户定义设置布、
   呈现格式等。

-  =./scripts/templates/*.py= :: 可以从访问的示例脚本:
   文本空间标题-->--> 脚本模板的文本。

-  =./python/ ...= :: 捆绑的 Python 发行版，不仅是必要的系统安装的
   Python 时缺席或不兼容。

   搜索顺序: =LOCAL, SYSTEM=.


***** 插件--NGENNGT翻译[[#add-ons][¶]]

https://www.blender.org/manual/zh.cn/advanced/scripting/python/add_ons.html

/插件/ 是对扩展Blender功能的脚本的通用术语。在 /用户设置/ 窗口的 /插件/
标签页找到这些脚本，在该标签页下可以搜索、安装、启用和禁用 插件。

****** 搜索[[#searching][¶]]

Blender自带一些好用的插件，你可以自行启用。不过你也可以添加你自己的或者从网上找到的有趣插件。


#+DOWNLOADED: https://www.blender.org/manual/zh.cn/_images/user_prefs-addons_tab.png @ 2016-01-18 11:47:34
 [[~/Wally/Journal/Figure/.org-download/Journal/user_prefs-addons_tab_2016-01-18_11:47:33.png]]

用户设置窗口中的插件标签页

[[http://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts][脚本目录]]
提供了Blender自带插件索引，同时也列出了许多外部插件。

****** 启用和禁用[[#enabling-and-disabling][¶]]

如图所示，勾选或取消勾选插件右侧的复选框即可启用或禁用该插件。


#+DOWNLOADED: https://www.blender.org/manual/zh.cn/_images/Extensions-Python-Addons-EnabledAddOn.jpg @ 2016-01-18 11:47:56
 [[~/Wally/Journal/Figure/.org-download/Journal/Extensions-Python-Addons-EnabledAddOn_2016-01-18_11:47:55.jpg]]

启用插件

启用插件功能可以即时生效。 如果启用后插件未激活， 可以在 [[../../../interface/window_system/console_window.html][/控制台窗口/]]
查看发生的错误。

单击插件左侧的箭头可以查看更多信息，如插件存放位置、描述和文档链接，你
还可以通过“报告Bug”按钮报告该插件的bug。


小技巧

保存插件设置

如果想要插件随Blender打开同时启用，你需要 /保存用户设置/ 。

****** 安装第三方插件[[#installation-of-a-3rd-party-add-on][¶]]

对于网络下载的或你自己的插件，需要单击 /从文件安装.../ 并选择 .zip 或
.py文件安装后，才能在插件列表中显示该插件。

或者你还可以手动安装插件，这在开发自己的插件过程中很有用。

直接将文件移动或链接至 =../scripts/addons= 文件夹(你的Blender文件夹配
置路径).

[[/home/wally/Wally/Journal/Figure/scrot/2380aff.png]]

****** 文件位置[[#file-locations][¶]]

关于Blender目录信息详见 [[../../../getting_started/installing_blender/directorylayout.html][/配置& 数据路径/]]。

你还可以新建个人插件目录，并在 /用户设置/ 中的 /文件/
面板配置该路径。新建一个个人脚本文件夹：

-  新建一个空文件夹 (如'script_addon_2-7x')

-  在该文件夹下添加一个 ‘addons'
   文件夹，只有这样命名Blender才能正确识别。

-  将你的新插件置于该 ‘addons' 文件夹。

-  打开 /用户设置/ 的 /文件/ 面板。

-  在 /脚本/ 路径中选择你的脚本文件夹路径 (如 ‘script_addon_2-7x')。

****** 开发指南[[#development-guidelines][¶]]

如果你是一个脚本开发人员，你可能对 [[http://wiki.blender.org/index.php/Dev:2.5/Py/Scripts/Guidelines/Addons][插件开发指南]] 感兴趣。

**
*** Linux
**** [[https://mp.weixin.qq.com/mp/appmsg/show?__biz=MzA3MzAwMjAxMQ==&appmsgid=10000009&itemidx=1&sign=c926ff23def356a4a0f2ed7141c466d6&scene=1&srcid=0118jxrIABVW8XwWSGpkpoJd&pass_ticket=8B57gmAPihhXDqY3DNHOKiG9154WT42aR6KFVbb%2FAFpL7bBsnVOOoPubYSkLb3iH][当你想放弃时，看看这幅漫画！]] :责任:

[[/home/wally/Wally/Journal/Figure/scrot/32504b9n.png]]

这篇东西转自一位有思想的研究生！她看到这篇漫画，觉得很不错，我看后也觉
得值得我们思考，尤其是当我们抱怨时！

[[/home/wally/Wally/Journal/Figure/scrot/32504oHu.png]]

第一幅漫画中，每个人都背负着一个沉重的十字架，在缓慢而艰难地前行！

[[/home/wally/Wally/Journal/Figure/scrot/325041R0.png]]

途中，有一个人忽然停了下来。他在想着什么！

[[/home/wally/Wally/Journal/Figure/scrot/32504nbD.png]]

他想，上帝啊，这个十字架太沉重了，我可以把十字架砍掉一块！

[[/home/wally/Wally/Journal/Figure/scrot/325040lJ.png]]

于是他动手砍了起来！

[[/home/wally/Wally/Journal/Figure/scrot/32504BwP.png]]

砍掉之后走起来，的确是轻松了很多，他的步伐也不由得加快了。

[[/home/wally/Wally/Journal/Figure/scrot/32504oOi.png]]

就这样走啊走啊！走着走着，他觉得肩上的十字架还是很沉，很重！

[[/home/wally/Wally/Journal/Figure/scrot/325041Yo.png]]

他祈求道，上帝啊，请你让我再砍掉一截吧，我会走得更轻松！

[[/home/wally/Wally/Journal/Figure/scrot/32504Cju.png]]

于是，他又砍掉了一截！感谢上帝，这样一来，他感到轻松多了！

[[/home/wally/Wally/Journal/Figure/scrot/32504Pt0.png]]

如此，他毫不费力地就走到了队伍的最前面。当其他人在吃力地负重前行时，他
却轻松地哼起了小曲！

[[/home/wally/Wally/Journal/Figure/scrot/32504B3D.png]]

啊哈!谁料，前边忽然出现了一个又深又宽的沟壑！沟上没有桥，周围
也没有路。也没有蜘蛛侠或者超人出来解救他…

[[/home/wally/Wally/Journal/Figure/scrot/32504bLQ.png]]

后面的人都慢慢地赶上来了，他们用自己背负的十字架搭在沟上，做成桥，从容
不迫地跨越了沟壑。

[[/home/wally/Wally/Journal/Figure/scrot/32504oVW.png]]

他也想如法炮制。只可惜啊，他的十字架之前已经被砍掉了长长的一大截，根本
无法做成桥帮助他跨越沟壑！

[[/home/wally/Wally/Journal/Figure/scrot/325041fc.png]]

于是，当其他人都在朝着目标继续前进时，他却只能停在原地，垂头丧气，追悔
莫及……

每个人都背负着属于自己的十字架，的确是这样，漫画中的每个人，都是背负着
属于自己的十字架，而当沟壑出现时，他们也只能利用自己背负的十字架去跨越
沟壑，继续前进。

所以：在人生的道路上，有些黑暗，只能自己穿越；有些痛苦，只能自己体验；
有些孤独，也只能自己品尝……人生是没有捷径的！

**** [[http://daily.zhihu.com/story/4573178?utm_campaign=in_app_share&utm_medium=Android&utm_source=Weixin&from=timeline&isappinstalled=0][哪些习惯能让生活变得简洁高效？]] :知乎:习惯：极简主义:

个人现状是处在三条规则，距离一条规则完全保持简约的生活方式还要努力几年时间。

***** 让生活变得简洁而高效只需要一条规则

就是照管好自己，保持一种简约的生活方式, 控制好自己的内心，从加法生活过
度到减法生活。

***** 如果觉得这一点说的太简单，就可以扩展成三条

*第一条：应用好 80/20原则*

把这个法则用在生活的各个方向中，把时间和精力放到自己擅长事情和主要目标
上，比如工作、家庭、友情、爱好、情绪，提高生活的质量和稳定

*第二条：做好精力管理，保持稳定而规律的生活方式：*

应该根据自己的精力进行安排和调整生活，周期性地补充精力，来平衡精力消耗。
需要对你的精力进行海战略性的规划和应用，并把它当成一种习惯。

人们的精力有4种来源，身体的、情感的、思想的和精神的，这4种精力资源需要
在消耗和储备之间取得平衡才能保证不会枯竭。


*第三条、 控制过度消费和物质过剩*

最初从减少选择开始，然后是学会丢东西，最成功的一次是用几个月时间丢掉了
50种不同类型的东西，包括当时的工作和26斤体重，整个生活立刻就简单了很多，
但距离断舍离的要求还有差距：

断舍离”是指：

断 = 不买、不收取不需要的东西

舍 = 处理掉堆放在家里没用的东西

离 = 舍弃对物质的迷恋，让自己处于宽敞舒适，自由自在的空间。


选择物品时不是“能不能用”，而是“我要不要用”。

扩展阅读：

-  [[http://www.read.org.cn/html/1386-reduce-the-choice-to-let-you-save-time.html][减少选择让你节省时间]]
-  《丢掉50样东西，找回100分人生》读书笔记
   --[[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200035644&itemidx=1&sign=6f0cd694354b3f75b757e41bc93b767b][warfalcon]]
-  进阶时看《断舍离》 [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000734&itemidx=1&sign=31ac402a40a351bf6823237d2d020057][warfalcon]]


***** 觉得这三条还是太难，那继续扩展成九条

只要减少这九类时间黑洞，生活中就会简约高效


*1、减少网络黑洞时间：*

每个人都离不网络，而网络上的无效时间黑洞是最多的：

不看新闻：

-  *时间管理之新闻阅读*[[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000055&itemidx=1&uin=MjU4MjUyNzM2MA%3D%3D&key=79cf83ea5128c3e59a05178691cc0d51487d45a3b3704ccaa2340ff568d898b089e6e31cf75c6a261042289e859b66c0&devicetype=android-10&version=25000338&lang=zh_CN&pass_ticket=1V0MbhKBMhjP%2BE4eiEonppyltegkgcZRy%2F%2FCxeKJlauehqow4jLPOnbhMpyI0xCB#wechat_webview_type=1#wechat_redirect&From=test][warfalcon]]**
-  你是在掌控新闻还是被新闻所掌控？
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200791870&itemidx=1&sign=77679932e20ecb28fa3ae6c26f653caf&scene=4&uin=MjU4MjUyNzM2MA%3D%3D&key=79cf83ea5128c3e59a05178691cc0d51487d45a3b3704ccaa2340ff568d898b089e6e31cf75c6a261042289e859b66c0&devicetype=android-10&version=25000338&lang=zh_CN&pass_ticket=1V0MbhKBMhjP%2BE4eiEonppyltegkgcZRy%2F%2FCxeKJlauehqow4jLPOnbhMpyI0xCB#wechat_webview_type=1#wechat_redirect&uin=MjU4MjUyNzM2MA%3D%3D&key=79cf83ea5128c3e59a05178691cc0d51487d45a3b3704ccaa2340ff568d898b089e6e31cf75c6a261042289e859b66c0&devicetype=android-10&version=25000338&lang=zh_CN&pass_ticket=1V0MbhKBMhjP%2BE4eiEonppyltegkgcZRy%2F%2FCxeKJlauehqow4jLPOnbhMpyI0xCB#wechat_webview_type=1#wechat_redirect&uin=MjU4MjUyNzM2MA%3D%3D&key=79cf83ea5128c3e59a05178691cc0d51487d45a3b3704ccaa2340ff568d898b089e6e31cf75c6a261042289e859b66c0&devicetype=android-10&version=25000338&lang=zh_CN&pass_ticket=1V0MbhKBMhjP%2BE4eiEonppyltegkgcZRy%2F%2FCxeKJlauehqow4jLPOnbhMpyI0xCB#wechat_webview_type=1#wechat_redirect&From=test][warfalcon]]
-  为什么你不应该读新闻
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200781923&itemidx=1&sign=96c0608f4ab861aac6271cf737d334ae][warfalcon]]

微信篇：

-  除非工作需求，否则每天集中查看三到四次微信，每次10分钟集中回复。
-  关闭微信朋友圈
-  定期退出无用的微信群
-  取消和关闭所有微信通知，否则微信的通知会不断的弹出信息来干扰和打断你

QQ篇：

1. 除非工作需求，否则一、二天登陆一次QQ
2. 定期评估并退出QQ群
3. 并关闭各种广告及提示。

邮件篇：
*[[http://www.read.org.cn/html/1986-shi-jian-guan-li-zhi-jian-chu-li-1-hai-liang-jian-chu-li.html][时间管理之邮件处理（1）海量邮件处理]]
*

*2、减少请求黑洞：*

学会拒绝工作和生活中各种要求，能减少大量的时间

要根据实际情况对要求做出判断。收到一个任务之后，应该问问自己：我必须马
上处理这个要求吗？我遇到最坏的情况就是每一项任务都是紧急的，需要立刻完
成。因为紧急任务一多，就会发现一整天都在不停地从一个工作转移到另一个工
作，最终一事无成。

对于别人的紧急要求，别立刻接受，而是提出一个近期内更合理的时间，以便完
成他/她手中的工作后处理新要求。然后将这个要求同其他相同的要求合并进行
批量处理。

*扩展阅读：*

-  [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000492&itemidx=1&sign=94c0656089fbaf9a6b751a5bbab54b4b][warfalcon]]
-  [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000495&itemidx=1&sign=b1adeb2d5aac7069cce791cda2bb5726][warfalcon]]


*3、减少选择黑洞*

我们必须控制过量选择，只把精力和时间放在生活中最重要的选项上，放弃一些
不重要的选择机会。千万别过于追求完美，做选择时要考虑好时间成本和机会成
本，而且一旦选择之后，别浪费精力去为其它放弃的选择而后悔。减少跟他人的
比较。

最好建立一个自己做选择的框架，在面临一些人生中的重大问题时可以更好的选
择和权衡。

扩展阅读：

-  控制过多的选择
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000177&itemidx=1&uin=MjU4MjUyNzM2MA%3D%3D][warfalcon]]
-  针对大量选择时的最优策略
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000738&itemidx=1&sign=b1ce75ef1000a3b70e770060e32d3b99][warfalcon]]
-  [[http://www.zhihu.com/question/19591602/answer/36731615][如何做选择才不会后悔？ - warfalcon 的回答]]


*4、减少负面情绪黑洞*

能正确面对恐惧、焦虑、抱怨等负面情绪，

扩展阅读：

-  [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000759&itemidx=1&sign=27c1add809978d24c929c82738753a76][warfalcon]]
-  [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201278840&itemidx=1&sign=a31cc5b12cf9be442ee1d07338376f3e#rd][warfalcon]]

5、减少注意力黑洞

-  如何集中自己的注意力
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000066&itemidx=1&uin=MjU4MjUyNzM2MA%3D%3D][warfalcon]]
-  观察自己的呼吸
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=203934058&itemidx=1&sign=e240a22c7e63853168c863c30c912577#rd][warfalcon]]
-  集中注意力的入门方法
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200983071&itemidx=1&sign=5ea7109a5848631609a7e0c81dc19983#rd][warfalcon]]
-  从管理时间转向管理注意力
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201082765&itemidx=1&sign=de78e74517d821092b5cd062d42f293e][warfalcon]]
-  集中注意力的十大秘诀
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201401194&itemidx=1&sign=9570baf0bb1fbc52c2c6ece7a4cb2add#rd][warfalcon]]
-  写给注意力严重不集中人士的生活建议
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=205820380&itemidx=1&sign=b5f6285133b0e65cea78336124a128c0#rd][warfalcon]]
-  学会在网络上控制你的注意力
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000685&itemidx=1&sign=09a1c1c940c29b1af205784d0159ce2f][warfalcon]]
-  学会在网络上控制你的注意力
   （2）[[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000688&itemidx=1&sign=be90345c551fa4c16c3aa91200e2685f&][warfalcon]]
-  用清理桌面物品来集中注意力：我常用的一种方法把笔记本关机，然后用笔
  记本清洁工具，把键盘、屏幕好好擦一下，然后看到焕然一新的笔记本心情大
  好。

6、减少交际黑洞

7、减少沟通黑洞

工作篇：

学会开会：*只去参加必要的会议*
[[http://www.zhihu.com/question/20291195/answer/15595509][开高效率的会议，有哪些好的经验？
- warfalcon 的回答]]

学会授权和培养新人：

-  [[http://www.read.org.cn/html/1563-monkey.html][《别让猴子跳回背上》读书笔记]]
-  快速培养新人的四个方法
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=202558668&itemidx=1&sign=62f0f7914474712f96af84ea8f66b269#rd][warfalcon]]

生活篇：


8、减少拖延黑洞

扩展阅读：

-  我的战拖策略
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200321752&itemidx=1&sign=e15045518f8cb1f89109961166752b6b][warfalcon]]
-  战拖小技巧
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=202225151&itemidx=1&sign=6fffbbd02142e150a56636f1f8d88a8d][warfalcon]]
-  《一分钟能做什么？》60招对抗拖延
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=202103054&itemidx=1&sign=9f9ca10919eededa948ae6395d01db77#rd][warfalcon]]
-  [[http://www.read.org.cn/html/2322-tuo-la-yi-dian-ye-wu-fang-zhong-de-jie-gou-hua-tuo-yan.html?From=test][《拖拉一点也无妨》中的结构化拖延]]
-  告别拖延症的7个信条
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201182906&itemidx=1&sign=89d62d5852b848338ebb20cc62068595#rd][warfalcon]]
-  对抗的拖延两种方法
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=205332382&itemidx=2&sign=4880ef380f52f401332ada12fdf28a71#rd][warfalcon]]
-  《战胜拖延症》笔记
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200233145&itemidx=1&sign=f64af36f8c909993966140447c54003c][warfalcon]]
-  对抗睡前拖延
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201089296&itemidx=1&sign=03827fccc3ecf45edb9946bca9ed239b][warfalcon]]
-  拖延处理技巧汇编
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000048&itemidx=1&uin=MjU4MjUyNzM2MA%3D%3D][warfalcon]]
-  《拖延心理学》中的12条应对技巧
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000365&itemidx=1&sign=2f8da62dc06a8be12691f8dd6a995a63][warfalcon]]


9、

***** 觉得这九条做到有些困难，那继续扩展成81条

1. 整理好办公桌 [[http://mp.weixin.qq.com/s?__biz=MjM5NjA3OTM0MA==&mid=204814936&idx=1&sn=fdc5f29e094ac9bc4b91a1c13f160296#rd][warfalcon]]

2. 每周提前做好下一周的规划和时间安排：[[http://www.zhihu.com/question/27783349/answer/38065315][如何让星期天的晚上过得更有意
   义？-warfalcon 的回答]]

3. 不整理名片，直接扫描，用名片全能王，直接扫描一下，大多数名片都能自
   动提取并识别，然后有时间的时候统一处理一下，一张名片只需要20、30秒
   就能处理完。

4. 问自己，如果我不做这件事情的话. 是否会出现极其严重的后果呢？”如果
   答案是否定的话. 我就会取消这件任务。

5. 提早1小时出门，在途中确认每天日程表

6. 多利用录音来取代手写的备忘录，用来记录各种想法和点子

7. 练就3分钟内长话短说的功夫

8. 工作日的时候，每天5点钟起床（晚上早些上床睡觉）。

9. 早上起床的时候做几个简单的体操，加上几个深呼吸，可以上大脑马上清醒

10. 午饭吃得很少，这样下午就不会感到困倦。

11. 用消噪耳机把公共场所变成书房

12. 读书的时候，我只会用很少时间，只了解书的要点内容。

13. 不要太相信记忆力，要勤做笔记，记录下来的东西要定期整理，消化。

14. 学习开会，要有重点，会后会把会议要点记录在一张A4纸上.

15. 不把日程表排满任务，每天留出三十分钟给自己，去跟自己约个会。在这段
    时间里，可以思考自己现在处于什么状态，思考将来需要一步步完成些什么，
    对未来进行长期的展望。

16. 放弃所有的“等待时间”。如果我不得不等待的时候，我将其看成是放松自
    我的机会，或者我也可以利用这段时间来做一些我平时不会做的事情。

17. 只要你多花一点心思，把自己的生活设计的更加有趣更加迷人，就能让你的
    生活丰富起来

18. 把你经常用的固定句式进行自定义加入词库中，比如搜狗输入法里面就有批
    量造词，把地址、邮箱、问候语、公文格式之类做成短语，打字速度会马上
    提高很多

19. 每天都会浏览一下自己的人生目标，并确保自己每天都会做一些事情来推进
    自己的人生目标。

20. 把目标可视化，设成手机壁纸或桌面壁纸，每天会重复提醒自己。

21. 即便是在做一些最不起眼的工作的时候，我都会想着自己的长期目标。

22. 尽量只做A级活动，少做B、C级活动。

23. 在开始一个大型项目的时候，我会首先从那些最重要的部分开始，并经常发
    现其他部分其实并不重要。

24. 首先做重要的事情。

25. 每当完成一些比较重要的任务之后，给自己放个假，或者是给自己一些特殊
    的奖励。

26. 集中精力处理那些能够带来长期收益的事情.

27. 一次只集中精力处理一件事情。

28. 坚持一件件完成'事务清单”上的工作。

29，把自己的大部分想法记录下来。

30. 用早晨的时间做一些比较有创造性的工作，然后利用下午的时间召开会议
    （如果有必要的话）。

31. 为自己和其他人设定最后期限。

32. 在每次跟人讨论的时候都会积极聆听。

33. 尽量不浪费其他人的时间（除非是一些对我真正重要的事情）。

34. 尽量把一些事情委托给他人完成。

35. 请专家来帮助我完成一些专业性的问题。

36. 请人帮助我处理所有常规性工作。

37. 尽量减少纸面工作。

39. 每份文件我只处理一次。

40. 把自己的桌面整理干净. 并把最重要的工作放到办公桌中央。

41，为所有的文件准备了专门的地方（这样我就不用再花时间到处找它们）。

42. 每个月会专门抽出三小时时间来处理琐碎事情。

43. 周末的时候尽量不考虑工作。

44. 经常让自己放松，什么都不做。

45. 我意识到迟早有一天，我会用一些时间来应付一些自己无法控制的事悄. 我
    不会为此感到厌烦。

46. 不断问自己，“我现在最应该做什么事情？”

47. 利用思维导图把握总体结构

48. 不要长时间连续学习: 每个人的精力是有限，并一定长时间学习效果就好

49. 花钱上课，强迫自己学习

50. 寻找学习伙伴，避免半途而废

51，冬天把空调设定在20℃

52. 利用腹式呼吸消除杂念

53. 马上实践学过的知识

54. 阅读中有30%～50%都是没用的

55. 给大脑0.5～9小时来处理信息，再回顾才会有新收获，不要在难点上停留

56. 倾听微弱的声音能提高注意力，每天练习3分钟

57. 每天做件不愿做的事

58. 自我讲授，像老师教学一样把资料概述出来，疑点会变得清晰

59. 大脑更喜欢图像

60. 技能不是持久的，不练习，它每天都在退步

61. 把问题用另一个角度重复一遍

62. 画效率/时间曲线表

63. 每天花10分钟写随笔，不要停顿

64. 不要压制欲望，化解它

65. 微笑释放的化学物质对紧张和愤怒极有效

66. 总是全力以赴，因为你最好的一面每段时间都不一样

67. 从别人的错误中学习，脑中犯的错越多现实中越少

68. 每天运动一刻钟

69. 区分抱怨，停止抱怨

70. 一年是很长的时间，重复就是力量

71. 每工作90~120分钟便需要休整，再全力以赴

72. 问自己，愿用2小时把事情做到80%还是4小时做到100%？它需要做到完美吗？

73. 为每页笔记作出简要总结，方便日后抓住重心

74. 整出条理可按时间、地点、连续统（难~易）、种类和字母排序

75. 觉得再难的，只要你能静下心来反复练习，就会有进步。

76. 找办法督促自己执行任务

77. 不要服用不必要的维生素和补充品。

78. 每年性生活高潮的次数越多、质量越高，你就越年轻。

79. 坚持每天吃早餐。

80. 低卡路里、高营养价值、均衡饮食。

81. 固定的睡眠时间能帮助你保持年轻。女性每晚睡眠时间7小时，男性8小时。

-------------------------------------------------------------------------------------------------------
觉得这81条也还是有问题，那继续扩展成6561条：
-------------------------------------------------------------------------------------------------------

这个版本可以直接关注我的微信、知乎、Blog和豆瓣，写了8年快完成1/3
了，还有 2/3 估计在我死之前还是很有希望的。

***** 对这么多的技巧应该如何吸收和整理？

*去“做”，但不要期待任何 “结果”。*

第一步分类。把不同的技巧，按用处或类型，从新整理一下。放上关键字，收藏
起来。

第二步删除。对你帮忙不大或暂时用不了的技巧。

*第三步挑出少数几条实践。* 选择一些能解决你当前问题的技巧，从现在开始
尝试。可以列个清单。

第四步记录。每尝试完一条之后，记录一下心得，想想是否有可以改变的地方或
者直接放弃。

第五步总结。积累5-10条实用小技巧之后，写篇文章总结一下，找机会分享出来，
你会发现在写的时间，会考虑一些以前想不到的问题，分享也能让你印象更深刻。

**** [[https://mp.weixin.qq.com/s?__biz=MzA3MjM2MzYzOQ==&mid=402437707&idx=1&sn=02c915a39a2124790476688c0bde69d9&scene=1&srcid=0115wtZqKbY2mdXhwAlhVlmz&pass_ticket=8B57gmAPihhXDqY3DNHOKiG9154WT42aR6KFVbb%2FAFpL7bBsnVOOoPubYSkLb3iH#rd][孩纸，事情不象你想的那么简单]] :行动:

文：雾满拦江

（01）

明朝时，有个叫李晟的人，他心怀大志，胸有奇谋，痴迷军事器械研究，发明了
许多先进武器，战车连弩什么的。朝廷是非常重视这类科学家的，立即传令工部，
照着李晟的图纸打造弓弩战车。

战车连弩很快打造出来了，可是怎么看都有点不对------车装配不起来，弓弩拉
不动。都是废品，根本没法儿用。

李晟以坐废钱粮之罪，贬。

好多年后，李晟再次卷土重来，给朝廷呈上他最新研究出来的战甲。朝廷仍然一
如既往的重视，立命工部铸造。

但这次，工部多了个心眼，铸造新式兵甲可以，但要求李晟本人，要先行试用。

试用就试用，等兵甲造出来，往李晟身上一扣，就听哐的一声巨响，李晟被他自
己研究出来的兵甲，死死的扣在了地下，怎么用力都爬不出来。

原来，李晟研究的兵甲，防御力量绝对没的说，刀砍不入水泼不进，就是忽略了
人体的承受重量。这兵甲一旦穿在身上，就被压得趴在地上，根本爬不动......

（02）

纪大烟袋纪晓岚，写了本《阅微草堂笔记》，书中提到一个怪人刘羽冲：

刘羽冲，沧州人。他也是个喜欢琢磨事儿的人。有一次，他无意中得到本古兵书，
潜心研读多年，终于破关而出。言称其可统兵十万众。恰逢当地闹土匪，刘羽冲
主动担纲领队，率乡勇出击土匪。一触即溃，如果不是刘羽冲逃得还算快，铁定
被土匪捉去了。

从此刘羽冲不言兵事。

又不久，他又得到了一本古水利书，再次潜心研读多年，终于破关而出，自谓可
使千里成沃壤。游说于州官。州官也是位富创新精神的冒险家，遂大胆采用刘羽
冲先生的方法，开渠治水。岂料沟渎初成，大水狂涌而入，州郡之人，几为鱼鳖。

连续的失败，让刘羽冲陷入忧伤之中。他每天独自徘徊在台阶下，不时的自言自
语：噫吁戏，古人都是王八蛋，净写假书把我骗。都怪老子太犯贱，连续上当没
咒念......

（03）

晚清年间，倡导洋务。有下有个蒋老汉，是个创新型的实干家。他在报纸上看到
洋人的火轮船，顿发宏愿，要亲手制造一艘。

制造一艘铁甲战船，那要花老钱了。蒋老汉舍得投入，他花光家产，负债累累，
凑足了材料，然后拎只小铁锤上阵了：叮哩当啷，哐哐咣咣，不眠不休的苦战了
不知几多日月，最终是功夫不负苦心人，一艘华丽的铁甲船，终于成功的制造出
来了。

铁船下水之日，三乡五里的人全都跑来看热闹，被蒋老汉的创意深深的折服：看
看人家，你看看人家，敢想敢干敢冒险，真是了不起......哎哟，那是怎么回事？

没怎么回事，就是蒋老汉研究出来的铁甲船，一碰到水，就听咕嘟咕嘟，瞬间就
沉没了。

造了这么多日子的铁甲船，刚刚见水就沉了，这未免......蒋老汉呆立水边，茫
然失措。

一个看热闹的人告诉他：老蒋呀，你的创新精神，是好的，是应该受到鼓励和支
持的。可是这世上的事儿，不是你胆肥儿就能干明白的。单说这铁甲船，在洋人
那里都是个超复杂的问题，要学好多好多的知识，才可以......

原来是这样啊，蒋老汉毅然发了狠，要送儿子去西洋，学习制造铁甲船。

蒋老汉把儿子送去了西洋，可是这个儿子学了半天，还是没弄会如何制造铁甲船。
他毕业归国，去北大当了校长，专门告诉孩子们：骚年，这个做事呢，不象你们
想的辣么简单，真的不象，就比如说咱爹......

这位校长，叫蒋梦麟。

（04）

前段时间，一位当父亲的在我微信里留言，说了这么件事：

他的儿子，大学毕业了，雄心勃勃，要开工办厂。

可是，这家人父亲没开过厂，爷爷没经过商，祖上十八代都是凡人，你个熊孩子
开口就要开厂，你懂得厂门该向哪儿开吗？

孩子才不管，在家里大吵大闹，要家里拿五十万创业基金出来。

钱是有，可五十万，足以让这家人抽筋剥皮了，毕竟是工薪阶层......可这苦情，
根本不能跟读了书的孩子讲。这孩子读书读得已经不会说人话了，开口就骂：五
十万你都拿不出来，活这辈子还不如条狗，现在赚钱这么容易，狗汪汪两声都能
赚五十万......

家里被这孩子闹得乌烟瘴气，最后老伴屈服了，瞒着他给了孩子存折。

不出所料，孩子拿到钱，立即就消失了。不久有债主找上门来，厂子没见到，据
来人说孩子还在外边欠下一百来万......此时家人心急如焚，到处找孩子，最终
在家网吧，成功的把那熊孩子找回来。那孩子回来时梗着脖子，一脸的不服不忿，
此后爹妈做牛做马还债，这孩子就呆坐在沙发上看电视，还不能问他怎么欠下人
家的钱，一问这孩子就疯起来......

那位父亲问：你说我儿子，这书他究竟是怎么读的呢？读到最后，连事情看着容
易做起来难，这么简单个道理，他都不懂了呢？

（05）

前段时间，我的几个写字吃饭的朋友，聚一起喝酒，一边喝一边愤慨：唉，什么
世道，这人都是瞎了眼吗？你看那个谁，那个谁，还有那个谁谁谁，他们写的东
西，叫什么玩艺儿呀？烂到家的文章，根本看不下去，可是他们都红了，还大红
大紫，这可真是日了狗了。

咱们也要红！

咱们几个的才华，比他们强上几百倍，想红不过是分分钟的事儿！

而且，咱们是个团队，随便扔过去一个，都把他们砸趴下的那种。咱们几个合写
一个微信公众号，大家轮流上，每天一篇原创，最多不出半个月，准保大火。火
了后咱们就那啥......那啥......

干啦！

然后他们就真的开了个公众号，联手上，一共五个人，每五天轮一圈，每天一篇
原创文章。

头两圈，大家严肃认真，克尽职守。

到了第三圈，有位老兄讨个巧，他没写文章，顺手把他早年写的诗，发上去凑个
数。

他的想法是，我就今天偷个懒，有你们四个人的原创撑着呢，整体质量也不会下
降，等我哪天灵感来了，写篇涨粉的......

不曾想，另外几个老兄，也是这种想法。只是不好意思，见这老兄先行下了手，
大家心里再无顾忌。

从此这个公众号，发的时候随便抄几句，或者干脆停发，就这样过了段时间，这
个公众号，大家就很少登录了。

团队合作，怎么想都是极完美的，但当真做起来，却发现总会有意想不到的事情
发生，让我们心中美好愿望，最终沦为空想。

------人世间的事儿，怎么用脑子想，怎么合理。只有等做起来时，才会发现，
想象中的逻辑与现实，往往不在一个频道上。

（06）

一个人，做事越少，怨愤之气就越重。

*做事少的人，会把所有的事情，想得极简单。*

做事如此简单，可证自己的智商，那可不是一般的高。自己这么高的智商，却混
不出个模样来，可证这世道是多么的昏黑阴暗。世道如此不公，让自己满腔宏愿，
无由抒展，这种情况下的人，想不悲愤，真的很难。

*但这几个故事，告诉我们，人间事儿，真的没有简单可言------如果有，那一
定是你以旁观者的角度，看别人做事。*

明朝的李晟，清朝的刘羽冲、蒋老汉，都是认真做事之人。只不过，他们所做的，
是自己不熟悉的领域，不知道一项研究，要经过无数次试错，才会稍有点眉目的。
比如爱迪生，他为了寻找最合适的电灯丝，先后试验了上万种材料。在这个过程
中，所谓做事，不过是不停的试错，把所有的错误都找出来，就知道对的方案
了------但明李晟，清刘羽种和蒋梦麟的父亲，都只有一次试错的机会，一次不
对，人生成本耗尽，就玩不下去了。

人是没有预知能力的------许多人看到这句话，会频繁点头，但当轮到他们自己，
却往往忘了这点。那个非要开工办厂的孩子，和五个合开微信公众号的老兄，就
是不知道一件事情做起来，会有无数的枝节问题需要解决。这些问题和困难，只
有做了之后才知道。

不知道事情会遇到什么问题，不清楚事情的枝节，只看到事情的头和尾，这就是
许多人，把没做过的事情，想得过于简单的原因。

（07）

人生就是这样，除非在你自己的主场，所有的因素完全可控，这时候你才敢说胜
劵在握。

余者，你必须准备支付试错成本。

台湾有个歌星，曾讲述他服兵役时，如其所愿的被安排去歌唱，他雄心勃勃，以
为自己是偶像，铁定是赢得满堂喝彩。岂料真要演出时，惊发现还需要他自己搭
舞台，可他只会唱，从未搭过舞台，顿时傻了眼。这时候他的同伴们立即取出携
带的简易工具，噼哩啪啦搭个台子，自己走上去引吭高歌，让这位大歌星看得直
眨巴眼。

没有亲手做过的事儿，之所以想得容易，就是不知道还需要自己搭台。嚷着开厂
的孩子不知道这个，生生被人骗成狗。我那几个写字的朋友，他们根本没有与人
合作过，心里想的简单，以为人人都会出工卖力，替自己搭台。但等真做起来，
才发现人性还有偷懒搭便车的一面，台子还得你自己搭。只会唱戏不会搭台，这
戏你就唱不了。

想象中的逻辑，完全构建在别人都是无生命的劳作单元、心甘情愿替自己搭台的
基础之上。想象中的别人，都是没有私欲的，对自己是绝对顺从的。就跟电视剧
里演的一样。电视剧中，所有人都是主角的奴隶，就算是对手，也是以其拙劣映
衬主角的高智商。而电视剧是典型的想象思维，符合人类的主观想象------唯独
与现实不太贴边。

（08）

许多人喜欢指点别人，却最痛恨别人指点自己。

指点他人时，个个都是高手，从未做过实事的孩子，敢怒斥辛苦的父亲笨。等轮
到他来做，才知道这世上最笨的，就是他自己。

事非经过不知难。事情也只有做，才会在一次次试错后，走向成功------这是尽
人皆知的大道理。

但，没人告诉过你，你需要为每次试错，支付多少。

哪怕最简单的事儿，流程都复杂到超出你的预期。而每个环节的支出，加起来更
是个惊人的数字。以为五十万就能开个厂的孩子，需要有人告诉他，胼手胝足用
自己的努力来开厂的人，会发现自己付出的远不止这些。以为自己能力具备只差
钱的人，多半是把事情想简单了。

*永远要记住，想象最容易，做事最艰难，想象的逻辑与现实，始终有一条不可
逾越的鸿沟。*

真要想做成事，还要避免那种一次性就把人打入失败深渊的成本付出，适当的方
法有许多，比如你可以：

------先要知道自己这事儿没做过，许多细节不知道。这话说着简单，但没做过
事儿的人，会拼死的抬杠，死活不肯承认这点。

------承认你没做过的，必有你不明白的，这就可以了。

------从学徒做起。现在没有学徒制了，没有也不要紧，你可以找个正经做事的
人，到他身边，帮忙也好求聘也好，以员工的身份，踏实的观察，学习。这世上，
老板是最苦鳖的人，做梦都盼着个懂事明理的孩子，帮自己一把。如果你是这样
的人，就会获得具体实践的机会。

------事情做起来，慢慢你就知道什么叫资源了，你会认识越来越多做事的人，
知道每一个流程细节，能正确估算一件事的成本投入。

------等到你知道如何做事，懂得如何做成事，这时候你用不着逼家里拿钱成就
你的梦想，许多人自然就来找你了。当然，在你不会做事，还蠢透天的时候，也
会有许多人来找你，但这时候来的都是骗子。除非你成为做事的人，同类型的人
才会出现在你身边。

*事情是用来做的，不是说的。*

没做过事儿的人，往往会趾高气昂指点江山。而做事之人，莫不是低调谦
和------不是做事者人品好，而是他知道做事之难，再不敢摇头晃尾胡言乱语而
已。

让我们开始吧，先把心沉下，承认自己确实没有做过这件事。学习，询问，倾听，
学习的过程中，难免因为犯错而遭到斥责羞辱，如果你是玻璃心，明明什么都不
懂，还想让人拿爷供着，那就需要认真思考一下自己了。

要记住，这世上有两种人，一类是不做事，只管趾高气昂嘲笑别人，却荒废了自
己事业的蠢人。另一类是低调隐忍，任人嘲笑但逐步成就事业的人。你选择什么，
就会得到什么。你的人生你做主，荒废或是成就，取决于你内心深处的愿望。

**** [[http://m.wufazhuce.com/question/2016-01-03?from=timeline&isappinstalled=1][什么才是真正的成长？]] :一个:成长:

毛头子问：经常看到很多人说“成长”，感觉仿佛只要懂得了某个道理，就是一
种成长，成长就是不断地明白道理的过程，是这样么？


@曲玮玮 答毛头子：

真正的成长，就是不再急于成长。

有一类问题似乎很受欢迎------“哪些道理让你相见恨晚？”“你的每日私人成
长暗器是什么？”“哪些习惯能让生活变得更好？”

大家忙着收藏，忙着把一眼扫过去瞬间读完的道理抄在小本儿上，忙着赶紧找到
填补袖口破洞的补丁，忙着大彻大悟，忙着醍醐灌顶，即刻见疗效。

这些简洁的人生道理总是高赞。因为不需大费周章就能把几行金玉良言背下来，
产生自己手持武林秘籍行走江湖畅通无阻的幻象。

可是，你以为那些道理，作者栽跟头之前从没听说过吗？它们是治病的药丸，不
是预防针。只有跌了跟头后混合苦水服下去，才能缓解跌打损伤，从此溶进血液
里内化，终身傍身。在你经历到这些之前，它们只是粘在衣服上供你摘取的小处
方纸片。

当你真的成熟，慢慢不会再把“每天进步一点点”挂在嘴边。不会只对可以量化
的努力成果情有独钟，不会执念于“少吃一顿肉必然体重掉两斤，多做两道题考
试加五分”。没必要咬牙给自己设定
KPI。生活又不是大妈坐小板凳上织毛衣，一切所见即所得。

和我一样，很多写小说出身的人做自媒体，从前的创作是“背向”读者，所谓的
“成长”更多来源于自我省察。开了公众号之后，一切数据都转向阅读量与粉丝
数。有了可量化的数据之后，旁人哪里顾得上你内在的进步呢，只会忙不迭问你，
“最近粉丝涨了多少？”

或许世俗对成长与成功都有一套冷冰冰的评价体系，你要忍受层层标尺在身上测
量的尴尬，挺直腰板儿，心中另有一套无形的标尺。

时间本身是没有标度的，是人类为了有所区分与回顾，把连贯的时间分割成块。
又到年底，以前也执念于写一年总结，这一年看了多少书和电影，输出了多少万
字，把量的积累看作成长之一。也渴望从每段经历里萃取几滴人生精华敷在脸上，
希望每次摸爬滚打都能换来可视化的成长。

今年我依然会写总结，但不再有此心态。

生活不仅不是织毛衣，甚至连“蜗牛爬金字塔”都不是。没有任何人向你拍胸脯
保证，你所做的一切努力都指向前方。

有人用了错误的健身方式，辛苦流汗，却把自己严重拉伤。一些连续创业者总是
急于标榜自己在失败中得到多少宝贵的经验，却不会勇于承认，自己消耗了多少
资源和好年华。

你只是旅人走在陌生丛林里，天高地暗，薄雾微茫。你可能离星辰大海越来越近，
可能跋涉一天依然绕回原点，甚至努力一番仍向后退。

罗曼·罗兰说，“看清这个世界，然后爱它。”真正的成长，大概是你看透一切
之后，放下“你要去相信，没有到不了的明天”这种鸡汤执念，放下自欺欺人，
依然往前奔跑，无畏无惧。

初中时看《老友记》，看他们每天坐在同一张沙发上一本正经瞎扯淡，端着咖啡
杯消磨时间，乐此不疲地制造笑料，心里都在替他们着急，这些人什么时候能长
大啊。那些闲扯淡和玩填字游戏的时间，用来报个技能班学个编程该多好。

今年又重温了一遍。第一季穿着婚纱一惊一乍、被宠坏了的姑娘
Rachel，成了某时尚公司主管。吊儿郎当玩世不恭的
Chandler，重新找到了所爱的职业，也成了充满责任感的丈夫。

电视剧里从来没有从天而降一场惊人的变故，让每个人瞬间遭受锤炼，一夜之间
沧桑得判若两人。他们也没有合上书本后一拍大腿，顿悟真理从此铠甲傍身。

我只是在陪他们傻笑，替他们尴尬之余，年复一年，发现他们慢慢成长为另一种
样子。Joey
依然行为低幼，Monica
依然强迫症，Phoebe依然鬼马。十年过去，这些点缀人性的漂亮羽毛依然在他们
头顶随风飘，但是人生已经有了更厚重的根基底座，再也不是二十出头受了惊吓
随时地动山摇世界崩塌的小孩子。

急什么呢。

我很喜欢一句话，叫“但行好事，莫问前程”。

并非要你放下功名尘土无欲无求，只是不带着强烈的结果导向去做事，不是把一
串葡萄放进榨汁机就马上求一杯饱满的果汁。

我们坚持一件事情，并非因为这样做了会有效果，而是坚信，这样做是对的。哈
维尔说。

只顾笃定往前走便是，胸中自有云月。
**** [[https://mp.weixin.qq.com/s?__biz=MzI0OTEzNzY3NA==&mid=402189489&idx=4&sn=52e6a4a3f19737ffb0f786bc26b0482b&scene=1&srcid=0118goA5DF1wmTRug9ZOpCti&pass_ticket=8B57gmAPihhXDqY3DNHOKiG9154WT42aR6KFVbb%2FAFpL7bBsnVOOoPubYSkLb3iH#rd][韩寒：长跑就是长跑，人生就是人生]]

很多人在长跑的时候喜欢思考人生，但对我来说，长跑就是长跑，人生就是人生，
我在长跑时考虑最多的时候是我的表情。

要知道我小时候一直是长跑队的，也拿了不少学校和区里的长跑比赛第一名。

其实我很早的时候是长跑的，如果我真的好好练的话，我的长跑应该可以到进国
家队的水平的。

我进高中是体育特招，长跑特招，我以前跑步是跑不快的，因为我的好朋友跑的
很慢，每次在体育课的时候我得跟他们做伴，他们跑得慢我也得跑得慢，有一次
误打误撞参加学校的800米和1500米比赛，第一次跑就两个比赛都破了校记录10
多秒，而且当中还停过，跑两圈以后，我以为到终点了，我跟同学们在欢呼拥抱
了，但是我们的跑道是250米一圈的。同学们给我欢呼完以后说哥们儿还有一圈，
然后我又追上去，还破记录，还拿的第一。

后来参加区里面长跑的比赛，8000米的也都很轻松地赢了，我自己从来都不训练。
跑8000米的时候，在街道上警察还带错路，我当时跑在第一，后来警察转身对我
说，哥们儿不好意思，我开错路了，然后又回到那条路上，等于我比人家多跑了
几百米，后来还赢了很多，体育特招进了市重点以后，学校里和松江区的、包括
跟体校在一起的只要是长距离的跑步的比赛，我都能赢，而且都能有很大的一个
领先的优势。而且我从来都不训练。

上学时别人说我是跑步天才，我觉的算不上，因为毕竟区或者是市一级的比赛还
是比较低的，但是如果我经过一些训练或者是怎么样的话，我相信我的长跑肯定
应该是挺好的。当然你不一定在世界上争得什么荣誉。

我当时穿篮球鞋在跑步，因为那个时候我爸爸一个月给我四五百块钱，我在外面
寄宿，我积攒了几个月之后终于有买球鞋的钱了，但是我想来想去，当时是灌篮
高手，爱面子，参加比赛就穿着很重的篮球鞋，如果有很轻的跑鞋的话，一定会
跑得更快。

可能是我的腿脚的形状比较适合长跑，耐力会比较好一些。我不会游泳，我很喜
欢骑自行车，当然不一定是奥运会的比赛，是好玩，参加一下。

但始终有一个问题困扰着我，那就是我的比赛照片实在是太难看了，每一张都是
面目狰狞，鼻孔放大，舌头外甩，眉头紧皱。而那些照片都被放在所有学生都能
看见的学校形象展示玻璃橱窗里，导致有一些女生看见我会说，哟，你真人没那
么丑嘛。

于是，长大以后，我选择了一个至少看起来比较酷的运动：赛车。最关键是，无
论我的表情是啥样，再也没有人能看见我的脸。我有头盔，而且选择了黑色的玻
璃镜片。

我对长跑没有眷恋，我抛弃了它整整十年。但跑步让我感触很深，因为这是唯一
一个我没能找到起点在哪里的比赛。

现在我三十多岁了，我又开始长跑。不为别的，不为思索，不为感悟，只为了自
己的身体。硬要我说出些什么，我只能说这是一个忆苦思甜的运动。

人在坐着的时候常常会想如果我能躺着那该多好；躺着的时候常常会想如果旁边
有一盘水果那该多好；吃到了水果常常会想如果有个人在边上给我按摩那该多好。
只有在长跑的时候我会想如果我能坐着那该多好。

**** [[http://www.cnblogs.com/skyseraph/archive/2010/10/30/1865280.html][完全用Linux工作-王垠]] :linux:

注：本文是清华“牛仔”王垠的“成名作”，在网上引起很大的争议。对他崇拜
地五体投地者有，对他嗤之以鼻者也有，总之成了一年多以前Linux

爱好者的圈子里的一个很有意思的现象。之后他对这篇文章进行了很大的修改，
已经没有了原来那种意气风发。现存的版本如白开水一般无味，请参见：
[[http://learn.tsinghua.edu.cn/homepage/2001315450/]]


尽管他原来的观点有所偏激，但我还是很欣赏他原来的风格。

***** “UNIX 是简单的，你不需要成为天才也能理解这种简单。”

由于GNU/Linux这个词太长，下面如果没有特别指明，“Linux”就是指“GNU/Linux”。

在这个年代，恐怕没有人需要我来介绍 Linux 是什么了吧？如果你觉得“Linux
只不过是跟 DOS
差不多的东西”，那你恐怕很久在山洞里没见天日了吧？请问问你旁边的 Linux
用户，Linux 到底是个什么地位？

那为什么我还要写一篇这样的文章？因为，我发现还有很多人不不理解 Linux 和
UNIX，虽然他们也在用它，但是他们有时会问：“为什么 Linux 不能像 Windows
那样 ......？”，“怎么Redhat Linux不能 mount NTFS
分区！”，“Linux下用什么整理硬盘？”，“什么时候OpenOffice才能完全兼容Word文件啊？”，“现在还有什么Windows能干的事情Linux干不了的？”......

他们有40G的硬盘，却只为 Linux
分配了2G空间，有时还抱怨“这个东西怎么占这么多硬盘！” 似乎
Windows该占用大部分硬盘。他们把重要的数据装在Windows的分区，似乎信不过
Linux。他们总是到处寻找新奇的，好看的GUI程序，对命令行的东西一概不屑一顾。他们对Drag&Drop，菜单配置，自动升级非常感兴趣。他们如果找到一个很像
Windows 程序的 Linux 程序，一定会很高兴的说：“哈哈！Linux
也能......了！”
如果Linux在某种测试中胜过Windows，他们会高兴得跳起来。他们没有办法用Linux解决问题的时候，甚至用Wine来运行Windows程序。有时实在没办法，只好重起到
Windows，或者干脆省得麻烦，在 Windows 下装一个 VMWare 虚拟一个 Linux
玩。

你支持 Linux，你喜欢
Linux，你能从中感觉到快乐，这非常好。你现在只需要明白的是：Linux
从来就不是一个玩具，它是天才UNIX的后代。UNIX
是自晶体管发明以来最伟大的发明，它从诞生那一天开始就比 Windows
的设计出色。Linux 并不需要追赶
Windows，不需要打垮微软，它的最终目标是改变整个计算机世界，还人们自由，给人们乐趣和方便。其它UNIX很多都已经败在Linux脚下，更何况
Windows！

你如果出现了以上的情况，说明你的思想受到了 Windows
的某种潜移默化的影响和误导。你没有能够从本质上理解存在于 Linux 身上的
UNIX 思想。UNIX的设计者 Dennis Ritchie 说：“Unix is simple. It just
takes a genius to understand its simplicity.”
但是我不这么认为，因为我不是一个天才，但是我却勇敢的把Windows完全删除掉，半年之后我体会到了
UNIX 的思想和好处。因为我相信这样的信念：“Windows 能办到的事 Linux
一定能办到，而且办的更好。”

这小节开头的话应该改成：“Unix 是简单的，但是在这个冲斥着 Windows
错误观念的世界，你需要信念和勇气才能理解它的简单！”
我下面就告诉你一些我理解到的东西。

***** 微软的地位

微软的名声在欧洲和美国的大学里，特别是在计算机系里之坏，大家可能有所耳闻。我认识的
MIT，Stanford
的教授，贝尔实验室的专家，甚至一个欧洲小国的高中计算机老师都绝口不提微软的名字。在他们眼里，微软只是一个没有真技术，专靠在落后国家商业宣传和垄断经营的小公司。这个“小”并不是说它人少，钱少，而是说它先进技术少。

我上次和王益合作写了一个算法演示程序，那个算法是贝尔实验室一位科学家Steven
Fortune很天才的发明，为了程序能够被身边大多数人使用，我们选择了 VC+MFC
作为平台。我在分析算法时还得到 Fortune
很热情的鼓励，寄给我一份资料，还多次回信耐心的给我讲解了很多细节。但是程序完成之后，我把样品发给
Fortune，他回信说：“对不起。我机器上没有 MFC。”
话说的很客气，但是我已经感觉到了他对 Windows 的不屑。然后我把 MFC
静态编译进程序再发给他，他就没有再回信了。他显然不是瞧不起我，而是确实有难处。

你能感觉到这位科学家对微软和 Windows
是什么态度了吧？不是反感，而是他心里根本没有 Windows
这个东西！微软在高科技领域没有发展，那么它怎么生存呢？到发展中国家去发展一下，他们的人民还对电脑一无所知，我说不定甚至可以打入大学的计算机系呢。我送他们软件，我捐钱盖大楼，我出钱找图灵奖获得者来演讲，让他们觉得我们都是科学家！

好了，现在全国的大学包括清华，几乎所有人机器必装盗版 Win2000，Office
XP，学校的选课系统是非IE不能正确浏览，论文用 Word
编辑，演示用ppt做，email 的通知附件是 doc 文件，你不用 Word 打不开，连
863 项目都用 VC
写程序了。我很久以前就看到一份报纸说，“微软为什么不严厉打击盗版？”
这篇文章说，微软非但不打击中国的盗版行为，而且有放任之趋势。放长线吊大鱼，“以后我要你们加倍的来还我！”
确实如此，它的目的快实现了。

***** Windows 笼罩下的中国计算机教育

说句丢脸的话，比尔盖茨很久以前是我的偶像...... //blush

在中国，比尔盖茨被很多人奉为神圣，“少年电脑天才”，甚至有的人提到他的名字就做出“抱拳对天”的姿势。很多人谈到微软的“新技术”，“高科技”
都是眉飞色舞。各种“VC编程圣经”，“深入了解 Visual
C++”之类的书，在开头几页都会出现非常肉麻的字眼，“在那团团的混沌中，一个开天辟地的精灵，Windows
1.0，诞生了......”

微软的软件被这么多人盗用，那么人们是怎样使用这些盗版程序的呢？先看看电脑培训班，教的都是一些
DOS 命令，打字，Windows 基本操作，Word
文档处理，PowerPoint，高级班可能有 Excel，Access......
参加各种微软认证考试，MCSE，MSDE
的人络绎不绝。考试辅导班都贴出了“280元，考过为止”之类的字样。考试参考资料更是昂贵，有些电脑书店整整两书架都是“Microsoft
Press”的东西。我有个同学参加认证考试，每门考试都要200多元。而且你一次考不过可以再考，又要交钱。他后来还津津乐道跟我说，看我，花了XXXX(一个四位数)元考过了微软认证，得到一张比尔盖茨亲笔签名的证书和价值6000元的
Windows XP 内部发行版。

“电脑要从娃娃抓起”，我们再来看看娃娃们学的是什么。大部分家长给孩子买了电脑之后，他们首先就会装一个盗版的
Windows，然后买来盗版的游戏开始玩。如果哪个孩子会用 Delphi
编程序，那可不得了。报社记者，电视台争相报导，说，某某学校的初中生某某，在别人都还在玩电脑游戏这种“初级阶段”的时候就已经用
Delphi 写程序了。镜头还瞄准了他显示器上面的像框中的比尔盖茨头像！

我刚进入大学计算机系时还不懂得什么是操作系统，因为我以前只用过“中华学习机”。看到新入学的同学们各个谈论的都是
“Windows 95”，“VC”......
我简直觉得我落后了好几十年一样，整个一土人，根本跟他们答不上话。好不容易找到一个比较熟的同学问了一下：“你们天天谈论的瘟95是什么啊？”答：“win95就是一个操作系统，跟DOS是一类。”“朵死是什么？”
“你连DOS都不知道是什么？别在计算机系混了。”
学校上课当然不讲VC编程之类的东西，但是上 Pascal
的老师有一次就说：“嗨，我们学校真是落后。现在别人都用 C, C++，甚至 VC
了，我们还在讲
Pascal。不知道什么时候才能有VC课啊。你们出去也是要用VC的，只好自学了。”
于是，有些同学很多时候上课都捧着一本很重的“Windows
编程大全”之类的书，根本没有听课。吃饭时就念念有词的跟我说，“代码的优化是无止境的”，“匈牙利命名法真是伟大的发明”
...... 这就是中国很多大学计算机系的情况。

感觉到无知了？这不是偶然的，而是微软长久以来埋下的伏笔。它要让无知的大家都把它奉为神圣，它要让支持UNIX，Xwindow的人一旦说
UNIX 好，Xwindow 好的时候，都被一群人围着说教：“这个 Windows
也能做到”，“你对 Windows 有偏见”，“微软才是主流啊”，“你敢瞧不起
win2k？”，“.NET
就是世界潮流”，“微软的毕竟是新技术”，“有钱就是有技术”......
甚至在一番论战比较后败下来还是要说：“Windows
性能差点，但是易用性强”，“Windows
是老百姓用的，要求别那么高”，“微软那么有钱，以后想超过 UNIX
还不容易吗？”......

***** 发达国家的计算机教育

我前段时间在 USENET 发文问有关 Scheme
语言的问题时，认识了一位丹麦人。他解决了我所有的问题，并且建议我阅读一些很“深奥”的有关程序语言语法，文法的书，他告诉我很多网站可以学习
LISP，Scheme，人工智能，算法。他叫我看 Jonathan Rees 的论文 "Syntactic
Closures"。他还打包给我寄过来一份 MIT 的 "How to Design
Programs"。他说他在自己的 PC 机上装的是 Linux，他用 Emacs 编辑，运行
Scheme 程序。他对 Emacs
的了解和爱好真是使人惊讶。他大学本科毕业时做的毕业设计是一个 Scheme
解释器。这对于我来说是望尘末及了。

他是那么的不厌其烦，我的每一个问题他都详细的回答。我有时都觉得过于详细了，怎么这么耐心啊？我觉得他似乎是我的高中老师。他是什么样的人呢？我好奇的打听了他的情况。原来，她是丹麦一所普通高中的计算机老师，而且是个女老师！

她说她在高中里讲授程序设计和算法，计算机语言文法。她说用
Scheme，她的学生不用再为内存泄漏等程序语言本身的问题而烦恼，而专注于问题和算法本身。有利于培养学生解决问题的能力，特别是用计算机解决数学问题的能力。

天哪！为什么欧洲出现那么多数学家，几何学家？你看看别人重视的是什么！我们的计算机教育如果继续这样下去，只会沿着弯路越走越远！

***** 微软和它的朋友们的如意算盘

下面来看看微软的收入是怎么来的。首先，Windows 98系列操作系统，一个就是
100 多美元，每次升级又是几乎同样的价钱。Windows NT
还要贵几倍，而且有用户数目限制，5个用户的，10个用户的......
以后如果要增加用户数目还要按比例付钱。这个奇怪的现象被通用汽车公司的总裁比喻为：“你买的微软牌汽车最开头只有一个座位，每加一个座位你得向汽车公司付钱，每开100英里要大修一次，每过一年要换一次引擎。”

花了如此多钱买来的操作系统就能用了吗？它竟然连压缩程序都没有提供！你装上
Windows 之后一般第一件事就是去下载一个 WinZip 吧，“只要 29
美元”。Windows 会中病毒啊，马上花 70 美元买一个 Norton AntiVirus
吧。还有黑客呢？再买一个 Norton Internet Security 好了，100
美元。系统需要优化，磁盘需要整理，买一个 Norton System Works
是你最佳的解决方案，100美元。

可是你现在还是不能干正事啊！你想要一个 Word, PowerPoint？那就买一套
Office XP 吧，一起买便宜些，9.90。

那些程序不会用啊！那些菜单怎么设置，到底有什么功能啊？看“帮助”也学不会。买本书看看吧，我推荐“Special
Edition Using Microsoft Office
XP”，不贵，.99。这本书里面大部分是屏幕抓图，还是买一本旧的比较划算，.85。

你如果只是当个秘书，上面的差不多还凑合了。可是你有更高的追求，你想成为
Windows 程序员。首先买一个 Visual Studio.NET
吧，要不然怎么编译程序。4.95。

为了紧跟微软动向，世界潮流，不能不注册个 MSDN
什么的吧？这个贵一点，不过物有所值啊，,799。

嗯，你现在已经是上层阶级，白领人士了。你现在可以像这样“自由”的，“安全”的生活了：

***** 什么是 Windows 能干而 Linux 干不了的事情？

“Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”

有个朋友看我半年没有用 Windows，有时就会问我：“你只用
Linux，有没有发现有些 Windows 能处理的事情 Linux 干不了？”

我回答说：“Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”

Windows 能做的有益的事情 Linux 都能做

Windows 下的某些功能确实是我们需要的，那么 Linux
的开发者们和用户也需要这种功能，他们就会去实现这种功能，而且比Windows
的方式好得多。由于大多数科学家，工程师用的都是 Linux 或者某种商业 UNIX,
所以几乎所有商业的科学工程程序，比如Matlab, Mathematica, AutoCAD,
Candence的，Synopsys的，Avant! 的......全都是先有 UNIX
的版本(包括Linux)，然后再考虑移植给 Windows，甚至根本不移植给
Windows，因为 Windows
的机器一般没有足够的能力运行这样的程序。你不要以为只有 Windows 才有
PSpice, UNIX 的 HSpice
要好得多，而且可以运行在大型主机上。当然它们不是免费的，但是它们值那个价钱。

但是 Windows 下有些东西在 Linux
下没有很相似的，或者你找到很多类似的，但是它们每一个比起 Windows
的那个程序都要差很多，那么原因有两种可能性：

1. 有一个完全类似的程序，但是由于它乍一看不漂亮，被你忽略了。

而其它程序虽然看起来很漂亮，但是它们是一些初学编程的人写的。现在由于
Gtk+, Qt 的诞生，Linux
下开发图形界面程序极其简单，很多初中生甚至小学生都可以随手编出一些漂亮不中用的程序。如果你整天寻找这样的程序挑来挑去，永远也找不到你满意的。

我曾经也犯过这样的错误，优秀的 FVWM, lftp, Mutt, wget
都被我忽略过！当我找回它们的时候，我是那么的羞愧不已，它们现在都是我的朋友
:) 用这些程序你可以改变它们的一切，我第一次看到 FVWM
觉得它只不过是一个有很厚很难看边框的东西。可是现在，我的同学看到 FVWM
都说：“哇！真漂亮。”

2. 有另一种完全不同的方式可以达到相同的目的，甚至更好。

很多人很关心 Open Office, Star Office, AbiWord, ...
他们多么盼望有一天某一个 Linux 程序能够完全兼容的打开一个复杂的 doc
文档。但是你永远也不可能有那一天。为什么呢？因为微软为了占有市场，必定不会让其它系统的程序能够完全兼容它的文档格式！它一定会不断变化
doc 文档的内部结构，隐藏一些秘密，让其它公司的程序打开 doc
文档时总是有某种问题，从而你必需购买 Microsoft Office 和Windows。

你应该想一下，那么多的高智商的大学教授，科学家，学生，他们用的都是
Linux 或者其它类型的 UNIX，他们没有 Word
可用，怎么处理文档呢？这么多年没有一个像 Open Office
的程序出现，难道大家没有办法写文档吗？

显然不是这样。你看看那些高水平的学术杂志，论文，那些大学教授的网页，那些漂亮的PDF幻灯片，它们是什么做的？原来
UNIX 用户早就有非常方便的 troff, LaTeX, SGML
等东西可以处理文档，而且它们比起 Word 都要高明的多。Word
显然被这些大拿忽略了，以至于很久以来没有人想在 Linux 下开发一个类似 Word
的程序，除非某些公司想抢微软的饭碗。

很多人留着 Windows 在硬盘上的原因无非是为了用 Word 和
PowerPoint。你待会儿可以看看我的TeX网页，你就会知道为什么我可以完全离开
Windows.

***** Windows 能做的那些没用的事情 Linux 永远做不好

1. 电脑游戏

有些人说 Linux 下不能玩 Windows 下所能得到的所有游戏。的确，Linux
下虽然也有少量的游戏，比如 Quake。但是它没有 Counter Strike, 没有 Star
Craft, ......

并不是说电脑游戏不该玩，但是应该适可而止。电脑是用来处理事务，帮助你学习，解决问题的工具，而不是一个玩具！整天沉迷于电脑游戏中，而不出去感觉外面的世界，你会变得越来越冷酷，越来越缺乏人情味。你与真实的世界越来越远。

你可以在 CS 里杀人，你可以在 Tomb Raider 里探险，你甚至可以在 Tony
Hawk's Pro Skaters 里滑板...... 但是 It's not
real！你虽然有很高的“反恐技巧”，但是遇到歹徒的时候，你是那么的怯懦；你虽然控制
Laura 伸手敏捷，但是你打篮球的时候怎么总是被人断球？你虽然可以轻易的在
THPS 里作出一个 "360 kickflip to hangten grind to
fakie"，但是你踩在自己的滑板上的时候还不会 ollie！

说回来，如果你偶尔玩一下电脑游戏未尝不可。但是世界上有远比 Windows
+ PC 更好的游戏方式。Sony 的 PlayStation2, SEGA 的 DreamCast, Nintendo
的 N64，Namco 的街机......每一个都比 Windows
游戏精彩，每一个都有如此高的3D性能，以至于 Pentium4, Itanium + GForce4
都无法与它们比美！

Linux
的用户们都是关心解决世界的关键问题的份子，他们哪里有时间用自己的机器来玩游戏啊？他们每天用Linux高效的做完自己的工作就到阳光下享受自然去了。要玩游戏也是玩一些类似推箱子，贪吃蛇之类的智力小游戏。所以，你知道为什么
Linux 几乎没有游戏了吧？:)

2. “整理硬盘，优化系统”

这是一个非常有意思的话题，仅次于有关“病毒”的话题。相信很多 Windows
用户都有整理硬盘的经历。在很多 Windows
用户眼里，“硬盘用久了，会出现碎片，速度会减慢，需要一个程序来整理，整理硬盘的时候不要做其它工作”，这好像是天经地义的事情。

我也曾经津津有味的看着 Norton Defrag
一点一点的把我的硬盘排序，调整，用图形的方式显示出来，然后报告：“100%
没有碎片。你的硬盘现在已经达到最佳状态。”
我现在才发觉我那时是多么的幼稚。

Linux 和 UNIX
用户似乎从来没有“整理硬盘”这种说法呢？你觉得很奇怪吗？如果你觉得很奇怪，那说明你的思想在某种程度上被微软的垃圾程序禁锢了。你需要明白，UNIX
的大型主机很多必须是一天24小时，一年365又1/4天不停运转的，要是每个星期都要整理一次硬盘，在整理的时候几乎不能干任何事情，那是绝对行不通的！

Linux 机器根本不用整理硬盘，这就是为什么没有看到过 Linux
用户整理硬盘。Linux 的文件系统是比 Windows 的 FAT, FAT32, NTFS
高明得多的文件系统，它们不但可以对文件设置权限，实施完全的保护，而且可以“越用越整齐”，“越用碎片越少”！你应该把文件大部分放在
Linux 的分区，而不是 Windows 分区，因为它比 Windows 分区可靠得多。

还有更滑稽的事情就是有很多“Norton System Doctor”，“Windows
优化大师”，“超级兔仔注册表魔法”
之类的程序存在，而且价格昂贵。似乎一个操作系统本来应该有很多问题，需要别的厂商做程序来“优化”它，而且为了得到优化，你需要付钱！这些问题
Linux 根本就没有，所以不需要什么优化。Linux 内核本身就是高度优化的。

3. IDE

有些人在抱怨为什么 Linux 没有一个良好的 IDE 开发环境。Linux
现在已经有一些 IDE 了，但是总是有很多问题。你是不是正在寻找，正在期望
Linux
某一天可以有一个VC那样的开发环境？你有没有发现你正在进入微软给你设下的怪圈？你为什么一定要用
IDE？你说：“IDE 开发迅速，调试方便，适合大型程序......”
那说明微软的程序在你脑子里已经比较根深蒂固，你需要好好清醒一下了，看看我来告诉你。

高明的 UNIX 程序员不用 IDE，IDE 从来就是给初级 Windows 程序员用的。

你看看大型的 UNIX 程序，包括 Linux 内核，各种网络服务程序，Xwindow
程序在内，哪一个是 IDE 搞出来的？我们实验室的 EDA 程序也没有一个是 IDE
弄的，我还知道 Candence, Synopsys，Mentor 的高性能的图形界面 EDA
程序也都不是 IDE 写的。你信不信，微软的人在写 Windows
本身的时候也根本不用 IDE！

有一次某杂志采访一些出名的 Linux 内核程序员，包括 Linus
在内，没有一个人用 IDE，有的人用 VIM，有的用 Emacs，只有 Linus 说“GNU
Emacs is evil”，但是其实他用的是一种跟 Emacs 有同样键绑定功能的
MicroEmacs。大家都是用编辑器编辑了程序文件，然后用 make
这样的自动工具调用 gcc 编译器完成编译工作的。

我以前也编过 Windows 程序：应用程序，驱动程序。但是我没有用 VC 的
IDE。Linux 教育了我，我会在命令行调用 CL，我知道 CL 才是 VC
的编译器。我可以在 cygwin 的 Makefile 里使用 CL。我还知道 CL
的参数都有什么用处。但是这些不是一个从一开头就用 IDE
的人能很快理解到的。

我相信: IDE is evil。我有一些用 Windows 的 IDE
写程序的朋友，他们对那套东西已经很精通了。但是我却惊奇的发现，他们竟然把编译器和汇编器的概念都分不清楚，甚至有的人连“编辑器”和“编译器”都搞混淆了！他们只知道在一个窗口里输入了代码，点击一个按钮就可以编译程序，但是这里面到底是怎么工作的，他们不知道！他们被盖在上面的窗口挡住了视线，甚至会以为那个按钮就是编译器！

他们对那些 IDE
的热键背的滚瓜烂熟，但是我却看到他们在一个函数一个函数的把别人的 ANSI
风格的代码变成 VC 的风格。想想这件事在 VIM
里有多么简单，一瞬间就可以搞定。

为什么 UNIX 程序员不用 IDE？明白了这个道理你就能体会到 UNIX
的设计思想了。首先，一个 IDE
集成了编辑器，编译器，汇编器，调试器，跟踪器......
这个编辑器功能肯定比不上 VIM 或 Emacs，编译器比不上 GCC，汇编器比不上
as，调试器比不上 gdb, ddd, 跟踪器比不上 strace, ltrace,
truss。你得到的是一套整合的低能的程序。如果你对调试器的功能不满意，你只好换用另外一套
IDE，但是这套 IDE 的热键，菜单，编辑器功能，按钮......
跟原来那个有很大不同。你不得不花很多时间来熟悉新的环境，而不能保持原来的某些东西。

而在 UNIX 下就不一样了。你可以用你最喜欢的 VIM 编辑程序，你在 VIM
里可以调用 GNU make，make 可以调用 gcc, ld, ... 实际上 make
能帮你很多忙。make 的出错信息可以被 VIM 捕获，VIM
能帮你在源程序里定位。你如果喜欢 icc, 你可以让 make 用 icc 而不是
gcc。你如果觉得 gdb 跟踪变量时比较麻烦，你可以用 ddd
来显示各种数据结构之间的关系。你还可以在 Emacs 里调用
gdb，那样就可以同步显示源代码了。而且 VIM 和 Emacs
还可以编辑很多其它东西，比如信件，LaTeX 文档，HTML，配置文件......
你不用另外找一个什么编辑器来干这些杂活了。很多程序比如 Mutt, tin
都可以在内部使用 VIM，这样就更方便了。

4. 释放内存

我在 Windows
下做过的一件最傻的事情莫过于“释放内存”了。有一天我看到一个 Windows
程序说：“这个程序可以帮你把大量内存释放出来给一个很大的程序用。”我试了一下，居然一下把我的
64M 内存释放出来
48M！我高兴极了。现在想一想，那是多么傻的事情，那么多的内存留着干什么？不用白不用啊！一个操作系统，居然还需要别人写的程序来释放内存，那是什么样的操作系统？

在 Linux 下用 free
命令，你会发现你的内存几乎每时每刻都快要被用完。那是因为 Linux
把大部分内存用来作为磁盘缓冲了。Linux 有比 Windows
先进的磁盘缓冲技术。你有没有发现你往硬盘写数据的时候，很快就完成了？那是因为
Linux
在内存里有很多磁盘缓冲区，你要写到硬盘上的数据先被写到了这些内存里，然后
Linux 就告诉你“拷贝完成”，当你马上又想删除刚才写入的某些数据时，Linux
只是把数据从内存里移除，然后报告“删除完成”。在一定的间隔时间后，Linux
才把数据写回硬盘，这样不但高效，避免了多次硬盘操作，而且减少了文件的不连续，也就是减少了“碎片”。Windows
当然也有磁盘缓冲，但是由于它内存管理的低效率，它不敢把大量内存都用来作为磁盘缓冲，因为它没有能力在用的时候随时把内存收回来。

***** Linux 能干的高级的事情 Windows 都干不了

当然有很多事情是Linux/UNIX的专利了。因为 Windows 只能装在 PC
机上，好像以前也有 Alpha 可以使用 Windows NT，但是就是没见到有人用。PC
机的能力是很低的，像我们编程序处理 NP-Hard 问题的人，用 Windows
的机器显然速度不够，而且有时一个问题算上几天甚至几个星期，Windows
机器是以“死机”著称的，我们怎么能放心？

所以几乎所有科学计算程序，EDA 程序，高性能图像处理程序都不是 Windows
的。他们有时也会移植一些给 Windows，但是常常降低那些程序的能力。你比较过
Windows 版本的 Mathematica 和 Linux 的有什么区别吗？

IBM 制造的最大的并行计算机有 8000 多个处理器，Windows
不可能有能力管理这么多处理器，它用的是什么操作系统？答案是 Linux。

《[[http://fifid.com/site_search?cx=003017831450918707819%3Ae2pgfm8nybw&cof=FORID%3A10&ie=UTF-8&q=%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7][泰坦尼克号]]》电影里的三维动画，那么细腻逼真，Windows机器能做出来吗？不行。那也是
Linux 机器做的。

民航总局用来训练地情人员的虚拟现实训练设备，Windows
当然无能为力。那都是商业的 IRIX 机器。

UNIX 是最早支持 TCP/IP
网络协议的系统。它上面有很多可以互相协作的网络服务程序，它们经过多年的使用和修订，已经达到比较完善的程度。而就在1997年，微软的比尔盖茨还在扬言：“Internet
是没有前途的。”
微软的这个“远见卓识”大家应该都已见识，它后来加上的网络服务程序IIS漏洞之多，让公安部都频频发出警报，大家也是见识了的。

其实你知道了，Windows 没有一样有用的事情能比 UNIX 干的更好。

***** Linux 干不了的有用的事情 Windows 照样干不了

当然 Linux 不是万能的。它也有不能干的事情，电脑也有干不了的事情。但是
Linux 干不了的事情，Windows
肯定也干不了。这些事情就是我们需要探索，需要努力的事情了。在你探索的过程中，Linux
必定是你的好伙伴。

Windows 的流毒

不要用 Windows 的方式来思考问题

什么？你早就知道 Windows
是垃圾？噢！你怎么不早说呢！害我废话这么多。嘿嘿。

“好了。你知道 Windows 是垃圾，你现在用什么？”

“Linux + Xwindow”

“那我问你，Xwindow 是什么样的？”

“不就是跟 Windows 差不多吗？只不过 'Start' 按钮比较方，而且上面不是一个
Windows
标志，而是一个脚丫子。点击一下居然还有很漂亮的中文菜单。我喜欢！”

“你知道什么是‘根窗口'吗？”

“不知道。从来没听说过呢？”

“根窗口就是遮盖整个屏幕的那个最大的窗口。”

“哪儿有什么窗口啊！我没有看到呢？”

你发现了问题吗？这些 Linux 用户说是在用 Linux 和 Xwindow，但是他们对
Linux 和 Xwindow 几乎完全不了解。很多人用了那么久 Xwindow
都不知道根窗口是什么东西，不知道其实按钮也是窗口，不知道窗口管理器和
Gnome，KDE
有什么关系，大家都以为窗口上面的按钮是程序自己放上去的，不知道窗口的“class
name”，“resource name”是什么东西。他们被遮在 Linux
之上的一层一层的包装迷惑了！

当我告诉一个既能用 Windows 又能用 Linux Qt 编程的朋友 Xwindow
的“中键粘贴”是怎么回事时，他大吃一惊，说：“Xwindow
怎么这么落后啊！居然请求剪贴板的东西时还要联系剪贴内容的所有者自己来转换格式！你看看
Windows 的剪贴板......” 经过一顿饭的友好的讨论之后，他不得不称认，这个
Xwindow 用了几十年的方法比 Windows 的剪贴板要合理的多。

后来又有一次，我告诉他每个 Xwindow 的按钮都是一个窗口。他说：“不会吧～
这样效率一定很低。你看看 Windows 的按钮 ......”
又是一顿饭之后，他说：“哎呀。不得不承认 Xwindow 的方式是良好的设计。”

现在很多人已经把能够利用别人的库写出一个好看的程序作为自己编程水平的象征。在这个“图形化”，“可视化”
的年代，你如果还在用 troff, LaTeX 写文档，你还在用 VIM 自己编辑 HTML，用
Mutt 处理邮件，你还在用文本模式的 gdb 调试程序，你还在用 Xlib 写程序,
你还在用 tin 上 USENET，你还在自己写 Makefile，写机器代码，你还在玩
Clossal Cave 这样的字符模式冒险游戏，那你就是老古董，不合时宜，变态。

其实这种思想是错误的。虽然你是一个坚决的 Linux 支持者，但是你的思想是
Windows
的思想。你认为图形界面，菜单，按钮就可以解决一切问题，就可以给你高效方便。你要做坚决的
GUI 派而不是 CLI 派 ......
你还是没能摆脱微软给你的潜移默化的东西。你其实离不开 Windows
那样的环境，你害怕符号，你迟早会删掉自己的 Linux。

***** GUI vs. CLI

UNIX 和 Xwindow 是一家

大家看到这个标题是不是热血沸腾？两派大虾都可以围攻我了：

GUI派用户：“哇！我一看你这小子就是 CLI 的。要不然自己写什么
Makefile？用什么 Mutt？”

CLI派用户：“切～ 你还用 X！高手都不用 X。你是 GUI 那边的。”

可怜的我：“555～～你们都不要我～～ GUI 和 CLI 就那么水火不容吗？”

计算机界这样的门派之分还很多。很有特点的就是 CLI 和 GUI 了。CLI (Command
LIne) 的狂热份子声称永远不用 X。我上次在实验室看到一个同学用一个
SecureCRT 登录到 Sun 机器，然后用一个 vanilla vi
编辑程序，我建议他启动一个 GVIM 过来显示在 Exceed
上可以有语法加亮。但是他坚决反对，说：“高手不用X。你想想，要是我在一个很慢的网络连接怎么用
X？而且好多服务器没有装 X 程序。”

但是我们实验室的网速可够快，Windows 机器都有 Exceed 啊，而且 Sun
机器有全套 X 客户程序包括 GVIM。他说他是 CLI 的坚决拥护者，但是他却在用
Windows，他后来打开了好几个
SecureCRT，每次从文本框输入地址，用户名和密码，从下拉菜单选择
"SSH2"，然后点击“Connnect”。他还不断的夸SecureCRT是“网络管理员投票选出的最受欢迎的登录方式”。老天，SecureCRT
本身就是个 GUI 啊，他其实是一个 GUI。

你说我是 GUI 的？我虽然很少在 console 下工作。但是我对 bash, VIM
很熟悉，我可以让 bash 按照我的键绑定方式来工作。我可以在 rxvt 里使用
Mutt 来收发 email。我的每个桌面上都常常堆放着一打不同大小的 rxvt。我用
VIM 编辑 LaTeX。我自己写 Makefile 来维护 LaTeX 文档。我有时用 mpg321
来放 mp3。我上BBS用的我自己写的 expect 脚本，定义了很多热键，我只要
Ctrl-H 就可以随机变化我的签名档和说明档。我的 expect
脚本有高级的自动回复功能，甚至可以以假乱真，让你看不出其实我不在，你有可能跟我的机器人聊上10分种才发现那不是我
:p 好了，CLI 派的朋友可以收我做盟友了 :)

你说我是 CLI 的老古董？我的 FVWM
被我配置为可以“手写操作”，我只要画一个"r"就可以启动 rxvt，我只要画一个
"U" 就可以启动 GVIM，...... 我用 GVIM 语法加亮模式编辑程序，我用 Mozilla
浏览网页，...... GUI 派的现在好像认我做朋友了 :)

好了。CLI
派的朋友，虽然我很喜欢命令行，但是我有时在屏幕上左右画一下就可以执行:

Module FvwmConsole -terminal rxvt -geometry 45x5-0+0 \

-bg gold -fg midnightblue \

-fn "-adobe-courier-medium-r-*-*-14-*-*-*-*-*-*-*"

你是不是现在又想把我逐出师门？

GUI 派的朋友，虽然我很喜欢窗口。但是我可以在 FvwmConsole 里输入：

All (rxvt) MoveToDesk

把我所有的 rxvt 移动到我现在工作的桌面。“这家伙，怎么这么快就叛变了！”

其实何必分什么 GUI 和 CLI，UNIX 和 Xwindow
都是工业标准，它们从设计那天开始就有非常灵活的用法，各个程序，不管是 GUI
还是命令行的都可以互相协作。UNIX 和 X
是一家，何必搞的那么偏激，非此即彼？你从我上面的行为可以看出 GUI 和 CLI
的模糊界线吗？你说我是“花心大萝卜”？花心就花心。hengheng :P

UNIX 的真谛何在？

***** 让聪明人干任何他们想干的事情。

UNIX 的一个特点就是非常高的灵活性，Xwindow
也具有这种灵活性。这种灵活性体现在哪里呢？

UNIX
的程序一般都有很多参数，不管你现在用的着用不着，总有人需要某些参数。它们的行为很多都可以用配置文件来改变。比如
GNU bash, 通常缺省的命令行输入方式是 Emacs 方式，但是只要我编辑一个
.inputrc 文件，就可以把它变成 vi
的输入方式，而且我还可以自己绑定键序列到某些操作。我可以用 shopt
来设置它的很多特点，比如是否进行通配符扩展，是否可以把一个变量当作一个目录来cd，是否可以自动纠正某些明显的目录名打字错误
......

UNIX
程序设计的思想是提供给用户“机制”，而不限制用户制定“政策”。这是一个重要的尊重用户的作法。

我们再来看看 Xwindow。Xwindow
是一个出色的设计，它把显示服务器和客户程序分开。一个显示上既可以显示本机上的程序，也可以显示别的机器上的
X
程序，而它们都遵守你的窗口管理器的统一指挥，它们之间可以方便的传送剪贴版数据，各种事件
...... 比如有时我的 XFree86 上会出现四个不同机器上的
XTerm，两个不同机器上的 GVIM，...... 它们统一受本机上的 FVWM 指挥。

Xwindow 程序都具有很多很多命令行参数和 resource
参数。你可以随意的在命令行或者 .Xdefaults
文件设置所有的颜色，字体，尺寸...... 而且如果你用 xrdb 把 .Xdefaults
导入到根窗口，那么其它机器上没有经过配置的同样的程序，显示到你的机器上的时候也会遵守同样的外观规定。

Xwindow 的窗口具有 Property,
也就是一些可以自己定义的共享数据(原子)。正是因为这些 Property
的存在，使得 Xwindow 具有无比强大的生命力。X
的窗口管理器和其它客户程序之间并没有统一的协议，但是后来出现了
ICCCM(客户程序间通信规范)，这个规范就是通过 property
定义的。现在又有人定义了一套“扩展的窗口协议(EWM Hints)”，使得 Xwindow
可以具有某些 Windows
的特征，比如一个工具条程序可以告诉窗口管理器：“这个屏幕下面被我占据了24个像素的空间，你最大化程序的时候不要越过这个界线。”

一个强大的窗口管理程序比如
FVWM，它收到这样的提示时，可以答应工具条程序的这个要求，也可以不答应。一切选择的权力在于谁？当然是用户了！一切窗口乖乖听话，FVWM
给予用户最大的尊重。

你想想，是不是有些 Windows 程序常常弹出一个窗口要你选择 "Yes or
No"？你不点击它它就不下去。你觉不觉得你的程序在侵犯你的尊严？你是一个人，一个智慧的生物，怎能受到一个程序如此的待遇？

还有就是很多 Windows
程序把人当成傻瓜，而它是“智能程序”。比如，有一个程序就是喜欢把你的每句话第一个字母都变成大写，我不说它是谁了，你遇到的时候就知道了。如果连“一句话开头一个字母要大写”这么明显的问题都需要程序帮你纠正的话，人脑还用来干什么？况且如果你故意想要不大写的话，那就更麻烦了，我楞是没有从它那一大堆菜单里找到怎么关闭这个愚蠢的选项。

***** 只有符号才能完全操纵计算机。

我们来说说很多初学 Linux 的用户。虽然他们在用
Linux，但是他们打心眼儿里是觉得 Windows 的工作方式好，他们希望 Linux
有一天能“像Windows那样”。你说：“我鼠标一点，我菜单一拉，......
就可以完成我的操作。” 但是我要告诉你：“Linux 从来没有摹仿
Windows，将来也不会。Linux 从诞生之日起，它的工作方式就比 Windows
的先进。Linux 属于能勇敢面对符号的人。只有符号才能完全操纵计算机。”

看看优秀的 UNIX 程序，XFree86, FVWM, VIM, Emacs, proftpd, Mutt, wget,
tin, ...
没有一个不是用配置文件来设置选项的。为什么这些程序没有方便的菜单可以用来配置？难道它们的设计者就那么低能，连个图形配置界面也写不出来？

当然不是。因为图形界面配置方式的能力是极其有限的，而配置文件和程序语言的表达能力却是无限的。用图形界面配置这些程序的话，如果你想达到配置文件的效果，你需要成百上千的菜单，checkbox,
radio button, ...
到时候你根本没办法找到你需要修改的地方了！而各个程序的配置文件的语法都有很多相似之处，一般就是一些命令，设置一些变量，参数，......
一旦用会了一个，其它的也就容易理解了。如果你用惯了 awk, sed,
Perl，你会觉得那才是真正的自动化啊。

鼠标虽然是很好的工具，但是它的表达能力是有限的。你不可能光用鼠标就让电脑完全明白你的意思，它毕竟只有3个按钮。看看我的MetaPost页你就能体会到鼠标的这一弱点。所以我们虽然很喜欢鼠标，但是却不能完全依赖它。

***** 各个小程序的完美配合

这就是UNIX最重要的特点了，它就是UNIX设计的思想。让每个程序只具有一项专门的能力，然后让它们合作。Xwindow也继承了这种好传统。

这恐怕就是Windows和其它操作系统望尘末及的地方了。UNIX
程序设计之统一，配合之完美，真使我难以置信！shell, grep, find, awk, sed,
make, Perl, Emacs, vi, tin, Mutt, ...
它们是那么的具有一致性！你一旦学会了 sed
的正则表达式，其它程序基本上都能用了。你一旦学会了 vi 和 VIM,
你会发现它的操作是那么的有规律性，似乎vi的设计者在几十年前就已经设计好了
VIM 在今天的完美而统一的操作方式！而且vi的操作还体现在 Mutt, tin
等很多程序中。你甚至可以把 bash 设置为 vi
的输入方式来输入命令行，我就是这么做的。一个程序可以调用另外一个程序来得到数据，可以把数据交给它处理后返回来，可以在自己的窗口里“嵌入”另外一个程序。

在 Windows 和其它非 UNIX 操作系统中，这种合作是非常困难的。我曾经在
Windows 下使用 Perl来进行一些自动工作。但是 Windows
的文件操作，管道是如此的不稳定，程序之间基本不能合作。你别想在 Visual
Studio 窗口里面嵌入 UltraEdit 编辑器，你别想用一个 expect 脚本来控制
telnet 到水木清华BBS，这就是为什么 helloooo 诞生在 Linux 而不是
Windows。我曾经试图从 Windows + Exceed + SecureCRT ssh 登录到 Sun
机器，然后通过 ssh 的隧道(X11 tunnel)把 X 程序传到 Exceed
上运行，但是搞了两天都没有成功！而在 Linux
下这个事情根本就是不用怎么配置的，OpenSSH 和 XFree86
本来就是完美结合，只要打开 ssh 的 "forward X11" 选项就什么都搞定了。

Windows
的程序都是大而全，大而杂，所有的电子邮件程序都需要自己提供编辑器，自己发送和收取邮件，自己显示邮件的附件。每一个BBS程序都提供自己的Virtual
Terminal, 自己的通讯代码。每一个 IDE
都自己提供编辑器，编译器，汇编器，调试器。人们为了使用一种新的程序，需要适应所有这些它提供的界面，而不能使用自己喜欢的编辑器的键绑定，菜单组织......
不能 DIY！

你要知道，最高级的电脑是定做的，自己想要什么什么CPU，什么主板，多少内存，什么硬盘，键盘，鼠标，显示器都是自己选择的。最高级的滑板，自己想要什么牌子的版面，什么牌子的沙，什么桥，什么轮子，什么轴承，也都是自己选的。最高级的乒乓球拍，木板，胶皮，海绵，胶水都是可以自己选择......
而用 Windows
程序，你得到的是大杂烩，就像你去买“品牌机”，只有那么几种配置，而且附带很多你不需要的软件和服务；就像你去买组装好的滑板，你想要大一点的轮子和窄一点的板子，但是你没有这种选择余地！Windows
程序就相当于最廉价，最次的滑板。但是它却会花你更多的钱，因为一旦一个部件坏了，或者你不喜欢了，你不能另外找一个好的换掉它，你必需重新买全套配件！

而 UNIX 和 Xwindow 就是高档的“组装货”。比如我用 Mutt 的时候，我可以用
VIM 也可以用 pico 来编辑邮件，我可以用 ImageMagick 也可以用 xv
来显示附件里的图片，我可以用 lynx 把 HTML
附件转成文本嵌入窗口中，我也可以把 HTML 附件交给 Mozilla
图形显示。我可以让 GnuPG 帮我把邮件进行数字签名和加密，我也可以用其它
PGP 程序。我想让 Postfix 而不是 sendmail 帮我发出邮件，我想让 fetchmail
帮我收邮件，转发给 postfix，然后被我自己写的Perl过滤器处理......
这一切我都可以办到！我可以选择我最喜欢的专门的程序来完成专门的工作，然后把它们结合在一起，我也可以分别得到它们的好处。

***** 结论

我写这么多的目的是什么？我希望喜欢 Linux 的朋友，完全清除微软和 Windows
灌输在你脑子里的谬论，别再相信它们所谓的“新技术”，别再追赶
Windows，因为追赶 Windows
＝倒退。马克思有一个思想很重要，“新生事物并不一定是在最近出现的。”
UNIX，Xwindow, TeX 虽然都比 Windows
先出现，但是它们才是先进生产力的代表。我们要清楚的认识到什么才是真正的现代化，什么才是真正的自动化。

勇敢的拿起像 bash, FVWM, TeX, VIM, Emacs, Mutt, lftp ......
这样强大的程序，勇敢的面对符号。不要再埋怨“Linux 为什么不能像 Windows
那样”，不要再浪费时间试用这样那样的程序，不要再忙着升级。需要改变的是你自己，而不是
Linux 和 Xwindow，Linux
现在就可以成为你的好朋友。你需要认识它，了解它，信任它，才能完全的靠它来高效的工作，省出时间来处理世界上更加值得处理的事情。

***** 附录: 我用来处理日常事务的 Linux 程序

好了好了。我知道你发现自己应该转向
Linux，你很后悔当初为什么中了微软的邪。但是不要着急。因为这些东西本来只是工具，它们是用来完成你的主要任务的辅助而已。你以前选错了工具，这不要紧。你还是拥有你自己原来的专业技能，那才是最重要的。工具的东西只有慢慢适应转换，不能一蹴而就，否则你会感到非常没意思，甚至放弃。

这里给出一些推荐使用的可以处理一般事情的程序。至于你的专业上要用到的科学和工程软件比如
Matlab, Mathematica, Maple, HSpice, Design Compiler, ......
还有其它物理上的，化学上的，生物上的 ...... 都必然有 Linux 和 UNIX
的版本。当然他们很多不是免费的，不要总是觉得什么都应该免费，它们是经过很多人辛勤劳动的产物，是可靠的程序，他们物有所值。

下面列出我常用的一些 Linux
程序。一个列表里可能有很多，那是为了方便你来选择，我列出了比较信得过的。但其实很多只有第一个是我真正在用的。我不喜欢试用程序。


- Shell: bash。我使用 bash 的 vi 命令行方式。

- 编辑器： VIM, Emacs

- 程序开发： GCC, make, ld, Scheme48, j2sdk, Perl, Python, Tcl/Tk ...

- 论文，幻灯工具：LaTeX, ConTeXt

- 绘图工具：MetaPost。这个语言太强了，以至于我只用它了。你不熟悉的话可
  以用dia 来画一些流程图之类的图片。

- 图像处理：ImageMagick。其中的 import 程序可以屏幕抓图，convert程序可
  以转换图像格式，display可以显示图片和简单编辑(缩放，换质量，转格式，
  简单绘图，简单虑镜)。通常我就这么点需要。如果你要更强大的图像工具可
  以用Gimp, 它几乎和 Photoshop 差不多。

- 自动管理工具：make。我可以用make来自动编译程序，自动编译文档，自动更
  新插图......全自动，而且不会重复劳动。

- 加密程序：GnuPG。我的 PGP 密钥就是它搞出来的，我用了 2048 位加密。

- 打包，压缩程序。什么都有: tar, gzip, bzip2, zip, rar, ...

- 虚拟光驱程序。Linux 不需要虚拟光驱程序，直接 mount 就行了。

- ftp 服务器：proftpd, vsftpd

- WWW 服务器：apache。(我一般没有开)

- ftp 客户程序：lftp

- 自动下载工具：wget

- 虚拟终端：rxvt, xterm, gnome-terminal, mlterm, ...

- X server: XFree86

- 窗口管理器：FVWM。编译加入了 libstroke。

- 中文输入：XSIM。被我修改过以适应 FVWM 的需要。另外推荐你还可以用SCIM。

- email 处理：Mutt + Postfix + fetchmail

- 看 PDF, PS, DJVU 文件：Acrobat Reader, xpdf, GhostScript, gv,djvu工
  具包和 netscape 插件。

- 看CAJ文档。我从来不看CAJ之类的文档，如果找不到PDF或PS，直接去图书馆借最好。

- 看网页：Mozilla, Phoenix, lynx。Mozilla-Xft 的显示效果比 IE好很多。

- 英汉字典：IBM智能词典，星际译王。

- 编辑网页：我用 VIM 直接写HTML。你如果想要图形方式的可以用其它的比如
  screem, BlueFish。

- 登录其它 UNIX, Linux 机器：openSSH, telnet。 openSSH 还可以把其它机
  器的 X 程序通过 ssh 加密的隧道传到我机器上显示。

- 上BBS：rxvt(或任何一种终端) + telnet + chatbot(helloooo机器人的程序)

- QQ, ICQ: 我没有 QQ 或 ICQ。不过你可以用 Gaim, 它同时支持 QQ, ICQ 和
  很多其它的即时通信方式。ICQ 用户也可以用 Licq。

- 放录像：MPlayer, RealPlayer。MPlayer 太好了，直接就可以放 VCD,
  DVD,divx, wma, wmv ... 用 Windows 的同学都很羡慕我，说 Windows要放这
  个需要大堆插件。rm 最好还是用 realplayer 放，它也是免费的。

- 放音乐： xmms(mp3,ogg都可以), mpg321(放mp3), ogg123(放ogg).

- 看 Word 文档。请 Word 用户把文档全部转为 PDF 或 PS 再给我，文档里没
  有特殊的格式就用文本文件，要不我就不看 :P

- 其它程序：还有很多我需要用而你不一定用得着的。比如，Doctor
  Scheme,Scheme48, Scsh, ...这些程序只有 Doctor Scheme有Windows版本。
  还有很多幕后工作但是你一般不察觉的：xinetd, telnetd,sshd, crond,
  atd, lpd, ... 他们都比 Windows 的对应者强的多。
**** 心灵鸡汤

有只黄鼠狼，在养鸡场的山崖顶上立了块碑，上面写着：“摆脱禁锢，不勇敢跳
下去，你怎么知道自己不是一只老鹰？”于是，它每天就在崖底等着吃摔死的鸡。
——这个故事告诉我们，阅读心灵鸡汤时需要智商，大多鸡汤都是黄鼠狼写的。

原来鸡汤是这样熬成的！

* Previsous
** w2
*** 2016/01/16
**** irc                                                             :irc:

[[/home/wally/Wally/Journal/Figure/scrot/30980jYW.png]]

***** what?

- [[http://baike.baidu.com/link?url=jB5JRb4FBbjGCs8fKheTymXOqf6zMaalCSvNR7_lkkrsjRbrgKPKS3a7jLchJcJ2x2OQMt4J4TuYSkzb_kZb2sdoG0dAMnLrVcXd1Nooo7y][百度百科]]

IRC是Internet Relay Chat 的英文缩写，中文一般称为互联网中继聊天。

它是多用户、多频道的讨论系统，许多用户可以在一个频道内就某一话题进行交
谈或私谈，每个用户都有一个不同的昵称。IRC允许任意的因特网用户之间做即
时的交谈。

IRC用户使用特定的用户端聊天软件连接到IRC服务器，通过服务器中继与其他连
接到这一服务器上的用户交流，所以IRC的中文名为“因特网中继聊天”。

***** features

- [[http://www.zhihu.com/question/24851247][知乎：为什么现如今还有人使用 IRC 聊天交流？
]]


- IRC 协议简单，开源实现多，本来就备受开发者青睐；
- 因此，其第三方机器人程序非常众多，开源实现库一抓一大把，任何想做多人同用机器人的开发者，都可以轻易上手，几乎每种语言都有一个实现，不必去望洋兴叹。
- IRC 不用登录，不用注册；但如果你注册了，就可以强制把占用自己唯一ID 的人踢下线。
- IRC 也可以私聊。
- IRC 也有特殊权限。
- IRC 是开源社区会议标准；
- 因此，IRC 在开源社区用得比较多；
- 因此，许多开源世界的技术大牛混在那里。

***** 客户端

- [[http://wiki.ubuntu.org.cn/IRC%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%89%E5%93%AA%E4%BA%9B][Ubuntu Forum: IRC 客户端有哪些]]

****** 网络浏览器

Firefox插件

-  [[https://addons.mozilla.org/en-US/firefox/addon/16][火狐插件ChatZilla]]

****** 网页

-  [[http://webchat.freenode.net/]] Freenode封了Mibbit后自己搞定HTML版本
-  [[https://irc.gitter.im/]] Beta，兼容lynx
-  [[https://kiwiirc.com/client]] 神抛弃老旧Opera后的选择

****** QT

-  [[/Quassel][Quassel]] 配合KDE功能强悍
-  [[https://konversation.kde.org/][Konversation]] KDE的默认客户端
-  [[http://www.kvirc.net/][KVIrc]]

****** GTK

-  [[/IRC@Pidgin][Pidgin]]
-  [[/Xchat][xchat]]

****** CLI

-  [[http://irssi.org/][irssi]] CLI界面IRC工具
-  [[http://www.gnu.org/software/emacs/][ERC]] 神的工具，神的ERC *Emacs IRC*

**** ERC                                                         :erc:irc:

- [[~/Wally/Reference/Manual/ERCManual.pdf][ERCManual.pdf]]
- [[http://www.emacswiki.org/emacs/ERC][EmacsWiki:ERC]]


ERC is part of the GNU project. It is included with recent versions of
GNU Emacs.

ERC is included in released versions of GNU Emacs since v22.3.

使用： M-x erc

**** blender

https://zh.wikibooks.org/zh-cn/Blender_3D%EF%B8%B0%E5%BE%9E%E5%85%A5%E9%96%80%E5%88%B0%E7%B2%BE%E9%80%9A

http://wiki.blender.org/

**** matlab 启动错误

#+BEGIN_EXAMPLE
  Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar
#+END_EXAMPLE

[[http://askubuntu.com/questions/615644/after-upgrading-ubuntu-14-10-to-15-04-i-am-no-longer-able-to-open-matlab-2013a/617059#617059][Ubuntu fomula]]

This package is responsible for application menu support for Java
swing applications, and seems to be the cause for the segfault.

#+BEGIN_EXAMPLE
sudo apt-get remove jayatana
#+END_EXAMPLE

没有解决问题。

[[http://www.mathworks.com/matlabcentral/answers/50971-matlab-r2012b-java-exception-error-starting-desktop][Mathworks]]

以超级用户身份执行 matlab, 解决问题, 不明所以。

#+BEGIN_EXAMPLE
Same thing happens to me on a macbook. Same exception, exception disappears when starting matlab using sudo.
#+END_EXAMPLE

Most likely you don't have write permissions on your preferences
directory. You can determine the location of the MATLAB preferences
folder by running the PREFDIR command at the MATLAB prompt.

If for some reason you're unable to fix the permissions, you can try
changing the prefs directory location:
http://www.mathworks.com/support/solutions/en/data/1-37KDWN/

In Matlab.
#+BEGIN_EXAMPLE
>> prefdir

ans =

/home/wally/.matlab/R2014a
#+END_EXAMPLE

#+BEGIN_EXAMPLE
   ls -l .matlab/R2014a/
  总用量 1536
  -rw-r--r-- 1 root root     12  1月 15 10:58 cwdhistory.m
  -rw-r--r-- 1 root root    512  1月 15 11:04 History.xml
  -rw-r--r-- 1 root root   6070  1月 15 11:03 MATLABDesktop.xml
  -rw-r--r-- 1 root root   6092  1月 15 10:58 MATLABDesktop.xml.prev
  -rw-r--r-- 1 root root    429  1月 15 10:57 matlab.prf
  -rw-r--r-- 1 root root   8864  1月 15 11:02 matlab.settings
  -rw-r--r-- 1 root root    201  1月 10 14:03 shortcuts_2.xml
  -rw-r--r-- 1 root root 553920  1月 10 14:03 toolbox_cache-8.3.0-2211579006-glnxa64.xml
  -rw-r--r-- 1 root root 970053  1月 15 10:58 toolbox_cache-8.3.0-903067591-glnxa64.xml
#+END_EXAMPLE
所有者为 root 用户。。。


问题找到了。但是不想修改 predir ，因为麻烦。折衷使用超级用户权限运行
matlab

Note: 在终端使用 C-c 结束 Matlab，反应慢，在 GUI 上点击关闭按钮。

**** mark-ring list ?

因为经常需要转换任务，所以可能会忘记之前的任务。

org-mark-ring-push

#+BEGIN_EXAMPLE
org-mark-ring-push is an interactive Lisp function in `org.el'.

It is bound to C-c %, C-c 4.

(org-mark-ring-push &optional POS BUFFER)

Put the current position or POS into the mark ring and rotate it.
#+END_EXAMPLE

org-mark-ring-goto

#+BEGIN_EXAMPLE
org-mark-ring-goto is an interactive Lisp function in `org.el'.

It is bound to C-c 5.

(org-mark-ring-goto &optional N)

Jump to the previous position in the mark ring.
With prefix arg N, jump back that many stored positions.  When
called several times in succession, walk through the entire ring.
Org-mode commands jumping to a different position in the current file,
or to another Org-mode file, automatically push the old position
onto the ring.
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-<f1>") 'org-mark-ring-push)
  (global-set-key (kbd "C-<f2>") 'org-mark-ring-goto)
#+END_SRC

**** wine 百度云

不行，别折腾

**** sdl                                                             :sdl:

***** sdl

[[https://www.libsdl.org/][Homepage]]

Simple DirectMedia Layer is a cross-platform development library
designed to provide low level access to audio, keyboard, mouse,
joystick, and graphics hardware via OpenGL and Direct3D.

****** install                                                 :install:

#+BEGIN_EXAMPLE
 $ sudo apt-get install  libsdl2-2.0-0
#+END_EXAMPLE

***** sdl_image                                               :sdl_image:

- [[http://www.libsdl.org/projects/SDL_image/][Homepage]]
- [[http://jcatki.no-ip.org:8080/SDL_image/][Document]]


SDL_image is an *image loading library* that is used with the SDL
library, and almost as portable. It allows a programmer to use
multiple image formats without having to code all the loading and
conversion algorithms themselves.

****** install                                                 :install:

#+BEGIN_EXAMPLE
 $ sudo apt-get install libsdl-image1.2
#+END_EXAMPLE

**** 学习时不要听 Eason 的歌

听 Eason 的歌太容易入神。

听一些舒缓的轻音乐。

*** 2016/01/14
**** supply

***** connector

输入： KF128-2
输出：5557 https://item.taobao.com/item.htm?id=41139630227&ali_refid=a3_430582_1006:1104098595:N:%E6%8F%92%E6%8B%94%E5%BC%8F%E6%8E%A5%E7%BA%BF%E7%AB%AF%E5%AD%90:cd6bd631faf7c8d74c8748dd98c47073&ali_trackid=1_cd6bd631faf7c8d74c8748dd98c47073&spm=a230r.1.14.3.Ozxn0o#detail

***** protector

电容：100uF/A

[[/home/wally/Wally/Journal/Figure/scrot/3098085D.png]]

二极管：


开关电源？

***** ref

[[https://app.yinxiang.com/shard/s52/nl/11551545/273c7e8c-dacd-4f22-a004-bb30aec5d710/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D152408a07ab%3AS%3Df5af2039594c32603700a7a7b6d115dc][直插式电阻电容封装与尺寸图解]]

[[https://app.yinxiang.com/shard/s52/nl/11551545/96b290e4-eb4d-4148-b51a-72fa4469c77e/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D152408b2f28%3AS%3D9a57fbc29200b7dff1aed88c48aa5ab2][Protel中Cap,Cap2，Cap Pol的区别]]

**** irc

[[/home/wally/Wally/Journal/Figure/scrot/30980jYW.png]]

*** 2016/01/13
**** cedet

使用 git 版的 cedet, 在 load 配置文件时与内置 cedet 矛盾

#+BEGIN_EXAMPLE
error:Cannot unload builtin CEDET since it is already loaded
#+END_EXAMPLE

解决： 将 cedet 的加载配置放在前面

*每次折腾 Emacs C++ IDE 都好烦人！！！*

**** emacs clang

#+BEGIN_SRC emacs-lisp
  (setq company-backends (delete 'company-semantic company-backends))
  (define-key c-mode-map (kbd "C-<tab>") 'company-complete)
  (define-key c++-mode-map (kbd "C-<tab>" 'company-complete)
#+END_SRC

**** wordpress

***** reference

- [[https://cn.wordpress.org/][Homepage]]
- [[https://github.com/wordpress/wordpress][Github]]
- [[https://github.com/punchagan/org2blog][org2blog]]

***** [[http://www.trinea.cn/other/choice-between-wordpress-and-github-page/][WordPress VS GitHub Page]]

****** WordPress和github page的选择和搭建

搭建博客时对wordpress和github page进行了简单的对比，最终选择了wp。

这里就简单对比下wp和gp的优缺点及搭建过程简介。主要比较方面包括*搭建复
杂度、对域名空间要求、写博客的便捷程度、开放性（主题、工具插件）、访问
速度、SEO优化、迁移成本

****** ps: 下面介绍中github page使用octopress博客框架

首先如果希望能以独立域名访问，域名的注册是必不可少的，可选择[[http://www.net.cn/domain/][万网]] 或 [[http://www.west263.cn/services/domain/][西部
数码]]等

*a. 搭建复杂度*

wp近乎傻瓜式；github较复杂，需要安装不少软件，而且还可能有莫名的错误，
需随时google解决结果：wp胜出，当然喜欢折腾或是对ruby相当熟悉的话可能差
别不是很明显。


*b. 对域名空间要求*

wp需要自己购买虚拟主机，低配大约在100-200RMB/Y，主机需要有lamp的环境运
行wp，不过现在的linux虚拟主机一般都提供此环境；

github page的一大优点就是不需要虚拟主机，它是可以发布到githubpage上的。

结果：github page免费优势明显

*c. 写博客的便捷程度*

wp需要打开后台，在后台撰写文章，即时写当然是需要联网的。wp的强大插件使
得博客文字样式可以很丰富
githubpage支持本地编写、本地预览，满意后再发布，并且支持markdown语法所
以对于不少程序员可能会比较方便。文本中直接编写极客的感觉*\_*

结果：对于不同人群各有优劣吧


*d. 开放性（主题、工具插件）*

wp的主题和插件是无比丰富的，这是选择wp的一大原因之一，不过插件多同时也
带来了另一个问题就是质量良莠不齐，选择相当麻烦费事，org~，之后会分享自
己装的觉得还不错的插件。

octopress相当来说发展没多久，插件方面没怎么调查，不过主题是标准的程序
员黑，自己改css相当费事

结果：wp胜出

*e、访问速度*

wp的访问速度与虚拟空间地址有关，不过我挂在朋友的购买的国外虚拟空间上速
度感觉也还不错

github的访问速度感觉与其他国外网站比还是较慢的，这几天刚好因为抢票插件
被封

结果：看具体虚拟空间的选择


*f、SEO优化*

wp不少插件提供seo优化功能，但也需要发博客时自己填写不少信息比较麻烦

githubpage搜索引擎优化就不需要自己做了，并且github在google上权重肯定相
当高，所以优势明显

结果：github page胜出

*g、迁移成本*

wp的迁移需要将网站目录迁移、数据库备份后再导入即可octopress的迁移也还
好，就算不利用githubpage的话，自己有一套ruby和nginx的环境的话也是可以
很方便重新部署的

结果：旗鼓相当

我比较在乎开放性（主题、工具插件）、写博客的便捷程度、访问速度、迁移成
本四点。尤其对第一点比较看重，所以选择了wp，不过比较插件真是差点被折腾
死||\_||，在wordpress和github

page的搭建中有自己安装的比较好的插件.

*PS：搭建过程*

wordpress搭建：下载 [[http://cn.wordpress.org/][最新wordpress包]] ，解压上传。直接访问index.php，按
照提示填写数据库信息即可（可以自己将个数据库）。

githubpage博客搭建参考[[http://www.hopes4.me/post/2012-02-29-introduce-octopress-on-github][在github上用octopress搭建博客]]， 关于ruby的安装可
参考 [[http://blog.sina.com.cn/s/blog_6b59aaa701017sff.html][Ruby在windows下的安装]]。

**** gtags

http://tuhdo.github.io/c-ide.html#orgheadline37

GNU Global has an environment variable named *GTAGSLIBPATH*. This
variable holds GTAGS database of _external libraries_ that your project
depends on but not inside your project. For example, your project may
rely on *system headers* such as stdio.h, stdlib.h… but these headers
are internal to your project.

However, remember that you can *only jump to tag definitions* of
external dependencies, and nothing else (such as files or
references).

But, again, once you are inside the external
library, you can start jumping around sicne it becomes your current
project.

#+BEGIN_EXAMPLE
export GTAGSLIBPATH=$HOME/.gtags/
#+END_EXAMPLE

**** xsel                                                           :xsel:

Manipulate the X selection

sudo apt-get install xsel

***** option

+ -b, --clipboard       Operate on the CLIPBOARD selection
+ -o, --output          Write the selection to standard output
+ -i, --input           Read standard input into the selection

***** usage

1. 复制内容到剪贴板中

   #+BEGIN_EXAMPLE
   cat file | xsel -i -b
   #+END_EXAMPLE

2. 取出剪贴板内容

   #+BEGIN_EXAMPLE
   xsel -o -b
   #+END_EXAMPLE

**** /usr/local 空间不足

/usr/local 挂载的分区大小为20G，完全不够用

移动 /usr/local/MATLAB 并建立软链接后，MATLAB 启动不了

以同样的方式处理 texlive 暂时没有问题

*** 2016/01/12
**** latex2html                                         :latex:latex2html:

***** reference

- https://www.ctan.org/pkg/latex2html?lang=en
- https://www.ctan.org/tex-archive/support/latex2html
- [[~/Wally/Reference/Manual/LaTeX2HtmlManual.pdf][LaTeX2HtmlManual.pdf]]

***** install                                                   :install:

#+BEGIN_EXAMPLE
$ ./configure & make & sudo make install
#+END_EXAMPLE

**** sdcv history                                                   :sdcv:

*$(HOME)/.sdcv_history*

**** fcitx 启动不了

#+BEGIN_EXAMPLE
  $ fcitx &


  (INFO-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/addon.c:151) 加载附加组件配置文件: fcitx-vk.conf
  (WARN-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/addon.c:298) 禁用插件 fcitx-ipc，依赖 fcitx-dbus 无法满足。
  (ERROR-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/frontend.c:565) 无可用前端
  (ERROR-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/instance.c:437) Exiting.
#+END_EXAMPLE

- 原因： 配置错误
- 解决：删除配置文件

  #+BEGIN_EXAMPLE
     mv ~/.config/fcitx ~/.config/fcitx.bak
  #+END_EXAMPLE

- 暴力解决(不推荐)

  #+BEGIN_EXAMPLE
    $ sudo dpkg -P fcitc*
    $ sudo apt-get install fcitx
  #+END_EXAMPLE

**** fcitx 切换输入法与 xmodmap 冲突

使用 gnome-tweak 解决

**** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

**** make -jn

多线程编译

用于多cpu的系统编译，n一般是cpu个数的2倍。

*** 2016/01/11
**** bash completion

#+BEGIN_EXAMPLE
For auto-completion, do not forget to install 'ct-ng.comp' into
your bash completion directory (usually /etc/bash_completion.d)
#+END_EXAMPLE

*/etc/bash_completion.d*

**** gazebo & ros jade

- [[http://answers.ros.org/question/217970/ros-jade-and-gazebo-50-migration-problem/][Q&A: ros jade and gazebo 5.0 migration problem]]

#+BEGIN_EXAMPLE
/opt/ros/jade/lib/gazebo_ros/gzclient: 17: .: Can't open /usr/share/gazebo//setup.sh
[gazebo_gui-3] process has died [pid 2459, exit code 2, cmd /opt/ros/jade/lib/gazebo_ros/gzclient __name:=gazebo_gui __log:=/home/wally/.ros/log/4fb3d678-b80e-11e5-9dba-002186ef9d91/gazebo_gui-3.log].
log file: /home/wally/.ros/log/4fb3d678-b80e-11e5-9dba-002186ef9d91/gazebo_gui-3*.log
#+END_EXAMPLE

*installing the gazebo5 package seems to have solved the
problem*.

**** softwares
***** octave
   http://mirrors.ustc.edu.cn/gnu/octave/
   https://coderwall.com/p/wo***kw/ubuntu-installing-octave-fortran-***error

***** briss

***** latex2html
https://www.ctan.org/pkg/latex2html?lang=en

***** xmradio
vlc
sourcecode

***** foxitreader

**** Foxit Reader                                            :foxitreader:

***** Linux 版安装

1. 官网下载：https://www.foxitsoftware.com/products/pdf-reader/
2. .run 可执行文件，安装至 /opt 下
3. 界面较 Windows 版，简化过多，功能不全，体验不好

*还是使用 wine foxitreader 习惯*

**** python install                                              :install:

- https://www.python.org/downloads/

version 3.5


READEM

#+BEGIN_EXAMPLE
  On Unix, Linux, BSD, OSX, and Cygwin:

      ./configure
      make
      make test
      sudo make install
#+END_EXAMPLE

***** 修改软链

#+BEGIN_EXAMPLE
  wally@ Python-3.5.1 $ python  --version
  Python 2.7.9
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/py
  pydoc3             python3            python3.5-config   python3.5m-config  pyvenv
  pydoc3.5           python3.5          python3.5m         python3-config     pyvenv-3.5
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/py
  pydoc3             python3            python3.5-config   python3.5m-config  pyvenv
  pydoc3.5           python3.5          python3.5m         python3-config     pyvenv-3.5
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/python /usr/bin/python
  [sudo] password for wally:
  ln: 无法创建符号链接"/usr/bin/python": 文件已存在
  wally@ Python-3.5.1 $ ls -l /usr/bin/python
  lrwxrwxrwx 1 root root 9  1月  9 16:07 /usr/bin/python -> python2.7
  wally@ Python-3.5.1 $ sudo rm /usr/bin/python
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/python3 /usr/bin/python
  wally@ Python-3.5.1 $ python --version
  Python 3.5.1
#+END_EXAMPLE

**** [[http://www.cnblogs.com/yejianfei/p/3351626.html][Linux的压缩与解压]]

***** zip格式                                                       :zip:

#+BEGIN_EXAMPLE
    压缩： zip -r [目标文件名].zip [原文件/目录名]
    解压： unzip [原文件名].zip
#+END_EXAMPLE

注：-r参数代表递归

***** tar格式（该格式仅仅打包，不压缩）                             :tar:

#+BEGIN_EXAMPLE
    打包：tar -cvf [目标文件名].tar [原文件名/目录名]
    解包：tar -xvf [原文件名].tar
#+END_EXAMPLE

注：c参数代表create（创建），x参数代表extract（解包），v参数代表
verbose（详细信息），f参数代表filename（文件名），所以f后必须接文件名。

***** tar.gz格式                                                     :gz:

方式一：利用前面已经打包好的tar文件，直接用压缩命令。

#+BEGIN_EXAMPLE
    压缩：gzip [原文件名].tar
    解压：gunzip [原文件名].tar.gz
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -zcvf [目标文件名].tar.gz [原文件名/目录名]
    解压并解包： tar -zxvf [原文件名].tar.gz
#+END_EXAMPLE

注：z代表用gzip算法来压缩/解压。

***** tar.bz2格式                                                   :bz2:

方式一：利用已经打包好的tar文件，直接执行压缩命令：

#+BEGIN_EXAMPLE
    压缩：bzip2 [原文件名].tar
    解压：bunzip2 [原文件名].tar.bz2
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -jcvf [目标文件名].tar.bz2 [原文件名/目录名]
    解压并解包： tar -jxvf [原文件名].tar.bz2
#+END_EXAMPLE

注：小写j代表用bzip2算法来压缩/解压。

***** tar.xz格式                                                     :xz:

方式一：利用已经打包好的tar文件，直接用压缩命令：

#+BEGIN_EXAMPLE
    压缩：xz [原文件名].tar
    解压：unxz [原文件名].tar.xz
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -Jcvf [目标文件名].tar.xz [原文件名/目录名]
    解压并解包： tar -Jxvf [原文件名].tar.xz
#+END_EXAMPLE

注：大写J代表用xz算法来压缩/解压。

***** tar.Z格式（已过时）

方式一：利用已经打包好的tar文件，直接用压缩命令：

#+BEGIN_EXAMPLE
    压缩：compress [原文件名].tar
    解压：uncompress [原文件名].tar.Z
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -Zcvf [目标文件名].tar.Z [原文件名/目录名]
    解压并解包： tar -Zxvf [原文件名].tar.Z
#+END_EXAMPLE

注：大写Z代表用ncompress算法来压缩/解压。另，ncompress是早期Unix系统的压缩格式，但由于ncompress的压缩率太低，现已过时。

***** jar格式                                                       :jar:

#+BEGIN_EXAMPLE
    压缩：jar -cvf [目标文件名].jar [原文件名/目录名]
    解压：jar -xvf [原文件名].jar
#+END_EXAMPLE

注：如果是打包的是Java类库，并且该类库中存在主类，那么需要写一个META-INF/MANIFEST.MF配置文件，内容如下：

#+BEGIN_EXAMPLE
    Manifest-Version: 1.0
    Created-By: 1.6.0_27 (Sun Microsystems Inc.)
    Main-class: the_name_of_the_main_class_should_be_put_here
#+END_EXAMPLE

然后用如下命令打包：

#+BEGIN_EXAMPLE
    jar -cvfm [目标文件名].jar META-INF/MANIFEST.MF [原文件名/目录名]
#+END_EXAMPLE

这样以后就能用“java -jar [文件名].jar”命令直接运行主类中的public static
void main方法了。

***** 7z格式                                                         :7z:

#+BEGIN_EXAMPLE
    压缩：7z a [目标文件名].7z [原文件名/目录名]
    解压：7z x [原文件名].7z
#+END_EXAMPLE

注：这个7z解压命令支持rar格式，即：

#+BEGIN_EXAMPLE
    7z x [原文件名].rar
#+END_EXAMPLE

**** freemind                                           :freemind:mindmap:

***** [[http://www.douban.com/group/topic/19280450/][思维导图软件]]

思维导图，又叫心智图。它的创始人是”大脑先生”托尼•巴赞（Tony Buzan）。

思维导图是一种将放射性思考具体化的方法。我们知道放射性思考是人类大脑的
自然思考方式，每一种进入大脑的信息，不论是感觉、记忆或是想法——包括文字、
数字、符码、食物、香气、线条、颜色、意象、节奏、音符等，都可以成为一个
思考中心，并由此中心向外发散出成千上万的关节点，每一个关节点代表与中心
主题的一个连结，而每一个连结又可以成为另一个中心主题，再向外发散出成千
上万的关节点，而这些关节的连结可以视为您的记忆，也就是您的个人数据库。

几款高级思维导图软件

1. PersonalBrain http://personalbrain.evget.com/

   目前比较流行的思维导图软件，使用简单方便，有专业版和普通版区别，专
   业版收费，界面很漂亮，蓝色的皮肤有点像宇宙的感觉，每个元素有上级、
   下级、同级3个节点，提供注释、备注等功能。

2. MindMapper http://www.mindmapper.com/

   它严格地遵守托尼巴贡的制图法则，关键字都是放在延伸手臂上。能够提供
   xml的输出 能与微软办公软件沟通，还有最妙的时间线进度。 快捷键是最好
   用的，无需点鼠标就可以建立新节点。

3. ThinkMap SDK http://www.thinkmap.com/

   软件介面非产酷，强大的数据库功能，3d树形网络,有很好的API开发接口。
   就是价格太贵。

4. FreeMind

   FreeMind是一款跨平台的、基于GPL协议的自由软件，用Java编写，是一个用
   来绘制思维导图的软件。其产生的文件格式后缀为.mm 。可用来做笔记，脑
   图记录，脑力激汤等。　

5. Xmind http://www.xmind.net/

   XMind是一款易用性很强的软件，通过XMind可以随时开展头脑风暴，帮助人
   们快速理清思路。XMind 绘制的思维导图、鱼骨图、二维图、树形图、逻辑
   图、组织结构图等以结构化的方式来展示具 LOGO

6. mindmanager http://www.evget.com/zh-CN/product/1069/feature.aspx

   mindmanager由美国Mindjet公司开发，界面可视化，有着直观、友好的用户
   界面和丰富的功能，　可使使用者有序地组织思维、资源和项目进程，同时
   它是高效的项目管理软件，能很好提高项目组的工作效率和小组成员之间的
   协作性。它作为一个组织资源和管理项目的方法，可从思维导图的核心分枝
   派生出各种关联的想法和信息。

***** [[http://xbeta.info/xmind-freemind.htm][XMind vs FreeMind]] :xmind:

思维导图类软件中，最有影响力的开源免费软件是 FreeMind 和XMind。

FreeMind历史悠久，当属经典；XMind作为后起之秀，大有赶超之势。同作为免费、开源的思维导图解决方案，应如何选择/结合两款软件？

本文的分析基于Windows平台下的 FreeMind 0.90 RC3 和 XMind 3.03，结合笔
者的使用经验，也包括XMind开发者所提供的信息。基本结论是： *总体看，
XMind已超越 FreeMind；个别方面，FreeMind 值得 XMind 学习*

****** XMind 与 FreeMind 的相同/相通之处

- 都是免费、开源、基于 Java。
- 都满足绘制思维导图的基本甚至高级功能。
- 相通之处：XMind 可以导入/导出 FreeMind 格式；反之不能。

****** XMind 与 FreeMind 比较

1. XMind: 更丰富的结构且支持混用

   FreeMind：只支持一种逻辑图（水平）结构。

   XMind：在逻辑图之外，还支持组织结构图（竖直）、树状图（水平+竖直）、
   思维导图（辐射）、鱼骨图、二维图（表格）。不仅如此，还能在一个文档
   中组合使用多种表达形式。实用举例：整个项目管理用逻辑图，人员安排部
   分用组织结构图，风险及应对采用鱼骨图，进度部分用二维图。

2. XMind: 支持自由节点因而支持多图

   FreeMind：只能有一棵树，即：根节点唯一，其他节点必须直接或间接放在
   根节点下。

   XMind：允许在主树之外创建自由节点（应用举例：把“文档作者/创建日期”作
   为自由节点，补充思维导图信息）；由于自由节点也是可以增加子节点的，
   所以可产生第二棵、第N棵新树。

3. FreeMind: 根节点仍可以插入父节点

   需求：在绘完的导图上再加一层。比如，最初建立了“唐诗”导图，现在要
   扩展到“唐宋文学”，即“唐诗”根节点要降至二级节点。

   XMind：顶级的自由节点之间是可以互为子节点的，但原来的根节点（XMind
   称为中心主题）则不能拖到其他节点上。满足上述需求，就要新建文档，以
   “唐宋文学”为根节点，然后导入或粘贴原有内容。\\

    FreeMind：支持根节点上插入“父节点”。

   建议：XMind的“根节点”比FreeMind减少了一份特殊性，即允许其他节点独
   立于此；但仍包留了另一份特殊性，不能成为其他节点的子节点。从使用角
   度，建议取消此限制，即：任何节点本身是一样的，彼此之间为父子关
   系。------或许有技术限制，但节点/层级的平等灵活是XML的精神。

4. XMind 支持附件, FreeMind 全为链接

   FreeMind：可以有超链接到外部文档和图片，也可以显示外部的图片。但这
   些资源都只是.mm文件中的链接url，并非素材本身。即，.mm是纯文本的xml，
   包括 FreeMind的图标也是以ID数字标示。

   XMind：支持上述链接方式，也支持（默认）把该文档及图片引入XMind文件
   作为附件，形成完整的资料包。.xmind 格式与OOo文档一样，实质是 xml＋
   素材的zip包。展开后的内容举例如下：

   #+BEGIN_EXAMPLE
     attachments\
     attachments\4hm2upmpscpth85latqpd49biq.png
     attachments\179ekuhhgn9g866cg5a26b78fh.pdf
     META-INF\
     META-INF\manifest.xml
     Thumbnails\
     Thumbnails\thumbnail.jpg
     content.xml
     meta.xml
     styles.xml
   #+END_EXAMPLE

5. 发布思维导图方面，XMind 要向 FreeMind 学习

   1) 能导出哪些格式

      - XMind 免费版：FreeMind、html、图片（bmp/jpg/gif/png）、纯文本
      - XMind Pro：以上 + MindManager、pdf（普通/思维图）、ppt/doc/rtf
      - FreeMind：各种html、flash、pdf、OpenOffice文档、png/jpg、
        svg/twiki等格式

   2) 我关注的导出格式、比较、说明

      - 静态图片：思维导“图”当然要能导出静态图片，这是最低需求。实在
        不能导出，截屏亦可。只是内容太多超过一屏时，截屏就不太方便了。
        图片可用于网页发布，也可用于其他文档（pdf/office）。格式方面，
        强烈不推荐bmp/jpg，推荐png/gif格式，[[http://blog.sina.com.cn/s/blog_46dac66f010004ox.html][原因见此]]。这方面，XMind与
        FreeMind持平。

      - pdf文档发布：相比图片的优点是，放大后文字仍然清晰。如果内容太
        多，导出一页的pdf发给别人，无论用于打印还是放大查看，都比图片
        的效果好很多。对比结果：XMindPro（未用过）＞ FreeMind（够用）
        ＞ XMind（无）-- 广义html导出：FreeMind 遥遥领先，详细见下。

      - 广义html导出的详细比较

        结论：广义html/flash式导出，目的是在线发布后，仍保留折叠/展开
        动态效果，及链接功能。这方面，FreeMind遥遥领先，远胜 XMind。

        XMind：导出的html包括图片和节点文字。但图与文字无链接；文字层
        级也不能折叠；图片默认为jpg，强烈建议换为png。

        FreeMind：可采用不同技术进行导出，每种导出效果都非常好。
        FreeMind导出html的格式有：

        - html：纯文字方式，节点保留原有格式，层级关系可折叠展开，url链接有效。
        - xhtml（javascript）：效果同上，只是改用js实现。
        - xhtml（可点击map图片）：除了上述文字内容外，还附有图片，并且点击图片的节点可跳转到对应的文字。
        - java applet：功能保留最多的方式。在浏览器中的使用效果近乎在 FreeMind中打开 .mm文件。
        - flash：点击可折叠/展开，链接url有显示但无法点击。

6. FreeMind节点支持html代码

   FreeMind：节点支持html代码，实现文字格式化、换行、分段、图像链接、
   表格。（此外，还支持LaTex代码）

    XMind：不能对部分文字分别设定格式，可以shift+enter换行。

7. XMind 具有更好的可持续性

   FreeMind作为经典开源软件，虽在持续更新中，但新功能进展并不多。而同
   作为开源软件的XMind，不仅因为后发优势拥有了更多功能。并且，作为有商
   业公司支持的开源产品，新功能的开发会更加活跃------这并非迷信商业，
   而是实际情况，包括两个开发团队的成员也有此认识。

    另外，XMind还提供了更强大的Pro版，可以满足个人和企业的更高需求，并
   能提供可靠的技术支持。

8. XMind 更美观，FreeMind 更快速省资源

   无论用户界面还是思维导图文件，XMind 都更加美观。而 FreeMind更加简约，
   占用资源更少，启动和运行速度更快。各取所需即可。

9. 其他差异

   FreeMind 可以导入目录结构，相当于变成了资源管理器；XMind不能。

   在节点输入较多文字的过程中，XMind的输入框会阶梯式不断加大，而
   FreeMind会保持同样大小（只显示最右侧部分）。

   XMind的节点可以添加标签，以进行过滤筛选；而FreeMind可以根据节点文字
   进行过滤显示。

    注意：XMind导入.mm时，无法识别包含html代码的节点。

****** 结论：软件选择建议

大多数人普通用户：XMind。理由：支持逻辑图、二维图等多种表达形式并可混
用，更加美观、支持附件。

*Geek或偏执者：FreeMind。理由：更节约资源，界面更简朴。*

自主网络发布：FreeMind。理由：强大灵活的html导出功能。

不执着于软件，仅执着于最优效果：主用 XMind 辅用FreeMind。即仅在自主网
络发布时另存为FreeMind格式，再用FreeMind导出为html。

***** freemind

+ [[http://freemind.sourceforge.net/wiki/index.php/Main_Page][Homepage]]

****** install                                                 :install:

新得立 version 0.9

beta: 1.1

http://freemind.sourceforge.net/wiki/index.php/Download

http://www.getdeb.net/app/Freemind -> 软件中心

不支持的软件源，安装过程中需要 “修复”。。。

还是源码 -> ant (java 版 make)

#+BEGIN_EXAMPLE
java.io.IOException: Cannot run program "/home/wally/Download/freemind/check_for_duplicate_resources.sh": error=13, 权限不够
#+END_EXAMPLE

sudo 和切换为 root 用户，也不行？

还是 apt-get 方式

****** usage

用起来体验不错。
**** org export to freemind                             :freemind:mindmap:

#+BEGIN_EXAMPLE
- State "DONE"       from "ABORT"      [2016-01-11 一 10:20] \\
  重新安装系统后编译Emacs，解决问题
- State "ABORT"      from "TODO"       [2015-11-23 一 19:26] \\
  不需要的东西不要瞎折腾, 放弃也是一种智慧
#+END_EXAMPLE


#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "~/.emacs.d/src/org-mode/contrib/lisp"))
  (require 'ox-freemind)
  (setq org-freemind-pretty-output t)
  (setq org-freemind-section-format 'note)
#+END_SRC

(void-function libxml-parse-xml-region) 暂时解决不了。。。

-> 重新编译安装Emacs??? 不要鲁莽！！！

*org-freemind-export-to-freemind*

**** desktop重命名                                               :desktop:

- http://blog.csdn.net/manmaximus/article/details/3567919

- why: 重命名桌面文件夹，桌面所在文件夹是“桌面”，习惯了用终端进行操
  作，但是在终端打中文比较麻烦

- 配置文件: *~/.config/user-dirs.dirs*

  #+BEGIN_EXAMPLE
    # This file is written by xdg-user-dirs-update
    # If you want to change or add directories, just edit the line you're
    # interested in. All local changes will be retained on the next run
    # Format is XDG_xxx_DIR="$HOME/yyy", where yyy is a shell-escaped
    # homedir-relative path, or XDG_xxx_DIR="/yyy", where /yyy is an
    # absolute path. No other format is supported.
    #
    XDG_DESKTOP_DIR="$HOME/Desktop"
    XDG_DOWNLOAD_DIR="$HOME/Download"
    XDG_TEMPLATES_DIR="$HOME/模板"
    XDG_PUBLICSHARE_DIR="$HOME/Share"
    XDG_DOCUMENTS_DIR="$HOME/Document"
    XDG_MUSIC_DIR="$HOME/Audio"
    XDG_PICTURES_DIR="$HOME/Picture"
    XDG_VIDEOS_DIR="$HOME/Video"
  #+END_EXAMPLE

**** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

**** emacs matlab                                                 :matlab:

***** matlab-emacs

中止的项目

#+BEGIN_SRC emacs-lisp
  (autoload 'matlab-mode "matlab" "Enter MATLAB mode." t)
  (setq auto-mode-alist (cons '("\\.m\\'" . matlab-mode) auto-mode-alist))
  (autoload 'matlab-shell "matlab" "Interactive MATLAB mode." t)
#+END_SRC

***** matlab-mode

https://github.com/pronobis/matlab-mode

****** configure

+ [[http://www.emacswiki.org/emacs/MatlabMode][EmacsWiki]]

#+BEGIN_SRC emacs-lisp
  (autoload 'matlab-mode "matlab" "Matlab Editing Mode" t)
  (add-to-list
   'auto-mode-alist
   '("\\.m$" . matlab-mode))
  (setq matlab-indent-function t)
  (setq matlab-shell-command "matlab")
#+END_SRC

****** usage

- *matlab shell* 后台运行 matlab (Note: 不会启动 GUI，但会短暂地弹出一
  个窗口)
- 只能运行，不支持调试，调试还是使用 Matlab GUI

***** matlab IDE 支持 Emacs 基本的编辑快捷键，所以可能不需要集成在 Emacs 中

** w1
*** 2016/01/10
**** index

关于建立索引的想法

1. 索引类似书后面的 index
2. 按字母顺序排列
3. 不使用标题，因为不需要继承标签
4. 使用无序列表
5. 可以包含简要的笔记内容和链接等

**** 手机 VPN

不用下载客户端，直接使用配置中的VPN

**** 交换 CapsLock 和 Ctrl 键
***** reference

- http://tuhdo.github.io/emacs-tutor.html
- http://www.kodiva.com/post/swapping-caps-lock-and-control-keys
-
  http://askubuntu.com/questions/412576/swap-caps-lock-and-ctrl-in-ubuntu-13-10/412622#412622

***** windows: 通过修改注册表

In our opinion this is the best way to swap the control and caps lock
keys in Windows because you don't have to rely on any external program
and the registry edit works 100% perfectly (for the paranoid).

Why should one bother changing the caps lock and control keys, what's
wrong with the control key where it is? After extensive testing, our
conclusion is that - if you use the control key a lot (like in Emacs or
Vim), then you should definitely swap the control and caps lock keys as
it's extremely ergo-dynamic to have the control key in the home row.

1. Click Start -> Run

2. Type: regedit, and click OK

3. Go to: HKEY_LOCAL_MACHINE -> System -> CurrentControlSet -> Control
   -> KeyBoard Layout

   Note: *KeyBoard Layout*, and not KeyBoard Layouts

4. Right-click: Keyboard Layout, and select New -> Binary value

5. Rename: New Value #1 -> Scancode Map

6. Right click: Scancode Map -> Modify
   #+BEGIN_EXAMPLE
     0000  00 00 00 00 00 00 00 00
     0008  03 00 00 00 1d 00 3a 00
     0010  3a 00 1d 00 00 00 00 00
     0018
   #+END_EXAMPLE

7. Close regedit and restart your computer

***** Linux

1. Put this in your shell init file (.bashrc, .zshrc…):

   #+BEGIN_EXAMPLE
   /usr/bin/setxkbmap -option "ctrl:swapcaps"
   #+END_EXAMPLE

2. xmodmap

3. gnome-tweak-tool(Ubuntu)

   First, install gnome-tweak-tool using sudo apt-get install
   gnome-tweak-tool from a console.

   Then, run it using the command gnome-tweak-tool, or by typing
   "Tweak Tool" into the dash at the top-left.

   From this tool, choose the "Typing" tab on the left. Then, from the
   dropdown next to "Ctrl key position" on the right, choose "Swap
   Ctrl and Caps Lock". This should swap those two keys.
**** org-mobile

+ http://darksun.blog.51cto.com/3874064/1302920

***** 下载 MobileOrg

豌豆荚上的 MobileOrg 版本低。

google play 在手机上安装后打开无反应！！！

https://github.com/matburt/mobileorg-android  源码不会编译，android 平
台。似乎不再更新了，最后一次提交是两年前。

Google 搜索关键字 "MobileOrg apk": [[http://www.appdownloader.net/Android/App/602857/com.matburt.mobileorg/Download][Down MobileOrg Apk 0.9.13]]

***** 配置 Emacs org

org-mobile-push C-c C-x RET p

#+BEGIN_SRC emacs-lisp
  (require 'org-mobile)
  (require 'org-id)
  (setq org-mobile-directory (expand-file-name "~/Share/Dropbox/MobileOrg"))
  (setq org-directory "~/Wally/Journal/GTD")
  (setq org-mobile-files '("~/Wally/Journal/GTD/task.org"))
  (setq org-mobile-inbox-for-pull "~/Wally/Journal/GTD/mobile.org")
#+END_SRC

****** error

#+BEGIN_EXAMPLE
(void-function org-id-get)
#+END_EXAMPLE

(require 'org-id)

***** 使用小结

#+BEGIN_EXAMPLE
  C-c C-x RET p (translated from C-c C-x <return> p) runs the command
  org-mobile-push, which is an interactive Lisp function in
  `org-mobile.el'.

  It is bound to <menu-bar> <Org> <MobileOrg> <Push Files and Views>,
  C-c C-x RET p.

  (org-mobile-push)

#+END_EXAMPLE

可以更新任务状态，但是更新的内容只是同步到了 mobile.org, 而没有改变对
应的 task.org
**** software
***** 新得立
***** Ubuntu Windows 双系统，硬盘安装

****** windows 配置

1. 下载镜像文件
   - Ubuntu 64位(乌班图系统) v12.04.1 官方原版iso镜像：http://www.33lc.com/soft/18055.html
   - Ubuntu(乌班图系统) v12.04.1 官方原版iso镜像： http://www.33lc.com/soft/18053.html

2. 下载并安装easybcd。

   easybcd是一款很优秀的系统引导软件，功能强大，最关键的是傻瓜式一站式
   简易操作，极其适合新手使用!

3. 新建分区

   腾出一个空盘，点击右键格式化之后把它删除(这个盘最好是在硬盘的后面，
   因为Windows系统不能识别Linux系统分区，如果将ubuntu装在D盘，将D盘删
   除并建立Linux系统分区后，原来的E盘就会变成D盘，安装在E盘的软件会出
   现系统注册表路径不对称，要重新安装一遍软件)。网上很多说使用磁盘压缩
   功能以整理出空白分区，这个方法也可行，但这个盘要保证有10G空间以上比
   较稳妥。

4. 安装好easybcd2.1.2后，启动软件

   #+DOWNLOADED: http://www.33lc.com/article/UploadPic/2012-8/20128241427190206.jpg @ 2016-01-10 14:16:48

   [[~/Wally/Journal/Figure/.org-download/Journal/20128241427190206_2016-01-10_14:16:48.jpg]]

   按照上图的序号依次点击“Add New Entry”——“Neo Grub”——“Install”，
   点到“Install”后出面下面的界面，再点“Configure”。

   点击“Configure”按钮后，会出现一个记事本文件，将下面的代码粘贴到文
   件尾部：

   #+BEGIN_EXAMPLE
     title Install Ubuntu 12.04 LTS
     root (hd0,6)
     kernel (hd0,6)/vmlinuz boot=casper iso-scan/filename=/ubuntu-12.04-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8
     initrd (hd0,6)/initrd.lz
   #+END_EXAMPLE

   上图代码中“ubuntu-12.04-desktop-amd64.iso”为你下载的ubuntu 12.04
   系统镜像文件名，这个文件名是可以修改的，但修改的名字一定要与写入的
   代码名字一致，否则将无法引导安装;

   (hd0,6) 表示磁盘分区，hd(0,0), hd(0,1), hd(0,2), hd(0,3)表示主分区，
   (hd0,4)以后的表示逻辑分区，现在我只有一个主分区C盘，则(hd0,0)表示C
   盘，(hd0,4)表示D盘，(hd0,5)表示E盘，(hd0,6)表示F盘，我的镜像就是放
   在F盘里，请把(hd0,6)改成自己对应的分区)

5. 将下载的镜像文件放到(hd0,N)盘的根目录下，并确保文件名与上面写入的代
   码的文件名一致为ubuntu-12.04-desktop-amd64.iso，然后用WinRAR解压缩
   软件将iso打开，将casper文件夹目录下的vmlinuz和 initrd.lz解压并复制
   到(hd0,N)盘根目录下。准备工作至此已全部完成!!!

****** Ubuntu 安装

1. sudo umount /isodevice

2. /usr/local 或 /opt 可以单独挂载一个分区

****** Windows 下删除 Ubuntu 分区导致系统无法启动（引导程序失败） :grub:

- [[http://zhidao.baidu.com/question/495728786.html?fr=ala&word=grub%20rescue%E5%88%A0%E9%99%A4ubuntu&device=mobile&ssid=0&from=2001a&uid=0&pu=usm@0][百度知道]]

装了ubuntu后，会默认从Ubuntu的Grub菜单引导系统，Win8的MBR被替换为Grub
来引导。

于是，你删除了Ubuntu，也就是删除了Grub的文件。但是，你的引导扇区的启动
参数还是指向了Grub，于是就grun rescue了。。。

*解决方法*

用PE启动，打开WinPM或者DiskGen，找到一个叫重建主引导记录（MBR）的东西，
重建一下就好了，记得把Windows分区设置为活动！

***** [[http://seisman.info/install-texlive-under-linux.html][Linux下安装TeXLive 2015]]
****** [[#id8][依赖包]]

-  安装过程中需要调用Perl的模块 =Digest::MD5= 来检测ISO文件的完整性；
-  升级过程中界面需要调用Perl的模块 =Tk= ；

CentOS:

#+BEGIN_EXAMPLE
    $ sudo yum install perl-Digest-MD5 perl-Tk
#+END_EXAMPLE

Ubuntu:

#+BEGIN_EXAMPLE
    $ sudo apt-get install libdigest-perl-md5-perl perl-tk
#+END_EXAMPLE

****** [[#id9][安装]]

******* [[#id10][下载]]

下载地址：

-  官方镜像:
   [[http://mirrors.ctan.org/systems/texlive/Images/texlive2015.iso]]
-  USTC镜像：
   [[http://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/texlive2015.iso]]

Linux下可以用wget、axel，windows下可以用迅雷，怎么快怎么来。

******* [[#id11][挂载ISO镜像]]

 #+BEGIN_EXAMPLE
     $ su
     # mount -o loop texlive2015.iso  /mnt/
     # cd /mnt
     # ./install-tl
 #+END_EXAMPLE


出现选项后，输入 =I=
直接安装（也可以更改选项）。不出意外的话，5分钟应该就OK了，然后退出root用户。

******* [[#id12][环境变量]]

在当前用户的 =~/.bashrc= 中加入如下语句：

 #+BEGIN_EXAMPLE
     # TeX Live 2015
     export MANPATH=${MANPATH}:/usr/local/texlive/2015/texmf-dist/doc/man
     export INFOPATH=${INFOPATH}:/usr/local/texlive/2015/texmf-dist/doc/info
     export PATH=${PATH}:/usr/local/texlive/2015/bin/x86_64-linux
 #+END_EXAMPLE


******* [[#id13][卸载ISO镜像]]

 #+BEGIN_EXAMPLE
     1
     2
 #+END_EXAMPLE

 #+BEGIN_EXAMPLE
     $ cd
     $ sudo umount /mnt/
 #+END_EXAMPLE

****** [[#id14][更新TeXLive]]

可以使用如下命令更新TeXLive宏包：


 #+BEGIN_EXAMPLE
     $ su
     # 更新TeXLive包管理器tlmgr
     # tlmgr update --self
     # 更新TeXLive的全部包
     # tlmgr update --all
 #+END_EXAMPLE


默认情况下，会自动搜索合适的镜像来更新，也可以使用 =--repository=
选项指定了要使用哪一个CTAN镜像。

比如USTC镜像:

#+BEGIN_EXAMPLE
    # tlmgr update --self --repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet/
    # tlmgr update --all --repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet/
#+END_EXAMPLE

比如阿里云镜像:

#+BEGIN_EXAMPLE
    # tlmgr update --self --repository http://mirrors.aliyun.com/CTAN/systems/texlive/tlnet/
    # tlmgr update --all --repository http://mirrors.aliyun.com/CTAN/systems/texlive/tlnet/
#+END_EXAMPLE

如果希望在图形界面下升级，可以使用如下命令调出tlmgr的中文图形界面：

 #+BEGIN_EXAMPLE
     $ su
     # tlmgr --gui --gui-lang zh_CN
 #+END_EXAMPLE

****** [[#id15][安装额外的字体]]

TeXLive 2015在使用xeLaTeX处理中文时，有自己的默认字体。大多数Linux发行版下，都使用自带的Fandol字体。

如果想要使用Windows字体，可以将字体文件复制到 =~/.fonts=
目录下，并在tex源码中指定字体选项即可。

*.local/share/fonts 文件夹*

****** [[#id16][修订历史]]

-  2013-07-11：初稿；
-  2014-07-06：修改为TeXLive2014，并删除中文字体部分；
-  2015-03-08：新增“安装依赖”；
-  2015-03-15：使用命令行更新包；
-  2015-03-20：指定更新源以及GUI更新；
-  2015-06-13：更新至TeXLive 2015；

So what do you think? Did I miss something? Is any part unclear? Leave
your comments below.

[[http://seisman.info/install-texlive-under-linux.html#disqus_thread][Comments]]

Please enable JavaScript to view the
[[http://disqus.com/?ref_noscript][comments powered by Disqus.]]

[[http://disqus.com][comments powered by Disqus]]

--------------

****** Related Posts:

-  [[http://seisman.info/terms-about-tex.html][与TeX相关的一些名词]]
-  [[http://seisman.info/perl-plenv.html][Perl多版本共存之plenv]]
-  [[http://seisman.info/install-gmt5-under-linux.html][GMT 5.1.2在Linux下的安装]]
-  [[http://seisman.info/mini-template-for-xeCJK.html][使用xeCJK解决中文问题的最小模板]]
-  [[http://seisman.info/install-gmt5-under-windows.html][GMT 5.1.2在Windows下的安装]]

***** [[http://ergoemacs.org/emacs/building_emacs_on_linux.html][How to Build Emacs on Linux]] :install:

This page shows you how to compile/build latest version of publically
released version of emacs on Linux. It should work for building any
emacs version. I assume you are on Ubuntu Linux.

If you want to build latest development version, see:
[[building_emacs_from_git_repository.html][How to Build Emacs from git
Repository]].

****** Summary

Here's summary of what to do.

① Install essential build tools and dependency first:

#+BEGIN_EXAMPLE
    # install essential build tools
    sudo apt-get install build-essential
#+END_EXAMPLE

② Download emacs dependencies:

#+BEGIN_EXAMPLE
    # get all dependencies of a previous emacs version
    sudo apt-get build-dep emacs24
#+END_EXAMPLE

③ Download emacs source code from [[http://ftp.gnu.org/gnu/emacs/]],
then cd to the emacs source directory.

④ Compile emacs:

#+BEGIN_EXAMPLE
    cd ‹source dir name›
    ./configure
    make
    sudo make install # optional. This basically copy the binary to /usr/local/bin
#+END_EXAMPLE

Following is detailed explanation.

--------------

****** Check Prepared Emacs Packages

On Ubuntu, typically you install by =sudo apt-get install emacs24=,
where the “emacs24” may be other version.

To search for emacs, do: =apt-cache search emacs | grep emacs=.

When emacs has a new version, Ubuntu Linux typically takes half a year
to a year to have a prepared package.

Or, you build it yourself. It's easy.

****** Download Emacs Source Code

Download emacs source code here: [[http://ftp.gnu.org/gnu/emacs/]]

****** Compile Steps

To compile programs on unix, typically the steps are:

#+BEGIN_EXAMPLE
    cd ‹source dir name›
    ./configure
    make
    sudo make install # optional. This basically copy the binary to /usr/local/bin
#+END_EXAMPLE

In the source dir, there's usually a README or INSTALL file.

However, you'll probably fail in the configure step, because emacs
requires lots other libraries, also, you might be missing build tools.

Here's some sample output of failure:

#+BEGIN_EXAMPLE
    checking for libXaw... configure: error: No X toolkit could be found.
    If you are sure you want Emacs compiled without an X toolkit, pass
      --with-x-toolkit=no
    to configure.  Otherwise, install the development libraries for the toolkit
    that you want to use (⁖ Gtk+) and re-run configure.
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    configure: error: The following required libraries were not found:
        libXpm libjpeg libpng libgif/libungif libtiff
    Maybe some development libraries/packages are missing?
    If you don't want to link with them give
        --with-xpm=no --with-jpeg=no --with-png=no --with-gif=no --with-tiff=no
    as options to configure
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    configure: error: The required function `tputs' was not found in any library.
    These libraries were tried: libncurses, libterminfo, libtermcap, libcurses.
    Please try installing whichever of these libraries is most appropriate
    for your system, together with its header files.
    For example, a libncurses-dev(el) or similar package.
#+END_EXAMPLE

You can type =./configure --help= to see the options it supports. See
its output here: [[linux_compile_emacs_24_config_help_output.txt]].

****** Install Basic Build Tools

#+BEGIN_EXAMPLE
    # install basic build tools
    sudo apt-get install build-essential
#+END_EXAMPLE

To see info about the package, do:

-  =apt-cache showpkg build-essential=
-  =apt-cache show build-essential=

****** Dependencies

You'll need to install some 30 dependent libraries. The trick is to know
which are they. Took me a couple hours to find out the hard way.

The easiest way is to install all dependencies of a previous version of
the package, like this:

#+BEGIN_EXAMPLE
    sudo apt-get build-dep emacs24
#+END_EXAMPLE

This will install all packages emacs24 depends on.

Here's the output on my machine for emacs23:

#+BEGIN_EXAMPLE
    The following NEW packages will be installed:
      autoconf automake autotools-dev bsd-mailx diffstat imagemagick libasound2-dev libdatrie-dev
      libdbus-1-dev libgconf2-dev libgpm-dev libgtk2.0-dev liblockfile-dev liblqr-1-0 libm17n-dev
      libmagickcore3 libmagickwand3 libncurses5-dev libotf-dev librsvg2-dev libthai-dev libtinfo-dev
      libxml2-dev postfix quilt sharutils texinfo xaw3dg xaw3dg-dev xutils-dev
    0 upgraded, 30 newly installed, 0 to remove and 4 not upgraded.
    Need to get 12.4 MB of archives.
    After this operation, 49.5 MB of additional disk space will be used.
#+END_EXAMPLE

You can see the full bash output here:
[[linux_compile_emacs_23_dependencies.txt]]

****** config, make

=make distclean= to clear files created by configure.

Once you have all the dependencies, you can now run =./configure= and
=make= again.

Here's a sample successful output:

-  [[linux_compile_emacs_24_config_success_output.txt]]
-  [[linux_compile_emacs_24_make_success_output.txt]]

After successful “make”, you should have a binary at =src/emacs= in the
current dir. You can test run it by =src/emacs &=.

Optionally, you can do =sudo make install=, which will basically copy
the binary to =/user/loca/bin/=, and copy various elisp files, info
files, man pages, etc, into various Linux default dirs.

***** steam                                                       :steam:
****** dota 全屏

http://jingyan.baidu.com/article/e75057f2dca190ebc91a893e.html

全屏问题，选项里设置视频，全屏模式

****** error

http://askubuntu.com/questions/614422/problem-with-installing-steam-on-ubuntu-15-04

#+BEGIN_EXAMPLE
$ steam
Running Steam on ubuntu 15.04 64-bit
STEAM_RUNTIME is enabled automatically
Installing breakpad exception handler for appid(steam)/version(0_client)
libGL error: unable to load driver: r600_dri.so
libGL error: driver pointer missing
libGL error: failed to load driver: r600
libGL error: unable to load driver: swrast_dri.so
libGL error: failed to load driver: swrast
#+END_EXAMPLE

***** [[http://lanbing510.info/2014/12/03/Linux-Matlab.html][Matlab 安装]] :install:

1. 从[[http://pan.baidu.com/s/1o6qKdxo#path=%252Fmatlab][这里]]下载Matlab2014的Linux版本及破解文件。

   - note: 两个 rar 文件，只需使用 unrar 解压其中一个即可，会自动解压
     另外一个。

2. 下载完成后将iso文件挂载到Linux进行安装。

   #+BEGIN_EXAMPLE
    sudo mkdir /media/matlab
    mount -o loop [path][filename].iso /media/matlab
    cd /media/matlab
    sudo ./install
   #+END_EXAMPLE

  - ./install 触发的是 GUI 方式，而不是命令行方式

3. 安装过程中使用readme.txt中的序列号。

4. 破解

   1) 安装完成后使用crack下的 license进行激活；

   2) 将crack文件夹下的libmwservices.so copy到 /usr/local/MATLAB/R2014A/bin/glnxa64。

5. 完成安装，命令行下使用sudo matlab即可启动使用。

***** git 安装                                                  :install:

https://github.com/git/git

from INSTALL(file)

#+BEGIN_EXAMPLE
Alternatively you can use autoconf generated ./configure script to
set up install paths (via config.mak.autogen), so you can write instead

        $ make configure ;# as yourself
        $ ./configure --prefix=/usr ;# as yourself
        $ make all doc ;# as yourself
        # make install install-doc install-html;# as root
#+END_EXAMPLE

顺便解决了 magit 因为 git 版本低的 bug

***** pandoc 安装                                               :install:

- https://github.com/jgm/pandoc


1. apt-get

   #+BEGIN_EXAMPLE
     :~$ apt-cache search pandoc
     doconce - document once, include anywhere
     gitit - Wiki engine backed by a git or darcs filestore
     libghc-citeproc-hs-data - Haskell support for Citation Style Language - data files
     libghc-citeproc-hs-dev - Haskell support for Citation Style Language
     libghc-citeproc-hs-doc - Haskell support for Citation Style Language; documentation
     libghc-citeproc-hs-prof - Haskell support for Citation Style Language; profiling libraries
     libghc-gitit-dev - Wiki engine backed by a git or darcs filestore
     libghc-gitit-doc - Wiki engine backed by a git or darcs filestore; documentation
     libghc-gitit-prof - Wiki engine backed by a git or darcs filestore; profiling libraries
     libghc-pandoc-citeproc-data - Pandoc support for Citation Style Language - data files
     libghc-pandoc-citeproc-dev - support for using pandoc with citeproc
     libghc-pandoc-citeproc-doc - support for using pandoc with citeproc; documentation
     libghc-pandoc-citeproc-prof - support for using pandoc with citeproc; profiling libraries
     libghc-pandoc-dev - general markup converter - libraries
     libghc-pandoc-doc - general markup converter - library documentation
     libghc-pandoc-prof - general markup converter - profiling libraries
     libghc-pandoc-types-dev - Haskell data types to represent structured documents
     libghc-pandoc-types-doc - Haskell data types to represent structured documents; documentation
     libghc-pandoc-types-prof - Haskell data types to represent structured documents; profiling libraries
     libghc-yesod-markdown-dev - tools for using Markdown in a Yesod application
     libghc-yesod-markdown-doc - tools for using Markdown in a Yesod application; documentation
     libghc-yesod-markdown-prof - tools for using Markdown in a Yesod application; profiling libraries
     pandoc - general markup converter
     pandoc-citeproc - Pandoc support for Citation Style Language - tools
     pandoc-data - general markup converter - data files
     python-pandocfilters - python bindings for Pandoc's filters
     python3-pandocfilters - python3 bindings for Pandoc's filters
     wally@wally:~$ sudo apt-get install pandoc
     [sudo] password for wally:
     正在读取软件包列表... 完成
     正在分析软件包的依赖关系树
     正在读取状态信息... 完成
     将会安装下列额外的软件包：
       liblua5.1-0 pandoc-data
     建议安装的软件包：
       texlive-latex-recommended texlive-xetex texlive-luatex pandoc-citeproc etoolbox
     下列【新】软件包将被安装：
       liblua5.1-0 pandoc pandoc-data
     升级了 0 个软件包，新安装了 3 个软件包，要卸载 0 个软件包，有 256 个软件包未被升级。
     需要下载 4,519 kB 的软件包。
     解压缩后会消耗掉 38.9 MB 的额外空间。
   #+END_EXAMPLE

2. source code

   + git clone git://github.com/jgm/pandoc
   + cd pandoc
   + git submodule update --init
   + cabal install --force --enable-tests
   + cabal test

注：
- 使用 cabal

- Make sure the `$CABALDIR/bin` directory is in your path.

  #+BEGIN_EXAMPLE
  export PATH=~/.cabal/bin:$PATH
  #+END_EXAMPLE

- *没有必要使用源码方式*

***** dropbox 安装

- 下载(64bit for Ubuntu): https://www.dropbox.com/zh_CN/install?os=lnx

- dpkg install
  #+BEGIN_EXAMPLE
    $ sudo dpkg -i dropbox_2015.10.28_amd64.deb
    正在选中未选择的软件包 dropbox。
    (正在读取数据库 ... 系统当前共安装有 241104 个文件和目录。)
    正准备解包 dropbox_2015.10.28_amd64.deb  ...
    正在解包 dropbox (2015.10.28) ...
    正在设置 dropbox (2015.10.28) ...
    Please restart all running instances of Nautilus, or you will experience problems. i.e. nautilus --quit
    Dropbox installation successfully completed! You can start Dropbox from your applications menu.
    正在处理用于 gnome-menus (3.10.1-0ubuntu5) 的触发器 ...
    正在处理用于 desktop-file-utils (0.22-1ubuntu3) 的触发器 ...
    正在处理用于 bamfdaemon (0.5.1+15.04.20150202-0ubuntu1) 的触发器 ...
    Rebuilding /usr/share/applications/bamf-2.index...
    正在处理用于 mime-support (3.58ubuntu1) 的触发器 ...
    正在处理用于 hicolor-icon-theme (0.14-0ubuntu1) 的触发器 ...
    正在处理用于 man-db (2.7.0.2-5) 的触发器 ...
  #+END_EXAMPLE

*** 2016/01/08
**** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

**** gazebo

- ROS 建模

**** smartparens

- [[https://github.com/Fuco1/smartparens][Github]]
- [[https://github.com/Fuco1/smartparens/wiki][Wiki]]
- https://ebzzry.github.io/emacs-pairs.html

***** add pairs
1. global
  #+BEGIN_EXAMPLE
    (sp-pair "\{" "\}") ;; latex literal brackets (included by default)
    (sp-pair "<#" "#>")
    (sp-pair "$" "$")   ;; latex inline math mode. Pairs can have same opening and closing string
  #+END_EXAMPLE
2. local
   #+BEGIN_EXAMPLE
   (sp-local-pair 'LaTeX-mode "\\\\left(" "\\\\right)" :insert "C-b l" :trigger "\\\\l(")
   #+END_EXAMPLE

3. :wrap
   #+BEGIN_EXAMPLE
     (sp-pair "(" ")" :wrap "C-(")
   #+END_EXAMPLE

***** remove pairs
#+BEGIN_EXAMPLE
  ;; the second argument is the closing delimiter, so you need to skip it with nil
  (sp-pair "\{" nil :actions :rem)
  (sp-pair "'" nil :actions :rem)
#+END_EXAMPLE

***** wrapping

https://github.com/Fuco1/smartparens/wiki/Wrapping

#+BEGIN_SRC emacs-lisp
  (sp-local-pair 'org-mode "*" "*"
                 :wrap "*")
  (sp-local-pair 'org-mode "=" "="
                 :wrap "=")
  (sp-local-pair 'org-mode "/" "/"
                 :wrap "/")
  (sp-local-pair 'org-mode "\left(" "\n\\right)"
                 :trigger "\l(")
  (sp-local-pair 'org-mode "\left[" "\n\\right]"
                 :trigger "\l[")
  (sp-local-pair 'org-mode "\left{" "\n\\right}"
                 :trigger "\l{")
  (sp-local-pair 'org-mode "\\[" "\\]"
                 :trigger "\\[")
#+END_SRC

E=mc^2

**** wrap-region

+ [[https://github.com/rejeep/wrap-region.el][GitHub]]

Wrap Region is a minor mode for Emacs that wraps a region with
punctuations. For "tagged" markup modes, such as HTML and XML, it wraps
with tags.

***** Installation

I recommend installing via ELPA, but manual installation is simple as
well:

#+BEGIN_EXAMPLE
    (add-to-list 'load-path "/path/to/wrap-region")
    (require 'wrap-region)
#+END_EXAMPLE

***** Usage

Start =wrap-region-mode= using.

#+BEGIN_EXAMPLE
    (wrap-region-mode t)
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    M-x wrap-region-mode
#+END_EXAMPLE

Now try selecting a region and press any of the following keys: ="=,
='=, =(=, ={=, =[=.

The above are the default wrappers. You can add more yourself:

#+BEGIN_EXAMPLE
    (wrap-region-add-wrapper "$" "$")
    (wrap-region-add-wrapper "{-" "-}" "#")
    (wrap-region-add-wrapper "/" "/" nil 'ruby-mode)
    (wrap-region-add-wrapper "/* " " */" "#" '(java-mode javascript-mode css-mode))
    (wrap-region-add-wrapper "`" "`" nil '(markdown-mode ruby-mode))
#+END_EXAMPLE

The same can be done with:

#+BEGIN_EXAMPLE
    (wrap-region-add-wrappers
     '(("$" "$")
       ("{-" "-}" "#")
       ("/" "/" nil ruby-mode)
       ("/* " " */" "#" (java-mode javascript-mode css-mode))
       ("`" "`" nil (markdown-mode ruby-mode))))
#+END_EXAMPLE

For more information, see comments in =wrap-region.el=.

***** Except modes

In some modes, such as =calc-mode= and =dired-mode=, you don't want to
have wrap region active since the key bindings will conflict. Wrap
region stores a list of modes (see =wrap-region-except-modes=) in which
wrap region will be inactive.

Some modes are added to the except list by default. See the list with:

#+BEGIN_EXAMPLE
    (describe-variable 'wrap-region-except-modes)
#+END_EXAMPLE

To add a new mode, do this:

#+BEGIN_EXAMPLE
    (add-to-list 'wrap-region-except-modes 'conflicting-mode)
#+END_EXAMPLE

***** customize

****** wrap-region-add-wrapper

(wrap-region-add-wrapper LEFT RIGHT &optional KEY MODE-OR-MODES)

Add new LEFT and RIGHT wrapper.

Optional KEY is the trigger key and MODE-OR-MODES is a single
mode or multiple modes that the wrapper should trigger in.

****** global minor mode

#+BEGIN_SRC emacs-lisp
  (require 'wrap-region)
  (wrap-region-global-mode t)
#+END_SRC

****** org-mode

#+BEGIN_SRC emacs-lisp
  (wrap-region-add-wrappers
   '(("*" "*" "*" org-mode)
     ("=" "=" "=" org-mode)
     ("/" "/" "/" org-mode)
     ("$" "$" "$" org-mode)))
#+END_SRC

***** smartparens 可以替代，而且似乎更强大，同类产品只择其一

**** Eason

从2015年8月16日在微信上分享《天下无双》到12月31的《七百年后》，前前后
后一共听Eason四个半月，按发布顺序以每周一张的速度认真听了不下十五张专
辑。Eason 在我的心中已经封神。

今天一如继往听Eason的专辑《上五楼的快活》，2009年的国语专，主打“台风”。
然而对我来说，真的是一种忍受，根本不想再听第二遍。接着又看了其后几张专
辑的评论，仍然不尽如人意。进一步地关注了知乎上一些关于 Eason、Jay 和王
力宏等人的对比，问答间充斥着所谓“真粉“的武断式的论点。这为单纯的喜欢
陡然增加了嘈杂的因素---我知道这是该离开一段时间了。2016年听的Eason的首
张专辑没给我带来惊艳，反而让我畏缩了：我会有一天突然不喜欢我一直热爱的
东西么？这一时期的例子还有跑步。如果是真的的，那简直太可怕了。

等我回归 Eason 的时候，我就知道我会一直热爱自己所喜爱的事物的。此刻随
机循环着收藏的Eason单曲。

**** osrf

http://www.osrfoundation.org/

Open Source Robotics Foundation

**** 软件源配置

*/etc/apt/sources.list.d*

#+BEGIN_EXAMPLE
   $ ls /etc/apt/sources.list.d
  dartsim-ppa-trusty.list              libccd-debs-ppa-trusty.list
  dartsim-ppa-trusty.list.save         libccd-debs-ppa-trusty.list.save
  dropbox.list.save                    lotem-rime-trusty.list
  fcitx-team-nightly-trusty.list       lotem-rime-trusty.list.save
  fcitx-team-nightly-trusty.list.save  mc3man-trusty-media-trusty.list
  fcl-debs-ppa-trusty.list             mc3man-trusty-media-trusty.list.save
  fcl-debs-ppa-trusty.list.save        ros-latest.list
  gazebo-latest.list                   ros-latest.list.save
  gazebo-latest.list.save              timxx-xmradio-trusty.list
  gazebo-stable.list                   timxx-xmradio-trusty.list.save
  gazebo-stable.list.save              wengxt-fcitx-nightly-trusty.list
  gophers-go-trusty.list               wengxt-fcitx-nightly-trusty.list.save
  gophers-go-trusty.list.save
#+END_EXAMPLE

**** 新得立

#+BEGIN_EXAMPLE
E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。
#+END_EXAMPLE

后台调用 apt-get 解决依赖问题。

安装 gazebo6, OK

安装 ros-jade, 删除 gazebo6, 安装了 gazebo5

用不着参考安装指导完全使用命令行方式安装。
*可以增加了 source （软件源） 之后使用新得立安装*

*抽象出做的内容，方法只是表象*

**** ros matlab

http://jp.mathworks.com/hardware-support/robot-operating-system.html?requestedDomain=www.mathworks.com

http://www.ros.org/news/2014/01/mathworks-releases-robot-operating-system-ros-support-from-matlab.html

**** openni

**** ros jade

1. xacro
   #+BEGIN_EXAMPLE
     inconsistent namespace redefinitions for xmlns:xacro:
      old: http://ros.org/wiki/xacro
      new: http://wiki.ros.org/xacro (/home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/mecanum.xacro)
     xacro.py is deprecated; please use xacro instead
   #+END_EXAMPLE

2. CMakeLists.txt 链接依然是 indigo

   重新 catkin_init_workspace

**** 根目录空间不足

#+BEGIN_EXAMPLE
卷文件系统根目录仅剩余856M的硬盘空间
#+END_EXAMPLE

- 增加主分区容量，可以使用U盘启动ubuntu，然后用gparted调整
- 在分一个区，挂接到/var, /opt, 然后把已有文件copy过去就行
- 系统应该有个叫baobab的图形界面程序，点开看看/分区都有哪些东西占地方咯
- apt-get autoclean看看把安装软件下载的缓存清理掉
**** Linux 建立无线局域网与如何连接

http://ubuntuhandbook.org/index.php/2014/09/3-ways-create-wifi-hotspot-ubuntu/

http://roylez.herokuapp.com/2011/08/11/hostapd.html

**** Emacs 简体繁体转换

https://groups.google.com/forum/#!topic/cn.bbs.comp.emacs/0nNRwGaN1X8


#+BEGIN_QUOTE
似乎还没人写过，我觉得意义不大，
这种转换造成的问题比起的作用更多，
很多错别字或者读不通的文章都是这种转换造成的，
比如这句话：“国”字的繁体是“國”，
转成繁体后变成了：“國”字的繁體是“國”，意思完全不对了。
其实繁体的文章又不是读不懂，转换它干嘛？多此一举。
#+END_QUOTE

1. 使用 hanconvert ，失败 https://github.com/monkey413/tongwen-emacs

2. 使用谷歌翻译(网页版)

*** 2016/01/07
**** routine

1. 表格 or 格式化文本?

   后者

2. elisp+keybinding or yasnippet

   yasnippet

   - 可以有默认值
   - 必要的时候可以使用 elisp 函数

3. snippet

   #+BEGIN_SRC snippet
     # -*- mode: snippet; require-final-newline: nil -*-
     # name: rt:RoutinesExpandingForOrg-agenda
     # key: rt
     # binding: direct-keybinding
     # --
     睡眠:${1:1:00}
     起床:${2:7:00}
     跑步:${3:5K}
     吉它:${4:0.5h}
     读书:${5:0.5h}
     Friends:${6:S01E01}
     Dota:${7:45m}
     早餐:${8:1}
     锻炼:${9:0+0}
     牛奶:${10:1}
   #+END_SRC

**** doxygen API

1. PDF vs HTML

   更喜欢 PDF，可以标注、搜索方便等

2. API vs Source Code

   更喜欢后者！

**** IDE
***** Emacs VS Vim

Emacs 更熟悉

Vim 慢慢来

***** IDE & project
***** 目标

- [ ] 头文件与源文件之间跳转
- [ ] 浏览Linux内核树
- [ ] 交互式大纲显示文件结构
- [ ] 以文件浏览器形式显示静态大纲树
- [ ] 符号引用
- [ ] 代码补全
- [ ] 头文件补全
- [ ] 在底部显示函数接口和变量定义
- [ ] 跳转到当前函数头
- [ ] 编译支持
- [ ] 编译输出
- [ ] GDB调试
- [ ] 查看手册

***** 头文件与源文件之间跳转

**** usb camera                                           :camera:web_cam:

#+BEGIN_EXAMPLE
   ~ $ fswebcam --no-banner -r 640x480 demo.jpg
  --- Opening /dev/video0...
  Trying source module v4l2...
  /dev/video0 opened.
  No input was specified, using the first.
  --- Capturing frame...
  Captured frame in 0.00 seconds.
  --- Processing captured image...
  Disabling banner.
  Writing JPEG image to 'demo.jpg'.
#+END_EXAMPLE
***** /dev/vedio*

/dev/video0

#+BEGIN_EXAMPLE
$ lsusb
Bus 001 Device 006: ID 1e4e:0102 Cubeternet GL-UPC822 UVC WebCam
#+END_EXAMPLE


***** fswebcam: Small and simple webcam software for *nix      :fswebcam:

- [[http://manpages.ubuntu.com/manpages/lucid/man1/fswebcam.1.html][Ubuntu manpages]]
- [[https://github.com/fsphil/fswebcam][github]]
- [[http://www.firestorm.cx/fswebcam/][Homepage]]
- http://www.bkjia.com/Linuxjc/992291.html

****** man                                                         :man:
******* NAME


fswebcam - Small and simple webcam for *nix.

******* SYNOPSIS


fswebcam [<options>] <filename> [[<options>] <filename> ... ]

******* DESCRIPTION


fswebcam  is  a  small  and  simple webcam app for *nix. It can capture
images  from  a  number  of  different  sources  and   perform   simple
manipulation  on  the  captured image. The image can be saved as one or
more PNG or JPEG files.

The PNG or JPEG image can be sent to stdio using the filename "-".  The
output filename is formatted by strftime.

******* CONFIGURATION

******** Configuration File

Config  files  use the long version of options without the "--" prefix.
Comments start with a # symbol at the beginning of the line.

******** General Options
-?, --help
       Show a usage summary.

-c, --config
       Load  options  from  a  file.  You can load more than one config
       file, and can mix them with command-line arguments.

       Note: This option can not be used from  within  a  configuration
       file.

-q, --quiet
       Hides all messages except errors.

-v, --verbose
       Print extra information during the capture process.

--version
       Print the version number and exit.

-l, --loop <frequency>
       Continually capture images. The time between images is specified
       in seconds.

       Default behaviour is to capture a single image and exit.

       Note: The time to capture the next image is calculated  relative
       to  the epoch, so an image will not be captured immediately when
       the program is first started.

--offset <seconds>
       Sets the offset to use when calculating when the next  image  is
       due in loop mode. Value can be positive or negative.

-b, --background
       Run  in  the background. In this mode stdout and console logging
       are unavailable.

--pid <filename>
       Saves the PID of the background process to the  specified  file.
       Ignored when not using background mode.

--log [file/syslog:]<filename>
       Redirect log messages to a file or syslog. For example

       --log output.log
       --log file:output.log
       --log syslog

--gmt  Use  GMT instead of the local timezone when formatting text with
       strftime.

******** Capture Options
-d, --device [<prefix>:]<device name>
       Set the source or device to use. The source module  is  selected
       automatically unless specified in the prefix.

       Default is /dev/video0.

       Available source modules, in order of preference:

       V4L2 - Capture images from a V4L2 compatible video device.
       V4L1 - Capture images from a V4L1 compatible video device.
       FILE - Capture an image from a JPEG or PNG image file.
       RAW - Reads images straight from a device or file.
       TEST - Draws colour bars.

-i, --input <input number or name>
       Set  the  input  to  use. You may select an input by either it’s
       number or name.

       Default is "0".

--list-inputs
       List available inputs for the selected source or device.

       fswebcam -d v4l2:/dev/video1 --list-inputs

-t, --tuner <tuner number>
       Set the tuner to use.

-f, --frequency <frequency>
       Set the frequency of the selected input or tuner. The value  may
       be read as KHz or MHz depending on the input or tuner.

-p, --palette <name>
       Try  to use the specified image format when capturing the image.

       Default is to select one automatically.

       Supported formats:

       PNG
       JPEG
       MJPEG
       RGB32
       RGB24
       BGR32
       BGR24
       YUYV
       UYVY
       YUV420P
       BAYER
       RGB565
       RGB555
       GREY

-r, --resolution <dimensions>
       Set the image resolution of the source  or  device.  The  actual
       resolution  used  may  differ  if  the  source  or device cannot
       capture at the specified resolution.

       Default is "384x288".

--list-framesizes
       Lists the supported resolutions for the selected source.

--list-framerates
       Lists the supported frame rates  for  the  selected  source  and
       resolution.

-F, --frames <number>
       Set the number of frames to capture. More frames mean less noise
       in the final image, however capture times  will  be  longer  and
       moving objects may appear blurred.

       Default is "1".

-S, --skip <number>
       Set  the number of frames to skip. These frames will be captured
       but won’t be use. Use this option if your camera sends some  bad
       or corrupt frames when it first starts capturing.

       Default is "0".

-D, --delay <delay>
       Inserts  a  delay after the source or device has been opened and
       initialised, and before the capture begins.  Some  devices  need
       this  delay to let the image settle after a setting has changed.
       The delay time is specified in seconds.

-R, --read
       Use read() to capture images. This can be slower but more stable
       with some devices.

       Default  is  to  use mmap(), falling back on read() if mmap() is
       unavailable.

-s, --set <name=value>
       Set a control. These are used by the source modules  to  control
       image or device parameters. Numeric values can be expressed as a
       percentage of there  maximum  range  or  a  literal  value,  for
       example:

       --set brightness=50% --set framerate=5

       Non-numeric controls are also supported:

       --set lights=on

       V4L2  features  a  type  of  control  called  a  ’button’. These
       controls do not take any  value,  but  trigger  an  action.  For
       example:

       --set "Restore Factory Settings"

       Control names and values are not case sensitive.

       Note:  Available  controls  will  vary  depending  in the source
       module  and  devices  used.  For  more   information   see   the
       --list-controls option.

--list-controls
       List  available  controls  and  their  current  values  for  the
       selected source module and device. For example:

       fswebcam -d v4l2:/dev/video2 --list-controls

******** Output Options
These options are performed in the order they  appear  on  the  command
line,  only  effecting  images  output  later  on the command line. For
example:

       fswebcam -r 640x480 output1.jpeg --scale 320x240 output2.jpeg

       Will  create  two  images,  "output1.jpeg"  containing  a   full
       resolution   copy  of  the  captured  image  and  "output2.jpeg"
       containing the same captured image but scaled to half the  size.

--no-banner
       Disable the banner.

--top-banner
       Position the banner at the top of the image.

--bottom-banner
       Position the banner at the bottom of the image.

       This is the default.

--banner-colour <#AARRGGBB>
       Set  the  colour  of  the banner. Uses the web-style hexadecimal
       format (#RRGGBB) to describe the  colour,  and  can  support  an
       alpha channel (#AARRGGBB). Examples:

       "#FF0000" is pure red.
       "#80000000" is semi-transparent black.
       "#FF000000" is invisible (alpha channel is at maximum).
       Default is "#40263A93".

--line-colour <#AARRGGBB>
       Set the colour of the divider line. See --banner-colour for more
       information.

       Default is "#00FF0000".

--text-colour <#AARRGGBB>
       Set the  colour  of  the  text.  See  --banner-colour  for  more
       information.

       Default is "#00FFFFFF".

--font <[file or font name]:[font size]>
       Set  the  font  used  in the banner. If no path is specified the
       path in the GDFONTPATH environment variable is searched for  the
       font.

       If no font size is specified the default of "10" will be used.

       Default is "luxisr:10".

--no-shadow
       Disable the text shadow.

--shadow
       Enable the text shadow.

       This is the default behaviour.

--title <text>
       Set the main text, located in the top left of the banner.

--no-title
       Clear the main text.

--subtitle <text>
       Set  the  sub-title  text,  located  in  the  bottom left of the
       banner.

--no-subtitle
       Clear the sub-title text.

--timestamp <text>
       Set the timestamp text, located in the top right of the  banner.
       This string is formatted by strftime.

       Default is "%Y-%m-%d %H:%M (%Z)".

--no-timestamp
       Clear the timestamp text.

--info <text>
       Set the info text, located in the bottom right of the banner.

--no-info
       Clear the info text.

--underlay <filename>
       Load  a PNG image and overlay it on the image, below the banner.
       The image is aligned to the top left.

       Note: The underlay is only applied when saving an image  and  is
       not modified by any of the image options or effects.

--no-underlay
       Clear the underlay image.

--overlay <filename>
       Load a PNG image and overlay on the image, above the banner. The
       image is aligned to the top left.

       Note: The overlay is only applied when saving an  image  and  is
       not modified by any of the image options or effects.

--no-overlay
       Remove the overlay image.

--jpeg <factor>
       Set JPEG as the output image format. The compression factor is a
       value between 0 and 95, or -1 for automatic.

       This is the default format, with a factor of "-1".

--png <factor>
       Set PNG as the output image format. The compression  factor  can
       be a value between 0 and 9, or -1 for automatic.

--save <filename>
       Saves the image to the specified filename.

       Note:  This isn’t necessary on the command-line where a filename
       alone is enough to save an image.

--revert
       Revert to the  original  captured  image  and  resolution.  This
       undoes all previous effects on the image.

       Note:  This  only reverts the image itself, and not options such
       as font, colours and overlay.

--flip <direction[,direction]>
       Flips the image. Direction can be  (h)orizontal  or  (v)ertical.
       Example:

       --flip h    Flips the image horizontally.
       --flip h,v  Flips the image both horizontally and vertically.

--crop <dimensions[,offset]>
       Crop  the  image.  With  no  offset the cropped area will be the
       center of the image. Example:

       --crop 320x240    Crops the center 320x240 area of the image.
       --crop 10x10,0x0  Crops the 10x10 area at the top left corner of
       the image.

--scale <dimensions>
       Scale the image.

       Example:  "--scale  640x480"  scales  the  image  up  or down to
       640x480.

       Note: The aspect ratio of the image is not maintained.

--rotate <angle>
       Rotate the image in right angles (90, 180 and 270 degrees).

       Note: Rotating the  image  90  or  270  degrees  will  swap  the
       dimensions.

--deinterlace
       Apply a simple deinterlacer to the image.

--invert
       Invert all the colours in the image, creating a negative.

--exec <command>
       Executes  the  specified  command  and  waits for it to complete
       before continuing. The command line is formatted by strftime.

******* SIGNALS

SIGHUP This causes fswebcam to reload it’s configuration.

SIGUSR1
       Causes fswebcam to capture an image immediately without  waiting
       on the timer in loop mode.

****** help                                                       :help:

#+BEGIN_EXAMPLE
   ~ $ fswebcam --help
  Usage: fswebcam [<options>] <filename> [[<options>] <filename> ... ]

   Options:

   -?, --help                   Display this help page and exit.
   -c, --config <filename>      Load configuration from file.
   -q, --quiet                  Hides all messages except for errors.
   -v, --verbose                Displays extra messages while capturing
       --version                Displays the version and exits.
   -l, --loop <seconds>         Run in loop mode.
   -b, --background             Run in the background.
   -o, --output <filename>      Output the log to a file.
   -d, --device <name>          Sets the source to use.
   -i, --input <number/name>    Selects the input to use.
   -t, --tuner <number>         Selects the tuner to use.
   -f, --frequency <number>     Selects the frequency use.
   -p, --palette <name>         Selects the palette format to use.
   -D, --delay <number>         Sets the pre-capture delay time. (seconds)
   -r, --resolution <size>      Sets the capture resolution.
       --fps <framerate>        Sets the capture frame rate.
   -F, --frames <number>        Sets the number of frames to capture.
   -S, --skip <number>          Sets the number of frames to skip.
       --dumpframe <filename>   Dump a raw frame to file.
   -s, --set <name>=<value>     Sets a control value.
       --revert                 Restores original captured image.
       --flip <direction>       Flips the image. (h, v)
       --crop <size>[,<offset>] Crop a part of the image.
       --scale <size>           Scales the image.
       --rotate <angle>         Rotates the image in right angles.
       --deinterlace            Reduces interlace artifacts.
       --invert                 Inverts the images colours.
       --greyscale              Removes colour from the image.
       --swapchannels <c1c2>    Swap channels c1 and c2.
       --no-banner              Hides the banner.
       --top-banner             Puts the banner at the top.
       --bottom-banner          Puts the banner at the bottom. (Default)
       --banner-colour <colour> Sets the banner colour. (#AARRGGBB)
       --line-colour <colour>   Sets the banner line colour.
       --text-colour <colour>   Sets the text colour.
       --font <[name][:size]>   Sets the font and/or size.
       --no-shadow              Disables the text shadow.
       --shadow                 Enables the text shadow.
       --title <text>           Sets the main title. (top left)
       --no-title               Clears the main title.
       --subtitle <text>        Sets the sub-title. (bottom left)
       --no-subtitle            Clears the sub-title.
       --timestamp <format>     Sets the timestamp format. (top right)
       --no-timestamp           Clears the timestamp.
       --gmt                    Use GMT instead of local timezone.
       --info <text>            Sets the info text. (bottom right)
       --no-info                Clears the info text.
       --underlay <PNG image>   Sets the underlay image.
       --no-underlay            Clears the underlay.
       --overlay <PNG image>    Sets the overlay image.
       --no-overlay             Clears the overlay.
       --jpeg <factor>          Outputs a JPEG image. (-1, 0 - 95)
       --png <factor>           Outputs a PNG image. (-1, 0 - 10)
       --save <filename>        Save image to file.
       --exec <command>         Execute a command and wait for it to complete.

#+END_EXAMPLE

***** uvc                                                           :uvc:

USB Video Class (UVC)

**** usb_cam

- http://wiki.ros.org/usb_cam

A ROS Driver for V4L USB Cameras

***** usb_cam_node

The =usb_cam_node= interfaces with standard USB cameras (e.g. the
Logitech Quickcam) using libusb_cam and publishes images as
sensor_msgs::Image. Uses the [[/image_transport][image_transport]]
library to allow compressed image transport.

****** Published Topics

=~<camera_name>/image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image

****** Parameters

=~video_device= (=string=, default: ="/dev/video0"=)

-  The device the camera is on.

=~image_width= (=integer=, default: =640=)

-  Image width

=~image_height= (=integer=, default: =480=)

-  Image height

=~pixel_format= (=string=, default: ="mjpeg"=)

-  Possible values are mjpeg, yuyv, uyvy

=~io_method= (=string=, default: ="mmap"=)

-  Possible values are mmap, read, userptr

=~camera_frame_id= (=string=, default: ="head_camera"=)

-  The camera's tf frame

=~framerate= (=integer=, default: =30=)

-  The required framerate

=~contrast= (=integer=, default: =32=)

-  Contrast of video image (0-255)

=~brightness= (=integer=, default: =32=)

-  Brightness of video image (0-255)

=~saturation= (=integer=, default: =32=)

-  Saturation of video image (0-255)

=~sharpness= (=integer=, default: =22=)

-  Sharpness of video image (0-255)

=~autofocus= (=boolean=, default: =false=)

-  Enable camera's autofocus

=~focus= (=integer=, default: =51=)

-  If autofocus is disabled, the focus of the camera (0=at infinity)

=~camera_info_url= (=string=, default: ==)

-  An url to the camera calibration file that will be read by the
   [[/CameraInfoManager][CameraInfoManager]] class

=~camera_name= (=string=, default: =head_camera=)

-  The camera name. This must match the name in the camera calibration

****** Related packages

[[/gencam_cu][gencam_cu]] - supports image capture from usb cameras
using OpenCV
**** 电源

- UTM

  [[/home/ben/Wally/Journal//Figure/scrot/151903Kb.png]]

- Microstrain

  [[/home/ben/Wally/Journal//Figure/scrot/15190EVh.png]]

- raspberry

  5V 1.2A
  - GPIO ： 50mA
  - HDMI : 50mA
  - Camera: 250mA
  - keyboard/mice: 100mA~1000mA

- LMS 291

  [[/home/ben/Wally/Journal//Figure/scrot/15190Rfn.png]]

Power

12*3 + 5*0.08 < 40W

https://e2e.ti.com/blogs_/b/powerhouse/archive/2015/09/16/high-density-pcb-layout-of-dc-dc-converters-part-2



***** 纹波

纹波(ripple)是由于直流稳定电源的电压波动而造成的一种现象，因为直流稳定电源一般
是由交流电源经整流稳压等环节而形成的，这就不可避免地在直流稳定量中多少
带有一些交流成份，这种叠加在直流稳定量上的交流分量就称之为纹波。纹波的
成分较为复杂，它的形态一般为频率高于工频的类似正弦波的谐波，另一种则是
宽度很窄的脉冲波。
**** latex 梯度                                                     :梯度:

\nabla

**** image_view

Released Continuous integration Documented

A simple viewer for ROS image topics. Includes a specialized viewer for
stereo + disparity images.

***** Usage

****** Viewing a single image topic

#+BEGIN_EXAMPLE
    image_view image:=<image topic> [image transport type]
#+END_EXAMPLE

For example, to view raw images on the topic =/camera/image=, use:

#+BEGIN_EXAMPLE
    image_view image:=/camera/image
#+END_EXAMPLE

You may save the current image by left-clicking on the display window.
By default, images will be saved as =frame0000.jpg=, =frame0001.jpg=,
.... }}}

If you want to view a compressed image stream (usually a good idea over
wireless!) using the capabilities of
[[/image_transport][image_transport]], specify the transport type as a
command-line argument. For example, if
[[/theora_image_transport][theora_image_transport]] is built on the
publisher's side, you can use =theora= transport:

#+BEGIN_EXAMPLE
    image_view image:=/camera/image theora
#+END_EXAMPLE

Note that this is merely shorthand equivalent to setting the
=~image_transport= parameter:

#+BEGIN_EXAMPLE
    image_view image:=/camera/image _image_transport:=theora
#+END_EXAMPLE

****** Viewing stereo images

#+BEGIN_EXAMPLE
    stereo_view stereo:=<stereo namespace> image:=<image topic identifier>
#+END_EXAMPLE

For example, to view stereo image pairs on topics
=/my_stereo_cam/left/image_rect_color= and
=/my_stereo_cam/right/image_rect_color=, use:

#+BEGIN_EXAMPLE
    stereo_view stereo:=/my_stereo_cam image:=image_rect_color
#+END_EXAMPLE

=stereo_view= also shows the disparity image computed from the stereo
pair, color-mapped for clarity.

You may save the current image pair by left-clicking on either display
window. By default, images will be saved as =left0000.jpg=,
=right0000.jpg=, =left0001.jpg=, =right0001.jpg=....

***** Nodes

****** image_view

Simple image viewer for ROS topics.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~filename_format= (=string=, default: ="frame%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image stream. =image_view= allows you to
   specify this as a simple command-line argument for convenience.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

****** stereo_view

Viewer for stereo images. Shows the left/right image pair and the
disparity image (color-mapped) computed from them.
******* Subscribed Topics

=<stereo>/left/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The left image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/right/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The right image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/disparity=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

-  The disparity image computed from the left/right stereo pair.

******* Parameters

=~autosize= (=bool=, default: true)

-  Whether the windows should autosize to the image or be resizeable by
   the user.

=~filename_format= (=string=, default: ="%s%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images. The string argument is ="left"=
   or ="right"=.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image streams.

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div
  class="version diamondback electric fuerte groovy hydro indigo jade">
#+END_HTML

#+BEGIN_HTML
  <div id="image_view.2BAC8-diamondback.content" dir="ltr" lang="en">
#+END_HTML

#+BEGIN_HTML
  <div class="table-of-contents">
#+END_HTML

Contents

1. [[#image_view.2BAC8-diamondback.Usage][Usage]]

   1. [[#image_view.2BAC8-diamondback.Viewing_a_single_image_topic][Viewing
      a single image topic]]
   2. [[#image_view.2BAC8-diamondback.Viewing_stereo_images][Viewing
      stereo images]]

2. [[#image_view.2BAC8-diamondback.Nodes][Nodes]]

   1. [[#image_view.2BAC8-diamondback.image_view][image_view]]
   2. [[#image_view.2BAC8-diamondback.disparity_view][disparity_view]]
   3. [[#image_view.2BAC8-diamondback.stereo_view][stereo_view]]

3. [[#image_view.2BAC8-diamondback.Nodelets][Nodelets]]

   1. [[#image_view.2BAC8-diamondback.image_view.2BAC8-image][image_view/image]]
   2. [[#image_view.2BAC8-diamondback.image_view.2BAC8-disparity][image_view/disparity]]

4. [[#image_view.2BAC8-diamondback.Tools][Tools]]

   1. [[#image_view.2BAC8-diamondback.image_saver][image_saver]]
   2. [[#image_view.2BAC8-diamondback.extract_images][extract_images]]
   3. [[#image_view.2BAC8-diamondback.video_recorder][video_recorder]]

#+BEGIN_HTML
  </div>
#+END_HTML

***** Usage

****** Viewing a single image topic

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=<image topic> [image transport type]
#+END_EXAMPLE

For example, to view raw images on the topic =/camera/image=, use:

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=/camera/image
#+END_EXAMPLE

You may save the current image by right-clicking on the display window.
By default, images will be saved as =frame0000.jpg=, =frame0001.jpg=,
....

If you want to view a compressed image stream (usually a good idea over
wireless!) using the capabilities of
[[/image_transport][image_transport]], specify the transport type as a
command-line argument. For example, if
[[/theora_image_transport][theora_image_transport]] is built on the
publisher's side, you can use =theora= transport:

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=/camera/image theora
#+END_EXAMPLE

Note that this is merely shorthand equivalent to setting the
=~image_transport= parameter:

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=/camera/image _image_transport:=theora
#+END_EXAMPLE

****** Viewing stereo images

#+BEGIN_EXAMPLE
    rosrun image_view stereo_view stereo:=<stereo namespace> image:=<image topic identifier>
#+END_EXAMPLE

For example, to view stereo image pairs on topics
=/my_stereo_cam/left/image_rect_color= and
=/my_stereo_cam/right/image_rect_color=, use:

#+BEGIN_EXAMPLE
    rosrun image_view stereo_view stereo:=/my_stereo_cam image:=image_rect_color
#+END_EXAMPLE

=stereo_view= also shows the disparity image computed from the stereo
pair, color-mapped for clarity.

You may save the current image pair by right-clicking on any display
window. By default, images will be saved as =left0000.jpg=,
=right0000.jpg=, =disp0000.jpg=, =left0001.jpg=, =right0001.jpg=,
=disp0001.jpg=.... As with =image_view=, you can specify an image
transport to use for the left and right image as an optional argument.

***** Nodes

****** image_view

Simple image viewer for ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topics.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~filename_format= (=string=, default: ="frame%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image stream. =image_view= allows you to
   specify this as a simple command-line argument for convenience.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

****** disparity_view

Simple viewer for
[[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]]
topics. Color-maps the disparity image for visualization.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

-  The disparity image topic. Should be remapped to the name of the real
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

****** stereo_view

Viewer for stereo images. Shows the synchronized left/right image pair
and the disparity image (color-mapped) computed from them.
******* Subscribed Topics

=<stereo>/left/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The left image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/right/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The right image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/disparity=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

-  The disparity image computed from the left/right stereo pair.

******* Parameters

=~autosize= (=bool=, default: true)

-  Whether the windows should autosize to the image or be resizeable by
   the user.

=~filename_format= (=string=, default: ="%s%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images. The string argument is ="left"=
   or ="right"=.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image streams.

=~approximate_sync= (=bool=, default: false)

-  Whether to use approximate synchronization. Set to true if the left
   and right cameras do not produce exactly synced timestamps.

=~queue_size= (=int=, default: 5)

-  Size of message queue for each synchronized topic. You may need to
   raise this if disparity processing takes too long, or if there are
   significant network delays.

***** Nodelets

****** image_view/image

Nodelet version of image_view. Brings up a display window for a
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~filename_format= (=string=, default: ="frame%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image stream. =image_view= allows you to
   specify this as a simple command-line argument for convenience.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

****** image_view/disparity

Nodelet version of disparity_view. Brings up a display window for a
[[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]]
topic, color-mapped for visualization.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

-  The disparity image topic. Should be remapped to the name of the real
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

#+BEGIN_HTML
  <div class="version hydro_and_newer">
#+END_HTML

***** Tools

****** image_saver

This tool allows you to save images as jpg/png file from streaming (ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic) to a file.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

******* Services

=save=
([[http://docs.ros.org/api/std_srvs/html/srv/Empty.html][std_srvs/Empty]])

-  Save images, you need to set save_all_images to false

******* Parameters

=~filename_format= (=string=, default: =left%04d.%s=)

-  File name for saved images, you can use '%04i' for sequence number,
   and '%s' for default file format, you can use 'jpg' ,'png', 'pgm' as
   filename suffixes.

=~encoding= (=string=, default: 'bgr8')

-  Encoding type of input image topic.

=~save_all_image= (=bool=, default: true)

-  If you set false, images are only saved when 'save' service is called

****** extract_images

This tool also allows you to save images as jpg/png file from streaming
(ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic) to a file. =image_saver= node provide very similar
functionalities, such as providing service call to trigger the node to
save images, save images other than Jpeg format, etc.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~filename_format= (=string=, default: =frame%04d.jpg=)

-  File name for saved images, you must add use '%04i' for sequence
   number.

=~sec_per_frame= (=double=, default: '0.1')

-  set sec per frame value.

****** video_recorder

This tool allows you to record a video stream (ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic) to a file. It relies on
[[http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videowriter][OpenCV's
VideoWriter class]]. With the default options, it encodes the video as
MPG, encapsulated in a AVI container at 15 fps, and produces a file
called =output.avi= in the current directory.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~filename= (=string=, default: =output.avi=)

-  Path and name of the output video.

=~fps= (=int=, default: 15)

-  Framerate of the video.

=~codec= (=string=, default: =MJPG=)

-  The [[http://www.fourcc.org/codecs.php][FOURCC]] identifier of the
   codec.

=~encoding= (=string=, default: =bgr8=)

-  The image color space of the video.
*** 2016/01/06
**** vtk: Visualization Toolkit

The *Visualization Toolkit* (VTK) is an *open-source*, freely available
software system for _3D computer graphics, image processing, and
visualization._ It consists of =a C++ class library= and several
interpreted =interface= layers including Tcl/Tk, Java, and
*Python*. Kitware, whose team created and continues to extend the
toolkit, offers professional support and consulting services for
VTK. VTK supports a wide variety of *visualization algorithms* including
scalar, vector, tensor, texture, and volumetric methods, as well as
advanced modeling techniques such as implicit modeling, polygon
reduction, mesh smoothing, cutting, contouring, and Delaunay
triangulation. VTK has an extensive information visualization
framework and a suite of 3D interaction widgets. The toolkit supports
parallel processing and integrates with various databases on GUI
toolkits such as *Qt and Tk*. VTK is *cross-platform* and runs on Linux,
Windows, Mac, and Unix platforms.

**** org-download

- https://github.com/abo-abo/org-download


#+BEGIN_SRC emacs-lisp
  (require 'org-download)
  (setq org-download-method 'directory)
  (setq-default org-download-image-dir
                (concat (getenv "JOURNAL-WS") "/Figure/.org-download")) ; org-down 文件命名有时会比较丑，所以放在隐藏文件夹下
  (setq org-download-heading-lvl nil)
  (setq org-download-timestamp "_%Y-%m-%d_%H:%M:%S")
  ;; (define-key org-mode-map "\C-c\M-s" 'org-download-screenshot)
  (define-key org-mode-map "\C-c\M-y" 'org-download-yank)
  (setq org-download-backend "wget \"%s\" -O \"%s\"")
#+END_SRC

1. 从 chrome 中拖拽不管用

   委曲求全： 右键图片，复制图片网址， *org-download-image*

   #+BEGIN_EXAMPLE
     org-download-image is an interactive compiled Lisp function in
     `org-download.el'.

     (org-download-image LINK)

     Save image at address LINK to `org-download--dir'.
   #+END_EXAMPLE

2. 从 Firefox 中拖拽起作用
3. 从系统的文件管理器中拖拽起作用

*** 2016/01/04
**** chrome 下载文件命名编码

1. why?

   百度云打包下载的压缩文件命名正确，解压后出现乱码

2. 设置 chrome 字体编码

   http://jingyan.baidu.com/article/e52e36154b3ff640c70c515f.html
   http://www.tuicool.com/articles/VjInAf

   扳手-------->Settings（设置）-------->ShowAdvance Settings（显示高
   级设置）-------->Web Content（网页内容）-------->Customizefonts（自
   定义字体）-------->Encoding（编码）

3. 不是 chrome 的问题，是百度云的问题，没解决，不重要

   http://www.zhihu.com/question/28144692

**** RS232                                                         :rs232:
***** RS-232 Wiki


*RS-232* 是美国[[/wiki/%E7%94%B5%E5%AD%90%E5%B7%A5%E4%B8%9A%E8%81%94%E7%9B%9F][电子工业联盟]]（EIA）制定的串行数据通信的接口标准。它被广
泛用于计算机串行接口外设连接。


它規定連接[[/wiki/%E9%9B%BB%E7%BA%9C][電纜]]和[[/wiki/%E6%A9%9F%E6%A2%B0][機械]]、[[/wiki/%E9%9B%BB%E6%B0%A3][電氣]]特性、信號功能及傳送過程。其他常用電氣標準還有
[[/wiki/EIA-422][EIA-RS-422-A]]、[[/w/index.php?title=EIA-423&action=edit&redlink=1][EIA-RS-423A]]、[[/wiki/RS-485][EIA-RS-485]]。

由於RS-232-C的重大影響，即使自IBM [[/wiki/PC/AT][PC/AT ]]開始改用9針連接器起，目前已幾
乎不再使用RS-232中規定的25針連接器，但大多數人仍然普遍使用RS-232C來代
表此一介面。

****** 标准的细节

在RS-232标准中，字符是以一序列的位元串来一个接一个的[[/w/index.php?title=%E4%B8%B2%E5%88%97&action=edit&redlink=1][串列]]（serial）方式
傳輸，優點是傳輸線少，配線簡單，傳送距離可以較遠。最常用的编码格式是异
步起停（asynchronous start-stop）格式，它使用一个起始位元后面紧跟7或8
个数据位元（bit），然后是可选的奇偶校验位元，最后是一或两个停止位元。
所以发送一个字符至少需要10位元，带来的一个好的效果是使全部的传输速率，
发送信号的速率以10划分。一个最平常的代替异步起停方式的是使用[[/wiki/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6][高级数据链
路控制]]协议（HDLC）。

在RS-232标准中定义了逻辑一和逻辑零电压级数，以及标准的传输速率和连接器
类型。信号大小在正的和负的3－15v之间。RS-232规定接近零的电平是无效的，
逻辑一规定为负电平，有效负电平的信号状态称为传号marking，它的功能意义
为OFF，逻辑零规定为正电平，有效正电平的信号状态称为空号spacing，它的功
能意义为ON。根据设备供电电源的不同，±5、±10、±12和±15这样的电平都
是可能的。


******* 连接器

RS-232設計之初是用來連接數據機做傳輸之用，也因此它的腳位意義通常也和數
據機傳輸有關。RS-232的设备可以分为数据终端设备（DTE，Data Terminal
Equipment, For example, PC）和数据通信设备（DCE，Data Communication
Equipment）两类，这种分类定义了不同的线路用来发送和接受信号。一般来说，
计算机和终端设备有DTE连接器，调制解调器和打印机有DCE连接器。但是这么说
并不是总是严格正确的，用配线分接器测试连接，或者用试误法来判断电缆是否
工作，常常需要参考相关的文件说明。

RS-232指定了20个不同的信号连接，由25个D-sub（微型D类）管脚构成的DB-25
连接器。

很多设备只是用了其中的一小部分管脚，出于节省资金和空间的考虑不少机器采
用较小的连接器，特别是9管脚的D-sub或者是 *DB-9* 型连接器被广泛使用绝大
多数自IBM的AT机之后的PC机和其他许多设备上。DB-25 和 DB-9 型的连接器在大部
分设备上是雌型，但不是所有的都是这样。

下表中列出的是被较多使用的RS-232中的信号和管脚分配：

#+BEGIN_EXAMPLE
               DE-9 Male（Pin Side）                   DE-9 Female (Pin Side）
                 -------------                          -------------
                 \ 1 2 3 4 5 /                          \ 5 4 3 2 1 /
                  \ 6 7 8 9 /                            \ 9 8 7 6 /
                   ---------                              ---------
#+END_EXAMPLE

| 信号                | DB-25 | DE-9 | EIA/TIA 561 | Yost |
|---------------------+-------+------+-------------+------|
| 公共接地            |     7 |    5 |           4 |  4,5 |
| 发送数据（TD、TXD） |     2 |    3 |           6 |    3 |
| 接受数据（RD、RXD） |     3 |    2 |           5 |    6 |
| 数据终端准备（DTR） |    20 |    4 |           3 |    2 |
| 数据准备好（DSR）   |     6 |    6 |           1 |    7 |
| 请求发送（RTS）     |     4 |    7 |           8 |    1 |
| 清除发送（CTS）     |     5 |    8 |           7 |    8 |
| 数据载波检测（DCD） |     8 |    1 |           2 |    7 |
| 振铃指示（RI）      |    22 |    9 |           1 |   － |

| 腳位 | 簡寫 | 意義                | 說明                           |
|------+------+---------------------+--------------------------------|
| Pin1 | CD   | Carrier Detect      | 數據機通知電腦有載波被偵測到。 |
| Pin2 | RXD  | Receiver            | 接收資料。                     |
| Pin3 | TXD  | Transmit            | 傳送資料。                     |
| Pin4 | DTR  | Data Terminal Ready | 電腦告訴數據機可以進行傳輸。   |
| Pin5 | GND  | Ground              | 地線。                         |
| Pin6 | DSR  | Data Set Ready      | 數據機告訴電腦一切準備就緒。   |
| Pin7 | RTS  | Request To Send     | 電腦要求數據機將資料送出。     |
| Pin8 | CTS  | Clear To Send       | 數據機通知電腦可以傳資料過來。 |
| Pin9 | RI   | Ring Indicator      | 數據機通知電腦有電話進來。     |

TXD DTE->DCE DTE SEND DATA

RXD DCE->DTE DTE RECEIVE DATA

RTS DTE->DCE DTE REQUEST SEND

CTS DCE->DTE ACK TO DTE'S RTS

DSR DCE->DTE DCE IS READY

GND

DCD DCE->DTE DC DETECTED

DTR DTE->DCE DTE IS READY

RI DCE->DTE RING INDICATION

信号的标注是从DTE设备的角度出发的，TD、DTR和RTS信号是由DTE产生的，RD、DSR、CTS、DCD和RI信号是由DCE产生的。接地信号是所有连接都公共的，在Yost的标准中接地信号外部有两个管脚事实上是同一个信号。如果两个通信设备的距离相差的很远或者是有两个不同的供电系统供电，那么地信号在两个设备间会不一样，从而导致通信失败，跟踪描述这样的情形是很困难的。

******* 设置

串行通信在软件设置里需要做多项设置，最常见的设置包括[[/wiki/%E6%B3%A2%E7%89%B9%E7%8E%87][波特率]]（Baud）、奇偶校验（Parity
Check）和停止位（Stop Bit）。

-  波特率（又称[[/wiki/%E9%AE%91%E7%8E%87][鮑率]]）：是指从一设备发到另一设备的波特率，即每秒钟多少符號。典型的波特率是300,
   1200, 2400, 9600, 19200,
   115200等。一般通信两端设备都要设为相同的波特率，但有些设备也可设置为自动检测波特率。

-  奇偶校验（Parity：是用来验证数据的正确性。奇偶校验一般不使用，如果使用，那么既可以做奇校验（Odd
   Parity）也可以做偶校验（Even
   Parity）。奇偶校验是通过修改每一发送字节（也可以限制发送的字节）来工作的。如果不作奇偶校验，那么数据是不会被改变的。在偶校验中，因为奇偶校验位会被相应的置1或0（一般是最高位或最低位），所以数据会被改变以使得所有传送的数位（含字符的各数位和校验位）中“1”的个数为偶数；在奇校验中，所有传送的数位（含字符的各数位和校验位）中“1”的个数为奇数。奇偶校验可以用于接受方检查传输是否发送生错误------如果某一字节中“1”的个数发生了错误，那么这个字节在传输中一定有错误发生。如果奇偶校验是正确的，那么要么没有发生错误要么发生了偶数个的错误。如果使用者選擇資料長度為8位元，則因為沒有多餘的位元可被用來作為同位元，因此就叫做「非奇偶校验（Non
   Parity）」。

-  停止位：是在每个字节传输之后发送的，它用来帮助接受信号方硬件重同步。

RS-232在傳送資料時，並不需要另外使用一條傳輸線來傳送同步訊號，就能正確
的將資料順利傳送到對方，因此叫做「非同步傳輸」，簡稱UART（Universal
Asynchronous Receiver Transmitter），不過必須在每一筆資料的前後都加上
同步訊號，把同步訊號與資料混和之後，使用同一條傳輸線來傳輸。

在串行通信软件设置中D/P/S是常规的符号表示。8/N/1（非常普遍）表明8bit数
据，没有奇偶校验，1bit停止位。数据位可以设置为5、6、7或者8位元（不可以
大於8或小於5），奇偶校验位可以设置为无（N）、奇（O）或者偶（E），奇偶
校验可以使用数据中的位元（bit），所以8/E/1就表示一共8位数据位，其中一
位用来做奇偶校验位。停止位可以是1、1.5或者2位的（1.5是用在波特率为
60wpm的电传打字机上的）。


-  流量控制：当需要发送[[/wiki/%E6%8F%A1%E6%89%8B%E4%BF%A1%E5%8F%B7][握手信号]]或数据完整性检测时需要制定其他设置。公用的组合有RTS/CTS,
   DTR/DSR或者XON/XOFF（实际中不使用连接器管脚而在数据流内插入特殊字符）。

****** 類似規範

-  [[/wiki/%E5%9B%BD%E9%99%85%E7%94%B5%E4%BF%A1%E8%81%94%E7%9B%9F%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84][ITU-T]]（前CCITT）的對應規範，用語不同，但電氣規格幾乎相同

   -  ITU-T V.28

-  具有相似的通信目的，但功能與電氣規範不同

   -  [[/wiki/RS-422][RS-422]]
   -  [[/w/index.php?title=RS-423&action=edit&redlink=1][RS-423]]
   -  [[/wiki/RS-449][RS-449]]
   -  [[/wiki/RS-485][RS-485]]

****** 外部連結

-  [[http://www.zywyn.com.tw/index.php][RS-232 professional maker (ZYWYN.com）]]
-  [[http://www.camiresearch.com/Data_Com_Basics/RS232_standard.html][RS-232 tutorial]]
-  [[http://www.yost.com/Computers/RJ45-serial/][Yost Serial Device Wiring Standard]]
-  [[http://www.acumeninstruments.com/Support/documentation/SerialPortBasics/index.shtml][Serial Port Basics]]
-  [[http://www.lammertbies.nl/comm/info/RS-232.html][RS232 serial port info]]
-  [[http://www.tronisoft.com/rs232info/ASCII_serial_port_crib_sheets.pdf][Printable ASCII Serial Port Crib Sheets]]

***** RS232

- http://c.biancheng.net/cpp/html/1919.html

标准串口，在物理结构上分为 9 针的和 9 孔的，习惯上我们也称之为公头和母
头

[[/home/ben/Wally/Journal//Figure/scrot/2983mBR.png]]

RS232 接口一共有 9 个引脚，分别定义是：1、载波检测 DCD；2、接收数据
RXD；3、发送数据 TXD；4、数据终端准备好 DTR；5、信号地线 SG；6、数据准
备好 DSR；7、请求发送 RTS；8、清除发送 CTS；9、振铃提示 RI。我们要让这
个串口和我们单片机进行通信，我们只需要关心其中的 2 脚 RXD、3 脚 TXD 和
5 脚 GND 即可。

虽然这三个引脚的名字和我们单片机上的串口名字一样，但是却不能直接和单片
机对连通信，这是为什么呢？随着我们了解的内容越来越多，我们得慢慢知道，
不是所有的电路都是 5V 代表高电平而 0V 代表低电平的。对于 RS232 标准来
说，它是个反逻辑，也叫做负逻辑。为何叫负逻辑？它的 TXD 和 RXD 的电
压，-3V～-15V 电压代表是 1，+3～+15V 电压代表是 0。低电平代表的是 1，
而高电平代表的是 0，所以称之为负逻辑。因此电脑的 9 针 RS232串口是不能
和单片机直接连接的，需要用一个电平转换芯片 MAX232 来完成.

[[/home/ben/Wally/Journal//Figure/scrot/2983zLX.png]]

 RS232 串口和 UART 串口，它们的协议类型是一样的，只是电平标准不同而已，
 而 MAX232 这个芯片起到的就是中间人的作用，它把 UART 电平转换成 RS232
 电平，也把 RS232 电平转换成 UART 电平，从而实现标准 RS232接口和单片机
 UART 之间的通信连接。

***** RS485                                                       :rs485:
****** EIA-485 wiki                                               :wiki:

*EIA-485*（过去叫做*RS-485*或者*RS485*）是隶属于[[/wiki/OSI%E6%A8%A1%E5%9E%8B][OSI模型]][[/wiki/%E7%89%A9%E7%90%86%E5%B1%82][物理层]]的电气特
性规定为2线，[[/wiki/%E5%8D%8A%E9%9B%99%E5%B7%A5][半双工]]，多点通信的标准。它的电气特性和[[/wiki/RS-232][RS-232]]不大一样。用
缆线两端的[[/wiki/%E7%94%B5%E5%8E%8B][电压]]差值来表示传递信号，1极的电压标识为逻辑1，另一段标识为逻
辑0。两端的电压差最小为0.2V以上时有效，任何不大于12V或者不小于－7V的差
值对接受端都被认为是正确的。

EIA-485仅仅规定了接受端和发送端的电气特性。它没有规定或推荐任何数据协
议。EIA-485可以应用于配置便宜的[[/wiki/%E5%B9%BF%E5%9F%9F%E7%BD%91][广域网]]和采用单机发送，多机接受通信链接。
它提供高速的数据通信速率（10m时35[[/w/index.php?title=Bitrate&action=edit&redlink=1][Mbit/s]]；1200m时100[[/w/index.php?title=Bitrate&action=edit&redlink=1][kbit/s]]1200m）。

EIA-485和[[/wiki/EIA-422][EIA-422]]一样使用双绞线进行高电压差分平衡传输，它可以进行大面积
长距离传输（超过4000[[http://zh.wikipedia.org/wiki/%E8%8B%B1%E5%B0%BA][英尺]]，1200米）。

和EIA-422相对照的是，EIA-422采用不可转换的单发送端，EIA-485的发送端需
要设置为发送模式，这使得EIA-485可以使用双线模式实现真正的多点双向通信。

EIA-485推荐使用在点对点网络中，线型、总线型，不能是星型、环型网络。理
想情况下EIA-485需要2个终接电阻，其阻值要求等于传输电缆的特性阻抗。没有
特性阻抗的话，当所有的设备都静止或者没有能量的时候就会产生噪声，而且线
移需要双端的电压差。没有终接电阻的话，会使得较快速的发送端产生多个数据
信号的边缘，这其中的一些是不正确的。之所以不能使用星型或者环型的拓扑结
构是由于这些结构有不必要的反映，过低或者过高的终接电阻可以产生电磁干扰。

EIA-485在使用四线时可以和EIA-422一样实现[[/wiki/%E5%85%A8%E9%9B%99%E5%B7%A5][全双工]]。EIA-485可以实现真正的
多点通信，在许多情况下并没有什么用处。在某些限制条件下，EIA-485和
EIA-422可以实现相互的连接。

******* 比较

下面的表格列出了RS-485的一些特性和引脚的分配以及和[[/wiki/RS-232][RS-232]]的比较：

| EIA-485                    | [[/wiki/RS-232][RS-232]]                    | [[/w/index.php?title=D-subminiature&action=edit&redlink=1][DB-25]] | [[/w/index.php?title=D-subminiature&action=edit&redlink=1][DE-9]] | [[/w/index.php?title=RJ-50&action=edit&redlink=1][RJ-50]] |
|----------------------------+---------------------------+-------+------+-------|
| Common Ground              | Carrier Detect（DCD）     |     8 |    1 |    10 |
| Clear To Send +（CTS+）    | Received Data (RD)        |     3 |    2 |     9 |
| Ready To Send +（RTS+）    | Transmitted Data (TD)     |     2 |    3 |     8 |
| Received Data +（RxD+）    | Data Terminal Ready (DTR) |    20 |    4 |     7 |
| Received Data -（RxD-）    | Common Ground             |     7 |    5 |     6 |
| Clear To Send -（CTS-）    | Data Set Ready (DSR)      |     6 |    6 |     5 |
| Ready To Send -（RTS-）    | Request To Send (RTS)     |     4 |    7 |     4 |
| Transmitted Data +（TxD+） | Clear To Send (CTS)       |     5 |    8 |     3 |
| Transmitted Data -（TxD-） | Ring Indicator (RI)       |    22 |    9 |     2 |

**** Navigator

***** note

1. STM32 主控
2. 模块化： 每一个模块通过 CAN 或 UART 可以发送命令或接收数据
3. 可编程！！！
4. 有内部使用的CAN控制器
5. 使用CAN

***** 需要用它干嘛？

1. 获取编码器数据用于计算位置
2. 发送控制指令
3. 指令的封装？？ ROS how?

***** 暂时没有能力做这件事情。。。。

***** 复制到 Reference 目录下新建的 Product 文件夹下

**** auctex 按键绑定移植到 org 中

C-c C-f 前缀

#+BEGIN_EXAMPLE
  C-a                          \mathcal{ }
  C-b        \textbf{ }         \mathbf{ }
  C-c        \textsc{ }
  C-e          \emph{ }
  C-f        \textsf{ }         \mathsf{ }
  TAB        \textit{ }         \mathit{ }
  RET        \textmd{ }
  C-n    \textnormal{ }     \mathnormal{ }
  C-r        \textrm{ }         \mathrm{ }
  C-s        \textsl{ }         \mathbb{ }
  C-t        \texttt{ }         \mathtt{ }
  C-u        \textup{ }
  C-d  -- delete font
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  ;; (mapc (lambda(key-macro)
  ;;         (define-key org-mode-map (format "\C-cf%s" (car key-macro)) '(insert (cdr key-macro))))
  ;;       '(("i" "\\mathit{}")            ; note: escapte needed
  ;;         ("I" "\\textit{}")
  ;;         ("b" "\\mathbf{}")
  ;;         ("B" "\\textbf{}")))

  (define-key org-mode-map "\C-cfi" '(insert "\\mathbf{}"))
#+END_SRC

1. 不能使用 C-c C-f 作为前缀，因为已经绑定了
2. 不如使用 yasnippet

#+BEGIN_EXAMPLE
# -*- mode: snippet; require-final-newline: nil -*-
# name: mb:latex-mathbf
# key: mb
# binding: direct-keybinding
# --
\mathbf{$0}
#+END_EXAMPLE

**** IMU

project imutb simulation

*** 2016/01/03
**** BBDB: 通讯录管理
***** Reference

- [[http://savannah.nongnu.org/projects/bbdb/][Homepage]]
- [[http://bbdb.sourceforge.net/][Sourceforge(旧的项目主页)]]
- [[http://www.emacswiki.org/emacs/CategoryBbdb][EmacsWiki: Bddb category]]
- [[https://github.com/emacs-china/hello-emacs/blob/master/bbdb%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.org][Github 上的中文教程]]

***** Intro

BBDB is the Insidious =Big Brother Database= for GNU Emacs. It provides
_an address book for email and snail mail addresses, phone numbers and
the like_. It can be linked with various Emacs mail clients (Message
and Mail mode, Rmail, Gnus, MH-E, and VM). BBDB is fully customizable.

#+BEGIN_QUOTE
big brother DB, 用来管理数据的，比如mailing address book等等，和Gnus搭
配着用。Zawinski写的。

BBDB我主要是用来做通讯录管理， 它与gnus发邮件互通， 效果十分好。

BBDB里， 头像支持图片。 然后写一小段lisp代码， 它BBDB的数据转成vCard通
讯录格式， 定期同步到手机上。

#+END_QUOTE
***** 概念

- [[http://baike.baidu.com/link?url=WuKUitPM002pg1xs8GguhXm4nV8pqZcnY47opo6WmnfAz3QmGv3nMdJ3kDst5yP8_dv2pe3sBv7_dkCoopOFmK][vCard]]: 电子名片
- csv：网络交易平台商品信息数据包

***** 安装

1. 源码方式
2. Melpa

   #+BEGIN_EXAMPLE
     I bbdb               20151114.... available  melpa      The Insidious Big Brother Database for GNU Emacs
     I bbdb-android       20150705.... available  melpa      Android phone contacts import/export for BBDB
     I bbdb-china         20150615.... available  melpa      BBDB utils, which let Chinese BBDB users feel easy
     I bbdb-vcard         20150713.... available  melpa      vCard import/export for BBDB
   #+END_EXAMPLE

***** 使用

1. M-x bbdb-xxxx
2. M-x bbdb-vcard-xxx

***** bbdb简单使用教程

#  Github 上使用 org-mode 写的教程，相当不错

****** 配置

最简单的配置方法就是将下面的语句放入Emacs初始化文件中

#+BEGIN_SRC emacs-lisp
  (require 'bbdb)
  (bbdb-initialize)
#+END_SRC

这里的`bbdb-initialize'会初始化bbdb,并开启最基本的查询/维护记录功能.

除了最基本的查询/维护记录功能外,bbdb还有一些与其他package联合使用的特性,要开启这些特性,则需要在调用`bbdb-initialize'时传入其他的参数.

`bbdb-initialize'可以接收一系列的symbol作为参数,这些symbol决定了bbdb初始化时会开启与哪些package交互的特性. 这些symbol的说明如下表所示:
#+NAME: bbdb-initialize参数说明
| symbol  | meaning                                                               |
|---------+-----------------------------------------------------------------------|
| gnus    | Gnus mail/news reader. *should probably also pass the message symbol* |
| mh-e    | MH-E mail reader.                                                     |
| rmail   | Rmail mail reader.                                                    |
| vm      | VM mail reader.                                                       |
| mail    | Mail (M-x mail).                                                      |
| message | Message mode.                                                         |
| anniv   | Anniversaries in Emacs diary.                                         |
| sc      | Supercite.                                                            |
| pgp     | PGP support:                                                          |

******* 为其他package增加BBDB支持
bbdb提供了一系列的`bbdb-insinuate-xxxx'函数来为xxxx package提供BBDB的支持. 这些函数为package增加了默认的快捷键,并且配置这些package当收到新message时,通知bbdb.

例如:为了給gnus增加bbdb的支持,我们可以添加下面的语句到Emacs初始化文件中
#+BEGIN_SRC emacs-lisp
  (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)
#+END_SRC
****** BBDB基础
******* BBDB数据库结构
BBDB数据库由一系列的记录组成,每条记录对应一个联系人或组织. 每条记录由多种域组成,每种域对应联系人/组织的一个属性.

BBDB内置支持一些类型的域:
| type        | Description                              | Notes                                           |
|-------------+------------------------------------------+-------------------------------------------------|
| NAME        | 联系人的名称,若该记录表示一个组织,则为空         | 一条记录只能有一个该类型的域,一个域只能有一个值 |
| orgnization | 联系人所在的组织,可以为空                     | 一条记录只能有一个该类型的域,一个域只能有一个值 |
| AKA         | 联系人的别名                                | 一个域可以有多个值,以逗号分隔                  |
| mail        | 联系人的email地址                           | 一个域可以有多个值,以逗号分隔                  |
| Phone       | 联系人的电话                                | 一条记录可以有多个该类型的域,一个域只能有一个值 |
| address     | 联系人的地址                                | 一条记录可以有多个该类型的域,一个域只能有一个值 |
| Notes       | 其他说明                                   |  一条记录可以有多个该类型的域,一个域只能有一个值 |
******** 自定义类型
除了上面BBDB内置的域类型,我们还可以自定一些域类型. BBDB处理大多数自定义类型的域时,与Notes类型域一样,但是对有一些特殊名称的域类型,BBDB会进行特殊处理:
+ aka :: 用于存储指定记录的non-primary names
+ finger-host :: Address used in place of the listed net address for fingering the entity indicated by the record
+ gnus-score :: Gnus scoring adjustment for this person.
+ mail-alias :: Value used instead of name for completion
+ mail-name ::  Used for the storage of non-default names to be used in the reporting of new mail by Reportmail.
+ mark-char :: The field containing the character to be used for marking a given poster in the Gnus Summary Buffer
+ tex-name :: The value of this field is used in place of the name field when printing the database using bbdb-print
+ www :: This field contains the URL associated with the BBDB record.
******* BBDB相关命令
******** 搜索记录
********* bbdb

执行该命令后,输入一个正则表达式,则bbdb会列出任何域中的值符合该正则表达式的记录

********* bbdb-search-name/bbdb-search-organization/bbdb-search-address/bbdb-search-mail/bbdb-search-notes/bbdb-search-phone

执行该命令后,输入一个正则表达式,则bbdb会列出指定域中的值符合该正则表达式的记录

********* bbdb-timestamp-older

执行该命令后,输入一个`yyyy-mm-dd'格式的日期,则bbdb会列出在指定日期之前修改过的记录

********* bbdb-timestamp-newer

执行该命令后,输入一个`yyyy-mm-dd'格式的日期,则bbdb会列出在指定日期之后修改过的记录

********* bbdb-creation-older

执行该命令后,输入一个`yyyy-mm-dd'格式的日期,则bbdb会列出在指定日期之前创建的记录

********* bbdb-creation-newer

执行该命令后,输入一个`yyyy-mm-dd'格式的日期,则bbdb会列出在指定日期之后创建的记录

********* bbdb-creation-no-change

执行该命令后,bbdb会列出自创建以来,从未修改过的记录

******** 增加记录
********* bbdb-create

执行该命令后,bbdb会以此提示输入各个内置域的相关信息,然后根据这些相关信息新建一条记录

********* bbdb-snarf

该命令可以根据一定规则将选中的字符串转换成bbdb格式的记录. 默认的转换规则由变量`bbdb-snarf-rule-default'决定. 详细参见`bbdb-snarf-rule-alist'

******* BBDB Mode使用说明
使用BBDB的查询命令后,会弹出一个名为`*BBDB*'的buffer,该buffer处于bbdb mode下.

bbdb mode下拥有许多维护BBDB记录的各种命令,常用的命令有:

******** e (bbdb-edit-field)

修改记录中当前域的值

******** ; (bbdb-edit-foo)

若不带前置参数执行该命令,则修改`(car bbdb-edit-foo)'所表示的域(默认为notes)

若代前置参数执行该命令,则修改`(cdr bbdb-edit-foo)'所表示的域(默认为current-fields)

******** d / C-k (bbdb-delete-field-or-record)

删除光标所在的域,若光标所处的域为bbdb记录的第一个行,则会提示删除整个记录.

This may also be applied to multiple records at once by *.

******** i (bbdb-insert-field)

为当前记录添加新域,该新域的类型可以是BBDB的内置类型,也可以是新的用户自定义类型.

******** C-x C-t (bbdb-transpose-fields)

交换光标所在的field与上一行field的位置

若带参数0执行该命令,则光标所在的域与mark标记的域进行交换

With non-zero numeric argument ARG, the previous field is moved past ARG fields.

交换的field必须在同一条记录中,且具有相同的类型

******** n (bbdb-next-record)/ p (bbdb-prev-record)

移动到下一个/上一个记录,若带前缀参数N,则下移/上移N条记录

******** t (bbdb-toggle-records-layout)


切换是否显示记录中具体域的说明.

若带参数0调用该函数,则强制光标所在记录不显示记录域说明,此时,所有的域信息都压缩到一行内显示.

当待其他参数调用该函数时,则强制光标所在记录显示记录中的域说明时,此时,当前记录使用多行样式显示.

若使用`*t'而不是`t',则buffer内所有的记录都同时切换显示样式

******** T (bbdb-display-record-completely)

谢换是否展示当前记录的所有域,这时平时隐藏不显示的`creation-date'和`timestamp'都会显示出来.

******** o (bbdb-omit-record)

隐藏当前记录,但并不会将当前记录从BBDB数据库中删除掉.

若带参数N执行该命令,则会隐藏下面N条记录,N可以为负数

******** m (bbdb-mail)

发送电子邮件給当前的联系人. 默认邮件地址为记录中的第一个email地址.

若带参数N调用该函数,则表示邮件地址使用记录周公的第N个email地址

若使用`*m'而不是`m',则表示給该buffer中的所有联系人发送电子邮件

******** s /C-x C-s (bbdb-save)

保存BBDB数据库到文件中

******** M-d (bbdb-dial)

该命令会尝试着去拨打光标所在的数字. 若光标处于一条记录的开头,则会拨打第一个phone域.

具体原理不明...

******** q (quit-window)

退出bbdb窗口,但不会kill bbdb buffer

******** ? (bbdb-help)

在minibuffer中显示简易帮助信息

******** h (bbdb-info)

显示bbdb的info文档

若bbdb的info文档没有安装在标准的info目录下,可以通过设置`bbdb-info-file'变量来明确指明bbdb info文件的路径

******** (bbdb-print)

将BBDB记录导出到Tex文件中.

******** c (bbdb-create)

创建新记录保存新的联系人信息

******** C (bbdb-copy-records-as-kill)

将当前记录拷贝到kill ring中

若使用`* C'则拷贝buffer中的所有记录到kill ring中

******** b (bbdb)

重新查询bbdb数据库

******** / m (bbdb-search-mail)

搜索mail域

******** / a (bbdb-search-address)

搜索address域

******** / c (bbdb-search-changed)

搜索至上次保存后,改变过的bbdb记录

******** / d (bbdb-search-duplicates)

搜索具有相同域的记录

******** / n (bbdb-search-name)

搜索name域

******** / o (bbdb-search-organization)

搜索organization域

******** / p (bbdb-search-phone)

搜索phone域

******** / x (bbdb-search-xfields)

搜索xfield域(该域存什么?我也不知道...)

******** * (bbdb-do-all-records)

该命令用于修改紧接之后的命令的作用域,让其作用于buffer中的所有记录.(Command prefix for operating on all records currently displayed.)

但只对某些特定的命令有效

****** 配置

******* 配置项
+ bbdb-file

  bbdb数据库的存储路径,默认为`~/.bbdb'

+ bbdb-default-area-code

  当输入新电话好吗时,使用的默认区号.

  该变量的值也会影响到拨打电话时的行为

+ bbdb-address-format-list

  用于编辑/显示BBDB地址信息时的规则列表.

+ bbdb-continental-postcode-regexp

  该正则表达式决定了BBDB的address是否为欧洲格式的地址.

  若address域的值匹配该正则表达式,则表示该address为欧洲格式的地址,否则认为是美国格式的地址

+ bbdb-case-fold-search

  当使用bbdb系列的搜索命令进行搜索时,是否大小写敏感

+ bbdb-auto-revert

  若在Emacs中没有修改bbdb buffer中的信息,而此时,bbdb-file发生了改变,则自动重新加载bbdb-file的新内容

+ bbdb-pop-up-layout

  pop-up BBDB buffer时使用的默认布局(mail,news...). 默认为'pop-up-multi-line

+ bbdb-pop-up-window-size

  pop-up BBDB buffer时的高度.

  若为整数N,则表示高度为N行

  若为一个介于0到1之间的小数N,则拆分拥有最高高度的window,并且BBDB buffer占据N倍的高度

  若为t,则表示使用 `display-buffer'/`pop-to-buffer' 创建BBDB window??(貌似会占据next-window来显示BBDB buffer)

+ bbdb-completion-list

  控制`bbdb-complete-mail'的补全方式. 该函数用于在mail buffer中补全联系人信息

  该值可以为一个symbol list,用来指明补全哪些域的值. 这些symbol可以是:

  - fl-name :: first and last name

  - lf-name :: last and first name

  - organization ::

  - aka ::

  - mail :: all email address of each record

  - primary :: first email address of each record

  该值也可以为t,表示所有上面symbol的集合

  若该值为nil,则表示不提供补全

+ bbdb-complete-mail-allow-cycling

  当调用`bbdb-complete-mail'补全email地址时,是否允许循环展示补全项

+ bbdb-user-mail-address

  该变量的值为一个正则表达式,该正则表达式用于标识某email地址是否是用户自己的email地址.

  多数BBDB的命令根据变量`bbdb-message-headers'从消息中抽取出发送方和接收方的email地址. 但若发送方的email地址匹配上了`bbdb-user-mail-address-re',则该email地址依然被认为是接收方的email地址.

  改变量的默认值为`(user-login-name)'

+ bbdb-add-mails

  该变量指明了当收到某个联系人从新的email地址发来的消息后,是否增加该新email到联系人信息中.

  可选值有:

  - t :: 自动添加该新的email地址

  - query :: 询问用户是否添加该新的email地址

  - nil :: 忽略新的email地址

  - 数字N :: 在N秒内,BBDB显示该新的email地址,但只在当前session有效

  - 函数fn :: 使用record和新email地址作为参数来调用fn,fn需要返回t,'query,nil或一个数字

  - 正则表达式re :: 若新的email地址符合该正则,则忽略该新的email地址,否则询问用户是否添加该email地址

+ bbdb-new-mails-primary

  为联系人新增email地址时,该新email地址是否作为primary mail address(即该新email地址排在其他email地址的前面).

  可选值为:

  - t :: 让该新增的email地址自动称为primary mail address

  - query :: 询问用户是否作为primary mail address

  - nil :: 不作为primary mail address,会将新email地址放到列表最后面.

  - 函数fn :: 该函数接收两个参数:record和新email地址. 该函数需要返回t,'query或nil

  - 正则表达式re :: 若新email地址匹配该re,则不作为primary mail address,否则询问用户是否作为primary mail address

+ bbdb-ignore-redundant-mails

  当增加新mail地址时,若联系人中的旧mail地址是新mail地址的更一般形式(例如,已有的mail地址为darksun@baz.com,而新mail地址为darksun@foo.baz.com)时,是否覆盖原mail地址.

  可选的值为为:

  - t :: 自动忽略新email地址

  - query :: 询问用户是否忽略新email地址

  - nil :: 使用新email地址,覆盖原email地址

  - 数字N :: 在接下来的N秒内,保留新email地址

  - 函数fn :: fn接收两个参数:record及新email地址,fn需要返回t,'query,nil或数字

  - 正则表达式re :: 符合该正则表达式的email地址会替代原email地址,否则询问用户是否忽略新email地址

+ bbdb-check-auto-save-file

  若值为t,则BBDB会检查它的auto-save file,若auto-save file比`bbdb-file'要新,则BBDB会恢复auto-save file

+ bbdb-ignore-message-alist

  描述哪些message不允许触发自动新建BBDB联系人记录.

+ bbdb-accept-message-alist

  描述哪些message允许触发自动新建BBDB联系人记录.

+ bbdb-mua-auto-update-p

  决定了`bbdb-mua-auto-update'如何自动更新BBDB记录. 可选值:

  - nil :: 什么也不做

  - search :: 搜索匹配ADDRESS的记录

  - update :: 搜索匹配ADDRESS的记录,如有必要,会更新name和mail域

  - query :: 搜索匹配ADDRESS的记录,若记录不存在,提示用户是否创建新记录

  - create :: 搜索匹配ADDRESS的记录,若记录不存在,则创建新记录

  - t :: 搜索匹配ADDRESS的记录,若记录不存在,则创建新记录

  - 函数fn :: bbdb调用该函数,该函数需要返回nil,search,update,query,create或t

******* hooks

| hook                             | 调用hook的时机                                     | 调用hook时的参数                       | 其他说明                                                          |
|----------------------------------+----------------------------------------------------+----------------------------------------+-------------------------------------------------------------------|
| bbdb-display-hook                | 展示*BBDB* buffer后                                |                                        |                                                                   |
| bbdb-create-hook                 | 在BBDB创建新联系人记录前                           | 新增的record                           | bbdb-change-hook也会被触发                                        |
| bbdb-change-hook                 | *BBDB* buffer发生改变前                            | 修改的record                           |                                                                   |
| bbdb-mode-hook                   | 进入bbdb mode后                                    |                                        |                                                                   |
| bbdb-notice-record-hook          | 当发现message中的email地址包含在某个联系人记录中后 | 包含message中email的联系人记录         | 若某message中包含同一联系人的多个email地址,该hook也只会被触发一次 |
| bbdb-notice-mail-hook            | 当发现message中的email地址包含在某个联系人记录中后 | 包含message中email的联系人记录         | 若某message中包含同一联系人的多个email地址,该hook也会被触发多次   |
| bbdb-after-read-db-hook          | 当`bbdb-file'被读取之后                            |                                        | 当BBDB buffer revert之后还会再次触发该hook                        |
| bbdb-initialize-hook             | BBDB的初始化函数`bbdb-initialize'被调用之后        |                                        |                                                                   |
| bbdb-canonicalize-mail-functioin | 当BBDB notice a message后                          | message中的corresponding email address | 该函数用于对message中的对应email地址作一次转换,转换后的结果才拿来与BBDB中的记录进行对比,或添加入BBDB. 若该函数返回nil,则BBDB认为该message中无email address |

****** 其他
******* 函数
******** (bbdb-display-records records )

在bbdb buffer中显示records中的记录

******** (bbdb-record-field RECORD FIELD)

返回记录中的指定域的值. 域的说明为:
| firstname    | Return the first name of RECORD                   |
| lastname     | Return the last name of RECORD                    |
| name         | Return the full name of RECORD (first name first) |
| name-lf      | Return the full name of RECORD (last name first)  |
| affix        | Return the list of affixes                        |
| organization | Return the list of organizations                  |
| aka          | Return the list of AKAs                           |
| aka-all      | Return the list of AKAs plus mail-akas.           |
| mail         | Return the list of email addresses                |
| mail-aka     | Return the list of name parts in mail addresses   |
| mail-canon   | Return the list of canonical mail addresses.      |
| phone        | Return the list of phone numbers                  |
| address      | Return the list of addresses                      |
| xfields      | Return the list of all xfields                    |
| 其他         | 指定label的xfields                                   |

******** (bbdb-get-records PROMPT)

若在*BBDB* buffer中,则返回光标所在的记录,若在其他buffer中,则询问用户想要返回哪个记录

******** (bbdb-update-records ADDRESS-LIST &optional UPDATE-P SORT)

返回匹配ADDRESS-LIST的BBDB记录列表

其中ADDRESS-LIST是一个由email地址组成的列表


参数UPDATE-P的可选值为:

+ nil :: 使用变量`bbdb/MUA-update-records-p'中的值, 若该值依然为nil,则`bbdb-update-records'返回nil

+ search :: 搜索匹配ADDRESS的记录

+ update :: 搜索匹配ADDRESS的记录,如有必要,会更新name和mail域

+ query :: 搜索匹配ADDRESS的记录,若记录不存在,提示用户是否创建新记录

+ create :: 搜索匹配ADDRESS的记录,若记录不存在,则创建新记录

+ t :: 搜索匹配ADDRESS的记录,若记录不存在,则创建新记录

+ 函数fn :: bbdb调用该函数,该函数需要返回search,update,query,create或t

若参数SORT为非nil,则返回的记录列表中的记录会经过`bbdb-record-lessp'排序;若SORT为nil,则记录的顺序与参数ADDRESS-LIST中的邮件地址的顺序对应.

******** (bbdb-get-mail-aliases)

返回BBDB中使用的mail aliases列表

******** (bbdb-search-read &optional FIELD)

提示用户输入一个正则表达式re,并从BBDB数据库中搜索出指定的FIELD符合该re的记录

******** (bbdb-search RECORDS &optional NAME-RE ORG-RE MAIL-RE XFIELD-RE PHONE-RE ADDRESS-RE)

从RECORDS中搜索出符合指定域的指定正则表达式的记录. 其中

+ NAME-RE匹配FIRST_LAST,LAST_FIRST和AKA域

+ XFIELD-RE匹配xfiled notes域

+ XFIELD-RE也以格式为(LABEL . RE)表示label为xfield的正则表达式,其中若LABEL为`*'则表示任一个xfield

******** (bbdb-display-records-with-layout RECORDS LAYOUT)

使用LAYOUT形式来展示RECORDS,其中LAYOUT参见`bbdb-layout-alist'中的值

******** (bbdb-pop-up-window &optional SELECT HORIZ-P)

******** (bbdb-display-records RECORDS &optional LAYOUT APPEND SELECT HORIZ-P)

使用LAYOUT形式来显示RECORDS

若参数APPEND为非nil,则会在当前已经显示的记录后,再多显示这些RECORDS;若APPEND为nil,则会用RECORDS的显示结果代替已有的显示结果

参数SELECT与参数HORIZ-P的意义参见`bbdb-pop-up-window'

******** (bbdb-display-record RECORD LAYOUT NUMBER)

在当前buffer的光标所在处,插入格式化好的RECORD表示文本.

LAYOUT是`bbdb-layout-alist'中描述的layout符号,若为nil则表示`bbdb-layout'

NUMBER is the number of RECORD among the displayed records.

******** (bbdb-read-record &optional FIRST-AND-LAST)

提示用户输入联系人信息,并创建一个新的BBDB联系人记录.

*但该函数不会将新产生的BBDB记录存入数据库,也不会更新BBDB hashtable*

*该函数会检查新输入的联系人是否和已存在的联系人记录相冲突*

******** (bbdb-read-string PROMPT &optional INIT COLLECTION REQUIRE-MATCH)

读取用户输入的字符串,会取出字符串中的空格和text properties

参数PROMPT为提示说明

参数INIT为预设值,当编辑已存在记录时常用到

参数COLLECTION与REQUIRE-MATCH的意义与`completing-read'中的意义一致

******** (bbdb-record-set-field RECORD FIELD VALUE &optional MERGE CHECK)

设置RECORD中的FIELD域的值为VALUE.

该函数的返回值为VALUE

若参数MERGE为非nil,则将参数VALUE合并到FIELD的当前值中

若参数CHECK为非nil,则会检查FIELD是否能够存储VALUE

*该函数会更新bbdb hashtable,但不会保存RECORD到bbdb数据库中*. 一般使用函数`bbdb-change-record'来保存RECORD到bbdb数据库中.

其中参数FIELD的说明,参见`bbdb-record-field'中的FIELD说明

******** (bbdb-change-record RECORD &optional NEED-TO-SORT NEW)

该函数保存RECORD到BBDB数据库中,若参数RECORD中的值与BBDB数据库中的值相比发生了变化,则该函数返回RECORD,否则该函数返回nil

当RECORD中的联系人名称发生改变,或RECORD为新建的联系人记录时,NEED-TO-SORT参数需要为t

当RECORD为新建的联系人记录时,参数NEW需要为t. 若RECORD为新建联系人记录则该RECORD会自动更新入BBDB hashtable,否则需要手工更新BBDB hashtable

******** (bbdb-current-record &optional FULL)

返回光标所处的RECORD

若参数FULL为非nil,则返回包含RECORD和显示格式(layout)的一个list
#+BEGIN_SRC emacs-lisp
  (bbdb-current-record t)
  ;; ([nil "darksun" nil nil nil (["home" "(+86)15820984397"] ["work" "(0794)6593346"]) nil nil ((creation-date . "2015-03-30 09:46:57 +0000") (timestamp . "2015-03-30 13:17:00 +0000")) ["darksun" "darksun" nil nil "darksun" #<marker at 64 in bbdb>]] multi-line #<marker at 1 in *BBDB*>)
  (bbdb-current-record)
  ;; [nil "darksun" nil nil nil (["home" "(+86)15820984397"] ["work" "(0794)6593346"]) nil nil ((creation-date . "2015-03-30 09:46:57 +0000") (timestamp . "2015-03-30 13:17:00 +0000")) ["darksun" "darksun" nil nil "darksun" #<marker at 64 in bbdb>]]

#+END_SRC

******** (bbdb-current-field)

返回光标所处的当前域
#+BEGIN_SRC emacs-lisp
  (bbdb-current-field)
  ;; (name "darksun")
#+END_SRC

******** bbdb-record-set-xxx系列函数

置record中指定field的值

******* 变量
******** bbdb-records

该变量的值为当前bbdb buffer中的record列表

******** bbdb-search-invert

若值为t,则会反转`bbdb-search'的搜索结果
****** FAQ

******* 如何修改BBDB创建联系人的流程

使用`bbdb-create'新建联系人时,会以此提示你输入一系列的联系人的信息,包括姓名,所属机构,电子邮件,地址,电话,备注. 但若想让BBDB在创建联系人时也提示你输入其他额外的信息该如何作呢?

下面是一个例子,它让`bbdb-create'新建联系人时,还会提示你输入生日信息:
#+BEGIN_SRC emacs-lisp
  (defun bbdb-read-record-advise-function(record)
    "提示存储生日,QQ,微信号"
    (bbdb-record-set-field record 'birthdate
                           (bbdb-read-string "Birthdate (YYYY.MM.DD): "))
    (bbdb-record-set-field record 'QQ
                           (bbdb-read-string "QQ:"))
    (bbdb-record-set-field record 'WeChat
                           (bbdb-read-string "WeChat:"))
    record)

  (advice-add 'bbdb-read-record :filter-return #'bbdb-read-record-advise-function)

#+END_SRC

******* 如何将bbdb中保存的联系人信息导入到手机中

最简单的方法,就是使用"bbdb-to-outlook.el"将bbdb导出为.csv文件. 然后在手机上导入该.csv文件

1. 加载"bbdb-to-outlook.el"
2. 使用`bbdb'显示bbdb联系人信息
3. 键入`O'会运行`bbdb-to-outlook'命令,输入保存的csv文件路径即可.

**** ROS
- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html

**** org-preview-latex-fragment 与 minted 宏包冲突

- http://orgmode.org/worg/org-tutorials/org-latex-preview.html
- http://tex.stackexchange.com/questions/162767/can-not-preview-latex-equation-in-org-mode-dvipng-and-imagemagick-both-failed

#+BEGIN_QUOTE
But if you have set up preview to use the dvipng method, you are in
trouble: that method calls latex directly, the call is hardwired and
it does not use the -shell-escape option. LaTeX refuses to run the
external program that minted used, no DVI file is produced and dvipng
cannot produce a PNG file
#+END_QUOTE

上述问题并没有好的解决方法

*latex preview 要比 minted 使用的多，所以优先考虑前者*

dvipng 没有错误，但不会生成公式图片

imagemagick 产生错误信息，

#+BEGIN_EXAMPLE
(error "PDF file /tmp/orgtex31149_Wk.pdf wasn't produced")
#+END_EXAMPLE

查看 log =/tmp/orgtex12345abc.log=

#+BEGIN_EXAMPLE
l.4 \usepackage
               [utf8]{inputenc}
?
! Emergency stop.
 ...

l.4 \usepackage
               [utf8]{inputenc}
Pass the -shell-escape flag to LaTeX. Refer to the minted.sty documentation for
 more information.
#+END_EXAMPLE




解决方式： 注释掉 org 文件头部包含的 minted 宏包

#+BEGIN_EXAMPLE
#+LATEX_HEADER: \usepackage{minted}
#+END_EXAMPLE

Note:

1. org-toogle-latex-preview
   #+BEGIN_EXAMPLE
     `org-preview-latex-fragment' is an obsolete command (as of 24.4); use `org-toggle-latex-fragment' instead.
   #+END_EXAMPLE
2. imagemagick 产生 A4 的图片，太大了，没有 dvipng 方便

**** Using rosed to edit files in ROS

*Description:* This tutorial shows how to use [[/rosbash][rosed]] to
make editing easier.

***** Using rosed

=rosed= is part of the [[/rosbash][rosbash]] suite. It allows you to
directly edit a file within a package by using the package name rather
than having to type the entire path to the package.

Usage:

#+BEGIN_EXAMPLE
    $ rosed [package_name] [filename]
#+END_EXAMPLE

Example:

#+BEGIN_EXAMPLE
    $ rosed roscpp Logger.msg
#+END_EXAMPLE

This example demonstrates how you would edit the Logger.msg file within
the roscpp package.

If this example doesn't work is probably because you don't have the
=vim= editor installed. Please refer to
[[/ROS/Tutorials/UsingRosEd#Editor][Editor]] section. If you don't know
how to get out of vim, [[http://kb.iu.edu/data/afcz.html][click here]].

If the filename is not uniquely defined within the package, a menu will
prompt you to choose which of the possible files you want to edit.

***** Using rosed with tab completion

This way you can easily see and optionally edit all files from a package
without knowing its exact name.

Usage:

#+BEGIN_EXAMPLE
    $ rosed [package_name] <tab><tab>
#+END_EXAMPLE

Example:

#+BEGIN_EXAMPLE
    $ rosed roscpp <tab><tab>
#+END_EXAMPLE


#+BEGIN_EXAMPLE
  Empty.srv                   package.xml
  GetLoggers.srv              roscpp-msg-extras.cmake
  Logger.msg                  roscpp-msg-paths.cmake
  SetLoggerLevel.srv          roscpp.cmake
  genmsg_cpp.py               roscppConfig-version.cmake
  gensrv_cpp.py               roscppConfig.cmake
  msg_gen.py
#+END_EXAMPLE

***** Editor

The default editor for rosed is =vim=. The more beginner-friendly editor
=nano= is included with the default Ubuntu install. You can use it by
editing your ~/.bashrc file to include:

#+BEGIN_EXAMPLE
    export EDITOR='nano -w'
#+END_EXAMPLE

To set the default editor to =emacs= you can edit your ~/.bashrc file to
include:

#+BEGIN_EXAMPLE
    export EDITOR='emacs -nw'
#+END_EXAMPLE

/*NOTE:*/ /changes in .bashrc will only take effect for new terminals.
Terminals that are already open will not see the new environmental
variable./

Open a new terminal and see if =EDITOR= is defined:

#+BEGIN_EXAMPLE
    $ echo $EDITOR
#+END_EXAMPLE


#+BEGIN_EXAMPLE
    nano -w
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    emacs -nw
#+END_EXAMPLE

**** cdlatex-math-symbol

1. cdlatex-math-symbol
   #+BEGIN_EXAMPLE
     ` runs the command cdlatex-math-symbol, which is an interactive Lisp
     function in `cdlatex.el'.

     It is bound to `, <menu-bar> <Org> <LaTeX> <Insert math symbol>.

     (cdlatex-math-symbol)

     Read a char from keyboard and insert corresponding math char.
     The combinations are defined in `cdlatex-math-symbol-alist'.  If not in a LaTeX
     math environment, you also get a pair of dollars.
   #+END_EXAMPLE

2. cdlatex-math-symbol-alist

   #+BEGIN_EXAMPLE
     cdlatex-math-symbol-alist is a variable defined in `cdlatex.el'.
     Its value is nil

     Documentation:
     Key characters and math symbols for fast access with the prefix key.
     First element is a character, followed by a number of strings attached to
     this key.  When the string contains a question mark, this is where the
     cursor will be positioned after insertion of the string into the buffer.
     See `cdlatex-math-symbol-alist-default' for an example.  Any entry defined
     here will replace the corresponding entry of the default list.  The
     defaults implement 3 levels of symbols so far: Level 1 for greek letters
     and standard symbols, level 2 for variations of level 1, and level 3 for
     functions and opperators.
   #+END_EXAMPLE

3. cdlatex-math-symbol-alist-default

   #+BEGIN_EXAMPLE
     Default for cdlatex-math-symbol-alist.

     Value: ((97
       ("\\alpha"))
      (65
       ("\\forall" "\\aleph"))
      (98
       ("\\beta"))
      (66
       (""))
      (99
       ("" "" "\\cos"))
      (67
       ("" "" "\\arccos"))
      (100
       ("\\delta" "\\partial"))
      (68
       ("\\Delta" "\\nabla"))
      (101
       ("\\epsilon" "\\varepsilon" "\\exp"))
      (69
       ("\\exists" "" "\\ln"))
      (102
       ("\\phi" "\\varphi"))
      (70
       (""))
      (103
       ("\\gamma" "" "\\lg"))
      (71
       ("\\Gamma" "" "10^{?}"))
      (104
       ("\\eta" "\\hbar"))
      (72
       (""))
      (105
       ("\\in" "\\imath"))
      (73
       ("" "\\Im"))
      (106
       ("" "\\jmath"))
      (74
       (""))
      (107
       ("\\kappa"))
      (75
       (""))
      (108
       ("\\lambda" "\\ell" "\\log"))
      (76
       ("\\Lambda"))
      (109
       ("\\mu"))
      (77
       (""))
      (110
       ("\\nu" "" "\\ln"))
      (78
       ("\\nabla" "" "\\exp"))
      (111
       ("\\omega"))
      (79
       ("\\Omega" "\\mho"))
      (112
       ("\\pi" "\\varpi"))
      (80
       ("\\Pi"))
      (113
       ("\\theta" "\\vartheta"))
      (81
       ("\\Theta"))
      (114
       ("\\rho" "\\varrho"))
      (82
       ("" "\\Re"))
      (115
       ("\\sigma" "\\varsigma" "\\sin"))
      (83
       ("\\Sigma" "" "\\arcsin"))
      (116
       ("\\tau" "" "\\tan"))
      (84
       ("" "" "\\arctan"))
      (117
       ("\\upsilon"))
      (85
       ("\\Upsilon"))
      (118
       ("\\vee"))
      (86
       ("\\Phi"))
      (119
       ("\\xi"))
      (87
       ("\\Xi"))
      (120
       ("\\chi"))
      (88
       (""))
      (121
       ("\\psi"))
      (89
       ("\\Psi"))
      (122
       ("\\zeta"))
      (90
       (""))
      (32
       (""))
      (48
       ("\\emptyset"))
      (49
       (""))
      (50
       (""))
      (51
       (""))
      (52
       (""))
      (53
       (""))
      (54
       (""))
      (55
       (""))
      (56
       ("\\infty"))
      (57
       (""))
      (33
       ("\\neg"))
      (64
       (""))
      (35
       (""))
      (36
       (""))
      (37
       (""))
      (94
       ("\\uparrow"))
      (38
       ("\\wedge"))
      (63
       (""))
      (126
       ("\\approx" "\\simeq"))
      (95
       ("\\downarrow"))
      (43
       ("\\cup"))
      (45
       ("\\leftrightarrow" "\\longleftrightarrow"))
      (42
       ("\\times"))
      (47
       ("\\not"))
      (124
       ("\\mapsto" "\\longmapsto"))
      (92
       ("\\setminus"))
      (34
       (""))
      (61
       ("\\Leftrightarrow" "\\Longleftrightarrow"))
      (40
       ("\\langle"))
      (41
       ("\\rangle"))
      (91
       ("\\Leftarrow" "\\Longleftarrow"))
      (93
       ("\\Rightarrow" "\\Longrightarrow"))
      (123
       ("\\subset"))
      (125
       ("\\supset"))
      (60
       ("\\leftarrow" "\\longleftarrow" "\\min"))
      (62
       ("\\rightarrow" "\\longrightarrow" "\\max"))
      (96
       (""))
      (39
       ("\\prime"))
      (46
       ("\\cdot")))
   #+END_EXAMPLE

4. 层次

   + 这个很好用啊

   + 在默认值的基础上修改
     #+BEGIN_EXAMPLE
     (65 ("\\forall" "\\aleph"))
     #+END_EXAMPLE

   + 层次问题
     - 第一层： 希腊字母和标准符号
     - 第二层： 第一层的变种
     - 第三层： 数学函数与操作
     - 第四层： =自定义= (太深了，还是第一层)

*** 2016/01/02
**** Emacs VCF 手机备份文件
**** 整理 Chrome 收藏夹
:LOGBOOK:
CLOCK: [2016-01-02 六 10:53]--[2016-01-02 六 13:05] =>  2:12
:END:

1. 使用 Chrome 书签保存常用网页
2. 书签栏上仅显示常用网址，即每天都需要打开的网页，以及 INBOX 和 INDEX
   两个文件夹
3. INBOX 用于保存有待处理的网页
4. INDEX 用于分类收藏网址
   - ROS： ROS 相关常用网址
   - Google: Google相关网址
   - Cloud： 云存储网址
   - BUAA：校园相关
   - Community: 社区
   - Forum: 论坛
   - Guide：教程
   - Blog：博客
   - Manual：手册
   - Homepage: 项目主页
   - Resource: 资源
   - Github： Github 上的资源
   - Course: 课程
   - Project: 课题相关

**** Can we make a love heart with LaTeX

+
  http://tex.stackexchange.com/questions/139733/can-we-make-a-love-heart-with-latex

[[/home/ben/Wally/Journal//Figure/scrot/2959ite.png]]

**** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html

**** 像ROS，图片链接不是完整路径，可以改
**** VirtualBox USB 支持

-  [[http://www.cnblogs.com/ericsun/archive/2013/06/10/3130679.html][在Ubuntu12.04 上为Virtualbox 启用USB 设备支持]]


众所周知,VirtualBox使用宿主机的USB设备需要安装扩展包。根据自己的vbox的
版本，到vbox官网下载对应的扩展包。比如我的vbox 是4.1.12的，对应扩展包
地址是：[[http://download.virtualbox.org/virtualbox/4.1.12/Oracle_VM_VirtualBox_Extension_Pack-4.1.12-77245.vbox-extpack][http://download.virtualbox.org/virtualbox-extpack]]

下载完毕后，在“管理”菜单下的“全局设定”里的“扩展”标签下，加入、启
用即可。

如图：

[[http://static.xiazhengxin.name/img/install_vbox_ext_package.png]]

之后，打开虚拟系统设置，在“USB设备”标签下，勾选上"启用USB控制器"以及
"2.0控制器"增加对USB2.0的支持。

如图：
 [[http://static.xiazhengxin.name/img/enable_USB2_controller.png]]

按说这个时候已经搞定了。可是在USB列表里面却没有任何USB设备。这是为什么
呢？谷歌了一下，找到了一篇文章(具体地址已经无法回忆起来了，囧)，解释了
一下原因。

*原来是vbox 所在的用户组比如要包括当前用户才行。*

查看当前用户名：

#+BEGIN_EXAMPLE
sharl@sharl-laptop:~$ whoami
sharl
#+END_EXAMPLE


查看vbox 所在的组：

#+BEGIN_EXAMPLE
sharl@sharl-laptop:~$ cat /etc/group | grep vbox
vboxusers:x:125:sharl
#+END_EXAMPLE

将当前用户加入vbox组：

#+BEGIN_EXAMPLE
usermod -a -G vboxusers sharl
#+END_EXAMPLE

即可。

此时，重启系统。再次打开虚拟机，果然，USB设备都已经被识别、访问到了。
这些，在“设备”菜单下就可以看到。

如图：

[[http://static.xiazhengxin.name/img/add_USB_device_to_vbox_from_list.png]]

添加后，虚拟机系统果然发现了新硬件，按照一般步骤，安装驱动即可正常使用。

**** Running 64bit Matlab on 32bit host OS

-
  http://neuro.debian.net/blog/2013/2013-05-31_matlab_64bit_on_32bit.html


Note

- Debian 下32位系统使用64位 Matlab, Ubuntu 下不一定能用。
- 不要再 Linux 下折腾 Matlab
- 装系统要装64位的

Some of you have experienced problems due the recent move of Mathworks
to drop 32-bit Linux builds of their products (i.e. Matlab R2013a and
co.). Please note that this is not the first time Mathworks values its
own costs higher than the benefits of a few scientists. In 1998
PowerPC builds for Macs were abandoned, causing a furious reaction of
the community.

Luckily, users of the fresh Debian stable release wheezy (or more
recent variants of Debian and its derivatives) who still need a 32bit
OS on 64bit-capable hardware can take advantage of the new multiarch
support. Multiarch allows for multiple architecturesi to co-exist on a
hardware/kernel that is capable of supporting both (e.g. i386 and
amd64).

Below we describe how you can use multiarch support and in few simple
steps that prepare your existing 32bit user-land for running 64bit
Matlab.

Procedure
1. [2-10 min] Install 64-bit kernel and reboot:

   #+BEGIN_EXAMPLE
   sudo apt-get install linux-image-amd64
   #+END_EXAMPLE

2. [1-3 min] Enable multi-arch support for amd64 architecture:

   #+BEGIN_EXAMPLE
   sudo dpkg --add-architecture amd64
   sudo apt-get update
   #+END_EXAMPLE

3. [1-5 min] Install 64bit libraries (and compilers) needed for
   matlab:
   #+BEGIN_EXAMPLE
     sudo apt-get install libstdc++6:amd64 zlib1g:amd64 libncurses5:amd64 \
     libxp6:amd64 libstdc++6-4.4-dev:amd64 libxt6:amd64 libxmu6:amd64 libxtst6:amd64 \
     g++:amd64 gcc:amd64 binutils:amd64
   #+END_EXAMPLE

Now your 64bit matlab (which you hopefully “registered” with
matlab-support) is ready to run.

**** [[http://lanbing510.info/2014/12/03/Linux-Matlab.html][Linux下Matlab的安装及配置使用]]

1. 从[[http://pan.baidu.com/s/1o6qKdxo#path=%252Fmatlab][这里]]下载Matlab2014的Linux版本及破解文件。

2. 下载完成后将iso文件挂载到Linux进行安装。

   #+BEGIN_EXAMPLE
    sudo mkdir /media/matlab
    mount -o loop [path][filename].iso /media/matlab
    cd /media/matlab
    sudo ./install
   #+END_EXAMPLE

3. 安装过程中使用readme.txt中的序列号。

4. 破解

   1) 安装完成后使用crack下的 license进行激活；

   2) 将crack文件夹下的libmwservices.so copy到 /usr/local/MATLAB/R2014A/bin/glnxa64。

5. 完成安装，命令行下使用sudo matlab即可启动使用。

**** yasnippet elisp code

Emacs-Lisp code can be embedded inside the template, written inside back-quotes (`). The lisp forms are evaluated when the snippet is being expanded. The evaluation is done in the same buffer as the snippet being expanded.

Here's an example for c-mode` to calculate the header file guard
dynamically:

#+BEGIN_EXAMPLE
  #ifndef ${1:_`(upcase (file-name-nondirectory (file-name-sans-extension (buffer-file-name))))`_H_}
  #define $1

  $0

  #endif /* $1 */
#+END_EXAMPLE

**** date

(insert (format-time-string "%y-%m-%d-%H-%M"))16-01-02-16-10

**** TODO org-preview-latex-fragment

$\mathbf{x}=(x, y, \theta)$
