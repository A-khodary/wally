#+LATEX_HEADER: \usepackage[boxed, lined]{algorithm2e}
# #+LATEX_HEADER: \usepackage{minted}
# #+LATEX_HEADER: \usepackage{float}

# freemind
# .sdcv_history
# agenda
# obj


- [ ] Prime: PCL
- [ ] Project: IMU
- [ ] Progress: Deutsch
- [ ] Thesis: Outliers

* Objective
** month

+ [ ] 写完大论文初稿
+ [ ] 完成一篇小论文
+ [ ] IMUtoolbox / PythonSLAM / TimBailey

** week

+ [ ] EK-SLAM & Gazebo Sim & Thesis
+ [ ] PF

** 2016/01/11

+ [X] freemind
+ [X] wally & julie
+ [X] software
+ [X] ROS opencv

** 2016/01/01
+ [X] wally gazebo 仿真实现三维建模
+ [X] 小车测试 Hector SLAM
** 2016/01/02
+ [X] 理解 Hector SLAM 中 map/odom/base_footprint 的配置（仿真中即可）
+ [X] 绪论 SLAM 部分
** 2016/01/03
+ [X] gazebo worlds
+ [X] 使用小车采集数据实现三维建模（保存数据，不用实时）
+ [ ] 使用 Raspberry 采集数据
+ [X] 理解 Hector SLAM 的 base_stablized 坐标配置
** 2016/01/04
+ [X] 采集小车本身的数据
+ [X] IMU 积分算法
+ [X] 完成论文定位部分
** 2016/01/05

+ [X] laser_filter/laser_assembler/PLC
+ [ ] Samba 配置
+ [X] 推导 PF，莫放拦路虎
+ [X] 特征地图论文

** 2016/01/06
+ [X] PCL
+ [ ] SLAM 论文部分
** 2016/01/07
+ [X] 考虑电池和电路板
+ [X] PCD
+ [X] SLAM 论文部分
** 2016/01/08
+ [X] 考虑学报
+ [X] PF SLAM
+ [X] Gazebo sim
* Journal

** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

** 2016/01/22 summary
** Evernote 笔记清空




** EmacsWiki

- [[http://www.emacswiki.org/emacs/PhpMode][phpmode]]
- [[http://www.emacswiki.org/emacs/ArduinoSupport][ArduinoSupport]]
- [[http://www.emacswiki.org/emacs/AutoComplete][AutoComplete]]
- [[http://www.emacswiki.org/emacs/ArtistMode][ArtistMode]]
- [[http://www.emacswiki.org/emacs/ProgrammingWithPythonModeDotEl][ProgrammingWithPythonModeDotEl]]
- [[http://www.emacswiki.org/emacs/PythonProgrammingInEmacs][PythonProgrammingInEmacs]]
- [[http://www.emacswiki.org/emacs/EasyPG][EasyPG]]
- [[http://www.emacswiki.org/emacs/ThumbsMode][ThumbsMode]]
- [[http://www.emacswiki.org/emacs/XKeymacs][XKeymacs]]
- [[http://www.emacswiki.org/emacs/MakefileMode][MakefileMode]]
- [[http://www.emacswiki.org/emacs/DeletingWhitespace][DeletingWhitespace]]
- [[http://www.emacswiki.org/emacs/Edit_with_Emacs][Emacs]]
- [[http://www.emacswiki.org/emacs/CopyWithoutSelection][CopyWithoutSelection]]
- [[http://www.emacswiki.org/emacs/ModeLine][ModeLine]]

** wiki 代理

从该IP地址段106.187.32.0/20的账户创建已被Jimmy-abot禁止，而这也包括了
您的IP地址（106.187.44.23）。

Jimmy-abot给出的原因是

Banned proxys.svg您正在使用的IP地址已经被封禁，因我们相信其被用作代理。


问题是： 没法登录！！！

** [[http://blog.chinaunix.net/uid-25148547-id-138696.html][Protel中Cap,Cap2，Cap Pol的区别]]

# 序号	英文简写	元件英文名	元件中文名

|----+--------------+---------------------------------------+----------------------------------------------------|
|  1 | Res semi     | Semiconductor Resistor                | 半导体电阻                                         |
|  2 | Cap semi     | Semiconductor Capacitor               | 半导体电容器                                       |
|  3 | Cap Var      | Variable or                           | Adjustable Capacitor       可变或可调电容          |
|  4 | Cap Pol1     | Polarized Capacitor                   | (Radial)   极化电容（径向）                        |
|  5 | Cap Pol2     | Polarized Capacitor                   | (Axial)    极化电容（轴向）                        |
|  6 | Cap          | Capacitor                             | 电容（径向）                                       |
|  7 | Cap Pol3     | Polarized Capacitor                   | (Surface Mount)    极化电容（表面贴装）            |
|  8 | Cap Feed     | Feed-Through                          | Capacitor 馈通电容                                 |
|  9 | Cap2         | Capacitor                             | 电容                                               |
| 10 | Res Varistor | Varistor (Voltage-Sensitive Resistor) | 压敏电阻（电压敏感电阻）                           |
| 11 | Res Tap      | Tapped Resistor                       | 抽头电阻                                           |
| 12 | Res Thermal  | Thermal Resistor                      | 热敏电阻                                           |
| 13 | Rpot         | Potentiometer Resistor                | （侧调或顶调）电位器                               |
| 14 | Rpot SM      | Square Trimming                       | Potentiometer （顶调）方形电位器                   |
| 15 | Res Bridge   | Resistor Bridge                       | 电阻桥                                             |
| 16 | Bridge1      | Full Wave Diode Bridge                | 整流桥                                             |
| 17 | Bridge2      | Bridge Rectifier                      | 整流桥集成组件（比1封装较大）                      |
| 18 | Res Adj      | Variable Resistor                     | 可变电阻                                           |
| 19 | Res3         | Resistor                              | IPC的高密度贴片电阻                                |
| 20 | D Tunnel2    | Tunnel Diode                          | - Dependent Source Model  隧道二极管 - 依赖源模型  |
| 21 | D Varactor   | Variable Capacitance Diode            | 变容二极管                                         |
| 22 | D Schottky   | Schottky Diode                        | 肖特基二极管                                       |
| 23 | Diode 1N5402 | 3 Amp                                 | General Purpose Rectifier        3放大器通用整流器 |
|----+--------------+---------------------------------------+----------------------------------------------------|

其中，cap，cap2，cap pol1和cap pol2分别如下图所示


#+DOWNLOADED: http://blog.chinaunix.net/attachment/201102/25/25148547_1298643961S8lR.jpg @ 2016-01-23 00:11:22
 [[~/Wally/Journal/Figure/.org-download/Journal/25148547_1298643961S8lR_2016-01-23_00:11:22.jpg]]

其中，径向型电容如下图所示：


#+DOWNLOADED: http://blog.chinaunix.net/attachment/201102/25/25148547_1298604806OTrm.jpg @ 2016-01-23 00:11:45
 [[~/Wally/Journal/Figure/.org-download/Journal/25148547_1298604806OTrm_2016-01-23_00:11:45.jpg]]


轴向型电容如下所示：


#+DOWNLOADED: http://blog.chinaunix.net/attachment/201102/25/25148547_1298604874zIM5.jpg @ 2016-01-23 00:12:05
 [[~/Wally/Journal/Figure/.org-download/Journal/25148547_1298604874zIM5_2016-01-23_00:12:05.jpg]]

有极性电阻为电解电容，无极性电阻为普通电容，电解电容的容量一般比普通电
容的大，在滤波时电解电容用于滤低频，普通电容用于滤高频。

**

** [[http://blog.jobbole.com/49800/][Bash One-Liners Explained（一）：文件处理]]

原文出处：[[http://www.catonmat.net/series/bash-one-liners-explained][Peteris Krumins]]
译文出处：[[http://kodango.com/bash-one-liners-explained-part-one][团子的小窝]]

[[http://www.catonmat.net/series/bash-one-liners-explained][*BashOne-Liners Explained*]] 是一系列介绍 Bash 命令技巧的文章，由国外牛
人 [[http://www.catonmat.net/][Peteris Krumins]] 撰写。凭借扎实的功底和丰富的经验，作者总结了许多快
速解决问题的技巧，并且每一条都只要用简洁的一行Bash 命令就可以完成，同
时每一行命令文中都给出了非常详尽的解释。

Peteris Krumins是一位高产的博主，在他的博客上有很多非常精彩的文章，推
荐大家有机会都可以去好好读一读。例如，大家耳熟能详的
[[http://www.catonmat.net/series/awk-one-liners-explained][Awk
One-Liners
Explained]]、[[http://www.catonmat.net/series/sed-one-liners-explained][Sed
One-Liners Explained]]
等等。后者我也曾经在博客上分享过[[http://kodango.com/sed1line-notes][一篇笔记]]。

回到正题，虽然这一系列文章不难，但是还是可以从中学到很多细节的知识，相
信这些肯定会对许多初学者有所帮助，所以我打算将这一系列翻译成中文，分享
给大家。为了同原文保持一致，这一系列文章最终会分成以下五篇：

1. [[http://blog.jobbole.com/49800/][Bash One-Liners Explained 译文（一）: 文件处理]]；
2. [[http://blog.jobbole.com/49843/][Bash One-Liners Explained   译文（二）: 操作字符串]]；
3. Bash One-Liners Explained 译文（三）: 漫谈重定向；
4. Bash One-Liners Explained 译文（四）: 历史命令；
5. Bash One-Liners Explained 译文（五）: 命令行跳转；

本系列的文章同其它系列一样，最终都可以在连载页面找到，有兴趣的同学可以
随意翻翻，看看有没有一些对你有价值的文章，大家一起交流学习。

*** 清空文件内容

#+BEGIN_EXAMPLE
    $ > file
#+END_EXAMPLE

这一行命令用到了输出重定向操作符=>=。输出重定向发生时，文件会被打开准
备写入。如果此时文件不存在则先创建，存在则将其大小截取为0。这里我们并
没有重定向写任何内容到文件中，所以文件依然保持为空。

如果你想替换文件的内容，或者创建一个包含指定内容的文件，可以运行下面的
命令：

#+BEGIN_EXAMPLE
    $ echo "some string" > file
#+END_EXAMPLE

*** 追加内容到文件

#+BEGIN_EXAMPLE
    $ echo "foo bar baz" >> file
#+END_EXAMPLE

这一行命令用到了另外一个输出重定向操作符=>>=，该操作符将内容追加到文件。
同样地，如果文件不存在则先创建它。追加的内容之后，紧跟着换行符。如果你
不想要追加换行符，在执行=echo=命令时可以指定=-n=选项：

#+BEGIN_EXAMPLE
    $ echo -n "foo bar baz" >> file
#+END_EXAMPLE

*** 读取文件的首行并赋值给变量

#+BEGIN_EXAMPLE
    $ read -r line < file
#+END_EXAMPLE

这一行命令用到了 Bash 的内置命令 =read= ，和输入重定向操作符 =<= 。
=read= 命令从标准输入中读取一行，并将内容保存到变量 =line= 中。在这里，
=-r= 选项保证读入的内容是原始的内容，意味着反斜杠转义的行为不会发生。输入重定向
操作符 =< file= 打开并读取文件 =file= ，然后将它作为=read=命令的标准输入。


记住，=read=命令会删除包含在=IFS=变量中出现的所有字符，IFS 的全称是
Internal Field Separator，Bash 根据 IFS
中定义的字符来分隔单词。在这里，=read=命令读入的行被分隔成多个单词。默认情况下，=IFS=包含空格，制表符和回车，这意味着开头和结尾的空格和制表符都会被删除。如果你想保留这些符号，可以通过设置=IFS=为空来完成：

#+BEGIN_EXAMPLE
    $ IFS= read -r line < file
#+END_EXAMPLE

IFS
的变化仅会影响当前的命令，这行命令可以保证读入原始的首行内容到变量=line=中，同时行首与行尾的空白字符被保留。

另外一种读取文件首行内容，并赋值给变量的方法是:

#+BEGIN_EXAMPLE
    $ line=$(head -1 file)
#+END_EXAMPLE

这里用到了命令替换操作符=$(...)=，它运行括号里的命令并且将输出返回。
这个例子中，命令是=head -1 file=，输出的内容是文件的首行。输入然后通过等号赋值给变量=line=。=$(...)=的等价写法是=`...`=，所以也可以换成下面这样：

#+BEGIN_EXAMPLE
    $ line=`head -1 file`
#+END_EXAMPLE

不过，在 Bash
中=$(...)=用法更加推荐，因为它看起来更加整洁，并且容易嵌套使用。

*** TODO 依次读入文件每一行
- State "TODO"       from ""           [2016-01-23 六 01:20]
  == 加空格
#+BEGIN_EXAMPLE
    $ while read -r line; do
        # do something with $line
    done < file
#+END_EXAMPLE

这是一种正确的读取文件内容的做法，=read=命令放在=while=循环中。当=read=命令遇到文件结尾时（EOF），它会返回一个正值，导致循环判断失败终止。

记住，=read=命令会删除首尾多余的空白字符，所以如果你想保留，请设置 IFS
为空值:

#+BEGIN_EXAMPLE
    $ while IFS= read -r line; do
        # do something with $line
    done < file
#+END_EXAMPLE

如果你不想将=< file=放在最后，可以通过管道将文件的内容输入到 while
循环中：

#+BEGIN_EXAMPLE
    $ cat file | while IFS= read -r line; do
        # do something with $line
    done
#+END_EXAMPLE

*** 5. 随机读取一行并赋值给变量

#+BEGIN_EXAMPLE
    $ read -r random_line < <(shuf file)
#+END_EXAMPLE

Bash
中并没有提供一种直接的方法来随机读取文件的某一行内容，所以这里需要利用外部程序。在最新的一些
Linux 系统上，GNU Coreutils 包中提供的=shuf=命令可以满足我们的需求。

这一行命令中用到了进程替换（[[http://tldp.org/LDP/abs/html/process-sub.html][process
substitution]]）操作符=<(...)=。进程替换操作会创建一个匿名的管道文件，并将进程命令的标准输出连接到管道的写一端。然后
Bash
开始执行进程替换中的命令，然后将整个进程替换的表达式替换成匿名管道的文件名。

当 Bash
看到=<(shuf file)=时，它首先打开一个特殊的文件=/dev/fd/n=，这里的=n=是一个空闲的文件描述符，然后执行=shuf file=命令，将标准输出连接到=/dev/fd/n=，并且替换=<(shuf file)=
为=/dev/fd/n=，因此实际的命令会变成:

#+BEGIN_EXAMPLE
    $ read -r random_line < /dev/fd/n
#+END_EXAMPLE

结果会读取洗牌后的文件的第一行内容。

另外一种做法是，使用 GNU sort 命令，它提供的=-R=选项可以随机排序文件：

#+BEGIN_EXAMPLE
    $ read -r random_line < <(sort -R file
#+END_EXAMPLE

或者，同前面一样，将结果赋值给变量：

#+BEGIN_EXAMPLE
    $ random_line=$(sort -R file | head -1)
#+END_EXAMPLE

这里，我们首先通过=sort -R=随机排序文件，然后通过=head -1=
读取文件的第一行。

*** 6. 读取文件首行前三个字段并赋值给变量

#+BEGIN_EXAMPLE
    $ while read -r field1 field2 field3 throwaway; do
        # do something with $field1, $field2, and $field3
    done < file
#+END_EXAMPLE

如果在=read=命令中指定多个变量名，它会将读入的内容分隔成多个字段，然后依次赋值给对应的变量，第一个字段赋值给第一个变量，第二个字段赋值给第二个变量，等等，最后将剩余的所有字段赋值给最后一个变量。这也是为什么，在上面的例子中，我们加了一个=throwaway=变量，否则的话，当文件的一行大于三个字段时，第三个变量的内容会包含所有剩余的字段。

有时候，为了书写方便，可以简单地用=_=来替换=throwaway=变量：

#+BEGIN_EXAMPLE
    $ while read -r field1 field2 field3 _; do
        # do something with $field1, $field2, and $field3
    done < file
#+END_EXAMPLE

又或者，如果你的文件确实只有三个字段，那可以忽略它：

#+BEGIN_EXAMPLE
    $ while read -r field1 field2 field3; do
        # do something with $field1, $field2, and $field3
    done < file
#+END_EXAMPLE

下面是一个例子，假如你想知道一个文件到底包含多少行，多少个单词以及多少个字节。当你执行=wc=命令时，你会得到3个数字加上文件名，文件名在最后：

#+BEGIN_EXAMPLE
    $ cat file-with-5-lines
    x 1
    x 2
    x 3
    x 4
    x 5

    $ wc file-with-5-lines
     5 10 20 file-with-5-lines
#+END_EXAMPLE

所以，这个文件包含5行，10个单词，以及20个字符。我们接下来，可以通过=read=命令将这些信息保存到变量中：

#+BEGIN_EXAMPLE
    $ read lines words chars _ < <(wc file-with-5-lines)

    $ echo $lines
    5
    $ echo $words
    10
    $ echo $chars
    20
#+END_EXAMPLE

类似地，你也可以使用
[[http://linux.die.net/abs-guide/x15683.html][here-strings]]
将字符串分隔并保存到变量中。假设你有一个字符串变量=$info=，内容为="20 packets in 10 seconds"=，然后你想要将从中获取=20=和=10=。在不久之前，我是这样来完成的：

#+BEGIN_EXAMPLE
    $ packets=$(echo $info | awk '{ print $1 }')
    $ time=$(echo $info | awk '{ print $4 }')
#+END_EXAMPLE



然而，得益于=read=命令的强大和对 Bash 的了解，我们可以这样做：

#+BEGIN_EXAMPLE
    $ read packets _ _ time _ <<< "$info"
#+END_EXAMPLE

这里，=<<<= 就是 here-string 的语法，它允许你直接传递字符串给标准输入。

*** 7. 保存文件的大小到变量

#+BEGIN_EXAMPLE
    $ size=$(wc -c < file)
#+END_EXAMPLE

这一行命令中用到了第3点中介绍的命令替换操作=$(...)=，它运行里面的命令并将结果获取回来。在这个例子中，命令是=wc -c < file=，它输出文件的字节数。这个结果最终会赋值给变量=size=。

*** 8. 从文件路径中获取文件名

假设，你有一个文件，它的路径为=/path/to/file.ext=，然后你要从中获取文件名，在这里是=file.ext=。你要怎么做？
一个好的方法是通过参数展开（[[http://tldp.org/LDP/abs/html/parameter-substitution.html][parameter
expansion]]）功能：

#+BEGIN_EXAMPLE
    $ filename=${path##*/}
#+END_EXAMPLE

这一行命令使用了参数展开的语法：=${var##pattern}=，它从=$var=字符串开始处开始匹配=pattern=。如果能够匹配成功，将最长匹配的内容删除后再返回。

在这个例子中，匹配的模式是=*/=，它尝试匹配=/path/to/file.ext=的开始部分，正如前面所说，这里是贪婪匹配，所以它能够匹配到最后一个斜杠为止，即匹配的内容是=/path/to/=。所以当把匹配的内容删除后，返回的内容就是文件名=file.ext=。

*** 9. 从文件路径中获取目录名

和上面一样类似，这次你要从路径=/path/to/file.txt=中获取目录名=/path/to=。你可以继续通过参数展开功能来完成这个任务：

#+BEGIN_EXAMPLE
    $ dirname=${path%/*}
#+END_EXAMPLE

这次的用法是=${var%pattern}=，它从=$var=的结尾处匹配=/*=。如果能够成功匹配，将最短匹配的内容删除再返回。

在这个例子中，匹配的模式是=/*=，它能够匹配=/file.ext=部分，删除这部分内容后返回的就是目录名称。

*** 10. 快速拷贝文件

假设你要将文件=/path/to/fil=拷贝到=/path/to/file_copy=，一般情况下，大多数人会这么来写：

#+BEGIN_EXAMPLE
    $ cp /path/to/file /path/to/file_copy
#+END_EXAMPLE

不过，你可以利用括号展开（[[http://wiki.bash-hackers.org/syntax/expansion/brace][brace
expansion]]）={...}=功能:

#+BEGIN_EXAMPLE
    $ cp /path/to/file{,_copy}
#+END_EXAMPLE

括号展开可以生成任意字符串的组合，在这个例子中，=/path/to/file{,_copy}=最终生成=/path/to/file /path/to/file_copy=。所以上面这行命令最终发型成:

#+BEGIN_EXAMPLE
    $ cp /path/to/file /path/to/file_copy
#+END_EXAMPLE

类似地，你可以执行下面的命令快速的移动文件：

#+BEGIN_EXAMPLE
    $ mv /path/to/file{,_old}
#+END_EXAMPLE

这行命令展开后就变成了：

#+BEGIN_EXAMPLE
    $ mv /path/to/file /path/to/file_old
#+END_EXAMPLE

** TODO [[http://blog.csdn.net/xiaoweiboy/article/details/6714199][单片机I/O口推挽输出与开漏输出的区别]]
- State "TODO"       from ""           [2016-01-23 六 01:19]
  图

推挽输出:可以输出高,低电平,连接数字器件;

开漏输出:输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行.
适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内).

推挽结构一般是指两个三极管分别受两互补信号的控制,总是在一个三极管导通
的时候另一个截止.

我们先来说说集电极开路输出的结构。集电极开路输出的结构如图1所示，右边
的那个三极管集电极什么都不接，所以叫做集电极开路（左边的三极管为反相之
用，使输入为“0”时，输出也为“0”）。对于图1，当左端的输入为“0”时，
前面的三极管截止（即集电极C跟发射极E之间相当于断开），所以5V电源通过1K
电阻加到右边的三极管上，右边的三极管导通（即相当于一个开关闭合）；当左
端的输入为“1”时，前面的三极管导通，而后面的三极管截止（相当于开关断
开）。


[[http://www.eetop.cn/blog/attachments/2006/11/20061121_db31d8cfd1b54c04acd481b012275d2b.jpg]]


我们将图1简化成图2的样子。图2中的开关受软件控制，“1”时断开，“0”时闭合。很明显可以看出，当开关闭合时，输出直接接地，所以输出电平为0。而当开关断开时，则输出端悬空了，即高阻态。这时电平状态未知，如果后面一个电阻负载（即使很轻的负载）到地，那么输出端的电平就被这个负载拉到低电平了，所以这个电路是不能输出高电平的。

再看图三。图三中那个1K的电阻即是上拉电阻。如果开关闭合，则有电流从1K电阻及开关上流过，但由于开关闭[[http://hi.baidu.com/tracyao/blog/item/file::;][其它]]三个口带内部上拉），当我们要使用输入功能时，只要将输出口设置为1即可，这样就相当于那个开关断开，而对于P0口来说，就是高阻态了。

对于漏极开路（OD）输出，跟集电极开路输出是十分类似的。将上面的三极管换成场效应管即可。这样集电极就变成了漏极，OC就变成了OD，原理分析是一样的。

另一种输出结构是推挽输出。推挽输出的结构就是把上面的上拉电阻也换成一个开关，当要输出高电平时，上面的开关通，下面的开关断；而要输出低电平时，则刚好相反。比起OC或者OD来说，这样的推挽结构高、低电平驱动能力都很强。如果两个输出不同电平的输出口接在一起的话，就会产生很大的电流，有可能将输出口烧坏。而上面说的OC或OD输出则不会有这样的情况，因为上拉电阻提供的电流比较小。如果是推挽输出的要设置为高阻态时，则两个开关必须同时断开（或者在输出口上使用一个传输门），这样可作为输入状态，AVR单片机的一些IO口就是这种结构。



开漏电路特点及应用

   在电路设计时我们常常遇到开漏（open drain）和开集（open
collector）的概念。

所谓开漏电路概念中提到的“漏”就是指MOSFET的漏极。同理，开集电路中的“集”就是指三极管的集电极。开漏电路就是指以MOSFET的漏极为输出的电路。一般的用法是会在漏极外部的电路添加上拉电阻。完整的开漏电路应该由开漏器件和开漏上拉电阻组成。如图1所示：

[[http://www.cheluck.com/Article/UploadFiles/200706/20070614000913601.jpg][[[http://img.blog.163.com/photo/CWrVHp5T2Rn_gMeauvIbwA==/5385742204382260745.jpg]]]]

  图1

 组成开漏形式的电路有以下几个特点：
        1.
利用外部电路的驱动能力，减少IC内部的驱动（或驱动比芯片电源电压高的负载）。当IC内部MOSFET导通时，驱动电流是从外部的VCC流经R
pull-up ，MOSFET到GND。IC内部仅需很下的栅极驱动电流。如图1。

2. 可以将多个开漏输出的Pin，连接到一条线上。形成 “与逻辑”
关系。如图1，当PIN_A、PIN_B、PIN_C任意一个变低后，开漏线上的逻辑就为0了。这也是I2C，SMBus等总线判断总线占用状态的原理。如果作为输出必须接上拉电阻。接容性负载时，下降延是芯片内的晶体管，是有源驱动，速度较快；上升延是无源的外接电阻，速度慢。如果要求速度高电阻选择要小，功耗会大。所以负载电阻的选择要兼顾功耗和速度。
        3. 可以利用改变上拉电源的电压，改变传输电平。如图2,
IC的逻辑电平由电源Vcc1决定，而输出高电平则由Vcc2（上拉电阻的电源电压）决定。这样我们就可以用低电平逻辑控制输出高电平逻辑了（这样你就可以进行任意电平的转换）。（例如加上上拉电阻就可以提供TTL/CMOS电平输出等。）

[[http://www.cheluck.com/Article/UploadFiles/200706/20070614000913790.jpg][[[http://img.blog.163.com/photo/EIqHbVf0m6bd6V2z3VX4iA==/5385742204382260744.jpg]]]]

  图2

4.
开漏Pin不连接外部的上拉电阻，则只能输出低电平(因此对于经典的51单片机的P0口而言，要想做输入输出功能必须加外部上拉电阻，否则无法输出高电平逻辑)。一般来说，开漏是用来连接不同电平的器件，匹配电平用的。
        5.
标准的开漏脚一般只有输出的能力。添加其它的判断电路，才能具备双向输入、输出的能力。


 6.正常的CMOS输出级是上、下两个管子，把上面的管子去掉就是OPEN-DRAIN了。这种输出的主要目的有两个：电平转换、线与。

7.线与功能主要用于有多个电路对同一信号进行拉低操作的场合，如果本电路不想拉低，就输出高电平，因为OPEN-DRAIN上面的管子被拿掉，高电平是靠外接的上拉电阻实现的。（而正常的CMOS输出级，如果出现一个输出为高另外一个为低时，等于电源短路。）

8.OPEN-DRAIN提供了灵活的输出方式，但是也有其弱点，就是带来上升沿的延时。因为上升沿是通过外接上拉无源电阻对负载充电，所以当电阻选择小时延时就小，但功耗大；反之延时大功耗小。所以如果对延时有要求，则建议用下降沿输出。

应用中需注意：
              1.
开漏和开集的原理类似，在许多应用中我们利用开集电路代替开漏电路。例如，某输入Pin要求由开漏电路驱动。则我们常见的驱动方式是利用一个三极管组成开集电路来驱动它，即方便又节省成本。如图3。

[[http://www.cheluck.com/Article/UploadFiles/200706/20070614000913809.jpg][[[http://img.blog.163.com/photo/X_TpSikFBZLkYIzLqNZR1A==/5385742204382260743.jpg]]]]

              2. 上拉电阻R
pull-up的阻值决定了逻辑电平转换的沿的速度。阻值越大，速度越低功耗越小。反之亦然。


Push-Pull输出就是一般所说的推挽输出，在CMOS电路里面应该较CMOS输出更合适，因为在CMOS里面的push－pull输出能力不可能做得双极那么大。输出能力看IC内部输出极N管P管的面积。和开漏输出相比，push－pull的高低电平由IC的电源低定，不能简单的做逻辑操作等。push－pull是现在CMOS电路里面用得最多的输出级设计方式。

当然open
drain也不是没有代价，这就是输出的驱动能力很差。输出的驱动能力很差的说法不准确，驱动能力取决于IC中的末级晶体管功率。OD只是带来上升沿的延时，因为上升沿是通过外接上拉无源电阻对负载充电的，当电阻选择小时延时就小、但功耗大，反之延时大功耗小。OPEN
DRAIN提供了灵活的输出方式，但也是有代价的，如果对延时有要求，建议用下降沿输出。

电阻小延时小的前提条件是电阻选择的原则应在末级晶体管功耗允许范围内，有经验的设计者在使用逻辑芯片时，不会选择1欧姆的电阻作为上拉电阻。在脉冲的上升沿电源通过上拉无源电阻对负载充电，显然电阻越小上升时间越短，在脉冲的下降沿，除了负载通过有源晶体管放电外，电源也通过上拉电阻和导通的晶体管对地
形成通路，带来的问题是芯片的功耗和耗电问题。电阻影响上升沿，不影响下降沿。如果使用中不关心上升沿，上拉电阻就可选择尽可能的大点，以减少对地通路的
电流。如果对上升沿时间要求较高，电阻大小的选择应以芯片功耗为参考。

** [[http://kodango.com/shell-script-style][Shell 编码风格]]

[[http://wiki.bash-hackers.org/scripting/style][Scripting with style]] 是少见的一篇介绍 Shell 编码风格的文章，相信对大多
数运维人员有用，现在将译文献上。

*** 缩进准则

我一般使用2个空格来缩进（尽管大多人使用4个空格），原因是：

-  输入简单快速；
-  没有输入一个Tab键，避免不同环境下显示的差异问题；
-  缩进的效果已经足够，并且没有浪费太多的空间；

#+BEGIN_QUOTE
  译者注：本人也是使用4个空格，如果你也与本文作者的风格不一样，下面说到2个空格的地方请自觉替换成你实际使用的空格数。个人认为，缩进只是一个个人的风格，只要不影响可读性即可。
#+END_QUOTE

顺便说一句，尽量不要使用Tab键，它们容易带来麻烦，我只能想到一种情况下它是有用的：here
document中的缩进。

**** 分隔长行

如果需要分隔过长的代码，你可以使用下面的任意一种方法：

1） 使用与命令宽度相同的缩进

#+BEGIN_EXAMPLE
    activate some_very_long_option \
             some_other_option
#+END_EXAMPLE

2） 使用2个空格缩进

#+BEGIN_EXAMPLE
    activate some_very_long_option \
      some_other_option
#+END_EXAMPLE

从个人的角度来说，除非有特别的需要，我更倾向于第一种形式，因为它突出“上下两行的内容是一起的”这一联系。

**** 分离复合命令

#+BEGIN_QUOTE
  译者注：其实这里的复合命令就是指块语句，例如for/while循环,
  if分支结构等等。
#+END_QUOTE

#+BEGIN_EXAMPLE
    HEAD_KEYWORD parameters; BODY_BEGIN
      BODY_COMMANDS
    BODY_END
#+END_EXAMPLE

我习惯于：

-  将HEAD_KEYWORD和初始化命令或者参数放在第一行；
-  将BODY_BEGIN同样放在第一行；
-  复合命令中的BODY部分以2个空格缩进；
-  BODY_END部分独立一行放在最后；

1）if/then/elif/else分支语句

#+BEGIN_EXAMPLE
    if ...; then
      ...
    elif ...; then
      ...
    else
      ...
    fi
#+END_EXAMPLE

2）for循环

#+BEGIN_EXAMPLE
    for f in /etc/*; do
      ...
    done
#+END_EXAMPLE

3） while/until循环

#+BEGIN_EXAMPLE
    while [[ $answer != [YyNn] ]]; do
      ...
    done
#+END_EXAMPLE

4） case分支语句

#+BEGIN_EXAMPLE
    case $input in
      hello)
        echo "You said hello"
      ;;
      bye)
        echo "You said bye"
        if foo; then
          bar
        fi
      ;;
      *)
        echo "You said something weird..."
      ;;
    esac
#+END_EXAMPLE

几点注意的地方：

-  如果不是100%需要，匹配部分左右的括号不需要写（*译者注：例如写成hello)而不是(hello)*）；
-  匹配模式与分支的终止符号;;位于同一缩进级别
-  分支内部的命令多缩进一层；
-  尽管是可选的，这里还是把最后一个分支的终止符号也写上了；

*** 语法和编码指引

**** 晦涩的语法结构

我们都喜欢一些晦涩的语法结构，因为它们很简洁。但是如果不是100%需要用到，尽量不要使用它们，否则大多数人无法理解你的代码。

所以有有时候，我们需要在代码的智能，效率与可读性之间找到一个平衡点。

如果你一定要使用这种语法结构，记得在用的地方写上一小段注释。

#+BEGIN_QUOTE
  译者注：Shell提供的一些语法糖很难理解，但是有非常简洁实用，本人也很喜欢用，这样可以省下一大堆精力，而且用熟了也没有什么难以理解的，但是作者说的也有道理，这一点就仁者见仁，智者见智了
#+END_QUOTE

**** 变量名

因为所有保留的变量名都是大写的，最安全的方法是仅使用小写字母作为变量名，例如读入用户的输入、循环变量等等......：

-  变量名尽量选择小写字母；
-  如果你使用大写的变量名，不要使用保留的变量名（一份不完全的列表参见[[http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08][SUS]]）；
-  如果你使用大写的变量名，最后在变量名前面加一个独特的前缀（例如下面例子中的MY_）；

下面是一个例子：

#+BEGIN_EXAMPLE
    #!/bin/bash

    # the prefix 'MY_'
    MY_LOG_DIRECTORY=/var/adm/

    for file in "$MY_LOG_DIRECTORY"/*; do
      echo "Found Logfile: $file"
    done
#+END_EXAMPLE

**** 变量初始化

正如C语言一样，最好的处理是在变量声明的时候初始化。

用户可以将一个变量以环境变量的形式传递到脚本中。如果你盲目地假定你使用的所有变量都是未初始化的，其它人可以以环境变量的形式劫持一个变量。

#+BEGIN_QUOTE
  译者注：一个例子说明这一点：

  #+BEGIN_EXAMPLE
      $ cat b.sh

      if [ -z "$var" ]; then
          echo "$var is not set"
          var=1
      fi

      echo "Now, var is equals to $var"
      var=2 sh b.sh
      Now, var is equals to 2
  #+END_EXAMPLE
#+END_QUOTE

解决这个问题的方法很简单，将变量初始化：

#+BEGIN_EXAMPLE
    my_input=""
    my_array=()
    my_number=0
#+END_EXAMPLE

**** 参数展开

除非你知道自己做的事情，*请在参数展开的地方使用双引号*

当然，也有一些地方并不需要使用双引号，例如：

-  [[ ]]测试表达式内部是不会展开的；
-  在case $WORD in语法中WORD也不会展开的；
-  在变量赋值var=$WORD的地方也是不会展开的

但是在这些地方使用引号并不会出错，如果你习惯于在每个可能展开参数的地方使用引号，你写得代码会很安全。

如果你要传递一个参数作为一个单词列表，你可以不使用引号，例如：

#+BEGIN_EXAMPLE
    list="one two three"

    # you MUST NOT quote $list here
    for word in $list; do
      ...
    done
#+END_EXAMPLE

**** 函数名称

函数名称应该采用小写的形式，并且有一个很好的意义。函数名称应该容易让人理解，比如f1这个名称虽然容易输入但是对调试和其它人阅读代码造成了很大的困难，它说明不了任何东西。好的函数名称可以帮助说明代码，而不需要额外的注释。

一个或多或少有趣的是：如果你无意这样做，不要把函数名称命名为常见的命令名，新手往往比较容易将脚本或者函数名命名成test，这样就和UNIX的test命令冲突了。

除非绝对必要，仅使用字母、数字和下划线作为函数名称。+/bin/ls也是一个合法的Bash函数名称。+

#+BEGIN_QUOTE
  译者注：/bin/ls不是一个合法的函数名称。
#+END_QUOTE

**** 命令替换

正如文章[[http://wiki.bash-hackers.org/syntax/expansion/cmdsubst][the
article about command substitution [Bash Hackers
Wiki]]]中提及的，你应该使用$( .. )形式。

不过，如果可移植性是一个问题，你可能必须使用反引号的形式`...`。

在任何情况，如果其它展开或者单词分隔并不是你期望的，你应该将命令替换用双引号引起来。

**** Eval命令

正如Greg据说的：“If eval is the answer, surely you are asking the wrong
question.”。

避免它，除非绝对必要：

-  eval can be your neckshot（可能是你的麻烦？）
-  很有可能有其它的方法来实现你需要的；
-  如果可能，重新思考下脚本的工作过程，当eval的使用不可避免的时候；
-  如果你实在需要使用，小心慎用；

*** 脚本的基本结构

一个脚本的基本结构是这样的：

#+BEGIN_EXAMPLE
    #!SHEBANG

    CONFIGURATION_VARIABLES

    FUNCTION_DEFINITIONS

    MAIN_CODE
#+END_EXAMPLE

**** Shebang

如果可能，请不要忘记shebang。

请小心使用/bin/sh作为shebang，在Linux系统中，/bin/sh就是Bash这是一个错误的观点。

于我而言，shebang有两个目的：

-  说明直接执行时以哪个解释器来执行；
-  明确该脚本应该以哪个解释器来执行；

**** 配置变量

在这里，我将这一类变量------可以被用户更改的------叫做配置变量。

让这类变量容易找到，一般放在脚本的头部，给它们有意义的名称并且加上注释说明。正如上面说的，仅当你知道你为什么这么做的时候，才用大写的变量名形式，否则小写形式更加安全。

**** 函数定义

所有函数定义应该在脚本主要代码执行之前，这样可以给人全局的印象，并且确保所有函数在使用之前它是已知的。

你应该使用可移植性高的函数定义形式，即不带function关键字的形式。

*** 脚本行为和健壮性

-  当脚本检测到问题时尽早退出，以免执行潜在的问题；
-  如果你需要用到的命令可能并没有安装在系统上，在脚本执行的时候最好检查命令是否存在并且提醒用户缺少什么；
-  采用有意义的脚本返回值，例如0代码成功，1代码错误或者失败；

*** 其它

**** 输出内容

-  if the script is interactive, if it works for you and if you think
   this is a nice feature, you can try to
   [[http://wiki.bash-hackers.org/snipplets/screen_saverestore][save the
   terminal content and restore it]] after
   execution；（译者注：不理解这一点是什么意思）
-  在屏幕中输出简单易理解的消息；
-  使用颜色或者特别的前缀区分错误和警告信息；
-  输出正常的内容到STDOUT，而输出错误、警告或者诊断的信息到STDERR；
-  在日志文件中输出所有详细的信息；

**** 输入

不要盲目地假设任何事情，如果你希望用户输入一个数字，请在脚本中主动检查它是否真得是一个数字，检查头部是否包含0，等等。我们都应该知道这一点，用户仅仅是用户而不是程序员，他们会做他们想要的，而不是程序想要的。

** [[http://teliute.org/linux/abs-3.9.1/unofficialst.html][非官方的Shell脚本编写风格]]

-  习惯性的注释你的代码.
   这可以让别人更容易看懂(或者感激)你的代码(译者注: 犯错时,
   别人也会靠注释找到你), 而且也更便于维护.

   | #+BEGIN_EXAMPLE                                                                              |
   |       1 PASS="$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}"                                      |
   |       2 # 去年你写下这段代码的时候, 你非常了解这段代码的含义, 但现在它对你来说完全是个谜.    |
   |       3 # (摘自Antek Sawicki的"pw.sh"脚本.)                                                  |
   | #+END_EXAMPLE                                                                                |


   给脚本和函数加上描述性的头信息.

   | #+BEGIN_EXAMPLE                                                         |
   |       1 #!/bin/bash                                                     |
   |       2                                                                 |
   |       3 #************************************************#              |
   |       4 #                   xyz.sh                       #              |
   |       5 #           written by Bozo Bozeman              #              |
   |       6 #                July 05, 2001                   #              |
   |       7 #                                                #              |
   |       8 #           Clean up project files.              #              |
   |       9 #************************************************#              |
   |      10                                                                 |
   |      11 E_BADDIR=65                       # 没有这个目录.               |
   |      12 projectdir=/home/bozo/projects    # 想要清除的目录.             |
   |      13                                                                 |
   |      14 # --------------------------------------------------------- #   |
   |      15 # cleanup_pfiles ()                                         #   |
   |      16 # 删除指定目录中的所有文件.                                 #   |
   |      17 # Parameter: $target_directory                              #   |
   |      18 # 返回值: 0表示成功, 失败返回$E_BADDIR.                     #   |
   |      19 # --------------------------------------------------------- #   |
   |      20 cleanup_pfiles ()                                               |
   |      21 {                                                               |
   |      22   if [ ! -d "$1" ]  # Test if target directory exists.          |
   |      23   then                                                          |
   |      24     echo "$1 is not a directory."                               |
   |      25     return $E_BADDIR                                            |
   |      26   fi                                                            |
   |      27                                                                 |
   |      28   rm -f "$1"/*                                                  |
   |      29   return 0   # Success.                                         |
   |      30 }                                                               |
   |      31                                                                 |
   |      32 cleanup_pfiles $projectdir                                      |
   |      33                                                                 |
   |      34 exit 0                                                          |
   | #+END_EXAMPLE                                                           |


   在脚本开头添加任何注释之前,
   一定要确保/#!/bin/bash/放在脚本第一行的开头.

-  避免使用"魔法数字", [[#FTN.AEN15556][[1]]] 也就是,
   避免"写死的"字符常量. 可以使用有意义的变量名来代替.
   这使得脚本更易于理解, 并且允许在不破坏应用的情况下进行修改和更新.

   | #+BEGIN_EXAMPLE                                                       |
   |       1 if [ -f /var/log/messages ]                                   |
   |       2 then                                                          |
   |       3   ...                                                         |
   |       4 fi                                                            |
   |       5 # 一年以后, 你决定修改这个脚本, 让它来检查/var/log/syslog.    |
   |       6 # 到时候你就必须一行一行的手动修改这个脚本,                   |
   |       7 # 并且寄希望于没有遗漏的地方.                                 |
   |       8                                                               |
   |       9 # 更好的办法是:                                               |
   |      10 LOGFILE=/var/log/messages  # 只需要改动一行就行了.            |
   |      11 if [ -f "$LOGFILE" ]                                          |
   |      12 then                                                          |
   |      13   ...                                                         |
   |      14 fi                                                            |
   | #+END_EXAMPLE                                                         |


-  给变量和函数起一些有意义的名字.

   | #+BEGIN_EXAMPLE                                                                   |
   |       1 fl=`ls -al $dirname`                 # 含义模糊.                          |
   |       2 file_listing=`ls -al $dirname`       # 更好的名字.                        |
   |       3                                                                           |
   |       4                                                                           |
   |       5 MAXVAL=10   # 使用变量来代替脚本常量, 并且在脚本中都是用这个变量.         |
   |       6 while [ "$index" -le "$MAXVAL" ]                                          |
   |       7 ...                                                                       |
   |       8                                                                           |
   |       9                                                                           |
   |      10 E_NOTFOUND=75                        #  错误码使用大写,                   |
   |      11                                      #+ 并且命名的时候用"E_"作为前缀.     |
   |      12 if [ ! -e "$filename" ]                                                   |
   |      13 then                                                                      |
   |      14   echo "File $filename not found."                                        |
   |      15   exit $E_NOTFOUND                                                        |
   |      16 fi                                                                        |
   |      17                                                                           |
   |      18                                                                           |
   |      19 MAIL_DIRECTORY=/var/spool/mail/bozo  # 环境变量名使用大写.                |
   |      20 export MAIL_DIRECTORY                                                     |
   |      21                                                                           |
   |      22                                                                           |
   |      23 GetAnswer ()                         # 函数名采用大小写混合的方式.        |
   |      24 {                                                                         |
   |      25   prompt=$1                                                               |
   |      26   echo -n $prompt                                                         |
   |      27   read answer                                                             |
   |      28   return $answer                                                          |
   |      29 }                                                                         |
   |      30                                                                           |
   |      31 GetAnswer "What is your favorite number? "                                |
   |      32 favorite_number=$?                                                        |
   |      33 echo $favorite_number                                                     |
   |      34                                                                           |
   |      35                                                                           |
   |      36 _uservariable=23                     # 语法上可以这么起名, 但是不推荐.    |
   |      37 # 用户定义的变量名最好不要以下划线开头.                                   |
   |      38 # 因为以下划线开头的变量, 一般都保留, 作为系统变量.                       |
   | #+END_EXAMPLE                                                                     |


-  [[exit-status.html#EXITCOMMANDREF][退出码]]最好也采用具有系统性的或有意义的命名方式.

   | #+BEGIN_EXAMPLE              |
   |       1 E_WRONG_ARGS=65      |
   |       2 ...                  |
   |       3 ...                  |
   |       4 exit $E_WRONG_ARGS   |
   | #+END_EXAMPLE                |


   也请参考[[exitcodes.html][Appendix D]].

   /最后/, 我们建议采用=/usr/include/sysexits.h=中的定义作为退出码,
   虽然这些定义主要用于C/C++编程语言.

-  在脚本调用中使用标准化的参数标志. /最后/, 我们建议使用下面的参数集.

   | #+BEGIN_EXAMPLE                                                        |
   |       1 -a      全部: 返回全部信息(包括隐藏的文件信息).                |
   |       2 -b      摘要: 缩减版本, 通常用于其它版本. 通常用于其它脚本.    |
   |       3 -c      拷贝, 连接, 等等.                                      |
   |       4 -d      日常的: 使用全天的信息,                                |
   |       5         而不仅仅是特定用户或特定实例的信息.                    |
   |       6 -e      扩展/详细描述: (通常不包括隐藏文件信息).               |
   |       7 -h      帮助: 详细的使用方法, 附加信息, 讨论, 帮助.            |
   |       8         也请参考-V.                                            |
   |       9 -l      打印出脚本的输出记录.                                  |
   |      10 -m      手册: 显示基本命令的man页.                             |
   |      11 -n      数字: 仅使用数字数据.                                  |
   |      12 -r      递归: 这个目录中所有的文件(也包含所有子目录).          |
   |      13 -s      安装&文件维护: 这个脚本的配置文件.                     |
   |      14 -u      用法: 列出脚本的调用方法.                              |
   |      15 -v      详细信息: 只读输出, 或多或少的会做一些格式化.          |
   |      16 -V      版本/许可/版权Copy(right|left)/捐助(邮件列表).         |
   | #+END_EXAMPLE                                                          |


   也请参考[[standard-options.html][Section F.1]].

-  将一个复杂脚本分割成一些简单的模块. 使用合适的函数来实现模块的功能.
   请参考[[bashver2.html#EX79][例子 34-4]].

-  如果有更简单的结构可以使用的话, 就不要使用复杂的结构.

   | #+BEGIN_EXAMPLE                            |
   |       1 COMMAND                            |
   |       2 if [ $? -eq 0 ]                    |
   |       3 ...                                |
   |       4 # 多余, 而且不好理解.              |
   |       5                                    |
   |       6 if COMMAND                         |
   |       7 ...                                |
   |       8 # 更简练(可能会损失一些可读性).    |
   | #+END_EXAMPLE                              |


|     | //                                                                                                                                                                                        |
|     | /... 当我阅读UNIX中Bourne shell (/bin/sh)部分的源代码时. 我被震惊了, 有多少简单的算法被恶心的编码风格弄得令人看不懂, 并且因此变得没用. 我问我自己, "有人会对这种代码感到骄傲和自豪么?"/   |
|     | /Landon Noll/                                                                                                                                                                             |

*** 注意事项

| [[unofficialst.html#AEN15556][[1]]]   | 在这种上下文中所说的"魔法数字"与用来指明文件类型的[[sha-bang.html#MAGNUMREF][魔法数字]], 在含义上完全不同.   |

** [[http://www.linuxidc.com/Linux/2013-06/85747.htm][用GParted-LiveCD进行Ubuntu分区大小的调整]]

一、准备

1、下载最新版本的gparted镜像文件：点击这里。

2、将gparted镜像文件刻录成光盘或压制在U盘上制成LiveUSB

3、虽说是无损调整，但为了安全起见(万一停电咋办？)，建议备份重要数据到移动硬盘上

4、在BIOS中，将启动顺序设置为首先光驱启动(如果是用LiveUSB，应设为USB-HDD)

二、调整分区

1、将光盘放入光驱(如果是用LiveUSB，插上U盘)，重启电脑

2、进入gparted启动界面，直接选Defalt settings

3、第二个界面继续按回车

4、接下来选语言，输入“26”回车(就是简体中文，尽管汉化不全)

5、接着提示将要进入X-Windows界面，回车

6、进入gparted，就会发现和瘟到死的PQ相似的界面，实际操作也是一样的，而且也支持瘟到死分区的调整

7、点击你要腾出空间的分区，弹出右键菜单选择“Resize/Move”

8、用鼠标托动或数字精确调整要释放的空间大小，若要释放在分区头部拉左侧的控制条(输入第一行数值)，若要释放在分区尾部拉右侧的控制条(输入第三行数值),调整好之后点“更改大小/移动”按钮。

9、点击欲扩大容量的分区，弹出右键菜单选择“Resize/Move”

10、按照第8步的方法操作，只是现在变成扩大分区容量而已

11、点击“Edit”菜单，选择“Apply All Operations”

12、再次确认要调整分区容量后，gparted开始调整分区，完成后点“Close”按钮

13、点“gparted”菜单，选“Quit”关闭gparted窗口，再双击左上角的“Exit”按钮退出gparted系统

14、在弹出的窗口中选“Reboot”重启电脑，退出时系统会提示你取出光盘

三、可能存在的问题

可能会发生swap分区丢失的情况，可在终端中用“free -m”命令查看swap分区是否激活(是否显示容量)，如果未激活，可用“sudo mkswap /dev/sdaX”命令(X为swap分区的编号)进行激活，并将激活所得的UUID码替换掉“/etc/fstab”文件(需要管理员权限)中原来 swap分区的UUID编码，重启后即可自动激活挂载

警告：对swap分区的激活操作及对fstab文件的修改应谨慎，必需仔细核对修改的值

** [[http://www.linuxidc.com/Linux/2010-05/26118.htm][Ubuntu下硬盘安装Windows 7]]

此前在Ubuntu下用virtualbox装了份Windows 7，确实比以往的Windows好用许多。于是花了点时间把机子上原来与Ubuntu并存的Windows XP升级成Windows 7。

所需工具、文件
Windows 7安装镜像;
我下载的是7600.16385.090713-1255_x64fre_client_zh-cn_Retail_Ultimate-GRMCULXFRER_CN_DVD.iso,3.1G。
Grub4Dos
用于引导Windows安装，后来听说Grub2也行，还要更方便一些，但我没可能再装一遍，以下还是以grub4dos为例;
EasyBCD
用于在Windows安装完成后找回启动Ubuntu的菜单.

备份MBR
$ sudo dd if=/dev/sda of=/backup/mbr.img bs=512 count=1

至关重要。Ubuntu的安装过程会保留Windows启动项，但Windows的安装过程却很霸道，安装后需导入MBR才能找回Ubuntu启动项。
Windows下无法访问Ubuntu里的文件，所以需要把这个备份文件复制到Windows文件系统下，或则先用U盘备份。

挂载Windows 7 ISO
$ sudo mount /iso/7600.16385.090713-1255_x64fre_client_zh-cn_Retail_Ultimate-GRMCULXFRER_CN_DVD.iso /mnt -o loop
即把Windows 7 ISO挂载到/mnt，打开这个目录，把里边的所有文件复制到一个NTFS分区的根目录下——不能是将用于安装Windows 7的分区，亦即，需要预先准备两个Windows分区。

我这里因为原本就是Windows与Ubuntu并存，Windows下有C、D、E盘，C盘准备用来安装Windows 7，以上安装文件就复制到了E盘根目录下。

添加启动菜单
打开载下来的Grub4dos.zip，把其中的grub.exe解压出来。
修改/boot/grub/menu.lst,添加如下几行

title grub4dos
root (hd0,3)
kernel /home/grub.exe
boot

第二行的0,3需根据实际情况修改，可查看menu.lst里原有的部分，找到Ubuntu的选项复制成一样的即可。
如我原有启动项第一项是:

title Ubuntu 9.10, kernel 2.6.31-16-generic
root (hd0,3)

第三行的/home/grub.exe需修改成刚解压出的grub.exe所在路径。

重启安装
重启，在操作系统选单里选择grub4dos，屏幕一闪再度进入操作系统选单，按c进入命令行grub>，依次输入以下指令：

grub>find --set-root /bootmgr
grub>chainloader /bootmgr
grub>boot

随即进入Windows 7安装引导界面，一路装下去即可。

恢复MBR
Windows安装完成后，多系统选单不见了，此时需要恢复MBR。我安装前在网上找到的几篇文章里有指明，可以在Windows下以如下指令恢复：
echo c:\"linux.lnx"=linux >> boot.ini
遗憾的是Windows 7里好像根本就没有boot.ini，试了一下，此法无效。

无奈只好用下了一份easyBCD，安装之后运行，添加LINUX启动项。C盘下会生成c:\nst\nst_linux.mbr文件，删除之，把此前备份的mbr.img复制到这个位置，重命名为nst_linux.mbr。

重启在多系统选单选择linux选项，即可看见原来的Ubuntu多系统选单。进入Ubuntu之后，再彻底还原MBR。
$ sudo dd if=/backup/mbr.img of=/dev/sda bs=446 count=1

** [[http://purpletulipdyc.blog.sohu.com/259698858.html][LaTeX 引用多个参考文献]]

如果在文章中出现连续引用多个参考文献的情况，希望显示的格式为 [1-9]
在文章的导言区加
\usepackage{cite}

在文章正文中需要引用参考文献的地方使用：
\cite{liu2012, wen13,wang2010VTC,shen2008ICC,Alex2007ICC}

** [[http://blog.csdn.net/hansoft/article/details/1502859][emacs encoding,font]]

*** encoding

如果emacs识别的编码是错误的，可以用C-x <RET> r CODING-SYSTEM来重新指定

emacs在内部使用它自己的coding system，在读入文件时把该文件使用的coding
system转换为内部使用的coding sytem，在写入文件时把内部使用的coding
system转换为该文件使用的coding system。

*** 字体

emacs用fontset指定字体。一个fontset对一组script分别指定字体。用create-fontset-from-fontset-spec来创建fontset：

#+BEGIN_EXAMPLE
    (create-fontset-from-fontset-spec  (concat   "-outline-Courier New-normal-r-*-*-18-*-*-*-c-*-fontset-gbk,"   "han:-outline-新宋体-normal-r-*-*-18-*-*-*-c-*-iso10646-1"))
#+END_EXAMPLE

fontset-gbk就是新创建的fontset的名字，当一个frame使用该fontset作为其font属性，该frame的default
font name就是用iso8859-1替换该fontset名字而得到的字体名。

han是一个script
name，为了向后兼容，也可以使用charset名，emacs通过变量charset-script-alist来映射charset到script

用set-fontset-font来增加或修改某个fontset，如：

(set-fontset-font "fontset-gbk" 'han
"-outline-新宋体-normal-r-/-/-18-/-/-/-c-/-iso10646-1")

最后用

(set-default-font "fontset-gbk")

来指定使用该fontset

**** tips

(frame-parameter <frame>
'font)得到指定<frame>的fontset名，若<frame>为nil则为当前选择的frame

*** language environment

对于像unicode这种国际化的编码，某些字符是多个script共用的(比如中、日、韩在unicode里就共用了一些字符)，如果判断这种字符的所属的script有误，就会出现不期望的结果：

在LC_CTYPE为非中文locale的情况下，使用UTF-8 language
environment，打开一个包含“笔记”两字的utf-8编码的文件，“笔”字将会显示为一个方框(在没有安装日文字体的情况下)。

这个“笔”字就被emacs判断为日语的字符，而我们没有日文字体，所以就显示为了一个方框。

你必须告诉把你的语言信息告诉emacs，这可以通过以下方式：

-  locale：设置LC_CTYPE=zh_CN就能解决上面的问题
-  emacs的language
   environment：如果你不想改变locale，可以改变emacs的language
   environment，事实上language
   environment就是为此目的设立的，改变locale的方法实际上也是间接改变language
   environment---当没有指定language
   enviroment时，emacs会根据当前的locale推测一个language
   environment，这在LC_CTYPE=zh_CN的locale下推测的结果是Chinese-GB，正是我们想要设置的。



language environment还给一些编码相关的变量设置默认值，比较重要的有：

-  优先编码列表
   当读入一个文件时，以该列表的顺序来识别文件的编码，用prefer-coding-system在该列表首插入一个编码
-  default-buffer-file-coding-system 新建文件的默认编码



C-h L来查看当前或其他language environment的信息，使用M-x
set-lanaguage-environment来修改。

C-h C查看指定的coding system，如果不指定参数则显示当前所有的coding
system设置，包括优先编码列表

**** troubles

在en_US.UTF-8下推测的language
environment是UTF-8，按理说这时相关的编码变量应该也被设置为UTF-8 language
environment设置的默认值，不过在我的环境下这些变量的值似乎和UTF-8
language environment无关，于是不得不在.emacs下明确设置一下：

#+BEGIN_EXAMPLE
      (if (equal current-language-environment "UTF-8")       (prefer-coding-system 'gb2312)    (prefer-coding-system 'Utf-8)       )      )   )   (add-hook 'set-language-environment-hook 'utf8gbk)   (set-lanaguage-environment 'UTF-8)
#+END_EXAMPLE

在UTF-8这个language
environment下，emacs并不能自动识别gbk编码的文件，因为其缺省设置的优先编码列表没有gbk，上面的lisp对UTF-8
language
environment做了定制，之所以又加了一次utf-8编码是因为希望在UTF-8这个language
environment下首选的编码是utf-8。

*** tips

用C-u C-x =(describe char)查看buffer中某个字符的信息

** [[https://blogs.cs.st-andrews.ac.uk/jfdm/2013/04/04/documenting-python-using-doxygen/][Documenting Python using Doxygen]]

April 4th, 2013
[[https://blogs.cs.st-andrews.ac.uk/jfdm/author/jfdm/][jfdm]]
[[#respond][Leave a comment]] [[#comments][Go to comments]]

On and off I have been developing a little Python module to provide
KP-ABE and CP-ABE functionality to developers. One important aspect is
that of documentation. Any decent project needs to provide both User and
Developer documentation. User documentation is outward facing and tells
users how to use the project, and Developer documentation is inward
facing and tells developers how the project is structured. Developer
documentation is also know as reference documentation. Interestingly,
user documentation can be further divided into two groups: User---for
when the user is just a ‘plain-dumb-user'; and Dev-User---when the
project produces something for use by other developers i.e. an library.
Often Dev-User documentation is just reference documentation. This post
is concerned with reference documentation.

For documenting API's and libraries different languages have different
tools:

-  Java has
   [[http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html][Javadoc]],
   and [[http://www.stack.nl/~dimitri/doxygen/][Doxygen]]
-  Python has [[http://epydoc.sourceforge.net/][epydoc]],
   [[https://pypi.python.org/pypi/pydoctor/0.4][pydoctor]],
   [[http://pydoc.org/][pydoc]], [[http://sphinx-doc.org/][sphinx]], and
   Doxygen
-  C has ...
   [[https://developer.gnome.org/gtk-doc-manual/stable/][gtk-doc]],...,
   and Doxygen
-  For design there is always plantuml.

For user documentation, which is not generally tied to a specific
programming language there are different formats:

-  LaTeX
-  Sphinx
-  ASCIIDOC
-  Markdown
-  reST
-  DocBook

For developer facing documentation, one can use a combination of the
above tools. Especially, when producing UML diagrams.

When I develop code I try to use doxygen everywhere I go, Doxygen is
cross language and provides a nice means to produce: End-User,
Developer-User, and Developer documentation in HTML, MAN Pages, LaTeX,
RTF, and XML; and across multiple languages. This is handed is you are
dropping down into C. Moreover, doxygen has built in support for LaTeX
formula within documentation. Furthermore, recent versions of doxygen
allow for the use of Markdown, and inclusion of Markdown formatted
files. It is essentially the SwissArmy Knife of documentation.

However, when developing in Python the preferred documentation tool is
sphinx, and relies on reST mark up in python ‘docstrings', and other
files to produce both reference documentation, and user documentation. I
find the approach messy, especially reST.

Helaas, Doxygen doesn't want to play nice, and prefers to have its
documentation place in special comment blocks above method definitions
i.e.

#+BEGIN_EXAMPLE
    ##
    # Print message to STDOUT
    # @param msg The message to be printed
    #
    def print_message(msg):
        print(msg);
#+END_EXAMPLE

and not in docstrings. Luckily there is the
[[http://code.foosel.org/doxypy][doxypy]] filter that allows one to tell
doxygen to look in docstrings. Thus, the above snippet can now become:

#+BEGIN_EXAMPLE
    def print_message(msg):
    """ Print message to STDOUT
    @param msg The message to be printed.
    """
        print(msg);
#+END_EXAMPLE

To get python and doxygen working nicely together, aside from the
standard settings, the following configuration settings are also
recommended/required:

#+BEGIN_EXAMPLE
    INPUT_FILTER = "python /path/to/doxypy.py"
    FILTER_SOURCE_FILES = YES
    HIDE_UNDOC_RELATIONS = NO
    OPTIMIZE_OUTPUT_JAVA = YES
    JAVADOC_AUTOBRIEF = YES
    MULTILINE_CPP_IS_BRIEF = YES
    DETAILS_AT_TOP = YES
    EXTRACT_ALL = YES
    EXTRACT_STATIC = YES
    SHOW_DIRECTORIES = YES
    SOURCE_BROWSER = YES
    ALPHABETICAL_INDEX = YES
    COLS_IN_ALPHA_INDEX = 8
    TOC_EXPAND = YES
    DISABLE_INDEX = YES
    GENERATE_TREEVIEW = YES
#+END_EXAMPLE

Of note, with the latest version of Doxygen you can reference a markdown
file as the mainpage.

For an example python project that uses Doxygen, see
[[https://github.com/jfdm/pyPEBEL][pyPEBEL]].

References:

-  [[http://engtech.wordpress.com/2007/03/20/automatic_documentation_python_doxygen/][Automatic
   Documentation of Python Code using Doxygen]]
-  [[http://www.joshuascotton.com/main/archives/64][Creating
   Documentation from Python Source Files with Doxygen and doxypy]]
-  [[http://notemagnet.blogspot.co.uk/2009/10/using-doxypy-for-python-code.html][Using
   doxypy for Python code documentation]]
-  [[http://stackoverflow.com/a/13442157][Use the Readme MD file as main
   page in Doxygen]]

** [[http://noalgo.info/790.html][C++11多线程]]

*** 多线程

C++11中使用多线程非常简单，直接使用头文件thread中的thread类型即可创建一个线程，具体例子如下所示，该程序是一个多线程版本的Hello
World程序。
 注意，这里使用了C++11中的lambda匿名函数，如果对此不是很了解，请先阅读
[[http://noalgo.info/787.html][C++11中的lambda表达式]]。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    using namespace std;

    int main()
    {
      //线程函数无参数
        thread t([](){ cout << "Hello World!" << endl; });
        t.join(); //t1线程调用t2.join()，表示t1要等到t2结束后才能继续执行
    }
#+END_EXAMPLE

这里涉及到多线程环境中父子线程的关系问题。一般操作系统中，当主线程执行完毕退出时，无论子线程是否执行完毕，所有的子线程都会终止。而当子线程先退出时，无论是执行完毕正常退出还是以其他方式异常终止，线程均会进入终止态（僵死态），此时线程分配的系统资源还没有释放，线程仍作为一个线程实体存在于操作系统中。如果我们就这样不管这个子线程，那么它占用的系统资源（如动态申请的内存、打开的文件等）将一直被占据，造成资源的浪费。此时可以通过定义以下两种父子线程关系进行解决：

-  可会和（joinable）：主线程必须显示等待子线程，只有子线程结束后，主线程才继续执行后面的操作。
-  相分离（detached）：父子线程分离，主线程无须等待子线程完成，子线程一旦进入终止态后系统立即销毁线程以及回收资源。

以上的线程函数是无参数的，C++中还可以方便地给线程函数传递参数.

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    using namespace std;

    int main()
    {
        //线程函数带参数，传值
        thread t([](string s){ cout << s << endl; }, "Hello World!");
        t.join();
    }
#+END_EXAMPLE

以上带参数的线程函数是按值传递的，如果需要按引用传递，则使用方法稍微有点不同。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    using namespace std;

    int main()
    {
        int i = 0;
        //线程函数带参数，传引用
        thread t([](int &x){ cout << x++ << endl; }, ref(i)); //需要使用std::ref
        t.join();
        cout << i << endl;
    }
#+END_EXAMPLE

thread头文件的this_thread命名空间定义了几个有用的函数：

-  get_id：返回当前的线程id。
-  yield：在处于等待状态时，可以让调度器先运行其他可用的线程。
-  sleep_for：阻塞当前线程，时间不少于参数指定的时间。
-  sleep_util：阻塞当前线程，时间为参数指定的时间。

简单的使用方法如下：

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    using namespace std;

    void f()
    {
        cout << "Thread ID: " << this_thread::get_id() << endl;
        this_thread::sleep_for(chrono::seconds(3));
    }

    int main()
    {
        thread t(f);
        t.join();
    }
#+END_EXAMPLE

*** 互斥锁

多线程编程一般避免不了同步的问题，C++11这里也提供了非常方便的方法来进行解决。标准中提供了一下四种互斥锁，分别是：

-  Mutex：基本的Mutex类，提供了核心函数lock()和unlock()。
-  Recursive_mutex：递归Mutex类，允许在同一个线程中对一个互斥量的多次请求。一般在项目模块分工中可以使用，这样即使其他人使用了同样的锁也不会导致死锁。
-  Timed_mutex：定时递归Mutex类，除了递归，还可以在某个时间段里或者某个时刻到达之间获取该互斥量。当一个线程在临界区操作的时间非常长，可以用定时锁指定时间。
-  Recursive_timed_mutex：定时递归Mutex类，综合timed_mutex和recuseive_mutex。

下面是一个使用基本锁的小例子，该程序会按顺序输出5对enter和leave，分别对应5个线程。如果注释掉函数f中mt的lock和unlock函数，则线程没有同步，此时先输出5句enter，然后5s后再输出5句leave。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    #include <mutex>
    #include <vector>
    using namespace std;

    mutex mt;

    void f()
    {
        mt.lock();
        cout << "Enter Critical Section" << endl;
        this_thread::sleep_for(chrono::seconds(5));
        cout << "Leave Critical Section" << endl;
        mt.unlock();
    }

    int main()
    {
        vector<thread> v(5);
        for (auto &i : v) i = thread(f);
        for (auto &i : v) i.join();
    }
#+END_EXAMPLE

*** 条件变量

条件变量condition_variable也可以进行线程之间的通信，当一个线程要等待另一个线程完成某个操作时，可以使用条件变量进行实现。条件变量可以将一个或多个线程进入阻塞状态，直到收到另外一个线程的通知，或者超时才能退出阻塞状态。

一个线程等待某个条件满足，其首先获得一个unique_lock锁。该锁将会传递给wait()方法，然后wait()方法会释放互斥量并将该线程暂停，直到条件变量得到相应的信号。当接受到信号，线程被唤醒后，该锁就又被重新获得了。

另外一个线程发送信号使得条件满足。其通过调用notify_one()来发送通知，会将处于阻塞状态的等待该条件获得信号的线程中的某一个线程（任意一个线程）恢复执行；还可以通过调用notify_all()将等待该条件的所以线程唤醒。

下面是一个使用条件变量的简单例子。该程序中f1等待某个条件，该条件在f2输出并且睡眠2s后才得到满足，之后f1才能够进行输出。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <mutex>
    #include <thread>
    #include <condition_variable>
    using namespace std;

    mutex mt;
    condition_variable cv;

    void f1()
    {
        unique_lock<mutex> lock(mt);
        cv.wait(lock);
        cout << "F1 says Hi" << endl;
    }

    void f2()
    {
        cout << "F2 says Hi" << endl;
        this_thread::sleep_for(chrono::seconds(2));
        cv.notify_all();
    }

    int main()
    {
        thread t1(f1);
        this_thread::sleep_for(chrono::seconds(2));
        thread t2(f2);
        t1.join(), t2.join();
    }
#+END_EXAMPLE

*** Future

C++11中的future是标准库提供的一种用于获取异步操作的结果的机制，其可以调用一个函数，然后转而做其他的事情，让函数自己在一边执行，当需要的时候再回过头来获取该函数计算的结果。另外，其还可以延迟异步操作中异常(Exception)的抛出。
 下面是一个简单的例子。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <future>
    using namespace std;

    int main()
    {
        future<int> f = async([]()->int { return 42; });
        this_thread::sleep_for(chrono::seconds(2));
        cout << "The answer to life the universe and everything is: " << f.get() << endl;
    }
#+END_EXAMPLE

** [[http://blog.csdn.net/xiaoyangger/article/details/7879579][USBASP vs USBISP]]

1. USBISP与USBASP分别是2个德国人的设计,在硬件上基本兼容,但内核软件有不同,尽管低层USB都采用开源代码,但上层支持协议不同.USBISP是STK500v2 conpatible (direct from AVR-Studio useable) 的,直接在AVR STUDIO中支持和使用.而USBASP需要使用专用的编程软件.另外ASPISP的更新比USBASP快.

2、这两者硬件电路相同，固件程序不同；

3、两者使用的烧录软件不同，USBISP是模拟STK500下载线，所以可以使用AVR Stduio开发环境来下载烧录程序；而USBASP不能用AVR Stduio，但是现在网上很多支持USBASP的软件，比如PROGISP,AVR flater等。

4.USBISP与并口ISP(STK200/STK300)的比较
并口ISP(STK200/STK300)下载线需要PC带真正的LPT口,在ICC、CVAVR、BASCOM-AVR中可以直接使用。
USBISP使用USB口，只能在AVR STUDIO中使用（其它支持的不稳定）
USBISP速度稍为慢一点（M8模拟USB）

** [[http://blog.csdn.net/yimiyangguang1314/article/details/6449589][lsusb]]

插入usb鼠标后执行lsusb的输出内容如下:
-----------------------------------------
Bus 005 Device 001: ID 0000:0000
Bus 001 Device 001: ID 0000:0000
Bus 004 Device 001: ID 0000:0000
Bus 003 Device 001: ID 0000:0000
Bus 002 Device 006: ID 15d9:0a37
Bus 002 Device 001: ID 0000:0000

内容解读:
-----------------------------------------
Bus 005
    表示第五个usb主控制器(机器上总共有5个usb主控制器 -- 可以通过命令lspci | grep USB查看)

Device 006
    表示系统给usb鼠标分配的设备号(devnum)，同时也可以看到该鼠标是插入到了第二个usb主控制器
    006        usb_device.devnum
    /sys/devices/pci0000:00/0000:00:1d.1/usb2/2-2/devnum

ID 15d9:0a37
    表示usb设备的ID(这个ID由芯片制造商设置，可以唯一表示该设备)
    15d9    usb_device_descriptor.idVendor
    0a37    usb_device_descriptor.idProduct
    /sys/devices/pci0000:00/0000:00:1d.1/usb2/2-2/idVendor

Bus 002 Device 006: ID 15d9:0a37
Bus 002 Device 001: ID 0000:0000
    表示002号usb主控制器上接入了两个设备:
    一个是usb根Hub -- 001
    一个是usb鼠标   -- 006





说明：

lsusb命令是一个学习USB驱动开发，认识USB设备的助手，推荐大家使用，如果您的开发板中或者产品中没有lsusb命令可以自己移植一个，放到文件系统里面.

** [[http://python.jobbole.com/81129/][详解Python中的下划线]]

2015/03/13 · [[http://python.jobbole.com/category/basic/][基础知识]] ·
[[http://python.jobbole.com/tag/python/][Python]],
[[http://python.jobbole.com/tag/%e4%b8%8b%e5%88%92%e7%ba%bf/][下划线]]

分享到： [[http://www.jiathis.com/share?uid=1745061][]]

本文由 [[http://python.jobbole.com][伯乐在线]] -
[[http://www.jobbole.com/members/pyper][PyPer]]
翻译，[[http://www.jobbole.com/members/xianhu][xianhu]]
校稿。未经许可，禁止转载！
英文出处：[[http://shahriar.svbtle.com/underscores-in-python][shahriar.svbtle.com]]。欢迎加入[[http://group.jobbole.com/category/feedback/trans-team/][翻译组]]。

本文将讨论Python中下划线（_）字符的使用方法。我们将会看到，正如Python中的很多事情，下划线的不同用法大多数（并非所有）只是常用惯例而已。

*** 单下划线（_）

通常情况下，会在以下3种场景中使用：

1、*在解释器中*：在这种情况下，“_”代表交互式解释器会话中上一条执行的语句的结果。这种用法首先被标准CPython解释器采用，然后其他类型的解释器也先后采用。

Python

>>> _ Traceback (most recent call last): File "<stdin>", line 1, in
<module> NameError: name '_' is not defined >>> 42 >>> _ 42 >>>
'alright!' if _ else ':(' 'alright!' >>> _ 'alright!'

| 1    | >>> _ Traceback (most recent call last):   |
| 2    | File "<stdin>", line 1, in <module>         |
| 3    | NameError: name '_' is not defined         |
| 4    | >>> 42                                      |
| 5    | >>> _                                      |
| 6    | 42                                          |
| 7    | >>> 'alright!' if _ else ':('              |
| 8    | 'alright!'                                  |
| 9    | >>> _                                      |
| 10   | 'alright!'                                  |

2、*作为一个名称*：这与上面一点稍微有些联系，此时“_”作为临时性的名称使用。这样，当其他人阅读你的代码时将会知道，你分配了一个特定的名称，但是并不会在后面再次用到该名称。例如，下面的例子中，你可能对循环计数中的实际值并不感兴趣，此时就可以使用“_”。

Python

n = 42 for _ in range(n): do_something()

| 1   | n = 42                |
| 2   | for _ in range(n):   |
| 3   |  do_something()   |

3、*国际化*：也许你也曾看到”_“会被作为一个函数来使用。这种情况下，它通常用于实现国际化和本地化字符串之间翻译查找的函数名称，这似乎源自并遵循相应的C约定。例如，在[[https://docs.djangoproject.com/en/dev/topics/i18n/translation/][Django文档“转换”章节]]中，你将能看到如下代码：

Python

from django.utils.translation import ugettext as _ from django.http
import HttpResponse def my_view(request): output = _("Welcome to my
site.") return HttpResponse(output)

| 1   | from django.utils.translation import ugettext as _   |
| 2   | from django.http import HttpResponse                  |
| 3   | def my_view(request):                                |
| 4   | output = _("Welcome to my site.")                    |
| 5   | return HttpResponse(output)                           |

可以发现，场景二和场景三中的使用方法可能会相互冲突，所以我们需要避免在使用“_”作为国际化查找转换功能的代码块中同时使用“_”作为临时名称。

*** 名称前的单下划线（如：_shahriar）

程序员使用名称前的单下划线，用于指定该名称属性为“私有”。这有点类似于惯例，为了使其他人（或你自己）使用这些代码时将会知道以“_”开头的名称只供内部使用。正如Python文档中所述：

以下划线“_”为前缀的名称（如_spam）应该被视为API中非公开的部分（不管是函数、方法还是数据成员）。此时，应该将它们看作是一种实现细节，在修改它们时无需对外部通知。

正如上面所说，这确实类似一种惯例，因为它对解释器来说确实有一定的意义，如果你写了代码“from
<模块/包名> import
*”，那么以“_”开头的名称都不会被导入，除非模块或包中的“__all__”列表显式地包含了它们。了解更多请查看“[[http://shahriar.svbtle.com/importing-star-in-python][Importing* in Python]]”。

*** 名称前的双下划线（如：__shahriar）

名称（具体为一个方法名）前双下划线（__）的用法并不是一种惯例，对解释器来说它有特定的意义。Python中的这种用法是为了避免与子类定义的名称冲突。Python文档指出，“__spam”这种形式（至少两个前导下划线，最多一个后续下划线）的任何标识符将会被“_classname__spam”这种形式原文取代，在这里“classname”是去掉前导下划线的当前类名。例如下面的例子：

Python

>>> class A(object): ... def _internal_use(self): ... pass ... def
__method_name(self): ... pass ... >>> dir(A())
['_A__method_name', ..., '_internal_use']

| 1   | >>> class A(object):                              |
| 2   | ... def _internal_use(self):                    |
| 3   | ... pass                                          |
| 4   | ... def __method_name(self):                   |
| 5   | ... pass                                          |
| 6   | ...                                               |
| 7   | >>> dir(A())                                      |
| 8   | ['_A__method_name', ..., '_internal_use']   |

正如所预料的，“_internal_use”并未改变，而“__method_name”却被变成了“_ClassName__method_name”。此时，如果你创建A的一个子类B，那么你将不能轻易地覆写A中的方法“__method_name”。

Python

>>> class B(A): ... def __method_name(self): ... pass ... >>>
dir(B()) ['_A__method_name', '_B__method_name', ...,
'_internal_use']

| 1   | >>> class B(A):                                                          |
| 2   | ... def __method_name(self):                                          |
| 3   | ... pass                                                                 |
| 4   | ...                                                                      |
| 5   | >>> dir(B())                                                             |
| 6   | ['_A__method_name', '_B__method_name', ..., '_internal_use']   |

这里的功能几乎和Java中的final方法和C++类中标准方法（非虚方法）一样。

*** 名称前后的双下划线（如：__init__）

这种用法表示Python中特殊的方法名。其实，这只是一种惯例，对Python系统来说，这将确保不会与用户自定义的名称冲突。通常，你将会覆写这些方法，并在里面实现你所需要的功能，以便Python调用它们。例如，当定义一个类时，你经常会覆写“__init__”方法。

虽然你也可以编写自己的特殊方法名，但不要这样做。

Python

>>> class C(object): ... def __mine__(self): ... pass ... >>> dir(C)
... [..., '__mine__', ...]

| 1   | >>> class C(object):             |
| 2   | ... def __mine__(self):      |
| 3   | ... pass                         |
| 4   | ...                              |
| 5   | >>> dir(C)                       |
| 6   | ... [..., '__mine__', ...]   |

其实，很容易摆脱这种类型的命名，而只让Python内部定义的特殊名称遵循这种约定。

** [[http://www.cnblogs.com/dartagnan/archive/2013/04/25/3042417.html][termios属性设置 tcsetattr设置]]

终端I/O有两种不同的工作方式：

1. 规范方式输入处理。在这种方式中，终端输入以行为单位进行处理。对于每个读要求，终端驱动程序最多返回一行。
2. 非规范方式输入处理。输入字符不以行为单位进行装配。

如果不作特殊处理，则默认方式是规范方式。

V7和BSD类的终端驱动程序支持三种终端输入方式：

1. 精细加工方式(输入装配成行，并对特殊字符进行处理)；
2. 原始方式(输入不装配成行，也不对特殊字符进行处理)；
3. cbreak方式(输入不装配成行，但对某些特殊字符进行处理)。



*** 2.termios结构

*[c-sharp]* [[http://blog.csdn.net/jibcy/article/details/7351669][view
plain]][[http://blog.csdn.net/jibcy/article/details/7351669][copy]]



1. struct termios {
2.  tcflag_t c_iflag; /* Input modes */
3.  tcflag_t c_oflag; /* Output modes */
4.  tcflag_t c_cflag; /* Control modes */
5.  tcflag_t c_lflag; /* Local modes */
6.  cc_t c_cc[NCCS]; /* Control characters */
7. };

*[c-sharp]* [[http://blog.csdn.net/jibcy/article/details/7351669][view
plain]][[http://blog.csdn.net/jibcy/article/details/7351669][copy]]



1. struct termios {
2.  tcflag_t c_iflag; /* Input modes */
3.  tcflag_t c_oflag; /* Output modes */
4.  tcflag_t c_cflag; /* Control modes */
5.  tcflag_t c_lflag; /* Local modes */
6.  cc_t c_cc[NCCS]; /* Control characters */
7. };

各个字段的选项如下(不是所有UNIX系统都支持)：

******* c_iflag：

-  BRKINT：接到BREAK时产生SIGINT；
-  ICRNL：将输入的CR转换为NL；
-  IGNBRK：忽略BREAK条件；
-  IGNCR：忽略CR；
-  IGNPAR：忽略奇偶错字符；
-  IMAXBEL：在输入队列空时振铃；
-  INLCR：将输入的NL转换为CR；
-  INPCK：打开输入奇偶校验；
-  ISTRIP：剥除输入字符的第8位；
-  IUCLC：将输入的大写字符转换成小写字符(仅SVR4)；
-  IXANY：使任一字符都重新起动输出；
-  IXOFF：使起动/停止输入控制流起作用；
-  IXON：使起动/停止输出控制流起作用；
-  PARMRK：标记奇偶错；

******* c_oflag：

-  BSDLY：退格延迟屏蔽(仅SVR4)；
-  CRDLY：CR延迟屏蔽(仅SVR4)；
-  FFDLY：换页延迟屏蔽(仅SVR4)；
-  NLDLY：NL延迟屏蔽(仅SVR4)；
-  OCRNL：将输出的CR转换为NL(仅SVR4)；
-  OFDEL：填充符为DEL，否则为NUL(仅SVR4)；
-  OFILL：对于延迟使用填充符(仅SVR4)；
-  OLCUC：将输出的小写字符转换为大写字符(仅SVR4)；
-  ONLCR：将NL转换为CR-NL；
-  ONLRET：NL执行CR功能(仅SVR4)；
-  ONOCR：在0列不输出CR(仅SVR4)；
-  ONOEOT：在输出中删除EOT字符(仅4.3+BSD)；
-  OPOST：执行输出处理；
-  OXTABS：将制表符扩充为空格(仅4.3+BSD)；
-  TABDLY：水平制表符延迟屏蔽(仅SVR4)；
-  VTDLY：垂直制表符延迟屏蔽(仅SVR4)；

******* c_cflag：

-  CCTS_OFLOW：输出的CTS流控制(仅4.3+BSD)；
-  CIGNORE：忽略控制标志(仅4.3+BSD)；
-  CLOCAL：忽略解制解调器状态行；
-  CREAD：启用接收装置；
-  CRTS_IFLOW：输入的RTS流控制(仅4.3+BSD)；
-  CSIZE：字符大小屏蔽；
-  CSTOPB：送两个停止位，否则为1位；
-  HUPCL：最后关闭时断开；
-  MDMBUF：经载波的流控输出(仅4.3+BSD)；
-  PARENB：进行奇偶校；
-  PARODD：奇校，否则为偶校；

******* c_lflag：

-  ALTWERASE：使用替换WERASE算法(仅4.3+BSD)；
-  ECHO：进行回送；
-  ECHOCTL：回送控制字符为\^(char)；
-  ECHOE：可见擦除符；
-  ECHOK：回送kill符；
-  ECHOKE：kill的可见擦除；
-  ECHONL：回送NL；
-  ECHOPRT：硬拷贝的可见擦除方式；
-  FLUSHO：刷清输出；
-  ICANON：规范输入；
-  IEXTEN：使扩充的输入字符处理起作用；
-  ISIG：使终端产生的信号起作用；
-  NOFLSH：在中断或退出键后不刷清；
-  NOKERNINFO：STATUS不使内核输出(仅4.3+BSD)；
-  PENDIN：重新打印；
-  TOSTOP：对于后台输出发送SIGTTOU；
-  XCASE：规范大/小写表示(仅SVR4)；

所有列出的选择标志(除屏蔽标志外)都用一或多位表示，而屏蔽标志则定义多位。屏蔽标志有一个定义名，每个值也有一个名字。例如，为了设置字符长度，首先用字符长度屏蔽标志CSIZE将表示字符长度的位清0，然后设置下列值之一：CS5、CS6、CS7或CS8。由SVR4支持的6个延迟值也有屏蔽标志：BSDLY、CRDLY、FFDLY、NLDLY、TABDLY和VTDLY。

各个标志的含义如下：

-  ALTWERASE：(c_lflag,
   4.3+BSD)此标志设置时，若输入了WERASE字符，则使用一个替换的字擦除算法。它不是向后移动到前一个白空字符为止，而是向后移动到第一个非字母、数字符为止。
-  BRKINT：(c_iflag,
   POSIX.1)若此标志设置，而IGNBRK未设置，则在接到BREAK时，输入、输出队列被刷清，并产生一个SIGINT信号。如果此终端设备是一个控制终端，则将此信号送给前台进程组各进程。如果IGNBRK和BRKINT都没有设置，但是设置了PARMRK，则BREAK被读作为三个字节序列/377，/0和/0，如果PARMRK也没有设置，则BREAK被读作为单个字符/0。
-  BSDLY：(c_oflag, SVR4)退格延迟屏蔽，此屏蔽的值是BS0或BS1。
-  CCTS_OFLOW：(c_cflag, 4.3+BSD)输出的CTS流控制。
-  CIGNORE：(c_cflag, 4.3+BSD)忽略控制标志。
-  CLOCAL：(c_cflag,
   POSIX.1)如若设置，则忽略调制解调器状态线。这通常意味着该设备是本地连接的。若此标志未设置，则打开一个终端设备常常会阻塞到调制解调器回应。
-  CRDLY：(c_oflag, SVR4)回车延迟屏蔽。此屏蔽的值是CR0、CR1、CR2和CR3。
-  CREAD：(c_cflag, POSIX.1)如若设置，则接收装置被启用，可以接收字符。
-  CRTS_IFLOW：(c_cflag, 4.3+BSD)输入的RTS流控制。
-  CSIZE：(c_cflag,
   POSIX.1)此字段是一个屏蔽标志，它指明发送和接收的每个字节的位数。此长度不包括可能有的奇偶校验位。由此屏蔽定义的字段值是CS5、CS6、CS7和CS8，分别表示每个字节包含5、6、7和8位。
-  CSTOPB：(c_cflag,
   POSIX.1)如若设置，则使用两位作为停止位，否则只使用一位作为停止位。
-  ECHO：(c_lflag,
   POSIX.1)如若设置，则将输入字符回送到终端设备。在规范方式和非规范方式下都可以回送字符。
-  ECHOCTL：(c_lflag, SVR4和4.3+BSD)如若设置并且ECHO也设置，则除ASCII
   TAB、ASCII
   NL、START和STOP字符外，其他ASCII控制符(ASCII字符集中的0～037)都被回送为\^X，其中，X是相应控制字符代码值加0100所构成的字符。这就意味着ASCII
   Ctrl-A字符(01)被回送为\^A。ASCII
   DELETE字符(0177)则回送为\^?。如若此标志未设置，则ASCII控制字符按其原样回送。如同ECHO标志，在规范方式和非规范方式下此标志对控制字符回送都起作用。应当了解的是：某些系统回送EOF字符产生的作用有所不同，其原因是EOF的典型值是Ctrl-D，而这是ASCII
   EOT字符，它可能使某些终端挂断。
-  ECHOE：(c_lflag,
   POSIX.1)如若设置并且ICANON也设置，则ERASE字符从显示中擦除当前行中的最后一个字符。这通常是在终端驱动程序中写三个字符序列：退格，空格，退格实现的。如若支持WERASE字符，则ECHOE用一个或若干个上述三字符序列擦除前一个字。如若支持ECHOPRT标志，则在这里所说明的ECHOE动作假定ECHOPRT标志没有设置。
-  ECHOK：(c_lflag,
   POSIX.1)如若设置并且ICANON也设置，则KILL字符从显示中擦除当前行，或者输出NL字符(用以强调已擦除整个行)。如若支持ECHOKE标志，则这里的说明假定ECHOKE标志没有设置。
-  ECHOKE：(c_lflag,
   SVR4和4.3+BSD)如若设置并且ICANON也设置，则回送KILL字符的方式是擦去行中的每一个字符。擦除每个字符的方法则由ECHOE和ECHOPRT标志选择。
-  ECHONL：(c_lflag,
   POSIX.1)如若设置并且ICANON也设置，即使没有设置ECHO也回送NL字符。
-  ECHOPRT：(c_lflag,
   SVR4和4.3+BSD)如若设置并且ICANON和ECHO也都设置，则ERASE字符(以及WERASE字符，若受到支持)使所有正被擦除的字符按它们被擦除的方式打印。在硬拷贝终端上这常常是有用的，这样可以确切地看到哪些字符正被擦去。
-  FFDLY：(c_oflag, SVR4)换页延迟屏蔽。此屏蔽标志值是FF0或FF1。
-  FLUSHO：(c_lflag,
   SVR4和4.3+BSD)如若设置，则刷清输出。当键入DISCARD字符时设置此标志，当键入另一个DISCARD字符时，此标志被清除。设置或清除此终端标志也可设置或清除此条件。
-  HUPCL：(c_cflag,
   POSIX.1)如若设置，则当最后一个进程关闭此设备时，调制解调器控制线降至低电平(也就是调制解调器的连接断开)。
-  ICANON：(c_lflag,
   POSIX.1)如若设置，则按规范方式工作。这使下列字符起作用：EOF、EOL、EOL2、ERASE、KILL、REPRINT、STATUS和WERASE。输入字符被装配成行。如果不以规范方式工作，则读请求直接从输入队列取字符。在至少接到MIN个字节或已超过TIME值之前，read将不返回。
-  ICRNL：(c_iflag,
   POSIX.1)如若设置并且IGNCR未设置，即将接收到的CR字符转换成一个NL字符。
-  IEXTEN：(c_lflag,
   POSIX.1)如若设置，则识别并处理扩充的、实现定义的特殊字符。
-  IGNBRK：(c_iflag,
   POSIX.1)在设置时，忽略输入中的BREAK条件。关于BREAK条件是产生信号还是被读作为数据，请见BRKINT。
-  IGNCR：(c_iflag,
   POSIX.1)如若设置，忽略接收到的CR字符。若此标志未设置，而设置了ICRNL标志则将接收到的CR字符转换成一个NL字符。
-  IGNPAR：(c_iflag,
   POSIX.1)在设置时，忽略带有结构错误(非BREAK)或奇偶错的输入字节。
-  IMAXBEL：(c_iflag, SVR4和4.3+BSD)当输入队列满时响铃。
-  INLCR：(c_iflag, POSIX.1)如若设置，则接收到的NL字符转换成CR字符。
-  INPCK：(c_iflag,
   POSIX.1)当设置时，使输入奇偶校验起作用。如若未设置INPCK，则使输入奇偶校验不起作用。奇偶“产生和检测”和“输入奇偶性检验”是不同的两件事。奇偶位的产生和检测是由PARENB标志控制的。设置该标志后使串行界面的设备驱动程序对输出字符产生奇偶位，对输入字符则验证其奇偶性。标志PARODD决定该奇偶性应当是奇还是偶。如果一个其奇偶性为错的字符已经来到，则检查INPCK标志的状态。若此标志已设置，则检查IGNPAR标志(以决定是否应忽略带奇偶错的输入字节)，若不应忽略此输入字节，则检查PARMRK标志以决定向读进程应传送那种字符。
-  ISIG：(c_lflag,
   POSIX.1)如若设置，则判别输入字符是否是要产生终端信号的特殊字符(INTR，QUIT，SUSP和DSUSP)，若是，则产生相应信号。
-  ISTRIP：(c_iflag,
   POSIX.1)当设置时，有效输入字节被剥离为7位。当此标志未设置时，则保留全部8位。
-  IUCLC：(c_iflag, SVR4)将输入的大写字符映射为小写字符。
-  IXANY：(c_iflag, SVR4和4.3+BSD)使任一字符都能重新起动输出。
-  IXOFF：(c_iflag,
   POSIX.1)如若设置，则使起动-停止输入控制起作用。当终端驱动程序发现输入队列将要填满时，输出一个STOP字符。此字符应当由发送数据的设备识别，并使该设备暂停。此后，当已对输入队列中的字符进行了处理后，该终端驱动程序将输出一个START字符，使该设备恢复发送数据。
-  IXON：(c_iflag,
   POSIX.1)如若设置，则使起动-停止输出控制起作用。当终端驱动程序接收到一个STOP字符时，输出暂停。在输出暂停时，下一个START字符恢复输出。如若未设置此标志，则START和STOP字符由进程读作为一般字符。
-  MDMBUF：(c_cflag, 4.3+BSD)按照调制解调器的载波标志进行输出流控制。
-  NLDLY：(c_oflag, SVR4)新行延迟屏蔽。此屏蔽的值是NL0和NL1。
-  NOFLSH：(c_lflag,
   POSIX.1)按系统默认，当终端驱动程序产生SIGINT和SIGQUIT信号时，输入、出队列都被刷新。另外，当它产生SIGSUSP信号时，输入队列被刷新。如若设置了NOFLSH标志，则在这些信号产生时，不对输入、出队列进行刷新。
-  NOKERNINFO：(c_lflag,
   4.3+BSD)当设置时，此标志阻止STATUS字符使前台进程组的状态信息显示在终端上。但是不论本标志是否设置，STATUS字符使SIGINFO信号送至前台进程组中的所有进程。
-  OCRNL：(c_oflag, SVR4)如若设置，将输出的CR字符映照为NL。
-  OFDEL：(c_oflag, SVR4)如若设置，则输出填充字符是ASCII
   DEL，否则它是ASCII NUL，见OFILL标志。
-  OFILL：(c_oflag, SVR4)如若设置，则为实现延迟，发送填充字符(ASCII
   DEL或ASCII
   NUL，见OFDEL标志)，而不使用时间延迟。见6个延迟屏蔽：BSDLY，CRDLY，FFDLY，NLDLY，TABDLY以及VTDLY。
-  OLCUC：(c_oflag, SVR4)如若设置，将小写字符映射为大写。
-  ONLCR：(c_oflag, SVR4和4.3+BSD)如若设置，将输出的NL字符映照为CR-NL。
-  ONLRET：(c_oflag, SVR4)如若设置，则输出的NL字符将执行回车功能。
-  ONOCR：(c_oflag, SVR4)如若设置，则在0列不输出CR。
-  ONOEOT：(c_oflag,
   4.3+BSD)如若设置，则在输出中删除EOT字符(\^D)。在将Ctrl-D解释为挂断的终端上这可能是需要的。
-  OPOST：(c_oflag, POSIX.1)如若设置，则进行实现定义的输出处理。
-  OXTABS：(c_oflag,
   4.3+BSD)如若设置，制表符在输出中被扩展为空格。这与将水平制表延迟(TABDLY)设置为XTABS或TAB3产生同样效果。
-  PARENB：(c_cflag,
   POSIX.1)如若设置，则对输出字符产生奇偶位，对输入字符则执行奇偶性检验。若PARODD已设置，则奇偶校验是奇校验，否则是偶校验。也见INPCK、IGNPAR和PARMRK标志部分。
-  PARMRK：(c_iflag,
   POSIX.1)，当设置时，并且IGNPAR未设置，则结构性错(非BREAK)和奇偶错的字节由进程读作为三个字符序列/377,
   /0和X，其中X是接收到的具有错误的字节。如若ISTRIP未设置，则一个有效的/377被传送给进程时为/377，/377。如若IGNPAR和PARMRK都未设置，则结构性错和奇偶错的字节都被读作为一个字符/0。
-  PARODD：(c_cflag,
   POSIX.1)如若设置，则输出和输入字符的奇偶性都是奇，否则为偶。注意，PARENB标志控制奇偶性的产生和检测。
-  PENDIN：(c_lflag,
   SVR4和4.3+BSD)如若设置，则在下一个字符输入时，尚未读的任何输入都由系统重新打印。这一动作与键入REPRINT字符时的作用相类似。
-  TABDLY：(c_oflag,
   SVR4)水平制表延迟屏蔽。此屏蔽的值是TAB0、TAB1、TAB2或TAB3。XTABS的值等于TAB3。此值使系统将制表符扩展成空格。系统假定制表符所扩展的空格数到屏幕上最近一个8的倍数处为止。不能更改此假定。
-  TOSTOP：(c_lflag,
   POSIX.1)如若设置，并且该实现支持作业控制，则将信号SIGTTOU送到试图与控制终端的一个后台进程的进程组。按默认，此信号暂停该进程组中所有进程。如果写控制终端的进程忽略或阻塞此信号，则终端驱动程序不产生此信号。
-  VTDLY：(c_oflag, SVR4)垂直制表延迟屏蔽。此屏蔽的值是VT0或VT1。
-  XCASE：(c_lflag,
   SVR4)如若设置，并且ICANON也设置，则认为终端是大写终端，所以输入都变换为小写。为了输入一个大写字符，在其前加一个/。与之类似，输出一个大写字符也在其前加一个/(这一标志已经过时，现在几乎所有终端都支持大、小写字符)。



*** 3.终端特殊输入字符

POSIX.1定义了11个在输入时作特殊处理的字符。SVR4另外加了6个特殊字符，4.3+BSD则加了7个。见下表：

字符

说明

c_cc下标

起作用，由：

典型值

POSIX.1

SVR4

4.3+BSD

字段

标志

扩充

CR

回车

不能更改

c_lflag

ICANON

/r

YES





DISCARD

擦除输出

VDISCARD

c_lflag

IEXTEN

\^O



YES

YES

DSUSP

延迟挂起(SIGTSTP)

VDUSP

c_lflag

ISIG

\^Y



YES

YES

EOF

文件结束

VEOF

c_lflag

ICANON

\^D

YES





EOL

行结束

VEOL

c_lflag

ICANON



YES





EOL2

替换的行结束

VEOL2

c_lflag

ICANON





YES

YES

ERASE

擦除字符

VERASE

c_lflag

ICANON

\^H

YES





INTR

中断信号(SIGINT)

VINTR

c_lflag

ISIG

\^?, \^C

YES





KILL

擦行

VKILL

c_lflag

ICANON

\^U

YES





LNEXT

下一个字列字符

VLNEXT

c_lflag

IEXTEN

\^V



YES

YES

NL

新行

不能更改

c_lflag

ICANON

/n

YES





QUIT

退出信号(SIGQUIT)

VQUIT

c_lflag

ISIG

\^/

YES





REPRINT

再打印全部输入

VREPRINT

c_lflag

ICANON

\^R



YES

YES

START

恢复输出

VSTART

c_lflag

IXON/IXOFF

\^Q

YES





STATUS

状态要求

VSTATUS

c_lflag

ICANON

\^T





YES

STOP

停止输出

VSTOP

c_lflag

IXON/IXOFF

\^S

YES





SUSP

挂起信号(SIGTSTP)

VSUSP

c_lflag

ISIG

\^Z

YES





WERASE

擦除字

VWERASE

c_lflag

ICANON

\^W



YES

YES

我们称这些字符为特殊输入字符，但是其中有两个字符，STOP和START(Ctrl-S和Ctrl-Q)在输出时也对它们进行特殊处理。这些字符中的大多数在被终端驱动程序识别并进行特殊处理后都被丢弃，并不将它们传送给执行读终端操作的进程。例外的字符是新行符(NL，EOL，EOL2)和回车符(CR)。详细说明如下：

-  CR：POSIX.1的回车符，不能更改此字符。以规范方式进行输入时识别此字符。当设置了ICANON(规范方式)和ICRNL(将CR映照为NL)以及没有设置IGNCR(忽略CR)时，将CR转换成NL，并产生与NL符相同的作用。此字符返回给读进程(多半是在转换成NL后)。
-  DISCARD：SVR4和4.3+BSD的删除符。在扩充方式下(IEXTEN)，在输入中识别此字符。在输入另一个删除符之前或删除条件被清除之前(见FLUSHO选择项)此字符使后续输出都被删除。在处理后此字符即被删除，不送向读进程。
-  DSUSP：SVR4和4.3+BSD的延迟-挂起作业控制字符。在扩充方式下，若作业控制被挂起并且ISIG标志被设置，则在输入中识别此字符。与SUSP字符的相同处是：延迟-挂起字符产生SIGTSTP信号，它被送至前台进程组中的所有进程。但是并不是键入此字符时，而是在一个进程读控制终端时，此延迟-挂起字符才送向进程组。在处理后，此字符即被删除，不送向读进程。
-  EOF：POSIX.1的文件结束符。以规范方式进行输入时识别此字符。当键入此字符时，等待被读的所有字节都立即传送给读进程。如果没有字节等待读，则返回0。在行首输入一个EOF符是向程序指示文件结束的正常方式。在处理后，此字符即被删除，不送向读进程。
-  EOL：POSIX.1附加的行定界符，与NL作用相同。以规范方式进行输入时识别此字符。通常不使用此字符。此字符返回给读进程。
-  EOL2：SVR4和4.3+BSD的附加行定界符，与NL作用相同。以规范方式输入时识别此字符。通常不使用此字符，此字符返回给读进程。
-  ERASE：POSIX.1的擦除字符(退格)。以规范方式输入时识别此字符。它擦除行中的前一个字符，但不会超越行首字符擦除上一行中的字符。在处理后此字符即被擦除，不送向读进程。
-  INTR：POSIX.1的中断字符。若设置了ISIG标志，则在输入中识别此字符。它产生SIGINT信号，该信号被送至前台进程组中的所有进程。在处理后，此字符即被删除，不送向读进程。
-  KILL：POSIX.1的kill(杀死)字符。以规范方式输入时识别此字符。它擦除整个1行。在处理后，此字符即被删除，不送向读进程。
-  LNEXT：SVR4和4.3+BSD的“字面上-下一个”字符。以规范方式输入时识别此字符，它使下一个字符的任何特殊含意都被忽略。这对本节提及的所有特殊字符都起作用。使用这一字符可向程序键入任何字符。在处理后，LNEXT字符即被删除，但输入的下一个字符则被传送给读进程。
-  NL：POSIX.1的新行字符，它也被称为行定界符。不能更改此字符。以规范方式输入时识别此字符。此字符返回给读进程。
-  QUIT：POSIX.1的退出字符。若设置了ISIG标志，则在输入中识别此字符。它产生SIGQUIT信号，该信号又被送至前台进程组中的所有进程。在处理后，此字符即被删除，不送向读进程。
-  REPRINT：SVR4和4.3+BSD的再打印字符。以扩充规范方式(设置了IEXTEN和ICANON标志)进行输入时识别此字符。它使所有未读的输入被输出(再回送)。在处理后，此字符即被删除，不送向读进程。
-  START：POSIX.1的起动字符。若设置了IXON标志则在输入中识别此字符；若设置IXOFF标志，则作为输出自动产生此字符。在IXON已设置时接收到的START字符使停止的输出(由以前输入的STOP字符造成)重新起动。在此情形下，在处理后，此字符即被删除，不送向读进程。在IXOFF标志设置时，若输入不会使输入缓存溢出，则终端驱动程序自动地产生一START字符以恢复以前被停止的输入。
-  STATUS：4.3+BSD的状态-要求字符。以扩充、规范方式进行输入时识别此字符。它产生SIGINFO信号，该信号又被送至前台进程组中的所有进程。另外，如果没有设置NOKERNINFO标志，则有关前台进程组的状态信息也显示在终端上。在处理后，此字符即被删除，不送向读进程。
-  STOP：POSIX.1的停止字符。若设置了IXON标志，则在输入中识别此字符；若IXOFF标志已设置则作为输出自动产生此字符。在IXON已设置时接收到STOP字符则停止输出。在此情形下，在处理后删除此字符，不送向读进程。当输入一个START字符后，停止的输出重新起动。在IXOFF设置时，终端驱动程序自动地产生一个STOP字符以防止输入缓存溢出。
-  SUSP：POSIX.1的挂起作业控制字符。若支持作业控制并且ISIG标志已设置，则在输入中识别此字符。它产生SIGTSTP信号，该信号又被送至前台进程组的所有进程。在处理后，此字符即被删除，不送向读进程。
-  WERASE：SVR4和4.3+BSD的字擦除字符。以扩充、规范方式进行输入时识别此字符。它使前一个字被擦除。首先，它向后跳过任一白空字符(空格或制表符)，然后向后越过前一记号，使光标处在前一个记号的第一个字符位置上。通常，前一个记号在碰到一个白空字符时即终止。但是，可用设置ALTWERASE标志来改变这一点。此标志使前一个记号在碰到第一个非字母、数字符时即终止。在处理后，此字符即被删除，不送向读进程。

需要为终端设备定义的另一个“字符”是BREAK。BREAK实际上并不是一个字符，而是在异步串行数据传送时发生的一个条件。

在POSIX.1的11个特殊字符中，可将其中9个更改为几乎任何值。不能更改的两个特殊字符是新行符和回车符(/n和/r)，有些实现也不允许更改STOP和START字符。为了进行修改，只要更改termios结构中c_cc数组的相应项，该数组中的元素都用名字作为下标进行引用，每个名字都以字母V开头。

POSIX.1可选地允许禁止使用这些字符。若_POSIX_VDISABLE有效，则_POSIX_VDISABLE的值可存放在c_cc数组的相应项中以禁止使用该特殊字符。可以用pathconf和fpathconf函数查询此特征。



*** 4.POSIX终端I/O函数

| tcgetattr         | 取属性(termios结构)；     |
| tcsetattr         | 设置属性(termios结构)；   |
| cfgetispeed    | 得到输入速度；            |
| cfgetospeed       | 得到输出速度；            |
| cfsetispeed       | 设置输入速度；            |
| cfsetospeed       | 设置输出速度；            |
| tcdrain           | 等待所有输出都被传输；    |
| tcflow            | 挂起传输或接收；          |
| tcflush           | 刷清未决输入和/或输出；   |
| tcsendbreak       | 送BREAK字符；             |
| tcgetpgrp         | 得到前台进程组ID；        |
| tcsetpgrp         | 设置前台进程组ID；        |



*** 5.tcgetattr和tcsetattr

#+BEGIN_EXAMPLE
    #include <termios.h> int tcgetattr(int filedes, struct termios *termptr); int tcsetattr(int filedes, int opt, const struct termios *termptr); 两个函数返回：若成功则为0，若出错则为-1
#+END_EXAMPLE

这两个函数都有一个指向termios结构的指针作为其参数，它们返回当前终端的属性，或者设置该终端的属性。因为这两个函数只对终端设备进行操作，所以若filedes并不引用一个终端设备则出错返回，errno设置为ENOTTY。

tcsetattr的参数opt使我们可以指定在什么时候新的终端属性才起作用。opt可以指定为下列常数中的一个：

-  TCSANOW：更改立即发生；
-  TCSADRAIN：发送了所有输出后更改才发生。若更改输出参数则应使用此选择项。
-  TCSAFLUSH：发送了所有输出后更改才发生。更进一步，在更改发生时未读的所有输入数据都被删除(刷清)。

tcsetattr函数的返回值易于产生混淆。如果它执行了任意一种所要求的动作，即使未能执行所有要求的动作，它也返回0(表示成功)。如果该函数返回0，则我们有责任检查该函数是否执行了所有要求的动作。这就意味着，在调用tcsetattr设置所希望的属性后，需调用tcgetattr，然后将实际终端属性与所希望的属性相比较，以检测两者是否有区别。



*** 6.波特率函数

波特率(baud
rate)是一个历史沿用的术语，现在它指的是“位/每秒”。虽然大多数终端设备对输入和输出使用同一波特率，但是只要硬件许可，可以将它们设置为两个不同值。

#+BEGIN_EXAMPLE
    #include <termios.h> speed_t cfgetispeed(const struct termios *termptr); speed_t cfgetospeed(const struct termios *termptr); 两个函数返回：波特率值 int cfsetispeed(struct termios *termptr, speed_t speed); int cfsetospeed(struct termios *termptr, speed_t speed); 两个函数返回：若成功为0，出错为-1
#+END_EXAMPLE

两个cfget函数的返回值，以及两个cfset函数的speed参数都是下列常数之一：B50、B75、B110、B134、B150、B200、B300、B600、B1200、B1800、B2400、B4800、B9600、B19200或B38400。常数B0表示“挂断”。在调用tcsetattr时将输出波特率指定为B0，则调制解调器的控制线就不再起作用。

使用这些函数时，应当理解输入、输出波特率是存放在termios结构中的。在调用任一cfget函数之前，先要用tcgetattr获得设备的termios结构。与此类似，在调用任一cfset函数后，应将波特率设置到termios结构中。为使这种更改影响到设备，应当调用tcsetattr函数。如果所设置的波特率有错，则在调用tcsetattr之前，不会发现这种错误。



*** 7.行控制函数

#+BEGIN_EXAMPLE
    #include <termios.h> int tcdrain(int filedes); int tcflow(int filedes, int action); int tcflush(int filedes, int queue); int tcsendbreak(int filedes, int duration); 四个函数返回：若成功则为0，若出错则为-1
#+END_EXAMPLE

其中，参数filedes引用一个终端设备，否则出错返回，errno设置为ENOTTY。

tcdrain函数等待所有输出都被发送。

tcflow用于对输入和输出流控制进行控制。action参数应当是下列四个值之一：

-  TCOOFF：输出被挂起；
-  TCOON：以前被挂起的输出被重新起动；
-  TCIOFF：系统发送一个STOP字符。这将使终端设备暂停发送数据；
-  TCION：系统发送一个START字符。这将使终端恢复发送数据。

tcflush函数刷清(抛弃)输入缓存(终端驱动程序已接收到，但用户程序尚未读)或输出缓存(用户程序已经写，但尚未发送)。queue参数应当是下列三个常数之一：

-  TCIFLUSH：刷清输入队列；
-  TCOFLUSH：刷清输出队列；
-  TCIOFLUSH：刷清输入、输出队列；

tcsendbreak函数在一个指定的时间区间内发送连续的0位流。若duration参数为0，则此种发送延续0.25~
0.5秒之间。POSIX.1说明若duration非0，则发送时间依赖于实现。



*** 8.终端标识函数

POSIX.1提供了一个运行时函数，可被调用来决定控制终端的名字:

#+BEGIN_EXAMPLE
    #include <stdio.h> char * ctermid(char *ptr);
#+END_EXAMPLE

如果ptr是非空，则它被认为是一个指针，指向长度至少为L_ctermid字节的数组，进程的控制终端名存放在该数组中。常数L_ctermid定义在<stdio.h>中。若ptr是一个空指针，则该函数为数组(通常作为静态变量)分配空间。同样，进程的控制终端名存放在该数组中。

在这两种情况中，该数组的起始地址被作为函数值返回。因为大多数UNIX系统都使用/dev/tty作为控制终端名，所以此函数的主要作用是帮助提高向其他操作系统的可移植性。

其他终端标识函数还有：

#+BEGIN_EXAMPLE
    #include <unistd.h> int isatty(int filedes); 返回：若为终端设备则为1(真)，否则为0(假) char *ttyname(int filedes); 返回：指向终端路径名的指针，若出错则为NULL
#+END_EXAMPLE

如果文件描述符引用一个终端设备，则isatty返回真，而ttyname则返回在该文件描述符上打开的终端设备的路径名。



*** 9.规范方式

规范方式发一个读请求，当一行已经输入后，终端驱动程序即返回。许多条件造成读返回：

-  所要求的字节数已读到时读即返回。无需读一个完整的行。如果读了部分行，那么也不会丢失任何信息―下一次读从前一次读的停止处开始。
-  当读到一个行定界符时，读返回。在规范方式中，下列字符被解释为“行结束”：NL、EOL、EOL2和EOF。另外，如若已设置ICRNL，但未设置IGNCR，则CR字符的作用与NL字符一样，所以它也终止一行。在这五个行定界符中，其中只有一个EOF符在终端驱动程序对其进行处理后即被删除。其他四个字符则作为该行的最后一个字符返回调用者。
-  如果捕捉到信号而且该函数并不自动再起动，则读也返回。



*** 10.非规范方式

将termios结构中c_lflag字段的ICANON标志关闭就使终端处于非规范方式。在非规范方式中，输入数据不装配成行，不处理下列特殊字符：ERASE、KILL、EOF、NL、EOL、EOL2、CR、REPRINT、STATUS和WERASE。

在非规范方式下，由于不是每次返回一行，解决读的方法是：当已读了指定量的数据后，或者已经过了给定量的时间后，即通知系统返回。

这种技术使用termios结构中c_cc数组的两个变量：MIN和TIME。c_cc数组中的这两个元素的下标名为：VMIN和VTIME。

MIN说明一个read返回前的最小字节数。TIME说明等待数据到达的分秒数(秒的1/10为分秒)。有下列四种情形：

-  *情形A：MIN > 0, TIME >
   0*。TIME说明一个字节间的计时器，在接到第一个字节时才起动它。在该计时器超时之前，若已接到MIN个字节，则read返回MIN个字节。如果在接到MIN个字节之前，该计时器已超时，则read返回已接收到的字节(因为只有在接到第一个字节时才起动，所以在计时器超时时，至少返回1个字节)。在这种情形中，在接到第一个字节之前，调用者阻塞。如果在调用read时数据已经可用，则这如同在read后，数据立即被接收到一样。
-  *情形B：MIN > 0 , TIME = =
   0*。已经接到了MIN个字节时，read才返回。这可以造成read无限期的阻塞。
-  *情形C：MIN = = 0，TIME >
   0*。TIME指定了一个调用read时起动的读计时器。(与情形A相比较，两者是不同的)。在接到1个字节或者该计时器超时时，read即返回。如果是计时器超时，则read返回0。
-  *情形D ：MIN = = 0，TIME = =
   0*。如果有数据可用，则read最多返回所要求的字节数。如果无数据可用，则read立即返回0。

在所有这些情形中，MIN只是最小值。如果程序要求的数据多于MIN个字节，那么它可能能接收到所要求的字节数。这也适用于MIN
= = 0的情形A和B。



*** 11.break方式和raw方式

对cbreak方式的定义是：

-  非规范方式。这种方式不对某些输入特殊字符进行处理。这种方式仍对信号进行处理，所以用户可以键入任一终端产生的信号。调用者应当捕捉这些信号，否则这种信号就可能终止程序，并且终端将仍处于cbreak方式。作为一般规则，在编写更改终端方式的程序时，应当捕捉大多数信号，以便在程序终止前恢复终端方式；
-  关闭回送(ECHO)标志；
-  每次输入一个字节。为此将MIN设置为1，将TIME设置为0。至少有一个字节可用时，read再返回。

对原始方式的定义是：

-  非规范方式。另外，还关闭了对信号产生字符(ISIG)和扩充输入字符的处理(IEXTEN)。关闭BRKINT，这样就使BREAK字符不再产生信号；
-  关闭回送(ECHO)标志；
-  关闭ICRNL、INPCK、ISTRIP和IXON标志。于是：不再将输入的CR字符变换为NL(ICRNL)、使输入奇偶校验不起作用(INPCK)、不再剥离输入字节的第8位(ISTRIP)、不进行输出流控制(IXON)；
-  8位字符(CS8)，不产生奇偶位，不进行奇偶性检测(PARENB)；
-  禁止所有输出处理(OPOST)；
-  每次输入一个字节(MIN = 1，TIME = 0)。



*** 12.终端窗口

内核为每个终端和伪终端保存一个winsize结构：

*[c-sharp]* [[http://blog.csdn.net/jibcy/article/details/7351669][view
plain]][[http://blog.csdn.net/jibcy/article/details/7351669][copy]]



1. struct winsize {
2.  unsigned short ws_row; /* rows, in characters */
3.  unsigned short ws_col; /* columns, in character */
4.  unsigned short ws_xpixel; /* horizontal size, pixels */
5.  unsigned short ws_ypixel; /* vertical size, pixels */
6. };

*[c-sharp]* [[http://blog.csdn.net/jibcy/article/details/7351669][view
plain]][[http://blog.csdn.net/jibcy/article/details/7351669][copy]]



1. struct winsize {
2.  unsigned short ws_row; /* rows, in characters */
3.  unsigned short ws_col; /* columns, in character */
4.  unsigned short ws_xpixel; /* horizontal size, pixels */
5.  unsigned short ws_ypixel; /* vertical size, pixels */
6. };

此结构的作用是：

1. 用ioctl的TIOCGWINSZ命令可以取此结构的当前值。
2. 用ioctl的TIOCSWINSZ命令可以将此结构的新值存放到内核中。如果此新值与存放在内核中的当前值不同，则向前台进程组发送SIGWINCH信号。此信号的系统默认动作是忽略。
3. 除了存放此结构的当前值以及在此值改变时产生一个信号以外，内核对该结构不进行任何其他操作。对结构中的值进行解释完全是应用程序的工作。

提供这种功能的目的是，当窗口大小发生变化时通知应用程序(例如vi编辑程序)。应用程序接到此信号后，它可以取得窗口大小的新值，然后重绘屏幕。

** [[http://www.latexstudio.net/archives/3516][]]

** [[http://www.latexstudio.net/archives/3516][org-mode的中文beamer幻灯片模板]]

2015-04-09
分类：[[http://www.latexstudio.net/archives/category/tex-slides/beamer-theme-template][beamer]]
阅读(444) 评论(1)

org-mode 是 Emacs
的杀手级应用，使用它可以用来做很多事情，如GTD、做笔记等。它可以导出多种格式的文件，包括HTML、LaTeX、Freemind、DocBook等，因此，通过定制之后，编写一份org文件就等于同时编写（或者排版）了多种格式文件，而且每种格式的文件又可以各自拥有不同的排版效果。这正是
org-mode 精妙之处。

比如，我最喜欢的做法是先在 Emacs 里打开 evernote-mode 写一份 org-mode
的笔记，然后 =C-c C-e H= 导出成 HTML
代码，并发布到我的博客中或者加入到我的 wiki
里。如果有需要，我还可以 =C-c C-e l= 生成 LaTeX 代码并编译成 PDF 文件。

用 org-mode 制作 Beamer
幻灯片也很简单，官方已经给出了 [[http://orgmode.org/worg/org-tutorials/org-beamer/tutorial.html][详细的教程]] ，照着一步步做即可。官方的教程并没有针对中文进行定制，因此笔者写了一个org-mode的Beamer中文模板，这是在 [[http://orgmode.org/manual/Beamer-class-export.html#Beamer-class-export][Carsten
Dominik的例子]] 的基础上修改得到的。

*** 1 截图预览

[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2015/04/org-beamer-cn.png]]

*** 2 环境要求

1. Emacs
2. org-mode
3. TeXLive 或其他带有 Beamer 宏包的 LaTeX 系统
4. Adobe 字体

   -  Adobe Heiti Std
   -  Adobe Kaiti Std

*** 3 特点

1. 使用 “Darmstadt” 主题及 “Firebrick”配色方案；
2. 使用 listings
   宏包实现代码框。如果有中文内容，你可能需要使用逃逸字串(`')括住两边，否则会出现错位；
3. 使用xeCJK来处理中文，并使用 Adobe
   字体（[[http://ishare.iask.sina.com.cn/f/23186570.html][字体下载]]）。

*** 4 下载

-  Github主页：[[http://wzpan.github.com/org-beamer-cn/][http://wzpan.github.io/org-beamer-cn/]]
-  克隆git仓库：git clone https://github.com/wzpan/org-beamer-cn.git
-  zip压缩包：[[https://github.com/wzpan/org-beamer-cn/zipball/master][https://github.com/wzpan/org-beamer-cn/zipball/master]]
-  tar.gz压缩包：[[https://github.com/wzpan/org-beamer-cn/tarball/master][https://github.com/wzpan/org-beamer-cn/tarball/master]]
-  本站下载：[[http://www.latexstudio.net/wp-content/uploads/2015/04/wzpan-org-beamer-cn-e5b5173.zip][wzpan-org-beamer-cn-e5b5173]]

*** 5 使用方法

-  用 Emacs 打开 *beamer.org* 文件， =M-x org-mode= 打开 org-mode；
-  =C-c C-e l= 生成 beamer.tex 文件；
-  打开 *beamer.tex* 文件， =C-c C-c (M-x TeX-command-master)= 并选择使用 *XeLaTeX* 编译。完成后就可以得到幻灯片了。

*** 6 F&Q

-  两个“@”不能生成alert效果？

这个可能是 org-mode 本身的 bug，但可以通过修改
Emacs里的设置来解决。在 =(require 'org-latex)= 前加入这一段设置：

Lisp

(setq org-emphasis-alist (quote (("*" bold "<b>" "</b>") ("/" italic
"<i>" "</i>") ("_" underline "<span
style=\"text-decoration:underline;\">" "</span>") ("=" org-code "<code>"
"</code>" verbatim) ("~" org-verbatim "<code>" "</code>" verbatim) ("+"
(:strike-through t) "<del>" "</del>") ("@" org-warning "<b>" "</b>")))
org-export-latex-emphasis-alist (quote (("*" "\\textbf{%s}" nil) ("/"
"\\emph{%s}" nil) ("_" "\\underline{%s}" nil) ("+" "\\texttt{%s}" nil)
("=" "\\verb=%s=" nil) ("~" "\\verb~%s~" t) ("@" "\\alert{%s}" nil))))

| 1    | (setq org-emphasis-alist (quote (("*" bold "<b>" "</b>")                      |
| 2    |   ("/" italic "<i>" "</i>")                    |
| 3    |   ("_" underline "<span                       |
| 4    | style=\"text-decoration:underline;\">" "</span>")                             |
| 5    |   ("=" org-code "<code>" "</code>"             |
| 6    |   verbatim)                                                    |
| 7    |   ("~" org-verbatim "<code>" "</code>"         |
| 8    |   verbatim)                                                    |
| 9    |   ("+" (:strike-through t) "<del>" "</del>")   |
| 10   |   ("@" org-warning "<b>" "</b>")))             |
| 11   |  org-export-latex-emphasis-alist (quote                                  |
| 12   |   (("*" "\\textbf{%s}" nil)              |
| 13   |  ("/" "\\emph{%s}" nil)                |
| 14   |  ("_" "\\underline{%s}" nil)          |
| 15   |  ("+" "\\texttt{%s}" nil)              |
| 16   |  ("=" "\\verb=%s=" nil)                |
| 17   |  ("~" "\\verb~%s~" t)                  |
| 18   |  ("@" "\\alert{%s}" nil))))            |

** [[http://linuxcommand.org/man_pages/pdfinfo1.html][pdfinfo]]

*** NAME

#+BEGIN_EXAMPLE
           pdfinfo - Portable Document Format (PDF) document information extractor
           (version 3.01)

#+END_EXAMPLE

*** SYNOPSIS

#+BEGIN_EXAMPLE
           pdfinfo [options] [PDF-file]

#+END_EXAMPLE

*** DESCRIPTION

#+BEGIN_EXAMPLE
           Pdfinfo prints the contents of the ´Info’ dictionary (plus  some  other
           useful information) from a Portable Document Format (PDF) file.

           The ´Info’ dictionary contains the following values:

                  title
                  subject
                  keywords
                  author
                  creator
                  producer
                  creation date
                  modification date

           In addition, the following information is printed:

                  tagged (yes/no)
                  page count
                  encrypted flag (yes/no)
                  print and copy permissions (if encrypted)
                  page size
                  file size
                  linearized (yes/no)
                  PDF version
                  metadata (only if requested)

#+END_EXAMPLE

*** CONFIGURATION FILE

#+BEGIN_EXAMPLE
           Pdfinfo  reads a configuration file at startup.  It first tries to find
           the user’s private config file, ~/.xpdfrc.  If that doesn’t  exist,  it
           looks  for  a  system-wide config file, typically /etc/xpdfrc (but this
           location can be changed when pdfinfo is built).  See the xpdfrc(5)  man
           page for details.

#+END_EXAMPLE

*** OPTIONS

#+BEGIN_EXAMPLE
           Many  of  the following options can be set with configuration file com-
           mands.  These are listed in square brackets with the description of the
           corresponding command line option.

           -f number
                  Specifies  the  first  page  to  examine.  If multiple pages are
                  requested using the "-f" and "-l"  options,  the  size  of  each
                  requested  page  (and,  optionally,  the bounding boxes for each
                  requested page) are printed.  Otherwise, only page one is  exam-
                  ined.

           -l number
                  Specifies the last page to examine.

           -box   Prints the page box bounding boxes: MediaBox, CropBox, BleedBox,
                  TrimBox, and ArtBox.

           -meta  Prints document-level metadata.  (This is the "Metadata"  stream
                  from the PDF file’s Catalog object.)

           -enc encoding-name
                  Sets  the  encoding  to  use for text output.  The encoding-name
                  must be defined with the  unicodeMap  command  (see  xpdfrc(5)).
                  This defaults to "Latin1" (which is a built-in encoding).  [con-
                  fig file: textEncoding]

           -opw password
                  Specify the owner password for the  PDF  file.   Providing  this
                  will bypass all security restrictions.

           -upw password
                  Specify the user password for the PDF file.

           -cfg config-file
                  Read config-file in place of ~/.xpdfrc or the system-wide config
                  file.

           -v     Print copyright and version information.

           -h     Print usage information.  (-help and --help are equivalent.)

#+END_EXAMPLE

*** EXIT CODES

#+BEGIN_EXAMPLE
           The Xpdf tools use the following exit codes:

           0      No error.

           1      Error opening a PDF file.

           2      Error opening an output file.

           3      Error related to PDF permissions.

           99     Other error.

#+END_EXAMPLE

*** AUTHOR

#+BEGIN_EXAMPLE
           The pdfinfo software and documentation are copyright 1996-2005 Glyph  &
           Cog, LLC.

#+END_EXAMPLE

*** SEE ALSO

#+BEGIN_EXAMPLE
           xpdf(1),  pdftops(1),  pdftotext(1),  pdffonts(1),  pdftoppm(1), pdfim-
           ages(1), xpdfrc(5)
           http://www.foolabs.com/xpdf/



                                    17 August 2005                      pdfinfo(1)
#+END_EXAMPLE

--------------

Man(1) output converted with
[[http://www.oac.uci.edu/indiv/ehood/man2html.html][man2html]]

** [[http://www.cnblogs.com/fhefh/archive/2011/04/22/2024857.html][linux bash shell之declare]]

/declare/或/typeset/内建命令(它们是完全相同的)可以用来限定变量的属性.这是在某些编程语言中使用的定义类型不严格的方式。命令*declare*是bash版本2之后才有的。命令*typeset*也可以在ksh脚本中运行。

*declare/typeset 选项*

-  -r =只读= :: | #+BEGIN_EXAMPLE            |
                |        1 declare -r var1   |
                | #+END_EXAMPLE              |


   (=declare -r var1=与=readonly var1=作用相同)

   这大致和C的*const*限定词相同.一个试图改变只读变量值的操作将会引起错误信息而失败.

-  -i =整数= :: | #+BEGIN_EXAMPLE                                                                        |
                |        1 declare -i number                                                             |
                |        2 # 脚本余下的部分会把"number"当作整数看待.                                     |
                |        3                                                                               |
                |        4 number=3                                                                      |
                |        5 echo "Number = $number"     # Number = 3                                      |
                |        6                                                                               |
                |        7 number=three                                                                  |
                |        8 echo "Number = $number"     # Number = 0                                      |
                |        9 # 脚本尝试把字符串"three"作为整数来求值(译者注：当然会失败，所以出现值为0).   |
                | #+END_EXAMPLE                                                                          |


   某些算术计算允许在被声明为整数的变量中完成，而不需要特别使用expr或let来完成。

   | #+BEGIN_EXAMPLE                          |
   |        1 n=6/3                           |
   |        2 echo "n = $n"       # n = 6/3   |
   |        3                                 |
   |        4 declare -i n                    |
   |        5 n=6/3                           |
   |        6 echo "n = $n"       # n = 2     |
   | #+END_EXAMPLE                            |


-  -a =数组= :: | #+BEGIN_EXAMPLE               |
                |        1 declare -a indices   |
                | #+END_EXAMPLE                 |


   变量=indices=会被当作数组.

-  -f =函数= :: | #+BEGIN_EXAMPLE       |
                |        1 declare -f   |
                | #+END_EXAMPLE         |


   在脚本中没有带任何参数的=declare -f= 会列出所有在此脚本前面已定义的函数出来。

   | #+BEGIN_EXAMPLE                     |
   |        1 declare -f function_name   |
   | #+END_EXAMPLE                       |


   而=declare -f function_name=则只会列出指定的函数.

-  -x export :: | #+BEGIN_EXAMPLE            |
                |        1 declare -x var3   |
                | #+END_EXAMPLE              |


   这样将声明一个变量作为脚本的环境变量而被导出。

-  -x var=$value :: | #+BEGIN_EXAMPLE                |
                    |        1 declare -x var3=373   |
                    | #+END_EXAMPLE                  |


   *declare*命令允许在声明变量类型的时候同时给变量赋值。

--------------

*例子 9-21. 用*declare来声明变量类型**

| #+BEGIN_EXAMPLE                                                              |
|        1 #!/bin/bash                                                         |
|        2                                                                     |
|        3 func1 ()                                                            |
|        4 {                                                                   |
|        5 echo This is a function.                                            |
|        6 }                                                                   |
|        7                                                                     |
|        8 declare -f        # 列出上面的函数.                                 |
|        9                                                                     |
|       10 echo                                                                |
|       11                                                                     |
|       12 declare -i var1   # var1是一个整数.                                 |
|       13 var1=2367                                                           |
|       14 echo "var1 declared as $var1"                                       |
|       15 var1=var1+1       # 整数声明后，不需要使用'let'.                    |
|       16 echo "var1 incremented by 1 is $var1."                              |
|       17 # 试图将已声明为整数的变量的值更改为浮点值.                         |
|       18 echo "Attempting to change var1 to floating point value, 2367.1."   |
|       19 var1=2367.1       # 引起一个错误信息，此变量的值保持原样.           |
|       20 echo "var1 is still $var1"                                          |
|       21                                                                     |
|       22 echo                                                                |
|       23                                                                     |
|       24 declare -r var2=13.36         # 'declare'允许设置变量的属性，       |
|       25                               #+ 同时也给变量赋值.                  |
|       26 echo "var2 declared as $var2" # 试图更改只读变量的值.               |
|       27 var2=13.37                    # 引起错误，并且从脚本退出.           |
|       28                                                                     |
|       29 echo "var2 is still $var2"    # 这行不会被执行.                     |
|       30                                                                     |
|       31 exit 0                        # 脚本不会从这儿退出.                 |
| #+END_EXAMPLE                                                                |

** [[/a/1190000002539169][玩转Bash变量]]

[[/u/spacewander][[[http://sfault-avatar.b0.upaiyun.com/411/132/411132166-5646f64876acf_big64]]
*spacewander*]] ** 2015年02月05日 发布

-  推荐
   *3* 推荐
-  收藏
   *17* 收藏，*4k* 浏览

PS :
注意本文讨论的是Bash，而不一定是/bin/sh所链接的那个shell。这里出现的所有代码片段，默认在顶上都添加了=#!/bin/bash=。

*** 一门自带混淆的语言

#+BEGIN_EXAMPLE
    while (( $# )); do
        case $1 in
            -a*)
                # Error checking
                [[ ${1#-a} ]] || { echo "bash: ${FUNCNAME[0]}: \`$1': missing"\
                    "number specifier" 1>&2; return 1; }
                printf %d "${1#-a}" &> /dev/null || { echo "bash:"\
                    "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2
                return 1; }
                # Assign array of -aN elements
                [[ "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) &&
                    shift $((${1#-a} + 2)) || { echo "bash: ${FUNCNAME[0]}:"\
                    "\`$1${2+ }$2': missing argument(s)" 1>&2; return 1; }
                ;;
            -v)
                # Assign single value
                [[ "$2" ]] && unset -v "$2" && eval $2=\"\$3\" &&
                    shift 3 || { echo "bash: ${FUNCNAME[0]}: $1: missing"\
                    "argument(s)" 1>&2; return 1; }
                ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2
                return 1 ;;
        esac
    done
#+END_EXAMPLE

如果你觉得阅读上面的Bash代码，就像阅读段子一样顺畅，那么是时候关掉这个页面，去做别的更有意义的行为，比如去喝个水什么的。

如果你觉得上面的Bash代码犹如鬼画符，并且实际生活中不得不面对它，那么就看下去吧。

*** Bash变量操作

正式开始正文内容。

想要在一篇文章里，讲述要看懂开篇代码所需的所有知识点，这是不自量力的行为。因此，本文将讲且仅讲Bash中操作变量的方法。所以，即使你看完了这篇文章，你多半还是看不懂开篇的代码。

不过看完这篇文章之后，你对Bash的变量操作会有更为深入的认识。而且更重要的是，Bash之于你，不再是怎么也看不清摸不透。下一次要写脚本的时候，你也将更加坚定地下定决心
------ 人生苦短，我用Python/Ruby。

**** 严格意义上的Bash变量类型

Bash变量只有两种类型，字符串和数组。不过从严格意义上，Bash没有变量类型。Bash中的变量，在运行的时候会被展开成其对应的值（字符串）。你可以把它看做C/C++中的宏定义，或者一些模板语言中的占位符。

一般情况下，变量通过===赋值，注意===两边不要留空格。有些好孩子，已经养成了符号两端留空格的习惯，结果当开始写Bash的时候，他们抓狂了。

要想访问变量，只需在变量名前面添加=$=，解释器就会对它进行展开。如果该变量并不存在，解释器会把它展开成“”。

#+BEGIN_EXAMPLE
    me=spacewander
    echo $me
    echo $who
#+END_EXAMPLE

**** 来自命令行的你

作为脚本语言，第一要义当然是要随时随地获取到命令行输入啦。

在Bash中，使用=$1=可以获取命令行输入的第一个参数，=$2=可以获取命令行输入的第2个参数，=$3=可以获取命令行输入的第......
 你看，$1到$10000的用法就这么交代完了。Bash还是挺有逻辑的嘛。

顺便一提，=$0=获取的脚本的名字（其实就是其他语言中的第0个参数），=$@=获取所有的参数，=$#=获取参数的数目。记住=@=和=#=这两个符号，在Bash这一神秘的符文体系中，前者表示全部参数，后者表示参数的数目。

**** 展开，然后Bomb！

假如Bash变量中含有空白字符，或者含有特殊字符，比如=*=，展开后会污染到外面的字符串，结果就是*Bomb*。
 比如

#+BEGIN_EXAMPLE
    Oops='*'
    # '*'解释成所有匹配的文件名
    echo $Oops
    # 所以需要加双引号括起来
    echo "$Oops"
    # 加单引号会怎样呢？
    echo '$Oops'
#+END_EXAMPLE

上面的代码值得一试。

另外一种Bomb的可能是，变量后面需要接其它字符串，比如=$FRUITs=。如果想让解释器识别成=$FRUIT=变量，而不是=$FRUITs=，需要用花括号括起来，像=${FRUIT}s=

**** 数组和关联数组

Bash中可以使用两种容器。
 一种是数组，另一种是关联数组，类似于其他语言中的Map/Hash/Dict。
 声明数组的常用语法： =declare -a ARY=或者=ARY=(1 2 3)=
 声明关联数组的唯一语法： =declare -A MAP=

赋值的语法：

直接=ARY[N]=VALUE=，N可以是数字索引也可以是键。关联数组可以使用=MAP=([x]=a [y]=b)=进行多项赋值，注意这是赋值的语句而不是声明。

亲测数组中的索引不一定要按顺序来，你可以先给2和3上的元素赋值。（同样算是弱类型的Javascript也支持这种无厘头赋值，这算通病么？）

往现有数组批量添加元素：

#+BEGIN_EXAMPLE
    ARY+=(a b c)
    MAP+=([a]=1 [b]=2)
#+END_EXAMPLE

取值：

#+BEGIN_EXAMPLE
    ${ARY[INDEX]}
    ${MAP[KEY]}
#+END_EXAMPLE

注意花括号的使用

=${A[@]}= 展开成所有的变量，而获取数组长度使用 =${#A[@]}=

切片：
=${ARY[@]:N:M}= N是offset而M是length

返回索引，相当于keys()：
=${!MAP[@]}=

试试下面的代码：

#+BEGIN_EXAMPLE
    declare -a ARY
    declare -A MAP
    MAP+=([a]=1 [b]=2)
    ARY+=(a b c)

    echo ${ARY[1]}
    echo ${MAP[a]}
    echo "${ARY[@]}"
    echo "${MAP[@]}"
    echo "${ARY[@]:0:1}"
    echo ${#ARY[@]}
    echo "${!MAP[@]}"

    ARY[4]=a
    echo ${ARY[@]}
    echo ${ARY[3]}
#+END_EXAMPLE

**** 变量（字符串）变换

Bash中的变量变换，大体是${变量[操作符]}的形式

***** 大小写变换

#+BEGIN_EXAMPLE
    HI=HellO

    echo "$HI" # HellO
    echo ${HI^} # HellO
    echo ${HI^^} # HELLO
    echo ${HI,} # hellO
    echo ${HI,,} # hello
    echo ${HI~} # hellO
    echo ${HI~~} #hELLo
#+END_EXAMPLE

=^=大写，=,=小写， =~=大小写切换
 重复一次只修改首字母，重复两次则应用于所有字母。

混着用会怎样？
=echo ${HI^,^} # HellO=
 看来是不行的×_×

***** 移除匹配的字符串

=%xx= 从后往前，开始匹配，移除匹配的内容
=%%xx= 跟上面的差不多，不过这是贪婪匹配
=#xx= 从前往后，开始匹配，移除匹配的内容
=##xx= 跟上面的差不多，不过这是贪婪匹配

这个比较难理解，不过看下面几个例子应该能明白了。

#+BEGIN_EXAMPLE
    FILENAME=/home/spacewander/param.sh
    echo ${FILENAME%/*} # /home/spacewander
    echo ${FILENAME%%/*} #
    echo ${FILENAME#*/} # home/spacewander/param.sh
    echo ${FILENAME##*/} # param.sh
#+END_EXAMPLE

***** 查找并替换

=/MATCH/VALUE= 替换第一个匹配的内容。
=//MATCH/VALUE= 替换匹配的内容

#+BEGIN_EXAMPLE
    echo ${FILENAME/home/office} # /office/spacewander/param.sh
    echo ${FILENAME//s/S} # /home/Spacewander/param.Sh
#+END_EXAMPLE

**** 其它字符串操作

获取变量（字符串）长度：=${#FILENAME}=

字符串切片：跟数组切片是同样的语法，=${STR:offset:len}=

#+BEGIN_EXAMPLE
    TEXT=这个程序充满了BUG!
    echo ${TEXT:0:8}
    echo ${TEXT:4}

    # 你还可以使用负数作为offset，这时候就是从后往前算起。注意负数要用括号括起来，避免冲突。
    echo ${TEXT:(-4)}
#+END_EXAMPLE

**** 关于变量，其它的内容

Bash中有一项特性，你可以方便地检查某个变量是否设置了，如果没有设置，就赋予一个默认值。尤其在处理环境变量的时候，这项特性会让你感到欣慰。

语法是=${VAR:=VALUE}=或者=${VAR:=VALUE}=。此外，还有一个相似的语法，=${VAR:=VALUE}=和=${VAR：=VALUE}=。

下面展示下两者的区别

#+BEGIN_EXAMPLE
    # expand to default variable
    echo ${NULL-"Not null"} # Not null
    echo ${NULL} #

    # set default variable
    echo ${NIL="Not nil"} # Not nil
    echo ${NIL} # Not nil
#+END_EXAMPLE

可以看出，前者只是当变量不存在时，展开成指定的值。而后者在变量不存在时，将变量的值设置为指定值。

最后介绍一个，当目标变量不存在时，指定报错信息的语法。

#+BEGIN_EXAMPLE
    echo ${TARGET?Not Found} # 当$TARGET不存在时，显示TARGET: Not Found，并结束程序。
#+END_EXAMPLE

** [[http://orgmode.org/manual/Creating-timestamps.html][Creating timestamps]]


For Org mode to recognize timestamps, they need to be in the specific
format. All commands listed below produce timestamps in the correct
format.

C-c .  (=org-time-stamp=)

Prompt for a date and insert a corresponding timestamp. When the cursor
is at an existing timestamp in the buffer, the command is used to modify
this timestamp instead of inserting a new one. When this command is used
twice in succession, a time range is inserted.

C-c !  (=org-time-stamp-inactive=)

Like C-c ., but insert an inactive timestamp that will not cause an
agenda entry.

C-u C-c .

C-u C-c !

Like C-c . and C-c !, but use the alternative format which contains date
and time. The default time can be rounded to multiples of 5 minutes, see
the option =org-time-stamp-rounding-minutes=.

C-c C-c

Normalize timestamp, insert/fix day name if missing or wrong.

C-c <  (=org-date-from-calendar=)

Insert a timestamp corresponding to the cursor date in the Calendar.

C-c >  (=org-goto-calendar=)

Access the Emacs calendar for the current date. If there is a timestamp
in the current line, go to the corresponding date instead.

C-c C-o  (=org-open-at-point=)

Access the agenda for the date given by the timestamp or -range at point
(see
[[Weekly_002fdaily-agenda.html#Weekly_002fdaily-agenda][Weekly/daily
agenda]]).

S-<left>  (=org-timestamp-down-day=)

S-<right>  (=org-timestamp-up-day=)

Change date at cursor by one day. These key bindings conflict with
shift-selection and related modes (see
[[Conflicts.html#Conflicts][Conflicts]]).

S-<up>  (=org-timestamp-up=)

S-<down>  (=org-timestamp-down-down=)

Change the item under the cursor in a timestamp. The cursor can be on a
year, month, day, hour or minute. When the timestamp contains a time
range like ‘15:30-16:30', modifying the first time will also shift the
second, shifting the time block with constant length. To change the
length, modify the second time. Note that if the cursor is in a headline
and not at a timestamp, these same keys modify the priority of an item.
(see [[Priorities.html#Priorities][Priorities]]). The key bindings also
conflict with shift-selection and related modes (see
[[Conflicts.html#Conflicts][Conflicts]]).

C-c C-y  (=org-evaluate-time-range=)

Evaluate a time range by computing the difference between start and end.
With a prefix argument, insert result after the time range (in a table:
into the following column).

** [[https://wiki.freebsdchina.org/doc/r/reference][利用 Emacs 的 org-mode 管理文献]]

俗话说，“好记性不如烂笔头”。文献管理，不仅对科研工作者，对普通的用户也是必需的。看过的文献，写写心得做做笔记，以后写文章旁征博引的时候就不至于心乱如麻。

已有一些开源的文献管理的工具广受欢迎，如 JabRef、docear
等。一些常见的工具软件，读者可参阅
[[http://zh.wikipedia.org/wiki/文献管理软件比较][文献管理软件比较]]。

这里，我介绍另外一种简便的方法：利用 Emacs 的 org-mode
管理文献。原因有二：（1）Emacs
是可以使用一生的编辑器；（2）org-mode是做笔记的强大工具。

本着简单为美，高效为目的的原则，充分利用已有资源，本 wiki 的方法（源自
[[http://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/][http://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/]]）能够出色地完成文献管理的任务。

*** 利用 Google Scholar 导出 bibtex 文件

写科技文章，TeX 排版工具是必须掌握的。现在的国际会议和期刊，哪个不要求
TeX 排版？我们假定读者熟悉 TeX 排版，了解最简单的 Emacs 使用方法。

在 TeX 中，文献的索引来自独立文件 *.bib，它的格式必须通过 bibtex
的编译。[[https://wiki.freebsdchina.org/software/r/refdb][文献管理软件
RefDB]]介绍了如何从 RIS 格式转化为 bib 格式。RefDB
是图书馆时代的产物，随着 Google Scholar
的普及，我们有更便捷的文献管理方法。

Google Scholar 提供了搜索文献和导出其 bibtex
描述的强大功能，它在某种程度上替代了图书馆检索和某些专业数据库检索（如
PubMed
等），让更多的人能够方便地检索到文献。在知识共享的年代，我认为，Google
Scholar 是 Google 公司最伟大的产品之一。

*** 文献管理有哪些功能？

一个文献管理软件，必须具备以下几项功能。

1. bibtex 格式
2. 文章标题、作者、期刊名等关键词搜索
3. 链接到本地保存的文章（一般为 PDF 格式）
4. 做笔记（写文章的时候，笔记很重要）
5. 在 TeX 文档中利用 \cite{} 索引

*** 准备工作

我当前使用的 Emacs 版本是 GNU Emacs
24.3.1（在更低的版本上我没有试验过），自带了 RefTeX。

需要额外安装的是 /usr/ports/deskutils/org-mode.el。

建立目录 ~/reference，里面建立目录 ~/reference/papers。另外，

#+BEGIN_EXAMPLE
    IOU@~/reference$ touch notes.org
    IOU@~/reference$ touch reference.bib
#+END_EXAMPLE

要求 notes.org 文件的开头是

#+BEGIN_EXAMPLE
    # \bibliography{~/reference/reference.bib}
#+END_EXAMPLE

为了演示方便起见，reference.bib 里只有一篇文献

#+BEGIN_EXAMPLE
    @Article{     blei2012probabilistic,
      title     = {Probabilistic topic models},
      author    = {Blei, David M},
      journal   = {Communications of the ACM},
      volume    = {55},
      number    = {4},
      pages     = {77--84},
      year      = {2012},
      publisher = {ACM}
    }
#+END_EXAMPLE

该文章取名为 blei2012probabilistic.pdf，存放于 ~/reference/papers/ 下。

*** .emacs 里的一些设置

在 $HOME/.emacs 文件里，添加以下设置。

#+BEGIN_EXAMPLE
    ;; 定义 org-mode-reftex-search
    (defun org-mode-reftex-search ()
     ;; jump to the notes for the paper pointed to at from reftex search
     (interactive)
     (org-open-link-from-string (format "[[notes:%s]]" (reftex-citation t))))

    (setq org-link-abbrev-alist
     '(("bib" . "~/reference/reference.bib::%s")
       ("notes" . "~/reference/org/notes.org::#%s")
       ("papers" . "~/reference/papers/%s.pdf")))

    ;; 当使用 org-mode 时，自动调 RefTeX
    (defun org-mode-reftex-setup ()
      (load-library "reftex")
      (and (buffer-file-name) (file-exists-p (buffer-file-name))
           (progn
        ;; enable auto-revert-mode to update reftex when bibtex file changes on disk
        (global-auto-revert-mode t)
        (reftex-parse-all)
        ;; add a custom reftex cite format to insert links
        (reftex-set-cite-format
          '((?b . "[[bib:%l][%l-bib]]")
            (?c . "\\cite{%l}")
            (?n . "[[notes:%l][%l-notes]]")
            (?p . "[[papers:%l][%l-paper]]")
            (?t . "%t")
            (?h . "** %t\n:PROPERTIES:\n:Custom_ID: %l\n:END:\n[[papers:%l][%l-paper]]")))))
      (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
      ;; binding of  ”C-c (” to org-mode-reftex-search
      (define-key org-mode-map (kbd "C-c (") 'org-mode-reftex-search))

    (add-hook 'org-mode-hook 'org-mode-reftex-setup)
#+END_EXAMPLE

*** 如何使用 notes.org 来管理文献

org-mode 是利用 Emacs 做笔记的强大工具，可以直接生成 html、TeX、PDF
等文档。

-  用 emacs 打开 notes.org 文件，将光标放置于某空行，利用命令 “C-c )”
   来建立文献索引入口，可以是 bibtex 的入口，也可以是 PDF
   文件的入口，也可以是 \cite{}。
-  命令 ”C-c (“ 可进行正则表达式搜索
-  要打开入口，只需光标停留在入口上，键入 “C-c C-o” 命令即可。
-  利用命令 “C-c \” 来搜索关键词。

*** 效果图

[[https://wiki.freebsdchina.org/_detail/doc/r/reference.png?id=doc%3Ar%3Areference][[[https://wiki.freebsdchina.org/_media/doc/r/reference.png]]]]

** [[http://hyry.dip.jp/tech/slice/slice.html/35][IPython Notebook简介1]]

作者 : [[/tech/default/userpage.html/1][RY]]   标签:
[[/tech/default/tag.html/43][cython]]
[[/tech/default/tag.html/150][ipython-notebook]]

IPython
notebook目前已经成为用Python做教学、计算、科研的一个重要工具。本文介绍IPython
notebook的一些基本用法，以及如何使用它调试Cython程序。

IPython
Notebook使用浏览器作为界面，向后台的IPython服务器发送请求，并显示结果。在浏览器的界面中使用单元(Cell)保存各种信息。Cell有多种类型，经常使用的有表示格式化文本的[[http://daringfireball.net/projects/markdown/][Markdown]]单元，和表示代码的Code单元。

每个代码单元都有一个输出区域，在Code单元中输入代码，按 Shift-Enter
将运行此代码，代码中最后一个表达式的值将输出区域显示。如果希望屏蔽输出，可以在最后一条语句之后添加一个分号：”;”。此外，代码中还可以使用print语句在输出区域中显示信息。

在Markdown单元中还可以直接使用Html和Javascript。

*** 数学公式[[#id1][¶]]

在Markdown单元中可以使用LaTeX表示数学公式，例如[[/tech/static/math/ae8e52c9ff91d739a507e91fb1b70c27cf2af9a8.png]]。数学公式的显示使用MathJax，缺省情况下，MathJax从网络上下载，如果希望离线使用它，需要在IPython
Notebook中输入如下代码，把MathJax安装到本地磁盘中：

#+BEGIN_EXAMPLE
    from IPython.external.mathjax import install_mathjax
    install_mathjax()
#+END_EXAMPLE

Code单元的输出也可以显示为数学公式，例如在单元中输入如下代码，将显示为数学公式：

#+BEGIN_EXAMPLE
    from IPython.display import Latex
    Latex(r"$\sqrt{x^2+y^2}$")
#+END_EXAMPLE

[[/tech/static/math/8e7330cd9a445a585420f18a9d11cd97487620fb.png]]

SymPy的表达式也可以显示为LaTex，例如：

#+BEGIN_EXAMPLE
    %load_ext sympyprinting
    from sympy import *
    x, y = symbols("x,y")
    sqrt(x**2+y**2)
#+END_EXAMPLE

[[/tech/static/math/e8fc92a726c6078a31066d0d8c90589f872b4927.png]]

以%开头的为IPython的命令(Magic
Command)，这里通过%load_ext命令载入sympyprinting扩展插件，载入此插件之后，所有的SymPy表达式都显示为数学公式。

*** 各种显示[[#id2][¶]]

IPython.display模块中提供了许多显示Python返回值的类，例如下面的代码用Image类显示”python.png”图片，缺省路径为Notebook文件所在的目录：

#+BEGIN_EXAMPLE
    from IPython.display import Image
    Image(filename="python.png")
#+END_EXAMPLE

Image还可以用来显示表示图像的字符串。例如下面的代码通过cv2的imencode()将NumPy数组转换为一个表示PNG图像数据的数组，然后将此数组转换为字符串之后通过Image()将显示为图像：

#+BEGIN_EXAMPLE
    import cv2
    import numpy as np
    from IPython.display import Image
    img = np.random.randint(0,255,(250,250,3))
    cv2.blur(img, (11,11), img)
    r, dat = cv2.imencode(".png",img)
    Image(dat.tostring())
#+END_EXAMPLE

[[/tech/static/uploads/attachs.file/bb/attachs.file.bb603f00e2af3231.6f70656e63765f696d6167652e706e67.png]]

此外，还可以通过HTML和Javascript将Python代码的输出显示为Html，或者作为Javascript运行。

#+BEGIN_EXAMPLE
    from IPython.display import Javascript
    Javascript("alert('ok')")
#+END_EXAMPLE

将在浏览器中运行Javascript代码。

*** Magic命令[[#magic][¶]]

IPython中Magic命令有两种执行方式，以%开始的命令被称为行命令，它只对单行有效，以%%开头的为单元命令，它放在单元的第一行，对整个单元有效。例如*timeit*命令可以快速测试代码的执行效率，它可以作为行命令或者单元命令。

#+BEGIN_EXAMPLE
    %timeit 1 + 1
    %timeit 1.0 + 1.0
    %timeit "1" + "1"
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    10000000 loops, best of 3: 52 ns per loop
    10000000 loops, best of 3: 53.4 ns per loop
    10000000 loops, best of 3: 50.9 ns per loop
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    %%timeit
    s = 0
    for i in xrange(100):
        s += i
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    100000 loops, best of 3: 11 us per loop
#+END_EXAMPLE

每个Magic命令都可以指定参数，可以输入=timeit?=查看其帮助文档。下面让我们看看一些常用的Magic命令。

*%pylab*命令将载入numpy和pylab，并且将这两个模块中的名字载入到全局名字空间中。缺省参数时，它使用matplotlib的缺省界面库显示图表，如果带*inline*参数则将图表作为图像插入到Notebook中。使用界面库显示图像时可以使用交互工具，而将图表直接插入到Notebook中则有利于编写文档。

下面的例子，=plot=和=random=是从pylab和numpy中载入的。

#+BEGIN_EXAMPLE
    %pylab inline
    plot(random.randn(100));
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    Welcome to pylab, a matplotlib-based Python environment [backend: module://IPython.zmq.pylab.backend_inline].
    For more information, type 'help(pylab)'.
#+END_EXAMPLE

[[/tech/static/uploads/attachs.file/ae/attachs.file.ae67551cd095fdb0.70796c61625f696d672e706e67.png]]

*%load*可以从文件或者网址载入代码到一个新的单元中，例如下面载入某个matplotlib的示例程序，并执行：

#+BEGIN_EXAMPLE
    %load http://matplotlib.org/mpl_examples/pylab_examples/histogram_demo.py
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    #!/usr/bin/env python
    import numpy as np
    import matplotlib.mlab as mlab
    import matplotlib.pyplot as plt

    mu, sigma = 100, 15
    x = mu + sigma*np.random.randn(10000)

    # the histogram of the data
    n, bins, patches = plt.hist(x, 50, normed=1, facecolor='green', alpha=0.75)

    # add a 'best fit' line
    y = mlab.normpdf( bins, mu, sigma)
    l = plt.plot(bins, y, 'r--', linewidth=1)

    plt.xlabel('Smarts')
    plt.ylabel('Probability')
    plt.title(r'$\mathrm{Histogram\ of\ IQ:}\ \mu=100,\ \sigma=15$')
    plt.axis([40, 160, 0, 0.03])
    plt.grid(True)

    plt.show()
#+END_EXAMPLE

[[/tech/static/uploads/attachs.file/b0/attachs.file.b0e4f94453ee2ff0.686973745f696d672e706e67.png]]

*%prun*用于代码的执行性能分析，可以作为行命令和单元命令使用。下面的程序分析=numpy.linalg.det()=的性能：

#+BEGIN_EXAMPLE
    %%prun
    for i in xrange(100):
        linalg.det(random.rand(10,10))
#+END_EXAMPLE

其输出如下：

#+BEGIN_EXAMPLE
    3402 function calls in 0.096 seconds

    Ordered by: internal time

    ncalls  tottime  percall  cumtime  percall filename:lineno(function)
       100    0.032    0.000    0.091    0.001 linalg.py:1560(slogdet)
       300    0.022    0.000    0.022    0.000 {method 'reduce' of 'numpy.ufunc' objects}
       200    0.011    0.000    0.012    0.000 numeric.py:167(asarray)
       100    0.006    0.000    0.006    0.000 linalg.py:84(_realType)
       100    0.005    0.000    0.005    0.000 linalg.py:151(_assertRank2)
       ...
#+END_EXAMPLE

*%load_ext*载入IPython的扩展模块，通过它可以载入更多的Magic命令。下面我们载入*cythonmagic*模块，并使用*%%cython*命令编译一个高效的频率统计函数=count()=。

#+BEGIN_EXAMPLE
    %load_ext cythonmagic
#+END_EXAMPLE

*** 测试Cython代码[[#cython][¶]]

Cython的代码基本和Python的代码类似，但是可以使用类型声明，Cython可以使用这些类型声明产生更高效的C语言代码，并编译成Python的扩展模块。使用*%%cython*命令简化了编译扩展模块的过程，它会自动创建C语言程序，编译并载入。由于扩展模块无法卸载，因此IPython采用的策略是每次编译不同的代码都会产生一个全新的扩展模块。方便我们不退出Python环境即可运行新的代码。

#+BEGIN_EXAMPLE
    %%cython
    def count(list data):
        cdef:
            dict result = {}
            int i, length = len(data)
            object item

        for i in range(length):
            item = data[i]
            if item in result:
                (<list> result[item]).append(i)
            else:
                result[item] = [i]
        return result
#+END_EXAMPLE

下面是=count()=的Python版本。

#+BEGIN_EXAMPLE
    from collections import defaultdict
    def countpy(data):
        result = defaultdict(list)
        for i,item in enumerate(data):
            result[item].append(i)
        return result
#+END_EXAMPLE

先测试二者的结果是否相同：

#+BEGIN_EXAMPLE
    import random
    data = [random.randint(0,100) for _ in xrange(10000)]
    count(data) == countpy(data)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    True
#+END_EXAMPLE

然后测试它们的执行速度，可以看出Cython版本比Python的要快2倍多。在这个测试中，Cython程序也同样使用列表和字典等对象，但是由于可以直接调用Python的C
API，因此Cython版本的效率能提高几倍。如果只是单纯的数值运算，Cython能将程序提升到与C语言相近的速度。

#+BEGIN_EXAMPLE
    %timeit countpy(data)
    %timeit count(data)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    100 loops, best of 3: 4.52 ms per loop
    1000 loops, best of 3: 1.8 ms per loop
#+END_EXAMPLE

** [[http://my.oschina.net/jayzonex/blog/13579?fromerr=1K6znGs4][74HC573锁存器用法]]

[[http://www.oschina.net/search?scope=blog&q=74HC573][74HC573]]
[[http://www.oschina.net/search?scope=blog&q=%E9%94%81%E5%AD%98%E5%99%A8][锁存器]]

锁存器 介绍

如果单片机的总线接口只作一种用途，不需要接锁存器；如果单片机的总线接口要作两种用途，就要用两个锁存器。例如：一个口要控制两个
LED，对第一个 LED
送数据时，“打开”第一个锁存器而“锁住”第二个锁存器，使第二个 LED
上的数据不变。对第二个 LED
送数据时，“打开”第二个锁存器而“锁住”第一个锁存器，使第一个 LED
上的数据不变。如果单片机的一个口要做三种用途，则可用三个锁存器，操作过程相似。然而在实际应用中，我们并不这样做，只用一个锁存器就可以了，并用一根
I/O 口线作为对锁存器的控制之用（接 74373
的ＬＥ，而ＯＥ可恒接地）。所以，就这一种用法而言，可以把锁存器视为单片机的
I/O 口的扩展器。
 更多信息请看 http://baike.baidu.com/view/629932.htm?fr=ala0_1_1
 74hc573 引脚图

[[http://my.oschina.net/uploads/space/2011/0224/141233_KOut_105484.jpg]]

 1脚是输出使能
 11脚是锁存使能
 D是输入
 Q是输出
 Ｈ是高电平，L是低
 /OE是1脚 LE是11脚
 /OE 接低电平，使芯片内部数据保持器输出端与芯片8位输出端之间连通。
 LE
端的作用是通过高低电平控制8位输入与内部数据保持器输入端的连通与断开。
 当 LE = 0 时，P0端口的8位数据线与74HC573内部数据保持器的输入端断开。
 当 LE = 1 时，P0端口的8位数据线与74HC573内部数据保持器的输入端连通

** [[http://blog.sina.com.cn/s/blog_57132a730100phfw.html][定义自己的浮动体]]

对于浮动体的认识，很多初学者觉得比较困难，主要是平时接触不到这个概念。
浮动体可以比作是一个可以在文章里移动的盒子，不同的盒子里面放的东西略有差异。为什么移动？这个问题很多朋友询问，说简单点，就是为了排版的美观。为什么浮动（移动）了就可以排版得美观了。
    在使用字处理软件排版时，使用者可以让图形准确出现在放置的位置。但是，因为这些图形不能被分割开来，所以经常会导致糟糕的分页，将大片的空白留在页面下方。为得到专家级的排版效果，作者不得不手工调整图形的位置。这种工作是非常乏味的，尤其是几乎每次修改文档都得这样做一次。
    为了既能得到专家级的排版效果，又不必手工做调整图形位置的乏味的工作， LATEX 提供了一个浮动图形机制来自动将图形放置到合适的位置。这一机制是非常有效的。不过，它也会给那些习惯于手工调整图形的新手带来麻烦。
---选自《latex插图指南》
另外，它还有其他好处：
1.在浮动环境中，图片或者表格等等需要浮动的内容可以自动编号。
2.浮动体内容可以被引用和放入目录中。
3.排版更加美观。

如何创建一个自己的浮动环境呢？
如下示例：
documentclass[12pt]{article}
usepackage{float}
newfloat{Eq}{H}{eqn}
begin{document}
begin{Eq}
begin{equation}
y=f(x)
end{equation}
caption{my first equation}
end{Eq}
begin{Eq}
begin{equation}
y=f(x) end{equation}
caption{my second equation}
end{Eq}
listof{Eq}{list of  equations}

end{document}

** [[http://linuxtools-rst.readthedocs.org/zh_CN/latest/tool/crontab.html][crontab 定时任务[[#crontab][¶]]]]

通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell
script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。

*** 19.1. 命令格式[[#id2][¶]]

crontab [-u user] [ -e | -l | -r ]

*** 19.2. 命令参数[[#id3][¶]]

-  -u user：用来设定某个用户的crontab服务；
-  file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。
-  -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。
-  -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。
-  -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。
-  -i：在删除用户的crontab文件时给确认提示。

*** 19.3. crontab的文件格式[[#id4][¶]]

分 时 日 月 星期 要运行的命令

-  第1列分钟1～59
-  第2列小时1～23（0表示子夜）
-  第3列日1～31
-  第4列月1～12
-  第5列星期0～6（0表示星期天）
-  第6列要运行的命令

*** 19.4. 常用方法[[#id5][¶]]

**** 创建一个新的crontab文件[[#id6][¶]]

向cron进程提交一个crontab文件之前，首先要设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。9
9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$HOME目录下的.
profile文件，在其中加入这样一行:

#+BEGIN_EXAMPLE
    EDITOR=vi; export EDITOR
#+END_EXAMPLE

然后保存并退出。不妨创建一个名为<user>
cron的文件，其中<user>是用户名，例如，
davecron。在该文件中加入如下的内容。

#+BEGIN_EXAMPLE
    # (put your own initials here)echo the date to the console every
    # 15minutes between 6pm and 6am
    0,15,30,45 18-06 * * * /bin/echo 'date' > /dev/console
#+END_EXAMPLE

保存并退出。注意前面5个域用空格分隔。

在上面的例子中，系统将每隔1
5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数:

#+BEGIN_EXAMPLE
    $ crontab davecron
#+END_EXAMPLE

现在该文件已经提交给cron进程，它将每隔1
5分钟运行一次。同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。

**** 列出crontab文件[[#id7][¶]]

使用-l参数列出crontab文件:

#+BEGIN_EXAMPLE
    $ crontab -l
    0,15,30,45,18-06 * * * /bin/echo `date` > dev/tty1
#+END_EXAMPLE

可以使用这种方法在$HOME目录中对crontab文件做一备份:

#+BEGIN_EXAMPLE
    $ crontab -l > $HOME/mycron
#+END_EXAMPLE

这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。

**** 编辑crontab文件[[#id8][¶]]

如果希望添加、删除或编辑crontab文件中的条目，而EDITOR环境变量又设置为vi，那么就可以用vi来编辑crontab文件:

#+BEGIN_EXAMPLE
    $ crontab -e
#+END_EXAMPLE

可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时，
cron会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。
我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：

#+BEGIN_EXAMPLE
    # DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month
    30 3 1,7,14,21,26 * * /bin/find -name 'core' -exec rm {} \;
#+END_EXAMPLE

保存并退出。

注解

最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的定时作业。

**** 删除crontab文件[[#id9][¶]]

#+BEGIN_EXAMPLE
    $crontab -r
#+END_EXAMPLE

*** 19.5. 使用实例[[#id10][¶]]

**** 实例1：每1分钟执行一次myCommand[[#mycommand][¶]]

#+BEGIN_EXAMPLE
    * * * * * myCommand
#+END_EXAMPLE

**** 实例2：每小时的第3和第15分钟执行[[#id11][¶]]

#+BEGIN_EXAMPLE
    3,15 * * * * myCommand
#+END_EXAMPLE

**** 实例3：在上午8点到11点的第3和第15分钟执行[[#id12][¶]]

#+BEGIN_EXAMPLE
    3,15 8-11 * * * myCommand
#+END_EXAMPLE

**** 实例4：每隔两天的上午8点到11点的第3和第15分钟执行[[#id13][¶]]

#+BEGIN_EXAMPLE
    3,15 8-11 */2  *  * myCommand
#+END_EXAMPLE

**** 实例5：每周一上午8点到11点的第3和第15分钟执行[[#id14][¶]]

#+BEGIN_EXAMPLE
    3,15 8-11 * * 1 myCommand
#+END_EXAMPLE

**** 实例6：每晚的21:30重启smb[[#smb][¶]]

#+BEGIN_EXAMPLE
    30 21 * * * /etc/init.d/smb restart
#+END_EXAMPLE

**** 实例7：每月1、10、22日的4 : 45重启smb[[#id15][¶]]

#+BEGIN_EXAMPLE
    45 4 1,10,22 * * /etc/init.d/smb restart
#+END_EXAMPLE

**** 实例8：每周六、周日的1 : 10重启smb[[#id16][¶]]

#+BEGIN_EXAMPLE
    10 1 * * 6,0 /etc/init.d/smb restart
#+END_EXAMPLE

**** 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb[[#id17][¶]]

#+BEGIN_EXAMPLE
    0,30 18-23 * * * /etc/init.d/smb restart
#+END_EXAMPLE

**** 实例10：每星期六的晚上11 : 00 pm重启smb[[#pmsmb][¶]]

#+BEGIN_EXAMPLE
    0 23 * * 6 /etc/init.d/smb restart
#+END_EXAMPLE

**** 实例11：每一小时重启smb[[#id18][¶]]

#+BEGIN_EXAMPLE
    * */1 * * * /etc/init.d/smb restart
#+END_EXAMPLE

**** 实例12：晚上11点到早上7点之间，每隔一小时重启smb[[#id19][¶]]

#+BEGIN_EXAMPLE
    * 23-7/1 * * * /etc/init.d/smb restart
#+END_EXAMPLE

*** 19.6. 使用注意事项[[#id20][¶]]

**** 注意环境变量问题[[#id21][¶]]

有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。

在crontab文件中定义多个调度任务时，需要特别注环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。

不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：

1. 脚本中涉及文件路径时写全局路径；

2. 脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如:

   #+BEGIN_EXAMPLE
       cat start_cbp.sh
       !/bin/sh
       source /etc/profile
       export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf
       /usr/local/jboss-4.0.5/bin/run.sh -c mev &
   #+END_EXAMPLE

3）当手动执行脚本OK，但是crontab死活不执行时,很可能是环境变量惹的祸，可尝试在crontab中直接引入环境变量解决问题。如:

#+BEGIN_EXAMPLE
    0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh
#+END_EXAMPLE

**** 注意清理系统用户的邮件日志[[#id22][¶]]

每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。
例如，可以在crontab文件中设置如下形式，忽略日志输出:

#+BEGIN_EXAMPLE
    0 */3 * * * /usr/local/apache2/apachectl restart >/dev/null 2>&1
#+END_EXAMPLE

“/dev/null
2>&1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。

**** 系统级任务调度与用户级任务调度[[#id23][¶]]

系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过”crontab
--uroot
--e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。

**** 其他注意事项[[#id24][¶]]

新创建的cron
job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。

当crontab失效时，可以尝试/etc/init.d/crond
restart解决问题。或者查看日志看某个job有没有执行/报错tail -f
/var/log/cron。

千万别乱运行crontab
-r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。

在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date
‘+%Y%m%d'在crontab里是不会执行的，应该换成date ‘+%Y%m%d'。

更新系统时间时区后需要重启cron,在ubuntu中服务名为cron:

#+BEGIN_EXAMPLE
    $service cron restart
#+END_EXAMPLE

ubuntu下启动、停止与重启cron:

#+BEGIN_EXAMPLE
    $sudo /etc/init.d/cron start
    $sudo /etc/init.d/cron stop
    $sudo /etc/init.d/cron restart
#+END_EXAMPLE

** [[http://www.cnblogs.com/rollenholt/archive/2012/04/23/2466179.html][关于python文件操作]]

2012-04-23 11:28 by Rollen Holt, ... 阅读, ... 评论, [[#][收藏]],
[[http://i.cnblogs.com/EditPosts.aspx?postid=2466179][编辑]]

总是记不住API。昨晚写的时候用到了这些，但是没记住，于是就索性整理一下吧：

*python中对文件、文件夹**（文件操作函数）**的操作需要涉及到os模块和shutil模块。*

得到当前工作目录，即当前Python脚本工作的目录路径: *os.getcwd()*

返回指定目录下的所有文件和目录名:*os.listdir()*

函数用来删除一个文件:*os.remove()*

删除多个目录：*os.removedirs（r“c：\python”）*

检验给出的路径是否是一个文件：*os.path.isfile()*

检验给出的路径是否是一个目录：*os.path.isdir()*

判断是否是绝对路径：*os.path.isabs()*

检验给出的路径是否真地存:*os.path.exists()*

返回一个路径的目录名和文件名:*os.path.split() *  eg
os.path.split('/home/swaroop/byte/code/poem.txt')
结果：('/home/swaroop/byte/code', 'poem.txt')

分离扩展名：*os.path.splitext()*

获取路径名：*os.path.dirname()*

获取文件名：*os.path.basename()*

运行shell命令: *os.system()*

读取和设置环境变量:*os.getenv() 与os.putenv()*

给出当前平台使用的行终止符:*os.linesep *Windows使用'\r\n'，Linux使用'\n'而Mac使用'\r'

指示你正在使用的平台：*os.name *
对于Windows，它是'nt'，而对于Linux/Unix用户，它是'posix'

重命名：*os.rename（old， new）*

创建多级目录：*os.makedirs（r“c：\python\test”）*

创建单个目录：*os.mkdir（“test”）*

获取文件属性：*os.stat（file）*

修改文件权限与时间戳：*os.chmod（file）*

终止当前进程：*os.exit（）*

获取文件大小：*os.path.getsize（filename）*

*文件操作：*
*os.mknod("test.txt") *  创建空文件
*fp = open("test.txt",w) *  直接打开一个文件，如果文件不存在则创建文件

关于open 模式：

w 以写方式打开，
a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)
r+ 以读写模式打开
w+ 以读写模式打开 (参见 w )
a+ 以读写模式打开 (参见 a )
rb 以二进制读模式打开
wb 以二进制写模式打开 (参见 w )
ab 以二进制追加模式打开 (参见 a )
rb+ 以二进制读写模式打开 (参见 r+ )
wb+ 以二进制读写模式打开 (参见 w+ )
ab+ 以二进制读写模式打开 (参见 a+ )



*fp.read([size]) * #size为读取的长度，以byte为单位

*fp.readline([size]) *
#读一行，如果定义了size，有可能返回的只是一行的一部分

*fp.readlines([size]) *
#把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。

*fp.write(str) / /*
#把str写到文件中，write()并不会在str后加上一个换行符

*fp.writelines(seq) *
#把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。

*fp.close() *
#关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。
如果一个文件在关闭后还对其进行操作会产生ValueError

*fp.flush() *
#把缓冲区的内容写入硬盘

*fp.fileno() *
#返回一个长整型的”文件标签“

*fp.isatty() *
#文件是否是一个终端设备文件（unix系统中的）

*fp.tell()*
#返回文件操作标记的当前位置，以文件的开头为原点

*fp.next()    *
#返回下一行，并将文件操作标记位移到下一行。把一个file用于for ... in
file这样的语句时，就是调用next()函数来实现遍历的。

*fp.seek(offset[,whence]) *
#将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。

*fp.truncate([size]) *
#把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。



*目录操作：*
*os.mkdir("file") *  创建目录
复制文件：
*shutil.copyfile("oldfile","newfile") *
oldfile和newfile都只能是文件
*shutil.copy("oldfile","newfile") *
oldfile只能是文件夹，newfile可以是文件，也可以是目标目录
复制文件夹：
*shutil.copytree("olddir","newdir") *
olddir和newdir都只能是目录，且newdir必须不存在
重命名文件（目录）
*os.rename("oldname","newname") *  文件或目录都是使用这条命令
移动文件（目录）
*shutil.move("oldpos","newpos")  *
删除文件
*os.remove("file")*
删除目录
*os.rmdir("dir")*只能删除空目录
*shutil.rmtree("dir")  *  空目录、有内容的目录都可以删
转换目录
*os.chdir("path")  *换路径



*相关例子 *

 1 *将文件夹下所有图片名称加上'_fc'

*/python代码:/*

# -*- coding:utf-8 -*-
import re
import os
import time
#str.split(string)分割字符串
#'连接符'.join(list) 将列表组成字符串
def change_name(path):
  global i
  if not os.path.isdir(path) and not os.path.isfile(path):
  return False
  if os.path.isfile(path):
  file_path = os.path.split(path) #分割出目录与文件
  lists = file_path[1].split('.') #分割出文件与文件扩展名
  file_ext = lists[-1] #取出后缀名(列表切片操作)
  img_ext = ['bmp','jpeg','gif','psd','png','jpg']
  if file_ext in img_ext:
  os.rename(path,file_path[0]+'/'+lists[0]+'_fc.'+file_ext)
  i+=1 #注意这里的i是一个陷阱
  #或者
  #img_ext = 'bmp|jpeg|gif|psd|png|jpg'
  #if file_ext in img_ext:
  #  print('ok---'+file_ext)
  elif os.path.isdir(path):
  for x in os.listdir(path):

change_name(os.path.join(path,x)) #os.path.join()在路径处理上很有用

img_dir = 'D:\\xx\\xx\\images'
img_dir = img_dir.replace('\\','/')
start = time.time()
i = 0
change_name(img_dir)
c = time.time() - start
print('程序运行耗时:%0.2f'%(c))
print('总共处理了 %s 张图片'%(i))

输出结果：

程序运行耗时:0.11
总共处理了 109 张图片

** [[http://www.wklken.me/posts/2015/03/03/python-base-datetime.html#1-datetime][Python-基础-时间日期处理小结]]

好久没写文了, 继续清理笔记, 都是一些小结之类的,
源码分析以及在做系统中一些细节难点等, 后续逐步发

另外打个广告, [[http://www.itianpin.com/join][甜品礼物]], 坐标深圳,
有兴趣的同学可以给我发邮件, 非python职位会转到对应同事:)

#+BEGIN_EXAMPLE
          _       _       _   _
         | |     | |     | | (_)
       __| | __ _| |_ ___| |_ _ _ __ ___   ___
      / _` |/ _` | __/ _ \ __| | '_ ` _ \ / _ \
     | (_| | (_| | ||  __/ |_| | | | | | |  __/
      __,_|__,_|_____|__|_|_| |_| |_|___|
#+END_EXAMPLE

--------------

原则, 以=datetime=为中心, 起点或中转, 转化为目标对象,
涵盖了大多数业务场景中需要的日期转换处理

步骤:

#+BEGIN_EXAMPLE
    1. 掌握几种对象及其关系
    2. 了解每类对象的基本操作方法
    3. 通过转化关系转化
#+END_EXAMPLE

*** 涉及对象

**** 1. datetime

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> now = datetime.datetime.now()
    >>> now
    datetime.datetime(2015, 1, 12, 23, 9, 12, 946118)
    >>> type(now)
    <type 'datetime.datetime'>
#+END_EXAMPLE

**** 2. timestamp

#+BEGIN_EXAMPLE
    >>> import time
    >>> time.time()
    1421075455.568243
#+END_EXAMPLE

**** 3. time tuple

#+BEGIN_EXAMPLE
    >>> import time
    >>> time.localtime()
    time.struct_time(tm_year=2015, tm_mon=1, tm_mday=12, tm_hour=23, tm_min=10, tm_sec=30, tm_wday=0, tm_yday=12, tm_isdst=0)
#+END_EXAMPLE

**** 4. string

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    '2015-01-12 23:13:08'
#+END_EXAMPLE

**** 5. date

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().date()
    datetime.date(2015, 1, 12)
#+END_EXAMPLE

*** datetime基本操作

***** 1. 获取当前datetime

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now()
    datetime.datetime(2015, 1, 12, 23, 26, 24, 475680)
#+END_EXAMPLE

***** 2. 获取当天date

#+BEGIN_EXAMPLE
    >>> datetime.date.today()
    datetime.date(2015, 1, 12)
#+END_EXAMPLE

***** 3. 获取明天/前N天

明天

#+BEGIN_EXAMPLE
    >>> datetime.date.today() + datetime.timedelta(days=1)
    datetime.date(2015, 1, 13)
#+END_EXAMPLE

三天前

#+BEGIN_EXAMPLE
    >>> datetime.datetime.now()
    datetime.datetime(2015, 1, 12, 23, 38, 55, 492226)
    >>> datetime.datetime.now() - datetime.timedelta(days=3)
    datetime.datetime(2015, 1, 9, 23, 38, 57, 59363)
#+END_EXAMPLE

***** 4. 获取当天开始和结束时间(00:00:00 23:59:59)

#+BEGIN_EXAMPLE
    >>> datetime.datetime.combine(datetime.date.today(), datetime.time.min)
    datetime.datetime(2015, 1, 12, 0, 0)
    >>> datetime.datetime.combine(datetime.date.today(), datetime.time.max)
    datetime.datetime(2015, 1, 12, 23, 59, 59, 999999)
#+END_EXAMPLE

***** 5. 获取两个datetime的时间差

#+BEGIN_EXAMPLE
    >>> (datetime.datetime(2015,1,13,12,0,0) - datetime.datetime.now()).total_seconds()
    44747.768075
#+END_EXAMPLE

***** 6. 获取本周/本月/上月最后一天

本周

#+BEGIN_EXAMPLE
    >>> today = datetime.date.today()
    >>> today
    datetime.date(2015, 1, 12)
    >>> sunday = today + datetime.timedelta(6 - today.weekday())
    >>> sunday
    datetime.date(2015, 1, 18)
#+END_EXAMPLE

本月

#+BEGIN_EXAMPLE
    >>> import calendar
    >>> today = datetime.date.today()
    >>> _, last_day_num = calendar.monthrange(today.year, today.month)
    >>> last_day = datetime.date(today.year, today.month, last_day_num)
    >>> last_day
    datetime.date(2015, 1, 31)
#+END_EXAMPLE

获取上个月的最后一天(可能跨年)

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> today = datetime.date.today()
    >>> first = datetime.date(day=1, month=today.month, year=today.year)
    >>> lastMonth = first - datetime.timedelta(days=1)
#+END_EXAMPLE

*** 关系转换

几个关系之间的转化

=Datetime Object / String / timestamp / time tuple=

*** 关系转换例子

***** datetime <=> string

datetime -> string

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    '2015-01-12 23:13:08'
#+END_EXAMPLE

string -> datetime

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.strptime("2014-12-31 18:20:10", "%Y-%m-%d %H:%M:%S")
    datetime.datetime(2014, 12, 31, 18, 20, 10)
#+END_EXAMPLE

--------------

***** datetime <=> timetuple

datetime -> timetuple

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().timetuple()
    time.struct_time(tm_year=2015, tm_mon=1, tm_mday=12, tm_hour=23, tm_min=17, tm_sec=59, tm_wday=0, tm_yday=12, tm_isdst=-1)
#+END_EXAMPLE

timetuple -> datetime

#+BEGIN_EXAMPLE
    timetuple => timestamp => datetime [看后面datetime<=>timestamp]
#+END_EXAMPLE

--------------

***** datetime <=> date

datetime -> date

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().date()
    datetime.date(2015, 1, 12)
#+END_EXAMPLE

date -> datetime

#+BEGIN_EXAMPLE
    >>> datetime.date.today()
    datetime.date(2015, 1, 12)
    >>> today = datetime.date.today()
    >>> datetime.datetime.combine(today, datetime.time())
    datetime.datetime(2015, 1, 12, 0, 0)
    >>> datetime.datetime.combine(today, datetime.time.min)
    datetime.datetime(2015, 1, 12, 0, 0)
#+END_EXAMPLE

--------------

***** datetime <=> timestamp

datetime -> timestamp

#+BEGIN_EXAMPLE
    >>> now = datetime.datetime.now()
    >>> timestamp = time.mktime(now.timetuple())
    >>> timestamp
    1421077403.0
#+END_EXAMPLE

timestamp -> datetime

#+BEGIN_EXAMPLE
    >>> datetime.datetime.fromtimestamp(1421077403.0)
    datetime.datetime(2015, 1, 12, 23, 43, 23)
#+END_EXAMPLE

** [[http://www.cyberciti.biz/howto/question/general/linux-unix-list-common-environment-variables.php][Linux/UNIX list of common environment variables]]

Environment variables are a variable key pair stored in the shell's
environment space. Here is a list of common environment variables:

| *Variable*          | *Description*                                                                          |
| HISTFILE            | The name of the file in which command history is saved                                 |
| HISTFILESIZE        | The maximum number of lines contained in the history file                              |
| HOSTNAME            | The system's host name                                                                 |
| LD_LIBRARY_PATH   | It is a colon-separated set of directories where libraries should be searched for      |
| PS1                 | Your default (first) shell prompt                                                      |
| USER                | Current logged in user's name.                                                         |
| PATH                | Colon separated list of directories to search for binaries.                            |
| DISPLAY             | Network name of the X11 display to connect to, if available.                           |
| SHELL               | The current shell.                                                                     |
| TERM                | The name of the user's terminal. Used to determine the capabilities of the terminal.   |
| TERMCAP             | Database entry of the terminal escape codes to perform various terminal functions.     |
| OSTYPE              | Type of operating system.                                                              |
| MACHTYPE            | The CPU architecture that the system is running on.                                    |
| EDITOR              | The user's preferred text editor.                                                      |
| PAGER               | The user's preferred text pager.                                                       |
| MANPATH             | Colon separated list of directories to search for manual pages.                        |

** [[http://www.programgo.com/article/30302508918/][树莓派(raspberry pi) 系统在SD卡上安装Linux]]

*标签*:
[[/tag/android/748055864/;jsessionid=EFDE80EBE83A01CC45841A76E59F8D40][android系统手机的sd卡分区教程]]
[[/tag/android/610167617/;jsessionid=EFDE80EBE83A01CC45841A76E59F8D40][raspberry
pi android]]
[[/tag/android/877413287/;jsessionid=EFDE80EBE83A01CC45841A76E59F8D40][android系统sd卡分区教程]]

*转自*:
[[http://blog.csdn.net/berryreload/article/details/7983713][http://blog.csdn.net/berryreload/article/details/7983713]]

刚刚拿到一只Simon同学出借的树莓派(raspberry pi)
，准备一张4GB的SD卡，准备跑一下Linux。

在Windows 7上用
工具 [[https://launchpad.net/win32-image-writer/+download][Win32DiskImager]]写入img到SD卡上，报错，失败。

好在俺有Linux vmware虚拟机，在虚拟机上搞，执行命令 sudo dd bs=1M
if=2012-12-16-wheezy-raspbian.img  of=/dev/sdb

tips:

错误：接电启动树莓派，派上只有红色的Power灯亮，HDMI电视机上没有输出。

原因：在Linux上执行dd命令的时候，应该是把操作系统镜像写到SD卡（硬盘上），而不是写到某个硬盘分区上。of=/dev/sdb
误写成of=/dev/sdb1了。

当时写完后，我还纳闷呢，怎么Linux
 fdisk上这个SD卡还显示只有一个vfat分区，而不是多个Linux分区呢。

解决办法：首先fdisk /dev/sdb，删除vfat分区；然后执行dd命令写入镜像  sudo
dd bs=1M if=2012-12-16-wheezy-raspbian.img of=/dev/sdb

#Raspian安装Chrome
1,wget http://goo.gl/go5yx -O install.sh
2,chmod a+x install.sh
3,./install.sh
4,chrome -disable-ipv6 & (& for running at background)
5,error loading libsmime3.so->try sudo apt-get update then redo step 3
#Raspian安装中文输入法SCIM (Smart Common Input Method)
1,sudo apt-get install scim-pinyin
2,if some packages can't be downloaded, try sudo apt-get update
---fix-missing
3,run scim and it will run wihle booting.
#切换到root
$ sudo -s

** [[http://jingyan.eeboard.com/article/14464][不同操作环境下如何将Raspbian安装到SD卡]]

作者： [[/user/349428][wuxingxing]]

上传时间为： 2012-09-06 11:13 PM

[[http://jingyan.eeboard.com/assets/img/watch-icon.png]]

[[http://jingyan.eeboard.com/assets/img/like-icon.png]]

[[http://jingyan.eeboard.com/assets/img/comment-icon.png]]

-  [[/category/17][树莓派]]

•

-  [[/tags/raspberry%20pi][]]

   * raspberry pi

-  [[/login?referer=http://jingyan.eeboard.com/article/14464][]]
-  [[/login?referer=http://jingyan.eeboard.com/article/14464][]]
-  分享
-  [[javascript:;][]]
   返回
   顶部

Raspberry Pi
已经出了一段时间，有相当多的方法将Raspbian安装到你的SD卡。无论你使用Windows，Mac
OS
X或Linux，这篇文章的目的，我们将用非常通用的方法来教你实现它。具体而言，我们将使用dd工具来实现。

 一、如果你使用的是Mac

为了简单起见，我们建议您先清除您的下载文件夹，然后再开始。Raspbian.zip文件可以从这个[[http://uk.rs-online.com/web/generalDisplay.html?id=raspberrypi][网址]]下载。一旦你解压映像软件文件后，你需要一个终端应用程序。假设你使用的是OS
X
10.7或更高版本，可以从应用程序启动它，一旦终端应用程序的启动运行，通过“cd〜/下载”命令来打开你的下载文件夹：

你现在应该有至少两个文件在您的下载文件夹中。通过键入"ls”来验证“img”文件和"zip”文件是否存在。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/raspbian-1/][[[http://www.eeboard.com/wp-content/uploads/2012/09/Raspbian-1.png]]]]

接下来让我们看看如何将镜像文件文件放到SD卡。首先，在插入SD卡之前我们需要了解设备的使用情况。

在终端应用程序中键入：“df-h”。您应该会看到一些像这样的输出：

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-2/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-2.jpg]]]]

现在，插入你的SD卡并重新运行上面的命令，并注意新的“/
dev/disk1s1”行。这个方便的 - 你需要将其转换为一个原始磁盘的名称。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-3/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-3.jpg]]]]

接下来，我们需要卸载该卷，“DD”工具可以将镜像写入SD卡。这可以通过“sudo
diskutil unmount/ dev/disk1s1”命令。你会得到提示输入系统密码，输入即可。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-4/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-4.jpg]]]]

您现在应该看到最后一行的“卸载卷XXX”，“XXX”是你的卡的名称。现在，我们终于可以将Raspbian.img文件写到SD卡上了。
现在是时候进行转换。无论你的磁盘命名如何（例如，/
dev/disk1s1），去掉“s1”，在“disk”前面加“r”，变成了“/ dev/rdisk1”。
所以，举例来说，“/ dev/disk1s1”=“/ dev/rdisk1”。

然后键入以下内容：“sudo dd bs=1m if=2012-06-15-wheezy-raspbian.img
of=/dev/ YOURDISKNAME"。替换为您的实际原始磁盘名称。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-5/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-5.jpg]]]]

这将需要一段时间来完成。我们可以用“dd”命令，通过将磁盘镜像拖到桌面垃圾箱进行SD卡的安全卸载。这样我们的准备工作就完成了！

二、如果你用的是Linux

无论你使用的是Linux发行版，请确保有“dd”的工具。 我们在这里假设：
1）有sudo的配置，并熟悉它。 2）安装了fdisk。

我们在Ubuntu进行了测试。从[[http://www.raspberrypi.org/downloads][这个位置]]下载Raspbian.zip文件压缩到你主目录并解压。

启动你的Linux机器上的终端，通过“cd”命令访问你的主目录。键入“unzip
imagename.zip”，您刚刚下载的镜像取代“imagename”。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-6/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-6.jpg]]]]

接下来，我们需要确定您的SD卡目前正在使用的设备名称。插入您的SD卡，输入“sudo
fdisk-L”。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-7/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-7.jpg]]]]

请注意上图中列出的设备

我们的设备是“sdb”，15.9GB的空间。请记下“/ dev /
sdb”下面列出的设备，为了安全写入镜像你要卸载他们。我们看到“/
dev/sdb1”和“/ dev/sdb2”，所以我们运行： sudo umount/ dev/sdb1

sudo umount / dev/sdb2

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-8/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-8.jpg]]]]

现在用“dd”工具来写入我们镜像。键入“sudo dd bs
=1M=2012-08-16-wheezy-raspbian.img of= / dev /
sdb”。和上面Mac环境下一样，这将需要几分钟的时间才能完成。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-9/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-9.jpg]]]]

如果你看到如上图所示，那就成功了！

三、在 Windows环境下

先在Windows系统里安装Win32DiskImager应用程序，Win32DiskImager你可以在[[http://www.softpedia.com/get/CD-DVD-Tools/Data-CD-DVD-Burning/Win32-Disk-Imager.shtml][这里]]或[[https://launchpad.net/win32-image-writer][这里]]下载。下载好以后我们继续下载Raspbian镜像，从[[http://www.raspberrypi.org/downloads][这个地方]]下载。

Win32DiskImager和Raspbian下载完成后，我们需要解压缩。为了方便，将这两个文件放到桌面上或一个文件夹里。接着将win32diskimager-binary.zip和2012-08-16-wheezy-raspbian.zip两个文件解压缩。

然后将SD卡插入读卡连接到电脑，双击Win32DiskImager。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-10/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-10.jpg]]]]

Win32DiskImager加载的时候你会看到一个错误（在Windows 7环境下），如下图：

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-11/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-11.jpg]]]]

单击“确定”，应用程序将继续加载。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-12/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-12.jpg]]]]

点击蓝色的文件夹图标，选择Raspbian镜像文件，并确保列出的设备名称与SD卡驱动器盘符相同。

打开你的镜像文件，单击“Write”，“Yes”确认，然后稍等一会。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-13/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-13.jpg]]]]

当镜像写好后，会弹出下图窗口，接下来你就可以安全退出你的SD卡了。

[[http://www.eeboard.com/tutorials/%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e5%b0%86raspbian%e5%ae%89%e8%a3%85%e5%88%b0sd%e5%8d%a1/attachment/neo_img_raspbian-14/][[[http://www.eeboard.com/wp-content/uploads/2012/09/nEO_IMG_Raspbian-14.jpg]]]]

如果你在你的SD卡在写镜像的过程中卡住了，你可以来[[http://elinux.org/RPi_Easy_SD_Card_Setup][这里]]寻求解决办法。


** [[https://linuxtoy.org/archives/cv.html][cv: 显示 cp、mv等命令的进度]]

2014-07-14 By [[https://linuxtoy.org/author/toy.html][toy]] Posted in
[[https://linuxtoy.org/category/apps.html][Apps]] Edit on
[[https://github.com/xuxiaodong/linuxtoy.org/blob/master/content/cv.md][GitHub]]

在 Linux 系统中，大多数命令从来都是信奉“沉默是金”的准则，所以当我们利用
=cp=
复制文件的时候并不能看到所谓的进度条。如果你在意这一点，那么不妨来用用
[[https://github.com/Xfennec/cv][cv]]。

[[https://linuxtoy.org/img/2014/07/cv.png]]

cv 是 Coreutils
Viewer，它能够显示传输数据的进度，包括百分比、大小、以及速率等信息。cv
支持 coreutils 中的基本命令，比如 cp、mv、rm、dd、tar 等等。

cv 的源代码可从 [[https://github.com/Xfennec/cv][GitHub]]
获取，需要自行编译。

** [[http://blog.csdn.net/shendayjy/article/details/10281131][ubuntu 桌面重命名]]

刚安装上Ubuntu8.04的时候，不懂得怎么修改Firefox下载文件保存的位置，默认是在桌面。但下载下来要在终端上使用文件就必须进入桌面。但桌面所在文件夹是“桌面”，习惯了用终端进行操作，但是在终端打中文比较麻烦，尤其是刚开始，自己的Ubuntu连汉语输入都还没有，所以我就想把此文件夹重命名为“Desktop”但是注销之后桌面文件夹就被默认为用户文件夹maximus了，用户目录下的所有文件及文件夹都跑到桌面了，很郁闷。Google了一下，发现桌面的文件夹是可以任意设置的，修改
/home/maximus(我的用户名)/.config/user-dirs.dirs里面的
XDG_DESKTOP_DIR="$HOME/Desktop" 这一项就好了
例如XDG_DESKTOP_DIR="$HOME/Desktop" 这个就是把用户的桌面设置在Desktop文件夹下
要把桌面设置在“视频”文件夹下就可以这样修改：
XDG_DESKTOP_DIR="$HOME/视频"
其他的各个项也都可以类似的设置。

** [[http://blog.chinaunix.net/uid-20804763-id-68083.html][LaTeX命令速查手册]]

分类：

+---------------------------------+
|TeX各版本概述及基本约定，特殊字符|
+---------------------------------+

tex提供300多条基本排版命令
由D.E.Knuth1978年开发
plain tex：在tex基础上新定义600多条复合命令
AMS-TEX：美国数学会开发（amsmath宏包）排版的数学公式
LATEX：L.Lamport（1985）编写，适合排版普通文章和书籍
LATEX2e：可加载amsmath宏包，目前最流行的TEX宏包
版本：LATEX2.09-->LATEX2e-->LATEX3（开发中）
中文排版：
CCT：科学院张林波
TY（天元）：华师大肖刚、陈志杰教授开发
CJK：德国W.Lemberg开发，处理中日韩三国文字。
发行版CTEX：集成了CCT，TY，CJK的MikTEX系统。
ChinaTEX:内容涵盖MiKTeX系统及中文支持、常用外围软件、TeX\LaTeX文档和模板选萃等

TeX中的长度
mm毫米
cm厘米
in英寸＝2.54cm＝72.27pt
pt点
em大写字母M的宽度
ex小写字母x的高度

弹性长度：根据需要自动伸缩
正常值plus伸展值minus收缩值
实际长度可超过正常值和伸展值之和，但不能小于正常值和收缩值之差

\documentclass[11pt]{article}%11pt字体，普通文章
%导言区，全局命令
\usepackage{CJK}%使用CJK宏包
\begin{document}%主环境
\begin{CJK}{GBK}{song}%汉字必须放入CJK环境
%其它字体:song,kai,fs,hei,li,you
%CJK的两种环境CJK和CJK*
%GBK是采用的字符集：GB，GBK，Bg5，Gbt
Hi,This is my first \LaTeX file
祝贺你，MikTex和CJK安装成功了
\end{CJK}
\ent{document}

CJK和CJK*环境之间的切换
\CJKspace和\CJKnospace


\CJKtilde 重新定义～的长度


基本约定
分组｛......｝
注释符：%
西文标点后要加空格
各种环境的开始和结束命令最好独占一行
换行:连续两个回车，一个仅为空格


输入特殊字符
前加\的有：#$%{}~_\^&
\=\textbackslash
｜,<,>＝$|$,$<$,$>$,$*$(中间星）
*＝*上面星
特殊符号\s \p \dag \ddag \copyrigh版权号，\pounds 磅

\TeX \LaTeX \LaTeXe \AmS-\LaTeX(最后这个要amsmath宏包）

单引号：`'(1键前面的）
双引号：``"

+------------------------------+
|段落、行距、水平间距、缩进命令|
+------------------------------+


强制分行：\\或\\*[和下行间距离]、\newline
建议分行：\linebreak[0-4，数越大建议力度越大]
\linebreak增加字间距，强制换行
\nolinebreak［n］建议不分行
\mbox｛内容｝内容保持在同一行

分段：\par，或两个回车
分页：自动分页
强制分页：\newpage
建议分页：\pagebreak［n］，\nopagebreak［n］

增加当前页高度有时可以避免难看的分页
\enlargethispage｛尺寸｝可增加的最大高度
\enlargethispage*｛尺寸｝指定增加高度

水平间距：
\quad 插入空白相当于当前字体大小
\qquad＝\quad×2
\ ，＝\quad×3/18
~=???好象比\ 小
\hspace{宽度大小}，\hspace*{宽度大小}
\hfill弹性长度：hspace{\hfill}插入空白，撑满整行
\hphantom{文本内容},占据文本内容的宽度
\vphantom[文本内容},\phantom{文本内容}

导引线：\dotfill，\hrulefill

垂直间距：
\vspace{高度}和\vspace*{高度}
\vfill：相当于\vspace{\fill}
\smallskip:-->\vspace{\smallskipamount}
\medskip:-->\vspace{\medskipamount}
\bigskip:-->\vspace{\bigskipamount}

段落首行缩进：
\setlength{\parindent}{2em},2个M
\setlength{\parindent}{0pt},首行不缩进
\CJKindent:两个汉字
\indent与\noindent
每节的第一段首行不会自动缩进
\hspane{\parindent}
在导言区加入：\usepackage{indentfirst}

段落间距：\lineskip+\parskip
可用\setlength修改以上值

行距：
\baselineskip：相邻两行基线间距离
\baselinestretch：伸展因子
修改改变行距：\renewcommand{\baselinestretch}[1.2]
放在\begin{document}之后，字体尺寸改变时才生效




+----------------------------------+
|西文字体属性、及中文字体属性、命令|
+----------------------------------+
字体有5种属性
族：
\rmfamily：罗马字体
\sffamily：无衬线字体
\ttfamily：打字机字体
形状：（shape）直立斜
\upshape：直立
\itshape：意大利斜体
\slshape：斜体
\scshape：小体大写
系列：（series）宽度黑度
\mdseries：中等权重（黑）
\bfseries：粗体

\normalfont：默认字体，中等权重直立罗马字体
西文尺寸：10pt，11pt，12pt
\em强调，一般为斜体
以上命令称为声明（无参数）

每一声明对应字体命令
命令只对其参数中的文本起作用
族：
\testrm{},\testsf{},\testtt{}
形状
\textup{},\textit{},\textsl{},\textsc{}
系列
\textmd{}，\textbf{}
默认值：\textnormal{}
强调：\emph{}

定义了基本尺寸后，可使用下面的声明来改变字体
\tiny  5pt
\scriptsize 7pt
\footnotesize 8pt
\small  9pt
\normalsize 10pt
\large  12pt
\Large  14.4pt
\LARGE  17.28pt
\huge  20.74pt
\Huge  24.88pt
以上尺寸是基本尺寸为10pt时的大小

所有西文字体命令对中文同样起作用
italic和slanted斜体对中文一样

中文书籍基本字号为5号约等于11pt

使用GBK编码时，可同时输入简繁体。

自定义字体大小
\fontsize{字体尺寸}{行距}后面须加上\selectfont才生效
可得到任意大小汉字，西文最大不能超\Huge
行距通常为字体大小的1.2-1.5倍
例：\fontsize{12pt}{\baselineskip}\selectfont
\usepackage{type1cm}任意大小西文

行距：\linespread{1.3}产生1.5倍行距，1.6产生双倍行距，效果夸张，不适合出版
用下面方法：\setlength{\baselineskip}{1.5\baselineskip}{......}



正文中更换字体：\CJKfamily{字体族}

为方便，作以下自定义
\newcommand*{\SONG}{\CJKfamily{song}}
\newcommand*{\HEI}{\CJKfamily{hei}}
\newcommand*{\KAI}{\CJKfamily{kai}}
\newcommand*{\FS}{\CJKfamily{fs}}
\newcommand*{\LI}{\CJKfamily{li}}
\newcommand*{\YOU}{\CJKfamily{YOU}}

引用更改为宋体：\SONG 正文



文本居中
文本默认为左对齐
单行文本居中命令
\centerline{....}
多行使用\begin{center}环境
居中声明：\centering（不建议使用）

+------------+
|参考文献环境|
+------------+
\begin{thebibliography}{编号样本}
\bibitem[记号]{引用标志} 文献条目
 .
 .
 .
\bibitem[记号]{引用标志} 文献条目
\end{thebibliography}

\bibitem[省略为方括号数字]{不可省由字母，数字和，号外符号组成，各个文献互不相
同} 文献条目
编号样本，指定记号的宽度，一般为数字

引用文献时用\cite{引用标志1，引用标志2}

调节各文献间距离
\setlength{\itemsep}{高度}

标题缺省为左对齐Reference
（\Large\bfseries）
由\refname值确定
书籍参考文献标题由\bibname值确定

文献条目包含：作者，标题，出版社，年代，版本，页码
一行放不下，后面自动缩进，距离为“编号样本”宽度

+----------+
| 脚    注 |
+----------+
\footnote{脚注内容}
article文档，整篇同一编号
book和report文档，每章统一编号

+----------------+
| 文档类别、章节 |
+----------------+

\documentclass[可选项]{article,book,report,letter,只能选一种}
article 短篇文章
report 长篇报告，可分章
book （书）可含chapter，奇偶页采用不同处理
可选项对整篇文档起作用，使用多个选项互不排斥，用逗号分隔
基本字体：10pt，11pt，12pt
纸张大小：letterpaper，a4paper，a5paper...
排版方向：portrait（竖向），landscape（横向）
标题页：titlepage，notitlepage
final和draft

指定纸张大小（只有latex2e中使用）
letterpaper（11*8.5in）
legalpaper（14*8.5in）
executivepaper（10.5*7.25in）
a4paper（29.7*21cm）
a5paper（21*14.8cm）
b5paper（25*17.6cm）
默认值是letterpaper，美国信纸尺寸，纵向
landscape 横向


章节命令：
\part,\chapter,\section,\subsection,\subsubsection,\paragraph,\subparagraph
\命令[短标题]{标题},用于显示在目录和页眉
\命令*{标题}
层次号：book中\part为-1（article中为0），\chapter为0，....
book类
\part，\chapter独立编号，只出现在奇数页，\part独占一页
\section，\subsection 关联编号
article类
\part，\section独立编号
\subsection，\subsubsection 关联编号
星号章节不参加自动编号
\part和\chapter标题占两行

标题中文化
\renewcommand{\partname}{}
\renewcommand{\thepart}{第\，\Roman{part}}\,篇}

修改编号最深层次
\setcounter{secnumberdepth}{数}
secnumberdepth，book类-2～5，缺省为2，-2时取消编号
article类-1～5，缺省为3

自动编号章节对应计数器
part，chapter，section，bsection,subsubsection,paragraph,subparagraph
修改计数器值：
\setcounter{计数器名}{数}

 TeX的版式首先是文件版式, 也就是我们接触的第一个最最最
简单的TeX文档中的第一句:
       \documentstyle[选项1,选项2,...]{格式}
其中的[]及选项是可选的, 而{格式}是必需的. LaTeX有以下几种
格式: article(文章), report(报告), book(书), letter(信件).
CCT对前面三种进行了汉化, 分别是carticle, creport和cbook.
常用的选项有
  10pt/11pt/12pt: 定义基准字号, 缺省10pt.
  twoside: 两面印刷格式, 因奇偶页装订位置不同而异, 缺省为
           单页.
  twocolumn: 双栏排版, 缺省为单栏.
  titlepage: 仅在article格式使用, 它是\maketile产生一个单
             独的文章题目页, 同时abstract也产生单独页
  leqno: 使公式标号出现在左边, 缺省在右
  fleqn: 公式左对齐, 缺省中间对齐
  thesis: 专用于毕业论文排版
  IEEE: 专向IEEE类杂志投稿的格式
  IFTHEN: 排版计算机程序

\columnsep 指定两栏间距
\columnseprule 两栏间竖线宽度，默认为0。
\mathindent 选择fleqn时 左边界的缩进量

以上参数修改用\setlength{\mathindent}{2.5cm}


    LaTeX的一个页面有页眉(head, 通常是杂志名, 卷号, 当前
章节名等), 主体(body, 正文, 包括脚注及图表), 页脚(通常是
页码, 如果页码放在页眉处, 则页脚可能是空的). 我们用下面的
指令控制页版面:
        \pagestyle{参数}
参数可以是
  plain: 页码在页脚居中, 页眉空白, 为article, report的缺省
  empty: 页眉页脚都空白
  heading: 页脚为空, 页眉为正文的章节信息及页码
  myheadings: 自定义页眉, 内容由
     \markboth{left_head}{right_head}   (双面twoside排版)
   或\markright{right_head}             (单面排版)
    \pagestyle是对全文有效的, 而如果要定义某页的页面格式,
则可用\thispagestyle, 用法同上, 下一页自动恢复原设置.

    这里提到页码, 我们经常会修改页码的表现格式, 可能用阿
拉伯数字或罗马数字等, 则修改\pagenumbering{参数}, 这里参
数可以是arabic(阿拉伯数字), roman(小写罗马数字: i, ii, iii,)
Roman(大写罗马数字: I, II, III,), alph(小写英文: a, b, c,),
Alph(大写英文: A, B, C). 如果需要更改某页的页码, 则用修改
计数器命令: \setcounter{page}{数字}, 这里page是页码计数器.

+----------------+
|*修改版面的命令*|
+----------------+


TeX中还经常会在\documentstyle和\begin{document}之间
常用到很多修改版面尺寸的命令. 如未指明, 这些命令的格式都
是用\para_name=newvalue的格式.
  \texwidth, \texheight 主要正文body的宽度和高度, 不包括页眉页脚
  \oddsidemargin, \evensidemargin 奇数/偶数页, 纸张左边缘
    到页body左边缘的距离减去一英寸
  \topmargin 纸张上边缘到页眉或body(无页眉时)的距离减去一
    英寸
  \marginparwidth 页边注(marginnote)的宽度
  \marginparsep 正文边缘到页边注边缘的距离
  \headheight 页眉高度
  \headsep 页眉底部到页主体顶部的距离
  \footheight 页脚高度
  \footskip 页正文最后一行底到页脚底的距离
(建议, 总把
\oddsizemargin（奇数页的左边界）
\evensidemargin（偶数页的左边界）
\topmargin（从上页边到页眉的距离）
设为0cm;
如果没用页眉, 将
\headheight（页眉高度）,
headsep（页眉基线到正文顶部的距离）
设为0cm;
如果没用页脚, 将
\footheight（已过时latex2e中已被去掉）,
\footskip（正文底部到页脚底部的距离）设为0cm,
这样便于在输出时直接利用驱动程序的功能控制版心的位置.)

\columnsep 双栏article中, 左右栏间空白的距离
\columnseprule 双栏article中, 左右栏间分隔线的宽度, 缺省 为零, 即没有线
以下参数的修改可以在\begin{document}的前面和后面:
  \parskip 段落之间除了空出正常行距外额外空出的距离
  \parindent 段首空白的长度
  \footnotesep 两个注脚之间的距离
  \baselineskip 正文中前一行底和第二行底的距离, 会因字号的
    改变自动改变.
    另外, 定义行距还有一个特殊的参数, 那是\baselinestretch,
它是用在\begin{document}前的全局变量, 修改格式如
\renewcommand\baselinestretch{倍数}    缺省时为1.0, 因此
LaTeX中最小行距是\baselineskip乘上\baselinestretch得到的.

+----------------+
| 文档标题、摘要 |
+----------------+

\title{标题可有\\换行}
\author{作者名可用and分开}
\date{日期可选，无命令自动当天日期，空白选项不显示}
\thanks{}可出现\maketitle以上任何位置，或几个\thanks
\maketitle
LaTex用特定字体、号居中输出

自定义标题环境
\begin{titlepage}
\end{titlepage}
生成标题独占一页，并重置页码计数器

摘要环境
\begi{abstract}
...
\end{abstract}

book类没有摘要
摘要标题中文化
\renewcommand{abstractname}{摘\qquad 要}

** [[http://www.jiancool.com/article/62041508632/][TTL]]
LS型TTL负载
其中“L”表示低功耗,“S”表示肖特基技术

       肖特基（Schottky）二极管是一种快恢复二极管,它属一种低功耗、超高速半导体器件。其显著的特点为反向恢复时间极短（可以小到几纳秒），正向导通压降仅0.4V左右。肖特基（Schottky）二极管多用作高频、低压、大电流整流二极管、续流二极管、保护二极管，也有用在微波通信等电路中作整流二极管、小信号检波二极管使用。常用在彩电的二次电源整流,高频电源整流中。

TTL(逻辑门电路)

全称Transistor-Transistor Logic,即BJT-BJT逻辑门电路，是数字电子技术中常用的一种逻辑门电路，应用较早，技术已比较成熟。TTL主要有BJT（Bipolar Junction Transistor 即双极结型晶体管，晶体三极管）和电阻构成，具有速度快的特点。最早的TTL门电路是74系列，后来出现了74H系列，74L系列，74LS,74AS,74ALS等系列。但是由于TTL功耗大等缺点，正逐渐被CMOS电路取代。

TTL电平信号:

        TTL电平信号被利用的最多是因为通常数据表示采用二进制规定，+5V等价于逻辑“1”，0V等价于逻辑“0”，这被称做TTL（晶体管-晶体管逻辑电平）信号系统，这是计算机处理器控制的设备内部各部分之间通信的标准技术。
       TTL电平信号对于计算机处理器控制的设备内部的数据传输是很理想的，首先计算机处理器控制的设备内部的数据传输对于电源的要求不高以及热损耗也较低，另外TTL电平信号直接与集成电路连接而不需要价格昂贵的线路驱动器以及接收器电路；再者，计算机处理器控制的设备内部的数据传输是在高速下进行的，而TTL接口的操作恰能满足这个要求。TTL型通信大多数情况下，是采用并行数据传输方式，而并行数据传输对于超过10英尺的距离就不适合了。这是由于可靠性和成本两面的原因。因为在并行接口中存在着偏相和不对称的问题，这些问题对可靠性均有影响。
        TTL输出高电平>2.4V，输出低电平<0.4V。在室温下，一般输出高电平是3.5V，输出低电平是0.2V。最小输入高电平和低电平：输入高电平>=2.0V，输入低电平<=0.8V，噪声容限是0.4V。
TTL门电路是双极型集成电路，与分立元件相比，具有速度快、可靠性高和微型化等优点。

** [[http://people.ubuntu.com/~happyaron/ubuntu-docs/precise-html/nautilus-bookmarks-edit.html][编辑文件夹书签]]

您的书签列在文件管理器的书签菜单中。

*** 删除书签：

1. 依次单击书签 ▸ 编辑书签。

2. 在编辑书签窗口中，选中要删除的书签，然后单击删除。

3. 单击关闭。

*** 添加书签：

1. 打开要对其添加书签的文件夹(或位置)。

2. 依次单击书签 ▸ 添加书签。

*** 重命名书签：

1. 依次单击书签 ▸ 编辑书签。

2. 在编辑书签窗口中，选中要重命名的书签。

3. 在名称文本框中，为该书签输入新名称。

   重命名书签不会重命名文件夹。如果有指向位置不同的两个不同文件夹的书签，但书签和相应文件夹的名称都相同，则两个书签的名称会相同，而且不能将两者区分开。这种情况下，让书签的名称不同于所指向的文件夹的名称会很有用。

** [[https://help.github.com/articles/caching-your-github-password-in-git/][Caching your GitHub password in Git]]

-  [[#platform-mac][mac]]
-  [[#platform-windows][windows]]
-  [[#platform-linux][linux]]
-  [[#platform-all][all]]

If you're [[/articles/which-remote-url-should-i-use][cloning GitHub
repositories using HTTPS]], you can use a /credential helper/ to tell
Git to remember your GitHub username and password every time it talks to
GitHub.

If you clone GitHub repositories using SSH, then you authenticate using
SSH keys instead of a username and password. For help setting up an SSH
connection, see [[/articles/generating-an-ssh-key][Generating an SSH
Key]].

*Tips:*

-  You need Git *1.7.10* or newer to use the credential helper.
-  If you installed Git using [[http://brew.sh/][Homebrew]], the
   osxkeychain helper may already be installed.

Install the osxkeychain credential helper and tell Git to use it.

1. Find out if the osxkeychain credential helper is already installed by
   trying to run it:

   #+BEGIN_EXAMPLE
       git credential-osxkeychain
       # Test for the cred helper
       Usage: git credential-osxkeychain <get|store|erase>
   #+END_EXAMPLE

2. If the osxkeychain helper isn't installed, download it with curl:

   #+BEGIN_EXAMPLE
       git credential-osxkeychain
       # Test for the cred helper
       git: 'credential-osxkeychain' is not a git command. See 'git --help'.
       curl -s -O \
       https://github-media-downloads.s3.amazonaws.com/osx/git-credential-osxkeychain
       # Download the helper
       chmod u+x git-credential-osxkeychain
       # Fix the permissions on the file so it can be run
   #+END_EXAMPLE

3. Install the helper into the same directory where Git itself is
   installed:

   #+BEGIN_EXAMPLE
       sudo mv git-credential-osxkeychain \
       "$(dirname $(which git))/git-credential-osxkeychain"
       # Move the helper to the path where git is installed
       Password: [enter your password]
   #+END_EXAMPLE

4. Tell Git to use osxkeychain using the global =credential.helper=
   config:

   #+BEGIN_EXAMPLE
       git config --global credential.helper osxkeychain
       # Set git to use the osxkeychain credential helper
   #+END_EXAMPLE

The next time you clone an HTTPS URL that requires a password, you'll be
prompted for your username and password, and to grant access to the OSX
keychain. After you've done this, the username and password are stored
in your keychain and you won't be required to type them in to Git again.

*Tip:* You need Git *1.7.10* or newer to use the credential helper.

The credential helper is included with GitHub Desktop. The app also
provides a Git shell so you won't ever need to install and configure Git
manually. For more information, see
"[[/desktop/guides/getting-started/][Getting Started with GitHub
Desktop]]."

If you prefer working with the command line, you can also install a
native Git shell, such as [[https://msysgit.github.io/][msysgit]]. With
msysgit, running the following in the command line will store your
credentials:

#+BEGIN_EXAMPLE
    git config --global credential.helper wincred
#+END_EXAMPLE

*Tip:* You need Git *1.7.10* or newer to use the credential helper.

Turn on the credential helper so that Git will save your password in
memory for some time. By default, Git will cache your password for 15
minutes.

1. In Terminal, enter the following:

   #+BEGIN_EXAMPLE
       git config --global credential.helper cache
       # Set git to use the credential memory cache
   #+END_EXAMPLE

2. To change the default password cache timeout, enter the following:

   #+BEGIN_EXAMPLE
       git config --global credential.helper 'cache --timeout=3600'
       # Set the cache to timeout after 1 hour (setting is in seconds)
   #+END_EXAMPLE

*Tip:* You need Git *1.7.10* or newer to use the credential helper.

Turn on the credential helper so that Git will save your password in
memory for some time. By default, Git will cache your password for 15
minutes.

1. On the command line, enter the following:

   #+BEGIN_EXAMPLE
       git config --global credential.helper cache
       # Set git to use the credential memory cache
   #+END_EXAMPLE

2. To change the default password cache timeout, enter the following:

   #+BEGIN_EXAMPLE
       git config --global credential.helper 'cache --timeout=3600'
       # Set the cache to timeout after 1 hour (setting is in seconds)
   #+END_EXAMPLE

** [[http://blog.csdn.net/lithocntlor/article/details/7713511][JTag, JLink及OpenJtag的比较]]

标签： [[http://www.csdn.net/tag/%e5%b7%a5%e5%85%b7][工具]]

2012-07-03 23:37 2876人阅读 [[#comments][评论]](0)
[[javascript:void(0);][收藏]] [[#report][举报]]

[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

ARM+Linux/（7）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/lithocntlor/article/category/1172508][作者同类文章]]/X/

版权声明：本文为博主原创文章，未经博主允许不得转载。

**** 简介

#+BEGIN_QUOTE
  本文简单介绍了JTag,
  JLink及OpenJTag的用途，以及区别。同时也介绍了开发机没有并口时，该选择何种工具进行烧写。所有资料均从网上搜罗而来。
#+END_QUOTE

**** 一. JTag

#+BEGIN_QUOTE
  JTag(Joint Test Action Group) 是IEEE1149.1 （Standard Access Port and
  Boundary-Scan Architecture)标准.
  它最初用来以边界扫描的方式测试印刷电路板，当然它现在仍然这一方面广泛使用。
  JTag的用途：
  1. 边界扫描测试
#+END_QUOTE

#+BEGIN_QUOTE
  2. 往Flash烧写程序和数据： 可以烧写Nor Falsh 和 Nand Falsh
  3. 调试ARM裸机程序，不能调试嵌入式Linux程序
  JTag的接口：
  JTag接口并没有统一的标准。ARM处理器通常使用2＊10针（部分使用2＊7针）的JTag接口。
  JTag连接Host的一端通常为并口。一般笔记本及台式机都很少有并口接口，而且市面上买到的USB转并口并不能用于JTag，USB转并口主要是给老式打印机使用的。这就使得我们很难使用JTag以及笔记本进行烧写。另外的一个缺点是并口JTag的速率非常低。
  JTag的替代品：
  Serial Wire Debug（SWD）。
#+END_QUOTE

**** 二. JLink

#+BEGIN_QUOTE
  JLink是Segger的产品，[[http://www.segger.com/jlink.html][http://www.segger.com/jlink.html]]。它是USB接口转到JTag接口的适配器（adaptor)，并不是真正意义上的仿真器。它采用标准的14针或者20针的Jtag接口与开发板相连。它支持多种CPU内核（ARM7，
  ARM9，Cortex etc.）。对ARM而言，它可能是最受欢迎的适配器。
  JLink的功能：
  1. 往Flash烧写程序：不支持烧写NAND Flash
  参见[[http://www.segger2.com/index.php?page=Thread&threadID=144][http://www.segger2.com/index.php?page=Thread&threadID=144]]
  2. 支持Windows, Linux以及Mac： 但是Linux及Mac仅支持JLink Commander,
  Command Line GdbServer, 以及shared library。
  3. 支持多种调试协议： 如GDB， RDI 等
  4. USB转串口功能
  JLink的接口：
  USB接口，JLink的价格也比较低（当然是山寨的）。
#+END_QUOTE

**** 三. OpenJTag

#+BEGIN_QUOTE
  OpenJTag是一个开源项目（包含软件和硬件），采用GNU GPL
  license： [[http://www.openjtag.org/][http://www.openjtag.org/]]。同样它也是一个USB接口转JTag接口的适配器，同样不是真正意义上的仿真器。
  OpenJTag的功能：
  1. 往Flash烧写程序： 支持NOR Flash 和 NAND Flash
  2. 支持Windows以及Linux
  3. 能够用在支持GDB调试协议的工具上： 如IAR， Eclipse，
  但不能用在支持RDI调试协议的工具上： 如ADS
  4. USB转串口功能
  OpenJtag的接口：
  USB接口，但是他的价格要比JLink高一些。
#+END_QUOTE


** [[http://www.cnblogs.com/youtherhome/archive/2013/03/17/2964195.html][Linux C++的多线程编程]]

**** *1. 引言*

*线程（thread）*技术早在60年代就被提出，但真正应用多线程到操作系统中去，是在80年代中期，solaris是这方面的佼佼者。传统的Unix也支持线程的概念，但是在一个*进程（process）*中只允许有一个线程，这样多线程就意味着多进程。现在，多线程技术已经被许多操作系统所支持，包括Windows/NT，当然，也包括Linux。
为什么有了进程的概念后，还要再引入线程呢？使用多线程到底有哪些好处？什么的系统应该选用多线程？我们首先必须回答这些问题。
使用多线程的理由之一是和进程相比，它是一种非常"节俭"的多任务操作方式。我们知道，在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。
使用多线程的理由之二是线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。
除了以上所说的优点外，不和进程比较，多线程程序作为一种多任务、并发的工作方式，当然有以下的优点：
1)
提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time
consuming）置于一个新的线程，可以避免这种尴尬的情况。
2)
使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。
3)
改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。
下面我们先来尝试编写一个简单的多线程程序。



**** *2. 简单的多线程编程*

Linux系统下的多线程遵循POSIX线程接口，称为*pthread*。编写Linux下的多线程程序，需要使用头文件pthread.h，连接时需要使用库libpthread.a。顺便说一下，Linux下pthread的实现是通过系统调用clone()来实现的。clone()是Linux所特有的系统调用，它的使用方式类似fork，关于clone()的详细情况，有兴趣的读者可以去查看有关文档说明。下面我们展示一个最简单的多线程程序threads.cpp。

#+BEGIN_EXAMPLE
    //Threads.cpp
    #include <iostream>
    #include <unistd.h>
    #include <pthread.h>
    using namespace std;

    void *thread(void *ptr)
    {
        for(int i = 0;i < 3;i++) {
            sleep(1);
            cout << "This is a pthread." << endl;
        }
        return 0;
    }

    int main() {
        pthread_t id;
        int ret = pthread_create(&id, NULL, thread, NULL);
        if(ret) {
            cout << "Create pthread error!" << endl;
            return 1;
        }
        for(int i = 0;i < 3;i++) {
            cout <<  "This is the main process." << endl;
            sleep(1);
        }
        pthread_join(id, NULL);
        return 0;
    }
#+END_EXAMPLE

我们编译并运行此程序，可以得到如下结果：
This is the main process.
This is a pthread.
This is the main process.
This is the main process.
This is a pthread.
This is a pthread.
再次运行，我们可能得到如下结果：
This is a pthread.
This is the main process.
This is a pthread.
This is the main process.
This is a pthread.
This is the main process.

前后两次结果不一样，这是两个线程争夺CPU资源的结果。上面的示例中，我们使用到了两个函数，pthread_create和pthread_join，并声明了一个pthread_t型的变量。
pthread_t在头文件/usr/include/bits/pthreadtypes.h中定义：

#+BEGIN_EXAMPLE
    typedef unsigned long int pthread_t;
#+END_EXAMPLE

它是一个线程的标识符。函数pthread_create用来创建一个线程，它的原型为：

#+BEGIN_EXAMPLE
    extern int pthread_create __P ((pthread_t *__thread, __const pthread_attr_t *__attr,
    void *(*__start_routine) (void *), void *__arg));
#+END_EXAMPLE

第一个参数为指向线程标识符的指针，第二个参数用来设置线程属性，第三个参数是线程运行函数的起始地址，最后一个参数是运行函数的参数。这里，我们的函数thread不需要参数，所以最后一个参数设为空指针。第二个参数我们也设为空指针，这样将生成默认属性的线程。对线程属性的设定和修改我们将在下一节阐述。当创建线程成功时，函数返回0，若不为0则说明创建线程失败，常见的错误返回代码为EAGAIN和EINVAL。前者表示系统限制创建新的线程，例如线程数目过多了；后者表示第二个参数代表的线程属性值非法。创建线程成功后，新创建的线程则运行参数三和参数四确定的函数，原来的线程则继续运行下一行代码。
函数pthread_join用来等待一个线程的结束。函数原型为：

#+BEGIN_EXAMPLE
    extern int pthread_join __P ((pthread_t __th, void **__thread_return));
#+END_EXAMPLE

第一个参数为被等待的线程标识符，第二个参数为一个用户定义的指针，它可以用来存储被等待线程的返回值。这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回。一个线程的结束有两种途径，一种是象我们上面的例子一样，函数结束了，调用它的线程也就结束了；另一种方式是通过函数pthread_exit来实现。它的函数原型为：

#+BEGIN_EXAMPLE
    extern void pthread_exit __P ((void *__retval)) __attribute__ ((__noreturn__));
#+END_EXAMPLE

唯一的参数是函数的返回代码，只要pthread_join中的第二个参数thread_return不是NULL，这个值将被传递给thread_return。最后要说明的是，一个线程不能被多个线程等待，否则第一个接收到信号的线程成功返回，其余调用pthread_join的线程则返回错误代码ESRCH。
在这一节里，我们编写了一个最简单的线程，并掌握了最常用的三个函数pthread_create，pthread_join和pthread_exit。下面，我们来了解线程的一些常用属性以及如何设置这些属性。



**** *3. 修改线程的属性*

在上一节的例子里，我们用pthread_create函数创建了一个线程，在这个线程中，我们使用了默认参数，即将该函数的第二个参数设为NULL。的确，对大多数程序来说，使用默认属性就够了，但我们还是有必要来了解一下线程的有关属性。
属性结构为pthread_attr_t，它同样在头文件/usr/include/pthread.h中定义，喜欢追根问底的人可以自己去查看。属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。属性对象主要包括是否绑定、是否分离、堆栈地址、堆栈大小、优先级。默认的属性为非绑定、非分离、缺省1M的堆栈、与父进程同样级别的优先级。
关于线程的绑定，牵涉到另外一个概念：轻进程（LWP：Light Weight
Process）。轻进程可以理解为内核线程，它位于用户层和系统层之间。系统对线程资源的分配、对线程的控制是通过轻进程来实现的，一个轻进程可以控制一个或多个线程。默认状况下，启动多少轻进程、哪些轻进程来控制哪些线程是由系统来控制的，这种状况即称为非绑定的。绑定状况下，则顾名思义，即某个线程固定的"绑"在一个轻进程之上。被绑定的线程具有较高的响应速度，这是因为CPU时间片的调度是面向轻进程的，绑定的线程可以保证在需要的时候它总有一个轻进程可用。通过设置被绑定的轻进程的优先级和调度级可以使得绑定的线程满足诸如实时反应之类的要求。
设置线程绑定状态的函数为pthread_attr_setscope，它有两个参数，第一个是指向属性结构的指针，第二个是绑定类型，它有两个取值：PTHREAD_SCOPE_SYSTEM（绑定的）和PTHREAD_SCOPE_PROCESS（非绑定的）。下面的代码即创建了一个绑定的线程。



#+BEGIN_EXAMPLE
    #include <pthread.h>
    pthread_attr_t attr;
    pthread_t tid;
    /*初始化属性值，均设为默认值*/
    pthread_attr_init(&attr);
    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
    pthread_create(&tid, &attr, (void *) my_function, NULL);
#+END_EXAMPLE



线程的分离状态决定一个线程以什么样的方式来终止自己。在上面的例子中，我们采用了线程的默认属性，即为非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。设置线程分离状态的函数为pthread_attr_setdetachstate（pthread_attr_t
*attr, int
detachstate）。第二个参数可选为PTHREAD_CREATE_DETACHED（分离线程）和
PTHREAD
_CREATE_JOINABLE（非分离线程）。这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timewait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait（）之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。

另外一个可能常用的属性是线程的优先级，它存放在结构sched_param中。用函数pthread_attr_getschedparam和函数pthread_attr_setschedparam进行存放，一般说来，我们总是先取优先级，对取得的值修改后再存放回去。下面即是一段简单的例子。

#+BEGIN_EXAMPLE
    #include <pthread.h>
    #include <sched.h>
    pthread_attr_t attr;
    pthread_t tid;
    sched_param param;
    int newprio=20;
    pthread_attr_init(&amp;attr);
    pthread_attr_getschedparam(&attr, &param);
    param.sched_priority=newprio;
    pthread_attr_setschedparam(&attr, &param);
    pthread_create(&tid, &attr, (void *)myfunction, myarg);
#+END_EXAMPLE



*4. 线程的数据处理*
和进程相比，线程的最大优点之一是数据的共享性，各个进程共享父进程处沿袭的数据段，可以方便的获得、修改数据。但这也给多线程编程带来了许多问题。我们必须当心有多个不同的进程访问相同的变量。许多函数是不可重入的，即同时不能运行一个函数的多个拷贝（除非使用不同的数据段）。在函数中声明的静态变量常常带来问题，函数的返回值也会有问题。因为如果返回的是函数内部静态声明的空间的地址，则在一个线程调用该函数得到地址后使用该地址指向的数据时，别的线程可能调用此函数并修改了这一段数据。在进程中共享的变量必须用关键字volatile来定义，这是为了防止编译器在优化时（如gcc中使用-OX参数）改变它们的使用方式。为了保护变量，我们必须使用信号量、互斥等方法来保证我们对变量的正确使用。下面，我们就逐步介绍处理线程数据时的有关知识。

*　　4.1 线程数据
*　　在单线程的程序里，有两种基本的数据：全局变量和局部变量。但在多线程程序里，还有第三种数据类型：线程数据（TSD:
Thread-Specific
Data）。它和全局变量很象，在线程内部，各个函数可以象使用全局变量一样调用它，但它对线程外部的其它线程是不可见的。这种数据的必要性是显而易见的。例如我们常见的变量errno，它返回标准的出错信息。它显然不能是一个局部变量，几乎每个函数都应该可以调用它；但它又不能是一个全局变量，否则在A线程里输出的很可能是B线程的出错信息。要实现诸如此类的变量，我们就必须使用线程数据。我们为每个线程数据创建一个键，它和这个键相关联，在各个线程里，都使用这个键来指代线程数据，但在不同的线程里，这个键代表的数据是不同的，在同一个线程里，它代表同样的数据内容。
和线程数据相关的函数主要有4个：创建一个键；为一个键指定线程数据；从一个键读取线程数据；删除键。
创建键的函数原型为：

#+BEGIN_EXAMPLE
    extern int pthread_key_create __P ((pthread_key_t *__key,void (*__destr_function) (void *)));
#+END_EXAMPLE

第一个参数为指向一个键值的指针，第二个参数指明了一个destructor函数，如果这个参数不为空，那么当每个线程结束时，系统将调用这个函数来释放绑定在这个键上的内存块。这个函数常和函数pthread_once
((pthread_once_t*once_control, void (*initroutine)
(void)))一起使用，为了让这个键只被创建一次。函数pthread_once声明一个初始化函数，第一次调用pthread_once时它执行这个函数，以后的调用将被它忽略。

在下面的例子中，我们创建一个键，并将它和某个数据相关联。我们要定义一个函数createWindow，这个函数定义一个图形窗口（数据类型为Fl_Window
*，这是图形界面开发工具FLTK中的数据类型）。由于各个线程都会调用这个函数，所以我们使用线程数据。

#+BEGIN_EXAMPLE
    /* 声明一个键*/
    pthread_key_t myWinKey;
    /* 函数 createWindow */
    void createWindow ( void ) {
        Fl_Window * win;
        static pthread_once_t once= PTHREAD_ONCE_INIT;
        /* 调用函数createMyKey，创建键*/
        pthread_once ( & once, createMyKey) ;
        /*win指向一个新建立的窗口*/
        win=new Fl_Window( 0, 0, 100, 100, "MyWindow");
        /* 对此窗口作一些可能的设置工作，如大小、位置、名称等*/
        setWindow(win);
        /* 将窗口指针值绑定在键myWinKey上*/
        pthread_setpecific ( myWinKey, win);
    }

    /* 函数 createMyKey，创建一个键，并指定了destructor */
    void createMyKey ( void ) {
        pthread_keycreate(&myWinKey, freeWinKey);
    }

    /* 函数 freeWinKey，释放空间*/
    void freeWinKey ( Fl_Window * win){
        delete win;
    }
#+END_EXAMPLE

这样，在不同的线程中调用函数createMyWin，都可以得到在线程内部均可见的窗口变量，这个变量通过函数pthread_getspecific得到。在上面的例子中，我们已经使用了函数pthread_setspecific来将线程数据和一个键绑定在一起。这两个函数的原型如下：

#+BEGIN_EXAMPLE
    extern int pthread_setspecific __P ((pthread_key_t __key,__const void *__pointer));
    extern void *pthread_getspecific __P ((pthread_key_t __key));
#+END_EXAMPLE

这两个函数的参数意义和使用方法是显而易见的。要注意的是，用pthread_setspecific为一个键指定新的线程数据时，必须自己释放原有的线程数据以回收空间。这个过程函数pthread_key_delete用来删除一个键，这个键占用的内存将被释放，但同样要注意的是，它只释放键占用的内存，并不释放该键关联的线程数据所占用的内存资源，而且它也不会触发函数pthread_key_create中定义的destructor函数。线程数据的释放必须在释放键之前完成。



*　　4.2 互斥锁
*　　互斥锁用来保证一段时间内只有一个线程在执行一段代码。必要性显而易见：假设各个线程向同一个文件顺序写入数据，最后得到的结果一定是灾难性的。
我们先看下面一段代码。这是一个读/写程序，它们公用一个缓冲区，并且我们假定一个缓冲区只能保存一条信息。即缓冲区只有两个状态：有信息或没有信息。

#+BEGIN_EXAMPLE
    void reader_function ( void );
    void writer_function ( void );
    char buffer;
    int buffer_has_item=0;
    pthread_mutex_t mutex;
    struct timespec delay;

    void main ( void ){
        pthread_t reader;
        /* 定义延迟时间*/
        delay.tv_sec = 2;
        delay.tv_nec = 0;
        /* 用默认属性初始化一个互斥锁对象*/
        pthread_mutex_init (&mutex,NULL);
        pthread_create(&reader, pthread_attr_default, (void *)&reader_function), NULL);
        writer_function( );
    }

    void writer_function (void){
        while(1){
            /* 锁定互斥锁*/
            pthread_mutex_lock (&mutex);
            if (buffer_has_item==0){
                buffer=make_new_item( );
                buffer_has_item=1;
            }
            /* 打开互斥锁*/
            pthread_mutex_unlock(&mutex);
            pthread_delay_np(&delay);
        }
    }

    void reader_function(void){
        while(1){
            pthread_mutex_lock(&mutex);
            if(buffer_has_item==1){
                consume_item(buffer);
                buffer_has_item=0;
            }
            pthread_mutex_unlock(&mutex);
            pthread_delay_np(&delay);
        }
    }
#+END_EXAMPLE

这里声明了互斥锁变量mutex，结构pthread_mutex_t为不公开的数据类型，其中包含一个系统分配的属性对象。函数pthread_mutex_init用来生成一个互斥锁。NULL参数表明使用默认属性。如果需要声明特定属性的互斥锁，须调用函数pthread_mutexattr_init。函数pthread_mutexattr_setpshared和函数pthread_mutexattr_settype用来设置互斥锁属性。前一个函数设置属性pshared，它有两个取值，PTHREAD_PROCESS_PRIVATE和PTHREAD_PROCESS_SHARED。前者用来不同进程中的线程同步，后者用于同步本进程的不同线程。在上面的例子中，我们使用的是默认属性PTHREAD_PROCESS_
PRIVATE。后者用来设置互斥锁类型，可选的类型有PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE和PTHREAD
_MUTEX_DEFAULT。它们分别定义了不同的上锁、解锁机制，一般情况下，选用最后一个默认属性。
pthread_mutex_lock声明开始用互斥锁上锁，此后的代码直至调用pthread_mutex_unlock为止，均被上锁，即同一时间只能被一个线程调用执行。当一个线程执行到pthread_mutex_lock处时，如果该锁此时被另一个线程使用，那此线程被阻塞，即程序将等待到另一个线程释放此互斥锁。在上面的例子中，我们使用了pthread_delay_np函数，让线程睡眠一段时间，就是为了防止一个线程始终占据此函数。
上面的例子非常简单，就不再介绍了，需要提出的是在使用互斥锁的过程中很有可能会出现死锁：两个线程试图同时占用两个资源，并按不同的次序锁定相应的互斥锁，例如两个线程都需要锁定互斥锁1和互斥锁2，a线程先锁定互斥锁1，b线程先锁定互斥锁2，这时就出现了死锁。此时我们可以使用函数pthread_mutex_trylock，它是函数pthread_mutex_lock的非阻塞版本，当它发现死锁不可避免时，它会返回相应的信息，程序员可以针对死锁做出相应的处理。另外不同的互斥锁类型对死锁的处理不一样，但最主要的还是要程序员自己在程序设计注意这一点。

*　　4.3 条件变量
*　　前一节中我们讲述了如何使用互斥锁来实现线程间数据的共享和通信，互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其它的某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线承间的同步。
条件变量的结构为pthread_cond_t，函数pthread_cond_init（）被用来初始化一个条件变量。它的原型为：

#+BEGIN_EXAMPLE
    extern int pthread_cond_init __P ((pthread_cond_t *__cond,__const pthread_condattr_t *__cond_attr));
#+END_EXAMPLE

其中cond是一个指向结构pthread_cond_t的指针，cond_attr是一个指向结构pthread_condattr_t的指针。结构pthread_condattr_t是条件变量的属性结构，和互斥锁一样我们可以用它来设置条件变量是进程内可用还是进程间可用，默认值是PTHREAD_
PROCESS_PRIVATE，即此条件变量被同一进程内的各个线程使用。注意初始化条件变量只有未被使用时才能重新初始化或被释放。释放一个条件变量的函数为pthread_cond_
destroy（pthread_cond_t cond）。　
函数pthread_cond_wait（）使线程阻塞在一个条件变量上。

它的函数原型为：

#+BEGIN_EXAMPLE
    extern int pthread_cond_wait __P ((pthread_cond_t *__cond,
    pthread_mutex_t *__mutex));
#+END_EXAMPLE

线程解开mutex指向的锁并被条件变量cond阻塞。线程可以被函数pthread_cond_signal和函数pthread_cond_broadcast唤醒，但是要注意的是，条件变量只是起阻塞和唤醒线程的作用，具体的判断条件还需用户给出，例如一个变量是否为0等等，这一点我们从后面的例子中可以看到。线程被唤醒后，它将重新检查判断条件是否满足，如果还不满足，一般说来线程应该仍阻塞在这里，被等待被下一次唤醒。这个过程一般用while语句实现。
另一个用来阻塞线程的函数是pthread_cond_timedwait()，它的原型为：

#+BEGIN_EXAMPLE
    extern int pthread_cond_timedwait __P ((pthread_cond_t *__cond,
    pthread_mutex_t *__mutex, __const struct timespec *__abstime));
#+END_EXAMPLE

它比函数pthread_cond_wait()多了一个时间参数，经历abstime段时间后，即使条件变量不满足，阻塞也被解除。
函数pthread_cond_signal()的原型为：
extern int pthread_cond_signal __P ((pthread_cond_t
*__cond));
它用来释放被阻塞在条件变量cond上的一个线程。多个线程阻塞在此条件变量上时，哪一个线程被唤醒是由线程的调度策略所决定的。要注意的是，必须用保护条件变量的互斥锁来保护这个函数，否则条件满足信号又可能在测试条件和调用pthread_cond_wait函数之间被发出，从而造成无限制的等待。下面是使用函数pthread_cond_wait()和函数

#+BEGIN_EXAMPLE
    pthread_cond_signal()的一个简单的例子。
    pthread_mutex_t count_lock;
    pthread_cond_t count_nonzero;
    unsigned count;
    decrement_count () {
        pthread_mutex_lock (&count_lock);
        while(count==0)
            pthread_cond_wait( &count_nonzero, &count_lock);
        count=count -1;
        pthread_mutex_unlock (&count_lock);
    }

    increment_count(){
        pthread_mutex_lock(&count_lock);
        if(count==0)
            pthread_cond_signal(&count_nonzero);
        count=count+1;
        pthread_mutex_unlock(&count_lock);
    }
#+END_EXAMPLE

count值为0时，decrement函数在pthread_cond_wait处被阻塞，并打开互斥锁count_lock。此时，当调用到函数increment_count时，pthread_cond_signal（）函数改变条件变量，告知decrement_count（）停止阻塞。读者可以试着让两个线程分别运行这两个函数，看看会出现什么样的结果。
函数pthread_cond_broadcast（pthread_cond_t
*cond）用来唤醒所有被阻塞在条件变量cond上的线程。这些线程被唤醒后将再次竞争相应的互斥锁，所以必须小心使用这个函数。



*　　4.4 信号量*
信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。当公共资源增加时，调用函数sem_post（）增加信号量。只有当信号量值大于０时，才能使用公共资源，使用后，函数sem_wait（）减少信号量。函数sem_trywait（）和函数pthread_
mutex_trylock（）起同样的作用，它是函数sem_wait（）的非阻塞版本。下面我们逐个介绍和信号量有关的一些函数，它们都在头文件/usr/include/semaphore.h中定义。
信号量的数据类型为结构sem_t，它本质上是一个长整型的数。函数sem_init（）用来初始化一个信号量。它的原型为：
extern int sem_init __P ((sem_t *__sem, int __pshared,
unsigned int __value));
sem为指向信号量结构的一个指针；pshared不为０时此信号量在进程间共享，否则只能为当前进程的所有线程共享；value给出了信号量的初始值。
函数sem_post( sem_t *sem
)用来增加信号量的值。当有线程阻塞在这个信号量上时，调用这个函数会使其中的一个线程不在阻塞，选择机制同样是由线程的调度策略决定的。
函数sem_wait( sem_t *sem
)被用来阻塞当前线程直到信号量sem的值大于0，解除阻塞后将sem的值减一，表明公共资源经使用后减少。函数sem_trywait
( sem_t *sem
)是函数sem_wait（）的非阻塞版本，它直接将信号量sem的值减一。
函数sem_destroy(sem_t *sem)用来释放信号量sem。
下面我们来看一个使用信号量的例子。在这个例子中，一共有4个线程，其中两个线程负责从文件读取数据到公共的缓冲区，另两个线程从缓冲区读取数据作不同的处理（加和乘运算）。

#+BEGIN_EXAMPLE
    /* File sem.c */
    #include <stdio.h>
    #include <pthread.h>
    #include <semaphore.h>
    #define MAXSTACK 100
    int stack[MAXSTACK][2];
    int size=0;
    sem_t sem;

    /* 从文件1.dat读取数据，每读一次，信号量加一*/
    void ReadData1(void){
        FILE *fp=fopen("1.dat","r");
        while(!feof(fp)){
            fscanf(fp,"%d %d",&stack[size][0],&stack[size][1]);
            sem_post(&sem);
            ++size;
        }
        fclose(fp);
    }

    /*从文件2.dat读取数据*/
    void ReadData2(void){
        FILE *fp=fopen("2.dat","r");
        while(!feof(fp)){
            fscanf(fp,"%d %d",&stack[size][0],&stack[size][1]);
            sem_post(&sem);
            ++size;
        }
        fclose(fp);
    }
    /*阻塞等待缓冲区有数据，读取数据后，释放空间，继续等待*/
    void HandleData1(void){
        while(1){
            sem_wait(&sem);
            printf("Plus:%d+%d=%d\n",stack[size][0],stack[size][1],
            stack[size][0]+stack[size][1]);
            --size;
        }
    }

    void HandleData2(void){
        while(1){
            sem_wait(&sem);
            printf("Multiply:%d*%d=%d\n",stack[size][0],stack[size][1],
            stack[size][0]*stack[size][1]);
            --size;
        }
    }

    int main(void){
        pthread_t t1,t2,t3,t4;
        sem_init(&sem,0,0);
        pthread_create(&t1,NULL,(void *)HandleData1,NULL);
        pthread_create(&t2,NULL,(void *)HandleData2,NULL);
        pthread_create(&t3,NULL,(void *)ReadData1,NULL);
        pthread_create(&t4,NULL,(void *)ReadData2,NULL);
        /* 防止程序过早退出，让它在此无限期等待*/
        pthread_join(t1,NULL);
    }
#+END_EXAMPLE

在Linux下，我们用命令gcc -lpthread sem.c -o sem生成可执行文件sem。
我们事先编辑好数据文件1.dat和2.dat，假设它们的内容分别为1 2 3 4 5 6 7 8
9 10和 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 ，我们运行sem，得到如下的结果：
Multiply:-1*-2=2
Plus:-1+-2=-3
Multiply:9*10=90
Plus:-9+-10=-19
Multiply:-7*-8=56
Plus:-5+-6=-11
Multiply:-3*-4=12
Plus:9+10=19
Plus:7+8=15
Plus:5+6=11

从中我们可以看出各个线程间的竞争关系。而数值并未按我们原先的顺序显示出来这是由于size这个数值被各个线程任意修改的缘故。这也往往是多线程编程要注意的问题。

*5. 小结*

多线程编程是一个很有意思也很有用的技术，使用多线程技术的网络蚂蚁是目前最常用的下载工具之一，使用多线程技术的grep比单线程的grep要快上几倍，类似的例子还有很多。希望大家能用多线程技术写出高效实用的好程序来。

** [[http://www.cnblogs.com/finlay/p/pthread_create%e6%9c%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e5%bc%95%e7%94%a8.html][编译Linux程序出现“对‘pthread_create'未定义的引用”]]

2013-08-06 17:06 by Finlay Liu, ... 阅读, ... 评论, [[#][收藏]],
[[http://i.cnblogs.com/EditPosts.aspx?postid=3240910][编辑]]

在学习Linux程序设计POXIS线程的时候，编译一个段简单的代码，就出现下面的错误：

#+BEGIN_EXAMPLE
    1 /tmp/cc2FQJTh.o：在函数‘main’中：
    2 1-thread.c:(.text+0x29)：对‘pthread_create’未定义的引用
    3 1-thread.c:(.text+0x67)：对‘pthread_join’未定义的引用
    4 collect2: 错误： ld 返回 1
#+END_EXAMPLE

可是在我的代码中已经包含了pthread.h，这是什么回事呢，百度一下，*发现网上大部分的解决办法是在gcc编译命令加上选项：lpthread。*

#+BEGIN_EXAMPLE
    1 gcc -o pthread -lpthread pthread.c
#+END_EXAMPLE

但我照着网上的方法试试，发现还是不行，错误提示与原来相同。后来才发现是我自己错了，我是在目标代码文件前加上-lpthread。但实际的做法应该是在代码文件后面添加次选项。

#+BEGIN_EXAMPLE
    1 finlay@finlay-Lenovo-G470:~/文档/程序设计/Linux程序设计/12章$ gcc 1-thread.c -lpthread
    2 #成功！
    3 finlay@finlay-Lenovo-G470:~/文档/程序设计/Linux程序设计/12章$ gcc -lpthread -Wall 1-thread.c
    4 #失败！
    5 /tmp/ccE6dosW.o：在函数‘main’中：
    6 1-thread.c:(.text+0x29)：对‘pthread_create’未定义的引用
    7 1-thread.c:(.text+0x67)：对‘pthread_join’未定义的引用
    8 collect2: 错误： ld 返回 1
#+END_EXAMPLE

但是还有一个什么有趣的现象，如下：

#+BEGIN_EXAMPLE
    1 finlay@finlay-Lenovo-G470:~/文档/程序设计/Linux程序设计/12章$ gcc -pthread 1-thread.c
    2 #成功！
    3 finlay@finlay-Lenovo-G470:~/文档/程序设计/Linux程序设计/12章$ gcc -lpthread 1-thread.c
    4 #失败！
    5 /tmp/ccbr6m7v.o：在函数‘main’中：
    6 1-thread.c:(.text+0x29)：对‘pthread_create’未定义的引用
    7 1-thread.c:(.text+0x67)：对‘pthread_join’未定义的引用
    8 collect2: 错误： ld 返回 1
#+END_EXAMPLE

那么，-pthread与-lpthread的区别是什么呢？我们可以在verbose模式下执行一下对应的gcc命令行看出来。下面是老式的直接加
-lpthread 链接选项的输出结果：

#+BEGIN_EXAMPLE
    $ gcc -v -c x.c
    ...
    /usr/lib/gcc/i486-linux-gnu/4.2.4/cc1 -quiet -v x.c -quiet -dumpbase x.c
    -mtune=generic -auxbase x -version -fstack-protector -fstack-protector -o /tmp/cch4ASTF.s
    ...
    as --traditional-format -V -Qy -o x.o /tmp/cch4ASTF.s
    ...
    $ gcc -v x.o -ox -lpthread
    ...
     /usr/lib/gcc/i486-linux-gnu/4.2.4/collect2 --eh-frame-hdr -m elf_i386 --hash-style=both
    -dynamic-linker /lib/ld-linux.so.2 -ox
    /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crt1.o
    /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crti.o
    /usr/lib/gcc/i486-linux-gnu/4.2.4/crtbegin.o
    -L/opt/intel/Compiler/11.1/046/tbb/ia32/cc4.1.0_libc2.4_kernel2.6.16.21/lib/../lib
    -L/usr/lib/gcc/i486-linux-gnu/4.2.4
    -L/usr/lib/gcc/i486-linux-gnu/4.2.4
    -L/usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib
    -L/lib/../lib
    -L/usr/lib/../lib
    -L/opt/intel/Compiler/11.1/046/lib/ia32
    -L/opt/intel/Compiler/11.1/046/tbb/ia32/cc4.1.0_libc2.4_kernel2.6.16.21/lib
    -L/usr/lib/gcc/i486-linux-gnu/4.2.4/../../..
    x.o -lpthread -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc
    --as-needed -lgcc_s --no-as-needed
    /usr/lib/gcc/i486-linux-gnu/4.2.4/crtend.o /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crtn.o
#+END_EXAMPLE

下面是在编译和链接时分别指定 -pthread 选项的输出结果：

#+BEGIN_EXAMPLE
     1 $ gcc -v -pthread -c x.c
     2 ...
     3 /usr/lib/gcc/i486-linux-gnu/4.2.4/cc1 -quiet -v <strong>-D_REENTRANT</strong>
     4  x.c -quiet -dumpbase x.c
     5 -mtune=generic -auxbase x -version -fstack-protector -fstack-protector -o /tmp/cc205IQf.s
     6 ...
     7 as --traditional-format -V -Qy -o x.o /tmp/cc205IQf.s
     8 ...
     9 $ gcc -v x.o -ox -pthread
    10 /usr/lib/gcc/i486-linux-gnu/4.2.4/collect2 --eh-frame-hdr -m elf_i386 --hash-style=both
    11 -dynamic-linker /lib/ld-linux.so.2 -ox
    12 /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crt1.o
    13 /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crti.o
    14 /usr/lib/gcc/i486-linux-gnu/4.2.4/crtbegin.o
    15 -L/opt/intel/Compiler/11.1/046/tbb/ia32/cc4.1.0_libc2.4_kernel2.6.16.21/lib/../lib
    16 -L/usr/lib/gcc/i486-linux-gnu/4.2.4
    17 -L/usr/lib/gcc/i486-linux-gnu/4.2.4
    18 -L/usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib
    19 -L/lib/../lib
    20 -L/usr/lib/../lib
    21 -L/opt/intel/Compiler/11.1/046/lib/ia32
    22 -L/opt/intel/Compiler/11.1/046/tbb/ia32/cc4.1.0_libc2.4_kernel2.6.16.21/lib
    23 -L/usr/lib/gcc/i486-linux-gnu/4.2.4/../../..
    24 x.o -lgcc --as-needed -lgcc_s --no-as-needed <strong>-lpthread</strong>
    25  -lc -lgcc
    26 --as-needed -lgcc_s --no-as-needed
    27 /usr/lib/gcc/i486-linux-gnu/4.2.4/crtend.o /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crtn.o
#+END_EXAMPLE

所以可见编译选项中指定 -pthread
会附加一个宏定义 *-D_REENTRANT* ，该宏会导致 libc
头文件选择那些thread-safe的实现；链接选项中指定 -pthread 则同 -lpthread
一样，只表示链接 POSIX thread 库。由于 libc 用于适应 thread-safe
的宏定义可能变化，因此在编译和链接时都使用 -pthread 选项而不是传统的
-lpthread 能够保持向后兼容，并提高命令行的一致性。


** [[http://xg1990.com/blog/archives/87][Linux/Ubuntu下Octopress博客搭建过程]]

Posted on
[[http://xg1990.com/blog/archives/date/2012/03/13][2012年3月13日]] in
[[http://xg1990.com/blog/archives/category/tips][技术]]

总算搭好了这个静态博客，之前尝试了Jekyll与Jekyllbootstrap，还是不够给力，总是出现各种莫名的问题，总结下这个博客的搭建过程(Linux/Ubuntu
环境)：

**** 安装前准备

(这部分内容来自
http://gujiaxi.github.com/blog/2012/02/15/how-to-install-octopress-on-ubuntu-11-dot-04-and-deploy-on-github/)

配置前需要=curl=,=git=两个工具，安装之

sudo apt-get install curl git-core

| 1   | sudo apt-get install curl git-core   |

先确保ubuntu源中的=ruby=,=rubygem=已经卸载,如果没有，使用=sudo apt-get remove=命令卸载之

安装RVM(Ruby Version Manager)

bash -s stable &lt; &lt;(curl -s
https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer)

| 1   | bash -s stable &lt; &lt;(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer)   |

将rvm指令变成shell function

echo &#039;[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; .
&quot;$HOME/.rvm/scripts/rvm&quot;&#039;&gt;&gt;~/.bashrc

| 1   | echo &#039;[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; . &quot;$HOME/.rvm/scripts/rvm&quot;&#039;&gt;&gt;~/.bashrc   |

完毕之后重启终端，运行

type rvm | head -1

| 1   | type rvm | head -1   |

应该就能看到=rvm is a function=，说明安装成功

然后，在rvm下安装Ruby 1.9.2, RubyGems

rvm pkg install openssl rvm pkg install zlib rvm install 1.9.2 rvm use
1.9.2 rvm rubygems latest

| 1   | rvm pkg install openssl   |
| 2   | rvm pkg install zlib      |
| 3   | rvm install 1.9.2         |
| 4   | rvm use 1.9.2             |
| 5   | rvm rubygems latest       |

即可

**** 配置octopress

(这部分内容来自
http://gujiaxi.github.com/blog/2012/02/15/how-to-install-octopress-on-ubuntu-11-dot-04-and-deploy-on-github/)

下载octopress

git clone https://github.com/imathis/octopress.git octopress

| 1   | git clone https://github.com/imathis/octopress.git octopress   |

这里下载到了本地文件夹octopress ，然后依次执行

cd octopress gem install bundler bundle install rake install

| 1   | cd octopress          |
| 2   | gem install bundler   |
| 3   | bundle install        |
| 4   | rake install          |

然后就基本配置好了

添加 \(LaTeX\)

支持

(这部分内容来自
http://luikore.github.com/2011/09/good-things-learned-from-octopress/)

这里有个非常给力的 \(LaTeX\)

,排出来的公式还能够继续被识别为文字，比那些通过生成png实现的公式强多了

安装插件

gem install kramdown

| 1   | gem install kramdown   |

修改octopress目录下的_config.yml，将其中的

markdown: rdiscount

| 1   | markdown: rdiscount   |

改为

markdown: kramdown

| 1   | markdown: kramdown   |

然后修改octopress/source/_includes/custom/head.html
 向其中添加

&lt;!-- mathjax config similar to math.stackexchange --&gt; &lt;script
type=&quot;text/x-mathjax-config&quot;&gt; MathJax.Hub.Config({ jax:
[&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;], tex2jax: {
inlineMath: [ [&#039;$&#039;, &#039;$&#039;] ], displayMath: [
[&#039;$\$&#039;, &#039;$\$&#039;]], processEscapes: true, skipTags:
[&#039;script&#039;, &#039;noscript&#039;, &#039;style&#039;,
&#039;textarea&#039;, &#039;pre&#039;, &#039;code&#039;] },
messageStyle: &quot;none&quot;, &quot;HTML-CSS&quot;: { preferredFont:
&quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] }
}); &lt;/script&gt; &lt;script
src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;
type=&quot;text/javascript&quot;&gt;&lt;/script&gt;

| 1    | &lt;!-- mathjax config similar to math.stackexchange --&gt;                                                                                            |
| 2    | &lt;script type=&quot;text/x-mathjax-config&quot;&gt;                                                                                                  |
| 3    | MathJax.Hub.Config({                                                                                                                                   |
| 4    |  jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],                                                                                           |
| 5    |  tex2jax: {                                                                                                                                           |
| 6    |  inlineMath: [ [&#039;$&#039;, &#039;$&#039;] ],                                                                                                    |
| 7    |  displayMath: [ [&#039;$\$&#039;, &#039;$\$&#039;]],                                                                                                |
| 8    |  processEscapes: true,                                                                                                                              |
| 9    |  skipTags: [&#039;script&#039;, &#039;noscript&#039;, &#039;style&#039;, &#039;textarea&#039;, &#039;pre&#039;, &#039;code&#039;]                   |
| 10   |  },                                                                                                                                                   |
| 11   |  messageStyle: &quot;none&quot;,                                                                                                                      |
| 12   |  &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] }                                         |
| 13   | });                                                                                                                                                    |
| 14   | &lt;/script&gt;                                                                                                                                        |
| 15   | &lt;script src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;   |

但是此时右键单击公式会出现bug，解决办法是修改octopress/sass/base/_theme.scss如下所示比如

body - &gt; div + &gt; div#main background: $sidebar-bg border-bottom:
1px solid $page-border-bottom &gt; div background: $main-bg
border-right: 1px solid $sidebar-border

| 1   | body                                           |
| 2   | - &gt; div                                     |
| 3   | + &gt; div#main                                |
| 4   | background: $sidebar-bg                        |
| 5   | border-bottom: 1px solid $page-border-bottom   |
| 6   | &gt; div                                       |
| 7   | background: $main-bg                           |
| 8   | border-right: 1px solid $sidebar-border        |



**** 调整样式

最后，我觉得octopress的段距与行高太大了，
 修改octopress/source/stylesheets/screen.css，
 找到
 =p,blockquote,ul,ol{margin-bottom:0.5em}=
 与
 =body{line-height:1.1em;color:#222}=
 修改到合适的值即可

** [[http://blog.csdn.net/zd0303/article/details/7536967][Matlab中巧用LaTex]]

Matlab作为数据计算和处理的数学语言(软件)，而LaTex作为出版界的重要排版语言(软件)，尤其是对数学公式的排版功能特别强。在Matlab中有两种方法使用LaTeX：1）对Matlab生成的图形标注时，2）Matlab的计算结果转化成LaTeX格式。

1） 对Matlab生成的图形标注

Matlab图形中title、xlabel、ylabel、zlabel、textbox和legend等的Interpreter属性有三个属性：latex
、tex、none。默认为tex。(注：LaTeX是一套以TeX描述的宏软件。LaTeX有很多预设的模版、样式。它比TeX更为结构化，如包含了供建立索引、表格、列表等的宏和公用软件。利用这种格式，即使用户没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，对于生成复杂表格和数学公式，这一点表现得尤为突出)。

为方便利用LaTeX的命令，需要在把Matlab图形中title、xlabel、ylabel、zlabel、textbox和legend等的Interpreter属性设定为latex。首先，在Matlab中使用LaTeX语言的格式有三种：

1、\( LaTeX命令\)

2、$ LaTeX命令$

3、$$ LaTeX命令$$

以Matlab图形中的textbox属性为例，首先在图形中输入一个双重积分，然后输入一个Schrodinger方程。命令为：

x=0:0.2:2*pi;

y=sin(x);
 My_paper_figure(x,y)
 text('Interpreter','latex','String','$\rightarrow\phi
+\sin(x)$','Position',[2.2 sin(2)],'FontSize',20);
 %在坐标(2.2,sin(2)处输出-->)
 输出结果为

[[http://img.my.csdn.net/uploads/201211/02/1351820919_3763.jpg]]

当然也可以使用\(
\)命令。以此类推也可以对title、xlabel、ylabel、zlabel和legend等使用LaTeX命令，如：

xlabel({'∫x0∫ydF(u,v)'},'Interpreter','latex')

至于LaTeX命令使用方法可以参考[[http://www.sciencenet.cn/m/user_content.aspx?id=246649][LaTeX教程]]。

2）把Matlab的计算结果转化成Latex格式

 对于Matlab计算出的符号运算结果，可以通过latex()函数转化成LeTeX命令格式。由于latex()函数只对符号表达式进行转换，对于数值结果一定要通过sym()函数转化成符号结果。所以，为防止对数值结果转化出错，可同时使用latex()和sym()函数：latex(sym(s));
其中s代表符号表达式。

例如：syms a b c

s=a/b+c

使用latex(s)后转化为LeTeX命令：

{\frac {a}{b}}+c

附：数学符号和希腊字母的命令及其符号



[[http://blog.sciencenet.cn/upload/blog/images/2010/4/20104894349872.JPG]]

3）把Matlab的分析图片结果转化成Latex使用的.eps格式，以便使用latex进行编辑使用。

可以使用Latex Markup，将M-file转换成 text-file。

cell ->Insert text parkup ->Latex Markup

在编辑完M-file文件后，点击Publish 图标“[[http://write.blog.csdn.net/postedit/7537099]][[http://write.blog.csdn.net/postedit/7537099]]”的倒三角号，选择"Edit
M-File Con gurations" 窗口.

[[http://write.blog.csdn.net/postedit/7537099]][[http://write.blog.csdn.net/postedit/7537099]]

然后在"Publish settings"的对话框中，选择“Output file format”
中的“latex”选项，点击“Save as”即可。


** [[http://yaxin-cn.github.io/Python/classmethod-and-staticmethod-in-python.html][Python中的类方法和静态方法]]

*** 2014-12-22

Python类中有两个特殊的修饰符@classmethod和@staticmethod(即类方法和静态方法),
想要理解需要先理解类属性和实例属性的感念

*** 类属性和实例属性

看下面的代码

#+BEGIN_EXAMPLE
    >>> class TestProperty(object):
    ...     class_property = "class property"
    ...
    ...     def __init__(self):
    ...         self.instance_property = "instance property"
    >>>
    >>> test_property = TestProperty()
    >>> # 实例可以访问实例属性和类属性
    >>> print test_property.class_property
    class property
    >>> print test_property.instance_property
    instance property
    >>> # 类可以访问类属性
    >>> print TestProperty.class_property
    class property
    >>> # 但不可以访问实例属性
    >>> print TestProperty.instance_property
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    AttributeError: type object 'TestProperty' has no attribute 'instance_property'
    >>> # 注意下面的报错
    >>> del test_property.class_property
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    AttributeError: class_property
#+END_EXAMPLE

总结起来就是:

1. *实例属性*的初始化在=__init__=构造器方法中进行(当然也可以通过其它方法赋值)
2. *类实例*可以访问实例属性和类属性
3. 通过类本身则能访问类属性,无法访问实例属性
4. 类属性与类实例没有任何关系
5. 类属性其实就是其它语言中的静态变量(变量前加static)
6. 为什么要有类属性, 一句话*命名空间*

*** 类方法和静态方法

#+BEGIN_EXAMPLE
    >>> class TestMethod(object):
    ...     class_property = "class property"
    ...     def __init__(self):
    ...         self.instance_property = "instance property"
    ...     def instance_method(self, arvg):
    ...         print "instance_method(%s, %s)" % (self, arvg)
    ...         print "instance property: ", self.instance_property
    ...     @classmethod
    ...     def class_method(cls, arvg):
    ...         print "class_method(%s, %s)" % (cls, arvg)
    ...         print "class property: ", cls.class_property
    ...     @staticmethod
    ...     def static_method(arvg):
    ...         print "static_method(%s)" % arvg
    ...
    >>>
    >>> test_method = TestMethod()
    >>> # 执行普通方法, 打印出实例的内存地址和实例属性
    >>> test_method.instance_method("Hello")
    instance_method(<__main__.TestMethod object at 0x7fd8fc56eb90>, Hello)
    instance property:  instance property
    >>> # 执行类方法
    >>> # 通过实例访问, 打印出类本身和类属性
    >>> test_method.class_method("Hello")
    class_method(<class '__main__.TestMethod'>, Hello)
    class property:  class property
    >>> # 通过类直接访问, 同上
    >>> TestMethod.class_method("Hello")
    class_method(<class '__main__.TestMethod'>, Hello)
    class property:  class property
    >>> # 执行静态方法
    >>> # 通过实例访问, 打印出静态方法本身
    >>> test_method.static_method("Hello")
    static_method(Hello)
    >>> # 通过类直接访问, 同上
    >>> TestMethod.static_method("Hello")
    static_method(Hello)
#+END_EXAMPLE

可以看出类方法中=cls=代表的是类本身,
如果将类方法中的访问类属性的cls去掉, 则会报出/NameError/的错误

#+BEGIN_EXAMPLE
    >>> class TestMethod(object):
    ...     class_property = "class property"
    ...     @classmethod
    ...     def class_method(cls, arvg):
    ...         print "class property: ", cls.class_property
    ...
    >>> TestMethod.class_method("Hello")
    class property:
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 5, in class_method
    NameError: global name 'class_property' is not defined
#+END_EXAMPLE

1. *类方法是为了访问类属性更加方便*
2. 类方法和静态方法可以通过类和实例来访问,效果是相同的
3. 静态方法跟普通函数没有什么区别

可以通过在实例方法中直接通过=TestMethod.class_property=来访问,
但是这样不方便也不好维护(如果类名称改了,就会出错),
也可以使用=self.class_property=来访问, 但注意,
实例本身获取的并不应该是类属性即=TestMethod.class_property=,
只是因为实例中并没有=class_property=这个变量,
而是通过查找类属性,发现有同名变量,然后打印出来,通过上面无法实例无法删除类属性是可以看出来的.
当然,如果不信,可以看下面的例子

#+BEGIN_EXAMPLE
    >>> class TestMethod(object):
    ...     class_property = "class property"
    ...     def __init__(self):
    ...         pass
    ...
    >>> test_method = TestMethod()
    >>> id(test_method.class_property)
    140488040794968
    >>> id(TestMethod.class_property)
    140488040794968
    >>> print test_method.class_property
    class property
    >>> test_method.class_property = test_method.class_property + "!!!"
    >>> print test_method.class_property
    class property!!!
    >>> print TestMethod.class_property
    class property
    >>> id(test_method.class_property)
    140488040795080
    >>> id(TestMethod.class_property)
    140488040794968
#+END_EXAMPLE

** http://www.emacswiki.org/emacs/DeletingWhitespace

** [[http://www.cnblogs.com/emouse/p/3483774.html][Altium Designer 13 安装完整元件库]]

Altium Designer更新的非常快，都快赶上chrome了，13出来没多久14又出来了，之前一直用AD9.4，算是10之前的最后一个版本，也是很经典的一个版本。安装新版本后看到在目录结构上有些编号，元件库和示例文件从原来的安装根目录调整到C:\Users\Public\Documents\Altium\AD13文件夹中，而且元件库也默认只安装了一部分，包含常用的库和FPGA库，如下图所示。



更多的库可以在线下载（需要自己申请账号）http://designcontent.live.altium.com/#UnifiedComponents 也可以通过之前老版本的安装包再安装。

通过之前的老版本安装的方式也很简单，在老的安装包中元件库是单独存在的，在安装的时候会跟着一起安装，因此可以使用之前的安装包安装。

我用的是AD9.4的安装包，安装路径如下I:\AltiumDesignerSummer9Build9.4.0.20159\Setup\Board Level Libraries 点击Setup.exe即可安装，注意安装的目录，安装完成后即可得到老版本中完整的元件库。


** [[https://linuxtoy.org/archives/top-5-screen-recorder-for-linux.html][Linux 下值得使用的 5 个屏幕录像软件]]

2008-06-23 By [[https://linuxtoy.org/author/toy.html][toy]] Posted in
[[https://linuxtoy.org/category/tools.html][Tools]] Tagged as
[[https://linuxtoy.org/tag/screen-recorder.html][screen recorder]]
[[https://linuxtoy.org/tag/top-5.html][top 5]] Edit on
[[https://github.com/xuxiaodong/linuxtoy.org/blob/master/content/top-5-screen-recorder-for-linux.md][GitHub]]

在很多时候，我们需要将在 Linux
桌面上的操作过程录制下来，比如制作屏幕演示、视频教学等。这里将介绍在
Linux 下值得使用的 5 个屏幕录像软件，包括
Istanbul、Wink、Xvidcap、Vnc2swf、Recordmydesktop，希望对有此需求的朋友提供参考。

1. *[[http://linuxtoy.org/archives/istanbul.html][Istanbul]]* 使用
   Istanbul，你可以将 Linux 屏幕上的一切操作过程录制下来。Istanbul
   既能够按照你的需要录制全屏、区域或者窗口，也可以录制声音和鼠标指针，最终会生成
   Ogg Theora 格式的视频文件。
2. *[[http://linuxtoy.org/archives/wink.html][Wink]]* Wink 是录制 Flash
   视频演示的极好工具，除支持 Linux 平台外，也能够在 Windows
   系统上运行。你可以使用 Wink 为所录制的文件添加文字说明和声音旁白。
3. *[[http://linuxtoy.org/archives/xvidcap.html][Xvidcap]]* Xvidcap
   支持生成 avi、mpeg、asf、flv、swf、mov
   等视频格式，可以应用在各种场合。录制的区域也可以随意选择，显得非常方便。
4. *[[http://linuxtoy.org/archives/vnc2swf.html][Vnc2swf]]* Vnc2swf 是继
   Wink 外适合在 Linux 中使用的另一个 Flash 录制工具，但比 Wink
   稍微要难用点，而且也没有 Wink 功能全面。
5. *[[http://linuxtoy.org/archives/recordmydesktop.html][Recordmydesktop]]*
   Recordmydesktop
   功能主要有：可录制全屏、窗口，也可以录制选择的区域；除了能够录制视频的基本功能之外，还能够录制音频；有一些录制的参数可以调整；生成的视频格式为
   ogg。它默认提供 GTK+ 界面，另外也有一个适合 KDE 桌面环境的
   [[http://linuxtoy.org/archives/rekordmydesktop.html][reKordmydesktop]]。

** [[http://blog.useasp.net/archive/2014/09/05/rst-file-restructuredtext-markup-syntax-quikstart.aspx][reStructuredText(.rst)语法规则快速入门]]


这几天写了个[[http://blog.useasp.net/tags/Python][Python]]的模块，用Markdown写个个README，传到GitHub，感觉效果还不错，就难抑冲动，打了个包，也想放到PyPI上，结果放上去，发现README变成了源代码。一查，才发现PyPI竟然不支持Markdown格式的README文件，好像支持的README要reStructuredText格式的，对菜鸟的我来说这是个坑啊，好不容易在Emacs下用Markdown用的有点熟路了，结果发现却不被支持。只好重新看看reStructuredText的语法了，因此，也就有了此篇reStructuredText语法快速入门。

先文绉绉的来一段[[http://blog.useasp.net/tags/reStructuredText][reStructuredText]]的介绍吧：

reStructuredText是一种轻量级的文本标记语言，直译为：重构建的文本，为Python中Docutils项目的一部分。其一般保存的文件以.rst为后缀。在必要的时候，.rst文件可以被转化成PDF或者HTML格式，也可以有Sphinx转化为LaTex,man等格式，现在被广泛的用于程序的文档撰写。

 好了，时间无多，直接正题：

reStructuredText大致分章节，段落，块和列表这几种内容。而在这其中reStructuredText最主要用得到的标记也就是：

-  [[#title][标题]]
-  [[#paragraph][段落]]
-  [[#list][列表]]
-  [[#table][表格]]
-  [[#block][块（如：代码块）]]
-  [[#style][样式]]

下面一一介绍：





*标题（Title）*

来看看标题的实例：

#+BEGIN_EXAMPLE
    ===================
    这就是一个标题
    ===================

    ----------------
    这也是一个章节标题
    ----------------
#+END_EXAMPLE

怎么样，看起来不难吧，你只要按这个写法，就能被reStructuredText认识，并被解释为章节标题。reStructuredText可用于作为标题修饰的字符有很多很多：

#+BEGIN_EXAMPLE
    ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~
#+END_EXAMPLE

只要你想，上面的任意一个都可以用来作为标题的修饰符，当然，reStructuredText也是有推荐的，它推荐下面这些字符：

#+BEGIN_EXAMPLE
    = - ` : . ' " ~ ^ _ * + #
#+END_EXAMPLE

这些字符是上面一堆字符中稍微看起来不会那么奇怪的一部分，当然，个人建议不要那么花哨，尽量用这两个中的一个：

#+BEGIN_EXAMPLE
    = -
#+END_EXAMPLE

上面实例的写法也许有点复杂，.rst文件中，你还可以只给出下半部分的字符即可：

#+BEGIN_EXAMPLE
    这个标题和上面的一样
    ===================
#+END_EXAMPLE

TIPS：作为修饰的字符长度要大于等于文字长度。另外，标题是能够嵌套的。



*段落（Paragraphs）*

段落一般隶属于某个章节中，是一块左对齐并且没有其他元素体标记的块。在.rst文件中，段落和其他内容的分割是靠空行来完成，如果段落相较于其他的段落有缩进，reStructuredText会解析为引用段落，样式上有些不同。

#+BEGIN_EXAMPLE
    这里是一段reStructuredText的内容，它可以很长很长。。。。最后，末尾留出空行表示是本段落的结束即可。


    这里是另外一段reStructuredText的内容，这段内容和上一段之间，乃至后面的其他内容之间都要留出空行进行分割。

        这个也是段落，当时由于缩进了，会变成引用段落。显示和直接的段落有点不同
#+END_EXAMPLE



*列表(List)*

列表在HTML中被分为两种，一个是有序列表（Enumerated
Lists），一种是无序列表（Bullet
Lists），在reStructuredText中，我们也能找到这两种列表，还有一种称为定义列表（Definition
Lists），这和HTML中的DL一样，在.[[http://blog.useasp.net/tags/rst文件][rst文件]]中可以支持嵌套列表。

/无序列表/要求文本块是以下面这些字符开始，并且后面紧跟空格，而后跟列表项的内容，其中列表项比趋势左对齐并且有与列表对应的缩进。

#+BEGIN_EXAMPLE
    * + - • ‣ ⁃
#+END_EXAMPLE

还是那句话，用最常用的几个字符就好，不用那么花哨。下面是示例：

#+BEGIN_EXAMPLE
    - 这里是列表的第一个列表项

    - 这是第二个列表项

    - 这是第三个列表项

      - 这是缩进的第一个列表项
        注意，这里的缩进要和当前列表项的缩进同步。

    - 第一级的第四个列表项

    - 列表项之间要用个空格来分割。
#+END_EXAMPLE

/有序列表/在格式上和无序列表差不多，但是在使用的前缀修饰符上，使用的不是无序列表那种字符，而是可排序的字符，可以识别的有下面这些：

#+BEGIN_EXAMPLE
    arabic numerals: 1, 2, 3, ... (no upper limit).
    uppercase alphabet characters: A, B, C, ..., Z.
    lower-case alphabet characters: a, b, c, ..., z.
    uppercase Roman numerals: I, II, III, IV, ..., MMMMCMXCIX (4999).
    lowercase Roman numerals: i, ii, iii, iv, ..., mmmmcmxcix (4999).
#+END_EXAMPLE

如果你不想使用这些，在你标明第一个条目的序号字符后，第二个开始你还可以使用"#"号来让reStructuredText自动生成需要的序号（Docutils
>= 0.3.8）。

#+BEGIN_EXAMPLE
    1. 第一项
        巴拉巴拉好多内容在这里。。。

    #. 第二项

        a. 第二项的第一小项

        #. 第二项的第二小项

    #. 第三项
#+END_EXAMPLE

 /定义列表/：每个定义列表项里面包含术语（term），分类器（classifiers，可选），
定义（definition）。术语是一行文字或者短语，分类器跟在术语后面，用“ ：
”(空格，冒号，空格）分隔。定义是相对于术语缩进后的一个块。定义中可以包含多个段落或者其他的内容元素。术语和定义之间可以没有空行，但是在定义列表前后必须要有空行的存在。下面是示例：

#+BEGIN_EXAMPLE
    术语1
        术语1的定义

    术语 2
        术语2的定义,这是第一段

        术语2的定义，第二段

    术语 3 : 分类器
        术语3的定义


    术语 4 : 分类器1 : 分类器2
        术语4的定义
#+END_EXAMPLE

 TIPS：在reStructuredText中，还有两种列表，一种是字段列表（Field
Lists），一种是选项列表（Option
Lists）。由于是rst的[[http://blog.useasp.net/tags/语法教程][语法入门教程]]，这里不做深入介绍



 *表格(Table)*

reStructuredText提供两种表格：网格表格（Grid Tables）， 简单表格（Simple
Tables）。

/ 网格表/中，共使用的符号有：

#+BEGIN_EXAMPLE
    - = | +
#+END_EXAMPLE

“-” 用来分隔行， “=“ 用来分隔表头和表体行，"|"
用来分隔列，而"+"用来表示行和列相交的节点，如下面的例子：

#+BEGIN_EXAMPLE
    +------------------------+------------+----------+----------+
    | Header row, column 1   | Header 2   | Header 3 | Header 4 |
    | (header rows optional) |            |          |          |
    +========================+============+==========+==========+
    | body row 1, column 1   | column 2   | column 3 | column 4 |
    +------------------------+------------+----------+----------+
    | body row 2             | Cells may span columns.          |
    +------------------------+------------+---------------------+
    | body row 3             | Cells may  | - Table cells       |
    +------------------------+ span rows. | - contain           |
    | body row 4             |            | - body elements.    |
    +------------------------+------------+---------------------+

    来自docutils的帮助文档.
#+END_EXAMPLE

 TIPS：表头行是可选的，如果你不需要，就可以不用"="来分割了。



/简单表格/：这种表格比网格表来说简单许多，一般用于简单的数据展示。其用于修饰的字符也仅两个而已：

#+BEGIN_EXAMPLE
    = -
#+END_EXAMPLE

一般用"="就能完成简单表格的绘制，如果有表头，同样需要用"="将它和表体(body)内容分开，否则会被视为无表头数据。

#+BEGIN_EXAMPLE
    基本形式
    ========

    `下面这种是最简单的表格形式，当然你也可以去掉表头展示。`

    =====  =====  =======
      A      B    A and B
    =====  =====  =======
    False  False  False
    True   False  False
    False  True   False
    True   True   True
    =====  =====  =======

    表内嵌入
    ========

    `下面这种简单表内有列表`

    =====  =====
    col 1  col 2
    =====  =====
    1      Second column of row 1.
    2      Second column of row 2.
           Second line of paragraph.
    3      - Second column of row 3.

           - Second item in bullet
             list (row 3, column 2).
    \      Row 4; column 1 will be empty.
    =====  =====

    表头合并
    ========

    `表头进行分类合并`

    =====  =====  ======
       Inputs     Output
    ------------  ------
      A      B    A or B
    =====  =====  ======
    False  False  False A
    True   False  True
    False  True   True
    True   True   True
    =====  =====  ======
#+END_EXAMPLE

 TIPS：列需要和"="左对齐，不然可能会导致出错；如果碰到第一列为空时，需要使用"\"来转义，不然会被视为是上一行的延续；网格表和简单表中，简单表比较适合展现简单的数据，这些数据本身不需要太复杂的展现形式，而一旦碰到需要和并单元格这类的复杂操作，可能网格表会更加适合。

表格中还有更复杂的表格形式，比如：CSV表格，列表表格。这些复杂的格式就留给有兴趣的朋友深入吧。



*块（Blocks）*

块在reStructuredText中的表现方式也有好几种，但是最常见的是文字块(Literal
Blocks)。这种块的表达非常简单，就是在前面内容结束之后，用两个冒号" ::
"(空格[Optional]，冒号，冒号）来分割，并在之后紧接着插入空行，而后放入块的内容，块内容要相对之前的内容有缩进。

#+BEGIN_EXAMPLE
    这里是块之前的的内容。。。::

       这里是块的内容。前面有缩进，空行，和::分隔符。
        此处内容会被一直视为块内容

        空行也不能阻断块内容。。

    但是，当内容像这样，不再和块内容一样缩进时，块内容就自动的结束了。
#+END_EXAMPLE

这是块的最简单方式，一般我们编写的代码块就是用这种方式表现（如下），
除此之外，.rst还有引用文字块(Quoted Literal Blocks)，行块（Line
Blocks），块引用（Block Quotes）等。

#+BEGIN_EXAMPLE
    下面是我们的测试代码：

    ::

        for i in [1,2,3,4,5]:
            print i
        # 代码块测试

    很简单的代码块测试。
#+END_EXAMPLE

 更多的块内容，请参阅官方帮助文档。



*样式(Style)*

reStructuredText中支持对文本进行样式控制，比如：粗体(Strong)，斜体(Italic)，等宽字体(Monospace)，引用( interpreted
text)。

#+BEGIN_EXAMPLE
    .. Strong Emphasis

    This is **Strong Text**. HTML tag is strong.粗体

    .. Italic, Emphasis

    This is *Emphasis* Text.这个HTML使用em， 斜体

    .. Interpreted Text

    This is `Interpreted Text`. 注意，这个HTML一般用<cite>表示

    .. Inline Literals

    This is ``Inline Literals``. HTML tag is <tt>. 等宽字体.
#+END_EXAMPLE



来点补充，如果你需要在文档中插入超链接，那么你可以像下面这样：

#+BEGIN_EXAMPLE
    我这里是一个 链接_.

    .. _链接: http://blog.useasp.net
#+END_EXAMPLE

这种方式要求定义链接，而后引用链接。而且链接要有空格分隔前面的文字。这种方式略嫌麻烦，你可以用更加简化的方式------个人比较推荐：

#+BEGIN_EXAMPLE
    这里同样是一个 `链接<http://blog.useasp.net>`_，不需要特别设置。
#+END_EXAMPLE

TIPS：
我们会发现，两个处理连接的时候，都需要在链接文字前面要空格与前面进行分割，这个在英文当中比较好处理，因为单个词之间有空格，而在中文中，字之间没有空格，如果加入空格，在显示时会有空格，影响观感，为此，如果在中文中使用，需要考虑好。

到此为止，reStructuredText这个[[http://blog.useasp.net/tags/标记语言][标记语言]]的基本用法已经展现完毕，进入实战吧，骚年！



参考文献：

1.
[[http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html][reStructuredText
Markup Specification]] (本文有些例子是来源于此页面)

2.
在线reStructuredText编辑器，[[http://rst.ninjs.org/][编辑器1]]，[[https://www.notex.ch/][编辑器2]]

** [[http://blog.csdn.net/zd0303/article/details/7775657][PDF文档的矢量图提取详解]]

标签：
[[http://www.csdn.net/tag/%e6%96%87%e6%a1%a3][文档]][[http://www.csdn.net/tag/postscript][postscript]][[http://www.csdn.net/tag/%e8%af%ad%e8%a8%80][语言]][[http://www.csdn.net/tag/adobe][adobe]][[http://www.csdn.net/tag/%e5%9b%be%e5%bd%a2][图形]][[http://www.csdn.net/tag/google][google]]

2012-07-23 15:34 7180人阅读 [[#comments][评论]](2)
[[javascript:void(0);][收藏]] [[#report][举报]]

[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

计算机/（12）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/zd0303/article/category/855208][作者同类文章]]/X/

在做软件的时候，经常需要用到一些LOGO图片。如何从素材文档中提取出高分辨率、背景透明的LOGO是我一直关注的问题。对于素材文档是JPG、BMP等点阵格式的图片，那没有办法，只能老老实实地抠出来。不过很多LOGO图片，一般是PDF格式或EPS格式的文档的。假如这些文档中的LOGO是以矢量图的形式存在的话，就可以从这些文档中提取出任意分辨率的LOGO了。本文以ST的LOGO为例，说明提取的过程。



*1. PDF文档里面的矢量图*


PDF文件很常用，很早就知道，PDF里面的文字一般是用矢量的方式保存的。直到最近，才发现原来PDF除了能贴点阵图之外，还可以存矢量图（比较孤陋寡闻，呵呵）。举例说明PDF里面的矢量图。下图是ST公司的某芯片手册PDF文档里面的LOGO放大到1200%的效果，依然平滑，没有锯齿。很明显，这个LOGO就是矢量图。

 [[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/ST_LOGO.JPG]]



*2. EPS文档*


以前没有怎么接触过EPS文档。前一阵提取一个LOGO，同时有PDF和EPS两种格式，但是EPS格式的文档用Photoshop却死活打不开。于是没有管它。后来google了一下，大致了解了一下EPS文档格式：



  eps 文件是封装的PostScript（Encapsulated
PostScript）格式。PostScript语言是Adobe
公司设计用于向任何支持PostScript语言的打印机打印文件的页面描述语言。除了它是被优化用于纸张上打印文字和图像之外，它像Basjc
语言、C语言或任何其它编程语言一样。当你在
PostScript打印机上工作并告诉文字处理器（或任何其它的应用程序）打印页面时，计算机就会用PostScript语言编写一个程序描述该页面，并将这个程序传送给打印机。打印机实际上其中装有一台功能齐全的计算机和PostScript
语言解释器执行这个程序，将图形画在内存中的虚拟纸张上，然后将其打印到纸上。


直到今天才无意中发现，原来PDF文档可以导出为EPS格式，然后用Photoshop打开这个EPS文件，就可以获得任意分辨率的图片。下面介绍这个提取过程。



*3. 提取过程详解*


首先要说一下用到的辅助工具：PDF编辑器。因为一般PDF是以页面的形式存在的，如果直接导出到EPS文件，那么在用Photoshop打开EPS文件的时候，由于使用的分辨率很高，会占用大量内存。因此，需要用PDF编辑器把想要的LOGO复制出来，其余的“咔嚓”掉。我使用的PDF编辑器是Foxit
PDF Editor，下面以此为例说明。



 *第一步：在Foxit PDF
Editor中打开想要提取的PDF文件，选定矢量图，然后复制。*



[[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/1.JPG]]



 *第二步：在Foxit PDF
Editor中新建PDF文档，要注意文档页面尽量小，恰好装下这个图片就好了。这里选择宽80，高60。*



 [[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/2.JPG]]

  选择“粘贴”之后，图片就被复制到新建的PDF文档里面了。

 [[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/3.JPG]]


稍微发挥一下技巧，会发现其实复制的内容并不是全都有用的：Ctrl+A全选，将选择的内容移动到灰色区域，发现刚才把多余的白色背景也拷贝了进来。

 [[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/4.JPG]]



  单击白色背景区域将其选择，按DEL键删除，变成了这个样子：

[[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/5.JPG]]



  全选图形，将它放回文档的页面区域即可。最后保存该PDF文档。



 *第三步：由PDF导出EPS文档。*

  使用Acrobat 8
Professional打开刚才生成的PDF文档，选择“文件(F)”-->“导出(T)”-->“PostScript”-->“内嵌式PostScript”将其导出到EPS文件（至于什么版本的Acrobat有这个功能，我没有研究过，反正Acrobat
8 Professional可以）。



 *第四步：使用Photoshop将EPS矢量图打开。*


这是最后一步，也是体会收获喜悦的一步，因为在这里你可以设置图片为任意大的分辨率。

 [[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/6.JPG]]




点“确定”之后，得到的就是一个背景透明的高分辨率的图片了。补充一下，此时的图片已经是点阵图了，也就是说，如果你在这里放大，就会失真了。

[[http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/7.JPG]]




好了，大功告成。这个时候，只需要保存好EPS文件，以后再用到这个图片的时候，用Photoshop打开它，便可以得到任意你想要的分辨率图片了。

** [[http://blog.163.com/brave_smile_heart/blog/static/1872381712012619113640957/][openocd 命令行烧写ARM裸机程序 problems and solutions  ]]

摘要：  以前是用RVDS 的IDE来烧写调试ARM程序的，不过RVDS虽然是集成化的调试工具调试起来方便，但是有的时候只知其一，不知其二，只知道按部就班的来点击按钮，忽略了一些本质性的东西。而且RVDS还有一个不好的地方是它只能在windows平台下运行，不支持Linux OS。为了便于学习Linux，使用Openocd会是个不错的选择，可以学习gnu 汇编，Makefile编写，工具链命令行使用。   如果这些命令搞熟悉了，你还可以利用Qt 来做个自己的图形化界面烧写调试工具。（不过这只是个壳子而已，精髓在于openocd ，所以如果有时间你还可以分析一下Openocd的源码，因为它是开源的，开源的东西就是好，它可以满足你的好奇心，虽然有些时候不是我们在玩代码而是代码在玩我们，(*^__^*) ）。好了，废话不多说了。现列出我碰到的一些问题以及其解决办法，与诸位共享。
目录：
1.前提条件
2.执行的命令
3.执行命令时会遇到的问题
详细： details
1.前提条件
前提是你安装好了openocd .  并且Openocd的配置文件也准备好。运行起。
2.命令搞起 ：
2.1 运行ｏｐｅｎｏｃｄ．ｃｆｇ配置文件．　　　
首先我修改了samsung_s3c6410.cfg文件
在samsung_s3c6410.cfg中添加了如下语句
set _NANDNAME $_CHIPNAME.nand
nand device $_NANDNAME s3c6410 $_TARGETNAME
#openocd -f jlink.cfg -f samsung_s3c6410.cfg
运行如下：　
openocd 命令行烧写ARM裸机程序   problems and solutions - Melchior - Melchiors Home
以为ｏｐｅｎｏｃｄ不支持ｓ３ｃ６４１０的ｎａｎｄ擦写功能。于是看了/board/mini6410.cfg中有段内容如下：　

targets
nand device $_CHIPNAME.flash s3c6400 $_CHIPNAME.cpu
明明是６４１０，为什么要写成6400呢 ，不管了 ，于是试着修改samsung_s3c6410.cfg文件为
set _NANDNAME $_CHIPNAME.nand
nand device $_NANDNAME s3c6400 $_TARGETNAME

结果就ok 了  。
2.2 上面一步就完成jlink识别ARM的工作了。而且建立了telnet 服务器端口号 。现在我们要通过telnet与之建立通信 ，好能来使用openocd
#telnet localhost 4444(telnet端口号设置为4444)
openocd 命令行烧写ARM裸机程序   problems and solutions - Melchior - Melchiors Home
> halt
target state: halted
target halted in ARM state due to debug-request, current mode: Supervisor
cpsr: 0x000001d3 pc: 0x00000030
> nand probe 0
NAND flash device 'K9GAG08 2GB NAND 3.3V x8 MLC 2b/cell (Samsung)' found
> nand erase 0 0 0x100000（注：这个值应该是板子nand flash块的整数倍，0x100000为1M空间，足矣）

s3c2440_read_block_data: reading data: 0x8b94260, 0xbfe53d7a, 6
erased blocks 0 to 1 on NAND flash device #0 'K9GAG08 2GB NAND 3.3V x8 MLC 2b/cell'
> nand write 0 led.bin 0
couldn't open led.bin
failed to open 'led.bin' for read access
in procedure 'nand'

solution: 无法读取led.bin，那我们就改为绝对路径来试试  ：　
> nand write 0 /home/melchior/arm-work/1th_led/led.bin 0
> reset
JTAG tap: s3c6410.etb tap/device found: 0x2b900f0f (mfg: 0x787, part: 0xb900, ver: 0x2)
JTAG tap: s3c6410.cpu tap/device found: 0x07b76f0f (mfg: 0x787, part: 0x7b76, ver: 0x0)
found ARM1176

这样就ｏｋ了，ＡＲＭ板子上的ｌｅｄ就亮起来了　。　　

** [[http://forum.ubuntu.org.cn/viewtopic.php?f=97&t=327501][Linux系统下去烧录单片机]]

怎样在Linux系统下去烧录单片机51,avr,pic,fpga等实现实时控制子系统


｛编辑器｝：
首先介绍一下编辑器，emacs,vi,geany,等通用编辑器，（本人用终端的nano编辑器），把源代码编辑好之后进入以下环节。
二进制和hex编辑器有 beav, bless, bvi,lfhex等是不错的bin和hex文件的编辑器。
｛编译器｝:
其次是用软件把源代码编译成微控制器可以识别的代码，这里必须用的就是sdcc编译器(Small Device C Compiler)和gcc,gcc-avr，gcc-m68x,等。
＊SDCC 是小型器件c编译器，集成和优化的ANSI- C编译器目标是可以对英特尔8051，maxium,80DS390，Zilog公司的Z80和摩托罗拉68HC08微控制器。工作是支持 Microchip的PIC16和PIC18系列的进展。SDCC是自由开放源码软件，在GNU通用公共许可证（GPL）发布。
编程的语言以c和汇编为主。
＊gcc就太熟悉了。


还有一些专门针对固定器件的编译器：
01. mcu8051 ide, ASEM51(汇编），UISP, as31, dis51,等是专门针对51系列单片机的编译软件；
02. avra,avarice,arduino ide 等是专业针对avr系列进行编译的软件；
03, pikdev, piklab,gputil(兼容MPASM）等软件是专业针对microchip公司的pic和dspic系列的芯片进行编译和反编译的软件。
04. a56, crasm, biuntils-m68hc1x等是专业针对motorola, freescale 的 编译软件。
05，z80asm , z80dasm是专业针对zilog的 z80器件进行编译的软件。
等等... ... 很有很多

｛烧录软件｝和｛jtag在线调试｝


把编译的代码可以直接烧录到芯片中，这个是开发的必经之路。必须确定烧录硬件的可行性和正确性等，然后进行烧录。


01， 51系列的ASEM51支持的最多，http://plit.de/asem-51/derivat.htm， 几乎支持所有厂家的8051各个型号芯片。用BOOT-51写入到eeprom.
这个软件也是教程最完善的一个。
02.MCU 8051 这个IDE包含模拟仿真器，源代码编辑器，汇编器，硬件编程器和许多其他工具。是工具最全的51开发环境。
http://mcu8051ide.sourceforge.net/
03.s51dude,是一个专业的，基于终端的针对AT89S8252，AT89s53的isp烧录软件，usbtiny.
http://gd.tuwien.ac.at/opsys/linux/debi ... s/s51dude/
04.uisp, 是一个专业的，基于终端的针对AT89S518252，AT89s52的isp烧录软件,
http://www.nongnu.org/uisp/
05,usbprog,是一个针对usb转rs 232 的一个烧录软件，主要应用到avr 和 arm的固件烧录,（有一个固定的硬件）。
http://www2.embedded-projects.net/index.php?page_id=165
06，arduino是一个有专业电路板（arduino电路板）的avr 的集成开发环境（有一个固定硬件）。
http://www.arduino.cc/
07，avrp是一个针对flash和eeprom的烧录软件，应用到avr 8位系列的单片机和 at89系列的单片机。
http://www.colargol.tihlde.hist.no/~jonah/el/avrp.html
08，avrprog是一个针对atmel公司的avr系列的isp烧录软件，基于通过pc的并口转串口器件的烧录。
http://sourceforge.net/projects/avrprog/
09，avrdude是一个针对avr的isp烧录软件，针对rom和eeprom,基于终端操作。
http://www.nongnu.org/avrdude/
10，gdb avr, 是一个源代码调试软件，基于avr.
http://packages.debian.org/search?keywords=gdb-avr
11. picp,是一个比MPlab要快的软件，支持PICSTAR，Warp-13 or JuPic等编程器。
http://pp06.sourceforge.net/picp.html
12，pikdev是一个集成开发环境，同时支持并口，串口和usb全系列编程器进行烧录pic和dspic全系列的芯片。（piklab是基于pikdev开发的）。
http://pikdev.free.fr/


13，ARM和FPGA等一些支持jtag的芯片可以直接用openOCD, openwince-jtag, urjtag进行调试。
http://openocd.berlios.de/web/
http://urjtag.org/
14，TI系列的就可以用TI CCS 5.0.2 进行开发， 详细可见:TI CCS 5.0.1 支持linux
下载地址:http://processors.wiki.ti.com/index.php/Category:Code_Composer_Studio_v5


｛仿真软件和仿真器｝：同时可以用相关的专业软件进行仿真。
比如emu8051可以仿真51系列，gnusim8085是intel 8085的ide软件，simulavr，avarice可以仿真avr系列，gpsim,simulpic,nitpic等针对microchip公司的pic和dspic系列， softgen,是专业针对arm和dsp等进行嵌入仿真的软件，spim是mips R2000/R3000系列的仿真，coldfire是freescalecoldfire 5206仿真器， freeHDL是VHDL 在linux 环境下的仿真软件，verilator是一个verilog的仿真软件，sdcc-ucsim是一个MCS51 family, HC08 and Z80通用的仿真软件，
｛基础电路设计｝
qucs是一个不错的基础电路设计和仿真软件。
kicad是一个支持3d仿真的pcb设计软件，　包括原理图和元件库等。也可以选择eagle, geda, pcb等开源pcb软件。


总结：


到此，相信电子爱好者，同时也是Linux和开源铁杆用户们，可以尽情的去开发

** [[http://www.uzzf.com/soft/63096.html][电脑录音软件]]


Wondershare Streaming Audio Recorder 是一款易于使用的程序，可让您录制某网站上播放的歌曲或任何网页的背景音乐。本程序通过使用虚拟声卡，能够检测任何流音频。它可以记录在线音乐商店和在线广播电台的音频信号。即使是受到 DRM 保护的音乐文件，它也能轻松捕捉到。

您可以编辑和自定义录制好的文件，也可调整采样率和伴音通道等设置。音频文件可录制成高保真 MP3、WMA 和 WAV 等其他常见音频格式。此外，您还可在便携式设备上保存文件，如 iPod、iPhone 和 PSP 等。

借助 Wondershare Streaming Audio Recorder，您可随心所欲地录制音乐。

** http://www.dll-files.com/

** [[http://blog.csdn.net/yuzhongchun/article/details/11537829][Arduino的数据类型]]


2013-09-10 20:27 3611人阅读 [[#comments][评论]](0)
[[javascript:void(0);][收藏]] [[#report][举报]]

[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

Arduino/（2）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/yuzhongchun/article/category/1616091][作者同类文章]]/X/

| 数据类型        | 字节   | 范围                           | 备注                                          |
| void            |        |                                | 只用作函数声明，表示没有返回值                |
| boolean         |        | true,false                     | 每一个布尔变量占一个字节的内存                |
| char            | 1      | -128~127                       |                                               |
| unsigned char   | 1      | 0~255                          |                                               |
| byte            | 1      | 0~255                          |                                               |
| int             | 2      | -32768~32767                   | 在Arduino Due上是4个字节                      |
| unsigned int    | 2      | 0~65535                        |                                               |
| word            | 2      | 0~65535                        |                                               |
| long            | 4      | -2147483648~2147483647         |                                               |
| unsigned long   | 4      | 0~2\^32-1                      |                                               |
| short           | 2      | -32768~32767                   |                                               |
| float           | 4      | -3.4028235E+38~3.4028235E+38   | 只有6~7位小数精度                             |
| double          | 4      |                                | 在Arduino Due上有8个字节，其余的跟float一样   |
| string          |        |                                | 相当于char类型的数组                          |
| String          |        |                                | object                                        |
| array           |        |                                | 数组                                          |

参考：[[http://arduino.cc/en/Reference/HomePage][http://arduino.cc/en/Reference/HomePage]]

** [[http://blog.csdn.net/huang_xw/article/details/8760403][【C++11】新特性------auto的使用]]

C++11中引入的auto主要有两种用途：自动类型推断和返回值占位。auto在C++98中的标识临时变量的语义，由于使用极少且多余，在C++11中已被删除。前后两个标准的auto，完全是两个概念。

*** 1. 自动类型推断


auto自动类型推断，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推断，可以大大简化我们的编程工作。下面是一些使用auto的例子。

#+BEGIN_EXAMPLE
    #include <vector>
    #include <map>

    using namespace std;

    int main(int argc, char *argv[], char *env[])
    {
    //  auto a;                 // 错误，没有初始化表达式，无法推断出a的类型
    //  auto int a = 10;        // 错误，auto临时变量的语义在C++11中已不存在, 这是旧标准的用法。

        // 1. 自动帮助推导类型
        auto a = 10;
        auto c = 'A';
        auto s("hello");

        // 2. 类型冗长
        map<int, map<int,int> > map_;
        map<int, map<int,int>>::const_iterator itr1 = map_.begin();
        const auto itr2 = map_.begin();
        auto ptr = []()
        {
            std::cout << "hello world" << std::endl;
        };

        return 0;
    };

    // 3. 使用模板技术时，如果某个变量的类型依赖于模板参数，
    // 不使用auto将很难确定变量的类型（使用auto后，将由编译器自动进行确定）。
    template <class T, class U>
    void Multiply(T t, U u)
    {
       auto v = t * u;
    }
#+END_EXAMPLE

*** 2. 返回值占位

#+BEGIN_EXAMPLE
    template <typename T1, typename T2>
    auto compose(T1 t1, T2 t2) -> decltype(t1 + t2)
    {
       return t1+t2;
    }
    auto v = compose(2, 3.14); // v's type is double
#+END_EXAMPLE

*** 3.使用注意事项

①我们可以使用valatile，pointer（*），reference（&），rvalue
reference（&&） 来修饰auto

#+BEGIN_EXAMPLE
    auto k = 5;
    auto* pK = new auto(k);
    auto** ppK = new auto(&k);
    const auto n = 6;
#+END_EXAMPLE

②用auto声明的变量必须初始化

#+BEGIN_EXAMPLE
    auto m; // m should be intialized
#+END_EXAMPLE

③auto不能与其他类型组合连用

#+BEGIN_EXAMPLE
    auto int p; // 这是旧auto的做法。
#+END_EXAMPLE

④函数和模板参数不能被声明为auto

#+BEGIN_EXAMPLE
    void MyFunction(auto parameter){} // no auto as method argument

    template<auto T> // utter nonsense - not allowed
    void Fun(T t){}
#+END_EXAMPLE

⑤定义在堆上的变量，使用了auto的表达式必须被初始化

#+BEGIN_EXAMPLE
    int* p = new auto(0); //fine
    int* pp = new auto(); // should be initialized

    auto x = new auto(); // Hmmm ... no intializer

    auto* y = new auto(9); // Fine. Here y is a int*
    auto z = new auto(9); //Fine. Here z is a int* (It is not just an int)
#+END_EXAMPLE

⑥以为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid

#+BEGIN_EXAMPLE
    int value = 123;
    auto x2 = (auto)value; // no casting using auto

    auto x3 = static_cast<auto>(value); // same as above
#+END_EXAMPLE

⑦定义在一个auto序列的变量必须始终推导成同一类型

#+BEGIN_EXAMPLE
    auto x1 = 5, x2 = 5.0, x3='r';  // This is too much....we cannot combine like this
#+END_EXAMPLE

⑧auto不能自动推导成CV-qualifiers（constant & volatile
qualifiers），除非被声明为引用类型

#+BEGIN_EXAMPLE
    const int i = 99;
    auto j = i;       // j is int, rather than const int
    j = 100           // Fine. As j is not constant

    // Now let us try to have reference
    auto& k = i;      // Now k is const int&
    k = 100;          // Error. k is constant

    // Similarly with volatile qualifer
#+END_EXAMPLE

⑨auto会退化成指向数组的指针，除非被声明为引用

#+BEGIN_EXAMPLE
    int a[9];
    auto j = a;
    cout<<typeid(j).name()<<endl; // This will print int*

    auto& k = a;
    cout<<typeid(k).name()<<endl; // This will print int [9]
#+END_EXAMPLE

** [[http://www.cnblogs.com/pmars/archive/2012/10/16/2725511.html][c和c++中NULL和0的区别]]

1,什么是空指针常量（null pointer constant）?

[6.3.2.3-3] An integer constant expression with the value 0, or such an
expression cast to type void *, is called a null pointer constant.

这里告诉我们：0、0L、'\0'、3 - 3、0 * 17 （它们都是“integer constant
expression”）以及 (void*)0 （tyc：
我觉得(void*)0应该算是一个空指针吧，更恰当一点）等都是空指针常量（注意
(char*) 0
不叫空指针常量，只是一个空指针值）。至于系统选取哪种形式作为空指针常量使用，则是实现相关的。一般的
C 系统选择 (void*)0 或者 0 的居多（也有个别的选择 0L）；至于 C++
系统，由于存在严格的类型转化的要求，void* 不能象 C
中那样自由转换为其它指针类型，所以通常选 0 作为空指针常量（tyc:
C++标准推荐），而不选择 (void*)0。



2,什么是空指针（null pointer）?

[6.3.2.3-3] If a null pointer constant is converted to a pointer type,
the resulting pointer, called a null pointer, is guaranteed to compare
unequal to a pointer to any object or function.

因此，如果 p 是一个指针变量，则 p = 0;、p = 0L;、p = '\0';、p = 3 -
3;、p = 0 * 17; 中的任何一种赋值操作之后（对于 C 来说还可以是 p =
(void*)0;）， p
都成为一个空指针，由系统保证空指针不指向任何实际的对象或者函数。反过来说，任何对象或者函数的地址都不可能是空指针。（tyc:
比如这里的(void*)0就是一个空指针。把它理解为null pointer还是null pointer
constant会有微秒的不同，当然也不是紧要了）



3,什么是 NULL？

[6.3.2.3-Footnote] The macro NULL is defined in <stddef.h> (and other
headers) as a null pointer constant

即 NULL
是一个标准规定的宏定义，用来表示空指针常量。因此，除了上面的各种赋值方式之外，还可以用
p = NULL; 来使 p 成为一个空指针。（tyc：很多系统中的实现：#define NULL
(void*)0，与这里的“a null pointer constant”并不是完全一致的）



4,空指针（null pointer）指向了内存的什么地方（空指针的内部实现）？

标准并没有对空指针指向内存中的什么地方这一个问题作出规定，也就是说用哪个具体的地址值（0x0
地址还是某一特定地址）表示空指针取决于系统的实现。我们常见的空指针一般指向
0 地址，即空指针的内部用全 0 来表示（zero null
pointer，零空指针）；也有一些系统用一些特殊的地址值或者特殊的方式表示空指针（nonzero
null pointer，非零空指针），具体请参见C FAQ。



幸运的是，在实际编程中不需要了解在我们的系统上空指针到底是一个 zero null
pointer 还是 nonzero null
pointer，我们只需要了解一个指针是否是空指针就可以了------编译器会自动实现其中的转换，为我们屏蔽其中的实现细节。注意：不要把空指针的内部表示等同于整数
0 的对象表示------如上所述，有时它们是不同的。



5,如何判断一个指针是否是一个空指针？

这可以通过与空指针常量或者其它的空指针的比较来实现（注意与空指针的内部表示无关）。例如，假设
p 是一个指针变量，q 是一个同类型的空指针，要检查 p
是否是一个空指针，可以采用下列任意形式之一------它们在实现的功能上都是等价的，所不同的只是风格的差别。



指针变量 p 是空指针的判断：

if ( p == 0 )

if ( p == '\0' )

if ( p == 3 - 3 )

if ( p == NULL )  /* 使用 NULL 必须包含相应的标准库的头文件 */

if ( NULL == p )

if ( !p )

if ( p == q )

...

指针变量 p 不是空指针的判断：

if ( p != 0 )

if ( p != '\0' )

if ( p != 3 - 3 )

if ( p != NULL )  /* 使用 NULL 必须包含相应的标准库的头文件 */

if ( NULL != p )

if ( p )

if ( p != q )

...

6,可以用 memset 函数来得到一个空指针吗？

这个问题等同于：如果 p 是一个指针变量，那么

memset( &p, 0, sizeof(p) ); 和 p = 0;

是等价的吗？

答案是否定的，虽然在大多数系统上是等价的，但是因为有的系统存在着“非零空指针”
（nonzero null
pointer），所以这时两者不等价。由于这个原因，要注意当想将指针设置为空指针的时候不应该使用
memset，而应该用空指针常量或空指针对指针变量赋值或者初始化的方法。



7,可以定义自己的 NULL 的实现吗？兼答"NULL 的值可以是 1、2、3
等值吗？"类似问题

[7.1.3-2] If the program declares or defines an identifier in a context
in which it is reserved (other than as allowed by 7.1.4), or defines a
reserved identifier as a macro name, the behavior is undefined.

NULL 是标准库中的一个符合上述条件的 reserved identifier
（保留标识符）。所以，如果包含了相应的标准头文件而引入了 NULL
的话，则再在程序中重新定义 NULL
为不同的内容是非法的，其行为是未定义的。也就是说，如果是符合标准的程序，其
NULL 的值只能是 0，不可能是除 0 之外的其它值，比如 1、2、3 等。



8,malloc 函数在分配内存失败时返回 0 还是 NULL？

malloc 函数是标准 C
规定的库函数。在标准中明确规定了在其内存分配失败时返回的是一个 “null
pointer”（空指针）：

[7.20.3-1] If the space cannot be allocated, a null pointer is returned.

对于空指针值，一般的文档（比如 man）中倾向于用 NULL 表示，而没有直接说成
0。但是我们应该清楚：对于指针类型来说，返回 NULL 和 返回 0
是完全等价的，因为 NULL 和 0 都表示 “null
pointer”（空指针）。（tyc：一般系统中手册中都返回NULL，那我们就用NULL吧）

另外，附C FAQ上关于null pointer的解释：C FAQ：null pointer



参考：

[[http://topic.csdn.net/u/20121009/09/947a37cc-cb05-4f42-b889-a26e7253325e.html][NULL与0是否有区别？？（CSDN）]]

[[http://wenku.baidu.com/view/250567c08bd63186bcebbcc0.html][c和c++中NULL和0的区别（文库）]]

** [[http://bbs.21ic.com/icview-292853-1-1.html][卡尔曼滤波器]]

一片绿油油的草地上有一条曲折的小径，通向一棵大树。一个要求被提出：从起点沿着小径走到树下。

“很简单。” A说，于是他丝毫不差地沿着小径走到了树下。

现在，难度被增加了：蒙上眼。

“也不难，我当过特种兵。” B说，于是他歪歪扭扭地走到了树 ………. 旁。“唉，好久不练，生疏了。”

“看我的，我有 DIY 的 GPS！” C说，于是他像个醉汉似地走到了树………. 旁。“唉，这个 GPS 软件没做好，漂移太大。”

“我来试试。” 旁边一人拿过 GPS,  蒙上眼，居然沿着小径走到了树下。

“这么厉害！你是什么人?”

“卡尔曼 ! ”

“卡尔曼？！你是卡尔曼？”众人大吃一惊。

“我是说这个 GPS 卡而慢。”

** http://www.emacswiki.org/emacs/BasicNarrowing

** [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Narrowing.html][Narrowing]]

/Narrowing/ means focusing in on some portion of the buffer, making the
rest temporarily inaccessible. The portion which you can still get to is
called the /accessible portion/. Canceling the narrowing, which makes
the entire buffer once again accessible, is called /widening/. The
bounds of narrowing in effect in a buffer are called the buffer's
/restriction/.

Narrowing can make it easier to concentrate on a single subroutine or
paragraph by eliminating clutter. It can also be used to limit the range
of operation of a replace command or repeating keyboard macro.

-  C-x n n :: Narrow down to between point and mark
   (=narrow-to-region=).

-  C-x n w :: Widen to make the entire buffer accessible again
   (=widen=).

-  C-x n p :: Narrow down to the current page (=narrow-to-page=).

-  C-x n d :: Narrow down to the current defun (=narrow-to-defun=).

When you have narrowed down to a part of the buffer, that part appears
to be all there is. You can't see the rest, you can't move into it
(motion commands won't go outside the accessible part), you can't change
it in any way. However, it is not gone, and if you save the file all the
inaccessible text will be saved. The word ‘Narrow' appears in the mode
line whenever narrowing is in effect.

The primary narrowing command is C-x n n (=narrow-to-region=). It sets
the current buffer's restrictions so that the text in the current region
remains accessible, but all text before the region or after the region
is inaccessible. Point and mark do not change.

Alternatively, use C-x n p (=narrow-to-page=) to narrow down to the
current page. See [[Pages.html#Pages][Pages]], for the definition of a
page. C-x n d (=narrow-to-defun=) narrows down to the defun containing
point (see [[Defuns.html#Defuns][Defuns]]).

The way to cancel narrowing is to widen with C-x n w (=widen=). This
makes all text in the buffer accessible again.

You can get information on what part of the buffer you are narrowed down
to using the C-x = command. See
[[Position-Info.html#Position-Info][Position Info]].

Because narrowing can easily confuse users who do not understand it,
=narrow-to-region= is normally a disabled command. Attempting to use
this command asks for confirmation and gives you the option of enabling
it; if you enable the command, confirmation will no longer be required
for it. See [[Disabling.html#Disabling][Disabling]].

** [[http://blog.csdn.net/augusdi/article/details/11773943][C++11中的匿名函数(lambda函数,lambda表达式)]]


[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

C++ AMP/（74）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/Augusdi/article/category/686039][作者同类文章]]/X/

这篇文章是根据维基百科整理来的,原文请看:[[http://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B][http://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B]]

C++11提供了对匿名函数的支持,称为Lambda函数(也叫Lambda表达式).
Lambda表达式具体形式如下:

[capture](parameters)->return-type{body}

如果没有参数,空的圆括号()可以省略.返回值也可以省略,如果函数体只由一条return语句组成或返回类型为void的话.形如:

 　 [capture](parameters){body}

下面举了几个Lambda函数的例子: 　　　　

#+BEGIN_EXAMPLE
    [](int x, int y) { return x + y; } // 隐式返回类型
    [](int& x) { ++x; }   // 没有return语句 -> lambda 函数的返回类型是'void'
    []() { ++global_x; }  // 没有参数,仅访问某个全局变量
    []{ ++global_x; }     // 与上一个相同,省略了()
#+END_EXAMPLE

可以像下面这样显示指定返回类型:

#+BEGIN_EXAMPLE
    [](int x, int y) -> int { int z = x + y; return z; }
#+END_EXAMPLE

在这个例子中创建了一个临时变量z来存储中间值.
和普通函数一样,这个中间值不会保存到下次调用.
什么也不返回的Lambda函数可以省略返回类型, 而不需要使用 -> void 形式.
Lambda函数可以引用在它之外声明的变量. 这些变量的集合叫做一个闭包.
闭包被定义在Lambda表达式声明中的方括号[]内.
这个机制允许这些变量被按值或按引用捕获.下面这些例子就是:

#+BEGIN_EXAMPLE
    []        //未定义变量.试图在Lambda内使用任何外部变量都是错误的.
    [x, &y]   //x 按值捕获, y 按引用捕获.
    [&]       //用到的任何外部变量都隐式按引用捕获
    [=]       //用到的任何外部变量都隐式按值捕获
    [&, x]    //x显式地按值捕获. 其它变量按引用捕获
    [=, &z]   //z按引用捕获. 其它变量按值捕获
#+END_EXAMPLE

接下来的两个例子演示了Lambda表达式的用法.

[[][[[http://common.cnblogs.com/images/copycode.gif]]]]

#+BEGIN_EXAMPLE
    std::vector<int> some_list;
    int total = 0;
    for (int i=0;i<5;++i) some_list.push_back(i);
    std::for_each(begin(some_list), end(some_list), [&total](int x)
    {
        total += x;
    });
#+END_EXAMPLE

[[][[[http://common.cnblogs.com/images/copycode.gif]]]]

此例计算list中所有元素的总和. 变量total被存为lambda函数闭包的一部分.
因为它是栈变量(局部变量)total的引用,所以可以改变它的值.

[[][[[http://common.cnblogs.com/images/copycode.gif]]]]

#+BEGIN_EXAMPLE
    std::vector<int> some_list;
      int total = 0;
      int value = 5;
      std::for_each(begin(some_list), end(some_list), [&, value, this](int x)
      {
        total += x * value * this->some_func();
      });
#+END_EXAMPLE

[[][[[http://common.cnblogs.com/images/copycode.gif]]]]

此例中total会存为引用, value则会存一份值拷贝. 对this的捕获比较特殊,
它只能按值捕获.
this只有当包含它的最靠近它的函数不是静态成员函数时才能被捕获.对protect和priviate成员来说,
这个lambda函数与创建它的成员函数有相同的访问控制.
如果this被捕获了,不管是显式还隐式的,那么它的类的作用域对Lambda函数就是可见的.
访问this的成员不必使用this->语法,可以直接访问.
不同编译器的具体实现可以有所不同,但期望的结果是:按引用捕获的任何变量,lambda函数实际存储的应该是这些变量在创建这个lambda函数的函数的栈指针,而不是lambda函数本身栈变量的引用.
不管怎样, 因为大数lambda函数都很小且在局部作用中,
与候选的内联函数很类似, 所以按引用捕获的那些变量不需要额外的存储空间.
如果一个闭包含有局部变量的引用,在超出创建它的作用域之外的地方被使用的话,这种行为是未定义的!
lambda函数是一个依赖于实现的函数对象类型,这个类型的名字只有编译器知道.
如果用户想把lambda函数做为一个参数来传递,
那么形参的类型必须是模板类型或者必须能创建一个std::function类似的对象去捕获lambda函数.使用
auto关键字可以帮助存储lambda函数,

#+BEGIN_EXAMPLE
    auto my_lambda_func = [&](int x) { /*...*/ };
    auto my_onheap_lambda_func = new auto([=](int x) { /*...*/ });
#+END_EXAMPLE

这里有一个例子,
把匿名函数存储在变量,数组或vector中,并把它们当做命名参数来传递

[[][[[http://common.cnblogs.com/images/copycode.gif]]]]

#+BEGIN_EXAMPLE
    #include<functional>
    #include<vector>
    #include<iostream>
    double eval(std::function<double(double)> f, double x = 2.0){return f(x);}
    int main()
    {
         std::function<double(double)> f0    = [](double x){return 1;};
         auto                          f1    = [](double x){return x;};
         decltype(f0)                  fa[3] = {f0,f1,[](double x){return x*x;}};
         std::vector<decltype(f0)>     fv    = {f0,f1};
         fv.push_back                  ([](double x){return x*x;});
         for(int i=0;i<fv.size();i++)  std::cout << fv[i](2.0) << "\n";
         for(int i=0;i<3;i++)          std::cout << fa[i](2.0) << "\n";
         for(auto &f : fv)             std::cout << f(2.0) << "\n";
         for(auto &f : fa)             std::cout << f(2.0) << "\n";
         std::cout << eval(f0) << "\n";
         std::cout << eval(f1) << "\n";
         return 0;
    }
#+END_EXAMPLE

[[][[[http://common.cnblogs.com/images/copycode.gif]]]]

一个没有指定任何捕获的lambda函数,可以显式转换成一个具有相同声明形式函数指针.所以,像下面这样做是合法的:


#+BEGIN_EXAMPLE
    auto a_lambda_func = [](int x) { /*...*/ };
    void(*func_ptr)(int) = a_lambda_func;
    func_ptr(4); //calls the lambda.
#+END_EXAMPLE

** http://www.cplusplus.com/reference/sstream/stringstream/

** http://www.cplusplus.com/reference/cassert/assert/

** [[http://blog.csdn.net/sndaxdrs/article/details/6175701][shared_ptr]]

标签：
[[http://www.csdn.net/tag/iterator][iterator]][[http://www.csdn.net/tag/%e5%ad%98%e5%82%a8][存储]][[http://www.csdn.net/tag/vector][vector]][[http://www.csdn.net/tag/string][string]][[http://www.csdn.net/tag/class][class]][[http://www.csdn.net/tag/%e6%96%87%e6%a1%a3][文档]]

2011-02-09 16:22 29225人阅读 [[#comments][评论]](7)
[[javascript:void(0);][收藏]] [[#report][举报]]



shared_ptr是一个最像指针的"智能指针"，是boost.smart_ptr库中最有价值、最重要的组成部分，也是最有用的，Boost库的许多组件--甚至还包括其他一些领域的智能指针都使用了shared_ptr。抱歉，我实在想不出什么更恰当的词汇来形容它在软件开发中的重要性。再强调一遍，shared_ptr非常有价值、非常重要、非常有用。



shared_ptr与scoped_ptr一样包装了new操作符在堆上分配的动态对象，但它实现的是引用计数型的智能指针
，可以被自由地拷贝和赋值，在任意的地方共享它，当没有代码使用（引用计数为0）它时才删除被包装的动态分配的对象。shared_ptr也可以安全地放到标准容器中，并弥补了auto_ptr因为转移语义而不能把指针作为STL容器元素的缺陷。

在C++历史上曾经出现过无数的引用计数型智能指针实现，但没有一个比得上boost::shared_ptr，在过去、现在和将来，它都是最好的。

*1.  shared_ptr的线程安全性*



   shared_ptr 本身不是 100%
线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是，因为
shared_ptr 有两个数据成员，读写操作不能原子化。根据文档，shared_ptr
的线程安全级别和内建类型、标准库容器、string 一样，即：

-  一个 shared_ptr 实体可被多个线程同时读取；
-  两个的 shared_ptr 实体可以被两个线程同时写入，“析构”算写操作；
-  如果要从多个线程读写同一个 shared_ptr 对象，那么需要加锁。



*2.  shared_ptr用法*



*示例一：*

**

shared_ptr<int> sp(new int(10)); //一个指向整数的shared_ptr
assert(sp.unique()); //现在shared_ptr是指针的唯一持有者
shared_ptr<int> sp2 = sp; //第二个shared_ptr,拷贝构造函数 assert(sp ==
sp2 && sp.use_count() == 2);
//两个shared_ptr相等,指向同一个对象,引用计数为2 *sp2 = 100;
//使用解引用操作符修改被指对象 assert(*sp == 100);
//另一个shared_ptr也同时被修改 sp.reset(); //停止shared_ptr的使用
assert(!sp); //sp不再持有任何指针(空指针)



*示例二：*

class shared //一个拥有shared_ptr的类 { private: shared_ptr<int> p;
//shared_ptr成员变量 public: shared(shared_ptr<int> p_):p(p_){}
//构造函数初始化shared_ptr void print()
//输出shared_ptr的引用计数和指向的值 { cout << "count:" <<
p.use_count() << "v =" <<*p << endl; } }; void
print_func(shared_ptr<int> p) //使用shared_ptr作为函数参数 {
//同样输出shared_ptr的引用计数和指向的值 cout << "count:" <<
p.use_count() << " v=" <<*p << endl; } int main() { shared_ptr<int>
p(new int(100)); shared s1(p), s2(p); //构造两个自定义类 s1.print();
s2.print(); *p = 20; //修改shared_ptr所指的值 print_func(p);
s1.print(); }

*3. 应用于标准容器*

**

**

**

有两种方式可以将shared_ptr应用于标准容器（或者容器适配器等其他容器）。

一种用法是将容器作为shared_ptr管理的对象，如shared_ptr<list<T>
>，使容器可以被安全地共享，用法与普通shared_ptr没有区别，我们不再讨论。

另一种用法是将shared_ptr作为容器的元素，如vector<shared_ptr<T>
>，因为shared_ptr支持拷贝语义和比较操作，符合标准容器对元素的要求，所以可以实现在容器中安全地容纳元素的指针而不是拷贝。

标准容器不能容纳auto_ptr，这是C++标准特别规定的（读者永远也不要有这种想法）。标准容器也不能容纳scoped_ptr，因为scoped_ptr不能拷贝和赋值。标准容器可以容纳原始指针，但这就丧失了容器的许多好处，因为标准容器无法自动管理类型为指针的元素，必须编写额外的大量代码来保证指针最终被正确删除，这通常很麻烦很难实现。

存储shared_ptr的容器与存储原始指针的容器功能几乎一样，但shared_ptr为程序员做了指针的管理工作，可以任意使用shared_ptr而不用担心资源泄漏。





下面的代码示范了将shared_ptr应用于标准容器的用法：

#include <boost/make_shared.hpp> int main() { typedef
vector<shared_ptr<int> > vs; //一个持有shared_ptr的标准容器类型 vs
v(10); //声明一个拥有10个元素的容器，元素被初始化为空指针 int i = 0; for
(vs::iterator pos = v.begin(); pos != v.end(); ++pos) { (*pos) =
make_shared<int>(++i); //使用工厂函数赋值 cout << *(*pos) << ", ";
//输出值 } cout << endl; shared_ptr<int> p = v[9]; *p = 100; cout <<
*v[9] << endl; }





这段代码需要注意的是迭代器和operator[]的用法，因为容器内存储的是shared_ptr，我们必须对迭代器pos使用一次解引用操作符*以获得shared_ptr，然后再对shared_ptr使用解引用操作符*才能操作真正的值。*(*pos)也可以直接写成**pos，但前者更清晰，后者很容易让人迷惑。vector的operator[]用法与迭代器类似，也需要使用*获取真正的值。

** [[https://linux.cn/article-4016-1.html][如何清理 Ubuntu 14.04 的最近打开文件历史列表]]
要从dash搜索删除历史记录，请遵循以下程序。

转到系统设置（System Settings）并打开安全与隐私（Security & Privacy）。


在文件与应用（Files and Applications）标签下，点击清除用户数据（Clear Usage Data）。


你也可以关闭“记录文件与应用使用（Record file and Application usage）
以阻止系统记录你当前使用的文件和应用。






** [[http://www.latexstudio.net/archives/328][LaTeX技巧703：minted包使用环境的搭建]]

2014-02-03
分类：[[http://www.latexstudio.net/archives/category/tex-design/tex-code-design][代码输出]]
阅读(463) 评论(2)

pymentize是用来做高亮显示非常好的库，minted恰恰使用这一语法高亮库来实现代码的高亮显示，其效果做得也非常不错。下面介绍其环境的搭建过程。

[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/OLUjl.png][[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/OLUjl.png]]]]

【*安装Python环境*】

首先，安装python，推荐版本2.7，因为python软件包的管理工具setuptools只支持到2.7版本，python环境安装完毕，在操作系统的path增加环境变量：C:\Python27\Scripts\;C:\Python27\。新版的python的目录结构稍有变化，用户根据自己的实际安装路径来配置环境变量。

【*安装软件包工具*】

python环境安装好以后，可以到[[https://pypi.python.org/pypi/setuptools][https://pypi.python.org/pypi/setuptools]]下载包管理工具，可以下载.py脚本，也可以下载exe安装文件，下面是.exe安装文件的安装过程：

[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/easy-install1.png][[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/easy-install1.png]]]]

【*安装pygmentize库*】

安装好setuptool以后，可以利用命令行工具来安装相关的软件和库，这时之前设置的环境变量就会发挥其作用了。安装过程如下图所示：

输入：easy_install Pygments 即可！

[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/easy-install.png][[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/easy-install.png]]]]

*【安装验证】*

在命令行下使用pygmentize命令来测试安装是否正常。

【*代码测试*】

TeXlive新版已包含了minted宏包，若是您的系统没有安装此包，可以到[[http://code.google.com/p/minted/][http://code.google.com/p/minted/]]或者[[http://www.ctan.org/tex-archive/macros/latex/contrib/minted/][ctan]]下载安装。宏包安装完毕，可以用下面的代码来测试宏包是否可以正常使用。需要注意的是，运行的时候需要加一个参数即：-shell-escape
，如若是使用pdflatex编译，即：pdflatex -shell-escape  filename

测试代码如下：

TeX

\documentclass{article} \usepackage{minted} \begin{document}
\begin{minted}{c} int main() { printf("hello, world"); return 0; }
\end{minted} \end{document}

| 1    | \documentclass{article}   |
| 2    | \usepackage{minted}       |
| 3    | \begin{document}          |
| 4    | \begin{minted}{c}         |
| 5    | int main() {              |
| 6    | printf("hello, world");   |
| 7    | return 0;                 |
| 8    | }                         |
| 9    | \end{minted}              |
| 10   | \end{document}            |

效果图：

[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/minted.png][[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/minted.png]]]]

** [[http://blog.csdn.net/u013453604/article/details/45324121][用minted宏包在TeXWorks中插入代码高亮]]

标签：
[[http://www.csdn.net/tag/texlive][texlive]][[http://www.csdn.net/tag/texworks][texworks]][[http://www.csdn.net/tag/minted][minted]][[http://www.csdn.net/tag/Pygments][Pygments]][[http://www.csdn.net/tag/%e8%af%ad%e6%b3%95%e9%ab%98%e4%ba%ae][语法高亮]]

2015-04-28 00:43 219人阅读 [[#comments][评论]](0)
[[javascript:void(0);][收藏]] [[#report][举报]]

[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

存档/（10）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/u013453604/article/category/3149871][作者同类文章]]/X/

模式识别/（1）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/u013453604/article/category/2148725][作者同类文章]]/X/

版权声明：本文为博主原创文章，未经博主允许不得转载。

安装texlive时没有用自带的Texworks编辑器的请看这篇文章

（[[http://blog.csdn.net/gogdizzy/article/details/9136239][http://blog.csdn.net/gogdizzy/article/details/9136239]]）这是WinEdt编辑器下的操作。

一. minted宏包的使用

#+BEGIN_EXAMPLE
    \documentclass[CJK]{cctart}
    \usepackage{minted}
    \begin{document}
    \begin{minted}{c++}
    int main() {
        printf("hello, world");
        return 0;
    }
    \end{minted}
    \end{document}
#+END_EXAMPLE

效果如下
 [[http://img.blog.csdn.net/20150427235430332]]

二.使用过程遇到的报错

1. 安装texlive，选择自带的Texworks编辑器，最近的新版本都自带了minted宏包
2. 安装Python，在这里下载（[[https://www.python.org/downloads/][https://www.python.org/downloads/]]）
    并为Python设置好环境变量，这个自行百度，就是把
    D:\Python34\;D:\Python34\Scripts;加到系统环境变量path里面
3. 安装Pygments

   可以看我这个笔记，[[http://blog.csdn.net/u013453604/article/details/45319379][windows下用easy_install安装Pygments]]
    完了之后运行上面给出的代码还得报错，提示说“minted Error: You must
   invoke LaTeX with the =-shell-escape= flag”这时得启用shell escape
4. 启用shell escape

   我是TeXWorks所以很简单，“编辑器”->”首选项”->”排版”在“处理工具”那一栏的右边点加号，新建一个XeLatex+shellescape的配置，可以参照列表里的XeLatex配置，“程序”填xelates.exe，加入三个参数synctexoption，−−shell−escape，
   fullname，点击确定保存。如图所示
    [[http://img.blog.csdn.net/20150428001226422]]
    然后编译的时候选择新建的这个工具，如图
    [[http://img.blog.csdn.net/20150428002055045]]
    如果你的是WinEdt编辑器，请参照这篇启用shell escape

   （[[http://blog.csdn.net/gogdizzy/article/details/9136239][http://blog.csdn.net/gogdizzy/article/details/9136239]]）

   也可以参考国外官网论坛的帖子[[http://tex.stackexchange.com/questions/99475/how-to-invoke-latex-with-the-shell-escape-flag-in-texmakerx][How
   to invoke latex with the -shell-escape flag in TeXMakerX?]]
5. 注意\begin{minted}{c++} 这句中的c是小写的
6. minted支持300中语言的高亮，Pygments语法高亮工具提供了不同的高亮风格，具体配置见[[http://get-software.net/macros/latex/contrib/minted/minted.pdf][minted参考文档]]

   还有博客[[http://havee.me/internet/2013-08/support-pygments-in-jekyll.html][Jekyll
   中的语法高亮：Pygments]]

二.其他语法高亮方案

1. listings
    listings 是专用于代码排版的
   LaTeX宏包，可对关键词、注释和字符串等使用不同的字体和颜色或颜色，也可以为代码添加边框、背景等风格。
    但是这种方法相对于minted来说稍显麻烦，语法高亮需要自己设置。
    下面给出一份用于排版 C 语言 HelloWorld 程序代码的完整的 LaTeX 文档：

#+BEGIN_EXAMPLE
    \documentclass{ article}
    \usepackage{ listings}
    \begin{ document}
    \begin{ lstlisting}[ language=C]
    int main(int argc, char ** argv)
    {
    printf("Hello world! \n");
    return 0;
    }
    \end{ lstlisting}
    \end{ document}
#+END_EXAMPLE

注意，要使用 listings 宏包提供的语法高亮，需要 xcolor 宏包支持。

** [[http://doc-snapshots.qt.io/4.8/assistant-manual.html][The One-Minute Guide to Using Qt Assistant]]

Once you have installed Qt, /Qt Assistant/ should be ready to run:

-  On Windows, /Qt Assistant/ is available as a menu option on the Qt
   menu.
-  On Mac OS X, /Qt Assistant/ is installed in the
   /Developer/Applications/Qt directory.
-  On Unix/Linux, open a terminal, type =assistant= and press *Enter*.

When you start up /Qt Assistant/, you will be presented with a standard
main window application, with a menu bar and toolbar. Below these, on
the left hand side are navigation windows called /Contents/, /Index/ and
/Bookmarks/. On the right, taking up most of the space, is the
/Documentation/ window. By default, /Qt Assistant/ loads the Qt
reference documentation along with the manuals of other Qt tools, like
/Qt Designer/ or /Qt Linguist/.

/Qt Assistant/ works in a similar way to a Web browser. If you click
hyperlinks (cross-references), the /Documentation/ window will present
the relevant page. You can bookmark pages of particular interest and you
can click the *Previous* and *Next* toolbar buttons to navigate within
the pages you have visited.

Although /Qt Assistant/ can be used just like a Web browser to navigate
through the documentation, /Qt Assistant/ offers a powerful means of
navigation that Web browsers do not provide. /Qt Assistant/ uses an
advanced full text search engine to index all the pages in each
compressed help file so that you can search for particular words and
phrases.

To perform an index search, click the *Index* tab on the Sidebar (or
press *Alt+I*). In the *'Look For'* line edit enter a word; e.g.,
'homedirpath'. As you type, words are found and highlighted in a list
beneath the line edit. If the highlighted text matches what you're
looking for, double click it, (or press *Enter*) and the /Documentation/
window will display the relevant page. You rarely have to type in the
whole word before /Qt Assistant/ finds a match. Note that for some words
there may be more than one possible page that is relevant.

/Qt Assistant/ also provides full text searching for finding specific
words in the documentation. To activate the full text search, either
press *(Alt+S)* or click on the *Search* tab in the /Documentation/
window. Then enter the term you're looking for and hit the *Search*
button. All documents containing the specified term will then be listed
in the list box below.

[[assistant-details.html][Qt Assistant in More Detail]]

© 2015 The Qt Company Ltd. Documentation contributions included herein
are the copyrights of their respective owners.

The documentation provided herein is licensed under the terms of the
[[http://www.gnu.org/licenses/fdl.html][GNU Free Documentation License
version 1.3]] as published by the Free Software Foundation.

** [[http://www.asciima.com/][ASCII码表详解]]


ASCII码表

ASCII码大致可以分作三部分组成。


[[http://www.asciima.com/ascii/2.html][第一部分是：ASCII非打印控制字符]]
 [[http://www.asciima.com/ascii/3.html][第二部分是：ASCII打印字符]]；
 [[http://www.asciima.com/ascii/4.html][第三部分是：扩展ASCII打印字符]]

**** 第一部分：ASCII非打印控制字符表

ASCII表上的数字0--31分配给了控制字符，用于控制像打印机等一些外围设备。例如，12代表换页/新页功能。此命令指示打印机跳到下一页的开头。（参详ASCII码表中0-31）

**** 第二部分：ASCII打印字符

数字 32--126
分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。数字127代表
DELETE 命令。（参详ASCII码表中32-127）

*ASCII码表 0-127*

| Bin        | Dec   | Hex   | 缩写/字符                     | 解释           |
| 00000000   | 0     | 00    | NUL(null)                     | 空字符         |
| 00000001   | 1     | 01    | SOH(start of headling)        | 标题开始       |
| 00000010   | 2     | 02    | STX (start of text)           | 正文开始       |
| 00000011   | 3     | 03    | ETX (end of text)             | 正文结束       |
| 00000100   | 4     | 04    | EOT (end of transmission)     | 传输结束       |
| 00000101   | 5     | 05    | ENQ (enquiry)                 | 请求           |
| 00000110   | 6     | 06    | ACK (acknowledge)             | 收到通知       |
| 00000111   | 7     | 07    | BEL (bell)                    | 响铃           |
| 00001000   | 8     | 08    | BS (backspace)                | 退格           |
| 00001001   | 9     | 09    | HT (horizontal tab)           | 水平制表符     |
| 00001010   | 10    | 0A    | LF (NL line feed, new line)   | 换行键         |
| 00001011   | 11    | 0B    | VT (vertical tab)             | 垂直制表符     |
| 00001100   | 12    | 0C    | FF (NP form feed, new page)   | 换页键         |
| 00001101   | 13    | 0D    | CR (carriage return)          | 回车键         |
| 00001110   | 14    | 0E    | SO (shift out)                | 不用切换       |
| 00001111   | 15    | 0F    | SI (shift in)                 | 启用切换       |
| 00010000   | 16    | 10    | DLE (data link escape)        | 数据链路转义   |
| 00010001   | 17    | 11    | DC1 (device control 1)        | 设备控制1      |
| 00010010   | 18    | 12    | DC2 (device control 2)        | 设备控制2      |
| 00010011   | 19    | 13    | DC3 (device control 3)        | 设备控制3      |
| 00010100   | 20    | 14    | DC4 (device control 4)        | 设备控制4      |
| 00010101   | 21    | 15    | NAK (negative acknowledge)    | 拒绝接收       |
| 00010110   | 22    | 16    | SYN (synchronous idle)        | 同步空闲       |
| 00010111   | 23    | 17    | ETB (end of trans. block)     | 传输块结束     |
| 00011000   | 24    | 18    | CAN (cancel)                  | 取消           |
| 00011001   | 25    | 19    | EM (end of medium)            | 介质中断       |
| 00011010   | 26    | 1A    | SUB (substitute)              | 替补           |
| 00011011   | 27    | 1B    | ESC (escape)                  | 溢出           |
| 00011100   | 28    | 1C    | FS (file separator)           | 文件分割符     |
| 00011101   | 29    | 1D    | GS (group separator)          | 分组符         |
| 00011110   | 30    | 1E    | RS (record separator)         | 记录分离符     |
| 00011111   | 31    | 1F    | US (unit separator)           | 单元分隔符     |
| 00100000   | 32    | 20    | (space)                       | 空格           |
| 00100001   | 33    | 21    | !                             |                |
| 00100010   | 34    | 22    | "                             |                |
| 00100011   | 35    | 23    | #                             |                |
| 00100100   | 36    | 24    | $                             |                |
| 00100101   | 37    | 25    | %                             |                |
| 00100110   | 38    | 26    | &                             |                |
| 00100111   | 39    | 27    | '                             |                |
| 00101000   | 40    | 28    | (                             |                |
| 00101001   | 41    | 29    | )                             |                |
| 00101010   | 42    | 2A    | *                             |                |
| 00101011   | 43    | 2B    | +                             |                |
| 00101100   | 44    | 2C    | ,                             |                |
| 00101101   | 45    | 2D    | -                             |                |
| 00101110   | 46    | 2E    | .                             |                |
| 00101111   | 47    | 2F    | /                             |                |
| 00110000   | 48    | 30    | 0                             |                |
| 00110001   | 49    | 31    | 1                             |                |
| 00110010   | 50    | 32    | 2                             |                |
| 00110011   | 51    | 33    | 3                             |                |
| 00110100   | 52    | 34    | 4                             |                |
| 00110101   | 53    | 35    | 5                             |                |
| 00110110   | 54    | 36    | 6                             |                |
| 00110111   | 55    | 37    | 7                             |                |
| 00111000   | 56    | 38    | 8                             |                |
| 00111001   | 57    | 39    | 9                             |                |
| 00111010   | 58    | 3A    | :                             |                |
| 00111011   | 59    | 3B    | ;                             |                |
| 00111100   | 60    | 3C    | <                             |                |
| 00111101   | 61    | 3D    | =                             |                |
| 00111110   | 62    | 3E    | >                             |                |
| 00111111   | 63    | 3F    | ?                             |                |
| 01000000   | 64    | 40    | @                             |                |
| 01000001   | 65    | 41    | A                             |                |
| 01000010   | 66    | 42    | B                             |                |
| 01000011   | 67    | 43    | C                             |                |
| 01000100   | 68    | 44    | D                             |                |
| 01000101   | 69    | 45    | E                             |                |
| 01000110   | 70    | 46    | F                             |                |
| 01000111   | 71    | 47    | G                             |                |
| 01001000   | 72    | 48    | H                             |                |
| 01001001   | 73    | 49    | I                             |                |
| 01001010   | 74    | 4A    | J                             |                |
| 01001011   | 75    | 4B    | K                             |                |
| 01001100   | 76    | 4C    | L                             |                |
| 01001101   | 77    | 4D    | M                             |                |
| 01001110   | 78    | 4E    | N                             |                |
| 01001111   | 79    | 4F    | O                             |                |
| 01010000   | 80    | 50    | P                             |                |
| 01010001   | 81    | 51    | Q                             |                |
| 01010010   | 82    | 52    | R                             |                |
| 01010011   | 83    | 53    | S                             |                |
| 01010100   | 84    | 54    | T                             |                |
| 01010101   | 85    | 55    | U                             |                |
| 01010110   | 86    | 56    | V                             |                |
| 01010111   | 87    | 57    | W                             |                |
| 01011000   | 88    | 58    | X                             |                |
| 01011001   | 89    | 59    | Y                             |                |
| 01011010   | 90    | 5A    | Z                             |                |
| 01011011   | 91    | 5B    | [                             |                |
| 01011100   | 92    | 5C    | \                             |                |
| 01011101   | 93    | 5D    | ]                             |                |
| 01011110   | 94    | 5E    | \^                            |                |
| 01011111   | 95    | 5F    | _                            |                |
| 01100000   | 96    | 60    | `                             |                |
| 01100001   | 97    | 61    | a                             |                |
| 01100010   | 98    | 62    | b                             |                |
| 01100011   | 99    | 63    | c                             |                |
| 01100100   | 100   | 64    | d                             |                |
| 01100101   | 101   | 65    | e                             |                |
| 01100110   | 102   | 66    | f                             |                |
| 01100111   | 103   | 67    | g                             |                |
| 01101000   | 104   | 68    | h                             |                |
| 01101001   | 105   | 69    | i                             |                |
| 01101010   | 106   | 6A    | j                             |                |
| 01101011   | 107   | 6B    | k                             |                |
| 01101100   | 108   | 6C    | l                             |                |
| 01101101   | 109   | 6D    | m                             |                |
| 01101110   | 110   | 6E    | n                             |                |
| 01101111   | 111   | 6F    | o                             |                |
| 01110000   | 112   | 70    | p                             |                |
| 01110001   | 113   | 71    | q                             |                |
| 01110010   | 114   | 72    | r                             |                |
| 01110011   | 115   | 73    | s                             |                |
| 01110100   | 116   | 74    | t                             |                |
| 01110101   | 117   | 75    | u                             |                |
| 01110110   | 118   | 76    | v                             |                |
| 01110111   | 119   | 77    | w                             |                |
| 01111000   | 120   | 78    | x                             |                |
| 01111001   | 121   | 79    | y                             |                |
| 01111010   | 122   | 7A    | z                             |                |
| 01111011   | 123   | 7B    | {                             |                |
| 01111100   | 124   | 7C    | |                             |                |
| 01111101   | 125   | 7D    | }                             |                |
| 01111110   | 126   | 7E    | ~                             |                |
| 01111111   | 127   | 7F    | DEL (delete)                  | 删除           |

**** 第三部分：扩展ASCII打印字符

扩展的ASCII字符满足了对更多字符的需求。扩展的ASCII包含ASCII中已有的128个字符（数字0--32显示在下图中），又增加了128个字符，总共是256个。即使有了这些更多的字符，许多语言还是包含无法压缩到256个字符中的符号。因此，出现了一些ASCII的变体来囊括地区性字符和符号。例如，许多软件程序把ASCII表（又称作ISO8859-1）用于北美、西欧、澳大利亚和非洲的语言。

[[http://www.asciima.com/img/ascii127-255.jpg]]

**


** [[http://blog.chinaunix.net/uid-9525959-id-2001805.html][gdb基本命令总结]]
17:47:55/

分类：

*gdb基本命令*

本文介绍使用gdb调试程序的常用命令。

主要内容:

[简介]

[举例]

[其他]



*[简介] *

*=============*

GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。如果你是在
UNIX平台下做软件，你会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。同时GDB也具有例如ddd这样的图形化的调试端。

一般来说，GDB主要完成下面四个方面的功能：

(1)启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。

(2)可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）

(3)当程序被停住时，可以检查此时你的程序中所发生的事。

(4)动态的改变你程序的执行环境。



兴趣是最好的老师，这里先整理总结一下在调试的过程中经常遇到的问题。带着这些问题进行学习和实践可以有助于加深印象。
再往后是本人实践过程中总结的常见命令，如有什么问题或者建议，都可以联系我，谢谢！\^_\^

(1)如何打印变量的值？(print var)

(2)如何打印变量的地址？(print &var)

(3)如何打印地址的数据值？(print *address)

(4)如何查看当前运行的文件和行？(backtrace)

(5)如何查看指定文件的代码？(list file:N)

(6)如何立即执行完当前的函数，但是并不是执行完整个应用程序？(finish)

(7)如果程序是多文件的，怎样定位到指定文件的指定行或者函数？(list
file:N)

(8)如果循环次数很多，如何执行完当前的循环？(until)

(9)多线程如何调试？(???)



作者：QuietHeart

Email: quiet_heart000@126.com





*[举例] *

*============= *

*启动gdb

$gdb

这样可以和gdb进行交互了。



*启动gdb，并且分屏显示源代码：

$gdb -tui

这样,使用了'-tui'选项，启动可以直接将屏幕分成两个部分，上面显示源代码，比用list方便多了。这时候使用上下方向键可以查看源代码,想要命令行使用上下键就用[Ctrl]n和[Ctrl]p.



*启动gdb调试指定程序app：

$gdb app

这样就在启动gdb之后直接载入了app可执行程序，需要注意的是，载入的app程序必须在编译的时候有gdb调试选项，例如'gcc
-g app
app.c',注意，如果修改了程序的源代码，但是没有编译，那么在gdb中显示的会是改动后的源代码，但是运行的是改动前的程序，这样会导致跟踪错乱的。



*启动程序之后，再用gdb调试：

$gdb <program> <PID>

这里，<program>是程序的可执行文件名，<PID>是要调试程序的PID.如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。



*启动程序之后，再启动gdb调试：

$gdb <PID>

这里，程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID,<PID>是要调试程序的PID.这样gdb就附加到程序上了，但是现在还没法查看源代码,用file命令指明可执行文件就可以显示源代码了。





**启动gdb之后的交互命令：

交互命令支持[Tab]补全。



*显示帮助信息：

(gdb) help



*载入指定的程序：

(gdb) file app

这样在gdb中载入想要调试的可执行程序app。如果刚开始运行gdb而不是用gdb
app启动的话可以这样载入app程序，当然编译app的时候要加入-g调试选项。



*重新运行调试的程序：

(gdb) run

要想运行准备调试的程序，可使用run命令，在它后面可以跟随发给该程序的任何参数，包括标准输入和标准输出说明符(<和>
)和shell通配符（*、？、[、]）在内。



*修改发送给程序的参数：

(gdb) set args no

这里，假设我使用"r yes"设置程序启动参数为yes，那么这里的set
args会设置参数argv[1]为no。



*显示缺省的参数列表：

(gdb) show args



*列出指定区域(n1到n2之间)的代码：

(gdb) list n1 n2

这样,list可以简写为l,将会显示n1行和n2行之间的代码，如果使用-tui启动gdb，将会在相应的位置显示。如果没有n1和n2参数，那么就会默认显示当前行和之后的10行，再执行又下滚10行。另外，list还可以接函数名。

一般来说在list后面可以跟以下这们的参数：

<linenum>   行号。

<+offset>   当前行号的正偏移量。

<-offset>   当前行号的负偏移量。

<filename:linenum>  哪个文件的哪一行。

<function>  函数名。

<filename:function> 哪个文件中的哪个函数。

<*address>  程序运行时的语句在内存中的地址。



*执行下一步：

(gdb) next

这样，执行一行代码，如果是函数也会跳过函数。这个命令可以简化为n.



*执行N次下一步：

(gdb) next N



*执行上次执行的命令：

(gdb) [Enter]

这里，直接输入回车就会执行上次的命令了。



*单步进入：

(gdb) step

这样，也会执行一行代码，不过如果遇到函数的话就会进入函数的内部，再一行一行的执行。



*执行完当前函数返回到调用它的函数：

(gdb) finish

这里，运行程序，直到当前函数运行完毕返回再停止。例如进入的单步执行如果已经进入了某函数，而想退出该函数返回到它的调用函数中，可使用命令finish.



*指定程序直到退出当前循环体：

(gdb) until

或(gdb) u

这里，发现需要把光标停止在循环的头部，然后输入u这样就自动执行全部的循环了。



*跳转执行程序到第5行：

(gdb) jump 5

这里，可以简写为"j
5"需要注意的是，跳转到第5行执行完毕之后，如果后面没有断点则继续执行，而并不是停在那里了。

另外，跳转不会改变当前的堆栈内容，所以跳到别的函数中就会有奇怪的现象，因此最好跳转在一个函数内部进行,跳转的参数也可以是程序代码行的地址,函数名等等类似list。



*强制返回当前函数:

(gdb) return

这样，将会忽略当前函数还没有执行完毕的语句，强制返回。return后面可以接一个表达式，表达式的返回值就是函数的返回值。



*强制调用函数：

(gdb) call <expr>

这里,<expr>可以是一个函数，这样就会返回函数的返回值，如果函数的返回类型是void那么就不会打印函数的返回值,但是实践发现，函数运行过程中的打印语句还是没有被打印出来。



*强制调用函数2：

(gdb) print <expr>

这里，print和call的功能类似，不同的是，如果函数的返回值是void那么call不会打印返回值，但是print还是会打印出函数的返回值并且存放到历史记录中。



*在当前的文件中某一行（假设为6）设定断点：

(gdb) break 6



*设置条件断点：

(gdb) break 46 if testsize==100

这里，如果testsize==100就在46行处断点。



*检测表达式变化则停住：

(gdb) watch i != 10

这里，i != 10这个表达式一旦变化，则停住。watch <expr>
为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序(也是一种断点)。



*在当前的文件中为某一函数(假设为func)处设定断点：

(gdb) break func



*给指定文件（fileName）的某个行（N）处设置断点：

(gdb) break fileName:N

这里，给某文件中的函数设置断点是同理的。



*显示当前gdb断点信息：

(gdb) info breakpoints

这里，可以简写为info break.会显示当前所有的断点，断点号，断点位置等等。



*删除N号断点：

(gdb) delete N



*删除所有断点：

(gdb) delete



*清除行N上面的所有断点：

(gdb) clear N





*继续运行程序直接运行到下一个断点：

(gdb) continue

这里，如果没有断点就一直运行。



*显示当前调用函数堆栈中的函数：

(gdb) backtrace

命令产生一张列表，包含着从最近的过程开始的所有有效过程和调用这些过程的参数。当然，这里也会显示出当前运行到了哪里(文件，行)。



*查看当前调试程序的语言环境：

(gdb) show language

这里，如果gdb不能识别你所调试的程序，那么默认是c语言。



*查看当前函数的程序语言：

(gdb) info frame



*显示当前的调试源文件：

(gdb) info source

这样会显示当前所在的源代码文件信息,例如文件名称，程序语言等。



*手动设置当前的程序语言为c++:

(gdb) set language c++

这里，如果gdb没有检测出你的程序语言，你可以这样设置。



*查看可以设置的程序语言：

(gdb) set language

这里，使用没有参数的set language可以查看gdb中可以设置的程序语言。



*终止一个正在调试的程序：

(gdb) kill

这里，输入kill就会终止正在调试的程序了。



*print显示变量(var)值：

(gdb) print var

这里，print可以简写为p,print
是gdb的一个功能很强的命令，利用它可以显示被调试的语言中任何有效的表达式。表达式除了包含你程序中的变量外，还可以包含函数调用,复杂数据结构和历史等等。



*用16进制显示(var)值：

(gdb) print /x var

这里可以知道，print可以指定显示的格式，这里用'/x'表示16进制的格式。

可以支持的变量显示格式有：

x  按十六进制格式显示变量。

d  按十进制格式显示变量。

u  按十六进制格式显示无符号整型。

o  按八进制格式显示变量。

t  按二进制格式显示变量。

a  按十六进制格式显示变量。

c  按字符格式显示变量。

f  按浮点数格式显示变量。





*如果a是一个数组，10个元素，如果要显示则：

(gdb) print *a@10

这样，会显示10个元素，无论a是double或者是int的都会正确地显示10个元素。



*修改运行时候的变量值：

(gdb) print x=4

这里，x=4是C/C++的语法，意为把变量x值改为4，如果你当前调试的语言是Pascal，那么你可以使用Pascal的语法：x:=4。



*显示一个变量var的类型：

(gdb) whatis var



*以更详细的方式显示变量var的类型：

(gdb) ptype var

这里，会打印出var的结构定义。

**



*[其他] *

*============= *

*在Qt4.x环境中打印QString msg;的msg变量：

步骤如下：

1)定义一个宏printqstring

define printqstring

    printf "(QString)0x%x (length=%i): \"",&$arg0,$arg0.d->size

    set $i=0

    while $i < $arg0.d->size

        set $c=$arg0.d->data[$i++]

        if $c < 32 || $c > 127

                printf "\\u0x%04x", $c

        else

                printf "%c", (char)$c

        end

    end

    printf "\"\n"

end

2)(gdb) printqstring msg

这里，这个宏可以在gdb中直接定义，据说也可以写到$HOME/.gdbinit,这样每次启动自动加载。



*调试同时指明生成core文件：

$gdb <program> core

用gdb同时调试一个运行程序和core文件，core是程序非法执行后core
dump后产生的文件。当程序非法崩溃的时候会产生一个core文件，然后使用这个命令，会直接定位到发生程序崩溃的位置。注意：有时需要设置系统命令“ulimit
-c unlimited”才能产生core文件。





**没有实践过的

*print显示存储块,如显示h后面的10个整数：

print h@10

** [[http://blog.csdn.net/starlee/article/details/619827][C++中虚析构函数的作用]]

标签：
[[http://www.csdn.net/tag/c%2b%2b][c++]][[http://www.csdn.net/tag/destructor][destructor]][[http://www.csdn.net/tag/class][class]][[http://www.csdn.net/tag/%e7%bc%96%e8%af%91%e5%99%a8][编译器]][[http://www.csdn.net/tag/delete][delete]][[http://www.csdn.net/tag/output][output]]

2006-03-09 15:34 90702人阅读 [[#comments][评论]](75)
[[javascript:void(0);][收藏]] [[#report][举报]]

[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

C++/（24）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/starlee/article/category/172060][作者同类文章]]/X/

版权声明：本文为博主原创文章，未经博主允许不得转载。

 我们知道，用C++开发的时候，用来做基类的类的析构函数一般都是虚函数。可是，为什么要这样做呢？下面用一个小例子来说明：
  有下面的两个类：

class ClxBase
{
public:
 ClxBase() {};
 virtual ~ClxBase() {};

 virtual void DoSomething() { cout << "Do something in class ClxBase!" << endl; };
};

class ClxDerived : public ClxBase
{
public:
 ClxDerived() {};
 ~ClxDerived() { cout << "Output from the destructor of class ClxDerived!" << endl; };

 void DoSomething() { cout << "Do something in class ClxDerived!" << endl; };
};

  代码

ClxBase *pTest = new ClxDerived;
pTest->DoSomething();
delete pTest;

  的输出结果是：

Do something in class ClxDerived!
Output from the destructor of class ClxDerived!

 这个很简单，非常好理解。

但是，如果把类ClxBase析构函数前的virtual去掉，那输出结果就是下面的样子了：

Do something in class ClxDerived!


也就是说，类ClxDerived的析构函数根本没有被调用！一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。我想所有的C++程序员都知道这样的危险性。当然，如果在析构函数中做了其他工作的话，那你的所有努力也都是白费力气。
 所以，文章开头的那个问题的答案就是－－这样做是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。
 当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。

** [[http://www.cnblogs.com/longdouhzt/archive/2012/10/11/2720161.html][ubuntu latex 的 minted 安装]]

提示：minted包有一个bug，见文末。。

---------



*简介*（转自：
[[http://blog.houqp.me/minted-better-alternative-package-for-lstlisting/]]
）

------

曾几何时，我一直在使用lstlisting宏包高亮代码，鉴于我从来就没在Word里面享受过这样的功能，我一直感到很满意。直到今天我遇到了minted宏包。minted的[[https://code.google.com/p/minted/][[项目主页]]]托管于Google
Code。

使用非常的简单，例如：
=\begin{minted}{c}printf("Hello World.");\end{minted}=

minted在后台调用的是pygmentize，所以输出的结果非常漂亮，自然也就支持多种主题。minted提供很多可配置的参数，更多选项请参考[[[http://code.google.com/p/minted/downloads/detail?name=minted.pdf][官方文档]]]。

有一点要注意的是编译时需要加上*-shell-escape*参数。

------

*安装*

 minted的project home: http://code.google.com/p/minted/

主要按照上面文档的介绍安装就可以了。。 安装时会要求安装 minted.sty，
这里有一个简单的方法：

[[http://www.cnblogs.com/longdouhzt/archive/2012/10/11/2720045.html]]


安装完minted.sty 就大功告成了～～

--------

*使用*

查看支持的语言： $ pygmentize -L lexers
如 C， NASM *
*

注意用小写 如\begin{minted}{nasm}



几个可能有用的配置：

1. 背景：

#+BEGIN_EXAMPLE
    \definecolor{bg}{rgb}{0.95,0.95,0.95}
    \begin{minted}[bgcolor=bg]{php}
    <?php
    　　echo "Hello, $x";
    ?>
    \end{minted}
#+END_EXAMPLE

2. 行号

linenos  (boolean)
(default: false)
Enables line numbers. In order to customize the display style of line
numbers, you
need to redefine the \theFancyVerbLine macro:


#+BEGIN_EXAMPLE
    \renewcommand{\theFancyVerbLine}{\sffamily
    \textcolor[rgb]{0.5,0.5,1.0}{\scriptsize
    \oldstylenums{\arabic{FancyVerbLine}}}}
    \begin{minted}[linenos,
    firstnumber=11]{python}
    def all(iterable):
    　　for i in iterable:
    　　　　if not i:
    　　　　　　return False
    　　return True
    \end{minted}
#+END_EXAMPLE

** [[http://seisman.info/introduction-to-pdftk.html][PDF合并和分割工具---PDFtk]]

***** Contents

-  [[#id1][简介]]
-  [[#id2][功能]]
-  [[#id3][用法示例]]

*** [[#id4][简介]]

PDFtk是什么？我觉得官网的一句话解释得很好。

#+BEGIN_QUOTE
  If PDF is electronic paper, then PDFtk is an electronic
  staple-remover, hole-punch, binder, secret-decoder-ring, and
  X-Ray-glasses. PDFtk is a simple tool for doing everyday things with
  PDF documents.
#+END_QUOTE

其官方网站为： [[http://www.pdflabs.com/tools/pdftk-the-pdf-toolkit]]

PDFtk目前分为三个版本：

-  PDFtk Server：命令行工具。支持windows、Linux、Mac。
-  PDFtk Free：图形界面基础免费版；仅限windows用户；功能仅限于PDF合并和分割；
-  PDFtk Pro：图形界面专业收费版；仅限windows用户，可以对PDF文档进行合并、分割、旋转、加水印、加邮戳、加密。

对于Linux用户，唯一的选择是免费的PDFtk
Server，其功能与收费PDFtk Pro完全相同，只是没有GUI而已。作者还是很厚道的。

Linux的各个发行版的官方源中基本都有该软件，直接apt-get或者yum安装即可。

*** [[#id5][功能]]

-  合并PDF；
-  分割PDF页面；
-  旋转PDF文档或页面；
-  PDF解密；（不是破解）
-  PDF加密；
-  用X/FDF填写PDF表格；
-  从PDF表格中生成PDF Data Stencils；
-  加背景水印或前景印章；
-  报告PDF Metrics，书签和元数据；
-  增加/更新PDF书签或元数据；
-  给PDF页面或文档加附件；
-  解压PDF附件；
-  分解PDF文档为多个单页；
-  解压缩和重压缩页面流；
-  修复受损的PDF文档；

这功能完全可以与Adobe Acrobat相媲美了，更重要的是PDFtk支持Linux且完全免费。（个人用户免费，若用于商业用途需付费）。

*** [[#id6][用法示例]]

具体选项看这里： [[http://www.pdflabs.com/docs/pdftk-man-page/]]

下面给出一些常见的例子。例子原文在：
[[http://www.pdflabs.com/docs/pdftk-cli-examples/]]

扫描一本书，odd.pdf为书的全部奇数页，even.pdf为书的全部偶数页，下面的命令可以将两个pdf合并成页码正常的书:

#+BEGIN_EXAMPLE
    pdftk A=odd.pdf B=even.pdf shuffle A B output collated.pdf
#+END_EXAMPLE

如果odd.pdf是逆序的:

#+BEGIN_EXAMPLE
    pdftk A=odd.pdf B=even.pdf shuffle Aend-1 B output collated.pdf
#+END_EXAMPLE

加密PDF:

#+BEGIN_EXAMPLE
    pdftk secured.pdf input_pw foopass output unsecured.pdf
#+END_EXAMPLE

PDF 128位加密，保留全部权限:

#+BEGIN_EXAMPLE
    pdftk 1.pdf output 1.128.pdf owner_pw foopass
#+END_EXAMPLE

PDF 128位加密，保留全部权限，打开文档需输入密码”baz”:

#+BEGIN_EXAMPLE
    pdftk 1.pdf output 1.128.pdf owner_pw foo user_pw baz
#+END_EXAMPLE

PDF 128位加密，打开文档需输入密码”baz”，保留打印之外的其他权限:

#+BEGIN_EXAMPLE
    pdftk 1.pdf output 1.128.pdf owner_pw foo user_pw baz allow printing
#+END_EXAMPLE

合并in1.pdf和in2.pdf到新PDF中:

#+BEGIN_EXAMPLE
    pdftk in1.pdf in2.pdf cat output out1.pdf
#+END_EXAMPLE

或（使用句柄）:

#+BEGIN_EXAMPLE
    pdftk A=in1.pdf B=in2.pdf cat A B output out1.pdf
#+END_EXAMPLE

或（使用通配符）:

#+BEGIN_EXAMPLE
    pdftk *.pdf cat output combined.pdf
#+END_EXAMPLE

去除in1.pdf中的第13页，并创建out1.pdf:

#+BEGIN_EXAMPLE
    pdftk in.pdf cat 1-12 14-end output out1.pdf
#+END_EXAMPLE

或

#+BEGIN_EXAMPLE
    pdftk A=in1.pdf cat A1-12 A14-end output out1.pdf
#+END_EXAMPLE

对输出进行40位加密，撤销所有权限，设置owner密码为foopass:

#+BEGIN_EXAMPLE
    pdftk 1.pdf 2.pdf cat output 3.pdf encrypt_40bit owner_pw foopass
#+END_EXAMPLE

合并两个文件，其中一个需要被加密。对输出不加密:

#+BEGIN_EXAMPLE
    pdftk A=secured.pdf 2.pdf input_pw A=foopass cat output 3.pdf
#+END_EXAMPLE

解压PDF页面流，然后就可以在文本编辑器中编辑PDF文件:

#+BEGIN_EXAMPLE
    pdftk doc.pdf output doc.unc.pdf uncompress
#+END_EXAMPLE

压缩PDF:

#+BEGIN_EXAMPLE
    pdftk mydoc.pdf output mydoc.clear.pdf compress
#+END_EXAMPLE

修复破损的PDF:

#+BEGIN_EXAMPLE
    pdftk broken.pdf output fixed.pdf
#+END_EXAMPLE

将一个PDF文档分割成一页一个文档:

#+BEGIN_EXAMPLE
    pdftk in.pdf burst
#+END_EXAMPLE

将一个PDF文档分割成一页一个文档，并加密，允许低质量的打印:

#+BEGIN_EXAMPLE
    pdftk in.pdf burst owner_pw foopass allow DegradedPrinting
#+END_EXAMPLE

获取PDF问的元数据和书签信息:

#+BEGIN_EXAMPLE
    pdftk in.pdf dump_data output report.txt
#+END_EXAMPLE

将PDF第一页顺时针旋转90度:

#+BEGIN_EXAMPLE
    pdftk in.pdf cat 1east 2-end output out.pdf
#+END_EXAMPLE

将整个PDF文档旋转180度:

#+BEGIN_EXAMPLE
    pdftk in.pdf cat 1-endsouth output out.pdf
#+END_EXAMPLE

** [[http://blog.sina.com.cn/s/blog_5c13e0f40101coih.html][怎么在Latex文件中对文本加颜色]]

在编Latex文件的过程中，为了对一些修改后的文本标注出，需要对其加颜色。
刚开始利用书上指导的，要什么【模式】{符号}等，总也弄不出来，发现用最简
单的就可以了。比如：我要对“I love you”加注为红色。首先，在最前面的导
言区输入命令 \usepackage{color}，然后，在需要加注颜色的处输入
{\color{red}{I love you}}，最外面的大括号是只对“I love you”加注红色，
如果没有这个大括号的话，那会对后面所有的文本加颜色。如果要对公式加注颜
色，只需要将文字“I love you”换成公式的命令就可以了，如：要对公式A（x）
加颜色，输入{\color{red}{$A（x）$}}就可以了。

** [[http://blog.sina.com.cn/s/blog_5e16f1770102elx0.html][LaTeX技巧605：LaTeX排版XML语法高亮显示]]

语法高亮显示的问题，我还是推荐用户使用minted这个包，效果很不错，不过需要大家安装和配置一些东西。

这里给一个minted显示的例子，具体配置参看minted包的说明文档即可。

[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]

代码如下:

#+BEGIN_EXAMPLE
    \documentclass{minimal}
    \usepackage{minted}
    \begin{document}
    \begin{minted}{xml}
      <xml>
      <person age="22" sex="female">Ann</person>
      </xml>
    \end{minted}
    \end{document}
#+END_EXAMPLE



若是有用户不习惯使用这一包，也可以使用listings包来定制显示XML语句，如下：

[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]

代码选自：[[http://tex.stackexchange.com/questions/10255/xml-syntax-highlighting]]



#+BEGIN_EXAMPLE
    \usepackage{listings}

    \usepackage{color}
    \definecolor{gray}{rgb}{0.4,0.4,0.4}
    \definecolor{darkblue}{rgb}{0.0,0.0,0.6}
    \definecolor{cyan}{rgb}{0.0,0.6,0.6}

    \lstset{
      basicstyle=\ttfamily,
      columns=fullflexible,
      showstringspaces=false,
      commentstyle=\color{gray}\upshape
    }

    \lstdefinelanguage{XML}
    {
      morestring=[b]",
      morestring=[s]{>}{<},
      morecomment=[s]{<?}{?>},
      stringstyle=\color{black},
      identifierstyle=\color{darkblue},
      keywordstyle=\color{cyan},
      morekeywords={xmlns,version,type}% list your attributes here
    }
#+END_EXAMPLE

** [[http://www.cnblogs.com/xiangzi888/archive/2012/03/27/2420188.html][bash函数使用]]

一、bash函数定义及调用

在写c语言的时候，我们使用字符串数组存储命令行参数（argv[]）。同样，在编写Bash脚本的时候，也使用命令行参数。在Bash函数中也可以使用参数，特殊的是，Bash中的函数是没有参数列表的，例如

#+BEGIN_EXAMPLE
    #定义foo() {    statements}#调用foo
#+END_EXAMPLE

这样便完成了一个函数的定义，但是没有任何的形参名称，这是由于Bash中特殊的参数传递方法所致。



二、传参（命令行参数）

当一个函数被调用时，脚本程序的位置参数（$* $@ $#参数个数 $1 $2
$?上一条独立命令运行结果 ）等会被替换为函数的参数。



三、返回值

通常情况下Bash的函数是很少需要返回值的，但是有的时候需要，比如确定一个函数是否被成功执行，然后确定下一步的动作。这样的逻辑必须得到Bash函数的返回值，用以表示函数执行的状态。

#+BEGIN_EXAMPLE
    #!/bin/bash foo(){    echo Jay}result="$(foo)"                  echo $resultexit 0
#+END_EXAMPLE

也可用 return 关键字：

#+BEGIN_EXAMPLE
    #!/bin/bash yesorno(){    echo "is your name $*? "    while true    do        read -p "Enter yes or no: " x        case $x in　　　            y|Y )                return 0;;            n|N )                return 1;;            *   )                echo "answer yes or no"        esac    done }echo "original parameters are $*"if yesorno "$1"then    echo "Hi $1, nice name"else    echo "Never mind"fiexit 0
#+END_EXAMPLE

如果没有在一个函数内使用return命令指定一个返回值，函数返回的就是执行的最后一条命令的推出码。



四、其他

必须在调用一个函数之前先对他进行定义。

可以用 /local /关键字在shell函数中声明局部变量。

** [[http://blog.sina.com.cn/s/blog_5e16f1770100o9ef.html][LaTeX技巧473：Listings宏包定制python源代码输出]]


listing使用方法前面博文已经写了很多了有：[[http://blog.sina.com.cn/s/blog_5e16f1770100fw83.html][LaTeX技巧32：LaTeX程序代码排版，Listings宏包]]
以及
[[http://blog.sina.com.cn/s/blog_5e16f1770100fw8o.html][LaTex技巧35：listings的范例程序]]
还有制作
matlab样式的代码如：[[http://blog.sina.com.cn/s/blog_5e16f1770100fwr8.html][LaTeX技巧57：使用mcode宏包在LATEX制作m文件效果]]
[[http://blog.sina.com.cn/s/blog_5e16f1770100nwi5.html][LaTeX技巧466：如何利用listing宏包制作专业的C++输出代码？]]
[[http://blog.sina.com.cn/s/blog_5e16f1770100ngbk.html][LaTeX技巧450：Latex中插入彩色java代码]]

 下面我们看看python代码如何制作呢？

我们给出了一个语法文件（[[http://blog.miliauskas.lt/2008/09/python-syntax-highlighting-in-latex.html][选自这里）]]
其效果图如下：

[[http://photo.blog.sina.com.cn/showpic.html#blogid=5e16f1770100o9ef&url=http://s15.sinaimg.cn/orignal/5e16f177h9967c101863e][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]
 代码如下：
 \documentclass{article}
 \usepackage{amsfonts}
 \usepackage{xcolor}
 \usepackage{listings}
 \usepackage{textcomp}
 \usepackage{setspace}
 \usepackage{palatino}

 \renewcommand{\lstlistlistingname}{Code Listings}
 \renewcommand{\lstlistingname}{Code Listing}
 \definecolor{gray}{gray}{0.5}
 \definecolor{green}{rgb}{0,0.5,0}

 \lstnewenvironment{python}[1][]{
 \lstset{
 language=python,
 basicstyle=\ttfamily\small\setstretch{1},
 stringstyle=\color{red},
 showstringspaces=false,
 alsoletter={1234567890},
 otherkeywords={\ , \}, \{},
 keywordstyle=\color{blue},
 emph={access,and,break,class,continue,def,del,elif ,else,%
 except,exec,finally,for,from,global,if,import,in,i s,%
 lambda,not,or,pass,print,raise,return,try,while},
 emphstyle=\color{orange}\bfseries,
 emph={[2]True, False, None, self},
 emphstyle=[2]\color{green},
 emph={[3]from, import, as},
 emphstyle=[3]\color{blue},
 upquote=true,
 morecomment=[s]{"""}{"""},
 commentstyle=\color{gray}\slshape,
 emph={[4]1, 2, 3, 4, 5, 6, 7, 8, 9, 0},
 emphstyle=[4]\color{blue},
 literate=*{:}{{\textcolor{blue}:}}{1}%
 {=}{{\textcolor{blue}=}}{1}%
 {-}{{\textcolor{blue}-}}{1}%
 {+}{{\textcolor{blue}+}}{1}%
 {*}{{\textcolor{blue}*}}{1}%
 {!}{{\textcolor{blue}!}}{1}%
 {(}{{\textcolor{blue}(}}{1}%
 {)}{{\textcolor{blue})}}{1}%
 {[}{{\textcolor{blue}[}}{1}%
 {]}{{\textcolor{blue}]}}{1}%
 {<}{{\textcolor{blue}<}}{1}%
 {>}{{\textcolor{blue}>}}{1},%
 framexleftmargin=1mm, framextopmargin=1mm, frame=shadowbox,
rulesepcolor=\color{blue},#1
 }}{}
 \begin{document}

 We can see in Code Listing~\ref{ex1} that... And compared to Code
Listing~\ref{ex2} something else.

 \begin{python}[moreemph={[4]42},caption={Simple python example No.
1},label=ex1]
 #!/usr/bin/env python3

 class MyClass(MyOtherClass):
 """
 Some Docstring ()
 """
 a = 3
 b5 = -42
 q = (3, 5, j)
 SIGNAL('clicked()'),
 "A String"
 \end{python}

 \begin{python}[moreemph={[4], 46, 48},caption={Simple python example
No. 2},label=ex2]
 #!/usr/bin/env python
 #-*- coding: utf-8 -*-

 class MyClass(MyOtherClass):
 """
 Some Docstring
 """
 def __init__(self):
 fruitbowl = ["pear", "peach", "banana"]
 for fruit in fruitbowl:
 print fruit
 if fruit is "pear":
 continue
 else:
 pass
 if fruitbowl is not None:
 var = True
 else:
 var = False
 a = 3
 b = -46
 c = 3.48
 someDict = {'one':1, 'two':2, "three":3}
 aTuple = (1, 2, 3, 4, 5)
 string = "one-two=3"
 name = "Username: "
 self.button1.connect(self.button1,
 SIGNAL('clicked()'),
 self.login)
 return
 \end{python}
 \begin{equation}
   a\^2
 \end{equation}
 \lstlistoflistings

 \end{document}


 这样文档代码太长，可以拆分文件，为pythonlisting.tex +
主文件。语法文件这里下载：

http://cid-3cfe530319707374.office.live.com/self.aspx/ChinaTeX/pythonlisting.tex
 那上面代码可以写为：
 \documentclass{article}
 \include{pythonlisting}
 \begin{document}
 We can see in Code Listing~\ref{ex1} that... And compared to Code
Listing~\ref{ex2} something else.

 \begin{python}[moreemph={[4]42},caption={Simple python example No.
1},label=ex1]
 #!/usr/bin/env python3

 class MyClass(MyOtherClass):
 """
 Some Docstring ()
 """
 a = 3
 b5 = -42
 q = (3, 5, j)
 SIGNAL('clicked()'),
 "A String"
 \end{python}

 \begin{python}[moreemph={[4], 46, 48},caption={Simple python example
No. 2},label=ex2]
 #!/usr/bin/env python
 #-*- coding: utf-8 -*-

 class MyClass(MyOtherClass):
 """
 Some Docstring
 """
 def __init__(self):
 fruitbowl = ["pear", "peach", "banana"]
 for fruit in fruitbowl:
 print fruit
 if fruit is "pear":
 continue
 else:
 pass
 if fruitbowl is not None:
 var = True
 else:
 var = False
 a = 3
 b = -46
 c = 3.48
 someDict = {'one':1, 'two':2, "three":3}
 aTuple = (1, 2, 3, 4, 5)
 string = "one-two=3"
 name = "Username: "
 self.button1.connect(self.button1,
 SIGNAL('clicked()'),
 self.login)
 return
 \end{python}

 \lstlistoflistings


 \end{document}

** [[http://blog.csdn.net/zxia1/article/details/8134968][Latex之算法宏包]]


    Latex中对算法进行排版的宏包有不少，本文简单介绍几个常用的宏包。

*1.
listings*：这个用来对真实的代码排版，不适于伪代码。支持C++，Pascal等10几种语言。该环境中的内容完全与TeX环境隔离，无法直接处理下标，上标等符号。使用时需要以下步骤：
 \usepackage{listings}
 \lstloadlanguages{C++, Pascal}  %可以一次加入多种语言

\lstset{language=C++}  %使用前指定语言

\begin{lstlisting}{}
   code...
 \end{lstlisting}

*2. algorithmic和algorithmics*: 不支持switch-case语句。

*3. newalg*: 支持switch-case，不过似乎比较老了，很久没人维护了。

*4.
algorithmicx*：这个看起来功能最强大，包含了专门针对C语言，Pascal语言，matlab以及伪代码的sty文件，可惜它的C语言环境还在开发中，目前也不支持switch-case语句。

*5. algorithm*: 可以用于伪代码的排版。

** [[http://blog.sina.com.cn/s/blog_5e16f1770100nwi5.html][LaTeX技巧466：如何利用listing宏包制作专业的C++输出代码？]]


之前讲到了listing使用方法，[[http://blog.sina.com.cn/s/blog_5e16f1770100fw83.html][LaTeX技巧32：LaTeX程序代码排版，Listings宏包]]
以及
[[http://blog.sina.com.cn/s/blog_5e16f1770100fw8o.html][LaTex技巧35：listings的范例程序]]
还有制作
matlab样式的代码如：[[http://blog.sina.com.cn/s/blog_5e16f1770100fwr8.html][LaTeX技巧57：使用mcode宏包在LATEX制作m文件效果]]
下面我们看看这样的代码如何制作呢？

如图：

[[http://photo.blog.sina.com.cn/list/blogpic.php?pid=5e16f177497fcbfe0db8a&bid=5e16f1770100nwi5&uid=1578561911][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]

代码如下：

\documentclass{article}
 \usepackage{xcolor}
 \renewcommand{\sfdefault}{phv}
 \usepackage{listings}
   \usepackage{courier}
 \lstset{
   basicstyle=\footnotesize\ttfamily, % Standardschrift
   %numbers=left,  % Ort der Zeilennummern
   numberstyle=\tiny,  % Stil der Zeilennummern
   %stepnumber=2,  % Abstand zwischen den
Zeilennummern
   numbersep=5pt,  % Abstand der Nummern zum Text
   tabsize=2,  % Groesse von Tabs
   extendedchars=true,  %
   breaklines=true,  % Zeilen werden Umgebrochen
   keywordstyle=\color{red},
   frame=b,
   stringstyle=\color{white}\ttfamily, % Farbe der String
   showspaces=false,  % Leerzeichen anzeigen ?
   showtabs=false,  % Tabs anzeigen ?
   xleftmargin=17pt,
   framexleftmargin=17pt,
   framexrightmargin=5pt,
   framexbottommargin=4pt,
   �ckgroundcolor=\color{lightgray},
   showstringspaces=false  % Leerzeichen in Strings anzeigen
?
 }
 \renewcommand{\lstlistingname}{CODE}
 \lstloadlanguages{% Check Dokumentation for further languages ...
   %[Visual]Basic
   %Pascal
   %C
   %C++
   %XML
   %HTML
   Java
 }
   \usepackage{caption}
 \DeclareCaptionFont{white}{\color{white}}
 \DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35,
0.35,0.01}{\parbox{\textwidth}{#1#2#3}}}

\captionsetup[lstlisting]{format=listing,justification=raggedright,labelfont=white,textfont=white,
singlelinecheck=false, margin=0pt, font={sf,bf,footnotesize}}
 \begin{document}

\begin{lstlisting}[label=some-code,caption=Some Code]
 public void here() {
   goes().the().code()
 }
 \end{lstlisting}

\lstinputlisting[label=samplecode,caption=A sample]{HelloWorld.java}

\end{document}

** [[http://manpages.ubuntu.com/manpages/lucid/man1/pdfoutline.1.html][Ubuntu Manpage: pdfoutline - add outlines (aka bookmarks) to PDF files]]

**** *NAME*

#+BEGIN_EXAMPLE
           pdfoutline - add outlines (aka bookmarks) to PDF files
#+END_EXAMPLE

**** *SYNOPSIS*

#+BEGIN_EXAMPLE
           pdfoutline input.pdf outlines.txt output.pdf
#+END_EXAMPLE

**** *DESCRIPTION*

#+BEGIN_EXAMPLE
           pdfoutline reads input file given as first argument, adds outlines from
           text file given as second argument, and saves result to file with  name
           given as third argument.

           File with outlines information should consist of lines in the following
           format:
                  <level> <page> Outline text

           <level> and <page> should be integers.  Each field should be  separated
           by  exactly one space symbol.  All values for <level> should be greater
           or equal than that of the first line.  Page numeration starts with 1.

           Outlines file can contain comments that start with # in  first  column.
           Comments and empty lines are ignored.
#+END_EXAMPLE

**** *OPTIONS*

#+BEGIN_EXAMPLE
           pdfoutline accepts no options.
#+END_EXAMPLE

**** *EXAMPLES*

#+BEGIN_EXAMPLE
           Here is example of outlines data file:
                  0 1 Document title
                  1 1 Chapter 1
                  2 1 Chapter 1.1
                  2 2 Chapter 1.2
                  1 3 Chapter 2

           Using this file will result in outlines like the following:
                  Document title
                  +-Chapter 1
                  | +-Chapter 1.1
                  | +-Chapter 1.2
                  +-Chapter 2
#+END_EXAMPLE

**** *AUTHOR*

#+BEGIN_EXAMPLE
           pdfoutline author is Eugeniy Meshcheryakov <eugen@debian.org>
           pdfoutline   is   part   of   fntsample   and  can  be  downoaded  from
           <http://sourceforge.net/projects/fntsample>.

                                      2009-11-17                     pdfoutline(1)
#+END_EXAMPLE

** [[http://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/index.html][Python 代码调试技巧]]

Debug
对于任何开发人员都是一项非常重要的技能，它能够帮助我们准确的定位错误，发现程序中的
bug。python 提供了一系列 debug
的工具和包，可供我们选择。本文将主要阐述如何利用 python debug
相关工具进行 debug。

[[#authorN1001B][张 颖]], 软件工程师, IBM

[[#close][关闭 [x]]]

张颖，软件工程师，任职于 CSTL Director Build/BVT team，从事 Build/BVT
相关方面的工作。




2012 年 5 月 03 日

-  [[#toggle][[[//www.ibm.com/i/c.gif]]]]内容

   -  [[#major1][使用 pdb 进行调试]]
   -  [[#major2][使用 PyCharm 进行调试]]
   -  [[#major3][使用 PyDev 进行调试]]
   -  [[#major4][使用日志功能达到调试的目的]]
   -  [[#major5][总结]]
   -  [[#resources][参考资料]]
   -  [[#icomments][评论]]

*** 使用 pdb 进行调试

pdb 是 python 自带的一个包，为 python
程序提供了一种交互的源代码调试功能，主要特性包括设置断点、单步调试、进入函数调试、查看当前代码、查看栈片段、动态改变变量的值等。pdb
提供了一些常用的调试命令，详情见表 1。

****** 表 1. pdb 常用命令

命令

解释

break 或 b 设置断点

设置断点

continue 或 c

继续执行程序

list 或 l

查看当前行的代码段

step 或 s

进入函数

return 或 r

执行代码直到从当前函数返回

exit 或 q

中止并退出

next 或 n

执行下一行

pp

打印变量的值

help

帮助

下面结合具体的实例讲述如何使用 pdb 进行调试。

****** 清单 1. 测试代码示例

#+BEGIN_EXAMPLE
    import pdb
     a = "aaa"
     pdb.set_trace()
     b = "bbb"
     c = "ccc"
     final = a + b + c
     print final
#+END_EXAMPLE

开始调试：直接运行脚本，会停留在 pdb.set_trace() 处，选择 n+enter
可以执行当前的 statement。在第一次按下了 n+enter 之后可以直接按 enter
表示重复执行上一条 debug 命令。

****** 清单 2. 利用 pdb 调试

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]#  python epdb1.py
     > /root/epdb1.py(4)?()
     -> b = "bbb"
     (Pdb) n
     > /root/epdb1.py(5)?()
     -> c = "ccc"
     (Pdb)
     > /root/epdb1.py(6)?()
     -> final = a + b + c
     (Pdb) list
      1     import pdb
      2     a = "aaa"
      3     pdb.set_trace()
      4     b = "bbb"
      5     c = "ccc"
      6  -> final = a + b + c
      7     print final
     [EOF]
     (Pdb)
     [EOF]
     (Pdb) n
     > /root/epdb1.py(7)?()
     -> print final
     (Pdb)
#+END_EXAMPLE

退出 debug：使用 quit 或者 q 可以退出当前的 debug，但是 quit
会以一种非常粗鲁的方式退出程序，其结果是直接 crash。

****** 清单 3. 退出 debug

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]#  python epdb1.py
     > /root/epdb1.py(4)?()
     -> b = "bbb"
     (Pdb) n
     > /root/epdb1.py(5)?()
     -> c = "ccc"
     (Pdb) q
     Traceback (most recent call last):
      File "epdb1.py", line 5, in ?
        c = "ccc"
      File "epdb1.py", line 5, in ?
        c = "ccc"
      File "/usr/lib64/python2.4/bdb.py", line 48, in trace_dispatch
        return self.dispatch_line(frame)
      File "/usr/lib64/python2.4/bdb.py", line 67, in dispatch_line
        if self.quitting: raise BdbQuit
     bdb.BdbQuit
#+END_EXAMPLE

打印变量的值：如果需要在调试过程中打印变量的值，可以直接使用 p
加上变量名，但是需要注意的是打印仅仅在当前的 statement
已经被执行了之后才能看到具体的值，否则会报 NameError: <
exceptions.NameError ... ....> 错误。

****** 清单 4. debug 过程中打印变量

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]#  python epdb1.py
     > /root/epdb1.py(4)?()
     -> b = "bbb"
     (Pdb) n
     > /root/epdb1.py(5)?()
     -> c = "ccc"
     (Pdb) p b
    'bbb'
     (Pdb)
    'bbb'
     (Pdb) n
     > /root/epdb1.py(6)?()
     -> final = a + b + c
     (Pdb) p c
    'ccc'
     (Pdb) p final
     *** NameError: <exceptions.NameError instance at 0x1551b710 >
     (Pdb) n
     > /root/epdb1.py(7)?()
     -> print final
     (Pdb) p final
    'aaabbbccc'
     (Pdb)
#+END_EXAMPLE

使用 c 可以停止当前的 debug 使程序继续执行。如果在下面的程序中继续有
set_statement() 的申明，则又会重新进入到 debug 的状态，读者可以在代码
print final 之前再加上 set_trace() 验证。

****** 清单 5. 停止 debug 继续执行程序

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]#  python epdb1.py
     > /root/epdb1.py(4)?()
     -> b = "bbb"
     (Pdb) n
     > /root/epdb1.py(5)?()
     -> c = "ccc"
     (Pdb) c
     aaabbbccc
#+END_EXAMPLE

显示代码：在 debug
的时候不一定能记住当前的代码块，如要要查看具体的代码块，则可以通过使用
list 或者 l 命令显示。list 会用箭头 -> 指向当前 debug 的语句。

****** 清单 6. debug 过程中显示代码

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]#  python epdb1.py
     > /root/epdb1.py(4)?()
     -> b = "bbb"
     (Pdb) list
      1     import pdb
      2     a = "aaa"
      3     pdb.set_trace()
      4  -> b = "bbb"
      5     c = "ccc"
      6     final = a + b + c
      7     pdb.set_trace()
      8     print final
     [EOF]
     (Pdb) c
     > /root/epdb1.py(8)?()
     -> print final
     (Pdb) list
      3     pdb.set_trace()
      4     b = "bbb"
      5     c = "ccc"
      6     final = a + b + c
      7     pdb.set_trace()
      8  -> print final
     [EOF]
     (Pdb)
#+END_EXAMPLE

在使用函数的情况下进行 debug

****** 清单 7. 使用函数的例子

#+BEGIN_EXAMPLE
    import pdb
     def combine(s1,s2):      # define subroutine combine, which...
        s3 = s1 + s2 + s1    # sandwiches s2 between copies of s1, ...
        s3 = '"' + s3 +'"'   # encloses it in double quotes,...
        return s3            # and returns it.
     a = "aaa"
     pdb.set_trace()
     b = "bbb"
     c = "ccc"
     final = combine(a,b)
     print final
#+END_EXAMPLE

如果直接使用 n 进行 debug 则到 final=combine(a,b)
这句的时候会将其当做普通的赋值语句处理，进入到 print
final。如果想要对函数进行 debug 如何处理呢 ? 可以直接使用 s
进入函数块。函数里面的单步调试与上面的介绍类似。如果不想在函数里单步调试可以在断点处直接按
r 退出到调用的地方。

****** 清单 8. 对函数进行 debug

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]# python epdb2.py
     > /root/epdb2.py(10)?()
     -> b = "bbb"
     (Pdb) n
     > /root/epdb2.py(11)?()
     -> c = "ccc"
     (Pdb) n
     > /root/epdb2.py(12)?()
     -> final = combine(a,b)
     (Pdb) s
     --Call--
     > /root/epdb2.py(3)combine()
     -> def combine(s1,s2):      # define subroutine combine, which...
     (Pdb) n
     > /root/epdb2.py(4)combine()
     -> s3 = s1 + s2 + s1    # sandwiches s2 between copies of s1, ...
     (Pdb) list
      1     import pdb
      2
      3     def combine(s1,s2):      # define subroutine combine, which...
      4  ->     s3 = s1 + s2 + s1    # sandwiches s2 between copies of s1, ...
      5         s3 = '"' + s3 +'"'   # encloses it in double quotes,...
      6         return s3            # and returns it.
      7
      8     a = "aaa"
      9     pdb.set_trace()
     10     b = "bbb"
     11     c = "ccc"
     (Pdb) n
     > /root/epdb2.py(5)combine()
     -> s3 = '"' + s3 +'"'   # encloses it in double quotes,...
     (Pdb) n
     > /root/epdb2.py(6)combine()
     -> return s3            # and returns it.
     (Pdb) n
     --Return--
     > /root/epdb2.py(6)combine()->'"aaabbbaaa"'
     -> return s3            # and returns it.
     (Pdb) n
     > /root/epdb2.py(13)?()
     -> print final
     (Pdb)
#+END_EXAMPLE

在调试的时候动态改变值
。在调试的时候可以动态改变变量的值，具体如下实例。需要注意的是下面有个错误，原因是
b 已经被赋值了，如果想重新改变 b 的赋值，则应该使用！ B。

****** 清单 9. 在调试的时候动态改变值

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]# python epdb2.py
     > /root/epdb2.py(10)?()
     -> b = "bbb"
     (Pdb) var = "1234"
     (Pdb) b = "avfe"
     *** The specified object '= "avfe"' is not a function
     or was not found along sys.path.
     (Pdb) !b="afdfd"
     (Pdb)
#+END_EXAMPLE

pdb
调试有个明显的缺陷就是对于多线程，远程调试等支持得不够好，同时没有较为直观的界面显示，不太适合大型的
python 项目。而在较大的 python
项目中，这些调试需求比较常见，因此需要使用更为高级的调试工具。接下来将介绍
PyCharm IDE 的调试方法 .

*** 使用 PyCharm 进行调试

PyCharm 是由 JetBrains 打造的一款 Python IDE，具有语法高亮、Project
管理、代码跳转、智能提示、自动完成、单元测试、版本控制等功能，同时提供了对
Django 开发以及 Google App Engine 的支持。分为个人独立版和商业版，需要
license 支持，也可以获取免费的 30 天试用。试用版本的 Pycharm
可以在官网上下载，下载地址为：http://www.jetbrains.com/pycharm/download/index.html。
PyCharm
同时提供了较为完善的调试功能，支持多线程，远程调试等，可以支持断点设置，单步模式，表达式求值，变量查看等一系列功能。PyCharm
IDE 的调试窗口布局如图 1 所示。

****** 图 1. PyCharm IDE 窗口布局

[[image001.gif]]

下面结合实例讲述如何利用 PyCharm
进行多线程调试。具体调试所用的代码实例见清单 10。

****** 清单 10. PyCharm 调试代码实例

#+BEGIN_EXAMPLE
    __author__ = 'zhangying'
     #!/usr/bin/python
     import thread
     import time
     # Define a function for the thread
     def print_time( threadName, delay):
        count = 0
        while count <  5:
            count += 1
            print "%s: %s" % ( threadName, time.ctime(time.time()) )
     def check_sum(threadName,valueA,valueB):
        print "to calculate the sum of two number her"
        result=sum(valueA,valueB)
        print "the result is" ,result;
     def sum(valueA,valueB):
        if valueA >0 and valueB>0:
            return valueA+valueB
     def readFile(threadName, filename):
        file = open(filename)
        for line in file.xreadlines():
            print line
     try:
        thread.start_new_thread( print_time, ("Thread-1", 2, ) )
        thread.start_new_thread( check_sum, ("Thread-2", 4,5, ) )
        thread.start_new_thread( readFile, ("Thread-3","test.txt",))
     except:
        print "Error: unable to start thread"
     while 1:
     #   print "end"
        pass
#+END_EXAMPLE

在调试之前通常需要设置断点，断点可以设置在循环或者条件判断的表达式处或者程序的关键点。设置断点的方法非常简单：在代码编辑框中将光标移动到需要设置断点的行，然后直接按
Ctrl+F8 或者选择菜单"Run"->"Toggle Line Break
Point"，更为直接的方法是双击代码编辑处左侧边缘，可以看到出现红色的小圆点（如图
2）。当调试开始的时候，当前正在执行的代码会直接显示为蓝色。下图中设置了三个断点，蓝色高亮显示的为正在执行的代码。

****** 图 2. 断点设置

[[image002.jpg]]

表达式求值：在调试过程中有的时候需要追踪一些表达式的值来发现程序中的问题，Pycharm
支持表达式求值，可以通过选中该表达式，然后选择“Run”->”Evaluate
Expression”，在出现的窗口中直接选择 Evaluate 便可以查看。

Pychar 同时提供了 Variables 和 Watches
窗口，其中调试步骤中所涉及的具体变量的值可以直接在 variable 一栏中查看。

****** 图 3. 变量查看

[[image003.jpg]]

如果要动态的监测某个变量可以直接选中该变量并选择菜单”Run”->”Add
Watch”添加到 watches
栏中。当调试进行到该变量所在的语句时，在该窗口中可以直接看到该变量的具体值。

****** 图 4. 监测变量

[[image004.jpg]]

对于多线程程序来说，通常会有多个线程，当需要 debug
的断点分别设置在不同线程对应的线程体中的时候，通常需要 IDE
有良好的多线程调试功能的支持。 Pycharm
中在主线程启动子线程的时候会自动产生一个 Dummy
开头的名字的虚拟线程，每一个 frame 对应各自的调试帧。如图
5，本实例中一共有四个线程，其中主线程生成了三个线程，分别为
Dummy-4,Dummy-5,Dummy-6. 其中 Dummy-4 对应线程 1，其余分别对应线程 2
和线程 3。

****** 图 5. 多线程窗口

[[image005.jpg]]

当调试进入到各个线程的子程序时，Frame 会自动切换到其所对应的
frame，相应的变量栏中也会显示与该过程对应的相关变量，如图
6，直接控制调试按钮，如 setp in，step over 便可以方便的进行调试。

****** 图 6. 子线程调试

[[image006.jpg]]

查看[[image006_lg.jpg][大图]]。

*** 使用 PyDev 进行调试

PyDev 是一个开源的的 plugin，它可以方便的和 Eclipse
集成，提供方便强大的调试功能。同时作为一个优秀的 Python IDE
还提供语法错误提示、源代码编辑助手、Quick Outline、Globals
Browser、Hierarchy View、运行等强大功能。下面讲述如何将 PyDev 和 Eclipse
集成。在安装 PyDev 之前，需要先安装 Java 1.4 或更高版本、Eclipse 以及
Python。 第一步：启动 Eclipse，在 Eclipse 菜单栏中找到 Help 栏，选择
Help > Install New Software，并选择 Add button，添加 Ptdev 的下载站点
http://pydev.org/updates。选择 PyDev 之后完成余下的步骤便可以安装
PyDev。

****** 图 7. 安装 PyDev

[[image007.jpg]]

安装完成之后需要配置 Python 解释器，在 Eclipse 菜单栏中，选择 Window >
Preferences > Pydev > Interpreter -- Python。Python 安装在 C:\Python27
路径下。单击 New，选择 Python 解释器
python.exe，打开后显示出一个包含很多复选框的窗口，选择需要加入系统
PYTHONPATH 的路径，单击 OK。

****** 图 8. 配置 PyDev

[[image008.jpg]]

在配置完 Pydev 之后，可以通过在 Eclipse 菜单栏中，选择 File > New >
Project > Pydev >Pydev Project，单击 Next 创建 Python
项目，下面的内容假设 python 项目已经创建，并且有个需要调试的脚本
remote.py（具体内容如下），它是一个登陆到远程机器上去执行一些命令的脚本，在运行的时候需要传入一些参数，下面将详细讲述如何在调试过程中传入参数
.

****** 清单 11. Pydev 调试示例代码

#+BEGIN_EXAMPLE
     #!/usr/bin/env python
     import os
     def telnetdo(HOST=None, USER=None, PASS=None, COMMAND=None): #define a function
         import telnetlib, sys
         if not HOST:
             try:
                 HOST = sys.argv[1]
                 USER = sys.argv[2]
                 PASS = sys.argv[3]
                 COMMAND = sys.argv[4]
             except:
                 print "Usage: remote.py host user pass command"
                 return
         tn = telnetlib.Telnet() #
         try:
             tn.open(HOST)
         except:
             print "Cannot open host"
             return
         tn.read_until("login:")
         tn.write(USER + '\n')
         if PASS:
             tn.read_until("Password:")
             tn.write(PASS + '\n')
             tn.write(COMMAND + '\n')
             tn.write("exit\n")
             tmp = tn.read_all()
             tn.close()
             del tn
             return tmp

     if __name__ == '__main__':
         print telnetdo()
#+END_EXAMPLE

在调试的时候有些情况需要传入一些参数，在调试之前需要进行相应的配置以便接收所需要的参数，选择需要调试的程序（本例
remote.py），该脚本在 debug
的过程中需要输入四个参数：host，user，password 以及命令。在 eclipse
的工程目录下选择需要 debug 的程序，单击右键，选择“Debug As”->“Debug
Configurations”，在 Arguments Tab 页中选择“Variables”。如下 图 9 所示 .

****** 图 9. 配置变量

[[image009.gif]]

在窗口”Select Variable”之后选择“Edit Varuables”
，出现如下窗口，在下图中选择”New”
并在弹出的窗口中输入对应的变量名和值。特别需要注意的是在值的后面一定要有空格，不然所有的参数都会被当做第一个参数读入。

****** 图 10. 添加具体变量

[[image010.gif]]

按照以上方式依次配置完所有参数，然后在”select
variable“窗口中安装参数所需要的顺序依次选择对应的变量。配置完成之后状态如下图
11 所示。

****** 图 11. 完成配置

[[image011.jpg]]

选择 Debug 便可以开始程序的调试，调试方法与 eclipse
内置的调试功能的使用相似，并且支持多线程的
debug，这方面的文章已经有很多，读者可以自行搜索阅读，或者参考”使用
Eclipse 平台进行调试“一文。

*** 使用日志功能达到调试的目的

日志信息是软件开发过程中进行调试的一种非常有用的方式，特别是在大型软件开发过程需要很多相关人员进行协作的情况下。开发人员通过在代码中加入一些特定的能够记录软件运行过程中的各种事件信息能够有利于甄别代码中存在的问题。这些信息可能包括时间，描述信息以及错误或者异常发生时候的特定上下文信息。
最原始的 debug 方法是通过在代码中嵌入 print
语句，通过输出一些相关的信息来定位程序的问题。但这种方法有一定的缺陷，正常的程序输出和
debug 信息混合在一起，给分析带来一定困难，当程序调试结束不再需要 debug
输出的时候，通常没有很简单的方法将 print
的信息屏蔽掉或者定位到文件。python 中自带的 logging
模块可以比较方便的解决这些问题，它提供日志功能，将 logger 的 level
分为五个级别，可以通过 Logger.setLevel(lvl) 来设置。默认的级别为
warning。

****** 表 2. 日志的级别

Level

使用情形

DEBUG

详细的信息，在追踪问题的时候使用

INFO

正常的信息

WARNING

一些不可预见的问题发生，或者将要发生，如磁盘空间低等，但不影响程序的运行

ERROR

由于某些严重的问题，程序中的一些功能受到影响

CRITICAL

严重的错误，或者程序本身不能够继续运行

logging lib 包含 4 个主要对象

-  logger:logger
   是程序信息输出的接口。它分散在不同的代码中使得程序可以在运行的时候记录相应的信息，并根据设置的日志级别或
   filter 来决定哪些信息需要输出并将这些信息分发到其关联的
   handler。常用的方法有 Logger.setLevel()，Logger.addHandler()
   ，Logger.removeHandler() ，Logger.addFilter() ，Logger.debug(),
   Logger.info(), Logger.warning(), Logger.error()，getLogger()
   等。logger 支持层次继承关系，子 logger 的名称通常是父 logger.name
   的方式。如果不创建 logger 的实例，则使用默认的 root logger，通过
   logging.getLogger() 或者 logging.getLogger("") 得到 root logger
   实例。
-  Handler:Handler
   用来处理信息的输出，可以将信息输出到控制台，文件或者网络。可以通过
   Logger.addHandler() 来给 logger 对象添加 handler，常用的 handler 有
   StreamHandler 和 FileHandler 类。StreamHandler 发送错误信息到流，而
   FileHandler 类用于向文件输出日志信息，这两个 handler 定义在 logging
   的核心模块中。其他的 hander 定义在 logging.handles 模块中，如
   HTTPHandler,SocketHandler。
-  Formatter:Formatter 则决定了 log 信息的格式 , 格式使用类似于 %(<
   dictionary key >)s 的形式来定义，如'%(asctime)s - %(levelname)s -
   %(message)s'，支持的 key 可以在 python 自带的文档 LogRecord
   attributes 中查看。
-  Filter:Filter 用来决定哪些信息需要输出。可以被 handler 和 logger
   使用，支持层次关系，比如如果设置了 filter 为名称为 A.B 的
   logger，则该 logger 和其子 logger 的信息会被输出，如 A.B,A.B.C.

****** 清单 12. 日志使用示例

#+BEGIN_EXAMPLE
    import logging
     LOG1=logging.getLogger('b.c')
     LOG2=logging.getLogger('d.e')
     filehandler = logging.FileHandler('test.log','a')
     formatter = logging.Formatter('%(name)s %(asctime)s %(levelname)s %(message)s')
     filehandler.setFormatter(formatter)
     filter=logging.Filter('b')
     filehandler.addFilter(filter)
     LOG1.addHandler(filehandler)
     LOG2.addHandler(filehandler)
     LOG1.setLevel(logging.INFO)
     LOG2.setLevel(logging.DEBUG)
     LOG1.debug('it is a debug info for log1')
     LOG1.info('normal infor for log1')
     LOG1.warning('warning info for log1:b.c')
     LOG1.error('error info for log1:abcd')
     LOG1.critical('critical info for log1:not worked')
     LOG2.debug('debug info for log2')
     LOG2.info('normal info for log2')
     LOG2.warning('warning info for log2')
     LOG2.error('error:b.c')
     LOG2.critical('critical')
#+END_EXAMPLE

上例设置了 filter b，则 b.c 为 b 的子 logger，因此满足过滤条件该 logger
相关的日志信息会 被输出，而其他不满足条件的 logger（这里是
d.e）会被过滤掉。

****** 清单 13. 输出结果

#+BEGIN_EXAMPLE
    b.c 2011-11-25 11:07:29,733 INFO normal infor for log1
     b.c 2011-11-25 11:07:29,733 WARNING warning info for log1:b.c
     b.c 2011-11-25 11:07:29,733 ERROR error info for log1:abcd
     b.c 2011-11-25 11:07:29,733 CRITICAL critical info for log1:not worked
#+END_EXAMPLE

logging
的使用非常简单，同时它是线程安全的，下面结合多线程的例子讲述如何使用
logging 进行 debug。

****** 清单 14. 多线程使用 logging

#+BEGIN_EXAMPLE
    logging.conf
     [loggers]
     keys=root,simpleExample

     [handlers]
     keys=consoleHandler

     [formatters]
     keys=simpleFormatter

     [logger_root]
     level=DEBUG
     handlers=consoleHandler

     [logger_simpleExample]
     level=DEBUG
     handlers=consoleHandler
     qualname=simpleExample
     propagate=0

     [handler_consoleHandler]
     class=StreamHandler
     level=DEBUG
     formatter=simpleFormatter
     args=(sys.stdout,)

     [formatter_simpleFormatter]
     format=%(asctime)s - %(name)s - %(levelname)s - %(message)s
     datefmt=

     code example:
     #!/usr/bin/python
     import thread
     import time
     import logging
     import logging.config
     logging.config.fileConfig('logging.conf')
     # create logger
     logger = logging.getLogger('simpleExample')
     # Define a function for the thread
     def print_time( threadName, delay):
         logger.debug('thread 1 call print_time function body')
         count = 0
         logger.debug('count:%s',count)
#+END_EXAMPLE

*** 总结

全文介绍了 python 中 debug 的几种不同的方式，包括 pdb 模块、利用 PyDev
和 Eclipse 集成进行调试、PyCharm 以及 Debug 日志进行调试，希望能给相关
python 使用者一点参考。更多关于 python debugger 的资料可以参见参考资料。

*** 参考资料

**** 学习

-  参考 [[http://www.python.org/doc/][Tutorial Python]]查看 Python
   的官方文档。
-  参考 [[http://docs.python.org/library/logging.html][Python
   Logging]]文档获取更多的 logging 使用信息。
-  在 [[http://www.ibm.com/developerworks/cn/linux/][developerWorks
   Linux 专区]] 寻找为 Linux 开发人员（包括
   [[http://www.ibm.com/developerworks/cn/linux/newto/][Linux
   新手入门]]）准备的更多参考资料，查阅我们
   [[http://www.ibm.com/developerworks/cn/linux/best2009/index.html][最受欢迎的文章和教程]]。
-  在 developerWorks 上查阅所有
   [[http://www.ibm.com/developerworks/cn/views/linux/libraryview.jsp?search_by=Linux+%E6%8A%80%E5%B7%A7][Linux
   技巧]] 和
   [[http://www.ibm.com/developerworks/cn/views/linux/libraryview.jsp?type_by=%E6%95%99%E7%A8%8B][Linux
   教程]]。
-  随时关注 developerWorks
   [[http://www.ibm.com/developerworks/cn/offers/techbriefings/][技术活动]]和[[http://www.ibm.com/developerworks/cn/swi/][网络广播]]。

**** 讨论

-  参考 [[http://wiki.python.org/moin/PythonDebuggers][Python Debugger
   博客]]获取更多的 Python debug 信息。
-  加入
   [[http://www.ibm.com/developerworks/cn/community/][developerWorks
   中文社区]]，developerWorks 社区是一个面向全球 IT
   专业人员，可以提供博客、书签、wiki、群组、联系、共享和协作等社区功能的专业社交网络社区。
-  加入
   [[https://www.ibm.com/developerworks/mydeveloperworks/groups/service/html/communityview?communityUuid=38997896-bb16-451a-aa97-189a27a3cd5a/?lang=zh][IBM
   软件下载与技术交流群组]]，参与在线交流。

** [[http://clojure.iteye.com/blog/1724910][Emacs配置Python IDE]]


最近要学习Python编程，正好也在学习Emacs。所以借助Google到处乱搜一气，终于完成Emacs下的Python
IDE配置。

Emacs的Python IDE配置需要用到如下插件：

1、[[http://rope.sourceforge.net/ropemacs.html][Ropemacs]]:
一个python在emacs中的重构插件。它依赖于rope和pymacs（也就是说，要装它先要装好rope和pymacs）。

2、python-mode和[[http://www.rwdev.eu/articles/emacspyeng][python-completion]]：分别是Emacs中的python模式和自动补全提示插件。

3、[[https://github.com/akaihola/flymake-python][flymake-python]]：emacs中python语法检测工具。

4、auto-complete：自动补全插件。

5、Yasnippet：snippet补全插件，国人编写，享誉国际的插件。

6、cedet：Emacs开发环境工具集合。emacs23之后似乎就内置其中了。

7、ecb：代码浏览的插件。使你的Emacs看起来和真正的IDE一样。


以上工具不提供链接的可以通过Emacs内置的package安装工具。执行M+x
“package-list-packages” 来进行安装。其他的可以看说明文档进行安装。

最省力的安装是，直接安装别人整合好的一个配置[[https://github.com/gabrielelanaro/emacs-for-python][emacs-for-python]]
直接下载下来，并在.emacs文件中添加：

#+BEGIN_EXAMPLE
     (load-file "~/.emacs.d/emacs-for-python/epy-init.el")
#+END_EXAMPLE


如果要配置代码错误检测，添加：

#+BEGIN_EXAMPLE
     (epy-setup-checker "pyflakes %f")
#+END_EXAMPLE


（不过我觉得还是自己一个个安装比较好，不然哪天来个emacs-for-clojure，后天在来个emacs-for-ruby之类的难保里面的package没有重复冲突的）

** [[http://www.cnblogs.com/QLeelulu/archive/2009/09/20/1570292.html][Python的bool类型]]

写习惯了C#的代码，在想要将一个字符串'False'转换为bool型的时候，很自然的写了如下的Python代码：

[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_2.png][[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb.png]]]]

看到上面的结果了没？是True。突然记起Python中除了''、""、0、()、[]、{}、None为False之外，其他的都是True。也就是说上面的'False'就是一个不为空的字符串，所以结果就为True了。

为了深入了解下Python的bool类型，就看了下说明：

>>> help(True)
Help on bool object:

class bool(int)
 |  bool(x) -> bool
 |
 |  Returns True when the argument x is true, False otherwise.
 |  The builtins True and False are the only two instances of the class
bool.
 |  The class bool is a subclass of the class int, and cannot be
subclassed.
 |
 |  Method resolution order:
 |  bool
 |  int
 |  object
 |
 |  Methods defined here:
 |
 |  __and__(...)
 |  x.__and__(y) <==> x&y
 |
 |  __or__(...)
 |  x.__or__(y) <==> x|y

可以看到bool是int的子类来的，并且不可以子类化：

[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_4.png][[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_1.png]]]]

因为bool为int的子类，所以用1表示True，0表示False：

[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_6.png][[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_2.png]]]]

看到上面2==True是为false的。但是我们看下面的代码：

[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_8.png][[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_3.png]]]]

我们看到True被打印出来了，我想这样是因为if语句会在内部去调用bool()方法：

[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_10.png][[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_4.png]]]]

因为bool是继承自int类型的，所以我猜想在比较的时候最终是会转换为0和1来比较的，就像：

[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_12.png][[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_5.png]]]]

(注：这里只是猜想，未经证实)

既然bool是继承自int类型的所以很自然bool类型是支持数学运算的：

[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_14.png][[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_6.png]]]]

最后，我能想到的判断字符串是否有'False'的就是：

[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_16.png][[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_7.png]]]]

不知道是否有更好的方法呢？

** [[http://blog.sina.com.cn/s/blog_a15aa56901017u0c.html][配置Emacs下的Python开发环境]]


*** 特性

在Linux论坛上总有人问Python用什么IDE比较好，然后总会有人回答说Emacs。最近开始学Python，也花了点时间研究怎么配置Emacs，发现没有想象中的那么麻烦。这篇文章大致上来自于[[http://hide1713.wordpress.com/2009/01/30/setup-perfect-python-environment-in-emacs/][Lei
Chen博客文章的翻译]]，完成以后的Emacs具有以下特性:

-  自动完成同一个文件内的变量、函数
-  自动完成python库中的名称
-  代码重构
-  模板展开功能
-  在线帮助系统
-  即时语法检测

其他特性还包括自动缩进，括号匹配，语法高亮，代码折叠等等。其中最有用的莫过于自动完成了，貌似很少有python编辑器可以做到这一点。而即时语法检测让emacs下的python代码书写变得像Eclipse一样，一旦有错误立刻就会高亮标记出来。

*** 如何安装

首先你得在home目录下有一个.emacs配置文件，并且有一个用来放插件的文件夹（比如说~/.emacs.d/）

1. 下载auto-completion.el到.emacs.d，并且在.emacs中添加如下几行：

   #+BEGIN_EXAMPLE
       (require ‘auto-complete)
       (global-auto-complete-mode t)
   #+END_EXAMPLE

2. 下载yasnippet到.emacs.d并且编辑.emacs:

   #+BEGIN_EXAMPLE
       (require ‘yasnippet) (yas/initialize) (yas/load-directory “~/.emacs.d/snippets”)
   #+END_EXAMPLE

3. 下载python-mode.el并且放到.emacs.d中。我们会在之后的配置中用到它
4. 设置Rope, Ropemacs

   我们需要使用最新的development版的rope和ropemacs，否则在emacs中不能找到rope-completion函数。通过如下步骤安装：

   #+BEGIN_EXAMPLE
       sudo apt-get install mercurial python-setuptools
       mkdir /tmp/rope && cd /tmp/rope
       hg clone http://bitbucket.org/agr/rope
       hg clone http://bitbucket.org/agr/ropemacs
       hg clone http://bitbucket.org/agr/ropemode
       sudo easy_install rope
       ln -s ../ropemode/ropemode ropemacs/
       sudo easy_install ropemacs
   #+END_EXAMPLE

5. 到 http://pymacs.progiciels-bpi.ca/archives/ 下载 pymacs并安装
6. 安装pyflacks以进行自动语法检查：

   #+BEGIN_EXAMPLE
       sudo apt-get install pyflakes
   #+END_EXAMPLE

7. 把所有东西放到一块儿
8. 在你的.emacs.d中创建一个init_python.el，并且加入以下内容：

   #+BEGIN_EXAMPLE
       (autoload 'python-mode "python-mode" "Python Mode." t)
       (add-to-list 'auto-mode-alist '("\\.py\\'" . python-mode))
       (add-to-list 'interpreter-mode-alist '("python" . python-mode))
       (require 'python-mode)
       (add-hook 'python-mode-hook
             (lambda ()
        (set-variable 'py-indent-offset 4)
        ;(set-variable 'py-smart-indentation nil)
        (set-variable 'indent-tabs-mode nil)
        (define-key py-mode-map (kbd "RET") 'newline-and-indent)
        ;(define-key py-mode-map [tab] 'yas/expand)
        ;(setq yas/after-exit-snippet-hook 'indent-according-to-mode)
        (smart-operator-mode-on)
        ))
       ;; pymacs
       (autoload 'pymacs-apply "pymacs")
       (autoload 'pymacs-call "pymacs")
       (autoload 'pymacs-eval "pymacs" nil t)
       (autoload 'pymacs-exec "pymacs" nil t)
       (autoload 'pymacs-load "pymacs" nil t)
       ;;(eval-after-load "pymacs"
       ;;  '(add-to-list 'pymacs-load-path YOUR-PYMACS-DIRECTORY"))
       (pymacs-load "ropemacs" "rope-")
       (setq ropemacs-enable-autoimport t)
       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       ;;; Auto-completion
       ;;;  Integrates:
       ;;;   1) Rope
       ;;;   2) Yasnippet
       ;;;   all with AutoComplete.el
       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       (defun prefix-list-elements (list prefix)
         (let (value)
           (nreverse
            (dolist (element list value)
             (setq value (cons (format "%s%s" prefix element) value))))))
       (defvar ac-source-rope
         '((candidates
            . (lambda ()
                (prefix-list-elements (rope-completions) ac-target))))
         "Source for Rope")
       (defun ac-python-find ()
         "Python `ac-find-function'."
         (require 'thingatpt)
         (let ((symbol (car-safe (bounds-of-thing-at-point 'symbol))))
           (if (null symbol)
               (if (string= "." (buffer-substring (- (point) 1) (point)))
                   (point)
                 nil)
             symbol)))
       (defun ac-python-candidate ()
         "Python `ac-candidates-function'"
         (let (candidates)
           (dolist (source ac-sources)
             (if (symbolp source)
                 (setq source (symbol-value source)))
             (let* ((ac-limit (or (cdr-safe (assq 'limit source)) ac-limit))
                    (requires (cdr-safe (assq 'requires source)))
                    cand)
               (if (or (null requires)
                       (>= (length ac-target) requires))
                   (setq cand
                         (delq nil
                               (mapcar (lambda (candidate)
                                         (propertize candidate 'source source))
                                       (funcall (cdr (assq 'candidates source)))))))
               (if (and (> ac-limit 1)
                        (> (length cand) ac-limit))
                   (setcdr (nthcdr (1- ac-limit) cand) nil))
               (setq candidates (append candidates cand))))
           (delete-dups candidates)))
       (add-hook 'python-mode-hook
                 (lambda ()
                        (auto-complete-mode 1)
                        (set (make-local-variable 'ac-sources)
                             (append ac-sources '(ac-source-rope) '(ac-source-yasnippet)))
                        (set (make-local-variable 'ac-find-function) 'ac-python-find)
                        (set (make-local-variable 'ac-candidate-function) 'ac-python-candidate)
                        (set (make-local-variable 'ac-auto-start) nil)))
       ;;Ryan's python specific tab completion
       (defun ryan-python-tab ()
         ; Try the following:
         ; 1) Do a yasnippet expansion
         ; 2) Do a Rope code completion
         ; 3) Do an indent
         (interactive)
         (if (eql (ac-start) 0)
             (indent-for-tab-command)))
       (defadvice ac-start (before advice-turn-on-auto-start activate)
         (set (make-local-variable 'ac-auto-start) t))
       (defadvice ac-cleanup (after advice-turn-off-auto-start activate)
         (set (make-local-variable 'ac-auto-start) nil))
       (define-key py-mode-map "\t" 'ryan-python-tab)
       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       ;;; End Auto Completion
       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       ;; Auto Syntax Error Hightlight
       (when (load "flymake" t)
         (defun flymake-pyflakes-init ()
           (let* ((temp-file (flymake-init-create-temp-buffer-copy
                'flymake-create-temp-inplace))
           (local-file (file-relative-name
          temp-file
          (file-name-directory buffer-file-name))))
             (list "pyflakes" (list local-file))))
         (add-to-list 'flymake-allowed-file-name-masks
               '("\\.py\\'" flymake-pyflakes-init)))
       (add-hook 'find-file-hook 'flymake-find-file-hook)
       (provide 'init_python)
   #+END_EXAMPLE

9. 在你的.emacs文件中添加：(load-library “init_python”)

*** 使用说明

1. 代
   码自动展开。比如说在编辑C/C++头文件的时候键入once然后按tab，则会自动展开#ifndef
   __FILE_H__这样的宏。这个功能是YASnippet提供的，在emacs的菜单中可以看到它的所有宏。展开以后再按tab键可以在已展开的代码
   之间切换位置。
2. 自动完成代码。函数名输入到一半按tab键会调用Rope和Ropemacs的功能自动完成库文件中的函数、变量名
3. C-c d 显示python的doc string
4. C-c C-c 运行当前的文件
5. C-c ! 打开python shell

事
实上init_python.el做的事情是通过使用auto_complete.el中的功能，把YASnippet和Rope的功能结合到了
一块儿，实现了类似TexMate的自动完成等功能。其中YASnippet可以自定义模板，很是实用。Rope的功能还在研究中。

** [[http://old.sebug.net/paper/books/scipydoc/matplotlib_intro.html#artist][matplotlib-绘制精美的图表]]

[[http://matplotlib.sourceforge.net/][matplotlib]]
是python最著名的绘图库，它提供了一整套和matlab相似的命令API，十分适合交互式地进行制图。而且也可以方便地将它作为绘图控件，嵌入GUI应用程序中。

它的文档相当完备，并且
[[http://matplotlib.sourceforge.net/gallery.html][Gallery页面]]
中有上百幅缩略图，打开之后都有源程序。因此如果你需要绘制某种类型的图，只需要在这个页面中浏览/复制/粘贴一下，基本上都能搞定。

本章节作为matplotlib的入门介绍，将较为深入地挖掘几个例子，从中理解和学习matplotlib绘图的一些基本概念。

*** 快速绘图[[#id2][¶]]

matplotlib的pyplot子库提供了和matlab类似的绘图API，方便用户快速绘制2D图表。让我们先来看一个简单的例子：

#+BEGIN_EXAMPLE
    # -*- coding: utf-8 -*-
    import numpy as np
    import matplotlib.pyplot as plt

    x = np.linspace(0, 10, 1000)
    y = np.sin(x)
    z = np.cos(x**2)

    plt.figure(figsize=(8,4))
    plt.plot(x,y,label="$sin(x)$",color="red",linewidth=2)
    plt.plot(x,z,"b--",label="$cos(x^2)$")
    plt.xlabel("Time(s)")
    plt.ylabel("Volt")
    plt.title("PyPlot First Example")
    plt.ylim(-1.2,1.2)
    plt.legend()
    plt.show()
#+END_EXAMPLE

[[_images/pyplot_simple_plot.png]]

调用pyplot库快速将数据绘制成曲线图

matplotlib中的快速绘图的函数库可以通过如下语句载入：

#+BEGIN_EXAMPLE
    import matplotlib.pyplot as plt
#+END_EXAMPLE

pylab模块

matplotlib还提供了名为pylab的模块，其中包括了许多numpy和pyplot中常用的函数，方便用户快速进行计算和绘图，可以用于IPython中的快速交互式使用。

接下来调用figure创建一个绘图对象，并且使它成为当前的绘图对象。

#+BEGIN_EXAMPLE
    plt.figure(figsize=(8,4))
#+END_EXAMPLE

也可以不创建绘图对象直接调用接下来的plot函数直接绘图，matplotlib会为我们自动创建一个绘图对象。如果需要同时绘制多幅图表的话，可以是给figure传递一个整数参数指定图标的序号，如果所指定序号的绘图对象已经存在的话，将不创建新的对象，而只是让它成为当前绘图对象。

通过figsize参数可以指定绘图对象的宽度和高度，单位为英寸；dpi参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80。因此本例中所创建的图表窗口的宽度为8*80
= 640像素。

但是用工具栏中的保存按钮保存下来的png图像的大小是800*400像素。这是因为保存图表用的函数savefig使用不同的DPI配置，savefig函数也有一个dpi参数，如果不设置的话，将使用matplotlib配置文件中的配置，此配置可以通过如下语句进行查看，关于配置文件将在后面的章节进行介绍：

#+BEGIN_EXAMPLE
    >>> import matplotlib
    >>> matplotlib.rcParams["savefig.dpi"]
    100
#+END_EXAMPLE

下面的两行程序通过调用plot函数在当前的绘图对象中进行绘图：

#+BEGIN_EXAMPLE
    plt.plot(x,y,label="$sin(x)$",color="red",linewidth=2)
    plt.plot(x,z,"b--",label="$cos(x^2)$")
#+END_EXAMPLE

plot函数的调用方式很灵活，第一句将x,y数组传递给plot之后，用关键字参数指定各种属性：

-  *label* :
   给所绘制的曲线一个名字，此名字在图示(legend)中显示。只要在字符串前后添加"$"符号，matplotlib就会使用其内嵌的latex引擎绘制的数学公式。
-  *color* : 指定曲线的颜色
-  *linewidth* : 指定曲线的宽度

第二句直接通过第三个参数"b--"指定曲线的颜色和线型，这个参数称为格式化参数，它能够通过一些易记的符号快速指定曲线的样式。其中b表示蓝色，"--"表示线型为虚线。在IPython中输入
"plt.plot?" 可以查看格式化字符串的详细配置。

接下来通过一系列函数设置绘图对象的各个属性：

#+BEGIN_EXAMPLE
    plt.xlabel("Time(s)")
    plt.ylabel("Volt")
    plt.title("PyPlot First Example")
    plt.ylim(-1.2,1.2)
    plt.legend()
#+END_EXAMPLE

-  *xlabel* : 设置X轴的文字
-  *ylabel* : 设置Y轴的文字
-  *title* : 设置图表的标题
-  *ylim* : 设置Y轴的范围
-  *legend* : 显示图示

最后调用plt.show()显示出我们创建的所有绘图对象。

**** 配置属性[[#id3][¶]]

matplotlib所绘制的图的每个组成部分都对应有一个对象，我们可以通过调用这些对象的属性设置方法set_*或者pyplot的属性设置函数setp设置其属性值。例如plot函数返回一个
matplotlib.lines.Line2D
对象的列表，下面的例子显示如何设置Line2D对象的属性：

#+BEGIN_EXAMPLE
    >>> import numpy as np
    >>> import matplotlib.pyplot as plt
    >>> x = np.arange(0, 5, 0.1)
    >>> line, = plt.plot(x, x*x) # plot返回一个列表，通过line,获取其第一个元素
    >>> # 调用Line2D对象的set_*方法设置属性值
    >>> line.set_antialiased(False)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    >>> # 同时绘制sin和cos两条曲线，lines是一个有两个Line2D对象的列表
    >>> lines = plt.plot(x, np.sin(x), x, np.cos(x)) #
    >>> # 调用setp函数同时配置多个Line2D对象的多个属性值
    >>> plt.setp(lines, color="r", linewidth=2.0)
#+END_EXAMPLE

这段例子中，通过调用Line2D对象line的set_antialiased方法，关闭对象的反锯齿效果。或者通过调用plt.setp函数配置多个Line2D对象的颜色和线宽属性。

同样我们可以通过调用Line2D对象的get_*方法，或者plt.getp函数获取对象的属性值：

#+BEGIN_EXAMPLE
    >>> line.get_linewidth()
    1.0
    >>> plt.getp(lines[0], "color") # 返回color属性
    'r'
    >>> plt.getp(lines[1]) # 输出全部属性
    alpha = 1.0
    animated = False
    antialiased or aa = True
    axes = Axes(0.125,0.1;0.775x0.8)
    ... ...
#+END_EXAMPLE

注意getp函数只能对一个对象进行操作，它有两种用法：

-  指定属性名：返回对象的指定属性的值
-  不指定属性名：打印出对象的所有属性和其值

matplotlib的整个图表为一个Figure对象，此对象在调用plt.figure函数时返回，我们也可以通过plt.gcf函数获取当前的绘图对象：

#+BEGIN_EXAMPLE
    >>> f = plt.gcf()
    >>> plt.getp(f)
    alpha = 1.0
    animated = False
    ...
#+END_EXAMPLE

Figure对象有一个axes属性，其值为AxesSubplot对象的列表，每个AxesSubplot对象代表图表中的一个子图，前面所绘制的图表只包含一个子图，当前子图也可以通过plt.gca获得：

#+BEGIN_EXAMPLE
    >>> plt.getp(f, "axes")
    [<matplotlib.axes.AxesSubplot object at 0x05CDD170>]
    >>> plt.gca()
    <matplotlib.axes.AxesSubplot object at 0x05CDD170>
#+END_EXAMPLE

用plt.getp可以发现AxesSubplot对象有很多属性，例如它的lines属性为此子图所包括的
Line2D 对象列表：

#+BEGIN_EXAMPLE
    >>> alllines = plt.getp(plt.gca(), "lines")
    >>> alllines
    <a list of 3 Line2D objects>
    >>> alllines[0] == line # 其中的第一条曲线就是最开始绘制的那条曲线
    True
#+END_EXAMPLE

通过这种方法我们可以很容易地查看对象的属性和它们之间的包含关系，找到需要配置的属性。

*** 绘制多轴图[[#id4][¶]]

一个绘图对象(figure)可以包含多个轴(axis)，在Matplotlib中用轴表示一个绘图区域，可以将其理解为子图。上面的第一个例子中，绘图对象只包括一个轴，因此只显示了一个轴(子图)。我们可以使用subplot函数快速绘制有多个轴的图表。subplot函数的调用形式如下：

#+BEGIN_EXAMPLE
    subplot(numRows, numCols, plotNum)
#+END_EXAMPLE

subplot将整个绘图区域等分为numRows行 *
numCols列个子区域，然后按照从左到右，从上到下的顺序对每个子区域进行编号，左上的子区域的编号为1。如果numRows，numCols和plotNum这三个数都小于10的话，可以把它们缩写为一个整数，例如subplot(323)和subplot(3,2,3)是相同的。subplot在plotNum指定的区域中创建一个轴对象。如果新创建的轴和之前创建的轴重叠的话，之前的轴将被删除。

下面的程序创建3行2列共6个轴，通过axisbg参数给每个轴设置不同的背景颜色。

#+BEGIN_EXAMPLE
    for idx, color in enumerate("rgbyck"):
        plt.subplot(320+idx+1, axisbg=color)
    plt.show()
#+END_EXAMPLE

[[_images/pyplot_subplot01.png]]

用subplot函数将Figure分为六个子图区域

如果希望某个轴占据整个行或者列的话，可以如下调用subplot：

#+BEGIN_EXAMPLE
    plt.subplot(221) # 第一行的左图
    plt.subplot(222) # 第一行的右图
    plt.subplot(212) # 第二整行
    plt.show()
#+END_EXAMPLE

[[_images/pyplot_subplot02.png]]

将Figure分为三个子图区域

当绘图对象中有多个轴的时候，可以通过工具栏中的Configure
Subplots按钮，交互式地调节轴之间的间距和轴与边框之间的距离。如果希望在程序中调节的话，可以调用subplots_adjust函数，它有left,
right, bottom, top, wspace,
hspace等几个关键字参数，这些参数的值都是0到1之间的小数，它们是以绘图区域的宽高为1进行正规化之后的坐标或者长度。

*** 配置文件[[#id5][¶]]

一幅图有许多需要配置的属性，例如颜色、字体、线型等等。我们在绘图时，并没有一一对这些属性进行配置，许多都直接采用了Matplotlib的缺省配置。Matplotlib将缺省配置保存在一个文件中，通过更改这个文件，我们可以修改这些属性的缺省值。

Matplotlib 使用配置文件 matplotlibrc 时的搜索顺序如下：

-  *当前路径* : 程序的当前路径
-  *用户配置路径* : 通常为
   HOME/.matplotlib/，可以通过环境变量MATPLOTLIBRC修改
-  *系统配置路径* : 保存在 matplotlib的安装目录下的 mpl-data 下

通过下面的语句可以获取用户配置路径：

#+BEGIN_EXAMPLE
    >>> import matplotlib
    >>> matplotlib.get_configdir()
    'C:\\Documents and Settings\\zhang\\.matplotlib'
#+END_EXAMPLE

通过下面的语句可以获得目前使用的配置文件的路径：

#+BEGIN_EXAMPLE
    >>> import matplotlib
    >>> matplotlib.matplotlib_fname()
    'C:\\Python26\\lib\\site-packages\\matplotlib\\mpl-data\\matplotlibrc'
#+END_EXAMPLE

由于在当前路径和用户配置路径中都没有找到位置文件，因此最后使用的是系统配置路径下的配置文件。如果你将matplotlibrc复制一份到脚本的当前目录下：

#+BEGIN_EXAMPLE
    >>> import os
    >>> os.getcwd()
    'C:\\zhang\\doc'
#+END_EXAMPLE

复制配置文件之后再运行:

#+BEGIN_EXAMPLE
    >>> matplotlib.matplotlib_fname()
    'C:\\zhang\\doc\\matplotlibrc'
#+END_EXAMPLE

如果你用文本编辑器打开此配置文件的话，你会发现它实际上是定义了一个字典。为了对众多的配置进行区分，关键字可以用点分开。

配置文件的读入可以使用 rc_params 函数，它返回一个配置字典：

#+BEGIN_EXAMPLE
    >>> matplotlib.rc_params()
    {'agg.path.chunksize': 0,
     'axes.axisbelow': False,
     'axes.edgecolor': 'k',
     'axes.facecolor': 'w',
     ... ...
#+END_EXAMPLE

在matplotlib模块载入的时候会调用rc_params，并把得到的配置字典保存到rcParams变量中：

#+BEGIN_EXAMPLE
    >>> matplotlib.rcParams
    {'agg.path.chunksize': 0,
    'axes.axisbelow': False,
    ... ...
#+END_EXAMPLE

matplotlib将使用rcParams中的配置进行绘图。用户可以直接修改此字典中的配置，所做的改变会反映到此后所绘制的图中。例如下面的脚本所绘制的线将带有圆形的点标识符：

#+BEGIN_EXAMPLE
    >>> matplotlib.rcParams["lines.marker"] = "o"
    >>> import pylab
    >>> pylab.plot([1,2,3])
    >>> pylab.show()
#+END_EXAMPLE

为了方便配置，可以使用rc函数，下面的例子同时配置点标识符、线宽和颜色：

#+BEGIN_EXAMPLE
    >>> matplotlib.rc("lines", marker="x", linewidth=2, color="red")
#+END_EXAMPLE

如果希望恢复到缺省的配置(matplotlib载入时从配置文件读入的配置)的话，可以调用
rcdefaults 函数。

#+BEGIN_EXAMPLE
    >>> matplotlib.rcdefaults()
#+END_EXAMPLE

如果手工修改了配置文件，希望重新从配置文件载入最新的配置的话，可以调用：

#+BEGIN_EXAMPLE
    >>> matplotlib.rcParams.update( matplotlib.rc_params() )
#+END_EXAMPLE

*** Artist对象[[#artist][¶]]

matplotlib API包含有三层：

-  *backend_bases.FigureCanvas* : 图表的绘制领域
-  *backend_bases.Renderer* : 知道如何在FigureCanvas上如何绘图
-  *artist.Artist* : 知道如何使用Renderer在FigureCanvas上绘图

FigureCanvas和Renderer需要处理底层的绘图操作，例如使用wxPython在界面上绘图，或者使用PostScript绘制PDF。Artist则处理所有的高层结构，例如处理图表、文字和曲线等的绘制和布局。通常我们只和Artist打交道，而不需要关心底层的绘制细节。

Artists分为简单类型和容器类型两种。简单类型的Artists为标准的绘图元件，例如Line2D、
Rectangle、 Text、AxesImage
等等。而容器类型则可以包含许多简单类型的Artists，使它们组织成一个整体，例如Axis、
Axes、Figure等。

直接使用Artists创建图表的标准流程如下：

-  创建Figure对象
-  用Figure对象创建一个或者多个Axes或者Subplot对象
-  调用Axies等对象的方法创建各种简单类型的Artists

下面首先调用pyplot.figure辅助函数创建Figure对象，然后调用Figure对象的add_axes方法在其中创建一个Axes对象，add_axes的参数是一个形如[left,
bottom, width,
height]的列表，这些数值分别指定所创建的Axes对象相对于fig的位置和大小，取值范围都在0到1之间：

#+BEGIN_EXAMPLE
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> ax = fig.add_axes([0.15, 0.1, 0.7, 0.3])
#+END_EXAMPLE

然后我们调用ax的plot方法绘图，创建一条曲线，并且返回此曲线对象(Line2D)。

#+BEGIN_EXAMPLE
    >>> line, = ax.plot([1,2,3],[1,2,1])
    >>> ax.lines
    [<matplotlib.lines.Line2D object at 0x0637A3D0>]
    >>> line
    <matplotlib.lines.Line2D object at 0x0637A3D0>
#+END_EXAMPLE

ax.lines是一个为包含ax的所有曲线的列表，后续的ax.plot调用会往此列表中添加新的曲线。如果想删除某条曲线的话，直接从此列表中删除即可。

Axes对象还包括许多其它的Artists对象，例如我们可以通过调用set_xlabel设置其X轴上的标题：

#+BEGIN_EXAMPLE
    >>> ax.set_xlabel("time")
#+END_EXAMPLE

如果我们查看set_xlabel的源代码的话，会发现它是通过调用下面的语句实现的：

#+BEGIN_EXAMPLE
    self.xaxis.set_label_text(xlabel)
#+END_EXAMPLE

如果我们一直跟踪下去，会发现Axes的xaxis属性是一个XAxis对象：

#+BEGIN_EXAMPLE
    >>> ax.xaxis
    <matplotlib.axis.XAxis object at 0x06343230>
#+END_EXAMPLE

XAxis的label属性是一个Text对象：

#+BEGIN_EXAMPLE
    >>> ax.xaxis.label
    <matplotlib.text.Text object at 0x06343290>
#+END_EXAMPLE

而Text对象的_text属性为我们设置的值：

#+BEGIN_EXAMPLE
    >>> ax.xaxis.label._text
    'time'
#+END_EXAMPLE

这些对象都是Artists，因此也可以调用它们的属性获取函数来获得相应的属性：

#+BEGIN_EXAMPLE
    >>> ax.xaxis.label.get_text()
    'time'
#+END_EXAMPLE

**** Artist的属性[[#id6][¶]]

图表中的每个元素都用一个matplotlib的Artist对象表示，而每个Artist对象都有一大堆属性控制其显示效果。例如Figure对象和Axes对象都有patch属性作为其背景，它的值是一个Rectangle对象。通过设置此它的一些属性可以修改Figrue图表的背景颜色或者透明度等属性，下面的例子将图表的背景颜色设置为绿色：

#+BEGIN_EXAMPLE
    >>> fig = plt.figure()
    >>> fig.show()
    >>> fig.patch.set_color("g")
    >>> fig.canvas.draw()
#+END_EXAMPLE

patch的color属性通过set_color函数进行设置，属性修改之后并不会立即反映到图表的显示上，还需要调用fig.canvas.draw()函数才能够更新显示。

下面是Artist对象都具有的一些属性：

-  alpha : 透明度，值在0到1之间，0为完全透明，1为完全不透明
-  animated : 布尔值，在绘制动画效果时使用
-  axes : 此Artist对象所在的Axes对象，可能为None
-  clip_box : 对象的裁剪框
-  clip_on : 是否裁剪
-  clip_path : 裁剪的路径
-  contains : 判断指定点是否在对象上的函数
-  figure : 所在的Figure对象，可能为None
-  label : 文本标签
-  picker : 控制Artist对象选取
-  transform : 控制偏移旋转
-  visible : 是否可见
-  zorder : 控制绘图顺序

Artist对象的所有属性都通过相应的 get_* 和 set_*
函数进行读写，例如下面的语句将alpha属性设置为当前值的一半：

#+BEGIN_EXAMPLE
    >>> fig.set_alpha(0.5*fig.get_alpha())
#+END_EXAMPLE

如果你想用一条语句设置多个属性的话，可以使用set函数：

#+BEGIN_EXAMPLE
    >>> fig.set(alpha=0.5, zorder=2)
#+END_EXAMPLE

使用前面介绍的 matplotlib.pyplot.getp
函数可以方便地输出Artist对象的所有属性名和值。

#+BEGIN_EXAMPLE
    >>> plt.getp(fig.patch)
        aa = True
        alpha = 1.0
        animated = False
        antialiased or aa = True
        ... ...
#+END_EXAMPLE

**** Figure容器[[#figure][¶]]

现在我们知道如何观察和修改已知的某个Artist对象的属性，接下来要解决如何找到指定的Artist对象。前面我们介绍过Artist对象有容器类型和简单类型两种，这一节让我们来详细看看容器类型的内容。

最大的Artist容器是matplotlib.figure.Figure，它包括组成图表的所有元素。图表的背景是一个Rectangle对象，用Figure.patch属性表示。当你通过调用add_subplot或者add_axes方法往图表中添加轴(子图时)，这些子图都将添加到Figure.axes属性中，同时这两个方法也返回添加进axes属性的对象，注意返回值的类型有所不同，实际上AxesSubplot是Axes的子类。

#+BEGIN_EXAMPLE
    >>> fig = plt.figure()
    >>> ax1 = fig.add_subplot(211)
    >>> ax2 = fig.add_axes([0.1, 0.1, 0.7, 0.3])
    >>> ax1
    <matplotlib.axes.AxesSubplot object at 0x056BCA90>
    >>> ax2
    <matplotlib.axes.Axes object at 0x056BC910>
    >>> fig.axes
    [<matplotlib.axes.AxesSubplot object at 0x056BCA90>,
    <matplotlib.axes.Axes object at 0x056BC910>]
#+END_EXAMPLE

为了支持pylab中的gca()等函数，Figure对象内部保存有当前轴的信息，因此不建议直接对Figure.axes属性进行列表操作，而应该使用add_subplot,
add_axes,
delaxes等方法进行添加和删除操作。但是使用for循环对axes中的每个元素进行操作是没有问题的，下面的语句打开所有子图的栅格。

#+BEGIN_EXAMPLE
    >>> for ax in fig.axes: ax.grid(True)
#+END_EXAMPLE

Figure对象可以拥有自己的文字、线条以及图像等简单类型的Artist。缺省的坐标系统为像素点，但是可以通过设置Artist对象的transform属性修改坐标系的转换方式。最常用的Figure对象的坐标系是以左下角为坐标原点(0,0)，右上角为坐标(1,1)。下面的程序创建并添加两条直线到fig中：

#+BEGIN_EXAMPLE
    >>> from matplotlib.lines import Line2D
    >>> fig = plt.figure()
    >>> line1 = Line2D([0,1],[0,1], transform=fig.transFigure, figure=fig, color="r")
    >>> line2 = Line2D([0,1],[1,0], transform=fig.transFigure, figure=fig, color="g")
    >>> fig.lines.extend([line1, line2])
    >>> fig.show()
#+END_EXAMPLE

[[_images/pyplot_artist01.png]]

在Figure对象中手工绘制直线

注意为了让所创建的Line2D对象使用fig的坐标，我们将fig.TransFigure赋给Line2D对象的transform属性；为了让Line2D对象知道它是在fig对象中，我们还设置其figure属性为fig；最后还需要将创建的两个Line2D对象添加到fig.lines属性中去。

Figure对象有如下属性包含其它的Artist对象：

-  axes : Axes对象列表
-  patch : 作为背景的Rectangle对象
-  images : FigureImage对象列表，用来显示图片
-  legends : Legend对象列表
-  lines : Line2D对象列表
-  patches : patch对象列表
-  texts : Text对象列表，用来显示文字

**** Axes容器[[#axes][¶]]

Axes容器是整个matplotlib库的核心，它包含了组成图表的众多Artist对象，并且有许多方法函数帮助我们创建、修改这些对象。和Figure一样，它有一个patch属性作为背景，当它是笛卡尔坐标时，patch属性是一个Rectangle对象，而当它是极坐标时，patch属性则是Circle对象。例如下面的语句设置Axes对象的背景颜色为绿色：

#+BEGIN_EXAMPLE
    >>> fig = plt.figure()
    >>> ax = fig.add_subplot(111)
    >>> ax.patch.set_facecolor("green")
#+END_EXAMPLE

当你调用Axes的绘图方法（例如plot），它将创建一组Line2D对象，并将所有的关键字参数传递给这些Line2D对象，并将它们添加进Axes.lines属性中，最后返回所创建的Line2D对象列表：

#+BEGIN_EXAMPLE
    >>> x, y = np.random.rand(2, 100)
    >>> line, = ax.plot(x, y, "-", color="blue", linewidth=2)
    >>> line
    <matplotlib.lines.Line2D object at 0x03007030>
    >>> ax.lines
    [<matplotlib.lines.Line2D object at 0x03007030>]
#+END_EXAMPLE

注意plot返回的是一个Line2D对象的列表，因为我们可以传递多组X,Y轴的数据，一次绘制多条曲线。

与plot方法类似，绘制直方图的方法bar和绘制柱状统计图的方法hist将创建一个Patch对象的列表，每个元素实际上都是Patch的子类Rectangle，并且将所创建的Patch对象都添加进Axes.patches属性中：

#+BEGIN_EXAMPLE
    >>> ax = fig.add_subplot(111)
    >>> n, bins, rects = ax.hist(np.random.randn(1000), 50, facecolor="blue")
    >>> rects
    <a list of 50 Patch objects>
    >>> rects[0]
    <matplotlib.patches.Rectangle object at 0x05BC2350>
    >>> ax.patches[0]
    <matplotlib.patches.Rectangle object at 0x05BC2350>
#+END_EXAMPLE

一般我们不会直接对Axes.lines或者Axes.patches属性进行操作，而是调用add_line或者add_patch等方法，这些方法帮助我们完成许多属性设置工作：

#+BEGIN_QUOTE
  #+BEGIN_EXAMPLE
      >>> fig = plt.figure()
      >>> ax = fig.add_subplot(111)
      >>> rect = matplotlib.patches.Rectangle((1,1), width=5, height=12)
      >>> print rect.get_axes() # rect的axes属性为空
      None
      >>> rect.get_transform() # rect的transform属性为缺省值
      BboxTransformTo(Bbox(array([[  1.,   1.],
             [  6.,  13.]])))
      >>> ax.add_patch(rect) # 将rect添加进ax
      <matplotlib.patches.Rectangle object at 0x05C34E50>
      >>> rect.get_axes() # 于是rect的axes属性就是ax
      <matplotlib.axes.AxesSubplot object at 0x05C09CB0>
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> # rect的transform属性和ax的transData相同
      >>> rect.get_transform()
      ... # 太长，省略
      >>> ax.transData
      ... # 太长，省略
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> ax.get_xlim() # ax的X轴范围为0到1，无法显示完整的rect
      (0.0, 1.0)
      >>> ax.dataLim._get_bounds() # 数据的范围和rect的大小一致
      (1.0, 1.0, 5.0, 12.0)
      >>> ax.autoscale_view() # 自动调整坐标轴范围
      >>> ax.get_xlim() # 于是X轴可以完整显示rect
      (1.0, 6.0)
      >>> plt.show()
  #+END_EXAMPLE
#+END_QUOTE

通过上面的例子我们可以看出，add_patch方法帮助我们设置了rect的axes和transform属性。

下面详细列出Axes包含各种Artist对象的属性：

-  artists : Artist对象列表
-  patch : 作为Axes背景的Patch对象，可以是Rectangle或者Circle
-  collections : Collection对象列表
-  images : AxesImage对象列表
-  legends : Legend对象列表
-  lines : Line2D对象列表
-  patches : Patch对象列表
-  texts : Text对象列表
-  xaxis : XAxis对象
-  yaxis : YAxis对象

下面列出Axes的创建Artist对象的方法：

| Axes的方法     | annotate   | bars        | errorbar            | fill      | hist        | imshow      | legend    | plot     | scatter             | text    |
| 所创建的对象   | Annotate   | Rectangle   | Line2D, Rectangle   | Polygon   | Rectangle   | AxesImage   | Legend    | Line2D   | PolygonCollection   | Text    |
| 添加进的列表   | texts      | patches     | lines,patches       | patches   | patches     | images      | legends   | lines    | Collections         | texts   |

下面以绘制散列图(scatter)为例，验证一下：

#+BEGIN_EXAMPLE
    >>> fig = plt.figure()
    >>> ax = fig.add_subplot(111)
    >>> t = ax.scatter(np.random.rand(20), np.random.rand(20))
    >>> t # 返回值为CircleCollection对象
    <matplotlib.collections.CircleCollection object at 0x06004230>
    >>> ax.collections # 返回的对象已经添加进了collections列表中
    [<matplotlib.collections.CircleCollection object at 0x06004230>]
    >>> fig.show()
    >>> t.get_sizes() # 获得Collection的点数
    20
#+END_EXAMPLE

[[_images/pyplot_artist02.png]]

用scatter函数绘制散列图

**** Axis容器[[#axis][¶]]

Axis容器包括坐标轴上的刻度线、刻度文本、坐标网格以及坐标轴标题等内容。刻度包括主刻度和副刻度，分别通过Axis.get_major_ticks和Axis.get_minor_ticks方法获得。每个刻度线都是一个XTick或者YTick对象，它包括实际的刻度线和刻度文本。为了方便访问刻度线和文本，Axis对象提供了get_ticklabels和get_ticklines方法分别直接获得刻度线和刻度文本：

#+BEGIN_QUOTE
  #+BEGIN_EXAMPLE
      >>> pl.plot([1,2,3],[4,5,6])
      [<matplotlib.lines.Line2D object at 0x0AD3B670>]
      >>> pl.show()
      >>> axis = pl.gca().xaxis
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> axis.get_ticklocs() # 获得刻度的位置列表
      array([ 1. ,  1.5,  2. ,  2.5,  3. ])
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> axis.get_ticklabels() # 获得刻度标签列表
      <a list of 5 Text major ticklabel objects>
      >>> [x.get_text() for x in axis.get_ticklabels()] # 获得刻度的文本字符串
      [u'1.0', u'1.5', u'2.0', u'2.5', u'3.0']
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> axis.get_ticklines() # 获得主刻度线列表，图的上下刻度线共10条
      <a list of 10 Line2D ticklines objects>
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> axis.get_ticklines(minor=True) # 获得副刻度线列表
      <a list of 0 Line2D ticklines objects>
  #+END_EXAMPLE
#+END_QUOTE

获得刻度线或者刻度标签之后，可以设置其各种属性，下面设置刻度线为绿色粗线，文本为红色并且旋转45度：

#+BEGIN_QUOTE
  #+BEGIN_EXAMPLE
      >>> for label in axis.get_ticklabels():
      ...     label.set_color("red")
      ...     label.set_rotation(45)
      ...     label.set_fontsize(16)
      ...
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> for line in axis.get_ticklines():
      ...     line.set_color("green")
      ...     line.set_markersize(25)
      ...     line.set_markeredgewidth(3)
  #+END_EXAMPLE
#+END_QUOTE

最终的结果图如下：

[[_images/pyplot_axis01.png]]

手工配置X轴的刻度线和刻度文本的样式

上面的例子中，获得的副刻度线列表为空，这是因为用于计算副刻度的对象缺省为NullLocator，它不产生任何刻度线；而计算主刻度的对象为AutoLocator，它会根据当前的缩放等配置自动计算刻度的位置：

#+BEGIN_EXAMPLE
    >>> axis.get_minor_locator() # 计算副刻度的对象
    <matplotlib.ticker.NullLocator instance at 0x0A014300>
    >>> axis.get_major_locator() # 计算主刻度的对象
    <matplotlib.ticker.AutoLocator instance at 0x09281B20>
#+END_EXAMPLE

我们可以使用程序为Axis对象设置不同的Locator对象，用来手工设置刻度的位置；设置Formatter对象用来控制刻度文本的显示。下面的程序设置X轴的主刻度为pi/4，副刻度为pi/20，并且主刻度上的文本以pi为单位：

#+BEGIN_EXAMPLE
    # -*- coding: utf-8 -*-
    import matplotlib.pyplot as pl
    from matplotlib.ticker import MultipleLocator, FuncFormatter
    import numpy as np
    x = np.arange(0, 4*np.pi, 0.01)
    y = np.sin(x)
    pl.figure(figsize=(8,4))
    pl.plot(x, y)
    ax = pl.gca()

    def pi_formatter(x, pos):
        """
        比较罗嗦地将数值转换为以pi/4为单位的刻度文本
        """
        m = np.round(x / (np.pi/4))
        n = 4
        if m%2==0: m, n = m/2, n/2
        if m%2==0: m, n = m/2, n/2
        if m == 0:
            return "0"
        if m == 1 and n == 1:
            return "$\pi$"
        if n == 1:
            return r"$%d \pi$" % m
        if m == 1:
            return r"$\frac{\pi}{%d}$" % n
        return r"$\frac{%d \pi}{%d}$" % (m,n)

    # 设置两个坐标轴的范围
    pl.ylim(-1.5,1.5)
    pl.xlim(0, np.max(x))

    # 设置图的底边距
    pl.subplots_adjust(bottom = 0.15)

    pl.grid() #开启网格

    # 主刻度为pi/4
    ax.xaxis.set_major_locator( MultipleLocator(np.pi/4) )

    # 主刻度文本用pi_formatter函数计算
    ax.xaxis.set_major_formatter( FuncFormatter( pi_formatter ) )

    # 副刻度为pi/20
    ax.xaxis.set_minor_locator( MultipleLocator(np.pi/20) )

    # 设置刻度文本的大小
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize(16)
    pl.show()
#+END_EXAMPLE

关于刻度的定位和文本格式的东西都在matplotlib.ticker中定义，程序中使用到如下两个类：

-  *MultipleLocator* : 以指定值的整数倍为刻度放置刻度线
-  *FuncFormatter* :
   使用指定的函数计算刻度文本，他会传递给所指定的函数两个参数：刻度值和刻度序号，程序中通过比较笨的办法计算出刻度值所对应的刻度文本

此外还有很多预定义的Locator和Formatter类，详细内容请参考相应的API文档。

[[_images/pyplot_axis02.png]]

手工配置X轴的刻度线的位置和文本，并开启副刻度

** [[http://blog.fens.me/linux-mysql-install/][在Ubuntu中安装MySQL]]

[[http://blog.fens.me/series-ubuntu/][Ubuntu实用工具系列文章]]，将介绍基于Linux
ubuntu的各种工具软件的配置和使用。有些工具大家早已耳熟能详，有些工具经常用到但确依然陌生。我将记录我在使用操作系统时，安装及配置工具上面的一些方法，把使用心得记录下来也便于自己的以后查找和回忆。

*关于作者：*

-  张丹(Conan), 程序员Java,R,PHP,Javascript
-  weibo：@Conan_Z
-  blog: [[http://blog.fens.me/][http://blog.fens.me]]
-  email: bsspirit@gmail.com

*转载请注明出处：*
 [[http://blog.fens.me/linux-mysql-install/]]

[[http://blog.fens.me/wp-content/uploads/2014/03/ubuntu-mysql-install.png][[[http://blog.fens.me/wp-content/uploads/2014/03/ubuntu-mysql-install.png]]]]

*前言*

安装MySQL是个老话题，我安装MySQL服务器已不下百次了，为了博客文章结构的连贯性，还是再写一篇做为环境基础，同时也给自己一个备忘。

*目录*

1. MySQL在Windows中安装
2. MySQL在Linux Ubuntu中安装
3. 通过命令行客户端访问MySQL
4. 修改MySQL服务器的配置
5. 新建数据库并设置访问账号
6. 改变数据存储位置

*** 1. MySQL在Windows中安装

在Windows系统上安装MySQl数据库是件非常简单的事情，下载压缩包，解压即可。下载地址：[[http://dev.mysql.com/downloads/mysql/]]

-  MySQL服务器运行命令：MySQL安装目录/bin/mysqld.exe
-  MySQL客户端运行命令：MySQL安装目录/bin/mysql.exe

*** 2. MySQL在Linux Ubuntu中安装

本文使用的Linux是Ubuntu 12.04.2 LTS
64bit的系统，安装MySQL数据库软件包可以通过apt-get实现。

在Linux Ubuntu中安装MySQL数据库

#+BEGIN_EXAMPLE
    #安装MySQL服务器端
    ~ sudo apt-get install mysql-server
#+END_EXAMPLE

安装过程会弹出提示框，输入root用户的密码，我在这里设置密码为mysql。

安装完成后，MySQL服务器会自动启动，我们检查MySQL服务器程序

#+BEGIN_EXAMPLE
    # 检查MySQL服务器系统进程
    ~ ps -aux|grep mysql
    mysql     3205  2.0  0.5 549896 44092 ?        Ssl  20:10   0:00 /usr/sbin/mysqld
    conan     3360  0.0  0.0  11064   928 pts/0    S+   20:10   0:00 grep --color=auto mysql

    # 检查MySQL服务器占用端口
    ~ netstat -nlt|grep 3306
    tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN

    # 通过启动命令检查MySQL服务器状态
    ~ sudo /etc/init.d/mysql status
    Rather than invoking init scripts through /etc/init.d, use the service(8)
    utility, e.g. service mysql status

    Since the script you are attempting to invoke has been converted to an
    Upstart job, you may also use the status(8) utility, e.g. status mysql
    mysql start/running, process 3205

    # 通过系统服务命令检查MySQL服务器状态
    ~ service mysql status
    mysql start/running, process 3205
#+END_EXAMPLE

*** 3. 通过命令行客户端访问MySQL

安装MySQL服务器，会自动地一起安装MySQL命令行客户端程序。

在本机输入mysql命令就可以启动，客户端程序访问MySQL服务器。

#+BEGIN_EXAMPLE
    ~ mysql
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 42
    Server version: 5.5.35-0ubuntu0.12.04.2 (Ubuntu)

    Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    mysql>
#+END_EXAMPLE

使用户名和密码，登陆服务器

#+BEGIN_EXAMPLE
    ~ mysql -uroot -p
    Enter password:
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 37
    Server version: 5.5.35-0ubuntu0.12.04.2 (Ubuntu)

    Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    mysql>
#+END_EXAMPLE

MySQL的一些简单的命令操作。

#+BEGIN_EXAMPLE
    # 查看所有的数据库
    mysql> show databases;
    +--------------------+
    | Database           |
    +--------------------+
    | information_schema |
    | test               |
    +--------------------+
    2 rows in set (0.00 sec)

    # 切换到information_schema库
    mysql> use information_schema
    Reading table information for completion of table and column names
    You can turn off this feature to get a quicker startup with -A

    Database changed

    # 查看information_schema库中所有的表
    mysql> show tables;
    +---------------------------------------+
    | Tables_in_information_schema          |
    +---------------------------------------+
    | CHARACTER_SETS                        |
    | COLLATIONS                            |
    | COLLATION_CHARACTER_SET_APPLICABILITY |
    | COLUMNS                               |
    | COLUMN_PRIVILEGES                     |
    | ENGINES                               |
    | EVENTS                                |
    | FILES                                 |
    | GLOBAL_STATUS                         |
    | GLOBAL_VARIABLES                      |
    | KEY_COLUMN_USAGE                      |
    | PARAMETERS                            |
    | PARTITIONS                            |
    | PLUGINS                               |
    | PROCESSLIST                           |
    | PROFILING                             |
    | REFERENTIAL_CONSTRAINTS               |
    | ROUTINES                              |
    | SCHEMATA                              |
    | SCHEMA_PRIVILEGES                     |
    | SESSION_STATUS                        |
    | SESSION_VARIABLES                     |
    | STATISTICS                            |
    | TABLES                                |
    | TABLESPACES                           |
    | TABLE_CONSTRAINTS                     |
    | TABLE_PRIVILEGES                      |
    | TRIGGERS                              |
    | USER_PRIVILEGES                       |
    | VIEWS                                 |
    | INNODB_BUFFER_PAGE                    |
    | INNODB_TRX                            |
    | INNODB_BUFFER_POOL_STATS              |
    | INNODB_LOCK_WAITS                     |
    | INNODB_CMPMEM                         |
    | INNODB_CMP                            |
    | INNODB_LOCKS                          |
    | INNODB_CMPMEM_RESET                   |
    | INNODB_CMP_RESET                      |
    | INNODB_BUFFER_PAGE_LRU                |
    +---------------------------------------+
    40 rows in set (0.01 sec)

    # 查看数据库的字符集编码
    mysql> show variables like '%char%';
    +--------------------------+----------------------------+
    | Variable_name            | Value                      |
    +--------------------------+----------------------------+
    | character_set_client     | utf8                       |
    | character_set_connection | utf8                       |
    | character_set_database   | utf8                       |
    | character_set_filesystem | binary                     |
    | character_set_results    | utf8                       |
    | character_set_server     | latin1                     |
    | character_set_system     | utf8                       |
    | character_sets_dir       | /usr/share/mysql/charsets/ |
    +--------------------------+----------------------------+
    8 rows in set (0.00 sec)
#+END_EXAMPLE

*** 4. 修改MySQL服务器的配置

接下来，我需要做一些配置，让MySQL符合基本的开发要求。

*4.1 将字符编码设置为UTF-8*

默认情况下，MySQL的字符集是latin1，因此在存储中文的时候，会出现乱码的情况，所以我们需要把字符集统一改成UTF-8。

用vi打开MySQL服务器的配置文件my.cnf

#+BEGIN_EXAMPLE
    ~ sudo vi /etc/mysql/my.cnf

    #在[client]标签下，增加客户端的字符编码
    [client]
    default-character-set=utf8

    #在[mysqld]标签下，增加服务器端的字符编码
    [mysqld]
    character-set-server=utf8
    collation-server=utf8_general_ci
#+END_EXAMPLE

*4.2 让MySQL服务器被远程访问*

默认情况下，MySQL服务器不允许远程访问，只允许本机访问，所以我们需要设置打开远程访问的功能。

用vi打开MySQL服务器的配置文件my.cnf

#+BEGIN_EXAMPLE
    ~ sudo vi /etc/mysql/my.cnf

    #注释bind-address
    #bind-address            = 127.0.0.1
#+END_EXAMPLE

修改后，重启MySQL服务器。

#+BEGIN_EXAMPLE
    ~ sudo /etc/init.d/mysql restart
    Rather than invoking init scripts through /etc/init.d, use the service(8)
    utility, e.g. service mysql restart

    Since the script you are attempting to invoke has been converted to an
    Upstart job, you may also use the stop(8) and then start(8) utilities,
    e.g. stop mysql ; start mysql. The restart(8) utility is also available.
    mysql start/running, process 3577
#+END_EXAMPLE

重新登陆服务器

#+BEGIN_EXAMPLE
    ~ mysql -uroot -p
    Enter password:
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 37
    Server version: 5.5.35-0ubuntu0.12.04.2 (Ubuntu)

    Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    # 再次查看字符串编码
    mysql> show variables like '%char%';
    +--------------------------+----------------------------+
    | Variable_name            | Value                      |
    +--------------------------+----------------------------+
    | character_set_client     | utf8                       |
    | character_set_connection | utf8                       |
    | character_set_database   | utf8                       |
    | character_set_filesystem | binary                     |
    | character_set_results    | utf8                       |
    | character_set_server     | utf8                       |
    | character_set_system     | utf8                       |
    | character_sets_dir       | /usr/share/mysql/charsets/ |
    +--------------------------+----------------------------+
    8 rows in set (0.00 sec)
#+END_EXAMPLE

我们检查MySQL的网络监听端口

#+BEGIN_EXAMPLE
    # 检查MySQL服务器占用端口
    ~ netstat -nlt|grep 3306
      tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN
#+END_EXAMPLE

我们看到从之间的网络监听从 127.0.0.1:3306 变成 0
0.0.0.0:3306，表示MySQL已经允许远程登陆访问。通过root账号远程访问，是非常不安全的操作，因此我们下一步，将新建一个数据库，再新建一个用户进行远程访问。

*** 5. 新建数据库并设置访问账号

通过root账号登陆MySQl服务器

#+BEGIN_EXAMPLE
    ~ mysql -uroot -p
    Enter password:
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 39
    Server version: 5.5.35-0ubuntu0.12.04.2 (Ubuntu)

    Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    # 新建数据库abc
    mysql> CREATE DATABASE abc;

    # 使用数据库abc
    mysql> use abc;
    Database changed

    # 在数据库abc中，新建一张表a1
    mysql> create table a1(id int primary key,name varchar(32) not null);
    Query OK, 0 rows affected (0.05 sec)

    # 新建book用户，密码为book，允许book可以远程访问abc数据库，授权book对abc进行所有数据库
    mysql> GRANT ALL ON abc.* to book@'%' IDENTIFIED BY 'book';
    Query OK, 0 rows affected (0.00 sec)

    #允许book可以本地访问abc数据库，授权book对abc进行所有数据库
    mysql> GRANT ALL ON abc.* to book@localhost IDENTIFIED BY 'book';
    Query OK, 0 rows affected (0.00 sec)
#+END_EXAMPLE

我们在本地使用book用户登陆

#+BEGIN_EXAMPLE
    # 使用book用户登陆
    ~ mysql -ubook -p
    Enter password:
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 40
    Server version: 5.5.35-0ubuntu0.12.04.2 (Ubuntu)

    Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    #进行abc数据库
    mysql> use abc;
    Reading table information for completion of table and column names
    You can turn off this feature to get a quicker startup with -A

    Database changed

    #查看abc数据库的表
    mysql> show tables;
    +---------------+
    | Tables_in_abc |
    +---------------+
    | a1            |
    +---------------+
    1 row in set (0.00 sec)
#+END_EXAMPLE

我们在远程的另一台Linux使用book用户登陆

#+BEGIN_EXAMPLE
    ~ mysql -ubook -p -h 192.168.1.199
    Enter password:
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 41
    Server version: 5.5.35-0ubuntu0.12.04.2 (Ubuntu)

    Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    mysql> use abc
    Reading table information for completion of table and column names
    You can turn off this feature to get a quicker startup with -A

    Database changed
    mysql> show tables;
    +---------------+
    | Tables_in_abc |
    +---------------+
    | a1            |
    +---------------+
    1 row in set (0.00 sec)
#+END_EXAMPLE

*** 5. 改变数据存储位置

有时候我们可能还需要改变MySQL数据存储的位置，一种方法是直接修改配置文件
/etc/mysql/my.cnf，找到datadir属性修改目录。

#+BEGIN_EXAMPLE
    ~ vi /etc/mysql/my.cnf

    [mysqld]
    datadir         = /var/lib/mysql
#+END_EXAMPLE

如果通过这种方法修改，那么其他的调用存储路径的地方，我们也都需要进行修改，比如
用到了/usr/bin/mysql_install_db
命令，文件中ldata的属性也需要修改，关于mysql_install_db
命令的使用可以参考文章，[[http://blog.fens.me/mysql-ibdata1/][[MySQL优化]为MySQL数据文件ibdata1瘦身]]。

还有另一种修改存储位置的方法，就是通过Linux系统的软连(ln
-s)接来做的。当我们新挂载一块硬盘，停止MySQL服务，然后把/var/lib/mysql目录移动到新的硬盘存储，在/var/lib/mysql处建立指定新位置的软连接就行了。

#+BEGIN_EXAMPLE
    # 停止MySQL服务器
    ~ /etc/init.d/mysql stop

    # 挂载硬盘
    ~ mount -t ext4 /dev/vdb1 /vdb1

    # 建立新存储目录
    ~ mkdir /vdb1/data

    # 移动MySQL数据目录到新目录
    ~ mv /var/lib/mysql /vdb1/data/

    # 软连接
    ~ ln -s /vdb1/data/mysql /var/lib/mysql
#+END_EXAMPLE

修改apparmor的别名定义文件

#+BEGIN_EXAMPLE
    ~ vi /etc/apparmor.d/tunables/alias

    alias /var/lib/mysql/ -> /vdb1/data/mysql/,
#+END_EXAMPLE

注：如果没有修改apparmor的配置，MySQL会启动不了，并一直提示是权限的问题。

#+BEGIN_EXAMPLE
    # 重启apparmor服务
    ~ /etc/init.d/apparmor restart

    # 重启MySQL服务器
    ~ /etc/init.d/mysql start
#+END_EXAMPLE

这样就完成了，MySQL数据存储位置修改。

通过上面的操作，我们就把MySQL数据库服务器，在Linux
Ubuntu中的系统安装完成。

** Python 续行

变量的赋值是一条被分成了多行的命令, 用反斜线 (“\”) 作为续行符。 注意：
当一条命令用续行符 (“\”) 分割成多行时, 后续的行可以以任何方式缩近, 此时 Python 通常的严格的缩近规则无需遵守。
如果您的 Python IDE 自由对后续行进行了缩近, 您应该把它当成是缺省处理, 除非您有特别的原因不这么做。 严格地讲, 在小括号, 方括号或大括号中的表达式 (如 定义一个 dictionary) 可以用或者不用续行符 (“\”) 分割成多行。 甚至在不是必需的时候, 我也喜欢使用续行符, 因为我认为这样会让代码读起来更容易, 但那只是风格的问题。
Python

** [[http://blog.csdn.net/zcczcw/article/details/7362473][float浮点数的二进制存储方式及转换]]

int和float都是4字节32位表示形式。为什么float的范围大于int？

float精度为6～7位。1.66*10\^10的数字结果并不是166 0000 0000
指数越大，误差越大。

这些问题，都是浮点数的存储方式造成的。



    float和double在存储方式上都是遵从IEEE的规范的，float遵从的是IEEE
R32.24 ,而double 遵从的是R64.53。

  无论是单精度还是双精度在存储中都分为三个部分：

1. 符号位(Sign) : 0代表正，1代表为负
2. 指数位（Exponent）:用于存储科学计数法中的指数数据，并且采用移位存储
3. 尾数部分（Mantissa）：尾数部分

其中float的存储方式如下图所示：

[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image001%5B3%5D_2.gif]]

而双精度的存储方式为:

[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image001%5B6%5D_2.gif]]

   *将一个float型转化为内存存储格式的步骤为：*

 （1）先将这个实数的绝对值化为二进制格式。

（2）将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边。
   （3）从小数点右边第一位开始数出二十三位数字放入第22到第0位。
   （4）如果实数是正的，则在第31位放入“0”，否则放入“1”。
   （5）如果n
是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。

（6）如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。如果n是右移得到的或n=0，则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到第23位。




R32.24和R64.53的存储方式都是用科学计数法来存储数据的，比如8.25用十进制的科学计数法表示就为:8.25*[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image0021.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image0021_thumb.gif]]]],而120.5可以表示为:1.205*[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image0022.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image0022_thumb.gif]]]],计算机根本不认识十进制的数据，他只认识0，1，所以在计算机存储中，首先要将上面的数更改为二进制的科学计数法表示，8.25用二进制表示可表示为1000.01,120.5用二进制表示为：1110110.1用二进制的科学计数法表示1000.01可以表示为1.0001*[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B2%5D_1.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B2%5D_thumb_1.gif]]]],1110110.1可以表示为1.1101101*[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B3%5D_1.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B3%5D_thumb_1.gif]]]],任何一个数都的科学计数法表示都为1.xxx*[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B1%5D_1.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B1%5D_thumb_1.gif]]]],尾数部分就可以表示为xxxx,第一位都是1嘛，干嘛还要表示呀？可以将小数点前面的1省略，所以23bit的尾数部分，可以表示的精度却变成了24bit，道理就是在这里，那24bit能精确到小数点后几位呢，我们知道9的二进制表示为1001，所以4bit能精确十进制中的1位小数点，24bit就能使float能精确到小数点后6位，而对于指数部分，因为指数可正可负，8位的指数位能表示的指数范围就应该为:-127-128了，所以指数部分的存储采用移位存储，存储的数据为元数据+127，下面就看看8.25和120.5在内存中真正的存储方式。


首先看下8.25，用二进制的科学计数法表示为:1.0001*[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B2%5D_1.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B2%5D_thumb_1.gif]]]]

按照上面的存储方式，符号位为:0，表示为正，指数位为:3+127=130
,位数部分为,故8.25的存储方式如下图所示:

[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B5%5D.gif]]

而单精度浮点数120.5的存储方式如下图所示:

[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002_12.gif]]



     *将一个内存存储的float二进制格式转化为十进制的步骤：*

（1）将第22位到第0位的二进制数写出来，在最左边补一位“1”，得到二十四位有效数字。将小数点点在最左边那个“1”的右边。

（2）取出第29到第23位所表示的值n。当30位是“0”时将n各位求反。当30位是“1”时将n增1。

（3）将小数点左移n位（当30位是“0”时）或右移n位（当30位是“1”时），得到一个二进制表示的实数。

（4）将这个二进制实数化为十进制，并根据第31位是“0”还是“1”加上正号或负号即可。

那么如果给出内存中一段数据，并且告诉你是单精度存储的话，你如何知道该数据的十进制数值呢？其实就是对上面的反推过程，比如给出如下内存数据：0100001011101101000000000000，首先我们现将该数据分段，0
10000 0101 110 1101 0000 0000 0000 0000，在内存中的存储就为下图所示：

[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image001_1.gif]]

根据我们的计算方式，可以计算出，这样一组数据表示为:1.1101101*[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B3%5D_1.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B3%5D_thumb_1.gif]]]]=120.5

而双精度浮点数的存储和单精度的存储大同小异，不同的是指数部分和尾数部分的位数。所以这里不再详细的介绍双精度的存储方式了，只将120.5的最后存储方式图给出，大家可以仔细想想为何是这样子的

[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image001_2.gif]]

下面我就这个基础知识点来解决一个我们的一个疑惑，请看下面一段程序，注意观察输出结果

  float f = 2.2f;
   double d = (double)f;
   Console.WriteLine(d.ToString("0.0000000000000"));
   f = 2.25f;
   d = (double)f;
   Console.WriteLine(d.ToString("0.0000000000000"));

可能输出的结果让大家疑惑不解，单精度的2.2转换为双精度后，精确到小数点后13位后变为了2.2000000476837，而单精度的2.25转换为双精度后，变为了2.2500000000000，为何2.2在转换后的数值更改了而2.25却没有更改呢？很奇怪吧？其实通过上面关于两种存储结果的介绍，我们已经大概能找到答案。首先我们看看2.25的单精度存储方式，很简单
0 1000 0001 001 0000 0000 0000 0000 0000,而2.25的双精度表示为:0 100 0000
0001 0010 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
0000,这样2.25在进行强制转换的时候，数值是不会变的，而我们再看看2.2呢，2.2用科学计数法表示应该为：将十进制的小数转换为二进制的小数的方法为将小数*2，取整数部分，所以0.282=0.4，所以二进制小数第一位为0.4的整数部分0，0.4×2=0.8，第二位为0,0.8*2=1.6,第三位为1，0.6×2
=
1.2，第四位为1，0.2*2=0.4，第五位为0，这样永远也不可能乘到=1.0，得到的二进制是一个无限循环的排列
00110011001100110011...
,对于单精度数据来说，尾数只能表示24bit的精度，所以2.2的float存储为:

[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image001_7.gif]]

但是这样存储方式，换算成十进制的值，却不会是2.2的，应为十进制在转换为二进制的时候可能会不准确，如2.2，而double类型的数据也存在同样的问题，所以在浮点数表示中会产生些许的误差，在单精度转换为双精度的时候，也会存在误差的问题，对于能够用二进制表示的十进制数据，如2.25，这个误差就会不存在，所以会出现上面比较奇怪的输出结果。



附注：

*小数的二进制表示问题*

 首先我们要搞清楚下面两个问题：

  (1)  十进制整数如何转化为二进制数

  算法很简单。举个例子，11表示成二进制数：

  11/2=5   余  1

  5/2=2  余  1

  2/2=1  余  0

  1/2=0  余  1

  0结束  11二进制表示为(从下往上):1011


这里提一点：只要遇到除以后的结果为0了就结束了，大家想一想，所有的整数除以2是不是一定能够最终得到0。换句话说，所有的整数转变为二进制数的算法会不会无限循环下去呢？绝对不会，*整数永远可以用二进制精确表示 *，但小数就不一定了。

  (2) 十进制小数如何转化为二进制数

  算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数

  0.9*2=1.8  取整数部分  1

  0.8(1.8的小数部分)*2=1.6  取整数部分  1

  0.6*2=1.2  取整数部分  1

  0.2*2=0.4  取整数部分  0

  0.4*2=0.8  取整数部分  0

  0.8*2=1.6   取整数部分  1

  0.6*2=1.2  取整数部分  0

  .........  0.9二进制表示为(从上往下):
1100100100100......


注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，*小数的二进制表示有时是不可能精确的 *。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了"减不尽"的精度丢失问题。

** [[http://www.21ic.com/app/control/201304/178371.htm][]]

** [[http://eschulte.github.io/emacs-web-server/tutorials/][emacs-web-server]]

The following tutorials walk through common usage scenarios including
installing the Emacs web-server and running it behind a proxy. Install
the Emacs web-server and run (info "web-server") to browse the full
manual within Emacs, or view the HTML version at emacs-web-server.



*** 1 Installation and running a server

Most easily installable through the GNU ELPA, run
=M-x package-list-packages= select =web-server= and install.
Alternately, install from the git repository at
[[https://github.com/eschulte/emacs-web-server]] and update your the
load.

1. Ensure that you have Emacs version 24 or greater installed.

   #+BEGIN_EXAMPLE
       emacs --version
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
       GNU Emacs 24.3.1
       Copyright (C) 2013 Free Software Foundation, Inc.
       GNU Emacs comes with ABSOLUTELY NO WARRANTY.
       You may redistribute copies of Emacs
       under the terms of the GNU General Public License.
       For more information about these matters, see the file named COPYING.
   #+END_EXAMPLE

2. Download and unpack the zip archive of the Emacs web-server code from
   [[https://github.com/eschulte/emacs-web-server/archive/master.zip][emacs-web-server-master.zip]]
   or clone the source code repository with
   [[http://git-scm.com/][git]].

   #+BEGIN_EXAMPLE
       git clone https://github.com/eschulte/emacs-web-server.git
   #+END_EXAMPLE

3. Move into the root of the =emacs-web-server/= directory and
   optionally run =make= to compile the web-server code, and run
   =make    check= to test your web-server install.

   #+BEGIN_EXAMPLE
       make
       make check
   #+END_EXAMPLE

4. From the root of the =emacs-web-server/= directory, start an instance
   of Emacs with web-server loaded.

   #+BEGIN_EXAMPLE
       emacs -Q -L . -l web-server
   #+END_EXAMPLE

   Alternately, from an already running Emacs instance, add this
   directory to the load path and load the web server with the
   following.

   #+BEGIN_EXAMPLE
       (add-to-list 'load-path "path/to/emacs-web-server")
       (require 'web-server)
   #+END_EXAMPLE

5. Evaluate the following code in =*scratch*= buffer of this Emacs
   instance.

   #+BEGIN_EXAMPLE
       (ws-start
        (lambda (request)
          (with-slots (process headers) request
            (ws-response-header process 200 '("Content-type" . "text/plain"))
            (process-send-string process "hello world")))
        9000)
   #+END_EXAMPLE

6. Browse to [[http://localhost:9000/]] to see that the web-server is
   running.
7. Read the web-server
   [[http://eschulte.github.io/emacs-web-server/index.html#Top][manual]]
   and work through other
   [[http://eschulte.github.io/emacs-web-server/Usage-Examples.html#Usage-Examples][Usage
   Examples]].

*** 2 Running behind a proxy

Public-facing instance of the Emacs web-server should be run behind a
more established web server such as [[http://httpd.apache.org/][Apache]]
or [[http://wiki.nginx.org/][Nginx]] to provide additional robustness
and security.

The following example Apache configuration may be used to have a public
facing Apache server listening on port 80 proxy requests to a local
web-server instance running on port 8888 of the same machine.

#+BEGIN_EXAMPLE
    <VirtualHost *:80>
      ServerName  yourserver.com

      ProxyPass / http://localhost:8888/
    </VirtualHost>
#+END_EXAMPLE

A similar Nginx configuration is available at
[[http://wiki.nginx.org/LoadBalanceExample]].

*** 3 Running behind an https proxy

The following example configurations will cause Apache or Nginx to act
as an HTTPS proxy for an instance of the Emacs web server running on the
same machine. With this setup Apache speaks HTTPS to the outside world,
and communicates with the Emacs web server using HTTP. This allows use
of HTTPS even though the Emacs web server does not implement HTTPS
itself. This setup is recommended for any setup, but should be
considered *required* for sites using BASIC HTTP Authentication.

**** 3.1 Apache

This requires that Apache has =mod_proxy= and =mod_ssl= enabled, and
that the certificate and key files required for SSL are present. This
these requirements satisfied, and assuming the Emacs web server is
listening on port 8888 and is running on the same machine as the Apache
web server an Apache virtual host configuration such as the following.

#+BEGIN_EXAMPLE
    <VirtualHost *:443>
        ProxyPreserveHost On
        ServerName yourserver.com

        SSLEngine On
        SSLCertificateFile /etc/ssl/certs/ssl-cert-snakeoil.pem
        SSLCertificateKeyFile /etc/ssl/private/ssl-cert-snakeoil.key

        ProxyPass / http://localhost:8888/
        ProxyPassReverse / http://localhost:8888/
    </VirtualHost>
#+END_EXAMPLE

**** 3.2 Nginx

See the following for instructions configuring Nginx as an HTTPS proxy.

-  [[http://wiki.nginx.org/SSL-Offloader#sslproxy.conf]]
-  [[http://www.cyberciti.biz/faq/howto-linux-unix-setup-nginx-ssl-proxy/]]

** [[http://coolshell.cn/articles/4119.html][如何学好C++语言]]


昨天写了一篇[[http://coolshell.cn/articles/4102.html][如何学好C语言]]，就有人回复问我如何学好C++，所以，我把我个人的一些学习经验写在这里，希望对大家有用。首先，因为[[http://coolshell.cn/articles/4102.html][如何学好C语言]]中谈到了算法和系统，所以这里就只谈C++语言。

-  *C++是最难的语言*。这个世界上最难的编程语言可能非C++莫属了。你千万不要以为[[http://coolshell.cn/articles/2250.html][几天就可以学好C++]]，C++的学习曲线是相当BT的，你可以看看[[http://coolshell.cn/articles/2287.html][这篇文章]]。C++是一门很自由的语言，自由到了有点[[http://coolshell.cn/articles/1724.html][BT和恐怖的地步]]。我甚至认为C++并不是一门成熟的编程语言，因为太容易犯错了。所以，*你一定要在一开始就要有很小心谨慎的态度，并把C++当成一种难以训服的猛兽来看待*。

-  *多问“为什么要这样”的问题*。学习C++一定要多问几个“为什么是这样”，“凭什么要这样”的问题。比如：很多人知道C++有拷贝构造函数和初始化列表，但你真的知道为什么要有拷贝构造函数？为什么要有初始化列表吗？为什么要有template，为什么要有RTTI，为什么不是别的呢？难道就是为了让一门语言变得Cool一些吗？完全不是这样的，C++中的任何一个feature都有些实实在在的原因，*你一定要去了解为什么要把C++设计成这样的原因，你才能学好C++*。有空看看《[[http://product.china-pub.com/5217][C++演化和设计]]》一书。

-  *看书，大量的C++书*。你可以按如下先后顺序阅读（下面这些书，我花了大约4-5年的时间，今天我还在随时温习）

   -  《[[http://product.china-pub.com/28767][C++
      Primer]]》，这本初级读本可能让会你啃得很痛苦，所有的语言的特性和为什么都在里面了，好好读读。当然由C++之父写的《[[http://product.china-pub.com/196448][C++程序设计语言]]》也不错。两本看一本就好了（我看的是前者）。
   -  了解C++的语法仅仅是万里长征的第一步，你还需要看看《[[http://product.china-pub.com/197414][Effective
      C++]]》和《[[http://product.china-pub.com/197665][More Effective
      C++]]》这两本书并不厚，但我从02年就一直看到现在，每次读我都有新的体会，这两本书太经典了。如果你对C语言不熟，这两本书会让你回去补C语言的课。
   -  [[http://product.china-pub.com/4801][Think in
      C++]]同样是另一本经典之极的书，学c++必读，但是中文版的翻译的很不好，所以还是去读英文版的吧。
   -  《[[http://product.china-pub.com/38130&ref=browse][C++沉思录]]》同样非常值得一读，这里教的不是编程，而是思考的方法，这是相当珍贵的。
   -  《[[http://product.china-pub.com/33333][Exceptional
      C++]]》和《[[http://product.china-pub.com/197666][More Exceptional
      C++]]》让你看看各种问题的解决方法和一些常见的经典错误。
   -  《[[http://product.china-pub.com/16697][Advanced
      C++]]》和《[[http://product.china-pub.com/9700][Modern
      C++]]》可以让你知道C++各种神奇的用法。
   -  《[[http://product.china-pub.com/9864][泛型编程与STL]]》是把C++实践到了极致的东西。很强大。STL------神一样的模板库（容器，算法和函数对象），不得不服。
   -  《[[http://www.china-pub.com/3290&ref=browse][深入探索C++对象模型]]》让你了解编译器下的C++是什么样的，让你了解C++的性能并不差。这个对于C++的程序员太关键了。我以前写过的《[[http://coolshell.cn/articles/12165.html][C++虚函数表解析]]》还有《[[http://coolshell.cn/articles/12176.html][C++对象内存布局]]》属于这个范畴。

-  *和Java语言做对比*。我个人以为Java对C++这个并不成熟的语言做了很多调整，规范和限制。所以，对比一下Java和C++，想一想，为什么一些东西在C++中可以做，但在Java中却不行。比如：Java的异常是必需要catch的，不然就会编译不通过。为什么Java不提供操作符重载？为什么Java会引入接口来做多重继承？为什么Java没有像C++那样的I/O字符流？为什么Java不支持指针？为什么Java可以做到垃圾回收？等等。*Java体现着很多面向对象设计的东西，学习Java有助于你学会怎么更好地使用C++来编程*。

-  *面向对象设计*
   。虽然[[http://coolshell.cn/articles/3036.html][面向对象可能是个骗局]]。但是我觉得面向对象设计中的一些实践非常的不错，比如，单一原则，依赖倒置原则，等等，都非常地经典。《[[http://product.china-pub.com/25961][设计模式]]》必需一读，《[[http://product.china-pub.com/47106][面向对象的分析和设计]]》可以一读。*但不可以设计模式为中心来编程，而应该是用设计模式来解藕*。

-  *类库学习*。看看MFC是怎么封装Windows
   API的，看看ACE是怎么面向对象的，看看boost是怎么玩面向对象的，看看CPPUnit又是怎么设计的。当然，[[http://coolshell.cn/articles/3320.html][Java的JDK中有太多的设计模式]]，可以参考。

希望没有吓到大家，并欢迎大家补充。

/*---------------更新 2011/03/30 19:20------------*/

更新几个观点：

-  1）我不擅长写书评，所以推荐的这些书可能会让你有点看点没有感觉，你可以上豆瓣或是China-pub上看看书评。
-  2）C++有很多奇淫技巧，有的很BT，包括虚函数表，也许会有人觉得有点没意思，但我觉得很有意思，一方面可以了解一门语言的实现细节，另一方面可以开阔思路。我从学习这些知识中受益很多。
-  3）上述是我的个人的学习历程，我觉得对我很有效，所以是经验之谈。
-  4）这类的文章在网上有很多很多，我不是第一个写这样的文章，我也不是写得最好的，我并不希望用长篇大论来谈论什么。只是想给大家了解一下大概的学习样子。毕竟，C++博大精深，任何一篇文章都无法说好。不如就简单一些。

** [[http://coolshell.cn/articles/2287.html][C++ 程序员自信心曲线图]]


学习C++很长时间了，也看过很多程序员学习C++的历程。总体来说，C++是一个“双刃剑”式的语言，只有那些熟悉他的人才能把C++这门语言用好。Linus曾说过：“*C++是一门很[[http://coolshell.cn/articles/1724.html][恐怖的语言]]，而比它更恐怖的是很多不合格的程序员在使用着它*”。是的，C++并不是一门速成的语言，其是一门需要长时间磨练和学习的语言，那些说自己熟悉C++语言的程序只能算是轻浮的。详见[[http://coolshell.cn/articles/2250.html][“21天教你学会C++
”]]。

下面是一个C++程序员在学习过程序中的一个自信心曲线图：

[[http://coolshell.cn//wp-content/uploads/2010/03/c++.png][[[http://coolshell.cn//wp-content/uploads/2010/03/c++.png]]]]

程序员在一开始学习C++的时候，用C++的语法写C觉得很牛，也会觉得自己很快掌握了C++语言，对一切都充满了信心。他们告诉你他们懂C++，其它他们错误，但我们不能说他们在撒谎，因为人总是不知道自己不知道什么。此后，当他们在C++的学习历程中，发现了很多很多稀奇古怪的东西，还有很多相当底层和复杂的东西，他们的将会变得很受挫，很沮丧，还始变得怀疑起，自信心开始下降，甚至有时候他们靠人品来编程。只到有一天，开始开窃，觉得C++的世界不能乱来，需要一定的规则，一定的方法，于是通过大量的错误不停地总结和反省，最终自信心又会被建立起来，[[http://coolshell.cn/articles/2250.html][经历多年的历练后]]，才能恢复自信。

对于大多数的自称自己熟悉C++的程序员来说，基本上来说他们都是用C++的语法来写C。

** [[http://coolshell.cn/articles/10688.html][编程能力与编程年龄]]

程序员这个职业究竟可以干多少年，在中国这片神奇的土地上，很多人都说只能干到30岁，然后就需要转型，就像《[[http://coolshell.cn/articles/4990.html][程序员技术练级攻略]]》这篇文章很多人回复到这种玩法会玩死人的一样。我在很多面试中，问到应聘者未来的规划都能听到好些应聘都说程序员是个青春饭。因为，大多数程序员都认为，编程这个事只能干到30岁，最多35岁吧。每每我听到这样的言论，都让我感到相当的无语，大家都希望能像《[[http://coolshell.cn/articles/2250.html][21天速成C++]]》那样速成，好多时候超级有想和他们争论的冲动，但后来想想算了，因为*你无法帮助那些只想呆在井底思维封闭而且想走捷径速成的人*。

今天，我们又来谈这个老话题，因为我看到一篇论文，但是也一定会有很多人都会找出各种理由来论证这篇论文的是错的，无所谓了，我把这篇文章送给那些和我一样准备为技术和编程执着和坚持的人。

**** 论文

首先，我们先来看一篇论文《[[http://people.engr.ncsu.edu/ermurph3/papers/msr13.pdf][Is
Programming Knowledge Related to
Age?]]》（PDF链接），这篇论文是两个北卡罗莱纳州立大学计算机科学系的两个人Patrick
Morrison 和 Emerson Murphy-Hill
对StackOverflow.com上的用户做了相关的数据挖掘得出来的一些数据。（我们知道StackOverflow.com上的数据是公开的，任何人都可以用来分析和统计，所以这篇论文的真实性是有的）

数据采样和清洗条件如下：（数据全量是1694981用户，平均年龄30.3岁）

-  15-70岁之间的用户（这年龄段的用户被称做“Working
   age”），当然，有很多用户没有输入年龄，这些用户都被过滤了。
-  用户在2012年内都回答过问题。因为StackOverflow在2012年对问题和答案的质量要求得比以前高了一倍，所以更能反映程序员的真实水平。
-  Reputation声望在2-100K之间。（注：StackOverflow的用户Reputation是得到社会认可的，在面试和招聘中是硬通货币。比大学的学分更有价值）

上述的条件一共过滤出84,248名程序员，平均年龄：29.02岁，平均Reputaion在1073.9分。

***** 年龄分布图

下面我们来看一下他们的年龄分布图：我们可以看到程序员年纪的正态分布（高点在25岁左右，但是中点在29岁左右）

[[http://coolshell.cn//wp-content/uploads/2013/11/StackOverflow-Analysis-01.jpg]]

***** 能力和年龄分布图

然后，计算每个人每个月的Reputation，这样可以找到这个用户的真正的活跃时间，这样便于计算这个程序员的真实能力。（总声望
/ 活跃时间），可以得到他平均每个月得来的Reputation。

我们来看看程序员的能力和年龄段的分布图：（你可能会大吃一惊）

[[http://coolshell.cn//wp-content/uploads/2013/11/StackOverflow-Analysis-02.jpg]]

上图中我们可以看到，程序员的能力在从25岁左右开始上升，一直到50岁后才会开始下降。所以说，程序员吃的不是青春饭。只有码农，靠蛮力，用体力而不是用脑力的程序员才是吃青春饭的人。

***** 年纪大的人是否跟不上新技术

论文的作者分析了Tag，用了最近5年内比较流行的技术Tag，然后用了一套比较严谨的算法来查看那些所谓的“老程序员”是否在新技术上跟上不了，所谓跟不上，也就是这些老的程序员在回答这些新技术上并不活跃。所谓老，就是37岁以上的程序员（就是我现在的年纪）。

得到了下表：可以看到，老程序员和年轻的程序员对于一些新技术的学习来说也是差不多的，甚至有些项还超过了年轻的程序员。

[[http://coolshell.cn//wp-content/uploads/2013/11/StackOverflow-Analysis-03.jpg]]

***** 结论

论文的结论是：

*1）程序员技术能力上升是可以到50岁或60岁的。*

*2）老程序员在获取新技术上的能力并不比年轻的程序员差。*

**** 我的一些感受

最后，我说一说我的一些感受：

-  这些年来的对于外企和国内感受------ *国外牛B的IT公司的工程能力并不见得比国内的要强多少，但是国外那些NB的IT公司的架构和设计能力远远超过国内的公司，最可怕的是，那些有超强架构和设计能力的“老程序员们”还战斗在一线，这些战斗在一线的老鸟的能力绝对超过100个普能的新手。*

-  对年轻程序员的感受------国内新一代的程序员们太浮燥了。*老实说，对于大多数人来说，如果你没有编程到30岁，你还不能成为一个“合格”的程序员*。*所以，并不是编程编到30岁就玩完了，而是编程编到30岁才刚刚入门。*这些不合格的程序，整天BS这个不好，那个不好的，而且喜欢速成，好大喜功。

-  我是一个奔四的人了，编程就像登山一样，越往上爬人越少，所以，在我这个年纪还有想法，对编程还有热情的人不多了，基本上都是转Manager了。*其实，什么职位，Title都是虚的，公司没了什么都没了，只有技术才是硬通货。而且，越是这个年纪还在玩编程玩技术的人，其实其经验和能力都是比较强的，都是中坚力量，如果还有其它这个年纪和我一样的人，求交往*。


** [[http://coolshell.cn/articles/7829.html][28个Unix/Linux的命令行神器]]

下面是[[http://kkovacs.eu/][Kristóf
Kovács]]收集的28个Unix/Linux下的28个命令行下的工具（[[http://kkovacs.eu/cool-but-obscure-unix-tools][原文链接]]），有一些是大家熟悉的，有一些是非常有用的，有一些是不为人知的。这些工具都非常不错，希望每个人都知道。本篇文章还在[[http://news.ycombinator.com/item?id=2567186][Hacker
News上被讨论]]，你可以过去看看。我以作者的原文中加入了官网链接和一些说明。

**** dstat & sar

iostat, vmstat, ifstat
三合一的工具，用来查看系统性能（我在《[[http://coolshell.cn/articles/7490.html][性能调优攻略]]》中提到过那三个xxstat工具）。

官方网站：[[http://dag.wieers.com/rpm/packages/dstat/]]

你可以这样使用：

#+BEGIN_EXAMPLE
    alias dstat='dstat -cdlmnpsy'
#+END_EXAMPLE

[[http://coolshell.cn//wp-content/uploads/2012/07/dstat_screenshot.png]]

**** slurm

查看网络流量的一个工具

官方网站：/ [[https://computing.llnl.gov/linux/slurm/][Simple Linux
Utility for Resource Management]]/

[[http://coolshell.cn//wp-content/uploads/2012/07/slurm_screenshot.png]]

**** vim & emacs

真正程序员的代码编辑器。

[[http://coolshell.cn//wp-content/uploads/2012/07/vim_screenshot.png]]

**** screen, dtach, tmux, byobu

你是不是经常需要 SSH 或者 telent 远程登录到 Linux
服务器？你是不是经常为一些长时间运行的任务而头疼，比如系统备份、ftp
传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为他们执行的时间太长了。必须等待它执行完毕，在此期间可不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。

[[http://www.gnu.org/software/screen/][*Screen*]]是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。请参看IBM
DeveloperWorks的这篇文章《[[http://www.ibm.com/developerworks/cn/linux/l-cn-screen/][使用
screen 管理你的远程会话]]》

[[http://coolshell.cn//wp-content/uploads/2012/07/gnu_screen_screenshot.png]]

[[http://dtach.sourceforge.net/][*dtach*]]是用来模拟screen的detach的功能的小工具，其可以让你随意地attach到各种会话上
。下图为dtach+dvtm的样子。

[[http://coolshell.cn//wp-content/uploads/2012/07/dtach+dvtm.png]]

*[[http://tmux.sourceforge.net/][tmux]]*是一个优秀的终端复用软件，类似[[http://www.gnu.org/software/screen/][GNU
Screen]]，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机；当然其功能远不止于此。与screen相比的优点：可以横向和纵向分割窗口，且窗格可以自由移动和调整大小。可在多个缓冲区进行复制和粘贴，支持跨窗口搜索；非正常断线后不需重新detach；......
 有人说------*与tmux相比，screen简直弱爆了*。

[[http://coolshell.cn//wp-content/uploads/2012/07/tmux3.png]]

[[https://launchpad.net/byobu/][*byobu*]]是Ubuntu开发的，在Screen的基础上进行包装，使其更加易用的一个工具。最新的Byobu，已经是基于Tmux作为后端了。可通过“byobu-tmux”这个命令行前端来接受各种与tmux一模一样的参数来控制它。Byobu的细节做的非常好，效果图如下：[[http://coolshell.cn//wp-content/uploads/2012/07/byobu-tmux.jpg]]

**** multitail

MultiTail是个用来实现同时监控多个文档、类似tail命令的功能的软件。他和tail的区别就是他会在控制台中打开多个窗口，这样使同时监控多个日志文档成为可能。他还可以看log文件的统计，合并log文件，过滤log文件，分屏，......。

官网：[[http://www.vanheusden.com/multitail/]]

[[http://coolshell.cn//wp-content/uploads/2012/07/multitail_screenshot.png]]

**** tpp

终端下的PPT，要是在某某大会上用这个演示PPT，就太TMD的Geek了。

官网：[[http://www.ngolde.de/tpp.html]]

[[http://coolshell.cn//wp-content/uploads/2012/07/tpp_screenshot.png]]

**** xargs & parallel

Executes tasks from input (even multithread).

xargs
是一个比较古老的命令，有简单的并行功能，这个不说了。对于[[http://www.gnu.org/software/parallel/][GNU
parallel]] ( [[http://savannah.gnu.org/projects/parallel][online
manpage]] )来说，它不仅能够处理本机上多执行绪，还能分散至远端电脑协助处理。而使用GNU
parallel前，要先确定本机有安装GNU parallel / ssh /
rsync，远端电脑也要安装ssh。

[[http://coolshell.cn//wp-content/uploads/2012/07/xargs_screenshot.png]]

**** duplicity & rsyncrypto

[[http://duplicity.nongnu.org/][Duplicity]]是使用rsync算法加密的高效率备份软件，Duplicity支持目录加密生产和格式上传到远程或本地文件服务器。

[[http://rsyncrypto.lingnu.com/index.php/Home_Page][rsyncrypto]] 就是
rsync +
encryption。对于rsync的算法可参看酷壳的[[http://coolshell.cn/articles/7425.html][rsync核心算法]]。

Encrypting backup tools.

[[http://coolshell.cn//wp-content/uploads/2012/07/duplicity_screenshot.png]]

**** nethack & slash'em

[[http://www.nethack.org/][NetHack]]（[[http://zh.wikipedia.org/zh/NetHack][Wiki]]），20年历史的古老电脑游戏。没有声音，没有漂亮的界面，不过这个游戏真的很有意思。网上有个家伙说：*如果你一生只做一件事情，那么玩NetHack*。这句话很惹眼，但也让人觉得这个游戏很复杂不容易上手。其实，这个游戏很虽然很复杂，却容易上手。虽然玩通关很难，但上手很容易。NetHack上有许多复杂的规则，”the
DevTeam thinks of
everything”（开发团队想到了所有的事情)。各种各样的怪物，各种各样的武器....，有许多spoilers文件来说明其规则。除了每次开始随机生成的地图，每次玩游戏，你也都会碰到奇怪的事情:
因为喝了一种药水，变成了机器人;因为踢坏了商店的门被要求高价赔偿;你的狗为你偷来了商店的东西.....
这有点象人生，你不能完全了解这个世界，但你仍然可以选择自己的面对方式。

网上有许多文章所这是最好的电脑游戏或最好的电脑游戏之一。也许是因为它开放的源代码让人赞赏，古老的历史让人宽容，复杂的规则让人敬畏。虽然它不是当前流行的游戏，但它比任何一个当前流行的游戏都更有可能再经受20年的考验。

[[http://www.slashem.org][Slash'EM]] 也是一个基于NetHack的经典游戏。

[[http://coolshell.cn//wp-content/uploads/2012/07/nethack_screenshot.png]]

**** lftp

利用[[http://lftp.yar.ru/][lftp]]命令行ftp工具进行网站数据的增量备份，镜像，就像使用rsync一样。

[[http://coolshell.cn//wp-content/uploads/2012/07/lftp_screenshot.png]]

**** ack

[[http://betterthangrep.com/][ack]]是一个perl脚本，是grep的一个可选替换品。其可以对匹配字符有高亮显示。是为程序员专门设计的，默认递归搜索，省提供多种文件类型供选。

[[http://coolshell.cn//wp-content/uploads/2012/07/ack_screenshot.png]]

**** calcurse & remind + wyrd

[[http://calcurse.org/][calcurse]]是一个命令行下的日历和日程软件。[[http://www.roaringpenguin.com/products/remind][remind]]
+
[[http://pessimization.com/software/wyrd/][wyrd]]也很类似。关于日历，我不得不提一个[[http://coolshell.cn/articles/3489.html][Linux的Cycle日历]]，也是一个神器，呵呵。

[[http://coolshell.cn//wp-content/uploads/2012/07/calcurse_screenshot.png]]

**** newsbeuter & rsstail

[[http://newsbeuter.org/][newsbeuter ]]和
[[http://www.vanheusden.com/rsstail/][rsstail]]
是命令行下RSS的阅读工具。

[[http://coolshell.cn//wp-content/uploads/2012/07/newsbeuter_screenshot.png]]

**** powertop

[[http://coolshell.cn/articles/7186.html][做个环保的程序员]]，看看自己的电脑里哪些程序费电。[[https://01.org/powertop/][PowerTOP]] 是一个让
Intel 平台的笔记本电脑节省电源的 Linux 工具。此工具由 Intel
公司发布。它可以帮助用户找出那些耗电量大的程序，通过修复或者关闭那些应用程序或进程，从而为用户节省电源。

[[http://coolshell.cn//wp-content/uploads/2012/07/powertop_screenshot.png]]

**** htop & iotop

[[http://htop.sourceforge.net/][htop]] 和
[[http://guichaz.free.fr/iotop/][iotop]]  用来查看进程，内存和IO负载。

[[http://coolshell.cn//wp-content/uploads/2012/07/htop_screenshot.png]]

**** ttyrec & ipbt

[[http://0xcc.net/ttyrec/index.html.en][ttyrec]] 是一个 tty
控制台录制程序，其所录制的数据文件可以使用与之配套的 ttyplay
播放。不管是你在 tty 中的各种操作，还是在 tty
中耳熟能详的软件，都可进行录制。

[[http://www.chiark.greenend.org.uk/~sgtatham/ipbt/][ipbt]] 是一个用来回放
ttyrec 所录制的控制台输入过程的工具。

与此类似的还有[[http://shelr.tv/][Shelr]]
和 [[http://sourceforge.net/projects/termrec/][termrec ]]

[[http://coolshell.cn//wp-content/uploads/2012/07/ipbt_screenshot.png]]

**** rsync

通过SSH进行文件同步的经典工具（[[http://coolshell.cn/articles/7425.html][核心算法]]）

[[http://coolshell.cn//wp-content/uploads/2012/07/rsync_screenshot.png]]

**** mtr

[[http://www.bitwizard.nl/mtr/][MTR]] -- traceroute 2.0，其是把
traceroute 和 ping 集成在一块的一个小工具 用于诊断网络。

[[http://coolshell.cn//wp-content/uploads/2012/07/mtr_screenshot.png]]

**** socat & netpipes

[[http://www.dest-unreach.org/socat/][socat]]是一个多功能的网络工具，名字来由是”
Socket CAT”，可以看作是netcat的N倍加强版。

[[http://web.purplefrog.com/~thoth/netpipes/][netpipes]] 和socat一样，主要是用来在命令行来进行socket操作的命令，这样你就可以在Shell脚本下行进socket网络通讯了。

[[http://coolshell.cn//wp-content/uploads/2012/07/socat_screenshot.png]]

**** iftop & iptraf

[[http://www.ex-parrot.com/~pdw/iftop/][iftop]]和[[http://iptraf.seul.org/][iptraf]]可以用来查看当前网络链接的一些流量情况。

[[http://coolshell.cn//wp-content/uploads/2012/07/iftop_screenshot.png]]

[[http://coolshell.cn//wp-content/uploads/2012/07/iptraf-tcpudp.gif]]

**** siege & tsung

[[http://www.joedog.org/siege-home/][Siege]]是一个压力测试和评测工具，设计用于WEB开发这评估应用在压力下的承受能力：可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。

[[http://tsung.erlang-projects.org/][Tsung]]
是一个压力测试工具，可以测试包括HTTP, WebDAV, PostgreSQL, MySQL, LDAP,
and XMPP/Jabber等服务器。针对 HTTP 测试，Tsung 支持 HTTP 1.0/1.1
，包含一个代理模式的会话记录、支持 GET、POST 和 PUT 以及 DELETE
方法，支持 Cookie 和基本的 WWW 认证，同时还支持 SSL。

参看：[[http://coolshell.cn/articles/2589.html][十个免费的Web压力测试工具]]

[[http://coolshell.cn//wp-content/uploads/2012/07/siege_screenshot.png]]

**** ledger

[[http://ledger-cli.org/][ledger]] 一个命令行下记帐的小工具。

[[http://coolshell.cn//wp-content/uploads/2012/07/ledger_screenshot.png]]

**** taskwarrior

[[http://taskwarrior.org/projects/show/taskwarrior][TaskWarrior]] 是一个基于命令行的
TODO
列表管理工具。主要功能包括：标签、彩色表格输出、报表和图形、大量的命令、底层API、多用户文件锁等功能。

[[http://coolshell.cn//wp-content/uploads/2012/07/taskwarrior_screenshot.png]]

下图是TaskWarrior 2.0的界面：

[[http://coolshell.cn//wp-content/uploads/2012/07/TaskWarrior2.0.png]]

**** curl

[[http://curl.haxx.se/][cURL]]是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。cURL支援的通訊協定有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。

[[http://coolshell.cn//wp-content/uploads/2012/07/curl_screenshot.png]]

**** rtorrent & aria2

[[http://libtorrent.rakshasa.no/][rTorrent]]
是一个非常简洁、优秀、非常轻量的BT客户端. 它使用了 ncurses 库以 C++
编写, 因此它完全基于文本并在终端中运行. 将 rTorrent 用在安装有 GNU
Screen 和 Secure Shell 的低端系统上作为远程的 BT 客户端是非常理想的。

[[http://aria2.sourceforge.net/][aria2]] 是 Linux
下一个不错的高速下载工具。由于它具有分段下载引擎，所以支持从多个地址或者从一个地址的多个连接来下载同一个文件。这样自然就大大加快了文件的下载速度。aria2
也具有断点续传功能，这使你随时能够恢复已经中断的文件下载。除了支持一般的
http(s) 和 ftp 协议外，aria2 还支持 BitTorrent
协议。这意味着，你也可以使用 aria2 来下载 torrent 文件。

 [[http://coolshell.cn//wp-content/uploads/2012/07/rtorrent_screenshot.png]]

**** ttytter & earthquake

[[http://www.floodgap.com/software/ttytter][TTYtter]] 是一个Perl写的命令行上发Twitter的工具，可以进行所有其他平台客户端能进行的事情，当然，支持中文。脚本控、CLI控、终端控、Perl控的最愛。

[[https://github.com/jugyo/earthquake][Earthquake]]也是一个命令行上的Twitter客户端。

[[http://coolshell.cn//wp-content/uploads/2012/07/ttytter_screenshot.png]]

[[http://coolshell.cn//wp-content/uploads/2012/07/earthquake.jpg]]

**** vifm & ranger

[[http://vifm.sourceforge.net/][Vifm]] 基于ncurses的文件管理器，DOS风格，用键盘操作。

[[http://coolshell.cn//wp-content/uploads/2012/07/vifm_screenshot.png]]

[[http://savannah.nongnu.org/projects/ranger][Ranger]]用 Python
完成，默认为使用 Vim 风格的按键绑定，比如
hjkl（上下左右），dd（剪切），yy（复制）等等。功能很全，扩展/可配置性也非常不错。类似MacOS
X下Finder（文件管理器）的多列文件管理方式。支持多标签页。实时预览文本文件和目录。

[[http://coolshell.cn//wp-content/uploads/2012/07/ranger.png]]

**** cowsay & sl

[[http://www.nog.net/~tony/warez/cowsay.shtml][cowsay ]] 不说了，如下所示，哈哈哈。还有xcowsay，你可以自己搜一搜。

[[http://coolshell.cn//wp-content/uploads/2012/07/cowsay_screenshot.png]]

 sl是什么？ls？，呵呵，你会经常把ls
打成sl吗？如果是的话，这个东西可以让你娱乐一下，你会看到一辆火车呼啸而过~~，相当拉风。你可以使用sudo
apt-get install sl 安装。

[[http://coolshell.cn//wp-content/uploads/2012/07/sl.jpg]]

最后，再介绍一个命令中linuxlogo，你可以使用 sudo apt-get install
linuxlogo来安装，然后，就可以使用linuxlogo -L
 来看一下各种Linux的logo了

** [[http://coolshell.cn/articles/8619.html][你可能不知道的Shell]]

Shell也叫做命令行界面，它是*nix操作系统下用户和计算机的交互界面。Shell这个词是指操作系统中提供访问内核服务的程序。

这篇文章向大家介绍Shell一些非广为人知、但却实用有趣的知识，权当品尝shell主食后的甜点吧。

**** 科普

先科普几个你可能不知道的事实：

-  Shell几乎是和Unix操作系统一起诞生，第一个Unix Shell是肯·汤普逊（Ken
   Thompson）以Multics上的Shell为模范在1971年改写而成，并命名Thompson
   sh。即便是后来流行的bash（shell的一种变体），它的年龄实际上比当前流行的所有的Linux
   kernel都大，可谓在Linux系统上是先有Shell再有Kernel。

-  当前绝大部分*nix和MacOS操作系统里的默认的Shell都是bash，bash由Brian
   Fox在1987年创造，全称Bourne Again shell ( bash)。

-  你或许听说除了bash之外，还有Bourne shell ( sh)，Korn shell ( ksh)，C
   shell （包括 csh and
   tcsh），但是你知道这个星球上一共存在着大约50多种不同的shell么？想了解他们，请参考 [[http://www.freebsd.org/ports/shells.html]]。

-  每个月[[http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html][tiobe]]上都会给一个编程语言的排名，来显示各种语言的流行度。排名指数综合了全球范围内使用该语言的工程师人数、教学的课程数和第三方供应商数。截止至2012年11月份，tiobe公布的编程语言排行榜里，bash的指数是0.56%排名22位。如果算上它旗下的awk
   0.21%和tcl
   0.146%，大概就能排到14名。注意这里还不包括bash的同源的兄弟姐妹csh、ksh等，算上它们，shell家族有望接近前十。值得一提的是一直以来shell的排名就很稳定，不像某些“暴发户”语言，比如objective-c，这些语言的流行完全是因为当前Apple系的崛起，但这种热潮极有可能来得快去得更快。

1. [[http://www.ituring.com.cn/download/01RTOwtqdvu1]]

[[http://www.ituring.com.cn/download/01RTOwwaK8UF]]

全球最大的源代码仓库Github里，shell相关的项目数占到了8%，跻身前5和Java相当，可见在实战工程里，shell可谓宝刀不老。图片来源，[[https://github.com/languages][参见这里]]

1. [[http://www.ituring.com.cn/download/01RTOwxOSjba]]

**** 一些强大的命令

再分享一些可能你不知道的shell用法和脚本，简单&强大！

/在阅读以下部分前，强烈建议读者打开一个shell实验，这些都不是shell教科书里的大路货哦：）/

-  =!$ !$是一个特殊的环境变量，它代表了上一个命令的最后一个字符串。如：你可能会这样： $mkdir mydir $mv mydir yourdir=
    $cd yourdir
    可以改成：
    $mkdir mydir
    $mv !$ yourdir
    $cd !$

-  *=sudo !!=*
    以root的身份执行上一条命令 。

   场景举例：比如Ubuntu里用=apt-get=安装软件包的时候是需要root身份的，我们经常会忘记在=apt-get=前加=sudo=。每次不得不加上=sudo=再重新键入这行命令，这时可以很方便的用=sudo !!=完事。

   （陈皓注：在shell下，有时候你会输入很长的命令，你可以使用!xxx来重复最近的一次命令，比如，你以前输入过，vi
   /where/the/file/is, 下次你可以使用 !vi 重得上次最近一次的vi命令。）

-  *=cd –=*
    回到上一次的目录 。

   场景举例：当前目录为=/home/a=，用=cd ../b=切换到=/home/b=。这时可以通过反复执行=cd –=命令在=/home/a=和=/home/b=之间来回方便的切换。
    （陈皓注：cd ~ 是回到自己的Home目录，cd
   ~user，是进入某个用户的Home目录）

-  *‘ALT+.' or ‘<ESC> .'*
    热建alt+. 或 esc+. 可以把上次命令行的参数给重复出来。

-  *=^old^new=*
    替换前一条命令里的部分字符串。

   场景：=echo "wanderful"=，其实是想输出=echo "wonderful"=。只需要=^a^o=就行了，对很长的命令的错误拼写有很大的帮助。（陈皓注：也可以使用
   *!!:gs/old/new*）

-  *du -s * | sort -n | tail*
    列出当前目录里最大的10个文件。

-  *:w !sudo tee %*
    在vi中保存一个只有root可以写的文件

-  *date -d@1234567890*
    时间截转时间

-  *> file.txt*
    创建一个空文件，比touch短。

-  *mtr coolshell.cn*
    mtr命令比traceroute要好。

-  在命令行前加空格，该命令不会进入history里。

-  *echo “ls -l” | at midnight*
    在某个时间运行某个命令。

-  *curl -u user:pass -d status=”Tweeting from the shell”
   http://twitter.com/statuses/update.xml*
    命令行的方式更新twitter。

-  *curl -u username --silent “https://mail.google.com/mail/feed/atom” |
   perl -ne ‘print “\t” if /<name>/; print “$2\n” if
   /<(title|name)>(.*)<\/\1>/;'*
    检查你的gmail未读邮件

-  *ps aux | sort -nk +4 | tail*
    列出头十个最耗内存的进程

-  *=man ascii=*
    显示ascii码表。

   场景：忘记ascii码表的时候还需要google么?尤其在天朝网络如此“顺畅”的情况下，就更麻烦在GWF多应用一次规则了，直接用本地的=man ascii=吧。

-  *=ctrl-x e=*
    快速启动你的默认编辑器（由变量$EDITOR设置）。

-  *=netstat –tlnp=*
    列出本机进程监听的端口号。（陈皓注：netstat -anop
   可以显示侦听在这个端口号的进程）

-  *=tail -f /path/to/file.log | sed '/^Finished: SUCCESS$/ q'=*
    当file.log里出现Finished:
   SUCCESS时候就退出tail，这个命令用于实时监控并过滤log是否出现了某条记录。

-  *=ssh user@server bash < /path/to/local/script.sh=*

   在远程机器上运行一段脚本。这条命令最大的好处就是不用把脚本拷到远程机器上。

-  *ssh user@host cat /path/to/remotefile | diff /path/to/localfile
   --*
    比较一个远程文件和一个本地文件

-  *net rpc shutdown -I ipAddressOfWindowsPC -U username%password*
    远程关闭一台Windows的机器

-  *=screen -d -m -S some_name ping my_router=*

   后台运行一段不终止的程序，并可以随时查看它的状态。=-d -m=参数启动“分离”模式，=-S=指定了一个session的标识。可以通过=-R=命令来重新“挂载”一个标识的session。更多细节请参考screen用法 =man screen=。

-  *=wget --random-wait -r -p -e robots=off -U mozilla http://www.example.com=*

   下载整个www.example.com网站。（注：别太过分，大部分网站都有防爬功能了：））

-  *=curl ifconfig.me=*
    当你的机器在内网的时候，可以通过这个命令查看外网的IP。

-  *convert input.png -gravity NorthWest -background transparent -extent
   720×200  output.png*
    改一下图片的大小尺寸

-  *=lsof –i=*
    实时查看本机网络服务的活动状态。

-  *vim scp://username@host//path/to/somefile*
    vim一个远程文件

-  *=python -m SimpleHTTPServer=*

   一句话实现一个HTTP服务，把当前目录设为HTTP服务目录，可以通过=http://localhost:8000=访问
   这也许是这个星球上最简单的HTTP服务器的实现了。

-  *=history | awk '{CMD[$2]++;count++;} END { for (a in CMD )print CMD[a] " " CMD[a]/count*100 "% " a }' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl | head -n10=*
    (陈皓注：有点复杂了，history|awk ‘{print $2}'|awk ‘BEGIN {FS=”|”}
   {print $1}'|sort|uniq -c|sort -rn|head -10)

   这行脚本能输出你最常用的十条命令，由此甚至可以洞察你是一个什么类型的程序员。

-  *tr -c “[:digit:]” ” ” < /dev/urandom | dd cbs=$COLUMNS conv=unblock
   | GREP_COLOR=”1;32″ grep --color “[\^ ]”*
    想看看Marix的屏幕效果吗？（不是很像，但也很Cool!）

看不懂行代码？没关系，系统的学习一下*nix
shell脚本吧，力荐[[http://www.ituring.com.cn/book/980][《Linux命令行与Shell脚本编程大全》]]。

最后还是那句Shell的至理名言：(陈皓注：下面的那个马克杯很不错啊，[[http://404null.com][404null.com]]挺有意思的)

 *“Where there is a shell，there is a way!”*

[[http://www.ituring.com.cn/download/01RTOxPgdeVs]]

[[http://404null.com/item/7/][[[http://www.ituring.com.cn/download/01RTOxPvYWI0]]]]

*[[http://404null.com/item/7/][Unix Shell变色马克杯]]*

**** 参考文献：

-  [[http://en.wikipedia.org/wiki/Unix_shell#Shell_categories][Unix
   Shell Wiki]]
-  [[https://github.com][Github language ranking]]
-  [[http://www.softpanorama.org/People/Shell_giants/introduction.shtml][An introduction of
   Unix Shell history]]
-  [[http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html][Tiobe
   Software]]
-  [[http://www.commandlinefu.com/]]

** [[http://coolshell.cn/articles/8883.html][应该知道的Linux技巧]]


[[http://coolshell.cn//wp-content/uploads/2013/01/linux-bash-300x225.jpg]]这篇文章来源于Quroa的一个问答《[[http://www.quora.com/Linux/What-are-some-time-saving-tips-that-every-Linux-user-should-know#][What
are some time-saving tips that every Linux user should know?]]》------
Linux用户有哪些应该知道的提高效率的技巧。我觉得挺好的，总结得比较好，把其转过来，并加了一些自己的理解。
首先，我想告诉大家，*在Unix/Linux下，最有效率技巧的不是操作图形界面，而是命令行操作，因为命令行意味着自动化*。如果你看过《[[http://coolshell.cn/articles/8619.html][你可能不知道的Shell]]》以及《[[http://coolshell.cn/articles/7829.html][28个Unix/Linux的命令行神器]]》你就会知道Linux有多强大，这个强大完全来自于命令行，于是，就算你不知道怎么去[[http://coolshell.cn/articles/7186.html][做一个环保主义的程序员]]，至少他们可以让你少熬点夜，从而有利于你的身体健康和性生活。下面是一个有点长的列表，正如作者所说，你并不需要知道所有的这些东西，但是如果你还在很沉重地在使用Linux的话，这些东西都值得你看一看。
（注：如果你想知道下面涉及到的命令的更多的用法，你一定要man一点。对于一些命令，你可以需要先yum或apt-get来安装一下，如果有什么问题，别忘了Google。如果你要Baidu的话，我仅代表这个地球上所有的生物包括微生物甚至细菌病毒和小强BS你到宇宙毁灭）

**** 基础

-  *学习 [[http://www.quora.com/Bash-shell][Bash]] *。你可以man
   bash来看看bash的东西，并不复杂也并不长。你用别的shell也行，但是bash是很强大的并且也是系统默认的。（学习zsh或tsch只会让你在很多情况下受到限制）

-  *学习 vim*
   。在Linux下，基本没有什么可与之竞争的编+译+辑器（就算你是一个Emacs或Eclipse的重度用户）。你可以看看《[[http://coolshell.cn/articles/5426.html][简明vim攻略]]》和
   《[[http://coolshell.cn/articles/7166.html][Vim的冒险游戏]]》以及《[[http://coolshell.cn/articles/5479.html][给程序员的Vim速查卡]]》还有《[[http://coolshell.cn/articles/894.html][把Vim变成一个编程的IDE]]》等等。

-  *了解 ssh*。明白不需要口令的用户认证（通过ssh-agent,
   ssh-add），学会用ssh翻墙，用scp而不是ftp传文件，等等。你知道吗？scp
   远端的时候，你可以按tab键来查看远端的目录和文件（当然，需要无口令的用户认证），这都是bash的功劳。

-  *熟悉bash的作业管理*，如： &, Ctrl-Z, Ctrl-C, jobs, fg, bg, kill,
   等等。当然，你也要知道Ctrl+\（SIGQUIT）和Ctrl+C （SIGINT）的区别。

-  *简单的文件管理* ： ls 和 ls -l (你最好知道 “ls -l” 的每一列的意思),
   less, head, tail 和 tail -f, ln 和 ln -s (你知道明白hard link和soft
   link的不同和优缺点), chown, chmod, du (如果你想看看磁盘的大小 du -sk
   *), df, mount。当然，原作者忘了find命令。

-  *基础的网络管理*： ip 或 ifconfig, dig。当然，原作者还忘了如netstat,
   ping, traceroute, 等

-  *理解正则表达式*，还有grep/egrep的各种选项。比如： -o, -A, 和 -B
   这些选项是很值得了解的。

-  *学习使用 apt-get 和 yum
   来查找和安装软件*（前者的经典分发包是Ubuntu，后者的经典分发包是Redhat），我还建议你试着从源码编译安装软件。

*日常*

-  在 bash 里，使用 Ctrl-R 而不是上下光标键来查找历史命令。

-  在 bash里，使用 Ctrl-W 来删除最后一个单词，使用 Ctrl-U
   来删除一行。请man bash后查找Readline Key
   Bindings一节来看看bash的默认热键，比如：Alt-.
   把上一次命令的最后一个参数打出来，而Alt-* 则列出你可以输入的命令。

-  回到上一次的工作目录： cd --  （回到home是 cd ~）

-  使用
   xargs。这是一个很强大的命令。你可以使用-L来限定有多少个命令，也可以用-P来指定并行的进程数。如果你不知道你的命令会变成什么样，你可以使用xargs
   echo来看看会是什么样。当然， -I{} 也很好用。示例：

#+BEGIN_QUOTE
  #+BEGIN_EXAMPLE
      find . -name \*.py | xargs grep some_function

      cat hosts | xargs -I{} ssh root@{} hostname
  #+END_EXAMPLE
#+END_QUOTE

-  pstree -p
   可以帮你显示进程树。（读过我的那篇《[[http://coolshell.cn/articles/7965.html][一个fork的面试题]]》的人应该都不陌生）

-  使用 pgrep 和 pkill 来找到或是kill 某个名字的进程。 (-f 选项很有用).

-  了解可以发给进程的信号。例如：要挂起一个进程，使用 kill -STOP [pid].
   使用 man 7 signal 来查看各种信号，使用kill -l
   来查看数字和信号的对应表

-  使用 nohup 或  disown 如果你要让某个进程运行在后台。

-  使用netstat -lntp来看看有侦听在网络某端口的进程。当然，也可以使用
   lsof。

-  在bash的脚本中，你可以使用 set -x 来debug输出。使用 set -e
   来当有错误发生的时候abort执行。考虑使用 set -o pipefail
   来限制错误。还可以使用trap来截获信号（如截获ctrl+c）。

-  在bash 脚本中，subshells (写在圆括号里的)
   是一个很方便的方式来组合一些命令。一个常用的例子是临时地到另一个目录中，例如：

#+BEGIN_QUOTE
  #+BEGIN_EXAMPLE
      # do something in current dir
      (cd /some/other/dir; other-command)
      # continue in original dir
  #+END_EXAMPLE
#+END_QUOTE

-  在 bash 中，注意那里有很多的变量展开。如：检查一个变量是否存在:
   ${name:?error
   message}。如果一个bash的脚本需要一个参数，也许就是这样一个表达式
   input_file=${1:?usage: $0 input_file}。一个计算表达式： i=$(( (i +
   1) % 5 ))。一个序列： {1..10}。 截断一个字符串： ${var%suffix} 和
   ${var#prefix}。 示例： if var=foo.pdf, then echo ${var%.pdf}.txt
   prints “foo.txt”.

-  通过 <(some command)
   可以把某命令当成一个文件。示例：比较一个本地文件和远程文件
   /etc/hosts： diff /etc/hosts <(ssh somehost cat /etc/hosts)

-  了解什么叫
   “[[http://zh.wikipedia.org/wiki/Here%E6%96%87%E6%A1%A3][here
   documents]]” ，就是诸如 cat <<EOF 这样的东西。

-  在 bash中，使用重定向到标准输出和标准错误。如： some-command >logfile
   2>&1。另外，要确认某命令没有把某个打开了的文件句柄重定向给标准输入，最佳实践是加上
   “</dev/null”，把/dev/null重定向到标准输入。

-  使用 man ascii 来查看 ASCII 表。

-  在远端的 ssh 会话里，使用 screen 或 dtach
   来保存你的会话。（参看《[[http://coolshell.cn/articles/7829.html][28个Unix/Linux的命令行神器]]》）

-  要来debug Web，试试curl 和 curl -I 或是 wget 。我觉得debug
   Web的利器是firebug，curl和wget是用来抓网页的，呵呵。

-  把 HTML 转成文本： lynx -dump -stdin

-  如果你要处理XML，使用 xmlstarlet

-  对于 Amazon S3， s3cmd 是一个很方便的命令（还有点不成熟）

-  在 ssh中，知道怎么来使用ssh隧道。通过 -L or -D (还有-R) ，翻墙神器。

-  你还可以对你的ssh 做点优化。比如，.ssh/config
   包含着一些配置：避免链接被丢弃，链接新的host时不需要确认，转发认证，以前使用压缩（如果你要使用scp传文件）：

#+BEGIN_QUOTE
  #+BEGIN_EXAMPLE
      TCPKeepAlive=yes
      ServerAliveInterval=15
      ServerAliveCountMax=6
      StrictHostKeyChecking=no
      Compression=yes
      ForwardAgent=yes
  #+END_EXAMPLE
#+END_QUOTE

-  如果你有输了个命令行，但是你改变注意了，但你又不想删除它，因为你要在历史命令中找到它，但你也不想执行它。那么，你可以按下
   Alt-# ，于是这个命令关就被加了一个#字符，于是就被注释掉了。

*数据处理 *

-  了解 sort 和 uniq 命令 (包括 uniq 的 -u 和 -d 选项).

-  了解用 cut, paste, 和 join
   命令来操作文本文件。很多人忘了在cut前使用join。

-  如果你知道怎么用sort/uniq来做集合交集、并集、差集能很大地促进你的工作效率。假设有两个文本文件a和b已解被
   uniq了，那么，用sort/uniq会是最快的方式，无论这两个文件有多大（sort不会被内存所限，你甚至可以使用-T选项，如果你的/tmp目录很小）

#+BEGIN_QUOTE
  #+BEGIN_EXAMPLE
      cat a b | sort | uniq > c  # c is a union b 并集

      cat a b | sort | uniq -d > c  # c is a intersect b 交集

      cat a b b | sort | uniq -u > c  # c is set difference a - b 差集
  #+END_EXAMPLE
#+END_QUOTE

-  了解和字符集相关的命令行工具，包括排序和性能。很多的Linux安装程序都会设置LANG
   或是其它和字符集相关的环境变量。这些东西可能会让一些命令（如：sort）的执行性能慢N多倍（注：就算是你用UTF-8编码文本文件，你也可以很安全地使用ASCII来对其排序）。如果你想Disable那个i18n
   并使用传统的基于byte的排序方法，那就设置export LC_ALL=C
   （实际上，你可以把其放在
   .bashrc）。如果这设置这个变量，你的sort命令很有可能会是错的。

-  了解 awk 和
   sed，并用他们来做一些简单的数据修改操作。例如：求第三列的数字之和：
   awk ‘{ x += $3 } END { print x
   }'。这可能会比Python快3倍，并比Python的代码少三倍。

-  使用 shuf 来打乱一个文件中的行或是选择文件中一个随机的行。

-  了解sort命令的选项。了解key是什么（-t和-k）。具体说来，你可以使用-k1,1来对第一列排序，-k1来对全行排序。

-  Stable sort (sort -s)
   会很有用。例如：如果你要想对两例排序，先是以第二列，然后再以第一列，那么你可以这样：
   sort -k1,1 | sort -s -k2,2

-  我们知道，在bash命令行下，Tab键是用来做目录文件自动完成的事的。但是如果你想输入一个Tab字符（比如：你想在sort
   -t选项后输入<tab>字符），你可以先按Ctrl-V，然后再按Tab键，就可以输入<tab>字符了。当然，你也可以使用$'\t'。

-  如果你想查看二进制文件，你可以使用hd命令（在CentOS下是hexdump命令），如果你想编译二进制文件，你可以使用bvi命令（[[http://bvi.sourceforge.net/]] 墙）

-  另外，对于二进制文件，你可以使用strings（配合grep等）来查看二进制中的文本。

-  对于文本文件转码，你可以试一下 iconv。或是试试更强的 uconv
   命令（这个命令支持更高级的Unicode编码）

-  如果你要分隔一个大文件，你可以使用split命令（split by
   size）和csplit命令（split by a pattern）。

*系统调试*

-  如果你想知道磁盘、CPU、或网络状态，你可以使用 iostat, netstat, top
   (或更好的 htop), 还有 dstat
   命令。你可以很快地知道你的系统发生了什么事。关于这方面的命令，还有iftop,
   iotop等（参看《[[http://coolshell.cn/articles/7829.html][28个Unix/Linux的命令行神器]]》）

-  要了解内存的状态，你可以使用free和vmstat命令。具体来说，你需要注意
   “cached” 的值，这个值是Linux内核占用的内存。还有free的值。

-  Java 系统监控有一个小的技巧是，你可以使用kill -3 <pid>
   发一个SIGQUIT的信号给JVM，可以把堆栈信息（包括垃圾回收的信息）dump到stderr/logs。

-  使用 mtr 会比使用 traceroute 要更容易定位一个网络问题。

-  如果你要找到哪个socket或进程在使用网络带宽，你可以使用 iftop 或
   nethogs。

-  Apache的一个叫 ab
   的工具是一个很有用的，用quick-and-dirty的方式来测试网站服务器的性能负载的工作。如果你需要更为复杂的测试，你可以试试
   siege。

-  如果你要抓网络包的话，试试 wireshark 或 tshark。

-  了解 strace 和
   ltrace。这两个命令可以让你查看进程的系统调用，这有助于你分析进程的hang在哪了，怎么crash和failed的。你还可以用其来做性能profile，使用
   -c 选项，你可以使用-p选项来attach上任意一个进程。

-  了解用ldd命令来检查相关的动态链接库。注意：[[http://coolshell.cn/articles/1626.html][ldd的安全问题]]

-  使用gdb来调试一个正在运行的进程或分析core
   dump文件。参看我写的《[[http://coolshell.cn/articles/3643.html][GDB中应该知道的几个调试方法]]》

-  学会到 /proc
   目录中查看信息。这是一个Linux内核运行时记录的整个操作系统的运行统计和信息，比如：
   /proc/cpuinfo, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/,
   /proc/xxx/smaps.

-  如果你调试某个东西为什么出错时，sar命令会有用。它可以让你看看 CPU,
   内存, 网络, 等的统计信息。

-  使用 dmesg 来查看一些硬件或驱动程序的信息或问题。

作者最后加了一个免责声明：Disclaimer: Just because you /can/ do
something in bash, doesn't necessarily mean you should. ;) （全文完）

** [[http://coolshell.cn/articles/4102.html][如何学好C语言]]


有人在酷壳的留言版上询问下面的问题

#+BEGIN_QUOTE
  [[http://coolshell.cn/guestbook#comment-40269][keep_walker]] *:*
   今天晚上我看到这篇文章。

  [[http://programmers.stackexchange.com/questions/62502/small-c-projects]]

  我也遇到了和提问的老外一样的问题。。能给像遇到这样烦恼的程序员一点建议嘛？谢谢！
#+END_QUOTE

我相信，这可能是很多朋友的问题，我以前也有这样的感觉，编程编到一定的时候，发现能力到了瓶颈，既不深，也不扎实，半吊子。比如：你长期地使用Java和.NET
，这些有虚拟机的语言对于开发便利是便利，但是对于程序员来说可能并不太好，原因有两个：

1. 虚拟机屏蔽了操作系统的系统调用，以及很多底层机制。
2. 大量的封装好的类库也屏蔽了很多实现细节。

一段时间后，你会发现你知其然，不知所以然。。我以前在CSDN上写过一篇《*Java
NIO类库Selector机制解析（[[http://blog.csdn.net/haoel/archive/2008/03/27/2224055.aspx][上]]，[[http://blog.csdn.net/haoel/archive/2008/03/27/2224069.aspx][下]]，[[http://blog.csdn.net/haoel/archive/2008/05/04/2379586.aspx][续]]）*》，在那篇文章中我说提到过（有讥讽的语气）Java的程序员不懂底层实现，所以很难把技术学得更扎实。此时，一部分程序员会不自然地想学学底层的技术，很自然的，C语言就被提了上来。

下面是我给这位朋友的一些建议：

-  *鼓励并为你叫好*。我鼓励你想要去学C语言的想法和精神，很多人都觉得C语言好学，其实并不然。（你可以看看《[[http://coolshell.cn/articles/945.html][C语言的迷题]]》）现在的这个社会更多地去关注那些时髦的技术，而忽略了这个流行了40+年的C语言。*一门技术如果能够流行40多年，这才是你需要去关注和学习的技术*，而不是那些刚出来的技术（[[http://coolshell.cn/articles/3609.html][过度炒作的技术]]，[[http://coolshell.cn/articles/3008.html][Windows编程史]]）。这才是踏踏实实的精神。

-  *不要找借口*。这一条路走下来并不容易，不要给自己找借口。我最不喜欢听到的就是“*很忙，没有时间*”这样的借口。我以前在银行做项目，早9点到晚10点，周一到周六，我一样可以每天抽1个小时来看书和专研，一年下来也能精读5、6本书。我现在的工作项目和招聘任务很紧张，刚生的小孩只有自己和老婆两人带，还需要准备讲课，但是我还是能够找到时间看文章写文章维护酷壳。所以，我可以告诉你，“*时间就像乳沟，只要你肯挤，就一定会有*”。

-  *学好C语言和系统编程*。我认为，学好编程有四个方面：*语言、算法和数据结构、系统调用和设计*。

   -  *语言*。我可以告诉你C语言有两大主题你要好好学，一个是内存管理，一个是指针！这个世界上90%以上的C/C++出的严重性错误全是和这两个有关。不要看谭浩强的那本书，那本是本烂书。推荐这本书给你《[[http://product.china-pub.com/14975&ref=browse][C程序设计语言（第2版·新版）]]》
   -  *算法和数据结构*。我认为，用C语言实现算法和数据结构莫过于最爽的事情。推荐你看这本书------[[http://product.china-pub.com/192975&ref=browse][算法:C语言实现(第1～4部分)基础知识、数据结构、排序及搜索(原书第3版)]]，还有那本经典的《[[http://product.china-pub.com/31701][算法导论]]》
   -  [[http://product.china-pub.com/192975&ref=browse][]]*系统编程*。Windows下推荐两本书------《[[http://product.china-pub.com/52880][Windows
      程序设计]]》和《[[http://product.china-pub.com/209058][Windows核心编程]]》，Unix/Linux下推荐两本书------《[[http://product.china-pub.com/30181][Unix高级环境编程]]》和《[[http://product.china-pub.com/196770][Unix网络编程卷1，套接字]]》《[[http://product.china-pub.com/196859][Unix网络编程卷2，进程间通信]]》尤其是《Unix网络编程》这本书，一通百通，无论Windows还是Unix/Linux，都是一样的。
   -  *系统设计*。关于设计方面，我全力推荐《[[http://product.china-pub.com/197413][Unix编程艺术]]》，看完以后，你就明白什么是真正的编程文化了。然后，当你看到Windows的Fans的某些言论时，你就知道什么叫一笑了之了。

如果你能在2-3年内精读完这些书，并全部融会贯通，那么你就明白什么是一览众山小的感觉了！我足足花了5年时间才算是真正全部读完这些书的。最后，祝你好运！努力！

/*-------更新：2011/03/29 20:00-------*/

我想，这篇文章主要想告诉大家这么几件事：

-  编程编到一定时候，你就需要了解底层系统的机制，否则，知其然不知所以然。
-  我没有否定非C的程序员的逻辑，真正的逻辑是------如果你想要了解底层机制，请学习C语言和操作系统。
-  40多年的Unix/C影响深远。包括影响了Windows。如果你想一通百通，一定要了解Unix。那是计算机文化真正的根。
-  不要肤浅地去思考问题。比如，不要以为一个DBA就不会考虑数据库引擎的内存页面的问题。也不要以为Web程序员就不需要了解后台的服务器和脚本的运行性能以及TCP/IP的问题。

*高手往往都是有很强的系统的基础知识的，表面的东西永远是肤浅的。*

** [[http://coolshell.cn/articles/6548.html][Why C++ ? 王者归来]]

因为又有人邀请我去Quora的C2C网站去回答问题去了，这回是 关于
[[http://weibo.com/n/laiyonghao][@laiyonghao]]
的这篇有点争议的博文《2012 不宜进入的三个技术点》ActionScript，Thread 和
C++，[[http://blog.csdn.net/lanphaday/article/details/7223385][C++争议的争议最大]]。（要我说，.NET比C++更需要慎重进入，呵）。我就在这里回复一下这个问题吧。

正好我一个月前看到一个视频，这个演讲视频还比较著名，这个演讲者是/Exceptional
C++/ 和 /C++ Coding Standards/ 的作者，还是ISO C++
委员会的Chair，C++/CLI首席架构师，还是Microsoft的软件架构师，他叫[[http://herbsutter.com/][Herb
Sutter]]，他的这个演讲视频是 [[http://cppandbeyond.com/][C++ and Beyond
2011]]上的一次公开演讲，题目是------[[http://channel9.msdn.com/posts/C-and-Beyond-2011-Herb-Sutter-Why-C][Why
C++]]?
（如果你觉得那里的视频比较慢，你可以看[[http://v.youku.com/v_show/id_XMzA5OTIwODIw.html][优酷上的视频]]）（英文听力好的同学可以看一样，因为都没有中文字幕）

我觉得这篇文章就足够可以说明很多问题了，所以，我把Herb的演讲幻灯片截了几页放到这里，并做上一些注释，算是一个演讲内容摘要吧。

1） 为什么C++？因为 Performance per $，也就是说performance
就是钱，这个分成三个方面，

-  耗电，芯片的耗电量，移动设备的耗电量，家用电脑的耗电量都和钱有关系。
-  资源，家用电脑和移动设备上的处理器资源有限，因为要让一般消费者买的起。
-  体验，在更小的设备上会有更好的体验，有更好的体验就可以挣更多的钱。

移动设备上的耗电量相信用过智能手机的人都知道吧，Android手机的耗电量实在是太大了。就算是iPhone在开启Wifi和3G的情况下耗电量也很快。

[[http://coolshell.cn//wp-content/uploads/2012/02/WhyCPP.01.jpg]]

2）C++的进化分成三个时代：

-  1979 -- 1989：研究C的对象能力。主要是为C++做准备
-  1989 -- 1999：C++成了主流。
-  1999 -- 2009：Coffee-based语言（Java,
   .NET）出现了，极大的提高了开发生产力。

对于第三个时代，Herb说了很多，他说这个并没有什么错，因为这个时候我们非常关注开发的生产力，这个非常重要，这就是为什么C++一下就失去优势的地方。但是是否这些Coffee-Based的语言可以做任重要的事呢？不行，很多时候，这是一个Trade-Off的事，也就是生产力不是免费的是需要你用别的东西去交换的。

[[http://coolshell.cn//wp-content/uploads/2012/02/WhyCPP.02.jpg]]

3）第四个时期。

Herb认为，2009-2019是第四个时期，因为我们又喜欢Native
Code了，C++从被驱逐后又被请回来了。因为网站的性能越来越是个问题，移动端的设备非常流行。但主要是因为Performance就是钱，因为前面的三个因素，性能影响的是dollar，不尊重性能的公司都会发现花钱的速度太快了。（比如去年大家热炒的京东促销和12306.cn的问题，12306给整个社会造成了巨大的金钱浪费）

Herb把这个时期比做 The Return of the King。（指环王的第三部：王者归来）
*性能为王！*

这就好像我在“[[http://coolshell.cn/articles/6526.html][软件开发的三重门]]”里说的，开垦时代需要的是快和生产力，而开垦完后就得保证其稳定性。

[[http://coolshell.cn//wp-content/uploads/2012/02/WhyCPP.03.jpg]]

4）Herb还给了一张幻灯片问，“The World is built on
....”，后面例出了多个语言。然后Herb说，世界是由C和C++构成的。

[[http://coolshell.cn//wp-content/uploads/2012/02/WhyCPP.03.01.jpg]]

5）Herb给了一张表格，这张表可相当形像。如果把我们的对编程语言的需求总结为四个：*效率，灵活，抽象，生产率*。那么，C语言玩的是前两个，而C++玩的是前三个，Java和C#玩的是后两个（抽象和生产率）

任保一种设计都不可能让你什么都要的，这就是Trade-Off------什么事都需要交换的。

[[http://coolshell.cn//wp-content/uploads/2012/02/WhyCPP.04.jpg]]

6）Herb举了一个微软内的例子，用C++ 和 ATL
来开发IE工具条的报告，意思是你可以用脚本在IE的工具条上加按钮，但是作者建议使用C++，因为用.NET或是脚本有重大的limitation，尤其是性能上的问题。

[[http://coolshell.cn//wp-content/uploads/2012/02/WhyCPP.05.jpg]]

7）接下来，我们来看看移动设备。

下图中，第一个是iOS，第二个是Android，第三个是WinPhone。Herd说了几个事：

a）比Web APP，人们更喜欢Native的APP，这个在用移动设备上可以得到验证。

b）iOS也好，Android也好，WinPhone也好，他们不是在搞操作系统，而是在搞应用，为的是让智能手机更好。手机就是一个App。

c）这三个手机在第一版出来时都不支持C++，而第二版出来时都支持C++了。因为他们要兼顾性能和一定程度上的开发效率。WinPhone还没有到第二版，让我们拭目以待。（我以前写过一篇[[http://coolshell.cn/articles/3549.html][调侃Android支持C++开发]]的文章，这也只是一年前的事，说明C++全面回归了）

[[http://coolshell.cn//wp-content/uploads/2012/02/WhyCPP.06.jpg]]

8）如果你还是不相信的话，我们可以看看为什么Apple和Google都在搞C++的编译器，因为他们觉得g++性能不行。所以，基于LLVM的编译器正在领导潮流，因为我们关注Natvie
Code的性能优化。

[[http://coolshell.cn//wp-content/uploads/2012/02/WhyCPP.07.jpg]]

9）接下来，Herb说了一下数据中心，你知道数据中心最花钱的是什么吗？三个事：

#+BEGIN_QUOTE

  -  57% 花在了硬件上。
  -  18% 花在了配电和降温上。
  -  13% 花在了耗电上。
#+END_QUOTE

88%的钱花在了硬件和电力上。这可是很大一笔费用啊。（还有人说硬件比软件便宜吗？）我记得我上一个公司的数据中心每年要花的电费就在百万美元以上。

[[http://coolshell.cn//wp-content/uploads/2012/02/WhyCPP.08.jpg]]

10）昨天在[[http://weibo.com/1401880315/y3kshD9jf][微博上有个笑话]]，说是某咨询师要求程序员把代码打印出来走查，程序员问是不是要用彩打？哈哈。我说，这至少不环保嘛。消耗太大了。是的，C++是可以省电的，以及于C++之父都在YouTube
说C++是可以减轻全球变暖的问题。哇，C++开始真正造福人类了。

[[http://coolshell.cn//wp-content/uploads/2012/02/WhyCPP.09.jpg]]

11）我还需要重温一下老大的这句话------

#+BEGIN_QUOTE
  *My contribution to the fight against global warming is C++'s
  efficiency*: Just think if Google had to have twice as many server
  farms! Each uses as much energy as a small town. And it's not just a
  factor of two... *Efficiency is not just running fast or running
  bigger programs, it's also running using less resources*.

  Bjarne Stroustrup, June 2011
#+END_QUOTE

最后一句说的非常好！*效率不仅仅只是跑得，跑得多，更是可以使用更少的资源*。

12）下面让我们再来看一张表，一张把钱投到哪里的表格，这样我们可以看到一些趋势。

-  70年代80年代，资源不够，主要是把钱投在性能上。
-  80年代到90代，主要是90年代开始有一半的投次到了抽象和生产率上。
-  00年代，完全都在抽象和生产率上。
-  10年代，80%的钱都要回头来解决性能问题。这就是C/C++的王者归来。

[[http://coolshell.cn//wp-content/uploads/2012/02/WhyCPP.10.jpg]]

13）当然，不是C++不注重
开发效率，看看C++0X的标准引入了多少东西我们就知道了。但是本质上，*C++还是致力于性能和抽象的完全平衡*。

[[http://coolshell.cn//wp-content/uploads/2012/02/WhyCPP.11.jpg]]

那么，我们还会觉得C++要被淘汰了，不适合进入了吗？看完这个演讲，你应该有答案的。

后面讲了C++的文艺复兴，你可以在Google 搜索
“[[https://www.google.com/search?q=C%2B%2B+Renaissance][C++
Renaissance]]”看看。另外，*该视频的讲议可以在[[http://ecn.channel9.msdn.com/content/WhyCPPCB2011.pdf][这里下载]]*。

** [[http://www.williamlong.info/archives/2700.html][写给新手程序员的一封信]]

[[http://www.williamlong.info/cat/?tags=Programming][[[http://www.williamlong.info/logo/Programming.gif]]]]

首先，欢迎来到程序员的世界。在这个世界上，不是有很多人想创造软件并解决问题。你是一名hacker，属于那些愿意做一些有挑战性的事情的人。

“当你不创造东西时，你只会根据自己的感觉而不是能力去看待问题。” --
WhyTheLuckyStiff

对于下面的文字你不必完全接受，所有这些来自一个其貌不扬的程序员。我喜欢把事情做到最好，而不是对原来的东西修修补补。

仅仅是因为爱好开始做一些创新，这是一个很好的开始！如果你说“我要先学习一下再开始做”那么你永远不会真正开始。每个人都需要从某个地方开始，所以现在打开你的编辑器开始写代码吧。

下面是一些很重要的建议，虽然有人并不认同，但我保证你看完我的分析以后会站在我这一边。一开始，先不要管算法和数据结构。大多数简单的程序不需要用到算法和数据结构，所以当你真正需要时再去学习。编程一段时间以后，你就会知道在哪些地方用到他们。这时知道算法的名字并了解它们的功能，然后找一些相关的论文去理解算法并动手编程实践。如果没有现成的函数库（其他程序员提供的可重用代码），你用自己喜欢的编程语言来实现它。

[[/upload/2700_1.jpg]]

*0.
选择一门好的编程语言，一门你自认为可以用它快速地做出一些有用东西的语言。*

不要选择C语言作为你第一门编程语言。也许选择C语言会给你一种过时的满足感。虽然它比早期的汇编语言提供了更好语法描述，但是今天C（或者C++）不是能够快速编写软件的语言。毫不偏袒的说，我建议你学习一种动态语言。选择一种你觉得语法（文档）让你使用起来更舒服的编程。为此，你可能需要花费一些时间来在几种不同的语言之间进行比较。这么做目的不是为了让你感觉更好或者让编程更容易。更快地完成自己的作品并且能够看到成果，才是激励你编程的源动力。不要选择一门需要某种重量级的IDE（IDE是一种能够帮助你编写并运行代码的工具）才能轻松编程的语言。你所需要的仅仅是一个文本编辑器。（注：原文并没有标号，是我们加上的，请大家别忘记了哦，我们是从零开始数数的。:)
）

*1. 选择一个好的编辑器。*

编辑器对程序员而言，就是像是弓对弓箭手一样重要。这里有一些推荐的编辑器：

-  SublimeText 2 -- 如果你刚开始编程，推荐使用SublimeText 2

-  Emacs --
   学习曲线陡峭，快捷键复杂。如果你想定制自己的使用习惯，需要学习Emacs
   Lisp.

-  Vim --
   不仅操作简洁而且它默认包含在linux的发行版中，所以深受大家欢迎。我开始使用了2年Emacs。由于Emacs的快捷键操作过于复杂，我的双手开始经常疼痛，这迫使我转向了Vim阵营。了解Vim的快捷键是非常有必要的。当你在远程的服务器上编辑代码时，你唯一不需要安装的编辑器就是Vim。

注意！Emacs和Vim可能已经成为成为古董了。但是，它们都具备一些现代编辑器多不具备的功能。

*2. 选择一个你可以从中学到东西的操作系统*

Windows不会教会你任何东西。使用Windows你唯一学会的就是打开一个exe（可执行）文件来安装软件和使用它。可能刚开始的时候你会觉得很酷，但是长远来看，如果你立志成为一个web开发人员，可能还是要具备基本的linux知识，尤其是当你要发布程序的时候。Linux也允许你根据自己的要求来定制程序。Macs也很酷，但是我认为你现在经济上还负担不起。

*3. 不要通过复制粘贴来做备份*

一个新手程序员通常会把文件复制粘贴到一个临时目录下面来进行备份。这也许也是他们唯一知道的方法。不要那么做！你需要使用版本控制软件。我强烈推荐使用Git，它是个目前很流行的版本控制工具，而且使用起来非常简单。对一个Git新手，有一个良好的社区和很多参考资源来学习。（除了Git之外，还有mercurial,
darcs,
fossil等等。但是我还是建议从Git开始，我有很多的理由来支持Git，这里就不多费口舌了。）

*4. 知道去哪里寻求帮助*

参加一个和你相关的（你使用编程工具相关的）程序员社区。比如StackOverflow就是程序员的Facebook。那里没有消息状态和回复，取而代之的是问题和答案。除此之外还要学会使用IRC。IRC是一种老式的聊天室，现在还在被大多数开发人员用来分享技术信息和帮助解决问题。

*5. 培养你的礼仪*

知道什么时候问问题。你遇到的大多数问题都是别人碰到过并且在Internet上能够找到解答的。在IRC或者任何论坛里发问之前，先搜索一下google（或者blekko）来看看是不是有现成的答案。在IRC上问问题需要有耐心。永远记住，人们只是处于好心来免费帮助你。有时你发问以后需要几个小时才能有回复。所以，耐心等待。除此之外，记得问问题的时候要礼貌。世界很小，你怎么对待别人，别人就会怎么对待你。

*6. 结交朋友，技术书籍只能教你解决常见的问题（他们说：书是死的）*

当你在捣鼓一些程序或者从程序的作者那里学习，你能学到一些书本上没有的东西。当你散步的时候，请和遇到的朋友打招呼。你肯定不是唯一的程序员。和其他的程序员一起交朋友一起工作。你会注意到，当一群技术爱好者在一起的时候，不论话题是从什么地方开始，最后总是以技术话题收尾。这是必然的现象。所以你可以尽情参与。在你的黄金年龄努力编程，我能告诉你的是，我在开始6年前寻找朋友并开始讨论编程，从那时起才学到那些书本和文章不会我的东西。所以我总是说，我的编程经验有6年，因为只有那个时候开始，我才开始与人交流并开始感觉真正地开始学习编程。

*7. 参加开源项目*

为开源项目编写代码能带来回报。这不仅仅是帮助别人，你留下的代码会被其他人使用或（可能）改进。当别人给你的代码添加功能或者提出修改意见时，也是在提高你的编程水平。开源软件项目不一定要是一个大工程，编写一个下载youtube视频的小程序也是很有用的。更重要的是，你会惊奇地发现你编写的代码会成为与他人有效沟通的桥梁。

最后，若干年之后如果本文的内容曾经对你有一点点的帮助，作为回报请写一封类似的信给希望开始编程并不知如何入手的朋友，有可能的话请纠正本文中过时的内容。

智者说过，掌握某个东西需要10年或10000个小时，也就是汉语中的“十年磨一剑”，所以不用着急。

英文原文：[[http://blog.akash.im/an-open-letter-to-those-who-want-to-start][An
open letter to those who want to start programming]]

中文翻译：[[http://www.jobbole.com/entry.php/903][伯乐在线]]



** [[http://emuch.net/html/200711/641492.html][回复评审意见必说的话]]

很多人都遇到过回复审稿人意见的时候。本人曾经因为回复审稿意见不合适而导致拒稿，相当的惨哪！！后来发现回复审稿意见时，除了写清修改内容外，还有一些话是必须要写的。对审稿人的意见提出不同的看法也应该讲究一定的技巧。由于这些话的英文都不难写，所以我直接写成中文表述，觉得有用的虫友自己翻译吧。
      首先，不论审稿人提了什么意见，你在回复的时候，第一句话一定要说：“谢谢您的建议，您的所有建议都非常的重要，它们对我的论文写作和科研工作都具有重要的指导意义！！”
      其次，在回复信的结尾最好写上“再次谢谢您的建议，希望能够从您哪里学到更多的知识。”这句话最好用黑体，要显眼。
      再次，如果审稿人提的意见你暂时无法做到（比如，要你增加实验或改进实验等）。那么，为了论文尽快发表，你必须拒绝这样的要求。但是，你不要摆出一大堆理由来证明这个意见是不好实现的。你应该说：“谢谢您的建议，它非常的重要，由于您的建议，我发现了我目前工作中的不足之处，我会在以后的工作中按照您的建议提高科研水平，取得更多成绩！”这样就委婉的拒绝了评审意见，又让评审人觉得你很看重他的意见。
       第四，如果审稿人的意见明显有问题。那么没办法了，你必须据理力争。但是，你一定不能说：“审稿人先生，我认为你的意见是错的！”你不必对他的意见发表任何的评论，只需要列出你的理由和证据就可以了，结尾也不要强调你的观点是正确的。简单说就是“既不说你对，也不说我对，证据说话”。
       第五，如果审稿人的评价比较傲慢，而且有失公平。那么，不用客气，直接写信给编辑，痛批审稿人。（我就遇到过这样的情况，痛批后反而被录用。）

** [[http://blog.sina.com.cn/s/blog_49956eee0102vora.html][给国外教授发邮件的礼貌用语]]

感谢读者是邮件开场白的好办法。感谢您的读者能让对方感到高兴，特别是之后你有事相求的情况下会很有帮助。



Thank you for contacting us.如果有人写信来询问公司的服务，就可以使用这句句子开头。向他们对公司的兴趣表示感谢。



Thank you for your prompt reply.当别人很快就回复了你的邮件，一定记得要感谢他们。如果回复并不及时，只要将“prompt”除去即可，你还可以说，“Thank you for getting back to me.”



Thank you for providing the requested information.如果你询问某人一些信息，他们花了点时间才发送给你，那就用这句句子表示你仍然对他们的付出表示感激。



Thank you for all your assistance.如果有人给了你特别的帮助，那一定要感谢他们！如果你想对他们表示特别的感激，就用这个句子，“I truly appreciate … your help in resolving the problem.”Thank you raising your concerns.





在邮件的结尾



在邮件开头表示感谢一般是表示对对方过去付出的感谢，而在邮件结尾处表示感谢是对将来的帮助表示感谢。事先表示感谢，能让对方在行动时更主动更乐意。



Thank you for your kind cooperation.如果你需要读者帮助你做某事，那就先得表示感谢。



Thank you for your attention to this matter.与以上的类似，本句包含了你对对方将来可能的帮助表示感谢。



Thank you for your understanding.如果你写到任何会对读者产生负面影响的内容那就使用这句句子吧。



Thank you for your consideration.如果您是在寻求机会或是福利，就用这封邮件结尾。



Thank you again for everything you've done.这句句子可以用在结尾，和以上有所不同。如果你在邮件开头已经谢过了读者，你就可以使用这句话，但是因为他们的帮助，你可以着重再次感谢你们的付出。

** [[http://zhan.renren.com/leadessay?gid=3602888497999762196&checked=true][给国外教授发邮件会用到的礼貌用语]]

1. I am writing to confirm /enquire/inform you...
我写信时要确认/询问/通知你。。。

2. I am writing to follow up on our earlier decision on the marketing campaign in Q2.
我写信来追踪我们之前对于第二季度营销活动的决定。

3. With reference to our telephone conversation today...
关于我们今天在电话中的谈话。。。

4. In my previous e-mail on October 5...
先前在10月5日所写的信。。。

5. As I mentioned earlier about...
如我先前所提及关于。。。

6. as indicated in my previous e-mail...
如我在先前的信中所提出。。。

7. As we discussed on the phone...
如我们上次在电话中的讨论。。。

8. from our decision at the previous meeting...
如我们在上次会议中的决定。。。

9. as you requested/per your requirement...
按照你的要求。。。

10.In reply to your e-mail dated April 1，we decided...
回答你在4月1日写的信，我们决定。。。

11.This is in response to your e-mail today.
这是针对你今天早上来信的回复。

12. As mentioned before, we deem this product has strong unique selling points in china.
如先前所述，我们认为这个产品在中国有强有力且独一无二的销售点。

13. As a follow-up to our phone conversation yesterday, I wanted to get back to you about the pending issues of our agreement.
追踪我们昨天在电话中所谈，我想答复你我们合约的一些待解决的议题。

14. I received your voice message regarding the subject. I’m wondering if you can elaborate i.e. provide more details.
我收到你关于这个主题的留言。我想你是否可以再详尽说明，也就是再提供多一点细节。

15. Please be advised/informed that...
请被告知。。。

16. Please note that...
请注意。。。

17. We would like to inform you that...
我们想要通知你。。。

18. I am convinced that...
我确信。。。

19. We agree with you on...
我们同意你在。。。

20. With effect from 4 Oct., 2008...
从2008年10月4日开始生效。。。

21. We will have a meeting scheduled as noted below...
我们将举行一个会议，时间表如下。

22. Be assured that individual statistics are not disclosed and this is for internal use only.
请确保个人信息不会外泄且只供内部使用。

23. I am delighted to tell you that...
我很高兴地告诉你。。。

24. We are pleased to learn that...
我们很高兴得知。。。

25. We wish to notify you that...
我们希望通知你。。。

26. Congratulation on your...
恭喜您关于。。。

27. I am fine with the proposal.
我对这份提桉没意见。

28.I am pleased to inform you that you have been accepted to join the workshop scheduled for 22-24 Nov,2008.
我很高兴地告诉你，你已经被同意参加2008年11月22-24日的研讨会。

29. We are sorry to inform you that...
我们很抱歉地通知你。。。

30. I’m afraid I have some bad news.
我恐怕要带来一些坏消息。

31. There are a number of issues with our new system.
我们的新系统有些问题。

32. Due to circumstances beyond our control...
由于情况超出我们所能控制。。。

33. I don’t feel too optimistic about...
我觉得不太乐观关于。。。

34. It would be difficult for us to accept...
我们很难接受。。。

35. Unfortunately I have to say that, since receiving your enquiries on the subject, our view has not changed.
很不幸地，我必须这么说，自从收到你关于这个主题的询问，我们的看法都没有改变。

36. We would be grateful if you could...
我们会很感激如果你可以。。。

37. I could appreciate it if you could...
我会很感激如果你可以。。。

38. Would you please send us…?
可否请你寄给我们…？

39. We need your help.
我们需要你的帮助。

40. We seek your assistance to cascade/reply this message to your staff.
我们请求你的帮助，将此信息传达给你们的员工。

41. We look forward to your clarification.
我们期待你的澄清。

42.Your prompt attention to this matter will be appreciated.
您能立即注意此事，我们将非常感激。

43. I would really appreciate meeting up if you can spare the time. Please let me know what suits you best.
如果您能抽出时间，我希望能与你见面，请让我知道您最适合的时间。

44.Please give us your preliminary thoughts about this.
请让我知道你对于这件事情初步的想法。

45. Would you please reply to this e-mail if you plan to attend?
请您回信如果您计划参加？

46.Please advise if you agree with this approach.
请告知是否你同意这个方法。

47. Could you please let me know the status of this project?
请让我知道这个计划的进度？

48. If possible, I hope to receive a copy of your proposal when it is finished.
如果可能，当你完成提桉，我希望能收到一份复本。

49. I would appreciate it very much if you would send me your reply by next Monday.
如果能在下周一前收到您的答复，我将非常感激。

50. Hope this is OK with you. If not, let me know by e-mail ASAP.
希望您对此没有问题，如果不行，请利用电子邮件尽快让我知道。

51. Could you please send me your replies to the above questions by the end of June?
请您在6月份前答复我上述问题好吗？

52. May I have your reply by April 1, if possible?
如果可能，我可否在4月1日前收到您的答复？

53. If you wish, we would be happy to...
如果你希望，我们很乐意。。。

54. Please let me know if there’s anything I can do to help.
请让我知道任何我可以帮得上忙的地方。

55.If there’s anything else I can do for you on/regarding this matter, please feel free to contact me at any time.
对于这件事，如果还有任何我能帮得上忙的地方，请不要客气，随时与我联络。

56.If you want additional recommendations on this, please let us know and we can try to see if this is possible.如果关于此事你需要额外的建议，请让我们知道，我们会尝试看看是否可能。

57. I’m just writing to remind you of...
我只是写信来提醒您。。。

58. May we remind you that...?
我们想要提醒您。。。

59. I am enclosing...
我附上。。。

60. Please find enclosed...
请查阅附件。。。

61. Attached hereto...
附件是关于。。。

62. Attached please find the most up-to-date information on/regarding/concerning…
附上关于某某的最新资料…

63. Attached please find the draft product plan for your review and comment.
附上产品计划书的草稿，请审查及评价。

64. If you have any further questions, please feel free to contact me.
如果你有任何问题，请不要客气与我联络。

65. I hope my clarification has been helpful.
希望我的说明是有帮助的。

66. Please feel free to call me at any time, I will continually provide full support.
请随时跟我联络，我会持续地提供全程支援。

67. Please let me know if this is suitable.
请让我知道这是否恰当。

68. Looking forward to seeing you soon.
期待很快能见到你。

69. We look forward to hearing from you soon.
我们期待很快能得到您的回复。

70. Hope this is clear and we are happy to discuss this further if necessary.
希望上述说明很清楚，如有必要，我们很乐意再进一步讨论。

71. I look forward to receiving your reply soon.
我期待很快能收到你的回复。

72. Looking forward to receiving your comments in due course.
期待在预期的时间收到你的反馈。

73. I’ll keep you posted.
我会与你保持联络。

74. Please keep me informed on the matter.
请随时让我知道这件事的发展。

75. For any comments/suggestions, please contact Nadia at 2552-7482.
任何评价或建议，请打电话2552-7482联络Nadia。

76. I would like to apologize for...
我想就。。。道歉。。。

77. I apologize for the delay in...
对于。。。的耽搁，我深感抱歉。

78. We are sorry for any inconvenience caused.
对于产生任何不便，我们感到抱歉。

79. I am sorry for any inconvenience this has caused you.
对于造成你的任何不便，我感到抱歉。

80. I’m sorry about last time.
关于上次的事我很抱歉。

81.We apologize for not replying you earlier.
对于未能早一点回信给你，我们感到抱歉。

82. I’m really sorry about this.
关于这件事，我真的很抱歉。

83. Sorry, I’m late in replying to your e-mail dated Monday, April 1.
抱歉，太迟回您在4月1日（星期一）发给我的邮件。

84. We apologize for the delay and hope that it doesn’t inconvenience you too much.
我们为耽搁道歉，希望不会给您带来太多的不便。

85.Hoping that this will not cause you too much trouble.
希望不会为您带来太多的麻烦。

86.Sorry if my voice message is not clear enough.
如果我的电话留言不够清楚,我深感抱歉.

87. Thank you for your help.
谢谢你的帮助。

88. I appreciate very much that you...
我非常感激你。。。

89. I truly appreciate it.
我真的很感激。

90. Thank you for your participation.
谢谢你的参加。

91. Thank you so much for inviting me.
非常感谢你要请我。

92.Congratulations to all of you and thanks for your efforts.
恭喜各位并谢谢各位的努力。

93. Your understanding and cooperation is greatly/highly appreciated.
很感激你的理解及合作。

94. Your prompt response will be most appreciated.
很感激你快速的答复。

95. Once again, thank you all for your commitment and support.
再一次感谢你的承诺及支持。

96. Thanks for your input/clarification/message.
谢谢你的投入/澄清/信息。
97. Any comments will be much appreciated.
对于您的任何建议，我将非常感激。

98. Thank you very much for everything you’ve done for me.
谢谢你为我做的一切。

99. I would appreciate your kindest understanding with/regarding this matter.
我很感激你对这件事情的理解。

100. Please convey my thanks to all the staff involved, they certainly did an excellent job.
请表达我的谢意给那些有关的同仁，他们真的干得很好


** 使用模板则函数声明与实现不要分离

main.cpp:(.text+0x4f)：对‘void bubble_sort<double>(double*, unsigned int)’未定义的引用
collect2: error: ld returned 1 exit status


** [[http://www.cnblogs.com/sooner/archive/2012/04/18/2455279.html][C++标准模板库函数sort那点小事]]

STL里面有个sort函数，可以直接对数组排序，复杂度为n*log2(n)。sort()定义在在头文件<algorithm>中。sort函数是标准模板库的函数，已知开始和结束的地址即可进行排序，可以用于比较任何容器（必须满足随机迭代器），任何元素，任何条件，执行速度一般比qsort要快。另外，sort()是类属函数，可以用于比较任何容器，任何元素，任何条件。具体事例如下：

#+BEGIN_EXAMPLE
    char ch[20]="sdasdacsdasdas";
    cout<<ch<<endl;
    sort(ch,ch+14);
    cout<<ch<<endl;
#+END_EXAMPLE

注意：缺省是升序排序。sort中一个改变排序顺序的例子如下（降序）：

#+BEGIN_EXAMPLE
    #include<iostream>
    #include<algorithm>
    using namespace std;
    bool cmp (const int a, const int b)
    {
        return a > b;
    }
    int main()
    {
        int data[5];
        for(int i = 0; i < 5; i++)
            cin >> data[i];
        sort(data, data + 5, cmp);
        return 0;
    }
#+END_EXAMPLE

 这个函数可以传两个参数或三个参数。第一个参数是要排序的区间首地址，第二个参数是区间尾地址的下一地址。也就是说，排序的区间是[a,b)。简单来说，有一个数组int a[100]，要对从a[0]到a[99]的元素进行排序，只要写sort(a,a+100)就行了，默认的排序方式是升序。如需要对数组t的第0到len-1的元素排序，就写sort(t,t+len);对向量v排序也差不多，sort(v.begin(),v.end());排序的数据类型不局限于整数，只要是定义了小于运算的类型都可以，比如字符串类string。
 如果是没有定义小于运算的数据类型，或者想改变排序的顺序，就要用到第三参数------比较函数。比较函数是一个自己定义的函数，返回值是bool型，它规定了什么样的关系才是“小于”。想把刚才的整数数组按降序排列，可以先定义一个比较函数cmp:

#+BEGIN_EXAMPLE
    bool cmp(int a,int b)
    {
        return a>b;
    }
#+END_EXAMPLE

排序的时候就写sort(a,a+100,cmp);

假设自己定义了一个结构体node:

#+BEGIN_EXAMPLE
    struct node{
        int a;
        int b;
        double c;
    };
#+END_EXAMPLE

有一个node类型的数组node arr[100]，想对它进行排序：先按a值升序排列，如果a值相同，再按b值降序排列，如果b还相同，就按c降序排列。就可以写这样一个比较函数：

以下是代码片段：

#+BEGIN_EXAMPLE
    bool cmp(node x,node y)
    {
         if(x.a!=y.a)  return x.a
         if(x.b!=y.b)  return x.b>y.b;
         return  return x.c>y.c;
    }
#+END_EXAMPLE

 排序时写sort(arr,a+100,cmp);

最后看一个完整的实例，一道题目“文件名排序 ”。
以下是代码片段：

#+BEGIN_EXAMPLE
    #include<iostream>
    #include<algorithm>
    #include<string>
    using namespace std;
    //定义一个结构体来表示文件，a代表文件名，b代表文件类型（要么"File"要么"Dir"）
    struct node{
       string a,b;
    };
    //ASCII码中，所有大写字母排在所有小写字母前面，'A'<'Z'<'a'<'z'
    //而这题要求忽略大小写，所以不能直接用字符串的比较。自定义了一个lt函数，就是less than的意思
    //先把两个字符串全部转化为小写，再比较大小（字典序）
    bool lt(string x,string y)
    {
       int i;
       for(i=0;i<x.length();i++)
          if(x[i]>='A'&&x[i]<='Z')
             x[i]='a'+(x[i]-'A');
       for(i=0;i<y.length();i++)
          if(y[i]>='A'&&y[i]<='Z')
             y[i]='a'+(y[i]-'A');
       return x<y;
    }
    //自定义的比较函数，先按b值升序排列（也就是"Dir"排在"File"前面）
    //如果b值相同，再按a升序排列，用的是刚才定义的lt函数
    bool comp(node x,node y)
    {
       if(x.b!=y.b) return x.b<y.b;
       return lt(x.a,y.a);
    }
    int main()
    {
       node arr[10001];
       int size=0;
       while(cin>>arr[size].a>>arr[size].b)
          size++;
       sort(arr,arr+size,comp);
       for(int i=0;i<size;i++)
          cout<<arr[i].a<<" "<<arr[i].b<<endl;
       return 0;
    }
#+END_EXAMPLE

** [[http://blog.sina.com.cn/s/blog_6f26189101012111.html][C++中如何使函数返回数组]]


在C++中，数组不是一种类型，因此不能被直接返回。一般有两种方法来返回一个数组。

1. 返回一个指向数组的指针

 #include<iostream>
 using namespace std;

int* Array()
 {
  int *a;
  a=new int [10];

 for(int i=0;i<10;i++)
  {
  a[i]=i+1;
   cout<<a[i]<<" ";
  }
  cout<<endl;
  return a;
 }

void main()
 {
  int *b;
  b=Array();

  for(int i=0;i<10;i++)
  cout<<b[i]<<" ";
   cout<<endl;
 }

2.
返回一个结构的形式。这种形式相对较安全，可以避免忘记释放指针而造成内存泄露，也可以避免访问悬挂指针造成的错误。但缺点是由于结构是先拷贝再返回，因此如果结构较大时，会影响效率和占用较大内存。

 #include<iostream>
 using namespace std;
 class tag
 {
   public:
  int a[10];
 }X;

class tag Array()
 {
  for(int i=0;i<10;i++)
  {
  X.a[i]=i+1;
   cout<<X.a[i]<<" ";
  }
  cout<<endl;
  return X;
 }

void main()
 {
  class tag Y=Array();
  for(int i=0;i<10;i++)
  {
   cout<<Y.a[i]<<" ";
  }
   cout<<endl;
 }



** [[http://www.cnblogs.com/yangxi/archive/2011/09/18/2180759.html][怎样让函数返回数组]]

这个问题属于非常初级的问题，但是对于初学不知道的人可能会比较头疼。C++中函数是不能直接返回一个数组的，但是数组其实就是指针，所以可以让函数返回指针来实现。比如一个矩阵相乘的函数，很容易地我们就写成：

#+BEGIN_EXAMPLE
     1 #include <iostream> 2  3 using namespace std; 4  5 float* MultMatrix(float A[4], float B[4]) 6 { 7     float M[4]; 8     M[0] = A[0]*B[0] + A[1]*B[2]; 9     M[1] = A[0]*B[1] + A[1]*B[3];10     M[2] = A[2]*B[0] + A[3]*B[2];11     M[3] = A[2]*B[1] + A[3]*B[3];12 13     return M;14 }15 16 int main()17 {18     float A[4] = { 1.75, 0.66, 0, 1.75 };19     float B[4] = {1, 1, 0, 0};20     float *M = MultMatrix(A, B);21     cout << M[0] << " " << M[1] << endl;22     cout << M[2] << " " << M[3] << endl;23 24     return 0;25 }
#+END_EXAMPLE

但是运行后发现结果是：1.75 1.75
  6.51468e-039 3.76489e-039

根本不是想要的结果。于是我们在函数中也加上显示代码，看看是不是计算的问题，得到结果：

1.75 1.75
0 0
1.75 1.75
1.96875 1.75

发现计算的结果是正确的，但返回后就变了，而且跟上次的结果不一样。这是为什么呢？

因为在函数中定义的数组M在函数执行完后已经被系统释放掉了，所以在调用函数中得到的结果当然不是计算后的结果。有一个解决办法就是动态分配内存，在函数中new一个数组，这样就不会被释放掉了。

于是就应该将

7 　　 float M[4];

改为：

7　　float *M = new float[4];

修改运行后得到结果：

1.75 1.75
0 0
1.75 1.75
0 0

正确。但是我们这样并没有将自己申请的空间释放掉，如果我们在函数内释放的话结果就会跟开始时的一样了。

看看我们的调用代码：

20 　　 float *M = MultMatrix(A, B);

这样其实是将M指针指向了函数中M数组的首地址，我们可以将M指针释放，效果和释放申请的M数组是一样的，因为它们指向的是同一片内存空间。于是代码就修改为：

#+BEGIN_EXAMPLE
     1 #include <iostream> 2  3 using namespace std; 4  5 float* MultMatrix(float A[4], float B[4]) 6 { 7     float *M = new float[4]; 8     M[0] = A[0]*B[0] + A[1]*B[2]; 9     M[1] = A[0]*B[1] + A[1]*B[3];10     M[2] = A[2]*B[0] + A[3]*B[2];11     M[3] = A[2]*B[1] + A[3]*B[3];12     cout << M[0] << " " << M[1] << endl;13     cout << M[2] << " " << M[3] << endl;14 15     return M;16 }17 18 int main()19 {20     float A[4] = { 1.75, 0.66, 0, 1.75 };21     float B[4] = {1, 1, 0, 0};22     float *M = MultMatrix(A, B);23     cout << M[0] << " " << M[1] << endl;24     cout << M[2] << " " << M[3] << endl;25     delete[] M;26 27     return 0;28 }
#+END_EXAMPLE

运行结果：

1.75 1.75
0 0
1.75 1.75
0 0
没有问题，new的空间也delete掉了。

鉴于下面大牛们的建议，我将程序修改如下，大家看可否：

#+BEGIN_EXAMPLE
     1 #include <iostream> 2  3 using namespace std; 4  5 void MultMatrix(float M[4], float A[4], float B[4]) 6 { 7     M[0] = A[0]*B[0] + A[1]*B[2]; 8     M[1] = A[0]*B[1] + A[1]*B[3]; 9     M[2] = A[2]*B[0] + A[3]*B[2];10     M[3] = A[2]*B[1] + A[3]*B[3];11 12     cout << M[0] << " " << M[1] << endl;13     cout << M[2] << " " << M[3] << endl;14 }15 16 int main()17 {18     float A[4] = { 1.75, 0.66, 0, 1.75 };19     float B[4] = {1, 1, 0, 0};20 21     float *M = new float[4];22     MultMatrix(M, A, B);23 24     cout << M[0] << " " << M[1] << endl;25     cout << M[2] << " " << M[3] << endl;26     delete[] M;27 28     return 0;29 }
#+END_EXAMPLE

至于数组类和智能智能我还需要继续学习，多谢大家关注！

** [[http://www.cnblogs.com/gw811/archive/2012/10/25/2738929.html][C++ 模板详解（一）]]


模板是C++支持*参数化*多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。

模板是一种对*类型*进行*参数化*的工具；

通常有两种形式：*函数模板*和*类模板*；

函数模板针对仅*参数类型*不同的*函数*；

类模板针对仅*数据成员*和*成员函数类型*不同的类。

*使用模板的目的就是能够让程序员编写与类型无关的代码。*比如编写了一个交换两个整型int
类型的swap函数，这个函数就只能实现*int*
型，对*double*，字符这些类型无法实现，要实现这些类型的交换就要重新编写另一个*swap*函数。使用模板的目的就是要让这程序的实现与类型无关，比如一个*swap*模板函数，即可以实现*int*
型，又可以实现double型的交换。模板可以应用于函数和类。下面分别介绍。

*注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。*



***  一、函数模板通式

--------------

*1、函数模板的格式：*

*template <class 形参名，class 形参名，......> 返回类型
函数名(参数列表)*

*　　　{*

*　　　　　　函数体*

*　　　}*

其中*template*和*class*是关见字，*class*可以用*typename*
关见字代替，在这里*typename
和class没区别*，<>括号中的参数叫*模板形参*，模板形参和函数形参很相像，*模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。*模板形参需要调用该模板函数时提供的模板实参来初始化模板形参，一旦编译器确定了实际的模板实参类型就称他实例化了函数模板的一个实例。比如*swap*的模板函数形式为

*template <class T> void swap(T& a, T& b){}，*

当调用这样的模板函数时类型T就会被被调用时的类型所代替，比如*swap(a,b)*其中*a*和*b*是*int*
型，这时模板函数swap中的形参*T*就会被*int*
所代替，模板函数就变为*swap(int &a, int
&b)*。而当*swap(c,d)*其中*c*和*d*是*double*类型时，模板函数会被替换为*swap(double
&a, double &b)*，这样就实现了函数的实现与类型无关的代码。

2、注意：对于函数模板而言不存在 *h(int,int)*
这样的调用，*不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行*，即只能进行
*h(2,3)* 这样的调用，或者*int a, b; h(a,b)*。

*函数模板的示例演示将在下文中涉及！*

*** 二、类模板通式

--------------

1、类模板的格式为：

*　　　　template<class  形参名，class 形参名，...>  class 类名*

*　　　　{ ... };*

类模板和函数模板都是以*template*开始后接模板形参列表组成，模板形参不能为空，*一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。*比如

*template<class T> class A{public: T a; T b; T hy(T c, T &d);};*

在类*A*中声明了两个类型为*T*的成员变量*a*和*b*，还声明了一个返回类型为*T*带两个参数类型为*T*的函数*hy*。

2、类模板对象的创建：比如一个模板类*A*，则使用类模板创建对象的方法为*A<int>
m;*在类*A*后面跟上一个*<>*尖括号并在里面填上相应的类型，这样的话类*A*中凡是用到模板形参的地方都会被*int*
所代替。当类模板有两个模板形参时创建对象的方法为*A<int, double>
m;*类型之间用逗号隔开。

3、对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如*A<2>
m;*用这种方法把模板形参设置为*int*是错误的（*编译错误：error C2079: 'a'
uses undefined class
'A<int>'*），*类模板形参不存在实参推演的问题。*也就是说不能把整型值*2*推演为*int*
型传递给模板形参。要把类模板形参调置为*int* 型必须这样指定*A<int> m*。

4、在类模板外部定义成员函数的方法为：

*template<模板形参列表> 函数返回类型
类名<模板形参名>::函数名(参数列表){函数体}，*

比如有两个模板形参*T1*，*T2*的类*A*中含有一个*void
h()*函数，则定义该函数的语法为：

*　template<class T1,class T2> void A<T1,T2>::h(){}。*

注意：当在类外面定义类的成员时*template*后面的模板形参应与要定义的类的模板形参一致。

5、再次提醒注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在*main*函数中声明或定义一个模板。



*** 三、模板的形参

--------------

*有三种类型的模板形参：类型形参，非类型形参和模板形参。*

**** 　　1、类型形参

1.1
、类型模板形参：*类型形参由关见字class或typename后接说明符构成*，如*template<class
T> void h(T
a){}*;其中*T*就是一个类型形参，类型形参的名字由用户自已确定。*模板形参表示的是一个未知的类型*。模板类型形参可作为类型说明符用在模板中的任何地方，与内置类型说明符或类类型说明符的使用方式完全相同，即可以用于指定返回类型，变量声明等。

*作者原版：1.2、*
不能为同一个模板类型形参指定两种不同的类型，比如*template<class T>void
h(T a, T b){}，*语句调用*h(2,
3.2)*将出错，因为该语句给同一模板形参*T*指定了两种类型，第一个实参*2*把模板形参T指定为*int*，而第二个实参*3.2*把模板形参指定为*double*，两种类型的形参不一致，会出错。*（针对函数模板）*

作者原版：1.2针对函数模板是正确的，但是忽略了类模板。下面将对类模板的情况进行补充。

*本人添加1.2补充版（针对于类模板）、*当我们声明类对象为：*A<int>
a*，比如*template<class T>T g(T a, T b){}*，语句调用*a.g(2,
3.2)*在编译时不会出错，但会有警告，因为在声明类对象的时候已经将*T*转换为*int*类型，而第二个实参*3.2*把模板形参指定为*double*，在运行时，会对*3.2*进行强制类型转换为*3*。当我们声明类的对象为：*A<double>
a*,此时就不会有上述的警告，因为从*int*到*double*是自动类型转换。

*演示示例１：*

*　　TemplateDemo.h*

#+BEGIN_EXAMPLE
     1 #ifndef TEMPLATE_DEMO_HXX
     2 #define TEMPLATE_DEMO_HXX
     3
     4 template<class T> class A{
     5     public:
     6         T g(T a,T b);
     7         A();
     8 };
     9
    10 #endif
#+END_EXAMPLE

*　　TemplateDemo.cpp*

#+BEGIN_EXAMPLE
     1 #include<iostream.h>
     2 #include "TemplateDemo.h"
     3
     4 template<class T> A<T>::A(){}
     5
     6 template<class T> T A<T>::g(T a,T b){
     7     return a+b;
     8 }
     9
    10 void main(){
    11     A<int> a;
    12     cout<<a.g(2,3.2)<<endl;
    13 }
#+END_EXAMPLE

*　　编译结果：*

#+BEGIN_EXAMPLE
    1 --------------------Configuration: TemplateDemo - Win32 Debug--------------------
    2 Compiling...
    3 TemplateDemo.cpp
    4 G:\C++\CDaima\TemplateDemo\TemplateDemo.cpp(12) : warning C4244: 'argument' : conversion from 'const double' to 'int', possible loss of data
    5
    6 TemplateDemo.obj - 0 error(s), 1 warning(s)
#+END_EXAMPLE

*运行结果：　　　　　　5　　*

我们从上面的测试示例中可以看出，并非作者原作中的那么严密！此处仅是本人跟人测试结果！请大家本着实事求是的态度，自行验证！



**** 　　2、非类型形参

2.1
、非类型模板形参：*模板的非类型形参也就是内置类型形参*，如*template<class
T, int a> class B{};*其中*int a*就是非类型的模板形参。

2.2、
非类型形参在模板定义的内部是常量值，也就是说非类型形参在模板的内部是常量。

*2.3、
非类型*模板*的形参只能是整型，指针和引用，像double，String, String
**这样的类型是不允许的。*但是*double &，double
*，*对象的引用或指针是正确的。

2.4、
*调用非类型模板形参的实参必须是一个常量表达式*，即他必须能在编译时计算出结果。

2.5
、注意：*任何局部对象，局部变量，局部对象的地址，局部变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参*。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能用作非类型模板形参的实参。

2.6、
*全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参*。

2.7
、*sizeof*表达式的结果是一个常量表达式，也能用作非类型模板形参的实参。

2.8
、当模板的形参是整型时调用该模板时的实参必须是整型的，且在编译期间是常量，比如*template
<class T, int a> class A{};*如果有*int b，这时A<int, b>
m;*将出错，因为*b*不是常量，如果*const int b，这时A<int, b>
m*;就是正确的，因为这时*b*是常量。

*2.9
、非类型形参一般不应用于函数模板中*，比如有函数模板*template<class T,
int a> void h(T
b){}*，若使用*h(2)*调用会出现无法为非类型形参a推演出参数的错误，对这种模板函数可以用显示模板实参来解决，如用h<int,
3>(2)这样就把非类型形参a设置为整数3。显示模板实参在后面介绍。

2.10、 非类型模板形参的形参和实参间所允许的转换
*　　　　　　1、允许从数组到指针，从函数到指针的转换。如：template <int
*a> class A{}; int b[1]; A<b> m;即数组到指针的转换*
*　　　　　　2、const修饰符的转换。如：template<const int *a> class A{};
int b; A<&b> m;  即从int *到const int *的转换。*
*　　　　　　3、提升转换。如：template<int a> class A{}; const short
b=2; A<b> m; 即从short到int 的提升转换*
*　　　　　　4、整值转换。如：template<unsigned int a> class A{};  A<3>
m; 即从int 到unsigned int的转换。*
*　　　　　　5、常规转换。*

*非类型形参演示示例1：*

*由用户自己亲自指定栈的大小，并实现栈的相关操作。*

*　　TemplateDemo.h*

#+BEGIN_EXAMPLE
     1 #ifndef TEMPLATE_DEMO_HXX
     2 #define TEMPLATE_DEMO_HXX
     3
     4 template<class T,int MAXSIZE> class Stack{//MAXSIZE由用户创建对象时自行设置
     5     private:
     6         T elems[MAXSIZE];    // 包含元素的数组
     7         int numElems;    // 元素的当前总个数
     8     public:
     9         Stack();    //构造函数
    10         void push(T const&);    //压入元素
    11         void pop();        //弹出元素
    12         T top() const;    //返回栈顶元素
    13         bool empty() const{     // 返回栈是否为空
    14             return numElems == 0;
    15         }
    16         bool full() const{    // 返回栈是否已满
    17             return numElems == MAXSIZE;
    18         }
    19 };
    20
    21 template <class T,int MAXSIZE>
    22 Stack<T,MAXSIZE>::Stack():numElems(0){     // 初始时栈不含元素
    23     // 不做任何事情
    24 }
    25
    26 template <class T,int MAXSIZE>
    27 void Stack<T, MAXSIZE>::push(T const& elem){
    28     if(numElems == MAXSIZE){
    29         throw std::out_of_range("Stack<>::push(): stack is full");
    30     }
    31     elems[numElems] = elem;   // 附加元素
    32     ++numElems;               // 增加元素的个数
    33 }
    34
    35 template<class T,int MAXSIZE>
    36 void Stack<T,MAXSIZE>::pop(){
    37     if (numElems <= 0) {
    38         throw std::out_of_range("Stack<>::pop(): empty stack");
    39     }
    40     --numElems;               // 减少元素的个数
    41 }
    42
    43 template <class T,int MAXSIZE>
    44 T Stack<T,MAXSIZE>::top()const{
    45     if (numElems <= 0) {
    46         throw std::out_of_range("Stack<>::top(): empty stack");
    47     }
    48     return elems[numElems-1];  // 返回最后一个元素
    49 }
    50
    51 #endif
#+END_EXAMPLE

*　　TemplateDemo.cpp*

#+BEGIN_EXAMPLE
     1 #include<iostream.h>
     2 #include <iostream>
     3 #include <string>
     4 #include <cstdlib>
     5 #include "TemplateDemo.h"
     6
     7 int main(){
     8     try {
     9         Stack<int,20>  int20Stack;  // 可以存储20个int元素的栈
    10         Stack<int,40>  int40Stack;  // 可以存储40个int元素的栈
    11         Stack<std::string,40> stringStack; // 可存储40个string元素的栈
    12
    13         // 使用可存储20个int元素的栈
    14         int20Stack.push(7);
    15         std::cout << int20Stack.top() << std::endl;    //7
    16         int20Stack.pop();
    17
    18         // 使用可存储40个string的栈
    19         stringStack.push("hello");
    20         std::cout << stringStack.top() << std::endl;    //hello
    21         stringStack.pop();
    22         stringStack.pop();    //Exception: Stack<>::pop<>: empty stack
    23         return 0;
    24     }
    25     catch (std::exception const& ex) {
    26         std::cerr << "Exception: " << ex.what() << std::endl;
    27         return EXIT_FAILURE;  // 退出程序且有ERROR标记
    28     }
    29 }
#+END_EXAMPLE

*　　运行结果：*

[[http://pic002.cnblogs.com/images/2012/416402/2012102509100898.jpg]]

 *非类型形参演示示例2：*

*　　TemplateDemo01.h*

#+BEGIN_EXAMPLE
     1 #ifndef TEMPLATE_DEMO_O1
     2 #define TEMPLATE_DEMO_01
     3
     4 template<typename T> class CompareDemo{
     5     public:
     6         int compare(const T&, const T&);
     7 };
     8
     9 template<typename T>
    10 int CompareDemo<T>::compare(const T& a,const T& b){
    11     if((a-b)>0)
    12         return 1;
    13     else if((a-b)<0)
    14         return -1;
    15     else
    16         return 0;
    17 }
    18
    19 #endif
#+END_EXAMPLE

*　　TemplateDemo01.cpp*

#+BEGIN_EXAMPLE
    1 #include<iostream.h>
    2 #include "TemplateDemo01.h"
    3
    4 void main(){
    5     CompareDemo<int> cd;
    6     cout<<cd.compare(2,3)<<endl;
    7 }
#+END_EXAMPLE

*　　运行结果：　　　　　-1　*

#+BEGIN_EXAMPLE
    1 #include<iostream.h>
    2 #include "TemplateDemo01.h"
    3
    4 void main(){
    5     CompareDemo<double> cd;
    6     cout<<cd.compare(3.2,3.1)<<endl;
    7 }
#+END_EXAMPLE

*　运行结果：　　　　　　1　　*

*TemplateDemo01.h* *改动如下：*

#+BEGIN_EXAMPLE
     1 #ifndef TEMPLATE_DEMO_O1
     2 #define TEMPLATE_DEMO_01
     3
     4 template<typename T> class CompareDemo{
     5     public:
     6         int compare(T&, T&);
     7 };
     8
     9 template<typename T>
    10 int CompareDemo<T>::compare(T& a,T& b){
    11     if((a-b)>0)
    12         return 1;
    13     else if((a-b)<0)
    14         return -1;
    15     else
    16         return 0;
    17 }
    18
    19 #endif
#+END_EXAMPLE

*　　TempalteDemo01.cpp*

#+BEGIN_EXAMPLE
    1 #include<iostream.h>
    2 #include "TemplateDemo01.h"
    3
    4 void main(){
    5     CompareDemo<int> cd;
    6     int a=2,b=3;
    7     cout<<cd.compare(a,b)<<endl;
    8 }
#+END_EXAMPLE



 *非类型形参演示示例3：*

*　　TemplateDemo02.cpp*

#+BEGIN_EXAMPLE
     1 #include<iostream.h>
     2
     3 template<typename T>
     4 const T& max(const T& a,const T& b){
     5     return a>b ? a:b;
     6 }
     7
     8 void main(){
     9     cout<<max(2.1,2.2)<<endl;//模板实参被隐式推演成double
    10     cout<<max<double>(2.1,2.2)<<endl;//显示指定模板参数。
    11     cout<<max<int>(2.1,2.2)<<endl;//显示指定的模板参数，会将函数函数直接转换为int。
    12 }
#+END_EXAMPLE

*　　运行结果：*

[[http://pic002.cnblogs.com/images/2012/416402/2012102515230328.jpg]]

#+BEGIN_EXAMPLE
    cout<<max<int>(2.1,2.2)<<endl;//显示指定的模板参数，会将函数函数直接转换为int。此语句会出现警告：
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    1 --------------------Configuration: TemplateDemo02 - Win32 Debug--------------------
    2 Compiling...
    3 TemplateDemo02.cpp
    4 G:\C++\CDaima\TemplateDemo02\TemplateDemo02.cpp(11) : 　　warning C4244: 'argument' : conversion from 'const double' to 'const int', possible loss of data
    5 G:\C++\CDaima\TemplateDemo02\TemplateDemo02.cpp(11) : 　　warning C4244: 'argument' : conversion from 'const double' to 'const int', possible loss of data
    6
    7 TemplateDemo02.obj - 0 error(s), 2 warning(s)
#+END_EXAMPLE


** [[http://www.cnblogs.com/li-hao/archive/2013/02/27/2935100.html][size_t类型]]

size
_t 为了增强程序的可移植性，便有了size_t ，不同系统上，定义size_t可能不一样。

经测试发现，在32位系统中size_t是4字节的，在64位系统中，size_t是8字节的，这样利用该类型可以增加程序移植性。

*size_t的定义 *

它的定义在/usr/include/linux/types.h

  *typedef _kernel_size_t size_t;*



*跟体系结构相关 *

而__kernel_size_t 定义在 /usr/include/asm/posix_types.h

安装的是内核的源码

*asm-i386/posix_types.h*

 *typedef unsigned int __kernel_size_t;*

*asm-1a64/posix_types.h*

*typedef unsigned long kernel_size_t;*



size_t一般用来表示一种计数，比如有多少东西被拷贝等。例如：sizeof操作符的结果类型是size_t，该类型保证能容纳实现所建立的最大对象的字节大小。
它的意义大致是“适于计量内存中可容纳的数据项目个数的无符号整数类型”。所以，它在数组下标和内存管理函数之类的地方广泛使用。


** [[http://www.cnblogs.com/cxrs/archive/2010/07/21/1782007.html][用户态和核心态]]

 用户态：Ring3运行于用户态的代码则要受到处理器的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段（TSS）中I/O许可位图（I/O
Permission Bitmap）中规定的可访问端口进行直接访问。

  核心态：Ring0
在处理器的存储保护中，核心态，或者特权态（与之相对应的是用户态），是操作系统内核所运行的模式。运行在该模式的代码，可以无限制地对系统存储、外部设备进行访问。



用户态切换到内核态的3种方式

1) 系统调用 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int
80h中断。

2)
异常 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

3)
外围设备的中断 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

具体的切换步骤：

  [1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。

  [2]
使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个

过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一

条指令。

  [3]
将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始

执行中断处理程序，这时就转到了内核态的程序执行了。

  从用户态切换到核心态，要耗掉>100 cycle的CPU时钟

** [[http://my.oschina.net/liubin/blog/27795?fromerr=tiisuVGO][用户态和内核态的概念区别]]


*究竟什么是用户态，什么是内核态，这两个基本概念以前一直理解得不是很清楚，根本原因个人觉得是在于因为大部分时候我们在写程序时关注的重点和着眼的角度放在了实现的功能和代码的逻辑性上，先看一个例子：*

*1）例子*

*C代码* **

*1. * *void testfork(){ * **

*2. * *if(0 = = fork()){ * **

*3. * *printf(“create new process success!\n”); * **

*4. * *} * **

*5. * *printf(“testfork ok\n”); * **

*6. * *} *

*void testfork(){*

*if(0 = = fork()){*

*printf(“create new process success!\n”);*

*}*

*printf(“testfork ok\n”);*

*}*

*这段代码很简单，从功能的角度来看，就是实际执行了一个fork()，生成一个新的进程，从逻辑的角度看，就是判断了如果fork()返回的是则打印相关语句，然后函数最后再打印一句表示执行完整个testfork()函数。代码的执行逻辑和功能上看就是如此简单，一共四行代码，从上到下一句一句执行而已，完全看不出来哪里有体现出用户态和进程态的概念。*

*如果说前面两种是静态观察的角度看的话，我们还可以从动态的角度来看这段代码，即它被转换成CPU执行的指令后加载执行的过程，这时这段程序就是一个动态执行的指令序列。而究竟加载了哪些代码，如何加载就是和操作系统密切相关了。*

*2）特权级*

*熟悉Unix/Linux系统的人都知道，fork的工作实际上是以系统调用的方式完成相应功能的，具体的工作是由sys_fork负责实施。其实无论是不是Unix或者Linux，对于任何操作系统来说，创建一个新的进程都是属于核心功能，因为它要做很多底层细致地工作，消耗系统的物理资源，比如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录页表等等，这些显然不能随便让哪个程序就能去做，于是就自然引出特权级别的概念，显然，最关键性的权力必须由高特权级的程序来执行，这样才可以做到集中管理，减少有限资源的访问和使用冲突。*

*特权级显然是非常有效的管理和控制程序执行的手段，因此在硬件上对特权级做了很多支持，就Intel
x86架构的CPU来说一共有0~3四个特权级，级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查，相关的概念有*
*CPL、DPL和RPL，这里不再过多阐述。硬件已经提供了一套特权级使用的相关机制，软件自然就是好好利用的问题，这属于操作系统要做的事情，对于*
*Unix/Linux来说，只使用了级特权级和3级特权级。也就是说在Unix/Linux系统中，一条工作在级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力。*

*3）用户态和内核态*

*现在我们从特权级的调度来理解用户态和内核态就比较好理解了，当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在级特权级上时，就可以称之为运行在内核态。*

*虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，比如上面例子中的testfork()就不能直接调用*
*sys_fork()，因为前者是工作在用户态，属于用户态程序，而sys_fork()是工作在内核态，属于内核态程序。*

*当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，比如testfork()最初运行在用户态进程下，当它调用fork()最终触发*
*sys_fork()的执行时，就切换到了内核态。*

*2.* *用户态和内核态的转换*

*1）用户态切换到内核态的3种方式*

*a.* *系统调用*

*这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int
80h中断。*

*b.* *异常 *

*当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。*

*c.* *外围设备的中断*

*当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。*

*这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。*

*2）具体的切换操作*

*从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：*

*[1]* *从当前进程的描述符中提取其内核栈的ss0及esp0信息。*

*[2]*
*使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个*

*过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一*

*条指令。*

*[3]*
*将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始*

*执行中断处理程序，这时就转到了内核态的程序执行了。*

** [[http://blog.csdn.net/bbs598598/article/details/7746047][与vxWorks相比，Linux究竟有那些优势？]]


     2001年IBM大张旗鼓的宣布支持Linux，并投入10亿美金用于Linux相关开发。

【陈怀临注：是的，没有IBM Linux Research
Center的R&D投入，Linux在服务器市场方面的发展绝无今日之局面】*

  最近的Cisco抛弃了其专有的IOS核心，在
ASR1000的控制平面软件上采用了Linux为基础平台。【*陈怀临注：思科在OS方面目前比较乱了。是的，IOS确实没有能力支持其将来的发展。有兴趣的读者也可参阅弯曲评论相关文章，如“思科的OS战略是用三个OS逐步取代IOS。IOS
XR用于核心路由器（Core Router），IOS
XE用于边缘路由器，NX-OS用于数据中心的网络交换机。三个都是模块化的OS，IOS
XE和NX-OS基于Linux内核（目前Linux的代码质量已经全面超过BSD，JUNOS
1996年起步时Linux还不成熟，如果Juniper现在起步，大概也会选择Linux），IOS
XR基于一个兼容POSIX的微内核（Microkernel），
名叫QNX。IOS的各个功能模块被移植到这些新的OS，作为单独的进程运行于内核之上。”---《[[http://www.tektalk.org/?p=2377][思科和Juniper的操作系统之争：一个还是多个？]]》*】据传Huawei、H3C等厂商的软件平台也纷纷转向以Linux为基础，而以前他们都采用
vxWorks作为基础。【*陈怀临注：我个人对华为在这方面的判断力，特别是决断力略表失望。要加快步伐。这与决策者的知识面和视野的局限性有关系。*】几年前，就连vxWorks的开发者风河公司也宣布同时支持vxWorks和Linux【*陈怀临注：风河：WindRiver
Inc.
目前，WindRiver在Linux方面力挺其收购的RTLinux/FSMLab技术方案。相关信息可参阅笔者的[[http://www.tektalk.org/?p=4105][陈怀临时间]]--[[http://www.tektalk.org/?p=3026][RTLinux/RTCore体系结构]]*】。由此看来，Linux在网络设备领域取
代vxWorks几乎已成定局。这背后的原因究竟是什么？与vxWorks相比，Linux究竟有那些优势？

在我看来，IBM支持Linux，是为了借Linux来挽救其规模庞大的服务器产品线，借助Linux拓展其软件服务市场。（注1）

【*陈怀临注：是的，IBM不可能是因为，或单纯的因为GNU的道德精神，而投入大把的美金来支持。其主要原因是：扶持Linux，抗衡微软及其联盟。*】

*而网络设备上用Linux，并不在于Linux的技术有多先进，而是Linux所代表的产业链的发展速度超过了vxWorks，用Linux会使软件开发成本更低。*

【*陈怀临注：是的，大量的第三方应用软件，大量的社区人员是Linux生命力和自由软件精神永存的基础。严格来讲，不参考Open
Source
源码的工程师不存在。如果有，他要么是什么都不懂，或者其实从来不写程序*。】

Linux和vxWorks在技术上的主要差异在于：A、Linux的核心和用户进程之间是的地址空间隔离的，【*陈怀临注：这里指System
Call
Interfac.用户态与核心态的分离。*】每个用户进程之间的地址空间是隔离的，当某一个用户进程崩溃的时候，不会影响操作系统核心和其他用户进程正常运行【*陈怀临注：这里指每个用户进程拥有其自己的4G逻辑地址空间，共享1G的核心空间，3G的用户态地址空间。*】。B、Linux支持页面级的内存管理，支持换页【*陈怀临注：这里指Page
on Demand, Copy on
Write等Linux内存管理机制。当然，页面PageFault机制带来的效率开销有时也是嵌入式系统所不希望的。所以对一个Linux系统的从新开发和裁剪是很重要的。避开Linux的缺点，最大化的利用Linux的优点。*】。C、由于隔离的原因，使得Linux软件的各部分之间耦合性更小，Linux的应用程序跟核心之间有清晰的界面，POSIX
API。总而言之，Linux充分利用了现代微处理器的MMU硬件，而vxWorks则采用平面地址空间（注2）。在某些高端设备上Linux的保护模式
的确可以让系统更稳定，至少更容易找Bug。这个特点也是也是长期依赖Juniper赖以攻击Cisco
IOS的主要论据，因为Juniper的JunOS是基于freebsd的，也具有同样的特点，而Cisco的IOS核心与vxWorks类似（注3）。

Linux除了具有上述技术优势之外，其实也还有很多缺点，如：（a）Linux的网络协议栈是针对主机优化的，
对于低端路由器这类设备，运行效率不高。(b)
Linux的软件镜像较大，占用flash和内存空间大，对甚低端设备来说，成本高。（c）就总体运行效率而言，Linux比vxWorks
差，Linux系统调用开销大，Linux的动态连接库调用的开销也大，在某些硬件上Linux的进程间切换的开销也大等等。【*陈怀临注：Linux作为控制平面应该是不错的，System
Call的开销不应该是考量。*】

我认为，Linux相对于vxWorks的技术优势是微不足道的。【*陈怀临注：技术优势会变得significant。越来越多的人参与这个社区，她一定会强大。她的后面是一种人文精神团结的数千，数万人，而vxworks后面是最多2，3百人的研发队伍。Eric
Raymond的经典文章《[[http://www.aka.org.cn/Docs/c&b.html][大教堂和市集]]》的问世，基本上奠定了Open
Source开发一定超过商业开发的理论基础。*】导致网络设备厂商转向Linux的主要原因是
Linux代表产业链越来越成熟，用Linux的开发成本将远低于vxWorks。主要表现在：（a）支持Linux的软件越来越越多，而支持
vxWorks的软件越来越少，Linux下面有很多开源软件，而这些开源软件多半不支持vxWorks。现在用于网络设备的商业软件几乎都支持
Linux，如：Gated、Zebos、Trillium、InterPeek的协议栈等。（b）几乎所有的芯片都提供Linux驱动程序，几乎所有的CPU、评估板都提供Linux支持。【*陈怀临注：这一点异常重要。Driver上来就是Linux
版本的。这也是Linux
Prevail重要原因之一。一个非常好的正反馈生态环境了*】（c）熟悉Linux的开发人员更好找。与Linux相比，vxWorks则越来越显得曲高和寡，其生存环境也越来越差。【*陈怀临注：vxworks其实曲也不高，也没什么人和。当年NASA就应该将其彻底废掉。Mars
Path Finder的Priority Inversion的事故犹如昨天。*】

对于网络设备来说，选择哪种操作系统软件并不是决定成败的关键因素，操作系统只提供了一些如任务调度、任务间通
信、中断管理、内存管理等基本功能。*在一个路由器中，操作系统软件占总代码量的5-20%，而且无论选择那种操作系统，这部分代码都是相对稳定的，不需要作太多修改和维护。但是如果操作系统选择不当，却可能增加很多开发成本。*例如：如果你选择的CPU不被vxWorks支持，那么就必须自己开发其CPU支
持代码和BSP（注4）。如果某个以太网芯片没有vxWorks的驱动程序，那么你也不得不开发vxWorks的驱动程序。最让人无法忍受的事情是，现在用过vxWorks的人越来越少，会Linux编程的人越来越多，并且很多人非常熟练。【*陈怀临注：非常好的观点。在网络设备中，经典操作系统通常承担基本的功能，而且许多模块有可能被改写，如协议栈，内存管理系统等。也包括调度系统。*】

如果说IBM选择Linux还带有一定的冒险成分的话，那么现在Cisco、H3C、Huawei等选择Linux，更多是无奈之举。【*陈怀临注：也是明智之举。我就不明白某个公司花了好几年的时间还折腾不清楚GPL
Lincese的事情。让人哭笑不得。*】

注1：
当时的Linux已经在互联网行业得到了广泛应用，像FTP、Web这类服务器程序在Linux上运行已经没有任何问题，并且有Sybyse、
Oracle、Infomix等一批商业数据库有Linux版本。有一大批刚刚从学校毕业不久的年轻技术人员熟悉Linux，Linux各种技术资料在互
联网随处可得，讨论Linux论坛网站也层出不穷，Linux在服务器市场的份额快速增长。虽然IBM的AIX在技术上暂时领先（这一点也许有人不同意，
但我认为在2001年左右的时候，Linux在技术上还远远赶不上AIX、Solaris等商业Unix。也许这个问题可以专门作为一个话题展开讨
论。），并且有良好的商业化支持，而且在金融等传统企业市场占有率暂时领先与Linux，但是其活力和前景却远远落后于Linux。对IBM来说，AIX
软件销售并不是其主要收入来源，IBM主要业务是软件服务、服务器硬件的研发和销售。在这种情况下，IBM押宝Linux，不失为明智的选择。当大批信仰
Linux的年轻技术人员逐渐掌握了决策权的时候，他们会在采购中更倾向Linux，这是他们会发现，这些产品中很多都是IBM的。【*陈怀临注：在Web
2.0系统中，大量的LINUX做服务器。如经典的LAMP：Linux + Apache + MySQL +
PHP*.*另外，Google就是Linux的集群系统*。】

注2：这样说不完全准确，vxWorks在6.x版本中也提供了保护模式的支持，但这个不是vxWorks主要的特性，vxWorks下的大部分应用程序还没有用到这个特性。

注3：可能是基于某个QNX特殊版本的。

注4：有时候甚至这个工作是完全不可行的，某些CPU是跟Linux绑定了的，没有提供完整的寄存器文档。

** [[http://www.douban.com/online/10999983/discussion/43631043/][口语教材推荐]]

英语学习没有捷径,但有弯路
能够避开弯路,就等于走了捷径
所以如果要学习，那么就要用最经典的教材。

1.首推American Accent Training，借用奶爸的话来评价这本书就是：“牛逼无比，颠覆传统！”
真本书无论是在豆瓣还是 Amazon网站上的买家对它的评价挺高的，作者在英语教学领域也颇有建树，整套教材看起来确有过人之处。
我已经把这本书以及它的练习上传至新浪爱问http://ishare.iask.sina.com.cn/f/22684062.html、
http://ishare.iask.sina.com.cn/f/22684061.html。
至于此书配套的影评，电驴上就有资源，大家可以去下载。下载下来以后可以打印出来，当然最好是买一本，新东方曾经引入过。
网友对音频的评价“原版系列一共是5张CD加一本书，我找到的是经过MP3抓轨软件处理过的，Mp3压缩率为128kps，音质非常好，这种音质对于语音训练来说简直有点奢侈。其实32kps就足够了。我随机听了几个片断，感觉不错，的确是标准的北美语音。主讲人的语速有点快，所以对于听力还是有一点要求的。我个人认为这套教材对于介于初级和中级的英语学习者是非常有用的，那些希望改善自己发音的网友也可以尝试一下。
”

2.如果英文材料读起来有些不习惯，大家不妨选择《赖世雄美语音标》，这本书基本上算是国内最好的英文发音教材。


3.另外再推荐一个《BBC标准音标视频发音教程》，这是一个比较强大的英式英语视频发音教程，由BBC英语学习频道出品。视频中包含各种英式发音的不同角度嘴形阐述。从最基本的音标出发，强烈推荐！大概有45个小节，每小节仅有几分钟而已，每天抽出半个小时看三小节，那么寒假也就能完成任务！要不大家每天来这汇报进度吧！电驴上也有资源，大家可以去搜。


不建议大家过多使用资源，贪多嚼不烂！寒假认认真真的把american accent training弄完，不仅纠正了发音，而且还锻炼了阅读水平以及听力！切记不要贪多，认认真真的把这本书以及《BBC标准音标视频发音教程》弄完！

** [[http://wiki.mbalib.com/wiki/%E5%8F%91%E5%85%89%E4%BA%8C%E6%9E%81%E7%AE%A1][发光二极管(Light Emitting Diode，LED)]]


*** 什么是发光二极管

*发光二极管*是指当在其整流方向施加电压(称为顺方向)时，有[[/wiki/%E7%94%B5%E6%B5%81][电流]]注入，电子与空穴复合，其一部分能量变换为光并发射的[[/wiki/%E4%BA%8C%E6%9E%81%E7%AE%A1][二极管]]。这种LED由[[/wiki/%E5%8D%8A%E5%AF%BC%E4%BD%93][半导体]]制成，属于固体元件，工作状态稳定、[[/wiki/%E5%8F%AF%E9%9D%A0%E6%80%A7][可靠性]]高，其连续通电时间(寿命)可达10^{5}h以上。^{[[#_note-0][[1]]]}

[[[/w/index.php?title=%E5%8F%91%E5%85%89%E4%BA%8C%E6%9E%81%E7%AE%A1&action=edit&section=2][编辑]]]

*** 发光二极管的参数^{[[#_note-.E5.8F.91.E5.85.89.E4.BA.8C.E6.9E.81.E7.AE.A1][[2]]]}

发光二极管的主要参数有最大工作电流/I/_{/FM/}和最大反向电压/U/_{/RM/}。

*1．最大工作电流*

最大工作电流/U/_{/RM/}是指发光二极管长期正常工作所允许通过的最大正向电流。使用中不能超过此值，否则将会烧毁发光二极管。

*2．最大反向电压*

最大反向电压/U/_{/RM/}是指发光二极管在不被击穿的前提下，所能承受的最大反向电压。发光二极管的最大反向电压/U/_{/RM/}一般在5V左右，使用中不应使发光二极管承受超过5V的反向电压，否则发光二极管将可能被击穿。

*3．其他参数*

发光二极管还有发光波长、发光强度等参数，一般使用时可不必考虑，只要选择自己喜欢的颜色和形状就可以了。

[[[/w/index.php?title=%E5%8F%91%E5%85%89%E4%BA%8C%E6%9E%81%E7%AE%A1&action=edit&section=3][编辑]]]

*** 发光二极管的特点与作用^{[[#_note-.E5.8F.91.E5.85.89.E4.BA.8C.E6.9E.81.E7.AE.A1][[2]]]}

发光二极管的特点是会发光。发光二极管与普通二极管一样具有单向导电性，当有足够的正向电流通过PN结时，便会发出不同颜色的可见光或红外光。

发光二极管的主要作用是指示和光发射，并可作为稳压管使用。

*1．指示*

(1)发光二极管的典型应用电路如图所示，R为限流电阻，I为通过发光二极管的正向电流。发光二极管的管压降一般比普通二极管大，为2V左右，电源电压必须大于管压降，发光二极管才能正常工作。

[[/wiki/Image:%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A11.jpg][[[/w/images/b/b9/%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A11.jpg]]]]

(2)发光二极管用于交流电源指示的电路如图所示，VD_1为整流二极管，VD_2为发光二极管，R为限流电阻，T为电源变压器。

[[/wiki/Image:%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A12.jpg][[[/w/images/0/01/%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A12.jpg]]]]

*2．光发射*

在红外遥控器、接近开关、光电耦合器等电路中，红外发光二极管担任光发射管，电路如图所示，VT为开关调制[[/wiki/%E6%99%B6%E4%BD%93%E7%AE%A1][晶体管]]，VD为红外发光二极管。信号源通过VT驱动和调制VD，使VD向外发射调制红外光。

[[/wiki/Image:%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A13.jpg][[[/w/images/7/73/%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A13.jpg]]]]

*3．稳压*

发光二极管可作为低电压稳压二极管使用。图所示简单并联稳压电路，利用发光二极管VD的管压降，可提供+2V的直流稳压输出。VD同时具有电源指示功能。

[[/wiki/Image:%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A14.jpg][[[/w/images/d/dc/%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A14.jpg]]]]

*4．发光*

二极管的扫描驱动需要点亮多个发光二极管时，可以采用扫描驱动的方式，以简化电路和节约电能。如图所示，电子开关将电源电压依次快速轮流接入4只发光二极管，只要轮流的速度足够快，看起来这4只发光二极管都一直在亮着。

[[/wiki/Image:%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A15.jpg][[[/w/images/2/24/%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A15.jpg]]]]

[[[/w/index.php?title=%E5%8F%91%E5%85%89%E4%BA%8C%E6%9E%81%E7%AE%A1&action=edit&section=4][编辑]]]

*** 发光二级管的分类^{[[#_note-1][[3]]]}

按发光颜色分，发光二极管分为红色、橙色、绿色(又细分黄绿、标准绿和纯绿)、蓝光等。另外有的发光二极管中包含两种或三种颜色的[[/wiki/%E8%8A%AF%E7%89%87][芯片]]。根据掺或不掺散射剂、有色还是无色，又可分为有色透明、无色透明、有色散射和无色散射四种类型。散射型发光二极管常用来做指示灯。

按发光管出光面特征分为圆灯、方灯、[[/wiki/%E7%9F%A9%E5%BD%A2][矩形]]、面发光管、侧向管、表面安装用微型管等，其中圆形灯按直径分为Φ2mm、Φ4.4mm、Φ5mm、Φ8mm、Φ10mm及Φ20mm等，外形尺寸以Φ3mm、Φ5mml最为常见。国外通常把Φ3mm的发光二极管记作T-1，把Φ5mm的记作T-1(3/4)，把Φ4.4mm的记作T-1(1/4)。

按发光强度和工作电流分有普通亮度的LED(发光强度<10mcd)、超高亮度的LED(发光强度>100mcd)、高亮度的LED(发光强度在10～100mcd间)。

一般LED的工作电流在十几毫安至几十毫安，但低电流LED的工作电流在2mA以下(亮度与普通发光管相同)。

除上述分类方法外．还有按芯片材料分类及按功能分类的方法。

[[[/w/index.php?title=%E5%8F%91%E5%85%89%E4%BA%8C%E6%9E%81%E7%AE%A1&action=edit&section=5][编辑]]]

*** 发光二极管的应用^{[[#_note-2][[4]]]}

①电源通断指示发光二极管作为电源通断指示电路，如图所示，通常称为指示灯，在实际应用中给人提供很大的方便。发光二极管的供电电源既可以是直流的也可以是交流的，但必须注意的是．发光二极管是一种电流控制器件，应用中只要[[/wiki/%E4%BF%9D%E8%AF%81][保证]]发光二极管的正向工作电流在所规定的范围之内，它就可以正常发光。具体的工作电流可查阅有关资料。

[[/wiki/Image:%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A16.jpg][[[/w/images/a/a2/%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A16.jpg]]]]

②数码管是电子技术中应用的主要显示器件，其就是用发光二极管经过一定的排列组成的，如图(a)所示。

这是最常用的七段数码显示。要使它显示0～9的一系列数字只要点亮其内部相应的显示段即可。七段数码显示有共阳极[图(b)]和共阴极[图(c)]之分。数码管的驱动方式有直流驱动和脉冲驱动两种，应用中可任意选择。数码管应用十分广泛，可以说．凡是需要指示或读数的场合，都可采用数码管显示。

[[/wiki/Image:%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A17.jpg][[[/w/images/a/af/%E5%8F%91%E5%85%89%E4%BA%8C%E7%BA%A7%E7%AE%A17.jpg]]]]

** [[http://www.cnblogs.com/ggjucheng/archive/2012/10/30/2746963.html][bash的通配符与特殊符号]]

在 bash 的操作环境中还有一个非常有用的功能，那就是通配符 (wildcard) ！
我们利用 bash 处理数据就更方便了！底下我们列出一些常用的通配符喔：

| 符号   | *                                 | ?                            | [ ]                                                                                                                       | [ - ]                                                                                                                       | [\^ ]                                                                                                                                     |
| 意义   | 代表『 0 个到无穷多个』任意字符   | 代表『一定有一个』任意字符   | 同样代表『一定有一个在括号内』的字符(非任意字符)。例如 [abcd] 代表『一定有一个字符， 可能是 a, b, c, d 这四个任何一个』   | 若有减号在中括号内时，代表『在编码顺序内的所有字符』。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！   | 若中括号内的第一个字符为指数符号 (\^) ，那表示『反向选择』，例如 [\^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。   |

接下来让我们利用通配符来玩些东西吧！首先，利用通配符配合 ls 找檔名看看：

#+BEGIN_EXAMPLE
    [root@www ~]# LANG=C              <==由于与编码有关，先配置语系一下

    范例一：找出 /etc/ 底下以 cron 为开头的档名
    [root@www ~]# ll -d /etc/cron*    <==加上 -d 是为了仅显示目录而已

    范例二：找出 /etc/ 底下文件名『刚好是五个字母』的文件名
    [root@www ~]# ll -d /etc/?????    <==由于 ? 一定有一个，所以五个 ? 就对了

    范例三：找出 /etc/ 底下文件名含有数字的文件名
    [root@www ~]# ll -d /etc/*[0-9]*  <==记得中括号左右两边均需 *

    范例四：找出 /etc/ 底下，档名开头非为小写字母的文件名：
    [root@www ~]# ll -d /etc/[^a-z]*  <==注意中括号左边没有 *

    范例五：将范例四找到的文件复制到 /tmp 中
    [root@www ~]# cp -a /etc/[^a-z]* /tmp
#+END_EXAMPLE



除了通配符之外，bash 环境中的特殊符号有哪些呢？底下我们先汇整一下：

| 符号   | #                                                                      | \                                                | |                                                   | ;                                                                 | ~              | $                                                  | &                                              | !                                     | /                          | >, >>                                              | <, <<                                         | ' '                            | " "                    | ` `                                                | ( )                             | { }                        |
| 内容   | 批注符号：这个最常被使用在 script 当中，视为说明！在后的数据均不运行   | 跳脱符号：将『特殊字符或通配符』还原成一般字符   | 管线 (pipe)：分隔两个管线命令的界定(后两节介绍)；   | 连续命令下达分隔符：连续性命令的界定 (注意！与管线命令并不相同)   | 用户的家目录   | 取用变量前导符：亦即是变量之前需要加的变量取代值   | 工作控制 (job control)：将命令变成背景下工作   | 逻辑运算意义上的『非』 not 的意思！   | 目录符号：路径分隔的符号   | 数据流重导向：输出导向，分别是『取代』与『累加』   | 数据流重导向：输入导向 (这两个留待下节介绍)   | 单引号，不具有变量置换的功能   | 具有变量置换的功能！   | 两个『 ` 』中间为可以先运行的命令，亦可使用 $( )   | 在中间为子 shell 的起始与结束   | 在中间为命令区块的组合！   |

以上为 bash
环境中常见的特殊符号汇整！理论上，你的『档名』尽量不要使用到上述的字符啦！

** [[http://blog.sina.com.cn/s/blog_61c006ea0100mgxe.html][shell编程中的date用法]]


1、date --help

%% 输出%符号 a literal %
 %a 当前域的星期缩写 locale's abbreviated weekday name (Sun..Sat)
 %A 当前域的星期全写 locale's full weekday name, variable length
(Sunday..Saturday)
 %b 当前域的月份缩写 locale's abbreviated month name (Jan..Dec)
 %B 当前域的月份全称 locale's full month name, variable length
(January..December)
 %c 当前域的默认时间格式 locale's date and time (Sat Nov 04 12:02:33 EST
1989)
 %C n百年 century (year divided by 100 and truncated to an integer)
[00-99]
 %d 两位的天 day of month (01..31)
 %D 短时间格式 date (mm/dd/yy)
 %e 短格式天 day of month, blank padded ( 1..31)
 %F 文件时间格式 same as %Y-%m-%d
 %g the 2-digit year corresponding to the %V week number
 %G the 4-digit year corresponding to the %V week number
 %h same as %b
 %H 24小时制的小时 hour (00..23)
 %I 12小时制的小时 hour (01..12)
 %j 一年中的第几天 day of year (001..366)
 %k 短格式24小时制的小时 hour ( 0..23)
 %l 短格式12小时制的小时 hour ( 1..12)
 %m 双位月份 month (01..12)
 %M 双位分钟 minute (00..59)
 %n 换行 a newline
 %N 十亿分之一秒 nanoseconds (000000000..999999999)
 %p 大写的当前域的上下午指示 locale's upper case AM or PM indicator
(blank in many locales)
 %P 小写的当前域的上下午指示 locale's lower case am or pm indicator
(blank in many locales)
 %r 12小时制的时间表示（时:分:秒,双位） time, 12-hour (hh:mm:ss [AP]M)
 %R 24小时制的时间表示 （时:分,双位）time, 24-hour (hh:mm)
 %s 自基础时间 1970-01-01 00:00:00 到当前时刻的秒数 seconds since
`00:00:00 1970-01-01 UTC' (a GNU extension)
 %S 双位秒 second (00..60); the 60 is necessary to accommodate a leap
second
 %t 横向制表位(tab) a horizontal tab
 %T 24小时制时间表示 time, 24-hour (hh:mm:ss)
 %u 数字表示的星期（从星期一开始 1-7）day of week (1..7); 1 represents
Monday
 %U 一年中的第几周星期天为开始 week number of year with Sunday as first
day of week (00..53)
 %V 一年中的第几周星期一为开始 week number of year with Monday as first
day of week (01..53)
 %w 一周中的第几天 星期天为开始 0-6 day of week (0..6); 0 represents
Sunday
 %W 一年中的第几周星期一为开始 week number of year with Monday as first
day of week (00..53)
 %x 本地日期格式 locale's date representation (mm/dd/yy)
 %X 本地时间格式 locale's time representation (%H:%M:%S)
 %y 两位的年 last two digits of year (00..99)
 %Y 年 year (1970...)
 %z RFC-2822 标准时间格式表示的域 RFC-2822 style numeric timezone
(-0500) (a nonstandard extension)
 %Z 时间域 time zone (e.g., EDT), or nothing if no time zone is
determinable

By default, date pads numeric fields with zeroes. GNU date recognizes
 the following modifiers between `%' and a numeric directive.

`-' (hyphen) do not pad the field
 `_' (underscore) pad the field with spaces

--------------------------------------------------------------------------------

2、一些用法

1）#以yymmdd的格式输出43天前的当前时刻

date +%Y%m%d --date='43 days ago'



2）# 测试十亿分之一秒
 date +'%Y%m%d %H:%M:%S.%N';date +'%Y%m%d %H:%M:%S.%N';date +'%Y%m%d
%H:%M:%S.%N';date +'%Y%m%d %H:%M:%S.%N'

3）#创建以当前时间为文件名的目录
 mkdir `date +%Y%m%d`



4）#备份以时间做为文件名的
 tar -cvf ./htdocs`date +%Y%m%d`.tar ./*



5）#显示时间后跳行，再显示目前日期

date +%T%n%Y%m%d



6）#只显示月份与日数

date +%B%d



7）#获取上周日期（day,month,year,hour）

date -d "-1 week" +%Y%m%d 　　



8）#获取24小时前日期

date --date="-24 hour" +%Y%m%d



9）#shell脚本里面赋给变量值

date_now=`date +%s`



10）#计算执行一段sql脚本的运行时间



TIME_BEGIN=$(date '+%s.%N')
 $sqlcli < queries/q1.3.sql 1>> $FILE_RESULT  2>> $FILE_ERROR
 TIME_END=$(date '+%s.%N')
 TIME_RUN=$(awk 'BEGIN{print '$TIME_END' - '$TIME_BEGIN'}')



11）#编写shell脚本计算离自己生日还有多少天？

  read -p "Input your birthday(YYYYmmdd):" date1

m=`date --date="$date1" +%m`  #得到生日的月

d=`date --date="$date1" +%d`  #得到生日的日

date_now=`date +%s`  #得到当前时间的秒值

y=`date +%Y` #得到当前时间的年

birth=`date --date="$y$m$d" +%s`  #得到今年的生日日期的秒值

internal=$(($birth-$date_now))  #计算今日到生日日期的间隔时间

if [ "$internal" -lt "0" ]; then  #判断今天的生日是否已过

birth=`date --date="$(($y+1))$m$d" +%s`  #得到明天的生日日期秒值

internal=$(($birth-$date_now))
#计算今天到下一个生日的间隔时间

fi

echo "There is :$((einternal/60/60/24)) days."
#输出结果，秒换算为天





12）#若是不以加号作为开头，则表示要设定时间，而时间格式为
MMDDhhmm[[CC]YY][.ss]，

其中 MM 为月份，

DD 为日，

hh 为小时，

mm 为分钟，

CC 为年份前两位数字，

YY 为年份后两位数字，

ss 为秒数



13）

#显示目前的格林威治时间，也叫“世界时”。是英国的标准时间，也是世界各地时间的参考标准。中英两国的标准[[http://baike.baidu.com/view/72144.htm][时差]]为8个小时，即英国的当地时间比中国的[[http://baike.baidu.com/view/21267.htm][北京时间]]晚8小时。

date -u
 Thu Sep 28 09:32:04 UTC 2006



14）#修改时间

date -s
 按字符串方式修改时间
 可以只修改日期,不修改时间,输入: date -s 2007-08-03
 只修改时间,输入:date -s 14:15:00
 同时修改日期时间,注意要加双引号,日期与时间之间有一空格,输入:date -s
"2007-08-03 14:15:00"

 修改完后,记得输入:clock -w
 把系统时间写入CMOS

** [[http://www.cnblogs.com/xuxm2007/archive/2011/10/20/2218846.html][shell脚本中一些特殊符号]]

在shell中常用的特殊符号罗列如下：

# ;   ;; . , / \\ 'string'| !   $   ${}   $? $$   $*

\"string\"* **   ? : ^ $#   $@ `command`{}   [] [[]] ()   (())

||   && {xx,yy,zz,...}~   ~+   ~-   &   \\<...\\>   + - %=   ==   !=


# 井号 (comments)
这几乎是个满场都有的符号，除了先前已经提过的\"第一行\"
#!/bin/bash
井号也常出现在一行的开头，或者位于完整指令之后，这类情况表示符号后面的是注解文字，不会被执行。
# This line is comments.
echo \"a = $a\" # a = 0
由于这个特性，当临时不想执行某行指令时，只需在该行开头加上 # 就行了。这常用在撰写过程中。
#echo \"a = $a\" # a = 0
如果被用在指令中，或者引号双引号括住的话，或者在倒斜线的后面，那他就变成一般符号，不具上述的特殊功能。


~ 帐户的 home 目录
算是个常见的符号，代表使用者的 home 目录：cd ~；也可以直接在符号后加上某帐户的名称：cd ~user或者当成是路径的一部份：~/bin
~+ 当前的工作目录，这个符号代表当前的工作目录，她和内建指令 pwd的作用是相同的。
# echo ~+/var/log
~- 上次的工作目录，这个符号代表上次的工作目录。
# echo ~-/etc/httpd/logs


; 分号 (Command separator)
在 shell 中，担任\"连续指令\"功能的符号就是\"分号\"。譬如以下的例子：cd ~/backup ; mkdir startup ;cp ~/.* startup/.


;; 连续分号 (Terminator)
专用在 case 的选项，担任 Terminator 的角色。
case \"$fop\" inhelp) echo \"Usage: Command -help -version filename\";;version) echo \"version 0.1\" ;;esac


. 逗号 (dot,就是“点”)
在 shell 中，使用者应该都清楚，一个 dot 代表当前目录，两个 dot 代表上层目录。
CDPATH=.:~:/home:/home/web:/var:/usr/local
在上行 CDPATH 的设定中，等号后的 dot 代表的就是当前目录的意思。
如果档案名称以 dot 开头，该档案就属特殊档案，用 ls 指令必须加上 -a 选项才会显示。除此之外，在 regularexpression 中，一个 dot 代表匹配一个字元。


'string' 单引号 (single quote)
被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量替换。
heyyou=homeecho '$heyyou' # We get $heyyou


\"string\" 双引号 (double quote)
被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。
heyyou=homeecho \"$heyyou\" # We get home

`command` 倒引号 (backticks)
在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。
fdv=`date +%F`echo \"Today $fdv\"
在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。


, 逗点 (comma，标点中的逗号)
这个符号常运用在运算当中当做\"区隔\"用途。如下例
#!/bin/bashlet \"t1 = ((a = 5 + 3, b = 7 - 1, c = 15 / 3))\"echo \"t1= $t1, a = $a, b = $b\"


/ 斜线 (forward slash)
在路径表示时，代表目录。
cd /etc/rc.dcd ../..cd /
通常单一的 / 代表 root 根目录的意思；在四则运算中，代表除法的符号。
let \"num1 = ((a = 10 / 2, b = 25 / 5))\"


\\ 倒斜线
在交互模式下的escape 字元，有几个作用；放在指令前，有取消 aliases的作用；放在特殊符号前，则该特殊符号的作用消失；放在指令的最末端，表示指令连接下一行。
# type rmrm is aliased to `rm -i'# \\rm ./*.log
上例，我在 rm 指令前加上 escape 字元，作用是暂时取消别名的功能，将 rm 指令还原。
# bkdir=/home# echo \"Backup dir, \\$bkdir = $bkdir\"Backup dir,$bkdir = /home
上例 echo 内的 \\$bkdir，escape 将 $ 变数的功能取消了，因此，会输出 $bkdir，而第二个 $bkdir则会输出变数的内容 /home。


| 管道 (pipeline)
pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。
who | wc -l
善用这个观念，对精简 script 有相当的帮助。


! 惊叹号(negate or reverse)
通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表\"不等于\"
if [ \"$?\" != 0 ]thenecho \"Executes error\"exit 1fi
在规则表达式中她担任 \"反逻辑\" 的角色
ls a[!0-9]
上例，代表显示除了a0, a1 .... a9 这几个文件的其他文件。


: 冒号
在 bash 中，这是一个内建指令：\"什么事都不干\"，但返回状态值 0。
:
echo $? # 回应为 0
: > f.$$
上面这一行，相当于 cat /dev/null >f.$$。不仅写法简短了，而且执行效率也好上许多。
有时，也会出现以下这类的用法
: ${HOSTNAME?} ${USER?} ${MAIL?}
这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或 if这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。


? 问号 (wild card)
在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字元，但不包含 null 字元。
# ls a?a1
善用她的特点，可以做比较精确的档名匹配。


 * 星号 (wild card)
相当常用的符号。在文件名扩展(Filename expansion)上，她用来代表任何字元，包含 null 字元。
# ls a*a a1 access_log
在运算时，它则代表 \"乘法\"。
let \"fmult=2*3\"
除了内建指令 let，还有一个关于运算的指令expr，星号在这里也担任\"乘法\"的角色。不过在使用上得小心，他的前面必须加上escape 字元。


 ** 次方运算
两个星号在运算时代表 \"次方\" 的意思。
let \"sus=2**3\"echo \"sus = $sus\" # sus = 8


$ 钱号(dollar sign)
变量替换(Variable Substitution)的代表符号。
vrs=123echo \"vrs = $vrs\" # vrs = 123
另外，在 Regular Expressions 里被定义为 \"行\" 的最末端 (end-of-line)。这个常用在grep、sed、awk 以及 vim(vi) 当中。


${} 变量的正规表达式
bash 对 ${} 定义了不少用法。以下是取自线上说明的表列
   ${parameter:-word}   ${parameter:=word}   ${parameter:?word}   ${parameter:+word}   ${parameterffset}   ${parameterffset:length}   ${!prefix*}   ${#parameter}   ${parameter#word}   ${parameter##word}   ${parameter%word}   ${parameter%%word}   ${parameter/pattern/string}   ${parameter//pattern/string}


$*
$* 引用script的执行引用变量，引用参数的算法与一般指令相同，指令本身为0，其后为1，然后依此类推。引用变量的代表方式如下：
$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}.....
个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住。
$* 则是代表所有引用变量的符号。使用时，得视情况加上双引号。
echo \"$*\"
还有一个与 $* 具有相同作用的符号，但效用与处理方式略为不同的符号。


$@
$@ 与 $* 具有相同作用的符号，不过她们两者有一个不同点。
符号 $* 将所有的引用变量视为一个整体。但符号 $@ 则仍旧保留每个引用变量的区段观念。

$#
这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。
echo \"$#\"


$? 状态值 (status variable)
一般来说，UNIX(linux) 系统的进程以执行系统调用exit()来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行状态。
一般指令程序倘若执行成功，其回传值为 0；失败为 1。
tar cvfz dfbackup.tar.gz /home/user > /dev/nullecho\"$?\"$$
由于进程的ID是唯一的，所以在同一个时间，不可能有重复性的 PID。有时，script会需要产生临时文件，用来存放必要的资料。而此script亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠。唯有产生动态文件名，才能符合需要。符号$$或许可以符合这种需求。它代表当前shell 的 PID。
echo \"$HOSTNAME, $USER, $MAIL\" > ftmp.$$
使用它来作为文件名的一部份，可以避免在同一时间，产生相同文件名的覆盖现象。
ps: 基本上，系统会回收执行完毕的 PID，然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法，如果script 执行完毕后仍不加以清除，会产生其他问题。

(   ) 指令群组 (command group)
用括号将一串连续指令括起来，这种用法对 shell 来说，称为指令群组。如下面的例子：(cd ~ ; vcgh=`pwd` ;echo $vcgh)，指令群组有一个特性，shell会以产生 subshell来执行这组指令。因此，在其中所定义的变数，仅作用于指令群组本身。我们来看个例子
# cat ftmp-01#!/bin/basha=fsh(a=incg ; echo -e \"\\n $a \\n\")echo $a#./ftmp-01incgfsh
除了上述的指令群组，括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape字元才能使用的场合，如运算式。


(( ))
这组符号的作用与 let 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let指令要好许多。
#!/bin/bash(( a = 10 ))echo -e \"inital value, a = $a\\n\"(( a++))echo \"after a++, a = $a\"

{ } 大括号 (Block of code)
有时候 script 当中会出现，大括号中会夹着一段或几段以\"分号\"做结尾的指令或变数设定。
# cat ftmp-02#!/bin/basha=fsh{a=inbc ; echo -e \"\\n $a \\n\"}echo $a#./ftmp-02inbcinbc
这种用法与上面介绍的指令群组非常相似，但有个不同点，它在当前的 shell 执行，不会产生 subshell。
大括号也被运用在 \"函数\" 的功能上。广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写 script也是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。

此外，大括号还有另一种用法，如下
{xx,yy,zz,...}
这种大括号的组合，常用在字串的组合上，来看个例子
mkdir {userA,userB,userC}-{home,bin,data}
我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data, userC-home, userC-bin,userC-data，这几个目录。这组符号在适用性上相当广泛。能加以善用的话，回报是精简与效率。像下面的例子
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
如果不是因为支援这种用法，我们得写几行重复几次呀！


[   ] 中括号
常出现在流程控制中，扮演括住判断式的作用。if [ \"$?\" != 0 ]thenecho \"Executes error\"exit1fi
这个符号在正则表达式中担任类似 \"范围\" 或 \"集合\" 的角色
rm -r 200[1234]
上例，代表删除 2001, 2002, 2003, 2004 等目录的意思。


[[ ]]
这组符号与先前的 [] 符号，基本上作用相同，但她允许在其中直接使用 || 与&& 逻辑等符号。
#!/bin/bashread akif [[ $ak > 5 || $ak< 9 ]]thenecho $akfi


|| 逻辑符号
这个会时常看到，代表 or 逻辑的符号。


&& 逻辑符号
这个也会常看到，代表 and 逻辑的符号。


& 后台工作
单一个& 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。
tar cvfz data.tar.gz data > /dev/null&

\\<...\\> 单字边界
这组符号在规则表达式中，被定义为\"边界\"的意思。譬如，当我们想找寻 the 这个单字时，如果我们用
grep the FileA
你将会发现，像 there 这类的单字，也会被当成是匹配的单字。因为 the 正巧是 there的一部份。如果我们要必免这种情况，就得加上 \"边界\" 的符号
grep '\\' FileA


+ 加号 (plus)
在运算式中，她用来表示 \"加法\"。
expr 1 + 2 + 3
此外在规则表达式中，用来表示\"很多个\"的前面字元的意思。
# grep '10\\+9' fileB109100910000910000931010009#这个符号在使用时，前面必须加上escape 字元。


- 减号 (dash)
在运算式中，她用来表示 \"减法\"。
expr 10 - 2
此外也是系统指令的选项符号。
ls -expr 10 - 2
在 GNU 指令中，如果单独使用 - 符号，不加任何该加的文件名称时，代表\"标准输入\"的意思。这是 GNU指令的共通选项。譬如下例
tar xpvf -
这里的 - 符号，既代表从标准输入读取资料。
不过，在 cd 指令中则比较特别
cd -
这代表变更工作目录到\"上一次\"工作目录。


% 除法 (Modulo)
在运算式中，用来表示 \"除法\"。
expr 10 % 2
此外，也被运用在关于变量的规则表达式当中的下列
${parameter%word}${parameter%%word}
一个 % 表示最短的 word 匹配，两个表示最长的 word 匹配。


= 等号 (Equals)
常在设定变数时看到的符号。
vara=123echo \" vara = $vara\"
或者像是 PATH 的设定，甚至应用在运算或判断式等此类用途上。


== 等号 (Equals)
常在条件判断式中看到，代表 \"等于\" 的意思。
if [ $vara == $varb ]
...下略

!= 不等于
常在条件判断式中看到，代表 \"不等于\" 的意思。
if [ $vara != $varb ]
...下略


^
这个符号在规则表达式中，代表行的 \"开头\" 位置，在[]中也与\"!\"(叹号)一样表示“非”


输出/输入重导向
> >>   <   <<   :>   &>   2&>   2<>>&   >&2

文件描述符(File Descriptor)，用一个数字（通常为0-9）来表示一个文件。
常用的文件描述符如下：
文件描述符     名称     常用缩写 默认值
0        标准输入 stdin    键盘
1        标准输出 stdout     屏幕
2    标准错误输出   stderr     屏幕
我们在简单地用<或>时，相当于使用 0< 或 1>（下面会详细介绍）。
 * cmd > file
把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，使用bash的noclobber选项可以防止复盖原有文件。
 * cmd >> file
把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件後面。
 * cmd < file
使cmd命令从file读入
 * cmd << text
从命令行读取输入，直到一个与text相同的行结束。除非使用引号把输入括起来，此模式将对输入内容进行shell变量替换。如果使用<<- ，则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考後面的例子。
 * cmd <<< word
把word（而不是文件word）和後面的换行作为输入提供给cmd。
 * cmd <> file
以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。
 * cmd >| file
功能同>，但即便在设置了noclobber时也会复盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用>!实现这一功能。
: > filename    把文件\"filename\"截断为0长度.# 如果文件不存在, 那么就创建一个0长度的文件(与'touch'的效果相同).
cmd >&n 把输出送到文件描述符n
cmd m>&n 把输出 到文件符m的信息重定向到文件描述符n
cmd >&- 关闭标准输出
cmd <&n 输入来自文件描述符n
cmd m<&n m来自文件描述各个n
cmd <&- 关闭标准输入
cmd <&n- 移动输入文件描述符n而非复制它。（需要解释）
cmd >&n- 移动输出文件描述符 n而非复制它。（需要解释）
注意： >&实际上复制了文件描述符，这使得cmd > file 2>&1与cmd 2>&1 >file的效果不一样。

 http://hi.baidu.com/hellosimple/blog/item/559483f1f1c0e95e352acc89.html



 http://blog.csdn.net/mqboss/article/details/6549176

1、{} 大括号：
用法一：通配符扩展
代码:
ls my_{finger,toe}s

这条命令相当于如下命令的组合：
代码:
ls my_fingers my_toes
mkdir {userA,userB,userC}-{home,bin,data}

我们将得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data,userC-home, userC-bin, userC-data，这几个目录
用法二：可用于语句块的构造，语句之间用回车隔开。如果你想在某些使用单个语句的地方（比如在AND或OR列表中）使用多条语句，你可以把它们括在花括号{}中来构造一个语句块。
代码:
grep -v "$cdcatnum" $strack_file > $temp_file
cat $temp_file > $strack_file
echo
cat -n file1

(注：以上大括号中的四句命令够成了一个语句块)
用法三：参数扩展
代码:
${name:-default} 使用一个默认值（一般是空值）来代替那些空的或者没有赋值的变量name；
${name:=default}使用指定值来代替空的或者没有赋值的变量name；
${name:?message}如果变量为空或者未赋值，那么就会显示出错误信息并中止脚本的执行同时返回退出码1。
${#name} 给出name的长度
${name%word} 从name的尾部开始删除与word匹配的最小部分，然后返回剩余部分
${name%%word} 从name的尾部开始删除与word匹配的最长部分，然后返回剩余部分
${name#word} 从name的头部开始删除与word匹配的最小部分，然后返回剩余部分
${name##word} 从name的头部开始删除与word匹配的最长部分，然后返回剩余部分

（注，name为变量名，word为要匹配的字符串）
用法三在处理字符串和未知变量时，是很有用的。

2、[] 中括号：
用法一：通配符扩展：
允许匹配方括号中任何一个单个字符
代码:
ls /[eh][to][cm]*

相当于执行 ls /etc /home（若有/eom目录，就相当于会执行ls /etc /home /eom）
注：在mkdir命令下不能扩展
用法二：用于条件判断符号：
[]符号可理解为指向test命令的一个软链接，所以其用法可完全参照test，将test位置替换为[便可。
代码:
if [ "$?" != 0 ] 等价于 if test "$?" != 0
then echo "Executes error"


3、`command` 反引号：
`command`与$(command)的含义相同，都是返回当前执行命令的结果
代码:
#!/bin/sh
for file in $(ls f*.sh);do
    lpr $file
done
exit 0

该例实现了扩展f*.sh给出所有匹配模式的文件的名字。

4、'string' 单引号 和 "string" 双引号
双引号：如果想在定义的变量中加入空格，就必须使用单引号或双引号，
单、双引号的区别在于双引号转义特殊字符而单引号不转义特殊字符
代码:
$ heyyou=home
$ echo '$heyyou'
$ $heyyou （$没有转义）
eg: $ heyyou=home
$ echo "$heyyou"
$ home （很明显，$转义了输出了heyyou变量的值）


5、$# 它的作用是告诉你引用变量的总数量是多少；
代码:
$$ 它的作用是告诉你shell脚本的进程号；
$* 以一个单字符串显示所有的脚本传递的参数。等价于$1 $2 $3.......；
$@ 与$*基本类似（参见序号7），但在数组赋值时有些不同；
$? 前一个命令的退出码；
$- 显示shell使用的当前选项；
$! 最后一个后台运行的进程ID号。


6、$((...))语法：对括号内的表达式求值
代码:
#!/bin/sh
x=0
hile [ "$x" -ne 10 ];do
echo $x
x=$(($x+1))
done
exit 0


7、shell中几种特殊的参数变量的引用
代码:
$1、$2、$3……${10}、${11}、${12}…… ：表示脚本传入的的各个参数，注意当需表示两位数以后的参数时数字要用花括号括起。
$@ 列出所有的参数，各参数用空格隔开
$*: 列出所有的参数，各参数用环境变量IFS的第一个字符隔开


8、命令列表：
AND列表 statement1 && statement2 && statement3 && …:只有在前面所有的命令都执行成功的情况下才执行后一条命令
OR列表 statement1 || statement2 || statement3 || …:允许执行一系列命令直到有一条命令成功为止，其后所有命令将不再被执行
#!/bin/sh
代码:
touch file_one
rm -f file_two
if [ -f file_one ] && echo "hello" && [ -f file_two ] && echo " there"
then
echo "in if"
else
echo "in else"
fi
exit 0

上例的输出为：
代码:
hello
in else

关于AND列表与OR列表，在逻辑判断中很使用，下面就举一个其最常用的例子：
代码:
[ condition ] && command for true || command for false:

当条件为真时，执行commandfor true ,当条件为假时，执行command for false

9、: 冒号：内建空指令，返回值为0
代码:
$ :
$ echo $?
$ 0
while: (该语句结构可实现一个无限循环)


10、; 分号: 在 shell 中，担任"连续指令"功能的符号就是"分号"
代码:
cd ~/backup ; mkdir startup ; cp ~/.* startup/.


11、# 井号：表示符号后面的是注解文字，不会被执行；
代码:
 * 匹配文件名中的任何字符，包括字符串；
？ 匹配文件名中的任何单个字符。
~ 代表使用者的 home 目录


12、/ 倒斜线：
放在指令前，有取消 aliases（别名） 的作用；
放在特殊符号前，则该特殊符号的作用消失；
放在指令的最末端，表示指令连接下一行（使得回车符无效，只起换行作用）

13、! 感叹号：
通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表"不等于"

14、** 次方运算：两个星号在运算时代表 "次方" 的意思
代码:
let "sus=2**3"
ech

** [[http://www.cnblogs.com/xianghang123/archive/2011/12/06/2277602.html][【Matlab】读取文件各种方法]]

本技术支持指南主要处理：ASCII, binary, and MAT files.
要得到MATLAB中可用来读写各种文件格式的完全函数列表，可以键入以下命令：
help iofun

*MATLAB中有两种文件I/O程序：high level and low level.*
*High level routines:*
包括现成的函数，可以用来读写特殊格式的数据，并且只需要少量的编程。
*Low level routines:*
可以更加灵活的完成相对特殊的任务，需要较多的额外编程。


High level routines
包括现成的函数，可以用来读写特殊格式的数据，并且只需要少量的编程。



举个例子，如果你有一个包含数值和字母的文本文件（text
file）想导入MATLAB，你可以调用一些low level
routines自己写一个函数，或者是简单的用[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/textread.html][TEXTREAD]]函数。



*使用high level
routines的关键是：文件必须是相似的（homogeneous），*换句话说，文件必须有一致的格式。下面的段落描述一些high
level file I/O routines并给出一些例子帮助理解概念。



*LOAD/SAVE*



主要的high level file I/O routines
是[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/load.html][LOAD]]
和
[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/save.html][SAVE]]函数。LOAD
可以读MAT-file data或者用空格间隔的格式相似的ASCII data.
SAVE可以将MATLAB变量写入MAT-file格式或者空格间隔的ASCII
data。大多数情况下，语法相当简单。下面的例子用到数值由空格间隔的ASCII
file
[[http://www.mathworks.com/support/tech-notes/1600/1602_files/sample_file.txt][sample_file.txt]]
：



1 5 4 16 8

5 43 2 6 8

6 8 4 32 1

90 7 8 7 6

5 9 81 2 3



Example:
用 LOAD and SAVE 读写数据


CODE:

% Load the file to the matrix, M :
M = load('sample_file.txt')

% Add 5 to M :
M = M +5

% Save M to a .mat file called 'sample_file_plus5.mat':
save sample_file_plus5 M

% Save M to an ASCII .txt file called 'sample_file_plus5.txt' :
save sample_file_plus5.txt M -ascii


*UIGETFILE/UIPUTFILE
*



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/uigetfile.html][UIGETFILE]]/[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/uiputfile.html][UIPUTFILE]]是基于图形用户界面（GUI）的。会弹出对话框，列出当前目录的文件和目录，提示你选择一个文件。[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/uigetfile.html][UIGETFILE]]让你选择一个文件来写（类似Windows
‘另存为'选项？）。用[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/uigetfile.html][UIGETFILE]]，可以选择已存在的文件改写，也可以输入新的文件名。两个函数的返回值是所选文件名和路径。



Example:
用 UIGETFILE 从当前目录选择一个 M-file


CODE:

% This command lists all the M-files in the current directory and
% returns the name and path of the selected file

[fname,pname] = uigetfile('*.m','Sample Dialog Box')



注意: UIGETFILE 一次只能选择一个文件。



*UIIMPORT/IMPORTDATA*



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/uiimport.html][UIIMPORT]]是一个功能强大，易于使用的基于GUI的high
level routine，用于读complex data files。文件也必须是homogeneous。



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/importdata.html][IMPORTDATA]]形成[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/uiimport.html][UIIMPORT]]的功能，不打开GUI。可以将IMPORTDATA用于函数或者脚本中，因为在函数或者脚本中基于GUI的文件导入机制并不理想。下面的例子用到包含几行文件头和文本、数值数据的文件[[http://www.mathworks.com/support/tech-notes/1600/1602_files/sample_file2.txt]['sample_file2.txt']]
：



This is a file header.

This is file is an example.

col1 col2 col3 col4

A    1   4    612.000

B    1   4    613.000

C    1   4    614.000

D    1   4    615.000



Example: Using IMPORTDATA to read in a file with headers, text, and
numeric data


CODE:

% This reads in the file 'sample_file2.txt' and creates a
% structure D that contains both data and text data.
% Note the IMPORTDATA command specifies a white space
% as the delimiter of the file, but IMPORTDATA can usually
% detect this on its own

D = importdata('sample_file2.txt','') % 原文有误？
D = importdata('sample_file2.txt')


可以通过访问结构D的数据和文本域，来看结构D中的真实值，例如输入：

data = D.data

text = D.textdata



可以用UIIMPORT读同一个文件并得到同样的结构.



注意: 对于 ASCII data, 你必须检验导入向导正确的识别了列分隔符。



*TEXTREAD/STRREAD*



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/textread.html][TEXTREAD]]
是一个强大的动态high level
routine，设计用来读ASCII格式的文本和/或数值数据文件。[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/strread.html][STRREAD]]除是从字符串而不是文件读以外，类似于[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/textread.html][TEXTREAD]]。



两个函数可以用许多参数来改变其具体的工作方式，他们返回读入指定输出的数据。他们有效的提供给你一个
“两全其美”的方法，因为他们可以用一个命令读入混合的ASCII和数值数据（high
level routines的做法），并且你可以改变他们以匹配你特定的应用（如同low
level routines做到的）。例子：


CODE:
Example 1: Using TEXTREAD to read in an entire file into a cell array


% This command reads in the file fft.m into the cell array, file
file = textread('fft.m','%s','delimiter','\n','whitespace','');




CODE:
Example 2: Using STRREAD to read the words in a line

% This command uses the cell array created in Example 1 to
% read in each word of line 28 in 'file' to a cell array, words

words = strread(file{28},'%s','delimiter','')


CODE:
Example 3: Using TEXTREAD to read in text and numeric data from a file
with headers

% This command skips the 2 header lines at the top of the file
% and reads in each column to the 4 specified outputs

[c1 c2 c3 c4] = textread('sample_file2.txt','%s %s %s
%s','headerlines',2)


CODE:
Example 4: Using TEXTREAD to read in specific rows of text and numeric
data from a file

% This command reads in rows B and C of the file. The 'headerlines'
% property is used to move down to the desired starting row and the
% read operation is performed 2 times

[c1 c2 c3 c4] = textread('sample_file2.txt',...
'%s %s %s %s',2,'headerlines',4)


CODE:
Example 5: Using TEXTREAD to read in only the numeric data from a file
containing text and numbers

% This command reads in only the numeric data in the file. The
% 'headerlines' property is used to move down to the first row
% of interest and the first column of text is ignored with the
% '*' operator

[c2 c3 c4] = textread('sample_file2.txt','%*s %d %d
%f','headerlines',3)


*DLMREAD/DLMWRITE/CSVREAD*



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/dlmread.html][DLMREAD]]
和
[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/dlmwrite.html][DLMWRITE]]函数能够读写分隔的ASCII
data，而不是用low level routines。他们比low level routines容易使用，Low
level routines用几行代码实现的功能可以用DLMREAD/DLMWRITE简化成一行。



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/csvread.html][CSVREAD]]用来读分隔符是逗号的文件，是[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/dlmread.html][DLMREAD]]的特殊情况。当读空格和Tab分隔的电子数据表文件时，[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/dlmread.html][DLMREAD]]特别有用。以[[http://www.mathworks.com/support/tech-notes/1600/1602_files/sample_file.txt]['sample_file.txt']]为例：




CODE:
Example 1: Using DLMREAD to read in a file with headers, text, and
numeric data

% This reads in the file 'sample_file2.txt' and creates a matrix, D,
% with the numeric data this command specifies a white space as the
% delimiter of the file

D = dlmread('sample_file.txt','')


CODE:
Example 2: Using DLMREAD to extract the first 3 columns of the last 3
rows

% This reads in the first 3 columns of the last 3 rows of
% the data file 'sample_file.txt'into the matrix, D_partial.
% 读文件 'sample_file.txt' 前3列后3行，到矩阵D_partial.

D_partial = dlmread('sample_file.txt','',[2 0 4 2])



CODE:
Example 3: Using DLMWRITE to write a comma delimited file

% This creates a file called 'partialD.txt' that consists of
% the first 3 columns of the last 3 rows of data where each
% element is separated by a comma

dlmwrite('partialD.txt',D_partial,',')



注意: 保证DLMREAD and DLMWRITE指定范围的指标从0开始，而不是从1开始。



*WK1READ/WK1WRITE
*



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/wk1read.html][WK1READ]]
用来读Lotus123
电子数据表文件的数据；[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/wk1write.html][WK1WRITE]]用来写矩阵到Lotus123
电子数据表文件。



*XLSREAD*



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/xlsread.html][XLSREAD]]用来读Excel的数值和文本数据。





*三. 具体例子分析：
*Matlab网站用两个例子非常详尽地介绍了各个命令的基本用法，实际中，面对手头上的数据，如何选用合适的命令呢？以下结合几个示例给出一些总结，大家举一反三就可以了：

*1. 纯数据（列数相同）：
源文件：*



CODE:
0 3866.162 2198.938 141.140
1 3741.139 2208.475 141.252
2 3866.200 2198.936 141.156
3 3678.048 2199.191 141.230
4 3685.453 2213.726 141.261
5 3728.769 2212.433 141.277
6 3738.785 2214.381 141.256
7 3728.759 2214.261 141.228
8 3748.886 2214.299 141.243
9 3748.935 2212.417 141.253
10 3733.612 2226.653 141.236
11 3733.583 2229.248 141.223
12 3729.229 2229.118 141.186




*解答*：对于这个txt文件，由于各行列数相同，故简单地使用load,importdata均可。


*2.字段名（中、英文字段均可）+数据：*
*源文件：*


CODE:
CH0 CH1 CH2 CH3
0.000123 0.000325 0.000378 0.000598
0.000986 0.000256 0.000245 0.000698


*解答*：由于是记录的形式，因此各行列数必相同（缺少部分列时请自行在文件中补上
Inf 或 NaN），故直接使用 importdata 便可。

*3.注释（含有独立的数字串）+数据（列数相同）：*
*问题*：这个文件有4列,但前6行是文字说明,4列数字是从第8行开始的.现在我想把这个文件的前2列和文字说明提出来组成一个新的dat文件

*源文件：*


CODE:
Group 2 12.02.2006   Limei
Samples of datas: 50000

CH0 CH1 CH2 CH3
0.000123 0.000325   0.000378   0.000598
0.000986 0.000256   0.000245   0.000698


*目标文件：
*

CODE:
Group 2 12.02.2006 Limei
Samples of datas: 50000

CH0 CH1
0.000123 0.000325
0.000986 0.000256


*解答*：由于注释中含有独立的数字串，且注释部分没有明显的格式，
这时候用importdata, load等高级命令直接读取会失败，用 textread, dlmwrite
等格式化命令也不太合适，因此只能使用低级命令进行读取。（当然了，可以跳过注释部分直接用高级命令读取数据，即：[a
b c d] = textread(filename,'%f %f %f %f','headerlines',4);
）。一个简单的、非通用的包含注释的读取方法如下：
-------------------------------------转
---------------------------------------------------------------------------------------

CODE:
clc;clear;
fid = fopen('exp.txt', 'r');
fid_n=fopen('ex.dat','w');
while ~feof(fid)
    tline=fgetl(fid);
    if ~isempty(tline)
     if double(tline(1))>=48 && double(tline(1))<=57 %数值开始
         a=strread(tline);
         a(3:4)=[];
         fprintf(fid_n,'%f %f\n',a);
         clear a;
     elseif double(tline(1))==67   %字母C开始
       [b1,b2,b3,b4]=strread(tline,'%s %s %s %s');
       b=[b1{1},' ',b2{1}];
         fprintf(fid_n,'%s\n',b);
         clear b b1 b2 b3 b4;
     else
         fprintf(fid_n,'%s\n',tline);
     end
    else
     fprintf(fid_n,'%s\n',tline);
    end
end
fclose(fid);
fclose(fid_n);


---------------------------------------------------------------------------------

*4. 注释（不含独立的数字串）+数据（列数相同）：*
*源文件：*

CODE:
你好 abc
欢迎来到 我们
振动论坛
vib.hit.edu.cn
1 11 111 1111
2 22 222 2222
3 33 333 3333
4 44 444 4444
5 55 555 5555


*解答：*直接用 importdata 便可

*注：*有时候注释中含有独立的数字串也可以 importdata
成功，不过得到的结果有可能不正确，建议这时候使用第3种情形的读取方式。

*5. 注释与数据混排：*
对此当然只能自己编程，举例：

*源文件*：

CODE:
1 11 111 1111
你好
2 22 222 2222
欢迎来到
3 33 333 3333
振动论坛
4 44 444 4444
vib.hit.edu.cn
5 55 555 5555


*解答：*
--------------------------------------------转--------------------------------------


CODE:

function [data]=distilldata(infile)
%功能说明：
%将保存数据的原始文件中的数值数据读入到一个data变量中
%使用说明：
% infile------原始数据文件名;
% data=数据变量

tmpfile='tmp2.mat';

fidin=fopen(infile,'r'); % 打开原始数据文件（.list）

fidtmp=fopen(tmpfile,'w'); % 创建保存数据文件（不含说明文字）

while ~feof(fidin) % 判断是否为文件末尾
 tline=fgetl(fidin); % 从文件读入一行文本（不含回车键）
 if ~isempty(tline) % 判断是否空行
    [m,n]=size(tline);
    flag=1;
    for i=1:n %判断一行中有没有字符（＋－.Ee和空格键除外）
     if ~(tline(i)==' '|tline(i)=='-'|tline(i)=='.'|tline(i)=='E'...
        |tline(i)=='e'|tline(i)=='+'...
        |(double(tline(i))>=48&&double(tline(i))<=57))
     flag=0;
     break;
     end
    end
    if flag==1 % 如果是数字行，把此行数据写入文件
     fprintf(fidtmp,'%s\n',tline);
    end
 end
end

fclose(fidin);

fclose(fidtmp);

data=textread(tmpfile);

delete(tmpfile);



---------------------------------------------------------------------------------------------------------
另外，如果要求不高，也可以使用 textread
函数跳过注释部分进行读取，不过前提是需要事先知道文件内容的结构（即哪行是数据、哪行是注释）

*6.各列数据的分离：
源文件：*


CODE:
       0 + 47038.7   1.05 09:26:07 C
       2 + 46477.7   1.03 09:28:38 C
       4 + 44865.7   1.04 09:28:48 C
       6 + 41786.4   1.03 09:28:56 C
       8 + 39896.0   0.97 09:29:03 C
        10 + 37518.4   0.93 09:29:15 C
        12 + 35858.5   0.92 09:29:30 C
        14 + 46105.0   1.03 09:30:21 C
        16 + 46168.6   6.89 09:30:30 C
        18 + 48672.3   4.33 09:30:40 C
        20 + 49565.7   0.49 09:30:48 C
        22 + 49580.7   0.53 09:30:55 C
        24 + 49602.3   0.84 09:31:03 C
        26 + 49582.5   1.51 09:31:11 C
        28 + 49577.0   1.39 09:31:19 C
        30 + 49589.3   0.61 09:31:27 C
        32 + 49578.3   1.06 09:31:29 C
        34 + 49512.5   1.77 09:31:38 C




*解答：*直接用 [a,b,c,d,e,f]=textread(yourfilename,'%d %c %f %f %s %c');
便可


*四. 注意事项：*



1. 请在 matlab
中保持当前路径在该数据文件对应的目录下进行存取，否则，存取时请给出该数据文件的具体路径。




2. 存取时，请给出该数据文件的全称（包括后缀名，读取mat文件时可省略）




3. load data.txt和A=load(‘data.txt')的区别请参阅精华贴：




4. 请根据读写需要来打开文件，即根据你的需要来指定 fopen 的 permission
属性为读或写。如果只用 a 进行写入，就不能用 fread
读取。此时应该写完关闭文件，然后用 r 打开读取，或者直接用 a+
进行同时读写操作。否则，会产生莫名其妙的问题！以下代码是一个错误的例子：




CODE:

filename='e.dat';
fid=fopen(filename,'a');
if fid<0
    error('fopen error');
end
s=[1 2 3 4;5 6 7 8];
fwrite(fid,s,'float32')
[dd ll]=fread(fid,inf,'float32');％把t中的数据全部读出，即s矩阵。
fclose(fid);






此时得到的dd, ll 是错误且无意义的！


*五. 其他相关问题：*

*1. 连续读取多个文件的数据，并存放在一个矩阵中：*
*(1) 首先是如何读取文件名：*
*方法一：
*filename=dir(‘*.jpg');
那么第i个文件的文件名就可以表示为
filename(i).name
文件数量为：length(filename)

*方法二：*
先在Windows的 MSDOS（命令行）中使用以下命令生成一个list.txt文件：



dir path\folder /on /b /s > path\list.txt




举例：dir d:\test /on /b /s > d:\list.txt




然后在 matlab 中使用：




filename = textread(sFileFullName,'%s');




把所有文件名读取到list细胞矩阵中，最后对filename{i}便可得到各文件名。


*(2) 然后是读取文件名的数据并存储：*
假设每个文件对应的数据是m*n的，则：

CODE:
k = length(filename);

Data = zeros(m,n,k);

for ii = 1:k
 Data(:,:,ii) = yourreadstyle(filename{ii});
%yourreadstyle是对应的文件读取方式的函数
end




*2. 连续读取多个文件的数据，并存放在多个矩阵（以文件名命名）中：*
假设每个文件对应的数据是m*n的，则以上述第二种文件名读取方法为例：

CODE:
k = length(filename);
for ii = 1:k
 D = yourreadstyle(filename{ii});
eval([‘Data_', num2str(ii), ‘ = D;']);
end



*3. 文件名命名问题：*
文件名为 abc00001,abc00002,... abc00009,abc00010,...
abc00099,abc00100,...abc00879. 准备把这些文件名给放到一个数组里面去。

*解答：*

CODE:
a=cell(879,1);
for k=1:879
   a{k} = sprintf('%.5d',k);
end


*4.
上述各种文件格式、类型自动识别问题*：可以利用正则表达式来处理，使之通用性较强。例如使用以下代码可以自动处理上面提到了例1到例5各种情形，不过由于存在自动判断，对某些例子（如例1）效率自然要低一点，而对于另外的例子（如例3、例5）效率估计要高一点（少用了一个循环）。


CODE:

function [data]=distilldata_eight(infile)
%功能说明：
%将保存数据的原始文件中的数值数据读入到一个data变量中（自动判断数据行）
%使用说明：
% infile------原始数据文件名;
% data=数据变量

tmpfile='tmp2.mat';

fidin=fopen(infile,'r'); % 打开原始数据文件（.list）

fidtmp=fopen(tmpfile,'w'); % 创建保存数据文件（不含说明文字）

while ~feof(fidin) % 判断是否为文件末尾
 tline=fgetl(fidin); % 从文件读入一行文本（不含回车键）
 if ~isempty(tline) % 判断是否空行
    str = '[\^0-9 | \. | \- | \s | e | E]';
%正则表达式为：该行中是否包含除 - . E e 数字 和 空白字符 外的其他字符
    start = regexp(tline,str, 'once');
    if isempty(start)
     fprintf(fidtmp,'%s\n',tline);
    end
 end
end

fclose(fidin);

fclose(fidtmp);

data=textread(tmpfile);

delete(tmpfile)



*5. 大量数据的读取问题：*
可以考虑使用循环分批读取（特别是在各数据是独立的时候），或者使用稀疏矩阵来实现。另外，也可参考《深入浅出MATLAB
7_X混合编程》一书第一章

*6. 读取整个txt文件的内容（获得文件中的所有字符）：*

CODE:

f = fopen('yourfilename.txt','rt'); % t 属性根据需要可省略
x = fread(f,'*char');
fclose(f);


*7. 把维数不同的矩阵及其变量名保存到一个 txt 文件中，例如 a1 = 123; a2 =
[1 2 3;4 5 6] ，希望得到的 txt 文件如下：*
*

QUOTE:
*
*a1：
123
a2：
1 2 3
4 5 6
*
*


*
如果写入的时候简单一点，则可以采用以下方式，不过读取的时候比较麻烦：

CODE:

a1=123;
a2=[1 2 3;4 5 6];
fid = fopen('myfile.txt', 'wt');
for i=1:2
    fprintf(fid, '%s: \n %s\n', ['a',int2str(i)],
mat2str(eval(['a',int2str(i)])));
end
fclose(fid);


相反，如果写入的时候复杂一点，则读取的时候会简单一点：

CODE:

a1=123;
a2=[1 2 3;4 5 6];
fid = fopen('myfile.txt', 'wt');
for i=1:2
    fprintf(fid, '%s: \n', ['a',int2str(i)]);
    b = eval(['a',int2str(i)]);
    fprintf(fid, [repmat('%d ', 1, size(b,2)), '\n'], b');
end

** SDK
软件开发工具包（Software Development Kit, SDK）一般是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等创建应用软件的开发工具的集合。

它或许只是简单的为某个程序设计语言提供应用程序接口的一些文件，但也可能包括能与某种嵌入式系统通讯的复杂的硬件。一般的工具包括用于调试和其他用途的实用工具。SDK还经常包括示例代码、支持性的技术注解或者其他的为基本参考资料澄清疑点的支持文档。

软件工程师通常从目标系统开发者那里获得软件开发包。为了鼓励开发者使用其系统或者语言，许多SDK是免费提供的。SDK经常可以直接从互联网下载。有时也被作为营销手段。例如，甲产品或许会免费提供构件SDK以鼓励人们使用它，从而会吸引更多人由于能免费为其编程而购买其构件。

SDK可能附带了使其不能在不兼容的许可证下开发软件的许可证。例如一个专有的SDK可能与自由软件开发抵触。而GPL能使SDK与专有软件开发近乎不兼容。LGPL下的SDK则没有这个问题。

举例
Microsoft的DirectX SDK
iOS的iOS软件开发工具包
Sun Microsystems的Java SDK
构件工具包
英特尔AMT的SDK
Google的Android SDK

** 缩写词索引

** [[http://blog.sina.com.cn/s/blog_7ca994b80101b08l.html][TTL电平与RS232电平]]

之前一直没把他们当回事，真正到用的时候才知道，理解他们很重要。
什么是TTL电平、CMOS电平、RS232电平？它们有什么区别呢？一般说来，CMOS电平比TTL电平有着更高的噪声容限。

  （一）、TTL电平标准
输出 L： <0.8V ； H：>2.4V。
输入 L： <1.2V ； H：>2.0V
TTL器件输出低电平要小于0.8V，高电平要大于2.4V。输入，低于1.2V就认为是0，高于2.0就认为是1。于是TTL电平的输入低电平的噪声容限就只有(0.8-0)/2=0.4V，高电平的噪声容限为(5-2.4)/2=1.3V。

  （二）、CMOS电平标准

输出 L： <0.1*Vcc ； H：>0.9*Vcc。
输入 L： <0.3*Vcc ； H：>0.7*Vcc.
由于CMOS电源采用12V，则输入低于3.6V为低电平，噪声容限为1.8V，高于3.5V为高电平，噪声容限高为1.8V。比TTL有更高的噪声容限。

   （三）、RS232标准

逻辑1的电平为-3～-15V，逻辑0的电平为+3～+15V，注意电平的定义反相了一次。

** [[http://blog.csdn.net/yhf19881015/article/details/9048165][非常全的linux面试笔试题及参考答案]]


[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

linux开发/（23）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/yhf19881015/article/category/1192537][作者同类文章]]/X/

求职专题/（9）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/yhf19881015/article/category/1588327][作者同类文章]]/X/

一．填空题：\
 1.
在[[http://www.linux521.com/2009/system/][Linux系统]]中,以 文件 方式访问设备
.\
 2. Linux内核引导时,从文件/etc/fstab 中读取要加载的文件系统.\
 3. Linux文件系统中每个文件用 i节点来标识.\
 4. 全部磁盘块由四个部分组成,分别为引导块 、专用块 、 i节点表块
和数据存储块.\
 5. 链接分为： 硬链接 和 符号链接 .\
 6. 超级块包含了i节点表 和 空闲块表等重要的文件系统信息.\
 7.
某文件的权限为：d-rw-_r--_r--,用数值形式表示该权限,则该八进制数为： 644 ,该文件属性是 目录 .\
 8. 前台起动的进程使用 Ctrl c 终止.\
 9.
静态路由设定后,若网络拓扑结构发生变化,需由系统管理员修改路由的设置.\
 10. 网络管理的重要任务是： 控制 和 监控 .\
 11.
安装Linux系统对硬盘分区时,[[http://www.linux521.com/bixu.GIF]]有两种分区类型： 文件系统分区
和 交换分区 .\
 13.
编写的Shell程序运行前[[http://www.linux521.com/bixu.GIF]]赋予该脚本文件 执行 权限.\
 14.
系统管理的任务之一是能够在 分布式 环境中实现对程序和数据的[[http://www.linux521.com/2009/security/][安全]]保护、备份、恢复和更新.\
 15. 系统交换分区是作为系统虚拟存储器 的一块区域.\
 16. 内核分为 进程管理系统 、 内存管理系统 、 I/O管理系统
和文件管理系统 等四个子系统.\
 17. 内核配置是系统管理员在改变系统配置 硬件 时要进行的重要操作.\
 18.
在安装Linux系统中,使用netconfig程序对网络进行配置,该安装程序会一步步提示用户输入主机名、域名、域名服务器、IP地址、 网关地址
和 子网掩码 等必要信息.\
 19. 唯一标识每一个用户的是用户 ID 和用户名.\
 20 . RIP 协议是最为普遍的一种内部协议,一般称为动态路由信息协议.\
 21.
在Linux系统中所有内容都被表示为文件,组织文件的各种方法称为 文件系统 .\
 22. DHCP可以实现动态 IP 地址分配.\
 23. 系统网络管理员的管理对象是服务器、 用户 和服务器的进程
以及系统的各种资源.\
 24.
网络管理通常由监测、传输和管理三部分组成,其中管理部分是整个网络管理的中心.\
 25. 当想删除本系统用不上的 设备驱动程序
时[[http://www.linux521.com/bixu.GIF]]编译内核,当内核不支持系统上的
设备驱动程序 时,[[http://www.linux521.com/bixu.GIF]]对内核 升级 .\
 26 Ping命令可以测试网络中本机系统是否能到达 一台远程主机
,[[http://www.linux521.com/suoyi.GIF]]常常用于测试网络的 连通性 .\
 27. vi编辑器具有两种工作模式： 命令模式 和 输入模式 .\

28. 可以用ls
&ndash;al命令来观察文件的权限,每个文件的权限都用10位表示,并分为四段,其中第一段占
1 位,表示 文件类型 ,第二段占3位,表示 文件所有者 对该文件的权限.

29.
进程与程序的区别在于其动态性,动态的产生和终止,从产生到终止进程可以具有的基本状态为：
运行态 、 就绪态 和 等待态（阻塞态） .\
 30.
DNS实际上是分布在internet上的主机信息的[[http://www.linux521.com/2009/database/][数据库]],其作用是实现
IP地址和主机名 之间的转换.\
 31.
Apache是实现WWW服务器功能的应用程序,即通常所说的浏览web服务器,在服务器端
为用户提供浏览 web服务 的就是apache应用程序.\
 32. 在Linux系统上做备份可以有两种类型：系统备份 和 用户备份
.其中前者是指对 操作系统 的备份,后者是指对 应用程序和用户文件的备份.\
 33. CD-ROM标准的文件系统类型是 iso9660 .\
 34. 当lilo.conf配置完毕后,使之生效,应运行的命令及参数是 lilo .\
 35. 在使用ls命令时,用八进制形式显示非打印字符应使用参数 -b .\
 36. Linux使用支持Windows 9.x/2000长文件名的文件系统的类型是 vfat .\
 37. 设定限制用户使用磁盘空间的命令是 quota .\
 38 在Linux系统中,用来存放系统所需要的配置文件和子目录的目录是 /etc .\
 39. 硬连接只能建立对 文件 链接.符号链接可以跨不同文件系统创建.\
 40. 套接字文件的属性位是 s .\
 41. 结束后台进程的命令是 kill .\
 42. 进程的运行有两种方式,即 独立运行和使用父进程运行 .\
 43. Links分为 硬链接和符号链接 .\
 44. 在超级用户下显示Linux系统中正在运行的全部进程,应使用的命令及参数是
ps -aux .\
 45. 管道文件的属性位是 p .\
 46. 将前一个命令的标准输出作为后一个命令的标准输入,称之为 管道 .\
 47. 为脚本程序指定执行权的命令及参数是 chmod a x filename .\
 48. 进行远程登录的命令是 telnet .\

49.
欲发送10个分组报文测试与主机abc.tuu.edu.cn的连通性,应使用的命令和参数是：
ping abc.tuu.edu.cn &ndash;c 10 .\
 50. DNS服务器的进程命名为named,当其启动时,自动装载 /etc目录下的
named.conf 文件中定义的DNS分区数据库文件.\
 51. Apache服务器进程配置文件是 httpd.conf .52.在
Linux系统中,压缩文件后生成后缀为.gz文件的命令是 gzip .\
 53. 在用vi编辑文件时,将文件内容存入test.txt文件中,应在命令模式下键入
：w test.txt .\
 54 可以在标准输出上显示整年日历的命令及参数是 cal -y .\
 55.
在shell编程时,使用方括号表示测试条件的规则是：方括号两边[[http://www.linux521.com/bixu.GIF]]有
空格 .\
 56.
检查已安装的文件系统/dev/had5是否正常,若检查有错,则自动修复,其命令及参数是
fsck &ndash;a /dev/had5 .\
 57. 在Windows9.x环境下共享Unix/Linux中的用户目录的一个工具是
Samba服务器 .\
 58.
系统管理员的职责是进行系统资源管理、系统性能管理、设备管理、安全管理和
系统性能监测 .\
 59
在Linux系统中,测试DNS服务器是否能够正确解析域名的的客户端命令,使用命令
nslookup .\
 60. 在Linux系统下,第二个IDE通道的硬盘（从盘）被标识为 hdb .\
 61. 当系统管理员需升级内核版本和改变系统硬件配置时,应 重新编译内核 .\
 62. 如果只是要修改系统的IP地址,应修改 /etc/rc.d/rc.inet1 配置文件.\
 63.
当LAN内没有条件建立DNS服务器,但又想让局域网内的用户可以使用计算机名互相访问时,应配置
/etc/hosts 文件.\
 64. 在vi编辑环境下,使用 Esc键 进行模式转换.\
 65. Slackware Linux 9.0通常使用 ext3 文件系统,系统的全部磁盘块由 四
部分组成.\
 66.
将/home/stud1/wang目录做归档压缩,压缩后生成wang.tar.gz文件,并将此文件保存到/home目录下,实现此任务的tar命令格式
tar zcvf /home/wang.tar.gz /home/stud1/wang .\

67. 管道就是将前一个命令的 标准输出 作为后一个命令的 标准输入 .\
 68. 在使用手工的方法配置网络时,可通过修改 /etc/HOSTNAME
文件来改变主机名,若要配置该计算机的域名解析客户端,需配置
/etc/resolv.conf 文件.\
 69. 启动进程有手动启动和调度启动两种方法,其中调度启动常用的命令为 at 、
batch 和 crontab .\
 70. test.bns.com.cn的域名是 bns.com.cn ,如果要配置一域名服务器,应在
named.conf 文件中定义DNS数据库的工作目录.\
 71. Sendmail邮件系统使用的两个主要协议是： SMTP 和 POP
,前者用来发送邮件,后者用来接收邮件.\
 72. DHCP是动态主机配置协议的简称,其作用是：为网络中的主机分配IP地址 .\
 73. 目前代理服务器使用的软件包有很多种,教材中使用的是 squid .\
 74. rm命令可删除文件或目录,其主要差别就是是否使用递归开关 -r或-R .\
 75. mv 命令可以移动文件和目录,还可以为文件和目录重新命名.\
 76.
路由选择协议（RIP）的跳数表示到达目的地之前[[http://www.linux521.com/bixu.GIF]]通过的
网关 数,RIP接受的最长距离是 15跳 .\
 77. ping命令用于测试网络的连通性,ping命令通过 ICMP
协议（internet控制信息协议）来实现.\
 78. nfs 协议用于实现Unix（/linux）主机之间的文件系统共享.\
 79. 在Linux操作系统中,设备都是通过特殊的 文件 来访问.\
 80. shell不仅是 用户命令的解释器 ,它同时也是一种功能强大的编程语言.
bash是Linux的缺省shell.\
 81. 用 〉;〉; 符号将输出重定向内容附加在原文的后面.\
 82. 增加一个用户的命令是：adduser 或useradd .\
 83 进行字符串查找,使用grep命令.\
 84. 使用 * 每次匹配若干个字符.\
 85. /sbin 目录用来存放系统管理员使用的管理程序.

\

二．单项选择题:\

1. 下面的网络协议中,面向连接的的协议是： A .\
 A 传输控制协议 B 用户数据报协议 C 网际协议 D 网际控制报文协议\
 2. 在/etc/fstab文件中指定的文件系统加载参数中, D
参数一般用于CD-ROM等移动设备.\
 A defaults B sw C rw和ro D noauto\
 3. Linux文件权限一共10位长度,分成四段,第三段表示的内容是 C .\
 A 文件类型 B 文件所有者的权限 \
 C 文件所有者所在组的权限 D 其他用户的权限\
 4. 终止一个前台进程可能用到的命令和操作 B .\
 A kill B 〈CTRL〉; C C shut down D halt\
 5．在使用mkdir命令创建新的目录时,在其父目录不存在时先创建父目录的选项是
D .\
 A -m B -d C -f D -p\
 6. 下面关于i节点描述错误的是
A .（inode是一种数据结构,vfs中描述文件的相关参数？？）\
 A i节点和文件是一一对应的\
 B i节点能描述文件占用的块数\
 C i节点描述了文件大小和指向数据块的指针\
 D 通过i节点实现文件的逻辑结构和物理结构的转换\
 7. 一个文件名字为rr.Z,可以用来解压缩的命令是： D .\
 A tar B gzip C compress D uncompress\
 8. 具有很多C语言的功能,又称过滤器的是 C .\
 A csh\
 B tcsh\
 C awk　　（awk详解）\
 D sed\
 9. 一台主机要实现通过局域网与另一个局域网通信,需要做的工作是 C .A
配置域名服务器\
 B 定义一条本机指向所在网络的路由\
 C 定义一条本机指向所在网络网关的路由\
 D 定义一条本机指向目标网络网关的路由\
 10. 建立动态路由需要用到的文件有 D .\
 A /etc/hosts B /etc/HOSTNAME C /etc/resolv.conf D /etc/gateways\
 11.
局域网的网络地址192.168.1.0/24,局域网络连接其它网络的网关地址是192.168.1.1.主机192.168.1.20访问172.16.1.0/24网络时,其路由设置正确的是
B .\

A route add &ndash;net 192.168.1.0 gw 192.168.1.1 netmask 255.255.255.0
metric 1\
 B route add &ndash;net 172.16.1.0 gw 192.168.1.1 netmask
255.255.255.255 metric 1\
 C route add &ndash;net 172.16.1.0 gw 172.16.1.1 netmask 255.255.255.0
metric 1\
 D route add default 192.168.1.0 netmask 172.168.1.1 metric 1\
 12. 下列提法中,不属于ifconfig命令作用范围的是 D .\
 A 配置本地回环地址 B 配置网卡的IP地址\
 C 激活网络适配器 D 加载网卡到内核中\
 13. 下列关于链接描述,错误的是 B .\
 A 硬链接就是让链接文件的i节点号指向被链接文件的i节点\
 B 硬链接和符号连接都是产生一个新的i节点\
 C 链接分为硬链接和符号链接 D 硬连接不能链接目录文件\
 14.
在局域网络内的某台主机用ping命令测试网络连接时发现网络内部的主机都可以连同,而不能与公网连通,问题可能是
C.\
 A 主机IP设置有误\
 B 没有设置连接局域网的网关\
 C 局域网的网关或主机的网关设置有误\
 D 局域网DNS服务器设置有误\
 15. 下列文件中,包含了主机名到IP地址的映射关系的文件是： B .\
 A /etc/HOSTNAME B /etc/hosts C /etc/resolv.conf D /etc/networks\
 16. 不需要编译内核的情况是 D .\
 A 删除系统不用的设备驱动程序时 B 升级内核时\
 C 添加新硬件时 D 将网卡激活\
 17. 在shell中变量的赋值有四种方法,其中,采用name=12的方法称 A .\
 A 直接赋值 B使用read命令\
 C 使用命令行参数 D使用命令的输出\
 18. D 命令可以从文本文件的每一行中截取指定内容的数据.\
 A cp B dd C fmt D cut\
 19. 下列不是Linux系统进程类型的是 D .\
 A 交互进程 B 批处理进程 C 守护进程 D 就绪进程（进程状态）\
 20．配置Apache 1.3.19服务器需要修改的配置文件为___A______\

A httpd.conf B access.conf C srm.conf D named.conf\
 21. 内核不包括的子系统是 D .\
 A 进程管理系统 B 内存管理系统 C I/O管理系统 D硬件管理系统\
 22． 在日常管理中,通常CPU会影响系统性能的情况是： A .\
 A CPU已满负荷地运转 B CPU的运行效率为30%\
 C CPU的运行效率为50% D CPU的运行效率为80%\
 23． 若一台计算机的内存为128MB,则交换分区的大小通常是 C .\
 A 64MB B 128MB C 256MB D 512MB\
 24．
在安装Linux的过程中的第五步是让用户选择安装方式,如果用户希望安装部分组件（软件程序）,并在选择好后让系统自动安装,应该选择的选项是
D .\
 A full B expert C newbie D menu\
 25．
Linux有三个查看文件的命令,若希望在查看文件内容过程中可以用光标上下移动来查看文件内容,应使用
C 命令.\
 A cat B more C less D menu\
 26． 下列信息是某系统用ps &ndash;ef命令列出的正在运行的进程, D
进程是运行Internet超级服务器,它负责监听Internet
sockets上的连接,并调用合适的服务器来处理接收的信息.\
 A root 1 4.0 0.0 344 204? S 17:09 0:00 init \
 B root 2 0.0 0.1 2916 1520? S 17:09 0:00 /sbin/getty \
 C root 3 0.0 0.2 1364 632? S 17:09 0:00 /usr/sbin/syslogd \
 D root 4 0.0 1344 1204? S 17:09 0:10 /usr/sbin/inetd \
 27．在TCP/IP模型中,应用层包含了所有的高层协议,在下列的一些应用协议中, B
是能够实现本地与远程主机之间的文件传输工作.\
 A telnet B FTP C SNMP D NFS \

28．当我们与某远程网络连接不上时,就需要跟踪路由查看,以便了解在网络的什么位置出现了问题,满足该目的的命令是
C .\
 A ping B ifconfig C traceroute D netstat\
 29．对名为fido的文件用chmod 551 fido 进行了修改,则它的许可权是 D .\

A -rwxr-xr-x B -rwxr--r-- C -r--r--r-- D -r-xr-x-x\
 30．
在i节点表中的磁盘地址表中,若一个文件的长度是从磁盘地址表的第1块到第11块,则该文件共占有
B 块号.\
 A 256 B 266 C 11 D 256&times;10\
 (??)31． 用ls &ndash;al 命令列出下面的文件列表, D 文件是符号连接文件.\
 A -rw-rw-rw- 2 hel-s users 56 Sep 09 11:05 hello\
 B -rwxrwxrwx 2 hel-s users 56 Sep 09 11:05 goodbey\
 C drwxr--r-- 1 hel users 1024 Sep 10 08:10 zhangD lrwxr--r-- 1 hel
users 2024 Sep 12 08:12 cheng\
 32． DNS域名系统主要负责主机名和 A 之间的解析.\
 A IP地址 B MAC地址 C 网络地址 D 主机别名\
 33． WWW服务器是在Internet上使用最为广泛,它采用的是 B 结构.\
 A 服务器/工作站 B B/S C 集中式 D 分布式\
 34．Linux系统通过 C 命令给其他用户发消息.\
 A less B mesg y C write D echo to[ 注：mesg [y|n] 所有使用者
决定是否允许其他人传讯息到自己的终端机介面 ]\
\
\
 35．NFS是 C 系统.\
 A 文件 B 磁盘 C 网络文件 D 操作\
 36． B 命令可以在Linux的安全系统中完成文件向磁带备份的工作.\
 A cp B tr C dir D cpio[注：如果用 echo /home/wally/Program/phantomjs/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/texlive/2015/bin/x86_64-linux:/opt/crosstool-ng/bin:/home/wally/.x-tools/arm-wally-linux-gnueabi/bin:/usr/local/libexec/emacs/24.5/x86_64-unknown-linux-gnu 或者 echo
_LIBRARY_PATH
等类似的命令来显示路径信息的话,我们看到的将会是一大堆用冒号连接在一起的路径,
tr 命令可以把这些冒号转换为回车,这样,这些路径就具有很好的可读性了：\
 echo /home/wally/Program/phantomjs/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/texlive/2015/bin/x86_64-linux:/opt/crosstool-ng/bin:/home/wally/.x-tools/arm-wally-linux-gnueabi/bin:/usr/local/libexec/emacs/24.5/x86_64-unknown-linux-gnu | tr &quot;:&quot; &quot;&#92;n&quot;]\

37．Linux文件系统的文件都按其作用分门别类地放在相关的目录中,对于外部设备文件,一般应将其放在
C 目录中.\
 A /bin B /etc C /dev D /lib \
 38．在重新启动Linux系统的同时把内存中的信息写入硬盘,应使用 D
命令实现.\

A # reboot B # halt C # reboot D # shutdown &ndash;r now\
 39．网络管理具备以下几大功能：配置管理、 A
、性能管理、安全管理和计费管理等.\
 A 故障管理 B 日常备份管理 C 升级管理 D 发送邮件\
 40．关于代理服务器的论述,正确的是 A .\
 A 使用internet上已有的公开代理服务器,只需配置客户端.\
 B 代理服务器只能代理客户端http的请求.\
 C 设置好的代理服务器可以被网络上任何主机使用.\
 D 使用代理服务器的客户端没有自己的ip地址.\
 41.关闭linux系统（不重新启动）可使用命令 B .\
 A Ctrl Alt Del B halt C shutdown -r now D reboot\
 42．实现从IP地址到以太网MAC地址转换的命令为： C .\
 A ping B ifconfig C arp D traceroute\
 43．在vi编辑器中的命令模式下,键入 B 可在光标当前所在行下添加一新行.\
 A 〈a〉; B 〈o〉; C 〈I〉; D A\
 44．在vi编辑器中的命令模式下,删除当前光标处的字符使用 A 命令.\
 A 〈x〉; B 〈d〉;〈w〉; C 〈D〉; D 〈d〉;〈d〉;\
 45．在vi编辑器中的命令模式下,重复上一次对编辑的文本进行的操作,可使用 C
命令.\
 A 上箭头 B 下箭头 C 〈.〉; D 〈*〉;\
 46．用命令ls -al显示出文件ff的描述如下所示,由此可知文件ff的类型为 A .\
 -rwxr-xr-- 1 root root 599 Cec 10 17:12 ff\
 A 普通文件 B 硬链接 C 目录 D 符号链接\
 47．删除文件命令为： D .\
 A mkdir B rmdir C mv D rm\
 48．在下列的名称中,不属于DNS服务器类型的是：____C_____\
 A Primary Master Server B Secondary Master Server\
 C samba D Cache_only Server\
 49．网络管理员对WWW服务器进行访问、控制存取和运行等控制,这些控制可在 A
文件中体现.\
 A httpd.conf B lilo.conf C inetd.conf D resolv.conf\

50．邮件转发代理也称邮件转发服务器,它可以使用SMTP协议,也可以使用 C
协议. \
 A FTP B TCP C UUCP D POP\

51．启动samba服务器进程,可以有两种方式：独立启动方式和父进程启动方式,其中前者是在
C 文件中以独立进程方式启动.\
 A /usr/sbin/smbd B /usr/sbin/nmbd C rc.samba D /etc/inetd.conf\

52．DHCP是动态主机配置协议的简称,其作用是可以使网络管理员通过一台服务器来管理一个网络系统,自动地为一个网络中的主机分配___D______地址.\
 A 网络 B MAC C TCP D IP\
 53．为了保证在启动服务器时自动启动DHCP进程,应将
A文件中的dhcpd=no改为dhcpd=yes. \
 A rc.inet1 B lilo.conf C inetd.conf D httpd.conf[注：
英文原义：RC中文释义：含有程序（应用程序甚至操作系统）启动指令的脚本文件注解：这一文件在操作系统启动时会自动执行,它含有要运行的指令（命令或其它脚本）列表.]\
 54．对文件进行归档的命令为 D .\
 A dd B cpio C gzip D tar\
 55．改变文件所有者的命令为 C .\
 A chmod B touch C chown D cat\
 56．在给定文件中查找与设定条件相符字符串的命令为： A .\
 A grep B gzip C find D sort\
 57．建立一个新文件可以使用的命令为 D .\
 A chmod B more C cp D touch(指令改变档案的时间记录.)\
 58．在下列命令中,不能显示文本文件内容的命令是： D . \
 A more B less C tail D join\
 59．在使用匿名登录ftp时,用户名为 B .\
 A users B anonymous C root D guest\
 60．在实际操作中,想了解命令logname 的用法,可以键入 D 得到帮助.\
 A logname --man B logname/？ C help logname D logname --help\
 61．如果LILO被安装在MBR,使用 A 命令即可卸载LILO.\
 A lilo &ndash;u B lilo &ndash;c C lilo &ndash;v D lilo -V\

62．当用命令ls
&ndash;al查看文件和目录时,欲观看卷过屏幕的内容,应使用组合键 D .\
 A Shift Home B Ctrl PgUp C Alt PgDn D Shift PgUp\
 63．mc是UNIX风格操作系统的 C .\
 A 文件编辑器/程序编译器 B 配置网络的窗口工具 \
 C 目录浏览器/文件管理器 D Samba服务器管理工具\
 64．i节点是一个 D 长的表,表中包含了文件的相关信息.A 8字节 B 16字节 C
32字节 D 64字节\
 65．文件权限读、写、执行的三种标志符号依次是 A .\
 A rwx B xrw C rdx D srw\
 66．Linux 文件名的长度不得超过 C 个字符.\
 A 64 B 128 C 256 D 512\
 67．进程有三种状态： C .\
 A 准备态、执行态和退出态 B 精确态、模糊态和随机态\
 C 运行态、就绪态和等待态 D 手工态、自动态和自由态\
 68． 从后台启动进程,应在命令的结尾加上符号 A .\
 A &amp; B @ C # D $\
 69． B 不是邮件系统的组成部分.\
 A 用户代理 B 代理服务器 C 传输代理 D 投递代理\

70．在Shell脚本中,用来读取文件内各个域的内容并将其赋值给Shell变量的命令是
D .\
 A fold B join C tr D read\
 71．crontab文件由六个域组成,每个域之间用空格分割,其排列如下： B .\
 A MIN HOUR DAY MONTH YEAR COMMAND\
 B MIN HOUR DAY MONTH DAYOFWEEK COMMAND\
 C COMMAND HOUR DAY MONTH DAYOFWEEK \
 D COMMAND YEAR MONTH DAY HOUR MINcrontab命令：实现程序定时运行\
 72．用ftp进行文件传输时,有两种模式： C .\
 A Word和binary B .txt和Word Document \
 C ASCII和binary D ASCII和Rich Text Format\

73．某文件的组外成员的权限为只读；所有者有全部权限；组内的权限为读与写,则该文件的权限为
D .\
 A 467 B 674 C 476 D 764\
 74．在DNS系统测试时,设named进程号是53,命令 D 通知进程重读配置文件.\

A kill &ndash;USR2 53 B kill &ndash;USR1 53 C kill -INT 63 D kill
&ndash;HUP 53\
 75．Apache服务器默认的接听连接端口号是 C .\
 A 1024 B 800 C 80 (http)D 8\
 76．PHP和MySQL的联合使用解决了 C .\
 A 在Proxy上处理数据库的访问问题 B 在WWW服务器上处理黑客的非法访问问题\
 C 在WWW服务器上处理数据库的访问问题\
 D 在Sendmail邮件系统上处理数据库的访问问题\
 77．OpenSSL是一个 A .\
 A 加密软件 B 邮件系统 C 数据库管理系统 D 嵌入式脚本编程语言\
 78．Samba服务器的配置文件是 D .\
 A httpd.conf B inetd.conf C rc.samba D smb.conf\
 79．关于DNS服务器,叙述正确的是 D .\
 A DNS服务器配置不需要配置客户端\
 B 建立某个分区的DNS服务器时只需要建立一个主DNS服务器\
 C 主DNS服务器需要启动named进程,而辅DNS服务器不需要\
 D DNS服务器的root.cache文件包含了根名字服务器的有关信息\
 80．退出交互模式的shell,应键入 C .\
 A 〈Esc〉; B \^q C exit D quit\
 81．将Windows C:盘(hda1)安装在Linux文件系统的/winsys目录下,命令是 B .\
 A root@l04.edu.cn:~#mount dev/had1 /winsys \
 B root@l04.edu.cn:~#mount /dev/had1 /winsys\
 C root@l04.edu.cn:~#mount /dev/had1 winsys\
 D root@l04.edu.cn:~#mount dev/had1 winsys\

82．设超级用户root当前所在目录为：/usr/local,键入cd命令后,用户当前所在目录为
B .\
 A /home B /root C /home/root D /usr/local\
 83．字符设备文件类型的标志是 B .\
 A p B c C s D l\
 84．将光盘CD-ROM（hdc）安装到文件系统的/mnt/cdrom目录下的命令是 C .\

A mount /mnt/cdrom B mount /mnt/cdrom /dev/hdc\
 C mount /dev/hdc /mnt/cdrom D mount /dev/hdc\
 85．将光盘/dev/hdc卸载的命令是 C .\
 A umount /dev/hdc B unmount /dev/hdc\
 C umount /mnt/cdrom /dev/hdc D unmount /mnt/cdrom /dev/hdc\
 86．在/home/stud1/wang目录下有一文件file,使用 D
可实现在后台执行命令,此命令将file文件中的内容输出到file.copy文件中.\
 A cat file 〉;file.copy B cat 〉;file.copy C cat file file.copy &amp; D
cat file 〉;file.copy &amp;\
 87．在DNS配置文件中,用于表示某主机别名的是： B .\
 A NS B CNAME C NAME D CN\
 88．可以完成主机名与IP地址的正向解析和反向解析任务的命令是： A .\
 A nslookup B arp C ifconfig D dnslook\
 89．下列变量名中有效的shell变量名是： C .\
 A -2-time B _2 C trust_no_1 D 2004file\
 90．qmail是 B .\
 A 收取邮件的协议 B 邮件服务器的一种 C 发送邮件的协议 D 邮件队列\

92．已知某用户stud1,其用户目录为/home/stud1.分页显示当前目录下的所有文件的文件或目录名、用户组、用户、文件大小、文件或目录权限、文件创建时间等信息的命令是
D .\
 A more ls &ndash;al B more &ndash;al ls C more 〈 ls &ndash;al D ls
&ndash;al | more \
 93．关于进程调度命令, B 是不正确的.at--定期执行程序的调度命令\
 A 当日晚11点执行clear命令,使用at命令：at 23:00 today clearB
每年1月1日早上6点执行date命令,使用at命令：at 6am Jan 1 date\
 C 每日晚11点执行date命令,crontab文件中应为：0 23 * * * date\
 D 每小时执行一次clear命令,crontab文件中应为：0 */1 * * * clear\

94．系统中有用户user1和user2,同属于users组.在user1用户目录下有一文件file1,它拥有644的权限,如果user2用户想修改user1用户目录下的file1文件,应拥有
B 权限.\

A 744 B 664 C 646 D 746\
 95．如果想配置一台匿名ftp服务器,应修改 C 文件.\
 A /etc/gateway B /etc/ftpservers C /etc/ftpusers D /etc/inetd.conf\
 96．Samba服务器的进程由B 两部分组成 .\
 A named和sendmail B smbd和nmbd C bootp和dhcpd D httpd和squid\
 97．要配置NFS服务器,在服务器端主要配置 C 文件.\
 A /etc/rc.d/rc.inet1 B /etc/rc.d/rc.M C /etc/exports D /etc/rc.d/rc.S\
 98．为保证在启动服务器时自动启动DHCP进程,应对 B 文件进行编辑.\
 A /etc/rc.d/rc.inet2 B /etc/rc.d/rc.inet1 C /etc/dhcpd.conf D
/etc/rc.d/rc.S\
 99．在配置代理服务器时,若设置代理服务器的工作缓存为64MB,配置行应为 D
.\
 A cache 64MB B cache_dir ufs /usr/local/squid/cache 10000 16 256\
 C cache_ mgr 64MB D cache_ mem 64MB\

100．安全管理涉及的问题包括保证网络管理工作可靠进行的安全问题和保护网络用户及网络管理对象问题.
C 属于安全管理的内容.\
 A 配置设备的工作参数 B 收集与网络性能有关的数据 \
 C 控制和维护访问权限 D 监测故障\
 101．以下命令对中,正确的是： B .\
 A ls和sl B cat和tac C more和erom D
exit和tixecat是显示文件夹的命令,这个大家都知道,tac是cat的倒写,意思也和它是相反的.cat是从第一行显示到[[http://www.linux521.com/zuihou.GIF]]一行,而tac是从[[http://www.linux521.com/zuihou.GIF]]一行显示到第一行,而rev
则是从[[http://www.linux521.com/zuihou.GIF]]一个字符显示到第一个字符\
 102． B 命令是在vi编辑器中执行存盘退出.\
 A :q B ZZ C :q! D :WQ\
 103．下列关于/etc/fstab文件描述,正确的是 D .\
 A fstab文件只能描述属于linux的文件系统 B
CD_ROM和软盘[[http://www.linux521.com/bixu.GIF]]是自动加载的\
 C fstab文件中描述的文件系统不能被卸载 D
启动时按fstab文件描述内容加载文件系统\
 104．通过文件名存取文件时,文件系统内部的操作过程是通过 C .\

A 文件在目录中查找文件数据存取位置.B
文件名直接找到文件的数据,进行存取操作.\
 C 文件名在目录中查找对应的I节点,通过I节点存取文件数据.\
 D
文件名在中查找对应的超级块,在超级块查找对应i节点,通过i节点存取文件数据\
 105．Linux将存储设备和输入/输出设备均看做文件来操作, C
不是以文件的形式出现.\
 A 目录 B 软链接 C i节点表 D 网络适配器\
 106．关于i节点和超级块,下列论述不正确的是 B .\
 A i节点是一个长度固定的表 B 超级块在文件系统的个数是唯一的\
 C i节点包含了描述一个文件所必需的全部信息\
 D 超级块记录了i节点表和空闲块表信息在磁盘中存放的位置\
 107． D 设备是字符设备.\
 A hdc B fd0 C hda1 D tty1(A,B,C为块设备)\
 108． B 目录存放着Linux的源代码.\
 A /etc B /usr/src C /usr D /home\
 109．关于文件系统的安装和卸载,下面描述正确的是 A .\
 A 如果光盘未经卸载,光驱是打不开的 B 安装文件系统的安装点只能是/mnt下\
 C 不管光驱中是否有光盘,系统都可以安装CD-ROM设备\
 D mount /dev/fd0 /floppy 此命令中目录/floppy是自动生成的\
 110． B 不是进程和程序的区别.\
 A 程序是一组有序的静态指令,进程是一次程序的执行过程\
 B 程序只能在前台运行,而进程可以在前台或后台运行\
 C 程序可以长期保存,进程是暂时的\
 D 程序没有状态,而进程是有状态的\

111．文件exer1的访问权限为rw-r--r--,现要增加所有用户的执行权限和同组用户的写权限,下列命令正确的是
A .\
 A chmod a x g w exer1 B chmod 765 exer1\
 C chmod o x exer1 D chmod g w exer1\
 112．有关归档和压缩命令,下面描述正确的是 C .\

A 用uncompress命令解压缩由compress命令生成的后缀为.zip的压缩文件\
 B unzip命令和gzip命令可以解压缩相同类型的文件\
 C tar归档且压缩的文件可以由gzip命令解压缩\
 D tar命令归档后的文件也是一种压缩文件\
 113．不是shell具有的功能和特点的是 C .\
 A 管道 B 输入输出重定向 C 执行后台进程 D 处理程序命令\
 114．下列对shell变量FRUIT操作,正确的是： C .\
 A 为变量赋值：=apple B 显示变量的值：fruit=apple\
 C 显示变量的值：echo  D 判断变量是否有值：[ -f  ]\
 三．简答题：\

1．简述Linux文件系统通过i节点把文件的逻辑结构和物理结构转换的工作过程.\
 参考答案：\
 Linux通过i节点表将文件的逻辑结构和物理结构进行转换.\
 i
节点是一个64字节长的表,表中包含了文件的相关信息,其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息.在i节点表中最重要
的内容是磁盘地址表.在磁盘地址表中有13个块号,文件将以块号在磁盘地址表中出现的顺序依次读取相应的块.Linux文件系统通过把i节点和文件名进行
连接,当需要读取该文件时,文件系统在当前目录表中查找该文件名对应的项,由此得到该文件相对应的i节点号,通过该i节点的磁盘地址表把分散存放的文件物
理块连接成文件的逻辑结构.2．简述进程的启动、终止的方式以及如何进行进程的查看.\
 参考答案：\
 在Linux中启动一个进程有手工启动和调度启动两种方式：\
 （1）手工启动\
 用户在输入端发出命令,直接启动一个进程的启动方式.可以分为：\

①前台启动：直接在SHELL中输入命令进行启动.\
 ②后台启动：启动一个目前并不紧急的进程,如打印进程.\
 （2）调度启动\

系统管理员根据系统资源和进程占用资源的情况,事先进行调度安排,指定任务运行的时间和场合,到时候系统会自动完成该任务.\
 经常使用的进程调度命令为：at、batch、crontab.\
 3. 简述DNS进行域名解析的过程.\
 参考答案：\

[[http://www.linux521.com/shouxian.GIF]],客户端发出DNS请求翻译IP地址或主机名.DNS服务器在收到客户机的请求后：\

（1）检查DNS服务器的缓存,若查到请求的地址或名字,即向客户机发出应答信息；\

（2）若没有查到,则在数据库中查找,若查到请求的地址或名字,即向客户机发出应答信息；\

（3）若没有查到,则将请求发给根域DNS服务器,并依序从根域查找顶级域,由顶级查找二级域,二级域查找三级,直至找到要解析的地址或名字,即向客户机所在网络的DNS服务器发出应答信息,DNS服务器收到应答后现在缓存中存储,然后,将解析结果发给客户机.\

（4）若没有找到,则返回错误信息.4．系统管理员的职责包括那些？管理的对象是什么？\
 参考答案：\

系统管理员的职责是进行系统资源管理、设备管理、系统性能管理、安全管理和系统性能监测.管理的对象是服务器、用户、服务器的进程及系统的各种资源等.\
 5．简述安装Slackware Linux系统的过程.\
 参考答案： \
 （1）对硬盘重新分区. （2）启动Linux系统（用光盘、软盘等）.\
 （3）建立Linux主分区和交换分区.（4）用setup命令安装Linux系统.\
 （5）格式化Linux主分区和交换分区（6）安装Linux软件包\

（7）安装完毕,建立从硬盘启动Linux系统的LILO启动程序,或者制作一张启动Linux系统的软盘.重新启动Linux系统.\

6．什么是静态路由,其特点是什么？什么是动态路由,其特点是什么？\
 参考答案：\

静态路由是由系统管理员设计与构建的路由表规定的路由.适用于网关数量有限的场合,且网络拓朴结构不经常变化的网络.其缺点是不能动态地适用网络状况的变化,当网络状况变化后[[http://www.linux521.com/bixu.GIF]]由网络管理员修改路由表.\

动态路由是由路由选择协议而动态构建的,路由协议之间通过交换各自所拥有的路由信息实时更新路由表的内容.动态路由可以自动学习网络的拓朴结构,并更新路由表.其缺点是路由广播更新信息将占据大量的网络带宽.\
 87．进程的查看和调度分别使用什么命令？\
 参考答案：\
 进程查看的命令是ps和top.\
 进程调度的命令有at,crontab,batch,kill.\
 8．当文件系统受到破坏时,如何检查和修复系统？\
 参考答案：\

成功修复文件系统的前提是要有两个以上的主文件系统,并保证在修复之前[[http://www.linux521.com/shouxian.GIF]]卸载将被修复的文件系统.\

使用命令fsck对受到破坏的文件系统进行修复.fsck检查文件系统分为5步,每一步检查系统不同部分的连接特性并对上一步进行验证和修改.在执行
fsck命令时,检查[[http://www.linux521.com/shouxian.GIF]]从超级块开始,然后是分配的磁盘块、路径名、目录的连接性、链接数目以及空闲块链表、i-node.\
 9．解释i节点在文件系统中的作用.\
 参考答案：\

在linux文件系统中,是以块为单位存储信息的,为了找到某一个文件在存储空间中存放的位置,用i节点对一个文件进行索引.I节点包含了描述一个文件所[[http://www.linux521.com/bixu.GIF]]的全部信息.[[http://www.linux521.com/suoyi.GIF]]i节点是文件系统管理的一个数据结构.\
 10．什么是符号链接,什么是硬链接？符号链接与硬链接的区别是什么？\

参考答案：\
 链接分硬链接和符号链接.\

符号链接可以建立对于文件和目录的链接.符号链接可以跨文件系统,即可以跨磁盘分区.符号链接的文件类型位是l,链接文件具有新的i节点.\

硬链接不可以跨文件系统.它只能建立对文件的链接,硬链接的文件类型位是－,且硬链接文件的i节点同被链接文件的i节点相同.\

11．在对linux系统分区进行格式化时需要对磁盘簇（或i节点密度）的大小进行选择,请说明选择的原则.\
 参考答案：\

磁盘簇（或i节点密度）是文件系统调度文件的基本单元.磁盘簇的大小,直接影响系统调度磁盘空间效率.当磁盘分区较大时,磁盘簇也应选得大些；当分区较小时,磁盘簇应选得小些.通常使用经验值.\
 12．简述网络文件系统NFS,并说明其作用.\
 参考答案：\

网络文件系统是应用层的一种应用服务,它主要应用于Linux和Linux系统、Linux和Unix系统之间的文件或目录的共享.对于用户而言可以通过
NFS方便的访问远地的文件系统,使之成为本地文件系统的一部分.采用NFS之后省去了登录的过程,方便了用户访问系统资源.13．某/etc
/fstab文件中的某行如下：

\
 /dev/had5 /mnt/dosdata msdos defaults,usrquota 1 2\
 请解释其含义.\
 参考答案:\
 （1）第一列：将被加载的文件系统名；（2）第二列：该文件系统的安装点；\
 （3）第三列：文件系统的类型；（4）第四列：设置参数；\
 （5）第五列：供备份程序确定上次备份距现在的天数；\
 （6）第六列：在系统引导时检测文件系统的顺序.\
 14．Apache服务器的配置文件httpd.conf中有很多内容,请解释如下配置项：\
 （1）MaxKeepAliveRequests 200 （2）UserDir public_html\

  3）DefaultType text/plain （4）AddLanguare en.en\
 （5）DocumentRoot/usr/local/httpd/htdocs\
 （6）AddType application/x-httpd-php.php.php.php4\
 参考答案:\

（1）允许每次连接的最大请求数目,此为200；（2）设定用户放置网页的目录；\
 （3）设置服务器对于不认识的文件类型的预设格式；\

（4）设置可传送语言的文件给浏览器；（5）该目录为Apache放置网页的地方；\
 （6）服务器选择使用php4.\

15．某Linux主机的/etc/rc.d/rc.inet1文件中有如下语句,请修正错误,并解释其内容.\
 /etc/rc.d/rc.inet1：\
 &hellip;&hellip;\
 ROUTE add &ndash;net default gw 192.168.0.101 netmask 255.255.0.0
metric 1\
 ROUTE add &ndash;net 192.168.1.0 gw 192.168.0.250 netmask 255.255.0.0
metric 1\
 参考答案:\
 修正错误:\
 （1）ROUTE应改为小写：route；（2）netmask 255.255.0.0应改为:netmask
255.255.255.0；\
 （3）缺省路由的子网掩码应改为:netmask 0.0.0.0；\

（4）缺省路由[[http://www.linux521.com/bixu.GIF]]在[[http://www.linux521.com/zuihou.GIF]]设定,否则其后的路由将无效.\
 解释内容:\
 （1）route：建立静态路由表的命令；（2）add：增加一条新路由；\
 （3）-net 192.168.1.0：到达一个目标网络的网络地址；\
 （4）default：建立一条缺省路由；（5）gw 192.168.0.101：网关地址；\
 （6）metric
1：到达目标网络经过的路由器数（跳数）.16．试解释apache服务器以下配置的含义： \
 （1）port 1080 （2）UserDir userdoc\
 （3）DocumentRoot /home/htdocs\
 （4）〈Directory /home/htdocs/inside〉;\
 Options Indexes FollowSymLinks\
 AllowOverride None\
 Order deny,allow\
 deny from all\
 allow from 192.168.1.5\
 〈/Directory〉;\
 （5）Server Type Standlone\

Apache服务器配置行含义如下： \
 （1）将apache服务器的端口号设定为1080；\
 （2）设定用户网页目录为userdoc；\
 （3）设定apache服务器的网页根目录:/home/htdocs；\

（4）在此apache服务器上设定一个目录/home/htdocs/inside,且此目录只允许IP地址为192.168.1.5的主机访问；\
 （5）定义apache服务器以独立进程的方式运行.\

17．简述使用ftp进行文件传输时的两种登录方式？它们的区别是什么？常用的ftp文件传输命令是什么？ \
 参考答案：\

（1）ftp有两种登录方式：匿名登录和授权登录.使用匿名登录时,用户名为：anonymous,密码为：任何合法email地址；使用授权登录时,用户名为用户在远程系统中的用户帐号,密码为用户在远程系统中的用户密码.\

区别：使用匿名登录只能访问ftp目录下的资源,默认配置下只能下载；而授权登录访问的权限大于匿名登录,且上载、下载均可.\

（2）ftp文件传输有两种文件传输模式：ASCII模式和binary模式.ASCII模式用来传输文本文件,其他文件的传输使用binary模式.\

（3）常用的ftp文件传输命令为：bin、asc、put、get、mput、mget、prompt、bye\: openFile: invalid argument (File name too long)

** [[http://blog.csdn.net/kof2001kop/article/details/7425186][在函数内定义“局部函数”]]



[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

c++/（9）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/kof2001kop/article/category/1071916][作者同类文章]]/X/

版权声明：本文为博主原创文章，未经博主允许不得转载。

 在函数里也能定义函数？呵呵，这当然是不能的，但函数对象却是可以的。如果用旧的方法去定义一个函数对象，那就还要自己先编写一个函数类，这样还不够方便。


但C++11发布后，在函数内简便地定义“函数”（其实是函数对象）就成为了可能：

#+BEGIN_EXAMPLE
    #include <iostream>

    int main()
    {
        auto a = [](){std::cout << "Lambda is flexible!";};
        a();    //MinGW或VC10.0通过编译，显示结果：Lambda is flexible!
        return 0;
    }
#+END_EXAMPLE



上面代码中的auto并不是旧标准中自动变量的意思（自动分配和自动释放空间），它在C++11中赋予了新的功能：当变量被声明时，从变量的初始化值中推出并指定变量的类型。Lambda由于产生的是无名的函数对象，所以它并不能直接在函数中被调用。但如果“把这无名的函数对象起个别名”，那么就可以通过别名来调用了。


不得不承认，新的标准C++11的确使C++的用法更灵活了，或者说能把繁杂的代码简化了。

** [[http://wiki.dzsc.com/info/7158.html][PCI总线]]

PCI（Peripheral Component Interconnect）总线总线 的供应商是一种同步的
独立于处理器的32位或64位局部总线。从结构上看，PCI是在CPUCPU 的供应商和
原来的系统总线之间插入的一级总线，具体由一个桥接电路实现对这一层的管理，
并实现上下之间的接口以协调数据的传送。从1992年创立规范到如今，PCI总线
已成为了计算机的一种标准总线。 目录PCI总线的基本概念PCI总线的结构PCI总
线的特点PCI总线的主要功能PCI总线与VL-BUS的比较PCI总线

PCI总线的基本概念　　不同于ISA总线，PCI总线的地址总线与数据总线是分时复用的。这样做的好处是，一方面可以节省接插件的管脚数，另一方面便于实现突发数据传输。在做数据传输时，由一个PCI设备做发起者(主控，Initiator或Master)，而另一个PCI设备做目标(从设备，Target或Slave)。总线上的所有时序的产生与控制，都由Master来发起。PCI总线在同一时刻只能供一对设备完成传输，这就要求有一个仲裁机构(Arbiter)，来决定在谁有权力拿到总线的主控权。　　当PCI总线进行操作时，发起者(Master)先置REQ#，当得到仲裁器(Arbiter)的许可时(GNT#)，会将FRAME#置低，并在AD总线上放置Slave地址，同时C/BE#放置命令信号，说明接下来的传输类型。所有PCI总线上设备都需对此地址译码，被选中的设备要置DEVSEL#以声明自己被选中。然后当IRDY#与TRDY#都置低时，可以传输数据。当Master数据传输结束前，将FRAME#置高以标明只剩最后一组数据要传输，并在传完数据后放开IRDY#以释放总线控制权。　　这里我们可以看出，PCI总线的传输是很高效的，发出一组地址后，理想状态下可以连续发数据，峰值速率为132MB/s。实际上，目前流行的33M@32bit北桥芯片一般可以做到100MB/s的连续传输。
PCI总线的结构　　图1 为1 个典型的 PC I 多总线系统结构图。PCI总线的结构　　其主要 特点如下:　　( 1 ) PC I 规则支持多总线结构。 在整个系统中, 存 在着3种不同的总线:　　①HO ST B u s 为整个系统中最基本设备之间高性 能的连接, 它一般是 I T EL X 86 类型总线。　　②PC I B u s 为系统高性能局部总线, 各种高性能 外设连于其上, 增强系统功能。　　③L EGA CY B u s 为传统的性能较低的总线, 如 ISA 、 ISA 、 CA 总线。　　( 2) 整个系统可以分为多个层次, 不同的总线通过桥路 (BR I GE ) 相连, 桥路的主要功能是在2 种不同的 D 信号环境间进行转换, 使不同总线间的数据传输可以 顺畅进行。　　( 3 ) 在每条总线上接有各自的总线设备 (M A S2 T ER、 R GET M EM O R Y、 R GET I O ) , 这些设 TA TA 中断确认周期 ( in terrup t acknow ledge cycle ) 3 cycle ) 、 备增强系统功能, 整个总线系统为各设备之间可靠的 数据传输提供保障。
PCI总线的特点　　①突出的性能。 总线宽度 32 位, 可升级至 64 位, 支 持突发工作方式, 同步操作时最大频率 33M H z, 数据 最大传输率 132 bp s ( 32 位 ) 或 264M bp s ( 64 位 ) 。 满足 M 了当前对 PC 机传输速度的要求。　　②良好的兼容性。 I 总线部件和插板接口是相 PC 互独立的处理器, 所有目前和将来不同结构的处理器 都可以被很好地支持。　　③即插即用。 I 设备都包含存有设备具体信息 PC 的寄存器, 这些信息可以使得系统 B I S 和操作系统 O 层的软件可以自动配置 PC I 总线部件 和插板。　　④低成本。 采用最优化的芯片, 多路 复用体系减少了管脚个数和 PC I 部件, 基于 ISA 、 ISA 、 CA 的扩展板也可以 E M 在 PC I 总线上工作, 减少了用户开发费 用。　　⑤多主能力。 支持任何 PC I 主设备 和从设备之间点对点的访问。　　⑥定义了313V 和5V 2种信号环境, 5 313V 的组件技术可以使电压平滑过渡。　　⑦高速缓存 (Cache) 支持。
PCI总线的主要功能　　（1） 最大数据传输速率133MB/s　　（2） 总线时钟频率33.3MHz/66MHz　　（3） 支持10 台外设　　（4） 时钟同步方式　　（5） 与CPU 及时钟频率无关　　（6） 总线宽度 32 位（5V）/64 位（3.3V）　　（7） 能自动识别外设　　PCI （Peripheral Component Interconnect）总线是一种高性能局部总线，是为了满足外设间以及外设与主机间高速数据传输而提出来的。在数字图形、图像和语音处理，以及高速实时数据采集与处理等对数据传输率要求较高的应用中，采用PCI总线来进行数据传输，可以解决原有的标准总线数据传输率低带来的瓶颈问题。
PCI总线与VL-BUS的比较　　随着GUI(Graphical User Interface)、多媒体等技术在PC机上的应用,传统的PC总线(如ISA、ISA、EMCA)由于其带宽的限制,已不能满足系统工作的要求。为此,在90年代初,由视频电子标准协会(VESA)和ITEL分别提出了VL-BUS和PCI(PeripheralN Component Interconnect)这2种先进的局部总线规范。它们都为系统提供了一个高速的数据传输通道,系统的各设备可直接或间接地连接其上,设备间通过局部总线可以完成数据的快速传送,从而很好地解决了数据传输的瓶颈问题。　　2种局部总线相比,PCI总线由于是针对整个系统,而不象VL-BUS主要是针对图形加速,它可以带相对较多的负载且运行更为可靠;支持即插即用的结构;采用多路复用技术等一系列优点更受到了众多厂家的支持,成为市场的主流。目前PC机市场绝大多数的Pentium机都以PCI为系统总线。

** [[http://blog.chinaunix.net/uid-20671509-id-1580312.html][存储器分类]]

1．按存储介质分
（1）半导体存储器。存储元件由半导体器件组成的叫半导体存储器。其优点是体积小、功耗低、存取时间短。其缺点是当电源消失时，所存信息也随即丢失，是一种易失性存储器。
半导体存储器又可按其材料的不同，
分为双极型（TTL）半导体存储器和MOS半导体存储器两种。
前者具有高速的特点，而后者具有高集成度的特点，并且制造简单、成本低廉，
功耗小、故MOS半导体存储器被广泛应用。
（2）磁表面存储器。磁表面存储器是在金属或塑料基体的表面上涂一层磁性材料作为记录介质，工作时磁层随载磁体高速运转，用磁头在磁层上进行读写操作，故称为磁表面存储器。
按载磁体形状的不同，可分为磁盘、磁带和磁鼓。现代计算机已很少采用磁鼓。由于用具有矩形磁滞回线特性的材料作磁表面物质，它们按其剩磁状态的不同而区分“0”或“1”，而且剩磁状态不会轻易丢失，故这类存储器具有非易失性的特点。
（3）光盘存储器。光盘存储器是应用激光在记录介质(磁光材料)上进行读写的存储器，具有非易失性的特点。光盘记录密度高、耐用性好、可靠性高和可互换性强等。

2．按存取方式分类
按存取方式可把存储器分为随机存储器、只读存储器、顺序存储器和直接存取存储器四类。
（1）随机存储器RAM(Random Access Memory)。RAM是一种可读写存储器，
其特点是存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。计算机系统中的主存都采用这种随机存储器。由于存储信息原理的不同，
RAM又分为静态RAM
(以触发器原理寄存信息)和动态RAM(以电容充放电原理寄存信息)。
（2）只读存储器ROM(Read only
Memory)。只读存储器是能对其存储的内容读出，而不能对其重新写入的存储器。这种存储器一旦存入了原始信息后，在程序执行过程中，只能将内部信息读出，而不能随意重新写入新的信息去改变原始信息。因此，通常用它存放固定不变的程序、常数以及汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。
只读存储器分为掩膜型只读存储器MROM（Masked
ROM）、可编程只读存储器PROM(Programmable
ROM)、可擦除可编程只读存储器EPROM(Erasable Programmable
ROM)、用电可擦除可编程的只读存储器EEPROM(Electrically Erasable
Programmable ROM)。以及近年来出现了的快擦型存储器Flash
Memory，它具有EEPROM的特点，而速度比EEPROM快得多。
（3）串行访问存储器。如果对存储单元进行读写操作时，需按其物理位置的先后顺序寻找地址，则这种存储器叫做串行访问存储器。显然这种存储器由于信息所在位置不同，使得读写时间均不相同。如磁带存储器，不论信息处在哪个位置，读写时必须从其介质的始端开始按顺序寻找，故这类串行访问的存储器又叫顺序存取存储器。还有一种属于部分串行访问的存储器，如磁盘。在对磁盘读写时，首先直接指出该存储器中的某个小区域(磁道)，然后再顺序寻访，直至找到位置。故其前段是直接访问，后段是串行访问，也称其为半顺序存取存储器。

一、RAM(Random Access Memory，随机存取存储器)
RAM的特点是：电脑开机时，操作系统和应用程序的所有正在运行的数据和程序都会放置其中，并且随时可以对存放在里面的数据进行修改和存取。它的工作需要由持续的电力提供，一旦系统断电，存放在里面的所有数据和程序都会自动清空掉，并且再也无法恢复。

根据组成元件的不同，RAM内存又分为以下十八种：

01.DRAM（Dynamic RAM，动态随机存取存储器）
这是最普通的RAM，一个电子管与一个电容器组成一个位存储单元，DRAM将每个内存位作为一个电荷保存在位存储单元中，用电容的充放电来做储存动作，但因电容本身有漏电问题，因此必须每几微秒就要刷新一次，否则数据会丢失。存取时间和放电时间一致，约为2~4ms。因为成本比较便宜，通常都用作计算机内的主存储器。

02.SRAM（Static RAM，静态随机存取存储器）
静态，指的是内存里面的数据可以长驻其中而不需要随时进行存取。每6颗电子管组成一个位存储单元，因为没有电容器，因此无须不断充电即可正常运作，因此它可以比一般的动态随机处理内存处理速度更快更稳定，往往用来做高速缓存。

03.VRAM（Video RAM，视频内存）

它的主要功能是将显卡的视频数据输出到数模转换器中，有效降低绘图显示芯片的工作负担。它采用双数据口设计，其中一个数据口是并行式的数据输出入口，另一个是串行式的数据输出口。多用于高级显卡中的高档内存。

04.FPM DRAM（Fast Page Mode DRAM，快速页切换模式动态随机存取存储器）
改良版的DRAM，大多数为72Pin或30Pin的模块。传统的DRAM在存取一个BIT的数据时，必须送出行地址和列地址各一次才能读写数据。而FRM
DRAM在触发了行地址后，如果CPU需要的地址在同一行内，则可以连续输出列地址而不必再输出行地址了。由于一般的程序和数据在内存中排列的地址是连续的，这种情况下输出行地址后连续输出列地址就可以得到所需要的数据。FPM将记忆体内部隔成许多页数Pages，从512B到数KB不等，在读取一连续区域内的数据时，就可以通过快速页切换模式来直接读取各page内的资料，从而大大提高读取速度。在96年以前，在486时代和PENTIUM时代的初期，
FPM DRAM被大量使用。

05.EDO DRAM（Extended Data Out DRAM，延伸数据输出动态随机存取存储器）
这是继FPM之后出现的一种存储器，一般为72Pin、168Pin的模块。它不需要像FPM
DRAM那样在存取每一BIT
数据时必须输出行地址和列地址并使其稳定一段时间，然后才能读写有效的数据，而下一个BIT的地址必须等待这次读写操作完成才能输出。因此它可以大大缩短等待输出地址的时间，其存取速度一般比FPM模式快15%左右。它一般应用于中档以下的Pentium主板标准内存，后期的486系统开始支持EDO
DRAM，到96年后期，EDO DRAM开始执行。。

06.BEDO DRAM（Burst Extended Data Out
DRAM，爆发式延伸数据输出动态随机存取存储器）
这是改良型的EDO
DRAM，是由美光公司提出的，它在芯片上增加了一个地址计数器来追踪下一个地址。它是突发式的读取方式，也就是当一个数据地址被送出后，剩下的三个数据每一个都只需要一个周期就能读取，因此一次可以存取多组数据，速度比EDO
DRAM快。但支持BEDO
DRAM内存的主板可谓少之又少，只有极少几款提供支持（如VIA APOLLO
VP2），因此很快就被DRAM取代了。

07.MDRAM（Multi-Bank DRAM，多插槽动态随机存取存储器）
MoSys公司提出的一种内存规格，其内部分成数个类别不同的小储存库
(BANK)，也即由数个属立的小单位矩阵所构成，每个储存库之间以高于外部的资料速度相互连接，一般应用于高速显示卡或加速卡中，也有少数主机板用于L2高速缓存中。

08.WRAM（Window RAM，窗口随机存取存储器）
韩国Samsung公司开发的内存模式，是VRAM内存的改良版，不同之处是它的控制线路有一、二十组的输入/输出控制器，并采用EDO的资料存取模式,因此速度相对较快，另外还提供了区块搬移功能（BitBlt），可应用于专业绘图工作上。

09.RDRAM（Rambus DRAM，高频动态随机存取存储器）
Rambus公司独立设计完成的一种内存模式，速度一般可以达到500~530MB/s，是DRAM的10倍以上。但使用该内存后内存控制器需要作相当大的改变，因此它们一般应用于专业的图形加速适配卡或者电视游戏机的视频内存中。

10.SDRAM（Synchronous DRAM，同步动态随机存取存储器）
这是一种与CPU实现外频Clock同步的内存模式，一般都采用168Pin的内存模组，工作电压为3.3V。
所谓clock同步是指内存能够与CPU同步存取资料，这样可以取消等待周期，减少数据传输的延迟，因此可提升计算机的性能和效率。

11.SGRAM（Synchronous Graphics RAM，同步绘图随机存取存储器）
SDRAM的改良版，它以区块Block，即每32bit为基本存取单位，个别地取回或修改存取的资料，减少内存整体读写的次数，另外还针对绘图需要而增加了绘图控制器，并提供区块搬移功能（BitBlt），效率明显高于SDRAM。

12.SB SRAM（Synchronous Burst SRAM，同步爆发式静态随机存取存储器）
一般的SRAM是非同步的，为了适应CPU越来越快的速度，需要使它的工作时脉变得与系统同步，这就是SB
SRAM产生的原因。

13.PB SRAM（Pipeline Burst SRAM，管线爆发式静态随机存取存储器）
CPU外频速度的迅猛提升对与其相搭配的内存提出了更高的要求，管线爆发式SRAM取代同步爆发式SRAM成为必然的选择，因为它可以有效地延长存取时脉，从而有效提高访问速度。

14.DDR SDRAM（Double Data Rate二倍速率同步动态随机存取存储器）
作为SDRAM的换代产品，它具有两大特点：其一，速度比SDRAM有一倍的提高；其二，采用了DLL（Delay
Locked
Loop：延时锁定回路）提供一个数据滤波信号。这是目前内存市场上的主流模式。

15.SLDRAM （Synchronize Link，同步链环动态随机存取存储器）
这是一种扩展型SDRAM结构内存，在增加了更先进同步电路的同时，还改进了逻辑控制电路，不过由于技术显示，投入实用的难度不小。

16.CDRAM（CACHED DRAM，同步缓存动态随机存取存储器）
这是三菱电气公司首先研制的专利技术，它是在DRAM芯片的外部插针和内部DRAM之间插入一个SRAM作为二级CACHE使用。当前，几乎所有的CPU都装有一级CACHE来提高效率，随着CPU时钟频率的成倍提高，CACHE不被选中对系统性能产生的影响将会越来越大，而CACHE
DRAM所提供的二级CACHE正好用以补充CPU一级CACHE之不足，因此能极大地提高CPU效率。

17.DDRII (Double Data Rate Synchronous
DRAM，第二代同步双倍速率动态随机存取存储器)
DDRII
是DDR原有的SLDRAM联盟于1999年解散后将既有的研发成果与DDR整合之后的未来新标准。DDRII的详细规格目前尚未确定。

18.DRDRAM (Direct Rambus DRAM)
是下一代的主流内存标准之一，由Rambus
公司所设计发展出来，是将所有的接脚都连结到一个共同的Bus，这样不但可以减少控制器的体积，已可以增加资料传送的效率。

二、ROM(READ Only Memory，只读存储器)

ROM是线路最简单半导体电路，通过掩模工艺，一次性制造，在元件正常工作的情况下，其中的代码与数据将永久保存，并且不能够进行修改。一般应用于PC系统的程序码、主机板上的
BIOS (基本输入/输出系统Basic Input/Output
System)等。它的读取速度比RAM慢很多。

根据组成元件的不同，ROM内存又分为以下五种：

1.MASK ROM（掩模型只读存储器）
制造商为了大量生产ROM内存，需要先制作一颗有原始数据的ROM或EPROM作为样本，然后再大量复制，这一样本就是MASK
ROM，而烧录在MASK ROM中的资料永远无法做修改。它的成本比较低。

2.PROM（Programmable ROM，可编程只读存储器）
这是一种可以用刻录机将资料写入的ROM内存，但只能写入一次，所以也被称为“一次可编程只读存储器”(One
Time Progarmming
ROM，OTP-ROM)。PROM在出厂时，存储的内容全为1，用户可以根据需要将其中的某些单元写入数据0(部分的PROM在出厂时数据全为0，则用户可以将其中的部分单元写入1)，
以实现对其“编程”的目的。

3.EPROM（Erasable Programmable，可擦可编程只读存储器）
这是一种具有可擦除功能，擦除后即可进行再编程的ROM内存，写入前必须先把里面的内容用紫外线照射它的IC卡上的透明视窗的方式来清除掉。这一类芯片比较容易识别，其封装中包含有“石英玻璃窗”，一个编程后的EPROM芯片的“石英玻璃窗”一般使用黑色不干胶纸盖住，
以防止遭到阳光直射。

4.EEPROM（Electrically Erasable Programmable，电可擦可编程只读存储器）
功能与使用方式与EPROM一样，不同之处是清除数据的方式，它是以约20V的电压来进行清除的。另外它还可以用电信号进行数据写入。这类ROM内存多应用于即插即用（PnP）接口中。

5.Flash Memory（快闪存储器）
这是一种可以直接在主机板上修改内容而不需要将IC拔下的内存，当电源关掉后储存在里面的资料并不会流失掉，在写入资料时必须先将原本的资料清除掉，然后才能再写入新的资料，缺点为写入资料的速度太慢。

** [[http://lovelace.blog.51cto.com/1028430/1211373][shell 学习之for语句]]

一、for语法
for 变量 in 列表；do
    循环体
done
二、常见用法
1、for用来遍历目录

1
2
3
4
5
6
7
8
9
10
#!/bin/bash
#Version:0.1
#Author:lovelace
#pragram:This scripts is print all files in directory
#difine an varibale
DIR="/home/scripts/51cto"
#All files in directory traversal
for f in $(ls $DIR);do
echo $f
done

输出结果为：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
[root@lovelace for]# ./dir.sh
1.sh
2curl.sh
adduer.sh
aliquot.sh
argument.sh
argusum.sh
curl.sh
dd.sh
dirper.sh
info.sh
info.tt
ipcheck.sh
jugement.sh
netcard.sh
sum.sh
test.sh
The
Frist
week
The
Third
week

2、for ((初始条件;终止条件;异动项））
do
   命令区域
done

1
2
3
4
5
6
7
8
9
10
11
12
#!/bin/bash
#Version:0.1
#Author:lovelace
#pragram:This pragram is and the sum from 1 to 100
#define an integer
declare -i i
#loops
for ((i=1;i<=10;i=i+1))
do
let sum+=1
done
echo "The result is:" $sum

输出结果为：
1
2
[root@lovelace for]# ./sorsum.sh
The result is: 10
3、for 无穷循环
    for ((;1;));do
      命令区域
     done


1
2
3
4
5
[root@lovelace for]# cat forover.sh
#!/bin/bash
for ((;1;));do
echo "forever..."
done
输出结果：
1
2
3
4
5
6
7
8
[root@lovelace for]# ./forover.sh
forever...
forever...
forever...
forever...
forever...
forever...
forever...
三、关于break和continue

break、continue 一样可以运用在for while until select这4中循环中，
break :退出循环  提前退出
continue:提前进入下一轮循环 ,continue后面的语句将不再执行
示例（计算1到100内能被3整除的数之和）：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
#!/bin/bash
#Verson:0.1
#Auther:lovelace
#Pragram:This pragram is calculation from 1 to 100 aliquot 3 sum
#
declare -i i=0
declare -i sum=0
#use loop traverse from 1 to 100
while [ $i -lt 100 ];do
let i++
#jugement aliqotu 3 or not
if [ $(($i%3))  -eq 0 ];then
let sum+=i
else
continue
fi
done
#print sum
echo "from 1 to 100 aliquot 3 sum is $sum"
输出结果为：
1
2
[root@lovelace for]# ./three.sh
from 1 to 100 aliquot 3 sum is 1683
四、再次重提如何生成列表
如何生成列表：
1、整数列表
     {1..100}  生存1到100的列表
2、seq
    seq 10 1到10
    seq 5 10 5到10
    seq 5 10 2 返回列表为6 8 10
3、`ls /etc`

生成列表不单单只有我们列出的这些，实际案例上需要灵活运用
示例：（分别显示当前系统上所有默认shell中为bash的用户和默认为nologin的用户）
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
[root@lovelace for]# cat checkbash.sh
#!/bin/bash
#Version:0.1
#Author:lovelace
#pragram:This scripts is check user bash and print it
#取出使用bash的用户个数
bashline=`grep 'bash$' /etc/passwd | wc -l`
#取出使用nologin的用户个数
nologinline=`grep 'nologin$' /etc/passwd | wc -l`
#取出bash用户列表
bashuser=`grep 'bash$' /etc/passwd | cut -d: -f1`
#取出nologin用户列表
nologin=`grep 'nologin$' /etc/passwd | cut -d: -f1`
#遍历使用bash的用户并打印出来
for x in  $bashuser;do
echo "bash users is:$x"
done
#遍历使用nologin的用户并打印出来
for y in  $nologin;do
echo "nologin users is:$y"
done
#结果如下
[root@lovelace for]# ./checkbash.sh
bash users is:root
bash users is:nick
bash users is:kale
bash users is:user2
bash users is:user3
bash users is:user4
bash users is:user5
bash users is:user6
bash users is:user7
bash users is:user8
bash users is:user9
bash users is:user10
bash users is:mark
bash users is:lovelace
bash users is:lovetest
nologin users is:bin
nologin users is:daemon
nologin users is:adm
nologin users is:lp
nologin users is:mail
nologin users is:uucp
nologin users is:operator
nologin users is:games
nologin users is:gopher
nologin users is:ftp
nologin users is:nobody
nologin users is:nscd
nologin users is:vcsa
nologin users is:pcap
nologin users is:ntp
nologin users is:dbus
nologin users is:avahi
nologin users is:rpc
nologin users is:mailnull
nologin users is:smmsp
nologin users is:sshd
nologin users is:oprofile
nologin users is:rpcuser
nologin users is:nfsnobody
nologin users is:xfs
nologin users is:haldaemon
nologin users is:avahi-autoipd
nologin users is:gdm
nologin users is:sabayon
nologin users is:jack

** [[http://www.blogbus.com/fbirdzp-logs/37423250.html][Apr 3, 2009Linux用户命令行字符环境变量]]

   用户登录Linux系统的字符界面后，就会出现"#"或"$"等命令提示符，比如"[root@pxe
   root]# “、"[oracle@db1 ~]$”或是 “-bash-3.00#”等等。

   通过设置环境变量PS1、PS2、PS3以及PS4来自定义用户命令行的字符显示。如果要长期永久性修改提示符，可以将修改提示符的命令添加到$HOME/.profile或$HOME/.bash_profile文件中。

   *1. PS1*

   PS1是主提示符变量,也是默认提示符变量。默认值"\s-\v\$“，显示shell类型和版本。
   基本上通过设置PS1来定义命令行提示字符即可，最常用的需求就是显示登录的用户名、主目录、主机名等等，举个例子如下：

   --------------

   显示用户名，主机名和动态显示当前目录
   -bash-3.00# export PS1="[\u@\h \w]"
   [root@MagicLinux ~]cd /etc
   [root@MagicLinux /etc]

   注意：如果当前目录是用户的HOME目录，则显示＂~＂

   --------------

   PS1变量可以使用的参数值有如下：

   | \d                                                      | \H                                                                         | \h                                                      | \t                                     | \T                     | \A                             | \u                   | \v               | \w                                     | \W                                                       | \#                 | \$                                                      | \[        | \]        | \!                           |
   | 代表日期，格式为weekday month date，例如："Mon Aug 1"   | 完整的主机名称。例如：我的机器名称为：fc4.linux，则这个名称就是fc4.linux   | 仅取主机的第一个名字，如上例，则为fc4，.linux则被省略   | 显示时间为24小时格式，如：HH：MM：SS   | 显示时间为12小时格式   | 显示时间为24小时格式：HH：MM   | 当前用户的账号名称   | BASH的版本信息   | 完整的工作目录名称。家目录会以 ~代替   | 利用basename取得工作目录名称，所以只会列出最后一个目录   | 下达的第几个命令   | 提示字符，如果是root时，提示符为：# ，普通用户则为：$   | 字符"["   | 字符"]"   | 命令行动态统计历史命令次数   |

   *2. PS2*

   PS2是副提示符变量，默认值是''> ''。
   PS2一般使用于命令行里较长命令的换行提示信息，比如：

   --------------

   默认设置
   -bash-3.00# rpm -q gcc make binutils openmotif setarch compat-db
   compat-gcc \
   > compat-gcc-c++ compat-libstdc++ compat-libstdc++-devel

   自定义设置
   -bash-3.00# export PS2="PS2 => "
   -bash-3.00# rpm -q gcc make binutils openmotif setarch compat-db
   compat-gcc \
   PS2 => compat-gcc-c++ compat-libstdc++ compat-libstdc++-devel

   --------------

   *3. PS3，PS4*

   这两个环境变量可能用得不多，不研究了。如果有兴趣，可以学习bash里面的简介。

   PS3  The value of this parameter is used as the prompt for the
   select command (see SHELL GRAMMAR above).
   PS4  The value of this parameter is expanded as with PS1 and the
   value is printed before  each  command  bash displays  during an
   execution trace.  The first character of PS4 is replicated multiple
   times, as neces-sary, to indicate multiple levels of indirection.
   The default is ''+ ''.

** [[http://blog.csdn.net/flowingflying/article/details/5069646][Linux Bash Shell学习（九）：流程控制------if/else]]



[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

Linux/（83）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/flowingflying/article/category/526791][作者同类文章]]/X/

读书笔记/（147）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/flowingflying/article/category/520736][作者同类文章]]/X/

版权声明：本文为博主原创文章，未经博主允许不得转载。

本文也即《Learning the bash Shell》3rd Edition的第五章Flow
Control之读书笔记，但我们将不限于此。flow
control是任何编程语言中很常用的部分，也包括了bash。在这里，我们将学习他们。

if/else是通过判断选择执行或者执行部分代码，可以根据变量、文件名、命令是否执行成功等很多条件进行判断，他的格式如下：

#+BEGIN_QUOTE
  *if* /condition/
   *then*
     /statements/
   [*elif* /condition/
     *then* /statements./ ..]
   [*else*
     /statements/ ]
   *fi*
#+END_QUOTE

和
C程序不一样，bash的判断不是通过boolean，而是通过statement，也就是执行命令后的最终状态（exit
status）。所有的Linux命令，无论你是代码是C还是脚本，执行完，都返回一个整数通知他的调用这，这就是exit
status，通常0表示OK，其他（1-255）表示错误。这只是通常的情况，例如diff，0表示你no
difference，1表示difference，2表示错误。if判断statements的最后一个的exit
status，通常我们只放一个statement，如果为0，表示true，否则表示false。

执行下一条命令会冲掉原来exit
status。可以使用$?来查看上一命令执行的结果。例如我们希望用一个新的cd命令来替代原来在linux
kernel中已将编译的cd命令，由于function是优先于built-in命令，所以调用时，将调用我们的function。下面有一个例子，function
pushd，在stack中键入cd的dirname路径名，并执行跳到该路径下。

#+BEGIN_QUOTE
  cd ( )
   {

  #由于我们已经定义了具有更高优先级别的function，如果希望调用原来built-in的命令，需要再前面加上builtin。
     *builtin* cd "$@"
     #$?是上一command的返回值，即builtin cd
  "$@"的值，并记录在result里面。
     result=*$?
  *   echo "$OLDPWD --> $PWD"

  #返回result的值。我们需要注意shell中的返回和在其他程序，例如C语言中的返回是不一样的，只代表最后的exit
  statue，而不是所谓的返回值，虽然也用到了return。如何没有最后的reture，例如后面的push_func，exit
  status就是最后执行的command的exit status
     *return*   $result
   }

  push_func( )
   {
     dirname=$1
     #如果dirname为null，退出funcuntion，如cd dirname成功，push the
  directory ，否则显示still in
  $PWD，cd使用function的cd函数，其优先级别高于已在内核编译了的cd
     *if* cd ${dirname:?"missing directory name."}
     *then
  *   mystack="$dirname ${mystack:-$OLDPWD }"
     echo $mystack
     *else*
     echo still in $PWD.
     *fi
  * }

  push_func $1
#+END_QUOTE

/*条件结合*/

和C语言一样，可以进行条件结合，使用&&，||，以及！三种方式，表示“和”，“或”，与”非“，格式如下：if
/statement1/ *&&* /statement2，/ if /statement1/ *||* /statement2/ ，if
*！* /statement1/ 。

exit status不是判断的唯一值，可以使用[...]和[[...]]。

/*字符串比较*/

字符串比较是放置在[...]中，有以下的几种：

-  str1 = str2，字符串1匹配字符串2
-  str1 != str2，字符串1不匹配字符串2
-  str1 > str2，字符串1大于字符串2
-  str1 < str2，字符串1小于字符串2
-  -n str，字符串不为null，长度大于零
-  -z str，字符串为null，长度为零

*需要注意<和>符号和重定向符号相似，为了避免歧义和错误，使用if [ /$a/
/> /$b/ ] 的方式* 。仍然上面的例子，我们增加pop_func来操作stack:

#+BEGIN_QUOTE
    pop_func()
      {
       mystack=${mystack#* }
       #下面请至于[ ...
  ]，即[后面有一个空格，]前面有一空格，另外$mystack用双引号，表示这代表的是一个字符串。注意到then不放在下一行，与if放在用一行，用;来隔开。
       if *[ -n "$mystack" ];* then
       cd ${mystack%% *}
       echo "$PWD", stack is [$mystack]
       else
     echo "stack empty, still in $PWD."
     fi
      }
#+END_QUOTE

例如，我们要求命令带有参数，除了使用{1?"<message"}以外，下面给出更可读的方式：

#+BEGIN_QUOTE
  if [ -z "$1" ]; then
     echo 'usage: c filename [-N]'
     *exit* 1
   fi
#+END_QUOTE

在这里exit表示结束，退出，执行的结果为失败，非零。

/*文件属性比较*/

文件属性比较是另一个常用的条件判断类型。

-  *-a*   /file/ ：file 存在
-  *-d* /file/ ：file存在并是一个目录
-  *-e* /file/ ：file 存在，同- a
-  *-f* /file/ ：file
   存在并且是一个常规的文件（不是目录或者其他特殊类型文件）
-  *-r* /file/ ：有读的权限
-  *-s* /file/ ：文件存在且不为空
-  *-w* /file/ ：有写的权限
-  *-x* /file/ ：有执行的权限，或者对于目录有search的权限
-  *-N* /file/ ：在上次读取后，文件有改动
-  *-O* /file/ ：own所属的文件
-  *-G* /file/ ：group所属的文件
-  /file1/ *// -nt* /file2/ ：file1 比 file2 更新，以最后更新时间为准
-  /file1/ *-ot* /file2/ ：file1 比 file2 更旧 ，以最后更新时间为准

这些在[ ... ]中的条件判断是可以多个结合起来，例如if [ condition ] &&
[ condition ]; then，当然也可以if command && [ condition ];
then，不在类推。尤其我们可以进行复制的条件判断。另外还可以使用*-a*
和*-o*
，等同于C语言中的&和|的逻辑计算复符号，他们和&&即||相似。当他们用在condition里面。

在上面push_func的例子中，除了判断是否参数之外，增加判断是否是目录名，如下：

#+BEGIN_QUOTE
    if *[ -n "$dirname" ] &&[ -d "$dirname" ]*
     then
     cd $dirname
     mystack="$dirname ${mystack:-$OLDPWD }"
     echo $mystack
     else
     echo still in $PWD.
     fi
#+END_QUOTE

我们在增加一个判断，当时目录名的时候，在检查是否可以进行查看或操作。使用if
[ -n "$dirname" ] &&[ *-d "$dirname" -a -x "$dirname"*
]，但是这种写法很难阅读，我们需要将两个前后判断括起来，( -d "$dirname" )
-a ( -x "$dirname" )。但是（是个特殊符合，需使用/(的方式，即为：if [ -n
"$dirname" ] &&*[ /( -d "$dirname" /) -a /( -x "$dirname" /) ]* 。

/*整数比较*/

>或者<或者=是用于字符串的比较，如果用于整数比较，使用：

-  -lt，小于
-  -le，小于等于
-  -eq，等于
-  -ge，大于等于
-  -gt，大于
-  -ne，不等于

** [[http://www.cnblogs.com/chengmo/archive/2010/10/01/1839942.html][linux shell 逻辑运算符、逻辑表达式详解]]

shell的逻辑运算符
涉及有以下几种类型，因此只要适当选择，可以解决我们很多复杂的判断，达到事半功倍效果。



*一、逻辑运算符*







| *逻辑卷标*   | 1.                                 | -f                                                  | -d                           | -b                              | -c                                  | -S                                   | -L                                        | -e                           | 2.                       | -G                                  | -O                                  | -p                                                                        | 3.                       | -r                     | -w                         | -x                       | -s                         | -u                             | -g                             | -k                                   | 4.                                                          | -nt                        | -ot                        | -ef                                                      | 5.                            | &&                  | ||                 |
| *表示意思*   | *关于档案与目录的侦测逻辑卷标！*   | 常用！侦测『档案』是否存在 eg: if [ -f filename ]   | 常用！侦测『目录』是否存在   | 侦测是否为一个『 block 档案』   | 侦测是否为一个『 character 档案』   | 侦测是否为一个『 socket 标签档案』   | 侦测是否为一个『 symbolic link 的档案』   | 侦测『某个东西』是否存在！   | *关于程序的逻辑卷标！*   | 侦测是否由 GID 所执行的程序所拥有   | 侦测是否由 UID 所执行的程序所拥有   | 侦测是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！）   | *关于档案的属性侦测！*   | 侦测是否为可读的属性   | 侦测是否为可以写入的属性   | 侦测是否为可执行的属性   | 侦测是否为『非空白档案』   | 侦测是否具有『 SUID 』的属性   | 侦测是否具有『 SGID 』的属性   | 侦测是否具有『 sticky bit 』的属性   | *两个档案之间的判断与比较* ；例如[ test file1 -nt file2 ]   | 第一个档案比第二个档案新   | 第一个档案比第二个档案旧   | 第一个档案与第二个档案为同一个档案（ link 之类的档案）   | 逻辑的『和(and)』『或(or)』   | 逻辑的 AND 的意思   | 逻辑的 OR 的意思   |





| 运算符号   | =                                                         | !=                                                          | <                                                    | >                                                    | -eq                     | -ne                       | -lt                     | -gt                     | -le                           | -ge                           | -a                                            | -o                                         | -z         | -n           |
| 代表意义   | 等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串   | 不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串   | 小于 应用于：整型比较 在[] 中，不能使用 表示字符串   | 大于 应用于：整型比较 在[] 中，不能使用 表示字符串   | 等于 应用于：整型比较   | 不等于 应用于：整型比较   | 小于 应用于：整型比较   | 大于 应用于：整型比较   | 小于或等于 应用于：整型比较   | 大于或等于 应用于：整型比较   | 双方都成立（and） 逻辑表达式 --a 逻辑表达式   | 单方成立（or） 逻辑表达式 --o 逻辑表达式   | 空字符串   | 非空字符串   |



*二、逻辑表达式*

**

-  *test 命令*

#+BEGIN_QUOTE
  *使用方法：*test EXPRESSION

  如：

  [root@localhost ~]# test 1 = 1 && echo 'ok'
  ok

  [root@localhost ~]# test -d /etc/ && echo 'ok'
  ok

  [root@localhost ~]# test 1 -eq 1 && echo 'ok'
  ok



  [root@localhost ~]# if test 1 = 1 ; then echo 'ok'; fi
  ok
#+END_QUOTE



#+BEGIN_QUOTE
  *注意：所有字符 与逻辑运算符直接用“空格”分开，不能连到一起。*
#+END_QUOTE



-  *精简表达式*

#+BEGIN_QUOTE

  -  *[] 表达式*

  [root@localhost ~]# [ 1 -eq 1 ] && echo 'ok'
  ok

  [root@localhost ~]# [ 2 < 1 ] && echo 'ok'
  -bash: 2: No such file or directory


  [root@localhost ~]# [ 2 \< 1 ] && echo 'ok'

  [root@localhost ~]# [ 2 -gt 1 -a 3 -lt 4 ] && echo 'ok'

  ok

  [root@localhost ~]# [ 2 -gt 1 && 3 -lt 4 ] && echo 'ok'
  -bash: [: missing `]'

  注意：在[]
  表达式中，常见的>,<需要加转义字符，表示字符串大小比较，以acill码
  位置作为比较。 不直接支持<>运算符，还有逻辑运算符|| && 它需要用-a[and]
  --o[or]表示
#+END_QUOTE



#+BEGIN_QUOTE




  -  *[[]] 表达式*

  [root@localhost ~]# [ 1 -eq 1 ] && echo 'ok'
  ok

  [root@localhost ~]$ [[ 2 < 3 ]] && echo 'ok'
  ok

  [root@localhost ~]$ [[ 2 < 3 && 4 > 5 ]] && echo 'ok'
  ok
#+END_QUOTE

#+BEGIN_QUOTE
  注意：[[]]
  运算符只是[]运算符的扩充。能够支持<,>符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：||
  &&


#+END_QUOTE



*三、性能比较*

bash的条件表达式中有三个几乎等效的符号和命令：test，[]和[[]]。通常，大家习惯用if
[];then这样的形式。而[[]]的出现，根据ABS所说，是为了兼容><之类的运算符。以下是比较它们性能，发现[[]]是最快的。


$ time (for m in {1..100000}; do test -d .;done;)
real  0m0.658s
user  0m0.558s
sys  0m0.100s


$ time (for m in {1..100000}; do [ -d . ];done;)
real  0m0.609s
user  0m0.524s
sys  0m0.085s


$ time (for m in {1..100000}; do [[ -d . ]];done;)
real  0m0.311s
user  0m0.275s
sys  0m0.036s


不考虑对低版本bash和对sh的兼容的情况下，用[[]]是兼容性强，而且性能比较快，在做条件运算时候，可以使用该运算符。

** [[http://www.cppblog.com/amazon/archive/2010/01/10/105358.html][makefile和make规则]]

首先介绍make实用程序的语法和常用选项，然后细剖makefile文件的组成。

*make命令*

[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]make [选项] [目标] [宏定义]
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]通过命令行参数中的target，可指定make要编译的目标，并且允许同时定义编译多个目标，操作时按照从左向右的顺序依次编译target选项中指定的目标文件。如果命令行中没有指定目标，则系统默认target指向描述文件中第一个目标文件。
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-d 显示调试信息
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-n 不运行任何makefile文件，只打印需要执行的命令
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-p 输出所有宏定义和目标文件描述
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-s 静止状态下运行，不显示任何命令行信息
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-f file 通知make程序从file中读取内部依赖说明，缺省情况下会读取makefile或者Makefile文件处理，文件名-表示读取标准输入，在Linux中，GNU make工具在当前工作目录中按照GNUmakefile、makefile、Makefile的顺序搜索makefile文件
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]

注意：在源文件没有被修改的情况下，运行make命令会生成一条消息，说源文件的可执行文件是最新的，不需要用make命令重新编译和链接。要强制再创建可执行代码，需要改变源文件的上次更新时间，可以使用touch命令，然后再次运行make命令。

[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]touch [选项] 文件或目录
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-r 文件或目录 把指定文件或目录的日期时间，设成和参考文件或目录的日期时间相同
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]-d 日期时间
使用指定的日期时间，而非现在的时间


*makefile规则*

make程序基于文件之间的依赖性，需要建立的目标文件，以及建立目标文件时要执行的命令，以上所有被称为规则，存放在文件makefile中。定制规则的语法如下：
*目标列表 : 关联性列表
<TAB>命令列表
*注意：
1.可以在关联性列表和命令列表中使用shell文件名模式匹配字符，例如?、*、[]等等。
2.如果目标的命令列表中某个命令前面带有@，那么当make程序执行时，该命令是不会有反应的，在程序运行完毕之后，所有前面带@的命令按照反序执行。可以通过执行make
-n命令显示这些命令以供查看。
3.如果目标的命令列表中某个命令前面带有-，说明如果该命令执行有误，会跳过该命令并继续执行。

make程序使用makefile中的规则决定程序中需要重新编译的文件，并再次链接生成可执行代码。如果源文件上修改的时间戳比目标文件上的时间戳更新，那么make重新编译build中包含的源文件。例如，如果修改了一个.h头文件，make程序就会重新编译所有包含该头文件的源文件，前提是头文件在这些源文件的目标文件的关联性列表中；再如某.c源文件被修改，那么该源文件被重新编译，生成对应的新的目标文件。
myprog : foo.o bar.o
  gcc --o myprog foo.o bar.o
foo.o : foo.c foo.h bar.h
  gcc --o foo.o --c foo.c
bar.o : bar.c bar.h
  gcc --o bar.o --c bar.c
上述规则中，只要目标文件比冒号后面的文件任何一个旧，将会执行下一行的命令；但是在检查foo.o和bar.o的时间之前，会往下查找那些把foo.o和bar.o作为目标文件的规则；以此类推，并最终回到myprog规则。
如何得到每个C文件的输出规则呢？可使用-M和-MM编译选项。注意：使用-M和-MM编译选项时，仅在shell中输出规则信息，不能用于产生可执行文件，即不能写成gcc
-o hello -M hello.c这样的形式。
*gcc --M hello.c*
//输出hello.c和该文件中所有<>和””包含的头文件
*gcc --MM hello.c*  //仅输出hello.c和该文件中所有””包含的头文件

*后缀（隐含）规则*

make
-p命令显示了所有后缀规则列表。为了建立一个目标，make使用程序会遍历一连串的依赖关系，从而决定从何处开始建立。如果没有找到目标文件，make程序按照优先顺序查找源文件，首先查找.c、.f或.s后缀的文件，然后再查找SCCS（带.c~后缀）文件，如果没有找到任何一个源文件，make程序就会报告一个异常。
make程序知道调用gcc -c xxx.c -o
xxx.o的预定义命令，而且还知道目标文件通常和源文件是相同的，这种功能称作标准依赖性，所以foo.o
: foo.c foo.h bar.h这样的语句可以简写成foo.o : foo.h
bar.h。同时，如果把生成foo.o和bar.o的命令从规则中删除，make将自动查找它的隐含规则（gcc
-M/MM输出的代码），然后找到一个适当的命令，命令中会使用一些变量，并且按照一定步骤设定。
因此，上述makefile的内容可以根据后缀规则简写成：
myprog : foo.o bar.o
  gcc --o myprog foo.o bar.o
foo.o : foo.h bar.h
bar.o : bar.h

*宏定义（变量）*

makefile中的变量定义可以存储文件名列表、可执行文件名以及编译器标识等，主要是使用如下方法：

[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]VAR=name 变量定义
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]define VAR
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]] name
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]endef 同上
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]$(VAR) 使用变量，如果变量名为单字符，可以不使用圆括号或花括号
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]${VAR} 同上
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]$@ 当前目标文件
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]$* 删除了后缀的目标名
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]$< 依赖列表中，比当前目标更新的当前依赖名称（即第一个依赖文件）
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]$\^ 整个依赖列表
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]$? 依赖列表中，比当前目标更新的当前依赖列表
[[http://www.cppblog.com/Images/OutliningIndicators/None.gif]]CFLAGS 通常默认值是-O，但是可以被修改

未使用后缀规则的makefile文件变成如下：
OBJS=foo.o bar.o
SOURCES=foo.c bar.c
HEADERS=foo.h bar.h
CC=gcc
CFLAGS=-Wall -O -g
myprog : $(OBJS)
  $(CC) $\^ -o $@
foo.o : foo.c foo.h bar.h
  $(CC) $(CFLAGS) --c $< -o $@
bar.o : bar.c bar.h
  $(CC) $(CFLAGS) --c $< -o $@
而使用了后缀规则的makefile文件变成如下：
OBJS=foo.o bar.o
SOURCES=foo.c bar.c
HEADERS=foo.h bar.h
CC=gcc
myprog : $(OBJS)
  $(CC) S\^ -o $@
foo.o : foo.h bar.h
bar.o : bar.h

*虚目标
*
假设一个项目最后需要产生两个可执行文件exec1和exec2，但两个文件是相互独立的，此时可使用假想目的all来达到效果。
all : exec1 exec2
all文件并不存在，make总是会假设它需要被生成，因此会检查它的依靠文件exec1和exec2是否需要更新，当把它的依靠文件更新后，就会执行它的规则里的命令行，但是在规则里没有哪个命令作用于名为all的实际文件，所以该规则并不真正改变all的状态。
注意下面的语句用法，这些语句可以添加到makefile文件后：
myprog.tar : makefile $(SOURCES) $(HEADERS)
  tar -cvf $@ S\^
clean :
  rm *.o
当make命令不带参数执行时，最后两个目标myprog.tar和clean的命令不会执行，因为这些文件没有依赖文件。将这两个目标作为参数传递给make命令，可以调用与目标关联的命令。例如：执行make
myprog.tar命令会执行tar -cvf myprog.tar makefile foo.c bar.c foo.h
bar.h语句，而执行make clean命令会执行clean *.o语句。

下面给出一个较完整的makefile文件：
---------------------------------------------------------
#Updated makefile that uses some built-in macros and
[[mailto:#@-preceded][#@-preceded]] commands
define CC
  gcc
endef
OPTIONS=-03
OBJECTS=main.o input.o compute.o
SOURCES=main.c input.c compute.c
HEADERS=main.h input.h compute.h
complete : power
  @echo "Build complete"
power : $(OBJECTS)
  $(CC) $(OPTIONS) -o $@ $\^ -lm
  @echo "The executable is in the 'power' file"
main.o : main.h input.h compute.h
compute.o : compute.h
input.o : input.h
power.tar : makefile $(HEADERS) $(SOURCES)
  tar -cvf $@ $\^
clean :
  rm -f *.o
-----------------------------------------------------
执行结果为：
-----------------------------------------------------
$ make
gcc -c main.c -o main.o
gcc -c input.c -o input.o
gcc -c compute.c -o compute.o
gcc -o3 -o power main.o input.o compute.o -lm
The executable is in the 'power' file
Build complete
$ make power.tar
tar -cvf power.tar makefile main.h input.h compute.h main.c input.c
compute.c
makefile
main.h
input.h
compute.h
main.c
input.c
compute.c
$ make clean
rm -f *.o
------------------------------------------------------

** [[http://blog.csdn.net/adaptiver/article/details/7240364][Bash shell中的位置参数$#,$*,$@,$0,$1,$2...及特殊参数$?,$-等的含义]]


[[http://static.blog.csdn.net/images/category_icon.jpg]] 分类：

linux命令/（21）/
[[http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg]]
[[http://static.blog.csdn.net/images/arrow_triangle_up.jpg]]

[[http://blog.csdn.net/adaptiver/article/category/862986][作者同类文章]]/X/

 [[http://hi.baidu.com/lolorosa/blog/item/5775a608bd670d33b0351da7.html]]

$# 是传给脚本的参数个数

$@ 是传给脚本的所有参数的列表

$0 是脚本本身的名字

$1是传递给该shell脚本的第一个参数

$2是传递给该shell脚本的第二个参数

在Bash shell中经常会见到一些比较特殊的符号，本人现收集与此，以供查阅：

 位置参数：
 详见ABS(Advanced Bash
Shell)中文翻译版103页第9章第一节内部变量，当然英文版ABS都一样啦

 $0, $1, $2,等等...
 位置参数,从命令行传递给脚本,或者是传递给函数.或者赋职给一个变量.
 (具体见Example 4-5 和Example 11-15)
 $0表示当前执行的进程名,script
本身的名字,或者在正则表达式中表示整行输出

 $#
 命令行或者是位置参数的个数.(见Example 33-2)
 $*
 所有的位置参数,被作为一个单词.
 注意:"$*"必须被""引用.
 $@

与$*同义,但是每个参数都是一个独立的""引用字串,这就意味着参数被完整地传递,

并没有被解释和扩展.这也意味着,每个参数列表中的每个参数都被当成一个独立的单词.
 注意:"$@"必须被""引用.



其他的特殊参数
 $-
 传递给脚本的falg(使用set 命令).参考Example 11-15.
 注意:这起初是ksh 的特征,后来被引进到Bash 中,但不幸的是,在Bash
中它看上去也不

能可靠的工作.使用它的一个可能的方法就是让这个脚本进行自我测试(查看是否是交
 互的).
 $!
 在后台运行的最后的工作的PID(进程ID).
 $_
 保存之前执行的命令的最后一个参数.
 $?
 命令,函数或者脚本本身的退出状态(见Example 23-7)

用于检查上一个命令,函数或者脚本执行是否正确。（在Linux中，命令退出状态为0表示该命令正确执行，任何非0值表示命令出错。）
 $$
 脚本自身的进程ID.这个变量经常用来构造一个"unique"的临时文件名.
 (参考Example A-13,Example 29-6,Example 12-28 和Example 11-25).
 这通常比调用mktemp 来得简单.
 注意事项:
 [1] 当前运行的脚本的PID 为$$.
 [2]
"argument"和"parameter"这两个单词经常不加区分的使用.在这整本书中,这两个
 单词的意思完全相同.(在翻译的时候就未加区分,统统翻译成参数)

 退出和返回
 退出状态(exit status)
 函数返回一个被称为退出状态的值. 退出状态可以由return 来指定statement,
否则函数的
 退出状态是函数最后一个执行命令的退出状态(0 表示成功,非0 表示出错代码).
退出状态
 (exit status)可以在脚本中由$? 引用. 这个机制使脚本函数也可以像C
函数一样有一个"
 返回值".
 return
 终止一个函数.return
命令[1]可选地带一个整数参数,这个整数作为函数的"返回值"返回
 给调用此函数的脚本,并且这个值也被赋给变量$?.

 while true可以写为while :



 Example 23-7 两个数中的最大者
 ###################Start Script#################
 1 #!/bin/bash
 2 # max.sh: 两个整数中的最大者.
 3
 4 E_PARAM_ERR=-198 # 如果传给函数的参数少于2 个时的返回值.
 5 EQUAL=-199 # 如果两个整数值相等的返回值.
 6 # 任一个传给函数的参数值溢出
 7 #
 8
 9 max2 () # 返回两个整数的较大值.
 10 { # 注意: 参与比较的数必须小于257.
 11 if [ -z "$2" ]
 12 then
 13 return $E_PARAM_ERR
 14 fi
 15
 16 if [ "$1" -eq "$2" ]
 17 then
 18 return $EQUAL
 19 else
 20 if [ "$1" -gt "$2" ]
 21 then
 22 return $1
 23 else
 24 return $2
 25 fi
 26 fi
 27 }
 28
 29 max2 33 34
 30 return_val=$?
 31
 32 if [ "$return_val" -eq $E_PARAM_ERR ]
 33 then
 34 echo "Need to pass two parameters to the function."
 35 elif [ "$return_val" -eq $EQUAL ]
 36 then
 37 echo "The two numbers are equal."
 38 else
 39 echo "The larger of the two numbers is $return_val."
 40 fi
 41
 42
 43 exit 0
 44
 45 # 练习 (容易):
 46 # ---------------
 47 # 把这个脚本转化成交互式的脚本,
 48 #+ 也就是说,让脚本可以要求调用者输入两个整数.
 #####################End Script##################

** [[http://blog.163.com/redzang@yeah/blog/static/64918585201201474716158/][grep、egrep和fgrep命令--Linux文件内容查询命令  ]]

1.命令功能：

       grep命令用来在文本文件中查找指定模式的词或短语，并在标准输出上显示包括给定字符串模式的所有行；

       egrep命令等同于grep -E，可以使用扩展的字符串模式进行搜索；

       fgrep命令等同于grep -F，是快速搜索命令，它检索固定字符串，但不识别正则表达式。

2.一般格式：

grep [选项] [查找模式] [文件名1，文件名2，……]

    fgrep [选项] [查找模式] [文件名1，文件名2，……]

        egrep [选项] [查找模式] [文件名1，文件名2，……]

3.常用选项：

- E 每个模式作为一个扩展的正则表达式对待。

- F 每个模式作为一组固定字符串对待（以新行分隔），而不作为正则表达式。

- b在输出的每一行前显示包含匹配字符串的行在文件中的字节偏移量。

- c 只显示匹配行的数量。

- i 比较时不区分大小写。

- h 在查找多个文件时，指示grep不要将文件名加入到输出之前。

- l 显示首次匹配串所在的文件名并用换行符将其隔开。当在某文件中多次出现匹配串时，不重复显示此文件名。

- n 在输出前加上匹配串所在行的行号（文件首行行号为1）。

- v 只显示不包含匹配串的行。

- x 只显示整行严格匹配的行。

- e expression 指定检索使用的模式。用于防止以“-”开头的模式被解释为命令选项。

- f expfile 从expfile文件中获取要搜索的模式，一个模式占一行

 4.注意以下方面：

在命令后键入搜索的模式，再键入要搜索的文件。其中，文件名列表中也可以使用特殊字符，如“*”等，用来生成文件名列表。如果想在搜索的模式中包含有空格的字符串，可以用单引号把要搜索的模式括起来，用来表明搜索的模式是由包含空格的字符串组成。否则，Shell将把空格认为是命令行参数的定界符，而grep命令将把搜索模式中的单词解释为文件名列表中的一部分。在下面的例子中，grep命令在文件example中搜索模式“text file”。

$ grep ’text file’ example

用户可以在命令行上用Shell特殊字符来生成将要搜索的文件名列表。在下面的例子中，特殊字符“*”用来生成一个文件名列表，该列表包含当前目录下所有的文件。该命令将搜索出当前目录下所有文件中与模式匹配的行。

$ grep data *

特殊字符在搜索一组指定的文件时非常有用。例如，如果想搜索所有的C程序源文件中特定的模式，您可以用“*.c”来指定文件名列表。假设用户的 C程序中包含一些不必要的转向语句（goto语句），想要找到这些语句，可以用如下的命令来搜索并显示所有包含goto语句的代码行：

$ grep goto *.c

用户可以在命令行上键入搜索模式，也可以使用-f选项从指定文件中读取要搜索的模式。在文件中，每个搜索模式占一行。如果经常要搜索一组常见字符串时，这个功能非常有用。在下面的例子中，用户要在文件exam中搜索字符串“editor”和“create”，就把要搜索的模式放置在文件mypats中，然后，grep命令从文件mypats中读取要搜索的模式。

$ cat mypats

editor

create

$ grep -f mypats exam

** [[http://tommy9394.com/blog/linux/linux-command/41.html][Linux中的crond指令用法]]

cron是一個linux下的定時執行工具，可以在無需人工干預的情況下運行作業。由於Cron 是Linux的內置服務，但它不自動起來，可以用以下的方法啟動、關閉這個服務:


/sbin/service crond start //啟動服務
/sbin/service crond stop //關閉服務
/sbin/service crond restart //重啟服務
/sbin/service crond reload //重新載入配置
1
2
3
4
/sbin/service crond start //啟動服務
/sbin/service crond stop //關閉服務
/sbin/service crond restart //重啟服務
/sbin/service crond reload //重新載入配置
1.crontab指令選項:


-u 指定一個用戶,
-l 列出某個用戶的任務計劃,
-r 刪除某個用戶的任務,
-e 編輯某個用戶的任務
1
2
3
4
-u 指定一個用戶,
-l 列出某個用戶的任務計劃,
-r 刪除某個用戶的任務,
-e 編輯某個用戶的任務
2.cron文件語法:


分     小時   日       月       星期     命令
0-59   0-23   1-31   1-12     0-6     command     (取值範圍,0表示週日一般一行對應一個任務)
3.記住幾個特殊符號的含義:
「*」代表取值範圍內的數字,
「/」代表」每」,
「-」代表從某個數字到某個數字,
「,」分開幾個離散的數字
1
2
3
4
5
6
7
分     小時   日       月       星期     命令
0-59   0-23   1-31   1-12     0-6     command     (取值範圍,0表示週日一般一行對應一個任務)
3.記住幾個特殊符號的含義:
「*」代表取值範圍內的數字,
「/」代表」每」,
「-」代表從某個數字到某個數字,
「,」分開幾個離散的數字
任務調度設置文件的寫法
可用crontab -e命令來編輯,編輯的是/var/spool/cron下對應用戶的cron文件,也可以直接修改/etc/crontab文件
具體格式如下：


Minute Hour Day Month Dayofweek   command
分鐘     小時   天     月       天每星期       命令
每個字段代表的含義如下：
Minute             每個小時的第幾分鐘執行該任務
Hour               每天的第幾個小時執行該任務
Day                 每月的第幾天執行該任務
Month             每年的第幾個月執行該任務
DayOfWeek     每週的第幾天執行該任務
Command       指定要執行的程序
1
2
3
4
5
6
7
8
9
Minute Hour Day Month Dayofweek   command
分鐘     小時   天     月       天每星期       命令
每個字段代表的含義如下：
Minute             每個小時的第幾分鐘執行該任務
Hour               每天的第幾個小時執行該任務
Day                 每月的第幾天執行該任務
Month             每年的第幾個月執行該任務
DayOfWeek     每週的第幾天執行該任務
Command       指定要執行的程序
在這些字段裡，除了「Command」是每次都必須指定的字段以外，其它字段皆為可選字段，可視需要決定。對於不指定的字段，要用「*」來填補其位置。
舉例如下：


5       *       *           *     *     ls             指定每小時的第5分鐘執行一次ls命令
30     5       *           *     *     ls             指定每天的 5:30 執行ls命令
30     7       8         *     *     ls             指定每月8號的7：30分執行ls命令
30     5       8         6     *     ls             指定每年的6月8日5：30執行ls命令
30     6       *           *     0     ls             指定每星期日的6:30執行ls命令[註：0表示星期天，1表示星期1，以此類推，也可以用英文來表示，sun表示星期天，mon表示星期一等。]
30     3     10,20     *     *     ls     每月10號及20號的3：30執行ls命令[註：「，」用來連接多個不連續的時段]
25     8-11 *           *     *     ls       每天8-11點的第25分鐘執行ls命令[註：「-」用來連接連續的時段]
*/15   *       *           *     *     ls         每15分鐘執行一次ls命令 [即每個小時的第0 15 30 45 60分鐘執行ls命令 ]
30   6     */10         *     *     ls       每個月中，每隔10天6:30執行一次ls命令[即每月的1、11、21、31日是的6：30執行一次ls命令。 ]
每天7：50以root 身份執行/etc/cron.daily目錄中的所有可執行文件
50   7       *             *     *     root     run-parts     /etc/cron.daily   [ 註：run-parts參數表示，執行後面目錄中的所有可執行文件。
添加後保存的路徑是/var/spool/cron,可以用vi查看修改，這個不難
1
2
3
4
5
6
7
8
9
10
11
12
5       *       *           *     *     ls             指定每小時的第5分鐘執行一次ls命令
30     5       *           *     *     ls             指定每天的 5:30 執行ls命令
30     7       8         *     *     ls             指定每月8號的7：30分執行ls命令
30     5       8         6     *     ls             指定每年的6月8日5：30執行ls命令
30     6       *           *     0     ls             指定每星期日的6:30執行ls命令[註：0表示星期天，1表示星期1，以此類推，也可以用英文來表示，sun表示星期天，mon表示星期一等。]
30     3     10,20     *     *     ls     每月10號及20號的3：30執行ls命令[註：「，」用來連接多個不連續的時段]
25     8-11 *           *     *     ls       每天8-11點的第25分鐘執行ls命令[註：「-」用來連接連續的時段]
*/15   *       *           *     *     ls         每15分鐘執行一次ls命令 [即每個小時的第0 15 30 45 60分鐘執行ls命令 ]
30   6     */10         *     *     ls       每個月中，每隔10天6:30執行一次ls命令[即每月的1、11、21、31日是的6：30執行一次ls命令。 ]
每天7：50以root 身份執行/etc/cron.daily目錄中的所有可執行文件
50   7       *             *     *     root     run-parts     /etc/cron.daily   [ 註：run-parts參數表示，執行後面目錄中的所有可執行文件。
添加後保存的路徑是/var/spool/cron,可以用vi查看修改，這個不難
添加時間同步的
做任務計劃。


 * */1 * * * /usr/bin/rdate -s time-b.nist.gov
 * */1 * * * /usr/sbin/ntpdate time.windows.com
1
2
 * */1 * * * /usr/bin/rdate -s time-b.nist.gov
 * */1 * * * /usr/sbin/ntpdate time.windows.com
加入這兩句。
vps 和實際主機的時鐘頻率是不一樣的，所以必須得計劃同步，這個是一小時同步一次。
當出現問題，用這兩個就可以了
rdate -s stdtime.gov.hk
hwclock –systohc

Tags: Cron, crond, Linux

** [[http://blog.csdn.net/hguisu/article/details/7470695][C语言中的宏定义]]



[[http://blog.csdn.net/hguisu/article/category/1080443][作者同类文章]]/X/

版权声明：本文为博主原创文章，未经博主允许不得转载。

***

1. 简单宏定义

简单的宏定义有如下格式：

[#define指令（简单的宏）]　　#define  标识符替换列表

替换列表是一系列的C语言记号，包括标识符、关键字、数、字符常量、字符串字面量、运算符和标点符号。当预处理器遇到一个宏定义时，会做一个
“标识符”代表“替换列表”的记录。在文件后面的内容中，不管标识符在任何位置出现，预处理器都会用替换列表代替它。

| 不要在宏定义中放置任何额外的符号，否则它们会被作为替换列表的一部分。一种常见的错误是在宏定义中使用 = ：                                                                                            |
|                                                                                                                                                                                                    |
| #+BEGIN_EXAMPLE                                                                                                                                                                                    |
|     #define N = 100       /*** WRONG ***/                                                                                                                                                          |
|     int a[N];            /* 会成为 int a[= 100]; */                                                                                                                                                |
| #+END_EXAMPLE                                                                                                                                                                                      |
|                                                                                                                                                                                                    |
| 在上面的例子中，我们（错误地）把N定义成一对记号（= 和100）。                                                                                                                                       |
|                                                                                                                                                                                                    |
| 在宏定义的末尾使用分号结尾是另一个常见错误：                                                                                                                                                       |
|                                                                                                                                                                                                    |
| #+BEGIN_EXAMPLE                                                                                                                                                                                    |
|     #define N 100;       /*** WRONG ***/                                                                                                                                                           |
|     int a[N];            /*    become int a[100;]; */                                                                                                                                              |
| #+END_EXAMPLE                                                                                                                                                                                      |
|                                                                                                                                                                                                    |
| 这里N被定义为100和;两个记号。                                                                                                                                                                      |
|                                                                                                                                                                                                    |
| 在一个宏定义中，编译器可以检测到绝大多数由多余符号所导致的错误。但不幸的是，编译器会将每一处使用这个宏的地方标为错误，而不会直接找到错误的根源------宏定义本身，因为宏定义已经被预处理器删除了。   |

简单的宏主要用来定义那些被Kernighan和Ritchie称为“明示常量”（manifest
constant）的东西。使用宏，我们可以给数值、字符和字符串命名。

#+BEGIN_EXAMPLE
    #define STE_LEN 80

    #defineTRUE     1

    #defineFALSE    0

    #definePI        3.14159

    #defineCR        '\r'

    #defineEOS       '\0'
#+END_EXAMPLE

使用#define来为常量命名有许多显著的优点：

1)
、 程序会更易读。一个认真选择的名字可以帮助读者理解常量的意义。否则，程序将包含大量的“魔法数”，使读者难以理解。

2)
、 程序会更易于修改。我们仅需要改变一个宏定义，就可以改变整个程序中出现的所有该常量的值。“硬编码的”常量会更难于修改，特别是有时候当他们以稍微不同的形式出现时。（例如，如果一个程序包含一个长度为100的数组，它可能会包含一个从0到99的循环。如果我们只是试图找到所有程序中出现的100，那么就会漏掉99。）

3)
、可以帮助避免前后不一致或键盘输入错误。假如数值常量3.14159在程序中大量出现，它可能会被意外地写成3.1416或3.14195。

虽然简单的宏常用于定义常量名，但是它们还有其他应用。

4)
、可以对C语法做小的修改。实际上，我们可以通过定义宏的方式给C语言符号添加别名，从而改变C语言的语法。例如，对于习惯使用Pascal的begin和end（而不是C语言的{和}）的程序员，可以定义下面的宏：

#+BEGIN_EXAMPLE
    #define BEGIN  {

    #define END    }
#+END_EXAMPLE

我们甚至可以发明自己的语言。例如，我们可以创建一个LOOP“语句”，来实现一个无限循环：

#define LOOP  for (;;)

当然，改变C语言的语法通常不是个好主意，因为它会使程序很难被其他程序员所理解。

5) 、对类型重命名。在5.2节中，我们通过重命名int创建了一个Boolean类型：

#+BEGIN_EXAMPLE
    #define BOOL int
#+END_EXAMPLE

虽然有些程序员会使用宏定义的方式来实现此目的，但类型定义（7.6节）仍然是定义新类型的最佳方法。

6)
、控制条件编译。如将在14.4节中看到的那样，宏在控制条件编译中起重要的作用。例如，在程序中出现的宏定义可能表明需要将程序在“调试模式”下进行编译，来使用额外的语句输出调试信息：

#+BEGIN_EXAMPLE
    #define DEBUG
#+END_EXAMPLE

这里顺便提一下，如上面的例子所示，宏定义中的替换列表为空是合法的。

当宏作为常量使用时，C程序员习惯在名字中只使用大写字母。但是并没有如何将用于其他目的的宏大写的统一做法。由于宏（特别是带参数的宏）可能是程序中错误的来源，所以一些程序员更喜欢使用大写字母来引起注意。其他人则倾向于小写，即按照Kernighan和Ritchie编写的/The
C Programming Language/一书中的样式。

***

2. 带参数的宏

带参数的宏定义有如下格式：

[#define指令---带参数的宏]　　#define 标识符（/x/_{1},
/x/_{2},...,/x_{n}/）替换列表

其中/x/_{1},
/x/_{2},...,/x_{n}/是标识符（宏的参数）。这些参数可以在替换列表中根据需要出现任意次。

| 在宏的名字和左括号之间必须没有空格。如果有空格，预处理器会认为是在定义一个简单的宏，其中（/x/_{1},/x/_{2},...,/x_{n}/）是替换列表的一部分。   |

当预处理器遇到一个带参数的宏，会将定义存储起来以便后面使用。在后面的程序中，如果任何地方出现了标识符（/y/_{1},/y/_{2},...,/y_{n}/）格式的宏调用（其中/y/_{1},/y/_{2},...,/y_{n}/是一系列标记），预处理器会使用替换列表替代，并使用/y/_{1}替换/x/_{1}，/y/_{2}替换/x/_{2}，依此类推。

例如，假定我们定义了如下的宏：

#+BEGIN_EXAMPLE
    #define MAX(x,y)    ((x)>(y) ? (x) :(y))

    #define IS_EVEN(n)   ((n)%2==0)
#+END_EXAMPLE

现在如果后面的程序中有如下语句：

#+BEGIN_EXAMPLE
    i = MAX(j+k, m-n);

    if (IS_EVEN(i)) i++;
#+END_EXAMPLE

预处理器会将这些行替换为

#+BEGIN_EXAMPLE
    i = ((j+k)>(m-n)?(j+k):(m-n));
    if (((i)%2==0)) i++;
#+END_EXAMPLE

如这个例子所显示的，带参数的宏经常用来作为一些简单的函数使用。MAX类似一个从两个值中选取较大的值的函数。IS_EVEN则类似于另一种函数，该函数当参数为偶数时返回1，否则返回0。

下面的例子是一个更复杂的宏：

#+BEGIN_EXAMPLE
    #define TOUPPER(c)('a'<=(c)&&(c)<='z'?(c)-'a'+'A':(c))
#+END_EXAMPLE

这个宏检测一个字符c是否在'a'与'z'之间。如果在的话，这个宏会用'c'减去'a'再加上'A'，来计算出c所对应的大写字母。如果c不在这个范围，就保留原来的c。像这样的字符处理的宏非常有用，所以C语言库在<ctype.h>（23.4节）中提供了大量的类似的宏。其中之一就是toupper，与我们上面的TOUPPER例子作用一致（但会更高效，可移植性也更好）。

带参数的宏可以包含空的参数列表，如下例所示：

#+BEGIN_EXAMPLE
    #define getchar() getc(stdin)
#+END_EXAMPLE

空的参数列表不是一定确实需要，但可以使getchar更像一个函数。（没错，这就是<stdio.h>中的getchar，getchar的确就是个宏，不是函数------虽然它的功能像个函数。）

  *使用带参数的宏替代实际的函数的优点*：

1) 、
程序可能会稍微快些。一个函数调用在执行时通常会有些额外开销------存储上下文信息、复制参数的值等。而一个宏的调用则没有这些运行开销。

2) 、
宏会更“通用”。与函数的参数不同，宏的参数没有类型。因此，只要预处理后的程序依然是合法的，宏可以接受任何类型的参数。例如，我们可以使用MAX宏从两个数中选出较大的一个，数的类型可以是int，long
int，float，double等等。

 *但是带参数的宏也有一些缺点。*

1) 、
编译后的代码通常会变大。每一处宏调用都会导致插入宏的替换列表，由此导致程序的源代码增加（因此编译后的代码变大）。宏使用得越频繁，这种效果就越明显。当宏调用嵌套时，这个问题会相互叠加从而使程序更加复杂。思考一下，如果我们用MAX宏来找出3个数中最大的数会怎样？

#+BEGIN_EXAMPLE
    n = MAX(i, MAX(j,k));
#+END_EXAMPLE

下面是预处理后的这条语句：

#+BEGIN_EXAMPLE
    n=((i)>(((j)>(k)?(j):(k)))?(i):(((j)>(k)?(j):(k))));
#+END_EXAMPLE

2)
、宏参数没有类型检查。当一个函数被调用时，编译器会检查每一个参数来确认它们是否是正确的类型。如果不是，或者将参数转换成正确的类型，或者由编译器产生一个出错信息。预处理器不会检查宏参数的类型，也不会进行类型转换。

3)
、无法用一个指针来指向一个宏。如在17.7节中将看到的，C语言允许指针指向函数。这一概念在特定的编程条件下非常有用。宏会在预处理过程中被删除，所以不存在类似的“指向宏的指针”。因此，宏不能用于处理这些情况。

4)
、宏可能会不止一次地计算它的参数。函数对它的参数只会计算一次，而宏可能会计算两次甚至更多次。如果参数有副作用，多次计算参数的值可能会产生意外的结果。考虑下面的例子，其中MAX的一个参数有副作用：

#+BEGIN_EXAMPLE
    n = MAX(i++, j);
#+END_EXAMPLE

下面是这条语句在预处理之后的结果：

#+BEGIN_EXAMPLE
    n =((i++)>(j)?(i++):(j));
#+END_EXAMPLE

如果i大于j，那么i可能会被（错误地）增加了两次，同时n可能被赋予了错误的值。

| 由于多次计算宏的参数而导致的错误可能非常难于发现，因为宏调用和函数调用看起来是一样的。更糟糕的是，这类宏可能在大多数情况下正常工作，仅在特定参数有副作用时失效。为了自保护，最好避免使用带有副作用的参数。   |

带参数的宏不仅适用于模拟函数调用。他们特别经常被作为模板，来处理我们经常要重复书写的代码段。如果我们已经写烦了语句

#+BEGIN_EXAMPLE
    printf("%d"\n, x);
#+END_EXAMPLE

因为每次要显示一个整数x都要使用它。我们可以定义下面的宏，使显示整数变得简单些：

#+BEGIN_EXAMPLE
    #define PRINT_INT(x)    printf("%d\n", x)
#+END_EXAMPLE

一旦定义了PRINT_INT，预处理器会将这行

#+BEGIN_EXAMPLE
    PRINT_INT(i/j);
    //转换为
    printf("%d\n", i/j);
#+END_EXAMPLE

***

3. #运算符


 宏定义可以包含两个运算符：#和##。*编译器不会识别这两种运算符相反，它们会在预处理时被执行*。

#运算符将一个宏的参数转换为字符串字面量*(*字符串字面量（string
literal）是指双引号引住的一系列字符，双引号中可以没有字符，可以只有一个字符，也可以有很多个字符),，
简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号. 它仅允许出现在带参数的宏的替换列表中。（一些C程序员将#操作理解为“stringization（字符串化）”；其他人则认为这实在是对英语的滥用。）用比较官方的话说就是将语言符号(Token)转化为字符串。


#运算符有大量的用途，这里只来讨论其中的一种。假设我们决定在调试过程中使用PRINT_INT宏作为一个便捷的方法，来输出一个整型变量或表达式的值。#运算符可以使PRINT_INT为每个输出的值添加标签。下面是改进后的PRINT_INT：

#+BEGIN_EXAMPLE
    #define PRINT_INT(x) printf(#x " = %d\n", x)
#+END_EXAMPLE

x之前的#运算符通知预处理器根据PRINT_INT的参数创建一个字符串字面量。因此，调用

#+BEGIN_EXAMPLE
    PRINT_INT(i/j);
    //会变为
    printf("i/j" " = %d\n", i/j);
#+END_EXAMPLE

在C语言中相邻的字符串字面量会被合并，因此上边的语句等价于：

#+BEGIN_EXAMPLE
    printf("i/j = %d\n", i/j);
#+END_EXAMPLE

当程序执行时，printf函数会同时显示表达式i/j和它的值。例如，如果i是11，j是2的话，输出为

i/j = 5

TIPI例子：

#+BEGIN_EXAMPLE
    #define STR(x) #x

    int main(int argc char** argv)
    {
        printf("%s\n", STR(It's a long string)); // 输出 It's a long str
        return 0;
    }
#+END_EXAMPLE

***

4. ##运算符


 在C语言的宏中，"##"被称为 连接符（concatenator），*它是一种预处理运算符*，
用来把两个语言符号(Token)组合成单个语言符号。
这里的语言符号不一定是宏的变量。并且双井号不能作为第一个或最后一个元素存在.

##运算符可以将两个记号（例如标识符）“粘”在一起，成为一个记号。（无需惊讶，##运算符被称为“记号粘合”。）如果其中一个操作数是宏参数，“粘合”会在当形式参数被相应的实际参数替换后发生。考虑下面的宏：

如下例子:当MK_ID被调用时（比如MK_ID(1)），预处理器首先使用自变量（这个例子中是1）替换参数n。接着，预处理器将i和1连接成为一个记号（i1）。下面的声明使用MK_ID创建了3个标识符：

#+BEGIN_EXAMPLE
    #define MK_ID(n) i##n
    int MK_ID(1), MK_ID(2), MK_ID(3);
    //预处理后声明变为：
    int i1, i2, i3;
#+END_EXAMPLE


##运算符不属于预处理器经常使用的特性。实际上，想找到一些使用它的情况是比较困难的。为了找到一个有实际意义的##的应用，我们来重新思考前面提到过的MAX宏。如我们所见，当MAX的参数有副作用时会无法正常工作。一种解决方法是用MAX宏来写一个max函数。遗憾的是，往往一个max函数是不够的。我们可能需要一个实际参数是int值的max函数，还需要参数为float值的max函数，等等。除了实际参数的类型和返回值的类型之外，这些函数都一样。因此，这样定义每一个函数似乎是个很蠢的做法。


 解决的办法是定义一个宏，并使它展开后成为max函数的定义。宏会有唯一的参数type，它表示形式参数和返回值的类型。这里还有个问题，如果我们是用宏来创建多个max函数，程序将无法编译。（C语言不允许在同一文件中出现两个同名的函数。）为了解决这个问题，我们是用##运算符为每个版本的max函数构造不同的名字。下面的例子：请注意宏的定义中是如何将type和_max相连来形成新函数名的。假如我们需要一个针对float值的max函数。

#+BEGIN_EXAMPLE
    #define GENERIC_MAX (type)           \
    type type##_max(type x,  type y)    \
    {                                      \
      return x > y ? x :y;              \
    }
    GENERIC_MAX(float)
#+END_EXAMPLE

//预处理器会将这行展开为下面的代码：
 float float_max(float x, float y) { return x > y ? x :y; }

再如：

#+BEGIN_EXAMPLE
    #define PHP_FUNCTION            ZEND_FUNCTION
    #define ZEND_FUNCTION(name)             ZEND_NAMED_FUNCTION(ZEND_FN(name))
    #define ZEND_FN(name) zif_##name
    #define ZEND_NAMED_FUNCTION(name)       void name(INTERNAL_FUNCTION_PARAMETERS)
    #define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value, zval **return_value_ptr, \
    zval *this_ptr, int return_value_used TSRMLS_DC

    PHP_FUNCTION(count);
#+END_EXAMPLE


 //  预处理器处理以后， PHP_FUCNTION(count);就展开为如下代码

#+BEGIN_EXAMPLE
    void zif_count(int ht, zval *return_value, zval **return_value_ptr,
            zval *this_ptr, int return_value_used TSRMLS_DC)
#+END_EXAMPLE

宏ZEND_FN(name)中有一个"##"，它的作用一如之前所说，是一个连接符，将zif和宏的变量name的值连接起来。
以这种连接的方式以基础，多次使用这种宏形式，可以将它当作一个代码生成器，这样可以在一定程度上减少代码密度，
我们也可以将它理解为一种代码重用的手段，间接地减少不小心所造成的错误。

***

5. 宏的通用属性

现在我们已经讨论过简单的宏和带参数的宏了，我们来看一下它们都需要遵守的规则。
 1)
、宏的替换列表可以包含对另一个宏的调用。例如，我们可以用宏PI来定义宏TWO_PI：
 #definePI      3.14159
 #defineTWO_PI  (2*PI)

当预处理器在后面的程序中遇到TWO_PI时，会将它替换成（2*PI）。接着，预处理器会重新检查替换列表，看它是否包含其他宏的调用（在这个例子中，调用了宏PI）。预处理器会不断重新检查替换列表，直到将所有的宏名字都替换掉为止。


 2)
、预处理器只会替换完整的记号，而不会替换记号的片断。因此，预处理器会忽略嵌在标识符名、字符常量、字符串字面量之中的宏名。例如，假设程序含有如下代码行：

#+BEGIN_EXAMPLE
    #define SIZE 256
    int BUFFER_SIZE;
    if (BUFFER_SIZE> SIZE)
       puts("Error ： SIZEexceeded");
    //预处理后，这些代码行会变为：
    int BUFFER_SIZE;
    if (BUFFER_SIZE> 256)
      puts("Error ：SIZEexceeded");
#+END_EXAMPLE

标识符BUFFER_ZISE和字符串"Error:SIZE
exceeded"没有被预处理影响，虽然它们都包含SIZE。

3)
、一个宏定义的作用范围通常到出现这个宏的文件末尾。由于宏是由预处理器处理的，他们不遵从通常的范围规则。一个定义在函数中的宏并不是仅在函数内起作用，而是作用到文件末尾。

4)
、宏不可以被定义两遍，除非新的定义与旧的定义是一样的。小的间隔上的差异是允许的，但是宏的替换列表（和参数，如果有的话）中的记号都必须一致。

5) 、宏可以使用#undef指令“取消定义”。#undef指令有如下形式：
 [#undef指令]　　#undef  标识符
 其中标识符是一个宏名。例如，指令
 #undef N

会删除宏N当前的定义。（如果N没有被定义成一个宏，#undef指令没有任何作用。）#undef指令的一个用途是取消一个宏的现有定义，以便于重新给出新的定义。

***

6. 宏定义中圆括号


在我们前面定义的宏的替换列表中有大量的圆括号。确实需要它们吗？答案是绝对需要。如果我们少用几个圆括号，宏可能有时会得到意料之外的------而且是不希望有的结果。*对于在一个宏定义中哪里要加圆括号有两条规则要遵守：*

首先，如果宏的替换列表中有运算符，那么始终要将替换列表放在括号中：

#define TWO_PI (2*3.14159)
 其次，如果宏有参数，每次参数在替换列表中出现时都要放在圆括号中：
 #define SCALE(x) ((x)*10)

没有括号的话，我们将无法确保编译器会将替换列表和参数作为完整的表达式。编译器可能会不按我们期望的方式应用运算符的优先级和结合性规则。

为了展示为替换列表添加圆括号的重要性，考虑下面的宏定义，其中的替换列表没有添加圆括号：
 #define TWO_PI 2*3.14159
   /* 需要给替换列表加圆括号 */
 在预处理时，语句
 conversion_factor = 360/TWO_PI;
 //变为
 conversion_factor = 360/2*3.14159;
 除法会在乘法之前执行，产生的结果并不是期望的结果。

当宏有参数时，仅给替换列表添加圆括号是不够的。参数的每一次出现都要添加圆括号。例如，假设SCALE定义如下：
 #define SCALE(x) (x*10)   /* 需要给x添加括号 */
 在预处理过程中，语句
 j = SCALE(i+1);
 变为
 j = (i+1*10);
 由于乘法的优先级比加法高，这条语句等价于
 j = i+10;
 当然，我们希望的是
 j = (i+1)*10;

在宏定义中缺少圆括号会导致C语言中最让人讨厌的错误。程序通常仍然可以编译通过，而且宏似乎也可以工作，仅在少数情况下会出错。

***

7. 创建较长的宏

**** 1. 较长的宏中的逗号运算符


在创建较长的宏时，逗号运算符会十分有用。特别是可以使用逗号运算符来使替换列表包含一系列表达式。例如，下面的宏会读入一个字符串，再把字符串显示出来：

#define ECHO(s) (get(s), puts(s))


gets函数和puts函数的调用都是表达式，因此使用逗号运算符连接它们是合法的。我们甚至可以把ECHO宏当作一个函数来使用：
 ECHO(str);   /* 替换为 (gets(str), puts(str)); */

除了使用逗号运算符，我们也许还可以将gets函数和puts函数的调用放在大括号中形成复合语句：
 #define ECHO(s)  { gets(s);  puts(s);  }
 遗憾的是，这种方式并不奏效。假如我们将ECHO宏用于下面的if语句：

#+BEGIN_EXAMPLE
    if (echo_flag)
      ECHO(str);
    else
      gets(str);
    //将ECHO宏替换会得到下面的结果：
    if (echo_flag)
      { gets(str); puts(str);  };
    else
      gets(str);
#+END_EXAMPLE


 编译器会将头两行作为完整的if语句：

#+BEGIN_EXAMPLE
    if (echo_flag)
      { gets(str);  puts(str);  }
#+END_EXAMPLE


编译器会将跟在后面的分号作为空语句，并且对else子句产生出错信息，因为它不属于任何if语句。我们可以通过记住永远不要在ECHO宏后面加分号来解决这个问题。但是这样做会使程序看起来有些怪异。逗号运算符可以解决ECHO宏的问题，但并不能解决所有宏的问题。假如一个宏需要包含一系列的语句，而不仅仅是一系列的表达式，这时逗号运算符就起不到帮助的作用了。因为它只能连接表达式，不能连接语句。解决的方法是将语句放在do循环中，并将条件设置为假：

**** *2. 宏定义中的do-while循环do *

do循环必须始终随跟着一个分号，因此我们不会遇到在if语句中使用宏那样的问题了。为了看到这个技巧（嗯，应该说是技术）的实际作用，让我们将它用于ECHO宏中：

#+BEGIN_EXAMPLE
    #define ECHO(s)       \
          do{           \
               gets (s) ;      \
               puts (s) ;      \
          } while  (0)
#+END_EXAMPLE

当使用ECHO宏时，一定要加分号：
 ECHO(str);
   /* becomes do {  gets(str); puts(str); } while (0);  */
 为什么在宏定义时需要使用do-while语句呢?
我们知道do-while循环语句是先执行循环体再判断条件是否成立，
所以说至少会执行一次。当使用do{
}while(0)时由于条件肯定为false，代码也肯定只

 执行一次， 肯定只执行一次的代码为什么要放在do-while语句里呢?
这种方式适用于宏定义中存在多语句的情况。 如下所示代码：

#+BEGIN_EXAMPLE
    #define TEST(a, b)  a++;b++;

    if (expr)
        TEST(a, b);
    else
        do_else();
    代码进行预处理后，会变成：
    if (expr)
        a++;b++;
    else
        do_else();
#+END_EXAMPLE




这样if-else的结构就被破坏了if后面有两个语句，这样是无法编译通过的，那为什么非要do-while而不是简单的用{}括起来呢。
这样也能保证if后面只有一个语句。例如上面的例子，在调用宏TEST的时候后面加了一个分号，
虽然这个分号可有可无， 但是出于习惯我们一般都会写上。
那如果是把宏里的代码用{}括起来，加上最后的那个分号。 还是不能通过编译。
所以一般的多表达式宏定义中都采用do-while(0)的方式。

**** *3. "空操作"的定义*


了解了do-while循环在宏中的作用，再来看"空操作"的定义。在PHP源码中，由于PHP需要考虑到平台的移植性和不同的系统配置，
所以需要在某些时候把一些宏的操作定义为空操作。例如在sapi\thttpd\thttpd.c

文件中的VEC_FREE():

#+BEGIN_EXAMPLE
    #ifdef SERIALIZE_HEADERS
        # define VEC_FREE() smart_str_free(&vec_str)
    #else
        # define VEC_FREE() do {} while (0)
    #endif
#+END_EXAMPLE



这里涉及到条件编译，在定义了SERIALIZE_HEADERS宏的时候将VEC_FREE()定义为如上的内容，而没有定义时，
不需要做任何操作，所以后面的宏将VEC_FREE()定义为一个空操作，不做任何操作，通

 常这样来保证一致性， 或者充分利用系统提供的功能。

有时也会使用如下的方式来定义“空操作”，这里的空操作和上面的还是不一样，例如很常见的Debug日志打印宏：

#+BEGIN_EXAMPLE
    #ifdef DEBUG
    #   define LOG_MSG printf
    #else
    #   define LOG_MSG(...)
    #endif
#+END_EXAMPLE



在编译时如果定义了DEBUG则将LOG_MSG当做printf使用，而不需要调试，正式发布时则将LOG_MSG()宏定义为空，
由于宏是在预编译阶段进行处理的，所以上面的宏相当于从代码中删除了。


上面提到了两种将宏定义为空的定义方式，看上去一样，实际上只要明白了宏都只是简单的代码替换就知道该如何选择了。

***

8. 预定义宏

在C语言中预定义了一些有用的宏，*见*表预定义宏**。这些宏主要是提供当前编译的信息。宏__LINE__和__STDC__是整型常量，其他3个宏是字符串字面量。
 *表预定义宏:*
 __LINE__      被编译的文件的行数
 __FILE__      被编译的文件的名字
 __DATE__    编译的日期（格式"Mmm dd yyyy"）
 __TIME__    编译的时间（格式"hh:mm:ss"）
 __STDC__  如果编译器接受标准C，那么值为1



1)、 __DATE__宏和__TIME__宏指明程序编译的时间。例如，假设程序以下面的语句开始：

printf("Wacky Windows (c) 1996 Wacky Software, Inc.\n");

printf("Compiled on %s at %s\n", __DATE__,__TIME__);

 每次程序开始执行，程序都会显示下面两行：
 Wacky Windows (c) 1996 Wacky Software, Inc.
 Compiled on Dec 23 1996 at 22:18:48
 这样的信息可以帮助区分同一个程序的不同版本。

2)、我们可以使用__LINE__宏和__FILE__宏来找到错误。考虑下面这个检测被零除的除法的发生位置的问题。当一个C程序因为被零除而导致中止时，通常没有信息指明哪条除法运算导致错误。下面的宏可以帮助我们查明错误的根源：
 #define CHECK_ZERO(divisor)  \
   if (divisor == 0)  \
     printf("*** Attempt to divide byzero on line %d  "  \
             "of file %s  ***\n",__LINE__, __FILE__)
 CHECK_ZERO宏应该在除法运算前被调用：
 CHECK_ZERO(j);
 k = i / j;
 如果j是0，会显示出如下形式的信息：
 *** Attempt to divide by zero on line 9 of file FOO.c ***

类似这样的错误检测的宏非常有用。实际上，C语言库提供了一个通用的、用于错误检测的宏------assert宏
  再如：
 #line 838 "Zend/zend_language_scanner.c"

 #line预处理用于改变当前的行号（__LINE__）和文件名（__FILE__）。
如上所示代码，将当前的行号改变为838，文件名Zend/zend_language_scanner.c
它的作用体现在编译器的编写中，我们知道

 编译器对C 源码编译过程中会产生一些中间文件，通过这条指令，
可以保证文件名是固定的，不会被这些中间文件代替，有利于进行调试分析。



***

9. C语言中常用的宏

*01: 防止一个头文件被重复包含*

 #ifndef COMDEF_H
 #define COMDEF_H
 //头文件内容
 #endif
 *02: 重新定义一些类型*

防止由于各种平台和编译器的不同,而产生的类型字节数差异,方便移植。

typedef  unsigned char      boolean;     /* Boolean value type. */
 typedef  unsigned long int  uint32;      /* Unsigned 32 bit value */
 typedef  unsigned short     uint16;      /* Unsigned 16 bit value */
 typedef  unsigned char      uint8;       /* Unsigned 8  bit value */
 typedef  signed long int    int32;       /* Signed 32 bit value */
 typedef  signed short       int16;       /* Signed 16 bit value */
 typedef  signed char        int8;        /* Signed 8  bit value */

 //下面的不建议使用
 typedef  unsigned char     byte;         /* Unsigned 8  bit value type.
*/
 typedef  unsigned short    word;         /* Unsinged 16 bit value type.
*/
 typedef  unsigned long     dword;        /* Unsigned 32 bit value type.
*/
 typedef  unsigned char     uint1;        /* Unsigned 8  bit value type.
*/
 typedef  unsigned short    uint2;        /* Unsigned 16 bit value type.
*/
 typedef  unsigned long     uint4;        /* Unsigned 32 bit value type.
*/
 typedef  signed char       int1;         /* Signed 8  bit value type.
*/
 typedef  signed short      int2;         /* Signed 16 bit value type.
*/
 typedef  long int          int4;         /* Signed 32 bit value type.
*/
 typedef  signed long       sint31;       /* Signed 32 bit value */
 typedef  signed short      sint15;       /* Signed 16 bit value */
 typedef  signed char       sint7;        /* Signed 8  bit value */

 *03: 得到指定地址上的一个字节或字*
 #define  MEM_B(x) (*((byte *)(x)))
 #define  MEM_W(x) (*((word *)(x)))

*04: 求最大值和最小值*

#define  MAX(x,y) (((x)>(y)) ? (x) : (y))
 #define  MIN(x,y) (((x) < (y)) ? (x) : (y))

*05: 得到一个field在结构体(struct)中的偏移量*

#define FPOS(type,field) ((dword)&((type *)0)->field)

*06: 得到一个结构体中field所占用的字节数*
 #define FSIZ(type,field) sizeof(((type *)0)->field)

*07: 按照LSB格式把两个字节转化为一个Word*

#define FLIPW(ray) ((((word)(ray)[0]) * 256) + (ray)[1])

*08: 按照LSB格式把一个Word转化为两个字节*
 #define FLOPW(ray,val) (ray)[0] = ((val)/256); (ray)[1] = ((val) &
0xFF)

*09: 得到一个变量的地址（word宽度）*

#define B_PTR(var)  ((byte *) (void *) &(var))
 #define W_PTR(var)  ((word *) (void *) &(var))

 *10: 得到一个字的高位和低位字节*
 #define WORD_LO(xxx)  ((byte) ((word)(xxx) & 255))
 #define WORD_HI(xxx)  ((byte) ((word)(xxx) >> 8))

 *11: 返回一个比X大的最接近的8的倍数*
 #define RND8(x) ((((x) + 7)/8) * 8

*12: 将一个字母转换为大写*

#define UPCASE(c) (((c)>='a' && (c) <= 'z') ? ((c) -- 0×20) : (c))

*13: 判断字符是不是10进值的数字*

#define  DECCHK(c) ((c)>='0' && (c)<='9')

*14: 判断字符是不是16进值的数字*

#define HEXCHK(c) (((c) >= '0' && (c)<='9') ((c)>='A' && (c)<= 'F') \
 ((c)>='a' && (c)<='f'))

 *15: 防止溢出的一个方法*
 #define INC_SAT(val) (val=((val)+1>(val)) ? (val)+1 : (val))

 *16: 返回数组元素的个数*
 #define ARR_SIZE(a)  (sizeof((a))/sizeof((a[0])))

 *17: 返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2\^n)*
 #define MOD_BY_POWER_OF_TWO( val, mod_by ) ((dword)(val) &
(dword)((mod_by)-1))

 *18: 对于IO空间映射在存储空间的结构,输入输出处理*
 #define inp(port) (*((volatile byte *)(port)))
 #define inpw(port) (*((volatile word *)(port)))
 #define inpdw(port) (*((volatile dword *)(port)))
 #define outp(port,val) (*((volatile byte *)(port))=((byte)(val)))
 #define outpw(port, val) (*((volatile word *)(port))=((word)(val)))
 #define outpdw(port, val) (*((volatile dword
*)(port))=((dword)(val)))

 *19: 使用一些宏跟踪调试*
 ANSI标准说明了五个预定义的宏名。它们是：
 __LINE__
 __FILE__
 __DATE__
 __TIME__
 __STDC__

 C++中还定义了 __cplusplus

如果编译器不是标准的,则可能仅支持以上宏名中的几个,或根本不支持。记住编译程序也许还提供其它预定义的宏名。
 __LINE__ 及 __FILE__
宏指示，#line指令可以改变它的值，简单的讲，编译时，它们包含程序的当前行数和文件名。
 __DATE__
宏指令含有形式为月/日/年的串,表示源文件被翻译到代码时的日期。
 __TIME__ 宏指令包含程序编译的时间。时间用字符串表示，其形式为：
分：秒
 __STDC__
宏指令的意义是编译时定义的。一般来讲，如果__STDC__已经定义，编译器将仅接受不包含任何非标准扩展的标准C/C++代码。如果实现是标准的,则宏__STDC__含有十进制常量1。如果它含有任何其它数,则实现是非标准的。
 __cplusplus
与标准c++一致的编译器把它定义为一个包含至少6为的数值。与标准c++不一致的编译器将使用具有5位或更少的数值。

 可以定义宏,例如:当定义了_DEBUG,输出数据信息和所在文件所在行
 #ifdef _DEBUG
 #define DEBUGMSG(msg,date)
printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)
 #else
 #define DEBUGMSG(msg,date)
 #endif
 *20： 宏定义防止错误使用小括号包含。*
 例如：
 有问题的定义：#define DUMP_WRITE(addr,nr) {memcpy(bufp,addr,nr); bufp
+= nr;}
 应该使用的定义： #difne DO(a,b) do{a+b;a++;}while(0)
 例如：

#+BEGIN_EXAMPLE
    if(addr)
        DUMP_WRITE(addr,nr);
    else
        do_somethong_else();
    //宏展开以后变成这样:
    if(addr)
        {memcpy(bufp,addr,nr); bufp += nr;};
    else
        do_something_else();
#+END_EXAMPLE


 gcc
在碰到else前面的“；”时就认为if语句已经结束，因而后面的else不在if语句中。而采用do{}
while(0)的定义，在任何情况下都没有问题。而改为 #difne DO(a,b)
do{a+b;a++;}while(0) 的定义则在任何情况下都不会出错。

** [[http://www.cnblogs.com/pharen/archive/2012/02/06/2340257.html][C语言的布尔类型]]

在C语言标准(C89)没有定义布尔类型，所以C语言判断真假时以0为假，非0为真。所以我们通常使用逻辑变量的做法：

#+BEGIN_EXAMPLE
    //定义一个int类型变量，当变量值为0时表示false，值为1时表示trueint flag;flag = 0;//......flag = 1;if( flag ){//......}
#+END_EXAMPLE



但这种做法不直观，而且没有明确flag一定是布尔值。所以我们又借助C语言的宏定义：

#+BEGIN_EXAMPLE
    //宏定义布尔类型#define BOOL int#define TRUE 1#define FALSE 0//定义一个布尔变量BOOL flag = FALSE;
#+END_EXAMPLE



这种方法虽然直观，但依然是换汤不换药，变量flag在编译器看来依然是int类型。

新版本总会改进一些不好的地方，所以在最新的C语言标准(C99)解决了布尔类型的问题。C99提供了_Bool
型，所以布尔类型可以声明为 _Bool flag。

_Bool依然仍是整数类型，但与一般整型不同的是，_Bool变量只能赋值为0或1，非0的值都会被存储为1。

C99还提供了一个头文件 <stdbool.h>
定义了bool代表_Bool，true代表1，false代表0。只要导入 stdbool.h
，就能非常方便的操作布尔类型了。

#+BEGIN_EXAMPLE
    //导入 stdbool.h 来使用布尔类型#include <stdbool.h>#include <stdio.h>//计算n!,n的值在main中定义int main(void){    int n = 10;    //计算叠乘数    int sum = 1; //用来存放叠乘的结果    bool flag = false;    //叠乘标记        int num = n;    //循环次数    while( !flag )    {        sum = sum * (num--);        //当num=1时结束循环        if( num == 1)        {            flag = true;        }    }    printf ("%d的叠乘值为 %d \n", n, sum);    return 0;}
#+END_EXAMPLE

** 回车与换行

符号    ASCII码      意义
\n        10        换行NL
\r        13        回车CR

回车 \r 本义是光标重新回到本行开头，r的英文return，控制字符可以写成CR，即Carriage Return
换行 \n 本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成LF，即Line Feed

换行好理解，就是跳到下一行嘛

回车嘛

在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。
于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。
这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。
后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。
Unix系统里，每行结尾只有“<换行>”，即“\n”；Windows系统里面，每行结尾是“<换行><回车 >”，即“\n\r”；Mac系统里，每行结尾是“<回车>”(新的OSX的结尾同Unix）。一个直接后果是，Unix/Mac系统下的文件在Windows里打开 的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。

** *(int*)0=0

*（int *）0 = 0
C语言中(int *)表示将操作对象强制类型转换为int *类，即整形指针，这里是将0转换为int *，所以返回值还是0，不过类型发生了强制转换，成为int *型。你可以这样想象，有一个指向NULL的int *指针，和这个地方的(int *)0是等价的，因为当行ansi/iso-c99标准规定NULL指针为0x00000000，即内存中的“第0号地址”。


故意引发CPU异常,进入操作系统SEH处理。


0地址是linux系统内核特别定义的一个地址，专门指向空指针，用来捕捉空指针读写的错误。

** [[http://www.cnblogs.com/charley_yang/archive/2010/12/15/1907384.html][]]

** [[http://www.cnblogs.com/charley_yang/archive/2010/12/15/1907384.html][C++ typedef用法小结 （※不能不看※）]]

Posted on 2010-12-15 23:47
[[http://www.cnblogs.com/charley_yang/][charley_yang]] 阅读(...)
评论(...) [[http://i.cnblogs.com/EditPosts.aspx?postid=1907384][编辑]]
[[#][收藏]]

*第一、四个用途*

*用途一：*

定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。比如：
char* pa, pb; //
这多数不符合我们的意图，它只声明了一个指向字符变量的指针，
// 和一个字符变量；
以下则可行：
typedef char* PCHAR; // 一般用大写
PCHAR pa, pb; // 可行，同时声明了两个指向字符变量的指针
虽然：
char *pa, *pb;
也可行，但相对来说没有用typedef的形式直观，尤其在需要大量指针的地方，typedef的方式更省事。

*用途二：*

用在旧的C的代码中（具体多旧没有查），帮助struct。以前的代码中，声明struct新对象时，必须要带上struct，即形式为：
struct 结构名 对象名，如：
struct tagPOINT1
{
int x;
int y;
};
struct tagPOINT1 p1;

而在C++中，则可以直接写：结构名 对象名，即：
tagPOINT1 p1;

估计某人觉得经常多写一个struct太麻烦了，于是就发明了：
typedef struct tagPOINT
{
int x;
int y;
}POINT;

POINT p1; //
这样就比原来的方式少写了一个struct，比较省事，尤其在大量使用的时候

或许，在C++中，typedef的这种用途二不是很大，但是理解了它，对掌握以前的旧代码还是有帮助的，毕竟我们在项目中有可能会遇到较早些年代遗留下来的代码。

*用途三：*

用typedef来定义与平台无关的类型。
比如定义一个叫 REAL
的浮点类型，在目标平台一上，让它表示最高精度的类型为：
typedef long double REAL;
在不支持 long double 的平台二上，改为：
typedef double REAL;
在连 double 都不支持的平台三上，改为：
typedef float REAL;
也就是说，当跨平台时，只要改下 typedef
本身就行，不用对其他源码做任何修改。
标准库就广泛使用了这个技巧，比如size_t。
另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健（虽然用宏有时也可以完成以上的用途）。

*用途四：*

为复杂的声明定义一个新的简单的别名。方法是：在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例：

1. 原声明：int *(*a[5])(int, char*);
变量名为a，直接用一个新别名pFun替换a就可以了：
typedef int *(*pFun)(int, char*);
原声明的最简化版：
pFun a[5];

2. 原声明：void (*b[10]) (void (*)());
变量名为b，先替换右边部分括号里的，pFunParam为别名一：
typedef void (*pFunParam)();
再替换左边的变量b，pFunx为别名二：
typedef void (*pFunx)(pFunParam);
原声明的最简化版：
pFunx b[10];

3. 原声明：doube(*)() (*e)[9];
变量名为e，先替换左边部分，pFuny为别名一：
typedef double(*pFuny)();
再替换右边的变量e，pFunParamy为别名二
typedef pFuny (*pFunParamy)[9];
原声明的最简化版：
pFunParamy e;

理解复杂声明可用的“右左法则”：
从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：
int (*func)(int *p);
首先找到变量名func，外面有一对圆括号，而且左边是一个*号，这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明(*func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int*类型的形参，返回值类型是int。
int (*func[5])(int *);
func右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的*不是修饰func，而是修饰func[5]的，原因是[]运算符优先级比*高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指针，它指向的函数具有int*类型的形参，返回值类型为int。

也可以记住2个模式：
type (*)(....)函数指针
type (*)[]数组指针

*第二、两大陷阱*

*陷阱一：*

记住，typedef是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。比如：
先定义：
typedef char* PSTR;
然后：
int mystrcmp(const PSTR, const PSTR);

const PSTR实际上相当于const char*吗？不是的，它实际上相当于char*
const。
原因在于const给予了整个指针本身以常量性，也就是形成了常量指针char*
const。
简单来说，记住当const和typedef一起出现时，typedef不会是简单的字符串替换就行。

*陷阱二：*

typedef在语法上是一个存储类的关键字（如auto、extern、mutable、static、register等一样），虽然它并不真正影响对象的存储特性，如：
typedef static int INT2; //不可行
编译将失败，会提示“指定了一个以上的存储类”。

*以上资料出自：*[[http://blog.sina.com.cn/s/blog_4826f7970100074k.html]]
作者：赤龙

*第三、typedef 与 #define的区别*

案例一：

通常讲，typedef要比#define要好，特别是在有指针的场合。请看例子：

typedef char *pStr1;

#define pStr2 char *;

pStr1 s1, s2;

pStr2 s3, s4;

在上述的变量定义中，s1、s2、s3都被定义为char
*，而s4则定义成了char，不是我们所预期的指针变量，根本原因就在于#define只是简单的字符串替换而typedef则是为一个类型起新名字。

案例二：

下面的代码中编译器会报一个错误，你知道是哪个语句错了吗？

typedef char * pStr;

char string[4] = "abc";

const char *p1 = string;

const pStr p2 = string;

p1++;

p2++;

是p2++出错了。这个问题再一次提醒我们：typedef和#define不同，它不是简单的文本替换。上述代码中const
pStr p2并不等于const char * p2。const pStr p2和const long
x本质上没有区别，都是对变量进行只读限制，只不过此处变量p2的数据类型是我们自己定义的而不是系统固有类型而已。因此，const
pStr p2的含义是：限定数据类型为char *的变量p2为只读，因此p2++错误。

*第四部分资料：使用 typedef 抑制劣质代码*

作者：Danny Kalev
编译：MTT 工作室

原文出处：Using typedef to Curb Miscreant Code

*摘要：*Typedef
声明有助于创建平台无关类型，甚至能隐藏复杂和难以理解的语法。不管怎样，使用
typedef 能为代码带来意想不到的好处，通过本文你可以学习用 typedef
避免缺欠，从而使代码更健壮。

typedef 声明，简称 typedef，为现有类型创建一个新的名字。比如人们常常使用
typedef 来编写更美观和可读的代码。所谓美观，意指 typedef
能隐藏笨拙的语法构造以及平台相关的数据类型，从而增强可移植性和以及未来的可维护性。本文下面将竭尽全力来揭示
typedef 强大功能以及如何避免一些常见的陷阱。

Q：如何创建平台无关的数据类型，隐藏笨拙且难以理解的语法?

A： 使用 typedefs 为现有类型创建同义字。

*定义易于记忆的类型名*
typedef
使用最多的地方是创建易于记忆的类型名，用它来归档程序员的意图。类型出现在所声明的变量名字中，位于
''typedef'' 关键字右边。例如：

#+BEGIN_EXAMPLE
    typedef int size;
#+END_EXAMPLE

此声明定义了一个 int 的同义字，名字为 size。注意 typedef
并不创建新的类型。它仅仅为现有类型添加一个同义字。你可以在任何需要 int
的上下文中使用 size：

#+BEGIN_EXAMPLE
    void measure(size * psz); size array[4];size len = file.getlength();std::vector <size> vs;
#+END_EXAMPLE

typedef
还可以掩饰符合类型，如指针和数组。例如，你不用象下面这样重复定义有 81
个字符元素的数组：

#+BEGIN_EXAMPLE
    char line[81];char text[81];
#+END_EXAMPLE

定义一个 typedef，每当要用到相同类型和大小的数组时，可以这样：

#+BEGIN_EXAMPLE
    typedef char Line[81]; Line text, secondline;getline(text);
#+END_EXAMPLE

同样，可以象下面这样隐藏指针语法：

#+BEGIN_EXAMPLE
    typedef char * pstr;int mystrcmp(pstr, pstr);
#+END_EXAMPLE

这里将带我们到达第一个 typedef 陷阱。标准函数 strcmp()有两个‘const char
*'类型的参数。因此，它可能会误导人们象下面这样声明 mystrcmp()：

#+BEGIN_EXAMPLE
    int mystrcmp(const pstr, const pstr);
#+END_EXAMPLE

这是错误的，按照顺序，‘const pstr'被解释为‘char * const'（一个指向 char
的常量指针），而不是‘const char *'（指向常量 char
的指针）。这个问题很容易解决：

#+BEGIN_EXAMPLE
    typedef const char * cpstr; int mystrcmp(cpstr, cpstr); // 现在是正确的
#+END_EXAMPLE

*记住：*不管什么时候，只要为指针声明 typedef，那么都要在最终的 typedef
名称中加一个 const，以使得该指针本身是常量，而不是对象。

*代码简化*
上面讨论的 typedef 行为有点像 #define
宏，用其实际类型替代同义字。不同点是 typedef
在编译时被解释，因此让编译器来应付超越预处理器能力的文本替换。例如：

#+BEGIN_EXAMPLE
    typedef int (*PF) (const char *, const char *);
#+END_EXAMPLE

这个声明引入了 PF 类型作为函数指针的同义字，该函数有两个 const char *
类型的参数以及一个 int
类型的返回值。如果要使用下列形式的函数声明，那么上述这个 typedef
是不可或缺的：

#+BEGIN_EXAMPLE
    PF Register(PF pf);
#+END_EXAMPLE

Register() 的参数是一个 PF
类型的回调函数，返回某个函数的地址，其署名与先前注册的名字相同。做一次深呼吸。下面我展示一下如果不用
typedef，我们是如何实现这个声明的：

#+BEGIN_EXAMPLE
    int (*Register (int (*pf)(const char *, const char *))) (const char *, const char *);
#+END_EXAMPLE

很少有程序员理解它是什么意思，更不用说这种费解的代码所带来的出错风险了。显然，这里使用
typedef
不是一种特权，而是一种必需。持怀疑态度的人可能会问：“OK，有人还会写这样的代码吗？”，快速浏览一下揭示
*//* signal()函数的头文件 <csinal>，一个有同样接口的函数。

*typedef 和存储类关键字（storage class specifier）*
这种说法是不是有点令人惊讶，typedef 就像
auto，extern，mutable，static，和 register
一样，是一个存储类关键字。这并是说 typedef
会真正影响对象的存储特性；它只是说在语句构成上，typedef 声明看起来象
static，extern 等类型的变量声明。下面将带到第二个陷阱：

#+BEGIN_EXAMPLE
    typedef register int FAST_COUNTER; // 错误
#+END_EXAMPLE

编译通不过。问题出在你不能在声明中有多个存储类关键字。因为符号 typedef
已经占据了存储类关键字的位置，在 typedef 声明中不能用
register（或任何其它存储类关键字）。

*促进跨平台开发*
typedef
有另外一个重要的用途，那就是定义机器无关的类型，例如，你可以定义一个叫
REAL 的浮点类型，在目标机器上它可以i获得最高的精度：

#+BEGIN_EXAMPLE
    typedef long double REAL;
#+END_EXAMPLE

在不支持 long double 的机器上，该 typedef 看起来会是下面这样：

#+BEGIN_EXAMPLE
    typedef double REAL;
#+END_EXAMPLE

并且，在连 double 都不支持的机器上，该 typedef 看起来会是这样： 、

#+BEGIN_EXAMPLE
    typedef float REAL;
#+END_EXAMPLE

你不用对源代码做任何修改，便可以在每一种平台上编译这个使用 REAL
类型的应用程序。唯一要改的是 typedef
本身。在大多数情况下，甚至这个微小的变动完全都可以通过奇妙的条件编译来自动实现。不是吗?
标准库广泛地使用 typedef 来创建这样的平台无关类型：size_t，ptrdiff 和
fpos_t 就是其中的例子。此外，象 std::string 和 std::ofstream 这样的
typedef
还隐藏了长长的，难以理解的模板特化语法，例如：basic_string<char,
char_traits<char>，allocator<char>> 和 basic_ofstream<char,
char_traits<char>>。

** [[http://www.cnblogs.com/dc10101/archive/2007/08/22/865556.html][static的作用]]



在C语言中，static的字面意思很容易把我们导入歧途，其实它的作用有三条。

（1）先来介绍它的第一条也是最重要的一条：隐藏。

当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。为理解这句话，我举例来说明。我们要同时编译两个源文件，一个是a.c，另一个是main.c。

下面是a.c的内容

char a = 'A'; // global variable
 void msg()
 {
  printf("Hello\n");
 }



下面是main.c的内容

int main(void)
 {
  extern char a; // extern variable must be declared before use
  printf("%c ", a);
  (void)msg();
  return 0;
 }



程序的运行结果是：

A Hello

你可能会问：为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。

如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。Static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用。

（2）static的第二个作用是保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见，但我还是举一个例子。

#include <stdio.h>

 int fun(void){
  static int count = 10; // 事实上此赋值语句从来没有执行过
  return count--;
 }

 int count = 1;

 int main(void)
 {
  printf("global\t\tlocal static\n");
  for(; count <= 10; ++count)
  printf("%d\t\t%d\n", count, fun());

  return 0;
 }



程序的运行结果是：

global  local static

1  10

2  9

3  8

4  7

5  6

6  5

7  4

8   3

9  2

10  1



（3）static的第三个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加'\0'太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是'\0'。不妨做个小实验验证一下。

#include <stdio.h>

 int a;

 int main(void)
 {
  int i;
  static char str[10];

  printf("integer: %d; string: (begin)%s(end)", a, str);

  return 0;
 }

程序的运行结果如下

integer: 0; string: (begin)(end)

最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。

** [[http://www.cnblogs.com/wanghetao/archive/2012/04/04/2431760.html][sizeof和sizeof(string)的问题]]

今天看《程序员面试宝典》一书（为了应付将要到来的微软笔试），看到了sizeof(string)这个问题。在Dev
C++上测试的结果是4，很不明白。上网搜了一下，得到如下结果：

string strArr1[]={"Trend", "Micro", "Soft"};

sizeof(strArr1)=12



转自：[[http://apps.hi.baidu.com/share/detail/30398570]]

关于sizeof(string)，今天看那本面试宝典的时候看到这个表达式，有点吃惊，书上写着sizeof(string)=4;当时很纳闷，难道分配4个字节大小的内存给string吗？查阅了相关资料得出结论：string的实现在各库中可能有所不同，但是在同一库中相同一点是，无论你的string里放多长的字符串，它的sizeof()都是固定的，字符串所占的空间是从堆中动态分配的，与sizeof()无关。

sizeof(string)=4可能是最典型的实现之一，不过也有sizeof()为12、32字节的库实现。
但是VC6.0测试后sizeof(string)=16.还是跟编译器有关

#include<iostream>
using namespace std;
void main(void)
{
string a[] = {"aaaaa","bbbb","ccc"};
int x = sizeof(a);
int y = sizeof(string);
cout << x << endl;
cout << y << endl;
}

运行结果：

[[file:///C:/DOCUME~1/stoneboy/LOCALS~1/Temp/B59W8R[2QW0H)63MOX0[8UU.jpg]]

关于sizeof更多的用法摘自：[[http://hi.baidu.com/haijiaoshu/blog/item/a269f527706b910a908f9d5b.html]]

1、什么是sizeof

  首先看一下sizeof在msdn上的定义：

  The sizeof keyword gives the amount of storage, in bytes, associated
with a variable or a type (including aggregate types). This keyword
returns a value of type size_t.


看到return这个字眼，是不是想到了函数？错了，sizeof不是一个函数，你见过给一个函数传参数，而不加括号的吗？sizeof可以，所以sizeof不是函数。网上有人说sizeof是一元操作符，但是我并不这么认为，因为sizeof更像一个特殊的宏，它是在编译阶段求值的。举个例子：



cout<<sizeof(int)<<endl; // 32位机上int长度为4

cout<<sizeof(1==2)<<endl; // == 操作符返回bool类型，相当于
cout<<sizeof(bool)<<endl;

  在编译阶段已经被翻译为：

cout<<4<<endl;

cout<<1<<endl;

  这里有个陷阱，看下面的程序：

int a = 0;

cout<<sizeof(a=3)<<endl;

cout<<a<<endl;


输出为什么是4，0而不是期望中的4，3？？？就在于sizeof在编译阶段处理的特性。由于sizeof不能被编译成机器码，所以sizeof作用范围内，也就是()里面的内容也不能被编译，而是被替换成类型。=操作符返回左操作数的类型，所以a=3相当于int，而代码也被替换为：

int a = 0;

cout<<4<<endl;

cout<<a<<endl;


所以，sizeof是不可能支持链式表达式的，这也是和一元操作符不一样的地方。


结论：不要把sizeof当成函数，也不要看作一元操作符，把他当成一个特殊的编译预处理。

2、sizeof的用法

  sizeof有两种用法：



  （1）sizeof(object)

  也就是对对象使用sizeof，也可以写成sizeof object 的形式。例如：

  （2）sizeof(typename)

  也就是对类型使用sizeof，注意这种情况下写成sizeof
typename是非法的。下面举几个例子说明一下：



int i = 2;

cout<<sizeof(i)<<endl; // sizeof(object)的用法，合理

cout<<sizeof i<<endl; // sizeof object的用法，合理

cout<<sizeof 2<<endl; // 2被解析成int类型的object, sizeof
object的用法，合理

cout<<sizeof(2)<<endl; // 2被解析成int类型的object,
sizeof(object)的用法，合理

cout<<sizeof(int)<<endl;// sizeof(typename)的用法，合理

cout<<sizeof int<<endl; // 错误！对于操作符，一定要加()

  可以看出，加()是永远正确的选择。

  结论：不论sizeof要对谁取值，最好都加上()。

3、数据类型的sizeof

（1）C++固有数据类型

  32位C++中的基本数据类型，也就char,short int(short),int,long
int(long),float,double, long double

大小分别是：1，2，4，4，4，8, 10。

  考虑下面的代码：

cout<<sizeof(unsigned int) == sizeof(int)<<endl; // 相等，输出 1

  unsigned影响的只是最高位bit的意义，数据长度不会被改变的。

  结论：unsigned不能影响sizeof的取值。

（2）自定义数据类型

  typedef可以用来定义C++自定义类型。考虑下面的问题：

typedef short WORD;

typedef long DWORD;

cout<<(sizeof(short) == sizeof(WORD))<<endl; // 相等，输出1

cout<<(sizeof(long) == sizeof(DWORD))<<endl; // 相等，输出1

  结论：自定义类型的sizeof取值等同于它的类型原形。

（3）函数类型

  考虑下面的问题：

int f1(){return 0;};

double f2(){return 0.0;}

void f3(){}

cout<<sizeof(f1())<<endl; // f1()返回值为int，因此被认为是int

cout<<sizeof(f2())<<endl; // f2()返回值为double，因此被认为是double

cout<<sizeof(f3())<<endl; // 错误！无法对void类型使用sizeof

cout<<sizeof(f1)<<endl;  // 错误！无法对函数指针使用sizeof

cout<<sizeof*f2<<endl;  //
*f2，和f2()等价，因为可以看作object，所以括号不是必要的。被认为是double

  结论：对函数使用sizeof，在编译阶段会被函数返回值的类型取代，

4、指针问题

  考虑下面问题：



cout<<sizeof(string*)<<endl; // 4

cout<<sizeof(int*)<<endl; // 4

cout<<sizof(char****)<<endl; // 4


可以看到，不管是什么类型的指针，大小都是4的，因为指针就是32位的物理地址。

  结论：只要是指针，大小就是4。（64位机上要变成8也不一定）。


顺便唧唧歪歪几句，C++中的指针表示实际内存的地址。和C不一样的是，C++中取消了模式之分，也就是不再有small,middle,big,取而代之的是统一的flat。flat模式采用32位实地址寻址，而不再是c中的
segment:offset模式。举个例子，假如有一个指向地址
f000:8888的指针，如果是C类型则是8888(16位,
只存储位移，省略段)，far类型的C指针是f0008888(32位，高位保留段地址，地位保留位移),C++类型的指针是f8888(32位，相当于段地址*16
+ 位移，但寻址范围要更大)。

5、数组问题

  考虑下面问题：

char a[] = "abcdef";

int b[20] = {3, 4};

char c[2][3] = {"aa", "bb"};



cout<<sizeof(a)<<endl; // 7

cout<<sizeof(b)<<endl; // 20*4=80

cout<<sizeof(c)<<endl; // 6




数组a的大小在定义时未指定，编译时给它分配的空间是按照初始化的值确定的，也就是7。c是多维数组，占用的空间大小是各维数的乘积，也就是6。可以看出，数组的大小就是他在编译时被分配的空间，也就是各维数的乘积*数组元素的大小。

  结论：数组的大小是各维数的乘积*数组元素的大小。

  这里有一个陷阱：

int *d = new int[10];

cout<<sizeof(d)<<endl; // 4


d是我们常说的动态数组，但是他实质上还是一个指针，所以sizeof(d)的值是4。

  再考虑下面的问题：

double* (*a)[3][6];



cout<<sizeof(a)<<endl;  // 4

cout<<sizeof(*a)<<endl;  // 72

cout<<sizeof(**a)<<endl; // 24

cout<<sizeof(***a)<<endl; // 4

cout<<sizeof(****a)<<endl; // 8

  a是一个很奇怪的定义，他表示一个指向
double*[3][6]类型数组的指针。既然是指针，所以sizeof(a)就是4。


既然a是执行double*[3][6]类型的指针，*a就表示一个double*[3][6]的多维数组类型，因此sizeof(*a)=3*6*sizeof(double*)=72。同样的，**a表示一个double*[6]类型的数组，所以sizeof(**a)=6*sizeof(double*)=24。***a就表示其中的一个元素，也就是double*了，所以sizeof(***a)=4。至于****a，就是一个double了，所以sizeof(****a)=sizeof(double)=8。

6、向函数传递数组的问题。

  考虑下面的问题：

#include <iostream>

using namespace std;

int Sum(int i[])

{

int sumofi = 0;

for (int j = 0; j < sizeof(i)/sizeof(int); j++) //实际上，sizeof(i) = 4

{

  sumofi += i[j];

}

return sumofi;

}

int main()

{

int allAges[6] = {21, 22, 22, 19, 34, 12};

cout<<Sum(allAges)<<endl;

system("pause");

return 0;

}


Sum的本意是用sizeof得到数组的大小，然后求和。但是实际上，传入自函数Sum的，只是一个int
类型的指针，所以sizeof(i)=4，而不是24，所以会产生错误的结果。解决这个问题的方法使是用指针或者引用。

  使用指针的情况：

int Sum(int (*i)[6])

{

int sumofi = 0;

for (int j = 0; j < sizeof(*i)/sizeof(int); j++) //sizeof(*i) = 24

{

  sumofi += (*i)[j];

}

return sumofi;

}

int main()

{

int allAges[] = {21, 22, 22, 19, 34, 12};

cout<<Sum(&allAges)<<endl;

system("pause");

return 0;

}

  在这个Sum里，i是一个指向i[6]类型的指针，注意，这里不能用int Sum(int
(*i)[])声明函数，而是必须指明要传入的数组的大小，不然sizeof(*i)无法计算。但是在这种情况下，再通过sizeof来计算数组大小已经没有意义了，因为此时大小是指定为6的。

使用引用的情况和指针相似：

int Sum(int (&i)[6])

{

int sumofi = 0;

for (int j = 0; j < sizeof(i)/sizeof(int); j++)

{

  sumofi += i[j];

}

return sumofi;

}

int main()

{

int allAges[] = {21, 22, 22, 19, 34, 12};

cout<<Sum(allAges)<<endl;

system("pause");

return 0;

}


这种情况下sizeof的计算同样无意义，所以用数组做参数，而且需要遍历的时候，函数应该有一个参数来说明数组的大小，而数组的大小在数组定义的作用域内通过sizeof求值。因此上面的函数正确形式应该是：

#include <iostream>

using namespace std;

int Sum(int *i, unsigned int n)

{

int sumofi = 0;

for (int j = 0; j < n; j++)

{

  sumofi += i[j];

}

return sumofi;

}

int main()

{

int allAges[] = {21, 22, 22, 19, 34, 12};

cout<<Sum(i, sizeof(allAges)/sizeof(int))<<endl;

system("pause");

return 0;

}

7、字符串的sizeof和strlen

  考虑下面的问题：

char a[] = "abcdef";

char b[20] = "abcdef";

string s = "abcdef";

cout<<strlen(a)<<endl;  // 6，字符串长度

cout<<sizeof(a)<<endl;  // 7，字符串容量

cout<<strlen(b)<<endl;  // 6，字符串长度

cout<<sizeof(b)<<endl;  // 20，字符串容量

cout<<sizeof(s)<<endl;  // 12,
这里不代表字符串的长度，而是string类的大小

cout<<strlen(s)<<endl;  // 错误！s不是一个字符指针。

a[1] = '\0';

cout<<strlen(a)<<endl;  // 1

cout<<sizeof(a)<<endl;  // 7，sizeof是恒定的


strlen是寻找从指定地址开始，到出现的第一个0之间的字符个数，他是在运行阶段执行的，而sizeof是得到数据的大小，在这里是得到字符串的容量。所以对同一个对象而言，sizeof的值是恒定的。string是C++类型的字符串，他是一个类，所以sizeof(s)表示的并不是字符串的长度，而是类string的大小。strlen(s)根本就是错误的，因为strlen的参数是一个字符指针，如果想用strlen得到s字符串的长度，应该使用sizeof(s.c_str())，因为string的成员函数c_str()返回的是字符串的首地址。实际上，string类提供了自己的成员函数来得到字符串的容量和长度，分别是Capacity()和Length()。string封装了常用了字符串操作，所以在C++开发过程中，最好使用string代替C类型的字符串。

8、从union的sizeof问题看cpu的对界

  考虑下面问题：（默认对齐方式）

union u

{

  double a;

  int b;

};

union u2

{

  char a[13];

  int b;

};

union u3

{

  char a[13];

  char b;

};

cout<<sizeof(u)<<endl;  // 8

cout<<sizeof(u2)<<endl;  // 16

cout<<sizeof(u3)<<endl;  // 13


都知道union的大小取决于它所有的成员中，占用空间最大的一个成员的大小。所以对于u来说，大小就是最大的double类型成员a了，所以sizeof(u)=sizeof(double)=8。但是对于u2和u3，最大的空间都是char[13]类型的数组，为什么u3的大小是13，而u2是16呢？关键在于u2中的成员int
b。由于int类型成员的存在，使u2的对齐方式变成4，也就是说，u2的大小必须在4的对界上，所以占用的空间变成了16（最接近13的对界）。


结论：复合数据类型，如union，struct，class的对齐方式为成员中对齐方式最大的成员的对齐方式。


顺便提一下CPU对界问题，32的C++采用8位对界来提高运行速度，所以编译器会尽量把数据放在它的对界上以提高内存命中率。对界是可以更改的，使用#pragma
pack(x)宏可以改变编译器的对界方式，默认是8。C++固有类型的对界取编译器对界方式与自身大小中较小的一个。例如，指定编译器按2对界，int类型的大小是4，则int的对界为2和4中较小的2。在默认的对界方式下，因为几乎所有的数据类型都不大于默认的对界方式8（除了long
double），所以所有的固有类型的对界方式可以认为就是类型自身的大小。更改一下上面的程序：

#pragma pack(2)

union u2

{

  char a[13];

  int b;

};

union u3

{

  char a[13];

  char b;

};

#pragma pack(8)

cout<<sizeof(u2)<<endl;  // 14

cout<<sizeof(u3)<<endl;  // 13


由于手动更改对界方式为2，所以int的对界也变成了2，u2的对界取成员中最大的对界，也是2了，所以此时sizeof(u2)=14。

  结论：C++固有类型的对界取编译器对界方式与自身大小中较小的一个。

9、struct的sizeof问题


因为对齐问题使结构体的sizeof变得比较复杂，看下面的例子：(默认对齐方式下)

struct s1

{

  char a;

  double b;

  int c;

  char d;

};

struct s2

{

  char a;

  char b;

  int c;

  double d;

};

cout<<sizeof(s1)<<endl; // 24

cout<<sizeof(s2)<<endl; // 16


同样是两个char类型，一个int类型，一个double类型，但是因为对界问题，导致他们的大小不同。计算结构体大小可以采用元素摆放法，我举例子说明一下：首先，CPU判断结构体的对界，根据上一节的结论，s1和s2的对界都取最大的元素类型，也就是double类型的对界8。然后开始摆放每个元素。


对于s1，首先把a放到8的对界，假定是0，此时下一个空闲的地址是1，但是下一个元素d是double类型，要放到8的对界上，离1最接近的地址是8了，所以d被放在了8，此时下一个空闲地址变成了16，下一个元素c的对界是4，16可以满足，所以c放在了16，此时下一个空闲地址变成了20，下一个元素d需要对界1，也正好落在对界上，所以d放在了20，结构体在地址21处结束。由于s1的大小需要是8的倍数，所以21-23的空间被保留，s1的大小变成了24。


对于s2，首先把a放到8的对界，假定是0，此时下一个空闲地址是1，下一个元素的对界也是1，所以b摆放在1，下一个空闲地址变成了2；下一个元素c的对界是4，所以取离2最近的地址4摆放c，下一个空闲地址变成了8，下一个元素d的对界是8，所以d摆放在8，所有元素摆放完毕，结构体在15处结束，占用总空间为16，正好是8的倍数。


这里有个陷阱，对于结构体中的结构体成员，不要认为它的对齐方式就是他的大小，看下面的例子：

struct s1

{

  char a[8];

};

struct s2

{

  double d;

};

struct s3

{

  s1 s;

  char a;

};

struct s4

{

  s2 s;

  char a;

};

cout<<sizeof(s1)<<endl; // 8

cout<<sizeof(s2)<<endl; // 8

cout<<sizeof(s3)<<endl; // 9

cout<<sizeof(s4)<<endl; // 16;


s1和s2大小虽然都是8，但是s1的对齐方式是1，s2是8（double），所以在s3和s4中才有这样的差异。


所以，在自己定义结构体的时候，如果空间紧张的话，最好考虑对齐因素来排列结构体里的元素。

10、不要让double干扰你的位域


在结构体和类中，可以使用位域来规定某个成员所能占用的空间，所以使用位域能在一定程度上节省结构体占用的空间。不过考虑下面的代码：

struct s1

{

  int i: 8;

  int j: 4;

  double b;

  int a:3;

};

struct s2

{

  int i;

  int j;

  double b;

  int a;

};

struct s3

{

  int i;

  int j;

  int a;

  double b;

};

struct s4

{

  int i: 8;

  int j: 4;

  int a:3;

  double b;

};

cout<<sizeof(s1)<<endl;  // 24

cout<<sizeof(s2)<<endl;  // 24

cout<<sizeof(s3)<<endl;  // 24

cout<<sizeof(s4)<<endl;  // 16


可以看到，有double存在会干涉到位域（sizeof的算法参考上一节），所以使用位域的的时候，最好把float类型和double类型放在程序的开始或者最后。

** [[http://www.cnblogs.com/chenyuming507950417/archive/2012/01/05/2313647.html][C++关键字mutable]]

Mutable

（1）mutable的意思是“可变的，易变的”，跟C++中的const是反义词。

（2）在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中

实例说明：

#+BEGIN_EXAMPLE
    #include <iostream>using namespace std;class TestMutable{public:    TestMutable(){i=0;}    int Output() const    {        return i++; //error C2166: l-value specifies const object    }private:    int i;};int main(){   TestMutable testMutable;   cout<<testMutable.Output()<<endl;   return 0;}
#+END_EXAMPLE

显然i++在const修饰的函数里是编译通不过的。

#+BEGIN_EXAMPLE
    #include <iostream>using namespace std;class TestMutable{public:    TestMutable(){i=0;}    int Output() const    {        return i++;     }private:    mutable int i;};int main(){   TestMutable testMutable;   cout<<testMutable.Output()<<endl;   return 0;}
#+END_EXAMPLE

在 int i 前面加上
mutable上面就能编译通过了，马上可以看出关键字mutable的作用了。

** PID

PID调节器。工程上常常用在闭环系统中加入PID环节，对系统的传递函数进行修正，以快速的跟踪变化，消除稳态误差。

PID调节器中的P为比例环节，起放大作用。I为积分环节，可以消灭稳态误差。D为微分环节，可以加快系统的反应。

直流电机中加入PID调节器，可以实现快速启动。当系统中突发干扰、负载变化或者使用者主动调速是，PID环节可以帮助电机缩减过渡时间、进入新的稳定状态。




** [[http://andyhuzhill.github.io/html/shaolu.html][Linux系统下烧录单片机]]


有些人说Linux下怎么开发单片机程 序？
我们学得都是在Windows下的开发工具和烧录工具。其实这
只是中国的情况，中国大都是用Windows系统的。所以我们也只接
触到Windows下的开发工具。在国外，许多大牛是不用Windows的。那么，他们如果要做单片机怎么办？肯定没问题的，Linux也有许多的单片机和嵌入式的开发工具。下面，我以51系列单片机为例，介绍一下怎么使用Linux系统玩单片机。



首先，说一下我的硬件和软件情况。

硬件：

一台笔记本、 一个51单片机开发板
（这个在网上有很多卖，也就150左右的价格） 。单片机芯片有两块
：一块是Atmel的AT89S52，
另一块是STC的STC89C52RC 。USB转串口线一根（串口通信和STC下载用）。USBISP下载线一根（AT89S52下载用）。

软件：

操作系统：Ubuntu
11.04 （内核2.6.38-10-generic）、 sdcc(单片机C语言编译器)、 avrdude（AT单片机下载程序）、gSTCISP(STC单片机下载程序) 、objcopy（GUN 开
发工具里的 ，应该默认Linux都会安装）



操作系统的安装就不讲了。

SDCC可以在网上下到源代码然后编译
安装。/*SDCC也有Windows版本，不过我这只讲Linux下的东西，如果有兴趣请自己百度Google一下*/

不过这样很麻烦，而且不一定安装的上。我们的ubuntu 有超级牛力（不知道这个？在终端下输入apt-get就知道啦。）直接在终端下输入以下命令：

sudo apt-get install sdcc sdcc-doc

先讲AT89S52的下载

首先是安装AT89S52的下载软件 ，还是用ubuntu的超级牛力：


 sudo apt-get install gcc-avr binutils-avr avrdude avr-libc



 然后编辑avrdude.conf 以使得avrdude可以下载51的单片机



sudo gedit /etc/avrdude.conf



在最后面加入AT89s52的相关信息(这是Joy Shukla写的)





/#------------------------------------------------------------
 # Below chips by added by me .. Joy
Shukla([[mailto:joy_shukla@yahoo.in][joy_shukla@yahoo.in]])
 # these chips can be programmed with my usbasp programmer(changed
atmega8 program)
 # after adding avrdude support in this file ..
 #------------------------------------------------------------

 #------------------------------------------------------------
 # AT89S52
 #------------------------------------------------------------
 part
 id = "8052";
 desc = "AT89S52";
 signature = 0x1E 0x52 0x06;
 chip_erase_delay = 20000;
 pgm_enable = "1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1",
 "x x x x x x x x x x x x x x x x";

 chip_erase = "1 0 1 0 1 1 0 0 1 0 0 x x x x x",
 "x x x x x x x x x x x x x x x x";

 timeout = 200;
 stabdelay = 100;
 cmdexedelay = 25;
 synchloops = 32;
 bytedelay = 0;
 pollindex = 3;
 pollvalue = 0x53;
 predelay = 1;
 postdelay = 1;
 pollmethod = 0;

 memory "flash"
 size = 8192;
 paged = no;
 min_write_delay = 4000;
 max_write_delay = 9000;
 readback_p1 = 0xff;
 readback_p2 = 0xff;
 read = " 0 0 1 0 0 0 0 0",
 " x x x a12 a11 a10 a9 a8",
 " a7 a6 a5 a4 a3 a2 a1 a0",
 " o o o o o o o o";

 write = " 0 1 0 0 0 0 0 0",
 " x x x a12 a11 a10 a9 a8",
 " a7 a6 a5 a4 a3 a2 a1 a0",
 " i i i i i i i i";
 mode = 0x21;
 delay = 12;
 ;

 memory "signature"
 size = 3;
 read = "0 0 1 0 1 0 0 0 x x x 0 0 0 a1 a0",
 "0 0 0 0 0 0 0 0 o o o o o o o o";
 ;
 ;
 #------------------------------------------------------------/

然后保存
 现在就可以烧录AT89S52的单片机了,

 用命令

 sudo avrdude -p 8052 -c usbasp -e -U flash:w:'跑马灯.hex'

就可以烧录了 你可以把命令中的”跑马灯.hex”换 成你自己的程序。

如果觉得 命令太长 太难记， 那么推荐你使用 makefile来自动完成。

我是这样做的

在工作目录下建立一个makefile， 内容如下：



###########内容开始#############

main：

sdcc liushui.c #注意 这一行以及一下每行开头都是一个Tab

packihx liushui.ihx>liushui.hex #SDCC默认的输出格式是ihx 我
们把它转换成hex

sudo avrdude -p 8052 -c usbasp -e -U flash:w:liushui.hex
#这就是烧录的语句，其实最后的格式是ihx也可以烧录的

##########内容结束###############

保存之后 在工作目录下只要输入一句 make 就 可以完成 编译 烧录
一步到位了。

/*当然你得保障程序能正常编译，下载 器和单片机都连接好了*/



接下来讲讲如何烧录STC单片机

STC的程序编写 不用我说了
。它的下载是用gSTCISP 貌似是一个中国人写的，还是图形界面的。

[[http://forum.ubuntu.org.cn/download/file.php?id=104628&sid=767b624faf73a36c71fcd4f8111773ef][gSTCISP]] [[http://forum.ubuntu.org.cn/download/file.php?id=104628&sid=767b624faf73a36c71fcd4f8111773ef][下
载地址]]如下

[[http://forum.ubuntu.org.cn/download/file.php?id=104628&sid=767b624faf73a36c71fcd4f8111773e]]

gSTCISP下载要求的格式是bin 我 在网上也没找到所谓的Hex2bin 程序 ，不过
发现用 objcopy 也 可以把 hex文件转化为bin'文件，姑且我就先这么用了。

生成hex文件后，用如下命令将hex转化为bin

objcopy -I ihex -O binary liushui.hex liushui.bin # I 和O 都 是大写

 然后 打开gSTCISP （我直接把它cp到了/usr/bin，
就可以直接在提示符下输入gSTCISP运行了）

  选择port（端 口） 我的是/dev/ttyUSB0 然后选择文件
选择刚刚生成的bin文件 点击DownLoad

  好像STC的 是要先断电再上电的时候 就能把程序写入单片机了

当你看到Program OK Have already encrypt.就说明你烧录成功啦。




写在最后：

我其实也是一个小菜鸟，这其实只是我的一次笔记而已。而且有些地方还写得很罗嗦。高手可以直接略过啦。使用Linux 做
单片机可以不用学怎么去用鼠标操纵不同图形界面的IDE（集成开发环
境），只需考虑自己要做的程序，然后记住需要的编译选项，而且SDCC是windows
Linux通用的，在linux写的代码，makefile 在windows下甚至可以不用改
或者改动少许就能使用。而且Linux不用去装什么下载线驱动，我的usbisp下载线
和usb转串口下载线都是直接插上就可以下载了。


** [[http://www.cnblogs.com/MuyouSome/p/3175806.html][时钟周期、振荡周期、机器周期、CPU周期、状态周期、指令周期、总线周期、任务周期]]

   [[http://blog.csdn.net/yangtalent1206/article/details/5853017]]

计算机系统有一系列的“周期”概念，区别、联系地理解这些概念至关重要。以下对*时钟周期、振荡周期、机器周期、CPU周期、状态周期、指令周期、总线周期、任务周期*进行简单介绍。

*周期*

在电子技术中，脉冲信号是一个按一定电压幅度，一定时间间隔连续发出的脉冲信号。脉冲信号之间的时间间隔称为周期；而将在单位时间（如1秒）内所产生的脉冲个数称为频率。频率是描述周期性循环信号（包括脉冲信号）在单位时间内所出现的脉冲数量多少的计量名称；频率的标准计量单位是Hz（赫）。电脑中的系统时钟就是一个典型的频率相当精确和稳定的脉冲信号发生器。



*时钟周期*

时钟周期，一般也称振荡周期（如果晶振的输出没有经过分频就直接作为cpu的工作时钟，则时钟周期就等于振荡周期），即CPU的晶振的工作频率的倒数，是计算机中最基本的、最小的时间单位。通常成为节拍脉冲或者T周期。对于单片机时钟周期，时钟周期是单片机的基本时间单位，*两个振荡周期(时钟周期)组成一个状态周期。*



*振荡周期*（oscillating period）

在衰减振荡中，两个相邻同方向峰值之间的时间称为振荡周期Tp，振荡频率2π/Tp。在相同衰减比下，振荡周期越短或振荡频率越高，则回复时间越短，因此振荡周期(频率)反映系统响应快慢的指标。



*机器周期*

机器周期，一般也叫CPU周期。在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段（如，取指令、存储器读、存储器写等），每一阶段完成一项工作（称为一个基本操作）。完成一个基本操作所需要的时间称为机器周期。一般情况下，一个机器周期由若干个S周期（状态周期）组成。



*CPU周期*

又称机器周期，CPU周期定义为从内存读取一条指令字的最短时间。一个指令周期常由若干CPU周期构成。



*状态周期*

在8051单片机中把一个时钟周期定义为一个节拍（用P表示），二个节拍定义为一个状态周期（用S表示）。

8051系列单片机的一个机器周期同6个S周期（状态周期）组成。一个机器周期包含6个状态周期（S1-S6）,而一个状态周期又包含两个时钟振荡周期（简称时钟周期）。例：8051单片机的机器周期由6个状态周期组成，也就是说一个机器周期=6个状态周期=12个时钟周期。



*指令周期*

指令周期是执行一条指令所需要的时间，即CPU从内存取出一条指令并执行这条指令的时间总和。一般由若干个机器周期组成，从取指令、分析指令到执行完所需的全部时间。指令不同，所需的机器周期数也不同。对于一些简单的的单字节指令，在取指令周期中，指令取出到指令寄存器后，立即译码执行，不再需要其它的机器周期。对于一些比较复杂的指令，例如转移指令、乘法指令，则需要两个或者两个以上的机器周期。通常含一个机器周期的指令称为单周期指令，包含两个机器周期的指令称为双周期指令。



*总线周期*

总线周期通常指的使通过总线完成一次内存读写操作或完成一次输入输出设备的读写操作所必须的时间。由于存储器和I/O端口是挂接在总线上的，CPU对存储器和I/O接口的访问，是通过总线实现的。通常把CPU通过总线对微处理器外部（存储器或I/O接口）进行一次访问所需时间称为一个总线周期。一个总线周期一般包含4个时钟周期，这4个时钟周期分别称4个状态即T1状态、T2状态、T3状态和T4状态。



*任务周期*


周期任务是指计算机系统按一定周期达到并请求运行，每次请求称为任务的一个任务实例，任务实例所属任务的起始时刻称为该任务实例的到达时刻，任务实例被置为就绪态的时刻称为该任务实例的释放时刻。

** [[http://www.crifan.com/try_use_doxygen_to_generate_doc_for_python/][]]

** [[http://blog.csdn.net/czyt1988/article/details/8901191][C++标准注释原则 - 基于doxygen的C++注释]]



*** 标注总述

下载国外的源代码，往往能看到附带的说明文档，文档都有详细的说明，大部分文档都可以通过doxygen这个跨平台软件生成，doxygen并不能随便读取你的C++的注释,必须按照一定的规则才能生成，所以在编写代码时，一定要按照标准写注释，否则会为以后带来许多麻烦

下面介绍C++的标注写法，c++不推荐c语言式的/*
*/风格注释，这里，除了文件头使用这种注释外其余到使用C++风格的注释。

先看看总述：



文件头：

#+BEGIN_EXAMPLE
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    /*!
    * \file Ctext.h
    * \brief 概述
    *
    *详细概述
    *
    * \author 作者名字
    * \version 版本号(maj.min，主版本.分版本格式)
    * \date 日期
    */
#+END_EXAMPLE



命名空间：

#+BEGIN_EXAMPLE
    /// \brief 命名空间的简单概述
    ///
    ///命名空间的详细概述
    namespace text
    {
     ……
    }
#+END_EXAMPLE



 类说明：

#+BEGIN_EXAMPLE
    /// \brief Ctext的doxygen测试
    ///
    /// 作doxygen测试用
    class Ctext
    {
    }
#+END_EXAMPLE



 函数标注
    方法1：

#+BEGIN_EXAMPLE
        /// \brief 函数简要说明-测试函数
        /// \param n1 参数1
        /// \param c2 参数2
        /// \return 返回说明
        bool text(int n1,Ctext c2);
#+END_EXAMPLE

   方法2：

#+BEGIN_EXAMPLE
        /// \brief 函数简要说明-测试函数
        ///
        /// 函数详细说明，这里写函数的详细说明信息，说明可以换行
        /// ，如这里所示，同时需要注意的是详细说明和简要说明之间必须空一行
        /// ，详细说明之前不需要任何标识符
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        /// \return 返回说明
        /// \see text
        bool text2(int n1,Ctext c2);
#+END_EXAMPLE



 变量及枚举


#+BEGIN_EXAMPLE
       int m_a;     ///< 成员变量1m_a说明
        double m_b; ///< 成员变量2m_b说明


        /// \brief 成员变量m_c简要说明
        ///
        /// 成员变量m_c的详细说明，这里可以对变量进行
        ///详细的说明和描述，具体方法和函数的标注是一样的
        float m_c;


        /// \brief xxx枚举变量的简要说明
        ///
        /// xxx枚举变量的详细说明--枚举变量的详细说明和函数的详细说明
        ///的写法是一致的。每个枚举变量下可以进行单独说明
        enum{
            em_1,///< 枚举值1的说明
            em_2,///< 枚举值2的说明
            em_3 ///< 枚举值3的说明
        };
#+END_EXAMPLE




*** 1.文件头说明

文件头说明按照如下格式写

#+BEGIN_EXAMPLE
    /*!
    * \file Ctext.h
    * \brief 概述
    *
    *详细概述
    *
    * \author 作者,包含email等
    * \version 版本号(maj.min，主版本.分版本格式)
    * \date 日期
    */
#+END_EXAMPLE


 上注释等下于下面这种写法

#+BEGIN_EXAMPLE
    /*!
     \file Ctext.h
    \brief 概述
    详细概述
    \author 作者,包含email等
    \version 版本号(maj.min，主版本.分版本格式)
    \date 日期
    */
#+END_EXAMPLE




对于vs编译器可能中间那行*号比较麻烦，可以不写，对于Qt这种要去掉中间的*号反而是件麻烦事就不用去掉
 用doxygen生成注释如下效果

[[http://img.blog.csdn.net/20130508165355086]]



[[http://img.blog.csdn.net/20130508165557535]]

*** 2. 命名空间

***

命名空间说明如下写

#+BEGIN_EXAMPLE
    /// \brief 命名空间的简单概述
    ///
    ///命名空间的详细概述
    namespace text
    {

    }
#+END_EXAMPLE


 doxygen的说明写法都是类似于

#+BEGIN_EXAMPLE
    /// \brief
    ///
    ///
#+END_EXAMPLE


 以下将会见到很多这样的写法
 上注释的doxygen效果如下
 [[http://img.blog.csdn.net/20130508165701768]]


*** 3. 类说明


 类的注释和函数一样，


#+BEGIN_EXAMPLE
    /// \brief Ctext的doxygen测试
    ///
    /// 作doxygen测试用
    class Ctext
    {
    }
#+END_EXAMPLE


 上注释用doxygen生成文档效果如下：
 [[http://img.blog.csdn.net/20130508165756125]]

[[http://img.blog.csdn.net/20130508165806875]]




*** 4.函数注释原则

函数详细注释位于头文件，cpp文件只对函数做简明注释
 cpp文件不做///的注释，否则会和头文件重叠

**** 4.1 函数简要说明

注释方法1：

#+BEGIN_EXAMPLE
        /// \brief 函数简要说明-测试函数
        /// \param n1 参数1
        /// \param c2 参数2
        /// \return 返回说明
        bool text(int n1,Ctext c2);
#+END_EXAMPLE


 简要注释此注释会让doxygen生成函数简要说明和参数说明
 生成结果如：
 [[http://img.blog.csdn.net/20130508165935341]]


**** 4.2 函数简要说明+详细说明



#+BEGIN_EXAMPLE
        /// \brief 函数简要说明-测试函数
        ///
        /// 函数详细说明，这里写函数的详细说明信息，说明可以换行
        /// ，如这里所示，同时需要注意的是详细说明和简要说明之间必须空一行
        /// ，详细说明之前不需要任何标识符
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        /// \return 返回说明
        bool text2(int n1,Ctext c2);
#+END_EXAMPLE


 上注释用doxygen生成文档效果如下：
 [[http://img.blog.csdn.net/20130508170015199]]



**** 4.3 不带简要说明的函数标注

#+BEGIN_EXAMPLE
        /// 函数说明-测试函数
        ///
        /// 函数详细说明，这里写函数的详细说明信息，说明可以换行
        /// ，如这里所示，同时需要注意的是详细说明和简要说明之间必须空一行
        /// ，详细说明之前不需要任何标识符
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        /// \return 返回说明
        bool text3(int n1,Ctext c2);
#+END_EXAMPLE


 上注释用doxygen生成文档效果如下：
 [[http://img.blog.csdn.net/20130508170100995]]
 这里没有说明
 [[http://img.blog.csdn.net/20130508170122338]]



**** 4.4 带参见的写法

#+BEGIN_EXAMPLE
        /// \brief 函数说明-测试函数4
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        /// \return 返回说明
        /// \see text3 text2 text
        bool text4(int n1,Ctext c2);
#+END_EXAMPLE


 上注释用doxygen生成文档效果如下：
 [[http://img.blog.csdn.net/20130508170203321]]


 \see 上可以带中文等说明，doxygen会自动识别代码里存在的函数


*** 5.变量注释


 变量注释用///< 对变量进行说明，对于详细信息可以加\brief


#+BEGIN_EXAMPLE
        int m_a;     ///< 成员变量1m_a说明
        double m_b; ///< 成员变量2m_b说明

        /// \brief 成员变量m_c简要说明
        ///
        /// 成员变量m_c的详细说明，这里可以对变量进行
        ///详细的说明和描述，具体方法和函数的标注是一样的
        float m_c;
#+END_EXAMPLE



如果变量需要详细说明的可已按照m_c的写法写，*注意，m_b和m_c之间一定需要空行*，否则会导致m_b的简述消失
 上注释用doxygen生成文档的具体效果如下
 [[http://img.blog.csdn.net/20130508170247054]]

 [[http://img.blog.csdn.net/20130508170321178]]



*** 6.枚举


 枚举变量的标注方法如下


#+BEGIN_EXAMPLE
        /// \brief xxx枚举变量的简要说明
        ///
        /// xxx枚举变量的详细说明--枚举变量的详细说明和函数的详细说明
        ///的写法是一致的。每个枚举变量下可以进行单独说明
        enum{
            em_1,///< 枚举值1的说明
            em_2,///< 枚举值2的说明
            em_3 ///< 枚举值3的说明
        };
#+END_EXAMPLE




枚举的总体说明和函数的写法一致，每个枚举变量的说明和变量的说明写法一致
 上注释用doxygen生成效果如下：

 [[http://img.blog.csdn.net/20130508170401801]]

[[http://img.blog.csdn.net/20130508170410863]]





*** 7.doxygen的设置和中文问题



**** 7.1 生成私有成员


 如果想生成私有成员（doxygen默认不生成私有成员），可以如下设置
 选择Expert标签的Build项，勾选EXTRACT_PRIVATE即可


**** 7.2 中文问题

中文有时候是乱码
 对于vs2010的文档，默认是gb2312，可以设置
 Expert标签的Project项目的DOXYFILE_ENCODING 为 GB18030
 INPUT_ENCODING 为 GB18030

另外Project项目的生成语言（OUTPUT_LANGUAGE）选择Chinese



对于其他的代码文件如果中文乱码，可以用文本编辑器转换代码文本编码为UTF-8带BOM的（注意这有可能影响代码，所以转换编码时要备份），再进行导出。
 [[http://img.blog.csdn.net/20130508170446847]]



[[http://img.blog.csdn.net/20130508170504659]]



*** 8.vs2008、vs2010 及以上IDE的快速标注方法

vs2010 等编译器并不能像Qt
Creator那样生成上述标注样式，但是可以集成到vs的工具栏里，集成方法如下图所示：

[[http://img.blog.csdn.net/20130508212959822]]

这样在标注时可以直接从工具箱拖曳了，非常方便





*** 附：

Ctext.h


#+BEGIN_EXAMPLE
    /*!
    * \file Ctext.h
    * \brief 概述
    *
    *详细概述
    *
    * \author 作者,包含email等
    * \version 版本号(maj.min，主版本.分版本格式)
    * \date 日期
    */

    #pragma once
    /// \brief 命名空间的简单概述
    ///
    ///命名空间的详细概述
    namespace text
    {

    }

    /// \brief Ctext的doxygen测试
    ///
    /// 作doxygen测试用
    class Ctext
    {
    public:
        Ctext(void);
        ~Ctext(void);
        /// \brief 函数简要说明-测试函数
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        ///    \return 返回说明
        bool text(int n1,Ctext c2);
        /// \brief 函数简要说明-测试函数
        ///
        /// 函数详细说明，这里写函数的详细说明信息，说明可以换行
        /// ，如这里所示，同时需要注意的是详细说明和简要说明之间必须空一行
        /// ，详细说明之前不需要任何标识符
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        ///    \return 返回说明
        bool text2(int n1,Ctext c2);
        /// 函数说明-测试函数
        ///
        /// 函数详细说明，这里写函数的详细说明信息，说明可以换行
        /// ，如这里所示，同时需要注意的是详细说明和简要说明之间必须空一行
        /// ，详细说明之前不需要任何标识符
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        ///    \return 返回说明
        bool text3(int n1,Ctext c2);
        /// \brief 函数说明-测试函数4
        /// \param n1 参数1说明
        /// \param c2 参数2说明
        ///    \return 返回说明
        /// \see text3 text2 text
        bool text4(int n1,Ctext c2);

        int m_a;     ///< 成员变量1m_a说明
        double m_b; ///< 成员变量2m_b说明

        /// \brief 成员变量m_c简要说明
        ///
        /// 成员变量m_c的详细说明，这里可以对变量进行
        ///详细的说明和描述，具体方法和函数的标注是一样的
        float m_c;

        /// \brief xxx枚举变量的简要说明
        ///
        /// xxx枚举变量的详细说明--枚举变量的详细说明和函数的详细说明
        ///的写法是一致的。每个枚举变量下可以进行单独说明
        enum{
            em_1,///< 枚举值1的说明
            em_2,///< 枚举值2的说明
            em_3 ///< 枚举值3的说明
        };
    };
#+END_EXAMPLE



另外可看看这篇文章里面的注释：
http://blog.csdn.net/czyt1988/article/details/21743595

** [[http://www.douban.com/group/topic/40892505/][python安装模块的多种方法。]]

1、自己写的模块，可以直接添加到路径下。这样就可以直接调用。
import sys
sys.path.append("/home/username/")

2、单文件模块

直接把文件拷贝到$python_dir/lib

3、网上下载的第三方库，一般解压后，找setup.py文件
运行python setup.py install

4、 egg文件

1) 下载ez_setup.py,运行python ez_setup

2) easy_install *.egg

5、pip安装方法

Pip 是安装python包的工具，提供了安装包，列出已经安装的包，升级包以及卸载包的功能。

Pip 是对easy_install的取代，提供了和easy_install相同的查找包的功能，因此可以使用easy_install安装的包也同样可以使用pip进行安装。



安装Pip

Pip的安装可以通过源代码包，easy_install或者脚本。

下面介绍一下各种安装方法：

源代码方式：

$ wget https://pypi.python.org/packages/source/p/pip/pip-1.2.1.tar.gz （替换为最新的包）
$ tar xzf pip-1.2.1.tar.gz
$ cd pip-1.2.1.tar.gz
$ python setup.py install

easy_install:

$ easy_install pip

get_pip.py 脚本：

$ curl -0 https://raw.github.com/pypa/pip/master/contrib/get-pip.py

$ sudo python get-pip.py



OK, 下面来看一下Pip的使用

安装package

$ pip install Markdown

列出安装的packages

$ pip freeze

安装特定版本的package

通过使用==, >=, <=, >, <来指定一个版本号。

$ pip install 'Markdown<2.0'

$ pip install 'Markdown>2.0,<2.0.3'

升级包

升级包到当前最新的版本，可以使用-U 或者 --upgrade

$ pip install -U Markdown

卸载包

$ pip uninstall Markdown

查询包

pip search "Markdown"

6、特殊库的安装（一个科学计算库Enthought Python Distribution的安装）

Enthought Python Distribution在ubuntu下安装的测试，应一个网友的请求，问怎么安装这个库，从官方网站上下载了一个文件

epd_free-7.3-2-rh5-x86.sh，遮个文件是sh 格式的文件，用sudo bash epd_free-7.3-2-rh5-x86.sh 运行这个文件，出现很多权限的阅读，点回车，不要连续点

需要点一次看一下，最后出现一个同一不同一它的版权声明，输入"yes",再下来是让选择安装的目录，点回车，就安装在当前目录下。

这样就安装好了。

当前目录下输入

>>> ipython --pylab

就出来

Python 2.7.3 (default, Apr 20 2012, 22:44:07)
Type "copyright", "credits" or "license" for more information.

IPython 0.12.1 -- An enhanced Interactive Python.
? -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help -> Python's own help system.
object? -> Details about 'object', use 'object??' for extra details.

Welcome to pylab, a matplotlib-based Python environment [backend: TkAgg].
For more information, type 'help(pylab)'.

再这样调用。这个库由于我工作上用不上，所以也不需要进一步的研究。

In [1]: from scipy import *

In [2]: a=zeros(1000)

In 3]: a[:100]=1

In [4: b=fft(a)

In [5]: plot(abs(b))


7、windows平台下，可以找对应python版本的exe安装包。

比喻：python2.7.3下 MySQL-python-1.2.3.win32-py2.7.exe

或 MySQL-python-1.2.3.win-amd64-py2.7.exe

** [[http://www.iplaysoft.com/top10-programming-fonts.html][10大最适合编程的字体推荐下载，让代码看起来更美更舒服！]]



[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/10fonts.jpg]]


现在有事没事就喜欢写写代码的人越来越多了，对于成天盯着屏幕工作的开发人员来说，编程代码可能是每天见得最多的东西了。可是绝大部分人都一直使用编辑器默认的字体，其实，换一套适合自己的[[http://www.iplaysoft.com/top10-programming-fonts.html][编程字体]]不仅能让代码看得更舒服，甚至还能提高工作效率的！


如果你有想过换一种*编程字体*，却不知道哪里找合适的，那么看看异次元软件世界为您推荐的[[http://www.iplaysoft.com/top10-programming-fonts.html][10款最适合编程的字体]]吧，这些字体能让你的代码瞬间“优雅”起来！换一种字体，换一番心情嘛。当然，除了编程之外，经常需要编辑英文文档的朋友同样适用......

**** 前言：


下面字体的排序是作者的主观感受，每个人的喜好都不一样。建议您都试试，按照自己的喜好来选择。另外，还在使用
[[http://www.iplaysoft.com/winxp-sp3-vol.html][Windows XP]]
的同学，如果您希望显示到如截图中清晰的字体效果，则必须安装微软的[[http://dl.iplaysoft.com/files/1090.html][ClearType设置程序]]对清晰度进行设置。

**** 10. Courier

也叫Courier
New，这大概是我们最熟悉的[[http://www.iplaysoft.com/top10-programming-fonts.html][字体]]了，基本上所有系统都有。很不幸，很多终端和编辑器都默认使用此种字体，虽然不会影响使用，但它太无趣了。如果你正在使用这种字体，建议调大一点，并打开系统的
anti-aliasing (抗锯齿) 设置。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image001.png]]

[[http://dl.iplaysoft.com/files/1079.html][下载 Courier New 字体]]

**** 9. Andale Mono

比Courier稍好，也是常见的默认[[http://www.iplaysoft.com/top10-programming-fonts.html][字体]]。我感觉字母太宽了，字符间距也比较蠢。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image002.png]]

[[http://dl.iplaysoft.com/files/1080.html][下载 Andale Mono 字体]]

**** 8. Monaco

Mac的默认字体，好像也只有Mac上有。小字号的时候表现不错，而且再大些也不寒碜。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image003.png]]

[[http://dl.iplaysoft.com/files/1081.html][下载 Monaco 字体]]

**** 7. Profont

与Monaco类似的位图字体，你能够在Mac,
Windows和Linux上面使用。小字号的时候表现好。非Mac平台上Monaco的最佳替代。喜欢小字号且不怕眼睛疲劳的同学可以考虑。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image004.png]]

[[http://dl.iplaysoft.com/files/1082.html][下载 Profont 字体]]

**** 6. Monofur

独特的等宽字体，各种字号下都表现不错，但是需要设置anti-aliasing。怀旧而且喜欢与众不同的人推荐。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image005.png]]

[[http://dl.iplaysoft.com/files/1083.html][下载 Monofur 字体]]

**** 5. Proggy

干净的等宽字体，好像很受Windows用户欢迎，但在Mac上也不错。使用时，字号可以小一点，无需anti-aliasing。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image006.png]]

[[http://dl.iplaysoft.com/files/1084.html][下载 Proggy 字体]]

**** 4. Droid Sans Mono

开源[[http://www.iplaysoft.com/top10-programming-fonts.html][字体]]，可以在这里下载，适合手机屏幕。是等宽字体中最突出的一个。可惜0和O区别不大。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image007.png]]

[[http://dl.iplaysoft.com/files/1085.html][下载 Droid Sans Mono 字体]]

**** 3. Deja Vu Sans Mono

我最喜欢的免费字体系列，以Vera为基础，但是比后者提供更多字符了。适于任何字号，需要anti-aliasing。

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image008.png]]

[[http://dl.iplaysoft.com/files/1086.html][下载 Deja Vu Sans Mono 字体]]

**** 2. Consolas + 中文雅黑混合版

Consolas
是商业字体，专门为微软设计，微软不少产品上都有，所以很可能你的系统上已经有了。需要anti-aliasing。如果不是商业的，我可能就把它放第一了。Consolas仅含英文字母部分，这里提供的是雅黑中文+Consolas英文的混合体，即使代码里有中文注释显示效果也能很好的！

[[http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image009.png]]

[[http://www.iplaysoft.com/consolas.html][下载 Consolas 雅黑字体]]

**** 1. Inconsolata

我最喜欢的等宽字体，免费。我遇到它之后，很快就把原来的默认字体Deja Vu
Sans
Mono抛弃了。真正适合任何字号的好[[http://www.iplaysoft.com/top10-programming-fonts.html][字体]]。感谢它的创造者Raph
Levien！

** [[http://www.cnblogs.com/awpatp/archive/2011/02/27/1966380.html][Foo, Bar是什么意思？]]

有些朋友问：foo, bar是什么意思, 为什么C++书籍中老见到这个词。



我google了一下，
发现没有很好的中文答案。这个问题，在维基百科上有很好的回答。在这里翻译给大家。



译文：

术语*foobar*, *foo*, *bar*, *baz*
和*qux*经常在计算机编程或计算机相关的文档中被用作[[http://en.wikipedia.org/wiki/Placeholder_name][占位符]]的名字。当变量，函数，或命令本身不太重要的时候，*foobar*,
*foo*, *bar*, *baz*
和*qux*就被用来充当这些实体的名字，这样做的目的仅仅是阐述一个概念，说明一个想法。这些术语本身相对于使用的场景来说没有任何意义。Foobar经常被单独使用；而当需要多个实体举例的时候，foo，bar，和baz则经常被按顺序使用。

** [[http://net.pku.edu.cn/~yhf/tutorial/awk_manual.html][Unix awk使用手册]]

作者的话：

《UNIX AWK使用手册》是我几个月前的作品了，回过头来看，这
篇文章实在是很粗燥，因当时我写作并上传这个作品时实在是太
忙了，没有对文章的质量进行很好的检查，心里老觉得有愧于网
友的厚爱，于是趁闲赶忙重写一遍，虽然不一定会有很大的改观
，但质量是肯定要好一点的，唯如此，我的良心上才好受一点，
呶，下面就是我的修改稿，各位老友请与第一版相比一下，看是
否有所进步！

这次改写仍然保留了原有的风格：正文由浅入深，文后附上了大
量的相关资料，这样做的原因是为了满足各种用户的需求，这在
第一版中已经说过了。这次主要的改变是在内容上，加入了很多
新内容，并增加了示例，以帮助读者理解其中的内容，附录也补
充了许多新的资料。当然读者要真正地掌握awk，仅仅读了本文
是不够的，还必须有上机实习这一步。值得提醒大家的是，awk
有很多版本，并且各个版本之间存在着一些差别，因此，在使用
awk以前最好参考一下你使用的系统的联机帮助。

什么是awk?

你可能对UNIX比较熟悉，但你可能对awk很陌生，这一点也不奇
怪，的确，与其优秀的功能相比，awk还远没达到它应有的知名
度。awk是什么？与其它大多数UNIX命令不同的是，从名字上看
，我们不可能知道awk的功能：它既不是具有独立意义的英文单
词，也不是几个相关单词的缩写。事实上，awk是三个人名的缩
写，他们是：Aho、(Peter)Weinberg和(Brain)Kernighan。正是
这三个人创造了awk---一个优秀的样式扫描与处理工具。

AWK的功能是什么？与sed和grep很相似，awk是一种样式扫描与
处理工具。但其功能却大大强于sed和grep。 awk提供了极其强
大的功能：它几乎可以完成grep和sed所能完成的全部工作，同
时，它还可以可以进行样式装入、流控制、数学运算符、进程控
制语句甚至于内置的变量和函数。它具备了一个完整的语言所应
具有的几乎所有精美特性。实际上，awk的确拥有自己的语言：
awk程序设计语言，awk的三位创建者已将它正式定义为：样式扫
描和处理语言。

为什么使用awk?

即使如此，你也许仍然会问，我为什么要使用awk?

使用awk的第一个理由是基于文本的样式扫描和处理是我们经常
做的工作，awk所做的工作有些象数据库，但与数据库不同的是
，它处理的是文本文件，这些文件没有专门的存储格式，普通的
人们就能编辑、阅读、理解和处理它们。而数据库文件往往具有
特殊的存储格式，这使得它们必须用数据库处理程序来处理它们
。既然这种类似于数据库的处理工作我们经常会遇到，我们就应
当找到处理它们的简便易行的方法，UNIX有很多这方面的工具，
例如sed 、grep、sort以及find等等，awk是其中十分优秀的一
种。

使用awk的第二个理由是awk是一个简单的工具，当然这是相对于
其强大的功能来说的。的确，UNIX有许多优秀的工具，例如UNIX
天然的开发工具C语言及其延续C++就非常的优秀。但相对于它们
来说，awk完成同样的功能要方便和简捷得多。这首先是因为awk
提供了适应多种需要的解决方案：从解决简单问题的awk命令行
到复杂而精巧的awk程序设计语言，这样做的好处是，你可以不
必用复杂的方法去解决本来很简单的问题。例如，你可以用一个
命令行解决简单的问题，而C不行，即使一个再简单的程序，C语
言也必须经过编写、编译的全过程。其次，awk本身是解释执行
的，这就使得awk程序不必经过编译的过程，同时，这也使得它
与shell script程序能够很好的契合。最后，awk本身较C语言简
单，虽然awk吸收了C语言很多优秀的成分，熟悉C语言会对学习
awk有很大的帮助，但 awk本身不须要会使用C语言——一种功能强
大但需要大量时间学习才能掌握其技巧的开发工具。

使用awk的第三个理由是awk是一个容易获得的工具。与C和C++语
言不同，awk只有一个文件(/bin/awk)，而且几乎每个版本的
UNIX都提供各自版本的awk，你完全不必费心去想如何获得awk。
但C语言却不是这样，虽然C语言是UNIX天然的开发工具，但这个
开发工具却是单独发行的，换言之，你必须为你的UNIX版本的C
语言开发工具单独付费（当然使用D版者除外），获得并安装它
，然后你才可以使用它。

基于以上理由，再加上awk强大的功能，我们有理由说，如果你
要处理与文本样式扫描相关的工作，awk应该是你的第一选择。
在这里有一个可遵循的一般原则：如果你用普通的shell工具或
shell script有困难的话，试试awk,如果awk仍不能解决问题，
则便用C语言，如果C语言仍然失败，则移至C++。

awk的调用方式

前面曾经说过，awk提供了适应多种需要的不同解决方案，它们
是：

一、 awk命令行，你可以象使用普通UNIX命令一样使用awk，在
命令行中你也可以使用awk程序设计语言，虽然awk支持多行的录
入，但是录入长长的命令行并保证其正确无误却是一件令人头疼
的事，因此，这种方法一般只用于解决简单的问题。当然，你也
可以在shell script程序中引用awk命令行甚至awk程序脚本。

二、使用-f选项调用awk程序。awk允许将一段awk程序写入一个
文本文件，然后在awk命令行中用-f选项调用并执行这段程序。
具体的方法我们将在后面的awk语法中讲到。

三、利用命令解释器调用awk程序：利用UNIX支持的命令解释器
功能，我们可以将一段awk程序写入文本文件，然后在它的第一
行加上:
#!/bin/awk -f
并赋予这个文本文件以执行的权限。这样做之后，你就可以在命
令行中用类似于下面这样的方式调用并执行这段awk程序了。

$awk脚本文本名待处理文件

awk的语法：

与其它UNIX命令一样，awk拥有自己的语法：

awk [ -F re] [parameter...] ['prog'] [-f progfile]
[in_file...]

参数说明：

-F re:允许awk更改其字段分隔符。

parameter: 该参数帮助为不同的变量赋值。

'prog': awk的程序语句段。这个语句段必须用单拓号：'和'括
起，以防被shell解释。这个程序语句段的标准形式为：

'pattern {action}'

其中pattern参数可以是egrep正则表达式中的任何一个，它可以
使用语法/re/再加上一些样式匹配技巧构成。与sed类似，你也
可以使用","分开两样式以选择某个范围。关于匹配的细节，你
可以参考附录，如果仍不懂的话，找本UNIX书学学grep和sed（
本人是在学习ed时掌握匹配技术的）。 action参数总是被大括
号包围，它由一系统awk语句组成，各语句之间用";"分隔。awk
解释它们，并在pattern给定的样式匹配的记录上执行其操作。
与shell类似，你也可以使用“#”作为注释符，它使“#”到行尾的
内容成为注释，在解释执行时，它们将被忽略。你可以省略
pattern和 action之一，但不能两者同时省略，当省略pattern
时没有样式匹配，表示对所有行（记录）均执行操作，省略
action时执行缺省的操作——在标准输出上显示。

-f progfile:允许awk调用并执行progfile指定有程序文件。
progfile是一个文本文件，他必须符合awk的语法。

in_file:awk的输入文件，awk允许对多个输入文件进行处理。值
得注意的是awk不修改输入文件。如果未指定输入文件，awk将接
受标准输入，并将结果显示在标准输出上。awk支持输入输出重
定向。

awk的记录、字段与内置变量：

前面说过，awk处理的工作与数据库的处理方式有相同之处，其
相同处之一就是awk支持对记录和字段的处理，其中对字段的处
理是grep和sed不能实现的，这也是awk优于二者的原因之一。在
awk中，缺省的情况下总是将文本文件中的一行视为一个记录，
而将一行中的某一部分作为记录中的一个字段。为了操作这些不
同的字段，awk借用shell的方法，用$1,$2,$3...这样的方式来
顺序地表示行（记录）中的不同字段。特殊地，awk用$0表示整
个行（记录）。不同的字段之间是用称作分隔符的字符分隔开的
。系统默认的分隔符是空格。awk允许在命令行中用-F re的形式
来改变这个分隔符。事实上，awk用一个内置的变量FS来记忆这
个分隔符。awk中有好几个这样的内置变量，例如，记录分隔符
变量RS、当前工作的记录数NR等等，本文后面的附表列出了全部
的内置变量。这些内置的变量可以在awk程序中引用或修改，例
如，你可以利用NR变量在模式匹配中指定工作范围，也可以通过
修改记录分隔符RS让一个特殊字符而不是换行符作为记录的分隔
符。

例:显示文本文件myfile中第七行到第十五行中以字符%分隔的第
一字段，第三字段和第七字段：

awk -F % 'NR==7,NR==15 {printf $1 $3 $7}'

awk的内置函数

awk 之所以成为一种优秀的程序设计语言的原因之一是它吸收了
某些优秀的程序设计语言（例如C）语言的许多优点。这些优点
之一就是内置函数的使用，awk定义并支持了一系列的内置函数
，由于这些函数的使用，使得awk提供的功能更为完善和强大，
例如，awk使用了一系列的字符串处理内置函数(这些函数看起来
与C 语言的字符串处理函数相似，其使用方式与C语言中的函数
也相差无几)，正是由于这些内置函数的使用，使awk处理字符串
的功能更加强大。本文后面的附录中列有一般的awk所提供的内
置函数，这些内置函数也许与你的awk版本有些出入，因此，在
使用之前，最好参考一下你的系统中的联机帮助。

作为内置函数的一个例子，我们将在这里介绍awk的printf函数
，这个函数使得awk与c语言的输出相一致。实际上，awk中有许
多引用形式都是从C语言借用过来的。如果你熟悉C语言，你也许
会记得其中的printf函数，它提供的强大格式输出功能曾经带我
们许多的方便。幸运的是，我们在awk中又和它重逢了。awk中
printf几乎与C语言中一模一样，如果你熟悉C语言的话，你完全
可以照C语言的模式使用awk中的printf。因此在这里，我们只给
出一个例子，如果你不熟悉的话，请随便找一本C语言的入门书
翻翻。

例:显示文件myfile中的行号和第3字段：

$awk '{printf"%03d%s\n",NR,$1}' myfile

在命令行使用awk

按照顺序，我们应当讲解awk程序设计的内容了，但在讲解之前
，我们将用一些例子来对前面的知识进行回顾，这些例子都是在
命令行中使用的，由此我们可以知道在命令行中使用awk是多么
的方便。这样做的原因一方面是为下面的内容作铺垫，另一方面
是介绍一些解决简单问题的方法，我们完全没有必要用复杂的方
法来解决简单的问题----既然awk提供了较为简单的方法的话。

例：显示文本文件mydoc匹配（含有）字符串"sun"的所有行。

$awk '/sun/{print}' mydoc

由于显示整个记录（全行）是awk的缺省动作，因此可以省略
action项。

$awk '/sun/' mydoc

例：下面是一个较为复杂的匹配的示例：

$awk '/[Ss]un/,/[Mm]oon/ {print}' myfile

它将显示第一个匹配Sun或sun的行与第一个匹配Moon或moon的行
之间的行，并显示到标准输出上。

例：下面的示例显示了内置变量和内置函数length（）的使用：

$awk 'length($0)>80 {print NR}' myfile

该命令行将显示文本myfile中所有超过80个字符的行号，在这里
，用$0表示整个记录（行），同时，内置变量NR不使用标志符
'$'。

例：作为一个较为实际的例子，我们假设要对UNIX中的用户进行
安全性检查，方法是考察/etc下的passwd文件，检查其中的
passwd字段（第二字段）是否为"*"，如不为"*"，则表示该用户
没有设置密码，显示出这些用户名（第一字段）。我们可以用如
下语句实现：

#awk -F: '$2=="" {printf("%s no password!\n",$1' /etc/
passwd

在这个示例中，passwd文件的字段分隔符是“：”，因此，必须用
-F：来更改默认的字段分隔符，这个示例中也涉及到了内置函数
printf的使用。

awk的变量

如同其它程序设计语言一样，awk允许在程序语言中设置变量，
事实上，提供变量的功能是程序设计语言的其本要求，不提供变
量的程序设计语言本人还从未见过。

awk 提供两种变量，一种是awk内置的变量，这前面我们已经讲
过，需要着重指出的是，与后面提到的其它变量不同的是，在
awk程序中引用内置变量不需要使用标志符"$"（回忆一下前面讲
过的NR的使用）。awk提供的另一种变量是自定义变量。awk允许
用户在awk程序语句中定义并调用自已的变量。当然这种变量不
能与内置变量及其它awk保留字相同，在awk中引用自定义变量必
须在它前面加上标志符"$"。与C语言不同的是，awk中不需要对
变量进行初始化， awk根据其在awk中第一次出现的形式和上下
文确定其具体的数据类型。当变量类型不确定时，awk默认其为
字符串类型。这里有一个技巧：如果你要让你的 awk程序知道你
所使用的变量的明确类型，你应当在在程序中给它赋初值。在后
面的实例中，我们将用到这一技巧。

运算与判断：

作为一种程序设计语言所应具有的特点之一，awk支持多种运算
，这些运算与C语言提供的几本相同：如+、-、*、/、%等等，同
时，awk也支持C语言中类似++、--、+=、-=、=+、=-之类的功能
，这给熟悉C语言的使用者编写awk程序带来了极大的方便。作为
对运算功能的一种扩展，awk还提供了一系列内置的运算函数（
如log、sqr、cos、sin等等）和一些用于对字符串进行操作（运
算）的函数（如length、substr等等）。这些函数的引用大大的
提高了awk的运算功能。

作为对条件转移指令的一部分，关系判断是每种程序设计语言都
具备的功能，awk也不例外。 awk中允许进行多种测试，如常用
的==（等于）、！=（不等于）、>（大于）、<（小于）、>=（
大于等于）、>=（小于等于）等等，同时，作为样式匹配，还提
供了~（匹配于）和！~（不匹配于）判断。

作为对测试的一种扩充，awk也支持用逻辑运算符:!(非)、&&（
与）、||（或）和括号（）进行多重判断，这大大增强了awk的
功能。本文的附录中列出了awk所允许的运算、判断以及操作符
的优先级。

awk的流程控制

流程控制语句是任何程序设计语言都不能缺少的部分。任何好的
语言都有一些执行流程控制的语句。awk提供的完备的流程控制
语句类似于C语言，这给我们编程带来了极大的方便。

1、BEGIN和END:

在awk 中两个特别的表达式，BEGIN和END，这两者都可用于
pattern中（参考前面的awk语法），提供BEGIN和END的作用是给
程序赋予初始状态和在程序结束之后执行一些扫尾的工作。任何
在BEGIN之后列出的操作（在{}内）将在awk开始扫描输入之前执
行，而END之后列出的操作将在扫描完全部的输入之后执行。因
此，通常使用BEGIN来显示变量和预置（初始化）变量，使用END
来输出最终结果。

例：累计销售文件xs中的销售金额（假设销售金额在记录的第三
字段）：

$awk
>'BEGIN { FS=":";print "统计销售金额";total=0}
>{print $3;total=total+$3;}
>END {printf "销售金额总计：%.2f",total}' sx
（注：>是shell提供的第二提示符，如要在shell程序awk语句和
awk语言中换行，则需在行尾加反斜杠\）

在这里，BEGIN预置了内部变量FS（字段分隔符）和自定义变量
total,同时在扫描之前显示出输出行头。而END则在扫描完成后
打印出总合计。

2、流程控制语句
awk提供了完备的流程控制语句，其用法与C语言类似。下面我们
一一加以说明：

2.1、if...else语句:

格式：
if(表达式)
语句1
else
语句2

格式中"语句1"可以是多个语句，如果你为了方便awk判断也方便
你自已阅读，你最好将多个语句用{}括起来。awk分枝结构允许
嵌套，其格式为：

if(表达式1）
{if(表达式2）
语句1
else
语句2
}
语句3
else {if(表达式3)
语句4
else
语句5
}
语句6

当然实际操作过程中你可能不会用到如此复杂的分枝结构，这里
只是为了给出其样式罢了。

2.2、while语句

格式为:

while(表达式)
语句

2.3、do-while语句

格式为:

do
{
语句
}while(条件判断语句）

2.4、for语句

格式为：

for(初始表达式;终止条件;步长表达式)
{语句}

在awk 的 while、do-while和for语句中允许使用
break,continue语句来控制流程走向，也允许使用exit这样的语
句来退出。break 中断当前正在执行的循环并跳到循环外执行下
一条语句。continue从当前位置跳到循环开始处执行。对于exit
的执行有两种情况：当exit语句不在 END中时，任何操作中的
exit命令表现得如同到了文件尾，所有模式或操作执行将停止，
END模式中的操作被执行。而出现在END中的exit将导致程序终止
。

例：为了

awk中的自定义函数

定义和调用用户自己的函数是几乎每个高级语言都具有的功能，
awk也不例外，但原始的awk并不提供函数功能，只有在nawk或较
新的awk版本中才可以增加函数。

函数的使用包含两部分：函数的定义与函数调用。其中函数定义
又包括要执行的代码（函数本身）和从主程序代码传递到该函数
的临时调用。

awk函数的定义方法如下：

function 函数名(参数表){
函数体
}

在gawk中允许将function省略为func，但其它版本的awk不允许
。函数名必须是一个合法的标志符，参数表中可以不提供参数（
但在调用函数时函数名后的一对括号仍然是不可缺少的），也可
以提供一个或多个参数。与C语言相似，awk的参数也是通过值来
传递的。

在awk 中调用函数比较简单，其方法与C语言相似，但awk比C语
言更为灵活，它不执行参数有效性检查。换句话说，在你调用函
数时，可以列出比函数预计（函数定义中规定）的多或少的参数
，多余的参数会被awk所忽略，而不足的参数，awk将它们置为缺
省值0或空字符串，具体置为何值，将取决于参数的使用方式。

awk函数有两种返回方式：隐式返回和显式返回。当awk执行到函
数的结尾时，它自动地返回到调用程序，这是函数是隐式返回的
。如果需要在结束之前退出函数，可以明确地使用返回语句提前
退出。方法是在函数中使用形如：return 返回值格式的语句。

例：下面的例子演示了函数的使用。在这个示例中，定义了一个
名为print_header的函数，该函数调用了两个参数FileName和
PageNum， FileName参数传给函数当前使用的文件名，PageNum
参数是当前页的页号。这个函数的功能是打印（显示）出当前文
件的文件名，和当前页的页号。完成这个功能后，这个函数将返
回下一页的页号。

nawk
>'BEGIN{pageno=1;file=FILENAME
>pageno=print_header(file，pageno)；#调用函数
print_header
>printf("当前页页号是：%d\n",pageno);
>}

>#定义函数print_header
>function print_header(FileName,PageNum){
>printf("%s %d\n",FileName,PageNum); >PageNum++;return
PageNUm;
>}
>}' myfile

执行这个程序将显示如下内容：

myfile 1
当前页页号是：2

awk高级输入输出

1.读取下一条记录：

awk的next语句导致awk读取下一个记录并完成模式匹配，然后立
即执行相应的操作。通常它用匹配的模式执行操作中的代码。
next导致这个记录的任何额外匹配模式被忽略。

2.简单地读取一条记录

awk 的 getline语句用于简单地读取一条记录。如果用户有一个
数据记录类似两个物理记录，那么getline将尤其有用。它完成
一般字段的分离(设置字段变量$0 FNR NF NR)。如果成功则返回
1，失败则返回0（到达文件尾）。如果需简单地读取一个文件，
则可以编写以下代码：

例：示例getline的使用

{while(getline==1)
{
#process the inputted fields
}
}

也可以使getline保存输入数据在一个字段中，而不是通过使用
getline variable的形式处理一般字段。当使用这种方式时，NF
被置成0，FNR和NR被增值。

用户也可以使用getline<"filename"方式从一个给定的文件中输
入数据，而不是从命令行所列内容输入数据。此时，getline将
完成一般字段分离（设置字段变量$0和NF)。如果文件不存在，
返回-1,成功，返回1,返回0表示失败。用户可以从给定文件中读
取数据到一个变量中，也可以用stdin(标准输入设备）或一个包
含这个文件名的变量代替filename。值得注意的是当使用这种方
式时不修改FNR和NR。

另一种使用getline语句的方法是从UNIX命令接受输入，例如下
面的例子:

例：示例从UNIX命令接受输入

{while("who -u"|getline)
{
#process each line from the who command
}
}

当然，也可以使用如下形式:

"command" | getline variable

3.关闭文件:

awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的
close语句。

close("filename")

filename可以是getline打开的文件（也可以是stdin,包含文件
名的变量或者getline使用的确切命令）。或一个输出文件（可
以是stdout，包含文件名的变量或使用管道的确切命令）。

4.输出到一个文件:

awk中允许用如下方式将结果输出到一个文件：

printf("hello word!\n")>"datafile"
或
printf("hello word!\n")>>"datafile"

5.输出到一个命令

awk中允许用如下方式将结果输出到一个命令：

printf("hello word!\n")|"sort-t','"

awk与shell script混合编程

因为awk可以作为一个shell命令使用，因此awk能与shell批处理
程序很好的融合在一起，这给实现awk与shell程序的混合编程提
供了可能。实现混合编程的关键是awk与shell script之间的对
话，换言之，就是awk与shell script之间的信息交流:awk从
shell script中获取所需的信息（通常是变量的值）、在awk中
执行shell命令行、shell script将命令执行的结果送给awk处理
以及shell script读取awk的执行结果等等。

1.awk读取Shell script程序变量

在awk中我们可以通过“'$变量名'”的方式读取sell scrpit程序
中的变量。

例：在下面的示例中，我们将读取sell scrpit程序中的变量
Name，该变量存放的是文本myfile的撰写者，awk将打印出这个
人名。

$cat writename
:
# @(#)
#
.
.
.
Name="张三" nawk 'BEGIN {name="'Name'";\ printf("\t%s\t
撰写者%s\n",FILENAME,name");}\
{...}END{...}' myfile
.
.
.

2.将shell命令的执行结果送给awk处理

作为信息传送的一种方法，我们可以将一条shell命令的结果通
过管道线（|）传递给awk处理：

例：示例awk处理shell命令的执行结果

$who -u | awk '{printf("%s正在执行%s\n",$2,$1)}'

该命令将打印出注册终端正在执行的程序名。

3.shell script程序读awk的执行结果

为了实现shell script程序读取awk执行的结果，我们可以采取
一些特殊的方法，例如我们可以用变量名=`awk语句`的形式将
awk执行的结果存放入一个 shell script变量。当然也可以用管
道线的方法将awk执行结果传递给shell script程序处理。

例：作为传送消息的机制之一，UNIX提供了一个向其所有用户传
送消息的命令wall（意思是write to all写给所有用户），该命
令允许向所有工作中的用户（终端）发送消息。为此，我们可以
通过一段shell批处理程序wall.shell来模拟这一程序（事实上
比较老的版本中wall就是一段shell批处理程序：

$cat wall.shell
:
# @(#) wall.shell:发送消息给每个已注册终端
#
cat >/tmp/$$
#用户录入消息文本 who -u | awk '{print $2}' | while read
tty
do
cat /tmp/$$>$tty
done

在这个程序里，awk接受who -u命令的执行结果，该命令打印出
所有已注册终端的信息，其中第二个字段是已注册终端的设备名
，因此用awk命令析出该设备名，然后用while read tty语句循
环读出这些文件名到变量（shell script变量）tty中，作为信
息传送的终结地址。

4.在awk中执行shell命令行----嵌入函数system()

system()是一个不适合字符或数字类型的嵌入函数，该函数的功
能是处理作为参数传递给它的字符串。system对这个参数的处理
就是将其作为命令处理，也就是说将其当作命令行一样加以执行
。这使得用户在自己的awk程序需要时可以灵活地执行命令或脚
本。

例：下面的程序将使用system嵌入函数打印用户编制好的报表文
件，这个文件存放在名为myreport.txt的文件中。为简约起见，
我们只列出了其END部分：

.
.
.
END {close("myreport.txt");system("lp myreport.txt");}

在这个示例中，我们首先使用close语句关闭了文件
myreport.txt文件，然后使用system嵌入函数将myreport.txt送
入打印机打印。

写到这里，我不得不跟朋友们说再见了，实在地说，这些内容仍
然是awk的初步知识，电脑永远是前进的科学，awk也不例外，本
篇所能做的只是在你前行的漫漫长途中铺平一段小小开端，剩下
的路还得靠你自己去走。老实说，如果本文真能给你前行的路上
带来些许的方便，那本人就知足了！

如对本篇有任何疑问，请E-mail To:Chizlong@yeah.net或到主
页http://chizling.yeah.net中留言。

附录：

1.awk的常规表达式元字符

\ 换码序列
^ 在字符串的开头开始匹配
$ 在字符串的结尾开始匹配
. 与任何单个字符串匹配
[ABC] 与[]内的任一字符匹配
[A-Ca-c] 与A-C及a-c范围内的字符匹配（按字母表顺序）
[^ABC] 与除[]内的所有字符以外的任一字符匹配
Desk|Chair 与Desk和Chair中的任一个匹配
[ABC][DEF] 关联。与A、B、C中的任一字符匹配，且其后要跟D
、E、F中的任一个字符。
 * 与A、B或C中任一个出现0次或多次的字符相匹配
+ 与A、B或C中任何一个出现1次或多次的字符相匹配
？与一个空串或A、B或C在任何一个字符相匹配
（Blue|Black）berry 合并常规表达式，与Blueberry或
Blackberry相匹配

2.awk算术运算符

运算符用途
------------------
x^y x的y次幂
x**y 同上
x%y 计算x/y的余数（求模）
x+y x加y
x-y x减y
x*y x乘y
x/y x除y
-y 负y(y的开关符号);也称一目减
++y y加1后使用y(前置加）
y++ 使用y值后加1（后缀加）
--y y减1后使用y(前置减）
y-- 使用后y减1(后缀减）
x=y 将y的值赋给x
x+=y 将x+y的值赋给x
x-=y 将x-y的值赋给x
x*=y 将x*y的值赋给x
x/=y 将x/y的值赋给x x%=y 将x%y的值赋给x
x^=y 将x^y的值赋给x
x**=y 将x**y的值赋给x

3.awk允许的测试：

操作符含义

x==y x等于y
x!=y x不等于y
x>y x大于y
x>=y x大于或等于y
x<y x小于y
x<=y x小于或等于y?
x~re x匹配正则表达式re?
x!~re x不匹配正则表达式re?

4.awk的操作符(按优先级升序排列)

= 、+=、 -=、 *= 、/= 、 %=
||
&&
> >= < <= == != ~ !~
xy (字符串连结，'x''y'变成"xy"）
+ -
 * / %
++ --

5.awk内置变量（预定义变量）

说明：表中v项表示第一个支持变量的工具（下同）：A=awk，N=
nawk,P=POSIX awk,G=gawk

V 变量含义缺省值
--------------------------------------------------------
N ARGC 命令行参数个数
G ARGIND 当前被处理文件的ARGV标志符
N ARGV 命令行参数数组
G CONVFMT 数字转换格式 %.6g
P ENVIRON UNIX环境变量
N ERRNO UNIX系统错误消息
G FIELDWIDTHS 输入字段宽度的空白分隔字符串
A FILENAME 当前输入文件的名字
P FNR 当前记录数
A FS 输入字段分隔符空格
G IGNORECASE 控制大小写敏感0（大小写敏感）
A NF 当前记录中的字段个数
A NR 已经读出的记录数
A OFMT 数字的输出格式 %.6g
A OFS 输出字段分隔符空格
A ORS 输出的记录分隔符新行
A RS 输入的记录他隔符新行
N RSTART 被匹配函数匹配的字符串首
N RLENGTH 被匹配函数匹配的字符串长度
N SUBSEP 下标分隔符 "\034"

6.awk的内置函数

V 函数用途或返回值
------------------------------------------------
N gsub(reg,string,target) 每次常规表达式reg匹配时替换
target中的string
N index(search,string) 返回string中search串的位置
A length(string) 求串string中的字符个数
N match(string,reg) 返回常规表达式reg匹配的string中的位
置
N printf(format,variable) 格式化输出，按format提供的格式
输出变量variable。
N split(string,store,delim) 根据分界符delim,分解string为
store的数组元素
N sprintf(format,variable) 返回一个包含基于format的格式
化数据，variables是要放到串中的数据
G strftime(format,timestamp) 返回一个基于format的日期或
者时间串，timestmp是systime()函数返回的时间
N sub(reg,string,target) 第一次当常规表达式reg匹配，替换
target串中的字符串
A substr(string,position,len) 返回一个以position开始len
个字符的子串
P totower(string) 返回string中对应的小写字符
P toupper(string) 返回string中对应的大写字符
A atan(x,y) x的余切(弧度)
N cos(x) x的余弦(弧度)
A exp(x) e的x幂
A int(x) x的整数部分
A log(x) x的自然对数值
N rand() 0-1之间的随机数
N sin(x) x的正弦(弧度)
A sqrt(x) x的平方根
A srand(x) 初始化随机数发生器。如果忽略x，则使用system()
G system() 返回自1970年1月1日以来经过的时间（按秒计算）

参考资料

1、《精通UNIX》（《Understanding UNIX》[美]Stan
Kelly-Bootle 著李永峰等译电子工业出版社)
2、《unix使用指南》（第2版）（Using UNIX（Second Edition
）Steve Moritsugu等原著张拥军、韩柯、原小玲等译电子工业
出版社出版、发行）
3、unix 联机手册:sco OpenSrever 5.05版.
4、感谢无名的网路资源提供者，由于你们辛勤而无私的劳动，
INTERNET才如此精彩！


** [[http://coolshell.cn/articles/9070.html][AWK 简明教程]]


[[http://coolshell.cn//wp-content/uploads/2013/02/awk.jpg]]有一些网友看了前两天的《[[http://coolshell.cn/articles/8883.html][Linux下应该知道的技巧]]》希望我能教教他们用awk和sed，所以，出现了这篇文章。我估计这些80后的年轻朋友可能对awk/sed这类上古神器有点陌生了，所以需要我这个老家伙来炒炒冷饭。*况且，AWK是贝尔实验室1977年搞出来的文本出现神器，今年是蛇年，是AWK的本命年，而且年纪和我相仿，所以非常有必要为他写篇文章*。

之所以叫AWK是因为其取了三位创始人 [[http://en.wikipedia.org/wiki/Alfred_Aho][Alfred
Aho]]，[[http://en.wikipedia.org/wiki/Peter_J._Weinberger][Peter
Weinberger]], 和 [[http://en.wikipedia.org/wiki/Brian_Kernighan][Brian
Kernighan]] 的Family
Name的首字符。要学AWK，就得提一提AWK的一本相当经典的书《[[http://plan9.bell-labs.com/cm/cs/awkbook/][The
AWK Programming
Language]]》，它在[[http://book.douban.com/subject/1876898/][豆瓣上的评分]]是9.4分！在[[http://www.amazon.cn/mn/detailApp/?asin=020107981X][亚马逊上居然卖1022.30元]]。

我在这里的教程并不想面面俱到，本文和我之前的[[http://coolshell.cn/articles/8460.html][Go语言简介]]一样，全是示例，基本无废话。

*我只想达到两个目的：*

*1）你可以在乘坐公交地铁上下班，或是在坐马桶拉大便时读完（保证是一泡大便的工夫）。*

*2）我只想让这篇博文像一个火辣的脱衣舞女挑起你的兴趣，然后还要你自己去下工夫去撸。*

废话少说，我们开始脱吧（注：这里只是topless）。

**** 起步上台

我从netstat命令中提取了如下信息作为用例：

#+BEGIN_EXAMPLE
    $ cat netstat.txt
    Proto Recv-Q Send-Q Local-Address          Foreign-Address             State
    tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
    tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
    tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
    tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT
    tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED
    tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED
    tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT
    tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
    tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1
    tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED
    tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT
    tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK
    tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED
    tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2
    tcp        0      0 :::22                  :::*                        LISTEN
#+END_EXAMPLE

下面是最简单最常用的awk示例，其输出第1列和第4例，

-  其中单引号中的被大括号括着的就是awk的语句，注意，其只能被单引号包含。
-  其中的$1..$n表示第几例。注：$0表示整个行。

#+BEGIN_EXAMPLE
    $ awk '{print $1, $4}' netstat.txt
    Proto Local-Address
    tcp 0.0.0.0:3306
    tcp 0.0.0.0:80
    tcp 127.0.0.1:9000
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp :::22
#+END_EXAMPLE

我们再来看看awk的格式化输出，和C语言的printf没什么两样：

#+BEGIN_EXAMPLE
    $ awk '{printf "%-8s %-8s %-8s %-18s %-22s %-15s\n",$1,$2,$3,$4,$5,$6}' netstat.txt
    Proto    Recv-Q   Send-Q   Local-Address      Foreign-Address        State
    tcp      0        0        0.0.0.0:3306       0.0.0.0:*              LISTEN
    tcp      0        0        0.0.0.0:80         0.0.0.0:*              LISTEN
    tcp      0        0        127.0.0.1:9000     0.0.0.0:*              LISTEN
    tcp      0        0        coolshell.cn:80    124.205.5.146:18245    TIME_WAIT
    tcp      0        0        coolshell.cn:80    61.140.101.185:37538   FIN_WAIT2
    tcp      0        0        coolshell.cn:80    110.194.134.189:1032   ESTABLISHED
    tcp      0        0        coolshell.cn:80    123.169.124.111:49809  ESTABLISHED
    tcp      0        0        coolshell.cn:80    116.234.127.77:11502   FIN_WAIT2
    tcp      0        0        coolshell.cn:80    123.169.124.111:49829  ESTABLISHED
    tcp      0        0        coolshell.cn:80    183.60.215.36:36970    TIME_WAIT
    tcp      0        4166     coolshell.cn:80    61.148.242.38:30901    ESTABLISHED
    tcp      0        1        coolshell.cn:80    124.152.181.209:26825  FIN_WAIT1
    tcp      0        0        coolshell.cn:80    110.194.134.189:4796   ESTABLISHED
    tcp      0        0        coolshell.cn:80    183.60.212.163:51082   TIME_WAIT
    tcp      0        1        coolshell.cn:80    208.115.113.92:50601   LAST_ACK
    tcp      0        0        coolshell.cn:80    123.169.124.111:49840  ESTABLISHED
    tcp      0        0        coolshell.cn:80    117.136.20.85:50025    FIN_WAIT2
    tcp      0        0        :::22              :::*                   LISTEN
#+END_EXAMPLE

**** 脱掉外套

***** 过滤记录

我们再来看看如何过滤记录（下面过滤条件为：第三列的值为0 &&
第6列的值为LISTEN）

#+BEGIN_EXAMPLE
    $ awk '$3==0 && $6=="LISTEN" ' netstat.txt
    tcp        0      0 0.0.0.0:3306               0.0.0.0:*              LISTEN
    tcp        0      0 0.0.0.0:80                 0.0.0.0:*              LISTEN
    tcp        0      0 127.0.0.1:9000             0.0.0.0:*              LISTEN
    tcp        0      0 :::22                      :::*                   LISTEN
#+END_EXAMPLE

其中的“==”为比较运算符。其他比较运算符：!=, >, <, >=, <=

我们来看看各种过滤记录的方式：

#+BEGIN_EXAMPLE
    $ awk ' $3>0 {print $0}' netstat.txt
    Proto Recv-Q Send-Q Local-Address          Foreign-Address             State
    tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
    tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1
    tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK
#+END_EXAMPLE

如果我们需要表头的话，我们可以引入内建变量NR：

#+BEGIN_EXAMPLE
    $ awk '$3==0 && $6=="LISTEN" || NR==1 ' netstat.txt
    Proto Recv-Q Send-Q Local-Address          Foreign-Address             State
    tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
    tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
    tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
    tcp        0      0 :::22                  :::*                        LISTEN
#+END_EXAMPLE

再加上格式化输出：

#+BEGIN_EXAMPLE
    $ awk '$3==0 && $6=="LISTEN" || NR==1 {printf "%-20s %-20s %s\n",$4,$5,$6}' netstat.txt
    Local-Address        Foreign-Address      State
    0.0.0.0:3306         0.0.0.0:*            LISTEN
    0.0.0.0:80           0.0.0.0:*            LISTEN
    127.0.0.1:9000       0.0.0.0:*            LISTEN
    :::22                :::*                 LISTEN
#+END_EXAMPLE

***** *内建变量*

说到了内建变量，我们可以来看看awk的一些内建变量：

| $0                                         | $1~$n                                 | FS                               | NF                                   | NR                                                                              | FNR                                                      | RS                                | OFS                             | ORS                              | FILENAME             |
| 当前记录（这个变量中存放着整个行的内容）   | 当前记录的第n个字段，字段间由FS分隔   | 输入字段分隔符 默认是空格或Tab   | 当前记录中的字段个数，就是有多少列   | 已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。   | 当前记录数，与NR不同的是，这个值会是各个文件自己的行号   | 输入的记录分隔符， 默认为换行符   | 输出字段分隔符， 默认也是空格   | 输出的记录分隔符，默认为换行符   | 当前输入文件的名字   |

怎么使用呢，比如：我们如果要输出行号：

#+BEGIN_EXAMPLE
    $ awk '$3==0 && $6=="ESTABLISHED" || NR==1 {printf "%02s %s %-20s %-20s %s\n",NR, FNR, $4,$5,$6}' netstat.txt
    01 1 Local-Address        Foreign-Address      State
    07 7 coolshell.cn:80      110.194.134.189:1032 ESTABLISHED
    08 8 coolshell.cn:80      123.169.124.111:49809 ESTABLISHED
    10 10 coolshell.cn:80      123.169.124.111:49829 ESTABLISHED
    14 14 coolshell.cn:80      110.194.134.189:4796 ESTABLISHED
    17 17 coolshell.cn:80      123.169.124.111:49840 ESTABLISHED
#+END_EXAMPLE

***** *指定分隔符*

#+BEGIN_EXAMPLE
    $  awk  'BEGIN{FS=":"} {print $1,$3,$6}' /etc/passwd
    root 0 /root
    bin 1 /bin
    daemon 2 /sbin
    adm 3 /var/adm
    lp 4 /var/spool/lpd
    sync 5 /sbin
    shutdown 6 /sbin
    halt 7 /sbin
#+END_EXAMPLE

上面的命令也等价于：（-F的意思就是指定分隔符）

#+BEGIN_EXAMPLE
    $ awk  -F: '{print $1,$3,$6}' /etc/passwd
#+END_EXAMPLE

注：如果你要指定多个分隔符，你可以这样来：

#+BEGIN_EXAMPLE
    awk -F '[;:]'
#+END_EXAMPLE

再来看一个以\t作为分隔符输出的例子（下面使用了/etc/passwd文件，这个文件是以:分隔的）：

#+BEGIN_EXAMPLE
    $ awk  -F: '{print $1,$3,$6}' OFS="\t" /etc/passwd
    root    0       /root
    bin     1       /bin
    daemon  2       /sbin
    adm     3       /var/adm
    lp      4       /var/spool/lpd
    sync    5       /sbin
#+END_EXAMPLE

**** 脱掉衬衫

***** 字符串匹配

我们再来看几个字符串匹配的示例：

#+BEGIN_EXAMPLE
    $ awk '$6 ~ /FIN/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
    1       Local-Address   Foreign-Address State
    6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2
    9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2
    13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1
    18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2

    $ $ awk '$6 ~ /WAIT/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
    1       Local-Address   Foreign-Address State
    5       coolshell.cn:80 124.205.5.146:18245     TIME_WAIT
    6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2
    9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2
    11      coolshell.cn:80 183.60.215.36:36970     TIME_WAIT
    13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1
    15      coolshell.cn:80 183.60.212.163:51082    TIME_WAIT
    18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2
#+END_EXAMPLE

上面的第一个示例匹配FIN状态， 第二个示例匹配WAIT字样的状态。其实 ~
表示模式开始。/ /中是模式。这就是一个正则表达式的匹配。

其实awk可以像grep一样的去匹配第一行，就像这样：

#+BEGIN_EXAMPLE
    $ awk '/LISTEN/' netstat.txt
    tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN
    tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN
    tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN
    tcp        0      0 :::22                   :::*                    LISTEN
#+END_EXAMPLE

我们可以使用 “/FIN|TIME/” 来匹配 FIN 或者 TIME :

#+BEGIN_EXAMPLE
    $ awk '$6 ~ /FIN|TIME/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
    1       Local-Address   Foreign-Address State
    5       coolshell.cn:80 124.205.5.146:18245     TIME_WAIT
    6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2
    9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2
    11      coolshell.cn:80 183.60.215.36:36970     TIME_WAIT
    13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1
    15      coolshell.cn:80 183.60.212.163:51082    TIME_WAIT
    18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2
#+END_EXAMPLE

再来看看模式取反的例子：

#+BEGIN_EXAMPLE
    $ awk '$6 !~ /WAIT/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
    1       Local-Address   Foreign-Address State
    2       0.0.0.0:3306    0.0.0.0:*       LISTEN
    3       0.0.0.0:80      0.0.0.0:*       LISTEN
    4       127.0.0.1:9000  0.0.0.0:*       LISTEN
    7       coolshell.cn:80 110.194.134.189:1032    ESTABLISHED
    8       coolshell.cn:80 123.169.124.111:49809   ESTABLISHED
    10      coolshell.cn:80 123.169.124.111:49829   ESTABLISHED
    12      coolshell.cn:80 61.148.242.38:30901     ESTABLISHED
    14      coolshell.cn:80 110.194.134.189:4796    ESTABLISHED
    16      coolshell.cn:80 208.115.113.92:50601    LAST_ACK
    17      coolshell.cn:80 123.169.124.111:49840   ESTABLISHED
    19      :::22   :::*    LISTEN
#+END_EXAMPLE

或是：

#+BEGIN_EXAMPLE
    awk '!/WAIT/' netstat.txt
#+END_EXAMPLE

*折分文件*

awk拆分文件很简单，使用重定向就好了。下面这个例子，是按第6例分隔文件，相当的简单（其中的NR!=1表示不处理表头）。

#+BEGIN_EXAMPLE
    $ awk 'NR!=1{print > $6}' netstat.txt

    $ ls
    ESTABLISHED  FIN_WAIT1  FIN_WAIT2  LAST_ACK  LISTEN  netstat.txt  TIME_WAIT

    $ cat ESTABLISHED
    tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED
    tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
    tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED

    $ cat FIN_WAIT1
    tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1

    $ cat FIN_WAIT2
    tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2

    $ cat LAST_ACK
    tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK

    $ cat LISTEN
    tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
    tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
    tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
    tcp        0      0 :::22                  :::*                        LISTEN

    $ cat TIME_WAIT
    tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT
    tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT
    tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT
#+END_EXAMPLE

你也可以把指定的列输出到文件：

#+BEGIN_EXAMPLE
    awk 'NR!=1{print $4,$5 > $6}' netstat.txt
#+END_EXAMPLE

再复杂一点：（注意其中的if-else-if语句，可见awk其实是个脚本解释器）

#+BEGIN_EXAMPLE
    $ awk 'NR!=1{if($6 ~ /TIME|ESTABLISHED/) print > "1.txt";
    else if($6 ~ /LISTEN/) print > "2.txt";
    else print > "3.txt" }' netstat.txt

    $ ls ?.txt
    1.txt  2.txt  3.txt

    $ cat 1.txt
    tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT
    tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED
    tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT
    tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
    tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED
    tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT
    tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED

    $ cat 2.txt
    tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
    tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
    tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
    tcp        0      0 :::22                  :::*                        LISTEN

    $ cat 3.txt
    tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2
    tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1
    tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK
    tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2
#+END_EXAMPLE

***** 统计

下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。

#+BEGIN_EXAMPLE
    $ ls -l  *.cpp *.c *.h | awk '{sum+=$5} END {print sum}'
    2511401
#+END_EXAMPLE

我们再来看一个统计各个connection状态的用法：（我们可以看到一些编程的影子了，大家都是程序员我就不解释了。注意其中的数组的用法）

#+BEGIN_EXAMPLE
    $ awk 'NR!=1{a[$6]++;} END {for (i in a) print i ", " a[i];}' netstat.txt
    TIME_WAIT, 3
    FIN_WAIT1, 1
    ESTABLISHED, 6
    FIN_WAIT2, 3
    LAST_ACK, 1
    LISTEN, 4
#+END_EXAMPLE

再来看看统计每个用户的进程的占了多少内存（注：sum的RSS那一列）

#+BEGIN_EXAMPLE
    $ ps aux | awk 'NR!=1{a[$1]+=$6;} END { for(i in a) print i ", " a[i]"KB";}'
    dbus, 540KB
    mysql, 99928KB
    www, 3264924KB
    root, 63644KB
    hchen, 6020KB
#+END_EXAMPLE

**** 脱掉内衣

***** awk脚本

在上面我们可以看到一个END关键字。END的意思是“处理完所有的行的标识”，即然说到了END就有必要介绍一下BEGIN，这两个关键字意味着执行前和执行后的意思，语法如下：

-  BEGIN{ 这里面放的是执行前的语句 }
-  END {这里面放的是处理完所有的行后要执行的语句 }
-  {这里面放的是处理每一行时要执行的语句}

为了说清楚这个事，我们来看看下面的示例：

假设有这么一个文件（学生成绩表）：

#+BEGIN_EXAMPLE
    $ cat score.txt
    Marry   2143 78 84 77
    Jack    2321 66 78 45
    Tom     2122 48 77 71
    Mike    2537 87 97 95
    Bob     2415 40 57 62
#+END_EXAMPLE

我们的awk脚本如下（我没有写有命令行上是因为命令行上不易读，另外也在介绍另一种用法）：

#+BEGIN_EXAMPLE
    $ cat cal.awk
    #!/bin/awk -f
    #运行前
    BEGIN {
        math = 0
        english = 0
        computer = 0

        printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"
        printf "---------------------------------------------\n"
    }
    #运行中
    {
        math+=$3
        english+=$4
        computer+=$5
        printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5
    }
    #运行后
    END {
        printf "---------------------------------------------\n"
        printf "  TOTAL:%10d %8d %8d \n", math, english, computer
        printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR
    }
#+END_EXAMPLE

我们来看一下执行结果：（也可以这样运行 ./cal.awk score.txt）

#+BEGIN_EXAMPLE
    $ awk -f cal.awk score.txt
    NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL
    ---------------------------------------------
    Marry  2143     78       84       77      239
    Jack   2321     66       78       45      189
    Tom    2122     48       77       71      196
    Mike   2537     87       97       95      279
    Bob    2415     40       57       62      159
    ---------------------------------------------
      TOTAL:       319      393      350
    AVERAGE:     63.80    78.60    70.00
#+END_EXAMPLE

***** 环境变量

即然说到了脚本，我们来看看怎么和环境变量交互：（使用-v参数和ENVIRON，使用ENVIRON的环境变量需要export）

#+BEGIN_EXAMPLE
    $ x=5

    $ y=10
    $ export y

    $ echo $x $y
    5 10

    $ awk -v val=$x '{print $1, $2, $3, $4+val, $5+ENVIRON["y"]}' OFS="\t" score.txt
    Marry   2143    78      89      87
    Jack    2321    66      83      55
    Tom     2122    48      82      81
    Mike    2537    87      102     105
    Bob     2415    40      62      72
#+END_EXAMPLE

**** 几个花活

最后，我们再来看几个小例子：

#+BEGIN_EXAMPLE
    #从file文件中找出长度大于80的行
    awk 'length>80' file

    #按连接数查看客户端IP
    netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr

    #打印99乘法表
    seq 9 | sed 'H;g' | awk -v RS='' '{for(i=1;i<=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")}'
#+END_EXAMPLE

**** 自己撸吧

关于其中的一些知识点可以参看[[http://www.gnu.org/software/gawk/manual/gawk.html][gawk的手册]]：

-  内建变量，参看：[[http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din-Variables]]
-  流控方面，参看：[[http://www.gnu.org/software/gawk/manual/gawk.html#Statements]]
-  内建函数，参看：[[http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din]]
-  正则表达式，参看：[[http://www.gnu.org/software/gawk/manual/gawk.html#Regexp]]

** [[http://no001.blog.51cto.com/1142339/389798/][QT_BEGIN_NAMESPACE、QT_END_NAMESPACE 等问题]]

#ifndef WINDOW_H
#define WINDOW_H

#include <QSystemTrayIcon>
#include <QDialog>

QT_BEGIN_NAMESPACE
class QAction;
class QCheckBox;
class QComboBox;
class QGroupBox;
class QLabel;
class QLineEdit;
class QMenu;
class QPushButton;
class QSpinBox;
class QTextEdit;
QT_END_NAMESPACE

//! [0]
class Window : public QDialog
{
Q_OBJECT

public:
Window();
……

｝

问题：
1、QT_BEGIN_NAMESPACE、QT_END_NAMESPACE作用是什么
2、这样引入类有什么好处
3、为什么这两个类要通过include引入
#include <QSystemTrayIcon>
#include <QDialog>

1、It is possible to compile whole Qt inside a user-defined namespace.
See configure options for more details. These macros expand as:

Qt Code:
# define QT_BEGIN_NAMESPACE namespace QT_NAMESPACE {
# define QT_END_NAMESPACE }
参考资料：
http://www.qtcentre.org/threads/15946-What-s-effect-of-QT_BEGIN_NAMESPACE-Thanks

2、3
在头文件中尽量引入较少的其它头文件，可以加快编译速度；

要include QSystemTrayIcon是因为在
void iconActivated(QSystemTrayIcon::ActivationReason reason);
这个函数申明的时候需要QSystemTrayIcon类下的变量，其他的用
class QAction;
class QCheckBox;
...
是因为在头文件里面只有这些类的指针申明，并没有真正实例化，在这个头文件对应的cpp文件里面应该会
#include <QAction>
#include <QCheckBox>
...
在cpp文件里面才会正真实例化这些类。
其 实直接在头文件里面#include <QAction> #include <QCheckBox>也是可以的，像它这样做，好像是可以降低各个文件编译时的关联度，不会在改动了一下部分类的时候，引发其他大量文件的 重新编译，在做小工程的时候没什么区别，但是做大了，编译一次需要好几个小时的时候，这样做的优势就显现出来了

** [[http://blog.sina.com.cn/s/blog_674b5aae0100nqpt.html][atoll()函数使用注意事项及分析]]

atoll是c99标准加入的函数，在编译的时候可能要打开C99标准的编译选项
-std=c99。

另外，必须包含stdlib.h头文件，否则会出错。

☞ C程序代码如下所示：

#include <stdio.h>

#include <stdlib.h> // 声明atoll函数
 int main()
 {
  char tempbuf[]="430007020001";
  long long unit;

 unit=atoll(tempbuf);
    printf("%lld\n", unit);

 return 0;
 }

编译：
 gcc -S -o test.s test.c



☞ 编译器产生的汇编代码是这样的：

Assembly code

 call atoll ;调用atoll。返回值的低32位保存在eax，高32位保存在edx
  addl $16, %esp ; 调整栈指针，与本题无

     movl % eax, -32(%
ebp); 把eax里保存的低32位保存到局部变量unit的低32位

     movl % edx, -28(%
ebp); 把edx里保存的高32位保存到局部变量unit的高32位

☞ 而如果把#include
<stdlib.h>删掉，也就是不声明atoll函数，编译器产生的汇编代码就变成了这样：

Assembly code

 call atoll
  addl $16, %esp

 cltd ; AT&T汇编里的cltd指令相当于cdq指令，作用是把eax的32位整数扩展为64位，高32位用eax的符号位填充保存到edx

       movl % eax, -32(% ebp);

       movl % edx, -28(% ebp);



☞ 从汇编代码可以看出：

有atoll声明的时候，编译器知道atoll的返回值是64位，所以直接把edx:eax里面保存的64位返回值赋值给unit。

而没有atoll声明的时候，编译器认为atoll的返回值是32位，于是多了一条关键的cltd指令。真正调用atoll的时候，atoll也会把返回值保存在edx:eax；但是main里面不知道，通过cltd指令，用eax的扩展把edx里面保存的有用的高32位覆盖掉了。



☞ 不添加和添加输出结果对比：

   不添加头文件时，输出510290401，显然是错误的；

   添加头文件后，输出430007020001，正确。

** [[http://blog.sina.com.cn/s/blog_6f4e385c0101ksu0.html][gcc头文件搜索路径]]


*** [[http://blog.csdn.net/yasi_xi/article/details/8833094][查看gcc/g++默认include路径]]

*`gcc -print-prog-name=cc1plus` -v
*

*`g++ -print-prog-name=cc1plus` -v*

*
*

-
    :: 本文介绍在linux中头文件的搜索路径，也就是说你通过include指定的头文件，linux下的gcc编译器它是怎么找到它的呢。在此之前，先了解一个基本概念。


   头文件是一种文本文件，使用文本编辑器将代码编写好之后，以扩展名.h保存就行了。头文件中一般放一些重复使用的代码，例如函数声明、变量声明、常数定
   义、宏的定义等等。当使用＃include语句将头文件引用时，相当于将头文件中所有内容，复制到＃include处。#include有两种写法形式，
   分别是：

   #include <> ： 直接到系统指定的某些目录中去找某些头文件。

   #include “” ：
   先到源文件所在文件夹去找，然后再到系统指定的某些目录中去找某些头文件。




   #include文件可能会带来一个问题就是重复应用，如a.h引用的一个函数是某种实现，而b.h引用的这个函数却是另外一种实现，这样在编译的时候将会出现错误。所以，为了避免因为重复引用而导致的编译错误，头文件常具有：

   #ifndef  LABEL

   #define  LABEL

     //代码部分

   #endif

   的格式。其中LABEL为一个唯一的标号，命名规则跟变量的命名规则一样。常根据它所在的头文件名来命名，例如，如果头文件的文件名叫做hardware.h，那么可以这样使用：

   #ifndef  __HARDWARE_H__

   #define  __HARDWARE_H__

     //代码部分

   #endif

   这样写的意思就是，如果没有定义__HARDWARE_H__，则定义__HARDWARE_H__，并编译下面的代码部分，直到遇到#endif。这样当重复引用时，由于__HARDWARE_H__已经被定义，则下面的代码部分就不会被编译了，这样就避免了重复定义。




   一句话，头文件事实上只是把一些常用的命令集成在里面，你要用到哪方面的命令就载入哪个头文件就可以了。



     gcc寻找头文件的路径(按照1->2->3的顺序)

     1.
   在gcc编译源文件的时候，通过参数-I指定头文件的搜索路径，如果指定路径有多个路径时，则按照指定路径的顺序搜索头文件。命令形式如：“gcc
   -I /path/where/theheadfile/in
   sourcefile.c“，这里源文件的路径可以是绝对路径，也可以是相对路径。eg：

   设当前路径为/root/test，include_test.c如果要包含头文件“include/include_test.h“，有两种方法：

   1) include_test.c中#include “include/include_test.h”或者#include
   "/root/test/include/include_test.h"，然后gcc include_test.c即可

   2) include_test.c中#include 或者#include ，然后gcc --I include
   include_test.c也可



     2.
   通过查找gcc的环境变量C_INCLUDE_PATH/CPLUS_INCLUDE_PATH/OBJC_INCLUDE_PATH来搜索头文件位置。



     3. 再找内定目录搜索，分别是

   /usr/include

   /usr/local/include

   /usr/lib/gcc-lib/i386-linux/2.95.2/include

   最后一行是gcc程序的库文件地址，各个用户的系统上可能不一样。

     gcc在默认情况下，都会指定到/usr/include文件夹寻找头文件。


   gcc还有一个参数：-nostdinc，它使编译器不再系统缺省的头文件目录里面找头文件，一般和-I联合使用，明确限定头文件的位置。在编译驱动模块
   时，由于非凡的需求必须强制GCC不搜索系统默认路径，也就是不搜索/usr/include要用参数-nostdinc，还要自己用-I参数来指定内核
   头文件路径，这个时候必须在Makefile中指定。


      4.
   当#include使用相对路径的时候，gcc最终会根据上面这些路径，来最终构建出头文件的位置。如#include
   就是包含文件/usr/include/sys/types.h

** [[http://blog.csdn.net/mfc11/article/details/6591134][关于qt中的tr（）函数]]



在论坛中漂，经常遇到有人遇到tr相关的问题。用tr的有两类人：

-  (1)因为发现中文老出问题，然后搜索，发现很多人用tr，于是他也开始用tr
-  (2)另一类人，确实是出于国际化的需要，将需要在界面上显示的文件都用tr包起来，这有分两种：

   -  (2a)
      用tr包住英文(最最推荐的用法，源码英文，然后提供英文到其他语言的翻译包)
   -  (2b) 用tr包住中文(源码用中文，然后提供中文到其他语言的翻译包)

*注意哦，如果你正在用tr包裹中文字符，却不属于(2b)，那么，这是个信号：*

-  你在误用tr
-  你需要的是QString，而不是tr

*如果你确实属于(2b)，请做好心理准备，你可能还会遇到很多困难,请考虑*[[http://blog.csdn.net/dbzhang800/archive/2011/04/19/6334852.aspx][Qt国际化（源码含中文时）的点滴分析]]*
*

*tr 是做什么的？下面二者的区别是什么？*

#+BEGIN_EXAMPLE
    QString text1 = QObject::tr("hello");
     QString text2 = QString("hello");
#+END_EXAMPLE

tr是用来实现国际化，如果你为这个程序提供了中文翻译包(其中hello被翻译成中文"你好")，那么text1的内容将是中文"你好"；如果你为程序提供且使用日文翻译包，那么text1的内容将是日文。

tr是经过多级函数调用才实现了翻译操作，是有代价的，所以不该用的时候最好不要用。

*** 关注的对象

本文关注的是tr或translate中包含中文字符串的情况：

-  =QObject::tr()=

-  =QCoreApplication::translate()=

-  =QTextCodec::setCodecForTr=

这个问题本多少可说的。因为涉及到的编码问题和[[http://hi.baidu.com/cyclone/blog/item/9d7293130e5a498d6538dbf1.html][QString
与中文问题]]中是完全一样的，只不过一个是用的setCodecForCStrings一个用的是setCodecForTr。

**** 简单回顾QString的中文问题

-  QString 采用的unicode，在中文支持上不存在任何问题
-  ="我是中文"= 这是传统的 =const char *= 的窄字符串

-  当将窄字符串赋值到QString时，我们需要告诉它我们的窄串采用的何种编码(gbk?、utf-8?)
-  究竟何种编码主要取决于我们的源代码文件的编码(windows上一般是gbk，其他平台一般utf-8)

例子：

#+BEGIN_EXAMPLE
    QString s1 = "我是中文";
    QString s2("我是中文");
    QString s3;
    s3 = "我是中文"
#+END_EXAMPLE

-  s1、s2 用的是QString的构造函数=QString ( const char * str )=

-  s3
   用的是QString的赋值操作符 =QString & operator= ( const char * str)=

如果不指定编码，s1,s2,s3将全部都是(国内大多数人所称的)乱码。因为QString将这些=const char *=按照latin1来解释的，而不是用户期待的gbk或utf8。

#+BEGIN_EXAMPLE
    QTextCodec::setCodecForCStrings(QTextCodec::codecForName("GB2312"));
    QTextCodec::setCodecForCStrings(QTextCodec::codecForName("UTF-8"))
#+END_EXAMPLE

这两条语句中的一条可以解决问题，至于如何选择，此处不再重复。

*** QObject::tr

说实话，在tr中使用中文不是个好主意。不过既然总有人用（无论是(1)还是(2b)），而且总有人遇到问题，所以还是简单整理一下吧。

相比=QCoreApplication::translate=，大家用tr应该用的很多了，尽管不少人不清楚tr究竟是做什么的=^_^=





#+BEGIN_EXAMPLE
    tr("我是中文");
#+END_EXAMPLE

这调用的是下面这个函数(至少我们可这么认为是)。

#+BEGIN_EXAMPLE
    QString QObject::tr ( const char * sourceText, const char * disambiguation = 0, int n = -1 )
#+END_EXAMPLE

与QString("我是中文")完全一样，你必须告诉tr这个窄字符串是何种编码？你不告诉它，它就用latin1。于是所谓的乱码问题就出来了。

如何告诉tr你写的这几个汉字在磁盘中保存的是何种编码呢？这正是

#+BEGIN_EXAMPLE
    QTextCodec::setCodecForTr(QTextCodec::codecForName("GB2312"));
    QTextCodec::setCodecForTr(QTextCodec::codecForName("UTF-8"));
#+END_EXAMPLE

所做的。这两个选择的原则，由于和前文完全一样，此处也不再重复。

如果你的编码采用的utf8，可以直接使用trUtf8而不必设置setCodecForTr。

如果你只关心乱码问题，到此为止就可以了(下面不再关注编码)。如果想对tr进一步了解，不妨。。继续。。



*** QCoreApplication::translate

我们知道tr是用于实现程序的国际化(或者说多语言翻译)，看Qt相关资料的话，我们知道实现该功能的还有下面这个函数：

#+BEGIN_EXAMPLE
    QString QCoreApplication::translate ( const char * context, const char * sourceText, const char * disambiguation, Encoding encoding, int n )
#+END_EXAMPLE

其实，这个才是真正进行翻译操作的函数，前面我们提到的tr最终是通过调用该函数来实现翻译功能的(稍后我们会看tr是如何调用translate的)。

对tr和这个函数，manual中都有比较详尽的解释。我们这儿简单看一下它的这几个参数：

-  context 上下文，一般就是需要翻译的字符串所在的类的名字
-  sourceText 需要翻译的字符串。(我们关注的编码其实就是它的编码)
-  disambiguation
   消除歧义用的。(比如我们的类内出现两处"close"，一处含义是关闭，另一处含义是亲密的。显然需要让翻译人员知道这点区别)
-  encoding 指定编码。它有两个值

   -  CodecForTr 使用setCodecForTr()设置的编码来解释 sourceText

   -  UnicodeUTF8 使用utf8编码来解释 sourceText
   -  其实这两个分别对应tr和trUtf8

-  n 处理单复数(对中文来说，不存在这个问题)

*** tr与translate

这两个函数的说明，一个在QObject的manual，另一个在QCoreApplication的manual中。

介绍一下tr与translate的关系。前面提到了，tr调用的是translate。如果仅仅这样一说，没有证据，还真难以让大家相信。好吧，继续

**** tr 在何处定义

你可能说：这不废话吗，manual中写得明白的，它是QObject的静态成员函数。而且还有源码为证：

#+BEGIN_EXAMPLE
    //来自 src/corelib/kernel/qobject.h
    #ifdef qdoc
    static QString tr(const char *sourceText, const char *comment = 0, int n = -1);
    static QString trUtf8(const char *sourceText, const char *comment = 0, int n = -1);
    #endif
#+END_EXAMPLE

嘿嘿，差点就被骗了，发现没：它们被预处理语句包住了。

这说明了什么呢？说明了这段代码*仅仅是*用来生成Qt那漂亮的文档的(qdoc3从代码中抽取信息，生成一系列的html格式的manual)。

啊，也就是说，这是假的。那么真正的定义呢？？在一个大家都很熟悉的地方,猜猜看？

这就是

#+BEGIN_EXAMPLE
    Q_OBJECT
#+END_EXAMPLE

该宏的定义在src/corelib/kernel/qobjectdefs.h中

#+BEGIN_EXAMPLE
    #define Q_OBJECT \
     public: \
     Q_OBJECT_CHECK \
     static const QMetaObject staticMetaObject; \
     Q_OBJECT_GETSTATICMETAOBJECT \
     virtual const QMetaObject *metaObject() const; \
     virtual void *qt_metacast(const char *); \
     QT_TR_FUNCTIONS \
     virtual int qt_metacall(QMetaObject::Call, int, void **); \
     private:
#+END_EXAMPLE



其中的宏QT_TR_FUNCTIONS

#+BEGIN_EXAMPLE
    #  define QT_TR_FUNCTIONS \
     static inline QString tr(const char *s, const char *c = 0) \
     { return staticMetaObject.tr(s, c); } \
     static inline QString trUtf8(const char *s, const char *c = 0) \
     { return staticMetaObject.trUtf8(s, c); } \
     static inline QString tr(const char *s, const char *c, int n) \
     { return staticMetaObject.tr(s, c, n); } \
     static inline QString trUtf8(const char *s, const char *c, int n) \
     { return staticMetaObject.trUtf8(s, c, n); }
#+END_EXAMPLE

现在看到：tr调用的是 staticMetaObject对象的tr函数，staticMetaObject
的定义在moc生成的 xxx.moc 或 moc_xxx.cpp 文件内(你随时可以验证的)。

staticMetaObject 是一个 QMetaObject 类的实例，我们继续看一下该类的源码：

#+BEGIN_EXAMPLE
    /*!
     \internal
    */
     QString QMetaObject::tr(const char *s, const char *c) const
     {
     return QCoreApplication::translate(d.stringdata, s, c, QCoreApplication::CodecForTr);
     }
     /*!
     \internal
    */
    QString QMetaObject::trUtf8(const char *s, const char *c) const
    {
    return QCoreApplication::translate(d.stringdata, s, c, QCoreApplication::UnicodeUTF8);
#+END_EXAMPLE

}

** [[http://blog.sina.com.cn/s/blog_ad91f9bc01018as9.html][QT的安装及环境配置]]



QT的安装及环境配置

一、windows的下QT的安装及环境配置

（一）从框架安装程序中安装

步骤：

准备：下载QT库，下载指定版本的MINGW，QT IDE

1、下载QT安装文件如：qt-win-opensoure-4.6.4-mingw.exe

2、下载MINGW：mingw 或者 dev-cpp

3、下载QTIDE：QTCreator

3、执行安装MINGW(至少安gcc complier、g++ complier、MinGw Make)

4、执行安装QTIDE:QtCreator

5、安装QT库：qt-win-opensoure-4.5.2-mingw.exe

6、编译QT debug库。QT库安装后有一个QT Build Debug libraries快捷方式。

7、手动配置环境变量(一般在WINDOWS下可略过此步,但最好配置一下)

8、安装完QT库以后，一般会有一个QT command prompt 的快捷方式，它可以

打开一个控制台，并且能够自动设置（使用MinGw编译器编译QT程序所需要的)

环境变量，在这个窗口中，就可以运行qmake以及make命令来编译QT应用程序。

9、QTIDE(QtCreator的配置)，

主要设置：

1) QT版本设置：tools>options>build&run>Qt version

在这里添加QT库的（安装目录下的）qmake

如：C:\Qt\4.6.4\bin\qmake.exe

[[http://photo.blog.sina.com.cn/showpic.html#blogid=ad91f9bc01018as9&url=http://s10.sinaimg.cn/orignal/ad91f9bcxd10bcda20f79][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]



2) 编译器及调试器设置：tools>options>build&run>Tool Chains

首先添加MINGW

在Complier path添加g++目录(mingw安装目录中的)

如：C:\MINGW\bin\g++.exe

[[http://photo.blog.sina.com.cn/showpic.html#blogid=ad91f9bc01018as9&url=http://s8.sinaimg.cn/orignal/ad91f9bcxd10bcef38907][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]



（二）使用SDK安装

安装完成，设置环境变量及QTIDE设置

（三）使用源代码安装

1、安装MINGW

2、安装QTIDE：QtCreator

3、下载并解压缩QT源代码到指定目录，如：C:\QT\QTSRC

4、编译源代码：如果编译不成功，则设置MINGW环境变量，及加入到PATH中

进入命令窗口

进入解压目录：

//运行configure进行配置生成makefile 这里同时编译debug版本(调试程序用)和

release版（运行程序使用）

C:\QT\QTSRC>configure -debug-and-release

//运行MINGW的make工具(mingw32-make) 进行编译

C:\QT\QTSRC>mingw32-make

编译成功后，便可使用，无需安装。

5、环境变量的设置。

6、Qt Creator的配置





二、X11平台下安装

（一）SDK安装

安装完以后需要配置环境变量。



（二）编译源代码安装

1、下载所需要的版本QT库源代码。

2、解压缩源代码到指定目录

3、切换工作目录到源代码解压缩目录。

4、生成平台相关qmake>makefile

运行./configure（使用绝对路径，或者相对路径），可加参数

(最好先使用make clean将以前有可能已经编译的清除掉)

./configure -prefix=安装目录 //编译完成后，使用make install时，安装到哪个

目录

5、执行make 编译

make [all] //编译debug 与release版，默认只编译release

6、安装QT

make install 默认安装到/usr/local下(如果configure -prefix指定，则安装到指定

目录)

7、设置环境变量

8、验证安装

qmake -v

9、删除本次安装时使用的编译过的文件及配置文件等

make clean

10、可提前安装QTIDE，都完成安装后设置QTIDE的选项(编译器及调试器的

路径设置g++ gdb)

三、环境变量的配置

² WINDOWS平台

1、可以使用我的电脑属性右键设置。永久有效

QTDIR=QT安装目录

MINGW=MINGW安装目录

PATH附加上%QTDIR%\bin;%MINGW%\bin;

QMAKESPEC=win32-g++

2、也可以使用进入DOS窗口，使用CMD命令设置，但只对本窗口有效

设置：进入CMD

C:>set QTDIR=QT安装目录

set MINGW=MINGW安装目录

set PATH=%QTDIR%\BIN;%MINGW%\bin;%PATH%

set QMAKESPEC=win32-g++





² X11平台

1、如果使用的Shell是bash、ksh、zsh、sh

将下列内容写入到~/.bash_profile(或者~/.profile)加入以下内容

#QT Settings

export QTDIR=QT安装目录

export PATH=$QTDIR/bin:$PATH

export LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH

export MANPATH=$QTDIR/doc/man:$MANPATH

#End QT Settings

#为批注。

2、如果使用的Shell是CSH 或者TCSH

将下列代码加入到/etc/csh.login

#QT Settings

setenv PATH QT安装目录/bin:$PATH

#End QT Settings



注1：所有目录，最好不带有空格和中文。gcc是GNU c编译器， g++是GNU c++编译器

注2：默认只编译release(用于运行QT程序)，不编译debug(用于调试QT程序)

解决：

在WINDOWS，

使用QT框架安装完以后，有一个QT Build Debug Libraries快捷方式(进行编译)

指向QT安装目录\bin\qtvars.bat文件

使用QT源代码编译时，指定configure -debug-and-release

在X11下，make时，加上选项 make all



附件：QT安装目录\bin\qtvars.bat文件 DOS下编译Debug Libraries

@echo off

rem

rem This file is generated

rem



echo Setting up a MinGW/Qt only environment...

echo -- QTDIR set to C:\Qt\4.6.4

echo -- PATH set to C:\Qt\4.6.4\bin

echo -- Adding C:\MinGW\\bin to PATH

echo -- Adding %SystemRoot%\System32 to PATH

echo -- QMAKESPEC set to win32-g++



set QTDIR=C:\Qt\4.6.4

set PATH=C:\Qt\4.6.4\bin

set PATH=%PATH%;C:\MinGW\\bin

set PATH=%PATH%;%SystemRoot%\System32

set QMAKESPEC=win32-g++



if not "%1"=="compile_debug" goto END

cd %QTDIR%

echo This will configure and compile qt in debug.

echo The release libraries will not be recompiled.

pause

configure -plugin-sql-sqlite -plugin-sql-odbc -qt-libpng -qt-libjpeg

cd %QTDIR%\src

qmake

mingw32-make debug

:END

** [[http://blog.csdn.net/lincyang/article/details/5779464][关于qt :: error: collect2: ld returned 1 exit status的错误]]

刚才遇到的这个问题，在网上搜索了一下，

有说之前的程序已经运行了，有说pro文件有问题的，

我找了一会，发现我在头文件中定义了两个slots，

在cPP文件中没有实现。

见nokia论坛

Another reason might be that your source is incomplete and calls method DECLARATIONS that get called but the method IMPLEMENTATIONS are missing.

Declaration is the stuff that you usually put in a header file (method signature without body)
Implementation is the signature with body.

Usually if you look in the linker output, you can find which implementation the linker is missing.

click the "Compile Output" view (Alt+4) to see more detailed info.

这样，我找到了这个低级错误~~~

** [[http://blog.csdn.net/wh_19910525/article/details/8128916][如何在windows下使用git及github仓库管理项目]]


*第一，下载并安装git*


目前windows版本的git有几种实现，但我们选择msysgit发行版，这是目前做得*兼容性最好的*。

下载地址：[[http://code.google.com/p/msysgit/downloads/list]]

使用默认配置安装Git。这个不用多说，一路Next就可以，如果对各种选项不熟悉，建议使用默认配置，没问题的。



*第二，创建github账号*

***** 什么是Git和GitHub

*Git* ---The stupid content tracker,
傻瓜内容跟踪器，是一个由Linux内核开发者Linus为了更好地管理Linux内核开发而创立的*分布式版本控制软件*。

*GitHub* ---
学生做版本控制最讨厌的就是找服务器，配置太麻烦了。*GitHub这个网站为每个用户提供服务器托管其Git代码库，免费空间为300M*。注册GitHub后你就会有0.3G的免费空间，不过*只能创建公开项目*。

***** 为什么不选CVS或SVN

-  Git提交/克隆/pull/push的速度更快
-  Git的*绝大多数操作都可以在本地完成，不需要频繁连接服务器*。

--------------

***** 注册GitHub账号

-  *GitHub网址在[[https://github.com/][这里]]*
-  点击上方导航条的[[https://github.com/plans][Signup and
   Pricing]]即可进入注册界面， 选择注册免费账户

[[http://oncoding.in/wp-content/uploads/2011/10/9cccbccb8c60.jpg][[[http://www.kuqin.com/upimg/allimg/111113/2304132200-1.jpg]]]]



-  *GitHub选择的默认通信方式是SSH*，所以要先在Git里面生成SHH
   Key，打开Git Bash在其中输入如下命令：

*ssh-keygen -t rsa -C "3sdfsf80@xinlang.com"*

之后会让你选择是否对存放SSH
Key的文件夹进行加密，一般都不需要的。*一路回车，就OK了。*

-  在c盘，*当前用户*文件夹下，有个.ssh 文件夹，在里边 找到
   id_rsa.pub文件，用记事本打开，复制其中的全部内容。
-  登陆你的GitHub账户，依次点击/Account Settings/ > /SSH Public Keys/ >
   /Add another public key/，把id_rsa.pub中的内容拷贝进去 。
-  至此，基本的设置已经完成了。

成了。

--------------

***** 测试你的Git

-  经过上述配置，*你的Gti应该可以通过SSH连接GitHub服务器了，让我们来测试下*，输入如下命令：

[[http://oncoding.in/wp-content/uploads/2011/10/1.jpg][[[http://www.kuqin.com/upimg/allimg/111113/23041312D-3.jpg]]]]

-  会给你这样的提示：

[[http://oncoding.in/wp-content/uploads/2011/10/2.jpg][[[http://www.kuqin.com/upimg/allimg/111113/230413I29-4.jpg]]]]

-  输入yes，会显示：

[[http://oncoding.in/wp-content/uploads/2011/10/3.jpg][[[http://www.kuqin.com/upimg/allimg/111113/2304135U1-5.jpg]]]]

-  到这里，说明你的SSH运转良好。

如果提示你的密钥不正确，那么你需要重新确认上一步的操作是否完整无误。



*第三，建立本地git仓库*



首先，git要求使用者必须提供自己的身份标识，为此我们需要在git
bash中执行以下命令：

 *git config --global user.name  'aa.Tessst'
 git config --global user.email  fsc@sina.com*

 其次，选择git仓库目录

 我们*假设将git仓库目录放在D盘的OPENSource目录下*，可以通过在git
bash中执行以下命令完成：

 cd /d
 mkdir OPENSource

 注：git bash支持大多linux bash终端命令，你可以自己尝试更多终端操作。



最后，建立项目并初始化git仓库


我们的第一个项目是一个使用Python语言将XML文件转换成Python字典，通过执行以下命令完成此步骤：

 mkdir Python-XML2Dict
 cd Python-XML2Dict
 *git init


执行此操作后，git将在Python-XML2Dict目录下创建一个隐藏目录（.git），这个目录就是git用来管理软件版本的仓库。*


*第四，使用git管理项目*

  此步 和 在linux 上 使用 git 的 方法一样，具体参考 我的 其他 博文！



*第五，将项目提交到github管理，[[http://blog.csdn.net/wh_19910525/article/details/7438183][gitpush]]*

如果 *第二步 测试无错*，那么 经过 以下两步
就可以将本地的文件提交到github仓库了。

1、登录GitHub后，你可以在右上边靠中那里找到一个按钮“creat a New
Repository”，点击过后，*填入项目名称*、说明等
过后就可以创建了，然后会出现一个提示页面，记下类似*
git@github.com:XXX/XXX.git* 的地址，这个就是你这个项目的地址了。



2、

#+BEGIN_EXAMPLE
    1 git remote add origin git@github.com:XXX/XXX.git
    2 git push -u origin master //把本地 master 分支 推送到 服务器的master分支上，如果服务器没有此分支，就 新建 此分支。这也是 在服务器上新建分支的一种方法
#+END_EXAMPLE



这个=git@github.com:XXX/XXX.git=就是上面创建项目是生成的地址。现在打开你的项目网址，你就可以发现你的代码已经展示出来了。



*第六，直接 用 git pull 将项目 从 github 上 同步 下来
*

有两种方法：

*1、当git clone之后，直接git pull它会自动匹配一个正确的remote url*

是因为在config文件中配置了以下内容：

#+BEGIN_EXAMPLE
    1 [branch "master"]
    2     remote = origin
    3     merge = refs/heads/master
#+END_EXAMPLE

表明：

1.git处于master这个branch下时，默认的remote就是origin；

2.当在master这个brach下，使用指定remote和merge的git
pull时，使用默认的remote和merge。



*2、但是对于自己建的项目*，*并没有这块内容，需要自己配置*。

#+BEGIN_EXAMPLE
    1 git remote add -f origin login@git.sv.gnu.org:/srv/git/project.git  //若是 执行过 第五步，那么 这一句 就 不用了
    2 git config branch.master.remote origin  //这一步 设置： 把 master 分支上 的 默认服务器地址 设为 origin指向的地址
    3 git config branch.master.merge refs/heads/master   //这一步 设置：如果当前分支是 master 分支，那么 git pull之后，直接 把 “从 origin 下载 下来的 code合并到 master分支上“

    或者加上--global选项，对于全部项目都使用该配置。
#+END_EXAMPLE



建议：用第二种 方法，因为 如果 是 git clone的 项目，当 执行 git push
时，因为 *在 git  config里 url  是 只读方式*

[remote "origin"]
    fetch = +refs/heads/*:refs/remotes/origin/*
   * url = git://github.com/xxx/xxx.git*
 //*git@github.com:XXX/XXX.git 这才是 读写方式*


---------------------------------



如果提交了敏感信息，比如代码中设置的自己的密码什么的忘删除就上传上去了怎么办？

有两个方法：

1、重新修改本地代码，然后提交到服务器（覆盖），

2、直接登录 github
删除之前的项目。删除项目需要在GitHub网站上右上方找到*admin*按钮，进去后右边最下面有个删除的按钮，这样就可以删除了。



--------------------------



若是一个项目就托管在 GitHub 上。你可以把它的 URL
分享给每位对此项目感兴趣的人。本例的 URL 是
=http://github.com/testinguser/iphone_project=。而在项目页面的摘要部分，你会发现有两个
Git URL 地址，见 右图：

[[http://git-scm.com/figures/18333fig0408-tn.png]]


   右图的 摘要中的公共 URL 和私有 URL

Public Clone URL 是一个公开的，只读的 Git
URL，任何人都可以通过它克隆该项目。可以随意散播这个
URL，比如发布到个人网站之类的地方等等。

Your Clone URL 是一个基于 SSH 协议的可读可写 URL，只有使用与上传的 SSH
公钥对应的密钥来连接时，才能通过它进行读写操作。其他用户访问该项目页面时只能看到之前那个公共的
URL，看不到这个私有的 URL。

** [[http://jandan.net/2013/12/20/robots-drc.html][DARPA 机器人挑战赛里的机器人
]]

DARPPA机器人挑战赛(DRC)是是机器人领域的一项重大赛事，由DARPA(国防高等研究计划署)举办。今年的DRC大赛预计会相当混乱。DRC每两年举办一次，由美国国防部赞助，比赛希望能甄选出可在福岛核电站这种人类密集，人类无法接近的危害发生地担负现场急救任务的机器人。就现在看来，比赛还遥遥无期，全球各个机器人团队正在研发和测试他们的机器人，还停留在模拟软件阶段。DRC的初赛是VRC，虚拟机器人挑战赛，今年夏天已经结束，并没有多少人知道这个赛事。只有通过VRC赛事的团队才有获得使用一台Atlas机器人的资格(由波士顿动力公司研发，DARPA提供研发经费)。DRC比赛将于12月20日举行到21日，机器人物理能力测试将在佛罗里达州的霍姆斯特德－迈阿密赛道进行。

再强调一次，这种比赛是场灾难。超过12台机器人将自主寻路跨越障碍，完成跨越崎岖路段的挑战，以及驾驶北极星越野车这种疯狂任务，让机器人进行这种比赛会成功么？答案是：一定会失败。机器人的下场可以预见：电机失效、制动失灵、即使有电脑控制机器人也会脱离目标或退出比赛。

有了这些可能性，DRC大赛更加激动人心。会有机器人完成所有的八项挑战么？比赛会因失控草草结束么？DARPA不担心比赛失控，仅仅一年后就会进行决赛——表现最佳的团队会进入2014年12月的决赛，全面升级的机器人们将挑战更变态的任务，赢取200万美元大奖。

在测试结果的搞笑视频还没有出来之前，我们先看看这些参加DRC大赛的机器人。



DARPA 机器人挑战赛里的机器人
THOR 和 THOR-OP


弗吉尼亞理工学院暨州立大学派出的还是两台机器人。一台叫做THOR(图中左边那台，全称Tactical Hazardous Operations Robot战略危害作业机器人)是首发选手，相比大多数人形机器，THOR更接近人类肌肉活动和稳定性，用于进行高风险的危险作业，此类作业的报酬也相当可观。THOR具有复杂的弹性制动联轴装置，可以像人类一样抬腿走路，行进中出现错误也可以通过对应动作来恢复步姿。THOR-OR(Open Platform开阔地带作业机器人)作为候补选手，比THOR机器人更小，步姿也更像本田开发的机器人Asimo，是民用CHARLI-2人形机器的更新版。DARPA此前提到要进行爬梯等特技动作实验，在THOR-OP身上并没有看出对应的设计。

但是就在刚刚过去的11月，机器人和机器实验室(RoMeLa)的负责人Dennis Hong认为THOR还没有完成对抗测试。THOR-OP的研制略显匆忙只能作为后备方案，Hong希望能打进八强，为的是可以获得政府的项目资助。机器人大赛的规则十分复杂，但是THOR-OP并不是Hong团队的唯一希望。不论是不是DARPA赞助的比赛，只要有比赛，明年Hong的实验室还要参加。Hong将在2014年机器人大赛决赛上放出THOR放手一搏，这周的机器人比赛里他们会派出大个头机器人，让大家过瘾。“THOR和THOR-OP我们都会带去参加迈阿密的比赛，”Hong说，“赛场上THOR会告诉人们：‘我叫THOR，明年我还会来的！’”



DARPA 机器人挑战赛里的机器人
THOR


尽管今年DRC上THOR出师不利，但是THOR会像克里斯汀U+2022贝尔一样重新崛起，2014年2月THOR将入选美国海军作为消防机器人服役。早在DARPA宣布进行机器人挑战赛之前，美国海军和Hong的RoMeLa实验室就签订了合作跳跃，美国海军要求RoMeLa研发出舰载消防机器人，今年11月装备于已经退役的U.S.S Shadwell试验舰进行实舰演习，不过由于种种原因被延后至2014年2月进行。



DARPA 机器人挑战赛里的机器人
THOR-OP


本该作为候补选手无缘竞赛的THOR-OP有望完成DRC比赛的大多数挑战，例如开门、和拧阀门，其他的任务会也许会交给其他机器人。“我们也许不会参加驾驶越野车的挑战。”Hong说。就算THOR-OP比THOR要矮1英尺(约1.49米高)，但是由于无法灵活更换部件，所以不适合进行驾驶测试。



DARPA 机器人挑战赛里的机器人
CHIMP


卡内基梅隆大学(CMU)有数次赢得DARPA机器人挑战赛的经历，该大学的自寻路机器人Chevy Tahoe驾驶汽车赢得了2007机器人城市挑战。这次他们的Tartan Rescue团队计划用一台和猩猩长的差不多的机器人(重400磅)，在机器人的手臂和腿上装备有坦克履带，这台机器人将成功迈过终点线。CHIMP(卡内基梅隆大学高级智能移动平台)站起来进入多任务模式时，算上“小腿”部分，有1.57米高。不过滚动行进模式依靠履带控制方向、调整位置，需要跨越较长障碍物和清除障碍时会转换成四足模式。CMU国家机器人工程中心总指挥Tony Stenz说：“CHIMP不会像所有两足机器人一样费力用两足站立保持平衡，我们有四条腿，用不着保持平衡，机器人只需要改变形态，四条腿的结构会让它稳稳的。”



DARPA 机器人挑战赛里的机器人
CHIMP


顾名思义，CHIMP(猩猩)配备了两条强壮到不成比例的前肢(和其他机器人相比)，完全伸展情况下翼展达到2.54米，CHIMP并不需要将实时视频传送给开发者——这样对带宽和信号强度需求会超过DARPA的许可，Tony Stenz说：“CHIMP机器人会生成周边环境的彩色3D模型”，使用者可以远控制摄像头焦距，还可以旋转摄像头获得更好的视野，这样可以更好的发布和修改指令。



DARPA 机器人挑战赛里的机器人
Valkyrie


NASA派出了两个机器人进入DRC，一个是约翰逊航天中心的Valkyrie机器人，还有一个是喷气推动实验室的RoboSmian机器人，前者在上周电子工程杂志IEEE Spectrum发布的深度披露视频中大出风头。Valkyrie机器人高1.88米，外层纤维完全包裹了整个躯体，和其他光秃秃的机器人形成了鲜明反差。阵列摄像头是Valkyrie最大的亮点，装载于头部、躯干、脚上、膝盖和手臂。约翰逊航天中心此前在国际空间站测试过机器人宇航员和机器人宇航员2号，这次他们也将把Valkyrie送上去，这对提升Valkyrie的操作能力有非常大的优势。但是也有团队领队质疑Valkyrie看上去连“最基本”的移动能力都没有。

RoboSimian

和它的竞争对手也是NASA制造的兄弟机器人大为不同，可以说，RoboSiiman是本届DRC上最不像人的人形机器人，身上多处裸露，制造它的喷气推动实验室(JPL)形容它长得像猩猩，然而这种猩猩是不存在的。四肢节点众多，灵活度很高，这点类似灵长类。关节均匀分布，可以重合折叠在一起，操作部分的运动角度也绝不像猩猩。RoboSimian运用了双侧半球兑成的设计，也即没有头部或脸部——遍布全身上下的摄像头可以让RoboSimian迅速改变运动方向，无需旋转镜头方向。可不转身进行逆向运动，可以迅速回到原位。这或许也让这台230磅机器人在2014年决赛上多少有些把握。RoboSmian的开发者针对此次DRC比赛专门设计了同方向配备6镜头。即便如此，JPL的机器人还是和其他机器人的视角大为不同。“我们没有用激光雷达”JPL机器人车辆和操控小组的总监Brett Kennedy说，“机器人主要依赖摄像头，自带电源和电池包的大部分电量都是供给摄像头。”火星探测车就没有用上激光雷达技术，这是出于距离遥远能源是最宝贵的，RoboSimian总有一天也会以某种形式登上火星的。

DRC-Hubo

Hubo机器人开发出来已经有些年头了，身材比例像小孩，两足小心行走的姿势让人想起了本田开发的Asimo机器人。“它的个头和力气都和一个10岁小男孩相若，”Drexel实验室的Paul Oh说，“你不会让一个10岁小孩去灾难现场的，你要的是20多个消防员汉子。”DRC-Hubo就可以满足这种需求——比之前的型号高30厘米左右，重20%。但即使这样(只有130磅)，壮汉还是可以背起它，机器人就能更接近事发地点，然后利用自供电独自到达危险地点。Oh先生说，栓机器人的背带是为猎鹿和其他狩猎活动准备的。在疯狂的DRC大赛中，装卸操作对重型机器人是致命的，即便在机器人众多的DRC场面里，Hubo也属于非常超现实的风格，同时也非常聪明，相信在不久的将来如果能解决电池供电问题，Hubo就能投放市场。Hubo团队在参赛前就拥有七台Hubo机器人，Drexel实验室和佐治亚理工大学在训练这批机器人军团的同时，可以开发更强力的机器人。Drexel实验室会带两台相同的Hubo参加迈阿密物理特性测试，所有比赛环节会由两台机器人分工完成。但是如果某一台机器人当机了，Oh希望另一台可以加载响应的控制程序并完成比赛。

DRC-Hubo

为了应对比赛的操控环节，DRC-Hubo对手臂部分进行了修改，机器人的灵活度比之前有所提高。“是不是看上去有点吓人？”Drexel团队的Paul Oh说，“以前Hubo有个挺欢乐的帽子，我们把它取掉了。” Hubo的脑袋瘦瘦长长像个竹竿，在越野车驾驶环节有较大的视野优势。

HRP-2-Based Robot
毋庸置疑DRC中最神秘的机器人，模型机由日本Schaft公司负责制造，目前还没有名字。装备水冷电机、急速放电电池短时间放出的强大电流可以提供超强动力。Schaft的职员前东京大学机器人开发部研究员公布了一段机器人推行其他机器人的视频。

和机器人的表现无关，Google去年收购了这家机器人公司。世界最大的公司加入到了机器人比赛中。

Atlas
前面提到的机器人全部由Track A比赛团队制造，每个团队负责研发各自的控制软件和硬件(DARPA全程提供总共400万美元的资助。)Track B比赛的参赛者只是负责软件开发，DARPA会给每个团队一部配置相同的Atlas机器人，这个闪闪发光的Atlas是波士顿动力开发的超强机器人。

Atlas更为大家所知是一次在日本的演示，演示过程中机器人被摄像头搬到，自己摔了一跤。在另一个视频里，Atlas被一个小东西绊倒了。讽刺的是，生产Atlas的公司就是生产著名的踢不倒机器狗的公司。Atals并不像众多TrackA参赛团队担心的那样拥有牛逼的平衡能力(参加Track A比赛的团队最后要和Track B团队的Atlas机器人进行物理特性测试的比赛。)

过了这周末，Atlas机器人就会更出名了，Atlas将加入Google的机器人大军，波士顿动力未向外界公布Google收购公司的价格，即便考虑到波士顿动力与DARPA的签约在收购之前，公众还是会更关注Atlas机器人在DRC上的表现，机器人大赛也会为Google的无人驾驶项目铺路。这次Google也会举办一个类似DRC的比赛，不过赛程更长。不管最终是机器人奴役人类还是服务人类，不管机器人会不会摔跤或是会不会摔坏，我们明年再看吧。

** [[http://tieba.baidu.com/p/1184618169][Linux系统备份的两种办法]]

经听到很多人抱怨 Linux 下没有 ghost 这样“方便”的备份工具。这是一种普遍的误解，其实 Linux 下是可以用 ghost for Linux 的，但因为有更好的办法，所以 ghost 在 Linux 下用得少，知名度不高。

现在以我的系统为例，介绍两种 Linux 下最常见最实用的系统备份方案。我的系统是 Gentoo Linux，sda1 30GB，挂载为 /，sda2 400GB，挂载为 /home, sda3 100GB，格式化为 ext4，空闲。

*** dd
dd 是最强劲有力、稳定可靠的备份工具。

备份：当前系统下，

~ % sudo dd if=/dev/sda1 of=~/gentoo_$(date +"%Y-%m-%d").backup

还原：其它 Linux 系统或者 LiveCD/LiveUSB 下，

~ % sudo dd if=gentoo_*.backup of=/dev/sda1

如果要改变根分区的位置，比如说把根分区移动到 sda5，那麽还需要调整一下：

~ % sudo resize2fs -f /dev/sda5
~ % sudo e2fsck -f /dev/sda5

然后修改恢复出来的 /etc/fstab 文件。

请注意 sda5 的容量必须大于 sda1.

dd 备份简单快速，是速度优先的最好选择，但所需要的磁盘空间比较大。

*** tar + xz
tar 用于打包，xz 用于压缩。

备份：当前系统下，

~ % cd /

/ % sudo tar Jcpvf ~/gentoo_amd64_$(date +"%Y-%m-%d").tar.xz --exclude=./usr/portage/distfiles --exclude=./home --exclude=./lost+found --exclude=./sys --exclude=./proc .

其中，--exclude= 参数列出了不需要备份的目录，可以根据实际情况自行调整。

还原：其它 Linux 系统或者 LiveCD/LiveUSB 下，

~ % sudo mkfs.ext4 /dev/sda1

~ % sudo mount -v /dev/sda1 /mnt

~ % sudo cd /mnt/

~ % sudo tar xpvf gentoo_amd64_*.tar.xz

~ % sudo mkdir -pv home sys proc usr/portage/distfiles

~ % cd && sudo umount -v /mnt

如果移动了根分区，则需要修改还原出来的 /etc/fstab 文件

tar+xz 压缩打包备份的优点，在于极高的压缩率，可以大大减少备份文件的大小。我的备份以前的 / 分区有 11G 大小，而备份出来的 .tar.xz 文件，只有 2.1G，压缩比为超过了 5:1. 但这带来一个问题：备份耗时漫长。比如说我这次 11G 的压缩备份就花了 2 小时。幸好还原速度还可以，只需要 8 分钟。此外，如果你 man 一下 tar，就会发现这种做法其实十分灵活好用。

我就介绍这两种办法，欢迎纠正和补充。

** [[http://www.2cto.com/os/201301/182484.html][linux下更改文件的默认打开方式]]



在Gnome的文件管理器(nautilus)里，双击一个文件的时候，系统会自动调用相应 的程序去打开这个文件。在Nautilus里通过右键菜单固然可以修改默认的打开方式，但是缺乏灵活性和可操作性，比如，不能删除一些候选的打开方式，不 能批量增加一些打开方式等等。  www.2cto.com

GNMOE的打开方式的配置方式涉及到以下几个目录和文件：
/usr/share/applications
~/.local/share/applications
/usr/share/applications/mimeinfo.cache
~/.local/share/applications/mimeinfo.cache
去这几个目录看一下，就会发现很多以.desktop为后缀的文件。
你可以手动修正部分打开方式错误的
如  www.2cto.com
vi preferred-web-browser.desktop
[Desktop Entry]
Version=1.0
Encoding=UTF-8
Type=ApplicationExec=/usr/local/softbase/firefox/firefox
TryExec=/usr/local/softbase/firefox/firefox
Name=Preferred Web Browser
GenericName=Web Browser
Comment=Browse the Web
Icon=redhat-web-browser.png
Terminal=false
X-Panel-Monitor=true
NoDisplay=true
修改完成后，就可以解决打开方式命令行参数错误的问题，然后右键选择默认打开方式即可
从总体上讲/usr/share/applications/defaults.list保存了全局的打开方式;
~/.local/share/applications/ 目录下保存了个人的打开方式【候选方式以及个性打开方式】;当两着不一致是，优先采用局部的个人设置。
  www.2cto.com
cd ~/.local/share/applications
删除无用的打开方式，候选打开方式里面就不会再有
如rm -rf wine*    即可【此时立即生效，所有wine相关的候选菜单不会再有
vi mimeapps.list 处理当前右键菜单以及默认打开方式【立即生效】
rm -rf  ~/.local/share/applications/mimeinfo.cache 【或者先察看下】
/usr/share/applications

这两个分别是局部的desktop项和全局的desktop项
/usr/share/applications/mimeinfo.cache
~/.local/share/applications/mimeinfo.cache
这两个分别是全局的和局部的打开方式缓存,想删除某种打开方式，或者修改默认的打开方式，在这里删除或改变顺序即可。

/usr/share/applications/defaults.list的结构 是这样的一种形式
程序的类型/文件类型=打开这个文件的项;[项2;]…[项n;]
候选打开方式可以有好几种中间用；隔开，不留其余字符
要修改一个文件的打开方式，需要先确定这个文件的类型
以纯文本文件为例 类型是plain 打开方式默认为vim.desktop候选的是firefox.desktop
text/plain=vim.desktop;firefox.desktop
可以直接编辑
~/.local/share/applications/defaults.list

编辑完之后，手工修改
/usr/share/applications/mimeinfo.cache
~/.local/share/applications/mimeinfo.cache

这两个cache文件。

下面看一下*.desktop文件的结构
[Desktop Entry]
Encoding=UTF-8 //字符编码
Name=vim　　//现实的名字
MimeType=text/plain; //类型
Exec=vim %f //运行的程序 %f表示一个参数
Type=Application　//类型

** [[http://www.2cto.com/os/201306/222522.html][交换ctrl和caps lock]]

交换ctrl和caps lock

因为ctrl键在笔记本键盘的左下角，对于经常使用ctrl键的人来说是个痛苦的事情。在网上搜了下有几种交换键位的方法，在这里记录一下。

第一种方法是使用xmodmap。建立一个新文件~/.Xmodmap，添加以下内容：

remove Lock = Caps_Lock
remove Control = Control_L
keysym Control_L = Caps_Lock
keysym Caps_Lock = Control_L
add Lock = Caps_Lock
add Control = Control_L
然后执行

xmodmap ~/.Xmodmap 2>/dev/null
就行了。如果不想每次启动都手动输入命令，可以把命令写到~/.xinitrc中。注意如果把命令写到~/.bashrc中，每次新开一个终端或tab上述命令都会被执行一次，这样键位又换回来了。

另一种方法是使用setxkbmap命令。只需执行下面的命令：

setxkbmap -option ctrl:swapcaps
就行了。而且可以把命令放到~/.bashrc中，重复执行并不影响。

(2012.07.02更新)在gnome中可以通过图形界面选项调整。打开 系统 -> 首选项 -> 键盘 -> 布局 -> 选项… -> Ctrl key position，选择”Swap Ctrl and CapsLock”即可。

除了交换ctrl和caps lock外也有和alt互换的，这样就可以用两个拇指分别按ctrl和alt(交换右ctrl和alt)：

remove mod1 = Alt_R
remove Control = Control_R
keysym Control_R = Alt_R
keysym Alt_R = Control_R
add mod1 = Alt_R
add Control = Control_R
为什么会想到要交换ctrl键呢？因为某天在网上闲逛的时候，无意中看到这篇文章，顿时热血沸腾，心想左手vim右手emacs是多么拉风的事情。为了表明自己学习的决心，装上emacs的同时也把相伴5年的vim给卸了。磕磕碰地碰用了几个星期，最深的感触是左手小指太辛苦了，即使是把ctrl和caps lock交换，一天下来小指也是又累又痛，于是又灰溜溜地用回vim了。想学习emacs的朋友如果觉得没有动力的话可以看看上面提到的文章，一直在用vim的或者没用过这两者的也建议尝试一下，说不定你就爱上它了。即使可能被吓退，但是相信会从学习过程中收获不少，例如可以在vim里模拟几个emacs移动定位的快捷键，对于输入法切换或输入括号和引号等成对出现的字符时就很方便：

" emacs-style key bindings
inoremap <C-a> <C-o>^
inoremap <C-b> <left>
inoremap <C-d> <del>
inoremap <C-e> <C-o>$
inoremap <C-f> <right>
inoremap <C-g> <esc>
inoremap <C-k> <C-o>D
inoremap <C-n> <down>
inoremap <C-p> <up>
inoremap <C-t> <esc>xpi
inoremap <C-y> <esc>pa
更夸张一点的还把右ctrl和enter给换了，毕竟在emacs中用ctrl的时候很多，而且enter可以用ctrl-m和ctrl-j代替，这样两只手的小指可以左右开弓。

** [[http://bbs.mydigit.cn/simple/?t523987.html][ HDMI、DVI和VGA之间的区别 ]]

目前在高清设备中，主要的接口有DVI、HDMI、VGA接口，其中VGA传输的是模拟视频信号，DVI传播的是数字视频信号，HDMI可以同时传输数字视频信号和数字音频信号。在现在的计算机和电视等设备中，我们经常可以看到这三种接口，很多用户存在疑问，这三种接口之间有什么区别呢?
DVI接口是在1999年推出的接口标准。DVI接口的传输信号采用全数字格式，与之对应的是采用模拟信号的VGA接口。VGA和DVI的区别，首先VGA模拟信号的传输比较麻烦，首先是将电脑内的数字信号转换为模拟信号，将信号发送到LCD显示器，由显示器再将该模拟信号转换为数字信号，形成画面展示在大家面前。正因为如此，中间的信号丢失严重，虽然可以通过软件的方法修复部分画面，但是随着显示器的分辨率越高画面就会越模糊。一般模拟信号在超过1280×1024分辨率以上的情况下就会出现明显的误差，分辨率越高越严重。
VGA接口应用范围非常广泛，是三种接口中最先推出的标准，VGA(Video Graphics Array)接口，也叫D-Sub接口。虽然液晶显示器可以直接接收数字信号，但很多低端产品为了与VGA接口显卡相匹配，因而采用VGA接口。VGA接口是一种D型接口，上面共有15针空，分成三排，每排五个。VGA接口是显卡上应用最为广泛的接口类型，绝大多数的显卡都带有此种接口。
HDMI (High-Definition Multimedia Interface) ，常被称作高清晰度多媒体接口，是终结以往影音分离传输的全新接口，其最大传输速度可达5Gb/s，除影像数据外，更可同时传输高达8声道的音讯信号。这种非压缩式的数字数据传输，可有效降低数/类转换所造成的信号干扰与衰减。HDMI是首个支持在单线缆上传输，不经过压缩的全数字高清晰度、多声道音频和智能格式与控制命令数据的数字接口。HDMI接口由Silicon Image美国晶像公司倡导，联合索尼、日立、松下、飞利浦、汤姆逊、东芝等八家著名的消费类电子制造商联合成立的工作组共同开发的。HDMI最早的接口规范HDMI1.0于2002年12月公布，目前的最高版本是于今年6月发布的HDMI1.3规范。
HDMI源于DVI接口技术，它们主要是以美国晶像公司的TMDS信号传输技术为核心，这也就是为何HDMI接口和DVI接口能够通过转接头相互转换的原因。美国晶像公司是HDMI八个发起者中唯一的集成电路设计制造公司，是高速串行数据传输技术领域的领导厂商。
目前的高端显卡上一般有VGA、DVI、HDMI接口，一般的显示卡VGA、DVI接口；目前生产的大屏幕LED显示器上有VGA、HDMI接口（如三星24寸），中型LED显示器有VGA、DVI接口（比如三星21寸），选购连接线前请注意观察显示卡和显示器接口的匹配，接口型号不同时，可以选择转接线。

** [[https://wiki.archlinux.org/index.php/Xinitrc][xinitrc]]

The =~/.xinitrc= file is a shell script read by =xinit= and by its
front-end =startx=. It is mainly used to execute
[[/index.php/Desktop_environment][desktop environments]],
[[/index.php/Window_manager][window managers]] and other programs when
starting the X server (e.g., starting daemons and setting environment
variables). The =xinit= program starts the
[[/index.php/X_Window_System][X Window System]] server and works as
first client program on systems that are not using a
[[/index.php/Display_manager][display manager]].

One of the main functions of =~/.xinitrc= is to dictate which client for
the X Window System is invoked with =startx= or =xinit= programs on a
per-user basis. There exists numerous additional specifications and
commands that may also be added to =~/.xinitrc= as you further customize
your system.

Most DMs also source the similar [[/index.php/Xprofile][xprofile]]
before xinit.

*** Contents

-  [[#Installation][1 Installation]]
-  [[#Configuration][2 Configuration]]
-  [[#Autostart_X_at_login][3 Autostart X at login]]

   -  [[#Automatic_login_to_the_virtual_console][3.1 Automatic login to
      the virtual console]]

-  [[#Tips_and_tricks][4 Tips and tricks]]

   -  [[#Override_xinitrc_from_command_line][4.1 Override xinitrc from
      command line]]
   -  [[#Making_a_DE.2FWM_choice][4.2 Making a DE/WM choice]]
   -  [[#Starting_applications_without_a_window_manager][4.3 Starting
      applications without a window manager]]

*** Installation

[[/index.php/Install][Install]]
[[https://www.archlinux.org/packages/?name=xorg-xinit][xorg-xinit]],
which provides both /xinit/ and /startx/.

*** Configuration

If =.xinitrc= is present in a user's home directory, /startx/ and
/xinit/ execute it. Otherwise /startx/ will run the default
=/etc/X11/xinit/xinitrc=.

*Note:* /Xinit/ has its own default behaviour instead of executing the
file. See =man 1 xinit= for details.

This default xinitrc will start a basic environment with
[[/index.php/Twm][Twm]],
[[https://www.archlinux.org/packages/?name=xorg-xclock][xorg-xclock]]
and [[/index.php/Xterm][Xterm]] (assuming that the necessary packages
are installed). Therefore, to start a different window manager or
desktop environment, first create a copy of the default =xinitrc= in
home directory:

#+BEGIN_EXAMPLE
    $ cp /etc/X11/xinit/xinitrc ~/.xinitrc
#+END_EXAMPLE

The reason of doing this (instead of creating one from scratch) is to
preserve some desired default behaviour in the original file, such as
sourcing shell scripts from =/etc/X11/xinit/xinitrc.d=. Scripts in this
directory without =.sh= extension are not sourced:
[[https://bugs.archlinux.org/task/41471][FS#41471]]. As such, replace
=/etc/X11/xinit/xinitrc.d/?*.sh= with =/etc/X11/xinit/xinitrc.d/?*=.
[[https://bbs.archlinux.org/viewtopic.php?pid=1514318#p1514318][[1]]]

Append desired commands and /remove/comment the conflicting lines/.
Remember, lines following =exec= would be ignored. For example, to start
[[/index.php/Openbox#Standalone][openbox]]:

#+BEGIN_EXAMPLE
    ~/.xinitrc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    ...

    if [ -d /etc/X11/xinit/xinitrc.d ] ; then
        for f in /etc/X11/xinit/xinitrc.d/?* ; do
            [ -x "$f" ] && . "$f"
        done
        unset f
    fi

    # twm &
    # xclock -geometry 50x50-1+1 &
    # xterm -geometry 80x50+494+51 &
    # xterm -geometry 80x20+494-0 &
    # exec xterm -geometry 80x66+0+0 -name login

    ## some applications that should be run in the background
    xscreensaver &
    xsetroot -cursor_name left_ptr &

    exec openbox-session
#+END_EXAMPLE

*Note:* At the very least, ensure that the /if block/ in the example
above is present in your =.xinitrc= file to ensure that the scripts in
=/etc/X11/xinit/xinitrc.d= are sourced.

Long-running programs started before the window manager, such as a
screensaver and wallpaper application, must either fork themselves or be
run in the background by appending an =&= sign. Otherwise, the script
would halt and wait for each program to exit before executing the window
manager or desktop environment. Note that some programs should instead
not be forked, to avoid race bugs, as is the case of
[[/index.php/Xrdb][xrdb]]. Prepending =exec= will replace the script
process with the window manager process, so that X does not exit even if
this process forks to the background.

To now run Xorg as a regular user, issue:

#+BEGIN_EXAMPLE
    $ startx
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    $ xinit -- :1 -nolisten tcp vt$XDG_VTNR
#+END_EXAMPLE

Your window manager (or desktop environment) of choice should now start
correctly.

To quit X, run your window manager's exit function (assuming it has
one). If it lacks such functionality, run:

#+BEGIN_EXAMPLE
    $ pkill -15 Xorg
#+END_EXAMPLE

*Note:* /pkill/ will kill all running X instances. To specifically kill
the window manager on the current VT, use:

#+BEGIN_EXAMPLE
    WM_PID=$(xprop -id $(xprop -root _NET_SUPPORTING_WM_CHECK \
    | awk -F'#' '{ print $2 }') _NET_WM_PID \
    | awk -F' = ' '{ print $2 }')

    kill -15 $WM_PID
#+END_EXAMPLE

The program =xprop= is provided by the package
[[https://www.archlinux.org/packages/?name=xorg-xprop][xorg-xprop]] in
the [[/index.php/Official_repositories][official repositories]].

*Note:*

-  The above commands run [[/index.php/Xorg][Xorg]] on the same virtual
   terminal the user is logged in to.
   [[http://blog.falconindy.com/articles/back-to-basics-with-x-and-systemd.html][[2]]]
   This maintains an authenticated session with =logind=, and prevents
   bypassing the screen locker by switching terminals.
-  You have to specify =vt$XDG_VTNR= as command line option for /xinit/
   in order to
   [[/index.php/General_troubleshooting#Session_permissions][preserve
   session permissions]].
-  /xinit/ does not handle multiple sessions when already logged-in into
   a different virtual terminal. For that you must specify the session
   by appending =-- :session_no=. If X is already running, then you
   should start with :1 or more.
-  By default, due to permissions on console devices, the X display
   needs to be on the same tty where the login occurred. This is handled
   by the default =/etc/X11/xinit/xserverrc=. See
   [[/index.php/General_troubleshooting#Session_permissions][General
   troubleshooting#Session permissions]] for details.
-  If you wish to have the X display on a separate console from the one
   where the server is invoked, you can do so by using the X server
   wrapper provided by =/usr/lib/systemd/systemd-multi-seat-x=. For
   convenience, /startx/ can be set up to use this wrapper by modifying
   your =~/.xserverrc=.
-  If you choose to use /xinit/ instead of /startx/, you are responsible
   for passing =-nolisten tcp= and ensuring the session does not break
   by starting X on a different tty.
-  If X terminates with error message "SocketCreateListener() failed",
   you may need to delete socket files in =/tmp/.X11-unix=. This may
   happen if you have previously run Xorg as root (e.g. to generate an
   =xorg.conf=, as below).

*** Autostart X at login

*Note:* These solutions run X on the same tty used to login, which is
required in order to maintain the login session.

For [[/index.php/Bash][Bash]], add the following to the bottom of
=~/.bash_profile=. If the file does not exist, copy a skeleton version
from =/etc/skel/.bash_profile=. For [[/index.php/Zsh][Zsh]], add it to
=~/.zlogin= (or =~/.zprofile=) instead.

#+BEGIN_EXAMPLE
    [[ -z $DISPLAY && $XDG_VTNR -eq 1 ]] && exec startx
#+END_EXAMPLE

*Note:*

-  You can replace the =-eq 1= comparison with one like =-le 3= (for vt1
   to vt3) if you want to use graphical logins on more than one VT.
-  X must always be run on the same tty where the login occurred, to
   preserve the logind session. This is handled by the default
   =/etc/X11/xinit/xserverrc=.
-  =xinit= may be faster than =startx=, but needs additional parameter
   such as =-nolisten tcp=.
-  If you would like to remain logged in when the X session ends, remove
   =exec=.

See also [[/index.php/Fish#Start_X_at_login][Fish#Start X at login]] and
[[/index.php/Systemd/User#Automatic_login_into_Xorg_without_display_manager][Systemd/User#Automatic
login into Xorg without display manager]].

**** Automatic login to the virtual console

This method can be combined with
[[/index.php/Automatic_login_to_virtual_console][automatic login to
virtual console]].

*** Tips and tricks

**** Override xinitrc from command line

If you have a working =~/.xinitrc=, but just want to try other WM/DE,
you can run it by issuing /startx/ followed by the path to the window
manager:

#+BEGIN_EXAMPLE
    $ startx /full/path/to/window-manager
#+END_EXAMPLE

If the window manager takes arguments, they need to be enquoted to be
recognized as part of the first parameter of /startx/:

#+BEGIN_EXAMPLE
    $ startx "/full/path/to/window-manager --key value"
#+END_EXAMPLE

Note that the full path is *required*. Optionally, you can also override
=/etc/X11/xinit/xserverrc= file (which stores the default X server
options) with custom options by appending them after =--=, e.g.:

#+BEGIN_EXAMPLE
    $ startx /usr/bin/enlightenment -- -nolisten tcp -br +bs -dpi 96 vt$XDG_VTNR
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    $ xinit /usr/bin/enlightenment -- -nolisten tcp -br +bs -dpi 96 vt$XDG_VTNR
#+END_EXAMPLE

See also =man startx=.

*Tip:* This can be used even to start a regular GUI programs but without
any of the window manager features. See also
[[#Starting_applications_without_a_window_manager][#Starting
applications without a window manager]] and
[[/index.php/Running_program_in_separate_X_display][Running program in
separate X display]].

**** Making a DE/WM choice

If you are frequently switching between different DEs/WMs, it is
recommended to either use a [[/index.php/Display_manager][Display
manager]] or add code to =.xinitrc=. The code described next consists of
a simple few lines, which will take the argument and load the desired
desktop environment or window manager.

The following example =~/.xinitrc= shows how to start a particular DE/WM
with an argument:

#+BEGIN_EXAMPLE
    ~/.xinitrc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    ...

    # Here Xfce is kept as default
    session=${1:-xfce}

    case $session in
        awesome           ) exec awesome;;
        bspwm             ) exec bspwm;;
        catwm             ) exec catwm;;
        cinnamon          ) exec cinnamon-session;;
        dwm               ) exec dwm;;
        enlightenment     ) exec enlightenment_start;;
        ede               ) exec startede;;
        fluxbox           ) exec startfluxbox;;
        gnome             ) exec gnome-session;;
        gnome-classic     ) exec gnome-session --session=gnome-classic;;
        i3|i3wm           ) exec i3;;
        icewm             ) exec icewm-session;;
        jwm               ) exec jwm;;
        kde               ) exec startkde;;
        mate              ) exec mate-session;;
        monster|monsterwm ) exec monsterwm;;
        notion            ) exec notion;;
        openbox           ) exec openbox-session;;
        unity             ) exec unity;;
        xfce|xfce4        ) exec startxfce4;;
        xmonad            ) exec xmonad;;
        # No known session, try to run it as command
        *) exec $1;;
    esac
#+END_EXAMPLE

Then copy the =/etc/X11/xinit/xserverrc= file to your home directory:

#+BEGIN_EXAMPLE
    $ cp /etc/X11/xinit/xserverrc ~/.xserverrc
#+END_EXAMPLE

After that, you can easily start a particular DE/WM by passing an
argument, e.g.:

#+BEGIN_EXAMPLE
    $ xinit
    $ xinit gnome
    $ xinit kde
    $ xinit wmaker
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    $ startx
    $ startx ~/.xinitrc gnome
    $ startx ~/.xinitrc kde
    $ startx ~/.xinitrc wmaker
#+END_EXAMPLE

**** Starting applications without a window manager

It is possible to start only specific applications without a window
manager, although most likely this is only useful with a single
application shown in full-screen mode. For example:

#+BEGIN_EXAMPLE
    ~/.xinitrc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    ...

    exec chromium
#+END_EXAMPLE

With this method you need to set each application window's geometry
through its own configuration files, if possible at all.

*Tip:* This method can be useful to launch graphical games, especially
on systems where excluding the memory or CPU usage of a window manager
or desktop environment, and possible accessory applications, can help
improve the game's execution performance.

See also
[[/index.php/Display_manager#Starting_applications_without_a_window_manager][Display
manager#Starting applications without a window manager]].

** [[https://wiki.archlinux.org/index.php/Xmodmap][xmodmap]]


*Note:* /xmodmap/ settings are reset by /setxkbmap/, which not only
alters the alphanumeric keys to the values given in the map, but also
resets all other keys to the startup default.
[[http://wiki.linuxquestions.org/wiki/Configuring_keyboards][[1]]]

/xmodmap/ is a utility for modifying keymaps and pointer button mappings
in [[/index.php/Xorg][Xorg]].

/xmodmap/ is not directly related to
[[/index.php/X_KeyBoard_extension][X KeyBoard extension]] (XKB), as it
uses different (pre-XKB) ideas on how /keycodes/ are processed within X.
Generally, it is only recommended for the simplest tasks. See
[[/index.php/X_KeyBoard_extension][X KeyBoard extension]] for advanced
layout configuration.

*** Contents

-  [[#Introduction][1 Introduction]]
-  [[#Installation][2 Installation]]
-  [[#Keymap_table][3 Keymap table]]
-  [[#Custom_table][4 Custom table]]

   -  [[#Activating_the_custom_table][4.1 Activating the custom table]]
   -  [[#Test_changes][4.2 Test changes]]

-  [[#Modifier_keys][5 Modifier keys]]
-  [[#Reverse_scrolling][6 Reverse scrolling]]
-  [[#Templates][7 Templates]]

   -  [[#Spanish][7.1 Spanish]]
   -  [[#Turn_CapsLock_into_Control.2C_and_LeftControl_into_Hyper][7.2
      Turn CapsLock into Control, and LeftControl into Hyper]]
   -  [[#Switch_every_number_key_N_with_Shift-N_and_vice-versa.2C_for_Croatian_layout][7.3
      Switch every number key N with Shift-N and vice-versa, for
      Croatian layout]]

-  [[#See_also][8 See also]]

*** Introduction

There are two types of keyboard values in [[/index.php/Xorg][Xorg]]:
/keycodes/ and /keysyms/.

-   keycode  :: The /keycode/ is the numeric representation received by
   the kernel when a key or a mouse button is pressed.
-   keysym :: The /keysym/ is the value assigned to the /keycode/. For
   example, pressing =A= generates the =keycode 73=, which is mapped to
   the =keysym 0×61=, which matches =A= in the
   [[https://en.wikipedia.org/wiki/ASCII][ASCII table]].
   The /keysyms/ are managed by [[/index.php/Xorg][Xorg]] in a table of
   /keycodes/ defining the /keycode/-/keysym/ relations, which is called
   the [[#Keymap_table][keymap table]]. This can be shown by running
   =xmodmap=.

*** Installation

/xmodmap/ can be [[/index.php/Pacman][installed]] through the
[[https://www.archlinux.org/packages/?name=xorg-xmodmap][xorg-xmodmap]]
package from the [[/index.php/Official_repositories][official
repositories]].

Optionally, install
[[https://www.archlinux.org/packages/?name=xkeycaps][xkeycaps]], which
is a graphical front-end to /xmodmap/.

*** Keymap table

Print the current keymap table formatted into expressions:

#+BEGIN_EXAMPLE
    $ xmodmap -pke
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [...]
    keycode  57 = n N
    [...]
#+END_EXAMPLE

Each /keycode/ is followed by the /keysym/ it is mapped to. The above
example indicates that the /keycode/ =57= is mapped to the lowercase
=n=, while the uppercase =N= is mapped to /keycode/ =57= plus =Shift=.

Each /keysym/ column in the table corresponds to a particular
combination of modifier keys:

1. =Key=
2. =Shift+Key=
3. =mode_switch+Key=
4. =mode_switch+Shift+Key=
5. =AltGr+Key=
6. =AltGr+Shift+Key=

Not all /keysyms/ have to be set, but to assign only a latter /keysym/,
use the =NoSymbol= value.

To see which /keycode/ corresponds to a key, see
[[/index.php/Extra_keyboard_keys#In_Xorg][Extra keyboard keys#In Xorg]]
for details on the /xev/ utility.

*Tip:* There are predefined descriptive /keysyms/ for multimedia keys,
e.g. =XF86AudioMute= or =XF86Mail=. These /keysyms/ can be found in
=/usr/include/X11/XF86keysym.h=. Many multimedia programs are designed
to work with these /keysyms/ out-of-the-box, without the need to
configure any third-party application.

Note that xmodmap is influenced by xkbd settings, so all eight keysym
are available for the us(intl) xkbd layout but not for the default us
(it is missing the ralt_switch symbol defined in level3). To have all 8
keysyms available you should configure the /(intl)/ variant of the
keyboard from xorg.conf or add, using us layout as an example,
=setxkbmap -layout 'us(intl)'= before calling xmodmap.

*** Custom table

To create a key map (i.e. =~/.Xmodmap=):

#+BEGIN_EXAMPLE
    $ xmodmap -pke > ~/.Xmodmap
#+END_EXAMPLE

To test the changes:

#+BEGIN_EXAMPLE
    $ xmodmap ~/.Xmodmap
#+END_EXAMPLE

**** Activating the custom table

With [[/index.php/GDM][GDM]], [[/index.php/XDM][XDM]],
[[/index.php/KDM][KDM]] or [[/index.php/LightDM][LightDM]] there is no
need to source =~/.Xmodmap=. For [[/index.php/Startx][startx]], use:

#+BEGIN_EXAMPLE
    ~/.xinitrc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    if [ -s ~/.Xmodmap ]; then
        xmodmap ~/.Xmodmap
    fi
#+END_EXAMPLE

Alternatively, edit the global startup script =/etc/X11/xinit/xinitrc=.

**** Test changes

To make temporary changes:

#+BEGIN_EXAMPLE
    $ xmodmap -e "keycode  46 = l L l L lstroke Lstroke lstroke"
    $ xmodmap -e "keysym a = e E"
#+END_EXAMPLE

*** Modifier keys

/xmodmap/ can also be used to override
[[https://en.wikipedia.org/wiki/Modifier_key][modifier keys]], e.g. to
swap =Control= and =Super= (the
[[https://en.wikipedia.org/wiki/Windows_key][Windows keys]]).

Before assignment the modifier keys need to be empty. =!= is a comment,
so only the modifiers =Control= and =Mod4= get cleared in the following
example. Then the /keysyms/ =Control_L=, =Control_R=, =Super_L= and
=Super_R= are assigned to the opposite modifier. Assigning both left and
right to the same modifier means that both keys are treated the same
way.

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [...]
    !clear Shift
    !clear Lock
    clear Control
    !clear Mod1
    !clear Mod2
    !clear Mod3
    clear Mod4
    !clear Mod5
    !add Shift   = Shift_L Shift_R
    !add Lock    = Caps_Lock
    add Control = Super_L Super_R
    !add Mod1    = Alt_L Alt_R
    !add Mod2    = Mode_switch
    !add Mod3    =
    add Mod4    = Control_L Control_R
    !add Mod5    =
#+END_EXAMPLE

*Note:* The example assumes that the =Control_L= and =Control_R= keysyms
were assigned to the =Control= modifier, and =Super_L= and =Super_R=
keysyms to the =Mod4= modifier. If you get the following error message
=X Error of failed request:  BadValue (integer parameter out of range for operation)=,
you will need to adapt accordingly. Running =xmodmap= produces a list of
modifiers and keys that are assigned to them.

The following example modifies =CapsLock= to =Control=, and
=Shift+CapsLock= to =CapsLock=:

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    clear lock
    clear control
    add control = Caps_Lock Control_L Control_R
    keycode 66 = Control_L Caps_Lock NoSymbol NoSymbol
#+END_EXAMPLE

*** Reverse scrolling

The
[[http://who-t.blogspot.com/2011/09/natural-scrolling-in-synaptics-driver.html][natural
scrolling]] feature available in OS X Lion (mimicking smartphone or
tablet scrolling) can be
[[https://bbs.archlinux.org/viewtopic.php?id=126258][replicated]] with
/xmodmap/. Since the synaptics driver uses the buttons 4/5/6/7 for
up/down/left/right scrolling, you simply need to swap the order of how
the buttons are declared in =~/.Xmodmap=:

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    pointer = 1 2 3 5 4 7 6 8 9 10 11 12
#+END_EXAMPLE

Then update /xmodmap/:

#+BEGIN_EXAMPLE
    $ xmodmap ~/.Xmodmap
#+END_EXAMPLE

*** Templates

**** Spanish

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    keycode  24 = a A aacute Aacute ae AE ae
    keycode  26 = e E eacute Eacute EuroSign cent EuroSign
    keycode  30 = u U uacute Uacute downarrow uparrow downarrow
    keycode  31 = i I iacute Iacute rightarrow idotless rightarrow
    keycode  32 = o O oacute Oacute oslash Oslash oslash
    keycode  57 = n N ntilde Ntilde n N n
    keycode  58 = comma question comma questiondown dead_acute dead_doubleacute dead_acute
    keycode  61 = exclam section exclamdown section dead_belowdot dead_abovedot dead_belowdot
    !Maps the Mode key to the Alt key
    keycode 64 = Mode_switch
#+END_EXAMPLE

**** Turn CapsLock into Control, and LeftControl into Hyper

Laptop users may prefer having =CapsLock= as =Control=. The =Left Hyper=
key can be used as a modifier.

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    clear      lock
    clear   control
    clear      mod1
    clear      mod2
    clear      mod3
    clear      mod4
    clear      mod5
    keycode      37 = Hyper_L
    keycode      66 = Control_L
    add     control = Control_L Control_R
    add        mod1 = Alt_L Alt_R Meta_L
    add        mod2 = Num_Lock
    add        mod3 = Hyper_L
    add        mod4 = Super_L Super_R
    add        mod5 = Mode_switch ISO_Level3_Shift
#+END_EXAMPLE

**** Switch every number key N with Shift-N and vice-versa, for Croatian
layout

Should work fine for layouts similar to Croatian as well.

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    keycode 10 = exclam 1 1 exclam asciitilde dead_tilde asciitilde
    keycode 11 = quotedbl 2 2 quotedbl dead_caron caron dead_caron
    keycode 12 = numbersign 3 3 numbersign asciicircum dead_circumflex asciicircum
    keycode 13 = dollar 4 4 dollar dead_breve breve dead_breve
    keycode 14 = percent 5 5 percent degree dead_abovering degree
    keycode 15 = ampersand 6 6 ampersand dead_ogonek ogonek dead_ogonek
    keycode 16 = slash 7 7 slash grave dead_grave grave
    keycode 17 = parenleft 8 8 parenleft dead_abovedot abovedot dead_abovedot
    keycode 18 = parenright 9 9 parenright dead_acute apostrophe dead_acute
    keycode 19 = equal 0 0 equal dead_doubleacute doubleacute dead_doubleacute
#+END_EXAMPLE

*** See also

-  [[http://www.x.org/archive/current/doc/man/man1/xmodmap.1.xhtml][Current
   man page]] at X.Org Foundation
-  [[http://cweiske.de/howto/xmodmap/allinone.html][Multimediakeys with
   .Xmodmap HOWTO]] by Christian Weiske
-  [[http://dev-loki.blogspot.com/2006/04/mapping-unsupported-keys-with-xmodmap.html][Mapping
   unsupported keys with xmodmap]] by Pascal Bleser
-  [[http://wiki.linuxquestions.org/wiki/List_of_Keysyms_Recognised_by_Xmodmap][List
   of Keysyms Recognised by Xmodmap]] on
   [[http://linuxquestions.org][LinuxQuestions]]

** [[http://blog.sina.com.cn/s/blog_578fb7710101m90d.html][ubuntu安装fcitx五笔拼音输入法 ]]

根据网络资料整理，参考：
http://gongstring.iteye.com/blog/1392151
http://cyanman.blog.163.com/blog/static/1525020820111196433790/

第一步：缷载ibus
sudo apt-get remove ibus
重启ubuntu

第二步：安装fcitx五笔拼音
sudo add-apt-repository ppa:wengxt/fcitx-nightly
sudo apt-get update
sudo apt-get install im-switch fcitx
sudo apt-get install fcitx-table-wbpy
sudo im-switch -s fcitx
im-switch -s fcitx
重启ubuntu

其它参考：
     1，不希望使用一大堆用不着的输入法，可以关闭它：
        $sudo gedit /usr/share/fcitx/data/tabels.conf
     把里面不要的输入法整段删除，至于双拼可以在下面说的config 里关闭
     2，在打字时要输入,.号经常按不出来，可以这样：
     ~/.fcitx 目录下有一个 config 文件（启动至少一次fcitx 才会自动建立）可以配置翻页键把里面的 ,. 二个删除，不然在出联想时打不出,. 号
     3，不想让它一直显示在那，可以这样：
     ~/.fcitx 目录下有一个 config 文件可以配置 代码:
     主窗口隐藏模式=1
     4，在英文local 下 fcitx 打出的字全方块，可以这样：
     修改上面说的这个config 里的 代码:
     显示字体(中)=字体名
     5，使用ctrl+左shift键可以切换输入方案
     6，其它应用技巧可以到fcitx的主页下载其最新版的使用说明书（pdf文档）。
中文简繁转换：ctrl+shift+f

** [[http://blog.csdn.net/mdx20072419/article/details/8060432][sudo: no valid sudoers sources found, quitting]]

我的环境实在VMwa 下装了一个Ubuntu，今天在Ubuntu添加了一个用户，

adduser mdx



添加用户成功，可是我在使用sudo安装软件的时候提示：

[[mailto:mdx@ubuntu:/home/farsight$][mdx@ubuntu:/home/farsight$]] sudo
apt-get install ssh
 [sudo] password for mdx:
 mdx is not in the sudoers file.  This incident will be reported.

上网查了一些解决办法，千篇一律：

1>、进入超级用户模式。 2>、添加文件的写权限。也就是输入命令"chmod 0777
/etc/sudoers"。

 3>、编辑/etc/sudoers文件，找到这一行："root ALL=(ALL)
ALL"在这一行下面添加"xxx ALL=(ALL)
ALL"(这里的xxx是你的用户名，我这里是mdx)，然后保存退出。

本以为大功告成，可是再次使用sudo时，又出现了另一个问题：

sudo: /etc/sudoers is mode 0777, should be 0440

sudo: no valid sudoers sources found, quitting



这让给我很纠结，想用sudo去更改权限，sudo还不能用，想su切换到root用户，可是我的root没设密码，还没激活。

参考了一些资料，最终解决，先把解决办法共享一下：

重启Ubuntu，按F12进入Recovery mode

在Recovery Menu选择root

这样就可以使用root用户了，然后把/etc/sudoers属性改回来 "chmod 0440
/etc/sudoers"。

That's OK！

这里你也可以给root设置密码，激活root

** [[http://tieba.baidu.com/p/3006415003?bd_source_light=1563095][玩ubuntu系统修改sudoers 错误了，没用visudo]]

1.错误提示：sudo: no valid sudoers sources found,quitting
解决办法：(1)重启系统，选择(recovery mode/恢复模式)引导项;
(2)在Recovery Menu页面选择root后回车;
(3)设置或者撤销/etc/sudoers文件的权限,命令如下：
chmod u-w /etc/sudoers
chmod 440 /etc/sudoers
2、错误提示：chomd :changing permissions of 'sudoers' :Read-only file system解决办法：利用 mount 指令解决 Read-only file system的问题 mount -o remount rw /
3.修改 /etc/sudoers 时，用 sudo visudo 命令修改，就不用先改权限了。修改后按Ctrl+x，选择Y，输入文件名，回车；

** [[http://blog.csdn.net/hustrains/article/details/8652098][ubuntu如何设置默认程序打开方式]]

1   简单的方法：
右键点击所需要的开的文件，选择“属性” ，“打开方式” 即可以选择默认打开的程序，这是最简便的设定方法！！

2  复杂一点的方法：
从总体上讲

/etc/gnome/defaults.list 保存了全局的打开方式

/.local/share/applications/mimeapps.list 保存了个人的打开方式

当两着不一致是，优先采用局部的个人设置。

例如，ubuntu12.04下视频文件默认是用电影播放机打开的，如果你想要改成用smplayer来打开的话，可以按照以下步聚来进行：

1.进入/etc/gnome目录
  命令 ：cd /etc/gnome

2.复制要改变打开方式的那些内容行到mimeapps.list文件
 命令 grep “totem” defaults.list >> ~/.local/share/applications/mimeapps.list

3.进入~/.local/share/applications目录
 命令 cd ~/.local/share/applications

4.编缉mimeapps.list文件
 命令： sudo vim mimeapps.list

5.在vim中执行
 命令：%s/totem/smplayer/g

6.然后执行保存
 命令：wq

7.完成

想要改其它类型的可照此类推，比如我就把音频文件换成了audacious来打开，文本文件用gvim来默认打开。

** [[http://54rd.net/html/2015/server_0122/30.html][ubuntu分屏终端terminator好用的快捷键]]

在ubuntu下的默认终端为terminal，但terminator会更好用一些，操作设置会更方便。使用常用快捷键：新增标签页：Ctrl
+ Shift + T 关闭标签页：Ctrl + Shift + W 左右分屏：Ctrl + Shift + E
上下分屏：Ctrl + Shi

在ubuntu下的默认终端为terminal，但terminator会更好用一些，操作设置会更方便。
 安装命令直接使用apt-get安装：


$sudo apt-get install terminator


 安装完成后，可以根据自己喜好修改颜色，可支持横竖切屏，支持多标签。

 [[http://54rd.net/uploadfile/2015/0122/20150122020858396.png]]

 使用常用快捷键：

 新增标签页：Ctrl + Shift + T
 关闭标签页：Ctrl + Shift + W
 左右分屏：Ctrl + Shift + E
 上下分屏：Ctrl + Shift + O
 复制：Ctrl + Shift + C
 粘贴：Ctrl + Shift + V
 清屏幕：Ctrl + Shift + G

** [[https://www.haskell.org/cabal/][The Haskell Cabal]]

Cabal is a system for building and packaging Haskell libraries and programs. It defines a common interface for package authors and distributors to easily build their applications in a portable way. Cabal is part of a larger infrastructure for distributing, organizing, and cataloging Haskell libraries and programs.

Specifically, the Cabal describes what a Haskell package is, how these packages interact with the language, and what Haskell implementations must to do to support packages. The Cabal also specifies some infrastructure (code) that makes it easy for tool authors to build and distribute conforming packages.

The Cabal is only one contribution to the larger goal. In particular, the Cabal says nothing about more global issues such as how authors decide where in the module name space their library should live; how users can find a package they want; how orphan packages find new owners; and so on.

** [[http://blog.csdn.net/wudiyi815/article/details/7473097][ Linux查看端口使用状态、关闭端口方法]]

前提：首先你必须知道，端口不是独立存在的，它是依附于进程的。某个进程开启，那么它对应的端口就开启了，进程关闭，则该端口也就关闭了。下次若某个进程再次开启，则相应的端口也再次开启。而不要纯粹的理解为关闭掉某个端口，不过可以禁用某个端口。

1. 可以通过"netstat -anp" 来查看哪些端口被打开。
（注：加参数'-n'会将应用程序转为端口显示，即数字格式的地址，如：nfs->2049, ftp->21，因此可以开启两个终端，一一对应一下程序所对应的端口号）
2. 然后可以通过"lsof -i:$PORT"查看应用该端口的程序（$PORT指对应的端口号）。或者你也可以查看文件/etc/services，从里面可以找出端口所对应的服务。
（注：有些端口通过netstat查不出来，更可靠的方法是"sudo nmap -sT -O localhost"）
3. 若要关闭某个端口，则可以：
1)通过iptables工具将该端口禁掉，如：
"sudo iptables -A INPUT -p tcp --dport $PORT -j DROP"
"sudo iptables -A OUTPUT -p tcp --dport $PORT -j DROP"
2)或者关掉对应的应用程序，则端口就自然关闭了，如：
"kill -9 PID" (PID：进程号)
如：    通过"netstat -anp | grep ssh"
有显示：    tcp 0 127.0.0.1:2121 0.0.0.0:* LISTEN 7546/ssh
则：    "kill -9 7546"

（可通过"chkconfig"查看系统服务的开启状态）

** [[http://www.cnblogs.com/benio/archive/2010/09/15/1826728.html][Linux查看程序端口占用情况]]

今天发现服务器上Tomcat 8080端口起不来，老提示端口已经被占用。

使用命令：

ps -aux | grep tomcat

发现并没有8080端口的Tomcat进程。

使用命令：netstat --apn

查看所有的进程和端口使用情况。发现下面的进程列表，其中最后一栏是PID/Program
name

[[http://www.blogjava.net/images/blogjava_net/hankchen/WindowsLiveWriter/Linux_7E54/clip_image002_2.jpg][[[http://www.blogjava.net/images/blogjava_net/hankchen/WindowsLiveWriter/Linux_7E54/clip_image002_thumb.jpg]]]]

发现8080端口被PID为9658的Java进程占用。

进一步使用命令：ps -aux | grep java，或者直接：ps -aux | grep pid 查看

[[http://www.blogjava.net/images/blogjava_net/hankchen/WindowsLiveWriter/Linux_7E54/clip_image004_2.jpg][[[http://www.blogjava.net/images/blogjava_net/hankchen/WindowsLiveWriter/Linux_7E54/clip_image004_thumb.jpg]]]]

就可以明确知道8080端口是被哪个程序占用了！然后判断是否使用KILL命令干掉！


方法二：直接使用 netstat   -anp   |   grep portno
即：netstat --apn | grep 8080

** [[http://www.ibm.com/developerworks/cn/linux/l-roadmap/part8/][ Windows 到 Linux 之旅: 第 8 部分. 备份与恢复]]

/Linux 备份与恢复速成指南/

IBM 电子商务架构师 Chris Walden 将通过他在 developerWorks
上发表的九篇系列文章来指导您如何在 Linux 环境中运用您的 Windows
操作技巧。本部分将考察 Linux
系统上的内容，同时在考虑到恢复和安全的情况下，计划并实现常规备份。

[[#authorN1001C][Chris Walden]]
([[mailto:cmwalden@us.ibm.com?subject=第%208%20部分.%20备份与恢复][cmwalden@us.ibm.com]]),
电子商务架构师

[[#close][关闭 [x]]]

Chris Walden 是德克萨斯州奥斯汀的 IBM Developer Relations Technical
Consulting（也称为
/[[http://www.ibm.com/developerworks/linux/library/i-slayers.html?S_TACT=105AGX52&S_CMP=cn-a-l][dragonslayers]]/）的一名电子商务架构师，该公司为
IBM 商业伙伴提供教育、实现和咨询。他致力于 Linux
相关工作，一有机会就向身边的人宣传 Linux
的种种好处。除了完成他的架构师的职责之外，他还精通 Linux
基础设施服务器的各个领域，包括混合平台用户环境下的文件、打印以及其他应用服务等。Chris
有 10 年的计算机行业经验，从现场支持到 Web
应用开发和顾问，各个领域他都曾涉足。您可以通过电子邮件
[[mailto:cmwalden@us.ibm.com][cmwalden@us.ibm.com]] 与 Chris 联系。




2004 年 1 月 01 日

-  [[#toggle][[[//www.ibm.com/i/c.gif]]]]内容

   -  [[#IDAULSY][确定策略]]
   -  [[#IDACMSY][确定要备份的内容]]
   -  [[#IDAPNSY][备份工具]]
   -  [[#IDA0VOY][dump 和 restore]]
   -  [[#IDAYXOY][使用 dump 执行备份]]
   -  [[#IDAC0OY][使用 restore 来执行还原]]
   -  [[#IDAC3OY][dump 与 tar]]
   -  [[#IDAB4OY][其他工具]]
   -  [[#IDAG5OY][商业化备份产品]]
   -  [[#IDAEBPY][前瞻和回顾]]
   -  [[#resources][参考资料]]
   -  [[#icomments][评论]]

Linux
是一个稳定而可靠的环境。但是任何计算系统都有无法预料的事件，比如硬件故障。拥有关键配置信息的可靠备份是任何负责任的管理计划的组成部分。在
Linux
中可以通过各种各样的方法来执行备份。所涉及的技术从非常简单的脚本驱动的方法，到精心设计的商业化软件。备份可以保存到远程网络设备、磁带驱动器和其他可移动媒体上。备份可以是基于文件的或基于驱动器映像的。可用的选项很多，您可以混合搭配这些技术，为您的环境设计理想的备份计划。

*** 确定策略

可以采用许多不同的方法来备份系统。欲了解关于这方面的一些信息，您可以阅读本文结尾处
[[#resources][参考资料]] 中列出的“Introduction to Backing Up and
Restoring Data”一文。

所备份的内容很大程度上取决于您备份它们的理由。您是否试图从严重的故障（比如硬盘驱动器问题）中恢复？您是否想归档以便能在需要时恢复旧的文件？您计划从一个冷系统和还原着手，还是从一个预加载的备用系统着手？

--------------

[[#ibm-pcon][回页首]]

*** 确定要备份的内容

在备份和还原系统时，Linux 基于文件的性质成了一个极大的优点。在 Windows
系统中，注册表与系统是非常相关的。配置和软件安装不仅仅是将文件放到系统上。因此，还原系统就需要有能够处理
Windows 这种特性的软件。在 Linux
中，情况就不一样了。配置文件是基于文本的，并且除了直接处理硬件时以外，它们在很大程度上是与系统无关的。硬件驱动程序的现代方法是，使它们以动态加载的模块的形式可用，这样内核就变得更加与系统无关。不同于让备份必须处理操作系统如何安装到系统和硬件上的复杂细节，Linux
备份处理的是文件的打包和解包。

一般情况下，以下这些目录是需要备份的：

-  */etc*

   包含所有核心配置文件。这其中包括网络配置、系统名称、防火墙规则、用户、组，以及其他全局系统项。
-  */var*
    包含系统守护进程（服务）所使用的信息，包括 DNS 配置、DHCP
   租期、邮件缓冲文件、HTTP 服务器文件、db2 实例配置，等等。
-  */home*

   包含所有用户的默认用户主目录。这包括他们的个人设置、已下载的文件和用户不希望失去的其他信息。
-  */root*
    是根（root）用户的主目录。
-  */opt*
    是安装许多非系统文件的地方。IBM 软件就安装在这里。OpenOffice、JDK
   和其他软件在默认情况下也安装在这里。

有些目录是应该考虑 /不/备份的。

-  */proc*

   应该永远不要备份这个目录。它不是一个真实的文件系统，而是运行内核和环境的虚拟化视图。它包括诸如
   /proc/kcore
   这样的文件，这个文件是整个运行内存的虚拟视图。备份这些文件只是在浪费资源。
-  */dev*
    包含硬件设备的文件表示。如果计划还原到一个空白的系统，那就可以备份
   /dev。然而，如果计划还原到一个已安装的 Linux 系统，那么备份 /dev
   是没有必要的。

其他目录包含系统文件和已安装的包。在服务器环境中，这其中的许多信息都不是自定义的。大多数自定义都发生在
/etc 和/home 目录中。不过出于完整性的考虑，您可能希望备份它们。

在生产环境中，我希望确保数据不会丢失，因而我会备份除 /proc
目录之外的整个系统。如果最担心用户和配置，我会仅备份 /etc、/var、/home
和 /root 目录。

--------------

[[#ibm-pcon][回页首]]

*** 备份工具

正如前面提到过的， Linux
备份在很大程度上就是打包和解包文件。这允许使用现有的系统实用工具和脚本来执行备份，而不必购买商业化的软件包。在许多情况下，这类备份将是足够的，并且为管理员提供了极大的控制能力。备份脚本可以使用
=cron= 命令来自动化，这个命令控制 Linux 中预定的事件。

**** tar

=tar= 是一个已移植到 Linux 中的经典 UNIX 命令。 =tar= 是 *t*ape
*ar*chive（磁带归档）的缩写，最初设计用于将文件打包到磁带上。如果您下载过
Linux 源代码，或许已经碰到过 tar
文件。这是一个基于文件的命令，它本质上是连续地、首尾相连地堆放文件。

使用 =tar=
可以打包整个目录树，这使得它特别适合用于备份。归档文件可以全部还原，或从中展开单独的文件和目录。备份可以保存到基于文件的设备或磁带设备上。文件可以在还原时重定向，以便将它们重新放到一个与最初保存它们的目录（或系统）不同的目录（或系统）。
=tar= 是与文件系统无关的。它可以使用在 ext2、ext3、 jfs、Reiser
和其他文件系统上。

使用 =tar= 非常类似于使用诸如 PKZip
这样的文件实用工具。只需将它指向一个目的（可以是文件或设备），然后指定您想要打包的文件。您可以通过标准的压缩类型来动态压缩归档文件，或指定一个自己选择的外部压缩程序。要通过
bzip2 压缩或解压缩文件，可使用 = tar -z= 命令。

要使用 = tar= 来把除 /proc 目录之外的整个文件系统备份到 SCSI 磁带设备：

#+BEGIN_EXAMPLE
    tar -cpf /dev/st0 / --exclude=/proc
#+END_EXAMPLE

在上面的例子中， =-c= 开关表示归档文件正在被创建。 =-p=
开关表示我们希望保留文件许可权限，这对良好的备份来说是很关键的。 =-f=
开关指向该归档文件的文件名。在本例中，我们使用的是原始磁带设备
/dev/st0。/
表示我们想要备份的内容。既然我们想要备份整个系统，因此把这个开关指定为根（root）。当把
=tar= 指向一个目录（以 / 结尾）时，它会自动递归。最后，我们排除了 /proc
目录，因为它没有包含需要保存的任何内容。如果单盒磁带容纳不下这个备份，我们需要添加
=-M= 开关（本例中没有显示）以进行多卷备份。

*** 以防万一

不要忘了 Linux 是区分大小写的。例如， =tar=
命令应该总是以小写的形式执行。命令行开关可以是大写、小写或大小写的混合。例如，
=-t= 和 =-T=
执行不同的功能。文件或目录名称可以混合使用大小写，而且就像命令和命令行开关一样，是区分大小写的。

要还原一个或多个文件，可以使用带提取开关（ =-x= ）的 =tar= 命令：

#+BEGIN_EXAMPLE
    tar -xpf /dev/st0 -C /
#+END_EXAMPLE

这里的 =-f= 开关同样指向归档文件， =-p= 开关表明我们想要还原归档的权限。
=-x= 开关表明从归档中提取文件。 =-C /= 表明我们想要让还原从 / 开始。
=tar= 通常还原到运行这个命令的目录。 =-C= 开关使我们的当前目录不再相关。

您可能会经常使用的另外两个 =tar= 命令是 =-t= 和 =-d= 开关。 =-t=
开关列出某个归档文件的内容。 =-d=
开关将归档文件的内容与系统上的当前文件作比较。

为便于操作和编辑，您可以将想要归档的文件和目录放进一个文本文件中，然后在命令行通过
=-T=
开关引用这个文本文件。这些文件和目录可以与命令行上列出的其他目录结合起来。下面的命令行备份
MyFiles 中列出的所有文件和目录、/ 根目录和 /tmp 目录中的所有 iso 文件。

#+BEGIN_EXAMPLE
    tar -cpf /dev/st0 -T MyFiles /root /tmp/*.iso
#+END_EXAMPLE

文件列表只是一个文本文件，其中列出文件或目录。下面是一个例子：

#+BEGIN_EXAMPLE
    /etc


    /var


    /home


    /usr/local


    /opt
#+END_EXAMPLE

请注意 =tar -T= （或 =files-from=
）命令不能接受通配符。文件必须明确地列出。上面的例子展示了一种单独地引用文件的方法。您还可以执行脚本来搜索系统，然后建立一个列表。下面就是这样一个脚本的例子：

#+BEGIN_EXAMPLE
    #!/bin/sh


    cat MyFiles > TempList


    find /usr/share -iname *.png >> TempList


    find /tmp -iname *.iso >> TempList


    tar -cpzMf /dev/st0 -T TempList
#+END_EXAMPLE

上面的脚本首先将 MyFiles 中的所有现有文件列表复制到
TempList。然后它执行两个 =find=
命令来搜索文件系统中匹配某个模式的文件，并将它们附加到
TempList。第一次是搜索 /usr/share 目录树中以 =.png=
结尾的所有文件。第二次是搜索 /tmp 目录树中以 =.iso=
结尾的所有文件。在建立好列表之后， =tar= 然后在文件设备 /dev/st0
（第一个 SCSI 磁带设备）上创建 一个新的归档文件，该文件使用 g *z*ip
格式来压缩，并保留所有文件权限。该归档文件将跨越多个卷。要归档的文件的名称将从
TempList 文件中提取。

还可以使用脚本来执行更精细的操作，比如增量备份。Gerhard Mourani 在他的
/Securing and Optimizing Linux/
一书中给出了一个优秀的脚本，您可在本文结尾处的
[[#resources][参考资料]]中找到关于这本书的信息。

也可以编写脚本来还原文件，虽然还原通常是手动进行的。正如上面提到过的，用于提取文件的
=-x= 开关代替了 =-c=
开关。可以还原整个归档文件，或者还原指定的个别文件或者目录。使用通配符来引用归档文件中的文件是可以的。还可以使用开关来转储和还原。

--------------

[[#ibm-pcon][回页首]]

*** dump 和 restore

=dump= 可以执行类似 =tar= 的功能。然而， =dump=
倾向于考虑文件系统而不是个别的文件。下面是引自 dump
手册文件中的内容：“dump 检查 ext2
文件系统上的文件，并确定哪些文件需要备份。这些文件将出于安全保护而被复制到给定的磁盘、磁带或其他存储媒体上......大于输出媒体容量的转储将被划分到多个卷。在大多数媒体上，容量是通过一直写入直至返回一个
end-of-media 标记来确定的。”

配合 =dump= 的程序是 =restore= ，它用于从转储映像还原文件。

=restore=
命令执行转储的逆向功能。可以首先还原文件系统的完全备份，而后续的增量备份可以在已还原的完全备份之上覆盖。可以从完全或部分备份中还原单独的文件或者目录树。

=dump= 和 =restore=
都能在网络上运行，因此您可以通过远程设备进行备份或还原。 =dump= 和
=restore= 使用磁带驱动器和提供广泛选项的文件设备。然而，两者都仅限用于
ext2 和 ext3 文件系统。如果使用的是 JFS、Reiser
或者其他文件系统，您将需要其他的实用工具，比如 =tar= 。

--------------

[[#ibm-pcon][回页首]]

*** 使用 dump 执行备份

使用 =dump= 执行备份是相当简单的。下面的命令执行一个完全 Linux
备份，它把所有 ext2 和 ext3 文件系统备份到一个 SCSI 磁带设备。

#+BEGIN_EXAMPLE
    dump 0f /dev/nst0 /boot


    dump 0f /dev/nst0 /
#+END_EXAMPLE

在这个例子中，系统中有两个文件系统。一个用于 /boot，另一个用于 */*
，这是常见的配置。它们必须在执行备份时单独地引用。 /dev/nst0 引用第一个
SCSI
磁带驱动器，不过是以非重绕的模式引用。这样确保各个卷在磁带上一个接一个地排列。

=dump= 的一个有趣特性是其内置的增量备份功能。在上面的例子中， *0* 表示 0
级或基本级备份。这是完全系统备份，您要定期执行以保存整个系统。对于后续的备份，您可以使用其他数字（1-9）来代替
0，以改变备份级别。1 级备份会保存自从执行 0
级备份以来更改过的所有文件。2 级备份会保存自从执行 1
级备份以来更改过的所有文件，以此类推。使用 =tar=
和脚本可以执行相同的功能，但要求脚本创建人员提供一种机制来确定上次备份是何时执行的。
=dump=
具有它自己的机制，即它在执行备份时会输出一个更新文件（/etc/dumpupdates）。这个更新文件将在每次执行
0 级备份时被重设。后续级别的备份会保留它们的标记，直至执行另一次 0
级备份。如果您在执行基于磁带的备份， =dump= 会自动跟踪多个卷。

*** 跳过文件

标记将被 =dump= 跳过的文件和目录是可以做到的。实现此目的的命令是
=chattr= ，它改变 ext2 和 ext3 文件系统上的扩展属性。

chattr +d <filename>

上面的命令向文件添加一个标记，让 =dump= 在执行备份时跳过该文件。

--------------

[[#ibm-pcon][回页首]]

*** 使用 restore 来执行还原

要还原使用 =dump= 保存的信息，可以使用 =restore= 命令。像 =tar= 一样，
=dump= 能够列出（ =-t= ）归档文件的内容，并与当前文件作比较（ =-C=
）。使用 =dump=
時必须小心的地方是还原数据。有两种非常不同的还原方法，您必须使用正确的方法才能获得可预测的结果。

**** 重建 (-r)

记住，在设计 =dump=
时考虑得更多的是文件系统，而不是单独的文件。因此，存在两种不同的文件还原风格。要重建一个文件系统，可使用
=-r=
命令行开关。设计重建的目的是为了能在空文件系统上操作，并将它还原为已保存的状态。在执行重建之前，您应该已经创建、格式化和装载（mount）了该文件系统。不应该对包含文件的文件系统执行重建。

下面是使用上面执行的转储来执行完全重建的例子。

#+BEGIN_EXAMPLE
    restore -rf /dev/nst0
#+END_EXAMPLE

上面这个命令需要针对要还原的每个文件系统分别执行。

在需要的时候，可以重复这个过程来添加增量备份。

**** 提取 (-x)

如果需要使用单独的文件而不是使用整个文件系统，您必须使用 =-x=
开关来提取它们。例如，要仅从我们的磁带备份中提取 /etc
目录，可使用以下命令：

#+BEGIN_EXAMPLE
    restore -xf /dev/nst0 /etc
#+END_EXAMPLE

**** 交互式还原 (-i)

=restore= 提供的另外一个特性是交互式模式。使用命令：

#+BEGIN_EXAMPLE
    restore -if /dev/nst0
#+END_EXAMPLE

将把您置于交互式 shell
中，同时还显示了包含在该归档文件中的项。键入“help”将会显示一个命令列表。然后您就可以浏览并选择希望提取的项。务必记住，您提取的任何文件都将进入当前目录。

--------------

[[#ibm-pcon][回页首]]

*** dump 与 tar

=dump= 和 =tar= 都有一批拥护者。两者都各有优点和缺点。如果您运行的是除
ext2 或 ext3 之外的任何文件系统，那么 =dump=
就对您不可用。然而如果不是这种情况，那么只需最少的脚本就能运行 =dump=
，并且 =dump= 还具有可用于帮助还原的交互式模式。

我倾向于使用 =tar=
，因为我喜欢编写脚本来获得额外的控制级别。此外还有用于操作 .tar
文件的多平台工具。

--------------

[[#ibm-pcon][回页首]]

*** 其他工具

在 Linux
中，任何能够复制文件的程序都可以用来执行某种程度的备份。有人就使用
=cpio= 和 =dd= 来执行备份 。 =cpio= 是又一个与 =tar=
差不多的打包实用工具，但使用得不太普遍。 =dd=
是一个文件系统复制实用工具，它产生文件系统的二进制副本。 =dd =
还可用于产生硬盘驱动器的映像，类似于使用诸如 Symantec 的 Ghost
这样的产品。然而， =dd=
不是基于文件的，因此您只能使用它来将数据还原到完全相同的硬盘驱动器分区。

--------------

[[#ibm-pcon][回页首]]

*** 商业化备份产品

可用于 Linux
的商业化备份产品有很多。商业化产品一般提供了便利的界面和报告系统，而在使用诸如
=dump= 和 =tar=
这样的工具时，您必须自食其力。商业化产品很广泛，通常提供大量的特性。使用商业软件包的最大好处是，有一个预先建立的用于处理备份的策略，您可以立即投入工作。商业化的开发人员已经犯了您即将要犯的许多错误，他们的智慧的代价相比于丢失您的宝贵数据来说是廉价的。

**** Tivoli Storage Manager

Tivoli Storage Manager 或许是现在可用于 Linux
的最好的商业化备份和存储管理实用工具。Tivoli Storage Manager
服务器可运行在多种平台上，包括
Linux，而客户机则可以运行在更多种类的平台上。

本质上，Storage Manager
服务器是通过适合于备份该环境的设备来配置的。要参与备份的任何系统都要加载一个与服务器通信的客户机。备份可以按计划执行、通过
Tivoli Storage Manager 客户机界面手动执行，或者使用基于 Web
的界面远程执行。

TSM
基于策略的性质意味着无需经常调整文件列表，就能够为备份行为定义中心规则。此外，IBM
Tivoli Storage Resource Manager
还能够识别、评估、控制和预测企业存储资产的利用情况，能够检测潜在的问题并自动应用自修复调整。更多细节请参见
Tivoli Web 站点（参见 [[#resources][参考资料]]中的链接）。

****** 图 1. Tivoli Storage Manager 菜单

[[tivsm0.jpg]]

然后备份和还原就通过远程设备来处理 *。*

****** 图 2. Tivoli Storage Manager 界面

[[tivsm1.jpg]]

--------------

[[#ibm-pcon][回页首]]

*** 前瞻和回顾

拥有良好备份的第一步是拥有计划。首先知道您需要保存的数据以及需要什么恢复策略，然后使用最适合该策略的工具。

Linux 附带了一些现成的（out of the box）有用备份工具。其中两个最常用的是
=tar= 和 =dump/restore=
。两者都能执行完全系统备份。使用创造性的脚本，您能够设计一个自定义的方案来本地和远程地备份系统。

然而，编写自己的备份脚本可能是一项繁重的任务，对于复杂的企业来说更是如此。诸如
Tivoli Storage Manager
这样的商业化软件降低了学习难度，并允许您立即控制自己的备份，但是您可能必须调整自己的策略来适应这些工具的功能。

*** 参考资料

-  您可以参阅本文在 developerWorks 全球站点上的
   [[http://www.ibm.com/developerworks/library/l-roadmap8/index.html?S_TACT=105AGX52&S_CMP=cn-a-l][英文原文]].
-  阅读 [[/developerworks/cn/linux/l-roadmap/index.html][Windows 到
   Linux 之旅系列文章]]的其他部分（ /developerWorks/，2003 年 11 月）。
-  [[http://www.seifried.org/lasg/backups/][Linux Administrator's
   Security Guide]]是一个安全指南，其中有一个非常优秀的小节讨论了 Linux
   备份和恢复实践。
-  [[http://www.tldp.org/REF/INTRO/Backup-INTRO/index.html][Introduction
   to Backing Up and Restoring
   Data]]是一篇与操作系统或系统体系结构无关的概述。作者在本文中探讨了备份技术以及如何为备份制定计划。
-  [[http://www.tldp.org/LDP/lame/LAME/linux-admin-made-easy/index.html][Linux
   Administration Made Easy]]是一篇较旧的参考资料，但是仍然有用，因为
   Linux 的一般过程和技术仍然保持一致。
-  [[http://www.tldp.org/LDP/sag/index.html][The Linux System
   Administrator's Guide]]为初学者介绍了 Linux 系统的系统管理。
-  /Securing and Optimizing Linux - A Hands on Guide/ (Red Hat Edition)
   一书的
   [[http://pierre.mit.edu/compfac/linux/Securing-Optimizing-Linux-RH-Edition-v%201.3/backup-rest.html][第
   7 章“备份和还原”]]是另一份不错的指南，其中包括一个脚本，用于执行基于
   =tar= 的增量备份。
-  [[http://www.taobackup.com/][The TAO of
   Backup]]是对备份哲学的有趣展示，以哲学的形式呈现出来。虽然它和一款商业化的产品相关，但是这段信息写得非常好。
-  IBM /developerWorks/教程“
   [[http://www.ibm.com/developerworks/cn/views/linux/tutorials.jsp?cv_doc_id=84954][Linux
   机器备份]]”指导您完成创建和贯彻备份策略的过程。
-  在 CD 上存储数据和其他内容很容易：在 IBM /developerWorks/文章“
   [[/developerworks/cn/linux/l-cdburn/index.html][在 Linux 上烧录
   CD]]”中学习如何做到这点。
-  如果正在从 Windows 环境转换到 Linux 环境，您还需要阅读
   [[/developerworks/cn/linux/l-faq/index.html][Linux 用户技术 FAQ]]。
-  The Tivoli Storage Manager 被评为
   [[http://www.linuxjournal.com/article.php?sid=6678][LinuxWorld 2003
   最佳存储解决方案]]。从 IBM 站点的 Linux 专区了解更多关于
   [[http://www.ibm.com/linux/solutions/tivolistormanaglinuxsolution.shtml][Tivoli
   Storage Manager for Linux]]的信息。
-  [[http://www.ibm.com/software/tivoli/][Tivoli 产品页]] 包含关于
   Tivoli 的更多信息，包括安全和隐私特性。
-  “Linux 文档计划”中
   [[http://tldp.org/LDP/intro-linux/html/sect_03_04.html][/Introduction
   to Linux/的第 3 章]]讨论了文件权限和安全。
-  在 /developerWorks/Linux 专区可以找到更多
   [[/developerworks/cn/linux/index.html][为 Linux
   开发者准备的参考资料]]。

** [[http://www.ibm.com/developerworks/cn/linux/l-ipc/][深刻理解Linux进程间通信（IPC）]]

一个大型的应用系统，往往需要众多进程协作，进程（Linux进程概念见附1）间通信的重要性显而易见。本系列文章阐述了Linux环境下的几种主要进程间通信手段，并针对每个通信手段关键技术环节给出详细实例。为达到阐明问题的目的，本文还对某些通信手段的内部实现机制进行了分析。

[[#authorN10017][郑彦兴]]
([[mailto:mlinux@163.com?subject=深刻理解Linux进程间通信（IPC）][mlinux@163.com]])国防科大计算机学院

[[#close][关闭 [x]]]

郑彦兴，男，现攻读国防科大计算机学院网络方向博士学位。您可以通过电子邮件
[[mailto:mlinux@163.com?cc=][mlinux@163.com]]和他联系。




2002 年 12 月 11 日

-  [[#toggle][[[//www.ibm.com/i/c.gif]]]]内容

   -  [[#N1002F][序]]
   -  [[#resources][参考资料]]
   -  [[#icomments][评论]]

*** 序

linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的。而对Unix发展做出重大贡献的两大主力AT&T的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心）在进程间通信方面的侧重点有所不同。前者对Unix早期的进程间通信手段进行了系统的改进和扩充，形成了“system
V
IPC”，通信进程局限在单个计算机内；后者则跳过了该限制，形成了基于套接口（socket）的进程间通信机制。Linux则把两者继承了下来，如图示：

******

[[1.gif]]

其中，最初Unix IPC包括：管道、FIFO、信号；System V IPC包括：System
V消息队列、System V信号灯、System V共享内存区；Posix IPC包括：
Posix消息队列、Posix信号灯、Posix共享内存区。有两点需要简单说明一下：1）由于Unix版本的多样性，电子电气工程协会（IEEE）开发了一个独立的Unix标准，这个新的ANSI
Unix标准被称为计算机环境的可移植性操作系统界面（PSOIX）。现有大部分Unix和流行版本都是遵循POSIX标准的，而Linux从一开始就遵循POSIX标准；2）BSD并不是没有涉足单机内的进程间通信（socket本身就可以用于单机内的进程间通信）。事实上，很多Unix版本的单机IPC留有BSD的痕迹，如4.4BSD支持的匿名内存映射、4.3+BSD对可靠信号语义的实现等等。

图一给出了linux
所支持的各种IPC手段，在本文接下来的讨论中，为了避免概念上的混淆，在尽可能少提及Unix的各个版本的情况下，所有问题的讨论最终都会归结到Linux环境下的进程间通信上来。并且，对于Linux所支持通信手段的不同实现版本（如对于共享内存来说，有Posix共享内存区以及System
V共享内存区两个实现版本），将主要介绍Posix API。

linux下进程间通信的几种主要手段简介：

1. 管道（Pipe）及有名管道（named
   pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
2. 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；
3. 报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system
   V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
5. 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
6. 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System
   V的变种都支持套接字。

下面将对上述通信机制做具体阐述。

附1：参考文献[2]中对linux环境下的进程进行了概括说明：

一般来说，linux下的进程包含以下几个关键要素：

-  有一段可执行程序；
-  有专用的系统堆栈空间；
-  内核中有它的控制块（进程控制块），描述进程所占用的资源，这样，进程才能接受内核的调度；
-  具有独立的存储空间

进程和线程有时候并不完全区分，而往往根据上下文理解其含义。

*** 参考资料

-  UNIX环境高级编程，作者：W.Richard
   Stevens，译者：尤晋元等，机械工业出版社。具有丰富的编程实例，以及关键函数伴随Unix的发展历程。
-  linux内核源代码情景分析（上、下），毛德操、胡希明著，浙江大学出版社，提供了对linux内核非常好的分析，同时，对一些关键概念的背景进行了详细的说明。
-  UNIX网络编程第二卷：进程间通信，作者：W.Richard
   Stevens，译者：杨继张，清华大学出版社。一本比较全面阐述Unix环境下进程间通信的书（没有信号和套接口，套接口在第一卷中）。

** [[http://www.cnblogs.com/dolphinX/p/3460545.html][简单理解Socket]]

**** 题外话

前几天和朋友聊天，朋友问我怎么最近不写博客了，一个是因为最近在忙着公司使用的一些控件的开发，浏览器兼容性搞死人；但主要是因为这段时间一直在看html5的东西，看到web
socket时觉得很有意思，动手写几个demo，但web
socket需要特定的服务器支持，由于标准制定工作还没完成，所以没有多少主流的服务器支持，自己在网上下载了几个实现，包括php的、C#的、甚至Node.js的，但一个是协议变化比较大，很多代码已经过时了，再就是有一些支持最新的标准，但是我想稍微改造一下，看人家源代码的时候云里雾里，看看别人的代码行数也不多，决定自己实现一个。

悲剧由此开始，虽然哥们儿国内非知名工科大学毕业，但好歹也是科班CS出身，但大学得过且过，什么TCP/IP协议，什么socket了都没概念。为了做出一个简单的支持广播的websocket
server，在网上找了很多相关代码，左抄一句，右抄一句，弄了一个星期竟然还是漏洞百出，调试不起来，只好从头来过了，先补一些基本知识，然后再一步步根据原理实现，今天终于实现了绝大部分功能，由此真的感受到了，搞计算机必须得有理论指导实践，否则只能像个没头苍蝇到处乱撞。

**** TCP/IP

要想理解socket首先得熟悉一下TCP/IP协议族， TCP/IP（Transmission Control
Protocol/Internet
Protocol）即传输控制协议/网间协议，定义了主机如何连入因特网及数据如何再它们之间传输的标准，

从字面意思来看TCP/IP是TCP和IP协议的合称，但实际上TCP/IP协议是指因特网整个TCP/IP协议族。不同于ISO模型的七个分层，TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中

应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等

传输层：TCP，UDP

网络层：IP，ICMP，OSPF，EIGRP，IGMP

数据链路层：SLIP，CSLIP，PPP，MTU

每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的

[[http://images.cnitblog.com/blog/349217/201312/05230830-04807bb739954461a8bfc7513707f253.jpg]]
[[http://images.cnitblog.com/blog/349217/201312/05230857-f49d5855f1e14a23a186737e0bec8a0f.gif]]

估计有兴趣打开此文的同学都对此有一定了解了，加上我也是一知半解，所以就不详细解释，有兴趣同学可以上网上搜一下资料

[[http://zh.wikipedia.org/wiki/TCP/IP][维基百科]][[http://zh.wikipedia.org/wiki/TCP/IP][
]]

[[http://baike.baidu.com/link?url=KJleEWJUBxe3XaxEaTU1lcQrg9qYN7FYzuPhoWVyoPFNk79NIURxAO6HSWC1MfrCU1Dh7QRsNDWOaZ-4bg5HRa][百度百科]]

在TCP/IP协议中两个因特网主机通过两个路由器和对应的层连接。各主机上的应用通过一些数据通道相互执行读取操作

[[http://images.cnitblog.com/blog/349217/201312/05221430-6bd4ce2a2cf7434ca9216c0a5b6a0985.png]]

**** socket

我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。

能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。

[[http://images.cnitblog.com/blog/349217/201312/05225723-2ffa89aad91f46099afa530ef8660b20.jpg]]

socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种"打开---读/写---关闭"模式的实现，服务器和客户端各自维护一个"文件"，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。

**** socket通信流程

socket是"打开---读/写---关闭"模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的

[[http://images.cnitblog.com/blog/349217/201312/05232335-fb19fc7527e944d4845ef40831da4ec2.png]]

服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket

服务器为socket绑定ip地址和端口号

服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开

客户端创建socket

客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket

服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入*阻塞*状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求

客户端连接成功，向服务器发送连接状态信息

服务器accept方法返回，连接成功

客户端向socket写入信息

服务器读取信息

客户端关闭

服务器端关闭

**** 三次握手

在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接

[[http://images.cnitblog.com/blog/349217/201312/05234233-eed6ddcba93c42be8847e98d6da62802.jpg]]

第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号/*Synchronize
Sequence Numbers*/），syn=j，客户端进入SYN_SEND状态等待服务器确认

第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态

第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手

定睛一看，服务器socket与客户端socket建立连接的部分其实就是大名鼎鼎的三次握手

[[http://images.cnitblog.com/blog/349217/201312/05234946-b80841921eae4d2ab983f26ed9023768.png]]

 *socket编程API*

前面提到socket是"打开---读/写---关闭"模式的实现，简单了解一下socket提供了哪些API供应用程序使用，还是以TCP协议为例，看看Unix下的socket
API，其它语言都很类似（PHP甚至名字都几乎一样），这里我就简单解释一下方法作用和参数，具体使用有兴趣同学可以看看博客参考中的链接或者上网搜索

#+BEGIN_EXAMPLE
    int socket(int domain, int type, int protocol);
#+END_EXAMPLE

根据指定的地址族、数据类型和协议来分配一个socket的描述字及其所用的资源。

domain:协议族，常用的有AF_INET、AF_INET6、AF_LOCAL、AF_ROUTE其中AF_INET代表使用ipv4地址

type:socket类型，常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等

protocol:协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等

#+BEGIN_EXAMPLE
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_EXAMPLE

把一个地址族中的特定地址赋给socket

sockfd:socket描述字，也就是socket引用

addr:要绑定给sockfd的协议地址

addrlen:地址的长度

/通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。/

#+BEGIN_EXAMPLE
    int listen(int sockfd, int backlog);
#+END_EXAMPLE

监听socket

sockfd:要监听的socket描述字

backlog:相应socket可以排队的最大连接个数

#+BEGIN_EXAMPLE
    int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_EXAMPLE

连接某个socket

sockfd:客户端的socket描述字

addr:服务器的socket地址

addrlen:socket地址的长度

#+BEGIN_EXAMPLE
    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
#+END_EXAMPLE

 TCP服务器监听到客户端请求之后，调用accept()函数取接收请求

sockfd:服务器的socket描述字

addr:客户端的socket地址

addrlen:socket地址的长度

#+BEGIN_EXAMPLE
    ssize_t read(int fd, void *buf, size_t count);
#+END_EXAMPLE

读取socket内容

fd:socket描述字

buf：缓冲区

count：缓冲区长度

#+BEGIN_EXAMPLE
    ssize_t write(int fd, const void *buf, size_t count);
#+END_EXAMPLE

向socket写入内容，其实就是发送内容

fd:socket描述字

buf：缓冲区

count：缓冲区长度

#+BEGIN_EXAMPLE
    int close(int fd);
#+END_EXAMPLE

socket标记为以关闭
，使相应socket描述字的引用计数-1，当引用计数为0的时候，触发TCP客户端向服务器发送终止连接请求。

**** 参考

[[http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html][Linux
Socket编程（不限Linux）]]

[[http://goodcandle.cnblogs.com/archive/2005/12/10/294652.aspx][揭开Socket编程的面纱
]]

PS.
有同学看完后发现没有demo示例，参考中的示例已经很不错了，我就不班门弄斧了，而且我用C#实现了一个websocket
server，接下来的博客中会有介绍。另外由于刚刚实际接触socket，文中谬误较多，还望大家批评指正，文章内容主要参考上面两个博文，图片全部来源于网络，在百度图片搜索得来，无法注明第一源地址，如有版权问题请站内信联系，第一时间处理。

** [[http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html][Linux Socket 编程（不限Linux）]]

2010-12-12 21:58 by 吴秦, ... 阅读, ... 评论, [[#][收藏]],
[[http://i.cnblogs.com/EditPosts.aspx?postid=1903949][编辑]]

“一切皆Socket！”

话虽些许夸张，但是事实也是，现在的网络编程几乎都是用的socket。

------有感于实际编程和开源项目研究。

我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket的基本函数，这些都是本文想介绍的。本文的主要内容如下：

-  1、网络中进程之间如何通信？
-  2、Socket是什么？
-  3、socket的基本操作

   -  3.1、socket()函数
   -  3.2、bind()函数
   -  3.3、listen()、connect()函数
   -  3.4、accept()函数
   -  3.5、read()、write()函数等
   -  3.6、close()函数

-  4、socket中TCP的三次握手建立连接详解
-  5、socket中TCP的四次握手释放连接详解
-  6、一个例子（实践一下）
-  7、留下一个问题，欢迎大家回帖回答！！！

*** 1、网络中进程之间如何通信？

本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：

-  消息传递（管道、FIFO、消息队列）
-  同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）
-  共享内存（匿名的和具名的）
-  远程过程调用（Solaris门和Sun RPC）

但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“*ip地址*”可以唯一标识网络中的主机，而传输层的“*协议+端口*”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。

使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX
BSD的套接字（socket）和UNIX System
V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。

*** 2、什么是Socket？

上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open
--> 读写write/read -->
关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。

#+BEGIN_QUOTE
  *** socket一词的起源

  在组网领域的首次使用是在1970年2月12日发布的文献[[http://datatracker.ietf.org/doc/rfc33/][IETF
  RFC33]]中发现的，撰写者为Stephen Carr、Steve Crocker和Vint
  Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”
#+END_QUOTE

*** 3、socket的基本操作

既然socket是“open---write/read---close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。

**** 3.1、socket()函数

#+BEGIN_EXAMPLE
    int socket(int domain, int type, int protocol);
#+END_EXAMPLE

socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而*socket()*用于创建一个socket描述符（socket
descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。

正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：

-  domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。
-  type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。
-  protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。

注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。

当我们调用*socket*创建一个socket时，返回的socket描述字它存在于协议族（address
family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。

**** 3.2、bind()函数

正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。

#+BEGIN_EXAMPLE
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_EXAMPLE

函数的三个参数分别为：

-  sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。
-  addr：一个const struct sockaddr
   *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：

   #+BEGIN_EXAMPLE
       struct sockaddr_in {
           sa_family_t    sin_family; /* address family: AF_INET */
           in_port_t      sin_port;   /* port in network byte order */
           struct in_addr sin_addr;   /* internet address */
       };

       /* Internet address. */
       struct in_addr {
           uint32_t       s_addr;     /* address in network byte order */
       };
   #+END_EXAMPLE

   ipv6对应的是：

   #+BEGIN_EXAMPLE
       struct sockaddr_in6 {
           sa_family_t     sin6_family;   /* AF_INET6 */
           in_port_t       sin6_port;     /* port number */
           uint32_t        sin6_flowinfo; /* IPv6 flow information */
           struct in6_addr sin6_addr;     /* IPv6 address */
           uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */
       };

       struct in6_addr {
           unsigned char   s6_addr[16];   /* IPv6 address */
       };
   #+END_EXAMPLE

   Unix域对应的是：

   #+BEGIN_EXAMPLE
       #define UNIX_PATH_MAX    108

       struct sockaddr_un {
           sa_family_t sun_family;               /* AF_UNIX */
           char        sun_path[UNIX_PATH_MAX];  /* pathname */
       };
   #+END_EXAMPLE

-  addrlen：对应的是地址的长度。

通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。

#+BEGIN_QUOTE
  *** 网络字节序与主机字节序

  *主机字节序*就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：

  　　a)
  Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。

  　　b)
  Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。

  *网络字节序*：4个字节的32
  bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。*由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。*字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。

  所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。
#+END_QUOTE

**** 3.3、listen()、connect()函数

如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。

#+BEGIN_EXAMPLE
    int listen(int sockfd, int backlog);
    int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_EXAMPLE

listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。

connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。

**** 3.4、accept()函数

TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。

#+BEGIN_EXAMPLE
    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
#+END_EXAMPLE

accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct
sockaddr
*的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。

注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。

**** 3.5、read()、write()等函数

万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：

-  read()/write()
-  recv()/send()
-  readv()/writev()
-  recvmsg()/sendmsg()
-  recvfrom()/sendto()

我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：

#+BEGIN_EXAMPLE
           #include <unistd.h>

           ssize_t read(int fd, void *buf, size_t count);
           ssize_t write(int fd, const void *buf, size_t count);

           #include <sys/types.h>
           #include <sys/socket.h>

           ssize_t send(int sockfd, const void *buf, size_t len, int flags);
           ssize_t recv(int sockfd, void *buf, size_t len, int flags);

           ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                          const struct sockaddr *dest_addr, socklen_t addrlen);
           ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                            struct sockaddr *src_addr, socklen_t *addrlen);

           ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
           ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
#+END_EXAMPLE

read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。

write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。
在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。

其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。

**** 3.6、close()函数

在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。

#+BEGIN_EXAMPLE
    #include <unistd.h>
    int close(int fd);
#+END_EXAMPLE

close一个TCP
socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。

注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。

*** 4、socket中TCP的三次握手建立连接详解

我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：

-  客户端向服务器发送一个SYN J
-  服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1
-  客户端再想服务器发一个确认ACK K+1

只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：

[[http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png][[[http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157476286.png]]]]

图1、socket中发送的TCP三次握手

从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN
J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN
J包，调用accept函数接收请求向客户端发送SYN K ，ACK
J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK
J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK
K+1时，accept返回，至此三次握手完毕，连接建立。

#+BEGIN_QUOTE
  总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。
#+END_QUOTE

*** 5、socket中TCP的四次握手释放连接详解

上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：

[[http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png][[[http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157494693.png]]]]

图2、socket中发送的TCP四次握手

图示过程如下：

-  某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；
-  另一端接收到FIN
   M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；
-  一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN
   N；
-  接收到这个FIN的源发送端TCP对它进行确认。

这样每个方向上都有一个FIN和ACK。

*** 6、一个例子（实践一下）

说了这么多了，动手实践一下。下面编写一个简单的服务器、客户端（使用TCP）------服务器端一直监听本机的6666号端口，如果收到连接请求，将接收请求并接收客户端发来的消息；客户端与服务器端建立连接并发送一条消息。

服务器端代码：

[[http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif]][[http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif]]服务器端

#+BEGIN_EXAMPLE
    #include<stdio.h>#include<stdlib.h>#include<string.h>#include<errno.h>#include<sys/types.h>#include<sys/socket.h>#include<netinet/in.h>#define MAXLINE 4096int main(int argc, char** argv){    int    listenfd, connfd;    struct sockaddr_in     servaddr;    char    buff[4096];    int     n;    if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ){    printf("create socket error: %s(errno: %d)\n",strerror(errno),errno);    exit(0);    }    memset(&servaddr, 0, sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);    servaddr.sin_port = htons(6666);    if( bind(listenfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) == -1){    printf("bind socket error: %s(errno: %d)\n",strerror(errno),errno);    exit(0);    }    if( listen(listenfd, 10) == -1){    printf("listen socket error: %s(errno: %d)\n",strerror(errno),errno);    exit(0);    }    printf("======waiting for client's request======\n");    while(1){    if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1){        printf("accept socket error: %s(errno: %d)",strerror(errno),errno);        continue;    }    n = recv(connfd, buff, MAXLINE, 0);    buff[n] = '\0';    printf("recv msg from client: %s\n", buff);    close(connfd);    }    close(listenfd);}
#+END_EXAMPLE

客户端代码：

[[http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif]][[http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif]]客户端

#+BEGIN_EXAMPLE
    #include<stdio.h>#include<stdlib.h>#include<string.h>#include<errno.h>#include<sys/types.h>#include<sys/socket.h>#include<netinet/in.h>#define MAXLINE 4096int main(int argc, char** argv){    int    sockfd, n;    char    recvline[4096], sendline[4096];    struct sockaddr_in    servaddr;    if( argc != 2){    printf("usage: ./client <ipaddress>\n");    exit(0);    }    if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){    printf("create socket error: %s(errno: %d)\n", strerror(errno),errno);    exit(0);    }    memset(&servaddr, 0, sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_port = htons(6666);    if( inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0){    printf("inet_pton error for %s\n",argv[1]);    exit(0);    }    if( connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0){    printf("connect error: %s(errno: %d)\n",strerror(errno),errno);    exit(0);    }    printf("send msg to server: \n");    fgets(sendline, 4096, stdin);    if( send(sockfd, sendline, strlen(sendline), 0) < 0)    {    printf("send msg error: %s(errno: %d)\n", strerror(errno), errno);    exit(0);    }    close(sockfd);    exit(0);}
#+END_EXAMPLE

当然上面的代码很简单，也有很多缺点，这就只是简单的演示socket的基本函数使用。其实不管有多复杂的网络程序，都使用的这些基本函数。上面的服务器使用的是迭代模式的，即只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力是很弱的，现实中的服务器都需要有并发处理能力！为了需要并发处理，服务器需要fork()一个新的进程或者线程去处理请求等。

*** 7、动动手

留下一个问题，欢迎大家回帖回答！！！是否熟悉Linux下网络编程？如熟悉，编写如下程序完成如下功能：

服务器端：

接收地址192.168.100.2的客户端信息，如信息为“Client
Query”，则打印“Receive Query”

客户端：

向地址192.168.100.168的服务器端顺序发送信息“Client Query test”，“Cleint
Query”，“Client Query Quit”，然后退出。

题目中出现的ip地址可以根据实际情况定。

------本文只是介绍了简单的socket编程。

更为复杂的需要自己继续深入。

***** [[http://www.cnblogs.com/skynet/archive/2010/12/04/1881236.html][（unix
domain
socket）使用udp发送>=128K的消息会报ENOBUFS的错误]]（一个实际socket编程中遇到的问题，希望对你有帮助）

** [[http://ditaa.sourceforge.net/#download][DIagrams Through Ascii Art]]


ditaa is a small command-line utility written in Java, that can convert
diagrams drawn using ascii art ('drawings' that contain characters that
resemble lines like =| / - =), into proper bitmap graphics. This is best
illustrated by the following example -- which also illustrates the
benefits of using ditaa in comparison to other methods :)

| #+BEGIN_EXAMPLE                               | After conversion using ditaa, the above file becomes:\\   |
|         +--------+   +-------+    +-------+   | [[images/first.png]]                                      |
|         |        | --+ ditaa +--> |       |   |                                                           |
|         |  Text  |   +-------+    |diagram|   |                                                           |
|         |Document|   |!magic!|    |       |   |                                                           |
|         |     {d}|   |       |    |       |   |                                                           |
|         +---+----+   +-------+    +-------+   |                                                           |
|             :                         ^       |                                                           |
|             |       Lots of work      |       |                                                           |
|             +-------------------------+       |                                                           |
| #+END_EXAMPLE                                 |                                                           |


ditaa interprets ascci art as a series of open and closed shapes, but it
also uses special markup syntax to increase the possibilities of shapes
and symbols that can be rendered.

ditaa is open source and free software (/free/ as in free speech), since
it is released under the GPL license.

**** BUT WHY? Does this thing have any /real/ use?

There are several reasons why I did this:

1. Simply for *hack value*. I wanted to know if/how it could be done and
   how easily.
2. *Aesthetic reasons and legacy formats:* there are several old FAQs
   with ascii diagrams lying out there. At this time and age ascii
   diagrams make my eyes hurt due to their ugliness. ditaa can be used
   to convert them to something nicer. Although ditaa would not be able
   to convert all of them (due to differences in drawing 'style' in each
   case), it could prove useful in the effort of modernising some of
   those documents without too much effort. I also know a lot of people
   that can make an ascii diagram easily, but when it gets to using a
   diagram program, they don't do very well. Maybe this utility could
   help them make good-looking diagrams easily/quickly.
3. *Embedding diagrams to text-only formats:* There is a number of
   formats that are text-based (html, docbook, LaTeX, programming
   language comments), but when rendered by other software (browsers,
   interpreters, the javadoc tool etc), they can contain images as part
   of their content. If ditaa was intergrated with those tools (and I'm
   planning to do the javadoc bit myself soon), then you would have
   readable/editable diagrams within the text format itself, something
   that would make things much easier. ditaa syntax can currently be
   embedded to [[#html_mode][HTML]].
4. *Reusability of "code":* Suppose you make a diagram in ascii art and
   you render it with version 0.6b of ditaa. You keep the ascii diagram,
   and then version 0.8 comes out, which features some new cool effects.
   You re-render your old diagram with the new version of ditaa, and it
   looks better, with zero effort! In that sense ditaa is a diagram
   markup language, with very loose syntax.

*** Download

(((-[[#intro][intro]]-))) (((-[[#download][download]]-)))
(((-[[#usage][usage and syntax]]-))) (((-[[#friends][friends]]-)))
(((-[[#contact][contact]]-)))

The latest version of ditaa can be obtained from its
[[http://sourceforge.net/projects/ditaa/][SourceForge project page]].

You can checkout the code using:

 =svn co https://ditaa.svn.sourceforge.net/svnroot/ditaa ditaa=

You can also [[http://ditaa.svn.sourceforge.net/viewvc/ditaa/][browse
the code online]].

*** Usage and syntax

(((-[[#intro][intro]]-))) (((-[[#download][download]]-)))
(((-[[#usage][usage and syntax]]-))) (((-[[#friends][friends]]-)))
(((-[[#contact][contact]]-)))

**** Command line

You need the latest Java runtimes (JRE) to use ditaa. The best
anti-aliasing can be achieved using Java 1.5 or higher.

To start from the command line, type (where XXX is the version number):

#+BEGIN_EXAMPLE
    java -jar ditaaXXX.jar
#+END_EXAMPLE

You will be presented with the command-line options help:

#+BEGIN_EXAMPLE
     -A,--no-antialias          Turns anti-aliasing off.
     -d,--debug                 Renders the debug grid over the resulting
                                image.
     -E,--no-separation         Prevents the separation of common edges of
                                shapes. You can see the difference below:
#+END_EXAMPLE

| #+BEGIN_EXAMPLE                | Before processing        |
|     +---------+                | Common edge\\            |
|     | cBLU    |                | separation (default)     |
|     |         |                | No separation\\          |
|     |    +----+                | (with the =-E= option)   |
|     |    |cPNK|                |                          |
|     |    |    |                |                          |
|     +----+----+                |                          |
|                                |                          |
| #+END_EXAMPLE                  |                          |
|                                |                          |
| [[images/separation.png]]      |                          |
| [[images/no_separation.png]]   |                          |

#+BEGIN_EXAMPLE
     -e,--encoding <ENCODING>   The encoding of the input file.
     -h,--html                  In this case the input is an HTML file. The
                                contents of the <pre class="textdiagram"> tags
                                are rendered as diagrams and saved in the
                                images directory and a new HTML file is
                                produced with the appropriate <img> tags.
                                See the HTML section.
        --help                  Prints usage help.
     -o,--overwrite             If the filename of the destination image
                                already exists, an alternative name is chosen.
                                If the overwrite option is selected, the image
                                file is instead overwriten.
     -r,--round-corners         Causes all corners to be rendered as round
                                corners.
     -s,--scale <SCALE>         A natural number that determines the size of
                                the rendered image. The units are fractions of
                                the default size (2.5 renders 1.5 times bigger
                                than the default).
     -S,--no-shadows            Turns off the drop-shadow effect.
     -t,--tabs <TABS>           Tabs are normally interpreted as 8 spaces but
                                it is possible to change that using this
                                option. It is not advisable to use tabs in
                                your diagrams.
     -v,--verbose               Makes ditaa more verbose.
#+END_EXAMPLE

***** Syntax

****** Round corners

If you use / and \ to connect corners, they are rendered as round
corners:

| #+BEGIN_EXAMPLE               | Before processing   |
|     /--+                      | Rendered            |
|     |  |                      |                     |
|     +--/                      |                     |
|                               |                     |
| #+END_EXAMPLE                 |                     |
|                               |                     |
| [[images/round_corner.png]]   |                     |

****** Color

Color codes can be used to add color to the diagrams. The syntax of
color codes is

#+BEGIN_EXAMPLE
    cXXX
#+END_EXAMPLE

where XXX is a hex number. The first digit of the number represents the
red compoment of the color, the second digit represents green and the
third blue (good ol' RGB). See below for an example of use of color
codes:

| #+BEGIN_EXAMPLE        | Before processing   |
|     /----\ /----\      | Rendered            |
|     |c33F| |cC02|      |                     |
|     |    | |    |      |                     |
|     \----/ \----/      |                     |
|                        |                     |
|     /----\ /----\      |                     |
|     |c1FF| |c1AB|      |                     |
|     |    | |    |      |                     |
|     \----/ \----/      |                     |
|                        |                     |
| #+END_EXAMPLE          |                     |
|                        |                     |
| [[images/color.png]]   |                     |

This can become a bit tedious after a while, so there are (only some for
now) human readable color codes provided:

| #+BEGIN_EXAMPLE                     | Before processing   |
|     Color codes                     | Rendered            |
|     /-------------+-------------\   |                     |
|     |cRED RED     |cBLU BLU     |   |                     |
|     +-------------+-------------+   |                     |
|     |cGRE GRE     |cPNK PNK     |   |                     |
|     +-------------+-------------+   |                     |
|     |cBLK BLK     |cYEL YEL     |   |                     |
|     \-------------+-------------/   |                     |
| #+END_EXAMPLE                       |                     |
|                                     |                     |
| [[images/color_codes.png]]          |                     |

As you can see above, if a colored shape contains any text, the color of
the text is adjusted according to the underlying color. If the undelying
color is dark, the text color is changed to white (from the default
black).

Note that color codes only apply if they are within closed shapes, and
they have no effect anywhere outside.

****** Tags

ditaa recognises some tags that change the way a rectangular shape is
rendered. All tags are between { and }. See the table below:

Name

Original

Rendered

Comment

Document

#+BEGIN_EXAMPLE
    +-----+
    |{d}  |
    |     |
    |     |
    +-----+

#+END_EXAMPLE

[[images/document.png]]

Symbol representing a document.

Storage

#+BEGIN_EXAMPLE
    +-----+
    |{s}  |
    |     |
    |     |
    +-----+

#+END_EXAMPLE

[[images/storage.png]]

Symbol representing a form of storage,
like a database or a hard disk.

Input/Output

#+BEGIN_EXAMPLE
    +-----+
    |{io} |
    |     |
    |     |
    +-----+

#+END_EXAMPLE

[[images/io.png]]

Symbol representing input/output.

****** Dashed lines

Any lines that contain either at least one *=* (for horizontal lines) or
at least one *:* (for vertical lines) are rendered as dashed lines. Only
one of those characters can make a whole line dashed, so this feature
"spreads". The rationale behind that is that you only have to change one
character to switch from normal to dashed (and vice versa), rather than
redrawing the whole line/shape. Special symbols (like document or
storage symbols) can also be dashed. See below:

| #+BEGIN_EXAMPLE              | Before processing   |
|     ----+  /----\  +----+    | Rendered            |
|         :  |    |  :    |    |                     |
|         |  |    |  |{s} |    |                     |
|         v  \-=--+  +----+    |                     |
| #+END_EXAMPLE                |                     |
|                              |                     |
| [[images/dashed_demo.png]]   |                     |

****** Point markers

If *** is encountered on a line (but not at the end of the line), it is
rendered as a special marker, called the point marker (this feature is
still experimental). See below:

| #+BEGIN_EXAMPLE               | Before processing   |
|     *----*                    | Rendered            |
|     |    |      /--*          |                     |
|     *    *      |             |                     |
|     |    |  -*--+             |                     |
|     *----*                    |                     |
| #+END_EXAMPLE                 |                     |
|                               |                     |
| [[images/point_marker.png]]   |                     |

****** Text handling

(This section is still being written)

If the pattern ' o XXXXX' is encountered, where XXXXX is any text, the
'o' is interpreted and rendered as a bullet point. Note that there must
be a space before the 'o' as well as after it. See below:

| #+BEGIN_EXAMPLE           | Before processing   |
|     /-----------------\   | Rendered            |
|     | Things to do    |   |                     |
|     | cGRE            |   |                     |
|     | o Cut the grass |   |                     |
|     | o Buy jam       |   |                     |
|     | o Fix car       |   |                     |
|     | o Make website  |   |                     |
|     \-----------------/   |                     |
| #+END_EXAMPLE             |                     |
|                           |                     |
| [[images/bullet.png]]     |                     |

****** HTML mode

When ditaa is run using the =--html= option, the input is an HTML file.
The contents of the =<pre     class="textdiagram">= tags are rendered as
diagrams and saved in the =images= directory and a new HTML file is
produced with the appropriate =<img>= tags.

If the =id= parameter is present in the =<pre>= tag, its value is used
as the filename of the rendered png. Otherwise a filename of the form
=ditaa_diagram_X.png= is used, where X is a number. Similarly, if there
is no output filename specified, the converted html file is named in the
form of =xxxx_processed.html=, where xxxx is the filename of the
original file.

In this mode, files that exist are not generated again, they are just
skipped. You can force overwrite of the files using the =--overwrite=
option.

**** Friends and relatives

(((-[[#intro][intro]]-))) (((-[[#download][download]]-)))
(((-[[#usage][usage and syntax]]-))) (((-[[#friends][friends]]-)))
(((-[[#contact][contact]]-)))

Here is a list of projects that are related to ditaa and add to its
functionality:

-  Mikael Brännström's
   [[http://ditaa-addons.sourceforge.net/][ditaa-addons]] offers two
   very interesting pieces of functionality: The =Textdiagram= Javadoc
   taglet allows you to embedd ascii diagrams to Java comments and have
   them rendered as ditaa diagrams in the HTML output. The Ditaa Eps
   program allows you to render to EPS instead of PNG.
-  Mathieu Lecarme's [[http://github.com/athoune/Ditaa-web/][ditaa-web]]
   allows you to install ditaa on your web server and use it as a
   webservice through a HTTP POST request.
-  Bill Baker's [[http://ditaa.org/][ditaa.org]] allows you to run ditaa
   from the web.
-  ditaa comes bundled within [[http://orgmode.org/][org-mode]], a major
   mode for emacs.
   [[http://doc.norang.ca/org-mode.html#sec-13.1][Here's]] an example of
   how you can use it.
-  There is a [[http://www.dokuwiki.org/plugin:ditaa][plugin]] for
   [[http://www.dokuwiki.org][DocuWiki]] that allows you to render ditaa
   diagrams in the wiki pages. Written by Dennis Ploeger.

Here's a list of projects that are somehow related to ditaa, and could
prove useful/relevant while using it:

-  Nadim Khemir's [[http://search.cpan.org/dist/App-Asciio/][asciio]]
   could be used for producing the ascii diagrams more easily. It would
   require some modifications to its default settings for the diagrams
   to render properly (specifically the characters used for corners
   should all be set to =+=). Here is a
   [[http://www.youtube.com/watch?v=IiOHYNHo_Nw][screencast]] of how
   asciio works.
-  Markus Gebhard's [[http://www.jave.de/][JavE]] could be used for the
   same purpose, although I've never tried it.
-  If you make sure to keep the lines straight,
   [[http://www.cinsk.org/emacs/emacs-artist.html][artist-mode]] for
   emacs can be used to produce ditaa-compatible diagrams.

** [[http://www.cnblogs.com/bayonetxxx/archive/2010/12/07/1898489.html][sudo apt-get 和dpkg命令大全]]

一、APT的使用（Ubuntu Linux软件包管理工具一）
apt-cache search # ------(package 搜索包)
apt-cache show #------(package 获取包的相关信息，如说明、大小、版本等)
sudo apt-get install # ------(package 安装包)
sudo apt-get install # -----(package - - reinstall 重新安装包)
sudo apt-get -f install # -----(强制安装?#"-f = --fix-missing"当是修复安
装吧...)
sudo apt-get remove #-----(package 删除包)
sudo apt-get remove - - purge # ------(package 删除包，包括删除配置文件
等)
sudo apt-get autoremove --purge # ----(package 删除包及其依赖的软件包+配置文件等（只对6.10有效，强烈推荐）)
sudo apt-get update #------更新源
sudo apt-get upgrade #------更新已安装的包
sudo apt-get dist-upgrade # ---------升级系统
sudo apt-get dselect-upgrade #------使用 dselect 升级
apt-cache depends #-------(package 了解使用依赖)
apt-cache rdepends # ------(package 了解某个具体的依赖?#当是查看该包被哪些包依赖吧...)
sudo apt-get build-dep # ------(package 安装相关的编译环境)
apt-get source #------(package 下载该包的源代码)
sudo apt-get clean && sudo apt-get autoclean # --------清理下载文件的存
档 && 只清理过时的包
sudo apt-get check #-------检查是否有损坏的依赖


apt-get install 的用法
apt-get install <package>
下载 <package> 以及所有倚赖的包裹,同时进行包裹的安装或升级.如果某个包裹被设置了 hold (停止标志,就会被搁在一边(即不会被升级).更多 hold 细节请看下面.

apt-get remove [--purge] <package>
移除 <package> 以及任何倚赖这个包裹的其它包裹.--purge 指明这个包裹应该被完全清除 (purged) ,更多信息请看 dpkg -P .

apt-get update
升级来自 Debian 镜像的包裹列表,如果你想安装当天的任何软件,至少每天运行一次,而且每次修改了
/etc/apt/sources.list 后,必须执行.

apt-get upgrade [-u]
升级所以已经安装的包裹为最新可用版本.不会安装新的或移除老的包裹.如果一个包改变了倚赖关系而需要安装一个新的包裹,那么它将不会被升级,而是标志为 hold .apt-get update 不会升级被标志为 hold 的包裹 (这个也就是 hold 的意思).请看下文如何手动设置包裹为 hold .我建议同时使用 '-u' 选项,因为这样你就能看到哪些包裹将会被升级.

apt-get dist-upgrade [-u]
和 apt-get upgrade 类似,除了 dist-upgrade 会安装和移除包裹来满足倚赖关系.因此具有一定的危险性.

apt-cache search <pattern>
搜索满足 <pattern> 的包裹和描述.

apt-cache show <package>
显示 <package> 的完整的描述.

apt-cache showpkg <package>
显示 <package> 许多细节,以及和其它包裹的关系.

dselect, console-apt, aptitude, gnome-apt,是APT 的几个图形前端(其中一些在使用前得先安装).这里 dselect 无疑是最强大的,也是最古老,最难驾驭.

－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－

二、 DPKG的 用法（Ubuntu Linux软件包管理工具二）
dpkg -i <package.deb>
安装一个 Debian 包裹文件;如你手动下载的文件.

dpkg -c <package.deb>
列出 <package.deb> 的内容.

dpkg -I <package.deb>
从 <package.deb> 中提取包裹信息.

dpkg -r <package>
移除一个已安装的包裹.

dpkg -P <package>
完全清除一个已安装的包裹.和 remove 不同的是, remove 只是删掉数据和可执行
文件, purge 另外还删除所有的配制文件.

dpkg -L <package>
列出 <package> 安装的所有文件清单.同时请看 dpkg -c 来检查一个 .deb 文件
的内容.

dpkg -s <package>
显示已安装包裹的信息.同时请看 apt-cache 显示 Debian 存档中的包裹信息,以
及 dpkg -I 来显示从一个
.deb 文件中提取的包裹信息.

dpkg-reconfigure <package>
重新配制一个已经安装的包裹,如果它使用的是 debconf (debconf 为包裹安装提
供了一个统一的配制界面).你能够重新配制 debconf 它本身,如你想改变它的前端
或提问的优先权.例如,重新配制 debconf ,使用一个 dialog 前端,简单运行:

dpkg-reconfigure --frontend=dialog debconf (如果你安装时选错了,这里可以
改回来哟

echo "<package> hold" | dpkg --set-selections
设置 <package> 的状态为 hlod (命令行方式)

dpkg --get-selections "<package>"
取的 <package> 的当前状态 (命令行方式)

支持通配符,如:
Debian:~# dpkg --get-selections *wine*




备注：

－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－例如:
大家现在用的都是 gaim-0.58 + QQ-plugin,为了防止 gaim 被升级,我们可以采用
如下方法:

方法一:
Debian:~# echo "gaim hold" | dpkg --set-selections
然后用下面命令检查一下:
Debian:~# dpkg --get-selections "gaim"
gaim hold
现在的状态标志是 hold,就不能被升级了.

如果想恢复怎么办呢?
Debian:~# echo "gaim install" | dpkg --set-selections
Debian:~# dpkg --get-selections "gaim"
gaim install
这时状态标志又被重置为 install,可以继续升级了.

同志们会问,哪个这些状态标志都写在哪个文件中呢?
在 /var/lib/dpkg/status 里,你也可以通过修改这个文件实现 hold.

有时你会发现有的软件状态标志是 purge,不要奇怪.
如:事先已经安装了 amsn, 然后把它卸了.
apt-get remove --purge amsn
那么状态标志就从 install 变成 purge.

方法二:
在/etc/apt 下手动建一个 preferences 文件
内容：
Package: gaim
Pin: version 0.58*
保存
更详细内容请看:
http://linuxsir.com/bbs/showthread....&threadid=22601

dpkg -S <file>
在包裹数据库中查找 <file>,并告诉你哪个包裹包含了这个文件.(注:查找的是事
先已经安装的包裹)

从源码建立deb packages

apt-get source [-b] <package>
下载一个源码的包并解开。
你必须在你的/etc/apt/sources.list文件里写入一条 deb-src 的记录才能完成这
项工作。
如果你输入了一个-b参数，并且是以root的身份，deb包会被自动的创建。

apt-get build-dep <package>
自动下载并安装通过源码创建 <package> 时需要的包。
只有apt 0.5以上版本才支持这个功能。
现在woody和以上版本包含了这个功能。
如果你使有一个旧版本的apt，查找依赖性最简单的方法是查看源码包中
debian/control 这个文件，
注意这个路径是相对的，是包内的路径。

普通的用法，结合 apt-get source -b,例子 (as root)：

apt-get build-dep <package>
apt-get source -b <package>

会下载源码包，建立依赖性，然后尝试编译源码。

dpkg-source -x <package.dsc>
如果你手工下载了一个程序的源码包，其中包含了几个类
似 .orig.tar.gz , .dsc ,
以及 .diff.gz 之类的文件，
那么你就可以对 .dsc 文件使用这个命令来 unpack 源码包。

dpkg-buildpackage
从 Debian 源码树建立一个deb包。你必须在source tree的主目录才能生效。例
如：

dpkg-buildpackage -rfakeroot -uc -b

这里 '-rfakeroot' 指定命令使用 fakeroot 程序来模仿 root 权限 (来实现所有
者(ownership)目的)，
'-uc' 表示 "Don't cryptographically sign the changelog", '-b' 代表只建立
二进制包.

debuild
一个快速打包脚本类似 dpkg-buildpackage ,能自动的识别是否使用 fakeroot,
同时为你运行 lintian 和 gpg

修正倚赖关系

dpkg --configure --pending
如果dpkg在apt-get install upgrade dist-uptradeing 的时候出错退出，
尝试使用此命令来配置已经unpack的包。
然后再用 apt-get install ，upgrade, or dist-upgrade -f ，
然后再用 apt-get install, upgrade, or dist-upgrade.

可能会重复多次，这样通常可以解决大多数的依赖性问题。
(同时,如果提示由于某种原因需要某个特定的包裹,你可以常识安装或卸载这个包)

apt-get install -f
apt-get upgrade -f
apt-get dist-upgrade -f
尝试修正上述过程中出现依赖性关系
注意 apt-get install -f 不需要 <package> 作为参数。



－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
用apt-cdrom -d /media/cdrom0 add 加载光驱，

/dev/hdc /cdrom iso9660 user,noauto 0 0
用编辑器修改一下存盘，重启，应该可以了。
然后，apt-cdrom -d /cdrom add
apt-get install (你要装的软件名：《例如gcc》)
gcc相关的软件会自动装入。
昨天，刚试过，很爽。
注意：apt不会认你手动挂载的光驱，如果fstab中设置不对apt不会正常工作。

用apt-cdrom -d /media/cdrom0 add 加载光驱，
需要使用#mkdir /media/cdrom0 否则会错误提示说“无法读取文件系统挂载
点/media/cdrom的状态 -stat(2 没有那个文件或目录)”

** [[http://www.cnblogs.com/sld666666/archive/2010/06/25/1765510.html][利用Graphviz画结构图]]

*** 1. Graphviz介绍

  Graphviz是大名鼎鼎的贝尔实验室的几位牛人开发的一个画图工具。

它的理念和一般的“所见即所得”的画图工具不一样，是“所想即所得”。

Graphviz提供了dot语言来编写绘图脚本。什么？！画个图也需要一个语言！！

不要急，dot语言是非常简单地，只要看了下面几个列子，就能使用了。



*** 2. Graphviz的几个例子


下面的几个例子都来自于官方文档。详情请见：[[http://www.graphviz.org/][Graphviz官网]].

**** 2.1 Fancy graph

#+BEGIN_EXAMPLE
     digraph G{

        size = "4, 4";//图片大小
        main[shape=box];/*形状*/

        main->parse;
        parse->execute;

        main->init[style = dotted];//虚线

        main->cleanup;

        execute->{make_string; printf}//连接两个

        init->make_string;

        edge[color = red]; // 连接线的颜色

        main->printf[style=bold, label="100 times"];//线的 label

        make_string[label = "make a\nstring"]// \n, 这个node的label，注意和上一行的区别

        node[shape = box, style = filled, color = ".7.3 1.0"];//一个node的属性

        execute->compare;
    }
#+END_EXAMPLE

从上面的代码可以看出，dot语言非常简单，就是一个纯描述性的语言而已。

大家可以把上面的代码和下图中的连接对应起来看。


[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/1.png][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/1_thumb.png]]]]

  <图1. Fancy graph>



**** 2.2 Polygon graph

#+BEGIN_EXAMPLE
     digraph G{
        size = "4, 4"
        a->b->c;
        b->d;

        a[shape = polygon, sides = 5, peripheries=3, color = lightblue, style = filled];
        //我的形状是多边形，有五条边，3条边框， 颜色的淡蓝色， 样式为填充
        c[shape = polygon, sides = 4, skew= 0.4, lable = "hello world"];
        //我的形状是4变形， 角的弯曲度0.4, 里面的内容为"hello world"
        d[shape = invtriange];
        //我是三角形
        e[shape = polygon, side = 4, distortion = .7];
        //我是梯形啊
    }
#+END_EXAMPLE





下面是对应的图片：


[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/polygon_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/polygon_thumb.jpg]]]]

#+BEGIN_QUOTE
    <图2. Polygon graph>
#+END_QUOTE

**** 2.3 连接点的方向

  我们可以用“n”,”ne”,”e”,””se”, “sw”,”w”,”nw”,

分别表示冲哪一个方向连接这个节点（图形）-“north, northeast......”

如：

#+BEGIN_EXAMPLE
     digraph G{
        //b->c[tailport = se];
        b->c:se;
    }
#+END_EXAMPLE





#+BEGIN_QUOTE

  [[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/se_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/se_thumb.jpg]]]]

    <图3. Se graph>


#+END_QUOTE

**** 2.4 数据结构图

  数据结构图是我们很容易用到的一类图形，一个简单地数据结构图代码如下：

#+BEGIN_EXAMPLE
     digraph g{
        node [shape = record,height=.1//我定义了我下面的样式;
        node0[label = "<f0> |<f1> G|<f2> "];
        //我是一个node,我有三个属性，第二个的名字为G，其他两个为空
            node1[label = "<f0> |<f1> E|<f2> "];
           node2[label = "<f0> |<f1> B|<f2> "];
           node3[label = "<f0> |<f1> F|<f2> "];
           node4[label = "<f0> |<f1> R|<f2> "];
           node5[label = "<f0> |<f1> H|<f2> "];
           node6[label = "<f0> |<f1> Y|<f2> "];
           node7[label = "<f0> |<f1> A|<f2> "];
           node8[label = "<f0> |<f1> C|<f2> "];

        "node0": f2->"node4":f1;
        //我的第三个属性连到node4的第二个属性
        "node0": f0->"node1":f1;
        "node1": f0->"node2":f1;
        "node1": f2->"node3":f1;
        "node2": f2->"node8":f1;
        "node2": f0->"node7":f1;
        "node4": f2->"node6":f1;
        "node4": f0->"node5":f1;
    }
#+END_EXAMPLE






[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/data_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/data_thumb.jpg]]]]

  <图4. Data graph>

**** 2.5 Hash table graph

#+BEGIN_EXAMPLE
     digraph g {
        nodesep = .05;
        rankdir = LR;

        node[shape = record, width = .1, height = .1];

        node0[label = "<f0> |<f1> |<f2> |<f3> |<f4> |<f5> |<f6> |", height = 2.5];
        //我是一个节点，我有7个属性
        node [width = 1.5];
        node1[label = "{<n> n14 | 719 |<p>}"];
        //我还是一个节点， 也定义了三个属性
        node2[label = "{<n> a1 | 719 |<p>}"];
        node3[label = "{<n> i9 | 512 |<p>}"];
        node4[label = "{<n> e5 | 632 |<p>}"];
        node5[label = "{<n> t20 | 959 |<p>}"];
        node6[label = "{<n> o15 | 794 |<p>}"];
        node7[label = "{<n> s19 | 659 |<p>}"];

        //好了，我开始连接了
        node0:f0->node1:n;
        node0:f1->node2:n;
        node0:f2->node3:n;
        node0:f5->node4:n;
        node0:f6->node5:n;
        node2:p->node6:n;
        node4:p->node7:n;
    }
#+END_EXAMPLE



这是一个简单地哈希表，如下图所示


[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/Hash_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/Hash_thumb.jpg]]]]

  <图5. Hash
table graph>





**** 2.6 Process grahp

下面画一个轻量级的流程图。

#+BEGIN_EXAMPLE
     digraph g {
        subgraph cluster0 {
            //我是一个子图，subgraph定义了我，
            node[style = filled, color = white];
            //我之内的节点都是这种样式
            style = filled;
            //我的样式是填充
            color = lightgrey;
            //我的颜色
            a0->a1->a2->a3;
            label = "prcess #1"
            //我的标题
        }

        subgraph cluster1 {
            //我也是一个子图
            node[style = filled];
            b0->b1->b2->b3;
            label = "process #2";
            color = blue;
        }

        //定义完毕之后，下面还是连接了
        start->a0;
        start->b0;
        a1->b3;
        b2->a3;
        a3->end;
        b3->end;

        start[shape=Mdiamond];
        end[shape=Msquare];
    }
#+END_EXAMPLE







结果输出图形如下：


[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/Process_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/Process_thumb.jpg]]]]

  <图6. Hash table graph>



*** 3. 小结


相信这几个列子下来，各位看官对graphviz也有了了解了吧，我个人用了一遍下来发现太爽了。

而对于dot语言，作为一个描述性的语言就非常简单了，
只要有编程基础的人，模仿几个列子下来

应该就能应用了。

** [[http://manpages.ubuntu.com/manpages/hardy/man1/pdfoutline.1.html][Ubuntu Manpage: pdfoutline - add outlines (aka bookmarks) to PDF files]]

**** *NAME*

#+BEGIN_EXAMPLE
           pdfoutline - add outlines (aka bookmarks) to PDF files
#+END_EXAMPLE

**** *SYNOPSIS*

#+BEGIN_EXAMPLE
           pdfoutline input.pdf outlines.txt output.pdf
#+END_EXAMPLE

**** *DESCRIPTION*

#+BEGIN_EXAMPLE
           pdfoutline reads input file given as first argument, adds outlines from
           text file given as second argument, and saves result to file with  name
           given as third argument.

           File with outlines information should consist of lines in the following
           format:
                  <level> <page> Outline text

           <level> and <page> should be integers.  Each field should be  separated
           by  exactly one space symbol.  All values for <level> should be greater
           or equal than that of the first line.  Page numeration starts with 1.

           Outlines file can contain comments that start with # in  first  column.
           Comments and empty lines are ignored.
#+END_EXAMPLE

**** *OPTIONS*

#+BEGIN_EXAMPLE
           pdfoutline accepts no options.
#+END_EXAMPLE

**** *EXAMPLES*

#+BEGIN_EXAMPLE
           Here is example of outlines data file:
                  0 1 Document title
                  1 1 Chapter 1
                  2 1 Chapter 1.1
                  2 2 Chapter 1.2
                  1 3 Chapter 2

           Using this file will result in outlines like the following:
                  Document title
                  +-Chapter 1
                  | +-Chapter 1.1
                  | +-Chapter 1.2
                  +-Chapter 2
#+END_EXAMPLE

**** *AUTHOR*

#+BEGIN_EXAMPLE
           pdfoutline author is Eugeniy Meshcheryakov <eugen@debian.org>
           pdfoutline   is   part   of   fntsample   and  can  be  downoaded  from
           <http://sourceforge.net/projects/fntsample>.

                                      2007-10-27                     pdfoutline(1)
#+END_EXAMPLE

** [[http://linux-wiki.cn/wiki/zh-hans/%E8%A1%A5%E4%B8%81(patch)%E7%9A%84%E5%88%B6%E4%BD%9C%E4%B8%8E%E5%BA%94%E7%94%A8][补丁(patch)的制作与应用]]

此页由Linux Wiki用户[[/wiki/User:Chenxing][Chenxing]]于2011年3月27日
(星期日) 18:51的最后更改。

**** 出自Linux Wiki

*提示：*此文已超过 4 年（1762
天）未更新，如发现内容过时或有误，欢迎改进:)

如果hack了开源代码，为了方便分享（如提交Bug）或自己留存使用，一般都要制作一个补丁（Patch）。在从源码安装软件时，也难免要应用些别人做好的补丁。本文介绍如何制作和应用补丁。^{[[#cite_note-0][[1]]]}

[[/wiki/File:Hint.gif][[[/images/7/7d/Hint.gif]]]]

*提示：*
本文目前的多数内容是对《Linux下patch的制作和应用》的修正、整理与重新排版。

| ** 目录                                                                    |
|                                                                            |
| -  [[#.E5.91.BD.E4.BB.A4.E7.AE.80.E4.BB.8B][1 命令简介]]                   |
|                                                                            |
|    -  [[#diff][1.1 diff]]                                                  |
|    -  [[#patch][1.2 patch]]                                                |
|    -  [[#.E5.BA.94.E7.94.A8][1.3 应用]]                                    |
|                                                                            |
| -  [[#patch.E6.96.87.E4.BB.B6.E6.9E.84.E6.88.90][2 patch文件构成]]         |
| -  [[#.E5.AE.9E.E4.BE.8B.E5.88.86.E6.9E.90][3 实例分析]]                   |
|                                                                            |
|    -  [[#.E5.8D.95.E6.96.87.E4.BB.B6.E8.A1.A5.E4.B8.81][3.1 单文件补丁]]   |
|    -  [[#.E6.96.87.E4.BB.B6.E5.A4.B9.E8.A1.A5.E4.B8.81][3.2 文件夹补丁]]   |
|                                                                            |
| -  [[#.E5.8F.82.E8.80.83.E8.B5.84.E6.96.99][4 参考资料]]                   |


*** 命令简介

用到的两个命令是diff和patch。

**** diff

*diff*可以比较两个东西，并可同时记录下二者的区别。制作补丁时的一般用法和常见选项为：

#+BEGIN_EXAMPLE
    diff 【选项】 源文件（夹） 目的文件（夹）
#+END_EXAMPLE

-  -r :: 递归。设置后diff会将两个不同版本源代码目录中的所有对应文件全部都进行一次比较，包括子目录文件。
-  -N :: 选项确保补丁文件将正确地处理已经创建或删除文件的情况。
-  -u :: 输出每个修改前后的3行，也可以用-u5等指定输出更多上下文。
-  -E, -b, -w, -B,
   --strip-trailing-cr :: 忽略各种空白，可参见文档，按需选用。

**** patch

*patch*的作用则是将diff记录的结果（即补丁）应用到相应文件（夹）上。最常见的用法为：

#+BEGIN_EXAMPLE
    patch -pNUM <patchfile>
#+END_EXAMPLE

-  -p Num :: 忽略几层文件夹，随后详解。
-  -E :: 选项说明如果发现了空文件，那么就删除它
-  -R :: 取消打过的补丁。

为了解释 /-p/ 参数，需要看看如下patch文件片段：

#+BEGIN_EXAMPLE
    --- old/modules/pcitable       Mon Sep 27 11:03:56 1999
    +++ new/modules/pcitable       Tue Dec 19 20:05:41 2000
#+END_EXAMPLE

如果使用参数
*-p0*，那就表示从当前目录找一个叫做old的文件夹，再在它下面寻找
/modules/pcitable/ 文件来执行patch操作。
 而如果使用参数
*-p1*，那就表示忽略第一层目录（即不管old），从当前目录寻找 /modules/
的文件夹，再在它下面找pcitable。

**** 应用

利用以上命令，处理单个文件补丁的方法：

#+BEGIN_EXAMPLE
    # 产生补丁
    diff -uN from-file to-file >to-file.patch

    # 打补丁
    patch -p0 < to-file.patch

    # 取消补丁
    patch -RE -p0 < to-file.patch
#+END_EXAMPLE

对整个文件夹打补丁的情况：

#+BEGIN_EXAMPLE
    # 产生补丁
    diff -uNr  from-docu  to-docu  >to-docu.patch

    # 打补丁
    cd to-docu
    patch -p1 < to-docu.patch

    # 取消补丁
    patch -R -p1 <to-docu.patch
#+END_EXAMPLE

另外，使用版本控制工具时，可以直接用/svn diff/或/git diff/生成补丁文件。

值得一提的是，由于应用补丁时的目标代码和生成补丁时的代码未必相同，打补丁操作可能失败。补丁失败的文件会以.rej结尾，下面命令可以找出所有rej文件：

#+BEGIN_EXAMPLE
    find . -name '*.rej'
#+END_EXAMPLE

*** patch文件构成

补丁文件里到底存储了哪些信息呢？看看这个例子：

#+BEGIN_EXAMPLE
    --- test0       2006-08-18 09:12:01.000000000 +0800
    +++ test1       2006-08-18 09:13:09.000000000 +0800
    @@ -1,3 +1,4 @@
    +222222
     111111
    -111111
    +222222
     111111
#+END_EXAMPLE

-  补丁头 :: 补丁头是分别由---/+++开头的两行，用来表示要打补丁的文件。---开头表示旧文件，+++开头表示新文件。
-  一个补丁文件中的多个补丁 :: 一个补丁文件中可能包含以---/+++开头的很多节，每一节用来打一个补丁。所以在一个补丁文件中可以包含好多个补丁。
-  块 :: 块是补丁中要修改的地方。它通常由一部分不用修改的东西开始和结束。他们只是用来表示要修改的位置。他们通常以@@开始，结束于另一个块的开始或者一个新的补丁头。
-  块的缩进 :: 块会缩进一列，而这一列是用来表示这一行是要增加还是要删除的。
-  块的第一列 :: +号表示这一行是要加上的。-号表示这一行是要删除的。没有加号也没有减号表示这里只是引用的而不需要修改。

*** 实例分析

**** 单文件补丁

设当前目录有文件 *test0*：

#+BEGIN_EXAMPLE
    111111
    111111
    111111
#+END_EXAMPLE

和文件*test1*：

#+BEGIN_EXAMPLE
    222222
    111111
    222222
    111111
#+END_EXAMPLE

使用diff创建补丁*test1.patch*

#+BEGIN_EXAMPLE
    diff -uN test0 test1 > test1.patch
#+END_EXAMPLE

因为是单个文件，故不需要 -r 选项。此命令得到如下补丁：

#+BEGIN_EXAMPLE
    --- test0       2006-08-18 09:12:01.000000000 +0800
    +++ test1       2006-08-18 09:13:09.000000000 +0800
    @@ -1,3 +1,4 @@
    +222222
     111111
    -111111
    +222222
     111111
#+END_EXAMPLE

要应用补丁，只需：

#+BEGIN_EXAMPLE
    $ patch -p0 < test1.patch
    patching file test0
#+END_EXAMPLE

此时test0就和test1一样了。

如果要取消补丁做出的更改，恢复旧版本：

#+BEGIN_EXAMPLE
    $ patch -RE -p0 < test1.patch
    patching file test0
#+END_EXAMPLE

**** 文件夹补丁

设有如下环境：

#+BEGIN_EXAMPLE
    --prj0/
         test0
         prj0name
    --prj1/
         test1
         prj1name
#+END_EXAMPLE

/prj0/prj0name/内容为如下三行：

#+BEGIN_EXAMPLE
    --------
    prj0/prj0name
    --------
#+END_EXAMPLE

/prj1/prj1name/内容为如下三行：

#+BEGIN_EXAMPLE
    --------
    prj1/prj1name
    --------
#+END_EXAMPLE

用 /diff -uNr/ 创建补丁，

#+BEGIN_EXAMPLE
    diff -uNr prj0 prj1 > prj1.patch
#+END_EXAMPLE

得到的patch文件为：

#+BEGIN_EXAMPLE
    diff -uNr prj0/prj0name prj1/prj0name
    --- prj0/prj0name       2006-08-18 09:25:11.000000000 +0800
    +++ prj1/prj0name       1970-01-01 08:00:00.000000000 +0800
    @@ -1,3 +0,0 @@
    ---------
    -prj0/prj0name
    ---------
    diff -uNr prj0/prj1name prj1/prj1name
    --- prj0/prj1name       1970-01-01 08:00:00.000000000 +0800
    +++ prj1/prj1name       2006-08-18 09:26:36.000000000 +0800
    @@ -0,0 +1,3 @@
    +---------
    +prj1/prj1name
    +---------
    diff -uNr prj0/test0 prj1/test0
    --- prj0/test0  2006-08-18 09:23:53.000000000 +0800
    +++ prj1/test0  1970-01-01 08:00:00.000000000 +0800
    @@ -1,3 +0,0 @@
    -111111
    -111111
    -111111
    diff -uNr prj0/test1 prj1/test1
    --- prj0/test1  1970-01-01 08:00:00.000000000 +0800
    +++ prj1/test1  2006-08-18 09:26:00.000000000 +0800
    @@ -0,0 +1,4 @@
    +222222
    +111111
    +222222
    +111111
#+END_EXAMPLE

如果要应用此补丁，则：

#+BEGIN_EXAMPLE
    $ ls
    prj0  prj1  prj1.patch
    $ cd prj0
    $ patch -p1 < ../prj1.patch
    patching file prj0name
    patching file prj1name
    patching file test0
    patching file test1
#+END_EXAMPLE

此时可用[[/wiki/Ls][ls]]看到打补丁后的结果：

#+BEGIN_EXAMPLE
    $ ls
    prj1name  test1
#+END_EXAMPLE

类似的，如果要回滚补丁操作：

#+BEGIN_EXAMPLE
    $ patch -R -p1 < ../prj1.patch
    patching file prj0name
    patching file prj1name
    patching file test0
    patching file test1
    $ ls
    prj0name  test0
#+END_EXAMPLE

*** 参考资料

1. [[#cite_ref-0][↑]]
   [[http://www.cublog.cn/u/21948/showart_157145.html][Linux下patch的制作和应用]]

** [[http://tech.sina.com.cn/s/2012-03-16/14166844479.shtml#artibodyTitle][5款替代微软Visio的开源免费软件]]

提到流程图和图表设计，自然会想到微软出品的Office Visio，它是一款强大的流程图设计工具。Visio并不在Office标准套装中，需要额外付费购买，这可能会带来某些不便。一方面，并不是所有人都负担得起，另外，如果是应急之需，临时购买恐怕也来不及了。

今天我们介绍几款免费的Visio替代软件，也许你对某些软件的名字感到陌生，现在我们逐一简要了解一下。

1、DIA Diagram Editor

Dia主界面Dia主界面
Dia被我们列在头一名，不仅是因为它功能强大和跨平台特性，也源于它原生支持简体中文界面。与Visio相比，Dia安装包仅不足20MB，可以放在网盘或U盘中随身携带。初用者可能觉得Dia用法比较繁琐而麻烦，但是无法否认，它仍然是综合性能最佳的免费替代方案。

Dia支持导出的流程图格式如下：EPS、SVG、DXF(Autocad格式)、CGM、WMF、PNG、JPEG、VDX(Microsoft Visio格式)。

优点：跨平台，支持简体中文界面

缺点：不易上手

下载：http://down.tech.sina.com.cn/content/41811.html

2、Open Office Draw

Open Office DrawOpen Office Draw
Linux用户对OpenOffice应该不会陌生，它是大名鼎鼎的开源办公套件，同时支持Windows和Mac。做为办公套件中的一部分，OpenOffice DRAW不仅免费提供，而且具备较为出色和相对完整的结构图表绘制功能，其最大绘图尺寸可达300cm x 300cm。绘图时产生的“对象”可以编组、分组、重组等操作，它也有些高级特性，例如支持渲染自定义贴图和模拟灯光效果，并能输出具备真实光感的高品质图形。OpenOffice DRAW支持大部分常见图像格式，我们还可以通过其内置的图形库获得大量免费图形素材。

优点：跨平台，简单易用

缺点：安装包较大

下载简体便携版：http://down.tech.sina.com.cn/content/37788.html

3、Inkscape

Inkscape主界面Inkscape主界面
又一款开源免费的矢量绘图软件，初看界面很像Photoshop，还是比较容易上手的，加上自带简体中文支持，对国人来说更是方便了。Inkscape支持节点编辑，可绘制复杂的路径和位图描摹。Inkscape比较突出的一大特点就是针对SVG的优化支持，它使用W3C标准的SVG文件格式，提供了众多高级特性，包括标记、克隆、Alpha融合、渐变、贴图，编组等等。

优点：跨平台，支持简体中文界面

缺点：流程图设计方面有待加强

下载：http://down.tech.sina.com.cn/content/16418.html

4、Graphviz

Graphviz绘制的复杂流程图Graphviz绘制的复杂流程图
Graphviz是大名鼎鼎的贝尔实验室的几位牛人开发的一个画图工具，历史比较久远了。它的软件设计理念和一般“所见即所得”的画图工具不一样，是“所想即所得”。Graphviz提供了DOT语言来编写绘图脚本。显然，这款软件并不适合一般用户，只适合那些对脚本语言代码较熟练的用户或是开发人员使用。

优点：使用脚本绘图，功能强大，支持SVG

缺点：无用户界面，不适合普通用户

下载：http://down.tech.sina.com.cn/content/53737.html

5、Kivio

Kivio主界面Kivio主界面
Kivio是开源办公套件KOffice的一部分，是一款强大的Linux图表和流程图绘制软件。它可以帮助你快速设计原型、线框图、流程图或是图表。Kivio有着与微软Visio类似的用户界面，但在用户界面上有所增强，允许使用分割窗格进行图形绘制。比较遗憾的是，Kivio目前只面向Linux用户。

其它功能：

支持使用Python脚本模板创作

与Dia模具兼容

优点：操作简单，界面清晰易懂

缺点：无Windows版本

下载：http://down.tech.sina.com.cn/content/35996.html

** [[][]]

** [[http://www.seanet.com/~hgg9140/comp/diatut/all/all.html][Dia Tutorial]]

Location: http://www.seanet.com/~hgg9140/comp/diatut/all/all.html
                                                      Dia Tuto

                                                    Dia Tutorial

                                                       [[http://www.lysator.liu.se/~alla/dia][Dia]]  [[http://www.gtk.org/][GTK+]]


           1. Copying

           Copyright (c) 2002 Harry George.

           Permission is granted to copy, distribute and/or modify this document under the terms of the
           GNU Free Documentation License, Version 1.1 or any later version published by the Free Software
           Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy
           of the license is included in the section entitled [[http://www.seanet.com/~hgg9140/comp/diatut/COPYING][GNU Free Documentation License]].

           2. Abstract

           This tutorial introduces [[http://www.lysator.liu.se/~alla/dia/][Dia]], the GTK-based GNU diagramming tool. We will install and configure
           the tool, then learn to use the basic shapes, then explore advanced features.

           3. Introduction

           From [[http://www.lysator.liu.se/~alla/dia/][Dia home]]:

               Welcome to Dia's homepage. Dia is a gtk+ based diagram creation program released under the
               GPL license.

               Dia is designed to be much like the commercial Windows program 'Visio'. It can be used to
               draw many different kinds of diagrams. It currently has special objects to help draw entity
               relationship diagrams, UML diagrams, flowcharts, network diagrams, and simple circuits. It
               is also possible to add support for new shapes by writing simple XML files, using a subset
               of SVG to draw the shape.

               It can load and save diagrams to a custom XML format (gzipped by default, to save space),
               can export diagrams to EPS or SVG formats and can print diagrams (including ones that span
               multiple pages).

           4. Installation

           See the current version's INSTALL file for requirements.

           To build dia, you need to install (in order):

             * From [[http://www.gtk.org/][GTK]]:
                 + glib
                 + gtk+
             * From: [[http://www.gnome.org][Gnome]] (optional):
                 + base libraries (installed in order per gnome instructions)
             * From [[http://www.lysator.liu.se/~alla/dia/][Dia]]:
                 + dia. If you installed gnome, configure with "--enable-gnome"

           Each of these is an autoconf-style install from sources. Binaries are available for some
           platforms. If you have a recent Linux installation, you may have all the pieces already.

           5. Basics

           5.1. Startup

           Once installed, the app is started with:

             dia

           This gives:

           mainwin.

           The first time up, you click File...Preferences and fill in personal choices. These are saved
           in your home dir as .dia/diarc. For example, I generally use the defaults except I make sure it
           is set to:

             * User Interface...
                 + Compress...no (so I can easily manipulate the UML models later. If I were worried about
                   space, I'd use "yes")
             * Grid lines...
                 + Visible...yes
                 + Snap to...yes

           After clicking OK on the preferences, you can make a diagram.

           5.2. New diagram

           Clicking File...New gives:

           newwin.p

           Right-clicking in that window gives a diagram-specific menu. From that select File...page
           setup:

           newpage.

           Typically:

             * Paper size: Use Letter for US printers.
             * Orientation: Use portrait for most web pages, and landscape for viewfoils
             * Margins: Leave as is. They resize for the paper size.
             * Scaling: Leave as Scale...100. However, we'll come back to this later.

           After clicking OK, the page setup goes away and you are ready to populate the diagram.

           5.3. Draw an Organization Chart

           An organization chart requires several boxes with text, some piped solid lines, and a few
           dashed lines. This can be done with the basic tools. So how do we use the basic tools?

           Notice the mainwindow's layout:

           layout.p

           If you hold the mouse over an icon, a tooltip will appear. If you click an icon, the tool is
           activated and any clicks in the diagram will provide a copy of that tool. After clicking and
           placing one or more copies of a shape, click the pointer tool (top left arrow icon) before
           attempting to move things around. (Otherwise you will get lots of unexpected shapes.)

           The easiest way to work is to:

            a. Select a shape
            b. Click approximately the right number of them onto your diagram.
            c. Label them (most shapes accept text labels).
            d. Move the shapes into place.
            e. Connect them with lines. Make sure the lines actually link to the shape handles.
            f. Label the lines as needed.
            g. Drag shapes and lines around as needed. Add connection points as needed to make tidy lines.
            h. Add/modify more shapes and lines as needed.

           For an org chart, we'll start with:

           org1.png

           That looks terrible. The text doesn't line up with the boxes, and the font is tacky. How can we
           fix it?

           5.4. Boxes and text

           We could use a box which knows about text, and resizes around text. The boxes in the Flowchart
           library (e.g., the square) can do this. We could even make our own shape which knows about
           text.

           But let's do it the hard way for now, with the basic box.

           First, get the font right. Select a text item. Right-click to get the menu, then
           Dialogs...Properties. Select Helvetica. Leave the size as is -- we can scale later. Do this for
           each text item.

           Next, carefully center the text in the box. Drag the box bigger if needed. Since the default is
           snap-to-grid, it will be difficult to align the text. So let's turn off snap-to-grid for a
           moment: With the pointer tool, click somewhere in the diagram (but not on a specific item), and
           type "g". Drag the text as needed, then type "g" again to toggle back to snap-to-grid.

           Ok, the text is the right font and is aligned nicely. Let's lock those box-and-text
           combinations together. Use the pointer to drag a selection box (dashed lines) around a
           box-and-text combo. Type "Ctl-G" to make them a group. Do this for each of the boxes.

           If you need to un-group a combo (e.g., to edit the text or realign), type "Ctl-U". For example,
           we notice misspellings, so we ungroup to fix those and then regroup.

           We now have:

           org2.png

           5.5. Lines

           Now we can draw some lines. We'll use the piped lines (90 degree turns). We draw them
           approximately from one item to the next, and then use the pointer to drag the ends directly to
           the handles at each end. The line end turns red when it locks in to a handle.

           We want to make the lines more interesting.

           In general, lines are controlled from the main window in several ways:

            a. Line color, via the foreground/background icon.
            b. Line width, via the vertical lines of varying width
            c. Line style (e.g., dotted, dashed), via the middle of the bottom row.
            d. Line end arrows, via the left and right ends of the bottom row.

           All of these apply to future lines. You can also modify an already-drawn line. Select it using
           the pointer. Right-click to get the diagram menu. Select Dialogs...properties. This brings up a
           dialog for changing any of the line's properties.

           Thus, to fix our current lines: For each line, select the line, right-click to get the menu,
           select Dialogs...Properties, and change the line width from 0.1 to 0.2. Change the System
           Architect-to-Project Manager line to dotted line. But the wide dots look odd, so we change to
           dashed lines. The dashes are too long, so we make the dash interval 0.5. The net effect is:

           org3.png

           Let's say the Systems Architect actually reports to the CIO (via a long chain of middle
           managers of course). We want to note that, but not over emphasize it. So we draw it in a thin
           line:

           org4.png

           Ugh. We want that line to go around the outside. But there aren't enough middle bending points
           in the line to do it. So we select the line and the middle-click, to get the add-segment
           dialog. After adding a segment or two, we can drag the line to make a nice connection:

           org5.png

           5.6. Saving

           Ok, the diagram looks pretty good. Time to save it. First, we want to save the intellectual
           content, so we can later modify it. Second, we want to export it as a specific graphic format.

           To save it, right-click for the menu, then File...Save. Insert the name, e.g., org.dia, and
           click OK. If you are saving a whole series of variants on the same file and need to save each
           to a separate file, use File...Save As. The file is saved in an XML format which is mostly
           Scalable Vector graphics (SVG). NOTE: Since we set Compress to No in the user preferences, we
           can examine the file in a text editor. Go take a look.

           To export a usable image, select File...Export, and then enter the name with an appropriate
           extension, e.g., org.png. Look at the extensions list for candidates. If you don't have a
           preference, we suggest png (Portable Network Graphics).

           A simple export may make a rather large image. If you look closely at the diagram window, you
           can see blue lines representing printable pages. Your diagram probably extends over several
           pages. So if you print out the diagram to a physical printer, you will need to tape the pieces
           together. This is not much of a concern for HTML, where the browser can pan back and forth over
           a large image. However, even for HTML a large image can be awkward.

           So here is the recommendation:

             * Build the diagram to any convenient size
             * Save it as is
             * Export it as is (full sized), for use in HTML links
             * Export another copy for directly embedding in an HTML page.

               Do this via File...Page setup...Scaling...Fit 1 by 1. This will show the scaling needed to
               fit the whole diagram on one page. But even that may be too large, so you can switch back
               to Scaling...Scale, and tweak the numbers until a convenient size is found for your HTML
               context.

           6. Advanced

           6.1. Layers

           6.1.1. Simple case

           Suppose we have four UML "class" objects, and want to draw a box around two of them. Doing so
           leaves the box on top and obstructs view of the two boxed classes. Putting the box in the
           background solves the problem.

           Putting an object in the background is done by first selecting it, and then:

            a. Long way: Right-click for menu...Objects...Send to back
            b. Shortcut: Ctl-B

           ../advan

           6.1.2. Full layering

           Now suppose we have a common background (e.g., project logo) and want to build our diagram on
           top of that. It is no longer convenient to do this object by object. Instead we want to
           establish the layers in advance and use them over time.

           If you are familiar with Gimp layers, you are in business -- it is the same mechanism.
           Otherwise, listen carefully.

           When you start a new diagram, after doing page setup, select right-click...Objects...layers.
           This gives:

           ../advan

           Click on the "new layer" icon (page with corner turned down), and you will get a "New layer".
           It is automatically placed above the Background layer. Click on the layer's name to select it.
           Once selected, you can move it relative to the other layers using the up and down arrows. Of
           course you should leave the Background layer at the bottom of the stack.

           Clicking on the eyeball next to a layer toggles whether or not it is visible in the diagram.
           Generally, you build each layer separately, with just it visible, but turn on all layers
           occasionally to check alignment.

           For our example, we put a text object which says "DRAFT" on the background layer. We make this
           text object grey using the color selector. Then we go to the new layer and make a diagram.
           Making both layers visible gives:

           ../advan

           6.2. Alignment

           Suppose we have several objects roughly aligned:

           ../advan

           We could very carefully drag them around to get them aligned. But a better approach is to use
           the alignment functions. Select the almost-vertically-aligned circles. Right-click to get the
           menu, then...Objects...Horizontal...center. This moves the objects horizontally until their
           centers are aligned vertically.

           Yes, it is a bit confusing: To align on a vertical axis, you have to select horizontal, because
           that is the axis on which the movement takes place.

           Similarly, to align objects along a single horizontal axis, you select
           Objects...Vertical...center. After aligning groups vertically and horizontally, we get:

           ../advan

           6.3. Selection

           The obvious ways to select are:

            a. With pointer, click on an item
            b. With pointer, and shift-button down, click on 1 or more items
            c. With pointer, drag dashed-line box around the items to be selected

           But you might want something fancier. In that case, Right-click to get the menu and then
           Select.... This gives the dialog:

           ../advan

           For example, applied to this diagram, after selecting the "A" object:

           ../advan

             * All: All boxes and lines are selected.

             * None: No boxes or lines are selected (e.g., A is also unselected)

             * Invert: Everything is selected except A

             * Connected: A and L1 and L3 are selected, because L1 and L2 are directly connected to A.

             * Transitive: A,B,C,D, and L1,L2,L3 are selected, because by following connections, you can
               reach each of these. E is left out because it cannot be reached.

             * Same Type: A,B,C,D,E are selected, because they are the same type of Dia object (i.e., all
               UML class objects).

           NOTE: If I ever figure out what the check boxes do, I'll let you know.

           6.4. Shape Libraries

           Dia comes with several shape libraries. It is also designed to allow you to add your own.

           These libraries are of course domain-specific, so their use should be described in other
           contexts (e.g., UML should be discussed in a tutorial on software engineering). Here we will
           concentrate on the mechanics of using the shape libraries.

           The libraries are saved in the share dir for wherever dia is installed. For example if which
           dia gives /usr/bin/dia, then we want to look at /usr/share.dia:

           /usr/share/dia/
             dia_logo.png         Dia's logo
             shapes/
               Flowchart/         objects, in paired files (icon and shape)
                 magdisk.xpm      icon
                 magdisk.shape    shape description
                 ...
             sheets/      object descriptions in various languages (XML)
               ER.sheet
               Flowchart.sheet
               UML.sheet
               ...

           For example, if we are interested in the Flowchart library, and specifically in the magnetic
           disk object, we find the magdisk.shape file:

           <?xml version="1.0"?>

           <shape xmlns="http://www.daa.com.au/~james/dia-shape-ns";
                  xmlns:svg="http://www.w3.org/TR/2000/03/WD-SVG-20000303/DTD/svg-20000303-stylable.dtd">;
             <name>Flowchart - Magnetic Disk</name>
             <description>Magnetic Disk</description>
             <icon>magdisk.xpm</icon>
             <connections>
               <point x="0"   y="2"/>
               <point x="2.5" y="0.4375"/>
               <point x="5"   y="0"/>
               <point x="7.5" y="0.4375"/>
               <point x="10"  y="0"/>
               <point x="0"   y="2.5"/>
               <point x="0"   y="7.5"/>
               <point x="0"   y="5"/>
               <point x="0"   y="10"/>
               <point x="10"  y="2.5"/>
               <point x="10"  y="5"/>
               <point x="10"  y="7.5"/>
               <point x="10"  y="10"/>
               <point x="2.5" y="11.5625"/>
               <point x="5"   y="12"/>
               <point x="7.5" y="11.5625"/>
             </connections>
             <textbox x1="0" y1="4" x2="10" y2="10"/>
             <svg:svg width="10" height="12">
               <svg:path d="M 0,2 c 2,-1.5 3,-2 5,-2 s 3,0.5 5,2 v 8
                            c -2,1.5 -3,2 -5,2 s -3,-0.5 -5,-2 v -8 z
                            M 0,2 c 2,1.5 3,2 5,2 s 3,-0.5 5,-2" style="fill: default"/>
             </svg:svg>
           </shape>

           Notice:

            a. The name value maps to the description lines in the Flowchart.sheet file

                   <object name="Flowchart - Magnetic Disk">
                     <description xml:lang="no">Magnetdisk</description>
                     <description xml:lang="fr">Disque Magn?tique</description>
                     <description xml:lang="de">Magnetdisk</description>
                     <description>Magnetic Disk</description>
                   </object>

               Thus, we get language-specific tooltips.

            b. The icon value is the file name of the icon shown on the main window.

            c. The shape is described by a Scalable Vector Graphics (svg) width/height and path.

            d. The location of connection points is given in the context of the width and height. You can
               add other connection points if you wish.

            e. The associated text field is also defined in the context of the width and height.
               Originally, it is under the magdisk object. You could move that to the middle of the
               magdisk object if you wished.

           You can make your own sheets/shapes by following the above patterns.

           Some shape libraries (e.g., UML) have associated processing and therefore are not just .shape
           files. To make your own library-with-processing requires going into the C code, and that is
           beyond the scope of this tutorial. (Perhaps embedded python will be supported in the future,
           simplifying even this adventure.)

           -----------------------------------------------------------------------------------------------
           Creator: [[mailto:hgg9140@seanet.com][Harry George]]
           Updated/Created: 2002-06-02

** [[http://www.cnblogs.com/xkfz007/articles/2182480.html][Linux 中将多个Word文档转换成PDF格式的方法及多个PDF文件的合并]]

在Linux中常常涉及到多种文档格式，如doc、txt、html、rtf等等。为了方便文件传递，就可能需要在各种格式之间进行转换。OpenOffice.Org可以方便的打开多各文档格式并按需进行转换，但要一次处理大量文件或要编写脚本进行转换时，仅用OpenOffice就难以胜任了。
用unoconv就可以轻松地实现用OpenOffice可以打开的文档的转换.
首先下载安装unoconv采用下面任一种方法:
1)到 http://dag.wieers.com/home-made/unoconv/ 下载,再安装.
2) yum install unoconv

然后就可以用命令
unoconv -f pdf myDoc.doc
进行转换了.以上命令即会生成一个名为 myDoc.pdf 的 pdf 文件。

批量转换需要结合find命令或脚本使用，使用时需注意最好使用C/S模式以加快速度：
unoconv --listener &
unoconv -f pdf some-document.odt
unoconv -f doc other-document.odt
unoconv -f jpg some-image.png
unoconv -f xsl some-spreadsheet.csv

多个PDF文件的合并:
gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=out.pdf  *.pdf
就会生成一个名为out.pdf的文件.但要保证当前目录下没有out.pdf这个文件.


** [[http://www.zhixing123.cn/ubuntu/draw-figures-and-store-using-gnuplot.html][gnuplot绘制图像并保存]]


对于在Linux下工作的人，如果你经常要画一些二维图和简单的三维图的话，那么，gnuplot无疑是一个非常好的选择，不仅图形漂亮，而且操作简单。当然如果需要质量更高的三维图，请用其他的一些专业绘图软件。建议大家学会使用gnuplot。这个小软件通常都是Redhat Linux自带的，但自带的版本是3.7的，建议将其升级到4.0，新版本具有很多新功能。最新版本可以到http://www.gnuplot.info/下载。
一些最基本的操作请大家看说明书。这里总结一下我在使用过程中遇到的一些问题以及解决的办法，目的是让那些以前不会的或不熟练的能快速入门，会画自己想要 的图，因为原来的说明书很长，较难有针对性地很快找到自己想要的信息。这里简单的总结不可能面面俱到，所以大家不要抱怨我写的不全，更全面的了解还是请看 说明书，网上的资料也多的是。其实这也是我们从网上一点一点搜集和摸索出来的。我相信看完后，应该平时最常见的问题基本上都能在这里找到答案。如果大家在 使用过程中摸索到了我没有写到的技巧和体会，或有其它建议，请大家提告诉我，以不断完善这篇总结，谢谢！
一、基础篇
在linux命令提示符下运行gnuplot命令启动，输入quit或q或exit退出。
1、plot命令
gnuplot> plot sin(x) with line linetype 3 linewidth 2 或
gnuplot> plot sin(x) w l lt 3 lw 2    %用线画，线的类型（包括颜色与虚线的类型）是3，线的宽度是2，对函数sin(x)作图
gnuplot> plot sin(x) with point pointtype 3 pointsize 2  或
gnuplot> plot sin(x) w p pt 3 ps 2    %用点画，点的类型（包括颜色与点的类型）是3，点的大小是2
gnuplot> plot sin(x) title ‘f(x)’ w lp lt 3 lw 2 pt 3 ps 2    %同时用点和线画，这里title ‘f(x)’表示图例上标’f(x)’，如果不用则用默认选项
gnuplot> plot sin(x)    %此时所有选项均用默认值。如果缺某一项则将用默认值
gnuplot> plot ‘a.dat’ u 2:3  w l lt 3 lw 2 %利用数据文件a.dat中的第二和第三列作图
顺便提一下，如这里最前面的两个例子所示，在gnuplot中，如果某两个词，按字母先后顺序，前面某几个字母相同，后面的不同，那么只要写到第一个不同的字母就可以了。如with，由于没有其它以w开头的词，因此可以用 w 代替，line也可以用 l 代替。
2、同时画多条曲线
gnuplot> plot sin(x) title ‘sin(x)’ w l lt 1 lw 2, cos(x) title ‘cos(x)’  w l lt 2 lw 2  ％两条曲线是用逗号隔开的。画多条曲线时，各曲线间均用逗号隔开就可以了。
以上例子中是对函数作图，如果对数据文件作图，将函数名称换为数据文件名即可，但要用单引号引起来。
3、关于图例的位置
默认位置在右上方。
gnuplot> set key left  %放在左边，有left 和right两个选项
gnuplot> set key bottom  %放在下边，只有这一个选项；默认在上边
gnuplot> set key outside  %放在外边，但只能在右面的外边
以上三个选项可以进行组合。如：
gnuplot> set key left bottom  %表示左下边
还可以直接用坐标精确表示图例的位置，如
gnuplot> set key 0.5,0.6  %将图例放在0.5,0.6的位置处
4、关于坐标轴
gnuplot> set xlabel ‘x’   %x轴标为‘x’
gnuplot> set ylabel ‘y’   %y轴标为’y’
gnuplot> set ylabel ‘DOS’ tc lt 3  %其中的tc lt 3表示’DOS’的颜色用第三种颜色。
gnuplot> set xtics 1.0    %x轴的主刻度的宽度为1.0，同样可以为y轴定义ytics
gnuplot> set mxtics 3    %x轴上每个主刻度中画3个分刻度，同样可以为y轴定义mytics
gnuplot> set border 3 lt 3 lw 2 %设为第三种边界，颜色类型为3，线宽为2
同样可以为上边的x轴（称为x2）和右边y（称为y2）轴进行设置，即x2tics，mx2tics，y2tics，my2tics。
gnuplot> set xtics nomirror
gnuplot> unset x2tics     %以上两条命令去掉上边x2轴的刻度
gnuplot> set ytics nomirror
gnuplot> unset y2tics     %以上两条命令去掉右边y轴的刻度
5、在图中插入文字
gnuplot> set label ‘sin(x)’ at 0.5,0.5  %在坐标（0.5,0.5）处加入字符串’sin(x)’。
在输出为.ps或.eps文件时，如果在set term 的语句中加入了enhanced选现，则可以插入上下标、希腊字母和特殊符号。上下标的插入和latex中的方法是一样的。
6、在图中添加直线和箭头
gnuplot> set arrow from 0.0,0.0 to 0.6,0.8    %从（0.0,0.0）到（0.6,0.8）画一个箭头
gnuplot> set arrow from 0.0,0.0 to 0.6,0.8 lt 3 lw 2   %这个箭头颜色类型为3，线宽类型为2
gnuplot> set arrow from 0.0,0.0 to 0.6,0.8 nohead lt 3 lw 2  %利用nohead可以去掉箭头的头部，这就是添加直线的方法。
注意，在gnuplot中，对于插入多个的label和arrow等等，系统会默认按先后顺序分别对各个label或arrow进行编号，从1开始。如果以后要去掉某个label或arrow，那么只要用unset命令将相应的去掉即可。如：
gnuplot> unset arrow 2
将去掉第二个箭头。
7、图的大小和位置
gnuplot>set size 0.5,0.5  %长宽均为默认宽度的一半，建议用这个取值，尤其是画成ps或eps图形的时候
gnuplot>set origin 0.0,0.5   %设定图的最左下角的那一点在图形面板中的位置。这里图将出现在左上角。
8、画三维图
gnuplot>splot ‘文件名’ u 2:4:5  %以第二和第四列作为x和y坐标，第五列为z坐标。
9．将图形输出到文件
在gnuplot中，输出文件的格式是由terminal来控制的。默认的情况下，都是输出到屏幕，即终端模式为X11。如果想输出到文件，则必须对 terminal进行设置。要了解有那些终端类型，可以输入 set terminal后回车，所有支持的终端模式（或文件格式）都列出来了。就我来说，输出文件的格式用得最多的是ps和eps文件。这在运行画图命令 plot或splot前必须先运行如下两条命令：
gnuplot>set term post eps color solid enh
gnuplot>set output ‘a.eps’
其中第一条命令为设置终端模式，post即为postscript模式，这是输出到ps或eps文件必须有的。后面的eps，color，solid以及 enh选项均可以有或没有，根据你的需要。eps表示输出为eps文件，没有就输出为ps文件；color表示输出图形为彩色，不用就会保存为黑白 的；solid表示输出图中的所有线都用实线，不用则除了第一条线为实线外，其它的均用不同的虚线；使用enh(enhanced)选项可以在图中插入上 下标、希腊字母和特殊符号，不用则不能实现这些功能。后面的选项可以根据自己的需要选择一个或几个。
第二条命令对output的设置表示要输出的文件的名字。但是请注意，运行完这条命令后，还仅仅是定义了输出文件的名字，实际上，图还没画到这个文件里去。因此运行这两条命令还只是进行了必须的设置。然后运行如下命令
gnuplot>plot sin(x) w l
或
gnuplot>replot（假如前面已经运行过plot或replot命令的话）
这时，图形就在上面指定的文件中了。
要输出为其它格式，同样要进行这样的设置，比如要输出为jpg格式，则在运行画图命令前先运行如下命令：
gnuplot>set term jpeg
gnuplot>set output ‘a.jpg’
如果要由其它模式再返回到输出到屏幕，则运行如下命令：
gnuplot>set term X11
二、提高篇
1、如何在同一张图里同时画多个图
gnuplot>set multiplot   %设置为多图模式
gnuplot>set origin 0.0,0.5   %设置第一个图的原点的位置
gnuplot>set size 0.5,0.5  %设置第一个图的大小
gnuplot>plot “a1.dat”
gnuplot>set origin 0.5,0.5   %设置第二个图的原点的位置
gnuplot>set size 0.5,0.5   %设置第二个图的大小
gnuplot>plot “a2.dat”
gnuplot>set origin 0.0,0.0   %设置第三个图的原点的位置
gnuplot>set size 0.5,0.5  %设置第三个图的大小
gnuplot>plot “a3.dat”
gnuplot>set origin 0.5,0.0   %设置第四个图的原点的位置
gnuplot>set size 0.5,0.5  %设置第四个图的大小
gnuplot>plot “a4.dat”
当然，如果后一个图中的某个量的设置和前一个的相同，那么后一个中的这个量的设置可以省略。例如上面对第二、第三和第四个图的大小的设置。前一个图中对某个量的设置也会在后一个图中起作用。如果要取消在后面图中的作用，必须用如下命令，如取消label，用
gnuplot>unset label
2、作二维图时，如何使两边坐标轴的单位长度等长
gnuplot> set size square    %使图形是方的
gnuplot> set size 0.5,0.5    %使图形是你要的大小
gnuplot> set xrange[-a:a]
gnuplot> set yrange[-a:a]    %两坐标轴刻度范围一样
gnuplot> plot ‘a.dat’
3、如何在同一张图里利用左右两边的y轴分别画图
gnuplot> set xtics nomirror   %去掉上面坐标轴x2的刻度
gnuplot> set ytics nomirror   %去掉右边坐标轴y2的刻度
gnuplot> set x2tics       %让上面坐标轴x2刻度自动产生
gnuplot> set y2tics     %让右边坐标轴y2的刻度自动产生
gnuplot> plot sin(x),cos(x) axes x1y2    %cos(x)用x1y2坐标，axes x1y2表示用x1y2坐标轴
gnuplot> plot sin(x),cos(x) axes x2y2     %cos(x)用x2y2坐标，axes x2y2表示用x2y2坐标轴
gnuplot> set x2range[-20:20]   %设定x2坐标的范围
gnuplot> replot
gnuplot> set xrange[-5:5]  %设定x坐标的范围
gnuplot> replot
gnuplot> set xlabel ‘x’
gnuplot> set x2label ‘t’
gnuplot> set ylabel ‘y’
gnuplot> set y2label ‘s’
gnuplot> replot
gnuplot> set title ‘The figure’
gnuplot> replot
gnuplot> set x2label ‘t’ textcolor lt 3    %textcolor lt 3或tc lt 3设置坐标轴名称的颜色
4、如何插入希腊字母和特殊符号
一般只能在ps和eps图中，且必须指定enhanced选项。在X11终端（即显示器）中无法显示。
gnuplot> set terminal postscript enhanced
然后希腊字母就可以通过{/Symbol a}输入。例如
gnuplot> set label ‘{/Symbol a}’
各种希腊字母与特殊符号的输入方法请见安装包中gnuplot-4.0.0/docs/psdoc目录下的ps_guide.ps文件。
另外还可参见：
http://t16web.lanl.gov/Kawano/gnuplot/label-e.html#4.3
5、gnuplot中如何插入Angstrom（埃）这个符号(A上面一个小圆圈)
脚本中在插入前先加入
gnuplot>set encoding iso_8859_1
这个命令，然后就可以通过“{\305}”加入了。如横坐标要标上“k(1/?)”：
gnuplot>set xlabel ‘k(1/{\305})
如果是multiplot模式，则这个命令必须放在
gnuplot>set multiplot
的前面。
如果后面还要插入别的转义字符，那么还要在插入字符后加入如下命令：
set encoding default
安装包中gnuplot-4.0.0/docs/psdoc/ps_guide.ps文件中的表中的‘E’代表那一列的所有符号都用这个方法输入。
6、gnuplot画等高线图
gnuplot>splot  ‘文件名.dat’  u 1:2:3  w  l   %做三维图
gnuplot>set dgrid3d 100,100 %设置三维图表面的网格的数目
gnuplot>replot
gnuplot>set contour    %设置画等高线
gnuplot>set cntrparam  levels  incremental -0.2,0.01,0.2   %设置等高线的疏密和范围，数据从   -0.2到0.2中间每隔0.01画一条线
gnuplot>unset surface   去掉上面的三维图形
最后用鼠标拽动图形，选择合理的角度即可。或者直接设置(0,0)的视角也可以：
gnuplot>set view 0,0
gnuplot>replot
这里注意，画三维图的数据文件必须是分块的，也就是x每变换一个值，y在其变化范围内变化一周，这样作为一块，然后再取一个x值，y再变化一周，作为下一数据块，等等。块与块之间用一空行格开。
7、如何画漂亮的pm3d图
gnuplot> set pm3d                %设置pm3d模式
gnuplot> set isosamples 50,50       %设置网格点
gnuplot> splot x**2+y**2          ％画三维图
gnuplot> splot x**2+y**2 w pm3d   ％画成pm3d模式，注意比较变化
gnuplot> set view 0,0              ％设置视角，（0，0）将投影到底面上去
gnuplot> splot x**2+y**2 w pm3d   ％重画，注意看变化
gnuplot> unset ztics               %把z轴上的数字给去掉
gnuplot> set isosamples 200,200     ％使网格变细
gnuplot> replot                   ％重画，注意看变化，主要是过渡更光滑
8、利用脚本文件避免重复输入
有时候对某个数据文件做好一张图后，下次可能还要利用这个数据文件作图，但某个或某些设置要作些细微变化。这时候，可以把第一次作图时的命令全部写到一个文件里，如a.plt，下次只要将相应的设置做修改后，用下面的命令就会自动运行文件所有的命令而最后得到你要的图：
gnuplot>load ‘a.plt’
作为一个例子，假设文件名为a.plt，里面的内容为：
set pm3d
set view 0,0
unset ztics
set isosamples 200,200
splot x**2+y**2 w pm3d
set term post color
set output ‘a.ps’
replot
那么启动gnuplot后，只要运行如下命令就可以了：
gnuplot>load ‘a.plt’
如果我们要得到的仅仅是.ps或.eps图，那也可以在linux命令提示符下直接运行如下命令：
[zxh@theory zxh]$gnuplot a.plt
9、在gnuplot模式下运行linux命令
在gnuplot提示符下也可以运行linux命令，但必须在相应的命令前面加上 ! 号。例如，假设很多参量都已经设置好了，但需要对某个数据文件a.dat进行修改后再画图，则可以用如下方式
gnuplot>!vi a.dat
通过这种方式，所有的linux命令都可以在gnuplot环境里运行。
另外，也可以在gnuplot的提示符后输入shell，暂时性退出gnuplot，进入linux环境，做完要做的事情后，运行exit命令，又回到gnuplot环境下。
gnuplot>shell
[zxh@theory zxh]$vi a.f
[zxh@theory zxh]$f77 a.f
[zxh@theory zxh]$a.out    (假设生成a.dat数据文件)
[zxh@theory zxh]$exit
gnuplot>plot ‘a.dat’

** [[http://blog.chinaunix.net/uid-488742-id-2113697.html][Ubuntu中安装PDF虚拟打印机 ]]

为了保存一些网页文档，通常在WIN下我们都是利用MS Office自带的PDF打印机打印成PDF格式文档。
当然，在无所不能的Ubuntu下，也是有这样的工具的哦。尤其可以解决Linux和WIN下文档不兼容的问题。
用PDF格式互通文件该是非常不错的吧。
1. 安装cups 和cups-pdf
sudo apt-get install cups-pdf
2. 设置cups-pdf 的 backend root 权限
sudo chmod 4755 /usr/lib/cups/backend/cups-pdf
3.通过 系统-系统管理-打印 启动打印机配置向导
4.右键 “新建打印机” 图表-添加 开始添加打印机
5. 使用检测到的打印机 -选择 PDF Printer-前进
6. 制造商 选择 Generic-PostScript -前进
7. 添入打印机的名称。
8.完成。
现在你就可以用虚拟打印机将你需要的文档打印成PDF格式了。
PS:
sudo gedit /etc/cups/cups-pdf.conf
找到Out开头，就可以修改默认保存文件夹了。
其实gedit ，gThumb都能直接打印成PDF文档，但是打印网页什么的，还是安个虚拟打印机比较方便。而且这个只有几十K那么大！
实在是好东西。
还有，打印快捷键是Ctrl＋P

** [[https://app.yinxiang.com/Home.action#n=105bfce9-941a-454c-acc1-26d67434c546&b=f3a3ebdb-638e-4fde-8608-34ae1b790adc&ses=4&sh=1&sds=5&][如何把NH、KDH文件转换为PDF或者WORD文档]]

在做毕业论文时不可避免的要下载中国期刊网上面的论文，这些文件又需要专门的阅读器，而大家更常用的文档格式是PDF或者WORD文档，不利于个人阅读，虽然CAJ浏览器可以把NH、KDH文件如何转成 txt格式，但是会出现乱码，并且不能转换图片；下面是转换这类文档的个人经验：
1. 转换成PDF文档
首先用高版本的CAJ浏览器打开文档，然后选择打印，在打开的“打印”设置窗口中将“打印机”栏中的“名称”设置为“*** PDF printer”字样，安装不同的PDF 阅读器，前面的单词不同，接下来设置打印属性，向平时打印一样，一般默认，最后点击“确定”，OK，耐心等待文档转换吧。
2. 转换成WORD文档
方法一
1、.若安装有PDF Professional，按照上述方法先转换成PDF文档，再把所得到的文件直接另存为WORD文档(.DOC)。
2.、若你的PDF阅读器不能把文档直接保存为WORD文档,使用第三方软件：PDF WORD 转换软件 如pdf2word和pdf to word
方法二
第一步：首先使用CAJ浏览器打开文档，接下来选择打印，在打开的“打印”设置窗口中将“打印机”栏中的“名称”设置为“Microsoft Office Document Image Writer”，确认后将该NH文件输出为MDI格式的虚拟打印文件。
提示：如果你在“名称”设置的下拉列表中没有找到“Microsoft Office Document Image Writer”项，那证明你在安装Office 2003的时候没有安装该组件，请使用Office 2003安装光盘中的“添加/删除组件”更新安装该组件。

第二步：运行Microsoft Office Document Imaging，并利用它来打开刚才保存的MDI文件，选择“工具→将文本发送到Word”菜单，并在弹出的窗口中勾选“在输出时保持图片版式不变”，确 认后系统提示“必须在执行此操作前重新运行OCR。这可能需要一些时间”，确认即可。

好象CAJ5.0以上版本可以转换为WORD文档,只是不可以转换图象，公式，图表，但是您可以用“复制图位”按钮，以图象方式复制到WORD文档.
CAJ支持另存为TXT，操作在“文件”选项里，但TXT为文本文件，不能保存图片，公式，图表等，可由TXT转为DOC后，通过“复制图位”按钮，以图象方式复制到WORD文档中去。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

方法四：
首先到中国知网（www.cnki.net） 下载CAJViewer阅读器，安装CAJViewer阅读器软件。运行CAJViewer阅读器并点击“文件”打开.CAJ、.NH、.KDH等格式文 件。接下来选择“文件→打印”菜单，在打开的“打印”设置窗口中将“打印机”栏中的“名称”设置为“Microsoft Office Document Image Writer”，确认后将.CAJ、.NH、.KDH等格式文件输出为MDI格式的虚拟打印文件。

（如果 你在“名称”设置的下拉列表中没有找到“Microsoft Office Document Image Writer”项，那证明你在安装Office 2003的时候没有安装该组件，请使用Office 2003安装光盘中的“添加/删除组件”更新安装该组件。）

运行Microsoft Office Document Imaging，并利用它来打开刚才保存的MDI文件，选择“工具→将文本发送到Word”菜单，并在弹出的窗口中勾选“在输出时保持图片版式不变”，确 认后系统提示“必须在执行此操作前重新运行OCR。这可能需要一些时间”，不用管它，点确认即可。
（目前，包括此工具在内的所有软件对PDF转DOC的识别率都不是特别完美，而且转换后会丢失原来的排版格式，所以大家在转换后还需要手工对其进行后期排版和校对工作。）

大功告成！补充一下，PDF格式文件也可以按照上面的方法转换成DOC格式文件。

还有一个方法如下所述：
首先用CAJViewer7.02版本阅读器打开nh文件，在你当前打开页的左上方有个保存为图片的按钮
， 把当前页面保存为图片。然后下载安装一个汉王6.0，安装好后打开。注意，此软件安装好后没有快捷方式，需要按照下面的步骤打开：开始--程序--汉王 ocr6.0--汉王ocr6.0.打开后按照下面的操作就可以识别图片，转换成文字。文件--打开图像--识别--开始识别--输出--到指定格式文 件，保存为txt文件就可以了。现在打开刚刚保存的文件，是不是看见文字转换好了！
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
百度知道的回答
如何将ＮＨ格式文件转为ＷＯＲＤ或文本文件？

我下载了一个ＮＨ格式的文件，现在想对其进行复制其中的一些内容．我从网上搜了一下，有的说先转成ＰＤＦ然后再编辑，也有的说从ＣＡＪ里可以识别后编辑．前一种方法，我从网上未找到相关软件，后一种方法我从ＣＡJ6.0中选中文字，右键文字识别，可识别不出来，一片空白．请大家帮帮忙．谢谢．
呵呵，自己找到答案了，
还是用的ＣＡＪ软件，7.0的，在http://www.cnki.net/software/xzydq.htm
这个网站上下的标准版的，呵呵，在线客服帮的忙．
看到许多人在找PDF转Word的软件，感觉大可不必，其实很多这类软件转换后是变成rtf格式，里边文字变得很小很难看，还得手动调字体，调格式。
    Word自身已经提供了任何文档文件转文字的功能，说白了就是Word自身的OCR工具。PDF、NH、CAJ等常用文档文件都可以通过此方法进行转换。以PDF为例，打开PDF文件后直接选择打印，打印机选择使用Microsoft Office Document Image Writer，这是Office自带的虚拟图像打印工具。确定之后自动存储为mdi文件。它默认会自动启动。此时可以继续另存为图片文件，用其他OCR工具识别，也可以在启动后的界面里直接选择工具－－将文本发送到word，选择一个存储的位置，确认后word会自动进行识别，稍等片刻一篇已经识别好的文本就出现了，并且文本字体十分清楚。相比其他识别工具，word的识别正确率非常高。
    当然，缺点是图片和表格框无法识别，但这也是其他软件的软肋，即便是rtf文件，表格也不那么正规。相比那么多的文本，这也不算什么了吧。
    除此以外，AutoCAD的打印以及其他程序都可以使用此功能

** [[http://blog.csdn.net/wangjunjun2008/article/details/21982843][tar 建立档案文件]]

【语法】 tar [option] tarfile filename

【命令说明】

文件名必须紧跟在-f参数后,且作为参数的最后一项;

【参数说明】

-c 建立一个新的档案文件;

-f 指定档案文件名;

-r 往归档文件中追加文件;

-x 从档案文件中提取文件;

-v,-vv 显示进度信息;

-t 列出存档文件的信息(不提取);

-C 指定文件提取的目录;

-A 合并多个tar文件;

--totals 归档完成后,打印总归档字节数;

--delete 从归档文件中删除指定的文件;

--exclude 归档时,排除指定样式的文件;

-j 生成归档文件时,使用bunzip2格式进行压缩;

-z 生成归档文件时,使用gzip格式进行压缩;

--lzma 生成归档文件时,使用lzma格式进行压缩;

-a 生成归档文件时,根据扩展名自动进行压缩;



【一般用法】

#打tar包,名称为all.tar

$ tar -cvf all.tar *.text;

#追加文件b.doc

$ tar -rvf all.tar b.doc;

#列出归档文件中的内容

$ tar -tvf all.tar;

#提取归档文件中的全部文件

$ tar -xvf all.tar;

$ tar -xvf all.tar -C /opt/app/tool_dir;

#提取归档文件中的指定文件

$ tar -xvf all.tar file_one file_two

#合并两个tar文件

$ tar -Af file_one.tar file_two.tar

#删除指定的文件

$ tar -f all.tar --delete file_one file_two

#归档时,排除日志文件

$ tar -cf all.tar * --exclude ”*.log”





*gzip/gunzip 进行压缩/解压缩*

【语法】

gzip [options] file;

gunzip [options] file;

【命令说明】

gzip只能压缩单个文件,如果指定多个文件,则会生成多个单独的压缩文件;

gzip会在生成压缩文件后,删除源文件!!!!

gunzip会在解压缩完成后,删除源文件!!!

【参数说明】

-l,--list 列出压缩文件的属性信息;

--fast 指定最低压缩比;

--best 指定最高压缩比;

-n 指定压缩比(n为数字,且1<=n<=9);

-v 显示进度信息;





*bzip2/bunzip2 进行压缩/解压缩*

【语法】

bzip2 file;

bunzip2 file;

【命令说明】

bzip2通常能生成比gzip压缩比更高的文件;默认bzip2会删除源文件,可使用-k参数保留源文件;

【参数说明】

-k 保留源文件;

-n 指定压缩比(n为数字,且1<=n<=9);





*zip/unzip 进行压缩/解压缩*

【语法】 zip [options] file file dirs

【命令说明】

zip压缩/解压缩后,不会删除源文件;

【参数说明】

-r 递归;压缩目录时使用;

-l 列出压缩文件内容;

-d 从压缩文件中删除指定文件;

-u 更新压缩文件的内容;



【一般用法】

#压缩文件

$ zip all.zip file;

$ zip all.zip file_one file_two;

$ zip -r all.zip dir_name;

#更新压缩文件

$ zip all.zip -u log.text

#删除指定的内容

$ zip -d all.zip log.text;



#解压文件

$ unzip all.zip;

#列出压缩文件内容

$ unzip -l all.zip;

** [[http://www.lampweb.org/linux/3/18.html][patch 修补文件（给文件打补丁）]]

*功能*：修补文件。使用补丁文件，对源文件进行更改。更改方式根据参数来设定。
倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行。如果配合修补文件的方式则能一次修补大批文件。

#+BEGIN_EXAMPLE
    语法：patch   [OPTION]   [ORIGFILE]  [PATCHFILE]
#+END_EXAMPLE



输入选项

-p NUM

--strip=NUM

去除相对路径层次的数目

-F LINES

--fuzz LINES

设置监别列数

-l

--ignore-whitespace

忽略修补数据与输入数据的跳格，空格字符

-c

--context

把修补数据解译成关联性的差异

-e

--ed

把修补数据解译成ed指令可用的叙述文件

-n

--normal

把修补数据解译成一般性的差异

-u

--unified

把修补数据解译成一致化的差异

-N

--forward

忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使用过

-R

--reverse

假设修补数据是由新旧文件交换位置而产生

-i PATCHFILE

--input=PATCHFILE

读取指定的修补文件

输出选项

-o FILE

--output=FILE

设置输出文件的名称，修补过的文件会以该名称存放

-r FILE

--reject-file=FILE

Output rejects to FILE

-D NAME

--ifdef=NAME

用指定的符号把改变的地方标示出来

-m

--merge

Merge using conflict markers instead of creating reject files

-E

--remove-empty-files

若修补过后输出的文件其内容是一片空白，则移除该文件

-Z

--set-utc

把修补过的文件更改，存取时间设为UTC

-T

--set-time

此参数的效果和指定"-Z"参数类似，但以本地时间为主



--quoting-style=WORD

使用WORD引述类型显示项目名称,可设定值有literal,shell,shell-always,c,escape

备份和版本控制选项

-b

--backup

备份每一个原始文件



--backup-if-mismatch

在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件



--no-backup-if-mismatch

在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件

-V STYLE

--version-control=STYLE

用"-b"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用"-z"参数变更，
当使用"-V"参数指定不同备份方式时，也会产生不同字尾的备份字符串

-B PREFIX

--prefix=PREFIX

设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称

-Y PREFIX

--basename-prefix=PREFIX

设置文件备份时，附加在文件基本名称开头的字首字符串

-z SUFFIX

--suffix=SUFFIX

此参数的效果和指定"-B"参数类似，差别在于修补作业使用的路径与文件名若为src/linux/fs/super.c，
加上"backup/"字符串后，文件super.c会备份于/src/linux/fs/backup目录里

-g NUM

--get=NUM

设置以RSC或SCCS控制修补作业

其他选项

-t

--batch

自动略过错误，不询问任何问题

-f

--force

此参数的效果和指定"-t"参数类似，但会假设修补数据的版本为新版本

-s

--quiet或--silent

不显示指令执行过程，除非发生错误



--verbose

显示详细的过程信息



--dry-run

实际上不改变任何文件；演示讲会发生什么



--posix

符合POSIX标准

-d DIR

--directory=DIR

先改变工作目录到指定的目录



--reject-format=FORMAT

Create 'context' or 'unified' rejects



--binary

以二进制方式读写数据



--read-only=BEHAVIOR

如何处理只读输入文件：“忽视”，他们是只读的，“警告”（默认），或“失败”



#+BEGIN_QUOTE

  -  patch 命令（默认）使用从标准输入读入的源文件 *< PATCHFILE*
     ，但是使用 -i  /PATCHFILE/ 设置。
  -  源文件包含由 diff 命令产生的差别列表（或者 diff
     列表）。差异列表是比较两个文件和构建关于如何纠正差别的指示信息的结果。
  -  差异列表有三种格式：正常、上下文或者是 ed 编辑器风格。patch
     命令确定差异列表格式，除非被 -c、-e 或 -n 标志否决。
  -  默认，/ORIGFILE/ 被/PATCHFILE/
     替换。若/ORIGFILE/（原始文件）不存在时，/PATCHFILE/（补丁文件）根据差别列表，创建
     /ORIGFILE/ 文件。
  -  指定 -b
     标志时，/ORIGFILE/（原始文件）会备份在自身的文件中，只是在文件名后附加了后缀
     .orig。使用 -o 标志也可以指定输出的目的地。
#+END_QUOTE

patch常用选项：
 -r
是一个递归选项，设置了这个选项，diff会将两个不同版本源代码目录中的所有对应文件全部都进行一次比较，包括子目录文件。
 -N 选项确保补丁文件将正确地处理已经创建或删除文件的情况。
 -u 选项以统一格式创建补丁文件，这种格式比缺省格式更紧凑些。
 -p0 选项从当前目录查找目的文件（夹）(直接使用补丁文件里面指定的路径)
 -p1
选项忽略掉第一层目录，从当前目录查找(去掉补丁文件指定路径最左的第1个'/'及前面所有内容)。
 -E  选项说明如果发现了空文件，那么就删除它
 -R
 选项说明在补丁文件中的“新”文件和“旧”文件现在要调换过来了（实际上就是给新版本打补丁，让它变成老版本）



**** svn生成补丁文件和打补丁文件

#+BEGIN_EXAMPLE
    生成补丁文件：
    svn diff > patchFile  整个工程的变动生成补丁
    或 svn diff file > patchFile  某个文件单独变动的补丁

    svn回滚：
    svn revert FILE   单个文件回滚
    svn revert DIR --depth=infinity   整个目录进行递归回滚

    打patch：
    patch -p0 < test.patch   -p0 选项要从当前目录查找目的文件

    patch -p1 < test.patch  -p1 选项要从当前目录查找目的文件，不包含patch中的最上级目录
    例如两个版本以a,b开头，而a,b并不是真正有效地代码路径，则这时候需要使用"-p1"参数。
    a/src/...
    b/src/...
#+END_EXAMPLE

** [[http://www.jincon.com/archives/248][linux系统下Imagemagick的convert图像处理常用命令详解]]

[[http://www.jincon.com/tag/convert/][convert]] 是 [[http://www.jincon.com/tag/imagemagick/][imagemagick]] 软件包中的一个命令。它可以读取、转换、写入多种
格式的图片。图片切割、颜色替换、各种效果的应用，图片的旋转、组合，文本，
直线，多边形，椭圆，曲线，附加到图片伸展旋转。这里介绍几个简单的命令，
具体的用法请参考man手册或者其官方网站。在Ubuntu中用命令


#+BEGIN_EXAMPLE
    sudo apt-get install imagemagick(centos的yum 一下就OK了)
#+END_EXAMPLE



*Convert的resize命令：*

Convert的resize子命令应该是在ImageMagick中使用较多的命令，它实现了图片任意大小的缩放，唯一需要掌握的就是如何使用它的一些参数测试设定值：

此说明文件中所用的原始文件(src.jpg)，宽度：200，高度：150

命令格式： -resize widthxheight{%} {@} {!} {<} {>} {\^}

1.
默认时，宽度和高度表示要最终需要转换图像的最大尺寸，同时Convert会控制图片的宽和高，保证图片按比例进行缩放。

如：convert -resize 600×600 src.jpg dst.jpg

转换后的dst.jpg的图片大小(宽度为600，而高度已经按比例调整为450).

2.如果需要转换成600×600，而图片无需保持原有比例，可以在宽高后面加上一个感叹号!.

如：convert -resize 600×600! src.jpg dst.jpg

3.
只指定高度，图片会转换成指定的高度值，而宽度会按原始图片比例进行转换。

如：convert -resize 400 src.jpg dst.jpg

转换后的dst.jpg的图片大小(宽度为400，而高度已经按比例调整为300)，和例1有点类似。

4. 默认都是使用像素作为单位，也可以使用百分比来形象图片的缩放。

如：convert -resize 50%x100%! src.jpg dst.jpg 或者convert -resize
50%x100% src.jpg dst.jpg

此参数只会按你的比例计算后缩放，不保持原有比例。(结果尺寸为100×150)

5.使用 @ 来制定图片的像素个数。

如：convert -resize “10000@” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(115×86)，图片保持原有比例(115×86= 9080 <
10000)。

6.当原始文件大于指定的宽高时，才进行图片放大缩小，可使用>命令后缀。

如：convert -resize “100×50>” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(67×50)，图片保持原有比例。

如：convert -resize “100×50>!” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(100×50)，图片不保持原有比例。

7.当原始文件小于指定的宽高时，才进行图片放大转换，可使用<命令后缀。

如：convert -resize “100×500<” src.jpg dst.jpg 或者convert -resize
“100×100

此命令执行后，dst.jpg和src.jpg大小相同，因为原始图片宽比100大。

如：convert -resize “600×600<” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(600×450)，图片保持原有比例。

如：convert -resize “600×600

此命令执行后，dst.jpg图片大小为(600×600)，图片不保持原有比例。

8.使用\^命令后缀可以使用宽高中较小的那个值作为尺寸

如：convert -resize “300×300\^” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(400×300)，图片保持原有比例，(300:300 <
200:150，选择高作为最小尺寸)。

如：convert -resize “300×200\^” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(300×225)，图片保持原有比例，(300:200 >
200:150，选择宽作为最小尺寸)。

*Convert的quality 命令：*



#+BEGIN_EXAMPLE
    convert -resize -quality 50 1405407568-633.jpg 800.jpg
#+END_EXAMPLE





*Convert的sample命令 生成250x250缩略图：*

convert -sample 250x250 wgy.jpg sample.jpg

另外，你还可以加水印，就不再赘述了。命令行的强大之处还是在于其简洁、快速，更适用于批量处理。

附上一个简单的shell脚本，共大家修改和使用：

#+BEGIN_EXAMPLE
    #! /bin/sh
    for i in `ls *.jpg`;
    do
    convert -resize 50% "$i" "${i%.jpg}.png";
    done
#+END_EXAMPLE

** [[http://www.jincon.com/archives/249/][Linux使用imagemagick的convert命令压缩图片，节省服务器空间]]

本人管的一台阿里云服务器由于空间的带宽才只有1MB，图片一多，网站打开就慢，真是蛋疼啊，在不增加带宽的情况只有通过系统让图片更小，这样可以加快速度了，真是人穷就没办法啊。而且压缩图片还可以节省服务器空间，相必也是极好极好的。

安装imagemagick



#+BEGIN_EXAMPLE
    sudo apt-get install imagemagick
#+END_EXAMPLE



imagemagick的命令convert可以完成此任务,其参数-resize用来改变图片尺寸,可以直接指定像素值,也可以指定缩放百分比。而如果想降低图片的质量,可以用convert的-quality参数,质量值为0-100之间的数值,数字越大,质量越好,一般指定70-80,基本上看不出前后的差别。

我们首先要获取图片，自然find命令：



#+BEGIN_EXAMPLE
    find ./ -regex '.*\(jpg\|JPG\|png\|jpeg\)' -size +500k
#+END_EXAMPLE



统计下数量可对：



#+BEGIN_EXAMPLE
    find ./ -regex '.*\(jpg\|JPG\|png\|jpeg\)' -size +500k | wc -l
#+END_EXAMPLE



执行convert 压缩：



#+BEGIN_EXAMPLE
    find ./ -regex '.*\(jpg\|JPG\|png\|jpeg\)' -size +500k -exec convert -resize 50%x50% {} {} \;
#+END_EXAMPLE



或者限定大小：



#+BEGIN_EXAMPLE
    find ./ -regex '.*\(jpg\|JPG\|png\|jpeg\)' -size +500k -exec convert -resize 800x800 {} {} \;
#+END_EXAMPLE



convert 是会自动按照最大尺寸等比例进行缩小的。

用规则表达式把jpg和JPG后缀图片一网打尽,{}代表查找到的文件,这里没有改变convert前后的文件名,最后是转义的分号表示一个迭代的处理完成。

缩小图片质量为50：



#+BEGIN_EXAMPLE
    convert -resize 800x800 -quality 50 1405407568-633.jpg 800.jpg
#+END_EXAMPLE



整合下命令我就不说了，呵呵。。。

加上shell脚本每天定时操作，哈哈，爽 的一塌糊涂。

** [[http://www.linux178.com/linux/sudo.html][]]

** [[http://www.linux178.com/linux/sudo.html][sudo命令详解]]

-  作者：斯巴达克斯
-  时间：January 4, 2014
-  分类：[[http://www.linux178.com/category/linux/][Linux]]

**** 1.sudo是什么？

sudo是一种权限管理机制，管理员可以授权于一些普通用户去执行一些root执行的操作，而不需要知道root的密码，它依赖于/etc/sudoers这个文件，可以授权于那个用户在那个主机上能够以管理员的身份执行什么样的管理命令，而且是有限的。这个文件相当于就是一个授权表。

**** 2./etc/sudoers 文件的语法

可以使用 man sudoers 来查看其帮助信息

由于这个文件是一个授权文件，那么其权限必定是很严格

#+BEGIN_EXAMPLE
    [root@Linux178 ~]# ll /etc/sudoers
    -r--r----- 1 root root 3381 Feb 23  2012 /etc/sudoers
    [root@Linux178 ~]#

    [root@Linux178 ~]# lsattr /etc/sudoers
    ------------- /etc/sudoers
    [root@Linux178 ~]#
#+END_EXAMPLE

看到这个文件的权限是root和root组
只有读的权限，那也就是，编辑这个文件是有单独的命令的
visudo（这个文件我们最好不要使用vim命令来打开），是因为一旦你的语法写错会造成严重的后果，这个工具会替你检查你写的语法,这个文件的语法遵循以下格式：

#+BEGIN_EXAMPLE
    who where whom command
#+END_EXAMPLE

说白了就是
那个用户在哪个主机以谁的身份执行那些命令，那么这个where,是指允许在那台主机ssh连接进来才能执行后面的命令，文件里面默认给root用户定义了一条规则，
看例子：

#+BEGIN_EXAMPLE
    root    ALL=(ALL)       ALL
#+END_EXAMPLE

root root用户
 ALL 所有的主机上都可以
 (ALL) 是以谁的身份来执行，ALL就代表root可以任何人的身份来执行命令
 ALL 所有的命令

那么整个一条规则就是root用户可以在任何主机以任何人的身份来执行所有的命令，也就是不限定。

再来看一条里面的规则：

#+BEGIN_EXAMPLE
    %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom
    jerry   192.168.100.0/24=(root) /usr/sbin/useradd
#+END_EXAMPLE

%users 就是代表users这个组里面的所有成员
 ALL 代表可以这所有的主机上
 = 后面没有括号，也就是代表默认是以root身份
 /sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom 可以执行挂载的命令

**** 3.查看用户可以执行的命令

已经授权的普通用户可以使用

#+BEGIN_EXAMPLE
    sudo -l
#+END_EXAMPLE

来查看自己可以执行那些命令

要执行命令要在执行命令之前加上 sudo
，然后输入用户自己的密码，这是因为要验证，执行命令的用户确实是该用户。

sudo命令还有这个机制，就是在你正确输入密码并成功执行命令的5分钟内，再执行命令是不需要输入密码的，过了5分钟，就需要再次验证该用户的自己的密码，当然也可以手动让该期限过期，看下面sudo命令的语法

**** 4.sudo命令语法

#+BEGIN_EXAMPLE
    sudo [-bhHpV][-s ][-u <用户>][指令]
    或
    sudo [-klv]
    参数
      -b  在后台执行指令。
      -h  显示帮助。
      -H  将HOME环境变量设为新身份的HOME环境变量。
      -k  结束密码的有效期限，也就是下次再执行sudo时便需要输入密码。
      -l  列出目前用户可执行与无法执行的指令。
      -p  改变询问密码的提示符号。
      -s  执行指定的shell。
      -u <用户>  以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份。
      -v  延长密码有效期限5分钟。
      -V  显示版本信息。
      -S   从标准输入流替代终端来获取密码
#+END_EXAMPLE

**** 5.场景

思考这么一个场景，看下面的规则

#+BEGIN_EXAMPLE
    jerry   192.168.100.0/24=(root) /usr/sbin/useradd
#+END_EXAMPLE

这里面我如果想很多台主机上登录并执行命令（但是并不是所有的主机上），那这里岂不是要写很多的主机在这里吗？
你执行useradd命令，但是这只是添加，不能为用户指定密码，那岂不是也不行？如果还有执行很多的命令，那是不是这里又要写很多的命令？

答案是否定的

sudo 是支持 主机别名、用户别名、whom别名（就是以谁的身份）、命令别名

有了别名，规则就变得很清爽，就是把同类的对象放到一个组里面，*组名必须全部大写*

*主机别名* 通过 Host_Alias 关键字来定义 例如下面的：

#+BEGIN_EXAMPLE
    # Host_Alias     FILESERVERS = 192.168.100.0/24, 127.0.0.1
#+END_EXAMPLE

*用户别名* 通过 User_Aliases 关键字来定义，例如下面的：

#+BEGIN_EXAMPLE
    # User_Alias ADMINS = jsmith, mikem
#+END_EXAMPLE

*whom别名*（就是以谁的身份） 通过 RunAs_Aliases 关键字来定义

#+BEGIN_EXAMPLE
    这个通常是root或者是ALL 就不用定义了。
#+END_EXAMPLE

*命令别名* 通过 Cmnd_Alias 关键字来定义，例如下面的：

#+BEGIN_EXAMPLE
    #Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig
#+END_EXAMPLE

**** 6.限定执行的命令

假设你允许一个普通用户执行passwd，那这就危险了，那么它是可以直接修改root的密码，这就有背于我们的初衷了，这就需要做限制了，如下设置：

#+BEGIN_EXAMPLE
    pete    127.0.0.1 = /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root
#+END_EXAMPLE

[A-Za-z]* 是一个正则表达式，代表是大小写字母组成的用户名

这一条就是限制pete这个用户，只能修改以字母组成的用户，而不能修改root的密码，!
就是代表不能执行此命令。

在某个命令之前加!,就代表该用户或组不能执行该命令

**** 7.设定那些命令执行的时候不需要输入密码

当然也是可以设置在执行某些命令的时候不用输入密码,例如：

#+BEGIN_EXAMPLE
    fred           ALL = (DB) NOPASSWD: ALL
#+END_EXAMPLE

这就代表这个fred用户执行所有的命令时不需要输入密码

再如：

#+BEGIN_EXAMPLE
    tom ALL = (root) PASSWD:/usr/sbin/useradd,/usr/sbin/usermod NOPASSWD:/usr/sbin/gourpadd
#+END_EXAMPLE

这一条就是代表tom这个用户在执行uesradd和usermod的时候是需要输入密码，而执行gourpadd时不需要

凡是 PASSWD
后面跟的命令都需要输入密码，而NOPASSWD后面的命令都不需要输入密码，前提是sudo记住密码的期限已过。

** [[http://os.51cto.com/art/201104/255359.htm][Linux文件分割与合并：split&cat]]

Linux下文件分割可以通过split命令来实现，而用cat进行文件合并。而分割可以指定按行数分割和安大小分割两种模式。Linux下文件合并可以通过cat命令来实现，非常简单。

在Linux下用split进行文件分割：

模式一：指定分割后文件行数

对与txt文本文件，可以通过指定分割后文件的行数来进行文件分割。

命令：

split -l 300 large_file.txt new_file_prefix
模式二：指定分割后文件大小

对于可执行文件等二进制文件，则不能通过文件行数来进行文件分割，此时我们可以指定分割大小来分隔文件。

命令：

split -b 10m large_file.bin new_file_prefix
对二进制文件我们同样也可以按文件大小来分隔。

在Linux下用cat进行文件合并：

命令：

cat small_files* > large_file
Linx文件分割命令英文释义：

-, read standard input.

Mandatory arguments to long options are mandatory for short options too.

-a, --suffix-length=N

use suffixes of length N (default 2)

-b, --bytes=SIZE

put SIZE bytes per output file

-C, --line-bytes=SIZE

put at most SIZE bytes of lines per output file

-d, --numeric-suffixes

use numeric suffixes instead of alphabetic

-l, --lines=NUMBER

put NUMBER lines per output file

** [[http://www.cnblogs.com/Charles-Zhang-Blog/archive/2013/02/05/2892879.html][ubuntu下搭建nfs服务器]]

*1.1 *搭建NFS服务器

 NFS（Network
FileSystem，网络文件系统）是由SUN公司发展，并于1984年推出的技术，用于在不同机器，不同操作系统之间通过网络互相分享各自的文件。NFS设计之初就是为了在不同的系统间使用，所以它的通讯协议设计与主机及操作系统无关。

NFS分服务器和客户机，当使用远端文件时只要用mount命令就可把远端NFS服务器上的文件系统挂载在本地文件系统之下，操作远程文件与操作本地文件没有不同。NFS服务器所共享文件或目录记录在/etc/exports文件中。

 嵌入式Linux开发中，会经常使用NFS，目标系统通常作为NFS客户机使用，Linux主机作为NFS服务器。在目标系统上通过NFS，将服务器的NFS共享目录挂载到本地，可以直接运行服务器上的文件。在调试系统驱动模块以及应用程序，NFS都是十分必要的，并且Linux还支持NFS根文件系统，能直接从远程NFS
root启动系统，这对嵌入式Linux根文件系统裁剪和集成也是十分有必要的。

安装nfs-kernel-server：

ky@ubuntu:~$ sudo apt-get install nfs-kernel-server

设置NFS-Server目录。修改/etc/exports文件，在其中增加NFS服务器目录。 一个NFS服务器可以共享多个NFS目录，在/etc/exports文件中，每个目录的设置独占一行，编写格式如下：

NFS共享目录路径 客户机IP或者名称(参数1,参数2,...,参数n)

 说明：

q NFS共享目录可以是主机的任何一个目录，为了方便使用，最好将权限设置为777。

q 客户机指的是可以访问共享目录的客户机的IP或者主机名，可以是指定的IP或者主机名。如果使用IP，可以使用通配符。假如指定IP为192.168.1.x的客户机可以访问，可以写成192.168.1.*，如果设置为*，则表示任何客户机都可以访问。

q 访问参数可以是一个，也可以是多个，用逗号分开。可能的参数和说明如 REF
_Ref286733518
\h 表 5.108D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F005200650066003200380036003700330033003500310038000000 所列。

表 STYLEREF 1 \s 5. SEQ 表 \* ARABIC \s 1 1 NFS设置参数和说明

| 参数   | ro         | rw         | sync                       | async                         | secure                                | insecure                    | wdelay                                          | no_wdelay                                                         | hide                            | no_hide              | subtree_check                                                    | no_subtree_check   | all_squash                                             | no_all_squash                  | root_squash                                                | no_root_squash                       | anonuid=xxx                                   | anongid=xxx                                   |
|        |            |            |                            |                               |                                       |                             |                                                 |                                                                    |                                 |                       |                                                                   |                      |                                                         |                                  |                                                             |                                        |                                               |                                               |
| 说明   | 只读访问   | 读写访问   | 所有数据在请求时写入共享   | nfs在写入数据前可以响应请求   | nfs通过1024以下的安全TCP/IP端口发送   | nfs通过1024以上的端口发送   | 如果多个用户要写入nfs目录，则归组写入（默认）   | 如果多个用户要写入nfs目录，则立即写入，当使用async时，无需此设置   | 在nfs共享目录中不共享其子目录   | 共享nfs目录的子目录   | 如果共享/usr/bin之类的子目录时，强制nfs检查父目录的权限（默认）   | 不检查父目录权限     | 共享文件的UID和GID映射匿名用户anonymous，适合公用目录   | 保留共享文件的UID和GID（默认）   | root用户的所有请求映射成如anonymous用户一样的权限（默认）   | root用户具有根目录的完全管理访问权限   | 指定nfs服务器/etc/passwd文件中匿名用户的UID   | 指定nfs服务器/etc/passwd文件中匿名用户的GID   |



假定NFS共享目录是/home/ky/nfs，允许所有客户机访问，/etc/exports文件可写为：

/home/ky/nfs *(rw,sync,no_subtree_check, no_root_squash)

启动NFS服务器。启动portmap（如果有必要）和nfs-kernel-server服务：

ky@ubuntu:~$ *sudo service portmap start*

ky@ubuntu:~$ *sudo service nfs-kernel-server start*

 本地验证NFS服务器。将NFS服务器目录挂载到本机另外一个目录下，可以看到挂载点目录下可以看到NFS服务器目录中的文件。

ky@ubuntu:~$ ls /home/ky/nfs/

aaaa

ky@ubuntu:~$ *sudo mount -t nfs 127.0.0.1:/home/ky/nfs /mnt*

ke@ubuntu:~$ ls /mnt

aaaa

ky@ubuntu:~$ sudo umount /mnt/

用开发板验证NFS服务器是否可用。启动开发板，进入系统，配置好开发板的IP地址后，用mount命令挂载NFS服务器的NFS目录：

target# *mount -t nfs 192.168.1.3:/home/ky/nfs /mnt -o nolock*

target# ls /mnt

kingyee

target# umount /mnt/

 挂载成功后，可以在开发板的/mnt目录下看到NFS服务器上的文件。

说明，使用开发板与虚拟机安装的客户系统进行NFS挂载，需要将虚拟网卡设置为Bridged模式，并建议使用静态IP地址。

 如果在使用中需要增加新的NFS共享目录，直接修改/etc/exports文件即可。修改该文件后，可以不用重启NFS服务，用exportfs命令读取/etc/exports文件，重新共享输出。exportfs命令语法如下：

 exportfs [-aruv]

 选项说明：

-a：全部挂载(或卸载) /etc/exports的设置；

-r：重新挂载/etc/exports的设置；

-u：卸载某一个目录；

-v：在输出的时候，把共享目录显示出来。

 如果NFS已经启动，修改了/etc/exports文件，执行如下命令，新的设置即可生效：

ky@ubuntu:~$ *exportfs -ra*

** [[http://yanue.net/post-117.html][]]

** [[http://yanue.net/post-117.html][dia在Linux(ubuntu)下无法输入中文的解决办法]]

// 发表于 2013-08-29 09:54 -
[[http://yanue.net/post-117.html#comments][// 0条评论]]   // 2966
次浏览   所属分类：[[http://yanue.net/topic/ubuntu.html][Ubuntu]]

我是执行一下命令安装的

#+BEGIN_EXAMPLE
    sudo apt-get install dia
#+END_EXAMPLE

打开软件后发现不能输入中文，网上搜索一圈后找到以下解决方案

#+BEGIN_EXAMPLE
     sudo vi /usr/bin/dia
#+END_EXAMPLE

然后把dia-gnome --integrated "$@"修改成

#+BEGIN_EXAMPLE
     dia-gnome  "$@"
#+END_EXAMPLE

重新启动dia，输入法选择系统默认（我的系统输入法是ibus），就可以输入中文了不过这样一改，工具条变成浮动的了

另外，发现windows下dia，默认也是不能输入中文的，

解决办法倒是简单些：dia的输入法菜单里选择“简单”，就可以输入中文了

xp系统搜狗输入法下测试成功

** [[http://hw1287789687.iteye.com/blog/1766217][linux shell 遍历指定目录下的所有文件夹]]


在linux 中，如何遍历指定目录下的所有文件夹呢？

要求能搜索结果中包含隐藏文件夹

脚本名：ergodic_folder.sh

脚本内容：

#+BEGIN_EXAMPLE
    #!/bin/sh
    list_alldir(){
        for file2 in `ls -a $1`
        do
            if [ x"$file2" != x"." -a x"$file2" != x".." ];then
                if [ -d "$1/$file2" ];then
                    echo "$1/$file2"
                    list_alldir "$1/$file2"
                fi
            fi
        done
    }

    list_alldir ./test
#+END_EXAMPLE



测试如下：



[root@localhost whuang]# ./ergodic_folder.sh

./test/.abc

./test/.abc/.ccc

./test/bbb

** [[http://bashdb.sourceforge.net/bashdb-man.html][bash debugger script]]

*** NAME

bashdb - bash debugger script

--------------

*** SYNOPSIS

*bashdb* [/options/] [--] /script-name/ [/script options/]

*bashdb* [/options/] -c /execution-string/

*bash --debugger* [/bash-options/...] /script-name/ [/script options/]

--------------

*** DESCRIPTION

=bashdb= is a bash script to which arranges for another bash script to
be debugged.

The debugger has a similar command interface as
[[http://sourceware.org/gdb/current/onlinedocs/gdb_toc.html][gdb]].

The way this script arranges debugging to occur is by including (or
actually "source"-ing) some debug-support code and then sourcing the
given script or command string.

One problem with sourcing a debugged script is that the program name
stored in $0 will be =bashdb= rather than the name of the script to be
debugged. The debugged script will appear in a call stack not as the top
item but as the item below =bashdb=. If this is of concern, use the last
form given above, =bash --debugger= /script-name/ [/script-options/].

If you used bashdb script and need to pass options to the script to be
debugged, add =--= before the script name. That will tell bashdb not to
try to process any further options.

See the reference manual [[http://bashdb.sourceforge.net/bashdb.html]]
for how to to call the debugger from inside your program or arrange for
the debugger to get called when your program is sent a signal.

--------------

*** OPTIONS

-  *-h | --help* :: Print a usage message on standard error and exit
   with a return code of 100.

-  *-A | --annotation /level/* :: Sets to output additional stack and
   status information which allows front-ends such as emacs to track
   what's going on without polling.

   This is needed in for regression testing. Using this option is
   equivalent to issuing:

   #+BEGIN_EXAMPLE
         set annotation LEVEL
   #+END_EXAMPLE

   inside the debugger.

-  *-B | --basename* :: In places where a filename appears in debugger
   output give just the basename only. This is needed in for regression
   testing. Using this option is equivalent to issuing:

   #+BEGIN_EXAMPLE
         set basename on
   #+END_EXAMPLE

   inside the debugger.

-  *-n | nx* :: Normally the debugger will read debugger commands in
   =~/.bashdbinit= if that file exists before accepting user
   interaction. =.bashdbinit= is analogus to Perl's =.perldb= or GNU
   gdb's =.gdbinit=: a user might want to create such a debugger profile
   to add various user-specific customizations.

   Using the =-n= option this initialization file will not be read. This
   is useful in regression testing or in tracking down a problem with
   one's =.bashdbinit= profile.

-  *-c /command-string/* :: Instead of specifying the name of a script
   file, one can give an execution string that is to be debugged. Use
   this option to do that.

   If you invoke the debugger via =bash --debugger=, the filename that
   will appear in source listing or in a call stack trace will be the
   artifical name *BOGUS*.

-  *-q | --quiet* :: Do not print introductory version and copyright
   information. This is again useful in regression testing where we
   don't want to include a changeable copyright date in the
   regression-test matching.

-  *-x /debugger-cmdfile/* :: Run the debugger commands
   /debugger-cmdfile/ before accepting user input. These commands are
   read however after any =.bashdbinit= commands. Again this is useful
   running regression-testing debug scripts.

-  *-L | --library /debugger-library/* :: The debugger needs to source
   or include a number of functions and these reside in a library. If
   this option is not given the default location of library is relative
   to the installed bashdb script: =../lib/bashdb=.

-  *-T | --tempdir /temporary-file-directory/* :: The debugger needs to
   make use of some temporary filesystem storage to save persistent
   information across a subshell return or in order to evaluate an
   expression. The default directory is =/tmp= but you can use this
   option to set the directory where debugger temporary files will be
   created.

-  *-t | --tty /tty-name/* :: Debugger output usually goes to a terminal
   rather than stdout or stdin which the debugged program may use.
   Determination of the tty or pseudo-tty is normally done
   automatically. However if you want to control where the debugger
   output goes, use this option.

-  *-V | --version* :: Show version number and no-warranty and exit with
   return code 1.

-  *-X | --trace* :: Similar to "=set -x=" line tracing except that by
   default the location of each line, the bash level, and subshell level
   are printed. You might be able to get something roughly similar if
   you set =PS4= as follows

   #+BEGIN_EXAMPLE
           export PS4='(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]}\n'
   #+END_EXAMPLE

   In contrast however to "=set -x=" tracing, indentation of the
   original program is also preserved in the source output. And if you
   interrupt the program with a break (a =SIGINT= signal), you will go
   into the debugger (assuming your program doesn't trap =SIGINT=).

--------------

*** BUGS

The =bashdb= script and =--debugger= option assume a version of bash
with debugging support. That is you can't debug bash scripts using the
standard-issue version 2.05b bash or earlier versions. In versions after
3.0, debugging should have been enabled when bash was built. (I think
this is usually the case though.) If you try to run the bashdb script on
such as shell, may get the message:

#+BEGIN_EXAMPLE
      Sorry, you need to use a debugger-enabled version of bash.
#+END_EXAMPLE

Debugging startup time can be slow especially on large bash scripts.
Scripts created by GNU autoconf are at thousands of lines line and it is
not uncommon for them to be tens of thousands of lines.

There is a provision to address this problem by including a fast
file-to-array read routine (readarray), but the bashdb package has to be
compiled in a special way which needs access to the bash source code and
objects.

Another reason of the debugger slowness is that the debugger has to
intercept every line and check to see if some action is to be taken for
this and this is all in bash code. A better and faster architecture
would be for the debugger to register a list of conditions or stopping
places inside the bash code itself and have it arrange to call the
debugger only when a condition requiring the debugger arises. Checks
would be faster as this would be done in C code and access to internal
structures would make this more efficient.

** [[http://www.douban.com/note/170604841/][linux 自动挂载 windows分区
]]

  个人学习linux日志，高手绕过
    对于linux系统挂载windows分区是必须的，比如你u盘 fat32的或是ntfs的格式的。当然这个在ubuntu的我我文件管理器nautilus	会自动挂载。而对双系统用户你的windows在默认的情况下就不会被挂载。当然于是你打开音乐播放器放音乐之前还要打开nautilus 挂载下。如果我的启动是在命令行下 那好也要手动mount下。也有一种软件能够让你自动挂载windows  比如ntfs-config 和ivman 。ntfs-config就用过一次。就是有次重装之前，被ntfs-config 搞的 / 分区无法挂载（当时还不懂改fstab，汗 只好重装）。其实我们只需要手懂配置fstab来挂载linux分区。
      fstab 拆开下 filesystem  table 也就是 linux开机过程控制你要挂载的硬盘分区配置文件（并没说开机后不能用）。关于挂可以参考http://forum.ubuntu.org.cn/viewtopic.php?f=120&t=257333的内容。
     修改fstab内容是这样的    个人学习linux日志，高手绕过
    对于linux系统挂载windows分区是必须的，比如你u盘 fat32的或是ntfs的格式的。当然这个在ubuntu的我我文件管理器nautilus	会自动挂载。而对双系统用户你的windows在默认的情况下就不会被挂载。当然于是你打开音乐播放器放音乐之前还要打开nautilus 挂载下。如果我的启动是在命令行下 那好也要手动mount下。也有一种软件能够让你自动挂载windows  比如ntfs-config 和ivman 。ntfs-config就用过一次。就是有次重装之前，被ntfs-config 搞的 / 分区无法挂载（当时还不懂改fstab，汗 只好重装）。其实我们只需要手懂配置fstab来挂载linux分区。
      fstab 拆开下 filesystem  table 也就是 linux开机过程控制你要挂载的硬盘分区配置文件（并没说开机后不能用）。关于挂可以参考http://forum.ubuntu.org.cn/viewtopic.php?f=120&t=257333的内容。
     修改fstab内容是这样的
# <file system> <mount point>   <type>  <options>       <dump>  <pass>

 # / was on /dev/sda3 during installation
UUID=c5dc9d91-c74b-4d1f-a232-d3151fd57157    /               ext4    errors=remount-ro     0       1
或者是
/dev/sda3      /        ext4        errors=remount-ro     0       1
#的后的面的部分是给人看的，即后面的对已来说是只是乱码 ，前面是同过uuid 挂载面的则是 通过 分区编号
我们所要做的修改
首先对于linux读取 ntfs分区靠的是 ntfs-3g 所以首先检查下ntfs-3g 有没有安装   sudo  apt-get
install ntfs-3g （这个 一般都会安装 n年ubuntu 要手动装）ntfs-3g 参看 http://www.linuxsir.org/main/node/281
   其次查看你要挂分区的硬件号 或者uuid   一般来说你D盘是 /dev/sda5， E盘是/dev/sda6  一次向后 实在确定 可以先mount看下 看uuid
 sudo blkid
我的是/dev/sda1: LABEL="C" UUID="34C85D1DC85CDF24" TYPE="ntfs"
/dev/sda2: UUID="f17f1975-e0f7-489c-87a6-7393efa34355" TYPE="ext2"
/dev/sda3: UUID="c5dc9d91-c74b-4d1f-a232-d3151fd57157" TYPE="ext4"
/dev/sda5: LABEL="D" UUID="178D4B66B84A6E29" TYPE="ntfs"
/dev/sda6: LABEL="E" UUID="5E352DAE4AAB4664" TYPE="ntfs"
/dev/sda7: LABEL="F" UUID="D3F7A6DDFEB31F89" TYPE="ntfs"
/dev/sda8: UUID="f670f9ac-f2ae-4485-b8d1-d3b53e099962" TYPE="reiserfs"
/dev/sda9: UUID="37eefbed-32f7-4514-9154-9129747d0066" TYPE="swap"
/dev/sda10: UUID="e27b304b-78c7-4f05-a8c0-b9b73669bc9d" TYPE="ext4
或者 ls -al /dev/disk/by-uuid

建议用uuid。 因为uuid是 一个硬盘分区 全 中国 全世界 全宇宙的唯一标示符 ，当然uuid 不仅标示硬盘分区标示其他电脑设备 具体的 请google
  然后
1.对fstab 进行备份
cp  /etc/fstab  /etc/fstab.bak
这是一种习惯 修改错的话 cp回来覆盖就行了  比如这里 可以 cp /etc/fstab.bak  /etc/fstab  记不住 目录名 这个你可以搞笔记本 稍微记录下，注意多用神键 tab 键 在输入的时候自动补齐
2.设置你的挂载点 就是你要把文件挂载到哪里
比如我想把E盘的挂载到是 /home/fly/wp/E这个目录下
那么 我就先创键这个目录
mkdir   /home/fly/wp/E
也可以顺便多建几个 mkdir /home/fly/wp/C  /home/fly/wp/F  ……
修改
sudo vim fstab
在文件后 添加你要挂载分区的信息
<uuid  或 分区标号>       <挂载点>      <分区格式>       < 挂载参数 >   0  0
比如我要要挂载我的E盘
 那么 就是
UUID="5E352DAE4AAB4664"     /home/fly/wp/E     ntfs-3g      default  0   0
或者是
/dev/sda6         /home/fly/wp/E    ntfs-3g     default  0  0
  其中 第4 挂载参数 默人填 default 就行 如果需要更多的功能可以藏  这么填写  defaults,utf8,umask=000,uid=fly,gid=fly     （uid 后面的参数 是你用户名 gid后面的是你的用户组名，）gid ，uid 主要是为了你可能无法将文件删除近回收站  umask这个参是防止你不能读写文件  文件utf8 是考虑可能出现的乱码 ，
具体看uid和gid 可以参考http://blog.csdn.net/wl_haanel/article/details/4793176
umask 参考 http://www.linuxso.com/command/umask.html
utf8这个假如你的文件都去是乱的话可以改成

** [[http://wuchong.me/blog/2014/07/14/linux-boot-process/][Linux基础：启动流程]]

计算机的启动是一个非常复杂的过程，从打开电源到桌面的显示，需要经过一系列不可或缺的过程，了解这些过程有助于我们更好地理解操作系统，也有助于我们修复系统可能出现的问题。

*** 0. 启动流程一览

我们先给出 Linux 启动流程的总览图，然后再每一个模块展开说明。

[[http://ww4.sinaimg.cn/large/81b78497jw1eic3rqn72tj20hf06774l.jpg]]

*** 1. BIOS

当我们按下电源按键后，计算机硬件会自动读取主板上的BIOS（Basic
Input/Output
System）来加载硬件信息以及硬件系统的自我测试。BIOS也是一套程序，它知道如何与硬件进行交互。BIOS首先会对硬件进行检查，判断计算机硬件是否能满足运行的基本条件，这叫做“硬件自检”（Power-On
Self-Test，简称 POST）。

硬件自检后，BIOS
会将控制权交给下一段启动程序。这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部存储设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot
Sequence）。

因此，BIOS按照”启动顺序”，把控制权转交给排在第一位的存储设备。

*** 2. MBR

系统读取位列第一的可启动存储设备。计算机先读取该设备的第一个扇区，也就是读取最前面的512个字节。这最前面的512个字节，就叫做”主引导记录”（Master
boot record，缩写为MBR）。MBR
只有512字节，放不了太多东西，它主要告诉计算机从该设备的哪一个分区（partition）来装载引导加载程序（boot
loader）。Boot Loader
储存有操作系统（OS）的相关信息，比如操作系统名称，操作系统内核（kernel）所在位置等。它的主要功能就是加载内核到内存中去执行。常用的
boot loader 有 GRUB 和 LILO 。

那我们经常说到的多操作系统是怎么回事呢？其实每个文件系统（或分区）的最前面会保留一个引导扇区（boot
selector），这个引导扇区可以安装 boot loader。这样我们在每个 boot loader
中对应不同的操作系统，在读取 MBR 的时候选择我们需要启动的 boot loader
即可。

*** 3. kernel

随后，boot loader
会帮助我们加载内核，内核就会开始检测硬件与加载驱动程序。没错，内核会以自己的功能重新检测一遍硬件，而不一定会使用
BIOS 检测到的硬件信息。也就是说，内核此时才开始接管 BIOS 后的工作。

Kernel
实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过
kernel 传达给硬件。

*** 4. init process

在内核加载完毕以后，此时内核会主动调用第一个进程，那就是
=/sbin/init=，它的作用就是初始化系统环境。使用=pstree=命令会发现init的进程编号（PID）是1，也就是说init是第一个运行的程序，其他所有进程都从它衍生，都是它的子进程。

许多程序需要开机启动。它们在Windows叫做”服务”（service），在 Linux
就叫做”守护进程”（daemon）。

init
进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动
Apache，用作桌面就不需要。Linux
允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（run
level）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。

基本上，依据有无网络与有无 X Window ，Linux 将 run level
划分为7个等级（0-6）。其中0是关机，1是单用户模式，6是重启。而
2-5，一般来说都是多用户模式。

Linux
在启动各个服务前会先执行一系列的初始脚本（rc.sysinit）。这些脚本执行如下功能：设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络......
之后会根据运行级别的不同，系统会运行 rc0.d 到 rc6.d
目录中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。rc*.d目录中存放的是该运行级别中需要执行的服务脚本的软链接文件（即快捷方式）。

除此之外，Linux
还会运行一些其他的初始脚本。运行完后，操作系统已经完全准备好了，只是，还没有人可以登录！！！init
会给出登录（login）对话框，或者是图形化的登录界面。

*** 5. login

输入用户名密码登录成功后，系统会为用户分配一个用户 ID（UID），和一个组
ID（GID）。这两个 ID
就好像身份证一样会一直伴随用户，用于检测用户执行程序时的身份验证。

当用户登录成功后，一个完整的操作系统就展现在用户的面前了。哈哈！

*** 总结

结合一开始给出的流程图，Linux 的启动流程可以概括为以下几个主要步骤：

1. 加载 BIOS 的硬件信息与硬件自检，并依据设置取得第一个可启动的设备；
2. 读取并执行第一个启动设备内的MBR的 boot loader；
3. 依据 boot loader 的设置加载内核，内核会开始检测硬件与加载驱动程序；
4. 在内核 Kernel 加载完毕后，Kernel 会主动调用 init 进程，而 init 会取得
   run-level 信息；
5. init 执行 rc.sysinit 初始化系统的操作环境（网络、时区等）；
6. init 启动 run-level 的各个服务；
7. 用户登录

要注意在一开始的流程图中 init
虽然只用了一个模块展现出来，但其实在启动过程中 init 占了很大的比重。

*** 参考文献

-  [[http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html][Linux
   的启动流程]]
-  [[http://www.ruanyifeng.com/blog/2013/02/booting.html][计算机是如何启动的？]]
-  [[http://www.cnblogs.com/vamei/archive/2012/09/05/2672039.html][Linux开机启动
   (bootstrap)]]
-  [[http://vbird.dic.ksu.edu.tw/linux_basic/linux_basic.php][鸟哥的Linux私房菜.基础学习篇]]

** [[http://www.cnblogs.com/hnrainll/archive/2011/06/08/2074976.html][关于Linux系统清理/tmp/文件夹的原理]]

转自:[[http://www.opsers.org/base/clean-up-on-the-linux-system-tmp-folder-you-may-want-to-know.html]]

我们知道，在Linux系统中/tmp文件夹里面的文件会被清空，至于多长时间被清空，如何清空的，可能大家知识的就不多了，所以，今天我们就来剖析一个这两个问题。

****** 在RHEL\CentOS\Fedora\系统中(本次实验是在RHEL6中进行的)

先来看看tmpwatch这个命令，他的作用就是删除一段时间内不使用的文件（removes
files which haven't been accessed for a period of
time）。具体的用法就不多说了，有兴趣的自行研究。我们主要看看和这个命令相关的计划任务文件。
他就是/etc/cron.daily/tmpwatch，我们可以看一下这个文件里面的内容
#! /bin/sh
flags=-umc
/usr/sbin/tmpwatch "$flags" -x /tmp/.X11-unix -x /tmp/.XIM-unix \
  -x /tmp/.font-unix -x /tmp/.ICE-unix -x /tmp/.Test-unix \
  -X '/tmp/hsperfdata_*' 10d /tmp
/usr/sbin/tmpwatch "$flags" 30d /var/tmp
for d in /var/{cache/man,catman}/{cat?,X11R6/cat?,local/cat?}; do
  if [ -d "$d" ]; then
  /usr/sbin/tmpwatch "$flags" -f 30d "$d"
  fi
done

这个脚本大家仔细分析一下就明白了，第一行相当于一个标记（参数），第二行就是针对/tmp目录里面排除的目录，第三行，这是对这个/tmp目录的清理，下面的是针对其他目录的清理，就不说了。

我们就来看/usr/sbin/tmpwatch "$flags" 30d
/var/tmp这一行，关键的是这个30d，就是30天的意思，这个就决定了30天清理/tmp下不访问的文件。如果说，你想一天一清理的话，就把这个30d改成1d。这个你懂的......哈哈！

但有个问题需要注意，如果你设置更短的时间来清理的话，比如说是30分钟、10秒等等，你可以在这个文件中设置，但你会发现重新电脑，他不清理/tmp文件夹里面的内容，这是为什么呢？这就是tmpwatch他所在的位置决定的，他的上层目录是/etc/cron.daily/，而这个目录是第天执行一次计划任务，所以说，你设置了比一天更短的时间，他就不起作用了。这下明白了吧。
*所以结论是：在RHEL6中，系统自动清理/tmp文件夹的默认时限是30天*

****** 在Debian\Ubuntu系统中（Ubuntu10.10为实验环境）

在Ubuntu系统中，在/tmp文件夹里面的内容，每次开机都会被清空，如果不想让他自动清理的话，只需要更改rcS文件中的TMPTIME的值。
我们看如何来修改
sudo vi /etc/default/rcS
把
TMPTIME=0
修改成
TMPTIME=-1或者是无限大
改成这样的话，系统在重新启动的时候就不会清理你的/tmp目录了。
依些类推，如果说要限制多少时间来更改的话，就可以改成相应的数字（本人没有测试，我是这么理解的）

*所以结论是：在Ubuntu中，系统自动清理/tmp文件夹的时限默认每次启动*

** [[http://www.chinaunix.net/old_jh/4/438660.html][Linux的用户和用户组管理
]]
Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。

实现用户账号的管理，要完成的工作主要有如下几个方面：
· 用户账号的添加、删除与修改。
· 用户口令的管理。
· 用户组的管理。


一、Linux系统用户账号的管理

用户账号的管理工作主要涉及到用户账号的添加、修改和删除。

添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。

1、添加新的用户账号使用useradd命令，其语法如下：


useradd 选项 用户名


其中各选项含义如下：

-c comment 指定一段注释性描述。

-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。

-g 用户组 指定用户所属的用户组。

-G 用户组，用户组 指定用户所属的附加组。

-s Shell文件 指定用户的登录Shell。

-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。

用户名 指定新账号的登录名。


2、例子说明

例1：


# useradd –d /usr/sam -m sam


此命令创建了一个用户sam，
其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam（/usr为默认的用户主目录所在的父目录）。


例2：


# useradd -s /bin/sh -g group –G adm,root gem


此命令新建了一个用户gem，该用户的登录Shell是/bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。
这里可能新建组：#groupadd group及groupadd adm　

增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。

Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。


3、删除帐号

如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。删除一个已有的用户账号使用userdel命令，其格式如下：


userdel 选项 用户名


常用的选项是-r，它的作用是把用户的主目录一起删除。

例如：


# userdel sam


此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。


4、修改帐号

修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。

修改已有用户的信息使用usermod命令，其格式如下：


usermod 选项 用户名


常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。另外，有些系统可以使用如下选项：


 -l 新用户名


这个选项指定一个新的账号，即将原来的用户名改为新的用户名。

例如：


# usermod -s /bin/ksh -d /home/z –g developer sam


此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。


5、用户口令的管理

用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。

指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：


passwd 选项 用户名


可使用的选项：

-l 锁定口令，即禁用账号。

-u 口令解锁。

-d 使账号无口令。

-f 强迫用户下次登录时修改口令。

如果默认用户名，则修改当前用户的口令。


例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：

$ passwd

Old password:******

New password:*******

Re-enter new password:*******


如果是超级用户，可以用下列形式指定任何用户的口令：

# passwd sam

New password:*******

Re-enter new password:*******


普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。

为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。

为用户指定空口令时，执行下列形式的命令：


# passwd -d sam


此命令将用户sam的口令删除，这样用户sam下一次登录时，系统就不再询问口令。

passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如：


# passwd -l sam



 wingger 回复于：2004-11-04 13:03:40

二、Linux系统用户组的管理

每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。
用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。

1、增加一个新的用户组使用groupadd命令。其格式如下：

groupadd 选项 用户组

可以使用的选项有：
-g GID 指定新用户组的组标识号（GID）。

-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。

例1：

# groupadd group1

此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。

例2：

#groupadd -g 101 group2

此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。

2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下：

groupdel 用户组

例如：

#groupdel group1

此命令从系统中删除组group1。

3、修改用户组的属性使用groupmod命令。其语法如下：

groupmod 选项 用户组

常用的选项有：
-g GID 为用户组指定新的组标识号。

-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。

-n新用户组 将用户组的名字改为新名字


例1：

# groupmod -g 102 group2

此命令将组group2的组标识号修改为102。

例2：

# groupmod –g 10000 -n group3 group2

此命令将组group2的标识号改为10000，组名修改为group3。

4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：

$ newgrp root

这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。

 wingger 回复于：2004-11-04 13:21:16

三、与用户账号有关的系统文件

完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。下面分别介绍这些文件的内容。

1、/etc/passwd文件是用户管理工作涉及的最重要的一个文件。Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。这个文件对所有用户都是可读的。它的内容类似下面的例子：

＃ cat /etc/passwd



root:x:0:0:Superuser:/:

daemon:x:1:1:System daemons:/etc:

bin:x:2:2:Owner of system commands:/bin:

sys:x:3:3:Owner of system files:/usr/sys:

adm:x:4:4:System accounting:/usr/adm:

uucp:x:5:5:UUCP administrator:/usr/lib/uucp:

auth:x:7:21:Authentication administrator:/tcb/files/auth:

cron:x:9:16:Cron daemon:/usr/spool/cron:

listen:x:37:4:Network daemon:/usr/net/nls:

lp:x:71:18:Printer administrator:/usr/spool/lp:

sam:x:200:50:Sam san:/usr/sam:/bin/sh


从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：


用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell


1）“用户名”是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。

2）“口令”一些系统中，存放着加密后的用户口令字。。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。

3）“用户标识号”是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。

通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。

4）“组标识号”字段记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。

5)“注释性描述”字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。

6)“主目录”，也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。

7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。

用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。


8)系统中有一类用户称为伪用户（psuedo users），这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下所示。

伪  用  户         含     义

 bin                        拥有可执行的用户命令文件

 sys                       拥有系统文件

 adm                     拥有帐户文件

 uucp                    UUCP使用

 lp                         lp或lpd子系统使用

 nobody                 NFS使用

 拥有帐户文件

除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。

由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。只有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。


2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生。它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用“:”隔开。这些字段是：


登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志


1）“登录名”是与/etc/passwd文件中的登录名相一致的用户账号
2）“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。
3）“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。
4）“最小时间间隔”指的是两次修改口令之间所需的最小天数。
5）“最大时间间隔”指的是口令保持有效的最大天数。
6）“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。
7）“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。
8）“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。

下面是/etc/shadow的一个例子：


＃ cat /etc/shadow



root:Dnakfw28zf38w:8764:0:168:7:::

daemon:*::0:0::::

bin:*::0:0::::

sys:*::0:0::::

adm:*::0:0::::

uucp:*::0:0::::

nuucp:*::0:0::::

auth:*::0:0::::

cron:*::0:0::::

listen:*::0:0::::

lp:*::0:0::::

sam:EkdiSECLWPdSa:9740:0:0::::



3、用户组的所有信息都存放在/etc/group文件中。

将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：


组名:口令:组标识号:组内用户列表


1）“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。
2）“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。
3）“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。
4）“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。

/etc/group文件的一个例子如下：

# cat /etc/group

root::0:root

bin::2:root,bin

sys::3:root,uucp

adm::4:root,adm

daemon::5:root,daemon

lp::7:root,lp

users::20:root,sam


 wingger 回复于：2004-11-04 13:31:28

四、添加量用户批

添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：

（1）先编辑一个文本用户文件，每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：

user001::600:100:user:/home/user001:/bin/bash

user002::601:100:user:/home/user002:/bin/bash

user003::602:100:user:/home/user003:/bin/bash

user004::603:100:user:/home/user004:/bin/bash

user005::604:100:user:/home/user005:/bin/bash

user006::605:100:user:/home/user006:/bin/bash


（2）以root身份执行命令/usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户：


# newusers < user.txt


然后可以执行命令vipw或vi /etc/passwd检查/etc/passwd文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。

（3）执行命令/usr/sbin/pwunconv，将/etc/shadow产生的shadow密码解码，然后回写到/etc/passwd中，并将/etc/shadow的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消shadow password功能。


# pwunconv


（4）编辑每个用户的密码对照文件，范例文件passwd.txt内容如下：

user001:密码

user002:密码

user003:密码

user004:密码

user005:密码

user006:密码


（5）以root身份执行命令/usr/sbin/chpasswd，创建用户密码，chpasswd会将经过/usr/bin/passwd命令编码过的密码写入/etc/passwd的密码栏。


# chpasswd < passwd.txt


（6）确定密码经编码写入/etc/passwd的密码栏后，执行命令/usr/sbin/pwconv将密码编码为shadow password，并将结果写入/etc/shadow。


# pwconv


这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。

 wingger 回复于：2004-11-04 13:39:12

五、赋予普通用户特殊权限

在Linux系统中，管理员往往不止一人，若每位管理员都用root身份进行管理工作，根本无法弄清楚谁该做什么。所以最好的方式是：管理员创建一些普通用户，分配一部分系统管理工作给他们。

我们不可以使用su让他们直接变成root，因为这些用户都必须知道root的密码，这种方法很不安全，而且也不符合我们的分工需求。一般的做法是利用权限的设置，依工作性质分类，让特殊身份的用户成为同一个工作组，并设置工作组权限。例如：要wwwadm这位用户负责管理网站数据，一般Apache Web Server的进程httpd的所有者是www，您可以设置用户wwwadm与www为同一工作组，并设置Apache默认存放网页目录/usr/local/httpd/htdocs的工作组权限为可读、可写、可执行，这样属于此工作组的每位用户就可以进行网页的管理了。

但这并不是最好的解决办法，例如管理员想授予一个普通用户关机的权限，这时使用上述的办法就不是很理想。这时您也许会想，我只让这个用户可以以root身份执行shutdown命令就行了。完全没错，可惜在通常的Linux系统中无法实现这一功能，不过已经有了工具可以实现这样的功能——sudo。

sudo通过维护一个特权到用户名映射的数据库将特权分配给不同的用户，这些特权可由数据库中所列的一些不同的命令来识别。为了获得某一特权项，有资格的用户只需简单地在命令行输入sudo与命令名之后，按照提示再次输入口令（用户自己的口令，不是root用户口令）。例如，sudo允许普通用户格式化磁盘，但是却没有赋予其他的root用户特权。

1、sudo工具由文件/etc/sudoers进行配置，该文件包含所有可以访问sudo工具的用户列表并定义了他们的特权。一个典型的/etc/sudoers条目如下：


liming ALL=(ALL) ALL


这个条目使得用户liming作为超级用户访问所有应用程序，如用户liming需要作为超级用户运行命令，他只需简单地在命令前加上前缀sudo。因此，要以root用户的身份执行命令format，liming可以输入如下命令：


# sudo /usr/sbin/useradd sam


注意：命令要写绝对路径，/usr/sbin默认不在普通用户的搜索路径中，或者加入此路径：PATH=$PATH:/usr/sbin;export PATH。另外，不同系统命令的路径不尽相同，可以使用命令“whereis 命令名”来查找其路径。

这时会显示下面的输出结果：

We trust you have received the usual lecture from the local System

Administrator. It usually boils down to these two things:

#1) Respect the privacy of others.

#2) Think before you type.

Password:


如果liming正确地输入了口令，命令useradd将会以root用户身份执行。

注意：配置文件/etc/sudoers必须使用命令 Visudo来编辑。

只要把相应的用户名、主机名和许可的命令列表以标准的格式加入到文件/etc/sudoers，并保存就可以生效，再看一个例子。

2、例子：管理员需要允许gem用户在主机sun上执行reboot和shutdown命令，在/etc/sudoers中加入：


gem sun=/usr/sbin/reboot，/usr/sbin/shutdown


注意：命令一定要使用绝对路径，以避免其他目录的同名命令被执行，从而造成安全隐患。

然后保存退出，gem用户想执行reboot命令时，只要在提示符下运行下列命令：


$ sudo /usr/sbin/reboot


输入正确的密码，就可以重启服务器了。

如果您想对一组用户进行定义，可以在组名前加上%，对其进行设置，如：


%cuug ALL=(ALL) ALL


3、另外，还可以利用别名来简化配置文件。别名类似组的概念，有用户别名、主机别名和命令别名。多个用户可以首先用一个别名来定义，然后在规定他们可以执行什么命令的时候使用别名就可以了，这个配置对所有用户都生效。主机别名和命令别名也是如此。注意使用前先要在/etc/sudoers中定义：User_Alias, Host_Alias, Cmnd_Alias项，在其后面加入相应的名称，也以逗号分隔开就可以了，举例如下：

Host_Alias SERVER=no1

User_Alias ADMINS=liming，gem

Cmnd_Alias SHUTDOWN=/usr/sbin/halt，/usr/sbin/shutdown，/usr/sbin/reboot

ADMINS SERVER=SHUTDOWN


4、再看这个例子：


ADMINS ALL=(ALL) NOPASSWD: ALL


表示允许ADMINS不用口令执行一切操作，其中“NOPASSWD:”项定义了用户执行操作时不需要输入口令。

5、sudo命令还可以加上一些参数，完成一些辅助的功能，如


$ sudo –l


会显示出类似这样的信息：

User liming may run the following commands on this host:

(root) /usr/sbin/reboot


说明root允许用户liming执行/usr/sbin/reboot命令。这个参数可以使用户查看自己目前可以在sudo中执行哪些命令。

6、在命令提示符下键入sudo命令会列出所有参数，其他一些参数如下：

-V 显示版本编号。

-h 显示sudo命令的使用参数。

-v 因为sudo在第一次执行时或是在N分钟内没有执行（N预设为5）会询问密码。这个参数是重新做一次确认，如果超过N分钟，也会问密码。

-k 将会强迫使用者在下一次执行sudo时询问密码（不论有没有超过N分钟）。

-b 将要执行的命令放在背景执行。

-p prompt 可以更改问密码的提示语，其中%u会替换为使用者的账号名称，%h会显示主机名称。

-u username/#uid 不加此参数，代表要以root的身份执行命令，而加了此参数，可以以username的身份执行命令（#uid为该username的UID）。

-s 执行环境变量中的 SHELL 所指定的 Shell ，或是 /etc/passwd 里所指定的 Shell。

-H 将环境变量中的HOME（宿主目录）指定为要变更身份的使用者的宿主目录。（如不加-u参数就是系统管理者root。）


 要以系统管理者身份（或以-u更改为其他人）执行的命令。

** [[http://www.cnblogs.com/sopost/archive/2013/01/09/2853200.html][Linux┊详解udev]]

如果你使用Linux比较长时间了，那你就知道，在对待设备文件这块，Linux改变了几次策略。在Linux早期，设备文件仅仅是是一些带有适当的属性集的普通文件，它由mknod命令创建，文件存放在/dev目录下。后来，采用了devfs,
一个基于内核的动态设备文件系统，他首次出现在2.3.46内核中。Mandrake，Gentoo等Linux分发版本采用了这种方式。devfs创建
的设备文件是动态的。但是devfs有一些严重的限制，从2.6.13版本后移走了。目前取代他的便是文本要提到的udev－－一个用户空间程序。

目前很多的Linux分发版本采纳了udev的方式，因为它在Linux设备访问，特别是那些对设备有极端需求的站点(比如需要控制上千个硬盘)和热插拔设备(比如USB摄像头和MP3播放器)上解决了几个问题。下面我我们来看看如何管理udev设备。
实际上，对于那些为磁盘，终端设备等准备的标准配置文件而言，你不需要修改什么。但是，你需要了解udev配置来使用新的或者外来设备，如果不修改配置，
这些设备可能无法访问，或者说Linux可能会采用不恰当的名字，属组或权限来创建这些设备文件。你可能也想知道如何修改RS－232串口，音频设备等文件的属组或者权限。这点在实际的Linux实施中是会遇到的。

为什么使用udev

在此之前的设备文件管理方法(静态文件和devfs)有几个缺点：

*不确定的设备映射。特别是那些动态设备，比如USB设备，设备文件到实际设备的映射并不可靠和确定。举一个例子：如果你有两个USB打印机。一个可能称
为/dev/usb/lp0,另外一个便是/dev/usb/lp1。但是到底哪个是哪个并不清楚，lp0,lp1和实际的设备没有一一对应的关系，因为
他可能因为发现设备的顺序，打印机本身关闭等原因而导致这种映射并不确定。理想的方式应该是：两个打印机应该采用基于他们的序列号或者其他标识信息的唯一
设备文件来映射。但是静态文件和devfs都无法做到这点。

*没有足够的主/辅设备号。我们知道，每一个设备文件是有两个8位的数字：一个是主设备号
，另外一个是辅设备号来分配的。这两个8位的数字加上设备类型(块设备或者字符设备)来唯一标识一个设备。不幸的是，关联这些身边的的数字并不足够。

*/dev目录下文件太多。一个系统采用静态设备文件关联的方式，那么这个目录下的文件必然是足够多。而同时你又不知道在你的系统上到底有那些设备文件是激活的。

*命名不够灵活。尽管devfs解决了以前的一些问题，但是它自身又带来了一些问题。其中一个就是命名不够灵活；你别想非常简单的就能修改设备文件的名字。缺省的devfs命令机制本身也很奇怪，他需要修改大量的配置文件和程序。

*内核内存使用，devfs特有的另外一个问题是，作为内核驱动模块，devfs需要消耗大量的内存，特别当系统上有大量的设备时(比如上面我们提到的系统一个上有好几千磁盘时)

udev的目标是想解决上面提到的这些问题，他通采用用户空间(user-space)工具来管理/dev/目录树，他和文件系统分开。知道如何改变缺省配置能让你之大如何定制自己的系统，比如创建设备字符连接，改变设备文件属组，权限等。

udev配置文件

主要的udev配置文件是/etc/udev/udev.conf。这个文件通常很短，他可能只是包含几行#开头的注释，然后有几行选项：

udev_root=“/dev/”
udev_rules=“/etc/udev/rules.d/”
udev_log=“err“

上面的第二行非常重要，因为他表示udev规则存储的目录，这个目录存储的是以.rules结束的文件。每一个文件处理一系列规则来帮助udev分配名字给设备文件以保证能被内核识别。
你的/etc/udev/rules.d下面可能有好几个udev规则文件，这些文件一部分是udev包安装的，另外一部分则是可能是别的硬件或者软件包
生成的。比如在Fedora Core
5系统上，sane-backends包就会安装60-libsane.rules文件，另外initscripts包会安装60-net.rules文
件。这些规则文件的文件名通常是两个数字开头，它表示系统应用该规则的顺序。

规则文件里的规则有一系列的键/值对组成，键/值对之间用逗号(,)分割。每一个键或者是用户匹配键，或者是一个赋值键。匹配键确定规则是否被应用，而赋
值键表示分配某值给该键。这些值将影响udev创建的设备文件。赋值键可以处理一个多值列表。匹配键和赋值键操作符解释见下表：

udev 键/值对操作符

操作符  匹配或赋值  解释
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
==  匹配  相等比较
!=  匹配  不等比较
=  赋值
分配一个特定的值给该键，他可以覆盖之前的赋值。
+=  赋值  追加特定的值给已经存在的键
:=  赋值
分配一个特定的值给该键，后面的规则不可能覆盖它。

这有点类似我们常见的编程语言，比如C语言。只是这里的键一次可以处理多个值。有一些键在udev规则文件里经常出现，这些键的值可以使用通配符(*,?,甚至范围，比如[0-9])，这些常用键列举如下：

常用udev键
键  含义
ACTION
一个时间活动的名字，比如add，当设备增加的时候
KERNEL
在内核里看到的设备名字，比如sd*表示任意SCSI磁盘设备
DEVPATH  内核设备录进，比如/devices/*
SUBSYSTEM  子系统名字，比如sound,net
BUS  总线的名字，比如IDE,USB
DRIVER  设备驱动的名字，比如ide-cdrom
ID  独立于内核名字的设备名字
SYSFS{ value}  sysfs属性值，他可以表示任意
ENV{ key}  环境变量，可以表示任意
PROGRAM
可执行的外部程序，如果程序返回0值，该键则认为为真(true)
RESULT  上一个PROGRAM调用返回的标准输出。
NAME
根据这个规则创建的设备文件的文件名。注意：仅仅第一行的NAME描述是有效的，后面的均忽略。
如果你想使用使用两个以上的名字来访问一个设备的话，可以考虑SYMLINK键。
SYMLINK  根据规则创建的字符连接名
OWNER  设备文件的属组
GROUP  设备文件所在的组。
MODE  设备文件的权限，采用8进制
RUN  为设备而执行的程序列表
LABEL
在配置文件里为内部控制而采用的名字标签(下下面的GOTO服务)
GOTO
跳到匹配的规则（通过LABEL来标识），有点类似程序语言中的GOTO
IMPORT{ type}
导入一个文件或者一个程序执行后而生成的规则集到当前文件
WAIT_FOR_SYSFS
等待一个特定的设备文件的创建。主要是用作时序和依赖问题。
PTIONS  特定的选项： last_rule
对这类设备终端规则执行； ignore_device 忽略当前规则； ignore_remove
忽略接下来的并移走请求。all_partitions 为所有的磁盘分区创建设备文件。

我们给出一个列子来解释如何使用这些键。下面的例子来自Fedora Core
5系统的标准配置文件。



KERNEL=="*", OWNER="root" GROUP="root", MODE="0600"
KERNEL=="tty", NAME="%k", GROUP="tty", MODE="0666",
OPTIONS="last_rule"
KERNEL=="scd[0-9]*", SYMLINK+="cdrom cdrom-%k"
KERNEL=="hd[a-z]", BUS=="ide", SYSFS{removable}=="1",
  SYSFS{device/media}=="cdrom", SYMLINK+="cdrom cdrom-%k"
ACTION=="add", SUBSYSTEM=="scsi_device", RUN+="/sbin/modprobe
sg"上面的例子给出了5个规则，每一个都是KERNEL或者ACTION键开头：

*第一个规则是缺省的，他匹配任意被内核识别到的设备，然后设定这些设备的属组是root，组是root，访问权限模式是0600(-rw-------)。这也是一个安全的缺省设置保证所有的设备在默认情况下只有root可以读写

*第二个规则也是比较典型的规则了。它匹配终端设备(tty)，然后设置新的权限为0600，所在的组是tty。它也设置了一个特别的设备文件名:%K。在这里例子里，%k代表设备的内核名字。那也就意味着内核识别出这些设备是什么名字，就创建什么样的设备文件名。

*第三行开始的KERNEL==”scd[0-9]*”,表示 SCSI CD-ROM 驱动.
它创建一对设备符号连接：cdrom和cdrom-%k。

*第四行，开始的 KERNEL==”hd[a-z]“, 表示ATA
CDROM驱动器。这个规则创建和上面的规则相同的符号连接。ATA
CDROM驱动器需要sysfs值以来区别别的ATA设备，因为SCSI
CDROM可以被内核唯一识别。.

*第五行以 ACTION==”add”开始，它告诉udev增加 /sbin/modprobe sg
到命令列表，当任意SCSI设备增加到系统后，这些命令将执行。其效果就是计算机应该会增加sg内核模块来侦测新的SCSI设备。

当然，上面仅仅是一小部分例子，如果你的系统采用了udev方式，那你应该可以看到更多的规则。如果你想修改设备的权限或者创建信的符号连接，那么你需要熟读这些规则，特别是要仔细注意你修改的那些与之相关的设备。

修改你的udev配置

在修改udev配置之前，我们一定要仔细，通常的考虑是：你最好不要修改系统预置的那些规则，特别不要指定影响非常广泛的配置，比如上面例子中的第一行。不正确的配置可能会导致严重的系统问题或者系统根本就无法这个正确的访问设备。

而我们正确的做法应该是在/etc/udev/rules.d/下创建一个信的规则文件。确定你给出的文件的后缀是rules文件名给出的数字序列应该比
标准配置文件高。比如，你可以创建一个名为99-my-udev.rules的规则文件。在你的规则文件中，你可以指定任何你想修改的配置，比如，假设你
修改修改floppy设备的所在组，还准备创建一个信的符号连接/dev/floppy，那你可以这么写：

KERNEL==”fd[0-9]*“, GROUP=“users“,  SYMLINK+=“floppy“

有些发行版本，比如Fedora，采用了外部脚本来修改某些特定设备的属组，组关系和权限。因此上面的改动可能并不见得生效。如果你遇到了这个问题，你就需要跟踪和修改这个脚本来达到你的目的。或者你可以修改PROGRAM或RUN键的值来做到这点。

某些规则的修改可能需要更深的挖掘。比如，你可能想在一个设备上使用sysfs信息来唯一标识一个设备。这些信息最好通过udevinfo命令来获取。

$ udevinfo --a --p $(udevinfo --q path  --n
/dev/hda)上面的命令两次使用udevinfo：一次是返回sysfs设备路径(他通常和我们看到的Linux设备文件名所在路径－－/dev/hda－－不同)；第
二次才是查询这个设备路径，结果将是非常常的syfs信息汇总。你可以找到最够的信息来唯一标志你的设备，你可以采用适当的替换udev配置文件中的
SYSFS选项。下面的结果就是上面的命令输出



[root@localhost rules.d]# udevinfo -a -p $(udevinfo -q path
-n  /dev/hda1)
Udevinfo starts with the device specified by the devpath and then walks
up the chain of
parent devices. It prints for every device found,all possible attributes
in the udev rules
key format. A rule to match, can be composed by the attributes of the
device and the
attributes from one single parent device.

looking at device '/block/hda/hda1':
KERNEL=="hda1"  SUBSYSTEM=="block"  DRIVER==""
ATTR{stat}=="  1133  2268  2
4"  ATTR{size}=="208782"
ATTR{start}=="63"  ATTR{dev}=="3:1"  looking at parent
device '/block/hda':

KERNELS=="hda"  SUBSYSTEMS=="block"  DRIVERS==""
ATTRS{stat}=="28905 18814 1234781 302540 34087 133247 849708 981336 0
218340 1283968"
ATTRS{size}=="117210240"  ATTRS{removable}=="0"
ATTRS{range}=="64"  ATTRS{dev}=="3:0"

looking at parent device
'/devices/pci0000:00/0000:00:1f.1/ide0/0.0':

KERNELS=="0.0"  SUBSYSTEMS=="ide"  DRIVERS=="ide-disk"
ATTRS{modalias}=="ide:m-disk"  ATTRS{drivename}=="hda"
ATTRS{media}=="disk"
looking at parent device '/devices/pci0000:00/0000:00:1f.1/ide0':

KERNELS=="ide0"  SUBSYSTEMS==""  DRIVERS==""
looking at parent device '/devices/pci0000:00/0000:00:1f.1':
KERNELS=="0000:00:1f.1"  SUBSYSTEMS=="pci"
DRIVERS=="PIIX_IDE"
ATTRS{broken_parity_status}=="0"  ATTRS{enable}=="1"
ATTRS{modalias}=="pci:v00008086d000024CAsv0000144Dsd0000C009bc01sc01i8a"
ATTRS{local_cpus}=="1"  ATTRS{irq}=="11"
ATTRS{class}=="0x01018a"
ATTRS{subsystem_device}=="0xc009"
ATTRS{subsystem_vendor}=="0x144d"
ATTRS{device}=="0x24ca"  ATTRS{vendor}=="0x8086"
looking at parent device '/devices/pci0000:00':

KERNELS=="pci0000:00"  SUBSYSTEMS==""  DRIVERS==""
举一个例子：假设你想修改USB扫描仪的配置。通过一系列的尝试，你已经为这个扫描仪标识了Linux设备文件(每次打开扫描仪时，名字都会变)。你可以使
用上面的命令替换这个正确的Linux设备文件名，然后定位输出的采用SYSFS{idVendor}行和SYSFS{idProduct}行。最后你可
以使用这些信息来为这个扫描仪创建新的选项。

SYSFS{idVendor}=="0686",  SYSFS{idProduct}=="400e",
SYMLINK+="scanner", MODE="0664",
group="scanner"上面的例子表示将扫描仪的组设置为scanner，访问权限设置为0664,同时创建一个/dev/scanner的符号连接。

udev-FAQ

问：udev是什么? 它的目的何在?

答：udev是一种工具，它能够根据系统中的硬件设备的状态动态更新设备文件，包括设备文件的创建，删除等。设备文件通常放在/dev目录下。使用udev后，在/dev目录下就只包含系统中真正存在的设备。

问：udev支持什么内核？

答：udev只支持linux-2.6内核，因为udev严重依赖于sysfs文件系统提供的信息，而sysfs文件系统只在linux-2.6内核中才有。

问：udev是一个内核程序还是用户程序？

答：udev是一个用户程序(user-mode daemon)。

问：udev和devfs有什么差别？

答：udev能够实现所有devfs实现的功能。但udev运行在用户模式中，而devfs运行在内核模式中。据称：devfs具有一些不太容易解决的先天缺陷。

问：udev的配置文件放在哪里？

答：udev是一个用户模式程序。它的配置文件是/etc/udev/udev.conf。这个文件一般缺省有这样几项：

udev_root=”/dev” ; udev产生的设备文件的根目录是/dev
udev_db=”/dev/.udevdb” ; 通过udev产生的设备文件形成的数据库
udev_rules=”/etc/udev/rules.d” ;用于指导udev工作的规则所在目录。
udev_log=”err” ;当出现错误时，用syslog记录错误信息。

问：udev的工作过程是怎样的？

答：由于没有研究过udev的源程序，不敢贸然就说udev的工作过程。我只是通过一些网上的资料和udev的说明文档，大致猜测它的工作过程可能是这样的。

当内核检测到在系统中出现了新设备后，内核会在sysfs文件系统中为该新设备生成一项新的记录，一般sysfs文件系统会被mount到/sys目录中。新记录是以一个或多个文件或目录的方式来表示。每个文件都包含有特定的信息。(信息是如何表述的，还要另外研究？)

udev在系统中是以守护进程的方式udevd在运行，它通过某种途径(到底什么途径，目前还没搞懂。)检测到新设备的出现，通过查找设备对应的sysfs中的记录得到设备的一些信息。

udev会根据/etc/udev/udev.conf文件中的udev_rules指定的目录，逐个检查该目录下的文件，这个目录下的文件都是针对某类或某个设备应该施行什么措施的规则文件。udev读取文件是按照文件名的ASCII字母顺序来读取的，如果udev一旦找到了与新加入的设备匹配的规则，udev就会根据规则定义的措施对新设备进行配置。同时不再读后续的规则文件。

问：udev的规则文件的语法是怎样的？

答：udev的规则文件以行为单位，以”#”开头的行代表注释行。其余的每一行代表一个规则。每个规则分成一个或多个“匹配”和“赋值”部分。“匹配”部分用“匹配“专用的关键字来表示，相应的“赋值”部分用“赋值”专用的关键字来表示。“匹配”关键字包括：ACTION，KERNEL，BUS，SYSFS等等，“赋值”关键字包括：NAME，SYMLINK，OWNER等等。具体详细的描述可以阅读udev的man文档。

下面举个例子来说明一下，有这样一条规则：SUBSYSTEM==”net”, ACTION==”add”,
SYSFS{address}==”00:0d:87:f6:59:f3″, IMPORT=”/sbin/rename_netiface %k
eth0″
这个规则中的“匹配”部分有三项，分别是SUBSYSTEM，ACTION和SYSFS。而”赋值”部分有一项，是IMPORT。这个规则就是说，当系统中出现的新硬件属于net子系统范畴，系统对该硬件采取的动作是加入这个硬件，且这个硬件在SYSFS文件系统中的“address”信息等于“00：0d...”时，对这个硬件在udev层次施行的动作是调用外部程序/sbin/rename_netiface，传递的参数有两个，一个是“%k”，代表内核对该新设备定义的名称。另一个是”eth0“。
从上面这个例子中可以看出，udev的规则的写法比较灵活的，尤其在“匹配”部分中，可以通过诸如”*“,
”?“,[a-c],[1-9]等shell通配符来灵活匹配多个匹配项。具体的语法可以参考udev的man文档。

问：udev怎样做到不管设备连接的顺序而维持一个统一的设备名？

答：实际上，udev是通过对内核产生的设备名增加别名的方式来达到上述目的的。前面说过，udev是用户模式程序，不会更改内核的行为。因此，内核依然会我行我素地产生设备名如sda,sdb等。但是，udev可以根据设备的其他信息如总线（bus），生产商（vendor）等不同来区分不同的设备，并产生设备文件。udev只要为这个设备文件取一个固定的文件名就可以解决这个问题。在后续对设备的操作中，只要引用新的设备名就可以了。但为了保证最大限度的兼容，一般来说，新设备名总是作为一个对内核自动产生的设备名的符号链接（link）来使用的。

例如：内核产生了sda设备名，而根据信息，这个设备对应于是我的内置硬盘，那我就可以制定udev规则，让udev除了产生/dev/sda设备文件外，另外创建一个符号链接叫/dev/internalHD。这样，我在fstab文件中，就可以用/dev/internalHD来代替原来的/dev/sda了。下次，由于某些原因，这个硬盘在内核中变成了sdb设备名了，那也不用着急，udev还会自动产生/dev/internalHD这个链接，并指向正确的/dev/sdb设备。所有其他的文件像fstab等都不用修改。

问：怎样才能找到这些设备信息，并把他们放到udev的规则文件中来匹配呢？

答：这个问题比较难，网上资料不多，我只找到一篇文章来介绍如何写udev的规则。他的基本方法是通过udevinfo这个实用程序来找到那些可以作为规则文件里的匹配项的项目。有这样两种情况可以使用这个工具：

第一种情况是，当你把设备插入系统后，系统为设备产生了设备名（如/dev/sda）。那样的
话，你先用udevinfo -q path
-n/dev/sda，命令会产生一个该设备名对应的在sysfs下的路径，如/block/sda。然后，你再用udevinfo
-a
-p/sys/block/sda，这个命令会显示一堆信息，信息分成很多块。这些信息实际来自于操作系统维护的sysfs链表，不同的块对应不同的路径。你就可以用这些信息来作为udev规则文件中的匹配项。但需要注意的是，同一个规则只能使用同一块中显示的信息，不能跨块书写规则。

第二种情况是，不知道系统产生的设备名，那就只有到/sys目录下去逐个目录查找了，反复用udevinfo　-a
-p/sys/path...这个命令看信息，如果对应的信息是这个设备的，那就恭喜你。否则就再换个目录。当然，在这种情况下，成功的可能性比较小。

问: udev和devfs是什么关系
答:
udev完全在用户态(userspace)工作，利用设备加入或移除时内核所发送的hotplug事件(event)来工作。关于设备的详细信息是由内核输出(export)到位于/sys的sysfs文件系统的。所有的设备命名策略、权限控制和事件处理都是在用户态下完成的。与此相反，devfs是作为内核的一部分工作的。

问:
如果udev不能完成所有devfs的工作的话，为什么把devfs标记为OBSOLETE/removed?

答: 引用 Al Viro (Linux VFS 内核维护者):

-devfs所做的工作被确信可以在用户态来完成。
-devfs被加入内核之时，大家寄望它的质量可以迎头赶上。
-devfs被发现了一些可修复和无法修复的 bug。
-对于可修复的 bug，几个月前就已经被修复了，其维护者认为一切良好。
-对于后者，同样是相当常一段时间以来没有改观了。
-devfs的维护者和作者对它感到失望并且已经停止了对代码的维护工作。

问:
但是当一个并不存在的/dev节点被打开的时候，udev并不能如devfs一样自动加载驱动程序。
答:
的确如此，但Linux的设计是在设备被发现的时候加载模块，而不是当它被访问的时候。

问: 不过等等，我确实希望 udev
可以在不存在的节点被打开的时候自动加载驱动。这是我使用devfs的唯一原因了。给udev
增加这个功能吧。
答: 不，udev 是用来管理/dev 的，不是用来加载内核驱动的。

问: 嗨，求你们了。这不难做到的。
答:
这么个功能对于一个配置正确的计算机是多余的。系统中所有的设备都应该产生hotplug
事件、加载恰当的驱动，而 udev
将会注意到这点并且为它创建对应的设备节点。如果你不想让所有的设备驱动停留在内存之中，应该使用其它东西来管理你的模块(如脚本,
modules.conf, 等等) 这不是udev 的工作。

问: 但是我真的喜欢那个功能，还是加上吧
答:
devfs用的方法导致了大量无用的modprobe尝试，以此程序探测设备是否存在。每个试探性探测都新建一个运行
modprobe 的进程，而几乎所有这些都是无用的。

问: 我喜欢devfs的设备文件命名方式，udev 可以这样命名么?
答: 可以，udev 可以使用 /dev
的命名策略来创建节点。通过一个配置文件，可以把内核缺省的名字映射到 devfs
的名字。可以看看udev 中带的 udev.rules.devfs 文件。注意: devfs
的命名方式是不被建议并且不被官方支持的，因为它所用的简单枚举设备的方式在设备可能被随时加入或删除的情况下确实是一个比较笨的方法。这些编号代给你的将只有麻烦，而并不能用来确定设备。看看那个永久性磁盘
(persistentdisk)
的规则就知道如何在用户态下正确的做这件事，而不是傻傻地列出设备。

问: udev 可以为哪些设备创建节点?
答: 所有在 sysfs 中显示的设备都可以由 udev
来创建节点。如果内核中增加了其它设备的支持，udev
也就自动地可以为它们工作了。现在所有的块设备都在被支持之列，大部分的主字符设备也是被支持的。内核开发者们正致力于让所有的字符设备都被支持。可以到linux-kernel邮件列表上寻找补丁或是查看补丁的状态。

问: udev 是否会去掉匿名设备数量的限制?
答: udev 完全工作于用户态。如果内核支持了更多的匿名设备，udev就会支持。

问: udev 是否会支持符号链接?
答: udev 现在就支持符号链接，每个设备节点拥有多个符号链接也是被支持的。

问: udev如何处理/dev文件系统?
答: 建议使用一个每次启动系统的时候重新创建的 tmpfs 作为 /dev
的文件系统。不过实际上udev并不关心那种文件系统在被使用。

问: 在 init 运行之前，udev 如何处理设备?
答: udev 可以被放入 initramfs
之中，并在每个设备被发现的时候运行。也可以让udev
工作在一个真的根分区被加载之后根据 /sys 的内容创建的初始/dev目录之中。

问: 我是否可以利用 udev 在一个 USB 设备被加载的时候自动加载上这个设备?
答: 技术上讲是可以的，但是 udev 不是用于这个工作的。所有的主流发布版
(distro)都包含了 HAL ([[http://freedesktop.org/wiki/Software_2fhal]])
用于这个工作，它也是专门用于监视设备变更的，并且集成进入了桌面软件。

换个角度说，这可以简单的通过 fstab 来实现:/dev/disk/by-label/PENDRIVE
/media/PENDRIVE vfat user,noauto 0 0
这样，用户可以用如下命令来访问设备:
$mount /media/PENDRIVE
同样不需要管理员权限，但却拥有了设备的全部访问权限。使用永久性磁盘链接(label,
uuid) 将可以指定同一设备，无论其实际上的内核名字是什么。

问: 有什么我需要注意的安全问题么?
答:
当使用动态设备编号的时候，一个给定的主/从设备号可能在不同时间对应不同的设备，如果一个用户拥有对这个节点的访问权限，并且可以创建一个到这个节点的硬链接，他就可以如此得到一个这个设备节点的拷贝。当设备被移除之后，udev
删除了设备节点，但硬链接依然存在。如果这个设备节点之后被重新使用不同的访问权限被创建的时候，其硬链接仍然可以使用先前的访问权限来访问。(同样的问题也存在在使用
PAM 改变访问权限的 login 上。)

简单的解决方案就是通过把 /dev 放在 tmpfs
这样的单独的文件系统之上来防止建立硬链接。

** [[http://albertcn.blog.163.com/blog/static/2094201452013521105128316/#crayon-51c3bb178fb44797891969-7][texlive的中文问题  ]]

采用ctex支持中文\usepackage{ctex}后，
执行xelatex时出如下错：
Invalid fontname `[SIMKAI.TTF]/ICU', contains '['

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! fontspec error: "font-not-found"
!
! The font "[SIMKAI.TTF]" cannot be found.
!
! See the fontspec documentation for further information.
!
! For immediate help type H &lt;return&gt;.
!...............................................

说明字体[SIMKAI.TTF]找不到。

texlive的ctex包的配置文件：(以mac为例，texlive为texlive2013，其它操作系统和版本类似)
/usr/local/texlive/2013/texmf-dist/tex/latex/ctex/fontset/ctex-xecjk-winfonts.def

解决方法：
1. 将Windows上的字体文件simxxx.ttf等拷贝到mac桌面上，双击安装字体
2. 列出中文字体sudo fc-list  :lang=zh-cn
/Library/Fonts/华文仿宋.ttf: STFangsong:style=常规体,標準體,Ordin?r,Normal,Regular,Normaali,Regolare,レギュラー,???,Regulier,Обычный
/Library/Fonts/楷体.ttc: STKaiti:style=常规体,標準體,Ordin?r,Normal,Regular,Normaali,Regolare,レギュラー,???,Regulier,Обычный
/System/Library/Fonts/STHeiti Medium.ttc: 黑体\-简,黑體\-簡,Heiti SC,黒体\-簡,Heiti\-??:style=中等,中黑,Medium,Halbfett,Normaali,Moyen,Medio,ミディアム,???,Médio,Средний,Normal,Media
/Library/Fonts/Microsoft/STHUPO.TTF: 华文琥珀,STHupo:style=Regular
/Library/Fonts/Microsoft/Kaiti.ttf: 楷体,KaiTi:style=Regular,Normal,oby?ejné,Standard,Κανονικ?,Normaali,Normál,Normale,Standaard,Normalny,Обычный,Normálne,Navadno,Arrunta
/Library/Fonts/楷体.ttc: 楷体\-简,楷體\-簡,Kaiti SC:style=常规体,標準體,Regular
/Library/Fonts/华文黑体.ttf: STHeiti:style=常规体,標準體,Ordin?r,Normal,Regular,Normaali,Regolare,レギュラー,???,Regulier,Обычный
/Library/Fonts/宋体.ttc: 宋体\-简,宋體\-簡,Songti SC:style=细体,細體,Light
/Library/Fonts/华文细黑.ttf: STHeiti:style=细体,細體,Mager,Fein,Light,Ohut,Fin,Leggero,ライト,???,Licht,Tynn,Leve,Светлый,Fina
/Library/Fonts/Hei.ttf: Hei:style=Regular
/Library/Fonts/Microsoft/STXINWEI.ttf: 华文新魏,STXinwei:style=Regular
/Library/Fonts/Kai.ttf: Kai:style=Regular
/Library/Fonts/Microsoft/STXINGKA.ttf: 华文行楷,STXingkai:style=Regular
/Library/Fonts/宋体.ttc: 宋体\-简,宋體\-簡,Songti SC:style=黑体,黑體,Black
/Library/Fonts/楷体.ttc: 楷体\-简,楷體\-簡,Kaiti SC:style=粗体,粗體,Bold
...


3. (可选)生成字体sudo fc-cache -fsv

4.修改texlive的ctex包的配置文件
将[SIMKAI.TTF]替换为第2步骤列出的楷体名字KaiTi即可
原文：
% ctex-xecjk-winfonts.def: Windows 的 xeCJK 字体设置，默认为六种中易字体
% vim:ft=tex

\setCJKmainfont[BoldFont={SimHei},ItalicFont={[SIMKAI.TTF]}]
  {SimSun}
\setCJKsansfont{SimHei}
\setCJKmonofont{[SIMFANG.TTF]}

\setCJKfamilyfont{zhsong}{SimSun}
\setCJKfamilyfont{zhhei}{SimHei}
\setCJKfamilyfont{zhkai}{[SIMKAI.TTF]}
\setCJKfamilyfont{zhfs}{[SIMFANG.TTF]}
% \setCJKfamilyfont{zhli}{LiSu}
% \setCJKfamilyfont{zhyou}{YouYuan}

\newcommand*{\songti}{\CJKfamily{zhsong}} % 宋体
\newcommand*{\heiti}{\CJKfamily{zhhei}}   % 黑体
\newcommand*{\kaishu}{\CJKfamily{zhkai}}  % 楷书
\newcommand*{\fangsong}{\CJKfamily{zhfs}} % 仿宋

修改后：
% ctex-xecjk-winfonts.def: Windows 的 xeCJK 字体设置，默认为六种中易字体
% vim:ft=tex

%\setCJKmainfont[BoldFont={SimHei},ItalicFont={[SIMKAI.TTF]}]
\setCJKmainfont[BoldFont={SimHei},ItalicFont={KaiTi}]
  {SimSun}
\setCJKsansfont{SimHei}
%\setCJKmonofont{[SIMFANG.TTF]}
\setCJKmonofont{FangSong}

\setCJKfamilyfont{zhsong}{SimSun}
\setCJKfamilyfont{zhhei}{SimHei}
%\setCJKfamilyfont{zhkai}{[SIMKAI.TTF]}
\setCJKfamilyfont{zhkai}{KaiTi}
%\setCJKfamilyfont{zhfs}{[SIMFANG.TTF]}
\setCJKfamilyfont{zhfs}{FangSong}
% \setCJKfamilyfont{zhli}{LiSu}
% \setCJKfamilyfont{zhyou}{YouYuan}

\newcommand*{\songti}{\CJKfamily{zhsong}} % 宋体
\newcommand*{\heiti}{\CJKfamily{zhhei}}   % 黑体
\newcommand*{\kaishu}{\CJKfamily{zhkai}}  % 楷书
\newcommand*{\fangsong}{\CJKfamily{zhfs}} % 仿宋

ok，可以支持ctex中文了。

** [[http://blog.sina.com.cn/s/blog_4d72d6e70100otue.html][使用Latex2Html (l2h)将Latex转为Html ]]

使用Latex写论文时，有一个缺点是不方便协作修改，不能使用类似于word提供的修改跟踪等功能。虽然也有很多开源的工具提供了Latex文件编辑的跟踪功能，但总体都是在Latex源码上进行修改，不方便修改人（特别是当修改人不会使用Latex）使用。我们的原则是，既然是我们请别人修改论文，当然是让修改人轻松点，我们多劳动点了。最简单的办法是将latex转成Word了，然后把word文件交给审稿人了。
将latex转成word有很多方法。最简单最完全工作量也最大的一种是用word重新撰写一遍。当文档包含大量的公式，符号时，重写一遍的工作量是很大的，不太可行。还有一种方法是将latex生成为pdf，然后在pdf上copy text，然后手动粘贴图片。对于公式和符号等，也要重新写一边或者直接粘贴为图片。这种方法还有一个问题是会在原pdf每行末尾增加一个换行，看起来非常不爽。还有一种办法是采用一些latex转word或者rtf的工具，这些工具基本上需要花钱买，而且生成的格式也不是非常完美。
个人觉得将latex转成html，然后在将html粘贴到word中是一个比较好的解决方案。本文介绍如何使用开源工具latex2html(l2h)。之所以整理一下是因为这个工具配起来不是很容易，折腾我一个上午的时间。
前提：
（1）安装Miktex，GS, GSView, Netpbm（for windows, 我用的10.27，有更新的版本）.
（2）安装Perl，如ActivePerl等。
注意：这些文件都要建议安装在C盘，各安装目录名称中不要有空格。MikTex在默认安装的目录中有空格如MikTex 2.5，把空格去掉。之所以这样做是因为Latex2html比较土，不支持路径中的空格。
（3）下载Latex2html，我用的版本是2002
（4）把下载的安装包解压到C盘一个临时目录，如C:\temp
（5）修改文件prefs.pm:
123行：
$prefs('EXTRAPATH')='C:\\TEXUTILS\\GS5.50;C:\\TEXUTILS\\NETPBM\\BIN';
中修改为（1）中各应用程序可执行文件目录，如
$prefs{'EXTRAPATH'} = 'C:\\Texs\\Ghostgum\\gsview;C:\\Texs\\gs\\gs8.53\\bin;C:\\Texs\\GnuWin32\\bin;C:\\Texs\\MiKTeX2.5\\miktex\\bin';
129 行：
$prefs('PREFIX')= 'C:\\TEXUTILS\\L2H';
将改值修改为你打算安装Latex2Html到的目录
（6）运行Config.bat，检查各项是否正确。
（7）运行test.bat，看是否正常执行。正常执行完成后在tests目录下会生成l2htest目录及输出的html文件等。无误后点击install.bat，安装latex2html到（5）中配置的目录
（8）配置Latex2html，修改l2hconf.pm 文件。
line 52
@IMAGE_TYPES = qw(gif png);
line 290
$LOCAL_ICONS = 1;
line 553
$HTML_VERSION = '3.2,math';
line 567
$UNSEGMENT = 1;
line 767
$EXTRA_IMAGE_SCALE = 2;
（9）测试，如运行latex2html.bat c:\t\mytex.tex. 对于论文，通常使用下面命令（可将下面命令做成批处理，放到latex文件目录下）：
C:\Texs\l2h\bin\latex2html -split 0 -lcase_tags -nonavigation -notop_navigation -auto_prefix -noinfo -image_type png -show_section_numbers -noaddress -numbered_footnotes CTRanking_Dou.tex
配置到这里，一个简单的latex文件应该可以转成html了。但我的论文中有大量的figure，当时为了方便，这些figure被我统一放到tex文件下的一个figures目录中了。需要手动将figures目录copy到latex2html生成的目录，如CTRanking_Dou中，同时还需要把对应的cls文件也copy过去。此外，需要把latex生成的附属文件如aux,bib文件等也copy过去。这样才能保证能够正确的生成论文中的图像文件。
到这里基本上就okay了，不过生成的html文件还是有点小问题，如公式对应的图片左边和下边有黑边，subfigure序号有问题（所有subfigure被统一编号，而不是一个figure一编），不过总体说来，还算可以了。毕竟对latex修改完后，直接执行一个命令，一个html文件就生成了。然后copy到word中，就可以交给别人去修改了。
参考资料：http://www.mayer.dial.pipex.com/l2h.htm

** [[http://zhidao.baidu.com/link?url=81iKOAaTCNYG0-Wej-I2TwGNHmTBytvj7M6GeEpb1KdHWqUE1eqLyQtYcdZqjtnlc97r3bSZyg1ZEAOAsORhuox3q33i3PdbEug-d2AmX6u][如何把Latex自动转为Word]]

论文给导师修改又产生了很多麻烦。PDF上直接加Note可读性很差。最好还是能尽量保持公式、图形、Reference的完整性，然后直接转成
Word，然后导师在Word上用审阅模式修改，我们自己在Latex对应修改。这样导师就不用面对丑陋的Latex源码了。
简单的说，我们可以这样做：
1）我们用Latex书写论文
2）我们转成Word给导师
3）导师使用Word的审阅功能，修改论文
4）我们对照修改的地方直接修改Latex
5）最后生成修改后的PDF。
这样我们方便，导师也方便。具体方式如下：
以Ubuntu的Linux系统如下：
1、安装Latex
sudo apt-get install texlive
2、安装latex2html
sudo apt-get install latex2html
3、把论文从Latex转换为html
latex2html -split +0 input.tex
(input.tex是我们的论文tex文件)
4、这时在当前目录下多出一个input目录，大家可以弄到Windows里。（相信大家都有一个Linux的远程机器）
5、这个目录就是所有的html文件，找到index.html，右键用Word打开。
6、在word里另存为.doc或者docx文件。
7、把word文档发给导师，等那些让人心惊肉跳的红字和note吧。。。
大功告成，这样比Acrobat
Pro转为word文档在格式上更加安全。所有公式、图片、表格、算法都会被变为图片或者相应格式，在word里显示没有任何问题。
(注意：使用这种办法，要求你的tex可以在latex编译出dvi没有问题，也就是说使用eps图片的没有问题，但是使用pdf，jpg图片格式的，由于使用pdflatex命令编译出PDF。这个方法就不行了，需要手动改一下html文件)。
（EPS图片问题，我一般使用ImageMagic去批处理的转jpg，pdf到eps，然后在tex文件里引用eps图片，这样就规避了无论用pdflatex或者latex都可以编译出正确的pdf和dvi，那么Latex2html就没有任何问题了）

** [[http://www.xuebuyuan.com/1673310.html][Latex之安装宏包]]

2013年07月11日 ⁄ 综合 ⁄ 共 2898字 ⁄ 字号 [[javascript:doZoom(12)][小]]
[[javascript:doZoom(13)][中]] [[javascript:doZoom(18)][大]] ⁄ 评论关闭


宏包就是Latex发行版（TexLive、MikTex等）的插件功能，通过安装不同的宏包可以获得更多的功能。一般情况下，Latex的发行版都自带了一些宏包（多是[[http://ctan.org/][CTAN]]中的），以便于使用者快速的编译。这些宏包默认安装在texmf/tex/latex/下，这里texmf是“Tex
and MetaFont”的缩写，指代Latex发行版的目录树。以Windows
 7 下MikTex2.9为例，texmf=“D:\Program Files\MiKTeX
2.9\”。宏包的功能可以通过[[http://ctan.org/][CTAN]]的搜索功能查询到。


一个宏包往往包含一个文件或多个文件，这些文件利用Tex命令定义了新的命令，用来改变Latex默认的功能。这些文件主要有两种类型：clas文件，以.cls为后缀；类型文件，以.sty为后缀。其它类型的文件多是辅助文件。当编译一篇tex文档时，如果引用某个缺失的宏包时，编译[[http://www.xuebuyuan.com/][程序]]会报package
missing的错误。当然，这些宏包是可以更新的。一个Latex发行版理论上可以安装任意多的宏包，但是，一篇文档可以使用的宏包数目是受限制的。

     虽然　Latex发行版自带的宏包已经很多，并且自带的Package
Manager也能自动从CTAN上下载和安装宏包。但是，宏包的数量远比CTAN拥有的为多。所以，下面介绍下安装宏包的三种方式：

*1. 傻瓜式安装*


第一种方式比较简单，就是下载.cls或者.sty格式的文件，直接放在编译的目录下与主文件一起运行。这种方式简单易行，但是每次使用都要复制过去，更新也不易，如果使用几十个宏包，会使得编译目录里文件过多。只适合要使用期刊模板的情况。



*2. 自动安装*


目前，多数的Latex发行版都带有宏包管理器，如TexLive的tlmgr，MikTex的Package
Manager。对于TexLive，可以使用如下命令自动安装：

#+BEGIN_EXAMPLE
    tlmgr install <package1> <package2> ...
    tlmgr remove <package1> <package2> ...
#+END_EXAMPLE

对于MikTex，使用 Start -> All Programs -> MikTex ->
Settings(admin)，记得使用管理员模式来更改。



*3. 手动安装*


手动安装相对前两种方式要稍微复杂些。如果你下载的宏包里包含sty等格式的必需文件，说明宏包已经经过编译了，可以直接跳到第三步；如果没有，对于较复杂的包，一般包含五个步骤：

（a）*提取文件*：在下载的宏包里找到后缀名为.ins格式的文件，然后运行“latex
yourfilename.ins”命令或者用Latex发行版打开ins文件进行编译。此步骤可以从dtx格式的文件中提取制定的内容并生成需要的文件。

（b）*创建文档*：接着利用dtx文件创建说明文档，运行命令“latex
yourfilename.dtx”。此步骤可以创建一个dvi格式的说明文档，以说明该宏包的功能。

（c）*安装文件*：此步是最关键的一步，也是容易出错的一步。此步骤的作用是将生成的必需文件，如cls文件和sty文件放到合适的本地位置，以便Latex发行版能够找到。关键是如何定义合适的本地位置呢？在Tex及其衍生物中，所谓合适的本地位置，就是以TDS(Tex
Directory
Structure)规则组织的文件夹及其子文件夹，也就是一个自定义的目录。一般情况，这个自定义的目录最上层的名字为texmf-local或者texmf。在不同的发行版本下，具体也不一样：

-  MacTex：Users/username/Library/texmf/.
-  Unix-type Systems：~/texmf.
-  MikTex：任意名字，但是子目录要满足一定的规则，具体规则在[[http://docs.miktex.org/manual/localadditions.html#id573803][这里]]。

TDS定义了不同类型的文件存放的位置不同。比如sty格式文件，一般放在texmf/tex/latex下不同的文件夹下，文件夹的名字即是宏包的名字。下面的表格中给出了文件存放的规则：

Where to put files from packages

Type

Directory (under =texmf/= or =texmf-local/=)

Description

.afm

fonts/afm//foundry///typeface/

Adobe Font Metrics for Type 1 fonts

.bst

bibtex/bst//packagename/

BibTeX style

.cls

tex/latex/base

Document class file

.dvi

doc

package documentation

.enc

fonts/enc

Font encoding

.fd

tex/latex/mfnfss

Font Definition files for METAFONT fonts

.fd

tex/latex/psnfss

Font Definition files for PostScript Type 1 fonts

.map

fonts/map/

Font mapping files

.mf

fonts/source/public//typeface/

METAFONT outline

.pdf

doc

package documentation

.pfb

fonts/type1//foundry///typeface/

PostScript Type 1 outline

.sty

tex/latex//packagename/

Style file: the normal package content

.tex

doc

TeX source for package documentation

.tex

tex/plain//packagename/

Plain TeX macro files

.tfm

fonts/tfm//foundry///typeface/

TeX Font Metrics for METAFONT and Type 1 fonts

.ttf

fonts/truetype//foundry///typeface/

TrueType font

.vf

fonts/vf//foundry///typeface/

TeX virtual fonts

others

tex/latex//packagename/

other types of file unless instructed otherwise

（d）*更新索引：*最后更新Latex发行版的索引文件，以便Latex发行版能找到新安装的宏包。不同的发行版使用了不同的索引器：

-  teTeX, TeX Live, fpTeX：texhash.
-  web2c: mktexlsr
-  MacTeX: MacTeX appears to do this for you.
-  MikTeX: initexmf --update-fndb；或者使用GUI，即Start -> All Programs
   -> MikTex -> Settings(admin)下第一个tab，点击“Refresh
   FNDB”按钮即可。

（e）*更新字体映射图：*如果一个宏包还顺带安装了一些字体，还应该更新字体的映射。详细方法参详[[http://www.tug.org/fonts/fontinstall.html][这里]]。

此外，还有一些老版本的宏包并没有参照TDS格式，因此只能使用前两种方式。



此文参考了Wikibooks[[http://en.wikibooks.org/wiki/LaTeX/Installing_Extra_Packages][Latex]]和[[http://tex.stackexchange.com/][stackexchange]]上的一些讨论。

** [[http://www.mjoldfield.com/atelier/2009/02/arduino-cli.html][Arduino from the command line]]

*** Retirement

2013-05-19 : I've let this languish for too long, mainly because I don't
do much with Arduinos now. Happily Sudar Muthu has taken over
maintainance of the code. His github repository is
[[https://github.com/sudar/Arduino-Makefile/]]^{1} though by the magic
of github, the old URL continues to work.

Thanks to Sudar and everyone else who has helped for keeping this alive.

*** Update News

2012-09-17 : After letting this languish for many months there's now
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz][version
0.10.]]^{2} This:

-  Supports the Leonardo board.
-  Moves the board reset code to Perl (this means you'll need the
   Device::SerialPort module).
-  Has new path handling code.

There are other small changes, for more details see the
[[https://github.com/mjoldfield/Arduino-Makefile/commits/master][commit
history.]]^{3}

The new path calculations mean that:

1. Few, if any, paths need to specified in project specific Makefiles.
2. Paths can be grabbed from the environment e.g. from .bashrc.
3. It should be easier to move projects between e.g. Mac & Linux.

However, you'll need to set up some new variables to make this work:

-  ARDMK_DIR :: Things which are included in this distribution e.g.
   ard-parse-boards
-  ARDUINO_DIR :: Things which are always in the Arduino distribution
   e.g. boards.txt, libraries, &c.
-  AVR_TOOLS_DIR :: Things which might be bundled with the Arduino
   distribution, but might come from the system. Most of the toolchain
   is like this: on Linux it's supplied by the system.

Thanks to Dan Villiom Podlaski Christiansen, Tom Hall, Scott Howard,
Kalin Kozhuharov, Rickard Lindberg, Christopher Peplin, Marc
Plano-Lesay, Jared Szechy, and Matthias Urlichs for patches and
comments.

**** Github

You can now grab the source for this from
[[https://github.com/mjoldfield/Arduino-Makefile][github.]]^{4} Besides
my version there are several others under development which offer better
integration with the IDE, support for Microchip's ChipKIT boards, and
other delights.

*** Introduction

The [[http://www.arduino.cc/][Arduino]]^{5} has done much to popularize
microcontrollers for the casual tinkerer. Its success suggests that
there's considerable value in combining a standard microcontroller (the
ATmega) and a GCC based toolchain into an easily digesible package. For
myself, it's certainly easier to just install the latest release of the
Arduino software than worry about building my own cross-compilers,
particularly when it's all new to me and consequently somewhat
confusing.

After working through the toy tutorials though, I found myself wishing
that writing code for the Arduino were more like writing other C
programs. In my case, that means editing it with emacs then building it
with make. I must emphasize that I'm not criticizing the Arduino IDE:
there's nothing wrong with it beyond it not being emacs...

It turns out that others have been along this path before: in the past
the Arduino website had a hopeful sounding ‘Arduino from the Command
Line' article, but it's gone now. There is still
[[http://arduino.cc/en/Hacking/HomePage][some information]]^{6} though
it's more limited.

Without an official Makefile, I wrote my own. You might wonder why I
should embark on such a task. Well:

-  I was keen that all of my objects and random other files were
   completely separate from the main Arduino stuff in the applet
   directory.
-  Although I wanted to be able to build Arduino sketches, I also wanted
   a suitable jumping-off point for code which didn't use wiring. In
   other words, to regard the Arduino software as a convenient way to
   get the AVR GCC toolchain.
-  Rather than dumping a big Makefile in each sketch directory, I wanted
   to have a few definitions in the directory which then included a
   large project-independent file from elsewhere.

Finally, one of the things I enjoy about writing code for
microcontrollers is the sense of continuity between the hardware
datasheets published by the chip manufacturer and the code I write (by
contrast if you're writing code on Linux there's a vast gulf between the
code executing printf and stuff appearing on the screen). Writing my own
Makefile seemed a good way to make sure I understood what was going on.

So to the Makefile. Obviously it owes a great debt to the people who
wrote the Makefile shipped with the Arduino IDE and here's the credit
list from that file:

#+BEGIN_EXAMPLE
    # Arduino 0011 Makefile
    # Arduino adaptation by mellis, eighthave, oli.keller
#+END_EXAMPLE

Thanks then to mellis, eighthavem and oli.keller.

*** Installation instructions

If you're using Debian or Ubuntu, then just grab the arduino-mk package.

You should then set up environment variables thus:

#+BEGIN_EXAMPLE
    ARDUINO_DIR   = /usr/share/arduino
    ARDMK_DIR     = /usr
    AVR_TOOLS_DIR = /usr
#+END_EXAMPLE

Otherwise, you'll need to download
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz][the
tarball containing the Makefile,]]^{7} unpack it, and then copy the
files somewhere sensible:

#+BEGIN_EXAMPLE
    $ wget http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz
    $ tar xzvf arduino-mk_0.10.tar.gz
    $ cp arduino-mk-0.10/arduino-mk/Arduino.mk /usr/local/arduino/Arduino.mk
    $ cp arduino-mk-0.10/bin/* /usr/local/bin
#+END_EXAMPLE

The next step is to set up environment variables which point to the
different files.

On the Mac you might want to set:

#+BEGIN_EXAMPLE
    ARDUINO_DIR   = /Applications/Arduino.app/Contents/Resources/Java
    ARDMK_DIR     = /usr/local
#+END_EXAMPLE

On Linux, where the toolchain is installed in /usr, you might prefer:

#+BEGIN_EXAMPLE
    ARDUINO_DIR   = /usr/share/arduino
    ARDMK_DIR     = /usr/local
    AVR_TOOLS_DIR = /usr
#+END_EXAMPLE

The final step is to create a small Makefile for the sketch you actually
want to build. Let's build the
[[http://arduino.cc/en/Tutorial/WebServer][WebServer example]]^{8} from
the Arduino distribution: it's a good example because software-wise it's
as complicated as the stardard examples get, but you can just plug the
hardware together.

Create a new directory and copy the WebServer.ino file into it.

*Note: If you're using version 1.0 of the Arduino software, you'll need
to make sure that the sketch's name ends in .ino and not .pde.*

Now this we'll add a Makefile:

#+BEGIN_EXAMPLE
    BOARD_TAG    = uno
    ARDUINO_PORT = /dev/cu.usb*

    ARDUINO_LIBS = Ethernet Ethernet/utility SPI

    include /usr/local/arduino/Arduino.mk
#+END_EXAMPLE

Hopefully these will be self-explanatory but in case they're not:

-  BOARD_TAG :: A tag identifying which type of Arduino you're using.
   This only works in version 0.6 and later.
-  ARDUINO_PORT :: The port where the Arduino can be found (only needed
   when uploading) If this expands to several ports, the first will be
   used.
-  ARDUINO_LIBS :: A list of any libraries used by the sketch---we
   assume these are in $(ARDUINO_DIR)/hardware/libraries.

Until version 0.8 you had to specify a TARGET name which set the
basename for the executables. You still /can/ do this, but it's not
necessary: thanks to a patch from Daniele Vergini it now defaults to the
name of the current directory.

In the past, the following options were used, and indeed you can still
use them. However it's probably better to use set BOARD_TAG and let the
Makefile look up the values in boards.txt:

-  MCU :: The target processor (atmega168 for the Duemilanove).
-  F_CPU :: The target's clock speed (16000000 for the Duemilanove).
-  AVRDUDE_ARD_PROGRAMMER :: The protocol avrdude speaks---defaults to
   stk500v1.
-  AVRDUDE_ARD_BAUDRATE :: The rate at which we talk to the
   board---defaults to 19,200.

**** BOARD_TAG

Makefiles before version 0.5 had to specify which processor and speed
the target used. For standard boards, this information can be found in
the boards.txt file, so it seemed sensible to use that instead.

Now, one need only define BOARD_TAG to match the target hardware and it
should work. Internally the Makefile invokes ard-parse-boards---a small
Perl utility included with the software---which parses board.txt.

If you're not sure which board tag you need, ard-parse-board will dump a
full list:

#+BEGIN_EXAMPLE
    $ ard-parse-boards --boards
    Tag          Board Name
    atmega168    Arduino NG or older w/ ATmega168
    atmega328    Arduino Duemilanove or Nano w/ ATmega328
    atmega8      Arduino NG or older w/ ATmega8
    bt           Arduino BT w/ ATmega168
    bt328        Arduino BT w/ ATmega328
    diecimila    Arduino Diecimila, Duemilanove, or Nano w/ ATmega168
    fio          Arduino Fio
    lilypad      LilyPad Arduino w/ ATmega168
    lilypad328   LilyPad Arduino w/ ATmega328
    mega         Arduino Mega (ATmega1280)
    mega2560     Arduino Mega 2560
    mini         Arduino Mini
    pro          Arduino Pro or Pro Mini (3.3V, 8 MHz) w/ ATmega168
    pro328       Arduino Pro or Pro Mini (3.3V, 8 MHz) w/ ATmega328
    pro5v        Arduino Pro or Pro Mini (5V, 16 MHz) w/ ATmega168
    pro5v328     Arduino Pro or Pro Mini (5V, 16 MHz) w/ ATmega328
    uno          Arduino Uno
#+END_EXAMPLE

If you don't set it, BOARD_TAG defaults to uno.

You can, of course, continue to set F_CPU and MCU directly should you
prefer that.

**** ARDUINO_LIBS

Early (up to and including version 0.4) of this Makefile didn't really
support this (despite claims to the contrary). Happily various kind
people sorted out the problem, one of whom patched the Debian and Ubuntu
version.

In the official IDE, it's enough to select the library from a menu: this
puts the relevant #include into the Sketch and adds the necessarily
linker tweaks too.

In this Makefile, you'll need to both add the #include yourself and
append the directories which contain the library to the ARDUINO_LIBS
variable. Often these will both have the same name, though it's worth
noting that the #include refers to a single file, but the ARDUINO_LIBS
entry refers to an entire directory of source files.

However, care is needed if the library's source files aren't in a single
directory. For example, the webserver example uses the
[[http://www.arduino.cc/en/Reference/Ethernet][Ethernet library]]^{9}
and we needed to include both Ethernet and Ethernet/utility in
ARDUINO_LIBS.

If you omit the .../utility library, you'll get messy looking link
errors from the bowels of the Ethernet library. The SPI and Wire
libraries are like this too!

*** Building

If you're used to Unix then this is easy:

#+BEGIN_EXAMPLE
    $ make
    ...
#+END_EXAMPLE

The output is pretty verbose, but I think it should be obvious if it
worked. After building you'll see a new directory has been created which
contains all the object files: build-uno. Since version 0.10, if you
rebuild the software with a different BOARD_TAG, you'll get a different
directory name.

#+BEGIN_EXAMPLE
    $ $ ls -lR
    total 16
    -rw-r--r--   1 mjo  staff   263 12 Feb 11:06 Makefile
    -rw-r--r--   1 mjo  staff  2308 12 Feb 10:57 WebServer.ino
    drwxr-xr-x  28 mjo  staff   952 12 Feb 11:07 build-uno
#+END_EXAMPLE

**** build-uno

Let's peek inside the build-uno directory:

#+BEGIN_EXAMPLE
    $ ls -l build-uno
    total 2136
    -rw-r--r--  1 mjo  staff    2292 12 Feb 11:07 CDC.o
    -rw-r--r--  1 mjo  staff    2292 12 Feb 11:07 HID.o
    -rw-r--r--  1 mjo  staff   23452 12 Feb 11:07 HardwareSerial.o
    -rw-r--r--  1 mjo  staff   16008 12 Feb 11:07 IPAddress.o
    -rw-r--r--  1 mjo  staff   40012 12 Feb 11:07 Print.o
    -rw-r--r--  1 mjo  staff   21068 12 Feb 11:07 Stream.o
    -rw-r--r--  1 mjo  staff   16580 12 Feb 11:07 Tone.o
    -rw-r--r--  1 mjo  staff    2300 12 Feb 11:07 USBCore.o
    -rw-r--r--  1 mjo  staff    6048 12 Feb 11:06 WInterrupts.o
    -rw-r--r--  1 mjo  staff    7068 12 Feb 11:07 WMath.o
    -rw-r--r--  1 mjo  staff   79196 12 Feb 11:07 WString.o
    -rw-r--r--  1 mjo  staff    2329 12 Feb 10:57 WebServer.cpp
    -rw-r--r--  1 mjo  staff    1920 12 Feb 11:06 WebServer.d
    -rw-r--r--  1 mjo  staff   11324 12 Feb 11:06 WebServer.o
    -rwxr-xr-x  1 mjo  staff  193852 12 Feb 11:07 WebServer.elf
    -rw-r--r--  1 mjo  staff   28572 12 Feb 11:07 WebServer.hex
    -rw-r--r--  1 mjo  staff    1920 12 Feb 11:08 depends.mk
    -rw-r--r--  1 mjo  staff  541002 12 Feb 11:07 libcore.a
    drwxr-xr-x  4 mjo  staff     136 12 Feb 10:57 libs
    -rw-r--r--  1 mjo  staff    3616 12 Feb 11:07 main.o
    <-rw-r--r--  1 mjo  staff    5544 12 Feb 11:07 new.o
    -rw-r--r--  1 mjo  staff    9780 12 Feb 11:06 wiring.o
    -rw-r--r--  1 mjo  staff    7024 12 Feb 11:06 wiring_analog.o
    -rw-r--r--  1 mjo  staff    9704 12 Feb 11:06 wiring_digital.o
    -rw-r--r--  1 mjo  staff    7056 12 Feb 11:06 wiring_pulse.o
    -rw-r--r--  1 mjo  staff    5736 12 Feb 11:06 wiring_shift.o

    ./build-uno/libs:
    total 0
    drwxr-xr-x  9 mjo  staff  306 12 Feb 11:07 Ethernet
    drwxr-xr-x  3 mjo  staff  102 12 Feb 11:07 SPI

    ./build-uno/libs/Ethernet:
    total 392
    -rw-r--r--  1 mjo  staff  24836 12 Feb 11:07 Dhcp.o
    -rw-r--r--  1 mjo  staff  23112 12 Feb 11:07 Dns.o
    -rw-r--r--  1 mjo  staff  33008 12 Feb 11:07 Ethernet.o
    -rw-r--r--  1 mjo  staff  42000 12 Feb 11:07 EthernetClient.o
    -rw-r--r--  1 mjo  staff  19420 12 Feb 11:07 EthernetServer.o
    -rw-r--r--  1 mjo  staff  41244 12 Feb 11:07 EthernetUdp.o
    drwxr-xr-x  4 mjo  staff    136 12 Feb 11:07 utility

    ./build-uno/libs/Ethernet/utility:
    total 152
    -rw-r--r--  1 mjo  staff  40480 12 Feb 11:07 socket.o
    -rw-r--r--  1 mjo  staff  34840 12 Feb 11:07 w5100.o

    ./build-uno/libs/SPI:
    total 16
    -rw-r--r--  1 mjo  staff  6812 12 Feb 11:07 SPI.o
#+END_EXAMPLE

Most of the files in here are object files for the wiring library. What
about the others ?

-  WebServer.cpp :: This is the .pde sketch file with a small main
   program prepended and a suitable #include prepended.
-  WebServer.d :: This tracks the dependencies used by WebServer.pde
-  WebServer.elf :: This is executable produced by the linker
-  WebServer.hex :: This is a hex dump of (the code part) of the
   executable in a format understood by the Arduino's bootloader.
-  WebServer.o :: The object file we got by compiling WebServer.cpp.
-  depends.mk :: A single file containing all the dependency relations
   (it's the concatentation of all the .d files).
-  libcore.a :: Rather than link all the system supplied objects
   directly, we build them into this library first, then link against
   it.

*** Uploading code

This is easy:

#+BEGIN_EXAMPLE
    $ make upload
#+END_EXAMPLE

*** Uploading via ISP

If you're using target hardware which doesn't have a bootloader then you
might want to use ISP to upload the code. Though you'll obviously need
some extra hardware to do this.

Assuming that avrdude supports your programmer though, you'll only need
to make a few changes to the Makefile to tell avrdude where it can find
the programmer and how to talk to it:

#+BEGIN_EXAMPLE
    ISP_PORT         = /dev/ttyACM0
    ISP_PROG         = -c stk500v2
#+END_EXAMPLE

Then to upload:

#+BEGIN_EXAMPLE
    $ make ispload
#+END_EXAMPLE

**** Fuses

You might need to change the fuse settings when programming, though some
care needs to be taken here or you might irreversibly damage the chip.

Normally the fuse settings are chosen from the boards.txt file to match
the value of BOARD_TAG (assuming you're running version 0.6 or higher),
but you can set them yourself:

#+BEGIN_EXAMPLE
    ISP_LOCK_FUSE_PRE  = 0x3f
    ISP_LOCK_FUSE_POST = 0xcf
    ISP_HIGH_FUSE      = 0xdf
    ISP_LOW_FUSE       = 0xff
    ISP_EXT_FUSE       = 0x01
#+END_EXAMPLE

*** Growing the project

There a couple of obvious things to do now. You might want to edit the
sketch. That's easy: just edit the .ino file and run make again.

Alternatively you might want to add some more source files to the
project. That's easy too: the Makefile understands C, C++ and assembler
files in the source directory (with .c, .cpp, and .s extensions).
Everything *should* just work.

*** Wiring-less development

Finally you might want to develop code which isn't linked against the
Wiring library. There's some scope for this: just set NO_CORE in the
Makefile e.g.

#+BEGIN_EXAMPLE
    NO_CORE = 1
#+END_EXAMPLE

*** Bugs and problems

-  The Makefile isn't very elegant.
-  When compiling the sketch file, the compiler actually sees the .cpp
   file derived from it. Accordingly the line numbers of any errors will
   be wrong (but not by that much).
-  The Makefile doesn't do some of the things that the Makefile
   distributed with the Arduino software does e.g. generating COFF
   files. I worry that some of these might be important.
-  This hasn't been used very much yet, even by me. I'm writing this now
   as much for my benefit as anyone else's, though I'd be delighted to
   know if anyone else finds it useful.

*** Changelog

**** 2010-05-21,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.3.tar.gz][version
0.3]]^{10}

-  Tidied up the licensing, making it clear that it's released under
   LGPL 2.1.
-  [[http://hands.com/~phil/][Philip Hands]]^{11} sent me some code to
   reset the Arduino by dropping DTR for 100ms, and I added it.
-  Tweaked the Makefile to handle version 0018 of the Arduino software
   which now includes main.cpp. Accordingly we don't need to---and
   indeed must not---add main.cxx to the .pde sketch file. The paths
   seem to have changed a bit too.

**** 2010-05-24,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.4.tar.gz][version
0.4]]^{12}

-  Tweaked rules for the reset target on Philip Hands' advice.

**** 2011-06-23,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.5.tar.gz][version
0.5]]^{13}

-  Imported changes from Debian/Ubuntu, which incorporate a patch from
   Stefan Tomanek so that libraries would be compiled too.

Note: Many other people sent me similar patches, but I didn't get around
to using them. In the end, I took the patch from Debian and Ubuntu:
there seems merit in not forking the code and using a tested version.
So, thanks and apologies to Nick Andrew, Leandro Coletto Biazon, Thibaud
Chupin, Craig Hollabaugh, Johannes H. Jensen, Fabien Le Lez, Craig
Leres, and Mark Sproul.

**** 2011-06-23,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.6.tar.gz][version
0.6]]^{14}

-  Added ard-parse-boards. Mark Sproul suggested doing something like
   this ages ago, but I've only recently looked at it in detail.
-  Fabien Le Lez reported that one needs to link with -lc to avoid
   [[http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1290294587][linker
   errors.]]^{15}

**** Unreleased,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.7.tar.gz][version
0.7]]^{16}

-  Added -lm to the linker options, and -F to stty.

**** 2012-02-12,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.8.tar.gz][version
0.8]]^{17}

-  Patches for version 1.0 of the Arduino IDE. Older versions might
   still work, but I've not tested it.
-  A change to the build process: rather than link all the system
   objects directly into the executable, bundle them in a library first.
   This should make the final executable smaller.
-  If TARGET isn't explicitly set, default to the current directory
   name. Thanks to Daniele Vergini for this patch.
-  Add support for .c files in system libraries: Dirk-Willem van Gulik
   and Evan Goldenberg both reported this and provided patches in the
   same spirit.
-  Added a size target as suggested by Alex Satrapa.

**** Later versions

Please consult the
[[https://github.com/mjoldfield/Arduino-Makefile/commits/master][commit
history]]^{18} on github.

*** Similar work

It's not a derivative of this, but Alan Burlison has written
[[http://bleaklow.com/2010/06/04/a_makefile_for_arduino_sketches.html][a
similar thing.]]^{19}

Alan's Makefile was used in
[[http://pragprog.com/magazines/2011-04/advanced-arduino-hacking][a
Pragmatic Programmer's article.]]^{20}

Rei Vilo wrote to tell me that he's using the Makefile ina Xcode 4
template called [[http://embedxcode.weebly.com][embedXcode.]]^{21}
Apparently it supports many platforms and boards, including AVR-based
Arduino, AVR-based Wiring, PIC32-based chipKIT, MSP430-based LaunchPad
and ARM3-based Maple.

*** References

-  1. https://github.com/sudar/Arduino-Makefile/
-  2.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz
-  3. https://github.com/mjoldfield/Arduino-Makefile/commits/master
-  4. https://github.com/mjoldfield/Arduino-Makefile
-  5. http://www.arduino.cc/
-  6. http://arduino.cc/en/Hacking/HomePage
-  7.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz
-  8. http://arduino.cc/en/Tutorial/WebServer
-  9. http://www.arduino.cc/en/Reference/Ethernet
-  10.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.3.tar.gz
-  11. http://hands.com/~phil/
-  12.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.4.tar.gz
-  13.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.5.tar.gz
-  14.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.6.tar.gz
-  15. http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1290294587
-  16.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.7.tar.gz
-  17.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.8.tar.gz
-  18. https://github.com/mjoldfield/Arduino-Makefile/commits/master
-  19.
   http://bleaklow.com/2010/06/04/a_makefile_for_arduino_sketches.html
-  20. http://pragprog.com/magazines/2011-04/advanced-arduino-hacking
-  21. http://embedxcode.weebly.com

** [[https://truongtx.me/2013/03/10/ecb-emacs-code-browser/][Install and Config ECB on Emacs]]

Install and Config ECB on Emacs

Introduction

ECB, stands for Emacs Code Browser, tranforms your emacs from a text editor to a real IDE for coding. Once activated, it can display many
useful information that help you program more effectively. The ECB’s informational windows can contain:

  * a directory tree,
  * a list of source files in the current directory,
  * a list of functions/classes/methods/… in the current file, (ECB uses the Semantic Bovinator, or Imenu, or etags, for getting this list
    so all languages supported by any of these tools are automatically supported by ECB too)
  * a history of recently visited files,
  * the Speedbar and
  * output from compilation (the “compilation” window) and other modes like help, grep, etc. or whatever the user defines to be displayed in
    that window.

For more information, please visit ECB Homepage.

Screenshot

Here is the ECB screenshot from my Emacs

ECB Scre

Installation

ECB requires CEDET version 1.0+, which is included in Emacs version 24.

You can install ECB manually by cloning the package and add it to your load-path. However, there is another convinience method, that is to
use package.el. If you haven’t known it yet, have a look at this post Emacs Package Manager. To install it, M-x and type in list-package
RET, C-s and search for ecb, RET and select Install. After that, add this to your .emacs or init.el file

;;; activate ecb
(require 'ecb)
(require 'ecb-autoloads)

Now, everything you need to run ECB is to type M-x ecb-activate RET and ECB is now ready for you to use. When you want to stop it, just
execute the command ecb-deactivate.

Some Basic Configurations

To set the layout for ECB, add this to your .emacs

(setq ecb-layout-name "layout-name")

Replace layout-name with the name of the layout you want. For a list of ECB layouts, follow this link ECB Layouts.

Show source files in directories buffer

(setq ecb-show-sources-in-directories-buffer 'always)

By default, ECB hides the compilation window. Everytime I compile, it displays the compilation message to the same window as the buffer that
I’m editing. This is really annoying because I want to see all the messages so that I can fix the error in my code easily. To keep a
persistent compile window in ECB, add this to your .emacs

(setq ecb-compile-window-height 12)

Some key bindings for quick interation with ECB, replace them with the key bindings that you want.

;;; activate and deactivate ecb
(global-set-key (kbd "C-x C-;") 'ecb-activate)
(global-set-key (kbd "C-x C-'") 'ecb-deactivate)
;;; show/hide ecb window
(global-set-key (kbd "C-;") 'ecb-show-ecb-windows)
(global-set-key (kbd "C-'") 'ecb-hide-ecb-windows)
;;; quick navigation between ecb windows
(global-set-key (kbd "C-)") 'ecb-goto-window-edit1)
(global-set-key (kbd "C-!") 'ecb-goto-window-directories)
(global-set-key (kbd "C-@") 'ecb-goto-window-sources)
(global-set-key (kbd "C-#") 'ecb-goto-window-methods)
(global-set-key (kbd "C-$") 'ecb-goto-window-compilation)

Some of My Functions

Personally, I don’t like those function ecb-deactivate, ecb-show-ecb-windows, ecb-hide-ecb-windows since I usually have to open multiple
windows in Emacs. When deactivate or hide ECB window, it does not automatically restore the window layout and switch to the buffer that I’m
editing. Similar problem happens when I try to show ecb window again. Because of that, I wrote those functions to replace the ECB built in
three functions ecb-deactivate, ecb-show-ecb-windows, ecb-hide-ecb-windows.

;;; replacement for built-in ecb-deactive, ecb-hide-ecb-windows and
;;; ecb-show-ecb-windows functions
;;; since they hide/deactive ecb but not restore the old windows for me
(defun tmtxt/ecb-deactivate ()
  "deactive ecb and then split emacs into 2 windows that contain 2 most recent buffers"
  (interactive)
  (ecb-deactivate)
  (split-window-right)
  (switch-to-next-buffer)
  (other-window 1))
(defun tmtxt/ecb-hide-ecb-windows ()
  "hide ecb and then split emacs into 2 windows that contain 2 most recent buffers"
  (interactive)
  (ecb-hide-ecb-windows)
  (split-window-right)
  (switch-to-next-buffer)
  (other-window 1))
(defun tmtxt/ecb-show-ecb-windows ()
  "show ecb windows and then delete all other windows except the current one"
  (interactive)
  (ecb-show-ecb-windows)
  (delete-other-windows))

After that, bind them with a key sequence for quick interaction with ECB

(global-set-key (kbd "C-x C-'") 'tmtxt/ecb-deactivate)
(global-set-key (kbd "C-;") 'tmtxt/ecb-show-ecb-windows)
(global-set-key (kbd "C-'") 'tmtxt/ecb-hide-ecb-windows)

** Github project & sourceforge project
** [[http://www.educity.cn/help/510677.html][vim中执行shell命令小结]]

vim中执行shell命令，有以下几种形式

1):!command

不退出vim，并执行shell命令command，将命令输出显示在vim的命令区域，不会改变当前编辑的文件的内容

例如:!ls -l

特别的可以运行:!bash来启动一个bash shell并执行命令，不需要退出vim

2):r !command

将shell命令command的结果插入到当前行的下一行

例如:r !date，读取系统时间并插入到当前行的下一行。

3):起始行号,结束行号 !command

将起始行号和结束行号指定的范围中的内容输入到shell命令command处理，并将处理结果替换起始行号和结束行号指定的范围中的内容

例如:62,72 !sort，将62行到72行的内容进行排序

可以只指定起始行，例如:62 !tr [a-z] [A-Z]，将62行的小写字母转为大写字母

当前光标所在行，除可以指定行号外，也可以用.表示，例如:. !tr [a-z] [A-Z]，将当前行的小写转为大写

4):起始行号,结束行号 w !command

将起始行号和结束行号所指定的范围的内容作为命令command的输入。不会改变当前编辑的文件的内容

例如:62,72 w !sort，将62行到72行的内容进行排序，但排序的结果并不会直接输出到当前编辑的文件中，而是显示在vim敲命令的区域

特殊的可以下面这么用:62 w !bash，将会把第62行的内容作为bash命令来执行并显示结果，而且不会改变当前编辑的文件的内容

同样的:. w !bash，将当前行的内容作为bash命令来执行

例如52行内容为ls -l

那么输入:52 w !bash就跟执行!ls -l是一样的效果，如果你用的shell是bash shell

如果输入的是:52 !bash，那么会把第52行的内容也就是ls -l作为命令执行，同时命令的输出结果会替换第52行的内容，注意其中的区别。
** [[http://blog.csdn.net/lcj_cjfykx/article/details/9091569][VIM选择文本块/复制/粘贴]]


在正常模式下（按ESC进入）按键v进入可视化模式，然后按键盘左右键或h,l键即可实现文本的选择。
 其它相关命令：
 v：按字符选择。经常使用的模式，所以亲自尝试一下它。

 V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。


CTRL＋v：按块选择。非常强大，只在很少的编辑器中才有这样的功能。你可以选择一个矩形块，并且在这个矩形里面的文本会被高亮。


值得注意的是如果VIM中使用自动换行，那么直到你按ENTER换行前，VIM都会将你之前输入的内容视为一行而不是你看到的好几行，按块选择时就会按VIM中的行来选择块。


在选择模式的时候使用上面所述的方向键和命令（motion）。比如，vwww，会高亮光标前面的三个词。Vjj
将会高亮当前行以及下面两行。


================================================================
 ================================================================

原文：[[http://hi.baidu.com/shadouyou/blog/item/7ccb234e5a75d1cfd0c86a55.html][http://hi.baidu.com/shadouyou/blog/item/7ccb234e5a75d1cfd0c86a55.html
]]

vi编辑器有3种模式：命令模式、输入模式、末行模式。掌握这三种模式十分重要：


命令模式：vi启动后默认进入的是命令模式，从这个模式使用命令可以切换到另外两种模式，同时无论在任何模式下只要按一下[Esc]键都可以返回命令模式。在命令模式中输入字幕“i”就可以进入vi的输入模式编辑文件。


输入模式：在这个模式中我们可以编辑、修改、输入等编辑工作，在编辑器最后一行显示一个“--INSERT--”标志着vi进入了输入模式。当我们完成修改输入等操作的时候我们需要保存文件，这时我们需要先返回命令模式，在进入末行模式保存。


末行模式：在命令模式输入“：”即可进入该模式，在末行模式中有好多好用的命令。

 4.编辑操作
 　　进入输入模式命令
 　　i插入命令 a附加命令 o打开命令 c修改命令
 　　r取代命令 s替换命令 Esc退出命令

 　　输入模式的操作
 　　Home光标到行首
 　　End 光标到行尾
 　　Page Up和Page Down上下翻页
 　　Delect删除光标位置的字符

 　　删除操作(命令模式使用)
 　　x删除光标处的单个字符
 　　dd删除光标所在行
 　　dw删除当前字符到单词尾包括空格的所有字符
 　　#x例如3x删除光标处向右的三个字符
 　　#dd例如3dd从当前行开始向下删除三行文本

 　　撤销操作
 　　u命令取消最近一次的操作，可以使用多次来恢复原有的操作
 　　U取消所有操作
 　　Ctrl+R可以恢复对使用u命令的操作

 　　复制操作
 　　yy命令复制当前整行的内容到vi缓冲区

yw复制当前光标所在位置到单词尾字符的内容到vi缓存区，相当于复制一个单词
 　　y$复制光标所在位置到行尾内容到缓存区
 　　y\^复制光标所在位置到行首内容到缓存区
 　　#yy例如：5yy就是复制5行
 　　#yw例如：2yw就是复制两个单词


如果要复制第m行到第n行之间的内容，可以在末行模式中输入m，ny例如：3，5y复制第三行到第五行内容到缓存区。

 5.查找和替换
 　　vi的查找和替换功能主要在末行模式完成：

 　　至上而下的查找
 　　/ 要查找的字符窜，其中/代表从光标所在位置起开始查找，例如：/ work

 　　至下而上的查找
 　　？要查找的字符窜 例如：/ work

 　　替换
 　　:s/old/new用new替换行中首次出现的old
 　　: s/old/new/g 用new替换行中所有出现的old
 　　:#,# s/old/new/g用new替换从第＃行到第＃行中出现的old
 　　：% s/old/new/g用new替换整篇中出现的old


如果替换的范围较大时，在所有的命令尾加一个c命令，强制每个替换需要用户进行确认，例如:s/old/new/c
或s/old/new/gc

 　　6恢复文件
 　　vi在编辑某一个文件时，会生成一个临时文件，这个文件以 . 开头并以
.swp结尾。正常退出该文件自动删除，如果意外退出例如忽然断电，该文件不会删除，我们在下次编辑时可以选择一下命令处理：

 　　O只读打开，不改变文件内容
 　　E继续编辑文件，不恢复.swp文件保存的内容
 　　R将恢复上次编辑以后未保存文件内容
 　　Q退出vi
 　　D删除.swp文件
 　　或者使用vi －r 文件名来恢复未保存的内容

 在GUI下：
 （1）可按i进入插入模式
 （2）使用鼠标拖动反选要粘贴的内容，按鼠标左键复制选定块到缓冲区

（3）然后将光标移到要粘贴处，按鼠标中键（两键鼠标可同时按左右键），粘贴缓冲区内容。

 在纯文本终端下：
 （1）选定文本块，使用v进入可视模式；移动光标键选定内容
 （2）复制选定块到缓冲区，用y；复制整行，用yy
 （3）剪切选定块到缓冲区，用d；剪切整行用dd
 （4）粘贴缓冲区中的内容，用p

 在同一编辑窗打开第二个文件，用:sp [filename]
 在多个编辑文件之间切换，用Ctrl+w

 命令前面加数字表示重复次数，加字母表示使用的缓冲区名称。
 获取帮助，用:help [内容或命令]
** [[http://blog.csdn.net/yunjie2008/article/details/5684983][Programming in Emacs Lisp笔记（七）基础函数:car, cdr, cons]]


基础函数:car, cdr, cons
Lisp中car，cdr和cons都是基础函数。cons用于构造lists，car和cdr用于分割lisp。

奇怪的命名
cons函数的名称并非没有含意：它是单词'construct'的缩写。car是短语'Contents
of the Address part of the Register'；cdr（'could-er'）是短语'Contents
of the Decrement part of the
Register'。这些短语说明了Lisp是在多么原始的机器上被开发的。

car和cdr
一个list的CAR是list中的第一个元素。(rose violet daisy
buttercup)的CAR就是rose。

执行下面的代码：

(car '(rose violet daisy buttercup))执行这个语句后，回显区将显示rose。
有一个更合理的car函数：first。

car并不从list移除第一个元素；它只返回第一个元素。car执行完后list并没有发生改变。car是一个无害的函数（'non-destructive'）。

CDR是list中的其余部分，cdr函数返回list中首元素后面的其它元素。因此'(rose
violet daisy buttercup)的CDR部分是(violet daisy buttercup)。

对：

(cdr '(rose violet daisy buttercup))求值将在回显区显示(violet daisy
butercup)
cdr也不从列表中移除元素。

附带说明一下：在这个例子中list前面加了单引号。如果不加，Lisp解释器把rose当作函数执行。在这个例子中我们并不需要那样。

cdr的一个更合理的名称是：rest。

当car和cdr应用于符号组成的列表时，比如(pine fir oak
maple)，函数car将返回列表中的pine元素，并且pine不会被括号包含。这个list的CDR也是一个list，(fir
oak maple)。

如果car和cdr应用于包含list的list，第一个元素也是list。car将返回list中的第一个list元素。

car和cdr是无害的，它们不修改list中的数据。这是非常重要的一点。

在第一章中曾说过：“在Lisp中某些原子类型，比如数组，可以被分隔成更小的部分；但这种机制与分割list的机制是不同的。这与Lisp的早期
概念有关，list中的原子是不可分隔的。”（car和cdr也并不修改list。）car和cdr是用于分割list的基础函数。但它们不能用于分割数
组或者访问数组中的一部分。数组被看作原子类型。另一个基础函数cons可以用于构造列表，但也不能用于数组。

cons
cons函数是构造list的函数。例：

(cons 'pine '(fir oak maple))执行时回显区将显示(pine fir oak
maple)。cons将新的元素放到列表的开头，它将新元素推入list中。***
构造一个listcons函数必须要有一个可以被插入的list参数。构造一个list时，至少要提供一个空的list。下面是一些构造list的语句：<src
lang="lisp">(cons 'buttercup ())  => (buttercup)(cons 'daisy
'(buttercup))  => (daisy buttercup)(cons 'violet '(daisy
buttercup))  => (violet daisy buttercup)(cons 'rose '(violet daisy
buttercup))  => (rose violet daisy
buttercup)</src>在第一个例子中，()是一个空的list并且用空list和buttercup构造了一个list。可以看到空list并没有显示在被构造的list中。
只能看到(buttercup)。空list不会被当作一个list元素，因为空list中没有任何元素。空list是不可见的。
检查list的长度：length
可以用函数length检查list中的元素数量：

(length '(buttercup))  => 1(length '(daisy buttercup))  =>
2(length (cons 'violet '(daisy buttercup)))  =>
3也可以将length应用于空list上：
(length ())  => 0当调用length函数而不传递参数给它时：

(length)你将得到一个错误信息：
Wrong number of arguments: #<subr length="">,
0</subr>这表示函数接收到了错误的参数个数，0，函数需要一定数量的参数。在这里length需要一个参数，参数应该是一个list。（一个list也是一个参数而不管list中有多少元素）
错误信息中的#是函数的名称。#

nthcdr
nthcdr是一个与cdr相关的函数。它用于多次获取list的CDR部分。

如果获取(pine fir oak maple)的CDR部分，将得到(fir oak
maple)。如果在这个结果上再重复操作将得到(oak
maple)。（如果你在原来的list上取CDR，将一直得到同样的结果，因为原来的list并没有被修改）如果继续下去，将得到一个空的list，这
时将不会显示为()，而是显示为nil。 例：

(cdr '(pine fir oak maple))  =>(fir oak maple)(cdr '(fir oak
maple))  => (oak maple)(cdr '(oak maple))  =>(maple)(cdr
'(maple))  => nil(cdr 'nil)  => nil(cdr ())  =>
nil或者用下面的方式：
(cdr (cdr '(pine fir oak maple)))  => (oak
maple)nthcdr函数与多次调用cdr类似。下面的例子中，参数2和一个list被传递给nthcdr，返回的值与原list相比，不含前面两个元素，相当于在list上执行了两次cdr。

(nthcdr 2 '(pine fir oak maple))  => (oak maple);; Leave the list as
it was.(nthcdr 0 '(pine fir oak maple))  => (pine fir oak maple);;
Return a copy without the first element.(nthcdr 1 '(pine fir oak
maple))  => (fir oak maple);; Return a copy of the list without three
elements.(nthcdr 3 '(pine fir oak maple))  => (maple);; Return a copy
lacking all four elements.(nthcdr 4 '(pine fir oak maple))  => nil;;
Return a copy lacking all elements.(nthcdr 5 '(pine fir oak maple))
=> nilnth
nthcdr重复取list的CDR部分。nth函数取nthcdr返回值的CAR部分。它返回list中的Nth元素。

如果nth没有被因为效率原因而用C定义，那么nth的定义将会是下面的样子：

(defun nth (n list)  "Returns the Nth element of LIST.N counts from
zero.  If LIST is not that long, nil is returned."  (car (nthcdr n
list)))（最初的nth在定义在Emacs
Lisp文件subr.el中，但后来在1980年被重新用C实现。）
元素计数从0开始而不是1。这就是说list的第一个元素CAR是第零个元素。

(nth 0 '("one" "two" "three"))  => "one"(nth 1 '("one" "two"
"three"))  =>
"two"注意：nth与nthcdr和cdr一样，也不修改原来的list，也是一个无害函数。
setcar
从命名上就可以猜想到，setcdr和setcar函数用于设置list的CAR或CDR部分为一个新值。与car和cdr不同，它们将修改原始的list。

例：

(setq animals '(antelope giraffe lion tiger))animals  => (antelope
giraffe lion tiger)(setcar animals 'hippopotamus)animals  =>
(hippopotamus giraffe lion
tiger)可以看到setcar函数并非像cons那样向list中添加元素；它将giraffe替换为hippopotamus；它修改了list。
setcdr
setcdr与setcar函数类似，它用于替换list中除首元素外的其它元素。

例：

(setq domesticated-animals '(horse cow sheep
goat))domesticated-animals  => (horse cow sheep goat)(setcdr
domesticated-animals '(cat dog))domesticated-animals  => (horse cat
dog)
** [[http://blog.csdn.net/csfreebird/article/details/7197392][Emacs CMake mode使用]]




CMake mode for emacs
提供了一些好的功能，一直都没有注意到这个mode，今天正式开始使用。

首先，下载cmake-mode.el文件

﻿﻿[[http://www.cmake.org/CMakeDocs/cmake-mode.el]]



放到自己的emacs plugin目录下：

/opt/emacs_plugins/cmake-mode.el



然后在.emacs文件中设置如下：

#+BEGIN_EXAMPLE
    (setq load-path (cons (expand-file-name "/opt/emacs_plugins") load-path))
    (require 'cmake-mode)
    (setq auto-mode-alist
          (append '(("CMakeLists\\.txt\\'" . cmake-mode)
                    ("\\.cmake\\'" . cmake-mode))
                  auto-mode-alist))
#+END_EXAMPLE




重新启动Emacs后，打开我的CMake工程的CMakeLists.txt文件,里面command关键字都已经变成高亮。

M-x 执行 cmake-help-list-commands
后，可以看到所有当前CMake版本支持的命令。

将光标停在某个command（比如AUX_SOURCE_DIRECTORY)之上，运行cmake-help-command
会看到关于AUX_SOURCE_DIRECTORY command的详细介绍。
** [[http://blog.waterlin.org/articles/bind-emacs-org-mode-with-bibtex.html][Emacs Org Mode 与 BibTeX 的结合]]

Filed Under
([[http://blog.waterlin.org/articles/category/%e6%8a%80%e6%9c%af][技术]])
by waterlin

[[http://blog.waterlin.org/articles/publish-org-files-to-html-project.html][Emacs
Org Mode
可以是一个优秀的笔记工具]]，可是，如果你想用它来写正式一点的论文，可以吗？当然可以了，你可以[[http://orgmode.org/worg/org-contrib/babel/languages/org-babel-doc-LaTeX.php][把
Org Mode 和 LaTeX 结合起来用]]，当然最重要的是要解决参考文献引用的问题。

整体的思路如下：

1. 先准备好你的 BibTeX 文件

   可以用 Emacs BibTeX Mode 或 JabRef
   之类的方式来生成这个文件，当然也可以用其它文献管理工具，只要它能导出
   BibTeX 文件即可。

2. 用 Emacs Org 建立工程并记笔记

   [[http://blog.waterlin.org/articles/publish-org-files-to-html-project.html][创建
   Org 工程]]的时候，和一般的工程没有任何区别。

3. 用 RefTeX 方式来插入 BibTeX 的记录

在这里，重点介绍一下第三个步骤，即如何在 Org Mode 里插入 BibTeX
记录。从官方的[[http://orgmode.org/worg/org-faq.php#sec-18_11_1][这篇参考文献]]里可以看出，我们可以用三种方法在
org 文件里引用 BibTeX 参考文献，从而插入 LaTeX 类的参考文献。

1). 最简单的办法，给所有的 Org 文件指定一个 BibTeX 文件，然后在 Org
文件里插入该 BibTeX 文件的参考文献记录

具体的办法，先把下面的代码放到 .emacs 里：

#+BEGIN_EXAMPLE
    (setq reftex-default-bibliography
          (quote
           ("default.bib" "~/org/notes/refer.bib")))
    (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
#+END_EXAMPLE

在这里，我指定的 BibTeX 文件为 *default.bib* 和 *~/org/notes/refer.bib*
。然后，可以在所有的 Org 文件里，通过命令 *C-c )* 或 *M-x
reftex-citation* 来进行参考文献的插入，根据提示进行相关操作即可。

2). 为特定的 Org 文件，指定特定的 BibTeX 文件

这个方法是
[[http://www.mfasold.net/blog/2009/02/using-emacs-org-mode-to-draft-papers/][Marios
Braindump 的博客里介绍的]]，具体方法如下：

先把下面的代码放到 .emacs 里：

#+BEGIN_EXAMPLE
    (defun org-mode-reftex-setup ()
      (load-library "reftex")
      (and (buffer-file-name)
           (file-exists-p (buffer-file-name))
           (reftex-parse-all))
      (define-key org-mode-map (kbd "C-c )") 'reftex-citation))
    (add-hook 'org-mode-hook 'org-mode-reftex-setup)
#+END_EXAMPLE

然后在你需要插入 BibTeX 参考文献的 Org
文件里，加入下面这段话（可以是任意位置）：

#+BEGIN_EXAMPLE
    \bibliographystyle{plain}
    \bibliography{BIB-NAME}
#+END_EXAMPLE

把上面的 BIB-NAME 换成你想指定的 BibTeX 文件，这样就可以对该 Org
文件指定特定的 BibTeX 文件，然后可以用 *C-c )* 或 *M-x reftex-citation*
来插入该 BibTeX 文件里的参考文献。

上面的代码会在 Emacs 启动的时候，要求你指定一个 master
文件，用来存储生成的 tex 文件。

3). 另外一种方法，实现为特定的 Org 文件指定特定 BibTeX 文件的功能

还有[[http://orgmode.org/worg/org-faq.php#sec-18_11_2][另外一种方法]]，可以实现第2种方法类似的功能，即为特定
Org 文件指定特定 BibTeX 文件的方法。把下面的代码放到 .emacs 文件里：

#+BEGIN_EXAMPLE
    (defun org-mode-article-modes ()
      (reftex-mode t)
      (and (buffer-file-name)
           (file-exists-p (buffer-file-name))
           (reftex-parse-all)))

    (add-hook 'org-mode-hook
              (lambda ()
                (if (member "REFTEX" org-todo-keywords-1)
                    (org-mode-article-modes))))
#+END_EXAMPLE

然后把下面这一行加到你需要插入 BibTeX 的 Org 文件的开头：

#+BEGIN_EXAMPLE
    #+TODO: TODO(t) STARTED(s) | DONE(d) DEFERRED(f) REFTEX
#+END_EXAMPLE

其它步骤与第2种方法类似。这种方法我没有仔细测试，有兴趣的 Emacser
们可以试试。

通过以上方法，就可以在用 Org Mode 打造的笔记本里，很方便地索引 BibTeX
里的参考文献了。

当然，如果你不喜欢用 Org Mode，也有其它用 Emacs
来写论文的思路，例如：Emacs + AucTeX + RefTeX + Outline-minor-mode
** [[http://hahack.com/tools/ispell-and-flyspell/][ispell与emacs的拼写检查]]

介绍ispell以及emacs里的拼写检查功能。

*** 了解Ispell

**** Ispell vs Aspell

Ispell是Unix下的一个拼写检查工具，支持多种语言（见：[[http://lasr.cs.ucla.edu/geoff/ispell-dictionaries.html][ispell
dictionaries]]），并且提供很多接口，其中包括了Emacs。另外一个比较出名的拼写检查工具是Aspell，两者的区别是Aspell不仅为拼错的单词提供形近的单词列表，还同时提供读音相似的单词的建议，e.g.如果你拼了一个错词“trubble”，Ispell只会建议“rubble”，而Aspell还会建议“trouble”、“dribble”、
“rubble”之类的词。不过Aspell的这种匹配算法只能用在英语单词上，而且在速度上以及指令的简单程度上不及Ispell。我使用的是Ispell，Aspell的配置可以参考[[http://aspell.net/0.61/man-html/Using-Aspell-with-other-Applications.html#Using-Aspell-with-other-Applications][这里]]。

**** 安装和配置Ispell

Ubuntu安装Ispell：

| #+BEGIN_EXAMPLE                                                   |
|     1                                                             |
| #+END_EXAMPLE                                                     |
|                                                                   |
| #+BEGIN_EXAMPLE                                                   |
|     $ sudo apt-get install ispell iamerican dictionaries-common   |
| #+END_EXAMPLE                                                     |


Arch安装Ispell：

| #+BEGIN_EXAMPLE                         |
|     1                                   |
| #+END_EXAMPLE                           |
|                                         |
| #+BEGIN_EXAMPLE                         |
|     $ sudo pacman -S ispell aspell-en   |
| #+END_EXAMPLE                           |


你可以试着在shell里直接使用ispell命令对一份文件进行拼写检查：

| #+BEGIN_EXAMPLE     |
|     1               |
| #+END_EXAMPLE       |
|                     |
| #+BEGIN_EXAMPLE     |
|     $ ispell FILE   |
| #+END_EXAMPLE       |


注意上面的FILE得你自己指定一个文件，建议是一份有英文单词的文件。如果能输出检查结果，说明此时Ispell运作正常。

如果提示找不到default.hash，那可能是没有把iamerican设为预设辞典的原因，解决方法如下：

| #+BEGIN_EXAMPLE                                               |
|     1                                                         |
| #+END_EXAMPLE                                                 |
|                                                               |
| #+BEGIN_EXAMPLE                                               |
|     $ cd /usr/lib/ispell/ sudo cp iamerican.hash default.sh   |
| #+END_EXAMPLE                                                 |


*** Emacs中的拼写检查（使用Ispell）

有些编辑器可以自动对我们输入的英语单词进行拼写检查，甚至还能给出拼写建议（比如Microsoft
Word），Emacs当然也可以做到这个功能，甚至更加强大。不过，Emacs本身并不提供这个功能，幸运的是像Ispell和Aspell这样的拼写检查工具都提供了Emacs相应接口，因此，通过在Emacs中调用Ispell的命令，我们可以一边编辑文件一边进行拼写检查。

Ispell和Aspell现在在Emacs已经内置支持，通常不需要自己安装。如果你发现Emacs里确实没有Ispell的支持，或者你想升级到最新的ispell.el，那就请参见[[http://www.kdstevens.com/stevens/ispell-faq.html#install][这里]]。

**** ispell-minor-mode：实时拼写检查

要让Flyspell随时根据你的输入提示错误拼写，可以打开*ispell-minor-mode辅模式*。在ispell-minor-mode 模式下，
当你输完一个单词时，Ispell
会自动帮您在辞典里查询这个单词，如果找不到这个单词，它就会/哔/一声来提醒您。

要启动或关闭这模式，请键入指令：

| #+BEGIN_EXAMPLE                      |
|     1                                |
| #+END_EXAMPLE                        |
|                                      |
| #+BEGIN_EXAMPLE                      |
|     M-x ispell-minor-mode <Return>   |
| #+END_EXAMPLE                        |


**** ispell-buffer：全文拼写检查

在emas中，可以使用*ispell-buffe*r命令，对光标之后的单词逐个进行拼写检查：

| #+BEGIN_EXAMPLE                  |
|     1                            |
| #+END_EXAMPLE                    |
|                                  |
| #+BEGIN_EXAMPLE                  |
|     M-x ispell-buffer <Return>   |
| #+END_EXAMPLE                    |


如果全文拼写正确，就会提示检查完成。如果发现不认识的单词，此时ispell将会把光标定在该单词的位置，在文本的上方会显示修改建议，如图1：

[[/images/ispell-and-flyspell/Evrd5.png]]

此时ispell会等待用户的进一步的指令：

| 键盘指令   | C-h 或者 ?       | 空格               | a/A                                            | r/R            | i/I                      | u                                    | q/Q            |
| 功能       | 获得进一步帮助   | 忽略这个错误拼写   | 在全文中都忽略这个单词（只在这个缓冲区有效）   | 修改这个单词   | 将这个单词加入个人辞典   | 将这个单词以小写的形式加入个人辞典   | 退出单词检查   |

如果文档中有多处相同的拼写错误，可以使用“R”进入查询替换，输入要替换的单词，当查找到第二个匹配的单词时，按下“!”将自动将接下来所有的单词替换成正确的单词。

[[/images/ispell-and-flyspell/iqdSB.png]]

[[/images/ispell-and-flyspell/bmhjf.png]]

使用Ispell要注意以下两点：

1. *Ispell是根据你所指定的辞典里的单词来确定这个词是否拼写正确的*。换句话说，如果某个单词没有在选定的辞典里有定义的话，即使它的拼写是正确的，Ispell也会把它当成错误的拼写。如果光标不在文章开头的第一个位置，要进行全文检查的话就得先使用M-<将光标移动到文章开头。
2. *同一个单词的不同形式，比如复数、过去式、过去分词等，在进行拼写检查时需要分别进行*。比如，如果你把receive拼成了“recieve”，Ispell会把“recieved”当成另外一个单词，所以这个拼写检查器会把它当作另外一个拼写错误找出来。

**** C-r：递归编辑

我们经常会遇到这种情况：当我们在查找修改某段文本的时候，可能会意外发现当前的查找结果周围有个地方需要修改，但因为现在正在进行查找修改，如果不想中断当前的工作，我们就只好等着完成查找修改工作后再找到刚刚那个位置，但却记不起来在那里了。拼写检查也可以看成一类查找（对错误拼写的查找），为了解决这个问题，Emacs给我们提供了一个贴心的编辑方法------递归编辑。

什么是递归编辑呢？我们可以把递归编辑看成一种中断：当你在进行某个查找任务的时候，还能够暂时中断当前的查找工作，去进行其他的编辑工作，完成后再跑回刚刚的中断的地方，继续未完成的查找。这和“递归”有什么联系呢？这是因为，这种中断可以嵌套！你可以在查找单词A的时候中断A的查找，进入一个递归编辑，在这个位置开始对B进行查找，突然在某个B的查找位置你又看到周围有个单词C要修改，你又可以暂时中断对B的查找，而进入另一个递归编辑。等你修改完C后，你可以回到上一个查找的中断位置，继续对B进行查找。等你查找完B之后，你又可以回到再上一个查找的中断位置，继续对A进行查找。说起来很复杂，其实道理非常简单。我还是“一图以蔽之”吧：

[[/images/ispell-and-flyspell/Gmot9.png]]

使用方法：

| C-r            | C-M-c                        | C-] (命令：top-level)          |
| 进入递归编辑   | 结束递归编辑并继续拼写检查   | 结束递归编辑，并退出拼写检查   |

例如，在在修改“xmas”的时候，突然发现要修改“newyear.”

[[/images/ispell-and-flyspell/Y088c.png]]

C-r进入递归编辑，使用replace-string命令将“newyear.”改成“new year!”

[[/images/ispell-and-flyspell/N9Ow2.png]]

**** Ispell-word：检查单个单词

有时候我们拼写某个单词脑袋壳突然卡住了：“哎，这个词怎么拼啊？”或者“我好像拼得不对”。这时，我们可以利用Ispell来单独检查光标所在的这个单词，如果想对光标位置上的单词进行检查，请按下
=M-$=
（命令名是ispell-word）组合键，或者从【Spell】拼写菜单里选择执行“Check
Word”（检查单词）操作，Ispell将对那个单词进行检查，并给出检查结果。

| #+BEGIN_EXAMPLE                      |
|     1                                |
| #+END_EXAMPLE                        |
|                                      |
| #+BEGIN_EXAMPLE                      |
|     M-$ (M-x ispell-word <Return>)   |
| #+END_EXAMPLE                        |


[[/images/ispell-and-flyspell/SltMB.png]]

**** ispell-complete-word：单词补全

有时我们想不起来要怎么拼一个单词，这就到Ispell的单词补全功能大展身手的时候了。敲击ESC-tab（命令名是ispell-complete-word），将获得一个可供选择的列表。

| #+BEGIN_EXAMPLE                            |
|     1                                      |
| #+END_EXAMPLE                              |
|                                            |
| #+BEGIN_EXAMPLE                            |
|     ESC-tab（M-x ispell-complete-word ）   |
| #+END_EXAMPLE                              |


[[/images/ispell-and-flyspell/gCBFZ.png]]

**** ispell-kill-ispell：终止Ispell进程

只要启用了Ispell，它就将一直在后台运行等待再次启用。如果觉得它使得系统变慢了，可以输入
=M-x ispell-kill-ispell <Return>=
杀掉这个进程，或是从“Spell”菜单里选择执行“Kill
Process（终止进程）”操作。

| #+BEGIN_EXAMPLE               |
|     1                         |
| #+END_EXAMPLE                 |
|                               |
| #+BEGIN_EXAMPLE               |
|     M-x ispell-kill-ispell    |
| #+END_EXAMPLE                 |


*** Emacs中的高亮错误拼写

**** 什么是Flyspell

Flyspell是Ispell的增强工具，Ispell只能够在缓冲区里逐个提示错误的拼写，如果想要用下划线的形式标记出所有错误的拼写，可以使用Flyspell。这样的好处是你可以继续编辑你的文本，而不需要进入查找模式。很多高级的编辑器都是采用这样的方式来提醒用户可能存在的错误拼写。

**** flyspell-mode：实时高亮提醒错误拼写

要让Flyspell随时根据你的输入提示错误拼写，可以打开*flyspell-mode*模式：

| #+BEGIN_EXAMPLE          |
|     1                    |
| #+END_EXAMPLE            |
|                          |
| #+BEGIN_EXAMPLE          |
|     M-x flyspell-mode    |
| #+END_EXAMPLE            |


例如，打开Flyspell辅模式后，在缓冲区中输入“applle.”之后，Flyspell将对applle高亮显示。

[[/images/ispell-and-flyspell/2Awhx.png]]

flyspell-mode和ispell-minor-mode的区别主要是flyspell的错误拼写提醒方式是用下划线，而ispell-minor-mode则会在消息窗口进行提示，并/哔/一声进行提醒，有时候会让人厌烦（当然，可以通过设置关闭声音提醒）。因此，flyspell显得比较“安静”，因此更受人喜欢。

**** flyspell-buffer：查找错误拼写并高亮

如果只需要检查一下缓冲区现有的文本，可以使用*flyspell-buffer*：

| #+BEGIN_EXAMPLE            |
|     1                      |
| #+END_EXAMPLE              |
|                            |
| #+BEGIN_EXAMPLE            |
|     M-x flyspell-buffer    |
| #+END_EXAMPLE              |


[[/images/ispell-and-flyspell/1n2zn.png]]

flyspell-buffer和ispell-buffer的区别：*ispell-buffer是进入对错误拼写的查找，并逐个提示错误的拼写，而flyspell-buffer会在检查完所有拼写后，一次性将所有找到的错误以下划线的形式标记出来。*

要对Flysepll高亮的文本进行修改，可以将鼠标移到该单词上，点击 *鼠标中键 *，将弹出一个菜单。（什么？没有鼠标中键？听我的，你真的需要去买一个新鼠标了
:tounge:
）如果要在当前编辑的缓冲区中接受这个拼写，可以在弹出菜单中选择Accept(session)；如果要在本次Emacs运行期间打开的所有缓冲区中接受这个拼写，可以选择Accept(buffer)；如果要永久记住这个拼写，可以选择Save
this word。

还有一种专门为程序员提供的辅模式flyspell-prog-mode，Emacs将只在注释和字符串里高亮错误的拼写。

| #+BEGIN_EXAMPLE               |
|     1                         |
| #+END_EXAMPLE                 |
|                               |
| #+BEGIN_EXAMPLE               |
|     M-x flyspell-prog-mode    |
| #+END_EXAMPLE                 |


*** 其他定制

**** 让Emacs自动开启flyspell-mode

对于很多打字员来说，*flyspell-mode*是一个非常实用的辅模式，如果想要让Emacs启动时自动打开flyspell-mode，可以在.emacs文件里添加这一行：

| #+BEGIN_EXAMPLE                               |
|     1                                         |
| #+END_EXAMPLE                                 |
|                                               |
| #+BEGIN_EXAMPLE                               |
|     (setq-default flyspell-mode t) <Return>   |
| #+END_EXAMPLE                                 |


**** 选择Ispell预设辞典

如果你为Ispell安装了不止一个辞典，你可以设定Emacs，使之在开始载入某一文件时，便自
动选择所需的辞典（你可以选择好几个）。预设辞典(main dictionary)
即主要辞典，是与
Ispell一起发行的辞典。您可以选择您所需要的语言。第二个即是你的个人辞典(personal
dictionary)，你可以设定要
Ispell将您在主要辞典里所找不到的字放到这里。假如您要将
Ispell里的法文辞典设为预设辞典，并想用你主目录 (home directory)下的
‘.ispell-dico-perso' 文档作为个人辞典，可以在 ‘.emacs'
文档里加入下列指令：

| #+BEGIN_EXAMPLE                                                                                                                                               |
|     12345                                                                                                                                                     |
| #+END_EXAMPLE                                                                                                                                                 |
|                                                                                                                                                               |
| #+BEGIN_EXAMPLE                                                                                                                                               |
|     (setq sgml-mode-hook'(lambda () "Defauts for SGML mode."(setq ispell-personal-dictionary "~/.ispell-dico-perso")(ispell-change-dictionary "francais")))   |
| #+END_EXAMPLE                                                                                                                                                 |


**** 为特定文件设定个别的辞典

在每一个文档的结尾，只要将下列指令加入作为注释，你都可以指定您现行的文档要使用哪一辞典。
Ispell 开始拼字检查时即可应用所指定的辞典：

| #+BEGIN_EXAMPLE                                                                                |
|     12                                                                                         |
| #+END_EXAMPLE                                                                                  |
|                                                                                                |
| #+BEGIN_EXAMPLE                                                                                |
|     <!-- Local IspellDict: english --><!-- Local IspellPersDict: ~/emacs/.ispell-english -->   |
| #+END_EXAMPLE                                                                                  |


*** 本文参考资料

1. [[http://www.google.com.hk/url?sa=t&rct=j&q=Learning+GNU+Emacs&source=web&cd=1&ved=0CCwQFjAA&url=http%3A%2F%2Fbook.douban.com%2Fsubject%2F1431970%2F&ei=Npr1Ttv4OeaziQeg4KXuAw&usg=AFQjCNGR0JeJmtslTGgFcY3le75a1jIIhA&sig2=CvEr-ea6iU4hRy06oFG2Sg][Learning
   GNU Emacs, 3rd Edition(Debra Cameron, James Elliott, Marc Loy)]]
2. [[http://man.chinaunix.net/linux/how/LinuxDoc+Emacs+Ispell-HOWTO-5.html][LinuxDoc+Emacs+Ispell-HOWTO中文版(Philippe
   MARTIN, Sébastien Blondeel, 李安珊)]]
** [[http://m.oschina.net/blog/124113][]]

使用iimage-mode可以在buffer里面显示图片，改了一个lisp函数来实现截屏、保存文件并插入到buffer中的功能。参考了这个： http://dreamrunner.org/wiki/public_html/Emacs/org-mode.html#sec-2-3


安装起来很简单：

安装scrot，会用这个工具来截图

创建一个文件夹 ~/.emacs.img ，截屏产生的图片会保存到这里

把下面的lisp放到emacs的配置文件中(我把截屏的快捷键绑定到了C-p上面)

;;;  image for org-mode
; 1. suspend current emacs window
; 2. call scrot to capture the screen and save as a file in $HOME/.emacs.img/
; 3. put the png file reference in current buffer, like this:  [[/home/path/.emacs.img/1q2w3e.png]]

(add-hook 'org-mode-hook 'iimage-mode) ; enable iimage-mode for org-mode
(defun my-screenshot ()
  "Take a screenshot into a unique-named file in the current buffer file
  directory and insert a link to this file."
  (interactive)
  (setq filename
    (concat (make-temp-name
         (concat  (getenv "HOME") "/.emacs.img/" ) ) ".png"))
  (suspend-frame)
  (call-process-shell-command "scrot" nil nil nil nil " -s " (concat
                                "\"" filename "\"" ))
  (insert (concat "[[" filename "]]"))
  (org-display-inline-images)
  )

(global-set-key (kbd "C-p") 'my-screenshot)
** [[http://blog.163.com/wobutianl@126/blog/static/1335848201293033635805/][emacs 计算器  ]]


1. Quick Calculator模式

在Emacs23里，可以用命令M-x quick-calc或快捷键C-x * q来启动Quick Calculator模式。这是一个非常小巧的工具，启动后会在minibuffer里提示输入数学计算式，回车就显示结果。这个模式能非常方便地用来做一些基本的数学运算，比用系统自带的计算器来得方便、快捷一些。

用C-g可以退出Quick Calculator模式。

2. programmable calculator

在Emacs23里，用命令M-x Calc或是通过菜单”Tools –> Programmable Calculator“就可以启用programmable calculator模式。总的来说，programmable calculator模式可以有以下三方面的用途：

(1) 数学计算

如果要计算1 + 2的值，输入”1 回车 2 回车 +”即可。

(2) 在二进制、八进制、十进制与十六进制之间进行转换

输入”10 回车 d2″，这个d2会把窗口中的所有数字显示为二进制形式，所有的数字都会以”2#”开头，以表示它们是二进制形式。如果要重新用十进制显示，则输入”d0″即可。

同样，也可以用”d8″，”d6″来显示八进制和十六进制的格式。

如果要把1010这样的二进制数转成十进制数，则输入”2#1010 回车”，然后再输入”d0″就可以显示该数字的十进制格式。

同样，输入八进制数以”8#”开头，输入十六进制以”16#”开头。

(3) 温度单位转换

如果你想知道40 F°是多少C°，输入”40 回车 ut dF 回车 dC 回车”即可，这下就不会再为这些温度单位换算弄得晕头转向了吧！

如果要退出programmable calculator这个计算器，则输入”q”即可。

总的来说，这个programmable calculator风格有点怪异，不是太复杂的功能，还是不要用为好。
** [[http://blog.csdn.net/argansos/article/details/6867575][Eshell]]

eshell 并不是一个真正的 shell，它只能在 emacs 上运行。尽管和 bash、zsh
相比,它的功能很有限，但对大多数人来说已经足够了。此外,由于 eshell 是 由
elisp 编写的，所以它还有其他 shell
所没有的一些特点，比如更强的扩展性和可以使用 emacs 函数。

1. alias

eshell 添加 alias 的方法和 bash 几乎是相同的，并且默认保存在
~/.eshell/alias。不同的是,eshell 中既可以使用外部命令，也可以使用 emacs
函数，比如:

#+BEGIN_EXAMPLE
    alias ll ls -al $*
    alias dl dpkg -l $1
    alias e find-file $1
    alias v view-file $1
    alias sai sudo aptitude install $1
#+END_EXAMPLE



2. histroy

bash 中有很多变量控制命令历史，比如: HISTCONTROL、HISTIGNORE 和
HISTFILESIZE。和它们相对应的 eshell
变量是 eshell-hist-ignoredups、eshell-input-filter
 和 eshell-history-size。eshell-hist-ignoredups
决定是否忽视重复的命令，eshell-history-size 控制历史文件的大小。
eshell-input-filter 的值其实是一个函数,我们每输入一条命令，这条命令会
作为参数传递给 eshell-input-filter，如果返回
t，这条命令才会被保存到历史中。它默认只过滤空白命令，如果要过滤
ls、cd、clear，可以这样修改:

#+BEGIN_EXAMPLE
    (defvar eshell-histignore
    '("\\`\\(ls\\|ll\\|cd\\|clear\\)\\'"
    "\\`\\s-*\\'"))
    (setq eshell-input-filter
    #'(lambda (str)
    (let ((regex eshell-histignore))
    (not
    (catch 'break
    (while regex
    (if (string-match (pop regex) str)
    (throw 'break t))))))))
#+END_EXAMPLE



3. completion

zsh 的补全据说非常强大，安装 bash-completion 后 bash
的补全也变得不错。eshell
的补全虽然没有前两者丰富，但却很灵活,自定义也很简单。eshell 的补全依靠
pcomplete，以定义上面的 sai 的补全函数为例。

首先获取当前符合名称的软件包的列表:

#+BEGIN_EXAMPLE
    (defun pcmpl-package-cache (name)
    "return a list of packages in cache"
    (unless (equal name "")
    (split-string (shell-command-to-string
    (concat "apt-cache pkgnames " name " 2> /dev/null")))))
#+END_EXAMPLE


 其次定义 sai 的补全函数:

#+BEGIN_EXAMPLE
    (defun pcomplete/sai ()
    "completion for `sai'"
    (while
    (pcomplete-here
    (pcmpl-package-cache (pcomplete-arg 'last)))))
#+END_EXAMPLE


 现在在 eshell 里就可以按 TAB 对 sai 进行软件包名字的补全了。
 eshell 的一些补全选项:

#+BEGIN_EXAMPLE
    (setq eshell-cmpl-ignore-case t      ; 补全时忽略大小写
    eshell-cmpl-cycle-completions nil) ; 不要循环补全
#+END_EXAMPLE


 4. cd path

在 bash 里我们可以通过 cd - 回到上一个目录，eshell
同样可以。不仅如此，cd -<number>会回到倒数第 number个目录。cd =<REGEXP>
会回到上一个满足 REGEXP 的目录。zsh 中有对路径的别名，cd~X可以进入 ~X
所指代的目录，当目录比较深或很常用时非常方便。这在 eshell
也可以方便地实现。

首先定义一个别名与路径的关联表:

#+BEGIN_EXAMPLE
    (defvar eshell-path-alist
    `(("e" . ,user-emacs-directory)
    ("t" . "/tmp/")
    ("document" . "~/Documents/")
    ("download" . "~/Downloads/")
    ("v" . "~/video/")
    ("p" . "~/Pictures/")))
#+END_EXAMPLE


 现在直接修改ehsell/cd是可行的，但另外定义一个函数更方便:

#+BEGIN_EXAMPLE
    (defun eshell/d (arg)
    (let ((path (cdr (assoc arg eshell-path-alist))))
    (eshell/cd path)))
#+END_EXAMPLE


 eshell /d 的补全函数也很容易:

#+BEGIN_EXAMPLE
    (defun pcomplete/d ()
    (pcomplete-here
    (mapcar #'car eshell-path-alist)))
#+END_EXAMPLE


 现在直接输入 d t 就可以进入 /tmp
** [[http://blog.csdn.net/yzzst/article/details/12045801][linux下apache 的安装，php安装过程]]

linux下apache 的安装
1、进入work目录下:cd /usr/local/work
（如没有则自己新建，命令：mkdir /usr/local/work）

2、在work目录下从网站下载apache并解压：
wget http://dev.xiaonei.com/apache-mirror/httpd/httpd-2.0.63.tar.gz
解压：tar zxvf httpd-2.0.63.tar.gz

3、进入httpd-2.0.63目录：cd httpd-2.0.63

4、建立makefile，并将Apache安装到/usr/local/apache2目录下：
./configure -prefix=/usr/local/apache2 -enable-module=so   （/configure前有一个点“.”的）

5、开始编译：make

6、开始安装Apache到work目录中：
make install

7、至此Apache的安装工作完成，可以在每次启动系统时通过如下命令启动或重新启动Apache服务：
/usr/local/apache2/bin/apachectl start
/usr/local/apache2/bin/apachectl restart

8、打开浏览器,在地址栏输入“http://localhost”出现“It works!”或apache图标的漂亮界面，说明apache安装成功！




//////////////PHP 安装////


1.获取安装文件： http://www.php.net/downloads.php   http://cn2.php.net/distributions/php-5.5.4.tar.gz
wget http://cn2.php.net/distributions/php-5.5.4.tar.gz


获取安装php需要的支持文件：http://xmlsoft.org/sources/libxml2-2.9.1.tar.gz
wget http://xmlsoft.org/sources/libxml2-2.9.1.tar.gz


2.安装libxml2


 tar zxvf libxml2-2.9.1.tar.gz
 cd libxml2-2.9.1.
 ./configure --prefix=/usr/local/libxml2
 make
 make install




如果安装成功以后，在/usr/local/libxml2/目录下将生成bin、include、lib、man和share五个目录。在后面安装PHP5源代码包的配置时，会通过在configure命令的选项中加上"--with-libxml-dir=/usr/ local/libxml2"选项，用于指定安装libxml2库文件的位置。






3.安装php5




#tar zvxf php-5.5.4.tar.gz
#cd php-5.5.4
#./configure --prefix=/usr/local/php --with-apxs2=/usr/local/apache2/bin/apxs --with-libxml-dir=/usr/local/libxml2
#make
#make install


4.重新配置apache2让他支持php


配置 httpd.conf 让apache支持PHP：
# vi /usr/local/apache2/conf/httpd.conf


找到 AddType application/x-gzip .gz .tgz 在其下添加如下内容


     AddType application/x-httpd-php .php      (.前面有空格)


AddType application/x-httpd-php-source .phps        (.前面有空格)


然后CPOPY PHP的配置文件
cp php-5.5.4/php.ini.dist /usr/local/php/lib/php.ini


    （如果没有php.ini.dist 则把php.ini-development php.ini-production中的任何一个重命名为php.ini.dist即可。）


修改php.ini文件 增加 register_globals = On


重启apache
service apache restart


5.测试php是否成功安装


写一个php测试页info.php，放到apache2/htdocs中。


<?php


 phpinfo();


?>;


在浏览器中输入：服务器地址/info.php


如果能正常显示出php的信息，则说明Apche+Mysql+PHP安装成功！






今日编译apache时出错：//////////////////////////////////


#./configure --prefix……检查编辑环境时出现：


checking for APR... no
configure: error: APR not found .  Please read the documentation


解决办法：


1.下载所需软件包：


wget http://archive.apache.org/dist/apr/apr-1.4.5.tar.gz
wget http://archive.apache.org/dist/apr/apr-util-1.3.12.tar.gz
wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.10/pcre-8.10.zip
2.编译安装：


yum remove apr-util-devel apr apr-util-mysql apr-docs apr-devel apr-util apr-util-docs
具体步骤如下:


  a:解决apr not found问题>>>>>>


[root@xt test]# tar -zxf apr-1.4.5.tar.gz
[root@xt test]# cd  apr-1.4.5
[root@xt apr-1.4.5]# ./configure --prefix=/usr/local/apr
[root@xt apr-1.4.5]# make && make install

  b:解决APR-util not found问题>>>>


[root@xt test]# tar -zxf apr-util-1.3.12.tar.gz
[root@xt test]# cd apr-util-1.3.12
[root@xt apr-util-1.3.12]# ./configure --prefix=/usr/local/apr-util -with-apr=/usr/local/apr/bin/apr-1-config
[root@xt apr-util-1.3.12]# make && make install


  c:解决pcre问题>>>>>>>>>


[root@xt test]#unzip -o pcre-8.10.zip
[root@xt test]#cd pcre-8.10
[root@xt pcre-8.10]#./configure --prefix=/usr/local/pcre
[root@xt pcre-8.10]#make && make install
4.最后编译Apache时加上：


--with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util/ --with-pcre=/usr/local/pcre
** [[http://www.cam.hi-ho.ne.jp/oishi/indexen.html][XKeymacs]]

XKeymacs is a keyboard utility to realize emacs like-useability on all
windows applications. With XKeymacs you can use emacs keybindings with
any windows application. You can create a keyboard macro and assign any
shortcut key too. You also get bash-like command completion in your DOS
shell. If you do not know Emacs, Xemacs, Mule or Meadow, you probably
want nothing to do with XKeymacs. I began to make XKeymacs because I
wanted to add C-t and C-l to Keymacs. Now that all the functions I want
are available, I think I will burnish XKeymacs by adding new functions
that users want and to fix bugs.
 Supported OS: Windows 95, 98, Me, NT 4.0, 2000, XP, 2003, Vista
(Internet Explorer 5.0 is required on Windows 95, 98 or NT 4.0.)

[[xkeymacs347.zip][xkeymacs347.zip (198,839 bytes)]]
 It includes xkeymacs.exe, xkeymacs.dll, [[readmeen.html][Readme.txt]],
[[readme.html][Readme_J.txt]], [[dot.xkeymacs]],
[[faqen.html][FAQ.txt]], [[faq.html][FAQ_J.txt]],
[[releaseen.html][release.txt]], [[release.html][release_J.txt]],
[[specen.html][spec.txt]] and [[spec.html][spec_J.txt]].


 [[xkeymacssrc347.zip][xkeymacssrc347.zip (181,788 bytes)]]
 It is the [[sourceen.html][source code]] of xkeymacs.exe and
xkeymacs.dll. You can compile them by using Microsoft Visual C++ 6.0.
 - You have to install
[[http://www.microsoft.com/msdownload/platformsdk/sdkupdate/][Microsoft
Platform Software Development Kit (SDK)]] and add include/lib directory
at the top of list on Directory tab in Options dialog of Microsoft
Visual C++ 6.0.

 [[xkeymacs347.msi][xkeymacs347.msi (246,272 bytes)]]
 It is installer of XKeymacs.
 [[xkeymacsins347.zip][xkeymacsins347.zip (218,445 bytes)]]
 It is the source of the installer. You can build them by Microsoft
Visual Studio Installer.

[[http://xkeymacs.sourceforge.net/archive/][Archive of old versions]]

[[xkeymacsen.png]]

[[http://lists.sourceforge.net/lists/listinfo/xkeymacs-support][Mailing
List]]
 Please tell me your impression, question, request, etc. I announce bug
information and new version release news on this ML.

Known Problems (or Specifications?!)

-  C-l does not work well with someapplications.
-  M-? by the Alt key is ignored with Microsoft Visual C++ or Netscape.
   (It works well if you retry.)
-  C-r works as C-s with Internet Explorer if Find dialog does not
   appear.
-  C-t, etc. do not work well with command prompt.
-  C-k works as C-f on an edit box for a password.
-  XKeymacs version 1.16 and later will be occured Invalid Page Fault
   error of Kernel32.dll on Windows 95.
    (But only the dialog pop up, OS and/or applications are never
   ABEND.)
-  XKeymacs causes an application error when you shutdown Windows NT.
-  XKeymacs conflicts with X-mouse of Tweak UI.
-  XKeymacs conflicts with KbdAcc. (Acceleration does not work well in
   some case.)

Notes
 The xkeymacs.exe require the mfc42.dll and the msvcrt.dll. If your
system does not have these files, the xkeymacs.exe pop up an error
message. When an error message is poped up, you must get the mfc42.dll
(ex. from
[[http://www.vector.co.jp/soft/win95/util/se040499.html][here]]) and the
msvcrt.dll and put them in the directry which include the xkeymacs.exe.
** [[https://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/][Research Paper Management with Emacs, org-mode and RefTeX]]

January 4, 2011

/Update 3-11-14: / **Nuno Salgueiro* *in the comments led me to a RefTeX
change that broke the “jump to this entry in notes.org” behavior (it
seems “reftex-citation” returns a list now, regardless if there is only
one entry). This can be fixed by changing (reftex-citation t) to (first
(reftex-citation t)).

/Update 1-19-11:/ I've added a screencast of me demonstrating how I use
this setup to work with my papers, I've also re-written the “Workflow”
section (due to the fact it was kind of confusing...) Hope this all
helps :]

/Update 4-27-12:/  *olberger* (in the comments section) has added, what
I consider, an incredibly clever and useful function to help when
writing papers. I've just finished tweaking it slightly for my purposes,
but please check out his post,
[[http://www-public.it-sudparis.eu/~berger_o/weblog/2012/03/23/how-to-manage-and-export-bibliographic-notesrefs-in-org-mode/][here]].
I'll be adding what I did to this post... when I get around to it.

My labmates and I have been searching for a while now for methods to
organize the mountain of research papers we collect as graduate
students. I've tried a handful of approaches, and was happy using
zim-wiki for a while, but entering info became a choir, and finding a
paper could sometimes be a hassle.

My recent attempts at working with lisp have led me to switch to emacs,
and in what seems to be a common occurrence, I wanted to do everything
in emacs. As silly as that sounds, I believe I've found my solution to
organize my papers through emacs.

Managing papers and references in emacs is nothing new, and I actually
followed a few guides on how other people used org-mode and reftex to do
so. Specifically this
[[http://www.mfasold.net/blog/2009/02/using-emacs-org-mode-to-draft-papers/][post]],
and this
[[http://article.gmane.org/gmane.emacs.orgmode/2406/match=bibliography][email]].
My hope with this initial post is to pull the bits together, show what I
built on top of them, and how I setup my org files to facilitate my
workflow. If you don't know how to use or don't know what emacs and
org-mode are, give a quick search--there is plenty of info out there.

***** *Setting up RefTeX*

First, we want to load to load RefTeX whenever we use org-mode. This is
well documented, and mine only differs in the citation formats I pass to
RefTex, and my additional key binding.

#+BEGIN_EXAMPLE
    (defun org-mode-reftex-setup ()
      (load-library "reftex")
      (and (buffer-file-name) (file-exists-p (buffer-file-name))
           (progn
         ;enable auto-revert-mode to update reftex when bibtex file changes on disk
         (global-auto-revert-mode t)
         (reftex-parse-all)
         ;add a custom reftex cite format to insert links
         (reftex-set-cite-format
          '((?b . "[[bib:%l][%l-bib]]")
            (?n . "[[notes:%l][%l-notes]]")
            (?p . "[[papers:%l][%l-paper]]")
            (?t . "%t")
            (?h . "** %t\n:PROPERTIES:\n:Custom_ID: %l\n:END:\n[[papers:%l][%l-paper]]")))))
      (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
      (define-key org-mode-map (kbd "C-c (") 'org-mode-reftex-search))

    (add-hook 'org-mode-hook 'org-mode-reftex-setup)
#+END_EXAMPLE

***** *Jump to Entry*

The other difference I added was the binding of  “C-c (” to
org-mode-reftex-search, which I defined earlier in my init.el. This is
the command that will jump to the entry in my org-mode file, and follows

#+BEGIN_EXAMPLE
    (defun org-mode-reftex-search ()
      ;;jump to the notes for the paper pointed to at from reftex search
      (interactive)
      (org-open-link-from-string (format "[[notes:%s]]" (reftex-citation t))))


    (defun org-mode-reftex-search ()
      ;;jump to the notes for the paper pointed to at from reftex search
      (interactive)
      (org-open-link-from-string (format "[[notes:%s]]" (first (reftex-citation t)))))
#+END_EXAMPLE

Simple. But I was happy with the results. /Update:/ changes in reftex
from initial authoring of this post have reftex-citation return a list.
An updated function to fix this has been added :P

***** *Making Org-mode work with you*

Lastly, org-mode needs a few things to pull all this together. The first
and most important is importing the bibtex file. RefTeX looks for a
LaTeX \bibliography tag anywhere in the file, I place mine as an
org-mode comment at the start of the file

#+BEGIN_EXAMPLE
    # \bibliography{~/research/refs.bib}
#+END_EXAMPLE

The other thing needed is link abbreviations. While you could hardcode
this into your citation formats, I prefer to put abbreviations in for
the citation formats, and define defaults elsewhere in my init.el

#+BEGIN_EXAMPLE
    (setq org-link-abbrev-alist
          '(("bib" . "~/research/refs.bib::%s")
        ("notes" . "~/research/org/notes.org::#%s")
        ("papers" . "~/research/papers/%s.pdf")))
#+END_EXAMPLE

These can be easily overridden in an org-mode file, which I actually do
for the org-mode file I store the actual entries in. If I left it as is,
following a “notes” link in this org-mode file would open the same file
in a new window and jump to the entry in that one. Not quite what we
want. This is where I override it in the local file by adding this to my
heading.

#+BEGIN_EXAMPLE
    #+LINK: notes #%s
#+END_EXAMPLE

Now, if I follow a “notes” link in the entries file, it jumps to that
entry in the same frame, while following a “notes” link in another
org-mode file (or using my new reftex search addition) will open this
file in a new frame and jump to the entry.

***** *Workflow*

My setup for this involves two main files: /refs.bib,/ the main bibtex
file, and /notes.org,/ the org-mode file I use to manage the papers and
store notes for each.

In /notes.org/ my overall workflow follows a typical org-mode
hierarchical layout, the key parent being “Papers” with each child
heading being either a category or an entry for a paper, each with the
appropriate or useful org-mode tags. Each paper headline corresponds to
that paper, and I write notes under these headlines about the paper.

The hierarchical layout has children inheriting parents tags which is
quite nifty. This is my initial lookup method when I'm looking for a
paper. For example, I want to find a paper that describes how to couple
EDOT using an iron catalyst, I can type “C-c \” to do a tag search, type
in one or all of the relevant keywords, and org-mode will show the
entries matching those tag[s]. I can then expand those entries, see what
notes I've written on the papers, and when I found the one I'm looking
for, I can open the link to the pdf I've placed there using “C-c C-o”.

When I find a new paper I need to add, I initially gather all the data I
need to use org-mode: the bibtex entry and the paper itself. I modify
the bibtex key to fit with my scheme (FirstAuthorYear) but you can use
whatever suites you best. I then save the paper using that bibtex key as
the filename in another folder.

Note: I manage my bibtex entries by first saving each new bibtex entry
as a separate file in a collective folder (due to the fact I usually
export them from the journal's website when I find the paper) and then I
concatenate all the files in that folder to make a new bibtex file using

#+BEGIN_EXAMPLE
    $ cat bibtex/*.bib > refs.bib
#+END_EXAMPLE

This feels a little messy, but the easiest solution I could think of;
I'm sure I could setup a command to do this for me from emacs, but this
is a low priority. The one problem with this is if you change the bibtex
file while org-mode is running, RefTeX will not see the changes. To do
so you need to enable “global-auto-revert-mode” in emacs. Supposedly,
this is automatically enabled in emacs 23, but it seems to be disabled
by default for me (23.2.1)

Adding a new headline in my /notes.org/ file is simplified by using
RefTex. I place my cursor on a new line and hit “C-c )” which is bound
to “reftex-citation”. The first prompt is for a citation format (if more
than one) and I have a few for different purposes. I hit ‘h' for
heading, which contains all the formatting for a barebones paper
headline. This puts a new entry with the title of the paper as the
headline, a propeties list with custom-id of the bibtex key (this allows
linking to this entry by it's bibtex key), and a body containing a link
to the pdf. After selecting the format, RefTeX prompts for a regex to
search the bibtex file with, presenting a list of matching entries.
Selecting the desired entry inserts the citation, in this case, the new
entry.

This is how we exploit RefTeX, we create custom citation formats that
are really org-mode tags and formattings. A few other formats I have are
all org-mode links: one that links to the entry in the bibtex file
itself, one that links to the pdf, and another that links to the entry
in the org-mode file. I use org-mode link abbreviations to get general
behavior that can be changed on a per-file basis.

Another option I recently added to this is a way to search for other
info I may not have placed in a tag, such as an author or journal name.
Here I shamelessly take adavtage of having reftex loaded again. I bound
this key to a custom command I made that will jump to the entry for the
bibtex entry you select from the reftex-citation prompt.

And that's that! So far, this is the most powerful approach I have
found, and I know I've spent less time searching than any other method
I've found. What's also great about this is that org-mode's exporting
allows me to export this as HTML to serve up on our group's website for
the rest of my group to use. An additional benefit is that because I'm
already gathering bibtex entries, when it comes time to write a paper, I
already have all my citation data, and I can easily search a key to
retrieve all my notes on that paper as well.

There are some weaknesses I'm still trying to work out, such as manually
scraping bibtex entries and making sure everything has the proper
filename. The problem really is that all the journals aren't consistent
with these things (some don't even provide bibtex export! Luckily,
there's bibutils to handle the conversions) and entries need to be
tweaked and/or pdf's named according to the key. Ideally, I would like
to find a database that I could script a tool against to scrape the data
I need and already name and places the files for me, but that is for
another day/entry

I've been trying to see about using attachments to handle the papers
instead, but I haven't been able to tweak it to my satisfaction just
yet. Still trying though. This should allow me to attach multiple files
for an entry (such as supporting info, etc)

** [[http://www.mfasold.net/blog/2009/02/using-emacs-org-mode-to-draft-papers/][Using Emacs Org-mode to Draft Papers]]

Scientific papers are mostly written in
[[http://www.latex-project.org/][LaTeX,]] a markup language for
typesetting. With LaTeX, a document is programmed rather than edited in
a WYSIWYG-way. There is a great deal of specialized editors or editor
modes (e.g. [[http://www.gnu.org/software/auctex/][AucTeX]]) simplifying
the creation of LaTeX documents. In many cases, however, you just want
to quickly write down what's in your head instead of getting stuck in
the details of LaTeX markup. I found that Emacs
[[http://orgmode.org/][org-mode]] is very well suited to fill that gap.
You can efficiently draft a scientific document that can directly be
converted into LaTeX code which you can beautify later on. I'll show you
here how.

*Installation*

First, you have to install org-mode for Emacs as described
[[http://orgmode.org/manual/Installation.html#Installation][here]].
Org-mode is included in Emacs since version 22.1 and the latest version
can be obtained from the a git repository via

#+BEGIN_QUOTE
  =git clone git://repo.or.cz/org-mode.git=
#+END_QUOTE

Be sure to use the latest version for this tutorial as there really is
some active development going on and some of the features I use were
included just recently.

*The First Document*

Begin by opening a new files with a “.org” extension. Paste the
following lines into that document

#+BEGIN_QUOTE
  =The Impact of Beer Consumption on Scientific Collaboration #+AUTHOR: Mario Fasold * Introduction ** Previous Work Some studies relating scientific output and beer have previously been done. #+BEGIN_QUOTE In Europe, most alcohol is consumed as beer and, based on well known negative effects of alcohol consumption on cognitive performance, I predicted negative correlations between beer consumption and several measures of scientific performance. #+END_QUOTE ([[www.zoologie.upol.cz/osoby/Grim/Grim_Oikos_2008_on-line.pdf]]) * Results ** What beer should you drink + Becks + Czech Budweiser + Duff=
#+END_QUOTE

The first line contains the title of your document. It will be used by
each of the exporters, e.g. LaTeX or HTML. Note that there was a bug in
the latex exporter, leading to duplicated text after the
table-of-contents if the first line of the document was a headline.
Leaving the fist line empty is the suggested
[[http://www.mail-archive.com/emacs-orgmode@gnu.org/msg08440.html][workaround]]
here.

The export can be controlled by various parameters that can be set
anywhere in the org-document. The syntax is “#+OPTIONS: toc:nil”, for
example
([[http://www.gnu.org/software/emacs/manual/html_node/org/Export-options.html][available
options]]). Some export options that might be useful to create a paper
draft include
 = =

-  #+AUTHOR: the author (default taken from user-full-name)
-  #+DATE: A date, fixed, of a format string for format-time-string
-  #+EMAIL: his/her email address (default from user-mail-address)

Using the very simple
[[http://orgmode.org/manual/Markup-rules.html][org-mode markup]], the
document then defines some sections, subsections, textblocks and
formulas. Note that only the first three outline levels (* -- ***) are
used for headlines by default. Using the markup you can easily define
lists, include other files, enter footnotes, define literal and source
code blocks (and even use Emacs font-lock for those areas) and more. For
example, a text literal is inserted via

#+BEGIN_QUOTE
  =#+BEGIN_EXAMPLE Some example from a text file. #+END_EXAMPLE=
#+END_QUOTE

and the following passes code directly into latex

#+BEGIN_QUOTE
  =#+BEGIN_LaTeX All lines between these markers are exported literally #+END_LaTeX=
#+END_QUOTE

Another honored mention be the org-tables mode which lets you create and
edit and tables in a dead-easy manner (try to swap a table column in
AucTeX...).

*Figures*

Papers and their drafts can't live without images in most cases. The
following syntax allows
[[http://thread.gmane.org/gmane.emacs.orgmode/8588/focus=9927][since
december]] to insert one

#+BEGIN_QUOTE
  =#+CAPTION: Degradation Plot #+ATTR_LaTeX: scale=0.75 #+LABEL: fig:degradation [[./images/DegradationPlot.png]]=
#+END_QUOTE

It's a little buggy still, for example, no underscores seem to be
allowed within filenames for now. For more complex cases, you can just
write the LaTeX-code (org-mode will recognize many identifiers):

#+BEGIN_QUOTE
  =\begin{figure}[!tpb] \centerline{ \includegraphics[scale=0.3]{images/BeerPlot} }\caption{This is plot looks like a beer.}\label{fig:Beer} \end{figure}=
#+END_QUOTE

*References*

You may also want to include references while drafting the paper.
Luckily, you can use RefTex-Mode (included in Emacs) to scan your
BibTeX-file (containing the bibliographies) and easily insert a
reference to an entry of that file. First, activate RefTex in org-mode
by inserting the following lines into .emacs:

#+BEGIN_QUOTE
  =(defun org-mode-reftex-setup () (load-library "reftex") (and (buffer-file-name) (file-exists-p (buffer-file-name)) (reftex-parse-all)) (define-key org-mode-map (kbd "C-c )") 'reftex-citation) ) (add-hook 'org-mode-hook 'org-mode-reftex-setup)=
#+END_QUOTE

Second, include the BibTeX-file by inserting

#+BEGIN_QUOTE
  =\bibliographystyle{plain} \bibliography{ProbePosition}=
#+END_QUOTE

at the end of your org-document. When you want to insert the reference
just invoke “C-c )”, enter a search term (e.g. auther name) and select
the right one from the search results. Note: When first opening the org
document, RefTeX will ask you to give him the name of the “master” which
is the .tex-file corresponding to your org-file.

You can also use org-mode to collect notes about all the publications
you are reading. Stick to
[[http://article.gmane.org/gmane.emacs.orgmode/2406/match=bibliography][this
description]] to find out how you could manage bibliographies and
PDF-documents in a nice way.

*Outlook*

Org-mode is a very versatile and extensible mode for Emacs. If Emacs is
considered an Operating System, consider Org-mode as the Emacs for that
system! I find org-mode particularly handy to draft papers. Include
images, formulas, tables and references with ease, without the hassle of
dealing with LaTeX markup.

Additionaly, you might use org-mode to organize related links, documents
and data. With
[[http://orgmode.org/worg/org-tutorials/org-R/org-R.php][org-R]] you can
even do any computations (e.g.statistics) and plots in-line using R --
no need to fragment your information! Also, expect to see nice features
appearing for org-mode frequently. I would be glad to hear how you use
org-mode to collect information and do science!

Ps. Someone even wrote his complete diploma thesis with org-mode. He
describes his experience
[[http://www.mail-archive.com/emacs-orgmode@gnu.org/msg04582.html][here]]
(his org-file is a good example, too).

** [[https://wiki.freebsdchina.org/doc/r/reference][利用 Emacs 的 org-mode 管理文献]]

*** 利用 Emacs 的 org-mode 管理文献

俗话说，“好记性不如烂笔头”。文献管理，不仅对科研工作者，对普通的用户也是必需的。看过的文献，写写心得做做笔记，以后写文章旁征博引的时候就不至于心乱如麻。

已有一些开源的文献管理的工具广受欢迎，如 JabRef、docear
等。一些常见的工具软件，读者可参阅
[[http://zh.wikipedia.org/wiki/文献管理软件比较][文献管理软件比较]]。

这里，我介绍另外一种简便的方法：利用 Emacs 的 org-mode
管理文献。原因有二：（1）Emacs
是可以使用一生的编辑器；（2）org-mode是做笔记的强大工具。

本着简单为美，高效为目的的原则，充分利用已有资源，本 wiki 的方法（源自
[[http://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/]]）能够出色地完成文献管理的任务。

*** 利用 Google Scholar 导出 bibtex 文件

写科技文章，TeX 排版工具是必须掌握的。现在的国际会议和期刊，哪个不要求
TeX 排版？我们假定读者熟悉 TeX 排版，了解最简单的 Emacs 使用方法。

在 TeX 中，文献的索引来自独立文件 *.bib，它的格式必须通过 bibtex
的编译。[[https://wiki.freebsdchina.org/software/r/refdb][文献管理软件
RefDB]]介绍了如何从 RIS 格式转化为 bib 格式。RefDB
是图书馆时代的产物，随着 Google Scholar
的普及，我们有更便捷的文献管理方法。

Google Scholar 提供了搜索文献和导出其 bibtex
描述的强大功能，它在某种程度上替代了图书馆检索和某些专业数据库检索（如
PubMed
等），让更多的人能够方便地检索到文献。在知识共享的年代，我认为，Google
Scholar 是 Google 公司最伟大的产品之一。

*** 文献管理有哪些功能？

一个文献管理软件，必须具备以下几项功能。

1. bibtex 格式
2. 文章标题、作者、期刊名等关键词搜索
3. 链接到本地保存的文章（一般为 PDF 格式）
4. 做笔记（写文章的时候，笔记很重要）
5. 在 TeX 文档中利用 \cite{} 索引

*** 准备工作

我当前使用的 Emacs 版本是 GNU Emacs
24.3.1（在更低的版本上我没有试验过），自带了 RefTeX。

需要额外安装的是 /usr/ports/deskutils/org-mode.el。

建立目录 ~/reference，里面建立目录 ~/reference/papers。另外，

#+BEGIN_EXAMPLE
    IOU@~/reference$ touch notes.org
    IOU@~/reference$ touch reference.bib
#+END_EXAMPLE

要求 notes.org 文件的开头是

#+BEGIN_EXAMPLE
    # \bibliography{~/reference/reference.bib}
#+END_EXAMPLE

为了演示方便起见，reference.bib 里只有一篇文献

#+BEGIN_EXAMPLE
    @Article{     blei2012probabilistic,
      title     = {Probabilistic topic models},
      author    = {Blei, David M},
      journal   = {Communications of the ACM},
      volume    = {55},
      number    = {4},
      pages     = {77--84},
      year      = {2012},
      publisher = {ACM}
    }
#+END_EXAMPLE

该文章取名为 blei2012probabilistic.pdf，存放于 ~/reference/papers/ 下。

*** .emacs 里的一些设置

在 $HOME/.emacs 文件里，添加以下设置。

#+BEGIN_EXAMPLE
    ;; 定义 org-mode-reftex-search
    (defun org-mode-reftex-search ()
     ;; jump to the notes for the paper pointed to at from reftex search
     (interactive)
     (org-open-link-from-string (format "[[notes:%s]]" (reftex-citation t))))

    (setq org-link-abbrev-alist
     '(("bib" . "~/reference/reference.bib::%s")
       ("notes" . "~/reference/org/notes.org::#%s")
       ("papers" . "~/reference/papers/%s.pdf")))

    ;; 当使用 org-mode 时，自动调 RefTeX
    (defun org-mode-reftex-setup ()
      (load-library "reftex")
      (and (buffer-file-name) (file-exists-p (buffer-file-name))
           (progn
        ;; enable auto-revert-mode to update reftex when bibtex file changes on disk
        (global-auto-revert-mode t)
        (reftex-parse-all)
        ;; add a custom reftex cite format to insert links
        (reftex-set-cite-format
          '((?b . "[[bib:%l][%l-bib]]")
            (?c . "\\cite{%l}")
            (?n . "[[notes:%l][%l-notes]]")
            (?p . "[[papers:%l][%l-paper]]")
            (?t . "%t")
            (?h . "** %t\n:PROPERTIES:\n:Custom_ID: %l\n:END:\n[[papers:%l][%l-paper]]")))))
      (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
      ;; binding of  ”C-c (” to org-mode-reftex-search
      (define-key org-mode-map (kbd "C-c (") 'org-mode-reftex-search))

    (add-hook 'org-mode-hook 'org-mode-reftex-setup)
#+END_EXAMPLE

*** 如何使用 notes.org 来管理文献

org-mode 是利用 Emacs 做笔记的强大工具，可以直接生成 html、TeX、PDF
等文档。

-  用 emacs 打开 notes.org 文件，将光标放置于某空行，利用命令 “C-c )”
   来建立文献索引入口，可以是 bibtex 的入口，也可以是 PDF
   文件的入口，也可以是 \cite{}。
-  命令 ”C-c (“ 可进行正则表达式搜索
-  要打开入口，只需光标停留在入口上，键入 “C-c C-o” 命令即可。
-  利用命令 “C-c \” 来搜索关键词。

*** 效果图

[[https://wiki.freebsdchina.org/_detail/doc/r/reference.png?id=doc%3Ar%3Areference][[[https://wiki.freebsdchina.org/_media/doc/r/reference.png]]]]

** [[http://www.binghe.org/2010/05/typeset-references-in-latex/#post-120][]]

** [[http://xb9he.bokee.com/6688578.html][LaTeX 的对参考文献的处理]]


LaTeX 的对参考文献的处理实在是非常的方便，我用过几次，有些体会，写出来供大家
参考。当然，自己的功力还不够深，有些地方问题一解决就罢手了，没有细究。

    LaTeX 对参考文献的处理有这么一些优点：

1. 可以维护一个 bib 文件，在你的整个研究生涯可以只维护这样一个文件，就象一个数
据库，每个参考文献是一个记录，由一个唯一的 ID （例如下面的 MartinDSP00）描述。
比如我的 myreference.bib 文件里一条典型的文献是这样的：

@article{MartinDSP00,
     author = "A. Martin and M. Przybocki",
     title = "The {NIST} 1999 speaker recognition evaluation --- an overview",

     journal = "Digital Signal Processing",
     volume = "10",
     pages = "1--18",
     year = "2000",}

    其中 {NIST} 中的大括号不会被显示，它的作用是保证将来的生成的参考文献中 NIST
 四个字保持原样，不会被小写。

2. 需要引用文献的时候，在正文里加入：

\bibliographystyle{ieeetr}
\bibliography{myreference}

    就可以用 \cite{} 来引用文献库中的论文了，如 \cite{MartinDSP00}。上面第一行是
控制文献显示格式的，这个后面再讲。此时，myreference.bib 文件在正文 tex 文件的同
一目录下，以保证 LaTeX 可以找到该 bib 文件。

3. 编译正文之后，生成 aux 文件，然后用 bibtex 在当前目录生成 bbl 文件，再编译正
文两次，完整的 dvi 就生成了。这样，LaTeX 保证了所有用 \cite 引用到的文献都已被
列出，并且自动编号。同时，如果没有用 \nocite 命令，LaTeX 还保证所有列出的参考文
献都在正文中得到了引用。

4. 关于 bib 文件
    前面提到 bib 文件的维护问题。我一般不对里面的文献排序，如果文献比较多，需要
查找的话，可以通过查询关键字来实现。bib 文件把 @ 所定义的 entry 之外的所有东西
看作是注释。比如在上面 @article 的例子里，如果我在大括号之外写些东西的话，bibt
ex 是不会关心的，就当它不存在。所以我就把文献的关键字写在这里，将来通过搜索关键
字来查找某些文献。其实也可以搞一个临时的 LaTeX 文件，使用 \nocite{*} 命令，然后
编译成 dvi，这样就得到了一个 bib 文件中所有参考文献的列表，当然是可以按照作者名
字排序的。
    另外，很多 journal（学术期刊）或者 booktitle（国际会议）都是重复的，为了规范
化，可以定义缩写，如

@string(ICASSP = "Proc. of the International Conference on Acoustics, Speech,
and Signal Processing (ICASSP)")

    然后

    @conference{QL.ICA98,
     author = "Qi Li and Biing-Hwang Juang",
     title   = "Speaker Verification Using Verbal Information Verification for A
utomatic Enrollment",
     booktitle = ICASSP,
     year = "1998",}

    这样在执行 bibtex 之后，ICASSP 会被替换成它的全称。

5. bib 中的中文文献
    中文文献和英文的格式不同，并且使用全角的标点符号，有一点难办。我的解决办法是
这样的：

    @misc{Xie.1995,
     note = "谢锦辉，《隐 {Markov} 模型及其在语音处理中的应用》，华中理工大学出
版社，1995年4月",
     key = "Xie",}

    唯一的缺陷是参考文献中最后是以英文的 "." 而不是 "。" 结束的。还好我的中文文
献不多，无伤大雅，否则就手工修改一下 bbl 文件吧。

6. 关于参考文献的显示格式、排序，及其他
    前面提到参考文献的排序问题，以及引用序号是 LaTeX 提供的 ID 还是数字的问题。
其实不止这些，参考文献的显示格式也是可以定制的。参考文献以正文中引用顺序排序，
还是以文献第一作者的 last name 排序，是通过一些 bst 文件来控制的。而使用哪种 b
st 格式，可通过 bibliographystyle 命令控制。LaTeX 默认提供了这么几种格式，如：
plain、alpha、unsrt等。具体意义见相关文档，这些 bst 在 texmf\bibtex\bst\base 可
被找到。
    bst 控制的格式非常细致，除了上面讲过的排序方式等，还有：作者名字是否用缩写，
作者名字放在文献的起始还是结束，文章 title 要不要大小写（即 "Speaker Verificat
ion Using ..." 还是 "Speaker verification using "），title 用什么区分（用不用引
号括起来，用不用斜体等），刊物名字的格式（要不要全部大写，要不要粗体，要不要斜
体，要不要括起来），等等等等。打开 bst 文件看一下就知道，绝对是想要什么形式，就
可以得到什么形式。最关键的是，在文章定稿之后，完全可以用几个命令重新定义参考文
献的格式！

    给个例子：采用 IEEE 给出的 bst 格式（即 ieeetr.bst），声明：

\bibliographystyle{ieeetr}

    就可以使用了。最终格式是这样的（按正文引用顺序排序）：
    [4] D. A. Reynolds, "Comparison of background normalization
        methods for text-independent speaker verication," in
        EUROSPEECH, 1997.

7. 如何定制参考文献的显示格式
    其实 bst 文件有很多，总能找到自己需要的。如果这些还不能满足，可以通过生成自
己的 bst 文件来定制。这有两个方法，第一是手写（反正我是写不出来），第二是通过工
具。custom-bib 是一个定制 bst 文件的包，解压缩后用 LaTeX 编译其中的主 tex 文件
，便会进行交互式的 bst 定制过程，具体过程我就不讲了。把生成的自定义的 bst 放到
 LaTeX 相应目录下，刷新文件名数据库就可以使用了。

** [[http://www.latexstudio.net/archives/3516][org-mode的中文beamer幻灯片模板]]

2015-04-09
分类：[[http://www.latexstudio.net/archives/category/tex-slides/beamer-theme-template][beamer]]
阅读(447) 评论(1)

org-mode 是 Emacs
的杀手级应用，使用它可以用来做很多事情，如GTD、做笔记等。它可以导出多种格式的文件，包括HTML、LaTeX、Freemind、DocBook等，因此，通过定制之后，编写一份org文件就等于同时编写（或者排版）了多种格式文件，而且每种格式的文件又可以各自拥有不同的排版效果。这正是
org-mode 精妙之处。

比如，我最喜欢的做法是先在 Emacs 里打开 evernote-mode 写一份 org-mode
的笔记，然后 =C-c C-e H= 导出成 HTML
代码，并发布到我的博客中或者加入到我的 wiki
里。如果有需要，我还可以 =C-c C-e l= 生成 LaTeX 代码并编译成 PDF 文件。

用 org-mode 制作 Beamer
幻灯片也很简单，官方已经给出了 [[http://orgmode.org/worg/org-tutorials/org-beamer/tutorial.html][详细的教程]] ，照着一步步做即可。官方的教程并没有针对中文进行定制，因此笔者写了一个org-mode的Beamer中文模板，这是在 [[http://orgmode.org/manual/Beamer-class-export.html#Beamer-class-export][Carsten
Dominik的例子]] 的基础上修改得到的。

*** 1 截图预览

[[http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2015/04/org-beamer-cn.png]]

*** 2 环境要求

1. Emacs
2. org-mode
3. TeXLive 或其他带有 Beamer 宏包的 LaTeX 系统
4. Adobe 字体

   -  Adobe Heiti Std
   -  Adobe Kaiti Std

*** 3 特点

1. 使用 “Darmstadt” 主题及 “Firebrick”配色方案；
2. 使用 listings
   宏包实现代码框。如果有中文内容，你可能需要使用逃逸字串(`')括住两边，否则会出现错位；
3. 使用xeCJK来处理中文，并使用 Adobe
   字体（[[http://ishare.iask.sina.com.cn/f/23186570.html][字体下载]]）。

*** 4 下载

-  Github主页：[[http://wzpan.github.com/org-beamer-cn/][http://wzpan.github.io/org-beamer-cn/]]
-  克隆git仓库：git clone https://github.com/wzpan/org-beamer-cn.git
-  zip压缩包：[[https://github.com/wzpan/org-beamer-cn/zipball/master]]
-  tar.gz压缩包：[[https://github.com/wzpan/org-beamer-cn/tarball/master]]
-  本站下载：[[http://www.latexstudio.net/wp-content/uploads/2015/04/wzpan-org-beamer-cn-e5b5173.zip][wzpan-org-beamer-cn-e5b5173]]

*** 5 使用方法

-  用 Emacs 打开 *beamer.org* 文件， =M-x org-mode= 打开 org-mode；
-  =C-c C-e l= 生成 beamer.tex 文件；
-  打开 *beamer.tex* 文件， =C-c C-c (M-x TeX-command-master)= 并选择使用 *XeLaTeX* 编译。完成后就可以得到幻灯片了。

*** 6 F&Q

-  两个“@”不能生成alert效果？

这个可能是 org-mode 本身的 bug，但可以通过修改
Emacs里的设置来解决。在 =(require 'org-latex)= 前加入这一段设置：

Lisp

(setq org-emphasis-alist (quote (("*" bold "<b>" "</b>") ("/" italic
"<i>" "</i>") ("_" underline "<span
style=\"text-decoration:underline;\">" "</span>") ("=" org-code "<code>"
"</code>" verbatim) ("~" org-verbatim "<code>" "</code>" verbatim) ("+"
(:strike-through t) "<del>" "</del>") ("@" org-warning "<b>" "</b>")))
org-export-latex-emphasis-alist (quote (("*" "\\textbf{%s}" nil) ("/"
"\\emph{%s}" nil) ("_" "\\underline{%s}" nil) ("+" "\\texttt{%s}" nil)
("=" "\\verb=%s=" nil) ("~" "\\verb~%s~" t) ("@" "\\alert{%s}" nil))))

| 1                                                                             |
| 2                                                                             |
| 3                                                                             |
| 4                                                                             |
| 5                                                                             |
| 6                                                                             |
| 7                                                                             |
| 8                                                                             |
| 9                                                                             |
| 10                                                                            |
| 11                                                                            |
| 12                                                                            |
| 13                                                                            |
| 14                                                                            |
| 15                                                                            |
| 16                                                                            |
| 17                                                                            |
| 18                                                                            |
| (setq org-emphasis-alist (quote (("*" bold "<b>" "</b>")                      |
|   ("/" italic "<i>" "</i>")                    |
|   ("_" underline "<span                       |
| style=\"text-decoration:underline;\">" "</span>")                             |
|   ("=" org-code "<code>" "</code>"             |
|   verbatim)                                                    |
|   ("~" org-verbatim "<code>" "</code>"         |
|   verbatim)                                                    |
|   ("+" (:strike-through t) "<del>" "</del>")   |
|   ("@" org-warning "<b>" "</b>")))             |
|  org-export-latex-emphasis-alist (quote                                  |
|   (("*" "\\textbf{%s}" nil)              |
|  ("/" "\\emph{%s}" nil)                |
|  ("_" "\\underline{%s}" nil)          |
|  ("+" "\\texttt{%s}" nil)              |
|  ("=" "\\verb=%s=" nil)                |
|  ("~" "\\verb~%s~" t)                  |
|  ("@" "\\alert{%s}" nil))))            |

选自：[[http://hahack.com/tools/org-beamer-cn/]]

** [[http://segmentfault.com/a/1190000002438813][Edit with Emacs]]


[[/u/venmos][[[http://sfault-avatar.b0.upaiyun.com/243/840/2438401179-1030000000093355_big64]]
*venmos*]] ** 2014年12月22日 发布

-  推荐
   *0* 推荐
-  收藏
   *1* 收藏，*687* 浏览

如果你用习惯了Emacs编辑器并经常使用它纂写各种文字和代码的话,
再使用网站内置的文字编辑器是不是会让你发狂呢? 不过还好, 有一款叫做Edit
with Emacs的Chrome插件可以解决,
它可以让Chrome在外部调用Emacs进行文字编辑.

Edit with Emacs for Chrome
[[https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonikaiipfkggjbhkghgicgoh][]][[https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonikaiipfkggjbhkghgicgoh][https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonik...]]
 Edit-Server for Emacs
[[http://github.com/stsquad/emacs_chrome][]][[http://github.com/stsquad/emacs_chrome]]

使用Chrome安装for Chrome的插件,
之后从Github下载Edit-Server到Emacs的插件目录,
然后在Emacs的配置文件中写入:

#+BEGIN_EXAMPLE
    (add-to-list 'load-path "~/.emacs.d/edit-servers")
    (require 'edit-server)
    (when (require 'edit-server nil t)
      (setq edit-server-new-frame nil)
      (edit-server-start))
#+END_EXAMPLE

之后在网站的编辑框下方就会有一个紫色的=edit=小图标,
点击它Chrome就会在外部调用Emacs进行编辑了, 非常方便.

另外Edit with Emacs还有根据网站网址自动转换编辑模式的功能, 比如:

#+BEGIN_EXAMPLE
    lisp(setq edit-server-url-major-mode-alist
          '(("github\\.com" . markdown-mode)
                    ("segmentfault\\.com" . markdown-mode)
                    ))
#+END_EXAMPLE

如此添加之后,
当我们在Github或者Segmentfault网站调用Emacs进行编辑的时候Emacs会自动切换为Markdown-mode.

PS: Edit with Emacs的原理是在Emacs里开启一个服务, 默认监听=9292端口=.
然后Chrome将文字发送给Emacs进行处理,
Emacs保存时在将编辑结果返回给Chrome. 如果Edit with
Emacs在你的电脑上不能正常工作, 那么可以检查下=9292端口=是否被占用.
你可以修改Edit-Server的默认端口, 然后从Chrome插件的选项里做相应修改即可.

** [[http://www.zzbaike.com/wiki/Emacs/EDIFF#jump-to-nav][Emacs/EDIFF]]


*** 软件概况

授权协议：免费软件

运行环境：Emacs

官方网站：[[http://www.dirfile.com/freeware/ediff.htm]]

软件下载：[[http://www.dirfile.com/freeware/ediff.htm][官方下载]]

*** 简介

Ediff是Emacs提供的一种实时浏览文件间不同(diff)的工具，它可以比较两个或
三个文件间的不同，分别表示为file-A, file-B 或 file-C，也可以比较两个或
三个emacs-buffer间的不同。Ediff的另一个强有力特性则是可以把正的比较的
文件合并成第三个文件。另外， Ediff还可以对目录进行操作。

Ediff浏览文件的差异是在Emacs的两个Buffer上进行，分别使用不同的颜色表示
所存在的差异，而且Ediff对差异区域的差异进行了“细化”，diff程序只进行
到“行”级别比较，而Ediff则是基于diff程序的输出上，对差异区域进行更细
致的比较，从而得到区域内“单词”级别上的差异比较。从而使比较文件间的细
致不同更加容易。

Ediff的更强功能：Ediff可以“忽略”某些细微的差别，例如有两个程序几乎相
同，但是其中都些变量的命名却不一样，如bar变量在另一个程序中却都foo，这
对程序而言是“相同”，如果用一般的diff程序来查看该两程序的差别，则这种
没有意义的变量名不同将充满了整个差异输出，从而不易找到真正的“程序不
同”，而使用Ediff则可以忽略这类不同，很容易就定位我们真正想要的差异。

Ediff的特点是它与[[/wiki/%E7%BC%96%E8%BE%91%E5%99%A8][编辑器]]（即
Emacs本身）集成在一起，所以在比较的过程可以方便的编辑被比较的文件。例
如语法高亮仍然有效。它还提供了对版本控制工具的支持，例如用
ediff-revision命令可以方便的比较不同版本之间的区别。

*** Ediff命令

-  比较两文件： ‘M-x ediff-files'‘M-x ediff'(以后略去M-x)比较两个
-  Buffer： ‘ediff-buffers'比较三个文件： ediff-file3 ediff3比较三个
-  Buffer： ediff-buffer3交互式使用一个patch： ediff-patch-file epatch

以上是一些主要的命令，这些命令在运行时可能会提示输入一些参数，如文件名
等，同时都能很智能地提供一些合适的默认值。

Ediff命令被执行后，进行所谓的‘Ediff Session'它接受一些Ediff命令以决定
Ediff的行为。具体的表现是Ediff另外建立一个窗口(称为“Quick Help
window”)，当聚焦在该窗口输入则被认为是Ediff命令，否则仍是一般的Emacs
编辑行为，即还可以实时的编辑你正在比较的文件或Buffer。

在“Quick Help window”上输入“？”使该窗口变大或是缩小，输入q并确认则
完成比较退出Ediff Session。

常用的Session Command：

**** 移动命令

- v ( V )

把文件-A，文件-B，文件-C(如果有)，同步向下(向上)滚动，

- < ( > )

把文件-A，文件-B，文件-C(如果有)，同步向左(向右)滚动，

- j

跳到差异区域，可以先加数值参数，如 ‘3j'则跳到第三个差异区域，‘j'则跳
到第一个差异区域，则‘-2j'跳到倒数第二个差异区域。跳到某区域后，再输入
的编辑命令就是针对该区域执行，即有一个“当前区域”的概念，而‘j'命令则
就是用于使用绝对参数设置当前活动区域。

- n (或 SPC 空格)

跳到下一个差异区域，并设其为当前区域，

- p (或 DEL)

跳到前一个差异区域，并设其为当前区域，

- ga ( gb gc )

根据光标在Buffer-A(或Buffer-B, Buffer-C)中的位置，设置一个离它们最近的
差异区域为当前活动区域

**** 编辑命令

- a

比较模式：把Buffer-A的内容复制到Buffer-B，可以使用‘rb'恢复Buffer-B的
内容，

合并模式： 把Buffer-A的内容复制到合并Buffer. 可以使用‘r'恢复旧内容，

- b

比较模式：把Buffer-B的内容复制到Buffer-A，可以使用‘ra'恢复Buffer-A的
内容，

合并模式： 把Buffer-B的内容复制到合并Buffer. 可以使用‘r'恢复旧内容，

- ra ( rb rc )

分别用于恢复 Buffer-A Buffer-B Buffer-C 差异区域中的被修改的内容。

**** 三方比较的编辑命令

- ab

把Buffer-A的内容复制到Buffer-B，可以使用‘rb'恢复Buffer-B的内容，

- ac

把Buffer-A的内容复制到Buffer-C，可以使用‘rc'恢复Buffer-C的内容，

-  ba bc ca cb

分别把Buffer-B(C)的内容复制到相应的Buffer-ABC，同时仍可以使用‘ra(bc)'
恢复相应的被修改的内容。

**** Buffer属性设置命令

- A ( B C )

改变Buffer-A, buffer-B, buffer-C的只读属性，是Toggle命令。

** [[http://emacsblog.org/2007/02/18/emacs-key-bindings-in-ms-word/][Emacs Key Bindings in MS Word]]

**** February 18th, 2007 by Ryan McGeary ·
[[http://emacsblog.org/2007/02/18/emacs-key-bindings-in-ms-word/#comments][189
Comments]]

Macosxhints.com points us to a way to
[[http://www.macosxhints.com/article.php?story=20070215034801484][enable
emacs key bindings in Microsoft Word]]. Just assign new shortcut keys to
each of these Word commands (instructions below):

| #+BEGIN_EXAMPLE         |
|     StartOfLine : C-a   |
|     EndOfLine   : C-e   |
|     LineUp      : C-p   |
|     LineDown    : C-n   |
|     CharLeft    : C-b   |
|     CharRight   : C-f   |
| #+END_EXAMPLE           |


Please feel free to suggest other emacs equivalent Word commands and
shortcuts in the comments.

*** Word 2004 for Mac

1. Tools > Customize > Customize Keyboard ...
2. Select “All Commands” in the Categories box.

1. Add new shortcut keys for each of the commands above.

*** Word 2002 (XP) for Windows

1. Tools > Customize ...
2. Click the “Keyboard ...” button.
3. Select “All Commands” in the Categories box.

1. Add new shortcut keys for each of the commands above.

/Note: On Windows, =C-p=, =C-n=, and =C-f= will probably conflict with
FilePrint, FileNew, and EditFind, so you may want to remove those
existing shortcut keys first./

** [[http://hints.macworld.com/article.php?story=20070215034801484][]]

Emacs users get addicted to the standard key bindings (which are also
available in Cocoa apps). Microsoft Word doesn't support these by
default, but you can add them through customization. Here are the ones I
find most useful:

-  StartOfLine: Control-A
-  EndOfLine: Control-E
-  LineUp: Control-P
-  LineDown: Control-N
-  CharLeft: Control-B
-  CharRight: Control-F

To set these up in Word, go to Tools » Customize » Customize Keyboard.
From the Categories panel, choose All commands. Find each of the entries
in the above list, select the /Press new shortcut key/ box for each,
then type the shortcut as shown above and click Assign. (Word will tell
you if any of the shortcuts are currently assigned to other commands.)

The icing on the cake is to get Control-K working. You can do this with
a macro. Go to Tools » Macro » Macros. Set the macro name to /CtrlK/,
then click Create. When the macro window appears, add the following
lines just before the =End Sub= line:

#+BEGIN_EXAMPLE
        Selection.EndKey Unit:=wdLine, Extend:=wdExtend    Selection.Cut
#+END_EXAMPLE

Hit the W icon on the toolbar to save the macro and go back to Word. Now
go back to the Tools » Customize » Customize Keyboard window, choose
Macros from the Categories pane, and assign your new macro to Control-K.

** [[http://blog.useasp.net/archive/2014/07/18/emacs-temporary-files-and-backup-files-for-edited-file.aspx][Emacs的临时文件和备份文件]]

Emacs在编辑文件的时候实际上并非对文件本身进行编辑，而是会将要编辑的文件内容拷贝到[[http://blog.useasp.net/tags/Emacs][Emacs]]的一个临时缓冲区（buffer）内，而我们编辑的时候，也只是对这个缓冲区的内容进行更改。为了便于在需要的时候能够方便的应对，Emacs会自动产生一些其他的辅助文件，其中最常见的有临时文件和备份文件。

[[http://blog.useasp.net/tags/临时文件][临时文件]](Auto-Save file)

Emacs的临时文件的文件名是使用“#”包围，这种文件一般是在Emacs中编辑时，emacs自动保存的文件，他在编辑文件的同一个目录内生成一个以=#file-name#=这样的文件，这个文件会在我们保存文件之后被emacs删除。这个文件的作用是为了防止在进行编辑的时候异常退出造成的损失。

#+BEGIN_EXAMPLE
    1. 在Emacs内使用[C-x,C-f]打开要编辑的文件(test-file.txt)
    2. 在打开的buffer中编辑内容
    3. Emacs自动侦测buffer是否更改，如果更改会自动Auto-Save
    4. 此时我们能够在编辑的文件同一目录下看到临时文件为:
        #test-file.txt#
    5. 使用[C-x,C-s]保存当前buffer
    6. 当前buffer中的内容被写入文件,#test-file.txt#消失——被Emacs自动删除
#+END_EXAMPLE

 如果你不想产生这个临时文件也是有办法的，就是关闭自动保存功能，在你启动的=.emacs=文件内添加下面这行

#+BEGIN_EXAMPLE
    (setq auto-save-default nil) ;; 默认值是t， 要关闭直接用nil更改默认值
#+END_EXAMPLE

 当然，一般是不建议关闭的，因为在异常退出之后，如果你想要恢复自己辛苦编辑的内容，它能帮上大忙，你只要在emacs内打开你要恢复的文件，然后在恢复即可。

#+BEGIN_EXAMPLE
    1. 打开要恢复的文件，如：test.txt
    2. [M-x]
    3. 输入:recover-file 回车
    4. 确认恢复
#+END_EXAMPLE

用起来还是不错的。



[[http://blog.useasp.net/tags/备份文件][备份文件]]（Backup files）

备份文件是在第一次保存的时候，如果保存的文件已经存在，Emacs会自动将当前已经存在的文件重命名作为备份文件，并将当前buffer的内容写入同名的文件中来替代原来的文件。而备份文件使用的是一个“～”作为后缀(如：=file-name~=)。大概的流程如下：

#+BEGIN_EXAMPLE
    1. 打开文件,如:MitchellChu.txt
    2. 编辑...（这涉及到临时文件的问题，忽略）
    3. 在emacs内发出保存指令
    4. emacs先将MitchellChu.txt保存为：MitchellChu.txt~
    5. 保存完成后，Emacs将当前buffer的内容写入MitchellChu.txt
    注意：此时的MitchellChu.txt已经不再是原来的那个文件，但所有连接到原来那个文件的，现在被这个新文件接管。
#+END_EXAMPLE

 当然，上面的这个流程是可以定制的，比如，我们可以要求emacs通过拷贝，而非重命名的方式来备份文件，在=.emacs=或者Emacs内设置个变量就成：

#+BEGIN_EXAMPLE
    ;; 在.emacs文件中添加下面这行表示使用拷贝模式
    (setq backup-by-copying t) ;; 默认是nil，开启之后使用拷贝模式

    ;;;;;;;;;;;;;;;
    ;; 如果是在Emacs中
    ;; 你可以通过直接设置这个变量的值来改变模式
    ;;;;;;;;;;;;;;;

    ;; [M-x]
    ;; set-variable
    ;; backup-by-copying
    ;; t
    ;; 回车，即可修改模式
#+END_EXAMPLE

 这里同上，还是建议不要修改这个值，因为重命名的方式Mitchell个人感觉要优于拷贝模式。

备份文件默认仅会发生在Emacs第一次写入的时候，即，开启Emacs之后，第一次打开文件并保存的时候，编辑期间多次保存并不能产生多次备份动作。然而，下次重新打开Emacs，再次执行同样的动作的时候，同样在第一次保存时，Emacs是会将上次的备份文件覆盖的（如果有）。这也许是你不想要的，这时候你可以通过设置，让每次的备份文件都不同。具体的操作涉及到比较多的参数，这个功能觉得没有太大用处的，这里就不赘述，如果感兴趣，可以参看：=version-control=。

** [[http://blog.sina.com.cn/s/blog_88b165d301017dc2.html][emacs 大小写转换]]

-  *从光标位置开始，处理单词后半部分*

1. capitalize-word (M-c) ;; 单词首字母转为大写
2. upcase-word (M-u)  ;; 整个单词转为大写
3. downcase-word (M-l)  ;; 整个单词转为小写（注意，这里是 META － l(*
   小写字母 L)）

-  *从光标位置开始，处理单词前半部分*

1. negtive-argument; capitalize-word (M-- M-c) ;; 单词首字母转为大写
2. negtive-argument; upcase-word (M-- M-u)  ;; 整个单词转为大写
3. negtive-argument; downcase-word (M-- M-l)  ;; 整个单词转为小写

-  *改变选定区域的大小写*



1. downcase-region (C-x C-l) ;; 选定区域全部改为小写
2. upcase-region (C-x C-u)  ;; 选定区域全部改为大写

** [[http://blog.sina.com.cn/s/blog_88b165d301017djg.html][emacs 矩形操作]]

*** 原始矩形块模式

emacs以C-x
r开头的命令来进行矩形操作。先用C-space或者C-@设一个mark，移动光标到另一点，用以下命令进行列操作：

1. C-x r k 剪切一个矩形块
2. C-x r y 粘贴一个矩形块
3. C-x r o 插入一个矩形块
4. C-x r c 清除一个矩形块(使其变成空白)
5. C-x r t 在选定区域的所有列前插入样的字符



*** cua-mode支持的可视化块模式

除了emacs本身支持的列模式外，emacs还可以通过cua-mode支持一种可视化的列模式。在cua-mode下，按[C-return]会进入
cua
rectangle模式。在这个模式下可以通过鼠标点击确认起点，然后通过光标键来选中一个rect范围，这个rect会用另外的颜色显示出来。

直接输入字符: 在每行前(或后)都插入这个字符



1.  [M-a]: 将rect中的文字左对齐
2.  [M-b]: 用空格(tabs或者spaces)替换所有rect中的字符
3.  [M-c]: 去掉所有行左侧的空格
4.  [M-f]: 用单个字符替换所有rect中的字符(提示输入一个字符)
5.  [M-i]: 对每行中第一个找到的数字进行加1操作(自动把0x开头的当作十六进制数字)
6.  [M-k]: 剪切rect
7.  [M-l]: 把rect中的内容全部转换为小写
8.  [M-m]: 拷贝rect
9.  [M-n]: 用一串自增的数字替换rect中的每一行(这个功能可以用来给每行编号) ### 非常好用的功能
10. [M-o]: rect的内容右移，选中的rect用空格填充
11. [M-r]: 用字符串替换符满足正则表达式的字符串
12. [M-R]: 上下反转
13. [M-s]: 把rect中的每一行替换为一个字符串(提示输入)
14. [M-t]: 把rect整个替换为一个字符串(提示输入)
15. [M-u]: 把rect中的内容全部转换为大写
16. [M-|]: 对rect执行一个shell命令

** [[http://blog.csdn.net/pfanaya/article/details/7068710][Emacs Bookmark 书签]]

*书到用时方恨少......掌握Emacs的最好办法就是使用，使用，再使用......哈哈......*

*转自：*[[http://www.ibm.com/developerworks/cn/education/aix/au-emacs4/section4.html]]



使用 Emacs 书签

Emacs 提供了保存缓冲区中位置的另一种工具。这些
Emacs /书签/ 的工作方式与寄存器相同，但是它们的标签可以超过一个字符长，而且它们比寄存器更为持久：如果保存了书签，那么您可以在两个不同的会话之间使用它们。它们将一直保留下来，直到您删除它们。正如它们的名称所表示的，对于保存您在缓冲区中的位置，以便您稍后可以返回到该位置（通常是在以后的
Emacs 会话期间），使用书签是非常方便的。

这个部分将向您介绍使用、设置、列出、保存和删除 Emacs 书签。

设置一个书签

对于保存光标位置，书签与寄存器是很相似的，不同之处在于书签能够保持到当前会话之外。对于标记您在文件中的位置，并在稍后返回到该位置，书签是非常方便的，您可以为很多文件设置书签，并且您可以在单个文件中设置很多书签。

要在当前缓冲区中，为您正在访问的文件的当前光标设置一个书签，可以运行 =bookmark-set= 功能，它与 =C-x r m= 进行了绑定。

这一命令后面紧跟您的书签的名称；在缺省情况下，它就是当前缓冲区的名称。

现在，尝试保存一些书签：

1. 启动 Emacs，并使光标定位于您的练习文件中的第 20 行：

   | #+BEGIN_EXAMPLE                    |
   |     $ emacs +20 practice.b         |
   |                                    |
   | #+END_EXAMPLE                      |




2. 键入 =C-x r m= 以便将这个光标作为书签保存。

3. 当 Emacs
   请求为这一书签提供相应的名称时，可以按 *Enter* 以使用该缓冲区的名称
   (practice.b)。

4. 键入 =M-<= 以移动到缓冲区的顶部。

5. 保存一个名为 top 的新书签：键入 =C-x r m top=。

列出您的书签

=bookmarks-bmenu-list= 功能可以列出一个由已设置的所有书签组成的菜单。通过键入 =C-x r l= 运行该功能，而您的会话应该与[[http://www.ibm.com/developerworks/cn/education/aix/au-emacs4/section4.html#fig5][图
5]] 中所示类似。


 *图 5. Emacs 的书签菜单*

[[http://www.ibm.com/developerworks/cn/education/aix/au-emacs4/image05.jpg]]

您可以通过按 *Enter* 从该列表中选择一个书签。Emacs
将在一个新的缓冲区（如果尚未在一个缓冲区中打开它）中访问该文件，并将其作为当前缓冲区，同时将光标移动到该书签的位置。

现在，尝试运行这一功能，并使用箭头键选择您的“top”书签。

跳转至一个书签

您可以通过直接/跳转/ 至某个书签来访问它，而无需从您的书签主列表中选择它。要跳转至某个特定的书签，可以使用 =bookmark-jump=功能，=C-x r b=。这一命令将移动到特定文件中的给定位置；如果尚未在缓冲区中打开这个带书签的文件，那么这一命令将打开它。

在迷你缓冲区中会提示您输入要跳转到的书签。这个提示使用了自动完成功能，所以您只需键入该书签名前面足够的字母，以使其能够区别于其他的书签即可，然后按 *Tab* 以选择该书签。

尝试跳转到您的 practice.b
书签：键入 =C-x r b prac=，按 *Tab* 键，然后按 *Enter*。

删除一个书签

当您使用一个现有书签的标签来设置新书签（请参见[[http://www.ibm.com/developerworks/cn/education/aix/au-emacs4/section4.html#seta][设置一个书签]]部分）时，您将使用新的书签取代原来的书签。这是一种“删除”书签的方式，即使用新的值来取代其原来的值。当您在阅读一个大文件时，如果您仅仅保留一个书签以标记您的位置，上述方法是很常见的，因为您每次设置该书签时都替换了它先前的值。

但是您可以同时删除一个书签，那么该标签不再指向任何文件中的任何位置。要实现这一点，可以运行 =bookmark-delete= 功能，并在被询问时，给出要进行删除的书签的名称。

尝试删除您的“top”书签：

1. 键入 =C-x bookmark-delete= 并按 *Enter*。

2. 当被询问时，给出要删除的书签的名称：键入 =top= 并按 *Enter*。

通过使用 =C-x r l= 调出书签列表，您可以验证已经删除了该书签。

保存您的书签

在 Emacs 的新版本中，一旦您生成了任何书签，那么您为当前 Emacs
会话所设置的书签将自动地保存到您的永久书签文件中。您的书签文件是您的
home 目录中的一个名为 .emac.bmk 的隐藏文件。

如果没有配置 Emacs
以使其自动保存您的书签，那么通过运行 =bookmark-save= 功能，可以将它们保存到您的
.emac.bmk 文件中。如果当您退出时没有保存任何新的书签，那么 Emacs
将询问您是否想要保存它们。

Emacs 书签命令表

[[http://www.ibm.com/developerworks/cn/education/aix/au-emacs4/section4.html#table4][表
4]] 列出了使用 Emacs
书签的各种命令和键，给出了它们的功能名，并描述了它们的含义。


 *表 4. 使用书签的 Emacs 命令*

键盘输入

功能

描述

=C-x r m Bookmark=

=bookmark-set=

设置一个名为 /Bookmark/ 的书签。

=C-x r l=

=bookmarks-bmenu-list=

列出所有已保存的书签。



=bookmark-delete=

删除一个书签。

=C-x r b Bookmark=

=bookmark-jump=

跳转至名为 /Bookmark/ 的书签中所设置的位置。

/未定义/

=bookmark-save=

将所有的书签保存到书签文件 ~/.emac.bmk 中。

** [[http://blog.chinaunix.net/uid-27091459-id-3359118.html][emacs-24.2 install]]

when configure the emacs:  error like this!
You seem to be running X, but no X development libraries
were found. You should install the relevant development files for X
and for the toolkit you want, such as Gtk+, Lesstif or Motif. Also
make
sure you have development files for image handling, i.e.
tiff, gif, jpeg, png and xpm.
If you are sure you want Emacs compiled without X window support, pass
--without-x
to configure.

装GTK+等图形开发库
*sudo apt-get install libgtk2.0-dev
*
几个图像开发库
*sudo apt-get install libxpm-dev
sudo apt-get install libjpeg62-dev
sudo apt-get install libgif-dev
sudo apt-get install libtiff4-dev

*last one:
**sudo apt-get install libncurses5-dev

./configure
make
make install

run it in window
**emacs

run it without any window
emacs -nw

** [[http://c.biancheng.net/cpp/biancheng/view/2227.html][C++格式化输出，C++输出格式控制]]

在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采取默认的格式，但有时希望数据按指定的格式输出，如要求以十六进制或八进制形式输出一个 整数，对输出的小数只保留两位小数等。有两种方法可以达到此目的。一种是我们已经介绍过的使用控制符的方法（详情请查看：C++输入cout与输出cin）；第2种是使用流对象的有关成员函数。分别叙述如下。
使用控制符控制输出格式

控制格式的使用方法这里不再赘述，仅举例说明，详情请查看：C++输入cout与输出cin。

[例13.2] 用控制符控制输出格式。
#include <iostream>
#include <iomanip>//不要忘记包含此头文件
using namespace std;
int main()
{
   int a;
   cout<<"input a:";
   cin>>a;
   cout<<"dec:"<<dec<<a<<endl;  //以十进制形式输出整数
   cout<<"hex:"<<hex<<a<<endl;  //以十六进制形式输出整数a
   cout<<"oct:"<<setbase(8)<<a<<endl;  //以八进制形式输出整数a
   char *pt="China";  //pt指向字符串"China"
   cout<<setw(10)<<pt<<endl;  //指定域宽为,输出字符串
   cout<<setfill('*')<<setw(10)<<pt<<endl;  //指定域宽,输出字符串,空白处以'*'填充
   double pi=22.0/7.0;  //计算pi值
   //按指数形式输出,8位小数
   cout<<setiosflags(ios::scientific)<<setprecision(8);
   cout<<"pi="<<pi<<endl;  //输出pi值
   cout<<"pi="<<setprecision(4)<<pi<<endl;  //改为位小数
   cout<<"pi="<<setiosflags(ios::fixed)<<pi<<endl;  //改为小数形式输出
   return 0;
}
运行结果如下：
input a:34↙(输入a的值)
dec:34                   (十进制形式)
hex:22                   (十六进制形式)
oct:42                   (八进制形式)
         China               (域宽为)
*****China               (域宽为,空白处以'*'填充)
pi=3.14285714e+00        (指数形式输出,8位小数)
pi=3.1429e+00            (指数形式输出,4位小数)
pi=3.143                 (小数形式输出,精度仍为)
用流对象的成员函数控制输出格式

除了可以用控制符来控制输出格式外，还可以通过调用流对象cout中用于控制输出格式的成员函数来控制输出格式。用于控制输出格式的常用的成员函数见表13.4。

表13.4 用于控输出格式的流成员函数
流成员函数	与之作用相同的控制符	作用
precision(n)	setprecision(n)	设置实数的精度为n位
width(n)	setw(n)	设置字段宽度为n位
fill(c)	setfill(c)	设置填充宇符c
setf()	setiosflags()	设置输出格式状态，括号中应给出格式状态，内容与控制符setiosflags括号中的内容相同，如表13.5所示
unsetf()	resetioflags()	终止已设置的输出格式状态，在括号中应指定内容
流成员函数setf和控制符setiosflags括号中的参数表示格式状态，它是通过格式标志来指定的。格式标志在类ios中被定义为枚举值。因此在引用这些格式标志时要在前面加上类名ios和域运算符“::”。格式标志见表13.5。

表13.5 设置格式状态的格式标志
格式标志	作用
ios::left	输出数据在本域宽范围内向左对齐
ios::right	输出数据在本域宽范围内向右对齐
ios::internal	数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充
ios::dec	设置整数的基数为10
ios::oct	设置整数的基数为8
ios::hex	设置整数的基数为16
ios::showbase	强制输出整数的基数(八进制数以0打头，十六进制数以0x打头)
ios::showpoint	强制输出浮点数的小点和尾数0
ios::uppercase	在以科学记数法格式E和以十六进制输出字母时以大写表示
ios::showpos	对正数显示“+”号
ios::scientific	浮点数以科学记数法格式输出
ios::fixed	浮点数以定点格式(小数形式)输出
ios::unitbuf	每次输出之后刷新所有的流
ios::stdio	每次输出之后清除stdout, stderr
[例13.3] 用流控制成员函数输出数据。
#include <iostream>
using namespace std;
int main( )
{
   int a=21
   cout.setf(ios::showbase);//显示基数符号(0x或)
   cout<<"dec:"<<a<<endl;         //默认以十进制形式输出a
   cout.unsetf(ios::dec);         //终止十进制的格式设置
   cout.setf(ios::hex);           //设置以十六进制输出的状态
   cout<<"hex:"<<a<<endl;         //以十六进制形式输出a
   cout.unsetf(ios::hex);         //终止十六进制的格式设置
   cout.setf(ios::oct);           //设置以八进制输出的状态
   cout<<"oct:"<<a<<endl;         //以八进制形式输出a
   cout.unseft(ios::oct);
   char *pt="China";              //pt指向字符串"China"
   cout.width(10);                //指定域宽为
   cout<<pt<<endl;                //输出字符串
   cout.width(10);                //指定域宽为
   cout.fill('*');                //指定空白处以'*'填充
   cout<<pt<<endl;                //输出字符串
   double pi=22.0/7.0;            //输出pi值
   cout.setf(ios::scientific);    //指定用科学记数法输出
   cout<<"pi=";                   //输出"pi="
   cout.width(14);                //指定域宽为
   cout<<pi<<endl;                //输出pi值
   cout.unsetf(ios::scientific); //终止科学记数法状态
   cout.setf(ios::fixed);        //指定用定点形式输出
   cout.width(12);               //指定域宽为
   cout.setf(ios::showpos);      //正数输出“+”号
   cout.setf(ios::internal);     //数符出现在左侧
   cout.precision(6);            //保留位小数
   cout<<pi<<endl;               //输出pi,注意数符“+”的位置
   return 0;
}
运行情况如下：
dec:21(十进制形式)
hex:0x15                 (十六进制形式,以x开头)
oct:025                  (八进制形式,以开头)
         China               (域宽为)
*****China               (域宽为,空白处以'*'填充)
pi=**3.142857e+00        (指数形式输出,域宽,默认位小数)
+***3.142857             (小数形式输出,精度为,最左侧输出数符“+”)

对程序的几点说明：
1) 成员函数width(n)和控制符setw(n)只对其后的第一个输出项有效。如：
    cout. width(6);
    cout <<20 <<3.14<<endl;
输出结果为 203.14

在输出第一个输出项20时，域宽为6，因此在20前面有4个空格，在输出3.14时，width (6)已不起作用，此时按系统默认的域宽输出（按数据实际长度输出）。如果要求在输出数据时都按指定的同一域宽n输出，不能只调用一次width(n)，而必须在输出每一项前都调用一次width(n>，上面的程序中就是这样做的。

2) 在表13.5中的输出格式状态分为5组，每一组中同时只能选用一种（例如dec、hex和oct中只能选一，它们是互相排斥的）。在用成员函数setf和控制符setiosflags设置输出格式状态后，如果想改设置为同组的另一状态，应当调用成员函数unsetf（对应于成员函数self）或resetiosflags（对应于控制符setiosflags），先终止原来设置的状态。然后再设置其他状态，大家可以从本程序中看到这点。程序在开始虽然没有用成员函数self和控制符setiosflags设置用dec输出格式状态，但系统默认指定为dec，因此要改变为hex或oct，也应当先用unsetf 函数终止原来设置。如果删去程序中的第7行和第10行，虽然在第8行和第11行中用成员函数setf设置了hex和oct格式，由于未终止dec格式，因此hex和oct的设置均不起作用，系统依然以十进制形式输出。

同理，程序倒数第8行的unsetf 函数的调用也是不可缺少的。

3) 用setf 函数设置格式状态时，可以包含两个或多个格式标志，由于这些格式标志在ios类中被定义为枚举值，每一个格式标志以一个二进位代表，因此可以用位或运算符“|”组合多个格式标志。如倒数第5、第6行可以用下面一行代替：
    cout.setf(ios::internal I ios::showpos);  //包含两个状态标志，用"|"组合

4) 可以看到：对输出格式的控制，既可以用控制符(如例13.2)，也可以用cout流的有关成员函数(如例13.3)，二者的作用是相同的。控制符是在头文件iomanip中定义的，因此用控制符时，必须包含iomanip头文件。cout流的成员函数是在头文件iostream 中定义的，因此只需包含头文件iostream，不必包含iomanip。许多程序人员感到使用控制符方便简单，可以在一个cout输出语句中连续使用多种控制符。

** [[http://bbs.ednchina.com/BLOG_ARTICLE_124613.HTM][]]

** [[http://os.yesky.com/88/8733088.shtml][]]

** [[http://os.yesky.com/88/8733088.shtml][Ubuntu系统上轻松截图的几种方法介绍]]

相信大家对于屏幕截图(或称抓图)应该不会陌生，在Windows平台上，我们可以使用许多第三方的专业抓图软件如[[http://mydown.yesky.com/soft/multimedia/capture/446/401446.shtml][SnagIt]]等来实现抓取屏幕图像的功能。在
Ubuntu系统中，实现抓图功能的开源工具很多，用好这些工具可以让我们轻松获取任何所需的屏幕图像。本文介绍基于Ubuntu desktop 8.10(i386)，GNOME集成
桌面环境。

1.使用[[http://product.yesky.com/keyboard/][键盘]]快捷键抓图

在GNOME集成桌面环境下，我们可以使用键盘功能键Print Screen或Alt+Print Screen组合键来抓图，前者可以抓取整个屏幕的图像，而后者可以抓取当前
活动窗口的图像。例如抓取整个屏幕的图像，则按下Alt+Print Screen组合键，不一会儿将弹出“保存抓图”对话框(图1)，对话框中显示截图的文件名以及图像
存储的目标路径(这里我们使用默认存储路径)，如点击“复制到剪贴板”按钮则将截图复制到系统剪贴板中，在其他程序中使用时只要“粘贴”过去就可以了;如点
击“保存”按钮则将抓取的屏幕图像保存为文件，文件名由系统自动生成，如Screenshot.png。使用键盘快捷键来抓图，优点是快捷、方便，适用于只需要抓取全
屏或某个活动窗口图像的情况。

                                                                  Ubuntu

2.用gnome-screenshot抓图

GNOME集成桌面环境自带了抓图工具“抓图(gnome-screenshot)”。在菜单“[[http://search.yesky.com/search.do?wd=%25E5%25BA%2594%25E7%2594%25A8][应用]]程序”→“附件”下找到“抓图”项，单击该项则运行“抓图”程序(图2)。“抓图”程
序提供了抓取整个桌面或当前活动窗口图像的功能，可以设定抓取前的延迟时间。另外，抓图程序也支持一些简单的特效，如是否包括[[http://product.yesky.com/mouse/][鼠标]]箭头、窗口边框以及
是否带有阴影效果或方框。

                                                                  Ubuntu

需要指出的是，在GNOME集成桌面环境下，使用功能键Print Screen或组合键Alt+Print Screen来抓取屏幕图像，在后台调用的正是gnome-screenshot程序
。与用键盘快捷键抓图相比，“抓图”程序增加了一些特效功能，适合于对截图有特定需求的用户。

3.用GIMP自带的抓图功能抓图

GIMP是Linux平台上可与[[http://product.yesky.com/imagesoftware/adobe/][Adobe]] Photoshop媲美的图像处理软件，该软件也自带截图的功能。在系统菜单“应用程序→图形”下找到“GIMP图片编辑器”项，单击
该项运行GIMP程序。在打开的GIMP应用程序窗口的菜单“文件→Create”下找到“屏幕抓图”项，单击该项则出现“屏幕抓图”窗口(图3)。

                                                                  Ubuntu

使用GIMP的抓图工具可以抓取整个屏幕或当前活动窗口的图像或屏幕上的选定区域。当用户点击“抓取”按钮后，抓取的图像自动出现在GIMP图像编辑器中，
我们既可以利用GIMP强大的图像编辑功能直接对抓取的图像进行处理，也可以将抓取的图像以某种图像文件格式保存。

4.功能强大的KSnapshot

KSnapshot是KDE集成桌面环境自带的截图工具，不过在GNOME集成桌面环境下也可以安装和使用它。我们可以通过新立得软件包管理器或使用apt-get命令来
安装它。假设使用命令行方式来安装，打开一个GNOME终端窗口，在终端窗口中输入如下命令：

sudo apt-get install ksnapshot

命令执行后，将在线下载并安装KSnapshot。安装完毕后，在菜单“应用程序”→“图像”下找到“KSnapshot”项，点击该项则运行KSnapshot程序(如图4)。

                                                                  Ubuntu

KSnapshot功能非常强大，提供的截图模式有全屏(Full Screen)、光标下的窗体(Window under cursor)、任意区域(Region)和窗体部件(Section of
Window)四种。其中“光标下的窗体”抓取模式可以在不激活要抓取的窗体的情况下，只要将鼠标移动到该窗体的某个区域即可抓取该窗体。

在输出所抓取的图像方面，KSnapshot增加了复制到剪贴板和直接打印的功能。KSnapshot应该算得上是一款较为专业的抓图工具，使用KSnapshot几乎可以
轻松抓取屏幕上的任意图像，笔者推荐大家安装和使用这款软件。

** [[http://forum.nydus.co/forum.php?mod=viewthread&tid=4406&extra=page%3D1][Linux VPN设置教程]]

| 注：由于桌面环境的不同，方法可能会有所差异                                                                                      |
| 1.在“系统设置”中找的“网络”                                                                                                      |
| [[static/image/common/none.gif]]                                                                                                |
| *图片1.png* /(105.53 KB, 下载次数: 9)/                                                                                          |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1MnxhNmQxMjQxNHwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:03 上传                                                                                                            |
|                                                                                                                                 |
| 2.打开“网络”，选择左下角的“+”                                                                                                   |
| [[static/image/common/none.gif]]                                                                                                |
| *图片2.png* /(42.26 KB, 下载次数: 2)/                                                                                           |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1M3wzNmRhNGVhNXwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:03 上传                                                                                                            |
|                                                                                                                                 |
| 3.点击“+”后选择“VPN”                                                                                                            |
| [[static/image/common/none.gif]]                                                                                                |
| *图片3.png* /(34.09 KB, 下载次数: 1)/                                                                                           |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1NHxjMDI2MzMyM3wxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:03 上传                                                                                                            |
|                                                                                                                                 |
| 4.选择“PPTP”                                                                                                                    |
| [[static/image/common/none.gif]]                                                                                                |
| *图片4.png* /(50.5 KB, 下载次数: 1)/                                                                                            |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1NXxiYjRlMTI1Y3wxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:04 上传                                                                                                            |
|                                                                                                                                 |
| 5.输入网关、用户名、密码                                                                                                        |
| [[static/image/common/none.gif]]                                                                                                |
| *图片5.png* /(58.87 KB, 下载次数: 1)/                                                                                           |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1NnxiMGNjMTZhMnwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:04 上传                                                                                                            |
|                                                                                                                                 |
| 6.选择右下角的“高级”                                                                                                            |
| [[static/image/common/none.gif]]                                                                                                |
| *图片6.png* /(43.03 KB, 下载次数: 2)/                                                                                           |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1N3wzYjZkYzExMXwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:04 上传                                                                                                            |
|                                                                                                                                 |
| 7.取消“EAP”，勾选“使用点到点加密（MPPE）”                                                                                       |
| [[static/image/common/none.gif]]                                                                                                |
| *图片7.png* /(63.88 KB, 下载次数: 2)/                                                                                           |
|                                                                                                                                 |
| [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1OHxjZjM2Njk4ZnwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]   |
|                                                                                                                                 |
| 2014-7-29 11:04 上传                                                                                                            |
|                                                                                                                                 |
| 9.在右上角的网络图标找到“VPN”那栏，选择刚刚你配置的VPN的连接的名字，进行连接（注：不是所有的桌面环境都是这样的）                |
| 感谢用户秋月提供                                                                                                                |
| \\                                                                                                                              |

** [[http://blog.fens.me/ubuntu-vpn-pptp/][在Ubuntu上安装PPTP VPN服务]]

此图完整的阐述了身为帝国平民的必备技能之一，VPN服务则是此种技能的技术实现，虚拟专用网络（Virtual Private Network ，简称VPN)指的是在公用网络上建立专用网络的技术。它涵盖了跨共享网络或公共网络的封装、加密和身份验证链接的专用网络的扩展。VPN主要采用了彩隧道技术、加解密技术、密钥管理技术和使用者与设备身份认证技术。
点对点隧道协议（PPTP）是VPN服务的一种最简单的实现协议，其它常见的VPN类型还有：使用IPsec的第2层隧道协议（L2TP/IPsec）、安全套接字隧道协议（SSL VPN）。本文主要讨论PPTP VPN服务在Ubuntu上的安装和配置。

A.使用apt源服务来安装PPTPD服务


sudo apt-get update
sudo apt-get install pptpd
B.安装完成之后编辑pptpd.conf配置文件


sudo vi /etc/pptpd.conf

#确保如下选项的配置
option /etc/ppp/pptpd-option                    #指定PPP选项文件的位置
debug                                           #启用调试模式
localip 192.168.0.1                             #VPN服务器的虚拟ip
remoteip 192.168.0.200-238,192.168.0.245        #分配给VPN客户端的虚拟ip
C.编辑PPP选项配置文件

sudo vi /etc/ppp/pptpd-options

#确保如下选项的配置
name pptpd                      #pptpd服务的名称
refuse-pap                      #拒绝pap身份认证模式
refuse-chap                     #拒绝chap身份认证模式
refuse-mschap                   #拒绝mschap身份认证模式
require-mschap-v2               #允许mschap-v2身份认证模式
require-mppe-128                #允许mppe 128位加密身份认证模式
ms-dns 8.8.8.8                  #使用Google DNS
ms-dns 8.8.4.4                  #使用Google DNS
proxyarp                        #arp代理
debug                           #调试模式
dump                            #服务启动时打印出所有配置信息
lock                            #锁定TTY设备
nobsdcomp                       #禁用BSD压缩模式
logfile /var/log/pptpd.log      #输出日志文件位置
D.编辑用户配置文件来添加用户

sudo vi /etc/ppp/chap-secrets

#格式：用户名   服务类型   密码   分配的ip地址
test    *    1234    *
#第一个*代表服务可以是PPTPD也可以是L2TPD，第二个*代表随机分配ip
E.重启PPTPD服务


sudo service pptpd restart
F.配置网络和路由规则 设置ipv4转发


sudo sed -i 's/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/g' /etc/sysctl.conf
sudo sysctl -p
设置iptables NAT转发

#注意这里eth0代表你的外网网卡，请用ifconfig查看或者咨询网络管理员
sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE
#如果上面的命令报错,那么可以尝试以下的命令，其中xxx.xxx.xxx.xxx代表你的VPS外网ip地址
sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j SNAT --to-source xxx.xxx.xxx.xxx
设置MTU来确保过大的包不会被丢弃（这个可以不做）


sudo iptables -I FORWARD -s 192.168.0.0/24 -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1300
iptables的设置重启之后会取消，所以可以将上面的命令加入到/etc/rc.local来确保每次重启都会执行设置。

G.至此设置全部完成，可以用任意一个客户端机器如MAC、PC或者手机来新建一个VPN连接使用用户test，密码1234进行测试。另外网上提供一种自动安装脚本，可以参见如下操作：


wget -c http://small-script.googlecode.com/files/debian-pptpd.tar.gz
tar -zxf debian-pptpd.tar.gz
sudo sh pptpd.sh
最后，如果想要实现更便利的用户管理，请参见在Ubuntu上安装FreeRADIUS服务。

** [[http://www.xp510.com/article/2564.html][关闭Win7 UAC教程]]

相信每一个刚使用win7的人对于win7 UAC服务特别不舒服。每次操作时，都要等待一会，弹出来一个UAC提示。甚至很多人都开始对这个UAC反感。
 首先我们来讲一下UAC是什么？
UAC是User Account Control的缩写，也叫做用户帐户控制。从Windows Vista开始，微软为提高系统安全而引入的新技术。要求用户在执行，提供权限或管理员
密码，以此来提高系统的安全性。通过在这些操作启动前对其进行验证，UAC 可以帮助防止恶意软件和间谍软件在未经许可的情况下在计算机上进行安装或对计
算机进行更改。
下面我们以系统之家GHOST Win7_SP1纯净旗舰版V3.0为例，给大家讲解一下如何关闭win7 UAC服务。
1.点击windows 7开始按钮，在底下的输入框中输入MSCONFIG。之后，win7系统将弹出“系统配置”对话框。如下图：
\
2.选中“更改UAC设置”，并点击启动。弹出“用户账户控制设置”对话框。如下图：
 \
3.下拉到“从不通知”，然后点击确定，即可。这样，UAC的设置就完成了。
4.注意，关闭UAC要重启电脑才能生效。

好了，今天的教程关闭Win7 UAC到此为止。

** [[http://blog.csdn.net/zodiac1111/article/details/8193928][Linux下avr单片机开发环境]]

*** 前提:环境

**** 软件:

***** 开发平台Linux(kernel 3.6):

终端使用=uname -a=命令查看:

#+BEGIN_EXAMPLE
    Linux localhost.localdomain 3.6.3-1.fc17.i686.PAE #1 SMP Mon Oct 22 15:48:37 UTC 2012 i686 i686 i386 GNU/Linux
#+END_EXAMPLE

***** Linux 发行版(Fedora)

终端使用=lsb_release -a=命令查看:

#+BEGIN_EXAMPLE
    LSB Version:    :core-4.1-ia32:core-4.1-noarch:cxx-4.1-ia32:cxx-4.1-noarch:desktop-4.1-ia32:desktop-4.1-noarch:languages-4.1-ia32:languages-4.1-noarch:printing-4.1-ia32:printing-4.1-noarch    Distributor ID: Fedora    Description:    Fedora release 17 (Beefy Miracle)    Release:    17    Codename:   BeefyMiracle
#+END_EXAMPLE

***** IDE 平台:

#+BEGIN_EXAMPLE
    Eclipse Platform
    Version: 4.2.1
    Build id: M20120914-1800
#+END_EXAMPLE

***** Eclipse 软件(插件)avr-eclipse:

#+BEGIN_EXAMPLE
    http://avr-eclipse.sourceforge.net
#+END_EXAMPLE

****** 下载软件:

******* Linux平台交叉编译avr程序交叉编译器:avr-gcc.

yum安装或者源代码编译

******* avr程序下载(烧写)软件:avrdude

网址[[http://savannah.nongnu.org/projects/avrdude/]]

**** 硬件:

***** 下载器:

****** USBasp,很早以前淘宝上买的[参考4]:

lsusb查看如下:

#+BEGIN_EXAMPLE
    Bus 003 Device 006: ID 16c0:05dc VOTI shared ID for use with libusb
#+END_EXAMPLE

这个好像只能下载(ISP).

****** AVR-JTAG-USB仿真器,也是很久以前买的[参考8]:

lsusb识别是usb转串,应该就是这样吧 = = .

#+BEGIN_EXAMPLE
    Bus 003 Device 012: ID 067b:2303 Prolific Technology, Inc. PL2303 Serial Port
#+END_EXAMPLE

除了下载功能以外,这个还能在线调试.

*以上两者任意一个都可以下载程序.*

***** 开发板:

一年多前淘宝买的开发板(ATmega128a)[参考5],原理图[参考6],扔那里也没怎么玩,最近来了兴致拿起来折腾折腾
:P .

*** 正文:搭建开发环境:在Linux在使用AVR-Eclipse中，AVR-GCC和AVRDUDE进行Atmel的AVR单片机开发.

[参考1]

**** 安装AVR-Eclipse

在Eclipse中单击帮助(Help)->安装新软件(Install New
Sofrware),之后将打开一个对话框.在对话框的顶部 Work with 文本框中粘贴
AVR-Eclipse 更新服务器的地址
([[http://avr-eclipse.sourceforge.net/updatesite/]]).如图:

[图:安装插件][[http://img.my.csdn.net/uploads/201211/17/1353137357_6721.png]]



安装好之后,点击窗口(Window)->首选项(Preferences)展开左边的AVR一栏.

[图:配置窗口]

[[http://img.my.csdn.net/uploads/201211/17/1353137381_2144.png]]



侧边栏 编程器配置(Programmer
COnfigurations)中点击添加(Add).左侧选择"USBasp,http://www.fishchl.de/usbasp"(*注意*:需要根据实际下载器硬件选择).

[图:下载器/编程器配置]

[[http://img.my.csdn.net/uploads/201211/17/1353137425_9540.png]]



同时,在项目-属性中也可以设置.

[图:项目属性中的设置(目标硬件设置等)]

[[http://img.my.csdn.net/uploads/201211/17/1353137470_4016.png]]

**** 使用

文件(File)->新建(New)->C语言项目(C Project).项目类型(Project
type)中选择AVR Cross Target Project -> Empty Project. 给项目名字.

下一步,点击高级设置(Advanced settings),选择之前配置文件.
就可以开始在Linux下进行单片机开发了.

编译完成后,点击avr菜单->上载项目到目标设备即可

[图:上载到设备(开发板)]

[[http://img.my.csdn.net/uploads/201211/17/1353137499_9855.png]]

环境详情参阅[参考1]

***** 可能遇到的问题:

****** 下载器(硬件)

1.
选择好适当的下载器.USBasp在Eclipse中工程项目的属性选项中,左侧Programmer
Hardwavr编程器硬件应该选择"USBasp".默认端口如果不是默认的=/dev/ttyUSB0=,必须填写正确的端口以覆盖配置.

2. 使用AVR JTAG USB仿真器时选择"Atmel JTAG
ICE(mk1)".因为默认端口(/dev/parport0)不是usb,可能会提示如下错误:

#+BEGIN_EXAMPLE
    avrdude: ser_open(): can't open device "/dev/parport0": No such file or directory
    avrdude: jtagmkI_close(): unsupported baudrate -1
#+END_EXAMPLE

所以默认端口必须覆盖,例如=/dev/ttyUSB0=.
测试可以下载,在线调试功能还在折腾中 :)

3. 总之:硬件和设置一定必须向配合.

****** 软件:linux设备文件权限

默认情况下普通用户是没有linux的设备文件的读写权限的.所以avarice可能会提示访问受限.

这时只要给avarice增加权限位即可.

1. 切换到root用户

2. chmod a+s /usr/bin/avrdude #赋予权限位

3. 切换回普通用户,继续操作即可.

*** 参考:

1. avr开发环境搭建教程(EN),本文主要就是参考/翻译它的.
   [[http://www.timteatro.net/2012/03/22/beginning-atmel-avr-development-in-linux-using-avr-eclipse-avr-gcc-and-avrdude/]]
2. Linux下avr-Eclipse环境(EN):[[http://awawa.hariko.com/eclipse_avr_en.html]]
3. avrdude
   命令说明(CN):[[http://blog.21ic.com/user1/69/archives/2005/1551.html]]
4. 淘宝上的USBasp下载器:[[http://tradearchive.taobao.com/trade/detail/tradeSnap.htm?spm=a1z09.2.9.147.BquMN6&tradeID=79509563401088]]
5. ATmega128a开发板淘宝:[[http://tradearchive.taobao.com/trade/detail/tradeSnap.htm?spm=a1z09.2.9.184.BquMN6&tradeID=79064532741088]]
6. 开发板原理图(DropBox),包括厂商提供的学习手册:[[https://www.dropbox.com/sh/hyh2zcqd3px6iml/tOYBevw_Co]]
7. 自制USBasp下载器(CN):[[http://www.amobbs.com/thread-723786-1-1.html]]
8. AVR-jtag
   usb仿真器(也可以用来下载):[[http://item.taobao.com/item.htm?spm=0.0.0.46.W1V8IW&id=2332186600]]

** [[http://blog.sina.com.cn/s/blog_605f124c0100dzsz.html][AT89S52最小系统和isp并口下载线]]


一 最小系统

[[http://photo.blog.sina.com.cn/showpic.html#blogid=605f124c0100dzsz&url=http://s14.sinaimg.cn/orignal/605f124cx6b450b08fe8d&690][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]

小结：复位电路可以暂时省掉，在p1.0接发光二极管的阴极，阳极接5v高电平，确保最小系统可以用，用同学买的实验板下载一测试程序，让接P1.0的发光二极管闪起来。如果可以闪哪么最小系统搭建成功，再接上复位电路。

二 isp下载线

[[http://photo.blog.sina.com.cn/showpic.html#blogid=605f124c0100dzsz&url=http://s4.sinaimg.cn/orignal/605f124cx6b4528355423&690][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]

1、MOSI:数据串行输出 （S51 P1.5脚）， MISO:串行数据输入（S51 P1.6脚），
，SCK:同步控制时钟（S51
P1.7脚），RST接单片机复位脚（当有足够的高电平使S51处于复位状态，它就会开启读写程序功能），
LE:器件的锁存允许，OE:器件的输出允许

2、并口各针脚的功能。
2,3,4,5,6,7,8,9为数据口,可读可写;1,14,16,17为控制口,可读可写;10,11,12,13,15为状态口,只读.18-25接地。

3，目前电脑主要有三种类型的并口：Normal、EPP、ECP。

Normal口是一种低速的并口模式，适合将结果输出送到打印机上。又分为4bit、8bit、半8bit等几类。

EPP口(EnhancedParallelPort)：增强并行口。Intel、Xircom、Zenith和其它一些公司开发的，目的是在外部设备间进行双向通信。自1991年开始笔记本电脑率先配备有EPP口。

ECP口(ExtendedCapabilitiesPort)：扩展并行口。Intel和其它公司开发出EPP口的同时，Microsoft和Hewlett-Packard也开发了一种被称为ECP(扩展并行口)的接口规格。它具有和EPP一样高的速率和双向通信能力，但在多任务环境下，它能使用DMA(直接存储器访问)方式，所需缓冲区也不大。

<1>电脑bios设置：port设置Normal
address设置378（和下载软件对应即可如下图）[[http://photo.blog.sina.com.cn/showpic.html#blogid=605f124c0100dzsz&url=http://s10.sinaimg.cn/orignal/605f124cx6b453ba266a9&690][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]

<2>软件设置：我用的isp v1.3
主要是下载线配置文件根据上面的下载线电路原理图进行设置

;----------------------------EasyIsp-2的引脚定义-------------------------

[引脚控制]
 MOSI=2
 MISO=15
 SCK=5
 RST=16
 LE=17
 OE=1
 R1=3
 R2=4

[锁存控制(LE)]
 Enable=1
 Disable=1

 [输出控制(OE)]
 Enable=0
 Disable=1



;-------------------------------------说明--------------------------------
 ;  --引脚控制--
 ;
你可以定义下载线所使用的并口引脚，只要设置对应的引脚号即可。
 ;  MOSI:数据串行输出  MISO:串行数据输入  SCK:同步控制时钟
 ;  RST:复位  LE:器件的锁存允许  OE:器件的输出允许
 ;  R1,R2:保留为以后扩展用
 ;  注意:18-25引脚都接地
2,3,4,5,6,7,8,9为数据口,可读可写;1,14,16,17为控制
 ;  口,可读可写;10,11,12,13,15为状态口,只读.
 ;  如果引脚=0,表示该引脚无效,不作控制,例如74244的OE=0.
 ;
 ;  --锁存控制--
 ;  如果器件有LE,例如74373的LE,高电平有效低电平无效.所以可以Enable=1
 ;
Disable=0,如果Enable=1,Disable=1,表示LE引脚恒为高电平,Enable=0,Disable=0,
 ;  表示LE引脚恒为低电平
 ;
 ;  --输出控制--

 三 联机 下载

不知道是电源不稳定还是下载线过长（有1.0米）isplay v1.3无法检测到器件
但是可以进行读写擦除 跑马灯根据下载的程序闪起来 还是很爽的 呵呵！


** [[http://www.cnblogs.com/zcshan/archive/2010/12/03/com.html][并口、串口、COM口区别]]


并口的工作模式：

1：SPP（Standard Parallel
Port）称为标准并口，它是最早出现的并口工作模式，几乎所有使用并口的外设都支持该模式。

2：EPP（Enhanced Parallel Port）称为增强型高速并口，它是在SPP
的基础上发展起来的新型工作模式，也是现在应用最多的并口工作模式，目前市面上的大多数打印机、扫描仪都支持EPP
模式。

3：ECP（ExtendedCapability
Port）即扩充功能并口，它是目前比较先进的并口工作模式，但兼容性问题也比较多，除非您的外设支持ECP
模式，否则不要选择该模式。



串口叫做[[http://baike.baidu.com/view/161117.htm][串行接口]]，也称串行通信接口，即COM口。按电气标准及协议来分包括[[http://baike.baidu.com/view/112004.htm][RS-232]]-C、[[http://baike.baidu.com/view/1940451.htm][RS-422]]、[[http://baike.baidu.com/view/196467.htm][RS485]]、[[http://baike.baidu.com/view/854.htm][USB]]等。
RS-232-C、RS-422与RS-485标准只对接口的电气特性做出规定，不涉及接插件、电缆或协议。USB是近几年发展起来的新型接口标准，主要应用于高速数据传输领域。


[[http://imgsrc.baidu.com/baike/pic/item/1899a23ed1770ae9828b13f2.jpg][[[http://images.cnblogs.com/cnblogs_com/zcshan/1899a23ed1770ae9828b13f2.jpg]]]]

RS-232-C：也称标准串口，是目前最常用的一种串行通讯接口。它是在1970年由美国电子工业协会（EIA）联合贝尔系统、
调制解调器厂家及计算机终端生产厂家共同制定的用于串行通讯的标
准。它的全名是“数据终端设备（DTE）和数据通讯设备（DCE）之间
串行二进制数据交换接口技术标准”。传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座。后来的PC上使用简化了的9芯D型插座。现在应用中25芯插头座已很少采用。现在的[[http://baike.baidu.com/view/2358.htm][电脑]]一般有两个串行口：COM1和COM2，你到计算机后面能看到9针D形接口就是了。现在有很多手机数据线或者物流接收器都采用COM口与计算机相连。

RS-422：为改进RS-232通信距离短、速率低的缺点，RS-422定义了一种平衡通信接口，将传输速率提高到10Mb/s，传输距离延长到4000英尺（速率低于100kb/s时），并允许在一条平衡总线上连接最多10个接收器。RS-422是一种单机发送、多机接收的单向、平衡传输规范，被命名为TIA/EIA-422-A标准。

RS-485：为扩展应用范围，EIA又于1983年在RS-422基础上制定了RS-485标准，增加了多点、双向通信能力，即允许多个发送器连接到同一条总线上，同时增加了发送器的驱动能力和冲突保护特性，扩展了总线共模范围，后命名为TIA/EIA-485-A标准。

Universal Serial
Bus（[[http://baike.baidu.com/view/474321.htm][通用串行总线]])简称USB，是目前电脑上应用较广泛的接口规范，由Intel、Microsoft、Compaq、IBM、NEC、Northern
Telcom等几家大厂商发起的新型外设接口标准。USB接口是电脑主板上的一种四针接口，其中中间两个针传输数据，两边两个针给外设供电。USB接口速度快、连接简单、不需要外接电源，传输速度12Mbps，最新USB2.0可达480Mbps；电缆最大长度5米，USB电缆有4条线，2条信号线，2条电源线，可提供5伏特电源，USB电缆还分屏蔽和非屏蔽两种，屏蔽电缆传输速度可达12Mbps，价格较贵，非屏蔽电缆速度为1.5Mbps，但价格便宜；USB通过串联方式最多可串接127个设备；支持热插拔。

RJ-45接口是以太网最为常用的接口，RJ45是一个常用名称，指的是由IEC
(60)603-7标准化，使用由国际性的接插件标准定义的8个位置(8针)的模块化插孔或者插头。



串口与并口的区别：

串口形容一下就是
一条车道，而并口就是有8个车道同一时刻能传送8位（一个字节）数据。

但是并不是并口快，由于8位通道之间的互相干扰。传输时速度就受到了限制。而且当传输出错时，要同时重新传8个位的数据。串口没有干扰，传输出错后重发一位就可以了。所以要比并口快。串口硬盘就是这样被人们重视的。



交换机的串口:

交换机的串口的英文就是trunk;是用来做下一跳路由转换用的.每个VLAN只有通过与TRUNK的路由指向后才能上外网

** [[http://www.waveshare.net/txt/AVR_ISP_Interface.htm][AVR ISP接口定义]]

AVR的ISP接口是如何定义的？

大部分AVR MCU的ISP数据端口亦为 SCK、MOSI、MISO引脚（如Attiny13/24/2313，Atmega48/88/168，Atmega16/32/162，Atmega8515/8535等），如下：

ISP下载器   AVR端口                  备注
   端口
   MISO       MISO
   VCC        VCC
   SCK        SCK
   MOSI       MOSI
  RESET      RESET
   GND        GND

少部分AVRMCU的ISP数据端口则不是使用这些接口，而是：SCK、PDI、PDO引脚（如ATmega64/128/1281等），如下：

ISP下载器   AVR端口                  备注
   端口
   MISO       PDO
   VCC        VCC
   SCK        SCK
   MOSI       PDI
  RESET      RESET
   GND        GND

以上仅例举出常用的AVR型号的连接方式，若您使用的AVR型号没有被列举到，请查看相关型号的PDF文档，里面的编程章节将有介绍使用ISP时，需连接哪些引脚
。

下面是标准的接口排列：

[10-pin]
ATMEL指定的ISP_10PIN标准接口

[6-pin_]
ATMEL指定的ISP_6PIN标准接口


** [[http://www.dianziaihaozhe.com/ziliao/929/][三极管8050和8550对管的参数]]



浏览发布时间 2009-03-13

三极管805

图１　8050和8550[[http://www.dianziaihaozhe.com/mulu/zhuanti/sjg/][三极管]]TO-92封装外形和引脚排列

三极管805

图２　8050和8550三极管SOT-23封装外形和引脚排列

8050和8550三极管在电路应用中经常作为对管来使用，当然很多时候也作为单管应用。8050 为硅材料NPN型三极管；8550 为硅材料PNP型三极管。

8050S 8550S S8050 S8550 参数：
耗散功率0.625W（贴片：0.3W）
集电极电流0.5A
集电极--基极电压40V
集电极--发射极击穿电压25V
特征频率fT 最小150MHZ 典型值产家的目录没给出
按三极管后缀号分为 B C D档贴片为 L H档
放大倍数B85-160 C120-200 D160-300 L100-200 H200-350

C8050 C8550 参数：
耗散功率1W
集电极电流1.5A
集电极--基极电压40V
集电极--发射极击穿电压25V
特征频率fT 最小100MHZ 典型190MHZ
放大倍数：按三极管后缀号分为 B C D档
放大倍数B：85-160 C：120-200 D：160-300

8050SS 8550SS 参数：
耗散功率﻿: 1W(TA=25℃) 2W(TC=25℃)
集电极电流1.5A
集电极--基极电压40V
集电极--发射极击穿电压25V
特征频率fT 最小100MHZ
放大倍数：按三极管后缀号分为 B C D D3 共4档
放大倍数 B：85-160 C：120-200 D：160-300 D3:300-400
引脚排列有EBC ECB两种

SS8050 SS8550 参数：
耗散功率﻿: 1W(TA=25℃) 2W(TC=25℃)
集电极电流1.5A
集电极--基极电压40V
集电极--发射极击穿电压25V
特征频率fT 最小100MHZ
放大倍数：按三极管后缀号分为 B C D 共3档
放大倍数 B：85-160 C：120-200 D：160-300
引脚排列多为EBC

UTC的 S8050 S8550 引脚排列有EBC
8050S 8550S 引脚排列有ECB
这种管子很少见
参数：
耗散功率1W
集电极电流0.7A
集电极--基极电压30V
集电极--发射极击穿电压20V
特征频率fT 最小100MHZ 典型产家的目录没给出
放大倍数：按三极管后缀号分为C D E档
C：120-200 D：160-300 E：280-400

NEC的8050
最大集电极电流(A):0.5 A;
直流电增益:10 to 60;
功耗:625 mW;
最大集电极-发射极电压（VCEO）:25;
频率:150 MHz .

其它的8050
PE8050 硅 NPN 30V 1.5A 1.1W
MC8050 硅 NPN 25V 700mA 200mW 150MHz
CS8050 硅 NPN 25V 1.5A FT=190 *K
3DG8050 硅 NPN 25V 1.5A FT=190 *K
2SC8050 硅 NPN 25V 1.5A FT=190 *K

值得注意的是，在代换相应的8050或8550三极管时，除了型号匹配，放大倍数也是很重要的参数。

** [[http://www.51hei.com/dianzi/300.html][晶振的作用与原理]]


     每个单片机系统里都有晶振，全程是叫晶体震荡器，在单片机系统里晶振的作用非常大，他结合单片机内部的电路，产生单片机所必须的时钟频率，单片
机的一切指令的执行都是建立在这个基础上的，晶振的提供的时钟频率越高，那单片机的运行速度也就越快。

晶振用一种能把电能和机械能相互转化的晶体在共振的状态下工作，以提供稳定，精确的单频振荡。在通常工作条件下，普通的晶振频率绝对精度可达百万分之
五十。高级的精度更高。有些晶振还可以由外加电压在一定范围内调整频率，称为压控振荡器（VCO）。

晶振的作用是为系统提供基本的时钟信号。通常一个系统共用一个晶振，便于各部分保持同步。有些通讯系统的基频和射频使用不同的晶振，而通过电子调整频
率的方法保持同步。

晶振通常与锁相环电路配合使用，以提供系统所需的时钟频率。如果不同子系统需要不同频率的时钟信号，可以用与同一个晶振相连的不同锁相环来提供。

    晶振一般采用如图1a的电容三端式(考毕兹) 交流等效振荡电路；实际的晶振交流等效电路如图1b，其中Cv是用来调节振荡频率，一般用变容二极管加上不
同的反偏电压来实现，这也是压控作用的机理；把晶体的等效电路代替晶体后如图1c。其中Co，C1，L1，RR是晶体的等效电路。

                                                                  [200712]

  分析整个振荡槽路可知，利用Cv来改变频率是有限的：决定振荡频率的整个槽路电容C=Cbe,Cce,Cv三个电容串联后和Co并联再和C1串联。可以看出：C1越小，
Co越大，Cv变化时对整个槽路电容的作用就越小。因而能“压控”的频率范围也越小。实际上，由于C1很小(1E-15量级)，Co不能忽略(1E-12量级，几PF)。所以，
Cv变大时，降低槽路频率的作用越来越小，Cv变小时，升高槽路频率的作用却越来越大。这一方面引起压控特性的非线性，压控范围越大，非线性就越厉害；另
一方面，分给振荡的反馈电压(Cbe上的电压)却越来越小，最后导致停振。采用泛音次数越高的晶振，其等效电容C1就越小；因此频率的变化范围也就越小。

   微控制器的时钟源可以分为两类：基于机械谐振器件的时钟源，如晶振、陶瓷谐振槽路；RC（电阻、电容）振荡器。一种是皮尔斯振荡器配置，适用于晶振
和陶瓷谐振槽路。另一种为简单的分立RC振荡器。

  用万用表测量晶体振荡器是否工作的方法：测量两个引脚电压是否是芯片工作电压的一半，比如工作电压是51单片机的+5V则是否是2.5V左右。另外如果用镊
子碰晶体另外一个脚，这个电压有明显变化，证明是起振了的。

  晶振的类型有SMD和DIP型，即贴片和插脚型。

 先说DIP：常用尺寸有HC-49U/T，HC-49S，UM-1，UM-5，这些都是MHZ单位的。

  再说SMD：有0705，0603，0503，0302，这里面又分四个焊点和二个焊点的，对我们公司来说默认的是四个焊点的，两个焊点的材料要求进口，周期长，一般
说两个焊点的做不了。

** [[http://blog.csdn.net/muge0913/article/details/6741064][VCC,VDD,VEE,VSS,VPP 表示的意义]]

VCC,VDD,VEE,VSS,VPP 表示的意义

*版本一：*

简单说来，可以这样理解：

一、解释

VCC：C=circuit 表示电路的意思, 即接入电路的电压；
 VDD：D=device 表示器件的意思, 即器件内部的工作电压；
 VSS：S=series 表示公共连接的意思，通常指电路公共接地端电压；
 VEE：负电压供电；
 VPP：编程/擦除电压。

二、说明

1、对于数字电路来说，VCC是电路的供电电压,VDD是芯片的工作电压（通常Vcc>Vdd），VSS是接地点。
 2、有些IC既有VDD引脚又有VCC引脚，说明这种器件自身带有电压转换功能。

3、在场效应管（或COMS器件）中，VDD为漏极，VSS为源极，VDD和VSS指的是元件引脚，而不表示供电电压。

*版本二：*

VPP：编程/擦除电压。
 VEE：负电压供电；场效应管的源极（S）
 VSS:地或电源负极

VCC：电源电压（双极器件）；电源电压（74系列数字电路）；声控载波（Voice Controlled Carrier)

VDD:电源电压（单极器件）；电源电压（4000系列数字电 路）；漏极电压（场效应管）

*版本三：*

通常VCC和VDD为电源正，而VEE和VSS为电源负或者地。
 VSS表示连接到场效应管的源极（S）的电源。
 VDD表示连接到场效应管的漏极（D）的电源。
 VEE表示连接到三极管发射极（E）的电源。
 VCC表示连接到三极管集电极（C）的电源。
 它们是这样得名的：

VCC、VDD、VEE、VSS是指芯片、分解电路的电源集结点，详细接电源的极性需视器件材料而定。 VCC一般是指直接连接到集成或分解电路内部的三极管C极，VEE是指连接到集成或分解电路内部三极管的E极。 同样，VDD、VSS就是指连接到集成内部、分解电路的场效应管的D和S极。 例如是采用P沟E/DMOS工艺制成的集成，那么它的VDD就应接电源的负，而VSS应接正电源。

*版本四：*

Vcc和Vee出现在双极型晶体管电路中，和集电极(collector)发射极(emitter)有关，所以一正一负。

Vdd,Vss在MOS电路中出现，和漏级(Drain)，源极(Source)有关，也是一正一负。

Vcc和Vdd是器件的电源端。Vcc是双极器件的正，Vdd多半是单级器件的正（例如：二极管）。下标可以理解为NPN晶体管的集电极C，和PMOS
or
NMOS场效应管的漏极D。同样你可在电路图中看见Vee和Vss，含义一样。因为主流芯片结构是硅NPN所以Vcc通常是正。如果用PNP结构Vcc就为负了。建议选用芯片时一定要看清电气参数。
 单片机中Vpp多数定义为编程电压，有的资料上把Vddf为Flash供电的外部电压



*总结：这四个版本从两个方面讲了VCC、VDD、VEE、VSS、VPP之间的区别，前两个版本一个方面，后两个版本一个方面，互相补充。*


** [[http://www.cnblogs.com/lds85930/archive/2007/09/19/897912.html][二进制、八进制、十进制、十六进制之间转换]]

一、 十进制与二进制之间的转换
 （1） 十进制转换为二进制，分为整数部分和小数部分
 ① 整数部分

方法：除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。下面举例：
 例：将十进制的168转换为二进制

 得出结果 将十进制的168转换为二进制，（10101000）2
 分析:第一步，将168除以2,商84,余数为0。
 第二步，将商84除以2，商42余数为0。
 第三步，将商42除以2，商21余数为0。
 第四步，将商21除以2，商10余数为1。
 第五步，将商10除以2，商5余数为0。
 第六步，将商5除以2，商2余数为1。
 第七步，将商2除以2，商1余数为0。
 第八步，将商1除以2，商0余数为1。

第九步，读数，因为最后一位是经过多次除以2才得到的，因此它是最高位，读数字从最后的余数向前读，即10101000

 （2） 小数部分

方法：乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，剩下的小数部分又乘以2，一直取到小数部分

为零为止。如果永远不能为零，就同十进制数的四舍五入一样，按照要求保留多少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向入一位。换句话说就是0舍1入。读数要从前面的整数读到后面的整数，下面举例：
 例1：将0.125换算为二进制

 得出结果：将0.125换算为二进制（0.001）2
 分析：第一步，将0.125乘以2，得0.25,则整数部分为0,小数部分为0.25;
 第二步, 将小数部分0.25乘以2,得0.5,则整数部分为0,小数部分为0.5;
 第三步, 将小数部分0.5乘以2,得1.0,则整数部分为1,小数部分为0.0;
 第四步,读数,从第一位读起,读到最后一位,即为0.001。


 例2,将0.45转换为二进制（保留到小数点第四位）



大家从上面步骤可以看出，当第五次做乘法时候，得到的结果是0.4，那么小数部分继续乘以2，得0.8，0.8又乘以2的，到1.6这样一直乘下去，最后不可能得到小数部分为零，因此，这个时候只好学习十进制的方法进行四舍五入了，但是二进制只有0和1两个，于是就出现0舍1入。这个也是计算机在转换中会产生误差，但是由于保留位数很多，精度很高，所以可以忽略不计。
 那么，我们可以得出结果将0.45转换为二进制约等于0.0111
 上面介绍的方法是十进制转换为为二进制的方法，需要大家注意的是：
 1） 十进制转换为二进制，需要分成整数和小数两个部分分别转换
 2） 当转换整数时，用的除2取余法，而转换小数时候，用的是乘2取整法
 3） 注意他们的读数方向

因此，我们从上面的方法，我们可以得出十进制数168.125转换为二进制为10101000.001,或者十进制数转换为二进制数约等于10101000.0111。

 （3） 二进制转换为十进制 不分整数和小数部分

方法：按权相加法，即将二进制每位上的数乘以权，然后相加之和即是十进制数。例
 将二进制数101.101转换为十进制数。

 得出结果：（101.101）2=(5.625)10
 大家在做二进制转换成十进制需要注意的是
 1） 要知道二进制每位的权值
 2） 要能求出每位的值


 二、 二进制与八进制之间的转换

首先，我们需要了解一个数学关系，即23=8，24=16，而八进制和十六进制是用这

关系衍生而来的，即用三位二进制表示一位八进制，用四位二进制表示一位十六进制数。

接着，记住4个数字8、4、2、1（23=8、22=4、21=2、20=1）。现在我们来练习二进制与八进制之间的转换。
 （1） 二进制转换为八进制

方法：取三合一法，即从二进制的小数点为分界点，向左（向右）每三位取成一位，接着将这三位二进制按权相加，得到的数就是一位八位二进制数，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的八进制数。如果向左（向右）取三位后，取到最高（最低）位时候，如果无法凑足三位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足三位。例
 ①将二进制数101110.101转换为八进制

 得到结果：将101110.101转换为八进制为56.5

 ② 将二进制数1101.1转换为八进制

 得到结果：将1101.1转换为八进制为15.4

 （2） 将八进制转换为二进制

方法：取一分三法，即将一位八进制数分解成三位二进制数，用三位二进制按权相加去凑这位八进制数，小数点位置照旧。例：
 ① 将八进制数67.54转换为二进制

 因此，将八进制数67.54转换为二进制数为110111.101100，即110111.1011
 大家从上面这道题可以看出，计算八进制转换为二进制
 首先，将八进制按照从左到右，每位展开为三位，小数点位置不变
 然后，按每位展开为22，21，20（即4、2、1）三位去做凑数，即a×22+ b×21
+c×20=该位上的数（a=1或者a=0，b=1或者b=0，c=1或者c=0）,将abc排列就是该位的二进制数
 接着，将每位上转换成二进制数按顺序排列
 最后，就得到了八进制转换成二进制的数字。
 以上的方法就是二进制与八进制的互换，大家在做题的时候需要注意的是
 1） 他们之间的互换是以一位与三位转换，这个有别于二进制与十进制转换
 2）
大家在做添0和去0的时候要注意，是在小数点最左边或者小数点的最右边（即整数的最高位和小数的最低位）才能添0或者去0，否则将产生错误

 三、 二进制与十六进制的转换

方法：与二进制与八进制转换相似，只不过是一位（十六）与四位（二进制）的转换，下面具体讲解
 （1） 二进制转换为十六进制

方法：取四合一法，即从二进制的小数点为分界点，向左（向右）每四位取成一位，接着将这四位二进制按权相加，得到的数就是一位十六位二进制数，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的十六进制数。如果向左（向右）取四位后，取到最高（最低）位时候，如果无法凑足四位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足四位。
 ①例：将二进制11101001.1011转换为十六进制

 得到结果：将二进制11101001.1011转换为十六进制为E9.B


 ② 例：将101011.101转换为十六进制

 因此得到结果：将二进制101011.101转换为十六进制为2B.A



 (2)将十六进制转换为二进制

方法：取一分四法，即将一位十六进制数分解成四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧。
 ①将十六进制6E.2转换为二进制数

 因此得到结果：将十六进制6E.2转换为二进制为01101110.0010即110110.001

 四、八进制与十六进制的转换

方法：一般不能互相直接转换，一般是将八进制（或十六进制）转换为二进制，然后再将二进制转换为十六进制（或八进制），小数点位置不变。那么相应的转换请参照上面二进制与八进制的转换和二进制与十六进制的转


 五、八进制与十进制的转换
 （1）八进制转换为十进制

方法：按权相加法，即将八进制每位上的数乘以位权，然后相加之和即是十进制数。
 例：①将八进制数67.35转换为十进制

 （2）十进制转换为八进制
 十进制转换成八进制有两种方法：
 1）间接法：先将十进制转换成二进制，然后将二进制又转换成八进制

2）直接法：前面我们讲过，八进制是由二进制衍生而来的，因此我们可以采用与十进制转换为二进制相类似的方法，还是整数部分的转换和小数部分的转换，下面来具体讲解一下：
 ①整数部分

方法：除8取余法，即每次将整数部分除以8，余数为该位权上的数，而商继续除以8，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。
 ②小数部分

方法：乘8取整法，即将小数部分乘以8，然后取整数部分，剩下的小数部分继续乘以8，然后取整数部分，剩下的小数部分又乘以8，一直取到小数部分为零为止。如果永远不能为零，就同十进制数的四舍五入一样，暂取个名字叫3舍4入。
 例：将十进制数796.703125转换为八进制数
 解：先将这个数字分为整数部分796和小数部分0.703125
 整数部分

 小数部分

 因此，得到结果十进制796.703125转换八进制为1434.55

上面的方法大家可以验证一下，你可以先将十进制转换，然后在转换为八进制，这样看得到的结果是否一样

 六、十六进制与十进制的转换

十六进制与八进制有很多相似之处，大家可以参照上面八进制与十进制的转换自己试试这两个进制之间的转换。
 通过上面对各种进制之间的转换，我们可以将前面的转换图重新完善一下：



本文介绍了二进制、十进制、八进制、十六进制四种进制之间相互的转换，大家在转换的时候要注意转换的方法，以及步骤，特别是十进制转换为期于三种进制之间，要分为整数部分和小数部分，最后就是小数点的位置。但是要保证考试中不出现错误还是需要大家经常练习，这样才能熟能生巧。

** [[http://www.cnblogs.com/gmh915/archive/2010/06/11/1756067.html][指针函数与函数指针的区别]]



一、

在学习arm过程中发现这“指针函数”与“函数指针”容易搞错，所以今天，我自己想一次把它搞清楚，找了一些资料，首先它们之间的定义：

1、指针函数是指带指针的函数，即本质是一个函数。函数返回类型是某一类型的指针

  类型标识符  *函数名(参数表)

  int *f(x，y);



首先它是一个函数，只不过这个函数的返回值是一个地址值。函数返回值必须用同类型的指针变量来接受，也就是说，指针函数一定有函数返回值，而且，在主调函数中，函数返回值必须赋给同类型的指针变量。

表示：

float *fun();

float *p;

p = fun(a);

注意指针函数与函数指针表示方法的不同，千万不要混淆。最简单的辨别方式就是看函数名前面的指针*号有没有被括号（）包含，如果被包含就是函数指针，反之则是指针函数。

来讲详细一些吧！请看下面

 指针函数：
 当一个函数声明其返回值为一个指针时，实际上就是返回一个地址给调用函数，以用于需要指针或地址的表达式中。
 格式：
 类型说明符 * 函数名(参数)
 当然了，由于返回的是一个地址，所以类型说明符一般都是int。
 例如：int *GetDate();
 int * aaa(int,int);
 函数返回的是一个地址值，经常使用在返回数组的某一元素地址上。

 int * GetDate(int wk,int dy);

 main()
 {
 int wk,dy;
 do
 {
 printf(Enter week(1-5)day(1-7)\n);
 scanf(%d%d,&wk,&dy);
 }
 while(wk<1||wk>5||dy<1||dy>7);
 printf(%d\n,*GetDate(wk,dy));
 }

 int * GetDate(int wk,int dy)
 {
 static int calendar[5][7]=
 {
 {1,2,3,4,5,6,7},
 {8,9,10,11,12,13,14},
 {15,16,17,18,19,20,21},
 {22,23,24,25,26,27,28},
 {29,30,31,-1}
 };
 return &calendar[wk-1][dy-1];
 }
 程序应该是很好理解的，子函数返回的是数组某元素的地址。输出的是这个地址里的值。







2、函数指针是指向函数的指针变量，即本质是一个指针变量。

int (*f) (int x); /* 声明一个函数指针 */

f=func; /* 将func函数的首地址赋给指针f */



指向函数的指针包含了函数的地址，可以通过它来调用函数。声明格式如下：
 类型说明符 (*函数名)(参数)
 其实这里不能称为函数名，应该叫做指针的变量名。这个特殊的指针指向一个返回整型值的函数。指针的声明笔削和它指向函数的声明保持一致。
 指针名和指针运算符外面的括号改变了默认的运算符优先级。如果没有圆括号，就变成了一个返回整型指针的函数的原型声明。
 例如：
 void (*fptr)();
 把函数的地址赋值给函数指针，可以采用下面两种形式：
 fptr=&Function;
 fptr=Function;
 取地址运算符&不是必需的，因为单单一个函数标识符就标号表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。
 可以采用如下两种方式来通过指针调用函数：
 x=(*fptr)();
 x=fptr();
 第二种格式看上去和函数调用无异。但是有些程序员倾向于使用第一种格式，因为它明确指出是通过指针而非函数名来调用函数的。下面举一个例子：

 void (*funcp)();
 void FileFunc(),EditFunc();

 main()
 {
 funcp=FileFunc;
 (*funcp)();
 funcp=EditFunc;
 (*funcp)();
 }

 void FileFunc()
 {
 printf(FileFunc\n);
 }

 void EditFunc()
 {
 printf(EditFunc\n);
 }

 程序输出为：
 FileFunc
 EditFunc



主要的区别是一个是指针变量，一个是函数。在使用是必要要搞清楚才能正确使用



二、指针的指针
 指针的指针看上去有些令人费解。它们的声明有两个星号。例如：
 char ** cp;
 如果有三个星号，那就是指针的指针的指针，四个星号就是指针的指针的指针的指针，依次类推。当你熟悉了简单的例子以后，就可以应付复杂的情况了。当然，实际程序中，一般也只用到
二级指针，三个星号不常见，更别说四个星号了。
 指针的指针需要用到指针的地址。
 char c='A';
 char *p=&c;
 char **cp=&p;
 通过指针的指针，不仅可以访问它指向的指针，还可以访问它指向的指针所指向的数据。下面就是几个这样的例子：
 char *p1=*cp;
 char c1=**cp;
 你可能想知道这样的结构有什么用。利用指针的指针可以允许被调用函数修改局部指针变量和处理指针数组。

 void FindCredit(int **);

 main()
 {
 int vals[]={7,6,5,-4,3,2,1,0};
 int *fp=vals;
 FindCredit(&fp);
 printf(%d\n,*fp);
 }

 void FindCredit(int ** fpp)
 {
 while(**fpp!=0)
 if(**fpp<0) break;
 else (*fpp)++;
 }

 首先用一个数组的地址初始化指针fp，然后把该指针的地址作为实参传递给函数FindCredit()。FindCredit()函数通过表达式**fpp间接地得到数组中的数据。为遍历数组以找到一个负值，FindCredit()函数进行自增运算的对象是调用者的指向数组的指针，而不是它自己的指向调用者指针的指针。语句(*fpp)++就是对形参指针指向的指针进行自增运算的。但是因为*运算符高于++运算符，所以圆括号在这里是必须的，如果没有圆括号，那么++运算符将作用于二重指针fpp上。

三、指向指针数组的指针
 指针的指针另一用法旧处理指针数组。有些程序员喜欢用指针数组来代替多维数组，一个常见的用法就是处理字符串。

 char *Names[]=
 {
 Bill,
 Sam,
 Jim,
 Paul,
 Charles,
 0
 };

 main()
 {
 char **nm=Names;
 while(*nm!=0) printf(%s\n,*nm++);
 }

 先用字符型指针数组Names的地址来初始化指针nm。每次printf()的调用都首先传递指针nm指向的字符型指针，然后对nm进行自增运算使其指向数组的下一个元素(还是指针)。注意完成上述认为的语法为*nm++，它首先取得指针指向的内容，然后使指针自增。
 注意数组中的最后一个元素被初始化为0，while循环以次来判断是否到了数组末尾。具有零值的指针常常被用做循环数组的终止符。程序员称零值指针为空指针(NULL)。采用空指针作为终止符，在树种增删元素时，就不必改动遍历数组的代码，因为此时数组仍然以空指针作为结束。

** [[http://blog.csdn.net/jiangwei0910410003/article/details/38269117][数据结构和算法设计专题之---判断单链表中是否有环，环的长度，环的入口节点]]

题目：

给定一个单链表，只给出头指针head：

*1、如何判断是否存在环？
 2、如何知道环的长度？
 3、如何找出环的连接点在哪里？
 4、带环链表的长度是多少？*

 解法：

1、对于问题1，使用追赶的方法，设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。

2、对于问题2，记录下问题1的碰撞点p，slow、fast从该点开始，再次碰撞所走过的操作数就是环的长度s。

3、问题3：有定理：*碰撞点p到连接点的距离=头指针到连接点的距离*，因此，分别从碰撞点、头指针开始走，相遇的那个点就是连接点。(证明在后面附注)

4、问题3中已经求出连接点距离头指针的长度，加上问题2中求出的环的长度，二者之和就是带环单链表的长度



判断是否存在环的程序：

#+BEGIN_EXAMPLE
    bool IsExitsLoop(slist *head)
    {
        slist *slow = head, *fast = head;
        while ( fast && fast->next )
        {
            slow = slow->next;
            fast = fast->next->next;
            if ( slow == fast ) break;
        }
        return !(fast == NULL || fast->next == NULL);
    }
#+END_EXAMPLE


 寻找环连接点（入口点）的程序：

#+BEGIN_EXAMPLE
    slist* FindLoopPort(slist *head)
    {
        slist *slow = head, *fast = head;
        while ( fast && fast->next )
        {
            slow = slow->next;
            fast = fast->next->next;
            if ( slow == fast ) break;
        }
        if (fast == NULL || fast->next == NULL)
            return NULL;
        slow = head;
        while (slow != fast)
        {
             slow = slow->next;
             fast = fast->next;
        }
        return slow;
    }
#+END_EXAMPLE



亦可以用类似与hash表的方法，即设立一个数组，将链表结点中的值做数组下标，当赋值冲突时就是环的接入点



证明题：

对于一个顺时针的环，有P,Q两点，且两点相距为N,同时，P每向前移动一步，Q就向前以东两步，已知环的周长是L,问P,Q两点相遇在哪点上？如下图所示：P点是环的入口点

[[http://img.blog.csdn.net/20140729143710703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center]]

假设P,Q两点相遇时，P点移动的距离是X,则有以下等式：

X-N = 2*X - L;

=>X= L-N

那么我可以从上图看到相遇点离入口点的距离为：L-(L-N)=N



综上所述：

假设单链表的总长度为L，头结点到环入口的距离为a，环入口到快慢指针相遇的结点距离为x，环的长度为r，慢指针总共走了s步，则快指针走了2s步。另外，快指针要追上慢指针的话快指针至少要在环里面转了一圈多(假设转了n圈加x的距离)，得到以下关系：
     s = a + x
     2s = a + nr + x
     =>a + x = nr
     =>a = nr - x

由上式可知：若在头结点和相遇结点分别设一指针，同步(单步)前进，则最后一定相遇在环入口结点

通过上面的证明题发现数学知识在编程世界中真的很重要呀~~



总结：我们看到这里面有一个核心的地方就是第一个问题，判断有没有环的情况，采用了两个指针：快指针和慢指针，这个在处理一些链表的问题中尤其重要，比如下面的两道关于链表的题目：

*第一题：已知单链表的头指针，查找到倒数第K个节点*

这道题的通俗的解法就是先遍历一边链表，得到链表的长度N,然后再从头开始遍历N-K个节点即可

但是现在如果要求只遍历一遍链表的话，该怎么操作呢？

这时候就可以借助快指针和慢指针了

我们定义一个快指针P和慢指针Q,先让P指针走到K个节点位置，然后Q指针从头指针开始和P一起移动，当P移动到尾部的时候，那么此时Q节点所在的位置就是倒数第K个节点。



*第二题：已知单链表的头结点，查找到链表的中间节点*

这道题的通俗的解法和上面的方法一样，就是先遍历一边链表，得到链表的长度N，然后再次遍历N/2个节点即可

但是现在同样的如果要求之遍历一边链表的话，该怎么操作呢？

这时候我们同样可以借助快指针和慢指针了

我们定义一个快指针P和慢指针Q,P和Q同时从头指针出发，快指针P每次移动两步，慢指针每次移动一步，当快指针P到尾部的时候，慢指针Q所在的位置就是中间节点的位置。



通过上面的两道题目我们可以看到快慢指针的在解决单链表的相关问题上还是很有用的~~



下面在来看一下还有一个技巧就是在解决第二道题目的时候，那个求环的入口节点，这个当时真的是没有任何头绪，所以这时候就要求我们又很好的数学功底了，能够发现相关的规律，然后总结出定理，这样就可以将问题简化了。

** [[http://blog.csdn.net/guoyong10721073/article/details/8144401][判断一个单向链表中是否有环]]

**** 写一段代码判断一个单向链表中是否有环

#+BEGIN_EXAMPLE
    思路：
    用两个指针，pSlow，pFast，就是一个慢一个快
    慢的一次跳一步，
    快的一次跳两步，
    什么时候快的追上慢的了就表示有环（pSlow == pFast ）。
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    实现如下：
#+END_EXAMPLE

#+BEGIN_EXAMPLE
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    struct  listtype
    {
        int data;
        struct listtype * next;
    }list;

    int find_cicle(list *head)
    {
         list *pFast=head;
         list *pSlow=head;
         if (pFast==NULL)
         {
              return -1;
          }
         while(pFast && pFast->next)
        {
            pFast=pFast->next->next;
            pSlow=pSlow->next;
            if (pFast==pSlow)
           {
               return 1;
            }
         }
         return 0
    }
#+END_EXAMPLE


调用函数返回值为1时，表示单向链表有环；

#+BEGIN_EXAMPLE
    调用函数返回值为-1时，表示测试的单向链表为空；
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    调用函数返回值为0时，表示单向链表无环；
#+END_EXAMPLE

** [[http://blog.sina.com.cn/s/blog_5420e000010185o2.html][conflicting types for xx错误]]

编译libvmi 0.8版本时，出现以下错误：

libtool: compile:  gcc -DHAVE_CONFIG_H -I. -I.. -I..
-fvisibility=hidden -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include
-g -O2 -MT libvmi_la-pretty_print.lo -MD -MP -MF
.deps/libvmi_la-pretty_print.Tpo -c pretty_print.c  -fPIC -DPIC -o
.libs/libvmi_la-pretty_print.o

pretty_print.c:31: error: conflicting types for ‘vmi_print_hex'

libvmi.h:749: note: previous declaration of ‘vmi_print_hex' was here

make[3]: *** [libvmi_la-pretty_print.lo] Fehler 1

make[3]: Leaving directory `/usr/local/src/libvmi-0.8/libvmi'

make[2]: *** [all-recursive] Fehler 1

make[2]: Leaving directory `/usr/local/src/libvmi-0.8/libvmi'

make[1]: *** [all-recursive] Fehler 1

make[1]: Leaving directory `/usr/local/src/libvmi-0.8'

make: *** [all] Fehler 2

解决方案：

将*libvmi/libvmi.h:void vmi_print_hex (unsigned char *data, unsigned
long length);和*

*libvmi/pretty_print.c:void vmi_print_hex (unsigned char *data,
size_t length)*

*中的数据类型改为一致的即可。*

*见其论坛：[[https://groups.google.com/forum/?fromgroups#!topic/vmitools/w76m93KevFg]]*



*常见此类问题的原因如下（引）*

错误：
test.c:22: error: conflicting types for 'urlencode'
 test.c:18: error: previous implicit declaration of 'urlencode' was here



原因一：
 原来是因为没有先做函数声明，而函数位于main()之后。
 在main函数前声明了函数原型后，一切ok.



原因二：

头文件的被循环引用，在引用时考虑清楚包含顺序



原因三：

头文件声明和定义参数稍有不同

例：

 头文件中声明 void Hanlder(const char * buf);

 在定义时写作 void Hanlder(char * buf);

这是就会发生conflicting types for 错误问题

** [[http://blog.chinaunix.net/uid-21411227-id-1826747.html][gcc及其选项详解]]

*1.简介：*

gcc是gnu旗舰产品,目前基本上就是和unix捆绑在一起分发的。这个东西功能强大,但是有多达上千个选项,其用户手册也有将近一万行.虽然其中的多数选项平时很少用到.但是不管装软件还是写程序,往往都会用到gcc.下面我就gcc最最常用的几个选项做一个简要的说明,如果你想对gcc有一个全面的了解,比如你想知道在其他非x86平台上gcc是如何工作的话,你可以用命令：man
gcc;

gcc  [-c|-S|-E] [-std=standard]

  [-g] [-pg] [-Olevel]

  [-Wwarn...] [-pedantic]

  [-Idir...] [-Ldir...]

  [-Dmacro[=defn]...] [-Umacro]

  [-foption...] [-mmachine-option...]

  [-o outfile] infile...

-c  编译为目标文件，不连接库

-S  编译为汇编代码

-E   预处理.预处理之后的代码将送往标准输出

-Wwarn... 设置警告,可以设置的警告开关很多,通常用-Wall开启所有的警告

-Olevel  设置优化级别,level可以是0,1,2,3或者s,默认-O0,即不进行优化。.

-Dname=definition...
在命令行上定义宏,有两种方式,-Dname或者-Dname=definition.在命令行上设置宏定义的目的主要是为了在调试的时候设定一些开关,
而在发布的时候再关闭或者打开这些开关即可,当然宏定义也用来对代码进行有选择地编译.另外也还有其他的一些作用.

-Uname  取消宏定义name,作用和上面的正好相反.

-Idir...
把dir加到头文件的搜索路径中,而且gcc会在搜索标准头文件之前先搜索dir.

-llibrary
在连接的时候搜索library库，库是一些archieve文件--其成员是目标文件.如果有文件引用library,library在命令行的位置应该在那个文件之后,因此,*越底层的库越要放在后面.*比如如果你要连接pcap库,那么你就需要使用-lpcap对源文件进行编译.

-Ldir...
把dir加到库文件的搜索路径中,而且gcc会在搜索标准库文件之前先搜索dir.

-pthread
通过pthreads库加入对多线程的支持,这为预处理和连接设置了标志.pthread是POSIX指定的标准线程库.

-std=standard
设置采用的标准,该选项是针对C语言的,比如-std=c99表示编译器遵循C99标准.该选项较少使用.而且有时反而会把你搞糊涂.

-o outfile  指定输出文件的文件名,默认为a.out

-mmachine-option...  指定所用的平台.



---------------------------------------------------------------------------------------

*2.gcc常用选项总结* **

*2.1* *常规选项* **

1、没有任何选项：gcc  helloworld.c

结果会在与helloworld.c相同的目录下产生一个a.out的可执行文件。

*2、-o选项，指定输出文件名：*gcc -o helloworld helloworld.c

-o意思是Output即需要指定输出的可执行文件的名称。这里的名称为helloworld。

*3、-c选项，只编译，不汇编连接：*gcc -c helloworld.c

-c意思就是Compile，产生一个叫helloworld.o的目标文件

4、-S选项，产生汇编源文件：gcc -S helloworld.c

-S意思就是aSsemble，产生一个叫helloworld.s的汇编源文件

5、-E选项，预处理C源文件：gcc -E helloworld.c

-E意思就是prEprocess。输出不是送到一个文件而是标准输出。当然可以对它进行重定向：

gcc -E helloworld.c > helloworld.txt

*2.2* *优化选项* **

1) -O选项，基本优化：gcc -O helloworld.c

-O意思就是Optimize，产生一个经过优化的叫作a.out的可执行文件。也可以同时使用-o选项，以指定输出文件名。如：

gcc -O -o test helloworld.c

即会产生一个叫test的经过优化的可执行文件。

2) -O2选项，最大优化：gcc -O2 helloworld.c

产生一个经过最大优化的叫作a.out的可执行文件。

*2.3* *调试选项* **

*1) -g选项，产生供gdb调试用的可执行文件：gcc -g helloworld.c*

产生一个叫作a.out的可执行文件，大小明显比只用-o选项编译汇编连接后的文件大。

2) -pg选项，产生供gprof剖析用的可执行文件：gcc -pg helloworld.c

产生一个叫作a.out的执行文件，大小明显比用-g选项后产生的文件还大。





------------------------------------------------------------------------------------

*3. Gcc的错误类型及对策* **

 Gcc编译器如果发现源程序中有错误，就无法继续进行，也无法生成最终的可执行文件。为了便于修改，gcc给出错误资讯，我们必须对这些错误资讯逐个进行分析、处理，并修改相应的语言，才能保证源代码的正确编译连接。gcc给出的错误资讯一般可以分为四大类，下面我们分别讨论其产生的原因和对策。

*第一类∶C语法错误* **

*错误资讯∶文件source.c中第n行有语法错误(syntex
errror)。*这种类型的错误，一般都是C语言的语法错误，应该仔细检查源代码文件中第n行及该行之前的程序，有时也需要对该文件所包含的头文件进行检查。有些情况下，一个很简单的语法错误，gcc会给出一大堆错误，我们最主要的是要保持清醒的头脑，不要被其吓倒，必要的时候再参考一下C语言的基本教材。

*第二类∶头文件错误* **

错误资讯∶找不到头文件head.h(Can not find include file
head.h)。这类错误是源代码文件中的包含头文件有问题，可能的原因有头文件名错误、指定的头文件所在目录名错误等，也可能是错误地使用了双引号和尖括号。

*第三类∶档案库错误* **

错误资讯∶连接程序找不到所需的函数库，例如∶

ld: -lm: No such file or directory

这类错误是与目标文件相连接的函数库有错误，可能的原因是函数库名错误、指定的函数库所在目录名称错误等，检查的方法是使用find命令在可能的目录中寻找相应的函数库名，确定档案库及目录的名称并修改程序中及编译选项中的名称。

*第四类∶未定义符号* **

错误资讯∶有未定义的符号(Undefined
symbol)。这类错误是在连接过程中出现的，可能有两种原因∶*一是*使用者自己定义的函数或者全局变量所在源代码文件，没有被编译、连接，或者干脆还没有定义，这需要使用者根据实际情况修改源程序，给出全局变量或者函数的定义体；*二是*未定义的符号是一个标准的库函数，在源程序中使用了该库函数，而连接过程中还没有给定相应的函数库的名称，或者是该档案库的目录名称有问题，这时需要使用档案库维护命令ar检查我们需要的库函数到底位于哪一个函数库中，确定之后，修改gcc连接选项中的-l和-L项。

排除编译、连接过程中的错误，应该说这只是程序设计中最简单、最基本的一个步骤，可以说只是开了个头。这个过程中的错误，只是我们在使用C语言描述一个算法中所产生的错误，是比较容易排除的。我们写一个程序，到编译、连接通过为止，应该说刚刚开始，程序在运行过程中所出现的问题，是算法设计有问题，说得更玄点是对问题的认识和理解不够，还需要更加深入地测试、调试和修改。一个程序，稍为复杂的程序，往往要经过多次的编译、连接和测试、修改。

** [[http://blog.csdn.net/wae_gossip/article/details/8102614][ GetMemory(),运行Test 函数会有什么样的结果？]]

题目：void GetMemory(char *p)
{
p = (char *)malloc(100);
}
void Test(void)
{
char *str = NULL;
GetMemory(str);
strcpy(str, "hello world");
printf(str);
}
请问运行Test 函数会有什么样的结果？
分析：程序崩溃。因为GetMemory 并不能传递动态内存，Test 函数中的 str 一直都是 NULL。strcpy(str, "hello world");将使程序崩溃。

题目：char *GetMemory(void)
{
char p[] = "hello world";
return p;
}
void Test(void)
{
char *str = NULL;
str = GetMemory();
printf(str);
}
请问运行Test 函数会有什么样的结果？
分析：可能是乱码。因为GetMemory 返回的是指向“栈内存”的指针，该指针的地址不是 NULL，但其原来的内容已经被清除，新内容不可知。

题目：void GetMemory(char **p, int num)
{
*p = (char *)malloc(num);
}
void Test(void)
{
char *str = NULL;
GetMemory(&str, 100);
strcpy(str, "hello");
printf(str);
}
请问运行Test 函数会有什么样的结果？
分析：
（1）能够输出hello
（2）内存泄漏

题目：void Test(void)
{
char *str = (char *) malloc(100);
strcpy(str, “hello”);
free(str);
if(str != NULL)
{
strcpy(str, “world”);
printf(str);
}
}
请问运行Test 函数会有什么样的结果？
分析：
篡改动态内存区的内容，后果难以预料，非常危险。
因为free(str);之后，str 成为野指针，if(str != NULL)语句不起作用。

** [[http://blog.csdn.net/hairetz/article/details/4141043][堆和栈的区别]]

一、预备知识—程序的内存分配
  一个由C/C++编译的程序占用的内存分为以下几个部分
  1、栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。其
  操作方式类似于数据结构中的栈。
  2、堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回
  收   。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。
  3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的
  全局变量和静态变量在一块区域，   未初始化的全局变量和未初始化的静态变量在相邻的另
  一块区域。   -   程序结束后由系统释放。
  4、文字常量区   —常量字符串就是放在这里的。   程序结束后由系统释放
  5、程序代码区—存放函数体的二进制代码。


  二、例子程序
  这是一个前辈写的，非常详细
  //main.cpp
  int   a   =   0;   全局初始化区
  char   *p1;   全局未初始化区
  main()
  {
  int   b;   栈
  char   s[]   =   "abc";   栈
  char   *p2;   栈
  char   *p3   =   "123456";   123456/0在常量区，p3在栈上。
  static   int   c   =0；   全局（静态）初始化区
  p1   =   (char   *)malloc(10);
  p2   =   (char   *)malloc(20);
  分配得来得10和20字节的区域就在堆区。
  strcpy(p1,   "123456");   123456/0放在常量区，编译器可能会将它与p3所指向的"123456"
  优化成一个地方。
  }


  二、堆和栈的理论知识
  2.1申请方式
  stack:
  由系统自动分配。   例如，声明在函数中一个局部变量   int   b;   系统自动在栈中为b开辟空
  间
  heap:
  需要程序员自己申请，并指明大小，在c中malloc函数
  如p1   =   (char   *)malloc(10);
  在C++中用new运算符
  如p2   =   new   char[10];
  但是注意p1、p2本身是在栈中的。


  2.2
  申请后系统的响应
  栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢
  出。
  堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
  会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表
  中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的
  首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。
  另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部
  分重新放入空闲链表中。

  2.3申请大小的限制
  栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意
  思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有
  的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将
  提示overflow。因此，能从栈获得的空间较小。
  堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储
  的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小
  受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。



  2.4申请效率的比较：
  栈由系统自动分配，速度较快。但程序员是无法控制的。
  堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
  另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是
  直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。


  2.5堆和栈中的存储内容
  栈：   在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可
  执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈
  的，然后是函数中的局部变量。注意静态变量是不入栈的。
  当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地
  址，也就是主函数中的下一条指令，程序由该点继续运行。
  堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

  2.6存取效率的比较

  char   s1[]   =   "aaaaaaaaaaaaaaa";
  char   *s2   =   "bbbbbbbbbbbbbbbbb";
  aaaaaaaaaaa是在运行时刻赋值的；
  而bbbbbbbbbbb是在编译时就确定的；
  但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。
  比如：
  #include
  void   main()
  {
  char   a   =   1;
  char   c[]   =   "1234567890";
  char   *p   ="1234567890";
  a   =   c[1];
  a   =   p[1];
  return;
  }
  对应的汇编代码
  10:   a   =   c[1];
  00401067   8A   4D   F1   mov   cl,byte   ptr   [ebp-0Fh]
  0040106A   88   4D   FC   mov   byte   ptr   [ebp-4],cl
  11:   a   =   p[1];
  0040106D   8B   55   EC   mov   edx,dword   ptr   [ebp-14h]
  00401070   8A   42   01   mov   al,byte   ptr   [edx+1]
  00401073   88   45   FC   mov   byte   ptr   [ebp-4],al
  第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到
  edx中，再根据edx读取字符，显然慢了。


  2.7小结：
  堆和栈的区别可以用如下的比喻来看出：
  使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就
  走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自
  由度小。
  使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由
  度大。

** [[http://www.cnblogs.com/sunnyjones/archive/2008/10/31/1323438.html][在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”]]

首先，作为extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。
通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数

extern "C"是连接申明(linkage declaration),被extern "C"修饰的变量和函数是按照C语言方式编译和连接的,来看看C++中对类似C的函数是怎样编译的：

作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：

void foo( int x, int y );



该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。

_foo_int_int 这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。

同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以"."来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。

未加extern "C"声明时的连接方式

假设在C++中，模块A的头文件如下：

// 模块A头文件  moduleA.h

#ifndef MODULE_A_H

#define MODULE_A_H

int foo( int x, int y );

#endif

在模块B中引用该函数：

// 模块B实现文件  moduleB.cpp

＃i nclude "moduleA.h"

foo(2,3);

    实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.obj中寻找_foo_int_int这样的符号！

加extern "C"声明后的编译和连接方式

加extern "C"声明后，模块A的头文件变为：

// 模块A头文件  moduleA.h

#ifndef MODULE_A_H

#define MODULE_A_H

extern "C" int foo( int x, int y );

#endif

在模块B的实现文件中仍然调用foo( 2,3 )，其结果是：

（1）模块A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用了C语言的方式；

（2）连接器在为模块B的目标代码寻找foo(2,3)调用时，寻找的是未经修改的符号名_foo。

如果在模块A中函数声明了foo为extern "C"类型，而模块B中包含的是extern int foo( int x, int y ) ，则模块B找不到模块A中的函数；反之亦然。

所以，可以用一句话概括extern “C”这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）：实现C++与C及其它语言的混合编程。

明白了C++中extern "C"的设立动机，我们下面来具体分析extern "C"通常的使用技巧：

extern "C"的惯用法

（1）在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理：

extern "C"

{

＃i nclude "cExample.h"

}

而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern "C"声明，在.c文件中包含了extern "C"时会出现编译语法错误。

C++引用C函数例子工程中包含的三个文件的源代码如下：

/* c语言头文件：cExample.h */

#ifndef C_EXAMPLE_H

#define C_EXAMPLE_H

extern int add(int x,int y);

#endif

/* c语言实现文件：cExample.c */

＃i nclude "cExample.h"

int add( int x, int y )

{

return x + y;

}

// c++实现文件，调用add：cppFile.cpp

extern "C"

{

＃i nclude "cExample.h"

}

int main(int argc, char* argv[])

{

add(2,3);

return 0;

}

如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern "C" {  }。

（2）在C中引用C++语言中的函数和变量时，C++的头文件需添加extern "C"，但是在C语言中不能直接引用声明了extern "C"的该头文件，应该仅将C文件中将C++中定义的extern "C"函数声明为extern类型。

C引用C++函数例子工程中包含的三个文件的源代码如下：

//C++头文件 cppExample.h

#ifndef CPP_EXAMPLE_H

#define CPP_EXAMPLE_H

extern "C" int add( int x, int y );

#endif

//C++实现文件 cppExample.cpp

＃i nclude "cppExample.h"

int add( int x, int y )

{

return x + y;

}

/* C实现文件 cFile.c

/* 这样会编译出错：＃i nclude "cExample.h" */

extern int add( int x, int y );

int main( int argc, char* argv[] )

{

add( 2, 3 );

return 0;

}

** [[http://blog.csdn.net/azhang00000/article/details/5357134][写出float x 与“零值”比较的if语句------一道面试题分析]]

写出float  x 与“零值”比较的if语句

请写出 float x 与“零值”比较的 if 语句：
*const float EPSINON = 0.00001;*
*if ((x >= - EPSINON) && (x <= EPSINON)*
不可将浮点变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”此类形式。

EPSINON应该是一个很小的值吧
因为计算机在处理浮点数的时候是有误差的，所以判断两个浮点数是不是相同，是要判断是不是落在同一个区间的，这个区间就是
[-EPSINON,EPSINON]
EPSINON一般很小，10的-6次方以下吧，具体的好像不确定的，和机器有关

出处：[[http://topic.csdn.net/t/20041126/10/3590118.html]]

*[结论]
*浮点数等值比较使用下式：
#include
#include
fabs(a - b) < FLT_EPSILON

三个EPSILON：
FLT_EPSILON
DBL_EPSILON
LDBL_EPSILON


*为什么浮点数不能直接作“等值比较”？*
在以前看书或看文章就知道有这件事了。知道是因为“精度”，但一直没有真正想过问题的严重性。
今天在易自考www.ezikao.com.cn看到一个帖子，顺便搜索了一下，测试结果让我信服了这条规则：
易自考帖子：[[http://www.ezikao.com.cn/bbs_disp.asp?boardid=47&id=79506]]

以下内容引用自林锐《高质量C/C++代码编写指南》

#+BEGIN_QUOTE
  4.3.3 浮点变量与零值比较
  ? 【规则4-3-3】不可将浮点变量用“==”或“！=”与任何数字比较。
  千万要留意，无论是float还是double类型的变量，都有精度限制。所以一定要避免将浮点变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”形式。
  假设浮点变量的名字为x，应当将
  if (x == 0.0) // 隐含错误的比较
  转化为
  if ((x>=-EPSINON) && (x<=EPSINON))
  其中EPSINON是允许的误差（即精度）。
#+END_QUOTE




最好定义一个符号常量来做。#define EPSINON 1e-6


我想是因为浮点数表示范围大，如果一个数已经很小的时候，就可以认为是0了，epsinon嘛，limit，极限什么的。
也可以想一下，0.9无限循环不是等于1吗？
如果正好某个值等于0.9循环，浮点数只能给出一个“确定”的值，那就会“做错题”。

我想原理大约是这样的。具体的嘛，我还没有弄清楚 ：）

再经过搜索后，写下如下一段话：


好了，终于找到不完整的答案了。反正我是绝不会再将浮点数直接比较了：
参见帖子：http://blog.joycode.com/joe/archive/2004/12/07/40592.aspx

我参照这篇文章写了这个例子：
#include <stdio.h>
#include <stdlib.h>

main()
{
  float d1, d2, d3, d4;

  d1 = 194268.02;
  d2 = 194268;
  d4 = 0.02;

  d3 = d1 - d2;
  if (d3 > d4)
  printf(">0.02/n");
  else if (d3 < d4)
  printf("<0.02/n");
  else
  printf("=0.02/n");

  printf("%f - %f = %f /n", d1,d2,d3);

  system("pause");
}

*请看结果：*
<0.02
194268.015625 - 194268.000000 = 0.015625

即：194268.02 - 194268.0 不等于 0.02!
存进去的数居然会变！怕了吧？

4个变量改成double型的，再测试：
*这是结果*
<0.02
194268.020000 - 194268.000000 = 0.020000
明明是0.02啊，怎么还是小于？
这次没有改我存的数了吧？WHY？

我说，我怕了，以后我再不敢用浮点数直接作相等比较了！

还是那句话：*浮点数都是有精度限制的。*
所以你存的数，不一定就是你要的数。

虽然这件事很值得郁闷，不过我还是很高兴又知道了点东西。


*2005.10.10 晚继续更新*
关于EPSINON，可不是能随便定义的！
而且应该能想到，double和float的EPSINON是不同的。
定义成什么呢？不必你去定义了，ANSI C已经定义了这些常量：
载入头文件
#include
就可以引用

FLT_EPSILON
DBL_EPSILON
LDBL_EPSILON

几个常量了。

** [[http://blog.chinaunix.net/uid-23860671-id-150499.html][常指针和指向常量的指针 ]]

1 常量指针！如 int b, c; int * const a = &b;
表示a是一个常量指针它指向变量b的内存。但是因为是常量指针所以不能再用a指向其他变量，如 a = &c; 错误！可以修改指向内存的值，如:*a = 20; BTW 常量指针声明的时候必须向我那样赋初值。

2 指向常量的指针！如 int b, c; int const *a; a = &b; a = &c;
都可以，唯独它指向的内存不能被修改。如：*a=20;这是违法的！错误！

这就是主要区别！

BTW 还有一个记住他们不同形式的技巧！看const关键字，他后面的不可修改，如int * const a = &b; 后面是a,则说明a不能修改！
int const * a = &b;后面是*a则说明*a不可被修改！

在好多书上或MSDN是经常用 const int a=5;
int b=6;
const int *p=&b;
其实 const int* 和int const* 一样，就是常指针 也就是它所指向的数据（在这是int）是常量，它自己的数据类型是const int*
还有const int *p=&b;是可以的 虽然b不是常量。
但是  const int a=6;
      int *p=&a;
会报错，因为它消除了a的const属性
**********************************************

*******我们可以总结一下********
1.  对于常量（符号常量）和常指针、常引用常对象声明都是一样的
定义格式： const 数据类型  常量名=常量值；
或  数据类型 const 常量名=常量值；

例如：const int a=7; 或 int const a=7;（符号常量）
  int b=5;
 const int *p=&b;  或 int const *p=&b;(常指针）
const int &m=b;（常引用）
const Point pt; 或 Point const pt; //常对象不能更新
常指针和常引用在功能上有所限制，就是不能通过他们更改其指向的变量的数据（值）

2. 指针常量
定义格式： 数据类型 *const 指针常量=常量值；
如char ch,*const pch=&ch;(我是一步完成的，你也可以分开）
也就是说这个指针本身是个常量，不可改变，即它所指向的地址是固定的。但，ch是可以改变的。

补充：
如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &引用名=目标变量名；
例1
int a ;
const int &ra=a;
ra=1; //错误
a=1; //正确
例2
string foo( );
void bar(string & s);
那么下面的表达式将是非法的：
bar(foo( ));
bar("hello world");
原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。
引用型参数应该在能被定义为const的情况下，尽量定义为const 。


** How to reduce PDF file size in Linux


Using a single line of GhostScript command on my Ubuntu’s terminal, I was able to reduce the size of a  PDF file from 6 MB to approximately 1 MB:

gs -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -sOutputFile=output.pdf input.pdf

You can also use the following parameters for -dPDFSETTINGS instead of /screen:

/screen – Lowest quality, lowest size
/ebook – Moderate quality
/printer – Good quality
/prepress – Best quality, highest size

** [[http://seisman.info/merge-multiple-pdfs.html][Linux下合并PDF]]

***** Contents

-  [[#cpdf][cpdf]]
-  [[#pdfunite][pdfunite]]
-  [[#pdfjam][pdfjam]]
-  [[#pdftk][pdftk]]
-  [[#gs][gs]]
-  [[#id3][参考]]
-  [[#id4][修订历史]]

经常需要将多个PDF合并为一个文件，这里收集了网上给出的一些方案，并总结一下。

*推荐使用cpdf*

*** [[#id5][cpdf]]

[[http://community.coherentpdf.com/][cpdf]]全称是Coherent PDF Command
Line Tools，是一个强大的PDF处理工具。PDF合并只是它的一个功能之一。

#+BEGIN_EXAMPLE
    cpdf input1.pdf input2.pdf -o output.pdf
#+END_EXAMPLE

*** [[#id6][pdfunite]]

=pdfunite=
是[[http://poppler.freedesktop.org][Poppler]]提供的一个工具，一般系统都已经安装了Poppler，所以这个工具在Linux下是很常见的。

#+BEGIN_EXAMPLE
    pdfunite input1.pdf input2.pdf input3.pdf output.pdf
#+END_EXAMPLE

该命令用法简单，没有多余的选项，需要注意的是该命令的最后一个PDF文件为输出文件名。

*** [[#id7][pdfjam]]

如果你安装了TeXLive，并且安装了[[http://www.ctan.org/tex-archive/macros/latex/contrib/pdfpages/][pdfpage]]包，则其中包含了
=pdfjam= 工具。

#+BEGIN_EXAMPLE
    pdfjam input1.pdf input2.pdf input3.pdf -o output.pdf
#+END_EXAMPLE

该命令的选项很多，可以通过 =pdfjam --help= 查看。

=pdfjoin= 是 =pdfjam= 的一个封装，也可以直接使用:

#+BEGIN_EXAMPLE
    pdfjoin a.pdf b.pdf
#+END_EXAMPLE

*** [[#id8][pdftk]]

[[https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/][pdftk]]是专门用于处理PDF文档的一套工具。在大多数发行版中都可以直接安装使用。

#+BEGIN_EXAMPLE
    pdftk input1.pdf input2.pdf input3.pdf cat output output.pdf
#+END_EXAMPLE

pdftk的选项很多，用法复杂，可以参考[[http://seisman.info/introduction-to-pdftk.html][PDF合并和分割工具---PDFtk]] 。

*** [[#id9][gs]]

[[http://www.ghostscript.com][GhostScript]]不仅可以用于处理PS，也可以用于处理PDF文档。

#+BEGIN_EXAMPLE
    gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=out.pdf in1.pdf in2.pdf
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -dPDFSETTINGS=/prepress -sOutputFile=out.pdf in1.pdf in2.pdf
#+END_EXAMPLE

*** [[#id10][参考]]

-  [[https://blog.dbrgn.ch/2013/8/14/merge-multiple-pdfs/]]
-  [[http://stackoverflow.com/questions/2507766/merge-convert-multiple-pdf-files-into-one-pdf]]




** [[http://www.33lc.com/article/4013.html][Win7系统下硬盘安装Ubuntu 12.04双系统]]



作者:佚名　来源:本站整理　发布时间:2012-08-24 14:26:46

本教程讲的是Win7下硬盘安装Ubuntu12.04双系统的方法。大家都知道，安装了双系统就有多种选择，这样不会疲劳，自己也可以随心所欲的看想要用哪个
系统~。好处肯定是有的，那么下面绿茶小编带大家去看看要怎么安装。

第一步、准备工作(在win7下操作完成)

1.下载镜像文件

                          +-------------------------------------------------------------------------------------+
                          |Ubuntu 64位(乌班图系统) v12.04.1 官方原版iso镜像 |http://www.33lc.com/soft/18055.html|
                          |-------------------------------------------------+-----------------------------------|
                          |Ubuntu(乌班图系统) v12.04.1 官方原版iso镜像      |http://www.33lc.com/soft/18053.html|
                          +-------------------------------------------------------------------------------------+

2.下载并安装easybcd。easybcd是一款很优秀的系统引导软件，功能强大，最关键的是傻瓜式一站式简易操作，极其适合新手使用!

3.腾出一个空盘，点击右键格式化之后把它删除(这个盘最好是在硬盘的后面，因为Windows系统不能识别Linux系统分区，如果将ubuntu装在D盘，将D盘删
除并建立Linux系统分区后，原来的E盘就会变成D盘，安装在E盘的软件会出现系统注册表路径不对称，要重新安装一遍软件)。网上很多说使用磁盘压缩功能以
整理出空白分区，这个方法也可行，但这个盘要保证有10G空间以上比较稳妥。

4.安装好easybcd2.1.2后，启动软件：

                                                                  Win7系

按照上图的序号依次点击“Add New Entry”——“Neo Grub”——“Install”，点到“Install”后出面下面的界面，再点“Configure”。

                                                                  Win7系

点击“Configure”按钮后，会出现一个记事本文件，将下面的代码粘贴到文件尾部：

title Install Ubuntu 12.04 LTS

root (hd0,6)

kernel (hd0,6)/vmlinuz boot=casper iso-scan/filename=/ubuntu-12.04-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8

initrd (hd0,6)/initrd.lz

如下图：

                                                                  Win7系

特别说明：

上图代码中“ubuntu-12.04-desktop-amd64.iso”为你下载的ubuntu 12.04系统镜像文件名，这个文件名是可以修改的，但修改的名字一定要与写入的代码名
字一致，否则将无法引导安装;

(hd0,6) 表示磁盘分区，hd(0,0), hd(0,1), hd(0,2), hd(0,3)表示主分区，(hd0,4)以后的表示逻辑分区，现在我只有一个主分区C盘，则(hd0,0)表示C盘
，(hd0,4)表示D盘，(hd0,5)表示E盘，(hd0,6)表示F盘，我的镜像就是放在F盘里，请把(hd0,6)改成自己对应的分区)

5.将下载的镜像文件放到(hd0,N)盘的根目录下，并确保文件名与上面写入的代码的文件名一致为ubuntu-12.04-desktop-amd64.iso，然后用WinRAR解压缩
软件将iso打开，将casper文件夹目录下的vmlinuz和 initrd.lz解压并复制到(hd0,N)盘根目录下。准备工作至此已全部完成!!!



** [[http://jingyan.baidu.com/article/f96699bb8b38e0894e3c1bef.html][]]

百度经验:jingyan.baidu.com

工具/原料

  * JDK 1.7 安装包

百度经验:jingyan.baidu.com

步骤/方法

 1. 1

    想要成功配置Java的环境变量，那肯定就要安装JDK，才能开始配置的。

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=1][步骤阅读]]
 2. 2

    安装JDK 向导进行相关参数设置。如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=2][步骤阅读]]
    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=3][步骤阅读]]
 3. 3

    正在安装程序的相关功能，如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=4][步骤阅读]]
 4. 4

    选择安装的路径，可以自定义，也可以默认路径。如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=5][步骤阅读]]
 5. 5

    成功安装之后，进行测试是否真的成功安装，点击【开始】----【运行】----输入 CMD，在命令提示符里面输入“Java -version”并按回车键，出现下图，
    即为安装成功。如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=6][步骤阅读]]
    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=7][步骤阅读]]
    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=8][步骤阅读]]
 6. 6

    下面开始配置环境变量，右击【我的电脑】---【属性】-----【高级】---【环境变量】，如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=9][步骤阅读]]
 7. 7

    选择【新建系统变量】--弹出“新建系统变量”对话框，在“变量名”文本框输入“JAVA_HOME”,在“变量值”文本框输入JDK的安装路径（也就是步骤5的文件夹路
    径），单击“确定”按钮，如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=10][步骤阅读]]
 8. 8

    在“系统变量”选项区域中查看PATH变量，如果不存在，则新建变量 PATH，否则选中该变量，单击“编辑”按钮，在“变量值”文本框的起始位置添加
    “%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;”或者是直接“%JAVA_HOME%\bin;”，单击确定按钮，如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=11][步骤阅读]]
 9. 9

    在“系统变量”选项区域中查看CLASSPATH 变量，如果不存在，则新建变量CLASSPATH，否则选中该变量，单击“编辑”按钮，在“变量值”文本框的起始位置添
    加“.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;”。如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=12][步骤阅读]]
10. 10

    现在测试环境变量的配置成功与否。在DOS命令行窗口输入“JAVAC”，输出帮助信息即为配置正确。如图：

    [[http://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html?picindex=13][步骤阅读]]
    END



** [[http://mp.weixin.qq.com/s?__biz=MzA3NDg0MjMxMQ==&mid=206256009&idx=1&sn=f62f186187df4bca90b09354f882ae51&scene=1&srcid=vDPm1xjsriWRNYBwXU0y&key=dffc561732c2265169f91fb169dff119595328fddf7b729591e26ccae95031a9c186df0df63cd453de729fee51231e4a&ascene=1&uin=MjM0NDAwMTM2MA%3D%3D&devicetype=webwx&version=70000001&pass_ticket=tLtEme1SBD65kfEr67N%2BlElthfzIaRBwY99P4kPDDe08Av5aTH8tqWKNeHjlIeMl][投文章前，先搞清SCI、EI、ISTP、SSCI、CSSCI和CSCD吧！]]

SCI

是美国《科学引文索引》的英文简称，其全称为：Science Citation
Index,，创刊于1961年，它是根据现代情报学家加菲尔德(Engene Garfield)
1953年提出的引文思想而创立的。时至今日加菲尔德仍是SCI主编之一。SCI是由
ISI（ Institute for Scientific Information
Inc.）美国科学情报所出版。现为双月刊。ISI除了出版SCI外，还有联机型据
SCISEARCH。ISTP（Index to Scientific ＆Technical
Proceeding）也由其出版。



SCI是一部国际性的检索刊物，包括有：自然科学、生物、医学、农业、技术和行为科学等，主要侧重基础科学。所选用的刊物来源于94个类、40多个国家、5O多种文字，这些国家主要有美国、英国、荷兰、德国、俄罗斯、法国、日本、加拿大等，也收录一定数量的中国刊物。



SCI选择期刊比较科学，它运用引文数据分析和同行评议相结合的方法，充分考虑了期刊的学术价值，在选用的
3400余种期刊里包含了国际上较为重要的期刊。它所择取的80万条论文，可以说是集各学科之精萃。因而，它成为国际公认的反映基础学科研究水准的代表性工具。并将其收录的科技论文数量的多寡，看做是一个国家的基础科学研究水平及其科技实力指标一。SCI检索系统历来成为世界学术界密切注视的中心，争相角逐的焦点，世界公认的文献统计源。



然而SCI就其本身而言，最重要的功能是帮助科技人员获取最需要的文献信息。这也是编辑该部索引的主要意图。
SCI最大的优点是引文功能，在这里读者能很快地了解到某一作者的某篇论文是否被他人引用过，通过引文次数可以了解某一学科的发展过程。另外，使用SCI还可以了解到科学技术发展的最新信息，如：有没有关于某一课题的评论？某一理论有没有被证实，某方面的工作有没有被扩展，某一方法有没有被改善，某一提法是否成立，某一概念是否具有创新性等等。因此SCI也具有反映科技论文质量和学术水平的功能。



SCI的这些优点对科技工作者查阅最新文献、跟踪国际学术前沿、科研立项以及在具体的课题研究时及时了解国际动态都有很大帮助。



SCI选取论文情况

SCI选取期刊、论文标准较其他刊物严格，已成为公认事实。SCI每年收录我国科技论文不等，究其原因相当复杂，有语言、政治、经济、科技发展规律本身的原因，也有其严格执行选刊和论文选取标准的原因。SCI每年都要充实和调整使用刊物种数。

经有关部门调查指出，SCI选刊依据主要有三方面：编辑质量、引文指标和专家评审，其中引文指标最为客观。经统计1995年
SCI收录我国6种期刊的影响因子（即期刊论文被引用的比率）都不足0.4，平均不足0．2
3，而同年SCI收录的3 4 0
0多种期刊的平均影响因子约为1左右，其中影响因子最高者达到48．9，可见我国期刊的引文指标距世界先进水平的差距之大，这恐怕是影响我国期刊入选
SCI的重要原因之一。



面对现实如何提高投稿入选率，我们觉得应从两方面引起注意：一、力争向国外投稿。SCI选刊情况虽在不断变化，但它仍有自己的核心圈刊物。据1996年中国科学技术信息研究所（简称：中信所）发表的年度研究报告显示，1996年SCI收录我国论文期刊种数虽减少，但排位却由15升至14名。增长的原因，主要是我国论文进入SCISEARCH的期刊数量增多了。从进入SCI核心圈的8200篇论文看，有
91％是发表在国外期刊上，只有9%发表在国内期刊上。据专家分析，几年内国内期刊入选种数不会有更大的突破。因此，论文外投越多，入选机率越大。二、注意论文的质量和规范化。据中信所信息分析中心1993年调查结果指出：提高入选率关键在于论文内容和学术水平是否能引起对方足够的重视。此外，SCI非常注意论文格式的标准化程度，例如：题目、作者、机构名称等是否清晰，参考文献著录的是否齐全（包括：参考文献的作者、论文题目、发表在什么期刊上及发表的年、卷、期、页、号等）。总之，由于种种原因，我们无法改变被他人选择这一事实，但经过不懈努力主宰命运的仍将是我们自己。

EI

《工程索引》(EngineeringIndex，EI)，1884年创刊，由美国工程信息公司出版，报道工程技术各学科的期刊、会议论文、科技报告等文献。

ISTP

《科技会议录索引》(Index to Scientific & Technical
Proceedings，ISTP)，也是由ISI出版，1978年创刊，报导世界上每年召开的科技会议的会议论文。版本(及区别名称)出版周期，收录文献源，印刷版(ISTP)
月刊 每年报导4700多种会议录，光盘版(ISTP)
季度更新，每年报导10000多种会议录，网络版(WOSP---S/T) 周更新，同光盘版。

SSCI

SSCI是美国《社会科学引文索引》的一个简称。《社会科学引文索引》（Social
Science Citation
Index，简称SSCI）为美国科学情报研究所建立的综合性社科文献数据库，涉及经济、法律、管理、心理学、区域研究、社会学、信息科学等。收录50个语种的1700多种重要的国际性期刊，累计约350万条记录。

CSCD

CSCD是《中国科学引文数据库》（Chinese Science Citation
Database）的简称，学科范围：数学，物理学，力学，化学，天文，地球科学，生物学，农林科学，医药卫生，工程技术，环境，管理科学。来源期刊：核心库669种期刊，扩展库378种期刊。光盘版《中国科学引文数据库》，光盘版《中国科学计量指标数据库》，书版《中国科学计量指标：论文与引文统计》。中国科学院核心CSCD与美国Thomson-Reuters
Scientific合作,中国科学引文数据库(CSCD)是ISI Web of
Knowledge(SCI)平台上第一个非英文语种的数据库，教育部学位中心2009年学科评估结果公布，中国科学引文数据库为指定查询库。中国科学引文数据库（CSCD）分为核心库和扩展库。核心库的来源期刊经过严格的评选，是各学科领域中具有权威性和代表性的核心期刊。扩展库的来源期刊也经过大范围遴选，入选者是我国各学科领域较优秀的期刊。此外，中国科学引文索引数据库（CSCD）还是：中国科学院院士推选人指定查询库、自然基金委国家杰出青年基金指定查询库、第四届中国青年科学家奖申报人指定查询库、自然基金委资助项目后期绩效评估指定查询库、自然基金委国家重点实验室评估查询库。2009
年－2010年CSCD 共遴选了 1123 种期刊，其中英文刊 67 种，中文刊 1056
种；核心库期刊 748 种，扩展库期刊 375 种。据2009 年－2010
年最新收录报告显示，好几种刊物被CSCD（核心库）收录。



中国科学引文数据库创建于1989年，收录我国数学、物理、化学、天文学、地学、生物学、农林科学、医药卫生、工程技术、环境科学和管理科学等领域出版的中英文科技核心期刊和优秀期刊千余种，目前已积累从1989年到现在的论文记录300万条，引文记录近1700万条。中国科学引文数据库被誉为“中国的SCI
”。

CSSCI

CSSCI为《中文社会科学引文索引》(Chinese Social Science Citation
Information)英文名称首字母缩写，是由南京大学研制成功的、我国人文社会科学评价领域的标志性工程。科学引文索引是从文献之间相互引证的关系上，揭示科学文献之间的内在联系。通过科学引文索引数据库的检索与查询，可以揭示已知理论和知识的应用、提高、发展和修正的过程，从一个重要侧面揭示学科研究与发展的基本走向；通过科学引文索引数据库的统计与分析，可以从定量的视角评价地区、机构、学科以及学者的科学研究水平，为人文社会科学事业发展与研究提供第一手资料。



CSSCI遵循文献计量学规律，采取定量与定性评价相结合的方法从中文人文社会科学学术性期刊中精选出学术性强、编辑规范的期刊作为来源期刊。CSSCI的来源期刊或来源文献，不仅包括中国（内地、香港、澳门、台湾），而且将包括欧美等各国出版的中文人文社会科学学术期刊。来源期刊按引文量、影响因素、专家意见等标准评定。在国内，只要具有CN（中国连续出版物编号）的正式人文社科学术期刊，又是学术性的期刊，都可参加评选。随着技术手段的成熟，CSSCI今后也将关注和收录学术集刊（具有正式书号的连续出版物）以及其他形式的学术成果。



CSSCI建有一个全国性的“CSSCI咨询委员会”（2005年改名为“CSSCI指导委员会”）。该委员会由17家委员单位和技术专家组成，其中包括北京大学、清华大学、复旦大学、中国人民大学、北京师范大学、武汉大学、南开大学、吉林大学、四川大学、中山大学、山东大学、厦门大学、华东师范大学、华中师范大学、温州师范学院、南京大学等。指导委员会是学术决策机构。其主要职责是：制定和修改指导委员会章程；审议中心中长期研究发展规划；指导中心CSSCI系统的研制与开发；审议中文社会科学引文索引来源期刊；审核CSSCI重大新闻发布内容；协调中国人文社会科学研究评价领域的全国性重大学术活动。



目前，教育部已将CSSCI数据作为全国高校机构与基地评估、成果评奖、项目立项、名优期刊的评估、人才培养等方面的重要指标。CSSCI数据库已被北京大学、清华大学、中国人民大学、复旦大学、国家图书馆、中科院等100多个单位包库使用，并作为地区、机构、学术、学科、项目及成果评价与评审的重要依据。

** [[http://www.ctex.org/documents/latex/graphics/node59.html][在页眉和页脚使用图形]]



在页眉和页脚使用图形的一个最容易的方法是使用 fancyhdr（它是旧的
fancyheadings 的增强版本）。 fancyhdr 的用法和宏包说明详见文献 [[[http://www.ctex.org/documents/latex/graphics/node119.html#fancyhdr][12]]]
。在 L^ATEX 文档中，页眉由左、中、右三部分组成。  \fancyhead 命令指
定了页眉的形式和内容，并以 L,C,R  区分左、中、右区域。例如：

\pagestyle{fancy}
\fancyhead[C]{我的文档}

使得页眉的中间部分印出`` 我的文档''，而

\pagestyle{fancy}
\fancyhead[L,R]{\textbf{Confidential}}

使得页眉的左右都印出``Confidential''。如果没有指定 L,C,R 中的任何一
个，那么由 \fancyhead 定义的内容将在三个区域中都会印出。相似地，\
fancyfoot 则用来定义页脚的左、中、右三个区域。可以利用 fancyhdr 宏
包中的命令来在页眉和页脚上使用图形。例如，在用第 [[http://www.ctex.org/documents/latex/graphics/node58.html#sec:defps][15.1]] 节的方法将
 EPS 文件 file.eps 分为 file.h 和 file.ps 后，下面的命令

\documentclass{article}
\usepackage{fancyhdr,graphicx}
\renewcommand{\headheight}{0.6in}% must be large enough for graphic
\renewcommand{\textheight}{7.5in}

% Define PostScript graphics command
\special{header=file.h}

% Save graphics in LaTeX box
\newsavebox{\mygraphic}
\sbox{\mygraphic}{\includegraphics[totalheight=0.5in]{file.ps}}
\pagestyle{fancy}
\fancyhead{} % clear all header fields
\fancyhead[L]{\usebox{\mygraphic}}
\fancyfoot{} % clear all footer fields
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\begin{document}
  ...
\end{document}

将图形放置在每一使用 ``fancy'' 风格页的左上角，并且下面有一条宽为
 0.5pt  的横线。此外，每页的页角的中央放置页码，但它的上方没有横线
。这些设置不会影响 ``plain'' 风格的页面。当使用 [twoside] 排版选项
时，经常希望在奇数页和偶数页设置不同页眉和页脚，这时可使用  O,E 选
项来区分奇数页和偶数页。如果没有给出  O,E 选项，则页眉和页脚的命令
会应用到所有的页面中，无论是奇数页还是偶数页。例如：

\pagestyle{fancy}
\fancyhead[LE]{我的文章}
\fancyhead[RO]{我的名字}
\fancyfoot[C]{\thepage}

在偶数页的左上角放置我的文章，在奇数页的右上角放置我的名字，页脚的
中央则放置页码。而命令

\pagestyle{fancy}
\fancyhead[LE,RO]{\usebox{\mygraphic}}
\fancyfoot[C]{\thepage}

使得偶数页的左上角和奇数页的右上角印出图形。 \fancyhead 命令只对那
些页面式样为 ``fancy'' 的页面起作用。即使用 \pagestyle{fancy} 将文
档的页面式样设置为 ``fancy'' 式样，一些页面，如封面，目录和每章的第
一页仍为缺省的 ``plain'' 式样。改变 Plain'' 页面式样的缺省设置可用
\fancypagestyle 命令来实现。例如将下面的命令加到上面的例子中可使得
封面，目录等的页眉上也将会有图形印出。

\fancypagestyle{plain}{%
  \fancyhead{} % clear all header fields
  \fancyhead[L]{\usebox{\mygraphic}}
  \fancyfoot{} % clear all footer fields
  \fancyfoot[C]{\thepage}
  \renewcommand{\headrulewidth}{0.5pt}
  \renewcommand{\footrulewidth}{0pt}}

当使用 [twoside] 排版选项时，将上面的

\fancyhead[L]{\usebox{\mygraphic}}

替换为

\fancyhead[LE,RO]{\usebox{\mygraphic}}

则在每一页的页眉上都放置上图形。

** [[http://jingyan.baidu.com/article/2f9b480db035e141cb6cc23e.html][9个 SSH常用命令选项]]

*** SSH 是什么

SSH（全称 Secure
Shell)是一种加密的网络协议。使用该协议的数据将被加密，如果在传输中间数据泄漏，也可以确保没有人能读取出有用信息。要使用
SSH，目标机器应该安装 SSH 服务端应用程序，因为 SSH
是基于客户-服务模式的。 当你想安全的远程连接到主机，可中间的网络（比如因特网）并不安全，通常这种情况下就会使用
SSH。

安装 SSH

如果碰巧你的机器没装，我们可以手工来安装一下。最简单的方式就是使用 Linux
包管理器。

基于 Debian / Ubuntu 的系统 :

安装 ssh-client

$ sudo apt-get install openssh-client

安装 ssh-server

$ sudo apt-get install openssh-server

基于 RedHat / CentOS 的系统 :

# yum install openssh-server openssh-clients

SSH 一旦安装上，我们就可以在终端下输入 ssh 来检查下安装的是否正常。

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

*** 使用 SSH

提供了许多可使用的选项。这篇文章会介绍一些我们在日常操作中经常使用的选项。

1. 无选项参数运行 SSH

通常使用 SSH 的方式就是不加任何选项参数,仅仅输入 "ssh"。下面是示例：

$ ssh 192.168.0.103

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

第一次连接目标主机时，ssh
会让你确认目标主机的真实性。如果你回答的是 NO，SSH
将不会继续连接，只有回答 Yes才会继续。

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

下一次再登陆此主机时，SSH
就不会提示确认消息了。对此主机的真实验证信息已经默认保存在每个用户的
/home/user/.ssh 文件里。

2. 指定登陆用户

默认的，ssh 会尝试用当前用户作为用户名来连接。在上面的示例命令中，ssh
会尝试用用户名叫 pungki 的用户身份来登入服务器，这是因为用户 pungki
正在客户机上使用 ssh 客户端软件。

假如目标主机上没有叫 pungki
的用户呢？这时你就必须提供一个目标主机上存在的用户名。从一开始就要指定用户名的，可以使用
-l 选项参数。

$ ssh -l leni 192.168.0.103

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

我们也可以这样输入：

$ ssh leni@192.168.0.0103

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

3. 指定端口

SSH 默认使用的端口号是 22。大多现代的 Linux 系统 22
端口都是开放的。如果你运行 ssh 程序而没有指定端口号，它直接就是通过 22
端口发送请求的。

一些系统管理员会改变 SSH 的默认端口号。让我们试试，现在端口号是
1234.要连上那主机，就要使用 **-p* 选项，后面在加上 SSH 端口号。

$ ssh 192.168.0.103 -p 1234

要改变端口号，我们需要修改 /etc/ssh/ssh_config 文件，找到此行：

Port 22

把它换成其他的端口号，比如上面示例的 1234 端口，然后重启 SSH 服务。

4.对所有数据请求压缩

有了这个选项，所有通过 SSH
发送或接收的数据将会被压缩，并且任然是加密的。要使用 SSH
的压缩功能，使用 -C 选项。

$ ssh -C 192.168.0.103

如果你的连网速度很慢的话，比如用 modem
上网，这个选项非常有用。但如果你使用的是像 LAN
或其它更高级网络的话，压缩反而会降低你的传输速度。可以使用 -o 选项加上压缩级别参数来控制压缩的级别，但这个选项仅仅只在
SSH-1 下起作用。

5. 指定一个加密算法

SSH 提供了一些可用的加密算法。可以在 */etc/ssh/ssh_config or
~/.ssh/config * 文件中看到（如果存在的话）。

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

让我们试试比如你想使用 blowfish 算法来加密你的 SSH
会话，那么你只要把这一行加入你的/etc/ssh/ssh_config or
~/.ssh/config 文件就可以：

Cipher blowfish

默认的，SSH 会使用 3des 算法。

6. 打开调试模式

因为某些原因，我们想要追踪调试我们建立的 SSH 连接情况。SSH
提供的 -v 选项参数正是为此而设的。

$ ssh -v 192.168.0.103

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

7. 绑定源地址

如果你的客户端有多于两个以上的 IP 地址，你就不可能分得清楚在使用哪一个
IP 连接到 SSH 服务器。

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

为了解决这种情况，我们可以使用 -b 选项来指定一个IP 地址。这个 IP
将会被使用做建立连接的源地址。

$ ssh -b 192.168.0.200 -l leni 192.168.0.103

服务端，我们可以使用 netstat 命令来检查到服务的连接是否建立。可以看到 IP
为 192.168.0.200 的连接已经建立。

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

8. 使用其他配置文件

默认情况下，ssh
会使用位于 /etc/ssh/ssh_config 的配置文件。这个配置文件作用于系统的所有用户。但你想要为特定的用户指定特殊的设置的话，可以把配置放入 ~/.ssh/config 文件中。如果此文件不存在，可以手工创建一个。

下面是一个通用 ssh_config 文件配置的例子。这配置文件位于 /home/pungki 目录下。

Host 192.168.0.*
ForwardX11 yes
PasswordAuthentication yes
ConnectTimeout 10
Ciphers
aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc
Protocol 2
HashKnownHosts yes

要使用指定的配置文件，可以使用 -F 选项。

$ ssh -F /home/pungki/my_ssh_config 192.168.0.101

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]

9. 使用 SSH X11 Forwarding

某些时候，你可能想把服务端的 X11 应用程序显示到客户端计算机上，SSH
提供了 -X 选项。但要启用这功能，我们需要做些准备，下面是它的设置：

在服务器端，你需要使 /etc/ssh/ssh_config 文件中的行设置成 ForwardX11
yes 或者 X11Forwad yes，以启用 X11 Forwarding，重启 SSH 服务程序。

然后在客户端，输入 ssh -X user@host:

$ ssh -X leni@192.168.0.101

一旦登陆，可以输入：

$ echo $DISPLAY

来检查，你应该可以看到向如下所示的

localhost:10:0

随后就可以运行应用了，仅仅只能输入应用程序的命令。让我们试试，比如想运行
xclock 程序，输入：

$ xclock

它就运行起来了，xclock
确实是运行在远端系统的，但它在你的本地系统里显示了。

[[http://img.baidu.com/img/iknow/exp/album/exp_loading.gif]]


** [[http://blog.csdn.net/reyleon/article/details/14000997][shuf 命令： 随机排序文件]]


 有时候我们需要将文本的顺序打乱，也就是随机排序，我以前的做法是写个shell，利用
bash 里的内置变量 $RANDOM 进行排序，然后打印。代码如下：

#+BEGIN_EXAMPLE
     while read line;do echo $RANDOM $line; done < file | sort -n | sed 's/[^ ]\+ //'
#+END_EXAMPLE

    这里取了个巧而已。虽然也能实现需求，但是如果遇到大文件，本身 shell
的效率是很低的。偶然得知系统本身有一个命令是专职干这事儿的，那就是 shuf
命令，那效率，是杠杠滴啊。简单介绍下：

    1. 这个命令属于 coreutils 包，如果系统没有此命令，请 yum install
coreutils 进行安装。
     2. 它也能够接受标准输入，即管道
     参数：
         -n 最多显示多少行
          -o 将随机排序后的输出写到一个文件中
     更多信息请参考man页。



另外，今天发现用 *sort
-R*也可以随机排序，只是效率比shuf稍微慢一点儿！man sort 的解释如下：

#+BEGIN_EXAMPLE
           -R, --random-sort
                  sort by random hash of keys
#+END_EXAMPLE




2013.11.13 更新

1. 在centos 5.5下，sort版本为sort (GNU coreutils) 5.97，没有-R选项

2. 在centos 6.4下，sort版本为sort (GNU coreutils) 8.4，有-R选项。

3. shuf 和 sort命令同属于coreutils 包。

** [[http://blog.csdn.net/hansel/article/details/8736775][ Bash shell 的算术运算有四种方式]]

Bash shell 的算术运算有四种方式:
1：使用 expr 外部程式

加法 r=`expr 4 + 5`
echo $r
注意! '4' '+' '5' 这三者之间要有空白
r=`expr 4 * 5` #错误
乘法 r=`expr 4 \* 5`

2：使用 $(( ))
r=$(( 4 + 5 ))
echo $r

3：使用 $[ ]

r=$[ 4 + 5 ]
echo $r

乘法
r=`expr 4 \* 5`
r=$(( 4 * 5 ))
r=$[ 4 * 5 ]
echo $r

除法
r=`expr 40 / 5`
r=$(( 40 / 5 ))
r=$[ 40 / 5 ]
echo $r

减法
r=`expr 40 - 5`
r=$(( 40 - 5 ))
r=$[ 40 - 5 ]
echo $r

求余数
r=$[ 100 % 43 ]
echo $r

乘幂 (如 2 的 3 次方)
r=$(( 2 ** 3 ))
r=$[ 2 ** 3 ]
echo $r
注：expr 没有乘幂

4：使用let 命令

变量和运算符直接不能有空格，否则要用引号括起。

加法：
n=10
let n=n+1
echo $n #n=11

乘法：
let m=n*10
echo $m

除法：
let r=m/10
echo $r

求余数：
let r=m%7
echo $r

乘幂：
let r=m**2
echo $r

虽然Bash shell 有四种算术运算方法，但并不是每一种都是跨平台的，建议使用expr。
另外，我们在 script 中经常有加1操作，以下四法皆可：
m=$[ m + 1]
m=`expr $m + 1`
m=$(($m + 1))
let m=m+1

** [[http://blog.csdn.net/jianchi88/article/details/7212370][Linux设备驱动--块设备（一）之概念和框架]]



*基本概念 *

 *块设备（blockdevice）*

--- 是一种具有一定结构的*随机存取*设备，对这种设备的读写是按*块*进行的，他使用*缓冲*区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或者从设备一次性读到缓冲区。

*字符设备（Character device）*

---是一个*顺序的数据流*设备，对这种设备的读写是按*字符*进行的，而且这些字符是连续地形成一个数据流。他不具备缓冲区，所以对这种设备的读写*是实时的*。



*扇区(Sectors)：*任何块设备硬件对数据处理的基本单位。通常，1个扇区的大小为512byte。（对设备而言）

*块
(Blocks)：*由Linux制定对内核或文件系统等数据处理的基本单位。通常，1个块由1个或多个扇区组成。（对Linux操作系统而言）

*段(Segments)：*由若干个相邻的块组成。是Linux内存管理机制中一个内存页或者内存页的一部分。

页、段、块、扇区之间的关系图如下：

[[http://hi.csdn.net/attachment/201201/20/0_13270444482t2H.gif]]



*块设备驱动整体框架*

[[http://hi.csdn.net/attachment/201201/20/0_1327044749MMUm.gif]]

 块设备的应用在Linux中是一个完整的子系统。

在Linux中，驱动对块设备的输入或输出(I/O)操作，都会向块设备发出一个请求，在驱动中用*request结构体*描述。但对于一些磁盘设备而言请求的速度很慢，这时候内核就提供一种队列的机制把这些*I/O请求*添加到队列中（即：请求队列），在驱动中用*request_queue结构体*描述。在向块设备提交这些请求前内核会先执行请求的合并和排序预操作，以提高访问的效率，然后再由内核中的*I/O调度程序子系统*来负责提交
I/O 请求，
调度程序将磁盘资源分配给系统中所有挂起的块 I/O 请求，其工作是管理块设备的请求队列，*决定队列中的请求的排列顺序以及什么时候派发请求到设备*。

由通用块层(Generic Block
Layer)负责维持一个I/O请求在上层文件系统与底层物理磁盘之间的关系。在通用块层中，*通常用一个bio结构体来对应一个I/O请求*。

Linux提供了一个*gendisk数据结构体*，用来表示一个独立的磁盘设备或分区，用于对底层物理磁盘进行访问。在gendisk中有一个类似字符设备中file_operations的硬件操作结构指针，是*block_device_operations结构体*。

当多个请求提交给块设备时，执行效率依赖于请求的顺序。如果所有的请求是同一个方向（如：写数据），执行效率是最大的。内核在调用块设备驱动程序例程处理请求之前，先收集I/O请求并将请求排序，然后，*将连续扇区操作的多个请求进行合并以提高执行效率（内核算法会自己做，不用你管）*，对I/O请求排序的算法称为*电梯算法*（elevator
algorithm）。电梯算法在I/O调度层完成。内核提供了不同类型的电梯算法，电梯算法有

1 noop（实现简单的FIFO，基本的直接合并与排序）,
 2 anticipatory（延迟I/O请求，进行临界区的优化排序），
 3 Deadline（针对anticipatory缺点进行改善，降低延迟时间）,
 4 Cfq（均匀分配I/O带宽，公平机制）

PS：其实IO调度层（包括请求合并排序算法）是不需要用户管的，内核已经做好

*相关数据结构*

block_device:  描述一个分区或整个磁盘对内核的一个块设备实例
 gendisk:   描述一个通用硬盘（generic hard disk）对象。
 hd_struct:  描述分区应有的分区信息
 bio:
描述块数据传送时怎样完成填充或读取块给driver
 request:  描述向内核请求一个列表准备做队列处理。
 request_queue:  描述内核申请request资源建立请求链表并填写BIO形成队列。


** 百度云浏览PDF

使用网页版百度云浏览PDF效果挺不错的。

** org-mode evernote

- why
  - 使用org-mode记笔记绝对要比evernote的编辑方便得多
  - org-mode支持babel、LaTeX等
  - 使用evernote阅读与同步则要比emacs友好得多
  - 顺便解决了本地HTML保存到EVERNOTE的问题
- how
  - org-mode记笔记
  - 使用org-ehtml和emacs-web-server，在浏览器端打开org文件
  - 使用悦读保存到Evernote中，不要使用剪藏，效果不好
- problems
  - 访问太慢，不知为何
  - 不支持图片


** 12个小技巧帮你快速整理你的书桌

这里有12个小技巧帮你快速整理你的书桌。这些技巧对于博华来说非常管用，它
们使我的书桌整齐有序，不仅让人看起来赏心悦目，而且另一方面也提高了我的
学习效率。我相信，大多数技巧对你也会有帮助的。如果你也有好的建议也可以
在评论里写下来让我补充完善这篇文章。


拿走你不用的钢笔和铅笔

博华一般写字只用一种钢笔，但是每个月我都会发现我的笔袋里被塞满了各种各
样的笔（油笔、钢笔、记号笔、铅笔、自动铅笔、中性笔……）其中有很多都重
复了。如果你不准备用它们，那么就把它们清理出来，不要难以割舍，只留下有
用的，这样可以使你的效率更高。


找一个地方放你的零碎物品

你的钥匙、手机、PDA、钱包、蓝牙耳机等等，是不是因该有个家呢？最好的方
式就是找一个专门的抽屉放它们，这样你就不会因为找不到东西而浪费时间了。
但是，如果你的书桌没有抽屉，那么为什么不找一个纸盒呢？纸盒上写上“小零
件的家”，这样不是既温馨又方便么？


按使用频率来整理书桌

如果你经常使用某个东西，那么这个东西肯定放在离你很近的地方，比那些你一
周只用一两次的东西要更容易拿到。这是个共识，但是按美观来整理书桌却比按
使用性更容易操作，两者皆可，随你喜好。


让电子产品离开你的视野

你的路由器、电源、充电器等等是不应该摆在桌上的。即使你的桌子足够大，博
华也不建议你这样做。因为那些交错纵横的电线会让你的心情变得不好，快点把
他们搬到桌子下面吧。


把文件放到伸手可及的地方

不移动椅子或者起身，你就可以取到需要的文件，最好给文件贴上标签，并把它
们放到文件柜里。这样你就不会为寻找一个急用的文件而在一堆资料里翻找半天
了。建议每周都整理一下你的文件柜，使它们整齐有序。


扫描文档

这个是我正在实验中的做法。当我的学习资料太多时，我会为一时找不到我需要
的东西而发愁。于是，我把它们用扫描仪（正好我家HP打印机带这个功能）扫描
下来存成PDF格式。并且我用OCR标识，这样搜索我需要的东西变得简单易行。这
个方法对于那些经常旅行携带大量资料的人特别有用。但问题是要找出什么资料
需要扫描，如果你对于自己的需要很了解，那么可以试试这个方法。


必要的清洁工具

如果你用纸巾来擦桌面，那么最好桌上摆放一盒抽纸。这样不仅可以鼓励你及时
擦桌子而且可以帮助你应付突发事件，如咖啡洒了。这样做的目的就是让你有一
个舒心的工作学习环境，提高效率。

备一个草稿本

在一天的工作当中，你将会有电话号码、名字、地址、任务等信息需要及时记录。
如果你把它们都记在一处，那么当你需要查阅它们时会变得很方便。


整理那些电线

我们的桌子经常被各种电线所占据。USB数据线、MP3充电器线、手机线、网线、
音箱线、电话线、鼠标线、键盘线……当它们缠到一块，想想都头大。你可以用
细线将过长的电线都绑到一块，将不用的线整理到抽屉里等等。如果条件允许的
话，换一个无线路由器也是个不错的选择。


如果你的抽屉不够用

你可以买一个储物柜来放东西。也可以用纸箱，如牛奶箱，博华的书桌下面就摆
放着两个用过的蒙牛牛奶箱，里面放着我的书和杂物，为我节约了不少空间。当
然，这仅限于放一些无关紧要的东西，若是贵重物品还是放到抽屉里比较安全。


充足的光线

要确保你的书桌有充足的光线。这样不仅对你的眼睛有好处，也易于发现和清理
看不见的灰尘，保持学习环境的清洁。


离开时记得整理书桌

当你完成了一天的工作时，把你杂乱的书桌收拾一下。这样不仅让别人看到你的
好习惯，也使你第二天的工作学习更加充满激情。


** 练习记忆的小习惯

1 、每当桌上满是食物的时候，就闭着眼睛吃饭。

2 、经常用手指分辨硬币（或象棋子也不错）。

3 、戴上耳机上下楼梯。

4 、放开嗓子大声朗读。

5 、到餐馆点没吃过的菜。

6 、左手端茶杯。

7 、听不同类型的歌。

8 、每天 23 ： 00前睡觉， 5 ：00 起床。（太残酷了，但可以很好的把早晨的时间利用起来）


10 、每天吃点甜食（这个最喜欢）。

11 、吃早餐。

12 、多咀嚼。

13 、每天快走20 分钟。

14 、一天十次“ 手指操 ”。

15 、每季度学一项新运动。

16 、记录成功的事。

17 、每天出门前对着镜子里的自己微笑并说：我肯定能行。

18 、写 100 个自己喜欢的东西，每天拿出来看看。

19 、站在对方的立场看问题。

20 、每周给自己半小时的无聊时间。

21 、每周看一到二次自己没不看的节目。


23 、每天找个时间专门背一些东西。

** 生活技巧

1.吃了辣的东西，感觉就要被辣死了，就往嘴里放上少许盐，含一下，漱下口，就不辣了；
 2.牙齿黄，可以把花生嚼碎后含在嘴里，并刷牙三分钟，很有效；
 3.若有小面积皮肤损伤或者烧伤、烫伤，抹上少许牙膏，可立即止血止痛；
 4.经常装茶的杯子里面留下难看的茶渍，用牙膏洗之，非常干净；
 5.仰头点眼药水时微微张嘴，这样眼睛就不会乱眨了；
 6.嘴里有溃疡，就用维生素 C贴在溃疡处，等它溶化后溃疡基本就好了；
 7.眼睛进了小灰尘，闭上眼睛用力咳嗽几下，灰尘就会自己出来；
 8.洗完脸后，用手指沾些细盐在鼻头两侧轻轻按摩，然后再用清水冲洗，黑头和粉刺就会清除干净，毛细孔也会变小；
 9.刚刚被蚊子咬完时，涂上肥皂就不会痒了；
 10.如果嗓子、牙龈发炎了，在晚上把西瓜切成小块，沾着盐吃，记得一定要是晚上，当时症状就会减轻，第二天就好了；
 11.吹风机对着标签吹，等吹到商标的胶热了，就可以很容易的把标签撕下来；
 12.旅行带衣服时如果怕压起褶皱，可以把每件衣服都卷成卷；
 13.打打嗝时就喝点醋，立杆见影；
 14.吃了有异味的东西，如大蒜、臭豆腐，吃几颗花生米就好了；
 15.治疗咳嗽，特别是干咳，晚上睡觉前，用纯芝麻香油煎鸡蛋，油放稍多些，什么调味料都不要放，趁热吃过就去睡觉，连吃几天效果很明显；
 16.手腕长粗的MM想带较细的手镯，就不能硬带，应把手上套上一个塑料袋再带上手镯，非常好带，也不会把手弄疼，取下也是同样的方法；
 17.栗子皮难剥，先把外壳剥掉，再把它放进微波炉转一下，拿出后趁热一搓，皮就掉了；
 18.插花时，在水里滴上一滴洗洁精，可以维持好几天；
 19.把核桃放进锅里蒸十分钟，取出放在凉水里再砸开，就能取出完整的桃核仁了；
 20.把虾仁放进碗里，加一点精盐、食用碱粉，用手抓搓一会儿后用清水浸泡，然后再用清水冲洗，即能使炒出的虾仁透明如水晶，爽嫩可口；
 21.炒肉时，先把肉用小苏打水浸泡十几分钟，倒掉水，再入味，炒出来会很嫩滑；
 22.将残茶叶浸入水中数天后，浇在植物根部，可促进植物生长；
 23.把残茶叶晒干，放到厕所或者沟渠里燃熏，可消除恶臭，具有驱除蚊子苍蝇的功能；
 24.夹生饭重煮法：可用筷子在饭内扎些直通锅底的孔，洒入少许黄酒重焖；
 25.若只表面夹生，只要将表层翻到中间再焖即可；
 26.巧除纱窗油腻：将洗衣服、吸烟剩下的烟头一起放在水里，待溶解后，拿来擦玻璃窗、纱窗，效果真不错；
 27.只要在珠宝盒中放上一节小小的粉笔，即可让首饰常保光泽；
 28.桌子、瓶子表面的不干胶痕迹用风油精可以擦拭；
 29.出门时随时在包里带一节小的干电池，若裙子带静电，就把电池的正极在裙子上面擦几下即可去掉静电；
 30.不管是鞋子的哪个地方磨到了你的脚，你就在鞋子磨脚的地方涂一点点白酒，保证就不磨脚了；
 31.亨调蔬菜时，如果必须要焯，焯好菜的水最好尽量利用。如做水饺的菜，焯好的水可适量放在肉馅里，这样既保证营养，又使水饺馅味美有汤；
 32.夏天足部容易出汗，每天用淡盐水泡脚可有效应对汗脚；
 33.夏天游泳后晒晒太阳，可防肌肤劳损等疾病发生；
 34.夏天枕头易受潮滋生霉菌，时常曝晒枕芯有利健康；
 35.多吃薏米小豆粥等潮湿健脾，可防暑湿；
 36.防失眠：睡前少讲太多话，忌饮浓茶，睡前勿大用脑，可用热水加醋洗脚；
 37.金银花有疏散风湿功效，金银花水煎取汁凉后与蜂蜜冲调可解暑；
 38.吃过于肥腻的食物后喝茶，能刺激自律神经，促进脂肪代谢；
 39.睡眠不足会变笨，一天需要睡眠八小时，有午睡习惯可延缓衰老；
 40.双手易变得干燥粗糙，用醋泡手十分钟可护肤；
 41.夏天擦拭凉席，用滴加了花露水的清水擦拭凉席，可使凉席保持清爽洁净。当然，擦拭时最好沿着凉席纹路进行，以便花露水渗透到凉席的纹路缝隙，这样清凉舒适的感觉会更持久；
 42.早餐多食西红柿、柠檬酸等酸性蔬菜和水果，有益于养肝；
 43.爽身止痒洗头或洗澡时，在水中加五六滴花露水，能起到很好的清凉除菌、祛痱止痒作用；
 44.葡萄含有睡眠辅助激素，常食有助睡眠；
 45.夏天多喝番茄汤既可获得养料，又能补充水分，番茄汤应烧好并冷却后再喝，所含番茄红素有一定的抗前列腺癌和保护心肌的功效，最适合于男子；吃酸性物质马上刷牙会损害牙齿健康；
 46.因外伤碰破皮肉时，在伤处涂上牙膏进行消炎、止血，再包扎，作为临时急救药，以药物牙膏效果最为显著；
 47.将白醋喷洒在菜板上，放上半小时后再洗，不但能杀菌，还能除味；
 48.喝酸奶能解酒后烦躁，酸奶能保护胃黏膜、延缓酒精吸收，并且含钙丰富，对缓解酒后烦躁尤其有效；
 49.皮鞋包皮放久了发霉时，可用软布蘸酒精加水（ 1：1 ）溶液擦拭即可；
 50.发生头痛、头晕时，可在太阳穴涂上牙膏，因为牙膏含有薄荷脑、丁香油可镇痛；
 51.蜡烛冷冻二十四小时后，再插到生日蛋糕上，点燃时不会流下烛油；
 52.白色衣裤洗后易泛黄，可取一盆清水，滴上二三滴蓝墨水，将洗过的衣裤在浸泡一刻钟，不必拧干，就放在太阳下晒，即可洁白干净；
 53.过多食用生葱蒜会刺激口腔肠胃， 不利健康，最好加一点醋再食用；
 54.及时补充水分但应少喝果汁、可乐、雪碧、汽水等饮料，含有较多的糖精和电解质，喝多了会对肠胃产生不良刺激，影响消化和食欲。因此夏天应多喝白开水或淡盐（糖）水；
 55.每天早晨用豆腐摩擦面部几分钟，坚持一个月，面部会变得很滋润；
 56.空调室内温差不宜超过五度，即使天气再热，空调室内温度也不宜到 24度以下；
 57.加酶洗衣粉剂放在温水中需要较长的分解时间才能使洗衣效果更佳；
 58.夏天，人的活动时间变长，出汗多，耗能过大，应适当多吃鸡、鸭、瘦肉、鱼类、蛋类等营养食品，以满足人体的代谢需要；
 59.头痛时把苹果磨成泥状涂在纱布上，贴在头痛处，症状可减轻；
 60.皮包上有污渍，可以用棉花蘸风油精擦拭。

** 听过很多道理,依旧过不好一生

- 世界上只有一种真正的英雄主义，那就是认清生活的真相后依然热爱生活。

- Work hard in silence. Let your success be your noise.

- Tomorrow is another day.

- 其实这个世界上的大部分传奇，不过是普普通通的人们将心意化成了行动，坚
  持至极致而已。

- 也许，在所有不被看好，无人尝试的错误的选择背后，会有不曾见到的可能，
  不曾设计的未知。未知让人恐惧，引人好奇，也因此证明你的勇气，成就你的
  自信。在每个死胡同的尽头，都有另一个维度的天空，在无路可走时迫使你腾
  空而起，那就是奇迹。——廖一梅《像我这样笨拙地生活》

- 宝剑锋从磨砺出，梅花香自苦寒来。

- 做你想做的，坚持下去，那就是你的未来。

- 永远年轻，永远热泪盈眶。

- 每次想到在有限的生命里，竟要被那些傻逼的人和事所束缚，便会油然而生一
  种没来由的斗志，书剑满血复活。 马良《坦白书》

-  你配得上你想要的生活么？

- 感觉快乐，就要忙东忙西；感觉累了，就放空自己。

- 有些东西根本无法抗拒，比如孤独，比如回忆，比如爱上你。

- 生活太残酷了，如果我们不相信爱，还能为什么而活呢？

- 生活不是用来妥协的，你退缩得越多，让你喘息的空间就越有限；日子不是用
  来将就的，你表现得越卑微，一些幸福的东西就会离你越远。在有些事情中，
  无须把自己摆得太低，属于自己的，都要积极争取；在有些人前，不必一而再
  德容忍，不能让别人践踏你的底线。只有挺直了腰板，世界给你的回馈才会多
  点。

- 今天很残酷，明天更残酷，后天很美好。但是大多数人都死在明天的晚上，看
  不到后天的太阳。 马云

- Stay hungry. Stay foolish.

- 坚持下去，并不是我们真正的足够坚强，而是我们别无选择。并不是我们喜欢
  一件事情就可以把它做好，而是我们在做的时候，学会喜欢它。我没有别的，
  只有热血，眼泪和汗水可以奉献。这些都是我最宝贵的财富。请记住：永远不
  要放弃你自己。 丘吉尔

- 你必须非常努力，才能看起来毫不费力。

- 一切不能毁灭你的，都是你变得更强大。

- 人丑就该多读书。

- 比起害怕挑战失败，更可怕的是你什么都不做。

- 走自己的路，让别人去说吧。

- 越努力，越幸运。页精于勤荒于嬉，行成于思毁于随。 韩愈

- 你永远比你想象的要强大。

- Go home or stand up. It's your fucking choice.

- Pain is inevitable. Suffering is optional.

- 每天清晨起床走到镜子面前对自己说：今天将是你余生中最年轻的一天，你没
  有理由不全力以赴。

- 人如果没有梦想，那跟咸鱼有什么分别？

- 梦想一定要有的，万一实现了呢？

- 把人们引向艺术和科学的最强烈的动机之一，就是要逃避日常生活中令人厌恶
  的粗俗和使人绝望的沉闷，是要摆脱人们反复无常的欲望的桎梏。一个修养有
  素的人总是渴望逃避个人生活而进入客观知觉和思维的世界；这种愿望好比城
  市里的人渴望逃避喧嚣拥挤的环境，而到高山去享受幽静的生活，在那里透过
  清寂而纯洁的空气，可以自由地眺望，陶醉于似乎是为永恒而设计的宁静景色。
  叔本华

- 自己选择的路，跪着也要走完；宁愿笑着流泪，也不哭着说后悔。

- 每个人走的路，都是自己选的。

- 你不努力，谁也给不了你想要的生活。

- 糖，是熬出来的。

- 不要让未来的你，讨厌现在的自己。

- 人生没有太晚的开始。

- 怎能将这个世界，让给那些你所鄙夷的人！

- 你值得拥有最好的一切。

- Your future is created by what you do today not tomorrow.

- when you reach for the stars you may not quite get one, but you
  won't come up with a handful of mud either. Leo Burnett

- Yesterday is history. Tomorrow is a mystery. Today is a gift. That's
  why it's called present.

- 父母年纪大了。

- 以大多人的努力程度之低，根本轮不上拼天赋。

- 如果你的前面有阴影，你的背后一定有亮光。

- 守之甚严，而持之有恒者！

- 不负光阴不负心。

- 不忘初心，方得始终。

- 天助自助者。

- tried. Ever failed. No matter. Try again. Fail again. Fail better.

- 你没有变强，是因为你一直很舒服。

- 逆风的方向，更适合飞翔。我不怕千万人阻挡，只怕自己投降。 五月天《倔
  强》

- Live as if you were to die tomorrow. Learn as if you were to live
  forever.

- 你所浪费的今天，是所有昨天所有死去的人所期待的明天。

- Be the changes you want to see in the world. 圣雄甘地

- 时间就像海绵里的水，只要愿挤，总还是有的。

- 人生最大的是失败，就是放弃。

- 最遗憾的不是失败，而是，我本可以。

- Everything will be OK.

- 不求思想上的纯粹，只求行动上的坚决。

- A man is not old until regrets take place of dreams.

- 你所负担的将变成礼物。你所受的苦将照亮你的路。 泰戈尔

- 将来的你，一定会感激现在努力的自己。

- Tomorrow the birds will sing.

- 一个人活的应该是自己，并且干净。

- 不论你在什么时候开始，重要的是开始之后就不要停止。

- 你总是喜欢把事情拖到第二天，你不能总是这么拖了。有一天，你会有很多事
  情要做，你的余生都不够用了。

- 如果看不清自己，就看看身边的人。你只是你周围的事物。

- You have to kill those excuses, or they will kill you.

- 那些与你毫无关系的人，就是毫无关系的，永远是毫无关系的。从认识的第一
  天开始，其实你就知道。就算是笑得甜甜蜜蜜，就算是有过无关痒痛的来往，
  就算你努力经营这段关系。而那些与你有关的，就是与你有关的，是逃也逃不
  掉的，就算你们只见过三次，就算你们三年彼此才搭理一次，就算是你简直想
  不起他或者她的样子，就算是你们隔着十万八千里。from《送你一颗子弹》

- 每个人在他的人生发轫之初，总有一段时光，没有什么可留恋，只有抑制不住
  的梦想，没有什么可凭仗，只有他的好身体，没有地方可去，只想到处流浪。
  by E·B·怀特

- 仰望星空时，我们知道这些星星距离我们成百上千光年，有些甚至已经不存在
  了。它们的光花了很长很长时间才到达地球，而在此期间，他们本身已经消失
  或爆炸瓦解成红矮星了。这些事实会让人觉得自己很渺小，如果生活中遇到了
  困难，不妨想想这些，你就会明白什么叫微不足道。 by 马克·哈登

- 每个优秀的人都有一段沉默的时光。那一段时光是付出了很多努力，忍受孤独
  和寂寞，不抱怨不诉苦，日后说起时，连自己都能被感动的日子。from《关于
  这个世界，你不快乐什么》

- 如果没有那么多的感动，那么多的痛苦，在狂喜和绝望的两极来来回回，活着
  还有什么意思呢？from 《恋爱的犀牛》

- 做自己就好，爱情的真谛在于相互的吸引,志趣相投的同行，而不是追逐和依
  附。

- 上士闻道，勤而行之；中士闻道，若存若亡；下士闻道，大笑之，不笑不足以
  为道。

- Don't You Cry, Babe. Tears Are Made For Non-Ugly People.

- 我们无法选择自己的缺点，它们也是我们的一部分，我们必须去适应它们。

- 少说话多做事。我认为我是个好家伙。

- 在完全了解一件事物之前，你并不拥有否定它的资格，对人亦是如此。

- Loser always whine their best.

- 让你难过 的事情，总有一天你会笑着说出来。

- 人要有信仰。

- 安慰捉襟见肘，唯有冷暖自知。

- 此心拖泥带水是人生最苦处。

- 继续向前买进吧。你不是有健全的双脚么，不需要依靠任何东西。

- 我们早就过了向往轰轰烈烈爱情的年纪。

- Look! If you had one shot, one opportunity, to seize everything you
  ever wanted one moment. Would you apture it, or just let it slip?

- 你非常年轻的时候，最敏感最细腻最有激情的时候一定要背起包，睁眼看一看
  外面的世界，看看朝阳如何从海面上升起，看看满天神佛的寺庙日落的样子，
  看看外国的月亮有没有更圆一点，打开自己的心灵，前往世界的另一边，尝试
  一下有时差的生活，看看不同文化不同生活背景的其他人的生活。

- 不管未来平坦还是泥泞，只要热爱生命，一切都在预料之中。

-  Follow Excellence. Success will chase you.

- I have a dream.

- 前方是绝路，希望在转角。

- 尽人事而后听天命，人自助则天助。

- 有时不吃些苦头，就看不清真相。

- 事情永远都只会想着阻力最小的方向发展，而不会向着最有效率的方向变化。

- 人们只会相信他们愿意相信的东西而不是真相。

- 我不相信奇迹，我相信事在人为。

- 尽人事，听天命。

- 命里有时终须有，命里无时莫强求。

- Don't let your dreams be dreams.

- 胜，不妄喜；败，不逞馁。胸有激雷而面如平湖者，可拜上将军！

- 不论你对此生的决定如何，一定要真诚地对待自己。

- 得知我幸，失之我命。

- 一个男人不成熟的标志是他愿意为了某种事业 英勇地死去，一个成熟男人的
  标志是他愿意为某种事业卑贱地活着。

- 那些爱过我们和伤害过我们的人都是我们青春存在的意义。

- 不用正确地做事，只须做正确的事。

- If you never try you'll never konw.

- 人之所以痛苦，在于追求错误的东西。如果不给自己烦恼，别人永远不可能给
  你烦恼，因为你的内心，你放不下。

- The best is yet to come.

- 每一天都要全力以赴。

- 无论现在是风光还是落魄，都需要明辨哪些才是真正属于自己，而不是他人给
  予或环境造就。浮华终究过去，唯有内心的坚定和丰富才是真的自己。

- 无论今天发生了什么，明天的我一定要比今天的我更加美好。

- Life is like a box fo chocolate, you never know what you're gonna
  get.

- 生命中那些最深刻的体验必定也是最无奈的。

- 今日是你余生的第一天。

- 黑夜给了我黑色的眼睛，我却用它来寻找光明。

- 有一种鸟是永远也管不住的，因为它的每片羽翼上都沾满了自由的光辉。

- 悲伤尽情地来吧，但要尽快过去。

- Remember, hope is a good thing, maybe the best of things and no good
  things ever dies.

- 做一个现实的理想主义者。

- What I do that defines me.

- 人只能活一次。

- 人一切的痛苦，本质上都是对自己无能的愤怒。

- 要上进。

- 只要努力活下去，一定会有好事情发生。

- 我的未来，敬请期待。

- 文思泉涌的人往往性格安静

- 问题在于问题本身。

- 生命在于担当。

- 存在即是合理的，很多你不知道，并不代表不存在。

- 其实我早就下决心做个异类/只是不想同流合污。

- 仗义每是屠狗辈，负心必是读书人。

- 不要让年华老去的时候鄙视自己。

- 你若盛开，清风自来。

-  To handle yourself, use your mind. To handle others, use your
  heart.

-  用脑对待自己，用心对待他人。

- 似水流年才是一个人的一切，其他的部分都是片刻的欢愉和不幸。

- 越努力，越幸运。

- 只有你愿意为之而死的东西，你才能够藉之而生。

- 永远年轻，永远热泪盈眶。

- Without pain, withour sacrifice, you would have nothing.

- 决定我们成为什么样的人的，不是我们的能力，而是我们的选择。

- 做最好的自己，无论何时。

- 想触及天空的人，必先学会享受孤独。

- 阳光从未走远。

- 美色当前 忠义让步

- 你们最犀利的武器就是勇气。

- 我们坚信，仍然有人为理想活着。

- 己所不欲 勿施于人

- 内心单纯而善良的人前途无可限量

- 卑鄙是卑鄙者的通行证 高尚是高尚者的墓志铭

- 不必仰望他人，自己亦是风景。

- 如果你醒着，你就当醒着。如果你睡着，你就当睡着。如果你在做一件事情，
  就不该再考虑其他事。如果你的手在这里，你的思想同时也因应该在这里。如
  果开始行动，就不要迟疑，在一些问题成为你的负担并使你生病之前，就解决
  掉它们。

- 情不寿，强极则辱。谦谦君子，温润如玉

- 欲速则不达。

- 只要一直努力，终有一日会得到回报；只要坚持下去，梦想就会成真。这是幻
  想。多数情况下，努力得不到回报；多数情况下，正义不会取得胜利；多数情
  况下，梦想不会成真。在现实世界中，这些是常有的事。可是，这又怎样？起
  点就在那里。技术开发可能有99%的可能失败。只要尝试新东西，就一定会摔
  跟头。很恼火，所以便连睡觉和吃饭的时间都不放过，反复去做。来吧，超越
  昨天的自己。怎么可能认输呢！

- 你永远无法叫醒一个装睡的人。

- 羡慕别人，不如自己去争取。

- 不要让未来的烦恼来影响现在享受生活的心情。

- 我是要成为海贼王的男人。

- 宁鸣而死，不默而生。

- 任何值得做的事情，都值得做好。

- 时间自有公道 付出总有回报 说到不如做到 要做就做更好

- 我不去想是否能够成功，既然选择了远方，便只顾风雨兼程。

- 永远不要皱眉，因为你不知道谁会爱上你的笑容。

- 勇敢的人会有特别的明天。

- 学会感恩，慢慢成长。

- 有些事情你现在不做 一辈子都不会做了。

- 如果你有梦想的话，就要去努力实现。

- 知识不会让我们觉得低人一等。

- 每一个不曾起舞的日子，都是对生命的辜负。

- 生活不是眼前的苟且，生活有诗和远方。

- 人生不如意事常八九，可于人言无三二。

- I am a slow walker, but I never walk backwards.

- 只有自己修炼好了，才会有人来亲附。这叫“近者悦，远者来”。自己是梧桐，
  凤凰才会来栖；自己是大海，白川才会来归。你只有到了那个层次，才会有相
  应的圈子，而不是倒过来。

- 越是接近梦想的道路越是艰辛，于是成功的终点便成为一种坚持。当世界有识
  之士把成功的条件精辟地归纳为两个字——坚持，我就意识到这两个字的分量。
  因为坚持的过程中，满是忍耐。

- 现在做的事是你必须要做的事，以后做的事才是你喜欢做的事。

- Tomorrow is another day. The best is yet to come.

- 一个人的性格决定他的际遇。如果你喜欢保持自己的性格，那么，你就无权拒
  绝你的际遇。

- 不要因路远而踌躇，只要去，就比到达。

- 故天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行
  拂乱其所为，所以动心忍行，增益其所不能。

- 只要有时间，什么都会有的。

- 不是对手太强了，只是我还不够努力。

- 这是你的十字架，你要背负得起。

- 永远不要为还没有发生的事担忧和害怕。

- 心之何如，有似万丈迷津，遥亘千里，其中无舟子以渡人，除了自渡，他人爱
  莫能助。 三毛

- 人不可有傲气，但不可无骨气。

- 量的积累，产生质的飞跃/

- 胸无城府人如玉，腹有诗书气自华。

- 有些人懒散惯了，到关头连装都不会装了。要知道，优秀是一种习惯。

- 鸡蛋，从外打破是食物，从内打破是生命。人生亦不过如此。从外打破是压力，
  从内打破是成长。如果你等待别人从外打破你，那么你注定是别人的食物；如
  果能让自己从内打破，那么你就会发现自己的成长相当于一种重生。

- 不管怎样，未来都是可以改变的。

- 只要用力呼吸，就会看到奇迹。

- 你遇见什么事想不通的时候，是你在博弈的这个过程中，距离棋盘太近了。

- 不论发生什么事...我都会如今天这样怀抱着不安向前。心中怀疑这些不安是
  否明天就会消失...可是，如果真的消失了，不就正好说明昨天的日记已经终
  结了过去。

- 你的负担将变成礼物，你受的苦将照亮你的路。

- The world has kissed my soul with its pain, asking for its return in
  songs.

- 你不努力，连自己都看不起自己。

- 梦想是名词，要想办法将它变成动词。

- 只要开始，任何时候都不晚。

- 少问别人为什么，多问自己凭什么。

- 狭路相逢勇者胜。

- Life is short. Make everyday count.

- 看着街上为了生活而不停忙碌的人，突然觉得自己活得毫不要脸。

- 凡是尽力，成败坦然。

- 呐，做人呢最要紧的是开心。

- 对于一个人自身的存在，何者是有意义的，他自己并不知晓，并且，这一点肯
  定也不应该打扰其他人。一条鱼能对它终生畅游其中的水知道些什么？苦难也
  罢，甜蜜也罢，都是来自外界，而坚毅却来自内部，来自一个人自身的努力。

- 我们能做的不是去要求别人的品质没有瑕疵，而是我们自己如何磨练自己，变
  得更加坚强。

- 请相信失约而至的爱情必不枉等待的时光搭建更丰富的世界，成为更有趣的人，
  我鲜衣怒马，总就高歌，走向你

- Everything will be okay in the end. If it's not okay, it's not the
  end.

- 永不期待，永不假设，永不强求。顺其自然，若是注定发生，必会如你所愿。

- 只要心向往，无处不天堂。

- 每逢你要想批评任何人的时候，你就记住，这个世界上所有的人，并不是个个
  都有过你拥有的那些优越条件。

- 凡是不能杀死我的，必将使我更强。

- 神只给我们可以跨越的考验。

- 文青，去掉了实践，就是个贬义词。

- 谁能任性不认命。

- 让我们面对现实，让我们忠于理想。

- 行动起来吧，不狠狠把自己逼一把，不会知道自己有多么优秀的。

- 想做一件事情必能找到一个方法，不想做一件事情必能找到一个借口。

- 承认你的欲望。

- 失败只有一种，那就是半途而废。

- 生活总是让我们遍体鳞伤，但是到后来，那些受伤的地方一定会变成我们最强
  壮的地方。

- 活在当下。Ｂe here now.

- 我们可以一次一次地去撞南墙，我们不能一个一个失去理想。

- 没有一种教育，比得上逆境。

- 无论做什么，记得为自己而做，那就毫无怨言。

- 还没有衣不蔽体食不裹腹举目无亲，我们没有资格难过，我们还能把快乐写得
  源远流长。

- 怕什么呢，你还年轻不是么？

- 懒惰是很奇怪的东西，它使你以为那是安逸，是休息，是福气；但实际上它所
  给你的是无聊，是倦怠，是消沉；它剥夺你对前途的希望，割断你与别人的友
  情，使你心心胸日渐狭窄，对人生也越来越怀疑。

- 人要耐得住寂寞，才能守得住繁华。

- 一个人生命中的得与失，总是守衡的。人生，由我不由天；幸福，由心不由境。

- 一个人可以轻易地学会不在乎，但学习在乎却要付出百倍的努力和勇气。

- 人生总是这样，你想要的东西要到你不再指望的那一刻，才姗姗来迟。

- 不重蹈覆辙，才是真正的醒悟。

- 你所站的地方 正是你的中国 你怎么样 中国便怎么样 你是什么 中国便是什
  么 你有光明 中国便不黑暗。

- 敢想不敢为者，终困牢笼。

- 有三种情感，单纯而强烈，支配着我的人生：对爱情的渴望，对知识的追求，
  以及对人类不可遏制的同情心。

- 花有重开日，人无再少年。

- 没有那么多人看你，不要活得那么累。

- 我不担心我努力了不优秀，只担心优秀的人比我更努力。如果你无法忍受孤独，
  那就不要追逐梦想，每一个优秀的人，都有一段沉默的时光。

- 阳光下像个孩子，风雨中像个大人。

- 好的爱情使你通过一个人看到整个世界，坏的爱情使你为了一个人舍弃世

- 如果你不真不对自己恶习下手，不忏悔业障反思己过，持戒实行，逐步放下你
  执着的东西...

- 真正的勇士敢于正视淋漓的鲜血。

- 生活催人熟，速度远比你想象的要快。

- 有些事你做了，或许会后悔一阵子；有些事你不做，或许会后悔一辈子。

- 我喜欢你，但不爱你。

- 自由之思想，独立之精神。

- 你比想象中的要强大。

- 当你成功的欲望足以与对呼吸的欲望相媲美的时候，你就会成功。

- 与其祈求生活平淡点，还不如祈求自己强大点。

- 我要强大到任何事物都无法破坏我内心的平和。

- 一句“拿着”胜过十句“我会给你的”

- 一个人不会永远心想事成，但你若是勇于尝试，你也许会得到自己想要的一切。

- 知道什么叫失败么？ 真正失败的人，就是那种特别害怕不能成功，怕死了，
  连试都不敢试的人。

- 世间有很多东西令我觉得很无趣。我便不会在意它们的发生和发展，我懂得人
  总要有所为有所不为。

- Ｄon't panic.

- 我和我骄傲的倔强 我在风中大声地唱 下一站是不是天堂 就算失望不能绝望

- 仗剑之人比死于剑下。

- 容忍比自由更重要。

- 现在的我明白，只要有相见的人，就不是孤身一人了。

- 无人理睬时坚定执着，万人艳羡时心如止水。

- 无论黑夜多么漫长难熬，黎明始终会如约而至。 没有到不了的明天。

- 如果你痛恨所处的黑暗，请成为你想要的光明。

- 如果你看到前面的阴影，别怕，那是因为你的背后有阳光。

- 于是我决定，不再呼唤无法回应我的人。

- Ｈas anything you've done made your life better?

- 人生就像是一座钟摆，从右摆到左，从痛苦摆到苦闷。

- 生活不可能像你想象的那么好，但也不会像你想像得那么糟，我觉得人的脆弱
  和坚强都超乎自己的想象。有时，我可能脆弱得一句话就泪流满面，有时，我
  也发现自己咬着牙走了很长的路。

- 因为害怕结果就什么都不做么？

- 以大多数人的努力程度之低，根本轮不上去拼天赋。

- Life is short. No procrastination.

- 只要你要只要我有。

- 即使现在形单影只，明日依旧满怀希望。

- 温柔要有，但不是妥协，我们要在安静中，不慌不忙地坚强。

- 你所经历的一切，都是你自己造就的。

- If there is light in everybody, so send out your ray of sunshine.

- 机会永远降临在有准备的人身上。

- 归根结底，只要想着做一切事到最后的受益者都是自己，我们就不会抱怨太多。

- 嗯，加油，要做一个让未来的自己感动到要哭的人。

- Ｈappiness is only real when shared.

- Keep moving forward.

- You got a dream, you gotta protect it. Ｐeople can't do something
  themselves, they wanna tell you you can't do it. If you want
  something, go get it.

- 生活再苦再累，请在心里对自己说：给老子笑。

- 当你太在意别人的眼光，你永远做不了自己。

- Sky is your limit.

- 我就是我 是颜色不一样的烟火 天空开阔 要做最坚强的泡沫 我喜欢我 让蔷
  薇开出一种结果 孤独的沙漠里 一样盛开得赤裸裸

- 能不能暂时把你的勇气给我 在梦想快消失的时候 让我的歌 用力地穿过天空
  为我爱的人 做一秒英雄

- 成功只有一个——按照自己的方式，去度过人生。

- 为什么要登山——因为山就在那里

- 总有一个合适的人在未来与我相遇 而我所能做的就是使自己更好 更足够配得
  上她 而在这之中 我会遇到很多人 或许她们会有她们的轨迹 而这些轨迹只是
  恰好与我有一小段在一起 这也没关系 我只需要做好自己能做的一切就行 夕
  阳也有自己的轨迹 但当它谢幕前 它染红了云彩 没有人知道自己走的路对不
  对 我能做的只有把手头的事情做到最好 对未来充满希望热爱现在的生活 我
  得到的都是侥幸啊 我失去的都是人生 失去的当作礼物眼下的就是幸福

- 追寻心中所想 永远都不会太晚

- 顺其自然 不乱于心

- Yesterday you said tomorrow.

- 弱小即是罪孽。

- 冬天里吃冰淇淋也别有风味。

- 做人如果没有梦想，跟咸鱼有什么区别。

- Ｈold On Pain End —— hope

- 最小的善行胜过最大的善念

- 保持自我比你整天装逼活得更愉快。

- 面对就会简单 奋斗带来自由

- 我不怕千万人阻挡 只怕自己投降

- 灾难总会接踵而至 这是世间的常理。

- 让我做个行动上的流氓思想上的文青吧

- 一旦放弃的话比赛就结束了。

- 我可以失败，但我绝不放弃。

- 要抱怨的话，先努力完了再说。

- 总是说明天再做的人是蠢蛋，老想着还有明天，会吃到苦头的。

- 如果有一天我们湮没在人潮之中，庸碌一生，那是因为我们没有努力活得丰盛。

- 先想想你能给别人什么，再说你想要什么。

- 要有最遥远的梦想和最朴素的生活。

- 天行健 君子以自强不息 地势坤 君子以厚德载物

- 够真心，才是最厉害的武器。

- 你想过普通人的生活就会遇上普通的挫折 你想过上最好的生活就一定会遇上
  最强的伤害。世界很公平，你想要最好的，就一定会给你最痛的。能闯过去，
  你就是赢家；闯不过去，那就乖乖做个普通人吧。所谓成功，并不是看你有多
  聪明，也不是要你出卖自己，而是看你能否笑着渡过难关。

- 每天都会冒出许多念头，那些不死的才叫梦想。

- To strive, to seek, to find and not to yield.

- 一个人遇见一个人是可以获得重生的。

- 不是每一次努力都能收获成功，但每一次成功都离不开努力。

- 承担责任也是证明自己的一种方式。

- 不要叹气。每叹一口气，就会少一分自信。要时刻提醒自己，我无所不能。

- 谦和，温顺且自持地生活，不乱于心，不困于情，不畏将来，不念过去。

- It's better to burn than to fade away.

- It's very easy to be different, but very difficult to be better.

- 爱情不是生命的全部。

- 处于人生的最低谷，有个好处，就是无论从那个方向努力，都是向上。

- 不要把自己的信念挂在墙上。

- 世间安得两全法， 不负如来不负卿。

- 梦想使生活得以忍受。

- 一个人要像一支队伍，对着自己的头脑和心灵招兵买马，不气馁，有召唤，爱
  自由。

- 我知道自己喜欢你，但我不知道将来在哪里。因为我知道，无论哪里，你都不
  会带我去。而记忆打亮你的微笑，要如此用力才变得欢喜。

- 你是非常可爱的人，真应该遇上最好的人，我也真希望我就是。

- 你的时间就是你自己。

** 曾经微信里的备忘

1. Today is difficult, tomorrow is more difficult, but the day after
   tomorrow is beautiful. So we have to work very hard in order to
   survive the long journey. 14/09/15 14:21

2. 努力，奋斗。 14/09/16 00:56

3. 菩提本无树，明镜亦非台。本来无一物，何处惹尘埃。 14/09/16 23:37

4. 太阳尚远，但必有太阳。 14/09/17 16:23

5. 走别人没走过的路，让别人有路可走。 14/09/17 23:27

6. 仗义每从屠狗辈，负心最是读书人。 14/09/19 23:27

7. 出溜是这个世界上最容易的事情。 14/09/20

8. 可遇不可求。 14/09/20

9. 突然记起一件事情，笔记本没出故障之前，桌面上有一个记事本，内容大致
   分为了几类，包括我想读的书，我想看的电影，我想听的音乐，我想骑行的
   地方，我想学习的东西。估计里面很多的内容我都记不清了，大概我又会嘲
   讽自己的幼稚。但，谁又能否认这些都是梦想呢？ 14/09/20

10. 梦想一定要有的，万一实现了呢。

11. 未来始于今天，而不是明天。

12. 利他。

13. 唯一能做好最佳的感恩就是用行动去做，做得更好。

14. 诚信是最大的财富。

15. 态度比能力重要，选择也比能力重要。

16. 梦想是一定要有的，万一实现了呢。认真的人改变自己，执着的人改变命运
    每天都优于昨天的自己，再辛苦也要为了活得更好而奋斗。

17. 不经一番寒彻骨，哪得梅花扑鼻香。

18. 永远不要抱怨，别人的抱怨也许就是你的机会。

19. 托福。

20. 梦想。

21. 为什么没有紧迫感？明明时间少得可怜，却好像没事人似的。有那么多梦想
    却不去捍卫。总给自己懈怠的借口，总给自己拖延的借口。

22. 请不要再折腾了。

23. 我把自己折腾得身心俱疲 安分些吧。

24. 晚上想想千条路,早上起来走原路.

25. 想法很多，不采取行动,只会让自己更痛苦.

** 给侄女起名

盈什 锦什 胤什 坤什 乾什 宇什 雨什 语什 煜什 君什 婉什
翰什 康什 安什 梦什 叶什 曦什 若什 箬什 敏什 瑞什 锐什
睿什 秋什 如什 学什 苏什 云什 兆什 佩什 韵什 钧针
歆什  轩什 茗什 旭什 冉什 月什  婵什 娟什 晟什

名字最好要有出处
可以在大名基础上起小名
明字可以拆成日和月两个字，起相关的名字

** 竹忆

*MicroMsg*

- 你是我的偶像啊

- 谢谢你陪我聊了这么久

- 我也多了一个理由早起

- 我是猪

- 去了北京你考给我吃啊

- 好好休息一下吧面包会有的

- 以后早晨给你打卡啊。。。。

- 我红包有点问题先欠着我可以下次去北京请你吃金钱豹  没人陪。那个时候也
  忙  我早就想吃了

- 对自己有信心至少在我眼里非常优秀

- 今天最可怕的是我想自杀了。我就呆呆坐在那里，想好了自杀的每一个步骤每
  一个场景，挂掉之后每一个人难过的表情，会发生什么事。就好像这件事是真
  实的会在未来某一天发生的

- 你是很特别的人

- 我先下了借妹妹手机。我手机锁起来了

- 恩。你记住啊你是个好男孩不要为了内向话不多和别人道歉。

- 你是满满正能量

- 你今天的那个朋友圈是给我发的吗

*伊* 阴319 阳503

** 求职中的项目介绍、个人评价、学科介绍等

熟练使用C++/C, Pyhon, Matlab等编程语言进行软件开发，熟练使用Qt进行UI开发和使用OpenGL库进行图形开发，具备良好的数据结构和算法设计技能
熟练使用Linux操作系统, 以及shell, gcc/gdb, cmake, emacs, git等
熟练使用机器人操作系统ROS，理解其核心概念与设计理念
具备良好的英语阅读视听能力和基础的口语表达能力(CET4:650, CET6:587)
具备ARM/Arduino/ARV/51等嵌入式开发的能力，掌握嵌入式Linux操作系统的基础知识
熟练使用 LaTeX, 以及MS Office办公套件

融合Lidar/IMU的同步定位与地图创建算法
项目介绍:基于ROS实现可移植的SLAM算法，融合惯导姿态数据和激光测距数据对室内结构化环境进行创建地图。
系统地自学了Linux操作系统和机器人操作系统ROS,负责项目的整体方案的制定，并在实践过程中不断充实和完善；
算法设计：设计了基于扩展卡尔曼的EKF-SLAM算法, 使用C++和Python混合编程实现，并以ROS的风格和机制进行封装打包；
软件编写：设计了基于ROS的软件框架，搭建了仿真环境,测试了算法的有效性；
硬件集成：集成了硬件平台，核心部件包括惯性测量单元IMU和二维激光扫描仪Lidar，并将算法从仿真环境中移植到真实环境中，实现了手持设备的6D运动时的实时制图和2D建模；
算法移植：载体平台为四轮驱动的Mechanum小车，通过CAN总线对实现运动控制和数据采集，并在算法中对该平台运动中特有的振动进行滤波处理。

面向服务移动机器人的复杂环境语义三维地图构建
项目介绍:北京市自然科学基金支撑，项目针对面向服务型移动机器人的复杂动态非结构环境三维语义地图即时创建问题，从“数据对齐与融合”、“点云分割与语义标号”和“局部与全局语义地图创建”三个侧面展开系统性研究。
数据处理：使用C++语言设计合理的数据结构实现对传感器数据的采集和滤波处理
可视化：使用Qt设计了UI和OpenGL实现数据的可视化
数据库：利用MySQL设计数据库存储和检索处理后的数据。

高空飞艇载荷集成与定量处理技术
项目介绍:国家科技支撑项目，包括飞艇机械结构，飞控系统，姿态解算和航拍系统几大部分的集成，在项目中主要负责航拍系统的嵌入式软件设计。
嵌入式软件：USB通信，嵌入式FAT文件系统；捕获GPS的PPS信号，接收GPS的时间、速度、位置信息并完成NMEA解码，对外输出3路PPS信号与NMEA信息；按照要求对多相机进行触发并且捕获相机曝光反馈小信号，对信号放大整形后判断相机是否正常工作，最后将时间、速度、位置以及触发结果等信息存储到板上SD卡；
图像处理：使用Matlab工具箱函数对采集的航拍图像进行校正、特征提取和分割聚类处理。


学习能力强，对自己喜欢的事物如Linux、编程等抱有强烈的好奇心和求知欲，能够以其为核心进行广泛的涉猎和系统的自学，并保持持久的耐性和热情；
注重独立思考，善于观察细节和倾听，同时具备良好的团队合作精神，尊重规则，踏实认真；
具备扎实的英文阅读能力和科研分析能力，能够刻苦钻研新的理论和技术并快速应用于实践。


马拉松：热爱长跑，保持晨跑的习惯，数次完成全程马拉松赛事
编程：喜欢钻研算法并通过编程解决实际问题，具备良好的数学功底

北京科技大学机电子工程隶属机械工程学院，开设课程方向比较广泛，涉及了机械、电子和编程等多个方面，主要包括
1. C++程序设计
2. 电子电路技术
3. 机械设计与分析
4. 汇编原理
5. 高等数学
6. 机电一体化技术
7. 单片机原理
8. 机械加工技术
9. 机械工艺分析
10. 嵌入式系统设计
11. 机械制图
12. 数字电路与模拟电路
13. 计算机辅助设计
14. 数据结构基础
15. 三维建模等

北京科技大学机电子工程隶属机械工程学院，开设课程方向比较广泛，涉及了机械、电子和编程等多个方面，主要包括
1. C++程序设计；2. 电子电路技术；3. 机械设计与分析；4. 汇编原理；5. 高等数学；6. 机电一体化技术；7. 单片机原理；8. 机械加工技术；9. 机械工艺分析；10. 嵌入式系统设计；11. 机械制图；12. 数字电路与模拟电路；13. 计算机辅助设计；14. 数据结构基础；15. 三维建模等


机械电子工程专业（706系）隶属北航机械工程及自动化学院，主要方向包括 计算机测控、机电一体化、嵌入式系统，无损检测技术以及液压技术等，与航天科技结合紧密。
开设课程包括：
1. 嵌入式系统设计
2. 智能控制及应用
3. 工业控制网络技术
4. 有限元分析
5. 无损检测技术
6. 矩阵理论
7. 数字图像处理
8. 面向对象的设计与分析
9. 计算机图形学
10. 数据库系统原理与应用
11. 机电一体化技术
12. 液压传动与控制
13. 机电系统建模辨识与控制
14. 软件技术基础
15. 计算机视觉
等

机械电子工程专业（706系）隶属北航机械工程及自动化学院，主要方向包括 计算机测控、机电一体化、嵌入式系统，无损检测技术以及液压技术等，与航天科技结合紧密。
开设课程包括：1. 嵌入式系统设计；2. 智能控制及应用；3. 工业控制网络技术；4. 有限元分析；5. 无损检测技术；6. 矩阵理论；7. 数字图像处理；8. 面向对象的设计与分析；9. 计算机图形学；10. 数据库系统原理与应用；11. 机电一体化技术；12. 液压传动与控制；13. 机电系统建模辨识与控制；14. 软件技术基础；15. 计算机视觉等

北京科技大学新生奖学金，20100613
北京科技大学三等人民奖学金,20111128
北京科技大学二等人民奖学金，20111128
北京科技大学三好学生,20101128
北京科技大学三好学生,20111128
北京科技大学优秀毕业生,20130618
北京航空航天大学二等奖学金,2013-2015

一种艇载多光谱高光谱对地观测装置，CN104635241A，2015.05.20
一种多相机同步触发装置及控制方法，CN104503306A，2015.04.08


*社会活动*

2010.3     大钟寺志愿讲解
2010.4     清明万安公墓扫墓
2010.5     五四青年文化节志愿服务
2010.7     龙门石窟社会考查
2010.8     武搏会志愿者


*GPA*

本科：3.39/4
您的GPA（绩点）：
算法标准 标准算法GPA 常见算法GPA
标准4.0算法 3.39 3.06

研究生：3.41/4
您的GPA（绩点）：
算法标准 标准算法GPA 常见算法GPA
标准4.0算法 3.41 3.17
改进4.0算法(1) 3.41 3.52
改进4.0算法(2) 3.41 3.52
北大4.0算法 3.41 3.46
加拿大4.3算法 3.41 3.89
中科大4.3算法 3.41 3.48
上海交大4.3算法 3.41 3.54

** 我是掩耳盗铃的小丑

我是掩耳盗铃的小丑，
每一个自欺欺人的谎言，
都是自掘坟墓的一抔土。

这里阴仄暗无天光，
我在墓壁上挂起虚幻的梦想，
投下让人迷醉的琉璃光影。

无处可起的凉风奏响哀乐，
我裹紧薄如蝉翼的希冀，
在身上勒起自缚之茧。

凝重的空气压垮孱弱的双肩，
面部贴于冰冷的墓碑表面，
它带着嘲弄的口吻写到：
等待救赎？

** 人，在窘途

寒意袭人，尚未归家，便已怀念北京的暖气，怀念刚刚行过的这段路程，怀念流逝的这半年光景和这段时光里的物和人。颠颠簸簸的火车上断断续续地睡了一个白昼和半个夜晚，此刻凌晨，睡意全无，闲来无趣，聊以记事。

大学最后一门考试刚结束便急匆火燎地往家里奔离，想又不想。早晨习惯性地导公交到西站，到站后才惊知车票上的西字不翼而飞，两个大老爷们立刻傻了眼。屁颠屁颠地奔到北京站，一路上拎断了行李箱的两个把手，自嘲了一路，抢在发车前登上了车。要不是结伴而行，此刻恐怕是另外一番光景。

数字打头的火车恐怕只比绿皮车要高贵一点，四年来烦透了这遇站便停遇车就让白天跑半夜停标准晚点一个半小时的1503/4次，可还是得坐。旅途的四分之三的时间在睡眠或争取睡眠，唯一的乐趣便是看窗外，先是一片接一片雪地，穿插着几道凝冻的河流，间或几只鸭子三三两两地痴呆地蹲在上面，雕塑一般，接着是一片又一片麦田，枯黄枯黄的，几处燃烧后的灰烬倒是增添了别样颜色——半亩黑。商丘过后，掉头折回一段便落下了漆黑的夜，窗上也只有车内的倒影。一路上周边地人高谈阔论着所谓的物质生活——婚房钱车，就像《小王子》里描述的那样：成人格外注重数字，似乎知道一切。说得好听的叫做现实，说得不好听得也叫现实，谁都没有资格去对谁指手画脚，但是我知道现在的我会讨厌将来很可能同样现实的我……车缓缓地行，思绪慢慢凝固僵化，近站，鲜有“近乡情更怯”的感觉，只觉寒意愈浓。车站旁的小旅舍内，“设备一应俱全”，一部手机，打发一个无眠夜晚。港城。

2012同样是一段囧途。夏天，循环完五月天和胡夏的歌，落荒跑到新疆，第一次对自己出生地的行政名称有了明确概念，却未曾捡起七岁前的多少记忆，好在表面上放下了一些该放下的，同样落荒般地逃回了帝都。

之后一直在保研和考研之间摇摆不定，一边是左，一边是右，时而左时而右，直到不得不做决定时，依旧在徘徊，感慨有些决定怎么就如此之难。这一年里看似愚蠢不过的决定就是弃保从考了，有点逼良为娼的感觉，很多时候我常常如是怀疑自己。100余天的复习让我囧然意识到似乎高估了自己，过于相信未来的那个幻想中很努力的我了。于是，我的面前屹然横亘着自己一手缔造的九十度峭崖，至于攀爬了多高，破罐子破摔，是生是死——未尽人事，惟有听天命了。

但是愚蠢不过的决定却带给我了一段值得感恩的时光，于人于事。我知道如果没有这翻愚蠢，我会怎样地虚所不愿见到的最坏的结果。
考研落幕后的十天复习大学最后一门课程，再次验证了deadline是第一生产力，很囧和欢乐，因人因事。


很多路很囧，但没准能通往理想的目的地，或在沿途收获美丽的风景。

韩寒的新书题为《我所理解的生活》，对生活的理解因人而异，于我而言，生活是一段找寻自我的历程，这种寻找自始至终，忘记了便只是生，寻找着便是活，无论多囧。

Life is beautiful for there is always sometime worth gratitude.

早安，连云港

** 语录：关于爱情

1、你走，我不送你 ; 你来，无论多大风多大雨，我都会去接你。
2、我爱你，爱了整整一个曾经。
3、每件事最后都会是好事。如果不是好事，说明还没到最后。要这样相信着。
4、在古代，我们不电话，不短信，不网聊，不微博，不漂洋过海，不被堵在路上。如果我想你，就翻过两座山，走五里路，去牵你的手。
5、這一生，總有一個人，老是跟你過不去，你卻很想跟他過下去。
6、我只是想有一个人明白我，即使我什么都没说。
7、其实。你爱我像谁。任何的表情我都会给。
8、我藏不住秘密，也藏不住忧伤，正如我藏不住爱你的喜悦，藏不住分离时的彷徨。我就是这样坦然，你舍得伤，就伤。
9、听到一些事，明明不相干的，也会在心中拐好几个弯的 想到你 。
10、所谓爱情就是有那么一个人,可以轻易控制你的情绪,前一刻让你哭,下一刻又让你笑。

11、曾经多情如斯，伤痕累累，才终于学会无情。有一天，没那么年轻了，爱着的依然是你，但是，我总是跟自己说：我也可以过自己的日子。惟其如此，失望和孤单的时候，我才可以不掉眼泪，不起波动，微笑告诉自己，不是你对我不好，而是爱情本来就是虚妄的，它曾经有多热烈，也就有多寂寞。  ___张小娴
12、有没有这样一个人， 无论多么想念， 却不曾再见面。
13、缘分是本书，翻得不经意会错过，读得太认真会流泪。
14、有时候想找人说说话，于是一遍遍翻看手机里的电话簿，却不知道可以给谁发个短信或打个电话，最后还是按下了“清除”。其实很想找个人倾诉一下，却又不知从何说起，最终的最终是什么也不说，告诉自己，明天就好了。
15、当你仍想继续，永远不要说再见；当你还能承受，永远不要说放弃；当你舍不得一个人，永远永远不要说你不再爱他（她）。
16、爱情不是数着日子过去，它让每个日子都变得有意义。
17、爱就是赋予某人摧毁你的力量，却坚信他/她不会伤害你。
18、有些人永远都不会知道，他的一句话，我会记得很久；他的一个不以为然的承诺，我却苦苦守侯。之后，再经过时间而改变，而变淡，渐渐的，淡忘了。那种前一秒，还怀着满心期望，象被推上高高的天空；然后下一秒，满心的失望，象从高空狠狠坠落。
19、如果，在身边的最后真的不是你。如果经历了那么多坎坷辗转后，最终还是要分开。如果故事到最后，是我们的身边都有了别的人。如果回忆，诺言和曾经相爱的决心都在现实面前变得渺小，不堪一击。不管以后如何，不管结局如何。现在的我还是愿意执着的去爱。------ 我们一起等我们的最后，最后的最后。
20、总有一天，你会遇到一个彩虹般绚烂的人，怦然而心动。
21、重要的不是你转身之后会遇见谁 而是你转身的时候 希望遇见谁 。
22、时间不是让人忘了痛，而是让人习惯了痛。
23、有时候感觉到难过并不是因为做了什么，而是发现自己什么都做不了。 有而的时候放声大笑也并不是因为开心至极，而是发现 根本哭不出来。

24、如果你讨厌我，我一点也不介意，我活着 不是为了取悦你。
25、最喜欢的对白：“你这么优秀，会被越来越多的人喜欢，那我怎么办？”  “被我喜欢。”
26、那个时候，我还不知道我们可以一如往常生活，工作，在开玩笑的时候心如刀割………我完全不知道，我们可以在伤心欲绝的同時，一面全神貫注工作，精神崩潰同時又笑容可掬，悲伤又自在，苍凉又爱恋。 ——布里吉特•吉罗《爱情没那么美好》
27、世界真的很小，好像一转身，就不知道会遇见谁。世界真的很大，好像一转身，就不知道谁会消失。 爱情有时是一种习惯，你习惯生活中有他，他习惯生活中有你。 拥有的时候不觉得什么，一旦失去，却仿佛失去了所有。
28、有些人很坚强，喜欢在流泪的人面前，开导逗笑，又无所不能，总是轻而易举地帮助别人解决难题，为了理想，再苦再累也心甘情愿。但面对自己的创伤，他们只会躲在角落里看着伤口变大，只有面对最信赖的人时，才会丢盔弃甲，委屈地流下眼泪。在哭过之后，笑着擦干眼泪，说，没关系，我可以做得很好。
29、别再为错过了什么而懊悔。你错过的人和事，别人才有机会遇见，别人错过了，你才有机会拥有。人人都会错过，人人都曾经错过，真正属于你的，永远不会错过。
30、如果我们还有缘，走一圈还是会回到对方的身边。
31、错过 、其实就是你深情凝视我的时候 我没有抬头  而当我把柔情的目光投向你 你却已经转身 。
32、在真爱面前，不要放弃，哪怕你喜欢的人要求你放弃。
33、人只要管好自己已經很了不起，幹嗎要去管男人呢？聽話的男人不用管，不聽話的男人，要管也管不到，對你好的男人不用管，對你不好的男人，不會讓你管， 愛你的男人不用管，不愛你的，輪不到你管。
34、当一个深爱着你的人为你而改变，那是因为他爱你；当你遇到一个人，他为你收起他的顽固脾气，也因为他爱你；他把你的兴趣也变成了他的兴趣，还是因为他爱你。如果你发现身边有这样的人，请你好好珍惜。 溜掉的小鱼，总是最美丽的；失去的情人，总是最懂你的。
35、忘记一个人，并非不再想起，而是偶尔想起，心中却不再有波澜。真正的忘记，是不需要努力的。 每个人的电话本里，都会有那么一个你永远不会打，也永远不会删的号码；每个人的心里，都会有那么一个你永远不会提，也永远不会忘的人

36、很爱你，却不知道该如何靠近你，所以觉得离开是可以的，并没有什么不同，结果反正都是这样，是好是坏都不重要，重要的是我曾经迷恋你。——安妮宝贝
37我害怕的是 那些回忆 我还记得 你却忘了 。
38、我梦到你的时候 你也梦到我的话 多美妙
39、全世界暂停 听我的声音
40、我想 终有一天我会遇见你 。嗯。我一直这样相信着 。
41、我赶不上爱你的一辈子 、但来得及一辈子爱你 。
42、应该趁着年轻和喜欢的人一起制造些 比夏天还要温暖的事
43、我一直相信等你出现的时候 我就知道是你
44、不要让那个喜欢你的人 撕心裂肺地为你哭那么一次 因为你能把他伤害到 那个样子的机会 只有一次 那一次以后你就从不可或缺的人变成可有可无的人了  即使他还爱你可是总有一些真的东西改变了
45、如果我喜欢你的时候 你也刚好喜欢我  那该多好 。
46、如果你回来  如果我还在
47、如果你喜欢的人不喜欢你  那么就算全世界的人都喜欢你 也还是会觉得很孤单吧
48、我一直觉得我们就该在一起 我从来都没有想过和你分手
即使我们吵得最凶的那一次

** 凡人语录

         1、一个人有生就有死，但只要你活着，就要以最好的方式活下去。
2、当我们失去的时候，才知道自己曾经拥有。
3、记住该记住的，忘记该忘记的。改变能改变的，接受不能改变的。
4、眼泪的存在，是为了证明悲伤不是一场幻觉。
5、妈妈说过没有人值得你为他哭，唯一值得你为他哭的那个人，永远都不会让你为他哭。
6、两人相爱时，渴求无限甜蜜的吻，但为何在争吵时，却要用接吻的嘴互相伤害呢？
7、像掉到沙发下面的一粒纽扣 ——你专心找，怎么也找不到，等你淡忘了，它自己就滚出来了。
8、眼泪的温度有 530℃，只是因为外面的世界太冷，流出来的时候才会降到 53℃。
9、宠和爱是不同的两件事，宠可以没有交流，而爱则不能。
10、试题一共有四道题目：学业、、、。平均分高才能及格，切莫花太多的时间和精力在任一题目上。
11、鱼说：你看不见我的眼中的泪，因为我在水里；水说：我能感受到你的泪，因为你在我心里。
12、在世，应该这样，在芬芳别人的同时美丽自己。
13、只需一分钟就可以碰到一个人，一小时上一个人，一天爱上一个人，但需要花尽一生的时间去忘掉一个人。
14、发光并非太阳的专利，你也可以发光。
15、人只要不失去方向，就不会失去自己！重要的不是所站的位置，而是所朝的方向。
16、每一件事都要用多方面的角度来看它。
17、的路总是为有信心的人预备着。
18、快乐要懂得分享，才能加倍的快乐。这也是三峡在线之所以总是在 "盘点生活，分享"的理由。
19、抱最大的希望，为最大的，做最坏的打算。
20、生活中若没有朋友，就像生活中没有阳光一样。
21、一个人有生就有死，但只要你活着，就要以最好的方式活下去。
22、要做的事情总找得出时间和机会，不要做的事情总找得出借口。
23、令人不能自拔的，除了牙齿还有。
24、就像一双袜子，越是瞧起来不顺眼的袜子，越有可能永远陪在你身边，越是的漂亮袜子经常会少一只。
25、我们缺少的不是机会，而是在机会面前将自己重新归零的勇气。
26、微小的就在身边，容易就是天堂。
27、没有人因水的平淡而厌倦饮水，也没有人因生活的平淡而摒弃生活。
28、思恋一个人的滋味就像喝了一大杯冰水，然后用很长很长的时间流成热泪。
29、得不到你所爱的，就爱你所得的。
30、日出东海落西山，愁也一天，喜也一天；遇事不钻角尖，人也舒坦，心也舒
31、失因为贪 ——说真的，老实人很少上当。
32、当你能飞的时候就不要放弃飞；当你能梦的时候就不要放弃梦；当你能爱的时候就不要放弃爱。
33、家！甜蜜的家！天下最的莫过于家。
34、如果敌人让你生气，那说明你还没有胜他的把握。如果朋友让你生气，那说明你仍然在意他的友情。
35、有些事情本身我们无法控制，只好控制自己。
36、聪明人是快乐的，自以为聪明的才烦恼。帮助别人减轻三分烦恼，自己就会享受七分快乐。
37、流言造成伤害至少需要两个人 ——你的敌人诋毁你，你的朋友转告你。
38、的生命应该充满期待、惊喜和感激。
39、最快乐的人并不是一切东西都是最好的，但他们会充分享受自己已有的东西。
40、自己要先看得起自己，别人才会看得起你。
41、假如一千个人从我身边踏过的，我也能听出你的脚步声，因为 999个人的脚是踏在地上，只有你的脚步声是踏在我的心上。
42、生命太过短暂，今天放弃了明天不一定能得到。
43、每天告诉自己一次：我真的很不错。
44、要铭记在心：每天都是一年中最的日子。
45、爱的力量大到可以使人忘记一切，却又小到连一粒嫉妒的沙石也不能容纳。
46、爱一个人而那个人不爱你是很让人难受的，但更痛苦的是，爱一个人，却永远都没勇气告诉他。
47、后悔是一种耗费精神的情绪。后悔是比损失更大的损失，比错误更大的错误，所以请不要后悔。
48、每个人都有潜在的能量，只是很容易：被习惯所掩盖，被时间所迷离，被惰性所消磨。
49、能冲刷一切的除了眼泪，就是时间，以时间来推移，时间越长，冲突越淡，仿佛不断稀释的茶。
50、有勇气并不表示恐惧不存在，而是敢面对恐惧、克服恐惧。

** 语录

１.别怕丢人，追求丢人是一种成功的尝试，至于为此笑话你的人，你可以把他们从你将来人生对手的名单中排除了，你也要为每一位上台唱歌的人鼓掌。

２.你有足够的理由佩服每天早起的人,不信的话,你去做。做到后会发现有很多人佩服你呢。

３. Impossible  is nothing.只要选择了目标，不要再想太远，每天脚踏实地，风雨兼程。生命不息，奋斗不止。

４.你和你的朋友会一起在将来打造一个可能很辉煌的事业。很好听是吗？记住，你们都要努力。

５.很多事情当你再回忆时会发现其实没什么。所以，不管当时你多么生气都告诉自己不必这样，你会发现其实真的不必。

６.不管别人怎么说大学是个提高综合能力的地方云云，如果你学习失败了，你就什么也不是——不排除意外，处世能力过分出众而成功得人是有，但你考虑好了吗？你会是那个意外吗？？

７.别说脏话，随便的一个字或者几个字会让你在别人心中的形象大打折扣，切忌无病呻吟的成天喊“堕落与颓废”。

８.好好利用在公共场合说话的机会来锻炼自己。

９.别为你自己和别人下定论，你所看到听到的可能只是一面。

１０.如果周围有人嫉妒你，那么你可以把他从你的竞争者之列排除了。

１１.很多事情别人通知你了，要说谢谢，没有通知你，不要责怪，因为那些事你其实应该自己弄清楚。

１２.在坚持不懈的过程中，实在累了的时候，拿来读一读，看一看，又会有继续奋斗的动力。记住，再苦再累是自己选择的路，决不能放弃，更不能掉眼泪。只有毕业胜利的时候，眼泪才能流下。

１３.让自己的尊严有足够大的承受力，社会是一个最喜欢打碎人尊严的地方,除了你自己,没人会为你保留它，你呆的地方是大学，所以你有空间承受失败和打击。

１４.当你上了高年级后,要让自己有大人的形象,大一的孩子看到你,要让他们感觉到你是他们的学长.你很成熟.

１５.遇到再大困难的时候，不要惊慌，千万要学会冷静；不要去想着求别人，以前有家人帮你，现在需要你一个人面对挑战，从绝望中寻找希望，人生终将辉煌。

１６.学会说谢谢，但谢谢并不是随便敷衍，是对别人帮助的肯定和回报；更要学会说对不起，但对不起不是借口，是对自己过错的弥补和内疚。

１７.如果你一直是一个人去食堂吃饭或者去上自习，别在意，大学里一个人是正常的，你觉得孤独？你的朋友是怕你觉得你没有自由的空间，所以别以为你没有朋友。

１８.不要抱怨学校的差异和现实的不公平，你的不公平对于别人而言却是公平，要靠你自己去改变不如意的环境，争取合理的公平。

１９.不论男人还是女人,如果在大学里还把容貌当作重要的东西而过分重视的话,可能不会吃亏,但是早晚会吃亏.可能,很可能。

２０.放假的时候，要么留在家里多陪陪父母，帮他们做点事，远走高飞的你能像以前天天守在他们身旁的时间已不多；要么多去社会中体验生活，因为你不但要懂得生活，还要学会如何去生活。

２１.心烦意乱或者无聊闲着的时候，多到图书馆去泡泡，书中有现实中难得的纯明和清静；多看些书，生活会渐渐少一些迷茫，多一些追求。

２２.永远不要瞧不起家境贫困的同学，他们在相对差的条件下做到了和你一样的成绩，已经说明他们比你更加出色。每个人的生活都应该是平等的，尽你所能去帮助他们。

２３.你可以输给任何人，但不能输给自己。

２４.经常给家里打个电话，即使嘴上都说不想对方，其实内心早已情动于中；有了女（男）朋友，也不能忘了爹和娘。

２５.多笑笑，会慢慢让自己真的快乐起来。

２６.好好利用公开场合锻炼、展示自我，哪怕只是一次课堂上的发言，别怕尴尬，更别怕丢人，也不要笑话在公众面前丢脸的人。

２７.大学是一个新环境，你的所有过去对于他们来说是一张白纸，这是你最好的重新塑造自己形象的时候，改掉以前的缺点，以全新的形象出现。

２８.学生会的干部，如果你尊重他们，告诉自己那是因为他们是你的学长而不是因为他们是你的上级，大家都只是学生而已。

２９.永远别渴望做个任何人都不得罪的人，有人反对有人支持然后自己做出决定是精彩的人生。

３０.无论你是什么级别的学生干部，即使已成为学生会主席，也要尊重普通同学，大家都是学生，更应该是朋友。

３１.后悔是一种耗费精神的情绪.后悔是比损失更大的损失,比错误更大的错误.所以不要后悔。

３２.你的确要学的有心计,但是记住,永远记住,在社会上要胜利的唯一的方法永远只是一个,那就是实力,永远不用怀疑。

３３.面对不公平的东西,不要抱怨,你的不公平可能恰恰是别人的公平。所以，你不如去努力的奋斗，争取你自己最合适的公平。

３４.人生百态,不要对新的看不惯的东西生气,无所谓的。

３５.我们确实活得艰难，一要承受种种外部的压力，更要面对自己内心的困惑。在苦苦挣扎中，如果有人向你投以理解的目光，你会感到一种生命的暖意，或许仅有短暂的一瞥，就足以使我感奋不已，所以我们要学会感激。

３６.冷静，有大事时，能安静并能快速想出办法的人，很厉害。

３７.社会充满竞争，大学也在竞争，赢得竞争靠的是自己的实力。

３８.一种对工作和学习的冲击力及持久力会让你有特殊的魅力和个人实力

３９.喜欢一个人，就勇敢的告诉他或者她，我在天涯说过大学是学习的地方，但是我理解爱情的力量。追求你真正爱的人，只要自己认为值得，那就是值得的。

４０.不要在女孩子面前就慷慨解囊，俨然一个款哥，即便你的确很有钱。要知道，看中你现有金钱的女人，终究有一天会因为金钱背叛你。

４１.不要幻想自己成为招聘会上的宠儿，当你明白百分之七十的初中生都可以上大学时，你应该明白人们不会去崇拜一个群体的大多数的，单位需要的是工作的人 而不是当官的人 。

４２.你可以选择坚持，也可以选择放弃。没有对错。我是说对爱情来说，但是重要的是坚持你的选择。

４３.如果老是去琢磨哪些人你讨厌，哪些人与你志趣相投，那么你就大错了，要想着如何让别人接纳你，而不是你能接受什么样的人。

４４.对陌生人，或者把对方当做一张白纸，或者把对方当你的朋友，总之别当做敌人，即使你听到再多的关于他（她）的不好的传闻。

４５.爱你的人，不管你接不接受，你都应该感谢对方，这是对他们的尊重。

４６.坚持在背后说别人好话，别担心这好话传不到当事人耳朵里,有人在你面前说某人坏话时，你只微笑。

４７.抽时间出来锻炼身体。

４８.不管现在你对未来多困惑，多迷茫，都不要忘了树立一个目标。一个人过去或现在的情况并不重要，将来想要获得什么成就才最重要。除非你对未来有理想，否则做不出什么大事来 。

４９.不要把过去的事全让人知道，尊敬不喜欢你的人。

５０.成大事的方法多种多样 ，别不接受你看不惯的方法

** 富兰克林名言

我未曾见过一个早起、勤奋、谨慎、诚实的人抱怨命运不好；良好的品格，优良的习惯，坚强的意志，是不会被假设所谓的命运击败的。——《富兰克林自传》

** 微博

“你相信人能改变命运么？”“人应竭尽所能……然后再听天由命。”——《最后的武士》
拥有的资源多少并不重要，如果你不懂得使用，永远都是不够的。
“你要按你所想的去生活，否则，你迟早会按你生活的去想。” by 陈楸帆
人要是太关注自己了，就会失去正常的判断能力了。——藤田宜永
一个人真正关心别人的时候，才会忘记自己。---《看见》之非典纪录
永不期待，永不假设，永不强求。顺其自然，若是注定发生，必会如你所愿。
士人读书，第一要有志，第二要有识，第三要有恒。有志，则断不甘为下流。有识，则知学问无尽，不敢以一得自足；如河伯之观海，如井蛙之窥天，
皆无见识也。有恒，则断无不成之事。此三者缺一不可。——曾国藩
自惭多情污梵行，入山又恐误倾城。世间安得双全法，不负如来不负卿？——仓央嘉措
语言很多时候都是假的，一起经历的事情才是真的
路飞(⊙o⊙)，索隆（=_≠），香吉（º_\\\），乌索普⊙﹄⊙，乔巴⊙ω⊙，弗兰其⊙△⊙，布鲁\^O^/，娜美$3$，罗宾=L=
昨日种种譬如昨日死，今日种种譬如今日生
成熟是给陌生人看的，傻逼是给小伙伴看的，幼稚是给喜欢的人看的。
“所谓的幸运，就是当你准备好了的时候，机会来了。” ——《把时间当作朋友》
做自己的观察者，不做情绪的小跟班！

相信自己，你能作茧自缚，就能破茧成蝶。
思想的本质是不安。一个人的观念一旦产生动荡，新的思想就已经萌芽，人们需要的只是给这个萌芽一个剥离掉泥土，让它露出来的机会。-----摘自柴静清华讲座
好感和反感是你在观察人的时候最有害的一种心态，你要在事前就对一个人形成了好感或者反感，就没有办法诚实和客观地观察他了。----柴静
你知道什么叫失败？ 真正失败的人，就是那种特别害怕不能成功，怕死了，连试都不敢试的人。——《阳光小美女》
梵高对弟弟说过＂没有什么是不朽的，包括艺术本身。唯一不朽的，是艺术所传递出来的对人和世界的理解。＂----摘自「看见」
只承诺你能做到的，然后尽力超越你承诺的。
灾难总是接踵而至，这正是世间的常理。你以为只要解释一下，就有谁会来救你吗？要是死了，就只能说明我不过是如此程度的男人。 By罗罗诺亚·索隆
获取幸福最重要的是：有所为，有所爱，有所期待。
【一个人努力奋斗一生，大多是为了实现三大追求】1、财务自由：有足够金钱养活自己和家人，需要用钱时不发愁；2、时间自由：有可支配时间灵活安排工作、休息和娱乐；3、心灵自由：跟随自己内心，不让梦想憋屈。实现自由最容易的时间段，不是未来的某天而是现在。「转」
对于我而言，其实真正能够让我生活的心安理得的，不是锦衣玉食的生活，而是那种知识深入骨髓的踏实感，是那种每天都看到自己在进步，在前进，没虚度年华
学生问追一个女孩总是追不上怎么办？我回答：女孩不是追来的，是吸引来的，你追的过程是吸引女孩的过程，如果女孩没有看上你，再追都是没有用的。也许用更多的时间丰富自己，让自己变得更有内涵，再出现在女孩面前，她就喜欢你了。另外，爱是有缘分的，哪怕再有内涵气质的人，也不能让所有女孩喜欢。
治疗悲伤最有效的方法就是去学习一些东西。当你受到打击，经历挫折，从骨子里颤抖，看到你的世界被人摧毁，体验你的荣誉被踩进下水道，发生这些事情之后，你要学的只有一件事情。学习世事为何如此变化，发生了哪些变化。这是唯一可以让心永不疲惫，永不疏离，永不后悔的事情 - T.H. White
【三条丢弃规则】1.如果让你心情沉重、对自己有不好的感觉、阻碍你前行的，把它丢掉。2.如果只是占有空间，对你的人生毫无正面贡献，把它丢掉。3.任何事物，要丢还是要留，你得花很长的时间权衡利弊，或是烦恼不知所错的，那把它丢掉。
你必须只有内心丰富，才能摆脱这些生活表面的相似。——王朔《致女儿书》
不要欺骗自己，想当然地认为自己在“最后关头”会表现得最好。你做不到这一点。没完成的任务会一直潜伏在你的潜意识里，这不会消除你的压力，相反你会感到压力越来越大。某件事非常重要，而且是必须要做的，即使你讨厌，你也一定要去做，现在就做。（约瑟夫·费拉里）
Eleanor Roosevelt says that “You must do the thing you think you cannot do.” 罗斯福夫人说过，“你必须做你认为自己做不了的事。”

当我年轻时我梦想改变世界；当我成熟后，我发现我不能改变世界，我将目光缩短，决定只改变我的国家；当我进入暮年，我发现我不能改变国家，我的最后愿望仅仅是改变一下家庭，但这也不可能。当行将就木，我突然意识到：如果一开始我仅仅去改变自己，我可能改变家庭、国家甚至世界——威斯敏斯特教堂碑文
你总是喜欢把事情拖到第二天，你不能总是这么拖了，有一天，你会有很多事情要做，你的余生都不够用。一一《余生的第一天》
梁启超曾告诫已到美国留学三年的梁思成：你该挤出一部分时间学些常识性东西，特别是文学或人文科学，稍稍多用点工夫就能有大的收获。我深怕你因所学太专一的缘故，把多彩的生活弄得平平淡淡，生活过于单调，则生厌倦心理，厌倦一生即成苦恼之事……书宜杂读，业宜精钻。
大部分的恐惧与懒惰有关，这句我深以为然。我们常常会害怕改变，其实都是因为自己太懒了，懒得去适应新的环境，懒得去学习新的知识，涉足新的领域，但如果总是这样的话如何能让自己成熟起来呢？—— M·斯科特·派克《少有人走的路》

放纵自己的欲望是最大的祸害；谈论别人的隐私是最大的罪恶；不知自己过失是最大的病痛。—— 亚里士多德
托尔斯泰：“一个人越聪明、越善良，他看到别人身上的美德越多；而人越愚蠢、越恶毒，他看到别人身上的缺点也越多。”
当你能念书时，你念书就是；当你能做事时，你做事就是；当你能恋爱时，你再去恋爱；当你能结婚时，你再去结婚。环境不许可时，强求不来；时机来临时，放弃不得。这便是一个人应有的生活哲学了。——罗兰《我们的路》
做你没做过的事情叫成长，做你不愿意做的事情叫改变，做你不敢做的事情叫突破。
积极的人在每一次忧患中都看到一个机会，而消极的人则在每个机会都看到某种忧患。
一本好书会让我安静下来，会让我有内心生活。我每天出去都是应酬、谋生、作假，片刻的安静都是读书带来的。法国人蒙田有句话，大意是人类的一切灾难在于人回到家还安静不下来。我很庆幸我没有变成在自己的房间里面安静不下来的人。这和我这么多年坚持阅读有很大的关系。我对阅读充满感激。——陈丹青
【内向者更易成为卓越领导者？】40%美国公司高管是“内向者”,包括盖茨和巴菲特。内向者的力量源自“安静”：1.他们先思考,再发言：善于沉默,往往会被更好地倾听；2.更注重深度；3.平和的自信：让团队安心归附；4.更热衷文字交流：更清晰、准确地表达立场；5.习惯孤独：不为社交浪费太多精力，善承压。
优于别人，并不高贵，真正的高贵应该是优于过去的自己。━━━ 海明威
如果因为一个借口而不想去做一件事情，那么这个借口的存在便是去做的理由。
对明天如此恐惧，你今天又怎么能过好呢？————《三傻大闹宝莱坞》
幸福本身就是虚妄，它只存在于追求幸福的过程中。

** 格言

宽恕自己意味着接纳自己，也就是我必须放弃我的老朋友---自我谴责。我总是无情得贬低自己，感觉自己是不值得被爱的。在这些问题的背后，是一份自怨自艾的感觉，使我无法见到光明和奇迹。这才是我最大的问题。—— 肯·威尔伯《超越死亡》


人生的困境，有时是自己编织出来的蜘蛛网。人生的绝境，往往也都是你内心创造出来的假象。其实，生命里那些让你过不去的境遇，都是未来让你成长蜕变的养分。当你看清这个真相，你就会发现，原来老天从不会让你走投无路；相反的，是你的恐惧和妄想，才会逼你走入绝境。——《我与这个世界温柔相处》

对每个人而言，真正的职责只有一个：找到自我，然后在心中坚守其一生，全心全意，永不停息。所有其他的路都是不完整的，是人的逃避方式，是对大众理想的懦弱回归，是随波逐流，是对内心的恐惧。—— 黑塞《德米安》

每只毛毛虫都可以变成自己的蝴蝶。只不过，在变成蝴蝶之前，自己会先变成作茧自缚的蛹。在茧里边面对自己制造的痛苦，任何挣扎或试图改变的行为都是徒劳的。蛹只有一个选择，那就是放弃所有抗拒、全然接纳当下感觉、平静等待。直到有一天破茧而出成为蝴蝶。——《亲密关系》

鸡蛋从外打破，是食物；从内打破，是生命。人生，从外打破，是压力；从内打破，是成长

幸福本身就是虚妄，它只存在于追求幸福的过程中。

没有阅读习惯的人，就时间，空间而言简直就被监禁于周遭的环境中。他的生活完全公式化，他只限于和几个朋友接触，只看到他生活环境中发生的事情，他无法逃脱这个监狱。但当他拿起一本书，他立刻就进入了另一个世界，到另一个国家，或另一个时代，讨论一个从未想过的问题。----林语堂

生活不是用来妥协的，你退缩得越多，能让你喘息的空间就越有限；日子不是用来将就的，你表现得越卑微，一些幸福的东西就会离你越远。无须把自己摆得太低，若是那些是属于自己的，那么你都要积极地争取。

这些年我一直提醒自己一件事情，千万不要自己感动自己。大部分人看似的努力，不过是愚蠢导致的。什么熬夜看书到天亮，连续几天只睡几小时，多久没放假了，如果这些东西也值得夸耀，那么富士康流水线上任何一个人都比你努力多了。人难免天生有自怜的情绪，唯有时刻保持清醒，才能看清真正的价值在哪里。

《小王子》作者：（法）圣埃克苏佩里；摘要：大人们从来不自己去了解任何事情，总要小孩子们不厌其烦地把每件事解释给他们听；忘记一个朋友是令人忧伤的，并不是每个人都有过朋友；天上的星星都亮着，是不是为了让我们每个人有一天可以找到属于他自己的那一颗；我永远对我所驯化的东西负有责任，我对我的玫瑰负有责任；一个人只有用心才能看得到真实的东西，真正重要的东西不是眼睛可以看得到的。

怕什么就会想到什么，信什么就会听到什么，让我们恐惧的，不是外面的世界，而是我们的内心。

** 语录：心灵非鸡汤

【如何使大脑精神集中】1. 合理安排工作计划：先做需要精神集中的工作，再进行简单的工作；2. 谨慎分配自己的时间：明确自己每天在何时、何地能更好地集中精力，安排艰难任务；3. 刻意训练：每天花一些时间强迫自己集中地做一件事，也许从坚持5分钟开始，逐步累加。

眼光有多远，思想就有多远。思想是无垠的，它取决于你的见识。思想是深邃的，它取决于你的态度。走出去，多邂逅陌生的人，多遇见新鲜的事。让脚步载着目光，穿过繁华、荒凉，穿越时尚、古老，于熟悉中发现陌生，于喧闹中发现世态，于静谧中发现永恒，于平常中发现真理。善于思考的人都是善于发现的人。


你是一个什么样的人，就会听到什么样的歌，看到什么样的文，写出什么样的字，遇到什么样的人。你能听到治愈的歌，看到温暖的文，写着倔强的字，遇到正好的人；你会相信那些信念，温暖，梦想和坚持这些早就老掉牙的字眼；是因为你就是这样的人。


【炫耀源于内心的不自信】心理学上认为，“爱向别人炫”是一种内心需要被关注被肯定的表现，很可能是因为某种东西自己不常有，一旦拥有，希望藉以外界的羡慕来建立自信。不向别人晒自己的幸福会憋死你么？如果会，最好问问为什么。记住：生活不是演戏，自己精彩就好！






【管理微寓言】老钟对小钟说：“你一年要摆31536000下。”小钟说：“我怎么可能完成？”老钟说：“你只需一秒摆一下，每一秒坚持下来就行。” 小钟想着：一秒摆一下,每一秒坚持下来。一年过去了，小钟真摆了31536000下！制定目标不难，难的是如何分解目标，一步步去实现。

一个人经历地越多，他的抱怨就会越少。这是一个有趣的现象，因为跟那些成天抱怨的人比起来，他经受的波折可能更多。越是优秀越是努力。这一现象的症结在于，优秀的人总能看到比自己更好的，而平庸的人总能看到比自己更差的。


托尔斯泰：“一个人越聪明、越善良，他看到别人身上的美德越多；而人越愚蠢、越恶毒，他看到别人身上的缺点也越多。”

一个人要做成事情，需要三个要素；第一是意愿，有强烈意愿的人更容易百折不挠做成事情；第二是能力，能力包括知识、眼光、经验、人品、个性等，有能力的人一般判断力都不错；第三是资源，能否调动人脉关系，是否有财力上支持等。但最重要的是意愿和能力，有了意愿和能力，早晚能够逢山开路，遇水搭桥。
"在你成为领导者之前，成功就是做使自己成长的事；但在你成为领导者之后，成功就是做使他人成长的事” － 杰克·韦尔奇 （Jack Welch）



＂文化＂可以用四句话表达：植根于内心的修养；无需提醒的自觉；以约束为前提的自由；为别人着想的善良。——梁晓声


一位印度老人对孙子说，每个人的身体里都有两只狼，他们残酷地互相搏杀。一只狼代表愤怒、嫉妒、骄傲、害怕和耻辱；另一只代表温柔、善良、感恩、希望、微笑和爱。小男孩着急地问：“爷爷，哪只狼更厉害？”老人回答：你喂食的那一只。— — 你的心所朝的方向就是你未来人生的路。

被人信赖是一笔用金钱买不到的财富。

无趣的不是这个世界，而是我们没有坚持那些有趣的活法。

【保龄球效应】保龄球投掷对象是10个瓶子，你如果每次砸倒9个瓶子，最终得分90分；而你如果每次能砸倒10个瓶子，最终得分240分。社会记分规则就是这样：只要你每次比别人稍微优秀一点，能再多坚持一会，就可能赢得更多机会。这种机会叠加就是人生效应的逐级放大，最终造成人与人之间巨大的落差

这个世界上谁比谁明白的道理少呢。我愈发觉得，所谓“懂事”，不是你手里的人生哲理集有多厚，而是你的情绪和行为控制能力有多强。情绪稳定简直是太牛逼的事儿了，别拼谁更懂，拼谁更能停，谁更能等。

每天花一点钟看10页有用的书，每年可看3600多页书，30年读11万页书。诸位，11万页书足可以使你成为一个学者了。可是，每天看三种小报也得费你一点钟的工夫；四圈麻将又得费你一点钟的光阴。看小报呢？还是打麻将呢？还是努力做一个学者呢？——胡适


如果想成为一颗太阳，那就从尘埃做起；如果想成为一条大江，那就从水滴做起；如果想成为世界瞩目的英雄，那就从最普通、最平凡的人做起。循序渐进永远好过急于求成，每个想法的实现都是通过积累获得。——《微改变》

【脸皮薄的人难以成功】1、我们干大事的从来不要脸。——严介和（太平洋集团前总裁） 2、只有不要脸的人，才会成为成功的人。——任正非（华为总裁） 3、为了面子坚持错误是最没有面子的事情。——巍巍（经济刊物主编）4、当你知道了面子是最不重要的东西时，你便真的长大了。——格瓦拉

不要想太多，定时清除消极思想。

别在喜悦时许诺，别在忧伤时回答，别在愤怒时做决定.

你嘴上所说的人生就是你的人生。“好的”“一定会有办法的”“没问题”，每天都能说出这种积极话语的人，他们的每一天都会过得非常顺利，即使遇到了困难，他们也能够渡过难关。相反，每天听嚷着“太糟了”“太让人气愤了”“没办法了”的人，遇到的挫折也特别多，运气也显得特别糟糕。——佐藤富雄

不吃早餐的人不能委以重任，一个连自己健康都不在意的人不会在意任何项目的细节。

＂注意你所想的，因为它们会变成嘴里的话；注意你所说的，因为它们会变成实际的行动；注意你的行为，因为它们会形成习惯；注意你的习惯，因为它们会形成你的人格；注意你的人格，因为它们会影响你的命运；我们想的是什么，就会成为什么样的人。＂----玛格丽特·希尔达·撒切尔。

爱因斯坦：“If you always do what you always did, you will always get what you always got.”（如果你一直重复过去做过的事情，那么你将只会获得已经拥有的东西。）

所谓坚强，不是在灾难面前不哭，而是要笑着面对以后。——《背包十年》


因为害怕结束，就避免了开始； 因为害怕跌倒，就避免了奔跑； 因为害怕失去，就避免了拥有； 因为害怕伤痛，就避免了相恋； 因为害怕失败，就避免了尝试；因为害怕离别，就避免了欢聚； 因为害怕了害怕，只能不断徘徊着徘徊； 因为避免了避免，只剩失去自己的自己。

"要评估一个人，看他失败后的表现，而不是成功后的表现。" "Judge a man on how he reacts to failure, not success. " -- Martin Luther King

Hope is wishing something would happen. Faith is believing it will happen. Courage is making it happen. “愿望”是希望某事发生。“信念”是相信它会发生。“勇气”是让它发生。

你知道什么叫失败吗？真正失败的人就是那种特别害怕不能成功，连试都不敢试的人。

撑不住的时候，可以对自己说声“我好累”，但不要对自己说“我不行”。

人生最低处有一个好处，就是无论从哪个方向努力，都是向上的。

如果你现在得到的不是你所想要的回报，只能证明你付出的还不够。

如果这世界上真有奇迹，那只是努力的另一个名字。

生活的有趣还在于，你昨日的最大痛楚，极可能会造就你明日的最大力量。 —— 德鲁.巴里摩尔

十年前你是谁，一年前你是谁，甚至昨天你是谁，都不重要。重要的是，今天你是谁，以及明天你将成为谁。Who you were 10 years ago, a year ago, or even yesterday isn't important. What's important is who you are today, and who you'll be tomorrow.

耿耿于怀着过去和忐忑不安着未来的人，也常常挥霍无度着现在。

许多事情只是当时身临其境时很痛苦，其实回过头来想想也没什么。那些当时你觉得快要了你命的事情，那些你觉得快要撑不过去的境地，都会慢慢地好起来。就算再慢，只要你愿意等，它也会成为过去。而那些你暂时不能战胜的，不能克服的，不能容忍的，就告诉自己：凡是不能杀死你的，最终都会让你更强。

学会与自己的伤痛和平共处，这就是成长的意义。

只要你想做成一件事，全世界都会来帮你。 －－《搭车去柏林》

“梦想，可以天花乱坠，理想，是我们一步一个脚印踩出来的坎坷道路。”—《我親愛的三毛》

成长的路上只需全神贯注地努力就好，剩下的交给运气，不好的事情总会过去的

事情一件一件去做 | 夢想先生隨後就到

友善地对待你讨厌的人，正是你成熟的表现。

施人之恩，不发于言。受人之惠，不忘于心。

我一直信奉以下做事的三原则：1）有勇气来改变可以改变的事情；2）有度量接受不可改变的事情；3）有智慧来分辨两者的不同。

A smile is an inexpensive way to improve your looks. 微笑是改善容貌的一种并不昂贵的方式。

很多时候人的差别在于业余时间，而一个人的命运决定于晚上8点到10点之间。每晚抽出2个小时的时间用来阅读、进修、思考或参加有意的演讲、讨论，你会发现，你的人生正在发生改变，坚持数年之后，成功就会向你招手。

不要太把钱当回事，也不要不把钱当回事，它值多少就多少。金钱是一个好仆人，却是一个坏主子。——小仲马



面对别人的优秀时，发自内心地赞美。

成功的秘密就是每天淘汰自己。你不与别人竞争，不意味着别人不会与你竞争；你不淘汰别人，就会被人淘汰。别人进步时你没有进步就等于退步。如果你没有构建任何适应竞争、抗击风险的能力，当下一次危机来临时，你就将第一个倒下！追求安稳，是坐以待毙的开始。

喜欢一个人，一定要让对方知道。也许得不到答案，至少你努力过，不必后悔。

当所有人都拿我当回事的时候，我不能太拿自己当回事。当所有人都不拿我当回事的时，我一定得瞧得上自己。这就是淡定，这就是从容。

“我们必须勇敢地面对可怕的事情，因为我们不可能逃避它们、忘记它们。你越早渡过这一关，越早对自己说，‘是的，事情已经发生，我无能为力。’就越早能开始你自己的生活。” ----安妮·普鲁

Don't worry too much about the ambiguous future, just make effort for explicit being present. 不为模糊不清的未来过分担忧，只为清清楚楚的现在奋发图强。

Everyone knows about principles of life. But it is hard to control blue mood.大道理人人都懂，小情绪却是难以自控

最短命的活法：1.长时间对着电脑 2.晚上十一点以后睡觉 3.不能保证睡眠时间 4.极度缺乏体育锻炼 5.有病不求医 6.吃饭口味偏重，特别喜食咸的和辣的 7.不饿不吃，不困不睡，不累不息 8.与家人缺少交流 9.长时间用手机打电话，享受近距离辐射 10.三餐饮食无规律。

努力赚钱，是为了不让自己的爱情受到别人金钱的考验——这就是现实。

【如果一件事情的成功率是1%，那么反复100次至少成功1次的概率是多少？】备选答案：10%，23%，38%，63%。——正确答案居然是63%，计算方法：成功率1%，失败率即99%，反复尝试100次，失败率99%的100次方约等于37%的失败率，那么成功率即63%。一件事若反复尝试，它的成功率居然可以不可思议的发生质变！

生活最沉重的负担不是工作，而是无聊。——《成成驾到脱口秀》

【如果你感到很迷茫】①先处理心情，再处理事情；②最困难的时候，就是最接近成功的时候；③不为模糊不清的未来担忧，只为清清楚楚的现在努力；④宽容他人对你的冒犯；⑤不要无缘无故的妒忌；⑥只为成功找方法，不为失败找借口；⑦不要看我失去什么，只看我还拥有什么；⑧用最放松的心态对待一切艰难。

青春终究是幸福，因为它有未来。 ——果戈理

每天告诉自己：你的生命非常有限，所以，不要浪费在重复他人的生活上；不要被教条束缚，不要被他人喧嚣的声音掩盖你内心；你要有勇气，听从你心灵和直觉的指示，你的内心知道你想要成为什么样子的。其他事情都是次要的

既然选择了你、我就会去好好的去爱你，我只想好好的爱你，我只想做你的唯一，陪你一起走下去，走到生命停止的那一刻，你若不离不弃、我定生死相随，现在我更明白了什么是珍惜，所以我没轻易放下这段感情。

上班族趴在桌上睡觉易导致青光眼：趴在桌上睡觉，胳膊会压住眼睛，醒后就会出现短暂视力模糊。这是因为压迫到了眼球，造成眼压过高。如果长此以往，还有可能形成青光眼。因此建议，午睡最好躺着睡。可在办公室里备一个颈枕，背靠在椅子上睡，颈椎也能处于跟躺着睡觉时一样自然放松的状态。

死记硬背也许能让你通过大学4年，但会毁掉你接下来的40年。 —— 《三个傻瓜

1.压力最大的时候，效率可能最高。2.最忙的时候，学的东西可能最多。3.最惬意的时候，往往是失败的开始。4.寒冷到了极致时，太阳就要光临。5.少说多做，句句都会得到别人的重视；多说少做，句句都会受到别人的忽视。6.宽容不是软弱而是融合。

1.脾气泄露了你的修养，沉默道出了你的品味。2.当感觉天快塌下来时，实际上是自己站歪了！3.不要把自己看得太强，以致无视外因的成就；不要把自己看的太轻，以致成为他人的踏板。4.总有人会迷失方向，否则真理的路上将人满为患。5.有棱有角的害处是，别人啃起你来十分方便。

每年，至少要去一个从没去过的地方

无论环境多么恶劣，你总还可以做最好的自己，改变不了大环境，就改变小环境，做自己力所能及的事情。你不能决定太阳几点升起，但可以决定自己几点起床！

人生最大的勇敢之一，就是经历欺骗和伤害之后，还能保持信任和爱的能力。

慢慢的，你会养成另外一种心情对付过去的事：就是能够想到而不再惊心动魄，能够从客观的立场分析前因后果，做将来的借鉴，以免重蹈覆辙。一个人惟有敢于正视现实，正视错误，用理智分析，彻底感悟，才不至于被回忆侵蚀。我相信你逐渐会学会这一套，越来越坚强的。——《傅雷家书》

要“八交九不交”：『一』八交：胜己者；盛德者；趣味者；肯吃亏者；直言者；志趣广大者；惠在当厄者，体人者。『九不交』：志不同者；谀人者；恩怨颠倒者；好占便宜者；全无性情者；不孝不悌者；愚人者；落井下石者；德薄者。——所以，你有什么样的朋友，你就是什么样的人。

不要因为一点瑕疵而放弃一段爱情，毕竟爱情——需要的是真情，而不是完美。

想爱就爱了，不要自责，不要顾忌，不要纠结，不要拧巴，不要感叹，不要患得患失…尽量不要…！

无论你的收入是多少，记得分成五份进行规划投资：增加对身体的投资，让身体始终好用；增加对社交的投资，扩大你的人脉；增加对学习的投资，加强你的自信；增加对旅游的投资，扩大你的见闻；增加对未来的投资，增加你的收益。好好规划落实，你会发现你的人生逐步会有大量盈余。

上帝关上了一扇门，必然会为你打开另一扇窗。你失去了一种东西，必然会在其他地方收获另一个馈赠。关键是，我们要有乐观的心态，相信有失必有得。要舍得放弃，正确对待你的失去，因为失去可能是一种生活的福音，它预示着你的另一种获得。大舍大得，小舍小得，不舍不得。

1、每个人都会有不幸的时候，不要怨天尤人，也不要幸灾乐祸。2、每个人都会有幸运的时候，不要忘乎所以，也不要身在福中不知福。3、每个人都有不可理喻的地方，不要苛求别人，也不必埋怨自己。4、每个人都各怀天赋，不要因为鱼不会爬树，就把鱼说成一无所长。

怕什么就会想到什么，信什么就会听到什么，让我们恐惧的，不是外面的世界，而是我们的内心。

恋人之所以会吵架，往往不是感情浅，而是用情深。两个人都深爱时，一点点矛盾都会让人受伤很重。因为太重视对方，所以放不下。其实，如果不爱，分手无所谓。但有感情，还是相互宽解和容忍吧。爱情，没有不吵架的，但底线是不分手。因为爱就是坚持在一起。

有记者问科比：“科比，你为什么如此成功？”科比反问记者：“你知道洛杉矶凌晨4点的样子吗？”记者摇摇头。科比：“我知道每一天凌晨4点洛杉矶的样子。”

生活，就是一种永恒沉重的努力，努力使自己在自我之中，努力不至迷失方向，努力在原位中坚定存在。——米兰·昆德拉《被背叛的遗嘱》

「成事之道」1、事大，须有宏远的观点；事小，须有谨慎的态度；事难，须有无畏的精神；事易，须有珍惜的心情。 2、凡事不着意，则宏伟的大事，变成小事；万事皆有心，则微细的小事，终成大事。 3、缘不聚，则一事难成；缘相聚，则万事俱可。

【格式塔心理疗法】 格式塔心理疗法是心理学中一种修身养性的疗法，归纳为九项原则：1.生活在现在；2.生活在这里；3.停止猜想，面向实际；4.暂停思考，多去感受；5.接受不愉快的情感；6.不要妄断和发表参考意见；7.不要盲目地崇拜偶像和权威；8.我就是我；9.对自己负责。

【人与人之间的差距是这样炼成的】1别人休息的时候，你在加班，或参加各种培训班；2别人嘲笑的时候，你在闷头苦干；3别人想着如何找工作的时候，你在想着如何做得更好；4别人抱怨的时候，你在思考解决之道；5别人在想着归入哪一派时，你在寻求专业突破；6每天坚持写专业心得，参与讨论。

如果脸上长了个疙瘩，我们就会特别注意掩饰，害怕别人注视，总觉得会很难看，其实别人基本上不太关注，看到了也不会有什么负面评价；但对于那些无形的缺点比如自以为是、小气狭隘等，我们常常不加掩饰或改正，以为别人看不到，但恰恰人的本能是看不清自己，却能看清别人，所以会对你的缺点洞若观火。

有人问我怎样才能不浪费时间，我说忘掉时间才是真正的不浪费时间。如果做一件事情专注到忘掉时间，就意味着全心投入。只要这件事情本身是有意义的，就一定会有所成就。凡是我们每天赶时间的事情，大部分是没有意义浪费时间的事情。

亚马逊CEO杰夫-贝索斯说：善良比聪明更难。聪明是一种天赋，而善良是一种选择。天赋与生俱来，选择则颇为不易。你可能被天赋所诱惑，这可能会损害到你做出的选择。

很多人面对未来，总是左思考右打算，就是不敢迈开大步向前走。其实规划好的人生并不多，义无反顾勇敢向前的人常常得到更多，走得也更远。生命的远行不需要太多的准备，上帝给你两条长腿和坚实的脚掌，就是为了让你前行。向哪里走？让心告诉你。考研、出国、工作都会有前途。不同的路不同的风景。

《成熟定律》 1果实的成熟不是颜色美丽,而是味道甘甜;2孩子的成熟不是年龄长大,而是独立克制;3女人的成熟不是能力非凡,而是温良贤淑;4男人的成熟不是圆融处世,而是善于担当;5性格的成熟不是心平气和,而是能屈能伸;6领导成熟的标志,不是发号施令,而是能听不同的声音。

一个优秀人物的八大特征：1、热爱生命，相信未来；2、对工作专注、喜欢并创造性发挥；3、关心他人感受；4、追求成就感和荣誉感；5、进取心强，不断学习成长；6、对于财富、名声、权力没有过分的贪欲，得失之间天高云淡；7、真诚、坦率、阳光的个性；8、自己当人看，但不把自己太当人看。

有人问我怎样才能不浪费时间，我说忘掉时间才是真正的不浪费时间。如果做一件事情专注到忘掉时间，就意味着全心投入。只要这件事情本身是有意义的，就一定会有所成就。凡是我们每天赶时间的事情，大部分是没有意义浪费时间的事情。

1.一杯清水因滴入一滴污水而变污浊,一杯污水却不会因一滴清水的存在而变清澈。2.最小的善行也会胜过最大的善念。3.世界没有悲剧和喜剧之分,如果你能从悲剧中走出来,那就是喜剧,如果你总沉缅于喜剧之中,那它就是悲剧。4.真正的朋友不是在一起有聊不完的话,而是不说一句话也不觉得尴尬。

1.时间是治疗心灵创伤的大师,但绝不是解决问题的高手。2.人生三不斗:不与君子斗名，不与小人斗利，不与天地斗巧。人生三不争:不与上级争锋，不与同级争宠，不与下级争功。人生三大憾事:遇良友不交，遇良机不握，遇好书不读。

目标和梦想是成长的核心成分。 勤奋学习和努力工作是成长的必经之路。 征服的勇气和愉悦的心情是成长的营养剂。 不断的阅读和独立思考是成长的加速器。

自信来自于内心，而不是来自于和别人的比较，和别人比较永远不可能带来真正的自信。比较的结果不是产生虚妄的优越感，就是产生强烈的自卑感。这两种感觉和真实的你无关，也和自信无关。自信是一种自我肯定，肯定自己在某些方面能够做得比较出色，而不是在所有方面都比别人好。

但求成长，不求成功，让成功成为成长的必然结果，这就是成功最正确的道路。如果我们只向往作为结果的成功，人生必然拔苗助长，最后枯萎而死。一只蝴蝶飞向天空，展示了她所有的美丽，但在美丽的背后，她曾经有过毛毛虫笨拙的爬行，织丝成茧的辛劳，在黑暗之中的等待和化蛹成蝶的痛苦。

当你打算放弃梦想时，告诉自己再多撑一天、一个星期、一个月，再多撑一年吧。你会发现，拒绝退场的结果令人惊讶。---力克.胡哲

1凡事第一反应找方法，不是找借口。2养成记录习惯，好记性不如烂笔头。3每天自我反省。4用心倾听，不打断别人的话，作个倾听高手。5遵守诚信，说到做到。6时刻微笑待人处事。7无论什么会议都找前排坐。

爱情如果不落到穿衣、吃饭、睡觉、数钱这些实实在在的生活中去，是不会长久的。真正的爱情，就是不紧张，就是可以在他面前无所顾忌地打嗝、放屁、挖耳朵、流鼻涕；真正爱你的人，就是那个你可以不洗脸、不梳头、不化妆见到的那个人。——三毛

人之一生，如负重远行，不可急于求成；以受约束为常事，则不会心生不满；常思贫困，方无贪婪之念；忍耐乃长久无事之基石；愤怒是敌；只知胜而不知败，必害其身；常思己过，莫论人非；不及尚能补，过之无以救。

真正相爱的人是不需无时不刻在一起的，他们需要精神上的沟通和默契。他们尊重对方的生活方式，同时拥有自己的人格和世界。他们不会溺在一起，因为过分的依赖，特别是对他人身体、时间、空间、物质的无度占据，不是爱，是身心不独立的表现。不占有、不控制、而是精神契合

乔布斯年轻时每天凌晨四点起床，九点半前把一天工作做完。他说：自由从何而来？从自信来，而自信则是从自律来！先学会克制自己，用严格的日程表控制生活，才能在这种自律中不断磨练出自信。自信是对事情的控制能力，如果你连最基本的时间都做控制不了，还谈什么自信？

什么样的工作比较可能给你快乐?第一,它给你意义;第二,它给你时间;你的工作是你觉得有意义的，你的工作不绑架你使你成为工作的俘虏,你就比较可能是快乐的。当你的工作在你心目中有意义,你就有成就感。当你的工作给你时间,不剥夺你的生活,你就有尊严。成就感和尊严,给你快乐。——龙应台《亲爱的安德烈》

对于大多数人来说，生活是由环境决定的。他们在命运的拨弄面前，不仅逆来顺受，甚至不能随遇而安。我尊重这些人，可我并不觉得他们令人振奋。还有一些人，他们把生活紧紧地掌握在自己手里，似乎一切要按照自己的意愿去创造生活。这样的人虽然寥若星辰，却深深吸引着我。——毛姆《生活的道路》

【电子简历小建议】1. 联络信息中强调电子邮件；2. 清晰简明地表述职业目标；3. 可以插入视频或音频；4. 将个人能力放到更明显区域；5. 详细描绘工作经验和工作业绩，注意应包括所有关键字；5. 将学历、专业和毕业院校集中在一行；6. 最好在最后包含推荐人信息；7. 最终命名时应与求职工作相关。

【10招帮你赢取上司最佳印象】1、早到；2、从不以“这不是我份内的工作”为由逃避责任；3、面对艰巨任务时淡定；4、立刻动手；5、口风紧；6、听从上司的临时指派；7、拿着解决方案汇报工作；8、以无欲的心态做事；9、善于在关键时候作出果断决定；10、专业及相关信息丰富。

【如何成为一个高效的人】1）将自己的表拨快10分钟。2）为目标设定像1-2-3这样的优先级。3）把大目标细分为可以立刻执行出结果的小任务。4）第一次就做对。5）每天自学1小时，一年365小时，3年可成专家。6）每周5天，每天花5分钟改进自己的工作，在5年里将使同一个工作被改进1200余次。

一个人怎么看待自己，决定了此人的命运，指向了他的归宿。我们的展望也这样，当更好的思想注入其中，它便光明起来。不管你的生命多么卑微，你要勇敢地面对生活，不用逃避，更不要用恶语诅咒它。—— 梭罗《种子的信念》

陈道明说，好男人的基本标准：不一定要浪漫，但一定要负责任。不一定要挣大钱，但一定要养家。不一定要事事听父母，但一定要有孝心。不一定要三从四德，但一定要宠老婆。不一定要飞黄腾达，但一定要有时间陪家人。不一定要管孩子，但一定要爱孩子。不一定要大男子主义，但大事发生一定要拿得了主意。

【摆脱“穷忙”人生的十大黄金定律】1、思考你想要的生活；2、明白你为谁工作；3、找到“穷”与“富”，“忙”与“闲”的平衡；4、你必须积累财富；5、适时地控制欲望；6、清晰的人生规划；7、持久的耐力；8、良好的人际关系氛围；9、培养自己的业余爱好；10、不断挑战自己。

你的父母正在为你打拼，这就是你今天坚强的理由。


【如何保持年轻】1. 保持求知若渴：不光对知识，也应积极向身边优秀的人才学习，不论年龄大小；2. 保持热情和能量：时常微笑，正能量会感染周围员工；3. 保持好奇心：通过好奇继续学习、成长；4. 不被规则束缚：勇于尝试新想法；5. 看到每个人的优点：挖掘员工潜能。

我渴望能见你一面，但请你记得，我不会开口要求要见你。这不是因为骄傲，你知道我在你面前毫无骄傲可言，而是因为，唯有你也想见我的时候，我们见面才有意义。—— 西蒙娜·德·波伏娃

无论你犯了多少错，或者你进步得有多慢，你都走在了那些不曾尝试的人的前面。No matter how many mistakes you make or how slowly you progress, you are already ahead of those who never tried.

读大学的价值也许在，能认识未来几十年最重要的朋友，能分辨哪些人自己一辈子都不会交往，能集中解决很多困惑，从而形成自己的原则，开始学会拒绝。读大学的价值也在于你明白世界上有很多优秀的人，你开始有靠近的动力。读书，不是为了拿文凭或发财，而是成为一个有温度懂情趣会思考的人。

那个第一个向我表白的人，谢谢你让我知道了人生的第一次被爱。

“自信来源于成功的暗示；自卑来源于失败的暗示。” 如果你有自信，它会在无形之中释放出能量，推动你走向成功；如果你自卑或恐惧，它也会在无形之中释放出能量，导致你走向失败。成功的人会因为体验到成功的快乐而更加自信；失败的人也会因为体验到失败的痛苦而更加自卑。

不要轻言你是在为谁付出和牺牲，其实所有的付出和牺牲最终的受益人都是自己。人生是一场与任何人无关的独自的修行，这是一条悲欣交集的道路，路的尽头一定有礼物——就看你配不配得到。——卡玛《人生是一场独自的修行》

【什么是人脉?】1）人脉不是你利用多少人，而是你帮助多少人！2）人脉不是多少人在面前吹捧你，而是多少人在背后称赞你！3）人脉不是辉煌时多少人奉承你，而是落魄时多少人愿意帮助你！4）人脉不是你认识多少人，而是多少人认识你！5）人脉不是你和多少人打过交道，而是多少人愿意主动和你打交道！

【想上进就去努力培养，别说很难】 1.培养自信的语言 2.让你的笑容像阳光一样 3.紧张的时候深呼吸 4.别为小事生气 5.学会控制自己的情绪 6.悲观时，进行自我暗示 7.每天自省一小时 8.戒烟戒酒，戒掉恶习 9.永远是跑步一族 10.定期体检，为健康护航 11.养成不屈不挠的风格 12.记住别人的姓名。

【如何让自己强大】斯坦福大学教授杰弗瑞·菲佛的建议是：1、别信某人天生具备领导才能，那是鬼话；2、不要人见人爱；3、和老板的关系比业绩重要；4、帮助强者；5、建立有效的关系网，但不拉帮结派；6、接近核心资源；7、准确的自我评价；8、提早行动；9、别害怕发火；10、准确的自我评价。

我很庆幸生在这样一个家庭，即非富二代也非官二代，但我有衣服穿，有书读，不会挨饿。爸爸妈妈给了我能力范围内最好的生活，虽然不是ipad3也不是LV，但足够让我出去走走。比起花别人的钱却瞧不起别人的人，我宁愿自己努力改变生活。这样的人生我很喜欢，再来一次我还会选。

“出发时，你们就要定下高目标，不断努力。我希望你们找到生命中真正的意义、快乐和激情。希望你们能安渡艰难时光，并收获更强的力量与更坚定的决心。希望你们能怀着进取之心，在事业里全心投入，去掌控世界。因为世界需要你们去改变！”——facebook 首席运营官 谢丽尔·桑德伯格

临危而不惧，途穷而志存；苦难能自立，责任揽自身；怨恨能德报，美丑辩分明；名利甘居后，为理愿驰骋；仁厚纳知己，开明扩胸襟；当机能立断，遇乱能慎行；忍辱能负重，坚忍能守恒；临弱可落泪，对恶敢拼争；功高不自傲，事后常反省；举止终如一，立言必有行。——南怀瑾

【改变命运的十个途径】①比大多数人勤奋认真。②做好每一件小事。③微笑面对命运的不公。④时间比金钱重要。⑤养成好习惯，习惯决定命运。⑥不断与人性弱点斗争。⑦天才都是有心人。⑧机会无大小，只有时间早晚，永不嫌弃小机会。⑨等待大机会是痴心妄想。⑩坚持不懈锻炼身体。

施人之恩，不发于言。受人之惠，不忘于心。

** 语录：心灵鸡汤

时光静好，与君语；细水流年，与君同；繁华落尽，与君老。
1，再难也要坚持。2，再好也要淡泊。3，再差也要自信。4，再多也要节省。5，再冷也要热情。
情不知所起，一往而深。恨不知所踪，一笑而泯。
Sometimes a winner is just a dreamer that never gives up.——有时候，成功者只是坚持梦想不放弃的人。
大学里应该去去想去的地方，读读应该读的书，逃一逃想逃的课，追一追想追的人，喝一喝想喝的酒，打一打想打的架，都是些健康快乐、充沛的事情。大学要做些什么，就是要做些在30岁、40岁之后回想起来，依然能够感到热泪盈眶的事情，这就是大学，这就是青春时代应该做的事情。
你现在的付出，都会是一种沉淀，它们会默默铺路，只为让你成为更好的人
别抱怨了，要怪就怪自己。有本事喜欢上别人，没本事让人家喜欢你。
感觉累的时候，也许你正处于人生的上坡路。坚持走下去，你就会发现到达了人生的另一个高度。
曾经输掉的东西，只要你想，就一定可以再一点一点赢回来！
大部份的痛苦，都是不肯离场的结果，没有命定的不幸，只有死不放手的执着。—— 素黑
不要因为也许会改变就不肯说那句美丽的誓言；不要因为也许会分离就不敢求一次倾心的相遇。——席慕容
无痛不快，无苦何甜，活着，本就是一种修行。.
你必须很努力，才能做到看起来毫不费力。
将来的你，一定会感谢现在拼命努力的你。
学着坚持自己认定的事，不要管别人怎么说，人活着，不是要取悦别人。
生命中总有那么一段时光，充满不安，可是除了勇敢面对，我们别无选择。
旅行最大的好处，不是能见到多少人，见过多美的风景，而是走着走着，在一个际遇下，突然重新认识了自己。
青春就是疯狂地奔跑，然后华丽地跌倒。
我想，如果你有那么一点点喜欢我，就一点点，我也会有勇气去争取。可是，我也不知道怎么去分辨，生怕或许我以为的表示，也只是自己的自作多情。这样的自己，就会显得那么的渺小而力不从心。当对某人放进了感情，那么在他/她面前，你就像个神经，会惶恐，会不安，会焦虑，会患得患失。
成功人生四步曲：1、耐住寂寞；2、抵住诱惑；3、懂得放弃；4、学会选择。
永不期待，永不假设，永不强求。顺其自然，若是注定发生，必会如你所愿。
The person who can make you feel better is also the reason why you cry..能让你好起来的那个人通常也是那个让你哭的人。
当你害怕失去一样东西时，这意味着，你只能要么放弃这样东西，要么放弃你自己。
当你真心相信一切都会好的时候，一切就会真的好了。
时间很短，天涯很远。往后的一山一水，一朝一夕，自己安静地走完。倘若不慎走失迷途，跌入水中，也应记得，有一条河流，叫重生。这世上，任何地方，都可以生长；任何去处，都是归宿。那么，别来找我，我亦不去寻你。守着剩下的流年，看一段岁月静好，现世安稳。——白落梅
世界真的很小，好像一转身，就不知道会遇见谁；世界真的很大，好像一转身，就不知道谁会消失。
在乎才会乱想，不在乎连想都不会想。
【人生智慧】1.机遇总是有的，如果把握不住，不要怨天忧人，只因自己不够优秀；2.不要把时间当垃圾处理，唯有珍惜光阴，才能提升生命的质量；3.两点之间未必直线最短，有时迂回曲折能够更快地抵达终点；4.如果错了，那就停止，如果得不到，那就放弃；5.赶路并非越快越好，把握正确的方向最重要。
趁年轻，走自己想走的路。没理由，不去闯。
你是什么人便会遇上什么人；你是什么人便会选择什么人。——竹久梦二《出帆》
有些人，有些事，该忘就忘了吧，人家从没把你放心里过，你又何必自作多情。
要学会在轻淡无形，不给别人施加压力的情况下去爱一个人。很好的爱一个人需要经过漫长的时间，甚至用一生的时间才能办到——保持足够距离，拥有适宜的谦卑。——梅·萨藤《独居日记》
Hope的含义: Hold On, Pain Ends. 坚持住, 痛苦终会过去。
如果你不快樂，那就出去走走、世界這么大。風景很美、機會很多、人生很短，不要捲縮在一處陰影中。
越有本事的男人，越没脾气。
人总是在接近幸福时倍感幸福，在幸福进行时却患得患失。——张爱玲
如果你想任性，那就先学会承受，能承受后果才可以任性。如果你想独立，那就先学会坚强，能忍住伤痛，才可以独立。如果你想放肆的爱，那就先学会遗忘，忘掉失恋痛楚，才可以大胆爱。你可以去做一切事情，但前提是不会为结果伤悲。一个人真正的强大，并非看他能做什么，而是看他能承担什么。
正如故乡是用来怀念的，青春就是用来追忆的，当你怀揣着它时，它一文不值，只有将它耗尽后，再回过头看，一切才有了意义——爱过我们的人和伤害过我们的人，都是我们青春存在的意义。——《致我们终将逝去的青春》
与其热闹着引人夺目，步步紧逼，不如趋向做一个人群之中真实自然的人，不张扬，不虚饰，随时保持退后的位置。心有所定，只是专注做事。——安妮宝贝《素年锦时》
忘记一个人，并非不再想起，而是偶尔想起，心中却不再有波澜。
如果你看到面前的阴影，别怕，那是因为你的背后有阳光。
我们必须接受失望，因为它是有限的，但千万不可失去希望，因为它是无穷的。
没有谁能一路单纯到底，但要记住，别忘了最初的自己。
越有故事的人越沉静简单，越肤浅单薄的人越浮躁不安
二十岁到三十岁这段时间，是人生中最艰苦的一段岁月------ 逐渐退去学生的身份，承担着渐长的责任，或许拿着与工作量不匹配的薪水，艰难的权衡事业和感情，不情愿的建立人脉…但你总得撑下去，上天只会给我们能过得去的坎...
傻逼样的去坚持，自会看见牛逼的结果
“愿望”是希望某事发生。“信念”是相信它会发生。“勇气”是让它发生。
“预测未来的最好方法就是创造未来。” -- Alan Kay
自爱，沉稳，而后爱人。 ———亦舒
摔倒了又怎样，至少我们还年轻。
青春是一场无知的奔忙，总会留下颠沛流离的伤，我多么希望明天有太阳，灼烧我那腐烂的梦想。
总有些事，管你愿不愿意，它都要发生，你只能接受；总有些东西，管你躲不躲避，它都要来临，你只能面对
人所受苦的根源就是来自于不清楚自己是谁，而盲目地去攀附、追求那些不能代表我们的东西。——张德芬
一个人二十岁出头的时候，除了仅剩不多的青春以外什么都没有，但是你手头为数不多的青春却能决定你变成一个什么样的人。这个世界那么多不顺心的事情又能怎么样，对他们说一句fuck you，然后继续努力做好自己应该做的事情。——《要么滚回去，要么拼命》
我喜欢香蕉，可是你给了我一车苹果，然后你说你被自己感动了，问我为什么不感动。我无言以对，然后你告诉全世界，你花光了所有的钱给我买了一车苹果，可是我却没有一点点感动，我一定是一个铁石心肠的人！我的人品确定是有问题的！我只是喜欢香蕉而已啊。。——借此言送给那些对爱情盲目执着的人


不懂得自爱的人，就没有能力去爱别人

When someone appears in your dreams, it means that person misses you. ~~~当某人出现在你的梦里，意味着那个人在想你。

叫你滚你就滚啊 不知道过来抱紧一点就没事了吗

情不知所起，一往而情深，怎奈何，如花美眷，终不敌，似水流年。

When you're about to say goodbye, think twice, look back, and remember how hard it was to say hello. 当你想说再见的时候，请三思，请回回头，想想当初遇见的时候是多么不容易。

每个人的内心都有一座孤城，里面住着一个想赶也赶不走的人。

学生问追一个女孩总是追不上怎么办？我回答：女孩不是追来的，是吸引来的，你追的过程是吸引女孩的过程，如果女孩没有看上你，再追都是没有用的。也许用更多的时间丰富自己，让自己变得更有内涵，再出现在女孩面前，她就喜欢你了。另外，爱是有缘分的，哪怕再有内涵气质的人，也不能让所有女孩喜欢。



你能明白，只要一想起某个人，心就会绞着疼的那种感觉吗？——《分手合约》
爱情的十分之九是由爱人自己造成的，十分之一才靠那被爱的对象。——莫洛亚
“那个第一个向我表白的人，谢谢你让我知道了人生的第一次被爱。 ”——《听见涛声》
有件事我们必须明白：从现在到30岁，我们都必须为生活而进行各种尝试，防止堕落。置身于生活之中。我必须打一场漂亮的战争，我们一定要成为有出息的人，尽管现在我们都没有。直觉告诉我：我们一定能干一番大事业，一定会与别人不一样。—— 《梵高书信集》
没有抛弃人的梦想，只有抛弃梦想的人，再牛逼的梦想，也抵不住傻逼似的坚持！
我不管这个世上的人怎麼说我...我只想依照我的信念做事，绝不后悔，不管现在将来都一样! ——罗罗亚·索隆
得按你想的去生活，否则，你迟早会按你生活的去想。——连岳
再苦再累，也要坚持，因为我知道生活就是这样的残酷现实，我除了坚持，还得坚持。
做人最高境界不是一味低调，也不是一味张扬，而是不卑不亢。
人生如路，须在荒凉中走出繁华的风景来。——七堇年
有些事情不是看到希望才去坚持，而是坚持了才会看到希望。
Be crazy. Be stupid. Be weird. Be whatever. Because life is too short to be anything but happy.疯就疯吧，笨就笨吧，怪就怪吧，想怎么样就怎么样。生命短暂，快乐至上。
每个人都要有个骨灰级的爱好。
所谓成功，就是不停地经历失败，并且始终保持热情。
年轻的时候最大的财富不是你的青春，你的美貌，也不是你的充沛的精力，而是你有犯错误的机会。如果年轻的时候你都不能追随自己心里强烈的愿望，去为自己认为值得干的事冒一次风险，哪怕是犯一次错误的话，那青春多么苍白呀！——杨澜
有关的人太多，所以还不如做一个想要做的人，人生都太短暂，去疯去爱去孤单一场，真正能平静自己的只有自己。人都是孤独的，孤独不可怕，可怕的是惧怕孤独。想要摘星星的孩子，孤独是我们的必修课，我不怕自己努力了不优秀，我只怕比我优秀的人比我更努力。—— 《孤独是你的必修课》
别让怯弱否定自己，别让懒惰误了青春。
每一个不曾起舞的日子，都是对生命的辜负。
It's never too late to be what you might have been.勇敢做自己，永远都不迟。（乔治·艾略特）
你要克服的是你的虚荣心，是你的炫耀欲，你要对付的是你的时刻想要冲出来想要出风头的小聪明。—— 毛姆



* Week
** 2016/01/21
*** openwrt                                                :openwrt:路由器:

- [[https://zh.wikipedia.org/wiki/OpenWrt][Wiki]]
- [[https://openwrt.org/][Homepage]]
- [[http://post.smzdm.com/p/99210/][树莓派&OpenWrt]]


1. what?

   基于 Linux 的开源路由器(应用于嵌入式的 Linux 发行版本)

2. history

   2003年底推出WRT-54G，是一款基于MIPS架构的无线路由器，并且使用
   802.11g标准使得带宽在理论上能够达到54M，在当时是一次巨大的成长。
   WRT-54G操作系统以Linux取代vXworks，哥伦比亚大学法学院教授Eben
   Moglen向Linksys提出开源要求。2003年7月，Linksys迫于压力，开源了
   WRT54G的firmware，不久sveasoft公司开发了Alchemy。从此无线路由器进入
   了可以刷机的时代。

3. application

   - 用于脱机离线下载。
   - VPN服务器。
   - SSH服务器。
   - Shadowsocks配合Pdnsd、Chinadns、Dnscrypt软件智能突破网络审查。
   - 动态DDNS。
   - 单线多拨及带宽叠加。
   - QOS智能限速（从石像鬼中提取）。
   - 远程视频监控。

*** tag 分类

标签的性质
1. 对象本身（普通）
2. 对象属性（普通）
3. 对象组件（普通）
4. 对象范畴 ： 大写
5. GTD 标签 ： 下划线开头的标签为特殊标签

需要定点提前准备东西的任务，打上 _preparation 的标签

** 2016/01/20
*** dpkg error                                                      :error:

https://www.ubuntu.org.cn/viewtopic.php?f=86&t=54689&p=2260127

1. error
   #+BEGIN_EXAMPLE
     ImportError: No module named 'ConfigParser'
     dpkg: 处理软件包 python-markupsafe (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     dpkg: 依赖关系问题使得 python-mako 的配置工作不能继续：
      python-mako 依赖于 python-markupsafe；然而：
       软件包 python-markupsafe 尚未配置。

     dpkg: 处理软件包 python-mako (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 依赖关系问题使得 gobject-introspection 的配置工作不能继续：
      gobject-introspection 依赖于 python-mako；然而：
       软件包 python-mako 尚未配置。

     dpkg: 处理软件包 gobject-introspection (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 依赖关系问题使得 libgirepository1.0-dev 的配置工作不能继续：
      libgirepository1.0-dev 依赖于 gobject-introspection (= 1.42.0-2.2)；然而：
       软件包 gobject-introspection 尚未配置。

     dpkg: 处理软件包 libgirepository1.0-dev (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 依赖关系问题使得 libpeas-dev 的配置工作不能继续：
      libpeas-dev 依赖于 libgirepository1.0因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
                               因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
                   由于已经达到 MaxReports 限制，没有写入 apport 报告。
                                                                       由于已经达到 MaxReports 限制，没有写入 apport 报告。
                                           由于已经达到 MaxReports 限制，没有写入 apport 报告。
               -dev (>= 0.10.1)；然而：
       软件包 libgirepository1.0-dev 尚未配置。

     dpkg: 处理软件包 libpeas-dev (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 处理软件包 python-oneconf (--configure)时出错：
      该软件包正处于非常不稳定的状态；
     您最好在配置它之前，先重新安装它
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     dpkg: 处理软件包 python-markupsafe (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     正在设置 python-oneconf (0.3.7.15.04.1) ...
     Traceback (most recent call last):
       File "/usr/bin/pycompile", line 35, in <module>
         from debpython.version import SUPPORTED, debsorted, vrepr, \
       File "/usr/share/python/debpython/version.py", line 24, in <module>
         from ConfigParser import SafeConfigParser
     ImportError: No module named 'ConfigParser'
     dpkg: 处理软件包 python-oneconf (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     dpkg: 依赖关系问题使得 software-center 的配置工作不能继续：
      software-center 依赖于 python-oneconf (>= 0.3) | oneconf (<< 0.3)；然而：
       软件包 python-oneconf 尚未配置。
     系统中 oneconf 的版本为 0.3.7.15.04.1。

     dpkg: 处理软件包 software-center (--configure)时出错：
      依赖关系问题 - 仍未被配置
     正在设置 youtube-dl (2015.02.28-1) ...
     因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
                                                                         Traceback (most recent call last):
       File "/usr/bin/pycompile", line 35, in <module>
         from debpython.version import SUPPORTED, debsorted, vrepr, \
       File "/usr/share/python/debpython/version.py", line 24, in <module>
         from ConfigParser import SafeConfigParser
     ImportError: No module named 'ConfigParser'
     dpkg: 处理软件包 youtube-dl (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     由于已经达到 MaxReports 限制，没有写入 apport 报告。
                                                         在处理时有错误发生：
      python-markupsafe
      python-oneconf
      software-center
      youtube-dl

   #+END_EXAMPLE

2. solution 1

   #+BEGIN_EXAMPLE
   sudo apt-get remove -f
   #+END_EXAMPLE

   无效

3. 终极暴力解法

   删除 */var/lib/dpkg/status* 中有关那个软件的安装信息
   和 */var/lib/dpkg/info* 目录下那个软件包的几个文件
   这个应该是 =终极方法= ，不过， *使用之前注意备份就是了*

   #+BEGIN_EXAMPLE
     wally@ info $ ls | grep youtube-dl
     youtube-dl.conffiles
     youtube-dl.list
     youtube-dl.md5sums
     youtube-dl.postinst
     youtube-dl.prerm
     wally@ info $ sudo find . -name "youtube-dl.*" -exec mv {} {}.20160120.1.bak \;
     wally@ info $ ls | grep youtube-dl
     youtube-dl.conffiles.20160120.1.bak
     youtube-dl.list.20160120.1.bak
     youtube-dl.md5sums.20160120.1.bak
     youtube-dl.postinst.20160120.1.bak
     youtube-dl.prerm.20160120.1.bak
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
      $ sudo apt-get -f install
     正在读取软件包列表... 完成
     正在分析软件包的依赖关系树
     正在读取状态信息... 完成
     下列软件包是自动安装的并且现在不需要了：
       libffi-dev linux-headers-3.19.0-15 linux-headers-3.19.0-15-generic linux-image-3.19.0-15-generic linux-image-extra-3.19.0-15-generic
     使用'apt-get autoremove'来卸载它(它们)。
     升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。
     有 4 个软件包没有被完全安装或卸载。
     解压缩后会消耗掉 0 B 的额外空间。
     正在设置 python-markupsafe (0.23-1) ...
     正在设置 python-oneconf (0.3.7.15.04.1) ...
     正在设置 software-center (13.10-0ubuntu6.1) ...
     正在设置 youtube-dl (2015.02.28-1) ...
   #+END_EXAMPLE

   测试 OK

*** [[http://askubuntu.com/questions/144905/virtualbox-windows-key-pass-through-to-gnome][VirtualBox 解除 win 键占用]]

1. 出发点

   使用 Ubuntu 时要经常使用 Win + Num 组合键在 Emacs，shell, Chrome 等
   窗口之间切换。当切换到虚拟机时，该组合键失效。

   Win+1 EmacS
   Win+2 Shell
   Win+3 Chrome
   Win+4 File
   Win+5 VirtualBox

   补充： 还有 Alt+Tab 键

2. 设置

   #+BEGIN_EXAMPLE
     Open the VirtualBox Manager window, and go to "File" menu,
     "Preferences" (Ctrl-G).
     Under "Input", uncheck the box labeled "Auto Capture
     Keyboard". There is no need to restart the VM if it's running, so
     this can be changed "on the fly".
   #+END_EXAMPLE

   #+DOWNLOADED: file:///home/wally/Desktop/2016-01-20%2015:12:44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png @ 2016-01-20 15:13:10
   [[~/Wally/Journal/Figure/.org-download/Tasks/2016-01-20%2015:12:44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2016-01-20_15:13:10.png]]

   Note: 在 Virtual Box 的管理窗口中，而不是虚拟机窗口中。

3. 测试 OK

*** .build 文件夹                                                   :trick:

1. 出发点

   从源码编译安装的软件或库一般都完成后删除。这样节省存储空间，并不是
   最优的。

   因为有的时候需要使用 make 的其他选项
   - 最常用的是 unintall (dpkg 对源码安装的软件无效)
   - 其次，make doc, 比如 PCL 库的 doxygen 文档

2. trick

   建立 $HOME/.build 目录，用来
   1) 临时存放源码
   2) 暂存编译安装信息
   3) 定期确认并清理

*** HTML 参考文档                                                   :trick:

1. 出发点

   PDF 是我最喜欢的文档格式，可视化良好，恰到好处的可编辑功能。

   HTML 文件是 Doxygen 生成文档可视化最好的格式，但在线看往往不方便，
   也不能使用 org-mode 建立链接或索引。

2. 在 Referece/HTML 文件夹下保存所有 HTML 格式的参考文档

*** org-tag-view

搜索标签常用。

绑定在 C-c a m 太慢

#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "<f12>") 'org-tags-view)
#+END_SRC
** 2016/01/18
*** blender

- [[https://www.blender.org/manual/zh.cn/getting_started/index.html][Blender 官方入门教材（中文）]]
- [[https://zh.wikibooks.org/zh-cn/Blender_3D%EF%B8%B0%E5%BE%9E%E5%85%A5%E9%96%80%E5%88%B0%E7%B2%BE%E9%80%9A][Blender 3D︰从入门到精通(wikibook)]]
- [[http://wiki.blender.org/][Homepage]]

*** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

*** PCL

#+include: ~/Wally/Project/pcl_tutorials

http://www.pointclouds.org/documentation/tutorials/

**** [[http://www.pointclouds.org/documentation/tutorials/basic_structures.php#basic-structures][Basic Structure]]

*PointCloud*

- width
- height
- points
- is_dense
- sensor_origin
- senor_orientation

To simplify development, the PointCloud class contains a number of
helper member functions. For example, users don’t have to check if
height equals 1 or not in their code in order to see if a dataset is
organized or not, but instead use *PointCloud()*:

#+BEGIN_SRC cpp
if (!cloud.isOrganized ())
#+END_SRC

***** writing point cloud data to PCD files

#+include: ~/Wally/Project/pcl_tutorials/src/pcd_write.cpp

头文件位置 =/usr/include/pcd-1.7/pc/=

#+BEGIN_SRC cpp
#include <pcl-1.7/pcl/io/pcd_io.h>
#include <pcl-1.7/pcl/point_types.h>
#+END_SRC

创建 link

#+BEGIN_EXAMPLE
 ~ $ ls -l /usr/include/pcl
lrwxrwxrwx 1 root root 24  1月  7 09:53 /usr/include/pcl -> /usr/include/pcl-1.7/pcl
#+END_EXAMPLE

***** CMakeLists.txt

#+include: ~/Wally/Project/pcl_tutorials/CMakeLists.txt

**** [[http://www.pointclouds.org/documentation/tutorials/voxel_grid.php#voxelgrid][Downsampling a PointCloud using a VoxelGrid filter]]


- *downsample*: reduce the number of points
- using a *voxelized grid* approach

#+include: ~/Wally/Project/pcl_tutorials/src/voxel_grid.cpp

**** Merging PCDs
***** concatenate the points of two points clouds

http://pointclouds.org/documentation/tutorials/concatenate_clouds.php

#+include: ~/Wally/Project/pcl_tutorials/src/concatenate_clouds.cpp

** 2016/01/17
*** scratch                                                       :scratch:

**** intro                                                         :intro:

Scratch是麻省理工大学媒体实验室终身幼稚园组开发的一套电脑程序开发平台，
旨在让程序设计语言初学者不需先学习语言语法便能设计创作产品。开发者期望
通过学习Scratch，启发和激励用户在愉快的环境下通过实验（如设计交互故事）
去学习程序设计、数学和计算知识，同时获得创造性的思考，系统推理，和协同
工作的体验。

Scratch 开发平台可安装在Mac OS X、Windows、Linux的平台上；自2.0之后，
换用Actionscript编制，Scratch运行于浏览器。Scratch源码开放给非商业性质
用途使用。


#+DOWNLOADED: https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Scratchcat.svg/180px-Scratchcat.svg.png @ 2016-01-18 11:17:22
 [[~/Wally/Journal/Figure/.org-download/Journal/180px-Scratchcat.svg_2016-01-18_11:17:21.png]]

**** keyword                                                     :keyword:

scratch, MIT, 教育软件， 跨平台， 开源

**** reference                                                  :homepage:

- [[https://zh.wikipedia.org/wiki/Scratch%E8%AF%AD%E8%A8%80][Wikipedia: scratch 语言]]
- [[https://scratch.mit.edu/][Homepage]]
- [[http://cacm.acm.org/magazines/2009/11/48421-scratch-programming-for-all/fulltext][Scratch: Programming for All]]

*** godot                                                           :godot:

**** reference                                                  :homepage:

- [[http://www.godotengine.org/projects/godot-engine][Homepage]]
- [[https://github.com/godotengine/godot][Github]]

**** intro                                                         :intro:

Godot is a fully featured, open source, MIT licensed, game engine. It
focuses on having great tools, and a visual oriented workflow that can
export to PC, Mobile and Web platforms with no hassle. The editor,
language and APIs are feature rich, yet simple to learn, allowing you
to become productive in a matter of hours.

[[/home/wally/Wally/Journal/Figure/scrot/32504Cqi.png]]


开源游戏引擎

*** ccmake intro                                             :ccmake:intro:

- [[http://blog.csdn.net/arackethis/article/details/42155589][CMake 和 CCMake 的区别]]

CCMake is the GUI for manipulating files generated by / used by the
cmake system.

- ccmake is curses (terminal handling library) interface to CMake.

- cmake is the CLI (Command Line Interface)
*** metapost

http://www.ctex.org/documents/shredder/metapost.html

http://www.ctex.org/documents/shredder/metapostexample.html

*** emacs gif                                                         :gif:

**** record gif

- [[http://emacs.stackexchange.com/questions/798/recording-a-gif-screencast-of-emacs][stackexchange:Recording a GIF screencast of Emacs ]]
- [[https://github.com/Malabarba/camcorder.el][Github: camcorder.el]]


1. To use it, simply call *M-x camcorder-record*
2. A new smaller frame will popup and recording starts.
3. When you’re finished, hit *F12*.

View screencasts are generated in *ogv* format, and you can even pause
the recording with *F11*! You can also convert the .ogv file to a gif
by issuing the command *M-x camcorder-convert-to-gif*

后台程序

1. 录制
   - recordmydesktop
   - ffmpeg
   - mplayer & imagemagick

2. 转换
   - ffmpeg
   - mplayer & imagemagick

**** view gif

- https://github.com/Fuco1/org-inline-image

#+BEGIN_SRC emacs-lisp
  (require 'org-inline-image)
#+END_SRC

not work 没细看

*** blender dae

**** solutions

http://blender.stackexchange.com/questions/160/can-blender-export-to-the-collada-format

***** ppa

https://launchpad.net/~irie/+archive/blender

#+BEGIN_EXAMPLE
  Installing from the PPA:
  Add the PPA: ppa:irie/blender (sudo add-apt-repository ppa:irie/blender)
  Update your sources (Ubuntu Software Center does this automatically, but you will need to do it manually if adding from the command line). (sudo apt-get update)
  Install blender (this package is 2.6x from git) (sudo apt-get install blender)
#+END_EXAMPLE

http://askubuntu.com/questions/169542/how-do-i-install-the-latest-blender-3d-builds-from-a-ppa

#+BEGIN_EXAMPLE
And now that Irie PPA is not updated anymore, to get the latest version (updated weekly), you can use this instead:

sudo add-apt-repository ppa:thomas-schiex/blender
sudo apt-get update
sudo apt-get install blender
#+END_EXAMPLE

***** plugin

http://sourceforge.net/projects/colladablender/

the above link points to a blender 2.49 script. it will not work with recent Blender versions!

***** compile

#+BEGIN_EXAMPLE
 WITH_OPENCOLLADA                 ON
#+END_EXAMPLE

****** git clone

https://developer.blender.org/diffusion/B/

#+BEGIN_EXAMPLE
# read-only access
git clone git://git.blender.org/blender.git

# read/write access
git clone git@git.blender.org:blender.git

cd blender
git submodule update --init --recursive
git submodule foreach git checkout master
git submodule foreach git pull --rebase origin master
#+END_EXAMPLE

****** build

http://wiki.blender.org/index.php/Dev:Doc/Building_Blender

ccmake

#+BEGIN_EXAMPLE
  home/wally/Download/blender/source/blender/imbuf/intern/openexr/openexr_api.cpp
  fatal error: ImfMultiView.h: 没有那个文件或目录
   #include <ImfMultiView.h>
#+END_EXAMPLE

- openexr :: command-line tools and docs for the OpenEXR image format
- openexr-viewers :: viewer for images in the OpenEXR format

apt-get 方式安装相应软件后依然存在错误。


https://github.com/openexr/openexr

装这个更加烦人，编译半天一堆错误。

**** test

#+BEGIN_EXAMPLE
fake_module: addon missing 'bl_info' gives bad performance!: '/usr/share/blender/scripts/addons/colladaExport14.py'
#+END_EXAMPLE

**** plugin


***** 配置数据路径[[#configuration-and-data-paths][¶]]

https://www.blender.org/manual/zh.cn/getting_started/installing_blender/directorylayout.html

Blender使用了三种不同的文件夹，它们是跟操作系统有关系的。

- 本地 :: 配置和运行时数据位置（只供自己绑定使用）

- 用户 :: 配置文件位置（通常情况下在用户的家文件夹下）

- 系统 :: 系统级安装后的运行时数据位置（可能是只读的）。

系统级安装 *系统* 和 *用户* 文件夹都是需要的。

如果是本地解压Blender的发行版，这些用户配置数据和运行时数据都在一个子
文件夹下面，允许Blender的多个版本共存而且不会有冲突，可以忽略

*用户* 和 *系统* 文件。

注解

注解：你有可能需要确保你的文件管理器中，显示隐藏文件的选项已经被勾选。

****** 基于不同平台的路径[[#platform-dependant-paths][¶]]

下面是各个系统的默认文件夹位置：

******* Linux[[#linux][¶]]

- 本地 ::
  #+BEGIN_EXAMPLE
      ./2.76/
  #+END_EXAMPLE

- 用户 ::
  #+BEGIN_EXAMPLE
      $HOME/.config/blender/2.76/
  #+END_EXAMPLE

  # $ ls .config/blender/2.72/
  # config  scripts

- 系统 ::
  #+BEGIN_EXAMPLE
      /usr/share/blender/2.76/
  #+END_EXAMPLE

注解

该路径./2.76/是相对于Blender可执行文件以及用于自包含官方blender.org构建发布软件包。

注解

The *USER* path will use =$XDG_CONFIG_HOME= if its set:

#+BEGIN_EXAMPLE
    $XDG_CONFIG_HOME/blender/2.76/
#+END_EXAMPLE

******* Mac OSX[[#mac-osx][¶]]

-  本地 :: #+BEGIN_EXAMPLE
       ./2.76/
   #+END_EXAMPLE

-  用户 :: #+BEGIN_EXAMPLE
       /Users/$USER/Library/Application Support/Blender/2.76/
   #+END_EXAMPLE

-  系统 :: #+BEGIN_EXAMPLE
       /Library/Application Support/Blender/2.76/
   #+END_EXAMPLE

注解

OSX 存储blender二进制文件，放在 ‘./blender.app/Contents/MacOS/blender
‘，所以数据及配置的本地路径是:

#+BEGIN_EXAMPLE
    ./blender.app/Contents/MacOS/2.76/
#+END_EXAMPLE

******* MS-Windows[[#ms-windows][¶]]

-  本地 :: #+BEGIN_EXAMPLE
       .\2.76\.
   #+END_EXAMPLE

-  用户 :: #+BEGIN_EXAMPLE
       C:\Documents and Settings\$USERNAME\AppData\Roaming\Blender Foundation\Blender\2.76\
   #+END_EXAMPLE

-  系统 :: #+BEGIN_EXAMPLE
       C:\Documents and Settings\All Users\AppData\Roaming\Blender Foundation\Blender\2.76\
   #+END_EXAMPLE

****** 路径布局[[#path-layout][¶]]

下面的路径布局是以上的文件夹描述规范。

‘./Config/startup.blend ‘ 可能在哪里 ~/.blender/[[#id1][|例如
BLENDER_VERSION|]]/config/startup.blend。

-  =./autosave/ ...= :: 自动保存混合文件位置。* Windows
   只，临时目录用于其他 systems.*

   搜索顺序: =LOCAL, USER=.

-  =./config/ ...= :: 默认值与会话信息。

   搜索顺序: =LOCAL, USER=.

-  =./config/startup.blend= :: 载入初始文件和用户设置

-  =./config/userpref.blend= :: 载入初始文件和用户设置

-  =./config/bookmarks.txt= :: 在文件选择器中隐藏系统书签

-  =./config/recent-files.txt= :: 在文件管理器中隐藏最近查看的路径

-  =./datafiles/ ...= :: 运行时文件

   搜索顺序: =LOCAL, USER, SYSTEM=.

-  =./datafiles/locale/{language}/= :: 用户界面翻译的静态预编译的语言文件。

-  =./datafiles/icons/*.png= :: Blender用户界面的图标主题。*
   不目前可选的主题 preferences.*

-  =./datafiles/brushicons/*.png= :: 对于每个画笔的图像。

-  =./scripts/ ...= :: Python 脚本的用户界面和工具。

   搜索顺序: =LOCAL, USER, SYSTEM=.

-  =./scripts/addons/*.py= :: Python
   加载项在用户首选项，可以使包括导入/导出格式支持、
   渲染引擎集成和许多方便实用。

-  =./scripts/addons/modules/*.py= :: 模块的加载项的使用 (添加到 Python
   的 sys.path)。

-  =./scripts/addons_contrib/*.py= :: 另一个加载项目录是用于社区维护的插件
   (必须手动创建)。

-  =./scripts/addons_contrib/modules/*.py= :: 对 addons_contrib 的模块
   (添加到 Python 的 sys.path) 的使用。

-  =./scripts/modules/*.py= :: 包含我们的核心 API 和其他脚本到效用函数的
   Python 模块导入 (添加到 Python 的 ‘sys.path ‘)。

-  =./scripts/startup/*.py= :: 在启动时将自动导入的脚本。

-  =./scripts/presets/{preset}/*.py= :: 预设用于存储用户定义设置布、
   呈现格式等。

-  =./scripts/templates/*.py= :: 可以从访问的示例脚本:
   文本空间标题-->--> 脚本模板的文本。

-  =./python/ ...= :: 捆绑的 Python 发行版，不仅是必要的系统安装的
   Python 时缺席或不兼容。

   搜索顺序: =LOCAL, SYSTEM=.


***** 插件--NGENNGT翻译[[#add-ons][¶]]

https://www.blender.org/manual/zh.cn/advanced/scripting/python/add_ons.html

/插件/ 是对扩展Blender功能的脚本的通用术语。在 /用户设置/ 窗口的 /插件/
标签页找到这些脚本，在该标签页下可以搜索、安装、启用和禁用 插件。

****** 搜索[[#searching][¶]]

Blender自带一些好用的插件，你可以自行启用。不过你也可以添加你自己的或者从网上找到的有趣插件。


#+DOWNLOADED: https://www.blender.org/manual/zh.cn/_images/user_prefs-addons_tab.png @ 2016-01-18 11:47:34
 [[~/Wally/Journal/Figure/.org-download/Journal/user_prefs-addons_tab_2016-01-18_11:47:33.png]]

用户设置窗口中的插件标签页

[[http://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts][脚本目录]]
提供了Blender自带插件索引，同时也列出了许多外部插件。

****** 启用和禁用[[#enabling-and-disabling][¶]]

如图所示，勾选或取消勾选插件右侧的复选框即可启用或禁用该插件。


#+DOWNLOADED: https://www.blender.org/manual/zh.cn/_images/Extensions-Python-Addons-EnabledAddOn.jpg @ 2016-01-18 11:47:56
 [[~/Wally/Journal/Figure/.org-download/Journal/Extensions-Python-Addons-EnabledAddOn_2016-01-18_11:47:55.jpg]]

启用插件

启用插件功能可以即时生效。 如果启用后插件未激活， 可以在 [[../../../interface/window_system/console_window.html][/控制台窗口/]]
查看发生的错误。

单击插件左侧的箭头可以查看更多信息，如插件存放位置、描述和文档链接，你
还可以通过“报告Bug”按钮报告该插件的bug。


小技巧

保存插件设置

如果想要插件随Blender打开同时启用，你需要 /保存用户设置/ 。

****** 安装第三方插件[[#installation-of-a-3rd-party-add-on][¶]]

对于网络下载的或你自己的插件，需要单击 /从文件安装.../ 并选择 .zip 或
.py文件安装后，才能在插件列表中显示该插件。

或者你还可以手动安装插件，这在开发自己的插件过程中很有用。

直接将文件移动或链接至 =../scripts/addons= 文件夹(你的Blender文件夹配
置路径).

[[/home/wally/Wally/Journal/Figure/scrot/2380aff.png]]

****** 文件位置[[#file-locations][¶]]

关于Blender目录信息详见 [[../../../getting_started/installing_blender/directorylayout.html][/配置& 数据路径/]]。

你还可以新建个人插件目录，并在 /用户设置/ 中的 /文件/
面板配置该路径。新建一个个人脚本文件夹：

-  新建一个空文件夹 (如'script_addon_2-7x')

-  在该文件夹下添加一个 ‘addons'
   文件夹，只有这样命名Blender才能正确识别。

-  将你的新插件置于该 ‘addons' 文件夹。

-  打开 /用户设置/ 的 /文件/ 面板。

-  在 /脚本/ 路径中选择你的脚本文件夹路径 (如 ‘script_addon_2-7x')。

****** 开发指南[[#development-guidelines][¶]]

如果你是一个脚本开发人员，你可能对 [[http://wiki.blender.org/index.php/Dev:2.5/Py/Scripts/Guidelines/Addons][插件开发指南]] 感兴趣。

**
*** Linux
**** [[https://mp.weixin.qq.com/mp/appmsg/show?__biz=MzA3MzAwMjAxMQ==&appmsgid=10000009&itemidx=1&sign=c926ff23def356a4a0f2ed7141c466d6&scene=1&srcid=0118jxrIABVW8XwWSGpkpoJd&pass_ticket=8B57gmAPihhXDqY3DNHOKiG9154WT42aR6KFVbb%2FAFpL7bBsnVOOoPubYSkLb3iH][当你想放弃时，看看这幅漫画！]] :责任:

[[/home/wally/Wally/Journal/Figure/scrot/32504b9n.png]]

这篇东西转自一位有思想的研究生！她看到这篇漫画，觉得很不错，我看后也觉
得值得我们思考，尤其是当我们抱怨时！

[[/home/wally/Wally/Journal/Figure/scrot/32504oHu.png]]

第一幅漫画中，每个人都背负着一个沉重的十字架，在缓慢而艰难地前行！

[[/home/wally/Wally/Journal/Figure/scrot/325041R0.png]]

途中，有一个人忽然停了下来。他在想着什么！

[[/home/wally/Wally/Journal/Figure/scrot/32504nbD.png]]

他想，上帝啊，这个十字架太沉重了，我可以把十字架砍掉一块！

[[/home/wally/Wally/Journal/Figure/scrot/325040lJ.png]]

于是他动手砍了起来！

[[/home/wally/Wally/Journal/Figure/scrot/32504BwP.png]]

砍掉之后走起来，的确是轻松了很多，他的步伐也不由得加快了。

[[/home/wally/Wally/Journal/Figure/scrot/32504oOi.png]]

就这样走啊走啊！走着走着，他觉得肩上的十字架还是很沉，很重！

[[/home/wally/Wally/Journal/Figure/scrot/325041Yo.png]]

他祈求道，上帝啊，请你让我再砍掉一截吧，我会走得更轻松！

[[/home/wally/Wally/Journal/Figure/scrot/32504Cju.png]]

于是，他又砍掉了一截！感谢上帝，这样一来，他感到轻松多了！

[[/home/wally/Wally/Journal/Figure/scrot/32504Pt0.png]]

如此，他毫不费力地就走到了队伍的最前面。当其他人在吃力地负重前行时，他
却轻松地哼起了小曲！

[[/home/wally/Wally/Journal/Figure/scrot/32504B3D.png]]

啊哈!谁料，前边忽然出现了一个又深又宽的沟壑！沟上没有桥，周围
也没有路。也没有蜘蛛侠或者超人出来解救他…

[[/home/wally/Wally/Journal/Figure/scrot/32504bLQ.png]]

后面的人都慢慢地赶上来了，他们用自己背负的十字架搭在沟上，做成桥，从容
不迫地跨越了沟壑。

[[/home/wally/Wally/Journal/Figure/scrot/32504oVW.png]]

他也想如法炮制。只可惜啊，他的十字架之前已经被砍掉了长长的一大截，根本
无法做成桥帮助他跨越沟壑！

[[/home/wally/Wally/Journal/Figure/scrot/325041fc.png]]

于是，当其他人都在朝着目标继续前进时，他却只能停在原地，垂头丧气，追悔
莫及……

每个人都背负着属于自己的十字架，的确是这样，漫画中的每个人，都是背负着
属于自己的十字架，而当沟壑出现时，他们也只能利用自己背负的十字架去跨越
沟壑，继续前进。

所以：在人生的道路上，有些黑暗，只能自己穿越；有些痛苦，只能自己体验；
有些孤独，也只能自己品尝……人生是没有捷径的！

**** [[http://daily.zhihu.com/story/4573178?utm_campaign=in_app_share&utm_medium=Android&utm_source=Weixin&from=timeline&isappinstalled=0][哪些习惯能让生活变得简洁高效？]] :知乎:习惯：极简主义:

个人现状是处在三条规则，距离一条规则完全保持简约的生活方式还要努力几年时间。

***** 让生活变得简洁而高效只需要一条规则

就是照管好自己，保持一种简约的生活方式, 控制好自己的内心，从加法生活过
度到减法生活。

***** 如果觉得这一点说的太简单，就可以扩展成三条

*第一条：应用好 80/20原则*

把这个法则用在生活的各个方向中，把时间和精力放到自己擅长事情和主要目标
上，比如工作、家庭、友情、爱好、情绪，提高生活的质量和稳定

*第二条：做好精力管理，保持稳定而规律的生活方式：*

应该根据自己的精力进行安排和调整生活，周期性地补充精力，来平衡精力消耗。
需要对你的精力进行海战略性的规划和应用，并把它当成一种习惯。

人们的精力有4种来源，身体的、情感的、思想的和精神的，这4种精力资源需要
在消耗和储备之间取得平衡才能保证不会枯竭。


*第三条、 控制过度消费和物质过剩*

最初从减少选择开始，然后是学会丢东西，最成功的一次是用几个月时间丢掉了
50种不同类型的东西，包括当时的工作和26斤体重，整个生活立刻就简单了很多，
但距离断舍离的要求还有差距：

断舍离”是指：

断 = 不买、不收取不需要的东西

舍 = 处理掉堆放在家里没用的东西

离 = 舍弃对物质的迷恋，让自己处于宽敞舒适，自由自在的空间。


选择物品时不是“能不能用”，而是“我要不要用”。

扩展阅读：

-  [[http://www.read.org.cn/html/1386-reduce-the-choice-to-let-you-save-time.html][减少选择让你节省时间]]
-  《丢掉50样东西，找回100分人生》读书笔记
   --[[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200035644&itemidx=1&sign=6f0cd694354b3f75b757e41bc93b767b][warfalcon]]
-  进阶时看《断舍离》 [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000734&itemidx=1&sign=31ac402a40a351bf6823237d2d020057][warfalcon]]


***** 觉得这三条还是太难，那继续扩展成九条

只要减少这九类时间黑洞，生活中就会简约高效


*1、减少网络黑洞时间：*

每个人都离不网络，而网络上的无效时间黑洞是最多的：

不看新闻：

-  *时间管理之新闻阅读*[[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000055&itemidx=1&uin=MjU4MjUyNzM2MA%3D%3D&key=79cf83ea5128c3e59a05178691cc0d51487d45a3b3704ccaa2340ff568d898b089e6e31cf75c6a261042289e859b66c0&devicetype=android-10&version=25000338&lang=zh_CN&pass_ticket=1V0MbhKBMhjP%2BE4eiEonppyltegkgcZRy%2F%2FCxeKJlauehqow4jLPOnbhMpyI0xCB#wechat_webview_type=1#wechat_redirect&From=test][warfalcon]]**
-  你是在掌控新闻还是被新闻所掌控？
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200791870&itemidx=1&sign=77679932e20ecb28fa3ae6c26f653caf&scene=4&uin=MjU4MjUyNzM2MA%3D%3D&key=79cf83ea5128c3e59a05178691cc0d51487d45a3b3704ccaa2340ff568d898b089e6e31cf75c6a261042289e859b66c0&devicetype=android-10&version=25000338&lang=zh_CN&pass_ticket=1V0MbhKBMhjP%2BE4eiEonppyltegkgcZRy%2F%2FCxeKJlauehqow4jLPOnbhMpyI0xCB#wechat_webview_type=1#wechat_redirect&uin=MjU4MjUyNzM2MA%3D%3D&key=79cf83ea5128c3e59a05178691cc0d51487d45a3b3704ccaa2340ff568d898b089e6e31cf75c6a261042289e859b66c0&devicetype=android-10&version=25000338&lang=zh_CN&pass_ticket=1V0MbhKBMhjP%2BE4eiEonppyltegkgcZRy%2F%2FCxeKJlauehqow4jLPOnbhMpyI0xCB#wechat_webview_type=1#wechat_redirect&uin=MjU4MjUyNzM2MA%3D%3D&key=79cf83ea5128c3e59a05178691cc0d51487d45a3b3704ccaa2340ff568d898b089e6e31cf75c6a261042289e859b66c0&devicetype=android-10&version=25000338&lang=zh_CN&pass_ticket=1V0MbhKBMhjP%2BE4eiEonppyltegkgcZRy%2F%2FCxeKJlauehqow4jLPOnbhMpyI0xCB#wechat_webview_type=1#wechat_redirect&From=test][warfalcon]]
-  为什么你不应该读新闻
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200781923&itemidx=1&sign=96c0608f4ab861aac6271cf737d334ae][warfalcon]]

微信篇：

-  除非工作需求，否则每天集中查看三到四次微信，每次10分钟集中回复。
-  关闭微信朋友圈
-  定期退出无用的微信群
-  取消和关闭所有微信通知，否则微信的通知会不断的弹出信息来干扰和打断你

QQ篇：

1. 除非工作需求，否则一、二天登陆一次QQ
2. 定期评估并退出QQ群
3. 并关闭各种广告及提示。

邮件篇：
*[[http://www.read.org.cn/html/1986-shi-jian-guan-li-zhi-jian-chu-li-1-hai-liang-jian-chu-li.html][时间管理之邮件处理（1）海量邮件处理]]
*

*2、减少请求黑洞：*

学会拒绝工作和生活中各种要求，能减少大量的时间

要根据实际情况对要求做出判断。收到一个任务之后，应该问问自己：我必须马
上处理这个要求吗？我遇到最坏的情况就是每一项任务都是紧急的，需要立刻完
成。因为紧急任务一多，就会发现一整天都在不停地从一个工作转移到另一个工
作，最终一事无成。

对于别人的紧急要求，别立刻接受，而是提出一个近期内更合理的时间，以便完
成他/她手中的工作后处理新要求。然后将这个要求同其他相同的要求合并进行
批量处理。

*扩展阅读：*

-  [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000492&itemidx=1&sign=94c0656089fbaf9a6b751a5bbab54b4b][warfalcon]]
-  [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000495&itemidx=1&sign=b1adeb2d5aac7069cce791cda2bb5726][warfalcon]]


*3、减少选择黑洞*

我们必须控制过量选择，只把精力和时间放在生活中最重要的选项上，放弃一些
不重要的选择机会。千万别过于追求完美，做选择时要考虑好时间成本和机会成
本，而且一旦选择之后，别浪费精力去为其它放弃的选择而后悔。减少跟他人的
比较。

最好建立一个自己做选择的框架，在面临一些人生中的重大问题时可以更好的选
择和权衡。

扩展阅读：

-  控制过多的选择
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000177&itemidx=1&uin=MjU4MjUyNzM2MA%3D%3D][warfalcon]]
-  针对大量选择时的最优策略
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000738&itemidx=1&sign=b1ce75ef1000a3b70e770060e32d3b99][warfalcon]]
-  [[http://www.zhihu.com/question/19591602/answer/36731615][如何做选择才不会后悔？ - warfalcon 的回答]]


*4、减少负面情绪黑洞*

能正确面对恐惧、焦虑、抱怨等负面情绪，

扩展阅读：

-  [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000759&itemidx=1&sign=27c1add809978d24c929c82738753a76][warfalcon]]
-  [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201278840&itemidx=1&sign=a31cc5b12cf9be442ee1d07338376f3e#rd][warfalcon]]

5、减少注意力黑洞

-  如何集中自己的注意力
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000066&itemidx=1&uin=MjU4MjUyNzM2MA%3D%3D][warfalcon]]
-  观察自己的呼吸
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=203934058&itemidx=1&sign=e240a22c7e63853168c863c30c912577#rd][warfalcon]]
-  集中注意力的入门方法
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200983071&itemidx=1&sign=5ea7109a5848631609a7e0c81dc19983#rd][warfalcon]]
-  从管理时间转向管理注意力
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201082765&itemidx=1&sign=de78e74517d821092b5cd062d42f293e][warfalcon]]
-  集中注意力的十大秘诀
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201401194&itemidx=1&sign=9570baf0bb1fbc52c2c6ece7a4cb2add#rd][warfalcon]]
-  写给注意力严重不集中人士的生活建议
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=205820380&itemidx=1&sign=b5f6285133b0e65cea78336124a128c0#rd][warfalcon]]
-  学会在网络上控制你的注意力
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000685&itemidx=1&sign=09a1c1c940c29b1af205784d0159ce2f][warfalcon]]
-  学会在网络上控制你的注意力
   （2）[[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000688&itemidx=1&sign=be90345c551fa4c16c3aa91200e2685f&][warfalcon]]
-  用清理桌面物品来集中注意力：我常用的一种方法把笔记本关机，然后用笔
  记本清洁工具，把键盘、屏幕好好擦一下，然后看到焕然一新的笔记本心情大
  好。

6、减少交际黑洞

7、减少沟通黑洞

工作篇：

学会开会：*只去参加必要的会议*
[[http://www.zhihu.com/question/20291195/answer/15595509][开高效率的会议，有哪些好的经验？
- warfalcon 的回答]]

学会授权和培养新人：

-  [[http://www.read.org.cn/html/1563-monkey.html][《别让猴子跳回背上》读书笔记]]
-  快速培养新人的四个方法
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=202558668&itemidx=1&sign=62f0f7914474712f96af84ea8f66b269#rd][warfalcon]]

生活篇：


8、减少拖延黑洞

扩展阅读：

-  我的战拖策略
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200321752&itemidx=1&sign=e15045518f8cb1f89109961166752b6b][warfalcon]]
-  战拖小技巧
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=202225151&itemidx=1&sign=6fffbbd02142e150a56636f1f8d88a8d][warfalcon]]
-  《一分钟能做什么？》60招对抗拖延
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=202103054&itemidx=1&sign=9f9ca10919eededa948ae6395d01db77#rd][warfalcon]]
-  [[http://www.read.org.cn/html/2322-tuo-la-yi-dian-ye-wu-fang-zhong-de-jie-gou-hua-tuo-yan.html?From=test][《拖拉一点也无妨》中的结构化拖延]]
-  告别拖延症的7个信条
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201182906&itemidx=1&sign=89d62d5852b848338ebb20cc62068595#rd][warfalcon]]
-  对抗的拖延两种方法
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=205332382&itemidx=2&sign=4880ef380f52f401332ada12fdf28a71#rd][warfalcon]]
-  《战胜拖延症》笔记
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=200233145&itemidx=1&sign=f64af36f8c909993966140447c54003c][warfalcon]]
-  对抗睡前拖延
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=201089296&itemidx=1&sign=03827fccc3ecf45edb9946bca9ed239b][warfalcon]]
-  拖延处理技巧汇编
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000048&itemidx=1&uin=MjU4MjUyNzM2MA%3D%3D][warfalcon]]
-  《拖延心理学》中的12条应对技巧
   [[http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NjA3OTM0MA%3D%3D&appmsgid=10000365&itemidx=1&sign=2f8da62dc06a8be12691f8dd6a995a63][warfalcon]]


9、

***** 觉得这九条做到有些困难，那继续扩展成81条

1. 整理好办公桌 [[http://mp.weixin.qq.com/s?__biz=MjM5NjA3OTM0MA==&mid=204814936&idx=1&sn=fdc5f29e094ac9bc4b91a1c13f160296#rd][warfalcon]]

2. 每周提前做好下一周的规划和时间安排：[[http://www.zhihu.com/question/27783349/answer/38065315][如何让星期天的晚上过得更有意
   义？-warfalcon 的回答]]

3. 不整理名片，直接扫描，用名片全能王，直接扫描一下，大多数名片都能自
   动提取并识别，然后有时间的时候统一处理一下，一张名片只需要20、30秒
   就能处理完。

4. 问自己，如果我不做这件事情的话. 是否会出现极其严重的后果呢？”如果
   答案是否定的话. 我就会取消这件任务。

5. 提早1小时出门，在途中确认每天日程表

6. 多利用录音来取代手写的备忘录，用来记录各种想法和点子

7. 练就3分钟内长话短说的功夫

8. 工作日的时候，每天5点钟起床（晚上早些上床睡觉）。

9. 早上起床的时候做几个简单的体操，加上几个深呼吸，可以上大脑马上清醒

10. 午饭吃得很少，这样下午就不会感到困倦。

11. 用消噪耳机把公共场所变成书房

12. 读书的时候，我只会用很少时间，只了解书的要点内容。

13. 不要太相信记忆力，要勤做笔记，记录下来的东西要定期整理，消化。

14. 学习开会，要有重点，会后会把会议要点记录在一张A4纸上.

15. 不把日程表排满任务，每天留出三十分钟给自己，去跟自己约个会。在这段
    时间里，可以思考自己现在处于什么状态，思考将来需要一步步完成些什么，
    对未来进行长期的展望。

16. 放弃所有的“等待时间”。如果我不得不等待的时候，我将其看成是放松自
    我的机会，或者我也可以利用这段时间来做一些我平时不会做的事情。

17. 只要你多花一点心思，把自己的生活设计的更加有趣更加迷人，就能让你的
    生活丰富起来

18. 把你经常用的固定句式进行自定义加入词库中，比如搜狗输入法里面就有批
    量造词，把地址、邮箱、问候语、公文格式之类做成短语，打字速度会马上
    提高很多

19. 每天都会浏览一下自己的人生目标，并确保自己每天都会做一些事情来推进
    自己的人生目标。

20. 把目标可视化，设成手机壁纸或桌面壁纸，每天会重复提醒自己。

21. 即便是在做一些最不起眼的工作的时候，我都会想着自己的长期目标。

22. 尽量只做A级活动，少做B、C级活动。

23. 在开始一个大型项目的时候，我会首先从那些最重要的部分开始，并经常发
    现其他部分其实并不重要。

24. 首先做重要的事情。

25. 每当完成一些比较重要的任务之后，给自己放个假，或者是给自己一些特殊
    的奖励。

26. 集中精力处理那些能够带来长期收益的事情.

27. 一次只集中精力处理一件事情。

28. 坚持一件件完成'事务清单”上的工作。

29，把自己的大部分想法记录下来。

30. 用早晨的时间做一些比较有创造性的工作，然后利用下午的时间召开会议
    （如果有必要的话）。

31. 为自己和其他人设定最后期限。

32. 在每次跟人讨论的时候都会积极聆听。

33. 尽量不浪费其他人的时间（除非是一些对我真正重要的事情）。

34. 尽量把一些事情委托给他人完成。

35. 请专家来帮助我完成一些专业性的问题。

36. 请人帮助我处理所有常规性工作。

37. 尽量减少纸面工作。

39. 每份文件我只处理一次。

40. 把自己的桌面整理干净. 并把最重要的工作放到办公桌中央。

41，为所有的文件准备了专门的地方（这样我就不用再花时间到处找它们）。

42. 每个月会专门抽出三小时时间来处理琐碎事情。

43. 周末的时候尽量不考虑工作。

44. 经常让自己放松，什么都不做。

45. 我意识到迟早有一天，我会用一些时间来应付一些自己无法控制的事悄. 我
    不会为此感到厌烦。

46. 不断问自己，“我现在最应该做什么事情？”

47. 利用思维导图把握总体结构

48. 不要长时间连续学习: 每个人的精力是有限，并一定长时间学习效果就好

49. 花钱上课，强迫自己学习

50. 寻找学习伙伴，避免半途而废

51，冬天把空调设定在20℃

52. 利用腹式呼吸消除杂念

53. 马上实践学过的知识

54. 阅读中有30%～50%都是没用的

55. 给大脑0.5～9小时来处理信息，再回顾才会有新收获，不要在难点上停留

56. 倾听微弱的声音能提高注意力，每天练习3分钟

57. 每天做件不愿做的事

58. 自我讲授，像老师教学一样把资料概述出来，疑点会变得清晰

59. 大脑更喜欢图像

60. 技能不是持久的，不练习，它每天都在退步

61. 把问题用另一个角度重复一遍

62. 画效率/时间曲线表

63. 每天花10分钟写随笔，不要停顿

64. 不要压制欲望，化解它

65. 微笑释放的化学物质对紧张和愤怒极有效

66. 总是全力以赴，因为你最好的一面每段时间都不一样

67. 从别人的错误中学习，脑中犯的错越多现实中越少

68. 每天运动一刻钟

69. 区分抱怨，停止抱怨

70. 一年是很长的时间，重复就是力量

71. 每工作90~120分钟便需要休整，再全力以赴

72. 问自己，愿用2小时把事情做到80%还是4小时做到100%？它需要做到完美吗？

73. 为每页笔记作出简要总结，方便日后抓住重心

74. 整出条理可按时间、地点、连续统（难~易）、种类和字母排序

75. 觉得再难的，只要你能静下心来反复练习，就会有进步。

76. 找办法督促自己执行任务

77. 不要服用不必要的维生素和补充品。

78. 每年性生活高潮的次数越多、质量越高，你就越年轻。

79. 坚持每天吃早餐。

80. 低卡路里、高营养价值、均衡饮食。

81. 固定的睡眠时间能帮助你保持年轻。女性每晚睡眠时间7小时，男性8小时。

-------------------------------------------------------------------------------------------------------
觉得这81条也还是有问题，那继续扩展成6561条：
-------------------------------------------------------------------------------------------------------

这个版本可以直接关注我的微信、知乎、Blog和豆瓣，写了8年快完成1/3
了，还有 2/3 估计在我死之前还是很有希望的。

***** 对这么多的技巧应该如何吸收和整理？

*去“做”，但不要期待任何 “结果”。*

第一步分类。把不同的技巧，按用处或类型，从新整理一下。放上关键字，收藏
起来。

第二步删除。对你帮忙不大或暂时用不了的技巧。

*第三步挑出少数几条实践。* 选择一些能解决你当前问题的技巧，从现在开始
尝试。可以列个清单。

第四步记录。每尝试完一条之后，记录一下心得，想想是否有可以改变的地方或
者直接放弃。

第五步总结。积累5-10条实用小技巧之后，写篇文章总结一下，找机会分享出来，
你会发现在写的时间，会考虑一些以前想不到的问题，分享也能让你印象更深刻。

**** [[https://mp.weixin.qq.com/s?__biz=MzA3MjM2MzYzOQ==&mid=402437707&idx=1&sn=02c915a39a2124790476688c0bde69d9&scene=1&srcid=0115wtZqKbY2mdXhwAlhVlmz&pass_ticket=8B57gmAPihhXDqY3DNHOKiG9154WT42aR6KFVbb%2FAFpL7bBsnVOOoPubYSkLb3iH#rd][孩纸，事情不象你想的那么简单]] :行动:

文：雾满拦江

（01）

明朝时，有个叫李晟的人，他心怀大志，胸有奇谋，痴迷军事器械研究，发明了
许多先进武器，战车连弩什么的。朝廷是非常重视这类科学家的，立即传令工部，
照着李晟的图纸打造弓弩战车。

战车连弩很快打造出来了，可是怎么看都有点不对------车装配不起来，弓弩拉
不动。都是废品，根本没法儿用。

李晟以坐废钱粮之罪，贬。

好多年后，李晟再次卷土重来，给朝廷呈上他最新研究出来的战甲。朝廷仍然一
如既往的重视，立命工部铸造。

但这次，工部多了个心眼，铸造新式兵甲可以，但要求李晟本人，要先行试用。

试用就试用，等兵甲造出来，往李晟身上一扣，就听哐的一声巨响，李晟被他自
己研究出来的兵甲，死死的扣在了地下，怎么用力都爬不出来。

原来，李晟研究的兵甲，防御力量绝对没的说，刀砍不入水泼不进，就是忽略了
人体的承受重量。这兵甲一旦穿在身上，就被压得趴在地上，根本爬不动......

（02）

纪大烟袋纪晓岚，写了本《阅微草堂笔记》，书中提到一个怪人刘羽冲：

刘羽冲，沧州人。他也是个喜欢琢磨事儿的人。有一次，他无意中得到本古兵书，
潜心研读多年，终于破关而出。言称其可统兵十万众。恰逢当地闹土匪，刘羽冲
主动担纲领队，率乡勇出击土匪。一触即溃，如果不是刘羽冲逃得还算快，铁定
被土匪捉去了。

从此刘羽冲不言兵事。

又不久，他又得到了一本古水利书，再次潜心研读多年，终于破关而出，自谓可
使千里成沃壤。游说于州官。州官也是位富创新精神的冒险家，遂大胆采用刘羽
冲先生的方法，开渠治水。岂料沟渎初成，大水狂涌而入，州郡之人，几为鱼鳖。

连续的失败，让刘羽冲陷入忧伤之中。他每天独自徘徊在台阶下，不时的自言自
语：噫吁戏，古人都是王八蛋，净写假书把我骗。都怪老子太犯贱，连续上当没
咒念......

（03）

晚清年间，倡导洋务。有下有个蒋老汉，是个创新型的实干家。他在报纸上看到
洋人的火轮船，顿发宏愿，要亲手制造一艘。

制造一艘铁甲战船，那要花老钱了。蒋老汉舍得投入，他花光家产，负债累累，
凑足了材料，然后拎只小铁锤上阵了：叮哩当啷，哐哐咣咣，不眠不休的苦战了
不知几多日月，最终是功夫不负苦心人，一艘华丽的铁甲船，终于成功的制造出
来了。

铁船下水之日，三乡五里的人全都跑来看热闹，被蒋老汉的创意深深的折服：看
看人家，你看看人家，敢想敢干敢冒险，真是了不起......哎哟，那是怎么回事？

没怎么回事，就是蒋老汉研究出来的铁甲船，一碰到水，就听咕嘟咕嘟，瞬间就
沉没了。

造了这么多日子的铁甲船，刚刚见水就沉了，这未免......蒋老汉呆立水边，茫
然失措。

一个看热闹的人告诉他：老蒋呀，你的创新精神，是好的，是应该受到鼓励和支
持的。可是这世上的事儿，不是你胆肥儿就能干明白的。单说这铁甲船，在洋人
那里都是个超复杂的问题，要学好多好多的知识，才可以......

原来是这样啊，蒋老汉毅然发了狠，要送儿子去西洋，学习制造铁甲船。

蒋老汉把儿子送去了西洋，可是这个儿子学了半天，还是没弄会如何制造铁甲船。
他毕业归国，去北大当了校长，专门告诉孩子们：骚年，这个做事呢，不象你们
想的辣么简单，真的不象，就比如说咱爹......

这位校长，叫蒋梦麟。

（04）

前段时间，一位当父亲的在我微信里留言，说了这么件事：

他的儿子，大学毕业了，雄心勃勃，要开工办厂。

可是，这家人父亲没开过厂，爷爷没经过商，祖上十八代都是凡人，你个熊孩子
开口就要开厂，你懂得厂门该向哪儿开吗？

孩子才不管，在家里大吵大闹，要家里拿五十万创业基金出来。

钱是有，可五十万，足以让这家人抽筋剥皮了，毕竟是工薪阶层......可这苦情，
根本不能跟读了书的孩子讲。这孩子读书读得已经不会说人话了，开口就骂：五
十万你都拿不出来，活这辈子还不如条狗，现在赚钱这么容易，狗汪汪两声都能
赚五十万......

家里被这孩子闹得乌烟瘴气，最后老伴屈服了，瞒着他给了孩子存折。

不出所料，孩子拿到钱，立即就消失了。不久有债主找上门来，厂子没见到，据
来人说孩子还在外边欠下一百来万......此时家人心急如焚，到处找孩子，最终
在家网吧，成功的把那熊孩子找回来。那孩子回来时梗着脖子，一脸的不服不忿，
此后爹妈做牛做马还债，这孩子就呆坐在沙发上看电视，还不能问他怎么欠下人
家的钱，一问这孩子就疯起来......

那位父亲问：你说我儿子，这书他究竟是怎么读的呢？读到最后，连事情看着容
易做起来难，这么简单个道理，他都不懂了呢？

（05）

前段时间，我的几个写字吃饭的朋友，聚一起喝酒，一边喝一边愤慨：唉，什么
世道，这人都是瞎了眼吗？你看那个谁，那个谁，还有那个谁谁谁，他们写的东
西，叫什么玩艺儿呀？烂到家的文章，根本看不下去，可是他们都红了，还大红
大紫，这可真是日了狗了。

咱们也要红！

咱们几个的才华，比他们强上几百倍，想红不过是分分钟的事儿！

而且，咱们是个团队，随便扔过去一个，都把他们砸趴下的那种。咱们几个合写
一个微信公众号，大家轮流上，每天一篇原创，最多不出半个月，准保大火。火
了后咱们就那啥......那啥......

干啦！

然后他们就真的开了个公众号，联手上，一共五个人，每五天轮一圈，每天一篇
原创文章。

头两圈，大家严肃认真，克尽职守。

到了第三圈，有位老兄讨个巧，他没写文章，顺手把他早年写的诗，发上去凑个
数。

他的想法是，我就今天偷个懒，有你们四个人的原创撑着呢，整体质量也不会下
降，等我哪天灵感来了，写篇涨粉的......

不曾想，另外几个老兄，也是这种想法。只是不好意思，见这老兄先行下了手，
大家心里再无顾忌。

从此这个公众号，发的时候随便抄几句，或者干脆停发，就这样过了段时间，这
个公众号，大家就很少登录了。

团队合作，怎么想都是极完美的，但当真做起来，却发现总会有意想不到的事情
发生，让我们心中美好愿望，最终沦为空想。

------人世间的事儿，怎么用脑子想，怎么合理。只有等做起来时，才会发现，
想象中的逻辑与现实，往往不在一个频道上。

（06）

一个人，做事越少，怨愤之气就越重。

*做事少的人，会把所有的事情，想得极简单。*

做事如此简单，可证自己的智商，那可不是一般的高。自己这么高的智商，却混
不出个模样来，可证这世道是多么的昏黑阴暗。世道如此不公，让自己满腔宏愿，
无由抒展，这种情况下的人，想不悲愤，真的很难。

*但这几个故事，告诉我们，人间事儿，真的没有简单可言------如果有，那一
定是你以旁观者的角度，看别人做事。*

明朝的李晟，清朝的刘羽冲、蒋老汉，都是认真做事之人。只不过，他们所做的，
是自己不熟悉的领域，不知道一项研究，要经过无数次试错，才会稍有点眉目的。
比如爱迪生，他为了寻找最合适的电灯丝，先后试验了上万种材料。在这个过程
中，所谓做事，不过是不停的试错，把所有的错误都找出来，就知道对的方案
了------但明李晟，清刘羽种和蒋梦麟的父亲，都只有一次试错的机会，一次不
对，人生成本耗尽，就玩不下去了。

人是没有预知能力的------许多人看到这句话，会频繁点头，但当轮到他们自己，
却往往忘了这点。那个非要开工办厂的孩子，和五个合开微信公众号的老兄，就
是不知道一件事情做起来，会有无数的枝节问题需要解决。这些问题和困难，只
有做了之后才知道。

不知道事情会遇到什么问题，不清楚事情的枝节，只看到事情的头和尾，这就是
许多人，把没做过的事情，想得过于简单的原因。

（07）

人生就是这样，除非在你自己的主场，所有的因素完全可控，这时候你才敢说胜
劵在握。

余者，你必须准备支付试错成本。

台湾有个歌星，曾讲述他服兵役时，如其所愿的被安排去歌唱，他雄心勃勃，以
为自己是偶像，铁定是赢得满堂喝彩。岂料真要演出时，惊发现还需要他自己搭
舞台，可他只会唱，从未搭过舞台，顿时傻了眼。这时候他的同伴们立即取出携
带的简易工具，噼哩啪啦搭个台子，自己走上去引吭高歌，让这位大歌星看得直
眨巴眼。

没有亲手做过的事儿，之所以想得容易，就是不知道还需要自己搭台。嚷着开厂
的孩子不知道这个，生生被人骗成狗。我那几个写字的朋友，他们根本没有与人
合作过，心里想的简单，以为人人都会出工卖力，替自己搭台。但等真做起来，
才发现人性还有偷懒搭便车的一面，台子还得你自己搭。只会唱戏不会搭台，这
戏你就唱不了。

想象中的逻辑，完全构建在别人都是无生命的劳作单元、心甘情愿替自己搭台的
基础之上。想象中的别人，都是没有私欲的，对自己是绝对顺从的。就跟电视剧
里演的一样。电视剧中，所有人都是主角的奴隶，就算是对手，也是以其拙劣映
衬主角的高智商。而电视剧是典型的想象思维，符合人类的主观想象------唯独
与现实不太贴边。

（08）

许多人喜欢指点别人，却最痛恨别人指点自己。

指点他人时，个个都是高手，从未做过实事的孩子，敢怒斥辛苦的父亲笨。等轮
到他来做，才知道这世上最笨的，就是他自己。

事非经过不知难。事情也只有做，才会在一次次试错后，走向成功------这是尽
人皆知的大道理。

但，没人告诉过你，你需要为每次试错，支付多少。

哪怕最简单的事儿，流程都复杂到超出你的预期。而每个环节的支出，加起来更
是个惊人的数字。以为五十万就能开个厂的孩子，需要有人告诉他，胼手胝足用
自己的努力来开厂的人，会发现自己付出的远不止这些。以为自己能力具备只差
钱的人，多半是把事情想简单了。

*永远要记住，想象最容易，做事最艰难，想象的逻辑与现实，始终有一条不可
逾越的鸿沟。*

真要想做成事，还要避免那种一次性就把人打入失败深渊的成本付出，适当的方
法有许多，比如你可以：

------先要知道自己这事儿没做过，许多细节不知道。这话说着简单，但没做过
事儿的人，会拼死的抬杠，死活不肯承认这点。

------承认你没做过的，必有你不明白的，这就可以了。

------从学徒做起。现在没有学徒制了，没有也不要紧，你可以找个正经做事的
人，到他身边，帮忙也好求聘也好，以员工的身份，踏实的观察，学习。这世上，
老板是最苦鳖的人，做梦都盼着个懂事明理的孩子，帮自己一把。如果你是这样
的人，就会获得具体实践的机会。

------事情做起来，慢慢你就知道什么叫资源了，你会认识越来越多做事的人，
知道每一个流程细节，能正确估算一件事的成本投入。

------等到你知道如何做事，懂得如何做成事，这时候你用不着逼家里拿钱成就
你的梦想，许多人自然就来找你了。当然，在你不会做事，还蠢透天的时候，也
会有许多人来找你，但这时候来的都是骗子。除非你成为做事的人，同类型的人
才会出现在你身边。

*事情是用来做的，不是说的。*

没做过事儿的人，往往会趾高气昂指点江山。而做事之人，莫不是低调谦
和------不是做事者人品好，而是他知道做事之难，再不敢摇头晃尾胡言乱语而
已。

让我们开始吧，先把心沉下，承认自己确实没有做过这件事。学习，询问，倾听，
学习的过程中，难免因为犯错而遭到斥责羞辱，如果你是玻璃心，明明什么都不
懂，还想让人拿爷供着，那就需要认真思考一下自己了。

要记住，这世上有两种人，一类是不做事，只管趾高气昂嘲笑别人，却荒废了自
己事业的蠢人。另一类是低调隐忍，任人嘲笑但逐步成就事业的人。你选择什么，
就会得到什么。你的人生你做主，荒废或是成就，取决于你内心深处的愿望。

**** [[http://m.wufazhuce.com/question/2016-01-03?from=timeline&isappinstalled=1][什么才是真正的成长？]] :一个:成长:

毛头子问：经常看到很多人说“成长”，感觉仿佛只要懂得了某个道理，就是一
种成长，成长就是不断地明白道理的过程，是这样么？


@曲玮玮 答毛头子：

真正的成长，就是不再急于成长。

有一类问题似乎很受欢迎------“哪些道理让你相见恨晚？”“你的每日私人成
长暗器是什么？”“哪些习惯能让生活变得更好？”

大家忙着收藏，忙着把一眼扫过去瞬间读完的道理抄在小本儿上，忙着赶紧找到
填补袖口破洞的补丁，忙着大彻大悟，忙着醍醐灌顶，即刻见疗效。

这些简洁的人生道理总是高赞。因为不需大费周章就能把几行金玉良言背下来，
产生自己手持武林秘籍行走江湖畅通无阻的幻象。

可是，你以为那些道理，作者栽跟头之前从没听说过吗？它们是治病的药丸，不
是预防针。只有跌了跟头后混合苦水服下去，才能缓解跌打损伤，从此溶进血液
里内化，终身傍身。在你经历到这些之前，它们只是粘在衣服上供你摘取的小处
方纸片。

当你真的成熟，慢慢不会再把“每天进步一点点”挂在嘴边。不会只对可以量化
的努力成果情有独钟，不会执念于“少吃一顿肉必然体重掉两斤，多做两道题考
试加五分”。没必要咬牙给自己设定
KPI。生活又不是大妈坐小板凳上织毛衣，一切所见即所得。

和我一样，很多写小说出身的人做自媒体，从前的创作是“背向”读者，所谓的
“成长”更多来源于自我省察。开了公众号之后，一切数据都转向阅读量与粉丝
数。有了可量化的数据之后，旁人哪里顾得上你内在的进步呢，只会忙不迭问你，
“最近粉丝涨了多少？”

或许世俗对成长与成功都有一套冷冰冰的评价体系，你要忍受层层标尺在身上测
量的尴尬，挺直腰板儿，心中另有一套无形的标尺。

时间本身是没有标度的，是人类为了有所区分与回顾，把连贯的时间分割成块。
又到年底，以前也执念于写一年总结，这一年看了多少书和电影，输出了多少万
字，把量的积累看作成长之一。也渴望从每段经历里萃取几滴人生精华敷在脸上，
希望每次摸爬滚打都能换来可视化的成长。

今年我依然会写总结，但不再有此心态。

生活不仅不是织毛衣，甚至连“蜗牛爬金字塔”都不是。没有任何人向你拍胸脯
保证，你所做的一切努力都指向前方。

有人用了错误的健身方式，辛苦流汗，却把自己严重拉伤。一些连续创业者总是
急于标榜自己在失败中得到多少宝贵的经验，却不会勇于承认，自己消耗了多少
资源和好年华。

你只是旅人走在陌生丛林里，天高地暗，薄雾微茫。你可能离星辰大海越来越近，
可能跋涉一天依然绕回原点，甚至努力一番仍向后退。

罗曼·罗兰说，“看清这个世界，然后爱它。”真正的成长，大概是你看透一切
之后，放下“你要去相信，没有到不了的明天”这种鸡汤执念，放下自欺欺人，
依然往前奔跑，无畏无惧。

初中时看《老友记》，看他们每天坐在同一张沙发上一本正经瞎扯淡，端着咖啡
杯消磨时间，乐此不疲地制造笑料，心里都在替他们着急，这些人什么时候能长
大啊。那些闲扯淡和玩填字游戏的时间，用来报个技能班学个编程该多好。

今年又重温了一遍。第一季穿着婚纱一惊一乍、被宠坏了的姑娘
Rachel，成了某时尚公司主管。吊儿郎当玩世不恭的
Chandler，重新找到了所爱的职业，也成了充满责任感的丈夫。

电视剧里从来没有从天而降一场惊人的变故，让每个人瞬间遭受锤炼，一夜之间
沧桑得判若两人。他们也没有合上书本后一拍大腿，顿悟真理从此铠甲傍身。

我只是在陪他们傻笑，替他们尴尬之余，年复一年，发现他们慢慢成长为另一种
样子。Joey
依然行为低幼，Monica
依然强迫症，Phoebe依然鬼马。十年过去，这些点缀人性的漂亮羽毛依然在他们
头顶随风飘，但是人生已经有了更厚重的根基底座，再也不是二十出头受了惊吓
随时地动山摇世界崩塌的小孩子。

急什么呢。

我很喜欢一句话，叫“但行好事，莫问前程”。

并非要你放下功名尘土无欲无求，只是不带着强烈的结果导向去做事，不是把一
串葡萄放进榨汁机就马上求一杯饱满的果汁。

我们坚持一件事情，并非因为这样做了会有效果，而是坚信，这样做是对的。哈
维尔说。

只顾笃定往前走便是，胸中自有云月。
**** [[https://mp.weixin.qq.com/s?__biz=MzI0OTEzNzY3NA==&mid=402189489&idx=4&sn=52e6a4a3f19737ffb0f786bc26b0482b&scene=1&srcid=0118goA5DF1wmTRug9ZOpCti&pass_ticket=8B57gmAPihhXDqY3DNHOKiG9154WT42aR6KFVbb%2FAFpL7bBsnVOOoPubYSkLb3iH#rd][韩寒：长跑就是长跑，人生就是人生]]

很多人在长跑的时候喜欢思考人生，但对我来说，长跑就是长跑，人生就是人生，
我在长跑时考虑最多的时候是我的表情。

要知道我小时候一直是长跑队的，也拿了不少学校和区里的长跑比赛第一名。

其实我很早的时候是长跑的，如果我真的好好练的话，我的长跑应该可以到进国
家队的水平的。

我进高中是体育特招，长跑特招，我以前跑步是跑不快的，因为我的好朋友跑的
很慢，每次在体育课的时候我得跟他们做伴，他们跑得慢我也得跑得慢，有一次
误打误撞参加学校的800米和1500米比赛，第一次跑就两个比赛都破了校记录10
多秒，而且当中还停过，跑两圈以后，我以为到终点了，我跟同学们在欢呼拥抱
了，但是我们的跑道是250米一圈的。同学们给我欢呼完以后说哥们儿还有一圈，
然后我又追上去，还破记录，还拿的第一。

后来参加区里面长跑的比赛，8000米的也都很轻松地赢了，我自己从来都不训练。
跑8000米的时候，在街道上警察还带错路，我当时跑在第一，后来警察转身对我
说，哥们儿不好意思，我开错路了，然后又回到那条路上，等于我比人家多跑了
几百米，后来还赢了很多，体育特招进了市重点以后，学校里和松江区的、包括
跟体校在一起的只要是长距离的跑步的比赛，我都能赢，而且都能有很大的一个
领先的优势。而且我从来都不训练。

上学时别人说我是跑步天才，我觉的算不上，因为毕竟区或者是市一级的比赛还
是比较低的，但是如果我经过一些训练或者是怎么样的话，我相信我的长跑肯定
应该是挺好的。当然你不一定在世界上争得什么荣誉。

我当时穿篮球鞋在跑步，因为那个时候我爸爸一个月给我四五百块钱，我在外面
寄宿，我积攒了几个月之后终于有买球鞋的钱了，但是我想来想去，当时是灌篮
高手，爱面子，参加比赛就穿着很重的篮球鞋，如果有很轻的跑鞋的话，一定会
跑得更快。

可能是我的腿脚的形状比较适合长跑，耐力会比较好一些。我不会游泳，我很喜
欢骑自行车，当然不一定是奥运会的比赛，是好玩，参加一下。

但始终有一个问题困扰着我，那就是我的比赛照片实在是太难看了，每一张都是
面目狰狞，鼻孔放大，舌头外甩，眉头紧皱。而那些照片都被放在所有学生都能
看见的学校形象展示玻璃橱窗里，导致有一些女生看见我会说，哟，你真人没那
么丑嘛。

于是，长大以后，我选择了一个至少看起来比较酷的运动：赛车。最关键是，无
论我的表情是啥样，再也没有人能看见我的脸。我有头盔，而且选择了黑色的玻
璃镜片。

我对长跑没有眷恋，我抛弃了它整整十年。但跑步让我感触很深，因为这是唯一
一个我没能找到起点在哪里的比赛。

现在我三十多岁了，我又开始长跑。不为别的，不为思索，不为感悟，只为了自
己的身体。硬要我说出些什么，我只能说这是一个忆苦思甜的运动。

人在坐着的时候常常会想如果我能躺着那该多好；躺着的时候常常会想如果旁边
有一盘水果那该多好；吃到了水果常常会想如果有个人在边上给我按摩那该多好。
只有在长跑的时候我会想如果我能坐着那该多好。

**** [[http://www.cnblogs.com/skyseraph/archive/2010/10/30/1865280.html][完全用Linux工作-王垠]] :linux:

注：本文是清华“牛仔”王垠的“成名作”，在网上引起很大的争议。对他崇拜
地五体投地者有，对他嗤之以鼻者也有，总之成了一年多以前Linux

爱好者的圈子里的一个很有意思的现象。之后他对这篇文章进行了很大的修改，
已经没有了原来那种意气风发。现存的版本如白开水一般无味，请参见：
[[http://learn.tsinghua.edu.cn/homepage/2001315450/]]


尽管他原来的观点有所偏激，但我还是很欣赏他原来的风格。

***** “UNIX 是简单的，你不需要成为天才也能理解这种简单。”

由于GNU/Linux这个词太长，下面如果没有特别指明，“Linux”就是指“GNU/Linux”。

在这个年代，恐怕没有人需要我来介绍 Linux 是什么了吧？如果你觉得“Linux
只不过是跟 DOS
差不多的东西”，那你恐怕很久在山洞里没见天日了吧？请问问你旁边的 Linux
用户，Linux 到底是个什么地位？

那为什么我还要写一篇这样的文章？因为，我发现还有很多人不不理解 Linux 和
UNIX，虽然他们也在用它，但是他们有时会问：“为什么 Linux 不能像 Windows
那样 ......？”，“怎么Redhat Linux不能 mount NTFS
分区！”，“Linux下用什么整理硬盘？”，“什么时候OpenOffice才能完全兼容Word文件啊？”，“现在还有什么Windows能干的事情Linux干不了的？”......

他们有40G的硬盘，却只为 Linux
分配了2G空间，有时还抱怨“这个东西怎么占这么多硬盘！” 似乎
Windows该占用大部分硬盘。他们把重要的数据装在Windows的分区，似乎信不过
Linux。他们总是到处寻找新奇的，好看的GUI程序，对命令行的东西一概不屑一顾。他们对Drag&Drop，菜单配置，自动升级非常感兴趣。他们如果找到一个很像
Windows 程序的 Linux 程序，一定会很高兴的说：“哈哈！Linux
也能......了！”
如果Linux在某种测试中胜过Windows，他们会高兴得跳起来。他们没有办法用Linux解决问题的时候，甚至用Wine来运行Windows程序。有时实在没办法，只好重起到
Windows，或者干脆省得麻烦，在 Windows 下装一个 VMWare 虚拟一个 Linux
玩。

你支持 Linux，你喜欢
Linux，你能从中感觉到快乐，这非常好。你现在只需要明白的是：Linux
从来就不是一个玩具，它是天才UNIX的后代。UNIX
是自晶体管发明以来最伟大的发明，它从诞生那一天开始就比 Windows
的设计出色。Linux 并不需要追赶
Windows，不需要打垮微软，它的最终目标是改变整个计算机世界，还人们自由，给人们乐趣和方便。其它UNIX很多都已经败在Linux脚下，更何况
Windows！

你如果出现了以上的情况，说明你的思想受到了 Windows
的某种潜移默化的影响和误导。你没有能够从本质上理解存在于 Linux 身上的
UNIX 思想。UNIX的设计者 Dennis Ritchie 说：“Unix is simple. It just
takes a genius to understand its simplicity.”
但是我不这么认为，因为我不是一个天才，但是我却勇敢的把Windows完全删除掉，半年之后我体会到了
UNIX 的思想和好处。因为我相信这样的信念：“Windows 能办到的事 Linux
一定能办到，而且办的更好。”

这小节开头的话应该改成：“Unix 是简单的，但是在这个冲斥着 Windows
错误观念的世界，你需要信念和勇气才能理解它的简单！”
我下面就告诉你一些我理解到的东西。

***** 微软的地位

微软的名声在欧洲和美国的大学里，特别是在计算机系里之坏，大家可能有所耳闻。我认识的
MIT，Stanford
的教授，贝尔实验室的专家，甚至一个欧洲小国的高中计算机老师都绝口不提微软的名字。在他们眼里，微软只是一个没有真技术，专靠在落后国家商业宣传和垄断经营的小公司。这个“小”并不是说它人少，钱少，而是说它先进技术少。

我上次和王益合作写了一个算法演示程序，那个算法是贝尔实验室一位科学家Steven
Fortune很天才的发明，为了程序能够被身边大多数人使用，我们选择了 VC+MFC
作为平台。我在分析算法时还得到 Fortune
很热情的鼓励，寄给我一份资料，还多次回信耐心的给我讲解了很多细节。但是程序完成之后，我把样品发给
Fortune，他回信说：“对不起。我机器上没有 MFC。”
话说的很客气，但是我已经感觉到了他对 Windows 的不屑。然后我把 MFC
静态编译进程序再发给他，他就没有再回信了。他显然不是瞧不起我，而是确实有难处。

你能感觉到这位科学家对微软和 Windows
是什么态度了吧？不是反感，而是他心里根本没有 Windows
这个东西！微软在高科技领域没有发展，那么它怎么生存呢？到发展中国家去发展一下，他们的人民还对电脑一无所知，我说不定甚至可以打入大学的计算机系呢。我送他们软件，我捐钱盖大楼，我出钱找图灵奖获得者来演讲，让他们觉得我们都是科学家！

好了，现在全国的大学包括清华，几乎所有人机器必装盗版 Win2000，Office
XP，学校的选课系统是非IE不能正确浏览，论文用 Word
编辑，演示用ppt做，email 的通知附件是 doc 文件，你不用 Word 打不开，连
863 项目都用 VC
写程序了。我很久以前就看到一份报纸说，“微软为什么不严厉打击盗版？”
这篇文章说，微软非但不打击中国的盗版行为，而且有放任之趋势。放长线吊大鱼，“以后我要你们加倍的来还我！”
确实如此，它的目的快实现了。

***** Windows 笼罩下的中国计算机教育

说句丢脸的话，比尔盖茨很久以前是我的偶像...... //blush

在中国，比尔盖茨被很多人奉为神圣，“少年电脑天才”，甚至有的人提到他的名字就做出“抱拳对天”的姿势。很多人谈到微软的“新技术”，“高科技”
都是眉飞色舞。各种“VC编程圣经”，“深入了解 Visual
C++”之类的书，在开头几页都会出现非常肉麻的字眼，“在那团团的混沌中，一个开天辟地的精灵，Windows
1.0，诞生了......”

微软的软件被这么多人盗用，那么人们是怎样使用这些盗版程序的呢？先看看电脑培训班，教的都是一些
DOS 命令，打字，Windows 基本操作，Word
文档处理，PowerPoint，高级班可能有 Excel，Access......
参加各种微软认证考试，MCSE，MSDE
的人络绎不绝。考试辅导班都贴出了“280元，考过为止”之类的字样。考试参考资料更是昂贵，有些电脑书店整整两书架都是“Microsoft
Press”的东西。我有个同学参加认证考试，每门考试都要200多元。而且你一次考不过可以再考，又要交钱。他后来还津津乐道跟我说，看我，花了XXXX(一个四位数)元考过了微软认证，得到一张比尔盖茨亲笔签名的证书和价值6000元的
Windows XP 内部发行版。

“电脑要从娃娃抓起”，我们再来看看娃娃们学的是什么。大部分家长给孩子买了电脑之后，他们首先就会装一个盗版的
Windows，然后买来盗版的游戏开始玩。如果哪个孩子会用 Delphi
编程序，那可不得了。报社记者，电视台争相报导，说，某某学校的初中生某某，在别人都还在玩电脑游戏这种“初级阶段”的时候就已经用
Delphi 写程序了。镜头还瞄准了他显示器上面的像框中的比尔盖茨头像！

我刚进入大学计算机系时还不懂得什么是操作系统，因为我以前只用过“中华学习机”。看到新入学的同学们各个谈论的都是
“Windows 95”，“VC”......
我简直觉得我落后了好几十年一样，整个一土人，根本跟他们答不上话。好不容易找到一个比较熟的同学问了一下：“你们天天谈论的瘟95是什么啊？”答：“win95就是一个操作系统，跟DOS是一类。”“朵死是什么？”
“你连DOS都不知道是什么？别在计算机系混了。”
学校上课当然不讲VC编程之类的东西，但是上 Pascal
的老师有一次就说：“嗨，我们学校真是落后。现在别人都用 C, C++，甚至 VC
了，我们还在讲
Pascal。不知道什么时候才能有VC课啊。你们出去也是要用VC的，只好自学了。”
于是，有些同学很多时候上课都捧着一本很重的“Windows
编程大全”之类的书，根本没有听课。吃饭时就念念有词的跟我说，“代码的优化是无止境的”，“匈牙利命名法真是伟大的发明”
...... 这就是中国很多大学计算机系的情况。

感觉到无知了？这不是偶然的，而是微软长久以来埋下的伏笔。它要让无知的大家都把它奉为神圣，它要让支持UNIX，Xwindow的人一旦说
UNIX 好，Xwindow 好的时候，都被一群人围着说教：“这个 Windows
也能做到”，“你对 Windows 有偏见”，“微软才是主流啊”，“你敢瞧不起
win2k？”，“.NET
就是世界潮流”，“微软的毕竟是新技术”，“有钱就是有技术”......
甚至在一番论战比较后败下来还是要说：“Windows
性能差点，但是易用性强”，“Windows
是老百姓用的，要求别那么高”，“微软那么有钱，以后想超过 UNIX
还不容易吗？”......

***** 发达国家的计算机教育

我前段时间在 USENET 发文问有关 Scheme
语言的问题时，认识了一位丹麦人。他解决了我所有的问题，并且建议我阅读一些很“深奥”的有关程序语言语法，文法的书，他告诉我很多网站可以学习
LISP，Scheme，人工智能，算法。他叫我看 Jonathan Rees 的论文 "Syntactic
Closures"。他还打包给我寄过来一份 MIT 的 "How to Design
Programs"。他说他在自己的 PC 机上装的是 Linux，他用 Emacs 编辑，运行
Scheme 程序。他对 Emacs
的了解和爱好真是使人惊讶。他大学本科毕业时做的毕业设计是一个 Scheme
解释器。这对于我来说是望尘末及了。

他是那么的不厌其烦，我的每一个问题他都详细的回答。我有时都觉得过于详细了，怎么这么耐心啊？我觉得他似乎是我的高中老师。他是什么样的人呢？我好奇的打听了他的情况。原来，她是丹麦一所普通高中的计算机老师，而且是个女老师！

她说她在高中里讲授程序设计和算法，计算机语言文法。她说用
Scheme，她的学生不用再为内存泄漏等程序语言本身的问题而烦恼，而专注于问题和算法本身。有利于培养学生解决问题的能力，特别是用计算机解决数学问题的能力。

天哪！为什么欧洲出现那么多数学家，几何学家？你看看别人重视的是什么！我们的计算机教育如果继续这样下去，只会沿着弯路越走越远！

***** 微软和它的朋友们的如意算盘

下面来看看微软的收入是怎么来的。首先，Windows 98系列操作系统，一个就是
100 多美元，每次升级又是几乎同样的价钱。Windows NT
还要贵几倍，而且有用户数目限制，5个用户的，10个用户的......
以后如果要增加用户数目还要按比例付钱。这个奇怪的现象被通用汽车公司的总裁比喻为：“你买的微软牌汽车最开头只有一个座位，每加一个座位你得向汽车公司付钱，每开100英里要大修一次，每过一年要换一次引擎。”

花了如此多钱买来的操作系统就能用了吗？它竟然连压缩程序都没有提供！你装上
Windows 之后一般第一件事就是去下载一个 WinZip 吧，“只要 29
美元”。Windows 会中病毒啊，马上花 70 美元买一个 Norton AntiVirus
吧。还有黑客呢？再买一个 Norton Internet Security 好了，100
美元。系统需要优化，磁盘需要整理，买一个 Norton System Works
是你最佳的解决方案，100美元。

可是你现在还是不能干正事啊！你想要一个 Word, PowerPoint？那就买一套
Office XP 吧，一起买便宜些，9.90。

那些程序不会用啊！那些菜单怎么设置，到底有什么功能啊？看“帮助”也学不会。买本书看看吧，我推荐“Special
Edition Using Microsoft Office
XP”，不贵，.99。这本书里面大部分是屏幕抓图，还是买一本旧的比较划算，.85。

你如果只是当个秘书，上面的差不多还凑合了。可是你有更高的追求，你想成为
Windows 程序员。首先买一个 Visual Studio.NET
吧，要不然怎么编译程序。4.95。

为了紧跟微软动向，世界潮流，不能不注册个 MSDN
什么的吧？这个贵一点，不过物有所值啊，,799。

嗯，你现在已经是上层阶级，白领人士了。你现在可以像这样“自由”的，“安全”的生活了：

***** 什么是 Windows 能干而 Linux 干不了的事情？

“Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”

有个朋友看我半年没有用 Windows，有时就会问我：“你只用
Linux，有没有发现有些 Windows 能处理的事情 Linux 干不了？”

我回答说：“Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”

Windows 能做的有益的事情 Linux 都能做

Windows 下的某些功能确实是我们需要的，那么 Linux
的开发者们和用户也需要这种功能，他们就会去实现这种功能，而且比Windows
的方式好得多。由于大多数科学家，工程师用的都是 Linux 或者某种商业 UNIX,
所以几乎所有商业的科学工程程序，比如Matlab, Mathematica, AutoCAD,
Candence的，Synopsys的，Avant! 的......全都是先有 UNIX
的版本(包括Linux)，然后再考虑移植给 Windows，甚至根本不移植给
Windows，因为 Windows
的机器一般没有足够的能力运行这样的程序。你不要以为只有 Windows 才有
PSpice, UNIX 的 HSpice
要好得多，而且可以运行在大型主机上。当然它们不是免费的，但是它们值那个价钱。

但是 Windows 下有些东西在 Linux
下没有很相似的，或者你找到很多类似的，但是它们每一个比起 Windows
的那个程序都要差很多，那么原因有两种可能性：

1. 有一个完全类似的程序，但是由于它乍一看不漂亮，被你忽略了。

而其它程序虽然看起来很漂亮，但是它们是一些初学编程的人写的。现在由于
Gtk+, Qt 的诞生，Linux
下开发图形界面程序极其简单，很多初中生甚至小学生都可以随手编出一些漂亮不中用的程序。如果你整天寻找这样的程序挑来挑去，永远也找不到你满意的。

我曾经也犯过这样的错误，优秀的 FVWM, lftp, Mutt, wget
都被我忽略过！当我找回它们的时候，我是那么的羞愧不已，它们现在都是我的朋友
:) 用这些程序你可以改变它们的一切，我第一次看到 FVWM
觉得它只不过是一个有很厚很难看边框的东西。可是现在，我的同学看到 FVWM
都说：“哇！真漂亮。”

2. 有另一种完全不同的方式可以达到相同的目的，甚至更好。

很多人很关心 Open Office, Star Office, AbiWord, ...
他们多么盼望有一天某一个 Linux 程序能够完全兼容的打开一个复杂的 doc
文档。但是你永远也不可能有那一天。为什么呢？因为微软为了占有市场，必定不会让其它系统的程序能够完全兼容它的文档格式！它一定会不断变化
doc 文档的内部结构，隐藏一些秘密，让其它公司的程序打开 doc
文档时总是有某种问题，从而你必需购买 Microsoft Office 和Windows。

你应该想一下，那么多的高智商的大学教授，科学家，学生，他们用的都是
Linux 或者其它类型的 UNIX，他们没有 Word
可用，怎么处理文档呢？这么多年没有一个像 Open Office
的程序出现，难道大家没有办法写文档吗？

显然不是这样。你看看那些高水平的学术杂志，论文，那些大学教授的网页，那些漂亮的PDF幻灯片，它们是什么做的？原来
UNIX 用户早就有非常方便的 troff, LaTeX, SGML
等东西可以处理文档，而且它们比起 Word 都要高明的多。Word
显然被这些大拿忽略了，以至于很久以来没有人想在 Linux 下开发一个类似 Word
的程序，除非某些公司想抢微软的饭碗。

很多人留着 Windows 在硬盘上的原因无非是为了用 Word 和
PowerPoint。你待会儿可以看看我的TeX网页，你就会知道为什么我可以完全离开
Windows.

***** Windows 能做的那些没用的事情 Linux 永远做不好

1. 电脑游戏

有些人说 Linux 下不能玩 Windows 下所能得到的所有游戏。的确，Linux
下虽然也有少量的游戏，比如 Quake。但是它没有 Counter Strike, 没有 Star
Craft, ......

并不是说电脑游戏不该玩，但是应该适可而止。电脑是用来处理事务，帮助你学习，解决问题的工具，而不是一个玩具！整天沉迷于电脑游戏中，而不出去感觉外面的世界，你会变得越来越冷酷，越来越缺乏人情味。你与真实的世界越来越远。

你可以在 CS 里杀人，你可以在 Tomb Raider 里探险，你甚至可以在 Tony
Hawk's Pro Skaters 里滑板...... 但是 It's not
real！你虽然有很高的“反恐技巧”，但是遇到歹徒的时候，你是那么的怯懦；你虽然控制
Laura 伸手敏捷，但是你打篮球的时候怎么总是被人断球？你虽然可以轻易的在
THPS 里作出一个 "360 kickflip to hangten grind to
fakie"，但是你踩在自己的滑板上的时候还不会 ollie！

说回来，如果你偶尔玩一下电脑游戏未尝不可。但是世界上有远比 Windows
+ PC 更好的游戏方式。Sony 的 PlayStation2, SEGA 的 DreamCast, Nintendo
的 N64，Namco 的街机......每一个都比 Windows
游戏精彩，每一个都有如此高的3D性能，以至于 Pentium4, Itanium + GForce4
都无法与它们比美！

Linux
的用户们都是关心解决世界的关键问题的份子，他们哪里有时间用自己的机器来玩游戏啊？他们每天用Linux高效的做完自己的工作就到阳光下享受自然去了。要玩游戏也是玩一些类似推箱子，贪吃蛇之类的智力小游戏。所以，你知道为什么
Linux 几乎没有游戏了吧？:)

2. “整理硬盘，优化系统”

这是一个非常有意思的话题，仅次于有关“病毒”的话题。相信很多 Windows
用户都有整理硬盘的经历。在很多 Windows
用户眼里，“硬盘用久了，会出现碎片，速度会减慢，需要一个程序来整理，整理硬盘的时候不要做其它工作”，这好像是天经地义的事情。

我也曾经津津有味的看着 Norton Defrag
一点一点的把我的硬盘排序，调整，用图形的方式显示出来，然后报告：“100%
没有碎片。你的硬盘现在已经达到最佳状态。”
我现在才发觉我那时是多么的幼稚。

Linux 和 UNIX
用户似乎从来没有“整理硬盘”这种说法呢？你觉得很奇怪吗？如果你觉得很奇怪，那说明你的思想在某种程度上被微软的垃圾程序禁锢了。你需要明白，UNIX
的大型主机很多必须是一天24小时，一年365又1/4天不停运转的，要是每个星期都要整理一次硬盘，在整理的时候几乎不能干任何事情，那是绝对行不通的！

Linux 机器根本不用整理硬盘，这就是为什么没有看到过 Linux
用户整理硬盘。Linux 的文件系统是比 Windows 的 FAT, FAT32, NTFS
高明得多的文件系统，它们不但可以对文件设置权限，实施完全的保护，而且可以“越用越整齐”，“越用碎片越少”！你应该把文件大部分放在
Linux 的分区，而不是 Windows 分区，因为它比 Windows 分区可靠得多。

还有更滑稽的事情就是有很多“Norton System Doctor”，“Windows
优化大师”，“超级兔仔注册表魔法”
之类的程序存在，而且价格昂贵。似乎一个操作系统本来应该有很多问题，需要别的厂商做程序来“优化”它，而且为了得到优化，你需要付钱！这些问题
Linux 根本就没有，所以不需要什么优化。Linux 内核本身就是高度优化的。

3. IDE

有些人在抱怨为什么 Linux 没有一个良好的 IDE 开发环境。Linux
现在已经有一些 IDE 了，但是总是有很多问题。你是不是正在寻找，正在期望
Linux
某一天可以有一个VC那样的开发环境？你有没有发现你正在进入微软给你设下的怪圈？你为什么一定要用
IDE？你说：“IDE 开发迅速，调试方便，适合大型程序......”
那说明微软的程序在你脑子里已经比较根深蒂固，你需要好好清醒一下了，看看我来告诉你。

高明的 UNIX 程序员不用 IDE，IDE 从来就是给初级 Windows 程序员用的。

你看看大型的 UNIX 程序，包括 Linux 内核，各种网络服务程序，Xwindow
程序在内，哪一个是 IDE 搞出来的？我们实验室的 EDA 程序也没有一个是 IDE
弄的，我还知道 Candence, Synopsys，Mentor 的高性能的图形界面 EDA
程序也都不是 IDE 写的。你信不信，微软的人在写 Windows
本身的时候也根本不用 IDE！

有一次某杂志采访一些出名的 Linux 内核程序员，包括 Linus
在内，没有一个人用 IDE，有的人用 VIM，有的用 Emacs，只有 Linus 说“GNU
Emacs is evil”，但是其实他用的是一种跟 Emacs 有同样键绑定功能的
MicroEmacs。大家都是用编辑器编辑了程序文件，然后用 make
这样的自动工具调用 gcc 编译器完成编译工作的。

我以前也编过 Windows 程序：应用程序，驱动程序。但是我没有用 VC 的
IDE。Linux 教育了我，我会在命令行调用 CL，我知道 CL 才是 VC
的编译器。我可以在 cygwin 的 Makefile 里使用 CL。我还知道 CL
的参数都有什么用处。但是这些不是一个从一开头就用 IDE
的人能很快理解到的。

我相信: IDE is evil。我有一些用 Windows 的 IDE
写程序的朋友，他们对那套东西已经很精通了。但是我却惊奇的发现，他们竟然把编译器和汇编器的概念都分不清楚，甚至有的人连“编辑器”和“编译器”都搞混淆了！他们只知道在一个窗口里输入了代码，点击一个按钮就可以编译程序，但是这里面到底是怎么工作的，他们不知道！他们被盖在上面的窗口挡住了视线，甚至会以为那个按钮就是编译器！

他们对那些 IDE
的热键背的滚瓜烂熟，但是我却看到他们在一个函数一个函数的把别人的 ANSI
风格的代码变成 VC 的风格。想想这件事在 VIM
里有多么简单，一瞬间就可以搞定。

为什么 UNIX 程序员不用 IDE？明白了这个道理你就能体会到 UNIX
的设计思想了。首先，一个 IDE
集成了编辑器，编译器，汇编器，调试器，跟踪器......
这个编辑器功能肯定比不上 VIM 或 Emacs，编译器比不上 GCC，汇编器比不上
as，调试器比不上 gdb, ddd, 跟踪器比不上 strace, ltrace,
truss。你得到的是一套整合的低能的程序。如果你对调试器的功能不满意，你只好换用另外一套
IDE，但是这套 IDE 的热键，菜单，编辑器功能，按钮......
跟原来那个有很大不同。你不得不花很多时间来熟悉新的环境，而不能保持原来的某些东西。

而在 UNIX 下就不一样了。你可以用你最喜欢的 VIM 编辑程序，你在 VIM
里可以调用 GNU make，make 可以调用 gcc, ld, ... 实际上 make
能帮你很多忙。make 的出错信息可以被 VIM 捕获，VIM
能帮你在源程序里定位。你如果喜欢 icc, 你可以让 make 用 icc 而不是
gcc。你如果觉得 gdb 跟踪变量时比较麻烦，你可以用 ddd
来显示各种数据结构之间的关系。你还可以在 Emacs 里调用
gdb，那样就可以同步显示源代码了。而且 VIM 和 Emacs
还可以编辑很多其它东西，比如信件，LaTeX 文档，HTML，配置文件......
你不用另外找一个什么编辑器来干这些杂活了。很多程序比如 Mutt, tin
都可以在内部使用 VIM，这样就更方便了。

4. 释放内存

我在 Windows
下做过的一件最傻的事情莫过于“释放内存”了。有一天我看到一个 Windows
程序说：“这个程序可以帮你把大量内存释放出来给一个很大的程序用。”我试了一下，居然一下把我的
64M 内存释放出来
48M！我高兴极了。现在想一想，那是多么傻的事情，那么多的内存留着干什么？不用白不用啊！一个操作系统，居然还需要别人写的程序来释放内存，那是什么样的操作系统？

在 Linux 下用 free
命令，你会发现你的内存几乎每时每刻都快要被用完。那是因为 Linux
把大部分内存用来作为磁盘缓冲了。Linux 有比 Windows
先进的磁盘缓冲技术。你有没有发现你往硬盘写数据的时候，很快就完成了？那是因为
Linux
在内存里有很多磁盘缓冲区，你要写到硬盘上的数据先被写到了这些内存里，然后
Linux 就告诉你“拷贝完成”，当你马上又想删除刚才写入的某些数据时，Linux
只是把数据从内存里移除，然后报告“删除完成”。在一定的间隔时间后，Linux
才把数据写回硬盘，这样不但高效，避免了多次硬盘操作，而且减少了文件的不连续，也就是减少了“碎片”。Windows
当然也有磁盘缓冲，但是由于它内存管理的低效率，它不敢把大量内存都用来作为磁盘缓冲，因为它没有能力在用的时候随时把内存收回来。

***** Linux 能干的高级的事情 Windows 都干不了

当然有很多事情是Linux/UNIX的专利了。因为 Windows 只能装在 PC
机上，好像以前也有 Alpha 可以使用 Windows NT，但是就是没见到有人用。PC
机的能力是很低的，像我们编程序处理 NP-Hard 问题的人，用 Windows
的机器显然速度不够，而且有时一个问题算上几天甚至几个星期，Windows
机器是以“死机”著称的，我们怎么能放心？

所以几乎所有科学计算程序，EDA 程序，高性能图像处理程序都不是 Windows
的。他们有时也会移植一些给 Windows，但是常常降低那些程序的能力。你比较过
Windows 版本的 Mathematica 和 Linux 的有什么区别吗？

IBM 制造的最大的并行计算机有 8000 多个处理器，Windows
不可能有能力管理这么多处理器，它用的是什么操作系统？答案是 Linux。

《[[http://fifid.com/site_search?cx=003017831450918707819%3Ae2pgfm8nybw&cof=FORID%3A10&ie=UTF-8&q=%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7][泰坦尼克号]]》电影里的三维动画，那么细腻逼真，Windows机器能做出来吗？不行。那也是
Linux 机器做的。

民航总局用来训练地情人员的虚拟现实训练设备，Windows
当然无能为力。那都是商业的 IRIX 机器。

UNIX 是最早支持 TCP/IP
网络协议的系统。它上面有很多可以互相协作的网络服务程序，它们经过多年的使用和修订，已经达到比较完善的程度。而就在1997年，微软的比尔盖茨还在扬言：“Internet
是没有前途的。”
微软的这个“远见卓识”大家应该都已见识，它后来加上的网络服务程序IIS漏洞之多，让公安部都频频发出警报，大家也是见识了的。

其实你知道了，Windows 没有一样有用的事情能比 UNIX 干的更好。

***** Linux 干不了的有用的事情 Windows 照样干不了

当然 Linux 不是万能的。它也有不能干的事情，电脑也有干不了的事情。但是
Linux 干不了的事情，Windows
肯定也干不了。这些事情就是我们需要探索，需要努力的事情了。在你探索的过程中，Linux
必定是你的好伙伴。

Windows 的流毒

不要用 Windows 的方式来思考问题

什么？你早就知道 Windows
是垃圾？噢！你怎么不早说呢！害我废话这么多。嘿嘿。

“好了。你知道 Windows 是垃圾，你现在用什么？”

“Linux + Xwindow”

“那我问你，Xwindow 是什么样的？”

“不就是跟 Windows 差不多吗？只不过 'Start' 按钮比较方，而且上面不是一个
Windows
标志，而是一个脚丫子。点击一下居然还有很漂亮的中文菜单。我喜欢！”

“你知道什么是‘根窗口'吗？”

“不知道。从来没听说过呢？”

“根窗口就是遮盖整个屏幕的那个最大的窗口。”

“哪儿有什么窗口啊！我没有看到呢？”

你发现了问题吗？这些 Linux 用户说是在用 Linux 和 Xwindow，但是他们对
Linux 和 Xwindow 几乎完全不了解。很多人用了那么久 Xwindow
都不知道根窗口是什么东西，不知道其实按钮也是窗口，不知道窗口管理器和
Gnome，KDE
有什么关系，大家都以为窗口上面的按钮是程序自己放上去的，不知道窗口的“class
name”，“resource name”是什么东西。他们被遮在 Linux
之上的一层一层的包装迷惑了！

当我告诉一个既能用 Windows 又能用 Linux Qt 编程的朋友 Xwindow
的“中键粘贴”是怎么回事时，他大吃一惊，说：“Xwindow
怎么这么落后啊！居然请求剪贴板的东西时还要联系剪贴内容的所有者自己来转换格式！你看看
Windows 的剪贴板......” 经过一顿饭的友好的讨论之后，他不得不称认，这个
Xwindow 用了几十年的方法比 Windows 的剪贴板要合理的多。

后来又有一次，我告诉他每个 Xwindow 的按钮都是一个窗口。他说：“不会吧～
这样效率一定很低。你看看 Windows 的按钮 ......”
又是一顿饭之后，他说：“哎呀。不得不承认 Xwindow 的方式是良好的设计。”

现在很多人已经把能够利用别人的库写出一个好看的程序作为自己编程水平的象征。在这个“图形化”，“可视化”
的年代，你如果还在用 troff, LaTeX 写文档，你还在用 VIM 自己编辑 HTML，用
Mutt 处理邮件，你还在用文本模式的 gdb 调试程序，你还在用 Xlib 写程序,
你还在用 tin 上 USENET，你还在自己写 Makefile，写机器代码，你还在玩
Clossal Cave 这样的字符模式冒险游戏，那你就是老古董，不合时宜，变态。

其实这种思想是错误的。虽然你是一个坚决的 Linux 支持者，但是你的思想是
Windows
的思想。你认为图形界面，菜单，按钮就可以解决一切问题，就可以给你高效方便。你要做坚决的
GUI 派而不是 CLI 派 ......
你还是没能摆脱微软给你的潜移默化的东西。你其实离不开 Windows
那样的环境，你害怕符号，你迟早会删掉自己的 Linux。

***** GUI vs. CLI

UNIX 和 Xwindow 是一家

大家看到这个标题是不是热血沸腾？两派大虾都可以围攻我了：

GUI派用户：“哇！我一看你这小子就是 CLI 的。要不然自己写什么
Makefile？用什么 Mutt？”

CLI派用户：“切～ 你还用 X！高手都不用 X。你是 GUI 那边的。”

可怜的我：“555～～你们都不要我～～ GUI 和 CLI 就那么水火不容吗？”

计算机界这样的门派之分还很多。很有特点的就是 CLI 和 GUI 了。CLI (Command
LIne) 的狂热份子声称永远不用 X。我上次在实验室看到一个同学用一个
SecureCRT 登录到 Sun 机器，然后用一个 vanilla vi
编辑程序，我建议他启动一个 GVIM 过来显示在 Exceed
上可以有语法加亮。但是他坚决反对，说：“高手不用X。你想想，要是我在一个很慢的网络连接怎么用
X？而且好多服务器没有装 X 程序。”

但是我们实验室的网速可够快，Windows 机器都有 Exceed 啊，而且 Sun
机器有全套 X 客户程序包括 GVIM。他说他是 CLI 的坚决拥护者，但是他却在用
Windows，他后来打开了好几个
SecureCRT，每次从文本框输入地址，用户名和密码，从下拉菜单选择
"SSH2"，然后点击“Connnect”。他还不断的夸SecureCRT是“网络管理员投票选出的最受欢迎的登录方式”。老天，SecureCRT
本身就是个 GUI 啊，他其实是一个 GUI。

你说我是 GUI 的？我虽然很少在 console 下工作。但是我对 bash, VIM
很熟悉，我可以让 bash 按照我的键绑定方式来工作。我可以在 rxvt 里使用
Mutt 来收发 email。我的每个桌面上都常常堆放着一打不同大小的 rxvt。我用
VIM 编辑 LaTeX。我自己写 Makefile 来维护 LaTeX 文档。我有时用 mpg321
来放 mp3。我上BBS用的我自己写的 expect 脚本，定义了很多热键，我只要
Ctrl-H 就可以随机变化我的签名档和说明档。我的 expect
脚本有高级的自动回复功能，甚至可以以假乱真，让你看不出其实我不在，你有可能跟我的机器人聊上10分种才发现那不是我
:p 好了，CLI 派的朋友可以收我做盟友了 :)

你说我是 CLI 的老古董？我的 FVWM
被我配置为可以“手写操作”，我只要画一个"r"就可以启动 rxvt，我只要画一个
"U" 就可以启动 GVIM，...... 我用 GVIM 语法加亮模式编辑程序，我用 Mozilla
浏览网页，...... GUI 派的现在好像认我做朋友了 :)

好了。CLI
派的朋友，虽然我很喜欢命令行，但是我有时在屏幕上左右画一下就可以执行:

Module FvwmConsole -terminal rxvt -geometry 45x5-0+0 \

-bg gold -fg midnightblue \

-fn "-adobe-courier-medium-r-*-*-14-*-*-*-*-*-*-*"

你是不是现在又想把我逐出师门？

GUI 派的朋友，虽然我很喜欢窗口。但是我可以在 FvwmConsole 里输入：

All (rxvt) MoveToDesk

把我所有的 rxvt 移动到我现在工作的桌面。“这家伙，怎么这么快就叛变了！”

其实何必分什么 GUI 和 CLI，UNIX 和 Xwindow
都是工业标准，它们从设计那天开始就有非常灵活的用法，各个程序，不管是 GUI
还是命令行的都可以互相协作。UNIX 和 X
是一家，何必搞的那么偏激，非此即彼？你从我上面的行为可以看出 GUI 和 CLI
的模糊界线吗？你说我是“花心大萝卜”？花心就花心。hengheng :P

UNIX 的真谛何在？

***** 让聪明人干任何他们想干的事情。

UNIX 的一个特点就是非常高的灵活性，Xwindow
也具有这种灵活性。这种灵活性体现在哪里呢？

UNIX
的程序一般都有很多参数，不管你现在用的着用不着，总有人需要某些参数。它们的行为很多都可以用配置文件来改变。比如
GNU bash, 通常缺省的命令行输入方式是 Emacs 方式，但是只要我编辑一个
.inputrc 文件，就可以把它变成 vi
的输入方式，而且我还可以自己绑定键序列到某些操作。我可以用 shopt
来设置它的很多特点，比如是否进行通配符扩展，是否可以把一个变量当作一个目录来cd，是否可以自动纠正某些明显的目录名打字错误
......

UNIX
程序设计的思想是提供给用户“机制”，而不限制用户制定“政策”。这是一个重要的尊重用户的作法。

我们再来看看 Xwindow。Xwindow
是一个出色的设计，它把显示服务器和客户程序分开。一个显示上既可以显示本机上的程序，也可以显示别的机器上的
X
程序，而它们都遵守你的窗口管理器的统一指挥，它们之间可以方便的传送剪贴版数据，各种事件
...... 比如有时我的 XFree86 上会出现四个不同机器上的
XTerm，两个不同机器上的 GVIM，...... 它们统一受本机上的 FVWM 指挥。

Xwindow 程序都具有很多很多命令行参数和 resource
参数。你可以随意的在命令行或者 .Xdefaults
文件设置所有的颜色，字体，尺寸...... 而且如果你用 xrdb 把 .Xdefaults
导入到根窗口，那么其它机器上没有经过配置的同样的程序，显示到你的机器上的时候也会遵守同样的外观规定。

Xwindow 的窗口具有 Property,
也就是一些可以自己定义的共享数据(原子)。正是因为这些 Property
的存在，使得 Xwindow 具有无比强大的生命力。X
的窗口管理器和其它客户程序之间并没有统一的协议，但是后来出现了
ICCCM(客户程序间通信规范)，这个规范就是通过 property
定义的。现在又有人定义了一套“扩展的窗口协议(EWM Hints)”，使得 Xwindow
可以具有某些 Windows
的特征，比如一个工具条程序可以告诉窗口管理器：“这个屏幕下面被我占据了24个像素的空间，你最大化程序的时候不要越过这个界线。”

一个强大的窗口管理程序比如
FVWM，它收到这样的提示时，可以答应工具条程序的这个要求，也可以不答应。一切选择的权力在于谁？当然是用户了！一切窗口乖乖听话，FVWM
给予用户最大的尊重。

你想想，是不是有些 Windows 程序常常弹出一个窗口要你选择 "Yes or
No"？你不点击它它就不下去。你觉不觉得你的程序在侵犯你的尊严？你是一个人，一个智慧的生物，怎能受到一个程序如此的待遇？

还有就是很多 Windows
程序把人当成傻瓜，而它是“智能程序”。比如，有一个程序就是喜欢把你的每句话第一个字母都变成大写，我不说它是谁了，你遇到的时候就知道了。如果连“一句话开头一个字母要大写”这么明显的问题都需要程序帮你纠正的话，人脑还用来干什么？况且如果你故意想要不大写的话，那就更麻烦了，我楞是没有从它那一大堆菜单里找到怎么关闭这个愚蠢的选项。

***** 只有符号才能完全操纵计算机。

我们来说说很多初学 Linux 的用户。虽然他们在用
Linux，但是他们打心眼儿里是觉得 Windows 的工作方式好，他们希望 Linux
有一天能“像Windows那样”。你说：“我鼠标一点，我菜单一拉，......
就可以完成我的操作。” 但是我要告诉你：“Linux 从来没有摹仿
Windows，将来也不会。Linux 从诞生之日起，它的工作方式就比 Windows
的先进。Linux 属于能勇敢面对符号的人。只有符号才能完全操纵计算机。”

看看优秀的 UNIX 程序，XFree86, FVWM, VIM, Emacs, proftpd, Mutt, wget,
tin, ...
没有一个不是用配置文件来设置选项的。为什么这些程序没有方便的菜单可以用来配置？难道它们的设计者就那么低能，连个图形配置界面也写不出来？

当然不是。因为图形界面配置方式的能力是极其有限的，而配置文件和程序语言的表达能力却是无限的。用图形界面配置这些程序的话，如果你想达到配置文件的效果，你需要成百上千的菜单，checkbox,
radio button, ...
到时候你根本没办法找到你需要修改的地方了！而各个程序的配置文件的语法都有很多相似之处，一般就是一些命令，设置一些变量，参数，......
一旦用会了一个，其它的也就容易理解了。如果你用惯了 awk, sed,
Perl，你会觉得那才是真正的自动化啊。

鼠标虽然是很好的工具，但是它的表达能力是有限的。你不可能光用鼠标就让电脑完全明白你的意思，它毕竟只有3个按钮。看看我的MetaPost页你就能体会到鼠标的这一弱点。所以我们虽然很喜欢鼠标，但是却不能完全依赖它。

***** 各个小程序的完美配合

这就是UNIX最重要的特点了，它就是UNIX设计的思想。让每个程序只具有一项专门的能力，然后让它们合作。Xwindow也继承了这种好传统。

这恐怕就是Windows和其它操作系统望尘末及的地方了。UNIX
程序设计之统一，配合之完美，真使我难以置信！shell, grep, find, awk, sed,
make, Perl, Emacs, vi, tin, Mutt, ...
它们是那么的具有一致性！你一旦学会了 sed
的正则表达式，其它程序基本上都能用了。你一旦学会了 vi 和 VIM,
你会发现它的操作是那么的有规律性，似乎vi的设计者在几十年前就已经设计好了
VIM 在今天的完美而统一的操作方式！而且vi的操作还体现在 Mutt, tin
等很多程序中。你甚至可以把 bash 设置为 vi
的输入方式来输入命令行，我就是这么做的。一个程序可以调用另外一个程序来得到数据，可以把数据交给它处理后返回来，可以在自己的窗口里“嵌入”另外一个程序。

在 Windows 和其它非 UNIX 操作系统中，这种合作是非常困难的。我曾经在
Windows 下使用 Perl来进行一些自动工作。但是 Windows
的文件操作，管道是如此的不稳定，程序之间基本不能合作。你别想在 Visual
Studio 窗口里面嵌入 UltraEdit 编辑器，你别想用一个 expect 脚本来控制
telnet 到水木清华BBS，这就是为什么 helloooo 诞生在 Linux 而不是
Windows。我曾经试图从 Windows + Exceed + SecureCRT ssh 登录到 Sun
机器，然后通过 ssh 的隧道(X11 tunnel)把 X 程序传到 Exceed
上运行，但是搞了两天都没有成功！而在 Linux
下这个事情根本就是不用怎么配置的，OpenSSH 和 XFree86
本来就是完美结合，只要打开 ssh 的 "forward X11" 选项就什么都搞定了。

Windows
的程序都是大而全，大而杂，所有的电子邮件程序都需要自己提供编辑器，自己发送和收取邮件，自己显示邮件的附件。每一个BBS程序都提供自己的Virtual
Terminal, 自己的通讯代码。每一个 IDE
都自己提供编辑器，编译器，汇编器，调试器。人们为了使用一种新的程序，需要适应所有这些它提供的界面，而不能使用自己喜欢的编辑器的键绑定，菜单组织......
不能 DIY！

你要知道，最高级的电脑是定做的，自己想要什么什么CPU，什么主板，多少内存，什么硬盘，键盘，鼠标，显示器都是自己选择的。最高级的滑板，自己想要什么牌子的版面，什么牌子的沙，什么桥，什么轮子，什么轴承，也都是自己选的。最高级的乒乓球拍，木板，胶皮，海绵，胶水都是可以自己选择......
而用 Windows
程序，你得到的是大杂烩，就像你去买“品牌机”，只有那么几种配置，而且附带很多你不需要的软件和服务；就像你去买组装好的滑板，你想要大一点的轮子和窄一点的板子，但是你没有这种选择余地！Windows
程序就相当于最廉价，最次的滑板。但是它却会花你更多的钱，因为一旦一个部件坏了，或者你不喜欢了，你不能另外找一个好的换掉它，你必需重新买全套配件！

而 UNIX 和 Xwindow 就是高档的“组装货”。比如我用 Mutt 的时候，我可以用
VIM 也可以用 pico 来编辑邮件，我可以用 ImageMagick 也可以用 xv
来显示附件里的图片，我可以用 lynx 把 HTML
附件转成文本嵌入窗口中，我也可以把 HTML 附件交给 Mozilla
图形显示。我可以让 GnuPG 帮我把邮件进行数字签名和加密，我也可以用其它
PGP 程序。我想让 Postfix 而不是 sendmail 帮我发出邮件，我想让 fetchmail
帮我收邮件，转发给 postfix，然后被我自己写的Perl过滤器处理......
这一切我都可以办到！我可以选择我最喜欢的专门的程序来完成专门的工作，然后把它们结合在一起，我也可以分别得到它们的好处。

***** 结论

我写这么多的目的是什么？我希望喜欢 Linux 的朋友，完全清除微软和 Windows
灌输在你脑子里的谬论，别再相信它们所谓的“新技术”，别再追赶
Windows，因为追赶 Windows
＝倒退。马克思有一个思想很重要，“新生事物并不一定是在最近出现的。”
UNIX，Xwindow, TeX 虽然都比 Windows
先出现，但是它们才是先进生产力的代表。我们要清楚的认识到什么才是真正的现代化，什么才是真正的自动化。

勇敢的拿起像 bash, FVWM, TeX, VIM, Emacs, Mutt, lftp ......
这样强大的程序，勇敢的面对符号。不要再埋怨“Linux 为什么不能像 Windows
那样”，不要再浪费时间试用这样那样的程序，不要再忙着升级。需要改变的是你自己，而不是
Linux 和 Xwindow，Linux
现在就可以成为你的好朋友。你需要认识它，了解它，信任它，才能完全的靠它来高效的工作，省出时间来处理世界上更加值得处理的事情。

***** 附录: 我用来处理日常事务的 Linux 程序

好了好了。我知道你发现自己应该转向
Linux，你很后悔当初为什么中了微软的邪。但是不要着急。因为这些东西本来只是工具，它们是用来完成你的主要任务的辅助而已。你以前选错了工具，这不要紧。你还是拥有你自己原来的专业技能，那才是最重要的。工具的东西只有慢慢适应转换，不能一蹴而就，否则你会感到非常没意思，甚至放弃。

这里给出一些推荐使用的可以处理一般事情的程序。至于你的专业上要用到的科学和工程软件比如
Matlab, Mathematica, Maple, HSpice, Design Compiler, ......
还有其它物理上的，化学上的，生物上的 ...... 都必然有 Linux 和 UNIX
的版本。当然他们很多不是免费的，不要总是觉得什么都应该免费，它们是经过很多人辛勤劳动的产物，是可靠的程序，他们物有所值。

下面列出我常用的一些 Linux
程序。一个列表里可能有很多，那是为了方便你来选择，我列出了比较信得过的。但其实很多只有第一个是我真正在用的。我不喜欢试用程序。


- Shell: bash。我使用 bash 的 vi 命令行方式。

- 编辑器： VIM, Emacs

- 程序开发： GCC, make, ld, Scheme48, j2sdk, Perl, Python, Tcl/Tk ...

- 论文，幻灯工具：LaTeX, ConTeXt

- 绘图工具：MetaPost。这个语言太强了，以至于我只用它了。你不熟悉的话可
  以用dia 来画一些流程图之类的图片。

- 图像处理：ImageMagick。其中的 import 程序可以屏幕抓图，convert程序可
  以转换图像格式，display可以显示图片和简单编辑(缩放，换质量，转格式，
  简单绘图，简单虑镜)。通常我就这么点需要。如果你要更强大的图像工具可
  以用Gimp, 它几乎和 Photoshop 差不多。

- 自动管理工具：make。我可以用make来自动编译程序，自动编译文档，自动更
  新插图......全自动，而且不会重复劳动。

- 加密程序：GnuPG。我的 PGP 密钥就是它搞出来的，我用了 2048 位加密。

- 打包，压缩程序。什么都有: tar, gzip, bzip2, zip, rar, ...

- 虚拟光驱程序。Linux 不需要虚拟光驱程序，直接 mount 就行了。

- ftp 服务器：proftpd, vsftpd

- WWW 服务器：apache。(我一般没有开)

- ftp 客户程序：lftp

- 自动下载工具：wget

- 虚拟终端：rxvt, xterm, gnome-terminal, mlterm, ...

- X server: XFree86

- 窗口管理器：FVWM。编译加入了 libstroke。

- 中文输入：XSIM。被我修改过以适应 FVWM 的需要。另外推荐你还可以用SCIM。

- email 处理：Mutt + Postfix + fetchmail

- 看 PDF, PS, DJVU 文件：Acrobat Reader, xpdf, GhostScript, gv,djvu工
  具包和 netscape 插件。

- 看CAJ文档。我从来不看CAJ之类的文档，如果找不到PDF或PS，直接去图书馆借最好。

- 看网页：Mozilla, Phoenix, lynx。Mozilla-Xft 的显示效果比 IE好很多。

- 英汉字典：IBM智能词典，星际译王。

- 编辑网页：我用 VIM 直接写HTML。你如果想要图形方式的可以用其它的比如
  screem, BlueFish。

- 登录其它 UNIX, Linux 机器：openSSH, telnet。 openSSH 还可以把其它机
  器的 X 程序通过 ssh 加密的隧道传到我机器上显示。

- 上BBS：rxvt(或任何一种终端) + telnet + chatbot(helloooo机器人的程序)

- QQ, ICQ: 我没有 QQ 或 ICQ。不过你可以用 Gaim, 它同时支持 QQ, ICQ 和
  很多其它的即时通信方式。ICQ 用户也可以用 Licq。

- 放录像：MPlayer, RealPlayer。MPlayer 太好了，直接就可以放 VCD,
  DVD,divx, wma, wmv ... 用 Windows 的同学都很羡慕我，说 Windows要放这
  个需要大堆插件。rm 最好还是用 realplayer 放，它也是免费的。

- 放音乐： xmms(mp3,ogg都可以), mpg321(放mp3), ogg123(放ogg).

- 看 Word 文档。请 Word 用户把文档全部转为 PDF 或 PS 再给我，文档里没
  有特殊的格式就用文本文件，要不我就不看 :P

- 其它程序：还有很多我需要用而你不一定用得着的。比如，Doctor
  Scheme,Scheme48, Scsh, ...这些程序只有 Doctor Scheme有Windows版本。
  还有很多幕后工作但是你一般不察觉的：xinetd, telnetd,sshd, crond,
  atd, lpd, ... 他们都比 Windows 的对应者强的多。
**** 心灵鸡汤

有只黄鼠狼，在养鸡场的山崖顶上立了块碑，上面写着：“摆脱禁锢，不勇敢跳
下去，你怎么知道自己不是一只老鹰？”于是，它每天就在崖底等着吃摔死的鸡。
——这个故事告诉我们，阅读心灵鸡汤时需要智商，大多鸡汤都是黄鼠狼写的。

原来鸡汤是这样熬成的！

* Previsous
** w2
*** 2016/01/16
**** irc                                                             :irc:

[[/home/wally/Wally/Journal/Figure/scrot/30980jYW.png]]

***** what?

- [[http://baike.baidu.com/link?url=jB5JRb4FBbjGCs8fKheTymXOqf6zMaalCSvNR7_lkkrsjRbrgKPKS3a7jLchJcJ2x2OQMt4J4TuYSkzb_kZb2sdoG0dAMnLrVcXd1Nooo7y][百度百科]]

IRC是Internet Relay Chat 的英文缩写，中文一般称为互联网中继聊天。

它是多用户、多频道的讨论系统，许多用户可以在一个频道内就某一话题进行交
谈或私谈，每个用户都有一个不同的昵称。IRC允许任意的因特网用户之间做即
时的交谈。

IRC用户使用特定的用户端聊天软件连接到IRC服务器，通过服务器中继与其他连
接到这一服务器上的用户交流，所以IRC的中文名为“因特网中继聊天”。

***** features

- [[http://www.zhihu.com/question/24851247][知乎：为什么现如今还有人使用 IRC 聊天交流？
]]


- IRC 协议简单，开源实现多，本来就备受开发者青睐；
- 因此，其第三方机器人程序非常众多，开源实现库一抓一大把，任何想做多人同用机器人的开发者，都可以轻易上手，几乎每种语言都有一个实现，不必去望洋兴叹。
- IRC 不用登录，不用注册；但如果你注册了，就可以强制把占用自己唯一ID 的人踢下线。
- IRC 也可以私聊。
- IRC 也有特殊权限。
- IRC 是开源社区会议标准；
- 因此，IRC 在开源社区用得比较多；
- 因此，许多开源世界的技术大牛混在那里。

***** 客户端

- [[http://wiki.ubuntu.org.cn/IRC%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%89%E5%93%AA%E4%BA%9B][Ubuntu Forum: IRC 客户端有哪些]]

****** 网络浏览器

Firefox插件

-  [[https://addons.mozilla.org/en-US/firefox/addon/16][火狐插件ChatZilla]]

****** 网页

-  [[http://webchat.freenode.net/]] Freenode封了Mibbit后自己搞定HTML版本
-  [[https://irc.gitter.im/]] Beta，兼容lynx
-  [[https://kiwiirc.com/client]] 神抛弃老旧Opera后的选择

****** QT

-  [[/Quassel][Quassel]] 配合KDE功能强悍
-  [[https://konversation.kde.org/][Konversation]] KDE的默认客户端
-  [[http://www.kvirc.net/][KVIrc]]

****** GTK

-  [[/IRC@Pidgin][Pidgin]]
-  [[/Xchat][xchat]]

****** CLI

-  [[http://irssi.org/][irssi]] CLI界面IRC工具
-  [[http://www.gnu.org/software/emacs/][ERC]] 神的工具，神的ERC *Emacs IRC*

**** ERC                                                         :erc:irc:

- [[~/Wally/Reference/Manual/ERCManual.pdf][ERCManual.pdf]]
- [[http://www.emacswiki.org/emacs/ERC][EmacsWiki:ERC]]


ERC is part of the GNU project. It is included with recent versions of
GNU Emacs.

ERC is included in released versions of GNU Emacs since v22.3.

使用： M-x erc

**** blender

https://zh.wikibooks.org/zh-cn/Blender_3D%EF%B8%B0%E5%BE%9E%E5%85%A5%E9%96%80%E5%88%B0%E7%B2%BE%E9%80%9A

http://wiki.blender.org/

**** matlab 启动错误

#+BEGIN_EXAMPLE
  Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar
#+END_EXAMPLE

[[http://askubuntu.com/questions/615644/after-upgrading-ubuntu-14-10-to-15-04-i-am-no-longer-able-to-open-matlab-2013a/617059#617059][Ubuntu fomula]]

This package is responsible for application menu support for Java
swing applications, and seems to be the cause for the segfault.

#+BEGIN_EXAMPLE
sudo apt-get remove jayatana
#+END_EXAMPLE

没有解决问题。

[[http://www.mathworks.com/matlabcentral/answers/50971-matlab-r2012b-java-exception-error-starting-desktop][Mathworks]]

以超级用户身份执行 matlab, 解决问题, 不明所以。

#+BEGIN_EXAMPLE
Same thing happens to me on a macbook. Same exception, exception disappears when starting matlab using sudo.
#+END_EXAMPLE

Most likely you don't have write permissions on your preferences
directory. You can determine the location of the MATLAB preferences
folder by running the PREFDIR command at the MATLAB prompt.

If for some reason you're unable to fix the permissions, you can try
changing the prefs directory location:
http://www.mathworks.com/support/solutions/en/data/1-37KDWN/

In Matlab.
#+BEGIN_EXAMPLE
>> prefdir

ans =

/home/wally/.matlab/R2014a
#+END_EXAMPLE

#+BEGIN_EXAMPLE
   ls -l .matlab/R2014a/
  总用量 1536
  -rw-r--r-- 1 root root     12  1月 15 10:58 cwdhistory.m
  -rw-r--r-- 1 root root    512  1月 15 11:04 History.xml
  -rw-r--r-- 1 root root   6070  1月 15 11:03 MATLABDesktop.xml
  -rw-r--r-- 1 root root   6092  1月 15 10:58 MATLABDesktop.xml.prev
  -rw-r--r-- 1 root root    429  1月 15 10:57 matlab.prf
  -rw-r--r-- 1 root root   8864  1月 15 11:02 matlab.settings
  -rw-r--r-- 1 root root    201  1月 10 14:03 shortcuts_2.xml
  -rw-r--r-- 1 root root 553920  1月 10 14:03 toolbox_cache-8.3.0-2211579006-glnxa64.xml
  -rw-r--r-- 1 root root 970053  1月 15 10:58 toolbox_cache-8.3.0-903067591-glnxa64.xml
#+END_EXAMPLE
所有者为 root 用户。。。


问题找到了。但是不想修改 predir ，因为麻烦。折衷使用超级用户权限运行
matlab

Note: 在终端使用 C-c 结束 Matlab，反应慢，在 GUI 上点击关闭按钮。

**** mark-ring list ?

因为经常需要转换任务，所以可能会忘记之前的任务。

org-mark-ring-push

#+BEGIN_EXAMPLE
org-mark-ring-push is an interactive Lisp function in `org.el'.

It is bound to C-c %, C-c 4.

(org-mark-ring-push &optional POS BUFFER)

Put the current position or POS into the mark ring and rotate it.
#+END_EXAMPLE

org-mark-ring-goto

#+BEGIN_EXAMPLE
org-mark-ring-goto is an interactive Lisp function in `org.el'.

It is bound to C-c 5.

(org-mark-ring-goto &optional N)

Jump to the previous position in the mark ring.
With prefix arg N, jump back that many stored positions.  When
called several times in succession, walk through the entire ring.
Org-mode commands jumping to a different position in the current file,
or to another Org-mode file, automatically push the old position
onto the ring.
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-<f1>") 'org-mark-ring-push)
  (global-set-key (kbd "C-<f2>") 'org-mark-ring-goto)
#+END_SRC

**** wine 百度云

不行，别折腾

**** sdl                                                             :sdl:

***** sdl

[[https://www.libsdl.org/][Homepage]]

Simple DirectMedia Layer is a cross-platform development library
designed to provide low level access to audio, keyboard, mouse,
joystick, and graphics hardware via OpenGL and Direct3D.

****** install                                                 :install:

#+BEGIN_EXAMPLE
 $ sudo apt-get install  libsdl2-2.0-0
#+END_EXAMPLE

***** sdl_image                                               :sdl_image:

- [[http://www.libsdl.org/projects/SDL_image/][Homepage]]
- [[http://jcatki.no-ip.org:8080/SDL_image/][Document]]


SDL_image is an *image loading library* that is used with the SDL
library, and almost as portable. It allows a programmer to use
multiple image formats without having to code all the loading and
conversion algorithms themselves.

****** install                                                 :install:

#+BEGIN_EXAMPLE
 $ sudo apt-get install libsdl-image1.2
#+END_EXAMPLE

**** 学习时不要听 Eason 的歌

听 Eason 的歌太容易入神。

听一些舒缓的轻音乐。

*** 2016/01/14
**** supply

***** connector

输入： KF128-2
输出：5557 https://item.taobao.com/item.htm?id=41139630227&ali_refid=a3_430582_1006:1104098595:N:%E6%8F%92%E6%8B%94%E5%BC%8F%E6%8E%A5%E7%BA%BF%E7%AB%AF%E5%AD%90:cd6bd631faf7c8d74c8748dd98c47073&ali_trackid=1_cd6bd631faf7c8d74c8748dd98c47073&spm=a230r.1.14.3.Ozxn0o#detail

***** protector

电容：100uF/A

[[/home/wally/Wally/Journal/Figure/scrot/3098085D.png]]

二极管：


开关电源？

***** ref

[[https://app.yinxiang.com/shard/s52/nl/11551545/273c7e8c-dacd-4f22-a004-bb30aec5d710/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D152408a07ab%3AS%3Df5af2039594c32603700a7a7b6d115dc][直插式电阻电容封装与尺寸图解]]

[[https://app.yinxiang.com/shard/s52/nl/11551545/96b290e4-eb4d-4148-b51a-72fa4469c77e/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D152408b2f28%3AS%3D9a57fbc29200b7dff1aed88c48aa5ab2][Protel中Cap,Cap2，Cap Pol的区别]]

**** irc

[[/home/wally/Wally/Journal/Figure/scrot/30980jYW.png]]

*** 2016/01/13
**** cedet

使用 git 版的 cedet, 在 load 配置文件时与内置 cedet 矛盾

#+BEGIN_EXAMPLE
error:Cannot unload builtin CEDET since it is already loaded
#+END_EXAMPLE

解决： 将 cedet 的加载配置放在前面

*每次折腾 Emacs C++ IDE 都好烦人！！！*

**** emacs clang

#+BEGIN_SRC emacs-lisp
  (setq company-backends (delete 'company-semantic company-backends))
  (define-key c-mode-map (kbd "C-<tab>") 'company-complete)
  (define-key c++-mode-map (kbd "C-<tab>" 'company-complete)
#+END_SRC

**** wordpress

***** reference

- [[https://cn.wordpress.org/][Homepage]]
- [[https://github.com/wordpress/wordpress][Github]]
- [[https://github.com/punchagan/org2blog][org2blog]]

***** [[http://www.trinea.cn/other/choice-between-wordpress-and-github-page/][WordPress VS GitHub Page]]

****** WordPress和github page的选择和搭建

搭建博客时对wordpress和github page进行了简单的对比，最终选择了wp。

这里就简单对比下wp和gp的优缺点及搭建过程简介。主要比较方面包括*搭建复
杂度、对域名空间要求、写博客的便捷程度、开放性（主题、工具插件）、访问
速度、SEO优化、迁移成本

****** ps: 下面介绍中github page使用octopress博客框架

首先如果希望能以独立域名访问，域名的注册是必不可少的，可选择[[http://www.net.cn/domain/][万网]] 或 [[http://www.west263.cn/services/domain/][西部
数码]]等

*a. 搭建复杂度*

wp近乎傻瓜式；github较复杂，需要安装不少软件，而且还可能有莫名的错误，
需随时google解决结果：wp胜出，当然喜欢折腾或是对ruby相当熟悉的话可能差
别不是很明显。


*b. 对域名空间要求*

wp需要自己购买虚拟主机，低配大约在100-200RMB/Y，主机需要有lamp的环境运
行wp，不过现在的linux虚拟主机一般都提供此环境；

github page的一大优点就是不需要虚拟主机，它是可以发布到githubpage上的。

结果：github page免费优势明显

*c. 写博客的便捷程度*

wp需要打开后台，在后台撰写文章，即时写当然是需要联网的。wp的强大插件使
得博客文字样式可以很丰富
githubpage支持本地编写、本地预览，满意后再发布，并且支持markdown语法所
以对于不少程序员可能会比较方便。文本中直接编写极客的感觉*\_*

结果：对于不同人群各有优劣吧


*d. 开放性（主题、工具插件）*

wp的主题和插件是无比丰富的，这是选择wp的一大原因之一，不过插件多同时也
带来了另一个问题就是质量良莠不齐，选择相当麻烦费事，org~，之后会分享自
己装的觉得还不错的插件。

octopress相当来说发展没多久，插件方面没怎么调查，不过主题是标准的程序
员黑，自己改css相当费事

结果：wp胜出

*e、访问速度*

wp的访问速度与虚拟空间地址有关，不过我挂在朋友的购买的国外虚拟空间上速
度感觉也还不错

github的访问速度感觉与其他国外网站比还是较慢的，这几天刚好因为抢票插件
被封

结果：看具体虚拟空间的选择


*f、SEO优化*

wp不少插件提供seo优化功能，但也需要发博客时自己填写不少信息比较麻烦

githubpage搜索引擎优化就不需要自己做了，并且github在google上权重肯定相
当高，所以优势明显

结果：github page胜出

*g、迁移成本*

wp的迁移需要将网站目录迁移、数据库备份后再导入即可octopress的迁移也还
好，就算不利用githubpage的话，自己有一套ruby和nginx的环境的话也是可以
很方便重新部署的

结果：旗鼓相当

我比较在乎开放性（主题、工具插件）、写博客的便捷程度、访问速度、迁移成
本四点。尤其对第一点比较看重，所以选择了wp，不过比较插件真是差点被折腾
死||\_||，在wordpress和github

page的搭建中有自己安装的比较好的插件.

*PS：搭建过程*

wordpress搭建：下载 [[http://cn.wordpress.org/][最新wordpress包]] ，解压上传。直接访问index.php，按
照提示填写数据库信息即可（可以自己将个数据库）。

githubpage博客搭建参考[[http://www.hopes4.me/post/2012-02-29-introduce-octopress-on-github][在github上用octopress搭建博客]]， 关于ruby的安装可
参考 [[http://blog.sina.com.cn/s/blog_6b59aaa701017sff.html][Ruby在windows下的安装]]。

**** gtags

http://tuhdo.github.io/c-ide.html#orgheadline37

GNU Global has an environment variable named *GTAGSLIBPATH*. This
variable holds GTAGS database of _external libraries_ that your project
depends on but not inside your project. For example, your project may
rely on *system headers* such as stdio.h, stdlib.h… but these headers
are internal to your project.

However, remember that you can *only jump to tag definitions* of
external dependencies, and nothing else (such as files or
references).

But, again, once you are inside the external
library, you can start jumping around sicne it becomes your current
project.

#+BEGIN_EXAMPLE
export GTAGSLIBPATH=$HOME/.gtags/
#+END_EXAMPLE

**** xsel                                                           :xsel:

Manipulate the X selection

sudo apt-get install xsel

***** option

+ -b, --clipboard       Operate on the CLIPBOARD selection
+ -o, --output          Write the selection to standard output
+ -i, --input           Read standard input into the selection

***** usage

1. 复制内容到剪贴板中

   #+BEGIN_EXAMPLE
   cat file | xsel -i -b
   #+END_EXAMPLE

2. 取出剪贴板内容

   #+BEGIN_EXAMPLE
   xsel -o -b
   #+END_EXAMPLE

**** /usr/local 空间不足

/usr/local 挂载的分区大小为20G，完全不够用

移动 /usr/local/MATLAB 并建立软链接后，MATLAB 启动不了

以同样的方式处理 texlive 暂时没有问题

*** 2016/01/12
**** latex2html                                         :latex:latex2html:

***** reference

- https://www.ctan.org/pkg/latex2html?lang=en
- https://www.ctan.org/tex-archive/support/latex2html
- [[~/Wally/Reference/Manual/LaTeX2HtmlManual.pdf][LaTeX2HtmlManual.pdf]]

***** install                                                   :install:

#+BEGIN_EXAMPLE
$ ./configure & make & sudo make install
#+END_EXAMPLE

**** sdcv history                                                   :sdcv:

*$(HOME)/.sdcv_history*

**** fcitx 启动不了

#+BEGIN_EXAMPLE
  $ fcitx &


  (INFO-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/addon.c:151) 加载附加组件配置文件: fcitx-vk.conf
  (WARN-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/addon.c:298) 禁用插件 fcitx-ipc，依赖 fcitx-dbus 无法满足。
  (ERROR-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/frontend.c:565) 无可用前端
  (ERROR-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/instance.c:437) Exiting.
#+END_EXAMPLE

- 原因： 配置错误
- 解决：删除配置文件

  #+BEGIN_EXAMPLE
     mv ~/.config/fcitx ~/.config/fcitx.bak
  #+END_EXAMPLE

- 暴力解决(不推荐)

  #+BEGIN_EXAMPLE
    $ sudo dpkg -P fcitc*
    $ sudo apt-get install fcitx
  #+END_EXAMPLE

**** fcitx 切换输入法与 xmodmap 冲突

使用 gnome-tweak 解决

**** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

**** make -jn

多线程编译

用于多cpu的系统编译，n一般是cpu个数的2倍。

*** 2016/01/11
**** bash completion

#+BEGIN_EXAMPLE
For auto-completion, do not forget to install 'ct-ng.comp' into
your bash completion directory (usually /etc/bash_completion.d)
#+END_EXAMPLE

*/etc/bash_completion.d*

**** gazebo & ros jade

- [[http://answers.ros.org/question/217970/ros-jade-and-gazebo-50-migration-problem/][Q&A: ros jade and gazebo 5.0 migration problem]]

#+BEGIN_EXAMPLE
/opt/ros/jade/lib/gazebo_ros/gzclient: 17: .: Can't open /usr/share/gazebo//setup.sh
[gazebo_gui-3] process has died [pid 2459, exit code 2, cmd /opt/ros/jade/lib/gazebo_ros/gzclient __name:=gazebo_gui __log:=/home/wally/.ros/log/4fb3d678-b80e-11e5-9dba-002186ef9d91/gazebo_gui-3.log].
log file: /home/wally/.ros/log/4fb3d678-b80e-11e5-9dba-002186ef9d91/gazebo_gui-3*.log
#+END_EXAMPLE

*installing the gazebo5 package seems to have solved the
problem*.

**** softwares
***** octave
   http://mirrors.ustc.edu.cn/gnu/octave/
   https://coderwall.com/p/wo***kw/ubuntu-installing-octave-fortran-***error

***** briss

***** latex2html
https://www.ctan.org/pkg/latex2html?lang=en

***** xmradio
vlc
sourcecode

***** foxitreader

**** Foxit Reader                                            :foxitreader:

***** Linux 版安装

1. 官网下载：https://www.foxitsoftware.com/products/pdf-reader/
2. .run 可执行文件，安装至 /opt 下
3. 界面较 Windows 版，简化过多，功能不全，体验不好

*还是使用 wine foxitreader 习惯*

**** python install                                              :install:

- https://www.python.org/downloads/

version 3.5


READEM

#+BEGIN_EXAMPLE
  On Unix, Linux, BSD, OSX, and Cygwin:

      ./configure
      make
      make test
      sudo make install
#+END_EXAMPLE

***** 修改软链

#+BEGIN_EXAMPLE
  wally@ Python-3.5.1 $ python  --version
  Python 2.7.9
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/py
  pydoc3             python3            python3.5-config   python3.5m-config  pyvenv
  pydoc3.5           python3.5          python3.5m         python3-config     pyvenv-3.5
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/py
  pydoc3             python3            python3.5-config   python3.5m-config  pyvenv
  pydoc3.5           python3.5          python3.5m         python3-config     pyvenv-3.5
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/python /usr/bin/python
  [sudo] password for wally:
  ln: 无法创建符号链接"/usr/bin/python": 文件已存在
  wally@ Python-3.5.1 $ ls -l /usr/bin/python
  lrwxrwxrwx 1 root root 9  1月  9 16:07 /usr/bin/python -> python2.7
  wally@ Python-3.5.1 $ sudo rm /usr/bin/python
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/python3 /usr/bin/python
  wally@ Python-3.5.1 $ python --version
  Python 3.5.1
#+END_EXAMPLE

**** [[http://www.cnblogs.com/yejianfei/p/3351626.html][Linux的压缩与解压]]

***** zip格式                                                       :zip:

#+BEGIN_EXAMPLE
    压缩： zip -r [目标文件名].zip [原文件/目录名]
    解压： unzip [原文件名].zip
#+END_EXAMPLE

注：-r参数代表递归

***** tar格式（该格式仅仅打包，不压缩）                             :tar:

#+BEGIN_EXAMPLE
    打包：tar -cvf [目标文件名].tar [原文件名/目录名]
    解包：tar -xvf [原文件名].tar
#+END_EXAMPLE

注：c参数代表create（创建），x参数代表extract（解包），v参数代表
verbose（详细信息），f参数代表filename（文件名），所以f后必须接文件名。

***** tar.gz格式                                                     :gz:

方式一：利用前面已经打包好的tar文件，直接用压缩命令。

#+BEGIN_EXAMPLE
    压缩：gzip [原文件名].tar
    解压：gunzip [原文件名].tar.gz
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -zcvf [目标文件名].tar.gz [原文件名/目录名]
    解压并解包： tar -zxvf [原文件名].tar.gz
#+END_EXAMPLE

注：z代表用gzip算法来压缩/解压。

***** tar.bz2格式                                                   :bz2:

方式一：利用已经打包好的tar文件，直接执行压缩命令：

#+BEGIN_EXAMPLE
    压缩：bzip2 [原文件名].tar
    解压：bunzip2 [原文件名].tar.bz2
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -jcvf [目标文件名].tar.bz2 [原文件名/目录名]
    解压并解包： tar -jxvf [原文件名].tar.bz2
#+END_EXAMPLE

注：小写j代表用bzip2算法来压缩/解压。

***** tar.xz格式                                                     :xz:

方式一：利用已经打包好的tar文件，直接用压缩命令：

#+BEGIN_EXAMPLE
    压缩：xz [原文件名].tar
    解压：unxz [原文件名].tar.xz
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -Jcvf [目标文件名].tar.xz [原文件名/目录名]
    解压并解包： tar -Jxvf [原文件名].tar.xz
#+END_EXAMPLE

注：大写J代表用xz算法来压缩/解压。

***** tar.Z格式（已过时）

方式一：利用已经打包好的tar文件，直接用压缩命令：

#+BEGIN_EXAMPLE
    压缩：compress [原文件名].tar
    解压：uncompress [原文件名].tar.Z
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -Zcvf [目标文件名].tar.Z [原文件名/目录名]
    解压并解包： tar -Zxvf [原文件名].tar.Z
#+END_EXAMPLE

注：大写Z代表用ncompress算法来压缩/解压。另，ncompress是早期Unix系统的压缩格式，但由于ncompress的压缩率太低，现已过时。

***** jar格式                                                       :jar:

#+BEGIN_EXAMPLE
    压缩：jar -cvf [目标文件名].jar [原文件名/目录名]
    解压：jar -xvf [原文件名].jar
#+END_EXAMPLE

注：如果是打包的是Java类库，并且该类库中存在主类，那么需要写一个META-INF/MANIFEST.MF配置文件，内容如下：

#+BEGIN_EXAMPLE
    Manifest-Version: 1.0
    Created-By: 1.6.0_27 (Sun Microsystems Inc.)
    Main-class: the_name_of_the_main_class_should_be_put_here
#+END_EXAMPLE

然后用如下命令打包：

#+BEGIN_EXAMPLE
    jar -cvfm [目标文件名].jar META-INF/MANIFEST.MF [原文件名/目录名]
#+END_EXAMPLE

这样以后就能用“java -jar [文件名].jar”命令直接运行主类中的public static
void main方法了。

***** 7z格式                                                         :7z:

#+BEGIN_EXAMPLE
    压缩：7z a [目标文件名].7z [原文件名/目录名]
    解压：7z x [原文件名].7z
#+END_EXAMPLE

注：这个7z解压命令支持rar格式，即：

#+BEGIN_EXAMPLE
    7z x [原文件名].rar
#+END_EXAMPLE

**** freemind                                           :freemind:mindmap:

***** [[http://www.douban.com/group/topic/19280450/][思维导图软件]]

思维导图，又叫心智图。它的创始人是”大脑先生”托尼•巴赞（Tony Buzan）。

思维导图是一种将放射性思考具体化的方法。我们知道放射性思考是人类大脑的
自然思考方式，每一种进入大脑的信息，不论是感觉、记忆或是想法——包括文字、
数字、符码、食物、香气、线条、颜色、意象、节奏、音符等，都可以成为一个
思考中心，并由此中心向外发散出成千上万的关节点，每一个关节点代表与中心
主题的一个连结，而每一个连结又可以成为另一个中心主题，再向外发散出成千
上万的关节点，而这些关节的连结可以视为您的记忆，也就是您的个人数据库。

几款高级思维导图软件

1. PersonalBrain http://personalbrain.evget.com/

   目前比较流行的思维导图软件，使用简单方便，有专业版和普通版区别，专
   业版收费，界面很漂亮，蓝色的皮肤有点像宇宙的感觉，每个元素有上级、
   下级、同级3个节点，提供注释、备注等功能。

2. MindMapper http://www.mindmapper.com/

   它严格地遵守托尼巴贡的制图法则，关键字都是放在延伸手臂上。能够提供
   xml的输出 能与微软办公软件沟通，还有最妙的时间线进度。 快捷键是最好
   用的，无需点鼠标就可以建立新节点。

3. ThinkMap SDK http://www.thinkmap.com/

   软件介面非产酷，强大的数据库功能，3d树形网络,有很好的API开发接口。
   就是价格太贵。

4. FreeMind

   FreeMind是一款跨平台的、基于GPL协议的自由软件，用Java编写，是一个用
   来绘制思维导图的软件。其产生的文件格式后缀为.mm 。可用来做笔记，脑
   图记录，脑力激汤等。　

5. Xmind http://www.xmind.net/

   XMind是一款易用性很强的软件，通过XMind可以随时开展头脑风暴，帮助人
   们快速理清思路。XMind 绘制的思维导图、鱼骨图、二维图、树形图、逻辑
   图、组织结构图等以结构化的方式来展示具 LOGO

6. mindmanager http://www.evget.com/zh-CN/product/1069/feature.aspx

   mindmanager由美国Mindjet公司开发，界面可视化，有着直观、友好的用户
   界面和丰富的功能，　可使使用者有序地组织思维、资源和项目进程，同时
   它是高效的项目管理软件，能很好提高项目组的工作效率和小组成员之间的
   协作性。它作为一个组织资源和管理项目的方法，可从思维导图的核心分枝
   派生出各种关联的想法和信息。

***** [[http://xbeta.info/xmind-freemind.htm][XMind vs FreeMind]] :xmind:

思维导图类软件中，最有影响力的开源免费软件是 FreeMind 和XMind。

FreeMind历史悠久，当属经典；XMind作为后起之秀，大有赶超之势。同作为免费、开源的思维导图解决方案，应如何选择/结合两款软件？

本文的分析基于Windows平台下的 FreeMind 0.90 RC3 和 XMind 3.03，结合笔
者的使用经验，也包括XMind开发者所提供的信息。基本结论是： *总体看，
XMind已超越 FreeMind；个别方面，FreeMind 值得 XMind 学习*

****** XMind 与 FreeMind 的相同/相通之处

- 都是免费、开源、基于 Java。
- 都满足绘制思维导图的基本甚至高级功能。
- 相通之处：XMind 可以导入/导出 FreeMind 格式；反之不能。

****** XMind 与 FreeMind 比较

1. XMind: 更丰富的结构且支持混用

   FreeMind：只支持一种逻辑图（水平）结构。

   XMind：在逻辑图之外，还支持组织结构图（竖直）、树状图（水平+竖直）、
   思维导图（辐射）、鱼骨图、二维图（表格）。不仅如此，还能在一个文档
   中组合使用多种表达形式。实用举例：整个项目管理用逻辑图，人员安排部
   分用组织结构图，风险及应对采用鱼骨图，进度部分用二维图。

2. XMind: 支持自由节点因而支持多图

   FreeMind：只能有一棵树，即：根节点唯一，其他节点必须直接或间接放在
   根节点下。

   XMind：允许在主树之外创建自由节点（应用举例：把“文档作者/创建日期”作
   为自由节点，补充思维导图信息）；由于自由节点也是可以增加子节点的，
   所以可产生第二棵、第N棵新树。

3. FreeMind: 根节点仍可以插入父节点

   需求：在绘完的导图上再加一层。比如，最初建立了“唐诗”导图，现在要
   扩展到“唐宋文学”，即“唐诗”根节点要降至二级节点。

   XMind：顶级的自由节点之间是可以互为子节点的，但原来的根节点（XMind
   称为中心主题）则不能拖到其他节点上。满足上述需求，就要新建文档，以
   “唐宋文学”为根节点，然后导入或粘贴原有内容。\\

    FreeMind：支持根节点上插入“父节点”。

   建议：XMind的“根节点”比FreeMind减少了一份特殊性，即允许其他节点独
   立于此；但仍包留了另一份特殊性，不能成为其他节点的子节点。从使用角
   度，建议取消此限制，即：任何节点本身是一样的，彼此之间为父子关
   系。------或许有技术限制，但节点/层级的平等灵活是XML的精神。

4. XMind 支持附件, FreeMind 全为链接

   FreeMind：可以有超链接到外部文档和图片，也可以显示外部的图片。但这
   些资源都只是.mm文件中的链接url，并非素材本身。即，.mm是纯文本的xml，
   包括 FreeMind的图标也是以ID数字标示。

   XMind：支持上述链接方式，也支持（默认）把该文档及图片引入XMind文件
   作为附件，形成完整的资料包。.xmind 格式与OOo文档一样，实质是 xml＋
   素材的zip包。展开后的内容举例如下：

   #+BEGIN_EXAMPLE
     attachments\
     attachments\4hm2upmpscpth85latqpd49biq.png
     attachments\179ekuhhgn9g866cg5a26b78fh.pdf
     META-INF\
     META-INF\manifest.xml
     Thumbnails\
     Thumbnails\thumbnail.jpg
     content.xml
     meta.xml
     styles.xml
   #+END_EXAMPLE

5. 发布思维导图方面，XMind 要向 FreeMind 学习

   1) 能导出哪些格式

      - XMind 免费版：FreeMind、html、图片（bmp/jpg/gif/png）、纯文本
      - XMind Pro：以上 + MindManager、pdf（普通/思维图）、ppt/doc/rtf
      - FreeMind：各种html、flash、pdf、OpenOffice文档、png/jpg、
        svg/twiki等格式

   2) 我关注的导出格式、比较、说明

      - 静态图片：思维导“图”当然要能导出静态图片，这是最低需求。实在
        不能导出，截屏亦可。只是内容太多超过一屏时，截屏就不太方便了。
        图片可用于网页发布，也可用于其他文档（pdf/office）。格式方面，
        强烈不推荐bmp/jpg，推荐png/gif格式，[[http://blog.sina.com.cn/s/blog_46dac66f010004ox.html][原因见此]]。这方面，XMind与
        FreeMind持平。

      - pdf文档发布：相比图片的优点是，放大后文字仍然清晰。如果内容太
        多，导出一页的pdf发给别人，无论用于打印还是放大查看，都比图片
        的效果好很多。对比结果：XMindPro（未用过）＞ FreeMind（够用）
        ＞ XMind（无）-- 广义html导出：FreeMind 遥遥领先，详细见下。

      - 广义html导出的详细比较

        结论：广义html/flash式导出，目的是在线发布后，仍保留折叠/展开
        动态效果，及链接功能。这方面，FreeMind遥遥领先，远胜 XMind。

        XMind：导出的html包括图片和节点文字。但图与文字无链接；文字层
        级也不能折叠；图片默认为jpg，强烈建议换为png。

        FreeMind：可采用不同技术进行导出，每种导出效果都非常好。
        FreeMind导出html的格式有：

        - html：纯文字方式，节点保留原有格式，层级关系可折叠展开，url链接有效。
        - xhtml（javascript）：效果同上，只是改用js实现。
        - xhtml（可点击map图片）：除了上述文字内容外，还附有图片，并且点击图片的节点可跳转到对应的文字。
        - java applet：功能保留最多的方式。在浏览器中的使用效果近乎在 FreeMind中打开 .mm文件。
        - flash：点击可折叠/展开，链接url有显示但无法点击。

6. FreeMind节点支持html代码

   FreeMind：节点支持html代码，实现文字格式化、换行、分段、图像链接、
   表格。（此外，还支持LaTex代码）

    XMind：不能对部分文字分别设定格式，可以shift+enter换行。

7. XMind 具有更好的可持续性

   FreeMind作为经典开源软件，虽在持续更新中，但新功能进展并不多。而同
   作为开源软件的XMind，不仅因为后发优势拥有了更多功能。并且，作为有商
   业公司支持的开源产品，新功能的开发会更加活跃------这并非迷信商业，
   而是实际情况，包括两个开发团队的成员也有此认识。

    另外，XMind还提供了更强大的Pro版，可以满足个人和企业的更高需求，并
   能提供可靠的技术支持。

8. XMind 更美观，FreeMind 更快速省资源

   无论用户界面还是思维导图文件，XMind 都更加美观。而 FreeMind更加简约，
   占用资源更少，启动和运行速度更快。各取所需即可。

9. 其他差异

   FreeMind 可以导入目录结构，相当于变成了资源管理器；XMind不能。

   在节点输入较多文字的过程中，XMind的输入框会阶梯式不断加大，而
   FreeMind会保持同样大小（只显示最右侧部分）。

   XMind的节点可以添加标签，以进行过滤筛选；而FreeMind可以根据节点文字
   进行过滤显示。

    注意：XMind导入.mm时，无法识别包含html代码的节点。

****** 结论：软件选择建议

大多数人普通用户：XMind。理由：支持逻辑图、二维图等多种表达形式并可混
用，更加美观、支持附件。

*Geek或偏执者：FreeMind。理由：更节约资源，界面更简朴。*

自主网络发布：FreeMind。理由：强大灵活的html导出功能。

不执着于软件，仅执着于最优效果：主用 XMind 辅用FreeMind。即仅在自主网
络发布时另存为FreeMind格式，再用FreeMind导出为html。

***** freemind

+ [[http://freemind.sourceforge.net/wiki/index.php/Main_Page][Homepage]]

****** install                                                 :install:

新得立 version 0.9

beta: 1.1

http://freemind.sourceforge.net/wiki/index.php/Download

http://www.getdeb.net/app/Freemind -> 软件中心

不支持的软件源，安装过程中需要 “修复”。。。

还是源码 -> ant (java 版 make)

#+BEGIN_EXAMPLE
java.io.IOException: Cannot run program "/home/wally/Download/freemind/check_for_duplicate_resources.sh": error=13, 权限不够
#+END_EXAMPLE

sudo 和切换为 root 用户，也不行？

还是 apt-get 方式

****** usage

用起来体验不错。
**** org export to freemind                             :freemind:mindmap:

#+BEGIN_EXAMPLE
- State "DONE"       from "ABORT"      [2016-01-11 一 10:20] \\
  重新安装系统后编译Emacs，解决问题
- State "ABORT"      from "TODO"       [2015-11-23 一 19:26] \\
  不需要的东西不要瞎折腾, 放弃也是一种智慧
#+END_EXAMPLE


#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "~/.emacs.d/src/org-mode/contrib/lisp"))
  (require 'ox-freemind)
  (setq org-freemind-pretty-output t)
  (setq org-freemind-section-format 'note)
#+END_SRC

(void-function libxml-parse-xml-region) 暂时解决不了。。。

-> 重新编译安装Emacs??? 不要鲁莽！！！

*org-freemind-export-to-freemind*

**** desktop重命名                                               :desktop:

- http://blog.csdn.net/manmaximus/article/details/3567919

- why: 重命名桌面文件夹，桌面所在文件夹是“桌面”，习惯了用终端进行操
  作，但是在终端打中文比较麻烦

- 配置文件: *~/.config/user-dirs.dirs*

  #+BEGIN_EXAMPLE
    # This file is written by xdg-user-dirs-update
    # If you want to change or add directories, just edit the line you're
    # interested in. All local changes will be retained on the next run
    # Format is XDG_xxx_DIR="$HOME/yyy", where yyy is a shell-escaped
    # homedir-relative path, or XDG_xxx_DIR="/yyy", where /yyy is an
    # absolute path. No other format is supported.
    #
    XDG_DESKTOP_DIR="$HOME/Desktop"
    XDG_DOWNLOAD_DIR="$HOME/Download"
    XDG_TEMPLATES_DIR="$HOME/模板"
    XDG_PUBLICSHARE_DIR="$HOME/Share"
    XDG_DOCUMENTS_DIR="$HOME/Document"
    XDG_MUSIC_DIR="$HOME/Audio"
    XDG_PICTURES_DIR="$HOME/Picture"
    XDG_VIDEOS_DIR="$HOME/Video"
  #+END_EXAMPLE

**** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

**** emacs matlab                                                 :matlab:

***** matlab-emacs

中止的项目

#+BEGIN_SRC emacs-lisp
  (autoload 'matlab-mode "matlab" "Enter MATLAB mode." t)
  (setq auto-mode-alist (cons '("\\.m\\'" . matlab-mode) auto-mode-alist))
  (autoload 'matlab-shell "matlab" "Interactive MATLAB mode." t)
#+END_SRC

***** matlab-mode

https://github.com/pronobis/matlab-mode

****** configure

+ [[http://www.emacswiki.org/emacs/MatlabMode][EmacsWiki]]

#+BEGIN_SRC emacs-lisp
  (autoload 'matlab-mode "matlab" "Matlab Editing Mode" t)
  (add-to-list
   'auto-mode-alist
   '("\\.m$" . matlab-mode))
  (setq matlab-indent-function t)
  (setq matlab-shell-command "matlab")
#+END_SRC

****** usage

- *matlab shell* 后台运行 matlab (Note: 不会启动 GUI，但会短暂地弹出一
  个窗口)
- 只能运行，不支持调试，调试还是使用 Matlab GUI

***** matlab IDE 支持 Emacs 基本的编辑快捷键，所以可能不需要集成在 Emacs 中

** w1
*** 2016/01/10
**** index

关于建立索引的想法

1. 索引类似书后面的 index
2. 按字母顺序排列
3. 不使用标题，因为不需要继承标签
4. 使用无序列表
5. 可以包含简要的笔记内容和链接等

**** 手机 VPN

不用下载客户端，直接使用配置中的VPN

**** 交换 CapsLock 和 Ctrl 键
***** reference

- http://tuhdo.github.io/emacs-tutor.html
- http://www.kodiva.com/post/swapping-caps-lock-and-control-keys
-
  http://askubuntu.com/questions/412576/swap-caps-lock-and-ctrl-in-ubuntu-13-10/412622#412622

***** windows: 通过修改注册表

In our opinion this is the best way to swap the control and caps lock
keys in Windows because you don't have to rely on any external program
and the registry edit works 100% perfectly (for the paranoid).

Why should one bother changing the caps lock and control keys, what's
wrong with the control key where it is? After extensive testing, our
conclusion is that - if you use the control key a lot (like in Emacs or
Vim), then you should definitely swap the control and caps lock keys as
it's extremely ergo-dynamic to have the control key in the home row.

1. Click Start -> Run

2. Type: regedit, and click OK

3. Go to: HKEY_LOCAL_MACHINE -> System -> CurrentControlSet -> Control
   -> KeyBoard Layout

   Note: *KeyBoard Layout*, and not KeyBoard Layouts

4. Right-click: Keyboard Layout, and select New -> Binary value

5. Rename: New Value #1 -> Scancode Map

6. Right click: Scancode Map -> Modify
   #+BEGIN_EXAMPLE
     0000  00 00 00 00 00 00 00 00
     0008  03 00 00 00 1d 00 3a 00
     0010  3a 00 1d 00 00 00 00 00
     0018
   #+END_EXAMPLE

7. Close regedit and restart your computer

***** Linux

1. Put this in your shell init file (.bashrc, .zshrc…):

   #+BEGIN_EXAMPLE
   /usr/bin/setxkbmap -option "ctrl:swapcaps"
   #+END_EXAMPLE

2. xmodmap

3. gnome-tweak-tool(Ubuntu)

   First, install gnome-tweak-tool using sudo apt-get install
   gnome-tweak-tool from a console.

   Then, run it using the command gnome-tweak-tool, or by typing
   "Tweak Tool" into the dash at the top-left.

   From this tool, choose the "Typing" tab on the left. Then, from the
   dropdown next to "Ctrl key position" on the right, choose "Swap
   Ctrl and Caps Lock". This should swap those two keys.
**** org-mobile

+ http://darksun.blog.51cto.com/3874064/1302920

***** 下载 MobileOrg

豌豆荚上的 MobileOrg 版本低。

google play 在手机上安装后打开无反应！！！

https://github.com/matburt/mobileorg-android  源码不会编译，android 平
台。似乎不再更新了，最后一次提交是两年前。

Google 搜索关键字 "MobileOrg apk": [[http://www.appdownloader.net/Android/App/602857/com.matburt.mobileorg/Download][Down MobileOrg Apk 0.9.13]]

***** 配置 Emacs org

org-mobile-push C-c C-x RET p

#+BEGIN_SRC emacs-lisp
  (require 'org-mobile)
  (require 'org-id)
  (setq org-mobile-directory (expand-file-name "~/Share/Dropbox/MobileOrg"))
  (setq org-directory "~/Wally/Journal/GTD")
  (setq org-mobile-files '("~/Wally/Journal/GTD/task.org"))
  (setq org-mobile-inbox-for-pull "~/Wally/Journal/GTD/mobile.org")
#+END_SRC

****** error

#+BEGIN_EXAMPLE
(void-function org-id-get)
#+END_EXAMPLE

(require 'org-id)

***** 使用小结

#+BEGIN_EXAMPLE
  C-c C-x RET p (translated from C-c C-x <return> p) runs the command
  org-mobile-push, which is an interactive Lisp function in
  `org-mobile.el'.

  It is bound to <menu-bar> <Org> <MobileOrg> <Push Files and Views>,
  C-c C-x RET p.

  (org-mobile-push)

#+END_EXAMPLE

可以更新任务状态，但是更新的内容只是同步到了 mobile.org, 而没有改变对
应的 task.org
**** software
***** 新得立
***** Ubuntu Windows 双系统，硬盘安装

****** windows 配置

1. 下载镜像文件
   - Ubuntu 64位(乌班图系统) v12.04.1 官方原版iso镜像：http://www.33lc.com/soft/18055.html
   - Ubuntu(乌班图系统) v12.04.1 官方原版iso镜像： http://www.33lc.com/soft/18053.html

2. 下载并安装easybcd。

   easybcd是一款很优秀的系统引导软件，功能强大，最关键的是傻瓜式一站式
   简易操作，极其适合新手使用!

3. 新建分区

   腾出一个空盘，点击右键格式化之后把它删除(这个盘最好是在硬盘的后面，
   因为Windows系统不能识别Linux系统分区，如果将ubuntu装在D盘，将D盘删
   除并建立Linux系统分区后，原来的E盘就会变成D盘，安装在E盘的软件会出
   现系统注册表路径不对称，要重新安装一遍软件)。网上很多说使用磁盘压缩
   功能以整理出空白分区，这个方法也可行，但这个盘要保证有10G空间以上比
   较稳妥。

4. 安装好easybcd2.1.2后，启动软件

   #+DOWNLOADED: http://www.33lc.com/article/UploadPic/2012-8/20128241427190206.jpg @ 2016-01-10 14:16:48

   [[~/Wally/Journal/Figure/.org-download/Journal/20128241427190206_2016-01-10_14:16:48.jpg]]

   按照上图的序号依次点击“Add New Entry”——“Neo Grub”——“Install”，
   点到“Install”后出面下面的界面，再点“Configure”。

   点击“Configure”按钮后，会出现一个记事本文件，将下面的代码粘贴到文
   件尾部：

   #+BEGIN_EXAMPLE
     title Install Ubuntu 12.04 LTS
     root (hd0,6)
     kernel (hd0,6)/vmlinuz boot=casper iso-scan/filename=/ubuntu-12.04-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8
     initrd (hd0,6)/initrd.lz
   #+END_EXAMPLE

   上图代码中“ubuntu-12.04-desktop-amd64.iso”为你下载的ubuntu 12.04
   系统镜像文件名，这个文件名是可以修改的，但修改的名字一定要与写入的
   代码名字一致，否则将无法引导安装;

   (hd0,6) 表示磁盘分区，hd(0,0), hd(0,1), hd(0,2), hd(0,3)表示主分区，
   (hd0,4)以后的表示逻辑分区，现在我只有一个主分区C盘，则(hd0,0)表示C
   盘，(hd0,4)表示D盘，(hd0,5)表示E盘，(hd0,6)表示F盘，我的镜像就是放
   在F盘里，请把(hd0,6)改成自己对应的分区)

5. 将下载的镜像文件放到(hd0,N)盘的根目录下，并确保文件名与上面写入的代
   码的文件名一致为ubuntu-12.04-desktop-amd64.iso，然后用WinRAR解压缩
   软件将iso打开，将casper文件夹目录下的vmlinuz和 initrd.lz解压并复制
   到(hd0,N)盘根目录下。准备工作至此已全部完成!!!

****** Ubuntu 安装

1. sudo umount /isodevice

2. /usr/local 或 /opt 可以单独挂载一个分区

****** Windows 下删除 Ubuntu 分区导致系统无法启动（引导程序失败） :grub:

- [[http://zhidao.baidu.com/question/495728786.html?fr=ala&word=grub%20rescue%E5%88%A0%E9%99%A4ubuntu&device=mobile&ssid=0&from=2001a&uid=0&pu=usm@0][百度知道]]

装了ubuntu后，会默认从Ubuntu的Grub菜单引导系统，Win8的MBR被替换为Grub
来引导。

于是，你删除了Ubuntu，也就是删除了Grub的文件。但是，你的引导扇区的启动
参数还是指向了Grub，于是就grun rescue了。。。

*解决方法*

用PE启动，打开WinPM或者DiskGen，找到一个叫重建主引导记录（MBR）的东西，
重建一下就好了，记得把Windows分区设置为活动！

***** [[http://seisman.info/install-texlive-under-linux.html][Linux下安装TeXLive 2015]]
****** [[#id8][依赖包]]

-  安装过程中需要调用Perl的模块 =Digest::MD5= 来检测ISO文件的完整性；
-  升级过程中界面需要调用Perl的模块 =Tk= ；

CentOS:

#+BEGIN_EXAMPLE
    $ sudo yum install perl-Digest-MD5 perl-Tk
#+END_EXAMPLE

Ubuntu:

#+BEGIN_EXAMPLE
    $ sudo apt-get install libdigest-perl-md5-perl perl-tk
#+END_EXAMPLE

****** [[#id9][安装]]

******* [[#id10][下载]]

下载地址：

-  官方镜像:
   [[http://mirrors.ctan.org/systems/texlive/Images/texlive2015.iso]]
-  USTC镜像：
   [[http://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/texlive2015.iso]]

Linux下可以用wget、axel，windows下可以用迅雷，怎么快怎么来。

******* [[#id11][挂载ISO镜像]]

 #+BEGIN_EXAMPLE
     $ su
     # mount -o loop texlive2015.iso  /mnt/
     # cd /mnt
     # ./install-tl
 #+END_EXAMPLE


出现选项后，输入 =I=
直接安装（也可以更改选项）。不出意外的话，5分钟应该就OK了，然后退出root用户。

******* [[#id12][环境变量]]

在当前用户的 =~/.bashrc= 中加入如下语句：

 #+BEGIN_EXAMPLE
     # TeX Live 2015
     export MANPATH=${MANPATH}:/usr/local/texlive/2015/texmf-dist/doc/man
     export INFOPATH=${INFOPATH}:/usr/local/texlive/2015/texmf-dist/doc/info
     export PATH=${PATH}:/usr/local/texlive/2015/bin/x86_64-linux
 #+END_EXAMPLE


******* [[#id13][卸载ISO镜像]]

 #+BEGIN_EXAMPLE
     1
     2
 #+END_EXAMPLE

 #+BEGIN_EXAMPLE
     $ cd
     $ sudo umount /mnt/
 #+END_EXAMPLE

****** [[#id14][更新TeXLive]]

可以使用如下命令更新TeXLive宏包：


 #+BEGIN_EXAMPLE
     $ su
     # 更新TeXLive包管理器tlmgr
     # tlmgr update --self
     # 更新TeXLive的全部包
     # tlmgr update --all
 #+END_EXAMPLE


默认情况下，会自动搜索合适的镜像来更新，也可以使用 =--repository=
选项指定了要使用哪一个CTAN镜像。

比如USTC镜像:

#+BEGIN_EXAMPLE
    # tlmgr update --self --repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet/
    # tlmgr update --all --repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet/
#+END_EXAMPLE

比如阿里云镜像:

#+BEGIN_EXAMPLE
    # tlmgr update --self --repository http://mirrors.aliyun.com/CTAN/systems/texlive/tlnet/
    # tlmgr update --all --repository http://mirrors.aliyun.com/CTAN/systems/texlive/tlnet/
#+END_EXAMPLE

如果希望在图形界面下升级，可以使用如下命令调出tlmgr的中文图形界面：

 #+BEGIN_EXAMPLE
     $ su
     # tlmgr --gui --gui-lang zh_CN
 #+END_EXAMPLE

****** [[#id15][安装额外的字体]]

TeXLive 2015在使用xeLaTeX处理中文时，有自己的默认字体。大多数Linux发行版下，都使用自带的Fandol字体。

如果想要使用Windows字体，可以将字体文件复制到 =~/.fonts=
目录下，并在tex源码中指定字体选项即可。

*.local/share/fonts 文件夹*

****** [[#id16][修订历史]]

-  2013-07-11：初稿；
-  2014-07-06：修改为TeXLive2014，并删除中文字体部分；
-  2015-03-08：新增“安装依赖”；
-  2015-03-15：使用命令行更新包；
-  2015-03-20：指定更新源以及GUI更新；
-  2015-06-13：更新至TeXLive 2015；

So what do you think? Did I miss something? Is any part unclear? Leave
your comments below.

[[http://seisman.info/install-texlive-under-linux.html#disqus_thread][Comments]]

Please enable JavaScript to view the
[[http://disqus.com/?ref_noscript][comments powered by Disqus.]]

[[http://disqus.com][comments powered by Disqus]]

--------------

****** Related Posts:

-  [[http://seisman.info/terms-about-tex.html][与TeX相关的一些名词]]
-  [[http://seisman.info/perl-plenv.html][Perl多版本共存之plenv]]
-  [[http://seisman.info/install-gmt5-under-linux.html][GMT 5.1.2在Linux下的安装]]
-  [[http://seisman.info/mini-template-for-xeCJK.html][使用xeCJK解决中文问题的最小模板]]
-  [[http://seisman.info/install-gmt5-under-windows.html][GMT 5.1.2在Windows下的安装]]

***** [[http://ergoemacs.org/emacs/building_emacs_on_linux.html][How to Build Emacs on Linux]] :install:

This page shows you how to compile/build latest version of publically
released version of emacs on Linux. It should work for building any
emacs version. I assume you are on Ubuntu Linux.

If you want to build latest development version, see:
[[building_emacs_from_git_repository.html][How to Build Emacs from git
Repository]].

****** Summary

Here's summary of what to do.

① Install essential build tools and dependency first:

#+BEGIN_EXAMPLE
    # install essential build tools
    sudo apt-get install build-essential
#+END_EXAMPLE

② Download emacs dependencies:

#+BEGIN_EXAMPLE
    # get all dependencies of a previous emacs version
    sudo apt-get build-dep emacs24
#+END_EXAMPLE

③ Download emacs source code from [[http://ftp.gnu.org/gnu/emacs/]],
then cd to the emacs source directory.

④ Compile emacs:

#+BEGIN_EXAMPLE
    cd ‹source dir name›
    ./configure
    make
    sudo make install # optional. This basically copy the binary to /usr/local/bin
#+END_EXAMPLE

Following is detailed explanation.

--------------

****** Check Prepared Emacs Packages

On Ubuntu, typically you install by =sudo apt-get install emacs24=,
where the “emacs24” may be other version.

To search for emacs, do: =apt-cache search emacs | grep emacs=.

When emacs has a new version, Ubuntu Linux typically takes half a year
to a year to have a prepared package.

Or, you build it yourself. It's easy.

****** Download Emacs Source Code

Download emacs source code here: [[http://ftp.gnu.org/gnu/emacs/]]

****** Compile Steps

To compile programs on unix, typically the steps are:

#+BEGIN_EXAMPLE
    cd ‹source dir name›
    ./configure
    make
    sudo make install # optional. This basically copy the binary to /usr/local/bin
#+END_EXAMPLE

In the source dir, there's usually a README or INSTALL file.

However, you'll probably fail in the configure step, because emacs
requires lots other libraries, also, you might be missing build tools.

Here's some sample output of failure:

#+BEGIN_EXAMPLE
    checking for libXaw... configure: error: No X toolkit could be found.
    If you are sure you want Emacs compiled without an X toolkit, pass
      --with-x-toolkit=no
    to configure.  Otherwise, install the development libraries for the toolkit
    that you want to use (⁖ Gtk+) and re-run configure.
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    configure: error: The following required libraries were not found:
        libXpm libjpeg libpng libgif/libungif libtiff
    Maybe some development libraries/packages are missing?
    If you don't want to link with them give
        --with-xpm=no --with-jpeg=no --with-png=no --with-gif=no --with-tiff=no
    as options to configure
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    configure: error: The required function `tputs' was not found in any library.
    These libraries were tried: libncurses, libterminfo, libtermcap, libcurses.
    Please try installing whichever of these libraries is most appropriate
    for your system, together with its header files.
    For example, a libncurses-dev(el) or similar package.
#+END_EXAMPLE

You can type =./configure --help= to see the options it supports. See
its output here: [[linux_compile_emacs_24_config_help_output.txt]].

****** Install Basic Build Tools

#+BEGIN_EXAMPLE
    # install basic build tools
    sudo apt-get install build-essential
#+END_EXAMPLE

To see info about the package, do:

-  =apt-cache showpkg build-essential=
-  =apt-cache show build-essential=

****** Dependencies

You'll need to install some 30 dependent libraries. The trick is to know
which are they. Took me a couple hours to find out the hard way.

The easiest way is to install all dependencies of a previous version of
the package, like this:

#+BEGIN_EXAMPLE
    sudo apt-get build-dep emacs24
#+END_EXAMPLE

This will install all packages emacs24 depends on.

Here's the output on my machine for emacs23:

#+BEGIN_EXAMPLE
    The following NEW packages will be installed:
      autoconf automake autotools-dev bsd-mailx diffstat imagemagick libasound2-dev libdatrie-dev
      libdbus-1-dev libgconf2-dev libgpm-dev libgtk2.0-dev liblockfile-dev liblqr-1-0 libm17n-dev
      libmagickcore3 libmagickwand3 libncurses5-dev libotf-dev librsvg2-dev libthai-dev libtinfo-dev
      libxml2-dev postfix quilt sharutils texinfo xaw3dg xaw3dg-dev xutils-dev
    0 upgraded, 30 newly installed, 0 to remove and 4 not upgraded.
    Need to get 12.4 MB of archives.
    After this operation, 49.5 MB of additional disk space will be used.
#+END_EXAMPLE

You can see the full bash output here:
[[linux_compile_emacs_23_dependencies.txt]]

****** config, make

=make distclean= to clear files created by configure.

Once you have all the dependencies, you can now run =./configure= and
=make= again.

Here's a sample successful output:

-  [[linux_compile_emacs_24_config_success_output.txt]]
-  [[linux_compile_emacs_24_make_success_output.txt]]

After successful “make”, you should have a binary at =src/emacs= in the
current dir. You can test run it by =src/emacs &=.

Optionally, you can do =sudo make install=, which will basically copy
the binary to =/user/loca/bin/=, and copy various elisp files, info
files, man pages, etc, into various Linux default dirs.

***** steam                                                       :steam:
****** dota 全屏

http://jingyan.baidu.com/article/e75057f2dca190ebc91a893e.html

全屏问题，选项里设置视频，全屏模式

****** error

http://askubuntu.com/questions/614422/problem-with-installing-steam-on-ubuntu-15-04

#+BEGIN_EXAMPLE
$ steam
Running Steam on ubuntu 15.04 64-bit
STEAM_RUNTIME is enabled automatically
Installing breakpad exception handler for appid(steam)/version(0_client)
libGL error: unable to load driver: r600_dri.so
libGL error: driver pointer missing
libGL error: failed to load driver: r600
libGL error: unable to load driver: swrast_dri.so
libGL error: failed to load driver: swrast
#+END_EXAMPLE

***** [[http://lanbing510.info/2014/12/03/Linux-Matlab.html][Matlab 安装]] :install:

1. 从[[http://pan.baidu.com/s/1o6qKdxo#path=%252Fmatlab][这里]]下载Matlab2014的Linux版本及破解文件。

   - note: 两个 rar 文件，只需使用 unrar 解压其中一个即可，会自动解压
     另外一个。

2. 下载完成后将iso文件挂载到Linux进行安装。

   #+BEGIN_EXAMPLE
    sudo mkdir /media/matlab
    mount -o loop [path][filename].iso /media/matlab
    cd /media/matlab
    sudo ./install
   #+END_EXAMPLE

  - ./install 触发的是 GUI 方式，而不是命令行方式

3. 安装过程中使用readme.txt中的序列号。

4. 破解

   1) 安装完成后使用crack下的 license进行激活；

   2) 将crack文件夹下的libmwservices.so copy到 /usr/local/MATLAB/R2014A/bin/glnxa64。

5. 完成安装，命令行下使用sudo matlab即可启动使用。

***** git 安装                                                  :install:

https://github.com/git/git

from INSTALL(file)

#+BEGIN_EXAMPLE
Alternatively you can use autoconf generated ./configure script to
set up install paths (via config.mak.autogen), so you can write instead

        $ make configure ;# as yourself
        $ ./configure --prefix=/usr ;# as yourself
        $ make all doc ;# as yourself
        # make install install-doc install-html;# as root
#+END_EXAMPLE

顺便解决了 magit 因为 git 版本低的 bug

***** pandoc 安装                                               :install:

- https://github.com/jgm/pandoc


1. apt-get

   #+BEGIN_EXAMPLE
     :~$ apt-cache search pandoc
     doconce - document once, include anywhere
     gitit - Wiki engine backed by a git or darcs filestore
     libghc-citeproc-hs-data - Haskell support for Citation Style Language - data files
     libghc-citeproc-hs-dev - Haskell support for Citation Style Language
     libghc-citeproc-hs-doc - Haskell support for Citation Style Language; documentation
     libghc-citeproc-hs-prof - Haskell support for Citation Style Language; profiling libraries
     libghc-gitit-dev - Wiki engine backed by a git or darcs filestore
     libghc-gitit-doc - Wiki engine backed by a git or darcs filestore; documentation
     libghc-gitit-prof - Wiki engine backed by a git or darcs filestore; profiling libraries
     libghc-pandoc-citeproc-data - Pandoc support for Citation Style Language - data files
     libghc-pandoc-citeproc-dev - support for using pandoc with citeproc
     libghc-pandoc-citeproc-doc - support for using pandoc with citeproc; documentation
     libghc-pandoc-citeproc-prof - support for using pandoc with citeproc; profiling libraries
     libghc-pandoc-dev - general markup converter - libraries
     libghc-pandoc-doc - general markup converter - library documentation
     libghc-pandoc-prof - general markup converter - profiling libraries
     libghc-pandoc-types-dev - Haskell data types to represent structured documents
     libghc-pandoc-types-doc - Haskell data types to represent structured documents; documentation
     libghc-pandoc-types-prof - Haskell data types to represent structured documents; profiling libraries
     libghc-yesod-markdown-dev - tools for using Markdown in a Yesod application
     libghc-yesod-markdown-doc - tools for using Markdown in a Yesod application; documentation
     libghc-yesod-markdown-prof - tools for using Markdown in a Yesod application; profiling libraries
     pandoc - general markup converter
     pandoc-citeproc - Pandoc support for Citation Style Language - tools
     pandoc-data - general markup converter - data files
     python-pandocfilters - python bindings for Pandoc's filters
     python3-pandocfilters - python3 bindings for Pandoc's filters
     wally@wally:~$ sudo apt-get install pandoc
     [sudo] password for wally:
     正在读取软件包列表... 完成
     正在分析软件包的依赖关系树
     正在读取状态信息... 完成
     将会安装下列额外的软件包：
       liblua5.1-0 pandoc-data
     建议安装的软件包：
       texlive-latex-recommended texlive-xetex texlive-luatex pandoc-citeproc etoolbox
     下列【新】软件包将被安装：
       liblua5.1-0 pandoc pandoc-data
     升级了 0 个软件包，新安装了 3 个软件包，要卸载 0 个软件包，有 256 个软件包未被升级。
     需要下载 4,519 kB 的软件包。
     解压缩后会消耗掉 38.9 MB 的额外空间。
   #+END_EXAMPLE

2. source code

   + git clone git://github.com/jgm/pandoc
   + cd pandoc
   + git submodule update --init
   + cabal install --force --enable-tests
   + cabal test

注：
- 使用 cabal

- Make sure the `$CABALDIR/bin` directory is in your path.

  #+BEGIN_EXAMPLE
  export PATH=~/.cabal/bin:$PATH
  #+END_EXAMPLE

- *没有必要使用源码方式*

***** dropbox 安装

- 下载(64bit for Ubuntu): https://www.dropbox.com/zh_CN/install?os=lnx

- dpkg install
  #+BEGIN_EXAMPLE
    $ sudo dpkg -i dropbox_2015.10.28_amd64.deb
    正在选中未选择的软件包 dropbox。
    (正在读取数据库 ... 系统当前共安装有 241104 个文件和目录。)
    正准备解包 dropbox_2015.10.28_amd64.deb  ...
    正在解包 dropbox (2015.10.28) ...
    正在设置 dropbox (2015.10.28) ...
    Please restart all running instances of Nautilus, or you will experience problems. i.e. nautilus --quit
    Dropbox installation successfully completed! You can start Dropbox from your applications menu.
    正在处理用于 gnome-menus (3.10.1-0ubuntu5) 的触发器 ...
    正在处理用于 desktop-file-utils (0.22-1ubuntu3) 的触发器 ...
    正在处理用于 bamfdaemon (0.5.1+15.04.20150202-0ubuntu1) 的触发器 ...
    Rebuilding /usr/share/applications/bamf-2.index...
    正在处理用于 mime-support (3.58ubuntu1) 的触发器 ...
    正在处理用于 hicolor-icon-theme (0.14-0ubuntu1) 的触发器 ...
    正在处理用于 man-db (2.7.0.2-5) 的触发器 ...
  #+END_EXAMPLE

*** 2016/01/08
**** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html
-
  http://answers.ros.org/question/99211/how-to-combine-a-camera-image-and-a-laser-pointcloud-to-create-a-color-pointcloud/

**** gazebo

- ROS 建模

**** smartparens

- [[https://github.com/Fuco1/smartparens][Github]]
- [[https://github.com/Fuco1/smartparens/wiki][Wiki]]
- https://ebzzry.github.io/emacs-pairs.html

***** add pairs
1. global
  #+BEGIN_EXAMPLE
    (sp-pair "\{" "\}") ;; latex literal brackets (included by default)
    (sp-pair "<#" "#>")
    (sp-pair "$" "$")   ;; latex inline math mode. Pairs can have same opening and closing string
  #+END_EXAMPLE
2. local
   #+BEGIN_EXAMPLE
   (sp-local-pair 'LaTeX-mode "\\\\left(" "\\\\right)" :insert "C-b l" :trigger "\\\\l(")
   #+END_EXAMPLE

3. :wrap
   #+BEGIN_EXAMPLE
     (sp-pair "(" ")" :wrap "C-(")
   #+END_EXAMPLE

***** remove pairs
#+BEGIN_EXAMPLE
  ;; the second argument is the closing delimiter, so you need to skip it with nil
  (sp-pair "\{" nil :actions :rem)
  (sp-pair "'" nil :actions :rem)
#+END_EXAMPLE

***** wrapping

https://github.com/Fuco1/smartparens/wiki/Wrapping

#+BEGIN_SRC emacs-lisp
  (sp-local-pair 'org-mode "*" "*"
                 :wrap "*")
  (sp-local-pair 'org-mode "=" "="
                 :wrap "=")
  (sp-local-pair 'org-mode "/" "/"
                 :wrap "/")
  (sp-local-pair 'org-mode "\left(" "\n\\right)"
                 :trigger "\l(")
  (sp-local-pair 'org-mode "\left[" "\n\\right]"
                 :trigger "\l[")
  (sp-local-pair 'org-mode "\left{" "\n\\right}"
                 :trigger "\l{")
  (sp-local-pair 'org-mode "\\[" "\\]"
                 :trigger "\\[")
#+END_SRC

E=mc^2

**** wrap-region

+ [[https://github.com/rejeep/wrap-region.el][GitHub]]

Wrap Region is a minor mode for Emacs that wraps a region with
punctuations. For "tagged" markup modes, such as HTML and XML, it wraps
with tags.

***** Installation

I recommend installing via ELPA, but manual installation is simple as
well:

#+BEGIN_EXAMPLE
    (add-to-list 'load-path "/path/to/wrap-region")
    (require 'wrap-region)
#+END_EXAMPLE

***** Usage

Start =wrap-region-mode= using.

#+BEGIN_EXAMPLE
    (wrap-region-mode t)
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    M-x wrap-region-mode
#+END_EXAMPLE

Now try selecting a region and press any of the following keys: ="=,
='=, =(=, ={=, =[=.

The above are the default wrappers. You can add more yourself:

#+BEGIN_EXAMPLE
    (wrap-region-add-wrapper "$" "$")
    (wrap-region-add-wrapper "{-" "-}" "#")
    (wrap-region-add-wrapper "/" "/" nil 'ruby-mode)
    (wrap-region-add-wrapper "/* " " */" "#" '(java-mode javascript-mode css-mode))
    (wrap-region-add-wrapper "`" "`" nil '(markdown-mode ruby-mode))
#+END_EXAMPLE

The same can be done with:

#+BEGIN_EXAMPLE
    (wrap-region-add-wrappers
     '(("$" "$")
       ("{-" "-}" "#")
       ("/" "/" nil ruby-mode)
       ("/* " " */" "#" (java-mode javascript-mode css-mode))
       ("`" "`" nil (markdown-mode ruby-mode))))
#+END_EXAMPLE

For more information, see comments in =wrap-region.el=.

***** Except modes

In some modes, such as =calc-mode= and =dired-mode=, you don't want to
have wrap region active since the key bindings will conflict. Wrap
region stores a list of modes (see =wrap-region-except-modes=) in which
wrap region will be inactive.

Some modes are added to the except list by default. See the list with:

#+BEGIN_EXAMPLE
    (describe-variable 'wrap-region-except-modes)
#+END_EXAMPLE

To add a new mode, do this:

#+BEGIN_EXAMPLE
    (add-to-list 'wrap-region-except-modes 'conflicting-mode)
#+END_EXAMPLE

***** customize

****** wrap-region-add-wrapper

(wrap-region-add-wrapper LEFT RIGHT &optional KEY MODE-OR-MODES)

Add new LEFT and RIGHT wrapper.

Optional KEY is the trigger key and MODE-OR-MODES is a single
mode or multiple modes that the wrapper should trigger in.

****** global minor mode

#+BEGIN_SRC emacs-lisp
  (require 'wrap-region)
  (wrap-region-global-mode t)
#+END_SRC

****** org-mode

#+BEGIN_SRC emacs-lisp
  (wrap-region-add-wrappers
   '(("*" "*" "*" org-mode)
     ("=" "=" "=" org-mode)
     ("/" "/" "/" org-mode)
     ("$" "$" "$" org-mode)))
#+END_SRC

***** smartparens 可以替代，而且似乎更强大，同类产品只择其一

**** Eason

从2015年8月16日在微信上分享《天下无双》到12月31的《七百年后》，前前后
后一共听Eason四个半月，按发布顺序以每周一张的速度认真听了不下十五张专
辑。Eason 在我的心中已经封神。

今天一如继往听Eason的专辑《上五楼的快活》，2009年的国语专，主打“台风”。
然而对我来说，真的是一种忍受，根本不想再听第二遍。接着又看了其后几张专
辑的评论，仍然不尽如人意。进一步地关注了知乎上一些关于 Eason、Jay 和王
力宏等人的对比，问答间充斥着所谓“真粉“的武断式的论点。这为单纯的喜欢
陡然增加了嘈杂的因素---我知道这是该离开一段时间了。2016年听的Eason的首
张专辑没给我带来惊艳，反而让我畏缩了：我会有一天突然不喜欢我一直热爱的
东西么？这一时期的例子还有跑步。如果是真的的，那简直太可怕了。

等我回归 Eason 的时候，我就知道我会一直热爱自己所喜爱的事物的。此刻随
机循环着收藏的Eason单曲。

**** osrf

http://www.osrfoundation.org/

Open Source Robotics Foundation

**** 软件源配置

*/etc/apt/sources.list.d*

#+BEGIN_EXAMPLE
   $ ls /etc/apt/sources.list.d
  dartsim-ppa-trusty.list              libccd-debs-ppa-trusty.list
  dartsim-ppa-trusty.list.save         libccd-debs-ppa-trusty.list.save
  dropbox.list.save                    lotem-rime-trusty.list
  fcitx-team-nightly-trusty.list       lotem-rime-trusty.list.save
  fcitx-team-nightly-trusty.list.save  mc3man-trusty-media-trusty.list
  fcl-debs-ppa-trusty.list             mc3man-trusty-media-trusty.list.save
  fcl-debs-ppa-trusty.list.save        ros-latest.list
  gazebo-latest.list                   ros-latest.list.save
  gazebo-latest.list.save              timxx-xmradio-trusty.list
  gazebo-stable.list                   timxx-xmradio-trusty.list.save
  gazebo-stable.list.save              wengxt-fcitx-nightly-trusty.list
  gophers-go-trusty.list               wengxt-fcitx-nightly-trusty.list.save
  gophers-go-trusty.list.save
#+END_EXAMPLE

**** 新得立

#+BEGIN_EXAMPLE
E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。
#+END_EXAMPLE

后台调用 apt-get 解决依赖问题。

安装 gazebo6, OK

安装 ros-jade, 删除 gazebo6, 安装了 gazebo5

用不着参考安装指导完全使用命令行方式安装。
*可以增加了 source （软件源） 之后使用新得立安装*

*抽象出做的内容，方法只是表象*

**** ros matlab

http://jp.mathworks.com/hardware-support/robot-operating-system.html?requestedDomain=www.mathworks.com

http://www.ros.org/news/2014/01/mathworks-releases-robot-operating-system-ros-support-from-matlab.html

**** openni

**** ros jade

1. xacro
   #+BEGIN_EXAMPLE
     inconsistent namespace redefinitions for xmlns:xacro:
      old: http://ros.org/wiki/xacro
      new: http://wiki.ros.org/xacro (/home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/mecanum.xacro)
     xacro.py is deprecated; please use xacro instead
   #+END_EXAMPLE

2. CMakeLists.txt 链接依然是 indigo

   重新 catkin_init_workspace

**** 根目录空间不足

#+BEGIN_EXAMPLE
卷文件系统根目录仅剩余856M的硬盘空间
#+END_EXAMPLE

- 增加主分区容量，可以使用U盘启动ubuntu，然后用gparted调整
- 在分一个区，挂接到/var, /opt, 然后把已有文件copy过去就行
- 系统应该有个叫baobab的图形界面程序，点开看看/分区都有哪些东西占地方咯
- apt-get autoclean看看把安装软件下载的缓存清理掉
**** Linux 建立无线局域网与如何连接

http://ubuntuhandbook.org/index.php/2014/09/3-ways-create-wifi-hotspot-ubuntu/

http://roylez.herokuapp.com/2011/08/11/hostapd.html

**** Emacs 简体繁体转换

https://groups.google.com/forum/#!topic/cn.bbs.comp.emacs/0nNRwGaN1X8


#+BEGIN_QUOTE
似乎还没人写过，我觉得意义不大，
这种转换造成的问题比起的作用更多，
很多错别字或者读不通的文章都是这种转换造成的，
比如这句话：“国”字的繁体是“國”，
转成繁体后变成了：“國”字的繁體是“國”，意思完全不对了。
其实繁体的文章又不是读不懂，转换它干嘛？多此一举。
#+END_QUOTE

1. 使用 hanconvert ，失败 https://github.com/monkey413/tongwen-emacs

2. 使用谷歌翻译(网页版)

*** 2016/01/07
**** routine

1. 表格 or 格式化文本?

   后者

2. elisp+keybinding or yasnippet

   yasnippet

   - 可以有默认值
   - 必要的时候可以使用 elisp 函数

3. snippet

   #+BEGIN_SRC snippet
     # -*- mode: snippet; require-final-newline: nil -*-
     # name: rt:RoutinesExpandingForOrg-agenda
     # key: rt
     # binding: direct-keybinding
     # --
     睡眠:${1:1:00}
     起床:${2:7:00}
     跑步:${3:5K}
     吉它:${4:0.5h}
     读书:${5:0.5h}
     Friends:${6:S01E01}
     Dota:${7:45m}
     早餐:${8:1}
     锻炼:${9:0+0}
     牛奶:${10:1}
   #+END_SRC

**** doxygen API

1. PDF vs HTML

   更喜欢 PDF，可以标注、搜索方便等

2. API vs Source Code

   更喜欢后者！

**** IDE
***** Emacs VS Vim

Emacs 更熟悉

Vim 慢慢来

***** IDE & project
***** 目标

- [ ] 头文件与源文件之间跳转
- [ ] 浏览Linux内核树
- [ ] 交互式大纲显示文件结构
- [ ] 以文件浏览器形式显示静态大纲树
- [ ] 符号引用
- [ ] 代码补全
- [ ] 头文件补全
- [ ] 在底部显示函数接口和变量定义
- [ ] 跳转到当前函数头
- [ ] 编译支持
- [ ] 编译输出
- [ ] GDB调试
- [ ] 查看手册

***** 头文件与源文件之间跳转

**** usb camera                                           :camera:web_cam:

#+BEGIN_EXAMPLE
   ~ $ fswebcam --no-banner -r 640x480 demo.jpg
  --- Opening /dev/video0...
  Trying source module v4l2...
  /dev/video0 opened.
  No input was specified, using the first.
  --- Capturing frame...
  Captured frame in 0.00 seconds.
  --- Processing captured image...
  Disabling banner.
  Writing JPEG image to 'demo.jpg'.
#+END_EXAMPLE
***** /dev/vedio*

/dev/video0

#+BEGIN_EXAMPLE
$ lsusb
Bus 001 Device 006: ID 1e4e:0102 Cubeternet GL-UPC822 UVC WebCam
#+END_EXAMPLE


***** fswebcam: Small and simple webcam software for *nix      :fswebcam:

- [[http://manpages.ubuntu.com/manpages/lucid/man1/fswebcam.1.html][Ubuntu manpages]]
- [[https://github.com/fsphil/fswebcam][github]]
- [[http://www.firestorm.cx/fswebcam/][Homepage]]
- http://www.bkjia.com/Linuxjc/992291.html

****** man                                                         :man:
******* NAME


fswebcam - Small and simple webcam for *nix.

******* SYNOPSIS


fswebcam [<options>] <filename> [[<options>] <filename> ... ]

******* DESCRIPTION


fswebcam  is  a  small  and  simple webcam app for *nix. It can capture
images  from  a  number  of  different  sources  and   perform   simple
manipulation  on  the  captured image. The image can be saved as one or
more PNG or JPEG files.

The PNG or JPEG image can be sent to stdio using the filename "-".  The
output filename is formatted by strftime.

******* CONFIGURATION

******** Configuration File

Config  files  use the long version of options without the "--" prefix.
Comments start with a # symbol at the beginning of the line.

******** General Options
-?, --help
       Show a usage summary.

-c, --config
       Load  options  from  a  file.  You can load more than one config
       file, and can mix them with command-line arguments.

       Note: This option can not be used from  within  a  configuration
       file.

-q, --quiet
       Hides all messages except errors.

-v, --verbose
       Print extra information during the capture process.

--version
       Print the version number and exit.

-l, --loop <frequency>
       Continually capture images. The time between images is specified
       in seconds.

       Default behaviour is to capture a single image and exit.

       Note: The time to capture the next image is calculated  relative
       to  the epoch, so an image will not be captured immediately when
       the program is first started.

--offset <seconds>
       Sets the offset to use when calculating when the next  image  is
       due in loop mode. Value can be positive or negative.

-b, --background
       Run  in  the background. In this mode stdout and console logging
       are unavailable.

--pid <filename>
       Saves the PID of the background process to the  specified  file.
       Ignored when not using background mode.

--log [file/syslog:]<filename>
       Redirect log messages to a file or syslog. For example

       --log output.log
       --log file:output.log
       --log syslog

--gmt  Use  GMT instead of the local timezone when formatting text with
       strftime.

******** Capture Options
-d, --device [<prefix>:]<device name>
       Set the source or device to use. The source module  is  selected
       automatically unless specified in the prefix.

       Default is /dev/video0.

       Available source modules, in order of preference:

       V4L2 - Capture images from a V4L2 compatible video device.
       V4L1 - Capture images from a V4L1 compatible video device.
       FILE - Capture an image from a JPEG or PNG image file.
       RAW - Reads images straight from a device or file.
       TEST - Draws colour bars.

-i, --input <input number or name>
       Set  the  input  to  use. You may select an input by either it’s
       number or name.

       Default is "0".

--list-inputs
       List available inputs for the selected source or device.

       fswebcam -d v4l2:/dev/video1 --list-inputs

-t, --tuner <tuner number>
       Set the tuner to use.

-f, --frequency <frequency>
       Set the frequency of the selected input or tuner. The value  may
       be read as KHz or MHz depending on the input or tuner.

-p, --palette <name>
       Try  to use the specified image format when capturing the image.

       Default is to select one automatically.

       Supported formats:

       PNG
       JPEG
       MJPEG
       RGB32
       RGB24
       BGR32
       BGR24
       YUYV
       UYVY
       YUV420P
       BAYER
       RGB565
       RGB555
       GREY

-r, --resolution <dimensions>
       Set the image resolution of the source  or  device.  The  actual
       resolution  used  may  differ  if  the  source  or device cannot
       capture at the specified resolution.

       Default is "384x288".

--list-framesizes
       Lists the supported resolutions for the selected source.

--list-framerates
       Lists the supported frame rates  for  the  selected  source  and
       resolution.

-F, --frames <number>
       Set the number of frames to capture. More frames mean less noise
       in the final image, however capture times  will  be  longer  and
       moving objects may appear blurred.

       Default is "1".

-S, --skip <number>
       Set  the number of frames to skip. These frames will be captured
       but won’t be use. Use this option if your camera sends some  bad
       or corrupt frames when it first starts capturing.

       Default is "0".

-D, --delay <delay>
       Inserts  a  delay after the source or device has been opened and
       initialised, and before the capture begins.  Some  devices  need
       this  delay to let the image settle after a setting has changed.
       The delay time is specified in seconds.

-R, --read
       Use read() to capture images. This can be slower but more stable
       with some devices.

       Default  is  to  use mmap(), falling back on read() if mmap() is
       unavailable.

-s, --set <name=value>
       Set a control. These are used by the source modules  to  control
       image or device parameters. Numeric values can be expressed as a
       percentage of there  maximum  range  or  a  literal  value,  for
       example:

       --set brightness=50% --set framerate=5

       Non-numeric controls are also supported:

       --set lights=on

       V4L2  features  a  type  of  control  called  a  ’button’. These
       controls do not take any  value,  but  trigger  an  action.  For
       example:

       --set "Restore Factory Settings"

       Control names and values are not case sensitive.

       Note:  Available  controls  will  vary  depending  in the source
       module  and  devices  used.  For  more   information   see   the
       --list-controls option.

--list-controls
       List  available  controls  and  their  current  values  for  the
       selected source module and device. For example:

       fswebcam -d v4l2:/dev/video2 --list-controls

******** Output Options
These options are performed in the order they  appear  on  the  command
line,  only  effecting  images  output  later  on the command line. For
example:

       fswebcam -r 640x480 output1.jpeg --scale 320x240 output2.jpeg

       Will  create  two  images,  "output1.jpeg"  containing  a   full
       resolution   copy  of  the  captured  image  and  "output2.jpeg"
       containing the same captured image but scaled to half the  size.

--no-banner
       Disable the banner.

--top-banner
       Position the banner at the top of the image.

--bottom-banner
       Position the banner at the bottom of the image.

       This is the default.

--banner-colour <#AARRGGBB>
       Set  the  colour  of  the banner. Uses the web-style hexadecimal
       format (#RRGGBB) to describe the  colour,  and  can  support  an
       alpha channel (#AARRGGBB). Examples:

       "#FF0000" is pure red.
       "#80000000" is semi-transparent black.
       "#FF000000" is invisible (alpha channel is at maximum).
       Default is "#40263A93".

--line-colour <#AARRGGBB>
       Set the colour of the divider line. See --banner-colour for more
       information.

       Default is "#00FF0000".

--text-colour <#AARRGGBB>
       Set the  colour  of  the  text.  See  --banner-colour  for  more
       information.

       Default is "#00FFFFFF".

--font <[file or font name]:[font size]>
       Set  the  font  used  in the banner. If no path is specified the
       path in the GDFONTPATH environment variable is searched for  the
       font.

       If no font size is specified the default of "10" will be used.

       Default is "luxisr:10".

--no-shadow
       Disable the text shadow.

--shadow
       Enable the text shadow.

       This is the default behaviour.

--title <text>
       Set the main text, located in the top left of the banner.

--no-title
       Clear the main text.

--subtitle <text>
       Set  the  sub-title  text,  located  in  the  bottom left of the
       banner.

--no-subtitle
       Clear the sub-title text.

--timestamp <text>
       Set the timestamp text, located in the top right of the  banner.
       This string is formatted by strftime.

       Default is "%Y-%m-%d %H:%M (%Z)".

--no-timestamp
       Clear the timestamp text.

--info <text>
       Set the info text, located in the bottom right of the banner.

--no-info
       Clear the info text.

--underlay <filename>
       Load  a PNG image and overlay it on the image, below the banner.
       The image is aligned to the top left.

       Note: The underlay is only applied when saving an image  and  is
       not modified by any of the image options or effects.

--no-underlay
       Clear the underlay image.

--overlay <filename>
       Load a PNG image and overlay on the image, above the banner. The
       image is aligned to the top left.

       Note: The overlay is only applied when saving an  image  and  is
       not modified by any of the image options or effects.

--no-overlay
       Remove the overlay image.

--jpeg <factor>
       Set JPEG as the output image format. The compression factor is a
       value between 0 and 95, or -1 for automatic.

       This is the default format, with a factor of "-1".

--png <factor>
       Set PNG as the output image format. The compression  factor  can
       be a value between 0 and 9, or -1 for automatic.

--save <filename>
       Saves the image to the specified filename.

       Note:  This isn’t necessary on the command-line where a filename
       alone is enough to save an image.

--revert
       Revert to the  original  captured  image  and  resolution.  This
       undoes all previous effects on the image.

       Note:  This  only reverts the image itself, and not options such
       as font, colours and overlay.

--flip <direction[,direction]>
       Flips the image. Direction can be  (h)orizontal  or  (v)ertical.
       Example:

       --flip h    Flips the image horizontally.
       --flip h,v  Flips the image both horizontally and vertically.

--crop <dimensions[,offset]>
       Crop  the  image.  With  no  offset the cropped area will be the
       center of the image. Example:

       --crop 320x240    Crops the center 320x240 area of the image.
       --crop 10x10,0x0  Crops the 10x10 area at the top left corner of
       the image.

--scale <dimensions>
       Scale the image.

       Example:  "--scale  640x480"  scales  the  image  up  or down to
       640x480.

       Note: The aspect ratio of the image is not maintained.

--rotate <angle>
       Rotate the image in right angles (90, 180 and 270 degrees).

       Note: Rotating the  image  90  or  270  degrees  will  swap  the
       dimensions.

--deinterlace
       Apply a simple deinterlacer to the image.

--invert
       Invert all the colours in the image, creating a negative.

--exec <command>
       Executes  the  specified  command  and  waits for it to complete
       before continuing. The command line is formatted by strftime.

******* SIGNALS

SIGHUP This causes fswebcam to reload it’s configuration.

SIGUSR1
       Causes fswebcam to capture an image immediately without  waiting
       on the timer in loop mode.

****** help                                                       :help:

#+BEGIN_EXAMPLE
   ~ $ fswebcam --help
  Usage: fswebcam [<options>] <filename> [[<options>] <filename> ... ]

   Options:

   -?, --help                   Display this help page and exit.
   -c, --config <filename>      Load configuration from file.
   -q, --quiet                  Hides all messages except for errors.
   -v, --verbose                Displays extra messages while capturing
       --version                Displays the version and exits.
   -l, --loop <seconds>         Run in loop mode.
   -b, --background             Run in the background.
   -o, --output <filename>      Output the log to a file.
   -d, --device <name>          Sets the source to use.
   -i, --input <number/name>    Selects the input to use.
   -t, --tuner <number>         Selects the tuner to use.
   -f, --frequency <number>     Selects the frequency use.
   -p, --palette <name>         Selects the palette format to use.
   -D, --delay <number>         Sets the pre-capture delay time. (seconds)
   -r, --resolution <size>      Sets the capture resolution.
       --fps <framerate>        Sets the capture frame rate.
   -F, --frames <number>        Sets the number of frames to capture.
   -S, --skip <number>          Sets the number of frames to skip.
       --dumpframe <filename>   Dump a raw frame to file.
   -s, --set <name>=<value>     Sets a control value.
       --revert                 Restores original captured image.
       --flip <direction>       Flips the image. (h, v)
       --crop <size>[,<offset>] Crop a part of the image.
       --scale <size>           Scales the image.
       --rotate <angle>         Rotates the image in right angles.
       --deinterlace            Reduces interlace artifacts.
       --invert                 Inverts the images colours.
       --greyscale              Removes colour from the image.
       --swapchannels <c1c2>    Swap channels c1 and c2.
       --no-banner              Hides the banner.
       --top-banner             Puts the banner at the top.
       --bottom-banner          Puts the banner at the bottom. (Default)
       --banner-colour <colour> Sets the banner colour. (#AARRGGBB)
       --line-colour <colour>   Sets the banner line colour.
       --text-colour <colour>   Sets the text colour.
       --font <[name][:size]>   Sets the font and/or size.
       --no-shadow              Disables the text shadow.
       --shadow                 Enables the text shadow.
       --title <text>           Sets the main title. (top left)
       --no-title               Clears the main title.
       --subtitle <text>        Sets the sub-title. (bottom left)
       --no-subtitle            Clears the sub-title.
       --timestamp <format>     Sets the timestamp format. (top right)
       --no-timestamp           Clears the timestamp.
       --gmt                    Use GMT instead of local timezone.
       --info <text>            Sets the info text. (bottom right)
       --no-info                Clears the info text.
       --underlay <PNG image>   Sets the underlay image.
       --no-underlay            Clears the underlay.
       --overlay <PNG image>    Sets the overlay image.
       --no-overlay             Clears the overlay.
       --jpeg <factor>          Outputs a JPEG image. (-1, 0 - 95)
       --png <factor>           Outputs a PNG image. (-1, 0 - 10)
       --save <filename>        Save image to file.
       --exec <command>         Execute a command and wait for it to complete.

#+END_EXAMPLE

***** uvc                                                           :uvc:

USB Video Class (UVC)

**** usb_cam

- http://wiki.ros.org/usb_cam

A ROS Driver for V4L USB Cameras

***** usb_cam_node

The =usb_cam_node= interfaces with standard USB cameras (e.g. the
Logitech Quickcam) using libusb_cam and publishes images as
sensor_msgs::Image. Uses the [[/image_transport][image_transport]]
library to allow compressed image transport.

****** Published Topics

=~<camera_name>/image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image

****** Parameters

=~video_device= (=string=, default: ="/dev/video0"=)

-  The device the camera is on.

=~image_width= (=integer=, default: =640=)

-  Image width

=~image_height= (=integer=, default: =480=)

-  Image height

=~pixel_format= (=string=, default: ="mjpeg"=)

-  Possible values are mjpeg, yuyv, uyvy

=~io_method= (=string=, default: ="mmap"=)

-  Possible values are mmap, read, userptr

=~camera_frame_id= (=string=, default: ="head_camera"=)

-  The camera's tf frame

=~framerate= (=integer=, default: =30=)

-  The required framerate

=~contrast= (=integer=, default: =32=)

-  Contrast of video image (0-255)

=~brightness= (=integer=, default: =32=)

-  Brightness of video image (0-255)

=~saturation= (=integer=, default: =32=)

-  Saturation of video image (0-255)

=~sharpness= (=integer=, default: =22=)

-  Sharpness of video image (0-255)

=~autofocus= (=boolean=, default: =false=)

-  Enable camera's autofocus

=~focus= (=integer=, default: =51=)

-  If autofocus is disabled, the focus of the camera (0=at infinity)

=~camera_info_url= (=string=, default: ==)

-  An url to the camera calibration file that will be read by the
   [[/CameraInfoManager][CameraInfoManager]] class

=~camera_name= (=string=, default: =head_camera=)

-  The camera name. This must match the name in the camera calibration

****** Related packages

[[/gencam_cu][gencam_cu]] - supports image capture from usb cameras
using OpenCV
**** 电源

- UTM

  [[/home/ben/Wally/Journal//Figure/scrot/151903Kb.png]]

- Microstrain

  [[/home/ben/Wally/Journal//Figure/scrot/15190EVh.png]]

- raspberry

  5V 1.2A
  - GPIO ： 50mA
  - HDMI : 50mA
  - Camera: 250mA
  - keyboard/mice: 100mA~1000mA

- LMS 291

  [[/home/ben/Wally/Journal//Figure/scrot/15190Rfn.png]]

Power

12*3 + 5*0.08 < 40W

https://e2e.ti.com/blogs_/b/powerhouse/archive/2015/09/16/high-density-pcb-layout-of-dc-dc-converters-part-2



***** 纹波

纹波(ripple)是由于直流稳定电源的电压波动而造成的一种现象，因为直流稳定电源一般
是由交流电源经整流稳压等环节而形成的，这就不可避免地在直流稳定量中多少
带有一些交流成份，这种叠加在直流稳定量上的交流分量就称之为纹波。纹波的
成分较为复杂，它的形态一般为频率高于工频的类似正弦波的谐波，另一种则是
宽度很窄的脉冲波。
**** latex 梯度                                                     :梯度:

\nabla

**** image_view

Released Continuous integration Documented

A simple viewer for ROS image topics. Includes a specialized viewer for
stereo + disparity images.

***** Usage

****** Viewing a single image topic

#+BEGIN_EXAMPLE
    image_view image:=<image topic> [image transport type]
#+END_EXAMPLE

For example, to view raw images on the topic =/camera/image=, use:

#+BEGIN_EXAMPLE
    image_view image:=/camera/image
#+END_EXAMPLE

You may save the current image by left-clicking on the display window.
By default, images will be saved as =frame0000.jpg=, =frame0001.jpg=,
.... }}}

If you want to view a compressed image stream (usually a good idea over
wireless!) using the capabilities of
[[/image_transport][image_transport]], specify the transport type as a
command-line argument. For example, if
[[/theora_image_transport][theora_image_transport]] is built on the
publisher's side, you can use =theora= transport:

#+BEGIN_EXAMPLE
    image_view image:=/camera/image theora
#+END_EXAMPLE

Note that this is merely shorthand equivalent to setting the
=~image_transport= parameter:

#+BEGIN_EXAMPLE
    image_view image:=/camera/image _image_transport:=theora
#+END_EXAMPLE

****** Viewing stereo images

#+BEGIN_EXAMPLE
    stereo_view stereo:=<stereo namespace> image:=<image topic identifier>
#+END_EXAMPLE

For example, to view stereo image pairs on topics
=/my_stereo_cam/left/image_rect_color= and
=/my_stereo_cam/right/image_rect_color=, use:

#+BEGIN_EXAMPLE
    stereo_view stereo:=/my_stereo_cam image:=image_rect_color
#+END_EXAMPLE

=stereo_view= also shows the disparity image computed from the stereo
pair, color-mapped for clarity.

You may save the current image pair by left-clicking on either display
window. By default, images will be saved as =left0000.jpg=,
=right0000.jpg=, =left0001.jpg=, =right0001.jpg=....

***** Nodes

****** image_view

Simple image viewer for ROS topics.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~filename_format= (=string=, default: ="frame%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image stream. =image_view= allows you to
   specify this as a simple command-line argument for convenience.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

****** stereo_view

Viewer for stereo images. Shows the left/right image pair and the
disparity image (color-mapped) computed from them.
******* Subscribed Topics

=<stereo>/left/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The left image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/right/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The right image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/disparity=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

-  The disparity image computed from the left/right stereo pair.

******* Parameters

=~autosize= (=bool=, default: true)

-  Whether the windows should autosize to the image or be resizeable by
   the user.

=~filename_format= (=string=, default: ="%s%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images. The string argument is ="left"=
   or ="right"=.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image streams.

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div
  class="version diamondback electric fuerte groovy hydro indigo jade">
#+END_HTML

#+BEGIN_HTML
  <div id="image_view.2BAC8-diamondback.content" dir="ltr" lang="en">
#+END_HTML

#+BEGIN_HTML
  <div class="table-of-contents">
#+END_HTML

Contents

1. [[#image_view.2BAC8-diamondback.Usage][Usage]]

   1. [[#image_view.2BAC8-diamondback.Viewing_a_single_image_topic][Viewing
      a single image topic]]
   2. [[#image_view.2BAC8-diamondback.Viewing_stereo_images][Viewing
      stereo images]]

2. [[#image_view.2BAC8-diamondback.Nodes][Nodes]]

   1. [[#image_view.2BAC8-diamondback.image_view][image_view]]
   2. [[#image_view.2BAC8-diamondback.disparity_view][disparity_view]]
   3. [[#image_view.2BAC8-diamondback.stereo_view][stereo_view]]

3. [[#image_view.2BAC8-diamondback.Nodelets][Nodelets]]

   1. [[#image_view.2BAC8-diamondback.image_view.2BAC8-image][image_view/image]]
   2. [[#image_view.2BAC8-diamondback.image_view.2BAC8-disparity][image_view/disparity]]

4. [[#image_view.2BAC8-diamondback.Tools][Tools]]

   1. [[#image_view.2BAC8-diamondback.image_saver][image_saver]]
   2. [[#image_view.2BAC8-diamondback.extract_images][extract_images]]
   3. [[#image_view.2BAC8-diamondback.video_recorder][video_recorder]]

#+BEGIN_HTML
  </div>
#+END_HTML

***** Usage

****** Viewing a single image topic

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=<image topic> [image transport type]
#+END_EXAMPLE

For example, to view raw images on the topic =/camera/image=, use:

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=/camera/image
#+END_EXAMPLE

You may save the current image by right-clicking on the display window.
By default, images will be saved as =frame0000.jpg=, =frame0001.jpg=,
....

If you want to view a compressed image stream (usually a good idea over
wireless!) using the capabilities of
[[/image_transport][image_transport]], specify the transport type as a
command-line argument. For example, if
[[/theora_image_transport][theora_image_transport]] is built on the
publisher's side, you can use =theora= transport:

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=/camera/image theora
#+END_EXAMPLE

Note that this is merely shorthand equivalent to setting the
=~image_transport= parameter:

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=/camera/image _image_transport:=theora
#+END_EXAMPLE

****** Viewing stereo images

#+BEGIN_EXAMPLE
    rosrun image_view stereo_view stereo:=<stereo namespace> image:=<image topic identifier>
#+END_EXAMPLE

For example, to view stereo image pairs on topics
=/my_stereo_cam/left/image_rect_color= and
=/my_stereo_cam/right/image_rect_color=, use:

#+BEGIN_EXAMPLE
    rosrun image_view stereo_view stereo:=/my_stereo_cam image:=image_rect_color
#+END_EXAMPLE

=stereo_view= also shows the disparity image computed from the stereo
pair, color-mapped for clarity.

You may save the current image pair by right-clicking on any display
window. By default, images will be saved as =left0000.jpg=,
=right0000.jpg=, =disp0000.jpg=, =left0001.jpg=, =right0001.jpg=,
=disp0001.jpg=.... As with =image_view=, you can specify an image
transport to use for the left and right image as an optional argument.

***** Nodes

****** image_view

Simple image viewer for ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topics.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~filename_format= (=string=, default: ="frame%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image stream. =image_view= allows you to
   specify this as a simple command-line argument for convenience.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

****** disparity_view

Simple viewer for
[[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]]
topics. Color-maps the disparity image for visualization.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

-  The disparity image topic. Should be remapped to the name of the real
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

****** stereo_view

Viewer for stereo images. Shows the synchronized left/right image pair
and the disparity image (color-mapped) computed from them.
******* Subscribed Topics

=<stereo>/left/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The left image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/right/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The right image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/disparity=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

-  The disparity image computed from the left/right stereo pair.

******* Parameters

=~autosize= (=bool=, default: true)

-  Whether the windows should autosize to the image or be resizeable by
   the user.

=~filename_format= (=string=, default: ="%s%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images. The string argument is ="left"=
   or ="right"=.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image streams.

=~approximate_sync= (=bool=, default: false)

-  Whether to use approximate synchronization. Set to true if the left
   and right cameras do not produce exactly synced timestamps.

=~queue_size= (=int=, default: 5)

-  Size of message queue for each synchronized topic. You may need to
   raise this if disparity processing takes too long, or if there are
   significant network delays.

***** Nodelets

****** image_view/image

Nodelet version of image_view. Brings up a display window for a
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~filename_format= (=string=, default: ="frame%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image stream. =image_view= allows you to
   specify this as a simple command-line argument for convenience.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

****** image_view/disparity

Nodelet version of disparity_view. Brings up a display window for a
[[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]]
topic, color-mapped for visualization.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

-  The disparity image topic. Should be remapped to the name of the real
   topic.

******* Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

#+BEGIN_HTML
  <div class="version hydro_and_newer">
#+END_HTML

***** Tools

****** image_saver

This tool allows you to save images as jpg/png file from streaming (ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic) to a file.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

******* Services

=save=
([[http://docs.ros.org/api/std_srvs/html/srv/Empty.html][std_srvs/Empty]])

-  Save images, you need to set save_all_images to false

******* Parameters

=~filename_format= (=string=, default: =left%04d.%s=)

-  File name for saved images, you can use '%04i' for sequence number,
   and '%s' for default file format, you can use 'jpg' ,'png', 'pgm' as
   filename suffixes.

=~encoding= (=string=, default: 'bgr8')

-  Encoding type of input image topic.

=~save_all_image= (=bool=, default: true)

-  If you set false, images are only saved when 'save' service is called

****** extract_images

This tool also allows you to save images as jpg/png file from streaming
(ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic) to a file. =image_saver= node provide very similar
functionalities, such as providing service call to trigger the node to
save images, save images other than Jpeg format, etc.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~filename_format= (=string=, default: =frame%04d.jpg=)

-  File name for saved images, you must add use '%04i' for sequence
   number.

=~sec_per_frame= (=double=, default: '0.1')

-  set sec per frame value.

****** video_recorder

This tool allows you to record a video stream (ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic) to a file. It relies on
[[http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videowriter][OpenCV's
VideoWriter class]]. With the default options, it encodes the video as
MPG, encapsulated in a AVI container at 15 fps, and produces a file
called =output.avi= in the current directory.
******* Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

******* Parameters

=~filename= (=string=, default: =output.avi=)

-  Path and name of the output video.

=~fps= (=int=, default: 15)

-  Framerate of the video.

=~codec= (=string=, default: =MJPG=)

-  The [[http://www.fourcc.org/codecs.php][FOURCC]] identifier of the
   codec.

=~encoding= (=string=, default: =bgr8=)

-  The image color space of the video.
*** 2016/01/06
**** vtk: Visualization Toolkit

The *Visualization Toolkit* (VTK) is an *open-source*, freely available
software system for _3D computer graphics, image processing, and
visualization._ It consists of =a C++ class library= and several
interpreted =interface= layers including Tcl/Tk, Java, and
*Python*. Kitware, whose team created and continues to extend the
toolkit, offers professional support and consulting services for
VTK. VTK supports a wide variety of *visualization algorithms* including
scalar, vector, tensor, texture, and volumetric methods, as well as
advanced modeling techniques such as implicit modeling, polygon
reduction, mesh smoothing, cutting, contouring, and Delaunay
triangulation. VTK has an extensive information visualization
framework and a suite of 3D interaction widgets. The toolkit supports
parallel processing and integrates with various databases on GUI
toolkits such as *Qt and Tk*. VTK is *cross-platform* and runs on Linux,
Windows, Mac, and Unix platforms.

**** org-download

- https://github.com/abo-abo/org-download


#+BEGIN_SRC emacs-lisp
  (require 'org-download)
  (setq org-download-method 'directory)
  (setq-default org-download-image-dir
                (concat (getenv "JOURNAL-WS") "/Figure/.org-download")) ; org-down 文件命名有时会比较丑，所以放在隐藏文件夹下
  (setq org-download-heading-lvl nil)
  (setq org-download-timestamp "_%Y-%m-%d_%H:%M:%S")
  ;; (define-key org-mode-map "\C-c\M-s" 'org-download-screenshot)
  (define-key org-mode-map "\C-c\M-y" 'org-download-yank)
  (setq org-download-backend "wget \"%s\" -O \"%s\"")
#+END_SRC

1. 从 chrome 中拖拽不管用

   委曲求全： 右键图片，复制图片网址， *org-download-image*

   #+BEGIN_EXAMPLE
     org-download-image is an interactive compiled Lisp function in
     `org-download.el'.

     (org-download-image LINK)

     Save image at address LINK to `org-download--dir'.
   #+END_EXAMPLE

2. 从 Firefox 中拖拽起作用
3. 从系统的文件管理器中拖拽起作用

*** 2016/01/04
**** chrome 下载文件命名编码

1. why?

   百度云打包下载的压缩文件命名正确，解压后出现乱码

2. 设置 chrome 字体编码

   http://jingyan.baidu.com/article/e52e36154b3ff640c70c515f.html
   http://www.tuicool.com/articles/VjInAf

   扳手-------->Settings（设置）-------->ShowAdvance Settings（显示高
   级设置）-------->Web Content（网页内容）-------->Customizefonts（自
   定义字体）-------->Encoding（编码）

3. 不是 chrome 的问题，是百度云的问题，没解决，不重要

   http://www.zhihu.com/question/28144692

**** RS232                                                         :rs232:
***** RS-232 Wiki


*RS-232* 是美国[[/wiki/%E7%94%B5%E5%AD%90%E5%B7%A5%E4%B8%9A%E8%81%94%E7%9B%9F][电子工业联盟]]（EIA）制定的串行数据通信的接口标准。它被广
泛用于计算机串行接口外设连接。


它規定連接[[/wiki/%E9%9B%BB%E7%BA%9C][電纜]]和[[/wiki/%E6%A9%9F%E6%A2%B0][機械]]、[[/wiki/%E9%9B%BB%E6%B0%A3][電氣]]特性、信號功能及傳送過程。其他常用電氣標準還有
[[/wiki/EIA-422][EIA-RS-422-A]]、[[/w/index.php?title=EIA-423&action=edit&redlink=1][EIA-RS-423A]]、[[/wiki/RS-485][EIA-RS-485]]。

由於RS-232-C的重大影響，即使自IBM [[/wiki/PC/AT][PC/AT ]]開始改用9針連接器起，目前已幾
乎不再使用RS-232中規定的25針連接器，但大多數人仍然普遍使用RS-232C來代
表此一介面。

****** 标准的细节

在RS-232标准中，字符是以一序列的位元串来一个接一个的[[/w/index.php?title=%E4%B8%B2%E5%88%97&action=edit&redlink=1][串列]]（serial）方式
傳輸，優點是傳輸線少，配線簡單，傳送距離可以較遠。最常用的编码格式是异
步起停（asynchronous start-stop）格式，它使用一个起始位元后面紧跟7或8
个数据位元（bit），然后是可选的奇偶校验位元，最后是一或两个停止位元。
所以发送一个字符至少需要10位元，带来的一个好的效果是使全部的传输速率，
发送信号的速率以10划分。一个最平常的代替异步起停方式的是使用[[/wiki/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6][高级数据链
路控制]]协议（HDLC）。

在RS-232标准中定义了逻辑一和逻辑零电压级数，以及标准的传输速率和连接器
类型。信号大小在正的和负的3－15v之间。RS-232规定接近零的电平是无效的，
逻辑一规定为负电平，有效负电平的信号状态称为传号marking，它的功能意义
为OFF，逻辑零规定为正电平，有效正电平的信号状态称为空号spacing，它的功
能意义为ON。根据设备供电电源的不同，±5、±10、±12和±15这样的电平都
是可能的。


******* 连接器

RS-232設計之初是用來連接數據機做傳輸之用，也因此它的腳位意義通常也和數
據機傳輸有關。RS-232的设备可以分为数据终端设备（DTE，Data Terminal
Equipment, For example, PC）和数据通信设备（DCE，Data Communication
Equipment）两类，这种分类定义了不同的线路用来发送和接受信号。一般来说，
计算机和终端设备有DTE连接器，调制解调器和打印机有DCE连接器。但是这么说
并不是总是严格正确的，用配线分接器测试连接，或者用试误法来判断电缆是否
工作，常常需要参考相关的文件说明。

RS-232指定了20个不同的信号连接，由25个D-sub（微型D类）管脚构成的DB-25
连接器。

很多设备只是用了其中的一小部分管脚，出于节省资金和空间的考虑不少机器采
用较小的连接器，特别是9管脚的D-sub或者是 *DB-9* 型连接器被广泛使用绝大
多数自IBM的AT机之后的PC机和其他许多设备上。DB-25 和 DB-9 型的连接器在大部
分设备上是雌型，但不是所有的都是这样。

下表中列出的是被较多使用的RS-232中的信号和管脚分配：

#+BEGIN_EXAMPLE
               DE-9 Male（Pin Side）                   DE-9 Female (Pin Side）
                 -------------                          -------------
                 \ 1 2 3 4 5 /                          \ 5 4 3 2 1 /
                  \ 6 7 8 9 /                            \ 9 8 7 6 /
                   ---------                              ---------
#+END_EXAMPLE

| 信号                | DB-25 | DE-9 | EIA/TIA 561 | Yost |
|---------------------+-------+------+-------------+------|
| 公共接地            |     7 |    5 |           4 |  4,5 |
| 发送数据（TD、TXD） |     2 |    3 |           6 |    3 |
| 接受数据（RD、RXD） |     3 |    2 |           5 |    6 |
| 数据终端准备（DTR） |    20 |    4 |           3 |    2 |
| 数据准备好（DSR）   |     6 |    6 |           1 |    7 |
| 请求发送（RTS）     |     4 |    7 |           8 |    1 |
| 清除发送（CTS）     |     5 |    8 |           7 |    8 |
| 数据载波检测（DCD） |     8 |    1 |           2 |    7 |
| 振铃指示（RI）      |    22 |    9 |           1 |   － |

| 腳位 | 簡寫 | 意義                | 說明                           |
|------+------+---------------------+--------------------------------|
| Pin1 | CD   | Carrier Detect      | 數據機通知電腦有載波被偵測到。 |
| Pin2 | RXD  | Receiver            | 接收資料。                     |
| Pin3 | TXD  | Transmit            | 傳送資料。                     |
| Pin4 | DTR  | Data Terminal Ready | 電腦告訴數據機可以進行傳輸。   |
| Pin5 | GND  | Ground              | 地線。                         |
| Pin6 | DSR  | Data Set Ready      | 數據機告訴電腦一切準備就緒。   |
| Pin7 | RTS  | Request To Send     | 電腦要求數據機將資料送出。     |
| Pin8 | CTS  | Clear To Send       | 數據機通知電腦可以傳資料過來。 |
| Pin9 | RI   | Ring Indicator      | 數據機通知電腦有電話進來。     |

TXD DTE->DCE DTE SEND DATA

RXD DCE->DTE DTE RECEIVE DATA

RTS DTE->DCE DTE REQUEST SEND

CTS DCE->DTE ACK TO DTE'S RTS

DSR DCE->DTE DCE IS READY

GND

DCD DCE->DTE DC DETECTED

DTR DTE->DCE DTE IS READY

RI DCE->DTE RING INDICATION

信号的标注是从DTE设备的角度出发的，TD、DTR和RTS信号是由DTE产生的，RD、DSR、CTS、DCD和RI信号是由DCE产生的。接地信号是所有连接都公共的，在Yost的标准中接地信号外部有两个管脚事实上是同一个信号。如果两个通信设备的距离相差的很远或者是有两个不同的供电系统供电，那么地信号在两个设备间会不一样，从而导致通信失败，跟踪描述这样的情形是很困难的。

******* 设置

串行通信在软件设置里需要做多项设置，最常见的设置包括[[/wiki/%E6%B3%A2%E7%89%B9%E7%8E%87][波特率]]（Baud）、奇偶校验（Parity
Check）和停止位（Stop Bit）。

-  波特率（又称[[/wiki/%E9%AE%91%E7%8E%87][鮑率]]）：是指从一设备发到另一设备的波特率，即每秒钟多少符號。典型的波特率是300,
   1200, 2400, 9600, 19200,
   115200等。一般通信两端设备都要设为相同的波特率，但有些设备也可设置为自动检测波特率。

-  奇偶校验（Parity：是用来验证数据的正确性。奇偶校验一般不使用，如果使用，那么既可以做奇校验（Odd
   Parity）也可以做偶校验（Even
   Parity）。奇偶校验是通过修改每一发送字节（也可以限制发送的字节）来工作的。如果不作奇偶校验，那么数据是不会被改变的。在偶校验中，因为奇偶校验位会被相应的置1或0（一般是最高位或最低位），所以数据会被改变以使得所有传送的数位（含字符的各数位和校验位）中“1”的个数为偶数；在奇校验中，所有传送的数位（含字符的各数位和校验位）中“1”的个数为奇数。奇偶校验可以用于接受方检查传输是否发送生错误------如果某一字节中“1”的个数发生了错误，那么这个字节在传输中一定有错误发生。如果奇偶校验是正确的，那么要么没有发生错误要么发生了偶数个的错误。如果使用者選擇資料長度為8位元，則因為沒有多餘的位元可被用來作為同位元，因此就叫做「非奇偶校验（Non
   Parity）」。

-  停止位：是在每个字节传输之后发送的，它用来帮助接受信号方硬件重同步。

RS-232在傳送資料時，並不需要另外使用一條傳輸線來傳送同步訊號，就能正確
的將資料順利傳送到對方，因此叫做「非同步傳輸」，簡稱UART（Universal
Asynchronous Receiver Transmitter），不過必須在每一筆資料的前後都加上
同步訊號，把同步訊號與資料混和之後，使用同一條傳輸線來傳輸。

在串行通信软件设置中D/P/S是常规的符号表示。8/N/1（非常普遍）表明8bit数
据，没有奇偶校验，1bit停止位。数据位可以设置为5、6、7或者8位元（不可以
大於8或小於5），奇偶校验位可以设置为无（N）、奇（O）或者偶（E），奇偶
校验可以使用数据中的位元（bit），所以8/E/1就表示一共8位数据位，其中一
位用来做奇偶校验位。停止位可以是1、1.5或者2位的（1.5是用在波特率为
60wpm的电传打字机上的）。


-  流量控制：当需要发送[[/wiki/%E6%8F%A1%E6%89%8B%E4%BF%A1%E5%8F%B7][握手信号]]或数据完整性检测时需要制定其他设置。公用的组合有RTS/CTS,
   DTR/DSR或者XON/XOFF（实际中不使用连接器管脚而在数据流内插入特殊字符）。

****** 類似規範

-  [[/wiki/%E5%9B%BD%E9%99%85%E7%94%B5%E4%BF%A1%E8%81%94%E7%9B%9F%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84][ITU-T]]（前CCITT）的對應規範，用語不同，但電氣規格幾乎相同

   -  ITU-T V.28

-  具有相似的通信目的，但功能與電氣規範不同

   -  [[/wiki/RS-422][RS-422]]
   -  [[/w/index.php?title=RS-423&action=edit&redlink=1][RS-423]]
   -  [[/wiki/RS-449][RS-449]]
   -  [[/wiki/RS-485][RS-485]]

****** 外部連結

-  [[http://www.zywyn.com.tw/index.php][RS-232 professional maker (ZYWYN.com）]]
-  [[http://www.camiresearch.com/Data_Com_Basics/RS232_standard.html][RS-232 tutorial]]
-  [[http://www.yost.com/Computers/RJ45-serial/][Yost Serial Device Wiring Standard]]
-  [[http://www.acumeninstruments.com/Support/documentation/SerialPortBasics/index.shtml][Serial Port Basics]]
-  [[http://www.lammertbies.nl/comm/info/RS-232.html][RS232 serial port info]]
-  [[http://www.tronisoft.com/rs232info/ASCII_serial_port_crib_sheets.pdf][Printable ASCII Serial Port Crib Sheets]]

***** RS232

- http://c.biancheng.net/cpp/html/1919.html

标准串口，在物理结构上分为 9 针的和 9 孔的，习惯上我们也称之为公头和母
头

[[/home/ben/Wally/Journal//Figure/scrot/2983mBR.png]]

RS232 接口一共有 9 个引脚，分别定义是：1、载波检测 DCD；2、接收数据
RXD；3、发送数据 TXD；4、数据终端准备好 DTR；5、信号地线 SG；6、数据准
备好 DSR；7、请求发送 RTS；8、清除发送 CTS；9、振铃提示 RI。我们要让这
个串口和我们单片机进行通信，我们只需要关心其中的 2 脚 RXD、3 脚 TXD 和
5 脚 GND 即可。

虽然这三个引脚的名字和我们单片机上的串口名字一样，但是却不能直接和单片
机对连通信，这是为什么呢？随着我们了解的内容越来越多，我们得慢慢知道，
不是所有的电路都是 5V 代表高电平而 0V 代表低电平的。对于 RS232 标准来
说，它是个反逻辑，也叫做负逻辑。为何叫负逻辑？它的 TXD 和 RXD 的电
压，-3V～-15V 电压代表是 1，+3～+15V 电压代表是 0。低电平代表的是 1，
而高电平代表的是 0，所以称之为负逻辑。因此电脑的 9 针 RS232串口是不能
和单片机直接连接的，需要用一个电平转换芯片 MAX232 来完成.

[[/home/ben/Wally/Journal//Figure/scrot/2983zLX.png]]

 RS232 串口和 UART 串口，它们的协议类型是一样的，只是电平标准不同而已，
 而 MAX232 这个芯片起到的就是中间人的作用，它把 UART 电平转换成 RS232
 电平，也把 RS232 电平转换成 UART 电平，从而实现标准 RS232接口和单片机
 UART 之间的通信连接。

***** RS485                                                       :rs485:
****** EIA-485 wiki                                               :wiki:

*EIA-485*（过去叫做*RS-485*或者*RS485*）是隶属于[[/wiki/OSI%E6%A8%A1%E5%9E%8B][OSI模型]][[/wiki/%E7%89%A9%E7%90%86%E5%B1%82][物理层]]的电气特
性规定为2线，[[/wiki/%E5%8D%8A%E9%9B%99%E5%B7%A5][半双工]]，多点通信的标准。它的电气特性和[[/wiki/RS-232][RS-232]]不大一样。用
缆线两端的[[/wiki/%E7%94%B5%E5%8E%8B][电压]]差值来表示传递信号，1极的电压标识为逻辑1，另一段标识为逻
辑0。两端的电压差最小为0.2V以上时有效，任何不大于12V或者不小于－7V的差
值对接受端都被认为是正确的。

EIA-485仅仅规定了接受端和发送端的电气特性。它没有规定或推荐任何数据协
议。EIA-485可以应用于配置便宜的[[/wiki/%E5%B9%BF%E5%9F%9F%E7%BD%91][广域网]]和采用单机发送，多机接受通信链接。
它提供高速的数据通信速率（10m时35[[/w/index.php?title=Bitrate&action=edit&redlink=1][Mbit/s]]；1200m时100[[/w/index.php?title=Bitrate&action=edit&redlink=1][kbit/s]]1200m）。

EIA-485和[[/wiki/EIA-422][EIA-422]]一样使用双绞线进行高电压差分平衡传输，它可以进行大面积
长距离传输（超过4000[[http://zh.wikipedia.org/wiki/%E8%8B%B1%E5%B0%BA][英尺]]，1200米）。

和EIA-422相对照的是，EIA-422采用不可转换的单发送端，EIA-485的发送端需
要设置为发送模式，这使得EIA-485可以使用双线模式实现真正的多点双向通信。

EIA-485推荐使用在点对点网络中，线型、总线型，不能是星型、环型网络。理
想情况下EIA-485需要2个终接电阻，其阻值要求等于传输电缆的特性阻抗。没有
特性阻抗的话，当所有的设备都静止或者没有能量的时候就会产生噪声，而且线
移需要双端的电压差。没有终接电阻的话，会使得较快速的发送端产生多个数据
信号的边缘，这其中的一些是不正确的。之所以不能使用星型或者环型的拓扑结
构是由于这些结构有不必要的反映，过低或者过高的终接电阻可以产生电磁干扰。

EIA-485在使用四线时可以和EIA-422一样实现[[/wiki/%E5%85%A8%E9%9B%99%E5%B7%A5][全双工]]。EIA-485可以实现真正的
多点通信，在许多情况下并没有什么用处。在某些限制条件下，EIA-485和
EIA-422可以实现相互的连接。

******* 比较

下面的表格列出了RS-485的一些特性和引脚的分配以及和[[/wiki/RS-232][RS-232]]的比较：

| EIA-485                    | [[/wiki/RS-232][RS-232]]                    | [[/w/index.php?title=D-subminiature&action=edit&redlink=1][DB-25]] | [[/w/index.php?title=D-subminiature&action=edit&redlink=1][DE-9]] | [[/w/index.php?title=RJ-50&action=edit&redlink=1][RJ-50]] |
|----------------------------+---------------------------+-------+------+-------|
| Common Ground              | Carrier Detect（DCD）     |     8 |    1 |    10 |
| Clear To Send +（CTS+）    | Received Data (RD)        |     3 |    2 |     9 |
| Ready To Send +（RTS+）    | Transmitted Data (TD)     |     2 |    3 |     8 |
| Received Data +（RxD+）    | Data Terminal Ready (DTR) |    20 |    4 |     7 |
| Received Data -（RxD-）    | Common Ground             |     7 |    5 |     6 |
| Clear To Send -（CTS-）    | Data Set Ready (DSR)      |     6 |    6 |     5 |
| Ready To Send -（RTS-）    | Request To Send (RTS)     |     4 |    7 |     4 |
| Transmitted Data +（TxD+） | Clear To Send (CTS)       |     5 |    8 |     3 |
| Transmitted Data -（TxD-） | Ring Indicator (RI)       |    22 |    9 |     2 |

**** Navigator

***** note

1. STM32 主控
2. 模块化： 每一个模块通过 CAN 或 UART 可以发送命令或接收数据
3. 可编程！！！
4. 有内部使用的CAN控制器
5. 使用CAN

***** 需要用它干嘛？

1. 获取编码器数据用于计算位置
2. 发送控制指令
3. 指令的封装？？ ROS how?

***** 暂时没有能力做这件事情。。。。

***** 复制到 Reference 目录下新建的 Product 文件夹下

**** auctex 按键绑定移植到 org 中

C-c C-f 前缀

#+BEGIN_EXAMPLE
  C-a                          \mathcal{ }
  C-b        \textbf{ }         \mathbf{ }
  C-c        \textsc{ }
  C-e          \emph{ }
  C-f        \textsf{ }         \mathsf{ }
  TAB        \textit{ }         \mathit{ }
  RET        \textmd{ }
  C-n    \textnormal{ }     \mathnormal{ }
  C-r        \textrm{ }         \mathrm{ }
  C-s        \textsl{ }         \mathbb{ }
  C-t        \texttt{ }         \mathtt{ }
  C-u        \textup{ }
  C-d  -- delete font
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  ;; (mapc (lambda(key-macro)
  ;;         (define-key org-mode-map (format "\C-cf%s" (car key-macro)) '(insert (cdr key-macro))))
  ;;       '(("i" "\\mathit{}")            ; note: escapte needed
  ;;         ("I" "\\textit{}")
  ;;         ("b" "\\mathbf{}")
  ;;         ("B" "\\textbf{}")))

  (define-key org-mode-map "\C-cfi" '(insert "\\mathbf{}"))
#+END_SRC

1. 不能使用 C-c C-f 作为前缀，因为已经绑定了
2. 不如使用 yasnippet

#+BEGIN_EXAMPLE
# -*- mode: snippet; require-final-newline: nil -*-
# name: mb:latex-mathbf
# key: mb
# binding: direct-keybinding
# --
\mathbf{$0}
#+END_EXAMPLE

**** IMU

project imutb simulation

*** 2016/01/03
**** BBDB: 通讯录管理
***** Reference

- [[http://savannah.nongnu.org/projects/bbdb/][Homepage]]
- [[http://bbdb.sourceforge.net/][Sourceforge(旧的项目主页)]]
- [[http://www.emacswiki.org/emacs/CategoryBbdb][EmacsWiki: Bddb category]]
- [[https://github.com/emacs-china/hello-emacs/blob/master/bbdb%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.org][Github 上的中文教程]]

***** Intro

BBDB is the Insidious =Big Brother Database= for GNU Emacs. It provides
_an address book for email and snail mail addresses, phone numbers and
the like_. It can be linked with various Emacs mail clients (Message
and Mail mode, Rmail, Gnus, MH-E, and VM). BBDB is fully customizable.

#+BEGIN_QUOTE
big brother DB, 用来管理数据的，比如mailing address book等等，和Gnus搭
配着用。Zawinski写的。

BBDB我主要是用来做通讯录管理， 它与gnus发邮件互通， 效果十分好。

BBDB里， 头像支持图片。 然后写一小段lisp代码， 它BBDB的数据转成vCard通
讯录格式， 定期同步到手机上。

#+END_QUOTE
***** 概念

- [[http://baike.baidu.com/link?url=WuKUitPM002pg1xs8GguhXm4nV8pqZcnY47opo6WmnfAz3QmGv3nMdJ3kDst5yP8_dv2pe3sBv7_dkCoopOFmK][vCard]]: 电子名片
- csv：网络交易平台商品信息数据包

***** 安装

1. 源码方式
2. Melpa

   #+BEGIN_EXAMPLE
     I bbdb               20151114.... available  melpa      The Insidious Big Brother Database for GNU Emacs
     I bbdb-android       20150705.... available  melpa      Android phone contacts import/export for BBDB
     I bbdb-china         20150615.... available  melpa      BBDB utils, which let Chinese BBDB users feel easy
     I bbdb-vcard         20150713.... available  melpa      vCard import/export for BBDB
   #+END_EXAMPLE

***** 使用

1. M-x bbdb-xxxx
2. M-x bbdb-vcard-xxx

***** bbdb简单使用教程

#  Github 上使用 org-mode 写的教程，相当不错

****** 配置

最简单的配置方法就是将下面的语句放入Emacs初始化文件中

#+BEGIN_SRC emacs-lisp
  (require 'bbdb)
  (bbdb-initialize)
#+END_SRC

这里的`bbdb-initialize'会初始化bbdb,并开启最基本的查询/维护记录功能.

除了最基本的查询/维护记录功能外,bbdb还有一些与其他package联合使用的特性,要开启这些特性,则需要在调用`bbdb-initialize'时传入其他的参数.

`bbdb-initialize'可以接收一系列的symbol作为参数,这些symbol决定了bbdb初始化时会开启与哪些package交互的特性. 这些symbol的说明如下表所示:
#+NAME: bbdb-initialize参数说明
| symbol  | meaning                                                               |
|---------+-----------------------------------------------------------------------|
| gnus    | Gnus mail/news reader. *should probably also pass the message symbol* |
| mh-e    | MH-E mail reader.                                                     |
| rmail   | Rmail mail reader.                                                    |
| vm      | VM mail reader.                                                       |
| mail    | Mail (M-x mail).                                                      |
| message | Message mode.                                                         |
| anniv   | Anniversaries in Emacs diary.                                         |
| sc      | Supercite.                                                            |
| pgp     | PGP support:                                                          |

******* 为其他package增加BBDB支持
bbdb提供了一系列的`bbdb-insinuate-xxxx'函数来为xxxx package提供BBDB的支持. 这些函数为package增加了默认的快捷键,并且配置这些package当收到新message时,通知bbdb.

例如:为了給gnus增加bbdb的支持,我们可以添加下面的语句到Emacs初始化文件中
#+BEGIN_SRC emacs-lisp
  (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)
#+END_SRC
****** BBDB基础
******* BBDB数据库结构
BBDB数据库由一系列的记录组成,每条记录对应一个联系人或组织. 每条记录由多种域组成,每种域对应联系人/组织的一个属性.

BBDB内置支持一些类型的域:
| type        | Description                              | Notes                                           |
|-------------+------------------------------------------+-------------------------------------------------|
| NAME        | 联系人的名称,若该记录表示一个组织,则为空         | 一条记录只能有一个该类型的域,一个域只能有一个值 |
| orgnization | 联系人所在的组织,可以为空                     | 一条记录只能有一个该类型的域,一个域只能有一个值 |
| AKA         | 联系人的别名                                | 一个域可以有多个值,以逗号分隔                  |
| mail        | 联系人的email地址                           | 一个域可以有多个值,以逗号分隔                  |
| Phone       | 联系人的电话                                | 一条记录可以有多个该类型的域,一个域只能有一个值 |
| address     | 联系人的地址                                | 一条记录可以有多个该类型的域,一个域只能有一个值 |
| Notes       | 其他说明                                   |  一条记录可以有多个该类型的域,一个域只能有一个值 |
******** 自定义类型
除了上面BBDB内置的域类型,我们还可以自定一些域类型. BBDB处理大多数自定义类型的域时,与Notes类型域一样,但是对有一些特殊名称的域类型,BBDB会进行特殊处理:
+ aka :: 用于存储指定记录的non-primary names
+ finger-host :: Address used in place of the listed net address for fingering the entity indicated by the record
+ gnus-score :: Gnus scoring adjustment for this person.
+ mail-alias :: Value used instead of name for completion
+ mail-name ::  Used for the storage of non-default names to be used in the reporting of new mail by Reportmail.
+ mark-char :: The field containing the character to be used for marking a given poster in the Gnus Summary Buffer
+ tex-name :: The value of this field is used in place of the name field when printing the database using bbdb-print
+ www :: This field contains the URL associated with the BBDB record.
******* BBDB相关命令
******** 搜索记录
********* bbdb

执行该命令后,输入一个正则表达式,则bbdb会列出任何域中的值符合该正则表达式的记录

********* bbdb-search-name/bbdb-search-organization/bbdb-search-address/bbdb-search-mail/bbdb-search-notes/bbdb-search-phone

执行该命令后,输入一个正则表达式,则bbdb会列出指定域中的值符合该正则表达式的记录

********* bbdb-timestamp-older

执行该命令后,输入一个`yyyy-mm-dd'格式的日期,则bbdb会列出在指定日期之前修改过的记录

********* bbdb-timestamp-newer

执行该命令后,输入一个`yyyy-mm-dd'格式的日期,则bbdb会列出在指定日期之后修改过的记录

********* bbdb-creation-older

执行该命令后,输入一个`yyyy-mm-dd'格式的日期,则bbdb会列出在指定日期之前创建的记录

********* bbdb-creation-newer

执行该命令后,输入一个`yyyy-mm-dd'格式的日期,则bbdb会列出在指定日期之后创建的记录

********* bbdb-creation-no-change

执行该命令后,bbdb会列出自创建以来,从未修改过的记录

******** 增加记录
********* bbdb-create

执行该命令后,bbdb会以此提示输入各个内置域的相关信息,然后根据这些相关信息新建一条记录

********* bbdb-snarf

该命令可以根据一定规则将选中的字符串转换成bbdb格式的记录. 默认的转换规则由变量`bbdb-snarf-rule-default'决定. 详细参见`bbdb-snarf-rule-alist'

******* BBDB Mode使用说明
使用BBDB的查询命令后,会弹出一个名为`*BBDB*'的buffer,该buffer处于bbdb mode下.

bbdb mode下拥有许多维护BBDB记录的各种命令,常用的命令有:

******** e (bbdb-edit-field)

修改记录中当前域的值

******** ; (bbdb-edit-foo)

若不带前置参数执行该命令,则修改`(car bbdb-edit-foo)'所表示的域(默认为notes)

若代前置参数执行该命令,则修改`(cdr bbdb-edit-foo)'所表示的域(默认为current-fields)

******** d / C-k (bbdb-delete-field-or-record)

删除光标所在的域,若光标所处的域为bbdb记录的第一个行,则会提示删除整个记录.

This may also be applied to multiple records at once by *.

******** i (bbdb-insert-field)

为当前记录添加新域,该新域的类型可以是BBDB的内置类型,也可以是新的用户自定义类型.

******** C-x C-t (bbdb-transpose-fields)

交换光标所在的field与上一行field的位置

若带参数0执行该命令,则光标所在的域与mark标记的域进行交换

With non-zero numeric argument ARG, the previous field is moved past ARG fields.

交换的field必须在同一条记录中,且具有相同的类型

******** n (bbdb-next-record)/ p (bbdb-prev-record)

移动到下一个/上一个记录,若带前缀参数N,则下移/上移N条记录

******** t (bbdb-toggle-records-layout)


切换是否显示记录中具体域的说明.

若带参数0调用该函数,则强制光标所在记录不显示记录域说明,此时,所有的域信息都压缩到一行内显示.

当待其他参数调用该函数时,则强制光标所在记录显示记录中的域说明时,此时,当前记录使用多行样式显示.

若使用`*t'而不是`t',则buffer内所有的记录都同时切换显示样式

******** T (bbdb-display-record-completely)

谢换是否展示当前记录的所有域,这时平时隐藏不显示的`creation-date'和`timestamp'都会显示出来.

******** o (bbdb-omit-record)

隐藏当前记录,但并不会将当前记录从BBDB数据库中删除掉.

若带参数N执行该命令,则会隐藏下面N条记录,N可以为负数

******** m (bbdb-mail)

发送电子邮件給当前的联系人. 默认邮件地址为记录中的第一个email地址.

若带参数N调用该函数,则表示邮件地址使用记录周公的第N个email地址

若使用`*m'而不是`m',则表示給该buffer中的所有联系人发送电子邮件

******** s /C-x C-s (bbdb-save)

保存BBDB数据库到文件中

******** M-d (bbdb-dial)

该命令会尝试着去拨打光标所在的数字. 若光标处于一条记录的开头,则会拨打第一个phone域.

具体原理不明...

******** q (quit-window)

退出bbdb窗口,但不会kill bbdb buffer

******** ? (bbdb-help)

在minibuffer中显示简易帮助信息

******** h (bbdb-info)

显示bbdb的info文档

若bbdb的info文档没有安装在标准的info目录下,可以通过设置`bbdb-info-file'变量来明确指明bbdb info文件的路径

******** (bbdb-print)

将BBDB记录导出到Tex文件中.

******** c (bbdb-create)

创建新记录保存新的联系人信息

******** C (bbdb-copy-records-as-kill)

将当前记录拷贝到kill ring中

若使用`* C'则拷贝buffer中的所有记录到kill ring中

******** b (bbdb)

重新查询bbdb数据库

******** / m (bbdb-search-mail)

搜索mail域

******** / a (bbdb-search-address)

搜索address域

******** / c (bbdb-search-changed)

搜索至上次保存后,改变过的bbdb记录

******** / d (bbdb-search-duplicates)

搜索具有相同域的记录

******** / n (bbdb-search-name)

搜索name域

******** / o (bbdb-search-organization)

搜索organization域

******** / p (bbdb-search-phone)

搜索phone域

******** / x (bbdb-search-xfields)

搜索xfield域(该域存什么?我也不知道...)

******** * (bbdb-do-all-records)

该命令用于修改紧接之后的命令的作用域,让其作用于buffer中的所有记录.(Command prefix for operating on all records currently displayed.)

但只对某些特定的命令有效

****** 配置

******* 配置项
+ bbdb-file

  bbdb数据库的存储路径,默认为`~/.bbdb'

+ bbdb-default-area-code

  当输入新电话好吗时,使用的默认区号.

  该变量的值也会影响到拨打电话时的行为

+ bbdb-address-format-list

  用于编辑/显示BBDB地址信息时的规则列表.

+ bbdb-continental-postcode-regexp

  该正则表达式决定了BBDB的address是否为欧洲格式的地址.

  若address域的值匹配该正则表达式,则表示该address为欧洲格式的地址,否则认为是美国格式的地址

+ bbdb-case-fold-search

  当使用bbdb系列的搜索命令进行搜索时,是否大小写敏感

+ bbdb-auto-revert

  若在Emacs中没有修改bbdb buffer中的信息,而此时,bbdb-file发生了改变,则自动重新加载bbdb-file的新内容

+ bbdb-pop-up-layout

  pop-up BBDB buffer时使用的默认布局(mail,news...). 默认为'pop-up-multi-line

+ bbdb-pop-up-window-size

  pop-up BBDB buffer时的高度.

  若为整数N,则表示高度为N行

  若为一个介于0到1之间的小数N,则拆分拥有最高高度的window,并且BBDB buffer占据N倍的高度

  若为t,则表示使用 `display-buffer'/`pop-to-buffer' 创建BBDB window??(貌似会占据next-window来显示BBDB buffer)

+ bbdb-completion-list

  控制`bbdb-complete-mail'的补全方式. 该函数用于在mail buffer中补全联系人信息

  该值可以为一个symbol list,用来指明补全哪些域的值. 这些symbol可以是:

  - fl-name :: first and last name

  - lf-name :: last and first name

  - organization ::

  - aka ::

  - mail :: all email address of each record

  - primary :: first email address of each record

  该值也可以为t,表示所有上面symbol的集合

  若该值为nil,则表示不提供补全

+ bbdb-complete-mail-allow-cycling

  当调用`bbdb-complete-mail'补全email地址时,是否允许循环展示补全项

+ bbdb-user-mail-address

  该变量的值为一个正则表达式,该正则表达式用于标识某email地址是否是用户自己的email地址.

  多数BBDB的命令根据变量`bbdb-message-headers'从消息中抽取出发送方和接收方的email地址. 但若发送方的email地址匹配上了`bbdb-user-mail-address-re',则该email地址依然被认为是接收方的email地址.

  改变量的默认值为`(user-login-name)'

+ bbdb-add-mails

  该变量指明了当收到某个联系人从新的email地址发来的消息后,是否增加该新email到联系人信息中.

  可选值有:

  - t :: 自动添加该新的email地址

  - query :: 询问用户是否添加该新的email地址

  - nil :: 忽略新的email地址

  - 数字N :: 在N秒内,BBDB显示该新的email地址,但只在当前session有效

  - 函数fn :: 使用record和新email地址作为参数来调用fn,fn需要返回t,'query,nil或一个数字

  - 正则表达式re :: 若新的email地址符合该正则,则忽略该新的email地址,否则询问用户是否添加该email地址

+ bbdb-new-mails-primary

  为联系人新增email地址时,该新email地址是否作为primary mail address(即该新email地址排在其他email地址的前面).

  可选值为:

  - t :: 让该新增的email地址自动称为primary mail address

  - query :: 询问用户是否作为primary mail address

  - nil :: 不作为primary mail address,会将新email地址放到列表最后面.

  - 函数fn :: 该函数接收两个参数:record和新email地址. 该函数需要返回t,'query或nil

  - 正则表达式re :: 若新email地址匹配该re,则不作为primary mail address,否则询问用户是否作为primary mail address

+ bbdb-ignore-redundant-mails

  当增加新mail地址时,若联系人中的旧mail地址是新mail地址的更一般形式(例如,已有的mail地址为darksun@baz.com,而新mail地址为darksun@foo.baz.com)时,是否覆盖原mail地址.

  可选的值为为:

  - t :: 自动忽略新email地址

  - query :: 询问用户是否忽略新email地址

  - nil :: 使用新email地址,覆盖原email地址

  - 数字N :: 在接下来的N秒内,保留新email地址

  - 函数fn :: fn接收两个参数:record及新email地址,fn需要返回t,'query,nil或数字

  - 正则表达式re :: 符合该正则表达式的email地址会替代原email地址,否则询问用户是否忽略新email地址

+ bbdb-check-auto-save-file

  若值为t,则BBDB会检查它的auto-save file,若auto-save file比`bbdb-file'要新,则BBDB会恢复auto-save file

+ bbdb-ignore-message-alist

  描述哪些message不允许触发自动新建BBDB联系人记录.

+ bbdb-accept-message-alist

  描述哪些message允许触发自动新建BBDB联系人记录.

+ bbdb-mua-auto-update-p

  决定了`bbdb-mua-auto-update'如何自动更新BBDB记录. 可选值:

  - nil :: 什么也不做

  - search :: 搜索匹配ADDRESS的记录

  - update :: 搜索匹配ADDRESS的记录,如有必要,会更新name和mail域

  - query :: 搜索匹配ADDRESS的记录,若记录不存在,提示用户是否创建新记录

  - create :: 搜索匹配ADDRESS的记录,若记录不存在,则创建新记录

  - t :: 搜索匹配ADDRESS的记录,若记录不存在,则创建新记录

  - 函数fn :: bbdb调用该函数,该函数需要返回nil,search,update,query,create或t

******* hooks

| hook                             | 调用hook的时机                                     | 调用hook时的参数                       | 其他说明                                                          |
|----------------------------------+----------------------------------------------------+----------------------------------------+-------------------------------------------------------------------|
| bbdb-display-hook                | 展示*BBDB* buffer后                                |                                        |                                                                   |
| bbdb-create-hook                 | 在BBDB创建新联系人记录前                           | 新增的record                           | bbdb-change-hook也会被触发                                        |
| bbdb-change-hook                 | *BBDB* buffer发生改变前                            | 修改的record                           |                                                                   |
| bbdb-mode-hook                   | 进入bbdb mode后                                    |                                        |                                                                   |
| bbdb-notice-record-hook          | 当发现message中的email地址包含在某个联系人记录中后 | 包含message中email的联系人记录         | 若某message中包含同一联系人的多个email地址,该hook也只会被触发一次 |
| bbdb-notice-mail-hook            | 当发现message中的email地址包含在某个联系人记录中后 | 包含message中email的联系人记录         | 若某message中包含同一联系人的多个email地址,该hook也会被触发多次   |
| bbdb-after-read-db-hook          | 当`bbdb-file'被读取之后                            |                                        | 当BBDB buffer revert之后还会再次触发该hook                        |
| bbdb-initialize-hook             | BBDB的初始化函数`bbdb-initialize'被调用之后        |                                        |                                                                   |
| bbdb-canonicalize-mail-functioin | 当BBDB notice a message后                          | message中的corresponding email address | 该函数用于对message中的对应email地址作一次转换,转换后的结果才拿来与BBDB中的记录进行对比,或添加入BBDB. 若该函数返回nil,则BBDB认为该message中无email address |

****** 其他
******* 函数
******** (bbdb-display-records records )

在bbdb buffer中显示records中的记录

******** (bbdb-record-field RECORD FIELD)

返回记录中的指定域的值. 域的说明为:
| firstname    | Return the first name of RECORD                   |
| lastname     | Return the last name of RECORD                    |
| name         | Return the full name of RECORD (first name first) |
| name-lf      | Return the full name of RECORD (last name first)  |
| affix        | Return the list of affixes                        |
| organization | Return the list of organizations                  |
| aka          | Return the list of AKAs                           |
| aka-all      | Return the list of AKAs plus mail-akas.           |
| mail         | Return the list of email addresses                |
| mail-aka     | Return the list of name parts in mail addresses   |
| mail-canon   | Return the list of canonical mail addresses.      |
| phone        | Return the list of phone numbers                  |
| address      | Return the list of addresses                      |
| xfields      | Return the list of all xfields                    |
| 其他         | 指定label的xfields                                   |

******** (bbdb-get-records PROMPT)

若在*BBDB* buffer中,则返回光标所在的记录,若在其他buffer中,则询问用户想要返回哪个记录

******** (bbdb-update-records ADDRESS-LIST &optional UPDATE-P SORT)

返回匹配ADDRESS-LIST的BBDB记录列表

其中ADDRESS-LIST是一个由email地址组成的列表


参数UPDATE-P的可选值为:

+ nil :: 使用变量`bbdb/MUA-update-records-p'中的值, 若该值依然为nil,则`bbdb-update-records'返回nil

+ search :: 搜索匹配ADDRESS的记录

+ update :: 搜索匹配ADDRESS的记录,如有必要,会更新name和mail域

+ query :: 搜索匹配ADDRESS的记录,若记录不存在,提示用户是否创建新记录

+ create :: 搜索匹配ADDRESS的记录,若记录不存在,则创建新记录

+ t :: 搜索匹配ADDRESS的记录,若记录不存在,则创建新记录

+ 函数fn :: bbdb调用该函数,该函数需要返回search,update,query,create或t

若参数SORT为非nil,则返回的记录列表中的记录会经过`bbdb-record-lessp'排序;若SORT为nil,则记录的顺序与参数ADDRESS-LIST中的邮件地址的顺序对应.

******** (bbdb-get-mail-aliases)

返回BBDB中使用的mail aliases列表

******** (bbdb-search-read &optional FIELD)

提示用户输入一个正则表达式re,并从BBDB数据库中搜索出指定的FIELD符合该re的记录

******** (bbdb-search RECORDS &optional NAME-RE ORG-RE MAIL-RE XFIELD-RE PHONE-RE ADDRESS-RE)

从RECORDS中搜索出符合指定域的指定正则表达式的记录. 其中

+ NAME-RE匹配FIRST_LAST,LAST_FIRST和AKA域

+ XFIELD-RE匹配xfiled notes域

+ XFIELD-RE也以格式为(LABEL . RE)表示label为xfield的正则表达式,其中若LABEL为`*'则表示任一个xfield

******** (bbdb-display-records-with-layout RECORDS LAYOUT)

使用LAYOUT形式来展示RECORDS,其中LAYOUT参见`bbdb-layout-alist'中的值

******** (bbdb-pop-up-window &optional SELECT HORIZ-P)

******** (bbdb-display-records RECORDS &optional LAYOUT APPEND SELECT HORIZ-P)

使用LAYOUT形式来显示RECORDS

若参数APPEND为非nil,则会在当前已经显示的记录后,再多显示这些RECORDS;若APPEND为nil,则会用RECORDS的显示结果代替已有的显示结果

参数SELECT与参数HORIZ-P的意义参见`bbdb-pop-up-window'

******** (bbdb-display-record RECORD LAYOUT NUMBER)

在当前buffer的光标所在处,插入格式化好的RECORD表示文本.

LAYOUT是`bbdb-layout-alist'中描述的layout符号,若为nil则表示`bbdb-layout'

NUMBER is the number of RECORD among the displayed records.

******** (bbdb-read-record &optional FIRST-AND-LAST)

提示用户输入联系人信息,并创建一个新的BBDB联系人记录.

*但该函数不会将新产生的BBDB记录存入数据库,也不会更新BBDB hashtable*

*该函数会检查新输入的联系人是否和已存在的联系人记录相冲突*

******** (bbdb-read-string PROMPT &optional INIT COLLECTION REQUIRE-MATCH)

读取用户输入的字符串,会取出字符串中的空格和text properties

参数PROMPT为提示说明

参数INIT为预设值,当编辑已存在记录时常用到

参数COLLECTION与REQUIRE-MATCH的意义与`completing-read'中的意义一致

******** (bbdb-record-set-field RECORD FIELD VALUE &optional MERGE CHECK)

设置RECORD中的FIELD域的值为VALUE.

该函数的返回值为VALUE

若参数MERGE为非nil,则将参数VALUE合并到FIELD的当前值中

若参数CHECK为非nil,则会检查FIELD是否能够存储VALUE

*该函数会更新bbdb hashtable,但不会保存RECORD到bbdb数据库中*. 一般使用函数`bbdb-change-record'来保存RECORD到bbdb数据库中.

其中参数FIELD的说明,参见`bbdb-record-field'中的FIELD说明

******** (bbdb-change-record RECORD &optional NEED-TO-SORT NEW)

该函数保存RECORD到BBDB数据库中,若参数RECORD中的值与BBDB数据库中的值相比发生了变化,则该函数返回RECORD,否则该函数返回nil

当RECORD中的联系人名称发生改变,或RECORD为新建的联系人记录时,NEED-TO-SORT参数需要为t

当RECORD为新建的联系人记录时,参数NEW需要为t. 若RECORD为新建联系人记录则该RECORD会自动更新入BBDB hashtable,否则需要手工更新BBDB hashtable

******** (bbdb-current-record &optional FULL)

返回光标所处的RECORD

若参数FULL为非nil,则返回包含RECORD和显示格式(layout)的一个list
#+BEGIN_SRC emacs-lisp
  (bbdb-current-record t)
  ;; ([nil "darksun" nil nil nil (["home" "(+86)15820984397"] ["work" "(0794)6593346"]) nil nil ((creation-date . "2015-03-30 09:46:57 +0000") (timestamp . "2015-03-30 13:17:00 +0000")) ["darksun" "darksun" nil nil "darksun" #<marker at 64 in bbdb>]] multi-line #<marker at 1 in *BBDB*>)
  (bbdb-current-record)
  ;; [nil "darksun" nil nil nil (["home" "(+86)15820984397"] ["work" "(0794)6593346"]) nil nil ((creation-date . "2015-03-30 09:46:57 +0000") (timestamp . "2015-03-30 13:17:00 +0000")) ["darksun" "darksun" nil nil "darksun" #<marker at 64 in bbdb>]]

#+END_SRC

******** (bbdb-current-field)

返回光标所处的当前域
#+BEGIN_SRC emacs-lisp
  (bbdb-current-field)
  ;; (name "darksun")
#+END_SRC

******** bbdb-record-set-xxx系列函数

置record中指定field的值

******* 变量
******** bbdb-records

该变量的值为当前bbdb buffer中的record列表

******** bbdb-search-invert

若值为t,则会反转`bbdb-search'的搜索结果
****** FAQ

******* 如何修改BBDB创建联系人的流程

使用`bbdb-create'新建联系人时,会以此提示你输入一系列的联系人的信息,包括姓名,所属机构,电子邮件,地址,电话,备注. 但若想让BBDB在创建联系人时也提示你输入其他额外的信息该如何作呢?

下面是一个例子,它让`bbdb-create'新建联系人时,还会提示你输入生日信息:
#+BEGIN_SRC emacs-lisp
  (defun bbdb-read-record-advise-function(record)
    "提示存储生日,QQ,微信号"
    (bbdb-record-set-field record 'birthdate
                           (bbdb-read-string "Birthdate (YYYY.MM.DD): "))
    (bbdb-record-set-field record 'QQ
                           (bbdb-read-string "QQ:"))
    (bbdb-record-set-field record 'WeChat
                           (bbdb-read-string "WeChat:"))
    record)

  (advice-add 'bbdb-read-record :filter-return #'bbdb-read-record-advise-function)

#+END_SRC

******* 如何将bbdb中保存的联系人信息导入到手机中

最简单的方法,就是使用"bbdb-to-outlook.el"将bbdb导出为.csv文件. 然后在手机上导入该.csv文件

1. 加载"bbdb-to-outlook.el"
2. 使用`bbdb'显示bbdb联系人信息
3. 键入`O'会运行`bbdb-to-outlook'命令,输入保存的csv文件路径即可.

**** ROS
- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html

**** org-preview-latex-fragment 与 minted 宏包冲突

- http://orgmode.org/worg/org-tutorials/org-latex-preview.html
- http://tex.stackexchange.com/questions/162767/can-not-preview-latex-equation-in-org-mode-dvipng-and-imagemagick-both-failed

#+BEGIN_QUOTE
But if you have set up preview to use the dvipng method, you are in
trouble: that method calls latex directly, the call is hardwired and
it does not use the -shell-escape option. LaTeX refuses to run the
external program that minted used, no DVI file is produced and dvipng
cannot produce a PNG file
#+END_QUOTE

上述问题并没有好的解决方法

*latex preview 要比 minted 使用的多，所以优先考虑前者*

dvipng 没有错误，但不会生成公式图片

imagemagick 产生错误信息，

#+BEGIN_EXAMPLE
(error "PDF file /tmp/orgtex31149_Wk.pdf wasn't produced")
#+END_EXAMPLE

查看 log =/tmp/orgtex12345abc.log=

#+BEGIN_EXAMPLE
l.4 \usepackage
               [utf8]{inputenc}
?
! Emergency stop.
 ...

l.4 \usepackage
               [utf8]{inputenc}
Pass the -shell-escape flag to LaTeX. Refer to the minted.sty documentation for
 more information.
#+END_EXAMPLE




解决方式： 注释掉 org 文件头部包含的 minted 宏包

#+BEGIN_EXAMPLE
#+LATEX_HEADER: \usepackage{minted}
#+END_EXAMPLE

Note:

1. org-toogle-latex-preview
   #+BEGIN_EXAMPLE
     `org-preview-latex-fragment' is an obsolete command (as of 24.4); use `org-toggle-latex-fragment' instead.
   #+END_EXAMPLE
2. imagemagick 产生 A4 的图片，太大了，没有 dvipng 方便

**** Using rosed to edit files in ROS

*Description:* This tutorial shows how to use [[/rosbash][rosed]] to
make editing easier.

***** Using rosed

=rosed= is part of the [[/rosbash][rosbash]] suite. It allows you to
directly edit a file within a package by using the package name rather
than having to type the entire path to the package.

Usage:

#+BEGIN_EXAMPLE
    $ rosed [package_name] [filename]
#+END_EXAMPLE

Example:

#+BEGIN_EXAMPLE
    $ rosed roscpp Logger.msg
#+END_EXAMPLE

This example demonstrates how you would edit the Logger.msg file within
the roscpp package.

If this example doesn't work is probably because you don't have the
=vim= editor installed. Please refer to
[[/ROS/Tutorials/UsingRosEd#Editor][Editor]] section. If you don't know
how to get out of vim, [[http://kb.iu.edu/data/afcz.html][click here]].

If the filename is not uniquely defined within the package, a menu will
prompt you to choose which of the possible files you want to edit.

***** Using rosed with tab completion

This way you can easily see and optionally edit all files from a package
without knowing its exact name.

Usage:

#+BEGIN_EXAMPLE
    $ rosed [package_name] <tab><tab>
#+END_EXAMPLE

Example:

#+BEGIN_EXAMPLE
    $ rosed roscpp <tab><tab>
#+END_EXAMPLE


#+BEGIN_EXAMPLE
  Empty.srv                   package.xml
  GetLoggers.srv              roscpp-msg-extras.cmake
  Logger.msg                  roscpp-msg-paths.cmake
  SetLoggerLevel.srv          roscpp.cmake
  genmsg_cpp.py               roscppConfig-version.cmake
  gensrv_cpp.py               roscppConfig.cmake
  msg_gen.py
#+END_EXAMPLE

***** Editor

The default editor for rosed is =vim=. The more beginner-friendly editor
=nano= is included with the default Ubuntu install. You can use it by
editing your ~/.bashrc file to include:

#+BEGIN_EXAMPLE
    export EDITOR='nano -w'
#+END_EXAMPLE

To set the default editor to =emacs= you can edit your ~/.bashrc file to
include:

#+BEGIN_EXAMPLE
    export EDITOR='emacs -nw'
#+END_EXAMPLE

/*NOTE:*/ /changes in .bashrc will only take effect for new terminals.
Terminals that are already open will not see the new environmental
variable./

Open a new terminal and see if =EDITOR= is defined:

#+BEGIN_EXAMPLE
    $ echo $EDITOR
#+END_EXAMPLE


#+BEGIN_EXAMPLE
    nano -w
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    emacs -nw
#+END_EXAMPLE

**** cdlatex-math-symbol

1. cdlatex-math-symbol
   #+BEGIN_EXAMPLE
     ` runs the command cdlatex-math-symbol, which is an interactive Lisp
     function in `cdlatex.el'.

     It is bound to `, <menu-bar> <Org> <LaTeX> <Insert math symbol>.

     (cdlatex-math-symbol)

     Read a char from keyboard and insert corresponding math char.
     The combinations are defined in `cdlatex-math-symbol-alist'.  If not in a LaTeX
     math environment, you also get a pair of dollars.
   #+END_EXAMPLE

2. cdlatex-math-symbol-alist

   #+BEGIN_EXAMPLE
     cdlatex-math-symbol-alist is a variable defined in `cdlatex.el'.
     Its value is nil

     Documentation:
     Key characters and math symbols for fast access with the prefix key.
     First element is a character, followed by a number of strings attached to
     this key.  When the string contains a question mark, this is where the
     cursor will be positioned after insertion of the string into the buffer.
     See `cdlatex-math-symbol-alist-default' for an example.  Any entry defined
     here will replace the corresponding entry of the default list.  The
     defaults implement 3 levels of symbols so far: Level 1 for greek letters
     and standard symbols, level 2 for variations of level 1, and level 3 for
     functions and opperators.
   #+END_EXAMPLE

3. cdlatex-math-symbol-alist-default

   #+BEGIN_EXAMPLE
     Default for cdlatex-math-symbol-alist.

     Value: ((97
       ("\\alpha"))
      (65
       ("\\forall" "\\aleph"))
      (98
       ("\\beta"))
      (66
       (""))
      (99
       ("" "" "\\cos"))
      (67
       ("" "" "\\arccos"))
      (100
       ("\\delta" "\\partial"))
      (68
       ("\\Delta" "\\nabla"))
      (101
       ("\\epsilon" "\\varepsilon" "\\exp"))
      (69
       ("\\exists" "" "\\ln"))
      (102
       ("\\phi" "\\varphi"))
      (70
       (""))
      (103
       ("\\gamma" "" "\\lg"))
      (71
       ("\\Gamma" "" "10^{?}"))
      (104
       ("\\eta" "\\hbar"))
      (72
       (""))
      (105
       ("\\in" "\\imath"))
      (73
       ("" "\\Im"))
      (106
       ("" "\\jmath"))
      (74
       (""))
      (107
       ("\\kappa"))
      (75
       (""))
      (108
       ("\\lambda" "\\ell" "\\log"))
      (76
       ("\\Lambda"))
      (109
       ("\\mu"))
      (77
       (""))
      (110
       ("\\nu" "" "\\ln"))
      (78
       ("\\nabla" "" "\\exp"))
      (111
       ("\\omega"))
      (79
       ("\\Omega" "\\mho"))
      (112
       ("\\pi" "\\varpi"))
      (80
       ("\\Pi"))
      (113
       ("\\theta" "\\vartheta"))
      (81
       ("\\Theta"))
      (114
       ("\\rho" "\\varrho"))
      (82
       ("" "\\Re"))
      (115
       ("\\sigma" "\\varsigma" "\\sin"))
      (83
       ("\\Sigma" "" "\\arcsin"))
      (116
       ("\\tau" "" "\\tan"))
      (84
       ("" "" "\\arctan"))
      (117
       ("\\upsilon"))
      (85
       ("\\Upsilon"))
      (118
       ("\\vee"))
      (86
       ("\\Phi"))
      (119
       ("\\xi"))
      (87
       ("\\Xi"))
      (120
       ("\\chi"))
      (88
       (""))
      (121
       ("\\psi"))
      (89
       ("\\Psi"))
      (122
       ("\\zeta"))
      (90
       (""))
      (32
       (""))
      (48
       ("\\emptyset"))
      (49
       (""))
      (50
       (""))
      (51
       (""))
      (52
       (""))
      (53
       (""))
      (54
       (""))
      (55
       (""))
      (56
       ("\\infty"))
      (57
       (""))
      (33
       ("\\neg"))
      (64
       (""))
      (35
       (""))
      (36
       (""))
      (37
       (""))
      (94
       ("\\uparrow"))
      (38
       ("\\wedge"))
      (63
       (""))
      (126
       ("\\approx" "\\simeq"))
      (95
       ("\\downarrow"))
      (43
       ("\\cup"))
      (45
       ("\\leftrightarrow" "\\longleftrightarrow"))
      (42
       ("\\times"))
      (47
       ("\\not"))
      (124
       ("\\mapsto" "\\longmapsto"))
      (92
       ("\\setminus"))
      (34
       (""))
      (61
       ("\\Leftrightarrow" "\\Longleftrightarrow"))
      (40
       ("\\langle"))
      (41
       ("\\rangle"))
      (91
       ("\\Leftarrow" "\\Longleftarrow"))
      (93
       ("\\Rightarrow" "\\Longrightarrow"))
      (123
       ("\\subset"))
      (125
       ("\\supset"))
      (60
       ("\\leftarrow" "\\longleftarrow" "\\min"))
      (62
       ("\\rightarrow" "\\longrightarrow" "\\max"))
      (96
       (""))
      (39
       ("\\prime"))
      (46
       ("\\cdot")))
   #+END_EXAMPLE

4. 层次

   + 这个很好用啊

   + 在默认值的基础上修改
     #+BEGIN_EXAMPLE
     (65 ("\\forall" "\\aleph"))
     #+END_EXAMPLE

   + 层次问题
     - 第一层： 希腊字母和标准符号
     - 第二层： 第一层的变种
     - 第三层： 数学函数与操作
     - 第四层： =自定义= (太深了，还是第一层)

*** 2016/01/02
**** Emacs VCF 手机备份文件
**** 整理 Chrome 收藏夹
:LOGBOOK:
CLOCK: [2016-01-02 六 10:53]--[2016-01-02 六 13:05] =>  2:12
:END:

1. 使用 Chrome 书签保存常用网页
2. 书签栏上仅显示常用网址，即每天都需要打开的网页，以及 INBOX 和 INDEX
   两个文件夹
3. INBOX 用于保存有待处理的网页
4. INDEX 用于分类收藏网址
   - ROS： ROS 相关常用网址
   - Google: Google相关网址
   - Cloud： 云存储网址
   - BUAA：校园相关
   - Community: 社区
   - Forum: 论坛
   - Guide：教程
   - Blog：博客
   - Manual：手册
   - Homepage: 项目主页
   - Resource: 资源
   - Github： Github 上的资源
   - Course: 课程
   - Project: 课题相关

**** Can we make a love heart with LaTeX

+
  http://tex.stackexchange.com/questions/139733/can-we-make-a-love-heart-with-latex

[[/home/ben/Wally/Journal//Figure/scrot/2959ite.png]]

**** ROS

- sql http://wiki.ros.org/sql_database
- arbotix_python http://wiki.ros.org/arbotix_python?distro=indigo#Services
- Q&A
  - http://answers.ros.org/question/95486/hector-slam-with-turtlebot-in-gazebo/
  - http://answers.ros.org/question/46004/turtlebothector-slam-possibile-or-not/
- http://wiki.ros.org/hector_turtlebot
- http://wiki.ros.org/hector_turtlebot
- http://www.ros.org/news/2014/12/updated-package-razor-imu-9dof.html

**** 像ROS，图片链接不是完整路径，可以改
**** VirtualBox USB 支持

-  [[http://www.cnblogs.com/ericsun/archive/2013/06/10/3130679.html][在Ubuntu12.04 上为Virtualbox 启用USB 设备支持]]


众所周知,VirtualBox使用宿主机的USB设备需要安装扩展包。根据自己的vbox的
版本，到vbox官网下载对应的扩展包。比如我的vbox 是4.1.12的，对应扩展包
地址是：[[http://download.virtualbox.org/virtualbox/4.1.12/Oracle_VM_VirtualBox_Extension_Pack-4.1.12-77245.vbox-extpack][http://download.virtualbox.org/virtualbox-extpack]]

下载完毕后，在“管理”菜单下的“全局设定”里的“扩展”标签下，加入、启
用即可。

如图：

[[http://static.xiazhengxin.name/img/install_vbox_ext_package.png]]

之后，打开虚拟系统设置，在“USB设备”标签下，勾选上"启用USB控制器"以及
"2.0控制器"增加对USB2.0的支持。

如图：
 [[http://static.xiazhengxin.name/img/enable_USB2_controller.png]]

按说这个时候已经搞定了。可是在USB列表里面却没有任何USB设备。这是为什么
呢？谷歌了一下，找到了一篇文章(具体地址已经无法回忆起来了，囧)，解释了
一下原因。

*原来是vbox 所在的用户组比如要包括当前用户才行。*

查看当前用户名：

#+BEGIN_EXAMPLE
sharl@sharl-laptop:~$ whoami
sharl
#+END_EXAMPLE


查看vbox 所在的组：

#+BEGIN_EXAMPLE
sharl@sharl-laptop:~$ cat /etc/group | grep vbox
vboxusers:x:125:sharl
#+END_EXAMPLE

将当前用户加入vbox组：

#+BEGIN_EXAMPLE
usermod -a -G vboxusers sharl
#+END_EXAMPLE

即可。

此时，重启系统。再次打开虚拟机，果然，USB设备都已经被识别、访问到了。
这些，在“设备”菜单下就可以看到。

如图：

[[http://static.xiazhengxin.name/img/add_USB_device_to_vbox_from_list.png]]

添加后，虚拟机系统果然发现了新硬件，按照一般步骤，安装驱动即可正常使用。

**** Running 64bit Matlab on 32bit host OS

-
  http://neuro.debian.net/blog/2013/2013-05-31_matlab_64bit_on_32bit.html


Note

- Debian 下32位系统使用64位 Matlab, Ubuntu 下不一定能用。
- 不要再 Linux 下折腾 Matlab
- 装系统要装64位的

Some of you have experienced problems due the recent move of Mathworks
to drop 32-bit Linux builds of their products (i.e. Matlab R2013a and
co.). Please note that this is not the first time Mathworks values its
own costs higher than the benefits of a few scientists. In 1998
PowerPC builds for Macs were abandoned, causing a furious reaction of
the community.

Luckily, users of the fresh Debian stable release wheezy (or more
recent variants of Debian and its derivatives) who still need a 32bit
OS on 64bit-capable hardware can take advantage of the new multiarch
support. Multiarch allows for multiple architecturesi to co-exist on a
hardware/kernel that is capable of supporting both (e.g. i386 and
amd64).

Below we describe how you can use multiarch support and in few simple
steps that prepare your existing 32bit user-land for running 64bit
Matlab.

Procedure
1. [2-10 min] Install 64-bit kernel and reboot:

   #+BEGIN_EXAMPLE
   sudo apt-get install linux-image-amd64
   #+END_EXAMPLE

2. [1-3 min] Enable multi-arch support for amd64 architecture:

   #+BEGIN_EXAMPLE
   sudo dpkg --add-architecture amd64
   sudo apt-get update
   #+END_EXAMPLE

3. [1-5 min] Install 64bit libraries (and compilers) needed for
   matlab:
   #+BEGIN_EXAMPLE
     sudo apt-get install libstdc++6:amd64 zlib1g:amd64 libncurses5:amd64 \
     libxp6:amd64 libstdc++6-4.4-dev:amd64 libxt6:amd64 libxmu6:amd64 libxtst6:amd64 \
     g++:amd64 gcc:amd64 binutils:amd64
   #+END_EXAMPLE

Now your 64bit matlab (which you hopefully “registered” with
matlab-support) is ready to run.

**** [[http://lanbing510.info/2014/12/03/Linux-Matlab.html][Linux下Matlab的安装及配置使用]]

1. 从[[http://pan.baidu.com/s/1o6qKdxo#path=%252Fmatlab][这里]]下载Matlab2014的Linux版本及破解文件。

2. 下载完成后将iso文件挂载到Linux进行安装。

   #+BEGIN_EXAMPLE
    sudo mkdir /media/matlab
    mount -o loop [path][filename].iso /media/matlab
    cd /media/matlab
    sudo ./install
   #+END_EXAMPLE

3. 安装过程中使用readme.txt中的序列号。

4. 破解

   1) 安装完成后使用crack下的 license进行激活；

   2) 将crack文件夹下的libmwservices.so copy到 /usr/local/MATLAB/R2014A/bin/glnxa64。

5. 完成安装，命令行下使用sudo matlab即可启动使用。

**** yasnippet elisp code

Emacs-Lisp code can be embedded inside the template, written inside back-quotes (`). The lisp forms are evaluated when the snippet is being expanded. The evaluation is done in the same buffer as the snippet being expanded.

Here's an example for c-mode` to calculate the header file guard
dynamically:

#+BEGIN_EXAMPLE
  #ifndef ${1:_`(upcase (file-name-nondirectory (file-name-sans-extension (buffer-file-name))))`_H_}
  #define $1

  $0

  #endif /* $1 */
#+END_EXAMPLE

**** date

(insert (format-time-string "%y-%m-%d-%H-%M"))16-01-02-16-10

**** TODO org-preview-latex-fragment

$\mathbf{x}=(x, y, \theta)$
