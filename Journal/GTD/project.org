# project.org

* Prime                                                               :prime:
** Thesis

#+INCLUDE: ~/Wally/GraduationProject/Thesis/README.md
#+INCLUDE: ~/Wally/GraduationProject/Thesis/ChangeLog.txt
#+INCLUDE: ~/Wally/GraduationProject/Thesis/literature.org
#+INCLUDE: ~/Wally/GraduationProject/Thesis/julie.org
#+INCLUDE: ~/Wally/GraduationProject/Thesis/thesis.tex
#+INCLUDE: ~/Wally/Project/BUAAthesis

** TAGERILL
*** model
1. joint类型为continuous时，显示wheel与base的transform出错，改成fixed则没
   有问题，why?

   continuous 类型joint需要joint_state_publisher发布
   joint_states(sensor_msgs/JointState)

   开启节点： <node name="joint_state_publisher"
   pkg="joint_state_publisher" type="joint_state_publisher" />

   pub: JointState

2. package: robot_state_publisher node: state_publisher ?
   *robot_state_publisher*

*** move_control
**** TODO kobuki.launch.xml  control部分
+ kobuki.launch.xml  control部分
  #+BEGIN_SRC xml
    <launch>
      <arg name="base"/>
      <arg name="stacks"/>
      <arg name="3d_sensor"/>

      <!-- <arg name="urdf_file" default="$(find xacro)/xacro.py '$(find turtlebot_description)/robots/$(arg base)_$(arg stacks)_$(arg 3d_sensor).urdf.xacro'" /> -->
      <arg name="urdf_file" default="$(find xacro)/xacro.py '$(find turtlebot_description)/robots/kobuki_hexagons_kinect.urdf.xacro'" />
      <param name="robot_description" command="$(arg urdf_file)" />

      <!-- Gazebo model spawner -->
      <node name="spawn_turtlebot_model" pkg="gazebo_ros" type="spawn_model"
            args="$(optenv ROBOT_INITIAL_POSE) -unpause -urdf -param robot_description -model mobile_base"/>

      <!-- Velocity muxer -->
      <node pkg="nodelet" type="nodelet" name="mobile_base_nodelet_manager" args="manager"/>
      <node pkg="nodelet" type="nodelet" name="cmd_vel_mux"
            args="load yocs_cmd_vel_mux/CmdVelMuxNodelet mobile_base_nodelet_manager">
        <param name="yaml_cfg_file" value="$(find turtlebot_bringup)/param/mux.yaml" />
        <remap from="cmd_vel_mux/output" to="mobile_base/commands/velocity"/>
      </node>

      <!-- Bumper/cliff to pointcloud (not working, as it needs sensors/core messages) -->
      <include file="$(find turtlebot_bringup)/launch/includes/kobuki/bumper2pc.launch.xml"/>
    </launch>

  #+END_SRC

+ kobuki gazebo
  #+BEGIN_SRC xml
    <gazebo>
      <plugin name="kobuki_controller" filename="libgazebo_ros_kobuki.so">
        <publish_tf>1</publish_tf>
        <left_wheel_joint_name>wheel_left_joint</left_wheel_joint_name>
        <right_wheel_joint_name>wheel_right_joint</right_wheel_joint_name>
        <wheel_separation>.230</wheel_separation>
        <wheel_diameter>0.070</wheel_diameter>
        <torque>1.0</torque>
        <velocity_command_timeout>0.6</velocity_command_timeout>
        <cliff_sensor_left_name>cliff_sensor_left</cliff_sensor_left_name>
        <cliff_sensor_center_name>cliff_sensor_front</cliff_sensor_center_name>
        <cliff_sensor_right_name>cliff_sensor_right</cliff_sensor_right_name>
        <cliff_detection_threshold>0.04</cliff_detection_threshold>
        <bumper_name>bumpers</bumper_name>
        <imu_name>imu</imu_name>
      </plugin>
    </gazebo>
  #+END_SRC

  - 位置：.ckws/devel/lib/libgazebo_ros_kobuki.so
**** 先研究ros_control, 再琢磨自己写控制lib

*** gmapping
+ turtlebot_gazebo gmapping_demo.launch
  #+BEGIN_SRC xml
  <launch>
    <include file="$(find turtlebot_navigation)/launch/includes/gmapping.launch.xml"/>
  </launch>
  #+END_SRC

+ turtlebot_navigation gmapping.launch.xml
  #+BEGIN_SRC xml
      <launch>
      <arg name="scan_topic"  default="scan" />
      <arg name="base_frame"  default="base_footprint"/>
      <arg name="odom_frame"  default="odom"/>

      <node pkg="gmapping" type="slam_gmapping" name="slam_gmapping" output="screen">
        <param name="base_frame" value="$(arg base_frame)"/>
        <param name="odom_frame" value="$(arg odom_frame)"/>
        <param name="map_update_interval" value="5.0"/>
        <param name="maxUrange" value="6.0"/>
        <param name="maxRange" value="8.0"/>
        <param name="sigma" value="0.05"/>
        <param name="kernelSize" value="1"/>
        <param name="lstep" value="0.05"/>
        <param name="astep" value="0.05"/>
        <param name="iterations" value="5"/>
        <param name="lsigma" value="0.075"/>
        <param name="ogain" value="3.0"/>
        <param name="lskip" value="0"/>
        <param name="minimumScore" value="200"/>
        <param name="srr" value="0.01"/>
        <param name="srt" value="0.02"/>
        <param name="str" value="0.01"/>
        <param name="stt" value="0.02"/>
        <param name="linearUpdate" value="0.5"/>
        <param name="angularUpdate" value="0.436"/>
        <param name="temporalUpdate" value="-1.0"/>
        <param name="resampleThreshold" value="0.5"/>
        <param name="particles" value="80"/>
      <!--
        <param name="xmin" value="-50.0"/>
        <param name="ymin" value="-50.0"/>
        <param name="xmax" value="50.0"/>
        <param name="ymax" value="50.0"/>
      make the starting size small for the benefit of the Android client's memory...
      -->
        <param name="xmin" value="-1.0"/>
        <param name="ymin" value="-1.0"/>
        <param name="xmax" value="1.0"/>
        <param name="ymax" value="1.0"/>

        <param name="delta" value="0.05"/>
        <param name="llsamplerange" value="0.01"/>
        <param name="llsamplestep" value="0.01"/>
        <param name="lasamplerange" value="0.005"/>
        <param name="lasamplestep" value="0.005"/>
        <remap from="scan" to="$(arg scan_topic)"/>
      </node>
    </launch>

  #+END_SRC

*** rviz error

自己配置的rviz不但模型不是平面的，而且不会动

使用别人的，这两个问题同时得到了解决。

原因是没有 Listen tf

*** 增加 pan-and-tilt
*** 关于display.launch

#+BEGIN_SRC xml
  <launch>
          <arg name="model" default="$(find xacro)/xacro.py '$(find tagerill_description)/urdf/tagerill.urdf.xacro'"/>
          <arg name="gui" default="False" />
          <param name="robot_description" command="$(arg model)" />
          <param name="use_gui" value="$(arg gui)"/>
          <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher" />
          <node name="robot_state_publisher" pkg="robot_state_publisher" type="state_publisher" />
          <node name="rviz" pkg="rviz" type="rviz" args="-d $(find tagerill_description)/rviz/urdf.rviz" required="true" />
  </launch>
#+END_SRC

Note1: 有时在其它roslaunch中修改了某些ros param, 可能会使模型加载失败

*** kinect

**** 目标
1. 学会在仿真中使用Kinect
   1) 建立urdf模型，并使用rviz显示出来
   2) 在Gazebo中仿真并与ROS通信
2. 测试 depthimage_to_laserscan 以及 nodelet

*** 新的模型 *Holonomic*
**** ROS answer: Holonomic mobile base using Gazebo
+
  http://answers.ros.org/question/30629/holonomic-mobile-base-using-gazebo/


The base platform containing of four wheels, each wheel has 2 degrees
of freedom. It is a holonomic wheel base. There are two motors
connected to each wheel, one is used for steering and the other is
used for driving. The wheel is no deformable planar circle
type. Therefore, each wheel has the capability of steering and driving
independently.


From what I understand, this is the same configuration used by the PR2
and the Care-O-Bot. You can therefore have a look at these packages
for inspiration/reference.

**** PR2 VS Care-O-Bot
Of course,  *PR2*.
****
*** Mecanum

**** how

https://github.com/micpalmia/youbot_ros_tools/issues/5

It's a really interesting simulation issue.

First of all, let's a look at the wheels. They are not standard
wheels, they are mecanum wheels. This kind of wheels help the robot to
move and rotate easily in any directions, even in congested area. The
movement come from the resulting rotation speeds of the wheels, which
are independent. I have found I nice explanation of the relationship
between the wheels rotation and the resulting movement on this lego
page. On the videos, the youBot looks like gliding on the ground.

From a design point of view, this is convenient, because it is similar
to a planar joint + a revolute joint between the base and the
ground. Very easy to control.

From a simulation point of view, it is a nightmare.

I doubt that the repo from youBot or WPI-RAIL did the job, because
they involve casters. And there is no casters on the real KUKA
youBot. If you have a look at their teleop program, you will see that
this program align the wheels before the rotation, which is not the
design of a mecanum wheel at all. With the mesh of the wheels, you
will see it. This not natural (this is also why the wheels solid shape
is a sphere). And even worst, the the rotation is therefore not
supported. So for me, this model is really poor.

I raised the question on Gazebo answers. Someone suggested to use this
planar controller. I considered it as a second choice, but finally,
this is very close to the behavior of the real mecanum wheels, as you
define the x/y velocity and rotation, which can be directly linked to
the wheel individual speeds. I have remove the friction between the
wheels and the ground.

On the real robot, this x/y speed and rotation translation to
individual wheels speeds would also be very convenient.

A visually better solution would be to add the mesh of the wheels, and
rotate them according to the planar messages. No time to work on this.

Finally, if you are looking for a very physical solution, I have found
this link, where it has been done in another simulator, by mixing
kinematics and dynamics solutions.

That would be really great to have more realistic solution. For my
requirement, the planar controller is enough.





*** [pcl::SampleConsensusModelPlane::optimizeModelCoefficients] Not enough inliers found to support a model (0)! Returning the same coefficients.
+
  http://answers.ros.org/question/30909/problem-with-feeding-pointcloud2-messages-from-swissranger-4000-to-octomap-server/


Do you actually need the built-in ground plane filter? For mere map
building there's usually no need and you can set the parameter
~filter_ground to false. By default (in the latest version of
octomap_server), it should be false.

Otherwise you usually need to adjust the PCL plane detection
parameters to your sensor, it is currently tuned to the PR2's stereo
camera by default. Best have a look at the code, not all parameters
are explained on the wiki site in detail.

** wally
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/README.md
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/ChangeLog.org
*** wally stack

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally/package.xml :src xml

*** wally_description
**** package

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_description/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_description/package.xml :src xml

**** wally.xacro

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_description/urdf/wally.xacro :src xml

**** display.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_description/launch/display.launch :src xml

***** 测试 node 标签的 doc 属性，进行文档化工作

#+BEGIN_EXAMPLE
  test $ roslaunch --ros-args wally_description display.launch
  Optional Arguments:
    gui (default "false"): undocumented
    model (default "/opt/ros/indigo/share/xacro/xacro.py /home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/wally.xacro"): undocumented
    xacro (default "/home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/wally.xacro"): xacro文件， default '/home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/wally.xacro'

#+END_EXAMPLE

***** 测试 node 标签中的 required 属性

#+BEGIN_EXAMPLE
  test $ rosnode list
  /joint_state_publisher
  /robot_state_publisher
  /rosout
  /rviz
  test $ rosnode kill rviz
  killing /rviz
  killed
  test $ rosnode list
  /rosout
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  ================================================================================
  REQUIRED process [rviz-3] has died!
  process has finished cleanly
  log file: /home/ben/.ros/log/466aa446-9439-11e5-bfff-002186ef9d91/rviz-3*.log
  Initiating shutdown!
  ================================================================================

#+END_EXAMPLE

***** 测试 display 是否对 hokuyo.xacro [嵌套的层不要太多]

失败，hokuyo.xacro本身不会生成完整的urdf文件，除非指定参数alpha为true
*** wally_bringup

**** package
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_bringup/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_bringup/package.xml :src xml

*** wally_gazebo
**** package

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_gazebo/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_gazebo/package.xml :src xml

**** wally_gazebo.launch
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_gazebo/launch/wally_gazebo.launch :src xml

*** wally_launch
**** package

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/package.xml :src xml

**** nav

***** move_base

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/move_base.launch :src xml

****** TODO configs <参数含义>

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/base_local_planner_params.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/costmap_common_params.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/global_costmap_params.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/local_costmap_params.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/nav_obstacles_params.yaml :src yaml

**** wally.launch
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/wally.launch :src xml
**** gmapping.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/gmapping.launch :src xml

**** sim.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/sim.launch :src xml

**** NEXT filter.launch
- State "NEXT"       from ""           [2016-01-01 五 16:42] \\
  laser_filter 还是存在问题！！!
  先不管它。
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/filter.launch :src xml

**** laser_assembler.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/laser_assembler.launch :src xml

**** hector_mapping.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/hector_mapping.launch :src xml

**** Hector SLAM 的 Map/odom/base_footprint 的配置问题

***** 问题描述

1) odom 由谁发布？
2) map 与 odom 之间的关联

[[/home/ben/Wally/Journal//Figure/scrot/2959IZS.png]]

[[/home/ben/Wally/Journal//Figure/scrot/2959VjY.png]]

***** solution 1

http://wiki.ros.org/hector_slam/Tutorials/SettingUpForYourRobot

The system can also be used without broadcasting any tf
transformation. This can be useful if another node is responsible for
publishing the map->odom or map->base_frame transform.

In this case, the estimated pose published on the poseupdate topic of
hector_mapping might be used for example by a INS system which then
publishes a map->base_frame transform.


#+BEGIN_EXAMPLE
  <arg name="odom_frame" default="odom"/>
  <arg name="pub_map_odom_transform" default="true"/>
#+END_EXAMPLE

***** error

#+BEGIN_EXAMPLE
[ERROR] [1451717998.212424627, 25.216000000]: Transform failed during
publishing of map_odom transform: "odom" passed to lookupTransform
argument target_frame does not exist.

[ERROR] [1451717998.830369203, 25.762000000]: Transform failed during
publishing of map_odom transform: Lookup would require extrapolation
at time 24.721000000, but only time 24.637000000 is in the buffer,
when looking up transform from frame [base_footprint] to frame [odom]
#+END_EXAMPLE

不存在 odom ???


#+BEGIN_EXAMPLE
~ $ rosnode info /hector_mapping
--------------------------------------------------------------------------------
Node [/hector_mapping]
Publications:
 * /map_metadata [nav_msgs/MapMetaData]
 * /slam_cloud [sensor_msgs/PointCloud]
 * /rosout [rosgraph_msgs/Log]
 * /tf [tf2_msgs/TFMessage]
 * /poseupdate [geometry_msgs/PoseWithCovarianceStamped]
 * /map [nav_msgs/OccupancyGrid]
 * /slam_out_pose [geometry_msgs/PoseStamped]

Subscriptions:
 * /syscommand [unknown type]
 * /tf_static [unknown type]
 * /initialpose [unknown type]
 * /tf [tf2_msgs/TFMessage]
 * /lidar_scan [unknown type]

Services:
 * /hector_mapping/set_logger_level
 * /hector_mapping/get_loggers
 * /dynamic_map

#+END_EXAMPLE


也就是说不存在 Odom 坐标系

***** use_sim_time?

Tells ROS nodes asking for time to get the Gazebo-published simulation
time, published over the ROS topic /clock (default true)

#+BEGIN_EXAMPLE
Warning: TF_OLD_DATA ignoring data from the past for frame base_footprint at time 35.174 according to authority unknown_publisher
Possible reasons are listed at http://wiki.ros.org/tf/Errors%20explained
at line 260 in /tmp/buildd/ros-indigo-tf2-0.5.9-0trusty-20150326-1908/
#+END_EXAMPLE

***** 解决 通过 base_stablized 配置

[[/home/ben/Wally/Journal//Figure/scrot/2959AUv.png]]

***** 配合使用 plannar-move 有新的问题

**** gazbo world

- http://jderobot.org/Teaching_robotics_with_jderobot
** Julie

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/README.md
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/ChangeLog.org

*** Thoughts on ROS
+ 不一定非要以源码方式安装package, *只有需要深入研究并借鉴的才使用源码
  安装* -> 精简
*** Problems
**** TODO 编译 gazebo_ros_package 失败
‘Q_WS_WIN’ was not declared in this scope

TODO 暂时不管
*** Stack: Julie
*** Metapackage                                               :metapackage:

[2015-11-24 周2 19:09]

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie/package.xml :src xml :lines "9-"

元包(Metapackage)是一种特殊的包，它不包含任何代码、文件或其它常见的条
目。它仅仅是简单的引用一个或几个相关松散耦合的包。

It is often convenient to group multiple packages as a single logical
package. This can be accomplished through metapackages. A metapackage
is a normal package with the following export tag in the package.xml:
*<metapackage />*

#+begin_latex
\begin{minted}[frame=single, mathescape]{xml}
 <export>
   <metapackage />
 </export>
\end{minted}
#+end_latex

Other than a required <buildtool_depends> dependency on catkin,
metapackages can only have run dependencies on packages of which they
group.

Additionally a metapackage has a required, boilerplate CMakeLists.txt
file: *catkin_metapackage()*

#+begin_latex
\begin{minted}[frame=single, mathescape]{xml}
cmake_minimum_required(VERSION 2.8.3)
project(<PACKAGE_NAME>)
find_package(catkin REQUIRED)
catkin_metapackage()
\end{minted}
#+end_latex
Note: replace <PACKAGE_NAME> with the name of the metapackage.

boilerplate: 样板，所谓样板，是指一尘不变，使用catkin_create_package命
令生成的CMakeLists.txt文件会有 *多余* 的配置，导致编译时失败。

/This workspace contains non-catkin packages in it, and catkin cannot build  a non-homogeneous workspace without isolation.  Try the 'catkin_make_isolated' command instead./

*** julie_bringup

*** julie_description
CLOCK: [2015-11-25 三 14:39]--[2015-11-25 三 14:49] =>  0:10

**** package management
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/package.xml :src xml
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/CMakeLists.txt :src cmake


***** 手记                                                       :catkin:
使用 catkin_create_pkgs 命令生成的 package 配置文件中除基本信息外，添
加了以下信息

1. package.xml 中的 *find_package()*
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{cmake}
       find_package(catkin REQUIRED COMPONENTS
         tf
         urdf
       )
     \end{minted}
   #+end_latex
2. CMakeLists.txt 中的 *<build_depend>* 和 *<run_depend>*
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
     <build_depend>urdf</build_depend>
     <run_depend>urdf</run_depend>
     \end{minted}
   #+end_latex


#+BEGIN_EXAMPLE
  tmp $ catkin_create_pkg test urdf tf
  Created file test/package.xml
  Created file test/CMakeLists.txt
  Successfully created files in /tmp/test. Please adjust the values in package.xml.
  tmp $ ls test
  CMakeLists.txt  package.xml
  tmp $ cat test/CMakeLists.txt | grep urdf
    urdf
  #  CATKIN_DEPENDS tf urdf
  tmp $ cat test/package.xml | grep urdf
    <build_depend>urdf</build_depend>
    <run_depend>urdf</run_depend>

#+END_EXAMPLE

**** urdf

#+BEGIN_SRC sh :results output :exports both
ls -l ~/Wally/Project/catkin_ws/src/julie/julie_description
#+END_SRC

#+RESULTS:
: 总用量 24
: -rw-rw-r-- 1 ben ben  111 11月 25 14:34 CMakeLists.txt
: drwxrwxr-x 2 ben ben 4096 11月 27 16:44 launch
: drwxrwxr-x 2 ben ben 4096 11月 27 16:46 meshes
: -rw-rw-r-- 1 ben ben  435 11月 25 14:20 package.xml
: drwxrwxr-x 2 ben ben 4096 11月 26 19:59 test
: drwxrwxr-x 2 ben ben 4096 11月 26 22:41 urdf

***** emacs auto-mode-alist
#+begin_latex
\begin{minted}[frame=single, mathescape]{lisp}
(add-to-list 'auto-mode-alist '("\\.xacro\\'" . nxml-mode))
(add-to-list 'auto-mode-alist '("\\.urdf\\'" . nxml-mode))
\end{minted}
#+end_latex

***** common_properties.xacro

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/urdf/common_properties.xacro :src xml


***** hokuyo.xacro
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/urdf/hokuyo.xacro :src xml


****** Trick 增加test文件夹用于测试，内部文件使用链接形式        :trick:

****** test
*$ rosrun xacro xacro.py test/hokuyo.xacro alpha:=true -o hokuyo.urdf*

+ 传递命令行参数
+ -o 指定输出文件名

*$ check_urdf hokuyo.urdf*

#+BEGIN_EXAMPLE
  robot name is: sensor_hokuyo
  ---------- Successfully Parsed XML ---------------
  root Link: base_link has 1 child(ren)
      child(1):  hokuyo_link_link
#+END_EXAMPLE

****** TODO 中文注释问题
UnicodeEncodeError: 'ascii' codec can't encode characters in position
464-471: ordinal not in range(128)

xacro.py 文件编码没有问题，

-> 那问题就是 *XML编码* ？

好的推断，但不对！

Pyhont 中 file.write() 方法的编码问题， /暂时解决不了/

*XML文件要有必要的注释，所以暂时使用英文注释*



****** error
1. xacro.XacroException: Property wasn't defined: u'_parent'

   property 使用 property定义， arg传递的是命令行参量(xacro.py)。

2. xacro.XacroException: Property parent recursively used

   macro中使用的参数名称不能与已经定义的property相同

***** microstrain.xacro

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/urdf/microstrain.xacro :src xml

类似 hokuyo.acro

***** TODO julie.xacro

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/urdf/julie.xacro :src xml

#+BEGIN_EXAMPLE
  $ check_urdf julie.urdf
  robot name is: julie
  ---------- Successfully Parsed XML ---------------
  root Link: base_footprint has 1 child(ren)
      child(1):  base_link
          child(1):  imu_link
          child(2):  lidar_link
#+END_EXAMPLE

**** launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/launch/display.launch :src xml

*** julie_gazebo
**** note

*ROS Jade is using the gazebo-5.x series* Jade有更多的特性，可以尝试。

**** gazebo_world
***** empty_world.launch
****** launch
#+include: ~/Wally/Project/catkin_ws/src/julie/julie_gazebo/launch/empty_world.launch :src xml

#+BEGIN_EXAMPLE
  julie_gazebo $ roslaunch gazebo_ros
  empty_world.launch         shapes_world.launch
  mud_world.launch           willowgarage_world.launch
  rubble_world.launch
#+END_EXAMPLE

****** gazebo_ros args
******* gzserver 命令行选项
*$ gzserver --help*

#+BEGIN_EXAMPLE
gzserver -- Run the Gazebo server.

`gzserver` [options] <world_file>

Gazebo server runs simulation and handles commandline options, starts
a Master, runs World update and sensor generation loops.


Options:
  -q [ --quiet ]                Reduce output to stdout.
  -h [ --help ]                 Produce this help message.
  -u [ --pause ]                Start the server in a paused state.
  -e [ --physics ] arg          Specify a physics engine
                                (ode|bullet|dart|simbody).
  -p [ --play ] arg             Play a log file.
  -r [ --record ]               Record state data.
  --record_encoding arg (=zlib) Compression encoding format for log data
                                (zlib|bz2|txt).
  --record_path arg             Absolute path in which to store state data
  --seed arg                    Start with a given random number seed.
  --iters arg                   Number of iterations to simulate.
  --minimal_comms               Reduce the messages output by gzserver
  -s [ --server-plugin ] arg    Load a plugin.
#+END_EXAMPLE

******* gazebo_ros 结点

$ rosrun gazebo_ros

#+BEGIN_EXAMPLE
debug        gdbrun       gzserver     spawn_model
gazebo       gzclient     perf
#+END_EXAMPLE

******* empty_world.launch 命令行参数含义

1. gui: *gzclient*

   Launch the user interface window of Gazebo (default true)

2. paused: gzserve -u

   Start Gazebo in a paused state (default false)
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
       <arg unless="$(arg paused)" name="command_arg1" value=""/>
       <arg     if="$(arg paused)" name="command_arg1" value="-u"/>
     \end{minted}
   #+end_latex

3. headless: gzserver -r

   Disable any function calls to simulator rendering (Ogre)
   components. Does not work with gui:=true (default false)

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
       <arg     if="$(arg headless)" name="command_arg2" value="-r"/>
       <arg unless="$(arg verbose)" name="command_arg3" value=""/>
     \end{minted}
   #+end_latex

4. debug: gzserver/debug

   Start gzserver (Gazebo Server) in debug mode using gdb (default
   false)

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
       <arg unless="$(arg debug)" name="script_type" value="gzserver"/>
       <arg     if="$(arg debug)" name="script_type" value="debug"/>
     \end{minted}
   #+end_latex

5. verbose: gzserve --verbose

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
       <arg unless="$(arg verbose)" name="command_arg3" value=""/>
       <arg     if="$(arg verbose)" name="command_arg3" value="--verbose"/>
     \end{minted}
   #+end_latex

6. usesimtime(gazebo)

   Tells ROS nodes asking for time to get the Gazebo-published
   simulation time, published over the ROS topic /clock (default true)

7. respawn: roslaunch node arguments

8. output: roslaunch node arguments

****** $GAZEBO_RESOURCE_PATH
#+BEGIN_SRC sh :results output :exports both
echo $GAZEBO_RESOURCE_PATH
#+END_SRC

#+RESULTS:
:

+ ~/.gazebo
+ /usr/share/gazebo-2.2/

****** empty.world

#+INCLUDE: /usr/share/gazebo-2.2/worlds/empty.world

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_gazebo/worlds/empty.world

****** 小结

理清了通过gazebo_ros启动Gazebo的最基本的launch。

***** julie_world.launch
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_gazebo/launch/julie_gazebo.launch :src xml

****** spawn_model arguments

~ $ *rosrun gazebo_ros spawn_model -h*

#+BEGIN_EXAMPLE
  spawn_model script started
  Commands:
      -[urdf|sdf|trimesh|gazebo] - specify incoming xml is urdf, sdf or trimesh format. gazebo arg is deprecated in ROS Hydro
      -[file|param|database] [<file_name>|<param_name>|<model_name>] - source of the model xml or the trimesh file
      -model <model_name> - name of the model to be spawned.
      -reference_frame <entity_name> - optinal: name of the model/body where initial pose is defined.
                                       If left empty or specified as "world", gazebo world frame is used.
      -gazebo_namespace <gazebo ros_namespace> - optional: ROS namespace of gazebo offered ROS interfaces.  Defaults to /gazebo/ (e.g. /gazebo/spawn_model).
      -robot_namespace <robot ros_namespace> - optional: change ROS namespace of gazebo-plugins.
      -unpause - optional: !!!Experimental!!! unpause physics after spawning model
      -wait - optional: !!!Experimental!!! wait for model to exist
      -trimesh_mass <mass in kg> - required if -trimesh is used: linear mass
      -trimesh_ixx <moment of inertia in kg*m^2> - required if -trimesh is used: moment of inertia about x-axis
      -trimesh_iyy <moment of inertia in kg*m^2> - required if -trimesh is used: moment of inertia about y-axis
      -trimesh_izz <moment of inertia in kg*m^2> - required if -trimesh is used: moment of inertia about z-axis
      -trimesh_gravity <bool> - required if -trimesh is used: gravity turned on for this trimesh model
      -trimesh_material <material name as a string> - required if -trimesh is used: E.g. Gazebo/Blue
      -trimesh_name <link name as a string> - required if -trimesh is used: name of the link containing the trimesh
      -x <x in meters> - optional: initial pose, use 0 if left out
      -y <y in meters> - optional: initial pose, use 0 if left out
      -z <z in meters> - optional: initial pose, use 0 if left out
      -R <roll in radians> - optional: initial pose, use 0 if left out
      -P <pitch in radians> - optional: initial pose, use 0 if left out
      -Y <yaw in radians> - optional: initial pose, use 0 if left out
      -J <joint_name joint_position> - optional: initialize the specified joint at the specified value
#+END_EXAMPLE

****** $() ${} *不要混淆*

error: ${alpha} is not a 'bool' type

在 launch 文件中， 使用 $() <dollor圆括号> 替换， 仅此一个

在 xacro 文件中， 使用 ${} <dollor花括号> 进行引用属性或者数学运算，使
用 $() 进行命令行参数传递。

****** 文件与文件夹命名要有规范

#+BEGIN_EXAMPLE
  Error [SystemPaths.cc:367] File or path does not exist
  ["/home/ben/Wally/Project/catkin_ws/src/julie/julie_gazebo/world/empty.world"]
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  $ ls ~/.gazebo/ | grep world
  worlds
#+END_EXAMPLE

****** 手记
******* test as a whole: ok

#+BEGIN_EXAMPLE
$ roslaunch julie_gazebo julie_gazebo.launch
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  test $ rosnode list
  /gazebo
  /rosout
  test $ rostopic list
  /clock
  /cmd_vel
  /gazebo/link_states
  /gazebo/model_states
  /gazebo/parameter_descriptions
  /gazebo/parameter_updates
  /gazebo/set_link_state
  /gazebo/set_model_state
  /imu_data
  /lidar_scan
  /odom
  /rosout
  /rosout_agg
  /tf
#+END_EXAMPLE

******* test lidar/imu
******** $() 不允许嵌套

#+begin_latex
\begin{minted}[frame=single, mathescape]{xml}
<param     if="$(arg alpha)" name="robot_description" command="$(arg $(arg sensor}_model)" />
\end{minted}
#+end_latex
error:

*Dollar signs '$' cannot be inside of substitution args [$(arg $(arg
sensor}_model)]*

******** 修改： 组合使用 if/unless/group 实现多重条件

#+begin_latex
  \begin{minted}[frame=single, mathescape]{xml}
    <param unless="$(arg alpha)" name="robot_description" command="$(arg robot_model)" />
    <group     if="$(arg alpha)">
    <param unless="$(arg test)" name="robot_description" command="$(arg imu_model)" />
    <param     if="$(arg test)" name="robot_description" command="$(arg lidar_model)" />
    </group>
  \end{minted}
#+end_latex

******** lidar： ok

#+BEGIN_EXAMPLE
$ roslaunch julie_gazebo julie_gazebo.launch alpha:=true
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  test $ rosnode list
  /gazebo
  /rosout
  test $ rostopic list
  /clock
  /gazebo/link_states
  /gazebo/model_states
  /gazebo/parameter_descriptions
  /gazebo/parameter_updates
  /gazebo/set_link_state
  /gazebo/set_model_state
  /hokuyo_scan
  /rosout
  /rosout_agg
  test $
#+END_EXAMPLE

******** imu: ok,  test参数取名不好

#+BEGIN_EXAMPLE
test $ roslaunch julie_gazebo julie_gazebo.launch alpha:=true test:=false
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  test $ rostopic list
  /clock
  /gazebo/link_states
  /gazebo/model_states
  /gazebo/parameter_descriptions
  /gazebo/parameter_updates
  /gazebo/set_link_state
  /gazebo/set_model_state
  /imu_data
  /rosout
  /rosout_agg
#+END_EXAMPLE

**** gazebo_rviz: 尽量地减少不同模块的耦合

*** julie_launch

julie_launch 主要包含了一些launch文件，主要以下配置文件

|-------------------------+----------------------------+-------------|
| Sensors                 | package                    | node        |
|-------------------------+----------------------------+-------------|
| hokuyo UTM30(Lidar)     | hokuyo_node                | hokuyo_node |
| microstrain 3GMS25(IMU) | microstrain_3dmgx2_imuNode | imu_node    |
|-------------------------+----------------------------+-------------|

#+include: ~/Wally/Project/catkin_ws/src/julie/julie_launch/CMakeLists.txt

#+include: ~/Wally/Project/catkin_ws/src/julie/julie_launch/CMakeLists.txt

**** hokuyo.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/hokuyo.launch :src xml

1. hokuyo connecting
2. hokuyo parameters setting
3. roslaunch if/unless

测试OK。

**** microstrain.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/microstrain.launch :src xml

IMU 有个初始化的过程，需要几秒钟的时间。

***** TODO 姿态似乎并不是很准 why?

1. 传感器输出的是什么数据？
2. ROS用的是什么消息，定义的是什么内容？
3. 如果需要校正，如何处理？

#+BEGIN_EXAMPLE
  header:
    seq: 1956
    stamp:
      secs: 1448536768
      nsecs: 743254578
    frame_id: imu_link
  orientation:
    x: 0.998275596255
    y: -0.0579387949886
    z: -0.00247682392276
    w: 0.00910004910749
  orientation_covariance: [0.0012250000000000002, 0.0, 0.0, 0.0, 0.0012250000000000002, 0.0, 0.0, 0.0, 0.0012250000000000002]
  angular_velocity:
    x: -0.000441648298874
    y: 0.000969532527961
    z: 0.00244149100035
  angular_velocity_covariance: [0.000144, 0.0, 0.0, 0.0, 0.000144, 0.0, 0.0, 0.0, 0.000144]
  linear_acceleration:
    x: -0.049793684483
    y: 0.180994773722
    z: -9.81023545727
  linear_acceleration_covariance: [0.009604000000000001, 0.0, 0.0, 0.0, 0.009604000000000001, 0.0, 0.0, 0.0, 0.009604000000000001]
#+END_EXAMPLE

**** lidar_sim.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/lidar_sim.launch :src xml

**** imu_sim.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/imu_sim.launch :src xml

OK， 证明 rviz.launch 可行

**** rviz.launch

仅可视化激光数据，用于测试传感器或仿真，一般需要被其他launch文件包含。

1. 匿名rviz
2. config arg

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/rviz.launch :src xml

**** hector slam

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/hector.launch :src xml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/hector_with_imu.launch :src xml

1. /map_size/ 的大小会影响实时性，所以不能太大
2. hector_imu_attitude_to_tf 的 /API/ 消息和参数的命名和 /remap/
   [[file:~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/hector_with_imu.launch::<node%20pkg%3D"hector_imu_attitude_to_tf"%20type%3D"imu_attitude_to_tf_node"%20name%3D"imu_attitude_to_tf_node"%20][hector_imu_attitude_to_tf]]

**** map merge

http://answers.ros.org/question/133486/how-can-i-merge-some-maps/

https://github.com/tu-darmstadt-ros-pkg/mapstitch

**** julie.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/julie.launch :src xml

**** sim.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/sim.launch :src xml

[[~/Wally/Journal/Figure/scrot/30792uVs.png]]

**** teleop_key.py

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/scripts/teleop_key.py :src python

发送命令 /cmd_vel 给 plannar_move_plugin

最好在单独一个窗口，因为需要交互。

***** sys, select, termios, tty
#+begin_latex
\begin{minted}[frame=left, mathescape]{py}
import sys, select, termios, tty
\end{minted}
#+end_latex

*优先查阅手册*

****** termios:Low-level terminal control interface.           :termios:

This module provides an interface to the POSIX calls for tty I/O
control.

All functions in this module take a *file descriptor fd* as their first
argument. This can be an integer file descriptor, such as returned by
*sys.stdin.fileno()*, or a file object, such as *sys.stdin* itself.

[[/home/ben/Wally/Journal/Figure/scrot/4904FSb.png]]

******* example
#+INCLUDE: ~/Wally/Journal/Project/Python/termios/test.py :src python

输入密码时不可见

****** tty:Terminal control functions                              :tty:

The *tty* module defines functions for putting the tty into cbreak and
raw modes.

1. what is tty?
2. what is cbreak mode?
3. what is raw mode?

+Because it requires the termios module, it will work only on Unix+

[[/home/ben/Wally/Journal/Figure/scrot/4904TrQ.png]]

****** 终端模式                                                   :term:

终端I/O有两种不同的工作方式：
1. 规范方式输入处理。在这种方式中，终端输入以行为单位进行处理。对于每
   个读要求，终端驱动程序最多返回一行。
2. 非规范方式输入处理。输入字符不以行为单位进行装配。

如果不作特殊处理，则默认方式是规范方式。

V7和BSD类的终端驱动程序支持三种终端输入方式：
+ 精细加工方式(输入装配成行，并对特殊字符进行处理)；
+ 原始方式(输入不装配成行，也不对特殊字符进行处理)；
+ cbreak方式(输入不装配成行，但对某些特殊字符进行处理)。

******* reference

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/3300d5e1-d8a3-48df-8ff1-bc4be441f46d?title=%E7%BB%88%E7%AB%AFI%2FO%20termios%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%20tcsetattr%E8%AE%BE%E7%BD%AE%20-%20dartagnan%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD][CNDS: 终端I/O termios属性设置 tcsetattr]]
****** select: waiting for I/O completion                       :select:

This module provides access to the *select()* and *poll()* functions
available in most operating systems, epoll() available on Linux 2.5+
and kqueue() available on most BSD. Note that on Windows, it only
works for sockets; on other operating systems, it also works for other
file types (in particular, on Unix.

[[/home/ben/Wally/Journal/Figure/scrot/4904tNF.png]]

****** dict
#+begin_latex
  \begin{minted}[frame=left, mathescape]{py}
  moveBindings = {
          'i':(1,0),
          'o':(1,-1),
          'j':(0,1),
          'l':(0,-1),
          'u':(1,1),
          ',':(-1,0),
          '.':(-1,1),
          'm':(-1,-1),
             }

  speedBindings={
          'q':(1.1,1.1),
          'z':(.9,.9),
          'w':(1.1,1),
          'x':(.9,1),
          'e':(1,1.1),
          'c':(1,.9),
            }
  \end{minted}
#+end_latex

****** def get_key()

#+begin_latex
  \begin{minted}[frame=left, mathescape]{py}
  def getKey():
      tty.setraw(sys.stdin.fileno())
      rlist, _, _ = select.select([sys.stdin], [], [], 0.1)
      if rlist:
          key = sys.stdin.read(1)
      else:
          key = ''

      termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
      return key

  speed = 0.75
  turn = 1
  \end{minted}
#+end_latex

1. setraw 设置为原始模式

2. rlist: wait until ready for reading

****** ros related

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{py}
      rospy.init_node('teleop')
      pub = rospy.Publisher('/cmd_vel', Twist, queue_size=5)

      ...

      twist = Twist()
      twist.linear.x = control_speed; twist.linear.y = 0; twist.linear.z = 0
      twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = control_turn
      pub.publish(twist)
  \end{minted}
#+end_latex

****** speed control logic
#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{py}
          while(1):
              key = getKey()
              if key in moveBindings.keys():
                  x = moveBindings[key][0]
                  th = moveBindings[key][1]
                  count = 0
              elif key in speedBindings.keys():
                  speed = speed * speedBindings[key][0]
                  turn = turn * speedBindings[key][1]
                  count = 0

                  print vels(speed,turn)
                  if (status == 14):
                      print msg
                  status = (status + 1) % 15
              elif key == ' ' or key == 'k' :
                  x = 0
                  th = 0
                  control_speed = 0
                  control_turn = 0
              else:
                  count = count + 1
                  if count > 4:
                      x = 0
                      th = 0
                  if (key == '\x03'):
                      break

              target_speed = speed * x
              target_turn = turn * th

              if target_speed > control_speed:
                  control_speed = min( target_speed, control_speed + 0.02 )
              elif target_speed < control_speed:
                  control_speed = max( target_speed, control_speed - 0.02 )
              else:
                  control_speed = target_speed

              if target_turn > control_turn:
                  control_turn = min( target_turn, control_turn + 0.1 )
              elif target_turn < control_turn:
                  control_turn = max( target_turn, control_turn - 0.1 )
              else:
                  control_turn = target_turn

              twist = Twist()
              twist.linear.x = control_speed; twist.linear.y = 0; twist.linear.z = 0
              twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = control_turn
              pub.publish(twist)

  \end{minted}
#+end_latex

****** try

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{py}
    try:
        ...
    except:
        print e
   finally:
        twist = Twist()
        twist.linear.x = 0; twist.linear.y = 0; twist.linear.z = 0
        twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = 0
        pub.publish(twist)
  \end{minted}
#+end_latex

**** bagfile
#+INCLUDE: ~/Wally/Project/catkin_ws/bagfile/

**** rosbag 不是一个包，不能在 launch file中启动

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/bag.launch :src xml

**** DONE laser_filter.launch
- State "DONE"       from "NEXT"       [2015-12-23 三 19:49]
- State "NEXT"       from "NEXT"       [2015-12-23 三 11:04] \\
  曲线比较，订阅并重新发布 scan_filtered
- State "NEXT"       from "NEXT"       [2015-12-23 三 10:28] \\
  - 在 rqt.launch 包含 rviz.lanuch 以及 toggle 参数
  - 更改 scan_filtered 的 frame_id 并 publish static tf from old frame
- State "NEXT"       from "TODO"       [2015-12-23 三 09:53] \\
  同样的配置重新测试可以了，下一步如何动态设置消息的 frame_id，可可视化
  需要
- State "TODO"       from ""           [2015-12-15 二 16:51] \\
  laser_filters 能够运行，接收和发布的话题配置也正确，只是发布的话题为空，
  不知为何

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/laser_filter.launch :src xml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/config/laser_filter.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/scripts/reassign_frame_id.py

- laser_filters 前后 LaserScan 的 frame_id 一致
- laser_filters 的 Node API 中没有 frame_id 选项，也就是说，不能重置 frame_id

**** DONE rqt_launch
- State "DONE"       from ""           [2015-12-21 一 15:56] \\
  在理解了命令行方式之后，使用图形界面方式能够进一步增加开发效率

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/rqt.launch

- perspective import export 的含义,  导出的文件不能像 rviz 那样直接作
  为参数在命令行传递，需要手动导入。新建的 perspective 可以作为参数。
- rviz 不要集成在 rqt 中
- 使用 rqt_bag 需要手动 publish，默认不发布。

[[/home/ben/Wally/Journal//Figure/scrot/29439HuT.png]]

**** NEXT tf_height.cpp
- State "NEXT"       from ""           [2016-01-02 六 16:55] \\
  1. 通过命令行传递高度参数
  2. 通过话题接收超声波传感器数据

The base_footprint frame provides no height information and represents
the 2D pose of the robot (position and orientation). The
base_stabilized frame adds information about the robot height relative
to the map/odom layer.

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/src/tf_height.cpp



*** MultiMachine 连接 raspberry

1. ROS_MASTER_URI

   #+BEGIN_EXAMPLE
   ~ $ export ROS_MASTER_URI=http://192.168.1.3:11311
   #+END_EXAMPLE

2. ROS_IP

   error: /Couldn't find an AF_INET address for .../

   + http://answers.ros.org/question/163556/how-to-solve-couldnt-find-an-af_inet-address-for-problem/

   #+BEGIN_EXAMPLE
   export ROS_IP=10.0.6.9
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
   $ hostname -I
   #+END_EXAMPLE

3. +测试可以，但是延迟似乎过高，是否有影响还有待测试+

   原因可能有
   - raspberry 不够快，查看内在试试
   - wlan 和 eth0 之间通信并不快？？？

** ros_tutorials
*** rospy tutorials
**** talker
**** listener

- spin() simply keeps python from exiting until this node is stopped

** Navigator
*** Navigator Manul
**** 操作注意事项
+ 开机，四伺服处于闭环状态，锁死电机，勿动
+ 每月充电，保证电池性能
+ 载重小于80Kg
**** 特点
Navigator Q2 是四轮 45 度全向轮轮系的机器人平台, 使用航发
公司的 QMA-15 全向轮,与传统轮系相比,能够实现平移、自转、平
移并自转等特殊运动。
**** 性能指标
+ 驱动方式： 四轮独立驱动
+ *悬挂形式：液压阻尼避震器悬挂* ???
+ 负载：80KG
+ 电机类型： *空心杯直流伺服电机*
+ 电机额定功率： 90W
+ 电机编码器： 500线/转，A、B相输出
+ 电机驱动： 伺服驱动器，CAN总线，RS232通信接口
+ 最大移动速度： 1.2m/s
+ 最大自转速度：145°/s
+ 最小转弯半径：0
+ 电池 24V/18.2Ah锂电池

**** 电机驱动器

美国Copley Control公司 *ACJ-055-18* 高性能直流伺服驱动器


#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:21:43
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_10:21:43.png]]

**** 电路硬件

***** 16路超声测距传感器板

***** 电源板

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:28:25
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_10:28:25.png]]

+ 24V
+ 12V
+ 5V


#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:30:33
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_10:30:33.png]]
通信方式
+ CAN总线
+ UART串口，TTL电平

***** 运动控制卡

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:31:21
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_10:31:21.png]]

1. 运动控制方式
   + 步进电机方式？？
   + CAN总线（独立）
   + 串口命令方式

2. 模式
   + 速度模式：接收命令后立即执行，没有后续命令则持续到设置默认时间结
     束
   + 位置模式：先保存到命令队列，收到开始命令后才按顺序执行

***** 主控板
1. *STM32F407VE*
   + 32位
   + ARM Cortex-M4F
   + 168M主频
   + 210MIPS
   + 512K FLASH
   + 196K SRAM
   + LQFP 封装

2. 资源
   + 两个RS232电平UART串口
     - 一个可以直接连接到PC串口
     - 一个以3Pin白端子连接到其他设备
   + 一个TTL电平的UART串口，可以连接其它需要控制端的设备
   + 一个RS485接口
   + 一个TF卡接口，使用SPI总线
   + 一个TFT LCD接口，使用FSMC，带SPI接口，和TF卡接口共用
   + 两路CAN总线接口
   + 8个ADC输入
   + 两个DAC输出
   + 8个PWM输出
   + 一个I2C接口，和PWM2，PWM3复用
   + 标准20针JTAG接口

3. 尺寸：86mm*100mm

***** OFPS定位模块
+ 短时间内对机器人运动轨迹进行辅助定位
+ 三个码盘
+ CAN总线和UART串口
+ STM32F4


#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:52:04
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_10:52:04.png]]

***** Pathfinder遥控器

*** RHF407
**** 处理器
***** 时钟、启动与复位
+ 主时钟： 25M无源晶振
+ 启动方式： BOOT0接地，总是从用户FLASH启动
+ 备份电源：使用可充电纽扣锂电池
+ 复位电路：SP809芯片
  #+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:14:04
  [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_11:14:04.png]]
***** JTAG
JTAG: JTAG254-10x2
#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:25:53
[[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_11:25:53.png]]

***** 电源电路
#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:37:35
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_11:37:35.png]]

+ D1 SS14 反压保护
+ LM1117-3.3稳压
+ FB1/FB2磁珠滤波给模拟电路供电

***** LED 指示灯

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:42:53
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_11:42:53.png]]

使用 *倒灌式* 连接

***** 按键电路

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:43:58
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_11:43:58.png]]

+ 外部上拉
+ 电容滤波
***** RS232串口
*MAX3232*
#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:44:54
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_11:44:54.png]]

+ 2路
+ 一路串口接到DB9孔式插座
+ 一路接到端子插座

***** TTL串口电路

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:07:55
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:07:55.png]]

直接从处理器连接到端子，同时提供3whIO口线作控制用。

***** RS485电路
*SP3485* or *MAX3485* 电平转换
#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:09:54
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:09:54.png]]

JP7的1，2引脚短路时使用终端阻抗匹配电阻

***** CAN总线电路

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:21:32
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:21:32.png]]

驱动芯片 *SN65HBD230*

***** USB

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:22:57
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:22:57.png]]

+ 处理器有两路USB，这是使用全速OTG端口
+ 作为主机时应用不多，仅做从机。

***** TF卡

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:25:02
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:25:02.png]]

TF卡使用SPI总线连接方式，各种信号都外接上拉电阻。

***** LCD

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:26:46
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:26:46.png]]

接口兼容神州王3.2寸TFT模块。

***** ADC

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:28:18
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:28:18.png]]

直接接到处理器口线上，使用时必须保证不能超过处理器的极限条件以损坏处理
器，否则输入前需要添加保护电路。

***** DAC

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:31:02
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:31:02.png]]
处理器线口直接输出，还可以做ADC使用。

***** PWM

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:32:04
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:32:04.png]]

处理器接口直接输出，可以接舵机或其它设备。


**** 开发环境

+ MDK：ARM7, ARM9, 部分Cortex
+ IAR：ARM11, Cortex-A9

+ 基于GNU的：emIDE

**** 芯片

***** AMS1117电源转换
1. Features
   + dropout voltage 1.2v 压差
   + Line regulation 0.2% max
   + Load regulation 0.4% max
   + Current limiting and Thermal Protection
   + Adjustable Output Voltage or Fixed 1.25V, 1.5V, 1.8V, 2.5V, 2.85V, 3.3V, 5V
   + Maxumum Input Voltage 15V


***** STM32F407VE

****** ICP & IAP
1. *in-circuit programming(ICP)*
   + JTAG
   + SWD
   + the boot loader
2. *in-application programming(IAP)* can use any communication
   interface supported by the microcontroller(I/Os, USB, CAN, UART,
   I2C, SPI, etc.) to download data into memory,  With IAP, the Flash
   memory can be reprogrammed while the application is running,
   Nevertheless, part of the application has to have been previously
   programmed in the Flash memory using ICP

****** Glossary
+ The CPU nitegrates two debug ports:
  - *JTAG debug port(JTAG-DP)* provides a 5-pin standard interface
    based on the *Joint Test Action Group(JTAG)* protocal
  - *SWD debug port(SWD-DP)* provides a 2-pin(clock and data)
    interface based on the *Serial Wire Debug* protocal
+ *word*: data/instruction of 32-bit length
+ *Half world*: data/instruction of 16-bit length
+ *Byte*: data of 8-bit length
+ *Double word*: data of 64-bit length
+ *IAP(in-application programming)*: IAP is the ability to reprogram
  the Flash memory of a microcontroller while the user program is running.
+ *ICP(in-circuit programming)*: ICP is the ability to program the
  Flash memory of a microcontroller using the JTAG protocol, the SWD
  protocol or the bootloader while the device is mounted on the user
  application board.
+ *I-Code*: this bus connects the Instruction bus of the CPU core to
  the instruction interface. Prefetch is performed on this bus.
+ *D-Code*: this bus connects the D-Code bus(literal load and debug
  access) of the CPU to the Flash data interface.
+ *OBL*: option byte loader
+ *AHB*: advanced high-preformance bus

*****

*** CAN
*CAN(Controller Area Network)* 控制器局域网

CAN总线是唯一成为国际标准的现场总线，也是国际上应用最为广泛的现场总线
之一。

+ 成本低
+ 传输距离远(<10Km)
+ 传输速率高（1Mb/s）


层： OSI开放系统互连模型

+ 物理介质：双绞线（常用），光纤

+ 信号线： *CAN_H* 和 *CAN_L*
  - 静态时均为2.5V。状态表逻辑1，也称隐形
  - CAN_H(3.5V)比CAN_L(1.5V)高表逻辑0, 称显形

+ 标准CAN的标志符长度为11位，扩展格式可达29位

+

** Tasks

*** TODO Stression
**** Objective

+ [ ] 方阵的一般乘法算法的伪代码和Python实现
+ [ ] 方阵的一般分治
+ [ ] 方阵的Strassen乘法
+ [ ] 将以上算法推广到一般矩阵乘法

**** Notes

+ 优先使用 Python 实现算法，使用 C++ 容易过度关注语言本身的细节
+ 写的代码要有良好的歌读性，

**** 普通方阵乘法：Square-Matrix-Mutltiply(A, B)
***** 伪代码(preudo-code)

#+BEGIN_SRC latex
  \begin{algorithm}[H]
  SQUARE-MATRIX-MULTIPLY(A, B)\;
  n = A.rows\;
  let C be a new nxn matrix\;
  \For{i = 1 \KwTo n}{
    \For{j = 1 \KwTo n}{
      $C_{ij} = 0$
      \For{k = 1 \KwTo n}{
        $C_{ij} = C_{ij} + A_{ik}\cdot{B_{kj}}$
  }
  }
  }
  \Return C
  \end{algorithm}


#+END_SRC

***** Python实现
#+INCLUDE: ~/Wally/Journal/Project/Algorithm/SplitAndonquer/strassen.py :src python

* Project                                                           :proj:

#+include: ~/Wally/Project/README.md
#+include: ~/Wally/Project/ChangeLog.org

** 2D SLAM in Python

#+include: ~/Wally/Project/SLAM2dPython/README.md
#+include: ~/Wally/Project/SLAM2dPython/ChangeLog.txt

*** Unit_A: Robot,  motion model,  scan data
**** Motion model
***** 推导过程

[[~/Wally/Journal/Figure/scrot/154864nG.png]]

#+BEGIN_SRC latex
  \begin{displaymath}
    \left\{
      \begin{array}{l}
        r=\alpha(R+w) \\
        l=\alpha\cdot R
      \end{array}
    \right.
  \end{displaymath}


  \begin{displaymath}
    \left\{
      \begin{array}{l}
        \alpha=\frac{r-l}{w} \\
        R=\frac{l}{\alpha}
      \end{array}
    \right.
  \end{displaymath}
#+END_SRC

[[~/Wally/Journal/Figure/scrot/15486UFV.png]]

#+BEGIN_SRC latex
  \begin{displaymath}
    C=P-(R+\frac{w}{2})\cdot\left[
      \begin{array}{l}
        \sin\theta\\
        -\cos\theta
      \end{array}
    \right]
  \end{displaymath}
  \begin{displaymath}
    P'=C+(R+\frac{w}{2})\cdot\left[
      \begin{array}{l}
        \sin(\theta+\alpha)\\
        -\cos(\theta+\alpha)
      \end{array}
    \right]
  \end{displaymath}
  \begin{displaymath}
    \theta'=(\theta+\pi)\mod 2\pi
  \end{displaymath}
#+END_SRC

***** 问题模型

*Given*:
+ (x, y, \theta)
+ (l, r)
+ w
*For*
($x'$, $y'$, $\theta'$)

***** 求解

1. case 1: $l \ne r$
   1) $\alpha=\frac{r-l}{w}$
   2) $R=\frac{l}{\alpha}$
   3) $\left[\begin{array}{l}cx\\cy\end{array}\right]=\left[\begin{array}{l}x\\y\end{array}\right]-\left(R+\frac{w}{2}\right)\cdot\left[\begin{array}{l}\sin\theta\\-\cos\theta\end{array}\right]$
   4) $\theta'=(\theta+\alpha)\mod 2\pi$
   5) $\left[\begin{array}{l}x'\\y'\end{array}\right]=\left[\begin{array}{l}cx\\cy\end{array}\right]+\left(R+\frac{w}{2}\right)\cdot\left[\begin{array}{l}\sin\theta'\\-\cos\theta'\end{array}\right]$
2. case 2: l=r
   1) $\theta=\theta'$
   2) $x'=x+l\cdot\cos\theta$
   3) $y'=y+l\cdot\sin\theta$

***** 参数

+ w = 150mm
+ 1 tick = 0.349mm

***** 实现

#+BEGIN_SRC python
  from math import sin, cos, pi
  from pylab import *
  from lego_robot import *


  def filter_step(old_pose, motor_ticks):

      # Find out if there is a turn at all
      if motor_ticks[0] == motor_ticks[1]:
          # No turn. Just drive straight
          theta = old_pose[2]
          x = old_pose[0] + motor_ticks[0]*ticks_to_mm*cos(theta)
          y = old_pose[1] + motor_ticks[0]*ticks_to_mm*sin(theta)

          return (x, y, theta)

      else:
          # Turn. Computer alpha, R, etc.
          alpha = (motor_ticks[1]*ticks_to_mm - motor_ticks[0]*ticks_to_mm) \
                  / robot_width
          r = motor_ticks[0] / alpha

          cx = old_pose[0] - (r+robot_width/2)*sin(old_pose[2])
          cy = old_pose[1] + (r+robot_width/2)*cos(old_pose[2])
          theta = (old_pose[2] + alpha) % (2*pi)

          x = cx + (r+robot_width/2)*sin(theta)
          y = cy - (r+robot_width/2)*cos(theta)

          return (x, y, theta)


  if __name__ == '__main__':
      # Empirically derived conversion from ticks to mm
      ticks_to_mm = 0.349

      # Mesured width of the robot(wheel gauge), in mm
      robot_width = 150.0

      # Read data
      logfile = LegoLogfile()
      logfile.read("robot4_motors.txt")

      # start at origin (0,0), looking along x axis (alpha = 0)
      pose = (0.0, 0.0, 0.0)

      # Loop over all motor ticks records generate filtered position list
      filtered = []
      for ticks in logfile.motor_ticks:
          pose = filter_step(pose, ticks)
          filtered.append(pose)

      for pose in filtered:
          print pose
      plot([p[0] for p in filtered], [p[1] for p in filtered], 'bo')
      show()
#+END_SRC

**** Scan data
***** sensor data memory

#+BEGIN_EXAMPLE
S(flag) 315(timestamp) 660(count) 123 124(range data) ....
#+END_EXAMPLE

***** 计算微分

$f'(i)=\frac{f(i+1)-f(i-1)}{2}$

****** 伪代码

#+BEGIN_SRC latex
    \begin{algorithm}[ht]
      \textbf{ComputeDerivative(A, t)}\;

      \KwIn{A=[a1, a2, ... an]: array, t: threshold against outliers}
      \KwOut{D=[d1, d2, ... dn]: derivative at each element}

      D[1]=0 \tcp{头部边界}\;
      \For{{\color{red}{{i = 2 \KwTo A.length-1}}}}{
        \eIf{A[i-1] > t AND A[i+1] > t}{
          D[i]=(A[i+1]-A[i-1])/2
        }{
          D[i] = 0\tcp{异常点}
        }
      }
      D[n]=0\tcp{尾部边界}\;
      \Return{D}
    \end{algorithm}
#+END_SRC

****** python 实现

#+BEGIN_SRC sh
  def compute_derivative(scan, min_dist):
      jumps = [0]
      for i in xrange(1, len(scan)-1):
          l = scan[i-1]
          r = scan[i+1]
          if l > min_dist and r > min_dist:
              derivative = (r - l) / 2.0
              jumps.append(derivative)
          else:
              jumps.append(0)

      jumps.append(0)
      return jumps
#+END_SRC

***** 特征点提取

[[~/Wally/Journal/Figure/scrot/15486z1K.png]]

****** 定义与特征

圆柱
在扫描线上处于波谷中心，在微分曲线上表现为先上升尖后下降尖

****** 问题描述

+ 输入：扫描线
  - 数据结构：数组，每个元素对应一个距离
+ 输出：特征点位置
  - 数据结构：结构数组，每个元素为一个结构，结构中包含一组索引和距离信
    息

****** 算法描述

思想：取扫描线上升沿和下降沿之间的索引和距离数据均值

注意：
1. 特征点的重叠处理
2. 索引整数除法或者说需要取整

****** 伪代码

#+BEGIN_SRC latex
  \begin{algorithm}
    \textbf{FIND-CYLINDERS(scan, jump)}\;
    \KwIn{scan: 扫描线数组，每个元素对应一个距离信息, jump: 微分的跳动阈
      值}
    \KwOut{cylinders: 特征点结构数组，每个元素对应一个包含索引和距离
      的结构}
    oncylinder = FALSE\;
    ray = 0\;
    index = 0\tcp{索引和}
    depth = 0\tcp{距离和}
    cylinders=[]\;
    n = 0\tcp{特征点个数}
    derivate=COMPUTE-DERIVATIVES(scan)\;
    \For{i=1 \KwTo scan.length}{
      \If{derivative[i] < -jump\tcp{下降沿，开始计数}}{
        ray = 0
        index = 0
        depth = 0
        oncylinder = TRUE
      }
      \tcp{注意条件分支结构}
      \eIf{derivate[i] > jump AND oncylinder \tcp{上升沿，结束计数}}{
        n = n+1
        cylinders[i]=struct(index/ray, depth/ray)
      }{
        \If{scan[i] > mindist}{
          ray = ray+1
          index = index+i
          depth = depth+scan[i]
        }
      }
    }
    \Return{cylinders}
  \end{algorithm}
#+END_SRC

****** python实现

#+BEGIN_SRC python
  def find_cylinders(scan, scan_derivative, jump, min_dist):
      cylinder_list = []
      on_cylinder = False
      rays, sum_ray, sum_depth = 0, 0.0, 0.0

      for i in xrange(len(scan_derivative)):
          if scan_derivative[i] < -jump:
              rays, sum_ray, sum_depth = 0, 0.0, 0.0
              on_cylinder = True
          if on_cylinder:
              if scan_derivative[i] > jump:
                  cylinder_list.append((sum_ray/rays, sum_depth/rays))
                  on_cylinder = False
              elif scan[i] > min_dist:
                  rays += 1
                  sum_ray += i
                  sum_depth += scan[i]

      return cylinder_list
#+END_SRC

**** 阅读源码的思考

良好的源码有明确的目标需求和良好的结构层次。

所以阅读源码不应该直接逐行逐句来，遇到不会的地方就查，而是应该
1) 首先，把握目标 *明白程序实现的是什么功能* ， 同时去思考如果自己写，会怎
   么实现
2) 其次，立足整体， *理清楚程序的结构，并找出逻辑*
3) 先总后分， 分而治之，逐步求精， 阅读源码
4) 遇到拦路虎先不去管，只是记下来， *时刻明确自己在做什么* ， 不要顾及
   不重要的细节

**** logfile_viewer.py
***** 功能

1. GUI --> Tkinter
   + 主窗口
     - 传感器坐标(Canvas)
     - 世界坐标系(Canvas)
     - 其它控件
   + 事件响应
     - 加载文件(tkFileDialog)
     - 响应拖动(Scale)

2. 数据可视化
   1) 数据如何存储
   2) 可视化的方法怎样实现

***** 结构

1. 主函数中构建GUI界面
2. LegoLogfile保存并跟踪数据
3. 绘制不同数据使用不同的对象，这些对象有共同的基类（因为方法相似）

***** main

1. legologfile
2. tk & widgets
3. mainloop

***** 基类

1. DrawableObject
   - Trajectory : class
   - ScannerData : class
   - Landmarks : class
   - Points : class
   - Particles : class
2. Methods
   1) background_draw (self)
   2) draw (self,at_step)
      #+begin_latex
        \begin{minted}[frame=single, mathescape]{py}
            def draw(self, at_step):
                print "To be overwritten - will draw a certain point in time:", at_step

            def background_draw(self):
                print "Background draw."
        \end{minted}
      #+end_latex

      - 基类共同的方法为空
      - 默认 __init__方法
   3) get_ellipse_points (center,main_axis_angle,radius1,radius2,start_angle,end_angle)
      #+begin_latex
        \begin{minted}[frame=single, mathescape]{py}
            @staticmethod
            def get_ellipse_points(center, main_axis_angle, radius1, radius2,
                                   start_angle = 0.0, end_angle = 2 * pi):
                """Generate points of an ellipse, for drawing (y axis down)."""
                # ...
                return points
        \end{minted}
      #+end_latex
      - @staticmethod 定义静态方法
      - """""" 三引号函数说明
      - 参数与返回值

***** Trajectory

Trajectory : class
- Parents: DrawableObject
- __init__ (self,points,canvas,world_extents,canvas_extents,standard_deviations,point_size2,background_color,cursor_color,position_stddev_color,theta_stddev_color)
- background_draw (self)
- draw (self,at_step)

*** Unit_B: Landmark assignment, similarity transform,  Icp
- State "TOBECONTINED" from "TODO"       [2015-11-04 三 16:09]

**** simularity simularity
***** 模型
[[~/Wally/Journal/Figure/scrot/329789G.png]]

#+BEGIN_SRC latex
  \begin{displaymath}
    \lambda{}Rl_i+t=r_i
  \end{displaymath}

  $\lambda\in\mathbf{R}$ scale factor
  \[
  R=\left[
    \begin{array}{ll}
      \cos\alpha&-\sin\alpha\\
      \sin\alpha&\cos\alpha
    \end{array}
  \right]\in\mathbf{R}^{2\times{}2}
  \]
  $t=[t_X,t_y]^T\in\mathbf{R}^2$
#+END_SRC

4 parameters

#+begin_src latex
  \begin{displaymath}
    \lambda{}Rl_i+t=r_i
  \end{displaymath}
  \begin{displaymath}
    \sum_{i}\
lambda{}Rl_i+t-r_i\
  \end{displaymath}
#+end_src

Nonlinear -> Linearize and iterate.

***** 变换： compute center

[[~/Wally/Journal/Figure/scrot/3297d1U.png]]

#+begin_src latex
  \begin{displaymath}
    \bar{l}=\frac{1}{m}\sum_{i}l_i
  \end{displaymath}
  \[\bar{r}=\frac{1}{m}\sum_{i}l_i\]
  \[l_i'=l_i-\bar{l}\]
  \[r_i'=r_i-\bar{r}\]
  \[\sum_{i}l_i'=0\]
  \[\sum_i{}r_i'=0\]
#+end_src

#+begin_src latex
  \begin{align*}
    & \lambda{}Rl_i-r_i+t \\
  = & \lambda{}R(l_i'+\bar{l})-(r_i'+\bar{r})+t\\
  = & \lambda{}Rl_i'-r_i'+\underbrace{\lambda{}R\bar{l}-\bar{r}+t}_{t'}\\
  = & \lambda{}Rl_i'-r_i'-t'\rightarrow min
  \end{align*}
#+end_src

#+begin_src latex
  \begin{align}
    & \sum_{i}\|\lambda{}Rl_i'-r_i'+t'\|^2 \\
  = &
      \sum_{i}\|lambda{}Rl_i'-r_i'\|^2+2t'^T\underbrace{\sum_{i}(\lambda{}Rl_i'-r_i')}_{0}+\underbrace{\sum_{i}\|t'\|^2}_{m\cdot\|t'\|^2}
    \\
  = &
      \underbrace{\sum_{i}\|lambda{}Rl_i'-r_i'\|^2}_{\geqslant{}0}+\underbrace{m\cdot\|t'\|^2}_{\geqslant{}0}
      \rightarrow min
  \end{align}
#+end_src

#+begin_src latex
  \begin{eqnarray*}
    t'=0  \\
   \lambda{}R\bar{l}-\bar{r}+t=0 \\
\rightarrow t = \bar{r}-\lambda{}R\bar{l}
  \end{eqnarray*}
#+end_src

#+begin_src latex
  \begin{eqnarray*}
    \sum_{i}\|\lambda{}Rl_i'-r_i'\|^2\rightarrow min \\
    \sum_i\|sqrt{\lambda}Rl_i'-\frac{1}{\sqrt{\lambda}r_i'}\|^2\rightarrow min
  \end{eqnarray*}

  \begin{align*}
    &
      \sum_i\|sqrt{\lambda}Rl_i'-\frac{1}{\sqrt{\lambda}r_i'}\|^2 \\
  = &
      \lambda\underbrace{\sum_{i}\|Rl_i'\|^2}_{\sum_{i}\|l_i'\|^2}-2\sum_{i}r_i'^Tl_i'+\frac{1}{\lambda}\sum_{i}\|r_i'\|^2
    \\
  = & \lambda{}a+b+\frac{1}{\lambda}c\rightarrow min
  \end{align*}

  \begin{eqnarray*}
    \lambda^2=\frac{c}{a}=\frac{\sum_{i}\|r_i'\|^2}{\sum_i{\|l_i'\|^2}}\\
    \lambda=\sqrt{\frac{c}{a}=\frac{\sum_{i}\|r_i'\|^2}{\sum_i{\|l_i'\|^2}}}
  \end{eqnarray*}
#+end_src

#+begin_src latex
    \begin{eqnarray*}
      \sum_{i}r_i'^T\cdot R\cdot l_i' \rightarrow max \\
      \left[
      \begin{array}{ll}
        l_x&r_x
      \end{array}
  \right]\left[
      \begin{array}{ll}
        \cos\alpha & -\sin\alpha \\
        \sin\alpha & \cos\alpha
      \end{array}
      \right]
  \left[
                     \begin{array}{l}
                       l_x\\l_y
                     \end{array}
                     \right] \\
  \left[
      \begin{array}{ll}
        l_x&r_x
      \end{array}
  \right] \left[
      \begin{array}{l}
        l_x\cos\alpha -l_y\sin\alpha \\
        \_x\sin\alpha+l_y\cos\alpha
      \end{array}
      \right]\\
    r_xl_x\cos\alpha-r_xl_y\sin\alpha+r_y\l_x\sin\alpha+r_yl_y\cos\alpha\\
    \cos\alpha(r_xl_x+r_yl_y)+\sin\alpha(-r_xl_y+r_yl_x)
    \end{eqnarray*}

    \begin{align*}
      \sum_{i}r_i'^TRl_i'& = & \cos\alpha\cdot\sum_{i}(r_x'l_x'+r_y'l_y')+
                               \sin\alpha\sum_{i}(-r_x'l_y'+r_y'l_x')
                               \\
   &= &\left[
        \begin{array}{ll}
         \cos\alpha &\sin\alpha
        \end{array}
  \right]\left[
                      \begin{array}{l}
                        \sum_{i}(r_x'l_x'+r_y'l_y')\\
                        \sum_{i}(-r_x'l_y'+r_y'l_x')
                      \end{array}
  \right]
    \end{align*}
    \begin{displaymath}
      \left[
        \begin{array}{l}
          \cos\alpha\\\sin\alpha
        \end{array}
  \right]=\frac{1}{\|\cdot\|}\left[
    \begin{array}{l}
      \sum_{i}(r_x'l_x'+r_y'l_y')\\
      \sum_{i}(-r_x'l_y'+r_y'l_x')
    \end{array}
  \right]
    \end{displaymath}
#+end_src

****** Recipe

+ Given: l_i,  r_i
+ Compute: $\bar{l}=\frac{1}{m}\sum{}l_{i}$,
  $\bar{r}=\frac{1}{m}\sum{}r_{i}$
  $l_{i}'=l_{i}-\bar{l}$, $r_{i}'=r_{i}-\bar{r}$


cs, ss, rr, ll = 0.0
for i in 1...m:
    $cs+=r_{x}'l_{x}'+r_{y}'l_{y'}$
    $ss+=-r_{x}'l_{y}'+r_{y}'l_{x}'$
    $rr+=r_{x}'r_{x}'+r_{y}'r_{y}'$
    $ll+=l_{x}'l_{x}'+l_{y}'l_{y}'$
$\lambda=\sqrt{\frac{rr}{ll}}$

#+begin_src latex
  \begin{displaymath}
    \left[
      \begin{array}{l}
        c\\s
      \end{array}
  \right]=\left[
    \begin{array}{l}
      cs\\ss
    \end{array}
  \right]/\sqrt{cs^2+ss^2}
  \end{displaymath}

  \begin{displaymath}
    \left[
      \begin{array}{l}
        t_x\\t_y
      \end{array}
  \right]=\bar{r}-\lambda{}R\bar{l}=\left[
    \begin{array}{l}
      \bar{r_x}\\\bar{r_y}
    \end{array}
  \right]-\lambda\left[
    \begin{array}{ll}
      c&-s\\s&c
    \end{array}
  \right]\left[
    \begin{array}{l}
      \bar{l_x}\\\bar{l_y}
    \end{array}
  \right]
  \end{displaymath}
  \begin{displaymath}
    (\lambda, c, s, t_x, t_y)
  \end{displaymath}
#+end_src

*** lego_robot.py

1. int & tuple
   #+BEGIN_SRC python
     p = (int(sp[2]), int([sp[3]]))  # position as a tuple'
   #+END_SRC

2. map
   #+BEGIN_SRC python
   map(int, sp[2:])
   #+END_SRC

** toolbox                                                      :bash:style:

#+include: ~/Wally/Project/toolbox/README.md
#+include: ~/Wally/Project/toolbox/ChangeLog.txt

*** DONE Links to pdf
- State "DONE"       from ""           [2015-12-18 五 09:45] \\
  1) wkhtmltopdf 原生支持多个网页，只要在命令行中依次给出 url 即可，用不
     着写这样麻烦劣质的东西
  2) 使用英文注释，不要使用中文注释
  3) 不要在代码中加入无关的东西，注释中不要添加关于语言的用法，这是笔记
     的事情


#+BEGIN_SRC sh
  #! /bin/bash

  ## 功能
  ##    1. 使用wkhtmltopdf将多个网页转换为pdf
  ##    2. 使用gs合并生成的多个PDF
  ##    3. 使用pdfoutline合并的PDF生成目录

  ## 格式： links2pdf index
  ## 输入： index为文件，包含链接和章节信息
  ##       index每行为一个链接
  ##       line: link---chapter---level


  ## version 0.2 --- 添加注释
  ## version 0.3 --- 类似CMake的外部编译，在目录build下进行

  index=$1
  builddir=links2pdf_build
  mkdir $builddir
  cd $builddir
  cp ../$index .

  > outline                       # 利用重定向生成空文件
  declare -i counter=0            # 限制变量counter的属性为整型，counter用于计算章节数
  declare -i page=1               # page用于跟踪页数
  cat $index | while read -r line
  do
      counter=counter+1           # "整型"变量可以直接进行数值计算， 一般变量需要通过$(())

      # ${} 字符串处理
      link=${line%%\ *}           # %去尾，双%匹配最长，即删除尾部与模式匹配的最大子字符串
      level=${line##*\ }          # #支头，双#匹配最长，即删除头部与模式匹配的最大子字符串
      # range=$((len3-len1-len2-2))       # range???  len<N>??? 明显多余
      link_chapter=${line%\ *}    # %去尾，单%匹配最短，即删除尾部与模式匹配的最小子字符串

      # #去头，单#匹配最短，即删除头部与模式匹配的最小子字符串
      # 前提是link中无空格，章节中可能存在空格
      chapter=${link_chapter#*\ }

      # 9是幻数，含义是小于10的章节索引有前缀0，即01,02... 便于gs排序
      if test ${counter} -gt 9    # test 或 [ condition ]
         then
                 wkhtmltopdf --no-outline $link $counter.pdf; # HTML to PDF
                 Pages=$(pdfinfo $counter.pdf | grep Pages);  # $() 或 反引号`` 执行shell命令并c返回
                 num=${Pages##*\ };
      else
          wkhtmltopdf --no-outline $link 0${counter}.pdf;
          Pages=$(pdfinfo 0${counter}.pdf | grep Pages);
          num=${Pages##*\ };
      fi
      echo "$level $page $chapter" >> outline
      page=$((page+num))          # $(()) 数值运算，变量page已经声明为“整型”，也可以不包裹
  done


  # gs
  gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=out.pdf  *.pdf

  # pdfoutline
  pdfoutline out.pdf outline output.pdf

  # 删除文件
  mv output.pdf ..
  cd ..
  rm -rf $builddir

#+END_SRC

*** Track 规范化 standardize file name                     :filename:stdfn:
- State "Track"      from ""           [2015-12-18 五 10:48] \\
  1. 小结
     + 文件命名要有规范，最好不要仅使用下划线连接几个单词，好丑
     + 不要使用中文注释

  2. TODOs
     + 多个路径参数
     + 参数检查
     + 递归遍历
     + 使用正则替换所有除下划线、数字和字母外的所有特殊字符为下划线

#+INCLUDE: ~/Wally/Project/toolbox/src/stdfn.sh

*** convert pptx to pdf in batch                             :ppt:pptx:pdf:

#+INCLUDE: ~/Wally/Project/toolbox/src/pptx2pdf.sh

*** merge PDFs with outline

#+INCLUDE: ~/Wally/Project/toolbox/src/mergepdfs.sh

*** NEXT remove backfile ended with ~ recursively
- State "NEXT"       from ""           [2015-12-20 日 23:03] \\
  not working well. ls may be the problem

#+INCLUDE: ~/Wally/Project/toolbox/src/debackup.sh

*** NEXT project
- State "NEXT"       from "TODO"       [2015-12-21 一 19:17] \\
  写了简单的 project 脚本，仅生成 .projectile, README.md, ChangeLog.txt
  文件和 test 目录
- State "TODO"       from ""           [2015-12-18 五 11:44] \\
  更简洁些，不要多余的功能

#+INCLUDE: ~/Wally/Project/toolbox/src/project.sh

**** project
#+BEGIN_SRC sh
   #! /bin/sh

  # tagerill_update_project.sh

  # version 1.0
  # This is a bash script to initialize a new project of common sense
  # It mainly finishes the following tasks
  # 1. create a new root directory that named by the first arguments
  # 2. create a README file containing information like timestamps,
  #    author, email, license and so on
  # 3. create a .projectile file for the convinence of Projectile to manage it
  #
  # version 1.1
  # add the function of update a project
  #
  # Usage
  # tagerill_new_project.sh <PROJECT> [COMMENT_STR]
  #
  # TODO
  # [ ] select a rule of naming versions & update the version information


  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "error: wrong number of arguments"
      echo "usage: tagerill_new_project.sh <PROJECT> [COMMENT_STR]"
      exit -1
  fi


  project=$1
  comments=""
  if [ $# -eq 3 ]
  then
      comments=$2
  fi

  # update the project
  if [ -d $project ]
  then
     cd $project
     echo >> README
     echo -n "MODIFICATION:" >> README
     date +%Y/%m/%d-%H:%M >> README
     # TODO： 变更版本信息
     if [ $# -eq 3 ]
     then
         echo "COMMENT: $comments" >> README
     fi
     echo "Project: $project updated."
     exit 0
  fi


  # create a new project
  # root workspace
  mkdir $project

  # README
  cd $project
  touch README
  echo "PROJECT: $project" >> README
  echo "VERSION: v1.0"
  echo -n "TIME: " >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "License: GPL v3.0" >> README

  # .projectile
  touch .projectile

  #
  echo "Project: $project has been created"

  exit 0

#+END_SRC

**** cpp

#+BEGIN_SRC sh
  #! /bin/sh

  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "Usage: cpp_pro.sh PROJECT"
      exit 1
  fi

  project=$1
  mkdir $project
  cd $project
  touch README COPYRIGHT TODO Makefile
  mkdir bin src include lib

  # README
  echo PROJECT: $project >> README
  echo -n TIME: >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "LICENSE: GPL v3.0" >> README

  # TODO
  echo [ ] >> TODO
  echo [ ] >> TODO
  echo [ ] >> TODO
#+END_SRC

**** cmake

#+BEGIN_SRC sh
  #! /bin/bash

  # 参数检查
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "usage: cmake_pro.sh PROJECT"
      exit
  fi

  project=$1
  mkdir $project
  cd $project
  # 目录结构
  mkdir src scripts build lib bin doc

  # 根目录下文件
  touch CMakeLists.txt
  echo "CMAKE_MINIMUM_REQUIRED(VERSION 3.2)" >> CMakeLists.txt
  echo "PROJECT($project)" >> CMakeLists.txt
  echo "ADD_SUBDIRECTORY(src bin)" >> CMakeLists.txt
  echo "ADD_SUBDIRECTORY(scripts)" >> CMakeLists.txt

  touch README COPYRIGHT TODO
  echo "PROJECT: $project" >> README
  echo -n "TIME: " >> README
  date +%Y/%M/%d-%H:%m >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README

  # TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO

  # src
  cd src
  touch CMakeLists.txt

  # scripts
  cd ../scripts
  touch CMakeLists.txt
  echo "# INSTALL(PROGRAMS project DESTINATION bin)" >> CMakeLists.txt
#+END_SRC

**** arduino

#+BEGIN_SRC sh
  #! /bin/bash

  # 参数个数检查
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of argument"
      echo "usage: ardpro PROJECT"
      exit
  fi

  project=$1
  mkdir $project                  # 创建目录
  cd $project
  touch README COPYRIGHT TODO Makefile $project.ino

  # README
  echo PROJECT: $project >> README
  echo -n TIME: >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "LICENSE: GPL v3.0" >> README

  # TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO

  # Makefile
  echo "BOARD_TAG = uno" >> Makefile
  echo "ARDUINO_LIBS = " >> Makefile
  echo "MONITOR_PORT = /dev/ttyACM0" >> Makefile
  echo "include /usr/share/arduino/Arduino.mk" >> Makefile
#+END_SRC

**** bash

#+BEGIN_SRC sh
  #! /bin/bash

  # Function: Create a new bash project
  # Usage: bash_pro.sh
  # Input: Project name
  # Output: Name


  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "Usage: bash_pro.sh PROJECT"
      exit
  fi

  project=$1
  mkdir $project
  cd $project
  touch README LICENSE TODO Makefile      # Files
  mkdir scripts bin               # Contents

  # REAMDE
  echo "Project: $project" >> README
  echo -n "Time: " >> README
  date +%Y/%m/%d-%H:%m >> README
  echo "Author: Wally" >> README
  echo "Email: buaaben@163.com" >> README
#+END_SRC

**** CMakelists.txt

#+BEGIN_SRC cmake
  CMAKE_MINIMUM_REQUIRED(VERSION 3.2)
  PROJECT(bash_pro)
  ADD_SUBDIRECTORY(src bin)
  ADD_SUBDIRECTORY(scripts)

  INSTALL(PROGRAMS bash_pro.sh DESTINATION bin)
#+END_SRC
*** TODO routine


#+INCLUDE: ~/Wally/Project/toolbox/src/routine.sh

TODOs
+ [ ] [[file:~/Wally/Project/toolbox/src/routine.sh::path=$1%20#%20path%20need%20to%20be%20absolute][check path]]




#+BEGIN_SRC sh
  #! /bin/sh

  # 执行git, pdf, clean等日常工作
  # 根据时间和地点完成不同的任务

  home=tiger                      # 用户名
  office=ben
  host=`echo $HOSTNAME`
  ws=$HOME/Wally/Journal  # workspace
  emacs_settings_ws="/home/${host}/.emacs.d"


  time=`date +%H`

  cmd=$1

  # if [ $time -gt $line ]                # in the evening
  # then
  #     if [ $host == $office ]   # at office
  #     then
  #       # clean
  #       touch tmpfile
  #       rm `ls . | grep -E "*~$|*.out$|*.log$|*.toc$|*.aux$|^tmpfile$"`
  #       # git push
  #       git add --ignore-removal .
  #       git commit -m "committed automatically by script at $office `date +%H%M`"
  #       git push origin master

  #       # pdf
  #       journal=journal.pdf
  #       if [ -e $journal ]
  #       then
  #           mv journal.pdf "PDFs/`date +%Y%m%d`.pdf"
  #       fi
  #     elif [ $host == $home ]                   # at home
  #     then
  #       # git pull
  #       git pull
  #       git merge origin/master
  #     fi
  # else                          # in the morning
  #     if [ $host == $office ]
  #     then
  #       # git pull
  #       git pull
  #       git merge origin/home
  #     elif [ $host == $home ]
  #     then
  #       # git push
  #       git add --ignore-removal .
  #       git commit -m "committed automatically by script at $home at `date +%H:%M`"
  #       git push origin home
  #     fi
  # fi


  if [ $cmd = "push" ]
  then
      cd $ws
      git add --ignore-removal .
      git commit -m "committed automatically by script at $home at `date +%H:%M`"
      git push origin master

      if [ $host = $office ]
      then
          cd $emacs_settings_ws
          git add settings.org
          git add elpa/yasnippet-20150323.311/snippets/
          git commit -m "committed automatically by script at $home at `date +%H:%M`"
          git push origin master

          thesis_ws="~/Wally/GraduationProject/Thesis"
          cd $thesis_ws
          git add .
          git commit -m "committed automatically by script at $home at `date +%H:%M`"
      fi
  elif [ $cmd = "pull" ]
  then
      cd $ws
      git pull
  fi


  # 命令行参数为密码
  # if [ $# -eq 1 ]
  # then
  #     passwd=$1
  #     python email_evernote.py $passwd
  # fi

  # dict

#+END_SRC

*** TODO email

#+BEGIN_SRC python
  #! /usr/bin/env python
  # -*- encoding:utf-8 -*-

  import smtplib

  from email import encoders
  from email.header import Header
  from email.mime.text import MIMEText
  from email.mime.multipart import MIMEMultipart
  from email.mime.base import MIMEBase
  from email.utils import parseaddr, formataddr

  import sys, datetime, os

  if len(sys.argv) < 2:
      print "done nothing. If a email needs to be delieved, please confirm and provide the passwd"
      exit(0)

  def _format_addr(s):
      name, addr = parseaddr(s)
      return formataddr((Header(name, 'utf-8').encode(), addr))

  pdf_file = "%s.pdf" % datetime.datetime.now().strftime("%Y%m%d")
  path = "/home/ben/Wally/Journal/PDFs/"
  filename = path + pdf_file

  from_addr = "buaaben@163.com"
  passwd = sys.argv[1]            # 从命令行获取密码
  to_addr = "buaaben.fa289a0@m.yinxiang.com"

  # 构造邮件对象
  msg = MIMEMultipart()
  # 发送地址
  msg['From'] = _format_addr("Ben<%s>" % from_addr)
  # 接收地址
  msg['To'] = _format_addr('Evernote<%s>' % to_addr)
  # 主题
  msg['Subject'] = Header("%s @Tagerill #journal" %
                          datetime.datetime.now().strftime("%Y%m%d"),
                          'utf-8').encode()

  # 时间戳
  now = datetime.datetime.now().strftime('%Y/%m/%d-%H:%M')
  msg.attach(MIMEText('Generated automatically by python script at %s' % now,
                      'plain', 'utf-8'))
  # 正文
  with open("/home/ben/dic.txt", 'r+') as f:
      voc = f.read()
      msg.attach(MIMEText('Vacabularies for today are as following: %s' % voc,
                          'plain', 'utf-8'))
      null = ''
      f.write(null)

  # 附件
  if os.path.exists(filename):
      with open(filename, 'rb') as f:
          mime = MIMEBase('PDF', 'pdf', filename='journal.pdf')
          mime.add_header('Content-Disposition', 'attachment',
                          filename='journal.pdf')
          mime.add_header('Content-ID', '<0>')
          mime.add_header('X-Attachment-Id', '0')

          # 把附件的内容读进来:
          mime.set_payload(f.read())
          # 用Base64编码:
          encoders.encode_base64(mime)
          # 添加到MIMEMultipart:
          msg.attach(mime)

  # 发送邮件
  # stmp_server = None              ####### TODO
  stmp_server = "smtp.163.com"
  port = 25
  server = smtplib.SMTP(stmp_server, 25)
  server.set_debuglevel(1)
  server.login(from_addr, passwd)
  server.sendmail(from_addr, [to_addr], msg.as_string())

#+END_SRC
** .emacs.d

#+include: ~/.emacs.d/README.md
#+include: ~/.emacs.d/ChangeLog.txt
#+include: ~/.emacs.d/init.el
#+include: ~/.emacs.d/lisp/emets.el :src emacs-lisp
#+include: ~/.emacs.d/.projectile

*** Notes
**** 0 is not nil(nil & [])

#+BEGIN_EXAMPLE
  (while (> len 0)  ...) ; 0 is not nil(nil & [])
#+END_EXAMPLE

*** TODOs

+ [ ] [[file:Project/emets/lisp/emets.el::(defun%20emets-insert-current-date()][合并 insert-time, 结合使用前缀和 HELM 选择不同格式的时间]]
+ [ ] [[file:Project/emets/lisp/init-org.el::(setq%20org-reverse-note-order%20t)][使用 mapcar 定义 org-refile-targets]]
+ [ ] [[file:Project/emets/lisp/init-org.el::%3B%3B%20(add-to-list%20'org-latex-classes%20'("beamer"][beamer documentclass in org-mode]]
+ [ ] [[file:Project/emets/lisp/init-org.el::%3B%3B%20ox-freemind][ox-freemind]]

** TimBailey
#+include: ~/Wally/Project/TimBailey

*** ekfslam

#+include: ~/Wally/Project/TimBailey/ekfslam_v1.0


*** fastslam

*** ukfslam

** tagerill PCB
*** ARM芯片选型
+ Cortex系列
+ 内含CAN控制器
+ 最好支持openocd
*** flash选型
+ NAND（安装Ubuntu和ROS所需要的容量）
+ NOR
*** 电源模块
+ 需要几种电源
+ 几层PCB，哪层做为电源层，怎么敷铜
+ 电源的反向防护（二级管选型）和过压保护（how）
+
*** CAN模块
+ 淘宝：http://item.taobao.com/item.htm?spm=a230r.1.14.1.1GNisu&id=39187810657&ns=1&abbucket=14#detail

*** 网口
**** socket
整合多个串口
**** 多机
台式机运行图形界面
ARM传输数据
笔记本做算法
*** 整板参考
**** pcDuino
+ http://learn.linksprite.com/pcduino/pcduino-3-circuit-diagram/
+ https://github.com/pcduino/pcDuino3C_carrierboard
**** 古月居 http://blog.csdn.net/hcx25909/article/details/8539587
**** OpenSource hardware
+ https://www.linux.com/news/embedded-mobile/mobile-linux/732197-top-10-open-source-linux-boards-under-200
+ http://www.omappedia.com/wiki/PandaBoard
+ http://www.pcworld.com/article/2046232/top-opensource-pcs.html
+ http://www.techhive.com/article/242863/new_89_opensource_hardware_runs_full_linux_os.html
+ https://en.wikipedia.org/wiki/List_of_open-source_hardware_projects
+ https://en.wikipedia.org/wiki/Open-source_hardware

** imutb

#+include: ~/Wally/Project/imutb/README.md
#+include: ~/Wally/Project/imutb/ChangeLog.org



* Progress                                                         :progress:
** README.md

1. 学习是有系统的
2. 长期零散化的知识吸收是有害的
3. 坚持就是力量
4. 要有优先级

** not tar
*** TOBECONTINED [#A] 算法导论                          :project:algorithm:

**** tobecontined 项目规化 [1/3]
- state "tobecontined" from "todo"       [2015-11-23 一 14:37]
- state "todo"       from ""           [2015-11-23 一 14:36]


1. [ ] 为什么要学习算法，我想过这个问题么？
2. [x] 教材选择： 《算法导论》
3. [ ] 整理已学习的内容
4. [ ] 学习计划

*** TOBECONTINED [#A] 数据结构                      :project:datastructure:
- state "tobecontined" from ""           [2015-11-23 一 14:39]
  算法与数据结构分不开

- 教材： [[~/Document/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90C%2B%2B%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%89%E7%89%88.pdf][数据结构与算法分析]]

**** 项目规化 [1/4]
- state "tobecontined" from ""           [2015-11-23 一 14:39]

1. [ ] 思考： 为什么学习数据结构？
2. [x] 教材选择： 《数据结构与算法分析：c++描述》
3. [ ] 整理已学习内容
4. [ ] 学习计划

**** 引论
***** 选择问题(selection problem)                   :selection:algorithm:

****** 问题描述

有一组n个数，要确定其第k个最大者
+ 输入： 数组a
+ 输出： 第k个最大数

****** 算法一

先排序，然后返回索引为k的元素

#+begin_src latex
  \begin{algorithm}[ht]
    sort-select(a, k)
    \kwdata{a: 数组， k: integer}
    sort(a)
    return a[k]
  \end{algorithm}
#+end_src

****** 算法二

先读入前k个元素并排序，接着将剩下的元素逐个读入，替换适当位置的元素或舍
弃。最终返回第k个元素

#+begin_src latex
  \begin{algorithm}[ht]
    optimized-sort-select
    \kwdata{a: array, k: index}
    \kwout{第k大元素}
    \blankline
    \begin{
      \for{i=1 \kwto k}{
        b[i] = a[i]
      }
      sort(b)
      \for{i=k+1 \kwto a.length}{
        j = k
        key = a[i]
        \while{key>b[j] and j>0}{
          b[j]=b[j-1]
          j = j-1
        }
        b[j-1] = key
      }
      return b[k]
    }
  \end{algorithm}
#+end_src

****** 实现

#+include: ~/Wally/Journal/Project/Algorithm/selects.h :src cpp

****** 算法的性能

length=1000万，k=5000,000时，两种算法都不能在合理的时间内完成（每种算
法都需要计算机处理若干天才能完成）
存在另外一种算法可以在1s左右给出答案。

***** c++类
****** 基本class语法

+ 学习类的程序风格
+ 文件以下划线连接的小写字母单词命名
+ 类使用驼峰式命名
+ 类的方法使用小写字母q命名
+ 合理的注释是必要的

#+begin_src latex
  \begin{cpp}
    /**
    ,* a class for simulating an integer memory cell
    ,*/

    class intcell
    {
      /**
      ,* construct the intcell
      ,* initial value is 0
      ,*/
      intcell(){
        storedvalue = 0;
      }

      /**
      ,* construct the intcell
      ,* initial value is initialvalue
      ,*/
      intcell(int initialvalue){
        storedvalue = initialvalue;
      }

      /**
      ,* return the stored value
      ,*/
      int read(){
        return storedvalue;
      }

      /**
      ,* change the stored value
      ,*/
      void write(int x){
        storedvalue = x;
      }

      private:
      int storedvalue;
    };

  \end{cpp}
#+end_src

****** 特别的构造函数和访问函数

#+begin_src latex
  \begin{cpp}
    /**
    ,* a class for simulating an integer memory cell.
    ,*/

    class intcelloptimized
    {
      public:
      explicit intcelloptimized(int initialvalue=0)
      : storedvalue(initialvalue) {}
      int read() const{
        return storedvalue;
      }
      void write(int x){
        storedvalue = x;
      }

      private:
      int storedvalue;

    };

  \end{cpp}
#+end_src


******* 四项优化
1. 使用默认参数（default parameter）

2. 初始化列表
   1) 在数据成员是具有复杂初始化过程的类类型时，使用初始化列表代替代码
      体中的赋值语句可以节省许多时间
   2) 如果一个数据成员是const（在对象被构造后就不能再改变），数据成员
      的值只能在初始化列表中时行初始化
   3) 如果一具数据成员是不具有零参数构造函数的类类型时，该数据成员的初
      始化也必须在初始化列表中进行

3. explicit构造函数
   1) 所有单参数的构造函数都必须是explicit的，以避免后台的类型转换；
   2) 否则一些宽松的规则将允许在没有显式类型转换操作的情况下进行类型转换
   3) 通常单构造函数定义了一个隐式类型转换(impllicit type conversion)，该转换创建一个临时对象，从而使赋值变得兼容
   4) intcell obj; obj = 37; // should not compile, 会转换为intcell temp = 37; obj = temp;

4. 常量成员函数
   1) 在c++中每个成员函数都被标记为访问函数(accessor)或者修改函数(mutator)
   2) 函数声明可以在不同的情况下以不同的方式使用const关键字，只有跟在结尾圆括号后面的const才标记一个访问函数

******* 其它优化
1. 预处理指令，防止多次包括同一文件 #ifndef intcell_h #define intcell_h #endif
2. 接口与实现分离
   1) 签名一致
   2) 默认参数仅在接口中被定义，在实现中被忽略

****** vector和string

c++标准定义了两个类vector和string。

*如果可能，应尽量避免使用c++内置数组和字符串。*

******* 内置数组带来的麻烦

内置数组的问题在于其行为与基本对象不同
+ 不能使用=复制
+ 不能记忆本身长度
+ 不能对索引进行边界检查

**** 表、栈和队列                                            :vector:list:

最基本的3种数据结构， *每一个有意义的程序都将明晰地至少使用一个这样的
数据结构*

***** 抽象数据类型

抽象数据类型(abstract date type, *ADT*)是带有一组操作的一些对象的集合。

抽象数据类型是数学的抽象：在ADT的定义中根本没有提到这组操作是如何实现
的。

e.g. 表、集合、图

***** 表ADT
****** 表ADT

表ADT： A_{0}, A_{1}, ..., A_{n-a}

表的大小(size)。

n=0, 空表(empty list)

A_{i} *后继* A_{i-1}; A_{i-1} *前驱* A_{i}

表的操作：
1. printList
2. makeEmpty
3. find
4. insert
5. remove
6. findKth

****** 表的简单数组实现

vector类

1. printList 线性时间
2. findKth 常数时间
3. insert/delete: O(N)
   1) 最坏的情况，在表头（位置0）插入删除元素，N
   2) 最好的情况，在表尾插入删除元素，O(1)
   3) 平均：线性时间

在许多情况，表是
1) 通过在 *末尾插入* 元素来 *建立* 的
2) 之后只有数组访问发生
这样，数组实现是适合和。

如果插入和删除都发生在表中的话，特别是前端的话，数组就不是一个好选择了。

****** 链表

为了避免插入和删除的线性开销 -> 表可以不连续存储。

[[~/Wally/Journal/Figure/scrot/59702FS.png]]

1. printList或find(x) 线性时间，但比数组要大

2. findKth(i) 以明显的遍历链表实现O(i)

   - 因此，调用findKth常常以排序（按i）方式进行

***** STL中的向量和表

Standard Template Library标准模板库。 集合(collection) 或 容器
(container)

表ADT的两种流行的实现

1. *vector*
   1) 优势： 在常量时间里是可索引的
   2) 缺点： 插入新项或者删除已有项的代价是高昂的，除非是在末端发生

2. *list* 双向链表
   1) 优点： 变化发生位置已知的话，插入新项和删除已有项的代价是很小的
   2) 缺点： 不容易索引

两者在查找时的效率都是很低的。

方法：

1. 公共的方法（所有STL）
   + int size() const
   + void clear()
   + bool empty

2. 常量时间内在末尾插入或者删除项
   + void push_back(const Object& x)
   + void pop_back()

3. 在常量时间内访问前端的项
   + const Object& back() const
   + const Object& front() const

4. 双向链表list特有的，对前端高效地改变
   + void push_front(const Object & x): 在list的前端加x
   + void pop_front(): 在list对象的前端删除对象

5. vector特有的方法
   + Object& operator[] (int idx)
   + Object& at(int idx)
   + int capacity() const
   + void reserve(int newCapacity): 设定新的容量

****** 迭代器

对于在表中插入删除的操作需要 *位置标记*,  -> 内置类型 *iterator* 给出
位置。

问题:
1) 如何得到迭代器
2) 迭代器可以执行什么操作（方法）
3) 哪些表ADT方法需要迭代器作为形参

******* 获得迭代器

+ iterator begin()
+ iterator end()  // 返回 *边界之外*

******* 迭代器方法

+ itr++ 和 ++itr
+ *itr
+ == 和 ！=

#+begin_latex
\begin{minted}[frame=single, mathescape]{cpp}
for(vector<int>::iterator itr = v.begin(); itr != v.end; ++itr){
}
\end{minted}
#+end_latex

或

#+begin_latex
\begin{minted}[frame=single, mathescape]{cpp}
vector<int>::iterator itr = v.begin()
while(itr != v.end()){
    cout << *itr++ << endl;
}
\end{minted}
#+end_latex

注：
- 后置自增运算符(++)优先级高于解引用(*)运算符，
- 后置自增运算符(++)表达式的返回值为原值，副作用是加1

******* 需要迭代器的容器操作

1. iterator insert(iterator pos, const Object& x)
   - 添加x到表中迭代器pos所指向的位置之前的位置
   - 对于list是常量时间，对于vector不是
   - 返回值是一个指向插入位置的迭代器

2. iterator erase(iterator pos)
   - 删除迭代器所给位置的对象
   - 对于list是常量时间，对于vector不是
   - 返回值是调用之前pos所指向元素的下一个元素的位置，这个操作使pos失
     效

3. iterator erase(iterator start,  iterator end)

表ADT的通用函数模板

[[~/Wally/Journal/Figure/scrot/5970DQY.png]]

******* const_iterator

1. iterator begin()
2. const_iterator begin() const
3. iterator end()
4. const_iterator end() const

方法的定常性(后置const修饰符)是标号(函数签名)的一部分。

***** 向量实现

****** Vector类需求分析

1. 数组的特性
   1) 数组就是指向一块内存的指针变量
   2) 内存块可以使用new[]来分配，相应地必须使用delete[]来释放
   3) 内在块的大小不能改变（但是可以定义一个新的具有更大内存块的数组，
      并且用原来的数组进行初始化）

2. Vector需求分析
   1) 存储基本数组和数组容量
   2) 三大函数
      - 复制构造函数和operator=深复制
      - 析构函数回收基本数组
   3) resize改变大小，reserve改变容量
      - 为新的数组分配一块新的内存块
      - 复制旧内存块到新的内存块
      - 释放旧的内存块
   4) operator[]
      - 访问函数
      - 修改函数
   5) size, empty, clear, back, pop_back, push_back(调用reserve增大容
      量)
   6) 支持嵌套的iterator和const_iterator类型，和begin和end方法

****** 实现

#+INCLUDE: ~/Wally/Journal/Project/DataStructure/Vector.h :src cpp


***** 栈
***** 队列

**** 树
CLOCK: [2015-12-06 日 16:09]

***** Tree

****** 表 VS 树
对于大量数据， _线性表的访问时间太长_ ，不宜使用。

*树* 的大部分操作的平均运行时间为 /O(logN)/

/二叉查找树(binary search tree)/, 是 *set* 和 *map* 的实现基础。

应用：
- 文件系统
- 表达式树
- set/map

****** 基本概念

1. /树(tree)/: 由根结点以及零个或多个子树组成 （递归定义）
2. /根(root)/
3. /边(edge)/: 每个树由N个结点和N-1条边组成
4. /儿子(child)/
5. /父亲(parent)/
6. /叶结点(leaf)/
7. /兄弟结点(sibling)/
8. /祖父(grandparent)/
9. /孙子(grandchild)/
10. /祖先(ancestor)/
11. /后裔(descendant)/
12. /真祖先(proper ancestor)/
13. /真后裔(proper descendant)/
14. /路径(path)/: 从祖先到后裔的唯一路径
15. /长(length)/: 路径的条数
16. /深度(depth)/: 根到结点的长，根深度为0
17. /高度(height)/: 结点到叶子的最长路径的长，树叶的高度为0

****** 树的实现

将每个结点所有的儿子放在树结点的 *链表* 中。

#+BEGIN_SRC cpp
  /// \brief 一般树的实现
  ///
  /// 普通树直接存储所有子结点的链接会浪费许多空间
  struct TreeNode{
    Object element;
    TreeNode *firstChild;         ///< 指向儿子
    TreeNode *nextSibling;        ///< 指向兄弟
  }
#+END_SRC

****** 树的遍历

******* 前序遍历(preorder traversal)

/对结点的处理是在它的所有儿子结点处理之前进行的/

应用： 遍历目录



******* 后向遍历

*** TOBECONTINED [#A] 德语学习                            :project:deutsch:
- State "TOBECONTINED" from ""           [2015-11-23 一 14:52]

**** TODO 项目规化
1. [ ] 为什么要学习德语？
2. [ ] 什么时间和地点学习德语？
3. [ ] 学习一门语言需要平时投入零散的时间进行记忆，这一点我怎么做到？
4. [ ] 整理已经学习的内容并回顾？
5. [ ] 制定合理的学习计划

*** TODO [#A] Raspberry学习                             :project:raspberry:
- State "TODO"       from ""           [2015-11-23 一 15:07]

**** TODO 项目规化
- State "TODO"       from ""           [2015-11-23 一 15:07]

*** TODO [#A] 概率论                                         :project:math:
- state "todo"       from ""           [2015-11-23 一 15:01] \\
  概率论的知识十分重要

**** 项目计划 [/]
1. [ ] 教材选择
2. [ ] 学习计划
*** TODO [#B] 线性代数学习                                   :project:math:
- state "todo"       from ""           [2015-11-23 一 14:59] \\
  数学的知识是必不可少的，再难也不能放弃学习

**** todo 项目计划 [0/2]
- state "todo"       from ""           [2015-11-23 一 15:00]


1. [ ] 教材选择
2. [ ] 制定计划
*** TOBECONTINED [#B] GNU Make                               :project:make:
- State "TOBECONTINED" from "TODO"       [2015-11-23 一 14:34]
- State "TODO"       from ""           [2015-11-23 一 14:12] \\
  Make学习之路

**** 项目规化
1. 学习教材： 《GNU Make项目管理》
2. 学习计划： *按章节来* ，教材布局合理，由浅入深，内容均布
   1) 首先无笔记式地阅读书籍，计划平均 *1小时*
      - 不圈不点
      - 不实现程序
      - 遇到不会但不是核心的东西暂时不管
   2) 阅读电子版书籍，计划平均 *1.5小时*
      - 实现源码
      - 做ORG-笔记
      - 将不会但不相关的知识使用 *org-capture* 添加到待为事项中，等有
        时间处理
   3) *小结* 并 规化下一步


**** TOBECONTINED make 入门
- State "TOBECONTINED" from ""           [2015-11-23 一 17:25]
CLOCK: [2015-11-20 五 18:31]--[2015-11-20 五 19:43] =>  1:12
CLOCK: [2015-11-20 五 10:12]--[2015-11-20 五 11:24] =>  1:12

***** minted for makefile                                        :minted:
#+begin_example
  $ pygmentize -l lexers | grep make
  ,* basemake:
  ,* cmake:
      cmake (filenames *.cmake, cmakelists.txt)
  ,* make, makefile, mf, bsdmake:
      makefile (filenames *.mak, makefile, makefile, makefile.*, gnumakefile)
#+end_example

*make,  makefile,  mf*

***** make VS scripts
相对于脚本，make的优点是：
*你可以把程序中各元素之间的关系告诉make，然后make会根据这些关系和时间
戳判断应该重新进行哪些步骤，以及产生你所需要的程序*

***** 规则(rule)
1) 工作目标(target)
2) 必要条件(prerequisite)
3) 命令(command)

#+begin_latex
  \begin{minted}[frame=single, mathescape]{mf}
  target:prereq1 prereq2
      commands
  \end{minted}
#+end_latex

e.g.
#+begin_latex
\begin{minted}[frame=single, mathescape]{mf}
foo.o: foo.c foo.h
    gcc -c foo.c
\end{minted}
#+end_latex

运行过程中任何错误都会使make终止工作目标的建立并结束运行。

demo1

*** TOBECONTINED [#B] Arduino学习                         :project:arduino:
- State "TOBECONTINED" from ""           [2015-11-23 一 14:57]

**** TODO 项目规化 [0/2]
1. [ ] 教材选择： 《Arduino Cookbook》
2. [ ] 整理已学习内容并制定新的计划

*** TODO [#C] OpenCV学习                                   :project:opencv:

**** TODO 项目规化 [1/2]

1. [X] why: 以后必然离不开计算机视觉
2. [ ] 整理资源与选择教材(*最好是书籍教材*)
3. [ ] 项目计划

*** TODO [#C] 数字图像处理
- State "TODO"       from ""           [2015-11-23 一 14:43] \\
  应该很好玩

**** TODO 项目规化
1. [ ] 思考： 为什么要学习数字图像处理？
2. [ ] 教材选择：数字图像处理， matlab版还是一般版本(使用Python实现)，
   现在等倾向于后者
3. [ ] 学习计划

*** TODO [#C] 数据库学习                                      :project:sql:
- State "TODO"       from ""           [2015-11-23 一 14:48] \\
  数据库的学习可能有必要

**** TODO 项目规化 [1/1]
1. [X] 数据库选择: MySQL 还是 SQLite（优点之一，无后台服务，可以应用于嵌入
   式中）
2. [ ]必要性在哪： *没有找到切切实实的应用之前不要开始*

*** TODO [#C] Qt4                                              :project:qt:
**** TODO 项目规化
**** Chapter 1
***** Hello Qt
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/helloqt/helloqt.cpp
  #include <QApplication>
  #include <QLabel>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QLabel* label = new QLabel("Hello Qt!");
    label->show();
    return app.exec();
  }
#+END_SRC

+ 窗口部件(widget)是指用户界面的一个可视化元素，该词源于"window
  gadget"（窗口配件），相当于Window系统术语的”控件”(control)和”容
  器”(container).
+ QApplication对象用于管理整个应用程序所用到的资源，以argc和argv为参
  数，也就是说，Qt支持自己的一些命令行参数。
+ 绝大多数应用程序都会使用一个QMainWindow或一个QDialog作为它的窗口，但
  Qt是如此灵活，以至于任意窗口部件都可以用作窗口。
+ show()方法使部件可见，在创建窗口部件时标签通常都是隐藏的，这样允许先
  进行设置再显示，避免闪烁。
+ app.exec()方法使程序进入事件循环状态，这是一种等待状态，程序会等候用
  户的动作。

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/helloqt2/helloqt.cpp
  #include <QApplication>
  #include <QLabel>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QLabel* label = new QLabel("<h2><i>Hello</i><font color=red>Qt!</font></h2>");

    label->show();
    return app.exec();
  }
#+END_SRC

+ 通过使用一些简单的HTML样式格式，就可以轻松地把Qt应用程序的用户接口变
  得丰富多彩。
***** 建立连接
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/quit/quit.cpp
  #include <QApplication>
  #include <QPushButton>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QPushButton *button = new QPushButton("quit");
    QObject::connect(button, SIGNAL(clicked()), &app, SLOT(quit()));
    button->show();
    return app.exec();
  }

#+END_SRC

***** 窗口部件的布局
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/age/age.cpp
  #include <QApplication>
  #include <QHBoxLayout>
  #include <QSpinBox>
  #include <QSlider>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QWidget* window = new QWidget;
    window->setWindowTitle("Enter your age:");

    QSpinBox* spinBox = new QSpinBox;
    QSlider* slider = new QSlider(Qt::Horizontal);
    spinBox->setRange(0, 130);
    slider->setRange(0, 130);

    QObject::connect(spinBox, SIGNAL(valueChanged(int)),
                     slider, SLOT(setValue(int)));
    QObject::connect(slider, SIGNAL(valueChanged(int)),
                     spinBox, SLOT(setValue(int)));

    QHBoxLayout* layout = new QHBoxLayout;
    layout->addWidget(spinBox);
    layout->addWidget(slider);
    window->setLayout(layout);
    window->show();
    return app.exec();
  }
#+END_SRC

Qt有三个主要的布局管理器：
+ QHBoxLayout
+ QVBoxLayout
+ QGridLayout

***** 窗口部件的风格
Qt应用程序在每个平台上都可以看起来像本地程序一样，Qt是通过所模拟平台的
外观来实现这一点的，而不是针对某个特殊平台的封闭或者一个工具包中的窗口
部件集。
+ Plastique(KDE)
+ Cleanlooks(GNOME)
+ CDE
+ motif
+ Windows(仅能在本地平台上有效，因为需要依赖平台的主题引擎，下同)
+ Windows XP
+ Windows Vista
+ Mac


在X11下，可以在命令行设置程序窗口风格
#+BEGIN_EXAMPLE
./out -style motif
#+END_EXAMPLE

**** 创建对话框
***** 子类化QDialog
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/finddialog.h
  #ifndef FINDDIALOG_H
  #define FINDDIALOG_H

  #include <QDialog>

  class QCheckBox;
  class QLabel;
  class QLineEdit;
  class QPushButton;

  class FindDialog : public QDialog{
    Q_OBJECT

  public:
    FindDialog(QWidget *parent=0);

  signals:
    void findNext(const QString& str, Qt::CaseSensitivity cs);
    void findPrevious(const QString& str, Qt::CaseSensitivity cs);

  private slots:
    void findClicked();
    void enableFindButton(const QString& text);

  private:
    QLabel *label;
    QLineEdit *lineEdit;
    QCheckBox *caseCheckBox;
    QCheckBox *backwardCheckBox;
    QPushButton *findButton;
    QPushButton *closeButton;
  };

  #endif
#+END_SRC

+ 前置声明(forward declaration)告诉C++编译器类的存在，而不用提供类定义
  的所有细节
+ 前置声明的类型在头文件中使用指针声明
+ 编译速度快
+ FindDialog(QWidget *parent=0)为典型的Qt窗口部件构造函数定义方式，
  parent参数指定部件的父窗口，默认为空指针，即没有父对象。
+ 对于所有使用信号和槽的类，在类定义开始处的 Q_OBJECT 宏是必须的。
+ signals部分定义信号，signals实际上是一个宏，C++预处理器会在编译程序
  前将其转换为标准C++代码
+ Qt::CaseSensitivity是枚举类型
  - Qt::CaseSensitive
  - Qt::CaseInsensitive
+ slots部分定义槽，也是宏

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/finddialog.cpp
  #include <QtWidgets>
  #include "finddialog.h"

  FindDialog::FindDialog(QWidget *parent)
    : QDialog(parent)
  {
    label = new QLabel("Find &What:");
    lineEdit = new QLineEdit;
    label->setBuddy(lineEdit);

    caseCheckBox = new QCheckBox("Match &case");
    backwardCheckBox = new QCheckBox("Search &backward");

    findButton = new QPushButton("&Find");
    findButton->setDefault(true);
    findButton->setEnabled(false);

    closeButton = new QPushButton("&Close");

    connect(lineEdit, SIGNAL(textChanged(const QString&)),
            this, SLOT(enableFindButton(const QString&)));
    connect(findButton, SIGNAL(clicked()),
            this, SLOT(findClicked()));
    connect(closeButton, SIGNAL(clicked()),
            this, SLOT(close()));

    QHBoxLayout *topLeftLayout = new QHBoxLayout;
    topLeftLayout->addWidget(label);
    topLeftLayout->addWidget(lineEdit);

    QVBoxLayout *leftLayout = new QVBoxLayout;
    leftLayout->addLayout(topLeftLayout);
    leftLayout->addWidget(caseCheckBox);
    leftLayout->addWidget(backwardCheckBox);

    QVBoxLayout *rightLayout = new QVBoxLayout;
    rightLayout->addWidget(findButton);
    rightLayout->addWidget(closeButton);
    rightLayout->addStretch();

    QHBoxLayout *mainLayout = new QHBoxLayout;
    mainLayout->addLayout(leftLayout);
    mainLayout->addLayout(rightLayout);
    setLayout(mainLayout);

    setWindowTitle("Find");
    setFixedHeight(sizeHint().height());
  }


  void FindDialog::findClicked(){
    QString text = lineEdit->text();
    Qt::CaseSensitivity cs =
      caseCheckBox->isChecked() ? Qt::CaseSensitive
      : Qt::CaseInsensitive;
    if(backwardCheckBox->isChecked()){
      emit findPrevious(text, cs);
    }else{
      emit findNext(text, cs);
    }
  }

  void FindDialog::enableFindButton(const QString &text){
    findButton->setEnabled(!text.isEmpty());
  }

#+END_SRC
+ #include <QtWidgets>包含所有窗口部件，但在一个头文件中包含一个在的头文
  件着实不是一个好的编程习惯。
  + Qt4 $include <QtGui>
+ 构造函数中把parent参数传递给基类的构造函数
+ tr()函数表示翻译，有时是不错的选择
+ &操作符表快捷键(Alt+W)
+ 所谓“伙伴”(buddy)，就是一个窗口部件，它可以在按下标签的快捷键时接
  收焦点(focus).
+ setDefault()设定默认按钮(default button), 即当用户按下Enter键时对应
  的按钮。
+ 通过 QHBoxLaytout,QVBoxLayout,QGridLayout的不同嵌套组合，可以构建出
  相当复杂的对话框。
+ addStrentch方法增加分隔符(伸展器)，用来占据空白区域
+ 当将子布局对象添加到父布局对象，子布局对象就会重新定义自己的父对象。
  它所有的子窗口部件都会重新定义自己的父对象。
+ QWidget::sizeHint()方法返回部件“理想”的尺寸大小
+ 创建窗口对象使用的是new，所以需要调用delete来析构。但这样不是必须的，
  Qt在删除对象时会自动删除所有的子对象
+ emit是Qt扩展的关键字，像其它Qt扩展一样，它也会被C++预处理器转换为标
  准的C++代码

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>

  #include "finddialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    FindDialog *dialog = new FindDialog;
    dialog->show();
    return app.exec();
  }

#+END_SRC

+ 为了使 *moc* 能够正常运行，必须把类定义从实现文件中分离出来并放到头
  文件中
+ 必须对使用了Q_OBJECT宏的类运行moc(qmake),否则会出现不明确的错误信息。
+ 默认的Tab键顺序是创建窗口部件的顺序，可以使用QWidget::setTabOrder()
  方法设置
+ 提供一种合理的Tab键顺序的键盘快捷键可以确保不愿（或者不能）使用鼠标
  的用户能够充分享受应用程序提供的全部功能。完全通过键盘控制应用程序也
  深受快速输入人员的赞赏。

***** 信号和槽
1. 槽
   + 可以是虚函数
   + 可以被重载
   + 可以是公有的，私有的，保护的
   + 可以被其它成员函数直接调用
   + 参数可以是任意类型
   + *槽可以与信号连接*
2. connect(sender, SIGNAL(signal), receiver, SLOT(slot))
   + sender, receiver是指向QObject的指针
   + signal和slot是不带参数的函数名
3. 机制
   + 一个信号可以连接多个槽
     + 发射信号时，会以不确定的顺序一个接一个调用关联的槽
   + 多个信号可以关联一个槽
   + 一个信号可以与另外一个信号关联
     #+BEGIN_EXAMPLE
       connect(lineEdit, SIGNAL(textChanged(const QString&))
               this, SIGNAL(updateRecord(const QString&)))
     #+END_EXAMPLE
   + 连接可以被移除
     + 很少用，当删除对象时，Qt会自动移除和这个对象相关的所有关联。
4. 注意
   + 信号和槽的参数必有有相同的顺序和相同的类型
   + 信号的参数比槽多时，多余参数会为被忽略
   + 不匹配则警告
   + 信号和槽机制是由QObject实现，并不只是局限于图形界面编程

***** Qt的对象系统
moc(meta-object system), 对C++的重要扩展。
+ 信号和槽
+ 内省
***** 快速设计对话框
Qt的设计初衷是为了能够直观并且友好也进行 *手工编码* ，并且对于程序员来
说， 编写C++源代码开发整个Qt应用程序并不稀奇。

QtDesigner提供了Qt的可视化编码方式。

手工编码和使用QtDesigner在创建对话框时的基本步骤是一致的
1. 创建并初始化子窗口部件
2. 把子窗口部件放到布局中
3. 设置Tab键顺序
4. 建立信号的槽的连接
5. 实现对话框自定义的槽

****** 使用QtDesigner设计对话框并保存为 ui 文件
+ filename.ui
+ Qt用户界面编译器(user interface compiler, uic) 将ui文件转换为C++代码
  + $ uic filename.ui
  + ui_filename.h
    + 头文件中包含了Ui::GoToCellDialog的定义(GoTocelldialog为
      QtDesigner设计的窗体的顶层部件的objectName)
    + setupUi()函数用于初始化窗体

******* 直接使用
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>
  #include <QDialog>

  #include "ui_gotocelldialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);

    Ui::GoToCellDialog ui;
    QDialog *dialog = new Dialog;
    ui.setupUi(dialog);
    dialog.show();
    return app.exec();
  }

#+END_SRC

+ 什么也做不了

******* 多继承：最简捷
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/gotocelldialog.h
  #ifndef GOTOCELLDIALOG_H
  #define GOTOCELLDIALOG_H

  #include <QDialog>

  #include "ui_gotocelldialog.h"

  class GoToCellDialog : public QDialog, public Ui::GoToCellDialog{
    Q_OBJECT

  public:
    GoToCellDialog(QWidget *parent=0);

  private slots:
    void on_lineEdit_textChanged();
  };

  #endif
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/gotocelldialog.cpp
  #include <QtWidgets>

  #include "gotocelldialog.h"

  GoToCellDialog::GoToCellDialog(QWidget *parent)
    : QDialog(parent)
  {
    setupUi(this);

    QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");
    lineEdit->setValidator(new QRegExpValidator(regExp, this));

    connect(okButton, SIGNAL(clicked()), this, SLOT(accept()));
    connect(cancelButton, SIGNAL(clicked()), this, SLOT(reject()));
  }

  void GoToCellDialog::on_lineEdit_textChanged(){
    okButton->setEnabled(lineEdit->hasAcceptableInput());
  }
#+END_SRC

+ setUp()还会自动将那些符合on_objectName_signalName()命名惯例的任意槽
  与相应的objectName的signalName()信号连接到一起。
+ Qt提供了三种内置检验器类:
  - QIntValidator
  - QDoubleValidator
  - QRegExpValidator
+ 通过this传递绘QRegExpValidator的构造函数，使它成为窗口的子对象，这样
  就可以不用担心有关删除QRegExpValidator的事情了，当删除它的父对象时，
  会被自动删除。
+ Qt的父子对象机制是在QObject中实现的。很大程度上简化了内在管理的工作，
  降低了内在泄漏的风险。需要明确删除的是那些使用new创建并且没有父对象
  的对象。
+ accept()和reject()槽都可以关闭对话框，前者将QDialog::Accepted置1,后
  者置0.

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>

  #include "gotocelldialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    GoToCellDialog *dialog = new GoToCellDialog;
    dialog->show();
    return app.exec();
  }

#+END_SRC

+ 注：org tangle不会覆盖已存在的文件

***** 改变对话框的形状
+ 扩展对话框(extension dialog)
+ 多页对话框(multi-page dialog)

****** 扩展对话框

Qt Designer允许我们在构成同一窗体的不同部分内的窗口部件之间建立连接。
+ Edit -> Edit Signals/Slots 进入设置连接模式。

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/sortdialog.h
  #ifndef SORTDIALOG_H
  #define SORTDIALOG_H

  #include <QDialog>

  #include "ui_sortdialog.h"

  class SortDialog : public QDialog, public Ui::SortDialog{
    Q_OBJECT

  public:
    SortDialog(QWidget *parent=0);
    void setColumnRange(QChar first, QChar last);
  };

  #endif
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/sortdialog.cpp
  #include <QtWidgets>

  #include "sortdialog.h"

  SortDialog::SortDialog(QWidget *parent)
    : QDialog(parent)
  {
    setupUi(this);

    secondaryGroupBox->hide();
    tertiaryGroupBox->hide();
    layout()->setSizeConstraint(QLayout::SetFixedSize);

    setColumnRange('A', 'Z');
  }

  void SortDialog::setColumnRange(QChar first, QChar last){
    primaryColumnCombo->clear();
    secondaryColumnCombo->clear();
    tertiaryColumnCombo->clear();

    secondaryColumnCombo->addItem("None");
    tertiaryColumnCombo->addItem("None");
    primaryColumnCombo->setMinimumSize(
                                       secondaryColumnCombo->sizeHint());

    QChar ch = first;
    while(ch <= last){
      primaryColumnCombo->addItem(QString(ch));
      secondaryColumnCombo->addItem(QString(ch));
      tertiaryColumnCombo->addItem(QString(ch));
      ch = ch.unicode()+1;
    }
  }
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/main.cpp
  #include <QApplication>

  #include "sortdialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    SortDialog *dialog = new SortDialog;
    dialog->setColumnRange('C', 'F');
    dialog->show();
    return app.exec();
  }

#+END_SRC

****** 多页对话框
+ QTabWidget
+ QListWidget
+ QStackedWidget


***** 动态对话框
+ 动态对话框(dynamic dialog)就是在程序运行时使用的从Qt设计师的.ui文件
  创建而来的那些对话框。
+ 运行时加载，而非先使用uic将ui文件转换为C++代码
+ 使用QUiLoader类载入ui文件
  #+BEGIN_EXAMPLE
    QUiLoader uiLoader;
    QFile file("sortdialog.ui");
    QWidget *sortDialog = uiLoader.load(&file);
    if(sortDialog){
        ...
    }
  #+END_EXAMPLE
+ 使用QObject::findChild<T>()来访问窗体中的各个子窗口部件
  #+BEGIN_EXAMPLE
    QComboBox *primaryColumnCombo =
              sortDialog->findChild<QCombobox *>("primaryColumnCombo");
    if(primaryColumncombo){
        ...
    }
  #+END_EXAMPLE
+ 对于MSVC 6, 须使用全局函数qFindChild()函数代替
+ QUiLoader类放在一个独立的类库中，需要在pro文件中加入 CONFIG += uitools

***** 内置的窗口部件和对话框
1. 按钮
   + QPushButton
   + QToolButton
   + QRadioButton
   + QCheckButton
2. 容器
   + QGroupBox
   + QFrame
3. 多页窗口部件
   + QTabWidget
   + QToobBox
4. 项视图窗口部件
   + QListView(列表/图标)
   + QTreeView
   + QTabView
5. 显示窗口部件
   + QLabel(应用最多，显示普通文本，HTML，图片)
   + QLCDNumber
   + QProgressBar
   + QTextBrowser
6. 输入窗口部件
   + QLineEdit
   + QTextEdit
   + QSpinBox
   + QDoubleSpinBox
   + QComboBox
   + QDateEdit
   + QTimerEdit
   + QDateTimeEdit
   + QScrollBar
   + QSlider
   + QDial
7. 对话框
   + QInputDialog
   + QProgressDialog
   + QMessageBox
   + QErrorMessage
   + QColorDialog
   + QFontDialog
   + QPageSetupDialog
   + QFileDialog
   + QPrintDialog
8. 向导
   + QWizard
9. 富文本引擎
   Qt库含有一个富文本引擎(rich text engine)，用于格式化文本的显示和编
   辑。

** Raspberry Pi                                                  :raspberry:
*** 树莓派

**** Intro

树莓派（英语： *Raspberry Pi* ），是一款基于Linux系统的只有信用卡大小
的单板机电脑。

[[/home/ben/Wally/Journal/Figure/scrot/5070Ejz.png]]

1. 单板机电脑
2. 体积小： 85x54(B+)
3. 配置
   1) CPU
      ARM CortexA7-四核 900MHz
   2) 内存
      512(B+)
   3) 接口
      + USB: 4个，支持Hub
      + Ethernet
      + HDMI
      + GPIO： 通用IO，8+
      + UART
      + I2C
      + SPI: 2个带地
      + 电源引脚： 3.3v, 5v
      + HAT规格铺设

   4) 存储
      + SD
      + MMC
      + SDIO/MicroSD卡插槽
   5) 支持系统
      + Debian
      + ArchLinux
      + OpenWrt
      + *Raspbian* （自带系统，基于Linux）

   6) 型号
   A, A+, B,  B+, B2

**** 资源汇总

**** 安装ROS

1. 系统要求： Raspbian
2. 方式： 源码方式

**** 参考资料
1. [[https://zh.wikipedia.org/wiki/%E6%A0%91%E8%8E%93%E6%B4%BE][Wiki: 树莓派]]
2. [[http://post.smzdm.com/p/99210/][树莓派&OpenWrt]]
3. [[http://wiki.ros.org/ROSberryPi/Installing%20ROS%20Indigo%20on%20Raspberry%20Pi][ROS wiki: Installing ROS indigo on the Paspberry Pi]]
4. [[http://blog.csdn.net/crazyquhezheng/article/details/43413231][blog 东方赤龙：树莓派编译安装完整版ROS]]
5. [[http://blog.csdn.net/hcx25909/article/category/1759051][blog 古月居： 树莓派Linux驱动学习系列（不多3篇，仅入门）]]
*** todos

1. [ ] 盒子和配件
2. [ ] gpio使用
3. [ ] 各种通信 uart，i2c, isp
4. [ ] 交叉编译环境ubuntu下
5. [ ] 裸板，即不接显示器、鼠标、键盘、网线等
6. [ ] 与arduino相连
7. [ ] 按键等控制ros等
8. [ ]

*** 安装raspbian

1. 参考文献的选择
   + 有官网的教程优先考虑
   + 有国外的教程优先考虑
   + 国内的博客教程等要慎重选择

2. sd卡的分区和格式化处理
   + df -h
   + sudo fdisk -l
   + sudo fdisk =/dev/sdb=
   + mkfs.vfat 需要格式化成fat文件系统，分区之后为linux文件系统

3. 参考
   + [[https://app.yinxiang.com/shard/s52/nl/11551545/740d3fc2-81e5-4733-b3e3-90631ce11d4d?title=noobs%20for%20raspberry%20pi%20%7c%20rants%20%26%20raves%20%e2%80%93%20the%20blog!][noobs for raspberry pi 2 b]]
   + [[https://app.yinxiang.com/shard/s52/nl/11551545/57510d93-2c8b-488c-9a5c-e0db65c720dd?title=ubuntu%20%e5%ae%89%e8%a3%85%20raspbian%20%e5%88%b0%20raspberry%20pi%20b%2b%20-%20wiki][ubuntu下安装raspbian到raspberry中]]

*** rasp-config

1. 语言、时区、键盘
2. 用户及密码
3. 登录方式

*** 安装ros

1. 源码方式:

   http://wiki.ros.org/rosberrypi/installing%20ros%20indigo%20on%20raspberry%20pi

2. apt方式 for arm board(pi 2):

   http://wiki.ros.org/indigo/installation/ubuntuarm

*** headless

https://www.raspberrypi.org/forums/viewtopic.php?f=91&t=74176

*** ssh 远程登录到 raspberry

ssh pi@192.168.1.25

1. ssh-server (sshd) 默认在 raspberry pi 中启动，所以不用设置
2. 默认的，ssh 会尝试用当前用户作为用户名来连接。所以，需要指定用户名
   pi
3. 先 ping

   #+BEGIN_EXAMPLE
   ping 192.168.1.25
   #+END_EXAMPLE

*** NEXT 自动登录，无需密码
- State "NEXT"       from ""           [2015-12-25 五 16:15] \\
  1. 不便用 GUI 方式设置，使用命令行方式配置
  2. 不登录到 X 桌面，GUI设置中有，但先不尝试

在  raspberry configure 中设置 Autolog

+ http://blog.csdn.net/swliao/article/details/5989203

*** 设置静态 IP

+ http://www.cnblogs.com/keygle/archive/2013/04/27/3048273.html


1. 按照 http://www.cnblogs.com/keygle/archive/2013/04/27/3048273.html
   失败，启动时有问题，进入系统后没有自动连接网

2. 尝试只修改一句,  not ok

   #+BEGIN_EXAMPLE
   iface eth0 inet manual
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
   iface eth0 inet static
   address 192.168.1.27
   #+END_EXAMPLE

3. 系统使用的 wpa
   #+BEGIN_EXAMPLE
   wpa-conf /etc/wpa_supplicant/wap_supplicant.conf
   #+END_EXAMPLE

   其内容

   #+BEGIN_EXAMPLE
     network={
             ssid="A409"
             psk="A409A409A409"
             key_mgmt=WPA-PSK
     }
   #+END_EXAMPLE

4. 不重启系统，而是重启 network

   #+BEGIN_EXAMPLE
   sudo service networking restart
   #+END_EXAMPLE

5. 使用默认的配置，manual 还是动态的

   IP: 192.168.1.25

6. 配置

   #+BEGIN_EXAMPLE
     auto wlan0
     allow-hotplug wlan0
     iface wlan0 inet manual
     wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf
     iface wlan0 inet static
             address 192.168.1.25
             netmask 255.255.255.0
             gateway 192.168.1.1
   #+END_EXAMPLE

   - 桌面任务栏上显示的与 ifconfig 不一致，与后者为准。
   - 可以了，尽管还没有完全配置好

*** 使用蓄电池供电

5V 蓄电池 + 手机 USB 数据线，测试 OK

LED 的指示状态？？？

*** raspberry使用思考

1. 不要瞎折腾，用不着的东西不要装
2. 使用vi，不要装emacs
3. 不要过人热衷，先消停几天，十二月份再玩(2015/11/22)
4. ros也要精简，绝对不要尝试gui
*** 挂载 NFS

问题

#+BEGIN_EXAMPLE
  ~ $ sudo mount -t nfs 192.168.1.3:/home/ben/Wally/Project/catkin_ws catkin_ws/
  mount.nfs: rpc.statd is not running but is required for remote locking.
  mount.nfs: Either use '-o nolock' to keep locks local, or start statd.
  mount.nfs: an incorrect mount option was specified

#+END_EXAMPLE

解决

#+BEGIN_EXAMPLE
 sudo service rpcbind restart
#+END_EXAMPLE

** AVR

#+INCLUDE: ~/Wally/Project/avrpro/README.md
#+INCLUDE: ~/Wally/Project/avrpro/ChangeLog.org

- [[~/Wally/Reference/Chip/MCU/Atmega16.pdf][Atmage16]]
- [[~/Wally/Reference/Manual/AvrdudeManual.pdf][AvrdudeManual.pdf]]
- [[~/Wally/Reference/Manual/AvrLibcUserManual-1.8.0.pdf][AvrLibcUserManual-1.8.0.pdf]]

*** 教程

+ [[http://www.avrvi.com/index_avr.html][AVR 教程]]
+ [[~/Wally/Reference/Textbook/AVR单片机嵌入式系统原理与应用实践.pdf][AVR单片机嵌入式系统原理与应用实践.pdf]]

*** 开发环境

- MCU: Atmega16
- 编辑器： Emacs
- 编译器： gcc-avr
- 编程器： avrdude
- 下载器： usbasp
- 仿真： [[http://savannah.nongnu.org/projects/simulavr/][simulavr]]
- 调试： avr-gdb, [[http://sourceforge.net/projects/avarice/][AvaRICE]]

**** Reference

+ [[http://www.atmel.com/webdoc/AVRLibcReferenceManual/index.html][Atmel: AVR Libc Reference Manual]]
+ [[http://www.nongnu.org/avr-libc/][AVR Libc Homepage]]

**** avr libc

/AVR Libc/ is a *Free Software* project whose goal is to
_provide a high quality C library for use with GCC on Atmel AVR
microcontrollers_.

Together, /avr-binutils/, /avr-gcc/, and /avr-libc/ form the heart of
the Free Software toolchain for the Atmel AVR microcontrollers.

They are further accompanied by projects for in-system programming
software (/avrdude/), simulation (/simulavr/) and debugging
(/avr-gdb/, AVaRICE).

**** avrdude

*AVRDUDE* is an utility to *download/upload/manipulate* the ROM and
EEPROM contents of AVR microcontrollers using the in-system
programming technique (*ISP*).

*** avrdude
**** reference

+ [[http://www.nongnu.org/avrdude/][homepage]]
+ [[~/Document/EmbeddedSystem/Sofewares/Ardude/avrdude-doc-5.5.pdf][Manual]]
+ [[http://www.ladyada.net/learn/avr/avrdude.html][AVR tutorials]]
+ [[https://app.yinxiang.com/Home.action#n=8245c1de-e308-41be-92dd-45932263d7da&ses=3&sh=5&sds=5&x=avrdude&][在Linux下烧录单片机]]

**** overview

*AVRDUDE* is an utility to *download/upload/manipulate* the ROM and
EEPROM contents of AVR microcontrollers using the in-system
programming technique (*ISP*).

简言之， *AVR在线烧录*

features
1. 命令行 -> 自动化，makefile
2. terminal mode
3. 跨平台
4. 支持多烧录器, ISP/JTag/Serial
5. 支持多种格式，hex/bin

**** usage

#+BEGIN_EXAMPLE
 $ avrdude --help
avrdude: invalid option -- '-'
Usage: avrdude [options]
Options:
  -p <partno>                Required. Specify AVR device.
  -b <baudrate>              Override RS-232 baud rate.
  -B <bitclock>              Specify JTAG/STK500v2 bit clock period (us).
  -C <config-file>           Specify location of configuration file.
  -c <programmer>            Specify programmer type.
  -D                         Disable auto erase for flash memory
  -i <delay>                 ISP Clock Delay [in microseconds]
  -P <port>                  Specify connection port.
  -F                         Override invalid signature check.
  -e                         Perform a chip erase.
  -O                         Perform RC oscillator calibration (see AVR053).
  -U <memtype>:r|w|v:<filename>[:format]
                             Memory operation specification.
                             Multiple -U options are allowed, each request
                             is performed in the order specified.
  -n                         Do not write anything to the device.
  -V                         Do not verify.
  -u                         Disable safemode, default when running from a script.
  -s                         Silent safemode operation, will not ask you if
                             fuses should be changed back.
  -t                         Enter terminal mode.
  -E <exitspec>[,<exitspec>] List programmer exit specifications.
  -x <extended_param>        Pass <extended_param> to programmer.
  -y                         Count # erase cycles in EEPROM.
  -Y <number>                Initialize erase cycle # in EEPROM.
  -v                         Verbose output. -v -v for more.
  -q                         Quell progress output. -q -q for less.
  -l logfile                 Use logfile rather than stderr for diagnostics.
  -?                         Display this usage.

avrdude version 6.0.1, URL: <http://savannah.nongnu.org/projects/avrdude/>

#+END_EXAMPLE


#+BEGIN_EXAMPLE
sudo avrdude -p 8052 -c usbasp -e -U flash:w:'跑马灯.hex'
#+END_EXAMPLE


#+BEGIN_SRC makefile
  main：
      # 注意 这一行以及一下每行开头都是一个Tab
      sdcc liushui.c
      # SDCC默认的输出格式是ihx 我 们把它转换成hex
      packihx liushui.ihx>liushui.hex
      # 这就是烧录的语句，其实最后的格式是ihx也可以烧录的
      sudo avrdude -p 8052 -c usbasp -e -U flash:w:liushui.hex
#+END_SRC

**** 配置文件

#+include: /etc/avrdude.conf

***** programmer 编程器格式

#+BEGIN_EXAMPLE
#   programmer
#       parent <id>                                 # optional parent
#       id       = <id1> [, <id2> [, <id3>] ...] ;  # <idN> are quoted strings
#       desc     = <description> ;                  # quoted string
#       type     = <type>;                          # programmer type, quoted string
#                          # supported programmer types can be listed by "-c ?type"
#       connection_type = parallel | serial | usb
#       baudrate = <num> ;                          # baudrate for avr910-programmer
#       vcc      = <num1> [, <num2> ... ] ;         # pin number(s)
#       buff     = <num1> [, <num2> ... ] ;         # pin number(s)
#       reset    = <num> ;                          # pin number
#       sck      = <num> ;                          # pin number
#       mosi     = <num> ;                          # pin number
#       miso     = <num> ;                          # pin number
#       errled   = <num> ;                          # pin number
#       rdyled   = <num> ;                          # pin number
#       pgmled   = <num> ;                          # pin number
#       vfyled   = <num> ;                          # pin number
#       usbvid   = <hexnum>;                        # USB VID (Vendor ID)
#       usbpid   = <hexnum>;                        # USB PID (Product ID)
#       usbdev   = <interface>;                     # USB interface or other device info
#       usbvendor = <vendorname>;                   # USB Vendor Name
#       usbproduct = <productname>;                 # USB Product Name
#       usbsn    = <serialno>;                      # USB Serial Number
#
#        To invert a bit, use = ~ <num>, the spaces are important.
#        For a pin list all pins must be inverted.
#        A single pin can be specified as usual = ~ <num>, for lists
#        specify it as follows = ~ ( <num> [, <num2> ... ] ) .
#     ;
#+END_EXAMPLE

***** 查看支持的 programmer: avrdude -c foo (a little trick)

#+BEGIN_EXAMPLE
 $ avrdude -c foo

avrdude: Can't find programmer id "abc"

Valid programmers are:
  2232HIO          = FT2232H based generic programmer
  4232h            = FT4232H based generic programmer
  89isp            = Atmel at89isp cable
  abcmini          = ABCmini Board, aka Dick Smith HOTCHIP
  alf              = Nightshade ALF-PgmAVR, http://nightshade.homeip.net/
  arduino          = Arduino
  arduino-ft232r   = Arduino: FT232R connected to ISP
  atisp            = AT-ISP V1.1 programming cable for AVR-SDK1 from <http://micro-research.co.th/>
  avr109           = Atmel AppNote AVR109 Boot Loader
  avr910           = Atmel Low Cost Serial Programmer
  avr911           = Atmel AppNote AVR911 AVROSP
  avrftdi          = FT2232D based generic programmer
  avrisp           = Atmel AVR ISP
  avrisp2          = Atmel AVR ISP mkII
  avrispmkII       = Atmel AVR ISP mkII
  avrispv2         = Atmel AVR ISP V2
  bascom           = Bascom SAMPLE programming cable
  benisp           = none
  blaster          = Altera ByteBlaster
  bsd              = Brian Dean's Programmer, http://www.bsdhome.com/avrdude/
  buspirate        = The Bus Pirate
  buspirate_bb     = The Bus Pirate (bitbang interface, supports TPI)
  butterfly        = Atmel Butterfly Development Board
  butterfly_mk     = Mikrokopter.de Butterfly
  bwmega           = BitWizard ftdi_atmega builtin programmer
  c2n232i          = serial port banging, reset=dtr sck=!rts mosi=!txd miso=!cts
  dapa             = Direct AVR Parallel Access cable
  dasa             = serial port banging, reset=rts sck=dtr mosi=txd miso=cts
  dasa3            = serial port banging, reset=!dtr sck=rts mosi=txd miso=cts
  diecimila        = alias for arduino-ft232r
  dragon_dw        = Atmel AVR Dragon in debugWire mode
  dragon_hvsp      = Atmel AVR Dragon in HVSP mode
  dragon_isp       = Atmel AVR Dragon in ISP mode
  dragon_jtag      = Atmel AVR Dragon in JTAG mode
  dragon_pdi       = Atmel AVR Dragon in PDI mode
  dragon_pp        = Atmel AVR Dragon in PP mode
  dt006            = Dontronics DT006
  ere-isp-avr      = ERE ISP-AVR <http://www.ere.co.th/download/sch050713.pdf>
  frank-stk200     = Frank STK200
  ft232r           = FT232R Synchronous BitBang
  ft245r           = FT245R Synchronous BitBang
  futurlec         = Futurlec.com programming cable.
  jtag1            = Atmel JTAG ICE (mkI)
  jtag1slow        = Atmel JTAG ICE (mkI)
  jtag2            = Atmel JTAG ICE mkII
  jtag2avr32       = Atmel JTAG ICE mkII im AVR32 mode
  jtag2dw          = Atmel JTAG ICE mkII in debugWire mode
  jtag2fast        = Atmel JTAG ICE mkII
  jtag2isp         = Atmel JTAG ICE mkII in ISP mode
  jtag2pdi         = Atmel JTAG ICE mkII PDI mode
  jtag2slow        = Atmel JTAG ICE mkII
  jtag3            = Atmel AVR JTAGICE3 in JTAG mode
  jtag3dw          = Atmel AVR JTAGICE3 in debugWIRE mode
  jtag3isp         = Atmel AVR JTAGICE3 in ISP mode
  jtag3pdi         = Atmel AVR JTAGICE3 in PDI mode
  jtagkey          = Amontec JTAGKey, JTAGKey-Tiny and JTAGKey2
  jtagmkI          = Atmel JTAG ICE (mkI)
  jtagmkII         = Atmel JTAG ICE mkII
  jtagmkII_avr32   = Atmel JTAG ICE mkII im AVR32 mode
  lm3s811          = Luminary Micro LM3S811 Eval Board (Rev. A)
  mib510           = Crossbow MIB510 programming board
  mkbutterfly      = Mikrokopter.de Butterfly
  nibobee          = NIBObee
  o-link           = O-Link, OpenJTAG from www.100ask.net
  openmoko         = Openmoko debug board (v3)
  pavr             = Jason Kyle's pAVR Serial Programmer
  pickit2          = MicroChip's PICkit2 Programmer
  picoweb          = Picoweb Programming Cable, http://www.picoweb.net/
  pony-stk200      = Pony Prog STK200
  ponyser          = design ponyprog serial, reset=!txd sck=rts mosi=dtr miso=cts
  siprog           = Lancos SI-Prog <http://www.lancos.com/siprogsch.html>
  sp12             = Steve Bolt's Programmer
  stk200           = STK200
  stk500           = Atmel STK500
  stk500hvsp       = Atmel STK500 V2 in high-voltage serial programming mode
  stk500pp         = Atmel STK500 V2 in parallel programming mode
  stk500v1         = Atmel STK500 Version 1.x firmware
  stk500v2         = Atmel STK500 Version 2.x firmware
  stk600           = Atmel STK600
  stk600hvsp       = Atmel STK600 in high-voltage serial programming mode
  stk600pp         = Atmel STK600 in parallel programming mode
  usbasp           = USBasp, http://www.fischl.de/usbasp/
  usbasp-clone     = Any usbasp clone with correct VID/PID
  usbtiny          = USBtiny simple USB programmer, http://www.ladyada.net/make/usbtinyisp/
  wiring           = Wiring
  xil              = Xilinx JTAG cable
#+END_EXAMPLE

***** 自定义 ISP

1. 参考

   #+BEGIN_EXAMPLE
     programmer
       id    = "usbasp";
       desc  = "USBasp, http://www.fischl.de/usbasp/";
       type  = "usbasp";
       connection_type = usb;
       usbvid     = 0x16C0; # VOTI
       usbpid     = 0x05DC; # Obdev's free shared PID
       usbvendor  = "www.fischl.de";
       usbproduct = "USBasp";

       # following variants are autodetected for id "usbasp"

       # original usbasp from fischl.de
       # see above "usbasp"

       # old usbasp from fischl.de
       #usbvid     = 0x03EB; # ATMEL
       #usbpid     = 0xC7B4; # (unoffical) USBasp
       #usbvendor  = "www.fischl.de";
       #usbproduct = "USBasp";

       # NIBObee (only if -P nibobee is given on command line)
       # see below "nibobee"
     ;

     programmer
       id    = "usbasp-clone";
       desc  = "Any usbasp clone with correct VID/PID";
       type  = "usbasp";
       connection_type = usb;
       usbvid    = 0x16C0; # VOTI
       usbpid    = 0x05DC; # Obdev's free shared PID
       #usbvendor  = "";
       #usbproduct = "";
     ;

   #+END_EXAMPLE

2. benusp

   #+BEGIN_EXAMPLE
     programmer
       id    = "benisp";
       desc  = "Any usbasp clone with correct VID/PID";
       type  = "usbasp";
       connection_type = usb;
       usbvid    = 0x03eb; # VOTI
       usbpid    = 0xc8b4; # Obdev's free shared PID
       #usbvendor  = "";
       #usbproduct = "";
     ;
   #+END_EXAMPLE

3. test

   #+BEGIN_EXAMPLE
     Ardude $ avrdude -p 8052 -c benasp

     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted
     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted
     avrdude: warning: cannot set sck period. please check for usbasp firmware update.
     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted
     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted
     avrdude: error: programm enable: target doesn't answer. 0
     avrdude: initialization failed, rc=-1
              Double check connections and try again, or use -F to override
              this check.

     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted

     avrdude done.  Thank you.

     Ardude $ sudo avrdude -p 8052 -c benasp

     avrdude: warning: cannot set sck period. please check for usbasp firmware update.
     avrdude: error: programm enable: target doesn't answer. 0
     avrdude: initialization failed, rc=-1
              Double check connections and try again, or use -F to override
              this check.


     avrdude done.  Thank you.

   #+END_EXAMPLE

   1. 权限
   2. 配置不对

***** part AVR型号

#+BEGIN_EXAMPLE
  #   part
  #       id               = <id> ;                 # quoted string
  #       desc             = <description> ;        # quoted string
  #       has_jtag         = <yes/no> ;             # part has JTAG i/f
  #       has_debugwire    = <yes/no> ;             # part has debugWire i/f
  #       has_pdi          = <yes/no> ;             # part has PDI i/f
  #       has_tpi          = <yes/no> ;             # part has TPI i/f
  #       devicecode       = <num> ;            # deprecated, use stk500_devcode
  #       stk500_devcode   = <num> ;                # numeric
  #       avr910_devcode   = <num> ;                # numeric
  #       signature        = <num> <num> <num> ;    # signature bytes
  #       chip_erase_delay = <num> ;                # micro-seconds
  #       reset            = dedicated | io;
  #       retry_pulse      = reset | sck;
  #       pgm_enable       = <instruction format> ;
  #       chip_erase       = <instruction format> ;
  #       chip_erase_delay = <num> ;                # chip erase delay (us)
  #       # STK500 parameters (parallel programming IO lines)
  #       pagel            = <num> ;                # pin name in hex, i.e., 0xD7
  #       bs2              = <num> ;                # pin name in hex, i.e., 0xA0
  #       serial           = <yes/no> ;             # can use serial downloading
  #       parallel         = <yes/no/pseudo>;       # can use par. programming
  #       # STK500v2 parameters, to be taken from Atmel's XML files
  #       timeout          = <num> ;
  #       stabdelay        = <num> ;
  #       cmdexedelay      = <num> ;
  #       synchloops       = <num> ;
  #       bytedelay        = <num> ;
  #       pollvalue        = <num> ;
  #       pollindex        = <num> ;
  #       predelay         = <num> ;
  #       postdelay        = <num> ;
  #       pollmethod       = <num> ;
  #       mode             = <num> ;
  #       delay            = <num> ;
  #       blocksize        = <num> ;
  #       readsize         = <num> ;
  #       hvspcmdexedelay  = <num> ;
  #       # STK500v2 HV programming parameters, from XML
  #       pp_controlstack  = <num>, <num>, ...;   # PP only
  #       hvsp_controlstack = <num>, <num>, ...;  # HVSP only
  #       hventerstabdelay = <num>;
  #       progmodedelay    = <num>;               # PP only
  #       latchcycles      = <num>;
  #       togglevtg        = <num>;
  #       poweroffdelay    = <num>;
  #       resetdelayms     = <num>;
  #       resetdelayus     = <num>;
  #       hvleavestabdelay = <num>;
  #       resetdelay       = <num>;
  #       synchcycles      = <num>;               # HVSP only
  #       chiperasepulsewidth = <num>;            # PP only
  #       chiperasepolltimeout = <num>;
  #       chiperasetime    = <num>;               # HVSP only
  #       programfusepulsewidth = <num>;          # PP only
  #       programfusepolltimeout = <num>;
  #       programlockpulsewidth = <num>;          # PP only
  #       programlockpolltimeout = <num>;
  #       # JTAG ICE mkII parameters, also from XML files
  #       allowfullpagebitstream = <yes/no> ;
  #       enablepageprogramming = <yes/no> ;
  #       idr              = <num> ;                # IO addr of IDR (OCD) reg.
  #       rampz            = <num> ;                # IO addr of RAMPZ reg.
  #       spmcr            = <num> ;                # mem addr of SPMC[S]R reg.
  #       eecr             = <num> ;                # mem addr of EECR reg.
  #                                                 # (only when != 0x3c)
  #       is_at90s1200     = <yes/no> ;             # AT90S1200 part
  #       is_avr32         = <yes/no> ;             # AVR32 part
  #
  #       memory <memtype>
  #           paged           = <yes/no> ;          # yes / no
  #           size            = <num> ;             # bytes
  #           page_size       = <num> ;             # bytes
  #           num_pages       = <num> ;             # numeric
  #           min_write_delay = <num> ;             # micro-seconds
  #           max_write_delay = <num> ;             # micro-seconds
  #           readback_p1     = <num> ;             # byte value
  #           readback_p2     = <num> ;             # byte value
  #           pwroff_after_write = <yes/no> ;       # yes / no
  #           read            = <instruction format> ;
  #           write           = <instruction format> ;
  #           read_lo         = <instruction format> ;
  #           read_hi         = <instruction format> ;
  #           write_lo        = <instruction format> ;
  #           write_hi        = <instruction format> ;
  #           loadpage_lo     = <instruction format> ;
  #           loadpage_hi     = <instruction format> ;
  #           writepage       = <instruction format> ;
  #         ;
  #     ;
#+END_EXAMPLE
***** At89S52

+ http://www.avrfreaks.net/forum/writing-at89s52-through-usbasp

Avrdude默认配置中没有用于烧写51单片机的target对象，需要自己配置。

下述配置，测试没有成功。

#+BEGIN_EXAMPLE
#------------------------------------------------------------
# Below chips by added by me .. Joy Shukla(joy_shukla@yahoo.in)
# these chips can be programmed with my usbasp programmer(changed atmega8 program)
# after adding avrdude support in this file ..
#------------------------------------------------------------

#------------------------------------------------------------
# AT89S52
#------------------------------------------------------------
part
    id               = "8052";
    desc             = "AT89S52";
    signature        = 0x1E 0x52 0x06;
    chip_erase_delay = 20000;
    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                       "x x x x  x x x x    x x x x  x x x x";

    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                       "x x x x  x x x x    x x x x  x x x x";

    timeout      = 200;
    stabdelay      = 100;
    cmdexedelay      = 25;
    synchloops      = 32;
    bytedelay      = 0;
    pollindex      = 3;
    pollvalue      = 0x53;
    predelay      = 1;
    postdelay      = 1;
    pollmethod      = 0;

    memory "flash"
        size            = 8192;
        paged           = no;
        min_write_delay = 4000;
        max_write_delay = 9000;
        readback_p1     = 0xff;
        readback_p2     = 0xff;
        read            = "  0   0   1   0    0   0   0   0",
                          "  x   x   x a12  a11 a10  a9  a8",
                          " a7  a6  a5  a4   a3  a2  a1  a0",
                          "  o   o   o   o    o   o   o   o";

        write           = "  0   1   0   0    0   0   0   0",
                          "  x   x   x a12  a11 a10  a9  a8",
                          " a7  a6  a5  a4   a3  a2  a1  a0",
                          "  i   i   i   i    i   i   i   i";
   mode      = 0x21;
   delay      = 12;
      ;

    memory "signature"
        size            = 3;
        read            = "0  0  1  0   1  0  0  0   x  x  x  0   0  0 a1 a0",
                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
      ;
  ;
#+END_EXAMPLE

**** ISP测试

接入 USB ISP 后的反应

#+BEGIN_EXAMPLE
Ardude $ lsusb
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
...

Ardude $ lsusb
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
...
Bus 003 Device 003: ID 03eb:c8b4 Atmel Corp.
#+END_EXAMPLE

clk
#+BEGIN_EXAMPLE
   $ sudo avrdude -p 8052 -c benisp

  avrdude: warning: cannot set sck period. please check for usbasp firmware update.
  avrdude: error: programm enable: target doesn't answer. 0
  avrdude: initialization failed, rc=-1
           Double check connections and try again, or use -F to override
           this check.


  avrdude done.  Thank you.
#+END_EXAMPLE

/Warning 只是警告，不是错误/

#+BEGIN_EXAMPLE
avrdude: warning: cannot set sck period. please check for usbasp
firmware update.
#+END_EXAMPLE

**** usbasp测试

***** [[https://detail.tmall.com/item.htm?id=44102479119&spm=a1z09.2.0.0.Qt1XKV&_u=9mb80en1c47][Taobao上有一些资料]]

atmega8a
[[/home/ben/Wally/Journal/Figure/scrot/2472pvk.png]]

1.支持AT89S51/52单片机
2.支持AVR所有ASP芯片。
3.输出端口为ATMEL标准端口。
4.有USB取电和目标板支持目标电压5V，可通过跳线帽连接选择。
5.可AUTOSPEED 自动调速固件，下载器会自动跟踪要编程的芯片频率，自动改变速度，达到自动调速。
6.预留 MOSI，MISO，RET，SCK，VCC，GND。 6PIN接口，方便使用者根据需要连接目标板。

7.预留 PROGRAMMING 编程接口，用户可自行升级下载器固件。

编程软件：AVR_fighter,PROGISP1.66,PROGISP1.67,PROGISP1.68编译更低或者
更高软件都行、烧片一气呵成，非常方便。

支持烧写的芯片：

1. 51系列

   + AT89S51
   + AT89S52
   + AT89S53
   + AT89S8253
   + AT89S2051
   + AT89S8252
   + AT89S4051

2. AVR系列

   #+BEGIN_EXAMPLE
     AT90can128 AT90can32

     AT90can64, AT90pwm2, AT90pwm3, AT90s1200, AT90s2313, AT90s2323,
     AT90s2343, AT90s4414, AT90S8515, AT90S8535,  AT90usb1286, AT90usb1287

     Atmega103, Atmega128, Atmega1280, Atmega1281, Atmega16, Atmega161,
     Atmega162, Atmega163, Atmega164, Atmega165, Atmega168, Atmega169,
     Atmega2560, Atmega2561, Atmega32, Atmega323, Atmega324, Atmega325,
     Atmega3250, Atmega3259, Atmega328, Atmega329, Atmega3290, Atmega406,
     Atmega48, Atmega64, Atmega640, Atmega644, Atmega645, Atmega6450,
     Atmega649, Atmega6490, Atmega8, Atmega8515, Atmega8535, Atmega88,


     Attiny11, Attiny12, Attiny13 , Attiny15, Attiny22, Attiny2313,
     Attiny24,Attiny25, Attiny26, Attiny261,  Attiny28, Attiny44,
     Attiny45, Attiny46, Attiny46, Attiny84, Attiny85, Attiny861
   #+END_EXAMPLE

[[/home/ben/Wally/Journal/Figure/scrot/247225q.png]]

***** 虚拟机中测试

装驱动：51开发板的资料中有，可以用。

烧录软件: /progisp/

[[/home/ben/Wally/Journal/Figure/scrot/2472CYG.png]]

***** Ubuntu中测试

1. usbasp 连接没有问题

2. lsusb 显示的 设备ID与产商ID 与 avrdude 配置文件中的 usbasp-clone 一
   致

3. error

   #+BEGIN_EXAMPLE
     $ sudo avrdude -c usbasp-clone -p 8052

     avrdude: warning: cannot set sck period. please check for usbasp firmware update.
     avrdude: error: programm enable: target doesn't answer. 1
     avrdude: initialization failed, rc=-1
              Double check connections and try again, or use -F to override
              this check.
   #+END_EXAMPLE

***** usbasp可以给单片机供电

**** 使用 Arduino 烧录

+ http://openrcforums.com/forum/viewtopic.php?f=10&t=1363#p29615
+
  http://blackstufflabs.com/2013/10/24/aggiornare-firmware-usbasp-con-arduino/?lang=zh

**** [[http://blog.zakkemble.co.uk/avrdudess-a-gui-for-avrdude/][avrdudess]]: a GUI for avrdude :avrdude:avrdudess:

1. 直接运行 exe 文件

2. Linux 下使用 /Mono/

   1) Install Mono

      #+BEGIN_EXAMPLE
      # (this is the minimum required, you can do mono-complete for a full install)
      sudo apt-get install libmono-winforms2.0-cil
      #+END_EXAMPLE

   2) Install AVRDUDE

      #+BEGIN_EXAMPLE
      sudo apt-get install avrdude
      #+END_EXAMPLE

   3) Run AVRDUDESS with Mono

      #+BEGIN_EXAMPLE
      mono avrdudess.exe
      #+END_EXAMPLE

      you might have to run as root (/sudo/) so avrdude runs as root
      if you havn’t changed any rules.d stuff

**** 测试AVR Atmega16

#+BEGIN_EXAMPLE
   $ sudo avrdude -p m16 -c usbasp -e
  [sudo] password for ben:

  avrdude: warning: cannot set sck period. please check for usbasp firmware update.
  avrdude: AVR device initialized and ready to accept instructions

  Reading | ################################################## | 100% 0.01s

  avrdude: Device signature = 0x1e9403
  avrdude: erasing chip
  avrdude: warning: cannot set sck period. please check for usbasp firmware update.

  avrdude: safemode: Fuses OK (H:FF, E:99, L:E1)

  avrdude done.  Thank you.

#+END_EXAMPLE

OK,  warning not errors.

*** LED

#+INCLUDE: ~/Wally/Project/avrpro/src/led/led1.c

#+BEGIN_SRC makefile
  led1.o:led1.c
          avr-gcc -mmcu=atmega16 -c led1.c
  led1.elf:led1.o
          avr-gcc -mmcu=atmega16 -o led1.elf led1.o
  led1.hex:led1.elf
          avr-objcopy -j .text -j .data -O ihex led1.elf led1.hex
  .PHONY:upload
  upload:led1.hex
          sudo avrdude -p m16 -c usbasp -e -U flash:w:"led1.hex"
#+END_SRC

/编译烧录成功，但是没有效果！？/

**** 手记
#+BEGIN_EXAMPLE
  led $ cat makefile
  led1.o:led1.c
          avr-gcc -mmcu=atmega16 -c led.c
  led1.elf:ledl.o
          avr-gcc -mmcu=atmega16 -O led1.elf led1.o
  led1.hex:led1.elf
          avr-objcopy -j .text -j .data -O ihex led1.elf led1.hex
  led $ make led1.o
  avr-gcc -mmcu=atmega16 -c led.c
  avr-gcc: error: led.c: 没有那个文件或目录
  avr-gcc: fatal error: no input files
  compilation terminated.
  make: *** [led1.o] 错误 1
  led $ make led1.o
  avr-gcc -mmcu=atmega16 -c led1.c
  In file included from led1.c:2:0:
  /usr/lib/avr/include/util/delay.h:90:3: warning: #warning "F_CPU not defined for <util/delay.h>" [-Wcpp]
   # warning "F_CPU not defined for <util/delay.h>"
     ^
  /usr/lib/avr/include/util/delay.h:95:3: warning: #warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed" [-Wcpp]
   # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
     ^
  led $ ls
  led1.c  led1.o  makefile  makefile~
  led $ make led1.elf
  make: *** 没有规则可以创建“led1.elf”需要的目标“ledl.o”。 停止。
  led $ make led1.elf
  avr-gcc -mmcu=atmega16 -O led1.elf led1.o
  avr-gcc: error: led1.elf: 没有那个文件或目录
  make: *** [led1.elf] 错误 1
  led $ make led1.elf
  avr-gcc -mmcu=atmega16 -O led1.elf led1.o
  avr-gcc: error: led1.elf: 没有那个文件或目录
  make: *** [led1.elf] 错误 1
  led $ make led1.elf
  avr-gcc -mmcu=atmega16 -o led1.elf led1.o
  led $ ls
  led1.c  led1.elf  led1.o  makefile  makefile~
  led $ make led1.hex
  avr-objcopy -j .text -j .data -o ihex led1.elf led1.hex
  avr-objcopy：无效选项 -- o
  用法：avr-objcopy [选项] 输入文件 [输出文件]
   复制二进制文件，可能在此过程中进行变换
   选项为：
    -I --input-target <bfdname>      Assume input file is in format <bfdname>
    -O --output-target <bfdname>     Create an output file in format <bfdname>
    ...
  avr-objcopy：支持的目标： elf32-avr elf32-little elf32-big srec symbolsrec verilog tekhex binary ihex
  make: *** [led1.hex] 错误 1
  led $
  led $ make led1.hex
  avr-objcopy -j .text -j .data -O ihex led1.elf led1.hex
#+END_EXAMPLE
** buaathesis
*** BUAAthesis analysis
**** 文件后缀bst cls
+ *cls* (class): 稿件类型文件，可用命令\documentclass调用。
+ *bst*: BibTeX-style-file

**** encoding                                                   :encoding:

多人合作的时候涉及多平台，因而统一编码非常重要。
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
% !mode:: "tex:utf-8"
...
\end{minted}
#+end_latex

**** 模板声明
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \NeedsTeXFormat{LaTeX2e}[2007/10/19]
  \ProvidesClass{buaathesis}
                [2012/07/06 v0.8
  The LaTeX template for thesis of BUAA]
  \typeout{Document Class `buaathesis' v0.8 by BHOSC (2012/07)}

  ...

  \DeclareOption{twoteacher}{\buaa@twoteachertrue}
  % 其余选项传递给ctexbook
  \DeclareOption*{\PassOptionsToClass{\CurrentOption}{ctexbook}}
  \ProcessOptions\relax
  % 引用ctexbook及基本设置
  \LoadClass[cs4size,a4paper,fancyhdr]{ctexbook}[2007/10/19]

  %%%%%%%%%% global package %%%%%%%%%%
  % 全局通用宏包

  \RequirePackage{ifthen}

  \end{minted}
#+end_latex

1. \textbackslash{}NeedsTeXFormat
   specifies which version of TeX or LaTeX is required at least to run
   your package. The optional date may be used to specify the version
   more precisely.

2. \textbackslash{}ProvidesClass
   A package introduces itself using this command.
   1) <name> should be identical to the basename of the file itself.
   2) <version> should should begin with a date in the format
      YYYY/MM/DD. Version information should be kept updated while
      developing a package.

3. \textbackslash{}typeout

4. \textbackslash{}RequirePackage
   is equivalent to \textbackslash{}usepackage.

5. \textbackslash{}DeclareOptions
   are end-user parameters. Each option is declared by one such
   command.

6. \textbackslash{}ExecuteOptions{...}
   tells which are the default.

7. \textbackslash{}ProcessOptions\textbackslash{}relax
   terminates the option processing.

8. \textbackslash{}endinput
   this must be the last command(for package(.sty) not for class(cls)).

**** 选项
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
% 本模板自身包含五个选项
% 前四个为对应学位类型，决定不同样式
% 第五个为颜色选项，用于电子版的情况
\newif\ifbuaa@bachelor\buaa@bachelorfalse
\newif\ifbuaa@master\buaa@mastertrue
\newif\ifbuaa@engineer\buaa@engineerfalse
\newif\ifbuaa@doctor\buaa@doctorfalse
\newif\ifbuaa@color\buaa@colorfalse
\newif\ifbuaa@twoteacher\buaa@twoteacherfalse
\DeclareOption{bachelor}{\buaa@bachelortrue}
\DeclareOption{master}{\buaa@mastertrue}
\DeclareOption{engineer}{\buaa@engineertrue}
\DeclareOption{doctor}{\buaa@doctortrue}
\DeclareOption{color}{\buaa@colortrue}
\DeclareOption{twoteacher}{\buaa@twoteachertrue}
% 其余选项传递给ctexbook
\DeclareOption*{\PassOptionsToClass{\CurrentOption}{ctexbook}}
\end{minted}
#+end_latex

**** 字体与颜色
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \setmainfont{Times New Roman}
  % 不需要设置CJKmainfont，ctex 宏包已经很好的处理了
  % 不仅设置了粗体为黑体，斜体为楷体，还兼容了winfonts和adobefonts
  % 直接设置反而会在只有adobefonts的情况下报错
  % \setCJKmainfont{宋体}
  \setCJKfamilyfont{hwxingkai}{STXingkai}
  \newcommand{\hwxingkai}{\CJKfamily{hwxingkai}}
  \newcommand{\xiaochuhao}{\fontsize{32pt}{\baselineskip}\selectfont}

  %%%%%%%%%% color %%%%%%%%%%
  % 颜色设置

  % 只用于电子版
  \RequirePackage{color}
  \definecolor{dkgreen}{rgb}{0,0.6,0}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \definecolor{mauve}{rgb}{0.58,0,0.82}
  \end{minted}
#+end_latex

1. \textbackslash{}setmintfont
2. \textbackslash{}newcommand{}{}
3. \textbackslash{}{}{}{}

**** 页边距
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \RequirePackage{geometry}
  \newgeometry{
      top=30mm, bottom=25mm, left=30mm, right=20mm,
      headsep=5mm,
  }
  \savegeometry{bachelorgeometry}
  \newgeometry{
      top=25mm, bottom=25mm, left=30mm, right=20mm,
      headsep=5mm, headheight=10mm, footskip=10mm,
  }
  \savegeometry{mastergeometry}

  \ifbuaa@bachelor
      \loadgeometry{bachelorgeometry}
  \else
      \loadgeometry{mastergeometry}
  \fi

  \end{minted}
#+end_latex

+ \textbackslash{}newgeometry
+ \textbackslash{}savegeometry
+ \textbackslash{}if...\textbackslash{}else...\textbackslash{}fi

**** 其它间距

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \renewcommand{\baselinestretch}{1.5}
  \setlength{\parindent}{2em}
  \setlength{\floatsep}{3pt plus 3pt minus 2pt}      % 图形之间或图形与正文之间的距离
  \setlength{\abovecaptionskip}{10pt plus 1pt minus 1pt} % 图形中的图与标题之间的距离
  \setlength{\belowcaptionskip}{3pt plus 1pt minus 2pt} % 表格中的表与标题之间的距离
  \end{minted}
#+end_latex

+ \textbackslash{}renewcommand
+ \textbackslash{}setlength

**** 汉化
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \renewcommand{\contentsname}{目\qquad 录}
  \renewcommand\listfigurename{插\ 图\ 目\ 录}
  \renewcommand\listtablename{表\ 格\ 目\ 录}
  \renewcommand\bibname{参\ 考\ 文\ 献}
  \renewcommand{\figurename}{图}
  \renewcommand{\tablename}{表}
  \end{minted}
#+end_latex

**** 段落格式
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  % 格式
  \CTEXsetup[
      format={\centering\zihao{3}\heiti},
      nameformat={},
      aftername={\quad},
      titleformat={},
      beforeskip={-.5\baselineskip},
      afterskip={\baselineskip},
  ]{chapter}
  \CTEXsetup[
      aftername={\quad},
      beforeskip={.5\baselineskip},
      afterskip={.5\baselineskip},
  ]{section}
  \CTEXsetup[
      format={\zihao{-4}\heiti},
      aftername={\quad},
      beforeskip={.5\baselineskip},
      afterskip={.5\baselineskip},
  ]{subsection}
  \ifbuaa@bachelor
      \CTEXsetup[
          name={,},
          number={\arabic{chapter}},
      ]{chapter}
      \CTEXsetup[
          format={\zihao{-4}\heiti},
      ]{section}
  \else
      \CTEXsetup[
          name={第,章},
          number={\chinese{chapter}},
      ]{chapter}
      \CTEXsetup[
          format={\zihao{4}\heiti},
      ]{section}
  \fi

  \end{minted}
#+end_latex

**** 图片
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  %%%%%%%%%% picture %%%%%%%%%%
  % 图片

  \RequirePackage{graphicx}
  \DeclareGraphicsExtensions{.eps,.ps,.jpg,.bmp}
  \graphicspath{{figure/}}
  \RequirePackage{pifont} % “秘级”后的五角星
  \RequirePackage{subfigure}

  \end{minted}
#+end_latex

**** 列表
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
%%%%%%%%%% list %%%%%%%%%%
% 列表

\RequirePackage{enumitem}
\setlist{noitemsep}
\setlist[1,2]{labelindent=\parindent}
\setlist[enumerate,1]{label=\arabic*、}
\setlist[enumerate,2]{label=（\arabic*）}
\setlist{
    topsep=0pt,
    itemsep=0pt,
    partopsep=0pt,
    parsep=\parskip,
}

\end{minted}
#+end_latex

**** 代码
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  %%%%%%%%%% code %%%%%%%%%%
  % 代码

  % Listing 的设置请参考 http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
  \RequirePackage{listings}
  \lstset{
      backgroundcolor=\color{white},
      basicstyle=\zihao{5}\ttfamily,
      columns=flexible,
      breakatwhitespace=false,
      breaklines=true,
      captionpos=b,
      frame=single,
      numbers=left,
      numbersep=5pt,
      showspaces=false,
      showstringspaces=false,
      showtabs=false,
      stepnumber=1,
      rulecolor=\color{black},
      tabsize=2,
      texcl=true,
      title=\lstname,
      escapeinside={\%*}{*)},
      extendedchars=false,
      mathescape=true,
      xleftmargin=3em,
      xrightmargin=3em,
  }
  \end{minted}
#+end_latex

**** 定理

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  %%%%%%%%%% theorem %%%%%%%%%%
  % 定理

  \theoremsymbol{\ensuremath{\square}}
  \newtheorem*{proof}{证明}
  \theoremstyle{plain}
  \theoremsymbol{}
  \theoremseparator{：}
  \newtheorem{assumption}{假设}[chapter]
  \newtheorem{definition}{定义}[chapter]
  \newtheorem{proposition}{命题}[chapter]
  \newtheorem{lemma}{引理}[chapter]
  \newtheorem{theorem}{定理}[chapter]
  \newtheorem{axiom}{公理}[chapter]
  \newtheorem{corollary}{推论}[chapter]
  \newtheorem{exercise}{练习}[chapter]
  \newtheorem{example}{例}[chapter]
  \newtheorem{remark}{注释}[chapter]
  \newtheorem{problem}{问题}[chapter]
  \newtheorem{conjecture}{猜想}[chapter]
  \end{minted}
#+end_latex

**** 标题

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  %%%%%%%%%% caption %%%%%%%%%%
  % 图表标题

  \RequirePackage{caption}
  \DeclareCaptionFormat{bachelorfigure}{\songti\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{bachelortable}{\heiti\bf\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{bachelorlstlisting}{\songti\bf\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{masterfigure}{\bf\songti\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{mastertable}{\bf\songti\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{masterlstlisting}{\bf\songti\zihao{5}{#1\textrm{#2}#3}}
  \ifbuaa@bachelor
      \captionsetup[figure]{format=bachelorfigure,labelsep=quad}
      \captionsetup[table]{format=bachelortable,labelsep=quad}
      \captionsetup[lstlisting]{format=bachelorlstlisting,labelsep=quad}
      \renewcommand{\thefigure}{\arabic{chapter}.\arabic{figure}}
      \renewcommand{\thetable}{\arabic{chapter}.\arabic{table}}
      \renewcommand{\theequation}{\arabic{chapter}.\arabic{equation}}
  \else
      \RequirePackage{remreset}
      \@removefromreset{table}{chapter}
      \@removefromreset{figure}{chapter}
      %使图表的标号与章节无关
      \captionsetup[figure]{format=masterfigure,labelsep=quad}
      \captionsetup[table]{format=mastertable,labelsep=quad}
      \captionsetup[lstlisting]{format=masterlstlisting,labelsep=quad}
      \renewcommand{\thefigure}{\arabic{figure}}
      \renewcommand{\thetable}{\arabic{table}}
      \renewcommand{\theequation}{\arabic{chapter}.\arabic{equation}}
  \fi
  \end{minted}
#+end_latex

**** 页码
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  % 正文前的页码设置位大写罗马数字
  \renewcommand{\frontmatter}{
      \cleardoublepage
      \@mainmatterfalse
      \ifbuaa@bachelor
          \pagenumbering{Roman}
      \else
          \pagenumbering{roman}
      \fi
  }

  % 保证偶数页结束章节
  \newcommand{\clearemptydoublepage}{%
      \clearpage
      \if@twoside
          \ifodd
              \c@page
          \else
              \hbox{}\thispagestyle{empty}\newpage
              \if@twocolumn
                  \hbox{}\newpage
              \fi
          \fi
      \fi
  }
  \end{minted}
#+end_latex

**** 首页
好长！

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
% 中文首页
\newcommand{\titlech}{
....
}

% 英文首页
\newcommand{\titleeng}{
....
}
\end{minted}
#+end_latex

**** 摘要
#+begin_latex
% 中文摘要
\begin{minted}[frame=single, mathescape]{latex}
\newenvironment{cabstract}{
...
}

% 英文摘要
\newenvironment{eabstract}{
...
}
\end{minted}
#+end_latex

**** 其它
+ 声明
+ 任务书
+ 授权页
+ 用户信息

*** LaTeX 论文

**** 测试 ctex 和 winfonts 选项

#+BEGIN_SRC latex
\documentclass{article}
\usepackage[winfonts]{ctex}
\begin{document}
中文
\end{document}
#+END_SRC

编译有警告，可以生成 PDF

**** 测试 buaathesis 作为 org latex 文类

1. 配置

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-latex-classes
                  '("buaathesis" "\\documentclass{buaathesis}
       [NO-DEFAULT-PACKAGES]
       [NO-PACKAGES]"))
   #+END_SRC

2. 测试 org

   #+BEGIN_SRC org
     ,#+LaTeX_class: buaathesis

     中文
   #+END_SRC

3. 生成 latex

   #+BEGIN_SRC latex
     % Created 2015-12-28 一 10:00
     \documentclass{buaathesis}
     \usepackage[utf8]{inputenc}
     \usepackage[T1]{fontenc}
     \usepackage{fixltx2e}
     \usepackage{graphicx}
     \usepackage{longtable}
     \usepackage{float}
     \usepackage{wrapfig}
     \usepackage{rotating}
     \usepackage[normalem]{ulem}
     \usepackage{amsmath}
     \usepackage{textcomp}
     \usepackage{marvosym}
     \usepackage{wasysym}
     \usepackage{amssymb}
     \usepackage{capt-of}
     \usepackage{hyperref}
     \tolerance=1000
     \usepackage{minted}
     \author{ben}
     \date{\today}
     \title{}
     \hypersetup{
      pdfauthor={ben},
      pdftitle={},
      pdfkeywords={},
      pdfsubject={},
      pdfcreator={Emacs 24.4.1 (Org mode 8.3beta)},
      pdflang={English}}
     \begin{document}

     \tableofcontents

     中文
     \end{document}
   #+END_SRC

4. 分析

   1) 编译 LaTeX 文档，可以生成 PDF，有如下错误(error)

      #+BEGIN_EXAMPLE
        ! LaTeX Error: Option clash for package ulem.
      #+END_EXAMPLE

     原因： ulem宏包选项冲突， org导出的LaTeX文件中默认包含
      =\usepackage[normalem]{ulem}= 与 buaathesis 中设置冲突，注释后无
      错误。

   2) 如何配置 org latex 使其导出的 latex 文件零配置
      - 不默认包含使用各种宏包（OK）
      - 不默认生成目录（手动删除）
      - 不默认生成作者、日期等信息（手动删除）

   3) 导出的标题层次不对, 即 一级标题没有导出为 \chapter

**** 空格

**** 章节条

[[/home/ben/Wally/Journal//Figure/scrot/3959tpl.png]]

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-classes
               '("buaathesis" "\\documentclass{buaathesis}
    [NO-DEFAULT-PACKAGES]
    [NO-PACKAGES]
    [NO-EXTRA]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ))
#+END_SRC
**** 图片
***
**** 论文中如何引用网页

[[/home/ben/Wally/Journal//Figure/scrot/3769ZXh.png]]

[[/home/ben/Wally/Journal//Figure/scrot/3769mhn.png]]

http://tex.stackexchange.com/questions/3587/how-can-i-use-bibtex-to-cite-a-web-page

A simple way of doing it in BibTeX is with a @misc entry:

#+BEGIN_EXAMPLE
@misc{WinNT,
  title = {{MS Windows NT} Kernel Description},
  howpublished = {\url{http://web.archive.org/web/20080207010024/http://www.808multimedia.com/winnt/kernel.htm}},
  note = {Accessed: 2010-09-30}
}
#+END_EXAMPLE

You should also perhaps include an author if you know it. And remember to load a package such as hyperref or url.

If you are using BibLaTeX there is an @online entry type:

#+BEGIN_EXAMPLE
  @online{WinNT,
    author = {MultiMedia LLC},
    title = {{MS Windows NT} Kernel Description},
    year = 1999,
    url = {http://web.archive.org/web/20080207010024/http://www.808multimedia.com/winnt/kernel.htm},
    urldate = {2010-09-30}
  }
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  @misc{ROS,
  title={Robot Operating System},
  howpublished={\url{http://www.ros.org/wiki}},
  note={online}
  }

  @mics{Gazebo,
  title={Gazebo}
  howpublished={\url{http://http://www.gazebosim.org/}},
  note{online}}
#+END_EXAMPLE

*** 参考文献                                               :latex:参考文献:
**** bibtex                                                       :bibtex:
***** 格式

格式如下：
+ 以用{}包含具体内容

  #+BEGIN_EXAMPLE
    @article {name1,
    author = {作者, 多个作者用 and 连接},
    title = {标题},
    journal = {期刊名},
    volume = {卷20},
    number = {页码},
    year = {年份},
    }
#+END_EXAMPLE

+ 也可以直接用双引号“”包含具体内容
  #+BEGIN_EXAMPLE
    @book {name2,
    author ="作者",
    year ="年份2008",
    title ="书名",
    publisher ="出版社名称"
    }
#+END_EXAMPLE

***** bibtex支持的参考文献的条目：

|--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Item　       | 说明                                                                                                                                                                                                                                                                      |
|--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| address      | Publisher's address (usually just the city, but can be the full address for lesser-known publishers)                                                                                                                                                                      |
| annote       | An annotation for annotated bibliography styles                                                                                                                                                                                                                           |
| author       | The name(s) of the author(s) (in the case of more than one author, separated by and )                                                                                                                                                                                     |
| booktitle    | The title of the book, if only part of it is being cited                                                                                                                                                                                                                  |
| chapter      | The chapter number                                                                                                                                                                                                                                                        |
| crossref     | The key of the cross-referenced entry                                                                                                                                                                                                                                     |
| edition      | The edition of a book, long form (such as "first" or "second")                                                                                                                                                                                                            |
| editor       | The name(s) of the editor(s)                                                                                                                                                                                                                                              |
| eprint       | A specification of an electronic publication, often a preprint or a technical report                                                                                                                                                                                      |
| howpublished | How it was published, if the publishing method is nonstandard                                                                                                                                                                                                             |
| institution  | The institution that was involved in the publishing, but not necessarily the publisher                                                                                                                                                                                    |
| journal      | The journal or magazine the work was published in                                                                                                                                                                                                                         |
| key          | A hidden field used for specifying or overriding the alphabetical order of entries (when the "author" and "editor" fields are missing). Note that this is very different from the key (mentioned just after this list) that is used to cite or cross-reference the entry. |
| month        | The month of publication (or, if unpublished, the month of creation)                                                                                                                                                                                                      |
| note         | Miscellaneous extra information                                                                                                                                                                                                                                           |
| number       | The "number" of a journal, magazine, or tech-report, if applicable. (Most publications have a "volume", but no "number" field.)                                                                                                                                           |
| organization | The conference sponsor                                                                                                                                                                                                                                                    |
| pages        | Page numbers, separated either by commas or double-hyphens. For books, the total number of pages.                                                                                                                                                                         |
| publisher    | The publisher's name                                                                                                                                                                                                                                                      |
| school       | The school where the thesis was written                                                                                                                                                                                                                                   |
| series       | The series of books the book was published in (e.g. "The Hardy Boys " or "Lecture Notes in Computer Science ")                                                                                                                                                            |
| title        | The title of the work                                                                                                                                                                                                                                                     |
| type         | The type of tech-report, for example, "Research Note"                                                                                                                                                                                                                     |
| url          | The WWW address                                                                                                                                                                                                                                                           |
| volume       | The volume of a journal or multi-volume book                                                                                                                                                                                                                              |
| year         | The year of publication (or, if unpublished, the year of creation)                                                                                                                                                                                                        |
|--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

**** TeX 参考文献
参考:
+ [[https://app.yinxiang.com/shard/s52/nl/11551545/f5d953dd-91d8-4a1c-8dde-df6de5ba4921/?csrfBusterToken%3DU%253Db04339%253AP%253D%252F%253AE%253D1518f3e68f6%253AS%253Df642656b79ac72e805f2499d73c28c2b][LaTeX 对参考文献的管理]]
+ [[http://xb9he.bokee.com/6688578.html][TeX 参考文献]]

***** bibtex

经常写作论文的人都知道，多篇论文可能引用同一篇参考文献。如果每篇论文都
要键入此一文献，不仅费时，也容易犯错。

BibTeX 是 LaTeX 自带的一个辅助程序，启动时自动加载。它可根据文献引用处
出提供的检索名（如 \ cite{Huetal2000}），搜索一个或多个文献数据库，然后
在文件末尾创建参考文献。如果以后编写其它文件用到相同的参考文献时还可调
用这些文献数据库。图为 BibTeX 的徽标。

[[/home/ben/Wally/Journal/Figure/1503022216.png]]

可通过命令

#+BEGIN_EXAMPLE
  \bibliography{文献数据库名}
  \bibliographystyle{选项}
#+END_EXAMPLE

***** 标准选项
预先设置要检索的文献数据库以及文献引用与文献列表的样式，LaTeX 标准选项
及其样式共有以下8种：

****** plain，按字母的顺序排列，比较次序为作者、年度和标题：
[[~/Wally/Journal/Figure/1503022216-2.png]]

****** unsrt，样式同plain，只是按照引用的先后排序：
[[~/Wally/Journal/Figure/1503022216-3.png]]

****** alpha，用作者名首字母+年份后两位作标号，以字母顺序排序：
[[~/Wally/Journal/Figure/1503022216-4.png]]

****** abbrv，类似plain，将月份全拼改为缩写，更显紧凑：
[[~/Wally/Journal/Figure/1503022216-5.png]]

****** ieeetr，国际电气电子工程师协会期刊样式：
[[~/Wally/Journal/Figure/1503022216-6.png]]

****** acm，美国计算机学会期刊样式：
[[~/Wally/Journal/Figure/1503022216-7.png]]

****** siam，美国工业和应用数学学会期刊样式：
[[~/Wally/Journal/Figure/1503022216-8.png]]

****** apalike，美国心理学学会期刊样式：
[[~/Wally/Journal/Figure/1503022216-9.png]]

文献数据库可根据要求自行编写，其格式有：文章、书籍、技术报告、会议论文
集和博士论文等十几种，每种格式都有一些必填和选填的项目，如作者、标题、
出版社、发表年度、...等等，最后存储为 .bib 文件。

如果对生成的参考文献样式仍有不满意之处，还可将编译信息文件*.bbl 中的参
考文献列表源程序拷贝到论文尾部，然后进行手工调整。

***** bib文件
可以维护一个 bib 文件，在你的整个研究生涯可以只维护这样一个文件，就象
一个数据库，每个参考文献是一个记录，由一个唯一的 ID （例如下面的
MartinDSP00）描述。

比如我的 myreference.bib 文件里一条典型的文献是这样的：
#+BEGIN_EXAMPLE
  @article{MartinDSP00,
       author = "A. Martin and M. Przybocki",
       title = "The {NIST} 1999 speaker recognition evaluation --- an overview",

       journal = "Digital Signal Processing",
       volume = "10",
       pages = "1--18",
       year = "2000",}
#+END_EXAMPLE

其中 {NIST} 中的大括号不会被显示，它的作用是保证将来的生成的参考文献中
NIST 四个字保持原样，不会被小写。

***** 文献库引用

 需要引用文献的时候，在正文里加入：
 #+BEGIN_EXAMPLE
   \bibliographystyle{ieeetr}
   \bibliography{myreference}
 #+END_EXAMPLE

注:  /在正文中使用,而非导言中,一般放在tex文件尾部,在此生成参考文献/

就可以用 *cite{}* 来引用文献库中的论文了，如 cite{MartinDSP00}。上面第
一行是控制文献显示格式的，这个后面再讲。此时，myreference.bib 文件在正
文tex 文件的同一目录下，以保证 LaTeX 可以找到该 bib 文件。

***** 编译

BibTeX 提供了一个外部的 BibTeX 工具程序，源文件经过 LaTeX 编译后，还要
使用BibTeX 对数据库文件编译一次，最后再用 LaTeX 连续编译两遍，才能得到
正确结果。 可用下图解释这四个编译步骤的作用：

[[~/Wally/Journal/Figure/1503022216-A.png]]

1) 编译正文，生成 aux 文件
2) 然后用 bibtex 在当前目录生成 bbl 文件
3) 再编译正文两次，完整的 dvi 就生成了。

这样，LaTeX 保证了所有用 cite 引用到的文献都已被列出，并且自动编号。同
时，如果没有用ocite 命令，LaTeX 还保证所有列出的参考文献都在正文中得到
了引用。

***** bib 文件维护

*bib 文件把 @ 所定义的 entry 之外的所有东西看作是注释。* 比如在上面
@article 的例子里，如果我在大括号之外写些东西的话，bibtex 是不会关心的，
就当它不存在。所以可以把文献的关键字写在这里，将来通过搜索关键字来查找
某些文献。

*更好的选择是使用ORG-MODE进行管理bib文件*

其实也可以搞一个临时的LaTeX 文件，使用ocite{*} 命令，然后编译成 dvi，
这样就得到了一个 bib 文件中所有参考文献的列表，当然是可以按照作者名字
排序的。

另外，很多 journal（学术期刊）或者 booktitle（国际会议）都是重复的，为
了规范化，可以定义缩写，如
#+BEGIN_EXAMPLE
  @string(ICASSP = "Proc. of the International Conference on Acoustics,
          Speech,and Signal Processing (ICASSP)")
#+END_EXAMPLE

这样在执行 bibtex 之后，ICASSP 会被替换成它的全称。
#+BEGIN_EXAMPLE
  @conference{QL.ICA98,
       author = "Qi Li and Biing-Hwang Juang",
       title   = "Speaker Verification Using Verbal Information Verification for Automatic Enrollment",
       booktitle = ICASSP,
       year = "1998",}
#+END_EXAMPLE

***** bib 中的中文文献

中文文献和英文的格式不同，并且使用全角的标点符号，有一点难办。我的解决
办法是这样的：

#+BEGIN_EXAMPLE
  @misc{Xie.1995,
        note = "谢锦辉，《隐 {Markov} 模型及其在语音处理中的应用》，华中理工大学出版社，1995年4月",
        key = "Xie",}

#+END_EXAMPLE

唯一的缺陷是参考文献中最后是以英文的 "." 而不是 "。" 结束的。还好我的

中文文献不多，无伤大雅，否则就 *手工修改一下 bbl 文件* 吧。

***** 关于参考文献的显示格式、排序，及其他

是通过一些 *bst* 文件来控制的。而使用哪种 bst 格式，可通
过 *bibliographystyle* 命令控制。LaTeX 默认提供了这么几种格式，如：
plain、alpha、unsrt。具体意义见相关文档，这些bst 在 texmf/ibtex/st/ase
可被找到。

bst 控制的格式非常细致

+ 排序方式
  - 以正文中引用顺序排序
  - 以文献第一作者的 last name 排序
+ 引用序号是 LaTeX 提供的 ID 还是数字的
+ 作者名字是否用缩写
+ 作者名字放在文献的起始还是结束
+ 文章 title 要不要大小写（即 "Speaker Verification Using ..." 还是 "Speaker verification using "）
+ title 用什么区分（用不用引号括起来，用不用斜体等）
+ 刊物名字的格式（要不要全部大写，要不要粗体，要不要斜体，要不要括起来）
  等等等等。

打开 bst 文件看一下就知道，绝对是想要什么形式，就可以得到什么形式。最
关键的是，在文章定稿之后，完全可以用几个命令重新定义参考文献的格式！

***** 如何定制参考文献的显示格式

其实 bst 文件有很多，总能找到自己需要的。如果这些还不能满足，可以通过
生成自己的 bst 文件来定制。这有两个方法，第一是手写（反正我是写不出来），
第二是通过工具。 *custom-bib* 是一个定制 bst 文件的包，解压缩后用 LaTeX
编译其中的主 tex 文件，便会进行交互式的 bst 定制过程，具体过程我就不讲
了。把生成的自定义的 bst 放到 LaTeX 相应目录下，刷新文件名数据库就可以
使用了。

**** LaTeX 参考文献

***** 参考文献
****** What

参考文献是作者在从事科学研究过程中和在撰写论文中,直接或间接使用他人科
研成果或引用他人学术论著而做的标记.参考文献的内容包括专著及其析出文献,
连续出版物及其析出文献,专利文献和电子文献等文献资料信息.

****** 位置

正文之后,索引之前.

****** 意义

+ 体现科学技术的发展历程及其继承性
+ 尊重和保护他人的著作权
+ 简化论述,缩短论文篇幅
+ 指明理论依据
+ 与读者共享相关信息资源

***** 参考文献环境

标准文类book等都提供可以排版参考文献的 *thebibliography* 的 *列表*环
境, 及在该环境中使用的 *\textbackslash{}bibitem* 文献 *条目* 命令.

#+BEGIN_EXAMPLE
  \begin{thebibliography}{最大序号}
  \bibitem[文献序号]{检索名} 文献信息
    ...
  \end{thebibliography}
#+END_EXAMPLE

参数说明:
+ 最大序号: 测定文献序号最大宽度,通常一位用9,两位用99
+ 文献序号: 可选参数,自行设定文献序号,通常省略
+ 检索名: 正文中 *\textbackslash{}label* 引用文献的唯一标识
+ 文献信息:

注: 不同文类
+ book/report: 使用章命令 \textbackslash{}chapter* 创建以 *Bibliography* 为标题的一章
+ article: 使用节命令 \textbackslash{}section* 生成以 *Reference* 为题的一节

建议: *为了便于记忆和防止混淆,通常采用作者姓氏加上出版年份的后两位作为*
*每个参考文献的检索名.* 如Lamport98

***** 参考文献的引用

如果要在正文中引用参考文献列表中的文献时,可丰引文之后使用 *文献引用命
令 \textbackslash{}cite*

#+BEGIN_EXAMPLE
  \cite[附加信息]{检索名1,检索名2,...}
#+END_EXAMPLE

参考文献的引用也是一种 *交叉引用*, 源文件需多次编译.

***** 引用格式的修改

宏包: *cite*
#+BEGIN_EXAMPLE
  \usepackage[格式]{cite}
#+END_EXAMPLE

***** 文献信息分段

启用文类的 *openlib* 选项.
文献棩中使用 *\newblock* 命令.

**** [[http://purpletulipdyc.blog.sohu.com/259698858.html][引用多个参考文献]]

如果在文章中出现连续引用多个参考文献的情况，希望显示的格式为 [1-9].在
文章的导言区加

#+BEGIN_SRC latex
\usepackage{cite}
#+END_SRC

在文章正文中需要引用参考文献的地方使用：

#+BEGIN_SRC latex
\cite{liu2012, wen13,wang2010VTC,shen2008ICC,Alex2007ICC}
#+END_SRC

**** 不要使用 org-mode 维护 bib 文件

error

#+BEGIN_EXAMPLE
I couldn't open database file /home/ben/Wally/GraduationProject/Thesis/literature.org.bib
#+END_EXAMPLE

**** [[https://app.yinxiang.com/SetAuthToken.action?auth=S%3Ds52%3AU%3Db04339%3AE%3D151a0dccd97%3AC%3D151a0a5df17%3AP%3D195%3AA%3Den-chrome-clipper-xauth-new%3AV%3D2%3AH%3D5522a9e07f0c5aab83cf036e36eb2457&targetUrl=%2Fshard%2Fs52%2Fnl%2F11551545%2F2208e3d2-a67b-4620-bc54-855bfaaf5192%2F][引用参考文献时使用上标]]

1. 默认情况下 LaTeX 不使用上标

   [[/home/ben/Wally/Journal/Figure/scrot/24567oOO.png]]

2. /cite/ 宏包的 /superscript/ 选项

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{latex}
     \usepackage[superscript]{cite}
     \end{minted}
   #+end_latex

   [[/home/ben/Wally/Journal/Figure/scrot/24567c3m.png]]

   没有使用方括号

3. 修改 sty 文件

4. 解决 /BUAAthesis模板中定义得很好/
