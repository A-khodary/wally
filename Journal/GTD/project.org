# project.org

* Prime                                                               :prime:
** Thesis

#+INCLUDE: ~/Wally/GraduationProject/Thesis/literature.org
#+INCLUDE: ~/Wally/GraduationProject/Thesis/julie.org
#+INCLUDE: ~/Wally/GraduationProject/Thesis/thesis.tex
#+INCLUDE: ~/Wally/Project/BUAAthesis

*** ChangLog

1. 2015/12/07 摘要的概要和论文的结构
2. 2015/12/08 开始写LaTeX文档, /先不管不吻合的格式/
3. 2015/12/09 进一步确定了论文结构，但不是缺少些什么，比如自己的算法
4. 2015/12/14
   + 首次尝试编译，参考文献基本没有问题
   + 尝试使用 buaathesis 文类，无果， /org中直接使用一般文类/

** TAGERILL
*** model
1. joint类型为continuous时，显示wheel与base的transform出错，改成fixed则没
   有问题，why?

   continuous 类型joint需要joint_state_publisher发布
   joint_states(sensor_msgs/JointState)

   开启节点： <node name="joint_state_publisher"
   pkg="joint_state_publisher" type="joint_state_publisher" />

   pub: JointState

2. package: robot_state_publisher node: state_publisher ?
   *robot_state_publisher*

*** move_control
**** TODO kobuki.launch.xml  control部分
+ kobuki.launch.xml  control部分
  #+BEGIN_SRC xml
    <launch>
      <arg name="base"/>
      <arg name="stacks"/>
      <arg name="3d_sensor"/>

      <!-- <arg name="urdf_file" default="$(find xacro)/xacro.py '$(find turtlebot_description)/robots/$(arg base)_$(arg stacks)_$(arg 3d_sensor).urdf.xacro'" /> -->
      <arg name="urdf_file" default="$(find xacro)/xacro.py '$(find turtlebot_description)/robots/kobuki_hexagons_kinect.urdf.xacro'" />
      <param name="robot_description" command="$(arg urdf_file)" />

      <!-- Gazebo model spawner -->
      <node name="spawn_turtlebot_model" pkg="gazebo_ros" type="spawn_model"
            args="$(optenv ROBOT_INITIAL_POSE) -unpause -urdf -param robot_description -model mobile_base"/>

      <!-- Velocity muxer -->
      <node pkg="nodelet" type="nodelet" name="mobile_base_nodelet_manager" args="manager"/>
      <node pkg="nodelet" type="nodelet" name="cmd_vel_mux"
            args="load yocs_cmd_vel_mux/CmdVelMuxNodelet mobile_base_nodelet_manager">
        <param name="yaml_cfg_file" value="$(find turtlebot_bringup)/param/mux.yaml" />
        <remap from="cmd_vel_mux/output" to="mobile_base/commands/velocity"/>
      </node>

      <!-- Bumper/cliff to pointcloud (not working, as it needs sensors/core messages) -->
      <include file="$(find turtlebot_bringup)/launch/includes/kobuki/bumper2pc.launch.xml"/>
    </launch>

  #+END_SRC

+ kobuki gazebo
  #+BEGIN_SRC xml
    <gazebo>
      <plugin name="kobuki_controller" filename="libgazebo_ros_kobuki.so">
        <publish_tf>1</publish_tf>
        <left_wheel_joint_name>wheel_left_joint</left_wheel_joint_name>
        <right_wheel_joint_name>wheel_right_joint</right_wheel_joint_name>
        <wheel_separation>.230</wheel_separation>
        <wheel_diameter>0.070</wheel_diameter>
        <torque>1.0</torque>
        <velocity_command_timeout>0.6</velocity_command_timeout>
        <cliff_sensor_left_name>cliff_sensor_left</cliff_sensor_left_name>
        <cliff_sensor_center_name>cliff_sensor_front</cliff_sensor_center_name>
        <cliff_sensor_right_name>cliff_sensor_right</cliff_sensor_right_name>
        <cliff_detection_threshold>0.04</cliff_detection_threshold>
        <bumper_name>bumpers</bumper_name>
        <imu_name>imu</imu_name>
      </plugin>
    </gazebo>
  #+END_SRC

  - 位置：.ckws/devel/lib/libgazebo_ros_kobuki.so
**** 先研究ros_control, 再琢磨自己写控制lib

*** gmapping
+ turtlebot_gazebo gmapping_demo.launch
  #+BEGIN_SRC xml
  <launch>
    <include file="$(find turtlebot_navigation)/launch/includes/gmapping.launch.xml"/>
  </launch>
  #+END_SRC

+ turtlebot_navigation gmapping.launch.xml
  #+BEGIN_SRC xml
      <launch>
      <arg name="scan_topic"  default="scan" />
      <arg name="base_frame"  default="base_footprint"/>
      <arg name="odom_frame"  default="odom"/>

      <node pkg="gmapping" type="slam_gmapping" name="slam_gmapping" output="screen">
        <param name="base_frame" value="$(arg base_frame)"/>
        <param name="odom_frame" value="$(arg odom_frame)"/>
        <param name="map_update_interval" value="5.0"/>
        <param name="maxUrange" value="6.0"/>
        <param name="maxRange" value="8.0"/>
        <param name="sigma" value="0.05"/>
        <param name="kernelSize" value="1"/>
        <param name="lstep" value="0.05"/>
        <param name="astep" value="0.05"/>
        <param name="iterations" value="5"/>
        <param name="lsigma" value="0.075"/>
        <param name="ogain" value="3.0"/>
        <param name="lskip" value="0"/>
        <param name="minimumScore" value="200"/>
        <param name="srr" value="0.01"/>
        <param name="srt" value="0.02"/>
        <param name="str" value="0.01"/>
        <param name="stt" value="0.02"/>
        <param name="linearUpdate" value="0.5"/>
        <param name="angularUpdate" value="0.436"/>
        <param name="temporalUpdate" value="-1.0"/>
        <param name="resampleThreshold" value="0.5"/>
        <param name="particles" value="80"/>
      <!--
        <param name="xmin" value="-50.0"/>
        <param name="ymin" value="-50.0"/>
        <param name="xmax" value="50.0"/>
        <param name="ymax" value="50.0"/>
      make the starting size small for the benefit of the Android client's memory...
      -->
        <param name="xmin" value="-1.0"/>
        <param name="ymin" value="-1.0"/>
        <param name="xmax" value="1.0"/>
        <param name="ymax" value="1.0"/>

        <param name="delta" value="0.05"/>
        <param name="llsamplerange" value="0.01"/>
        <param name="llsamplestep" value="0.01"/>
        <param name="lasamplerange" value="0.005"/>
        <param name="lasamplestep" value="0.005"/>
        <remap from="scan" to="$(arg scan_topic)"/>
      </node>
    </launch>

  #+END_SRC

*** rviz error

自己配置的rviz不但模型不是平面的，而且不会动

使用别人的，这两个问题同时得到了解决。

原因是没有 Listen tf

*** 增加 pan-and-tilt
*** 关于display.launch

#+BEGIN_SRC xml
  <launch>
          <arg name="model" default="$(find xacro)/xacro.py '$(find tagerill_description)/urdf/tagerill.urdf.xacro'"/>
          <arg name="gui" default="False" />
          <param name="robot_description" command="$(arg model)" />
          <param name="use_gui" value="$(arg gui)"/>
          <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher" />
          <node name="robot_state_publisher" pkg="robot_state_publisher" type="state_publisher" />
          <node name="rviz" pkg="rviz" type="rviz" args="-d $(find tagerill_description)/rviz/urdf.rviz" required="true" />
  </launch>
#+END_SRC

Note1: 有时在其它roslaunch中修改了某些ros param, 可能会使模型加载失败

*** kinect

**** 目标
1. 学会在仿真中使用Kinect
   1) 建立urdf模型，并使用rviz显示出来
   2) 在Gazebo中仿真并与ROS通信
2. 测试 depthimage_to_laserscan 以及 nodelet

*** 新的模型 *Holonomic*
**** ROS answer: Holonomic mobile base using Gazebo
+
  http://answers.ros.org/question/30629/holonomic-mobile-base-using-gazebo/


The base platform containing of four wheels, each wheel has 2 degrees
of freedom. It is a holonomic wheel base. There are two motors
connected to each wheel, one is used for steering and the other is
used for driving. The wheel is no deformable planar circle
type. Therefore, each wheel has the capability of steering and driving
independently.


From what I understand, this is the same configuration used by the PR2
and the Care-O-Bot. You can therefore have a look at these packages
for inspiration/reference.

**** PR2 VS Care-O-Bot
Of course,  *PR2*.
****
*** Mecanum

**** how

https://github.com/micpalmia/youbot_ros_tools/issues/5

It's a really interesting simulation issue.

First of all, let's a look at the wheels. They are not standard
wheels, they are mecanum wheels. This kind of wheels help the robot to
move and rotate easily in any directions, even in congested area. The
movement come from the resulting rotation speeds of the wheels, which
are independent. I have found I nice explanation of the relationship
between the wheels rotation and the resulting movement on this lego
page. On the videos, the youBot looks like gliding on the ground.

From a design point of view, this is convenient, because it is similar
to a planar joint + a revolute joint between the base and the
ground. Very easy to control.

From a simulation point of view, it is a nightmare.

I doubt that the repo from youBot or WPI-RAIL did the job, because
they involve casters. And there is no casters on the real KUKA
youBot. If you have a look at their teleop program, you will see that
this program align the wheels before the rotation, which is not the
design of a mecanum wheel at all. With the mesh of the wheels, you
will see it. This not natural (this is also why the wheels solid shape
is a sphere). And even worst, the the rotation is therefore not
supported. So for me, this model is really poor.

I raised the question on Gazebo answers. Someone suggested to use this
planar controller. I considered it as a second choice, but finally,
this is very close to the behavior of the real mecanum wheels, as you
define the x/y velocity and rotation, which can be directly linked to
the wheel individual speeds. I have remove the friction between the
wheels and the ground.

On the real robot, this x/y speed and rotation translation to
individual wheels speeds would also be very convenient.

A visually better solution would be to add the mesh of the wheels, and
rotate them according to the planar messages. No time to work on this.

Finally, if you are looking for a very physical solution, I have found
this link, where it has been done in another simulator, by mixing
kinematics and dynamics solutions.

That would be really great to have more realistic solution. For my
requirement, the planar controller is enough.





*** [pcl::SampleConsensusModelPlane::optimizeModelCoefficients] Not enough inliers found to support a model (0)! Returning the same coefficients.
+
  http://answers.ros.org/question/30909/problem-with-feeding-pointcloud2-messages-from-swissranger-4000-to-octomap-server/


Do you actually need the built-in ground plane filter? For mere map
building there's usually no need and you can set the parameter
~filter_ground to false. By default (in the latest version of
octomap_server), it should be false.

Otherwise you usually need to adjust the PCL plane detection
parameters to your sensor, it is currently tuned to the PR2's stereo
camera by default. Best have a look at the code, not all parameters
are explained on the wiki site in detail.

** wally
*** wally stack

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally/package.xml :src xml

*** wally_bringup

**** package
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_bringup/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_bringup/package.xml :src xml

*** wally_gazebo
**** package

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_gazebo/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_gazebo/package.xml :src xml

**** wally_gazebo.launch
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_gazebo/launch/wally_gazebo.launch :src xml

*** wally_description
**** package

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_description/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_description/package.xml :src xml

**** wally.xacro

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_description/urdf/wally.xacro :src xml

**** display.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_description/launch/display.launch :src xml

***** 测试 node 标签的 doc 属性，进行文档化工作

#+BEGIN_EXAMPLE
  test $ roslaunch --ros-args wally_description display.launch
  Optional Arguments:
    gui (default "false"): undocumented
    model (default "/opt/ros/indigo/share/xacro/xacro.py /home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/wally.xacro"): undocumented
    xacro (default "/home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/wally.xacro"): xacro文件， default '/home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/wally.xacro'

#+END_EXAMPLE

***** 测试 node 标签中的 required 属性

#+BEGIN_EXAMPLE
  test $ rosnode list
  /joint_state_publisher
  /robot_state_publisher
  /rosout
  /rviz
  test $ rosnode kill rviz
  killing /rviz
  killed
  test $ rosnode list
  /rosout
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  ================================================================================
  REQUIRED process [rviz-3] has died!
  process has finished cleanly
  log file: /home/ben/.ros/log/466aa446-9439-11e5-bfff-002186ef9d91/rviz-3*.log
  Initiating shutdown!
  ================================================================================

#+END_EXAMPLE

***** 测试 display 是否对 hokuyo.xacro [嵌套的层不要太多]

失败，hokuyo.xacro本身不会生成完整的urdf文件，除非指定参数alpha为true
*** wally_launch
**** package

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/package.xml :src xml

**** nav

***** move_base

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/move_base.launch :src xml

****** TODO configs <参数含义>

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/base_local_planner_params.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/costmap_common_params.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/global_costmap_params.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/local_costmap_params.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/nav_obstacles_params.yaml :src yaml

**** gmapping.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/gmapping.launch :src xml

**** sim.launch
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/sim.launch :src xml

** Julie

*** ChangeLog
+ 2015/12/16 增加 ChangeLog
+ 2015/12/16 Hector SLAM中增加 IMU， OK
*** Thoughts on ROS
+ 不一定非要以源码方式安装package, *只有需要深入研究并借鉴的才使用源码
  安装* -> 精简
*** Problems
**** TODO 编译 gazebo_ros_package 失败
‘Q_WS_WIN’ was not declared in this scope

TODO 暂时不管
*** Stack: Julie
*** Metapackage                                               :metapackage:

[2015-11-24 周2 19:09]

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie/package.xml :src xml :lines "9-"

元包(Metapackage)是一种特殊的包，它不包含任何代码、文件或其它常见的条
目。它仅仅是简单的引用一个或几个相关松散耦合的包。

It is often convenient to group multiple packages as a single logical
package. This can be accomplished through metapackages. A metapackage
is a normal package with the following export tag in the package.xml:
*<metapackage />*

#+begin_latex
\begin{minted}[frame=single, mathescape]{xml}
 <export>
   <metapackage />
 </export>
\end{minted}
#+end_latex

Other than a required <buildtool_depends> dependency on catkin,
metapackages can only have run dependencies on packages of which they
group.

Additionally a metapackage has a required, boilerplate CMakeLists.txt
file: *catkin_metapackage()*

#+begin_latex
\begin{minted}[frame=single, mathescape]{xml}
cmake_minimum_required(VERSION 2.8.3)
project(<PACKAGE_NAME>)
find_package(catkin REQUIRED)
catkin_metapackage()
\end{minted}
#+end_latex
Note: replace <PACKAGE_NAME> with the name of the metapackage.

boilerplate: 样板，所谓样板，是指一尘不变，使用catkin_create_package命
令生成的CMakeLists.txt文件会有 *多余* 的配置，导致编译时失败。

/This workspace contains non-catkin packages in it, and catkin cannot build  a non-homogeneous workspace without isolation.  Try the 'catkin_make_isolated' command instead./

*** julie_bringup

*** julie_description
CLOCK: [2015-11-25 三 14:39]--[2015-11-25 三 14:49] =>  0:10

**** package management
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/package.xml :src xml
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/CMakeLists.txt :src cmake


***** 手记                                                       :catkin:
使用 catkin_create_pkgs 命令生成的 package 配置文件中除基本信息外，添
加了以下信息

1. package.xml 中的 *find_package()*
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{cmake}
       find_package(catkin REQUIRED COMPONENTS
         tf
         urdf
       )
     \end{minted}
   #+end_latex
2. CMakeLists.txt 中的 *<build_depend>* 和 *<run_depend>*
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
     <build_depend>urdf</build_depend>
     <run_depend>urdf</run_depend>
     \end{minted}
   #+end_latex


#+BEGIN_EXAMPLE
  tmp $ catkin_create_pkg test urdf tf
  Created file test/package.xml
  Created file test/CMakeLists.txt
  Successfully created files in /tmp/test. Please adjust the values in package.xml.
  tmp $ ls test
  CMakeLists.txt  package.xml
  tmp $ cat test/CMakeLists.txt | grep urdf
    urdf
  #  CATKIN_DEPENDS tf urdf
  tmp $ cat test/package.xml | grep urdf
    <build_depend>urdf</build_depend>
    <run_depend>urdf</run_depend>

#+END_EXAMPLE

**** urdf

#+BEGIN_SRC sh :results output :exports both
ls -l ~/Wally/Project/catkin_ws/src/julie/julie_description
#+END_SRC

#+RESULTS:
: 总用量 24
: -rw-rw-r-- 1 ben ben  111 11月 25 14:34 CMakeLists.txt
: drwxrwxr-x 2 ben ben 4096 11月 27 16:44 launch
: drwxrwxr-x 2 ben ben 4096 11月 27 16:46 meshes
: -rw-rw-r-- 1 ben ben  435 11月 25 14:20 package.xml
: drwxrwxr-x 2 ben ben 4096 11月 26 19:59 test
: drwxrwxr-x 2 ben ben 4096 11月 26 22:41 urdf

***** emacs auto-mode-alist
#+begin_latex
\begin{minted}[frame=single, mathescape]{lisp}
(add-to-list 'auto-mode-alist '("\\.xacro\\'" . nxml-mode))
(add-to-list 'auto-mode-alist '("\\.urdf\\'" . nxml-mode))
\end{minted}
#+end_latex

***** common_properties.xacro

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/urdf/common_properties.xacro :src xml


***** hokuyo.xacro
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/urdf/hokuyo.xacro :src xml


****** Trick 增加test文件夹用于测试，内部文件使用链接形式        :trick:

****** test
*$ rosrun xacro xacro.py test/hokuyo.xacro alpha:=true -o hokuyo.urdf*

+ 传递命令行参数
+ -o 指定输出文件名

*$ check_urdf hokuyo.urdf*

#+BEGIN_EXAMPLE
  robot name is: sensor_hokuyo
  ---------- Successfully Parsed XML ---------------
  root Link: base_link has 1 child(ren)
      child(1):  hokuyo_link_link
#+END_EXAMPLE

****** TODO 中文注释问题
UnicodeEncodeError: 'ascii' codec can't encode characters in position
464-471: ordinal not in range(128)

xacro.py 文件编码没有问题，

-> 那问题就是 *XML编码* ？

好的推断，但不对！

Pyhont 中 file.write() 方法的编码问题， /暂时解决不了/

*XML文件要有必要的注释，所以暂时使用英文注释*



****** error
1. xacro.XacroException: Property wasn't defined: u'_parent'

   property 使用 property定义， arg传递的是命令行参量(xacro.py)。

2. xacro.XacroException: Property parent recursively used

   macro中使用的参数名称不能与已经定义的property相同

***** microstrain.xacro

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/urdf/microstrain.xacro :src xml

类似 hokuyo.acro

***** TODO julie.xacro

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/urdf/julie.xacro :src xml

#+BEGIN_EXAMPLE
  $ check_urdf julie.urdf
  robot name is: julie
  ---------- Successfully Parsed XML ---------------
  root Link: base_footprint has 1 child(ren)
      child(1):  base_link
          child(1):  imu_link
          child(2):  lidar_link
#+END_EXAMPLE

**** launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/launch/display.launch :src xml

*** julie_gazebo

CLOCK: [2015-11-26 四 14:31]--[2015-11-26 四 16:21] =>  1:50
**** note

*ROS Jade is using the gazebo-5.x series* Jade有更多的特性，可以尝试。

**** gazebo_world
***** empty_world.launch
****** launch
#+include: ~/Wally/Project/catkin_ws/src/julie/julie_gazebo/launch/empty_world.launch :src xml

#+BEGIN_EXAMPLE
  julie_gazebo $ roslaunch gazebo_ros
  empty_world.launch         shapes_world.launch
  mud_world.launch           willowgarage_world.launch
  rubble_world.launch
#+END_EXAMPLE

****** gazebo_ros args
******* gzserver 命令行选项
*$ gzserver --help*

#+BEGIN_EXAMPLE
gzserver -- Run the Gazebo server.

`gzserver` [options] <world_file>

Gazebo server runs simulation and handles commandline options, starts
a Master, runs World update and sensor generation loops.


Options:
  -q [ --quiet ]                Reduce output to stdout.
  -h [ --help ]                 Produce this help message.
  -u [ --pause ]                Start the server in a paused state.
  -e [ --physics ] arg          Specify a physics engine
                                (ode|bullet|dart|simbody).
  -p [ --play ] arg             Play a log file.
  -r [ --record ]               Record state data.
  --record_encoding arg (=zlib) Compression encoding format for log data
                                (zlib|bz2|txt).
  --record_path arg             Absolute path in which to store state data
  --seed arg                    Start with a given random number seed.
  --iters arg                   Number of iterations to simulate.
  --minimal_comms               Reduce the messages output by gzserver
  -s [ --server-plugin ] arg    Load a plugin.
#+END_EXAMPLE

******* gazebo_ros 结点

$ rosrun gazebo_ros

#+BEGIN_EXAMPLE
debug        gdbrun       gzserver     spawn_model
gazebo       gzclient     perf
#+END_EXAMPLE

******* empty_world.launch 命令行参数含义

1. gui: *gzclient*

   Launch the user interface window of Gazebo (default true)

2. paused: gzserve -u

   Start Gazebo in a paused state (default false)
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
       <arg unless="$(arg paused)" name="command_arg1" value=""/>
       <arg     if="$(arg paused)" name="command_arg1" value="-u"/>
     \end{minted}
   #+end_latex

3. headless: gzserver -r

   Disable any function calls to simulator rendering (Ogre)
   components. Does not work with gui:=true (default false)

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
       <arg     if="$(arg headless)" name="command_arg2" value="-r"/>
       <arg unless="$(arg verbose)" name="command_arg3" value=""/>
     \end{minted}
   #+end_latex

4. debug: gzserver/debug

   Start gzserver (Gazebo Server) in debug mode using gdb (default
   false)

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
       <arg unless="$(arg debug)" name="script_type" value="gzserver"/>
       <arg     if="$(arg debug)" name="script_type" value="debug"/>
     \end{minted}
   #+end_latex

5. verbose: gzserve --verbose

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
       <arg unless="$(arg verbose)" name="command_arg3" value=""/>
       <arg     if="$(arg verbose)" name="command_arg3" value="--verbose"/>
     \end{minted}
   #+end_latex

6. usesimtime(gazebo)

   Tells ROS nodes asking for time to get the Gazebo-published
   simulation time, published over the ROS topic /clock (default true)

7. respawn: roslaunch node arguments

8. output: roslaunch node arguments

****** $GAZEBO_RESOURCE_PATH
#+BEGIN_SRC sh :results output :exports both
echo $GAZEBO_RESOURCE_PATH
#+END_SRC

#+RESULTS:
:

+ ~/.gazebo
+ /usr/share/gazebo-2.2/

****** empty.world

#+INCLUDE: /usr/share/gazebo-2.2/worlds/empty.world

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_gazebo/worlds/empty.world

****** 小结

理清了通过gazebo_ros启动Gazebo的最基本的launch。

***** julie_world.launch
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_gazebo/launch/julie_gazebo.launch :src xml

****** spawn_model arguments

~ $ *rosrun gazebo_ros spawn_model -h*

#+BEGIN_EXAMPLE
  spawn_model script started
  Commands:
      -[urdf|sdf|trimesh|gazebo] - specify incoming xml is urdf, sdf or trimesh format. gazebo arg is deprecated in ROS Hydro
      -[file|param|database] [<file_name>|<param_name>|<model_name>] - source of the model xml or the trimesh file
      -model <model_name> - name of the model to be spawned.
      -reference_frame <entity_name> - optinal: name of the model/body where initial pose is defined.
                                       If left empty or specified as "world", gazebo world frame is used.
      -gazebo_namespace <gazebo ros_namespace> - optional: ROS namespace of gazebo offered ROS interfaces.  Defaults to /gazebo/ (e.g. /gazebo/spawn_model).
      -robot_namespace <robot ros_namespace> - optional: change ROS namespace of gazebo-plugins.
      -unpause - optional: !!!Experimental!!! unpause physics after spawning model
      -wait - optional: !!!Experimental!!! wait for model to exist
      -trimesh_mass <mass in kg> - required if -trimesh is used: linear mass
      -trimesh_ixx <moment of inertia in kg*m^2> - required if -trimesh is used: moment of inertia about x-axis
      -trimesh_iyy <moment of inertia in kg*m^2> - required if -trimesh is used: moment of inertia about y-axis
      -trimesh_izz <moment of inertia in kg*m^2> - required if -trimesh is used: moment of inertia about z-axis
      -trimesh_gravity <bool> - required if -trimesh is used: gravity turned on for this trimesh model
      -trimesh_material <material name as a string> - required if -trimesh is used: E.g. Gazebo/Blue
      -trimesh_name <link name as a string> - required if -trimesh is used: name of the link containing the trimesh
      -x <x in meters> - optional: initial pose, use 0 if left out
      -y <y in meters> - optional: initial pose, use 0 if left out
      -z <z in meters> - optional: initial pose, use 0 if left out
      -R <roll in radians> - optional: initial pose, use 0 if left out
      -P <pitch in radians> - optional: initial pose, use 0 if left out
      -Y <yaw in radians> - optional: initial pose, use 0 if left out
      -J <joint_name joint_position> - optional: initialize the specified joint at the specified value
#+END_EXAMPLE

****** $() ${} *不要混淆*

error: ${alpha} is not a 'bool' type

在 launch 文件中， 使用 $() <dollor圆括号> 替换， 仅此一个

在 xacro 文件中， 使用 ${} <dollor花括号> 进行引用属性或者数学运算，使
用 $() 进行命令行参数传递。

****** 文件与文件夹命名要有规范

#+BEGIN_EXAMPLE
  Error [SystemPaths.cc:367] File or path does not exist
  ["/home/ben/Wally/Project/catkin_ws/src/julie/julie_gazebo/world/empty.world"]
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  $ ls ~/.gazebo/ | grep world
  worlds
#+END_EXAMPLE

****** 手记
******* test as a whole: ok

#+BEGIN_EXAMPLE
$ roslaunch julie_gazebo julie_gazebo.launch
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  test $ rosnode list
  /gazebo
  /rosout
  test $ rostopic list
  /clock
  /cmd_vel
  /gazebo/link_states
  /gazebo/model_states
  /gazebo/parameter_descriptions
  /gazebo/parameter_updates
  /gazebo/set_link_state
  /gazebo/set_model_state
  /imu_data
  /lidar_scan
  /odom
  /rosout
  /rosout_agg
  /tf
#+END_EXAMPLE

******* test lidar/imu
******** $() 不允许嵌套

#+begin_latex
\begin{minted}[frame=single, mathescape]{xml}
<param     if="$(arg alpha)" name="robot_description" command="$(arg $(arg sensor}_model)" />
\end{minted}
#+end_latex
error:

*Dollar signs '$' cannot be inside of substitution args [$(arg $(arg
sensor}_model)]*

******** 修改： 组合使用 if/unless/group 实现多重条件

#+begin_latex
  \begin{minted}[frame=single, mathescape]{xml}
    <param unless="$(arg alpha)" name="robot_description" command="$(arg robot_model)" />
    <group     if="$(arg alpha)">
    <param unless="$(arg test)" name="robot_description" command="$(arg imu_model)" />
    <param     if="$(arg test)" name="robot_description" command="$(arg lidar_model)" />
    </group>
  \end{minted}
#+end_latex

******** lidar： ok

#+BEGIN_EXAMPLE
$ roslaunch julie_gazebo julie_gazebo.launch alpha:=true
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  test $ rosnode list
  /gazebo
  /rosout
  test $ rostopic list
  /clock
  /gazebo/link_states
  /gazebo/model_states
  /gazebo/parameter_descriptions
  /gazebo/parameter_updates
  /gazebo/set_link_state
  /gazebo/set_model_state
  /hokuyo_scan
  /rosout
  /rosout_agg
  test $
#+END_EXAMPLE

******** imu: ok,  test参数取名不好

#+BEGIN_EXAMPLE
test $ roslaunch julie_gazebo julie_gazebo.launch alpha:=true test:=false
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  test $ rostopic list
  /clock
  /gazebo/link_states
  /gazebo/model_states
  /gazebo/parameter_descriptions
  /gazebo/parameter_updates
  /gazebo/set_link_state
  /gazebo/set_model_state
  /imu_data
  /rosout
  /rosout_agg
#+END_EXAMPLE

**** gazebo_rviz: 尽量地减少不同模块的耦合

*** julie_launch
**** pkg
julie_launch 主要包含了一些launch文件，主要以下配置文件

|-------------------------+----------------------------+-------------|
| Sensors                 | package                    | node        |
|-------------------------+----------------------------+-------------|
| hokuyo UTM30(Lidar)     | hokuyo_node                | hokuyo_node |
| microstrain 3GMS25(IMU) | microstrain_3dmgx2_imuNode | imu_node    |
|-------------------------+----------------------------+-------------|

**** hokuyo.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/hokuyo.launch :src xml

1. hokuyo connecting
2. hokuyo parameters setting
3. roslaunch if/unless

测试OK。

**** microstrain.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/microstrain.launch :src xml

IMU 有个初始化的过程，需要几秒钟的时间。

***** TODO 姿态似乎并不是很准 why?

1. 传感器输出的是什么数据？
2. ROS用的是什么消息，定义的是什么内容？
3. 如果需要校正，如何处理？

#+BEGIN_EXAMPLE
  header:
    seq: 1956
    stamp:
      secs: 1448536768
      nsecs: 743254578
    frame_id: imu_link
  orientation:
    x: 0.998275596255
    y: -0.0579387949886
    z: -0.00247682392276
    w: 0.00910004910749
  orientation_covariance: [0.0012250000000000002, 0.0, 0.0, 0.0, 0.0012250000000000002, 0.0, 0.0, 0.0, 0.0012250000000000002]
  angular_velocity:
    x: -0.000441648298874
    y: 0.000969532527961
    z: 0.00244149100035
  angular_velocity_covariance: [0.000144, 0.0, 0.0, 0.0, 0.000144, 0.0, 0.0, 0.0, 0.000144]
  linear_acceleration:
    x: -0.049793684483
    y: 0.180994773722
    z: -9.81023545727
  linear_acceleration_covariance: [0.009604000000000001, 0.0, 0.0, 0.0, 0.009604000000000001, 0.0, 0.0, 0.0, 0.009604000000000001]
#+END_EXAMPLE

**** lidar_sim.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/lidar_sim.launch :src xml

**** imu_sim.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/imu_sim.launch :src xml

OK， 证明 rviz.launch 可行

**** rviz.launch

仅可视化激光数据，用于测试传感器或仿真，一般需要被其他launch文件包含。

1. 匿名rviz
2. config arg

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/rviz.launch :src xml

**** hector slam

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/hector.launch :src xml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/hector_with_imu.launch :src xml

1. /map_size/ 的大小会影响实时性，所以不能太大
2. hector_imu_attitude_to_tf 的 /API/ 消息和参数的命名和 /remap/
   [[file:~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/hector_with_imu.launch::<node%20pkg%3D"hector_imu_attitude_to_tf"%20type%3D"imu_attitude_to_tf_node"%20name%3D"imu_attitude_to_tf_node"%20][hector_imu_attitude_to_tf]]

**** map merge

http://answers.ros.org/question/133486/how-can-i-merge-some-maps/

https://github.com/tu-darmstadt-ros-pkg/mapstitch

**** julie.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/julie.launch :src xml

**** sim.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/sim.launch :src xml

[[~/Wally/Journal/Figures/scrot/30792uVs.png]]

**** teleop_key.py

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/scripts/teleop_key.py :src python

发送命令 /cmd_vel 给 plannar_move_plugin

最好在单独一个窗口，因为需要交互。

***** sys, select, termios, tty
#+begin_latex
\begin{minted}[frame=left, mathescape]{py}
import sys, select, termios, tty
\end{minted}
#+end_latex

*优先查阅手册*

****** termios:Low-level terminal control interface.           :termios:

This module provides an interface to the POSIX calls for tty I/O
control.

All functions in this module take a *file descriptor fd* as their first
argument. This can be an integer file descriptor, such as returned by
*sys.stdin.fileno()*, or a file object, such as *sys.stdin* itself.

[[/home/ben/Wally/Journal/Figures/scrot/4904FSb.png]]

******* example
#+INCLUDE: ~/Wally/Journal/Project/Python/termios/test.py :src python

输入密码时不可见

****** tty:Terminal control functions                              :tty:

The *tty* module defines functions for putting the tty into cbreak and
raw modes.

1. what is tty?
2. what is cbreak mode?
3. what is raw mode?

+Because it requires the termios module, it will work only on Unix+

[[/home/ben/Wally/Journal/Figures/scrot/4904TrQ.png]]

****** 终端模式                                                   :term:

终端I/O有两种不同的工作方式：
1. 规范方式输入处理。在这种方式中，终端输入以行为单位进行处理。对于每
   个读要求，终端驱动程序最多返回一行。
2. 非规范方式输入处理。输入字符不以行为单位进行装配。

如果不作特殊处理，则默认方式是规范方式。

V7和BSD类的终端驱动程序支持三种终端输入方式：
+ 精细加工方式(输入装配成行，并对特殊字符进行处理)；
+ 原始方式(输入不装配成行，也不对特殊字符进行处理)；
+ cbreak方式(输入不装配成行，但对某些特殊字符进行处理)。

******* reference

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/3300d5e1-d8a3-48df-8ff1-bc4be441f46d?title=%E7%BB%88%E7%AB%AFI%2FO%20termios%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%20tcsetattr%E8%AE%BE%E7%BD%AE%20-%20dartagnan%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD][CNDS: 终端I/O termios属性设置 tcsetattr]]
****** select: waiting for I/O completion                       :select:

This module provides access to the *select()* and *poll()* functions
available in most operating systems, epoll() available on Linux 2.5+
and kqueue() available on most BSD. Note that on Windows, it only
works for sockets; on other operating systems, it also works for other
file types (in particular, on Unix.

[[/home/ben/Wally/Journal/Figures/scrot/4904tNF.png]]

****** dict
#+begin_latex
  \begin{minted}[frame=left, mathescape]{py}
  moveBindings = {
          'i':(1,0),
          'o':(1,-1),
          'j':(0,1),
          'l':(0,-1),
          'u':(1,1),
          ',':(-1,0),
          '.':(-1,1),
          'm':(-1,-1),
             }

  speedBindings={
          'q':(1.1,1.1),
          'z':(.9,.9),
          'w':(1.1,1),
          'x':(.9,1),
          'e':(1,1.1),
          'c':(1,.9),
            }
  \end{minted}
#+end_latex

****** def get_key()

#+begin_latex
  \begin{minted}[frame=left, mathescape]{py}
  def getKey():
      tty.setraw(sys.stdin.fileno())
      rlist, _, _ = select.select([sys.stdin], [], [], 0.1)
      if rlist:
          key = sys.stdin.read(1)
      else:
          key = ''

      termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
      return key

  speed = 0.75
  turn = 1
  \end{minted}
#+end_latex

1. setraw 设置为原始模式

2. rlist: wait until ready for reading

****** ros related

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{py}
      rospy.init_node('teleop')
      pub = rospy.Publisher('/cmd_vel', Twist, queue_size=5)

      ...

      twist = Twist()
      twist.linear.x = control_speed; twist.linear.y = 0; twist.linear.z = 0
      twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = control_turn
      pub.publish(twist)
  \end{minted}
#+end_latex

****** speed control logic
#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{py}
          while(1):
              key = getKey()
              if key in moveBindings.keys():
                  x = moveBindings[key][0]
                  th = moveBindings[key][1]
                  count = 0
              elif key in speedBindings.keys():
                  speed = speed * speedBindings[key][0]
                  turn = turn * speedBindings[key][1]
                  count = 0

                  print vels(speed,turn)
                  if (status == 14):
                      print msg
                  status = (status + 1) % 15
              elif key == ' ' or key == 'k' :
                  x = 0
                  th = 0
                  control_speed = 0
                  control_turn = 0
              else:
                  count = count + 1
                  if count > 4:
                      x = 0
                      th = 0
                  if (key == '\x03'):
                      break

              target_speed = speed * x
              target_turn = turn * th

              if target_speed > control_speed:
                  control_speed = min( target_speed, control_speed + 0.02 )
              elif target_speed < control_speed:
                  control_speed = max( target_speed, control_speed - 0.02 )
              else:
                  control_speed = target_speed

              if target_turn > control_turn:
                  control_turn = min( target_turn, control_turn + 0.1 )
              elif target_turn < control_turn:
                  control_turn = max( target_turn, control_turn - 0.1 )
              else:
                  control_turn = target_turn

              twist = Twist()
              twist.linear.x = control_speed; twist.linear.y = 0; twist.linear.z = 0
              twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = control_turn
              pub.publish(twist)

  \end{minted}
#+end_latex

****** try

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{py}
    try:
        ...
    except:
        print e
   finally:
        twist = Twist()
        twist.linear.x = 0; twist.linear.y = 0; twist.linear.z = 0
        twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = 0
        pub.publish(twist)
  \end{minted}
#+end_latex

**** bagfile
#+INCLUDE: ~/Wally/Project/catkin_ws/bagfile/

**** rosbag 不是一个包，不能在 launch file中启动

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/bag.launch :src xml

**** TODO laser_filter.launch
- State "TODO"       from ""           [2015-12-15 二 16:51] \\
  laser_filters 能够运行，接收和发布的话题配置也正确，只是发布的话题为空，
  不知为何

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/laser_filter.launch :src xml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/config/laser_filter.yaml :src yaml

** Navigator
*** Navigator Manul
**** 操作注意事项
+ 开机，四伺服处于闭环状态，锁死电机，勿动
+ 每月充电，保证电池性能
+ 载重小于80Kg
**** 特点
Navigator Q2 是四轮 45 度全向轮轮系的机器人平台, 使用航发
公司的 QMA-15 全向轮,与传统轮系相比,能够实现平移、自转、平
移并自转等特殊运动。
**** 性能指标
+ 驱动方式： 四轮独立驱动
+ *悬挂形式：液压阻尼避震器悬挂* ???
+ 负载：80KG
+ 电机类型： *空心杯直流伺服电机*
+ 电机额定功率： 90W
+ 电机编码器： 500线/转，A、B相输出
+ 电机驱动： 伺服驱动器，CAN总线，RS232通信接口
+ 最大移动速度： 1.2m/s
+ 最大自转速度：145°/s
+ 最小转弯半径：0
+ 电池 24V/18.2Ah锂电池

**** 电机驱动器

美国Copley Control公司 *ACJ-055-18* 高性能直流伺服驱动器


#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:21:43
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_10:21:43.png]]

**** 电路硬件

***** 16路超声测距传感器板

***** 电源板

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:28:25
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_10:28:25.png]]

+ 24V
+ 12V
+ 5V


#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:30:33
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_10:30:33.png]]
通信方式
+ CAN总线
+ UART串口，TTL电平

***** 运动控制卡

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:31:21
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_10:31:21.png]]

1. 运动控制方式
   + 步进电机方式？？
   + CAN总线（独立）
   + 串口命令方式

2. 模式
   + 速度模式：接收命令后立即执行，没有后续命令则持续到设置默认时间结
     束
   + 位置模式：先保存到命令队列，收到开始命令后才按顺序执行

***** 主控板
1. *STM32F407VE*
   + 32位
   + ARM Cortex-M4F
   + 168M主频
   + 210MIPS
   + 512K FLASH
   + 196K SRAM
   + LQFP 封装

2. 资源
   + 两个RS232电平UART串口
     - 一个可以直接连接到PC串口
     - 一个以3Pin白端子连接到其他设备
   + 一个TTL电平的UART串口，可以连接其它需要控制端的设备
   + 一个RS485接口
   + 一个TF卡接口，使用SPI总线
   + 一个TFT LCD接口，使用FSMC，带SPI接口，和TF卡接口共用
   + 两路CAN总线接口
   + 8个ADC输入
   + 两个DAC输出
   + 8个PWM输出
   + 一个I2C接口，和PWM2，PWM3复用
   + 标准20针JTAG接口

3. 尺寸：86mm*100mm

***** OFPS定位模块
+ 短时间内对机器人运动轨迹进行辅助定位
+ 三个码盘
+ CAN总线和UART串口
+ STM32F4


#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:52:04
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_10:52:04.png]]

***** Pathfinder遥控器

*** RHF407
**** 处理器
***** 时钟、启动与复位
+ 主时钟： 25M无源晶振
+ 启动方式： BOOT0接地，总是从用户FLASH启动
+ 备份电源：使用可充电纽扣锂电池
+ 复位电路：SP809芯片
  #+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:14:04
  [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_11:14:04.png]]
***** JTAG
JTAG: JTAG254-10x2
#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:25:53
[[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_11:25:53.png]]

***** 电源电路
#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:37:35
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_11:37:35.png]]

+ D1 SS14 反压保护
+ LM1117-3.3稳压
+ FB1/FB2磁珠滤波给模拟电路供电

***** LED 指示灯

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:42:53
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_11:42:53.png]]

使用 *倒灌式* 连接

***** 按键电路

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:43:58
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_11:43:58.png]]

+ 外部上拉
+ 电容滤波
***** RS232串口
*MAX3232*
#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:44:54
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_11:44:54.png]]

+ 2路
+ 一路串口接到DB9孔式插座
+ 一路接到端子插座

***** TTL串口电路

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:07:55
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_14:07:55.png]]

直接从处理器连接到端子，同时提供3whIO口线作控制用。

***** RS485电路
*SP3485* or *MAX3485* 电平转换
#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:09:54
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_14:09:54.png]]

JP7的1，2引脚短路时使用终端阻抗匹配电阻

***** CAN总线电路

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:21:32
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_14:21:32.png]]

驱动芯片 *SN65HBD230*

***** USB

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:22:57
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_14:22:57.png]]

+ 处理器有两路USB，这是使用全速OTG端口
+ 作为主机时应用不多，仅做从机。

***** TF卡

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:25:02
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_14:25:02.png]]

TF卡使用SPI总线连接方式，各种信号都外接上拉电阻。

***** LCD

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:26:46
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_14:26:46.png]]

接口兼容神州王3.2寸TFT模块。

***** ADC

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:28:18
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_14:28:18.png]]

直接接到处理器口线上，使用时必须保证不能超过处理器的极限条件以损坏处理
器，否则输入前需要添加保护电路。

***** DAC

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:31:02
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_14:31:02.png]]
处理器线口直接输出，还可以做ADC使用。

***** PWM

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:32:04
 [[~/Wally/Journal/Figures/Navigator/screenshot_2015-06-29_14:32:04.png]]

处理器接口直接输出，可以接舵机或其它设备。


**** 开发环境

+ MDK：ARM7, ARM9, 部分Cortex
+ IAR：ARM11, Cortex-A9

+ 基于GNU的：emIDE

**** 芯片

***** AMS1117电源转换
1. Features
   + dropout voltage 1.2v 压差
   + Line regulation 0.2% max
   + Load regulation 0.4% max
   + Current limiting and Thermal Protection
   + Adjustable Output Voltage or Fixed 1.25V, 1.5V, 1.8V, 2.5V, 2.85V, 3.3V, 5V
   + Maxumum Input Voltage 15V


***** STM32F407VE

****** ICP & IAP
1. *in-circuit programming(ICP)*
   + JTAG
   + SWD
   + the boot loader
2. *in-application programming(IAP)* can use any communication
   interface supported by the microcontroller(I/Os, USB, CAN, UART,
   I2C, SPI, etc.) to download data into memory,  With IAP, the Flash
   memory can be reprogrammed while the application is running,
   Nevertheless, part of the application has to have been previously
   programmed in the Flash memory using ICP

****** Glossary
+ The CPU nitegrates two debug ports:
  - *JTAG debug port(JTAG-DP)* provides a 5-pin standard interface
    based on the *Joint Test Action Group(JTAG)* protocal
  - *SWD debug port(SWD-DP)* provides a 2-pin(clock and data)
    interface based on the *Serial Wire Debug* protocal
+ *word*: data/instruction of 32-bit length
+ *Half world*: data/instruction of 16-bit length
+ *Byte*: data of 8-bit length
+ *Double word*: data of 64-bit length
+ *IAP(in-application programming)*: IAP is the ability to reprogram
  the Flash memory of a microcontroller while the user program is running.
+ *ICP(in-circuit programming)*: ICP is the ability to program the
  Flash memory of a microcontroller using the JTAG protocol, the SWD
  protocol or the bootloader while the device is mounted on the user
  application board.
+ *I-Code*: this bus connects the Instruction bus of the CPU core to
  the instruction interface. Prefetch is performed on this bus.
+ *D-Code*: this bus connects the D-Code bus(literal load and debug
  access) of the CPU to the Flash data interface.
+ *OBL*: option byte loader
+ *AHB*: advanced high-preformance bus

*****

*** CAN
*CAN(Controller Area Network)* 控制器局域网

CAN总线是唯一成为国际标准的现场总线，也是国际上应用最为广泛的现场总线
之一。

+ 成本低
+ 传输距离远(<10Km)
+ 传输速率高（1Mb/s）


层： OSI开放系统互连模型

+ 物理介质：双绞线（常用），光纤

+ 信号线： *CAN_H* 和 *CAN_L*
  - 静态时均为2.5V。状态表逻辑1，也称隐形
  - CAN_H(3.5V)比CAN_L(1.5V)高表逻辑0, 称显形

+ 标准CAN的标志符长度为11位，扩展格式可达29位

+

** Tasks

*** TODO Stression
**** Objective

+ [ ] 方阵的一般乘法算法的伪代码和Python实现
+ [ ] 方阵的一般分治
+ [ ] 方阵的Strassen乘法
+ [ ] 将以上算法推广到一般矩阵乘法

**** Notes

+ 优先使用 Python 实现算法，使用 C++ 容易过度关注语言本身的细节
+ 写的代码要有良好的歌读性，

**** 普通方阵乘法：Square-Matrix-Mutltiply(A, B)
***** 伪代码(preudo-code)

#+BEGIN_SRC latex
  \begin{algorithm}[H]
  SQUARE-MATRIX-MULTIPLY(A, B)\;
  n = A.rows\;
  let C be a new nxn matrix\;
  \For{i = 1 \KwTo n}{
    \For{j = 1 \KwTo n}{
      $C_{ij} = 0$
      \For{k = 1 \KwTo n}{
        $C_{ij} = C_{ij} + A_{ik}\cdot{B_{kj}}$
  }
  }
  }
  \Return C
  \end{algorithm}


#+END_SRC

***** Python实现
#+INCLUDE: ~/Wally/Journal/Project/Algorithm/SplitAndonquer/strassen.py :src python

* Project                                                           :proj:

#+include: ~/Wally/Project/README.md
#+include: ~/Wally/Project/ChangeLog.txt

** 2D SLAM in Python

#+include: ~/Wally/Project/SLAM2dPython/README.md
#+include: ~/Wally/Project/SLAM2dPython/ChangeLog.txt

*** Unit_A: Robot,  motion model,  scan data
**** Motion model
***** 推导过程

[[~/Wally/Journal/Figures/scrot/154864nG.png]]

#+BEGIN_SRC latex
  \begin{displaymath}
    \left\{
      \begin{array}{l}
        r=\alpha(R+w) \\
        l=\alpha\cdot R
      \end{array}
    \right.
  \end{displaymath}


  \begin{displaymath}
    \left\{
      \begin{array}{l}
        \alpha=\frac{r-l}{w} \\
        R=\frac{l}{\alpha}
      \end{array}
    \right.
  \end{displaymath}
#+END_SRC

[[~/Wally/Journal/Figures/scrot/15486UFV.png]]

#+BEGIN_SRC latex
  \begin{displaymath}
    C=P-(R+\frac{w}{2})\cdot\left[
      \begin{array}{l}
        \sin\theta\\
        -\cos\theta
      \end{array}
    \right]
  \end{displaymath}
  \begin{displaymath}
    P'=C+(R+\frac{w}{2})\cdot\left[
      \begin{array}{l}
        \sin(\theta+\alpha)\\
        -\cos(\theta+\alpha)
      \end{array}
    \right]
  \end{displaymath}
  \begin{displaymath}
    \theta'=(\theta+\pi)\mod 2\pi
  \end{displaymath}
#+END_SRC

***** 问题模型

*Given*:
+ (x, y, \theta)
+ (l, r)
+ w
*For*
($x'$, $y'$, $\theta'$)

***** 求解

1. case 1: $l \ne r$
   1) $\alpha=\frac{r-l}{w}$
   2) $R=\frac{l}{\alpha}$
   3) $\left[\begin{array}{l}cx\\cy\end{array}\right]=\left[\begin{array}{l}x\\y\end{array}\right]-\left(R+\frac{w}{2}\right)\cdot\left[\begin{array}{l}\sin\theta\\-\cos\theta\end{array}\right]$
   4) $\theta'=(\theta+\alpha)\mod 2\pi$
   5) $\left[\begin{array}{l}x'\\y'\end{array}\right]=\left[\begin{array}{l}cx\\cy\end{array}\right]+\left(R+\frac{w}{2}\right)\cdot\left[\begin{array}{l}\sin\theta'\\-\cos\theta'\end{array}\right]$
2. case 2: l=r
   1) $\theta=\theta'$
   2) $x'=x+l\cdot\cos\theta$
   3) $y'=y+l\cdot\sin\theta$

***** 参数

+ w = 150mm
+ 1 tick = 0.349mm

***** 实现

#+BEGIN_SRC python
  from math import sin, cos, pi
  from pylab import *
  from lego_robot import *


  def filter_step(old_pose, motor_ticks):

      # Find out if there is a turn at all
      if motor_ticks[0] == motor_ticks[1]:
          # No turn. Just drive straight
          theta = old_pose[2]
          x = old_pose[0] + motor_ticks[0]*ticks_to_mm*cos(theta)
          y = old_pose[1] + motor_ticks[0]*ticks_to_mm*sin(theta)

          return (x, y, theta)

      else:
          # Turn. Computer alpha, R, etc.
          alpha = (motor_ticks[1]*ticks_to_mm - motor_ticks[0]*ticks_to_mm) \
                  / robot_width
          r = motor_ticks[0] / alpha

          cx = old_pose[0] - (r+robot_width/2)*sin(old_pose[2])
          cy = old_pose[1] + (r+robot_width/2)*cos(old_pose[2])
          theta = (old_pose[2] + alpha) % (2*pi)

          x = cx + (r+robot_width/2)*sin(theta)
          y = cy - (r+robot_width/2)*cos(theta)

          return (x, y, theta)


  if __name__ == '__main__':
      # Empirically derived conversion from ticks to mm
      ticks_to_mm = 0.349

      # Mesured width of the robot(wheel gauge), in mm
      robot_width = 150.0

      # Read data
      logfile = LegoLogfile()
      logfile.read("robot4_motors.txt")

      # start at origin (0,0), looking along x axis (alpha = 0)
      pose = (0.0, 0.0, 0.0)

      # Loop over all motor ticks records generate filtered position list
      filtered = []
      for ticks in logfile.motor_ticks:
          pose = filter_step(pose, ticks)
          filtered.append(pose)

      for pose in filtered:
          print pose
      plot([p[0] for p in filtered], [p[1] for p in filtered], 'bo')
      show()
#+END_SRC

**** Scan data
***** sensor data memory

#+BEGIN_EXAMPLE
S(flag) 315(timestamp) 660(count) 123 124(range data) ....
#+END_EXAMPLE

***** 计算微分

$f'(i)=\frac{f(i+1)-f(i-1)}{2}$

****** 伪代码

#+BEGIN_SRC latex
    \begin{algorithm}[ht]
      \textbf{ComputeDerivative(A, t)}\;

      \KwIn{A=[a1, a2, ... an]: array, t: threshold against outliers}
      \KwOut{D=[d1, d2, ... dn]: derivative at each element}

      D[1]=0 \tcp{头部边界}\;
      \For{{\color{red}{{i = 2 \KwTo A.length-1}}}}{
        \eIf{A[i-1] > t AND A[i+1] > t}{
          D[i]=(A[i+1]-A[i-1])/2
        }{
          D[i] = 0\tcp{异常点}
        }
      }
      D[n]=0\tcp{尾部边界}\;
      \Return{D}
    \end{algorithm}
#+END_SRC

****** python 实现

#+BEGIN_SRC sh
  def compute_derivative(scan, min_dist):
      jumps = [0]
      for i in xrange(1, len(scan)-1):
          l = scan[i-1]
          r = scan[i+1]
          if l > min_dist and r > min_dist:
              derivative = (r - l) / 2.0
              jumps.append(derivative)
          else:
              jumps.append(0)

      jumps.append(0)
      return jumps
#+END_SRC

***** 特征点提取

[[~/Wally/Journal/Figures/scrot/15486z1K.png]]

****** 定义与特征

圆柱
在扫描线上处于波谷中心，在微分曲线上表现为先上升尖后下降尖

****** 问题描述

+ 输入：扫描线
  - 数据结构：数组，每个元素对应一个距离
+ 输出：特征点位置
  - 数据结构：结构数组，每个元素为一个结构，结构中包含一组索引和距离信
    息

****** 算法描述

思想：取扫描线上升沿和下降沿之间的索引和距离数据均值

注意：
1. 特征点的重叠处理
2. 索引整数除法或者说需要取整

****** 伪代码

#+BEGIN_SRC latex
  \begin{algorithm}
    \textbf{FIND-CYLINDERS(scan, jump)}\;
    \KwIn{scan: 扫描线数组，每个元素对应一个距离信息, jump: 微分的跳动阈
      值}
    \KwOut{cylinders: 特征点结构数组，每个元素对应一个包含索引和距离
      的结构}
    oncylinder = FALSE\;
    ray = 0\;
    index = 0\tcp{索引和}
    depth = 0\tcp{距离和}
    cylinders=[]\;
    n = 0\tcp{特征点个数}
    derivate=COMPUTE-DERIVATIVES(scan)\;
    \For{i=1 \KwTo scan.length}{
      \If{derivative[i] < -jump\tcp{下降沿，开始计数}}{
        ray = 0
        index = 0
        depth = 0
        oncylinder = TRUE
      }
      \tcp{注意条件分支结构}
      \eIf{derivate[i] > jump AND oncylinder \tcp{上升沿，结束计数}}{
        n = n+1
        cylinders[i]=struct(index/ray, depth/ray)
      }{
        \If{scan[i] > mindist}{
          ray = ray+1
          index = index+i
          depth = depth+scan[i]
        }
      }
    }
    \Return{cylinders}
  \end{algorithm}
#+END_SRC

****** python实现

#+BEGIN_SRC python
  def find_cylinders(scan, scan_derivative, jump, min_dist):
      cylinder_list = []
      on_cylinder = False
      rays, sum_ray, sum_depth = 0, 0.0, 0.0

      for i in xrange(len(scan_derivative)):
          if scan_derivative[i] < -jump:
              rays, sum_ray, sum_depth = 0, 0.0, 0.0
              on_cylinder = True
          if on_cylinder:
              if scan_derivative[i] > jump:
                  cylinder_list.append((sum_ray/rays, sum_depth/rays))
                  on_cylinder = False
              elif scan[i] > min_dist:
                  rays += 1
                  sum_ray += i
                  sum_depth += scan[i]

      return cylinder_list
#+END_SRC

**** 阅读源码的思考

良好的源码有明确的目标需求和良好的结构层次。

所以阅读源码不应该直接逐行逐句来，遇到不会的地方就查，而是应该
1) 首先，把握目标 *明白程序实现的是什么功能* ， 同时去思考如果自己写，会怎
   么实现
2) 其次，立足整体， *理清楚程序的结构，并找出逻辑*
3) 先总后分， 分而治之，逐步求精， 阅读源码
4) 遇到拦路虎先不去管，只是记下来， *时刻明确自己在做什么* ， 不要顾及
   不重要的细节

**** logfile_viewer.py
***** 功能

1. GUI --> Tkinter
   + 主窗口
     - 传感器坐标(Canvas)
     - 世界坐标系(Canvas)
     - 其它控件
   + 事件响应
     - 加载文件(tkFileDialog)
     - 响应拖动(Scale)

2. 数据可视化
   1) 数据如何存储
   2) 可视化的方法怎样实现

***** 结构

1. 主函数中构建GUI界面
2. LegoLogfile保存并跟踪数据
3. 绘制不同数据使用不同的对象，这些对象有共同的基类（因为方法相似）

***** main

1. legologfile
2. tk & widgets
3. mainloop

***** 基类

1. DrawableObject
   - Trajectory : class
   - ScannerData : class
   - Landmarks : class
   - Points : class
   - Particles : class
2. Methods
   1) background_draw (self)
   2) draw (self,at_step)
      #+begin_latex
        \begin{minted}[frame=single, mathescape]{py}
            def draw(self, at_step):
                print "To be overwritten - will draw a certain point in time:", at_step

            def background_draw(self):
                print "Background draw."
        \end{minted}
      #+end_latex

      - 基类共同的方法为空
      - 默认 __init__方法
   3) get_ellipse_points (center,main_axis_angle,radius1,radius2,start_angle,end_angle)
      #+begin_latex
        \begin{minted}[frame=single, mathescape]{py}
            @staticmethod
            def get_ellipse_points(center, main_axis_angle, radius1, radius2,
                                   start_angle = 0.0, end_angle = 2 * pi):
                """Generate points of an ellipse, for drawing (y axis down)."""
                # ...
                return points
        \end{minted}
      #+end_latex
      - @staticmethod 定义静态方法
      - """""" 三引号函数说明
      - 参数与返回值

***** Trajectory

Trajectory : class
- Parents: DrawableObject
- __init__ (self,points,canvas,world_extents,canvas_extents,standard_deviations,point_size2,background_color,cursor_color,position_stddev_color,theta_stddev_color)
- background_draw (self)
- draw (self,at_step)

*** Unit_B: Landmark assignment, similarity transform,  Icp
- State "TOBECONTINED" from "TODO"       [2015-11-04 三 16:09]

**** simularity simularity
***** 模型
[[~/Wally/Journal/Figures/scrot/329789G.png]]

#+BEGIN_SRC latex
  \begin{displaymath}
    \lambda{}Rl_i+t=r_i
  \end{displaymath}

  $\lambda\in\mathbf{R}$ scale factor
  \[
  R=\left[
    \begin{array}{ll}
      \cos\alpha&-\sin\alpha\\
      \sin\alpha&\cos\alpha
    \end{array}
  \right]\in\mathbf{R}^{2\times{}2}
  \]
  $t=[t_X,t_y]^T\in\mathbf{R}^2$
#+END_SRC

4 parameters

#+begin_src latex
  \begin{displaymath}
    \lambda{}Rl_i+t=r_i
  \end{displaymath}
  \begin{displaymath}
    \sum_{i}\
lambda{}Rl_i+t-r_i\
  \end{displaymath}
#+end_src

Nonlinear -> Linearize and iterate.

***** 变换： compute center

[[~/Wally/Journal/Figures/scrot/3297d1U.png]]

#+begin_src latex
  \begin{displaymath}
    \bar{l}=\frac{1}{m}\sum_{i}l_i
  \end{displaymath}
  \[\bar{r}=\frac{1}{m}\sum_{i}l_i\]
  \[l_i'=l_i-\bar{l}\]
  \[r_i'=r_i-\bar{r}\]
  \[\sum_{i}l_i'=0\]
  \[\sum_i{}r_i'=0\]
#+end_src

#+begin_src latex
  \begin{align*}
    & \lambda{}Rl_i-r_i+t \\
  = & \lambda{}R(l_i'+\bar{l})-(r_i'+\bar{r})+t\\
  = & \lambda{}Rl_i'-r_i'+\underbrace{\lambda{}R\bar{l}-\bar{r}+t}_{t'}\\
  = & \lambda{}Rl_i'-r_i'-t'\rightarrow min
  \end{align*}
#+end_src

#+begin_src latex
  \begin{align}
    & \sum_{i}\|\lambda{}Rl_i'-r_i'+t'\|^2 \\
  = &
      \sum_{i}\|lambda{}Rl_i'-r_i'\|^2+2t'^T\underbrace{\sum_{i}(\lambda{}Rl_i'-r_i')}_{0}+\underbrace{\sum_{i}\|t'\|^2}_{m\cdot\|t'\|^2}
    \\
  = &
      \underbrace{\sum_{i}\|lambda{}Rl_i'-r_i'\|^2}_{\geqslant{}0}+\underbrace{m\cdot\|t'\|^2}_{\geqslant{}0}
      \rightarrow min
  \end{align}
#+end_src

#+begin_src latex
  \begin{eqnarray*}
    t'=0  \\
   \lambda{}R\bar{l}-\bar{r}+t=0 \\
\rightarrow t = \bar{r}-\lambda{}R\bar{l}
  \end{eqnarray*}
#+end_src

#+begin_src latex
  \begin{eqnarray*}
    \sum_{i}\|\lambda{}Rl_i'-r_i'\|^2\rightarrow min \\
    \sum_i\|sqrt{\lambda}Rl_i'-\frac{1}{\sqrt{\lambda}r_i'}\|^2\rightarrow min
  \end{eqnarray*}

  \begin{align*}
    &
      \sum_i\|sqrt{\lambda}Rl_i'-\frac{1}{\sqrt{\lambda}r_i'}\|^2 \\
  = &
      \lambda\underbrace{\sum_{i}\|Rl_i'\|^2}_{\sum_{i}\|l_i'\|^2}-2\sum_{i}r_i'^Tl_i'+\frac{1}{\lambda}\sum_{i}\|r_i'\|^2
    \\
  = & \lambda{}a+b+\frac{1}{\lambda}c\rightarrow min
  \end{align*}

  \begin{eqnarray*}
    \lambda^2=\frac{c}{a}=\frac{\sum_{i}\|r_i'\|^2}{\sum_i{\|l_i'\|^2}}\\
    \lambda=\sqrt{\frac{c}{a}=\frac{\sum_{i}\|r_i'\|^2}{\sum_i{\|l_i'\|^2}}}
  \end{eqnarray*}
#+end_src

#+begin_src latex
    \begin{eqnarray*}
      \sum_{i}r_i'^T\cdot R\cdot l_i' \rightarrow max \\
      \left[
      \begin{array}{ll}
        l_x&r_x
      \end{array}
  \right]\left[
      \begin{array}{ll}
        \cos\alpha & -\sin\alpha \\
        \sin\alpha & \cos\alpha
      \end{array}
      \right]
  \left[
                     \begin{array}{l}
                       l_x\\l_y
                     \end{array}
                     \right] \\
  \left[
      \begin{array}{ll}
        l_x&r_x
      \end{array}
  \right] \left[
      \begin{array}{l}
        l_x\cos\alpha -l_y\sin\alpha \\
        \_x\sin\alpha+l_y\cos\alpha
      \end{array}
      \right]\\
    r_xl_x\cos\alpha-r_xl_y\sin\alpha+r_y\l_x\sin\alpha+r_yl_y\cos\alpha\\
    \cos\alpha(r_xl_x+r_yl_y)+\sin\alpha(-r_xl_y+r_yl_x)
    \end{eqnarray*}

    \begin{align*}
      \sum_{i}r_i'^TRl_i'& = & \cos\alpha\cdot\sum_{i}(r_x'l_x'+r_y'l_y')+
                               \sin\alpha\sum_{i}(-r_x'l_y'+r_y'l_x')
                               \\
   &= &\left[
        \begin{array}{ll}
         \cos\alpha &\sin\alpha
        \end{array}
  \right]\left[
                      \begin{array}{l}
                        \sum_{i}(r_x'l_x'+r_y'l_y')\\
                        \sum_{i}(-r_x'l_y'+r_y'l_x')
                      \end{array}
  \right]
    \end{align*}
    \begin{displaymath}
      \left[
        \begin{array}{l}
          \cos\alpha\\\sin\alpha
        \end{array}
  \right]=\frac{1}{\|\cdot\|}\left[
    \begin{array}{l}
      \sum_{i}(r_x'l_x'+r_y'l_y')\\
      \sum_{i}(-r_x'l_y'+r_y'l_x')
    \end{array}
  \right]
    \end{displaymath}
#+end_src

****** Recipe

+ Given: l_i,  r_i
+ Compute: $\bar{l}=\frac{1}{m}\sum{}l_{i}$,
  $\bar{r}=\frac{1}{m}\sum{}r_{i}$
  $l_{i}'=l_{i}-\bar{l}$, $r_{i}'=r_{i}-\bar{r}$


cs, ss, rr, ll = 0.0
for i in 1...m:
    $cs+=r_{x}'l_{x}'+r_{y}'l_{y'}$
    $ss+=-r_{x}'l_{y}'+r_{y}'l_{x}'$
    $rr+=r_{x}'r_{x}'+r_{y}'r_{y}'$
    $ll+=l_{x}'l_{x}'+l_{y}'l_{y}'$
$\lambda=\sqrt{\frac{rr}{ll}}$

#+begin_src latex
  \begin{displaymath}
    \left[
      \begin{array}{l}
        c\\s
      \end{array}
  \right]=\left[
    \begin{array}{l}
      cs\\ss
    \end{array}
  \right]/\sqrt{cs^2+ss^2}
  \end{displaymath}

  \begin{displaymath}
    \left[
      \begin{array}{l}
        t_x\\t_y
      \end{array}
  \right]=\bar{r}-\lambda{}R\bar{l}=\left[
    \begin{array}{l}
      \bar{r_x}\\\bar{r_y}
    \end{array}
  \right]-\lambda\left[
    \begin{array}{ll}
      c&-s\\s&c
    \end{array}
  \right]\left[
    \begin{array}{l}
      \bar{l_x}\\\bar{l_y}
    \end{array}
  \right]
  \end{displaymath}
  \begin{displaymath}
    (\lambda, c, s, t_x, t_y)
  \end{displaymath}
#+end_src

*** lego_robot.py

1. int & tuple
   #+BEGIN_SRC python
     p = (int(sp[2]), int([sp[3]]))  # position as a tuple'
   #+END_SRC

2. map
   #+BEGIN_SRC python
   map(int, sp[2:])
   #+END_SRC

** toolbox                                                      :bash:style:

#+include: ~/Wally/Project/toolbox/README.md
#+include: ~/Wally/Project/toolbox/ChangeLog.txt

*** DONE Links to pdf
- State "DONE"       from ""           [2015-12-18 五 09:45] \\
  1) wkhtmltopdf 原生支持多个网页，只要在命令行中依次给出 url 即可，用不
     着写这样麻烦劣质的东西
  2) 使用英文注释，不要使用中文注释
  3) 不要在代码中加入无关的东西，注释中不要添加关于语言的用法，这是笔记
     的事情


#+BEGIN_SRC sh
  #! /bin/bash

  ## 功能
  ##    1. 使用wkhtmltopdf将多个网页转换为pdf
  ##    2. 使用gs合并生成的多个PDF
  ##    3. 使用pdfoutline合并的PDF生成目录

  ## 格式： links2pdf index
  ## 输入： index为文件，包含链接和章节信息
  ##       index每行为一个链接
  ##       line: link---chapter---level


  ## version 0.2 --- 添加注释
  ## version 0.3 --- 类似CMake的外部编译，在目录build下进行

  index=$1
  builddir=links2pdf_build
  mkdir $builddir
  cd $builddir
  cp ../$index .

  > outline                       # 利用重定向生成空文件
  declare -i counter=0            # 限制变量counter的属性为整型，counter用于计算章节数
  declare -i page=1               # page用于跟踪页数
  cat $index | while read -r line
  do
      counter=counter+1           # "整型"变量可以直接进行数值计算， 一般变量需要通过$(())

      # ${} 字符串处理
      link=${line%%\ *}           # %去尾，双%匹配最长，即删除尾部与模式匹配的最大子字符串
      level=${line##*\ }          # #支头，双#匹配最长，即删除头部与模式匹配的最大子字符串
      # range=$((len3-len1-len2-2))       # range???  len<N>??? 明显多余
      link_chapter=${line%\ *}    # %去尾，单%匹配最短，即删除尾部与模式匹配的最小子字符串

      # #去头，单#匹配最短，即删除头部与模式匹配的最小子字符串
      # 前提是link中无空格，章节中可能存在空格
      chapter=${link_chapter#*\ }

      # 9是幻数，含义是小于10的章节索引有前缀0，即01,02... 便于gs排序
      if test ${counter} -gt 9    # test 或 [ condition ]
         then
                 wkhtmltopdf --no-outline $link $counter.pdf; # HTML to PDF
                 Pages=$(pdfinfo $counter.pdf | grep Pages);  # $() 或 反引号`` 执行shell命令并c返回
                 num=${Pages##*\ };
      else
          wkhtmltopdf --no-outline $link 0${counter}.pdf;
          Pages=$(pdfinfo 0${counter}.pdf | grep Pages);
          num=${Pages##*\ };
      fi
      echo "$level $page $chapter" >> outline
      page=$((page+num))          # $(()) 数值运算，变量page已经声明为“整型”，也可以不包裹
  done


  # gs
  gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=out.pdf  *.pdf

  # pdfoutline
  pdfoutline out.pdf outline output.pdf

  # 删除文件
  mv output.pdf ..
  cd ..
  rm -rf $builddir

#+END_SRC

*** Track 规范化 standardize file name                     :filename:stdfn:
- State "Track"      from ""           [2015-12-18 五 10:48] \\
  1. 小结
     + 文件命名要有规范，最好不要仅使用下划线连接几个单词，好丑
     + 不要使用中文注释

  2. TODOs
     + 多个路径参数
     + 参数检查
     + 递归遍历
     + 使用正则替换所有除下划线、数字和字母外的所有特殊字符为下划线

#+INCLUDE: ~/Wally/Project/toolbox/src/stdfn.sh

*** convert pptx to pdf in batch                             :ppt:pptx:pdf:

#+INCLUDE: ~/Wally/Project/toolbox/src/pptx2pdf.sh

*** merge PDFs with outline

#+INCLUDE: ~/Wally/Project/toolbox/src/mergepdfs.sh


*** TODO project
- State "TODO"       from ""           [2015-12-18 五 11:44] \\
  更简洁些，不要多余的功能


**** project
#+BEGIN_SRC sh
   #! /bin/sh

  # tagerill_update_project.sh

  # version 1.0
  # This is a bash script to initialize a new project of common sense
  # It mainly finishes the following tasks
  # 1. create a new root directory that named by the first arguments
  # 2. create a README file containing information like timestamps,
  #    author, email, license and so on
  # 3. create a .projectile file for the convinence of Projectile to manage it
  #
  # version 1.1
  # add the function of update a project
  #
  # Usage
  # tagerill_new_project.sh <PROJECT> [COMMENT_STR]
  #
  # TODO
  # [ ] select a rule of naming versions & update the version information


  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "error: wrong number of arguments"
      echo "usage: tagerill_new_project.sh <PROJECT> [COMMENT_STR]"
      exit -1
  fi


  project=$1
  comments=""
  if [ $# -eq 3 ]
  then
      comments=$2
  fi

  # update the project
  if [ -d $project ]
  then
     cd $project
     echo >> README
     echo -n "MODIFICATION:" >> README
     date +%Y/%m/%d-%H:%M >> README
     # TODO： 变更版本信息
     if [ $# -eq 3 ]
     then
         echo "COMMENT: $comments" >> README
     fi
     echo "Project: $project updated."
     exit 0
  fi


  # create a new project
  # root workspace
  mkdir $project

  # README
  cd $project
  touch README
  echo "PROJECT: $project" >> README
  echo "VERSION: v1.0"
  echo -n "TIME: " >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "License: GPL v3.0" >> README

  # .projectile
  touch .projectile

  #
  echo "Project: $project has been created"

  exit 0

#+END_SRC

**** cpp

#+BEGIN_SRC sh
  #! /bin/sh

  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "Usage: cpp_pro.sh PROJECT"
      exit 1
  fi

  project=$1
  mkdir $project
  cd $project
  touch README COPYRIGHT TODO Makefile
  mkdir bin src include lib

  # README
  echo PROJECT: $project >> README
  echo -n TIME: >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "LICENSE: GPL v3.0" >> README

  # TODO
  echo [ ] >> TODO
  echo [ ] >> TODO
  echo [ ] >> TODO
#+END_SRC

**** cmake

#+BEGIN_SRC sh
  #! /bin/bash

  # 参数检查
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "usage: cmake_pro.sh PROJECT"
      exit
  fi

  project=$1
  mkdir $project
  cd $project
  # 目录结构
  mkdir src scripts build lib bin doc

  # 根目录下文件
  touch CMakeLists.txt
  echo "CMAKE_MINIMUM_REQUIRED(VERSION 3.2)" >> CMakeLists.txt
  echo "PROJECT($project)" >> CMakeLists.txt
  echo "ADD_SUBDIRECTORY(src bin)" >> CMakeLists.txt
  echo "ADD_SUBDIRECTORY(scripts)" >> CMakeLists.txt

  touch README COPYRIGHT TODO
  echo "PROJECT: $project" >> README
  echo -n "TIME: " >> README
  date +%Y/%M/%d-%H:%m >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README

  # TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO

  # src
  cd src
  touch CMakeLists.txt

  # scripts
  cd ../scripts
  touch CMakeLists.txt
  echo "# INSTALL(PROGRAMS project DESTINATION bin)" >> CMakeLists.txt
#+END_SRC

**** arduino

#+BEGIN_SRC sh
  #! /bin/bash

  # 参数个数检查
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of argument"
      echo "usage: ardpro PROJECT"
      exit
  fi

  project=$1
  mkdir $project                  # 创建目录
  cd $project
  touch README COPYRIGHT TODO Makefile $project.ino

  # README
  echo PROJECT: $project >> README
  echo -n TIME: >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "LICENSE: GPL v3.0" >> README

  # TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO

  # Makefile
  echo "BOARD_TAG = uno" >> Makefile
  echo "ARDUINO_LIBS = " >> Makefile
  echo "MONITOR_PORT = /dev/ttyACM0" >> Makefile
  echo "include /usr/share/arduino/Arduino.mk" >> Makefile
#+END_SRC

**** bash

#+BEGIN_SRC sh
  #! /bin/bash

  # Function: Create a new bash project
  # Usage: bash_pro.sh
  # Input: Project name
  # Output: Name


  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "Usage: bash_pro.sh PROJECT"
      exit
  fi

  project=$1
  mkdir $project
  cd $project
  touch README LICENSE TODO Makefile      # Files
  mkdir scripts bin               # Contents

  # REAMDE
  echo "Project: $project" >> README
  echo -n "Time: " >> README
  date +%Y/%m/%d-%H:%m >> README
  echo "Author: Wally" >> README
  echo "Email: buaaben@163.com" >> README
#+END_SRC

**** CMakelists.txt

#+BEGIN_SRC cmake
  CMAKE_MINIMUM_REQUIRED(VERSION 3.2)
  PROJECT(bash_pro)
  ADD_SUBDIRECTORY(src bin)
  ADD_SUBDIRECTORY(scripts)

  INSTALL(PROGRAMS bash_pro.sh DESTINATION bin)
#+END_SRC
*** TODO routine


#+INCLUDE: ~/Wally/Project/toolbox/src/routine.sh

TODOs
+ [ ] [[file:~/Wally/Project/toolbox/src/routine.sh::path=$1%20#%20path%20need%20to%20be%20absolute][check path]]




#+BEGIN_SRC sh
  #! /bin/sh

  # 执行git, pdf, clean等日常工作
  # 根据时间和地点完成不同的任务

  home=tiger                      # 用户名
  office=ben
  host=`echo $HOSTNAME`
  ws=$HOME/Wally/Journal  # workspace
  emacs_settings_ws="/home/${host}/.emacs.d"


  time=`date +%H`

  cmd=$1

  # if [ $time -gt $line ]                # in the evening
  # then
  #     if [ $host == $office ]   # at office
  #     then
  #       # clean
  #       touch tmpfile
  #       rm `ls . | grep -E "*~$|*.out$|*.log$|*.toc$|*.aux$|^tmpfile$"`
  #       # git push
  #       git add --ignore-removal .
  #       git commit -m "committed automatically by script at $office `date +%H%M`"
  #       git push origin master

  #       # pdf
  #       journal=journal.pdf
  #       if [ -e $journal ]
  #       then
  #           mv journal.pdf "PDFs/`date +%Y%m%d`.pdf"
  #       fi
  #     elif [ $host == $home ]                   # at home
  #     then
  #       # git pull
  #       git pull
  #       git merge origin/master
  #     fi
  # else                          # in the morning
  #     if [ $host == $office ]
  #     then
  #       # git pull
  #       git pull
  #       git merge origin/home
  #     elif [ $host == $home ]
  #     then
  #       # git push
  #       git add --ignore-removal .
  #       git commit -m "committed automatically by script at $home at `date +%H:%M`"
  #       git push origin home
  #     fi
  # fi


  if [ $cmd = "push" ]
  then
      cd $ws
      git add --ignore-removal .
      git commit -m "committed automatically by script at $home at `date +%H:%M`"
      git push origin master

      if [ $host = $office ]
      then
          cd $emacs_settings_ws
          git add settings.org
          git add elpa/yasnippet-20150323.311/snippets/
          git commit -m "committed automatically by script at $home at `date +%H:%M`"
          git push origin master

          thesis_ws="~/Wally/GraduationProject/Thesis"
          cd $thesis_ws
          git add .
          git commit -m "committed automatically by script at $home at `date +%H:%M`"
      fi
  elif [ $cmd = "pull" ]
  then
      cd $ws
      git pull
  fi


  # 命令行参数为密码
  # if [ $# -eq 1 ]
  # then
  #     passwd=$1
  #     python email_evernote.py $passwd
  # fi

  # dict

#+END_SRC

*** TODO email

#+BEGIN_SRC python
  #! /usr/bin/env python
  # -*- encoding:utf-8 -*-

  import smtplib

  from email import encoders
  from email.header import Header
  from email.mime.text import MIMEText
  from email.mime.multipart import MIMEMultipart
  from email.mime.base import MIMEBase
  from email.utils import parseaddr, formataddr

  import sys, datetime, os

  if len(sys.argv) < 2:
      print "done nothing. If a email needs to be delieved, please confirm and provide the passwd"
      exit(0)

  def _format_addr(s):
      name, addr = parseaddr(s)
      return formataddr((Header(name, 'utf-8').encode(), addr))

  pdf_file = "%s.pdf" % datetime.datetime.now().strftime("%Y%m%d")
  path = "/home/ben/Wally/Journal/PDFs/"
  filename = path + pdf_file

  from_addr = "buaaben@163.com"
  passwd = sys.argv[1]            # 从命令行获取密码
  to_addr = "buaaben.fa289a0@m.yinxiang.com"

  # 构造邮件对象
  msg = MIMEMultipart()
  # 发送地址
  msg['From'] = _format_addr("Ben<%s>" % from_addr)
  # 接收地址
  msg['To'] = _format_addr('Evernote<%s>' % to_addr)
  # 主题
  msg['Subject'] = Header("%s @Tagerill #journal" %
                          datetime.datetime.now().strftime("%Y%m%d"),
                          'utf-8').encode()

  # 时间戳
  now = datetime.datetime.now().strftime('%Y/%m/%d-%H:%M')
  msg.attach(MIMEText('Generated automatically by python script at %s' % now,
                      'plain', 'utf-8'))
  # 正文
  with open("/home/ben/dic.txt", 'r+') as f:
      voc = f.read()
      msg.attach(MIMEText('Vacabularies for today are as following: %s' % voc,
                          'plain', 'utf-8'))
      null = ''
      f.write(null)

  # 附件
  if os.path.exists(filename):
      with open(filename, 'rb') as f:
          mime = MIMEBase('PDF', 'pdf', filename='journal.pdf')
          mime.add_header('Content-Disposition', 'attachment',
                          filename='journal.pdf')
          mime.add_header('Content-ID', '<0>')
          mime.add_header('X-Attachment-Id', '0')

          # 把附件的内容读进来:
          mime.set_payload(f.read())
          # 用Base64编码:
          encoders.encode_base64(mime)
          # 添加到MIMEMultipart:
          msg.attach(mime)

  # 发送邮件
  # stmp_server = None              ####### TODO
  stmp_server = "smtp.163.com"
  port = 25
  server = smtplib.SMTP(stmp_server, 25)
  server.set_debuglevel(1)
  server.login(from_addr, passwd)
  server.sendmail(from_addr, [to_addr], msg.as_string())

#+END_SRC
** .emacs.d

#+include: ~/.emacs.d/README.md
#+include: ~/.emacs.d/ChangeLog.txt
#+include: ~/.emacs.d/init.el
#+include: ~/.emacs.d/lisp/emets.el :src emacs-lisp
#+include: ~/.emacs.d/.projectile

*** Notes
**** 0 is not nil(nil & [])

#+BEGIN_EXAMPLE
  (while (> len 0)  ...) ; 0 is not nil(nil & [])
#+END_EXAMPLE

*** TODOs

+ [ ] [[file:Project/emets/lisp/emets.el::(defun%20emets-insert-current-date()][合并 insert-time, 结合使用前缀和 HELM 选择不同格式的时间]]
+ [ ] [[file:Project/emets/lisp/init-org.el::(setq%20org-reverse-note-order%20t)][使用 mapcar 定义 org-refile-targets]]
+ [ ] [[file:Project/emets/lisp/init-org.el::%3B%3B%20(add-to-list%20'org-latex-classes%20'("beamer"][beamer documentclass in org-mode]]
+ [ ] [[file:Project/emets/lisp/init-org.el::%3B%3B%20ox-freemind][ox-freemind]]

** algorithm

** BUAAthesis
*** 文件后缀bst cls
+ *cls* (class): 稿件类型文件，可用命令\documentclass调用。
+ *bst*: BibTeX-style-file

*** encoding                                                     :encoding:

多人合作的时候涉及多平台，因而统一编码非常重要。
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
% !mode:: "tex:utf-8"
...
\end{minted}
#+end_latex

*** 模板声明
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \NeedsTeXFormat{LaTeX2e}[2007/10/19]
  \ProvidesClass{buaathesis}
                [2012/07/06 v0.8
  The LaTeX template for thesis of BUAA]
  \typeout{Document Class `buaathesis' v0.8 by BHOSC (2012/07)}

  ...

  \DeclareOption{twoteacher}{\buaa@twoteachertrue}
  % 其余选项传递给ctexbook
  \DeclareOption*{\PassOptionsToClass{\CurrentOption}{ctexbook}}
  \ProcessOptions\relax
  % 引用ctexbook及基本设置
  \LoadClass[cs4size,a4paper,fancyhdr]{ctexbook}[2007/10/19]

  %%%%%%%%%% global package %%%%%%%%%%
  % 全局通用宏包

  \RequirePackage{ifthen}

  \end{minted}
#+end_latex

1. \textbackslash{}NeedsTeXFormat
   specifies which version of TeX or LaTeX is required at least to run
   your package. The optional date may be used to specify the version
   more precisely.

2. \textbackslash{}ProvidesClass
   A package introduces itself using this command.
   1) <name> should be identical to the basename of the file itself.
   2) <version> should should begin with a date in the format
      YYYY/MM/DD. Version information should be kept updated while
      developing a package.

3. \textbackslash{}typeout

4. \textbackslash{}RequirePackage
   is equivalent to \textbackslash{}usepackage.

5. \textbackslash{}DeclareOptions
   are end-user parameters. Each option is declared by one such
   command.

6. \textbackslash{}ExecuteOptions{...}
   tells which are the default.

7. \textbackslash{}ProcessOptions\textbackslash{}relax
   terminates the option processing.

8. \textbackslash{}endinput
   this must be the last command(for package(.sty) not for class(cls)).

*** 选项
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
% 本模板自身包含五个选项
% 前四个为对应学位类型，决定不同样式
% 第五个为颜色选项，用于电子版的情况
\newif\ifbuaa@bachelor\buaa@bachelorfalse
\newif\ifbuaa@master\buaa@mastertrue
\newif\ifbuaa@engineer\buaa@engineerfalse
\newif\ifbuaa@doctor\buaa@doctorfalse
\newif\ifbuaa@color\buaa@colorfalse
\newif\ifbuaa@twoteacher\buaa@twoteacherfalse
\DeclareOption{bachelor}{\buaa@bachelortrue}
\DeclareOption{master}{\buaa@mastertrue}
\DeclareOption{engineer}{\buaa@engineertrue}
\DeclareOption{doctor}{\buaa@doctortrue}
\DeclareOption{color}{\buaa@colortrue}
\DeclareOption{twoteacher}{\buaa@twoteachertrue}
% 其余选项传递给ctexbook
\DeclareOption*{\PassOptionsToClass{\CurrentOption}{ctexbook}}
\end{minted}
#+end_latex

*** 字体与颜色
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \setmainfont{Times New Roman}
  % 不需要设置CJKmainfont，ctex 宏包已经很好的处理了
  % 不仅设置了粗体为黑体，斜体为楷体，还兼容了winfonts和adobefonts
  % 直接设置反而会在只有adobefonts的情况下报错
  % \setCJKmainfont{宋体}
  \setCJKfamilyfont{hwxingkai}{STXingkai}
  \newcommand{\hwxingkai}{\CJKfamily{hwxingkai}}
  \newcommand{\xiaochuhao}{\fontsize{32pt}{\baselineskip}\selectfont}

  %%%%%%%%%% color %%%%%%%%%%
  % 颜色设置

  % 只用于电子版
  \RequirePackage{color}
  \definecolor{dkgreen}{rgb}{0,0.6,0}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \definecolor{mauve}{rgb}{0.58,0,0.82}
  \end{minted}
#+end_latex

1. \textbackslash{}setmintfont
2. \textbackslash{}newcommand{}{}
3. \textbackslash{}{}{}{}

*** 页边距
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \RequirePackage{geometry}
  \newgeometry{
      top=30mm, bottom=25mm, left=30mm, right=20mm,
      headsep=5mm,
  }
  \savegeometry{bachelorgeometry}
  \newgeometry{
      top=25mm, bottom=25mm, left=30mm, right=20mm,
      headsep=5mm, headheight=10mm, footskip=10mm,
  }
  \savegeometry{mastergeometry}

  \ifbuaa@bachelor
      \loadgeometry{bachelorgeometry}
  \else
      \loadgeometry{mastergeometry}
  \fi

  \end{minted}
#+end_latex

+ \textbackslash{}newgeometry
+ \textbackslash{}savegeometry
+ \textbackslash{}if...\textbackslash{}else...\textbackslash{}fi

*** 其它间距

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \renewcommand{\baselinestretch}{1.5}
  \setlength{\parindent}{2em}
  \setlength{\floatsep}{3pt plus 3pt minus 2pt}      % 图形之间或图形与正文之间的距离
  \setlength{\abovecaptionskip}{10pt plus 1pt minus 1pt} % 图形中的图与标题之间的距离
  \setlength{\belowcaptionskip}{3pt plus 1pt minus 2pt} % 表格中的表与标题之间的距离
  \end{minted}
#+end_latex

+ \textbackslash{}renewcommand
+ \textbackslash{}setlength

*** 汉化
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \renewcommand{\contentsname}{目\qquad 录}
  \renewcommand\listfigurename{插\ 图\ 目\ 录}
  \renewcommand\listtablename{表\ 格\ 目\ 录}
  \renewcommand\bibname{参\ 考\ 文\ 献}
  \renewcommand{\figurename}{图}
  \renewcommand{\tablename}{表}
  \end{minted}
#+end_latex

*** 段落格式
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  % 格式
  \CTEXsetup[
      format={\centering\zihao{3}\heiti},
      nameformat={},
      aftername={\quad},
      titleformat={},
      beforeskip={-.5\baselineskip},
      afterskip={\baselineskip},
  ]{chapter}
  \CTEXsetup[
      aftername={\quad},
      beforeskip={.5\baselineskip},
      afterskip={.5\baselineskip},
  ]{section}
  \CTEXsetup[
      format={\zihao{-4}\heiti},
      aftername={\quad},
      beforeskip={.5\baselineskip},
      afterskip={.5\baselineskip},
  ]{subsection}
  \ifbuaa@bachelor
      \CTEXsetup[
          name={,},
          number={\arabic{chapter}},
      ]{chapter}
      \CTEXsetup[
          format={\zihao{-4}\heiti},
      ]{section}
  \else
      \CTEXsetup[
          name={第,章},
          number={\chinese{chapter}},
      ]{chapter}
      \CTEXsetup[
          format={\zihao{4}\heiti},
      ]{section}
  \fi

  \end{minted}
#+end_latex

*** 图片
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  %%%%%%%%%% picture %%%%%%%%%%
  % 图片

  \RequirePackage{graphicx}
  \DeclareGraphicsExtensions{.eps,.ps,.jpg,.bmp}
  \graphicspath{{figure/}}
  \RequirePackage{pifont} % “秘级”后的五角星
  \RequirePackage{subfigure}

  \end{minted}
#+end_latex

*** 列表
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
%%%%%%%%%% list %%%%%%%%%%
% 列表

\RequirePackage{enumitem}
\setlist{noitemsep}
\setlist[1,2]{labelindent=\parindent}
\setlist[enumerate,1]{label=\arabic*、}
\setlist[enumerate,2]{label=（\arabic*）}
\setlist{
    topsep=0pt,
    itemsep=0pt,
    partopsep=0pt,
    parsep=\parskip,
}

\end{minted}
#+end_latex

*** 代码
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  %%%%%%%%%% code %%%%%%%%%%
  % 代码

  % Listing 的设置请参考 http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
  \RequirePackage{listings}
  \lstset{
      backgroundcolor=\color{white},
      basicstyle=\zihao{5}\ttfamily,
      columns=flexible,
      breakatwhitespace=false,
      breaklines=true,
      captionpos=b,
      frame=single,
      numbers=left,
      numbersep=5pt,
      showspaces=false,
      showstringspaces=false,
      showtabs=false,
      stepnumber=1,
      rulecolor=\color{black},
      tabsize=2,
      texcl=true,
      title=\lstname,
      escapeinside={\%*}{*)},
      extendedchars=false,
      mathescape=true,
      xleftmargin=3em,
      xrightmargin=3em,
  }
  \end{minted}
#+end_latex

*** 定理

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  %%%%%%%%%% theorem %%%%%%%%%%
  % 定理

  \theoremsymbol{\ensuremath{\square}}
  \newtheorem*{proof}{证明}
  \theoremstyle{plain}
  \theoremsymbol{}
  \theoremseparator{：}
  \newtheorem{assumption}{假设}[chapter]
  \newtheorem{definition}{定义}[chapter]
  \newtheorem{proposition}{命题}[chapter]
  \newtheorem{lemma}{引理}[chapter]
  \newtheorem{theorem}{定理}[chapter]
  \newtheorem{axiom}{公理}[chapter]
  \newtheorem{corollary}{推论}[chapter]
  \newtheorem{exercise}{练习}[chapter]
  \newtheorem{example}{例}[chapter]
  \newtheorem{remark}{注释}[chapter]
  \newtheorem{problem}{问题}[chapter]
  \newtheorem{conjecture}{猜想}[chapter]
  \end{minted}
#+end_latex

*** 标题

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  %%%%%%%%%% caption %%%%%%%%%%
  % 图表标题

  \RequirePackage{caption}
  \DeclareCaptionFormat{bachelorfigure}{\songti\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{bachelortable}{\heiti\bf\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{bachelorlstlisting}{\songti\bf\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{masterfigure}{\bf\songti\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{mastertable}{\bf\songti\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{masterlstlisting}{\bf\songti\zihao{5}{#1\textrm{#2}#3}}
  \ifbuaa@bachelor
      \captionsetup[figure]{format=bachelorfigure,labelsep=quad}
      \captionsetup[table]{format=bachelortable,labelsep=quad}
      \captionsetup[lstlisting]{format=bachelorlstlisting,labelsep=quad}
      \renewcommand{\thefigure}{\arabic{chapter}.\arabic{figure}}
      \renewcommand{\thetable}{\arabic{chapter}.\arabic{table}}
      \renewcommand{\theequation}{\arabic{chapter}.\arabic{equation}}
  \else
      \RequirePackage{remreset}
      \@removefromreset{table}{chapter}
      \@removefromreset{figure}{chapter}
      %使图表的标号与章节无关
      \captionsetup[figure]{format=masterfigure,labelsep=quad}
      \captionsetup[table]{format=mastertable,labelsep=quad}
      \captionsetup[lstlisting]{format=masterlstlisting,labelsep=quad}
      \renewcommand{\thefigure}{\arabic{figure}}
      \renewcommand{\thetable}{\arabic{table}}
      \renewcommand{\theequation}{\arabic{chapter}.\arabic{equation}}
  \fi
  \end{minted}
#+end_latex

*** 页码
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  % 正文前的页码设置位大写罗马数字
  \renewcommand{\frontmatter}{
      \cleardoublepage
      \@mainmatterfalse
      \ifbuaa@bachelor
          \pagenumbering{Roman}
      \else
          \pagenumbering{roman}
      \fi
  }

  % 保证偶数页结束章节
  \newcommand{\clearemptydoublepage}{%
      \clearpage
      \if@twoside
          \ifodd
              \c@page
          \else
              \hbox{}\thispagestyle{empty}\newpage
              \if@twocolumn
                  \hbox{}\newpage
              \fi
          \fi
      \fi
  }
  \end{minted}
#+end_latex

*** 首页
好长！

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
% 中文首页
\newcommand{\titlech}{
....
}

% 英文首页
\newcommand{\titleeng}{
....
}
\end{minted}
#+end_latex

*** 摘要
#+begin_latex
% 中文摘要
\begin{minted}[frame=single, mathescape]{latex}
\newenvironment{cabstract}{
...
}

% 英文摘要
\newenvironment{eabstract}{
...
}
\end{minted}
#+end_latex

*** 其它
+ 声明
+ 任务书
+ 授权页
+ 用户信息

** tagerill PCB
*** ARM芯片选型
+ Cortex系列
+ 内含CAN控制器
+ 最好支持openocd
*** flash选型
+ NAND（安装Ubuntu和ROS所需要的容量）
+ NOR
*** 电源模块
+ 需要几种电源
+ 几层PCB，哪层做为电源层，怎么敷铜
+ 电源的反向防护（二级管选型）和过压保护（how）
+
*** CAN模块
+ 淘宝：http://item.taobao.com/item.htm?spm=a230r.1.14.1.1GNisu&id=39187810657&ns=1&abbucket=14#detail

*** 网口
**** socket
整合多个串口
**** 多机
台式机运行图形界面
ARM传输数据
笔记本做算法
*** 整板参考
**** pcDuino
+ http://learn.linksprite.com/pcduino/pcduino-3-circuit-diagram/
+ https://github.com/pcduino/pcDuino3C_carrierboard
**** 古月居 http://blog.csdn.net/hcx25909/article/details/8539587
**** OpenSource hardware
+ https://www.linux.com/news/embedded-mobile/mobile-linux/732197-top-10-open-source-linux-boards-under-200
+ http://www.omappedia.com/wiki/PandaBoard
+ http://www.pcworld.com/article/2046232/top-opensource-pcs.html
+ http://www.techhive.com/article/242863/new_89_opensource_hardware_runs_full_linux_os.html
+ https://en.wikipedia.org/wiki/List_of_open-source_hardware_projects
+ https://en.wikipedia.org/wiki/Open-source_hardware

* Progress                                                         :progress:

 循序渐进

** README.md

1. 学习是有系统的
2. 长期零散化的知识吸收是有害的
3. 坚持就是力量
4. 要有优先级

** TOBECONTINED [#A] 算法导论                            :project:algorithm:

*** tobecontined 项目规化 [1/3]
- state "tobecontined" from "todo"       [2015-11-23 一 14:37]
- state "todo"       from ""           [2015-11-23 一 14:36]


1. [ ] 为什么要学习算法，我想过这个问题么？
2. [x] 教材选择： 《算法导论》
3. [ ] 整理已学习的内容
4. [ ] 学习计划

** TOBECONTINED [#A] 数据结构                        :project:datastructure:
- state "tobecontined" from ""           [2015-11-23 一 14:39]
  算法与数据结构分不开

- 教材： [[~/Document/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90C%2B%2B%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%89%E7%89%88.pdf][数据结构与算法分析]]

*** 项目规化 [1/4]
- state "tobecontined" from ""           [2015-11-23 一 14:39]

1. [ ] 思考： 为什么学习数据结构？
2. [x] 教材选择： 《数据结构与算法分析：c++描述》
3. [ ] 整理已学习内容
4. [ ] 学习计划

*** 引论
**** 选择问题(selection problem)                     :selection:algorithm:

***** 问题描述

有一组n个数，要确定其第k个最大者
+ 输入： 数组a
+ 输出： 第k个最大数

***** 算法一

先排序，然后返回索引为k的元素

#+begin_src latex
  \begin{algorithm}[ht]
    sort-select(a, k)
    \kwdata{a: 数组， k: integer}
    sort(a)
    return a[k]
  \end{algorithm}
#+end_src

***** 算法二

先读入前k个元素并排序，接着将剩下的元素逐个读入，替换适当位置的元素或舍
弃。最终返回第k个元素

#+begin_src latex
  \begin{algorithm}[ht]
    optimized-sort-select
    \kwdata{a: array, k: index}
    \kwout{第k大元素}
    \blankline
    \begin{
      \for{i=1 \kwto k}{
        b[i] = a[i]
      }
      sort(b)
      \for{i=k+1 \kwto a.length}{
        j = k
        key = a[i]
        \while{key>b[j] and j>0}{
          b[j]=b[j-1]
          j = j-1
        }
        b[j-1] = key
      }
      return b[k]
    }
  \end{algorithm}
#+end_src

***** 实现

#+include: ~/Wally/Journal/Project/Algorithm/selects.h :src cpp

***** 算法的性能

length=1000万，k=5000,000时，两种算法都不能在合理的时间内完成（每种算
法都需要计算机处理若干天才能完成）
存在另外一种算法可以在1s左右给出答案。

**** c++类
***** 基本class语法

+ 学习类的程序风格
+ 文件以下划线连接的小写字母单词命名
+ 类使用驼峰式命名
+ 类的方法使用小写字母q命名
+ 合理的注释是必要的

#+begin_src latex
  \begin{cpp}
    /**
    ,* a class for simulating an integer memory cell
    ,*/

    class intcell
    {
      /**
      ,* construct the intcell
      ,* initial value is 0
      ,*/
      intcell(){
        storedvalue = 0;
      }

      /**
      ,* construct the intcell
      ,* initial value is initialvalue
      ,*/
      intcell(int initialvalue){
        storedvalue = initialvalue;
      }

      /**
      ,* return the stored value
      ,*/
      int read(){
        return storedvalue;
      }

      /**
      ,* change the stored value
      ,*/
      void write(int x){
        storedvalue = x;
      }

      private:
      int storedvalue;
    };

  \end{cpp}
#+end_src

***** 特别的构造函数和访问函数

#+begin_src latex
  \begin{cpp}
    /**
    ,* a class for simulating an integer memory cell.
    ,*/

    class intcelloptimized
    {
      public:
      explicit intcelloptimized(int initialvalue=0)
      : storedvalue(initialvalue) {}
      int read() const{
        return storedvalue;
      }
      void write(int x){
        storedvalue = x;
      }

      private:
      int storedvalue;

    };

  \end{cpp}
#+end_src


****** 四项优化
1. 使用默认参数（default parameter）

2. 初始化列表
   1) 在数据成员是具有复杂初始化过程的类类型时，使用初始化列表代替代码
      体中的赋值语句可以节省许多时间
   2) 如果一个数据成员是const（在对象被构造后就不能再改变），数据成员
      的值只能在初始化列表中时行初始化
   3) 如果一具数据成员是不具有零参数构造函数的类类型时，该数据成员的初
      始化也必须在初始化列表中进行

3. explicit构造函数
   1) 所有单参数的构造函数都必须是explicit的，以避免后台的类型转换；
   2) 否则一些宽松的规则将允许在没有显式类型转换操作的情况下进行类型转换
   3) 通常单构造函数定义了一个隐式类型转换(impllicit type conversion)，该转换创建一个临时对象，从而使赋值变得兼容
   4) intcell obj; obj = 37; // should not compile, 会转换为intcell temp = 37; obj = temp;

4. 常量成员函数
   1) 在c++中每个成员函数都被标记为访问函数(accessor)或者修改函数(mutator)
   2) 函数声明可以在不同的情况下以不同的方式使用const关键字，只有跟在结尾圆括号后面的const才标记一个访问函数

****** 其它优化
1. 预处理指令，防止多次包括同一文件 #ifndef intcell_h #define intcell_h #endif
2. 接口与实现分离
   1) 签名一致
   2) 默认参数仅在接口中被定义，在实现中被忽略

***** vector和string

c++标准定义了两个类vector和string。

*如果可能，应尽量避免使用c++内置数组和字符串。*

****** 内置数组带来的麻烦

内置数组的问题在于其行为与基本对象不同
+ 不能使用=复制
+ 不能记忆本身长度
+ 不能对索引进行边界检查

*** 表、栈和队列                                              :vector:list:

最基本的3种数据结构， *每一个有意义的程序都将明晰地至少使用一个这样的
数据结构*

**** 抽象数据类型

抽象数据类型(abstract date type, *ADT*)是带有一组操作的一些对象的集合。

抽象数据类型是数学的抽象：在ADT的定义中根本没有提到这组操作是如何实现
的。

e.g. 表、集合、图

**** 表ADT
***** 表ADT

表ADT： A_{0}, A_{1}, ..., A_{n-a}

表的大小(size)。

n=0, 空表(empty list)

A_{i} *后继* A_{i-1}; A_{i-1} *前驱* A_{i}

表的操作：
1. printList
2. makeEmpty
3. find
4. insert
5. remove
6. findKth

***** 表的简单数组实现

vector类

1. printList 线性时间
2. findKth 常数时间
3. insert/delete: O(N)
   1) 最坏的情况，在表头（位置0）插入删除元素，N
   2) 最好的情况，在表尾插入删除元素，O(1)
   3) 平均：线性时间

在许多情况，表是
1) 通过在 *末尾插入* 元素来 *建立* 的
2) 之后只有数组访问发生
这样，数组实现是适合和。

如果插入和删除都发生在表中的话，特别是前端的话，数组就不是一个好选择了。

***** 链表

为了避免插入和删除的线性开销 -> 表可以不连续存储。

[[~/Wally/Journal/Figures/scrot/59702FS.png]]

1. printList或find(x) 线性时间，但比数组要大

2. findKth(i) 以明显的遍历链表实现O(i)

   - 因此，调用findKth常常以排序（按i）方式进行

**** STL中的向量和表

Standard Template Library标准模板库。 集合(collection) 或 容器
(container)

表ADT的两种流行的实现

1. *vector*
   1) 优势： 在常量时间里是可索引的
   2) 缺点： 插入新项或者删除已有项的代价是高昂的，除非是在末端发生

2. *list* 双向链表
   1) 优点： 变化发生位置已知的话，插入新项和删除已有项的代价是很小的
   2) 缺点： 不容易索引

两者在查找时的效率都是很低的。

方法：

1. 公共的方法（所有STL）
   + int size() const
   + void clear()
   + bool empty

2. 常量时间内在末尾插入或者删除项
   + void push_back(const Object& x)
   + void pop_back()

3. 在常量时间内访问前端的项
   + const Object& back() const
   + const Object& front() const

4. 双向链表list特有的，对前端高效地改变
   + void push_front(const Object & x): 在list的前端加x
   + void pop_front(): 在list对象的前端删除对象

5. vector特有的方法
   + Object& operator[] (int idx)
   + Object& at(int idx)
   + int capacity() const
   + void reserve(int newCapacity): 设定新的容量

***** 迭代器

对于在表中插入删除的操作需要 *位置标记*,  -> 内置类型 *iterator* 给出
位置。

问题:
1) 如何得到迭代器
2) 迭代器可以执行什么操作（方法）
3) 哪些表ADT方法需要迭代器作为形参

****** 获得迭代器

+ iterator begin()
+ iterator end()  // 返回 *边界之外*

****** 迭代器方法

+ itr++ 和 ++itr
+ *itr
+ == 和 ！=

#+begin_latex
\begin{minted}[frame=single, mathescape]{cpp}
for(vector<int>::iterator itr = v.begin(); itr != v.end; ++itr){
}
\end{minted}
#+end_latex

或

#+begin_latex
\begin{minted}[frame=single, mathescape]{cpp}
vector<int>::iterator itr = v.begin()
while(itr != v.end()){
    cout << *itr++ << endl;
}
\end{minted}
#+end_latex

注：
- 后置自增运算符(++)优先级高于解引用(*)运算符，
- 后置自增运算符(++)表达式的返回值为原值，副作用是加1

****** 需要迭代器的容器操作

1. iterator insert(iterator pos, const Object& x)
   - 添加x到表中迭代器pos所指向的位置之前的位置
   - 对于list是常量时间，对于vector不是
   - 返回值是一个指向插入位置的迭代器

2. iterator erase(iterator pos)
   - 删除迭代器所给位置的对象
   - 对于list是常量时间，对于vector不是
   - 返回值是调用之前pos所指向元素的下一个元素的位置，这个操作使pos失
     效

3. iterator erase(iterator start,  iterator end)

表ADT的通用函数模板

[[~/Wally/Journal/Figures/scrot/5970DQY.png]]

****** const_iterator

1. iterator begin()
2. const_iterator begin() const
3. iterator end()
4. const_iterator end() const

方法的定常性(后置const修饰符)是标号(函数签名)的一部分。

**** 向量实现

***** Vector类需求分析

1. 数组的特性
   1) 数组就是指向一块内存的指针变量
   2) 内存块可以使用new[]来分配，相应地必须使用delete[]来释放
   3) 内在块的大小不能改变（但是可以定义一个新的具有更大内存块的数组，
      并且用原来的数组进行初始化）

2. Vector需求分析
   1) 存储基本数组和数组容量
   2) 三大函数
      - 复制构造函数和operator=深复制
      - 析构函数回收基本数组
   3) resize改变大小，reserve改变容量
      - 为新的数组分配一块新的内存块
      - 复制旧内存块到新的内存块
      - 释放旧的内存块
   4) operator[]
      - 访问函数
      - 修改函数
   5) size, empty, clear, back, pop_back, push_back(调用reserve增大容
      量)
   6) 支持嵌套的iterator和const_iterator类型，和begin和end方法

***** 实现

#+INCLUDE: ~/Wally/Journal/Project/DataStructure/Vector.h :src cpp


**** 栈
**** 队列

*** 树
CLOCK: [2015-12-06 日 16:09]

**** Tree

***** 表 VS 树
对于大量数据， _线性表的访问时间太长_ ，不宜使用。

*树* 的大部分操作的平均运行时间为 /O(logN)/

/二叉查找树(binary search tree)/, 是 *set* 和 *map* 的实现基础。

应用：
- 文件系统
- 表达式树
- set/map

***** 基本概念

1. /树(tree)/: 由根结点以及零个或多个子树组成 （递归定义）
2. /根(root)/
3. /边(edge)/: 每个树由N个结点和N-1条边组成
4. /儿子(child)/
5. /父亲(parent)/
6. /叶结点(leaf)/
7. /兄弟结点(sibling)/
8. /祖父(grandparent)/
9. /孙子(grandchild)/
10. /祖先(ancestor)/
11. /后裔(descendant)/
12. /真祖先(proper ancestor)/
13. /真后裔(proper descendant)/
14. /路径(path)/: 从祖先到后裔的唯一路径
15. /长(length)/: 路径的条数
16. /深度(depth)/: 根到结点的长，根深度为0
17. /高度(height)/: 结点到叶子的最长路径的长，树叶的高度为0

***** 树的实现

将每个结点所有的儿子放在树结点的 *链表* 中。

#+BEGIN_SRC cpp
  /// \brief 一般树的实现
  ///
  /// 普通树直接存储所有子结点的链接会浪费许多空间
  struct TreeNode{
    Object element;
    TreeNode *firstChild;         ///< 指向儿子
    TreeNode *nextSibling;        ///< 指向兄弟
  }
#+END_SRC

***** 树的遍历

****** 前序遍历(preorder traversal)

/对结点的处理是在它的所有儿子结点处理之前进行的/

应用： 遍历目录



****** 后向遍历

** TOBECONTINED [#A] 德语学习                              :project:deutsch:
- State "TOBECONTINED" from ""           [2015-11-23 一 14:52]

*** TODO 项目规化
1. [ ] 为什么要学习德语？
2. [ ] 什么时间和地点学习德语？
3. [ ] 学习一门语言需要平时投入零散的时间进行记忆，这一点我怎么做到？
4. [ ] 整理已经学习的内容并回顾？
5. [ ] 制定合理的学习计划

** TODO [#A] Raspberry学习                               :project:raspberry:
- State "TODO"       from ""           [2015-11-23 一 15:07]

*** TODO 项目规化
- State "TODO"       from ""           [2015-11-23 一 15:07]

** TODO [#A] 概率论                                           :project:math:
- state "todo"       from ""           [2015-11-23 一 15:01] \\
  概率论的知识十分重要

*** 项目计划 [/]
1. [ ] 教材选择
2. [ ] 学习计划
** TODO [#B] 线性代数学习                                     :project:math:
- state "todo"       from ""           [2015-11-23 一 14:59] \\
  数学的知识是必不可少的，再难也不能放弃学习

*** todo 项目计划 [0/2]
- state "todo"       from ""           [2015-11-23 一 15:00]


1. [ ] 教材选择
2. [ ] 制定计划
** TOBECONTINED [#B] GNU Make                                 :project:make:
- State "TOBECONTINED" from "TODO"       [2015-11-23 一 14:34]
- State "TODO"       from ""           [2015-11-23 一 14:12] \\
  Make学习之路

*** 项目规化
1. 学习教材： 《GNU Make项目管理》
2. 学习计划： *按章节来* ，教材布局合理，由浅入深，内容均布
   1) 首先无笔记式地阅读书籍，计划平均 *1小时*
      - 不圈不点
      - 不实现程序
      - 遇到不会但不是核心的东西暂时不管
   2) 阅读电子版书籍，计划平均 *1.5小时*
      - 实现源码
      - 做ORG-笔记
      - 将不会但不相关的知识使用 *org-capture* 添加到待为事项中，等有
        时间处理
   3) *小结* 并 规化下一步


*** TOBECONTINED make 入门
- State "TOBECONTINED" from ""           [2015-11-23 一 17:25]
CLOCK: [2015-11-20 五 18:31]--[2015-11-20 五 19:43] =>  1:12
CLOCK: [2015-11-20 五 10:12]--[2015-11-20 五 11:24] =>  1:12

**** minted for makefile                                          :minted:
#+begin_example
  $ pygmentize -l lexers | grep make
  ,* basemake:
  ,* cmake:
      cmake (filenames *.cmake, cmakelists.txt)
  ,* make, makefile, mf, bsdmake:
      makefile (filenames *.mak, makefile, makefile, makefile.*, gnumakefile)
#+end_example

*make,  makefile,  mf*

**** make VS scripts
相对于脚本，make的优点是：
*你可以把程序中各元素之间的关系告诉make，然后make会根据这些关系和时间
戳判断应该重新进行哪些步骤，以及产生你所需要的程序*

**** 规则(rule)
1) 工作目标(target)
2) 必要条件(prerequisite)
3) 命令(command)

#+begin_latex
  \begin{minted}[frame=single, mathescape]{mf}
  target:prereq1 prereq2
      commands
  \end{minted}
#+end_latex

e.g.
#+begin_latex
\begin{minted}[frame=single, mathescape]{mf}
foo.o: foo.c foo.h
    gcc -c foo.c
\end{minted}
#+end_latex

运行过程中任何错误都会使make终止工作目标的建立并结束运行。

demo1

** TOBECONTINED [#B] Arduino学习                           :project:arduino:
- State "TOBECONTINED" from ""           [2015-11-23 一 14:57]

*** TODO 项目规化 [0/2]
1. [ ] 教材选择： 《Arduino Cookbook》
2. [ ] 整理已学习内容并制定新的计划

** TODO [#C] OpenCV学习                                     :project:opencv:

*** TODO 项目规化 [1/2]

1. [X] why: 以后必然离不开计算机视觉
2. [ ] 整理资源与选择教材(*最好是书籍教材*)
3. [ ] 项目计划

** TODO [#C] 数字图像处理
- State "TODO"       from ""           [2015-11-23 一 14:43] \\
  应该很好玩

*** TODO 项目规化
1. [ ] 思考： 为什么要学习数字图像处理？
2. [ ] 教材选择：数字图像处理， matlab版还是一般版本(使用Python实现)，
   现在等倾向于后者
3. [ ] 学习计划

** TODO [#C] 数据库学习                                        :project:sql:
- State "TODO"       from ""           [2015-11-23 一 14:48] \\
  数据库的学习可能有必要

*** TODO 项目规化 [1/1]
1. [X] 数据库选择: MySQL 还是 SQLite（优点之一，无后台服务，可以应用于嵌入
   式中）
2. [ ]必要性在哪： *没有找到切切实实的应用之前不要开始*

** TODO [#C] Qt4                                                :project:qt:
*** TODO 项目规化
*** Chapter 1
**** Hello Qt
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/helloqt/helloqt.cpp
  #include <QApplication>
  #include <QLabel>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QLabel* label = new QLabel("Hello Qt!");
    label->show();
    return app.exec();
  }
#+END_SRC

+ 窗口部件(widget)是指用户界面的一个可视化元素，该词源于"window
  gadget"（窗口配件），相当于Window系统术语的”控件”(control)和”容
  器”(container).
+ QApplication对象用于管理整个应用程序所用到的资源，以argc和argv为参
  数，也就是说，Qt支持自己的一些命令行参数。
+ 绝大多数应用程序都会使用一个QMainWindow或一个QDialog作为它的窗口，但
  Qt是如此灵活，以至于任意窗口部件都可以用作窗口。
+ show()方法使部件可见，在创建窗口部件时标签通常都是隐藏的，这样允许先
  进行设置再显示，避免闪烁。
+ app.exec()方法使程序进入事件循环状态，这是一种等待状态，程序会等候用
  户的动作。

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/helloqt2/helloqt.cpp
  #include <QApplication>
  #include <QLabel>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QLabel* label = new QLabel("<h2><i>Hello</i><font color=red>Qt!</font></h2>");

    label->show();
    return app.exec();
  }
#+END_SRC

+ 通过使用一些简单的HTML样式格式，就可以轻松地把Qt应用程序的用户接口变
  得丰富多彩。
**** 建立连接
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/quit/quit.cpp
  #include <QApplication>
  #include <QPushButton>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QPushButton *button = new QPushButton("quit");
    QObject::connect(button, SIGNAL(clicked()), &app, SLOT(quit()));
    button->show();
    return app.exec();
  }

#+END_SRC

**** 窗口部件的布局
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/age/age.cpp
  #include <QApplication>
  #include <QHBoxLayout>
  #include <QSpinBox>
  #include <QSlider>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QWidget* window = new QWidget;
    window->setWindowTitle("Enter your age:");

    QSpinBox* spinBox = new QSpinBox;
    QSlider* slider = new QSlider(Qt::Horizontal);
    spinBox->setRange(0, 130);
    slider->setRange(0, 130);

    QObject::connect(spinBox, SIGNAL(valueChanged(int)),
                     slider, SLOT(setValue(int)));
    QObject::connect(slider, SIGNAL(valueChanged(int)),
                     spinBox, SLOT(setValue(int)));

    QHBoxLayout* layout = new QHBoxLayout;
    layout->addWidget(spinBox);
    layout->addWidget(slider);
    window->setLayout(layout);
    window->show();
    return app.exec();
  }
#+END_SRC

Qt有三个主要的布局管理器：
+ QHBoxLayout
+ QVBoxLayout
+ QGridLayout

**** 窗口部件的风格
Qt应用程序在每个平台上都可以看起来像本地程序一样，Qt是通过所模拟平台的
外观来实现这一点的，而不是针对某个特殊平台的封闭或者一个工具包中的窗口
部件集。
+ Plastique(KDE)
+ Cleanlooks(GNOME)
+ CDE
+ motif
+ Windows(仅能在本地平台上有效，因为需要依赖平台的主题引擎，下同)
+ Windows XP
+ Windows Vista
+ Mac


在X11下，可以在命令行设置程序窗口风格
#+BEGIN_EXAMPLE
./out -style motif
#+END_EXAMPLE

*** 创建对话框
**** 子类化QDialog
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/finddialog.h
  #ifndef FINDDIALOG_H
  #define FINDDIALOG_H

  #include <QDialog>

  class QCheckBox;
  class QLabel;
  class QLineEdit;
  class QPushButton;

  class FindDialog : public QDialog{
    Q_OBJECT

  public:
    FindDialog(QWidget *parent=0);

  signals:
    void findNext(const QString& str, Qt::CaseSensitivity cs);
    void findPrevious(const QString& str, Qt::CaseSensitivity cs);

  private slots:
    void findClicked();
    void enableFindButton(const QString& text);

  private:
    QLabel *label;
    QLineEdit *lineEdit;
    QCheckBox *caseCheckBox;
    QCheckBox *backwardCheckBox;
    QPushButton *findButton;
    QPushButton *closeButton;
  };

  #endif
#+END_SRC

+ 前置声明(forward declaration)告诉C++编译器类的存在，而不用提供类定义
  的所有细节
+ 前置声明的类型在头文件中使用指针声明
+ 编译速度快
+ FindDialog(QWidget *parent=0)为典型的Qt窗口部件构造函数定义方式，
  parent参数指定部件的父窗口，默认为空指针，即没有父对象。
+ 对于所有使用信号和槽的类，在类定义开始处的 Q_OBJECT 宏是必须的。
+ signals部分定义信号，signals实际上是一个宏，C++预处理器会在编译程序
  前将其转换为标准C++代码
+ Qt::CaseSensitivity是枚举类型
  - Qt::CaseSensitive
  - Qt::CaseInsensitive
+ slots部分定义槽，也是宏

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/finddialog.cpp
  #include <QtWidgets>
  #include "finddialog.h"

  FindDialog::FindDialog(QWidget *parent)
    : QDialog(parent)
  {
    label = new QLabel("Find &What:");
    lineEdit = new QLineEdit;
    label->setBuddy(lineEdit);

    caseCheckBox = new QCheckBox("Match &case");
    backwardCheckBox = new QCheckBox("Search &backward");

    findButton = new QPushButton("&Find");
    findButton->setDefault(true);
    findButton->setEnabled(false);

    closeButton = new QPushButton("&Close");

    connect(lineEdit, SIGNAL(textChanged(const QString&)),
            this, SLOT(enableFindButton(const QString&)));
    connect(findButton, SIGNAL(clicked()),
            this, SLOT(findClicked()));
    connect(closeButton, SIGNAL(clicked()),
            this, SLOT(close()));

    QHBoxLayout *topLeftLayout = new QHBoxLayout;
    topLeftLayout->addWidget(label);
    topLeftLayout->addWidget(lineEdit);

    QVBoxLayout *leftLayout = new QVBoxLayout;
    leftLayout->addLayout(topLeftLayout);
    leftLayout->addWidget(caseCheckBox);
    leftLayout->addWidget(backwardCheckBox);

    QVBoxLayout *rightLayout = new QVBoxLayout;
    rightLayout->addWidget(findButton);
    rightLayout->addWidget(closeButton);
    rightLayout->addStretch();

    QHBoxLayout *mainLayout = new QHBoxLayout;
    mainLayout->addLayout(leftLayout);
    mainLayout->addLayout(rightLayout);
    setLayout(mainLayout);

    setWindowTitle("Find");
    setFixedHeight(sizeHint().height());
  }


  void FindDialog::findClicked(){
    QString text = lineEdit->text();
    Qt::CaseSensitivity cs =
      caseCheckBox->isChecked() ? Qt::CaseSensitive
      : Qt::CaseInsensitive;
    if(backwardCheckBox->isChecked()){
      emit findPrevious(text, cs);
    }else{
      emit findNext(text, cs);
    }
  }

  void FindDialog::enableFindButton(const QString &text){
    findButton->setEnabled(!text.isEmpty());
  }

#+END_SRC
+ #include <QtWidgets>包含所有窗口部件，但在一个头文件中包含一个在的头文
  件着实不是一个好的编程习惯。
  + Qt4 $include <QtGui>
+ 构造函数中把parent参数传递给基类的构造函数
+ tr()函数表示翻译，有时是不错的选择
+ &操作符表快捷键(Alt+W)
+ 所谓“伙伴”(buddy)，就是一个窗口部件，它可以在按下标签的快捷键时接
  收焦点(focus).
+ setDefault()设定默认按钮(default button), 即当用户按下Enter键时对应
  的按钮。
+ 通过 QHBoxLaytout,QVBoxLayout,QGridLayout的不同嵌套组合，可以构建出
  相当复杂的对话框。
+ addStrentch方法增加分隔符(伸展器)，用来占据空白区域
+ 当将子布局对象添加到父布局对象，子布局对象就会重新定义自己的父对象。
  它所有的子窗口部件都会重新定义自己的父对象。
+ QWidget::sizeHint()方法返回部件“理想”的尺寸大小
+ 创建窗口对象使用的是new，所以需要调用delete来析构。但这样不是必须的，
  Qt在删除对象时会自动删除所有的子对象
+ emit是Qt扩展的关键字，像其它Qt扩展一样，它也会被C++预处理器转换为标
  准的C++代码

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>

  #include "finddialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    FindDialog *dialog = new FindDialog;
    dialog->show();
    return app.exec();
  }

#+END_SRC

+ 为了使 *moc* 能够正常运行，必须把类定义从实现文件中分离出来并放到头
  文件中
+ 必须对使用了Q_OBJECT宏的类运行moc(qmake),否则会出现不明确的错误信息。
+ 默认的Tab键顺序是创建窗口部件的顺序，可以使用QWidget::setTabOrder()
  方法设置
+ 提供一种合理的Tab键顺序的键盘快捷键可以确保不愿（或者不能）使用鼠标
  的用户能够充分享受应用程序提供的全部功能。完全通过键盘控制应用程序也
  深受快速输入人员的赞赏。

**** 信号和槽
1. 槽
   + 可以是虚函数
   + 可以被重载
   + 可以是公有的，私有的，保护的
   + 可以被其它成员函数直接调用
   + 参数可以是任意类型
   + *槽可以与信号连接*
2. connect(sender, SIGNAL(signal), receiver, SLOT(slot))
   + sender, receiver是指向QObject的指针
   + signal和slot是不带参数的函数名
3. 机制
   + 一个信号可以连接多个槽
     + 发射信号时，会以不确定的顺序一个接一个调用关联的槽
   + 多个信号可以关联一个槽
   + 一个信号可以与另外一个信号关联
     #+BEGIN_EXAMPLE
       connect(lineEdit, SIGNAL(textChanged(const QString&))
               this, SIGNAL(updateRecord(const QString&)))
     #+END_EXAMPLE
   + 连接可以被移除
     + 很少用，当删除对象时，Qt会自动移除和这个对象相关的所有关联。
4. 注意
   + 信号和槽的参数必有有相同的顺序和相同的类型
   + 信号的参数比槽多时，多余参数会为被忽略
   + 不匹配则警告
   + 信号和槽机制是由QObject实现，并不只是局限于图形界面编程

**** Qt的对象系统
moc(meta-object system), 对C++的重要扩展。
+ 信号和槽
+ 内省
**** 快速设计对话框
Qt的设计初衷是为了能够直观并且友好也进行 *手工编码* ，并且对于程序员来
说， 编写C++源代码开发整个Qt应用程序并不稀奇。

QtDesigner提供了Qt的可视化编码方式。

手工编码和使用QtDesigner在创建对话框时的基本步骤是一致的
1. 创建并初始化子窗口部件
2. 把子窗口部件放到布局中
3. 设置Tab键顺序
4. 建立信号的槽的连接
5. 实现对话框自定义的槽

***** 使用QtDesigner设计对话框并保存为 ui 文件
+ filename.ui
+ Qt用户界面编译器(user interface compiler, uic) 将ui文件转换为C++代码
  + $ uic filename.ui
  + ui_filename.h
    + 头文件中包含了Ui::GoToCellDialog的定义(GoTocelldialog为
      QtDesigner设计的窗体的顶层部件的objectName)
    + setupUi()函数用于初始化窗体

****** 直接使用
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>
  #include <QDialog>

  #include "ui_gotocelldialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);

    Ui::GoToCellDialog ui;
    QDialog *dialog = new Dialog;
    ui.setupUi(dialog);
    dialog.show();
    return app.exec();
  }

#+END_SRC

+ 什么也做不了

****** 多继承：最简捷
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/gotocelldialog.h
  #ifndef GOTOCELLDIALOG_H
  #define GOTOCELLDIALOG_H

  #include <QDialog>

  #include "ui_gotocelldialog.h"

  class GoToCellDialog : public QDialog, public Ui::GoToCellDialog{
    Q_OBJECT

  public:
    GoToCellDialog(QWidget *parent=0);

  private slots:
    void on_lineEdit_textChanged();
  };

  #endif
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/gotocelldialog.cpp
  #include <QtWidgets>

  #include "gotocelldialog.h"

  GoToCellDialog::GoToCellDialog(QWidget *parent)
    : QDialog(parent)
  {
    setupUi(this);

    QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");
    lineEdit->setValidator(new QRegExpValidator(regExp, this));

    connect(okButton, SIGNAL(clicked()), this, SLOT(accept()));
    connect(cancelButton, SIGNAL(clicked()), this, SLOT(reject()));
  }

  void GoToCellDialog::on_lineEdit_textChanged(){
    okButton->setEnabled(lineEdit->hasAcceptableInput());
  }
#+END_SRC

+ setUp()还会自动将那些符合on_objectName_signalName()命名惯例的任意槽
  与相应的objectName的signalName()信号连接到一起。
+ Qt提供了三种内置检验器类:
  - QIntValidator
  - QDoubleValidator
  - QRegExpValidator
+ 通过this传递绘QRegExpValidator的构造函数，使它成为窗口的子对象，这样
  就可以不用担心有关删除QRegExpValidator的事情了，当删除它的父对象时，
  会被自动删除。
+ Qt的父子对象机制是在QObject中实现的。很大程度上简化了内在管理的工作，
  降低了内在泄漏的风险。需要明确删除的是那些使用new创建并且没有父对象
  的对象。
+ accept()和reject()槽都可以关闭对话框，前者将QDialog::Accepted置1,后
  者置0.

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>

  #include "gotocelldialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    GoToCellDialog *dialog = new GoToCellDialog;
    dialog->show();
    return app.exec();
  }

#+END_SRC

+ 注：org tangle不会覆盖已存在的文件

**** 改变对话框的形状
+ 扩展对话框(extension dialog)
+ 多页对话框(multi-page dialog)

***** 扩展对话框

Qt Designer允许我们在构成同一窗体的不同部分内的窗口部件之间建立连接。
+ Edit -> Edit Signals/Slots 进入设置连接模式。

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/sortdialog.h
  #ifndef SORTDIALOG_H
  #define SORTDIALOG_H

  #include <QDialog>

  #include "ui_sortdialog.h"

  class SortDialog : public QDialog, public Ui::SortDialog{
    Q_OBJECT

  public:
    SortDialog(QWidget *parent=0);
    void setColumnRange(QChar first, QChar last);
  };

  #endif
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/sortdialog.cpp
  #include <QtWidgets>

  #include "sortdialog.h"

  SortDialog::SortDialog(QWidget *parent)
    : QDialog(parent)
  {
    setupUi(this);

    secondaryGroupBox->hide();
    tertiaryGroupBox->hide();
    layout()->setSizeConstraint(QLayout::SetFixedSize);

    setColumnRange('A', 'Z');
  }

  void SortDialog::setColumnRange(QChar first, QChar last){
    primaryColumnCombo->clear();
    secondaryColumnCombo->clear();
    tertiaryColumnCombo->clear();

    secondaryColumnCombo->addItem("None");
    tertiaryColumnCombo->addItem("None");
    primaryColumnCombo->setMinimumSize(
                                       secondaryColumnCombo->sizeHint());

    QChar ch = first;
    while(ch <= last){
      primaryColumnCombo->addItem(QString(ch));
      secondaryColumnCombo->addItem(QString(ch));
      tertiaryColumnCombo->addItem(QString(ch));
      ch = ch.unicode()+1;
    }
  }
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/main.cpp
  #include <QApplication>

  #include "sortdialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    SortDialog *dialog = new SortDialog;
    dialog->setColumnRange('C', 'F');
    dialog->show();
    return app.exec();
  }

#+END_SRC

***** 多页对话框
+ QTabWidget
+ QListWidget
+ QStackedWidget


**** 动态对话框
+ 动态对话框(dynamic dialog)就是在程序运行时使用的从Qt设计师的.ui文件
  创建而来的那些对话框。
+ 运行时加载，而非先使用uic将ui文件转换为C++代码
+ 使用QUiLoader类载入ui文件
  #+BEGIN_EXAMPLE
    QUiLoader uiLoader;
    QFile file("sortdialog.ui");
    QWidget *sortDialog = uiLoader.load(&file);
    if(sortDialog){
        ...
    }
  #+END_EXAMPLE
+ 使用QObject::findChild<T>()来访问窗体中的各个子窗口部件
  #+BEGIN_EXAMPLE
    QComboBox *primaryColumnCombo =
              sortDialog->findChild<QCombobox *>("primaryColumnCombo");
    if(primaryColumncombo){
        ...
    }
  #+END_EXAMPLE
+ 对于MSVC 6, 须使用全局函数qFindChild()函数代替
+ QUiLoader类放在一个独立的类库中，需要在pro文件中加入 CONFIG += uitools

**** 内置的窗口部件和对话框
1. 按钮
   + QPushButton
   + QToolButton
   + QRadioButton
   + QCheckButton
2. 容器
   + QGroupBox
   + QFrame
3. 多页窗口部件
   + QTabWidget
   + QToobBox
4. 项视图窗口部件
   + QListView(列表/图标)
   + QTreeView
   + QTabView
5. 显示窗口部件
   + QLabel(应用最多，显示普通文本，HTML，图片)
   + QLCDNumber
   + QProgressBar
   + QTextBrowser
6. 输入窗口部件
   + QLineEdit
   + QTextEdit
   + QSpinBox
   + QDoubleSpinBox
   + QComboBox
   + QDateEdit
   + QTimerEdit
   + QDateTimeEdit
   + QScrollBar
   + QSlider
   + QDial
7. 对话框
   + QInputDialog
   + QProgressDialog
   + QMessageBox
   + QErrorMessage
   + QColorDialog
   + QFontDialog
   + QPageSetupDialog
   + QFileDialog
   + QPrintDialog
8. 向导
   + QWizard
9. 富文本引擎
   Qt库含有一个富文本引擎(rich text engine)，用于格式化文本的显示和编
   辑。
