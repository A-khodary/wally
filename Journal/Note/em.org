
* Fundamental                                                         :emacs:
** Emacs Belief
*** 生活在Emacs中
本文将给我带来无限方便的Emacs的一些使用技巧. 也许会向读者灌输一些
偏激的RMS(RichardStallman, 就是教主和精神领袖)的思想. 随着不断深入学
习和使用, 我将不断更新本文. 这里感谢所有给我提供Emacs帮助的朋友(名字我
没有列, 但相信你们可以感受到我的心), 也希望此文能帮助一些后来人, 我就
满足了.

*使用Emacs的缺点是, 你会患上Emacs"综合症"* , 上瘾, 在没有Emacs的电
脑前感到痛苦, 觉得世界暗了下来. 说明:Emacs是为每天使用八小时以上计算机
的人(不包括专业电脑打字员, 银行窗口操作员, 传呼台小姐等)或非常喜爱电脑的
人设计的, 一般人是不太会喜欢的. 所有程序员都喜欢Emacs是不可能的, 涉及
个人爱好等多方面原因, 但某种意义上讲, 一个大学或研究所(公司无所谓)只有
"非常少数"的学生和程序员知道和使用Emacs, 那也是一种悲哀!!

*这是一种生活方式, 一种信仰, 一种文化*. 你会逐渐排斥非Emacs的别的东
西. 就象基督教和伊斯兰教一样. 她博大精深, 渊源流长, 甚至和我本人同岁
(1974年有其最初模样). 只可惜我硕士(自动化专业, 热爱电脑)毕业前竟然不知
其大名. 有多少人和我也一样,  *某种意义上讲, 这是我国计算机教育的悲哀*. 我
们显然成了某几个商业公司的培训机器, 没有看到计算机科学的真正所在.

1. 我原来自己作了个超文本文件, 相当于日历, 作为电脑屏幕壁纸, 用于提醒自己
   的日程安排. 感觉不够可视化. 现在我删除了这个文件, 因为Emacs的Calendar
   很方便地完成了我的要求.  *所有将来有事的日子都会加亮显示*. 我每天一到
   电脑前必然先Emacs, 原来设置为自动调calendar, 后来又改为按F3调出它. 另
   外, 不知你相不相信, 这个Calendar能告诉你你想知道的任意一天天安门前升
   国旗的准确时间. 只要你告诉她经纬度等信息. 够酷吧!!

2. 我 *用AucTeX写TEX文件, 配合outline-minor-mode, bibtex-mode和
   reftex-mode感觉相当舒服*, 在文档中穿梭有种飞的感觉, 那隐藏和折叠的
   功能象变魔术一样. 要说快的话, 这个肯定最快, 象别的集成工具去菜单上
   找东西, 黄瓜菜都凉了, 比如C-c C-e两三个键就可以输入一个(begin{}
   end{})公式环境, 连标签label也同时可以输入. AucTeX其中还有一个神奇的
   功能就是区域编译, 如果你的文章很长很长, 新输入一个公式, 想马上看看
   效果, 只要选中这个公式, 按C-c C-r就会只编译这个公式. 对于老想编译看
   结果但又怕浪费时间的人, 这可是好东西. 使用Emacs, 就要相信神奇!!

3. 我的所有网页也是用Emacs写的, 虽然不是所谓所见所得工具, 但非常快. 一
   键(甚至不按键, 存盘时自动上传到服务器, 神不知鬼不觉. )就可以上传到
   服务器.

4. 我把经常访问的几个文件(如我的读书笔记等)在Emacs"挂了号", 比如只要我
   一按F5, 就会调出笔记来修改或阅读. 我把经常访问的网址写入一个HTML文
   件(现改为Wiki文件, 因为简单好写), 一按F6就调出来, 然后在相应网址击
   鼠标或回车就可以访问相应的地址.

5. 我的科技图形用 *MetaPost* 写, 当然也在Emacs中编辑, 按一个快捷键就能
   预览结果, 非常方便. Emacs中也有Meta方式来支持MetaPost文件的编辑. 不
   过使用metapost, 关键还是要用你的大脑, 谁也帮不了, 要不用别的"集成式
   "或"傻瓜式"工具.

6. 英文文本或TEX文件, 可以用ispell拼写检查, 还有一个flyspell-mode, 边
   输入就能检查, 方便极了.

7. 我的个人网页用CVS管理, Emacs作为其前端, 更为重要的是, 我的操作系统
   是日文, 在普通命令行下diff两个汉字文本当然是乱码, 借助Emacs, 完美地
   解决了问题. 我的网页文件放在本地, 用CVS管理(主要是玩和感觉一下
   CVS). 每次更新后我要上传到服务器. 原来用cutftp. exe. 按一堆按钮. 后
   来在Emacs的Eshell中拷贝或dired的dired-do-copy. 都需要动手输入服务器
   上的目标目录, 比较讨厌. 后来的完美的方法是:
   #+BEGIN_EXAMPLE
         (global-set-key [(f12)] 'UpMeToCn)
             (defun UpMeToCn()
             "Upload me to the ftp /cn"
             (interactive)
             (copy-file buffer-file-name "/...@133.62.153.5:/home/li/public_html/Cn"
      t
     ))
   #+END_EXAMPLE
   按F12就把当前编辑.件上传了. 我激.跳了起来. (我发邮件问过这个问题,
   可能是太简单了, 没人回答, 后来自己.了. )如果你连这一个键都懒的按,
   可以将这个函数加到存盘的,ok上去, 每次存盘时就上传.或者十分钟上,次,
   都是,的, 看各人喜好了!

8. 我要经常备份我的文件, 为了不重复也不漏掉, 用Emacs的Ediff精确比较硬
   盘和光盘上的对应目录, 只备份改过的和新的东西.
9. 我经常收到或下载来各种编码的文件, 中文简繁, 日文EUC/Shift-JIS,
   Unix/dos/mac等, Emacs中自如阅读和转换。

10. 我的控制C程序中分为仿真和实验两块, 用宏定义SIMU来区别, 以前苦恼的
    是经常在仿真时改了实验部分的代码, 使用了Emacs的 *hide-ifdef-mode*, 仿
    真时将实验部分的代码隐去, 再没有发生类似错误, 而且程序显得短多了,
    头脑也清晰多了.

11. Emacs中有一款五子棋游戏gomoku, 我从来没有赢过它. 也难怪, RMS的老巢
    MIT是人工智能的圣地. 当然这个游戏并非他本人所写. 有人说是第一个人
    工智能的产物, 不无道理, 因为LISP语言本身就是人工智能的语言, 表面上
    Emacs"非常难使用", 但实际上她非常人性化, 比如你可以以字母, 单词,
    句, 段落, 全文等为步长移动光标. 面对不同格式的文件有不同的界面和菜
    单等。

12. 有时想数一篇文章或一段有几个单词, word-counter.el提供了这样的功能,
    对应TeX文件有tex-wcount.el.

13. 我日文输入速度慢, 有时平假名和片假名的切换慢, Emacs竟也提供了这样
    的功能, 比如把选定部分变为片假名等很多功能. 而且LEIM的日文输入做的
    非常好, 不象中文拼音不能输入词组. 当然这与半田(Handa)先生有关.

14. 我有时需要直接读写远程服务器上自己的网页文件, 这一点Emacs也当然能
    做到, 就象编辑本地文件一样, 根本感觉不到"先下载, 然后改写, 再上传"
    的过程. Emacs原本就是专为Hacker而设计的. 更为重要的是, 由于我的操
    作系统是日文, 如果对方的服务器里的目录和文件名是中文的话, 只有在这
    里才能看到其真面目. 关键时候真是管用, 否则你根本不知那是什么目录,
    无从下手.
15. 最近Wiki火了一把, Emacs自然不会缺席, Emacs-wiki模式独成一派, 耳目
    一新. 可以方便地把wiki文件转变(Publish)成HTML文件等, 也可以以多种
    方式浏览. 让我差点把以前的全部个人HTML笔记变成Wiki格式, 新的笔记当
    然就会使用她了(唯一的缺憾是windows版的Emacs多少有些不完美).

16. 使用Emacs, 尤其是象我一样的中国人, 就意味着你最好好好学学英语, 甚
    至日语(Mule是日本的半田Handa先生主要开发的. Emacs靠MULE处理汉语.
    日本对这些方面有着很深很细的积累, 想学?请先学日语!). 以便和别人交
    流, 向别人请教. (顺便说几句闲话, 日本和美国的区别在于, 美国提出高
    深的新理论, 日本潜心细致学习, 然后作成仪器卖. 就象Fuzzy控制, 神经
    网络, 浑沌控制等都是如此, 日本的"细"和"小"是很历害的, 汽车, 笔记本
    电脑也都是这样. 我经常看见天津夏利汽车大小的推土机骑在小水沟上挖泥,
    非常可爱. 大家伙可能德国的也不错. 真该好好解读一下这两个二战战败国
    的神奇重建). 我就曾冒昧地给ShenghuiZHU(GNUS维护者, 中国人), 和
    Jason(NTEmacs维护者, 他可也会日语啊!)发Mail请教过, 并得到了指点.
    真的感谢他们. (我是在广泛查找和网上提问没有找到答案的情况下才冒昧
    直接发邮件的, 一般的问题最好不要直接发问, 高手都很忙啊!)但实在没有
    实力和勇气向RMS提问, 以他的性格, 面对象我等小辈提的弱智问题(千万别
    和他提微软, Windows), 估计答复是
    "Ihopesomebodywillansweryourquestion". 我也从来没有拒绝过任何一位
    直接给我发邮件讨论的朋友(如果有那么一两个的话, 当然前提是要简单明
    确, 不是象"我的电脑死机了, 怎么办"这样笼统的问题, 或感觉是让我代替
    做作业!).

17. Emacs就意味着你要维护着一个自己的. emacs文件. 某种意义下, 这个文件
    越大, Emacs越贴近你自己, 就象你的宠物一样, 也意味着你的水平越高.
    难怪网上那么多高手把自己的. emacs文件公布了出来. 这个文件太长时,
    最好字节编译一下, 如下的代码可以在你每次修改该文件后存盘时自动编译.
    该办法可以用来处理前面说的自动上传文件.


18. Emacs还有一位心理医生, 没事的时候可以和她聊两句, 挺逗的, 象真的一
    样, 都是人工智能的产物.

19. 有一种功能能当你存盘时自动更新第一行中的时间戳, 有时很有用. 我还从
    网上搞了几个函数, 可以在文章的任何地方随时插入当前时刻, 也很方便.
    本网页下面的更新时间原来就是这样改变的. 但是这样还是不爽, 因为我老
    得去手动插入. 不要紧, 有个宏包, html-helper-mode. el, 将这个时间放
    在特殊的注释语句内, 每次保存时就会自动更新. 再也不用去操心了. 也可
    以自己写, 挂hooks在保存上, 如下. 享受Emacs的快乐吧.
    #+BEGIN_EXAMPLE
      (add-hook'write-file-hooks
      (function (lambda () (set-lastmodified-tag) )))
      (defun set-lastmodified-tag ()
              "Insert current date after Last Modified:
              (interactive)
              (let ((tostr (concat "Last Modified: " (current-time-string) ". ")))
              (save-excursion
              (goto-char (point-min))
              (while (re-search-forward
              "\\Last Modified:\\([A-Za-z0-9: ]*\\)?\\. " nil t)
              (replace-match tostr nil t)))))
    #+END_EXAMPLE

20. *键盘宏* 的功能很好. 你可以将自己的一连串键盘操作录制成键盘宏, 经常使
    用的还可以起个名字保存到文件中, 象函数一样使用. 比如, 你可以将如下
    一连串动作起个名字GoHome:存盘, 关闭所有Buffer, 看看日历明天有什么
    安排, 然后退出Emacs, 甚至关机(这个我没有试过. )放到. emacs文件中,
    M-xGoHome就会执行这一系列动作. 比如前面的AucTeX, 编译时要按C-cC-c
    再按回车, 我讨厌多按这一下回车, 就编了个键盘宏并设置F9为快捷键, 按
    F9自动pdflatex文件.

21. 玩Emacs, 你一定要有坚定的信念. 当你经常做某件事或为某事感到困惑,
    一定要想到你的问题别人早就碰到并解决了, 你需要的只是找到这个答案.
    Emacs的事还是要Emacs自己解决, 肯定能解决, 顶多是时间问题. 比如, 关
    于文件备份的问题, 如果你不要备份, 不太安全. 象我这样谨慎的人肯定会
    要备份文件. 要吧, 会在你当前目录生成很多以~为扩展名的文件. 比较讨
    厌, 我就专门稿了个批处理去清理它们. 实际上Emacs可以重定向所有备份
    文件到一个临时目录中去. 你可以定期清理. 放心, 不同目录下的相同文件
    也不会搞混了. 还有类似版本管理的功能. 偷笑去吧!

23. 很多人不习惯Emacs的快捷键, 说记不住. 实际上你可以任意定义它们. 还
    有嫌菜单少, 按钮少, 实际上菜单也可以任意填加. 只不过你可以设想, 当
    你的桌面全是菜单和按钮的时候, 你在哪里工作啊?!这是很惨的事啊!!熟练
    的Emacs用户根本没有菜单, 更别说按钮. 全窗口都是工作空间, 够酷吧.

23. 使用Emacs的人几乎用不着鼠标, 对笔记本用户来说最合适了, 台式机用户
    也不用在一堆书和资料下去找那可爱的鼠标了.


I know the number of grains of sand as well as the expanse of the sea,
And I comprehend the dumb and hear him who does not speak
If Croisus passes over the Halys he will dissolve a great Empire. .
                                     -------------Oracle of
*** 我承认也许Emacs只是碰巧在我人生试图发生改变的时候, 碰巧发生在了我的面前

link:https://ruby-china.org/topics/2262

得益于 @fly2never的分享, 我看到一个有关松本行宏先生当年如何使用Emacs,
以及如何使用Emacs实现Ruby的PPT演示稿, 其中讲了许多我原先不知道的, 发生
在Emacs和Ruby之间的故事.

原文链接:
http://www.slideshare.net/yukihiro_matz/how-emacs-changed-my-life

我相信不是每个人都愿意去读英文. 我就毛遂自荐, 为大家翻译了, 之所以做这
件事情, 我想主要是PPT的内容引起了我强烈的共鸣的缘故吧. 虽然使用
Emacs(以及Ruby)的层次和水平我和Matz相差比天高, 不过, 这并无法阻止我发
自内心的喜欢Ruby, 喜欢Emacs.

事实上, 我在给Ruby新人的公开信就有提到, 我的Ruby编程之路, 是始于Emacs
的学习与使用. 而且在我个人身上, 真真切切的发生了一件和Matz非常相似的事
情. 那就是: 在使用Emacs之前, 接触过很多IDE, 也曾是Borland的忠实粉丝,
但是很多年, 我一直对编程提不起兴趣或无法坚持, 主要原因, 应该是我像电影
里演的那样, 那些黑客的那种噼里啪啦如行云流水一般的感觉. 真正的改变, 发
生在使用Emacs以后, 找到了一种久违的写字的感觉. 我使用org-mode记笔记,
以及GTD整理我的思绪, 并乐此不疲的折腾再折腾, 说白了就是为了这种传说中
的feeling. 随心所欲的feeling, 自由的feeling.

我承认也许Emacs只是碰巧在我人生试图发生改变的时候, 碰巧发生在了我的面
前, 但不可否认的是, Emacs最为个人未来编程生涯的一个起点, 而且显而易见,
现在我每天做的每件事情, 几乎都跟它有关(离不开它), 从这个意义上来说,
Emacs对我个人而言, 正如matz那样, 一个新的开始, 而现在看起来, 也是一段
美好的回忆.

下面正文开始:

*Emacs改变了我的人生* 原著: Yukihiro Matsumoto(松本行宏), 翻译: zw963

+ 在1980年.
+ 我开始编程...
+ (出现了一个夏普计算器的图像)
+ 400 steps (应该是那个计算器的型号, 表示那时候计算机还很初级.)
+ 到了1988年.
+ 在一台SUN-3型pp计算机上, 我遇到了Emacs.
+ 同学们之间相互分享这个东西.
+ 我也尝试着使用它.
+ 但是我无法真正使用它.
+ 因为Emacs在系统内被禁止使用的.
+ 因为它占用了太多的宝贵内存. (现在绝大多数的程序员应该无法想象当年节
  省1kb内存对于一个程序来说多么重要)
+ 但是我们可以自由下载, 因为它是自由软件.
+ 我下载了Emacs源码.
+ 开始研究...
+ Emacs是我使用过的地一个Lisp解释器.
+ 从Emacs中, 我了解到很多很多有关语言的实现.
+ embedding integers in pointers (如何在指针的低位嵌入目标类型)
+ (使用Mark and Sweep的方式来处理垃圾收集问题)
+ C 和 Lisp 之间的调用约定.
+ 我实实在在的懂得了Lisp如何工作.
+ 我沉迷于Lisp对象, 以及如何通过C来实现Lisp.
+ 这一年, 我开始使用Sparc工作站.
+ 我终于开始使用Eamcs.
+ Emacs变成了我的一部分.
+ 我可以随心所欲的改变任何不喜欢的地方.
+ Emacs的所有东西都是完全可配置的.
+ Emacs, 让我实现了作为一个程序员可以实现的所有一切.
+ 我可以随心所欲的换绑任意按键.
+ 离开Emacs, 我不想写任何东西.
+ 包括程序, 文档还有Mail.
+ 所以我写了我自己的Mail Lisp客户端.
+ 它叫做cmail. 在Emacs下使用.
+ 这是我写的第一个(不算太小的)Emacs-Lisp 程序.
+ 我每天都在使用它.
+ 到了1993年. (地球人都知道, 1993年发生了什么)
+ 我开始了Ruby解释器的开发.
+ 受到Emacs解释器的影响.
+ Integers are coded in tagged points (还是不明白, 整数被硬编码为tagged指针?)
+ 我使用了简单的mark以及垃圾收集机制.
+ 我使用了类似于Lisp的对象模型.
+ 并借鉴了Smalltalk一切都是对象的理念.
+ 在语法上, 我借鉴了Algol, Ada, Eiffel.
+ 但是, 作为一个沉溺于Emacs的瘾君子, 我还需要一个用于编写Ruby代码的mode.
+ 首先, 自动缩进必要的.
+ 在1993年, 还没有针对Ruby这类语法(以end作为结束)的自动缩进模式.
+ 所以, 我尝试写了一个ruby-mode.el
+ 基本上就是处理_emacs lisp_和_正则表达式_之类的概念.
+ 整整花了我一个星期...
+ 用尽各种办法, 我愣是给实现了代码自动缩进功能.
+ 现在回想起来, 如果(当时)我无法让ruby-mode开始工作.
+ 现在Ruby的语法也许会被改变.
+ 也许会变的更像C一些.
+ 或者和其他脚本语言更相似.
+ 如果那样做了, 我想Ruby一定没有现在这么受欢迎.
+ 总结
+ Emacs教会了我自由软件精神.
+ Emacs教会了我如何读代码.
+ Emacs教我领略了Lisp的威力.
+ Emacs教会了我如何实现一个语言核心.
+ Emacs教会了我如何实现垃圾收集.
+ Emacs帮助我编码和调试.
+ Emacs帮助我写, 编辑文本, 邮件, 文档等等.
+ Emacs使我成为一个高效的程序员.
+ Emacs使我成为了一个hacker.
+ Emacs改变了我的生活.
+ 永远...
+ 感谢Ｅｍａｃｓ.
*** 为什么使用Emacs
[[http://blog.chinaunix.net/uid-8118579-id-2034107.html#blogdtr]]

+ 无限的可扩展性及高度的可定制性
+ 强大的分屏编辑功能
+ 支持多种语言编辑模式,支持gcc,gdb,make,cscope的集成
+ Emacs Dired模式非常好用
+ 支持过十六进制编辑
+ 对正则表达式的支持非常好
+ Ediff很好用
+ eshell执行shell命令
+ CVS客户端
+ org-mode
+ 书签,计算器,日历
+ emms使得Emacs成为媒体播放器
+ w3m使得Emacs成为网页浏览器
+ gnus,gutt邮件收发
*** 为什么我还在使用Emacs
http://www.oschina.net/news/25874/why-i-am-still-using-emacs#NewsChannel

 + Emacs有GUI和CLI界面（TODO： 这里增加一个脚注解释什么是CLI）
   像Eclipse等IDE只有GUI界面，不适合在服务器上工作
 + Emacs可以完全键盘操作
 + Emacs拥有命令缓冲，即 M-x
 + Emacs配置灵活
 + Emacs可以编辑所有文件
 + Emacs有很多模式
   - calc-mode：计算器，支持大整数，无理数，复数和向量等等，通过C-x * *打开或
     关闭该模式。
   - epa-mode: 啊米果文件（不知道是什么），可以加密保存（这个有趣）。
   - org-mode: 无需多言。
   - ido-mode:
   - anything: 输入任何东西，就会返回可能的结果
   - occur-mode: 通过正则表达式搜索所有Emacs打开的文件
   - ibuffer
   - Tetris游戏
 + Emacs缺憾
   - 没有多线程支持
   - Elisp并不是特别好的语言，慢
   - 同一个文件中使用多个模式支持得不好
   - 对支持的编程语言没有语义支持，没有智能提示、重构等
** Emacs Tutorials
*** 最有帮助
**** Emacs学习笔记（1）：初学者的学习计划
已经用了5年的[[http://www.vim.org/][vim]]，
最近突然想试试[[http://www.gnu.org/software/emacs/ ][Emacs]]。不要问我为什么，我自己也
不清楚：），也许只是一时心血来潮，也许是对vim实在没有感觉，也许...但不管怎么
说，要学好一样东西，一定要有一个计划，并能够有效执行。参考网上的众多资源，结合
自己的实际情况，拟定了一个《Emacs初学者学习计划》

在开始学习之前，首先要确定一个原则就是：随时用，尽量用。就好像当年学习Linux，
彻底卸载了Windows,斩断了退路，才能去解决遇到的一个个问题。学习Emacs应该也是
一样，而且Emacs能做的事情很多，写文档，写代码，日程安排，收发邮件，浏览网页...
在这些场景下都坚持使用，相比能受到很好的效果。废话不多说，把学习计划show一下
（顺便说一句，这个计划的初稿就是用Emacs编辑的，但是使用了好多次鼠标）。

Emacs初学者学习计划（已完成的会添加链接）
[[http://www.cnblogs.com/holbrook/archive/2012/02/15/2357335.html][初识Emacs]]
Emacs能做什么，与同类软件相比，Emacs的优势在哪里
[[http://www.cnblogs.com/holbrook/archive/2012/02/15/2357335.html][最基本概念]]
界面的各个组成部分的功用，其他必须知道的概念
[[http://www.cnblogs.com/holbrook/archive/2012/02/16/2357334.html][帮助系统]]
遇到问题时如何查看帮助
[[http://www.cnblogs.com/holbrook/archive/2012/02/18/2357332.html][基本的编辑功能]]
Emacs至少是个编辑器，掌握编辑功能是根本
[[http://www.cnblogs.com/holbrook/archive/2012/02/18/2357660.html][高级编辑功能]]
如何使编辑工作更有效率
[[http://www.cnblogs.com/holbrook/archive/2012/02/28/2371205.html][有效率地学习]]
从了解到熟悉
[[http://www.cnblogs.com/holbrook/archive/2012/03/06/2381636.html][基本的定制]]
据说Emacs的强大来自于几乎无所不能的定制，至少要知道能定制什么，
并掌握一些简单的定制

相信掌握的这些内容，对Emacs可以成为“入门”了。同时我还找到一本书：叫《学习GNU
Emacs》
中文版：http://download.csdn.net/detail/thinkinside/4064868
英文版：http://download.csdn.net/detail/thinkinside/4064874

**** Emacs学习笔记（2）初识Emacs
内容提要:
1. Emcas是什么
2. Emacs能做什么
3. Emacs的界面
4. 基本概念--命令
5. 基本概念--快捷键
6. 基本概念--模式

***** 1.Emacs是什么
其实很难给Emacs下一个定义。正统的说法也许是“[[http://zh.wikipedia.org/zh-cn/Emacs][Emacs即Editor MACroS(宏编
辑器)，是一种文本编辑器]]”。
最初人们认为Emacs是一个编辑器(Editor)，与Vim一起并称两大神器，据说Vim是编辑
器之神而Emacs是神之编辑器，又据说世界上的程序员分三种，一种使用Emacs，一种
使用vim，剩余的是其他。
也有人认为Emacs是一个架构在编辑器上的集成环境，除了最基本的编辑功能，还可以
完成文件管理、终端模拟、浏览网页、收发邮件、编译程序等工作，以及煮咖啡。
更有人说Emcas是伪装成编辑器的操作系统，甚至说[[http://arch.pconline.com.cn//pcedu/soft/gj/photo/0609/865628.html][Emacs是一种信仰]]。
Emacs最初是由Richard Stallman在1975年开发，之后产生了众多的衍生版本，而目前
使用的最多的两个版本是Richard Stallman在1984年开发的GNU Emacs和1991年Jamie
Zawiski写成的XEmacs。Emacs可谓历史悠久，目前的GNU Emacs的版本是23.4。[[http://wiki.woodpecker.org.cn/moin/EmacsHackerHistory?highlight=%28Emacs%29][一
部Emacs的历史，等于一部计算机史，一部世界黑客史]]。本文不想将[[http://en.wikipedia.org/wiki/Editor_war][编辑器大战]]
的战火烧到这里，所以还是就此打住，来看看Emacs能做什么。

***** 2.Emacs能做什么
[[][王垠]]师兄[[][如是说]]：
据我所知，Emacs的能力包括：
1. 编辑文本
2. 编辑晨曦
3. 作为其它程序的界面
4. 作为操作系统
5. 煮咖啡

Emacs是一个具有超强扩展性，超强定制性的操作平台，它能做什么取决于你对它的定制
和扩展。Emacs之所以强大，就是源于其近乎无限的可定制性和可扩展性。

***** 3.Emacs的界面
未定制的Emacs如下图所示：
整个窗口在Emacs中叫做frame，图形界面下的Emacs可以打开多个frame。每个frame从上
到下分成3个部分，分别是缓冲区，状态栏和回显区。

缓冲区是编辑的主区域，但是在这里操作的还不是真正的文件，而是文件的一个缓存
(buffer)。只有执行写入操作时，才会将buffer的内容写入到文件。缓冲区可以分成
多个区域，缓冲不同的内容。这些区域在Emcas中称为“窗口”。

缓冲区之下是状态栏，显示当前的一些状态信息，比如图中从左至右依次为：
U：当前文件的编码是UTF-8,如果是GBK会显示为c
**：文件状态，**表示未保存，--表示可写，%%表示只读
Emacs1：是当前编辑的文件的名称
All：表示当前缓冲区已经显示文件的所有内容，否则会显示比如Bot，表示处于文件的
末尾处。
L23：当前光标所在的行数
fundamental：当前的模式
等等，不同发行版的Emacs显示的状态栏的内容可能会有所不同。

最下面是回显区，提示当前正在进行的操作。比如“文件已保存”之类的信息。如果一个
命令没有输入完没，这里还会显示输入的指令，提示用户。

***** 4.基本概念
对Emacs所有的操作都是通过调用命令实现的。对于一些常用的命令，会定义快捷键以便
快速使用。
不管是否有快捷键，都可以通过M-x command的方式执行命令。（M-x即Alt+x，是一种
快捷键，后面会有介绍）比如输入回车，相当于：
M-x newline
通过M-x执行命令，可以使用TAB补全，使用M-p上翻，M-n下翻。
Emacs中的取消通常是连按三下ESC：
ESC ESC ESC（M-x keyboard-escape-quit）
但是在命令执行过程中，有可能该命令无法使用（比如有些命令是交互式的，需要输入
一些参数），所以终止一条命令最好使用C-g(M-x keyboard-quit)。

***** 5,基本概念--快捷键
本质上，快捷键只是一种发送命令的方法！
Emacs的快捷键通常以组合键的方式定义。如M-x表示Alt+x。前面的字母M代表修饰符，
Emacs定义的修饰符如下：
+ C-：Control
+ M-：Alt（应该是Meta，在PC上，Meta通常对应Alt键）
+ C-M-：同时按住Ctrl和Alt
+ S-：Shift
+ RET：Return
+ ESC：Esc，等价于M-。比如，C-M-r，等价于ESC C-r
+ SPC：空格键
+ DEL：退格键
+ Delete：删除键


上面提到了ESC C-r。这是一种组合方式，表示先按住ESC，再按住C-r。在Emacs中的很
多快捷键定义成组合的方式。如C-x C-c（M-x save-buffers-kill-emacs）。
此外还有些命令可以传递参数，在Emacs的表示法中用（#）代表。如：
C-u（#）C-f代表重复#次C-f

***** 基本概念--模式
Emacs是一种“有模式”的编辑器。如果用过Vim就很容易理解。不过Emacs中的模式分成
主要模式（major mode）和次要模式（minor mode）两种。
主要模式由文件类型决定，每个buffer打开文件是会根据文件类型决定其主要模式。
常见的主要模式有：
- fundermental-mode: 缺省的Emacs模式，拥有最少设置和绑定
- text-mode：编辑文本的基本模式
- c-mode：用于编辑C程序源代码
- lisp-interaction-mode:用于编辑和编译Lisp代码
- ptex-mode:用于编辑TeX文档

次要模式可以组合到主要模式中，常见的次要模式比如：
- abbrev-mode：用于生成和使用缩写
- auto-fill-mode：用于自动文字回绕、填充较长的行和段落
- line-number-mode：显示当前行号
- overwrite-mode：覆盖模式，代替默认的插入模式


可以通过命令来制定模式：M-x mode_name

对于一个buffer来说，当前的主要模式只能有一种，当指定当前主要模式时，原来的主要
模式会被替换；而当前的次要模式可以有多种。

如果是输入的模式包含在当前模式中，对于主要模式，会晴空所有的次要模式；对于次要
模式，会关闭这个次要模式。

模式的变化在状态栏中可以看到。

**** Emacs学习笔记（4）：基本的编辑功能
掌握了[[http://www.cnblogs.com/holbrook/archive/2012/02/16/2357334.html][Emacs的帮助系统]]，就可以自己随时学习了。但是还是应该有个主
线。尽管[[http://www.cnblogs.com/holbrook/archive/2012/02/15/2357335.html][Emacs能做的事很多]]，但首先Emacs是个编辑器。所以还是应该从
文本编辑器的功能开始。完成本节的内容后，可以应付日常的大部分编辑工作。

内容提要
    * 文件操作
    * 光标定位
    * 输入删除
    * 撤销重做

***** 文件操作
文件操作的快捷键都集中在C-x“菜单”中：
| 快捷键（C-x） | 命令（M-x）                      | 说明                   |
|---------------+----------------------------------+------------------------|
| C-x C-f       | find-file                        | 打开文件或目录         |
| C-x C-c       | save-buffers-kill-emacs          | 保存推出               |
| C-x C-z       | iconify-or-deiconify-fram        | 挂起（最小化）         |
| C-x C-r       | find-file-read-only              | 以只读模式打开         |
| C-x i         | insert-file                      | 插入文件               |
| C-x C-s       | save-buffer                      | 保存                   |
| C-x s         | save-some-buffer                 | 保存所有未保存的缓冲区 |
| C-x C-w       | write-file                       | 另存为文件             |
| C-x RET r     | revert-buffer-with-coding-system | 以制定编码读取文件     |
| C-x RET f     | set-bugger-with-coding-system    | 以制定编码保存文件     |
| C-x d         | dired                            | 进入目录列表模式       |
| C-x C-d       | list-directory                   | 获取文件列表           |

***** 光标定位
|      | 向前 | 向后 | 向下 | 向上 |
| 翻页 |      |      | C-v  | M-v  |
| 字符 | C-f  | C-b  | C-n  | C-p  |
| 单词 | M-f  | M-b  |      |      |
| 句   | M-a  | M-e  |      |      |
| 行   | C-a  | C-e  |      |      |
| 段落 | M-{  | M-}  |      |      |
| 缓冲区 | M-<  | M->  |      |      |

其它：
M-g M-g (goto-line)  跳转到某行
M-x     (goto-char)  跳转到字符位置
C-M-l   (reposition-window)  将当前行卷至页面中部
C-l     (recenter)   刷新页面，将当前行卷至页面中部
M-r M-x (move-to-window-line)  移动光标之页面的中间行

***** 输入删除
输入很简单，在缓冲区直接敲击键盘就OK了（这个不想Vim）
删除：
|              | 向前                        | 向后  |
| 字符         | C-d                         | DEL   |
| 单词         | M-d                         | M-DEL |
| 行           | C-k(删除至行尾)             |       |
| 整行         | C-M-Backspace               |       |
| 按表达式删除 | C-M-k                       |       |
| 区块         | C-w                         |       |
| 删除连续空格 | M-x delete-horizontal-space |       |

注1:在PC中，用Backspace代替DEL
注2:单词、行、区块的删除是kill，相当于剪切，会被放入kill-ring，字符及
空格的删除是delete

***** 复制粘贴
复制之前要先选择：C-@开始区块操作，然后移动光标，选中的区域会高亮
剪切：前面“删除”的部分包括了一些剪切操作，对区块的剪切用C-w
复制：区块用M-w，至于复制1行，复制一个单词之类的功能，自己想办法吧：（
粘贴：C-y：粘贴kill-ring堆栈中的最后一次的内容
C-y之后可以继续M-y,对kill-ring中的内容依次召回

***** 撤销重做
撤销：C-/（每插入20个字符，视为一个undo单位）
重做：C-/后，依次输入C-g C-/就可以redo了。
**** Emacs学习笔记（5）:更有效率地编辑
前面学习了[[http://www.cnblogs.com/holbrook/archive/2012/02/18/2357332.html][Emacs的基本编辑功能]]。为了让编辑更有效率，还需要了解：
    * 窗口管理
    * 缓冲区管理
    * 搜索和替换
    * 批量处理

***** 窗口管理
C-x 2       split-window-vertically       水平分割
C-x 3       split-window-horizontally     竖直分割
C-x 1       delete-other-window           只保留当前窗格
C-x 0       delete-window                 关闭当前窗格
C-x o       other-window                  切换窗格
C-M-v       scroll-other-windwo           滚动下一个窗格

***** 缓冲区管理
在Emacs中，打开新的buffer，不会关闭原有的buffer，而是需要手工操作
C-x C-b   list-buffers      查看缓冲区列表
C-x b     switch-to-buffer  切换缓冲区
C-x k     kill-buffer       关闭缓冲

***** 搜索替换
Emacs中的搜索包括增量搜索和一般搜索。增量搜索实在前一次搜索的结果的基
础上继续搜索。在增量搜索时，如果上一次搜索之后进行了其他操作，则需要连
续两次快捷键才能召回关键词。

增量搜索
C-s M-x       isearch-forward      向前增量搜索
C-r M-x       isearch-backward     向后增量搜索
C-M-s M-x     isearch-forward-regexp  正则表达式向前增量搜索
C-M-r M-x     isearch-backward-regexp 正则表达式向后增量搜索

一般搜索
M-x           search-forward     向前搜索
M-x           search-backward    向后搜索
M-x           search-forward-regexp  正则表达式向前搜索
M-x           search-backwarg-regexp 正则表达式向后搜索

询问替换
M-% M-x       query-replace      询问替换
C-M-% M-x     query-replace-regexp 正则表达式询问替换

取消搜索
C-g  取消搜索，光标返回搜索前的位置
RET  结束搜索，光标停留在当前位置

批量处理
批量处理的命令应该有很多，这里列出2个：
选中区域，M-x untabify: 将TAB字符转换为空格
选中区域，M-x indent-region:对齐文本块

**** Emacs学习笔记（6）:常用命令备忘（打印版）
可能是因为年纪大了，记性大不如前，新学的很多Emacs快捷键/命令都记不住。
所以要整理一个常用的命令清单(与当初学习Vim一样)，并且打印出来贴在电脑
边上。
刚开始不可贪多，所以只整理了：
Key Mapping, Important, Help, File, Cursor, Cut/Del/Copy/Paste,
Buffer, Window, Undo/Redo,Search/Replace几个部分，控制在2页A4纸之内。

**** Emacs学习笔记（7）：简单的配置
继续Emacs学习计划。这是“初学者”阶段的最后一篇。完成本节的内容，就可
以想“中级计划”进军了：）
经过一段时间的使用，已经大体适应了Emacs的快捷键，不过还是要参考命令备
忘表。
Emacser通常要对Emacs进行定制，使用起来才爽。据说Vimer嘲笑Emacser的一个
理由就是：
        Emacser如果丢了配置文件就什么都干不了。
好吧好吧，这些争论和我没什么关系。我只是恰好原来用Vim现在喜欢上了Emacs。
还是回到Emacs的简单定制吧。
***** 1. 配置文件
Emacs的配置文件在~/。emacs。现在就用Emacs打开这个文件吧，如果没有就创
建一个首先改一下颜色配置，让Emacs看起来更酷一些：
           (set-background-color "black");;使用黑色背景
           (set-foreground-color "white");;使用白色前景
           (set-face-foreground 'region "green");;区域前景色设为绿色
           (set-face-background 'region "blue");;区域背景色设为蓝色
尽管可以重启Emacs使配置生效，但更快捷的方式是在打开~/.emacs的时候执行
命令M-x eval-buffer,就可以是配置文件生效
***** 2. 安装插件
Emacs和Vim都有大量的插件，一些经久不衰、广泛使用的插件组合起来，就体现
出一种“集体智慧”。
Emacs的插件一般都是一个以el为后缀名的文件。首先要制定一个插件目录，比
如~/.emacs.d/lisps。然后在~/.emacs中制定插件目录和要使用的插件。
        (add-to-list 'load-path "~/.emacs.d/lisp/")
        (require 'pluginname')
还是玩一下颜色设置。前面的方法只是进行了一些简单的颜色设置，但是有热心
人写了插件，配置好了很多方案，不仅仅是前景背景色，还包括高亮语法。从这
里下载，解压后，将color-theme.el文件从themes文件夹复制到插件目录，然后
修改配置文件：
    (add-to-list 'load-path "~/.emacs.d/lisp/")
    (require 'color-theme)
    (color-theme-initilize)
M-x eval-buffer使配置生效后，可以执行插件提供的命令：M-x
color-theme-select RET进入颜色选择界面。我选择的是Classic。
选好之后，你可能希望配色方案设成默认，还是修改配置文件。在配色方案选择
界面中选择主题后按d，会出现该配置的提示信息，比如：
将类似(color-theme-classic)的内容添加到.emacs中就可以每次启动Emacs时自
动选择配色方案了。

***** 进阶
不要迷信自己，不要一开始就自己尝试定制Emacs。一定要参考甚至是抄袭大牛
们的设置。比如[[https://github.com/purcell/emacs.d][Steve Purcell。学习他们的配置，不仅能让你直接学会“最佳
实践”，更加能深入你对Emacs的理解。]]
**** Emacs学习笔记（8）:使用emacs浏览网页
从这一篇开始，可以说已经脱离了Emacs的初级阶段，开始探索“无处不emacs”
之旅。首先，当然是如何使用emacs浏览网页
*Table Of Contents*
    * 1.为什么要在emacs中浏览网页
    * 2.什么是w3m
    * 3.如何在emacs中浏览网页
    * 4.配置
    * 5.使用
***** 为什么要在emacs中浏览网页
可以找出好多理由：比如速度快，支持emacs的快捷键，编辑文档时不需要从浏
览器拷贝再复制粘贴到emacs，以及咳咳~，隐蔽性强。而关键的理由一条就够了：
我喜欢！
***** 什么是w3m
[[http://www.w3m.org/][w3m]] 与Links,Lynx一样，都是基于文本的浏览器。w3m支持表格、框架
SSL连接、颜色。如果在支持图形界面的终端下，还可以显示图片。w3m支持很多
快捷键，可以参考[[http://wiki.ubuntu.org.cn/W3m%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%88%97%E8%A1%A8][这里]]。
***** 如何在emacs中浏览网页
使用w3m [[http://www.cnblogs.com/holbrook/archive/2012/02/15/2357335.html][emacs可以作为其他程序的界面]]， 当然也就可以作为w3m的界面，从而
实现在emacs中浏览网页。而这些就是通过[[http://emacs-w3m.namazu.org/][Emacs-w3m]] 这个Emacs的扩展来
实现的。Emacs-w3m是Emacs调用w3m的接口，所以首先还要装w3m。另外，为了能
够显示图片，还需要安装w3m-img。此时，就可以使用emacs浏览网页了。首先，
加载Emacs-w3m模块：
    M-x load-library RET w3m
之后用
    M-x w3m
打开一个w3m的buffer，输入url就可以浏览网页了
***** 配置
虽然这样已经可以使用了，但还是很麻烦，不符合Emacer的风格。所以还需要配
置一下。可以参考的配置：
***** 使用
此时可以使用M-x w3m-goto-url RET www.baidu.com打开网页了。
可以通过“T”切换整个页面是否显示图片，通过“t”切换光标所在位置图片的
显示。
Emacs-w3m还支持导航，标签，书签，工具栏，cookie等功能，可以自己慢慢挖
掘。
**** Emacs学习笔记（11）:用Org-mode实现GTD

*用Org-mode实现GDT*

有了Org-mode强大的人物管理功能，再配合其它一些Emacs插件，可以很容易地
实现个人时间管理（GTD）。如果不了解GTD，[[][这里]] 可以让你在两分钟之
内对GTD有一个初步的认识。

***** 1 收集
如GTD精要中所述，GTD包括收集、整理、组织、回顾、执行等环节。各个环节都
需要工具的支持：

****** 1.1 收集

任何需要关注的事情，如mail，电话，IM，口头交流，网页，文档，想法等，都
有可能产生新的任务。收集环节要把这些需要关注的时间案都记录下来。
*所以苏药一个收集箱（Inbox）,能够随时快速启用，记录需要的信息。*

****** 1.2 整理

在合适的时间梳理收件箱中的信息，抛弃掉没用的垃圾和暂时不用考虑的参考信
息，剩下的就是需要关注的任务。整理阶段的三种处理凡是是：
    * 既不需要处理又无保留价值的信息，直接舍弃
    * 不需要处理但有保留价值的信息，归档留存
      比如，一篇有用的资料，以后可能会用到，需要归档以备查阅；一个很好
      的想法但由于时间、前提条件、考虑程度等因素不能马上投入行动，需要
      记录下来等等。
    * 需要处理的信息，创建一个任务

*根据以上三种情况，整理阶段需要实现：*
    * *提出无用的信息*
    * *将信息归档*
    * *创建任务*

****** 1.3 组织

创建任务时，需要有一个快速的判断，包括what（做什么），who（谁来做），
when（什么时候做），where（什么地点处理），why（为什么要做，可以用原始
消息作为原因），how（如何做），how much（需要多长时间）。这个判断要非
常迅速，并根据判断的结果对任务进行组织，以便后来的处理和查询，通常可以
按照这样的步骤分析：
    1. 该任务是否属于一个项目？如果是，首先打上项目标记
    2. 该任务能够在2分钟完成？如果是，马上处理，然后将任务标记为“已完
       成”
    3. 根据重要性和紧迫性，为该任务划分优先级
    4. 该任务是否需要别人处理？如果是，通知对方，然后将任务标记为“等
       待中”
    5. 需要自己处理的任务，马上判断处理的地点/场合，并标记
    6. 对于能够确定时间的任务（日程安排）,标记计划处理时间，如果有截止
       日期，也标记上

*分居上述步骤，组织阶段需要的功能包括：*
    * *将任务归入不同的工作清单*
    * *为任务增加标记*
    * *定义任务的完成状态*
    * *为任务定义优先级*
    * *为任务设定时间点*

****** 1.4 回顾

在合适的时间检查所有的任务，根据实际情况进行处理。建议的做法包括：
    * 每日回顾 每天造成首先查看当日的日程表，然后检查待办任务清单，根
      据实际情况和当日的时间安排，以及当日的行程（地点），决定一天的工
      作计划。
    * 周期性回顾 可以是每周，每月或者更长的时间周期。回顾一段时间内所
      完成的事情，做出总结；同时根据项目的实际变化，调整下一阶段的计划。
    * 项目回顾 项目是一系列任务的组合，并且任务之间存在依赖关系。根据
      项目的时间点，在适当的时机回顾整个项目的相关任务，进行总结或计划。

可以遵循“六个高度检视法”：
    * 5万英尺+：人生目的和价值观（面临重大变化和转折时）
    * 4万英尺：3~5年的展望（建议每年检视）
    * 3万英尺：1~2年的目标（建议每年检视）
    * 1万英尺：当前的项目（建议每周检视）
    * 跑道：下一步行动（建议每日检视）

前3个较低层次的内容大多是针对事物当前状态（行动、项目、职责），再向上
的层次则主要设计指导方向、目标取向等方面，需要在恰当的时机去关注的方面，
长远规划，掌控愿景，保持全方位的平衡。

*回顾阶段需要：*
    * *按时间段检索任务*
    * *按项目检索任务*
    *  *处理任务间的依赖关系*

****** 1.5 执行
根据 *情境是否适合* 、 *时间是否够用* 、 *精力是否充沛* 、 *任务是否重
要* 四个原则来决定进行哪项任务。因为经过前面的步骤已经周密严谨地考量过
各项任务，所以此时只需要用直觉判断即可。可以参考“四象法则”：
    1. 给出任务的定性：重要/不重要，紧急/不紧急
    2. 按照“先轻重，再缓急”的原则，将任务按照“重要且紧急-重要不紧
       急-不重要但紧急-不重要不紧急”的顺序排序
    3. 对于划分大同意类型的任务，认为区分“高、中、低”的优先级
    4. 处理原则：
       + 重要且紧急：尽早动手，缓解压力
       + 重要不紧急：尽早计划，逐步完成
       + 不重要但紧急：寻求帮助，设定戒指时间
       + 不重要不紧急：冷却处理

每完成一项任务，就将该任务标记为“以完成”，并归档。
*为了帮助判断，需要支持任务的哦筛选、搜索和排序*

***** 2 用org-mode实现GTD

前面已经列出了GTD工具应该具备的功能，用Org-mode可以很好的实现这些功能，
从而将Org-mode当作GTD工具。

****** 2.1 文件的划分

Org-mode管理的基本单位是文件，尽管可以将所有的任务放到同一个文件中，但
是这样不利于管理，所以首先要规划文件的划分。

我根据自己的需要，设定了6个文件：
    * inbox收件箱，用于收集未整理的信息
    * task 待办事项，记录所有未完成的事项。但不包括项目内容。
      + Tasks 任务
        - 没有时间点的事项为“待办事项”
        - 有时间点的待办事项为“日程安排”
        - 有时间间隔的待办事项为“周期性任务”
      + Ideas 想法
    * finished 完成的任务会迁移到这里
      + Tasks 完成的任务
      + Journal 日志，按事件范围组织结构，可以将完成的任务转移到这里
    * note 笔记，临时存储一些以后可能会用到的资料。note会逐步转移到真
      正的笔记本中
    * trash 回收站，取消的任务，不需要的信息和资料会迁移到这里，等待删
      除，按类型区分
      + Tasks
      + Ideas
      + Notes
    * project 项目，专门收集非单独的，项目相关的事项。完成的项目实现不
      会迁移到finished中，项目日志和总结等都在这个文件中完成
      + 每个项目一条，以项目名称/简称作为标签
      + 统一的标签：Proj

****** 2.2 任务状态

| 状态（快捷键） | 完成状态 | 说明                                             | 回顾周期 |
|----------------+----------+--------------------------------------------------+----------|
|                |          | 无状态标示尚未开始整理，一般位于Inbox            |          |
| TODO(t)        |          | 最基本的任务状态，现在要做，但还没有计划做的时间 |          |
| NEXT(n)        |          | 下一步行动，还未开始计划                         |          |
| SOMEDAY(s)     |          | 想法，还没决定是否开始行动                       |          |
| Done(d)        | 是       | 已经完成，需要记录完成时间和备注说明，转移到finished.org |          |
| Abort(a)       | 是       | 取消任务，需要说明取消原因，转移到trash.org的相应节点中  |          |
| WAITING(w)     |          | 等待其他人完成                                                  |          |

任务状态在多个文件中都会使用，所以要在.emacs中定义（而不是单个.org文件
中）
    (setq org-todo-keywords
          '((sequence "TODO(t!)" "NEXT(n)" "WAITING(w)" "SOMEDAY(s)" |
           "DONE(d@/!)" "ABORT(a@/!)")))

****** 2.3 标签设计

标签包括机组：
1. 情境标签，表明该任务应该在何种情况下完成
   + @Office 办公室
   + @Home 在家
   + @Computer 有计算机的时候
   + @Call 打电话
   + @Way 在路上或外出
   + @Launchtime 午休时间
2. 分类标签
   + 所有的项目具有标签“project”
   + 其他的分类自行定义

****** 2.4 TODO属性设计

****** 2.5 初始化文件

为了是上面的设计能够生效，对于有些文件需要进行初始化，增加配置信息。还
可以包含一些例子。
    * task.org

****** 2.6 定义转接（Refiling）

使用文件管理GTD，一定会需要将标题从一个节点移动到另一个节点。
org-mode提供的C-c C-w可以方便地在同一文件内移动节点。
对于不同文件之间的移动，也可以通过配置来实现快速移动，下面是一个例子：
    '(org-refile-targets (quote (("newgtd.org" :maxlevel . 1)
                                ("someday.org" :level . 2))))
通过这样的设定，可以表示出someday.org文件中第二阶层的标题和newgtd.org
文件中的第一阶层的标题。

***** 3 使用场景

****** 3.1 快速收集信息

GTD工具通常会定义一个Inbox，用于快速记录想法、任务。万能的Inbox工具是
纸和笔，之前我也尝试过gmail、EverNote和doit.im，但都感觉不够快捷。而
Emacs下的org-mode + remember-mode能够满足我的要求。
最新版的Org（>6.36）集成了remember.el，可以快速捕获信息，通过预定义的
模板进行分类，并且能够保存相关的附件。
尽量使用Emacs完成更多的功能有利于收集（如www，mail，read）

******* 3.1.1 快速启动

在Emacs中使用命令M-x org-remember,会打开一个新的buffer,输入一些内容之
后输入命令C-c C-c，就会将内容保存到文件中（默认是~/.notes）。如果查
看~/.notes文件，会看到类似下面的内容：

    ** Mon Apr 16 10:32:38 2012 (使用org-remember创建)
org-remember会自动创建一些条目，包括时间，输入的注释内容以及当时Emacs
打开的文件名。

尽管这样已经比手工打开一个文件并输入一些内容要迅速许多，但是我们还可以
做到更快：
    * 可以定义org-remember命令的快捷键，比如C-c c(这个快捷键应该是Org
      菜单中最快捷的)：
      #+BEGIN_EXAMPLE
        (define-key global-map "\C-cc" 'org-remember)
      #+END_EXAMPLE

    * 如果不习惯一直开着Emacs并且觉得Emacs开得太慢，还可以使用Emacs的
      Server/Client模式。
          $ emacsclient e "(remember-other-frame)"

******* 3.1.2 模板定义

org-remember支持模板，可以通过快捷键选择事件的类型，生成特定格式的记录，
并插入到指定容器的制定位置。其格式是：（名称，快捷键，内容模板，文件，
父节点）

我的事件定义如下：
|----------------+-------------+------------------------------------------------|
| 事件（快捷键） | 容器        | 模板                                           |
|----------------+-------------+------------------------------------------------|
| New(n)         | inbox.org   | 收件箱，收集未整理的信息                       |
| Task(t)        | task.org    | 待办事项，所有未完成的事件                     |
| Calendar(c)    | task.org    | 日程安排，具有明确的待办实现，可以是周期性任务 |
| Idea(i)        | task.org    | 想法，愿望                                     |
| Note(r)        | note.org    | 笔记，最终会被移到真正的笔记本中               |
| Project(p)     | project.org | 项目任务                                           |
|----------------+-------------+----------------------------------------------------|

对应的模板配置：

使用模板参数能够带来很多便捷。比如上面的Project模板，在收集的时候能根
据选择的项目名称，自动将任务插入到对应的项目的条目下面。

常用的模板元素：
| 元素              | 说明                   |
|-------------------+------------------------|
| %?                | 输入文字               |
| \textbackslash{}n | 插入换行符             |
| %i                | 插入选择区域           |
| %a                | 当前光标所在标题的链接 |
| %t                | 插入日期               |
| %T                | 插入日期和时间         |
| %^g               | 从目标容器的标签中选择 |
| %^G               | 从全局标签中选择       |
| %^t               | 输入日期时间           |
|-------------------+------------------------|

模板的详细说明可以参考这里。

****** 3.2 TODO 查看日程表

在Emacs配置文件.emacs定义日程表快捷键：
#+BEGIN_EXAMPLE
  (define-key global-map "\C-ca" 'org-agenda)
#+END_EXAMPLE

C-c [ 将当前文件加入到日程表，

**** Emacs学习笔记（13）:在Emacs中打开pdf
Table of Content
    * 1 简介
    * 2 安装
    * 3 使用
    * 4 书签
    * 5 小结

***** 简介
DocviewMode为Emacs提供了DVI、PDF等文件的支持。DocViewMode将dvi、pdf等
文件转换成png图片，并在emacs中打开。如下图：
***** 安装
从Emacs v23开始，默认包括了DocViewMode。但需要系统中安装基础的软件包：
首先，ghostscript是必需的
然后需要安装xpdf
***** 使用
在DocViewMode中可以使用部分Emacs快捷键，同时DocView也定义了自己的一些
快捷键：
| 快捷键 | 功能 |
|--------+------|
| p/n    | 上下翻页 |
| +/-    | 缩放     |
| C-s    | 搜索     |
| q      | 推出       |
p** 书签
DocView不直接支持书签，这很不方便，尤其是在阅读大型文档的时候。不过
Emacs有另外一个插件BookMarks,可以与DocViewMode结合使用。
BookMarks是Emacs自带的产检，支持一下操作：
| 快捷键              | 操作         |
|---------------------+--------------|
| C-x r m             | 设置书签     |
| C-x r b             | 跳转到书签   |
| C-x r l             | 列出所有书签 |
| M-x bookmark-delete | 删除书签     |

    * 没个文件只能设置一个书签，如果要在一个文件中使用多个书签，参考Bookmark+
    * 默认将所有书签保存在~/.emacs.bmk
    * 更多的功能可以使用M-x bookmark TAB查看
***** 小结
现在，你可以将系统中PDF的默认打开程序设置成Emacs了。
**** Emacs学习笔记（14）：在Emacs中使用git

Table of Contents
    * 1 工具的选择
    * 2 安装和配置
    * 3 基本操作
    * 4 提交
    * 5 版本历史
    * 5 标签（tag）和分支（branch）

***** 1 工具的选择
在Emacs中使用git有很多选择，比如古老的Emacs VC，经典的git.el，强大的
git-emacs,以及新潮的magit / egg（egg是magit的一个分支）。
Emacs VC在Emacs中内置支持，配合后端，对各种版本的控制工具如CVS、SVN、
GIT、Hg等都能够支持，但是功能比较单一，操作方式简单而且古怪。
git.el是git项目的官方工具，但是已经很久没有更新了，据说对git的有些特性
没有提供支持。
而magit和egg个人感觉还有待时间的检验。
所以这里选择的是git-emacs。

***** 2 安装和配置
git clone https://github.com/tsgates/git-emacs.git 之后，只需要在Emacs
配置文件中增加：
    ;; git-emacs
    (add-to-list 'load-path "/path/to/git-emacs/")
    (require 'git-emacs)
然后可以通过M-x git-config-init进行配置

***** 基本操作
如果当前打开的文件所在的文件夹处于版本控制中，可以通过M-x git-status查
看状态，如下图：
在这个界面下可以使用一些命令：
| key     | Comment                                  |
|---------+------------------------------------------|
| p/n     | 在所有文件之间上下移动                   |
| P/N     | 在变更过的文件之间上下移动               |
| </>     | 定位到列表的头部/尾部                    |
| v       | 以只读方式打开文件                       |
| m/u/SPC | 设置/取消/切换标记，标记用于批量处理文件 |
| a       | 将文件加入版本控制                       |
| i       | 将文件加入到ignore                       |
| c       | 提交                                     |
|---------+------------------------------------------|

其它命令可以参考此时出现的Git-Emacs菜单。

***** 4 提交

在状态清单中使用“c”,或者在任何buffer中运行M-x
git-commit/git-commit-all/git-commit-file，可以提交index/所有文件/当前
文件。
pp提交时会要求填写注释，如下图：
填写注释后：
| C-c C-c | 提交 |
| C-c C-q | 取消   |

***** 5 版本历史

通过命令M-x git-history可以查看整个工程的版本历史，M-x git-log可以查看
当前标记文件的版本历史，两个命令都会打开一个新的buffer：
如果你很喜欢gitk,也可以通过M-x gitk（前提是已经安装了gitk）直接打开
gitk窗口：

***** 6 标签（tag）和分支（branch）

M-x git-branch:列出所有分支，在这里可以通过快捷键c/d/RET实现创建/删除/
切换分支。
tag的操作也很简单：
M-x git-tag可以创建一个标签，以后在git-checkout时可以制定标签的名字，
也可以通过git-checkout-to-new-branch来基于tag创建分支。

***** 7 小结

git-emacs在Emacs中实现了git命令行的所有功能，并且基于Emacs的强大功能而
使用起来更加方便。使用git-emacs，不需要在Emacs和Terminal之间来回切换，
提高了效率。

*** Emacs Mini
**** Emacs Mini Manual(PART1)-THE BASIC

_Before we start_
    * Please remember thrat you can always access a section using floating table
      of content at the upper-right corner of your screen.
    * Many people asked how can this manual be "mini",since it is pretty big for
      an online single page article.Yes,if this page is expoted to PDF,it is
      more than 40 pages.However,this manual is "mini" relative to the size of
      the official Emacs manual,which is more than 600 pages.That's why.
    * If you find the page is loading slow for you,you can always clone the git
      repo of this mini manual and read it
      offline:https://github.com/tuhdo/tuhdo.github.io

***** Why Emacs?

In Emacs,you can do many things aside from editing.Emacs is a programming
platform,not just another editor in the sense that people think.For more
details,read the Appendix.

Have a tour from the official Emacs homepage.

Here is my personal tour,with 3rd party plugins added.Don't worry if your Emacs
does not look like the screenshots.You can have something like mine and even
better,but now you need to get a solid foundation.The screenshots are just for
show.Even though,after going through this guide,you will be able to browse Linux
kernel source tree with ease.

    * Performance:Editing a 39MB C source file with no program.But well,if your
      project use really large source file like that ,if your favorite editors
      crash,it's not their fault.

    * Programming:
      + Jump to any header file:

      + Autocompletion: Pay attention to completion candidates when include
        <linux/printk.h> added and not added

      + Showing function arguments:

      + Quickly comment multiple lines:

      + GDB

    * Diff between current editing file and latest file revision:

    * Magit: From unstage -> stage -> commit -> push

    * Quickly select any file in a directory ynder a Version Control System,for
      example, Linux kernel.Note that in the demos you may see  me type in the
      commands.You can think of it like the start menu in the Windows,but
      actually those commands can be executed quickly with a shortcut.

    * Quickly select any file/directory in previous session:

    * Emacs is a PDF reader: I can serch text in the PDF file with highlighting
      and a table of conten side by side. All can be controlled with keyboard.

Filly, Emacs is featured in Tron Legacy.

***** Why this guide?

Let's look at part of the Emacs manual:

All about handling files are inside the Filse entry,which include how to open
files, save files, revert and auto-revert files, comparing file..., many things
from the basic to advance. If you are a new and reading the Emacs manual, you
have the burden to actively select what you need from the manual to learn to
achieve the basic common tasks in othe editors.

If you read the manual cover to cover, it would take a long time before you can
start using Emacs for basic operations (i.e. open files). "Fundamental Editing
Commands" is placed before "Major Structures of Emacs" section that contains
information about file handling. How can you learn to basic editing commands fi
you don't even know how to open a file? The problen with the manual is, it does
not really organize for new Emacs user to progressively learn Emacs.

I want to help you to use the Emacs efficient in a relative short amount fo
time, probably around a week. This guide is written to lift the burden of
filtering what you need while know nothing, when you are a complete
beginner. The Emacs manual is excellent, but it would be much easier with a
solid ground understanding and after using Emacs for a while.

After you finish this guide, it provides a good starting point to stat using the
official Emacs manual. GNU Emacs tour would be a nice tutorial, only if it isn't
made for demonstration.

***** A bit of history

The current version is Emacs 24.3; the upcoming Emacs 24.4 when this manual was
written.

Quote from GNU Emacs homepage:

   For those curious about Emacs history: Emacs was originally implemented in
   1976 on the MIT AI Lab's Incompatible Timesharing System(ITS), as a
   collection fo TECO macros. The name "Emacs" was orginally chosen as an
   abbreviation of "Editor MACroS". This version of Emacs, Richard Stallman, GNU
   Emacs, was orginally written in 1984. For more information, see the 1981
   paper by Richard Stallman, describing the design of eht orginal Emacs and the
   lessons to be learned from it, and a transcript of his 2002 speech at the
   International Lisp Conference, My Lisp Manual for ITS; the cober of the
   original Emacs Manual for Twenex; and (the only cartoon RMS has ever drawn)
   the Self-Documenting Extensible Editor.

***** "I don't want a complicated editor, I want something simple like Notepad++"

Well, that's your choice. But I suggest that writing code without any support ia
harmful.

If you are a programmer, you should automate things as much as possible, when
eht automation cost does not outweight the cost of doing manually. One really
easy way to do this is using a good editor that automates many menial and
tedious tasks. For examples, one of the thing that annoys me is using the
command *cd* to change into a deep directory path like this:

 /path/to/a/very/long/long/long/long/long/.../directory/

In Emacs, if you have a directory under a version control system, you can
immediately jump to any file quickly, even if it is buried 20 levels deep (as
demonstrated at the beginning).

Or when you want to quickly comment many lines of code but the programming
language you are using only has a single line comment. In many editors, you have
to comment line by line tediously. In Emacs, you can simply highlight the lines
and press a shortcut for inserting comments.

Many people think that writing program manually is much cooler than "amateurs"
that use fancy "Integrated Development Environment". I used to think like that
too, because working in Linux enironment requres me to understand the underlying
working, such as building software using Makefile in C/C++, automating with
shell script... And this is already considered "user friendly" wrong. While
working with such tools allow me to understanding what's going on, I do not need
to type in code manually to understand it. If you get what a for loop does,
typing it character by character is tedious and interrupt your thinking.

Write code manually won't make you smarter, because when you actually type, you
already have something in your head. Typing is just a mere reflection fo your
thoughts into the editor. You need to finish typing as fast as possible, because
the quicker you finish, the quicker you can get back your thinking. Only
thoughts matter, and there's no value in manually typing the same things
thousands of times. I must say, Cut, Copy and Paste are really great ideas and
great automation tools beacause ot their simplicity.

Your job may require you to use a esoteric in-house programming language and you
don't like it. Having an editor to help you finish the tasks as soon as possible
is a way to make yourself happier.

Typing too much can also lead to RSI. If you manually type code too much, it
harms your fingers. At least if you use a handsaw instead of a circular saw, you
do some physical exercises in the process.

In Sum:
   * Manually typing does not make you smarter. Not in any form.
   * Manually typing does not make you happier with programming.
   * Manually typing or do other things (navigate file system, remember changes
     you made to your files...) wastes your times, if automating is
     possible. Automate as much as you can.
   * Good editor help you automate boring tasks.
   * Typing too much potentially lead to RSI.

Your time and memory wasting for manually do tasks, you could have save it for
something that is more interesting.

***** Installation

****** Linux

Easy way to installif you are using ubuntu: sudo apt-get install emacs. If you
are using other Linux distriburions, use the package manager of your
distribution and install Emacs. However, the package manager only has the
lastest stable Emacs. If you want the lastest Emacs, build from source as the
following instrucitions:

To use Emacs with GUI:
   * Install GTK 3: sudo apt-get install libgtk-3-dev libgtk-3-common libgtk-3.0
   * Download Emacs; or if you prefer the lastest Emacs, get it from source: git
     clone https://repo.or.cz/remacs.git
   * If you download form the homepage, unpackage: tac xvf emacs-*.tar.gz
   * cd emacs-<version>*
   * ./autogen.sh
   * Add prefix and path to where you want to install. This is useful if you
     work on remote server without root access: ./configure
     --with-x-toolkit=gtk3 [--prefix=/path/to/dir]
     You should use GTKx 3, so you will be able to use the true type fonts such
     as Inconsolate for better Emacs experience.
   * make
   * make install

If ./configure tells you the dependencies missing, you should install
it. Recommended dependency: libtiff, libgiff, libpng, libxm12 for viewing and
browsing web in Emcas:

 sudo apt-get install libtiff5-dev libpng12-deb libjpeg-deb libgif-dev
 libgnutls-deb libxml2-dev

Using in Terminal only:
   * Download and unpackage as above.
   * ./configure --withour-x [--prefix=/path/to/dir]
   * make
   * sudo make install

IF you don't like to compile Emacs yourself, install from the package manager of
your Linux distribution.

After installation is done, add this line to your *.bashrc* or *.zshrc*:
     alias em='emacs'
So you can start Emacs as fast as Vim!

****** Windows
****** Mac OS X

***** Swap Control and Capslock

Swaping Control and Caplock, in general, is not required to make the best out of
Emacs, if you at least use regularly key PC keyboard or better. However, it is
not nice at all on a laptop keyboard. If you use a laptop keyboard for writing
code, I strongly recommended wo swap Control and Capslock for better Emacs
experience.

Swaping Control and Capslock will not benefit for using Emacs, it is beneficial
in general, as Control is a much more frequently uesd key than Capslock. Popular
shells like Bash or Zsh use Control a lot for quick cursor movement.

******* Windows

Follow this guide: Swapping Capslock and Control keys

******* Linux

put this in your shell init file(.bashrc, .zshrc)
   /usr/bin/setxkbmap -option "ctrl:swapcaps"
If you use Ubuntu, follow this guide: Swap caps lock and ctrl in ubuntu 13.10

******* Max OS X

Follow this answer on StackOverflow: Emacs on Max OS X Leopard key bindings

*If you don't like to swap Capslock and Control...*
You can use your palm to press Control in standard PC keyboard.

** Basic
*** emacs -nw

 emacs --help
 #+BEGIN_EXAMPLE
 --no-window-system, -nw     do not communicate with X, ignoring
                             $DISPLAY
 #+END_EXAMPLE

*** 安装

Reference:
+ http://blog.chinaunix.net/uid-27091459-id-3359118.html


安装Emacs时编译错误
#+BEGIN_EXAMPLE
  You seem to be running X, but no X development libraries
  were found. You should install the relevant development files for X
  and for the toolkit you want, such as Gtk+, Lesstif or Motif. Also make
  sure you have development files for image handling, i.e.
  tiff, gif, jpeg, png and xpm.
  If you are sure you want Emacs compiled without X window support, pass
  --without-x
  to configure.
#+END_EXAMPLE

解决方法：
+ 装GTK+等图形开发库: sudo apt-get install libgtk2.0-dev
+ 几个图像开发库:
  - sudo apt-get install libxpm-dev
  - sudo apt-get install libjpeg62-dev
  - sudo apt-get install libgif-dev
  - sudo apt-get install libtiff4-dev
+ last one: sudo apt-get install libncurses5-dev
*** 帮助系统
GNU的软件大多数有丰富的帮助系统，学习GNU的软件时，首先学习如何使用其帮
助系统，往往事半功倍。Emacs的帮助文档很多，并大部分都在C-h开头的组合键
中。
首先是C-h ?，关于帮助系统的“帮助”。该命令会打开一个新的frame，如下图：
从该文档中摘录常用的帮助功能如下：

|----------+--------------------------+-----------------------------------------------------|
| C-h ?    |                          | 关于帮助系统的帮助，可以通过SPC和DEL键滚动，ESC推出 |
| C-h t    | M-x help-with-tutorial   | 进入《Emacs快速指南》                               |
| C-h r    | M-x info-emacs-manual    | Emacs使用手册                                       |
| C-h i    | M-x info                 | 《Emacs说明》                                       |
| C-h a    | M-x apropos-command      | 搜索命令                                            |
| C-h v    | M-x describe-variable    | 查看变量说明                                        |
| C-h f    | M-x describe-function    | 查看函数说明                                        |
| C-h m    | M-x describe-mode        | 查看当前mode的相关文档，包含mode中的命令、快捷键等  |
| C-h k    | M-x describe-key KYES    | 查看快捷键对应的命令及简要说明                      |
| C-h c    | M-x describe-key-briefly | 查看绑定说明                                        |
| C-h w    | M-x where-is             | 查看某个命令对应的快捷键                            |
| C-h b    | M-x describe-bindings    | 查看当前buffer中的所有的快捷键列表                  |
| KEYS C-c |                          | 查看当前buffer中以某个快捷键序列开头的快捷键列表    |
|          | M-x appropos             | 查看匹配某个关键字的任何东西，如函数，变量，命令，模式等                        |
|----------+--------------------------+---------------------------------------------------------------------------------|


1. C-h t 《Emacs快速指南》是迅速上手最好的文档。
2. 使用帮助时，可能会分割出其它Frame，可以通过C-x 1关闭。

*** DONE Emacs 仅处理 elisp 脚本，不启动
- State "DONE"       from "TODO"       [2015-12-02 三 15:08] \\
  优先查阅手册和帮助文档，其后再Google

*emacs --script FILE*

#+BEGIN_EXAMPLE
   $ emacs --help
  Usage: emacs [OPTION-OR-FILENAME]...

  Run Emacs, the extensible, customizable, self-documenting real-time
  display editor.  The recommended way to start Emacs for normal editing
  is with no options at all.

  Run M-x info RET m emacs RET m emacs invocation RET inside Emacs to
  read the main documentation for these command-line arguments.

  Initialization options:

  --batch                     do not do interactive display; implies -q
  --chdir DIR                 change to directory DIR
  --daemon                    start a server in the background
  --debug-init                enable Emacs Lisp debugger for init file
  --display, -d DISPLAY       use X server DISPLAY
  --no-desktop                do not load a saved desktop
  --no-init-file, -q          load neither ~/.emacs nor default.el
  --no-shared-memory, -nl     do not use shared memory
  --no-site-file              do not load site-start.el
  --no-site-lisp, -nsl        do not add site-lisp directories to load-path
  --no-splash                 do not display a splash screen on startup
  --no-window-system, -nw     do not communicate with X, ignoring $DISPLAY
  --quick, -Q                 equivalent to:
                                -q --no-site-file --no-site-lisp --no-splash
  --script FILE               run FILE as an Emacs Lisp script
  --terminal, -t DEVICE       use DEVICE for terminal I/O
  --user, -u USER             load ~USER/.emacs instead of your own

  Action options:

  FILE                    visit FILE using find-file
  +LINE                   go to line LINE in next FILE
  +LINE:COLUMN            go to line LINE, column COLUMN, in next FILE
  --directory, -L DIR     prepend DIR to load-path (with :DIR, append DIR)
  --eval EXPR             evaluate Emacs Lisp expression EXPR
  --execute EXPR          evaluate Emacs Lisp expression EXPR
  --file FILE             visit FILE using find-file
  --find-file FILE        visit FILE using find-file
  --funcall, -f FUNC      call Emacs Lisp function FUNC with no arguments
  --insert FILE           insert contents of FILE into current buffer
  --kill                  exit without asking for confirmation
  --load, -l FILE         load Emacs Lisp FILE using the load function
  --visit FILE            visit FILE using find-file

  Display options:

  --background-color, -bg COLOR   window background color
  --basic-display, -D             disable many display features;
                                    used for debugging Emacs
  --border-color, -bd COLOR       main border color
  --border-width, -bw WIDTH       width of main border
  --color, --color=MODE           override color mode for character terminals;
                                    MODE defaults to `auto', and
                                    can also be `never', `always',
                                    or a mode name like `ansi8'
  --cursor-color, -cr COLOR       color of the Emacs cursor indicating point
  --font, -fn FONT                default font; must be fixed-width
  --foreground-color, -fg COLOR   window foreground color
  --fullheight, -fh               make the first frame high as the screen
  --fullscreen, -fs               make the first frame fullscreen
  --fullwidth, -fw                make the first frame wide as the screen
  --maximized, -mm                make the first frame maximized
  --geometry, -g GEOMETRY         window geometry
  --no-bitmap-icon, -nbi          do not use picture of gnu for Emacs icon
  --iconic                        start Emacs in iconified state
  --internal-border, -ib WIDTH    width between text and main border
  --line-spacing, -lsp PIXELS     additional space to put between lines
  --mouse-color, -ms COLOR        mouse cursor color in Emacs window
  --name NAME                     title for initial Emacs frame
  --no-blinking-cursor, -nbc      disable blinking cursor
  --reverse-video, -r, -rv        switch foreground and background
  --title, -T TITLE               title for initial Emacs frame
  --vertical-scroll-bars, -vb     enable vertical scroll bars
  --xrm XRESOURCES                set additional X resources
  --parent-id XID                 set parent window
  --help                          display this help and exit
  --version                       output version information and exit

  You can generally also specify long option names with a single -; for
  example, -batch as well as --batch.  You can use any unambiguous
  abbreviation for a --option.

  Various environment variables and window system resources also affect
  the operation of Emacs.  See the main documentation.

  Report bugs to bug-gnu-emacs@gnu.org.  First, please see the Bugs
  section of the Emacs manual or the file BUGS.

  Journal $ cd /tmp
  tmp $ vi test
  tmp $ emacs -script test
  hello world

#+END_EXAMPLE

** Buffer                                                           :buffer:
*** buffer func
#+BEGIN_SRC emacs-lisp
  (buffer-file-name)
#+END_SRC

*** 缓冲区导航
|---------+---------------------+-------------------------------------------|
| 按键    | 命令                | 作用                                      |
|---------+---------------------+-------------------------------------------|
| C-f     | forward-char        | 向前一个字符                              |
|---------+---------------------+-------------------------------------------|
| C-b     | backward-char       | 向后一个字符                              |
|---------+---------------------+-------------------------------------------|
| C-p     | previous-line       | 上移一行                                  |
|---------+---------------------+-------------------------------------------|
| C-n     | next-line           | 下移一行                                  |
|---------+---------------------+-------------------------------------------|
| M-f     | forward-word        | 向前一个单词                              |
|---------+---------------------+-------------------------------------------|
| M-b     | backward-word       | 向后一个单词                              |
|---------+---------------------+-------------------------------------------|
| C-a     | beginning-of-line   | 移到行首                                  |
|---------+---------------------+-------------------------------------------|
| C-e     | end-of-line         | 移到行尾                                  |
|---------+---------------------+-------------------------------------------|
| M-e     | forward-sentence    | 移到句首                                  |
|---------+---------------------+-------------------------------------------|
| M-a     | backward-sentence   | 移到句尾                                  |
|---------+---------------------+-------------------------------------------|
| M-}     | forward-paragraph   | 下移一段                                  |
|---------+---------------------+-------------------------------------------|
| M-{     | backward-paragraph  | 上移一段                                  |
|---------+---------------------+-------------------------------------------|
| C-v     | scroll-up           | 下移一屏                                  |
|---------+---------------------+-------------------------------------------|
| M-v     | scroll-down         | 上移一屏                                  |
|---------+---------------------+-------------------------------------------|
| C-x ]   | forward-page        | 下移一页                                  |
|---------+---------------------+-------------------------------------------|
| C-x [   | backward-page       | 上移一页                                  |
|---------+---------------------+-------------------------------------------|
| M-<     | beginning-of-buffer | 移到文档头                                |
|---------+---------------------+-------------------------------------------|
| M->     | end-of-buffer       | 移到文档尾                                |
|---------+---------------------+-------------------------------------------|
| M-g g n | goto-line           | 移到第n行                                 |
|---------+---------------------+-------------------------------------------|
| (none)  | goto-char           | 移到第n个字符                             |
|---------+---------------------+-------------------------------------------|
| C-l     | recenter            | 将当前位置放到页面中间(Emacs最喜欢的地方) |
|---------+---------------------+-------------------------------------------|
| M-n     | digit-argument      | 重复下个命令n次                           |
|---------+---------------------+-------------------------------------------|
| C-u n   | universal-argument  | 重复下个命令n次，n默认为4                 |
|---------+---------------------+-------------------------------------------|
*** 缓冲区管理
|-----------------+-------------------------------+-----------------------------------|
| 按键            | 命令                          | 作用                              |
|-----------------+-------------------------------+-----------------------------------|
| C-x b           | switch-to-buffer              | 打开或新建一个缓冲                |
|-----------------+-------------------------------+-----------------------------------|
| C-x 4 b         | switch-to-buffer-other-window | 在另一个window中打开或新建一个缓  |
|                 |                               | 冲                                |
|-----------------+-------------------------------+-----------------------------------|
| C-x 5 b         | switch-to-buffer-other-frame  | 在另一个frame中打开或新建一个缓冲 |
|-----------------+-------------------------------+-----------------------------------|
| C-x LEFT        | next-buffer                   | 移动到下一个缓冲                  |
|-----------------+-------------------------------+-----------------------------------|
| C-x RIGHT       | previous-buffer               | 移动到前一个缓冲                  |
|-----------------+-------------------------------+-----------------------------------|
| C-x C-b         | list-buffers                  | 显示所有缓冲                      |
|-----------------+-------------------------------+-----------------------------------|
| C-u C-x C-b     |                               | 显示映射到文件的缓冲              |
|-----------------+-------------------------------+-----------------------------------|
| C-x k           | kill-buffer                   | 关闭缓冲                          |
|-----------------+-------------------------------+-----------------------------------|
|                 | kill-some-buffers             | 关闭多个缓冲                      |
|-----------------+-------------------------------+-----------------------------------|
|                 | clean-buffer-list             | 关闭三天未使用的缓冲              |
|-----------------+-------------------------------+-----------------------------------|
| C-x C-q         | toggle-read-only              | 切换缓冲只读属性                  |
|-----------------+-------------------------------+-----------------------------------|
| C-u M-g M-g num |                               | 跳至前一缓冲num行                 |
|-----------------+-------------------------------+-----------------------------------|
|                 | rename-buffer                 | 重命名缓冲                        |
|-----------------+-------------------------------+-----------------------------------|
|                 | rename-uniquely               | 重命名缓冲，在其名后加数字        |
|-----------------+-------------------------------+-----------------------------------|
|                 | view-buffer                   | 只读方式打开缓冲                  |
|-----------------+-------------------------------+-----------------------------------|
|                 | buffer-menu                   | 打开Buffer Menu                   |
|-----------------+-------------------------------+-----------------------------------|
|                 | make-indirect-buffer          | 建立间接缓冲                      |
|-----------------+-------------------------------+-----------------------------------|
|                 | clone-indirect-buffer         | 建立当前缓冲的间接缓冲            |
|-----------------+-------------------------------+-----------------------------------|
*** save-some-buffers C-x s
It is bound to *C-x s*.

(save-some-buffers &optional ARG PRED)

Save some modified file-visiting buffers.  Asks user about each one.
You can answer `y' to save, `n' not to save, `C-r' to look at the
buffer in question with `view-buffer' before deciding or `d' to
view the differences using `diff-buffer-with-file'.
*** other-buffer                                                   :buffer:

(other-buffer &optional buffer visible-ok frame)

return most recently selected buffer other than buffer.
buffers not visible in windows are preferred to visible buffers, unless
optional second argument visible-ok is non-nil.  ignore the argument
buffer unless it denotes a live buffer.  if the optional third argument
frame is non-nil, use that frame's buffer list instead of the selected
frame's buffer list.

** encoding

1.查看当前buffer的编码：M-x describe-coding-system

2.列出所有编码：C-x <RET> r <TAB>

3.以指定编码重读当前buffer：C-x <RET> r utf-8，（revert-buffer-with-coding-system）
4.改变当前buffer的编码：C-x <RET> f utf-8，（set-buffer-file-coding-system）

5.设定下一步操作的编码格式：C-x <RET> c，（universal-coding-system-argument）

*** 乱码问题

不知为何，每次打开 journal.org 文件显示的都是乱码。

解决使用 gedit 强行保存。

** Window
*** 移动其它窗口
**** scroll-other-window
C-M-v runs the command scroll-other-window

(scroll-other-window &optional ARG)

Scroll next window upward ARG lines; or near full screen if no ARG.
A near full screen is `next-screen-context-lines' less than a full screen.
The next window is the one below the current one; or the one at the top
if the current one is at the bottom.  Negative ARG means scroll downward.
If ARG is the atom `-', scroll downward by nearly full screen.
When calling from a program, supply as argument a number, nil, or `-'.

If `other-window-scroll-buffer' is non-nil, scroll the window
showing that buffer, popping the buffer up if necessary.
If in the minibuffer, `minibuffer-scroll-window' if non-nil
specifies the window to scroll.  This takes precedence over
`other-window-scroll-buffer'.
(setq other-window-scroll-buffer t)
(setq minibuffer-scroll-window t )
**** other-window
other-window is an interactive compiled Lisp function in `window.el'.

It is bound to C-x o.

(other-window COUNT &optional ALL-FRAMES)

Select another window in cyclic ordering of windows.
COUNT specifies the number of windows to skip, starting with the
selected window, before making the selection.  If COUNT is
positive, skip COUNT windows forwards.  If COUNT is negative,
skip -COUNT windows backwards.  COUNT zero means do not skip any
window, so select the selected window.  In an interactive call,
COUNT is the numeric prefix argument.  Return nil.

If the `other-window' parameter of the selected window is a
function and `ignore-window-parameters' is nil, call that
function with the arguments COUNT and ALL-FRAMES.

This function does not select a window whose `no-other-window'
window parameter is non-nil.

This function uses `next-window' for finding the window to
select.  The argument ALL-FRAMES has the same meaning as in
`next-window', but the MINIBUF argument of `next-window' is
always effectively nil.
*** modeline
1) 字符集 (C-返斜杠 切换)
   + C: Chinese-gbk
   + U: Unicode
2) 文件状态: **-
3) buffer-name
4) 其它等
*** Fonts
+ http://www.douban.com/group/topic/36620961/
+ http://www.iplaysoft.com/top10-programming-fonts.html


#+BEGIN_EXAMPLE
  (set-default-font "Dejavu Sans Mono 11")
  (dolist (charset '(kana han symbol cjk-misc bopomofo))
          (set-fontset-font (frame-parameter nil 'font)
                            charset
                            (font-spec :family "WenQuanYi Micro Hei Mono" :size 18)))
#+END_EXAMPLE

+ 英文：Dejavu Sans Mono 11号
+ 中文：文泉驿等宽微米黑 18号

主要是用来解决org-mode里table的中英文对齐问题。

*** delete-other-windows
 |-------+----------------------|
 | C-x 1 | delete-other-windows |
 |-------+----------------------|
*** 多窗口
|---------+-------------------------------------+----------------------------------|
| 按键    | 命令                                | 作用                             |
|---------+-------------------------------------+----------------------------------|
| C-x 2   | split-window-vertically             | 垂直拆分窗口                     |
|---------+-------------------------------------+----------------------------------|
| C-x 3   | split-window-horizontally           | 水平拆分窗口                     |
|---------+-------------------------------------+----------------------------------|
| C-x o   | other-window                        | 选择下一个窗口                   |
|---------+-------------------------------------+----------------------------------|
| C-M-v   | scroll-other-window                 | 滚动下一个窗口                   |
|---------+-------------------------------------+----------------------------------|
| C-x 4 b | switch-to-buffer-other-window       | 在另一个窗口打开缓冲             |
|---------+-------------------------------------+----------------------------------|
| C-x 4   | display-buffer                      | 在另一个窗口打开缓冲，但不选中   |
| C-o     |                                     |                                  |
|---------+-------------------------------------+----------------------------------|
| C-x 4 f | find-file-other-window              | 在另一个窗口打开文件             |
|---------+-------------------------------------+----------------------------------|
| C-x 4 d | dired-other-window                  | 在另一个窗口打开文件夹           |
|---------+-------------------------------------+----------------------------------|
| C-x 4 m | mail-other-window                   | 在另一个窗口写邮件               |
|---------+-------------------------------------+----------------------------------|
| C-x 4 r | find-file-read-only-other-window    | 在另一个窗口以只读方式打开文件   |
|---------+-------------------------------------+----------------------------------|
| C-x 0   | delete-window                       | 关闭当前窗口                     |
|---------+-------------------------------------+----------------------------------|
| C-x 1   | delete-other-windows                | 关闭其它窗口                     |
|---------+-------------------------------------+----------------------------------|
| C-x 4 0 | kill-buffer-and-window              | 关闭当前窗口和缓冲               |
|---------+-------------------------------------+----------------------------------|
| C-x ^   | enlarge-window                      | 增高当前窗口                     |
|---------+-------------------------------------+----------------------------------|
| C-x {   | shrink-window-horizontally          | 将当前窗口变窄                   |
|---------+-------------------------------------+----------------------------------|
| C-x }   | enlarge-window-horizontally         | 将当前窗口变宽                   |
|---------+-------------------------------------+----------------------------------|
| C-x -   | shrink-window-if-larger-than-buffer | 如果窗口比缓冲大就缩小           |
|---------+-------------------------------------+----------------------------------|
| C-x +   | balance-windows                     | 所有窗口一样高                   |
|---------+-------------------------------------+----------------------------------|
|         | windmove-right                      | 切换到右边的窗口(类似：up, down, |
|         |                                     | left)                            |
|---------+-------------------------------------+----------------------------------|
*** 标准窗口重构
多数情况下,winner-undo(C-c LEFT)就足够了,自定义的重构窗口函数很少会使
用,所以用不着定义全局快捷键,这样反而会增加记忆负担.

*建议所有自定义的elisp函数均以"my"开头,"-"分隔单词*


#+BEGIN_EXAMPLE
  (defun my-window-layout()
    "重构窗口布局:左上左下右"
    (interactive)
    (delete-other-windows)
    (split-window-horizontally)
    (split-window-vertically)
    )

#+END_EXAMPLE

*** Emacs 字体增城
C-x C--
C-x C-+
*** 等宽字
Org表格,ditaa中文都需要

#+BEGIN_EXAMPLE
    (set-frame-font "DejaVu Sans Mono 15")
    (set-fontset-font "fontset-default" 'unicode"Droid Sans Fallback 15")
    (defun mono-font()
      (interactive)
      (set-frame-font "DejaVu Sans Mono 14")
      (set-fontset-font "fontset-default" 'unicode"Droid Sans Fallback 16")
      )
    (defun de-mono-font()
      (interactive)
      (set-frame-font "DejaVu Sans Mono 15")
      (set-fontset-font "fontset-default" 'unicode"Droid Sans Fallback 15")
      )
    (global-set-key (kbd "C-c f m") 'mono-font)
    (global-set-key (kbd "C-c f d") 'de-mono-font)
#+END_EXAMPLE

*** Emacs F2 F2
<f2> <f2> runs the command 2C-two-columns, which is an interactive

(2C-two-columns &optional BUFFER)

Split current window vertically for two-column editing.
When called the first time, associates a buffer with the current
buffer in *two-column minor mode* (use C-h m once in the mode,
for details.).

It runs `2C-other-buffer-hook' in the new buffer.
When called again, restores the screen layout with the current buffer
first and the associated buffer to its right.

*默认行宽变乍* 关闭当前buffer重新打开文件即可。

***

** Frame                                                             :frame:
*** 切换frame
+ C-x 5 o other-frame
+ Alt+`  (Ubuntu)
*** Emacs create frame
+
  http://www.gnu.org/software/emacs/manual/html_node/emacs/Creating-Frames.html


The prefix key C-x 5 is analogous to C-x 4. Whereas each C-x 4 command
pops up a buffer in a different window in the selected frame (see
[[Pop-Up-Window.html#Pop-Up-Window][Pop Up Window]]), the C-x 5 commands
use a different frame. If an existing visible or iconified (“minimized”)
frame already displays the requested buffer, that frame is raised and
deiconified (“un-minimized”); otherwise, a new frame is created on the
current display terminal.

The various C-x 5 commands differ in how they find or create the buffer
to select:

-  C-x 5 2 :: create a new frame (=make-frame-command=).

-  C-x 5 b bufname RET :: Select buffer bufname in another frame. This
   runs =switch-to-buffer-other-frame=.

-  C-x 5 f filename RET :: Visit file filename and select its buffer in
   another frame. This runs =find-file-other-frame=. See
   [[Visiting.html#Visiting][Visiting]].

-  C-x 5 d directory RET :: Select a Dired buffer for directory
   directory in another frame. This runs =dired-other-frame=. See
   [[Dired.html#Dired][Dired]].

-  C-x 5 m :: Start composing a mail message in another frame. This runs
   =mail-other-frame=. It is the other-frame variant of C-x m. See
   [[Sending-Mail.html#Sending-Mail][Sending Mail]].

-  C-x 5 . :: Find a tag in the current tag table in another frame. This
   runs =find-tag-other-frame=, the multiple-frame variant of M-.. See
   [[Tags.html#Tags][Tags]].

-  C-x 5 r filename RET :: Visit file filename read-only, and select its
   buffer in another frame. This runs =find-file-read-only-other-frame=.
   See [[Visiting.html#Visiting][Visiting]].

You can control the appearance and behavior of the newly-created frames
by specifying /frame parameters/. See
[[Frame-Parameters.html#Frame-Parameters][Frame Parameters]].

#+END_HTML
*** frame-maximum
+ toggle-frame-fullscreen <f11>
+ toggle-frame-maximized M-<f10>(Ubuntu系统菜单) ESC <f10>
+ 值得提起是因为在不同平台达到同样的效果真的很复杂

*** winner-undo(Emacs Window管理)
|-------------+-------------|
| C-c <left>  | winner-undo |
| C-c <right> | winner-redo |
|-------------+-------------|



支持连续多次的undo和redo，应该有一个类似yank-ring的机制

** Macro                                                             :macro:
*** 录制宏
Macro records your actions in Emacs and play back later.
|-------------+-----------------------|
| f3 or C-x ( | Start recording macro |
| f4 or C-x ) | Stop recording macro  |
| C-x e or f4 | Playback macro        |
|-------------+-----------------------|

+ shorter- cut: Personally, I use f3 and f4 for recording/playback, so
  I don't have to press many keys.
+ repeat:
  + *To repeat a macro many times, use prefix argument.*  For
    example, C-u 10 <f4> executes a macro 10 times.
  + If you want to repeat until the end of file, use prefix argument
    0: *C-u 0 <f4>*
  + Alternatively, highlight the region of remaining lines, and *C-x
    C-k r*: run the last keyboard macro on each line that begins in
    the region (apply-macro-to-region-lines).
+ cancel: If you want to cancel recording, C-g.
+ After a macro is defined, it is saved in the keyboard macro
  ring. There is only one keyboard macro ring, shared by all buffers.
+ All commands which operate on the keyboard macro ring use the same
  C-x C-k prefix. Just remember the prefix *C-x C-k = macro commands*,
  and you won't find macro key bindings difficult to remember.


|-------------+------------------------------------------------------|
| C-x C-k C-k | Command: kmacro-end-or-call-macro-repeat             |
|             | Execute the keyboard macro at the head of the ring   |
|-------------+------------------------------------------------------|
| C-x C-k C-n | Command: kmacro-cycle-ring-next                      |
|             | Rotate the keyboard macro ring to the next macro     |
|             | (defined earlier).                                   |
|-------------+------------------------------------------------------|
| C-x C-k C-p | Command: kmacro-cycle-ring-previous                  |
|             | Rotate the keyboard macro ring to the previous macro |
|             | (defined later)                                      |
|-------------+------------------------------------------------------|

*** 保存宏
|-----------+--------------------------------------------------------------|
| C-x C-k n | Command: kmacro-name-last-macr                               |
|           | Give a command name (for the duration of the Emacs session)  |
|           | to themost recently defined keyboard macro.                  |
|-----------+--------------------------------------------------------------|
| C-x C-k b | Command: kmacro-bind-to-key                                  |
|           | Bind the most recently defined keyboard macro to a key       |
|           | sequence                                                     |
|-----------+--------------------------------------------------------------|

+ Record some keyboard macros.
+ Give the macros names with C-x C-k n.
+ Bind the macros to C-x C-k 1, C-x C-k 2… with C-x C-k b.
+ Create the file ~/.emacs.d/init.el. If you do not have the directory and
  the file, create it with find-file.
+ Create the file ~/.emacs.d/macros with find-file. You should be inside
  the buffer of this file after creating it.
+ Save the macros with M-x insert-kbd-macro.
+ To save you trouble of reloading the macro file manually, put this Emacs
  Lisp code inside ~/.emacs.d/init.el:

  (load-file "~/.emacs.d/macros")

*** F4
<f4> runs the command kmacro-end-or-call-macro, which is an
interactive autoloaded compiled Lisp function in `kmacro.el'.

It is bound to <f4>.

(kmacro-end-or-call-macro ARG &optional NO-REPEAT)

End kbd macro if currently being defined; else call last kbd macro.
With numeric prefix ARG, repeat macro that many times.
*With C-u, call second macro in macro ring.*

*** marcos
**** excute-macro-through the buffer
#+BEGIN_SRC emacs-lisp
  (defun tagerill:excute-key-macro-througth-buffer(macro)
    (interactive "sMacro: ")
    (progn (goto-char (point-min))
           (while (< (point) (point-max))
             (macro)))
    )
#+END_SRC
**** macor
*M-x insert-kbd-macro*
#+BEGIN_SRC emacs-lisp
(fset 'rm_html_block
   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([19 35 43 66 69 71 73 78 95 69 S-backspace 72 84 77 76 return 1 tab 11] 0 "%d")) arg)))
#+END_SRC
*** kmacro-end-and-call-macro(C-x e )                               :macro:
(kmacro-end-and-call-macro arg &optional no-repeat)

call last keyboard macro, ending it first if currently being defined.
with numeric prefix arg, repeat macro that many times.
zero argument means repeat until there is an error.

** Editing
*** 基本编辑
|---------------+-------------------------+-----------------------------|
| 按键          | 命令                    | 作用                        |
|---------------+-------------------------+-----------------------------|
| C-x C-f       | find-file               | 打开文件                    |
|---------------+-------------------------+-----------------------------|
| C-x C-v       | find-alternate-file     | 打开另一个文件              |
|---------------+-------------------------+-----------------------------|
| C-x C-s       | save-buffer             | 保存文件                    |
|---------------+-------------------------+-----------------------------|
| C-x C-w       | write-file              | 另存文件                    |
|---------------+-------------------------+-----------------------------|
| C-q (n)       | quoted-insert           | 插入字符，n表示字符的八进制 |
|               |                         | ASCII码                     |
|---------------+-------------------------+-----------------------------|
| C-x 8         | ucs-insert              | 插入Unicode字符             |
|---------------+-------------------------+-----------------------------|
| C-d           | delete-char             | 删除光标处字符              |
|---------------+-------------------------+-----------------------------|
| Backspace     | delete-backward-char    | 删除光标前字符              |
|---------------+-------------------------+-----------------------------|
| M-d           | kill-word               | 删除光标起单词              |
|---------------+-------------------------+-----------------------------|
| M-Backspace   | backward-kill-word      | 删除光标前单词              |
|---------------+-------------------------+-----------------------------|
| C-k           | kill-line               | 删除光标起当前行            |
|---------------+-------------------------+-----------------------------|
| M-k           | kill-sentence           | 删除光标起句子              |
|---------------+-------------------------+-----------------------------|
| C-x Backspace | backward-kill-sentence  | 删除光标前句子              |
|---------------+-------------------------+-----------------------------|
| (none)        | kill-paragraph          | 删除光标起段落              |
|---------------+-------------------------+-----------------------------|
| (none)        | backward-kill-paragraph | 删除光标前段落              |
|---------------+-------------------------+-----------------------------|
| C-/           | undo                    | 撤销                        |
|---------------+-------------------------+-----------------------------|
| C-_           | undo                    | 撤销                        |
|---------------+-------------------------+-----------------------------|
| C-x u         | undo                    | 撤销                        |
|---------------+-------------------------+-----------------------------|
| C-g           | keyboard-quit           | 撤销命令                    |
|---------------+-------------------------+-----------------------------|
| C-h t         | help-with-tutorial      | 调出Emacs Tutorial          |
|---------------+-------------------------+-----------------------------|
| C-h r         | info-emacs-manual       | 调出Emacs Manual            |
|---------------+-------------------------+-----------------------------|
| C-h k         | describe-key            | 查看对应command帮助         |
| (command)     |                         |                             |
|---------------+-------------------------+-----------------------------|
| C-o           | open-line               | 插入空行                    |
|---------------+-------------------------+-----------------------------|
| C-x C-o       | delete-blank-line       | 删除空行                    |
|---------------+-------------------------+-----------------------------|
| C-x z         | repeat                  | 重复前个命令                |
|---------------+-------------------------+-----------------------------|
*** 删除
|---------------+-------------------------+-----------------------------------------------|
| C-d           | delete-char             | 删除光标处字符                                |
| Backspace     | delete-backward-char    | 删除光标前字符                                |
| M-\           | delete-horizontal-space | 删除光标处的所有空格和Tab字符                 |
| M-SPC         | just-one-space          | 删除光标处的所有空格和Tab字符，但留下一个     |
| C-x C-o       | delete-blank-lines      | 删除光标周围的空白行，保留当前行              |
| M-^           | delete-indentation      | 将两行合为一行，删除之间的空白和缩进          |
| C-k           | kill-line               | 从光标处起删除该行                            |
| C-S-Backspace | kill-whole-line         | 删除整行                                      |
| C-w           | kill-region             | 删除区域                                      |
| M-w           | kill-ring-save          | 复制到kill 环，而不删除                       |
| M-d           | kill-word               | 删除光标起一个单词                            |
| M-Backspace   | backward-kill-word      | 删除光标前单词                                |
| M-k           | kill-sentence           | 删除光标起一句                                |
| C-x Backspace | backward-kill-sentence  | 删除光标前删一句                              |
| M-z char      | zap-to-char             | 删至字符char为止                              |
|---------------+-------------------------+-----------------------------------------------|

*** Dired
+ g revert-buffer (revert恢复) 刷新目录buffer
+ ! dired-do-shell-command
+ & dired-do-async-shell-command
*** Killing & Yanking
|---------------+-------------------------+----------------------------------------------|
| 按键          | 命令                    | 作用                                         |
|---------------+-------------------------+----------------------------------------------|
| C-d           | delete-char             | 删除光标处字符                               |
|---------------+-------------------------+----------------------------------------------|
| Backspace     | delete-backward-char    | 删除光标前字符                               |
|---------------+-------------------------+----------------------------------------------|
| M-\           | delete-horizontal-space | 删除光标处的所有空格和Tab字符                |
|---------------+-------------------------+----------------------------------------------|
| M-SPC         | just-one-space          | 删除光标处的所有空格和Tab字符，但留下一个    |
|---------------+-------------------------+----------------------------------------------|
| C-x C-o       | delete-blank-lines      | 删除光标周围的空白行，保留当前行             |
|---------------+-------------------------+----------------------------------------------|
| M-^           | delete-indentation      | 将两行合为一行，删除之间的空白和缩进         |
|---------------+-------------------------+----------------------------------------------|
| C-k           | kill-line               | 从光标处起删除该行                           |
|---------------+-------------------------+----------------------------------------------|
| C-S-Backspace | kill-whole-line         | 删除整行                                     |
|---------------+-------------------------+----------------------------------------------|
| C-w           | kill-region             | 删除区域                                     |
|---------------+-------------------------+----------------------------------------------|
| M-w           | kill-ring-save          | 复制到kill 环，而不删除                      |
|---------------+-------------------------+----------------------------------------------|
| M-d           | kill-word               | 删除光标起一个单词                           |
|---------------+-------------------------+----------------------------------------------|
| M-Backspace   | backward-kill-word      | 删除光标前单词                               |
|---------------+-------------------------+----------------------------------------------|
| M-k           | kill-sentence           | 删除光标起一句                               |
|---------------+-------------------------+----------------------------------------------|
| C-x Backspace | backward-kill-sentence  | 删除光标前删一句                             |
|---------------+-------------------------+----------------------------------------------|
| M-z char      | zap-to-char             | 删至字符char为止                             |
|---------------+-------------------------+----------------------------------------------|
| C-y           | yank                    | 召回                                         |
|---------------+-------------------------+----------------------------------------------|
| M-y           | yank-pop                | 召回前一个                                   |
|---------------+-------------------------+----------------------------------------------|
| C-M-w         | append-next-kill        | 下一个删掉内容和上次删除合并                 |
|---------------+-------------------------+----------------------------------------------|
| C-h v         | describe-variable       | 显示变量内容                                 |
|---------------+-------------------------+----------------------------------------------|
| (none)        | append-to-buffer        | 将区域中内容加入到一个buffer中               |
|---------------+-------------------------+----------------------------------------------|
| (none)        | prepend-to-buffer       | 将区域中内容加入到一个buffer光标前           |
|---------------+-------------------------+----------------------------------------------|
| (none)        | copy-to-buffer          | 区域中内容加入到一个buffer中，删除该buffer原 |
|               |                         | 有内容                                       |
|---------------+-------------------------+----------------------------------------------|
| (none)        | insert-buffer           | 在该位置插入指定的buffer中所有内容           |
|---------------+-------------------------+----------------------------------------------|
| (none)        | append-to-file          | 将区域中内容复制到一个文件中                 |
|---------------+-------------------------+----------------------------------------------|
| (none)        | cua-mode                | 启用/停用CUA绑定                             |
|---------------+-------------------------+----------------------------------------------|

|-------------------+-----------------------------|
| 变量              | 作用                        |
|-------------------+-----------------------------|
| kill-read-only-ok | 是否在只读文件启用kill 命令 |
|-------------------+-----------------------------|
| kill-ring         | kill环                      |
|-------------------+-----------------------------|
| kill-ring-max     | kill环容量                  |
|-------------------+-----------------------------|
*** home目录处理 ~
+ 不同用户的主目录路径名不一致，e.g.
  - /home/ben
  - /home/tiger
+ 符号 ~ 是特定平台下主目录的表示，所以不一定具备移植性
+ 解决：使用 expand-file-name 对 ~ 进行扩展
  #+BEGIN_EXAMPLE
  (load-file (concat (expand-file-name "~/.emacs.d") "/cedet/cedet-devel-load.el"))
  #+END_EXAMPLE

*** 标记
|---------+-------------------------+----------------------|
| 按键    | 命令                    | 作用                 |
|---------+-------------------------+----------------------|
| C-@     | set-mark-command        | 设定标记             |
|---------+-------------------------+----------------------|
| C-x C-x | exchange-point-and-mark | 交换标记和光标位置   |
|---------+-------------------------+----------------------|
| C-w     | kill-region             | 删除区域中内容       |
|---------+-------------------------+----------------------|
| C-x C-u | upcase-region           | 将区域中字母改为大写 |
|---------+-------------------------+----------------------|
| C-x h   | mark-whole-buffer       | 全选                 |
|---------+-------------------------+----------------------|
| C-x C-p | mark-page               | 选取一页             |
|---------+-------------------------+----------------------|
| M-h     | mark-paragraph          | 选取一段             |
|---------+-------------------------+----------------------|
| M-@     | mark-word               | 选取一个单词         |
|---------+-------------------------+----------------------|
| C-@ C-@ |                         | 加入点到标记环       |
|---------+-------------------------+----------------------|
| C-u C-@ |                         | 在标记环中跳跃       |
|---------+-------------------------+----------------------|
| C-x C-@ | pop-global-mark         | 在全局标记环中跳跃   |
|---------+-------------------------+----------------------|
| (none)  | transient-mark-mode     | 非持久化标记模式     |
|---------+-------------------------+----------------------|

|-----------------------------+------------------------|
| 变量                        | 作用                   |
|-----------------------------+------------------------|
| set-mark-command-repeat-pop | 是否使用C-@连续跳跃    |
|-----------------------------+------------------------|
| mark-ring-max               | 标记环最大容量         |
|-----------------------------+------------------------|
| mark-even-if-nonactive      | 是否只使用激活状态标记 |
|-----------------------------+------------------------|

*** 查找替换
|-----------+-------------------------+--------------------------------------------|
| 按键      | 命令                    | 作用                                       |
|-----------+-------------------------+--------------------------------------------|
| C-s       | isearch-forward         | 向前进行增量查找                           |
|-----------+-------------------------+--------------------------------------------|
| C-r       | isearch-backward        | 向后进行增量查找                           |
|-----------+-------------------------+--------------------------------------------|
| M-c       |                         | (查找状态)切换大写敏感                     |
|-----------+-------------------------+--------------------------------------------|
| C-j       | newline-and-indent      | (查找状态)输入换行符                       |
|-----------+-------------------------+--------------------------------------------|
| M-Tab     | isearch-complete        | (查找状态)自动匹配                         |
|-----------+-------------------------+--------------------------------------------|
| C-h C-h   |                         | (查找状态)进入查找帮助                     |
|-----------+-------------------------+--------------------------------------------|
| C-w       |                         | (查找状态)将光标处单词复制到查找区域       |
|-----------+-------------------------+--------------------------------------------|
| C-y       |                         | (查找状态)将光标处直到行尾内容复制到查找区 |
|           |                         | 域                                         |
|-----------+-------------------------+--------------------------------------------|
| M-y       |                         | (查找状态)把kill 环中最后一项复制到查找区  |
|           |                         | 域                                         |
|-----------+-------------------------+--------------------------------------------|
| C-M-w     |                         | (查找状态)删除查找区域最后一个字符         |
|-----------+-------------------------+--------------------------------------------|
| C-M-y     |                         | (查找状态)将光标处字符复制到查找区域最后   |
|-----------+-------------------------+--------------------------------------------|
| C-f       |                         | (查找状态)将光标处字符复制到查找区域最后   |
|-----------+-------------------------+--------------------------------------------|
| C-s RET   | search-forward          | 向前进行简单查找                           |
|-----------+-------------------------+--------------------------------------------|
| C-r RET   | search-backward         | 向后进行简单查找                           |
|-----------+-------------------------+--------------------------------------------|
| M-s w     | isearch-forward-word    | 向前进行词组查找                           |
|-----------+-------------------------+--------------------------------------------|
| M-s w RET | word-search-forward     | 向前进行词组查找（非增量方式）             |
|-----------+-------------------------+--------------------------------------------|
| M-s w C-r | word-search-backward    | 向后进行词组查找（非增量方式）             |
| RET       |                         |                                            |
|-----------+-------------------------+--------------------------------------------|
| C-M-s     | isearch-forward-regexp  | 向前进行正则查找                   |
|-----------+-------------------------+--------------------------------------------|
| C-M-r     | isearch-backward-regexp | 向后进行正则查找                           |
|-----------+-------------------------+--------------------------------------------|
|           | replace-string          | 全文替换                                   |
|-----------+-------------------------+--------------------------------------------|
|           | replace-regexp          | 全文正则替换                               |
|-----------+-------------------------+--------------------------------------------|
| M-%       | query-replace           | 查找替换                                   |
|-----------+-------------------------+--------------------------------------------|
|           | recursive-edit          | 进入递归编辑                               |
|-----------+-------------------------+--------------------------------------------|
|           | abort-recursive-edit    | 退出递归编辑                               |
|-----------+-------------------------+--------------------------------------------|
|           | top-level               | 退出递归编辑                               |
|-----------+-------------------------+--------------------------------------------|

*** 大小写转换
http://blog.sina.com.cn/s/blog_88b165d301017dc2.html

1. 从光标位置开始，处理单词后半部分
   capitalize-word (M-c) ;; 单词首字母转为大写
   upcase-word (M-u)     ;; 整个单词转为大写
   downcase-word (M-l)   ;; 整个单词转为小写
2. 从光标位置开始，处理单词前半部分
   negtive-argument; capitalize-word (M-- M-c) ;; 单词首字母转为大写
   negtive-argument; upcase-word (M-- M-u)     ;; 整个单词转为大写
   negtive-argument; downcase-word (M-- M-l)   ;; 整个单词转为小写
3. 改变选定区域的大小写
   downcase-region (C-x C-l) ;; 选定区域全部改为小写
   upcase-region (C-x C-u)   ;; 选定区域全部改为大写

*** indent
Command: indent-region
+ Keybinding: *C-M-\*
+ Usage: (indent-region START END &optional COLUMN)
+ Function: Indent each nonblank line in the region.
+ Arugment: A numeric prefix argument specifies a column: indent each
  line to that column.
+ Note: With no prefix argument, the command chooses one of these
  methods and indents all the lines with it:
  1) If `fill-prefix' is non-nil, insert `fill-prefix' at the
     beginning of each line in the region that does not already begin
     with it.
  2) If `indent-region-function' is non-nil, call that function
     to indent the region.
  3) Indent each line via `indent-according-to-mode'.

*** flush-lines
Delete lines containing matches for REGEXP.

*** 交换前后字符
| C-t | transpose-chars |

(transpose-chars ARG)

Interchange characters around point, moving forward one character.
With prefix arg ARG, effect is to take character before point
and drag it forward past ARG other characters (backward if ARG negative).
If no argument and at end of line, the previous two chars are exchanged.

*** 矩形操作
参考:
+ [[http://blog.sina.com.cn/s/blog_88b165d301017djg.html][sina blog]]
+ [[http://blog.163.com/vic_kk/blog/static/494705242010428667250/][矩形和寄存器]]

Emacs以C-x r开头的命令来进行矩形操作.
注: *KEYS C-h* 查看当前buffer中以某个快捷键序列开头的快捷键列表.
|-----------+----------------------------+-----------------------|
| C-x r c   | clear-rectangle            | 清空一个矩形块,以空格 |
| C-x r d   | delete-rectangle           | 删除一个矩形块,以空白 |
| C-x r k   | kill-rectangle             | 剪切一个矩形块        |
| C-x r r   | copy-rectangle-to register | 复制矩形块到寄存器    |
| C-x r i   | insert-register            |                       |
| C-x r g   | insert-register            |                       |
| C-x r y   | yank-rectangle             | 粘贴一个矩形块        |
| C-x r o   | open-rectangle             | 插入一个矩形块        |
| C-x r t   | string-rectangle           | string-rectangle      |
| C-x r M-w | copy-rectangle-as-kill     |                       |
|-----------+----------------------------+-----------------------|

cua-mode支持可视化块模式.

*** rectangle-number-lines(C-x r N) 在region前加上行号,使某些行为失效
*** copy without selection
+ http://emacswiki.org/emacs/CopyWithoutSelection


1. built-in
   + C-M-SPC set-mark-command

   + C-M-SPC M-W/C-M

   + C-M-SPC C-M-SPC  mart two elements

2. copy word
   #+BEGIN_EXAMPLE
     (defun copy-word (&optional arg)
      "Copy words at point into kill-ring"
       (interactive "P")
       (copy-thing 'backward-word 'forward-word arg)
       ;;(paste-to-mark arg)
     )
   #+END_EXAMPLE

3. copy line
   #+BEGIN_EXAMPLE
     (defun copy-line (&optional arg)
        "Save current line into Kill-Ring without mark the line "
         (interactive "P")
         (copy-thing 'beginning-of-line 'end-of-line arg)
         (paste-to-mark arg)
       )
   #+END_EXAMPLE

4. copy paragraph
   #+BEGIN_EXAMPLE
     (defun copy-paragraph (&optional arg)
           "Copy paragraphes at point"
            (interactive "P")
            (copy-thing 'backward-paragraph 'forward-paragraph arg)
            (paste-to-mark arg)
          )
   #+END_EXAMPLE

5. copy string
   #+BEGIN_EXAMPLE
     (defun beginning-of-string(&optional arg)
            "  "
            (re-search-backward "[ \t]" (line-beginning-position) 3 1)
                  (if (looking-at "[\t ]")  (goto-char (+ (point) 1)) )
          )
          (defun end-of-string(&optional arg)
            " "
            (re-search-forward "[ \t]" (line-end-position) 3 arg)
                  (if (looking-back "[\t ]") (goto-char (- (point) 1)) )
          )

          (defun thing-copy-string-to-mark(&optional arg)
            " Try to copy a string and paste it to the mark
          When used in shell-mode, it will paste string on shell prompt by default "
            (interactive "P")
            (copy-thing 'beginning-of-string 'end-of-string arg)
            (paste-to-mark arg)
          )
   #+END_EXAMPLE

6. copy parenthesis
   #+BEGIN_EXAMPLE
     (defun beginning-of-parenthesis(&optional arg)
            "  "
            (re-search-backward "[[<(?\"]" (line-beginning-position) 3 1)
                  (if (looking-at "[[<(?\"]")  (goto-char (+ (point) 1)) )
          )
          (defun end-of-parenthesis(&optional arg)
            " "
            (re-search-forward "[]>)?\"]" (line-end-position) 3 arg)
                  (if (looking-back "[]>)?\"]") (goto-char (- (point) 1)) )
          )

          (defun thing-copy-parenthesis-to-mark(&optional arg)
            " Try to copy a parenthesis and paste it to the mark
          When used in shell-mode, it will paste parenthesis on shell prompt by default "
            (interactive "P")
            (copy-thing 'beginning-of-parenthesis 'end-of-parenthesis arg)
            (paste-to-mark arg)
          )
   #+END_EXAMPLE

*** 根据有无前缀区分find-file和find-file-other-window
- State "DONE"       from "TODO"       [2015-03-22 日 17:23]

 | C-x 4 C-f, C-x 4 f | find-file-other-window |

*** keybinding prefix
+ http://stackoverflow.com/questions/25232717/emacs-error-key-sequence

1. Question
   #+BEGIN_EXAMPLE
     (global-set-key (kbd "M-- M-u") 'upcase-word)
     (global-set-key (kbd "M-- M-c") 'capitalize-word)

     global-set-key: Key sequence M-- M-u starts with non-prefix key M--
   #+END_EXAMPLE

2. Ans
   + the key is already bound
   + de-keybinding

   #+BEGIN_EXAMPLE
     (global-set-key (kbd "M--") nil)        ; de-keybinding M--(negative-argument)
     (global-set-key (kbd "M-- M-u") 'upcase-word)
     (global-set-key (kbd "M-- M-c") 'capitalize-word)
   #+END_EXAMPLE

*** keybinds
- State "DONE"       from "TODO"       [2015-03-30 一 17:14]
http://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Binding-Commands.html

1. keybinding
   #+BEGIN_SRC emacs-lisp
     ;; redefines C-x C-\ to move down a line.
     (global-set-key (kbd "C-x C-\\") 'next-line)
     (global-set-key [?\C-x ?\C-\\] 'next-line)
     (global-set-key [(control ?x) (control ?\\)] 'next-line)

     (global-set-key [M-mouse-1] 'mouse-set-point)
   #+END_SRC

2. commands
   1) global-set-key

      + (global-set-key key binding)
      + (define-key (current-global-map) key binding)

   2) glabal-unset-key
      + (global-unset-key key)
      + (define-key (current-global-map) key nil)

   3) local-set-key
      + (local-set-key key binding)
      + (define-key (current-local-map) key binding)

   4) local-unset-keybinds
      + (local-unset-key key)
      + (define-key (current-local-map) key nil)


*** whitespace                                                 :whitespace:
+ http://emacswiki.org/emacs/DeletingWhitespace
**** M-SPC just-one-space
**** *=M-\=* delete-horizontal-space
**** M-x delete-trailing-whitespace
(add-hook 'before-save-hook 'delete-trailing-whitespace)
**** C-x C-o delete-blank-lines
deletes any extra blank lines between two paragraphs, leaving just one blank line.
**** org-mode delete extra line before haed line
#+BEGIN_SRC emacs-lisp
    ;; delete-blank-lines
    ;; It is bound to C-x C-o.
    ;; (delete-blank-lines)
    ;; On blank line, delete all surrounding blank lines, leaving just one.
    ;; On isolated blank line, delete that one.
    ;; On nonblank line, delete any immediately following blank lines.
  ;; <S-iso-lefttab> runs the command org-shifttab, which is an interactive
  ;; compiled Lisp function in `org.el'.

  ;; It is bound to <backtab>, <S-tab>, <S-iso-lefttab>, <menu-bar> <Tbl>
  ;; <Previous Field>, <menu-bar> <Org> <Show/Hide> <Cycle Global
  ;; Visibility>.

  ;; (org-shifttab &optional ARG)

  ;; Global visibility cycling or move to previous table field.
  ;; Call `org-table-previous-field' within a table.
  ;; When ARG is nil, cycle globally through visibility states.
  ;; When ARG is a numeric prefix, show contents of this level.


    (defun tagerill-org-mode-delete-extra-lines-before-headings()
      "delete extra lines before headings"
      (interactive)
      (save-excursion
        (goto-char (point-min))
        (next-line 2)
        (while (search-forward-regexp "^*+ " nil t)
          (previous-line)
          (delete-blank-lines)
          (next-line 2))
        )
      (org-shifttab 1)
      )
    (define-key 'org-mode-map "\C-ci\C-o" 'tagerill-org-mode-delete-extra-lines-before-headings)
#+END_SRC

**** TODO 将中文全角空格作为Whitespace处理

**** Deleting Whitespace
http://emacswiki.org/emacs/DeletingWhitespace

Emacs has several commands to delete whitespace.

***** Just one space

To make sure two words are separated by /just one space/, use =‘M-SPC’=
(=‘just-one-space’=).

***** Join two words

To /join two words/ (or any non-space characters) together by deleting
all whitespace between them, use any of the following:

-  `=M-\=' (=‘delete-horizontal-space’=)
-  This command:

#+BEGIN_EXAMPLE
            (defun kill-whitespace ()
              "Kill the whitespace between two non-whitespace characters"
              (interactive "*")
              (save-excursion
                (save-restriction
                  (save-match-data
                    (progn
                      (re-search-backward "[^ \t\r\n]" nil t)
                      (re-search-forward "[ \t\r\n]+" nil t)
                      (replace-match "" nil nil))))))
#+END_EXAMPLE

***** Remove trailing whitespace

To /remove trailing whitespace/ from the entire buffer, use any of the
following:

-  =‘M-x delete-trailing-whitespace’=
   ([[http://www.emacswiki.org/emacs/GnuEmacs][GnuEmacs]] version 21 or
   later). You can put this in =‘before-save-hook’= to ensure that your
   files have no trailing whitespace:

#+BEGIN_EXAMPLE
            (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_EXAMPLE

-   :: or you can add this hook locally for particular mode:

-  (add-hook ‘c-mode-hook (lambda () (add-to-list ‘write-file-functions
   ‘delete-trailing-whitespace)))

***** Remove even the last trailing newline

#+BEGIN_EXAMPLE
           (defun my-other-delete-trailing-blank-lines ()
              "Deletes all blank lines at the end of the file, even the last one"
              (interactive)
              (save-excursion
                (save-restriction
                  (widen)
                  (goto-char (point-max))
                  (delete-blank-lines)
                  (let ((trailnewlines (abs (skip-chars-backward "\n\t"))))
                    (if (> trailnewlines 0)
                        (progn
                          (delete-char trailnewlines)))))))
#+END_EXAMPLE

****** With PictureMode

-  [[http://www.emacswiki.org/emacs/PictureModeTrailingWhitespaceTrick][PictureModeTrailingWhitespaceTrick]].
   Simple and quick. Works in all
   [[http://www.emacswiki.org/emacs/GnuEmacs][GnuEmacs]] versions.

****** nuke-trailing-whitespace

-  =‘M-x nuke-trailing-whitespace’=



-   :: *Note:* I've had some corruption problems with
   =‘nuke-trailing-whitespace’= and Unicode files. In addition to the
   trailing newlines getting deleted, a few non-whitespace characters
   get deleted too. I've done a quick fix by replacing the
   =‘delete-region’= with =‘delete-blank-lines’=.



****** whitespace.el

-  =whitespace.el=. --
   [[http://www.emacswiki.org/emacs/GregFenton][GregFenton]]

****** Simple function

-  This commmand (e.g. bind to =‘C-x C-h’=):

#+BEGIN_EXAMPLE
            (defun my-delete-leading-whitespace (start end)
              "Delete whitespace at the beginning of each line in region."
              (interactive "*r")
              (save-excursion
                (if (not (bolp)) (forward-line 1))
                (delete-whitespace-rectangle (point) end nil)))
#+END_EXAMPLE

****** ethan-wspace

-  [[http://github.com/glasserc/ethan-wspace][ethan-wspace]] - keeps
   whitespace clean in clean files while highlighting it in dirty files

****** DeleteNlSpaces

-  [[http://www.emacswiki.org/emacs/DeleteNlSpaces][DeleteNlSpaces]] - a
   non intrusive minor mode for deleting needless spaces

***** Version control friendly options (modify only the lines you have
edited)

When working with version-control, you never want Emacs to modify lines
which you didn't edit, so automatically deleting all trailing whitespace
from a file is a bad idea.

The following libraries automatically remove unwanted trailing
whitespace from the lines you've edited (only).

-  [[ftp://ftp.lysator.liu.se/pub/emacs/ws-trim.el][ws-trim.el]] - an
   old but still very, very good package. Very configurable. My only
   complaint is that it doesn't use the Custom library to set variables.

   -  From the commentary: “This package contains tools to do various
      sorts of whitespace trimming on buffer lines. The main part is WS
      Trim mode, which is a minor mode that automatically trims
      whitespace on text lines. You can control how thorough this mode
      should be, e.g. whether all lines or only lines you edit should be
      trimmed.”
   -  ws-trim has been updated to provide compatibility with Emacs 24
      (support for Emacs 20 and below has been dropped).

-  [[https://github.com/lewang/ws-butler][ws-butler]] - An alternative
   to ws-trim which leverages highlight-changes-mode to track modified
   lines.

***** Show trailing whitespace

To /show/ (highlight) trailing whitespace, see
[[http://www.emacswiki.org/emacs/ShowWhiteSpace][ShowWhiteSpace]]. There
are several ways, depending on what you want and what Emacs version you
have.

***** Remove whitespace at the end of the document

To remove whitespace at the /end of a document/, use any of the
following:

-  =‘C-x C-o’= (=‘delete-blank-lines’=) at the end of the buffer
   (`=M->=').

-   :: however, be aware that if =‘require-final-newline’= is
   non-=‘nil’=, then a (single) newline will be added automatically at
   the end of the file. (The particular non-=‘nil’= value determines
   when it is added -- see =‘C-h v require-final-newline’=.)

-  This code:

#+BEGIN_EXAMPLE
        (defun my-delete-trailing-blank-lines ()
          "Deletes all blank lines at the end of the file."
          (interactive)
          (save-excursion
            (save-restriction
              (widen)
              (goto-char (point-max))
              (delete-blank-lines))))
#+END_EXAMPLE

***** Delete extra blank lines between paragraphs

=‘C-x C-o’= (=‘delete-blank-lines’=) also deletes any extra blank lines
between two paragraphs, leaving just one blank line.

***** Prevent adding newlines at end of buffer

To /prevent adding newlines/ when you move the
[[http://www.emacswiki.org/emacs/cursor][cursor]] forward at the end of
the buffer, customize =‘next-line-add-newlines’= to =‘nil’=.

***** Indent/unindent a block of lines

To /indent/ (or /unindent/) a block of lines together rigidly (adding or
removing whitespace at the line beginning):

1. Select all the lines to indent
2. Ensure the [[http://www.emacswiki.org/emacs/TextCursor][TextCursor]]
   is at the beginning of the last line to indent.
3. =C-u NUM C-x TAB= to indent =NUM= columns. A negative =NUM= (e.g.,
   =C-- 4 C-x TAB=) un-indents, removing a rectangle of whitespace

***** Whitespace Aware `kill-line'

This handles whitespace a little better when having indentation and you
kill a line.

#+BEGIN_EXAMPLE
        (defadvice kill-line (after kill-line-cleanup-whitespace activate compile)
          "cleanup whitespace on kill-line"
          (if (not (bolp))
          (delete-region (point) (progn (skip-chars-forward " \t") (point)))))
#+END_EXAMPLE

***** Delete adjacent whitespace

To delete whitespace from /point to next word/:

#+BEGIN_EXAMPLE
        (defun whack-whitespace (arg)
          "Delete all white space from point to the next word.  With prefix ARG
        delete across newlines as well.  The only danger in this is that you
        don't have to actually be at the end of a word to make it work.  It
        skips over to the next whitespace and then whacks it all to the next
        word."
          (interactive "P")
          (let ((regexp (if arg "[ \t\n]+" "[ \t]+")))
            (re-search-forward regexp nil t)
            (replace-match "" nil nil)))
#+END_EXAMPLE



To delete /adjacent whitespace/ forward:

#+BEGIN_EXAMPLE
        (defun delete-horizontal-space-forward () ; adapted from `delete-horizontal-space'
          "*Delete all spaces and tabs after point."
          (interactive "*")
          (delete-region (point) (progn (skip-chars-forward " \t") (point))))
#+END_EXAMPLE

Backward:

#+BEGIN_EXAMPLE
        (defun backward-delete-char-hungry (arg &optional killp)
          "*Delete characters backward in \"hungry\" mode.
        See the documentation of `backward-delete-char-untabify' and
        `backward-delete-char-untabify-method' for details."
          (interactive "*p\nP")
          (let ((backward-delete-char-untabify-method 'hungry))
            (backward-delete-char-untabify arg killp)))
#+END_EXAMPLE

What is the difference between those two functions and the built-in
=backward-delete-char-untabify-method= and =delete-horizontal-space=? --
c-7e5ae353.131-1-64736c10.cust.bredbandsbolaget.se

‘C-h f' for function reference clears this up.

backward-delete-char-untabify:

Delete characters backward, changing tabs into spaces. The exact
behavior depends on =‘backward-delete-char-untabify-method’=.

delete-horizontal-space:

Delete all spaces and tabs around point. If BACKWARD-ONLY is non-nil,
only delete them before point.

*** Narrowing                                                   :narrowing:
+ 前缀 *c-x n*
c-x n n  narrow-to-region
c-x n w

|---------+------------------+--------------------------------------------------|
| c-x n n | narrow-to-region | narrow down to between point and mark            |
| c-x n w | widen            | widen to make the entire buffer accessible again |
| c-x n p | narrow-to-page   | narrow down to the current page                  |
| c-x n d | narrow-to-defun  | narrow down to the current defun                 |
|---------+------------------+--------------------------------------------------|


the narrowing commands are *disabledcommands* because they can confuse
users who are unfamiliar with narrowing. you can enable them by using
command *‘enable-command’* or by putting the following emacslisp code
in your init file:

#+begin_src emacs-lisp
  (put 'narrow-to-defun  'disabled nil)
  (put 'narrow-to-page   'disabled nil)
  (put 'narrow-to-region 'disabled nil)
#+end_src

*** 快速切换文件                                                   :buffer:

clock: [2015-11-20 五 11:29]--[2015-11-20 五 11:40] =>  0:11

c-x b ret 键还是多了，而且有helm窗口，有时两个文件之间需要频繁切换。最
好绑定在另外一个快捷键。

快捷键 m-q: m-q 与 m-tab 和 m-～最近。
m-q 被预先绑定在 fill-paragraph

1. 方案1： 定义宏
   1) 可行性： ok
   2) 问题： 中文输入法

2. (other-buffer)
   #+begin_src emacs-lisp
     (define-key global-map "\m-q" nil)
     (define-key global-map "\m-q" '(lambda()
                                      (interactive)
                                      (switch-to-buffer (other-buffer))))
   #+end_src

** Regexp                                                           :regexp:
*** 匹配以"* "开头的行
#+BEGIN_EXAMPLE
+ "^" 匹配行首
+ "\^" (error "Invalid modifier in string")
+ "\\^" 匹配"^"本身

+ "*" 匹配*本身
+ "\*" 匹配本身
+ "\\*" 表重复
+ "^* " 匹配以"* "开头的行
+ ()  匹配括号本身
+ \(\) 还是匹配括号本身
+ \\(\\) 表分组
#+END_EXAMPLE


规则不一致


(org-current-level)
#+BEGIN_SRC emacs-lisp

#+END_SRC

*** 正则表达式
#+BEGIN_EXAMPLE
+ "^" 匹配行首
+ "\^" (error "Invalid modifier in string")
+ "\\^" 匹配"^"本身

+ "*" 表重复匹配*本身
+ "\*" 匹配*本身
+ "\\*"
+ "^* " 匹配以"* "开头的行

+ ()  匹配括号本身
+ \(\) 表索引
+ \\(\\) 无效

+ [0-9] 一位数字
+ [0-9]+ 多位数字
+ [0-9]* 一个或多位数字

+ . 匹配任意字符
+ \. 匹配句点
+ \\. 无效

+ \  无效
+ \\ 匹配反斜线

+ [] 表分组
+ \[ 匹配左中括号


#+END_EXAMPLE

** Games
*** games
1. built-in
   + *tetria* 俄罗斯方块
   + *gomoku*  五子棋
   + *mpuz* 填字游戏
   + *snake*  贪吃蛇
   + *zone*
   + *dunnet*
2. others
   + *2048*

*** tetria
|---------+--------------------|
| key     | binding            |
|---------+--------------------|
| SPC     | tetris-move-bottom |
| n       | tetris-start-game  |
| p       | tetris-pause-game  |
| q       | tetris-end-game    |
| <down>  | tetris-rotate-next |
| <left>  | tetris-move-left   |
| <right> | tetris-move-right  |
| <up>    | tetris-rotate-prev |
|---------+--------------------|

** key bindings
*** XKeymacs
+ http://www.cam.hi-ho.ne.jp/oishi/indexen.html
+ http://www.emacswiki.org/emacs/XKeymacs
+ http://www.v2ex.com/t/67869


1. what

   XKeymacs is a keyboard utility to realize emacs like-useability on
   all windows applications. With XKeymacs you can use emacs
   keybindings with any windows application. You can create a keyboard
   macro and assign any shortcut key too. You also get bash-like
   command completion in your DOS shell.

   XKeymacs is a keyboard utility to realize emacs like-useability on
   all windows applications:

*** custom word with emacs keybindings

参考:
+ [[http://hints.macworld.com/article.php?story=20070215034801484]]

**** MS Word配置和宏
Emacs users get addicted to the standard key bindings (which are also
available in Cocoa apps). Microsoft Word doesn't support these by
default, but you can add them through customization. Here are the ones
I find most useful:

+ StartOfLine: Control-A
+ EndOfLine: Control-E
+ LineUp: Control-P
+ LineDown: Control-N
+ CharLeft: Control-B
+ CharRight: Control-F

To set these up in Word, go to Tools » Customize » Customize
Keyboard. From the Categories panel, choose All commands. Find each of
the entries in the above list, select the Press new shortcut key box
for each, then type the shortcut as shown above and click
Assign. (Word will tell you if any of the shortcuts are currently
assigned to other commands.)

The icing on the cake is to get Control-K working. You can do this
with a macro. Go to Tools » Macro » Macros. Set the macro name to
CtrlK, then click Create. When the macro window appears, add the
following lines just before the End Sub line:
    Selection.EndKey Unit:=wdLine, Extend:=wdExtend
    Selection.Cut
Hit the W icon on the toolbar to save the macro and go back to
Word. Now go back to the Tools » Customize » Customize Keyboard
window, choose Macros from the Categories pane, and assign your new
macro to Control-K.

**** TODO 插件
- State "TODO"       from ""           [2015-03-10 二 21:05]

*** ABORT [#C] Word快捷键改为Emacs风格
DEADLINE: <2015-03-15 日>
- State "ABORT"      from "TODO"       [2015-03-04 三 01:41]
- State "TODO"       from ""           [2015-03-01 日 12:29]
 Date:<2015-02-28 六>

 Link:
  + http://emacsblog.org/2007/02/18/emacs-key-bindings-in-ms-word/
  + http://sourceforge.net/projects/womacs/
*** DONE [#C] OpenOffice Emacs Key bindings
DEADLINE: <2015-03-15 日>
- State "DONE"       from "START"      [2015-03-04 三 01:28]
- State "START"      from "TODO"       [2015-03-04 三 01:15]
- State "TODO"       from ""           [2015-03-01 日 12:28]
 Date:<2015-02-28 六>


Link:
+ http://www.emacswiki.org/emacs/OpenOffice
+ http://wideaperture.net/blog/?p=4324

*** Chrome: Edit with Emacs
+ http://www.emacswiki.org/emacs/Edit_with_Emacs
+ https://github.com/stsquad/emacs_chrome
+ http://segmentfault.com/a/1190000002438813


Edit with Emacs is an extension for Google's Chrome(ium) browser
family that allows you to edit text areas on your browser in a more
full featured editor. It does this in conjunction with an "Edit
Server" which services requests by the browser. T


使用Chrome安装for Chrome的插件, 之后从Github下载Edit-Server到Emacs的插
件目录, 然后在Emacs的配置文件中写入:
#+BEGIN_EXAMPLE
  (add-to-list 'load-path "~/.emacs.d/edit-servers")
  (require 'edit-server)
  (when (require 'edit-server nil t)
    (setq edit-server-new-frame nil)
    (edit-server-start))
#+END_EXAMPLE

之后在网站的编辑框下方就会有一个紫色的edit小图标, 点击它Chrome就会在外
部调用Emacs进行编辑了, 非常方便.
+ 绿色表示工作正常
+ 红色表示异常


另外Edit with Emacs还有根据网站网址自动转换编辑模式的功能, 比如:
#+BEGIN_EXAMPLE
  (setq edit-server-url-major-mode-alist
        '(("github\\.com" . markdown-mode)
                  ("segmentfault\\.com" . markdown-mode)
                  ))
#+END_EXAMPLE

如此添加之后, 当我们在Github或者Segmentfault网站调用Emacs进行编辑的时
候Emacs会自动切换为Markdown-mode.

PS: Edit with Emacs的原理是在Emacs里开启一个服务, 默认监听9292端口. 然
后Chrome将文字发送给Emacs进行处理, Emacs保存时在将编辑结果返回给
Chrome. 如果Edit with Emacs在你的电脑上不能正常工作, 那么可以检查下
9292端口是否被占用. 你可以修改Edit-Server的默认端口, 然后从Chrome插件
的选项里做相应修改即可.

*** define-key                                                        :key:
(define-key keymap key def)

in keymap, define key sequence key as def.
keymap is a keymap.

key is a string or a vector of symbols and characters, representing a
sequence of keystrokes and events.  non-ascii characters with codes
above 127 (such as iso latin-1) can be represented by vectors.
two types of vector have special meanings:
 [remap command] remaps any key binding for command.
 [t] creates a default definition, which applies to any event with no
    other definition in keymap.

def is anything that can be a key's definition:
 nil (means key is undefined in this keymap),
 a command (a lisp function suitable for interactive calling),
 a string (treated as a keyboard macro),
 a keymap (to define a prefix key),
 a symbol (when the key is looked up, the symbol will stand for its
    function definition, which should at that time be one of the above,
    or another symbol whose function definition is used, etc.),
 a cons (string . defn), meaning that defn is the definition
    (defn should be a valid definition in its own right),
 or a cons (map . char), meaning use definition of char in keymap map,
 or an extended menu item definition.

** 快捷键                                                        :shortcuts:
*** 基本编辑
**** 文件与目录

|---------------+----------------------------------+------------------------|
| 快捷键（C-x） | 命令（M-x）                      | 说明                   |
|---------------+----------------------------------+------------------------|
| C-x C-f       | find-file                        | 打开文件或目录         |
| C-x C-c       | save-buffers-kill-emacs          | 保存推出               |
| C-x C-z       | iconify-or-deiconify-fram        | 挂起（最小化）         |
| C-x C-r       | find-file-read-only              | 以只读模式打开         |
| C-x i         | insert-file                      | 插入文件               |
| C-x C-s       | save-buffer                      | 保存                   |
| C-x s         | save-some-buffer                 | 保存所有未保存的缓冲区 |
| C-x C-w       | write-file                       | 另存为文件             |
| C-x RET r     | revert-buffer-with-coding-system | 以制定编码读取文件     |
| C-x RET f     | set-bugger-with-coding-system    | 以制定编码保存文件     |
| C-x d         | dired                            | 进入目录列表模式       |
| C-x C-d       | list-directory                   | 获取文件列表           |
|---------------+----------------------------------+------------------------|

|---------------+-------------------------+-----------------------------|
| 按键          | 命令                    | 作用                        |
|---------------+-------------------------+-----------------------------|
| C-x C-f       | find-file               | 打开文件                    |
|---------------+-------------------------+-----------------------------|
| C-x C-v       | find-alternate-file     | 打开另一个文件              |
|---------------+-------------------------+-----------------------------|
| C-x C-s       | save-buffer             | 保存文件                    |
|---------------+-------------------------+-----------------------------|
| C-x C-w       | write-file              | 另存文件                    |
|---------------+-------------------------+-----------------------------|
| C-q (n)       | quoted-insert           | 插入字符，n表示字符的八进制 |
|               |                         | ASCII码                     |
|---------------+-------------------------+-----------------------------|
| C-x 8         | ucs-insert              | 插入Unicode字符             |
|---------------+-------------------------+-----------------------------|
| C-d           | delete-char             | 删除光标处字符              |
|---------------+-------------------------+-----------------------------|
| Backspace     | delete-backward-char    | 删除光标前字符              |
|---------------+-------------------------+-----------------------------|
| M-d           | kill-word               | 删除光标起单词              |
|---------------+-------------------------+-----------------------------|
| M-Backspace   | backward-kill-word      | 删除光标前单词              |
|---------------+-------------------------+-----------------------------|
| C-k           | kill-line               | 删除光标起当前行            |
|---------------+-------------------------+-----------------------------|
| M-k           | kill-sentence           | 删除光标起句子              |
|---------------+-------------------------+-----------------------------|
| C-x Backspace | backward-kill-sentence  | 删除光标前句子              |
|---------------+-------------------------+-----------------------------|
| (none)        | kill-paragraph          | 删除光标起段落              |
|---------------+-------------------------+-----------------------------|
| (none)        | backward-kill-paragraph | 删除光标前段落              |
|---------------+-------------------------+-----------------------------|
| C-/           | undo                    | 撤销                        |
|---------------+-------------------------+-----------------------------|
| C-_           | undo                    | 撤销                        |
|---------------+-------------------------+-----------------------------|
| C-x u         | undo                    | 撤销                        |
|---------------+-------------------------+-----------------------------|
| C-g           | keyboard-quit           | 撤销命令                    |
|---------------+-------------------------+-----------------------------|
| C-h t         | help-with-tutorial      | 调出Emacs Tutorial          |
|---------------+-------------------------+-----------------------------|
| C-h r         | info-emacs-manual       | 调出Emacs Manual            |
|---------------+-------------------------+-----------------------------|
| C-h k         | describe-key            | 查看对应command帮助         |
| (command)     |                         |                             |
|---------------+-------------------------+-----------------------------|
| C-o           | open-line               | 插入空行                    |
|---------------+-------------------------+-----------------------------|
| C-x C-o       | delete-blank-line       | 删除空行                    |
|---------------+-------------------------+-----------------------------|
| C-x z         | repeat                  | 重复前个命令                |
|---------------+-------------------------+-----------------------------|

**** 光标

|------+------+------+------+------|
|      | 向前 | 向后 | 向下 | 向上 |
|------+------+------+------+------|
| 翻页 |      |      | C-v  | M-v  |
| 字符 | C-f  | C-b  | C-n  | C-p  |
| 单词 | M-f  | M-b  |      |      |
| 句   | M-a  | M-e  |      |      |
| 行   | C-a  | C-e  |      |      |
| 段落 | M-{  | M-}  |      |      |
| 缓冲区 | M-<  | M->  |      |      |
|--------+------+------+------+------|


|---------+---------------------+--------------------------------|
| M-g M-g | goto-line           | 跳转到某行                     |
| M-x     | goto-char           | 跳转到字符位置                 |
| C-M-l   | reposition-window   | 将当前行卷至页面中部           |
| C-l     | recenter            | 刷新页面，将当前行卷至页面中部 |
| M-r M-x | move-to-window-line | 移动光标之页面的中间行         |
|---------+---------------------+--------------------------------|

|---------+---------------------+-------------------------------------------|
| 按键    | 命令                | 作用                                      |
|---------+---------------------+-------------------------------------------|
| C-f     | forward-char        | 向前一个字符                              |
|---------+---------------------+-------------------------------------------|
| C-b     | backward-char       | 向后一个字符                              |
|---------+---------------------+-------------------------------------------|
| C-p     | previous-line       | 上移一行                                  |
|---------+---------------------+-------------------------------------------|
| C-n     | next-line           | 下移一行                                  |
|---------+---------------------+-------------------------------------------|
| M-f     | forward-word        | 向前一个单词                              |
|---------+---------------------+-------------------------------------------|
| M-b     | backward-word       | 向后一个单词                              |
|---------+---------------------+-------------------------------------------|
| C-a     | beginning-of-line   | 移到行首                                  |
|---------+---------------------+-------------------------------------------|
| C-e     | end-of-line         | 移到行尾                                  |
|---------+---------------------+-------------------------------------------|
| M-e     | forward-sentence    | 移到句首                                  |
|---------+---------------------+-------------------------------------------|
| M-a     | backward-sentence   | 移到句尾                                  |
|---------+---------------------+-------------------------------------------|
| M-}     | forward-paragraph   | 下移一段                                  |
|---------+---------------------+-------------------------------------------|
| M-{     | backward-paragraph  | 上移一段                                  |
|---------+---------------------+-------------------------------------------|
| C-v     | scroll-up           | 下移一屏                                  |
|---------+---------------------+-------------------------------------------|
| M-v     | scroll-down         | 上移一屏                                  |
|---------+---------------------+-------------------------------------------|
| C-x ]   | forward-page        | 下移一页                                  |
|---------+---------------------+-------------------------------------------|
| C-x [   | backward-page       | 上移一页                                  |
|---------+---------------------+-------------------------------------------|
| M-<     | beginning-of-buffer | 移到文档头                                |
|---------+---------------------+-------------------------------------------|
| M->     | end-of-buffer       | 移到文档尾                                |
|---------+---------------------+-------------------------------------------|
| M-g g n | goto-line           | 移到第n行                                 |
|---------+---------------------+-------------------------------------------|
| (none)  | goto-char           | 移到第n个字符                             |
|---------+---------------------+-------------------------------------------|
| C-l     | recenter            | 将当前位置放到页面中间(Emacs最喜欢的地方) |
|---------+---------------------+-------------------------------------------|
| M-n     | digit-argument      | 重复下个命令n次                           |
|---------+---------------------+-------------------------------------------|
| C-u n   | universal-argument  | 重复下个命令n次，n默认为4                 |
|---------+---------------------+-------------------------------------------|

**** 删除
|--------------+-----------------------------+------------|
|              | 向前                        | 向后       |
|--------------+-----------------------------+------------|
| 字符         | C-d                         | DEL   |
| 单词         | M-d                         | M-DEL |
| 行           | C-k(删除至行尾)             |       |
| 整行         | C-M-Backspace               |       |
| 按表达式删除 | C-M-k                       |       |
| 区块         | C-w                         |       |
| 删除连续空格 | M-x delete-horizontal-space |       |
|--------------+-----------------------------+-------|

|---------------+-------------------------+-----------------------------------------------|
| C-d           | delete-char             | 删除光标处字符                                |
| Backspace     | delete-backward-char    | 删除光标前字符                                |
| M-\           | delete-horizontal-space | 删除光标处的所有空格和Tab字符                 |
| M-SPC         | just-one-space          | 删除光标处的所有空格和Tab字符，但留下一个     |
| C-x C-o       | delete-blank-lines      | 删除光标周围的空白行，保留当前行              |
| M-^           | delete-indentation      | 将两行合为一行，删除之间的空白和缩进          |
| C-k           | kill-line               | 从光标处起删除该行                            |
| C-S-Backspace | kill-whole-line         | 删除整行                                      |
| C-w           | kill-region             | 删除区域                                      |
| M-w           | kill-ring-save          | 复制到kill 环，而不删除                       |
| M-d           | kill-word               | 删除光标起一个单词                            |
| M-Backspace   | backward-kill-word      | 删除光标前单词                                |
| M-k           | kill-sentence           | 删除光标起一句                                |
| C-x Backspace | backward-kill-sentence  | 删除光标前删一句                              |
| M-z char      | zap-to-char             | 删至字符char为止                              |
|---------------+-------------------------+-----------------------------------------------|

**** 窗口管理
|------------+------------------------------+--------|
|C-x 2       |split-window-vertically       |水平分割|
|C-x 3       |split-window-horizontally     |竖直分割|
|C-x 1       |delete-other-window           |只保留当前窗格|
|C-x 0       |delete-window                 |关闭当前窗格|
|C-x o       |other-window                  |切换窗格|
|C-M-v       |scroll-other-windwo           |滚动下一个窗格|
|------------+------------------------------+--------------|

|---------+-------------------------------------+----------------------------------|
| 按键    | 命令                                | 作用                             |
|---------+-------------------------------------+----------------------------------|
| C-x 2   | split-window-vertically             | 垂直拆分窗口                     |
|---------+-------------------------------------+----------------------------------|
| C-x 3   | split-window-horizontally           | 水平拆分窗口                     |
|---------+-------------------------------------+----------------------------------|
| C-x o   | other-window                        | 选择下一个窗口                   |
|---------+-------------------------------------+----------------------------------|
| C-M-v   | scroll-other-window                 | 滚动下一个窗口                   |
|---------+-------------------------------------+----------------------------------|
| C-x 4 b | switch-to-buffer-other-window       | 在另一个窗口打开缓冲             |
|---------+-------------------------------------+----------------------------------|
| C-x 4   | display-buffer                      | 在另一个窗口打开缓冲，但不选中   |
| C-o     |                                     |                                  |
|---------+-------------------------------------+----------------------------------|
| C-x 4 f | find-file-other-window              | 在另一个窗口打开文件             |
|---------+-------------------------------------+----------------------------------|
| C-x 4 d | dired-other-window                  | 在另一个窗口打开文件夹           |
|---------+-------------------------------------+----------------------------------|
| C-x 4 m | mail-other-window                   | 在另一个窗口写邮件               |
|---------+-------------------------------------+----------------------------------|
| C-x 4 r | find-file-read-only-other-window    | 在另一个窗口以只读方式打开文件   |
|---------+-------------------------------------+----------------------------------|
| C-x 0   | delete-window                       | 关闭当前窗口                     |
|---------+-------------------------------------+----------------------------------|
| C-x 1   | delete-other-windows                | 关闭其它窗口                     |
|---------+-------------------------------------+----------------------------------|
| C-x 4 0 | kill-buffer-and-window              | 关闭当前窗口和缓冲               |
|---------+-------------------------------------+----------------------------------|
| C-x ^   | enlarge-window                      | 增高当前窗口                     |
|---------+-------------------------------------+----------------------------------|
| C-x {   | shrink-window-horizontally          | 将当前窗口变窄                   |
|---------+-------------------------------------+----------------------------------|
| C-x }   | enlarge-window-horizontally         | 将当前窗口变宽                   |
|---------+-------------------------------------+----------------------------------|
| C-x -   | shrink-window-if-larger-than-buffer | 如果窗口比缓冲大就缩小           |
|---------+-------------------------------------+----------------------------------|
| C-x +   | balance-windows                     | 所有窗口一样高                   |
|---------+-------------------------------------+----------------------------------|
|         | windmove-right                      | 切换到右边的窗口(类似：up, down, |
|         |                                     | left)                            |
|---------+-------------------------------------+----------------------------------|

**** frame
- C-x 5 2 :: Create a new frame (=make-frame-command=).

- C-x 5 b bufname RET :: Select buffer bufname in another frame. This
  runs =switch-to-buffer-other-frame=.

- C-x 5 f filename RET :: Visit file filename and select its buffer in
  another frame. This runs =find-file-other-frame=. See
  [[Visiting.html#Visiting][Visiting]].

- C-x 5 d directory RET :: Select a Dired buffer for directory
  directory in another frame. This runs =dired-other-frame=. See
  [[Dired.html#Dired][Dired]].

- C-x 5 m :: Start composing a mail message in another frame. This runs
  =mail-other-frame=. It is the other-frame variant of C-x m. See
  [[Sending-Mail.html#Sending-Mail][Sending Mail]].

- C-x 5 . :: Find a tag in the current tag table in another frame. This
  runs =find-tag-other-frame=, the multiple-frame variant of M-.. See
  [[Tags.html#Tags][Tags]].

- C-x 5 r filename RET :: Visit file filename read-only, and select its
  buffer in another frame. This runs =find-file-read-only-other-frame=.
  See [[Visiting.html#Visiting][Visiting]].

- toggle-frame-fullscreen <f11>

- toggle-frame-maximized M-<f10>(Ubuntu系统菜单) ESC <f10>
**** 缓冲区管理
|---------+------------------+----------------|
| C-x C-b | list-buffers     | 查看缓冲区列表 |
| C-x b   | switch-to-buffer | 切换缓冲区     |
| C-x k   | kill-buffer      | 关闭缓冲       |
|---------+------------------+----------------|

|-----------------+-------------------------------+-----------------------------------|
| 按键            | 命令                          | 作用                              |
|-----------------+-------------------------------+-----------------------------------|
| C-x b           | switch-to-buffer              | 打开或新建一个缓冲                |
|-----------------+-------------------------------+-----------------------------------|
| C-x 4 b         | switch-to-buffer-other-window | 在另一个window中打开或新建一个缓  |
|                 |                               | 冲                                |
|-----------------+-------------------------------+-----------------------------------|
| C-x 5 b         | switch-to-buffer-other-frame  | 在另一个frame中打开或新建一个缓冲 |
|-----------------+-------------------------------+-----------------------------------|
| C-x LEFT        | next-buffer                   | 移动到下一个缓冲                  |
|-----------------+-------------------------------+-----------------------------------|
| C-x RIGHT       | previous-buffer               | 移动到前一个缓冲                  |
|-----------------+-------------------------------+-----------------------------------|
| C-x C-b         | list-buffers                  | 显示所有缓冲                      |
|-----------------+-------------------------------+-----------------------------------|
| C-u C-x C-b     |                               | 显示映射到文件的缓冲              |
|-----------------+-------------------------------+-----------------------------------|
| C-x k           | kill-buffer                   | 关闭缓冲                          |
|-----------------+-------------------------------+-----------------------------------|
|                 | kill-some-buffers             | 关闭多个缓冲                      |
|-----------------+-------------------------------+-----------------------------------|
|                 | clean-buffer-list             | 关闭三天未使用的缓冲              |
|-----------------+-------------------------------+-----------------------------------|
| C-x C-q         | toggle-read-only              | 切换缓冲只读属性                  |
|-----------------+-------------------------------+-----------------------------------|
| C-u M-g M-g num |                               | 跳至前一缓冲num行                 |
|-----------------+-------------------------------+-----------------------------------|
|                 | rename-buffer                 | 重命名缓冲                        |
|-----------------+-------------------------------+-----------------------------------|
|                 | rename-uniquely               | 重命名缓冲，在其名后加数字        |
|-----------------+-------------------------------+-----------------------------------|
|                 | view-buffer                   | 只读方式打开缓冲                  |
|-----------------+-------------------------------+-----------------------------------|
|                 | buffer-menu                   | 打开Buffer Menu                   |
|-----------------+-------------------------------+-----------------------------------|
|                 | make-indirect-buffer          | 建立间接缓冲                      |
|-----------------+-------------------------------+-----------------------------------|
|                 | clone-indirect-buffer         | 建立当前缓冲的间接缓冲            |
|-----------------+-------------------------------+-----------------------------------|

**** 搜索替换
|-----------+-------------------------+------------------------|
| 增量搜索  |                         |                        |
|-----------+-------------------------+------------------------|
| C-s M-x   | isearch-forward         | 向前增量搜索           |
| C-r M-x   | isearch-backward        | 向后增量搜索           |
| C-M-s M-x | isearch-forward-regexp  | 正则表达式向前增量搜索 |
| C-M-r M-x | isearch-backward-regexp | 正则表达式向后增量搜索 |
|-----------+-------------------------+------------------------|
| 一般搜索  |                         |                        |
|-----------+-------------------------+------------------------|
| M-x       | search-forward          | 向前搜索               |
| M-x       | search-backward         | 向后搜索               |
| M-x       | search-forward-regexp   | 正则表达式向前搜索     |
| M-x       | search-backwarg-regexp  | 正则表达式向后搜索     |
|-----------+-------------------------+------------------------|
| 询问替换  |                         |                        |
| M-% M-x   | query-replace           | 询问替换               |
| C-M-% M-x | query-replace-regexp    | 正则表达式询问替换     |
|-----------+-------------------------+------------------------|

|-----------+-------------------------+--------------------------------------------|
| 按键      | 命令                    | 作用                                       |
|-----------+-------------------------+--------------------------------------------|
| C-s       | isearch-forward         | 向前进行增量查找                           |
|-----------+-------------------------+--------------------------------------------|
| C-r       | isearch-backward        | 向后进行增量查找                           |
|-----------+-------------------------+--------------------------------------------|
| M-c       |                         | (查找状态)切换大写敏感                     |
|-----------+-------------------------+--------------------------------------------|
| C-j       | newline-and-indent      | (查找状态)输入换行符                       |
|-----------+-------------------------+--------------------------------------------|
| M-Tab     | isearch-complete        | (查找状态)自动匹配                         |
|-----------+-------------------------+--------------------------------------------|
| C-h C-h   |                         | (查找状态)进入查找帮助                     |
|-----------+-------------------------+--------------------------------------------|
| C-w       |                         | (查找状态)将光标处单词复制到查找区域       |
|-----------+-------------------------+--------------------------------------------|
| C-y       |                         | (查找状态)将光标处直到行尾内容复制到查找区 |
|           |                         | 域                                         |
|-----------+-------------------------+--------------------------------------------|
| M-y       |                         | (查找状态)把kill 环中最后一项复制到查找区  |
|           |                         | 域                                         |
|-----------+-------------------------+--------------------------------------------|
| C-M-w     |                         | (查找状态)删除查找区域最后一个字符         |
|-----------+-------------------------+--------------------------------------------|
| C-M-y     |                         | (查找状态)将光标处字符复制到查找区域最后   |
|-----------+-------------------------+--------------------------------------------|
| C-f       |                         | (查找状态)将光标处字符复制到查找区域最后   |
|-----------+-------------------------+--------------------------------------------|
| C-s RET   | search-forward          | 向前进行简单查找                           |
|-----------+-------------------------+--------------------------------------------|
| C-r RET   | search-backward         | 向后进行简单查找                           |
|-----------+-------------------------+--------------------------------------------|
| M-s w     | isearch-forward-word    | 向前进行词组查找                           |
|-----------+-------------------------+--------------------------------------------|
| M-s w RET | word-search-forward     | 向前进行词组查找（非增量方式）             |
|-----------+-------------------------+--------------------------------------------|
| M-s w C-r | word-search-backward    | 向后进行词组查找（非增量方式）             |
| RET       |                         |                                            |
|-----------+-------------------------+--------------------------------------------|
| C-M-s     | isearch-forward-regexp  | 向前进行正则查找                   |
|-----------+-------------------------+--------------------------------------------|
| C-M-r     | isearch-backward-regexp | 向后进行正则查找                           |
|-----------+-------------------------+--------------------------------------------|
|           | replace-string          | 全文替换                                   |
|-----------+-------------------------+--------------------------------------------|
|           | replace-regexp          | 全文正则替换                               |
|-----------+-------------------------+--------------------------------------------|
| M-%       | query-replace           | 查找替换                                   |
|-----------+-------------------------+--------------------------------------------|
|           | recursive-edit          | 进入递归编辑                               |
|-----------+-------------------------+--------------------------------------------|
|           | abort-recursive-edit    | 退出递归编辑                               |
|-----------+-------------------------+--------------------------------------------|
|           | top-level               | 退出递归编辑                               |
|-----------+-------------------------+--------------------------------------------|

**** 复制与粘贴
|---------------+-------------------------+----------------------------------------------|
| 按键          | 命令                    | 作用                                         |
|---------------+-------------------------+----------------------------------------------|
| C-d           | delete-char             | 删除光标处字符                               |
|---------------+-------------------------+----------------------------------------------|
| Backspace     | delete-backward-char    | 删除光标前字符                               |
|---------------+-------------------------+----------------------------------------------|
| M-\           | delete-horizontal-space | 删除光标处的所有空格和Tab字符                |
|---------------+-------------------------+----------------------------------------------|
| M-SPC         | just-one-space          | 删除光标处的所有空格和Tab字符，但留下一个    |
|---------------+-------------------------+----------------------------------------------|
| C-x C-o       | delete-blank-lines      | 删除光标周围的空白行，保留当前行             |
|---------------+-------------------------+----------------------------------------------|
| M-^           | delete-indentation      | 将两行合为一行，删除之间的空白和缩进         |
|---------------+-------------------------+----------------------------------------------|
| C-k           | kill-line               | 从光标处起删除该行                           |
|---------------+-------------------------+----------------------------------------------|
| C-S-Backspace | kill-whole-line         | 删除整行                                     |
|---------------+-------------------------+----------------------------------------------|
| C-w           | kill-region             | 删除区域                                     |
|---------------+-------------------------+----------------------------------------------|
| M-w           | kill-ring-save          | 复制到kill 环，而不删除                      |
|---------------+-------------------------+----------------------------------------------|
| M-d           | kill-word               | 删除光标起一个单词                           |
|---------------+-------------------------+----------------------------------------------|
| M-Backspace   | backward-kill-word      | 删除光标前单词                               |
|---------------+-------------------------+----------------------------------------------|
| M-k           | kill-sentence           | 删除光标起一句                               |
|---------------+-------------------------+----------------------------------------------|
| C-x Backspace | backward-kill-sentence  | 删除光标前删一句                             |
|---------------+-------------------------+----------------------------------------------|
| M-z char      | zap-to-char             | 删至字符char为止                             |
|---------------+-------------------------+----------------------------------------------|
| C-y           | yank                    | 召回                                         |
|---------------+-------------------------+----------------------------------------------|
| M-y           | yank-pop                | 召回前一个                                   |
|---------------+-------------------------+----------------------------------------------|
| C-M-w         | append-next-kill        | 下一个删掉内容和上次删除合并                 |
|---------------+-------------------------+----------------------------------------------|
| C-h v         | describe-variable       | 显示变量内容                                 |
|---------------+-------------------------+----------------------------------------------|
| (none)        | append-to-buffer        | 将区域中内容加入到一个buffer中               |
|---------------+-------------------------+----------------------------------------------|
| (none)        | prepend-to-buffer       | 将区域中内容加入到一个buffer光标前           |
|---------------+-------------------------+----------------------------------------------|
| (none)        | copy-to-buffer          | 区域中内容加入到一个buffer中，删除该buffer原 |
|               |                         | 有内容                                       |
|---------------+-------------------------+----------------------------------------------|
| (none)        | insert-buffer           | 在该位置插入指定的buffer中所有内容           |
|---------------+-------------------------+----------------------------------------------|
| (none)        | append-to-file          | 将区域中内容复制到一个文件中                 |
|---------------+-------------------------+----------------------------------------------|
| (none)        | cua-mode                | 启用/停用CUA绑定                             |
|---------------+-------------------------+----------------------------------------------|

|-------------------+-----------------------------|
| 变量              | 作用                        |
|-------------------+-----------------------------|
| kill-read-only-ok | 是否在只读文件启用kill 命令 |
|-------------------+-----------------------------|
| kill-ring         | kill环                      |
|-------------------+-----------------------------|
| kill-ring-max     | kill环容量                  |
|-------------------+-----------------------------|

**** 标记
|---------+-------------------------+----------------------|
| 按键    | 命令                    | 作用                 |
|---------+-------------------------+----------------------|
| C-@     | set-mark-command        | 设定标记             |
|---------+-------------------------+----------------------|
| C-x C-x | exchange-point-and-mark | 交换标记和光标位置   |
|---------+-------------------------+----------------------|
| C-w     | kill-region             | 删除区域中内容       |
|---------+-------------------------+----------------------|
| C-x C-u | upcase-region           | 将区域中字母改为大写 |
|---------+-------------------------+----------------------|
| C-x h   | mark-whole-buffer       | 全选                 |
|---------+-------------------------+----------------------|
| C-x C-p | mark-page               | 选取一页             |
|---------+-------------------------+----------------------|
| M-h     | mark-paragraph          | 选取一段             |
|---------+-------------------------+----------------------|
| M-@     | mark-word               | 选取一个单词         |
|---------+-------------------------+----------------------|
| C-@ C-@ |                         | 加入点到标记环       |
|---------+-------------------------+----------------------|
| C-u C-@ |                         | 在标记环中跳跃       |
|---------+-------------------------+----------------------|
| C-x C-@ | pop-global-mark         | 在全局标记环中跳跃   |
|---------+-------------------------+----------------------|
| (none)  | transient-mark-mode     | 非持久化标记模式     |
|---------+-------------------------+----------------------|

|-----------------------------+------------------------|
| 变量                        | 作用                   |
|-----------------------------+------------------------|
| set-mark-command-repeat-pop | 是否使用C-@连续跳跃    |
|-----------------------------+------------------------|
| mark-ring-max               | 标记环最大容量         |
|-----------------------------+------------------------|
| mark-even-if-nonactive      | 是否只使用激活状态标记 |
|-----------------------------+------------------------|

**** 书签
|---------------------+---------------+--------------|
| C-x r m             | bookmark-set  | 设置书签     |
| C-x r b             | bookmark-jump | 跳转到书签   |
| C-x r l             | bookmark-list | 列出所有书签 |
| M-x bookmark-delete |               | 删除书签     |
|         | bookmark-save        | 将书签保存到书签文件中 |
|---------------------+---------------+--------------|

书签列表操作
|-----+--------------|
| d   | 标记删除     |
| u   | 取消删除标记 |
| x   | 执行删除     |
| r   | 重命名       |
| q   | 关闭列表     |
| o   |              |
| C-o |              |
| m   |              |
| u   |              |
| v   |              |
| s   |              |
|-----+--------------|

**** 帮助
|----------+--------------------------+-----------------------------------------------------|
| C-h ?    |                          | 关于帮助系统的帮助，可以通过SPC和DEL键滚动，ESC推出 |
| C-h t    | M-x help-with-tutorial   | 进入《Emacs快速指南》                               |
| C-h r    | M-x info-emacs-manual    | Emacs使用手册                                       |
| C-h i    | M-x info                 | 《Emacs说明》                                       |
| C-h a    | M-x apropos-command      | 搜索命令                                            |
| C-h v    | M-x describe-variable    | 查看变量说明                                        |
| C-h f    | M-x describe-function    | 查看函数说明                                        |
| C-h m    | M-x describe-mode        | 查看当前mode的相关文档，包含mode中的命令、快捷键等  |
| C-h k    | M-x describe-key KYES    | 查看快捷键对应的命令及简要说明                      |
| C-h c    | M-x describe-key-briefly | 查看绑定说明                                        |
| C-h w    | M-x where-is             | 查看某个命令对应的快捷键                            |
| C-h b    | M-x describe-bindings    | 查看当前buffer中的所有的快捷键列表                  |
| KEYS C-c |                          | 查看当前buffer中以某个快捷键序列开头的快捷键列表    |
|          | M-x appropos             | 查看匹配某个关键字的任何东西，如函数，变量，命令，模式等                        |
|----------+--------------------------+---------------------------------------------------------------------------------|

**** 矩形操作
|-----------+----------------------------+-----------------------|
| C-x r c   | clear-rectangle            | 清空一个矩形块,以空格 |
| C-x r d   | delete-rectangle           | 删除一个矩形块,以空白 |
| C-x r k   | kill-rectangle             | 剪切一个矩形块        |
| C-x r r   | copy-rectangle-to register | 复制矩形块到寄存器    |
| C-x r i   | insert-register            |                       |
| C-x r g   | insert-register            |                       |
| C-x r y   | yank-rectangle             | 粘贴一个矩形块        |
| C-x r o   | open-rectangle             | 插入一个矩形块        |
| C-x r t   | string-rectangle           | string-rectangle      |
| C-x r M-w | copy-rectangle-as-kill     |                       |
|-----------+----------------------------+-----------------------|

**** 寄存器
\begin{itemize}
\item \textbf{window and frame configuration}

  \begin{tabular}{l|l|l}
    \hline
    Key & Binding & Comment \\
    \hline
    C-x r w REG & window-configuration-to-register & save configure of the current frame \\
    C-x r f REG & frame-configuration-to-register & save the state of all frams \\
    C-x r j REG & jump-to-register & jump to a register REG\\
    \hline
  \end{tabular}

\item \textbf{save text}

  \begin{tabular}{l|l|l}
    \hline
    Key & Binding & Comment \\
    \hline
    C-x r s REG & copy-to-register & Copy region into register REG \\
    C-x r i REG & insert-register & insert text from register REG \\
    \hline
  \end{tabular}

\item \textbf{rectangle}

  \begin{tabular}{l|l|l}
    \hline
    Key & Binding & Comment \\
    C-x r r REG & copy-rectangke-to-register & copy the region-rectangle\\
    \hline
  \end{tabular}

\item \textbf{position}

    \begin{tabular}{l|l|l}
    \hline
    C-x r SPC REG & point-to-register & record the position fo the point\\
                  && and the current buffer \\
    C-x r j REG & jump-to-register & jump to the position and buffer \\
                  && if the buffer is killed, revisit the file and open the buffer\\
    \hline
    \end{tabular}

  \item \textbf{number}
\end{itemize}
**** 大小写转换
|---------------------------------------------+----------------------|
| 从光标位置开始，处理单词后半部分            |                      |
|---------------------------------------------+----------------------|
| capitalize-word (M-c)                       | 单词首字母转为大写   |
| upcase-word (M-u)                           | 整个单词转为大写     |
| downcase-word (M-l)                         | 整个单词转为小写     |
|---------------------------------------------+----------------------|
| 从光标位置开始，处理单词前半部分            |                      |
|---------------------------------------------+----------------------|
| negtive-argument; capitalize-word (M-- M-c) | 单词首字母转为大写   |
| negtive-argument; upcase-word (M-- M-u)     | 整个单词转为大写     |
| negtive-argument; downcase-word (M-- M-l)   | 整个单词转为小写     |
|---------------------------------------------+----------------------|
| 改变选定区域的大小写                        |                      |
|---------------------------------------------+----------------------|
| downcase-region (C-x C-l)                   | 选定区域全部改为小写 |
| upcase-region (C-x C-u)                     | 选定区域全部改为大写 |
|---------------------------------------------+----------------------|
**** 宏
|-------------+-----------------------|
| f3 or C-x ( | Start recording macro |
| f4 or C-x ) | Stop recording macro  |
| C-x e or f4 | Playback macro        |
|-------------+-----------------------|

|-------------+------------------------------------------------------|
| C-x C-k C-k | Command: kmacro-end-or-call-macro-repeat             |
|             | Execute the keyboard macro at the head of the ring   |
|-------------+------------------------------------------------------|
| C-x C-k C-n | Command: kmacro-cycle-ring-next                      |
|             | Rotate the keyboard macro ring to the next macro     |
|             | (defined earlier).                                   |
|-------------+------------------------------------------------------|
| C-x C-k C-p | Command: kmacro-cycle-ring-previous                  |
|             | Rotate the keyboard macro ring to the previous macro |
|             | (defined later)                                      |
|-------------+------------------------------------------------------|

|-----------+-------------------------------------------------------------|
| C-x C-k n | Command: kmacro-name-last-macr                              |
|           | Give a command name (for the duration of the Emacs session) |
|           | to themost recently defined keyboard macro.                 |
|-----------+-------------------------------------------------------------|
| C-x C-k b | Command: kmacro-bind-to-key                                 |
|           | Bind the most recently defined keyboard macro to a key      |
|           | sequence                                                    |
|-----------+-------------------------------------------------------------|

**** narrowing
|---------+------------------+--------------------------------------------------|
| C-x n n | narrow-to-region | Narrow down to between point and mark            |
| C-x n w | widen            | Widen to make the entire buffer accessible again |
| C-x n p | narrow-to-page   | Narrow down to the current page                  |
| C-x n d | narrow-to-defun  | Narrow down to the current defun                 |
|---------+------------------+--------------------------------------------------|
*** TOOLs
**** git
***** 基本使用
|-------------+-----------------------|
| C-x g c RET | git-commit-all        |
| C-x g c a   | git-commit-all        |
| C-x g c f   | git-commit-file       |
| C-x g c i   | git-commit            |
|-------------+-----------------------|
| C-x g s     | git-status            |
| C-x g a     | git-add               |
| C-x g l     | git-log               |
| C-x g b     | git-branch            |
|             | git-history           |
|-------------+-----------------------|
| C-x g C-l   | git-log-other         |
| C-x g .     | git-cmd               |
| C-x g D     | git--diff-all-map     |
| C-x g L     | git-log-files         |
| C-x g R     | git-reset             |
| C-x g c     | git--commit-map       |
| C-x g d     | git--diff-buffer-map  |
| C-x g g     | git-grep              |
| C-x g h     | git-stash             |
| C-x g i     | git-add-interactively |
| C-x g m     | git-merge-next-action |
|-------------+-----------------------|
| C-x g D RET | git-diff-all-head     |
| C-x g D b   | git-diff-all-baseline |
| C-x g D h   | git-diff-all-head     |
| C-x g D i   | git-diff-all-index    |
| C-x g D o   | git-diff-all-other    |
| C-x g d RET | git-diff-head         |
| C-x g d b   | git-diff-baseline     |
| C-x g d h   | git-diff-head         |
| C-x g d i   | git-diff-index        |
| C-x g d o   | git-diff-other        |
|-------------+-----------------------|

***** git-status
|---------+------------------------------------------|
| p/n     | 在所有文件之间上下移动                   |
| P/N     | 在变更过的文件之间上下移动               |
| </>     | 定位到列表的头部/尾部                    |
| v       | 以只读方式打开文件                       |
| m/u/SPC | 设置/取消/切换标记，标记用于批量处理文件 |
| a       | 将文件加入版本控制                       |
| i       | 将文件加入ignore                         |
| c       | 提交                                     |
|---------+------------------------------------------|

***** 提交

|----------+------|
| C-c C-c  | 提交 |
| C-c C-q  | 取消 |
|----------+------|

***** 标签和分支
M-x git-branch：列出所有分支,在这里可以通过快捷键c/d/RET实现创建/删除/切换分
支。

M-x git-tag可以创建一个标签，以后在git-checkout时可以指定标签的名字，也可以
通过git-checkout-to-new-branch来基于tag创建分支。

**** w3m
|----------+---------------------------------------------------------------|
| q        | 关闭窗口                                                      |
| Q        | 直接离开                                                      |
| C-x-k    | 关闭当前标签页                                                |
| U        | 打开 URL                                                      |
| G        | 在标签页中打开一个网址                                        |
| S        | 用google进行搜索                                              |
| B        | 后退                                                          |
| N        | 前进                                                          |
| H        | 主页                                                          |
| R        | 刷新                                                          |
| C-n      | 下一行                                                        |
| C-p      | 向上一行                                                      |
| C-b      | 向后                                                          |
| C-f      | 向前                                                          |
| C-v      | 向下滚屏                                                      |
| ESC v    | 向上滚屏                                                      |
| 打开链接 | RET                                                           |
| >        | 向右滚屏                                                      |
| <        | 向左滚屏                                                      |
| ,        | 向左移动一格                                                  |
| .        | 向右移动一格                                                  |
| R        | Reload the current page                                       |
| C-t  R   | Reload all the pages                                          |
| r        | Redisplay the current page                                    |
| TAB      | Move to the new anchor                                        |
| C-M-i    | Move to the previous anchor                                   |
| B        | move  back to the previous page in the history                |
| N        | move forward to the next page in the history                  |
| s        | display the history in the session                            |
|          | with the prefic arg, it displays the arrived URLS             |
|----------+---------------------------------------------------------------|
| M-d      | down th url                                                   |
| d        | down load the url under point                                 |
|----------+---------------------------------------------------------------|
| u        | display the url under the point and put it into kill-ring     |
| c        | display the url of the current page and put it into kill-ring |
|----------+---------------------------------------------------------------|
| t        | toggle the visibility of an image under point                 |
| T        | toggle the visibility of all images                           |
| I        | display the image under point in the external viewer          |
| M-i      | save the image under point to a file                          |
| M-左方括号   | zoom in an image on the point                                 |
| M-右方括号   | zoom out an image on the point                                |
|----------+---------------------------------------------------------------|
| \        | display the html source of the current page                   |
| a        | 添加当前页到书签                                              |
| M-a      | add the urls under point to the bookmark                      |
| ESC a    | 添加该URL到书签                                               |
| v        | 显示书签                                                      |
| E        | 编辑书签                                                      |
| C-k      | 删除书签                                                      |
| C-_      | 撤消书签                                                      |
| M        | 用外部浏览器打开当前页面                                      |
| ESC M    | 用外部浏览器打开链接                                          |
|----------+---------------------------------------------------------------|
| C-c C-k  | 停止载入                                                      |
|----------+---------------------------------------------------------------|


|-------------+-------------------------------+--------------|
| Key-binding | Function                      | 备注         |
|-------------+-------------------------------+--------------|
| SPC,C-v     | Forward page                  | 前页         |
| b,ESC v     | Backward page                 | 后页         |
| l,C-f       | Cursor right                  | 光标右移     |
| h,C-b       | Cursor left                   | 光标左移     |
| j,C-n       | Cursor down                   | 光标下移     |
| k,C-p       | Cursor up                     | 光标上移     |
| J           | Roll up one line              | 向上滚屏一行 |
| K           | Roll down one line            | 向下滚屏一行 |
| ^,C-a       | Go to the beginning of line   | 跳转至行首   |
| $,C-e       | Go to the end of line         | 跳转至行尾   |
| w           | Go to next word               | 后一个单词   |
| W           | Go to previous word           | 前一个单词   |
| >           | Shift screen right            | 向右滚屏     |
| <           | Shift screen left             | 向左滚屏     |
| .           | Shift screen one column right | 向右滚屏一列 |
| ,           | Shift screen one column left  | 向左滚屏一列 |
| g,M-<       | Go to the first line          | 跳转至首行   |
| G,M->       | Go to the last line           | 跳转至尾行   |
| ESC g       | Go to specified line          | 跳转至指定行 |
| Z           | Move to the center line       |              |
| z           | Move to the center column     |              |
| TAB         | Move to next hyperlink        |              |
| C-u,ESC TAB | Move to previous hyperlink    |              |
| 左方括号        | Move to the first hyperlink   |              |
| 右方括号        | Move to the last hyperlink    |              |
|-------------+-------------------------------+--------------|


|---------------------------+-------------------------------------------------------------------------+---|
| RET                       | Follow hyperlink                                                        |   |
| a, ESC RET                | Save link to file                                                       |   |
| u                         | Peek link URL                                                           |   |
| i                         | Peek image URL                                                          |   |
| I                         | View inline image                                                       |   |
| ESC I                     | Save inline image to file                                               |   |
| :                         | Mark URL-like strings as anchors                                        |   |
| ESC :                     | Mark Message-ID-like strings as news anchors                            |   |
| c                         | Peek current URL                                                        |   |
| =                         | Display information about current document                              |   |
| C-g                       | Show current line number                                                |   |
| C-h                       | View history of URL                                                     |   |
| F                         | Render frame                                                            |   |
| M                         | Browse current document using external browser (use 2M and 3M to invoke |   |
| second and third browser) |                                                                         |   |
| ESC M                     | Browse link using external browser (use 2ESC M and 3ESC M to invoke     |   |
|                           | second and third browser)                                               |   |
|---------------------------+-------------------------------------------------------------------------+---|

|---+----------------------------------|
| U | Open URL                         |
| V | View new file                    |
| @ | Execute shell command and load   |
| # | Execute shell command and browse |
|---+----------------------------------|

|-------+-----------------------------|
| B     | Back to the previous buffer |
| v     | View HTML source            |
| s     | Select buffer               |
| E     | Edit buffer source          |
| C-l   | Redraw screen               |
| R     | Reload buffer               |
| S     | Save buffer                 |
| ESC s | Save source                 |
| ESC e | Edit buffer image           |
|-------+-----------------------------|
**** tetria
  |---------+--------------------|
  | key     | binding            |
  |---------+--------------------|
  | SPC     | tetris-move-bottom |
  | n       | tetris-start-game  |
  | p       | tetris-pause-game  |
  | q       | tetris-end-game    |
  | <down>  | tetris-rotate-next |
  | <left>  | tetris-move-left   |
  | <right> | tetris-move-right  |
  | <up>    | tetris-rotate-prev |
  |---------+--------------------|
**** shell command
|---------+---------------------|
| M-!     | shell-command       |
| M-&     | async-shell-command |
| M-\vert | shell-command-on-region |
|---------+-------------------------|
**** mew
***** M-x mew
|-------------+---------------------------------------------------------|
| w           | 撰写新邮件                                              |
| a           | 回复邮件，不带引用                                      |
| A           | 回复邮件，带引用                                        |
| f           | 转发邮件                                                |
| E           | 重新编辑邮件                                            |
| r           | 重新发送邮件                                            |
| SPC         | 阅读邮件                                                |
| y           | 保存邮件（可以保存信件全文、信件正文、附件）            |
| C-c C-l     | 转换当前邮件的编码格式                                  |
| C-c C-a     | 加入地址薄                                              |
| C-u C-c C-a | 比 C-c C-a 多加入昵称和名字                             |
| i           | 收信                                                    |
| g           | 跳转邮箱                                                |
| o           | 对邮件进行分类                                          |
| M-o         | 对所有邮件按照设定的规则进行分类                        |
| d           | 把邮件标记为删除                                        |
| *           | 做星号标记                                              |
| m/          | 列出所有有星号标记的邮件                                |
| u           | 清除标记                                                |
| U           | 清除所有带有指定标记的标记                              |
| x           | 对所有标记进行处理(比如标记为D的邮件将真正被删除)       |
| ENTER       | 让阅读的邮件向下滚动一行                                |
| -           | 向上滚动一行                                            |
| n           | 下一封邮件                                              |
| p           | 前一封邮件                                              |
| j           | 跳到某一封邮件                                          |
| N           | 下一封带星号的邮件                                      |
| P           | 上一封带星号的邮件                                      |
| S           | 按某个指定项目对邮件排序                                |
| /           | 按指定条件搜索邮件，并进入虚拟模式                      |
| tt          | 进入虚拟模式，根据线索查看，普通模式下是不可以的        |
| v           | 切换"Summary mode only" 和 "Summary & Message mode"模式 |
| C-c C-m     | 编辑新邮件，放入草稿中                                  |
| Z           | 更新地址簿                                              |
|-------------+---------------------------------------------------------|

***** draft: M-x mew-send
***** 其它
|-----+-----------------------------------|
| C   | 如果设置了多个邮箱，用 C 命令切换 |
| Q   | 退出Mew                           |
|-----+-----------------------------------|
**** pdf-tools
***** pdf-view-mode
|--------+-----------------------------------------|
| RET    | image-next-line                         |
| ESC    | Prefix Command                          |
| SPC    | pdf-view-scroll-up-or-next-page         |
| +      | pdf-view-enlarge                        |
| -      | pdf-view-shrink                         |
| 0      | pdf-view-scale-reset                    |
| 1 .. 9 | digit-argument                          |
| <      | beginning-of-buffer                     |
| =      | pdf-view-enlarge                        |
| >      | end-of-buffer                           |
| ?      | describe-mode                           |
| H      | pdf-view-fit-height-to-window           |
| P      | pdf-view-fit-page-to-window             |
| Q      | kill-this-buffer                        |
| W      | pdf-view-fit-width-to-window            |
| g      | revert-buffer                           |
| h      | describe-mode                           |
| n      | pdf-view-next-page-command              |
| p      | pdf-view-previous-page-command          |
| q      | quit-window                             |
| r      | revert-buffer                           |
|--------+-----------------------------------------|

|------------------------+-----------------------------------------|
| s                      | Prefix Command                          |
| DEL                    | pdf-view-scroll-down-or-previous-page   |
| S-SPC                  | pdf-view-scroll-down-or-previous-page   |
| C-c C-c                | doc-view-mode                           |
| C-c C-d                | pdf-view-dark-minor-mode                |
|------------------------+-----------------------------------------|
| s b                    | pdf-view-set-slice-from-bounding-box    |
| s m                    | pdf-view-set-slice-using-mouse          |
| s r                    | pdf-view-reset-slice                    |
|------------------------+-----------------------------------------|
| M-<                    | pdf-view-first-page                     |
| M->                    | pdf-view-last-page                      |
|------------------------+-----------------------------------------|

***** pdf-annot-minor-mode
|-----------+-------------------------------|
| C-c C-a D | pdf-annot-delete              |
| C-c C-a a | pdf-annot-attachment-dired    |
| C-c C-a l | pdf-annot-list-annotations    |
| C-c C-a t | pdf-annot-add-text-annotation |
|-----------+-------------------------------|

***** pdf-history-minor-mode
|---+----------------------|
| B | pdf-history-backward |
| N | pdf-history-forward  |
|---+----------------------|

***** pdf-links-minor-mode
|---+--------------------------|
| F | pdf-links-action-perform |
| f | pdf-links-isearch-link   |
|---+--------------------------|
***** pdf-misc-context-menu-minor-mode
|----------------+-----------------------------|
| <down-mouse-3> | pdf-misc-popup-context-menu |
|----------------+-----------------------------|
***** pdf-outline-minor-mode

|---+---+-------------|
| o |   | pdf-outline |
|---+---+-------------|
**** 计算器
+ 命令  M-x quick-calc
+ 快捷键  C-x * q
+ MiniBuffer中显示
+ C-g  退出Quick Calculator模式。


|---------+----------------|
| C-x * c | M-x calc       |
| C-x * q | M-x quick-calc |
|---------+----------------|
**** ibuffer
|-------------+-----------------------------------------------|
| M-x ibuffer | 打开ibuffer                                   |
|             | 注:C-x C-b和C-x b被绑定到helm功能             |
| q           | 关闭ibuffer                                   |
|-------------+-----------------------------------------------|
| / m         | 根据模式筛选                                  |
| / /         | 去除筛选条件                                  |
| / g         |                                               |
| / n         | 根据buffer名称筛选                            |
| / c         | 根据内容筛选                                  |
| / f         | 根据文件名筛选                                |
| / >         | 根据buffer大小筛选                            |
| / <         | 根据buffer大小筛选                            |
|-------------+-----------------------------------------------|
| ,           | 在排序方法中循环切换                                    |
| s i         | 倒序                                          |
| s a         | 根据名称排序                                  |
| s f         | 根据文件名排序                                |
| s v         | 根据最后浏览时间排序                          |
| s s         | 根据大小排序                                  |
| s m         | 根据模式排序                                  |
|-------------+-----------------------------------------------|
| o           | 在其它窗口打开当前buffer,并将光标切换到该窗口 |
| C-o         | 在其它窗口打开当前buffer,光标停留在当前窗口   |
| g           | 更新ibuffer                                   |
| m           | 标记当前buffer                                |
| u           | 取消标记                                      |
| A           | 打开标记buffer或当前buffer                    |
| S           | 保存buffer                                    |
| D           | 关闭buffer                                    |
| V           | 放弃buffer的更改                              |
|-------------+-----------------------------------------------|
**** Dired-mode
***** Mark & Flag
|---------------------------------+----------------------------------------|
| d                               | 标记删除                               |
| x                               | 执行删除                               |
| C-u d                           | 去掉标记                               |
| #                               | 标记所有自动保存的文件,e.g. #demo.org# |
| ~                               | 标记所有备份文件(即文件名以~结尾)      |
| &                               | 标记垃圾文件                           |
| dired-garbage-files-regexp      | 查看垃圾文件                           |
|---------------------------------+----------------------------------------|
| **                              | 标记所有可执行文件                     |
| *@                              | 标记所有符号链接                       |
| */                              | 标记所有目录文件,不包括.和..           |
| *s                              | 标记所有文件,不包括.和..               |
| *.                              | 标记具有扩展名的文件                   |
| %m REGEXP RET OR  *% REGEXP RET | 标记正则表达式匹配文件                 |
| %g REGEXP RET                   | 标记文件内容匹配正则表达式的文件       |
|---------------------------------+----------------------------------------|
| u                               | 去除当前行的标记                       |
| DEL                             | 上移一行并去除该行的标记               |
| U                               | 去除所有标记                           |
| *? MARKCHAR                     | 去除所有以MARKCHAR标记的文件           |
| t                               | 交换标记                               |
| M-( OR * OR )                   | 使用断言                               |
|---------------------------------+----------------------------------------|
***** 常用操作
|---------------+------------------------|
| *C(不用加*号) | 拷贝文件               |
| *D            | 删除文件               |
| *R            | 重命名文件             |
| *H            | 创建硬链接             |
| *S            | 创建符号链接           |
| *M            | 修改权限               |
| *G            | 修改属组               |
| *O            | 修改属主               |
| *T            | 修改时间               |
| *P            | 打印                   |
| *Z            | 压缩或解压             |
| *L            | 加载Elisp文件          |
| *B            | 字节编译Elisp文件      |
| *A            | 正则表达式搜索         |
| *Q            | 对文件内容进行交互替换 |
|---------------+------------------------|

***** shell命令
|---+---------------|
| ！ | 执行shell命令 |
|---+---------------|
***** 强大的重命名
*wdired-change-to-wdired-mode* 进入编辑模式
*wdired-allow-to-change-permissions* 设为t可编辑权限

*** org
**** 基本
***** 视图循环
|-------+----------------------------------------------------------|
| TAB   | 子树循环，在FOLDED-CHILDREN-SUBTREE之间循环，C-u使用前缀 |
|-------+----------------------------------------------------------|
| S-TAB | 全局循环                                                 |
|-------+----------------------------------------------------------|

***** 移动
|---------+--------------|
| C-c C-n | 下个标题     |
|---------+--------------|
| C-c C-p | 上个标题     |
|---------+--------------|
| C-c C-f | 下个同级标题 |
|---------+--------------|
| C-c C-b | 上个同级标题 |
|---------+--------------|
| C-c C-u | 回到上层标题 |
|---------+--------------|
***** 结构编辑
|----------------+----------------------------------------------|
| M-TAB          | 插入一个同级标题                             |
|----------------+----------------------------------------------|
| M-S-TAB        | 插入一个和当前标题同级的TODO项               |
|----------------+----------------------------------------------|
| TAB            | 如果新的条目中还没有文字，则调整到合适的级别 |
|----------------+----------------------------------------------|
| M-LEFT/RIGHT   | 将当前标题提升/降低一个等级                  |
|----------------+----------------------------------------------|
| M-S-LEFT/RIGHT | 将当前子树提升/降低一个等级                  |
|----------------+----------------------------------------------|
| M-S-UP/DOWN    | 将当前子树上/下移                            |
|----------------+----------------------------------------------|
| C-c C-w        | 将条目或区域传送到另外一个文件中             |
|----------------+----------------------------------------------|
| C-c n s/w      | 将缓冲区试图局限到当前子树中/再次放宽视图    |
|----------------+----------------------------------------------|
***** 脚注
|-----------+------------------------------------------------------|
| C-c C-x f | 新建一个脚注，当有前缀时，会提供一个菜单以供选择操作 |
|           | 或者在定义和引用之间跳转                             |
|-----------+------------------------------------------------------|
| C-c C-c   | 在定义和引用之间跳转                                 |
|-----------+------------------------------------------------------|

***** 链接
[[link][]]
|---------+------------------------|
| C-c l   | 在当前位置保存一个链接 |
|---------+------------------------|
| C-c C-l | 插入一个链接           |
|---------+------------------------|
| C-c C-o | 打开光标处的链接       |
|---------+------------------------|

|-------+------------------------|
| C-c % | 记录内部链接地址       |
| C-c & | 跳转到已记录的内部链接 |
|-------+------------------------|

***** 标签
添加标签
|---------+--------------|
| C-c C-q | 正文部分使用 |
| C-c C-c | 在标题上使用 |
|---------+--------------|

搜索标签
|---------+----------------------------------------------|
| C-c \   | 按标签搜索标题                               |
| C-c / m | 搜索并按树状结构显示                         |
| C-c a m | 按标签搜索多个文件(需要将文件加入全局agenda) |
|---------+----------------------------------------------|
**** 表格
***** 创建和转换
C-c | *org-table-convert-region* 将活动区域转换为表格，以TAB，逗号或空白
符划分区域。

***** 调整和移动区域
|---------+----------------------------------------|
| C-c C-c | 调整表格，不移动光标                   |
|---------+----------------------------------------|
| TAB     | 将光标移动到下一个区域，必要时新建一行 |
|---------+----------------------------------------|
| S-TAB   | 将光标移动到上一个区域                 |
|---------+----------------------------------------|
| RET     | 将光标移动到下一行，必要时新建一行     |
|---------+----------------------------------------|
***** 编辑行和列
|--------------+------------------------------------------------------------------|
| M-LEFT/RIGHT | 左/右以当前列                                                    |
|--------------+------------------------------------------------------------------|
| M-S-LEFT     | 删除当前列                                                       |
|--------------+------------------------------------------------------------------|
| M-S-RIGHT    | 在光标位置左边添加一列                                           |
|--------------+------------------------------------------------------------------|
| M-UP/DOWN    | 上/下移动当前行                                                  |
|--------------+------------------------------------------------------------------|
| M-S-UP       | 删除当前行                                                       |
|--------------+------------------------------------------------------------------|
| M-S-DOWN     | 在当前行上面添加一行，如果有前缀，则在下面添加一行               |
|--------------+------------------------------------------------------------------|
| C-c -        | 在当前行下面添加一行一个水平线，如有前缀，则在上面添加一行水平线 |
|--------------+------------------------------------------------------------------|
| C-c ^        | 将表格排序，以当前位置所在的列作为依据                           |
|              | 排序在局当前位置最间的两个水平线之间的行（或者整个表）中进行     |
|--------------+------------------------------------------------------------------|
**** sort
|-------+----------|
| C-c ^ | org-sort |
|-------+----------|

**** w3m-copy
  |-------------+---------------------------|
  | C-c C-x C-w | org-w3m-copy-for-org-mode |
  |-------------+---------------------------|

**** refile
|-------------------------+---------+--------------------|
| org-refile              | C-c C-w | 同一文件中移动节点 |
| org-copy                | C-c M-w | 同形文件中复制节点 |
|-------------------------+---------+--------------------|

**** GTD
****** 任务
|---------+---------------|
| C-c C-t | org-todo      |
| S-LEFT  | org-shiftleft |
| S-RIGHT | org-shiftright |
|---------+----------------|
****** 优先级
|--------+---------------+---------------------------------------|
| S-UP   | org-shiftup   | increase priority of current headline |
| S-DOWN | org-shiftdown | decrease priority of current headline |
|--------+---------------+---------------------------------------|
****** 子任务
|---------+----------------|
| C-c C-c | 改变复选框状态 |
| M-S-RET | 增加一个子项   |
|---------+----------------|
****** 搜索
*C-c /            只列出包含搜索结果的大纲，并高亮，支持多种搜索方式*
****** 时间戳
|---------+-------------------------+---------------------------------------------------------------------|
| C-c .   | org-time-stamp          | Prompt for a date/time and insert a time stamp                      |
| C-c <   | org-date-from-calendar  | Insert time stamp corresponding to cursor date in *Calendar* buffer |
| C-c >   | org-goto-calendar       | Go to the Emacs calendar at the current date.                       |
| C-c !   | org-time-stamp-inactive | org-time-stamp-inactive                                             |
|---------+-------------------------+---------------------------------------------------------------------|
| S-UP    | org-shiftup             | Increase item in timestamp                                          |
| S-DOWN  | org-shiftdown           | Decrease item in timestamp                                          |
| S-LEFT  | org-shiftleft           |                                                                     |
| S-RIGHT | org-shifright           |                                                                     |
|---------+-------------------------+---------------------------------------------------------------------|

|---------------+------------------|
| 连续使用C-c . | 可以创建时间段   |
| C-c C-y       | 计算时间段的间隔 |
|---------------+------------------|

|---------+--------------+----------------------|
| C-c C-s | org-schedule | Insert the SCHEDULED |
| C-c C-d | org-deadline | Insert the DEADLINE  |
|---------+--------------+----------------------|
****** org-agenda
|-------+--------------------------+--------------------------------------------------------------|
| C-c [ | org-agenda-file-to-front | Move/add the current file to the top of the agenda file list |
| C-c ] | org-remove-file          | Remove current file from the org-agenda-files                |
|-------+--------------------------+--------------------------------------------------------------|
****** org-capture
|-----------+----------------------|
| C-c c     | org-capture          |
| C-c C-c   | org-capture-finalize |
| C-c C-w   | org-capture-refile   |
| C-c C-k   | org-capture-kill     |
|-----------+----------------------|

**** latex
|---------------------+-----------------------------------|
| C-c C-x C-l         | org-preview-latex-fragment        |
| C-c C-c             | remove overlay                    |
| C-u C-c C-x C-l     | preview everything in the subtree |
| C-u C-u C-c C-x C-l | preview everything in the buffer  |
|---------------------+-----------------------------------|

**** babel
   | C-c C-v t | org-babel-tangle      | tangle the current file |
   | C-c C-v f | org-babel-tangle-file | choose a file to tangle |

*** IDE
**** 基本操作

|-----------+--------------------+----------------------|
| C-M-f     | forward-sexp       | 前向匹配             |
| C-M-b     | backward-sexp      | 后向匹配             |
| C-M-k     | kill-sexp          | 删除匹配之间的区域   |
| C-M-SPC/@ | mark-sexp          | 选中匹配区域         |
| C-M-a     | beginning-of-defun | 将光标移至函数起始处 |
| C-M-e     | end-of-defun       | 将光标移至函数结尾处 |
| C-M-h     | mark-defun         | 选中函数定义         |
|-----------+--------------------+----------------------|

**** cedet

**** function-args

|-----+--------------|
| M-o | moo-complete |
| M-i | fa-show      |
| M-J | fa-jump      |
|-----+--------------|

**** gtags
+ C-c g a helm-gtags-tags-in-this-function
+ C-j helm-gtags-select
+ C-c g . helm-gtags-dwim
+ C-c g , helm-gtags-pop-stack
+ C-c g < helm-gtags-previous-history
+ C-c g > helm-gtags-next-history
+ C-c g f helm-gtags-find-files
+ C-c g s helm-gtags-find-symbol
+ C-c g r helm-gtags-find-reference
**** projectile
|-----------+---------------------------------------------+--------------------------------------------------------------|
| C-c p h   | helm-projectile                             | Helm interface to projectile                                 |
| C-c p p   | helm-projectile-switch-project              | Switches to another projectile project                       |
| C-c p f   | helm-projectile-find-file                   | Lists all files in a project                                 |
| C-c p F   | helm-projectile-find-file-in-known-projects | Find file in all known projects                              |
| C-c p g   | helm-projectile-find-file-dwim              | Find file based on context at point                          |
| C-c p d   | helm-projectile-find-dir                    | Lists available directories in current project               |
| C-c p e   | helm-projectile-recentf                     | Lists recently opened files in current project               |
| C-c p a   | helm-projectile-find-other-file             | Switch between files with same name but different extensions |
| C-c p i   | projectile-invalidate-cache                 | Invalidate cache                                             |
| C-c p z   | projectile-cache-current-file               | Add the file of current selected buffer to cache             |
| C-c p b   | helm-projectile-switch-to-buffer            | List all open buffers in current project                     |
| C-c p s g | helm-projectile-grep                        | Searches for symbol starting from project root               |
| C-c p s a | helm-projectile-ack                         | Same as above but using ack                                  |
| C-c p s s | helm-projectile-ag                          | Same as above but using ag                                   |
|-----------+---------------------------------------------+--------------------------------------------------------------|

**** senator
Senator: SEmatic NavigaTOR.
|---------+--------------------------|
| C-c n   | senator-next-tag         |
| C-c p   | senator-previous-tag     |
| C-c u   | senator-go-up-reference  |
| C-c g   | semantic-symref          |
| C-c M-w | senator-copy-tag         |
| C-c C-w | senator-kill-tag         |
| C-c C-y | senator-yank-tag         |
| C-c r   | senator-copy-to-register |
|         | senator-fold-code-toggle |
|---------+--------------------------|
**** sr-speedbar
   |---------+-------------------------------------------------------------------------------------------------|
   |         | sr-speedbar-open OR  sr-speedbar-toggle                                                         |
   | SPC     | open the children of a node.                                                                    |
   | RET     | open the node in another window.                                                                |
   |         | If node is a file  open that file;                                                              |
   |         | if node is a directory ,  enter that directory;                                                 |
   |         | if node is a tag in a file ,  jump to the location of that tag in the file.                     |
   | U       | go up parent directory.                                                                         |
   | n/p     | moves to next or previous node.                                                                 |
   | M-n/M-p | moves to next or previous node at the current level.                                            |
   | b       | switches to buffer list using Speedbar presentation. You can also open children of each buffer. |
   | f       | switches back to file list.                                                                     |
   |---------+-------------------------------------------------------------------------------------------------|
**** 代码折叠
|-------------+--------------------------------------------|
| C-c @ C-c   | Command: hs-toggle-hiding                  |
|             | Toggle hiding/showing of a block           |
|-------------+--------------------------------------------|
| C-c @ C-h   | Command: hs-hide-block                     |
|             | Select current block at point and hide it  |
|-------------+--------------------------------------------|
| C-c @ C-l   | Command: hs-hide-level                     |
|             | Hide all block with indentation levels     |
|             | below this block                           |
|-------------+--------------------------------------------|
| C-c @ C-s   | Command: hs-show-block                     |
|             | Select current block at point and show it. |
|-------------+--------------------------------------------|
| C-c @ C-M-h | Command: hs-hide-all                       |
|             | Hide all top level blocks, displaying      |
|             | only first and last lines.                 |
| C-c @ C-M-s | Command: hs-show-all                       |
|             | Show everything                            |
|-------------+--------------------------------------------|
**** narrowing
|---------+--------------------------------------------|
| C-x n d | Command: narrow-to-defun                   |
| C-x n r | Command: narrow-to-region                  |
| C-x n n | Narrow buffer to active region             |
| C-x n w | Command: widen                             |
|---------+--------------------------------------------|
**** compile
|------+-------------------------------------------------------------------|
| C-o  | Display matched location, but do not switch point to matched      |
|      | buffer                                                            |
|------+-------------------------------------------------------------------|
| M-n  | Move to next error message, but do not visit error location       |
|------+-------------------------------------------------------------------|
| M-p  | Move to next previous message, but do not visit error location    |
|------+-------------------------------------------------------------------|
| M-g  | Move to next error message, visit error location                  |
| n    |                                                                   |
|------+-------------------------------------------------------------------|
| M-g  | Move to previous error message, visit error location              |
| p    |                                                                   |
|------+-------------------------------------------------------------------|
| RET  | Visit location of error at poiint                                 |
|------+-------------------------------------------------------------------|
| M-{  | Move point to the next error message or match occurring in a      |
|      | different file                                                    |
|------+-------------------------------------------------------------------|
| M-}  | Move point to the previous error message or match occurring in a  |
|      | different file                                                    |
|------+-------------------------------------------------------------------|
| q    | Quit *compilation* buffer                                         |
|------+-------------------------------------------------------------------|
**** python
  \begin{tabular}{l|l}
    \hline
    C-c C-c & py-execute-buffer \\
    C-c | & py-execute-region \\
    C-c TAB & py-indent-region \\
    C-c ! & py-shell \\
    C-c C-v & py-version \\
    C-c C-k & py-mark-block-or-clause \\
    C-c C-e & py-help-at-point \\
    \hline
    C-M-a & py-begining-of-def-or-class\\
    C-M-d & py-down \\
    C-M-e & py-end-of-def-or-class \\
    C-M-h & py-mark-def-or-class \\
    C-M-i & completion-at-point \\
    C-M-u & py-up \\
    C-M-x & py-execute-def-or-class \\
    \hline
  \end{tabular}
**** octave
  \begin{tabular}{lll}
    \hline
    C-h a & octave-lookfor & octave搜索\\
    C-h d & octave-help & octave帮助\\
    C-c C-l & octave-source-file & sour文件 \\
    C-c ; & octave-update-function-file-comment & 更新函数文档 \\
    M+. & octave-find-definition & 查找定义 \\
    C-M-j & octave-indent-new-comment-line & 插入新的注释行\\
    C-M-q & prog-indent-sexp & 块缩进 \\
    C-c / OR ] & smie-indent-sexp & 闭合\\
    C-c TAB (C-)a & octave-send-buffer & 执行缓冲区\\
    C-c TAB (C-)r & octave-send-region & 执行区域\\
    C-c TAB (C-)l & octave-send-line & 执行行\\
    C-c TAB (C-)b & octave-send-block & 执行块\\
    C-c TAB (C-)f & octave-send-function & 执行函数\\
    C-c TAB (C-)k & octave-kill-process & 关闭当前程序\\
    C-c TAB (C-)s & octave-show-process-buffer & 显示程序进程缓冲区\\
    \hline
  \end{tabular}

*** LaTeX
    |-------------+------------------------+------------|
    | C-c C-s     | Entering sectioning    |            |
    | C-c C-e     | Inserting environment  |            |
    | C-c C-m     | Inserting macros       |            |
    | C-c RET     |                        |            |
    |-------------+------------------------+------------|
    | C-c C-f C-b | insert bold face text  | \textbf{*} |
    | C-c C-f C-i | insert italics text    | \textit{*} |
    | C-c C-f C-e | insert emphasized text | \emph{*}   |
    | C-c C-f C-s | insert slanted text    | \textsl{*} |
    | C-c C-f C-r | insert roman text      | \textrm{*} |
    | C-c C-f C-f | insert sans seriftext  | \textsf{*} |
    | C-c C-f C-t | insert typewriter text | \texttt{*} |
    | C-c C-f C-c | insert SMALL CAPS      | \textsc{*} |
    | C-c C-f C-d | ...                    |            |
    |-------------+------------------------+------------|
    | C-c ;       |                        |            |
    | C-c %       |                        |            |
    |-------------+------------------------+------------|
    | C-c C-c     |                        |            |
    |-------------+------------------------+------------|

C-c ],C-c \} latex-close-block

** Register                                                       :register:
*** 寄存器
#+BEGIN_SRC latex
Emacs \textbf{Register} is similar to CPU register in the sense that it allows quick access to temporal data. Each register has a name that consists of a \textbf{single} character, like 'a', 'A' and '1'.

In Emacs, registers are for quick access to things such as \textbf{a position}, \textbf{a piece of text},\textbf{a rectangle}, \textbf{a number}, \textbf{a file name} or \textbf{a window configure}.

Saving different types of objects has different key bindings, but to jump to a register, you use a single command \textbf{C-c r j REG\footnote{REG is the register of your choice}}

\textbf{Note}: The prefix for register command is \textbf{C-x r}.If you forget the key bindings,\textbf{C-x r C-h} to get the list of key bindings.

\begin{itemize}
\item \textbf{window and frame configuration}

  \begin{tabular}{l|l|l}
    \hline
    Key & Binding & Comment \\
    \hline
    C-x r w REG & window-configuration-to-register & save configure of the current frame \\
    C-x r f REG & frame-configuration-to-register & save the state of all frams \\
    C-x r j REG & jump-to-register & jump to a register REG\\
    \hline
  \end{tabular}

\item \textbf{save text}

  \begin{tabular}{l|l|l}
    \hline
    Key & Binding & Comment \\
    \hline
    C-x r s REG & copy-to-register & Copy region into register REG \\
    C-x r i REG & insert-register & insert text from register REG \\
    \hline
  \end{tabular}

\item \textbf{rectangle}

  \begin{tabular}{l|l|l}
    \hline
    Key & Binding & Comment \\
    C-x r r REG & copy-rectangke-to-register & copy the region-rectangle\\
    \hline
  \end{tabular}

\item \textbf{position}

    \begin{tabular}{l|l|l}
    \hline
    C-x r SPC REG & point-to-register & record the position fo the point\\
                  && and the current buffer \\
    C-x r j REG & jump-to-register & jump to the position and buffer \\
                  && if the buffer is killed, revisit the file and open the buffer\\
    \hline
    \end{tabular}

  \item \textbf{number}
\end{itemize}
#+END_SRC
*** prepend-to-register                                          :register:
(prepend-to-register register start end &optional delete-flag)

prepend region to text in register register.
with prefix arg, delete as well.
called from program, takes four args: register, start, end and delete-flag.
start and end are buffer positions indicating what to prepend.
** others
*** MS word
参考:
+ http://superuser.com/questions/116289/word-2007-files-on-emacs

**** antiword
Antiword is a free MS-Word reader for GNU/Linux, RISC OS, and DOS. It
converts the documents from Word 2, 6, 7, 97, 2000, 2002, and 2003 to
text, Postscript, and XML/DocBook. Antiword tries to keep the layout
of the document intact.

#+BEGIN_EXAMPLE
  (defun no-word ()
        "Run antiword on the entire buffer."
        (shell-command-on-region (point-min) (point-max) "antiword - " t t))
  (add-to-list 'auto-mode-alist '("\\.doc\\'" . no-word))
#+END_EXAMPLE

**** archive-mode
If you want to edit docx files, you can treat them as raw XML (docx
files are a ZIPped bundle of XML files), which can sometimes be
useful, but isn't acceptable for seriously engaing with the
content. This could, I think, in principle, be launched from
archive-mode.
**** docx2tex
Or you can convert them to Latex using docx2tex, which works pretty
well, but loses some formatting. docx2tex isn't packaged up by anyone,
and if you are on Linux, you'll need to install some pretty up-to-date
Mono libraries. Unfortunately, converting back again doesn't work so
well: there are a few fairly limited Latex to RTF converters around.

That's not really the same thing as an existing word-2007-mode, but
the steps could all be automated in Emacs.

*** Emacs Cask
+ http://cask.readthedocs.org/en/latest/
+ https://github.com/cask/cask

Cask 主要是用来维护 elisp project 的，给 Emacs 插件作者使用， 管理插件
的依赖关系。副作用是也可以拿来自动安装 Emacs 插件， 不用在 .emacs 写一
段了。

*** recover-this-file
(recover-this-file)

Recover the visited file--get contents from its last auto-save file. #file#

*** DONE org不使双下划线，一不需要，二与python常用冲突
- State "DONE"       from "TODO"       [2015-11-23 一 16:49] \\
  不可以
CLOCK: [2015-11-23 一 16:42]--[2015-11-23 一 16:49] =>  0:07
CLOCK: [2015-11-23 一 16:38]--[2015-11-23 一 16:42] =>  0:04

a_b
a_{b}
a^{b}
a^b
_ab_
__ab__

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  a\_b
  a$_{\text{b}}$
  a$^{\text{b}}$
  a\^{}b
  \uline{ab}
  \uline{\uline{ab}}
  \end{minted}
#+end_latex

1. org-export-with-emphasize
2. #+OPTIONS: *:nil
3. 问题是： 加粗为没有用了
4. +折衷办法: 仅在需要的地方设置 *#+OPTIONS: *:nil* （这是不行的）+
5. 那就没有办法的，强调是必须用的

* Modes                                                               :emacs:
** PDF                                                                 :pdf:
*** 使用Emacs阅览PDF文件
1. macro:pdf-layout: 目录+PDF
   (define-key pdf-view-mode-map "L" 'macro:pdf-layout)
2. 使用书签快速打开PDF，一般为手册或书籍
3. 使用org的链接功能保存PDF位置
   - C-c l org-store-link
   - C-c C-l org-insert-link
   - C-c C-o org-open-at-point(加前缀使用Emacs打开)
4. pdf-view-mode的功能
   - - 缩小
   - = 放大

*** pdf-tools

PDF是最常用的文件格式,而Emacs是用的最多的工具,自带的DOC-view对扫描版的
PDF的支持很不好.
参考:  [[help:PDF][PDF Tools Help]] (M-x pdf-tools-help)

/PDF tools 的标注在 FoxitReader中支持/


**** pdf-view-mode
|--------+-----------------------------------------|
| RET    | image-next-line                         |
| ESC    | Prefix Command                          |
| SPC    | pdf-view-scroll-up-or-next-page         |
| +      | pdf-view-enlarge                        |
| -      | pdf-view-shrink                         |
| 0      | pdf-view-scale-reset                    |
| 1 .. 9 | digit-argument                          |
| <      | beginning-of-buffer                     |
| =      | pdf-view-enlarge                        |
| >      | end-of-buffer                           |
| ?      | describe-mode                           |
| H      | pdf-view-fit-height-to-window           |
| P      | pdf-view-fit-page-to-window             |
| Q      | kill-this-buffer                        |
| W      | pdf-view-fit-width-to-window            |
| g      | revert-buffer                           |
| h      | describe-mode                           |
| n      | pdf-view-next-page-command              |
| p      | pdf-view-previous-page-command          |
| q      | quit-window                             |
| r      | revert-buffer                           |
|--------+-----------------------------------------|

|------------------------+-----------------------------------------|
| s                      | Prefix Command                          |
| DEL                    | pdf-view-scroll-down-or-previous-page   |
| S-SPC                  | pdf-view-scroll-down-or-previous-page   |
| C-c C-c                | doc-view-mode                           |
| C-c C-d                | pdf-view-dark-minor-mode                |
|------------------------+-----------------------------------------|
| s b                    | pdf-view-set-slice-from-bounding-box    |
| s m                    | pdf-view-set-slice-using-mouse          |
| s r                    | pdf-view-reset-slice                    |
|------------------------+-----------------------------------------|
| M-<                    | pdf-view-first-page                     |
| M->                    | pdf-view-last-page                      |
|------------------------+-----------------------------------------|

**** pdf-annot-minor-mode
`pdf-annot-minor-mode' is an interactive autoloaded compiled Lisp
function in `pdf-annot.el'.
|-----------+-------------------------------|
| C-c C-a D | pdf-annot-delete              |
| C-c C-a a | pdf-annot-attachment-dired    |
| C-c C-a l | pdf-annot-list-annotations    |
| C-c C-a t | pdf-annot-add-text-annotation |
|-----------+-------------------------------|

**** pdf-cache-prefetch-minor-mode
`pdf-cache-prefetch-minor-mode' is an interactive compiled Lisp
function in `pdf-cache.el'.

(pdf-cache-prefetch-minor-mode &optional ARG)

Try to load images which will probably be needed in a while.
**** pdf-history-minor-mode
|---+----------------------|
| B | pdf-history-backward |
| N | pdf-history-forward  |
|---+----------------------|

**** pdf-isearch-minor-mode
`pdf-isearch-minor-mode' is an interactive autoloaded compiled Lisp
function in `pdf-isearch.el'.

(pdf-isearch-minor-mode &optional ARG)

Isearch mode for PDF buffer.
**** pdf-links-minor-mode
`pdf-links-minor-mode' is an interactive autoloaded compiled Lisp
function in `pdf-links.el'.

(pdf-links-minor-mode &optional ARG)

Handle links in PDF documents.

|---+--------------------------|
| F | pdf-links-action-perform |
| f | pdf-links-isearch-link   |
|---+--------------------------|
**** pdf-misc-context-menu-minor-mode
`pdf-misc-context-menu-minor-mode' is an interactive autoloaded
compiled Lisp function in `pdf-misc.el'.

(pdf-misc-context-menu-minor-mode &optional ARG)

Provide a right-click context menu in PDF buffers.
|----------------+-----------------------------|
| <down-mouse-3> | pdf-misc-popup-context-menu |
|----------------+-----------------------------|
**** pdf-outline-minor-mode
`pdf-outline-minor-mode' is an interactive autoloaded compiled Lisp
function in `pdf-outline.el'.

(pdf-outline-minor-mode &optional ARG)

Display an outline of a PDF document.

This provides a PDF's outline on the menu bar via imenu.
Additionally the same outline may be viewed in a designated
buffer.
|---+---+-------------|
| o |   | pdf-outline |
|---+---+-------------|
**** pdf-view-auto-slice-minor-mode
`pdf-view-auto-slice-minor-mode' is an interactive compiled Lisp
function in `pdf-view.el'.

(pdf-view-auto-slice-minor-mode &optional ARG)

Automatically slice pages according to their bounding boxes.

*** DONE pdftools :pdf-view-goto-page
- State "DONE"       from ""           [2015-02-27 五 14:50]
[[help:Enabled][remap goto-page]]
#+BEGIN_EXAMPLE
  <remap> <goto-line>             pdf-view-goto-page
#+END_EXAMPLE

|-----------+-------|
| goto-line | M-g g |
|-----------+-------|

*** pdf-tools本身没有提供编辑大纲的功能
** Programming                                                 :programming:
*** make-mode
http://www.emacswiki.org/emacs/MakefileMode

make-mode

*** php-mode
+ EmacsWiki: http://www.emacswiki.org/emacs/PhpMode
+ Homepage: https://sourceforge.net/projects/php-mode/

*** nXhtml-mode
+ https://github.com/emacsmirror/nxhtml

(load "YOUR-PATH-TO/nxhtml/autostart.el")
**** nxml 关联特定类型文件
#+BEGIN_EXAMPLE
  (add-to-list 'auto-mode-alist '("\\.ui\\'" . nxml-mode))
  (add-to-list 'auto-mode-alist '("\\.qrc\\'" .nxml-mode))
#+END_EXAMPLE
*注: 正则表达式中的单引号.*

**** 快捷键

*C-c /* finishes the current element by inserting an end-tag.

*** asm-mode
+ http://www.emacswiki.org/emacs/AssemblyProgramming


1. AsmMode
2. GasMode

*** shell-script-mode

+ Emacs是自说明的。
+ 默认关联.sh文件, ~/.bashrc也是。
+ 语法高亮
+ 一些快捷输入

*** gnuplot-mode
#+BEGIN_SRC latex
\href{http://astro.berkeley.edu/~mkmcc/software/gnuplot-mode.html#content}{Emacs Gnuplot Mode}
\begin{enumerate}
\item Introduction\\
  Gnuplot is an extremely useful program.\\
  Features of gnuplot-mode in Emacs:\\
  \begin{itemize}
  \item offer syntax highlighting and basic indentation
  \item run directly a command to plot the file
  \item report errors in a standalone buffer
  \end{itemize}
  Key bindings:
  \begin{tabbing}
    C-c C-c\hspace{24pt} \= gnuplot-run-buffer\\
    C-c C-r \> gnuplot-plot-region\\
    C-c C-b \> send buffer fot Gnuplot\\
  \end{tabbing}
\item {Installation}
  Download the file or use MELPA.\\
  Settings:\\
\begin{verbatim}
;; make sure file is visible to emacs (if needed)
(add-to-list 'load-path "/path/to/your/lisp/files")
;; load the file
(require 'gnuplot-mode)
;; specify the gnuplot executable (if other than /usr/bin/gnuplot)
(setq gnuplot-program "/sw/bin/gnuplot")
;; automatically open files ending with .gp or .gnuplot in gnuplot mode
(setq auto-mode-alist
(append '(("\\.\\(gp\\|gnuplot\\)$" . gnuplot-mode)) auto-mode-alist))
\end{verbatim}
\end{enumerate}
#+END_SRC
*** Graphviz-dot-mode
#+BEGIN_SRC latex
\begin{enumerate}
\item Graphviz-dot-mode简介

  Graphviz-dot-mode is an emacs mode for the \textbf{DOT} language used
  by \textbf{graphviz}.

  Graphviz-dot-mode是Emacs下编辑graphviz的DOT代码的一种主模式,提供语法高
  亮,自动缩进,图像预览等特性.

\item 配置
\begin{verbatim}
(load-file PAHT/TO/FILE/graphviz-dot-mode.el)
\end{verbatim}

\item 快捷键

  \begin{tabular}{ll}
    TAB,M-j,C-M-q & 缩进\\
    C-c c, M-x compile & 编译\\
    C-c p & 预览\\
    C-c v & 调用外部程序预览\\
  \end{tabular}
\end{enumerate}
#+END_SRC
*** CMake
**** cmake-mode
http://blog.csdn.net/csfreebird/article/details/7197392
http://www.emacswiki.org/emacs/CMakeMode
+ 安装: mepla
+ 配置:
  - require
  - auto-mode-alist
+ 命令: cmake-help
**** emacs-cmake-project
+ https://github.com/alamaison/emacs-cmake-project
*** Octave
#+BEGIN_SRC latex
参考：\\
\indent\href{https://www.gnu.org/software/octave/doc/interpreter/Emacs-Octave-Support.html}{Emacs
  文档}

\begin{enumerate}
\item 加载和文件关联
\begin{verbatim}
;(autoload 'octave-mode "octave-mod" nil t)
(setq auto-mode-alist
      (cons '("\\.m$" . octave-mode) auto-mode-alist))
\end{verbatim}
\textbf{注:网站的说明可能跟不上,有些对应不上}
\item 关联abbrevs,auto-fill和font-lock子模式
\begin{verbatim}
(add-hook 'octave-mode-hook
          (lambda ()
            (abbrev-mode 1)
            (auto-fill-mode 1)
            (if (eq window-system 'x)
                (font-lock-mode 1))))
\end{verbatim}

\item 快捷键

  \begin{tabular}{lll}
    \hline
    C-h a & octave-lookfor & octave搜索\\
    C-h d & octave-help & octave帮助\\
    C-c C-l & octave-source-file & sour文件 \\
    C-c ; & octave-update-function-file-comment & 更新函数文档 \\
    M+. & octave-find-definition & 查找定义 \\
    C-M-j & octave-indent-new-comment-line & 插入新的注释行\\
    C-M-q & prog-indent-sexp & 块缩进 \\
    C-c / OR ] & smie-indent-sexp & 闭合\\
    C-c TAB (C-)a & octave-send-buffer & 执行缓冲区\\
    C-c TAB (C-)r & octave-send-region & 执行区域\\
    C-c TAB (C-)l & octave-send-line & 执行行\\
    C-c TAB (C-)b & octave-send-block & 执行块\\
    C-c TAB (C-)f & octave-send-function & 执行函数\\
    C-c TAB (C-)k & octave-kill-process & 关闭当前程序\\
    C-c TAB (C-)s & octave-show-process-buffer & 显示程序进程缓冲区\\
    \hline
  \end{tabular}

\item 在Emacs运行交互式Octave

  \textbf{M-x run-octave}命令.

  在Octave-mode中通过相关快捷键也可以打开交互式Octave缓冲区.

\end{enumerate}
#+END_SRC
*** Arduino                                                       :arduino:
+ http://emacswiki.org/emacs/arduinosupport


the arduino ide is useful for beginners, but emacs is better.

+ *arduino-mode.el* - major mode for editing .ino and .pde files.

+ *cedet* (collectionofemacsdevelopmentenvironmenttools) supports
  arduino sketch projects, enabling compilation and uploading sketches
  to your microcontroller.

+ *arduino.mk*: to compile sketches outside of the arduino ide, you
  will need to use arduino.mk which is comes with the arduino
  development environment. this enables command line compilation of
  your sketches, and is used by the cedet support.

+ alternately, to use the arduino ide for compilation, but edit in
  emacs, open the preferences in the ide, and choose “use external
  editor”.

**** arduinm.mk
+ http://www.mjoldfield.com/atelier/2009/02/arduino-cli.html

**** emacs arduino
+ http://emacswiki.org/emacs/ArduinoSupport


1. Add yourself to dialout group (whatever group allows access to
   serial port). You will probably need to kill off emacs and re-login
   to have this take effect.

2. Run regular arduino IDE and set up preferences to point to correct
   board type/serial port (arduino.mk reads this for automagically
   populating fields below)

3. Install arduino-mk from your repository/github

4. Create simple Makefile in the same directory as your .ino
   file. Contents can be as simple as this (only the include is truly
   necessary, all other lines can be omitted for simple sketches):

   #+BEGIN_EXAMPLE
     BOARD_TAG = uno   # (see make show_boards)
     ARDUINO_LIBS =    # <space separated list of libs, arduino.mk will try to guess> ros的库需要配置
     MONITOR_PORT = /dev/ttyUSB0   # (will be automatically guessed from IDE prefs)
     include /usr/share/arduino/Arduino.mk   # arduino中安装的，而不是Arduino-Makefile
   #+END_EXAMPLE

5. Call Makefile with *M-x compile* RET *make -k upload*
*** octave IDE                                                     :octave:
matlab叫什么？ *矩阵实验室* ，在研究过程中是离不开矩阵的，所以，不能简
单地放弃matlab，而用python代替。

linux可以不使用matlab，而使用octave作为替代。

*m-x run-octave*

|-------------+----------------------------|
| c-h a       | octave-lookfor             |
| c-h d       | octave-help                |
|-------------+----------------------------|
| c-c tab c-a | octave-send-buffer         |
| c-c tab c-b | octave-send-block          |
| c-c tab c-f | octave-send-defun          |
| c-c tab c-r | octave-send-region         |
| c-c tab c-l | octave-send-line           |
| c-c tab c-k | octave-kill-process        |
| c-c tab c-q | octave-hide-process-buffer |
| c-c tab c-s | octave-show-process-buffer |
| c-c tab a   | octave-send-buffer         |
| c-c tab b   | octave-send-block          |
| c-c tab f   | octave-send-defun          |
| c-c tab k   | octave-kill-process        |
| c-c tab l   | octave-send-line           |
| c-c tab q   | octave-hide-process-buffer |
| c-c tab r   | octave-send-region         |
| c-c tab s   | octave-show-process-buffer |
|-------------+----------------------------|

源码编译安装的octave默认没有安装帮助文档，所以在使用help函数以及
octave-help命令时会出现错误，解决的直接途径就是apt-get方式安装。

** Eshell                                                           :eshell:
*** shell-command                                               :shell:cmd:
|---------+---------------------|
| M-!     | shell-command       |
| M-&     | async-shell-command |
| M-\vert | shell-command-on-region |
|---------+-------------------------|

1. shell-command

   #+BEGIN_SRC emacs-lisp
     (shell-command COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER)
   #+END_SRC

   + Execute string COMMAND in inferior shell; display output, if
     any.
     With /prefix argument/, insert the COMMAND's /output at point/.

   + If COMMAND ends in /&/, execute it /asynchronously/.The output
     appears in the buffer `*Async Shell Command*'.That buffer is in
     shell mode.  You can also use`async-shell-command' that
     automatically adds `&'.

   + Otherwise, COMMAND is executed synchronously.  The output appears
     in the buffer `*Shell Command Output*'.
     If the output is _short enough to display in the echo area_
     (which is determined by the variables /resize-mini-windows/ and
     /max-mini-window-height/), it is shown there, but it is
     nonetheless available in buffer `*Shell Command Output*' even
     though that buffer is not automatically displayed.

*** alias

+ [[http://www.emacswiki.org/emacs/EshellAlias][EmacsWiki Eshell Alias]]

**** Reloading the aliase file
+ stored in a file whose name is in the variable *eshell-aliases-file*
+ this defaults to something like *~/.emacs.d/eshell/alias*
+ *M-x eshell-read-aliases-list* refresh eshell’s cache of the values
+ you can do by typing its name in eshell

**** open file
#+BEGIN_EXAMPLE
  (defalias 'open 'find-file)
  (defalias 'openo 'find-file-other-window)
#+END_EXAMPLE

**** alias ll to 'ls -l'
#+BEGIN_EXAMPLE
  alias ll 'll -l $*'
#+END_EXAMPLE

**** alias 'emacs' to 'find-file'
#+BEGIN_EXAMPLE
  alias emacs "find-file $1"
#+END_EXAMPLE
+ quotes matter
+ $* does not work

**** alias 'w3m' to 'w3-find-file'
The same idea is for checking html files. I generate a lot of html
documentation using Doxygen and want to see the document without
leaving emacs. If you have emacs-w3m and w3m installed; then you may
want to alias w3m to w3m-find-file same as emacs to find-file:
#+BEGIN_EXAMPLE
  alias w3m 'w3m-find-file $1'
#+END_EXAMPLE
**** permanent aliases
The trick is that
+ *all aliases will be stored automatically*
+ *thus you do not need to edit anything equivalent to your
  ".bash_alias" manually*

**** define new eshell commands in .emacs file
You also can define new eshell commands in your .emacs file. There is a
simple example. To define ‘emacs’ command as ‘find-file’ as above you may
write:
#+BEGIN_EXAMPLE
  (defun eshell/emacs (file)
      (find-file file))
#+END_EXAMPLE

*** emacs打开多个eshell
在emacs中如果只是多次运行eshell的话，默认会检测是否有名为eshell的
eshell存在，如果没有则打开一个eshell，如果有则跳转到这个eshell中。

*因此如果要打开多个eshell的话可以先用M-x rename-buffer 重命名现有的
eshell buffer，再启动一个eshell（M-x ehsell）*

*shell也一样.*

*** PS1
+ http://www.emacswiki.org/emacs/EshellPrompt


1. shell PS1 inter
2. eshell  *eshell-prompt-function* (variable)

   The Eshell prompt is generated by the function stored in
   ‘eshell-prompt-function’. When moving through the buffer, eshell
   also needs to know which lines start with a prompt. Therefore,
   whatever ‘eshell-prompt-function’ prints must be matched by
   ‘eshell-prompt-regexp’.

   #+BEGIN_SRC emacs-lisp
     (setq eshell-prompt-function
           (lambda nil
             (let (
                   (prompt-symbol (if (= (user-uid))
                                      " # "
                                    " $ "))
                   (current-path-str (eshell/pwd)))
               (concat (car (reverse
                             (split-string current-path-str "/")))
                       prompt-symbol)
               )))
   #+END_SRC

   + car(first of a list) & cdr(rest of a list)
   + eshell/pwd
   + user-id
   + reverse
   + split-string
*** eshell VS bash,zsh
+ 功能有限, 但基本足够
+ 扩展性强, 可使用eamcs函数
+ 可移植

*** alias
+ 与bash类似, 格式不完全相同
+ 可使用外部命令, 也可使用emacs函数
+ 默认保存在 *~/.eshell/alias*
+ 在eshell中定义时即自动保存

eg.
#+BEGIN_EXAMPLE
  alias ll ls -al $*
  alias dl dpkg -l $1
  alias e find-file $1
  alias v view-file $1
  alias sai sudo aptitude install $1
#+END_EXAMPLE

*** history
bash 中有很多变量控制命令历史，比如: HISTCONTROL、HISTIGNORE 和
HISTFILESIZE.
相对应的, eshell提供变量
+ eshell-hist-ignoredups: 是否忽略重复命令
+ eshell-input-filter: 其实是一个函数,我们每输入一条命令，这条命令会作
  为参数传递给 eshell-input-filter，如果返回 t，这条命令才会被保存到历
  史中。它默认只过滤空白命令，如果要过滤 ls、cd、clear，可以这样修改:
  #+BEGIN_EXAMPLE
    (defvar eshell-histignore
    '("\\`\\(ls\\|ll\\|cd\\|clear\\)\\'"
    "\\`\\s-*\\'"))
    (setq eshell-input-filter
    #'(lambda (str)
    (let ((regex eshell-histignore))
    (not
    (catch 'break
    (while regex
    (if (string-match (pop regex) str)
    (throw 'break t))))))))
  #+END_EXAMPLE
+ eshell-history-size: 历史文件大小

*** cd path
1. 在 bash 里我们可以通过 cd - 回到上一个目录，eshell 同样可以。
   1) *cd -* : 回到上一个目录
   2) *cd -<number>* : 回到倒数第 number个目录
   3) *cd =<REGEXP>* 会回到上一个满足 REGEXP 的目录
2. zsh 中有对路径的别名，cd~X可以进入 ~X 所指代的目录，当目录比较深或
   很常用时非常方便。 eshell也可以实现.
   #+BEGIN_EXAMPLE
     (defvar eshell-path-alist
             `(("e" . ,user-emacs-directory)
               ("t" . "/tmp/")
               ("document" . "~/Documents/")
               ("download" . "~/Downloads/")
               ("v" . "~/video/")
               ("p" . "~/Pictures/")))
   #+END_EXAMPLE

** Media
*** image viewer
+ http://emacs.stackexchange.com/questions/2433/using-emacs-as-an-image-viewer
+ http://emacswiki.org/emacs/ThumbsMode


1. thumbs-mode
   + major-mode
   +
2. emip

   It uses the mogrify utility from ImageMagick to do the actual
   transformations.
   #+BEGIN_EXAMPLE
   (add-hook 'image-mode-hook 'eimp-mode)
   #+END_EXAMPLE

   + (kbd "+") 'eimp-increase-image-size
   + (kbd "-") 'eimp-decrease-image-size
   + (kbd "<") 'eimp-rotate-image-anticlockwise
   + (kbd ">") 'eimp-rotate-image-clockwise
   + (kbd "B +") 'eimp-blur-image
   + (kbd "B -") 'eimp-sharpen-image
   + (kbd "B E") 'eimp-emboss-image
   + (kbd "B G") 'eimp-gaussian-blur-image
   + (kbd "B R") 'eimp-radial-blur-image
   + (kbd "C B +") 'eimp-increase-image-brightness
   + (kbd "C B -") 'eimp-decrease-image-brightness
   + (kbd "C C +") 'eimp-increase-image-contrast
   + (kbd "C C -") 'eimp-decrease-image-contrast
   + (kbd "F ^") 'eimp-flip-image
   + (kbd "F >") 'eimp-flop-image
   + (kbd "F <") 'eimp-flop-image
   + (kbd "N") 'eimp-negate-image
   +
   + ; Commands most relevant to you:
   + (kbd "S f") 'eimp-fit-image-to-window
   + (kbd "S h") 'eimp-fit-image-height-to-window
   + (kbd "S w") 'eimp-fit-image-width-to-window
   +
   + (kbd "<right>") 'eimp-roll-image-right
   + (kbd "<left>") 'eimp-roll-image-left
   + (kbd "<up>") 'eimp-roll-image-up
   + (kbd "<down>") 'eimp-roll-image-down
   + (kbd "<down-mouse-1>") 'eimp-mouse-resize-image
   + (kbd "<S-down-mouse-1>") 'eimp-mouse-resize-image-preserve-aspect
   + (kbd "C-c C-k") 'eimp-stop-all

*** Pandoc
**** org
pandoc & insert
(call-process-shell-command "pandoc")

+ 导出文件还是直接插入buffer
+ 标题层级要怎么处理
+ 正则表达式处理无用的多余信息
+ 有必要么？

**** pandoc-mode

*** scrot
#+BEGIN_SRC latex
参考:\href{http://m.oschina.net/blog/124113}{oschina}
\begin{verbatim}
(defun screenshot()
  "Take a screenshot into a unique-named file in the current buffer file"
  (interactive)
  (setq filename
	(concat (make-temp-name
		 (concat (getenv "HOME") "/Picture/scrot/")) ".png"))
  ;;(suspend-frame)
  (call-process-shell-command "scrot" nil nil nil nil " -s" (concat
"\"" filename "\"" )))

(global-set-key (kbd "C-c s") 'screenshot)
\end{verbatim}

\begin{itemize}
\item \textbf{make-temp-name}

  \textbf{(make-temp-name PREFIX)}\\
  \textbf{Generate temporary file name}(string) starting with PREFIX(a
  string).The Emacs process \textbf{number form} of the result.In addition,
  this function  attempts to choose the a name which has no existing
  file. To make this work, PREFIX should be an absolute file name.

\item \textbf{suspend-frame}

  \textbf{(suspend-frame)}\\
  Do whatever is right to suspend the current frame.(悬挂当前窗口,与C-
  z, C-x C-z键绑定).

\item \textbf{call-process-shell-command}

  \textbf{call-process-shell-command COMMAND \&optional INFILE BUFFER
    DISPLAY \&rest AGRS}\\
  Execute the shell command COMMAND synchronously in separator
  process.(在独立进程中同步执行shell命令COMMAND)
\item \textbf{getenv}

  (getenv VARIBLE \&optional FRAME)\\
  Get the value of the environment variable VARIBLE.
\end{itemize}
#+END_SRC
** Exteral Apps
*** git-emacs
**** 在Emacs中使用git的选择:
+ Emacs VC(古老)
+ git.el(经典, git项目的官方工具)
+ git-emacs(强大)
+ mgit(新潮)
**** 配置
#+BEGIN_EXAMPLE
    ;;git-emacs
    (add-to-list 'load-path "/path/to/git-emacs/")
    (require 'git-emacs)
#+END_EXAMPLE
**** 基本使用
|-------------+-----------------------|
| C-x g c RET | git-commit-all        |
| C-x g c a   | git-commit-all        |
| C-x g c f   | git-commit-file       |
| C-x g c i   | git-commit            |
|-------------+-----------------------|
| C-x g s     | git-status            |
| C-x g a     | git-add               |
| C-x g l     | git-log               |
| C-x g b     | git-branch            |
|             | git-history           |
|-------------+-----------------------|
| C-x g C-l   | git-log-other         |
| C-x g .     | git-cmd               |
| C-x g D     | git--diff-all-map     |
| C-x g L     | git-log-files         |
| C-x g R     | git-reset             |
| C-x g c     | git--commit-map       |
| C-x g d     | git--diff-buffer-map  |
| C-x g g     | git-grep              |
| C-x g h     | git-stash             |
| C-x g i     | git-add-interactively |
| C-x g m     | git-merge-next-action |
|-------------+-----------------------|
| C-x g D RET | git-diff-all-head     |
| C-x g D b   | git-diff-all-baseline |
| C-x g D h   | git-diff-all-head     |
| C-x g D i   | git-diff-all-index    |
| C-x g D o   | git-diff-all-other    |
| C-x g d RET | git-diff-head         |
| C-x g d b   | git-diff-baseline     |
| C-x g d h   | git-diff-head         |
| C-x g d i   | git-diff-index        |
| C-x g d o   | git-diff-other        |
|-------------+-----------------------|

**** git-status
如果当前打开的文件所在的文件夹处于版本控制中，可以通过 *M-x
git-status* 查看状态

|---------+------------------------------------------|
| p/n     | 在所有文件之间上下移动                   |
| P/N     | 在变更过的文件之间上下移动               |
| </>     | 定位到列表的头部/尾部                    |
| v       | 以只读方式打开文件                       |
| m/u/SPC | 设置/取消/切换标记，标记用于批量处理文件 |
| a       | 将文件加入版本控制                       |
| i       | 将文件加入ignore                         |
| c       | 提交                                     |
|---------+------------------------------------------|

**** 提交
在状态清单中使用“c",或者在任何buffer中运行 *M-x
git-commit/git-commit-all/git-commit-file* ，可以提交index/所有文件/当
前文件。
|----------+------|
| C-c C-c  | 提交 |
| C-c C-q  | 取消 |
|----------+------|

**** 标签和分支
M-x git-branch：列出所有分支,在这里可以通过快捷键c/d/RET实现创建/删除/切换分
支。

M-x git-tag可以创建一个标签，以后在git-checkout时可以指定标签的名字，也可以
通过git-checkout-to-new-branch来基于tag创建分支。

** Tools
*** 书签                                                         :bookmark:
[[http://blog.csdn.net/pfanaya/article/details/7068710][CSDN blog]]
书签:保存缓冲区位置
书签保存位置: $HOME/.emacs.d/bookmarks
|---------+----------------------+------------------------|
| C-x r m | bookmark-set         | 设置书签               |
| C-x r l | bookmarks-bmenu-list | 列出书签               |
| C-x r b | bookmark-jump        | 跳转至书签             |
|         | bookmark-delete      | 删除书签,亦可同名覆盖  |
|         | bookmark-save        | 将书签保存到书签文件中 |
|---------+----------------------+------------------------|

书签列表操作
|-----+--------------|
| d   | 标记删除     |
| u   | 取消删除标记 |
| x   | 执行删除     |
| r   | 重命名       |
| q   | 关闭列表     |
| o   |              |
| C-o |              |
| m   |              |
| u   |              |
| v   |              |
| s   |              |
|-----+--------------|

*** 临时文件和备份文件
Emacs在编辑文件的时候实际上并非对文件本身进行编辑，而是会将要编辑的文件内容
拷贝到Emacs的一个临时缓冲区（buffer）内，而我们编辑的时候，也只是对这个缓冲
区的内容进行更改。为了便于在需要的时候能够方便的应对，Emacs会自动产生一些其
他的辅助文件，其中最常见的有临时文件和备份文件。
**** 临时文件(Auto-Save file)
Emacs的临时文件的文件名是使用“#”包围，这种文件一般是在Emacs中编辑时，emacs自
动保存的文件，他在编辑文件的同一个目录内生成一个以#file-name#这样的文件，这
个文件会在我们保存文件之后被emacs删除。这个文件的作用是为了防止在进行编辑的
时候异常退出造成的损失。

使用以下配置关闭自动保存功能.当然，一般是不建议关闭的，因为在异常退出
之后，如果你想要恢复自己辛苦编辑的内容，它能帮上大忙，你只要在emacs内
打开你要恢复的文件， 使用 *M-x recover-file* 然后在恢复即可。

#+BEGIN_EXAMPLE
(setq auto-save-default nil) ;; 默认值是t， 要关闭直接用nil更改默认值
#+END_EXAMPLE
**** 备份文件(Backup files)
备份文件是在第一次保存的时候，如果保存的文件已经存在，Emacs会自动将当前已经
存在的文件重命名作为备份文件，并将当前buffer的内容写入同名的文件中来替代原来
的文件。而备份文件使用的是一个“～”作为后缀(如：file-name~)。

备份文件默认仅会发生在Emacs第一次写入的时候，即，开启Emacs之后，第一次打开文
件并保存的时候，编辑期间多次保存并不能产生多次备份动作。然而，下次重新打开
Emacs，再次执行同样的动作的时候，同样在第一次保存时，Emacs是会将上次的备份文
件覆盖的（如果有）。这也许是你不想要的，这时候你可以通过设置，让每次的备份文
件都不同。

上面的这个流程是可以定制的，比如，我们可以要求emacs通过拷贝，而非重命
名的方式来备份文件，在.emacs或者Emacs内设置个变量就成：

#+BEGIN_EXAMPLE
;; 在.emacs文件中添加下面这行表示使用拷贝模式
(setq backup-by-copying t) ;; 默认是nil，开启之后使用拷贝模式
#+END_EXAMPLE

建议不要修改这个值，因为重命名的方式感觉要优于拷贝模式。

*** smex                                                             :smex:
- State "DONE"       from "TODO"       [2015-03-21 六 19:12]
https://github.com/nonsequitur/smex/blob/master/README.markdown

1. 安装配置
   安装: MEPLA
   配置:
   #+BEGIN_EXAMPLE
     (require 'smex)
     (smex-initialize)
     (global-set-key (kbd "M-X") 'smex-major-mode-commands)
   #+END_EXAMPLE

2. Feature
   + smex-major-mode-commands runs Smex, limited to commands that are
     relevant to the active major mode.
   + *C-h f* while Smex is active, runs describe-function on the
     currently selected command.
   + *M-.*  jumps to the definition of the selected command
   + *C-h w* shows the key bindings for the selected command. (Via
     where-is.)
   + Smex keeps a file to save its state betweens Emacs sessions. The
     default path is "~/.smex-items"; you can change it by setting the
     variable *smex-save-file*
   + Set smex-history-length to change the number of recent commands
     that Smex keeps track of.

*** ibuffer                                                       :ibuffer:
|-------------+-----------------------------------------------|
| M-x ibuffer | 打开ibuffer                                   |
|             | 注:C-x C-b和C-x b被绑定到helm功能             |
| q           | 关闭ibuffer                                   |
|-------------+-----------------------------------------------|
| / m         | 根据模式筛选                                  |
| / /         | 去除筛选条件                                  |
| / g         |                                               |
| / n         | 根据buffer名称筛选                            |
| / c         | 根据内容筛选                                  |
| / f         | 根据文件名筛选                                |
| / >         | 根据buffer大小筛选                            |
| / <         | 根据buffer大小筛选                            |
|-------------+-----------------------------------------------|
| ,           | 在排序方法中循环切换                                    |
| s i         | 倒序                                          |
| s a         | 根据名称排序                                  |
| s f         | 根据文件名排序                                |
| s v         | 根据最后浏览时间排序                          |
| s s         | 根据大小排序                                  |
| s m         | 根据模式排序                                  |
|-------------+-----------------------------------------------|
| o           | 在其它窗口打开当前buffer,并将光标切换到该窗口 |
| C-o         | 在其它窗口打开当前buffer,光标停留在当前窗口   |
| g           | 更新ibuffer                                   |
| m           | 标记当前buffer                                |
| u           | 取消标记                                      |
| A           | 打开标记buffer或当前buffer                    |
| S           | 保存buffer                                    |
| D           | 关闭buffer                                    |
| V           | 放弃buffer的更改                              |
|-------------+-----------------------------------------------|

*** Dired-mode                                                      :dired:

**** reference

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/1c21394c-83a9-4195-8896-6e82f1537f33/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D1518af27d2e%3AS%3D4ed20871873e69333409d3b47be4c0e9][Emacs 强大的文件管理器]]

**** Mark & Flag

|---------------------------------+----------------------------------------|
| d                               | 标记删除                               |
| x                               | 执行删除                               |
| C-u d                           | 去掉标记                               |
| #                               | 标记所有自动保存的文件,e.g. #demo.org# |
| ~                               | 标记所有备份文件(即文件名以~结尾)      |
| &                               | 标记垃圾文件                           |
| dired-garbage-files-regexp      | 查看垃圾文件                           |
|---------------------------------+----------------------------------------|
| **                              | 标记所有可执行文件                     |
| *@                              | 标记所有符号链接                       |
| */                              | 标记所有目录文件,不包括.和..           |
| *s                              | 标记所有文件,不包括.和..               |
| *.                              | 标记具有扩展名的文件                   |
| %m REGEXP RET OR  *% REGEXP RET | 标记正则表达式匹配文件                 |
| %g REGEXP RET                   | 标记文件内容匹配正则表达式的文件       |
|---------------------------------+----------------------------------------|
| u                               | 去除当前行的标记                       |
| DEL                             | 上移一行并去除该行的标记               |
| U                               | 去除所有标记                           |
| *? MARKCHAR                     | 去除所有以MARKCHAR标记的文件           |
| t                               | 交换标记                               |
| M-( OR * OR )                   | 使用断言                               |
|---------------------------------+----------------------------------------|

**** 常用操作

|---------------+------------------------|
| *C(不用加*号) | 拷贝文件               |
| *D            | 删除文件               |
| *R            | 重命名文件             |
| *H            | 创建硬链接             |
| *S            | 创建符号链接           |
| *M            | 修改权限               |
| *G            | 修改属组               |
| *O            | 修改属主               |
| *T            | 修改时间               |
| *P            | 打印                   |
| *Z            | 压缩或解压             |
| *L            | 加载Elisp文件          |
| *B            | 字节编译Elisp文件      |
| *A            | 正则表达式搜索         |
| *Q            | 对文件内容进行交互替换 |
|---------------+------------------------|

**** shell命令

|---+---------------|
| ！ | 执行shell命令 |
|---+---------------|

**** 强大的重命名

+ /wdired-change-to-wdired-mode/ 进入编辑模式
+ /wdired-allow-to-change-permission/ 设为t可编辑权限

**** 排除过滤

/k/

ired 还有一个 /k/ 用于去掉不想显示出来的文件，它并不删除磁盘上的文件，
只是临 时从 dired 的 buffer 中去掉他们， g 刷新一下它们又会显示出来，
这样，首用强大的标记功能进行标记，然后使用 k 去掉，就实现了过滤的功能。

**** 子目录操作

dired 允许同时操作当前目录和子目录。

在 [[help:dired-listing-switches][dired-listing-switches]] 里面加入 R 选项就可以显示子目录.

#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-l")
#+END_SRC

如果只是想临时显示某个子目录的内容，对该目录执 行 /i/ 操作就会把该子目
录的内容添加到 dired 当前 buffer 的末尾并把光标移 动到那里.

dired 在移动之前会先设置一个 mark ，所以可以使用 /C-u C-<SPC>/

**** 其他功能

|-----+-----------------------------------------|
| +   | 创建目录                                |
| *w* | 复制文件名,C-u 0,绝对路径, C-u,相对路径 |
| I   | 以info文档格式打开                      |
| N   | 以man格式打开                           |
| Y   | ...                                     |
|-----+-----------------------------------------|

*** 计算器                                                           :calc:

参考:
[[http://blog.163.com/wobutianl@126/blog/static/1335848201293033635805/][网易博客]]
[[http://emacser.com/calc.htm][emacer中文]]

**** Quick Calculator模式
+ 命令  M-x quick-calc
+ 快捷键  C-x * q
+ MiniBuffer中显示
+ C-g  退出Quick Calculator模式。

**** programmable calculator
命令M-x Calc
1) 数学计算
   如果要计算1 + 2的值，输入”1 回车 2 回车 +”即可。
2) 在二进制、八进制、十进制与十六进制之间进行转换
   输入”10 回车  *d2* ，这个d2会把窗口中的所有数字显示为二进制形式，所
   有的数字都会以”2#”开头，以表示它们是二进制形式。如果要重新用十进
   制显示，则输入 *d0* 即可。
   同样，也可以用 *d8*，*d6* 来显示八进制和十六进制的格式。同样，输入
   八进制数以”8#”开头，输入十六进制以”16#”开头。
3) 温度单位转换
   如果你想知道40 F°是多少C°，输入40 回车 ut dF 回车 dC 回车即可，

如果要退出programmable calculator这个计算器，则输入”q”即可。

总的来说，这个programmable calculator风格有点怪异，不是太复杂的功能，
还是不要用为好。

**** calc
*****  概述
   “Calc” 是 emacs 自带的一个计算器，提供了许多方便的数值计算功能，
   可以让你在不离开 emacs 的情况下进行计算。但 calc 与 gnome 环境下的
   gcalctool 或者 windows 自带的计算器不同，它不是一个掌上计算器的模拟
   程序，操作不像上述两个计算器那样直观，需要记忆一些指令，相应的，提
   供的功能也更加强大了一些。
***** 打开计算器
   *C-x * c* ： 打开计算器。
   *C-x * t* ： 打开计算器，同时也打开 calc 的在线帮助。
***** 基本运算
****** 逆波兰表达式
calc 按照逆波兰表达式的方式进行计算。比如，你要计算2+3的结果，要按照如
下顺序在 calc 的 buffer 中输入：
2 <RET> 3 <RET> + (<RET> 表示回车)
假设，你当前输入了：
1 <RET> 2 <RET> 3 <RET>
然后，输入加号 ‘+’，那么 calc 将会计算 2+3 的结果， 并保持数字1不变，
calc 的 buffer 中会剩下 1,5两个数字。此时，再次输入’+'， calc 会计算
1+5 的结果，此时 calc 的 buffer 中只剩下一个数字 ‘6’。

很多时候，可以省略一个<RET>，比如计算2+3时，你可以省略第二个<RET>，只
输入：
2 <RET> 3 +

****** 基本运算符号
‘+’：加号
‘-’：减号
‘*’：乘号
‘/’：除号
‘%’：取余，比如6%5=1, 30%4=2
‘&’：取倒数
‘^’：幂运算，当然也可以用做开方运算，比如4^0.5=2

****** 代数运算
当我们只是想简单的对一系列数字进行代数运算时，使用逆波兰表达式不是很直
观，因此， calc 提供了一个更加直接的指令：

*‘* （就是分号旁边的那个按键）
比如，在 calc 中按’，然后输入算式：
(3^2 + 4^2) ^ 0.5
calc 会直接给出答案：5。

***** 数制转换
在 calc 中使用指令 *d2,d8,d0,d6* 可以在2进制，8进制，10进制，16进制之间切
换（d2 就是先按’d'，再按’2′，其他也以此类推）。calc 默认是使用10进
制进行计算。当进入2进制，8进制，16进制模式时，mode line上会给
出’Bin’，’Otc’，’Hex’字样的提示，默认的10进制模式是不会有任何提
示的。当进入任何一种进制模式的时候，输入的数字都是以10进制模式输入的。
比如在16进制模式下，输入：
10 <RET>
此时，calc中显示的数字是’A'，而不是16进制的10。
如果你想按照当前的进制输入数字，需要在键入数字前按‘#’，比如，在16进制模式下输入：
#10 <RET>
此时，calc中显示的数字就是16进制的10,而不是A。

***** 三角运算
****** 逆波兰表达式下的运算符
S：正弦
C：余弦
T：正切
比如，想计算30度角的正弦值，输入：
30 <RET> S（可以省略 <RET>）
calc 会给出答案：0.5
****** 在代数模式下的运算符
sin：正弦
cos：余弦
tan：正切
比如，输入
’sin(30)2+cos(30)2
我这里的calc给出答案：
0.999999999999
****** 弧度制和角度制的转换
*m r* ：进入弧度制（mode line 上显示 Rad）
*m d* ：进入角度制（mode line 上显示 Deg）

***** 向量运算与矩阵运算
输入向量与矩阵的方法很简单, *方括号* 。
比如，输入一个三维向量：
[ 1 <RET> 2 <RET> 3 <RET> ]
此时，calc 中就会显示：
[1, 2, 3]
（实际上最后一个<RET>可以省略）
输入矩阵的方法与向量类似，比如，我们输入一个2×2的矩阵：
[ [ 1 <RET> 2 <RET> ] [ 3 <RET> 4 <RET> ] ]
此时， calc 中会显示：
[ [ 1, 2 ]
[ 3, 4 ] ]
calc中专门的矩阵运算法则我没有研究过，我自己平常会用到的，也就是矩阵求
逆。只需输入一个矩阵，然后按 *&* 就可以了（还记得“&”么？如果对数字使
用“&”运算，就是求倒数，对于矩阵，就是求逆）。

***** 复制，删除，撤销
输入一个数字（或矩阵），然后按<RET>，可以复制该数字（或矩阵）到整个运
算 *堆栈的最顶部*

Backspace 或 Del 可以删除运算堆栈最顶部的数字（或矩阵）。

用 *U* 或者 *C-_* 或者 *M-x calc-undo* 可以在计算器中执行撤销操作
***** 定义函数
在 calc 中你可以定义自己的函数。定义函数的指令是：
Z F
比如，先输入一个公式：
‘a + 2b
然后键入：
Z F m
再回答几个 minibuffer 中提出的问题，就定义了一个以 ‘z m’为快捷键的函数了。
此时，再输入两个数字：
1 <RET> 2 <RET>
然后按：
z m
就会按照公式计算出1+2*2的结果，也就是5。

使用指令：
Z P
可以把函数保存到文件，这样在以后的 emacs 会话中都可以使用这个函数。
比如，输入：
Z P m
可以把刚才定义的函数’z m’保存到由变量 calc-settings-file 指定的文件中。以后每次进入 calc 时，保存在这只文件中的函数也会被自动加载。calc-settings-file 的默认值是”~/.calc.el”，我通常喜欢把它挪到.emacs.d 里面：
**** 小结
|---------+----------------|
| C-x * c | M-x calc       |
| C-x * q | M-x quick-calc |
|---------+----------------|
*** ledger-mode 快速输入                                           :ledger:
参考:
+ http://www.ledger-cli.org/3.0/doc/ledger-mode.html


1. 配置
   #+begin_example
     (autoload 'ledger-mode "ledger-mode" "a major mode for ledger" t)
     (add-to-list 'load-path
                  (expand-file-name "/path/to/ledger/source/lisp/"))
     (add-to-list 'auto-mode-alist '("\\.ledger$" . ledger-mode))
   #+end_example

2. quick add
   ledger provide two ways to add transactions with minimal
   typing. both are based on the idea that *most transactions are
   repetitions of earlier transaction*

   1) according to payee
      + type the date
      + tyep the first characters of the payee
      + c-c tab
   2) add transaction
      + c-c c-a

   3) convenient month and year
      + c-c ret month
      + c-c c-y year

*** Calendar
**** 配置
http://www.cnblogs.com/FelixLee/archive/2011/10/25/2412558.html
#+BEGIN_EXAMPLE
  (setq chinese-calendar-celestial-stem
  ["甲" "乙" "丙" "丁" "戊" "己" "庚" "辛" "壬" "癸"])
  (setq chinese-calendar-terrestrial-branch
  ["子" "丑" "寅" "卯" "辰" "巳" "午" "未" "申" "酉" "戌" "亥"])


  (setq diary-file "~/Tiger/Doc/diary")
  (setq diary-mail-addr "buaaben@163.com")
  (add-hook 'diary-hook 'appt-make-list)

  ;; make the calendar and diary display fancier
  (setq view-diary-entries-initially t
        mark-diary-entries-in-calendar t
        number-of-diary-entries 7)
  (add-hook 'diary-display-hook 'fancy-diary-display)
  (add-hook 'today-visible-calendar-hook 'calendar-mark-today)

  (setq appt-issue-message t)


  ;; holiday-fixed m d 固定阳历节日， m 月 d 日
  ;; holiday-float m w n 浮动阳历节日， m 月的第 n 个星期 w%7
  (setq general-holidays '((holiday-fixed 1 1 "元旦")
                           (holiday-fixed 2 14 "情人节")
                           (holiday-fixed 4 1 "愚人节")
                           (holiday-fixed 12 25 "圣诞节")
                           (holiday-float 5 0 2 "母亲节")
                           (holiday-float 6 0 3 "父亲节")
                           (holiday-fixed 10 1 "国庆节")))

  ;;除去基督徒的节日、希伯来人的节日和伊斯兰教的节日
  (setq christian-holidays nil
        hebrew-holidays nil
        islamic-holidays nil
        solar-holidays nil
        bahai-holidays nil
  )p

  (setq calendar-remove-frame-by-deleting t)
  (setq calendar-week-start-day 0) ; 每周第一天是周日
  (setq mark-diary-entries-in-calendar t) ; 标记有记录的日子
  (setq mark-holidays-in-calendar t) ; 日历中突出标记节日
  (setq view-calendar-holidays-initially t) ; 不显示节日列表
#+END_EXAMPLE
**** 快捷键
http://blog.163.com/wobutianl@126/blog/static/1335848201291810232827/

1. Calendar模式支持各种方式来更改当前日期
   + q 退出calendar模式
   + C-f 让当前日期向前一天
   + C-b 让当前日期向后一天
   + C-n 让当前日期向前一周
   + C-p 让当前日期向后一周
   + M-} 让当前日期向前一个月
   + M-{ 让当前日期向后一个月
   + C-x ] 让当前日期向前一年
   + C-x [ 让当前日期向后一年
   + C-a 移动到当前周的第一天
   + C-e 移动到当前周的最后一天
   + M-a 移动到当前月的第一天
   + M-e 多动到当前月的最后一天
   + M-< 移动到当前年的第一天
   + M-> 移动到当前年的最后一天

2. Calendar模式支持移动多种移动到特珠日期的方式
   + g d 移动到一个特别的日期
   + o 使某个特殊的月分作为中间的月分
   + . 移动到当天的日期
   + p d 显示某一天在一年中的位置，也显示本年度还有多少天。
   + C-c C-l 刷新Calendar窗口

3. Calendar支持生成LATEX代码。
   + t m 按月生成日历
   + t M 按月生成一个美化的日历
   + t d 按当天日期生成一个当天日历
   + t w 1 在一页上生成这个周的日历
   + t w 2 在两页上生成这个周的日历
   + t w 3 生成一个ISO-SYTLE风格的当前周日历
   + t w 4 生成一个从周一开始的当前周日历
   + t y 生成当前年的日历

4. EMACS Calendar支持配置节日：
   + h 显示当前的节日
   + x 定义当天为某个节日
   + u 取消当天已被定义的节日
   + e 显示所有这前后共三个月的节日。
   + M-x holiday 在另外的窗口的显示这前后三个月的节日。

5. 另外，还有一些特殊的，有意思的命令：
   + S 显示当天的日出日落时间(是大写的S)
   + p C 显示农历可以使用
   + g C 使用农历移动日期可以使用

6. 创建事件的命令：
   + d 显示被选中的日期的所有事件
   + s 显示所有事件，包括过期的，未到期的等等
   + i d 为当天日期添加一个事件
   + i w 为当天周创建一个周事件
   + i m 为当前月创建一个月事件
   + i y 为当前年创建一个年事件
   + i a 为当前日期创建一个周年纪念日
   + i c 创建一个循环的事件
*** Aspell                                                         :aspell:
参考:
+ [[
][IBM developwork]]
+ [[http://aspell.net/][Aspell homepage]]
+ [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Spelling.html][flyspell manual]]
+ [[http://hahack.com/tools/ispell-and-flyspell/][ispell使用]]

如果经常使用Emacs来写英文文章和邮件,那么拼写检查的功能则必不可少.Emacs
提供了 *flyspell* 模式来对拼写作出检查. flyspell只是Emacs的一个前端,提
供了桥接Emacs与其它拼写检查程序如 *Aspell*, *Ispell* 和 *Hunspell* 交
互的管道.

推荐使用 *Aspell*.

**** 安装Aspell及词典
*$ sudo apt-get install aspell*   # 没有必要一定要源码安装
**** Emacs的配置
1) 设置flyspell使用Aspell,并配置语言环境为英语
   #+BEGIN_EXAMPLE
     (setq-default ispell-program-name "aspell")
     (ispell-change-dictionary "american" t)
   #+END_EXAMPLE
2) 模式关联
   #+BEGIN_EXAMPLE
     (setq text-mode-hook '(lambda ()
                             (flyspell-mode t)))
   #+END_EXAMPLE
   注:从速度角度考虑,不推荐进行模式关联,推荐使用 *M-x flyspell-mode*
   来启动aspell的拼写检查功能.
**** flyspell模式使用与技巧
 |----------------------+------------------------------------------------------------|
 | ispell-word(M-$)     | check and correct the word at point/regioin                |
 | ispell               | check all the words in the buffer/region                   |
 | ispell-buffer        | check spelling in the buffer                               |
 | ispell-region        | check spelling in the region                               |
 | ispell-message       | check spelling in a draft mail message                     |
 | flyspell-mode        | Enable flyspell-mode,which highlights all misspelled words |
 | flyspell-prog-mode   | Enable flyspell-mode for comments and strings only         |
 | ispell-kill-ispell   | kill the aspell/ispell/Hunspell subprocess                 |
 | ispell-complete-word | complete the world, bindding to M-TAB                      |
 |----------------------+------------------------------------------------------------|

 *ispell-local-dictionary* 变量指定词典.
 *M-x ispell-change-dictionary* sets the dictionary and restart
 *subprocess.
 *ispell-personal-dictionary* 变量指定个人词典.
 *ispell-complete-word-dict* 变量指定单词补全使用的词典.

 Flyspell mode is a minor mode that performs automatic spell checking
 as you type. When it finds a word that it does not recognize, it
 highights that word. Type *M-x flyspell-mode* to toggle Flyspell mode
 in the current buffer.
 When Flyspell mode highlights a word as missspelled, you can click on
 it with *Mouse-2* to display a menu of possible corrections and
 actions.

 并不推荐on the fly的使用方法(Emacs与外部程序的通信和数据交换总是要浪
 费大量时间).最好的方法是,平时不开flymode,等写完了文章使用命令 M-x
 ispell-regoin 进行拼写检查.

|--------+----------------------------------------------------------------------|
| 命令   | 解释                                                                 |
|--------+----------------------------------------------------------------------|
| digit  | 屏幕的一半会显示出可以替换的正确单词，并用数字编号，输入这个数字编号 |
|        | 就可以选择提示单词，并且用来替换当前错误拼写的单词。                 |
| <SPC>  | 跳过当前单词的拼写检查，承认其错误，但是在这里并不改正。             |
| r new  | 用一个新输入的单词替换当前拼写错误的单词                             |
| <RET>  |                                                                      |
| R new  | 用一个新输入的单词替换当前拼写错误的单词，并且 flyspell 会提示是否替 |
| <RET>  | 换文章中其它地方出现的类似拼写错误。                                 |
| a      | 在当前编辑区域里，把当前提示错误的拼写当作正确的拼写。               |
| A      | 在当前的 buffer 里，把当前提示错误的拼写当作正确的拼写。             |
| i      | 把当前的单词插入到你的私人字典文件里，这样以后 Aspell 或 Ispell 或   |
|        | Hunspell 就会把它当作正确的单词来对待了。                                                                     |
| m      | 与 i 命令的操作相同，但是我们可以提供更多的补充信息                  |
| u      | 插入当前单词的小写形式到字典里。                                     |
| l word | 在词典里查找与该单词匹配的单词，这些单词会成为新的候选单词，我们可以 |
| <RET>  | 通过数字来选择它们中的其中一个作为替换。可以用 * 号来作为通配符。    |
| C-g    | 退出交互式的拼写检查操作，鼠标停留在当前被检查的单词上，可以用命令   |
| X      | C-u M-$ 来重新进行单词拼写检查。                                     |
| x      | 退出单词拼写检查并把光标返回到拼写检查开始前的位置。                 |
| q      | 退出交互式拼写检查，并且结束 Aspell/Ispell/Hunspell 等子进程。       |
| ?      | 显示帮助信息                                                         |
|--------+----------------------------------------------------------------------|
**** TODO 给flyspell添加自定义的词典
参考Aspell手册.
*** artist-mode                                                    :artist:
参考:
+ [[http://www.lysator.liu.se/~tab/artist/][artist-mode homepage]]
+ [[http://www.emacswiki.org/emacs/ArtistMode][EmacsWiki]]
+ [[http://emacser.com/artist-mode.htm][Emacs中文网]]

**** What is artist?
Artist is an Emacs lisp package that allow you to draw lines,
rectangles, squared, poly-line, ellisp and circles by use your mouse
and/or keyboard. The shapes are made up with the ascii
characters |,-,/ and \.

artist是一个emacs的内置lisp包。
在artist-mode中，你可以使用鼠标或者键盘来画线(可以带箭头)、矩形、正方形、多
边形、椭圆、圆和一些类似于水蒸气似的不规则图形，当然可以擦除，填出图形，还可
以在其上写字。

**** 基本使用
***** 开启minor mode
*M-x artist-mode* 开启artist-mode(注:该模式下,一些快捷键失效).
***** 三个mouse
|---------------------+----------------------------------------|
| *mouse-2(鼠标中键)* | 弹出选项菜单,选择左键绘图类型,更改设定 |
| *mouse-1(鼠标左键)* | 绘制                                   |
| *S-mouse-1*         | 绘制                                     |
| *mouse-3(鼠标右键)* | 删除鼠标下的字符                       |
| *S-mouse-3*         | 画出矩形框,删除框选字符                |
|---------------------+----------------------------------------|
***** 绘制操作
|------------+--------------------+------------------------|
| 操作       | 无shift            | 有shift                |
|------------+--------------------+------------------------|
| Pen        | 填充符为'.',绘制线 | 填充符为'o',绘制直线   |
| Line       | 任意方向           | 直线                   |
| Rectangle  | 矩形               | 正方形                 |
| Poly-line  | 任意方向的多边形   | 每条线都是直线的多边形 |
| Ellipse    | 椭圆               | 圆                     |
| Text       | 文本               | 覆盖式文本             |
| Spray-can  | 喷雾器             | 设置喷雾器大小         |
| Erase      | 橡皮,擦除一个字符  | 擦除矩形内字符         |
| Vaporize   | 擦除一行           | 擦除所有相连的行       |
| Cut        | 剪切矩形           | 剪切正方形             |
| copy       | 复制矩形           | 复制正方形             |
| paste      | 粘贴               | 粘贴                   |
| Flood-fill | 填充工具，填充 | 填充                   |
|------------+--------------------+------------------------|
***** 设定

|------------+----------------------------------------------------------|
| 设定选项   | 含义                                                     |
|------------+----------------------------------------------------------|
| Set fill   | 设定用来填充矩形和正方形的字符                           |
| Set line   | 设定绘制线的时候使用的字符                               |
| Erase char | 设置擦除的时候使用的字符                                 |
| Trimming   | 开关修剪行尾的功能（一个图画完，一行行尾的空格会被移除） |
| Borders    | 开关在填充图形周围绘制行边界的功能                       |
|------------+----------------------------------------------------------|
***** 命令
****** 基本命令
|---------------------------------------------------+----------------------|
| 命令                                              | 功能                 |
|---------------------------------------------------+----------------------|
| M-x artist-key-set-point                          | 执行以下功能         |
|---------------------------------------------------+----------------------|
| M-x artist-select-operation                       | 选择绘制类型         |
|---------------------------------------------------+----------------------|
| M-x artist-next-line, M-x artist-previous-line,   |                      |
| M-x artist-forward-char and M-x                   | 移动                 |
| artist-backward-char.                             |                      |
|---------------------------------------------------+----------------------|
| M-x artist-select-fill-char                       | 设置填充字符         |
| M-x artist-select-line-char                       | 设置绘制时字符       |
| M-x artist-select-erase-char                      | 设置擦除时使用字符   |
| M-x artist-toggle-rubber-banding                  | 开关 rubber-banding  |
|                                                   | 功能（不知道是什么） |
| M-x artist-toggle-trim-line-endings               | 开关修剪行尾的功能   |
| M-x artist-toggle-borderless-shapes               | 开关在填充图形周围绘 |
|                                                   | 制行边界的功能       |
|---------------------------------------------------+----------------------|
****** artist-key-set-point 执行的功能
|---------------------+----------------------------------------------------|
| 情况                | 作用                                               |
|---------------------+----------------------------------------------------|
| lines/rectangles/   | 设置起始/结束点                                    |
| squares             |                                                    |
|---------------------+----------------------------------------------------|
| poly-lines          | 设置其中一个点， (使用 C-u M-x                     |
|                     | artist-key-set-point 设置结束点)                   |
|---------------------+----------------------------------------------------|
| 擦除字符时          | 开关橡皮功能                                       |
|---------------------+----------------------------------------------------|
| 剪切，复制          | 设置区域/正方形的开始/结束点                       |
|---------------------+----------------------------------------------------|
| 粘贴时              | 粘贴动作                                           |
|---------------------+----------------------------------------------------|
****** 箭头命令
|--------------------------------+--------------------------------|
| M-x artist-toggle-first-arrow  | 设置/取消在线/多线段开头的箭头 |
|--------------------------------+--------------------------------|
| M-x artist-toggle-second-arrow | 设置/取消在线/多线段结尾的箭头 |
|--------------------------------+--------------------------------|
****** 选择操作
|-----------------------------------------+----------------------|
| M-x artist-select-op-line               | 绘制线               |
| M-x artist-select-op-straight-line      | 绘制直线             |
| M-x artist-select-op-rectangle          | 绘制矩形             |
| M-x artist-select-op-square             | 绘制正方形           |
| M-x artist-select-op-poly-line          | 绘制多线段           |
| M-x artist-select-op-straight-poly-line | 绘制直线组成的多线段 |
| M-x artist-select-op-ellipse            | 绘制椭圆             |
| M-x artist-select-op-circle             | 绘制圆               |
| M-x artist-select-op-text-see-thru      | 写字（插入模式）     |
| M-x artist-select-op-text-overwrite     | 写字（覆盖模式）     |
| M-x artist-select-op-spray-can          | 喷雾器               |
| M-x artist-select-op-spray-set-size     | 设置喷雾器的大小     |
| M-x artist-select-op-erase-char         | 擦除字符             |
| M-x artist-select-op-erase-rectangle    | 擦除矩形内字符       |
| M-x artist-select-op-vaporize-line      | 擦除一行             |
| M-x artist-select-op-vaporize-lines     | 擦除所有相连的行     |
| M-x artist-select-op-cut-rectangle      | 剪切矩形             |
| M-x artist-select-op-copy-rectangle     | 复制矩形             |
| M-x artist-select-op-paste              | 粘贴                 |
| M-x artist-select-op-flood-fill         | 填充                 |
|-----------------------------------------+----------------------|

*** google-translate                                         :google:
+ https://github.com/atykhonov/google-translate


*** define-minor-mode
+
  http://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Minor-Modes.html


define-minor-mode is an autoloaded Lisp macro in `easy-mmode.el'.

(define-minor-mode MODE DOC &optional INIT-VALUE LIGHTER KEYMAP &rest
BODY)

Define a new minor mode MODE.
This defines the toggle command MODE and (by default) a control variable
MODE (you can override this with the :variable keyword, see below).
DOC is the documentation for the mode toggle command.

The defined mode command takes one optional (prefix) argument.
Interactively with no prefix argument, it toggles the mode.
A prefix argument enables the mode if the argument is positive,
and disables it otherwise.

When called from Lisp, the mode command toggles the mode if the
argument is `toggle', disables the mode if the argument is a
non-positive integer, and enables the mode otherwise (including
if the argument is omitted or nil or a positive integer).

If DOC is nil, give the mode command a basic doc-string
documenting what its argument does.

Optional INIT-VALUE is the initial value of the mode's variable.
Optional LIGHTER is displayed in the mode line when the mode is on.
Optional KEYMAP is the default keymap bound to the mode keymap.
  If non-nil, it should be a variable name (whose value is a keymap),
  or an expression that returns either a keymap or a list of
  arguments for `easy-mmode-define-keymap'.  If you supply a KEYMAP
  argument that is not a symbol, this macro defines the variable
  MODE-map and gives it the value that KEYMAP specifies.

BODY contains code to execute each time the mode is enabled or disabled.
  It is executed after toggling the mode, and before running MODE-hook.
  Before the actual body code, you can write keyword arguments, i.e.
  alternating keywords and values.  These following special keywords
  are supported (other keywords are passed to `defcustom' if the minor
  mode is global):

:group group	custom group name to use in all generated `defcustom' forms.
		Defaults to MODE without the possible trailing "-mode".
		Don't use this default group name unless you have written a
		`defgroup' to define that group properly.
:global GLOBAL	If non-nil specifies that the minor mode is not meant to be
		buffer-local, so don't make the variable MODE buffer-local.
		By default, the mode is buffer-local.
:init-value VAL	Same as the INIT-VALUE argument.
		Not used if you also specify :variable.
:lighter SPEC	Same as the LIGHTER argument.
:keymap MAP	Same as the KEYMAP argument.
:require SYM	Same as in `defcustom'.
:variable PLACE	The location to use instead of the variable MODE to store
		the state of the mode.	This can be simply a different
		named variable, or a generalized variable.
		PLACE can also be of the form (GET . SET), where GET is
		an expression that returns the current state, and SET is
		a function that takes one argument, the new state, and
		sets it.  If you specify a :variable, this function does
		not define a MODE variable (nor any of the terms used
		in :variable).

:after-hook     A single lisp form which is evaluated after the mode hooks
                have been run.  It should not be quoted.

For example, you could write
  (define-minor-mode foo-mode "If enabled, foo on you!"
    :lighter " Foo" :require 'foo :global t :group 'hassle :version "27.5"
    ...BODY CODE...)

#+BEGIN_SRC emacs-lisp
  (define-minor-mode tagerill-mode
    "tagerill minor mode"
    :init-value nil
    :lighter tagerill
    ;; :keymap tagerill-mode-map
    :group 'tagerill)
#+END_SRC

*** epub                                                             :epub:
**** ebook -> org-mode
Calibre -> htmlz -> unzip -> [[anchor:pandoc][pandoc]]:

#+BEGIN_EXAMPLE
$ cp ~/Calibre\ Library/Metz*/Practi*/*.htmlz ./book.htmlz
$ unzip -q book.htmlz
$ pandoc ./index.html -o book.org
#+END_EXAMPLE
**** org-mode -> ebook
pandoc
**** epub-mode
#+BEGIN_EXAMPLE
;;; epub-mode.el --- Minor mode for reading epub e-books in Emacs

;; Copyright (C) 2011 Jayson Williams

;; Author: Jayson Williams <williams.jayson@gmail.com>
;; Last update: 2011-10-26
;; Version: 0.1 (early development)
;; Keywords: epub
;; URL: https://sourceforge.net/projects/epubmode/
;; Contributors:
;;

;; epub-mode is a minor mode for viewing epub documents in Emacs

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth floor,
;; Boston, MA 02110-1301, USA.

;; Installation

;; While in early development, install by visiting epubmode.el and
;; evaluating the buffer.

;; To use epubmode do:
;; M-x get_epub

;; Ener the path to the epub document, and epub mode will open a text
;; version of the document in Emacs

(defun get_epub (epub_file)
  "Read epub files in emacs"
  (interactive "fname of epub: ")
  (message "%s" epub_file)
  (setq working_folder (concat epub_file "-working"))
  (setq mk_working_dir_cmd (concat "mkdir " working_folder))

  (if (file-directory-p working_folder)
      (message "working folder present")
    (progn
     (shell-command mk_working_dir_cmd)
     (setq unzip_epub_cmd (concat "unzip " epub_file " -d " working_folder))
     (shell-command unzip_epub_cmd)))

  (setq directories (directory-files working_folder nil "[^.]"))
  (setq directories (delete "META-INF" directories))
  (setq count (length directories))
  (setq index 0)
  ;;; create html_files & book_txt after storing existing directories
  (shell-command (concat "mkdir " working_folder "/htm_files"))
  (shell-command (concat "mkdir " working_folder " /book_text"))

  (while (/= index count)
    ;;;need to find the folders with html docs in it
    (setq folder (elt directories index))
    (setq index (1+ index)) ;;;for next iteration
    (setq inner_folder_path (concat working_folder "/" folder))

    (if (file-directory-p inner_folder_path)
        (progn
          (message inner_folder_path)
          (sleep-for 2)
          (shell-command (concat "cp " inner_folder_path "/*.htm* " working_fol)
      (message "not a folder")))
  (shell-command (concat "touch " working_folder "/book.txt"))

  ;;;Get listing of htm-files , convert to txt, place in book.txt
  (setq index 0)
  (setq htm_files (directory-files (concat working_folder "/htm_files") nil "[^.]")
  (setq htm_files_count (length htm_files))
  ;;;(message "%d files in htm_folder" htm_files_count)

  (while (/= index htm_files_count)
    (setq htm_file (elt htm_files index))
    (message "on htm_files %d: %s" index htm_file)
    (setq index (1+ index))
    (setq source (concat working_folder "/htm_files/" htm_file))
    (setq convert_to_txt (concat "html2text -ascii -nobs " source ">>" working_)
    (shell-command convert_to_txt))
  (find-file (concat working_folder "/book.txt"))

  )
#+END_EXAMPLE

**** read-epub
#+BEGIN_EXAMPLE
;;;;;;;;;;;;;;;;; begin read-epub
;; read-epub
;; Read an epub in Emacs.

;; Requires Calibre package, to provide ebook-convert.

;; M-x read-epub
;; and give the path to the epub you want to read.

;; Inspired by epub-mode, but much simpler because it
;; depends on the Calibre package to do the work.

;; No error checking :) see the *messages* buffer if
;; it doesn't work.

;; 2014-06-08 Bob Newell (bobnew...@bobnewell.net),
;;            Honolulu, Hawai`i

;; Released into the public domain.

(defun read-epub (epub-file)
  "Read epub files in emacs"
  (interactive "fname of epub: ")
  (message "Converting %s, this may take some time" epub-file)
  (shell-command (concat "ebook-convert " epub-file " " epub-file".txt" ))
  (find-file (concat epub-file ".txt"))
  (mark-whole-buffer)
  (fill-paragraph nil 1)
  (save-buffer)
  (delete-other-windows)
  (goto-char (point-min))
)

;;;;;;;;;;;;;;; end read-epub
#+END_EXAMPLE

*** Serial Port                                             :serial:
**** Serial Terminal                                               :terminal:

if you have a device connected to a serial port of your computer, you
can communicate with it by typing m-x *serial-term*. this command asks
for a serial port name and speed, and switches to a new term mode
buffer. emacs communicates with the serial device through this buffer
just like it does with a terminal in ordinary term mode.

the speed of the serial port is measured in bits per second. the most
common speed is 9600 bits per second. you can change the speed
interactively by clicking on the mode line.

a serial port can be configured even more by clicking on “8n1” in
the mode line. by default, a serial port is configured as “8n1”,
which means that each byte consists of 8 data bits, no parity check
bit, and 1 stopbit.

if the speed or the configuration is wrong, you cannot communicate
with your device and will probably only see garbage output in the
window.

**** Term Mode                                                  :term:

the terminal emulator uses term mode, which has two input modes. in
line mode, term basically acts like shell mode (see shell mode). in
char mode, each character is sent directly to the subshell, except for
the term escape character, normally c-c.

to switch between line and char mode, use these commands:

+ *c-c c-j*
  switch to line mode (term-line-mode). do nothing if already in line
  mode.

+ *c-c c-k*
  switch to char mode (term-char-mode). do nothing if already in char
  mode.

the following commands are only available in char mode:

+ *c-c c-c*
  send a literal c-c to the sub-shell.

+ *c-c char*
  this is equivalent to c-x char in normal emacs. for example, c-c o
  invokes the global binding of c-x o, which is normally
  ‘other-window’.

term mode has a page-at-a-time feature. when enabled, it makes output
pause at the end of each screenful:

+ *c-c c-q*
  toggle the page-at-a-time feature. this command works in both line
  and char modes. when the feature is enabled, the mode-line displays
  the word ‘page’, and each time term receives more than a screenful
  of output, it pauses and displays ‘**more**’ in the
  mode-line. type spc to display the next screenful of output, or ? to
  see your other options. the interface is similar to the more
  program.

*** EasyPG: 加密                                               :easypg:gpg:
**** 参考:

+ http://www.baidu.com/link?url=ej9AHfY5QR5sRKUofHUYRnu8U-G2A5BO5SghohjAKGLTVnlD2luM0JUO7Fa5mijPnVioLyZV4Xbxb5GkEQr9XINO1YRyYXavf0EtjUZckre&wd=emacs%20%E5%8A%A0%E5%AF%86&issp=1&f=8&ie=utf-8&tn=baiduhome_pg
+ [[http://www.emacswiki.org/emacs/EasyPG][EmacsWiki]]

**** overview
对于一些比较隐私的文件，比如说帐号、密码等，如果不用文件记下来则容易忘
记；而用普通文件记下来，总是觉得有点不放心，哪天电脑丢了怎么办？

Emacs 支持加密文件的操作，总的来说，比较好用的有下面这些方法.

**** ange-crypt

最简单的可能是 ange-crypt 包：

把下面的代码添加到 .emacs 文件里

用命令 *M-x ange-crypt-mode* 来启动这个模式。

**** EasyPG

应该是比较好用的，EmacsWiki 上也专门有相关的讨论
配置:

#+BEGIN_EXAMPLE
  (require 'epa-file)
  (epa-file-enable)
#+END_EXAMPLE

这样，打开或是保存以 .gpg 为后缀的文件，Emacs 就会提示输入加密用的
关键字。
注:

1) 如果希望在打开以 .gpg 为后缀的加密文件时，也能进入相应的 mode，
   我们只需要把 .gpg 作为普通文件的后缀添加到普通文件名后面。比如说，
   一个使用 org mode 文件原来应该命名为 test.org，现在我希望通过
   Emacs 来对它进行加密处理，则我可以把它保存为 test.org.gpg，这样
   下次打开该文件时，Emacs 会自动进入相应的 org mode。

2) 如果在使用 EasyPG 的时候，提示下面的错误byte-code: Opening
   output file: Searching for program, no such file or directory,
   gpg, 则表示没有安装 gpg 这个程序，可以下载安装。

   [[https://www.gnupg.org/][gpg]]: GnuPG is a complete and free implementation of the OpenPGP
   standard as defined by RFC4880 (also known as PGP).

3) 如果希望使用minibuffer输入passphrase，而不是弹出对话框的话，可以
   将环境变量 GPG_AGENT_INFO 清空。

   #+BEGIN_EXAMPLE
   (setenv "GPG_AGENT_INFO" nil)
   #+END_EXAMPLE

4) 默认使用对称加密

   每次保存加密文件，Emacs 都会弹出来问你要用什么方式来加密，很烦人！

   #+BEGIN_EXAMPLE
   (setq epa-file-encrypt-to nil)
   #+END_EXAMPLE

   这样就可以让 Emacs 每次都使用对称加密。

5) 保存时不提示加密

   每次保存加密文件的时候，Emacs 都要让你输一遍密码。我相信你不想每
   次保存文件的时候，都让你输一遍密码

   用下面的代码可以让 Emacs 记住密码并自动保存文档：
   #+BEGIN_EXAMPLE
     (setq epa-file-cache-passphrase-for-symmetric-encryption t)
     (setq epa-file-inhibit-auto-save nil)
   #+END_EXAMPLE

当然，不用担心，Emacs 只是在当前这次 Session 记住密码，下次你重启
Emacs 要再次打开这个文件的时候，Emacs 依然会向你要一次密码的。

*** ediff                                                           :ediff:
- State "DONE"       from "TODO"       [2015-02-27 五 17:50]
- State "TODO"       from ""           [2015-02-27 五 15:48]

参考:
+ [[http://caobeixingqiu.is-programmer.com/posts/6783.html#article_wrap][emacs之ediff]]
+ [[http://www.zzbaike.com/wiki/Emacs/EDIFF#jump-to-nav][ediff]]

**** diff
使用 Unix 的 diff 工具程序，你可以找到两个文件的不同之处。所比较的两个文
件可能是：
+ 原始文件与更改之后的文件
+ 不同的两个人编辑的同一个文件(譬如，一个项目中协同工作的两个人编辑的
  文件)
+ 不同机器上的两个文件(譬如，你的 .emacs 文件可能在家和工作场合各有一
  份拷贝)
对于后面两种文件，两个要比较的文件共有一个原始的文件。此种情况下, *diff3*
程序会轻松的帮你创建一个文件，文件内容是对原始文件所做的修改记录。

**** ediff
除非两个文件的不同之处很少，否则 diff 的输出将会很难阅读。幸运的是,
Emacs 提供了一个 *diff 的接口* ，称为 *Ediff* ,将此工作变得简单。不仅
将 diff的输出变得可读之外， Emacs 还提供了合并文件函数以及其他的应用补
丁，更多的细节信息，可以参考 Ediff 的 info 文档。 Emacs 还能比较不同文
件夹下的两个文件，若你在不同地方工作，这个功能可能会非常有用(如你的
Lisp配置文件。

Ediff是Emacs集成的比较与合并（merge）文本文件内容的工具。有了
它，你可以方便地比较两个（或三个）不同文件、文件夹。
+ 实时浏览文件间不同(diff)
+ 比较两个或三个文件间的不同
+ 比较两个或三个emacs-buffer间的不同
+ 正在比较的文件合并成第三个文件
+ 对目录进行操作

***** 用ediff比较文件
|-------------------------+--------------------------------------------|
|        比较项目         |                    说明                    |
|-------------------------+--------------------------------------------|
|                         | 询问两个缓冲区的名字，然后比较相应的区域。 |
| ediff-regions-linewise, | 不过你只能在每一个缓冲区中选定一个区域，而 |
| ediff-regions-          | 不能比较一个文件缓冲区的两个区域。( TODO:  |
|                         | 第15个小时的内容 "了解文件" ，会提供一个比 |
|                         | 较同一个文件中的两个区域的方法。)          |
|-------------------------+--------------------------------------------|
| ediff-buffers           | 询问两个缓冲区的名字，然后比较             |
|-------------------------+--------------------------------------------|
| ediff-files             | 询问两个文件的名字，加载之，然后比较       |
|-------------------------+--------------------------------------------|
|                         | 让你选两个窗口，然后比较窗口的内容。       |
| ediff-windows-linewise, | -linewise- 函数比 -wordwise- 函数要快，但  |
| ediff-windows-wordwise  | 另一方面， -wordwise- 工作方式更好，尤其是 |
|                         | 小区域作业时。 -linewise- 一行一行地比较， |
|                         | -wordwise- 一个单词一个单词地比较。        |
|-------------------------+--------------------------------------------|
***** ediff控制命令
|-----------+-----------------------------------+----------------------|
| 快捷键    | 命令                              | 说明                 |
|-----------+-----------------------------------+----------------------|
| q         | ediff-quit                        | 关闭 ediff control   |
|           |                                   | buffer，并退出 ediff |
|-----------+-----------------------------------+----------------------|
| Space 或  | ediff-next-difference             | 下一个差异处         |
| n         |                                   |                      |
|-----------+-----------------------------------+----------------------|
| Del 或 p  | ediff-previous-difference         | 上一个差异处         |
|-----------+-----------------------------------+----------------------|
|           |                                   | 有数字前缀 n 修饰    |
| C-n j     | ediff-jump-to-difference          | ，第n个差异处,n可为 |
|           |                                   | 负数                 |
|-----------+-----------------------------------+----------------------|
| v 或 C-v  | ediff-scroll-vertically           | 所有缓冲区同步向下滚 |
|           |                                   | 动                   |
|-----------+-----------------------------------+----------------------|
| V 或 M-v  | ediff-scroll-vertically           | 所有缓冲区同步向上滚 |
|           |                                   | 动                   |
|-----------+-----------------------------------+----------------------|
| <         | ediff-scroll-horizontally         | 所有缓冲区同步向左滚 |
|           |                                   | 动                   |
|-----------+-----------------------------------+----------------------|
| >         | ediff-scroll-horizontally         | 所有缓冲区同步向右滚 |
|           |                                   | 动                   |
|-----------+-----------------------------------+----------------------|
| (vertical | ediff-toggle-split                | 切换缓冲区布局方式,  |
| bar)      |                                   | 水平和竖直           |
|-----------+-----------------------------------+----------------------|
| m         | ediff-toggle-wide-display         | 在正常 frame 大小和  |
|           |                                   | 最大化之间切换       |
|-----------+-----------------------------------+----------------------|
| a         | ediff-copy-A-to-B                 | 把Buffer-A的内容复制 |
|           |                                   | 到Buffer-B           |
|-----------+-----------------------------------+----------------------|
| b         | ediff-copy-B-to-A                 | 把Buffer-B的内容复制 |
|           |                                   | 到Buffer-A           |
|-----------+-----------------------------------+----------------------|
| r a 或 r  |                                   | 恢复 Buffer-A 或     |
| b         | ediff-restore-diff                | Buffer-B 差异区域中  |
|           |                                   | 的被修改的内容       |
|-----------+-----------------------------------+----------------------|
| A 或 B    | ediff-toggle-read-only            | 切换 Buffer-A 或     |
|           |                                   | Buffer-B 的只读状态  |
|-----------+-----------------------------------+----------------------|
|           |                                   | 根据光标在缓冲区中的 |
| g a 或 g  | ediff-jump-to-difference-at-point | 位置，设置一个离它们 |
| b         |                                   | 最近的差异区域为当前 |
|           |                                   | 活动区域             |
|-----------+-----------------------------------+----------------------|
| C-l       | ediff-recenter                    | 恢复先前的所有缓冲区 |
|           |                                   | 比较的高亮差异区。   |
|-----------+-----------------------------------+----------------------|
| !         | ediff-update-diffs                | 重新比较并高亮差异区 |
|           |                                   | 域                   |
|-----------+-----------------------------------+----------------------|
| w a 或 w  | ediff-save-buffer                 | 保存 Buffer-A 或     |
| b         |                                   | Buffer-B 到磁盘      |
|-----------+-----------------------------------+----------------------|
| E         | ediff-documentation               | 打开 Ediff 文档      |
|-----------+-----------------------------------+----------------------|
|           |                                   | 关闭 ediff control   |
| z         | ediff-suspend                     | buffer, 只是挂起，可 |
|           |                                   | 在以后恢复 ediff 状  |
|           |                                   | 态                   |
|-----------+-----------------------------------+----------------------|



***** 比较三个文件
|----------------+----------------|
|      函数      |      说明      |
|----------------+----------------|
| ediff-files3   | 比较三个文件   |
|----------------+----------------|
| ediff-buffers3 | 比较三个缓冲区 |
|----------------+----------------|

比较两个文件或缓冲区的所有操作，几乎都适于三个比较。不过在进行缓冲区差异
区从A到B拷贝的操作略有不同：
|--------+-----------------------------|
| 快捷键 | 说明                        |
|--------+-----------------------------|
| cb     | 将 Buffer-C 拷贝到 Buffer-A |
|--------+-----------------------------|
| ab     | 将 Buffer-A 拷贝到 Buffer-B |
|--------+-----------------------------|
***** ediff session
你可能同时要比较好多对文件，你可以同时拥有多个 Ediff Session 。按 *z*
挂起当前 Ediff session ,然后启动另一个 Ediff session 就可以了。此时，
在control buffer 中按 R 或是按下 M-x eregistry, 将会打开一个 *Ediff
Registry* 的缓冲区，此缓冲区包含当前运行的所有 Ediff Sessions.可以选择
一个 Ediff session 来进入。

***** 合并文件
***** 比较文件目录
***** 与版本控制系统一起工作

*** Emacs Serial Port                                              :serial:
**** Serial Terminal
If you have a device connected to a serial port of your computer, you
can communicate with it by typing M-x *serial-term*. This command asks
for a serial port name and speed, and switches to a new Term mode
buffer. Emacs communicates with the serial device through this buffer
just like it does with a terminal in ordinary Term mode.

The speed of the serial port is measured in bits per second. The most
common speed is 9600 bits per second. You can change the speed
interactively by clicking on the mode line.

A serial port can be configured even more by clicking on “8N1” in
the mode line. By default, a serial port is configured as “8N1”,
which means that each byte consists of 8 data bits, No parity check
bit, and 1 stopbit.

If the speed or the configuration is wrong, you cannot communicate
with your device and will probably only see garbage output in the
window.

**** Term Mode

The terminal emulator uses Term mode, which has two input modes. In
line mode, Term basically acts like Shell mode (see Shell Mode). In
char mode, each character is sent directly to the subshell, except for
the Term escape character, normally C-c.

To switch between line and char mode, use these commands:

+ *C-c C-j*
  Switch to line mode (term-line-mode). Do nothing if already in line
  mode.

+ *C-c C-k*
  Switch to char mode (term-char-mode). Do nothing if already in char
  mode.

The following commands are only available in char mode:

+ *C-c C-c*
  Send a literal C-c to the sub-shell.

+ *C-c char*
  This is equivalent to C-x char in normal Emacs. For example, C-c o
  invokes the global binding of C-x o, which is normally
  ‘other-window’.

Term mode has a page-at-a-time feature. When enabled, it makes output
pause at the end of each screenful:

+ *C-c C-q*
  Toggle the page-at-a-time feature. This command works in both line
  and char modes. When the feature is enabled, the mode-line displays
  the word ‘page’, and each time Term receives more than a screenful
  of output, it pauses and displays ‘**MORE**’ in the
  mode-line. Type SPC to display the next screenful of output, or ? to
  see your other options. The interface is similar to the more
  program.

**** 小结                                                         :serial:
1. M-x  serial-term
2. 两种模式
   1) term-char-mode
   2) term-line-mode
*** ABORT org export to freemind
- State "ABORT"      from "TODO"       [2015-11-23 一 19:26] \\
  不需要的东西不要瞎折腾, 放弃也是一种智慧


#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name "~/.emacs.d/src/org-mode/contrib/lisp"))
(require 'ox-freemind)
#+END_SRC

(void-function libxml-parse-xml-region) 暂时解决不了。。。

-> 重新编译安装Emacs??? 不要鲁莽！！！
*** sdcv

+ [[http://www.emacswiki.org/emacs/Sdcv][emacswiki]]


F6
*** DONE CAJ文件链接打开                                         :caj:wine:
- State "DONE"       from ""           [2015-12-07 一 14:00]

#+BEGIN_SRC emacs-lisp
  (setq org-file-apps '((auto-mode . emacs)
                        ("\\.mm\\'" . default)
                        ("\\.x?html?\\'" . default)
                        ;; ("\\.pdf\\'" . "evince %s")
                        ("\\.pdf\\'" . "wine \'C:\\Program Files\\Foxit Software\\Foxit Reader\\FoxitReader.exe\' ../../../../%s")
                        ("\\.caj\\'" . "wine \'C:\\Program Files\\TTKN\\CAJViewer 7.1\\CAJViewer.exe\' ../../../../%s")
                        ("\\.nh\\'" . "wine \'C:\\Program Files\\TTKN\\CAJViewer 7.1\\CAJViewer.exe\' ../../../../%s")
                        ))
#+END_SRC

测试OK， 只是使用 CAJ 不是很开心，但是没办法， /不要想着转换成PDF/ ,
不实用，既麻烦，又不方便。

**** wine caj 使用规范

+ 不要添加文字标签笔记，程序会崩溃
+ 使用高亮，表示有参考价值的地方
+ 使用下划线表示可以注意的地方
+ 使用删除线表示需要做为反面教材的地方

** Web
*** w3m                                                               :w3m:
**** 安装
*Emacs-w3m of this version does not support Emacs 23* try the development version

对Emacs23.2版本，需要使用cvs版本，下载如下：

#+BEGIN_EXAMPLE
  # cvs -d :pserver:anonymous@cvs.namazu.org:/storage/cvsroot co emacs-w3m
  ##下载完成后，将源码拷贝到/usr/local/src目录下，
  # cp -r emacs-w3m /usr/local/src/
  # cd /usr/local/src/emacs-w3m/
  ##然后进入emacs-w3m目录，进行如下操作：
  # autoconf
  # ./configure
  # make
  # sudo make install
  ##如果没有装autoconf，需要先apt安装。
#+END_EXAMPLE

**** 配置
#+BEGIN_EXAMPLE
  ;; set emacs-w3m
  ;;设置emacs-w3m浏览器
  (add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-w3m/")
  (require 'w3m)
  (require 'w3m-load)
  ;(require 'mime-w3m)

  ;; 设置w3m主页
  (setq w3m-home-page "http://www.google.com")

  ;; 默认显示图片
  (setq w3m-default-display-inline-images t)
  (setq w3m-default-toggle-inline-images t)

  ;; 使用cookies
  (setq w3m-command-arguments '("-cookie" "-F"))
  (setq w3m-use-cookies t)
  (setq browse-url-browser-function 'w3m-browse-url)
  (setq w3m-view-this-url-new-session-in-background t)

#+END_EXAMPLE

**** 快捷键
|----------+---------------------------------------------------------------|
| q        | 关闭窗口                                                      |
| Q        | 直接离开                                                      |
| C-x-k    | 关闭当前标签页                                                |
| U        | 打开 URL                                                      |
| G        | 在标签页中打开一个网址                                        |
| S        | 用google进行搜索                                              |
| B        | 后退                                                          |
| N        | 前进                                                          |
| H        | 主页                                                          |
| R        | 刷新                                                          |
| C-n      | 下一行                                                        |
| C-p      | 向上一行                                                      |
| C-b      | 向后                                                          |
| C-f      | 向前                                                          |
| C-v      | 向下滚屏                                                      |
| ESC v    | 向上滚屏                                                      |
| 打开链接 | RET                                                           |
| >        | 向右滚屏                                                      |
| <        | 向左滚屏                                                      |
| ,        | 向左移动一格                                                  |
| .        | 向右移动一格                                                  |
| R        | Reload the current page                                       |
| C-t  R   | Reload all the pages                                          |
| r        | Redisplay the current page                                    |
| TAB      | Move to the new anchor                                        |
| C-M-i    | Move to the previous anchor                                   |
| B        | move  back to the previous page in the history                |
| N        | move forward to the next page in the history                  |
| s        | display the history in the session                            |
|          | with the prefic arg, it displays the arrived URLS             |
|----------+---------------------------------------------------------------|
| M-d      | down th url                                                   |
| d        | down load the url under point                                 |
|----------+---------------------------------------------------------------|
| u        | display the url under the point and put it into kill-ring     |
| c        | display the url of the current page and put it into kill-ring |
|----------+---------------------------------------------------------------|
| t        | toggle the visibility of an image under point                 |
| T        | toggle the visibility of all images                           |
| I        | display the image under point in the external viewer          |
| M-i      | save the image under point to a file                          |
| M-左方括号   | zoom in an image on the point                                 |
| M-右方括号   | zoom out an image on the point                                |
|----------+---------------------------------------------------------------|
| \        | display the html source of the current page                   |
| a        | 添加当前页到书签                                              |
| M-a      | add the urls under point to the bookmark                      |
| ESC a    | 添加该URL到书签                                               |
| v        | 显示书签                                                      |
| E        | 编辑书签                                                      |
| C-k      | 删除书签                                                      |
| C-_      | 撤消书签                                                      |
| M        | 用外部浏览器打开当前页面                                      |
| ESC M    | 用外部浏览器打开链接                                          |
|----------+---------------------------------------------------------------|
| C-c C-k  | 停止载入                                                      |
|----------+---------------------------------------------------------------|


|-------------+-------------------------------+--------------|
| Key-binding | Function                      | 备注         |
|-------------+-------------------------------+--------------|
| SPC,C-v     | Forward page                  | 前页         |
| b,ESC v     | Backward page                 | 后页         |
| l,C-f       | Cursor right                  | 光标右移     |
| h,C-b       | Cursor left                   | 光标左移     |
| j,C-n       | Cursor down                   | 光标下移     |
| k,C-p       | Cursor up                     | 光标上移     |
| J           | Roll up one line              | 向上滚屏一行 |
| K           | Roll down one line            | 向下滚屏一行 |
| ^,C-a       | Go to the beginning of line   | 跳转至行首   |
| $,C-e       | Go to the end of line         | 跳转至行尾   |
| w           | Go to next word               | 后一个单词   |
| W           | Go to previous word           | 前一个单词   |
| >           | Shift screen right            | 向右滚屏     |
| <           | Shift screen left             | 向左滚屏     |
| .           | Shift screen one column right | 向右滚屏一列 |
| ,           | Shift screen one column left  | 向左滚屏一列 |
| g,M-<       | Go to the first line          | 跳转至首行   |
| G,M->       | Go to the last line           | 跳转至尾行   |
| ESC g       | Go to specified line          | 跳转至指定行 |
| Z           | Move to the center line       |              |
| z           | Move to the center column     |              |
| TAB         | Move to next hyperlink        |              |
| C-u,ESC TAB | Move to previous hyperlink    |              |
| 左方括号        | Move to the first hyperlink   |              |
| 右方括号        | Move to the last hyperlink    |              |
|-------------+-------------------------------+--------------|


|---------------------------+-------------------------------------------------------------------------+---|
| RET                       | Follow hyperlink                                                        |   |
| a, ESC RET                | Save link to file                                                       |   |
| u                         | Peek link URL                                                           |   |
| i                         | Peek image URL                                                          |   |
| I                         | View inline image                                                       |   |
| ESC I                     | Save inline image to file                                               |   |
| :                         | Mark URL-like strings as anchors                                        |   |
| ESC :                     | Mark Message-ID-like strings as news anchors                            |   |
| c                         | Peek current URL                                                        |   |
| =                         | Display information about current document                              |   |
| C-g                       | Show current line number                                                |   |
| C-h                       | View history of URL                                                     |   |
| F                         | Render frame                                                            |   |
| M                         | Browse current document using external browser (use 2M and 3M to invoke |   |
| second and third browser) |                                                                         |   |
| ESC M                     | Browse link using external browser (use 2ESC M and 3ESC M to invoke     |   |
|                           | second and third browser)                                               |   |
|---------------------------+-------------------------------------------------------------------------+---|

|---+----------------------------------|
| U | Open URL                         |
| V | View new file                    |
| @ | Execute shell command and load   |
| # | Execute shell command and browse |
|---+----------------------------------|

|-------+-----------------------------|
| B     | Back to the previous buffer |
| v     | View HTML source            |
| s     | Select buffer               |
| E     | Edit buffer source          |
| C-l   | Redraw screen               |
| R     | Reload buffer               |
| S     | Save buffer                 |
| ESC s | Save source                 |
| ESC e | Edit buffer image           |
|-------+-----------------------------|

**** w3m-default-save-directory
+ w3m-default-save-directory is a variable defined in `w3m.el'.
+ Its default value is "~/.w3m"
+ Default directory where downloaded files will be saved to.

#+BEGIN_EXAMPLE
(setq w3m-default-save-directory "~/Tiger/Figures/w3m/")
#+END_EXAMPLE

*** mew                                                               :mew:
参考:
+ [[http://www.mew.org/en/][Homepage]]
+ [[http://emacser.com/mew.htm][emacs中文]]
+ http://zerodoo.appspot.com/emacs.mew.1.0001.html

**** What is Mew?
Mew is an acronym for "Messaging in the Emacs World".
Mew is a mail reader for Emacs.

**** 安装
#+BEGIN_EXAMPLE
  $  git clone git://github.com/kazu-yamamoto/Mew.git  # 下载
  $  ./configure
  $  make
  $  sudo make install
#+END_EXAMPLE

**** 配置
***** 基本配置
#+BEGIN_EXAMPLE
  ;; 设置 Mew
  (autoload 'mew "mew" nil t)
  (autoload 'mew-send "mew" nil t)
  ;; 下面的图标路径和安装路径有关，具体请看Mew的安装过程

  (setq mew-use-cached-passwd t)
  ;; mew-pop-size设置成0时，pop邮件大小没有限制
  (setq mew-pop-size 0)
  ;; 不删除服务器上的邮件
  (setq mew-pop-delete nil)
#+END_EXAMPLE


***** 单账号配置
#+BEGIN_EXAMPLE
  (setq mew-name "Corel Chen") ;; (user-full-name)
  (setq mew-user "corel") ;; (user-login-name)
  (setq mew-mail-domain "a8.com")
  (setq mew-smtp-user "corel")
  (setq mew-smtp-server "smtp.a8.com")  ;; if not localhost
  (setq mew-pop-user "corel")  ;; (user-login-name)
  (setq mew-pop-server "pop.a8.com")    ;; if not localhost
  (setq mew-pop-auth 'pass)
  (setq mew-smtp-auth-list '("PLAIN" "LOGIN" "CRAM-MD5"))
#+END_EXAMPLE

***** 多账号配置
#+BEGIN_EXAMPLE
  (setq mew-config-alist
        '(("default"
       ("name"         .  "Corel Chen")
       ("user"         .  "corel")
       ("smtp-server"  .  "smtp.a8.com")
       ("smtp-port"    .  "25")
       ("pop-server"   .  "pop.a8.com")
       ("pop-port"     .  "110")
       ("smtp-user"    .  "corel")
       ("pop-user"     .  "corel")
       ("mail-domain"  .  "a8.com")
       ("mailbox-type" .  pop)
       ("pop-auth"     .  pass)
       ("smtp-auth-list" . ("PLAIN" "LOGIN" "CRAM-MD5"))
       )
       ("gmail"
          ("name"         . "corel")
          ("user"         . "corel.china")
          ("mail-domain"  . "gmail.com")
          ("proto"        . "+")
          ("pop-ssl"      . t)
          ("pop-ssl-port" . "995")
  ;       ("prog-ssl"     . "/usr/sbin/stunnel")
          ("pop-auth"     . pass)
          ("pop-user"     . "corel.china@gmail.com")
          ("pop-server"   . "pop.gmail.com")
          ("smtp-ssl"     . t)
          ("smtp-ssl-port". "465")
          ("smtp-auth-list" . ("PLAIN" "LOGIN" "CRAM-MD5"))
          ("smtp-user"    . "corel.china@gmail.com")
          ("smtp-server"  . "smtp.gmail.com")
          )
  ))

#+END_EXAMPLE

***** 密码管理
有两种方式：
+ 保存密码到内存，而不是写到文件
  #+BEGIN_EXAMPLE
  (setq mew-use-cached-passwd t)
  #+END_EXAMPLE
+ Mew运行时保存密码到内存，退出时加密保存到文件，有主密码
  #+BEGIN_EXAMPLE
  (setq mew-use-master-passwd t)
  #+END_EXAMPLE

***** 编码
缺省情况下，mew发送的邮件都是用的 iso-2022-jp-2 编码发送的，如果用 mew
接收邮件显示是正常的，但其他客户端接收则可能是乱码了。在已发送邮件上按
*C-c TAB* 会显示邮件的详情，可以看到：

Content-Type: Text/Plain; charset=iso-2022-jp-2
Content-Transfer-Encoding: 7bit

要改成用 utf8 发送邮件，查了很多资料并看了下mew的源码，发现要作如下设置，才
会用 utf8 来发送邮件：
#+BEGIN_EXAMPLE
(setq mew-charset-m17n "utf-8")
(setq mew-internal-utf-8p t)
#+END_EXAMPLE

这时再发送邮件时，会看到：
Content-Type: Text/Plain; charset=utf-8
Content-Transfer-Encoding: base64

***** biff设置
设置使用Biff检查邮箱是否有新邮件，默认为5分钟。如果有新邮件，则在
emacs的状态栏显示Mail(n)的提示—n表示新邮件数目。

#+BEGIN_EXAMPLE
  (setq mew-use-biff t)  ;;
  (setq mew-use-biff-bell t)  ;; 设置嘟嘟声通知有新邮件
  (setq mew-biff-interval 10) ;; 设置自动检查新邮件的时间间隔，单位：分钟
#+END_EXAMPLE

特别提示：要使用biff实现通知，需要先启动mew，然后就可以干其他的活了。如果看
到状态栏上有Mail(n)的提示，则切换到mew的buffer，这时是看不到新邮件的（也就是
说新邮件并没有收到本地），需要按 i 按键收取新邮件。

**** 使用
***** M-x mew
|-------------+---------------------------------------------------------|
| w           | 撰写新邮件                                              |
| a           | 回复邮件，不带引用                                      |
| A           | 回复邮件，带引用                                        |
| f           | 转发邮件                                                |
| E           | 重新编辑邮件                                            |
| r           | 重新发送邮件                                            |
| SPC         | 阅读邮件                                                |
| y           | 保存邮件（可以保存信件全文、信件正文、附件）            |
| C-c C-l     | 转换当前邮件的编码格式                                  |
| C-c C-a     | 加入地址薄                                              |
| C-u C-c C-a | 比 C-c C-a 多加入昵称和名字                             |
| i           | 收信                                                    |
| g           | 跳转邮箱                                                |
| o           | 对邮件进行分类                                          |
| M-o         | 对所有邮件按照设定的规则进行分类                        |
| d           | 把邮件标记为删除                                        |
| *           | 做星号标记                                              |
| m/          | 列出所有有星号标记的邮件                                |
| u           | 清除标记                                                |
| U           | 清除所有带有指定标记的标记                              |
| x           | 对所有标记进行处理(比如标记为D的邮件将真正被删除)       |
| ENTER       | 让阅读的邮件向下滚动一行                                |
| -           | 向上滚动一行                                            |
| n           | 下一封邮件                                              |
| p           | 前一封邮件                                              |
| j           | 跳到某一封邮件                                          |
| N           | 下一封带星号的邮件                                      |
| P           | 上一封带星号的邮件                                      |
| S           | 按某个指定项目对邮件排序                                |
| /           | 按指定条件搜索邮件，并进入虚拟模式                      |
| tt          | 进入虚拟模式，根据线索查看，普通模式下是不可以的        |
| v           | 切换"Summary mode only" 和 "Summary & Message mode"模式 |
| C-c C-m     | 编辑新邮件，放入草稿中                                  |
| Z           | 更新地址簿                                              |
|-------------+---------------------------------------------------------|

***** draft: M-x mew-send
***** 其它
|-----+-----------------------------------|
| C   | 如果设置了多个邮箱，用 C 命令切换 |
| Q   | 退出Mew                           |
|-----+-----------------------------------|

**** 地址薄
1. 地址薄
   Mew 提供地址自动完成功能，在输入地址的时候可以使用 TAB 键来进行自动
   完成，自动完成有几个信息来源：
   1) 地址簿中指定的扩展规则
   2) 地址簿中提供的个人信息
   3) 发送邮件的时候自动学习记录下来的地址
2. 位置
   Mew 的地址簿默认是 *~/Mail/Addrbook* 这个文件，里面有两种信息：扩展
   规则和个人信息。
   1) 扩展规则
      #+BEGIN_EXAMPLE
        <shortname>: <address1>[, <address2>, <address3, ...]
      #+END_EXAMPLE
      我们通常不使用这个，不过如果需要一个名称扩展到多个地址的时候可以
      使用这个，例如：
      #+BEGIN_EXAMPLE
        friends: pluskid@mstczju.org, pluskid.zju@gmail.com
      #+END_EXAMPLE
   2) 个人信息
      #+BEGIN_EXAMPLE
        <shortname> <address1>[, <address2>, <address3>, ...] <nickname> <fullname>
      #+END_EXAMPLE
      注意这里没有冒号了。如果使用第一种补全方式，那么可以通过不断地按
      TAB 键来在个人信息里面指定的各个邮件地址之间循环，而不是向扩展规
      则中指定的那样一下子把全部地址扩展出来。另外， nickname 和
      fullname 也是很有用的，例如，在summary-mode 里面可以以 nickname
      来代替发件人地址显示出来。
3. 注释
   注释可以使用
   1) # 用在任何地方
   2) ; 行首
4. 更新
   修改了地址簿之后，可以在 *summary-mode* 里面按 *Z* 提示 mew 读取更
   新后的地址簿的信息。

**** 附件
发送附件

Mew 允许你轻松编辑一个复杂的多媒体邮件。在编辑邮件的时候，按 C-c C-a 即可开
始添加附件，这个时候邮件的末尾会出现如下类似的字样：
#+BEGIN_EXAMPLE
  ------------------------------ attachments ------------------------------
        Multipart/Mixed                                                                   1/
       1  Text/Plain(guess)                                                                 *Cover.txt
       2                                                                                    .
  --------0-1-2-3-4-5-6-7-8-9----------------------------------------------
#+END_EXAMPLE

其中 1/ 是一个用于处理附件的临时目录，默认是 ~/Mail/attach/1 这个目录。默认
已经插入的这个附件 Cover.txt 其实就是邮件的文本内容。这个时候按下 c 即可添加
附件，输入要添加的附件的路径即可把附件拷贝到这个临时目录下面，也可以使用 l
来创建链接，但是如果要编辑附件的话，最好使用 c 来拷贝，免得修改了原来的文件
。

另外，除了添加已经存在的附件以外，还可以使用 F 来打开一个新的文件进行编辑并
添加为附件。随时可以使用 f 命令重新打开一个附件进行编辑，使用=P= 来改名或者
使用 d 进行删除。

m 可以建立子目录，在附件多的时候可以方便对附件进行分类管理。 C-f 和 C-b 可以
在不同层次的目录之间切换。

** LaTeX                                                             :latex:
*** bibtex-mode

参考:
+ [[http://www.emacswiki.org/emacs/BibTeX][EmacsWiki]]
+ [[http://www.jonathanleroux.org/bibtex-mode.html][bibtex-mode]]
+ [[http://ar.newsmth.net/thread-4a78ec7c6ce0c1-1.html][水木BibTeX]]
+ http://blog.waterlin.org/articles/bind-emacs-org-mode-with-bibtex.html

*bibtex-mode* , contained in bibtex.el file, is a major mode for
editing and validating BibTeX `.bib’ files. It is part of GnuEmacs,
and is included in XEmacs. Current bibtex.el maintainer is Roland
Winkler.

*BibTeX `.bib’ files contain bibliographical information*. Below is
an example of one entry in such `.bib’ BibTeX database file:
#+BEGIN_EXAMPLE
  @Article{Aamport:1986a,
     author  = "L[eslie] A. Aamport",
     title   = "The Gnats and Gnus Document Preparation System",
     journal = "{G-Animal's} Journal",
     year    = "1986",
     volume  = "41",
     pages   = "73",
  }
#+END_EXAMPLE

**** 使用
我刚刚开始用BibTeX，发现很好用。插入一个适当的模版，
填写完各个需要的项目，（C-j切换到下一个项目。）

填完项目后，按C-c C-c，
它可以清除所有的空项和删除所有的前缀ALT和OPT，
并且给你自动生成一个参考Key。
**** 定制Key
但是BibTeX自动生成的Key很长，也不符合我们课题组的要求。
花了好几个小时，总算把它给搞明白的。（搞明白后发现很简单）。
贴出来供大家参考或修改。偶以后用起来就不用担心Key的问题了。

针对英文的参考文献，我们组的要求是：
1. 如果文章只有一个作者，则是作者的姓_两位数字的年份（Bush_99）
2. 如果是两个作者，则是作者1的姓-作者2的姓_两位数字的年份
   （Bush-Clinton_02）
3. 如果是三位或三位以上的作者，则是作者1的姓-et.al._两位数字的年份
   （Bush-et.al._04）


在.emacs文件中可以用几行语句实现：
#+BEGIN_EXAMPLE
(setq bibtex-autokey-names 1)
(setq bibtex-autokey-names-stretch 1)
(setq bibtex-autokey-name-separator "-")
(setq bibtex-autokey-additional-names "-et.al.")
(setq bibtex-autokey-name-case-convert 'identity)
(setq bibtex-autokey-name-year-separator "_")
(setq bibtex-autokey-titlewords-stretch 0)
(setq bibtex-autokey-titlewords 0)
#+END_EXAMPLE
**** 排序
注意，如果.emacs文件中有下边的语句：
(setq bibtex-maintain-sorted-entries 'plain)

BibTeX-mode下，可以用 *M-x bibtex-sort-buffer* 对参考文献按Key排序。
用起来很方便。但是插入BibTeX的模板时，它会提醒你自己输入Key。
按[Enter]键可以忽略，填写完模版后，再C-c C-c即可。
最爽的是，插入新的文献后，BibTeX自动把文献插入到该排序的地方。

**** 任务
现在还想解决的一个问题是，如果同作者群一年有多篇文章，
Key就是相同的，希望能自动加入后缀a、b、c……
如：Bush-et.al._04a

*** DONE org如何使用参考文献,是否有便捷方式,有的话可以方便使用org写论文
- State "DONE"       from "waiting"    [2015-03-01 日 14:17] \\
  org中可以直接使用latax命令和环境,不须要包裹为SRC块
- State "waiting"    from "START"      [2015-03-01 日 13:21] \\
  有想法,但org中latex源码的导出遇到问题
- State "START"      from "TODO"       [2015-03-01 日 12:56]
 Date:<2015-02-27 五>

hello. \label{Wong15}

\begin{thebibliography}{99}
\bibitem{Wong15} Tiger Wong, 2015
\end{thebibliography}

*** AucTeX
+ 基础
  AucTeX是Emacs的一个功能模块,为LaTeX的编程提供了巨大的便利.
  + why AucTeX
    - 跨平台,Emacs的插件
    - 半WYSWYG, auctex可以对tex文件进行分析,并且提供部分可视化特性,配
      合preview组件,还可以显示tex公式和图片.
    - 可扩展,由Elisp实现
  + Get Started
    |-------------+------------------------+------------|
    | C-c C-s     | Entering sectioning    |            |
    | C-c C-e     | Inserting environment  |            |
    | C-c C-m     | Inserting macros       |            |
    | C-c RET     |                        |            |
    |-------------+------------------------+------------|
    | C-c C-f C-b | insert bold face text  | \textbf{*} |
    | C-c C-f C-i | insert italics text    | \textit{*} |
    | C-c C-f C-e | insert emphasized text | \emph{*}   |
    | C-c C-f C-s | insert slanted text    | \textsl{*} |
    | C-c C-f C-r | insert roman text      | \textrm{*} |
    | C-c C-f C-f | insert sans seriftext  | \textsf{*} |
    | C-c C-f C-t | insert typewriter text | \texttt{*} |
    | C-c C-f C-c | insert SMALL CAPS      | \textsc{*} |
    | C-c C-f C-d | ...                    |            |
    |-------------+------------------------+------------|
    | C-c ;       |                        |            |
    | C-c %       |                        |            |
    |-------------+------------------------+------------|
    | C-c C-c     |                        |            |
    |-------------+------------------------+------------|
  + LaTeX配置
    [[http://blog.sina.com.cn/s/blog_5387071f0100o54e.html#sina_keyword_ad_area2][sinablog]]
    通常情况下,编译tex文件选用的多是LaTeX mode.
    为了使用auctex方便,为LaTeX模式hook自动换行,数学公式,reftex和显示行
    号功能.
    #+BEGIN_EXAMPLE
    (mapc (lambda (mode)
         (add-hook 'LaTeX-mode-hook mode))
         (list 'auto-fill-mode
               'LaTeX-math-mode
               'turn-on-reftex
               'linum-mode))
    #+END_EXAMPLE
    设置变量TeX-engine更换排版引擎为latex
    默认开启PDF mode,即默认使用xelatex直接生成pdf文件.
  + TODO:  编译片段文件,多文件管理,reftex和preview
    http://blog.sina.com.cn/s/blog_5387071f0100o54e.html#sina_keyword_ad_area2

*** LaTeX-mode
#+BEGIN_SRC latex
C-c ],C-c \} latex-close-block
#+END_SRC
*** 使用org-mode结合AucTeX辅助阅读
1. org-mode的标题层次十分实用, 自动断行也实用
2. org-mode的加粗和斜体功能有限
3. AucTeX有良好的高亮功能

C-c w l
C-c w C-b
C-c w C-r
C-c w C-e

*改为使用印象笔记进行辅助阅读*
** vim                                                                 :vim:
*** evil
+ http://www.emacswiki.org/emacs/Evil
+ http://www.douban.com/group/topic/34775654/

**** evil-org-mode
+ https://github.com/edwtjo/evil-org-mode
+





*** Vim shell command
http://www.educity.cn/help/510677.html
vim中执行shell命令，有以下几种形式


1. :!cmd
   不退出vim，并执行shell命令command，将命令输出显示在vim的命令区域，
   不会改变当前编辑的文件的内容.

   特别的可以运行 :!bash 来启动一个bash shell并执行命令，不需要退出vim

2. :r !command

   将shell命令command的结果插入到当前行的下一行. e.g. r !date，读取系
   统时间并插入到当前行的下一行。

3. :起始行号,结束行号 !command

   将起始行号和结束行号指定的范围中的内容输入到shell命令command处理，
   并将处理结果替换起始行号和结束行号指定的范围中的内容

   e.g.
   + :62,72 !sort，将62行到72行的内容进行排序
   + 可以只指定起始行，:62 !tr [a-z] [A-Z]，将62行的小写字母转为大写字母
   + 当前光标所在行，除可以指定行号外，也可以用.表示，例如:. !tr [a-z]
     [A-Z]，将当前行的小写转为大写

4. :起始行号,结束行号 w !command

   将起始行号和结束行号所指定的范围的内容作为命令command的输入。不会改
   变当前编辑的文件的内容

   e.g. :62,72 w !sort，将62行到72行的内容进行排序，但排序的结果并不会
   直接输出到当前编辑的文件中，而是显示在vim敲命令的区域

   特殊的可以下面这么用:62 w !bash，将会把第62行的内容作为bash命令来执
   行并显示结果，而且不会改变当前编辑的文件的内容

   同样的 :. w !bash，将当前行的内容作为bash命令来执行
*** vim mark region

http://blog.csdn.net/lcj_cjfykx/article/details/9091569

v：按字符选择。经常使用的模式，所以亲自尝试一下它。

V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。

CTRL＋v：按块选择。非常强大，只在很少的编辑器中才有这样的功能。你可以
选择一个矩形块，并且在这个矩形里面的文本会被高亮。

** [[http://www.emacswiki.org/emacs/MarkdownMode][markdown-mode]]                                                  :markdown:

1. install: melpa

2. settings:

   1) auto-mode-alist

   2) org babel highlighting

   3) extral

   #+BEGIN_SRC emacs-lisp
     (add-hook 'markdown-mode-hook
                (lambda ()
                  (when buffer-file-name
                    (add-hook 'after-save-hook
                              'check-parens
                              nil t))))
   #+END_SRC

** Yasnippet                                                     :yasnippet:

* Org-mode                                                        :emacs:org:
** OrgModeTutorials
*** brief manual
$ turn-on-font-lock    # 语法高亮
**** Visibility cycling(视图循环)
|-----------------+----------------------------------------------|
| TAB             | Subtree cycling: FOLDED->CHILDREN->SUBTREE   |
| S-TAB           | Global cycling: OVERVIEW->CONTENTS->SHOW ALL |
| C-u C-u C-u TAN | show all, include drawers                    |
|-----------------+----------------------------------------------|
$ org-startup-folded    # variable to determine the initial behaviour
元数据: #+STARTUP: content    # overview/content/showall
**** Motion(标题间移动)
|---------+----------------------------------|
| C-c C-n | Next heading                     |
| C-c C-p | Previous heading                 |
| C-c C-f | Next heading the same level      |
| C-c C-b | Previous heading the same level  |
| C-c C-u | Backward to higher level heading |
|---------+----------------------------------|
**** Structure editing
|-----------------+-----------------------------------------------------|
| M-RET           | Insert new heading with the same level              |
| M-S-RET         | Insert new TODO entry with the same level           |
| M-LEFT/RIGHT    | Promote/demote current heading by one level         |
| M-S-LEFT/RIGHT  | Promote/demote the current subtree                  |
| M-S-UP/DOWNLOAD | Move subtree up/down                                |
| C-c C-w         | Refile entry ot region to a different location      |
| C-x n s/w       | Narrow buffer to the current subtree/widen it again |
|-----------------+-----------------------------------------------------|
**** Sparse trees
**** Plain list
*unordered list items start with:- + **
*Ordered list items start with: 1. or 1)*
*Description list use '::' to separate the term from the
description*
|-----------------+-------------------------------------------------------|
| TAB             | Fold or unfold current item                           |
| M-RET           | Insert new item at the current level                  |
| M-S-RET         | Insert a new item with a checkbox *?*                 |
| M-S-UP/DOWNLOAD | Move the item up/down                                 |
| M-LEFT/RIGHT    | Decrease/increase the indentation of an item          |
| M-S-LEFT/RIGHT  | Decrease/increase the indentation, including subitems |
| C-c C-c         | toggle the state of the checkbox if existing          |
|                 | also verify bullets and indentation consistency       |
| C-c -           | Cycle the entire list level through the diffent       |
|                 | itemize/enumerate bullet('-' '+' '*' '1.' '1)')       |
|-----------------+-------------------------------------------------------|
**** Footnotes(脚注)
*[fn:*]*   # a footnote marker, replace * with any number or label

|-----------+------------------------------------------|
| C-c C-x f | create a new footnote                    |
|           | or jump between definition and reference |
| C-c C-c   | jump between definitin and reference     |
|-----------+------------------------------------------|
**** Tables
*|-*  # considered to be a horizontal separator
C-c |  Convert the active region to table
|--------------+-----------------------------------------------------------|
| C-c C-c      | Re-align the tabel                                        |
| TAB          | Re-align, and move to the next field                      |
| S-TAB        | Re-align, and move previous field                         |
| RET          | Re-align, and move down to new row                        |
|--------------+-----------------------------------------------------------|
| M-LEFT/RIGHT | Move the current column left/right                        |
| M-S-LEFT     | Kill the current column                                   |
| M-S-RIGHT    | Insert a new column to the left of the cursor position    |
| M-UP/DOWN    | Move the current row up/down                              |
| M-S-UP       | Kill the current row or horizontal line                   |
| M-S-Down     | Insert a new row above the current row                    |
| C-c -        | Insert a horizontal line between the current row          |
| C-c RET      | move down to next row, and insert a horizontial separator |
| C-c ^        | sort the table lines in the region                        |
|--------------+-----------------------------------------------------------|
**** Hyperlinks
#+BEGIN_EXAMPLE
   [[link][description]]  / [link]
#+END_EXAMPLE

|---------+----------------------|
| C-c C-l | edit the 'link' part |
| 你好    | hello                |
|---------+----------------------|
*** GTD管理

  Org mode takes TODO items as an intergral part to the notes file,
  and provides medthods to give you an overview of all the things
  that you have to do.

**** Basic TODO functionality
|-----------------+-------------------------+-----------------------------------------------|
| C-c C-t         | org-todo                | rotate the TODO state of the current item     |
| S-right /S-left |                         | select the following/preceding TODO state     |
| C-c / t         | org-show-todo-tree      | view TODO items in a  sparse tree             |
| C-u C-c / t     | C-c / T                 | view iemts with specific TODO                 |
| C-c a t         | org-todo-list           | show the glabal TODO list                     |
| S-M-RET         | org-insert-todo-heading | insert a new TODO entry below the current one |
|-----------------+-------------------------+-----------------------------------------------|
**** Extended use of TODO keywords
Default states: TODO and DONE.(TODO keywords stored
in *org-todo-keywords*)
***** *TODO* keywords as workflow states
#+BEGIN_EXAMPLE
  (setq org-todo-keywords
        '((sequence "TODO" "FEEDBACK" "VERITY" "|" "DONE" "DELEGATED")))
#+END_EXAMPLE

***** *TODO* keywords as types
The second possibility is to use TODO keywords to indicate different
types of action items.
#+BEGIN_EXAMPLE
  (setq org-todo-keys
        '((type "Fred" "Sara" "Lucy" "|" "DONE")))
#+END_EXAMPLE
***** Multiple keyword sets in one file
#+BEGIN_EXAMPLE
  (setq org-todo-keywords
        '((sequence "TODO" "|" "DONE")
          (sequence "REPORT" "BUG" "KNOWnCAUSE" "|" "FIXED")))
#+END_EXAMPLE
C-u C-u C-c C-t
C-S-right
C-S-left
***** Fast access to TODO states
set up keys for single-letter access to the states
#+BEGIN_EXAMPLE
  (setq org-todo-keywords
        '((sequence "TODO(t)" "|" "DONE(d)")
          (sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(k)" "|" "FIXED(f)")
          (sequence | "CANCELED(c)")))
#+END_EXAMPLE
Note: SPC can be used to remove any TODO keyword from an entry.
***** Setting up keywords for individual files
#+BEGIN_EXAMPLE
  ,#+TODO: TODO FEEDBACK VERITY | DONE CANCELED
  ,#+TYPE_TODO: Fred Sara Lucy Mike | DONE

  ,#+TODO: TODO | DONE
  ,#+TODO: REPORT BUG KNOWNCAUSE | FIXED
  ,#+TODO: | CANCELED
#+END_EXAMPLE
Note: the keywords after the vertical bar (or the last keyword if no
bar is there) must always means that the item is DONE.

***** Faces for TODO keywords
#+BEGIN_EXAMPLE
  (setq org-todo-keyword-faces
        '(("TODO" . org-warning) ("STARTED" . "yellow")
          ("CANCELED" . (:foreground "blue" :weight bold))))
#+END_EXAMPLE
**** 元数据
文档元数据"#+TODO:"或"#+SEQ_TODO:",可以在文档的任何地方定义,但是建议统一定义在文档头部.
C-c C-c 使其生效.

+ !     切换该状态时会自动增加时间戳
+ @     切换到该状态时要求输入文字说明
+ @/!   同时设定以上两者

**** 任务优先级
Org-mode针对任务设定了A,B,C三种优先级,在安排日程时可按照优先级进行排序.
快捷键: S-UP/DOWN
**** 跟踪子任务
在上级标题的任意位置插入 [%] 或 [/],当任务状态变化时会自动更新其值
注意：
 1. 当改变子任务状态时，只更新上一级任务的完成情况，不可级联。
 2. 即使所有的子任务都完成，也只是标记上一级任务的完成情况为100%，而不能自动更新
    上级任务的完成状态。如果需要自动设定为完成，可以在.emacs中增加如下配置：
    #+BEGIN_EXAMPLE
       (defun org-summary-todo (n-done n-not-done)
           "Switch entry to DONE when all subentries are done, to TODO otherwise."
           (let (org-log-done org-log-states)   ; turn off logging
                 (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

       (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
    #+END_EXAMPLE
**** 用复选框标记非标题类型的子任务
对于任何以"[ ]"开头的列表,会被当作复选框,形成子任务.
快捷键:
+ C-c C-c 改变状态
+ M-S-RET 增加一个子项
***** 一个任务 [0%]
- [-] 步骤一 [2/3]
  - [X] 步骤1.1
  - [X] 步骤1.2
  - [ ] 步骤1.3
- [-] 步骤2 [33%]
  - [X] 步骤2.1
  - [ ] 步骤2.2
  - [ ] 步骤2.3

**** 查询任务
C-c /
**** 时间
在ORG中,还可以设置任务的计划时间(SCHEDULED)和截止时间(DEADLINE).
***** 时间戳
在ORG中,将带有日期和时间信息的特定格式的字符串称为时间戳,时间戳使用"< >"进行标记.
+ 时间点
#+BEGIN_EXAMPLE
  <2005-10-01 Tue>
  <2003-09-20 六 09:40>
  <2003-09-17 三 12:00-12:30>
#+END_EXAMPLE
+ 周期
  #+BEGIN_EXAMPLE
    <2007-05-16 Wed 12:30 +1w>
  #+END_EXAMPLE
+ 时间段
  两个时间戳用 "--" 连接起来就定义了一个时间段
  #+BEGIN_EXAMPLE
    <2015-02-25 三>--<2015-02-27 五>
  #+END_EXAMPLE

快捷键
|--------------+----------------------|
| 手工输入     |                      |
| C-c .        | 选择日期插入         |
| C-c <        | 插入当前日期         |
| C-c >        | 查看日历             |
| C-c !        | 输入日期,与任务无关  |
| S-left/right | 按天调整时间戳       |
| S-up/S-down  | 高速光标所在时间单位 |
|--------------+----------------------|

注: 改变时间戳中光标下的项。光标可以处在年、月、日、时或者分之上。当时间戳包含一个
时间段时，如 “15:30-16:30”，修改第一个时间，会自动同时修改第 DOWN 二个时间，以保
持时间段长度不变。想修改时间段长度，可以修改第二个时间。
***** 计划时间和截止时间
|---------+----------|
| C-c C-s | 计划时间 |
| C-c C-d | 截止时间     |
|---------+--------------|
**** 全局任务文件清单
预定义清单
#+BEGIN_EXAMPLE
  (setq org-agenda-files (list "~/.todos/work.org"
                                   "~/.todos/projects.org"
                                   "~/.todos/home.org"
                                   "~/Documents/todo/"
                                 ))
#+END_EXAMPLE
|---------+----------------------|
| C-c [   | 将当前文件加入清单   |
| C-x ]   | 将当前文件移出清单   |
| C-c ' / | 循环打开所有清单文件 |
|---------+----------------------|

**** 全局TODO列表
C-c a t   全局TODO列表
如果提示C-c a快捷键未定义，是因为Org-mode的快捷键没有启用，需要在.emacs中增加配
置：
#+BEGIN_EXAMPLE
      (global-set-key "\C-cl" 'org-store-link)
      (global-set-key "\C-cc" 'org-capture)
      (global-set-key "\C-ca" 'org-agenda)
      (global-set-key "\C-cb" 'org-iswitchb)
#+END_EXAMPLE
**** 日程表
C-c a a
** Babel & Source code                                               :babel:
*** 代码按语法高亮
org-mode在导出成HTML时,可以对代码按照各自的语法进行高亮,只要在
#begin_src后面声明的语言是emacs所支持的,即其对应的major mode存在.
编辑的时候也可以高亮
*(setq org-src-fontify-natively t)*
e.g.
#+BEGIN_EXAMPLE
;; fontify code in code blocks
(setq org-src-fontify-natively t)
#+END_EXAMPLE

*** Org-babel
参考:
+ [[docview:~/Document/tutorials/A%20Multi-Language%20Computing%20Environment%20for][A Multi-Language Computing Environment for Literate Programming and Reproducible Research]]
+ [[http://orgmode.org/worg/org-contrib/babel/intro.html][Babel: Introduction]]
+ [[http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-C.html][C, C++, D Source Code Blocks in Org Mode]]

*** code block in org
Code blocks can be entered directly into the org-mode file, but if is
often easier to enter code with the function *org-edit-src-code*,
which is called with the keyboard shortcut *C-c '**. This places the
code block in a new buffer with the appropriate mode activated.
*** code block in Babel
Babel adds some new elements to code blocks.The basic structure
becomes:
#+BEGIN_EXAMPLE
  ,#+BEGIN_SRC language org-switches header-arguments
  ,body
  ,#+END_SRC
#+END_EXAMPLE
+ *language*
  Valid values must be members of *org-babel-interpreters*
+ *header-arguments*
  Header arguments control many facets of the evaluation and output of
  souce-code blocks
+ *body*
*** session
The *:session* header argument starts a session for an *interpreted
language* where the state is preserved.

By default, a session is not started.

A string passed to the :session header argument will give session the
name. This make it possible to run concurrent sessions for each
interpreted language.

#+BEGIN_SRC sh :session exam_session :exports both
  cd /etc
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :session exam_session :exports both
  pwd
#+END_SRC

#+RESULTS:

*** tangle
1. Header arguments
   1) :tangle no

      The default.

   2) :tangle yes

      Include the code in the tangled output with the same name of the
      org file

   3) :tangle filename

      Specify the filename of the tangled output

2. Function
   | C-c C-v t | org-babel-tangle      | tangle the current file |
   | C-c C-v f | org-babel-tangle-file | choose a file to tangle |
**** #+header: :tangle
+ :tangle no  --- default, tangle nothing
+ :tangle yes --- tangle output to file with the same name of the org-file
+ :tangle filename --- tangle output  the specified name

**** cmd
1. org-babel-tangle
   + tangle the current file
   + C-c C-v t
   + With prefix argument only tangle the current code block
2. org-babel-tanle-file
   + choose a file to tangle
   + C-c C-v f

*** :padline
**** what
Control in insertion of padding lines around code block bodies in
tangled code files. The default value is yes which results in
insertion of newlines before and after each tangled code block. The
following arguments are accepted.
+ yes: Insert newlines before and after each code block body in tangled
  code files.
+ no: Do not insert any newline padding in tangled output.
**** why
The  *org-babel-tangle-jump-to-org* function provides this jumping
from code to Org-mode functionality.

Two header arguments are required for jumping to work,
+ first the padline option must be set to true ,
+ second the comments header argument must be set to links, which will
  insert comments into the source code buffer which point back to the
  original Org-mode file.

*** :results

|-----------------+--------------------------+-------------------------------------|
|                 | Non-session              | session                             |
|-----------------+--------------------------+-------------------------------------|
| :results value  | value of last expression | value of last expression            |
| :results output | contents of STDOUT       | concatenation of interperter output |
|-----------------+--------------------------+-------------------------------------|

Note: With *:results value*, the result in both :session and
non-session is return to the Org mode as *a table* when appropriate.

*** org-src-lang-mode
org-src-lang-modes: Alist mapping languages to their major mode.

org-src-lang-modes is a variable defined in `org-src.el'.
Its value is shown below.

Documentation:
Alist mapping languages to their major mode.
The key is the language name, the value is the string that should
be inserted as the name of the major mode.  For many languages this is
simple, but for language where this is not the case, this variable
provides a way to simplify things on the user side.

*** cmake                                                           :cmake:
以cmake-mode进行语法高亮，其它功能不需要
**** settings
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-src-lang-modes '("html" . nxhtml))
  (add-to-list 'org-src-lang-modes '("browser" . nxhtml))
  (add-to-list 'org-src-lang-modes '("php" . php))
  (add-to-list 'org-src-lang-modes '("cmake" . cmake))
#+END_SRC

*** org-emphasis-alist
**** org-emphasis=alist
Alist of characters and faces to emphasize text.

+ abc
+ /abc/
+ _abc_
+ *abc*
+ @abc@ (nothing)
+ =abc= (不断行)
+ ~abc~ (verb)
+ +abc+

#+BEGIN_EXAMPLE
  \begin{itemize}
  \item abc
  \item \emph{abc}
  \item \uline{abc}
  \item \textbf{abc}
  \item @abc@ (nothing)
  \item \texttt{abc} (不断行)
  \item \verb~abc~ (verb)
  \item \sout{abc}
  \end{itemize}
#+END_EXAMPLE

+ for local file

**** for local file
#+BEGIN_EXAMPLE
  # Local Variables:
  # org-emphasis-alist: (everything but strike through)
  # End:
#+END_EXAMPLE

**** 注： 前后最好有空格，不能有中文字符
*** php                                                               :php:
+ https://github.com/steckerhalter/ob-php


+ prequist
  - php : sudo apt-get install php5-cli
  - session prequist: boris
+ install and settings
+ demo
  #+begin_src php :var x="bear" :var y="mordor"
    4 + 4;
    print "dude\n";
    print $x;
    return $y;
  #+end_src

  #+results:
  : mordor

*** html                                                             :html:
+ https://github.com/krisajenkins/ob-browser


1. what?

   o write html blocks in org-mode and have them automagically
   rendered as screenshots

2. install and setting

   + mepla
   + path to phantmjs exec

3. mode

   默认关联html-mode，可以通过配置 *org-src-lang-modes* 变量进行修改

4. org babel argument

   :out path/to/screenshot

5. demo
   #+begin_src browser :out 201504282212.png
     <!doctype html>
     <html>
         <head>
             <link href="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.2/css/bootstrap.min.css" rel="stylesheet" media="screen">
         </head>
         <body>
             <div class="row">
                 <div class="span6 offset1">
                     <h1>rendered png</h1>

                     <button class="btn btn-primary">you can't press this</button>
                 </div>
             </div>
         </body>
     </html>
   #+end_src

   #+results:
   [[file:/tmp/demo.png]]

*** sh                                                                 :sh:
http://stackoverflow.com/questions/29163164/how-can-i-load-bash-as-opposed-to-sh-in-org-babel-to-enable-begin-src-bash


org babel的shell块默认使用sh执行，ubuntu默认使用的是bash，sh和bash大同
小异，但毕竟差异是存在的。

设置org babel通过bash执行shell代码块，方法有二
1. 在.emacs中更改变量 *org-babel-sh-command* 为 bash
   #+begin_src emacs-lisp
     (setq org-babel-sh-command "bash")
   #+end_src

   org-babel-sh-command is a variable defined in `ob-sh.el'. its value
   is "sh"

2. 在shell代码块前设置头参数 *:shebang* "#!/bin/bash"

*** gnuplot error                                                 :gunplot:

org-babel-execute:gnuplot: cannot open load file: no such file or
directory, gnuplot

ans: installing gnuplot.el (to drive gnuplot inside emacs)[mepla]
*** lstlisting                                                   :listings:
org-latex-listings-langs:

alist mapping languages to their listing language counterpart.
the key is a symbol, the major mode symbol without the "-mode".
the value is the string that should be inserted as the language
parameter for the listings package.  if the mode name and the
listings name are the same, the language does not need an entry
in this list - but it does not hurt if it is present.

*** listing                                                      :listings:
1. org-latex-listings

   non-nil means export source code using the listings package.

2. org-latex-listings-langs

   alist mapping languages to their listing language counterpart. the
   key is a symbol, the major mode symbol without the "-mode". the
   value is the string that should be inserted as the language
   parameter for the listings package.  if the mode name and the
   listings name are the same, the language does not need an entry in
   this list - but it does not hurt if it is present.

3. org-latex-listings-options

   association list of options for the latex listings package.

   these options are supplied as a comma-separated list to the
   \textbackslash{}lstset command.  each element of the association
   list should be a list containing two strings: the name of the
   option, and the value.  for example,
   #+begin_example
     (setq org-latex-listings-options
         '(("basicstyle" "\\small")
           ("keywordstyle" "\\color{black}\\bfseries\\underbar")))
   #+end_example

*** org source highlight
以cmake-mode进行语法高亮，其它功能不需要
**** org-src-lang-modes

org-src-lang-modes is a variable defined in `org-src.el'.
Its value is shown below.

Documentation:
Alist mapping languages to their major mode.
The key is the language name, the value is the string that should
be inserted as the name of the major mode.  For many languages this is
simple, but for language where this is not the case, this variable
provides a way to simplify things on the user side.

**** settings
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-src-lang-modes '("html" . nxhtml))
  (add-to-list 'org-src-lang-modes '("browser" . nxhtml))
  (add-to-list 'org-src-lang-modes '("php" . php))
  (add-to-list 'org-src-lang-modes '("cmake" . cmake))
#+END_SRC
*** DONE org babel minted是否可能
- State "DONE"       from "TODO"       [2015-11-23 一 20:26]

1. 变量： *org-latex-listings*
   #+BEGIN_SRC emacs-lisp
     ;; version lstlisting
     ;; (setq org-latex-listings t)
     ;; (setq org-latex-listings-options
     ;;       '(
     ;;         ("numbers" "\left")
     ;;         ("xleftmargin" "17pt")
     ;;         ("frame" "single")
     ;;         ("breaklines" "true")
     ;;         ("breakautoindent" "true")
     ;;         ("numberstyle" "\\tiny")
     ;;         ("tabsize" "4")
     ;;         ("showspaces" "false")
     ;;         ))



     (require 'ox-latex)
     (add-to-list 'org-latex-packages-alist '("" "minted"))
     (setq org-latex-listings 'minted)
     (setq org-latex-listings-options
           '(("frame" "single")))

     (add-to-list 'org-latex-listings-langs '(sh "bash")) ;
     (add-to-list 'org-latex-listings-langs '(cpp "cpp"))

   #+END_SRC

2. org-latex-listings-option 不要过多的选项了
   These options are supplied as a comma-separated list to the
   \textbackslash{}lstset command.
   所以对 minted 无效

3. org-latex-listings-langs
   (add-to-list 'org-latex-listings-langs '(sh "bash"))
   前者产LaTeX宏包选项，后者是Emacs mode选项，用于语法高亮

4. 参考
   +
     [[https://app.yinxiang.com/shard/s52/nl/11551545/3a446fb2-846d-41b1-bb43-7b3df39f5121/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D1513455a069%3AS%3Dac803e9b3af5432a7cb467ac0240b297][babel minted]]

** image                                                             :image:
*** (org-display-inline-images)
- State "DONE"       from ""           [2015-12-07 一 13:52]

Normally only links without a description part are inlined, because
this is how it will work for export.

**** reference
[[help:org-display-inline-images][help:org-display-inline-image]]

**** key note

1. inline

   Normally only *links* /without a description part/ are inlined,
   because this is how it will work for export.

   #+BEGIN_EXAMPLE
   [[path/to/image]]  # OK
   file: path/to/image
   #+END_EXAMPLE

**** key-bindings

由于常用，所以定制一个快捷键还是必须的

#+BEGIN_SRC emacs-lisp
  ;; toggle display of inline image links like [[path/to/figure]]
  (define-key org-mode-map "\C-zi" 'org-display-inline-images)
#+END_SRC

*** org-mode 不显示图片                                             :image:
(iimage-mode)

** Structure Editing
*** 视图循环
|-------+----------------------------------------------------------|
| TAB   | 子树循环，在FOLDED-CHILDREN-SUBTREE之间循环，C-u使用前缀 |
|-------+----------------------------------------------------------|
| S-TAB | 全局循环                                                 |
|-------+----------------------------------------------------------|

*** 移动
|---------+--------------|
| C-c C-n | 下个标题     |
|---------+--------------|
| C-c C-p | 上个标题     |
|---------+--------------|
| C-c C-f | 下个同级标题 |
|---------+--------------|
| C-c C-b | 上个同级标题 |
|---------+--------------|
| C-c C-u | 回到上层标题 |
|---------+--------------|
*** 结构编辑
|----------------+----------------------------------------------|
| M-TAB          | 插入一个同级标题                             |
|----------------+----------------------------------------------|
| M-S-TAB        | 插入一个和当前标题同级的TODO项               |
|----------------+----------------------------------------------|
| TAB            | 如果新的条目中还没有文字，则调整到合适的级别 |
|----------------+----------------------------------------------|
| M-LEFT/RIGHT   | 将当前标题提升/降低一个等级                  |
|----------------+----------------------------------------------|
| M-S-LEFT/RIGHT | 将当前子树提升/降低一个等级                  |
|----------------+----------------------------------------------|
| M-S-UP/DOWN    | 将当前子树上/下移                            |
|----------------+----------------------------------------------|
| C-c C-w        | 将条目或区域传送到另外一个文件中             |
|----------------+----------------------------------------------|
| C-c n s/w      | 将缓冲区试图局限到当前子树中/再次放宽视图    |
|----------------+----------------------------------------------|
*** 行内源码 inline source code
+ http://stackoverflow.com/questions/16186843/inline-code-in-org-mode

**** = embedded code =
This is a =\inline \source \code=. The exported latex code is
embedded in =\texttt=, instead of =\verb=. And the result shows that
the =\= is converted to =\textbackslash{}= even followed by
"reasonable" command name.

**** inline code syntax
inline code blocks have the form src_LANG[headers]{your code}

+ note: 在行内和单独成段导出latex的行为不一样，很奇怪。

*** org-structure-template-alist 快速扩展
http://orgmode.org/manual/Include-files.html


用org-mode写文章的时候,经常需要引用代码片段,这就需要输入#+BEGIN_SRC
... #+END_SRC 或者 #+BEGIN_EXAMPLE ... #+END_EXAMPLE。可以用
宏,elisp,yasnippets,或者skeleton来实现自动化.
org-mode内置了快速输入的方法
+ *输入<s,再键入TAB*,就会自动展开成#+BEGIN_SRC #+END_SRC
+ *输入>s,再键入TAB*,就会自动展开成#+BEGIN_EXAMPLE  #+END_EXAMPLE

#+BEGIN_EXAMPLE
<l -> begin_src latex
<p -> \begin{python}
<c -> \begin{cpp}
<[ -> \left[\right] [不行，改成k
<{ -> \left\{\right\} 同样，
<a -> \begin{algorithm}[ht]
#+END_EXAMPLE

This is a list of abbreviation keys and values.  The value gets inserted
if you type `<' followed by the key and then press the completion key,
usually `M-TAB'.

+ %file will be replaced by a file name after prompting for the file
  using completion.
+ The cursor will be placed at the position of the `?` in the
  template.

#+BEGIN_SRC emacs-lisp
  (setq org-structure-template-alist
        '(("s" "#+BEGIN_SRC ?\n\n#+END_SRC" "<src lang=\"?\">\n\n</src>")
         ("e" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE" "<example>\n?\n</example>")
         ("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE" "<quote>\n?\n</quote>")
         ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE" "<verse>\n?\n</verse>")
         ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM" "<verbatim>\n?\n</verbatim>")
         ;; ("c" "#+BEGIN_CENTER\n?\n#+END_CENTER" "<center>\n?\n</center>")
         ("l" "#+BEGIN_LaTeX\n?\n#+END_LaTeX" "<literal style=\"latex\">\n?\n</literal>")
         ("L" "#+LaTeX: " "<literal style=\"latex\">?</literal>")
         ("h" "#+BEGIN_HTML\n?\n#+END_HTML" "<literal style=\"html\">\n?\n</literal>")
         ("H" "#+HTML: " "<literal style=\"html\">?</literal>")
         ;; ("a" "#+BEGIN_ASCII\n?\n#+END_ASCII" "")
         ("A" "#+ASCII: " "")
         ("i" "#+INDEX: ?" "#+INDEX: ?")
         ("I" "#+INCLUDE: %file ?" "<include file=%file markup=\"?\">")
         ("p" "#+begin_latex\n\\begin{python}\n?\n\\end{python}\n#+end_latex")
         ("c" "#+begin_latex\n\\begin{cpp}\n?\n\\end{cpp}\n#+end_latex")
         ("k" "\\left[?\\right]")
         ("K" "\\left\{?\\right\}")
         ("a" "#+begin_latex\n\\begin{algorithm}\n?\n\\end{algorithm}\n#+end_latex")
         )
        )
#+END_SRC

*** org-mode 不要吝啬使用标题，吝啬使用多级列表
*** Include files                                                 :include:

During export, you can include the content of another file. For
example, to include your .emacs file, you could use:
#+BEGIN_EXAMPLE
  ,#+INCLUDE: "~/.emacs" src emacs-lisp
#+END_EXAMPLE

The optional second and third parameter are the markup (i.e.,
‘example’ or ‘src’), and, if the markup is ‘src’, the language
for formatting the contents. The markup is optional; if it is not
given, the text will be assumed to be in Org mode format and will be
processed normally.

Contents of the included file will belong to the same structure
(headline, item) containing the INCLUDE keyword. In particular,
headlines within the file will become children of the current
section. That behavior can be changed by providing an additional
keyword parameter, :minlevel. in that case, all headlines in the
included file will be shifted so the one with the lowest level reaches
that specified level. For example, to make a file become a sibling of
the current top-level headline, use
#+BEGIN_EXAMPLE
  ,#+INCLUDE: "~/my-book/chapter2.org" :minlevel 1
#+END_EXAMPLE


默认情况下，被包含org文件的标题会依次升/降级，使最高级标题为当前化位点
(point)的次级子标题，文件层级关系保持不变。

注：是 :minlevel 而还是 :minilevel

You can also include a portion of a file by specifying a lines range
using the :lines parameter. The line at the upper end of the range
will not be included. The start and/or the end of the range may be
omitted to use the obvious defaults.
#+BEGIN_EXAMPLE
  ,#+INCLUDE: "~/.emacs" :lines "5-10"   Include lines 5 to 10, 10 excluded
  ,#+INCLUDE: "~/.emacs" :lines "-10"    Include lines 1 to 10, 10 excluded
  ,#+INCLUDE: "~/.emacs" :lines "10-"    Include lines from 10 to EOF
#+END_EXAMPLE

#+TITLE: Tiger
#+AUTHOR: Tiger D Wong
#+EMAIL: buaaben@163.com

C-c ' --- Visit the include file at point.

*** reverse headlines 标题逆序                                       :sort:

[[http://stackoverflow.com/questions/12874595/reverse-notes-order-in-org-mode][stackoverflow]]

*利用宏和寄存器*

i don't think there is a predefined command you are looking for. you
can implement it by yourself.

if it's a one-time task i would use emacs macro:

you show only top-level headlines. then you go to the first headline
and start macro c-x ( . you select the line c-space c-n and you type
*c-u m-x prepend-to-register .* c-u deletes the line as well. you stop
the macro c-x ) .

now you repeat the macro for all top-level headlines *m-0 c-x e* .

and you insert the register *c-x r i .*

prepend-to-register 压入寄存器，有点像入栈。

栈的思想。
** Table
*** 创建和转换
C-c | *org-table-convert-region* 将活动区域转换为表格，以TAB，逗号或空白
符划分区域。

*** 调整和移动区域
|---------+----------------------------------------|
| C-c C-c | 调整表格，不移动光标                   |
|---------+----------------------------------------|
| TAB     | 将光标移动到下一个区域，必要时新建一行 |
|---------+----------------------------------------|
| S-TAB   | 将光标移动到上一个区域                 |
|---------+----------------------------------------|
| RET     | 将光标移动到下一行，必要时新建一行     |
|---------+----------------------------------------|
*** 编辑行和列
|--------------+------------------------------------------------------------------|
| M-LEFT/RIGHT | 左/右以当前列                                                    |
|--------------+------------------------------------------------------------------|
| M-S-LEFT     | 删除当前列                                                       |
|--------------+------------------------------------------------------------------|
| M-S-RIGHT    | 在光标位置左边添加一列                                           |
|--------------+------------------------------------------------------------------|
| M-UP/DOWN    | 上/下移动当前行                                                  |
|--------------+------------------------------------------------------------------|
| M-S-UP       | 删除当前行                                                       |
|--------------+------------------------------------------------------------------|
| M-S-DOWN     | 在当前行上面添加一行，如果有前缀，则在下面添加一行               |
|--------------+------------------------------------------------------------------|
| C-c -        | 在当前行下面添加一行一个水平线，如有前缀，则在上面添加一行水平线 |
|--------------+------------------------------------------------------------------|
| C-c ^        | 将表格排序，以当前位置所在的列作为依据                           |
|              | 排序在局当前位置最间的两个水平线之间的行（或者整个表）中进行     |
|--------------+------------------------------------------------------------------|
*** org表格中使用"|"
http://www.newsmth.net/nForum/#!article/Emacs/109231

\textbackslash{}vert

*** DONE [#C] org中如何使用 "|"
DEADLINE: <2015-03-15 日>
- State "DONE"       from "TODO"       [2015-03-17 二 11:29]
- State "TODO"       from ""           [2015-03-04 三 14:20]
 Date:<2015-02-26 四>

 只要行首不是 | 就可以了, 就像这样 |.

** List
** Link
*** 内部链接                                                       :anchor:
Org-mode支持内部链接：
#+BEGIN_EXAMPLE
  定义锚点 #<<my-anchor>>
  [[my-anchor][内部链接]]
#+END_EXAMPLE
*** 外部链接
对于符合链接规则的内容，org-mode会自动将其视为链接，包括括文件、网页、邮
箱、新闻组、BBDB 数据库项、IRC 会话和记录等。下面是一些例子：
#+BEGIN_EXAMPLE
  http://www.astro.uva.nl/~dominik            on the web
  file:/home/dominik/images/jupiter.jpg       file, absolute path
  /home/dominik/images/jupiter.jpg            same as above
  file:papers/last.pdf                        file, relative path
  file:projects.org                           another Org file
  docview:papers/last.pdf::NNN                open file in doc-view mode at page NNN
  id:B7423F4D-2E8A-471B-8810-C40F074717E9     Link to heading by ID
  news:comp.emacs                             Usenet link
  mailto:adent@galaxy.net                     Mail link
  vm:folder                                   VM folder link
  vm:folder#id                                VM message link
  wl:folder#id                                WANDERLUST message link
  mhe:folder#id                               MH-E message link
  rmail:folder#id                             RMAIL message link
  gnus:group#id                               Gnus article link
  bbdb:R.*Stallman                            BBDB link (with regexp)
  irc:/irc.com/#emacs/bob                     IRC link
  info:org:External%20links                   Info node link (with encoded space)
#+END_EXAMPLE

对于文件链接，可以用::后面增加定位符的方式链接到文件的特定位置。定位符可
以是行号或搜索选项。如：
#+BEGIN_EXAMPLE
  file:~/code/main.c::255                     进入到 255 行
  file:~/xx.org::My Target                    找到目标‘<<My Target>>’
  file:~/xx.org/::#my-custom-id               查找自定义 id 的项
#+END_EXAMPLE

除了上述的自动链接外，还可以显示指定链接，采用如下格式：
#+BEGIN_EXAMPLE
  [[link][description]]
  [[link]]
#+END_EXAMPLE

显示指定的链接可以不显示原始的URL而是显示对该链接的描述。这种方式可以用
相对路径链接本地文件。
*** 快捷键
|---------+-------------------+--------------------------------------|
| C-c l   |                   | 保存链接                             |
| C-c C-l | org-insert-link   | 创建或修改链接，可以引用已保存的链接 |
| C-c C-o | org-open-at-point | 打开链接                             |
|---------+-------------------+--------------------------------------|

|-------+------------------------|
| C-c % | 记录内部链接地址       |
| C-c & | 跳转到已记录的内部链接 |
|-------+------------------------|
*** org-open-at-point
+ It is bound to C-c C-o
+ (org-open-at-point &optional ARG REFERENCE-BUFFER)
+ Open link at or after point.
+ If there is no link at point, this function will search forward up
  tothe end of the current line.
+ Normally, files will be opened by an appropriate application.
+ If the optional prefix argument ARG is non-nil, Emacs will visit the
  file.

*** org中想要使插入的图片显示以及生成的PDF带有图片,需要使用方括号括起的链接形式,而非file等开头的链接形式.
#+BEGIN_EXAMPLE
[[~/Picture/demo.png]]   OK
file:~/Picture/demo.png  Not OK
#+END_EXAMPLE

file:~/Temp/1335.org
[[~/Temp/1335.org]]
file:~/Temp/1335.org::2

*** 脚注
|-----------+------------------------------------------------------|
| C-c C-x f | 新建一个脚注，当有前缀时，会提供一个菜单以供选择操作 |
|           | 或者在定义和引用之间跳转                             |
|-----------+------------------------------------------------------|
| C-c C-c   | 在定义和引用之间跳转                                 |
|-----------+------------------------------------------------------|

*** org link                                                         :link:

|---------+-------------------|
| C-c l   | org-store-link    |
| C-c C-l | org-insert-link   |
| C-c C-o | org-open-at-point |
|---------+-------------------|

**** org-store-link
org-store-link is an interactive autoloaded compiled Lisp function in
`org.el'.

It is bound to C-c l.

(org-store-link ARG)

Store an org-link to the current location.

**** org-insert-link
C-c C-l runs the command org-insert-link, which is an interactive
compiled Lisp function in `org.el'.

It is bound to C-c C-l, <menu-bar> <Org> <Hyperlinks> <Insert Link>.

(org-insert-link &optional COMPLETE-FILE LINK-LOCATION
DEFAULT-DESCRIPTION)

Insert a link.  At the prompt, enter the link.

**** org-open-at-point
C-c C-o runs the command org-open-at-point, which is an interactive
compiled Lisp function in `org.el'.

It is bound to C-c C-o, <menu-bar> <Org> <Hyperlinks> <Follow Link>.

(org-open-at-point &optional ARG REFERENCE-BUFFER)

Open link at or after point.
If there is no link at point, this function will search forward up to
the end of the current line.
Normally, files will be opened by an appropriate application.  If the
optional prefix argument ARG is non-nil, Emacs will visit the file.
With a double prefix argument, try to open outside of Emacs, in the
application the system uses for this file type.

*** org-return-follows-link

修改回车键的作用为打开point处的链接，与C-c C-o行为相同

Its value is t
Original value was nil

Documentation:
Non-nil means on links RET will follow the link.
In tables, the special behavior of RET has precedence.

#+BEGIN_SRC emacs-lisp
(setq org-return-follows-link t)
#+END_SRC

*** org open link programs                                       :pdf:wine:

why *使用 wine foxitreader 打开 PDF 链接*
**** *org-file-apps*
#+BEGIN_EXAMPLE
  Its value is ((auto-mode . emacs)
   ("\\.mm\\'" . default)
   ("\\.x?html?\\'" . default)
   ("\\.pdf\\'" . default))


  Documentation:
  External applications for opening `file:path' items in a document.
  Org-mode uses system defaults for different file types, but
  you can use this variable to set the application for a given file
  extension.  The entries in this list are cons cells where the car identifies
  files and the cdr the corresponding command.  Possible values for the
  file identifier are
   "string"    A string as a file identifier can be interpreted in different
                 ways, depending on its contents:

                 - Alphanumeric characters only:
                   Match links with this file extension.
                   Example: ("pdf" . "evince %s")
                            to open PDFs with evince.

                 - Regular expression: Match links where the
                   filename matches the regexp.  If you want to
                   use groups here, use shy groups.

                   Example: ("\.x?html\'" . "firefox %s")
                            ("\(?:xhtml\|html\)" . "firefox %s")
                            to open *.html and *.xhtml with firefox.

                 - Regular expression which contains (non-shy) groups:
                   Match links where the whole link, including "::", and
                   anything after that, matches the regexp.
                   In a custom command string, %1, %2, etc. are replaced with
                   the parts of the link that were matched by the groups.
                   For backwards compatibility, if a command string is given
                   that does not use any of the group matches, this case is
                   handled identically to the second one (i.e. match against
                   file name only).
                   In a custom lisp form, you can access the group matches with
                   (match-string n link).

                   Example: ("\.pdf::\(\d+\)\'" . "evince -p %1 %s")
                       to open [[file:document.pdf::5]] with evince at page 5.

   `directory'   Matches a directory
   `remote'      Matches a remote file, accessible through tramp or efs.
                 Remote files most likely should be visited through Emacs
                 because external applications cannot handle such paths.
  `auto-mode'    Matches files that are matched by any entry in `auto-mode-alist',
                 so all files Emacs knows how to handle.  Using this with
                 command `emacs' will open most files in Emacs.  Beware that this
                 will also open html files inside Emacs, unless you add
                 ("html" . default) to the list as well.
   t             Default for files not matched by any of the other options.
   `system'      The system command to open files, like `open' on Windows
                 and Mac OS X, and mailcap under GNU/Linux.  This is the command
                 that will be selected if you call `C-c C-o' with a double
                 C-u C-u prefix.

  Possible values for the command are:
   `emacs'       The file will be visited by the current Emacs process.
   `default'     Use the default application for this file type, which is the
                 association for t in the list, most likely in the system-specific
                 part.
                 This can be used to overrule an unwanted setting in the
                 system-specific variable.
   `system'      Use the system command for opening files, like "open".
                 This command is specified by the entry whose car is `system'.
                 Most likely, the system-specific version of this variable
                 does define this command, but you can overrule/replace it
                 here.
   string        A command to be executed by a shell; %s will be replaced
                 by the path to the file.
   sexp          A Lisp form which will be evaluated.  The file path will
                 be available in the Lisp variable `file'.
#+END_EXAMPLE

**** setting
#+BEGIN_SRC emacs-lisp
  (setq org-file-apps '((auto-mode . emacs)
                        ("\\.mm\\'" . default)
                        ("\\.x?html?\\'" . default)
                        ;; ("\\.pdf\\'" . "evince %s")
                        ("\\.pdf\\'" . "wine \'C:\\Program Files\\Foxit Software\\Foxit Reader\\FoxitReader.exe\' ../../../../%s")
                        ))
#+END_SRC

*wine必须的路径必须相对于wine启动路径，支持 .. , 不支持 ~ 和绝对路径。*

../../../../是从journal.org到时/的相对路径。



**** 测试

[[/usr/local/texlive/2014/texmf-dist/doc/latex/minted/minted.pdf]]

[[/media/ben/Reserch/Document/Programming/C++/Boost/Boost库学习指南.pdf]]

[[/media/ben/Reserch/Document/嵌入式系统/ARM/ARM Architecture Reference Manual.pdf]]

太繁琐！！！

文件中有空格也可以。

*** DONE Emacs后台进程管理
- State "DONE"       from "TODO"       [2015-11-25 三 14:07] \\
  proced

*M-x proced*

*** 使用 chromuium 打开 org-mode 中的网页链接                 :link:chrome:

1. why
   + 良好的可视化
   + 双显示器

2. how

   1) browse-url-browser-funtion
      #+BEGIN_SRC emacs-lisp
        (setq browse-url-browser-function 'browse-url-generic
              browse-url-generic-program "chromium-browser")
      #+END_SRC

   2) org-file-apps: External applications for opening *=file:path=* items in a document.

      #+BEGIN_SRC emacs-lisp
        (setq org-file-apps '((auto-mode . emacs)
                              ("\\.mm\\'" . default)
                              ("\\.x?html?\\'" . default)
                              ;; ("\\html\\'" . "chromium-browser %s")
                              ;; ("\\.pdf\\'" . "evince %s")
                              ("\\.pdf\\'" . "wine \'C:\\Program Files\\Foxit Software\\Foxit Reader\\FoxitReader.exe\' ../../../../%s")
                              ("\\.chm\\'" . "xchm %s")
                              ))
      #+END_SRC

      将浏览 html 链接的方式改为 'system' 和 'chromium-browser %s' 均
      无效.

3. test

   OK，鼠标焦点依然停留在 Emacs 上。

4. reference

   + [[http://stackoverflow.com/questions/4506249/how-to-make-emacs-org-mode-open-links-to-sites-in-google-chrome][stackoverflow: how to make emacs org-mode open links to sites in Google chrome]]

   + [[help:org-file-apps][help: org-file-apps]]

*** 去Link化，只保留description, pandoc ROS 文档的问题

- State "DONE"       from "TODO"       [2015-12-08 二 13:35]

1. /正则替换/ ，很简单

2. 没有必要，网页的可视化比 ORG 要好，所以 *除非必要不要使用pandoc将网
   页转换为PDF*

** Tag                                                               :tag:
*** why tag?
对于信息的管理，有两种方式:
+ 分类(category)
+ 标签(tag)

|---------+----------------------------------------|
| C-c C-q | 为当前标题输入标签 前缀C-u可以对齐标签 |
|---------+----------------------------------------|

*** 标签作用
这两种方式各有特点:通常分类是固定的，很少变化，而tag随时可以增加。分类
通常表现为树状结构，比较清晰，但是树状结构过于简单，不能表达复杂的信息。
比如，如果有多个分类树，处理起来就会比较麻烦。

所以，这两种方式通常结合起来使用。比如blog系统中，通常既支持文章的分类
（树），又支持为每篇文章作tag标记。

org-mode作为最好的文档编辑利器 ，在支持文内大纲（也是树状结构）的同时，
还方便的支持tag功能。tag可以在多篇文档中共用。

*** 标记tag
**** tag格式

在Org-mode中，可以对 *标题* 增加tag标记。标记的格式如下：
#+BEGIN_EXAMPLE
  跟特留尼西特握手                    :苦差:薪水:逃不掉:
#+END_EXAMPLE

**** 继承

而且Org-mode的标签自动按照大纲树的结构 *继承* 。即子标题自动继承父标题的标
签。比如：
#+BEGIN_EXAMPLE
  ,* Meeting with the French group     :work:
  ,** Summary by Frank                 :boss:notes:
  ,*** TODO Prepare slides for him     :action:
#+END_EXAMPLE

则最后一行标题具有 work, boss, notes, action 四个标签。

**** 元数据 *FILETAGS*

如果希望文档中的所有标题都具有某些标签，只需要定义文档元数据：
#+BEGIN_EXAMPLE
  ,#+FILETAGS: :peter:boss:secret:
#+END_EXAMPLE

**** 快捷键
*** 预定义标签
上面提到，除了可以输入标签外，还可以从预定义的标签中进行选择。预定义的
方式有两种：
**** 元数据 *TAGS*
这种方式预定义的标签只能在当前文件中使用。使用#+TAGS元数据进行标记，如：
#+BEGIN_EXAMPLE
  ,#+TAGS: { 桌面(d) 服务器(s) }  编辑器(e) 浏览器(f) 多媒体(m) 压缩(z)
#+END_EXAMPLE

+ 每项之间必须用 *空格分隔*
+ 可以在括号中定义一个 *快捷键*
+ 花括号里的为 *标签组* ，只能选择一个
+ 对标签定义进行修改后，要在标签定义的位置按 *C-c C-c* 刷新才能生效。

**** 全局配置
 在配置文件中定义上面的标签定义只能在当前文件生效，如果要在所有的.org
 文件中生效，需要在 Emacs 配置文件 .emacs 中进行定义：
 #+BEGIN_EXAMPLE
   (setq org-tag-alist '(

                       (:startgroup . nil)
                            ("桌面" . ?d) ("服务器" . ?s)
                       (:endgroup . nil)
                       ("编辑器" . ?e)
                       ("浏览器" . ?f)
                       ("多媒体" . ?m)
                       ))
 #+END_EXAMPLE

默认情况下，org会动态维护一个Tag列表，即当前输入的标签若不在列表中，则
自动加入列表以供下次补齐使用。

为了使这几种情况（默认列表、文件预设tags，全局预设tags）同时生效，需要
在文件中增加一个空的TAGS定义：
#+BEGIN_EXAMPLE
  ,#+TAGS:
#+END_EXAMPLE

*** 按标签搜索
|---------+----------------------------------------------|
| C-c \   | 按标签搜索标题                               |
| C-c / m | 搜索并按树状结构显示                         |
| C-c a m | 按标签搜索多个文件(需要将文件加入全局agenda) |
|---------+----------------------------------------------|

可使用逻辑表达式限制条件
|------+------+--------+--------------------------------|
| +    | 和   | a+b    | 同时有这两个标签               |
| -    | 排除 | a-b    | 有 a 但没有 b                  |
| 竖线 | 或   | a竖线b | 有 a 或者有 b                  |
| &    | 和   | a&b    | 同时有 a 和 b，可以用“+”替代 |
|------+------+--------+--------------------------------|

*** DONE 标签全部改为小写字母
- State "DONE"       from "TODO"       [2015-11-23 一 18:54]
CLOCK: [2015-11-23 一 18:31]--[2015-11-23 一 18:54] =>  0:23

1. 方便搜索与定制
2. 正则替换
3. 末尾冒号

正则替换大小写， +不会+
使用Eamcs键盘宏解决
** GTD                                                                 :gtd:
*** GTD overview
**** GTD精要

GTD(Getting Things Done) 是一种将繁重超负荷的工作生活方式变成无压力高效
的时间管理系统（David Allen，《Getting Things Done-The Art of
Stress-Free Productivity》。其核心是把所有要做的事情都记录下来，然后整理
组织，并逐一执行。也就是 *收集*, *整理*, *组织*, *回顾*, *执行* 五个过
程，如下图：

+ 收集：把接收到的各种事件集中在一起；
+ 整理：对事件做出快速判断，决定直接抛弃、留存归档或是产生一个任务；
+ 组织：根据任务的不同属性将其归入不同的工作清单；
+ 回顾：定期检查工作清单，如果条件成熟就进行处理；
+ 执行：对于可以处理的任务进行处理，并归档。

GTD的核心理念概括一句话，就是：你必须记录下来你要做的事，然后整理，并
安排自己去逐一执行。

整理和组织
***** 收集
一个交易系统，如果存储了大量的历史信息，就会负担过重，甚至无法有效处理新
的交易。同样，如果大脑中存放了大量的“杂事”，不但会增加焦虑感，甚至会排挤
掉真正有意义的思考，徒然损耗精力。清空大脑，可让人气定神闲，总是处于一切
就绪的状态，从容高效的提升决策的品质和做事的效率。所以需要把每一个悬而未
决的杂事都从大脑中拿出来，存储在外部的收集系统。
***** 整理
但是仅仅收集还不够，如果这些事情没有安排妥当，还是会让人感觉不安。当杂事
收集到一定程度是，要对其进行整理。抛弃掉没用的垃圾和暂时不用考虑的参考信
息，剩下的就是需要关注的任务。对于收集到的杂事，应该定期整理以便尽量控制
其数量，最好达到清空的状态。在整理的时候，要做到以下两点：

+ 从头到尾：平等对待所有杂事，逐一处理，不避不拖。
+ 一次一事：专注于每一件杂事，心无旁骛的判断当前杂事的实质，不要同时考
  虑下一件。

进一步，可以快速判断这个任务的特征：是否可以在2分钟内解决？如果可以就马
上解决掉。如果不能，还需要进一步判断任务的重要程度，谁来做，什么时候做，
在哪里做，并根据这些特征将任务分配到不同的工作列表。最后，如果这个任务属
于一个很多任务组成的“项目”，还需要为其打上该项目的标签。

大概80%以上的任务都可以如上略作思考就可得知下一步行动，15%的项目只要简单
的借助辅助手段（如MindMap等工具）稍加记录即可，只有5%重大复杂的项目任务
 需要通盘筹算。

**** 如何进行GTD
任何需要关注的事件，如mail, 电话，IM，口头交流，网页，文档，想法等，都有
可能产生新的任务。收集环节要把这些需要关注的事件都记录下来。
***** 收集
任何需要关注的事件，如mail, 电话，IM，口头交流，网页，文档，想法等，都有
可能产生新的任务。收集环节要把这些需要关注的事件都记录下来。

*所以需要一个收集箱（Inbox)，能够随时快速启用，记录需要的信息* 。
***** 整理
在合适的时间梳理收件箱中的信息，抛弃掉没用的垃圾和暂时不用考虑的参考信息
，剩下的就是需要关注的任务。整理阶段的三种处理方式是：
  + 既不需要处理又无保留价值的信息，直接舍弃
  + 不需要处理但有保留价值的信息，归档留存
     比如，一篇有用的资料，以后可能会用到，需要归档已被查阅；一个很好的想
    法但由于时间、前提条件、考虑程度等因素不能马上投入行动，需要记录下来
    等等。
  + 需要处理的信息，创建一个任务

根据以上三种情况，整理阶段需要实现 ：
+ 删除无用的信息
+ 将信息归档
+ 创建任务

***** 组织
创建任务时，要有一个快速的判断，包括what（做什么），who（谁来做），when
（什么时候做），where（什么地点处理），why（为什么要做，可以用原始消息作
为原因），how（如何做），how much（需要多长时间）。这个判断要非常迅速，
并根据判断的结果对任务进行组织，以便后来的处理和查询，通常按照可以这样的
步骤分析：
1. 该任务是否属于一个项目？如果是，首先打上项目标记
2. 该任务能否在2分钟完成？如果是，马上处理，然后将任务标记为“已完成”
3. 根据重要性和紧迫性，为该任务划分优先级
4. 该任务是否需要别人处理？如果是，通知对方，然后将任务标记为“等待中”
5. 需要自己处理的任务，马上判断处理的地点/场合，并标记
6. 对于能够确定时间的任务（日程安排），标记计划处理时间，如果有截止日期
   ，也标记上

根据上述步骤，组织阶段需要的功能包括 ：
+ *将任务归入不同的工作清单*
+ *为任务增加标记*
+ *定义任务的完成状态*
+ *为任务定义优先级*
+ *为任务设定时间点*

***** 回顾
在合适的时机检查所有的任务，根据实际情况进行处理。建议的做法包括：

+ 每日回顾每天早上首先查看当日的日程表，然后检查待办任务清单，根据实际
  情况和当日的时间安排，以及当日的行程（地点），决定一天的工作计划。
+ 周期性回顾可以是每周，每月或更长的时间周期。回顾一段时间内所完成的事
  情，做出总结；同时根据实际情况的变化，调整下一阶段的计划。
+ 项目回顾项目是一系列任务的组合，并且任务之间存在依赖关系。根据项目的
  时间点，在适当的时机回顾整个项目的相关任务，进行总结或计划。

可以遵循”六个高度检视法“：
+ 5万英尺+：人生目的和价值观（面临重大变化和转折时）
+ 4万英尺：3~5年的展望（建议每年检视）
+ 3万英尺：1~2年的目标（建议每季检视）
+ 2万英尺：责任范围（建议每月检视）
+ 1万英尺：当前的项目（建议每周检视）
+ 跑道：下一步行动（建议每日检视）

3个较低层次的内容大多是针对事物当前状态（行动、项目、职责），再向上的
层次则主要涉及指导方向、目标取向等方面，需要在恰当的时机去关注需要关注的
方面，长远规划，掌控愿景，保持全方位的平衡。

回顾阶段需要 ：
+ *按时间段检索任务*
+ *按项目检索任务*
+ *处理任务间的依赖关系*
***** 执行
根据 情境是否合适 、 时间是否够用 、 精力是否充沛 、 任务是否重要 四个原
则来决定要进行哪项任务。因为经过前面的步骤已经周密严谨系统地考量过各项任
务，所以此时只需要用直觉判断即可。可以参考”四象限法则“：

 1. 给出任务的定性：重要/不重要，紧急/不紧急
 2. 按照”先轻重，再缓急“的原则，将任务按照”重要且紧急-重要不紧急-不重要
    但紧急-不重要不紧急“的顺序排序
 3. 对于划分到同一类型的任务，人为区分”高、中、低“的优先级
 4. 处理原则：
    + 重要且紧急：尽早动手，缓解压力
    + 重要不紧急：尽早计划，逐步完成
    + 不重要但紧急：寻求帮助，设定截止时间
    + 不重要不紧急: 冷却处理

每完成一项任务，就将该任务标记为“已完成”，并归档。

*为了帮助判断，需要支持任务的筛选、搜索和排序* 。

**** 使用ORG实现GTD
***** 定义任务
Org-mode认为，每一个任务通常会需要附带一些文字说明。所以Org-mode将标题作
为任务的载体。通过在标题上增加状态标记，来定义任务。由于大纲是分级的，所
以将标题定义为任务 *天然支持了子任务* ：可以在子标题上标记子任务。

|---------+---------------|
| C-c C-t | org-todo      |
| S-LEFT  | org-shiftleft |
| S-RIGHT | org-shiftright |
|---------+----------------|
***** 定义任务状态
Org-mode内置的任务状态只有两种： *TODO* 和 *DONE* 。如果需要更多的状态，
需要自己定义。
****** 元数据定义 *SEQ_TODO* or *TODO*
可以在文件内部定义任务状态：关键字应该各不相同，这样对于一个选项 Org 才
知道该用哪个状态序列（集合）。例子中也给出了快速使用一个关键字的方法，就
是在关键字后面括号中给出快捷字母——当用 C-c C-t时，会询问，让你输入一个字
母。

要自定义任务状态，可以使用文档元数据“#+SEQ_TODO：”，可以在文档的任何地方
定义，但是 *建议统一定义在文档头部*.

将光标放在这些内容上，输入 C-c C-c 可以直接生效。

#+BEGIN_EXAMPLE
  ,#+SEQ_TODO: REPORT(r) BUG(b) KNOWNCAUSE(k) | FIXED(f)
  ,#+SEQ_TODO: TODO(T!) | DONE(D@)3  CANCELED(C@/!)
#+END_EXAMPLE

+ 可以定义多组状态序列，每个“#+SEQ[TODO”行定义一组]
+ 状态之间用空格分隔
+ 可以在（）中定义附加选项，包括：
  - 字符：该状态的快捷键
  - ！：切换到该状态时会自动增加时间戳
  - @ ：切换到该状态时要求输入文字说明
  - 如果同时设定@和！，使用“@/!”
+ 用“|”分隔未完成状态和已完成状态。未完成状态在查询待办事项时会列出。
+ 如果不存在"|",则默认最后一个关键字为完成状态





****** 全局配置 org-todo-keywords
#+BEGIN_EXAMPLE
  (setq org-todo-keywords
      '((sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(k)" "|" "FIXED(f)")
        (sequence "TODO(T!)" "|" "DONE(D@)3" "CANCELED(C@/!)")
       ))
#+END_EXAMPLE

****** TYPE_TODO
除了状态序列外，还可以定义type，来标记任务的分类。可以参考[[http://orgmode.org/manual/TODO-types.html#TODO-types][这里]] 。

***** 设置任务优先级
在Org-mode中，还针对任务设定了A，B，C三种优先级，在安排日程的时候可以按
照优先级进行排序。为任务设定优先级是通过快捷键 *S-UP/DOWN*
|--------+---------------+---------------------------------------|
| S-UP   | org-shiftup   | increase priority of current headline |
| S-DOWN | org-shiftdown | decrease priority of current headline |
|--------+---------------+---------------------------------------|
***** 跟踪子任务
对于有多个子任务的上级任务，很常见的一个需求是随时跟踪子任务的完成情况。
Org-mode支持在上级任务上增加标记，当子任务的状态发生改变时自动更新上级任
务的完成情况。支持百分比和分数两种形式，类似[66%] 或者 [2/3]。

可以在上级任务标题中的任意位置插入 [%] 或者 [/], 当子任务的状态发生变化时
，会自动更新该位置的值。

注:
 1) 当改变子任务状态时，只更新上一级任务的完成情况，不可级联。
 2) 即使所有的子任务都完成，也只是标记上一级任务的完成情况为100%，而不能
    自动更新上级任务的完成状态。如果需要自动设定为完成，可以在.emacs中增
    加如下配置：
    #+BEGIN_EXAMPLE
      (defun org-summary-todo (n-done n-not-done)
        "Switch entry to DONE when all subentries are done, to TODO otherwise."
        (let (org-log-done org-log-states)   ; turn off logging
          (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

      (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
    #+END_EXAMPLE
***** 用复选框标记非标题类型的子任务
Org-mode还支持非标题形式的子任务。对于以
”[ ]“(*注意空格*)开头的列表，会被当作复选框。这样就形成了局部的子任
务，适用于将一个任务划分成几个简单的步骤。
pp#+BEGIN_EXAMPLE
  ,*** 一个任务 [0/2]
  该任务包含几个步骤：
  - [-] 步骤1 [1/2]
    - [X] 步骤1.1
    - [ ] 步骤1.2
  - [-] 步骤2 [1/2]
    - [X] 步骤2.1
    - [ ] 步骤2.2
#+END_EXAMPLE

|---------+----------------|
| C-c C-c | 改变复选框状态 |
| M-S-RET | 增加一个子项   |
|---------+----------------|


***** 查询任务
*C-c /            只列出包含搜索结果的大纲，并高亮，支持多种搜索方式*
***** 时间
Org-mode中的任务还可以设置计划时间(*SCHEDULED*)和截止时间(*DEADLINE*)，
方便任务的管理和排程。
****** 时间戳
在Org-mode中，将带有日期和时间信息的特定格式的字符串称为 *时间戳*。时
间戳使用”< >“进行标记，比如：
#+BEGIN_EXAMPLE
  <2005-10-01 Tue>
  <2003-09-16 Tue 09:39>
  <2003-09-16 Tue 12:00-12:30>
#+END_EXAMPLE

时间戳分为两种，上面的例子中的时间戳都标记了一个 *时间点*,另外一种时
间戳标记 *重复出现的多个时间点* 。使用时间点+ 间隔（天（d）、周（w）、
月（m）或者年（y））来表示。比如：
#+BEGIN_EXAMPLE
  <2007-05-16 Wed 12:30 +1w>
#+END_EXAMPLE
表示从2007-05-16 12:30开始，每周重复一次。

时间戳可以放在标题或正文的任何部分。

时间戳输入:
+ 可以手工输入符合格式的标记，
+ 可以使用快捷键 C-c . 来创建
+ 如果要快速输入日期无需选择，可以直接用C-c <
+ C-c > 可以查看日历
+ 如果仅仅想输入一个日期/时间，与任务没有任何关系，可以用C-c !。

S-left/S-right 以天为单位调整时间戳时间 S-up/S-down 调整光标所在时间单
位；如果光标在时间戳之外，调整时间戳类型（是否在日程表中显示） S-LEFT/
将光标处理的时间戳改变一天。

S-UP/ 改变时间戳中光标下的项。光标可以处在年、月、日、时或者分之上。当时
间戳包含一个时间段时，如 “15:30-16:30”，修改第一个时间，会自动同时修改第
DOWN 二个时间，以保持时间段长度不变。想修改时间段长度，可以修改第二个时
间。

|---------+-------------------------+---------------------------------------------------------------------|
| C-c .   | org-time-stamp          | Prompt for a date/time and insert a time stamp                      |
| C-c <   | org-date-from-calendar  | Insert time stamp corresponding to cursor date in *Calendar* buffer |
| C-c >   | org-goto-calendar       | Go to the Emacs calendar at the current date.                       |
| C-c !   | org-time-stamp-inactive | org-time-stamp-inactive                                             |
|---------+-------------------------+---------------------------------------------------------------------|
| S-UP    | org-shiftup             | Increase item in timestamp                                          |
| S-DOWN  | org-shiftdown           | Decrease item in timestamp                                          |
| S-LEFT  | org-shiftleft           |                                                                     |
| S-RIGHT | org-shifright           |                                                                     |
|---------+-------------------------+---------------------------------------------------------------------|

S-LEFT:
- switch a timestamp at point one day into the past
- on a headline, switch to the previous TODO keyword.
- on an item, switch entire list to the previous bullet type
- on a property line, switch to the previous allowed value
- on a clocktable definition line, move time block into the past

****** 时间段
两个时间戳用‘–’连接起来就定义了一个时间段：
#+BEGIN_EXAMPLE
  <2004-08-23 Mon>--<2004-08-26 Thu>
#+END_EXAMPLE

|---------------+------------------|
| 连续使用C-c . | 可以创建时间段   |
| C-c C-y       | 计算时间段的间隔 |
|---------------+------------------|

***** 计划时间和截止时间
Org-mode可以为任务设定一个计划时间(SCHEDULED), 输入 C-c C-s，就可以设定
光标所在位置所属的任务的计划时间。而 C-c C-d是输入截止时间（DEADLINE）。
|---------+--------------+----------------------|
| C-c C-s | org-schedule | Insert the SCHEDULED |
| C-c C-d | org-deadline | Insert the DEADLINE  |
|---------+--------------+----------------------|
***** 全局任务文件清单
Org-mode还支持将多个.org文件组合起来进行管理。这带来很多好处：你可以按
照不同的用途将任务放在不同的文件中进行组织，比如项目，个人事务，家庭等
等。

要让Org-mode知道需要把哪些文件视为全局任务的组成部分，需要设定一个清单，
可以在.emacs中这样设置 *org-agenda-files* ：
#+BEGIN_EXAMPLE
  (setq org-agenda-files (list "~/.todos/work.org"
                               "~/.todos/projects.org"
                               "~/.todos/home.org"
                               "~/Documents/todo/"
                             ))
#+END_EXAMPLE

清单中可以加入文件或目录。如果是目录，该目录下的所有.org文件都会被加入清
单。

除了预定义的清单文件，还可以在编辑任务文件(.org)时随时使用C-c [ / ] 将文
件加入/移出清单。
可以随时通过C-c '/, 循环打开所有的清单文件。

|-------+--------------------------+--------------------------------------------------------------|
| C-c [ | org-agenda-file-to-front | Move/add the current file to the top of the agenda file list |
| C-c ] | org-remove-file          | Remove current file from the org-agenda-files                |
|-------+--------------------------+--------------------------------------------------------------|

***** 全局TODO列表
全局TODO列表列出所有全局任务文件中的未完成任务。通过快捷键 *C-c a t*
进入全局 TODO 列表。

在全局TODO列表中，用 t 键改变任务状态，；按 RET 跳到该条目所在的源文件。

如果提示C-c a快捷键未定义，是因为Org-mode的快捷键没有启用，需要在.emacs
中增加配置：
#+BEGIN_EXAMPLE
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cb" 'org-iswitchb)
#+END_EXAMPLE

***** 日程表
有时候可能需要根据未完成任务显示日程安排，通过 *C-c a a* 可以进入日程
表视图。日程表根据任务的计划时间列出每天的任务。

在日程表视图中按 "l"(小写字母L) 显示日志。这样就会显示你所有已经完成的任
务和他们完成的时间。

*** S-M-RET 插入TODO项目
*** org-agenda window setup
Two variables control how the agenda buffer is displayed and whether
the window configuration is restored when the agenda exits:
+ org-agenda-window-setup: current-window
+ org-agenda-restore-windows-after-quit: customize 3

*** refile                                                         :refile:

**** shortcuts

|-------------------------+---------+--------------------|
| org-refile              | C-c C-w | 同一文件中移动节点 |
| org-copy                | C-c M-w | 同形文件中复制节点 |
|-------------------------+---------+--------------------|

**** variables

1) /org-refile-targets/

   多级节点/多文件设置

   #+BEGIN_EXAMPLE
   '(org-refile-targets (quote (("newgtd.org" :maxlevel . 1)
                                ("someday.org" :level . 2))))
   #+END_EXAMPLE

   This is a list of cons cells.  Each cell contains:

   + a specification of the files
   + a specification of how to file candidate refile targets /required/
     - :tag . "tag"
     - :todo . "KEYWORD"
     - :regexp . "REGEXP"
     - :level . N
     - :maxlevel . N

2) /org-reverse-note-order/

   移动后节点位置

   Non-nil means store new notes at the beginning of a file or entry.
   When nil, new notes will be filed to the end of a file or entry.

3) /org-refile-use-outline-path/

   select a location via a file-path-like completition

   Non-nil means provide refile targets as paths.

   So a level 3 headline will be available as level1/level2/level3.

   When the value is `file', also include the file name (without
   directory) into the path.

   In this case, you can also stop the completion after the file name,
   to get entries inserted as top level in the file.

   When `full-file-path', include the full file path.

4) /org-outline-path-complete-in-steps/

   Non-nil means complete the outline path in hierarchical steps.

5) /org-refile-allow-creating-parent-nodes/

   create new nodes on the fly

   Non-nil means allow to create new nodes as refile targets.

   New nodes are then created by adding "/new node name" to the
   completion of an existing node.

   When the value of this variable is `confirm',new node creation must
   be confirmed by the user (recommended)

   When nil, the completion must match an existing entry.

**** 配置

***** v1.0

#+BEGIN_SRC emacs-lisp
  ;; V1.0
  (setq org-reverse-note-order t) ; 新的节点转接至文件或条目头部
  (setq org-refile-targets
        '(("~/Tiger/Journal/tiger.org" :maxlevel . 2)
          ("~/Tiger/GTD/task.org" :maxlevel . 2)
          ))
  (setq org-refile-use-outline-path nil)
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes nil)
#+END_SRC

***** v1.1

1. 使用 outline 逻辑性更强
2. 允许添加新的父节点

#+BEGIN_SRC emacs-lisp
  ;; V1.2
  (setq org-reverse-note-order t) ; 新的节点转接至文件或条目头部
  (setq org-refile-targets
        '(
          ("~/Wally/Journal/WallyNotes/Algorithms.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/ComputerScience.org" :level . 1)
          ("~/Wally/Journal/WallyNotes/Emacs.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/EmbeddedSystem.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Languages.org" :level . 1)
          ("~/Wally/Journal/WallyNotes/Linux.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Programming.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Robotics.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Science.org" :level . 1)
          ("~/Wally/Journal/WallyNotes/LaTeX.org" :level . 2)
          ))
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC

***** v1.2: 没有必要，用不着所有的东西都通过花哨的方式完成，要朴素

+ 增加 bibtex 的 refile
+ 无果， refile的对象必有是节点，即标题(Heading), 目标需要是 Org文件

#+BEGIN_SRC emacs-lisp
  ;; V1.2
  (setq org-reverse-note-order t) ; 新的节点转接至文件或条目头部
  (setq org-refile-targets
        '(
          ("~/Wally/Journal/WallyNotes/Algorithms.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/ComputerScience.org" :level . 1)
          ("~/Wally/Journal/WallyNotes/Emacs.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/EmbeddedSystem.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Languages.org" :level . 1)
          ("~/Wally/Journal/WallyNotes/Linux.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Programming.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Robotics.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Science.org" :level . 1)
          ("~/Wally/Journal/WallyNotes/LaTeX.org" :level . 2)
          ;; ("~/Wally/GraduationProject/Thesis/refs.bib")
          ))
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC

***** v1.3

+ 使用 outline，配合不再使用 不同等级 level
+ 正则替换 r" :level \. [12]"

#+BEGIN_SRC emacs-lisp
  ;; V1.3
  (setq org-reverse-note-order t) ; 新的节点转接至文件或条目头部
  (setq org-refile-targets
        '(
          ("~/Wally/Journal/WallyNotes/Algorithms.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/ComputerScience.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Emacs.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/EmbeddedSystem.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Languages.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Linux.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Programming.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Robotics.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/Science.org" :level . 2)
          ("~/Wally/Journal/WallyNotes/LaTeX.org" :level . 2)
          ))
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC

**** 参考:

+ ORG Manual
+ [[http://www.cnblogs.com/holbrook/archive/2012/04/17/2454619.html#sec-2-6][Emacs learning]]

*** org-capture                                               :org:capture:
- state "halt"       from ""           [2015-02-27 五 01:32]
**** 参考:
+ [[~/Document/Emacs/Org/org.pdf][org manual]]

**** setting up capture
#+BEGIN_EXAMPLE
(setq org-default-notes-file (concat org-directory "/notes.org"))
(define-key global-map "\C-cc" 'org-capture)
#+END_EXAMPLE
**** using capture
|-----------+----------------------|
| C-c c     | org-capture          |
| C-c C-c   | org-capture-finalize |
| C-c C-w   | org-capture-refile   |
| C-c C-k   | org-capture-kill     |
|-----------+----------------------|

**** capture templates
C-c c C  Customize the variable *org-capture-templates*
#+BEGIN_EXAMPLE
 (setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
             "* TODO %?\n  %i\n  %a")
        ("j" "Journal" entry (file+datetree "~/org/journal.org")
             "* %?\nEntered on %U\n  %i\n  %a")))
#+END_EXAMPLE

**** Templates elements

[[/home/ben/Tiger/Figures/scrot/10675oaC.png]]


[[/home/ben/Tiger/Figures/scrot/106752Qz.png]]

*** DONE org-capture 增加trick以及更改位置到minor下
- State "DONE"       from "TODO"       [2015-12-07 一 13:52]
#+BEGIN_SRC emacs-lisp
  (setq  org-capture-templates
           '(("t" "Todo" entry (file+headline "" "Minor") "* TODO %?\n %t %i\n %a")
             ("i" "Ideas" item (file+headline "" "Ideas") "%?\n %t %i\n %a")
             ("k" "tricks" item (file+headline "" "Tricks") "%?\n %t %i\n %a")
             ))
#+END_SRC

*** org-capture-place-template
http://stackoverflow.com/questions/21195327/emacs-force-org-mode-capture-buffer-to-open-in-a-new-window

I, too, like to use many side-by-side splits (usually 4 -- I'm spread
across multiple monitors), so org-capture's behavior of turning 4
regular windows into 2 really wide ones makes my head explode every
time -- which tends to knock me out of my flow.

So here's a way to prevent org-capture from modifying your window
configuration.

After some searching, *it does not look like there is an easy way to
customize this behavior (or at least not an obvious one)* . Tracing the
function calls in the source code brings us to
org-capture-place-template, which saves your original window
configuration, then deletes the other windows, then gives you the
two-window split. You get your window configuration back later when
you finalize the capture, of course, but it sure would be nice to get
rid of that "let's change your window layout without your say-so"
step.

*Turns out it's pretty simple*.:
*Just re-evaluate org-capture-place-template after commenting out the
*single line calling (delete-other-windows):*
#+BEGIN_EXAMPLE
  (defun org-capture-place-template ()
    "Insert the template at the target location, and display the buffer."
    (org-capture-put :return-to-wconf (current-window-configuration))
    ;; (delete-other-windows)                ; this is the culprit!
    (org-switch-to-buffer-other-window
     (org-capture-get-indirect-buffer (org-capture-get :buffer) "CAPTURE"))
    (widen)
    (show-all)
    (goto-char (org-capture-get :pos))
    (org-set-local 'org-capture-target-marker
           (point-marker))
    (org-set-local 'outline-level 'org-outline-level)
    (let* ((template (org-capture-get :template))
       (type (org-capture-get :type)))
      (case type
        ((nil entry) (org-capture-place-entry))
        (table-line (org-capture-place-table-line))
        (plain (org-capture-place-plain-text))
        (item (org-capture-place-item))
        (checkitem (org-capture-place-item))))
    (org-capture-mode 1)
    (org-set-local 'org-capture-current-plist org-capture-plist))
#+END_EXAMPLE

Aaaah. It was like org-capture was punching me in the face every time
I used it, but now it's stopped.
*** org-capture                                               :org:capture:
**** shortkeys
|---------------+----------------------------------------------|
| C-c c         | org-capture                                  |
| C-c C-c       | org-capture-finalize                         |
| C-c C-w       | org-capture-refile                           |
| C-c C-k       | org-capture-kill                             |
|---------------+----------------------------------------------|
| C-u C-c c     | visit the target location                    |
| C-c C-c C-c c | jump to bookmark org-capture-last-stored     |
|               |                                              |
| C-O C-c c     | insert the capture at point in an Org buffer |
|               | region无效                                     |
|---------------+----------------------------------------------|
| C-c c C       | org-capture-templates                        |
|---------------+----------------------------------------------|

**** templates
#+begin_latex
  \begin{minted}[frame=single, mathescape]{lisp}
  (setq org-capture-templates
        '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
           "* %?\n %i\n %a")
          ("j" "Journal" entry (file+datetree "~/org/journal.org")
           "* %?\nEntered on %U\n %i\n %a")
          ))                              ;模板

  ; 不浏览模板列表，直接插入capture
  (define-kye global-map "\C-cx"
    (lambda() (interactive (org-capture nil "x")))
  \end{minted}
#+end_latex

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
           "* %?\n %i\n %a")
          ("j" "Journal" entry (file+datetree "~/org/journal.org")
           "* %?\nEntered on %U\n %i\n %a")
          ))                              ;模板

  ; 不浏览模板列表，直接插入capture
  (define-kye global-map "\C-cx"
    (lambda() (interactive (org-capture nil "x")))
#+END_SRC

1. templates elements
   1) keys
   2) description
   3) type
      - entry: an headline
      - item: a plain list, in the fisrt plain list at the target
        location
      - checkitem: a checkbox item
      - table-line: a new line in the first table at the target location
      - plain: Text to be inserted as it is
   4) target
      - (*file* "path/to/file")
      - (*id* "id of existing org entry")
      - (*file+headline* "path/to/file" "node headline")
      - (*file+datetree* "path/to/file")
        [[/home/ben/Tiger/Figures/scrot/5070qOn.png]]
   5) template: creating the capture items
   6) properties

**** Templates expansion

[[/home/ben/Tiger/Figures/scrot/50703Yt.png]]

**** settings
#+BEGIN_SRC emacs-lisp
    (require 'org-capture)
    (global-set-key "\C-cc" 'org-capture)
    (setq org-default-notes-file (expand-file-name "~/Wally/Journal/journal.org"))
    (setq
   org-capture-templates
          '(("t" "Todo" entry (file+headline "" "Tasks") "* TODO %?\n %t %i\n %a")
            ("i" "Ideas" item (file+headline "" "Ideas") "%?\n %t %i\n %a")
            ))
    (define-key global-map "\C-cCi"
      (lambda() (interactive) (org-capture nil "i")))
    (define

  -key global-map "\C-cCt"
      (lambda() (interactive) (org-capture nil "t")))
#+END_SRC

*** org-clock                                                   :clock:
计时
|-------------+-------------------|
| c-c c-x c-i | org-clock-in      |
| c-c c-x c-o | org-clock-out     |
| c-c c-x c-x | org-clock-in-last |
|-------------+-------------------|

#+begin_example
clock: [2015-11-15 日 13:34]--[2015-11-15 日 13:34] =>  0:00
#+end_example

*** org-agenda-files search TAGS
C-c a m有
*** org-agenda-file recycle
C-'

*** DONE org-agenda-file 排序, 然后使用前缀+快捷键迅速定位
- State "DONE"       from ""           [2015-12-07 一 14:00]

1. journal.org
2. Emacs.org
3. Linux.org
4. Programming.org
5. Latex.org

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list (expand-file-name "~/Wally/Journal/journal.org") ; 0
                               "~/Wally/Journal/WallyNotes/Emacs.org" ; 1
                               "~/Wally/Journal/WallyNotes/Linux.org" ; 2
                               "~/Wally/Journal/WallyNotes/Programming.org" ; 3
                               "~/Wally/Journal/WallyNotes/LaTeX.org" ; 4
                               "~/Wally/Journal/WallyNotes/EmbeddedSystem.org" ; 5
                               "~/Wally/Journal/WallyNotes/Algorithms.org"
                               "~/Wally/Journal/WallyNotes/Languages.org"
                               "~/Wally/Journal/WallyNotes/Robotics.org"
                               "~/Wally/Journal/WallyNotes/Science.org"
                               "~/Wally/Journal/WallyNotes/ComputerScience.org"
                               ))
#+END_SRC

*** DONE 标签逻辑搜索
- State "DONE"       from "TODO"       [2015-11-23 一 17:30]
C-c a m     (org-tags-view)
Produce a list of all headlines that match a given set of tags. The
command prompts for a selection criterion, which is a boolean logic
expression with tags, like ‘+work+urgent-withboss’ or ‘work|home’

+ AND +
+ SUB -
+ OR |

*** org time-stamps                                                  :time:
**** [[http://orgmode.org/manual/Creating-timestamps.html][Creating timestamps]]

For Org mode to recognize timestamps, they need to be in the specific
format. All commands listed below produce timestamps in the correct
format.

+ C-c .     (org-time-stamp)

  Prompt for a date and insert a corresponding timestamp. When the
  cursor is at an existing timestamp in the buffer, the command is
  used to modify this timestamp instead of inserting a new one. When
  this command is used twice in succession, a time range is inserted.

+ *C-c !*     (org-time-stamp-inactive)
  Like C-c ., but insert an inactive timestamp that will not cause an
  agenda entry.

+ C-u C-c . &  C-u C-c !

  Like C-c . and C-c !, but use the alternative format which contains
  date and time. The default time can be rounded to multiples of 5
  minutes, see the option org-time-stamp-rounding-minutes.

+ C-c C-c

  Normalize timestamp, insert/fix day name if missing or wrong.

+ C-c <     (org-date-from-calendar)

  Insert a timestamp corresponding to the cursor date in the
  Calendar.

+ C-c >     (org-goto-calendar)

  Access the Emacs calendar for the current date. If there is a
  timestamp in the current line, go to the corresponding date
  instead.

+ C-c C-o     (org-open-at-point)

  Access the agenda for the date given by the timestamp or -range at
  point (see Weekly/daily agenda).

+ S-<left>/<right>     (org-timestamp-down/up-day)


  Change date at cursor by one day. These key bindings conflict with
  shift-selection and related modes (see Conflicts).

+ S-<up>/<down>     (org-timestamp-up/down)

  Change the item under the cursor in a timestamp. The cursor can be
  on a year, month, day, hour or minute. When the timestamp contains a
  time range like ‘15:30-16:30’, modifying the first time will also
  shift the second, shifting the time block with constant length. To
  change the length, modify the second time. Note that if the cursor
  is in a headline and not at a timestamp, these same keys modify the
  priority of an item. (see Priorities). The key bindings also
  conflict with shift-selection and related modes (see Conflicts).

+ C-c C-y     (org-evaluate-time-range)

  Evaluate a time range by computing the difference between start and
  end. With a prefix argument, insert result after the time range (in
  a table: into the following column).
**** usage
C-c ! 没有默认绑定

#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map "\C-c !" (lambda()
                                     (interactive)
                                     (org-time-stamp-inactive 1)))
#+END_SRC

以上配置无效， org-time-stamp-inactive 会(*prompt*)弹出一个buffer询问插入哪个日
期。

#+BEGIN_EXAMPLE
  [2015-11-24 二 15:24]
#+END_EXAMPLE

以前写过，简单的修改成标准格式（如上）
#+BEGIN_SRC emacs-lisp
  (defun tagerill:insert-current-time ()
    "Insert the current time"
    (interactive "*")
    (insert (format-time-string "[%Y-%m-%d 周%w " (current-time)))
    (insert (format-time-string "%H:%M]" (current-time))))
  (global-set-key "\C-zt" 'tagerill:insert-current-time)
  (defun tagerill:insert-current-date()
    "Insert the current date in certain format"
    (interactive)
    (insert (format-time-string "%Y/%m/%d" (current-time))))
  (global-set-key "\C-zd" 'tagerill:insert-current-date)
#+END_SRC

测试，OK

*TODO* 周2改为二，不难, elisp 字典？

*** mark-ring

**** v1.0

#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map "\C-c5" 'org-mark-ring-goto) ; 默认没有绑定
  (define-key org-mode-map "\C-c4" 'org-mark-ring-push)
#+END_SRC

**** v1.1 增加深度跟踪和消息提示

#+BEGIN_SRC emacs-lisp
  (setq workflow-depth 0)
  (define-key org-mode-map "\C-c5" (lambda()
                                     (interactive)
                                     (setq workflow-depth (- workflow-depth 1))
                                     (org-mark-ring-goto)
                                     (message (format "current workflow depth: %s" workflow-depth))
                                     ))
  (define-key org-mode-map "\C-c4" (lambda()
                                     (interactive)
                                     (setq workflow-depth (+ workflow-depth 1))
                                     (org-mark-ring-push)
                                     (message (format "current workflow depth: %s" workflow-depth))
                                     ))
#+END_SRC

**** v1.2 设置全局按键绑定
#+BEGIN_SRC emacs-lisp
  (setq workflow-depth 0)
  (global-set-key "\C-c5" (lambda()
                                     (interactive)
                                     (setq workflow-depth (- workflow-depth 1))
                                     (org-mark-ring-goto)
                                     (message (format "current workflow depth: %s" workflow-depth))
                                     ))
  (global-set-key  "\C-c4" (lambda()
                                     (interactive)
                                     (setq workflow-depth (+ workflow-depth 1))
                                     (org-mark-ring-push)
                                     (message (format "current workflow depth: %s" workflow-depth))
                                     ))
#+END_SRC

**** v1.3
#+BEGIN_SRC emacs-lisp
  (setq workflow-depth 0)
  (global-set-key "\C-c5" (lambda()
                                     (interactive)
                                     (setq workflow-depth (- workflow-depth 1))
                                     (org-mark-ring-goto)
                                     (message (format "current workflow depth: %s" workflow-depth))
                                     ))
  (global-set-key  "\C-c4" (lambda()
                                     (interactive)
                                     (setq workflow-depth (+ workflow-depth 1))
                                     (org-mark-ring-push)
                                     (message (format "current workflow depth: %s" workflow-depth))
                                     ))
#+END_SRC

*** Emacs 倒计时                                                     :time:

1. why: *切换任务时要保证在一定时限（10～15m）内解决，然后返回到主任务。*

2. google关键字:  emacs countdown timer

3. org-timer-set-timer

   emacs help:
   #+BEGIN_EXAMPLE
     It is bound to C-c C-x ;.

     (org-timer-set-timer &optional OPT)

     Prompt for a duration and set a timer.

     If `org-timer-default-timer' is not zero, suggest this value as
     the default duration for the timer.  If a timer is already set,
     prompt the user if she wants to replace it.

     Called with a numeric prefix argument, use this numeric value as
     the duration of the timer.

     Called with a `C-u' prefix arguments, use `org-timer-default-timer'
     without prompting the user for a duration.

     With two `C-u' prefix arguments, use `org-timer-default-timer'
     without prompting the user for a duration and automatically
     replace any running timer.
   #+END_EXAMPLE

4. 手记

   只能使用整数分钟，使用浮点数会被截取，比如设置0.5会立即结束倒计时。

   由系统提示， 满足要求。

   [[/home/ben/Tiger/Figures/scrot/106756Sw.png]]

5. 设置

#+BEGIN_SRC emacs-lisp
  (setq org-timer-default-timer 10)       ; 设置默认计时10分钟
#+END_SRC

*** org-ring-mark

**** org-mark-ring-push

C-c % runs the command org-mark-ring-push, which is an interactive
compiled Lisp function in `org.el'.

It is bound to C-c %.

(org-mark-ring-push &optional POS BUFFER)

Put the current position or POS into the mark ring and rotate it.

**** org-mark-ring-goto

org-mark-ring-goto is an interactive compiled Lisp function in
`org.el'.

(org-mark-ring-goto &optional N)

Jump to the previous position in the mark ring.
With prefix arg N, jump back that many stored positions.  When
called several times in succession, walk through the entire ring.
Org-mode commands jumping to a different position in the current file,
or to another Org-mode file, automatically push the old position
onto the ring.

**** 配置和使用

切换任务时先记录当前位置

#+BEGIN_SRC emacs-lisp :exports code
  (define-key org-mode-map "\C-c&" 'org-mark-ring-goto) ; 默认没有绑定
#+END_SRC

** ORG拾遗
*** org-download
+ https://github.com/abo-abo/org-download


This extension facilitates moving images from point A to point B.
**** source
Point A (the source) can be:
+ An image inside your browser that you can drag to Emacs.
  - not work properly

+ An image on your file system that you can drag to Emacs.

+ A local or remote image address in kill-ring. Use the
  org-download-yank command for this. Remember that you can use "0 w"
  in dired to get an address.
  - 使用文件浏览器复制的图片，ok，网页浏览器复制的图片，not ok
  - binding to *C-c M-y*

+ An screenshot taken using gnome-screenshot or scrot or gm. Use the
  org-download-screenshot command for this. Customize the backend with
  org-download-screenshot-method.
  - (默认的即可gnome, 修改可能会出错)
  - binding to *C-c M-s*
**** target

Point B (the target) is an Emacs  org-mode buffer where the inline
link will be inserted. Several customization options will determine
where exactly on the file system the file will be stored.

**** download-methdo
They are: org-download-method:

***** 'attach
use org-mode attachment machinery
***** 'directory

construct the directory in two stages:

****** first part of the folder name is:

+ either "." (current folder)
+ or org-download-image-dir (if it's not nil).
  - org-download-image-dir becomes buffer-local when set, so each file
    can customize this value, e.g with:
    #+BEGIN_EXAMPLE
    -*- mode: Org; org-download-image-dir: "~/Pictures/foo"; -*-
    #+END_EXAMPLE
  - To set it for all files at once, use this:
    #+BEGIN_SRC emacs-lisp
    (setq-default org-download-image-dir "~/Pictures/foo")
    #+END_SRC


****** second part is:

1. *org-download-heading-lvl* is nil => ""
2. org-download-heading-lvl is n => the name of current heading with
   level n.

   Level count starts with 0, i.e. * is 0, ** is 1, *** is 2
   etc. org-download-heading-lvl becomes buffer-local when set, so
   each file can customize this value, e.g with:
   #+BEGIN_EXAMPLE
    -*- mode: Org; org-download-heading-lvl: nil; -*-
   #+END_EXAMPLE
3. *org-download-timestamp*: optionally add a timestamp to the file name.

Customize org-download-backend to choose between url-retrieve (the default) or wget or curl.

*****

*** org-w3m
+ 快捷键
  |-------------+---------------------------|
  | C-c C-x C-w | org-w3m-copy-for-org-mode |
  |-------------+---------------------------|
+ 调用: (org-w3m-copy-for-org-mode)
+ 配置:
  #+BEGIN_EXAMPLE
    (require 'org-w3m')
  #+END_EXAMPLE
+ 说明:
  Copy current buffer content or active region *with `org-mode' style
  links.*

*** MobileORG
- State "ABORT"      from "TODO"       [2015-03-21 六 20:39] \\
  Dropbox被屏蔽, 其它服务器又不会用
- State "TODO"       from ""           [2015-03-04 三 14:20]
 Date:<2015-02-27 五>
  + https://github.com/matburt/mobileorg-android/wiki
  + http://orgmode.org/manual/MobileOrg.html#MobileOrg

*** ABORT 如何为PDF增加outline                                    :pdftool:
- State "ABORT"      from "waiting"    [2015-03-21 六 19:53] \\
  没有便捷的方法, 除了Adobecat
- State "waiting"    from "TODO"       [2015-03-01 日 12:16] \\
  下载和安装软件
- State "TODO"       from ""           [2015-03-01 日 12:16] \\
  Adobe Acrobat
 Date:<2015-02-27 五>
 Link: (Y/N)

*** alist

**** <p

<p 展开

#+BEGIN_QUOTE
智能移动机器人是一类能够通过传感器感知环
境和自身状态, 实现在有障碍物的环境中面向目标
的自主运动( 称为导航) , 从而完成一定作业功能的
机器人系统。
#+END_QUOTE

\LaTeX

#+BEGIN_SRC latex
  \begin{quote}
  智能移动机器人是一类能够通过传感器感知环
  境和自身状态, 实现在有障碍物的环境中面向目标
  的自主运动( 称为导航) , 从而完成一定作业功能的
  机器人系统。
  \end{quote}
#+END_SRC


** LaTeX & Exporting                                                 :latex:
*** LaTeX导出命令(export commands)
|---------------+---------------------------+---------------------------------|
| shortcuts     | command                   | comment                         |
|---------------+---------------------------+---------------------------------|
| *C-c C-e l l* | org-latex-export-to-latex | 导出为同名LaTeX文件,无警告重写  |
| *C-c C-e l L* | org-latex-export-as-latex | 导出到LaTeX临时缓冲区           |
| *C-c C-e l p* | org-latex-export-to-pdf   | 导出为LaTeX文件,之后生成PDF文档 |
| *C-c C-e l o* |                           | 并打开PDF                          |
|---------------+---------------------------+------------------------------------|
*** 导言(Header)和章节结构(section structure)
默认前三级大纲生成标题(headings),其它生成列表(itemize/enumerate).

文类默认使用article,可通过改变变量 *org-latex-default-class* 的值,或增
加元数据 *LATEX_CLASS*.

*** org-latex-preview
+ http://orgmode.org/worg/org-tutorials/org-latex-preview.html


|---------------------+-----------------------------------|
| C-c C-x C-l         | org-preview-latex-fragment        |
| C-c C-c             | remove overlay                    |
| C-u C-c C-x C-l     | preview everything in the subtree |
| C-u C-u C-c C-x C-l | preview everything in the buffer  |
|---------------------+-----------------------------------|

1. two methods
   + dvipng
   + *imagemagick*
*** latex源码的导出问题

 emacs babel的配置问题?

 org支持内嵌latex, \textbackslash{}后接latex命令都可直接使用, 没有必要
  使用babel包裹.
*** \ 转义字符的导出
**** 仅 \
#+BEGIN_EXAMPLE
  \      $\backslash$
#+END_EXAMPLE
**** 仅前置字符
#+BEGIN_EXAMPLE
  ,\     ,$\backslash$
  ，\    ，$\backslash$
  a\     a$\backslash$
  工\    工$\backslash$
#+END_EXAMPLE
**** 仅后置字符
#+BEGIN_EXAMPLE
  \a     \a
  \工    $\backslash$工
  \,     $\backslash$,
  \，    $\backslash$，
  \.     $\backslash$.
  \;     $\backslash$;
  \:     $\backslash$:
  \'     $\backslash$'
  \"     $\backslash$"
#+END_EXAMPLE
**** 后置 TeX 保留字符
#+BEGIN_EXAMPLE
  \\    \\
  \$    \$
  \^    \^
  \_    \_
  \#    \#
  \{    \{
  \}    \}
  \~    $\backslash$\textasciitilde{}
  \&    \&
  \%    \%
#+END_EXAMPLE

**** 前置 TeX 保留字符
#+BEGIN_EXAMPLE
  \\    \\
  $\    \$$\backslash$
  ^\    \^{}$\backslash$
  _\    \_$\backslash$
  #\    \#$\backslash$
  {\    \{$\backslash$
  }\    \}$\backslash$
  ~\    \textasciitilde{}$\backslash$
  &\    \&$\backslash$
  %\    \%$\backslash$
#+END_EXAMPLE

**** 后单词
#+BEGIN_EXAMPLE
  \abc      \abc
  \abc,     \abc,
  \abc.     \abc.
  \abc工    $\backslash$abc工
  \abc$     \abc\$
  \$工
  \${
#+END_EXAMPLE
**** 结论
当以下条件成立时, org导出的TeX文件中的\会造成错误.
1. *后置*
2. *英文字母或TeX保留字符*
   1) *英文字符与下一个分界符(标点和特殊符号)之间构成一个C变量名*
   2) *所有TeX保留字符*

该结论可以推广到其它特殊字符.
*** TeX保留符号
*前面或后面无空格时* 导出为 TeX 会产生问题, 方括号也会慎用

测试保留字符的转换

#+BEGIN_EXAMPLE
+ \
+ ~
+
#+END_EXAMPLE
*** org中"---"导出到 TeX 也是"---",因而生成pdf中的破折号
注:交集(&)导出 TeX{}和PDF没有问题
#+BEGIN_EXAMPLE
  注:交集(\&)导出 \TeX{}{}和PDF没有问题
#+END_EXAMPLE

对称差分(^) 对称^
#+BEGIN_EXAMPLE
  对称差分(\^{}) 对称\^{}
#+END_EXAMPLE
#+BEGIN_EXAMPLE
^
#
[]
$
#+END_EXAMPLE

*** org-latex-class
[[help:org-latex-classes][help::org-latex-classes]]
a variable defined in 'ox-latex.el'.

Alist of LaTeX classes and associated header and structure. If
*#+LATEX_CLASS* is set in the buffer, use its value and the ossociated
information.

#+BEGIN_EXAMPLE
  (add-to-list 'org-latex-classes
               '("ctexart" "\\documentclass[10pt,onepage]{article}
  \\usepackage{xcolor}
  \\usepackage{tipa}
  \\usepackage[fntef]{ctex}
  \\usepackage{hyperref}
  \\usepackage{graphicx}
  \\usepackage{layout}
  \\usepackage{fancyvrb}
  \\usepackage{listings}
  \\usepackage{picinpar}
  \\usepackage[text={150mm,240mm},centering]{geometry}
  \\pagestyle{myheadings}
  \\markboth{\\today}{\\today}
  [NO-DEFAULT-PACKAGES]
  [NO-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

  (add-to-list 'org-latex-classes
               '("ctexbook" "\\documentclass[10pt,twopage]{book}
  \\usepackage{xcolor}
  \\usepackage{tipa}
  \\usepackage[fntef]{ctex}
  \\usepackage{hyperref}
  \\usepackage{graphicx}
  \\usepackage{layout}
  \\usepackage{fancyvrb}
  \\usepackage{listings}
  \\usepackage{picinpar}
  \\usepackage[text={150mm,240mm},centering]{geometry}
  \\pagestyle{myheadings}
  \\markboth{\\today}{\\today}
  [NO-DEFAULT-PACKAGES]
  [NO-PACKAGES]"
    ("\\part{%s}" . "\\part*{%s}")
    ("\\chapter{%s}" . "\\chapter*{%s}")
    ("\\section{%s}" . "\\section*{%s}")
    ("\\subsection{%s}" . "\\subsection*{%s}")
    ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
#+END_EXAMPLE

*** org-latex-default-class
The defaut LaTeX class. Original value was "article"
#+BEGIN_EXAMPLE
(setq org-latex-default-class "ctexart")
#+END_EXAMPLE
*** TODO org-latex-default-figure-position
Default positoin for latex figures. The value is "htb"
*** org-latex-default-packages-alist
Alist of default packages to be inserted in the header.
*** 表格
**** TODO org-latex-default-table-environment
Default environment used to build tables. Its value is "tabular".
**** TODO org-latex-default-table-mode
Default mode for tables. Its value is table.
Value can be a symbol among:
 + `table' Regular LaTeX table.
 + `math' In this mode, every cell is considered as being in math
    mode and the complete table will be wrapped within a math
    environment.  It is particularly useful to write matrices.
 + `inline-math' This mode is almost the same as `math', but the
    math environment will be inlined.
 + `verbatim' The table is exported as it appears in the Org
    buffer, within a verbatim environment.
**** TODO org-latex-tables-caption-above
**** TODO org-latex-tables-scientific-natation
**** TODO org-latex-tables-booktabs
**** TODO org-latex-tables-centered
*** 图片
**** TODO org-latex-image-default-height
**** TODO org-latex-image-default-width
**** TODO org-latex-iamge-default-option
**** TODO org-latex-inline-image-rules
*** 源码
**** TODO org-latex-listings
**** TODO org-latex-listings-langs
**** TODO org-latex-listings-options

*** 导出成HTML的一些问题和技巧
**** 生成目录
Table of Content
*#+OPTIONS: toc:t*
或者
*setq org-export-with toc t*
**** 为每个分节的标题添加标号
**** 禁用下划线
*#+OPTIONS: ^:nil*
*(setq-default org-use-sub-superscripts nil)*
**** 让不同的标题采用不同大小的字体
*(set-face-attribute 'org-level-1 nil :height 1.3 :bold t)*
*(set-face-attribute 'org-level-2 nil :height 1.1 :bold t)*
*(set-face-attribute 'org-level-2 nil :height 1.0 :bold t)*

*** org-export-with-emphasize
org-export-with-emphasize is a variable defined in `ox.el'.
Its value is t

Documentation:
Non-nil means interpret *word*, /word/, _word_ and +word+.

If the export target supports emphasizing text, the word will be
typeset in bold, italic, with an underline or strike-through,
respectively.

This option can also be set with the OPTIONS keyword,
e.g. "*:nil".

*** 反引号

[[help:`][cdlatex-math-symbol]]

蛮好用的，就不解除默认绑定了。但是反引号怎么输入????

** 写论文
参考:
+ http://www.binghe.org/2010/05/typeset-references-in-latex/#post-120
+ https://wiki.freebsdchina.org/doc/r/reference
+ http://www.mfasold.net/blog/2009/02/using-emacs-org-mode-to-draft-papers/
+ https://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/

*** 利用 Emacs 管理文献
俗话说，“好记性不如烂笔头”。文献管理，不仅对科研工作者，对普通的用户
也是必需的。看过的文献，写写心得做做笔记，以后写文章旁征博引的时候就不
至于心乱如麻。

已有一些开源的文献管理的工具广受欢迎，如 JabRef、docear 等。一些常见的
工具软件，读者可参阅 文献管理软件比较。

这里，我介绍另外一种简便的方法：利用 Emacs 的 org-mode 管理文献。原因
有二：
1) *Emacs 是可以使用一生的编辑器*
2) *org-mode是做笔记的强大工具*

本着简单为美，高效为目的的原则，充分利用已有资源，本 wiki 的方法（源自
http://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/
）能够出色地完成文献管理的任务。

*** 利用 Google Scholar 导出 bibtex 文件

*写科技文章，TeX 排版工具是必须掌握的。现在的国际会议和期刊，哪个不要
求 TeX 排版？* 我们假定读者熟悉 TeX 排版，了解最简单的 Emacs 使用方法。

在 TeX 中，文献的索引来自独立文件 *.bib，它的格式必须通过 bibtex 的编
译。文献管理软件 RefDB介绍了如何从 RIS 格式转化为 bib 格式。RefDB 是图
书馆时代的产物，随着 Google Scholar 的普及，我们有更便捷的文献管理方法。


*Google Scholar 提供了搜索文献和导出其 bibtex 描述的强大功能*, 它在某
种程度上替代了图书馆检索和某些专业数据库检索（如 PubMed 等），让更多的
人能够方便地检索到文献。在知识共享的年代，我认为，Google Scholar 是
Google 公司最伟大的产品之一。

*** 文献管理有哪些功能？
一个文献管理软件，必须具备以下几项功能。
+ *bibtex 格式*
+ 文章标题、作者、期刊名等关键词 *搜索*
+ *链接* 到本地保存的文章（一般为 PDF 格式）
+ *做笔记* （写文章的时候，笔记很重要）
+ 在 TeX 文档中利用 \cite{} 索引
*** org + bibtex + reftex

Emacs Org Mode 可以是一个优秀的笔记工具，可是，如果你想用它来写正式一
点的论文，可以吗？当然可以了，你可以把 Org Mode 和 LaTeX 结合起来用，
当然 *最重要的是要解决参考文献引用的问题* 。

整体的思路如下：
1. 先准备好你的 BibTeX 文件
   + 可以用 Emacs BibTeX Mode
   + 或 JabRef 之类的方式来生成这个文件
   + 当然也可以用其它文献管理工具，只要它能导出 BibTeX 文件即可
   + google scholar
2. 用 Emacs Org 建立工程并记笔记,创建 Org 工程的时候，和一般的工程没有
   任何区别。
3. 用 *RefTeX* 方式来插入 BibTeX 的记录

在这里，重点介绍一下第三个步骤，即如何在 Org Mode 里插入 BibTeX 记录。
从官方的这篇参考文献里可以看出，我们可以用三种方法在 org 文件里引用
BibTeX 参考文献，从而插入 LaTeX 类的参考文献。

**** 最简单的办法，给所有的 Org 文件指定一个 BibTeX 文件，然后在 Org 文件里插入该 BibTeX 文件的参考文献记录

具体的办法，先把下面的代码放到 .emacs 里：
#+BEGIN_EXAMPLE
  (setq reftex-default-bibliography
        (quote
         ("default.bib" "~/org/notes/refer.bib")))
  (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
#+END_EXAMPLE

在这里，我指定的 BibTeX 文件为 default.bib 和 ~/org/notes/refer.bib 。
然后，可以在所有的 Org 文件里，通过命令 C-c ) 或 *M-x reftex-citation*
来进行参考文献的插入，根据提示进行相关操作即可。
\cite{Aamport:1986a}

**** 为特定的 Org 文件，指定特定的 BibTeX 文件
这个方法是 [[http://www.mfasold.net/blog/2009/02/using-emacs-org-mode-to-draft-papers/][Marios Braindump]] 的博客里介绍的，具体方法如下：
先把下面的代码放到 .emacs 里：
#+BEGIN_EXAMPLE
  (defun org-mode-reftex-setup ()
    (load-library "reftex")
    (and (buffer-file-name)
         (file-exists-p (buffer-file-name))
         (reftex-parse-all))
    (define-key org-mode-map (kbd "C-c )") 'reftex-citation))
  (add-hook 'org-mode-hook 'org-mode-reftex-setup)
#+END_EXAMPLE

然后在你需要插入 BibTeX 参考文献的 Org 文件里，加入下面这段话（可以是
任意位置）：
#+BEGIN_EXAMPLE
  \bibliographystyle{plain}
  \bibliography{BIB-NAME}
#+END_EXAMPLE

把上面的 BIB-NAME 换成你想指定的 BibTeX 文件，这样就可以对该 Org 文件
指定特定的 BibTeX 文件，然后可以用 C-c ) 或 M-x reftex-citation 来插入
该 BibTeX 文件里的参考文献。

上面的代码会在 Emacs 启动的时候，要求你指定一个 master 文件，用来存储
生成的 tex 文件。

**** 另外一种方法，实现为特定的 Org 文件指定特定 BibTeX 文件的功能

还有另外一种方法，可以实现第2种方法类似的功能，即为特定 Org 文件指定特
定 BibTeX 文件的方法。把下面的代码放到 .emacs 文件里：
#+BEGIN_EXAMPLE
  (defun org-mode-article-modes ()
    (reftex-mode t)
    (and (buffer-file-name)
         (file-exists-p (buffer-file-name))
         (reftex-parse-all)))

  (add-hook 'org-mode-hook
            (lambda ()
              (if (member "REFTEX" org-todo-keywords-1)
                  (org-mode-article-modes))))
#+END_EXAMPLE

然后把下面这一行加到你需要插入 BibTeX 的 Org 文件的开头：
#+BEGIN_EXAMPLE
  ,#+TODO: TODO(t) STARTED(s) | DONE(d) DEFERRED(f) REFTEX
#+END_EXAMPLE
其它步骤与第2种方法类似。这种方法我没有仔细测试，有兴趣的 Emacser 们可
以试试。

通过以上方法，就可以在用 Org Mode 打造的笔记本里，很方便地索引 BibTeX
里的参考文献了。

当然，如果你不喜欢用 Org Mode，也有其它用 Emacs 来写论文的思路，例如：
*Emacs + AucTeX + RefTeX + Outline-minor-mode*
*** Research Paper Management with Emacs, org-mode and RefTeX
+
  https://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/

*** bibtex编译
+ http://zzg34b.w3.c361.com/package/reference.htm

#+BEGIN_SRC latex
\bibliography{/home/ben/Tiger/GraduationProject/Literature/refs.bib}
\bibliographystyle{ieeetr}
#+END_SRC

在document结束之前。


BibTeX 提供了一个外部的 BibTeX 工具程序，源文件经过 LaTeX 编译后，还要
使用BibTeX 对数据库文件编译一次，最后再用 LaTeX 连续编译两遍，才能得到
正确结果。

*note: tex文件中不支持对文件路径中的"~"的扩展，使用绝对路径只能以"/"开
头，相对路径相对于tex文件所有目录*

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-20 19:28:25
 [[~/Tiger/Figures/Emacs/screenshot_2015-06-20_19:28:25.png]]


1. latex .tex  C-c C-c latex
2. bibtex .aux C-c C-c bibtex
3. latex .tex  C-c C-c latex
4. latex .tex  C-c C-c latex

*** 中文问题
+ http://www.eefocus.com/sunshine/blog/09-08/175253_b0ef9.html

中文文献和英文的格式不同，并且使用全角的标点符号，有一点难办。我的解决办法是
这样的：
#+BEGIN_EXAMPLE
   @misc{Xie.1995,
    note = "谢锦辉，《隐 {Markov} 模型及其在语音处理中的应用》，华中理工大学出版社，1995年4月",
    key = "Xie",}
#+END_EXAMPLE
唯一的缺陷是参考文献中最后是以英文的 "." 而不是 "。" 结束的。还好我的中文文
献不多，无伤大雅，否则就 *手工修改一下 bbl 文件* 吧。
* Elisp                                                         :emacs:elisp:
** ElispTutorials
*** 入门
#+BEGIN_SRC emacs-lisp :exports code
  ;; This gives an introduction to Emacs Lisp in 15 minutes (v0.2d)
  ;;
  ;; 英文原作者: Bastien / @bzg2 / http://bzg.fr
  ;; 中文翻译: iamxuxiao
  ;;
  ;;
  ;; 如何安装 Emacs
  ;;
  ;; Debian: apt-get install emacs (or see your distro instructions)
  ;; MacOSX: http://emacsformacosx.com/emacs-builds/Emacs-24.3-universal-10.6.8.dmg
  ;; Windows: http://ftp.gnu.org/gnu/windows/emacs/emacs-24.3-bin-i386.zip
  ;;
  ;; More general information can be found at:
  ;; http://www.gnu.org/software/emacs/#Obtaining
  ;; 免责声明：
  ;;
  ;; Going through this tutorial won't damage your computer unless
  ;; you get so angry that you throw it on the floor. In that case,
  ;; I hereby decline any responsability. Have fun!

  == 启动Emacs, 缓冲区和工作模式==
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;; 第一步首先启动Emacs: (在windows中可以双击emacs图标，在Linux中可以输入% emacs & )，
  ;; 然后在键盘上键入q 跳过系统欢迎的信息，
  ;; 先观察在Emacs屏幕的底部，会给出一堆关于当前的工作情况的信息，其中灰色的一行叫做状态行，
  ;; 在其中你会发现 *scratch* 的字样，这表示你当前的缓冲区(buffer)的名字。
  ;; 缓冲区也叫做工作区，在Emacs中打开一个文件，实际只是在Emacs中构造该文件的一个副本，放到缓冲区中，
  ;; 在Emacs中对该文件的编辑也是针对该副本的编辑，唯有保存改动时，Emacs才会把缓冲区中的内容在复制到原文件中去。
  ;; 状态行下面的那行，叫做辅助输入区(minibuffer),该minibuffer用于显示计算结果，以及和用户做交互。
  ;;
  ;;
  ;; 如何切换Emacs的工作模式
  ;; Emacs有各种各样功能各异的模式，工作模式的含义其实就是Emacs对当前的文本编辑工作
  ;; 更加的敏感，比如高亮和缩进，并且支持一些特殊的命令。
  ;; 为了实验本教程中的lisp命令，我们要让Emacs工作在lisp-interaction-mode工作模式下，
  ;; 这个模式可以让我们在缓冲区中和Emacs进行互动，并且直接执行Lisp命令,得到结果。
  ;; 进入lisp-interaction-mode的方法： 把光标移动到辅助输入区，键入M-x lisp-interaction-mode
  ;; 然后回车。

  == 表达式，变量和函数 ==

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;; 冒号在Lisp中表示注释
  ;; 在Elisp中做运算，调用函数的最简单的方式是
  ;; (function arg1 arg2)
  ;; 这相当于通常的function(arg1,arg2)，下面的表达式，对两个数字进行加法运算
  (+ 2 2)

  ;; Elisp中表达式可以通过括号来嵌套
  (+ 2 (+ 1 1))

  ;; 在lisp-interaction-mode模式中，我们可以直接计算一个表达式,计算的方法是
  (+ 3 (+ 1 2))
  ;; ^ 把光标放在这里，并且键入Ctrl-j (之后将简写成C-j)
  ;; C-j是一个快捷命令，在后台，该快捷键将调用求值命令，并且把计算的结果
  ;; 插入到当前的缓冲区中

  ;; 如果不希望Emacs在缓冲区中插入计算结果，我们还可以在表达式的末尾使用C-x C-e组合键
  ;; C-x C-e的意思是: 先按下Ctrl-x 再按下Ctrl-e
  ;; 这个命令会让Emacs在辅助缓冲区，也就是Emacs窗口的最底部那行显示计算结果

  ;; ELisp中的赋值函数是是setq，下面的表达式给变量my-name赋值"Bastien"
  (setq my-name "Bastien")
  ;; ^ 把光标停在这里，再键入C-x C-e

  ;; 下面insert函数的作用是在光标所在出插入字符Hello
  (insert "Hello!")
  ;; ^ 把光标停在这里，再键入C-x C-e

  ;; insert函数还可以两个常量字符，比如
  (insert "Hello" " world!")

  ;; insert函数还可以接受变量作为参数，我们之前已经给my-name变量赋过值了
  ;; 所以下面命令的输出结果是 "Hello, I am Bastien"
  (insert "Hello, I am " my-name)

  ;; defun命令用来定义一个函数,语法是
  ;; (defun 函数名 (参数列表) (函数体))
  (defun hello () (insert "Hello, I am " my-name))
  ;; ^ 把光标停在这里，再键入C-x C-e 执行defun命令来定义函数
  ;; 通过defun命令，你已经在Emacs中安装了这个hello函数，这个函数就成为了Emacs的一部分，知道你退出Emacs或者改变hello的定义

  ;; 从下面开始，我们将不再提醒读者使用C-x C-e来定义函数和执行ELisp指令

  ;; 在Elisp中直接输入函数的名称就是调用该函数。
  ;; 下面的命令的输入结果是: Hello, I am Bastien
  (hello)

  ;; 前面定义的hello函数不接受任何参数,过于简单，
  ;; 现在我们重新定义hello函数，让它接受一个参数name。
  (defun hello (name) (insert "Hello " name))

  ;; 然后调用新的hello函数，并且提供一个参数。
  ;; 下面命令的输出结果是"Hello you"
  (hello "you")

  == progn,let和交互式函数==
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;; 执行switch-to-buffer-other-window命令，将在在一个新的窗口中打开一个buffer
  ;; 该buffer命名叫做 test, 并且把光标移到新的buffer的窗口中。
  (switch-to-buffer-other-window "*test*")

  ;; 要回到原来的buffer中，可以使用鼠标点击原来的buffer
  ;; 或者使用组合键 C-x o
  ;; C-x o的意思是: 先按下Ctrl-x 再按下o

  ;; 如果要执行一系列的指令，可以使用流程函数progn，把函数命令连接起来.
  ;; 下面的命令,先打开一个新的buffer,再执行hello函数，该hello函数的参数是"you"
  (progn
  (switch-to-buffer-other-window "*test*")
  (hello "you"))

  ;; 如果要清空一个buffer,可以调用erase-buffer函数。下面的命令先清空test buffer,再调用hello函数做打印
  (progn
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  (hello "there"))

  ;; 在这一系列的质量后面再添加调用一个other-window函数，这样在hello函数被调用完毕之后
  ;; 光标自动回到之前的buffer窗口中
  (progn
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  (hello "you")
  (other-window 1))

  ;; let函数用来做局部变量的定义 下面的一系列命令中
  ;; let函数首先定义local-name变量的值为“you”
  ;; 然后接着执行括号中其它的语句块部分，这个功能和progn类似
  (let ((local-name "you"))
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  (hello local-name)
  (other-window 1))

  ;; format函数可以用做格式化的输出 其中%s表示该s的地方将被之后提供的一个字符串,即visitor替换
  ;; \n表示换行
  (format "Hello %s!\n" "visitor")

  ;; 现在我们利用format函数来改进之前定义的hello函数
  (defun hello (name)
  (insert (format "Hello %s!\n" name)))

  ;; 执行这个函数结果是"Hello you"，并且光标换到下一行
  (hello "you")

  ;; 下面我们再设计一个greeting函数，该函数接受一个参数name,
  ;; 在函数体的内部又使用了let函数，给一个局部变量your-name赋值
  ;; 最后把参数和局部变量格式化的打印出来
  (defun greeting (name)
  (let ((your-name "Bastien"))
  (insert (format "Hello %s!\n\nI am %s."
  name
  your-name ; 局部变量
  ))))

  ;; 执行greeting函数，并提供"you"字符串作为参数
  (greeting "you")

  ;; read-from-minibuffer函数提供和用户交互的功能，这个函数可以帮助Elisp程序从用户处得到输入
  (read-from-minibuffer "Enter your name: ")

  ;; 比如如果我们希望greeting函数能够从用户处得到姓名，并且做打印格式化的欢迎信息。
  ;; 可以先调用read-from-minibuffer在minibuffer中提示用户输入姓名，
  ;; 然后把得到的结果赋给局部变量your-name，
  ;; 最后insert函数在当前buffer中插入格式化的输出
  (defun greeting (from-name)
  (let ((your-name (read-from-minibuffer "Enter your name: ")))
  (insert (format "Hello!\n\nI am %s and you are %s."
  from-name ; 格式化输出参数1
  your-name ; 格式化输出参数2
  ))))

  ;; 执行这个函数
  (greeting "Bastien")

  ;; 再稍加改进greeting 把结果打印在新的buffer中
  (defun greeting (from-name)
  (let ((your-name (read-from-minibuffer "Enter your name: ")))
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  (insert (format "Hello %s!\n\nI am %s." your-name from-name))
  (other-window 1)))

  ;; 执行这个函数
  (greeting "Bastien")

  == 列表和综合实例 ==

  ;; Lisp中使用括号构造列表，使用setq给变量赋值。
  ;; 下面的命令先构造一个列表，再把这个列表赋给list-of-names变量
  (setq list-of-names '("Sarah" "Chloe" "Mathilde"))
  ;; ^这里的单引号表示这是一个列表

  ;; 如果想要得到列表中的第一个元素，可以使用car函数
  (car list-of-names)

  ;; 如果想要得到列表中的除第一个元素以外的其它元素，可以使用cdr函数
  (cdr list-of-names)

  ;; 以后push函数可p以在列表的头部插入新的元素，所以下面的命令将改变list-of-name中元素的个数
  (push "Stephanie" list-of-names)

  ;; mapcar函数对列表中的把列表中的每一个元素分别取出来，赋给hello函数
  (mapcar 'hello list-of-names)

  ;; 重新定义greeting函数，在一个新的，清空的buffer中，对list-of-names列表中的每一个元素，调用hello函数
  ;; 调用完毕之后，再让光标回到原的buffer中
  (defun greeting ()
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  (mapcar 'hello list-of-names)
  (other-window 1))

  ;;执行这个函数，我们将得到一个名叫test的buffer，其中的内容是
  ;; Hello Stephanie!
  ;; Hello Sarah!
  ;; Hello Chloe!
  ;; Hello Mathilde!
  ;; 暂时先不要关闭这个buffer!后面还有用！
  (greeting)

  ;; 下面我们对buffer做一些更有意思的事情！
  ;; 定义一个replace-hello-by-bonjour函数，顾名思义，就是把hello替换成bonjour
  ;; 该函数首先把光标移到一个叫做test的buffer中
  ;; 再把光标移到该buffer的开头
  ;; 从头开始搜索字符串Hello,并且替换成Bonjour
  ;; 结束之后在把光标移会到一开始的buffer中。
  (defun replace-hello-by-bonjour ()
  (switch-to-buffer-other-window "*test*")
  (goto-char (point-min)) ;该函数把光标移到buffer的开头
  (while (search-forward "Hello")
  (replace-match "Bonjour"))
  (other-window 1))

  ;; 其中 (search-forward "Hello") 在当前的buffer中做前向搜索
  ;; (while x y) 当x 的条件满足时执行y指令 ，当x返回nil时，while循环结束

  ;; 执行这个函数 替换test buffer中的hello
  (replace-hello-by-bonjour)

  ;; test buffer中的结果如下
  ;; Bonjour Stephanie!
  ;; Bonjour Sarah!
  ;; Bonjour Chloe!
  ;; Bonjour Mathilde!

  ;; 在minibuff中，还会有一条错误信息 "Search failed: Hello".
  ;; 把(search-forward "Hello")一句换成如下就不会有错误信息了
  ;; (search-forward "Hello" nil t)

  ;; 其中 nil参数表示 搜索的区域不加限制，直到buffer结束
  ;; 其中t参数指示search-foward函数 跳过错误信息 直接退出

  ;; 新hello-to-bonjour如下：
  (defun hello-to-bonjour ()
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  ;; 对list-of-names列表中的每个元素 使用hello函数
  (mapcar 'hello list-of-names)
  (goto-char (point-min))
  ;; 搜索Hello替换成Bonjour
  (while (search-forward "Hello" nil t)
  (replace-match "Bonjour"))
  (other-window 1))

  ;; 执行这个函数
  (hello-to-bonjour)

  ;; 下面的boldify-names 函数 ，
  ;; 首先把光标挪到名叫test的buffer的开头，
  ;; 然后使用regular expression 搜索 “Bonjour + 其它任何内容” 的pattern，
  ;; 然后对找到的字符加粗。
  (defun boldify-names ()
  (switch-to-buffer-other-window "*test*")
  (goto-char (point-min))
  (while (re-search-forward "Bonjour \<span class="MathJax_Preview">\(.+\\)</span><script type="math/tex">.+\</script>!" nil t)
  (add-text-properties (match-beginning 1) ;返回匹配模式中，最先匹配的位置
  (match-end 1) ;返回最后匹配的位置
  (list 'face 'bold)))
  (other-window 1))

  ;; 执行这个函数
  (boldify-names)

  == 帮助和参考==

  ;; 在Emacs中我们可以通过如下的方式得到变量和函数的帮助信息
  ;; C-h v a-variable RET
  ;; C-h f a-function RET
  ;;
  ;; 下面的命令将打开整个Emacs Manual
  ;;
  ;; C-h i m elisp RET
  ;;
  ;; Emacs Lisp 教程
  ;; https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html

  ;; Thanks to these people for their feedback and suggestions:
  ;; - Wes Hardaker
  ;; - notbob
  ;; - Kevin Montuori
  ;; - Arne Babenhauserheide
  ;; - Alan Schmitt
  ;; - LinXitoW
  ;; - Aaron Meurer
#+END_SRC
*** [[http://emacswiki.org/emacs/ElispCookbook#toc47][Elisp cookbook]]

This page contains snippets of code that demonstrate basic
[[http://www.emacswiki.org/emacs/EmacsLisp][EmacsLisp]] programming
operations in the spirit of the O'Reilly cookbook series of books. For
every task addressed, a worked-out solution is presented as a short,
focused, directly usable piece of code.

All this stuff can be found elsewhere, but it is scattered about in
libraries, manuals, etc. It would be helpful to have here in one spot.

These recipes should be pastable into the =*scratch*= buffer so that
users can hit =‘C-j’= and evaluate them step by step.

There's going to be some overlap with [[http://www.emacswiki.org/emacs/CategoryCode][CategoryCode]],
obviously. Just link to more elaborate pages when appropriate. Should
this page grow too large, we'll split it up later.

**** Strings

The empty string (zero-length string, null string, ...):

#+BEGIN_EXAMPLE
  (zerop (string-match "" "")) ;; O(n)
  ==> t
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (string-equal "" "") ;; O(n)?
  ==> t
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (equal "" "") ;; O(n)?
  ==> t
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (zerop (length "")) ;; O(1)
  ==> t
#+END_EXAMPLE

As a (very minor) space and performance optimization, starting with
Emacs 23, Emacs keeps an interned copy of the empty string as a single
object

#+BEGIN_EXAMPLE
  (eq "" "") ;; O(1)
  ==> t ; nil prior to Emacs 23
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (eq "" (purecopy ""))
  ==> t ; nil prior to Emacs 23
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (eq "" (propertize "" 'face 'italic))
  ==> t ; nil prior to Emacs 23
#+END_EXAMPLE

***** Strings vs buffer text

While it is quite common in other programming languages to work on
strings contained in
[[http://www.emacswiki.org/emacs/variable][variable]]s, in Emacs it is also common to work on text in
[[http://www.emacswiki.org/emacs/buffer][buffer]]s.

***** Substrings

#+BEGIN_EXAMPLE
  (substring "abcdefg" 0 3)
  ==> "abc"
  (substring "abcdefg" -3 -1)
  ==> "ef"
#+END_EXAMPLE

The TO argument is optional:

#+BEGIN_EXAMPLE
  (substring "abcdefg" -3)
  ==> "efg"
#+END_EXAMPLE

Buffers:

#+BEGIN_EXAMPLE
  (with-temp-buffer (insert "abcdefg") (buffer-substring 2 4))
  ==> "bc"
#+END_EXAMPLE

***** starts-with and ends-with predicates

#+BEGIN_EXAMPLE
  (defun string/ends-with (s ending)
    "Return non-nil if string S ends with ENDING."
    (cond ((>= (length s) (length ending))
           (let ((elength (length ending)))
             (string= (substring s (- 0 elength)) ending)))
          (t nil)))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (defun string/starts-with (s begins)
    "Return non-nil if string S starts with BEGINS."
    (cond ((>= (length s) (length begins))
           (string-equal (substring s 0 (length begins)) begins))
          (t nil)))
#+END_EXAMPLE

Faster, simpler:

#+BEGIN_EXAMPLE
  (defun string/ends-with (string suffix)
    "Return t if STRING ends with SUFFIX."
    (and (string-match (rx-to-string `(: ,suffix eos) t)
                       string)
         t))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (defun string/starts-with (string prefix)
    "Return t if STRING starts with prefix."
    (and (string-match (rx-to-string `(: bos ,prefix) t)
                       string)
         t))
#+END_EXAMPLE

***** Processing characters

Reversing a string:

#+BEGIN_EXAMPLE
  (defun string/reverse (str)
    "Reverse the str where str is a string"
    (apply #'string
       (reverse
        (string-to-list str))))
#+END_EXAMPLE

See
[[http://www.emacswiki.org/emacs/CharacterProcessing][CharacterProcessing]]
and
[[http://www.emacswiki.org/emacs/StringModification][StringModification]].
See [[http://www.emacswiki.org/emacs/tr][tr]] for an example mixing
strings and characters.

Looking at characters in a temporary buffer:

#+BEGIN_EXAMPLE
  (with-temp-buffer
    (insert "abcdefg")
    (goto-char (point-min))
    (while (not (= (char-after) ?b)) (forward-char))
    (point))
  ==> 2
#+END_EXAMPLE

***** Trim whitespace

Trim whitespace from the end of a string:

#+BEGIN_EXAMPLE
  (setq test-str "abcdefg  ")
  (when (string-match "[ \t]*$" test-str)
    (message (concat "[" (replace-match "" nil nil test-str) "]")))
#+END_EXAMPLE

Trim whitespace from a string with a Perl-like chomp function:

#+BEGIN_EXAMPLE
  (defun chomp (str)
    "Chomp leading and tailing whitespace from STR."
    (while (string-match "\\`\n+\\|^\\s-+\\|\\s-+$\\|\n+\\'"
                         str)
      (setq str (replace-match "" t t str)))
    str)
#+END_EXAMPLE

Let's not overcomplicate matters:

#+BEGIN_EXAMPLE
  (defun chomp-end (str)
    "Chomp tailing whitespace from STR."
    (replace-regexp-in-string (rx (* (any " \t\n")) eos)
                              ""
                              str))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (defun chomp (str)
    "Chomp leading and tailing whitespace from STR."
    (replace-regexp-in-string (rx (or (: bos (* (any " \t\n")))
                                      (: (* (any " \t\n")) eos)))
                              ""
                              str))
#+END_EXAMPLE

***** Splitting strings

See [[http://www.emacswiki.org/emacs/SplitString][SplitString]].

***** Joining strings

Use =‘mapconcat’= to join a list of strings using a separator string
between them.

Example:

#+BEGIN_EXAMPLE
  (mapconcat 'identity '("" "home" "alex " "elisp" "erc") "/")
    ==> "/home/alex /elisp/erc"
#+END_EXAMPLE

If the separator will be empty, use =‘apply’=:

#+BEGIN_EXAMPLE
  (apply #'concat '("hello, " "world"))
    ==> "hello, world"
#+END_EXAMPLE

#+BEGIN_HTML
  <div class="color one level0">
#+END_HTML

-   :: if the separator is empty then =‘concat’= (or =‘format’=) is
   sufficient - no need for =‘apply’=: =(concat "hello, " "world")= ⇒
   ="hello, world"= --
   [[http://www.emacswiki.org/emacs/DrewAdams][DrewAdams]]

#+BEGIN_HTML
  </div>
#+END_HTML

***** Serialization

Convert forms to strings using =‘prin1-to-string’=, then convert back
from a string using =‘read’=.

#+BEGIN_EXAMPLE
  (length (read (prin1-to-string (make-list 1000000 '(x)))))
    ==> 1000000
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (read (prin1-to-string "Hello World!"))
    ==> "Hello World!"
#+END_EXAMPLE

This works only in the simplest cases. Unfortunately, it doesn't work
for all [[http://www.emacswiki.org/emacs/EmacsLisp][EmacsLisp]] data
types.

#+BEGIN_EXAMPLE
  (read (prin1-to-string (make-hash-table))) ;; Error before Emacs 23.
    ==> #s(hash-table size 65 test eql rehash-size 1.5 [...] data ())
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (read (prin1-to-string (current-buffer)))
    ==> Lisp error: (invalid-read-syntax "#")
#+END_EXAMPLE

***** Formatting

**** Killing text

As the [[http://www.emacswiki.org/emacs/ElispManual][ElispManual]] says,
“Most of the kill commands are primarily for interactive use [...] When
you need to delete text for internal purposes within a Lisp function,
you should normally use deletion functions, so as not to disturb the
kill ring contents.”

The following mimic the =‘kill-’= commands but without disturbing the
[[http://www.emacswiki.org/emacs/kill_ring][kill ring]]. To make them
kill, use =‘kill-region’= instead of =‘delete-region’=.

***** Delete region

The Lisp equivalent of =‘kill-region’= (=‘C-w’=) but without kill-ring
side effects::

#+BEGIN_EXAMPLE
  (delete-region (region-beginning) (region-end))
#+END_EXAMPLE

According to the
[[http://www.emacswiki.org/emacs/ElispManual][ElispManual]], “Few
programs need to use the =‘region-beginning’= and =‘region-end’=
functions.” This is because Lisp code should not rely on nor “alter the
mark unless altering the mark is part of the user-level functionality of
the command. (And, in that case, this effect should be documented.) To
remember a location for internal use in the Lisp program, store it in a
Lisp variable. For example: [...]”

***** Delete line

The equivalent of =‘kill-line’= (=‘C-k’=) but without kill-ring side
effects:

#+BEGIN_EXAMPLE
  (let ((beg (point)))
    (forward-line 1)
    (forward-char -1)
    (delete-region beg (point)))
#+END_EXAMPLE

Alternatively, replacing the =‘let’= with =‘progn’=.

#+BEGIN_EXAMPLE
  (delete-region (point) (progn (forward-line 1)
                                (forward-char -1)
                                (point)))
#+END_EXAMPLE

Or just: =(delete-region (point) (line-end-position))=

The examples with =‘forward-line’= are shown for comparison with other
examples, below.

***** Delete line backwards

The equivalent of killing the line backwards (=‘C-0 C-k’=) but without
kill-ring side effects:

#+BEGIN_EXAMPLE
  (let ((beg (point)))
    (forward-line 0)
    (delete-region (point) beg))
#+END_EXAMPLE

Alternatively, replacing the =‘let’= with =‘progn’=.

#+BEGIN_EXAMPLE
  (delete-region (progn (forward-line 0) (point))
                 (point))
#+END_EXAMPLE

Or just: =(delete-region (line-beginning-position) (point))=

***** Delete line to next line

The equivalent of killing the line and the newline (=‘C-1 C-k’=) but
without kill-ring side effects:

#+BEGIN_EXAMPLE
  (let ((beg (point)))
    (forward-line 1)
    (delete-region beg (point)))
#+END_EXAMPLE

Alternatively, replacing the =‘let’= with =‘progn’=.

#+BEGIN_EXAMPLE
  (delete-region (point) (progn (forward-line 1) (point)))
#+END_EXAMPLE

***** Delete whole line

The equivalent of =‘kill-whole-line’= (=‘C-S-DEL’=) but without
kill-ring side effects:

#+BEGIN_EXAMPLE
  (let ((beg (progn (forward-line 0)
                    (point))))
    (forward-line 1)
    (delete-region beg (point)))
#+END_EXAMPLE

Alternatively, replacing the =‘let’= with =‘progn’=.

#+BEGIN_EXAMPLE
  (delete-region (progn (forward-line 0) (point))
                 (progn (forward-line 1) (point)))
#+END_EXAMPLE

Or just:

#+BEGIN_EXAMPLE
  (delete-region (line-beginning-position)
                 (line-end-position))
#+END_EXAMPLE

***** Delete word

The equivalent of =‘kill-word’= (=‘M-d’=) but without kill-ring side
effects:

#+BEGIN_EXAMPLE
  (let ((beg (point)))
    (forward-word 1)
    (delete-region beg (point)))
#+END_EXAMPLE

Alternatively, replacing the =‘let’= with =‘progn’=.

#+BEGIN_EXAMPLE
  (delete-region (point) (progn (forward-word 1) (point)))
#+END_EXAMPLE

***** Delete sentence

The equivalent of =‘kill-sentence’= (=‘M-k’=) but without kill-ring side
effects:

#+BEGIN_EXAMPLE
  (let ((beg (point)))
    (forward-sentence 1)
    (delete-region beg (point)))
#+END_EXAMPLE

Alternatively, replacing the =‘let’= with =‘progn’=.

#+BEGIN_EXAMPLE
  (delete-region (point) (save-excursion
                           (forward-sentence 1)
                           (point)))
#+END_EXAMPLE

**** Numbers

***** Test whether a string represents a number

#+BEGIN_EXAMPLE
  (defun string-integer-p (string)
    (if (string-match "\\`[-+]?[0-9]+\\'" string)
        t
      nil))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (string-integer-p "1234")
    ==> t
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (string-integer-p "x1234")
    ==> nil
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (string-integer-p "3.141592653589793")
    ==> nil
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (defun string-float-p (string)
    (if (string-match "\\`[-+]?[0-9]+\\.[0-9]*\\'" string)
        t
      nil))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (string-float-p "1234")
    ==> nil
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (string-float-p "3.141592653589793")
    ==> t
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (string-float-p ".1")
    ==> nil
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (string-float-p "1.")
    ==> t
#+END_EXAMPLE

***** String to number

The following example is for instruction. Normally standard function
=‘string-to-number’= would be used.

#+BEGIN_EXAMPLE
  (defun decimal-number (string)
    (let ((n (string-to-number string)))
      (save-match-data
        (if (and (not (zerop n))
                 (string-match "\\`\\s-*0+\\.?0*\\s-*\\'" string))
            n
          nil))))

  (decimal-number "536870911")
  ==> 536870911

  (decimal-number "536870912")
  ==> 536870912.0

  (decimal-number "3.141592653589793")
  ==> 3.141592653589793

  (decimal-number "042")
  ==> 42

  (decimal-number " 0 ")
  ==> 0

  (decimal-number "000")
  ==> 0

  (decimal-number "0.0")
  ==> 0.0
#+END_EXAMPLE

***** Random numbers

#+BEGIN_EXAMPLE
  (random 2)  ;coin toss (0 or 1)
  (+ (random 6) 1)  ;dice
#+END_EXAMPLE

***** Put commas in numbers

#+BEGIN_EXAMPLE
  (defun group-number (num &optional size char)
    "Format NUM as string grouped to SIZE with CHAR."
    ;; Based on code for `math-group-float' in calc-ext.el
    (let* ((size (or size 3))
           (char (or char ","))
           (str (if (stringp num)
                    num
                  (number-to-string num)))
            ;; omitting any trailing non-digit chars
            ;; NOTE: Calc supports BASE up to 36 (26 letters and 10 digits ;)
           (pt (or (string-match "[^0-9a-zA-Z]" str) (length str))))
      (while (> pt size)
        (setq str (concat (substring str 0 (- pt size))
                          char
                          (substring str (- pt size)))
              pt (- pt size)))
      str))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (group-number 299792458)
  ==> "299,792,458"
  (group-number "149597870691" 4 " ")
  ==> "1495 9787 0691"
#+END_EXAMPLE

***** Increment numbers

See [[http://www.emacswiki.org/emacs/IncrementNumber][IncrementNumber]].

***** Dates and times

****** Today's date

#+BEGIN_EXAMPLE
  (defun today-is ()
    "Display current time."
    (interactive)
    (message (format-time-string "Today is %Y-%m-%d %T")))
#+END_EXAMPLE

See
[[http://www.emacswiki.org/emacs/InsertingTodaysDate][InsertingTodaysDate]].

****** Formatting dates

Use the function =‘format-time-string’= which is a build in function in
both Emacsen and works like =‘strftime’=:

#+BEGIN_EXAMPLE
  ;; Year-Month-Day:
  (insert (format-time-string "%Y-%m-%d"))
  ;; Hour:Minutes:Seconds
  (insert (format-time-string "%H-%M-%S"))
#+END_EXAMPLE

****** Conversions

Read a date from a string.

#+BEGIN_EXAMPLE
  (let ((time (date-to-time "Tue, 27-Sep-83 12:35:59 EST")))
    (set-time-zone-rule t) ;; Use Universal time.
    (prog1 (format-time-string "%Y-%m-%d %T UTC" time)
      (set-time-zone-rule nil))) ;; Reset to default time zone.
  ==> "1983-09-27 17:35:59 UTC"
#+END_EXAMPLE

Decode a time object.

#+BEGIN_EXAMPLE
  (decode-time (date-to-time "Tue, 27-Sep-83 12:35:59 EST"))
  ==> (59 35 13 27 9 1983 2 t -14400)
#+END_EXAMPLE

Get the seconds from the unix epoch.

#+BEGIN_EXAMPLE
  (let ((time (date-to-time "13 Feb 2009 23:31:30 UTC")))
    (float-time time))
  ==> 1234585890.0
#+END_EXAMPLE

Find the date for seconds from the unix epoch.

#+BEGIN_EXAMPLE
  (format-time-string "%Y-%m-%d %T UTC" (seconds-to-time 1234585890))
  ==> "2009-02-13 23:31:30 UTC"
#+END_EXAMPLE

Find the date 30 seconds in the future.

#+BEGIN_EXAMPLE
  (format-time-string "%Y-%m-%d %T UTC" (time-add (current-time)
                                                  (seconds-to-time 30)))
  ==> "2012-02-13 10:07:11 UTC"
#+END_EXAMPLE

Formatting elapsed time in years, days, hours, minutes and seconds.

#+BEGIN_EXAMPLE
  (format-seconds "%Y %D %h:%m:%s" (1- (* 367 24 3600)))
  ==> "1 year 1 day 23:59:59"
#+END_EXAMPLE

Find the days between two dates.

#+BEGIN_EXAMPLE
  (let ((days1 (time-to-days (date-to-time "Tue, 27-Sep-83 12:35:59 EST")))
        (days2 (time-to-days (date-to-time "2009-02-13 23:31:30 UTC"))))
    (- days2 days1))
  ==> 9271
#+END_EXAMPLE

Getting the day in the year.

#+BEGIN_EXAMPLE
  (time-to-day-in-year (current-time))
  ==> 44
#+END_EXAMPLE

Build a date based on the day of the year.

#+BEGIN_EXAMPLE
  (format-time-string "%j"
                      (encode-time 0 0 0 44 1 2012))
  ==> "044"
#+END_EXAMPLE

**** Pattern matching

“Patterns” refers to
[[http://www.emacswiki.org/emacs/RegularExpression][RegularExpression]]s.

There's a set of functions that work in strings, and a set that work in
buffers.

***** Finding

#+BEGIN_EXAMPLE
  (string-match "foo*" "Fight foo for food!")
  ==> 6
#+END_EXAMPLE

Using a temporary buffer instead:

#+BEGIN_EXAMPLE
  (with-temp-buffer
    (insert "Fight foo for food!")
    (goto-char (point-min))
    (re-search-forward "foo*")
    (point))
  ==> 10
#+END_EXAMPLE

Alternative without regular expressions: =‘search-forward’=.

The functions working on buffers move
[[http://www.emacswiki.org/emacs/point][point]] to the end of the
occurrence found and return it. That's why the result is 10 instead of
6.

***** Verifying

Sometimes you just want to check whether you're at the right place:

#+BEGIN_EXAMPLE
  (with-temp-buffer
    (insert "Fight foo for food!")
    (goto-char (point-min))
    (looking-at "fight"))
  ==> t
#+END_EXAMPLE

***** Search and replace

#+BEGIN_EXAMPLE
  (replace-regexp-in-string "foo*" "fu" "Fight foo for food!")
  ==> "Fight fu fur fud!"
#+END_EXAMPLE

Using a temporary buffer instead:

#+BEGIN_EXAMPLE
  (with-temp-buffer
     (insert "Fight foo for food!")
     (goto-char (point-min))
     (while (re-search-forward "foo*" nil t)
       (replace-match "fu"))
     (buffer-string))
  ==> "Fight fu fur fud!"
#+END_EXAMPLE

Alternative without regular expressions: =‘search-forward’=.

See also
[[http://www.emacswiki.org/emacs/StringSearchAndReplace][StringSearchAndReplace]].

***** Search and do something with match

This finds numbers and increments them by one. It depends on
=‘decimal-number’= that was defined above. See also
[[http://www.emacswiki.org/emacs/IncrementNumber][IncrementNumber]].

#+BEGIN_EXAMPLE
  (while (re-search-forward "[0-9]" nil t)
    (goto-char (match-beginning 0))
    (when (and (looking-at "[-+]?[0-9]+\\.?[0-9]*")
               (decimal-number (match-string 0)))
      (replace-match
       (number-to-string (1+ (string-to-number (match-string 0)))))
      (goto-char (match-end 0))))
#+END_EXAMPLE

This loads [[http://www.emacswiki.org/emacs/EmacsLisp][EmacsLisp]] files
listed one per line in a text file.

#+BEGIN_EXAMPLE
  (with-current-buffer (find-file-noselect "~/load-files.txt")
    (while (re-search-forward "^.*\\.el\\(\\.gz\\)?$" nil t)
      (let ((filename (match-string 0)))
        (when (file-exists-p filename)
          (load-file filename)))))
#+END_EXAMPLE

***** Extracting submatches from a regex match

Like in most other regex implementations, if you use grouping
parentheses in a regular expression, you can extract the text that
matched each parenthesized group. Groups are numbered from the opening
parenthesis, left to right. These are also called back references, or
backrefs, or matching groups.

#+BEGIN_EXAMPLE
  (save-match-data ; is usually a good idea
    (and (string-match "\\`\\([^@]+\\)@\\([^@]+\\)\\'" email)
         (setq user (match-string 1 email)
               domain (match-string 2 email) ) ))
#+END_EXAMPLE

Usually you would use =*let*= instead of =*setq*= but this is just a
simple self-contained example. See also
[[http://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding][DynamicBindingVsLexicalBinding]].

***** Mapping with a regex

This invokes a function at every match of a
[[http://www.emacswiki.org/emacs/regexp][regexp]]:

#+BEGIN_EXAMPLE
  (defun map-regex (buffer regex fn)
    "Map the REGEX over the BUFFER executing FN.

  FN is called with the match-data of the regex.

  Returns the results of the FN as a list."
    (with-current-buffer buffer
      (save-excursion
        (goto-char (point-min))
        (let (res)
          (save-match-data
            (while (re-search-forward regex nil t)
              (let ((f (match-data)))
                (setq res
                      (append res
                              (list
                               (save-match-data
                                 (funcall fn f))))))))
          res))))
#+END_EXAMPLE

An example use might be:

#+BEGIN_EXAMPLE
  (map-regex
   (find-file-noselect "~/work/elnode-auth/build-parts.txt")
   "^\\(.*.el\\(\\.gz\\)*\\)$"
   (lambda (md)
     (let ((filename (match-string 0)))
       (when (file-exists-p filename)
         (load-file filename))))))
#+END_EXAMPLE

***** Finding all the strings that match

If you want to list all the matching strings, including subexpressions:

#+BEGIN_EXAMPLE
  (defun match-strings-all (&optional string)
    "Return the list of all expressions matched in last search.

  STRING is optionally what was given to `string-match'."
    (let ((n-matches (1- (/ (length (match-data)) 2))))
      (mapcar (lambda (i) (match-string i string))
              (number-sequence 0 n-matches))))
#+END_EXAMPLE

Here's an example:

#+BEGIN_EXAMPLE
  (let ((str "time help"))
    (string-match "time \\([A-Za-z]+\\)$" str)
    (match-strings-all str))
  ==> ("time help" "help")
#+END_EXAMPLE

**** Code Comments

Move to the beginning of the current comment:

#+BEGIN_EXAMPLE
  (require 'newcomment)
  (comment-beginning)
#+END_EXAMPLE

Move to the text after a comment:

#+BEGIN_EXAMPLE
  (comment-search-forward (line-end-position) t)
#+END_EXAMPLE

See also
[[http://www.emacswiki.org/emacs/EndOfLineNoComments][EndOfLineNoComments]].

**** Sequences

Datatypes used to represent sequences of things:

#+BEGIN_EXAMPLE
   _____________________________________________
  |                                             |
  |          Sequence                           |
  |  ______   ________________________________  |
  | |      | |                                | |
  | | List | |             Array              | |
  | |      | |    ________       ________     | |
  | |______| |   |        |     |        |    | |
  |          |   | Vector |     | String |    | |
  |          |   |________|     |________|    | |
  |          |  ____________   _____________  | |
  |          | |            | |             | | |
  |          | | Char-table | | Bool-vector | | |
  |          | |____________| |_____________| | |
  |          |________________________________| |
  |_____________________________________________|
#+END_EXAMPLE

***** Lists

List basics are explained at
[[http://www.emacswiki.org/emacs/ListStructure][ListStructure]]. Lists
can shrink and grow, but access to elements towards the end of the list
is slow if the list is long.

Use =‘cons’=, =‘push’=, or =‘add-to-list’= to prepend a new element to a
list. Use =‘nth’= to access an element of a list.

#+BEGIN_EXAMPLE
  (let ((words '("fight" "foo" "for" "food!")))
    (when (string= "foo" (nth 1 words))
      (setq words (cons "bar" words)))
    words)
  ==> ("bar" "fight" "foo" "for" "food!")
#+END_EXAMPLE

See
[[http://www.emacswiki.org/emacs/ListModification][ListModification]]
for more ways of changing a list.

Iteration:

#+BEGIN_EXAMPLE
  (let ((result  ()))
    (dolist (word  '("fight" "foo" "for" "food!"))
      (when (string-match "o" word) (push word result)))
    (nreverse result))
  ==> ("foo" "for" "food!")
#+END_EXAMPLE

Note how =‘push’= adds an element to the front of the list, so that
usually the list has to be reversed after the loop. =‘nreverse’= is
particularly efficient because it does this destructively. See
[[http://www.emacswiki.org/emacs/DestructiveOperations][DestructiveOperations]]
for more about this.

Copying:

Use =‘copy-sequence’= to make a shallow copy of a list without changing
the original.

#+BEGIN_EXAMPLE
  (let* ((orig '((1 2) (3 4)))
         (copy (copy-sequence orig)))
    (setcdr copy '((5 6)))
    (list orig copy))
  ==> (((1 2) (3 4)) ((1 2) (5 6)))
#+END_EXAMPLE

The elements in the copy remain in the original. More importantly, they
are in fact the same elements (i.e., =‘eq’=), not copies. The list is
copied, but its elements are shared with the original list.

#+BEGIN_EXAMPLE
  (let* ((orig '((1 2) (3 4)))
         (copy (copy-sequence orig)))
    (setcdr (cadr copy) '(0))
    (list orig copy))
  ==> (((1 2) (3 0)) ((1 2) (3 0)))
#+END_EXAMPLE

=‘copy-tree’= is the recursive version of =‘copy-sequence’=.

#+BEGIN_EXAMPLE
  (let* ((orig '((1 2) (3 4)))
         (copy (copy-tree orig)))
    (setcdr (cadr copy) '(0))
    (list orig copy))
  ==> (((1 2) (3 4)) ((1 2) (3 0)))
#+END_EXAMPLE

Filtering:

A =‘filter’= macro has been added to the Emacs development tree. It does
what you expect: filters a list, returning a copy that keeps elements
that satisfy a predicate and omitting elements that do not satisfy it.

If your Emacs does not yet have this built in, you can use =‘dolist’= or
=‘mapcar’= to iterate over a list with a conditional, and then use
=‘delq’= to remove the =‘nil’= values.

#+BEGIN_EXAMPLE
  (defun my-filter (condp lst)
    (delq nil
          (mapcar (lambda (x) (and (funcall condp x) x)) lst)))
#+END_EXAMPLE

Therefore,

#+BEGIN_EXAMPLE
  (my-filter 'identity my-list)
#+END_EXAMPLE

is equivalent to

#+BEGIN_EXAMPLE
  (delq nil my-list)
#+END_EXAMPLE

For example:

#+BEGIN_EXAMPLE
  (let ((num-list '(1 'a 2 "nil" 3 nil 4)))
    (my-filter 'numberp num-list))
  ==> (1 2 3 4)
#+END_EXAMPLE

Package =‘cl-seq’= has functions =‘remove-if’= and =‘remove-if-not’=.
The latter can be used instead of =‘my-filter’=.

#+BEGIN_EXAMPLE
  (let ((num-list '(1 'a 2 "nil" 3 nil 4)))
    (remove-if-not 'numberp num-list))
  ==> (1 2 3 4)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (let ((num-list '(1 'a 2 "nil" 3 nil 4)))
    (remove-if 'numberp num-list))
  ==> ((quote a) "nil" nil)
#+END_EXAMPLE

Here is a version of quicksort:

#+BEGIN_EXAMPLE
  (defun quicksort (lst)
    "Implement the quicksort algorithm."
    (if (null lst) nil
      (let* ((spl (car lst))
             (rst (cdr lst))
             (smalp (lambda (x)
                   (< x spl))))
        (append (quicksort (remove-if-not smalp rst))
                (list spl)
                (quicksort (remove-if smalp rst))))))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (quicksort '(5 7 1 3 -9 8 7 -4 0))
  ==> (-9 -4 0 1 3 5 7 7 8)
#+END_EXAMPLE

The following function was written by
[[http://www.emacswiki.org/emacs/tali713][tali713]] in response to
[[http://www.emacswiki.org/emacs/hypnocat][hypnocat]]'s question
regarding a filter function in
[[http://www.emacswiki.org/emacs/EmacsChannel][#emacs]]:

#+BEGIN_EXAMPLE
  (defun keep-when (pred seq)
    (let ((del (make-symbol "del")))
      (remove del (mapcar (lambda (el)
                (if (funcall pred el) el del)) seq))))
#+END_EXAMPLE

Use:

#+BEGIN_EXAMPLE
  (keep-when 'atom '(1 2 3 (4 5) 6 nil t foo))
  ==> (1 2 3 6 nil t foo)
#+END_EXAMPLE

Updated 31/05/2013.

Tranposing:

Create a list from multiple lists:

#+BEGIN_EXAMPLE
  ((lambda (&rest args)
     (mapcar (lambda (n)
               (delq nil (mapcar (lambda (arg) (nth n arg)) args)))
             (number-sequence 0 (1- (apply 'max (mapcar 'length args))))))
   '(1 2 3) '(a b c) '(A B C))
   ==> ((1 a A) (2 b B) (3 c C))
#+END_EXAMPLE

A more concise version is possible with the the higher-arity version of
=‘mapcar’= available from library =‘cl’=.

#+BEGIN_EXAMPLE
  ((lambda (&rest args)
     (apply (function mapcar*) (function list) args))
   '(1 2 3) '(a b c) '(A B C))
  ==> ((1 a A) (2 b B) (3 c C))
#+END_EXAMPLE

Searching:

You can check for presence of a value in a list using =‘member’= or
=‘memq’=.

#+BEGIN_EXAMPLE
  (let ((words  '("fight" "foo" "for" "food!")))
    (car (member "for" words)))
  ==> "for"
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (let ((re    "\\wo\\b")
        (words '("fight" "foo" "for" "food!")))
    (consp (memq t
             (mapcar (lambda (s) (numberp (string-match re s))) words))))
  ==> t
#+END_EXAMPLE

In the latter, a more efficient algorithm would use a loop (a non-local
exit).

***** Association lists

The [[http://www.emacswiki.org/emacs/ElispManual][ElispManual]] has
examples of finding and deleting values in an
[[http://www.emacswiki.org/emacs/alist][association list]], or alist.
Here are cases when the car values are strings.

#+BEGIN_EXAMPLE
  (assoc "2" '(("2" . 2) ("1" . 1) ("2") ("3" . 3)))
  ==> ("2" . 2)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (mapcar (lambda (c) (cons c (string c))) (number-sequence 56 65))
  ==> ((56 . "8") (57 . "9") (58 . ":") (59 . ";") (60 . "<")
       (61 . "=") (62 . ">") (63 . "?") (64 . "@") (65 . "A"))
  (assq 64
        (mapcar (lambda (c) (cons c (string c))) (number-sequence 56 65)))
  ==> (64 . "@")
  (assq 55
        (mapcar (lambda (c) (cons c (string c))) (number-sequence 56 65)))
  ==> nil
#+END_EXAMPLE

Deleting:

#+BEGIN_EXAMPLE
  (let ((alist '(("a" . 1) ("b" . 2))))
    (delq (assoc "a" alist) alist))
  ==> (("b" . 2))
#+END_EXAMPLE

Matches with a test function other than =‘equal’=:

#+BEGIN_EXAMPLE
  (let ((alist '(("ab" . 1) ("bc" . 2) ("cd" . 3))))
    (assoc-default "c" alist (lambda (x y) (string-match y x))))
  ==> 2
#+END_EXAMPLE

The alist functions are useful for finding the first instance of a value
in any list, not just association lists, and even when there are
duplicates.

The following uses =‘mapcar’= to associate the =‘major-mode’= to each
buffer returned by =‘buffer-list’=, then =‘assq’= to find the first
buffer where the major mode is =‘fundamental-mode’=.

#+BEGIN_EXAMPLE
  (assq 'fundamental-mode
        (mapcar
         (lambda (b)
           (cons (buffer-local-value 'major-mode b) b))
         (buffer-list)))
  ==> (fundamental-mode . #<buffer *Messages*>)
#+END_EXAMPLE

You can also find values in regular lists, by converting them to
association lists with a null cdr.

Here's an association list of random numbers with no associated value.

#+BEGIN_EXAMPLE
  '((8 . nil) (3 . nil) (1 . nil) (7 . nil) (3 . nil) (6 . nil) (9 . nil))
  ==> ((8) (3) (1) (7) (3) (6) (9))
#+END_EXAMPLE

This is really just making a list for each number -- a “list of lists”
-- which can be done with =‘mapcar’= and =‘list’=.

#+BEGIN_EXAMPLE
  (mapcar 'list '(8 3 1 7 3 6 9))
  ==> ((8) (3) (1) (7) (3) (6) (9))
  (assq 3 (mapcar 'list '(8 3 1 7 3 6 9)))
  ==> (3)
#+END_EXAMPLE

***** Vectors

Vectors are fixed in size, and their elements can be accessed in
constant time (neither of which is the case for lists).

#+BEGIN_EXAMPLE
  (let ((words ["fight" "foo" "for" "food!"]))
    (when (string= "foo" (aref words 1))
      (aset words 1 "bar"))
    words)
  ==> ["fight" "bar" "for" "food!"]
#+END_EXAMPLE

****** Convert vector to list

All vectors are sequences and the map functions work on sequences, so:

#+BEGIN_EXAMPLE
  (mapcar 'identity [1 2 3 4])
    ==> (1 2 3 4)
#+END_EXAMPLE

Here is another Lisp idiom for the same thing:

#+BEGIN_EXAMPLE
  (append [1 2 3 4] ())
    ==> (1 2 3 4)
#+END_EXAMPLE

**** Hash tables

Hash tables map keys to values. They are similar to alists, but they are
typically more efficient for a large number of keys.

See [[http://www.emacswiki.org/emacs/HashMap][HashMap]].

***** Storing and retrieving keys and values

By default, hash tables use =‘eql’= to compare keys. This is not
appropriate for strings: =(eql "alex" "alex")= ⇒ nil. Use =‘equal’= in
such cases:

#+BEGIN_EXAMPLE
  (let ((nick-table (make-hash-table :test 'equal)))
    (puthash "kensanata" "Alex Schroeder" nick-table)
    (gethash "kensanata" nick-table))
  ==> "Alex Schroeder"
#+END_EXAMPLE

Iterate:

#+BEGIN_EXAMPLE
  (let ((nick-table (make-hash-table :test 'equal))
        nicks)
    (puthash "kensanata" "Alex Schroeder" nick-table)
    (puthash "e1f" "Luis Fernandes" nick-table)
    (puthash "pjb" "Pascal J. Bourguignon" nick-table)
    (maphash (lambda (nick real-name)
               (setq nicks (cons nick nicks)))
             nick-table)
    nicks)
    ==> ("pjb" "e1f" "kensanata")
#+END_EXAMPLE

***** Sorting keys

Use =‘maphash’= to build up a list of keys, sort it, and then loop
through the list:

#+BEGIN_EXAMPLE
  (let ((nick-table (make-hash-table :test 'equal))
        nicks)
    (puthash "kensanata" "Alex Schroeder" nick-table)
    (puthash "e1f" "Luis Fernandes" nick-table)
    (puthash "pjb" "Pascal J. Bourguignon" nick-table)
    (maphash (lambda (nick real-name)
               (setq nicks (cons nick nicks)))
             nick-table)
    (mapcar (lambda (nick)
              (concat nick " => " (gethash nick nick-table)))
            (sort nicks 'string<)))
    ==> ("e1f => Luis Fernandes"
         "kensanata => Alex Schroeder"
         "pjb => Pascal J. Bourguignon")
#+END_EXAMPLE

**** Files
***** Read

A file can be inserted at point with =‘insert-file-contents’= or
=‘insert-file-contents-literally’=. To get a file as a string,

#+BEGIN_EXAMPLE
  (defun file-string (file)
    "Read the contents of a file and return as a string."
    (with-temp-buffer
      (insert-file-contents file)
      (buffer-string)))
#+END_EXAMPLE

On the chance that a buffer may already be actively visiting the file,
consider using =‘find-file-noselect’=

#+BEGIN_EXAMPLE
  (defun file-string (file)
    "Read the contents of a file and return as a string."
    (with-current-buffer (find-file-noselect file)
      (buffer-string)))
#+END_EXAMPLE

***** Filter

Processing a file is usually done with a temporary buffer:

#+BEGIN_EXAMPLE
  (defun process-file (file)
    "Read the contents of a file into a temp buffer and then do
  something there."
    (when (file-readable-p file)
      (with-temp-buffer
        (insert-file-contents file)
        (goto-char (point-min))
        (while (not (eobp))
          ;; do something here with buffer content
          (forward-line)))))
#+END_EXAMPLE

***** Write

To write something to a file you can create a temporary buffer, insert
the things to write there and write the buffer contents to a file. The
following example read a string and a filename (with completion, but
doesn't need to exist, see
[[http://www.emacswiki.org/emacs/InteractiveCodeChar][InteractiveCodeChar]]
F) and write the string to that file.

#+BEGIN_EXAMPLE
  (defun write-string-to-file (string file)
    (interactive "sEnter the string: \nFFile to save to: ")
    (with-temp-buffer
      (insert string)
      (when (file-writable-p file)
        (write-region (point-min)
                      (point-max)
                      file))))
#+END_EXAMPLE

Another way to do this is via with-temp-file:

#+BEGIN_EXAMPLE
  (defun write-string-to-file (string file)
    (interactive "sEnter the string: \nFFile to save to: ")
    (with-temp-file file
      (insert string)))
#+END_EXAMPLE

***** Input and output (I/O)

This is a nice and simple way to edit a file with Emacs Lisp, especially
when there's a chance the file might be already be visited in Emacs and
its ok to edit the existing buffer.

#+BEGIN_EXAMPLE
  (with-current-buffer (find-file-noselect "~/logfile")
    (goto-char (point-max))
    (insert (format "Hash of last line: %s"
             (md5
              (save-excursion
                (forward-line -1)
                (buffer-substring-no-properties (point)
                                                (line-end-position))))))
    (newline)
    (with-temp-message "Writing file..."
      (save-buffer))
    (message "Writing file...done"))
#+END_EXAMPLE

***** Searching within a File

If you don't have grep, then you may need to write some Lisp which can
find a match in a file.

#+BEGIN_EXAMPLE
  ;; Visit file unless its already open.
  (with-current-buffer (find-file-noselect "~/.emacs")
    (save-excursion ;; Don't change location of point.
      (goto-char (point-min)) ;; From the beginning...
      (if (re-search-forward ".*load-path.*" nil t 1)
          (match-string-no-properties 0)
        (error "Search failed"))))
  ==> "(add-to-list 'load-path \"/usr/share/emacs/site-lisp/\")"
#+END_EXAMPLE

***** Locking

#+BEGIN_EXAMPLE
  (unless (file-locked-p (buffer-file-name))
     (lock-buffer))
#+END_EXAMPLE

***** Stat

An interface to the kernel's stat(2) is provided by the function
file-attributes.

#+BEGIN_EXAMPLE
  (let* ((attrs (file-attributes (buffer-file-name)))
         (atime (nth 4 attrs))
         (mtime (nth 5 attrs))
         (ctime (nth 6 attrs)))
    (concat "File last accessed on "
            (format-time-string "%Y-%m-%d %T" atime) "\n"
            "File last modified on "
            (format-time-string "%Y-%m-%d %T" mtime) "\n"
            "File last changed on "
            (format-time-string "%Y-%m-%d %T" ctime) "\n"))
#+END_EXAMPLE

***** Deleting

#+BEGIN_EXAMPLE
  (if (file-exists-p filename)
      (delete-file filename))
#+END_EXAMPLE

***** Copy, move and rename

#+BEGIN_EXAMPLE
  (copy-file file new-name)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (rename-file file new-dir)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (rename-file file new-name)
#+END_EXAMPLE

**** Directories

***** Listing

All files in a directory sorted by name:

#+BEGIN_EXAMPLE
  (directory-files "~/")
  ==> ("." ".." ".bash_history" ".bashrc" ".emacs" ".emacs.d" "diary" "local" "public_html")
#+END_EXAMPLE

File names matching a regular expression and in no particular order.

#+BEGIN_EXAMPLE
  (directory-files "~/" (not 'absolute) "\\`\\." 'nosort)
  ==> (".emacs.d" ".emacs" ".bash_history" ".bashrc" ".." ".")
#+END_EXAMPLE

File names matching a wildcard expression sorted by name.

#+BEGIN_EXAMPLE
  (let ((default-directory "~/"))
    (file-expand-wildcards "?emacs*"))
  ==> (".emacs" ".emacs.d")
#+END_EXAMPLE

All files sorted by modification time:

#+BEGIN_EXAMPLE
  (let ((default-directory "~/"))
    (sort
      (directory-files default-directory (not 'absolute) nil 'nosort)
      (lambda (a b)
        (time-less-p (nth 5 (file-attributes a))
                     (nth 5 (file-attributes b))))))
  ==> (".bashrc" "diary" "public_html" "local" ".bash_history" ".." ".emacs" ".emacs.d" ".")
#+END_EXAMPLE

***** Recursion

Here's an example of using =‘directory-files’= to find all
subdirectories in a subdirectory.

Could potentially surpass =‘max-lisp-eval-depth’= if the filesystem has
a suffienctly complex number of subdirectories.

#+BEGIN_EXAMPLE
  (defun directory-dirs (dir)
    "Find all directories in DIR."
    (unless (file-directory-p dir)
      (error "Not a directory `%s'" dir))
    (let ((dir (directory-file-name dir))
          (dirs '())
          (files (directory-files dir nil nil t)))
        (dolist (file files)
          (unless (member file '("." ".."))
            (let ((file (concat (file-name-as-directory dir) file)))
              (when (file-directory-p file)
                (setq dirs (append (cons file
                                         (directory-dirs file))
                                   dirs))))))
        dirs))
#+END_EXAMPLE

Giving =‘directory-dirs’= an absolute file name:

#+BEGIN_EXAMPLE
  (directory-dirs "/emacs/lisp")
  ==> ("/usr/share/emacs/23.2/lisp/calc" "/usr/share/emacs/23.2/lisp/calendar"
       "/usr/share/emacs/23.2/lisp/cedet" "/usr/share/emacs/23.2/lisp/cedet/ede" ...)
#+END_EXAMPLE

Setting the =‘default-directory’= to a directory allows
=‘directory-dirs’= to return relative file names for subdirectories.

#+BEGIN_EXAMPLE
  (let ((default-directory "/usr/share/emacs/23.2/lisp"))
    (directory-dirs "."))
  ==> ("./calc" "./calendar" "./cedet" "./cedet/ede" ...)
#+END_EXAMPLE

***** Traversing

A file-tree-walk function has been added to the Emacs development tree.
Until it lands in your version, you can use this:

#+BEGIN_EXAMPLE
  (defun walk-path (dir action)
     "walk DIR executing ACTION with (dir file)"
     (cond ((file-directory-p dir)
            (or (char-equal ?/ (aref dir(1- (length dir))))
                (setq dir (file-name-as-directory dir)))
            (let ((lst (directory-files dir nil nil t))
                   fullname file)
              (while lst
                (setq file (car lst))
                (setq lst (cdr lst))
                (cond ((member file '("." "..")))
                      (t
                       (and (funcall action dir file)
                            (setq fullname (concat dir file))
                            (file-directory-p fullname)
                            (walk-path fullname action)))))))
           (t
            (funcall action
                     (file-name-directory dir)
                     (file-name-nondirectory dir)))))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (defun walk-path-visitor (dir file)
     "Called by walk-path for each file found"
     (message (concat  dir file)))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  (walk-path "~/" 'walk-path-visitor)
#+END_EXAMPLE

***** Path splitting

Splitting the path can be done with =‘split-string’= and with the slash.
Previously, Emacs would determine the character separating directory
names with =‘directory-sep-char’=. However, the variable is obselete
with Emacs 21.1.

#+BEGIN_EXAMPLE
  (split-string default-directory "/")
  ==> ("" "usr" "share" "emacs" "22.2" "lisp" "")
#+END_EXAMPLE

For splitting a path variable, Emacs already has the
=‘parse-colon-path’= function.

#+BEGIN_EXAMPLE
  (parse-colon-path (getenv "PATH"))
  ==> ("/usr/lib/qt-3.3/bin/" "/usr/kerberos/bin/" "/usr/local/bin/" "/usr/bin/" "/bin/" "/usr/local/sbin/" "/usr/sbin/" "/sbin/")
#+END_EXAMPLE

**** Processes

***** Running a program

Run a command without caring about its output.

#+BEGIN_EXAMPLE
  (async-shell-command "emacs")
#+END_EXAMPLE

Run a command and put its output in the current buffer.

#+BEGIN_EXAMPLE
  (shell-command "seq 8 12 | sort" t)
  10
  11
  12
  8
  9
#+END_EXAMPLE

Run a command and put its output in a new buffer.

#+BEGIN_EXAMPLE
  (shell-command "seq 8 12 | sort"
                 (get-buffer-create "*Standard output*"))
#+END_EXAMPLE

Run a command return its output as a string.

#+BEGIN_EXAMPLE
  (shell-command-to-string "seq 8 12 | sort")
#+END_EXAMPLE

Run a command return and insert its output at point in the current
buffer.

#+BEGIN_EXAMPLE
  (insert (shell-command-to-string "date"))
#+END_EXAMPLE

***** Handling signals

**** Sockets

***** Tcp client

***** Tcp server

Perhaps
[[http://www.emacswiki.org/emacs/EmacsEchoServer][EmacsEchoServer]] and
[[http://www.emacswiki.org/emacs/EmacsDaytimeServer][EmacsDaytimeServer]]
can be useful here. Also
[[https://github.com/stsquad/emacs_chrome/blob/master/servers/edit-server.el][Edit
with Emacs' edit-server.el]] which is a more complete server
implementation.

**** Keyboard events

Call function bound to key

#+BEGIN_EXAMPLE
  (funcall (key-binding (kbd "M-TAB")))
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
  (call-interactively (key-binding (kbd "M-TAB")))
#+END_EXAMPLE

**** Test code

Sometimes you might want to insert some demonstration code in a module.
The code should not be run when the module is loaded via =‘require’= or
=‘load’= but when you =‘eval-current-buffer’=. All you need to do add is
add a test condition of =‘eval-buffer-list’=:

#+BEGIN_EXAMPLE
  (dont-compile
    (when (eq (car eval-buffer-list) (current-buffer))
      ...))
#+END_EXAMPLE

*** AnIntroductionTOEmacsLispProgramming
**** 列表处理
***** what is lisp?
Lisp指的是“LISp Processing”（列表处理），和通过把列表放置在括号之间
来处理列表的编程语言。括号标记了列表的边界。有时，一个列表用一个单引号
或一个反引号开头。

列表是lisp的基础。
***** 列表(list)

在lisp中，数据和程序都以同样的方式表示。也就是说，它们都是由空格分隔的、
由括号括起来的单词、数字或者其他列表的列表。

如果一个程序看起来像数据，那么它很容易作为其它程序的数据。这是Lisp的一
个很用用的特性。

+ *原子(atom)* 指的是列表中使用的不可分割的部分。
一个列表可以拆分成不同的部分。
在一个列表中，原子由空格一一分隔。原子可以紧接着括号。
一个没有任何原子的列表称为 *空列表* 即()

原子和列表的书面表示都被称为符号表达式(symbolic expression)，或者称s-
表达式(sexp)。

*字符串*: 双引号中，不论是句子还是段落，都是一个原子，称字符串(string)

列表中的空格无关紧要。多余的空格和换行符只不过是为了方便人们阅读而设计
的。当Lisp读取表达式时，它剔除所有的多余的空格，只保留一个空格使原子分
隔开来。

Lisp中的一个列表——任何列表——都是一个准备运行的程序。运行列表，在Lisp中
称为 *求值(evaluate, eval)* 。
对列表求值，计算机将完成三件事情：
+ 只返回列表本身
+ 返回一个消息
+ 将列表中的第一个符号当做一个命令，然后执行这个命令

当单引号位于一个列表之前时，它告诉lisp不要对这个列表做任何操作，而是仅
仅返回其原样， 称为 *引用（quote）*
当一个列表前面没有引号时，这个列表的第一个符号就很特别了：它是计算机将
要执行的一条指令。如果该指令没有定义，则返回 *void-function* 错误消息。

*Lisp解释器* 的工作方式
- 首先，它查看列表前面是否有单引号，如果有，解释器则返回列表本
- 如果没有单引号，解释器就会查看列表的第一个元素，并判断它是否是一个函
  数定义，如果是函数，则解释器 执行函数定义中的指令。
- 否则，返回一条错误信息。

列表是lisp最基本的工作方式， 除此之外，lisp还有其他复杂方式
- 对一个符号求值，只要该符号前面既没有引号也没有括号。在这种情况下，
  lisp将符号作为变量返回其值，如果符号没有定义，则返回 *void-variable*
  错误信息。
- 特殊表(special form)，一些函数异常并以异常的方式运行。
- Lisp解释器首先解释内部列表，再处理外部列表。

字节编译
Lisp解释器可以解释两种类型的输入：lisp源代码，以及经过特殊处理的被称作
字节编译(byte compiled)的代码。
一般，字节编译的代码文件以.elc作为扩展名，lisp源码以.el作为扩展名。

对表达式进行求值(eval)之后，lisp解释器通常会返回一个值，要么是执行函数
指令的结果，要么是放弃那个函数并返回一个错误消息。
解释器在返回一个值的同时，它可以做些其他事情，例如移动光标或者拷贝一个
文件，这种动作称为 *附带作用(side effect)*

*$ eval-last-sexp*
C-x C-e
对最近一个的符号表达式进行求值

对一个数字求值，将得到这个数字本身——这是数字区别符号的地方。

在Lisp中可以将一个值赋给一个符号，一个符号的值可以是lisp中的任意表达式，
如一个符号，一个数字，一个列表或者一个字符串。有值的一个符号通常被称作
是 *变量(variable)*

*$ fill-column*
**** Practice Evaluation
***** Buffer Namespaces
(buffer-name)
(buffer-file-name)
*nil* is from the Latin word for 'nothing'

***** Getting Buffers
+ (current-buffer)  # Return the current buffer as a Lisp object.
+ (other-buffer) # Return most recently selected buffer other than BUFFER.

***** Switching Buffers
+ (switch-to-buffer BUFFER)
  - e.g. (switch-to-buffer (other-buffer))
+ (set-buffer BUFFER)  # Make buffer BUFFER-OR-NAME current for
  editing operations.

***** Buffer Size and the Location of Point
+ (buffer-size)  # Return the number of characters in the current buffer.
+ (point)  # Return value of point, as an integer.
+ (point-min) # Return the minimum permissible value of point in the
  current buffer.This is 1, unless narrowing (a buffer restriction) is
  in effect.
+ (point-max)  # Return the maximum permissible value of point in the
  current buffer.This is (1+ (buffer-size)), unless narrowing (a
  buffer restriction)is in effect, in which case it is less.

**** How To Write Function Definitions

***** The /defun/ Macro
1. define function
2. five parts
   1) name
   2) a list of arguments
   3) documentation(optional,recommanded)
      + the first line is a complete sentence
      + the second line is not indented
   4) interactive(optional)
   5) body
3. install, return the name. & change the definition
4. ; comment

***** Make a Function Interactive
+ (interactive "p")
+ C-u [NUM] M-x command
+ for the side effect
+ The "p" tells Emacs to pass the prefix argument to the function and
  use its value for the argument of the function.

***** Different Options for interactive
+ more than 20

***** let
+ special form
+ local variable
+ Local variables created by a /let/ expression retain their value
  only within the /let/ expression.
+ return the value of the last expresion in the body

****** parts of a let expression
+ let symbol
+ varlist
  + unintitialied(default nil)
  + var-value
+ body

#+BEGIN_EXAMPLE
  (let ((variable value)
        (variable value)
        variable
        ...)
        bdoy)
#+END_EXAMPLE

** API
+ [[help:string-to-char]]

** char
http://www.gnu.org/software/emacs/manual/html_node/elisp/Near-Point.html

+ char-after
+ char-before
+ followingchar
+ preceding-char

注： *char是Unicode码，是整形数字，不是字符串*

** List
+ http://emacswiki.org/emacs/ListModification#toc4
*** functions
+ delete
+ append
+ remove-duplicates
+ delete-dups
+ cons

*** car & cdr
+ http://blog.csdn.net/yunjie2008/article/details/5684983


car是短语'Contents of the Address part of the Register'；
cdr（'could-er'）是短语'Contents of the Decrement part of the
Register'。这些短语说明了Lisp是在多么原始的机器上被开发的。

**** car
一个list的CAR是list中的第一个元素。(rose violet daisy buttercup)的CAR
就是rose。

执行下面的代码：

(car '(rose violet daisy buttercup))执行这个语句后，回显区将显示rose。
有一个更合理的car函数：first。

car并不从list移除第一个元素；它只返回第一个元素。car执行完后list并没有
发生改变。car是一个无害的函数（'non-destructive'）。


**** cdr
CDR是list中的其余部分，cdr函数返回list中首元素后面的其它元素。因此'(rose
violet daisy buttercup)的CDR部分是(violet daisy buttercup)。

对：
(cdr '(rose violet daisy buttercup))求值将在回显区显示(violet daisy
butercup)

cdr也不从列表中移除元素。

附带说明一下：在这个例子中list前面加了单引号。如果不加，Lisp解释器把
rose当作函数执行。在这个例子中我们并不需要那样。

cdr的一个更合理的名称是：rest。

** let

*** let 在变量列表中定义局部变量时不能引用其它局部变量, 而应该在 body 中使用

#+BEGIN_SRC emacs-lisp

  ;; wrong usage
  (let ((ws (pwd))
        (len (- (length (split-string ws "/" t)) 1)) ; (void-variable ws)
        )
    (message ws)
    )


  ;; right usage
  (let ((ws (pwd))
        (len)
        )
    (message ws)
    (setq len  (- (length (split-string ws "/" t)) 1))
    )
#+END_SRC

** structure
*** Lisp cond and if

当分两种情况时，使用if函数即可，两种以上的情况时，使用cond函数比较方便。

1) 如果a>0,则b=+1；否则，b=-1
   #+BEGIN_EXAMPLE
     (if (a>0)
         (setq b +1)
      (setq b -1))
   #+END_EXAMPLE

2) 如果a>=100，则b=2；如果10<=a<100,则b=1；如果a<10,b=0
   #+BEGIN_EXAMPLE
     (cond
          ((>= a 100) (setq b 2))
          ((>= a 10) (setq b 1))
          (t (setq b 0))
          )
   #+END_EXAMPLE

** variable
*** auto-mode-alist
Alist of filename patterns vs corresponding major mode functions.

*** system-type
the value is a symbol indicating the type of operating
system you are using.
*** mode-line-format
*** emacs-version
;; version numbers of the version of emacs Emacs版本号
;; 在*scratch*使用C-j执行eval-last-sexp(C-x C-e)并在缓冲区显示结
果
*** user-emacs-directory
;;  the value is "~/emacs.d"
*** load-path

** Functions
*** current-time
(current-time) return the current time, as the number of
seconds since 1970-01-01 00:00:00 as a list of integer
*** expand-file-name
(expand-file-name NAME &optional DEFAULT-DIRECTORY)
converts filename NAME to absolute, and canonicalize(规范化)
it.

*** dolist
(dolist (VAR LIST [RESULT]) BODY...)
loop over a list(遍历一个链表，可以类比foreach)
*** directory-files
(directory-files DIRECTORY &optional FULL MATCH NOSORT)
return a list of names of files in DIRECTORY
*** file-regular-p
(file-regular-p FILENAME)
return t if FILENAME names regular file
*** when
(when COND BODY...)
if COND yeilds non-nil, then do BODY; else, return nil
*** load
(load FILE &optional NOERROR NOMESSAGE NOSUFFIX MUST-SUFFIX)
execute a file of Lisp code named FILE
*** setq-default
  (setq-default [VAR VALUE]...)
  set the default value of the variable VAR to VALUE
*** version<=
;; (version<= V1 V2)
;; return r if version V1 is lower(older) than or equal to V2
*** add-to-list
;;(add-to-list LIST-VAR ELEMENT &optional APPEND COMPARE-FN)
*** expand-file-name
;;(expand-file-name NAME &optional DEFAULT-DIRECTORY)
*** prequire
;;(require FEATURE &optional FILENAME NOERROR)
*** defconst
;;(defconst SYMBOL INITVALUE)
;;define SYMBOL as a constant value
*** message
(message FORMAT-STRING &rest ARGS)
Display a message at the bottom of the screen.

*** search-forward
(search-forward STRING &optional BOUND NOERROR COUNT)
Search forward from point for STRING.
Set point to the end of the occurrence found, and return point.

*** search-backward
(search-backward STRING &optional BOUND NOERROR COUNT)
Search backward from point for STRING.
Set point to the beginning of the occurrence found, and return point.

*** buffer-substring
(buffer-substring START END)
Return the contents of part of the current buffer as a string.
The two arguments START and END are character positions;
they can be in either order.

*** substring
(substring STRING FROM &optional TO)

Return a new string whose contents are a substring of STRING.
The returned string consists of the characters between index FROM
(inclusive) and index TO (exclusive) of STRING.  FROM and TO are
zero-indexed: 0 means the first character of STRING.  Negative values
are counted from the end of STRING.  If TO is nil, the substring runs
to the end of STRING.

*** call-process-shell-command
(call-process-shell-command COMMAND &optional INFILE BUFFER DISPLAY &rest ARGS)

Execute the shell command COMMAND synchronously in separate process.
The remaining arguments are optional.
The program's input comes from file INFILE (nil means `/dev/null').
Insert output in BUFFER before point; t means current buffer;
 nil for BUFFER means discard it; 0 means discard and don't wait.
BUFFER can also have the form (REAL-BUFFER STDERR-FILE); in that case,
REAL-BUFFER says what to do with standard output, as above,
while STDERR-FILE says what to do with standard error in the child.
STDERR-FILE may be nil (discard standard error output),
t (mix it with ordinary output), or a file name string.

*** with-temp-buffer
(with-temp-buffer &rest BODY)
Create a temporary buffer, and evaluate BODY there like `progn'.

*** string-match
(string-match REGEXP STRING &optional START)
Return index of start of first match for REGEXP in STRING, or nil.
Matching ignores case if `case-fold-search' is non-nil.

*** match-string
(match-string NUM &optional STRING)
Return string of text matched by last search.
NUM specifies which parenthesized expression in the last regexp.
pp Value is nil if NUMth pair didn't match, or there were less than NUM pairs.
Zero means the entire text matched by the whole regexp or whole string.
STRING should be given if the last search was by `string-match' on STRING.

*** length
(length SEQUENCE)
Return the length of vector, list or string SEQUENCE.

*** nth
(nth N LIST)
Return the Nth element of LIST.
N counts from zero.  If LIST is not that long, nil is returned.

*** progn
(progn BODY...)
Eval BODY forms sequentially and return value of last one.

*** message
(message FORMAT-STRING &rest ARGS)
Display a message at the bottom of the screen.

*** search-forward
(search-forward STRING &optional BOUND NOERROR COUNT)
Search forward from point for STRING.
Set point to the end of the occurrence found, and return point.

*** search-backward
(search-backward STRING &optional BOUND NOERROR COUNT)
Search backward from point for STRING.
Set point to the beginning of the occurrence found, and return point.

*** buffer-substring
(buffer-substring START END)
Return the contents of part of the current buffer as a string.
The two arguments START and END are character positions;
they can be in either order.

*** substring
(substring STRING FROM &optional TO)

Return a new string whose contents are a substring of STRING.
The returned string consists of the characters between index FROM
(inclusive) and index TO (exclusive) of STRING.  FROM and TO are
zero-indexed: 0 means the first character of STRING.  Negative values
are counted from the end of STRING.  If TO is nil, the substring runs
to the end of STRING.

*** call-process-shell-command
(call-process-shell-command COMMAND &optional INFILE BUFFER DISPLAY &rest ARGS)

Execute the shell command COMMAND synchronously in separate process.
The remaining arguments are optional.
The program's input comes from file INFILE (nil means `/dev/null').
Insert output in BUFFER before point; t means current buffer;
 nil for BUFFER means discard it; 0 means discard and don't wait.
BUFFER can also have the form (REAL-BUFFER STDERR-FILE); in that case,
REAL-BUFFER says what to do with standard output, as above,
while STDERR-FILE says what to do with standard error in the child.
STDERR-FILE may be nil (discard standard error output),
t (mix it with ordinary output), or a file name string.

*** with-temp-buffer
(with-temp-buffer &rest BODY)
Create a temporary buffer, and evaluate BODY there like `progn'.

*** string-match
(string-match REGEXP STRING &optional START)
Return index of start of first match for REGEXP in STRING, or nil.
Matching ignores case if `case-fold-search' is non-nil.

*** match-string
(match-string NUM &optional STRING)
Return string of text matched by last search.
NUM specifies which parenthesized expression in the last regexp.
pp Value is nil if NUMth pair didn't match, or there were less than NUM pairs.
Zero means the entire text matched by the whole regexp or whole string.
STRING should be given if the last search was by `string-match' on STRING.

*** length
(length SEQUENCE)
Return the length of vector, list or string SEQUENCE.

*** nth
(nth N LIST)
Return the Nth element of LIST.
N counts from zero.  If LIST is not that long, nil is returned.

*** progn
(progn BODY...)
Eval BODY forms sequentially and return value of last one.

*** point-min
(point-min)
Return the minimum permissible value of point in the current buffer.
This is 1, unless narrowing (a buffer restriction) is in effect.

*** point-max
(point-max)
Return the maximum permissible value of point in the current buffer.
This is (1+ (buffer-size)), unless narrowing (a buffer restriction)
is in effect, in which case it is less.

*** format
(format STRING &rest OBJECTS)
Format a string out of a format-string and arguments.
The first argument is a format control string.
The other arguments are substituted into it to make the result, a string.
The format control string may contain %-sequences meaning to substitute
the next available argument:
%s means print a string argument.  Actually, prints any object, with `princ'.
%d means print as number in decimal (%o octal, %x hex).
%X is like %x, but uses upper case.
%e means print a number in exponential notation.
%f means print a number in decimal-point notation.
%g means print a number in exponential notation
  or decimal-point notation, whichever uses fewer characters.
%c means print a number as a single character.
%S means print any object as an s-expression (using `prin1').

*** goto-char
(goto-char POSITION)
Set point to POSITION, a number or marker.

*** set-mark
(set-mark POS)
Set this buffer's mark to POS.  Don't use this function!
That is to say, don't use this function unless you want
the user to see that the mark has moved, and you want the previous
mark position to be lost.

*** delete-region
(delete-region START END)
Delete the text between START and END.
If called interactively, delete the region between point and mark.

*** other-buffer
(other-buffer &optional BUFFER VISIBLE-OK FRAME)
Return most recently selected buffer other than BUFFER.

*** search-forward-regexp
(search-forward-regexp REGEXP &optional BOUND NOERROR COUNT)

Search forward from point for regular expression REGEXP.
Set point to the end of the occurrence found, and return point.
An optional second argument bounds the search; it is a buffer position.
The match found must not extend after that position.
Optional third argument, if t, means if fail just return nil (no error).
  If not nil and not t, move to limit of search and return nil.
Optional fourth argument is repeat count--search for successive occurrences.

*** replace-string
(replace-string FROM-STRING TO-STRING &optional DELIMITED START END BACKWARD)
Replace occurrences of FROM-STRING with TO-STRING.
This function is usually the wrong thing to use in a Lisp program.
What you probably want is a loop like this:
  (while (search-forward FROM-STRING nil t)
    (replace-match TO-STRING nil t))

*** while
(while TEST BODY...)
If TEST yields non-nil, eval BODY... and repeat.

*** org-current-level
(org-current-level)
Return the level of the current entry, or nil if before the first headline.
The level is the number of stars at the beginning of the headline.

*** org-demote-subtree
(org-demote-subtree)
Demote the entire subtree.  See `org-demote'.

*** org-demote
(org-demote)
Demote the current heading lower down the tree.
If the region is active in `transient-mark-mode', demote all headings
in the region.

*** buffer-file-name
(buffer-file-name)

** elisp doxygen

doxygen 不支持 elisp 或 lisp 语言

** ElispProjects                                                    :project:
*** eshell pwd                                                        :pwd:
#+begin_src emacs-lisp


  (defun tagerill:eshell-at-pwd()
    (interactive)
    (let ((current_path (pwd)))
      (eshell (concat "*"
                     current_path
                     "*"
                     ))
      )
    )
  (setq current_path (pwd))
  (split-string current_path "/")

  ;; (shell &optional buffer)

  ;; run an inferior shell, with i/o through buffer (which defaults to `*shell*').
  ;; interactively, a prefix arg means to prompt for buffer.
  ;; if `default-directory' is a remote file name, it is also prompted
  ;; to change if called with a prefix arg.

  ;; if buffer exists but shell process is not running, make new shell.
  ;; if buffer exists and shell process is running, just switch to buffer.
  ;; program used comes from variable `explicit-shell-file-name',
  ;;  or (if that is nil) from the eshell environment variable,
  ;;  or (if that is nil) from `shell-file-name'.
  ;; if a file `~/.emacs_shellname' exists, or `~/.emacs.d/init_shellname.sh',
  ;; it is given as initial input (but this may be lost, due to a timing
  ;; error, if the shell discards input when it starts up).


  ;; (eshell &optional arg)

  ;; create an interactive eshell buffer.
  ;; the buffer used for eshell sessions is determined by the value of
  ;; `eshell-buffer-name'.  if there is already an eshell session active in
  ;; that buffer, emacs will simply switch to it.  otherwise, a new session
  ;; will begin.  a numeric prefix arg (as in `c-u 42 m-x eshell ret')
  ;; switches to the session with that number, creating it if necessary.  a
  ;; nonnumeric prefix arg means to create a new session.  returns the
  ;; buffer selected (or created).
#+end_src
*** ascii 码表 索引                                                 :ascii:
**** M-x man RET ascii RET
**** defun
#+BEGIN_SRC emacs-lisp
  (defun tagerill:ascii(input-char)
    "根据输入字符输出对应的ascii码值"
    (interactive "schar: ")
    (let ((target-char (string-to-char input-char))
          (i 0))
      ;; 轮询
      (while (and (< i 128) (not (equal i target-char)))
        (setq i (+ 1 i))
        )
      (message "The ascii code of %s is %4d %4x %s" input-char i i)
      )
    )

  ;; string-to-char is a built-in function in `C source code'.
  ;; (string-to-char STRING)
  ;; Return the first character in STRING.


#+END_SRC

*** 智能逗号
*自动增加一个空格*

+ 解除绑定： self-insert-command
+ 重新绑定
+ 最好不要使用global-set-key修改按键的基本绑定，使用define-key

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd ",") nil)
  (global-set-key (kbd ",") (lambda()
                             (interactive)
                             (progn
                               (insert ",")
                               (insert " ")
                               )))
#+END_SRC

*** org 跳转
目标
+ 保存当前point, 然后折叠大纲
+ 返回位点

#+BEGIN_SRC emacs-lisp
  ;; 利用堆栈的思想进行工作流程的跳转
  ;; 在跳转之前将当前point保存到寄存器中，之后可以快速跳回
  ;; 支持嵌套，最多9层，寄存器1-9
  ;; 特别支持了org-mode

  (setq tagerill:work-flow ())


  (defun tagerill:work-jump-push()
    "jump to another heading and jump back"
    (interactive)
    (if (not tagerill:work-flow)
        (setq register-available 1)
      (setq register-available
            (+ 1 (mod (car tagerill:work-flow) 10)))
      )
    (point-to-register register-available)
    ;; 对寄存器队列进行编码，个位表示寄存器，十位表示org标题等级
    (if (equal major-mode 'org-mode)
        (progn
          (add-to-list 'tagerill:work-flow
                       (+ register-available (* 10
                                                (let ((org-current-level 0))
                                                  (search-backward-regexp "^*+ " nil nil)
                                                  (while (=  42 (char-after (point))) ; * ASCII 42
                                                    (setq org-current-level (+ org-current-level 1))
                                                    (forward-char)
                                                    )
                                                  (message "ok %d" org-current-level)
                                                  org-current-level
                                                  ))))
          (org-shifttab 1)
          (goto-char (point-min))

          )
      (add-to-list 'tagerill:work-flow register-available)
      )
    )

  (defun tagerill:work-jump-pop()
    "jump to the rejgester a"
    (interactive)
    (let ((target-register (mod (car tagerill:work-flow) 10))
          (target-org-level (/ (car tagerill:work-flow)  10)))
      (if (not (equal major-mode 'org-mode))
          (jump-to-register target-register)
        (progn (jump-to-register target-register)
               (org-shifttab 1)
               (while (> target-org-level 0)
                 (jump-to-register target-register)
                 (move-beginning-of-line nil)
                 (org-cycle)
                 (setq target-org-level (- target-org-level 1))
                 )
               (jump-to-register target-register))
        )
      (setq tagerill:work-flow (delete (car tagerill:work-flow) tagerill:work-flow))
      )
    )
  (global-set-key  "\C-z[" 'tagerill:work-jump-push)
  (global-set-key "\C-z]" 'tagerill:work-jump-pop)


  ;; (setq a '(1 2))
  ;; (delete (car a) a)

  ;; *
  ;; 1
  ;; (setq a ())
  ;; (add-to-list 'a 2)
  ;; (/ 2 10)
  ;; C-x r SPC runs the command point-to-register, which is an interactive
  ;; compiled Lisp function in `register.el'.

  ;; It is bound to C-x r SPC, C-x r C-SPC, C-x r C-@.

  ;; (point-to-register REGISTER &optional ARG)

  ;; Store current location of point in register REGISTER.
  ;; With prefix argument, store current frame configuration.
  ;; Use C-x r j to go to that location or restore that configuration.
  ;; Argument is a character, naming the register.


  ;; C-x r j runs the command jump-to-register, which is an interactive
  ;; compiled Lisp function in `register.el'.

  ;; It is bound to C-x r j.

  ;; (jump-to-register REGISTER &optional DELETE)

  ;; Move point to location stored in a register.
  ;; If the register contains a file name, find that file.
  ;; (To put a file name in a register, you must use `set-register'.)
  ;; If the register contains a window configuration (one frame) or a frameset
  ;; (all frames), restore that frame or all frames accordingly.
  ;; First argument is a character, naming the register.
  ;; Optional second arg non-nil (interactively, prefix argument) says to
  ;; delete any existing frames that the frameset doesn't mention.
  ;; (Otherwise, these frames are iconified.)


  ;; (org-cycle &optional ARG)

  ;; TAB-action and visibility cycling for Org-mode.

  ;; This is the command invoked in Org-mode by the TAB key.  Its main purpose
  ;; is outline visibility cycling, but it also invokes other actions
  ;; in special contexts.

  ;; - When this function is called with a prefix argument, rotate the entire
  ;;   buffer through 3 states (global cycling)
  ;;   1. OVERVIEW: Show only top-level headlines.
  ;;   2. CONTENTS: Show all headlines of all levels, but no body text.
  ;;   3. SHOW ALL: Show everything.


  ;; org-show-context is a compiled Lisp function in `org.el'.

  ;; (org-show-context &optional KEY)

  ;; Make sure point and context are visible.
  ;; How much context is shown depends upon the variables
#+END_SRC

*** 替换example block 为 src block
#+BEGIN_SRC xml
    <launch>
      <node pkg="nodelet" type="nodelet" name="standalone_nodelet"  args="manager"/>

      <node pkg="nodelet" type="nodelet" name="Plus"
            args="load nodelet_tutorial_math/Plus standalone_nodelet">
        <remap from="/Plus/out" to="remapped_output"/>
      </node>
      <rosparam param="Plus2" file="$(find nodelet_tutorial_math)/plus_default.yaml"/>
      <node pkg="nodelet" type="nodelet" name="Plus2" args="load nodelet_tutorial_math/Plus standalone_nodelet">
        <rosparam file="$(find nodelet_tutorial_math)/plus_default.yaml"/>
      </node>
      <node pkg="nodelet" type="nodelet" name="Plus3" args="standalone nodelet_tutorial_math/Plus">
        <param name="value" type="double" value="2.5"/>
        <remap from="Plus3/in" to="Plus2/out"/>
      </node>
    </launch>
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun tagerill:replace_example_block_with_sepecific_src_block(lang)
    "replace example block in org mode with src block of specific language.
     use with pandoc to org.
     The point should be in the block
  "
    (interactive "slanguage: ")
    (save-excursion
       (let ((_begin (search-backward "#+BEGIN_EXAMPLE"))
             (_end (search-forward "#+END_EXAMPLE"))
             (_from_string_1 "#+BEGIN_EXAMPLE")
             (_to_string_1 (concat "#+BEGIN_SRC" " " lang))
             (_from_string_2 "#+END_EXAMPLE")
             (_to_string_2 "#+END_SRC"))
         (replace-string _from_string_1 _to_string_1 nil _begin _end)
         (replace-string _from_string_2 _to_string_2 nil _begin _end)
         )
       )
    )


  ;; (replace-string FROM-STRING TO-STRING &optional DELIMITED START END
  ;; BACKWARD)

  ;; Replace occurrences of FROM-STRING with TO-STRING.
  ;; Preserve case in each match if `case-replace' and `case-fold-search'
  ;; are non-nil and FROM-STRING has no uppercase letters.
  ;; (Preserving case means that if the string matched is all caps, or capitalized,
  ;; then its replacement is upcased or capitalized.)

  ;; Ignore read-only matches if `query-replace-skip-read-only' is non-nil,
  ;; ignore hidden matches if `search-invisible' is nil, and ignore more
  ;; matches using `isearch-filter-predicate'.

  ;; If `replace-lax-whitespace' is non-nil, a space or spaces in the string
  ;; to be replaced will match a sequence of whitespace chars defined by the
  ;; regexp in `search-whitespace-regexp'.

  ;; Third arg DELIMITED (prefix arg if interactive), if non-nil, means replace
  ;; only matches surrounded by word boundaries.  A negative prefix arg means
  ;; replace backward.

  ;; Operates on the region between START and END (if both are nil, from point
  ;; to the end of the buffer).  Interactively, if Transient Mark mode is
  ;; enabled and the mark is active, operates on the contents of the region;
  ;; otherwise from point to the end of the buffer.

#+END_SRC
*** pandoc html to org                                             :pandoc:
**** 目标
+ 使用pandoc将网页转换为org
+ 过滤
+ 去除冗余信息

**** 设计
1. 语言： sh vs *elisp*
2. 步骤
   + 确定网页内容值得花费一番功夫
     - 内容质量
     - 内容格式
     - 待定的网页
       - roswiki
       - gazebo tutorial
       - gnu emacs manual

   + 获取url源码
   + 过滤尾部多余信息
     - 主要是正文后的评论等
     - 注：头部信息定义了javascript，对富文本不可或缺
     - div块，注意可以嵌套
   + pandoc 转换html为org
   + 去除html多余标签
     - 需要不断收集整理
   + org-mode格式化
   + org标题降级
   + 手动删除无用信息

**** 问题
div块暂时去除不了，嵌套问题，

**** pandoc url to org
#+BEGIN_SRC emacs-lisp
  ;; func: 将网页转换为org
  ;; @param: url
  ;; @param: org headings level 删除
  ;; note： <div>标签可能会嵌套，删除时需要细致
  ;;       在org-mode中调用

  (defun tagerill:url_to_org (url)
    "turn url to org"
    (interactive "surl: ")
    (setq current_level (org-current-level))
    (setq cmd (concat "pandoc -t org \"" url "\"")) ;url中可能含有特殊字符，会影响shell命令执行，所以使用引号括起
    (with-temp-buffer
      (org-mode)
      (if (equal 0 (call-process-shell-command cmd nil t nil))
          (progn
            (goto-char (point-min))
            (save-excursion
              (setq header_end (search-forward-regexp "\\(^\\)\\(* \\)"))) ;匹配以*号和空格开头的行，好不容易 "^* "即可
            (delete-region (point-min) (- header_end 2)) ;删除头部冗余信息

            ;; 替换\_为_,pandoc在转换网页为org-mode时，将_转换为\_,对我是多余的
            (goto-char (point-min))
            (while (search-forward "\\_" nil t) ; 这里需要进行转义，note
              (replace-match "_" nil t))
            ;; (mark-whole-buffer)

            ;; 删除所有#_BEGIN_HTML段

            (while (search-forward "#+BEGIN_HTML" nil t)
              (setq html_begin (- (point) 12))
              (setq html_end (search-forward "#+END_HTML"))
              (delete-region html_begin html_end))

            ;; 多余空行处理

            ;; div块处理

            ;; org headings降级
            (org-mode)
            (goto-char (point-min))
            (setq level_to_be_demote current_level)
            (while (search-forward-regexp "\\(^\\)\\(* \\)" nil t)
              (while (> level_to_be_demote 0)
                (org-demote-subtree)
                (setq level_to_be_demote (- level_to_be_demote 1)))
              (setq level_to_be_demote current_level)
              )
            (kill-ring-save (point-min) (point-max))
            (setq convert_result 1)
            )
        (setq convert_result 0)
        ))
    (if convert_result
        (save-excursion
          (yank))
    ))




  ;; (point-min)
  ;; Return the minimum permissible value of point in the current buffer.
  ;; This is 1, unless narrowing (a buffer restriction) is in effect.


  ;; (point-max)
  ;; Return the maximum permissible value of point in the current buffer.
  ;; This is (1+ (buffer-size)), unless narrowing (a buffer restriction)
  ;; is in effect, in which case it is less.

  ;; (format STRING &rest OBJECTS)
  ;; Format a string out of a format-string and arguments.
  ;; The first argument is a format control string.
  ;; The other arguments are substituted into it to make the result, a string.
  ;; The format control string may contain %-sequences meaning to substitute
  ;; the next available argument:
  ;; %s means print a string argument.  Actually, prints any object, with `princ'.
  ;; %d means print as number in decimal (%o octal, %x hex).
  ;; %X is like %x, but uses upper case.
  ;; %e means print a number in exponential notation.
  ;; %f means print a number in decimal-point notation.
  ;; %g means print a number in exponential notation
  ;;   or decimal-point notation, whichever uses fewer characters.
  ;; %c means print a number as a single character.
  ;; %S means print any object as an s-expression (using `prin1').

  ;; (goto-char POSITION)
  ;; Set point to POSITION, a number or marker.

  ;; (set-mark POS)
  ;; Set this buffer's mark to POS.  Don't use this function!
  ;; That is to say, don't use this function unless you want
  ;; the user to see that the mark has moved, and you want the previous
  ;; mark position to be lost.

  ;; (delete-region START END)
  ;; Delete the text between START and END.
  ;; If called interactively, delete the region between point and mark.


  ;; (other-buffer &optional BUFFER VISIBLE-OK FRAME)
  ;; Return most recently selected buffer other than BUFFER.


  ;; (search-forward-regexp REGEXP &optional BOUND NOERROR COUNT)

  ;; Search forward from point for regular expression REGEXP.
  ;; Set point to the end of the occurrence found, and return point.
  ;; An optional second argument bounds the search; it is a buffer position.
  ;; The match found must not extend after that position.
  ;; Optional third argument, if t, means if fail just return nil (no error).
  ;;   If not nil and not t, move to limit of search and return nil.
  ;; Optional fourth argument is repeat count--search for successive occurrences.


  ;; (replace-string FROM-STRING TO-STRING &optional DELIMITED START END BACKWARD)
  ;; Replace occurrences of FROM-STRING with TO-STRING.
  ;; This function is usually the wrong thing to use in a Lisp program.
  ;; What you probably want is a loop like this:
  ;;   (while (search-forward FROM-STRING nil t)
  ;;     (replace-match TO-STRING nil t))

  ;; (while TEST BODY...)
  ;; If TEST yields non-nil, eval BODY... and repeat.


  ;; (org-current-level)
  ;; Return the level of the current entry, or nil if before the first headline.
  ;; The level is the number of stars at the beginning of the headline.

  ;; (org-demote-subtree)
  ;; Demote the entire subtree.  See `org-demote'.

  ;; (org-demote)
  ;; Demote the current heading lower down the tree.
  ;; If the region is active in `transient-mark-mode', demote all headings
  ;; in the region.

  \_
#+END_SRC

+ 没有实现, (format)函数使用错误，返回nil
***** 结论
花费两个小时写这么一个不完整的函数，值么？ 不知道

*** org anchor  仅展开当前point entry的函数不会写

1. 目标
   + 锚的快速跳转（内部链接）
   + 在在ROS.org中跳转到指定锚
   + 保存现场
   + region 和 光标下单词
   + 增加前缀可以手动输入锚

2. 函数
   + region-begining
   + region-end
   + mark-active


#+BEGIN_SRC emacs-lisp
    (defun tagerill:jump-to-ros-anchor()
      "jump to anchor in ros.org
         verion 0.1"
      (interactive)
      (save-excursion  (tagerill:work-jump-push))
      (if (not mark-active)
          (progn (backward-word)
                 (push-mark)
                 (forward-word))
        )
      (setq target-anchor (buffer-substring (region-beginning)
                                            (region-end)))
      (find-file (expand-file-name "~/Tiger/Journal/ROS.org"))
      (end-of-buffer)
      (insert "[[" target-anchor "]]")
      (org-open-at-point)
      )
  (global-set-key "\C-zr" 'tagerill:jump-to-ros-anchor)
  ;; optenv


    (defun ded/org-show-next-heading-tidily ()
      "Show next entry, keeping other entries closed."
      (if (save-excursion (end-of-line) (outline-invisible-p))
          (progn (org-show-entry) (show-children))
        (outline-next-heading)
        (unless (and (bolp) (org-on-heading-p))
          (org-up-heading-safe)
          (hide-subtree)
          (error "Boundary reached"))
        (org-overview)
        (org-reveal t)
        (org-show-entry)
        (recenter-top-bottom)
        (show-children)
        (recenter-top-bottom)))

    (defun ded/org-show-previous-heading-tidily ()
      "Show previous entry, keeping other entries closed."
      (let ((pos (point)))
        (outline-previous-heading)
        (unless (and (< (point) pos) (bolp) (org-on-heading-p))
          (goto-char pos)
          (hide-subtree)
          (error "Boundary reached"))
        (org-overview)
        (org-reveal t)
        (org-show-entry)
        (recenter-top-bottom)
        (show-children)
        (recenter-top-bottom)))
    ;; optenv



    ;; mark-active is a variable defined in `C source code'.
    ;; Its value is nil
    ;; Local in buffer *Org Src journal.org[ emacs-lisp ]*; global value is the same.
    ;; Automatically becomes permanently buffer-local when set.


    ;; set-mark is a compiled Lisp function in `simple.el'.

    ;; (set-mark POS)

    ;; Set this buffer's mark to POS.  Don't use this function!
    ;; That is to say, don't use this function unless you want
    ;; the user to see that the mark has moved, and you want the previous
    ;; mark position to be lost.

    ;; Normally, when a new mark is set, the old one should go on the stack.
    ;; This is why most applications should use `push-mark', not `set-mark'.
#+END_SRC

*** 在region前后增加文本
+
  http://emacs.stackexchange.com/questions/5430/org-mode-doesnt-seem-to-be-exporting-listings-minted-correctly

#+BEGIN_SRC emacs-lisp
  (defun tag-word-or-region (text-begin text-end)
    "Surround current word or region with given text."
    (interactive "sStart tag: \nsEnd tag: ")
    (let (bds)
      (if (and transient-mark-mode mark-active)
          (progn
            (goto-char (region-end))
            (insert text-end)
            (goto-char (region-beginning))
            (insert text-begin))
        (progn
          (setq bds (bounds-of-thing-at-point 'symbol))
          (goto-char (cdr bds))
          (insert text-end)
          (goto-char (car bds))
          (insert text-begin)))))
#+END_SRC

*** Elisp 备份文件
#+BEGIN_SRC emacs-lisp

  ;; version 0.01
  ;; (defun file_backup()
  ;;   "backup current file"
  ;;   (interactive)
  ;;   (setq filename buffer-file-name)

  ;;   ;; (setq current_time
  ;;   ;;       (call-process-shell-command "date" nil t nil " +%y%m%d-%H-%M"))
  ;;   (setq current_time
  ;;         (format-time-string "%Y%m%d%H%M"))
  ;;   (setq backup_file (concat filename  "_" current_time ".backup"))
  ;;   ;; 调用cp命令，会直接覆盖以前的备份文件，可以加上时间标志
  ;;   ;; (call-process-shell-command "cp" nil nil nil filename backup_file)
  ;;   (write-file backup_file)
  ;;   )


  ;; version 0.1
  (defun tagerill:file_backup()
    "backup current file with timestamp and suffix"
    (interactive)
    (write-file
     (concat
      (buffer-file-name)
      "_"
      (format-time-string "%y-%m-%d-%H-%M")
      ".backup"
      )))
  (global-set-key "\C-cub" 'tagerill:file_backup)

#+END_SRC

1. call-process-shell-command 的返回值

   If BUFFER is 0, `call-process-shell-command' returns immediately
   with value nil.

   Otherwise it waits for COMMAND to terminate and returns a numeric
   exit status or a signal description string.

   所以将标准输出赋值给变量并不是意想的那么直接。

2. shell command VS elisp command
   + elisp command具有可移植性，优先
   + “继承” message

3. 自定义的elisp函数
   + 函数名前缀tagerill:
   + 快捷键前缀：C-c u

*** 获取当前路径相对于根目录(/)的相对路径

1. why: wine 启动目录是当前buffer所在路径，而文件名参数需要是相对路径

2. example

   对于路径 */home/ben/Wally/Journal/*   返回 *../../../../*

3. steps
   1) 获取 buffer 路径字符串，(pwd)

   2) 分割字符串

   3) 构造新的字符串并返回

4. code

   #+BEGIN_SRC emacs-lisp
     (defun buffer-relative-ws()
       """ Return the relative path to / of current buffer"""
       (let ((ws (pwd)) (len) (result ""))
         (message ws)
         (setq len (- (length (split-string ws "/" t)) 1))
         (while (> len 0)                    ; 0 is not nil(nil & [])
           (setq result (format "%s../" result))
           (setq len (- len 1))
           )
         result                              ; is this OK?
         ))
   #+END_SRC

5. test

   #+BEGIN_SRC emacs-lisp
     (setq org-file-apps '((auto-mode . emacs)
                           ("\\.mm\\'" . default)
                           ("\\.x?html?\\'" . default)
                           ;; ("\\.pdf\\'" . "evince %s")
                           ("\\.pdf\\'" . (call-process-shell-command
                                           (format
                                            "wine \'C:\\Program Files\\Foxit Software\\Foxit Reader\\FoxitReader.exe\' %s%s"
                                            (buffer-relative-ws) file)))
                           ("\\.caj\\'" . (call-process-shell-command (format
                                                                       "wine \'C:\\Program Files\\TTKN\\CAJViewer 7.1\\CAJViewer.exe\' %s%s"
                                                                       (buffer-relative-ws) file)))
                           ))
   #+END_SRC

   费了好大力气，才把 org-file-apps 定义好

* IDE                                                             :emacs:ide:
** IDE General
*** smartparens                                               :smartparens:
https://github.com/fuco1/smartparens/wiki/pair-management
**** add pairs
1. global
  #+BEGIN_EXAMPLE
    (sp-pair "\{" "\}") ;; latex literal brackets (included by default)
    (sp-pair "<#" "#>")
    (sp-pair "$" "$")   ;; latex inline math mode. Pairs can have same opening and closing string
  #+END_EXAMPLE
2. local
   #+BEGIN_EXAMPLE
   (sp-local-pair 'LaTeX-mode "\\\\left(" "\\\\right)" :insert "C-b l" :trigger "\\\\l(")
   #+END_EXAMPLE

3. :wrap
   #+BEGIN_EXAMPLE
     (sp-pair "(" ")" :wrap "C-(")
   #+END_EXAMPLE

**** remove pairs
#+BEGIN_EXAMPLE
  ;; the second argument is the closing delimiter, so you need to skip it with nil
  (sp-pair "\{" nil :actions :rem)
  (sp-pair "'" nil :actions :rem)
#+END_EXAMPLE
*** Yasnippet: Yet another snippet extension                      :yasnippet:

**** Reference

+ [[https://github.com/capitaomorte/yasnippet][GitHub]]
+ [[http://capitaomorte.github.io/yasnippet/index.html][Document]]

**** What is yasnippet?

YASnippet is a template system for Emacs. It allows you to type an
abbreviation and automatically expand it into function templates. Bundled
language templates include: C, C++, C\#, Perl, Python, Ruby, SQL, LaTeX,
HTML, CSS and more.

YASnippet是Emacs的一个模版系统.允许输入一个缩写，自动为你扩展为相应的
功能模版。捆绑的语言模版包括 C, C++, C\#, Perl, Python, Ruby, SQL,
LaTeX, HTML, CSS 等等。

**** 基本结构
Yasnippets模板存储要纯文本文件中，Yasnippet以子目录的这些文本文件以子
目录组织这些文件，子目录多是以主模式命名。

变量 *yas-snippet-dirs* 保存Yasnippet模板的路径名。 Yasnippet的默认路
径名是``/path/to/yasnippet/snippets'',目录名变量可以自定义

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{lisp}
  (setq yas-snippet-dirs '("/default/path", "/your/own/path"))
  ;; OR，
  (setq yas-snippet-dirs (append yas-snippet-dirs
                                 '(/your/own/path)))
  \end{minted}
#+end_latex

命令 *yas-global-mode* *yas-reload-all*

**** Yasnippet配置

在Emacs初始化文件中进行以下配置，全局开启Yasnippet辅助模式。

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path
                "~/.emacs.d/plugins/yasnippet")
  (require 'yasnippet)
  (yas-global-mode 1)
#+END_SRC


也可以仅将Yasnippet与某些模式关联.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook
            '(lambda ()
               (yas-minor-mode)))
#+END_SRC

**** 命令
+ yas-new-snippet
+ yas-find-snippet
+ yas-visit-snippet-file
+ yas-expand /used interactively/
+ yas-expand-snippet /used in emacs-lisp code/
+ yas-load-snippet-buffer
+ yas-reload-all


**** yas-expand

Yasnippet扩展模板命令 *yas-expand* 默认绑定在TAB键，可自行修改，如下：

绑定于 *C-M-y*

#+BEGIN_SRC emacs-lisp
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (define-key yas-minor-mode-map (kbd "C-M-y") 'yas-expand)
#+END_SRC

**** 定义模板

*yas-new-snippet* 命令增加亲的自定义模板。在snippet缓冲区中可以看到以
下内容：

#+BEGIN_EXAMPLE
  # -*- mode: snippet -*-
  # name:
  # key:
  # binding: direct-keybinding
  # expand-env: ((some-var some-value))
  # type: command
  # --
#+END_EXAMPLE

1) name    菜单栏中Yasnippet显示的名字
2) key     是触发该模板的关键字
3) bindind和expanding-env   高级特性。
4) # --  后是模板meta内容。在模板中，$0,$1,$2 依次为tab光标停留的点。

注: 编辑完文件之后将其保存在对应主模式的子目录下。

**** snippets
***** python header                                              :python:

#+begin_example
  # -*- mode: snippet; require-final-newline: nil -*-
  # name: py
  # key: py
  # binding: direct-keybinding
  # --
  #! /usr/bin/env python
  # -*- encoding:utf-8 -*-

  $0
#+end_example

snippet: header

***** doxygen cpp                                     :doxygen:cpp:

1. reference

   + [[https://app.yinxiang.com/shard/s52/nl/11551545/fe360834-1a0a-4475-adbb-f11faf65c292?title=%E5%9F%BA%E4%BA%8Edoxygen%E7%9A%84C%2B%2B%E6%B3%A8%E9%87%8A][基于doxygen的C++注释]]

2. yasnippet 自定义风格

   + key 要短
   + 文件名要有意义 key:comment

3. 头文件

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{text}
     # -*- mode: snippet; require-final-newline: nil -*-
     # name: doxygen for header file
     # key: dh
     # binding: direct-keybinding
     # --
     /*!
     ,* \file $1
     ,* \brief $2
     ,*
     ,* ${3:详细概述}
     ,*
     ,* \author Tagerill Wong
     ,* \version ${4:maj.min}
     ,* \date $5
     ,*/
     $0
     \end{minted}
   #+end_latex

   #+BEGIN_SRC cpp
     /*!
      ,* \file test.h
      ,* \brief test
      ,*
      ,* test
      ,*
      ,* \author Tagerill Wong
      ,* \version 1.0
      ,* \date 2015/12/05
      ,*/
     hello world!

   #+END_SRC

4. 命名空间

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{text}
     # -*- mode: snippet; require-final-newline: nil -*-
     # name: doxygen for namespace
     # key: dn
     # binding: direct-keybinding
     # --
     /// \brief $1
     ///
     /// ${2: 命名空间的详细概述}
     $0
     \end{minted}
   #+end_latex

   #+BEGIN_SRC cpp
     /// \brief namespace
     ///
     /// namespace

   #+END_SRC

5. 类

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{text}
     # -*- mode: snippet; require-final-newline: nil -*-
     # name: doxygen for class
     # key: dc
     # binding: direct-keybinding
     # --
     /// \brief $1
     ///
     /// ${2:详细说明}
     \end{minted}
   #+end_latex

   #+BEGIN_SRC cpp
     /// \brief class
     ///
     /// fds
   #+END_SRC

6. 函数

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{text}
     # -*- mode: snippet; require-final-newline: nil -*-
     # name: doxygen for function
     # key: df
     # binding: direct-keybinding
     # --
     /// \brief $1
     ///
     /// ${2:详细说明, 不要标识，需要空行，可以多行}
     /// \param $3
     /// \return $4
     /// \see $5
     $0
     \end{minted}
   #+end_latex

   #+BEGIN_SRC cpp
     /// \brief func
     ///
     /// foo
     /// \param p1 comment
     /// \return commnet
     /// \see what

   #+END_SRC

7. 变量

   1) brief

      #+begin_latex
        \begin{minted}[frame=leftline, mathescape]{text}
        # -*- mode: snippet; require-final-newline: nil -*-
        # name: doxygen for variable, default brief, that is at the end
        # key: //
        # binding: direct-keybinding
        # --
        \\\< $0
        \end{minted}
      #+end_latex

      #+BEGIN_SRC cpp
        int foo;                        ///<
      #+END_SRC

      trick: *//* 使用快捷键生成注释符号，而且位置合适

   2) verbose

      #+begin_latex
        \begin{minted}[frame=leftline, mathescape]{text}
        # -*- mode: snippet; require-final-newline: nil -*-
        # name: doxygen for variable, verbose
        # key: dv
        # binding: direct-keybinding
        # --

        /// \brief $1
        ///
        /// ${2:详细说明}
        ///
        \end{minted}
      #+end_latex

      #+BEGIN_SRC cpp

        /// \brief varible for foo
        ///
        /// foo
        ///
      #+END_SRC

***** DONE babel块                                                :babel:
- state "done"       from "todo"       [2015-11-23 一 11:36]
clock: [2015-11-23 一 11:26]--[2015-11-23 一 11:36] =>  0:10

1. lang $0
2. :export [code | result | both | none]
3. :results [value | output]

*org-alias-list功能不够*

#+begin_example
  # -*- mode: snippet; require-final-newline: nil -*-
  # name: bbl
  # key: bbl
  # binding: direct-keybinding
  # --

  ,#+begin_src ${1:lang} :results ${2:[value | output]} :export ${3:[code | result | both | none]}
  $0
  ,#+end_src
#+end_example


#+begin_src sh :results output :export both
date +%m
#+end_src

#+results:
: 35

*** Projectile                                                 :projectile:

**** reference
+ [[http://tuhdo.github.io/helm-projectile.html][Emacs Minor Manual]]
+ [[https://github.com/bbatsov/projectile][GitHub]]

**** projectile

projectile is a *interaction library* for emacs. its goal is to
provide a nice set of features operating on a project level without
introducing external dependencies(when feasible). for instance -
finding project files has a portable implementation written in pure
emacs lisp without the use of gnu find (but for performance sake an
indexing mechanism backed by external commands exists as well).

projectile tries to be *practical* - portability is great, but if some
external tools could speed up some task substantially and the tools
are available, projectile will leverage them.

by default, *git*, mercurial, darcs and bazaar are considered
projects. so are lein, maven, sbt, scons, rebar and bundler. if you
want to mark a folder manually as a project just create an empty
*.projectile* file in it.


*note* :

after you have created a .projectile file in the directory of your
choice, projectile will only use it after you *restart emacs* from that
directory.

**** projectile-switch-project *C-c p p*
+ Switch to project (default action, bound to  *RET* ): Switch to a
  project and execute an action specified in
  projectile-switch-project-action variable.

+ Open Dired in project's directory ( *C-d* )

+ Open project root in vc-dir or magit ( *M-g* )

+ Switch to Eshell ( *M-e* ): Open a projectin Eshell.

+ Grep in projects ( *C-s* ; add prefix C-u to recursive grep): As you
  type the regexp in the mini buffer, the live grep results will be
  displayed incrementally.

+ Compile project ( *C-c* ): Run a compile command at the project
  root.

+ Remove project(s) ( *M-D* ): Delete marked projects from the list of
  known projects.

**** File management:  *helm-projectile-find-file* , C-c p f
This command lists all files in a project for users to narrow down to
wanted files. Some frequently used actions that cover open, rename,
copy, delete,search and other miscelaneous operations. Once you
mastered the actions of helm-projectile-find-file, you master the
actions of other commands as well since the actions of other commands
are just a subset of helm-projectile-find-file actions. All the key
bindings associated with actions are only available while a Helm
buffer is active. You can think of actions as an mini version of M-x:
only applicable commands are listed, and even those commands have key
bindings. Prefix argument can be applied, when possible.

***** Open
+ Find File (default action bound to  *RET* ): open files; if multiple
  files are marked, using either M-SPC to mark specific files or all
  marked using M-a, all marked files are opened

+ Find file other window ( *C-c o* ): Open file in other window. Very
  useful action and is used in many Helm commands.

+ Find file as root ( *C-c r* ): Another really useful action. With
  this command, you don't have to use Tramp syntax to open file as
  root. Just browse file to anywhere, and when needed, open it as root
  instantly.

+ Find file other frame (C-c C-o): Open file in another frame.

+ Find File in Dired: Open file directory in Dired.

+ Find file in hex dump: Open file using hexl.

+ View file: Open file for read-only.

+ Open file externally ( *C-c C-x* , add prefix C-u to choose a
  program): Open file using external applications. Once an application
  is selected, it is remembered as default application for the
  selected file type.

***** move and remove
+ Rename file(s) ( *M-R* ): Rename marked files. To mark files, press
  M-SPC. You must have two buffers side by side: one is a buffer that
  is running current helm-projectile-find-file command and another is
  destination buffer. When this action is executed, it copies marked
  files to the directory of destination buffers.

+ Serial rename files: Rename multiple files at once to the same name
  differentiated by the index at the end, and move files to a prompted
  directory. If there is a buffer in other window, default to the
  directory of that buffer.

+ Serial rename by symlinking files: Similar to Serial rename files
  but create symbolic links instead.

+ Serial rename by copying files: Similar to Serial rename files but
  copy files instead.

***** Copy and Delete

+ Copy file(s) (M-C): similar to Rename File(s) action but copy marked
  files. You can stay where you are and select any project files from
  anywhere to copy to somewhere! The files are always at your finger
  tips. This is demonstrated at the beginning: Copy files anywhere.

+ Delete File(s) (M-D or C-c d): similar to Rename File(s) action but
  delete marked files. You can stay where you are and delete any file
  anywhere in your project. This is demonstrated at the beginning:
  Delete files anywhere.

***** Search and Replace

+ Grep File(s) (C-s; add prefix C-u for recursive grep): grep current
  highlighted file or marked files. With prefix C-u, recursively grep
  parent directories of marked files. Remember, it only works on
  marked files, or the current file the highlight bar is on.

+ Zgrep (M-g z; add prefix C-u for recursive zgrep): Similar to grep
  but invokes grep on compressed or gzipped files.

+ Locate (C-x C-f, add C-u to specify locate db): Search using locate,
  the same as helm-locate.

***** Miscelaneous

+ Insert as org link (C-c @): Insert the current file that highlight
  bar is on as an Org link.

+ Ediff File (C-=): If only a file is marked (that is the line your
  Helm highlight bar is on), it prompts for another file to
  compare. If two files are marked, starts an Ediff session between
  two files. More than two files are marked, you are prompted for
  another file to compare again.
+ Ediff Merge File (C-c =): Start an Emerge session between selected
  files. Similar to Ediff file action: if one or more than two file
  are marked, prompts for another file. If exactly two files are
  selected, start an Emerge session.

+ Etags (M-.): Invoke Etags using Helm. You can switch back to
  helm-projectile-find-file by pressing C-c p f while inside a Helm
  Etags session. If exists a symbol at point, only lists matches that
  contain the symbol.

+ Switch to Eshell (M-e): Open Eshell in directory of the currently
  selected candidate. If selected candidate is a file, open the
  directory of that file; if selected candidate is a directory. open
  that directory.

+ Eshell command on file(s) (M-!): Run an Eshell command on a marked
  candidates. If Eshell aliases exist, provides completion for those
  aliases.

+ Symlink files(s) (M-S): Create symbolic link, using absolute
  path. If another buffer is available, choose the directory of that
  buffer as destination, similar to Rename files(s) action.

+ Relsymlink file(s): Create symbolic link, using relative path. If
  another buffer is available, choose the directory of that buffer as
  destination, similar to Rename files(s) action.

+ Hardlink file(s) (M-H): Create hard link. If another buffer is
  available, choose the directory of that buffer as destination,
  similar to Rename files(s) action.

+ Checksum File: Generate file checksum and insert the checksum
  kill-ring.

+ Print File (C-c p, add C-u to refresh): Print marked files.

**** Command:  *helm-projectile-find-file-in-known-projects* , C-c p F

This command is another one that can be used outside of any
project. When executed, it lists all files in all known
projects. Depends on your style, use this command or
helm-projectile-switch-project command, when you want to jump to a
file. Note that this command could be slow to show you the list of
files if there is a large number of files. To speed it up, it is
beneficial to enable caching. You will learn about caching at near the
end of this tutorial. With caching, Projectile won't have to build up
a list of files again; it simply reuses, and show you the list
instantly for selecting.

The action menu is the same as helm-projectile-find-file.

**** Command:  *helm-projectile-find-file-dwim* , C-c p g

Usage: Find file based on context at point (do what you mean):

+ If the command finds just a file, it switches to that file
  instantly. This works even if the filename is incomplete, but
  there's only a single file in the current project that matches the
  filename at point. For example, if there's only a single file named
  "projectile/projectile.el" but the current filename is
  "projectile/proj" (incomplete), the command still switches to
  "projectile/projectile.el" immediately because this is the only
  filename that matches.

+ If it finds a list of files, the list is displayed for selecting. A
  list of files is displayed when a filename appears more than one in
  the project or the filename at point is a prefix of more than two
  files in a project. For example, if `projectile-find-file' is
  executed on a path like "projectile/", it lists the content of that
  directory. If it is executed on a partial filename like
  "projectile/a", a list of files with character 'a' in that directory
  is presented.

+ If it finds nothing, display a list of all files in project for
  selecting.

**** Command:  *helm-projectile-find-dir* , C-c p d

Usage: List available directories in the current project.

Available actions:

+ Open Dired in project's directory: Open the directory in a Dired
  buffer.

+ Switch to Eshell (M-e): Open the directory in Eshell.

+ Grep in projects (C-s; add prefix C-u for recurse Grep): Run grep on
  selected directory.

**** Command:  *helm-projectile-recentf* , C-c p e

Usage: List recently visited files in current project. The command has
a subset of actions in helm-projectile-find-file, so once you mastered
the actions in helm-projectile-find-file, you can reuse your knowledge
here.

**** Command:  *helm-projectile-find-other-file* , C-c p a
Usage: Switch between files with the same name but different
extensions. With prefix argument C-u, enable flex-matching that match
any file that contains the name of current file. The command has a
subset of actions in helm-projectile-find-file, so once you mastered
the actions in helm-projectile-find-file, you don't need to learn
anything else.

Other file extensions can be customized with the variable
*projectile-other-file-alist* . The variable looks like this:
#+BEGIN_EXAMPLE
  '(("cpp" "h" "hpp" "ipp")
    ("ipp" "h" "hpp" "cpp")
    ("hpp" "h" "ipp" "cpp")
    ("cxx" "hxx" "ixx")
    ("ixx" "cxx" "hxx")
    ("hxx" "ixx" "cxx")
    ("c" "h")
    ("m" "h")
    ("mm" "h")
    ("h" "c" "cpp" "ipp" "hpp" "m" "mm")
    ("cc" "hh")
    ("hh" "cc")
    ("vert" "frag")
    ("frag" "vert")
    (nil "lock" "gpg")
    ("lock" "")
    ("gpg" ""))
#+END_EXAMPLE

**** Caching

Usage: In large projects, caching can significantly speedup file and
directory listings, making it display instantly. Caching is enabled
by:
#+BEGIN_EXAMPLE
(setq projectile-enable-caching t)
#+END_EXAMPLE

With caching enabled, even if you use Projectile on your home
directory with 30GB, it lists files instantly. Cache is a way to speed
up getting files because Projectile only needs to index your project
once and reuses this result future usages. In case if your project has
new files, you have to add C-u before executing any command to
invalidate the cache (except for helm-projectile-find-other-file and
projectile-find-other-file, C-u is reserved for different behaviour),
or using standalone command invalidate C-c p i to refresh the whole
cache.

+ Command: projectile-invalidate-cache, C-c p i

  Usage: As the command name suggests, it invalidates the current
  cache and retrieves everything as new.

+ Command: projectile-cache-current-file, C-c p z

  Usage: Add the file of current selected buffer to cache.

+ Command: projectile-purge-file-from-cache

  Usage: Remove a file from the cache. Once removed, you won't see it
  appear the next time using file related commands. If you delete a
  file, Projectile automatically removes the file from the cache.

+ Command: projectile-purge-dir-from-cache

  Usage: Remove a directory from the cache.

**** summary
|-----------+---------------------------------------------+--------------------------------------------------------------|
| C-c p h   | helm-projectile                             | Helm interface to projectile                                 |
| C-c p p   | helm-projectile-switch-project              | Switches to another projectile project                       |
| C-c p f   | helm-projectile-find-file                   | Lists all files in a project                                 |
| C-c p F   | helm-projectile-find-file-in-known-projects | Find file in all known projects                              |
| C-c p g   | helm-projectile-find-file-dwim              | Find file based on context at point                          |
| C-c p d   | helm-projectile-find-dir                    | Lists available directories in current project               |
| C-c p e   | helm-projectile-recentf                     | Lists recently opened files in current project               |
| C-c p a   | helm-projectile-find-other-file             | Switch between files with same name but different extensions |
| C-c p i   | projectile-invalidate-cache                 | Invalidate cache                                             |
| C-c p z   | projectile-cache-current-file               | Add the file of current selected buffer to cache             |
| C-c p b   | helm-projectile-switch-to-buffer            | List all open buffers in current project                     |
| C-c p s g | helm-projectile-grep                        | Searches for symbol starting from project root               |
| C-c p s a | helm-projectile-ack                         | Same as above but using ack                                  |
| C-c p s s | helm-projectile-ag                          | Same as above but using ag                                   |
|-----------+---------------------------------------------+--------------------------------------------------------------|

**** projectile: remove existing projects                     :projectile:
[[http://stackoverflow.com/questions/27643917/helm-projectile-how-to-remove-a-project-from-projectile][stackoverflow]]

The function /projectile-remove-known-project/ prompts for a project to
forget about. /projectile-remove-current-project-from-known-projects/
removes the active project.

known projects are stored in the file _~/.emacs.d/projectile-bookmarks.eld_.

note: c-p p p m-d 不起作用

**** ignore files
in /.projectile/

1. *-* ignore specified file or path
   #+BEGIN_EXAMPLE
     -/log
     -/tmp
     -/vendor
     -/public/uploads
   #+END_EXAMPLE

2. wild char
   #+BEGIN_EXAMPLE
     -tmp
     -*.rb
     -*.yml
     -models
   #+END_EXAMPLE

3. *+* ignore evertything except some specified /path/
   #+BEGIN_EXAMPLE
     +/src/foo
     +/tests/foo
   #+END_EXAMPLE

**** bookmark file : [[file:~/.emacs.d/elpa/projectile-20150517.1305/projectile.el::(defcustom%20projectile-known-projects-file][projectile-known-projects-file]]

show me the code

#+BEGIN_SRC emacs-lisp
  (defcustom projectile-known-projects-file
    (expand-file-name "projectile-bookmarks.eld"
                      user-emacs-directory)
    "Name and location of the Projectile's known projects file."
    :group 'projectile
    :type 'string)

  (setq projectile-known-projects-file
        (expand-file-name "mics/projectile-bookmarks.eld"
                          user-emacs-directory))
#+END_SRC

**** cache [[file:~/.emacs.d/elpa/projectile-20150517.1305/projectile.el::(defcustom%20projectile-cache-file][projectile-cache-file]]

#+BEGIN_SRC emacs-lisp
  (setq projectile-cache-file
        (expand-file-name "misc/projectile.cache"
                          user-emacs-directory))

#+END_SRC




**** DONE ignore .git or others svn,  only .projectile
- State "DONE"       from "TODO"       [2015-12-16 三 19:17] \\
  在源码中搜索 .git

#+BEGIN_SRC emacs-lisp
(setq projectile-project-root-files-bottom-up '(".projectile"))
#+END_SRC

/projectile-add-known-project/ 非 interactive

instead

|projectile-cache-current-file   | C-c p z|

**** setting

***** v1.0
#+BEGIN_SRC emacs-lisp
  (require 'projectile)
  (require 'helm-projectile)
  (projectile-global-mode)
  (setq projectile-completion-system 'helm)
  (helm-projectile-on)

  (setq projectile-indexing-method 'alien)

  (setq projectile-switch-project-action 'helm-projectile)

  (setq projectile-enable-caching t)
#+END_SRC

***** v1.1 disable projectile-global-mode or not!!!

#+BEGIN_SRC emacs-lisp
  (require 'projectile)
  (require 'helm-projectile)
  ;; (projectile-global-mode)
  (add-hook 'c++-mode-hook 'projectile-mode)
  (add-hook 'c-mode-hook 'projectitle-mode)
  (add-hook 'python-mode-hook 'projectile-mode)

  (setq projectile-completion-system 'helm)
  (helm-projectile-on)
  (setq projectile-indexing-method 'alien)
  (setq projectile-switch-project-action 'helm-projectile)
  (setq projectile-enable-caching t)
#+END_SRC

***** v1.2 ignore git etc
#+BEGIN_SRC emacs-lisp
  (require 'projectile)
  (require 'helm-projectile)
  (projectile-global-mode)
  ;; (add-hook 'c++-mode-hook 'projectile-mode)
  ;; (add-hook 'c-mode-hook 'projectitle-mode)
  ;; (add-hook 'python-mode-hook 'projectile-mode)

  (setq projectile-completion-system 'helm)
  (helm-projectile-on)
  (setq projectile-indexing-method 'alien)
  (setq projectile-switch-project-action 'helm-projectile)
  (setq projectile-enable-caching t)
  (setq projectile-project-root-files ".projectile")
#+END_SRC

*** folding: hs-minor-mode                                        :folding:

emacs has a minor mode called hs-minor-mode that allows users to fold
and hide blocks of text. blocks are defined by regular expressions
which match the start and end of a text region. for example, anything
in between { and } is a block. the regular expressions are defined in
hs-special-modes-alist.

setup for c/c++:
#+begin_example
(add-hook 'c-mode-common-hook   'hs-minor-mode)
#+end_example

default key bindings:

|-------------+------------------+------------------------------------------------------------------|
| c-c @ c-c   | hs-toggle-hiding | toggle hiding/showing of a block                                 |
| c-c @ c-h   | hs-hide-block    | select current block at point and hide it                        |
| c-c @ c-l   | hs-hide-level    | hide all block with indentation levels below this block          |
| c-c @ c-s   | hs-show-block    | select current block at point and show it.                       |
| c-c @ c-m-h | hs-hide-all      | hide all top level blocks, displaying only first and last lines. |
| c-c @ c-m-s | hs-show-all      | show everything                                                  |
|-------------+------------------+------------------------------------------------------------------|

*** narrowing                                                   :narrowing:
|---------+----------------------------------+--------------------------------------------|
| c-x n d | command: narrow-to-defun         | narrow buffer to current function at point |
| c-x n r | command: narrow-to-regionc-x n n | narrow buffer to active region             |
| c-x n w | command: widen                   | widen buffer                               |
|---------+----------------------------------+--------------------------------------------|

*** sr-speed-bar

To open sr-speedbar, execute the command sr-speedbar-open or
 *sr-speedbar-toggle* .

To close sr-speedbar, execute the command sr-speedbar-close or
sr-speedbar-toggle again.

shortcuts
+ Use SPC to open the children of a node.

+ RET to open the node in another window. If node is a file, open that
  file; if node is a directory, enter that directory; if node is a tag
  in a file, jump to the location of that tag in the file.

+ U to go up parent directory.

+ n or p moves to next or previous node.

+ M-n or M-p moves to next or previous node at the current level.

+ b switches to buffer list using Speedbar presentation. You can also
  open children of each buffer.

+ f switches back to file list.


Best is to use sr-speedbar-toggle only, for simplicity.

sr-speedbar gives the following improvements:

+ Automatically switches directory tree - when you switch buffer - to
  the default-directory of current buffer.

+ Use an Emacs window instead of frame, make it easier to use.

+ C-x 1 deletes every window except Speedbar, so you won't have to
  open again.

+ You can prevent C-x o to jump to sr-speedbar window by setting
  sr-speedbar-skip-other-window-p to `t`. You can still move to
  sr-speedbar window using either the mouse or windmove.

*** helm-company
+ https://github.com/yasuyk/helm-company

*** ecb: Emacs Code Browser                                             :ecb:
+ homepage: http://ecb.sourceforge.net/
+ git: https://github.com/alexott/ecb/
+ blog: http://blog.csdn.net/a593796769/article/details/9000055
+ blog(en): https://truongtx.me/2013/03/10/ecb-emacs-code-browser/


1. what
   ecb, stands for emacs code browser, tranforms your emacs from a
   text editor to a real ide for coding. once activated, it can
   display many useful information that help you program more
   effectively. the ecb’s informational windows can contain:

   + a directory tree,
   + a list of source files in the current directory,
   + a list of functions/classes/methods/… in the current file, (ecb
     uses the semantic bovinator, or imenu, or etags, for getting this
     list so all languages supported by any of these tools are
     automatically supported by ecb too)
   + a history of recently visited files,
   + the speedbar and
   + output from compilation (the “compilation” window) and other
     modes like help, grep, etc. or whatever the user defines to be
     displayed in that window.

2. 配置
   #+begin_example
     (require 'ecb)
     ;; (require 'ecb-autoloads) ;; mepla安装似乎不需要
     (setq stack-trace-on-error nil)
     (setq ecb-auto-activate t
           ecb-tip-of-the-day nil)
   #+end_example

   注：cedet的配置必须在ecb之前，不然ecb就会调用自带的cedt！

**** basic configures

1. Layout
   + (setq ecb-layout-name "layout-name")
   + layouts:
     http://ecb.sourceforge.net/docs/Changing-the-ECB-layout.html

2. Show source files in directories buffer

   (setq ecb-show-sources-in-directories-buffer 'always)

3. compile window

   By default, ECB hides the compilation window. Everytime I compile,
   it displays the compilation message to the same window as the
   buffer that I’m editing. This is really annoying because I want to
   see all the messages so that I can fix the error in my code
   easily. To keep a persistent compile window in ECB, add this to
   your .emacs

  (setq ecb-compile-window-height 12)

4. keybinds
   #+BEGIN_EXAMPLE
     ;;; activate and deactivate ecb
     (global-set-key (kbd "C-x C-;") 'ecb-activate)
     (global-set-key (kbd "C-x C-'") 'ecb-deactivate)
     ;;; show/hide ecb window
     (global-set-key (kbd "C-;") 'ecb-show-ecb-windows)
     (global-set-key (kbd "C-'") 'ecb-hide-ecb-windows)
     ;;; quick navigation between ecb windows
     (global-set-key (kbd "C-)") 'ecb-goto-window-edit1)
     (global-set-key (kbd "C-!") 'ecb-goto-window-directories)
     (global-set-key (kbd "C-@") 'ecb-goto-window-sources)
     (global-set-key (kbd "C-#") 'ecb-goto-window-methods)
     (global-set-key (kbd "C-$") 'ecb-goto-window-compilation)
   #+END_EXAMPLE

5. window restore

   Personally, I don’t like those function ecb-deactivate,
   ecb-show-ecb-windows, ecb-hide-ecb-windows since I usually have to
   open multiple windows in Emacs. When deactivate or hide ECB window,
   it does not automatically restore the window layout and switch to
   the buffer that I’m editing. Similar problem happens when I try to
   show ecb window again.

*** check
**** flymake
+ http://flymake.sourceforge.net/


Flymake is implemented as an Emacs minor mode. It runs the syntax
check tool in the background, passing it a temporary copy of the
current buffer, and parses the output for known error/warning message
patterns. Flymake then highlights erroneous lines (that is, lines for
which at least one error or warning has been reported), and displays
an overall buffer status in the mode line.

Unfortunately, this project is outdated and last change was 3 years ago.

**** flycheck
+ http://www.emacswiki.org/emacs/Flycheck
+ https://github.com/flycheck/flycheck


Flycheck is a modern on-the-fly syntax checking extension, and a
modern alternative to Flymake. It supports 39 languages with 65 syntax
checkers out of the box.


1. Install and enable Flycheck

   To get started with Flycheck, enable it by adding the following to
   your init file:
   (add-hook 'after-init-hook #'global-flycheck-mode)

   If you don’t know where your init file is take a look at the value
   of the variable user-init-file with C-h v user-init-file.

2. Install syntax checker tools

   Next you need to install syntax checking tools for the major modes
   you are using. For instance, for

   + Python Pylint:   $ pip install pylint

   + C/C++

     1) c/c++-clang (syntax and type check with Clang) or c/c++-gcc
        (syntax and type check with  *GCC* ), and

     2) c/c++-cppcheck (style and error check with  *cppcheck* ).

   + Emacs Lisp

     1) emacs-lisp (syntax check with the built-in Emacs byte compiler)

     2) eemacs-lisp-checkdoc (code and documentation check with checkdoc)

   + shell

     1) Syntax check with one of the following checkers, depending on
        the shell used for the current Sh Mode buffer,
        + sh-bash (for Bash)
        + sh-posix-dash or sh-posix-bash (for POSIX shell scripts, using Dash or Bash respectively)
        + sh-zsh (for Zsh)

     2) sh-shellcheck (code and style check using ShellCheck)

   + TeX/LaTeX
     + tex-chktex (style check using ChkTeX), or

     + tex-lacheck (style check using Lacheck)

   + XML
     + xml-xmlstarlet (using XMLStarlet), or

     + xml-xmllint (using xmllint)

   + YAML
     + yaml-jsyaml (using js-yaml), or

     + yaml-ruby (using Ruby’s YAML parser)

   See Supported languages, for a complete list of all languages that
   Flycheck supports.

3. Check syntax in a buffer

   Now switch to a Python or Ruby Mode buffer and run M-x
   flycheck-verify-setup to check whether Flycheck is correctly setup.

   If everything is fine Flycheck will now check syntax using these
   tools, when you visit a buffer in any of these languages. Syntax
   checking happens automatically when you save the buffer or make any
   changes. Flycheck highlights errors and warnings in the buffer,
   indicates them in the fringe, and reports their numbers in the mode
   line.

   You can also manually check a buffer with C-c ! c (flycheck-buffer).

4. Navigate and list errors

   Use C-c ! n (flycheck-next-error) and C-c ! p
   (flycheck-previous-error) to navigate between error locations. If
   you keep the point at an error location, Flycheck will show the
   error message in the echo area after a short delay. You can also
   hover error locations with the mouse and see the error message in a
   tooltip.

   To get an overview of all errors and warnings in the current
   buffer, type C-c ! l (flycheck-list-errors) to pop up a list of all
   errors in your current buffer. The error list updates automatically
   when you fix errors or introduce new ones, or when you switch to
   another buffer.

5. check warning
   +
     http://stackoverflow.com/questions/15552349/flycheck-how-to-disable-warnning-while-edit-emacs-lisp-scripts


   e.g.
   + The first line should be of the form: ";;; package --- Summary"
   +

   These are Checkdoc warnings. To disable these, add
   emacs-lisp-checkdoc to the option flycheck-disabled-checkers,
   either with the following code in your init file,  or via the
   customize interface with M-x customize-variable RET
   flycheck-disabled-checkers.

   #+BEGIN_EXAMPLE
     (with-eval-after-load 'flycheck
       (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
   #+END_EXAMPLE

**** emacs-flymake
*** auto-complete                                            :autocomplete:
+ emacswiki: http://emacswiki.org/emacs/autocomplete
+ git: https://github.com/auto-complete/auto-complete
+ manual: http://auto-complete.org/doc/manual.html

**** auto-complete-c-headers
+ https://github.com/mooz/auto-complete-c-headers

*** IDE 快捷键
**** Basic Movements
|---------+--------------------|
| C-M-f   | forward-sexp       |
| C-M-b   | backwward-sexp     |
| C-M-k   | kill-sexp          |
| C-M-SPC | mark-sexp          |
| C-M-a   | beginning-of-defun |
| C-M-e   | end-of-defun       |
| C-M-h   | mark-defun         |
|---------+--------------------|

**** function-args
|-------+-----------------|
| M-i   | fa-show         |
| M-j   | fa-jump         |
| M-n/h | cycle overloads |
| M-u   | dismiss hint    |
| M-o   | moo-complete    |
|-------+-----------------|

**** senator
|-----------+------------------------------|
| C-c , n   | senator-next-tag             |
| C-c , p   | senator-previous-tag         |
| C-c , u   | senator-go-up-reference      |
| C-c , M-w | senator-copy                 |
| C-c , C-w | senator-kill-tag             |
| C-c , C-y | senator-yank-tag             |
| C-c , C-r | senator-copy-tag-to-register |
|-----------+------------------------------|

**** projectile
|-----------+-------------------------------------------|
| C-c p p   | switch visited projects                   |
|-----------+-------------------------------------------|
| RET       | switch to project                         |
| C-d       | open dired                                |
| M-g       | open project root in magit                |
| M-e       | switch to eshell                          |
| C-s       | grep in project                           |
| C-c       | compile                                   |
|-----------+-------------------------------------------|
| M-D       | Delete marked projects from the list      |
| M-SPC     | mark specific file                        |
| C-c o     | open file in other window                 |
| C-c r     | find file as root                         |
| C-c C-o   | open file n another frame                 |
| C-c C-x   | open file externally                      |
|-----------+-------------------------------------------|
| C-c p f   | jump to file                              |
| C-c p d   | jump to directory                         |
| C-c p b   | list buffers local to current project     |
| C-c p e   | jump to recently visited files in peoject |
| C-c p g s | grep in project                           |
| C-c p a   | switch between .c and .h                  |
| C-c p c   | compile, default make                     |
|-----------+-------------------------------------------|

**** folding
|-------------+--------------------------------------------|
| C-c @ C-c   | Command: hs-toggle-hiding                  |
|             | Toggle hiding/showing of a block           |
|-------------+--------------------------------------------|
| C-c @ C-h   | Command: hs-hide-block                     |
|             | Select current block at point and hide it  |
|-------------+--------------------------------------------|
| C-c @ C-l   | Command: hs-hide-level                     |
|             | Hide all block with indentation levels     |
|             | below this block                           |
|-------------+--------------------------------------------|
| C-c @ C-s   | Command: hs-show-block                     |
|             | Select current block at point and show it. |
|-------------+--------------------------------------------|
| C-c @ C-M-h | Command: hs-hide-all                       |
|             | Hide all top level blocks, displaying      |
|             | only first and last lines.                 |
|-------------+--------------------------------------------|
| C-c @ C-M-s | Command: hs-show-all                       |
|             | Show everything                            |
|-------------+--------------------------------------------|

**** narrowing
|---------+--------------------------------------------|
| C-x n d | Command: narrow-to-defun                   |
| C-x n r | Command: narrow-to-region                  |
| C-x n n | Narrow buffer to active region             |
| C-x n w | Command: widen                             |
|---------+--------------------------------------------|

**** compile
|------+-----------------------------------------------------------|
| C-o  | Display matched location, but do not switch point to      |
|      | matched buffer                                            |
|------+-----------------------------------------------------------|
| M-n  | Move to next error message, but do not visit error        |
|      | location                                                  |
|------+-----------------------------------------------------------|
| M-p  | Move to next previous message, but do not visit error     |
|      | location                                                  |
|------+-----------------------------------------------------------|
| M-g n | Move to next error message, visit error location          |
|------+-----------------------------------------------------------|
| M-g p | Move to previous error message, visit error location      |
|------+-----------------------------------------------------------|
| RET  | Visit location of error at poiint                         |
|------+-----------------------------------------------------------|
| M-{  | Move point to the next error message or match occurring   |
|      | in a different file                                       |
|------+-----------------------------------------------------------|
| M-}  | Move point to the previous error message or match         |
|      | occurring in a different file                             |
|------+-----------------------------------------------------------|
| q    | Quit *compilation* buffer                                 |
|------+-----------------------------------------------------------|

**** gdb
*** man
1. Command:  *man*

   To read the documentation for symbol at point or a man entry of
   your choice, invoke M-x man.

2. Command:  *helm-man-woman*

   If you use Helm, you should be able to use the command
   helm-man-woman, which is bound to C-c h m if you follow my Helm
   guide.



*** Linux C++ 多线程                                         :linux:thread:
**** why 线程
1. 节省空间时间
2. 通信机制（方便）
**** Linux下的多线程
***** pthread
遵循POSIX线程接口， *pthread*,
头文件： <pthread.h>
库文件： libpthread.a
方法：clone()， 类似fork()

#+begin_latex
\begin{minted}[frame=single, mathescape]{cpp}
#include <iostream>
#include <unistd.h>
#include <pthread.h>

using namespace std;

void *thread(void *ptr){
  for(int i=0; i<3; i++){
    sleep(1);
    cout << "This is a pthread."  << endl;
  }

  return 0;
}

int main(int argc, char *argv[])
{
  pthread_t id;
  int ret = pthread_create(&id, NULL, thread, NULL);
  if(ret){
    cout << "Created pthread error!" << endl;
    return -1;
  }
  for(int i=0; i<3; i++){
    cout << "This is the main process." << endl;
    sleep(1);
  }
  pthread_join(id, NULL);
  return 0;
}

\end{minted}
#+end_latex

***** g++ 编译
#+begin_latex
\begin{minted}[frame=single, mathescape]{sh}
g++ thread.cpp  # 链接错误
g++ -lpthread thread.cpp  # 链接错误
g++ thread.cpp -lpthread  # 正确
g++ -pthread thread.cpp  # 正确
\end{minted}
#+end_latex

1. *实际的做法应该是在代码文件后面添加次选项。*
2. -lpthread VS -pthread
   1) -lpthread 传统的，老式的
   2) 可见编译选项中指定 -pthread 会附加一个宏定义 *-D_REENTRANT* ，该宏
      会导致 libc 头文件选择那些thread-safe的实现；链接选项中指定
      -pthread 则同 -lpthread 一样，只表示链接 POSIX thread 库。由于
      libc 用于适应 thread-safe 的宏定义可能变化，因此在编译和链接时都
      使用 -pthread 选项而不是传统的 -lpthread 能够保持向后兼容，并提
      高命令行的一致性。

***** 常用函数

1. *pthread_t* 线程标识符
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{cpp}
        typedef unsigned long int pthread$_t;
     \end{minted}
   #+end_latex

2. *pthread_create* 创建线程
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{cpp}
     extern int pthread_create (pthread_t *__restrict __newthread,
                                const pthread_attr_t *__restrict __attr,
                                void *(*__start_routine) (void *),
                                void *__restrict __arg) __THROWNL __nonnull ((1, 3));
     \end{minted}
   #+end_latex
   1) arg1： 指向线程标识符的指针
   2) arg2： 设置线程属性，NULL表示默认
   3) arg3： 线程运行函数的起始地址
   4) arg4： 运行函数的参数，NULL表示零参
   5) 返回值： 0表示创建线程成功，失败则返回其它。
      + EAGAIN: 系统限制创建线程
      + EINVAL: 线程属性值非法

3. *pthread_join* 用来等待一个线程的结束
   #+begin_latex
   \begin{minted}[frame=single, mathescape]{cpp}
   extern int pthread_join (pthread_t __th, void **__thread_return);
   \end{minted}
   #+end_latex
   1) arg1: 线程标识符指针
   2) arg2: 用户定义的指针，用来存储被等待线程的返回值。

4. *pthread_exit*

***** 线程属性

对于大多数程序来说，默认属性(NULL)就足够了。线程属性包括：是否绑定、是
否分离、堆栈地址、堆栈大小、优先级。默认的属性为非绑定、非分离、缺省1M
的堆栈、与父进程同样级别的优先级。

属性结构 *pthread_attr_t* 定义在头文件<pthread.h>中。

属性值不能直接设置，必须使用相关函数。
+ pthread_attr_init
+ pthread_attr_setscope等

** [[http://tuhdo.github.io/c-ide.html][Emacs C++ IDE]]

*** 功能分析

+ [X] 头文件和源文件之间的跳转(switch between .h and .c/.cpp)
  - helm-gtags-dwim 项目中跳转

+ [ ] 利用gtag在源文件之间跳转 (helm-gtags)

+ [ ] 交互式大纲 (function-args /moo-jump-local/)

+ [X] 文件目录树 (ecb, 不用 speedbar)
  - ecb

+ [ ] 符号引用

+ [ ] 代码补全 (helm窗口)

+ [ ] 头文件补全

+ [ ] 底边栏显示函数接口和变量定义

+ [ ] 顶部显示当前位置函数

+ [ ] 编译支持

+ [ ] 编译输出的可视化

+ [ ] GDB调试

+ [ ] man帮助手册

*** 基本操作

|-----------+--------------------+----------------------|
| C-M-f     | forward-sexp       | 前向匹配             |
| C-M-b     | backward-sexp      | 后向匹配             |
| C-M-k     | kill-sexp          | 删除匹配之间的区域   |
| C-M-SPC/@ | mark-sexp          | 选中匹配区域         |
| C-M-a     | beginning-of-defun | 将光标移至函数起始处 |
| C-M-e     | end-of-defun       | 将光标移至函数结尾处 |
| C-M-h     | mark-defun         | 选中函数定义         |
|-----------+--------------------+----------------------|

*** gtags                                                           :gtags:
**** intro: [[http://www.gnu.org/software/global/][GNU GLOBAL]]    :gtags:

GNU GLOBAL is a source code tagging system that works the same way
across diverse environments, such as Emacs editor, Vi editor, Less
viewer, Bash shell, various web browsers, etc.

首先在项目根目录下使用 *gtags* 命令生成标签数据库文件
+ /GTAGS/: definition database
+ /GRTAGS/: reference database
+ /GPATH/: path name database

e.g
#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{text}
  linux-stable $ du -h G*
  8.7M    GPATH
  318M    GRTAGS
  127M    GTAGS
  \end{minted}
#+end_latex

**** shortcuts                                                  :shortcut:

|---------+----------------------------------|
| C-c g a | helm-gtags-tags-in-this-function |
| C-j     | helm-gtags-select                |
| C-c g . | helm-gtags-dwim                  |
| C-c g , | helm-gtags-pop-stack             |
| C-c g < | helm-gtags-previous-history      |
| C-c g > | helm-gtags-next-history          |
| C-c g f | helm-gtags-find-files            |
| C-c g s | helm-gtags-find-symbol           |
| C-c g r | helm-gtags-find-reference        |
|---------+----------------------------------|

**** helm-gtags

#+BEGIN_SRC emacs-lisp
  (setq
   helm-gtags-ignore-case t
   helm-gtags-auto-update t
   helm-gtags-use-input-at-cursor t
   helm-gtags-pulse-at-cursor t
   helm-gtags-prefix-key "\C-cg"
   helm-gtags-suggested-key-mapping t
   )

  (require 'helm-gtags)
  ;; Enable helm-gtags-mode
  (add-hook 'dired-mode-hook 'helm-gtags-mode)
  (add-hook 'eshell-mode-hook 'helm-gtags-mode)
  (add-hook 'c-mode-hook 'helm-gtags-mode)
  (add-hook 'c++-mode-hook 'helm-gtags-mode)
  (add-hook 'asm-mode-hook 'helm-gtags-mode)

  (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
  ;; (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
  (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
  (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
  (define-key helm-gtags-mode-map (kbd "C-c g h") 'helm-gtags-show-stack)
  (define-key helm-gtags-mode-map (kbd "C-c g p") 'helm-gtags-previous-history)
  (define-key helm-gtags-mode-map (kbd "C-c g n") 'helm-gtags-next-history)
#+END_SRC

Note： 快捷键绑定以 *C-c g* 打头

**** ggtags

#+BEGIN_SRC emacs-lisp
  (require 'ggtags)
  (add-hook 'c-mode-common-hook
            (lambda ()
              (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
                (ggtags-mode 1))))

  (define-key ggtags-mode-map (kbd "C-c g s") 'ggtags-find-other-symbol)
  (define-key ggtags-mode-map (kbd "C-c g h") 'ggtags-view-tag-history)
  (define-key ggtags-mode-map (kbd "C-c g r") 'ggtags-find-reference)
  (define-key ggtags-mode-map (kbd "C-c g f") 'ggtags-find-file)
  (define-key ggtags-mode-map (kbd "C-c g c") 'ggtags-create-tags)
  (define-key ggtags-mode-map (kbd "C-c g u") 'ggtags-update-tags)

  (define-key ggtags-mode-map (kbd "M-,") 'pop-tag-mark)
#+END_SRC

ggtags 没有 helm-gtags 好用，可能会破坏当前 buffer 窗口布局， /弃用/

**** helm-gtags-dwim M-. （跳转定义、引用、头文件）

M-. runs the command *helm-gtags-dwim*

It is bound to *M-.*.

(helm-gtags-dwim)

Find by context. Here is
- on include statement then jump to included file
- on symbol definition then jump to its references
- on reference point then jump to its definition.

**** helm-gtags-pop-stack M-, (跳回)
**** helm-gtags-select （浏览project中的所有标签）

设置绑定在 C-j 上，不好， C-j 应该是回车与换行

[[/home/ben/Wally/Journal/Figures/scrot/22666kXD.png]]

**** helm-gtags-tags-in-this-function 本函数中的所有标签
**** tag history

|-----------------------------+---------|
| helm-gtags-show-stack       | C-c g h |
| helm-gtags-previous-history | C-c g p |
| helm-gtags-next-history     | C-c g n |
|-----------------------------+---------|
*** sr-speedbar                                                  :speedbar:

1. shortcut
   |---------+-------------------------------------------------------------------------------------------------|
   |         | sr-speedbar-open OR  sr-speedbar-toggle                                                         |
   | SPC     | open the children of a node.                                                                    |
   | RET     | open the node in another window.                                                                |
   |         | If node is a file  open that file;                                                              |
   |         | if node is a directory ,  enter that directory;                                                 |
   |         | if node is a tag in a file ,  jump to the location of that tag in the file.                     |
   | U       | go up parent directory.                                                                         |
   | n/p     | moves to next or previous node.                                                                 |
   | M-n/M-p | moves to next or previous node at the current level.                                            |
   | b       | switches to buffer list using Speedbar presentation. You can also open children of each buffer. |
   | f       | switches back to file list.                                                                     |
   |---------+-------------------------------------------------------------------------------------------------|

2. Improvements compared to speedbar
   1) Automatically switches directory tree - when you switch buffer -
      to the default-directory of current buffer.
   2) Use an Emacs window instead of frame, make it easier to use.
   3) C-x 1 deletes every window except Speedbar, so you won't have to
      open again.
   4) You can prevent C-x o to jump to sr-speedbar window by setting
      sr-speedbar-skip-other-window-p to `t`. You can still move to
      sr-speedbar window using either the mouse or windmove.

3. 结论

   *ecb完全可以取代之，弃*

*** company-mode: [[http://company-mode.github.io/][general completion]] :company:

**** intro

Company stands for /complete anything/ and is a modular in-buffer
completion mechanism.

+ *Back-ends* are single functions.
+ A visualization (*front-end*) is also a single function.

/Company-mode/ 比 /Auto-complete/ 用着更习惯。

**** settings

#+BEGIN_SRC emacs-lisp
  (require 'company)
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

**** shortcut                                                   :shortcut:

|-----------+-----------------------|
| M-p/n     | move to previous/next |
| M-<digit> | move to n-th          |
| Return    | select                |
| TAB       |                       |
| *C-s/r*   | search                |
| *C-w*     | see the source        |
|-----------+-----------------------|

*** [[https://github.com/abo-abo/function-args][fucntion-args]]

1. intro

   function-args is a GNU Emacs package for /showing an inline
   arguments hint/ for the C/C++ function at point.

2. moo-jump-local: 本地标签跳转

   Select a tag to jump to from tags defined in current buffer.

   弹出 helm 窗口，能够跳转至 /函数定义/, /头文件引用/ 和 /宏/ 处。
   不支持变量的定义与引用跳转。

   *使用 ECB 能够完全取代*

3. fa-show M-i

   |-------+-------------------------------------|
   | M-i   | fa-show                             |
   | M-n/h | cycle overloaded functions          |
   | M-u   | dismiss the hint                    |
   | M-j   | fa-jump  (*when fa-show is active*) |
   |-------+-------------------------------------|

4. moo-complete M-o

   It's essentially a c++-specific version of
   semantic-ia-complete-symbol. It behaves better, because it accounts
   more for function overloading and inheritance. Also it's prettier
   (type parts are fontified) and faster (helm is used for
   completion). You can invoke it with M-o by default.

*** CEDET: [[http://cedet.sourceforge.net/][Collection of Emacs Development Tools]] :cedet:

**** why cedet?

1. Elisp写成，便于移植
2. /动态/ 相对gtags静态
3. disadvantages: slow,  but still fast
4. 内置于Emacs，安装配置简单


#+BEGIN_SRC cpp
  #include <boost/asio.hpp>
  #include <iostream>

  struct s{
    int ab;
    bool b;
  };

  int main(int argc, char *argv[])
  {
    s ss;
    return 0;
  }

#+END_SRC

*Note: 在 org source buffer 中无效*

**** cedet源码安装（ 内置的cedet足够用了 ）

***** 编译错误
#+BEGIN_EXAMPLE
  Wrong type argument: stringp, nil
  make: *** [autoloads] 错误 255
#+END_EXAMPLE

原因：可能因为版本问题，官网上测试的Ubuntu和Emacs版本都低于当前使用版
本

***** 解决

****** 放弃，使用Emacs内置的cedet

****** 使用git版

1) git clone http://git.code.sf.net/p/cedet/git cedet

2) place the checked out cedet directory in your ~/.emacs.d.

3) make

   #+BEGIN_EXAMPLE
     cd cedet
     make # wait for it to complete
     cd contrib
     make
   #+END_EXAMPLE

4) setting

   #+BEGIN_EXAMPLE
     (load-file (concat user-emacs-directory "/cedet/cedet-devel-load.el"))
     (load-file (concat user-emacs-directory "cedet/contrib/cedet-contrib-load.el"))
   #+END_EXAMPLE


****** 使用bzr版
1) bzr checkout

   bzr://cedet.bzr.sourceforge.net/bzrroot/cedet/code/trunk cedet

2) place the checked out cedet directory in your ~/.emacs.d.

3) make

   #+BEGIN_EXAMPLE
     cd cedet
     make # wait for it to complete
     cd contrib
     make
   #+END_EXAMPLE

4) setting

   #+BEGIN_EXAMPLE
     (load-file (concat user-emacs-directory "/cedet/cedet-devel-load.el"))
     (load-file (concat user-emacs-directory "cedet/contrib/cedet-contrib-load.el"))
   #+END_EXAMPLE

5) error:Cannot unload builtin CEDET since it is already loaded

   - 原因：可能在load-file之前已经有其它包启用了内置的cedet
   - 解决
     - (setq load-path (remove-if (lambda (x) (string-match-p "cedet" x)) load-path))
     - 将cedet-bzr配置提前

**** semantic(语义)                                             :semantic:

***** intro

Semantic is a package that provides language-aware editing commands
based on /source code parsers/. Parsing is a process of analyzing source
code based on programming language syntax. Emacs understands your
source code through this process to provides features such as
contextual /code completion/, /code navigation/.

***** setup

#+BEGIN_EXAMPLE
  (require 'cc-mode)
  (require 'semantic)

  (global-semanticdb-minor-mode 1)
  (global-semantic-idle-scheduler-mode 1)

  (semantic-mode 1)
#+END_EXAMPLE

***** command: semantic-mode

This command activates semantic-mode. In Semantic mode, Emacs parses
the buffers you visit for their semantic content.

Notice that at the bottom, Emacs prints messages like this:

#+begin_latex
\begin{minted}[frame=leftline, mathescape]{text}
Parsing stl_list.h (LL)...done
\end{minted}
#+end_latex

This is common behavior of Semantic:  when you perform a jump to a
symbol or perform a completion, Semantic tries to be accurate by
parsing all the included files and all the included files in the
included files and so on, until it reaches the end:

You may worry that this process takes a long time. Sometimes, it
does. However, this is just a one time process. Once it is parsed,
Semantic will cache the parsing result for future use. The next time
you perform some action on the parsed code, such as code completion,
you will get your desired output instantly.

***** Command: global-semanticdb-minor-mode

As mentioned above, Semantic caches parsing result for future use. To
do that, /semanticdb-minor-mode/ must be activated. In Semantic DB mode,
Semantic parsers store results in a database, which can be saved for
future Emacs sessions. The cache is saved in directory specified by
semanticdb-default-save-directory variable. The default directory is
*~/.emacs.d/semanticdb* .

***** Command: global-semantic-idle-scheduler-mode

When /semantic-idle-scheduler-mode/ is enabled, Emacs periodically
checks to see if the buffer is out of date, and reparses while the
user is idle (not typing). When this mode is off, a buffer is only
reparsed when user explicitly issue some command.

With semantic-idle-scheduler-mode, Emacs keeps track live changes of
your source code.

***** Add more system include paths

By default, Semantic automatically includes some default system
include paths such as /usr/include, /usr/local/include… You can view
the list of include paths in
*semantic-dependency-system-include-path*. To add more include paths,
for example Boost include paths, use the function
/semantic-add-system-include/ like this:

#+BEGIN_EXAMPLE
(semantic-add-system-include "/usr/include/boost" 'c++-mode)
(semantic-add-system-include "~/linux/kernel")
(semantic-add-system-include "~/linux/include")
#+END_EXAMPLE

***** shortcuts                                                :shortcut:

|   | semantic-ia-fast-jump |
|   | semantic-ia-complete-symbol  |

** C++IDE                                                              :cpp:

*** Emacs C++ IDE
**** 目标
1) 头文件与源文件之间跳转
2) 浏览Linux内核树
3) 交互式大纲显示文件结构
4) 以文件浏览器形式显示静态大纲树
5) 符号引用
6) 代码补全
7) 头文件补全
8) 在底部显示函数接口和变量定义
9) 跳转到当前函数头
10) 编译支持
11) 编译输出
12) GDB调试
13) 查看手册


**** function-args
|-----+--------------|
| M-o | moo-complete |
| M-i | fa-show      |
| M-J | fa-jump      |
|-----+--------------|
**** senator
Senator: SEmatic NavigaTOR.
|---------+--------------------------|
| C-c n   | senator-next-tag         |
| C-c p   | senator-previous-tag     |
| C-c u   | senator-go-up-reference  |
| C-c g   | semantic-symref          |
| C-c M-w | senator-copy-tag         |
| C-c C-w | senator-kill-tag         |
| C-c C-y | senator-yank-tag         |
| C-c r   | senator-copy-to-register |
|         | senator-fold-code-toggle |
|---------+--------------------------|
**** company-c-header
https://github.com/randomphrase/company-c-headers
1. install: MEPLE
2. setting:
   #+BEGIN_EXAMPLE
   (add-to-list 'company-backends 'company-c-headers)
   #+END_EXAMPLE
3. Note: If you want to complete C++ header files, you have to add its
   paths since by default company-c-headers only includes these two
   system include paths: /usr/include/ and /usr/local/include/. To
   enable C++ header completion for standard libraries, you have to
   add its path, for example, like this:
   #+BEGIN_EXAMPLE
   (add-to-list 'company-c-headers-path-system "/usr/include/c++/4.8/")
   #+END_EXAMPLE

**** 代码折叠
Emacs has a minor mode called hs-minor-mode that allows users to fold and
hide blocks of text. Blocks are defined by regular expressions which match
the start and end of a text region. For example, anything in between { and }
is a block. The regular expressions are defined in hs-special-modes-alist.

Setup for C/C++:

(add-hook 'c-mode-common-hook   'hs-minor-mode)

Default key bindings:
|-------------+--------------------------------------------|
| C-c @ C-c   | Command: hs-toggle-hiding                  |
|             | Toggle hiding/showing of a block           |
|-------------+--------------------------------------------|
| C-c @ C-h   | Command: hs-hide-block                     |
|             | Select current block at point and hide it  |
|-------------+--------------------------------------------|
| C-c @ C-l   | Command: hs-hide-level                     |
|             | Hide all block with indentation levels     |
|             | below this block                           |
|-------------+--------------------------------------------|
| C-c @ C-s   | Command: hs-show-block                     |
|             | Select current block at point and show it. |
|-------------+--------------------------------------------|
| C-c @ C-M-h | Command: hs-hide-all                       |
|             | Hide all top level blocks, displaying      |
|             | only first and last lines.                 |
| C-c @ C-M-s | Command: hs-show-all                       |
|             | Show everything                            |
|-------------+--------------------------------------------|
**** smartparens
smartparens is a minor mode that provides many features for manipulating
pairs. Pair can be simple as parentheses or brackets, or can be programming
tokens such as if … fi or if … end in many languages. The most basic and
essential feature is automatic closing of a pair when user inserts an
opening one.

#+BEGIN_EXAMPLE
  ;; Package: smartparens
  (require 'smartparens-config)
  (show-smartparens-global-mode +1)
  (smartparens-global-mode 1)

  ;; when you press RET, the curly braces automatically
  ;; add another newline
  (sp-with-modes '(c-mode c++-mode)
    (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "ret")))
    (sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC")
                                              ("* ||\n[i]" "RET"))))
#+END_EXAMPLE

For complete documentation, please refer to [[https://github.com/Fuco1/smartparens/wiki#information-for-new-users][Smartparens manual]].
**** narrowing
Narrowing means making only a text portion in current buffer visible.
Narrowing is useful when you want to perform text editing on a small part of
the buffer without affecting the others. For example, you want to delete all
printf statements in current functions, using flush-lines command. But if
you do so, you will also delete printf outside the current function, which
is undesirable. By narrowing, you can safely remove all those printf and be
certain that nothing else is changed accidentally.

Default key bindings:

|---------+--------------------------------------------|
| C-x n d | Command: narrow-to-defun                   |
| C-x n r | Command: narrow-to-region                  |
| C-x n n | Narrow buffer to active region             |
| C-x n w | Command: widen                             |
|---------+--------------------------------------------|
**** indentation
**** compile
Compilation mode turns each error message in the buffer into a hyperlink.
You can click on each error, or execute a key binding like RET to jump to
the location of that error.
|------+-------------------------------------------------------------------|
| C-o  | Display matched location, but do not switch point to matched      |
|      | buffer                                                            |
|------+-------------------------------------------------------------------|
| M-n  | Move to next error message, but do not visit error location       |
|------+-------------------------------------------------------------------|
| M-p  | Move to next previous message, but do not visit error location    |
|------+-------------------------------------------------------------------|
| M-g  | Move to next error message, visit error location                  |
| n    |                                                                   |
|------+-------------------------------------------------------------------|
| M-g  | Move to previous error message, visit error location              |
| p    |                                                                   |
|------+-------------------------------------------------------------------|
| RET  | Visit location of error at poiint                                 |
|------+-------------------------------------------------------------------|
| M-{  | Move point to the next error message or match occurring in a      |
|      | different file                                                    |
|------+-------------------------------------------------------------------|
| M-}  | Move point to the previous error message or match occurring in a  |
|      | different file                                                    |
|------+-------------------------------------------------------------------|
| q    | Quit *compilation* buffer                                         |
|------+-------------------------------------------------------------------|
**** TODO debug

*** gtags
+ C-c g a helm-gtags-tags-in-this-function
+ C-j helm-gtags-select
+ C-c g . helm-gtags-dwim
+ C-c g , helm-gtags-pop-stack
+ C-c g < helm-gtags-previous-history
+ C-c g > helm-gtags-next-history
+ C-c g f helm-gtags-find-files
+ C-c g s helm-gtags-find-symbol
+ C-c g r helm-gtags-find-reference
*** cedet


**** senator
Senator is a part of CEDET. Senator stands for SEmantic
NAvigaTOR. Senator provides some useful commands for operating on
semantic tags in SemanticDB.

+ C-c , n (注意逗号)

  runs senator-next-tag, navigate to the next Semantic tag.

+ C-c , p

  runs senator-previous-tag, navigate to the previous Semantic tag.

+ C-c , u

  runs senator-go-to-up-reference, move up one reference level from
  current tag. An upper reference level of a tag is the source that
  defines the tag or includes the tag. This is incredibly useful when
  you want to jump from a function declaration in a class to its
  definition, or jump to the class that a function belongs to,
  quickly.

+ C-c , M-w

  runs senator-copy-tag, take the current tag, and place it in the tag
  ring.

+ C-c , C-w

  runs senator-kill-tag, take the current tag, place it in the tag
  ring, and kill it. Killing the tag removes the text for that tag,
  and places it into the kill ring. Retrieve that text with C-y.

+ C-c , C-y

  runs senator-yank-tag, yank a tag from the tag ring. The form the
  tag takes is different depending on where it is being yanked to. For
  example, in previous example with C-c , C-w, when you run C-y, it
  yanks the whole thing including function interface and its body. C-c
  , C-y only yanks the function interface.

**** ede


**** Command: global-semantic-idle-summary-mode

This mode, when enabled, displays function interface in the minibuffer:

It works well for C but not C++, since C++ can overload function and
semantic-idle-summary-mode can only display one interface at a
time. Since this mode is part of Semantic, it also relies on
SemanticDB that is created from parsing source files.

Setup:
#+BEGIN_EXAMPLE
(global-semantic-idle-summary-mode 1)
#+END_EXAMPLE

**** Command: global-semantic-stickyfunc-mode

When enable, this mode shows the function point is currently in at the
first line of the current buffer. This is useful when you have a very
long function that spreads more than a screen, and you don't have to
scroll up to read the function name and then scroll down to original
position.

Setup:
#+BEGIN_EXAMPLE
(add-to-list 'semantic-default-submodes 'global-semantic-stickyfunc-mode)
#+END_EXAMPLE

One of the problem with current semantic-stickyfunc-mode is that it
does not display all parameters that are scattered on multiple
lines. This package handles that problem:
semantic-stickyfunc-enhance. Extra: stock semantic-stickyfunc-mode
does not include assigned values to function parameters of
Python. This package also fixed that problem. You can click the link
to see demos.

You can install the package via MELPA and load it: https://github.com/tuhdo/semantic-stickyfunc-enhance
#+BEGIN_EXAMPLE
(require 'stickyfunc-enhance)
#+END_EXAMPLE

**** Emacs ede
+ http://www.gnu.org/software/emacs/manual/html_node/ede/index.html#Top
+


*** company-c-header
company-c-headers provides auto-completion for C/C++ headers using
Company. After installing from MELPA, set it up:

#+BEGIN_EXAMPLE
(add-to-list 'company-backends 'company-c-headers)
#+END_EXAMPLE

IMPORTANT: If you want to complete C++ header files, you have to add
its paths since by default company-c-headers only includes these two
system include paths: /usr/include/ and /usr/local/include/. To enable
C++ header completion for standard libraries, you have to add its
path, for example, like this:

#+BEGIN_EXAMPLE
(add-to-list 'company-c-headers-path-system "/usr/include/c++/4.8/")
#+END_EXAMPLE

After that, you can complete C++ header files. To complete project
local, use company-c-headers-path-user and put it in .dir-locals.el.

*** cedet qt
+ http://sourceforge.net/p/cedet/mailman/message/28257793/
+ http://www.emacswiki.org/emacs/SemanticLibraryParsing
+ http://alexott.blogspot.com/2009/02/cedet-qt.html
+ http://www.emacswiki.org/emacs/QtMode

*** QT Assistant
http://qt-project.org/doc/qt-4.8-snapshot/assistant-manual.html
https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0CB4QFjAA&url=http%3A%2F%2Fblog.morpheuz.cc%2F01%2F07%2F2008%2Fqt-assistant-emacs%2F&ei=XKwLVb-hHpDtoASky4GQCQ&usg=AFQjCNEiIgBsGpZWAMByiSqhyJ_4HOu1fA&sig2=9BHnXLzV3e3dZt3tWiALng

1. 思路1：从Emacs中启动Qt Assistant
   + call-process-shell-command

   #+BEGIN_EXAMPLE
   (defun assistant ()
   "runs qt assistant"
   (interactive)
   (call-process-shell-command "assistant" nil "assistant")
   )
   (global-set-key [f11] 'assistant)
   #+END_EXAMPLE

2. 思路2： 传递 (current-word) 给 assistant 的参数

** PythonIDE                                                        :python:
*** pyflakes                                                     :pyflakes:
+ https://pypi.python.org/pypi/pyflakes
+ https://github.com/pyflakes/pyflakes/


a simple program which checks python source files for errors.

pyflakes analyzes programs and detects various errors. it works by
parsing the source file, not importing it, so it is safe to use on
modules with side effects. it's also much faster.

install: pip install --upgrade pyflakes

*** pymacs
+ https://github.com/pinard/Pymacs
+ http://www.emacswiki.org/emacs/PyMacs


Pymacs is a powerful tool which, once started from Emacs, allows
both-way communication between Emacs Lisp and Python. Pymacs aims
Python as an extension language for Emacs rather than the other way
around, and this asymmetry is reflected in some design choices. Within
Emacs Lisp code, one may load and use Python modules. Python functions
may themselves use Emacs services, and handle Emacs Lisp objects kept
in Emacs Lisp space.

*** emacs-for-python
+ https://github.com/gabrielelanaro/emacs-for-python
+ http://gabrielelanaro.github.io/emacs-for-python/
+

*** elpy
+ https://github.com/jorgenschaefer/elpy
+ http://elpy.readthedocs.org/en/latest/introduction.html


1. indentation blocks
   + C-down (elpy-nav-next-iblock)
   + C-up (elpy-nav-previous-iblock)
   + C-left (elpy-nav-backward-iblock)
   + C-right (elpy-nav-forward-iblock)

   + M-down (elpy-nav-move-iblock-down)
   + M-up (elpy-nav-move-iblock-up)
   + M-left (elpy-nav-move-iblock-left)
   + M-right (elpy-nav-move-iblock-right)

2. project
   1) C-c C-f (elpy-find-file)

   2) C-c C-s (elpy-rgrep-symbol)
      Search the files in the current project for a string

   3) M-x elpy-set-project-root

3. completion
   M-TAB (elpy-company-backend) C-M-i

4. navigation
   + M-. (elpy-goto-definition)
   + M-* (pop-tag-mark)

5. interactive python
   + C-c C-z (elpy-shell-switch-to-shell)
   + C-c C-c (elpy-shell-send-region-or-buffer)
   + C-M-x (python-shell-send-defun)

6. syntax checking
   + C-c C-n (elpy-flymake-next-error)
   + C-c C-p (elpy-flymake-previous-error)
   + C-c C-v (elpy-check)

7. documentation
   + C-c C-d (elpy-doc)

8. refactoring
   + C-c C-e (elpy-multiedit-python-symbol-at-point)
   + C-c C-r (elpy-refactor)

*** Python
#+BEGIN_SRC latex
参考：
\begin{itemize}
\item \href{http://www.emacswiki.org/emacs/PythonProgrammingInEmacs}{EmacsWiki:Python programming in Emacs}
\item \href{http://www.emacswiki.org/emacs/ProgrammingWithPythonModeDotEl}{EmacsWiki:python-mode}
\item \href{http://blog.csdn.net/max__payne/article/details/6365324}{CSDN blog}
\item \href{https://launchpad.net/python-mode}{python-mode项目主页}
\end{itemize}

\begin{enumerate}
\item Python programming in Emacs

  Emacs中进行Python编程主要有两种主模式：Emacs默认的python-mode，和第三方插件python-mode.el。两者都能为Python编程提供诸多便捷，工欲善其事，必先利其器，择一熟练使用则好，过分纠结使用哪一个反而舍本逐末。

\item Python-mode安装配置\footnote{TODO:Python-mode的更多特性}
\begin{verbatim}
(add-to-list 'load-path "/PATH/TO/PYTHON-MODE")
(setq py-install-directory "/PATH/TO/PYTHON-MODE")
(require 'python-mode)
;;窗口布局
(setq py-split-window-on-execute t)
(setq py-switch-buffers-on-execute-p t)
\end{verbatim}


\item Python-mode按键绑定

  更多详见Emacs帮助文档，甚至这样更方便。

  \begin{tabular}{l|l}
    \hline
    C-c C-c & py-execute-buffer \\
    C-c | & py-execute-region \\
    C-c TAB & py-indent-region \\
    C-c ! & py-shell \\
    C-c C-v & py-version \\
    C-c C-k & py-mark-block-or-clause \\
    C-c C-e & py-help-at-point \\
    \hline
    C-M-a & py-begining-of-def-or-class\\
    C-M-d & py-down \\
    C-M-e & py-end-of-def-or-class \\
    C-M-h & py-mark-def-or-class \\
    C-M-i & completion-at-point \\
    C-M-u & py-up \\
    C-M-x & py-execute-def-or-class \\
    \hline
  \end{tabular}
\end{enumerate}

#+END_SRC

* Emacs拾遗
