* ROS                                                                   :ROS:
** README

1. ROS的参考资料仅保存链接
   - 保存为ORG笔记麻烦，使用Pandoc徒增烦恼
   - 网页随时会更新
   - org TAG + LINK 组合搜索、打开链接足够好用
   - 使用标题保存链接，标题下可以记使用手记

2. 使用 org-link 纪录阅读的源码

3. 不要专门地去学习教程，而是遇到问题查阅
** TODOs
*** rviz 俯视 二维
*** gazebo视角跟踪
*** move_base 点击导航， 避障 amcl
*** 写三种生成对照路径和地图的程序，用ROS map的接口
+ encoder
+ gyo
+ encoder+gyo ekf

*** rosrun tf view_frames
*** rviz可视化gyo trajectory
*** map base on imu and encoder

** API
*** [[file:/opt/ros/indigo/include/ros/init.h::ROSCPP_DECL%20void%20spinOnce()%3B][spinOnce]]
*** [[file:/opt/ros/indigo/include/rosconsole/macros_generated.h::#define%20ROS_INFO(...)%20ROS_LOG(::ros::console::levels::Info,%20ROSCONSOLE_DEFAULT_NAME,%20__VA_ARGS__)][ROS_INFO]]

** Fundermental
*** CMD
**** [[http://wiki.ros.org/rosbag][rosbag]]                                                       :rosbag:

***** Command Line Usage

The [[/rosbag][rosbag]] command-line tool provides functionality for ROS
[[/Bags][bags]].

It can record a bag, republish the messages from one or more bags,
summarize the contents of a bag, check a bag's message definitions,
filter a bag's messages based on a Python expression, compress and
decompress a bag and rebuild a bag's index.

This is the current list of supported commands:

- [[/rosbag/Commandline#record][record]]: Record a bag file with the contents of specified topics.

- [[/rosbag/Commandline#info][info]]: Summarize the contents of a bag file.

- [[/rosbag/Commandline#play][play]]: Play back the contents of one or more bag files.

- [[/rosbag/Commandline#check][check]]: Determine whether a bag is playable in the current system, or
  if it can be migrated.

- [[/rosbag/Commandline#fix][fix]]: Repair the messages in a bag file so that it can be played in the current system.
- [[/rosbag/Commandline#filter][filter]]: Convert a bag file using Python expressions.

- [[/rosbag/Commandline#compress][compress]]: Compress one or more bag files.

- [[/rosbag/Commandline#decompress][decompress]]: Decompress one or more bag files.

- [[/rosbag/Commandline#reindex][reindex]]: Reindex one or more broken bag files.

These are described in greater detail in the following sections.

****** rosbag record

=rosbag record= subscribes to topics and writes a bag file with the
contents of all messages published on those topics. The file contains
interlaced, serialized ROS messages dumped directly to a single file as
they come in over the wire. This is the most performance and
disk-friendly recording format possible.

If you are recording messages at a high bandwidth, such as from cameras,
it is strongly recommended you run =rosbag record= on the same machine
as the camera, and specify the file destination as being on the local
machine disk.

-  =record <topic-names>=

   -  Record a bag file with the contents of the specified topics.

      #+BEGIN_EXAMPLE
          $ rosbag record rosout tf cmd_vel
      #+END_EXAMPLE

   =-h=, =--help=

   -  Show the usage and exit.

      #+BEGIN_EXAMPLE
          $ rosbag record -h
      #+END_EXAMPLE

   =-a=, =--all=

   -  Record all topics.

      #+BEGIN_EXAMPLE
          $ rosbag record -a
      #+END_EXAMPLE

      Note that newly published topics are discovered by periodically
      polling the master. =rosbag record -a= will likely miss initial
      messages published on any topic.

   =-e=, =--regex=

   -  Match topics using regular expressions.

      #+BEGIN_EXAMPLE
          $ rosbag record -e "/(.*)_stereo/(left|right)/image_rect_color"
      #+END_EXAMPLE

   =-x EXCLUDE_REGEX=, =--exclude=EXCLUDE=REGEX=

   -  Exclude topics matching the given regular expression (subtracts
      from =-a= or =-e=).

      #+BEGIN_EXAMPLE
          $ rosbag record -e "/wide_stereo(.*)" -x "(.*)/points(.*)"
      #+END_EXAMPLE

   =-q=, =--quiet=

   -  Suppress console output.

      #+BEGIN_EXAMPLE
          $ rosbag record -q /chatter
      #+END_EXAMPLE

   =-o PREFIX=, =--output-prefix=PREFIX=

   -  Prepend PREFIX to beginning of bag name before date stamp.

      #+BEGIN_EXAMPLE
          $ rosbag record -o session1 /chatter
      #+END_EXAMPLE

   =-O NAME=, =--output-name=NAME=

   -  Record to bag with name NAME.bag.

      #+BEGIN_EXAMPLE
          $ rosbag record -O session2_090210.bag /chatter
      #+END_EXAMPLE

   =--split=

   -  Split the bag when maximum size or duration is reached

      #+BEGIN_EXAMPLE
          $ rosbag record --split --size=1024 /chatter
          $ rosbag record --split --duration=30 /chatter
          $ rosbag record --split --duration=5m /chatter
          $ rosbag record --split --duration=2h /chatter
      #+END_EXAMPLE

   =-b SIZE=, =--buffsize=SIZE=

   -  Use an internal buffer of SIZE MB (Default: 256, 0 = infinite).

      #+BEGIN_EXAMPLE
          $ rosbag record -b 1024 /chatter
      #+END_EXAMPLE

   =--chunksize=SIZE=

   -  Advanced. Record to chunks of SIZE KB (Default: 768)

      #+BEGIN_EXAMPLE
          $ rosbag record --chunksize=1024 /chatter
      #+END_EXAMPLE

   =-l NUM=, =--limit=NUM=

   -  Only record NUM messages on each topic.

      #+BEGIN_EXAMPLE
          $ rosbag record -l 1000 /chatter
      #+END_EXAMPLE

   =-j=, =--bz2=

   -  Use BZ2 compression.

      #+BEGIN_EXAMPLE
          $ rosbag record -j /chatter
      #+END_EXAMPLE

****** rosbag info

=rosbag info= displays a human-readable summary of the contents of the
bag files, including start and end times, topics with their types,
message counts and median frequency, and compression statistics.

To output a machine-readable representation, use =--yaml=. See the
[[/rosbag/Cookbook#get_summary_information][cookbook]] for an example of
how to load this representation in code.

-  =info <bag-files>=

   -  Display a summary of the contents of the bag files.

      #+BEGIN_EXAMPLE
          $ rosbag info session*.bag
      #+END_EXAMPLE

   =-h=, =--help=

   -  Show the usage and exit.

      #+BEGIN_EXAMPLE
          $ rosbag info -h
      #+END_EXAMPLE

   =-y=, =--yaml=

   -  Print information in [[http://www.yaml.org][YAML]] format.

      #+BEGIN_EXAMPLE
          $ rosbag info -y /path/to/my.bag
      #+END_EXAMPLE

   =-k KEY=, =--key=KEY=

   -  Print information only on the given field (requires =-y=).

      #+BEGIN_EXAMPLE
          $ rosbag info -y -k duration /path/to/my.bag
      #+END_EXAMPLE

/Example usage:/

#+BEGIN_EXAMPLE
    $ rosbag info foo.bag
    path:        foo.bag
    version:     2.0
    duration:    1.2s
    start:       Jun 17 2010 14:24:58.83 (1276809898.83)
    end:         Jun 17 2010 14:25:00.01 (1276809900.01)
    size:        14.2 KB
    messages:    119
    compression: none [1/1 chunks]
    types:       geometry_msgs/Point [4a842b65f413084dc2b10fb484ea7f17]
    topics:      /points   119 msgs @ 100.0 Hz : geometry_msgs/Point
#+END_EXAMPLE

****** rosbag play

=rosbag play= reads the contents of one or more bag file, and plays them
back in a time-synchronized fashion. Time synchronization occurs based
on the global timestamps at which messages were received. Playing will
begin immediately, and then future messages will be published according
to the relative offset times. If two separate bag files are used, they
are treated as a single bag with interlaced times according to the
timestamps. This means if you record one bag, wait an hour, and record a
second bag, when you play them back together you will have an hour-long
dead period in the middle of your playback.

If you do not want to observe playback timing, the =-i= option will
playback all messages from the file as fast as possible. Note that for
large files this will often lead to exceeding your incoming buffers.

Additionally, during playing, you can pause at any time by pressing
space. When paused, you can step through messages by pressing =s=.

-  =play <bag-files>=

   -  Play back (publish) the contents of the given bags.

      #+BEGIN_EXAMPLE
          $ rosbag play recorded1.bag recorded2.bag
      #+END_EXAMPLE

   =-h=, =--help=

   -  Show the usage and exit.

      #+BEGIN_EXAMPLE
          $ rosbag play -h
      #+END_EXAMPLE

   =-q=, =--quiet=

   -  Suppress console output.

      #+BEGIN_EXAMPLE
          $ rosbag play -q recorded1.bag
      #+END_EXAMPLE

   =-i=, =--immediate=

   -  Play back all messages without waiting.

      #+BEGIN_EXAMPLE
          $ rosbag play -i recorded1.bag
      #+END_EXAMPLE

   =--pause=

   -  Start in paused mode.

      #+BEGIN_EXAMPLE
          $ rosbag play --pause recorded1.bag
      #+END_EXAMPLE

   =--queue=SIZE=

   -  Use an outgoing queue of size SIZE (defaults to 0. As of *1.3.3*
      defaults to 100).

      #+BEGIN_EXAMPLE
          $ rosbag play --queue=1000 recorded1.bag
      #+END_EXAMPLE

   =--clock=

   -  Publish the clock time

      #+BEGIN_EXAMPLE
          $ rosbag play --clock recorded1.bag
      #+END_EXAMPLE

   =--hz=HZ=

   -  Publish clock time at frequency HZ Hz (default: 100).

      #+BEGIN_EXAMPLE
          $ rosbag play --clock --hz=200 recorded1.bag
      #+END_EXAMPLE

   =-d SEC=, =--delay=SEC=

   -  Sleep SEC seconds after every advertise call (to allow subscribers
      to connect).

      #+BEGIN_EXAMPLE
          $ rosbag play -d 5 recorded1.bag
      #+END_EXAMPLE

   =-r FACTOR=, =--rate=FACTOR=

   -  Multiply the publish rate by FACTOR.

      #+BEGIN_EXAMPLE
          $ rosbag play -r 10 recorded1.bag
      #+END_EXAMPLE

   =-s SEC=, =--start=SEC=

   -  Start SEC seconds into the bags.

      #+BEGIN_EXAMPLE
          $ rosbag play -s 5 recorded1.bag
      #+END_EXAMPLE

   =-u SEC=, =--duration=SEC=

   -  Play only SEC seconds from the bag files.

      #+BEGIN_EXAMPLE
          $ rosbag play -u 240 recorded1.bag
      #+END_EXAMPLE

   =-l=, =--loop=

   -  Loop playback.

      #+BEGIN_EXAMPLE
          $ rosbag play -l recorded1.bag
      #+END_EXAMPLE

   =-k=, =--keep-alive=

   -  Keep alive past end of bag (useful for publishing latched topics).

      #+BEGIN_EXAMPLE
          $ rosbag play -k recorded1.bag
      #+END_EXAMPLE

****** rosbag check

-  =check <bag-file>=

   -  Determine whether or not a bag is playable in the current system.

      #+BEGIN_EXAMPLE
          $ rosbag check old.bag
      #+END_EXAMPLE

   =-h=, =--help=

   -  Show the usage and exit.

      #+BEGIN_EXAMPLE
          $ rosbag check -h
      #+END_EXAMPLE

   =-g RULEFILE=, =--genrules=RULEFILE=

   -  Generate a bag migration rule file named RULEFILE.

      #+BEGIN_EXAMPLE
          $ rosbag check -g diagnostics.bmr diag.bag
      #+END_EXAMPLE

   =-a=, =--append=

   -  Append to the end of an existing bag migration rule file after
      loading.

      #+BEGIN_EXAMPLE
          $ rosbag check -a -g all.bmr diag.bag
      #+END_EXAMPLE

   =-n=, =--noplugins=

   -  Do not load rule files via plugins.

      #+BEGIN_EXAMPLE
          $ rosbag check -n diag.bag
      #+END_EXAMPLE

If a bag is currently unplayable and non-migratable, it may be necessary
to generate rules to bring the bag up to date. See
[[/rosbag/migration][Migrating Messages]] for the preferred approaches
to doing this.

****** rosbag fix

-  =fix <in-bag> <out-bag> [rules.bmr]=

   -  Repairs a bag using registered rules (and optionally locally
      defined rules).

      #+BEGIN_EXAMPLE
          $ rosbag fix old.bag repaired.bag myrules.bmr
      #+END_EXAMPLE

   =-h=, =--help=

   -  Show the usage and exit.

      #+BEGIN_EXAMPLE
          $ rosbag fix -h
      #+END_EXAMPLE

   =-n=, =--noplugins=

   -  Do not load rule files via plugins.

      #+BEGIN_EXAMPLE
          $ rosbag fix -n old.bag repaired.bag
      #+END_EXAMPLE

****** rosbag filter

-  =filter <in-bag> <out-bag> <expression>=

   -  Convert a bag file using the given Python expression.

      #+BEGIN_EXAMPLE
          $ rosbag filter my.bag only-tf.bag "topic == '/tf'"
      #+END_EXAMPLE

The Python expression can access any of the Python builtins plus:

-  =topic=

   -  the topic of the message

   =m=

   -  the message

   =t=

   -  time of message. The time is represented as a [[/rospy][rospy]]
      [[http://pr.willowgarage.com/pr-docs/ros-packages/rospy/html/classrospy_1_1msg_1_1Time.html][Time]]
      object (=t.secs=, =t.nsecs=)

   =-h=, =--help=

   -  Show the usage and exit.

      #+BEGIN_EXAMPLE
          $ rosbag filter -h
      #+END_EXAMPLE

   =--print=PRINT-EXPRESSION=

   -  Evaluate and print a Python expression for verbose debugging. Uses
      same variables as filter expression.

      #+BEGIN_EXAMPLE
          $ rosbag filter --print="'%s @ %d.%d: %s' % (topic, t.secs, t.nsecs, m.data)" big.bag small.bag "topic == '/chatter'"
      #+END_EXAMPLE

/Example output:/

#+BEGIN_EXAMPLE
    NO MATCH hello world 68
    NO MATCH hello world 69
    NO MATCH hello world 70
    MATCH hello world 71
    NO MATCH hello world 72
    NO MATCH hello world 73
#+END_EXAMPLE

To filter based on time, convert the time to a floating point number
(use UNIX time, to get this value, use rosbag info):

#+BEGIN_EXAMPLE
    rosbag filter input.bag output.bag "t.to_sec() <= 1284703931.86"
#+END_EXAMPLE

****** rosbag compress

=rosbag compress= is a command-line tool for compressing bag files.

A backup of each bag file (with the extension =.orig.bag=) is made
before the bag is compressed. If the backup file already exists (and the
=-f= option isn't specified) then the tool will not compress the file.

Currently, the only compression format supported is
[[http://www.bzip.org][BZ2]].

The bag format supports interleaving compressed data chunks with
uncompressed chunks a single bag. Running =rosbag compress= on a bag
with compressed data chunks will decompress and compress the bag.

-  =compress <bag-files>=

   -  Compress the given bag files.

      #+BEGIN_EXAMPLE
          $ rosbag compress *.bag
      #+END_EXAMPLE

   =-h=, =--help=

   -  Show the usage and exit.

      #+BEGIN_EXAMPLE
          $ rosbag compress -h
      #+END_EXAMPLE

   =--output-dir=DIR=

   -  Write to directory DIR.

      #+BEGIN_EXAMPLE
          $ rosbag compress --output-dir=compressed *.bag
      #+END_EXAMPLE

   =-f=, =--force=

   -  Force overwriting of backup file it it exists.

      #+BEGIN_EXAMPLE
          $ rosbag compress -f *.bag
      #+END_EXAMPLE

   =-q=, =--quiet=

   -  Suppress noncritical messages.

      #+BEGIN_EXAMPLE
          $ rosbag compress -q *.bag
      #+END_EXAMPLE

****** rosbag decompress

=rosbag decompress= is a command-line tool for decompressing bag files.

A backup of each bag file (with the extension =.orig.bag=) is made
before the bag is decompressed. If the backup file already exists (and
the =-f= option isn't specified) then the tool will not decompress the
file.

-  =decompress <bag-files>=

   -  Decompress the given bag files.

      #+BEGIN_EXAMPLE
          $ rosbag decompress *.bag
      #+END_EXAMPLE

   =-h=, =--help=

   -  Show the usage and exit.

      #+BEGIN_EXAMPLE
          $ rosbag decompress -h
      #+END_EXAMPLE

   =--output-dir=DIR=

   -  Write to directory DIR.

      #+BEGIN_EXAMPLE
          $ rosbag decompress --output-dir=uncompressed *.bag
      #+END_EXAMPLE

   =-f=, =--force=

   -  Force overwriting of backup file it it exists.

      #+BEGIN_EXAMPLE
          $ rosbag decompress -f *.bag
      #+END_EXAMPLE

   =-q=, =--quiet=

   -  Suppress noncritical messages.

      #+BEGIN_EXAMPLE
          $ rosbag decompress -q *.bag
      #+END_EXAMPLE

****** rosbag reindex

=rosbag reindex= is a command-line tool for repairing broken bag files
(or bag files recorded prior to ROS version 0.11.) If a bag was not
closed cleanly for any reason, then the index information may be
corrupted. Use this tool to reread the message data and rebuild the
index.

A backup of each bag file (with the extension =.orig.bag=) is made
before the bag is reindexed. If the backup file already exists (and the
=-f= option isn't specified) then the tool will not reindex the file.

-  =reindex <bag-files>=

   -  Reindex the given bag files.

      #+BEGIN_EXAMPLE
          $ rosbag reindex *.bag
      #+END_EXAMPLE

   =-h=, =--help=

   -  Show the usage and exit.

      #+BEGIN_EXAMPLE
          $ rosbag reindex -h
      #+END_EXAMPLE

   =--output-dir=DIR=

   -  Write to directory DIR.

      #+BEGIN_EXAMPLE
          $ rosbag reindex --output-dir=reindexed *.bag
      #+END_EXAMPLE

   =-f=, =--force=

   -  Force overwriting of backup file it it exists.

      #+BEGIN_EXAMPLE
          $ rosbag reindex -f *.bag
      #+END_EXAMPLE

   =-q=, =--quiet=

   -  Suppress noncritical messages.

      #+BEGIN_EXAMPLE
          $ rosbag reindex -q *.bag
      #+END_EXAMPLE



***** [[http://wiki.ros.org/rosbag/Tutorials][Tutorials]]      :tutorial:
****** [[http://wiki.ros.org/rosbag/Tutorials/Exporting%20image%20and%20video%20data][How to export image and video data from a bag file]]
****** [[http://wiki.ros.org/rosbag/Tutorials/Producing%20filtered%20bag%20files][Producing filtered bag files]]
****** [[http://wiki.ros.org/rosbag/Tutorials/Recording%20and%20playing%20back%20data][Recording and playing back data]]
**** [[http://wiki.ros.org/rosmsg][rosmsg]]                                                       :rosmsg:
**** [[http://wiki.ros.org/roscpp][roscpp]]                                                   :cpp:roscpp:
***** [[http://wiki.ros.org/CppStyleGuide][CppStyleGuide]]
**** [[http://wiki.ros.org/roslaunch][roslaunch]]                                          :roslaunch:launch:
***** [[http://wiki.ros.org/roslaunch/Commandline%20Tools][Command Line Usage]] :cmd:
****** syntax
1. roslaunch <package> <launchfile>

2. roslaunch <launchfile>  # in the package folder

3. roslaunch - # launch the roslaunch XML passed as standard input

****** launch options

1. *-p* <PORT>

2. *--wait*

   Delay until a roscore is detected

3. *--local*

   Launch of the local nodes only

4. *--screen*

   Force all node output to screen

5. *-v*

   Enable verbose printing

6. *--dump-params*

   Print paremeters in launch file in YAML format
   #+BEGIN_EXAMPLE
     ~ $ roslaunch julie_gazebo --dump-params empty_world.launch
     {/use_sim_time: true}
   #+END_EXAMPLE

****** non-launch options

用来查看 launch 文件信息，而不执行任何操作。

+ *--nodes <pkg> <launch>*

  List names of nodes in the launch file

  #+BEGIN_EXAMPLE
    ~ $ roslaunch --nodes julie_gazebo empty_world.launch
    /gazebo
    /gazebo_gui
  #+END_EXAMPLE

+ *--args <node> <pkg> <launch>*

  Display the command-line arguments

  #+BEGIN_EXAMPLE
    ~ $ roslaunch --args gazebo julie_gazebo empty_world.launch
    /opt/ros/indigo/lib/gazebo_ros/gzserver -e ode
    /home/ben/Wally/Journal/catkin_ws/src/julie/julie_gazebo/worlds/empty.world
    __name:=gazebo
  #+END_EXAMPLE

+ *--ros-args*

  #+BEGIN_EXAMPLE
    ~ $ roslaunch --ros-args julie_gazebo empty_world.launch
    Required Arguments:
      command_arg1: undocumented
      command_arg2: undocumented
      command_arg3: undocumented
      extra_gazebo_args: undocumented
    Optional Arguments:
      debug (default "false"): undocumented
      gui (default "true"): undocumented
      headless (default "false"): undocumented
      paused (default "false"): undocumented
      physics (default "ode"): undocumented
      use_sim_time (default "true"): undocumented
      verbose (default "false"): undocumented
      world_name (default "/home/ben/Wally/Journal/catkin_ws/src/julie/julie_gazebo/worlds/empty.world"): undocumented
  #+END_EXAMPLE

+ *--find <node> <launch>*

  print name of launch file that the node is defined in. due to
  including file

+ *--files <filename>*

  printed all filed included

  #+BEGIN_EXAMPLE
    ~ $ roslaunch --files julie_gazebo empty_world.launch
    /home/ben/Wally/Journal/catkin_ws/src/julie/julie_gazebo/launch/empty_world.launch
  #+END_EXAMPLE

***** [[http://wiki.ros.org/roslaunch/XML][XML format]]             :xml:
****** substitution args

1. $(env ENV)

2. $(optenv ENVE)

3. $(find PKG)

4. $(anon NAME): generate an anonymous id base on NAME

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
     <node name="$(anon foo)" pkg="rospy_tutorials" type="talker.py" />
     <node name="$(anon foo)" pkg="rospy_tutorials" type="talker.py" />
     \end{minted}
   #+end_latex

5. $(arg foo)

   $(arg foo) *evaluates* to the value specified by an <arg>
   tag. There must be a corresponding <arg> tag in the same launch
   file that declares the arg.

****** if & unless                                           :if:unless:

All tags support if and unless attributes, which include or exclude a
tag based on the evaluation of a value. "1" and "true" are considered
true values. "0" and "false" are considered false values. Other values
will error.

*搞明白逻辑*

1. if=value (optional)

   If value evaluates to true, include tag and its contents.
   *如果条件为真，那么就包含标签*

2. unless=value (optional)

   Unless value evaluates to false, include tag and its contents.
   *除非条件为假，否则包含标签*

#+BEGIN_SRC xml
  <group if="$(arg foo)">
    <!-- stuff that will only be evaluated if foo is true -->
  </group>

  <param name="foo" value="bar" unless="$(arg foo)" />
  <!-- This param won't be set when "unless" condition is met -->
#+END_SRC

****** [[http://wiki.ros.org/roslaunch/XML/launch][<launch>]]   :launch:
****** [[http://wiki.ros.org/roslaunch/XML/node][<node>]]         :node:


****** <node> tag


The =<node>= tag specifies a ROS [[/Nodes][node]] that you wish to have
launched. This is the most common =roslaunch= tag as it supports the
most important features: bringing up and taking down nodes.

=roslaunch= does not provide any guarantees about what order nodes start
in. This is intentional: there is no way to externally know when a node
is fully initialized, so all code that is launched must be robust to
launching in any order.

The [[/roslaunch/Tutorials][roslaunch tutorials page]] covers some
examples of how to fully utilize the =<node>= tag, such as
[[/roslaunch/Tutorials/Roslaunch%20Nodes%20in%20Valgrind%20or%20GDB][configuring
a node to launch in gdb]].

******* Examples

#+BEGIN_EXAMPLE
    <node name="listener1" pkg="rospy_tutorials" type="listener.py" args="--test" respawn="true" />
#+END_EXAMPLE

Launches the ="listener1"= [[/Nodes][node]] using the =listener.py=
executable from the =rospy_tutorials= [[/Packages][package]] with the
command-line argument =--test=. If the node dies, it will automatically
be respawned.

#+BEGIN_EXAMPLE
    <node name="bar1" pkg="foo_pkg" type="bar" args="$(find baz_pkg)/resources/map.pgm" />
#+END_EXAMPLE

Launches the bar node from the =foo_pkg= package. This example uses
substitution arguments to pass in a portable reference to
=baz_pkg/resources/map.pgm=.

******* Attributes

-  =pkg="mypackage"=

   -  Package of node.

   =type="nodetype"=

   -  Node type. There must be a corresponding executable with the same
      name.

   =name="nodename"=

   -  Node name. NOTE: name cannot contain a namespace. Use the =ns=
      attribute instead.

   =args="arg1 arg2 arg3"=/(optional)/

   -  Pass arguments to node.

   =machine="machine-name"=/(optional, see
   [[/roslaunch/XML/machine][<machine>]])/

   -  Launch node on designated machine.

   =respawn="true"=/(optional)/

   -  Restart the node automatically if it quits.

   =respawn_delay="30"= /(optional, default 0)/ New in ROS indigo

   -  If =respawn= is =true=, wait =respawn_delay= seconds after the
      node failure is detected before attempting restart.

   =required="true"=/(optional)/

   -  *ROS 0.10*: If node dies, kill entire roslaunch.

   =ns="foo"=/(optional)/

   -  Start the node in the 'foo' namespace.

   =clear_params="true|false"=/(optional)/

   -  Delete all parameters in the node's private namespace before
      launch.

   =output="log|screen"=/(optional)/

   -  If 'screen', stdout/stderr from the node will be sent to the
      screen. If 'log', the stdout/stderr output will be sent to a log
      file in $ROS_HOME/log, and stderr will continue to be sent to
      screen. The default is 'log'.

   =cwd="ROS_HOME|node"=/(optional)/

   -  If 'node', the working directory of the node will be set to the
      same directory as the node's executable. In C Turtle, the default
      is 'ROS_HOME'. In Box Turtle (ROS 1.0.x), the default is
      'ros-root'. The use of 'ros-root' is deprecated in C Turtle.

   =launch-prefix="prefix arguments"=/(optional)/

   -  Command/arguments to prepend to node's launch arguments. This is a
      powerful feature that enables you to enable =gdb=, =valgrind=,
      =xterm=, =nice=, or other handy tools. See
      [[/roslaunch/Tutorials/Roslaunch%20Nodes%20in%20Valgrind%20or%20GDB][Roslaunch
      Nodes in Valgrind or GDB]] for examples.

******* Elements

You can use the following XML tags inside of a =<node>= tag:

-  [[/roslaunch/XML/env][<env>]]

   -  Set an environment variable for the node.

   [[/roslaunch/XML/remap][<remap>]]

   -  Set a remapping argument for this node.

   [[/roslaunch/XML/rosparam][<rosparam>]]

   -  Load a [[/rosparam][rosparam]] file into this node's =~=/local
      namespace.

   [[/roslaunch/XML/param][<param>]]

   -  Set a [[/Parameters][parameter]] in the node's =~=/local
      namespace.

****** [[http://wiki.ros.org/roslaunch/XML/machine][<machine>]] :machine:
****** [[http://wiki.ros.org/roslaunch/XML/include][<include>]] :include:
******* attributes

- file="$(find pkg)/path/to/launch"
- ns="foo"
- clear_paramter="true|false": dangerous

******* elenments

- <env> : set an environment variable
- <arg> : pass an argument to in the inclue file

****** [[http://wiki.ros.org/roslaunch/XML/remap][<remap>]]      :remap:
****** [[http://wiki.ros.org/roslaunch/XML/env][<env>]]            :env:
****** [[http://wiki.ros.org/roslaunch/XML/param][<param>]]      :param:

The <param> tag *defines a parameter* to be set on the Parameter
Server.

Instead of value, you can specify a *textfile*, *binfile* or *command
attribute* to set the value of a parameter.

The <param> tag can be put inside of a <node> tag, in which case the
parameter is treated like a *private parameter*.

You can also set private parameter across a group of nodes by using
the *~param syntax* (see ROS names) in a <param> tag. The declared
parameter will be set as a local parameter in the <node> tags that
follow that are in the same scope (i.e. group or ns tag).

******* attribute

+ name="ns/name"

+ value="value"

+ type="str|int|double|bool"

+ textfile="$(find pkg)/path/to/file.txt"

  the contents of the file will be read and stored as a string.

+ binfile="$(find pkg)/path/file"

+ command="$(find pkg)/exe"

  The output of the command will be read and stored as a string.

****** [[http://wiki.ros.org/roslaunch/XML/rosparam][<rosparam>]] :rosparam:
****** [[http://wiki.ros.org/roslaunch/XML/group][<group>]]      :group:

The <group> tag makes it easier to apply settings to /a group of
nodes/. It has an ns attribute that lets you push the group of nodes
into /a separate namespace/.

******* attributes

- ns="namespace" (optional)

  Assign the group of nodes to the specified namespace. The namespace
  can be global or relative, though global namespaces are discouraged.

- clear_params="true|false" (optional)

  Delete all parameters in the group's namespace before launch. This
  feature is very dangerous and should be used with caution. ns must
  be specified.

******* elements

The <group> tag is _equivalent to the top-level <launch> tag_ and
simply acts as a /container/ for the tags within. This means that you
can use any tag as you would normally use it within a <launch> tag.

- <node>  Launch a node.
- <param>  Set a parameter on the Parameter Server
- <remap>  Declare a name remapping.
- <machine>  Declare a machine to use for launching.
- <rosparam>  Set ROS parameters for the launch using a rosparam file.
- <include>  Include other roslaunch files.
- <env>  Specify an environment variable for launched nodes.
- <test>  Launch a test node (see rostest).
- <arg>  Declare an argument.

****** [[http://wiki.ros.org/roslaunch/XML/test][<test>]]         :test:
****** [[http://wiki.ros.org/roslaunch/XML/arg][<arg>]]            :arg:
******* attributes

+ name="name"
+ default="default_value"
+ value+"value"
+ doc ="decription for this arg"

***** tutorials                                                :tutorial:
****** [[http://wiki.ros.org/roslaunch/Tutorials/Roslaunch%20Nodes%20in%20Valgrind%20or%20GDB][Roslaunch nodes in GDB]] :gdb:
******* node attribute

Command/arguments to prepend to node's launch arguments. This is a
powerful feature that enables you to enable *gdb*, valgrind, xterm,
nice, or other handy tools.

******* values
The launch-prefix attribute of the <node> tag that, among other things, makes it easy to debug a ROS node process. Here are some example launch-prefixes you might find useful:

+ launch-prefix="xterm -e gdb --args"

  run your node in a gdb in a separate xterm window, manually type run
  to start it

+ launch-prefix="gdb -ex run --args"

  run your node in gdb in the same xterm as your launch without having
  to type run to start it

+ launch-prefix="valgrind"

  run your node in valgrind

+ launch-prefix="xterm -e"

  run your node in a separate xterm window

+ launch-prefix="nice"

  nice your process to lower its CPU usage

+ launch-prefix="screen -d -m gdb --args"

  useful if the node is being run on another machine; you can then ssh
  to that machine and do screen -D -R to see the gdb session

+ launch-prefix="xterm -e python -m pdb"

  run your python node a separate xterm window in pdb for debugging;
  manually type run to start it

+ launch-prefix="/path/to/run_tmux

  run your node in a new tmux window; you'll need to create
  /path/to/run_tmux with the contents:

******* example
1. xterm -e

   [[/home/ben/Wally/Journal/Figures/scrot/701mEV.png]]

2.

****** [[http://wiki.ros.org/roslaunch/Tutorials/Roslaunch%20tips%20for%20larger%20projects][roslaunch tips for large projects]]

***** Launch undocumented 如何注释

arg的 doc属性，其它的元素不需要注释
**** [[http://wiki.ros.org/roswtf?distro=jade][roswtf]]

**** [[http://wiki.ros.org/rospack][rospack]]                                                     :rospack:

**** [[http://wiki.ros.org/rosclean][rosclean]]:  clean filesystem resource(e.g. log files)       :rosclean:

#+BEGIN_EXAMPLE
WARNING: disk usage in log directory [/home/ben/.ros/log] is over 1GB.
It's recommended that you use the 'rosclean' command.

Wally $ rosclean
usage: rosclean [-h] {check,purge} ...
rosclean: error: too few arguments
Wally $ rosclean -h
usage: rosclean [-h] {check,purge} ...

positional arguments:
  {check,purge}
    check        Check usage of log files
    purge        Remove log files

optional arguments:
  -h, --help     show this help message and exit
Wally $ rosclean check
1.7G ROS node logs
Wally $ rosclean purge
Purging ROS node logs.
PLEASE BE CAREFUL TO VERIFY THE COMMAND BELOW!
Okay to execute:

rm -rf /home/ben/.ros/log
(y/n)?
y
Wally $

#+END_EXAMPLE

****
**** rosmsg
**** rospack
**** rosstack
**** ROSTOPIC

*** Reps

**** [[http://www.ros.org/reps/rep-0105.html][Coordinate Frames for Mobile Platform]]

*** Concepts
**** [[http://wiki.ros.org/Manifest][Manifest]]
**** [[http://wiki.ros.org/Packages][Packages]]
**** [[http://wiki.ros.org/msg][msg]]
**** [[http://wiki.ros.org/srv][srv]]
**** [[http://wiki.ros.org/Metapackages][Metapackage]]
Metapackages are specialized packages in ROS (and catkin).
+ They do not install files other than their packages.xml
+ They do not contain any tests, code, files, or other items usually
  found in packages

*A metapackage simply references one or more related packages which
are loosely grouped together.*

#+BEGIN_SRC latex
  \begin{XML}
    <package>
    <name>hector_gazebo</name>
    <version>0.3.6</version>
    <description>hector_gazebo provides packages related to to simulation of robots using gazebo (gazebo plugins, world files etc.)</description>
    <maintainer email="meyer@fsr.tu-darmstadt.de">Johannes Meyer</maintainer>

    <license>BSD</license>

    <url type="website">http://ros.org/wiki/hector_gazebo</url>
    <!-- <url type="bugtracker"></url> -->

    <author email="kohlbrecher@sim.tu-darmstadt.de">Stefan Kohlbrecher</author>
    <author email="meyer@fsr.tu-darmstadt.de">Johannes Meyer</author>

    <!-- Dependencies which this package needs to build itself. -->
    <buildtool_depend>catkin</buildtool_depend>

    <!-- Dependencies needed after this package is compiled. -->
    <run_depend>hector_gazebo_thermal_camera</run_depend>
    <run_depend>hector_gazebo_worlds</run_depend>
    <run_depend>hector_gazebo_plugins</run_depend>

    <export>
    <metapackage/>
    </export>

    </package>

  \end{XML}
#+END_SRC
**** [[http://wiki.ros.org/ROS/Concepts][ros graph concept]]

***** overview

ROS has three levels of concepts: the Filesystem level, the
Computation Graph level, and the Community level. These levels and
concepts are summarized below and later sections go into each of these
in greater detail.

***** ros filesystem level
The filesystem level concepts mainly cover ROS resources that you
encounter on disk, such as:

+ *Packages*

  Packages are the main unit for organizing software in ROS. A package
  may contain ROS runtime processes (nodes), a ROS-dependent library,
  datasets, configuration files, or anything else that is usefully
  organized together. Packages are the most atomic build item and
  release item in ROS. Meaning that the most granular thing you can
  build and release is a package.

+ *Metapackages*

  Metapackages are specialized Packages which only serve to represent
  a group of related other packages. Most commonly metapackages are
  used as a backwards compatible place holder for converted rosbuild
  Stacks.

+ *Package*

  anifests: Manifests (package.xml) provide metadata about a package,
  including its name, version, description, license information,
  dependencies, and other meta information like exported packages. The
  package.xml package manifest is defined in REP-0127.

+ *Repositories*

  A collection of packages which share a common VCS system. Packages
  which share a VCS share the same version and can be released
  together using the catkin release automation tool bloom. Often these
  repositories will map to converted rosbuild Stacks. Repositories can
  also contain only one package.

+ *Message(msg) types*

  Message descriptions, stored in  my_package/msg/MyMessageType.msg,
  define the data structures for messages sent in ROS.

+ *Service(srv) types*

  Service descriptions, stored in my_package/srv/MyServiceType.srv,
  define the request and response data structures for services in ROS.

***** ROS Computation Graph Level

The Computation Graph is the peer-to-peer network of ROS processes
that are processing data together. The basic Computation Graph
concepts of ROS are nodes, Master, Parameter Server, messages,
services, topics, and bags, all of which provide data to the Graph in
different ways.

These concepts are implemented in the ros_comm repository.

+ *Nodes*

  Nodes are processes that perform computation. ROS is designed to be
  modular at a fine-grained scale; a robot control system usually
  comprises many nodes. For example, one node controls a laser
  range-finder, one node controls the wheel motors, one node performs
  localization, one node performs path planning, one Node provides a
  graphical view of the system, and so on. A ROS node is written with
  the use of a ROS client library, such as roscpp or rospy.

+ *Master*

  The ROS Master provides name registration and lookup to the rest of
  the Computation Graph. Without the Master, nodes would not be able
  to find each other, exchange messages, or invoke services.

+ *Parameter*

  erver: The Parameter Server allows data to be stored by key in a
  central location. It is currently part of the Master.

+ *Messages*

  Nodes communicate with each other by passing messages. A message is
  simply a data structure, comprising typed fields. Standard primitive
  types (integer, floating point, boolean, etc.) are supported, as are
  arrays of primitive types. Messages can include arbitrarily nested
  structures and arrays (much like C structs).

+ *Topics*

  Messages are routed via a transport system with publish / subscribe
  semantics. A node sends out a message by publishing it to a given
  topic. The topic is a name that is used to identify the content of
  the message. A node that is interested in a certain kind of data
  will subscribe to the appropriate topic. There may be multiple
  concurrent publishers and subscribers for a single topic, and a
  single node may publish and/or subscribe to multiple topics. In
  general, publishers and subscribers are not aware of each others'
  existence. The idea is to decouple the production of information
  from its consumption. Logically, one can think of a topic as a
  strongly typed message bus. Each bus has a name, and anyone can
  connect to the bus to send or receive messages as long as they are
  the right type.

+ *Services*

  The publish / subscribe model is a very flexible communication
  paradigm, but its many-to-many, one-way transport is not appropriate
  for request / reply interactions, which are often required in a
  distributed system. Request / reply is done via services, which are
  defined by a pair of message structures: one for the request and one
  for the reply. A providing node offers a service under a name and a
  client uses the service by sending the request message and awaiting
  the reply. ROS client libraries generally present this interaction
  to the programmer as if it were a remote procedure call.

+ *Bags*

  Bags are a format for saving and playing back ROS message data. Bags
  are an important mechanism for storing data, such as sensor data,
  that can be difficult to collect but is necessary for developing and
  testing algorithms.

***** ROS Community Level
The ROS Community Level concepts are ROS resources that enable
separate communities to exchange software and knowledge. These
resources include:

+ *Distributions*

  ROS Distributions are collections of versioned stacks that you can
  install. Distributions play a similar role to Linux distributions:
  they make it easier to install a collection of software, and they
  also maintain consistent versions across a set of software.

+ *Repositories*

  ROS relies on a federated network of code repositories, where
  different institutions can develop and release their own robot
  software components.

+ *The ROS Wiki*

  The ROS community Wiki is the main forum for documenting information
  about ROS. Anyone can sign up for an account and contribute their
  own documentation, provide corrections or updates, write tutorials,
  and more.

+ *Bug Ticket System*

  Please see Tickets for information about file tickets.

+ *Mailing Lists*

  The ros-users mailing list is the primary communication channel
  about new updates to ROS, as well as a forum to ask questions about
  ROS software.

+ *ROS Answers*

  A Q&A site for answering your ROS-related questions.

+ *Blog*

  The ros.org Blog provides regular updates, including photos and
  videos.

**** [[http://wiki.ros.org/Remapping%20Arguments][Remapping Arguments]]

***** overview

Any ROS name within a node can be remapped when it is launched at the
command-line. This is a powerful feature of ROS that lets you launch
the same node under multiple configurations from the command-line. All
resource names can be remapped. You can also provide assignment for
private node parameters. This feature of ROS allows you to defer
complex name assignments to the actual runtime loading of the system.

Remapping arguments can be passed to any node and use the syntax
*name:=new_name*. For example, to configure the talker node to publish
to /wg/chatter instead of chatter:

#+BEGIN_EXAMPLE
rosrun rospy_tutorials talker chatter:=/wg/chatter
#+END_EXAMPLE

We resolve the arguments before doing the match. The effect of this is
that you are remapping a full name, whereas before the remappings only
applied to a specific string. For example, where foo:=bar previously
only matched the exact string foo, it will also match
/<node_namespace>/foo. After resolution, a direct string match is
used, so you cannot use it to remap parts of Names, i.e. foo:=bar will
match foo or /<node_namespace>/foo, but will not match foo/baz. The
one exception to this is when using searchParam, which keeps the old
behavior. This is because searchParam itself works on unresolved
names.

|----------------+--------------------+----------------+---------------------|
| Node Namespace | Remapping Argument | Matching Names | Final Resolved Name |
|----------------+--------------------+----------------+---------------------|
| /              | foo:=bar           | foo, /foo      | /bar                |
| /baz           | foo:=bar           | foo, /baz/foo  | /baz/bar            |
| /              | /foo:=bar          | foo, /foo      | /bar                |
| /baz           | /foo:=bar          | /foo           | /baz/bar            |
| /baz           | /foo:=/a/b/c/bar   | /foo           | /a/b/c/bar          |
|----------------+--------------------+----------------+---------------------|

***** Node parameter assignment

You can assign private parameters for a node directly from the
command-line using a single underscore _ as a prefix. For example,
#+BEGIN_EXAMPLE
rosrun rospy_tutorials talker _param:=1.0
#+END_EXAMPLE

sets ~param to 1.0. ROS uses YAML syntax to determine the parameter
typing.

***** Special keys

+ *__name*

  __name is a special reserved keyword for "the name of the node." It
  lets you remap the node name without having to know its actual
  name. It can only be used if the program that is being launched
  contains one node.

+ *__log*

  __log is a reserved keyword that designates the location that the
  node's log file should be written. Use of this keyword is generally
  not encouraged -- it is mainly provided for use by ROS tools like
  roslaunch.

+ *__ip and __hostname*

  __ip and __hostname are substitutes for ROS_IP and ROS_HOSTNAME. Use
  of this keyword is generally not encouraged as it is provided for
  special cases where environment variables cannot be set.

+ *__master*

  __master is a substitute for ROS_MASTER_URI. Use of this keyword is
  generally not encouraged as it is provided for special cases where
  environment variables cannot be set.

+ *__ns*

  __ns is a substitute for ROS_NAMESPACE. Use of this keyword is
  generally not encouraged as it is provided for special cases where
  environment variables cannot be set.

**** [[http://wiki.ros.org/Names][Names]]

***** Graph Resource Names

Graph Resource Names provide a hierarchical naming structure that is
used for all resources in a ROS Computation Graph, such as Nodes,
Parameters, Topics, and Services. These names are very powerful in ROS
and central to how larger and more complicated systems are composed in
ROS, so it is critical to understand how these names work and how you
can manipulate them.

Graph Resource Names are an important mechanism in ROS for providing
encapsulation. Each resource is defined within a namespace, which it
may share with many other resources. In general, resources can create
resources within their namespace and they can access resources within
or above their own namespace. Connections can be made between
resources in distinct namespaces, but this is generally done by
integration code above both namespaces. This encapsulation isolates
different portions of the system from accidentally grabbing the wrong
named resource or globally hijacking names.

Names are resolved relatively, so resources do not need to be aware of
which namespace they are in. This simplifies programming as nodes that
work together can be written as if they are all in the top-level
namespace. When these Nodes are integrated into a larger system, they
can be pushed down into a namespace that defines their collection of
code. For example, one could take a Stanford demo and a Willow Garage
demo and merge them into a new demo with stanford and wg subgraphs. If
both demos had a Node named 'camera', they would not conflict. Tools
(e.g. graph visualization) as well as parameters (e.g. demo_name) that
need to be visible to the entire graph can be created by top-level
Nodes.

****** Valid Names
A valid name has the following characteristics:

+ *First character is an alpha character ([a-z|A-Z]), tilde (~) or
  forward slash (/)*

+ *Subsequent characters can be alphanumeric ([0-9|a-z|A-Z]),
  underscores (_), or forward slashes (/)*

+ *Exception: base names (described below) cannot have forward slashes
  (/) or tildes (~) in them.*

****** Resolving
There are four types of Graph Resource Names in ROS: *base*,
*relative*, *global*, and *private*, which have the following syntax:

+ base
+ relative/name
+ /global/name
+ ~private/name

Names with no namespace qualifiers whatsoever are base names. Base
names are actually a subclass of relative names and have the same
resolution rules. Base names are most frequently used to initialize
the node name.

Names that start with a "/" are global -- they are considered fully
resolved. Global names should be avoided as much as possible as they
limit code portability.

Names that start with a "~" are private. They convert the node's name
into a namespace. For example, node1 in namespace/wg/ has the private
namespace /wg/node1. Private names are useful for passing parameters
to a specific node via the parameter server.

|-----------+------------------------+----------------------+-------------------------------|
| Node      | Relative (default)     | Global               | Private                       |
|-----------+------------------------+----------------------+-------------------------------|
| /node1    | bar -> /bar            | /bar -> /bar         | ~bar -> /node1/bar            |
| /wg/node2 | bar -> /wg/bar         | /bar -> /bar         | ~bar -> /wg/node2/bar         |
| /wg/node3 | foo/bar -> /wg/foo/bar | /foo/bar -> /foo/bar | ~foo/bar -> /wg/node3/foo/bar |
|-----------+------------------------+----------------------+-------------------------------|

***** Package Resource Names

*Package Resource Names are used in ROS with Filesystem-Level
concepts* to simplify the process of referring to files and data types
on disk. Package Resource Names are very simple: they are just the
name of the Package that the resource is in plus the name of the
resource. For example, the name "std_msgs/String" refers to the
"String" message type in the "std_msgs" Package.

Package Resource Names are very similar to file paths, except they are
much shorter. This is due to the ability of ROS to locate Packages on
disk and make additional assumptions about their contents. For
example, Message descriptions are always stored in the msg
subdirectory and have the .msg extension, so std_msgs/String is
shorthand for path/to/std_msgs/msg/String.msg. Similarly, the Node
type foo/bar is equivalent to searching for a file named bar in
Package foo with executable permissions.

****** Valid Names
Package Resource Names have strict naming rules as they are often used
in auto-generated code. For this reason, a ROS package cannot have
special characters other than an underscore, and they must start with
an alphabetical character. A valid name has the following
characteristics:

+ First character is an alpha character ([a-z|A-Z])

+ Subsequent characters can be alphanumeric ([0-9|a-z|A-Z]),
  underscores (_) or a forward slash (/)

+ There is at most one forward slash ('/').

**** frame_id                                                   :frame_id:

1. [[http://answers.ros.org/question/34684/header-frame_id/][header frame_id]]
   The /frame_id/ in a message specifies the point of reference for
   data contained in that message.

2. [[http://answers.ros.org/question/42632/how-to-know-the-frame-id/][get frame_id]]

   In general, the frame_id in the header of any topic (if it has a
   header) can be found by /rostopic echo/

   #+BEGIN_EXAMPLE
     $ rostopic echo -n 1 /lidar_scan  | grep frame_id
     frame_id: hokuyo_link
     $ rostopic echo -n 1 /scan_filtered  | grep frame_id
     frame_id: hokuyo_link
   #+END_EXAMPLE

3. [[http://answers.ros.org/question/198590/start-map_server-with-custom-frame_id/][customize frame_id]]

   /ros param/

   1) command line

      #+BEGIN_EXAMPLE
      rosrun map_server map_server testenvironment.yaml _frame_id:="odometry_link"
      #+END_EXAMPLE

   2) launch

      #+BEGIN_SRC xml
        <node name="map_server" pkg="map_server" type="map_server" args="testenvironment.yaml">
        <param name="frame_id" value="odometry_link" />
        </node>
      #+END_SRC

**** [[http://wiki.ros.org/Clock][clock]]                          :clock:
***** Introduction

Normally, the ROS [[/Client%20Libraries][client libraries]] will use
your computer's system clock as a time source, also known as the
"wall-clock" or "wall-time" (like the clock on the wall of your lab).
When you are running a simulation or playing back logged data, however,
it is often desirable to instead have the system use a simulated clock
so that you can have accelerated, slowed, or stepped control over your
system's perceived time. For example, if you are playing back sensor
data into your system, you may wish to have your time correspond to the
timestamps of the sensor data.

To support this, the ROS [[/Client%20Libraries][client libraries]] can
listen to the =/clock= topic that is used to publish "simulation time".

In order for your code to take advantage of the ROS simulation time, it
is important that all code use the appropriate ROS
[[/Client%20Libraries][client library]] Time API for accessing time and
sleeping instead of using the language-native routines. This will allow
your system to have a consistent time measurement whether it is using
the wall-clock or a simulated clock. These APIs are described briefly
below, though you should familiarize yourself with your client library
of choice for more details.

When using wall-clock time on multiple machines, it is important that
you synchronize time between them. ROS does not provide this
functionality as there are already well-established methods (e.g.
[[http://www.ntp.org/][ntp]], our recommended syncronization tool is
[[http://chrony.tuxfamily.org/][chrony]]) for doing this. If you do not
synchronize the wall-clocks of multiple machines, they will not agree on
temporal calculations like those used in [[/tf][tf]].

*NOTE: this is not an API for real-time systems!*

***** Using Simulation Time from the /clock Topic

In order for a ROS node to use simulation time according to the =/clock=
topic, the =/use_sim_time= parameter must be set to =true= /before the
node is initialized/. This can be done in a
[[/roslaunch/XML/param][launchfile]] or from the
[[/rosparam#rosparam_set][command line]].

If the =/use_sim_time= parameter is set, the ROS Time API will return
time==0= until it has received a value from the =/clock= topic. Then,
the time will only be updated on receipt of a message from the /clock
topic, and will stay constant between updates.

For calculations of time durations when using simulation time, clients
should always wait until the first non-zero time value has been received
before starting, because the first simulation time value from =/clock=
topic may be a high value.

Note: Prior to [[/cturtle][ROS C Turtle]], nodes were automatically
subscribed to the =/clock= topic, and would use simulation time if there
was anything published to the =/clock= topic.

***** Running a Clock Server

A Clock Server is any node that publishes to the =/clock= topic, and
there should never be more than one running in a single ROS network. In
most cases, the Clock Server is either a simulator or a log playback
tool.

In order to resolve any issues with startup order, it is important that
the =/use_sim_time= Parameter is set to true in any launch files using a
Clock Server. If you are playing back a bag file with =rosbag play=,
using the =--clock= option will run a Clock Server while the bag file is
being played.

****** Clock Message

[[http://docs.ros.org/api/roslib/html/msg/Clock.html][roslib/Clock]] (Up
to [[/cturtle][C Turtle]])

[[http://docs.ros.org/api/rosgraph_msgs/html/msg/Clock.html][rosgraph_msgs/Clock]]
([[/diamondback][Diamondback]] and later):

#+BEGIN_EXAMPLE
    time clock
#+END_EXAMPLE

***** Client Libraries

Here are some simple examples of the ROS Time API use in three of the
main client libraries.

Note: For more documentation, please consult the "Code API" of the
relevant ROS Client Library Package listed below.

** Tools
*** [[http://wiki.ros.org/catkin][Catkin]]                                                         :catkin:
**** overview

**** [[http://wiki.ros.org/catkin/CMakeLists.txt][CMakeLists.txt]] :cmakelists:

***** Overall Structure and Ordering

Your CMakeLists.txt file *MUST* follow this format otherwise your
packages will not build correctly. The order in the configuration
*DOES* count.

1) Required CMake Version

   (*cmake_minimum_required*)

2) Package Name

   (*project()*)

3) Find other CMake/Catkin packages needed for build

   (*find_package()*)

4) Message/Service/Action Generators

   (*add_message_files(), add_service_files(), add_action_files()*)

5) Invoke message/service/action generation

   (*generate_messages()*)

6) Specify package build info export

   (*catkin_package()*)

7) Libraries/Executables to build

   (*add_library()/add_executable()/target_link_libraries()*)

8) Tests to build

   (*catkin_add_gtest()*)

9) Install rules

   (*install()*)

***** CMake Vertion

Every catkin CMakeLists.txt file *must start with* the required vesion
of CMake needed.(2.8.3 or higher)

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{cmake}
  cmake_minimum_required(VERSION 2.8.3)
  \end{minted}
#+end_latex

***** Package name

#+begin_latex
\begin{minted}[frame=leftline, mathescape]{cmake}
project(robot_brain)
\end{minted}
#+end_latex

使用 *${PROJECT_NAME}* 引用。

***** Finding Dependent CMake Packages

1. catkin is required

   #+begin_latex
   \begin{minted}[frame=leftline, mathescape]{cmake}
   find_package(catkin REQUIRED)
   \end{minted}
   #+end_latex

2. Instead of using find_package on those packages, if you specify
   them as *components*, it will make life easier.

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{cmake}
     find_package{catkin REQUIRED COMPONENTS nodelet}

     find_package{catkin REQUIRED}
     find_package{nodelet REQUIRED}  # OK, but not optical
     \end{minted}
   #+end_latex

3. creating for CMake environment *<PACKAGE-NAME>_<PROPERTY>*

   + *<NAME>_FOUND*

     Set to true if the library is found, otherwise fall

   + *<NAME>_INCLUDE_DIRS or <NAME>_INCLUDES*

     The include paths exported by the package

   + *<NAME>_LIBRARIES or <NAME>_LIBS*

     The libraries exported by the package

   + *<NAME>_DEFINITIONS*

     ?

***** catkin_package()

*catkin_package()* is a catkin-provided CMake *macro*. This is
required to specify catkin-specific information to the build system
which in turn is used to generate pkg-config and CMake files.

This function *must* be called before declaring any targets with
add_library() or add_executable().

The function has 5 optional arguments:

1) *INCLUDE_DIRS*

   The exported include paths (i.e. cflags) for the package

2) *LIBRARIES*

   The exported libraries from the project

3) *CATKIN_DEPENDS*

   Other catkin projects that this project depends on

4) *DEPENDS*

   Non-catkin CMake projects that this project depends on

5) *CFG_EXTRAS*

   Additional configuration options

***** TODO build targets / message/service/action / installation

**** error                                                         :error:
***** ImportError: No module named 'catkin_pkg'

#+BEGIN_EXAMPLE
$ catkin_create_pkg pcltk pcl_convention pcl_ros roscpp sensor_msgs
ImportError: No module named 'catkin_pkg'
#+END_EXAMPLE

原因： 更新了 Python 的版本
解决： 将 /usr/bin/python 软链指向 python2.7 (即安装 ros 时的版本)

http://answers.ros.org/question/204024/no-module-named-catkin_pkgpackage-on-catkin_make-w-hydro/

*** Debug                                                           :debug:
**** reference

+ [[http://answers.ros.org/question/155581/cmake-debug-option/][ROS anwser: cmake debug option]]
+ [[http://answers.ros.org/question/34966/debugging-ros-package-with-qtcreator/][ROS anwser: debugging ROS package with Qtcreator]]
+ [[http://wiki.ros.org/roslaunch/Tutorials/Roslaunch%20Nodes%20in%20Valgrind%20or%20GDB][roslaunch nodes in gdb]]
+ [[http://answers.ros.org/question/200155/how-to-debug-executable-built-with-catkin_make-without-roslaunch/][How to debug executable,  built with catkin_make]]

**** about

ROS 的多节点意味着 *多任务（多进程）* ， 而 gdb 调试的对象是单任务，任
务进程中可以包含多个线程。

GDB 没有对多进程程序调试提供直接支持。


**** [[http://wiki.ros.org/IDEs][IDEs]]                                                            :ide:

***** IDE 选择

+*Emacs 不二之选*+

***** General

On ROS Answers there is a thread about
[[http://answers.ros.org/question/9068/which-ides-do-ros-developers-use][Which IDE(s) do ROS developers use?]] that might have further hints not yet
entered here.

****** Reusing your shell's environment

For building and running ROS programs from inside IDEs, the ROS
enviroment has to be set up. All IDEs might have a config for that, but
*running your IDE from your ROS-sourced shell* should be the easiest
way, avoiding inconsistency.

Likewise, you can enhance your IDE's launcher icon to load your shells
environment. E.g., replace its command /=eclipse=/ with
/=bash-i-c"eclipse"=/. This will make bash source =~/.bashrc=, in
which ROS has to be sourced and parameterized, and start that IDE . For
convenience, you can also launch it by default like this by changing the
/=Exec==/ line in your /=eclipse.desktop=/ launcher (which you need to
create manually if you install Eclipse from the Eclipse website
directly).

***** Eclipse                                                   :eclipse:

Eclipse's built in C++ indexing capabilities have gotten quite good in
recent versions.

****** Installing Eclipse

To use this tutorial, users should not "sudo apt-get install eclipse".
Instead:

-  Go to [[http://www.eclipse.org][eclipse web site]]
-  Click on "download now" from the top-right corner
-  Download eclipse for C/C++ developers
-  Extract eclipse into a folder of your choice
-  To make a nice launcher for Ubuntu, google for instructions or check
   e.g.
   [[http://www.blogs.digitalworlds.net/softwarenotes/?p=54][http://www.blogs.digitalworlds.net/softwarenotes/?p=54]]

****** Creating the Eclipse project files

******* For a rosbuild package

CMake can produce Eclipse project files automatically. These project
files then set up all include paths correctly, so that auto completion
and code browsing will work out of the box.

However, currently, a small hack is required for generating these
project files in the right folder. The problem is that ROS creates the
Makefiles and all other build artifacts in the *build/* folder, but
Eclipse expects the source files to be located within (or below) the
folder where its project files are stored.

Fortunately, there is now a make target using a small script that
circumvents this problem, by forcing CMake to create the project files
in the directory of your package (and not the *build/* folder). Proceed
as follows:

Open a terminal, *roscd* into the folder of your package, and execute:

#+BEGIN_EXAMPLE
    make eclipse-project
#+END_EXAMPLE

You will now find two Eclipse files in your package. It is not
recommended to add them to the repository, as they contain absolute
links and will be different for different users checking out your
software.

Note that if you change anything to your *manifest.xml*, you will have
to run this script again, which will overwrite your Eclipse project file
and thereby reverting all manual changes to the project settings.

*Note*: Simply running the cmake Eclipse generator like

#+BEGIN_EXAMPLE
    cmake -G"Eclipse CDT4 - Unix Makefiles"
#+END_EXAMPLE

will overwrite the Makefile. This can also happen if
=makeeclipse-project= does not complete successfully. If you already
did this, you will want to restore the original Makefile, which should
contain the following line:

#+BEGIN_EXAMPLE
    include $(shell rospack find mk)/cmake.mk
#+END_EXAMPLE

******** Creating eclipse files for multiple packages/stacks

Go to the directory where your packages reside (which may be a
stack-folder or just a simple folder) and run:

#+BEGIN_EXAMPLE
    rosmake --target=eclipse-project --specified-only *
#+END_EXAMPLE

If you need to convert deeper nested packages or multiple stacks at once
be encouraged to use this [[https://gist.github.com/1098960][eclipse
projects bash script for subdirectories]].

******* Catkin-y approach

If you are using catkin, you do not have the possibility to use
=makeeclipse-project=. You need to execute:

#+BEGIN_EXAMPLE
    catkin_make --force-cmake -G"Eclipse CDT4 - Unix Makefiles"
#+END_EXAMPLE

to generate the =.project= file and then run:

#+BEGIN_EXAMPLE
    awk -f $(rospack find mk)/eclipse.awk build/.project > build/.project_with_env && mv build/.project_with_env build/.project
#+END_EXAMPLE

to pass the current shell environment into the make process in Eclipse.

After executing this command you will find the project files in the
*build/* folder. Now you can import your project as existing project
into workspace.

Maybe you will need to execute the following if you would like to debug
your program. To execute this command cd to the *build/* folder. You
should do so if you e.g. get an error like "No source available for
main()".

#+BEGIN_EXAMPLE
    cmake ../src -DCMAKE_BUILD_TYPE=Debug
#+END_EXAMPLE

For information on the proper approach using catkin, start
[[http://answers.ros.org/question/52013/catkin-and-eclipse/][here]]

******** Catkin and Python

For me, the above procedure didn't generate a =.pydevproject= file, like
=makeeclipse-project= ever did. Clicking /Set as PyDev Project/ would
create a config but without any Paths, so coding would be a hassle.

/*Workaround*:/ From within the package you want to program run:

#+BEGIN_EXAMPLE
    python $(rospack find mk)/make_pydev_project.py
#+END_EXAMPLE

Now copy the created file =.pydevproject= (which has all dependency
package paths included) to =<catkin_ws>/build= and import your
catkin-project into eclipse or /Set it as PyDev Project/ if already
imported.

******* catkin tools

With the new
[[http://catkin-tools.readthedocs.org/en/latest/index.html][catkin\_tools]],
there are few changed from the Catkin-y method described above. To
generate eclipse-project you need to execute:

#+BEGIN_EXAMPLE
    catkin build  --force-cmake -G"Eclipse CDT4 - Unix Makefiles"
#+END_EXAMPLE

to generate the .project files for each package and then run: the
follwoing script

#+BEGIN_EXAMPLE
    ROOT=$PWD
    cd build
    for PROJECT in `find $PWD -name .project`; do
        DIR=`dirname $PROJECT`
        echo $DIR
        cd $DIR
        awk -f $(rospack find mk)/eclipse.awk .project > .project_with_env && mv .project_with_env .project
    done
    cd $ROOT
#+END_EXAMPLE

To debug use use the following command and you can mention the name of
the package to configure that sepecific project for debug instead of the
entire workspace. remeber to run the script to modify .project topass
the current shell environment into the make process in Eclipse.

#+BEGIN_EXAMPLE
    catkin build  --force-cmake -G"Eclipse CDT4 - Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug
#+END_EXAMPLE

****** Importing the project into Eclipse

Now start Eclipse, select *File* --> *Import* --> *Existing projects
into workspace*, hit next, then browse for your package's directory
(*select root directory*). Do NOT select *Copy projects into workspace*.
Then finish.

You should now be able to browse through the code (hold down *CTRL*
while clicking on a function/class name), get auto completion
(automatically appears, or press *CTRL-SPACE*) et cetera.

******* Fixing unresolved includes

There are many possible reasons why indexing cannot resolve all
includes, functions, methods, variables, etc. Often, fixing the
resolving of includes solves these errors. If you have any problems,
these might be fixed by:

-  If the dependencies of your project have changed since first adding
   them to Eclipse, regenerate the project files and reimport the
   project into your workspace.
-  Making sure to load your .bashrc environment with Eclipse, by
   launching it using /=bash-i-c"eclipse"=/ (see
   [[/IDEs#Reusing_your_shell.27s_environment][Reusing your shell's
   environment]]).
-  In Eclipse, right click the project, click properties -> C/C++
   general -> Preprocessor Include Paths, Macros etc. Click the tab
   "Providers" and check the box next to "CDT GCC Built-in Compiler
   Settings [ Shared ]".
-  Afterwards, right click the project, select Index -> Rebuild. This
   will rebuild your index. Once this is done, usually all includes will
   resolve.
-  As a last resort, you can also manually add folders that will be
   searched for headers, using right click project -> properties ->
   C/C++ Include Paths and Symbols. This is usually not necessary
   though.

****** Building the project inside Eclipse

The =eclipse-project= make target automatically tries to set the
environment variables correctly such that building within Eclipse should
work out-of-the-box. Especially if you follow /Reusing your shell's
environment/ from above.

If not, this is where you need to start looking: Right click on the
project, select *Properties* --> *C/C++ Make Project* --> Environment,
and check whether the following environment variables are assigned to
the correct values:

-  ROS\_ROOT
-  ROS\_PACKAGE\_PATH
-  PYTHONPATH
-  PATH

The easiest way to obtain the correct values for your installation is to
open a terminal, and run

#+BEGIN_EXAMPLE
    echo $ROS_ROOT
    echo $ROS_PACKAGE_PATH
    echo $PYTHONPATH
    echo $PATH
#+END_EXAMPLE

You should now be able to compile your package properly, for example by
hitting *CTRL-B* (or selecting *Project* --> *Build project* in the
menu).

*Note*: When working with multiple projects, Eclipse won't be able to
determine the correct build order or when dependent projects have to be
rebuilt. You have to set the project interdependencies manually for each
project in your workspace (see
[[http://help.eclipse.org/helios/index.jsp?topic=/org.eclipse.cdt.doc.user/reference/cdt_u_prop_general_pns_ref.htm][http://help.eclipse.org/helios/index.jsp?topic=/org.eclipse.cdt.doc.user/reference/cdt\_u\_prop\_general\_pns\_ref.htm]]).

****** Running and debugging your executables within Eclipse

As for building within Eclipse, the crucial step here is to set the
required environment variables correctly in the launch configuration. As
the same for building, this should work out-of-the-box, especially if
you follow /Reusing your shell's environment/ from above.

Create a new launch configuration, by clicking on *Run* --> *Run
configurations...* --> *C/C++ Application* (double click or click on
*New*). Select the correct binary on the *main* tab (*Search project*
should work when your binary was already built). Then in the
*environment* tab, add (at least)

-  ROS\_ROOT
-  ROS\_MASTER\_URI

again with the values of your installation. If you are unsure about
them, open a terminal and run

#+BEGIN_EXAMPLE
    echo $ROS_ROOT
    echo $ROS_MASTER_URI
#+END_EXAMPLE

Finally, if you cannot save the configuration, remove the *@* character
in the name of the new run configuration.

This should now allow you to run and debug your programs within Eclipse.
The output directly goes into the *Console* of Eclipse. Note that the
ROS\_INFO macros use ANSI escape sequences, which are not parsed by
Eclipse; therefore, the output might look similar to this one (from
[[/roscpp_tutorials/Tutorials/WritingPublisherSubscriber][Writing a
Publisher/Subscriber (C++)]]):

#+BEGIN_EXAMPLE
    [0m[ INFO] [1276011369.925053237]: I published [Hello there! This is message [0]][0m
    [0m[ INFO] [1276011370.125082573]: I published [Hello there! This is message [1]][0m
    [0m[ INFO] [1276011370.325025148]: I published [Hello there! This is message [2]][0m
    [0m[ INFO] [1276011370.525034947]: I published [Hello there! This is message [3]][0m
#+END_EXAMPLE

You could use an ANSI console plugin (e.g.
[[http://www.mihai-nita.net/eclipse/][http://www.mihai-nita.net/eclipse/]])
to get rid of the "[0m" characters in the output.

****** More eclipse goodies

-  Setup a file template that pre-formats whenever a new source or
   header file is created. The template could for example contain the
   license header, author name, and include guards (in case of a header
   file). To setup the templates, choose in the Preferences *C/C++->Code
   Style->Code Templates*. For example, to add the license header choose
   *Files->C++ Source File->Default C++ source template* and click on
   *Edit...*. Paste the license header and click *OK*. From now on, all
   source files while automatically contain the license header.
-  Enable Doxygen with the project properties clicking on *C/C++
   General*, *enabling project specific settings* and selecting Doxygen
   as *Documentation tool*. This option automatically completes Doxygen
   style comments highlights them.
-  People that are used to the emacs key bindings can select emacs-style
   bindings in *Windows->Preferences General->Keys* and selecting the
   emacs*Scheme*. Also, other useful key bindings (e.g. make project)
   can easily be added.
-  To also index files that live outside the ROS tree (e.g. the boost
   include files) you can add them in project properties *C/C++
   General->Paths and Symbols*.
-  The generated eclipse project also works great for Python code. Just
   install the [[http://pydev.org/][PyDev]] plugin for syntax
   highlighting and code completion.

****** Auto Formatting

Eclipse also has extensive formatting configuration capabilities. To add
the ROS formatting profile to Eclipse, perform the following steps:

-  Download ROS\_Format.xml to some location (versions:
   [[/IDEs?action=AttachFile&do=view&target=ROS_format.xml][Indigo]]
   [[/IDEs?action=AttachFile&do=view&target=ROS_format-kepler.xml][Kepler]])
-  Start Eclipse
-  Select *Window*->*Preferences*->*C/C++*->/*Code Style*/
-  Click /*Import...*/
-  Select /ROS\_format.xml/ from the location used in step 1
-  Click /*OK*/

As you edit a file, Eclipse should use this new profile to format your
code following the ROS conventions. To reformat an entire file, select
/*Edit*->/*Format*/./

***** CodeBlocks

Here's how to create a ROS package using CodeBlocks:

-  Create a new project as you normally do in CodeBlocks, either as a
   console project or as a wxWidgets project. Write a manifest.xml file
   that specifies the ROS dependencies, as you normally do for a ROS
   package. To get the compiler and the linker flags, use these commands
   from a terminal window:

   #+BEGIN_EXAMPLE
         rospack export --lang=cpp --attrib=cflags PackageName
         rospack export --lang=cpp --attrib=lflags PackageName
   #+END_EXAMPLE

   You can just copy and paste the results into the Build Options of
   your project, specifically:

   -  In CodeBlocks, right click on the project name, select Build
      Options, select the project (rather than the Debug or Release
      versions that are selected by default in the popup window), select
      the tabs for Compiler Settings, Other Options, and paste the
      cflags you got from above. Then select the linker settings tab,
      and in Other Linker Options, paste the linker flags you got from
      above. You can also do this with a bash script: copy the flags
      into bash scripts, make them executable, and put the scripts in
      place of the long lists of flags. You can use environment
      varialbles in the script. Note that CodeBlocks allows a "local"
      definition of environment variables as well.

   If you are writing a ROS node, create the msg (and perhaps svr)
   directory and populate it as you normally do using.

   -  =`rospackfindroscpp`=/scripts/genmsg\_cpp msg/MessageName.msg

   Then be sure to go back and add -Imgs/cpp (and perhaps -I srv/cpp)
   flags to the cflags in Compiler Settings, Other Options.

   I posted in the Attachments an example of code that works in a
   CodeBlocks wxWidgets GUI project and runs a ROS node that subscribes,
   advertises, services, and publishes data across various busses. The
   files are nodeTemplate.cpp and nodeTemplate.h

Here's how to use the sample code: . Create a package called
wxWidgetsNodeTemplate, using the attached manifest.xml file. Also create
a msg directory and a srv directory.

-  Use the attached RosNodeTemplate.msg file and auto-generate the
   header for it with
-  =`rospackfindroscpp`=/scripts/genmsg\_cpp msg/RosNodeTemplate.msg
-  Similarly use the attached NodeTemplateServer,srv file and
   auto-generate the header for it with
-  =`rospackfindroscpp`=/scripts/gensrv\_cpp
   srv/NodeTemplateServer.srv
-  Now create a CodeBlocks project as detailed above. Add the attached
   files, nodeTempalte.h and nodeTemplate.cpp to the project.
-  Now make an instance of nodeTemplate, passing it a pointer to a
   wxTextCtrl:
-  m\_pNodeTemplate = new nodeTemplate(txtGeneral);
-  It will listen to monitor\_node\_bus and write to the textbox when it
   sees activity on that bus.
-  It will service calls to node\_service\_bus and write to the textbox
   when the service is called.
-  You can publish on node\_bus\_out with
-  m\_pNodeTemplate->Publish();
-  .

***** Emacs                                                       :emacs:

Support through the [[/rosemacs][rosemacs]] package. Navigate and tab
complete the ros package file system, live tracking and tab completion
of topics, tracking and notifications when nodes startup/die, etc.

***** Vim                                                           :vim:

The most feature-rich Vim plugin for ROS development is
[[https://github.com/taketwo/vim-ros][vim-ros]]. It provides =:Roscd=,
=:Rosed=, and =:TabRosed= commands with <Tab> completion, manages your
=&makeprg= setting (to allow building with =:make=), brings syntax
highlighting and omni-completion for ROS filetypes (e.g. message
descriptions, launch files), facilitates integration with =Ultisnips=
and =Syntastic= plugins, and whatnot. The plugin is written in Python
and, as such, is contribution-friendly.

Alternative support is through the
[[/IDEs?action=AttachFile&do=view&target=rosvim.vim][rosvim plugin]],
from Michael Styer. Drop the file in =~/.vim/plugin=.

Extended version of rosvim.vim is
[[https://github.com/ompugao/ros.vim][here]] (sorted and implemented
<Tab> completion feature), and
[[https://github.com/kien/ctrlp.vim][ctrlp.vim]] interface of ros.vim is
[[https://github.com/ompugao/ctrlp-ros][here]]. You can install these
plugins easily by using vimscript installation plugins such as
[[https://github.com/gmarik/vundle][https://github.com/gmarik/vundle]]
and
[[https://github.com/Shougo/neobundle.vim][https://github.com/Shougo/neobundle.vim]].

A useful complement to these plugins is the YouCompleteMe plugin for
code completion. Thanks to a configuration file from Gaël Ecorchard
([[https://gist.github.com/galou/92a2d05dd772778f86f2][.ycm\_extra\_conf.py]]),
the include paths are automatically added to the YouCompleteMe
configuration for ROS packages.

***** NetBeans

The NetBeans IDE is written in Java and supports development in Java and
many other programming languages. Here, C/C++ development support will
be of interest.

****** Installing NetBeans

Although NetBeans is included in Ubuntu repositories, everything
described here was tested with [[/NetBeans][NetBeans]] 6.9.1.

-  Go to [[http://www.netbeans.org/][http://www.netbeans.org/]]
-  Click on "Download FREE (NetBeans 6.9.1)" in the middle of the page
-  Download the C/C++ bundle

   -  If [[http://www.netbeans.org/][http://www.netbeans.org/]] is
      experiencing problems, try e.g.
      [[http://dlc.sun.com.edgesuite.net/netbeans/6.9.1/final/bundles/netbeans-6.9.1-ml-cpp-linux.sh][http://dlc.sun.com.edgesuite.net/netbeans/6.9.1/final/bundles/netbeans-6.9.1-ml-cpp-linux.sh]]
      (MD5 sum from
      [[http://www.netbeans.org/][http://www.netbeans.org/]] is
      26f585185b95682cb07d3e5218760702)

-  Run (as root) the downloaded file (install script and embedded
   archive)

#+BEGIN_EXAMPLE
    $ sudo sh netbeans-6.9.1-ml-cpp-linux.sh
#+END_EXAMPLE

****** Getting ROS environment variables in NetBeans

NetBeans can "import" project from existing sources. It can use
Makefiles, and even run configure script or CMake to generate one. But,
that kind of automatic project configuration and build would overwrite
stub makefile that every ROS package has. That makefile in essence runs
ROS build system for a package, and that is what we want NetBeans to do.

In order to use [[/rosmake][rosmake]] from NetBeans, we need to set ROS
environment variables in NetBeans. Since NetBeans is started with a
shell script on Linux, we can include the variables in the script.

******* In recent ROS (where rosinstall generates setup files for multiple
types of shell)

Since from recent versions [[/rosinstall][rosinstall]] generates
=setup.sh=, =setup.bash= and =setup.zsh= (as oposed to just =setup.sh=
which was actually a =bash= script), there is no need for all the steps
that are described in the next section.

The following will suffice to get ROS environment variables to NetBeans:

#+BEGIN_EXAMPLE
    $ roscd
    $ cd ..
    $ echo ". $(pwd)/setup.sh" > ~/.netbeans/6.9/etc/netbeans.conf
#+END_EXAMPLE

We don't actually need perks specific to =bash=.

The exact path of *netbeans.conf* for the various OS can be found here:
[[http://wiki.netbeans.org/FaqNetbeansConf][http://wiki.netbeans.org/FaqNetbeansConf]]

******* In previous ROS

If [[/rosinstall][rosinstall]] doesn't generate setup files for multiple
types of shell, you need to do the following. Since ROS shell tools are
for bash, we'll convert NetBeans startup script from =sh= to =bash=.
Simply edit the first line of NetBeans startup script (located at
=/usr/bin/netbeans= if you installed from the Ubuntu package, or
possibly =/usr/local/netbeans-6.9.1/bin/netbeans= if you installed
manually) from

#+BEGIN_EXAMPLE
    #!/bin/sh
#+END_EXAMPLE

to

#+BEGIN_EXAMPLE
    #!/bin/bash
#+END_EXAMPLE

Further down the startup script it can be seen that the file
=~/.netbeans/6.9/etc/netbeans.conf= is included if it exists. We'll
create that file like this

#+BEGIN_EXAMPLE
    $ roscd
    $ cd ..
    $ echo "source $(pwd)/setup.sh" > ~/.netbeans/6.9/etc/netbeans.conf
#+END_EXAMPLE

Now, it just takes to modify NetBeans .desktop launcher
(=/usr/share/applications/netbeans-6.9.1.desktop=). Change the line

#+BEGIN_EXAMPLE
    Exec=/bin/sh "/usr/local/netbeans-6.9.1/bin/netbeans"
#+END_EXAMPLE

to

#+BEGIN_EXAMPLE
    Exec=/bin/bash "/usr/local/netbeans-6.9.1/bin/netbeans"
#+END_EXAMPLE

And that is it. Next time you start NetBeans it will have ROS
environment variables, and you'll be able to use e.g.
[[/rosmake][rosmake]].

****** Making NetBeans project

We'll try to setup project for Microstrain 3DM-GX2 IMU driver package,
so note it's path:

#+BEGIN_EXAMPLE
    $ roscd microstrain_3dmgx2_imu
    $ pwd
#+END_EXAMPLE

-  Start "C/C++ Project with Existing Sources" wizard
-  Use the above path to "Specify the folder that contains existing
   sources"
-  Select "Custom" Configuration Mode (note that Automatic Mode
   recognizes cmake)
-  Proceed with the wizard accepting defaults

You should get a NetBeans project for
[[/microstrain_3dmgx2_imu][microstrain\_3dmgx2\_imu]] package with
automatically configured Code Assistance (and almost working for all
dependencies). E.g. you can see that the bullet library headers weren't
parsed.

We will configure Code Assistance manually. That means entering paths to
all header files the package uses and all preprocessor definitions.

To get the paths to include files for the package we will use
[[/rospack][rospack]]. Further, we'll use =sed= to format them for
easier input to NetBeans.

#+BEGIN_EXAMPLE
    $ rospack cflags-only-I microstrain_3dmgx2_imu | sed 's/ /:/g' -
#+END_EXAMPLE

Open the project properties. Go to Code Assistance -> C++ Compiler and
paste the output of the above command to Include Directories field.

Use [[/rospack][rospack]] to find the preprocessor definitions and enter
them manually.

#+BEGIN_EXAMPLE
    $ rospack cflags-only-other microstrain_3dmgx2_imu
#+END_EXAMPLE

****** Code auto formatting in NetBeans

Following file
[[/IDEs?action=AttachFile&do=view&target=netbeans-ros-code_style.zip][netbeans-ros-code\_style.zip]]
is prepared to enable auto formatting of C++ code in NetBeans as defined
in [[/CppStyleGuide][CppStyleGuide]]. In order to use it, you should
import it to Netbeans (Tools -> Options -> Import).

With this, example given in
[[/CppStyleGuide#Formatting][CppStyleGuide#Formatting]] will be
identically formated, except of extra blank lines before function or
class definitions. For a discussion see Google C++ style guide
[[http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Vertical_Whitespace#Vertical_Whitespace][Vertical
Whitespace]].

***** QtCreator                                               :qtcreator:

#+BEGIN_EXAMPLE
-DCMAKE_BUILD_TYPE=debug -DCATKIN_DEVEL_PREFIX=../devel -DCMAKE_INSTALL_PREFIX=../install
#+END_EXAMPLE

As QtCreator supports opening CMake projects out of the box ,it does not
require a setup procedure if started from a terminal. Note that this is
absolutely crucial, because otherwise the environment will not be set
correctly and functionality related to rosbuild or catkin will fail when
running cmake.

Note that instead of starting QtCreator from a terminal, you can use the
following desktop file and use it in your launcher:

#+BEGIN_EXAMPLE
    $ cat qtcreator.desktop
    [Desktop Entry]
    Exec=bash -i -c qtcreator %F
    Icon=qtcreator
    Type=Application
    Terminal=false
    Name=Qt Creator
    GenericName=Integrated Development Environment
    MimeType=text/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.nokia.qt.qmakeprofile;application/vnd.nokia.xml.qt.resource;
    Categories=Qt;Development;IDE;
    InitialPreference=9
#+END_EXAMPLE

In Ubuntu 13.04 and later, the third line must read:

#+BEGIN_EXAMPLE
    Icon=QtProject-qtcreator
#+END_EXAMPLE

This is the standard QtCreator desktop file, except for the Exec line
that has been modified with "bash -i -c". More about desktop files and
their locations for Ubuntu can be found
[[https://help.ubuntu.com/community/UnityLaunchersAndDesktopFiles][here]].
Note also that the same trick can be used with eclipse.

If you are experiencing issues with the qtcreator package shipped by
Ubuntu when opening the CMakeLists, then try installing QtCreator from
Nokia's installer.

****** rosbuild

To open a rosbuild ROS package code as a project, use "Open File or
Project" and select the CMakeLists.txt of your ROS package. Take care to
select the "[package\_name]/build" directory as the build directory,
which is the ROS default. On the next screen click 'Run Cmake' and then
Finish. This may not show all the folders such as launch and include in
the project tree. If you want to choose the files manually, goto
File->New File or Project->Import Project->Import Existing Project and
selected to choose all files/folders included in the project.

****** catkin\_make

To open a catkin code as a project, use "Open File or Project" and
select the top level CMakeLists.txt of the catkin workspace (e.g.
"src/CMakeLists.txt"). Select the catkin build folder as the build
directory and 'Run CMake' (in order to enable debugging add following
line into arguments edit box: -DCMAKE\_BUILD\_TYPE=Debug).

Recently this has started to fail, because the main CMakeLists is a
symlink to a non writtable location. The workaround is to make a copy to
toplevel.cmake instead of using a symlink. And if you want the project
to be named something else than "Project" then add a line at the top
with "project(MyProjectName)"

To be able to modify all the files in the workspace add those lines in
"src/CMakeLists.txt" :

#+BEGIN_EXAMPLE
    #Add all files in subdirectories of the project in
    # a dummy_target so qtcreator have access to all files
    FILE(GLOB children ${CMAKE_SOURCE_DIR}/*)
    FOREACH(child ${children})
      IF(IS_DIRECTORY ${child})
        file(GLOB_RECURSE dir_files "${child}/*")
        LIST(APPEND extra_files ${dir_files})
      ENDIF()
    ENDFOREACH()
    add_custom_target(dummy_${PROJECT_NAME} SOURCES ${extra_files})
#+END_EXAMPLE

You may specify the correct catkin /devel/ and /install/ spaces at
Projects->Build Settings by providing the following CMake arguments:
=-DCATKIN_DEVEL_PREFIX=../devel -DCMAKE_INSTALL_PREFIX=../install=

****** catkin tools

With the new
[[http://catkin-tools.readthedocs.org/en/latest/index.html][catkin\_tools]],
there is no longer a top level make file for the whole workspace.
Instead, open each package as an individual project in QtCreator. The
trick is to set the build folder to =ws/build/your_package= instead of
=ws/build= as before.

***** PyCharm (community edition)                               :pycharm:

PyCharm is IDE for Python. In order to run and debug ROS functionality
you need to modify the desktop file for PyCharm (the same procedure as
for other IDE's). Desktop file name was jetbrains-pycharm-ce.desktop.
Instead of

#+BEGIN_EXAMPLE
    Exec="/opt/pycharm-community-4.0.4/bin/pycharm.sh" %f
#+END_EXAMPLE

should be

#+BEGIN_EXAMPLE
    Exec=bash -i -c "/opt/pycharm-community-4.0.4/bin/pycharm.sh" %f
#+END_EXAMPLE

In the Exec line "bash -i -c" was added.

****** packages

In order to work with packages just create new project in parent folder
for all your packages or in particular package. Please note that folder
.idea with project files will be created. You can add it to .gitignore
file in case if you are using Git and do not want to commit this file to
repository. PyCharm will parse all files in the packages and allow you
quick navigation, fast code completions, run and debug Python code,
unitest run and debug.

****** code

******* run

Code can be run using roslaunch or rosrun command from command line.
Simple Python files can be run using run context menu.

******* debug

In order to debug Python node do the following changes

-  Comment node in the launch file my\_nodes.launch
-  If node has any parameters specified inside put them into <group> tag
   with ns attribute equal to node name
-  Launch my\_nodes.launch using roslaunch command
-  Run Python node from PyCharm IDE in debug mode

****** unittest

******* run

Unittest can be simple run using content menu on the file in the project
tree or on particular method in the code. Results would be shown in UI.

******* debug

Unittest can be normally debug using start debug menu.

In case of integration test (rostest)

-  Comment <test> tag in the my\_file.test launch file
-  launch my\_file.test using roslaunch not rostest
-  launch test using PyCharm unittest debug from IDE

***** kDevelop

kDevelop has excellent C++ support, GDB integration and does semantic
syntax highlighting with individual colors for different variables. Such
as [[http://wiki.ros.org/IDEs#QtCreator][QtCreator]], kDevelop supports
opening CMake projects out of the box.

kDevelop must know the ROS environment variables, therefore start
kDevelop from a terminal that has sourced your catkin workspace already.
Alternatively, create the following desktop file according to the
remarks in the
[[http://wiki.ros.org/IDEs#Reusing_your_shell.27s_environment][general
section]] and mark it as exectuable:

#+BEGIN_EXAMPLE
    cd ~/Desktop
    touch kDevelop.desktop
    # Now edit the file using the editor of your choice and insert the text from the box below
    chmod +x kDevelop.desktop
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [Desktop Entry]
    Type=Application
    Terminal=false
    Exec=bash -i -c "kdevelop"
    Name=kDevelop
    Icon=kdevelop
#+END_EXAMPLE

****** Import catkin top-level workspace

The following steps describe how to import the complete catkin workspace
into kDevelop.

-  It is recommended to clear the catkin build folder before importing
   the project. You can safely remove the build folder from your catkin
   workspace since it will be created again during the cmake configure
   and build process.
-  Start kDevelop from shell or using the modified desktop shortcut
   mentioned above.
-  Goto the "Project" tab and select "Open / Import Project...". Switch
   to your catkin source space (we assume =~/catkin_ws/src= here) and
   select "CMakeLists.txt". Afterwards, you may replace the "Name" by
   your workspace name (default: "src"). Make sure that the selected
   "Build System" is "CMake Project Manager". Proceed by clicking on
   "Finish".
-  A new window should appear that contains cmake build configurations.
-  Set the "Build Directory" to the catkin build space, e.g.:
   =/home/user/catkin_ws/build/=
-  Select your desired "Build type".
-  Finally, add the following *Extra Arguments* to make sure, that the
   binaries and libraries are moved into the correct catkin spaces
   (devel and install):

   =-DCATKIN_DEVEL_PREFIX=../devel-DCMAKE_INSTALL_PREFIX=../install=

-  Wait until kdevelop has finished importing your workspace. Try to
   compile your code by clicking on the "Build button".
-  After switching to the source code of an underlying package let
   kDevelop some seconds to parse for auto-completion and code
   highlighting.

****** Running and debugging your executables

Configure executable:

-  After the catkin workspace is successfully imported and *builded*,
   goto: "Run -> Configure Launches...".
-  Click on the "Add New..." menu and try to find your executable in the
   "Project Executables" submenu. If the binary is not listed there, you
   can add it manually using "Add New... -> Compiled Binary" (specify
   the location of the executable/binary, e.g.
   "~/catkin\_ws/devel/lib/package/node\_name").
-  Optionally specify any arguments.
-  Finish configuration by clicking "OK".

Run executable:

-  Just click on "Execute". In case of multiple configured executables,
   select the current executable at "Run -> Current Launch
   Configuration".

Debug executable:

-  Add a breakpoint to a related package source file and click on the
   "Debug" button. Make sure that the current launch configuration is
   set to the correct binary.

****** Remarks

If something went wrong, delete the "*.kdev4" file and the ".kdev4"
folder inside your source space and try to repeat the procedure.

The "Build Type" selected during project import (e.g. "Debug",
"Release", "[[/RelWithDebInfo][RelWithDebInfo]]") can be changed by
right-clicking on the project -> "Open Configuration...". Select CMake
in the left menu and change the CMake variable "CMAKE\_BUILD\_TYPE"
appropriately.

*Note*, if a package inside the catkin workspace specifies its own
"Build Type", e.g. by adding =set(CMAKE_BUILD_TYPERelease)= to the
underlying package "CMakeLists.txt", it will be used for that package
instead of the global one defined in the top-level CMake project.

You may set up a project filter since kDevelop displays a lot of files
and (ros) binaries in the source tree that are not really interesting
for the developer and finding individual files could be really
confusing. Right click on the project and select "Open
Configuration...". Choose "Project Filter" in the left menu. The
cleanest solution is to first exclude all files and then include only
desired file types:

1. Click Add. Type in the pattern: "*" (just the star character) and
   select as "Target" only *Files*. Choose "Action" *Exclude*.
2. Now add all files you want include into the project tree:
   Click "Add" and type in your desired file pattern. Choose "Action"
   *Include*. Suggested file patterns are: ".h" ".cpp" ".hpp ".c" ".ipp"
   ".c" ".txt" ".launch" ".xml" ".md" ".cmake" ".cfg" ".py" ".yaml"
   ".urdf" ".sdf" ".xacro"

**** CMake
1. catkin_make

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{sh}
     catkin_make -DCMAKE_BUILD_TYPE=Debug
     \end{minted}
   #+end_latex

2. CMakeLists.txt
   #+begin_latex
   \begin{minted}[frame=leftline, mathescape]{cmake}
   set(CMAKE_BUILD_TYPE Debug)
   \end{minted}
   #+end_latex

**** gdb调试单个节点

直接使用 GDB 运行节点。

1. shell: *gdb path/to/node*

2. emacs: *gdb -i=mi path/to/node*

*运行(r)前要设置断点*

**** gdb roslaunch

[[*launch-prefix%20%5B%5Bhttp://wiki.ros.org/roslaunch/Tutorials/Roslaunch%2520Nodes%2520in%2520Valgrind%2520or%2520GDB%5D%5BRoslaunch%20nodes%20in%20GDB%5D%5D][launch-prefix Roslaunch nodes in GDB]]

Btw: this is not really specific to *catkin_make*. The *launch-prefix*
just makes this convenient when starting things from launch files. For
single nodes (and an already running master), you can also just do:

**** TODO gdb多线程 （关键还是GDB）

**** TODO gdb多进程

*** roscpp                                                         :roscpp:

**** roscpp API                                                      :api:
***** [[file:/opt/ros/indigo/include/rosconsole/macros_generated.h::#define%20ROS_INFO(...)%20ROS_LOG(::ros::console::levels::Info,%20ROSCONSOLE_DEFAULT_NAME,%20__VA_ARGS__)][ROS_INFO]]

#+BEGIN_SRC cpp
#define ROS_INFO(...) ROS_LOG(::ros::console::levels::Info, ROSCONSOLE_DEFAULT_NAME, __VA_ARGS__)
#+END_SRC

*** rospy                                                           :rospy:
**** [[http://answers.ros.org/question/159251/why-do-we-need-roslibload_manifest/][load_manifest]]

In large projects, your code might depend on many external packages. A
manifest contain meta-information about what your software is doing
and how to set it up. The documentation is quite exhaustive on the
topic: wiki.ros.org/Manifest

Practically speaking, you can very well just "import roslib; import
rospy" and your code will still work. You might however want to think
of writing a manifest as soon as you start depending on other
libraries and want to share you code with other people.

*** [[http://wiki.ros.org/rviz][rviz]]                                                             :rviz:

**** Documentation
***** [[http://wiki.ros.org/rviz/UserGuide][User Guide]]
***** [[http://wiki.ros.org/rviz/Troubleshooting][Troubleshooting]]
***** [[http://wiki.ros.org/rviz/DisplayTypes][Built-in Display Types]]

**** Tutorials                                                  :tutorial:

***** [[http://wiki.ros.org/rviz/Tutorials/Markers%253A%2520Basic%2520Shapes][Markers: Sending Basic Shapes (C++)]]

Shows how to use [[http://docs.ros.org/api/visualization_msgs/html/msg/Marker.html][visualization_msgs/Marker]] messages to send basic
shapes (cube, sphere, cylinder, arrow) to rviz.

***** [[http://wiki.ros.org/rviz/Tutorials/Markers%253A%2520Points%2520and%2520Lines][Markers: Points and Lines (C++)]]

Teaches how to use the [[http://docs.ros.org/api/visualization_msgs/html/msg/Marker.html][visualization_msgs/Marker]] message to send
points and lines to rviz.

***** [[http://wiki.ros.org/rviz/Tutorials/Interactive%2520Markers%253A%2520Getting%2520Started][Interactive Markers: Getting Started]]

This tutorial explains what Interactive Marker are and teaches you
some of the basic concepts.

***** [[http://wiki.ros.org/rviz/Tutorials/Interactive%2520Markers%253A%2520Writing%2520a%2520Simple%2520Interactive%2520Marker%2520Server][Interactive Markers: Writing a Simple Interactive Marker Server]]

This tutorial explains how to setup a minimalist server which manages
a single interactive marker.

***** [[http://wiki.ros.org/rviz/Tutorials/Interactive%2520Markers%253A%2520Basic%2520Controls][Interactive Markers: Basic Controls]]

This tutorial explains how the basic_controls tutorial code works.

***** [[http://wiki.ros.org/rviz/Tutorials/Plugins%253A%2520New%2520Display%2520Type][Plugins: New Display Type]]

How to write a plugin which adds a new display capability to RViz.

***** [[http://wiki.ros.org/rviz/Tutorials/Plugins%253A%2520New%2520Dockable%2520Panel][Plugins: New Dockable Panel]]

How to write a plugin which adds a new type of dock-able Panel widget
to RViz.

***** [[http://wiki.ros.org/rviz/Tutorials/Plugins%253A%2520New%2520Tool%2520Type][Plugins: New Tool Type]]

How to write a plugin which adds a new tool to RViz.

***** [[http://wiki.ros.org/rviz/Tutorials/Librviz%253A%2520Incorporating%2520RViz%2520into%2520a%2520Custom%2520GUI][Librviz: Incorporating RViz into a Custom GUI]]

How to write an application using an RViz visualization widget.

***** [[http://wiki.ros.org/rviz/Tutorials/Rviz%2520in%2520Stereo][Rviz in Stereo]]

Teaches how to set up Rviz to render in 3D Stereo.

**** rviz 保存的通用配置文件保存在 $HOME/.rviz/ 文件夹下

#+BEGIN_EXAMPLE
    <node if="$(arg viz)" name="rviz" pkg="rviz" type="rviz"
          args="-d $(env HOME)/.rviz/display.rviz" required="false" />
#+END_EXAMPLE

**** Q&A
***** rviz python
http://answers.ros.org/question/33423/markers-python/
http://answers.ros.org/question/11135/plotting-a-markerarray-of-spheres-with-rviz/

Marker messages are ROS messages just like anything else you can
publish from a python node, there is no special about them.

*** [[http://wiki.ros.org/rqt][rqt]]                                                           :rqt:

***** intro

*rqt* is a software framework of ROS that implements the various GUI
 tools in the form of plugins. One can run all the existing GUI tools
 as dockable windows within rqt!

The tools can still run in a *traditional standalone* method, but rqt
_makes it easier to manage all the various windows on the screen at
one moment_.

****** components

rqt consists of three (+1) metapackages:

- /rqt/ - core modules. rqt plugin developers barely needs to pay
  attention.

- /rqt_common_plugins/ - ROS backend tools suite that can be used on/off
  robot runtime.

- /rqt_robot_plugins/ - Tools for interacting robots during their
  runtime.
  - rqt_pr2_dashboard - Robot specific (PR2). Temporarily excluded
    from other metapackages due to building issue

****** usage

******* basic

#+BEGIN_EXAMPLE
rqt
#+END_EXAMPLE

#+BEGIN_EXAMPLE
rqt --standalone rqt_mypkg
#+END_EXAMPLE

******* help

#+BEGIN_EXAMPLE
  usage: rqt [-b BINDING] [--clear-config] [-f] [--force-discover] [-h] [-l]
             [-m] [-p PERSPECTIVE] [--perspective-file PERSPECTIVE_FILE]
             [--reload-import] [-s PLUGIN] [-t] [-v]
             [--args [PLUGIN_ARGS [PLUGIN_ARGS ...]]] [--list-perspectives]
             [--list-plugins] [--command-pid PID]
             [--command-start-plugin PLUGIN]
             [--command-switch-perspective PERSPECTIVE]

  Options for GUI instance:
    -b BINDING, --qt-binding BINDING
                          choose Qt bindings to be used [pyqt|pyside]
    --clear-config        clear the configuration (including all perspectives
                          and plugin settings)
    -f, --freeze-layout   freeze the layout of the GUI (prevent rearranging
                          widgets, disable undock/redock)
    --force-discover      force a rediscover of plugins
    -h, --help            show this help message and exit
    -l, --lock-perspective
                          lock the GUI to the used perspective (hide menu bar
                          and close buttons of plugins)
    -m, --multi-process   use separate processes for each plugin instance
                          (currently only supported under X11)
    -p PERSPECTIVE, --perspective PERSPECTIVE
                          start with this named perspective
    --perspective-file PERSPECTIVE_FILE
                          start with a perspective loaded from a file
    --reload-import       reload every imported module
    -s PLUGIN, --standalone PLUGIN
                          start only this plugin (implies -l). To pass arguments
                          to the plugin use --args
    -t, --on-top          set window mode to always on top
    -v, --verbose         output qDebug messages
    --args [PLUGIN_ARGS [PLUGIN_ARGS ...]]
                          arbitrary arguments which are passes to the plugin
                          (only with -s, --command-start-plugin or --embed-
                          plugin). It must be the last option since it collects
                          all following options.

  Options to query information without starting a GUI instance:
    These options can be used to query information about valid arguments for
    various options.

    --list-perspectives   list available perspectives
    --list-plugins        list available plugins

  Options to operate on a running GUI instance:
    These options can be used to perform actions on a running GUI instance.

    --command-pid PID     pid of the GUI instance to operate on, defaults to
                          oldest running GUI instance
    --command-start-plugin PLUGIN
                          start plugin
    --command-switch-perspective PERSPECTIVE
                          switch perspective

  Special options for embedding widgets from separate processes:
    These options should never be used on the CLI but only from the GUI code
    itself.
#+END_EXAMPLE

******* list-plugins

#+BEGIN_EXAMPLE
rqt --list-plugins
#+END_EXAMPLE

- create_dashboard.dashboard.CreateDashboard
- kobuki_dashboard.dashboard.KobukiDashboard
- rqt_action.action_plugin.ActionPlugin
- rqt_bag.bag.Bag
- rqt_console.console.Console
- rqt_dep.ros_pack_graph.RosPackGraph
- rqt_graph.ros_graph.RosGraph
- rqt_image_view/ImageView
- rqt_joint_trajectory_controller.joint_trajectory_controller.JointTrajectoryController
- rqt_launch.launch_plugin.LaunchPlugin
- rqt_logger_level.logger_level.LoggerLevel
- rqt_moveit.moveit_plugin.MoveitPlugin
- rqt_msg.messages.Messages
- rqt_nav_view.nav_view_plugin.NavViewPlugin
- rqt_plot.plot.Plot
- rqt_pose_view.pose_view.PoseView
- rqt_publisher.publisher.Publisher
- rqt_py_console.py_console.PyConsole
- rqt_reconfigure.param_plugin.ParamPlugin
- rqt_robot_monitor.robot_monitor_plugin.RobotMonitorPlugin
- rqt_robot_steering.robot_steering.RobotSteering
- rqt_runtime_monitor.runtime_monitor.RuntimeMonitor
- rqt_rviz/RViz
- rqt_service_caller.service_caller.ServiceCaller
- rqt_shell.shell.Shell
- rqt_srv.services.Services
- rqt_tf_tree.tf_tree.RosTfTree
- rqt_top.top_plugin.Top
- rqt_topic.topic.Topic
- rqt_web.web.Web

******* list-perspectives

#+BEGIN_EXAMPLE
rqt --list-perspectives
#+END_EXAMPLE

- @rqt_console__Console
- @rqt_dep__RosPackGraph
- @rqt_graph__RosGraph
- @rqt_reconfigure__Param
- @rqt_tf_tree__RosTfTree
- Default

******* debugging rqt_gui with debugger

#+BEGIN_EXAMPLE
% gdb python
(gdb) run $YOUR_RQT_GUI_HOMEDIR$/bin/rqt_gui
 :          (usual gdb usage)
#+END_EXAMPLE

****** [[http://wiki.ros.org/rqt/Plugins][plugin]]              :plugin:
***** [[http://wiki.ros.org/rqt_gui?distro%3Dindigo][rqt_gui]]

rqt_gui provides the main to start an instance of the ROS integrated
graphical user interface provided by qt_gui.

***** [[http://wiki.ros.org/rqt_gui_cpp?distro%3Dindigo][rqt_gui_cpp]]

rqt_gui_cpp enables GUI plugins to use the C++ client library for ROS.

***** [[http://wiki.ros.org/rqt_gui_py?distro%3Dindigo][rqt_gui_py]]

rqt_gui_py enables GUI plugins to use the Python client library for ROS.

***** [[http://wiki.ros.org/rqt_common_plugins?distro=jade][rqt_common_plugins]] :plugin:rqt_common_plugins:

rqt_common_plugins metapackage provides ROS backend graphical tools
suite that can be used on/off of robot runtime.

****** [#A] [[http://wiki.ros.org/rqt_bag?distro=fuerte][rqt_bag]] :rqt_bag:

rqt_bag is an application for recording and managing bag files.

使用 rqt_bag 需要手动 publish，默认不发布。 右键菜单。

****** [[http://wiki.ros.org/rqt_bag_plugins?distro=fuerte][rqt_bag_plugins]] :rqt_bag_plugins:
****** [[http://wiki.ros.org/rqt_console?distro=fuerte][rqt_console]] :rqt_console:
****** [[http://wiki.ros.org/rqt_dep?distro=fuerte][rqt_dep]]  :rqt_dep:
****** [#A] [[http://wiki.ros.org/rqt_graph?distro=jade][rqt_graph]] :rqt_graph:

rqt_graph provides a GUI plugin for visualizing the ROS computation
graph.

****** [[http://wiki.ros.org/rqt_gui?distro=fuerte][rqt_gui]]  :rqt_gui:
****** [[http://wiki.ros.org/rqt_gui_cpp?distro=fuerte][rqt_gui_cpp]] :rqt_gui_cpp:
****** [[http://wiki.ros.org/rqt_gui_py?distro=fuerte][rqt_gui_py]] :rqt_gui_py:
****** [[http://wiki.ros.org/rqt_image_view?distro=fuerte][rqt_image_view]] :rqt_image_view:
****** [#A] [[http://wiki.ros.org/rqt_launch?distro=jade][rqt_launch]] :rqt_launch:

This rqt plugin ROS package provides easy view of .launch files.

****** [[http://wiki.ros.org/rqt_logger_level?distro=fuerte][rqt_logger_level]] :rqt_logger_level:
****** [[http://wiki.ros.org/rqt_msg?distro=fuerte][rqt_msg]]  :rqt_msg:
****** [[http://wiki.ros.org/rqt_nav_view?distro=fuerte][rqt_nav_view]] :rqt_nav_view:
****** [[http://wiki.ros.org/rqt_param?distro=fuerte][rqt_param]] :rqt_param:
****** [[http://wiki.ros.org/rqt_plot?distro=fuerte][rqt_plot]] :rqt_plot:
****** [[http://wiki.ros.org/rqt_pose_view?distro=fuerte][rqt_pose_view]] :rqt_pose_view:
****** [[http://wiki.ros.org/rqt_pr2_dashboard?distro=fuerte][rqt_pr2_dashboard]] :rqt_pr2_dashboard:
****** [[http://wiki.ros.org/rqt_publisher?distro=fuerte][rqt_publisher]] :rqt_publisher:
****** [[http://wiki.ros.org/rqt_py_common?distro=fuerte][rqt_py_common]] :rqt_py_common:
****** [[http://wiki.ros.org/rqt_py_console?distro=fuerte][rqt_py_console]] :rqt_py_console:
****** [[http://wiki.ros.org/rqt_robot_dashboard?distro=fuerte][rqt_robot_dashboard]] :rqt_robot_dashboard:
****** [[http://wiki.ros.org/rqt_robot_monitor?distro=fuerte][rqt_robot_monitor]] :rqt_robot_monitor:
****** [[http://wiki.ros.org/rqt_robot_steering?distro=fuerte][rqt_robot_steering]] :rqt_robot_steering:
****** [[http://wiki.ros.org/rqt_runtime_monitor?distro=fuerte][rqt_runtime_monitor]] :rqt_runtime_monitor:
****** [[http://wiki.ros.org/rqt_rviz?distro=fuerte][rqt_rviz]] :rqt_rviz:
****** [[http://wiki.ros.org/rqt_service_caller?distro=fuerte][rqt_service_caller]] :rqt_service_caller:
****** [[http://wiki.ros.org/rqt_shell?distro=fuerte][rqt_shell]] :rqt_shell:
****** [[http://wiki.ros.org/rqt_srv?distro=fuerte][rqt_srv]]  :rqt_srv:
****** [[http://wiki.ros.org/rqt_tf_tree?distro=fuerte][rqt_tf_tree]] :rqt_tf_tree:
****** [[http://wiki.ros.org/rqt_topic?distro=fuerte][rqt_topic]] :rqt_topic:
****** [[http://wiki.ros.org/rqt_web?distro=fuerte][rqt_web]]  :rqt_web:

*** [[http://wiki.ros.org/rosemacs][rosemacs]]                                                    :emacs:ide:
**** rosemacs安装

1. 使用 apt-get 方式安装: 需要安装许多额外的软件

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{text}
     将会安装下列额外的软件包：
       emacs emacs24 emacs24-bin-common emacs24-common emacs24-common-non-dfsg
       emacsen-common libm17n-0 libotf0 m17n-contrib m17n-db
     建议安装的软件包：
       emacs24-el m17n-docs
     下列【新】软件包将被安装：
       emacs emacs24 emacs24-bin-common emacs24-common emacs24-common-non-dfsg
       emacsen-common libm17n-0 libotf0 m17n-contrib m17n-db ros-indigo-rosemacs
     \end{minted}
   #+end_latex

2. install from source, 一般不推荐，但在这里可以

   #+begin_latex
   \begin{minted}[frame=leftline, mathescape]{text}

   \end{minted}
   #+end_latex
**** 配置
#+BEGIN_EXAMPLE
  (add-to-list 'load-path "/opt/ros/indigo/share/emacs/site-lisp")
  (require 'rosemacs-config)
  (global-set-key "\C-x\C-r" ros-keymap)
#+END_EXAMPLE

**** shortcuts                                                  :shortcut:

***** navigating the ros file system
+ find-ros-file (C-f)
+ view-ros-file (f)
+ find-ros-message (C-m)
+ view-ros-message (m)
+ find-ros-service (C-s)
+ view-ros-service (s)
+ ros-load-package-locations (r)
+ ros-rgrep-package (g)

***** topic tracking
+ display-ros-topic-info (C-t)

  Display the *ros-topics* buffer, which contains the set of published
  and subscribed topics

+ add-hz-update (h)

  Make rosemacs track the hz rate of the topics matching one or more
  regexps, and display this in the *ros-topics* buffer.

+ remove-hz-update (H)

  Stop tracking topics matching a given regexp.

+ echo-ros-topic (t)

  Echo a ROS topic into a new buffer.

***** node tracking

+ rosemacs/display-nodes (C-n)

  Display current list of ros nodes.

***** running/launching things

+ ros-launch (C-l)

  Start a launch file in an appropriately named buffer. In that
  buffer,

  + k  kills the launch (and the launched processes)
  + r restarts
  + q quits.

+ ros-run (C-r)

  Analogous to ros-launch with the same keybindings.

+ ros-core (C-c)

  Start a core that sends output to the *ros-core* or switch to that
  buffer if a core is already active.

***** ros events

+ rosemacs/display-event-buffer (C-e)

  Display the ros event buffer
**** customizationp
****** ros-completion-function
****** ros-topic-update-interval
****** ros-node-update-interval
**** tagerill
***** pros
- Emacs重度用户
- 不用开启太多的Terminator
***** cons
- 使用命令行更cool
- 也更方便
***** conclusion
- 不使用Emacs作为ROS的IDE
- 但像通过包查找文件目录等功能很实用

** Model
*** [[http://wiki.ros.org/robot_model?distro=jade][robot_model]]                                               :robot_model:
**** [[http://wiki.ros.org/urdf][URDF]]                             :urdf:
***** Tools

1. verfication: *check_urdf* <file>.urdf

2. visualization: *urdf_to_graphiz* <file>.urdf

***** [[http://wiki.ros.org/urdf/XML][XML specification]]           :xml:
****** [[http://wiki.ros.org/urdf/XML/sensor/proposals][sensor/proposals]]
******* attibutes
1. name(required)
2. type(required)
3. id
4. update_rate(HZ)

******* Elements
+ <parent>(required)
  - link(required)
+ <origin>
  - xyz
  - rpy
+ <gazebo>
+ <camera>
+ <ray>
+ <imu>
+ <magneometer>
+ <gps>
+ <contact>
+ <sonar>

****** [[http://wiki.ros.org/urdf/XML/link][link]]: describe the kinemic and dynamic properties of a link :link:

The <link> element describes a rigid body with an inertia,  visual
feature

[[~/Wally/Journal/Figures/scrot/16699xmw.png]]

******* Attribute
+ name(required)

******* Elements
+ <inertial>
  - *origin*: pose of the inertial referece frame,  relative to the
    link reference frame
    - xyz
    - rpy
  - mass
  - *inertia*: 3x3 rotational inertia matrix, represented in the
    inertia frame.Because the rotational inertia matrix is
    *symmetric*, only6 above-diagonal elements of this matrix are
    specified, i.e. ixx, ixy, ixz, iyy, iyz, izz

+ <visual>
  - name
  - <origin>
    - xyz
    - rpy
  - <geometry>
    - <box>
      - size
    - <cylinder>
      - raduis
      - length
    - <sphere>
      - radius
    - <mesh>
      - filename
      - scale
  - <material>
    - name
    - <color>
    - <texture>

+ <collision>
  - name
  - <origin>
    - xyz
    - rpy
  - <geometry>
****** [[http://wiki.ros.org/urdf/XML/joint][joint]]: describe the kinemic and dynamic properties of a joint :joint:

The <joint> element describes the kinemics and dynamics of a joint and
also specifies the safety limits of the joint.

[[~/Wally/Journal/Figures/scrot/16699w6F.png]]

******* attributes
+ name(required)
+ *type* (required)
  - *revolute* - a hinge joint that rotates along the axis and has a
    limited range specified by the upper and lower limits.

  - *continuous* - a continuous hinge joint that rotates around the
    axis and has no upper and lower limits

  - *prismatic* - a sliding joint that slides along the axis, and has
    a limited range specified by the upper and lower limits.

  - *fixed* - This is not really a joint because it cannot move. All
    degrees of freedom are locked. This type of joint does not require
    the axis, calibration, dynamics, limits or safety_controller.

  - *floating* - This joint allows motion for all 6 degrees of
    freedom.

  - *planar* - This joint allows motion in a plane perpendicular to
    the axis.

******* Elements
+ <origin>
  - xyz
  - rpy
+ <parent>(required)
  - link
+ <child>(required)
  - link
+ <axis>: The joint axis specified in the joint frame. This is the
  axis of rotation for revolute joints, the axis of translation for
  prismatic joints, and the surface normal for planar joints. The axis
  is specified in the joint frame of reference. Fixed and floating
  joints do not use the axis field.
  - xyz(required)
+ <calibration>
+ <dynamics>
  - damping
  - friction
+ <limit>
  - lower
  - upper
  - effort(requied)
  - velocity(required)
+ <mimic>：This tag is used to specify that the defined joint mimics
  another existing joint. The value of this joint can be computed as
  value = multiplier * other_joint_value + offset. Expected and
  optional attributes:
  - joint(required)
  - multiplier
  - offset
+ <safety_controller>

****** [[http://wiki.ros.org/urdf/XML/Transmission][transmission]]: Transmissions lin actuators to joints and represent their mechanical coupling :transmission:

The transmission element is an extension to the URDF robot description
model that is used to describe the relationship between an actuator
and a joint. This allows one to model concepts such as gear ratios and
parallel linkages. A transmission transforms efforts/flow variables
such that their product - power - remains constant. Multiple actuators
may be linked to multiple joints through complex transmission.

******* attribute
+ name(required)

******* element
+ <type>
+ <joint>
  - <hardwareinterface> [[http://wiki.ros.org/ros_control#Hardware_Interfaces][hardware interface]]
+ <actuator>
  - <mechanicalReduction>

****** gazebo

****** [[http://wiki.ros.org/urdf/XML/model][model]]: describe the kinematic and dynamic properties of a robot structure

[[~/Wally/Journal/Figures/scrot/16699KPS.png]]

+ <link>
+ <joint>

***** [[http://wiki.ros.org/xacro][xacro]]                        :xacro:

****** intro

Xacro (*XML Macros*) Xacro is an XML macro language. With xacro, you
can construct shorter and more readable XML files by using macros that
expand to larger XML expressions.

****** property

Properties are *named values* that can be inserted(*${PROPERTY}*) anywhere into the
XML document.

#+begin_latex
  \begin{minted}[frame=single, mathescape]{xml}
  <xacro:property name="the_radius" value="2.1" />
  <xacro:property name="the_length" value="4.5" />

  <geometry type="cylinder" radius="${the_radius}" length="${the_length}" />
  \end{minted}
#+end_latex

****** property block

Property blocks are *named snippets* of XML that can be inserted
anywhere that XML is allowed.

*<xacro:insert_block name=BLOCK />*

#+begin_latex
  \begin{minted}[frame=single, mathescape]{xml}
  <xacro:property name="front_left_origin">
    <origin xyz="0.3 0 0" rpy="0 0 0" />
  </xacro:property>

  <pr2_wheel name="front_left_wheel">
    <xacro:insert_block name="front_left_origin" />
  </pr2_wheel>
  \end{minted}
#+end_latex

****** math expression

Within dollared-braces (*${}*), you can also write simple math
expressions. Currently, basic arithmetic and variable substitution is
supported.

#+begin_latex
  \begin{minted}[frame=single, mathescape]{xml}
  <xacro:property name="pi" value="3.1415926535897931" />
  <circle circumference="${2.5 * pi}" />
  \end{minted}
#+end_latex

******* new in Jade                                              :jade:

Since ROS Jade, Xacro employs python to evaluate expressions enclosed
in dollared-braces (${}). This allows for more complex arithmetic
expressions. Also, some basic constants, e.g. pi, are already
predefined:

#+begin_latex
  \begin{minted}[frame=single, mathescape]{xml}
  <xacro:property name="R" value="2" />
  <xacro:property name="alpha" value="${30/180*pi}" />
  <circle circumference="${2 * pi * R}" pos="${sin(alpha)} ${cos(alpha)}" />
  \end{minted}
#+end_latex

****** conditional blocks

Xacro has conditional blocks *similar to roslaunch*.

This is useful for things like configurable robots or loading
different Gazebo plugins.

******* new in jade                                              :jade:

The more powerful evaluation capabilities in ROS Jade allow for much
more complex expression. Virtually *any python expression that
evaluates to a Boolean* is feasible.

#+begin_latex
  \begin{minted}[frame=single, mathescape]{xml}
  <xacro:property name="var" value="useit"/>
  <xacro:if value="${var == 'useit'}"/>
  <xacro:if value="${var.startswith('use') and var.endswith('it')}"/>

  <xacro:property name="allowed" value="[1,2,3]"/>
  <xacro:if value="${1 in allowed}"/>
  \end{minted}
#+end_latex

****** rospack commands

Xacro allows you to use certain rospack commands with
dollared-parentheses (*$()*).

#+begin_latex
  \begin{minted}[frame=single, mathescape]{xml}
  <foo value="$(find xacro)" />
  <foo value="$(arg myvar)" />
  \end{minted}
#+end_latex

Xacro currently supports all the rospack commands that roslaunch
supports using *substitution args*. Arguments need to be specified on
the command line using the *myvar:=true syntax.*

****** default arg

Since ROS Indigo, it is also possible to define defaults like so:
#+begin_latex
\begin{minted}[frame=single, mathescape]{xml}
<xacro:arg name="myvar" default="false"/>
\end{minted}
#+end_latex

Using this you can run xacro like:
#+begin_latex
\begin{minted}[frame=single, mathescape]{xml}
<param name="robot_description" command="$(find xacro)/xacro.py $(arg model) myvar:=true" />
\end{minted}
#+end_latex

****** Macros

The *main feature* of xacro is its support for macros. Define macros
with the macro tag, and specify the macro name and the list of
parameters. The list of parameters should be whitespace
separated. They become macro-local properties.

*<xacro:macro name="NAME" params="...">*

****** including files
 *<xacro:include filename="FILE" />*

 #+begin_latex
   \begin{minted}[frame=single, mathescape]{xml}
   <xacro:include filename="$(find package)/other_file.xacro" />
   <xacro:include filename="other_file.xacro" />
   <xacro:include filename="$(cwd)/other_file.xacro" />
   \end{minted}
 #+end_latex

****** YAML support                                               :jade:
new in jade

****** building from CMakeLists.txt                         :cmakelists:

****** Elements and Attributes

***** [[http://wiki.ros.org/urdf/Tutorials][tutorials]]        :tutorial:

****** learning URDF

******* [[http://wiki.ros.org/urdf/Tutorials/Create%2520your%2520own%2520urdf%2520file][Create your own urdf file]]

In this tutorial you start creating your own urdf robot description
file.

******* [[http://wiki.ros.org/urdf/Tutorials/Parse%2520a%2520urdf%2520file][Parse a urdf file]]

This tutorial teaches you how to use the urdf parser

******* [[http://wiki.ros.org/robot_state_publisher/Tutorials/Using%2520the%2520robot%2520state%2520publisher%2520on%2520your%2520own%2520robot][Using the robot state publisher on your own robot]]

This tutorial explains how you can publish the state of your robot to
tf, using the robot state publisher.

******* [[http://wiki.ros.org/kdl_parser/Tutorials/Start%2520using%2520the%2520KDL%2520parser][Start using the KDL parser]]

This tutorial teaches you how to create a KDL Tree from a [[http://wiki.ros.org/urdf/XML][URDF]] file

******* [[http://wiki.ros.org/urdf/Tutorials/Using%2520urdf%2520with%2520robot_state_publisher][Using urdf with robot_state_publisher]]

This tutorial gives a full example of a robot model with URDF that
uses robot_state_publisher. First, we create the URDF model with all
the necessary parts. Then we write a node which publishes the
JointState and transforms. Finally, we run all the parts together.

****** Learning URDF Step by Step

******* [[http://wiki.ros.org/urdf/Tutorials/Building%2520a%2520Visual%2520Robot%2520Model%2520with%2520URDF%2520from%2520Scratch][Building a Visual Robot Model with URDF from Scratch]]

Learn how to build a visual model of a robot that you can view in Rviz

******* [[http://wiki.ros.org/urdf/Tutorials/Building%2520a%2520Movable%2520Robot%2520Model%2520with%2520URDF][Building a Movable Robot Model with URDF]]

Learn how to define movable joints in URDF

******* [[http://wiki.ros.org/urdf/Tutorials/Adding%2520Physical%2520and%2520Collision%2520Properties%2520to%2520a%2520URDF%2520Model][Adding Physical and Collision Properties to a URDF Model]]

Learn how to add collision and inertial properties to links, and how
to add joint dynamics to joints.

******* [[http://wiki.ros.org/urdf/Tutorials/Using%2520Xacro%2520to%2520Clean%2520Up%2520a%2520URDF%2520File][Using Xacro to Clean Up a URDF File]]

Learn some tricks to reduce the amount of code in a URDF file using
Xacro

****** Explaining a complete URDF file

******* [[http://wiki.ros.org/urdf/Tutorials/UnderstandingPR2URDF][Understanding the PR2 Robot Description]]

This tutorial explains the layout of the top level URDF Xacro file for a complex robot such as PR2.

**** [[http://wiki.ros.org/joint_state_publisher][joint_state_publisher]]
**** [[http://wiki.ros.org/robot_state_publisher][robot_state_publisher]]

** Navigation
*** [[http://wiki.ros.org/navigation][navigation]]                                                 :navigation:

**** navigation
***** pkgs
+ *amcl*
+ base_local_planner
+ carrot_planner
+ clear_costmap_recovery
+ costmap_2d
+ dwa_local_planner
+ fake_localization
+ global_planner
+ *map_server*
+ *move_base*
+ move_base_msgs
+ move_slow_and_clear
+ nav_core
+ navfn
+ robot_pose_ekf
+ rotate_recovery
+ voxel_grid

***** intro

A *2D navigation* stack that takes in information from odometry,
sensor streams, and a goal pose and outputs safe velocity commands
that are sent to a mobile base.

即接收传感器数据和目标位置，输出命令。

[[~/Wally/Journal/Figure/scrot/30792qpM.png]]

***** installation

可能需要研究一些算法，所以源码安装。 /失败/

#+BEGIN_EXAMPLE
  /usr/local/lib/libgtest.a(gtest-all.cc.o)：在函数‘llvm::raw_ostream::raw_ostream(bool)’中：
  gtest-all.cc:(.text._ZN4llvm11raw_ostreamC2Eb[_ZN4llvm11raw_ostreamC5Eb]+0x1c)：对‘vtable for llvm::raw_ostream’未定义的引用
#+END_EXAMPLE

不折腾，将源码移至 *~/catkin_ws/SRC* 文件下

=重装系统后再次编译=

#+BEGIN_EXAMPLE
No package 'orocos-bfl' found
CMake Error at /usr/local/share/cmake-3.4/Modules/FindPkgConfig.cmake:362 (message):
#+END_EXAMPLE

[[*%5B%5Bhttp://wiki.ros.org/bfl%5D%5Bbfl%5D%5D][bfl]]

#+BEGIN_EXAMPLE
  fatal error: SDL/SDL_image.h: 没有那个文件或目录
   #include <SDL/SDL_image.h>
#+END_EXAMPLE

http://stackoverflow.com/questions/6843572/sdl-sdl-image-h-no-such-file-or-directory

http://answers.ros.org/question/68896/sdl-image-error-while-building-gmapping/

#+BEGIN_EXAMPLE
  I had the same issue when building the navigation stack,
  you can use the Synaptic to install not only the package libsdl-image but also the libsdl-image-dev!
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  fatal error: move_base_msgs/MoveBaseAction.h: 没有那个文件或目录
   #include <move_base_msgs/MoveBaseAction.h>
#+END_EXAMPLE

使用 apt-get 安装 move_base_msgs 解决，但问题是 move_base_msgs 本身是
navigation 的一部分。。。

#+BEGIN_EXAMPLE
 $ sudo apt-get install ros-jade-move-base-msgs
#+END_EXAMPLE

编译成功。


**** [[http://wiki.ros.org/navigation/Tutorials][tutorials]]    :tutorial:

**** [[http://wiki.ros.org/move_base?distro=jade][move_base]]  :move_base:

***** intro

[[~/Wally/Journal/Figures/Prime/overview_tf_2015-11-27_14:04:17.png]]

The move_base package provides an implementation of an action (see
the actionlib package) that, *given a goal in the world, will attempt
to reach it with a mobile base.* The move_base node links together a
global and local planner to accomplish its global navigation task.

***** API                                                           :api:
****** topics

1. Subscribed Topics

   + *move_base/goal* (move_base_msgs/MoveBaseActionGoal)

     A goal for move_base to pursue in the world.

   + *move_base/cancel* (actionlib_msgs/GoalID)

     A request to cancel a specific goal.

2. Action Published Topics

   + *move_base/feedback* (move_base_msgs/MoveBaseActionFeedback)

     Feedback contains the current position of the base in the world.

   + *move_base/status* (actionlib_msgs/GoalStatusArray)

     Provides status information on the goals that are sent to the move_base action.

   + *move_base/result* (move_base_msgs/MoveBaseActionResult)

     Result is empty for the move_base action.

****** parameters

**** [[http://wiki.ros.org/costmap_2d][costmap_2d]]                  :map:

**** [[http://wiki.ros.org/base_local_planner][base_local_planner]]

**** [[http://wiki.ros.org/map_server][map_server]]                  :map:

- http://wiki.ros.org/map_server

***** Package Summary

map_server provides the =map_server= ROS
[[http://www.ros.org/wiki/Nodes][Node]], which offers map data as a ROS
[[http://www.ros.org/wiki/Services][Service]]. It also provides the
=map_saver= command-line utility, which allows dynamically generated
maps to be saved to file.

***** Map format

Maps manipulated by the tools in this package are stored in a pair of
files. The YAML file describes the map meta-data, and names the image
file. The image file encodes the occupancy data.

****** Image format

The image describes the occupancy state of each cell of the world in the
color of the corresponding pixel. Whiter pixels are free, blacker pixels
are occupied, and pixels in between are unknown. Color and grayscale
images are accepted, but most maps are gray (even though they may be
stored as if in color). Thresholds in the YAML file are used to divide
the three categories; thresholding is done inside the =map_server=.

When comparing to the threshold parameters, the occupancy probability of
an image pixel is computed as follows:

#+BEGIN_EXAMPLE
  occ=(255-color_avg)/255.0
#+END_EXAMPLE

where color_avg is the 8-bit value
that results from averaging over all channels, e.g. if the image is
24-bit color, a pixel with the color =0x0a0a0a= has a probability of
0.96, which is very occupied. The color =0xeeeeee= yields 0.07, which is
very unoccupied.

When communicated via ROS messages, occupancy is represented as an
integer in the range [0,100], with 0 meaning completely free and 100
meaning completely occupied, and the special value -1 for completely
unknown.

Image data is read in via [[http://www.libsdl.org/projects/SDL_image/docs/index.html][SDL_Image]];
supported formats vary, depending on what SDL_Image provides on a
specific platform. Generally speaking, most popular image formats are
widely supported. A notable exception is that PNG is not supported on OS
X.

****** YAML format

The YAML format is best explained with a simple, complete example:

#+BEGIN_EXAMPLE
    image: testmap.png
    resolution: 0.1
    origin: [0.0, 0.0, 0.0]
    occupied_thresh: 0.65
    free_thresh: 0.196
    negate: 0
#+END_EXAMPLE

Required fields:

-  *image* : Path to the image file containing the occupancy data; can
   be absolute, or relative to the location of the YAML file
-  *resolution* : Resolution of the map, meters / pixel
-  *origin* : The 2-D pose of the lower-left pixel in the map, as (x, y,
   yaw), with yaw as counterclockwise rotation (yaw=0 means no
   rotation). Many parts of the system currently ignore yaw.
-  *occupied_thresh* : Pixels with occupancy probability greater than
   this threshold are considered completely occupied.
-  *free_thresh* : Pixels with occupancy probability less than this
   threshold are considered completely free.
-  *negate* : Whether the white/black free/occupied semantics should be
   reversed (interpretation of thresholds is unaffected)

***** Command-line Tools

****** map_server

=map_server= is a ROS node that reads a map from disk and offers it via
a ROS service.
The current implementation of the map_server converts color values in
the map image data into ternary occupancy values: free (0), occupied
(100), and unknown (-1). Future versions of this tool may use the values
between 0 and 100 to communicate finer gradations of occupancy.

******* Usage

#+BEGIN_EXAMPLE
    map_server <map.yaml>
#+END_EXAMPLE

******* Example

#+BEGIN_EXAMPLE
    rosrun map_server map_server mymap.yaml
#+END_EXAMPLE

Note that the map data may be retrieved via either latched topic
(meaning that it is sent once to each new subscriber), or via service.
The service may eventually be phased out.

******* Published Topics

=map_metadata=
([[http://docs.ros.org/api/nav_msgs/html/msg/MapMetaData.html][nav_msgs/MapMetaData]])

-  Receive the map metadata via this latched topic.

=map=
([[http://docs.ros.org/api/nav_msgs/html/msg/OccupancyGrid.html][nav_msgs/OccupancyGrid]])

-  Receive the map via this latched topic.

******* Services

=static_map=
([[http://docs.ros.org/api/nav_msgs/html/srv/GetMap.html][nav_msgs/GetMap]])

-  Retrieve the map via this service.

******* Parameters

=~frame_id= (=string=, default: ="map"=)

-  The frame to set in the header of the published map.

****** map_saver

=map_saver= saves a map to disk, e.g., from a SLAM mapping service.

******* Usage

#+BEGIN_EXAMPLE
    map_saver [-f mapname]
#+END_EXAMPLE

=map_saver= retrieves map data and writes it out to *map.pgm* and
*map.yaml*. Use the *-f* option to provide a different base name for the
output files.

******* Example

#+BEGIN_EXAMPLE
    rosrun map_server map_saver -f mymap
#+END_EXAMPLE

******* Subscribed Topics

=map=
([[http://docs.ros.org/api/nav_msgs/html/msg/OccupancyGrid.html][nav_msgs/OccupancyGrid]])

-  Map will be retrieved via this latched topic.


**** [[http://wiki.ros.org/dwa_local_planner][dwa_local_planner]]

**** [[http://wiki.ros.org/robot_pose_ekf][robot_pose_ekf]]          :ekf:

**** [[http://wiki.ros.org/amcl][amcl]]                             :amcl:

** SLAM
*** Hector                                                         :hector:
**** [[http://wiki.ros.org/hector_slam][hectorslam]]    :slam:hector_slam:
***** [[http://wiki.ros.org/hector_slam/Tutorials/SettingUpForYourRobot][Set up your robot]]



****** Overview

[[/hector_slam][hector_slam]] uses the
[[/hector_mapping][hector_mapping]] node for learning a map of the
environment and simultaneously estimating the platform's 2D pose at
laser scanner frame rate. The frame names and options for
[[/hector_mapping][hector_mapping]] have to be set correctly. This
tutorial explains the different options. The image below shows all
potential frames of interest in a simplified 2D view of a robot
travelling through rough terrain, leading to roll and pitch motion of
the platform:

[[/home/ben/Wally/Journal//Figure/scrot/477297r.png]]

The general relationship between the map, odom and base_link frames is
already described in [[http://www.ros.org/reps/rep-0105.html][Coordinate
Frames for Mobile Platforms]]. We use two frames in between odom and
base_link: The base_footprint frame provides no height information and
represents the 2D pose of the robot (position and orientation). The
base_stabilized frame adds information about the robot height relative
to the map/odom layer. The base_link frame is rigidly attached to the
robot and adds the roll and pitch angles compared to the
base_stabilized frame. For this transformation, a system for estimation
of the vehicle attitude like a AHRS or INS can be used (can be realized
using the [[/hector_imu_attitude_to_tf][hector_imu_attitude_to_tf]]
node for example). For a platform not exhibiting roll/pitch motion, the
base_stabilized and base_link frames are equal. The transformation
from base_link to laser_link is typically provided by a
[[/tf#static_transform_publisher][static transform publisher]] or the
[[/robot_state_publisher][robot state publisher]].

****** Setup

We assume that the reader has a basic understanding of ROS parameters
and launch files for the following section. The
[[/hector_slam_launch][hector_slam_launch]] package contains some
launch files that might serve as examples.

******* Use in place of gmapping

[[/gmapping][gmapping]] publishes the map->odom transform. You have to
set the following parameters of [[/hector_mapping][hector_mapping]] to
reflect the setup on your platform:

#+BEGIN_EXAMPLE
        <param name="pub_map_odom_transform" value="true"/>
        <param name="map_frame" value="map" />
        <param name="base_frame" value="base_frame" />
        <param name="odom_frame" value="odom" />
#+END_EXAMPLE

If your platform exhibits roll/pitch motion you have to set the
base_frame so it has the properties of the base_stabilized frame
described in the Overview section above.

******* Use without odom frame

If you do not require the use of a odom frame (for example because your
platform does not provide any usable odometry) you can directly publish
a transformation from map to base_link:

#+BEGIN_EXAMPLE
        <param name="pub_map_odom_transform" value="true"/>
        <param name="map_frame" value="map" />
        <param name="base_frame" value="base_frame" />
        <param name="odom_frame" value="base_frame" />
#+END_EXAMPLE

******* Use without Broadcasting of transformations

The system can also be used without broadcasting any tf transformation.
This can be useful if another node is responsible for publishing the
map->odom or map->base_frame transform. This can be done by setting:
***** [[http://wiki.ros.org/hector_slam/Tutorials/MappingUsingLoggedData][Mapping using logged data]]
***** [[http://wiki.ros.org/hector_mapping][hector_mapping]] :hector_mapping:

hector_mapping is a SLAM approach that can be used without odometry as
well as on platforms that exhibit roll/pitch motion (of the sensor, the
platform or both). It leverages the high update rate of modern LIDAR
systems like the Hokuyo UTM-30LX and provides 2D pose estimates at scan
rate of the sensors (40Hz for the UTM-30LX). While the system does not
provide explicit loop closing ability, it is sufficiently accurate for
many real world scenarios. The system has successfully been used on
Unmanned Ground Robots, Unmanned Surface Vehicles, Handheld Mapping
Devices and logged data from quadrotor UAVs.



****** Overview

An example video can be seen here:

Further video examples are available in this playlist:
[[http://www.youtube.com/playlist?list=PL0E462904E5D35E29]]

Details can also be found in this paper:

#+BEGIN_EXAMPLE
    @INPROCEEDINGS{KohlbrecherMeyerStrykKlingaufFlexibleSlamSystem2011,
      author = {S. Kohlbrecher and J. Meyer and O. von Stryk and U. Klingauf},
      title = {A Flexible and Scalable SLAM System with Full 3D Motion Estimation},
      year = {2011},
      month = {November},
      booktitle = {Proc. IEEE International Symposium on Safety, Security and Rescue Robotics (SSRR)},
      organization = {IEEE},
    }
#+END_EXAMPLE

available
[[http://www.sim.tu-darmstadt.de/publ/download/2011_SSRR_KohlbrecherMeyerStrykKlingauf_Flexible_SLAM_System.pdf][here]]
.

****** Hardware Requirements

To use =hector_mapping=, you need a source of
[[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]]
data (for example a Hokuyo UTM-30LX LIDAR or bagfiles). The node uses
[[/tf][tf]] for transformation of scan data, so the LIDAR does not have
to be fixed related to the specified base frame. Odometry data is not
needed.

****** ROS API

******* hector_mapping

=hector_mapping= is a node for LIDAR based SLAM with no odometry and low
computational resources. For simplicity, the ROS API detailed below
provides information about the commonly used options from a user
perspective, but not all options that are available for debugging
purposes.
******** Subscribed Topics

=scan=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  The laser scan used by the SLAM system.

=syscommand=
([[http://docs.ros.org/api/std_msgs/html/msg/String.html][std_msgs/String]])

-  System command. If the string equals "reset" the map and robot pose
   are reset to their inital state.

******** Published Topics

=map_metadata=
([[http://docs.ros.org/api/nav_msgs/html/msg/MapMetaData.html][nav_msgs/MapMetaData]])

-  Get the map data from this topic, which is latched, and updated
   periodically.

=map=
([[http://docs.ros.org/api/nav_msgs/html/msg/OccupancyGrid.html][nav_msgs/OccupancyGrid]])

-  Get the map data from this topic, which is latched, and updated
   periodically

=slam_out_pose=
([[http://docs.ros.org/api/geometry_msgs/html/msg/PoseStamped.html][geometry_msgs/PoseStamped]])

-  The estimated robot pose without covariance

=poseupdate=
([[http://docs.ros.org/api/geometry_msgs/html/msg/PoseWithCovarianceStamped.html][geometry_msgs/PoseWithCovarianceStamped]])

-  The estimated robot pose with an gaussian estimate of uncertainty

******** Services

=dynamic_map=
([[http://docs.ros.org/api/nav_msgs/html/srv/GetMap.html][nav_msgs/GetMap]])

-  Call this service to get the map data

******** Parameters

=~base_frame= (=string=, default: base_link)

-  The name of the base frame of the robot. This is the frame used for
   localization and for transformation of laser scan data.

=~map_frame= (=string=, default: map_link)

-  The name of the map frame.

=~odom_frame= (=string=, default: odom)

-  The name of the odom frame.

=~map_resolution= (=double=, default: 0.025)

-  The map resolution [m]. This is the length of a grid cell edge.

=~map_size= (=int=, default: 1024)

-  The size [number of cells per axis] of the map. The map is square and
   has (map_size * map_size) grid cells.

=~map_start_x= (=double=, default: 0.5)

-  Location of the origin [0.0, 1.0] of the /map frame on the x axis
   relative to the grid map. 0.5 is in the middle.

=~map_start_y= (=double=, default: 0.5)

-  Location of the origin [0.0, 1.0] of the /map frame on the y axis
   relative to the grid map. 0.5 is in the middle.

=~map_update_distance_thresh= (=double=, default: 0.4)

-  Threshold for performing map updates [m]. The platform has to travel
   this far in meters or experience an angular change as described by
   the map_update_angle_thresh parameter since the last update before
   a map update happens.

=~map_update_angle_thresh= (=double=, default: 0.9)

-  Threshold for performing map updates [rad]. The platform has to
   experience an angular change as described by this parameter of travel
   as far as specified by the map_update_distance_thresh parameter
   since the last update before a map update happens.

=~map_pub_period= (=double=, default: 2.0)

-  The map publish period [s].

=~map_multi_res_levels= (=int=, default: 3)

-  The number of map multi-resolution grid levels.

=~update_factor_free= (=double=, default: 0.4)

-  The map update modifier for updates of free cells in the range [0.0,
   1.0]. A value of 0.5 means no change.

=~update_factor_occupied= (=double=, default: 0.9)

-  The map update modifier for updates of occupied cells in the range
   [0.0, 1.0]. A value of 0.5 means no change.

=~laser_min_dist= (=double=, default: 0.4)

-  The minimum distance [m] for laser scan endpoints to be used by the
   system. Scan endpoints closer than this value are ignored.

=~laser_max_dist= (=double=, default: 30.0)

-  The maximum distance [m] for laser scan endpoints to be used by the
   system. Scan endpoints farther away than this value are ignored.

=~laser_z_min_value= (=double=, default: -1.0)

-  The minimum height [m] relative to the laser scanner frame for laser
   scan endpoints to be used by the system. Scan endpoints lower than
   this value are ignored.

=~laser_z_max_value= (=double=, default: 1.0)

-  The maximum height [m] relative to the laser scanner frame for laser
   scan endpoints to be used by the system. Scan endpoints higher than
   this value are ignored.

=~pub_map_odom_transform= (=bool=, default: true)

-  Determine if the map->odom transform should be published by the
   system.

=~output_timing= (=bool=, default: false)

-  Output timing information for processing of every laser scan via
   ROS_INFO.

=~scan_subscriber_queue_size= (=int=, default: 5)

-  The queue size of the scan subscriber. This should be set to high
   values (for example 50) if logfiles are played back to
   hector_mapping at faster than realtime speeds.

=~pub_map_scanmatch_transform= (=bool=, default: true)

-  Determines if the scanmatcher to map transform should be published to
   tf. The frame name is determined by the
   'tf_map_scanmatch_transform_frame_name' parameter.

=~tf_map_scanmatch_transform_frame_name= (=string=, default:
scanmatcher_frame)

-  The frame name when publishing the scanmatcher to map transform as
   described in the preceding parameter.

******** Required tf Transforms

=<the frame attached to incoming scans>= → =base_frame=

-  usually a fixed value, broadcast periodically by a
   [[/robot_state_publisher][robot_state_publisher]], or a =tf=
   [[/tf#static_transform_publisher][static_transform_publisher]].

******** Provided tf Transforms

=map= → =odom=

-  the current estimate of the robot's pose within the map frame (only
   provided if parameter "pub_map_odom_transform" is true).

***** [[http://wiki.ros.org/hector_trajectory_server][hector_trajectory_server]]

hector_trajectory_server keeps track of tf trajectories extracted from
tf data and makes this data accessible via a service and topic.

****** Documentation

This package provides a node that saves [[/tf][tf]] based trajectory
data given a target and and source frame. The trajectory is saved
internally as a
[[http://docs.ros.org/api/nav_msgs/html/msg/Path.html][nav_msgs/Path]]
and can be obtained using a service or topic. Internally, a
tf::Transformlistener listens to [[/tf][tf]], performs the necessary
transformations and pushes resulting poses to the saved trajectory. The
update and publish rates can be modified by parameters as described
below.

****** hector_trajectory_server

=hector_trajectory_server= is a node that saves trajectory data and
makes it available using the ROS API described below.

******* Subscribed Topics

=syscommand=
([[http://docs.ros.org/api/std_msgs/html/msg/String.html][std_msgs/String]])

-  System command. If the string equals "reset" the saved trajectory is
   cleared.

******* Published Topics

=trajectory=
([[http://docs.ros.org/api/nav_msgs/html/msg/Path.html][nav_msgs/Path]])

-  Get the traveled trajectory from this latched topic.

******* Services

=trajectory=
([[http://docs.ros.org/api/hector_nav_msgs/html/srv/GetRobotTrajectory.html][hector_nav_msgs/GetRobotTrajectory]])

-  Call this service to get the traveled trajectory.

******* Parameters

=~target_frame_name= (=string=, default: ="map"=)

-  The name of the [[/tf][tf]] target frame

=~source_frame_name= (=string=, default: ="base_link"=)

-  The name of the [[/tf][tf]] source frame

=~trajectory_update_rate= (=double=, default: 4.0)

-  The update rate [hz] for the saved trajectory

=~trajectory_publish_rate= (=double=, default: 0.25)

-  The publish rate [hz] for the trajectory published on the
   "trajectory" topic.

***** [[http://wiki.ros.org/hector_geotiff][hector_geotiff]]
***** hectorslam octomap
+ https://www.youtube.com/watch?v=JwbZegYgxzc
+
  https://code.google.com/p/rescue-ros-pkg/wiki/TestingCoverageOctomapsUsingLogfiles

**** [[http://wiki.ros.org/hector_localization][hector_localization]]
**** [[http://wiki.ros.org/hector_gazebo][hector_gazebo]]         :gazebo:

***** [[http://wiki.ros.org/hector_gazebo_plugins][hector_gazebo_plugins]]

****** hector_gazebo_plugins

******* Overview of Gazebo Plugins

******** what?
1. A C++ standard class
2. A shared library

******** what for?
Access to all the functionality of Gazebo

******** Advantages
+ full control cover almost every aspect
+ self-contained
+ dynamically loaded

******** Types
1. World
2. Model
3. Sensor
4. System
5. Visual

******** plugin类的基本结构
e.g. hello_world.cc
#+begin_latex
  \begin{cpp}
  #include <gazebo/gazebo.hh>

  namespace gazebo
  {
    class WorldPluginTutorial : public worldplugin
    {
      public: WorldPluginTutorial() : WorldPlugin()
              {
                printf("Hello World!\n");
              }

      public: void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf)
              {
              }
    };
    GZ_REGISTER_WORLD_PLUGIN(WorldPluginTutorial)
  }
  \end{cpp}
#+end_latex

1. 头文件:
   #+begin_latex
   \begin{cpp}
   #include <gazebo/gazebo.hh>
   \end{cpp}
   #+end_latex

   1) *<gazebo/gazebo.hh>*  include a core set of basic gazebo funtions
   2) <gazebo/physics/physics.hh>
   3) <gazebo/rendering/rendering.hh>

2. 命名空间
   #+begin_latex
   \begin{cpp}
   namespace gazebo{

   }
   \end{cpp}
   #+end_latex

   *All plugins must be in the /gazebo/ namespace*

3. 继承
   #+begin_latex
   \begin{cpp}
   class WorldPluginTutorial : public worldplugin
   \end{cpp}
   #+end_latex

   *Each plugin must /inherit/ from a plugin type*
   1) WorldPlugin
   2) ModelPlugin
   3) SensorPlugin

4. 成员函数
   #+begin_latex
   \begin{cpp}
   public: void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf){}
   \end{cpp}
   #+end_latex
   */Load/ is the only mandatory function*,  which receive an SDF
   element that contains teh elements and attributes specified in
   loaded SDF file.

5. 宏
   #+begin_latex
   \begin{cpp}
   GZ_REGISTER_WORLD_PLUGIN(WorldPluginTutorial)
   \end{cpp}
   #+end_latex

   The plugin must be *registered with the simulator* using the
   *type-specific macro*. The only parameter of the macro is the /name/
   of the plugin class.

   1) GZ_REGISTER_WORLD_PLUGIN
   2) GZ_REGISTER_MODEL_PLUGIN
   3) GZ_REGISTER_SENSOR_PLUGIN
   4) GZ_REGISTER_SYSTEM_PLUGIN
   5) GZ_REGISTER_VISUAL_PLUGIN

******** CMakelists.txt
#+BEGIN_EXAMPLE
cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

find_package(gazebo REQUIRED)
include_directories(${GAZEBO_INCLUDE_DIRS})
link_directories(${GAZEBO_LIBRARY_DIRS})
list(APPEND CMAKE_CXX_FLAGS "${GAZEBO_CXX_FLAGS}")  # required for gazebo6

add_library(hello_world SHARED hello_world.cc)
target_link_libraries(hello_world ${GAZEBO_LIBRARIES})
#+END_EXAMPLE

编译结果： 生成 ./build/libhello_world.so 库文件

******** Using  a plugin

********* add path to environment *GAZEBO_PLUGIN_PATH*
#+BEGIN_EXAMPLE
$ export GAZEBO_PLUGIN_PATH=${GAZEBO_PLUGIN_PATH}:/path/to/lib
#+END_EXAMPLE

********* attatch the plugin to a world or model in an SDF file
#+begin_latex
\begin{xml}
<?xml version="1.0"?>
<sdf version="1.4">
  <world name="default">
    <plugin name="hello_world" filename="libhello_world.so"/>
  </world>
</sdf>
\end{xml}
#+end_latex

******** Model plugin
#+begin_latex
  \begin{cpp}
  namespace gazebo
  {
    class ModelPush : public ModelPlugin
    {
      public: void Load(physics::ModelPtr _parent, sdf::ElementPtr /*_sdf*/)
      {
        // Store the pointer to the model
        this->model = _parent;

        // Listen to the update event. This event is broadcast every
        // simulation iteration.
        this->updateConnection = event::Events::ConnectWorldUpdateBegin(
            boost::bind(&ModelPush::OnUpdate, this, _1));
      }

      // Called by the world update start event
      public: void OnUpdate(const common::UpdateInfo & /*_info*/)
      {
        // Apply a small linear velocity to the model.
        this->model->SetLinearVel(math::Vector3(.03, 0, 0));
      }

      // Pointer to the model
      private: physics::ModelPtr model;

      // Pointer to the update event connection
      private: event::ConnectionPtr updateConnection;
    };

    // Register this plugin with the simulator
    GZ_REGISTER_MODEL_PLUGIN(ModelPush)
  }
  \end{cpp}
#+end_latex
******* 6wd differential drive plugin
******** 分析
1. 需求与功能分析
   + 以目标为导向
   + 要精简，一句话定义，之后再去分析与综合

2. 功能：
   *a controller for 6-wheeled light-weight robot using differential
   drive*

3. 分解
   1) controller?
      + who?
        - ros
        - gazebo
      + how
        - publish: geometry_msgs/Twist
        - subcribe: nav_msgs/Odometry

   2) 6-wheeled -> parameters?

   3) differential drive -> model?

******** 包含头文件
********* h文件
#+begin_latex
\begin{cpp}
#include <map>

#include <gazebo/common/Plugin.hh>
#include <gazebo/common/Time.hh>

// ROS
#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include <tf/transform_listener.h>
#include <geometry_msgs/Twist.h>
#include <nav_msgs/Odometry.h>

// Custom Callback Queue
#include <ros/callback_queue.h>
#include <ros/advertise_options.h>

// Boost
#include <boost/thread.hpp>
#include <boost/bind.hpp>

\end{cpp}
#+end_latex

********* cpp文件
#+begin_latex
\begin{cpp}
#include <algorithm>
#include <assert.h>

#include <hector_gazebo_plugins/diffdrive_plugin_6w.h>
#include <gazebo/common/Events.hh>
#include <gazebo/physics/physics.hh>

#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include <tf/transform_listener.h>
#include <geometry_msgs/Twist.h>
#include <nav_msgs/Odometry.h>
#include <boost/bind.hpp>
\end{cpp}
#+end_latex

********* 分析
头文件中只包含类定义需要的其它头文件，在实现中需要的其它头文件只需在
cpp文件中包含即可。
******** 构造与析构
#+begin_latex
\begin{cpp}
  DiffDrivePlugin6W();
  virtual ~DiffDrivePlugin6W();
\end{cpp}
#+end_latex



******* IMU sensor plugin
******* earch magnetic field plugin
******* GPS sensor plugin
******* sonar ranger plugin

****** 6wd differential drive plugin
******* 分析
1. 需求与功能分析
   + 以目标为导向
   + 要精简，一句话定义，之后再去分析与综合

2. 功能：
   *a controller for 6-wheeled light-weight robot using differential
   drive*

3. 分解
   1) controller?
      + who?
        - ros
        - gazebo
      + how
        - publish: geometry_msgs/Twist
        - subcribe: nav_msgs/Odometry

   2) 6-wheeled -> parameters?

   3) differential drive -> model?

******* 包含头文件
******** h文件
#+begin_latex
\begin{cpp}
#include <map>

#include <gazebo/common/Plugin.hh>
#include <gazebo/common/Time.hh>

// ROS
#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include <tf/transform_listener.h>
#include <geometry_msgs/Twist.h>
#include <nav_msgs/Odometry.h>

// Custom Callback Queue
#include <ros/callback_queue.h>
#include <ros/advertise_options.h>

// Boost
#include <boost/thread.hpp>
#include <boost/bind.hpp>

\end{cpp}
#+end_latex

******** cpp文件
#+begin_latex
\begin{cpp}
#include <algorithm>
#include <assert.h>

#include <hector_gazebo_plugins/diffdrive_plugin_6w.h>
#include <gazebo/common/Events.hh>
#include <gazebo/physics/physics.hh>

#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include <tf/transform_listener.h>
#include <geometry_msgs/Twist.h>
#include <nav_msgs/Odometry.h>
#include <boost/bind.hpp>
\end{cpp}
#+end_latex

******** 分析
头文件中只包含类定义需要的其它头文件，在实现中需要的其它头文件只需在
cpp文件中包含即可。

******* 属性
******* 构造与析构
#+begin_latex
\begin{cpp}
  DiffDrivePlugin6W();
  virtual ~DiffDrivePlugin6W();
\end{cpp}
#+end_latex
******** 析构
#+begin_latex
\begin{cpp}
DiffDrivePlugin6W::~DiffDrivePlugin6W()
{
  event::Events::DisconnectWorldUpdateBegin(updateConnection);
  delete transform_broadcaster_;
  rosnode_->shutdown();
  callback_queue_thread_.join();
  delete rosnode_;
}

\end{cpp}
#+end_latex

1.
******* 继承函数
******** load

******* gazebo_ros_utils.h
******** namespace: gazebo

******** GazeboRos : class

********* attributes
#+begin_latex
\begin{minted}{cpp}
private:
    sdf::ElementPtr sdf_;       /// sdf to read
    std::string plugin_;        /// name of the plugin class
    std::string namespace_;     /// name of the launched node
    boost::shared_ptr<ros::NodeHandle> rosnode_; /// rosnode
    std::string tf_prefix_;     /// prefix for the ros tf plublisher if not set it uses the namespace_
    std::string info_text;      /// info text for log messages to identify the node
\end{minted}
#+end_latex

********* constructor
#+begin_latex
  \begin{minted}{cpp}
      GazeboRos ( physics::ModelPtr &_parent, sdf::ElementPtr _sdf, const std::string &_plugin )
          : sdf_ ( _sdf ), plugin_ ( _plugin ) {
          namespace_ = _parent->GetName ();
          if ( !sdf_->HasElement ( "robotNamespace" ) ) {
              ROS_INFO ( "%s missing <robotNamespace>, defaults is %s", plugin_.c_str(), namespace_.c_str() );
          }  else {
              namespace_ = sdf_->GetElement ( "robotNamespace" )->Get<std::string>();
              if ( namespace_.empty() ) {
                  namespace_ = _parent->GetName();
              }
          }
          if ( !namespace_.empty() )
              this->namespace_ += "/";
          rosnode_ = boost::shared_ptr<ros::NodeHandle> ( new ros::NodeHandle ( namespace_ ) );
          info_text = plugin_ + "(ns = " + namespace_ + ")";
          readCommonParameter ();
      }
  \end{minted}
#+end_latex

1. 初始化成员列表

2. 获取robotNamespace(for ROS)
   1) sdf->GetElement("robotNamespace")->Get<std::string>()
   2) parent->GetName()
   3) /

3. 新建ROS node
   rosnode = boost::shared_ptr<ros::NodeHandle>(new ros::NodeHandle(namespace_))


******** GetModelName (parent : sensors::SensorPtr&) : std::string

#+begin_latex
  \begin{minted}{cpp}
  /**
  * Accessing model name like suggested by nkoenig at http://answers.gazebosim.org/question/4878/multiple-robots-with-ros-plugins-sensor-plugin-vs/
  * @param parent
  * @return accessing model name
  **/
  inline std::string GetModelName ( const sensors::SensorPtr &parent )
  {
      std::string modelName;
      std::vector<std::string> values;
      std::string scopedName = parent->GetScopedName();
      boost::replace_all ( scopedName, "::", "," );
      boost::split ( values, scopedName, boost::is_any_of ( "," ) );
      if ( values.size() < 2 ) {
          modelName = "";
      } else {
          modelName = values[1];
      }
      return modelName;
  }

  \end{minted}
#+end_latex

1. Gazebo模型命名规范：
   =world_name::model_name::link_name::sensor_name=

2. gazebo::sensors::Sensor::GetScopedName()
   Get fully scoped name of the sensor.
   Returns: world_name::parent_name::sensor_name.

3. boost:replace_all & boost::split()
   #+begin_latex
   \begin{minted}{cpp}
   #include <boost/algorithm/string.hpp>
   \end{minted}
   #+end_latex
   replace的主要函数(以及其包括的copy函数)包括:replace_range,
   replace_first, replace_last, replace_nth, replace_head,
   replace_tail, replace_regex, replace_all, replace_all_regex

4.





******** GetRobotNamespace (parent : sensors::SensorPtr&,sdf : sdf::ElementPtr&,pInfo : char*) : std::string
#+begin_latex
  \begin{minted}{cpp}
  /**
  * @brief Reads the name space tag of a sensor plugin
  * @param parent
  * @param sdf
  * @param pInfo
  * @return node namespace
  **/
  inline std::string GetRobotNamespace ( const sensors::SensorPtr &parent, const sdf::ElementPtr &sdf, const char *pInfo = NULL )
  {
      std::string name_space;
      std::stringstream ss;
      if ( sdf->HasElement ( "robotNamespace" ) ) {
          name_space = sdf->Get<std::string> ( "robotNamespace" );
          if ( name_space.empty() ) {
              ss << "the 'robotNamespace' param was empty";
              name_space = GetModelName ( parent );
          } else {
              ss << "Using the 'robotNamespace' param: '" <<  name_space << "'";
          }
      } else {
          ss << "the 'robotNamespace' param did not exit";
      }
      if ( pInfo != NULL ) {
          ROS_INFO ( "%s Plugin (robotNamespace = %s), Info: %s" , pInfo, name_space.c_str(), ss.str().c_str() );
      }
      return name_space;
  }

  \end{minted}
#+end_latex

1. stringstream
   1) #include <sstream>
   2) 处理字符串的 *流对象*
   3) 不直接输出到标准输出或者标准错误上，而保存在字符串流对象中，需要
      的时候再输出。

2. const stf::ElementPtr &sdf

   sdf::ElementPtr gazebo::sensors::Sensor::sdf
   protected
   Pointer the the SDF element for the sensor.

3. ROS_INFO

4.
******** Method-prototypes: GazeboRosPtr : typedef
typedef boost::shared_ptr<GazeboRos> GazeboRosPtr;

***** [[http://wiki.ros.org/hector_gazebo_worlds?distro=jade][hector_gazebo_worls]]
****** worlds

Some scenarios for gazebo simulation

******* rolling_landscape_120m.launch
[[/home/ben/Wally/Journal/Figures/scrot/15486Dbi.png]]
******* sick_robot_day_2014_20m.launch
[[/home/ben/Wally/Journal/Figures/scrot/15486cDE.png]]

******* sick_robot_day_2014.launch
[[/home/ben/Wally/Journal/Figures/scrot/15486pNK.png]]

******* small_indoor_scenario.launch
[[/home/ben/Wally/Journal/Figures/scrot/154862XQ.png]]

****** map setting yaml file

#+BEGIN_EXAMPLE
image: small_indoor_scenario_edited_map_hector_mapping.pgm
resolution: 0.050000
origin: [-19.224998, -19.224998, 0.000000]
negate: 0
occupied_thresh: 0.65
free_thresh: 0.196
#+END_EXAMPLE

****** .material文件定义颜色和材质？

**** Q & A
***** [[http://answers.ros.org/question/40584/hector_slam-and-imu/][How an IMU is used as a part of Hector_slam]]

/Information about the LIDAR attitude has to be available./

If the platform experiences roll/pitch motion, using a IMU and tf is a
straightforward way to supply this information. Of course, if the
LIDAR is mounted to a heavy platform traveling on flat ground, the
roll/pitch estimate can be considered fixed and no IMU is needed.

_Low cost IMUs as commonly used in robotics (as opposed to military
grade/aerospace ones) are hard to use for odometry_, as the double
integration of accelerometer data leads to very high translational
errors within seconds.

/IMU data generally has to be filtered and fused with other sources to
be useful for (translational)motion estimation./

A EKF-based filter for this is available in the *hector_localization*
stack.

Unfortunately we didn't get around to
writing a proper tutorial for that so far. This state estimation
filter estimates the 6DOF pose of the vehicle (as well as IMU sensor
biases). The tf generated by the filter can be used as a start
estimate for scan matching in hector_mapping, while the 2D pose
estimate by the latter in turn can be used to update the EKF solution
again.

***** [[http://answers.ros.org/question/198636/hector-slam-input-imu-data/][imu tf ?]]

hector_slam /only uses (roll/pitch) imu data/ implicitly by transforming
the scan through tf. It would be possible to for example use IMU data
for improving the scan-matching start estimate, but this is currently
not implemented.

*hector_imu_attitude_to_tf*

***** [[http://answers.ros.org/question/31618/hector-mapping-stabilized-frame/][stabilized frame]]

**** issues
1. hector_slam only uses (roll/pitch) imu data implicitly by
   transforming the scan through tf. It would be possible to for
   example use IMU data for improving the scan-matching start
   estimate, but this is currently not implemented.

2.

***** hector_slam and IMU

*** [[http://wiki.ros.org/gmapping][gmapping]]                   :gmapping:
**** slam_gmapping

This package contains a ROS wrapper for OpenSlam's Gmapping. The
gmapping package provides laser-based SLAM (Simultaneous Localization
and Mapping), as a ROS node called slam_gmapping. Using slam_gmapping,
you can create a 2-D occupancy grid map (like a building floorplan) from
laser and pose data collected by a mobile robot.


***** External Documentation

This is mostly a third party package; the underlying GMapping library is
[[http://openslam.org/gmapping.html][externally documented]]. Look there
for details on many of the parameters listed below.

***** Hardware Requirements

To use =slam_gmapping=, you need a mobile robot that provides odometry
data and is equipped with a horizontally-mounted, fixed, laser
range-finder. The =slam_gmapping= node will attempt to transform each
incoming scan into the =odom= (odometry) [[/tf][tf]] frame. See the
"[[/gmapping#Required_tf_Transforms][Required tf transforms]]" for more
on required transforms.

***** Example

To make a map from a robot with a laser publishing scans on the
=base_scan= topic:

#+BEGIN_EXAMPLE
    rosrun gmapping slam_gmapping scan:=base_scan
#+END_EXAMPLE

***** Nodes
****** slam_gmapping

The =slam_gmapping= node takes in
[[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]]
messages and builds a map
([[http://docs.ros.org/api/nav_msgs/html/msg/OccupancyGrid.html][nav_msgs/OccupancyGrid]]).
The map can be retrieved via a ROS [[/Topics][topic]] or
[[/Services][service]].

******* Subscribed Topics

=tf=
([[http://docs.ros.org/api/tf/html/msg/tfMessage.html][tf/tfMessage]])

-  Transforms necessary to relate frames for laser, base, and odometry
   (see below)

=scan=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  Laser scans to create the map from

******* Published Topics

=map_metadata=
([[http://docs.ros.org/api/nav_msgs/html/msg/MapMetaData.html][nav_msgs/MapMetaData]])

-  Get the map data from this topic, which is latched, and updated
   periodically.

=map=
([[http://docs.ros.org/api/nav_msgs/html/msg/OccupancyGrid.html][nav_msgs/OccupancyGrid]])

-  Get the map data from this topic, which is latched, and updated
   periodically

=~entropy=
([[http://docs.ros.org/api/std_msgs/html/msg/Float64.html][std_msgs/Float64]])

-  Estimate of the entropy of the distribution over the robot's pose (a
   higher value indicates greater uncertainty). New in 1.1.0.

******* Services

=dynamic_map=
([[http://docs.ros.org/api/nav_msgs/html/srv/GetMap.html][nav_msgs/GetMap]])

-  Call this service to get the map data

******* Parameters

=~inverted_laser= (=string=, default: ="false"=)

-  *(REMOVED in 1.1.1; transform data is used instead)* Is the laser
   right side up (scans are ordered CCW), or upside down (scans are
   ordered CW)?

=~throttle_scans= (=int=, default: 1)

-  Process 1 out of every this many scans (set it to a higher number to
   skip more scans)

=~base_frame= (=string=, default: ="base_link"=)

-  The frame attached to the mobile base.

=~map_frame= (=string=, default: ="map"=)

-  The frame attached to the map.

=~odom_frame= (=string=, default: ="odom"=)

-  The frame attached to the odometry system.

=~map_update_interval= (=float=, default: 5.0)

-  How long (in seconds) between updates to the map. Lowering this
   number updates the occupancy grid more often, at the expense of
   greater computational load.

=~maxUrange= (=float=, default: 80.0)

-  The maximum usable range of the laser. A beam is cropped to this
   value.

=~sigma= (=float=, default: 0.05)

-  The sigma used by the greedy endpoint matching

=~kernelSize= (=int=, default: 1)

-  The kernel in which to look for a correspondence

=~lstep= (=float=, default: 0.05)

-  The optimization step in translation

=~astep= (=float=, default: 0.05)

-  The optimization step in rotation

=~iterations= (=int=, default: 5)

-  The number of iterations of the scanmatcher

=~lsigma= (=float=, default: 0.075)

-  The sigma of a beam used for likelihood computation

=~ogain= (=float=, default: 3.0)

-  Gain to be used while evaluating the likelihood, for smoothing the
   resampling effects

=~lskip= (=int=, default: 0)

-  Number of beams to skip in each scan.

=~minimumScore= (=float=, default: 0.0)

-  Minimum score for considering the outcome of the scan matching good.
   Can avoid jumping pose estimates in large open spaces when using
   laser scanners with limited range (e.g. 5m). Scores go up to 600+,
   try 50 for example when experiencing jumping estimate issues.

=~srr= (=float=, default: 0.1)

-  Odometry error in translation as a function of translation (rho/rho)

=~srt= (=float=, default: 0.2)

-  Odometry error in translation as a function of rotation (rho/theta)

=~str= (=float=, default: 0.1)

-  Odometry error in rotation as a function of translation (theta/rho)

=~stt= (=float=, default: 0.2)

-  Odometry error in rotation as a function of rotation (theta/theta)

=~linearUpdate= (=float=, default: 1.0)

-  Process a scan each time the robot translates this far

=~angularUpdate= (=float=, default: 0.5)

-  Process a scan each time the robot rotates this far

=~temporalUpdate= (=float=, default: -1.0)

-  Process a scan if the last scan processed is older than the update
   time in seconds. A value less than zero will turn time based updates
   off.

=~resampleThreshold= (=float=, default: 0.5)

-  The Neff based resampling threshold

=~particles= (=int=, default: 30)

-  Number of particles in the filter

=~xmin= (=float=, default: -100.0)

-  Initial map size

=~ymin= (=float=, default: -100.0)

-  Initial map size

=~xmax= (=float=, default: 100.0)

-  Initial map size

=~ymax= (=float=, default: 100.0)

-  Initial map size

=~delta= (=float=, default: 0.05)

-  Resolution of the map

=~llsamplerange= (=float=, default: 0.01)

-  Translational sampling range for the likelihood

=~llsamplestep= (=float=, default: 0.01)

-  Translational sampling step for the likelihood

=~lasamplerange= (=float=, default: 0.005)

-  Angular sampling range for the likelihood

=~lasamplestep= (=float=, default: 0.005)

-  Angular sampling step for the likelihood

=~transform_publish_period= (=float=, default: 0.05)

-  How long (in seconds) between transform publications.

=~occ_thresh= (=float=, default: 0.25)

-  Threshold on gmapping's occupancy values. Cells with greater
   occupancy are considered occupied (i.e., set to 100 in the resulting
   [[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]]).
   New in 1.1.0.

=~maxRange= (=float=)

-  The maximum range of the sensor. If regions with no obstacles within
   the range of the sensor should appear as free space in the map, set
   maxUrange < maximum range of the real sensor <= maxRange.

******* Required tf Transforms

=<the frame attached to incoming scans>= → =base_link=

-  usually a fixed value, broadcast periodically by a
   [[/robot_state_publisher][robot_state_publisher]], or a =tf=
   [[/tf#static_transform_publisher][static_transform_publisher]].

=base_link= → =odom=

-  usually provided by the odometry system (e.g., the driver for the
   mobile base)

******* Provided tf Transforms

=map= → =odom=

-  the current estimate of the robot's pose within the map frame

**** reference

+ http://wiki.ros.org/gmapping
+ [[https://github.com/ros-perception/slam_gmapping][https://github.com/ros-perception/slam_gmapping.git]]

*** octomap
+ http://wiki.ros.org/octomap
+ Homepage: http://octomap.github.io/
+ Github: https://github.com/OctoMap/octomap
+ Doc: http://octomap.github.io/octomap/doc/
+ dataset: http://ais.informatik.uni-freiburg.de/projects/datasets/octomap/
+ wiki: https://github.com/OctoMap/octomap/wiki/_pages
**** octomap
The OctoMap library implements a 3D occupancy grid mapping approach,
providing data structures and mapping algorithms in C++ particularly
suited for robotics. The map implementation is based on an octree and
is designed to meet the following requirements:

License
+ OctoMap is released under the New BSD License.
+ The viewer octovis is released under the GNU-GPL License (version
  2).

**** octomap_mapping
+ http://wiki.ros.org/octomap_mapping?distro=indigo


Mapping tools to be used with the OctoMap library, implementing a 3D
occupancy grid mapping.
**** octomap_server
+ http://wiki.ros.org/octomap_server?distro=indigo


octomap_server loads a 3D map (as Octree-based OctoMap) and distributes
it to other nodes in a compact binary format. It also allows to
incrementally build 3D OctoMaps, and provides map saving in the node
octomap_saver.

-  Maintainer status: maintained
-  Maintainer: Armin Hornung <hornunga AT informatik.uni-freiburg DOT
   de>
-  Author: Armin Hornung
-  License: BSD
-  Bug / feature tracker:
   [[https://github.com/OctoMap/octomap_mapping/issues]]
-  Source: git
   [[https://github.com/OctoMap/octomap_mapping][https://github.com/OctoMap/octomap_mapping.git]]
   (branch: indigo-devel)


***** Overview

General information about OctoMap is available at
[[http://octomap.github.com]] and in the publication
[[http://www.informatik.uni-freiburg.de/~hornunga/pub/hornung13auro.pdf]["OctoMap:
An Efficient Probabilistic 3D Mapping Framework Based on Octrees"]] by
A. Hornung, K. M. Wurm, M. Bennewitz, C. Stachniss, and W. Burgard
(Autonomous Robots Journal, 2013).

BibTeX:

#+BEGIN_EXAMPLE
    @ARTICLE{hornung13auro,
      author = {Armin Hornung and Kai M. Wurm and Maren Bennewitz and Cyrill
      Stachniss and Wolfram Burgard},
      title = {{OctoMap}: An Efficient Probabilistic {3D} Mapping Framework Based
      on Octrees},
      journal = {Autonomous Robots},
      year = 2013,
      url = {http://octomap.github.com},
      doi = {10.1007/s10514-012-9321-0},
      note = {Software available at \url{http://octomap.github.com}}
    }
#+END_EXAMPLE

Please cite our paper if you use OctoMap in your research.

***** ROS Node API

****** dynamic_reconfigure API

*octomap_server* and *octomap_server_multilayer* offer a
dynamic_reconfigure interface to change the displayed map resolution on
the fly (since version 0.3.8). Note that this will not change the
resolution of the underlying [[/OctoMap][OctoMap]], but only of the
published marker / collision topics (e.g. for visualization).

****** octomap_server

octomap_server builds and distributes volumetric 3D occupancy maps as
OctoMap binary stream and in various ROS-compatible formats e.g. for
obstacle avoidance or visualization. The map can be a static OctoMap .bt
file (as command line argument) or can be incrementally built from
incoming range data (as PointCloud2). octomap_server starts with an
empty map if no command line argument is given. In general,
octomap_server creates and publishes only on topics that are
subscribed. Since some can be time-consuming to build for large maps,
only subscribe to topics you absolutely need (e.g. in RViz) and set the
"latch" parameter for false when building maps.
******* Subscribed Topics

=cloud_in=
([[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud2.html][sensor_msgs/PointCloud2]])

-  Incoming 3D point cloud for scan integration. You need to remap this
   topic to your sensor data and provide a tf transform between the
   sensor data and the static map frame.

******* Published Topics

=octomap_binary=
([[http://docs.ros.org/api/octomap_msgs/html/msg/Octomap.html][octomap_msgs/Octomap]])

-  The complete maximum-likelihood occupancy map as compact OctoMap
   binary stream, encoding free and occupied space. The binary message
   only distinguishes between free and occupied space but is smaller.
   See [[/octomap_msgs][octomap_msgs]] for deserializing the message.

=octomap_full=
([[http://docs.ros.org/api/octomap_msgs/html/msg/Octomap.html][octomap_msgs/Octomap]])

-  The complete maximum-likelihood occupancy map as compact OctoMap
   binary stream, encoding free and occupied space. The full message
   contains the complete probabilities and all additional data stored in
   the tree. See [[/octomap_msgs][octomap_msgs]] for deserializing the
   message.

=occupied_cells_vis_array=
([[http://docs.ros.org/api/visualization_msgs/html/msg/MarkerArray.html][visualization_msgs/MarkerArray]])

-  All occupied voxels as "box" markers for visualization in RViz. Be
   sure to subscribe to the topic *occupied_cells_vis* in RViz!

=octomap_point_cloud_centers=
([[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud2.html][sensor_msgs/PointCloud2]])

-  The centers of all occupied voxels as point cloud, useful for
   visualization. Note that this will have gaps as the points have no
   volumetric size and OctoMap voxels can have different resolutions!
   Use the MarkerArray topic instead.

=octomap_collision_object=
([[http://docs.ros.org/api/arm_navigation_msgs/html/msg/CollisionObject.html][arm_navigation_msgs/CollisionObject]])

-  All occupied voxels as "box" CollisionObjects, e.g. for collision
   avoidance in arm_navigation

=collision_map_out=
([[http://docs.ros.org/api/arm_navigation_msgs/html/msg/CollisionMap.html][arm_navigation_msgs/CollisionMap]])

-  All occupied voxels e.g. for collision avoidance in arm_navigation
   *New in octomap_mapping 0.4.4*

=map (up to fuerte) / projected_map (since fuerte)=
([[http://docs.ros.org/api/nav_msgs/html/msg/OccupancyGrid.html][nav_msgs/OccupancyGrid]])

-  Downprojected 2D occupancy map from the 3D map. Be sure to remap this
   topic if you have another 2D map server running. *New / changed in
   octomap_mapping 0.4.4*: The topic is now =projected_map= by default
   to avoid collisions with static 2D maps

******* Services

=octomap_binary=
([[http://docs.ros.org/api/octomap_msgs/html/srv/GetOctomap.html][octomap_msgs/GetOctomap]])

-  The complete maximum-likelihood occupancy map as compact OctoMap
   binary stream, encoding free and occupied space.

=~clear_bbx=
([[http://docs.ros.org/api/octomap_msgs/html/srv/BoundingBoxQuery.html][octomap_msgs/BoundingBoxQuery]])

-  Clears a region in the 3D occupancy map, setting all voxels in the
   region to "free"

=~reset=
([[http://docs.ros.org/api/std_srvs/html/srv/Empty.html][std_srvs/Empty]])

-  Resets the complete map

******* Parameters

=~frame_id= (=string=, default: /map)

-  Static global frame in which the map will be published. A transform
   from sensor data to this frame needs to be available when dynamically
   building maps.

=~resolution= (=float=, default: 0.05)

-  Resolution in meter for the map when starting with an empty map.
   Otherwise the loaded file's resolution is used.

=~base_frame_id= (=string=, default: base_footprint)

-  The robot's base frame in which ground plane detection is performed
   (if enabled)

=~height_map= (=bool=, default: true)

-  Whether visualization should encode height with different colors

=~color/[r/g/b/a]= (=float=)

-  Color for visualizing occupied cells when ~heigh_map=False, in range
   [0:1]

=~sensor_model/max_range= (=float=, default: -1 (unlimited))

-  Maximum range in meter for inserting point cloud data when
   dynamically building a map. Limiting the range to something useful
   (e.g. 5m) prevents spurious erroneous points far away from the robot.

=~sensor_model/[hit|miss]= (=float=, default: 0.7 / 0.4)

-  Probabilities for hits and misses in the sensor model when
   dynamically building a map

=~sensor_model/[min|max]= (=float=, default: 0.12 / 0.97)

-  Minimum and maximum probability for clamping when dynamically
   building a map

=~latch= (=bool=, default: True for a static map, false if no initial
map is given)

-  Whether topics are published latched or only once per change. For
   maximum performance when building a map (with frequent updates), set
   to false. When set to true, on every map change all topics and
   visualizations will be created.

=~filter_ground= (=bool=, default: false)

-  Whether the ground plane should be detected and ignored from scan
   data when dynamically building a map, using
   pcl::SACMODEL_PERPENDICULAR_PLANE. This clears everything up to the
   ground, but will not insert the ground as obstacle in the map. If
   this is enabled, it can be further configured with the
   ~ground_filter/... parameters.

=~ground_filter/distance= (=float=, default: 0.04)

-  Distance threshold for points (in z direction) to be segmented to the
   ground plane

=~ground_filter/angle= (=float=, default: 0.15)

-  Angular threshold of the detected plane from the horizontal plane to
   be detected as ground

=~ground_filter/plane_distance= (=float=, default: 0.07)

-  Distance threshold from z=0 for a plane to be detected as ground (4th
   coefficient of the plane equation from PCL)

=~pointcloud_[min|max]_z= (=float=, default: -/+ infinity)

-  Minimum and maximum height of points to consider for insertion in the
   callback. Any point outside of this intervall will be discarded
   before running any insertion or ground plane filtering. You can do a
   rough filtering based on height with this, but if you enable the
   ground_filter this interval needs to include the ground plane.

=~occupancy_[min|max]_z= (=float=, default: -/+ infinity)

-  Minimum and maximum height of occupied cells to be consider in the
   final map. This ignores all occupied voxels outside of the interval
   when sending out visualizations and collision maps, but will not
   affect the actual octomap representation.

******* Required tf Transforms

=sensor data frame= →
=/map (static world frame, changeable with parameter frame_id)=

-  Required transform of sensor data into the global map frame if you do
   scan integration. This information needs to be available from an
   external SLAM or localization node.

****** octomap_server_multilayer

An extension of octomap_server to publish multilayer projected 2D maps,
used by the [[/3d_navigation][3d_navigation]] stack. Subscriptions and
publications are mostly identical to the octomap_server node.
****** octomap_saver

A small command line tool to request octomap files from an
octomap_server, similar to
[[/map_server#map_saver][map_server#map_saver]]. Just run
"octomap_saver mapfile.bt" to request a compressed binary octomap via
service call and save it to mapfile.bt. Run "octomap_saver -f
mapfile.ot" to request a full probability octomap instead (Requires
version 0.5 or later).

**** octomap_msgs
+ http://wiki.ros.org/octomap_msgs


This package provides messages and serializations / conversion for the
OctoMap library.

**** octomap_ros
+ http://wiki.ros.org/octomap_ros


octomap_ros provides conversion functions between ROS and OctoMap's
native types. This enables a convenvient use of the octomap package in
ROS.

**** octomap_rviz_plugin
+ http://wiki.ros.org/octomap_rviz_plugins


A set of plugins for displaying occupancy information decoded from
binary octomap messages.

**** octomap in rviz
+ http://answers.ros.org/question/36465/octomap-in-rviz-and-occupancy-grids-in-3d-maps/


You can visualize both the incrementally built maps and the static
ones loaded from a .bt file in octomap_server in the same way (see the
documentation of octomap_server/Published Topics):

Add a MarkerArray display in RViz on the topic "occupied_cells_vis"
(without the trailing _array, that's an RViz problem). Be sure to set
the tf frame to "/map" or whatever your mapping frame is.

**** octomap turtlebot?
**** octoslam
+ https://github.com/ChallenHB/OctoSlam

**** OCTOMAP or PCL 没有必要相互转换
+ http://www.pcl-users.org/OctoMap-and-PCL-Question-td3850053.html




Octrees are general purpose data containers/structures which have certain properties (eight octant subdivision in this
case). As trees, they can be used for many applications, some involving visualization, compression, data reduction,
change detection, and so on.

Octomap is a code library that implements a 3D occupancy grid using octrees for mapping. This means that an octree
structure is used for a particular application (mapping) in this case, and thus most likely tailored with respect to the
specifics of that application.

PCL is a collection of libraries (think as "Boost 3D" being our final goal). One of the PCL libraries is called Octree
(libpcl_octree), and has a collection of different types of octrees. These octrees can be used for many different
applications like compression, change detection, mapping, etc.

More recently, the PCL community has been working on an out-of-core octree implementation (libpcl_outofcore) for large
scale mapping, i.e. the datasets/maps do not fit in memory and you have to store parts of them on disk. The goal is to
easily stream and use datasets of billions of points without any problems. We are collaborating with a lot of commercial
companies on this open source effort. See http://www.pointclouds.org/blog for more details.

You should figure out exactly what your application needs, then dig into our documentation to see which _type of octree_
is most suitable for you. There is not a single library or type of octree that can fulfill the requirements of many
different applications, so you need to pick what works best.

In terms of efficiency, PCL would be happy to optimize any piece of code that our users might find inefficient.

**** error
***** [pcl::SampleConsensusModelPlane::optimizeModelCoefficients] Not enough inliers found to support a model (0)! Returning the same coefficients.
+
  http://answers.ros.org/question/30909/problem-with-feeding-pointcloud2-messages-from-swissranger-4000-to-octomap-server/

Do you actually need the built-in ground plane filter? For mere map
building there's usually no need and you can set the parameter
~filter_ground to false. By default (in the latest version of
octomap_server), it should be false.

Otherwise you usually need to adjust the PCL plane detection
parameters to your sensor, it is currently tuned to the PR2's stereo
camera by default. Best have a look at the code, not all parameters
are explained on the wiki site in detail.

***** octovis 段错误 (核心已转储)
#+BEGIN_SRC sh
which octovis
#+END_SRC

#+RESULTS:
: /usr/local/bin/octovis


*使用 ~/Program/octomap/bin/octovis*

** Sensor
*** IMU                                                               :imu:
**** [[http://wiki.ros.org/microstrain_3dmgx2_imu][microstrain_3dmgx2_imu]] :imu:microstrain:
***** Intro
***** API                                                           :api:

****** Node

*imu_node*

****** Published Topics
1. *imu/data(sensor_msgs/imu)*
2. diagnostics(diagnostics_msgs/DiagnosticArray)
3. *imu/is_calibrated(std_msgs/Bool)*

****** Services
1. ~self_test(dignostic_msgs/SelfTest)
2. *imu/calibrate(std_srvs/Empty)*

****** Parameters
1. *~port (string, default: /dev/ttyUSB0)*

   The port the imu is running on.

2. *~frame_id (string, default: imu)*

   The frame in which imu readings will be returned.

3. ~autocalibrate (bool, default: true)

   Whether the imu automatically computes its biases at startup (set to
   false if you intend to calibrate via the calibrate service).

4. ~orientation_stdev (double, default: 0.035)

   Square root of the orientation_covariance diagonal elements in
   rad. The default value, derived from the manufacturer datasheet, is
   very conservative.

5. ~angular_velocity_stdev (double, default: 0.012)

   Square root of the angular_velocity_covariance diagonal elements in
   rad/s. The default value, derived from the manufacturer datasheet,
   is very conservative.

6. ~linear_acceleration_stdev (double, default: 0.098)

   Square root of the linear_acceleration_covariance diagonal elements
   in m/s^2. The default value, derived from the manufacturer
   datasheet, is very conservative.

7. *~max_drift_rate (double, default: 0.0001)*

   Just after performing a calibration, if the observed gyro rates are
   greater than this parameter, the calibration is assumed to have
   failed, and the imu starts reporting itself as uncalibrated.

8. ~assume_calibrated (bool, default: false)

   Indicates whether the IMU should assume that it is calibrated at
   startup.

***** Usage

1. connnect the plugin

2. configure the permission

   + $ ls -l /dev/ttyUSB0   # crw-rw-XX-
   + $ sudo chmod a+rw /dev/ttyUSB0

3. run the node

   + $ rosrun microstrain_3dmgx2_imu imu_node _port:=/dev/ttyUSB0

*TODO*: why _port？下划线前缀表示什么？？？

***** Reference

**** errors

***** [[https://github.com/ros-drivers/microstrain_3dmgx2_imu/issues/2][calibration check failed]]

I purposely set this calibration level a little too low so that users
had to purposely set the value according to their IMU model and
application.

It's in *radians/second*

We can set the value of max_drift_rate in the launch file to 0.001 (10
times of default value 0.0001). And after setting, no error exists
when running "roslaunch etc/ros/robot.launch".

However, we don't know what's the proper value. What should we learn
to know how to set the value?

You can generally evaluate the performance of your gyro by *1* degree /
drift_rate. So in your case, you'll see one degree of IMU rotation
error roughly every 3 seconds. Given that the PR2 has wheel odometry
and a kalman filter averaging these measurements, this is probably
okay. (In a quadrotor it would probably not be okay since there's
typically no real odometry, so it's compensated for with either GPS or
a compass).

**** Q&A
**** [[http://wiki.ros.org/microstrain_3dmgx2_imu/Tutorials/UsingTheIMUNode][Using the IMU Node]]

***** [[http://answers.ros.org/question/49204/using-amcl-without-wheel-odometry-only-laser-imu/][imu without odometry]]
***** [[http://answers.ros.org/question/193017/how-to-transform-the-acceleration-data-from-imu-to-velocity/][imu integration]]

I'm guessing your IMU puts out linear acceleration, angular velocity,
and absolute orientation. While I have a branch of robot_localization
that will take in linear acceleration data, I should point out that
*the double integration of linear acceleration as your only source of
absolute position will produce a really poor estimate* . If you had
some estimate of your vehicle's linear velocity, such as from your robot's
wheel encoder odometry, then you'd definitely benefit from the linear
acceleration data.

**** [[http://wiki.ros.org/imu_tools][imu_tools]]                    :imu:
***** [[http://wiki.ros.org/rviz_imu_plugin?distro=indigo][rviz_imu_plugin]] :rviz:
****** reference

+ [[http://wiki.ros.org/rviz_imu_plugin][roswiki: rviz_imu_plugin]]
+ [[https://github.com/ccny-ros-pkg/imu_tools][GitHub: imu_tools]]

****** stack: [[http://wiki.ros.org/imu_tools?distro=indigo][imu_tools]]

+ imu_complementary_filter
+ imu_filter_madgwick
+ rviz_imu_plugin

****** intro

The *rviz_imu_plugin* package is used to display *sensor_msgs/Imu*
messages in rviz.

Once you download and compile the package, it should be visible as a
plugin.

It displays the orientation of the IMU using *a box as well as and
coordinate axes*.

The acceleration can be visualized using *a vector*.
****** 安装： 源码（因为可能研究）

#+BEGIN_EXAMPLE
  $ rospack find rviz_imu_plugin
  /opt/ros/indigo/share/rviz_imu_plugin
#+END_EXAMPLE

1. \git clone\ OK

2. \cakin build\ OK

   #+BEGIN_EXAMPLE
     [100%] Built target imu_filter_node
     [100%] Built target imu_filter_nodelet
     [100%] Built target rviz_imu_plugin
   #+END_EXAMPLE

3. \check\ OK

   #+BEGIN_EXAMPLE
     $ rospack find rviz_imu_plugin
     /home/ben/catkin_ws/src/imu_tools/rviz_imu_plugin
   #+END_EXAMPLE

****** Usage

大致 OK， 箭头闪太快，不知什么问题。

***** [[http://wiki.ros.org/imu_complementary_filter?distro=indigo][imu_complementary_filter]] :ekf:

imu_tool::imu_complementary_filter 融合算法（磁），可以学习源码

***** [[http://wiki.ros.org/imu_filter_madgwick?distro=indigo][imu_filter_madgwick]]
*** Lidar                                                     :lidar:laser:
**** [[http://wiki.ros.org/hokuyo_node][hokuyo_node]]                                                  :hokuyo:

***** Package Summary

A ROS node to provide access to SCIP 2.0-compliant Hokuyo laser range
finders (including 04LX).

****** Supported Hardware

This driver should work with any SCIP 2.0-compliant laser range-finders.

****** API Stability

The ROS API of this driver should be considered stable.

****** Parameter Ranges

The UTM-30LX laser can report corrupt data and even crash if settings
with an excessive data rate are requested. The following settings are
known to work:

*Intensity mode off*:

-  =cluster=: 1
-  =skip=: 1
-  =intensity=: false
-  =min_ang=: -2.2689
-  =max_ang=: 2.2689

*Intensity mode on*:

-  =cluster=: 1
-  =skip=: 1
-  =intensity=: true
-  =min_ang=: -1.047
-  =max_ang=: 1.047

******* Allow Unsafe Settings Option

On the UTM-30LX, unless the =~allow_unsafe_settings= option is selected,
the hokuyo_node will limit the angular range to values that are known
to work. The angular range limit depends on the firmware version, and is
proportional to the =cluster= parameter.


| *Firmware version*      | *Maximum angular range / cluster (deg)*   | *hokuyo_node version*   |
| 1.16.01(16/Nov./2009)   | 190                                       | > 1.1.1                  |
| 1.16.02(19/Jan./2010)   | 95                                        | > 1.0.3                  |
| Other                   | 95                                        | > 1.0.3                  |

****** ROS API

******* Parameter interactions

Some parameter settings can cause problems, usually due to speed
limitations of the laser's serial interface. For example:

-  if =intensity= is true and =skip= is 0, then the device will likely
   drop some scans;
-  if =intensity= is true and =min_ang= / =max_ang= are outside -70 /
   +70 degrees, then some problems have been observed.

****** Command-Line Tools

The =getID= and =getFirmwareVersion= programs can be used to get
information about a hokuyo laser scanner. Each of them can be invoked in
a human readable way:

#+BEGIN_EXAMPLE
    $ rosrun hokuyo_node getID /dev/ttyACM0
    Device at /dev/ttyACM0 has ID H0807228
#+END_EXAMPLE

or in a script friendly way:

#+BEGIN_EXAMPLE
    $ rosrun hokuyo_node getID /dev/ttyACM0 --
    H0807228
#+END_EXAMPLE

If they fail to connect to the device they will retry for about ten
seconds before giving up.

****** Using udev to Give Hokuyos Consistent Device Names

The =getID= program can be used to get the hardware ID of a Hokuyo
device given its port. Combined with udev, this allows a consistent
device name to be given to each device, even if the order in which they
are plugged in varies. The following udev rule should work universally
on any ROS system:

#+BEGIN_EXAMPLE
    KERNEL=="ttyACM[0-9]*", ACTION=="add", ATTRS{idVendor}=="15d1", MODE="0666", GROUP="dialout", PROGRAM="/opt/ros/hydro/env.sh rosrun hokuyo_node getID %N q", SYMLINK+="sensors/hokuyo_%c"
#+END_EXAMPLE

This udev rule sets up a device name that is based on the Hokuyo's
hardware ID. The PR2 then has a symlink to that name that gets changed
if the Hokuyo is replaced:

#+BEGIN_EXAMPLE
    $ ls -l /etc/ros/sensors/base_hokuyo
    lrwxrwxrwx 1 root root 28 2010-01-12 15:53 /etc/ros/sensors/base_hokuyo -> /dev/sensors/hokuyo_H0902620
    $ ls -l /dev/sensors/hokuyo_H0902620
    lrwxrwxrwx 1 root root 10 2010-04-12 12:34 /dev/sensors/hokuyo_H0902620 -> ../ttyACM1
#+END_EXAMPLE

****** Communication Protocol Documentation

-  The SCIP 2.0 protocol is described in
   [[/hokuyo_node?action=AttachFile&do=view&target=URG-Series_SCIP2_Compatible_Communication_Specification_ENG.pdf][URG-Series_SCIP2_Compatible_Communication_Specification_ENG.pdf]].
-  The extension for intensity scans is documented in
   [[/hokuyo_node?action=AttachFile&do=view&target=UTM-30LX_Specification.pdf][UTM-30LX_Specification.pdf]].

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div id="pagebottom">
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

Wiki: hokuyo_node (last edited 2014-10-17 14:25:12 by
[[/JeffSchmidt][JeffSchmidt]])



Except where otherwise noted, the ROS wiki is licensed under the\\
[[http://creativecommons.org/licenses/by/3.0/][Creative Commons
Attribution 3.0]] |
[[https://plus.google.com/113789706402978299308][Find us on Google+]]

--------------





[[/custom/images/brought_by_horiz.png]]









***** API                                                           :api:
****** parameter

+ intensity	Whether or not intensity data should be provided
+ min_ang	Minimal angle of the scan (radians)
+ max_ang	Maximum angle of the scan (radians)
+ clustering	Number of adjascent ranges to be clustered into a single measurement
+ skip	Number of scans to skip between returning measurements
+ num	Number of times to repeat the measurement 0 for auto.
+ timeout	Timeout in milliseconds.

****** node
hokuyo_node

***** Usage

1. plugin and power on

2. check permission
   #+begin_latex
   \begin{minted}[frame=single, mathescape]{sh}
   $ ls -a /dev/ttyACM0   # crw-rw-XX-
   $ sudo chmod a+rw /dev/ttyACM
   \end{minted}
   #+end_latex

3. run
   1) roslaunch
   2) rosparam set & rosrun

***** 手记
$ rosparam get <TAB>

#+BEGIN_EXAMPLE
  /hokuyo/allow_unsafe_settings
  /hokuyo/calibrate_time
  /hokuyo/cluster
  /hokuyo/frame_id
  /hokuyo/intensity
  /hokuyo/max_ang
  /hokuyo/max_ang_limit
  /hokuyo/max_range
  /hokuyo/min_ang
  /hokuyo/min_ang_limit
  /hokuyo/min_range
  /hokuyo/port
  /hokuyo/skip
  /hokuyo/time_offset
#+END_EXAMPLE

***** Reference
+ [[https://github.com/ros-drivers/hokuyo_node][GitHub]]
+ [[http://wiki.ros.org/hokuyo_node][roswiki]]
+ [[http://docs.ros.org/indigo/api/hokuyo_node/html/index.html][API]]
**** hokuyo_node                                      :hokuyo:hokuyo_mode:

A ROS node to provide access to SCIP 2.0-compliant Hokuyo laser range
finders (including 04LX).

***** Supported Hardware

This driver should work with any SCIP 2.0-compliant laser range-finders.

***** API Stability

The ROS API of this driver should be considered stable.

***** Parameter Ranges

The UTM-30LX laser can report corrupt data and even crash if settings
with an excessive data rate are requested. The following settings are
known to work:

*Intensity mode off*:

-  =cluster=: 1
-  =skip=: 1
-  =intensity=: false
-  =min_ang=: -2.2689
-  =max_ang=: 2.2689

*Intensity mode on*:

-  =cluster=: 1
-  =skip=: 1
-  =intensity=: true
-  =min_ang=: -1.047
-  =max_ang=: 1.047

****** Allow Unsafe Settings Option

On the UTM-30LX, unless the =~allow_unsafe_settings= option is selected,
the hokuyo_node will limit the angular range to values that are known
to work. The angular range limit depends on the firmware version, and is
proportional to the =cluster= parameter.


| *Firmware version*      | *Maximum angular range / cluster (deg)*   | *hokuyo_node version*   |
| 1.16.01(16/Nov./2009)   | 190                                       | > 1.1.1                  |
| 1.16.02(19/Jan./2010)   | 95                                        | > 1.0.3                  |
| Other                   | 95                                        | > 1.0.3                  |

***** ROS API

Parameter interactions

Some parameter settings can cause problems, usually due to speed
limitations of the laser's serial interface. For example:

-  if =intensity= is true and =skip= is 0, then the device will likely
   drop some scans;
-  if =intensity= is true and =min_ang= / =max_ang= are outside -70 /
   +70 degrees, then some problems have been observed.

***** Command-Line Tools

The =getID= and =getFirmwareVersion= programs can be used to get
information about a hokuyo laser scanner. Each of them can be invoked in
a human readable way:

#+BEGIN_EXAMPLE
    $ rosrun hokuyo_node getID /dev/ttyACM0
    Device at /dev/ttyACM0 has ID H0807228
#+END_EXAMPLE

or in a script friendly way:

#+BEGIN_EXAMPLE
    $ rosrun hokuyo_node getID /dev/ttyACM0 --
    H0807228
#+END_EXAMPLE

If they fail to connect to the device they will retry for about ten
seconds before giving up.

***** Using udev to Give Hokuyos Consistent Device Names

The =getID= program can be used to get the hardware ID of a Hokuyo
device given its port. Combined with udev, this allows a consistent
device name to be given to each device, even if the order in which they
are plugged in varies. The following udev rule should work universally
on any ROS system:

#+BEGIN_EXAMPLE
    KERNEL=="ttyACM[0-9]*", ACTION=="add", ATTRS{idVendor}=="15d1", MODE="0666", GROUP="dialout", PROGRAM="/opt/ros/hydro/env.sh rosrun hokuyo_node getID %N q", SYMLINK+="sensors/hokuyo_%c"
#+END_EXAMPLE

This udev rule sets up a device name that is based on the Hokuyo's
hardware ID. The PR2 then has a symlink to that name that gets changed
if the Hokuyo is replaced:

#+BEGIN_EXAMPLE
    $ ls -l /etc/ros/sensors/base_hokuyo
    lrwxrwxrwx 1 root root 28 2010-01-12 15:53 /etc/ros/sensors/base_hokuyo -> /dev/sensors/hokuyo_H0902620
    $ ls -l /dev/sensors/hokuyo_H0902620
    lrwxrwxrwx 1 root root 10 2010-04-12 12:34 /dev/sensors/hokuyo_H0902620 -> ../ttyACM1
#+END_EXAMPLE

***** Communication Protocol Documentation

-  The SCIP 2.0 protocol is described in
   [[/hokuyo_node?action=AttachFile&do=view&target=URG-Series_SCIP2_Compatible_Communication_Specification_ENG.pdf][URG-Series_SCIP2_Compatible_Communication_Specification_ENG.pdf]].
-  The extension for intensity scans is documented in
   [[/hokuyo_node?action=AttachFile&do=view&target=UTM-30LX_Specification.pdf][UTM-30LX_Specification.pdf]].

**** [[http://wiki.ros.org/depthimage_to_laserscan][depth_image_to_laserscan]]
**** [[http://wiki.ros.org/laser_pipeline?distro%3Djade][laser_pipeline]]                                                :laser:
***** laser_pipeline

Meta-pack for /processing laser data/

1. filter: /laser_filter/
2. projection: /laser_geometry/
3. assembly: /laser_assembler/


*可以阅读源码*

***** [[http://wiki.ros.org/laser_filters][laser_filters]] :laser_filters:

https://github.com/ros-perception/laser_filters

****** Package Summary

Assorted filters designed to operate on 2D planar laser scanners, which
use the sensor_msgs/LaserScan type.

******* Overview

The primary content of the =laser_filters= package is a number of
general purpose filters for processing
[[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]]
messages. These filters are exported as plugins designed to work with
with the [[/filters][filters package]]. At the moment all of these
filters run directly on
[[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]],
but filters may be added in the future which process
[[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]]
instead. Please review the [[/filters][filters documentation]] for an
overview of how filters and filter chains are intended to work.

This package provides two nodes that can run multiple filters
internally. Using these nodes to run your filters is considered best
practice, since it allows multiple nodes to consume the output while
only performing the filtering computation once. The nodes are minimal
wrappers around filter chains of the given type. The
[[/laser_filters#scan_to_scan_filter_chain][scan_to_scan_filter_chain]]
applies a series of filters to a
[[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]].
The
[[/laser_filters#scan_to_cloud_filter_chain][scan_to_cloud_filter_chain]]
first applies a series of filters to a
[[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]],
transforms it into a
[[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]],
and then applies a series of filters to the
[[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]].

******* Using Laser Filters

Each [[/laser_filters#plugins][laser filter]] is a separate plugin
exported by the laser_filters package. This allows them to be specified
in a configuration file which can be loaded into an arbitrary
filter_chain templated on a
[[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]].
You can instantiate a laser filter into a filter_chain in C++
([[/laser_filters/Tutorials/Laser%20filtering%20in%20C%2B%2B][example]]),
or you can use the
[[/laser_filters#scan_to_scan_filter_chain][scan_to_scan_filter_chain]]
and
[[/laser_filters#scan_to_cloud_filter_chain][scan_to_cloud_filter_chain]]
nodes which contain appropriate filter chains internally
([[/laser_filters/Tutorials/Laser%20filtering%20using%20the%20filter%20nodes][example]]).

[[/filters][Filter chains]] are configured from the parameter server.
They expect a parameter which is a list made up of repeating blocks of
filter configurations. These should almost always be specified in a
=.yaml= file to be pushed to the parameter server. Each filter specified
in the chain will be applied in order.

The individual filters configurations contain a =name= which is used for
debugging purposes, a =type= which is used to locate the plugin, and a
=params= which is a dictionary of additional variables. Consult the
documentation for the particular filter plugin to see what variables may
be set in the params field.

For example, in a package, =mypkg=, to launch a
[[/laser_filters#scan_to_scan_filter_chain][scan_to_scan_filter_chain]]
with two filters: =LaserFilterClass1= and =LaserFilterClass2=, you could
use the file:

=my_laser_config.yaml=:

-

   #+BEGIN_EXAMPLE
       scan_filter_chain:
       - name: unique_name1
         type: LaserFilterClass1
         params:
           param1: a
           param2: b
       - name: unique_name2
         type: LaserFilterClass2
         params:
           param1: a
           param2: b
   #+END_EXAMPLE

You could then push this configuration to the parameter server using
[[/rosparam][rosparam]] by running:

-

   #+BEGIN_EXAMPLE
       $ rosparam load my_laser_config.yaml scan_to_scan_filter_chain
   #+END_EXAMPLE

And then launching the =scan_to_scan_filter_chain=:

-

   #+BEGIN_EXAMPLE
       $ rosrun laser_filters scan_to_scan_filter_chain
   #+END_EXAMPLE

******* Laser Filter Nodes

******** scan_to_scan_filter_chain (new in laser_pipeline-0.5)

The scan_to_scan_filter_chain is a very minimal node which wraps an
instance of a =filters::FilterChain<sensor_msgs::LaserScan>=. This node
can be used to run any filter in this package on an incoming laser scan.
If the =~tf_message_filter_target_frame= parameter is set, it will wait
for the transform between the laser and the target_frame to be
available before running the filter chain.

[[/laser_filters?action=AttachFile&do=get&target=scan_to_scan_filter_chain.png]]

********* ROS Parameters

=~scan_filter_chain= (list)

-  *[Required]* The list of laser filters to load.

=~tf_message_filter_target_frame= (string)

-  A target_frame for which a transform must exist at the current time
   before the filter_chain will be executed. This is the target_frame
   internally passed to the =tf::MessageFilter=. If this parameter is
   not set, the chain will simply be executed immediately upon the
   arrival of each new scan.

********* Subscribed Topics

=scan=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  The incoming laser scan to filter

********* Published Topics

=scan_filtered=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  The outgoing filtered laser scan

********* Example Launch File

=my_laser_filter.launch=:

-

   #+BEGIN_EXAMPLE
       <launch>
         <node pkg="laser_filters" type="scan_to_scan_filter_chain"
             name="laser_filter">
           <rosparam command="load" file="$(find mypkg)/my_laser_config.yaml" />
           <remap from="scan" to="base_scan" />
         </node>
       </launch>
   #+END_EXAMPLE

=my_laser_config.yaml=:

-

   #+BEGIN_EXAMPLE
       scan_filter_chain:
       - name: shadows
         type: ScanShadowsFilter
         params:
           min_angle: 10
           max_angle: 170
           neighbors: 20
           window: 1
       - name: dark_shadows
         type: LaserScanIntensityFilter
         params:
           lower_threshold: 100
           upper_threshold: 10000
           disp_histogram: 0
   #+END_EXAMPLE

******** scan_to_cloud_filter_chain

The scan_to_cloud_filter_chain is a very minimal node which wraps an
instances of =filters::FilterChain<sensor_msgs::LaserScan>= and
=filters::FilterChain<sensor_msgs::PointCloud>=. This node can be used
to run any filter in this package on an incoming laser scan. After
performing the laser filtering, it will use the =LaserProjection= from
[[/laser_geometry][laser_geometry]] to transform each scan into a point
cloud. It will then run any cloud-based filtering, and finally publish
the resultant cloud.

[[/laser_filters?action=AttachFile&do=get&target=scan_to_cloud_filter_chain.png]]

********* ROS Parameters

=~scan_filter_chain= (list)

-  *[Required]* The list of laser filters to load.

=~cloud_filter_chain= (list)

-  *[Required]* The list of cloud filters to load.

=~target_frame= (string)

-  *[Required]* The frame to transform the point_cloud into.

=~high_fidelity= (bool, default: false)

-  Default: false - Whether to perform a high fidelity transform

********* Subscribed Topics

=scan=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  The incoming laser scan to filter.

********* Published Topics

=cloud_filtered=
([[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]])

-  The outgoing filtered point cloud.

********* Example Launch File

=my_laser_cloud_filter.launch=:

-

   #+BEGIN_EXAMPLE
       <launch>
         <node pkg="laser_filters" type="scan_to_cloud_filter_chain"
             name="tilt_shadow_filter">
           <rosparam command="load" file="$(find mypkg)/my_laser_config.yaml" />
           <rosparam command="load" file="$(find mypkg)/my_cloud_config.yaml" />
           <param name="high_fidelity" value="true" />
           <param name="target_frame" type="string" value="base_link" />
           <remap from="scan" to="tilt_scan" />
           <remap from="cloud_filtered" to="tilt_scan_cloud_filtered" />
         </node>
       </launch>
   #+END_EXAMPLE

=my_laser_config.yaml=:

-

   #+BEGIN_EXAMPLE
       scan_filter_chain:
       - name: shadows
         type: ScanShadowsFilter
         params:
           min_angle: 10
           max_angle: 170
           neighbors: 20
           window: 1
       - name: dark_shadows
         type: LaserScanIntensityFilter
         params:
           lower_threshold: 100
           upper_threshold: 10000
           disp_histogram: 0
   #+END_EXAMPLE

=my_cloud_config.yaml=:

-

   #+BEGIN_EXAMPLE
       cloud_filter_chain:
       - type: PR2PointCloudFootprintFilter
         name: footprint_filter
         params:
           inscribed_radius: 0.325
   #+END_EXAMPLE

******* Laser Filter Plugins

******** LaserArrayFilter

This filter internally makes use of the the [[/filters][filters]]
implementation of float-array filters. It extracts the range and
intensity values and treats each as an independent float array passed
through an internal filter chain.

********* Parameters

=range_filter_chain= (=FilterChain=)

-  A nested filter chain description, describing an appropriate chain of
   =MultiChannelMedianFilterFloat= type filters.

=intensity_filter_chain= (=FilterChain=)

-  A nested filter chain description, describing an appropriate chain of
   =MultiChannelMedianFilterFloat= type filters.

********* Example Configuration

-

   #+BEGIN_EXAMPLE
       scan_filter_chain:
       - type: LaserArrayFilter
         name: laser_median_filter
         params:
           range_filter_chain:
             - name: median_5
               type: MultiChannelMedianFilterFloat
               params:
                 number_of_observations: 5
                 unused: 10
           intensity_filter_chain:
             - name: median_5
               type: MultiChannelMedianFilterFloat
               params:
                 number_of_observations: 5
                 unused: 10
   #+END_EXAMPLE

******** LaserIntensityFilter

This filter removes all measurements from the
[[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]]
which are greater than =max_intensity= or less than =min_intensity=.
These points are "removed" by setting the corresponding range value to
=max_range= + 1, which is assumed to be an error case.

********* Parameters

=lower_threshold= (=int=)

-  Intensity value below which readings will be dropped.

=upper_threshold= (=int=)

-  Intensity value above which readings will be dropped.

=disp_histogram= (=int=)

-  Whether or not to write an intensity histogram to standard out.

********* Example configuration

-

   #+BEGIN_EXAMPLE
       scan_filter_chain:
       - name: intensity
         type: LaserScanIntensityFilter
         params:
           lower_threshold: 8000
           upper_threshold: 100000
           disp_histogram: 0
   #+END_EXAMPLE

******** ScanShadowsFilter

This filter removes laser readings that are most likely caused by the
veiling effect when the edge of an object is being scanned. For any two
points
[[/laser_filters?action=AttachFile&do=get&target=latex_4cc7f2e9204254eb1391f46370b8fc6dccabd3b2_p1.png]]
and
[[/laser_filters?action=AttachFile&do=get&target=latex_5f1a3efb496f5d367663668cb0c3f2a4b733ec5f_p1.png]],
we do this by computing the perpendicular angle. That is, assuming the
origin of the laser is
[[/laser_filters?action=AttachFile&do=get&target=latex_899aa7b718d144a3c3bc52ea988663d6de4375c0_p1.png]],
the angle formed
[[/laser_filters?action=AttachFile&do=get&target=latex_8e7a06e3cc6efac2cde677452a6afecf2c2fdf8d_p1.png]].
If the perpendicular angle is less than a particular min or greater than
a particular max, we remove all neighbors further away than that point.

********* Parameters

=min_angle= (=int=)

-  Minimum perpendicular angle

=max_angle= (=int=)

-  Maximum perpendicular angle

=window= (=int=)

-  Number of consecutive measurements to consider angles inside of

=neighbors= (=int=)

-  Number of further-away neighbors to remove

********* Example configuration

-

   #+BEGIN_EXAMPLE
       scan_filter_chain:
       - name: shadows
         type: ScanShadowsFilter
         params:
           min_angle: 10
           max_angle: 170
           neighbors: 20
           window: 1
   #+END_EXAMPLE

******** InterpolationFilter

For any measurement in the scan which is invalid, the interpolation
comes up with a measurement which is an interpolation between the
surrounding good values.

********* Parameters

NONE

********* Example configuration

-

   #+BEGIN_EXAMPLE
       scan_filter_chain:
       - name: interpolation
         type: InterpolationFilter
   #+END_EXAMPLE

******** LaserScanRangeFilter

This filter removes all measurements from the
[[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]]
which are greater than =upper_threshold= or less than =lower_threshold=.
These points are "removed" by setting the corresponding range value to
=max_range= + 1, which is assumed to be an error case.

********* Parameters

=lower_threshold= (=double=)

-  Lower range threshold

=upper_threshold= (=double=)

-  Upper range threshold

********* Example configuration

-

   #+BEGIN_EXAMPLE
       scan_filter_chain:
       - name: range
         type: LaserScanRangeFilter
         params:
           lower_threshold: 0.3
           upper_threshold: .inf
   #+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div id="pagebottom">
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

Wiki: laser_filters (last edited 2014-06-06 18:54:18 by
[[/AllisonTse][AllisonTse]])



Except where otherwise noted, the ROS wiki is licensed under the\\
[[http://creativecommons.org/licenses/by/3.0/][Creative Commons
Attribution 3.0]] |
[[https://plus.google.com/113789706402978299308][Find us on Google+]]

--------------





[[/custom/images/brought_by_horiz.png]]









****** nodes
1. scan_to_scan_filter_chain

   [[/home/ben/Wally/Journal/Figures/scrot/13390Cry.png]]

2. scan_to_cloud_filter_chain

   [[/home/ben/Wally/Journal/Figures/scrot/13390B_H.png]]

****** filter plugins

1. LaserArrayFilter
2. LaserIntensityFilter
3. ScanShadowsFilter
4. InterpolationFilter
5. LaserScanRangeFilter

***** [[http://wiki.ros.org/laser_geometry][laser_geometry]]
***** [[http://wiki.ros.org/laser_assembler?distro=jade][laser_assembler]] :laser_assembler:

Provides nodes to assemble point clouds from either LaserScan or
PointCloud messages

****** Overview

Laser Rangefinder sensors (such as Hokuyo's
[[http://www.hokuyo-aut.jp/02sensor/07scanner/utm_30lx.html][UTM-30LX]])
generally output a stream of scans, where each scan is a set of range
readings of detected objects (in polar coordinates) in the plane of the
sensor.

Many robotic systems, like PR2's tilting laser platform, articulate a
laser rangefinder in order to get a 3D view of the world. The
=laser_assembler= package provides nodes that listen to streams of scans
and then assemble them into a larger 3D Cartesian coordinate (XYZ) point
cloud.

Users interface with the laser_assembler package via two ROS nodes:

-  =laser_scan_assembler=: Assembles a stream of
   [[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]]
   messages into point clouds
-  =point_cloud_assembler=: Sometimes due to some pre-processing, laser
   scans have already been converted into cartesian coordinates as
   [[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]]
   messages. This node assembles a stream of these
   [[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]]
   messages into larger point clouds

****** Roadmap / Stability

The ROS API of this package is considered stable. We don't foresee
making any large changes to =laser_assembler= anytime soon.

****** Data Flow

The general data flow can be descibed as follows:


[[/home/ben/Wally/Journal//Figure/scrot/3507V9S.png]]


The =laser_scan_assembler= subscribes to
[[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]]
messages on the =scan= topic. These scans are processed by the Projector
and Transformer, which project the scan into Cartesian space and then
transform it into the =fixed_frame=. This results in a
[[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]]
that can be added to the rolling buffer. Clouds in the rolling buffer
are then assembled on service calls.

Note that the Transformer automatically receives [[/tf][tf]] data
without any user intervention.

[[/home/ben/Wally/Journal//Figure/scrot/3507iHZ.png]]

The =point_cloud_assembler= looks very similar to the
=laser_scan_assembler=, except that the projection step is skipped,
since the input clouds are already in Cartesian coordinates.

****** ROS API/Nodes

The main interaction with the assemblers is via ROS services. The
=laser_scan_assembler= and =point_cloud_assembler= both provide the
=assemble_scans= service, which is documented below.

NOTE: For laser_pipeline releases < 0.5.0, this service is called
=build_cloud=.

******* laser_scan_assembler

Assembles a stream of [[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]] messages into point clouds.
******** Subscribed Topics

=scan=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  Topic on which to receive a stream of sensor_msgs/LaserScan
   messages.

******** Services

=assemble_scans=
([[http://docs.ros.org/api/laser_assembler/html/srv/AssembleScans.html][laser_assembler/AssembleScans]])

-  When an assembler receives an =assemble_scans= request, it searches
   its rolling buffer for clouds that occur in the requested interval
   (=begin= to =end=). These clouds are then assembled into a larger
   cloud, in the frame specified by the =~fixed_frame= parameter, and
   sent to to the caller in the service response. This is a
   /non-blocking/ operation and will return an empty cloud if no scans
   are received in the requested interval. The resulting cloud will have
   channels named =intensities=, =index=, =distances=, and =stamps= as
   defined by the
   [[http://www.ros.org/doc/api/laser_geometry/html/classlaser__geometry_1_1LaserProjection.html][laser_geometry::LaserProjection]]
   library.

=assemble_scans2=
([[http://docs.ros.org/api/laser_assembler/html/srv/AssembleScans2.html][laser_assembler/AssembleScans2]])

-  Same as assemble_scans, except returns a
   [[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud2.html][sensor_msgs/PointCloud2]]

******** Parameters

=~fixed_frame= (=string=)

-  *[Required]* Stationary frame into which received scans (or clouds)
   are transformed.

=~tf_cache_time_secs= (=double=, default: 10.0)

-  The cache time (seconds) to store past transforms.

=~max_scans= (=int=, default: 400)

-  The number of scans to store in the assembler's rolling buffer.

=~ignore_laser_skew= (=bool=, default: =true=)

-  If true, pretend that all hits in a single scan correspond to the
   same tf transforms. If false, individually transform each hit to the
   fixed_frame (this is a fairly cpu intensive operation).

******* point_cloud_assembler

Assembles a stream of these
[[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]]
messages into larger point clouds.
******** Subscribed Topics

=cloud=
([[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]])

-  Topic on which to receive a stream of sensor_msgs/PointCloud
   messages.

******** Services

=assemble_scans=
([[http://docs.ros.org/api/laser_assembler/html/srv/AssembleScans.html][laser_assembler/AssembleScans]])

-  When an assembler receives an =assemble_scans= request, it searches
   its rolling buffer for clouds that occur in the requested interval
   (=begin= to =end=). These clouds are then assembled into a larger
   cloud, in the frame specified by the =~fixed_frame= parameter, and
   sent to to the caller in the service response. This is a
   /non-blocking/ operation and will return an empty cloud if no scans
   are received in the requested interval.

******** Parameters

=~fixed_frame= (=string=)

-  *[Required]* Stationary frame into which received scans (or clouds)
   are transformed.

=~tf_cache_time_secs= (=double=, default: 10.0)

-  The cache time (seconds) to store past transforms.

=~max_clouds= (=int=, default: 400)

-  The number of point clouds to store in the assembler's rolling
   buffer.

******* Example Launch

*laser_scan_assembler:*

Launch an assembler operating on =tilt_scan=
[[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]]
messages in the base_link frame, with a buffer of 400
scans.[[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]]

#+BEGIN_EXAMPLE
    <launch>
      <node type="laser_scan_assembler" pkg="laser_assembler"
            name="my_assembler">
        <remap from="scan" to="tilt_scan"/>
        <param name="max_scans" type="int" value="400" />
        <param name="fixed_frame" type="string" value="base_link" />
      </node>
    </launch>
#+END_EXAMPLE

*point_cloud_assembler:*

Launch an assembler operating on =my_cloud_in=
[[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]]
messages in the =base_link= frame, with a buffer of 400 scans.

#+BEGIN_EXAMPLE
    <launch>
      <node type="point_cloud_assembler" pkg="laser_assembler"
            name="my_assembler">
        <remap from="cloud" to="my_cloud_in"/>
        <param name="max_clouds" type="int" value="400" />
        <param name="fixed_frame" type="string" value="base_link" />
      </node>
    </launch>
#+END_EXAMPLE

******* Example: Calling from C++

Request a cloud with scans occurring between the start of time and now.

#+BEGIN_HTML
  <div class="highlight cpp">
#+END_HTML

#+BEGIN_HTML
  <div class="codearea" dir="ltr" lang="en">
#+END_HTML

#+BEGIN_EXAMPLE
       1 #include <ros/ros.h>
       2 #include <laser_assembler/AssembleScans.h>
       3 using namespace laser_assembler;
       4 int main(int argc, char **argv)
       5 {
       6   ros::init(argc, argv, "test_client");
       7   ros::NodeHandle n;
       8   ros::service::waitForService("assemble_scans");
       9   ros::ServiceClient client = n.serviceClient<AssembleScans>("assemble_scans");
      10   AssembleScans srv;
      11   srv.request.begin = ros::Time(0,0);
      12   srv.request.end   = ros::Time::now();
      13   if (client.call(srv))
      14     printf("Got cloud with %u points\n", srv.response.cloud.points.size());
      15   else
      16     printf("Service call failed\n");
      17   return 0;
      18 }
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

******* Example: Calling from Python

Request a cloud with scans occurring between the start of time and now.

#+BEGIN_HTML
  <div class="highlight python">
#+END_HTML

#+BEGIN_HTML
  <div class="codearea" dir="ltr" lang="en">
#+END_HTML

#+BEGIN_EXAMPLE
       1 #!/usr/bin/env python
       2 import roslib; roslib.load_manifest('laser_assembler')
       3 import rospy; from laser_assembler.srv import *
       4
       5 rospy.init_node("test_client")
       6 rospy.wait_for_service("assemble_scans")
       7 try:
       8     assemble_scans = rospy.ServiceProxy('assemble_scans', AssembleScans)
       9     resp = assemble_scans(rospy.Time(0,0), rospy.get_rostime())
      10     print "Got cloud with %u points" % len(resp.cloud.points)
      11 except rospy.ServiceException, e:
      12     print "Service call failed: %s"%e
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

NOTE: in both service calls the number of points in the returned point
cloud is capped by the size of the assembler's rolling buffer.

****** Tutorials

#+BEGIN_HTML
  <div class="searchresults">
#+END_HTML

1. [[/laser_assembler/Tutorials/HowToAssembleLaserScans][How to assemble
   laser scan lines into a composite point cloud]]

   In this tutorial you will learn how to assemble individual laser scan
   lines into a composite point cloud. One particular use case is to
   assemble individual scan lines from a laser on a tilting stage into a
   single point cloud to form a full 3D laser sweep.

#+BEGIN_HTML
  </div>
#+END_HTML

****** Deprecated API

As of laser_pipeline 0.4.0. A large part of the laser_assembler's ROS
API was deprecated. The API reference for the deprecated API is
available on the [[/laser_assembler-0.3.0][laser_assembler-0.3.0]]
page.


***** TODO error
- State "TODO"       from ""           [2015-12-15 二 15:06] \\
  llvm 的配置问题，始终没有得到有效的解决，先不用管它。

#+BEGIN_EXAMPLE
对‘llvm::raw_os_ostream::~raw_os_ostream()’未定义的引用
collect2: error: ld returned 1 exit status
#+END_EXAMPLE

**** [[http://wiki.ros.org/scan_tools?distro=jade][scan_tools]]                                                     :scan:
***** [[http://wiki.ros.org/laser_scan_matcher][laser_scan_matcher]]
**** tilt_laser

+ 使用 *laser_assembler*
  http://answers.ros.org/question/11553/hokuyo-laser-data-to-composite-3d-map/

+ 机械结构： http://wiki.ros.org/Forecast

  [[~/Tiger/Figures/ROS/screenshot_2015-06-15_09:26:33.png]]

+ laser_assembler with a vertical fixed laser sensor
  http://answers.ros.org/question/202542/laser_assembler-with-a-vertical-fixed-laser-sensor/

+ hokuyo+dynamixel+laser_assemble+octomap
  http://answers.ros.org/question/12347/combining-angle-from-ax12-servo-and-data-from-hokuyo-laser/

**** vertical_scan -> laser_geomtry -> PoindCloud2 -> octomap_server
**** Q&A
+ http://answers.ros.org/question/11232/how-to-turn-laser-scan-to-point-cloud-map/
+ http://wiki.ros.org/laser_geometry

*** [[http://wiki.ros.org/hokuyo3d][ros-indigo-hokuyo3d]]                                          :hokuyo3d:

Released Continuous integration Documented

ROS driver for HOKUYO 3D sensor

-  Maintainer status: developed
-  Maintainer: Atsushi Watanabe <atsushi.w AT atr DOT jp>
-  Author: Atsushi Watanabe <atsushi.w AT atr DOT jp>
-  License: BSD
-  Source: git
   [[https://github.com/at-wat/hokuyo3d][https://github.com/at-wat/hokuyo3d.git]]
   (branch: indigo-devel)

 *EXPERIMENTAL*: This status indicates that this software is
 experimental code at best. There are known issues and missing
 functionality. The APIs are completely unstable and likely to
 change. Use in production systems is not recommended. All code starts
 at this level. For more information see the ROS-Industrial software
 status [[/Industrial/Software_Status][page]].

**** Supported Hardware

This driver should work with *VSSP 1.0/1.1-compliant HOKUYO 3D-LIDARs.*

**** ROS API

***** hokuyo3d

=hokuyo3d= is a driver for VSSP 1.0/1.1 (Volumetric Scanning Sensor
Protocol) compliant Hokuyo 3D LIDARs.

****** Published Topics

=~/hokuyo_cloud=
([[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]])

-  Output of measured point cloud in [[/PointCloud][PointCloud]] message
   type which contains all multi echos with intensity. Published on
   demand.

=~/hokuyo_cloud2=
([[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud2.html][sensor_msgs/PointCloud2]])

-  Output of measured point cloud in [[/PointCloud2][PointCloud2]]
   message type which contains all multi echos with intensity. Published
   on demand.

=~/imu=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Imu.html][sensor_msgs/Imu]])

-  Output of embedded 6D gyro and accelerometer data.

=~/mag=
([[http://docs.ros.org/api/sensor_msgs/html/msg/MagneticField.html][sensor_msgs/MagneticField]])

-  Output of embedded 3D magnetic field vector.

****** Parameters

=~ip= (=string=, default: "192.168.0.10")

-  IP address of the sensor.

=~port= (=int=, default: 10940)

-  TCP Port of the sensor.

=~interlace= (=int=, default: 4)

-  Interlace setting of laser scanning. One means no interlace.

=~frame_id= (=string=, default: "hokuyo3d")

-  The TF frame ID in which point clouds will be returned.

=~range_min= (=float=, default: 0.0)

-  Points within range_min are dropped. This parameter is useful to
   remove ghost points nearby for early development version of this 3D
   sensors.

=~output_cycle= (=string=, default: "field")

-  Specifies timing of point cloud output. "frame": outputs for each
   interlace cycle (several fields), "field": one horizontal scan (tens
   of lines), "line": one vertical scan

*** kinect

There are several ROS drivers for the Kinect. At the ROS level, both
provide point clouds, but the underlying implementations are very
different and offer different benefits.

+ *freenect_stack* : newer driver using libfreenect

+ *openni_kinect* : Wraps the OpenNI "natural interaction" drivers, as
  well as higher level libraries like skeleton and gesture
  tracking. This driver is officially supported by PrimeSense, has
  great performance, and provides the full capabilities of the sensor,
  including in-sensor registration for RGB and depth (no calibration
  required), support for different depth and RGB resolutions, and full
  audio support. This driver supports Linux, OS X, and Windows.

+ *kinect* : The ROS kinect stack wraps the libfreenect drivers. These
  drivers are Kinect-specific, and thus also contain access to the
  Kinect motors and accelerometers. This driver supports Linux and OS
  X.

+ *kinect_aux* : A standalone driver for accelerometer/tilt/led
  extracted from the kinect driver. To run in parallel with the ni
  driver.
*** [[http://wiki.ros.org/joystick_drivers][joystick_drivers]]

*** usb_cam                                                       :usb_cam:

- http://wiki.ros.org/usb_cam

A ROS Driver for V4L USB Cameras

**** usb_cam_node

The =usb_cam_node= interfaces with standard USB cameras (e.g. the
Logitech Quickcam) using libusb_cam and publishes images as
sensor_msgs::Image. Uses the [[/image_transport][image_transport]]
library to allow compressed image transport.

***** Published Topics

=~<camera_name>/image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image

***** Parameters

=~video_device= (=string=, default: ="/dev/video0"=)

-  The device the camera is on.

=~image_width= (=integer=, default: =640=)

-  Image width

=~image_height= (=integer=, default: =480=)

-  Image height

=~pixel_format= (=string=, default: ="mjpeg"=)

-  Possible values are mjpeg, yuyv, uyvy

=~io_method= (=string=, default: ="mmap"=)

-  Possible values are mmap, read, userptr

=~camera_frame_id= (=string=, default: ="head_camera"=)

-  The camera's tf frame

=~framerate= (=integer=, default: =30=)

-  The required framerate

=~contrast= (=integer=, default: =32=)

-  Contrast of video image (0-255)

=~brightness= (=integer=, default: =32=)

-  Brightness of video image (0-255)

=~saturation= (=integer=, default: =32=)

-  Saturation of video image (0-255)

=~sharpness= (=integer=, default: =22=)

-  Sharpness of video image (0-255)

=~autofocus= (=boolean=, default: =false=)

-  Enable camera's autofocus

=~focus= (=integer=, default: =51=)

-  If autofocus is disabled, the focus of the camera (0=at infinity)

=~camera_info_url= (=string=, default: ==)

-  An url to the camera calibration file that will be read by the
   [[/CameraInfoManager][CameraInfoManager]] class

=~camera_name= (=string=, default: =head_camera=)

-  The camera name. This must match the name in the camera calibration

***** Related packages

[[/gencam_cu][gencam_cu]] - supports image capture from usb cameras
using OpenCV

** Robots
*** [[http://wiki.ros.org/Robots/TurtleBot][turtlebot]]
**** [[http://wiki.ros.org/turtlebot_teleop][turtlebot_teleop]]

***** keyboard Teleop

The turtlebot_teleop_key provides a generic keyboard teleopnode.

****** Published Topics

+ *turtlebot_telop_keyboard/cmd_vel(geometry_msgs/Twist)*

****** Parameters

+ *~scale_linear (double, default: 0.5)*

  The amount to scale the joystick input for the command velocity
  output.

+ *~scale_angular (double, default: 1.5)*

  The amount to scale the joystick input for the command velocity
  output.

****** Usage

#+BEGIN_EXAMPLE
roslaunch turtlebot_teleop keyboard_teleop.launch
#+END_EXAMPLE

#+BEGIN_SRC xml
  <launch>
    <!-- turtlebot_teleop_key already has its own built in velocity smoother -->
    <node pkg="turtlebot_teleop" type="turtlebot_teleop_key" name="turtlebot_teleop_keyboard"  output="screen">
      <param name="scale_linear" value="0.5" type="double"/>
      <param name="scale_angular" value="1.5" type="double"/>
      <remap from="turtlebot_teleop_keyboard/cmd_vel" to="cmd_vel_mux/input/teleop"/>
    </node>
  </launch>
#+END_SRC

**** [[http://wiki.ros.org/turtlebot_apps?distro=indigo][turtlebot_app]]

***** turtlebot_navigation

****** gmapping_demo.launch

#+BEGIN_SRC xml
  <launch>
    <include file="$(find turtlebot_bringup)/launch/3dsensor.launch">
      <arg name="rgb_processing" value="false" />
      <arg name="depth_registration" value="false" />
      <arg name="depth_processing" value="false" />

      <!-- We must specify an absolute topic name because if not it will be prefixed by "$(arg camera)".
           Probably is a bug in the nodelet manager: https://github.com/ros/nodelet_core/issues/7 -->
      <arg name="scan_topic" value="/scan" />
    </include>

    <include file="$(find turtlebot_navigation)/launch/includes/gmapping.launch.xml"/>

    <include file="$(find turtlebot_navigation)/launch/includes/move_base.launch.xml"/>

  </launch>
#+END_SRC

****** gmapping.launch.xml

#+BEGIN_SRC xml
  <launch>
    <arg name="scan_topic"  default="scan" />
    <arg name="base_frame"  default="base_footprint"/>
    <arg name="odom_frame"  default="odom"/>

    <node pkg="gmapping" type="slam_gmapping" name="slam_gmapping" output="screen">
      <param name="base_frame" value="$(arg base_frame)"/>
      <param name="odom_frame" value="$(arg odom_frame)"/>
      <param name="map_update_interval" value="5.0"/>
      <param name="maxUrange" value="6.0"/>
      <param name="maxRange" value="8.0"/>
      <param name="sigma" value="0.05"/>
      <param name="kernelSize" value="1"/>
      <param name="lstep" value="0.05"/>
      <param name="astep" value="0.05"/>
      <param name="iterations" value="5"/>
      <param name="lsigma" value="0.075"/>
      <param name="ogain" value="3.0"/>
      <param name="lskip" value="0"/>
      <param name="minimumScore" value="200"/>
      <param name="srr" value="0.01"/>
      <param name="srt" value="0.02"/>
      <param name="str" value="0.01"/>
      <param name="stt" value="0.02"/>
      <param name="linearUpdate" value="0.5"/>
      <param name="angularUpdate" value="0.436"/>
      <param name="temporalUpdate" value="-1.0"/>
      <param name="resampleThreshold" value="0.5"/>
      <param name="particles" value="80"/>
    <!--
      <param name="xmin" value="-50.0"/>
      <param name="ymin" value="-50.0"/>
      <param name="xmax" value="50.0"/>
      <param name="ymax" value="50.0"/>
    make the starting size small for the benefit of the Android client's memory...
    -->
      <param name="xmin" value="-1.0"/>
      <param name="ymin" value="-1.0"/>
      <param name="xmax" value="1.0"/>
      <param name="ymax" value="1.0"/>

      <param name="delta" value="0.05"/>
      <param name="llsamplerange" value="0.01"/>
      <param name="llsamplestep" value="0.01"/>
      <param name="lasamplerange" value="0.005"/>
      <param name="lasamplestep" value="0.005"/>
      <remap from="scan" to="$(arg scan_topic)"/>
    </node>
  </launch>

#+END_SRC

**** [[http://wiki.ros.org/turtlebot_apps?distro=indigo][turtlebot_gazebo]]
***** Gazebo bringup
****** roslaunch
#+BEGIN_SRC sh
roslaunch turtlebot_gazebo turtlebot_world.launch
#+END_SRC

****** turtlebot_world.launch
#+BEGIN_SRC xml
  <launch>
    <arg name="world_file"  default="$(env TURTLEBOT_GAZEBO_WORLD_FILE)"/>

    <arg name="base"      value="$(optenv TURTLEBOT_BASE kobuki)"/> <!-- create, roomba -->
    <arg name="battery"   value="$(optenv TURTLEBOT_BATTERY /proc/acpi/battery/BAT0)"/>  <!-- /proc/acpi/battery/BAT0 -->
    <arg name="gui" default="true"/>
    <arg name="stacks"    value="$(optenv TURTLEBOT_STACKS hexagons)"/>  <!-- circles, hexagons -->
    <arg name="3d_sensor" value="$(optenv TURTLEBOT_3D_SENSOR kinect)"/>  <!-- kinect, asus_xtion_pro -->

    <include file="$(find gazebo_ros)/launch/empty_world.launch">
      <arg name="use_sim_time" value="true"/>
      <arg name="debug" value="false"/>
      <arg name="gui" value="$(arg gui)" />
      <arg name="world_name" value="$(arg world_file)"/>
    </include>
    <!-- <include file="$(find turtlebot_gazebo)/launch/includes/kobuki.launch.xml"> -->
    <include file="$(find turtlebot_gazebo)/launch/includes/$(arg base).launch.xml">
      <arg name="base" value="$(arg base)"/>
      <arg name="stacks" value="$(arg stacks)"/>
      <arg name="3d_sensor" value="$(arg 3d_sensor)"/>
    </include>

    <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher">
      <param name="publish_frequency" type="double" value="30.0" />
    </node>

    <!-- Fake laser -->
    <node pkg="nodelet" type="nodelet" name="laserscan_nodelet_manager" args="manager"/>
    <node pkg="nodelet" type="nodelet" name="depthimage_to_laserscan"
          args="load depthimage_to_laserscan/DepthImageToLaserScanNodelet laserscan_nodelet_manager">
      <param name="scan_height" value="10"/>
      <param name="output_frame_id" value="/camera_depth_frame"/>
      <param name="range_min" value="0.45"/>
      <remap from="image" to="/camera/depth/image_raw"/>
      <remap from="scan" to="/scan"/>
    </node>
  </launch>
#+END_SRC

+ gzserver 命令行参数
+ rosparammeter
+ roslaunch 命令行参数
+ robot_state_publisher
+ nodelet
+ depth_image_to_laser_scan

****** empty_world.launch
#+BEGIN_SRC xml
  <launch>

    <!-- these are the arguments you can pass this launch file, for example paused:=true -->
    <arg name="paused" default="false"/>
    <arg name="use_sim_time" default="true"/>
    <arg name="extra_gazebo_args" default=""/>
    <arg name="gui" default="true"/>
    <arg name="headless" default="false"/>
    <arg name="debug" default="false"/>
    <arg name="physics" default="ode"/>
    <arg name="verbose" default="false"/>
    <arg name="world_name" default="worlds/empty.world"/> <!-- Note: the world_name is with respect to GAZEBO_RESOURCE_PATH environmental variable -->

    <!-- set use_sim_time flag -->
    <group if="$(arg use_sim_time)">
      <param name="/use_sim_time" value="true" />
    </group>

    <!-- set command arguments -->
    <arg unless="$(arg paused)" name="command_arg1" value=""/>
    <arg     if="$(arg paused)" name="command_arg1" value="-u"/>
    <arg unless="$(arg headless)" name="command_arg2" value=""/>
    <arg     if="$(arg headless)" name="command_arg2" value="-r"/>
    <arg unless="$(arg verbose)" name="command_arg3" value=""/>
    <arg     if="$(arg verbose)" name="command_arg3" value="--verbose"/>
    <arg unless="$(arg debug)" name="script_type" value="gzserver"/>
    <arg     if="$(arg debug)" name="script_type" value="debug"/>

    <!-- start gazebo server-->
    <node name="gazebo" pkg="gazebo_ros" type="$(arg script_type)" respawn="false" output="screen"
          args="$(arg command_arg1) $(arg command_arg2) $(arg command_arg3) -e $(arg physics) $(arg extra_gazebo_args) $(arg world_name)" />

    <!-- start gazebo client -->
    <group if="$(arg gui)">
      <node name="gazebo_gui" pkg="gazebo_ros" type="gzclient" respawn="false" output="screen"/>
    </group>
  </launch>
#+END_SRC

+ gazebo_ros nodes
+ gzserver 命令行参数
****** kobuki.launch.xml
#+BEGIN_SRC xml
  <launch>
    <arg name="base"/>
    <arg name="stacks"/>
    <arg name="3d_sensor"/>

    <arg name="urdf_file" default="$(find xacro)/xacro.py '$(find turtlebot_description)/robots/$(arg base)_$(arg stacks)_$(arg 3d_sensor).urdf.xacro'" />
    <param name="robot_description" command="$(arg urdf_file)" />

    <!-- Gazebo model spawner -->
    <node name="spawn_turtlebot_model" pkg="gazebo_ros" type="spawn_model"
          args="$(optenv ROBOT_INITIAL_POSE) -unpause -urdf -param robot_description -model mobile_base"/>

    <!-- Velocity muxer -->
    <node pkg="nodelet" type="nodelet" name="mobile_base_nodelet_manager" args="manager"/>
    <node pkg="nodelet" type="nodelet" name="cmd_vel_mux"
          args="load yocs_cmd_vel_mux/CmdVelMuxNodelet mobile_base_nodelet_manager">
      <param name="yaml_cfg_file" value="$(find turtlebot_bringup)/param/mux.yaml" />
      <remap from="cmd_vel_mux/output" to="mobile_base/commands/velocity"/>
    </node>

    <!-- Bumper/cliff to pointcloud (not working, as it needs sensors/core messages) -->
    <include file="$(find turtlebot_bringup)/launch/includes/kobuki/bumper2pc.launch.xml"/>
  </launch>
#+END_SRC
+ *Declares the existence of =foo=. =foo= must be passed in either as a command-line argument (if top-level) or via =<include>= passing (if included).*
+
****** kobuki_kinect.urdf.xacro
#+BEGIN_SRC xml
  <?xml version="1.0"?>
  <!--
  - Base      : kobuki
  - Stacks    : hexagons
  - 3d Sensor : kinect
  -->
  <robot name="turtlebot" xmlns:xacro="http://ros.org/wiki/xacro">

    <xacro:include filename="$(find turtlebot_description)/urdf/turtlebot_library.urdf.xacro" />

    <kobuki/>
    <stack_hexagons parent="base_link"/>
    <sensor_kinect  parent="base_link"/>

  </robot>

#+END_SRC
****** turtlebot_library.urdf.xacro
#+BEGIN_SRC xml
  <?xml version="1.0"?>
  <!--
    The complete turtlebot library of xacros for easy reference
   -->
  <robot xmlns:xacro="http://ros.org/wiki/xacro">
    <!-- General -->
    <xacro:include filename="$(find turtlebot_description)/urdf/common_properties.urdf.xacro"/>
    <xacro:include filename="$(find turtlebot_description)/urdf/turtlebot_properties.urdf.xacro"/>
    <!-- Bases -->
    <xacro:include filename="$(find create_description)/urdf/create.urdf.xacro"/>
    <xacro:include filename="$(find kobuki_description)/urdf/kobuki.urdf.xacro" />
    <!-- Stacks -->
    <xacro:include filename="$(find turtlebot_description)/urdf/stacks/circles.urdf.xacro"/>
    <xacro:include filename="$(find turtlebot_description)/urdf/stacks/hexagons.urdf.xacro"/>
    <!-- 3D Sensors -->
    <xacro:include filename="$(find turtlebot_description)/urdf/sensors/kinect.urdf.xacro"/>
    <xacro:include filename="$(find turtlebot_description)/urdf/sensors/asus_xtion_pro.urdf.xacro"/>
    <xacro:include filename="$(find turtlebot_description)/urdf/sensors/asus_xtion_pro_offset.urdf.xacro"/>
  </robot>

#+END_SRC
****** kobuki.urdf.xacro
#+BEGIN_SRC xml
  <?xml version="1.0" ?>
  <!--
    This is not a standalone urdf for kobuki. It simply defines the 'kobuki' tag that can
    be incorporated by other urdf files (e.g. turtlebot).

    See kobuki_standalone.urdf.xacro for a standalone urdf to be tested with
        kobuki_description/launch/view_model.launch
   -->
  <robot name="kobuki" xmlns:xacro="http://ros.org/wiki/xacro">
    <xacro:include filename="$(find kobuki_description)/urdf/common_properties.urdf.xacro"/>
    <xacro:include filename="$(find kobuki_description)/urdf/kobuki_gazebo.urdf.xacro"/>

    <!-- Kobuki -->
    <xacro:macro name="kobuki">
      <link name="base_footprint"/>
      <!--
         Base link is set at the bottom of the base mould.
         This is done to be compatible with the way base link
         was configured for turtlebot 1. Refer to

         https://github.com/turtlebot/turtlebot/issues/40

         To put the base link at the more oft used wheel
         axis, set the z-distance from the base_footprint
         to 0.352.
        -->
      <joint name="base_joint" type="fixed">
        <origin xyz="0 0 0.0102" rpy="0 0 0" />
        <parent link="base_footprint"/>
        <child link="base_link" />
      </joint>
      <link name="base_link">
        <visual>
          <geometry>
            <!-- new mesh -->
            <mesh filename="package://kobuki_description/meshes/main_body.dae" />
          </geometry>
          <origin xyz="0.001 0 0.05199" rpy="0 0 0"/>
        </visual>
        <collision>
          <geometry>
            <cylinder length="0.10938" radius="0.178"/>
          </geometry>
          <origin xyz="0.0 0 0.05949" rpy="0 0 0"/>
        </collision>
        <inertial>
          <!-- COM experimentally determined -->
          <origin xyz="0.01 0 0"/>
          <mass value="2.4"/> <!-- 2.4/2.6 kg for small/big battery pack -->
          <!-- Kobuki's inertia tensor is approximated by a cylinder with homogeneous mass distribution
               More details: http://en.wikipedia.org/wiki/List_of_moment_of_inertia_tensors
               m = 2.4 kg; h = 0.09 m; r = 0.175 m
               ixx = 1/12 * m * (3 * r^2 + h^2)
               iyy = 1/12 * m * (3 * r^2 + h^2)
               izz = 1/2 * m * r^2
            -->
          <inertia ixx="0.019995" ixy="0.0" ixz="0.0"
                   iyy="0.019995" iyz="0.0"
                   izz="0.03675" />
        </inertial>
      </link>

      <joint name="wheel_left_joint" type="continuous">
        <parent link="base_link"/>
        <child link="wheel_left_link"/>
        <origin xyz="0.00 ${0.23/2} 0.0250" rpy="${-M_PI/2} 0 0"/>
        <axis xyz="0 0 1"/>
      </joint>
      <link name="wheel_left_link">
        <visual>
          <geometry>
            <mesh filename="package://kobuki_description/meshes/wheel.dae"/>
          </geometry>
          <origin xyz="0 0 0" rpy="0 0 0"/>
        </visual>
        <collision>
          <geometry>
            <cylinder length="0.0206" radius="0.0352"/>
          </geometry>
          <origin rpy="0 0 0" xyz="0 0 0"/>
        </collision>
        <inertial>
          <mass value="0.01" />
          <origin xyz="0 0 0" />
          <inertia ixx="0.001" ixy="0.0" ixz="0.0"
                   iyy="0.001" iyz="0.0"
                   izz="0.001" />
        </inertial>
      </link>

      <joint name="wheel_right_joint" type="continuous">
        <parent link="base_link"/>
        <child link="wheel_right_link"/>
        <origin xyz="0.00 -${0.23/2} 0.0250" rpy="${-M_PI/2} 0 0"/>
        <axis xyz="0 0 1"/>
      </joint>
      <link name="wheel_right_link">
        <visual>
          <geometry>
            <mesh filename="package://kobuki_description/meshes/wheel.dae"/>
          </geometry>
          <origin xyz="0 0 0" rpy="0 0 0"/>
        </visual>
        <collision>
          <geometry>
            <cylinder length="0.0206" radius="0.0350"/>
          </geometry>
          <origin rpy="0 0 0" xyz="0 0 0"/>
        </collision>
        <inertial>
          <mass value="0.01" />
          <origin xyz="0 0 0" />
          <inertia ixx="0.001" ixy="0.0" ixz="0.0"
                   iyy="0.001" iyz="0.0"
                   izz="0.001" />
        </inertial>
      </link>

      <joint name="caster_front_joint" type="fixed">
        <parent link="base_link"/>
        <child link="caster_front_link"/>
        <origin xyz="0.115 0.0 0.007" rpy="${-M_PI/2} 0 0"/>
      </joint>
      <link name="caster_front_link">
        <collision>
          <geometry>
            <cylinder length="0.0176" radius="0.017"/>
          </geometry>
          <origin rpy="0 0 0" xyz="0 0 0"/>
        </collision>
        <inertial>
          <mass value="0.01" />
          <origin xyz="0 0 0" />
          <inertia ixx="0.001" ixy="0.0" ixz="0.0"
                   iyy="0.001" iyz="0.0"
                   izz="0.001" />
        </inertial>
      </link>

      <joint name="caster_back_joint" type="fixed">
        <parent link="base_link"/>
        <child link="caster_back_link"/>
        <origin xyz="-0.135 0.0 0.009" rpy="${-M_PI/2} 0 0"/>
      </joint>
      <link name="caster_back_link">
        <collision>
          <geometry>
            <cylinder length="0.0176" radius="0.017"/>
          </geometry>
          <origin rpy="0 0 0" xyz="0 0 0"/>
        </collision>
        <inertial>
          <mass value="0.01" />
          <origin xyz="0 0 0" />
          <inertia ixx="0.001" ixy="0.0" ixz="0.0"
                   iyy="0.001" iyz="0.0"
                   izz="0.001" />
        </inertial>
      </link>

      <!-- Kobuki's sensors -->
      <joint name="gyro_joint" type="fixed">
        <axis xyz="0 1 0"/>
        <origin xyz="0.056 0.062 0.0202" rpy="0 0 0"/>
        <parent link="base_link"/>
        <child link="gyro_link"/>
      </joint>
      <link name="gyro_link">
        <inertial>
          <mass value="0.001"/>
          <origin xyz="0 0 0" rpy="0 0 0"/>
          <inertia ixx="0.0001" ixy="0" ixz="0"
                   iyy="0.000001" iyz="0"
                   izz="0.0001"/>
        </inertial>
      </link>

      <joint name="cliff_sensor_left_joint" type="fixed">
        <origin xyz="0.08734 0.13601 0.0214" rpy="0 ${M_PI/2} 0" />
        <parent link="base_link"/>
        <child link="cliff_sensor_left_link" />
      </joint>
      <link name="cliff_sensor_left_link">
        <inertial>
          <mass value="0.0001" />
          <origin xyz="0 0 0" />
          <inertia ixx="0.0001" ixy="0.0" ixz="0.0"
                   iyy="0.0001" iyz="0.0"
                   izz="0.0001" />
        </inertial>
      </link>

      <joint name="cliff_sensor_right_joint" type="fixed">
        <origin xyz="0.085 -0.13601 0.0214" rpy="0 ${M_PI/2} 0" />
        <parent link="base_link"/>
        <child link="cliff_sensor_right_link" />
      </joint>
      <link name="cliff_sensor_right_link">
        <inertial>
          <mass value="0.0001" />
          <origin xyz="0 0 0" />
          <inertia ixx="0.0001" ixy="0.0" ixz="0.0"
                   iyy="0.0001" iyz="0.0"
                   izz="0.0001" />
        </inertial>
      </link>

      <joint name="cliff_sensor_front_joint" type="fixed">
        <origin xyz="0.156 0.00 0.0214" rpy="0 ${M_PI/2} 0" />
        <parent link="base_link"/>
        <child link="cliff_sensor_front_link" />
      </joint>
      <link name="cliff_sensor_front_link">
        <inertial>
          <mass value="0.0001" />
          <origin xyz="0 0 0" />
          <inertia ixx="0.0001" ixy="0.0" ixz="0.0"
                   iyy="0.0001" iyz="0.0"
                   izz="0.0001" />
        </inertial>
      </link>

      <!-- Kobuki Gazebo simulation details -->
      <kobuki_sim/>

    </xacro:macro>
  </robot>

#+END_SRC
****** kobuki_gazebo.urdf.xacro
#+BEGIN_SRC xml
  <?xml version="1.0"?>

  <robot name="kobuki_sim" xmlns:xacro="http://ros.org/wiki/xacro">
    <xacro:macro name="kobuki_sim">
      <gazebo reference="wheel_left_link">
        <mu1>1.0</mu1>
        <mu2>1.0</mu2>
        <kp>1000000.0</kp>
        <kd>100.0</kd>
        <minDepth>0.001</minDepth>
        <maxVel>1.0</maxVel>
      </gazebo>

      <gazebo reference="wheel_right_link">
        <mu1>1.0</mu1>
        <mu2>1.0</mu2>
        <kp>1000000.0</kp>
        <kd>100.0</kd>
        <minDepth>0.001</minDepth>
        <maxVel>1.0</maxVel>
      </gazebo>

      <gazebo reference="caster_front_link">
        <mu1>0.0</mu1>
        <mu2>0.0</mu2>
        <kp>1000000.0</kp>
        <kd>100.0</kd>
        <minDepth>0.001</minDepth>
        <maxVel>1.0</maxVel>
      </gazebo>

      <gazebo reference="caster_back_link">
        <mu1>0.0</mu1>
        <mu2>0.0</mu2>
        <kp>1000000.0</kp>
        <kd>100.0</kd>
        <minDepth>0.001</minDepth>
        <maxVel>1.0</maxVel>
      </gazebo>

      <gazebo reference="base_link">
        <mu1>0.3</mu1>
        <mu2>0.3</mu2>
        <sensor type="contact" name="bumpers">
          <always_on>1</always_on>
          <update_rate>50.0</update_rate>
          <visualize>true</visualize>
          <contact>
            <collision>base_footprint_collision_base_link</collision>
          </contact>
        </sensor>
      </gazebo>

      <gazebo reference="cliff_sensor_left_link">
        <sensor type="ray" name="cliff_sensor_left">
          <always_on>true</always_on>
          <update_rate>50</update_rate>
          <visualize>true</visualize>
          <ray>
            <scan>
              <horizontal>
                <samples>50</samples>
                <resolution>1.0</resolution>
                <min_angle>-0.0436</min_angle>  <!-- -2.5 degree -->
                <max_angle>0.0436</max_angle> <!-- 2.5 degree -->
              </horizontal>
              <!--            Can't use vertical rays until this bug is resolved: -->
              <!--            https://bitbucket.org/osrf/gazebo/issue/509/vertical-sensor-doesnt-works -->
              <!--                  <vertical> -->
              <!--                    <samples>50</samples> -->
              <!--                    <resolution>1.0</resolution> -->
              <!--                    <min_angle>-0.0436</min_angle>  -2.5 degree -->
              <!--                    <max_angle>0.0436</max_angle> 2.5 degree -->
              <!--                  </vertical> -->
            </scan>
            <range>
              <min>0.01</min>
              <max>0.15</max>
              <resolution>1.0</resolution>
            </range>
          </ray>
        </sensor>
      </gazebo>

      <gazebo reference="cliff_sensor_right_link">
        <sensor type="ray" name="cliff_sensor_right">
          <always_on>true</always_on>
          <update_rate>50</update_rate>
          <visualize>true</visualize>
          <ray>
            <scan>
              <horizontal>
                <samples>50</samples>
                <resolution>1.0</resolution>
                <min_angle>-0.0436</min_angle>  <!-- -2.5 degree -->
                <max_angle>0.0436</max_angle> <!-- 2.5 degree -->
              </horizontal>
              <!--            Can't use vertical rays until this bug is resolved: -->
              <!--            https://bitbucket.org/osrf/gazebo/issue/509/vertical-sensor-doesnt-works -->
              <!--                  <vertical> -->
              <!--                    <samples>50</samples> -->
              <!--                    <resolution>1.0</resolution> -->
              <!--                    <min_angle>-0.0436</min_angle>  -2.5 degree -->
              <!--                    <max_angle>0.0436</max_angle> 2.5 degree -->
              <!--                  </vertical> -->
            </scan>
            <range>
              <min>0.01</min>
              <max>0.15</max>
              <resolution>1.0</resolution>
            </range>
          </ray>
        </sensor>
      </gazebo>

      <gazebo reference="cliff_sensor_front_link">
        <sensor type="ray" name="cliff_sensor_front">
          <always_on>true</always_on>
          <update_rate>50</update_rate>
          <visualize>true</visualize>
          <ray>
            <scan>
              <horizontal>
                <samples>50</samples>
                <resolution>1.0</resolution>
                <min_angle>-0.0436</min_angle>  <!-- -2.5 degree -->
                <max_angle>0.0436</max_angle> <!-- 2.5 degree -->
              </horizontal>
              <!--                  Can't use vertical rays until this bug is resolved: -->
              <!--            https://bitbucket.org/osrf/gazebo/issue/509/vertical-sensor-doesnt-works -->
              <!--                  <vertical> -->
              <!--                    <samples>50</samples> -->
              <!--                    <resolution>1.0</resolution> -->
              <!--                    <min_angle>-0.0436</min_angle>  -2.5 degree -->
              <!--                    <max_angle>0.0436</max_angle> 2.5 degree -->
              <!--                  </vertical> -->
            </scan>
            <range>
              <min>0.01</min>
              <max>0.15</max>
              <resolution>1.0</resolution>
            </range>
          </ray>
        </sensor>
      </gazebo>

      <gazebo reference="gyro_link">
        <sensor type="imu" name="imu">
          <always_on>true</always_on>
          <update_rate>50</update_rate>
          <visualize>false</visualize>
          <imu>
            <noise>
              <type>gaussian</type>
              <rate>
                <mean>0.0</mean>
                <stddev>${0.0014*0.0014}</stddev> <!-- 0.25 x 0.25 (deg/s) -->
                <bias_mean>0.0</bias_mean>
                <bias_stddev>0.0</bias_stddev>
              </rate>
              <accel> <!-- not used in the plugin and real robot, hence using tutorial values -->
                <mean>0.0</mean>
                <stddev>1.7e-2</stddev>
                <bias_mean>0.1</bias_mean>
                <bias_stddev>0.001</bias_stddev>
              </accel>
            </noise>
          </imu>
        </sensor>
      </gazebo>

      <gazebo>
        <plugin name="kobuki_controller" filename="libgazebo_ros_kobuki.so">
          <publish_tf>1</publish_tf>
          <left_wheel_joint_name>wheel_left_joint</left_wheel_joint_name>
          <right_wheel_joint_name>wheel_right_joint</right_wheel_joint_name>
          <wheel_separation>.230</wheel_separation>
          <wheel_diameter>0.070</wheel_diameter>
          <torque>1.0</torque>
          <velocity_command_timeout>0.6</velocity_command_timeout>
          <cliff_sensor_left_name>cliff_sensor_left</cliff_sensor_left_name>
          <cliff_sensor_center_name>cliff_sensor_front</cliff_sensor_center_name>
          <cliff_sensor_right_name>cliff_sensor_right</cliff_sensor_right_name>
          <cliff_detection_threshold>0.04</cliff_detection_threshold>
          <bumper_name>bumpers</bumper_name>
          <imu_name>imu</imu_name>
        </plugin>
      </gazebo>
    </xacro:macro>
  </robot>
#+END_SRC

****** libgazebo_ros_kobuki.so
#+BEGIN_SRC sh
locate libgazebo_ros_kobuki.so
#+END_SRC

#+RESULTS:
| /home/ben/.ckws/devel/lib/libgazebo_ros_kobuki.so   |
| /home/ben/.ckws/install/lib/libgazebo_ros_kobuki.so |
| /opt/ros/indigo/lib/libgazebo_ros_kobuki.so         |


#+BEGIN_SRC sh
rospack find kobuki_gazebo_plugins
#+END_SRC

#+RESULTS:
: /home/ben/.ckws/src/kobuki_desktop/kobuki_gazebo_plugins

****** kobuki_gazebo_plugins CMakeLists.txt
#+BEGIN_SRC cmake
  find_package(gazebo REQUIRED)

  find_package(catkin REQUIRED COMPONENTS gazebo_ros
                                          gazebo_plugins
                                          geometry_msgs
                                          kobuki_msgs
                                          nav_msgs
                                          roscpp
                                          sensor_msgs
                                          std_msgs
                                          tf)

  catkin_package(INCLUDE_DIRS include
                 LIBRARIES gazebo_ros_kobuki
                 CATKIN_DEPENDS gazebo_ros
                                gazebo_plugins
                                geometry_msgs
                                kobuki_msgs
                                nav_msgs
                                roscpp
                                sensor_msgs
                                std_msgs
                                tf)

  link_directories(${GAZEBO_LIBRARY_DIRS})
  include_directories(include
                      ${catkin_INCLUDE_DIRS}
                      ${GAZEBO_INCLUDE_DIRS})

  add_library(gazebo_ros_kobuki src/gazebo_ros_kobuki.cpp
                                src/gazebo_ros_kobuki_updates.cpp
                                src/gazebo_ros_kobuki_loads.cpp)
  add_dependencies(gazebo_ros_kobuki geometry_msgs_gencpp
                                     kobuki_msgs_gencpp
                                     nav_msgs_gencpp
                                     sensor_msgs_gencpp
                                     std_msgs_gencpp)
  target_link_libraries(gazebo_ros_kobuki
                        ${catkin_LIBRARIES}
                        ${GAZEBO_LIBRARIES})

  install(TARGETS gazebo_ros_kobuki
          DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION})
#+END_SRC

****** gazebo_ros_kobuki.cpp
****** mux.yaml
#+BEGIN_SRC yaml
  # Created on: Oct 29, 2012
  #     Author: jorge
  # Configuration for subscribers to multiple cmd_vel sources.
  #
  # Individual subscriber configuration:
  #   name:           Source name
  #   topic:          The topic that provides cmd_vel messages
  #   timeout:        Time in seconds without incoming messages to consider this topic inactive
  #   priority:       Priority: an UNIQUE unsigned integer from 0 (lowest) to MAX_INT
  #   short_desc:     Short description (optional)

  subscribers:
    - name:        "Safe reactive controller"
      topic:       "input/safety_controller"
      timeout:     0.2
      priority:    10
    - name:        "Teleoperation"
      topic:       "input/teleop"
      timeout:     1.0
      priority:    7
    - name:        "Navigation"
      topic:       "input/navi"
      timeout:     1.0
      priority:    5
#+END_SRC
***** export the gazebo world
****** keyboard_teleop.launch

#+BEGIN_SRC xml
  <launch>
    <!-- turtlebot_teleop_key already has its own built in velocity smoother -->
    <node pkg="turtlebot_teleop" type="turtlebot_teleop_key" name="turtlebot_teleop_keyboard"  output="screen">
      <param name="scale_linear" value="0.5" type="double"/>
      <param name="scale_angular" value="1.5" type="double"/>
      <remap from="turtlebot_teleop_keyboard/cmd_vel" to="cmd_vel_mux/input/teleop"/>
    </node>
  </launch>
#+END_SRC
****** turtlebot_teleop_keyboard(python)
#+BEGIN_SRC python
  import rospy

  from geometry_msgs.msg import Twist

  import sys, select, termios, tty

  msg = """
  Control Your Turtlebot!
  ---------------------------
  Moving around:
     u    i    o
     j    k    l
     m    ,    .

  q/z : increase/decrease max speeds by 10%
  w/x : increase/decrease only linear speed by 10%
  e/c : increase/decrease only angular speed by 10%
  space key, k : force stop
  anything else : stop smoothly

  CTRL-C to quit
  """

  moveBindings = {
          'i':(1,0),
          'o':(1,-1),
          'j':(0,1),
          'l':(0,-1),
          'u':(1,1),
          ',':(-1,0),
          '.':(-1,1),
          'm':(-1,-1),
             }

  speedBindings={
          'q':(1.1,1.1),
          'z':(.9,.9),
          'w':(1.1,1),
          'x':(.9,1),
          'e':(1,1.1),
          'c':(1,.9),
            }

  def getKey():
      tty.setraw(sys.stdin.fileno())
      rlist, _, _ = select.select([sys.stdin], [], [], 0.1)
      if rlist:
          key = sys.stdin.read(1)
      else:
          key = ''

      termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
      return key

  speed = .2
  turn = 1

  def vels(speed,turn):
      return "currently:\tspeed %s\tturn %s " % (speed,turn)

  if __name__=="__main__":
      settings = termios.tcgetattr(sys.stdin)

      rospy.init_node('turtlebot_teleop')
      pub = rospy.Publisher('~cmd_vel', Twist, queue_size=5)

      x = 0
      th = 0
      status = 0
      count = 0
      acc = 0.1
      target_speed = 0
      target_turn = 0
      control_speed = 0
      control_turn = 0
      try:
          print msg
          print vels(speed,turn)
          while(1):
              key = getKey()
              if key in moveBindings.keys():
                  x = moveBindings[key][0]
                  th = moveBindings[key][1]
                  count = 0
              elif key in speedBindings.keys():
                  speed = speed * speedBindings[key][0]
                  turn = turn * speedBindings[key][1]
                  count = 0

                  print vels(speed,turn)
                  if (status == 14):
                      print msg
                  status = (status + 1) % 15
              elif key == ' ' or key == 'k' :
                  x = 0
                  th = 0
                  control_speed = 0
                  control_turn = 0
              else:
                  count = count + 1
                  if count > 4:
                      x = 0
                      th = 0
                  if (key == '\x03'):
                      break

              target_speed = speed * x
              target_turn = turn * th

              if target_speed > control_speed:
                  control_speed = min( target_speed, control_speed + 0.02 )
              elif target_speed < control_speed:
                  control_speed = max( target_speed, control_speed - 0.02 )
              else:
                  control_speed = target_speed

              if target_turn > control_turn:
                  control_turn = min( target_turn, control_turn + 0.1 )
              elif target_turn < control_turn:
                  control_turn = max( target_turn, control_turn - 0.1 )
              else:
                  control_turn = target_turn

              twist = Twist()
              twist.linear.x = control_speed; twist.linear.y = 0; twist.linear.z = 0
              twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = control_turn
              pub.publish(twist)

              #print("loop: {0}".format(count))
              #print("target: vx: {0}, wz: {1}".format(target_speed, target_turn))
              #print("publihsed: vx: {0}, wz: {1}".format(twist.linear.x, twist.angular.z))

      except:
          print e

      finally:
          twist = Twist()
          twist.linear.x = 0; twist.linear.y = 0; twist.linear.z = 0
          twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = 0
          pub.publish(twist)

      termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
#+END_SRC

******* 私有名字以~开头，其命名空间为当前package

******* 减速要慢慢来

******* 这是重要的不是Python的函数，而是该脚本publish的topic: ~cmd_vel(geometry_msgs/Twist)
****** 将Gazebo中的运动驱动剥离出来
****** test kobuki
1. xacro脚本不支持对～的路径扩展，须使用绝对路径
2.

***** gmapping_demo.launch
#+BEGIN_SRC xml
  <launch>
    <include file="$(find turtlebot_navigation)/launch/includes/gmapping.launch.xml"/>
  </launch>
#+END_SRC
***** turtlebot_rviz_launchers view_navigation.launch
#+BEGIN_SRC xml
  <launch>
    <node name="rviz" pkg="rviz" type="rviz" args="-d $(find turtlebot_rviz_launchers)/rviz/navigation.rviz"/>
  </launch>
#+END_SRC  <<turtlebot

*** [[http://wiki.ros.org/kobuki][kobuki]]

*** [[http://wiki.ros.org/kobuki_desktop][kobuki_desktop]]
*** yujin_ocs

**** [[http://wiki.ros.org/cmd_vel_mux][cmd_vel_mux]]

*** pr2

#+include: ~/catkin_ws/src/pr2

**** [[http://wiki.ros.org/pr2_common][pr2_common]]

#+include: ~/catkin_ws/src/pr2/pr2_common

https://github.com/PR2/pr2_common

***** compile

1. ivcon

   #+BEGIN_EXAMPLE
   /bin/sh: 1: ivcon: not found
   #+END_EXAMPLE

   - ivcon [[http://wiki.ros.org/ivcon][ros::ivcon]]

   - synaptic : ros-jade-ivcon

     #+BEGIN_EXAMPLE
       Mesh Conversion Utility Used to generate '.iv' files from '.stl' files.
       This package has not been changed since 2001 and appears to be very stable.
       We plan on keeping this package in this revision for mesh conversions.
       This package is only available as a single source file for download.
       There are no local modifications to this package.
     #+END_EXAMPLE

   - sudo apt-get install ros-jade-ivcon

2. convex_decomposition

   #+BEGIN_EXAMPLE
   /bin/sh: 1: /bin/sh: 1: convex_decomposition: not found
   #+END_EXAMPLE

   [[http://wiki.ros.org/convex_decomposition][convex_decomposition]] : Convex Decomposition Tool for Robot Model

3. DONE

***** Package Summary

Released Continuous integration Documented

URDF description of the robot kinematics and dynamics, 3D models of
robot components, information required for gazebo to simulate the PR2,
and messages specific to the PR2 such as detailed information about its
power board and fingertip pressure sensors.



****** Overview

This stack contains no code, just definitions of the PR2 robot, and
robot-specific messages for the in-hand accelerometer, the the fingertip
pressure sensors, the tilting laser, and the power system. These
components are useful for running a PR2, either in actual hardware or in
a simulator.

-  [[/pr2_description][pr2_description]] describes the beta and
   production PR2 robots.
-  [[/pr2_msgs][pr2_msgs]] contains several messages that are useful
   for the PR2, but not sufficiently general to be used on other robots.
-  [[/pr2_machine][pr2_machine]] contains machine files, for inclusion
   from [[/roslaunch][roslaunch]] files, so that applications for the
   PR2 can be run on either the robot or the simulator without having to
   have the computer information hard-coded into them.

This stack is unlikely to be a good starting point. Recommended starting
points:

-  [[/pr2_robot][pr2_robot]] if you have PR2 hardware
-  [[/pr2_simulator][pr2_simulator]] if you want to run a PR2 in
   simulation
-  [[/robot_model][robot_model]] if you want to understand how to parse
   these robot description files

****** Documentation

This stack is not intended for user consumption. Check the
[[/robot_model][robot_model]] documentation for how to interpret this
data, or look at the examples in [[/pr2_gazebo][pr2_gazebo]]

**** [[http://wiki.ros.org/pr2_gazebo][pr2_gazebo]]

#+include: ~/catkin_ws/src/pr2/pr2_common

+ https://github.com/PR2/pr2_simulator

***** compile

#+BEGIN_EXAMPLE
  CMake Error at /opt/ros/jade/share/catkin/cmake/catkinConfig.cmake:75 (find_package):
    Could not find a package configuration file provided by
    "pr2_controller_manager" with any of the following names:

      pr2_controller_managerConfig.cmake
      pr2_controller_manager-config.cmake
#+END_EXAMPLE

#+BEGIN_EXAMPLE
   Could not find a package configuration file provided by
    "pr2_mechanism_msgs" with any of the following names:
#+END_EXAMPLE

http://wiki.ros.org/pr2_mechanism_msgs

***** running

#+BEGIN_EXAMPLE
 cannot launch node of type [robot_pose_ekf/robot_pose_ekf]: robot_pose_ekf
#+END_EXAMPLE

navigation stack

#+BEGIN_EXAMPLE
  The PR2 Simulator packages have not been released into Hydro yet.
  If you would like to use the PR2 Simulator, please use Groovy or earlier.
#+END_EXAMPLE

*运行错误太多* 还是不要折腾了！！！

**** [[http://wiki.ros.org/pr2_mechanism?distro=indigo][pr2_mechanism]]

***** stack

The pr2_mechanism stack contains the infrastructure to control the PR2
robot in a hard realtime control loop.

****** Overview

The =pr2_mechanism= stack contains useful libraries if you want to write
a realtime controller to interact with the PR2 (or similar) robot. These
libraries are contained in the following ROS packages:

-  [[/pr2_controller_interface][pr2_controller_interface]]: The C++
   interface for a realtime controller
-  [[/pr2_controller_manager][pr2_controller_manager]]: The
   infrastructure that allows you to run and manage multiple controllers
   in a realtime loop
-  [[/pr2_hardware_interface][pr2_hardware_interface]]: The C++
   interface for the PR2 hardware, containing actuators, pressure
   sensors, accelerometers, digital out and projector interface.
-  [[/pr2_mechanism_model][pr2_mechanism_model]]: The model of an
   effort controlled robot, based on the [[/urdf][urdf]] robot
   description format.
-  [[/pr2_mechanism_msgs][pr2_mechanism_msgs]]: Messages used to
   communicate with the realtime control loop, and messages that contain
   the state of the realtime controllers, the joints and the actuators.
-  [[/realtime_tools][realtime_tools]]: A tool to publish to a ROS
   topic from realtime.

***** [[http://ros.org/pr2_controller_manager][pr2_controller_manager]]

https://github.com/pr2/pr2_mechanism

*** [[http://www.ros.org/news/2015/09/erle-spider-the-ubuntu-drone-with-legs.html][Erle-Spider]]
** Control
*** [[http://wiki.ros.org/ros_control][ros_control]]                                                :roscontrol:

**** [[http://wiki.ros.org/controller_manager][controller_manager]]

*** [[http://wiki.ros.org/ros_controllers][ros_controllers]]

**** [[http://wiki.ros.org/diff_drive_controller?distro=hydro][diff_drive_controller]]

**** [[http://wiki.ros.org/joint_state_controller?distro=hydro][joint_state_controller]]

** Interface
*** [[http://wiki.ros.org/rosserial][rosserial]]                                                   :rosserial:

**** [[http://wiki.ros.org/rosserial_embeddedlinux][rosserial_embeddedlinux]]                               :embeddedlinux:

**** [[http://wiki.ros.org/rosserial_arduino][rosserial_arduino]]                                           :arduino:

***** IDE setup
1. install ros-indigo-rosserial and ros-indigo-rosserial-arduino
2. install *ros_lib* into the Arduino Environment
   *rosrun rosserial_arduino makelibrary <path/to/libraries>*

***** Hello World(as publisher)

****** src
#+begin_latex
\begin{minted}[frame=single, mathescape]{c}
#include <ros.h>
#include <std_msgs/String.h>

ros::NodeHandle nh;

std_msgs::String str_msg;
ros::Publisher chatter("chatter", &str_msg);

char hello[13] = "hello world!";

void setup()
{
  nh.initNode();
  nh.advertise(chatter);
}

void loop()
{
  str_msg.data = hello;
  chatter.publish(&str_msg);
  nh.spinOnce();
  delay(1000);
}
\end{minted}
#+end_latex

创建ROS节点需要做那些事情？
1. ros::NodeHandle
2. ros::NodeHandle::Method(advertise/subscribe) -> 绑定方法
   1) advertise <-> ros::Publisher
   2) subscribe <-> ros::Subscriber
3. Method implements(实现方法)
   1) *Publisher(topic, reference_to_msg)*
   2) *Subscriber<msg_type>(topic, &HandFunc)*

****** uploading
1. upload in Arduino IDE(easy to go)
2. upload in Emacs
   + ardpro.sh <PROJECT>
   + M-x compile make -k upload
     + <ros.h>找不到？ -> *在ros_lib目录下编写* 在其它目录下编写则有问
       题， /why?/  __暂时折衷笨方法__
     + 路径如何设置？ -> *makefile文件中缺省即可*

*在Arduino与ROS通信时下载程序会连接失败*

****** running
+ roscore&
+ *rosserial client*
  *rosrun rosserial_python serial_node /dev/ttyACM0*
+ rostopic echo chatter

***** Blink(as subscriber)
#+begin_latex
\begin{minted}[frame=single, mathescape]{c}
/*
 * rosserial Subscriber Example
 * Blinks an LED on callback
 */

#include <ros.h>
#include <std_msgs/Empty.h>

ros::NodeHandle nh;

boolean lit = false;
int ledPin = 13;

void messageCb( const std_msgs::Empty& toggle_msg){
  lit = !lit;
  if(lit)
    digitalWrite(ledPin, HIGH-digitalRead(13));   // blink the led
  else
    digitalWrite(ledPin, LOW);
}



ros::Subscriber<std_msgs::Empty> sub("toggle_led", &messageCb );

void setup()
{
  pinMode(13, OUTPUT);
  nh.initNode();
  nh.subscribe(sub);
}

void loop()
{
  nh.spinOnce();
  delay(1);
}
\end{minted}
#+end_latex

***** Using Time and TF
The rosserial_arduino package contains libraries for generating
timestamps on the Arduino which are synchronized with the PC/Tablet on
which the roscore instance is running.


#+begin_latex
\begin{minted}[frame=single, mathescape]{c}
/*
 * rosserial Time and TF Example
 * Publishes a transform at current time
*/


#include <ros.h>
#include <ros/time.h>
#include <tf/transform_broadcaster.h>

ros::NodeHandle nh;

geometry_msgs::TransformStamped t;
tf::TransformBroadcaster broadcaster;

char base_link[] = "/base_link";
char odom[] = "/odom";

void setup()
{
  nh.initNode();
  broadcaster.init(nh);
}

void loop()
{
  t.header.frame_id = odom;
  t.child_frame_id = base_link;
  t.transform.translation.x = 1.0;
  t.transform.rotation.x = 0.0;
  t.transform.rotation.y = 0.0;
  t.transform.rotation.z = 0.0;
  t.transform.rotation.w = 1.0;
  t.header.stamp = nh.now();
  broadcaster.sendTransform(t);
  nh.spinOnce();
  delay(10);
}
\end{minted}
#+end_latex

1. TF broadcaster

***** Temperature Sensor
1. sensor node
2. Arduino as IIC interface for ROS
3. Wire Library

***** Push Button
1. No pullup resistor(builtin)
2. debounce

***** CMake with rosserial_arduino
When you are doing large software projects, the Arduino IDE quickly
becomes unwieldly

1. catkin方式，更ROS化，不用将文件放到特定位置
   1) catkin_init_workspace
2. cpp而不是ino文件，IDE更友好



1. create package
   catkin_create_pkg helloworld rosserial_arduino rosserial_client std_msgs

2. source code
   in *firmware* sub-directory
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{cpp}
     #include <ros.h>
     #include <std_msgs/String.h>

     #include <Arduino.h>

     ros::NodeHandle nh;

     std_msgs::String str_msg;
     ros::Publisher chatter("chatter", &str_msg);

     char hello[] = "hello world!";

     void setup()
     {
       nh.initNode();
       nh.advertise(chatter);
     }

     void loop()
     {
       str_msg.data = hello;
       chatter.publish(&str_msg);
       nh.spinOnce();
       delay(1000);
     }

     \end{minted}
   #+end_latex

   + explicitly include a header file which contains all of the
     Arduino functions

3. CMakelists
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{cmake}
     cmake_minimum_required(VERSION 2.8.3)
     project(helloworld)

     find_package(catkin REQUIRED COMPONENTS
       rosserial_arduino
       rosserial_client
       std_msgs
     )

     catkin_package()

     rosserial_generate_ros_lib(
       PACKAGE rosserial_arduino
       SCRIPT make_libraries.py
       )

     rosserial_configure_client(
       DIRECTORY firmware
       TOOLCHAIN_FILE ${ROSSERIAL_ARDUINO_TOOLCHAIN}
       )

     rosserial_add_client_target(firmware hello ALL)
     rosserial_add_client_target(firmware hello-upload)


     include_directories(
       ${catkin_INCLUDE_DIRS}
     )
     \end{minted}
   #+end_latex

   + rosserial_generate_ros_lib:
   + rosserial_configure_client
   + rosserial_add_client_target

4. sub-project
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{cmake}
     cmake_minimum_required(VERSION 2.8.3)

     include_directories(${ROS_LIB_DIR})

     add_definitions(-DUSB_CON)

     generate_arduino_firmware(hello
       SRCS chatter.cpp ${ROS_LIB_DIR}/time.cpp
       BOARD uno
       PORT /dev/ttyACM0
       )
     \end{minted}
   #+end_latex

5. build
   catkin_make helloworld_firmware_hello  *注意命名*
   catkint_make helloworld_firmware_hello-upload

6. running
   rosrun rosserail_poython serial_node.py /dev/ttyACM0

*** can                                                               :can:
**** [[http://wiki.ros.org/cob_generic_can][cob_generic_can]]

The package cob_generic_can provides an interface for nodes on a
can-bus and examplary wrappers for two PeakSys-can-libs. When a
can-bus-device is generated (for an example see base_dirve_chain) you
can use generic_can to create as many itfs as there will be components
communicating via this can-bus. Assign type of the can communication
device (e.g. usb-to-can or can-card of a specific vendor) and
can-address of the target device. This package comes with wrappers for
PeakSys and PeakSysUSB adapters.

前提是了解CAN bus 协议。

**** [[http://answers.ros.org/question/123091/does-a-can-bus-library-or-package-exist-in-ros/][CAN bus library in ROS?]]

AFAIK there is no really 'generic CAN driver node' available, but some
packages that interface to CAN do exist. For instance the
cob_generic_can package:
#+BEGIN_EXAMPLE
The package cob_generic_can provides an interface for nodes on a
can-bus and examplary wrappers for two PeakSys-can-libs. When a
can-bus-device is generated (for an example see cob_base_drive_chain)
you can use generic_can to create as many itfs as there will be
components communicating via this can-bus. Assign type of the can
communication device (e.g. usb-to-can or can-card of a specific
vendor) and can-address of the target device. This package comes with
wrappers for PeakSys and PeakSysUSB adapters.
#+END_EXAMPLE

I'm not sure you can directly use this for your specific setup, but it
should provide you with enough pointers to get something going.

没有现成的通用CAN bus node, 但有特定的面向某个机器人，可以借鉴。

**** [[https://github.com/linux-can][Linux can]]

+ https://github.com/linux-can/can-utils

**** [[http://answers.ros.org/question/11691/how-to-communicate-the-hardware-to-a-realtime-controller/][CAN realtime?]]

If you're talking to the controller over a CAN bus, which is not
realtime safe. There's no way to implement a realtime controller in
software.

A common way to do a realtime controller is to have the realtime
thread and a non-realtime thread which does the external
communications, and passes data into the realtime thread in a lock
free manner. You can do this but it's not going to be worth the effort
if you're on the other side of a CAN bus. Realtime requirements are
about guaranteeing maximum response times, if there's ever a link
which cannot provide those guarantees you cannot continue to be
realtime beyond that connection.

**** [[http://answers.ros.org/question/46338/communication-with-microcontroller-via-can/][Communication with microcontroller via CAN]]

Q:
Hi, our team want to develop an autonomous car on the basis of a
RC-Car. As framework we want to use ROS. Unfortunately none of us has
any experiences with ROS.

The microcontroller that interfaces with the hardware of the car shall
communicate with an embedded PC via CAN. The embedded PC has a CAN
interface. I have found the can_communication stack, which contains a
package called can_msgs. If I have understood right this package
provides only a CAN library for ROS and is not executable. Is there
something like a ready CAN-node? Unless how can I realize a CAN
communication? Currently I'm the only person which works on the
software. Unfortunately I have not many experiences in this
field. Hence I would be very grateful for any help

Ans:
Expanding from dornhege, I would first write some Python/C++ code that
communicates with the microcontroller. You could use the CAN drivers
that are included with Linux, which are called Socket-CAN. There
should be plenty of example code using that, on the internet. Once you
can send/receive CAN messages, you then need to design the commands
for a software driver for your car, eg. turnLeft() driveForward()
which take a control command and send a CAN message.

Once you have your driver for the car working, you can incorporate it
into ROS. You should read all the tutorials and write some publisher
and subscriber nodes. Then you need to implement your higher level
commands as a ROS subscriber, eg. if a tele-operation node publishes a
Float64 message on the /drive_forward_command topic, the subscriber
inside your rc_car_driver node gets a callback and processes the
contents of the ROS message, sending the velocity value to the
driveForward() function.

This post is useful:
http://answers.ros.org/question/11691/how-to-communicate-the-hardware-to-a-realtime-controller/

It could be a lot of work to implement this when your microcontroller
and the embedded PC are sitting next to each other. Another
possibility is: http://www.ros.org/wiki/rosserial It sounds like it's
pretty easy to send rosserial messages directly to an arduino:
http://answers.ros.org/question/12464/splitting-work-between-ros-and-a-custom-motor-controller-board/


Usually, this is part of the driver itself (at least for our
implementations) and the ROS abstraction layer is higher, e.g., things
like odometry or velocity commands.

CAN是底层，ROS封装是高层抽象，这样考虑问题。

** Communication
*** msg
**** nav_msgs/OccupanyGrid

1. File: nav_msgs/OccupancyGrid.msg


1. Raw Message Definition

   #+BEGIN_EXAMPLE
     # This represents a 2-D grid map, in which each cell represents the probability of
     # occupancy.

     Header header

     #MetaData for the map
     MapMetaData info

     # The map data, in row-major order, starting with (0,0).  Occupancy
     # probabilities are in the range [0,100].  Unknown is -1.
     int8[] data
   #+END_EXAMPLE

2. Compact Message Definition

   #+BEGIN_EXAMPLE
     std_msgs/Header header
     nav_msgs/MapMetaData info
     int8[] data
   #+END_EXAMPLE

**** nav_msgs/MapMetaData

1. File: nav_msgs/MapMetaData.msg

2. Raw Message Definition

   #+BEGIN_EXAMPLE
     # This hold basic information about the characterists of the OccupancyGrid

     # The time at which the map was loaded
     time map_load_time
     # The map resolution [m/cell]
     float32 resolution
     # Map width [cells]
     uint32 width
     # Map height [cells]
     uint32 height
     # The origin of the map [m, m, rad].  This is the real-world pose of the
     # cell (0,0) in the map.
     geometry_msgs/Pose origin
   #+END_EXAMPLE

3. Compact Message Definition

   #+BEGIN_EXAMPLE
     time map_load_time
     float32 resolution
     uint32 width
     uint32 height
     geometry_msgs/Pose origin
   #+END_EXAMPLE

*** [[http://wiki.ros.org/common_msgs][common_msgs]]

**** overview

common_msgs contains messages that are widely used by other ROS
packages. These includes messages for actions (actionlib_msgs),
diagnostics (diagnostic_msgs), geometric primitives (geometry_msgs),
robot navigation (nav_msgs), and common sensors (sensor_msgs), such as
laser range finders, cameras, point clouds.

**** std_msgs
+ http://wiki.ros.org/std_msgs

***** overview
Standard ROS Messages including common message types representing
primitive data types and other basic message constructs, such as
multiarrays.
***** ROS Message Types
****** Bool
****** Byte
****** ByteMultiArray
****** Char
****** ColorRGBA
****** Duration
****** Empty
****** Float32
****** Float32MultiArray
****** Float64
****** Float64MultiArray
****** Header
****** Int16
****** Int16MultiArray
****** Int32
****** Int32MultiArray
****** Int64
****** Int64MultiArray
****** Int8
****** Int8MultiArray
****** MultiArrayDimension
****** MultiArrayLayout
****** String
#+BEGIN_SRC sh :results output
rosmsg show std_msgs/String
#+END_SRC

#+RESULTS:
: string data
:



****** Time
****** UInt16
****** UInt16MultiArray
****** UInt32
****** UInt32MultiArray
****** UInt64
****** UInt64MultiArray
****** UInt8
****** UInt8MultiArray

** Tutorials
*** [[http://wiki.ros.org/ros_tutorials?distro=jade][ros_tutorials]]
**** [[http://wiki.ros.org/roscpp_tutorials?distro=jade][roscpp_tutorials]]
***** [[http://wiki.ros.org/roscpp_tutorials/Tutorials/WritingPublisherSubscriber][Writing a Simple Publisher and Subscriber]]

#+INCLUDE: ~/Wally/Journal/catkin_ws/src/tutorials/roscpp_tutorials

***** [[http://wiki.ros.org/roscpp_tutorials/Tutorials/WritingServiceClient][Writing a Simple Service and Client]]
***** [[http://wiki.ros.org/roscpp_tutorials/Tutorials/Parameters][Using Parameters in roscpp]]
***** [[http://wiki.ros.org/roscpp_tutorials/Tutorials/AccessingPrivateNamesWithNodeHandle][Accessing Private Names from a NodeHandle]]
***** [[http://wiki.ros.org/roscpp_tutorials/Tutorials/UsingClassMethodsAsCallbacks][Using Class Methods as Callbacks]]
***** [[http://wiki.ros.org/roscpp_tutorials/Tutorials/Timers][Understanding Timers]]
***** [[http://wiki.ros.org/roscpp_tutorials/Tutorials/Publisher%20and%20Subscriber%20with%20Parameters%20and%20Dynamic%20Reconfigure][Dynamic Reconfigure]]
**** rospy
**** turtlesim

*** ros by example
**** testing simulator P53
***** use_sim_time
将fake_turtlebot.launch中的 param /use_sim_time 修改为 true, 导致Rviz
加载RobotModel display 失败 error:no transform form

****** wall-clock
+ use computer's system clock as a time source
+ synchronization between multiple machine: ntp
- 网络时间协议（英语：Network Time Protocol，[[http://www.ntp.org/][NTP]] ）是以分组交换把
  两台电脑的时钟同步化的网络传输协议。NTP使用UDP端口123作为传输层。
  它是用作抵销可变延迟的影响。
- [[http://chrony.tuxfamily.org/][chrony]] is a versatile implementation of the Network Time
  Protocol (NTP). It can synchronize the system clock with NTP
  servers, reference clocks (e.g. GPS receiver), and manual input
  using wristwatch and keyboard. It can also operate as an NTPv4
  (RFC 5905) server and peer to provide a time service to other
  computers in the network. [recommanded]
- necessary for *tf*

****** simulated clock
+ the ROS client libraries can listen to the /clock topic that is
  used to publish "simulation time"
+ In order for a ROS node to use simulation time according to the
  /clock topic, the /use_sim_time parameter must be set to true
  before the node is initialized.

***** 去除 urdf.xacro 中 robot 标签的冗余属性，证实
   http://www.gazebosim.org/tutorials?tut=ros_urdf&cat=connect_ros
   <Header of a URDF file> 的note。
   #+BEGIN_SRC xml :outputs
     <robot xmlns:sensor="http://playerstage.sourceforge.net/gazebo/xmlschema/#sensor"
            xmlns:controller="http://playerstage.sourceforge.net/gazebo/xmlschema/#controller"
            xmlns:interface="http://playerstage.sourceforge.net/gazebo/xmlschema/#interface"
            xmlns:xacro="http://playerstage.sourceforge.net/gazebo/xmlschema/#interface"
            name="pr2" >
     </robot>
   #+END_SRC

**** odometry: beyond just PID control

the robot's base controller node uses odometry
and PID control to turn motion requests into real-world velocities. The accuracy and
reliability of this process depends on the robot's internal sensors, the accuracy of the
calibration procedure, and environmental conditions.


1. mark assistant(indoor)
   + ar_pose: http://wiki.ros.org/ar_pose
   + ar_kinect: http://wiki.ros.org/ar_kinect
   + ar_track_alvar: http://wiki.ros.org/ar_track_alvar
2. slam
   + ccny_rgbd_tools: http://wiki.ros.org/ccny_rgbd_tools
   + rgbdslam: http://wiki.ros.org/rgbdslam
   + laser_scan_matcher: http://wiki.ros.org/laser_scan_matcher
3. GPS: http://wiki.ros.org/robot_pose_ekf/Tutorials/AddingGpsSensor

**** message: nav_msgs/Odometry
#+BEGIN_SRC sh :results output
rosmsg show nav_msgs/Odometry
#+END_SRC

#+RESULTS:
#+begin_example
std_msgs/Header header
  uint32 seq
  time stamp
  string frame_id
string child_frame_id
geometry_msgs/PoseWithCovariance pose
  geometry_msgs/Pose pose
    geometry_msgs/Point position
      float64 x
      float64 y
      float64 z
    geometry_msgs/Quaternion orientation
      float64 x
      float64 y
      float64 z
      float64 w
  float64[36] covariance
geometry_msgs/TwistWithCovariance twist
  geometry_msgs/Twist twist
    geometry_msgs/Vector3 linear
      float64 x
      float64 y
      float64 z
    geometry_msgs/Vector3 angular
      float64 x
      float64 y
      float64 z
  float64[36] covariance

#+end_example

By convention, odometry measurements in ROS use /odom as the parent
frame id and /base_link (or /base_footprint ) as the child frame
id. While the /base_link frame corresponds to a real physical part of
the robot, the /odom frame is defined by the translations and
rotations encapsulated in the odometry data.

**** Navigation, Path Planning, and SLAM
***** hardware
+ laser scanner(reliable)
+ Microsoft Kinect & Asus Xtion camera(generate a 'fake' laser scan)(TurtleBot)
  - depthimage_to_laserscan: http://wiki.ros.org/depthimage_to_laserscan
  - kinect_2d_scanner: http://wiki.ros.org/kinect_2d_scanner
+ Neato_robot: http://ros.org/wiki/neato_robot

***** core package
1. move_base: http://wiki.ros.org/move_base
2. gmapping: http://wiki.ros.org/gmapping
3. amcl: http://wiki.ros.org/amcl

***** prepare
+ navigation robot setup: http://wiki.ros.org/navigation/Tutorials/RobotSetup
+ Navigation Tutorials: http://wiki.ros.org/navigation/Tutorials
+ SLAM online course: http://www.udacity.com/overview/Course/cs373/CourseRev/apr2012

***** path planning and obstacle avoidance using move_base
****** action
Recall that actions provide feedback as progress is made toward the
goal. This means we no longer have to query the odometry topic
ourselves to find out if we have arrived at the desired location.
****** MoveBaseAction: to specify navigation goals using move_base
#+BEGIN_SRC sh :results output
rosmsg show -r MoveBaseActionGoal
#+END_SRC

#+RESULTS:
: [move_base_msgs/movebaseactiongoal]:
: # ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======
:
: header header
: actionlib_msgs/GoalID goal_id
: MoveBaseGoal goal
:
****** configuration parameters for plan planning
The move_base node requires four configuration files before it can be
run. These files define a number of parameters related to the cost of
running into obstacles, the radius of the robot, how far into the
future the path planner should look, how fast we want the robot to
move and so on.

+ base_local_planner_params.yaml
+ costmap_common_params.yaml
+ global_costmap_params.yaml
+ local_costmap_params.yaml

****** map

***** point and click navigation in Rviz

***** avoiding simulated obstacles
One of the most powerful features of /move_base/ is the ability to
*avoid obstacles while still setting to the goal*.

Obstacles can be *a static part* of the current map, or they can
appear dynamically such as when someone walks in front of the robot.

**** map building using the /gmapping/ Package

A map in ROS is simply a bitmap image representing an occupancy grid
where:
+ white pixels indicate free space
+ black pixels represent obstacles
+ grey pixels stand for "unkown"


The usual strategy is first to teleoperate the robot around an area
while recording the laser and odometry data in a rosbag file. Then run
the /slam_gmapping/ node against the recorded data to generate a map.

***** laser scanner or depth camera

****** depthimage_to_laserscan
http://wiki.ros.org/depthimage_to_laserscan

**** The /odom Topic versus the /odom Frame
The reader may be wondering why we used a TransformListener in the previous
script to access odometry information rather than just subscribing to the /odom topic.
The reason is that the data published on the /odom topic is not always the full story. For
example, the TurtleBot uses a single-axis gyro to provide an additional estimate of the
robot's rotation. This is combined with the data from the wheel encoders by the
robot_pose_ekf node (which is started in the TurtleBot launch file) to get a better
estimate of rotation than either source alone.

However, the robot_pose_ekf node does not publish its data back on the /odom topic
which is reserved for the wheel encoder data. Instead, it publishes it on the
/odom_combined topic. Furthermore, the data is published not as an Odometry
message but as a PoseWithCovarianceStamped message. It does however, publish a
transform from the /odom frame to the /base_link frame which provides the
information we need.

*As a result, it is generally safer to use tf to monitor the*
*transformation between the /odom and /base_link (or /base_footprint )*
*frames than to rely on the /odom message topic*

**** move base


**** Servos

*It is hard to beat* a *pan-and-tilt* head for adding life-like behavior
to your robot.

***** servos
+ Robotics Dynamixel: http://www.robotis.com/xe/dynamixel_en
+ AX-12:
  http://www.trossenrobotics.com/dynamixel-ax-12-robot-actuator.aspx

We can now see why Dynamixel servos are a good fit with ROS: namely, we can query
each servo for its current position, velocity and torque which is exactly the data we need
to fill in the JointState message.

***** controller
dynamixel_controllers: http://wiki.ros.org/dynamixel_controllers

****** dynamixel_motor(stack)
+ dynamixel_controller
+ dynamixel_driver
+ dynamixel_msgs
+ dynamixel_tutorials


This package contains a configurable node, services and a spawner
script to start, stop and restart one or more controller
plugins. Reusable controller types are defined for common Dynamixel
motor joints. Both speed and torque can be set for each joint. This
python package can be used by more specific robot controllers and all
configurable parameters can be loaded via a yaml file.

****** dynamixel_controllers
+ http://wiki.ros.org/dynamixel_controllers


Note: For some reason, the full documentation is not showing up on the
Groovy and Hydro Wiki pages.


This package contains a configurable node, services and a spawner script
to start, stop and restart one or more controller plugins. Reusable
controller types are defined for common Dynamixel motor joints. Both
speed and torque can be set for each joint. This python package can be
used by more specific robot controllers and all configurable parameters
can be loaded via a yaml file.

-  Maintainer status: maintained
-  Maintainer: Antons Rebguns <arebgun AT gmail DOT com>
-  Author: Antons Rebguns, Cody Jorgensen, Cara Slutter
-  License: BSD
-  Bug / feature tracker: [[https://github.com/arebgun/dynamixel_motor]]
-  Source: git
   [[https://github.com/arebgun/dynamixel_motor][https://github.com/arebgun/dynamixel_motor.git]]
   (branch: master)

******* Available Joint Controllers

-  [[/dynamixel_controllers/JointPositionController][joint_position_controller]]
-  [[/dynamixel_controllers/JointTorqueController][joint_torque_controller]]
-  [[/dynamixel_controllers/JointPositionControllerDual][joint_position_controller_dual_motor]]
-  [[/dynamixel_controllers/JointTorqueControllerDual][joint_torque_controller_dual_motor]]
-  [[/dynamixel_controllers/JointTrajectoryActionController][joint_trajectory_action_controller]]

******* ROS API

******** API Stability

-  ROS API is UNREVIEWED but UNSTABLE
-  Python API is UNREVIEWED and UNSTABLE

******** controller_manager.py

Manages a single serial connection to Dynamixel servo network. This node
provides services to start, stop and restart joint controllers. There
can be several instances of controller_manager running at the same
time, managing multiple serial connections.
********* Services

=start_controller/serial_port_name=
([[http://docs.ros.org/api/dynamixel_controllers/html/srv/StartController.html][dynamixel_controllers/StartController]])

-  Start stopped joint controller managed by this controller manager.

=stop_controller/serial_port_name=
([[http://docs.ros.org/api/dynamixel_controllers/html/srv/StopController.html][dynamixel_controllers/StopController]])

-  Stop running joint controller managed by this controller manager.

=restart_controller/serial_port_name=
([[http://docs.ros.org/api/dynamixel_controllers/html/srv/RestartController.html][dynamixel_controllers/RestartController]])

-  Restart running joint controller managed by this controller manager
   (a shortcut to running Stop and then Start).

********* Parameters

=~port_name= (=str=, default: /dev/ttyUSB0)

-  Path to serial port that the Dynamixel motors are connected to.

=~baud_rate= (=int=, default: 1000000)

-  Baud rate to use (make sure that the motors are set to the same baud
   rate, otherwise the controller_manager node will not be able to find
   any motors).

=~min_motor_id= (=int=, default: 1)

-  The valid motor id range is 1 - 253. Setting min_motor_id to your
   actual range of motor ids will cut node startup time.

=~max_motor_id= (=int=, default: 25)

-  The valid motor id range is 1 - 253. Setting max_motor_id to your
   actual range of motor ids will cut node startup time.

=~update_rate= (=int=, default: 5)

-  The rate (in Hz) at which motors will publish their status (current
   position, velocity, temperature, load, etc.) Setting this to 0 will
   turn off the feedback.

******** controller_spawner.py

********* Parameters

=joint_controller_name/controller/package= (=str=)

-  ROS package name that contains the controller code.

=joint_controller_name/controller/module= (=str=)

-  Specific file (python module) within a package that contains the
   controller code.

=joint_controller_name/controller/type= (=str=)

-  Class name within module that implements
   [[http://ua-ros-pkg.googlecode.com/svn/stacks/dynamixel_motor/trunk/dynamixel_controllers/src/dynamixel_controllers/joint_controller.py][JointController]]
   interface.

******** Common Joint Controller Interface

********* Subscribed Topics

=joint_controller_name/command=
([[http://docs.ros.org/api/std_msgs/html/msg/Float64.html][std_msgs/Float64]])

-  Listens for a joint angle (in radians) to be sent to the controller.

=motor_states/serial_port_name=
([[http://docs.ros.org/api/dynamixel_msgs/html/msg/MotorStateList.html][dynamixel_msgs/MotorStateList]])

-  Listens for motor status feedback published by low level driver.

********* Published Topics

=joint_controller_name/state=
([[http://docs.ros.org/api/dynamixel_msgs/html/msg/JointState.html][dynamixel_msgs/JointState]])

-  Provides current joint status information (current goal, position,
   velocity, load, etc.)

********* Services

=joint_controller_name/set_speed=
([[http://docs.ros.org/api/dynamixel_controllers/html/srv/SetSpeed.html][dynamixel_controllers/SetSpeed]])

-  Change the current velocity of the joint (specified in radians per
   second).

=joint_controller_name/torque_enable=
([[http://docs.ros.org/api/dynamixel_controllers/html/srv/TorqueEnable.html][dynamixel_controllers/TorqueEnable]])

-  Turn joint torque on or off.

=joint_controller_name/set_compliance_slope=
([[http://docs.ros.org/api/dynamixel_controllers/html/srv/SetComplianceSlope.html][dynamixel_controllers/SetComplianceSlope]])

-  Change the level of torque near goal position (see
   [[http://support.robotis.com/en/product/dynamixel/ax_series/dxl_ax_actuator.htm#Actuator_Address_1A][Dynamixel
   documentation]] for more details).

=joint_controller_name/set_compliance_margin=
([[http://docs.ros.org/api/dynamixel_controllers/html/srv/SetComplianceMargin.html][dynamixel_controllers/SetComplianceMargin]])

-  Change allowable error between goal position and present position
   (see
   [[http://support.robotis.com/en/product/dynamixel/ax_series/dxl_ax_actuator.htm#Actuator_Address_1A][Dynamixel
   documentation]] for more details).

=joint_controller_name/set_compliance_punch=
([[http://docs.ros.org/api/dynamixel_controllers/html/srv/SetCompliancePunch.html][dynamixel_controllers/SetCompliancePunch]])

-  Change minimum amount of torque at goal position (see
   [[http://support.robotis.com/en/product/dynamixel/ax_series/dxl_ax_actuator.htm#Actuator_Address_1A][Dynamixel
   documentation]] for more details).

=joint_controller_name/set_torque_limit=
([[http://docs.ros.org/api/dynamixel_controllers/html/srv/SetTorqueLimit.html][dynamixel_controllers/SetTorqueLimit]])

-  Change the maximum amount of torque (see
   [[http://support.robotis.com/en/product/dynamixel/ax_series/dxl_ax_actuator.htm#Actuator_Address_22][Dynamixel
   documentation]] for more details).

********* Parameters

=joint_controller_name/joint_name= (=str=)

-  Name of the joint this controller is responsible for.

=joint_controller_name/joint_max_speed= (=float=, default: depends on
the motor model and supplied voltage)

-  Maximum joint velocity (specified in radians per second).

=joint_controller_name/joint_speed= (=float=, default: 1.0)

-  Default joint velocity (specified in radians per second).

=joint_controller_name/joint_compliance_slope= (=int=, default: None)

-  Dynamixel motor compliance slope (acceptable values are 0 - 254).

=joint_controller_name/joint_compliance_margin= (=int=, default: None)

-  Dynamixel motor compliance margin (acceptable values are 0 - 255).

=joint_controller_name/joint_compliance_punch= (=int=, default: None)

-  Dynamixel motor punch (acceptable values are 0 - 255).

=joint_controller_name/joint_torque_limit= (=float=, default: None)

-  Dynamixel motor maximum torque (acceptable values are 0.0 - 1.0, with
   0 meaning no torque and 1 meaning maximum torque).

******** Additional Controller Configuration

Every joint controller can add additional configuration parameters (e.g.
dual motor controllers need to know the low level configuration of both
motors). See [[/DefaultJointControllers][joint controllers]] page for a
list of controllers included in the dynamixel_controllers package and
their configuration parameters.

******** Example Controller Configuration

/[[http://ua-ros-pkg.googlecode.com/svn/stacks/dynamixel_motor/tags/diamondback/dynamixel_tutorials/config/dynamixel_joint_controllers.yaml]]/

#+BEGIN_EXAMPLE
    pan_controller:
        controller:
            package: dynamixel_controllers
            module: joint_position_controller
            type: JointPositionController
        joint_name: pan_joint
        joint_speed: 1.17
        motor:
            id: 15
            init: 512
            min: 0
            max: 1023

    tilt_controller:
        controller:
            package: dynamixel_controllers
            module: joint_position_controller
            type: JointPositionController
        joint_name: tilt_joint
        joint_speed: 1.17
        motor:
            id: 16
            init: 512
            min: 0
            max: 1023
#+END_EXAMPLE


****** work manner
first a controller manager node is launched that connects to the
Dynamixel bus (in our case a USB2Dynamixel controller).

The controller node then launches a number of individual controllers,
one for each servo.

****** connetion
*USB2Dynamixel*: 类似USB hub， 连接多个Dynamixel USB，需配置Hardware
ID(default 1)

*arbotix_terminal*: 进行配置Hardware ID

****** config
+ 文件格式： yaml,  i.e. dynamixel_params.yaml
+ 文件位置：config子文件夹

#+BEGIN_SRC yaml
  joints: ['head_pan_joint', 'head_tilt_joint']

  head_pan_joint:
      controller:
          package: dynamixel_controllers
          module: joint_position_controller
          type: JointPositionController
      joint_name: head_pan_joint
      joint_speed: 2.0
      motor:
          id: 1
          init: 512
          min: 0
          max: 1024

  head_tilt_joint:
      controller:
          package: dynamixel_controllers
          module: joint_position_controller
          type: JointPositionController
      joint_name: head_tilt_joint
      joint_speed: 2.0
      motor:
          id: 2
          init: 512
          min: 300
          max: 800

#+END_SRC

****** launch file
#+BEGIN_SRC xml
  <launch>
      <param name="/use_sim_time" value="false" />

      <!-- Load the URDF/Xacro model of our robot -->
      <param name="robot_description" command="$(find xacro)/xacro.py '$(find rbx1_description)/urdf/turtlebot_with_head.xacro'" />

      <!-- Publish the robot state -->
      <node name="robot_state_publisher" pkg="robot_state_publisher" type="state_publisher">
          <param name="publish_frequency" value="20.0"/>
      </node>

     <!-- Start the Dynamixel low-level driver manager with parameters -->
     <node name="dynamixel_manager" pkg="dynamixel_controllers"
        type="controller_manager.py" required="true" output="screen">
        <rosparam>
           namespace: turtlebot_dynamixel_manager
           serial_ports:
              dynamixel_ax12:
                 port_name: /dev/ttyUSB0
                 baud_rate: 1000000
                 min_motor_id:  1
                 max_motor_id: 2
                 update_rate: 20
        </rosparam>
     </node>

      <!-- Load the joint controller configuration from a YAML file -->
      <rosparam file="$(find rbx1_dynamixels)/config/dynamixel_params.yaml" command="load"/>

     <!-- Start the head pan and tilt controllers -->
     <node name="dynamixel_controller_spawner_ax12" pkg="dynamixel_controllers"
     type="controller_spawner.py"
          args="--manager=turtlebot_dynamixel_manager
                --port=dynamixel_ax12
                --type=simple
          head_pan_joint
          head_tilt_joint"
          output="screen" />

     <!-- Start the Dynamixel Joint States Publisher -->
     <node name="dynamixel_joint_states_publisher" pkg="rbx1_dynamixels" type="dynamixel_joint_state_publisher.py" output="screen" />

     <!-- Start all Dynamixels in the relaxed state -->
     <node pkg="rbx1_dynamixels" type="relax_all_servos.py" name="relax_all_servos" />

     <!-- We need a static transforms for the TurtleBot wheels -->
     <node pkg="tf" type="static_transform_publisher" name="odom_left_wheel_broadcaster" args="0 0.13 0.015 0 0 0 /base_link /base_l_wheel_link 100" />
     <node pkg="tf" type="static_transform_publisher" name="odom_right_wheel_broadcaster" args="0 -0.13 0.015 0 0 0 /base_link /base_r_wheel_link 100" />
     <node pkg="tf" type="static_transform_publisher" name="odom_front_wheel_broadcaster" args="0.13 0 0 0 0 0 /base_link /front_wheel_link 100" />

  </launch>

#+END_SRC

+ controller_manager.py
+ dynamixel_joint_state_publisher.py

*** DONE ROS Beginner-Level Tutorials [20/20]
SCHEDULED: <2015-03-15 日>
- State "DONE"       from "TODO"       [2015-03-17 二 14:43]
- State "TODO"       from ""           [2015-03-14 六 14:34]
**** DONE Installing and Configuring ROS Environment
***** Managing ROS Environment
1. check ROS-relevant envs: *$ grep | grep ROS*
   注: 在eshell中export的含义不同
2. possible sources of environment setup files "setup.*sh"
   - ROS packages installed with package managers provide setup.*sh files
   - rosbuild workspaces provide setup.*sh files using tools like rosws
   - Setup.*sh files are created as a by-product of building or installing
     catkin packages
3. location of ROS setup.*sh
   Apt-way: [[/opt/ros/<distro>/setup.bash]]
   #+BEGIN_EXAMPLE
     # source /opt/ros/<distro>/setup.bash
   #+END_EXAMPLE
4. rosbuild vs catkin
   + rosbuild is easy to use and simple
   + catkin
     - uses more standard CMake conventions
     - it is more sophisticated
     - provides more flexibility especially for people wanting to
       integrate external code bases or who want to release their
       software.

***** Create a ROS Workspace
****** catkin
1) create a catkin workspace : *catkin_init_workspace*
   #+BEGIN_EXAMPLE
     $ mkdir -p ~/catkin_ws/src
     $ cd ~/catkin_ws/src
     $ catkin_init_workspace
   #+END_EXAMPLE

2) build the workspace: *catkin_make*
   #+BEGIN_EXAMPLE
     $ cd ~/catkin_ws/
     $ catkin_make
   #+END_EXAMPLE
   + catkin_make: catkin_make command is a convenience tool for
     working with catkin workspaces
   + build folder
   + devel folder: Inside the 'devel' folder you can see that there
     are now several setup.*sh files. Sourcing any of these files will
     overlay this workspace on top of your environment.
3) source setup.*sh file
   types of setup.*sh:(应该是针对不同的bash)
   + .bash
   + .zsh
   + .sh
   #+BEGIN_EXAMPLE
   $ source devel/setup.bash
   #+END_EXAMPLE
4) make sure ROS_PACKAGE_PATH environment variable includes the
   directory you're in.

**** DONE Navigating the ROS Filesystem
***** ROS Filesystem Concept
+ Packages: Packages are the lowest level of ROS software
  organization. They can contain anything: libraries, tools, executables, etc.
+ Manifest: A manifest is a description of a package. Its most
  important role is to define dependencies between packages.
+ Stacks: Stacks are collections of packages that form a
  higher-level library.
+ Stack Manifest: These are just like normal manifests, but for
  stacks.


[[/home/ben/Tiger/Figures/scrot/31630HH.png]]

***** Filesystem Tools
Code is spread across many ROS packages and stacks. Navigating with
command-line tools such as ls and cd can be very tedious which is why
ROS provides tools to help you.
****** rospack & rosstack
1) description
   rospack and rosstack allow you to get information about packages
   and stacks. In this tutorial, we are only going to cover the find
   option, which returns the path to package or stack.
2) Usage
   $ rospack find [package_name]
   $ rosstack find [stack_name]
3) Example:
   $ rospack find roscpp    # return the location of roscpp package


****** roscd
roscd is part of the rosbash suite. It allows you to change directory
(cd) directly to a package or a stack.

1) Usage:
   $ roscd [locationname[/subdir]]
2) example
   #+BEGIN_EXAMPLE
   $ roscd roscpp
   $ pwd
   #+END_EXAMPLE
3) roscd with no argument
   roscd without an argument will take you to $ROS_WORKSPACE.
4) roscd log
   roscd log will take you to the folder where ROS stores log
   files. Note that if you have not run any ROS programs yet, this
   will yield an error saying that it does not yet exist.
5) Note
   Note that roscd, like other ROS tools, will only find ROS packages
   that are below the directories listed in your *ROS_PACKAGE_PATH*.
   #+BEGIN_EXAMPLE
    $ echo $ROS_PACKAGE_PATH
   #+END_EXAMPLE

   Similarly to other environment paths, you can add additional
   directories to your $ROS_PACKAGE_PATH, with each path separated by
   a colon ':'
****** rosls
rosls is part of the rosbash suite. It allows you to ls directly in a
package, stack, or common location by name rather than by package
path.

1) Usage: $ rosls [locationname[/subdir]]
2) Example:
   #+BEGIN_EXAMPLE
   $ rosls roscpp_tutorials
   #+END_EXAMPLE
****** TAB completion
It can get tedious to type out an entire package name. In the previous
example, roscpp_tutorials is a fairly long name. Luckily, some ROS
tools support TAB completion.
注: 该特性在Terminal中有效, 在Emacs shell失效.
****** Review
+ rospack = ros + pack(age)
+ rosstack = ros + stack
+ roscd = ros + cd
+ rosls = ros + ls
**** DONE Creating a ROS package(catkin way)
***** make up of a catin package
For a package to be considered a catkin package it must meet a few
requirements:
+ The package must contain a catkin compliant package.xml file +
  That package.xml file provides meta information about the package
+ The package must contain a CMakeLists.txt which uses
  catkin. Catkin metapackages must have a boilerplate CMakeLists.txt
  file.
+ There can be no more than one package in each folder. This means
    no nested packages nor multiple packages sharing the same
    directory

The simplest possible package might look like this:
#+BEGIN_EXAMPLE
  * my_package/
      CMakeLists.txt
      package.xml
#+END_EXAMPLE

***** packages in a catkin workspace
The recommended method of working with catkin packages is using a
catkin workspace, but you can also build catkin packages standalone.

A trivial workspace might look like this:
#+BEGIN_EXAMPLE
  * workspace_folder/        -- WORKSPACE
      src/                   -- SOURCE SPACE
        CMakeLists.txt       -- 'Toplevel' CMake file, provided by catkin
        package_1/
          CMakeLists.txt     -- CMakeLists.txt file for package_1
          package.xml        -- Package manifest for package_1
        ...
        package_n/
          CMakeLists.txt     -- CMakeLists.txt file for package_n
          package.xml        -- Package manifest for package_n
#+END_EXAMPLE

***** creating a catkin package: catkin_create_pkg
1) Usage: *catkin_create_pkg <package_name> [depend1] [depend2] ...*
2) Example
   Use the catkin_create_pkg script to create a new package called
   'beginner_tutorials' which depends on std_msgs, roscpp, and rospy:
   #+BEGIN_EXAMPLE
     $ cd catkin_ws/src
     $ catkin_create_pkg beginner_tutorials std_msgs rospy roscpp
   #+END_EXAMPLE

   This will create a beginner_tutorials folder which contains a
   package.xml and a CMakeLists.txt, which have been partially filled
   out with the information you gave catkin_create_pkg.
***** build a catkin workspace and source
#+BEGIN_EXAMPLE
  $ cd catkin_ws
  $ catkin_make
  $ source devel/setup.bash
#+END_EXAMPLE

***** package dependencies
1) first-order dependencies
   When using catkin_create_pkg earlier, a few package dependencies
   were provided. These first-order dependencies can now be reviewed
   with the rospack tool.
   #+BEGIN_EXAMPLE
     $ rospack depends1 beginner_tutorials
   #+END_EXAMPLE
2) indirect dependencies
   In many cases, a dependency will also have its own
   dependencies. For instance, rospy has other dependencies.
   #+BEGIN_EXAMPLE
     $ rospack depends beginner_tutorials
   #+END_EXAMPLE

***** customizing your package
1. customizing the package.xml
   1) description tag
   2) maintainer tags
   3) license tags
   4) dependencies tags
      The dependencies are split into
      + build_depend
      + buildtool_depend
      + run_depend
      + test_depend.
2. customizing the CMakeLists.txt

**** DONE build ROS package(catkin way)
***** catkin_make
*catkin_make* is a command line tool which adds some convenience to
the standard catkin workflow.
You can imagine that *catkin_make combines the calls to cmake and make
in the standard CMake workflow.*
1) Usage:
   $ catkin_make [make_targets] [-DCMAKE_VARIABLES=...] # In a catkin workspace
2) CMake workflow & catkin workflow
   + CMake
     #+BEGIN_EXAMPLE
       # In a CMake project
       $ mkdir build
       $ cd build
       $ cmake ..
       $ make
       $ make install  # (optionally)
     #+END_EXAMPLE
   + catkin
     #+BEGIN_EXAMPLE
       # In a catkin workspace
       $ catkin_make
       $ catkin_make install  # (optionally)
     #+END_EXAMPLE
***** build ROS package
#+BEGIN_EXAMPLE
  $ catkin_make    # in catkin workspace
#+END_EXAMPLE

+ build folder is the default location of the *build space* and is
  where cmake and make are called to configure and build your
  packages.
+ The devel folder is the default location of the *devel space*, which
  is where your executables and libraries go before you install your
  packages.

**** DONE Understanding ROS Nodes
***** Overview of Graph Concepts
  + Nodes: A node is an executable that uses ROS to communicate with
    other nodes.
  + Messages: ROS data type used when subscribing or publishing to a
    topic.
  + Topics: Nodes can publish messages to a topic as well as subscribe
    to a topic to receive messages.
  + Master: Name service for ROS (i.e. helps nodes find each other)
  + rosout: ROS equivalent of stdout/stderr
  + roscore: Master + rosout + parameter server (parameter server will
    be introduced later)

***** Nodes
+ A node really isn't much more than *an executable file* within a ROS
  package.
+ ROS nodes use a *ROS client library* to communicate with other
  nodes.
+ Nodes can *publish or subscribe to a Topic*
+ Nodes can also *provide or use a Service*
***** Client Libraries
ROS client libraries allow nodes written in different programming
languages to communicate:
+ rospy = python client library
+ roscpp = c++ client library

***** roscore
*roscore* is the first thing you should run when using ROS.
#+BEGIN_EXAMPLE
$ roscore
#+END_EXAMPLE
***** rosnode
*rosnode* display information about the ROS nodes that are currently
running.

+ *rosnode list*: list the active nodes
  #+BEGIN_EXAMPLE
    $ rosnode list

    ,#+RESULT:
    /rosout
  #+END_EXAMPLE
  *rosout* is always running as it collects and logs nodes' debugging
  output.
+ *rosnode info* returns information about a specific node
  #+BEGIN_EXAMPLE
    $ rosnode info /rosout

    ,#+RESULT:
    Node [/rosout]
    Publications:
     ,* /rosout_agg [rosgraph_msgs/Log]

    Subscriptions:
     ,* /rosout [unknown type]

    Services:
     ,* /rosout/set_logger_level
     ,* /rosout/get_loggers


    contacting node http://ben:50314/ ...
  #+END_EXAMPLE
***** rosrun
*rosrun* allows you to use the package name to directly run a node
within a package (without having to know the package path).
1) Usage: *$ rosrun [package_name] [node_name]*
2) Example:
   #+BEGIN_EXAMPLE
     $ rosrun turtlesim turtlesim_node
   #+END_EXAMPLE
3) reassign Names from the command-line
   One powerful feature of ROS is that you can reassign Names from
   command-line.
   #+BEGIN_EXAMPLE
     $ rosrun turtlesim turtlesim_node __name:=my_turtle
   #+END_EXAMPLE
   注:
   + __name 前是双下划线
   + := 前后不能有空格, 在命令行中空白符是用来分隔不同参数的
***** rosnode clean
***** rosnode ping
***** Review
+ roscore = ros+core : master (provides name service for ROS) + rosout
  (stdout/stderr) + parameter server (parameter server will be introduced
  later)
+ rosnode = ros+node : ROS tool to get information about a node.
+ rosrun = ros+run : runs a node from a given package.

**** DONE Understanding ROS topics
***** Example for ROS Topics
+ The turtlesim_node and the turtle_teleop_key node are communicating
  witheach other over a ROS *Topic*.
+ turtle_teleop_key is *publishing* the key strokes on a topic,
+ while turtlesim *subscribes* to the same topic to receive the key
  strokes.

*rqt_graph* shows the nodes and topics currently running.
***** rqt_graph
rqt_graph creates a dynamic graph of what's going on in the system.
rqt_graph is part of the rqt package.
#+BEGIN_EXAMPLE
  $ sudo apt-get install ros-<distro>-rqt
  $ sudo apt-get install ros-<distro>-rqt-common-plugins
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  $ rosrun rqt_graph rqt_graph
#+END_EXAMPLE

***** Introducing rostopic
+ rostopic bw	display bandwidth used by topic
+ rostopic echo	print messages to screen
+ rostopic find	find topics by type
+ rostopic hz	display publishing rate of topic
+ rostopic info	print information about active topic
+ rostopic list	list active topics
+ rostopic pub	publish data to topic
+ rostopic type	print topic type
***** rostopic echo
rostopic echo shows the data published on a topic.

Usage: *rostopic echo [topic]*
***** rostopic list
Usage: rostopic list [/topic]
Options:
+  -h, --help            show this help message and exit
+  -b BAGFILE, --bag=BAGFILE
                            list topics in .bag file
+  -v, --verbose         list full details about each topic
+  -p                    list only publishers
+  -s                    list only subscribers

***** ROS Message
Communication on topics happens by sending ROS *messages* between
nodes.
This means that a topic type is defined by the message type published
on it. The type of the message sent on a topic can be determined using
rostopic type.
***** rostopic type
*rostopic type* returns the message type of any topic being published.

Usage: *rostopic type [topic]*
#+BEGIN_EXAMPLE
  $ rostopic type /turtle1/cmd_vel

  ,#+ RESULT:
  geometry_msgs/Twist
#+END_EXAMPLE

*rosmsgs show [ROSMessage]* shows the details of the message.
#+BEGIN_EXAMPLE
  $ rosmsg show geometry_msgs/Twist

  ,#+RESULT:
  geometry_msgs/Vector3 linear
    float64 x
    float64 y
    float64 z
  geometry_msgs/Vector3 angular
    float64 x
    float64 y
    float64 z
#+END_EXAMPLE



***** rostopic pub
*rostopic pub* publishes data on to a topic currently advertised.

Usage: *rostopic pub [topic] [msg_type] [args]*

#+BEGIN_EXAMPLE
$ rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'
#+END_EXAMPLE

The previous command will send a single message to turtlesim telling it to
move with an linear velocity of 2.0, and an angular velocity of 1.8 .

  1) This command will publish messages to a given topic: *rostopic
     pub*
  2) This option (*dash-one*) causes rostopic to only publish one
     message then exit: -1
  3) This is the name of the topic to publish to:  /turtle1/cmd_vel
  4) This is the message type to use when publishing the topic:
     geometry_msgs/Twist
  5) This option (*double-dash*) tells the option parser that *none of
     the following arguments is an option*. This is required in cases
     where your arguments have a leading dash -, like negative numbers.
  6) As noted before, a geometry_msgs/Twist msg has two vectors of three
     floating point elements each: linear and angular. In this case, '
     [2.0, 0.0, 0.0]' becomes the linear value with x=2.0, y=0.0, and z=0.0,
     and '[0.0, 0.0, 1.8]' is the angular value with x=0.0, y=0.0, and z=1.8.
     These arguments are actually in YAML syntax, which is described more in
     the YAML command line documentation.

     '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'

***** rostopic hz
*rostopic hz* reports the rate at which data is published.

Usage: *rostopic hz [topic]*

***** rqt_plot
*rqt_plot* displays a scrolling time plot of the data published on
topics.
#+BEGIN_EXAMPLE
$ rosrun rqt_plot rqt_plot
#+END_EXAMPLE
**** DONE Understanding ROS services and parameters
***** ROS Services
*Services* are another way that nodes can communicate with each
other. Services allow nodes to send a *request* and receive a
*respose*.
***** rosservice
*rosservice* can easily attach to ROS's *client/service* framework
with services.
+ rosservice list         print information about active services
+ rosservice call         call the service with the provided args
+ rosservice type         print service type
+ rosservice find         find services by service type
+ rosservice uri          print service ROSRPC uri

****** rosservice list
print information about active services
****** rosservice type
print service type
Usage: *rosservice type [service]*
#+BEGIN_EXAMPLE
  $ rosservice type /clear
  OR
  $ rosservice type clear

  RESULT:  * std_srvs/Empty
#+END_EXAMPLE
This service is empty, this means when the service call is made it
takes no arguments (i.e. it sends no data when making a request and
receives no data when receiving a response).
****** roservice call
call the service with provided args
Usage: *roservice call [service] [args]*
#+BEGIN_EXAMPLE
$ rosservice call /clear    # clear the bg of turtlesim_node
#+END_EXAMPLE
****** rosservice type
print service type
Usage: *rosservice type [SERVICE]*
RELATED: rossrc show [SERVICE_TYPE]
#+BEGIN_EXAMPLE
  $ rosservice type spawn | rossrv show

  RESULT:
  float32 x
  float32 y
  float32 theta
  string name
  ---
  string name
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  $ rosservice call spawn 2 2 0.2 ""

  RESULT:
  name: turtle2
#+END_EXAMPLE

***** rosparam
*rosparam* allows you to store and manipulate data on the ROS
*Parameter Server* . The Parameter Server can store integers, floats,
*boolean, dictionaries, and lists. rosparam uses the *YAML*[fn:1503131006] markup
*language for syntax.

In simple cases, YAML looks very natural: 1 is an integer, 1.0 is a
float, one is a string, true is a boolean, [1, 2, 3] is a list of
integers, and {a: b, c: d} is a dictionary.

+ rosparam set            set parameter
+ rosparam get            get parameter
+ rosparam load           load parameters from file
+ rosparam dump           dump parameters to file
+ rosparam delete         delete parameter
+ rosparam list           list parameter names

****** rosparam list
list parameter names.
#+BEGIN_EXAMPLE
  $ rosparam list

  RESULT:
  /background_b
  /background_g
  /background_r
  /rosdistro
  /roslaunch/uris/host_ben__35677
  /rosversion
  /run_id
#+END_EXAMPLE

****** rosparam set & rosparam get
set & get parameters.
Usage:
+ rosparam set [param_name]
+ rosparam get [param_name]

#+BEGIN_EXAMPLE
$ rosparam set background_r 150
$ rosservice call clear
#+END_EXAMPLE

#+BEGIN_EXAMPLE
$ rosparam get background_g
#+END_EXAMPLE

*rosparam get /* : show the contents of the entire parameter server.

****** rosparam dump & rosparam load
Usage:
+ rosparam dump [file_name] [namespace]
+ rosparam load [file_name] [namespace]

#+BEGIN_EXAMPLE
$ rossparam dump params.yaml
#+END_EXAMPLE
Contents of params.yaml:
#+BEGIN_EXAMPLE
  background_b: 255
  background_g: 86
  background_r: 150
  rosdistro: 'indigo

    '
  roslaunch:
    uris: {host_ben__35677: 'http://ben:35677/'}
  rosversion: '1.11.10

    '
  run_id: 70f25f26-c921-11e4-bb84-002186ef9d91
#+END_EXAMPLE
Load yaml files into new namespaces
#+BEGIN_EXAMPLE
  $ rosparam load params.yaml copy
  $ rosparam get copy/background_b
#+END_EXAMPLE

**** DONE Using rqt_console and roslaunch
***** rqt_console & rqt_logger_level
****** rqt_console
*rqt_console* attaches to ROS's logging framework to display output
from nodes.
#+BEGIN_EXAMPLE
$ rosrun rqt_consle rqt_console
#+END_EXAMPLE

****** rqt_logger_level
*rqt_logger_level* allows us to change the verbosity level of node as
they run. Logging levels are prioritized in the following order:
1. Fatal
2. ERROR
3. WARN
4. INFO
5. DEBUG

Fatal has the highest priority and Debug has the lowest. By setting
the logger level, you will get all messages of that priority level or
higher.



#+BEGIN_EXAMPLE
$ rosrun rqt_consle rqt_console
$ rosrun rqt_logger_level rqt_logger_level
#+END_EXAMPLE

***** roslaunch
*roslaunch* starts nodes as defined in a launch file.
Usage: *roslaunch [package] [filename.launch]*

Location of launch files
#+BEGIN_EXAMPLE
  $ roscd beginner_tutorials
  $ mkdir launch
  $ cd launch
#+END_EXAMPLE
****** launch file
file:~/Project/SLAM/ROS/catkin_ws/src/beginner_tutorials/launch/turtlemimic.launch
#+BEGIN_EXAMPLE
  <launch>
    <group ns="turtlesim1">
      <node pkg="turtlesim" name="sim" type="turtlesim_node"/>
    </group>

    <group ns="turtlesim2">
      <node pkg="turtlesim" name="sim" type="turtlesim_node"/>
    </group>

    <node pkg="turtlesim" name="mimic" type="mimic">
      <remap from="input" to="turtlesim1/turtle1"/>
      <remap from="output" to="turtlesim2/turtle1"/>
    </node>

  </launch>

#+END_EXAMPLE

1) Line 1:
   Here we start the launch file with the *launch tag*, so that the
   file is identified as a launch file.
2) Line 2~7
   Here we start two groups with a *namespace tag* of turtlesim1 and
   turtlesim2 with a turtlesim node with a name of sim. This allows us
   to start two simulators *without having name conflicts*.
3) Line 9~12
   Here we start the mimic node with the topics input and output
   renamed to turtlesim1 and turtlesim2. This renaming will cause
   turtlesim2 to mimic turtlesim1.
****** roslaunching
#+BEGIN_EXAMPLE
$ roslaunch beginner_tutorials turtlemimic.launch
#+END_EXAMPLE

#+BEGIN_EXAMPLE
$ rqt_graph
#+END_EXAMPLE

**** DONE Using rosed
- State "DONE"       from "TODO"       [2015-03-15 日 20:36]
- State "TODO"       from ""           [2015-03-14 六 14:37]

***** using rosed
rosed is part of the *rosbash* suite. It allows you to directly edit a
file within a package by using the package name rather than having to
type the entire path to the package.

Usage: *$ rosed [package_name] [filename]*
#+BEGIN_EXAMPLE
  $ rosed roscpp Logger.msg
#+END_EXAMPLE

This example demonstrates how you would edit the Logger.msg file
within the roscpp package.

***** using rosed with tab completion
This way you can easily see and optionally edit all files from a
package without knowing its exact name.

Usage: *$ rosed [package_name] <tab><tab>*

注：　package name 后面要有空格，不然补全的是package name
***** editor
The default editor for rosed is vim.

To set the default editor to emacs you can edit your ~/.bashrc file to
include:
#+BEGIN_EXAMPLE
  export EDITOR='emacs -nw'
#+END_EXAMPLE

NOTE: changes in .bashrc will only take effect for new
terminals. Terminals that are already open will not see the new
environmental variable.

Open a new terminal and see if EDITOR is defined:
#+BEGIN_EXAMPLE
  $ echo $EDITOR
#+END_EXAMPLE

**** DONE Creating a ROS msg and srv
- State "DONE"       from "TODO"       [2015-03-16 一 09:26]
- State "TODO"       from "TODO"       [2015-03-16 一 09:26]
***** introduction to msg and srv
  + *msg*:
    - msg files are simple text files
    - that describe the fields of a ROS message.
    - They are used to generate source code for messages in different
      languages.

  + *srv*:
    - an srv file describes a service.
    - It is composed of two parts: a *request* and a *response.*

msg files are stored in the *msg directory* of a package, and srv
files are stored in the *srv directory*.

msgs are just simple text files with a *field type* and *field name*
per line:
+ int8, int16, int32, int64 (plus uint*)
+ float32, float64
+ string
+ time, duration
+ other msg files
+ variable-length array[] and fixed-length array[C]
+ *Header*: the header contains a timestamp and coordinate frame
  information that are commonly used in ROS

#+BEGIN_EXAMPLE
  Header header
  string child_frame_id
  geometry_msgs/PoseWithCovariance pose
  geometry_msgs/TwistWithCovariance twist
#+END_EXAMPLE

srv files are just like msg files, except they contain two parts: a
request and a response. *The two parts are separated by a '---'
line*.
#+BEGIN_EXAMPLE
  int64 A
  int64 B
  ---
  int64 Sum
#+END_EXAMPLE
***** using msg
****** creating a msg
1) create a .msg file
   #+BEGIN_EXAMPLE
     $ cd ~/catkin_ws/src/beginner_tutorials
     $ mkdir msg
     $ echo "int64 num" > msg/Num.msg
   #+END_EXAMPLE
2) package.xml
   uncomment message_generatoin and message_runtime in package.xml in
   package.xml

   #+BEGIN_EXAMPLE
     <build_depend>message_generation</build_depend>
     <run_depend>message_runtime</run_depend>
   #+END_EXAMPLE

   Note that at build time, we need "message_generation", while at
   runtime, we only need "message_runtime".
3) CMakeLists.txt
   + message_generation
     add message_generation dependency to the find_package call which
     already exists in your CMakeLists.txt so that you can generate
     messages
     #+BEGIN_EXAMPLE
       find_package(catkin REQUIRED COMPONENTS
          roscpp
          rospy
          std_msgs
          message_generation
       )
     #+END_EXAMPLE

   + message_runtime
     #+BEGIN_EXAMPLE
       catkin_package(
           ...
           CATKIN_DEPENDS message_runtime ...
           ...)
     #+END_EXAMPLE

   + uncomment add_message_files
     #+BEGIN_EXAMPLE
       add_message_files(
         FILES
         Num.msg
       )
     #+END_EXAMPLE

   + ensure the generate_messages() function is called
     #+BEGIN_EXAMPLE
       generate_messages(
         DEPENDENCIES
         std_msgs
       )
     #+END_EXAMPLE

****** using rosmsg
Usage: *$ rosmsg show [message type]*
#+BEGIN_EXAMPLE
  $ rosmsg show beginner_tutorials/Num

  RESULT:
  int64 num

  $ rosmsg show Num

  RESULT:
  [beginner_tutorials]:
  int64 num
#+END_EXAMPLE

***** using srv
****** creating a srv
1) creating a .srv file by *roscp*
   #+BEGIN_EXAMPLE
     $ roscd beginner_tutorials
     $ mkdir srv
   #+END_EXAMPLE
   *roscp* is a useful commandline tool for copying files from one
   package to another.

   Usage: *$ roscp [package_name] [file_to_copy_path] [copy_path]*
   #+BEGIN_EXAMPLE
     $ roscp rospy_tutorials AddTwoInts.srv srv/AddTwoInts.srv
   #+END_EXAMPLE

2) package.xml: uncomment message_generation and message_runtime

   #+BEGIN_EXAMPLE
     <build_depend>message_generation</buid_depend>
     <run_depend>message_runtime</run_depend>
   #+END_EXAMPLE

3) CMakeLists.txt
   + message_generation
     #+BEGIN_EXAMPLE
       find_package(catkin REQUIRED COMPONENTS
         roscpp
         rospy
         std_msgs
        message_generation
       )
     #+END_EXAMPLE

　   注： Despite its name, message_generation works for both msg and srv.

   + services_files
     #+BEGIN_EXAMPLE
       add_service_files(
         FILES
         AddTwoInts.srv
       )
     #+END_EXAMPLE

****** using rossrv
Usage: *$ rossrv show <service type>*
#+BEGIN_EXAMPLE
  $ rossrv show beginner_tutorials/AddTwoInts

  RESULT:
      int64 a
      int64 b
      ---
      int64 sum

  $ rossrv show AddTwoInts

  RESULT:
      [beginner_tutorials/AddTwoInts]:
      int64 a
      int64 b
      ---
      int64 sum

      [rospy_tutorials/AddTwoInts]:
      int64 a
      int64 b
      ---
      int64 sum

#+END_EXAMPLE

***** common step for msg and srv

+ Uncomment *generate_messages*
+ add any packages you depend on which contain .msg files that your
  messages use (in this case std_msgs)

generate_messages(
  DEPENDENCIES
  std_msgs
)

***** catkin_make
#+BEGIN_EXAMPLE
  $ cd ../..
  $ catkin_make
#+END_EXAMPLE

Any .msg file in the msg directory will generate code for use in all
supported languages.

1) The C++ message header file will be generated in
   *~/catkin_ws/devel/include/beginner_tutorials/*.
2) The Python script will be created in
   *~/catkin_ws/devel/lib/python2.7/dist-packages/beginner_tutorials/msg*.
3) The lisp file appears in
   *~/catkin_ws/devel/share/common-lisp/ros/beginner_tutorials/msg/*

***** getting help
Getting Help

We've seen quite a few ROS tools already. It can be difficult to keep track
of what arguments each command requires. Luckily, most ROS tools provide
their own help.
#+BEGIN_EXAMPLE
  $ rosmsg -h

  Commands:
    rosmsg show Show message description
    rosmsg users  Find files that use message
    rosmsg md5  Display message md5sum
    rosmsg package  List messages in a package
    rosmsg packages List packages that contain messages

#+END_EXAMPLE

*You can also get help for subcommands*
#+BEGIN_EXAMPLE
  $ rosmsg show -h

  Usage: rosmsg show [options] <message type>

  Options:
    -h, --help  show this help message and exit
    -r, --raw   show raw message text, including comments
#+END_EXAMPLE

**** DONE Writing a Simple Publisher and Subscriber (C++)
- State "DONE"       from "TODO"       [2015-03-16 一 10:33]
***** writing the publisher node
*Node* is the ROS term for *an executable that is connected to the ROS
network*. Here we'll create a *publisher ("talker")* node which will
continually *broadcast a message*.

Create a src directory in the beginner_tutorials package
directory. This directory will contain any source files for our
package.
#+BEGIN_EXAMPLE
$ mkdir -p ~/catkin_ws/src/beginner_tutorials/src
#+END_EXAMPLE

****** ros/ros.h
*ros/ros.h* is a convenience include that includes all the headers
necessary to use the most common public pieces of the ROS system.

****** std_msg/String
This includes the std_msgs/String message, which resides in the std_msgs
package. This is a header generated automatically from the String.msg file
in that package. For more information on message definitions, see the msg
page.

****** ros::init()
#+BEGIN_EXAMPLE
  ros::init(argc, argv, "talker");
#+END_EXAMPLE

Initialize ROS. This allows ROS to do name remapping through the command
line -- not important for now. This is also where we specify the name of our
node. Node names must be unique in a running system.

+ The *ros::init()* function needs to see argc and argv
+ so that it can perform any ROS arguments and name remapping that
  were provided at the command line.
+ For programmatic remappings you can use a different version of init() which takes remappings directly
+ but for mostcommand-line programs, *passing argc and argv is the
  easiest way to do it*.
+ *The third argument to init() is the name of the node.*
+ You *must call one of the versions of ros::init() before using any
  other part of the ROS system.*

****** NodeHandle
#+BEGIN_EXAMPLE
  ros::NodeHandle n;
#+END_EXAMPLE
Create a handle to this process' node. The first NodeHandle created will
actually do the initialization of the node, and the last one destructed will
cleanup any resources the node was using.

NodeHandle is the main access point to communications with the ROS
system.

The *first* NodeHandle *constructed* will fully initialize this node, and
the *last* NodeHandle *destructed* will close down the node.

****** advertise()
#+BEGIN_EXAMPLE
  ros::Publisher chatter_pub = n.advertise<std_msgs::String>("chatter", 1000);
#+END_EXAMPLE
Tell the master that we are going to be publishing a message of type
std_msgs/String on the topic chatter. This lets the master tell any nodes
listening on chatter that we are going to publish data on that topic. The
second argument is the size of our publishing queue. In this case if we are
publishing too quickly it will buffer up a maximum of 1000 messages before
beginning to throw away old ones.

NodeHandle::advertise() returns a ros::Publisher object, which serves two
purposes:
1) it contains a publish() method that lets you publish messages onto
   the topic it was created with
2) when it goes out of scope, it will automatically unadvertise.

The advertise() function is how you *tell ROS that you want to publish
on a given topic name*.

This invokes a call to the *ROS master node*, which keeps a registry
of who is publishing and who is subscribing.

After this advertise() call is made, the master node will notify
anyone who is trying to subscribe to this topic name, and they will in
turn negotiate a *peer-to-peer* connection with this node.

advertise() *returns a Publisher object* which allows you to publish
messages on that topic through a call to publish().

Once all copies of the returned Publisher object are destroyed, the
topic will be automatically unadvertised.

The second parameter to advertise() is the size of the message queue
used for publishing messages.  If messages are published more quickly
than we can send them, the number here specifies how many messages to
buffer up before throwing some away.

****** ros::Rate
A ros::Rate object allows you to specify a frequency that you would like to
loop at. It will keep track of how long it has been since the last call to
Rate::sleep(), and sleep for the correct amount of time.

In this case we tell it we want to run at *10hz*.

****** ros::ok()
By default roscpp will install a SIGINT handler which provides Ctrl-C
handling which will cause ros::ok() to return false if that happens.

ros::ok() will return false if:
  + a SIGINT is received (Ctrl-C)
  + we have been kicked off the network by another node with the same name
  + ros::shutdown() has been called by another part of the application.
  + all ros::NodeHandles have been destroyed

Once ros::ok() returns false, all ROS calls will fail.

****** std_msgs
#+BEGIN_EXAMPLE
  std_mgs::String msg;
  std::stringstream ss;
  ss << "hello world" << count;
  msg.data = ss.str();
#+END_EXAMPLE
We broadcast a message on ROS using a message-adapted class,
*generally generated from a msg file*.
More complicated datatypes are possible, but for now we're going to
use the standard String message, which has one member:"data".

****** ROS_INFO
#+BEGIN_EXAMPLE
  ROS_INFO("%s", msg.data.c_str());
#+END_EXAMPLE
ROS_INFO and friends are our replacement for printf/cout.

****** ros::spinOnce()
#+BEGIN_EXAMPLE
  ros::spinOnce();
#+END_EXAMPLE
Calling ros::spinOnce() here is not necessary for this simple program,
because we are not receiving any callbacks. However, if you were to add a
subscription into this application, and did not have ros::spinOnce() here,
your callbacks would never get called. So, add it for good measure.

****** ros::Rate::sleep()

***** writing the subscriber node
****** ros::NodeHandle::subscribe()
The subscribe() call is how you tell ROS that you want to receive
messages on a given topic.

This invokes a call to the ROS master node, which keeps a registry of
who is publishing and who is subscribing.

Messages are passed to a callback function, here called
chatterCallback. The message is passed in a *boost shared_ptr*, which
means you can store it off if you want, without worrying about it
getting deleted underneath you, and without copying the underlying
data.

subscribe() returns a Subscriber object that you must hold on to until
you want to unsubscribe.

When all copies of the Subscriber object go out of scope, this
callback will automatically be unsubscribed from this topic.

Subscribe to the chatter topic with the master. ROS will call the
chatterCallback() function whenever a new message arrives. The 2nd argument
is the queue size, in case we are not able to process messages fast enough.
In this case, if the queue reaches 1000 messages, we will start throwing
away old messages as new ones arrive.

****** ros::spin()
ros::spin() will enter a loop, pumping callbacks.  With this version,
all callbacks will be called from within this thread (the main one).
ros::spin() will exit when Ctrl-C is pressed, or the node is shutdown
by the master.

***** building the nodes
****** CMakelists.txt
#+BEGIN_EXAMPLE
  include_directories(include ${catkin_INCLUDE_DIRS})

  add_executable(talker src/talker.cpp)
  target_link_libraries(talker ${catkin_LIBRARIES})
  add_dependencies(talker beginner_tutorials_generate_messages_cpp)

  add_executable(listener src/listener.cpp)
  target_link_libraries(listener ${catkin_LIBRARIES})
  add_dependencies(listener beginner_tutorials_generate_messages_cpp)

#+END_EXAMPLE
******* add_executable
This will create two executables, talker and listener, which by
default will go into package directory of your *devel space*, located
by default at ~/catkin_ws/devel/lib/<package name>.

******* add_dependencies
#+BEGIN_EXAMPLE
  add_dependencies(talker beginner_tutorials_generate_messages_cpp)
#+END_EXAMPLE

Note that you have to add dependencies for the executable targets to message
generation targets:

This makes sure message headers of this package are generated before being
used. If you use messages from other packages inside your catkin workspace,
you need to add dependencies to their respective generation targets as well,
because catkin builds all projects in parallel.

******* catkin_make

******* run
You can invoke executables directly or you can use rosrun to invoke them.
They are not placed in '<prefix>/bin' because that would pollute the PATH
when installing your package to the system. If you wish for your executable
to be on the PATH at installation time, you can setup an install target,
see: catkin/CMakeLists.txt

**** ABORT Writing a Simple Publisher and Subscriber (Python)
- State "ABORT"      from "TODO"       [2015-03-16 一 10:36] \\
  暂时搁置, 不要太复杂
**** DONE Examining the Simple Publisher and Subscriber
- State "DONE"       from "TODO"       [2015-03-16 一 10:35]
#+BEGIN_EXAMPLE
  $ roscore
  $ rosrun beginner_tutorials talker      (C++)
  $ rosrun beginner_tutorials talker.py   (Python)
  $ rosrun beginner_tutorials listener
  $ rosrun beginner_tutorials listener.py
#+END_EXAMPLE
**** DONE Writing a Simple Service and Client (C++)
- State "DONE"       from "TODO"       [2015-03-16 一 11:39]
***** writing a service node
#+BEGIN_EXAMPLE
  #include "ros/ros.h"
  #include "beginner_tutorials/AddTwoInts.h"

  bool add(beginner_tutorials::AddTwoInts::Request &req,
           beginner_tutorials::AddTwoInts::Response &res)
  {
    res.sum = req.a + req.b;
    ROS_INFO("request: x=%ld, y=%ld", (long int)req.a, (long int)req.b);
    ROS_INFO("sending back response: [%ld]", (long int)res.sum);
    return true;
  }

  int main(int argc, char *argv[])
  {
    ros::init(argc, argv, "add_two_ints_server");
    ros::NoadeHandle n;
    ros::ServiceServer service = n.advertiseService("add_to_ints", add);
    ROS_INFO("Ready to add two ints.");
    ros::spin();

    return 0;
  }
#+END_EXAMPLE

****** #include "beginner_tutorials/AddTwoInts.h"
beginner_tutorials/AddTwoInts.h is the header file generated from the srv
file that we created earlier.

****** advertiseService()

***** writing a client node
#+BEGIN_EXAMPLE
  #include "ros/ros.h"
  #include "beginner_tutorials/AddTwoInts.h"
  #include <cstdlib>

  int main(int argc, char *argv[])
  {
    ros::init(argc, argv, "add_two_ints_client");
    if(argc != 3){
      ROS_INFO("usage: add_two_ints_client X Y");
      return 1;
    }

    ros::NodeHandle n;
    ros::serviceClient client = n.serviceClient<beginner_tutorials::AddTwoInts>("add_two_ints");
    beginner_tutorials::AddTwoInts srv;
    srv.request.a = atoll(argv[1]);
    srv.request.b = atoll(argv[2]);
    if(client.call(srv))
    {
      ROS_INFO("Sum: %ld", (long int)srv.Response.sum);
    }
    else
    {
      ROS_ERROR("Failed to call service add_two_ints");
      return 1;
    }

    return 0;
  }
#+END_EXAMPLE
****** serviceClient()
#+BEGIN_EXAMPLE
  ros::ServiceClient client =
       n.serviceClient<beginner_tutorials::AddTwoInts>("add_two_ints");
#+END_EXAMPLE
****** call()
#+BEGIN_EXAMPLE
  if (client.call(srv))
#+END_EXAMPLE
This actually calls the service. Since service calls are blocking, it will
return once the call is done. If the service call succeeded, call() will
return true and the value in srv.response will be valid. If the call did not
succeed, call() will return false and the value in srv.response will be
invalid.

***** builds the node
****** CMakelists.txt
#+BEGIN_EXAMPLE
  add_executable(add_two_ints_server src/add_two_ints_server.cpp)
  target_link_libraries(add_two_ints_server ${catkin_LIBRARIES})
  add_dependencies(add_two_ints_server beginner_tutorials_gencpp)

  add_executable(add_two_ints_client src/add_two_ints_client.cpp)
  target_link_libraries(add_two_ints_client ${catkin_LIBRARIES})
  add_dependencies(add_two_ints_client beginner_tutorials_gencpp)
#+END_EXAMPLE

**** ABORT Writing a Simple Service and Client (Python)
- State "ABORT"      from "TODO"       [2015-03-16 一 10:36]
**** DONE Examining the Simple Service and Client
- State "DONE"       from "TODO"       [2015-03-16 一 19:30]
#+BEGIN_EXAMPLE

#+END_EXAMPLE

*

*** DONE ROS Intermediate Level tutorials   [4/4]
- State "DONE"       from "TODO"       [2015-04-01 三 21:42]
**** DONE catkin
- State "DONE"       from "DONE"       [2015-04-01 三 21:42]
- State "DONE"       from "TODO"       [2015-03-17 二 15:37]
http://wiki.ros.org/catkin/Tutorials
***** creating a workspace for catkin
1. catkin_init_workspace in src folder
2. catkin_make in wokrspace folder
3. source devel/setup.bash
   + check: *echo $ROS_PACKAGE_PATH*
***** creating a ROS package
done.
***** building and using catkin packages in worksapce
****** with catkin_make
******* devel
#+BEGIN_EXAMPLE
  $ cd ~/catkin_ws/src/beginner_tutorials/src

  # Add/Edit source files

  $ cd ~/catkin_ws/src/beginner_tutorials

  # Update CMakeFiles.txt to reflect any changes to your sources

  $ cd ~/catkin_ws

  $ catkin_make -DCMAKE_BUILD_TYPE=Release
#+END_EXAMPLE
Comments:
+ build any packages in the *source space*
+ source files remain in the sourc space
+ build to *buid space*
+ any generated files are placed in *devel space*
  + libraries
  + executables
  + generated code
  + setup.*sh
+ *DCMAKE_BUILD_TYPE*: specify a CMake build type

******* install space
#+BEGIN_EXAMPLE
$ catkin_make install
#+END_EXAMPLE
+ equivalent to calling 'build && make install'
+ create a *install space(catkin_ws/install)*
  + contains its own *.sh files
  + sourcing *.sh will overlay this install space onto your
    environment
+ either install space or devel space(develop), *not both at the same time*
  + devel space is useful when you are developing
  + install space is useful when you are ready to distribute or
    'install' the package
+ pass the CMake argument *-DCMAKE_INSTALL_PREFIX=/opt/ros/indigo*

******* others
+ --force-cmake
  If you have a previously compiled workspace and you add a new
  package inside it, you can tell catkin to add this new package to
  the already-compiled binaries by adding this parameter:
  #+BEGIN_EXAMPLE
  $ catkin_make --force-cmake
  #+END_EXAMPLE
+ -DCMAKE_VERBOSE_MAKEFILE=ON
  If you want to see the command lines used to run the compiler and
  linker, run catkin_make with this option:
  #+BEGIN_EXAMPLE
  $ catkin_make -DCMAKE_VERBOSE_MAKEFILE=ON
  #+END_EXAMPLE

****** without catkin_make
not necessary

***** overlay with catkin workspace
*Overlaying* refers to building and using a ROS package from source on
top of an existing version of that same package. In this way your new
or modified version of the package "overlays" the installed one.

1. creating a new workspace
   #+BEGIN_EXAMPLE
   $ mkdir -p ~/overlay_ws/src
   $ cd ~/overlay_ws/src
   $ wstool init
   #+END_EXAMPLE
   This creates an initial ".rosinstall" file in your src folder,
   which will store the urls and versions of sources you download.

2. add a ros package
   #+BEGIN_EXAMPLE
     $ wstool set ros_tutorials --git git://github.com/ros/ros_tutorials.git
     $ wstool update
   #+END_EXAMPLE
   The first command creates an entry "ros_tutorials" in your
   ".rosinstall" file with the given git configuration, and the second
   command downloads the files.

3. build and source
   #+BEGIN_EXAMPLE
   $ cd ~/overlay_ws
   $ catkin_make
   $ source devel/setup.bash
   #+END_EXAMPLE

4. test overlaying or not
   #+BEGIN_EXAMPLE
   $ roscd rospy_tutorials
   #+END_EXAMPLE

**** DONE creating a ROS package by hand
- State "DONE"       from "TODO"       [2015-03-17 二 15:45]
There is a tool for creating ROS Packages (roscreate-pkg), but, as you will
see, there is nothing actually difficult here. roscreate-pkg prevents
mistakes and saves effort, but packages are just a directory and a simple
XML file.

1. create a new foobar package
   #+BEGIN_EXAMPLE
   $ mkdir foobar   # in the range of ROS_PACKAGE_PATH
   $ cd foobar
   #+END_EXAMPLE
2. add *manifest* file:  packge.xml
   #+BEGIN_EXAMPLE
     <package>
       <description brief="example package tutorial">A simple tutorial package</description>
       <author>Your Name Here</author>
       <license>BSD</license>
       <depend package="roscpp" />
       <depend package="std_msgs" />
     </package>
   #+END_EXAMPLE
3. CMakelist.txt
4. cutomize

**** DONE managing system dependencies
- State "DONE"       from "TODO"       [2015-03-17 二 15:56]
ROS packages sometimes require external libraries and tools that must
be provided by the operating system. These required libraries and
tools are commonly referred to as *system dependencies*. In some cases
these system dependencies are not installed by default. ROS provides a
simple tool, *rosdep*, that is used to download and install system
dependencies.

ROS packages must declare that they need these system dependencies in
the package manifest. Let's look at the manifest for the turtlesim
package:
#+BEGIN_EXAMPLE
$ roscd turtlesim
$ cat package.xml
#+END_EXAMPLE
#+BEGIN_EXAMPLE
  <package>
  ...
  ...
    <build_depend>message_generation</build_depend>
    <build_depend>libqt4-dev</build_depend>
    <build_depend>qt4-qmake</build_depend>
    <build_depend>rosconsole</build_depend>
这    <build_depend>roscpp</build_depend>
    <build_depend>roscpp_serialization</build_depend>
    <build_depend>roslib</build_depend>
    <build_depend>rostime</build_depend>
    <build_depend>std_msgs</build_depend>
    <build_depend>std_srvs</build_depend>
  </package>
#+END_EXAMPLE

As you can see turtlesim needs libqt4-dev and qt4-qmake.

***** rosdep
*rosdep* is a tool you can use to install system dependencies required
by ros packages.
+ Usage: *rosdep install [package]*

**** DONE Using a C++ in Python
- State "DONE"       from "TODO"       [2015-03-17 二 15:57]
boost

*** turtlesim
**** NodeHandlePtr
+ typedef boost::shared_ptr<NodeHandle> NodeHandlePtr;
+
*** roscpp_tutorials
*** rospy_tutorials

** Gazebo                                                              :ros:
*** Tutorials
**** write a plugin

***** Plugins 101
+ http://www.gazebosim.org/tutorials?tut=plugins_hello_world&cat=write_plugin

***** Overview of Gazebo Plugins

A plugin is a chunk of code that is compiled as a shared library and
inserted into the simulation. The plugin has direct access to all the
functionality of Gazebo through the standard C++ classes.

Plugins are useful because they:

-  let developers control almost any aspect of Gazebo
-  are self-contained routines that are easily shared
-  can be inserted and removed from a running system

Previous versions of Gazebo utilized controllers. These behaved in much
the same way as plugins, but were statically compiled into Gazebo.
Plugins are more flexible, and allow users to pick and choose what
functionality to include in their simulations.

You should use a plugin when:

-  you want to programmaticaly alter a simulation

Ex: move models, respond to events, insert new models given a set of
preconditions * you want a fast interface to gazebo, without the
overhead of the transport layer

Ex: No serialization and deserialization of messages. * you have some
code that could benefit others and want to share it

***** Plugin Types

There are currently 5 types of plugins

1. World
2. Model
3. Sensor
4. System.
5. Visual.

Each plugin type is managed by a different component of Gazebo. For
example, a Model plugin is attached to and controls a specific model in
Gazebo. Similarly, a World plugin is attached to a world, and a Sensor
plugin to a specific sensor. The System plugin is specified on the
command line, and loads first during a Gazebo startup. This plugin gives
the user control over the startup process.

A plugin type should be chosen based on the desired functionality. Use a
World plugin to control world properties, such as the physics engine,
ambient lighting, etc. Use a Model plugin to control joints, and state
of a model. Use a Sensor plugin to acquire sensor information and
control sensor properties.

***** Hello WorldPlugin!

Plugins are designed to be simple. A bare bones world plugin contains a
class with a few member functions.

First, if you installed Gazebo from debians, make sure you've installed
the Gazebo development files. If you installed Gazebo from source, you
can ignore this step. If you have a lower release than gazebo5, replace
5 with whatever version number you have.

#+BEGIN_EXAMPLE
    sudo apt-get install libgazebo5-dev
#+END_EXAMPLE

Next, make a directory and a .cc file for the new plugin:

#+BEGIN_EXAMPLE
    $ mkdir ~/gazebo_plugin_tutorial
    $ cd ~/gazebo_plugin_tutorial
    $ gedit hello_world.cc
#+END_EXAMPLE

Copy the following into hello_world.cc:

#+BEGIN_EXAMPLE
    #include <gazebo/gazebo.hh>

    namespace gazebo
    {
      class WorldPluginTutorial : public worldplugin
      {
        public: WorldPluginTutorial() : WorldPlugin()
                {
                  printf("Hello World!\n");
                }

        public: void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf)
                {
                }
      };
      GZ_REGISTER_WORLD_PLUGIN(WorldPluginTutorial)
    }
#+END_EXAMPLE

The above code is also located in the Gazebo sources:
[[http://bitbucket.org/osrf/gazebo/src/gazebo_2.2/examples/plugins/hello_world][examples/plugins/hello/world/hello/world.cc]],
along with an appropriate CMakeLists.txt file.

****** Code Explained

#+BEGIN_EXAMPLE
    #include <gazebo/gazebo.hh>

    namespace gazebo
    {
#+END_EXAMPLE

The
[[https://bitbucket.org/osrf/gazebo/src/gazebo_2.2/gazebo/gazebo_core.hh][gazebo/gazebo.hh]]
file includes a core set of basic gazebo functions. It doesn't include
=gazebo/physics/physics.hh=, =gazebo/rendering/rendering.hh=, or
=gazebo/sensors/sensors.hh= as those should be included on a case by
case basis. All plugins must be in the =gazebo= namespace.

#+BEGIN_EXAMPLE
      class WorldPluginTutorial : public worldplugin
      {
        public: WorldPluginTutorial() : WorldPlugin()
                {
                  printf("Hello World!\n");
                }
#+END_EXAMPLE

Each plugin must inherit from a plugin type, which in this case is the
=WorldPlugin= class.

#+BEGIN_EXAMPLE
        public: void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf)
                {
                }
#+END_EXAMPLE

The only other mandatory function is =Load= which receives an SDF
element that contains the elements and attributes specified in loaded
SDF file.

#+BEGIN_EXAMPLE
      GZ_REGISTER_WORLD_PLUGIN(WorldPluginTutorial)
#+END_EXAMPLE

Finally, the plugin must be registered with the simulator using the
=GZ_REGISTER_WORLD_PLUGIN= macro. The only parameter to this macro is
the name of the plugin class. There are matching register macros for
each plugin type: =GZ_REGISTER_MODEL_PLUGIN=,
=GZ_REGISTER_SENSOR_PLUGIN=, =GZ_REGISTER_SYSTEM_PLUGIN= and
=GZ_REGISTER_VISUAL_PLUGIN=.

The following section contains instructions on how to compile this
plugin.

****** Compiling the Plugin

Please make sure that gazebo has been properly
[[http://gazebosim.org/#download][installed]].

To compile the above plugin, create
=~/gazebo_plugin_tutorial/CMakeLists.txt=:

#+BEGIN_EXAMPLE
    $ gedit ~/gazebo_plugin_tutorial/CMakeLists.txt
#+END_EXAMPLE

Copy the following in CMakeLists.txt:

#+BEGIN_EXAMPLE
    cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

    find_package(Boost REQUIRED COMPONENTS system)
    include_directories(${Boost_INCLUDE_DIRS})
    link_directories(${Boost_LIBRARY_DIRS})

    include (FindPkgConfig)
    if (PKG_CONFIG_FOUND)
      pkg_check_modules(GAZEBO gazebo)
    endif()
    include_directories(${GAZEBO_INCLUDE_DIRS})
    link_directories(${GAZEBO_LIBRARY_DIRS})

    add_library(hello_world SHARED hello_world.cc)
    target_link_libraries(hello_world ${GAZEBO_LIBRARIES} ${Boost_LIBRARIES})
#+END_EXAMPLE

Create the build directory

#+BEGIN_EXAMPLE
    $ mkdir ~/gazebo_plugin_tutorial/build
    $ cd ~/gazebo_plugin_tutorial/build
#+END_EXAMPLE

Compile the code.

#+BEGIN_EXAMPLE
    $ cmake ../
    $ make
#+END_EXAMPLE

Compiling will result in a shared library,
=~/gazebo_plugin_tutorial/build/libhello_world.so=, that can be inserted
in a Gazebo simulation.

Lastly, add your library path to the =GAZEBO_PLUGIN_PATH=:

#+BEGIN_EXAMPLE
    $ export GAZEBO_PLUGIN_PATH=${GAZEBO_PLUGIN_PATH}:~/gazebo_plugin_tutorial/build
#+END_EXAMPLE

***** Using a Plugin

Once you have a plugin compiled as a shared library (see above), you can
attach it to a world or model in an SDF file (see
[[http://gazebosim.org/sdf.html][SDF documentation]] for more info). On
startup, Gazebo parses the SDF file, locates the plugin, and loads the
code. It is important that Gazebo is capable of finding the plugin.
Either the full path to the plugin is specified, or the plugin exists in
one of the paths in the GAZEBO/PLUGIN/PATH environment variable.

Example world file also found in
[[https://bitbucket.org/osrf/gazebo/src/gazebo_2.2/examples/plugins/hello_world/hello.world][examples/plugins/hello_world/hello.world]].

#+BEGIN_EXAMPLE
    <?xml version="1.0"?>
    <sdf version="1.4">
      <world name="default">
        <plugin name="hello_world" filename="libhello_world.so"/>
      </world>
    </sdf>
#+END_EXAMPLE

Make a copy of the file in =~/gazebo_plugin_tutorial/hello.world=

If you don't have the build directory in your =GAZEBO_PLUGIN_PATH=, then
you must run the Gazebo server from your build directory:

#+BEGIN_EXAMPLE
    $ cd build
    $ gzserver ../hello.world --verbose
#+END_EXAMPLE

You should see output similar to:

#+BEGIN_EXAMPLE
    Gazebo multi-robot simulator, version 1.9.5
    Copyright (C) 2013 Open Source Robotics Foundation.
    Released under the Apache 2 License.
    http://gazebosim.org

    Msg Waiting for master
    Msg Connected to gazebo master @ http://localhost:11345
    Hello World!
#+END_EXAMPLE

















©2014 Open Source Robotics Foundation





Gazebo is open-source licensed under
[[http://www.apache.org/licenses/LICENSE-2.0.html][Apache 2.0]]





[[//plus.google.com/u/0/115981436296571800301?prsrc=3][[[/assets/google_gray-81ac802c18d850ab8cd58e127da1cc45.png]]]]
[[https://www.youtube.com/channel/UCJyqf9XJpDoM9XnpAwW6WxA][[[/assets/youtube_gray-41cfae2ba83f384053594eb0573cbc37.png]]]]
[[https://twitter.com/GazeboSim][[[/assets/twitter_gray-0c4a05fb4a031251e0a567e9f2d1674a.png]]]]










**** connect to ROS
***** Tutorial: Ros Plugins

In this tutorial we'll walk through creating a very basic Gazebo plugin
that is *ROS-aware*.

****** Create a ROS Package

Create a new ROS package in your catkin workspace:

#+BEGIN_EXAMPLE
    cd ~/catkin_ws
    catkin_create-pkg gazebo_tutorials gazebo_ros roscpp
#+END_EXAMPLE

****** Create the Plugin

Create a very simple plugin as described
[[http://gazebosim.org/tutorials?tut=plugins_hello_world&cat=write_plugin][here]]
and save the file as =gazebotutorials/src/simpleworld_plugin.cpp=:

#+BEGIN_EXAMPLE
    #include <gazebo/common/Plugin.hh>
    #include <ros/ros.h>

    namespace gazebo
    {
    class WorldPluginTutorial : public worldplugin
    {
    public:
      WorldPluginTutorial() : worldplugin()
      {
      }

      void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf)
      {
        // Make sure the ROS node for Gazebo has already been initialized
        if (!ros::isInitialized())
        {
          ROS_FATAL_STREAM("A ROS node for Gazebo has not been initialized, unable to load plugin. "
            << "Load the Gazebo system plugin 'libgazebo_ros_api_plugin.so' in the gazebo_ros package)");
          return;
        }

        ROS_INFO("Hello World!");
      }

    };
    GZ_REGISTER_WORLD_PLUGIN(WorldPluginTutorial)
    }
#+END_EXAMPLE

****** Update CMakeLists.txt

Open =gazebo_tutorials/CMakeLists.txt= and replace it with the
following:

#+BEGIN_EXAMPLE
    cmake_minimum_required(VERSION 2.8.3)
    project(gazebo_tutorials)

    # Load catkin and all dependencies required for this package
    find_package(catkin REQUIRED COMPONENTS
      roscpp
      gazebo_ros
    )

    # Depend on system install of Gazebo
    find_package(gazebo REQUIRED)

    link_directories(${GAZEBO_LIBRARY_DIRS})
    include_directories(${Boost_INCLUDE_DIR} ${catkin_INCLUDE_DIRS} ${GAZEBO_INCLUDE_DIRS})

    add_library(${PROJECT_NAME} src/simple_world_plugin.cpp)
    target_link_libraries(${PROJECT_NAME} ${catkin_LIBRARIES} ${GAZEBO_LIBRARIES})

    catkin_package(
      DEPENDS
        roscpp
        gazebo_ros
    )
#+END_EXAMPLE

****** Update package.xml

Update =gazebo_tutorials/package.xml= by adding the following line
within the == tags (or add the == tags also).

#+BEGIN_EXAMPLE
      <gazebo_ros plugin_path="${prefix}/lib" gazebo_media_path="${prefix}" />
#+END_EXAMPLE

****** Compiling the Plugin

Build the plugin by going to the base of your work space and running
catkin:

#+BEGIN_EXAMPLE
    cd ~/catkin_ws
    catkin_make
#+END_EXAMPLE

****** Creating a World file

Save the following file as =gazebo_tutorials/worlds/hello.world=:

#+BEGIN_EXAMPLE
    <?xml version="1.0" ?>
    <sdf version="1.4">
      <world name="default">
        <include>
          <uri>model://ground_plane</uri>
        </include>

        <include>
          <uri>model://sun</uri>
        </include>

        <!-- reference to your plugin -->
        <plugin name="gazebo_tutorials" filename="libgazebo_tutorials.so"/>
      </world>
    </sdf>
#+END_EXAMPLE

****** Create a Launch File

Create the following launch file gazebo_tutorials/launch/hello.launch:

#+BEGIN_EXAMPLE
    <launch>
      <!-- We resume the logic in empty_world.launch, changing only the name of the world to be launched -->
      <include file="$(find gazebo_ros)/launch/empty_world.launch">
        <arg name="world_name" value="$(find gazebo_tutorials)/worlds/hello.world"/>
        <!-- more default parameters can be changed here -->
      </include>
    </launch>
#+END_EXAMPLE

****** Run the Plugin

#+BEGIN_EXAMPLE
    roslaunch gazebo_tutorials hello.launch
#+END_EXAMPLE

An empty Gazebo should open and in the terminal you should see it print
out something like:

#+BEGIN_EXAMPLE
     INFO ros.gazebo_tutorials: Hello World!
#+END_EXAMPLE

****** Starting from a Template

A template is available to help you quickly get a Gazebo-ROS plugin
working:

[[https://github.com/ros-simulation/gazebo_ros_pkgs/blob/hydro-devel/gazebo_plugins/src/gazebo_ros_template.cpp][gazebo/ros/template.cpp]]

****** Adding Functionality

To make your plugin do something useful with Gazebo and ROS, we suggest
you read the ROS-agnostic tutorials on
[[http://gazebosim.org/tutorials/?cat=write_plugin][Plugins]].

****** ROS Node Note

All gazebo-ros plugins should check if the ROS node has already been
initialized in their =Load()= function, as discussed in this
[[http://answers.gazebosim.org/question/1493/rosinit-needed-for-ros-gazebo-plugin/][issue]].
The initialization of the ROS node is performed automatically when you
run

#+BEGIN_EXAMPLE
    rosrun gazeboros gazebo
#+END_EXAMPLE

or use the generic empty.world launch file. The
#+BEGIN_EXAMPLE
    gazeboros/src/gazeborosapi_plugin.cpp
#+END_EXAMPLE

should be the only place in Gazebo that calls
#+BEGIN_EXAMPLE
    ros::init()
#+END_EXAMPLE

.

****** tagerill
+ catkin_make: *The manifest (with format version 1) must not contain
  the following tags: gazebo_ros*

  - 如果要声明路径的话，应该在CMakelists.txt文件中进行声明，默认的即好
***** Using roslaunch to spawn URDF Robots
****** Two ways
1. Ros Service Call Spawn Method(recommanded)
   1) cmd
      #+BEGIN_EXAMPLE
        rosrun gazebo_ros spawn_mode -file `rospack find MYROBOT_description` \
        /urdf/MYROBOT.urdf -urdf -x 0 -y 0 -z 1 -model MYROBOT
      #+END_EXAMPLE
   2) launch
      #+BEGIN_EXAMPLE
        <!-- Spawn a robot into Gazebo -->
        <node name="spawn_urdf" pkg="gazebo_ros" type="spawn_model" args=
              "-file $(find baxter_description)/urdf/baxter.urdf -z 1 -model baxter"/>
      #+END_EXAMPLE

2. Model Database Method
****** empty_world.launch
#+BEGIN_SRC xml
  <launch>

    <!-- these are the arguments you can pass this launch file, for example paused:=true -->
    <arg name="paused" default="false"/>
    <arg name="use_sim_time" default="true"/>
    <arg name="extra_gazebo_args" default=""/>
    <arg name="gui" default="true"/>
    <arg name="headless" default="false"/>
    <arg name="debug" default="false"/>
    <arg name="physics" default="ode"/>
    <arg name="verbose" default="false"/>
    <arg name="world_name" default="worlds/empty.world"/> <!-- Note: the world_name is with respect to GAZEBO_RESOURCE_PATH environmental variable -->

    <!-- set use_sim_time flag -->
    <group if="$(arg use_sim_time)">
      <param name="/use_sim_time" value="true" />
    </group>

    <!-- set command arguments -->
    <arg unless="$(arg paused)" name="command_arg1" value=""/>
    <arg     if="$(arg paused)" name="command_arg1" value="-u"/>
    <arg unless="$(arg headless)" name="command_arg2" value=""/>
    <arg     if="$(arg headless)" name="command_arg2" value="-r"/>
    <arg unless="$(arg verbose)" name="command_arg3" value=""/>
    <arg     if="$(arg verbose)" name="command_arg3" value="--verbose"/>
    <arg unless="$(arg debug)" name="script_type" value="gzserver"/>
    <arg     if="$(arg debug)" name="script_type" value="debug"/>

    <!-- start gazebo server-->
    <node name="gazebo" pkg="gazebo_ros" type="$(arg script_type)" respawn="false" output="screen"
          args="$(arg command_arg1) $(arg command_arg2) $(arg command_arg3) -e $(arg physics) $(arg extra_gazebo_args) $(arg world_name)" />

    <!-- start gazebo client -->
    <group if="$(arg gui)">
      <node name="gazebo_gui" pkg="gazebo_ros" type="gzclient" respawn="false" output="screen"/>
    </group>

  </launch>
#+END_SRC
****** roslaunch arguments
You can append the following arguments to the launch files to change
the behavior of Gazebo:
+ *paused*

  Start Gazebo in a paused state (default false)

+ *usesimtime*

  Tells ROS nodes asking for time to get the Gazebo-published
  simulation time, published over the ROS topic /clock (default true)

+ *gui*

  Launch the user interface window of Gazebo (default true)

+ *headless*

  Disable any function calls to simulator rendering (Ogre)
  components. Does not work with gui:=true (default false)

+ *debug*

  Start gzserver (Gazebo Server) in debug mode using gdb (default
  false)

***** using gazebo plugins with ROS
#+BEGIN_SRC xml
   <gazebo reference="hokuyo_link">
      <sensor type="gpu_ray" name="head_hokuyo_sensor">
        <pose>0 0 0 0 0 0</pose>
        <visualize>false</visualize>
        <update_rate>40</update_rate>
        <ray>
          <scan>
            <horizontal>
              <samples>720</samples>
              <resolution>1</resolution>
              <min_angle>-1.570796</min_angle>
              <max_angle>1.570796</max_angle>
            </horizontal>
          </scan>
          <range>
            <min>0.10</min>
            <max>30.0</max>
            <resolution>0.01</resolution>
          </range>
          <noise>
            <type>gaussian</type>
            <!-- Noise parameters based on published spec for Hokuyo laser
                 achieving "+-30mm" accuracy at range < 10m.  A mean of 0.0m and
                 stddev of 0.01m will put 99.7% of samples within 0.03m of the true
                 reading. -->
            <mean>0.0</mean>
            <stddev>0.01</stddev>
          </noise>
        </ray>
        <plugin name="gazebo_ros_head_hokuyo_controller" filename="libgazebo_ros_gpu_laser.so">
          <topicName>/rrbot/laser/scan</topicName>
          <frameName>hokuyo_link</frameName>
        </plugin>
      </sensor>
    </gazebo>
#+END_SRC

*去掉gpu_*

***** gazebo tutorials: ros communication
+ http://gazebosim.org/tutorials/?tut=ros_comm


Gazebo provides a set of ROS API's that allows users to modify and get
information about various aspects of the simulated world.

****** plugins
+ gazebo_ros_api_plugin
+ gazebo_ros_path_plugin

****** Gazebo published parameters
+ parameters: */use_sim_time*:bool
****** Gazebo subscribed topics
+ topic: *set_link_state*
  + message: *gazebo_msgs/ModelState*

+ topic: *set_robot_state*
  + message: *gazebo_msgs/ModelState*

****** Gazebo Published Topics
+ topic: */clock*
  - message: *rosgraph_msgs/Clock*
  - publish simulation time
  - parameter: /use_sim_time

+ topic: *~/links_states*
  - message: *gazebo_msgs/LinkStates*
  - publishes states of all the links in simulation

+ topic: *~/model_state*
  - message: *gazebo_msgs/ModelState*
  - publishes states of all the models in simulation

****** services: Create and destroy models in simulation
+ service: *~/spawn_urdf_model*
  - message: *gazebo_msgs/SpawnModel*
  - to spawn a URDF
+ service: *~/spawn_sdf_model*
  - message: *gazebo_msgs/SpawnModel*
  - to spawn a model written in sdf
+ service: *~/delete_model*
  - message: *gazebo_msgs/DeleteModel*
  - delete model from simulation

****** services: State and Property getters
+ *~/get_model_properties: gazebo_msgs/GetModelProperties*
+ *~/get_model_state: gazebo_msgs/GetModelState*
+ *~/get_world_properties: gazebo_msgs/GetWorldProperties*
+ *~/get_joint_properties: gazebo_msgs/GetJointProperties*
+ *~/get_link_properties: gazebo_msgs/GetLinkProperties*
+ *~/get_link_state: gazebo_msgs/GetLinkState*
+ *~/get_physics_properties: gazebo_msgs/GetPhysicsProperties*
+ *~/link_states: gazebo_msgs/LinkStates*
+ *~/model_states: gazebo_msgs/ModelStates*

****** Services: Force control
+ *~/apply_body_wrench: gazebo_msgs/ApplyBodyWrench*
+ *~/apply_joint_effort: gezebo_msgs/ApplyJointEffort*
+ *~/clear_joint_effort: gazebo_msgs/ClearJointEffort*
+ *~/clear_body_wrench: gazebo_msgs/ClearBodyWrench*

****** Services: Simulation control
+ *~/pause_physics: std_srvs/Empty*
+ *~/unpause_physics: std_srvs/Empty*
+ *~/reset_simulation: std_srvs/Empty*
+ *~/reset_world: std_srvs/Empty*

***** Tutorial: ROS Control

In this tutorial we will setup simulated controllers to actuate the
joints of your robot. This will allow us to provide the correct ROS
interfaces for planners like [[http://moveit.ros.org][MoveIt!]]. We will
be using the [[http://ros.org/wiki/ros_control][ros_control]] packages,
a new standard in ROS for controller interfaces.

****** About ros_control

We encourage you to read an overview of the documentation on
[[http://ros.org/wiki/ros_control][ros_control]] before proceeding.

****** Data flow of ros_control and Gazebo

Simulating a robot's controllers in Gazebo can be accomplished using
ros_control and a simple Gazebo plugin adapter. An overview of the
relationship between simulation, hardware, controllers and transmissions
is shown below:

[[https://bitbucket.org/osrf/gazebo_tutorials/raw/default/ros_control/Gazebo_ros_transmission.png]]

****** Prerequisites

This tutorial builds off of many of the concepts in the previous
tutorials. We will again be using the RRBot that was setup in the
[[http://gazebosim.org/tutorials/?tut=ros_urdf][Using URDF in Gazebo]]
tutorial, as an example for the plugins covered here.

Make sure you have already installed ros_control, ros_controllers, and
their dependencies as described in the
[[http://gazebosim.org/tutorials?tut=ros_installing&cat=connect_ros][installation
instructions]].

****** Usage

******* Add transmission elements to a URDF

To use ros_control with your robot, you need to add some additional
elements to your URDF. The =<transmission>= element is used to link
actuators to joints, see the
[[http://ros.org/wiki/urdf/XML/Transmission][=<transmission>= spec]] for
exact XML format.

For the purposes of gazebo_ros_control in its current implementation,
the only important information in these transmission tags are:

-  =<joint name="">= - the name must correspond to a joint else where in
   your URDF
-  =<type>= - the type of transmission. Currently only
   "transmission_interface/SimpleTransmission" is implemented. (feel
   free to add more)
-  =<hardwareInterface>= - within the =<actuator>= tag, this tells the
   gazebo_ros_control plugin what hardware interface to load
   (position, velocity or effort interfaces). Currently only effort
   interfaces are implemented. (feel free to add more)

The rest of the names and elements are currently ignored.

******* Add the gazebo_ros_control plugin

In addition to the transmission tags, a Gazebo plugin needs to be added
to your URDF that actually parses the transmission tags and loads the
appropriate hardware interfaces and controller manager. By default the
gazebo_ros_control plugin is very simple, though it is also extensible
via an additional plugin architecture to allow power users to create
their own custom robot hardware interfaces between ros_control and
Gazebo.

The default plugin XML should be added to your URDF:

#+BEGIN_EXAMPLE
    <gazebo>
      <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">
        <robotNamespace>/MYROBOT</robotNamespace>
      </plugin>
    </gazebo>
#+END_EXAMPLE

The gazebo_ros_control =<plugin>= tag also has the following optional
child elements:

-  =<robotNamespace>=: The ROS namespace to be used for this instance of
   the plugin, defaults to robot name in URDF/SDF
-  =<controlPeriod>=: The period of the controller update (in seconds),
   defaults to Gazebo's period
-  =<robotParam>=: The location of the robot_description (URDF) on the
   parameter server, defaults to '/robot_description'
-  =<robotSimType>=: The pluginlib name of a custom robot sim interface
   to be used (see below for more details), defaults to
   'DefaultRobotHWSim'

******** Default gazebo_ros_control Behavior

By default, without a =<robotSimType>= tag, gazebo_ros_control will
attempt to get all of the information it needs to interface with a
ros_control-based controller out of the URDF. This is sufficient for
most cases, and good for at least getting started.

The default behavior provides the following ros_control interfaces:

-  hardware_interface::JointStateInterface
-  hardware_interface::EffortJointInterface
-  hardware_interface::VelocityJointInterface - /not fully implemented/

******** Advanced: custom gazebo_ros_control Simulation Plugins

The gazebo_ros_control Gazebo plugin also provides a pluginlib-based
interface to implement custom interfaces between Gazebo and ros_control
for simulating more complex mechanisms (nonlinear springs, linkages,
etc).

These plugins must inherit gazebo_ros_control::RobotHWSim which
implements a simulated ros_control hardware_interface::RobotHW.
RobotHWSim provides API-level access to read and command joint
properties in the Gazebo simulator.

The respective RobotHWSim sub-class is specified in a URDF model and is
loaded when the robot model is loaded. For example, the following XML
will load the default plugin (same behavior as when using no
=<robotSimType>= tag):

#+BEGIN_EXAMPLE
    <gazebo>
      <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">
        <robotNamespace>/MYROBOT</robotNamespace>
        <robotSimType>gazebo_ros_control/DefaultRobotHWSim</robotSimType>
      </plugin>
    </gazebo>
#+END_EXAMPLE

******* RRBot Example

We add a =<transmission>= block similar to the following for every joint
that we wish to have Gazebo actuate. Open your =rrbot.xacro= file and at
the bottom of the file you should see:

#+BEGIN_EXAMPLE
      <transmission name="tran1">
        <type>transmission_interface/SimpleTransmission</type>
        <joint name="joint1"/>
        <actuator name="motor1">
          <hardwareInterface>EffortJointInterface</hardwareInterface>
          <mechanicalReduction>1</mechanicalReduction>
        </actuator>
      </transmission>

      <transmission name="tran2">
        <type>transmission_interface/SimpleTransmission</type>
        <joint name="joint2"/>
        <actuator name="motor2">
          <hardwareInterface>EffortJointInterface</hardwareInterface>
          <mechanicalReduction>1</mechanicalReduction>
        </actuator>
      </transmission>
#+END_EXAMPLE

You'll also see the gazebo_ros_control plugin in =rrbot.gazebo= that
reads in all the =<transmission>= tags:

#+BEGIN_EXAMPLE
    <gazebo>
      <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">
        <robotNamespace>/rrbot</robotNamespace>
      </plugin>
    </gazebo>
#+END_EXAMPLE

******* Create a ros_controls package

We'll next need to create a configuration file and launch file for our
ros_control controllers that interface with Gazebo.

******** Create new package

#+BEGIN_EXAMPLE
    mkdir ~/catkin_ws
    cd ~/catkin_ws
    catkin_create_pkg MYROBOT_control ros_control ros_controllers
    cd MYROBOT_control
    mkdir config
    mkdir launch
#+END_EXAMPLE

******** Create a .yaml config file

The PID gains and controller settings must be saved in a yaml file that
gets loaded to the param server via the roslaunch file. In the config
folder of your =MYROBOT_control= package, adapt the following RRBot
example to your robot as =MYROBOT_control/config/rrbot_control.yaml=:

#+BEGIN_EXAMPLE
    rrbot:
      # Publish all joint states -----------------------------------
      joint_state_controller:
        type: joint_state_controller/JointStateController
        publish_rate: 50

      # Position Controllers ---------------------------------------
      joint1_position_controller:
        type: effort_controllers/JointPositionController
        joint: joint1
        pid: {p: 100.0, i: 0.01, d: 10.0}
      joint2_position_controller:
        type: effort_controllers/JointPositionController
        joint: joint2
        pid: {p: 100.0, i: 0.01, d: 10.0}
#+END_EXAMPLE

See the next section for more details about these controllers.

******** Create a roslaunch file

Create a roslaunch file for starting the ros_control controllers.
Within the launch folder create a
=MYROBOT_control/launch/MYROBOT_control.launch= file and adapt the
following RRBot example to your robot:

#+BEGIN_EXAMPLE
    <launch>

      <!-- Load joint controller configurations from YAML file to parameter server -->
      <rosparam file="$(find rrbot_control)/config/rrbot_control.yaml" command="load"/>

      <!-- load the controllers -->
      <node name="controller_spawner" pkg="controller_manager" type="spawner" respawn="false"
        output="screen" ns="/rrbot" args="joint1_position_controller joint2_position_controller joint_state_controller"/>

      <!-- convert joint states to TF transforms for rviz, etc -->
      <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher"
        respawn="false" output="screen">
        <remap from="/joint_states" to="/rrbot/joint_states" />
      </node>

    </launch>
#+END_EXAMPLE

********* Explanation

The first line, "rosparam", loads the controller settings to the
parameter server by loading a yaml configuration file (discussed in the
next section).

The controller_spawner node starts the two joint position controllers
for the RRBot by running a python script that makes a service call to
the ros_control controller manager. The service calls tell the
controller manager which controllers you want. It also loads a third
controller that publishes the joint states of all the joints with
hardware_interfaces and advertises the topic on /joint_states. The
spawner is just a helper script for use with roslaunch.

The final line starts a robot_state_publisher node that simply listens
to /joint_states messages from the joint_state_controller then
publishes the transforms to /tf. This allows you to see your simulated
robot in Rviz as well as do other tasks.

******* Start the controllers using roslaunch

Test the RRBot controlled by ros_control by running the following:

Start the RRBot simulation:

#+BEGIN_EXAMPLE
    roslaunch rrbot_gazebo rrbot_world.launch
#+END_EXAMPLE

Load the controllers for the two joints by running the second launch
file:

#+BEGIN_EXAMPLE
    roslaunch rrbot_control rrbot_control.launch
#+END_EXAMPLE

******** Using service calls manually

If you first load the rrbot_control.yaml files to the parameter server,
you could load the controllers manually through service requests. We'll
include them here for reference though we usually prefer roslaunch:

Load the controllers:

#+BEGIN_EXAMPLE
    rosservice call /rrbot/controller_manager/load_controller "name: 'joint1_position_controller'"
    rosservice call /rrbot/controller_manager/load_controller "name: 'joint2_position_controller'"
#+END_EXAMPLE

Start the controllers:

#+BEGIN_EXAMPLE
    rosservice call /rrbot/controller_manager/switch_controller "{start_controllers: ['joint1_position_controller','joint2_position_controller'], stop_controllers: [], strictness: 2}"
#+END_EXAMPLE

Stop the controllers:

#+BEGIN_EXAMPLE
    rosservice call /rrbot/controller_manager/switch_controller "{start_controllers: [], stop_controllers: ['joint1_position_controller','joint2_position_controller'], strictness: 2}"
#+END_EXAMPLE

******* Manually send example commands

Send example joint commands to them for testing:

#+BEGIN_EXAMPLE
    rostopic pub -1 /rrbot/joint1_position_controller/command std_msgs/Float64 "data: 1.5"
    rostopic pub -1 /rrbot/joint2_position_controller/command std_msgs/Float64 "data: 1.0"
#+END_EXAMPLE

******* Use RQT To Send Commands

In this section we'll go over tools to help you visualize the
performance of your controller and tune any gains/parameters the
controller might have, particularly PID gains. We'll be using
[[http://www.ros.org/wiki/rqt][RQT]], ROS's plugin-based user interface,
so be sure you first have that installed.

Start RQT:

#+BEGIN_EXAMPLE
    rosrun rqt_gui rqt_gui
#+END_EXAMPLE

******** Add a Command Publisher

On the 'Plugins' menu of RQT add the 'Topics->Message Publisher' plugin
then choose the topic from the drop down box that commands any
particular controller that you want to publish to. For the RRBot, add
the controller:

#+BEGIN_EXAMPLE
    /rrbot/joint1_position_controller/command
#+END_EXAMPLE

Then press the green plus sign button at the top right.

Enable the topic publisher by checking the check box on the left of the
topic name. Set the rate column to 100 (the frequency we send it
commands - 100hz in this case).

Next, expand the topic so that you see the "data" row. In the expression
column, on the data row, try different radian values between joint1's
joint limits - in RRBot's case there are no limits because the joints
are continuous, so any value works. You should be able to get the RRBot
to swing around if you are doing this tutorial with that robot.

Next, in that same expression box we'll have it automatically change
values using a sine wave. Add the following:

#+BEGIN_EXAMPLE
    sin(i/100)
#+END_EXAMPLE

For more advanced control, you can configure it to publish a sine wave
to your robot's exact joint limits:

#+BEGIN_EXAMPLE
    sin(i/rate*speed)*diff + offset
#+END_EXAMPLE

An explanation of variables:

-  i - the RQT variable for time
-  rate - the frequency that this expression is evaluated. This should
   be the same number as in the rate column of the topic publisher.
   Recommended value is 100.
-  speed - how quick you want the join to actuate. Start off with just 1
   for a slow speed
-  upper_limit and lower_limits - the joint limits of the hardware
   being controlled by this controller
-  diff = (upper_limit - lower_limit)/2
-  offset = upper_limit-diff

******** Visualize the controller's performance

Add a Plot plugin to RQT and add the same topic as the one you chose
above for the topic publisher:

#+BEGIN_EXAMPLE
    /rrbot/joint1_position_controller/command/data
#+END_EXAMPLE

Click the green add button. You should now see a sine wave being plotted
on the screen.

Add another topic to the Plot plugin that tracks the error between the
commanded position and actual position of the actuator being controlled.
For the RRBot:

#+BEGIN_EXAMPLE
    /rrbot/joint1_position_controller/state/error
#+END_EXAMPLE

You screen should look something like this:

[[https://bitbucket.org/osrf/gazebo_tutorials/raw/default/ros_control/rqt_controller_tuning.png]]

Note: the RQT plot plugin is known to have bugs after running for a
while (>1min). The drawings start acting strangely. The current solution
is to press the blue refresh button at the top right of the plugin.

******** Tune the PID gains

Finally, we'll use [[http://ros.org/wiki/dynamic_reconfigure][dynamic
reconfigure]] to tune the proportional, derivative, and integral gains
of the PID controller, assuming this is applicable to your robot.

Add the 'Dynamic Reconfigure' plugin to RQT and click 'Expand All' to
see the sub-options. Assuming your controller uses PID, you should use a
"pid" option. Clicking on it should reveal 5 sliders that let you tune
the controller, as pictured in the following screenshot. Adjust these
values until you get the desired performance of your controller.

[[https://bitbucket.org/osrf/gazebo_tutorials/raw/default/ros_control/rqt_dynamnic_reconfigure_pid.png]]

******** Use roslaunch to save your RQT perspective

A pre-configured RQT perspective for the rrbot can be easily launched
with the following command:

#+BEGIN_EXAMPLE
    roslaunch rrbot_control rrbot_rqt.launch
#+END_EXAMPLE

You can use that as a template for doing this with your own robot.

******* Connect Rviz to Gazebo Simulation

Now that you are using ros_control to send commands to your robot in
simulation, you can also use the ros_control joint/state/controller to
read the state of the robot from Gazebo. The idea behind a good
simulator is that you should be able to use the same software on your
real hardware as you do in simulation. A good starting point for that is
visualizing your simulated robot in Rviz, similar to how it is done with
real hardware.

Assuming you are already starting a joint_state_controller as
documented above in your rosparam and roslaunch files, your next step is
to start Rviz:

#+BEGIN_EXAMPLE
    rosrun rviz rviz
#+END_EXAMPLE

Under "Global Options" change your "Fixed Frame" to "world" to resolve
any errors it might be giving you.

Next, add a "RobotModel" display type to Rviz and you should then see
your simulated robot in Gazebo being visualized in Rviz!

****** 使用

******* 问题1： ros_control 是stack，而不是package, ros_controllers是metapackags，都不能做为catkin_create_pkg时的依赖包(后者警告)
#+BEGIN_EXAMPLE
catkin_create_pkg MYROBOT_control ros_control ros_controller
#+END_EXAMPLE
教程中该命令不成立，不要盲目迷信官方Tutorial，可能会过时，跟不上发展

#+BEGIN_SRC sh :results output
find ~/.ckws/devel | grep libgazebo_ros | sort
#+END_SRC

#+RESULTS:
#+begin_example
/home/ben/.ckws/devel/lib/libgazebo_ros_api_plugin.so
/home/ben/.ckws/devel/lib/libgazebo_ros_block_laser.so
/home/ben/.ckws/devel/lib/libgazebo_ros_bumper.so
/home/ben/.ckws/devel/lib/libgazebo_ros_camera.so
/home/ben/.ckws/devel/lib/libgazebo_ros_camera_utils.so
/home/ben/.ckws/devel/lib/libgazebo_ros_control.so
/home/ben/.ckws/devel/lib/libgazebo_ros_depth_camera.so
/home/ben/.ckws/devel/lib/libgazebo_ros_diff_drive.so
/home/ben/.ckws/devel/lib/libgazebo_ros_f3d.so
/home/ben/.ckws/devel/lib/libgazebo_ros_force.so
/home/ben/.ckws/devel/lib/libgazebo_ros_ft_sensor.so
/home/ben/.ckws/devel/lib/libgazebo_ros_gpu_laser.so
/home/ben/.ckws/devel/lib/libgazebo_ros_hand_of_god.so
/home/ben/.ckws/devel/lib/libgazebo_ros_imu.so
/home/ben/.ckws/devel/lib/libgazebo_ros_joint_pose_trajectory.so
/home/ben/.ckws/devel/lib/libgazebo_ros_joint_state_publisher.so
/home/ben/.ckws/devel/lib/libgazebo_ros_joint_trajectory.so
/home/ben/.ckws/devel/lib/libgazebo_ros_kobuki.so
/home/ben/.ckws/devel/lib/libgazebo_ros_laser.so
/home/ben/.ckws/devel/lib/libgazebo_ros_multicamera.so
/home/ben/.ckws/devel/lib/libgazebo_ros_openni_kinect.so
/home/ben/.ckws/devel/lib/libgazebo_ros_p3d.so
/home/ben/.ckws/devel/lib/libgazebo_ros_paths_plugin.so
/home/ben/.ckws/devel/lib/libgazebo_ros_planar_move.so
/home/ben/.ckws/devel/lib/libgazebo_ros_projector.so
/home/ben/.ckws/devel/lib/libgazebo_ros_prosilica.so
/home/ben/.ckws/devel/lib/libgazebo_ros_skid_steer_drive.so
/home/ben/.ckws/devel/lib/libgazebo_ros_template.so
/home/ben/.ckws/devel/lib/libgazebo_ros_tricycle_drive.so
/home/ben/.ckws/devel/lib/libgazebo_ros_utils.so
/home/ben/.ckws/devel/lib/libgazebo_ros_video.so
#+end_example

******* 所以，control的库文件需要自己写

******* 先行研究gazebo_ros_control 和 turtlebot_gazebo_control

******** gazebo_ros_control

*** [[https://bitbucket.org/osrf/gzweb/issue/66/configurable-cameraview-init-pose][gazebo 初始视角]]

clude: willowgarage.world文件

#+BEGIN_SRC xml
  <world>
    <gui>
      <camera name="camera_world_main">
        <pose>57 15 1 0 0.05 1.4</pose>
      </camera>
    </gui>
  </world>
#+END_SRC


from rrbot_gazebo
#+BEGIN_SRC xml
  <?xml version="1.0" ?>
  <sdf version="1.4">
    <!-- We use a custom world for the rrbot so that the camera angle is launched correctly -->

    <world name="default">
      <include>
        <uri>model://ground_plane</uri>
      </include>

      <!-- Global light source -->
      <include>
        <uri>model://sun</uri>
      </include>

      <!-- Focus camera on tall pendulum -->
      <gui fullscreen='1'>
        <camera name='user_camera'>
          <pose>4.927360 -4.376610 3.740080 0.000000 0.275643 2.356190</pose>
          <view_controller>orbit</view_controller>
        </camera>
      </gui>

    </world>
  </sdf>

#+END_SRC
**** TODO 问题： 相机视角是怎么定义的，如何合适地进行修改？

**** TODO 为何gui标签的其它元素不能使用？

*** spawn_model
**** arguments
rosrun gazebo_ros spawn_model --help
spawn_model script started
Commands:
+ -[urdf|sdf|trimesh|gazebo] - specify incoming xml is urdf, sdf or
  trimesh format. gazebo arg is deprecated in ROS Hydro

+ -[file|param|database] [<file_name>|<param_name>|<model_name>] -
  source of the model xml or the trimesh file

+ -model <model_name> - name of the model to be spawned.

+ -reference_frame <entity_name> - optinal: name of the model/body
  where initial pose is defined.

+ If left empty or specified as "world", gazebo world frame is used.

+ -gazebo_namespace <gazebo ros_namespace> - optional: ROS namespace
  of gazebo offered ROS interfaces.  Defaults to /gazebo/
  (e.g. /gazebo/spawn_model).

+ -robot_namespace <robot ros_namespace> - optional: change ROS
  namespace of gazebo-plugins.

+ -unpause - optional: !!!Experimental!!! unpause physics after
  spawning model

+ -wait - optional: !!!Experimental!!! wait for model to exist

+ -trimesh_mass <mass in kg> - required if -trimesh is used: linear
  mass

+ -trimesh_ixx <moment of inertia in kg*m^2> - required if -trimesh is
  used: moment of inertia about x-axis

+ -trimesh_iyy <moment of inertia in kg*m^2> - required if -trimesh is
  used: moment of inertia about y-axis

+ -trimesh_izz <moment of inertia in kg*m^2> - required if -trimesh is
  used: moment of inertia about z-axis

+ -trimesh_gravity <bool> - required if -trimesh is used: gravity
  turned on for this trimesh model

+ -trimesh_material <material name as a string> - required if -trimesh
  is used: E.g. Gazebo/Blue

+ -trimesh_name <link name as a string> - required if -trimesh is
  used: name of the link containing the trimesh

+ -x <x in meters> - optional: initial pose, use 0 if left out

+ -y <y in meters> - optional: initial pose, use 0 if left out

+ -z <z in meters> - optional: initial pose, use 0 if left out

+ -R <roll in radians> - optional: initial pose, use 0 if left out

+ -P <pitch in radians> - optional: initial pose, use 0 if left out

+ -Y <yaw in radians> - optional: initial pose, use 0 if left out

+ -J <joint_name joint_position> - optional: initialize the specified
  joint at the specified value

**** spawn_model example
#+BEGIN_EXAMPLE
<node name="spawn_turtlebot_model" pkg="gazebo_ros" type="spawn_model"
          args="$(optenv ROBOT_INITIAL_POSE) -unpause -urdf -param robot_description -model mobile_base"/>
#+END_EXAMPLE
*** tabot

1. spawn 的初始位置和轮胎宽度“不当”可能会使模型加载后轮子莫名消失，
   不明所以，可能是inertial设置出错

*** empty_world.launch
#+BEGIN_SRC xml
  <launch>

    <!-- these are the arguments you can pass this launch file, for example paused:=true -->
    <arg name="paused" default="false"/>
    <arg name="use_sim_time" default="true"/>
    <arg name="extra_gazebo_args" default=""/>
    <arg name="gui" default="true"/>
    <arg name="headless" default="false"/>
    <arg name="debug" default="false"/>
    <arg name="physics" default="ode"/>
    <arg name="verbose" default="false"/>
    <arg name="world_name" default="worlds/empty.world"/> <!-- Note: the world_name is with respect to GAZEBO_RESOURCE_PATH environmental variable -->

    <!-- set use_sim_time flag -->
    <group if="$(arg use_sim_time)">
      <param name="/use_sim_time" value="true" />
    </group>

    <!-- set command arguments -->
    <arg unless="$(arg paused)" name="command_arg1" value=""/>
    <arg     if="$(arg paused)" name="command_arg1" value="-u"/>
    <arg unless="$(arg headless)" name="command_arg2" value=""/>
    <arg     if="$(arg headless)" name="command_arg2" value="-r"/>
    <arg unless="$(arg verbose)" name="command_arg3" value=""/>
    <arg     if="$(arg verbose)" name="command_arg3" value="--verbose"/>
    <arg unless="$(arg debug)" name="script_type" value="gzserver"/>
    <arg     if="$(arg debug)" name="script_type" value="debug"/>

    <!-- start gazebo server-->
    <node name="gazebo" pkg="gazebo_ros" type="$(arg script_type)" respawn="false" output="screen"
          args="$(arg command_arg1) $(arg command_arg2) $(arg command_arg3) -e $(arg physics) $(arg extra_gazebo_args) $(arg world_name)" />

    <!-- start gazebo client -->
    <group if="$(arg gui)">
      <node name="gazebo_gui" pkg="gazebo_ros" type="gzclient" respawn="false" output="screen"/>
    </group>
  </launch>
#+END_SRC
**** gzserver --help
Gazebo server runs simulation and handles commandline options, starts
a Master, runs World update and sensor generation loops.

options:

+ -q [ --quiet ]                Reduce output to stdout.
+ -h [ --help ]                 Produce this help message.
+ -u [ --pause ]                Start the server in a paused state.  *paused*
+ -e [ --physics ] arg          Specify a physics engine (ode|bullet|dart|simbody). *physics*
+ -p [ --play ] arg             Play a log file.
+ -r [ --record ]               Record state data. *headless?*
+ --record_encoding arg (=zlib) Compression encoding format for log data
                                (zlib|bz2|txt).
+ --record_path arg             Absolute path in which to store state data
+ --seed arg                    Start with a given random number seed.
+ --iters arg                   Number of iterations to simulate.
+ --minimal_comms               Reduce the messages output by gzserver
+ -s [ --server-plugin ] arg    Load a plugin.
**** arguments
+ *paused*: Start Gazebo in a paused state (default false)

+ *use_sim_time*: Tells ROS nodes asking for time to get the
  Gazebo-published simulation time, published over the ROS topic
  /clock (default true)

+ *gui*: Launch the user interface window of Gazebo (default true)

+ *headless*: Disable any function calls to simulator rendering (Ogre)
  components. Does not work with gui:=true (default false)

+ *debug*: Start gzserver (Gazebo Server) in debug mode using gdb
  (default false)
**** rosrun gazebo_ros TAB
+ *debug*:
+ gdbrun
+ *gzserver*
+ *spawn_model*
+ *gazebo*
+ *gzclient*
+ perf
*** track view: make the camera track a moving robot

+ http://answers.gazebosim.org/question/8437/how-to-make-the-camera-track-a-moving-robot/

If you don't want to go through the trouble of writing a plugin, you
can right-click the model and choose Follow and the camera will follow
the robot. Press ESC to leave follow mode.

Programmatically, I think it should be possible to emit
gui::Events::follow(<modelName>). And gui::Events::follow("") to stop
following.

The ground plane seems to end where the gray square ends, but if you
try to place models beyond that point you'll see it's possible. You
can also edit a model's pose on the left panel, I guess the only
limitation should be numeric.

*** IMU

*** TODO Gazebo robotics simulator with ROS
+ http://www.generationrobots.com/en/content/75-gazebo-and-ros
*** TODO arm model simulation
+ http://robotica.unileon.es/mediawiki/index.php/MYRAbot's_arm_model_for_simulation_(urdf%2Bgazebo)
*** TODO spring simulation
http://ros-users.122217.n3.nabble.com/Simulating-a-spring-in-Gazebo-td2316359.html
*** IMU plugin
http://answers.gazebosim.org/question/4717/imu-sensor-plugin-libgazebo_ros_imuso-strange-data/
*** error

**** ros_controll: Controller Spawner: Waiting for service controller_manager/switch_controller

*不明所以*

**** 在Gazebo仿真中，ros_control之所以会使joint带动整个base_link振动，是因为PID参数设置不当
*** gazebo tutorial                                              :tutorial:
note: 用ros中的gazebo
**** Run Gazebo
1. run
   + $ gazebo
   + $ gzserver    # run the server
   + $ gzclient    # run the graphical client
   + rosrun gazebo_ros gazebo/gzserver/gzclient

2. world file location :
   + /usr/share/gazebo-<version>/worlds

**** Gazebo Components
1. World Files
   + contains all elemens in a simulation
     - robots
     - lights
     - sensors
     - static objectx
   + formatted using SDF(Simulation Description Format)

2. Model Files
   + SDF formatted
   + <model> ... </model>
   + included in a world fie using
     #+BEGIN_EXAMPLE
       <include>
           <uri>model://model_file_name</uri>
       </include>
     #+END_EXAMPLE
     - uri: Uniform Resource Identifier
   + online database:http://bitbucket.org/osrf/gazebo_models
   + inserted at runtime

3. Environment Variables
   + source /usr/share/gazebo-<version>/setup.sh
   + source first and then changed if neccessay

4. Gazebo Server
   + gzserver <world_filename>
     - absolute path
     - relative to the current directory
     - relative to $GAZEBO_RESOURCE_PATH (source first)
       - default: /usr/share/gazebo-2.2:/usr/share/gazebo_models
       - e.g. gzserver worlds/empty.world

5. Graphical Client
   + $ gzclient
6. Plugins
   + Plugins provide a simple and conventient mechanism to interface
     with Gazebo
   + loaded on the command line
     - $ gzserver -s <plugin_filename> <world_file>
     - $ gzclient -g <plugin_filename>
   + or specified in a world/model file

**** Gazebo Architecture
1. introduction
   + distributed architecture with separated libraries for
     - physics simulation
     - rendering
     - user interface
     - communication
     - sensor generation
   + two executable
     - a server gzserver
     - a client gzclient

2. Communication library
   + Google Protobuf for message serialization
   + boost::ASIO for transport mechanism

3. System
   1) Gazebo Master
      + a topic name server
      + namelookup
      + topic management
   2) Communication library
      + support only publish/subscribe
   3) Physics library
   4) Rendering library
   5) Sensor generation
   6) GUI
   7) Plugins

**** Capture screenshot
+ tool button on toolbar
+ saved to ~/.gazebo/pictures with a timestamped filename

**** Model Structure and requirements
1. Overview
   + Gazebo is able to *dynamically load models into simulation*
     - programmatically
     - though GUI
   + Model define a physical entity with
     - dynamic
     - kinematci
     - visual properties
     - plugin

2. The Model Database Repository
   + $ hg clone https://bitbucket.org/osrf/gazebo_models
   + download through browser

3. Model Database Structure
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.9\linewidth]{/home/ben/Tiger/Figures/scrot/8517Dnu.png}
   \end{figure}

   1) Database config
      + database.config
      + xml file
      + contains
        - license information
        - name for the database
        - a list of all the valid models
      + only rereuired for the online repositories

        \begin{figure}[ht]
        \centering
        \includegraphics[width=0.7\linewidth]{/home/ben/Tiger/Figures/scrot/8517Qx0.png}
        \end{figure}
   2) Model Config
      + Each model must have a model.config
      + <name> required
      + <sdf> required
      + <author> required
      + <description> required
      + <depend> optional,
      + <model> optional

        \begin{figure}[ht]
        \centering
        \includegraphics[width=0.5\linewidth]{/home/ben/Tiger/Figures/scrot/8517C7D.png}
        \end{figure}
   3) Model SDF
   4) Plugins Directory
   5) Meshes Directory
   6) Material Directory
      + textures subdirectory for texture image
      + scriptes subdirectory for OGRE scripts

**** Make a model
1. Compoments of a SDF models
   1) links
      + collison
      + visual
      + inertial
      + sensor
   2) joints
   3) plugins

2. Building a Model
   1) Collect your meshes
      + Google's 3D wharehouse:
        http://sketchup.google.com/3dwarehouse/
      + diy
        - Blender
        - Sketchup
      + Format
        - STL
        - Collada(preferred)
      + Tips
        - move each mesh so that it is centered on the origin
        - Collada file allow you to attach materials ot the meshes
        - keep meshes simple
          - low polygon mesh for a collison element
          - higher polygon mesh for visual
          - use build-in shapes

   2) Make model SDF file
      #+BEGIN_SRC xml :tangle /home/ben/project/slam/gazebo/gazebotutorials/models/box/box.sdf
        <?xml version='1.0'?>
        <sdf version="1.4">
          <model name="my_model">
            <pose>0 0 0.5 0 0 0</pose>
            <static>true</static>
            <link name="link">
              <inertial>
                <mass>1.0</mass>
                <inertia>
                  <ixx>0.083</ixx>
                  <ixy>0.0</ixy>
                  <ixz>0.0</ixz>
                  <iyy>0.083</iyy>
                  <iyz>0.0</iyz>
                  <izz>0.083</izz>
                </inertia>
              </inertial>
              <collision name="collision">
                <geometry>
                  <box>
                    <size>1 1 1</size>
                  </box>
                </geometry>
              </collision>
              <visual name="visual">
                <geometry>
                  <box>
                    <size>1 1 1</size>
                  </box>
                </geometry>
              </visual>
            </link>
          </model>
        </sdf>
      #+END_SRC

   3) Add to the model SDF file
      + recommended order
        1) Add a link
        2) set the collision element
        3) set the visual element
        4) set the visual element
        5) Go to #1 until all links have been added
        6) add all joints if any
        7) add all plugins if any

**** Make a Mobile robot
1) mkdir
2) create model.config
   #+BEGIN_SRC xml :tangle /home/ben/.gazebo/models/my_robot/model.config :mkdirp yes
     <?xml version="1.0"?>
     <model>
       <name>My Robot</name>
       <version>1.0</version>
       <sdf version="1.4">model.sdf</sdf>

       <autor>
         <name>TigerDWong</name>
         <email>buaaben@163.com</email>
       </autor>

       <description>
         My awesome robot
       </description>
     </model>
   #+END_SRC
3) create sdf file
   #+BEGIN_SRC xml :tangle /home/ben/.gazebo/models/my_robot/model.sdf :mkdirp yes
     <?xml version="1.0"?>
     <sdf version="1.4">
       <model name="my_robot">
         <static>false</static>
         <link name="chassis">
           <pose>0 0 .1 0 0 0</pose>

           <collision name="collision">
             <geometry>
               <box>
                 <size>.4 .2 .1</size>
               </box>
             </geometry>
           </collision>

           <visual name="visual">
             <geometry>
               <box>
                 <size>.4 .2 .1</size>
               </box>
             </geometry>
           </visual>
           <collision name="caster_collision">
             <pose>-0.15 0 -0.05 0 0 0</pose>
             <geometry>
               <sphere>
                 <radius>.05</radius>
               </sphere>
             </geometry>

             <surface>
               <friction>
                 <ode>
                   <mu>0</mu>
                   <mu2>0</mu2>
                   <slip1>1.0</slip1>
                   <slip2>1.0</slip2>
                 </ode>
               </friction>
             </surface>
           </collision>

           <visual name="caster_visual">
             <pose>-0.15 0 -0.05 0 0 0</pose>
             <geometry>
               <sphere>
                 <radius>.05</radius>
               </sphere>
             </geometry>
           </visual>
         </link>
         <link name="left_wheel">
           <pose>0.1 0.13 0.1 0 1.5707 1.5707</pose>
           <collision name="collision">
             <geometry>
               <cylinder>
                 <radius>.1</radius>
                 <length>.05</length>
               </cylinder>
             </geometry>
           </collision>

           <visual name="visual">
             <geometry>
               <cylinder>
                 <radius>.1</radius>
                 <length>.05</length>
               </cylinder>
             </geometry>
           </visual>
         </link>
         <link name="right_wheel">
           <pose>0.1 -0.13 0.1 0 1.5707 1.5707</pose>
           <collision name="collision">
             <geometry>
               <cylinder>
                 <radius>.1</radius>
                 <length>.05</length>
               </cylinder>
             </geometry>
           </collision>

           <visual name="visual">
             <geometry>
               <cylinder>
                 <radius>.1</radius>
                 <length>.05</length>
               </cylinder>
             </geometry>
           </visual>
         </link>
         <joint type="revolute" name="left_wheel_hinge">
           <pose>0 0 -0.03 0 0 0</pose>
           <child>left_wheel</child>
           <parent>chassis</parent>
           <axis>
             <xyz>0 1 0</xyz>
           </axis>
         </joint>
         <joint type="revolute" name="right_wheel_hinge">
           <pose>0 0 0.03 0 0 0</pose>
           <child>right_wheel</child>
           <parent>chassis</parent>
           <axis>
             <xyz>0 1 0</xyz>
           </axis>
         </joint>
       </model>
     </sdf>
   #+END_SRC

**** Attach Meshes
+ Meshes can add realism to a model both visually and for sensor
+ <mesh>...</mesh>
+ Parent: Visual
+ <scale>x y z</scale>

**** Import Meshes

+ Gazebo uses a right-hand coordinate system, where +Z is
  up(veritical), +X is forward(into the screen), and +Y is to the
  left.
+ Steps
  1) Reduce complexity
  2) Center the font
  3) Scale the mesh
  4) export the mesh as a Collada file

**** Add a Sensor to a Robot

1. Adding a Laser
   #+BEGIN_SRC xml
     <include>
       <uri>model://hokuyo</uri>
       <pose>0.2 0 0.2 0 0 0</pose>
     </include>
     <joint name="hokuyo_joint" type="revolute">
       <child>hokuyo::link</child>
       <parent>chassis</parent>
       <axis>
         <xyz>0 0 1</xyz>
         <limit>
           <upper>0</upper>
           <lower>0</lower>
         </limit>
       </axis>
     </joint>
   #+END_SRC

**** Make s simple gripper
1. create a world file
   #+BEGIN_SRC xml :tangle /home/ben/.gazebo/worlds/simple_gripper_tutoial/gripper.world :mkdirp yes
     <?xml version="1.0"?>
     <sdf version="1.4">
       <world name="default">

         <!-- A ground plane -->
         <include>
           <uri>model://ground_plane</uri>
         </include>

         <!-- A global light source -->
         <include>
           <uri>model://sun</uri>
         </include>

         <include>
           <uri>model://my_gripper</uri>
         </include>

       </world>
     </sdf>
   #+END_SRC

2. create a model file
   #+BEGIN_SRC xml :tangle /home/ben/.gazebo/models/my_gripper/model.config :mkdirp yes
     <?xml version="1.0"?>
     <model>
       <name>My Gripper</name>
       <version>1.0</version>
       <sdf version="1.4">simple_gripper.sdf</sdf>

       <author>
         <name>TigerDWong</name>
         <email>buaaben@163.com</email>
       </author>

       <description>
         My awesome robot
       </description>
     </model>
   #+END_SRC

   #+BEGIN_SRC xml :tangle /home/ben/.gazebo/models/my_gripper/simple_gripper.sdf
     <?xml version="1.0"?>
     <sdf version="1.4">
       <model name="simple_gripper">
         <static>true</static>
         <link name="riser">
           <pose>-0.15 0.0 0.5 0 0 0</pose>
           <inertial>
             <pose>0 0 -0.5 0 0 0</pose>
             <inertia>
               <ixx>0.01</ixx>
               <ixy>0</ixy>
               <ixz>0</ixz>
               <iyy>0.01</iyy>
               <iyz>0</iyz>
               <izz>0.01</izz>
             </inertia>
             <mass>10.0</mass>
           </inertial>
           <collision name="collision">
             <geometry>
               <box>
                 <size>0.2 0.2 1.0</size>
               </box>
             </geometry>
           </collision>
           <visual name="visual">
             <geometry>
               <box>
                 <size>0.2 0.2 1.0</size>
               </box>
             </geometry>
           </visual>
         </link>
         <link name="palm">
           <pose>0.0 0.0 0.05 0 0 0</pose>
           <inertial>
             <inertia>
               <ixx>0.01</ixx>
               <ixy>0</ixy>
               <ixz>0</ixz>
               <iyy>0.01</iyy>
               <iyz>0</iyz>
               <izz>0.01</izz>
             </inertia>
             <mass>0.5</mass>
           </inertial>
           <collision name="collision">
             <geometry>
               <box>
                 <size>0.1 0.2 0.1</size>
               </box>
             </geometry>
           </collision>
           <visual name="visual">
             <geometry>
               <box>
                 <size>0.1 0.2 0.1</size>
               </box>
             </geometry>
             <material>
               <script>Gazebo/Red</script>
             </material>
           </visual>
         </link>
         <link name="left_finger">
           <pose>0.1 0.2 0.05 0 0 -0.78539</pose>
           <inertial>
             <inertia>
               <ixx>0.01</ixx>
               <ixy>0</ixy>
               <ixz>0</ixz>
               <iyy>0.01</iyy>
               <iyz>0</iyz>
               <izz>0.01</izz>
             </inertia>
             <mass>0.1</mass>
           </inertial>
           <collision name="collision">
             <geometry>
               <box>
                 <size>0.1 0.3 0.1</size>
               </box>
             </geometry>
           </collision>
           <visual name="visual">
             <geometry>
               <box>
                 <size>0.1 0.3 0.1</size>
               </box>
             </geometry>
             <material>
               <script>Gazebo/Blue</script>
             </material>
           </visual>
         </link>
         <link name="left_finger_tip">
           <pose>0.336 0.3 0.05 0 0 1.5707</pose>
           <inertial>
             <inertia>
               <ixx>0.01</ixx>
               <ixy>0</ixy>
               <ixz>0</ixz>
               <iyy>0.01</iyy>
               <iyz>0</iyz>
               <izz>0.01</izz>
             </inertia>
             <mass>0.1</mass>
           </inertial>
           <collision name="collision">
             <geometry>
               <box>
                 <size>0.1 0.2 0.1</size>
               </box>
             </geometry>
           </collision>
           <visual name="visual">
             <geometry>
               <box>
                 <size>0.1 0.2 0.1</size>
               </box>
             </geometry>
             <material>
               <script>Gazebo/Blue</script>
             </material>
           </visual>
         </link>
         <link name="right_finger">
           <pose>0.1 -0.2 0.05 0 0 .78539</pose>
           <inertial>
             <inertia>
               <ixx>0.01</ixx>
               <ixy>0</ixy>
               <ixz>0</ixz>
               <iyy>0.01</iyy>
               <iyz>0</iyz>
               <izz>0.01</izz>
             </inertia>
             <mass>0.1</mass>
           </inertial>
           <collision name="collision">
             <geometry>
               <box>
                 <size>0.1 0.3 0.1</size>
               </box>
             </geometry>
           </collision>
           <visual name="visual">
             <geometry>
               <box>
                 <size>0.1 0.3 0.1</size>
               </box>
             </geometry>
             <material>
               <script>Gazebo/Green</script>
             </material>
           </visual>
         </link>
         <link name="right_finger_tip">
           <pose>0.336 -0.3 0.05 0 0 1.5707</pose>
           <inertial>
             <inertia>
               <ixx>0.01</ixx>
               <ixy>0</ixy>
               <ixz>0</ixz>
               <iyy>0.01</iyy>
               <iyz>0</iyz>
               <izz>0.01</izz>
             </inertia>
             <mass>0.1</mass>
           </inertial>
           <collision name="collision">
             <geometry>
               <box>
                 <size>0.1 0.2 0.1</size>
               </box>
             </geometry>
           </collision>
           <visual name="visual">
             <geometry>
               <box>
                 <size>0.1 0.2 0.1</size>
               </box>
             </geometry>
             <material>
               <script>Gazebo/Green</script>
             </material>
           </visual>
         </link>

         <joint name="palm_left_finger" type="revolute">
           <pose>0 -0.15 0 0 0 0</pose>
           <child>left_finger</child>
           <parent>palm</parent>
           <axis>
             <limit>
               <lower>-0.4</lower>
               <upper>0.4</upper>
             </limit>
             <xyz>0 0 1</xyz>
           </axis>
         </joint>
         <joint name="left_finger_tip" type="revolute">
           <pose>0 0.1 0 0 0 0</pose>
           <child>left_finger_tip</child>
           <parent>left_finger</parent>
           <axis>
             <limit>
               <lower>-0.4</lower>
               <upper>0.4</upper>
             </limit>
             <xyz>0 0 1</xyz>
           </axis>
         </joint>
         <joint name="palm_right_finger" type="revolute">
           <pose>0 0.15 0 0 0 0</pose>
           <child>right_finger</child>
           <parent>palm</parent>
           <axis>
             <limit>
               <lower>-0.4</lower>
               <upper>0.4</upper>
             </limit>
             <xyz>0 0 1</xyz>
           </axis>
         </joint>
         <joint name="right_finger_tip" type="revolute">
           <pose>0 0.1 0 0 0 0</pose>
           <child>right_finger_tip</child>
           <parent>right_finger</parent>
           <axis>
             <limit>
               <lower>-0.4</lower>
               <upper>0.4</upper>
             </limit>
             <xyz>0 0 1</xyz>
           </axis>
         </joint>
         <joint name="palm_riser" type="prismatic">
           <child>palm</child>
           <parent>riser</parent>
           <axis>
             <limit>
               <lower>0</lower>
               <upper>0.9</upper>
             </limit>
             <xyz>0 0 1</xyz>
           </axis>
         </joint>
       </model>
     </sdf>
   #+END_SRC

**** Attach Gripper to Robot

*** OGRE                                                             :orge:

+ http://zh.wikipedia.org/wiki/ogre
+ http://www.ogre3d.org/
+ http://baike.baidu.com/subview/104836/15875123.htm#viewpagecontent


ogre（object-oriented graphics rendering engine，面向对象图形渲染引擎）
又叫做ogre 3d。ogre是面向场景的、灵活的图像引擎。ogre仍然在发展中，如
果就功能和商业游戏引擎还有一定差距。

开源

gazebo使用ogre作为渲染的引擎。

*** gazebo & ros jade                                                :jade:

- [[http://answers.ros.org/question/217970/ros-jade-and-gazebo-50-migration-problem/][Q&A: ros jade and gazebo 5.0 migration problem]]

#+BEGIN_EXAMPLE
/opt/ros/jade/lib/gazebo_ros/gzclient: 17: .: Can't open /usr/share/gazebo//setup.sh
[gazebo_gui-3] process has died [pid 2459, exit code 2, cmd /opt/ros/jade/lib/gazebo_ros/gzclient __name:=gazebo_gui __log:=/home/wally/.ros/log/4fb3d678-b80e-11e5-9dba-002186ef9d91/gazebo_gui-3.log].
log file: /home/wally/.ros/log/4fb3d678-b80e-11e5-9dba-002186ef9d91/gazebo_gui-3*.log
#+END_EXAMPLE

*installing the gazebo5 package seems to have solved the
problem*.

*** model                                                     :robot_model:

**** [[http://playerstage.sourceforge.net/doc/Gazebo-manual-0.5-html/group__SickLMS200.html][Sick LMS]]                                                       :sick:
** PCL
*** overview

The Point Cloud Library (or PCL) for point cloud processing -
development The PCL framework contains numerous state-of-the art
algorithms including filtering, feature estimation, surface
reconstruction, registration, model fitting and segmentation.

http://wiki.ros.org/pcl/Tutorials


**** Data types

***** Point cloud data types in ROS

These are the current data structures in ROS that represent point
clouds:

-  [[http://www.ros.org/doc/api/sensor_msgs/html/structsensor__msgs_1_1PointCloud__.html][sensor_msgs::PointCloud]]

   -  The first adopted point cloud message in ROS. Contains x, y and z
      points (all floats) as well as multiple channels; each channel has
      a string name and an array of float values. This served the
      initial *point_cloud_mapping* package in ROS (never released)
      and most of the visualization and data producers/consumers were
      based on this format prior to ROS 1.0.

-  [[http://www.ros.org/doc/api/sensor_msgs/html/structsensor__msgs_1_1PointCloud2__.html][sensor_msgs::PointCloud2]]

   -  The newly revised ROS point cloud message (and currently the /de
      facto/ standard in *PCL*), now representing arbitrary n-D (n
      dimensional) data. Point values can now be of any primitive data
      types (int, float, double, etc), and the message can be specified
      as 'dense', with height and width values, giving the data a 2D
      structure, e.g. to correspond to an image of the same region in
      space.

      For more information on the rationale behind the new structure,
      see:
      [[http://www.ros.org/wiki/pcl?action=AttachFile&do=get&target=PCL_March_2010.pdf][PCL_March_2010.pdf]]
      and
      [[http://rbrusu.com/wp-content/uploads/2010/05/pcl_icra2010.pdf][pcl_icra2010.pdf]]

-  [[http://docs.pointclouds.org/trunk/classpcl_1_1_point_cloud.html][pcl::PointCloud<T>]]

   -  The core point cloud class in the PCL library; can be templated on
      any of the Point types listed in
      [[http://docs.pointclouds.org/trunk/point__types_8h_source.html][point_types.h]]
      or a user-defined type. This class has a similar structure to the
      PointCloud2 message type, including a header. Converting between
      the message class and the point cloud template class is
      straightforward (see below), and most methods in the PCL library
      accept objects of both types. Still, it's better to work with this
      template class in your point cloud processing node, rather than
      with the message object, among other reasons because you can work
      with the individual points as objects rather than having to work
      with their raw data.

***** Determining the point type for a given point cloud message

Each point cloud object type gives you information about the field names
in a different way.

If you have a =sensor_msgs::PointCloud= object, they're all floats. To
find out their names, look at the elements of the channels() vector;
each one has a =name= field.

If you have a =sensor_msgs::PointCloud2= object, look at the elements of
the fields() vector; each one has a =name= field and a =datatype= field.
PCL has methods for extracting this information, see
[[http://docs.pointclouds.org/1.5.1/common_2include_2pcl_2common_2io_8h.html][io.h]].

If you have a =pcl::PointCloud<T>= object, you probably already know
what type the fields are because you know what T is. If it's a topic
published by another node that you didn't write, you'll have to look at
the source for that node. PCL has methods for extracting this
information, see
[[http://docs.pointclouds.org/1.5.1/common_2include_2pcl_2common_2io_8h.html][io.h]].

It has been suggested that it would be helpful if rostopic info could
tell you what T is for a given [[/PointCloud2][PointCloud2]] topic, but
this hasn't been implemented yet.

***** Common PointCloud2 field names

Because field names are generic in the new [[/PointCloud2][PointCloud2]]
message, here's the list of commonly used names within PCL:

-  /x/ - the *X* Cartesian coordinate of a point (float32)
-  /y/ - the *Y* Cartesian coordinate of a point (float32)
-  /z/ - the *Z* Cartesian coordinate of a point (float32)
-  /rgb/ - the RGB (24-bit packed) color at a point (uint32)
-  /rgba/ - the A-RGB (32-bit packed) color at a point (uint32), the
   field name is unfortunately misleading
-  /normal_x/ - the first component of the normal direction vector at a
   point (float32)
-  /normal_y/ - the second component of the normal direction vector at
   a point (float32)
-  /normal_z/ - the third component of the normal direction vector at a
   point (float32)
-  /curvature/ - the surface curvature change estimate at a point
   (float32)
-  /j1/ - the first moment invariant at a point (float32)
-  /j2/ - the second moment invariant at a point (float32)
-  /j3/ - the third moment invariant at a point (float32)
-  /boundary_point/ - the boundary property of a point (e.g., set to 1
   if the point is lying on a boundary) (bool)
-  /principal_curvature_x/ - the first component of the direction of
   the principal curvature at a point (float32)
-  /principal_curvature_y/ - the second component of the direction of
   the principal curvature at a point (float32)
-  /principal_curvature_z/ - the third component of the direction of
   the principal curvature at a point (float32)
-  /pc1/ - the magnitude of the first component of the principal
   curvature at a point (float32)
-  /pc2/ - the magnitude of the second component of the principal
   curvature at a point (float32)
-  /pfh/ - the Point Feature Histogram (PFH) feature signature at a
   point (float32[])
-  /fpfh/ - the Fast Point Feature Histogram (FPFH) feature signature at
   a point (float32[])
-  ...

The complete list of field names and point types used in PCL can be
found in
[[http://www.ros.org/doc/api/pcl/html/point__types_8hpp_source.html][pcl/point_types.hpp]].

**** Point Cloud conversion

***** Converting between sensor_msgs::PointCloud2 and pcl::PointCloud<T>
objects

Use
[[http://docs.ros.org/hydro/api/pcl_conversions/html/namespacepcl.html#af662c7d46db4cf6f7cfdc2aaf4439760][pcl::fromROSMsg]]
and
[[http://docs.ros.org/hydro/api/pcl_conversions/html/namespacepcl.html#af2c39730f92ade1603c55d45265e386d][pcl::toROSMsg]]
from [[http://wiki.ros.org/pcl_conversions][pcl_conversions]]. The
versions of these methods provided by PCL
([[http://docs.pointclouds.org/1.5.1/namespacepcl.html#a2829cb35031f3c5ad0403de70f779915][pcl::fromROSMsg]]
and
[[http://docs.pointclouds.org/1.5.1/namespacepcl.html#a7a849048e91cfc75f30ed30619a74d5d][pcl::toROSMsg]])
are deprecated. The point_cloud::fromMsg() and point_cloud::toMsg()
methods are deprecated and will be removed in an imminent release.

***** Converting between the `sensor_msgs::PointCloud` and
`sensor_msgs::PointCloud2` format

The easiest way to convert between
[[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud>>.html][sensor_msgs/PointCloud>>]]
messages is to run an instance of the
[[/point_cloud_converter][point_cloud_converter]] node, which
subscribes to topics of both types and publishes topics of both types.

If you want to do the conversion in your node, look at
[[http://www.ros.org/doc/api/sensor_msgs/html/namespacesensor__msgs.html#a56242d12e091c19f7e829bc6b0b0b709][sensor_msgs::convertPointCloud2ToPointCloud]]
and
[[http://www.ros.org/doc/api/sensor_msgs/html/namespacesensor__msgs.html#ab3bdbe5a82173d3483899c776e6ccbab][sensor_msgs::convertPointCloudToPointCloud2]].

**** Publishing and subscribing to point cloud messages

Note: Use of the old [[/PointCloud][PointCloud]] message type should be
discontinued. Just for completeness, we'll summarize the subscription
and publication operations for all three point cloud types below anyway.

***** Subscribing to different point cloud message types

For all of these, assume you've done the following:





#+BEGIN_EXAMPLE
       1 ros::NodeHandle nh;
       2 std::string topic = nh.resolveName("point_cloud");
       3 uint32_t queue_size = 1;
#+END_EXAMPLE





For =sensor_msgs::PointCloud= topics:





#+BEGIN_EXAMPLE
       1 // callback signature:
       2 void callback(const sensor_msgs::PointCloudConstPtr&);
       3
       4 // create subscriber:
       5 ros::Subscriber sub = nh.subscribe(topic, queue_size, callback);
#+END_EXAMPLE





For =sensor_msgs::PointCloud2= topics:





#+BEGIN_EXAMPLE
       1 // callback signature
       2 void callback(const sensor_msgs::PointCloud2ConstPtr&);
       3
       4 // to create a subscriber, you can do this (as above):
       5 ros::Subscriber sub = nh.subscribe<sensor_msgs::PointCloud2> (topic, queue_size, callback);
#+END_EXAMPLE





For a subscriber that receives =pcl::PointCloud<T>= objects directly:





#+BEGIN_EXAMPLE
       1 // Need to include the pcl ros utilities
       2 #include "pcl_ros/point_cloud.h"
       3
       4 // callback signature, assuming your points are pcl::PointXYZRGB type:
       5 void callback(const pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr&);
       6
       7 // create a templated subscriber
       8 ros::Subscriber sub = nh.subscribe<pcl::PointCloud<pcl::PointXYZRGB> > (topic, queue_size, callback);
#+END_EXAMPLE





When subscribing to a =pcl::PointCloud<T>= topic with a
=sensor_msgs::PointCloud2= subscriber or viceversa, the conversion
(deserialization) between the two types =sensor_msgs::PointCloud2= and
=pcl::PointCloud<T>= is done on the fly by the subscriber.

***** Publishing different point cloud types

As before, assume you've already done this:





#+BEGIN_EXAMPLE
       1 ros::NodeHandle nh;
       2 std::string topic = nh.resolveName("point_cloud");
       3 uint32_t queue_size = 1;
#+END_EXAMPLE





For =sensor_msgs::PointCloud= messages:





#+BEGIN_EXAMPLE
       1 // assume you get a point cloud message somewhere
       2 sensor_msgs::PointCloud cloud_msg;
       3
       4 // advertise
       5 ros::Publisher pub = nh.advertise<sensor_msgs::PointCloud>(topic, queue_size);
       6 // and publish
       7 pub.publish(cloud_msg);
#+END_EXAMPLE





For =sensor_msgs::PointCloud2= messages:





#+BEGIN_EXAMPLE
       1 // get your point cloud message from somewhere
       2 sensor_msgs::PointCloud2 cloud_msg;
       3
       4 // to advertise you can do it like this (as above):
       5 ros::Publisher pub = nh.advertise<sensor_msgs::PointCloud2>(topic, queue_size);
       6
       7 /// and publish the message
       8 pub.publish(cloud_msg);
#+END_EXAMPLE





If you have a =pcl::PointCloud<T>= object, you don't have to convert it
to a message:





#+BEGIN_EXAMPLE
       1 // Need to include the pcl ros utilities
       2 #include "pcl_ros/point_cloud.h"
       3
       4 // you have an object already, eg with pcl::PointXYZRGB points
       5 pcl::PointCloud<pcl::PointXYZRGB> cloud;
       6
       7 // create a templated publisher
       8 ros::Publisher pub = nh.advertise<pcl::PointCloud<pcl::PointXYZRGB> > (topic, queue_size);
       9
      10 // and just publish the object directly
      11 pub.publish(cloud);
#+END_EXAMPLE





The publisher takes care of the conversion (serialization) between
=sensor_msgs::PointCloud2= and =pcl::PointCloud<T>= where needed.











Wiki: pcl/Overview (last edited 2014-05-13 14:32:59 by
[[/ThorstenGedicke][ThorstenGedicke]])



Except where otherwise noted, the ROS wiki is licensed under the\\
[[http://creativecommons.org/licenses/by/3.0/][Creative Commons
Attribution 3.0]] |
[[https://plus.google.com/113789706402978299308][Find us on Google+]]

--------------





[[/custom/images/brought_by_horiz.png]]

*** [[http://wiki.ros.org/perception_pcl][perception_pcl]]                                     :pcl:perception_pcl:

PCL (Point Cloud Library) ROS *interface* stack. PCL-ROS is the
preferred bridge for 3D applications involving n-D Point Clouds and 3D
geometry processing in ROS.

**** [[http://wiki.ros.org/pcl_ros?distro=jade][pcl_ros]]                                                     :pcl_ros:

Released Continuous integration Documented

PCL (Point Cloud Library) ROS interface stack. PCL-ROS is the preferred
bridge for 3D applications involving n-D Point Clouds and 3D geometry
processing in ROS.

***** Overview

This package provides interfaces and tools for bridging a running ROS
system to the Point Cloud Library. These include ROS nodelets, nodes,
and C++ interfaces.

***** ROS nodelets

=pcl_ros= includes several
[[http://www.ros.org/wiki/pcl_ros/Filters][PCL filters]] packaged as ROS
nodelets. These links provide details for using those interfaces:

-  [[http://www.ros.org/wiki/pcl_ros/Filters#Extract_Indices][Extract_Indices]]
-  [[http://www.ros.org/wiki/pcl_ros/Filters#PassThrough][PassThrough]]
-  [[http://www.ros.org/wiki/pcl_ros/Filters#ProjectInliers][ProjectInliers]]
-  [[http://www.ros.org/wiki/pcl_ros/Filters#RadiusOutlierRemoval][RadiusOutlierRemoval]]
-  [[http://www.ros.org/wiki/pcl_ros/Filters#StatisticalOutlierRemoval][StatisticalOutlierRemoval]]
-  [[http://www.ros.org/wiki/pcl_ros/Filters#VoxelGrid][VoxelGrid]]

***** ROS C++ interface

=pcl_ros= extends the ROS [[/roscpp][C++ client library]] to support
message passing with [[/pcl][PCL]] native data types. Simply add the
following include to your ROS node source code:

#+BEGIN_EXAMPLE
    #include <pcl_ros/point_cloud.h>
#+END_EXAMPLE

This header allows you to publish and subscribe
[[http://www.ros.org/doc/api/pcl/html/classpcl_1_1PointCloud.html][pcl::PointCloud<T>]]
objects as ROS messages. These appear to ROS as
[[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud2.html][sensor_msgs/PointCloud2]]
messages, offering seamless interoperability with non-PCL-using ROS
nodes. For example, you may publish a =pcl::PointCloud<T>= in one of
your nodes and visualize it in [[/rviz][rviz]] using a
[[/rviz/DisplayTypes/PointCloud][Point Cloud2 display]]. It works by
hooking into the
[[/roscpp/Overview/MessagesSerializationAndAdaptingTypes][roscpp
serialization]] infrastructure.

The old format
[[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud.html][sensor_msgs/PointCloud]]
is not supported in PCL.

****** Publishing point clouds

You may publish PCL point clouds using the standard =ros::Publisher=:

#+BEGIN_HTML
  <div class="highlight cpp">
#+END_HTML

#+BEGIN_HTML
  <div class="codearea" dir="ltr" lang="en">
#+END_HTML

#+BEGIN_EXAMPLE
       1 #include <ros/ros.h>
       2 #include <pcl_ros/point_cloud.h>
       3 #include <pcl/point_types.h>
       4
       5 typedef pcl::PointCloud<pcl::PointXYZ> PointCloud;
       6
       7 int main(int argc, char** argv)
       8 {
       9   ros::init (argc, argv, "pub_pcl");
      10   ros::NodeHandle nh;
      11   ros::Publisher pub = nh.advertise<PointCloud> ("points2", 1);
      12
      13   PointCloud::Ptr msg (new PointCloud);
      14   msg->header.frame_id = "some_tf_frame";
      15   msg->height = msg->width = 1;
      16   msg->points.push_back (pcl::PointXYZ(1.0, 2.0, 3.0));
      17
      18   ros::Rate loop_rate(4);
      19   while (nh.ok())
      20   {
      21     msg->header.stamp = ros::Time::now().toNSec();
      22     pub.publish (msg);
      23     ros::spinOnce ();
      24     loop_rate.sleep ();
      25   }
      26 }
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

****** Subscribing to point clouds

You may likewise subscribe to PCL point clouds using the standard
=ros::Subscriber=:

#+BEGIN_HTML
  <div class="highlight cpp">
#+END_HTML

#+BEGIN_HTML
  <div class="codearea" dir="ltr" lang="en">
#+END_HTML

#+BEGIN_EXAMPLE
       1 #include <ros/ros.h>
       2 #include <pcl_ros/point_cloud.h>
       3 #include <pcl/point_types.h>
       4 #include <boost/foreach.hpp>
       5
       6 typedef pcl::PointCloud<pcl::PointXYZ> PointCloud;
       7
       8 void callback(const PointCloud::ConstPtr& msg)
       9 {
      10   printf ("Cloud: width = %d, height = %d\n", msg->width, msg->height);
      11   BOOST_FOREACH (const pcl::PointXYZ& pt, msg->points)
      12     printf ("\t(%f, %f, %f)\n", pt.x, pt.y, pt.z);
      13 }
      14
      15 int main(int argc, char** argv)
      16 {
      17   ros::init(argc, argv, "sub_pcl");
      18   ros::NodeHandle nh;
      19   ros::Subscriber sub = nh.subscribe<PointCloud>("points2", 1, callback);
      20   ros::spin();
      21 }
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

***** ROS nodes

Several tools run as ROS nodes. They convert ROS messages or bags to and
from Point Cloud Data (PCD) file format.

****** bag_to_pcd

Reads a bag file, saving all ROS point cloud messages on a specified
topic as PCD files.

******* Usage

#+BEGIN_EXAMPLE
     $ rosrun pcl_ros bag_to_pcd <input_file.bag> <topic> <output_directory>
#+END_EXAMPLE

Where:

-  <input_file.bag> is the bag file name to read.
-  <topic> is the topic in the bag file containing messages to save.
-  <output_directory> is the directory on disk in which to create PCD
   files from the point cloud messages.

******* Example

Read messages from the =/laser_tilt_cloud= topic in =data.bag=, saving a
PCD file for each message into the =./pointclouds= subdirectory.

#+BEGIN_EXAMPLE
     $ rosrun pcl_ros bag_to_pcd data.bag /laser_tilt_cloud ./pointclouds
#+END_EXAMPLE

****** convert_pcd_to_image

Loads a PCD file, publishing it as a ROS image message five times a
second.
******* Published Topics

=output=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  A stream of images generated from the PCD file.

******* Usage

#+BEGIN_EXAMPLE
     $ rosrun pcl_ros convert_pcd_to_image <cloud.pcd>
#+END_EXAMPLE

Read the point cloud in <cloud.pcd> and publish it in ROS image messages
at 5Hz.

****** convert_pointcloud_to_image

Subscribes to a ROS point cloud topic and republishes image messages.
******* Subscribed Topics

=input=
([[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud2.html][sensor_msgs/PointCloud2]])

-  A stream of point clouds to save as PCD files.

******* Published Topics

=output=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  Corresponding stream of images.

******* Examples

Subscribe to the =/my_cloud= topic and republish each message on the
=/my_image= topic.

#+BEGIN_EXAMPLE
     $ rosrun pcl_ros convert_pointcloud_to_image input:=/my_cloud output:=/my_image
#+END_EXAMPLE

To view the images created by the previous command, use
[[/image_view][image_view]].

#+BEGIN_EXAMPLE
     $ rosrun image_view image_view image:=/my_image
#+END_EXAMPLE

****** pcd_to_pointcloud

Loads a PCD file, publishing it one or more times as a ROS point cloud
message.
******* Published Topics

=cloud_pcd=
([[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud2.html][sensor_msgs/PointCloud2]])

-  A stream of point clouds generated from the PCD file.

******* Parameters

=~frame_id= (=str=, default: /base_link)

-  Transform frame ID for published data.

******* Usage

#+BEGIN_EXAMPLE
     $ rosrun pcl_ros pcd_to_pointcloud <file.pcd> [ <interval> ]
#+END_EXAMPLE

Where:

-  <file.pcd> is the (required) file name to read.
-  <interval> is the (optional) number of seconds to sleep between
   messages. If <interval> is zero or not specified the message is
   published once.

******* Examples

Publish the contents of =point_cloud_file.pcd= once in the =/base_link=
frame of reference.

#+BEGIN_EXAMPLE
     $ rosrun pcl_ros pcd_to_pointcloud point_cloud_file.pcd
#+END_EXAMPLE

Publish the contents of =cloud_file.pcd= approximately ten times a
second in the =/odom= frame of reference.

#+BEGIN_EXAMPLE
     $ rosrun pcl_ros pcd_to_pointcloud cloud_file.pcd 0.1 _frame_id:=/odom
#+END_EXAMPLE

****** pointcloud_to_pcd

Subscribes to a ROS topic and saves point cloud messages to PCD files.
Each message is saved to a separate file, names are composed of an
optional =prefix= parameter, the ROS time of the message, and the =.pcd=
extension.
******* Subscribed Topics

=input=
([[http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud2.html][sensor_msgs/PointCloud2]])

-  A stream of point clouds to save as PCD files.

******* Parameters

=prefix= (=str=)

-  Prefix for PCD file names created.

******* Examples

Subscribe to the =/velodyne/pointcloud2= topic and save each message in
the current directory. File names look like =1285627014.833100319.pcd=,
the exact names depending on the message time stamps.

#+BEGIN_EXAMPLE
     $ rosrun pcl_ros pointcloud_to_pcd input:=/velodyne/pointcloud2
#+END_EXAMPLE

Set the =prefix= parameter in the current namespace, save messages to
files with names like =/tmp/pcd/vel_1285627015.132700443.pcd=.

#+BEGIN_EXAMPLE
     $ rosrun pcl_ros pointcloud_to_pcd input:=/my_cloud _prefix:=/tmp/pcd/vel_
#+END_EXAMPLE

**** [[http://wiki.ros.org/pcl_conversions?distro=jade][pcl_conversions]]

Provides conversions from PCL data types and ROS message types

**** [[http://wiki.ros.org/pcl_msgs?distro=jade][pcl_msgs]]

Package containing PCL (Point Cloud Library)-related ROS messages.
** Miscellaneous
*** [[http://wiki.ros.org/bfl][bfl]]                                                               :bfl:

**** compile

https://github.com/ros-gbp/bfl-release

#+BEGIN_EXAMPLE
Multiple packages found with the same name "bfl":
- bfl-release/groovy
- bfl-release/hydro
- bfl-release/indigo
- bfl-release/jade
#+END_EXAMPLE

#+BEGIN_EXAMPLE
   $ ls src/bfl-release/
  groovy  hydro  indigo  jade  README.md  tracks.yaml
#+END_EXAMPLE

仅保留其一

#+BEGIN_EXAMPLE
CMake Error at /opt/ros/jade/share/catkin/cmake/catkin_workspace.cmake:95 (message):
  This workspace contains non-catkin packages in it, and catkin cannot build
  a non-homogeneous workspace without isolation.  Try the
  'catkin_make_isolated' command instead.
#+END_EXAMPLE

不是 catkin 包， git 库中也只是包含一些 package.xml 文件，使用
ros-build 也许可以。

#+BEGIN_EXAMPLE
$ sudo apt-get install ros-jade-bfl
#+END_EXAMPLE

**** package

This package contains a recent version of the *Bayesian Filtering
Library* (BFL), distributed by the Orocos Project. For stability
reasons, this package is currently locked to revision 31655 (April 19,
2010), but this revision will be updated on a regular basis to the
latest available BFL trunk. This ROS package does not modify BFL in
any way, it simply provides a convenient way to download and compile
the library, because BFL is not available from an OS package
manager. This ROS package compiles BFL with the Boost library for
matrix operations and random number generation.

*** nodelet

**** [[http://wiki.ros.org/nodelet][nodelet]]

*** ros 升级到 jade                                                  :jade:

1. xacro
   #+BEGIN_EXAMPLE
     inconsistent namespace redefinitions for xmlns:xacro:
      old: http://ros.org/wiki/xacro
      new: http://wiki.ros.org/xacro (/home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/mecanum.xacro)
     xacro.py is deprecated; please use xacro instead
   #+END_EXAMPLE

2. CMakeLists.txt 链接依然是 indigo

   重新 catkin_init_workspace

*** ros matlab

http://jp.mathworks.com/hardware-support/robot-operating-system.html?requestedDomain=www.mathworks.com

http://www.ros.org/news/2014/01/mathworks-releases-robot-operating-system-ros-support-from-matlab.html

*** 新得立安装 gazebo, ros                                        :install:

#+BEGIN_EXAMPLE
E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。
#+END_EXAMPLE

后台调用 apt-get 解决依赖问题。

安装 gazebo6, OK

安装 ros-jade, 删除 gazebo6, 安装了 gazebo5

用不着参考安装指导完全使用命令行方式安装。
*可以增加了 source （软件源） 之后使用新得立安装*

*抽象出做的内容，方法只是表象*

*** osrf                                                             :osrf:

http://www.osrfoundation.org/

Open Source Robotics Foundation

*** image_view                                               :image_viewer:

Released Continuous integration Documented

A simple viewer for ROS image topics. Includes a specialized viewer for
stereo + disparity images.

**** Usage

***** Viewing a single image topic

#+BEGIN_EXAMPLE
    image_view image:=<image topic> [image transport type]
#+END_EXAMPLE

For example, to view raw images on the topic =/camera/image=, use:

#+BEGIN_EXAMPLE
    image_view image:=/camera/image
#+END_EXAMPLE

You may save the current image by left-clicking on the display window.
By default, images will be saved as =frame0000.jpg=, =frame0001.jpg=,
.... }}}

If you want to view a compressed image stream (usually a good idea over
wireless!) using the capabilities of
[[/image_transport][image_transport]], specify the transport type as a
command-line argument. For example, if
[[/theora_image_transport][theora_image_transport]] is built on the
publisher's side, you can use =theora= transport:

#+BEGIN_EXAMPLE
    image_view image:=/camera/image theora
#+END_EXAMPLE

Note that this is merely shorthand equivalent to setting the
=~image_transport= parameter:

#+BEGIN_EXAMPLE
    image_view image:=/camera/image _image_transport:=theora
#+END_EXAMPLE

***** Viewing stereo images

#+BEGIN_EXAMPLE
    stereo_view stereo:=<stereo namespace> image:=<image topic identifier>
#+END_EXAMPLE

For example, to view stereo image pairs on topics
=/my_stereo_cam/left/image_rect_color= and
=/my_stereo_cam/right/image_rect_color=, use:

#+BEGIN_EXAMPLE
    stereo_view stereo:=/my_stereo_cam image:=image_rect_color
#+END_EXAMPLE

=stereo_view= also shows the disparity image computed from the stereo
pair, color-mapped for clarity.

You may save the current image pair by left-clicking on either display
window. By default, images will be saved as =left0000.jpg=,
=right0000.jpg=, =left0001.jpg=, =right0001.jpg=....

**** Nodes

***** image_view

Simple image viewer for ROS topics.
****** Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

****** Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~filename_format= (=string=, default: ="frame%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image stream. =image_view= allows you to
   specify this as a simple command-line argument for convenience.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

***** stereo_view

Viewer for stereo images. Shows the left/right image pair and the
disparity image (color-mapped) computed from them.
****** Subscribed Topics

=<stereo>/left/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The left image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/right/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The right image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/disparity=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

-  The disparity image computed from the left/right stereo pair.

****** Parameters

=~autosize= (=bool=, default: true)

-  Whether the windows should autosize to the image or be resizeable by
   the user.

=~filename_format= (=string=, default: ="%s%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images. The string argument is ="left"=
   or ="right"=.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image streams.

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div
  class="version diamondback electric fuerte groovy hydro indigo jade">
#+END_HTML

#+BEGIN_HTML
  <div id="image_view.2BAC8-diamondback.content" dir="ltr" lang="en">
#+END_HTML

#+BEGIN_HTML
  <div class="table-of-contents">
#+END_HTML

Contents

1. [[#image_view.2BAC8-diamondback.Usage][Usage]]

   1. [[#image_view.2BAC8-diamondback.Viewing_a_single_image_topic][Viewing
      a single image topic]]
   2. [[#image_view.2BAC8-diamondback.Viewing_stereo_images][Viewing
      stereo images]]

2. [[#image_view.2BAC8-diamondback.Nodes][Nodes]]

   1. [[#image_view.2BAC8-diamondback.image_view][image_view]]
   2. [[#image_view.2BAC8-diamondback.disparity_view][disparity_view]]
   3. [[#image_view.2BAC8-diamondback.stereo_view][stereo_view]]

3. [[#image_view.2BAC8-diamondback.Nodelets][Nodelets]]

   1. [[#image_view.2BAC8-diamondback.image_view.2BAC8-image][image_view/image]]
   2. [[#image_view.2BAC8-diamondback.image_view.2BAC8-disparity][image_view/disparity]]

4. [[#image_view.2BAC8-diamondback.Tools][Tools]]

   1. [[#image_view.2BAC8-diamondback.image_saver][image_saver]]
   2. [[#image_view.2BAC8-diamondback.extract_images][extract_images]]
   3. [[#image_view.2BAC8-diamondback.video_recorder][video_recorder]]

#+BEGIN_HTML
  </div>
#+END_HTML

**** Usage

***** Viewing a single image topic

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=<image topic> [image transport type]
#+END_EXAMPLE

For example, to view raw images on the topic =/camera/image=, use:

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=/camera/image
#+END_EXAMPLE

You may save the current image by right-clicking on the display window.
By default, images will be saved as =frame0000.jpg=, =frame0001.jpg=,
....

If you want to view a compressed image stream (usually a good idea over
wireless!) using the capabilities of
[[/image_transport][image_transport]], specify the transport type as a
command-line argument. For example, if
[[/theora_image_transport][theora_image_transport]] is built on the
publisher's side, you can use =theora= transport:

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=/camera/image theora
#+END_EXAMPLE

Note that this is merely shorthand equivalent to setting the
=~image_transport= parameter:

#+BEGIN_EXAMPLE
    rosrun image_view image_view image:=/camera/image _image_transport:=theora
#+END_EXAMPLE

***** Viewing stereo images

#+BEGIN_EXAMPLE
    rosrun image_view stereo_view stereo:=<stereo namespace> image:=<image topic identifier>
#+END_EXAMPLE

For example, to view stereo image pairs on topics
=/my_stereo_cam/left/image_rect_color= and
=/my_stereo_cam/right/image_rect_color=, use:

#+BEGIN_EXAMPLE
    rosrun image_view stereo_view stereo:=/my_stereo_cam image:=image_rect_color
#+END_EXAMPLE

=stereo_view= also shows the disparity image computed from the stereo
pair, color-mapped for clarity.

You may save the current image pair by right-clicking on any display
window. By default, images will be saved as =left0000.jpg=,
=right0000.jpg=, =disp0000.jpg=, =left0001.jpg=, =right0001.jpg=,
=disp0001.jpg=.... As with =image_view=, you can specify an image
transport to use for the left and right image as an optional argument.

**** Nodes

***** image_view

Simple image viewer for ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topics.
****** Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

****** Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~filename_format= (=string=, default: ="frame%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image stream. =image_view= allows you to
   specify this as a simple command-line argument for convenience.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

***** disparity_view

Simple viewer for
[[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]]
topics. Color-maps the disparity image for visualization.
****** Subscribed Topics

=image=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

-  The disparity image topic. Should be remapped to the name of the real
   topic.

****** Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

***** stereo_view

Viewer for stereo images. Shows the synchronized left/right image pair
and the disparity image (color-mapped) computed from them.
****** Subscribed Topics

=<stereo>/left/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The left image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/right/<image>=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The right image topic. Formal parameters =stereo= and =image= should
   be remapped appropriately.

=<stereo>/disparity=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

-  The disparity image computed from the left/right stereo pair.

****** Parameters

=~autosize= (=bool=, default: true)

-  Whether the windows should autosize to the image or be resizeable by
   the user.

=~filename_format= (=string=, default: ="%s%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images. The string argument is ="left"=
   or ="right"=.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image streams.

=~approximate_sync= (=bool=, default: false)

-  Whether to use approximate synchronization. Set to true if the left
   and right cameras do not produce exactly synced timestamps.

=~queue_size= (=int=, default: 5)

-  Size of message queue for each synchronized topic. You may need to
   raise this if disparity processing takes too long, or if there are
   significant network delays.

**** Nodelets

***** image_view/image

Nodelet version of image_view. Brings up a display window for a
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic.
****** Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

****** Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~filename_format= (=string=, default: ="frame%04i.jpg"=)

-  printf-style format for saved image names. Use to control name,
   location and format of saved images.

=~image_transport= (=string=, default: ="raw"=)

-  Transport used for the image stream. =image_view= allows you to
   specify this as a simple command-line argument for convenience.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

***** image_view/disparity

Nodelet version of disparity_view. Brings up a display window for a
[[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]]
topic, color-mapped for visualization.
****** Subscribed Topics

=image=
([[http://docs.ros.org/api/stereo_msgs/html/msg/DisparityImage.html][stereo_msgs/DisparityImage]])

-  The disparity image topic. Should be remapped to the name of the real
   topic.

****** Parameters

=~autosize= (=bool=, default: false)

-  Whether the window should autosize itself to the image or be
   resizeable by the user.

=~window_name= (=string=, default: name of the image topic)

-  The name of the display window.

#+BEGIN_HTML
  <div class="version hydro_and_newer">
#+END_HTML

**** Tools

***** image_saver

This tool allows you to save images as jpg/png file from streaming (ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic) to a file.
****** Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

****** Services

=save=
([[http://docs.ros.org/api/std_srvs/html/srv/Empty.html][std_srvs/Empty]])

-  Save images, you need to set save_all_images to false

****** Parameters

=~filename_format= (=string=, default: =left%04d.%s=)

-  File name for saved images, you can use '%04i' for sequence number,
   and '%s' for default file format, you can use 'jpg' ,'png', 'pgm' as
   filename suffixes.

=~encoding= (=string=, default: 'bgr8')

-  Encoding type of input image topic.

=~save_all_image= (=bool=, default: true)

-  If you set false, images are only saved when 'save' service is called

***** extract_images

This tool also allows you to save images as jpg/png file from streaming
(ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic) to a file. =image_saver= node provide very similar
functionalities, such as providing service call to trigger the node to
save images, save images other than Jpeg format, etc.
****** Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

****** Parameters

=~filename_format= (=string=, default: =frame%04d.jpg=)

-  File name for saved images, you must add use '%04i' for sequence
   number.

=~sec_per_frame= (=double=, default: '0.1')

-  set sec per frame value.

***** video_recorder

This tool allows you to record a video stream (ROS
[[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]]
topic) to a file. It relies on
[[http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videowriter][OpenCV's
VideoWriter class]]. With the default options, it encodes the video as
MPG, encapsulated in a AVI container at 15 fps, and produces a file
called =output.avi= in the current directory.
****** Subscribed Topics

=image=
([[http://docs.ros.org/api/sensor_msgs/html/msg/Image.html][sensor_msgs/Image]])

-  The image topic. Should be remapped to the name of the real image
   topic.

****** Parameters

=~filename= (=string=, default: =output.avi=)

-  Path and name of the output video.

=~fps= (=int=, default: 15)

-  Framerate of the video.

=~codec= (=string=, default: =MJPG=)

-  The [[http://www.fourcc.org/codecs.php][FOURCC]] identifier of the
   codec.

=~encoding= (=string=, default: =bgr8=)

-  The image color space of the video.

*** Using rosed to edit files in ROS                                :rosed:

*Description:* This tutorial shows how to use [[/rosbash][rosed]] to
make editing easier.

**** Using rosed

=rosed= is part of the [[/rosbash][rosbash]] suite. It allows you to
directly edit a file within a package by using the package name rather
than having to type the entire path to the package.

Usage:

#+BEGIN_EXAMPLE
    $ rosed [package_name] [filename]
#+END_EXAMPLE

Example:

#+BEGIN_EXAMPLE
    $ rosed roscpp Logger.msg
#+END_EXAMPLE

This example demonstrates how you would edit the Logger.msg file within
the roscpp package.

If this example doesn't work is probably because you don't have the
=vim= editor installed. Please refer to
[[/ROS/Tutorials/UsingRosEd#Editor][Editor]] section. If you don't know
how to get out of vim, [[http://kb.iu.edu/data/afcz.html][click here]].

If the filename is not uniquely defined within the package, a menu will
prompt you to choose which of the possible files you want to edit.

**** Using rosed with tab completion

This way you can easily see and optionally edit all files from a package
without knowing its exact name.

Usage:

#+BEGIN_EXAMPLE
    $ rosed [package_name] <tab><tab>
#+END_EXAMPLE

Example:

#+BEGIN_EXAMPLE
    $ rosed roscpp <tab><tab>
#+END_EXAMPLE


#+BEGIN_EXAMPLE
  Empty.srv                   package.xml
  GetLoggers.srv              roscpp-msg-extras.cmake
  Logger.msg                  roscpp-msg-paths.cmake
  SetLoggerLevel.srv          roscpp.cmake
  genmsg_cpp.py               roscppConfig-version.cmake
  gensrv_cpp.py               roscppConfig.cmake
  msg_gen.py
#+END_EXAMPLE

**** Editor

The default editor for rosed is =vim=. The more beginner-friendly editor
=nano= is included with the default Ubuntu install. You can use it by
editing your ~/.bashrc file to include:

#+BEGIN_EXAMPLE
    export EDITOR='nano -w'
#+END_EXAMPLE

To set the default editor to =emacs= you can edit your ~/.bashrc file to
include:

#+BEGIN_EXAMPLE
    export EDITOR='emacs -nw'
#+END_EXAMPLE

/*NOTE:*/ /changes in .bashrc will only take effect for new terminals.
Terminals that are already open will not see the new environmental
variable./

Open a new terminal and see if =EDITOR= is defined:

#+BEGIN_EXAMPLE
    $ echo $EDITOR
#+END_EXAMPLE


#+BEGIN_EXAMPLE
    nano -w
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    emacs -nw
#+END_EXAMPLE

*** rospy 中的注释风格                         :python:style:rospy:doxygen:

#+BEGIN_SRC python
    def __init__(self, name, data_class, callback=None, callback_args=None,
                 queue_size=None, buff_size=DEFAULT_BUFF_SIZE, tcp_nodelay=False):
        """
        Constructor.

        NOTE: for the queue_size and buff_size
        parameters, rospy does not attempt to do intelligent merging
        between multiple Subscriber instances for the same topic. As
        they share the same underlying transport, multiple Subscribers
        to the same topic can conflict with one another if they set
        these parameters differently.

        @param name: graph resource name of topic, e.g. 'laser'.
        @type  name: str
        @param data_class: data type class to use for messages,
          e.g. std_msgs.msg.String
        @type  data_class: L{Message} class
        @param callback: function to call ( fn(data)) when data is
          received. If callback_args is set, the function must accept
          the callback_args as a second argument, i.e. fn(data,
          callback_args).  NOTE: Additional callbacks can be added using
          add_callback().
        @type  callback: str
        @param callback_args: additional arguments to pass to the
          callback. This is useful when you wish to reuse the same
          callback for multiple subscriptions.
        @type  callback_args: any
        @param queue_size: maximum number of messages to receive at
          a time. This will generally be 1 or None (infinite,
          default). buff_size should be increased if this parameter
          is set as incoming data still needs to sit in the incoming
          buffer before being discarded. Setting queue_size
          buff_size to a non-default value affects all subscribers to
          this topic in this process.
        @type  queue_size: int
        @param buff_size: incoming message buffer size in bytes. If
          queue_size is set, this should be set to a number greater
          than the queue_size times the average message size. Setting
          buff_size to a non-default value affects all subscribers to
          this topic in this process.
        @type  buff_size: int
        @param tcp_nodelay: if True, request TCP_NODELAY from
          publisher.  Use of this option is not generally recommended
          in most cases as it is better to rely on timestamps in
          message data. Setting tcp_nodelay to True enables TCP_NODELAY
          for all subscribers in the same python process.
        @type  tcp_nodelay: bool
        @raise ROSException: if parameters are invalid
        """
#+END_SRC

*** source ros

[2015-11-24 周2 15:39]

ros 单独配置一个source文件
1. 不然每次启动终端速度慢
2. 方便多个版本ROS运行

#+INCLUDE: ~/.rosrc :src sh

/source 包含 source 指令的配置文件似乎只有第一个 source 语句有效/

*** realtime
**** why ROS is not realtime?

There are a few reasons here. The simplest is that ROS is not realtime
because it is built on top of linux, which is not inherently realtime.

The longer answer here goes back to the definition of a realtime
OS. In particular, realtime software provides a set of time guarantees
around certain operations; usually these can include process
scheduling, IO, and inter-process communication. /simplest reason/

While ROS is fast, and is used for online operation in many robots, it
is inherently best-effort in many cases, and does not provide
guarantees about the timing of operations. This means that you should
not use ROS for operations that have strict timing requirements, such
as high-frequency PID and motion control. /what is realtime OS/

Many ROS robots will implement their timing-sensitive operations
either on an embedded controller which communicates with a computer
running ROS, or as a ROS node with separate realtime threads that
communicate through a non-blocking API to ROS threads within the same
node. The latter approach here requires a linux kernel with special
realtime extensions that help guarantee realtime scheduling of
user-space threads. /what to do in realtime-required ocassion/

Some of the particular things that ROS does that can violate realtime
constraints are:

1. Using a network-based transport:
   + Ethernet and IP are unreliable, but have minimal transport
     latency.
   + Standard switches and routers introduce a non-deterministic
     amount of latency, particularly when there is other traffic on
     the network.
   + The handshake and retry mechanisms that make TCP reliable also
     introduce a significant amount of latency.

2. Many of the ROS message types and other APIs do memory allocation
   internally. In a Linux system, this can cause a context switch
   which has the potential to break realtime.

3. The ROS message queue will drop messages when they become full.

4. I would study the locking and synchronization mechanisms inside of
   ROS before using it from a realtime context to make sure that there
   isn't the possibility for a priority inversion somewhere.

**** [[http://answers.ros.org/question/34718/ros-real-time/][realtime control]]

*** [[http://wiki.ros.org/ROS/Tutorials/MultipleMachines][multi-machine]]                                           :multi_machine:


/ROS is designed with distributed computing in mind./

_A well-written node makes no assumptions about where in the network
it runs_, allowing computation to be relocated at run-time to match
the available resources

*** [[http://wiki.ros.org/ROS/NetworkSetup][Network setup]]
*** ROSCon
+ 2015: http://roscon.ros.org/2015/
+ 2014: http://roscon.ros.org/2014/program/
+ 2013: http://roscon.ros.org/2013/?page_id=14
+ 2012：http://roscon.ros.org/2015/#program
+
ROSCon is a developers conference, in the model of PyCon and BoostCon

*** ros log hints

 log file:
 /home/ben/.ros/log/b2e91e66-9413-11e5-b20d-002186ef9d91/gazebo-2*.log

*Node log file*

Everything enabled goes into the log file. Your node's log file will
be in ~/.ros/log unless you override it with the ROS_HOME or
*ROS_LOG_DIR* environment variables. If you are using roslaunch, you can
use the *roslaunch-logs* command to tell you the location of the log
directory.


#+BEGIN_EXAMPLE
  ~ $ roslaunch-
  roslaunch-complete  roslaunch-deps      roslaunch-logs
  ~ $ roslaunch-logs
  /home/ben/.ros/log/d6daf7cc-94e5-11e5-8334-002186ef9d91
#+END_EXAMPLE

*** [[http://wiki.ros.org/actionlib][actionlib]]
**** [[http://wiki.ros.org/actionlib/Tutorials][tutorials]]

***** overview
The actionlib package provides tools to create servers that execute
long-running goals that can be preempted.

The actionlib package provides a standardized interface for
interfacing with preemptible tasks. Examples of this include

+ moving the base to a target location
+ performing a laser scan and returning the resulting point cloud
+ detecting the handle of a door, etc.

****** client-server interation

The *ActionClient* and *ActionServer* communicate via a "ROS Action
Protocol", which is built on top of ROS messages.

****** action specification: Goal, Feedback, & Result
+ *Goal*

  To accomplish tasks using actions, we introduce the notion of a goal
  that can be sent to an ActionServer by an ActionClient. In the case
  of moving the base, the goal would be a PoseStamped message that
  contains information about where the robot should move to in the
  world. For controlling the tilting laser scanner, the goal would
  contain the scan parameters (min angle, max angle, speed, etc).


+ *Feedback*

  Feedback provides server implementers a way to tell an ActionClient
  about the incremental progress of a goal. For moving the base, this
  might be the robot's current pose along the path. For controlling
  the tilting laser scanner, this might be the time left until the
  scan completes.


+ *Result*

  A result is sent from the ActionServer to the ActionClient upon
  completion of the goal. This is different than feedback, since it is
  sent exactly once. This is extremely useful when the purpose of the
  action is to provide some sort of information. For move base, the
  result isn't very important, but it might contain the final pose of
  the robot. For controlling the tilting laser scanner, the result
  might contain a point cloud generated from the requested scan.

****** .action file
******* file
The action specification is defined using a .action file. The .action
file has the goal definition, followed by the result definition,
followed by the feedback definition, with each section separated by 3
hyphens (---).

#+BEGIN_EXAMPLE
  # Define the goal
  uint32 dishwasher_id  # Specify which dishwasher we want to use
  ---
  # Define the result
  uint32 total_dishes_cleaned
  ---
  # Define a feedback message
  float32 percent_complete
#+END_EXAMPLE
******* directory
pkg/action
****** catkin
******* CMakeLists.txt
#+BEGIN_EXAMPLE
  find_package(catkin REQUIRED genmsg actionlib_msgs actionlib)
  add_action_files(DIRECTORY action FILES DoDishes.action)
  generate_messages(DEPENDENCIES actionlib_msgs)
#+END_EXAMPLE

******* package.xml
#+BEGIN_EXAMPLE
  <build_depend>actionlib</build_depend>
  <build_depend>actionlib_msgs</build_depend>
  <run_depend>actionlib</run_depend>
  <run_depend>actionlib_msgs</run_depend>
#+END_EXAMPLE

***** TODO writing a simple server
+ 头文件：
  - <actionlib/server/simple_action_server.h>
  - <learning_actionlib/FibonacciAction.h>  # generated from .action file
+ SimpleActionServer(ros::NodeHandle n, std::string name,
  ExecuteCallback execute_cb, bool auto_start)


**

*** [[http://wiki.ros.org/robot_localization][robot_localization]]
*** pcDuino
**** pcDuino
+ http://baike.baidu.com/link?url=0y6nY_M2MNkm00C8I1nB8qujx-CIqvyxPQhHr7kGpmYN-TzRutW7rs_0cN7Eo6iVpwpgtESJrU9rX88ftQtNm_
+ http://www.pcduino.com/

pcDuino is a mini PC platform that runs PC like OS such as Ubuntu and
Android ICS. It outputs screen to HDMI. Moreover, it has hardware
headers interface compatible with Arduino (TM). pcDuino can be used to
teach Python, C and more interesting stuff.

pcDuino是一种高性能，高性价比的迷你PC的平台，能够运行PC操作系统，如
Ubuntu和Android的ICS等。它可以通过内置HDMI接口输出视频到电视或显示器屏
幕。

pcDuino专门针对开源社区快速增长的需求，即希望有一个平台可以运行完整的
PC操作系统，容易使用的工具链和兼容流行的Arduino开放的生态系统，如
Arduino shield和开源项目等。

pcDuino迷你计算机的CPU采用1GHz ARM Cortex A8内核，DRAM为1GB，板载存储
达到2GB Flash, 完全兼容Arduino接口。另外，pcDuino 可以从NAND或者从
mini-SD卡(TF卡)启动，在NAND Flash内有出厂预装了ubuntu系统

参数：
+ CPU： 1GHz ARM Cortex A8内核
+ GPU： OpenGL ES2.0, OpenVG 1.1 Mali 400 core
+ DRAM： 1GB
+ 板载存储： 2GB Flash, microSD 插槽扩展至 32GB
+ 视频输出： HDMI
+ 操作系统： Linux3.0 + Ubuntu12.10
+ 扩展接口： 2.54mm Headers兼容Arduino
+ 以太网： RJ45接口以及可扩展 USB WiFi (未包括)
+ 电源： 5V 2A
+ 尺寸：125mm X 52mm

**** pcDuino Ubuntu
+ http://my.phirobot.com/blog/2013-07-setup_pcduino_for_ros.html
+ http://my.phirobot.com/blog/2013-07-install_ros_groovy_in_pcduino.html


1. 配件
   1) 5V2A直流电源。

      pcDuino外接键盘鼠标启动的时候大概800mA的电流峰值，作一般用途，使
      用1A的电源或者电脑的USB也够了，但最好还是2A电源保险。

   2) USB-microUSB数据线。

      此数据线不仅用于pcDuino的OTG口传输数据，还用于DCPOWER口供电（OGT口也能供电，但最好不要经常使用它供电）。

   3) HDMI视频线。

      HDMI，VGA，DVI是常见的几种视频（视音）数据接口，这几种接口长什么
      样自行谷歌。pcDuino的视频输出接口是HDMI，而一般的电脑显示器的视频
      输入接口会有VGA和DVI的接口，如果想让pcDuino输出的视频信号被显示出
      来，需要购买对应的HDMI转VGA(DVI)的数据线。

   4) microSD卡 + 读卡器。

      pcDuino的2G NAND flash不够装ROS以及一些包，最好准备一张class 10的
      8G（或者以上）的SD来装系统。

   5) 其它设备

      此外，还有一些外围设备是需要准备的，如：
      + 显示器。否则无法看到pcDuino的内部状态，如果无法通过HDMI输出
        pcDuino的内部状态，使用USB-TTL线将pcDuino的debug串口与PC机连接，
        也能看到pcDuino的内部状态，这里不讨论。
      + 鼠标 + 键盘。插到pcDuino的USB口上即可使用。后期透过网络SSH也能
        使用PC上的VNC工具操作pcDuino，但初次安装没有键盘是无法操作联网
        的。
      + 网线。联网更新，PC通过VNC工具访问等都需要。
      + USB Hub。以后可能会出现pcDuino的USB端口不够用的情况。

2. 安装Ubuntu

3. 扩容

4. 安装ROS

** Note
*** no transform from foo_link to base_link

+ 修改rviz中的Fixed frame
+ 确认urdf模型中joint无误
+ tf不工作，重启ros

*** 上述同样的错误会影响到 rviz和gazebo在同一个launch中启动， 解决方法也是关闭roscore
*** xacro文件中不要有中文字符
1. xacro.py仅支持ascii
2. 输出到标准输出没有问题
3. 但是输出到文件（包括重定向）就会抛出异常
*** No valid hardware interface element found in joint
+
  http://answers.gazebosim.org/question/6654/gazeboos-x-109-no-valid-hardware-interface-element/


I found out the reason is that in this version of
ros_control/transmission_interface/transimission_parser.cpp , the
parser will check if there are <hardwareinterface> tags in both
<joint> section and <actuator> section. But in rrbot and other gazebo
example, only <actuator> has <hardwareinterface> tag. Therefore this
error occurs.


By adding <hardwareinterface> tags to <joint> section, this error
disappears. For example, in rrbot.xacro, change

#+BEGIN_SRC xml
<joint name="joint1"/>
#+END_SRC

as:
#+BEGIN_SRC xml
  <transmission name="tran1">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="joint1">
      <hardwareInterface>EffortJointInterface</hardwareInterface>
    </joint>
  </transmission>
#+END_SRC
*** OSError: [Errno 13] Permission denied
have on idea
#+BEGIN_SRC xml
<arg name="urdf_model" default="$(find xacro)/xacro.py '$(find tagerill_description)'/urdf/tagerill.urdf.xacro" />
  <param name="robot_description" command="$(arg urdf_model)" />
#+END_SRC

*VS*

#+BEGIN_SRC xml
  <arg name="urdf_model" default="$(find tagerill_description)/urdf/tagerill.urdf.xacro" />
  <param name="robot_description" command="$(arg urdf_model)" />
#+END_SRC

tagerill.urdf.xacro自然没有执行权限了，真是傻叉。

*** Message removed because it is too old Rviz

*不明所以，可能重启 几次就好了*

*** launch file中不能重复定义arg

*** material 'white' is not unique.

xml中不能重复定义

* Robotics
** Robotics Tutorials
*** Robotics: Introduction to Automous Mobile Robots

**** Introduction
mobility: locomotion
autonomy


***** robots

****** KUKA: auto assembly plant-spot welding robot

[[/home/ben/Tiger/Figures/scrot/3297e0x.png]]

Robot arms / manipulators

****** Sojourner: Mars exploration,  NASA


[[/home/ben/Tiger/Figures/scrot/3297Q-A.png]]

****** Plustech: walking robot to move wood

[[/home/ben/Tiger/Figures/scrot/3297dIH.png]]

****** Airduct inspection robot: with a pan-tilt camera

[[/home/ben/Tiger/Figures/scrot/3297qSN.png]]

****** Pioneer

[[/home/ben/Tiger/Figures/scrot/32973cT.png]]

****** ALTEX AUV(autonomous underwater vehicle)

[[/home/ben/Tiger/Figures/scrot/3297EnZ.png]]

****** EXPO: tour-guide robot

[[/home/ben/Tiger/Figures/scrot/3297Rxf.png]]

****** HELPMATE: with camera looking to the ceiling

[[/home/ben/Tiger/Figures/scrot/3297e7l.png]]

****** RB 700: industrial cleaning robot,  navigation based on sonar and gyro

[[/home/ben/Tiger/Figures/scrot/3297rFs.png]]

****** RC 3000: RobotCleaner consumer robot,  optical sensor to measure air pollution

[[/home/ben/Tiger/Figures/scrot/32974Py.png]]

****** Pioneer: modular mobile robot, gripper/on-board camera

[[/home/ben/Tiger/Figures/scrot/3297qZB.png]]

****** iRobot: a large variety of sensors to high-performance navigation

[[/home/ben/Tiger/Figures/scrot/32973jH.png]]

****** Khepera: small 60mm

[[/home/ben/Tiger/Figures/scrot/3297EuN.png]]

****** Alice,  smallest fully automous robots,  2x2x2cm, infrared distance sensor
tactile whisker
***** high-level question: cognition, localization,  navigation
require standard research *robot platform*: */ROS/*

***** interdisciplinary
Mobile robot's design involves the integration of many different
bodies of knowledge

1. locomotion
   + mechanism
   + kinematics
   + dynamics
   + control theory

2. robust & perceptual
   + signal analysis
   + computer vision
   + sensor technologies

3. localization & navigation
   + computer algorithms
   + information theory
   + artificia intelligence
   + probability theory

[[/home/ben/Tiger/Figures/scrot/3297eCa.png]]

***** overview of the book
+ C2-3 locomotion：
  - mechanism enable locomotion(C2)
  - kinecmatics(C3)
  - shortcomings of conventional robotics: perception

+ C4 perception:
  - the most promising sensor for the future of mobile robotics is
    *vision*
    - CCD
    - CMOS
  - perception is mre than sensing: *interpertation*
    - feature extraction

+ C5-6 localization & cognition & navigation
  - localization(C5)
    - belief representation
    - map representation
    - Markov localization
    - Kalman filter
  - planning and navigation(C6)
    - obstacle avoidance and path planning

*Robotics is peruliar in that solution to high-level challenges are most meaningful only in the context of a solid understanding of the
 low-level details of the system.*

**** Locomotion
***** forms: walk, jump, run, slide, skate, swim, fly, roll -> 仿生

[[/home/ben/Tiger/Figures/scrot/3297rMg.png]]

adventures:
1. mechanical complexity
2. robustness
3. energy storage

-> wheeled or a small number of articulated legs

***** Key issues for locomotion
1. stability
   - number and geomety of contact point
   - center of gravity
   - static/dynamic stability
   - incination of terrain

2. characteristics of contact
   - contact point/path size and type
   - angle of contact
   - friction

3. type of environment
   - structure
   - medium

***** legged Mobile Robots
1. feature: a series of point contact between the robot and the ground

2. advantages
   1) adaptability and maneuverability in rough terrain
   2) capable of crossing a hole of chasm
   3) potential to manipulate objects

3. disadvantages
   - power and mechanical complexity
     - multi-freedom

****** Leg configuration and stability

[[/home/ben/Tiger/Figures/scrot/32974Wm.png]]

Legged robots are biologically inspired.

Two legs: much more complex active control to maintain balance

Three legs: static stability

6 legs: static walking
** Robotics Related
*** DRC
+ http://jandan.net/2013/12/20/robots-drc.html


DARPPA机器人挑战赛(DRC)是是机器人领域的一项重大赛事，由DARPA(国防高等
研究计划署)举办。

DARPA Robotics Challenge (DRC)

*** CARMEN: Carnegie Mellon Robot Navigation Toolkit           :carmen:cmu:

**** Core Functionalities

- Carmen is a modular robot control software
- Carmen uses the inter-process communication plattform IPC
- Process monitoring
- Robot hardware support for different plattforms (see here)
- Hardware support for SICK laser range finder and GPS receiver
- Robot/sensor simulator (in 2d)
- Path planning module
- Localization module
- Scan-matching and mapping module
- Message logging and playback functionality
- Centralized parameter server
- Several useful functions when working/programming with robots
- Carmen is written in C, but provides Java support
- Carmen runs under Linux and is available under GPL

**** reference

+ [[http://carmen.sourceforge.net/home.html][Homepage]]

*** vtk: Visualization Toolkit                                        :vtk:

The *Visualization Toolkit* (VTK) is an *open-source*, freely available
software system for _3D computer graphics, image processing, and
visualization._ It consists of =a C++ class library= and several
interpreted =interface= layers including Tcl/Tk, Java, and
*Python*. Kitware, whose team created and continues to extend the
toolkit, offers professional support and consulting services for
VTK. VTK supports a wide variety of *visualization algorithms* including
scalar, vector, tensor, texture, and volumetric methods, as well as
advanced modeling techniques such as implicit modeling, polygon
reduction, mesh smoothing, cutting, contouring, and Delaunay
triangulation. VTK has an extensive information visualization
framework and a suite of 3D interaction widgets. The toolkit supports
parallel processing and integrates with various databases on GUI
toolkits such as *Qt and Tk*. VTK is *cross-platform* and runs on Linux,
Windows, Mac, and Unix platforms.

*** sdl                                                               :sdl:

**** sdl

[[https://www.libsdl.org/][Homepage]]

Simple DirectMedia Layer is a cross-platform development library
designed to provide low level access to audio, keyboard, mouse,
joystick, and graphics hardware via OpenGL and Direct3D.

***** install                                                   :install:

#+BEGIN_EXAMPLE
 $ sudo apt-get install  libsdl2-2.0-0
#+END_EXAMPLE

**** sdl_image                                                 :sdl_image:

- [[http://www.libsdl.org/projects/SDL_image/][Homepage]]
- [[http://jcatki.no-ip.org:8080/SDL_image/][Document]]


SDL_image is an *image loading library* that is used with the SDL
library, and almost as portable. It allows a programmer to use
multiple image formats without having to code all the loading and
conversion algorithms themselves.

***** install                                                   :install:

#+BEGIN_EXAMPLE
 $ sudo apt-get install libsdl-image1.2
#+END_EXAMPLE

** PCL                                                                 :pcl:

*** Reference

- [[http://www.pointclouds.org/][Homepage]]
- [[http://docs.pointclouds.org/1.5.1/][API]]
- [[https://github.com/PointCloudLibrary/pcl][Github]]
- [[http://www.pointclouds.org/documentation/tutorials/][PCL tutorials]]
- [[http://wiki.ros.org/pcl/Tutorials][ROS PCL tutorials]]

*** overview

The Point Cloud Library (PCL) is a standalone, large scale, open
project for 2D/3D image and point cloud processing.


**** Module

 [[~/Wally/Journal/Figure/ROS/screenshot_2015-06-17_21:54:52.png]]

+ filters
+ features
+ keypoints
+ registration
+ kdtree
+ octree
+ segmentation
+ sample_consensus
+ surface
+ recognition
+ io
+ visualization


**** TODO PCL 看上去很好玩，但是太大

*** installation                                                  :install:

- http://www.pointclouds.org/downloads/

**** install prebuilt binaries

- http://www.pointclouds.org/downloads/linux.html

#+BEGIN_EXAMPLE
sudo add-apt-repository ppa:v-launchpad-jochen-sprickerhof-de/pcl
sudo apt-get update
sudo apt-get install libpcl-all
#+END_EXAMPLE

**** compile                                                     :compile:

http://www.pointclouds.org/documentation/tutorials/compiling_pcl_posix.php#compiling-pcl-posix

cmake

#+BEGIN_EXAMPLE
$ git clone https://github.com/PointCloudLibrary/pcl
$ cd pcl & mkdir build & cd build
$ cmake ..
$ make -j2
$ sudo make -j2 install
#+END_EXAMPLE

*make -j2* 表示衍生出两个作业数

编译过程十分耗内存， -j8(4核，每核分配两个任务) 直接被迫切换到字符终端
(C-M-<F1>) 重启。

***** check

#+BEGIN_EXAMPLE
   ~ $ dpkg -l | grep pcl
  ii  libpcl-1.7-all                                        1.7.1-3+trusty2                                     all          The Point Cloud Library (or PCL) for point cloud processing - development
  ii  libpcl-1.7-all-dev                                    1.7.1-3+trusty2                                     all          The Point Cloud Library (or PCL) for point cloud processing - development
  ii  libpcl-1.7-bin
#+END_EXAMPLE

*** PCL Visualization

http://www.pointclouds.org/documentation/overview/visualization.php

**** overview

base on ~VTK~

The pcl_visualization library was built for the purpose of being able
to quickly *prototype* and *visualize* the results of algorithms
operating on 3D point cloud data. Similar to OpenCV’s highgui
routines for displaying 2D images and for drawing basic 2D shapes on
screen.

- methods for rendering and setting visual properties (colors, point
  sizes, opacity, etc) for any n-D point cloud datasets in
  *pcl::PointCloud<T>* format;

- methods for *drawing basic 3D shapes* on screen (e.g., cylinders,
  spheres, lines, polygons, etc) either from sets of points or from
  parametric equations;

- a *histogram* visualization module (PCLHistogramVisualizer) for 2D
  plots;

- a multitude of Geometry and Color handler for pcl::PointCloud<T>
  datasets;

- a *pcl::RangeImage* visualization module.

**** PCD Viewer                                           :pcd:pcl_viewer:

源码编译的位置为 =~/Program/pcl/build/bin/pcl_viewer=

or *pcd_viewer* ?

$ pcl_viewer -multiviewer 1 *.pcd

1. pcl_v<TAB>

   #+BEGIN_EXAMPLE
     ~ $ pcl_v
     pcl_vfh_estimation                   pcl_voxel_grid_occlusion_estimation
     pcl_viewer                           pcl_vtk2obj
     pcl_virtual_scanner                  pcl_vtk2pcd
     pcl_voxel_grid                       pcl_vtk2ply
   #+END_EXAMPLE

2. pcl_view

   #+BEGIN_EXAMPLE
     Syntax is: pcd_viewer <file_name 1..N>.pcd <options>
       where options are:
                          -bc r,g,b                = background color
                          -fc r,g,b                = foreground color
                          -ps X                    = point size (1..64)
                          -opaque X                = rendered point cloud opacity (0..1)
                          -ax n                    = enable on-screen display of XYZ axes and scale them to n
                          -ax_pos X,Y,Z            = if axes are enabled, set their X,Y,Z position in space (default 0,0,0)

                          -cam (*)                 = use given camera settings as initial view
      (*) [Clipping Range / Focal Point / Position / ViewUp / Distance / Window Size / Window Pos] or use a <filename.cam> that contains the same information.

                          -multiview 0/1           = enable/disable auto-multi viewport rendering (default disabled)


                          -normals 0/X             = disable/enable the display of every Xth point's surface normal as lines (default disabled)
                          -normals_scale X         = resize the normal unit vector size to X (default 0.02)

                          -pc 0/X                  = disable/enable the display of every Xth point's principal curvatures as lines (default disabled)
                          -pc_scale X              = resize the principal curvatures vectors size to X (default 0.02)
   #+END_EXAMPLE

*** [[http://www.pointclouds.org/documentation/tutorials/walkthrough.php#filters][PCL walkthough]]

*modular*

**** filters

An example of /noise removal/ is presented in the figure below.


#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/statistical_removal_2.jpg @ 2016-01-06 13:51:12
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/statistical_removal_2_2016-01-06_13:51:12.jpg]]


Due to measurement errors, certain datasets present a large number of
*shadow points*.

This complicates the estimation of local point cloud 3D features. Some
of these =outliers= can be filtered by performing a *statistical
analysis* on each point’s *neighborhood*, and trimming those that do
not meet a certain criteria.

The sparse outlier removal implementation in PCL is based on the
computation of the *distribution of point to neighbor distances* in
the input dataset. For each point, the mean distance from it to all
its neighbors is computed. By assuming that the resulting distribution
is Gaussian with a mean and a standard deviation, all points whose
mean distances are outside an interval defined by the global distances
mean and standard deviation can be considered as outliers and trimmed
from the dataset.

**** features

The features library contains data structures and mechanisms for 3D
feature estimation from point cloud data. 3D features are
representations at certain 3D points, or positions, in space, which
describe geometrical patterns based on the information available
around the point. The data space selected around the query point is
usually referred to as the k-neighborhood.

**** keypoints

*Keypoints* (also referred to as /interest points/) are points in an image
or point cloud that are stable, distinctive, and can be identified
using a well-defined detection criterion. Typically, the number of
interest points in a point cloud will be much smaller than the total
number of points in the cloud, and when used in combination with local
feature descriptors at each keypoint, the keypoints and descriptors
can be used to form a compact—yet descriptive—representation of the
original data.


#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/narf_keypoint_extraction.png @ 2016-01-06 13:55:22
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/narf_keypoint_extraction_2016-01-06_13:55:22.png]]

**** registration

_Combining several datasets into a global consistent model_ is usually
performed using a technique called *registration*. The key idea is to
=identify corresponding points between the data sets and find a
transformation that minimizes the distance (alignment error)= between
corresponding points. This process is =repeated=, since correspondence
search is affected by the relative position and orientation of the
data sets. Once the alignment errors fall below a given threshold, the
registration is said to be complete.


#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/scans.jpg @ 2016-01-06 13:59:08
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/scans_2016-01-06_13:59:08.jpg]]

#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/s1-6.jpg @ 2016-01-06 13:59:28
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/s1-6_2016-01-06_13:59:28.jpg]]

**** kd-tree

A *Kd-tree* (k-dimensional tree) is a space-partitioning data
structure that stores a set of k-dimensional points in a tree
structure that enables efficient range searches and nearest neighbor
searches.


#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/3dtree.png @ 2016-01-06 14:00:49
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/3dtree_2016-01-06_14:00:49.png]]



#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/kdtree_mug.jpg @ 2016-01-06 14:01:05
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/kdtree_mug_2016-01-06_14:01:05.jpg]]

**** octree


#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/octree_bunny.jpg @ 2016-01-06 14:02:00
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/octree_bunny_2016-01-06_14:02:00.jpg]]

**** segmentation

The segmentation library contains algorithms for segmenting a point
cloud into distinct clusters. These algorithms are best suited for
processing a point cloud that is composed of a number of spatially
isolated regions. In such cases, clustering is often used to break the
cloud down into its constituent parts, which can then be processed
independently.


#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/plane_model_seg.jpg @ 2016-01-06 14:03:05
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/plane_model_seg_2016-01-06_14:03:05.jpg]]

#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/cylinder_model_seg.jpg @ 2016-01-06 14:03:18
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/cylinder_model_seg_2016-01-06_14:03:18.jpg]]

**** sample consensus

The sample_consensus library holds SAmple Consensus (SAC) methods like
RANSAC and models like planes and cylinders. These can combined freely
in order to detect specific models and their parameters in point
clouds.


#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/sample_consensus_planes_cylinders.jpg @ 2016-01-06 14:04:21
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/sample_consensus_planes_cylinders_2016-01-06_14:04:21.jpg]]

**** surface

The surface library deals with reconstructing the original surfaces
from 3D scans. Depending on the task at hand, this can be for example
the hull, a mesh representation or a smoothed/resampled surface with
normals.

*Smoothing* and *resampling* can be important if the cloud is noisy,
or if it is composed of multiple scans that are not aligned
perfectly. The complexity of the surface estimation can be adjusted,
and normals can be estimated in the same step if needed.


#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/resampling_1.jpg @ 2016-01-06 14:07:16
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/resampling_1_2016-01-06_14:07:16.jpg]]


*Meshing* is a general way to create a surface out of points, and
currently there are two algorithms provided: a very fast triangulation
of the original points, and a slower meshing that does smoothing and
hole filling as well.


#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/surface_meshing.jpg @ 2016-01-06 14:06:23
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/surface_meshing_2016-01-06_14:06:23.jpg]]

*Creating a convex or concave hull* is useful for example when there
is a need for a simplified surface representation or when boundaries
need to be extracted.


#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/surface_hull.jpg @ 2016-01-06 14:06:57
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/surface_hull_2016-01-06_14:06:57.jpg]]

**** range image

The range_image library contains two classes for representing and
working with range images. A range image (or depth map) is an image
whose pixel values represent a distance or depth from the sensor’s
origin. Range images are a common 3D representation and are often
generated by stereo or time-of-flight cameras. With knowledge of the
camera’s intrinsic calibration parameters, a range image can be
converted into a point cloud.


#+DOWNLOADED: http://www.pointclouds.org/documentation/tutorials/_images/range_image1.jpg @ 2016-01-06 14:08:14
 [[~/Wally/Journal/Figure/.org-download/ROS                                                                   :ros:/range_image1_2016-01-06_14:08:14.jpg]]

**** I/O

The io library contains classes and functions for reading and writing
point cloud data (PCD) files, as well as capturing point clouds from a
variety of sensing devices.

**** visualization
**** common
**** search
**** binaries

+ pcl_viewer: a quick way for visualizing PCD (Point Cloud Data)
  files.

+ pcd_convert_NaN_nan: converts “NaN” values to “nan” values.

+ pcd_convert_NaN_nan: converts “NaN” values to “nan” values.

  Usage example:
  #+BEGIN_EXAMPLE
  pcd_convert_NaN_nan input.pcd output.pcd
  #+END_EXAMPLE

+ convert_pcd_ascii_binary: converts PCD (Point Cloud Data) files from
  ASCII to binary and viceversa.

  Usage example:
  #+BEGIN_EXAMPLE
  convert_pcd_ascii_binary <file_in.pcd> <file_out.pcd> 0/1/2 (ascii/binary/binary_compressed) [precision (ASCII)]
  #+END_EXAMPLE

+ concatenate_points_pcd: concatenates the points of two or more PCD
  (Point Cloud Data) files into a single PCD file.

  Usage example:
  #+BEGIN_EXAMPLE
  concatenate_points_pcd <filename 1..N.pcd>
  #+END_EXAMPLE

+ pcd2vtk: converts PCD (Point Cloud Data) files to the VTK format.

  Usage example:
  #+BEGIN_EXAMPLE
  pcd2vtk input.pcd output.vtk
  #+END_EXAMPLE
+ pcd2ply: converts PCD (Point Cloud Data) files to the PLY format.

  Usage example:
  #+BEGIN_EXAMPLE
  pcd2ply input.pcd output.ply
  #+END_EXAMPLE
+ mesh2pcd: convert a CAD model to a PCD (Point Cloud Data) file,
  using ray tracing operations.

  Syntax is: mesh2pcd input.{ply,obj} output.pcd <options>, where options are:
  -level X = tesselated sphere level (default: 2)
  -resolution X = the sphere resolution in angle increments (default: 100 deg)
  -leaf_size X = the XYZ leaf size for the VoxelGrid – for data
  reduction (default: 0.010000 m)

+ octree_viewer: allows the visualization of octrees

  Syntax is: octree_viewer <file_name.pcd> <octree resolution>
  Usage example:
  #+BEGIN_EXAMPLE
  Example: ./octree_viewer ../../test/bunny.pcd 0.02
  #+END_EXAMPLE

* SLAM                                                                 :SLAM:

* Algorithms
** Kalman                                                           :kalman:
*** [[http://bbs.21ic.com/icview-292853-1-1.html][关于卡尔曼滤波器的笑话一则]]                                                :blog:joke:

一片绿油油的草地上有一条曲折的小径，通向一棵大树。一个要求被提出：从起点沿着小径走到树下。

“很简单。” A说，于是他丝毫不差地沿着小径走到了树下。

现在，难度被增加了：蒙上眼。

“也不难，我当过特种兵。” B说，于是他歪歪扭扭地走到了树 ………. 旁。“唉，好久不练，生疏了。”

“看我的，我有 DIY 的 GPS！” C说，于是他像个醉汉似地走到了树………. 旁。“唉，这个 GPS 软件没做好，漂移太大。”

“我来试试。” 旁边一人拿过 GPS,  蒙上眼，居然沿着小径走到了树下。

“这么厉害！你是什么人?”

“卡尔曼 ! ”

“卡尔曼？！你是卡尔曼？”众人大吃一惊。

“我是说这个 GPS 卡而慢。”

** Voronoi                          :voronoi:voro:维诺图:泰森多边形

*** Reference

- [[http://emuch.net/html/201207/4675940.html][小木虫]]
- [[http://www.in.tum.de/fileadmin/user_upload/Lehrstuehle/Lehrstuhl_XV/Teaching/Applets/applets/vis/voronoi/Fortune.html]]
- [[http://mathworld.wolfram.com/VoronoiDiagram.html][mathworld]]

*** [[http://www.cnblogs.com/Seiyagoo/p/3339886.html][Voronoi Diagram--维诺图]]

**** Voronoi图定义

任意两点p 和q 之间的欧氏距离，记作 dist(p, q) 。就平面情况而言，我们有

#+BEGIN_EXAMPLE
dist(p, q) = (px-qx)2+ (py-qy)2
#+END_EXAMPLE

设P := {p1, ..., pn}为平面上任意 n个互异的点；这些点也就是基点。按照我
们的定义，所谓P对应的Voronoi图，就是平面的一个子区域划分------整个平面
因此被划分为n个单元（cell ），它们具有这样的性质：

任一点q位于点pi 所对应的单元中，当且仅当对于任何的pj∈Pj,
j≠i,都有dist(q, pi)<dist(q, pj)。我们将与P对应的Voronoi图记作Vor(P)。

“Vor(P)
”或者“Voronoi图”所指示的仅仅只是组成该子区域划分的边和顶点。在Vor(P)中，与基点pi
相对应的单元记作V (pi)------称作与pi 相对应的Voronoi单元（Voronoi
cell）。上图是Voronoi图，下图的蓝色点围成的区域（凸包）是它对应的
Delaunay三角剖分。


#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/26154830-6aa16b0c2d834d3f831e91ee01199471.jpg @ 2016-03-03 14:53:05
 [[~/Wally/Journal/Figure/.org-download/Journal/26154830-6aa16b0c2d834d3f831e91ee01199471_2016-03-03_14:53:05.jpg]]

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/26154809-262b7630cca4415a9e841953a302243b.jpg @ 2016-03-03 14:52:28
 [[~/Wally/Journal/Figure/.org-download/Journal/26154809-262b7630cca4415a9e841953a302243b_2016-03-03_14:52:28.jpg]]

任给平面上两点p 和q ，所谓 p 和q 的平分线（bisector），就是线段
pq的垂直平分线。该平分线将平面划分为两张半平面（half-plane）。点 p
所在的那张开半平面记作 h(p, q) ，点 q 所在的那张开半平面记作 h(q, p)
。请注意，r ∈ h(p, q) 当且仅当 dist(r, p) < dist(r, q)
。据此，可以得出如下观察结论：

  V (pi) = ∩h(pi, pj) ,1≤j≤n, j≠ i

也就是说，V
(pi)是(n-1)张半平面的公共交集；它也是一个（不见得有界的）开的凸多边形（convex
polygon）子区域.

很显然，Voronoi顶点到相邻的三个site距离相等；Voronoi边上任意一点到相邻
的两个site距离相等；

对于任何点q，我们将以q为中心、内部不含P中任何基点的最大圆，称作q关于P的最大空圆（largestempty
circle ），记作Cp(q)。以下定理指出了Voronoi图的顶点及边所具有的特征：

对于任一点集P 所对应的Voronoi图Vor(P) ，下列命题成立：\\
1) 点q 是Vor(P)
的一个顶点，当且仅当在其最大空圆Cp(q)的边界上，至少有三个基点；
(Voronoi顶点是三个site的外接圆的圆心)\\
2) pi 和pj 之间的平分线确定了Vor (P)
的一条边，当且仅当在这条线上存在一个点 q，Cp(q)的边界经过pi
和pj，但不经过其它站点。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225148-43427baf0b2a43fcb83eaf32ea407433.jpg @ 2016-03-03 14:53:54
 [[~/Wally/Journal/Figure/.org-download/Journal/25225148-43427baf0b2a43fcb83eaf32ea407433_2016-03-03_14:53:54.jpg]]

**** 构造Voronoi图

构造Voronoi图有四种算法：定义法（Intersect of
Halfplanes）、增量（incremental）算法、分治法、plane sweep算法；

1、plane sweep（平面扫描）算法又名Fortune算法，它主要由两部分组成：sweep
line（扫描线）和beach line（海滩线）；

Fortune算法建立在点、线之间的距离关系上，如下图所示，平面上任意一点到一个点p的距离与到一条直线l的距离相等，这样的点有很多，它们构成的轨迹就是抛物线，点p就是抛物线的焦点，直线l就是抛物线的准线；

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225203-a4d8601e3b484f5a9c8f8f4c7c926506.jpg @ 2016-03-03 14:54:11
 [[~/Wally/Journal/Figure/.org-download/Journal/25225203-a4d8601e3b484f5a9c8f8f4c7c926506_2016-03-03_14:54:11.jpg]]

2、回到Fortune算法，这个固定点p就是一个site，l就是sweep line；

sweep line自上而下扫描，平面区域任何点到site与sweep
line距离相等的点构成一条抛物线（site就是抛物线的焦点），则n个site的抛物线相交的若干段抛物线弧构成beach
line，如下图的蓝色抛物线弧集合；

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225218-1f755c87f04b4970a86c99a85d03df4d.jpg @ 2016-03-03 14:54:40
 [[~/Wally/Journal/Figure/.org-download/Journal/25225218-1f755c87f04b4970a86c99a85d03df4d_2016-03-03_14:54:40.jpg]]

抛物线之间的交点称为断点（break point），每个断点都落在某条Voronoi
边上。这并非巧合，随着扫描线自上而下扫过整个平面，所有断点的轨迹合起来恰好就是待构造的Voronoi图；（几何证明：断点到相邻的两个site距离总是相等，这个关系随着sweep
line的扫描一直不变，则断点的运动轨迹就是这两个site的垂直平分线，也即Voronoi
边，两条Voronoi 边相交又产生Voronoi 顶点）

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225242-cbcc75751eff45898334f2f3aea5525c.jpg @ 2016-03-03 14:55:01
 [[~/Wally/Journal/Figure/.org-download/Journal/25225242-cbcc75751eff45898334f2f3aea5525c_2016-03-03_14:55:01.jpg]]

beach line上方的Voronoi 顶点和Voronoi 边已确定，将不会再变化。beach
line（曲线）和它上方的直线构成当前的Voronoi 边，最后随着sweep
line的移动而beach line也在不断下移，变为最终的Voronoi 边； （海滩线沿x
方向单调------即，它与任一垂线相交而且仅相交于一点。）



beach line属性

1、随着sweep line下降，break points跟踪Voronoi边；一个新的break
point（新弧形成或者两个break point融合为一体）产生一条新的边；

2、两个break point相遇产生voronoi顶点

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225309-40f6b465a6b2453d91c60b805818ae38.jpg @ 2016-03-03 14:55:32
 [[~/Wally/Journal/Figure/.org-download/Journal/25225309-40f6b465a6b2453d91c60b805818ae38_2016-03-03_14:55:32.jpg]]



3、为了确定Voronoi 边和Voronoi 顶点，我们需要维护beach
line这个结构，但是随着l
的运动它会持续不断地更新。那么，应该如何表示beach line结构呢？

所谓beach
line的组合结构发生变化，指的是其上出现了新的抛物线弧，或原有的某段抛物线弧收缩成一个点并进而消失。在这个算法中，产生新弧，称为site
event；旧弧消失，称为circle event。



两类事件site event和circle event：

1）、site event

sweep
line扫到某个site，设为p，在此瞬间，站点p对应于一条宽度为零的退化抛物线------亦即，将该新站点p与扫描线l联接起来的垂直线段。随着扫描线继续下移，这个宽度为0的抛物线将逐渐伸展开来。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225355-4711d3791a6c4cdc8bdae5bc738cbf82.jpg @ 2016-03-03 14:55:39
 [[~/Wally/Journal/Figure/.org-download/Journal/25225355-4711d3791a6c4cdc8bdae5bc738cbf82_2016-03-03_14:55:39.jpg]]

site
event发生后引起的变化：因为沿海滩线上各个断点的运动轨迹，就勾勒出了Voronoi
图的各边。所以每发生一次site事件，就会生成两个新的断点，此后它们会逐渐地勾勒出同一条新边。

那为什么是同一条新边呢？实际上，在刚刚诞生的那一瞬间，这两个断点相互重合，然后才会各自朝相反的方向运动，而且它们所勾勒的都是同一条边（同break
point定义处的几何证明）。在一开始，这条边与Voronoi图位于扫描线之上的其它部分并不相联。随着这条边的不断生长，直到后来它们与其它边相遇，此时它才会与Voronoi图的其它部分联接起来。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225413-3220930b83d345a4bfa8475ae4653b77.jpg @ 2016-03-03 14:55:44
 [[~/Wally/Journal/Figure/.org-download/Journal/25225413-3220930b83d345a4bfa8475ae4653b77_2016-03-03_14:55:44.jpg]]

定理：只有在发生某个site事件时，海滩线上才会有新的弧出现。



2）、circle event

发生于原有的某段弧收缩为一点并即将消失时，假设三段连续的弧α 、α '和α
''，这三段弧必然分别对应于三个不同基点pi 、pj和pk
，就在α'即将消失的那一刻，这三个基点所对应的抛物线将相交于同一点q
。此时点q 到扫描线l 与到这三个基点等距离。亦即，存在一个以q
为中心、穿过pi、pj和pk 的圆，且该圆在最低点处与l
相切。该圆的内部不可能有任何基点------否则，q 到该基点将比到l
更近，而这却与“q 位于海滩线上”的事实不合。因此，点q
必是Voronoi图的一个顶点。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225426-f631bdb745e541b1bd6559a78da57640.jpg @ 2016-03-03 14:55:51
 [[~/Wally/Journal/Figure/.org-download/Journal/25225426-f631bdb745e541b1bd6559a78da57640_2016-03-03_14:55:51.jpg]]



若海滩线上有某段弧消失，并因而有两段弧汇合起来，则相应地在Voronoi图中肯定也会有两条边汇合起来（成为一条新的边）。海滩线上依次首尾相联的任何三段弧，其对应的三个基点都会确定一个外接圆；当扫描线触及某个这类外接圆的最低点时，也就发生了一次圆事件（circle
event ）

定理：海滩线上已有的弧，只有在经过某次圆事件之后，才有可能消失。



简单点说，site event发生时，beach
line会产生一条新弧，同时就会有一条新边出现并朝两端生长，慢慢形成新的Voronoi边；circle
event发生时，会有两条正在生长的Voronoi边汇合起来，并在接合处形成一个Voronoi
顶点，同时中间的旧弧消失。



4、异常情况

a false alarm：We may have stored a circle event in the event list, but
it maybe that it never happens

There are two reasons for false alarms: site events and othercircle
events

我们存储了circle event，但它可能永远不会发生，真是一个美丽的错误...
在site event和circle event发生时，都会有可能误报情况。



1）、site event：circle event发生时产生的最大空心圆内部还有其他site。

如下面三个图例，p2、p3、p4组成的外接圆，确定了一个circle
event，外接圆y坐标最小的点（图中最低的小红点）将进入PQ，但是在sweep
line碰到它之前，先扫描到了site
p7，这样一来将产生新弧，破坏了原来的<p2,p3,p4>三元组。发生circle
event时，并不知道这是一个false
alarm，所以直到碰到该外接圆内部存在site。这时需要把这个circle
event去掉，也即删除原先进入PQ中的最低点。也说明了这个外接圆的圆心不是Voronoi顶点，属于误报。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225451-7d94d8afc8444cbea2fea6ed2b107079.jpg @ 2016-03-03 14:56:02
 [[~/Wally/Journal/Figure/.org-download/Journal/25225451-7d94d8afc8444cbea2fea6ed2b107079_2016-03-03_14:56:01.jpg]]

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225504-7fcdd7ef130446a59dee1c0e5e2b675c.jpg @ 2016-03-03 14:56:12
 [[~/Wally/Journal/Figure/.org-download/Journal/25225504-7fcdd7ef130446a59dee1c0e5e2b675c_2016-03-03_14:56:12.jpg]]

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225521-e7d1f4e99092443c82a8fae5ec9c4133.jpg @ 2016-03-03 14:56:14
 [[~/Wally/Journal/Figure/.org-download/Journal/25225521-e7d1f4e99092443c82a8fae5ec9c4133_2016-03-03_14:56:14.jpg]]



2）、circle
event：该事件还没有来得及真正发生，这一邻接弧三元组就已经消失了。

如下面三个图例，<p2,p3,p4>三元组先产生外接圆，第一个小红点进入PQ，当sweep
line扫描到p1时，<p1,p2,p3>三元组也产生外接圆，第二个小红点进入PQ；但是，当sweep
line扫描到第一个小红点时，它从PQ出队，随着sweep
line下移，α3消失，<α2,α3,α4>合并为<α2,α4>破坏了原来的三元组，则<p1,p2,p3>无法形成Voronoi顶点，也即这个circle
event属于误报。需要删除PQ中第二个小红点。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225609-6fe127e007194bf481cd59f1835d9188.jpg @ 2016-03-03 14:56:15
 [[~/Wally/Journal/Figure/.org-download/Journal/25225609-6fe127e007194bf481cd59f1835d9188_2016-03-03_14:56:15.jpg]]

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225616-604e0450623e4ba9aa70dd9911404f00.jpg @ 2016-03-03 14:56:15
 [[~/Wally/Journal/Figure/.org-download/Journal/25225616-604e0450623e4ba9aa70dd9911404f00_2016-03-03_14:56:15.jpg]]

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225624-1ca29f44f06d4396996ab5e72adcbf59.jpg @ 2016-03-03 14:56:16
 [[~/Wally/Journal/Figure/.org-download/Journal/25225624-1ca29f44f06d4396996ab5e72adcbf59_2016-03-03_14:56:16.jpg]]

图像说明： bayanbox.ir/id/3367913281004602743?download


[[http://www.cise.ufl.edu/~sitharam/COURSES/CG/kreveldmorevoronoi.pdf]]

**** 相关数据结构

构建Voronoi图需要三个数据结构，分别是平衡二叉树AVL，优先队列PQ和双向边链表DCEL。

1、beach line数据结构AVL：记录beach line的状态，包括break points, and
the arcs currently on beach line

一个叶子结点表示一段弧，因为每个弧都一 一对应一个site，所以用site
number来存储；

非叶子结点则表示两条弧的交点即断点，用两条弧对应的site对存储；因为弧和断点都是不断变化的，所以都用固定的site
number来表示。



此例中AVL中的p1、p2表示原图的site p1和site
p2对应的弧，<p1,p2>表示两弧的交点即断点，其实AVL树就是site和break
point的中序遍历。



若按照这样的方式来表示beach
line，每遇到一个新的site，都可以在O(logn)时间内，沿beach
line找出位于该site上方的那段弧：在查找过程中，在每个内部节点处，只要将其对应断点的x坐标，与新site的x坐标做一比较。

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225712-6b8ca04d1a57468291eca243c8f1437b.jpg @ 2016-03-03 14:56:52
 [[~/Wally/Journal/Figure/.org-download/Journal/25225712-6b8ca04d1a57468291eca243c8f1437b_2016-03-03_14:56:52.jpg]]



为了处理false alarm的第二种情况，T
的一片叶子若对应于某段弧α，则为它配备一个指针，指向PQ中的一个（事件）节点------具体说，就是（在将来可能）导致α
消失的那个圆事件所对应的节点。若没有导致α消失的圆事件，或者还没有发现这样一个事件，则该指针被置为nil。



最后，每个内部节点v 也配有一个指针，指向与当前Voronoi
图对应的双向链接边表DCEL中的某条半边（half-edge
）------更确切地说，此时与 v 相对应的断点，正在勾勒出的一条
Voronoi边，而v 的指针就指向这条边所对应的那条半边。



处理：新的site产生一条新弧，对应的旧弧被删除（DS中对应AVL某叶子节点被删除）；同时，该旧弧指向的event也将被删除（DS对应PQ中删除一个元素）；



添加弧操作：replacing the leaf with a sub-tree

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225724-384b5b4223d641928e32265811556e7f.jpg @ 2016-03-03 14:56:53
 [[~/Wally/Journal/Figure/.org-download/Journal/25225724-384b5b4223d641928e32265811556e7f_2016-03-03_14:56:53.jpg]]



删除弧操作：deleting a leaf from the tree

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225733-cb04d0d5bf2a4b49afb52d64c88b9c1b.jpg @ 2016-03-03 14:56:54
 [[~/Wally/Journal/Figure/.org-download/Journal/25225733-cb04d0d5bf2a4b49afb52d64c88b9c1b_2016-03-03_14:56:54.jpg]]





2、事件队列PQ：Event queue（on decreasing y-coordinate）

记录扫描线当前状态的结构。存储已确定即将发生的events。对于site
event，在sweep line开始扫描之前就可以全部送入PQ；

对于circle event,不仅要记录该外接圆的最低点（外接圆与sweep
line的切点），还要设置一个指针指向AVL中的某片叶子------这片叶子所对应的，就是在该事件发生时即将随之消失的那段弧。



如果某三个site形成的外接圆，该圆对应的纵坐标最小的点（即未来的切点）在sweep
line的下面，则为circle
event；并将该点入优先队列；并且这三个连续的sites与该切点互相链接对方。对于false
alarm的第一种情况还需处理。



处理：sweep
line扫描到切点，三条弧变成两条弧，形成Voronoi顶点；删除三条弧中间的那条，对应DS则为删除叶子节点，并在PQ中删除该节点指向的event（若有，即为一个false
alarm），同时将合并后的两条弧分别与原先三条弧的左右两侧各一条弧结合，形成两个新的三元组，将两新三元组对应的两切点加入PQ，并做指针链接；





3、双向边链表（DCEL）：记录Voronoi状态，包含half-edges,
edges（一对half-edge）, vertices and cellrecords（A chain of
counter-clockwisehalf-edges）



At the leaves of the tree, a pointer to the circle event is stored, if
the arc defines a circle event. If not, pointer is set to NULL. By
maintaining this pointer, we do not have to perform any search after
encountering false events.

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225746-8cf044f7bf7a43459f82c7d15aeea0b2.jpg @ 2016-03-03 14:56:55
 [[~/Wally/Journal/Figure/.org-download/Journal/25225746-8cf044f7bf7a43459f82c7d15aeea0b2_2016-03-03_14:56:55.jpg]]







**** 算法伪码



算法 VORONOID IAGRAM (P)\\
 输入：平面点集 P := {p1, ..., pn)\\
 输出：以双向链接边表 D 表示的（限制在一个足够大的包围框之内的）Voronoi
图Vor(P)\\
 1.初始化事件队列Q ：将所有的基点事件插入其中\\
  初始化状态结构T ：将其置空\\
  初始化双向链接边表D ：将其置空\\
 2. while ( Q 非空)\\
 3. do 将y- 坐标最大的事件从 Q 中取出\\
 4. if ( 这是一个发生于基点 pi 处的基点事件)\\
 5. then HANDLESITE EVENT(pi)\\
 6. else HANDLECIRCLE EVENT(γ)\\
  (* 这里的γ是T 的一匹叶子，它对应于那段即将消失的弧 *)\\
 7.(* 仍然存在于 T 中的那些内部节点，对应于 Voronoi 图的单向无穷边 *)\\
  计算出一个包围框，其尺寸之大，应足以容下Voronoi 图中的所有顶点\\
  通过对双向链接边表的适当调整，将这些单向无穷边都联接到这个包围框上\\
 8.遍历双向链接边表中的所有半边增加相应的单元记录\\
 设置好指向这些单元的指针，以及由这些单元发出的（指向对应各边的）指针



处理两类事件的子程序分别如下：\\
 算法 HANDLESITE EVENT(pi)

#+DOWNLOADED: http://images.cnitblog.com/blog/307487/201309/25225758-7c1139b0d8da4c58af2da4a57cdf1d54.jpg @ 2016-03-03 14:56:56
 [[~/Wally/Journal/Figure/.org-download/Journal/25225758-7c1139b0d8da4c58af2da4a57cdf1d54_2016-03-03_14:56:56.jpg]]



算法 HANDLECIRCLE EVENT(γ)\\
1.将（对应于即将消失的弧α的那匹）叶子γ，从T 删除掉\\
 检查相关的内部节点，更新其中表示有关断点的基点对信息\\
 若有必要，须对T 做调整，以使之重新平衡\\
 在Q 中，删除所有与α相关的圆事件\\
 (* 在T 中，γ的前驱与后继节点配有相应的指针 *)\\
 (* 借助这些指针，就可以找出这些事件 *)\\
 （α在其中居中的那个圆事件，此刻正在接受处理，并已经从Q 被删除掉了）\\
2. 更新存储当前Voronoi图的双向链接边表D ：\\

对应于该事件的圆心生成一个Voronoi顶点记录，并将该记录插入双向链接边表；\\

对应于海滩线上新生出的断点,并生成两个半边记录，正确地设置好它们相互之间的指针；\\
 将这三个新记录，与同样终止于该Voronoi顶点的其它半边链接起来\\
3. (* 此前与α紧邻于左侧的那段弧，现可能在某个新的邻接弧三元组中居中
*)\\
 检查该邻接弧三元组所对应的两个断点是否汇合为一点\\
 果真如此，则\\
 将对应的圆事件插入到事件队列Q 中，并\\
 在Q 中该节点和 T 中与之对应的节点之间设置指针，使它们相互指向对方\\
 (* 此前与α紧邻于右侧的那段弧，现也可能在某个新的邻接弧三元组中居中
*)\\
 对该弧，做类似的处理。

**** 算法复杂度



给定由平面上任意n 个基点构成的一个集合，其对应的
Voronoi图可以采用扫描线算法，在
O(nlogn)时间内、使用O(n)空间构造出来。因为Voronoi图可以归约为n个实数的排序问题，则最好时间复杂度为O(nlogn)，即sweep
line算法是最优的。

定义法：O(n\^2logn)，增量算法：O(n\^2)，分治法：O(nlogn)，sweep
line算法：O(nlogn)。

**** 参考

sweep line作者主页：[[http://ect.bell-labs.com/who/sjf/]]

数据结构说明：[[http://www.cescg.org/CESCG99/RCuk/]]

可视化界面演示：

[[http://www.in.tum.de/fileadmin/user_upload/Lehrstuehle/Lehrstuhl_XV/Teaching/Applets/applets/vis/voronoi/Fortune.html]]

* Computer Vision
** OpenCV                                                           :opencv:
*** TODO reference
*** OpenCV wiki

1. what?

   OpenCV的全称是Open Source Computer Vision Library，是一个跨平台的计
   算机视觉库。OpenCV是由英特尔公司发起并参与开发，以BSD许可证授权发行，
   可以在商业和研究领域中免费使用。OpenCV可用于开发实时的图像处理、计
   算机视觉以及模式识别程序。

2. 应用领域
   + 人机交互
   + 物体识别
   + 图像分区
   + 人脸识别
   + 动作识别
   + 运动跟踪
   + 机器人

3. 语言

   OpenCV用C++语言编写，它的主要接口也是C++语言，但是依然保留了大量的C
   语言接口。该库也有大量的Python, Java and MATLAB/OCTAVE (版本2.5)的
   接口。这些语言的API接口函数可以通过在线文档获得。现在也提供对于
   C#, Ch, Ruby的支持。

   所有新的开发和算法都是用C++接口。

4. 版本：2.4.11 2015/05/18

5. 参考网站
   + Wiki: http://zh.wikipedia.org/wiki/OpenCV
   + Home: http://sourceforge.net/projects/opencvlibrary/
   + Official wiki: http://opencvlibrary.sourceforge.net/
   + cn: http://www.opencv.org.cn/

*** OpencV howto
+ http://www.zhihu.com/question/20822510


1. 教材
   + 学习OpenCV:中文版
   + OpenCV2计算机视觉编程手册
   + OpenCV参考手册： http://wiki.opencv.org.cn/index.php/%E9%A6%96%E9%A1%B5
   + OpenCV Manual
   + 网络教程：http://blog.csdn.net/column/details/opencv-tutorial.html
   + OpenCV API：http://docs.opencv.org/modules/refman.html
   + OpenCV Tutorials: http://docs.opencv.org/doc/tutorials/tutorials.html

2. Tips
   + 多查官方文档，尤其现在OpenCV提供的方法函数越来越多，看书是远远不
     够的。书是拿来做个基本参考和入门，以及了解图像算法的基本原理。
   + 下载的opencv包里有英文文档，直接把opencv包全翻一遍，理解立马加深
   + 读OpenCV自带的tutorials：
     http://docs.opencv.org/doc/tutorials/tutorials.html
   + 学习OpenCV 2.4.3，不要先急着敲代码，应该要先把它的代码运行一遍，
     看看是什么结果。先知道运行结果，再逆向推导编程思路，最后看代码，
     分析代码，把每一个OpenCV类和函数的功能作用搞清楚，形成自己的思路，
     最后抛开原来的代码，按照自己的思路，把代码敲进去，这样才能实现消
     化吸收。

*** [[http://lanbing510.info/2014/12/03/Linux-Opencv.html][Linux下Opencv的安装及配置使用]]                       :install:blog_冰蓝:

冰蓝思考的地方

**** 安装


安装cmake及一些依赖库

#+BEGIN_EXAMPLE
    sudo apt-get install cmake
    sudo apt-get install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg.dev libtiff4.dev libswscale-dev libjasper-dev
#+END_EXAMPLE

安装opencv

从官网下载opencv并解压，cd命令进入opencv的目录

#+BEGIN_EXAMPLE
    cmake .
    sudo make
    sudo makeinstall
#+END_EXAMPLE

**** 配置

将opencv的库加入到路径，从而让系统可以找到

#+BEGIN_EXAMPLE
    sudo gedit /etc/ld.so.conf.d/opencv.conf
#+END_EXAMPLE

末尾加入/usr/local/lib，保存退出

#+BEGIN_EXAMPLE
    sudo ldconfig #使配置生效
#+END_EXAMPLE

编辑bash.bashrc

#+BEGIN_EXAMPLE
    sudo gedit /etc/bash.bashrc
#+END_EXAMPLE

末尾加入

#+BEGIN_EXAMPLE
    PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig
    export PKG_CONFIG_PATH
#+END_EXAMPLE

保存退出

#+BEGIN_EXAMPLE
    sudo source /etc/bash.bashrc  #使配置生效
    sudo updatedb #更新database
#+END_EXAMPLE

**** 测试使用


打开opencv2.4.9目录下的sample/c

#+BEGIN_EXAMPLE
    ./build
    ./build_all.sh
#+END_EXAMPLE

使用里面的一个sample进行测试，例如

#+BEGIN_EXAMPLE
    ./find_obj
#+END_EXAMPLE

以上。

*** opencv 入门
**** installation
+
  http://docs.opencv.org/doc/tutorials/introduction/linux_install/linux_install.html#linux-installation


1. Required Packages
   + GCC 4.4.x or later
   + CMake 2.6 or higher
   + Git
   + GTK+2.x or higher, including headers (libgtk2.0-dev)
   + pkg-config
   + Python 2.6 or later and Numpy 1.5 or later with developer packages (python-dev, python-numpy)
   + ffmpeg or libav development packages: libavcodec-dev, libavformat-dev, libswscale-dev
   + [optional] libtbb2 libtbb-dev
   + [optional] libdc1394 2.x
   + [optional] libjpeg-dev, libpng-dev, libtiff-dev, libjasper-dev,
     libdc1394-22-dev

2. geting source code
   + SourceForge: http://sourceforge.net/projects/opencvlibrary
   + git: git clone https://github.com/Itseez/opencv.git

3. Building: *CMake*
   #+BEGIN_EXAMPLE
     cd ~/opencv
     mkdir release
     cd release
     cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..
     make
     sudo make install
   #+END_EXAMPLE

**** 简单使用
+ http://docs.opencv.org/doc/tutorials/introduction/linux_gcc_cmake/linux_gcc_cmake.html#linux-gcc-usage

The easiest way of using OpenCV in your code is to use CMake. A few
advantages (taken from the Wiki):
+ No need to change anything when porting between Linux and Windows
+ Can easily be combined with other tools by CMake( i.e. Qt, ITK and
  VTK )


1. C++
   #+BEGIN_SRC cpp
     #include <stdio.h>
     #include <opencv2/opencv.hpp>

     using namespace cv;

     int main(int argc, char** argv )
     {
         if ( argc != 2 )
         {
             printf("usage: DisplayImage.out <Image_Path>\n");
             return -1;
         }

         Mat image;
         image = imread( argv[1], 1 );

         if ( !image.data )
         {
             printf("No image data \n");
             return -1;
         }
         namedWindow("Display Image", WINDOW_AUTOSIZE );
         imshow("Display Image", image);

         waitKey(0);

         return 0;
     }
   #+END_SRC

2. CMakeLists.txt
   #+BEGIN_EXAMPLE
     cmake_minimum_required(VERSION 2.8)
     project( DisplayImage )
     find_package( OpenCV REQUIRED )
     add_executable( DisplayImage DisplayImage.cpp )
     target_link_libraries( DisplayImage ${OpenCV_LIBS} )
   #+END_EXAMPLE

**** 模块架构(按目录组织)
+ http://blog.csdn.net/poem_qianmo/article/details/19925819


+ calib3d

  其实就是就是Calibration（校准）加3D这两个词的组合缩写。这个模块主要
  是相机校准和三维重建相关的内容。基本的多视角几何算法，单个立体摄像头
  标定，物体姿态估计，立体相似性算法，3D信息的重建等等。

+ contrib

  也就是Contributed/Experimental Stuf的缩写， 该模块包含了一些最近添加
  的不太稳定的可选功能，不用去多管。2.4.8里的这个模块有新型人脸识别，
  立体匹配，人工视网膜模型等技术。

+ core 核心功能模块，包含如下内容：
  + OpenCV基本数据结构
  + 动态数据结构
  + 绘图函数
  + 数组操作相关函数
  + 辅助功能与系统函数和宏
  + 与OpenGL的互操作


+ imgproc  Image和Processing这两个单词的缩写组合。图像处理模块，这个模
  块包含了如下内容：

  + 线性和非线性的图像滤波
  + 图像的几何变换
  + 其它（Miscellaneous）图像转换
  + 直方图相关
  + 结构分析和形状描述
  + 运动分析和对象跟踪
  + 特征检测
  + 目标检测等内容

+ features2d    也就是Features2D， 2D功能框架 ，包含如下内容：
  + 特征检测和描述
  + 特征检测器（Feature Detectors）通用接口
  + 描述符提取器（Descriptor Extractors）通用接口
  + 描述符匹配器（Descriptor Matchers）通用接口
  + 通用描述符（Generic Descriptor）匹配器通用接口
  + 关键点绘制函数和匹配功能绘制函数

+ flann

  Fast Library for Approximate Nearest Neighbors，高维的近似近邻快速搜索算法库，包含两个部分：
  + 快速近似最近邻搜索
  + 聚类

+ gpu 运用GPU加速的计算机视觉模块

+ highgui 也就是high gui，高层GUI图形用户界面，包含媒体的I / O输入输出，
  视频捕捉、图像和视频的编码解码、图形交互界面的接口等内容

+ legacy 一些已经废弃的代码库，保留下来作为向下兼容，包含如下相关的内容：
  + 运动分析
  + 期望最大化
  + 直方图
  + 平面细分（C API）
  + 特征检测和描述（Feature Detection and Description）
  + 描述符提取器（Descriptor Extractors）的通用接口
  + 通用描述符（Generic Descriptor Matchers）的常用接口
  + 匹配器

+ ml Machine Learning，机器学习模块， 基本上是统计模型和分类算法，包含如下内容：
  + 统计模型 （Statistical Models）
  + 一般贝叶斯分类器 （Normal Bayes Classifier）
  + K-近邻 （K-NearestNeighbors）
  + 支持向量机 （Support Vector Machines）
  + 决策树 （Decision Trees）
  + 提升（Boosting）
  + 梯度提高树（Gradient Boosted Trees）
  + 随机树 （Random Trees）
  + 超随机树 （Extremely randomized trees）
  + 期望最大化 （Expectation Maximization）
  + 神经网络 （Neural Networks）
  + MLData

+ nonfree 也就是一些具有专利的算法模块 ，包含特征检测和GPU相关的内容。
  最好不要商用，可能会被告哦。

+ objdetect 目标检测模块，包含Cascade Classification（级联分类）和
  Latent SVM这两个部分。

+ ocl 即OpenCL-accelerated Computer Vision，运用OpenCL加速的计算机视觉
  组件模块

+ photo 也就是Computational Photography，包含图像修复和图像去噪两部分

+ stitching images stitching，图像拼接模块，包含如下部分：
  + 拼接流水线
  + 特点寻找和匹配图像
  + 估计旋转
  + 自动校准
  + 图片歪斜
  + 接缝估测
  + 曝光补偿
  + 图片混合

+ superres SuperResolution，超分辨率技术的相关功能模块

+ ts opencv测试相关代码，不用去管他

+ video 视频分析组件，该模块包括运动估计，背景分离，对象跟踪等视频处理
  相关内容。

+ Videostab Video stabilization，视频稳定相关的组件，官方文档中没有多
  作介绍，不管它了。

**** 图像载入和显示
+ http://blog.csdn.net/poem_qianmo/article/details/20537737


对于OpenCV1.0时代的基于 C 语言接口而建的图像存储格式IplImage*，如果在
退出前忘记release掉的话，就会照成内存泄露。而且用起来超级麻烦，我们往
往在debug的时候，很大一部分时间在纠结手动释放内存的问题。虽然对于小型
的程序来说手动管理内存不是问题，但一旦我们写的代码变得越来越庞大，我们
便会开始越来越多地纠缠于内存管理的问题，而不是着力解决你的开发目标。这，
就有些舍本逐末的感觉了。


自从OpenCV踏入2.0时代，用 *Mat* 类数据结构作为主打之后，OpenCV变得越发
像需要很少编程涵养的Matlab那样，上手超级快。甚至有些函数名称都和matlab
一样，比如大家所熟知的imread，imwrite，imshow等函数。

1. 命名空间：cv

2. Mat

   cv::Mat类是用于保存图像以及其他矩阵数据的数据结构。默认情况下，其尺
   寸为0，我们也可以指定初始尺寸,比如，比如定义一个Mat类对象，就要写
   cv::Mat pic(320,640,cv::Scalar(100));

3. 载入: *Mat imread(const string& filename, intflags=1 )*
   + 支持图像类型
     - Windows位图 - *.bmp, *.dib
     - JPEG文件 - *.jpeg, *.jpg, *.jpe
     - JPEG 2000文件- *.jp2
     - PNG图片 - *.png
     - 便携文件格式- *.pbm, *.pgm, *.ppm
     - Sun rasters光栅文件 - *.sr, *.ras
     - TIFF 文件 - *.tiff, *.tif
   + const string&类型的filename，填我们需要载入的图片路径名
   + int类型的flags，为载入标识，它指定一个加载图像的颜色类型
     - 定义(higui_c.h)
       #+BEGIN_EXAMPLE
         enum
         {
         /* 8bit, color or not */
            CV_LOAD_IMAGE_UNCHANGED  =-1,
         /* 8bit, gray */
            CV_LOAD_IMAGE_GRAYSCALE  =0,
         /* ?, color */
            CV_LOAD_IMAGE_COLOR      =1,
         /* any depth, ? */
            CV_LOAD_IMAGE_ANYDEPTH   =2,
         /* ?, any color */
            CV_LOAD_IMAGE_ANYCOLOR   =4
         };
       #+END_EXAMPLE

     - CV_LOAD_IMAGE_UNCHANGED，这个标识在新版本中被废置了，忽略。
     - CV_LOAD_IMAGE_ANYDEPTH- 如果取这个标识的话，若载入的图像的深度
       为16位或者32位，就返回对应深度的图像，否则，就转换为8位图像再返
       回。
     - CV_LOAD_IMAGE_COLOR- 如果取这个标识的话，总是转换图像到彩色一体
     - CV_LOAD_IMAGE_GRAYSCALE- 如果取这个标识的话，始终将图像转换成灰度1
     - 位的或运算

4. 创建窗口: *void namedWindow(const string& winname,int
   flags=WINDOW_AUTOSIZE )*
   + 第一个参数，const string&型的name，即填被用作窗口的标识符的窗口名称。
   + 第二个参数，int 类型的flags ，窗口的标识，可以填如下的值：
     - WINDOW_NORMAL设置了这个值，用户便可以改变窗口的大小（没有限制）
     - WINDOW_AUTOSIZE如果设置了这个值，窗口大小会自动调整以适应所显示
       的图像，并且不能手动改变窗口大小。
     - WINDOW_OPENGL 如果设置了这个值的话，窗口创建的时候便会支持
       OpenGL。

5. 显示图片  *void imshow(const string& winname, InputArray mat)*
   + 第一个参数，const string&类型的winname，填需要显示的窗口标识名称。
   + 第二个参数，InputArray 类型的mat，填需要显示的图像。

6. 输出图像 *bool imwrite(const string& filename,InputArray img, const
   vector<int>& params=vector<int>() )*
   + 第一个参数，const string&类型的filename，填需要写入的文件名就行了，
     带上后缀，比如，“123.jpg”这样。
   + 第二个参数，InputArray类型的img，一般填一个Mat类型的图像数据就行
     了。
   + 第三个参数，const vector<int>&类型的params，表示为特定格式保存的
     参数编码，它有默认值vector<int>()，所以一般情况下不需要填写。

7. 小结
   + Mat
   + imread
   + namewindow
   + imshow
   + imwrite

*** intro
**** Wiki

-  *what*

  *OpenCV* 的全称是 *Open Source Computer Vision Library* ，是一个 *跨
  平台* 的 *计算机视觉库* 。OpenCV是由英特尔公司发起并参与开发，以
  *BSD许可证* 授权发行，可以在商业和研究领域中免费使用。OpenCV可用于开
  发 *实时的图像处理* 、 *计算机视觉* 以及 *模式识别* 程序。该程序库也
  可以使用英特尔公司的IPP进行加速处理。

-  *History*

   OpenCV项目最早由英特尔公司于1999年启动，致力于CPU密集型的任务，是一
   个包括如光线追踪和3D显示的计划的一部分。早期OpenCV的主要目标是

     -  为推进机器视觉的研究，提供一套开源且优化的基础库。 *不重复发明
       轮子* 。

     -  提供一个共同的基础库，使得开发人员的代码更容易阅读和转让，促进了知识的传播。

     -  通过提供一个不需要开源或免费的软件许可，促进商业应用软件的开发。

     -  OpenCV现在也集成了对CUDA的支持.

-  *语言支持*

   OpenCV用C++语言编写，它的  *主要接口也是C++语言，但是依然保留了大量
   的C语言接口* 。该库也有大量的 *Python* , Java and MATLAB/OCTAVE
   (版本2.5)的接口。这些语言的API接口函数可以通过在线文档获得。现在也提供对于C#,
   Ch, Ruby的支持。

-  *跨平台*

   OpenCV可以在Windows, Android, Maemo, FreeBSD, OpenBSD, iOS,
   *Linux* 和 Mac OS等平台上运行。用户可以在SourceForge获得官方版本，
   或者从SVN获得开发版本。OpenCV也是用 *CMake* .

**** Homepage

-  网址:    [[http://opencv.org/]]

-  *Introdution*

   OpenCV is released under a *BSD* license and hence it's free for
   both academic and commercial use. It has *C++*, *C*, *Python* and
   Java interfaces and supports Windows, *Linux*, Mac OS, iOS and
   Android. OpenCV was designed for *computational efficiency* and
   with a strong focus on *real-time* applications. Written in
   optimized C/C++, the library can take advantage of *multi-core*
   processing. Enabled with *OpenCL*, it can take advantage of the
   hardware acceleration of the underlying heterogeneous compute
   platform. Adopted all around the world, OpenCV has more than 47
   thousand people of user community and estimated number of
   downloads exceeding 9 million. Usage ranges from interactive art,
   to mines inspection, stitching maps on the web or through advanced
   *robotics*.

-  *Documentation*
   [[http://docs.opencv.org/]][[http://docs.opencv.org/][ ]]

-  *Tutorial*
   [[http://docs.opencv.org/doc/tutorials/tutorials.html]]

-  *Forum*
   [[http://answers.opencv.org/questions/]]

**** Reference

-  *中文论坛*

   -  [[http://www.opencv.org.cn/]]

-  *教材*

   -  学习OpenCV

      -  BUAALIB:[[http://202.112.134.140:8080/opac/item.php?marc_no=0001197557]]
      -  Amazon:[[http://www.amazon.com/Learning-OpenCV-Computer-Vision-Library/dp/0596516134]]
      -  中文PDF：链接: http://pan.baidu.com/s/1o6KjTY6 密码: xn4q
      -  英文PDF: 链接: http://pan.baidu.com/s/1o6zlj66 密码: anda

   -  OpenCV Cookbook

      -  Amazon:[[http://www.amazon.com/OpenCV-Computer-Application-Programming-Cookbook/dp/1849513244][http://www.amazon.com/OpenCV-Computer-Application-Programming-Cookbook/dp/1849513244]]

-  *网络教程*

   -  CSDN:[[http://blog.csdn.net/column/details/opencv-tutorial.html]]
   -  [[http://wiki.opencv.org.cn/index.php/%E9%A6%96%E9%A1%B5]]

**** 前车之鉴
   1. 《学习OpenCV》这本书能更多了解图像处理的原理，对于用opencv来做图
      像处理编程的人来说必不可少，时时翻阅。小缺点是基于1.0版本的，代
      码有些过时了。

   2. 《OpenCV2计算机视觉编程手册》，虽然没有《学习OpenCV》那么经典，
      但是值得参考和学习，和《学习OpenCV》一样，是使用opencv工作的必买
      书籍。

   3. 关于学习数字图像处理，那最能讲原理的是老冈的《数字图像处理》，我
      认为也是必买，没事时就翻着看看。

   4. 当然最好的文档莫过于OpenCV的源代码和文档，并且稍微旧的版本官方文
      档也有中文的，接口变化并不大。已经提供了非常丰富的例子。

   建议：OpenCV没有几本书，前面三本书都我认为是必买，多查官方文档，尤
   其现在OpenCV提供的方法函数越来越多，看书是远远不够的。书是拿来做个
   基本参考和入门，以及了解图像算法的基本原理。遇到问题，能看书就看书，
   书上没有的，就百度吧学习和使用OpenCV的人非常多的。

** 图像处理
*** [[http://lanbing510.info/2014/12/18/License-Plate-Detection-Recognition.html][车牌检测及识别 OpenALPR]]                                     :blog_冰蓝:

冰蓝思考的地方

**** 写在前面

最近项目需要，搞起了车牌检测及识别，进行了理论方法的调研和代码的实践，最终检测识别的效果还是很不错的。下面是相应的一些记录。

**** 车牌检测及识别的理论方法


一、检测的基本方法

1. 用边缘检测+轮廓提取+车牌特征进行车牌的检测；

2. 用Harr-like特征或者LBP特征+Adaboost来训练模板用于车牌的检测；还有用
   神经网络训练的；

3. 两者结合。

二、识别的基本方法

1. 用Tesseract.来进行训练；

2. 用车牌上的字符直接训练识别器。

**** 车牌检测的代码实践

自己网上搜到了一个非常不错的车牌自己识别的开源项目：[[https://github.com/openalpr/openalpr][OpenALPR]]，在其基础上进行的实践。

配置时的一些注意事项：

一、最好用在Ubuntu14.04下进行配置

自己最早是在自己Ubuntu12.04的系统下进行的编译，出现两个错误：一个是有
关string赋值为null的；另外一个是头文件少包含的（ocr.h里面进行了添加）。
进行修复后，编译完发现效果和作者网上的demo相差很远，看作者的论坛，说肯
能是软件版本不一致（想不通版本不一致能差这么远）。于是对系统进行了升级，
升到了和作者一致的Ubuntu14.04环境，解决了问题。

二、Windows下配置的时候注意需要修改CMakeList和匹配相应的Opencv版本。

编译安装完成后，就可以阅读源码，修改代码，进行各种应用了。

**** 小注

阅读和修改源码时强烈推荐Sublime Text，各种爽歪歪。

* progress



* project
