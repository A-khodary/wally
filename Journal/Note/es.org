# es.org --- containing notes on embedded system

* Develop Tools
** overview
*** Linux下嵌入式开发工具

1. 编辑

   - Emacs是不二之选

2. 编译

   - 51: sdcc
   - avr: avrgcc
   - arm: gcc工具链

3. 烧录

   - 51: ASEM51
   - avr: avrdude
   - arduino: arduino IDE
   - ARM: OpenOcd
   - DSP(TI): CCS

4. 调试： 同上

5. 仿真： 暂时用不到

6. 电路设计： eagle

*** linux 51 开发                                                      :51:

http://andyhuzhill.github.io/html/shaolu.html
http://forum.ubuntu.org.cn/viewtopic.php?f=97&t=327501
https://www.google.com/?gws_rd=ssl#q=linux+51+%e7%83%a7%e5%bd%95

linux下做单片机必然是没有问题的, 有问题的是windows在中国一统天下.

引用豆瓣的话, stc是一家垃圾的公司。下载协议没有公开，所以，下载器不好
做。

经典的51(at89s52)单片机为何不用, 资料又丰富.

*** Linux 下 AVR 开发环境                                             :avr:

- [[https://app.yinxiang.com/Home.action#n=9c09ae6a-512d-42b1-a8b0-731e9bba8e7f&ses=1&sh=5&sds=5&x=avrdude&][Linux 下 AVR 开发环境搭建]]
- [[http://www.atmel.com/webdoc/AVRLibcReferenceManual/index.html][Atmel: AVR Libc Reference Manual]]


gcc-avr + avr-libc + binutils-avr + avrdude + usbisp

1) MCU: Atmega16
2) 编辑器： Emacs
3) 编译器： gcc-avr
4) 编程器： avrdude
5) 下载器： usbasp
6) 仿真： [[http://savannah.nongnu.org/projects/simulavr/][simulavr]]
7) 调试： avr-gdb, [[http://sourceforge.net/projects/avarice/][AvaRICE]]

#+BEGIN_EXAMPLE
  1 $ avr-
  avr-addr2line   avr-g++         avr-gprof       avr-ranlib
  avr-ar          avr-gcc         avr-ld          avr-readelf
  avr-as          avr-gcc-4.8.1   avr-ld.bfd      avr-size
  avr-c++         avr-gcc-ar      avr-man         avr-strings
  avr-c++filt     avr-gcc-nm      avr-nm          avr-strip
  avr-cpp         avr-gcc-ranlib  avr-objcopy
  avr-elfedit     avr-gcov        avr-objdump
#+END_EXAMPLE

*** ARM IDE                                                           :ide:
**** emide

http://www.emide.org/

**** eclispe                                                     :eclipse:

http://blog.csdn.net/cxw3506/article/details/8292331

1. eclipse: eclipse的本身只是一个框架平台，但是众多插件的支持，使得
   eclipse拥有较好的灵活性。

2. cdt: cdt是eclipse用于扩展eclipse支持c/c++开发的插件。

3. zylin cdt: 支持eclipse用于嵌入式c/c++开发和远程调试的插件

4. yagarto:  yagarto整合了gnu arm的交叉编译工具链，是一个跨平台的 arm
   架构开发平台，是一个 eclipse 的插件。

5. j-link gdb server:  a jtag gdb debug agent run on host

**** ARM Crop

+ rvds
+ ads
+ arm ds development studio

**** keil uvision

**** 小结

ARM IDE 使用 ECLISPE

** avrlibc                                                     :avrlibc:avr:

*** reference                                                    :homepage:

- [[http://www.nongnu.org/avr-libc/][AVR Libc Homepage]]
- [[~/Wally/Reference/Manual/AvrLibcUserManual-1.8.0.pdf][AvrLibcUserManual-1.8.0.pdf]]

*** overview

/AVR Libc/ is a *Free Software* project whose goal is to
_provide a high quality C library for use with GCC on Atmel AVR
microcontrollers_.

Together, /avr-binutils/, /avr-gcc/, and /avr-libc/ form the heart of
the Free Software toolchain for the Atmel AVR microcontrollers.

They are further accompanied by projects for in-system programming
software (/avrdude/), simulation (/simulavr/) and debugging
(/avr-gdb/, AVaRICE).

*** installation                                                    :install:

1. download page: http://download.savannah.gnu.org/releases/avr-libc/

   version: 1.8.1

2. compile

   #+BEGIN_EXAMPLE
   $ ./configure --build=`./config.guess` --host=avr
   #+END_EXAMPLE

   error: avrgcc, 不玩了

   #+BEGIN_EXAMPLE
     configure: error: Wrong C compiler found; check the PATH!
   #+END_EXAMPLE

3. 新得立： 1.8.0

   依赖： gcc-avr, binutils-avr

** avrdude                                                     :avrdude:avr:
*** reference

+ [[http://www.nongnu.org/avrdude/][homepage]]
+ [[~/Wally/Reference/Manual/AvrdudeManual.pdf][AvrdudeManual.pdf]]

*** overview

**** what?

*AVRDUDE* is an utility to *download/upload/manipulate* the ROM and
EEPROM contents of AVR microcontrollers using the in-system
programming technique (*ISP*).

简言之， *AVR在线烧录*

**** features

1. 命令行 -> 自动化，makefile
2. terminal mode
3. 跨平台
4. 支持多烧录器, ISP/JTag/Serial
5. 支持多种格式，hex/bin

**** installation                                                :install:

1. download page: http://download.savannah.gnu.org/releases/avrdude/

   version: 6.2

2. compile

   #+BEGIN_EXAMPLE
   $ ./configure & make & make install
   #+END_EXAMPLE

*** usage
**** help                                                           :help:

#+BEGIN_EXAMPLE
  Usage: avrdude [options]
  Options:
    -p <partno>                Required. Specify AVR device.
    -b <baudrate>              Override RS-232 baud rate.
    -B <bitclock>              Specify JTAG/STK500v2 bit clock period (us).
    -C <config-file>           Specify location of configuration file.
    -c <programmer>            Specify programmer type.
    -D                         Disable auto erase for flash memory
    -i <delay>                 ISP Clock Delay [in microseconds]
    -P <port>                  Specify connection port.
    -F                         Override invalid signature check.
    -e                         Perform a chip erase.
    -O                         Perform RC oscillator calibration (see AVR053).
    -U <memtype>:r|w|v:<filename>[:format]
                               Memory operation specification.
                               Multiple -U options are allowed, each request
                               is performed in the order specified.
    -n                         Do not write anything to the device.
    -V                         Do not verify.
    -u                         Disable safemode, default when running from a script.
    -s                         Silent safemode operation, will not ask you if
                               fuses should be changed back.
    -t                         Enter terminal mode.
    -E <exitspec>[,<exitspec>] List programmer exit specifications.
    -x <extended_param>        Pass <extended_param> to programmer.
    -y                         Count # erase cycles in EEPROM.
    -Y <number>                Initialize erase cycle # in EEPROM.
    -v                         Verbose output. -v -v for more.
    -q                         Quell progress output. -q -q for less.
    -l logfile                 Use logfile rather than stderr for diagnostics.
    -?                         Display this usage.
#+END_EXAMPLE
**** example

$ sudo avrdude -p 8052 -c usbasp -e -U flash:w:'跑马灯.hex'

#+BEGIN_SRC makefile
  main：
      sdcc liushui.c
      # SDCC默认的输出格式是ihx 我们把它转换成hex
      packihx liushui.ihx>liushui.hex
      sudo avrdude -p 8052 -c usbasp -e -U flash:w:liushui.hex
#+END_SRC

*** configure                                                   :configure:

#+include: /etc/avrdude.conf

**** programmer(编程器)
***** list

#+BEGIN_EXAMPLE
  $ avrdude -c foo                # a little tricky

  avrdude: Can't find programmer id "foo"

  Valid programmers are:
    2232HIO          = FT2232H based generic programmer
    4232h            = FT4232H based generic programmer
    89isp            = Atmel at89isp cable
    abcmini          = ABCmini Board, aka Dick Smith HOTCHIP
    alf              = Nightshade ALF-PgmAVR, http://nightshade.homeip.net/
    arduino          = Arduino

#+END_EXAMPLE

***** format example

#+BEGIN_EXAMPLE
#   programmer
#       parent <id>                                 # optional parent
#       id       = <id1> [, <id2> [, <id3>] ...] ;  # <idN> are quoted strings
#       desc     = <description> ;                  # quoted string
#       type     = <type>;                          # programmer type, quoted string
#                          # supported programmer types can be listed by "-c ?type"
#       connection_type = parallel | serial | usb
#       baudrate = <num> ;                          # baudrate for avr910-programmer
#       vcc      = <num1> [, <num2> ... ] ;         # pin number(s)
#       buff     = <num1> [, <num2> ... ] ;         # pin number(s)
#       reset    = <num> ;                          # pin number
#       sck      = <num> ;                          # pin number
#       mosi     = <num> ;                          # pin number
#       miso     = <num> ;                          # pin number
#       errled   = <num> ;                          # pin number
#       rdyled   = <num> ;                          # pin number
#       pgmled   = <num> ;                          # pin number
#       vfyled   = <num> ;                          # pin number
#       usbvid   = <hexnum>;                        # USB VID (Vendor ID)
#       usbpid   = <hexnum>;                        # USB PID (Product ID)
#       usbdev   = <interface>;                     # USB interface or other device info
#       usbvendor = <vendorname>;                   # USB Vendor Name
#       usbproduct = <productname>;                 # USB Product Name
#       usbsn    = <serialno>;                      # USB Serial Number
#
#        To invert a bit, use = ~ <num>, the spaces are important.
#        For a pin list all pins must be inverted.
#        A single pin can be specified as usual = ~ <num>, for lists
#        specify it as follows = ~ ( <num> [, <num2> ... ] ) .
#     ;
#+END_EXAMPLE

**** part
***** format

#+BEGIN_EXAMPLE
  #   part
  #       id               = <id> ;                 # quoted string
  #       desc             = <description> ;        # quoted string
  #       has_jtag         = <yes/no> ;             # part has JTAG i/f
  #       has_debugwire    = <yes/no> ;             # part has debugWire i/f
  #       has_pdi          = <yes/no> ;             # part has PDI i/f
  #       has_tpi          = <yes/no> ;             # part has TPI i/f
  #       devicecode       = <num> ;            # deprecated, use stk500_devcode
  #       stk500_devcode   = <num> ;                # numeric
  #       avr910_devcode   = <num> ;                # numeric
  #       signature        = <num> <num> <num> ;    # signature bytes
  #       chip_erase_delay = <num> ;                # micro-seconds
  #       reset            = dedicated | io;
  ...
#+END_EXAMPLE

***** At89S52(测试没有成功)                                         :at89s52:

+ http://www.avrfreaks.net/forum/writing-at89s52-through-usbasp

Avrdude默认配置中没有用于烧写51单片机的target对象，需要自己配置。

#+BEGIN_EXAMPLE
#------------------------------------------------------------
# Below chips by added by me .. Joy Shukla(joy_shukla@yahoo.in)
# these chips can be programmed with my usbasp programmer(changed atmega8 program)
# after adding avrdude support in this file ..
#------------------------------------------------------------

#------------------------------------------------------------
# AT89S52
#------------------------------------------------------------
part
    id               = "8052";
    desc             = "AT89S52";
    signature        = 0x1E 0x52 0x06;
    chip_erase_delay = 20000;
    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                       "x x x x  x x x x    x x x x  x x x x";

    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                       "x x x x  x x x x    x x x x  x x x x";

    timeout      = 200;
    stabdelay      = 100;
    cmdexedelay      = 25;
    synchloops      = 32;
    bytedelay      = 0;
    pollindex      = 3;
    pollvalue      = 0x53;
    predelay      = 1;
    postdelay      = 1;
    pollmethod      = 0;

    memory "flash"
        size            = 8192;
        paged           = no;
        min_write_delay = 4000;
        max_write_delay = 9000;
        readback_p1     = 0xff;
        readback_p2     = 0xff;
        read            = "  0   0   1   0    0   0   0   0",
                          "  x   x   x a12  a11 a10  a9  a8",
                          " a7  a6  a5  a4   a3  a2  a1  a0",
                          "  o   o   o   o    o   o   o   o";

        write           = "  0   1   0   0    0   0   0   0",
                          "  x   x   x a12  a11 a10  a9  a8",
                          " a7  a6  a5  a4   a3  a2  a1  a0",
                          "  i   i   i   i    i   i   i   i";
   mode      = 0x21;
   delay      = 12;
      ;

    memory "signature"
        size            = 3;
        read            = "0  0  1  0   1  0  0  0   x  x  x  0   0  0 a1 a0",
                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
      ;
  ;
#+END_EXAMPLE

*** test
**** 自定义 ISP/ASP

1. 参考: programmer usbasp & usbasp-clone

2. benusp

   #+BEGIN_EXAMPLE
     programmer
       id    = "benisp";
       desc  = "Any usbasp clone with correct VID/PID";
       type  = "usbasp";
       connection_type = usb;
       usbvid    = 0x03eb; # VOTI
       usbpid    = 0xc8b4; # Obdev's free shared PID
       #usbvendor  = "";
       #usbproduct = "";
     ;
   #+END_EXAMPLE

3. test(not work)

   #+BEGIN_EXAMPLE
     Ardude $ avrdude -p 8052 -c benasp

     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted
     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted
     avrdude: warning: cannot set sck period. please check for usbasp firmware update.
     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted
     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted
     avrdude: error: programm enable: target doesn't answer. 0
     avrdude: initialization failed, rc=-1
              Double check connections and try again, or use -F to override
              this check.

     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted

     avrdude done.  Thank you.

     Ardude $ sudo avrdude -p 8052 -c benasp

     avrdude: warning: cannot set sck period. please check for usbasp firmware update.
     avrdude: error: programm enable: target doesn't answer. 0
     avrdude: initialization failed, rc=-1
              Double check connections and try again, or use -F to override
              this check.
   #+END_EXAMPLE

   1. 权限
   2. 配置不对

**** ISP测试

接入 USB ISP 后的反应

#+BEGIN_EXAMPLE
Ardude $ lsusb
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
...

Ardude $ lsusb
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
...
Bus 003 Device 003: ID 03eb:c8b4 Atmel Corp.
#+END_EXAMPLE

clk
#+BEGIN_EXAMPLE
   $ sudo avrdude -p 8052 -c benisp

  avrdude: warning: cannot set sck period. please check for usbasp firmware update.
  avrdude: error: programm enable: target doesn't answer. 0
  avrdude: initialization failed, rc=-1
           Double check connections and try again, or use -F to override
           this check.


  avrdude done.  Thank you.
#+END_EXAMPLE

/Warning 只是警告，不是错误/

#+BEGIN_EXAMPLE
avrdude: warning: cannot set sck period. please check for usbasp
firmware update.
#+END_EXAMPLE

**** usbasp测试

***** [[https://detail.tmall.com/item.htm?id=44102479119&spm=a1z09.2.0.0.Qt1XKV&_u=9mb80en1c47][Taobao上有一些资料]]

atmega8a
[[~/Wally/Journal/Figure/scrot/2472pvk.png]]

1.支持AT89S51/52单片机
2.支持AVR所有ASP芯片。
3.输出端口为ATMEL标准端口。
4.有USB取电和目标板支持目标电压5V，可通过跳线帽连接选择。
5.可AUTOSPEED 自动调速固件，下载器会自动跟踪要编程的芯片频率，自动改变速度，达到自动调速。
6.预留 MOSI，MISO，RET，SCK，VCC，GND。 6PIN接口，方便使用者根据需要连接目标板。

7.预留 PROGRAMMING 编程接口，用户可自行升级下载器固件。

编程软件：AVR_fighter,PROGISP1.66,PROGISP1.67,PROGISP1.68编译更低或者
更高软件都行、烧片一气呵成，非常方便。

支持烧写的芯片：

1. 51系列

   + AT89S51
   + AT89S52
   + AT89S53
   + AT89S8253
   + AT89S2051
   + AT89S8252
   + AT89S4051

2. AVR系列

   #+BEGIN_EXAMPLE
     AT90can128 AT90can32

     AT90can64, AT90pwm2, AT90pwm3, AT90s1200, AT90s2313, AT90s2323,
     AT90s2343, AT90s4414, AT90S8515, AT90S8535,  AT90usb1286, AT90usb1287

     Atmega103, Atmega128, Atmega1280, Atmega1281, Atmega16, Atmega161,
     Atmega162, Atmega163, Atmega164, Atmega165, Atmega168, Atmega169,
     Atmega2560, Atmega2561, Atmega32, Atmega323, Atmega324, Atmega325,
     Atmega3250, Atmega3259, Atmega328, Atmega329, Atmega3290, Atmega406,
     Atmega48, Atmega64, Atmega640, Atmega644, Atmega645, Atmega6450,
     Atmega649, Atmega6490, Atmega8, Atmega8515, Atmega8535, Atmega88,


     Attiny11, Attiny12, Attiny13 , Attiny15, Attiny22, Attiny2313,
     Attiny24,Attiny25, Attiny26, Attiny261,  Attiny28, Attiny44,
     Attiny45, Attiny46, Attiny46, Attiny84, Attiny85, Attiny861
   #+END_EXAMPLE

[[~/Wally/Journal/Figure/scrot/247225q.png]]

***** 虚拟机中测试

装驱动：51开发板的资料中有，可以用。

烧录软件: /progisp/

[[~/Wally/Journal/Figure/scrot/2472CYG.png]]

***** Ubuntu中测试

1. usbasp 连接没有问题

2. lsusb 显示的 设备ID与产商ID 与 avrdude 配置文件中的 usbasp-clone 一
   致

3. error

   #+BEGIN_EXAMPLE
     $ sudo avrdude -c usbasp-clone -p 8052

     avrdude: warning: cannot set sck period. please check for usbasp firmware update.
     avrdude: error: programm enable: target doesn't answer. 1
     avrdude: initialization failed, rc=-1
              Double check connections and try again, or use -F to override
              this check.
   #+END_EXAMPLE

***** usbasp可以给单片机供电

*** Arduino 也可以作为编程器(programmer)                          :arduino:

+ http://openrcforums.com/forum/viewtopic.php?f=10&t=1363#p29615
+
  http://blackstufflabs.com/2013/10/24/aggiornare-firmware-usbasp-con-arduino/?lang=zh

*** [[http://blog.zakkemble.co.uk/avrdudess-a-gui-for-avrdude/][avrdudess]]: a GUI for avrdude :avrdude:avrdudess:

1. 直接运行 exe 文件

2. Linux 下使用 /Mono/

   1) Install Mono

      #+BEGIN_EXAMPLE
      # (this is the minimum required, you can do mono-complete for a full install)
      sudo apt-get install libmono-winforms2.0-cil
      #+END_EXAMPLE

   2) Install AVRDUDE

      #+BEGIN_EXAMPLE
      sudo apt-get install avrdude
      #+END_EXAMPLE

   3) Run AVRDUDESS with Mono

      #+BEGIN_EXAMPLE
      mono avrdudess.exe
      #+END_EXAMPLE

      you might have to run as root (/sudo/) so avrdude runs as root
      if you havn’t changed any rules.d stuff

*** AVR Atmega16

#+BEGIN_EXAMPLE
   $ sudo avrdude -p m16 -c usbasp -e
  [sudo] password for ben:

  avrdude: warning: cannot set sck period. please check for usbasp firmware update.
  avrdude: AVR device initialized and ready to accept instructions

  Reading | ################################################## | 100% 0.01s

  avrdude: Device signature = 0x1e9403
  avrdude: erasing chip
  avrdude: warning: cannot set sck period. please check for usbasp firmware update.

  avrdude: safemode: Fuses OK (H:FF, E:99, L:E1)

  avrdude done.  Thank you.

#+END_EXAMPLE

OK,  warning not errors.

** Cross Tool                                                    :crosstool:
*** Introduction

1. 交叉编译

    *交叉编译* 通俗地讲就是在一种平台上编译出能运行在体系结构不同的另
   一种平台上的程序。

    比如在PC平台（X86 CPU）上编译出能运行在以ARM为内核的CPU平台上的程
   序，编译得到的程序在X86 CPU平台上是不能运行的，必须放到ARM CPU平台
   上才能运行，虽然两个平台用的都是Linux系统。

2. 本地编译

   相对与交叉编译，平常做的编译叫 *本地编译* ，也就是在当前平台编译，
   编译得到的程序也是在本地执行。

   用来编译这种跨平台程序的编译器就叫交叉编译器，相对来说，用来做本地
   编译的工具就叫本地编译器。

3. why

   在裁减和定制Linux内核用于嵌入式系统之前，由于一般嵌入式开发系统存储
   大小有限，通常都要在性能优越的PC上建立一个用于目标机的交叉编译工具
   链，用该交叉编译工具链在PC上编译目标机上要运行的程序。

4. 交叉编译工具链

   *交叉编译工具链* 是一个由编译器、连接器和解释器组成的综合开发环境。

   交叉编译工具链主要由binutils、gcc和glibc 3个部分组成。有时出于减小
   libc 库大小的考虑，也可以用别的 c 库来代替 glibc，例如 uClibc、
   dietlibc 和 newlib。

*** 构建ARM Linux交叉编译工具链

http://imkongguxiaoren.blog.51cto.com/488693/101897

建立交叉编译工具链是一个相当复杂的过程，如果不想自己经历复杂繁琐的编译
过程，网上有一些编译好的可用的交叉编译工具链可以下载，但就以学习为目的
来说读者有必要学习自己制作一个交叉编译工具链。

1. 目标平台

   构建交叉编译器的第一个步骤就是确定目标平台。

   在GNU系统中，每个目标平台都有一个明确的格式，这些信息用于在构建过程
   中识别要使用的不同工具的正确版本。因此，当在一个特定目标机下运行GCC
   时，GCC便在目录路径中查找包含该目标规范的应用程序路径。GNU的目标规
   范格式为 *CPU-PLATFORM-OS* 。例如x86/i386 目标机名为
   i686-pc-linux-gnu。本章的目的是讲述建立基于ARM平台的交叉工具链，所
   以目标平台名为arm-linux-gnu。

2. 方法

   通常构建交叉工具链有3种方法。

   1) 分步编译和安装交叉编译工具链所需要的库和源代码，最终生成交叉编译
      工具链。该方法相对比较困难，适合想深入学习构建交叉工具链的读者。
      如果只是想使用交叉工具链，建议使用方法二或方法三构建交叉工具链。

   2) 通过Crosstool脚本工具来实现一次编译生成交叉编译工具链，该方法相
      对于方法一要简单许多，并且出错的机会也非常少，建议大多数情况下使
      用该方法构建交叉编译工具链。

   3) 直接通过网上（ftp.arm.kernel.org.uk）下载已经制作好的交叉编译工
      具链。该方法的优点不用多说，当然是简单省事，但与此同时该方法有一
      定的弊端就是局限性太大，因为毕竟是别人构建好的，也就是固定的没有
      灵活性，所以构建所用的库以及编译器的版本也许并不适合你要编译的程
      序，同时也许会在使用时出现许多莫名的错误，建议读者慎用此方法。

*** 分步构建交叉编译链

1. 下载安装包
   + linux-2.6.10.tar.gz   ftp.kernel.org
   + glibc-2.3.2.tar.gz    ftp.gnu.org
   + binutils-2.15.tar.bz2 ftp.gnu.org
   + glibc-linuxthreads-2.3.2.tar.gz ftp.gnu.org
   + gcc-3.3.6.tar.gz      ftp.gnu.org

2. 建立工作目录

   首先建立工作目录，工作目录就是在什么目录下构建交叉工具链，目录的构
   建一般没有特别的要求，可以根据个人喜好建立。

   再在这个工作目录armlinux下建立3个目录 build-tools、kernel 和 tools。
   #+BEGIN_EXAMPLE
   mkdir build-tools kernel tools
   #+END_EXAMPLE

   其中各目录的作用如下。
   + build-tools 用来存放下载的binutils、gcc、glibc等源代码和用来编译
     这些源代码的目录；
   + kernel 用来存放内核源代码；
   + tools 用来存放编译好的交叉编译工具和库文件。

3. 建立环境变量

   该步骤的目的是为了方便重复输入路径，因为重复操作每件相同的事情总会
   让人觉得很麻烦。声明以下环境变量的目的是在之后编译工具库的时候会用
   到，很方便输入，尤其是可以降低输错路径的风险。

   #+BEGIN_EXAMPLE
     # export PRJROOT=/path/to/armlinux
     # export TARGET=arm-linux
     # export PREFIX=$PRJROOT/tools
     # export TARGET_PREFIX=$PREFIX/$TARGET
     # export PATH=$PREFIX/bin:PATH
   #+END_EXAMPLE

4. 编译、安装Binutils

   Binutils 是GNU工具之一，它包括连接器、汇编器和其他用于目标文件和档
   案的工具，它是二进制代码的处理维护工具。安装Binutils工具包含的程序
   有 addr2line、ar、as、c++filt、gprof、ld、nm、objcopy、objdump、
   ranlib、readelf、size、 strings、strip、libiberty、libbfd和
   libopcodes。对这些程序的简单解释如下。

   + addr2line 把程序地址转换为文件名和行号。在命令行中给它一个地址和
     一个可执行文件名，它就会使用这个可执行文件的调试信息指出在给出的
     地址上是哪个文件以及行号。
   + ar 建立、修改、提取归档文件。归档文件是包含多个文件内容的一个大文
     件，其结构保证了可以恢复原始文件内容。
   + as 主要用来编译GNU C编译器gcc输出的汇编文件，产生的目标文件由连接
     器ld连接。
   + c++filt 连接器使用它来过滤 C++ 和 Java 符号，防止重载函数冲突。
   + gprof 显示程序调用段的各种数据。
   + ld 是连接器，它把一些目标和归档文件结合在一起，重定位数据，并连接
     符号引用。通常，建立一个新编译程序的最后一步就是调用ld。
   + nm 列出目标文件中的符号。
   + objcopy 把一种目标文件中的内容复制到另一种类型的目标文件中。
   + objdump 显示一个或者更多目标文件的信息。使用选项来控制其显示的信
     息，它所显示的信息通常只有编写编译工具的人才感兴趣。
   + ranlib 产生归档文件索引，并将其保存到这个归档文件中。在索引中列出
     了归档文件各成员所定义的可重分配目标文件。
   + readelf 显示elf格式可执行文件的信息。
   + size 列出目标文件每一段的大小以及总体的大小。默认情况下，对于每个
     目标文件或者一个归档文件中的每个模块只产生一行输出。
   + strings 打印某个文件的可打印字符串，这些字符串最少4个字符长，也可
     以使用选项-n设置字符串的最小长度。默认情况下，它只打印目标文件初
     始化和可加载段中的可打印字符；对于其他类型的文件它打印整个文件的
     可打印字符。这个程序对于了解非文本文件的内容很有帮助。
   + strip 丢弃目标文件中的全部或者特定符号。
   + libiberty 包含许多GNU程序都会用到的函数，这些程序有getopt、
     obstack、strerror、strtol和strtoul。
   + libbfd 二进制文件描述库。
   + libopcode 用来处理opcodes的库，在生成一些应用程序的时候也会用到它。

   Binutils工具安装依赖于Bash、Coreutils、Diffutils、GCC、Gettext、
   Glibc、Grep、Make、Perl、Sed、Texinfo等工具。

   配置Binutils工具，建议建立一个新的目录用来存放配置和编译文件，这样
   可以使源文件和编译文件独立开，具体操作如下：

   #+BEGIN_EXAMPLE
   # cd $PRJROOT/build-tools
   # mkdir build-binutils
   # cd build-binutils
   # ../ binutils-2.15/configure --target=$TARGET --prefix=$PREFIX
   #+END_EXAMPLE

   其中选项
   + -–target的意思是制定生成的是 arm-linux 的工具
   + --prefix 是指出可执行文件安装的位置。

   执行make make install
   #+BEGIN_EXAMPLE
   # make
   # make install
   #+END_EXAMPLE

5. 获得内核头文件

   编译器需要通过系统内核的头文件来获得目标平台所支持的系统函数调用所
   需要的信息。对于Linux内核，最好的方法是下载一个合适的内核，然后复制
   获得头文件。需要对内核做一个基本的配置来生成正确的头文件；不过，不
   需要编译内核。
   #+BEGIN_EXAMPLE
     # cd $PRJROOT/kernel
     # tar –xvzf linux-2.6.10.tar.gz
     # cd linux-2.6.10
     # make ARCH=arm CROSS_COMPILE=arm-linux- menuconfig
   #+END_EXAMPLE
   其中
   + ARCH=arm表示是以arm为体系结构，
   + CROSS_COMPILE=arm-linux-表示是以arm-linux-为前缀的交叉编译器。
   + 推荐用make menuconfig，也可以用config和xconfig来代替menuconfig，
     这也是内核开发人员用的最多的配置方法。
   + 注意在配置时一定要选择处理器的类型，这里选择三星的S3C2410（System
     Type->ARM System Type->/Samsung S3C2410）
   + 配置完退出并保存，检查一下内核目录中的include/linux/version.h和
     include/linux/autoconf.h文件是不是生成了，这是编译glibc时要用到的，
     如果version.h 和 autoconf.h 文件存在，说明生成了正确的头文件。

   复制头文件到交叉编译工具链的目录，首先需要在
   /home/mike/armlinux/tools/arm-linux目录下建立工具的头文件目录
   inlcude，然后复制内核头文件到此目录下，具体操作如下：
   #+BEGIN_EXAMPLE
   # mkdir –p $TARGET_PREFIX/include
   # cp –r $PRJROOT/kernel/linux-2.6.10/include/linux $TARGET_PREFIX/include
   # cp –r $PRJROOT/kernel/linux-2.6.10/include/asm-arm $TARGET_PREFIX/include/asm
   #+END_EXAMPLE

6. 编译安装boot-trap gcc

   这一步的目的主要是建立arm-linux-gcc工具，注意这个gcc没有glibc库的支
   持，所以只能用于编译内核、BootLoader等不需要C库支持的程序，后面创建
   C库也要用到这个编译器，所以创建它主要是为创建C库做准备，如果只想编
   译内核和BootLoader，那么安装完这个就可以到此结束。安装命令如下：
   #+BEGIN_EXAMPLE
     # cd $PRJROOT/build-tools
     # tar –xvzf gcc-3.3.6.tar.gz
     # mkdir build-gcc
     # cd gcc-3.3.6
     # vi gcc/config/arm/t-linux
   #+END_EXAMPLE

   由于是第一次安装ARM交叉编译工具，没有支持libc库的头文件，所以在
   gcc/config/arm/t- linux文件中给变量TARGET_LIBGCC2_CFLAGS增加操作参
   数选项-Dinhibit_libc -D__gthr_ posix_h来屏蔽使用头文件，否则一般默
   认会使用/usr/inlcude头文件。

   将TARGET_LIBGCC2-CFLAGS = -fomit-frame-pointer –fPIC改为
   TARGET_LIBGCC2- CFLAGS=-fomit-frame-pointer–fPIC -Dinhibit_libc
   -D__gthr_posix_h

   修改完t-linux文件后保存，紧接着执行配置操作，如下命令：

   #+BEGIN_EXAMPLE
     # cd build-gcc
     # ../gcc-3.6.3/configure --target=$TARGET --prefix=$PREFIX \
       --enable-languages=c --disable-threads --disable-shared
   #+END_EXAMPLE

   其中选项
   + --enable-languages=c表示只支持C语言，
   + --disable-threads表示去掉thread功能，这个功能需要glibc的支持。
   + --disable-shared表示只进行静态库编译，不支持共享库编译。

   接下来执行编译和安装操作，命令如下：
   #+BEGIN_EXAMPLE
     # make
     # make install
   #+END_EXAMPLE

   安装完成后，在/home/mike/armlinux/tools/bin下查看，如果
   arm-linux-gcc等工具已经生成，表示boot-trap gcc工具已经安装成功。

7. 未完待续

*** 用Crosstool工具构建交叉工具链
*** 交叉工具链编译 crosstool-ng                                 :crosstool:
**** reference

+ [[http://crosstool-ng.org/][Homepage]]
+ [[http://crosstool-ng.org/][GitHub]]: github上为dev版，非 released 稳定版
+ [[https://app.yinxiang.com/shard/s52/nl/11551545/499881d7-0521-4cf7-bf27-0a1534070469?title=Crosstool-NG%20%E7%BA%AA%E5%BD%95-%20Double%20E.%20Rhapsody][安装 crosstool-ng]]
+ [[https://app.yinxiang.com/shard/s52/nl/11551545/66c56b20-ee69-45e8-a7a3-cb0d182797f9?title=Crosstool-NG%20%E7%BA%AA%E5%BD%95(%E7%BB%AD)%20-%20Double%20E.%20Rhapsody][使用 crosstool-ng 编译交叉工具链]]
+ 《Raspberry 创意项目制作》

**** 安装 crosstool-ng                                           :install:

1. 下载： 主页下载稳定版

2. 依赖
   + gcc
   + libstdc: 标准C++库
   + libtool
   + make
   + GNU MP
   + gperf: 哈希函数发生器
   + bison: C语法解析器
   + flex: 词法模式识别引擎
   + ncurses: 终端图形库
   + sed: 流编辑器
   + texinfo: 文档生成和解析工具

3. 安装

   #+BEGIN_EXAMPLE
       $ tar xjvf crosstool-ng-1.22.0.tar.bz2
       ...
       $ cd crosstool-ng/

      crosstool-ng $ ./configure --prefix=/opt/crosstool-ng-1.22.0
      ...
      configure: error: missing required tool: help2man

      crosstool-ng $ apt-cache search help2man
      help2man - Automatic manpage generator

      crosstool-ng $ sudo apt-get install help2man
      ...
      crosstool-ng $ ./configure --prefix=/opt/crosstool-ng-1.22.0
      checking ...
      configure: creating ./config.status
      config.status: creating Makefile

      crosstool-ng $ sudo make install

      For auto-completion, do not forget to install 'ct-ng.comp' into
      your bash completion directory (usually /etc/bash_completion.d)
   #+END_EXAMPLE

4. export PATH

   #+BEGIN_SRC sh
   export PATH=$PATH:/opt/crosstool-ng-1.22.0/bin
   #+END_SRC

   *cl-ng*

**** 配置交叉编译器：ct-ng menuconfig
1. sandbox

   #+BEGIN_EXAMPLE
     $ mkdir cross-sandbox
     $ cd cross-sandbox
     $ ct-ng menuconfig
   #+END_EXAMPLE

2. 路径和其它选项(Paths and Misc Options)

   1) 启用 "Try featured marked as EXPERIMENTAL"

   2) Prefix directory

      #+BEGIN_EXAMPLE
        ${HOME}/x-tools/${CT_TARGET}  # 默认
        ${HOME}/.x-tools/${CT_TARGET} # 修改，不喜欢主目录下文件过多
      #+END_EXAMPLE

   3) Number of parallel jobs: 加速构建时间， CPU个数*1.5 (6)

      #+BEGIN_EXAMPLE
        $ cat /proc/cpuinfo | grep processor
        processor       : 0
        processor       : 1
        processor       : 2
        processor       : 3
      #+END_EXAMPLE

3. 目标选项

   1) Target architecture: arm

   2) Endianness: Little endian

      查阅S3C2440手册，其两种模式均支持。至于差异，暂时不管
      [[/home/wally/Wally/Journal/Figures/scrot/49045DS.png]]

   3) Bitness: 32-bit

   4) Architecture level: armv4t

      The S3C2440A offers outstanding features with its CPU core, a
      16/32-bit *ARM920T* RISC processor designed by Advanced RISC
      Machines, Ltd. The ARM920T implements MMU, AMBA BUS, and Harvard
      cache architecture with separate 16KB instruction and 16KB data
      caches, each with an 8-word line length.

      ARM920t的ARM核： armv4t

   5) Emit assembly for CPU: arm920t

   6) Tune for CPU: arm920t

   7) Use specific FPU: floating 相关？？

   8) Floating point：software(no FPU)

      对于很多ARM架构CPU来说是不支持硬浮点运算的，所以选择软件方式有更好
      的兼容性

      S3c2440 没有 *FPA* (Float Point Architecture)，不能进行硬浮点运算,
      而是使用 FPE(Float Point Emulation), 即软浮点。

   9) default instruction set mode: arm

   10) 启用Use EABI

4. 工具链选项(Toolchain Options)

   + Tuple's vendor string: wally

5. 操作系统选项(Operating system)

   + Target OS: linux

   + Linux kernel version:
     - 2.6.32 (简单起见)
     - *使用最新 4.3*

6. 二进制实用工具选项(Binary Utilities Options)

   + Binary format: elf
   + binutils versio: 2.25(最新)

7. C 编译器选项(C Compile Options)

   + C compiler (gcc)

   + 启用 Show linaro versions

   + gcc version：linaro-4.9

   + 启用C++

   + gcc extra config --with-float=hard (NO)

8. C 库选项(C Library Options)

   + C library: glibc
   + glibc version: 2.22（最新的好不好，不知道）

9. gdb 选项

**** 构建 *ct-ng build*

等待下载

然后等待编译, 编译过程十分耗内存。

***** error:Don't set LD_LIBRARY_PATH                             :error:

#+BEGIN_EXAMPLE
[ERROR]  Don't set LD_LIBRARY_PATH. It screws up the build.
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  $ echo $LD_LIBRARY_PATH
  /home/wally/catkin_ws/devel/lib/x86_64-linux-gnu:/home/wally/Wally/Project/catkin_ws/devel/lib/x86_64-linux-gnu:~/catkin_ws/devel/lib/x86_64-linux-gnu:~/Wally/Project/catkin_ws/devel/lib/x86_64-linux-gnu:/opt/ros/jade/lib/x86_64-linux-gnu:/home/wally/catkin_ws/devel/lib:/home/wally/Wally/Project/catkin_ws/devel/lib:~/catkin_ws/devel/lib:~/Wally/Project/catkin_ws/devel/lib:/opt/ros/jade/lib
#+END_EXAMPLE

ROS 配置文件引入了环境变量 LD_LIBRARY_PATH 的原因.

***** error: python is missing or unusable

#+BEGIN_EXAMPLE
  [INFO ]  Installing cross-gdb
  [ERROR]    configure: error: python is missing or unusable
  [ERROR]    make[2]: *** [configure-gdb] Error 1
  [ERROR]    make[1]: *** [all] Error 2
#+END_EXAMPLE

Python 版本问题，ct-ng 使用 python 2.7

/usr/bin/python 链接改为指向 /usr/bin/python2.7

**** export PATH

#+BEGIN_EXAMPLE
   ~ $ ls .x-tools/arm-wally-linux-gnueabi/bin/
  arm-wally-linux-gnueabi-addr2line     arm-wally-linux-gnueabi-gdb
  arm-wally-linux-gnueabi-ar            arm-wally-linux-gnueabi-gprof
  arm-wally-linux-gnueabi-as            arm-wally-linux-gnueabi-ld
  arm-wally-linux-gnueabi-cc            arm-wally-linux-gnueabi-ld.bfd
  arm-wally-linux-gnueabi-c++filt       arm-wally-linux-gnueabi-ldd
  arm-wally-linux-gnueabi-cpp           arm-wally-linux-gnueabi-nm
  arm-wally-linux-gnueabi-ct-ng.config  arm-wally-linux-gnueabi-objcopy
  arm-wally-linux-gnueabi-elfedit       arm-wally-linux-gnueabi-objdump
  arm-wally-linux-gnueabi-gcc           arm-wally-linux-gnueabi-populate
  arm-wally-linux-gnueabi-gcc-4.9.4     arm-wally-linux-gnueabi-ranlib
  arm-wally-linux-gnueabi-gcc-ar        arm-wally-linux-gnueabi-readelf
  arm-wally-linux-gnueabi-gcc-nm        arm-wally-linux-gnueabi-size
  arm-wally-linux-gnueabi-gcc-ranlib    arm-wally-linux-gnueabi-strings
  arm-wally-linux-gnueabi-gcov          arm-wally-linux-gnueabi-strip

#+END_EXAMPLE


#+BEGIN_EXAMPLE
export PATH=$PATH:~/.x-tools/arm-wally-linux-gnueabi/bin
#+END_EXAMPLE

**** 为什么没有 gdb??

配置时没有勾选。
** OpenOCD: Open On-Chip Debugger*                                 :openocd:
*** references

+ [[http://openocd.org/][Homepage]]
+ [[http://sourceforge.net/projects/openocd/][SourceForge]]
+ [[~/Wally/Reference/Guide/OpenocdManual.pdf][OpenocdManual.pdf]]

*** intro
**** 为什么使用openocd

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/92b1d2c3-dc84-4924-b267-4ba4df453027?title=openocd%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%83%A7%E5%86%99ARM%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%20problems%20and%20solutions%20-%20Melchior%E7%9A%84%E6%97%A5%E5%BF%97%20-%20%E7%BD%91%E6%98%93%E5%8D%9A%E5%AE%A2][En::OpenOCD烧写ARM裸机程序]]

以前是用 rvds 的ide来烧写调试arm程序的，不过rvds虽然是集成化的
调试工具调试起来方便，但是有的时候只知其一，不知其二，只知道按部就班的
来点击按钮，忽略了一些本质性的东西。而且rvds还有一个不好的地方是它只能
在windows平台下运行，不支持linux os。为了便于学习linux，使用openocd会
是个不错的选择，可以学习gnu 汇编，makefile编写，工具链命令行使用。
如果这些命令搞熟悉了，你还可以利用qt 来做个自己的图形化界面烧写调试工
具。不过这只是个壳子而已，精髓在于openocd ，所以如果有时间你还可以分
析一下openocd的源码，因为它是开源的，开源的东西就是好，它可以满足你的
好奇心，虽然有些时候不是我们在玩代码而是代码在玩我们.

**** installation                                                :install:

1. version

   - apt-get(软件管理中心/新得立): 0.8
   - beta(release): 0.9, bug 修复 + 体验更多特性

2. 源码安装： http://sourceforge.net/projects/openocd/

   #+BEGIN_EXAMPLE
   ./configure & make & make install
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
      $ locate openocd
     ~/.openocd
     ~/.openocd_history
     wally@ openocd-0.9.0 $ which openocd
     /usr/local/bin/openocd
   #+END_EXAMPLE
*** guide                                                           :guide:
**** help
#+BEGIN_EXAMPLE
$ openocd --help
open on-chip debugger 0.9.0 (2015-06-11-20:27)
licensed under gnu gpl v2
for bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
open on-chip debugger
licensed under gnu gpl v2
--help       | -h       display this help
--version    | -v       display openocd version
--file       | -f       use configuration file <name>
--search     | -s       dir to search for config files and scripts
--debug      | -d       set debug level <0-3>
--log_output | -l       redirect log output to file <name>
--command    | -c       run <command>
#+END_EXAMPLE

#+begin_example
#+end_example

默认文件 *openocd.cfg*

#+begin_example
openocd -f config1.cfg -f config2.cfg
#+end_example

搜索顺序
1. the *current* directory
2. *-s* specified
3. *add_script_search_dir* added
4. $home/.openocd
5. $pkgdatadir/site  file:/usr/share/openocd/scripts/
6. $pkgdatadir/scripts

note: *reusing script libraries*

**** hooking up the jtag adapter

1. start with power to your target board *turned off*,  and *nothing
   connected to your jtag adapter*
2. connecting the adapter to the board
3. connecting the adapter to the pc
4. connecting the adapter's power supply if neccessary
5. power on the target board

**** user config files

1. configure files

   */usr/share/openocd/scripts/*

   + interface: for debug adapter
   + board: for board
   + target: the chips which integrate cpus and other jtag taps

     #+BEGIN_EXAMPLE
       source [find interface/jlink.cfg]
       source [find board/stm32.cfg]
     #+END_EXAMPLE

   */usr/share/openocd/scripts 目录下有对应接口(interface下)和芯片
   (target下)的配置文件，尽量复用这些文件*

2. openocd寻找配置文件的顺序

   1) 当前目录
   2) -s选项指定的目录
   3) add_script_search_dir指定的目录
   4) $home/.openocd
   5) openocd脚本目录：$packagedir/scripts(/usr/share/openocd/scripts)

**** running openocd

#+BEGIN_EXAMPLE
openocd -f test.cfg
#+END_EXAMPLE

***** error: unknown param: -variant                              :error:
point: samsung_s3c2440.cfg
方法： 删除

***** error：insert a call to adpter_khz or jtag_rclk to process  :error:

#+BEGIN_EXAMPLE
an adapter speed is not selected in the init script. insert a call to adpter_khz or jtag_rclk to process
#+END_EXAMPLE
point: jlink.cfg
方法：按提示来，增加 adapter_khz 6000


normally, openocd starts running as a daemon(无交互后台程序).once
openocd starts running as a deamon, it waits for connections from
clients(*telnet*, *gdb*, others) and processes the commands issued
through those channels.

**** connecting

在建立了jlink识别arm，而且建立了telnet服务器端口号之后，通过talnet与
target建立连接

#+begin_src sh
telnet localhost 4444(telnet的端口号设置为4444)
#+end_src

*** usage

1. openocd -f tq2440.cfg
2. telnet localhost 4444
3. halt
4. nand probe 0
5. nand erase 0 0 0x100000
6. write

*** 常用命令

**** 目标板状态处理命令(target state handling)

+ poll 查询目标板的当前状态
+ halt 中断目标板的运行
+ resume [address] 恢复目标板的运行，指定地址则从地址处
+ step [address] 单步

**** 断点命令

+ bp <addr> <lenght> [hw] 在地址addr处设置断点，指令长度为length，hw表
  示硬件断点
+ rbp <addr>  删除地址处的断点

**** 内在访问指令

+ mdw <addr> [count] 显示从地址addr开始的count（缺省1）个字（4字节）
+ mdh <addr> [count] 显示从地址addr开始的count个半字（2字节）
+ mdb <addr> [count] 显示从地址addr开始的count个字节

+ mww <addr> <value> 向地址addr写入一个字，值为value
+ mwh <addr> <value> 向地址addr写入一个半字，值为value
+ mwb <addr> <value> 向地址addr写入一个字节，值为value

+ load_image <file> <address> ['bin'|'ihex'|'elf']
  将文件file载入地址为addr的内在，格式有bin, ihex, elf

+ dump_image <file> <address> <size>
  将内存从地址address开始的size字节数据读出，保存到文件file中

+ verify_image <file> <address> ['bin'|'ihex'|'elf']
  将文件file与内存地址address开始的数据进行比较

**** nand

nand: nand flash command group (command valid any time)

+ *nand check_bad_blocks bank_id [offset length]*

   check all or part of nand flash device for bad blocks

+ *nand device bank_id driver target [driver_options ...]*

  defines a new nand bank (configuration command)

+ *nand drivers*

  lists available nand drivers (command valid any time)

+ *nand dump bank_id filename offset length ['oob_raw'|'oob_only']*

  dump from nand flash device

+ *nand erase bank_id [offset length]*

  erase all or subset of blocks on nand flash device

+ *nand info [banknum | first_bank_num last_bank_num]*

  print info about one or more nand flash devices

+ *nand init*

  initialize nand devices (configuration command)

+ *nand list*

  list configured nand flash devices

+ *nand probe bank_id*

  identify nand flash device

+ *nand raw_access bank_id ['enable'|'disable']*

  raw access to nand flash device

+ *nand verify bank_id filename offset ['oob_raw'|'oob_only'|'oob_softecc'|'oob_softecc_kw']*

  verify nand flash device

+ *nand write bank_id filename offset* ['oob_raw'|'oob_only'|'oob_softecc'|'oob_softecc_kw']

  write to nand flash device

**** cpu架构相关命令

+ armv4 reg 打印寄存器的值
+ arm7_9 sw_bkpts <enable|disable> 使能或禁止软件断点
+ arm920t cp15 <num> [value] 显示/修改cp15协处理器的寄存器
+ arm920t md<bhw>_phys <addr> [count] 显示物理地址addr处的内存
+ arm920t mw<bhw>_phys <addr> <value> 修改物理地址addr处的内存
+ arm920t virt2phys <va> 获取虚拟地址va对应的物理地址

**** 其它命令

script <file> 执行file文件中的命令

*** test                                                             :test:
**** 使用openocd连接jlink并烧录程序

1. jlink 端未连接开发板时, 不行，需要连接

   #+begin_example
     $ openocd -f interface/jlink.cfg
     open on-chip debugger 0.9.0 (2015-06-11-20:27)
     licensed under gnu gpl v2
     for bug reports, read
             http://openocd.org/doc/doxygen/bugs.html
     info : j-link arm v8 compiled jan 31 2018 18:34:52
     info : j-link caps 0xb9ff7bbf
     info : j-link hw version 80000
     info : j-link hw type j-link
     info : j-link max mem block 8368
     info : j-link configuration
     info : usb-address: 0x0
     info : kickstart power on jtag-pin 19: 0x0
     info : vref = 0.0 tck = 0 tdi = 0 tdo = 0 tms = 0 srst = 1 trst = 0
     error: vref too low. check target power
     info : j-link jtag interface ready
     error: jlink_tap_execute failed, result 5 (unknown)
     error: an adapter speed is not selected in the init script. insert a call to adapter_khz or jtag_rclk to proceed.
   #+end_example

   vref too low

2. jlink 端连接开发板后
   #+begin_example
     $ openocd -f interface/jlink.cfg
     open on-chip debugger 0.9.0 (2015-06-11-20:27)
     licensed under gnu gpl v2
     for bug reports, read
             http://openocd.org/doc/doxygen/bugs.html
     info : j-link arm v8 compiled jan 31 2018 18:34:52
     info : j-link caps 0xb9ff7bbf
     info : j-link hw version 80000
     info : j-link hw type j-link
     info : j-link max mem block 8368
     info : j-link configuration
     info : usb-address: 0x0
     info : kickstart power on jtag-pin 19: 0x0
     info : vref = 3.287 tck = 1 tdi = 0 tdo = 1 tms = 0 srst = 1 trst = 1
     info : j-link jtag interface ready
     error: jlink_tap_execute failed, result 1 (adaptive clocking timeout)
     error: an adapter speed is not selected in the init script. insert a call to adapter_khz or jtag_rclk to proceed.
   #+end_example

3. 根据提示配置 adapter_khz

   在命令行中使用 "-c adapter_khz 3000" 运行有错误

   在配置文件中配置之后， 运行暂时没有问题

   #+begin_example
   source [find interface/jlink.cfg]
   adapter_khz 3000
   transport select jtag
   #+end_example

   #+begin_example
     openocd $ openocd -f demo.config
     open on-chip debugger 0.9.0 (2015-06-11-20:27)
     licensed under gnu gpl v2
     for bug reports, read
             http://openocd.org/doc/doxygen/bugs.html
     adapter speed: 3000 khz
     jtag
     info : j-link arm v8 compiled jan 31 2018 18:34:52
     info : j-link caps 0xb9ff7bbf
     info : j-link hw version 80000
     info : j-link hw type j-link
     info : j-link max mem block 8368
     info : j-link configuration
     info : usb-address: 0x0
     info : kickstart power on jtag-pin 19: 0x0
     info : vref = 3.287 tck = 1 tdi = 0 tdo = 1 tms = 0 srst = 1 trst = 1
     info : j-link jtag interface ready
     info : clock speed 3000 khz
     warn : there are no enabled taps.  auto probing might not work!!
     info : jtag tap: auto0.tap tap/device found: 0x0032409d (mfg: 0x04e, part: 0x0324, ver: 0x0)
     warn : auto auto0.tap - use "jtag newtap auto0 tap -irlen 4 -expected-id 0x0032409d"
     warn : gdb services need one or more targets defined
   #+end_example

4. 开发板(tq2440)配置，使用 mini2440.cfg

   error:
   #+begin_example
   in procedure 'jtag' called at file "mini2440.cfg", line 124
   #+end_example

   注释掉

   #+begin_example
        adapter speed: 3000 khz
     jtag
     adapter_nsrst_delay: 100
     jtag_ntrst_delay: 100
     trst_and_srst separate srst_gates_jtag trst_push_pull srst_open_drain connect_deassert_srst
     force hard breakpoints
         targetname         type       endian tapname            state
     --  ------------------ ---------- ------ ------------------ ------------
      0* s3c2440.cpu        arm920t    little s3c2440.cpu        unknown
     error: no valid nand flash driver found (0)
     available nand flash controller drivers:
       nonce
       davinci
       lpc3180
       lpc32xx
       orion
       s3c2410
       s3c2412
       s3c2440
       s3c2443
       s3c6400
       mxc
       imx31
       at91sam9
       nuc910
     adapter_nsrst_delay: 100
     jtag_ntrst_delay: 100
     trst_and_srst separate srst_gates_jtag trst_push_pull srst_open_drain connect_deassert_srst
     info : j-link arm v8 compiled jan 31 2018 18:34:52
     info : j-link caps 0xb9ff7bbf
     info : j-link hw version 80000
     info : j-link hw type j-link
     info : j-link max mem block 8368
     info : j-link configuration
     info : usb-address: 0x0
     info : kickstart power on jtag-pin 19: 0x0
     info : vref = 3.287 tck = 1 tdi = 0 tdo = 1 tms = 0 srst = 1 trst = 1
     info : j-link jtag interface ready
     info : clock speed 3000 khz
     info : jtag tap: s3c2440.cpu tap/device found: 0x0032409d (mfg: 0x04e, part: 0x0324, ver: 0x0)
     info : embedded ice version 2
     info : s3c2440.cpu: hardware has 2 breakpoint/watchpoint units

     -------------------------------------------
     --- login with - telnet localhost 4444  ---
     --- then type help_2440                 ---
     -------------------------------------------

     help_2440
   #+end_example

   注意： *error: no valid nand flash driver found (0)*
   *先不管*

5. no valid nand flash driver found(0)


   #+begin_example
         # nand device s3c2440 0
         nand device 0 s3c2440 s3c2440.cpu
   #+end_example

   你的openocd 的版本是最新的0.5版吧，此版的 nand 命令跟以前的不一样了。

   nand device bank_id driver target [driver_options ...]

   我的 target 是 s3c2440.cpu 我改为以下的就好了：
   nand device 0 s3c2440 s3c2440.cpu

   [[http://www.100ask.org/bbs/forum.php?mod=viewthread&tid=2629][reference]]

6. seems ok

   #+begin_example
     adapter speed: 3000 khz
     jtag
     adapter_nsrst_delay: 100
     jtag_ntrst_delay: 100
     trst_and_srst separate srst_gates_jtag trst_push_pull srst_open_drain connect_deassert_srst
     force hard breakpoints
         targetname         type       endian tapname            state
     --  ------------------ ---------- ------ ------------------ ------------
      0* s3c2440.cpu        arm920t    little s3c2440.cpu        unknown
     adapter_nsrst_delay: 100
     jtag_ntrst_delay: 100
     trst_and_srst separate srst_gates_jtag trst_push_pull srst_open_drain connect_deassert_srst
     info : j-link arm v8 compiled jan 31 2018 18:34:52
     info : j-link caps 0xb9ff7bbf
     info : j-link hw version 80000
     info : j-link hw type j-link
     info : j-link max mem block 8368
     info : j-link configuration
     info : usb-address: 0x0
     info : kickstart power on jtag-pin 19: 0x0
     info : vref = 3.287 tck = 1 tdi = 0 tdo = 1 tms = 0 srst = 1 trst = 1
     info : j-link jtag interface ready
     info : clock speed 3000 khz
     info : jtag tap: s3c2440.cpu tap/device found: 0x0032409d (mfg: 0x04e, part: 0x0324, ver: 0x0)
     info : embedded ice version 2
     info : s3c2440.cpu: hardware has 2 breakpoint/watchpoint units

     -------------------------------------------
     --- login with - telnet localhost 4444  ---
     --- then type help_2440                 ---
     -------------------------------------------

     help_2440
   #+end_example

7. telnet

   #+begin_example
     telnet localhost 4444
     trying 127.0.0.1...
     connected to localhost.
     escape character is '^]'.
     open on-chip debugger
   #+end_example

**** 测试

***** halt
halt first

#+begin_example
     nand probe 0
     target not halted
     target not halted
     target must be halted to use s3c24xx nand flash controller
#+end_example

halt
#+begin_example
     > halt
     target state: halted
     target halted in arm state due to debug-request, current mode: supervisor
     cpsr: 0x80000053 pc: 0x33d15980
     mmu: enabled, d-cache: enabled, i-cache: enabled
#+end_example

***** nand probe

probe 探索

#+begin_example
     > nand probe 0
     nand flash device 'nand 256mib 3.3v 8-bit (unknown)' found
#+end_example

***** erase

erase
#+begin_example
     > nand erase 0 0 0x100000  # 应该是板子nand flash块的整数倍
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     erased blocks 0 to 7 on nand flash device #0 'nand 256mib 3.3v 8-bit'
#+end_example

#+BEGIN_EXAMPLE
didn't erase bad block 569; status: 0xe1
erased blocks 0 to 2047 on NAND flash device #0 'NAND 256MiB 3.3V 8-bit'
#+END_EXAMPLE

***** write

绝对路径

#+begin_example
  > nand write  0 ~/wally/journal/project/arm/arm/tq2440/led/led.bin 0
  wrote file ~/wally/journal/project/arm/arm/tq2440/led/led.bin to nand flash 0 up to offset 0x00000800 in 2.092001s (0.099 kib/s)
#+end_example

***** poll

poll 轮询
#+begin_example
  > poll
  background polling: on
  tap: s3c2440.cpu (enabled)
  target state: halted
  target halted in arm state due to debug-request, current mode: supervisor
  cpsr: 0x80000053 pc: 0x33d15980
  mmu: enabled, d-cache: enabled, i-cache: enabled
#+end_example

*** 调试                                                            :debug:

**** 直接使用openocd命令进行调试（如上）

1. telnet localhost 4444
2. openocd命令

**** 使用gdb调试                                                     :gdb:

1. arm-linux-gdb
2. target remote localhost:4444

#+BEGIN_EXAMPLE
~ $ arm-linux-gdb
GNU gdb (Sourcery G++ Lite 2008q3-72) 6.8.50.20080821-cvs
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "--host=i686-pc-linux-gnu --target=arm-none-linux-gnueabi".
For bug reporting instructions, please see:
<https://support.codesourcery.com/GNUToolchain/>.
(gdb) target remote localhost:4444
Remote debugging using localhost:4444
warning: unrecognized item "qSupported" in "qSupported" response
warning: Invalid remote reply: ?
#+END_EXAMPLE

*qSupported* 问题应该是 gdb 版本过低所致。

先不管它。(解决了)

*** TODO Eclisp integrate

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/262d6e1c-b8db-4335-9510-70a1f93b43b5?title=Openocd%20%E5%AE%89%E8%A3%85%E5%B9%B6%E5%9C%A8Eclipse%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%80%9A%E8%BF%87J-Link%E8%B0%83%E8%AF%95][在Eclipse环境下通过J-Link调试程序]]

** sdcc                                                            :sdcc:51:
*** reference

+ [[http://en.wikipedia.org/wiki/small_device_c_compiler][Wiki_En]]
+ [[http://sdcc.sourceforge.net/][SourceForge]]

*** intro
      .....
the _Small........C Compiler_ (/sdcc/) is a free-software, partially
retargetable c com.iler for microcontrollers. it is distributed
under the gnu general public license. the package also contains a
/linker/, /assembler/, /simulator/ and /debugger/.

*** 编译源文件

1. 命令: *$ sdcc sourcefile.c*

2. 输出
   ourcefile.asm - 程序的汇编文件
   sourcefile.lst - 程序的列表文件
   sourcefile.rst - 被链接器更新的列表文件
   sourcefile.sym - 由链接器生成的符号清单
   sourcefile.rel - 由汇编器生成的对象文件，提供给链接器使用
   sourcefile.map - 被链接器更新的最终存储器映射
   sourcefile.mem - 内存的使用情况摘要
   sourcefile.ihx - 用于生成intel hex格式文件模块

3. ihx

   + = intel hex
   + 转换为hex文件: *$ packihx file.ihx -> file.hex*

*** sbit

SDCC兼容 ANIS C 和 ISO C,  /sbit/ 作为一种标准数据类型使用, 而不是像keil那样
在main()的外围定义io(寄存器地址).

相应的, sdcc采用扩展的非anis标准的类型定义寄存器地址, *__sbit*, 以双下
划线作为前缀.

对于一些非ansi c的关键字,sdcc均采用双下滑线开头的方式定
义,如__code,__idata,__sbit......对于单片机引脚的定义sdcc采用了 __at关
键字和十六进制地址.
1. sdcc

   #+begin_example
     __sbit __at 0x80 led0;
     __sbit __at 0x81 led1;
     __sbit __at 0x82 led2;
     __sbit __at 0x83 led3;
   #+end_example

2. keil

   #+begin_example
     sbit p1_0 = p1^1;
   #+end_example

3. 区别

   + SDCC 中的 sbit 和 ^ 都符合 ANIS 标准
   + SDCC 的 __sbit等 在 main() 内使用

*** Note

+ 51输出端口默认输出1

+ 没有while循环也会循环, 可能是编译优化的原因.

** EDA                                                                 :eda:
*** Altium Designer                                        :altiumdesigner:
**** intro

*Altium Designer*: /PCB/ 设计 & /FPGA/ 开发环境

1988,  ACCEL公司， TANGO软件， EDA先河。
Protel for DOS -> Protel 98 -> Protel 99 -> /Protel 99SE/
-> Protel DXP(2001) -> Protel DXP2004 -> Altium Designer 6.0(2006，初
版)

q最好的教程： /软件手册/

Matlab, CCS等 help 文档十分清晰。

**** application

1. Foundation

   [[~/Wally/Journal/Figures/scrot/20587mNw.png]]

2. Board Implementation

   [[~/Wally/Journal/Figures/scrot/20587zX2.png]]

3. Embedded Intelligence Implementation

   [[~/Wally/Journal/Figures/scrot/20587yrL.png]]

**** shortcuts

右下角标签页，动态显示

[[~/Wally/Journal/Figures/scrot/20587ZKe.png]]

**** PCB
***** 设计流程

[[~/Wally/Journal/Figures/scrot/20587mUk.png]]

1) EDA设计PCB
2) 加工制作

***** EDA设计流程

[[~/Wally/Journal/Figures/scrot/20587Nz2.png]]

1. 原理图(/SCH/)设计/仿真
   1) 图纸设置
   2) 环境设置
   3) 元件库装载
   4) 放置元件并布局
   5) 原理图布线
   6) 电气检查
   7) NET
   8) 文件存储

2. 网络报表(/NET/)生成， AD可以省略

3. 印制版(/PCB/)设计
   1) 设置环境
   2) 设置PCB设计规则
   3) 放置元件并布局
   4) 布线
   5) 规则检查
   6) 报表生成
   7) 文件存储

高频板/多层板，需要进行SCH仿真，进行信号
低速板(<50M)

***** PCB基本概念

[[~/Wally/Journal/Figures/scrot/20587Awk.png]]

1. 基本材料：FR-4 环氧树脂 FR-5耐热

2. 1u = 0.25mm

3. 层(Layer)
   1) 信号层(一般为35um)
   2) 基层（一般为1.5mm, ）

4. 过孔(Via)

5. 丝印层(Overlay): 板上标识

6. 焊盘： 元器件焊接

7. 飞线

***** 线宽与电流关系

单位 u

弱电电流一般不会达到1A，10u的余度往往足够。

[[~/Wally/Journal/Figures/scrot/20587MOA.png]]

***** 设计准则

1. /抗干扰/

   1) 电源线的设计

      [[~/Wally/Journal/Figures/scrot/20587aLl.png]]

   2) 地线

      [[~/Wally/Journal/Figures/scrot/205870fx.png]]

   3) 元器件配置

      [[~/Wally/Journal/Figures/scrot/20587A-M.png]]

   4) 去耦电容

      [[~/Wally/Journal/Figures/scrot/20587ncf.png]]

   5) 降低噪声

      [[~/Wally/Journal/Figures/scrot/20587O7x.png]]

   6) 其它设计原则

      [[~/Wally/Journal/Figures/scrot/20587aZN.png]]

2. 热设计原则

3. 抗振

4. 可测试

**** 又犯病了，这种学习方式要干嘛，一点也没有效率，纯粹浪费时间
*** proteus                                                       :proteus:
**** intro

Proteus 软件是英国 Lab Center Electronics 公司出版的 EDA 工具软件。它
不仅具有其它EDA工具软件的仿真功能，还能仿真单片机及外围器件。它是目前
比较好的仿真单片机及外围器件的工具。

**** ubuntu                                                       :ubuntu:

***** alternatives

+ KiCad (available in the software center)
+ PCB Designer (available in software center)
+ gEDA (available in the software center)
+ Visolate (available in the software center)
+ ktech lab

***** [[http://askubuntu.com/questions/77399/are-there-any-alternative-programs-to-proteus-available][proteus alternative: wine]]                                                         :wine:

If you want, you can install Proteus /7.0/ which is functional on Ubuntu
12.04 (32bits) with Wine or PlayonLinux. However, newer versions (7.5
or 8.0) won't work since wine finishes with errors during execution.

Wine is good but not enough for such complex software as Proteus. I
installed CrossOver (based on Wine), and install Proteus on it
successfully.

[[https://www.codeweavers.com/products/][crossover: based on wine,  for Mac, 商业软件]]

***** 虚拟机 Virtualbox

**** reference

+ [[http://opt.zju.edu.cn/weijiyuanli/upload/PROTEUS/Proteus%20VSM%E6%95%99%E7%A8%8B/Proteus%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.htm][Proteus 入门教程]]
+ [[][]]

* MCU
** ARM                                                                 :arm:
*** Register

The ARM processor has a total of 37 registers:
1. 31 general-purpose registers(32-bits) including a program counter.
2. 6 status registers(32-bits)

Registers are arranged in partially overlapping banks(分组), with the
current processor mode controlling which bank is avaliable.


**** General-purpose registers(通用寄存器)

***** R0-R7: the unbanked registers

*Unbanked registers* means that each of them refers to the same 32-bit
 physical register in all processor modes. They are completely
 general-purpose registers, with no special used implied by the
 architecture, and can be used wherever an instruction allows a
 general-pupose register to be specified.

***** R8-R14: the banked registers

Registers R8 to R12 have two banked physical registers each. One is
used in all processor modes other than FIQ mode, and the other is used
in FIQ mode. R8-R12 do not have any dedicated special purposes in the
architecture.

Registers R13 and R14 have six banked physical registers each. One is
used in User and System modes, and each of the remaining five is used
in one of the five exception modes.

R13 is normally used as a stack pointer and is also known as the *SP*.

R14 is known as the Link Register(LR) has two special functions in the
archetecture
+ In each mode, the mode's own version of R14 is used to hold
  subroutine return address
+ When an exception occurs, the appropriate exception mode's version
  of R14 is set to the exception return address.

R15 is used to read or write the Program Counter(PC)

***** R15, the PC,  the program counter
**** Program status registers


+ The Current Program Status Register(*CPRS*) is accessible inall
  processor mode. It contains condition code flags, interrupt disable
  bits, the current processor mode, and other status and control
  information.

+ Each exception mode alse has a Saved Program Status
  Register(*SPSR*), that is used to preserve the value of the CPSR
  when the associated exception occurs.


***** condition code flags
+ N: Negative
+ Z: Zero
+ C: Carry
+ V: oVerflow

***** Mode bits

***** T and J
The T and J bits select the current instruction set'

***** The interrupt disable bits
+ A: disable inprecise data aborts when it is set
+ I: disable IRQ interrupts when set
+ F: disable RIQ interrupts when set

***** E
bit 9(E) controls load and store endianess for data handling.

***** Q

*** 开发工具

**** 链接器脚本

#+BEGIN_SRC latex
\includepdf[pages={1-}, nup=2x4, frame=true, delta={12pt 12pt}]{~/Document/ARM/ARM/2/第2季-裸奔吧-ARM/上学期/专题1-工欲善其事-必先利其器/第4课-链接器脚本/链接器脚本.pdf}
#+END_SRC

+ .lds
+ 链接器语法
+ session(段)
  + 代码段
  + 数据段
  + bbs段
+ . 起始链接地址
+ 对齐 ALIGN(4)
+ 变量
+ 代码段首文件

**** MakeFile

#+BEGIN_SRC latex
\includepdf[pages={1-}, nup=2x4, frame=true, delta={12pt 12pt}]{~/Tiger/Ref/Makefile工程管理.pdf}
#+END_SRC

+ 规则
  + 普通规则：目标-依赖-命令
    - make some_object
  + 伪目标：.PHONY
  + 最终目标
  + 通用规则
+ 变量
  + 定义：无类型
  + 引用：$()
  + 预定义：
    - $^ --- 所有依赖
    - $@ --- 目标
    - $< --- 第一个依赖
+ 去回显 @
+ 重命名
  - MakeFile / makefile
  - -f

**** ARM 嵌入式的童年
***** Linux命令
****** 用户管理
1. useradd [opts] USER
2. userdel [opts] USER
   1) -r /home下的用户目录也被删除
3. passwd [opt] USER    # 修改密码
4. su [opt] USER    # 切换用户
5. groupadd [opt] GROUP
6. groupdel [opt] GROUP

****** 文件与目录
1. ls [opts] DIR/FILE
2. cd DIR
   1) cd ..
   2) cd -
3. cp [opt] FILE
   + -r 拷贝目录
4. mv [opts] SORUCE DES
5. rm [opt] DIR/FILE
   + -r 删除目录
   + -f --force
   + -i 询问
6. chmod [whoe][+|-|=][mode] FILE
   1) who
      + u 所有者
      + g 同组用户
      + o 其它用户
      + a 所有用户
   2) action
      + + 添加某个权限
      + - 取消某个权限
      + = 赋予某个权限
   3) 数字
      + r 4
      + w 2
      + x 1
7. mkdir [opt] DIR
   + -p 父目录不存在则创建
8. du DIR
9. pwd

****** 压缩打包
1. 后缀
   + *.gz <-> gzip
   + *.bz2 <-> bzip2
   + *.tar <-> tar
2. gzip
   1) gzip FILE
   2) gzip -d *.gz
3. bzip2
   1) bzip2 FILE
   2) bzip2 -d *.bz2
4. tar [opt] DIR/
   1) tar cvf DIR
   2) tar xvf *.tar
   3) tar czvf DIR
   4) tar zxvf *.tar.gz

****** 磁盘管理
1. mount [opt] DEVICE DIR
2. umount DIR
3. df [opt]    # 查看磁盘
4. touch FILE    # 创建文件
5. ln [opt] SOURCE LINK
   1) ln file hlink
   2) ln -s file slink
   3) 共同:
      + 与源文件保持同步
      + 不占存储空间
   4) 区别:
      + 删除源文件后, 软链接失效, 硬链接保持原有内容

****** 查找命令
1. find PARH -name FILE
2. grep REX-MODE PATH [opt]   # 路径下文件内容

****** 进程管理
1. ps
   + ps aux
2. kill [opt] pid
3. free [opt]
4. top [opt]    # CPU占有率

****** 杂项
1. 软件管理 rpm(RedHat)
2. 管道 |
3. man CMD
4. shutdown [opt] TIME

***** Linux文本编辑器
****** Emacs
****** Vi
******* 三种模式
1. 命令行模式: 插入模式下键入ESC
2. 插入模式: 命令模式下键入i
3. 底行模式: 命令模式下键入:
******* 命令模式
1. yy: 复制当前行
2. [n]yy: 复制当前光标起的n行
3. p: 粘贴
4. dd: 删除当前行
5. [n]dd: 删除当前行开始的n行
6. /name: 查找
7. G: 移动到文件尾部
8. u: 取消上一个动作
******* 插入模式
******* 底行模式
+ :w --- 保存
+ :q --- 退出
+ :q! --- 强行退出
+ :wq --- 保存退出
+ :w [filenaem] --- 另存
+ :set nu --- 显示行号
+ :set nonu --- 取消显示行号
+ :/
***** Linux网络配置
****** 虚拟机网络模式
1. bridge(桥接模式)
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.7\linewidth]{~/Wally/Journal/Figures/scrot/24643_tw.png}
   \end{figure}

2. NAT(网络地址转换模式)
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.7\linewidth]{~/Wally/Journal/Figures/scrot/24643LMM.png}
   \end{figure}

3. host-only(主机模式)
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.7\linewidth]{~/Wally/Journal/Figures/scrot/24643YWS.png}
   \end{figure}

****** 相关命令
1. ifconfig: 查看网卡信息
2. /etc/init.d/network restart: 重启各网卡
****** Linux网络接口
1. eth0: 系统中的第一块物理网卡
2. lo: 虚拟的回环网卡
3. virbr0: 虚拟网桥
****** 网络设置
文件位置: /etc/sysconfig/network-script/ifcfg-eth0 (好像不对)
***** 远程登录Linux
1. 前提1: 从Windows能够Ping通Linux
2. 前提2: 关闭Linux防火墙
   #+BEGIN_EXAMPLE
     /etc/init.d/iptables stop
   #+END_EXAMPLE
3. 登录
   1) 方式一: CLI
      Putty

***** 文件共享

**** 交叉开发的通信方式
1. 网络：tffp/NFS(网络文件系统)
2. 串口
3. JTAG
4. USB
**** dnw
+ http://blog.csdn.net/u011452544/article/details/39393857
+ http://blog.csdn.net/huanghui167/article/details/8174763
+ https://github.com/Qunero/dnw4linux


1. error: dnw can not open dev secbulk0
   1) sudo?
   2) dev/secbulk0 OR dev/secbulk1(修改dnw源码)

*** 开发环境
**** windows

+ 开发工具： ADS RVDS
  + 做了很多重要工作，如makefile
  + Win&7 64 不兼容
+
**** Linux

+ makefile
+ lds链接器脚本
+ eclispe调试

**** 开发流程

1. 编写祼机程序
2. 调试
3. 生成二进制映像
4. 烧写

**** 交叉工具链

1. arm-linux-gcc 交叉工具编译
   - arm-linux-gcc -g -c led.S
2. arm-linux-ld 链接器脚本
   - arm-linux-ld -Tled.lds -o led.elf led.o
3. arm-linux-objcopy 转换elf为二进制
   - arm-linux-objcopy -O binary led.elf led.bin

4. 使用Makefile集成在一起
**** 烧写
+ Nand flash（相当于硬盘）：祼机程序烧写到Nand中
+ Nor flash: 建立与PC机连接，将文件烧写到Nand中（bootlaoder）

*** 连接方式
**** 串口连接
SecureCRT
- ttyUSB0
- Baudrate： 115200
- 取消勾选RTS/CTS

电脑机箱后的串口坏了，VGA线也坏了
**** JLink

目前在linux下使用jlink有两种方法，一种是用官方提供的linux下的beta版，
一种是使用openocd

***** J-Link(for Linux)
1. 下载安装

   + https://www.segger.com/jlink-software.html

   + Readme：适当修改权限

2.

***** J-Link
l  程序启动后Jlink会升级固件，结果升级的固件无法运行，拔下来之后发现
jlink已经不能用了，没有办法，需要重新刷固件。

1. 使用旧版本驱动软件。

   我发现jlink的升级固件并不是从网上下载的，而是该版本内嵌的固件，每一
   个不同的版本所带的固件也不相同。我下载的是最新的V441g版本，所带的固
   件比我的Jlink上的固件要新不少。从网上下载了V422a版本后，不会提示升
   级固件了，能够正常连接到开发板。另外，我发现，如果Windows下能够正常
   连接的话，Linux下选用和Windows下同样的软件版本，应该就能正常使用了，
   我Windows下正好也是V422a版本。

2. 升级Jlink固件

   如果能想办法把jlink升级到最新的固件，那即便用最新的驱动软件应该也不
   会提示升级固件了。Linux下是不可以了，似乎不能成功，Windows可以试一
   试。下载了Windows版本的Jlink驱动V442b，安装后连接Jlink，果然提示升
   级，升级后发现也不行，固件似乎也不能运行，Jlink Commander 停在了
   “New firmware booted successfully”这里，我的Jlink大概不能兼容最新
   的固件。软件换回V422a版本，重新连接Jlink，竟然发现固件升级成功了，
   而且也可以连接到开发板，简单测试没有发现问题。回到Linux下使用V441g
   版本连接，正常连接。

***** JLink烧写固件

问题：USB识别不了，JLINK上的指示灯也不亮。
原因：内部固件意外损坏或丢失。JLINK是没那么容易坏的，除非用火烧它。即
便是山寨得也是如此。可以通过刷固件得方法解决。

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{~/Wally/Journal/Figures/24343357_1409355462jrsL.jpg}
\end{figure}


1. Jlink 和PC相连的USB线，先拔下，将JLINK断电

2. 利用短接线短接ERASE短接点，然后连接USB线到PC,给JLINK供电

3. 第三步：等待大约5秒钟时间，断开USB线，给JLINK 断电

4. 将短接在ERASE短接点上的短接线拔下，短接到TST短接点上，然后连接USB线
   给JLINK 供电。


5. 等待大约20秒吧，然后断开USB线，给JLINK断电，然后拔掉TST上的短接线。
   上面五步中，短接线连接要稳定，不可以松动。

6. 给JLINK连接上USB线，重新给JLINK供电，这个时候，USB会识别出usb
   device，但是在设备管理其中会显示一个黄色的问号就是缺少驱动的意思，
   因为JLINK现在控制烧写程序的固件都被擦除了，但是它本身就是一个
   AT91SAM7S64测试板，因为JLINK的主控芯片就是这个AT91SAM7S64，接下来我
   们利用ATMEL公司的烧写软件sam-ba_2.10.exe软件烧写新的固件程序。

7. 我们要给JLINK重新烧写固件程序，先安装sam-ba_2.10.exe软件，然后就会
   发现此时JLINK被设备管理器识别为一个AT91测试板的USBdevice，因为此时
   的JLINK没有控制烧写程序的固件，但是它本身的USB和一些程序是正常运行
   的，所以现在就当初AT91的开发板了。

8. 打开sam-ba_2.10.exe软件，选择界面信息如下图，连接选择USB/ARM0，如果
   没有这一选项，重新拔插给JLINK上电，或重启计算机，选择开发板，就要选
   择AT91SAM7S64-EK，因为我的芯片就是这个芯片。然后点击连接按钮。

**** Linux超级终端 minicom
+ http://blog.csdn.net/bird67/article/details/2127235
+ http://www.cnblogs.com/pang123hui/archive/2011/05/30/2309887.html
***** 工具
+ 图形界面
  - cutecom
  - gtkterm
+ 文本界面
  - minicom
***** minicom
****** overview
Linux下的Minicom的功能与Windows下的超级终端功能相似，可以通过串口控制外部的硬件
设备.适于在linux通过超级终端对嵌入式设备行管理.同样也可以使用minicom对外置Modem
进行控制.

HOMEPAGE: https://alioth.debian.org/projects/minicom/

Minicom is a menu driven communications program. It emulates ANSI and
VT102 terminals. It has a dialing directory and auto zmodem download.

安装
1. apt
   #+BEGIN_SRC sh :results output
     apt-cache search minicom
   #+END_SRC

   #+RESULTS:
   : minicom - friendly menu driven serial communication program
   : cutecom - 图形界面的串口调试终端，类似于 minicom

2. 源码
   + 官网下载源码包
   + ./configure make make install
****** 使用
******* 启动
$ minicom
#+BEGIN_EXAMPLE
  Welcome to minicom 2.7

  OPTIONS: I18n
  Compiled on Jun 11 2015, 20:46:06.
  Port /dev/ttyS1, 08:41:48

  Press CTRL-A Z for help on special keys
#+END_EXAMPLE
******* font color
$ minicom -c on

.bashrc: export minicom="minicom -c on"
******* 基本使用
*Commands can be called by CTRL-A <key>*

|----------------------+----------------------+----------------------|
| Dialing directory..D | run script (Go)....G | Clear Screen.......C |
| Send files.........S | Receive files......R | cOnfigure Minicom..O |
| comm Parameters....P | Add linefeed.......A | Suspend minicom....J |
| Capture on/off.....L | Hangup.............H | eXit and reset.....X |
| send break.........F | initialize Modem...M | Quit with no reset.Q |
| Terminal settings..T | run Kermit.........K | Cursor key mode....I |
| lineWrap on/off....W | local Echo on/off..E | Help screen........Z |
| Paste file.........Y | Timestamp toggle...N | scroll Back........B |
| Add Carriage Ret...U |                      |                      |
|----------------------+----------------------+----------------------|

1. 发送

   进入开发板目录， Ctrl-A s 然后选择发送的文件

2. 接收
   sz filename 即可
****** Usage
+ http://linux.die.net/man/1/minicom
******* minicom(1) - Linux man page

******** Name

minicom - friendly serial communication program

******** Synopsis

*minicom* [-somMlwz8] [-c on|off] [-S script] [-d entry]

[-a on|off] [-t term] [-p pty] [-C capturefile] [/configuration/]
******** Description

*minicom* is a communication program which somewhat resembles the
shareware program TELIX but is free with source code and runs under most
unices. Features include dialing directory with auto-redial, support for
UUCP-style lock files on serial devices, a separate script language
interpreter, capture to file, multiple users with individual
configurations, and more.

******** Command-line

*-s*
*S*etup. Root edits the system-wide defaults in /etc/minirc.dfl with
this option. When it is used, minicom does /not/ initialize, but puts
you directly into the configuration menu. This is very handy if minicom
refuses to start up because your system has changed, or for the first
time you run minicom. For most systems, reasonable defaults are already
compiled in.

*-o*

Do not initialize. Minicom will skip the initialization code. This
option is handy if you quitted from minicom without resetting, and then
want to restart a session. It is potentially dangerous though: no check
for lock files etc. is made, so a normal user could interfere with
things like uucp... Maybe this will be taken out later. For now it is
assumed, that users who are given access to a modem are responsible
enough for their actions.

*-m*

Override command-key with the Meta or ALT key. This is the default in
1.80 and it can also be configured in one of minicom's menus, but if you
use different terminals all the time, of which some don't have a Meta or
ALT key, it's handy to set the default command key to Ctrl-A and use
this option when you have a keyboard supporting Meta or ALT keys.
Minicom assumes that your Meta key sends the ESC prefix, not the other
variant that sets the highest bit of the character.

*-M*

Same as -m, but assumes that your Meta key sets the 8th bit of the
character high (sends 128 + character code).

*-z*

Use terminal status line. This only works on terminals that support it
and that have the relevant information in their /termcap/ or /terminfo/
database entry.

*-l*

*L*iteral translation of characters with the high bit set. With this
flag on, minicom will try to translate the IBM line characters to ASCII.
Many PC-unix clones will display character correctly without translation
(Linux in a special mode, Coherent and Sco).

*-L*

Ditto but assume screen uses an ISO8859 character set.

*-w*

Turns line-wrap on at startup by default.

*-a*

*A*ttribute usage. Some terminals, notably Televideo's, have rotten
attribute handling (serial instead of parallel). By default, minicom
uses '-a on', but if you are using such a terminal you can (must!)
supply the option '-a off'. The trailing 'on' or 'off' is needed.

*-t*

*T*erminal type. With this flag, you can override the environment TERM
variable. This is handy for use in the MINICOM environment variable; one
can create a special termcap entry for use with minicom on the console,
that initializes the screen to raw mode so that in conjunction with the
-l flag, the IBM line characters are displayed untranslated.

*-c*

*C*olor usage. Some terminals (such as the Linux console) support color
with the standard ANSI escape sequences. Because there is apparently no
termcap support for color, these escape sequences are hard-coded into
minicom. Therefore this option is off by default. You can turn it on
with '-c on'. This, and the '-m' option, are good candidates to put into
the MINICOM environment variable.

*-S*

*script*. Run the named script at startup. So far, passing username and
password to a startup script is not supported. If you also use the -d
option to start dialing at startup, the -S script will be run BEFORE
dialing the entries specified with -d.

*-d*

*D*ial an entry from the dialing directory on startup. You can specify
an index number, but also a substring of the name of the entry. If you
specify a name that has multiple entries in the directory, they are all
tagged for dialing. You can also specify multiple names or index numbers
by separating them with commas. The dialing will start from the first
entry specified after all other program initialization procedures are
completed.

*-p*

*P*seudo terminal to use. This overrides the terminal port defined in
the configuration files, but only if it is a pseudo tty. The filename
supplied must be of the form (/dev/)tty[p-z/][0-f],
(/dev/)pts[p-z/][0-f] or (/dev/)pty[p-z/][0-f]. For example, /dev/ttyp1,
pts/0 or /dev/ptyp2.

*-C*

*filename*. Open capture file at startup.

*-T*

Disable the display of the online time in the status bar.

*-7*

7bit mode for terminals which aren't 8bit capable. 8bit is default if
the environment is configured for this via LANG or LC_ALL, 7bit
otherwise.

*-8*

8bit characters pass through without any modification. 'Continuous'
means no locate/attribute control sequences are inserted without real
change of locate/attribute. This mode is to display 8bit multi-byte
characters such as Japanese. Not needed in every language with 8bit
characters. (For example displaying Finnish text doesn't need this.)
When *minicom* starts, it first searches the MINICOM environment
variable for command-line arguments, which can be over-ridden on the
command line. Thus, if you have done
MINICOM='-m -c on'\\
 export MINICOM
or the equivalent, and start minicom, minicom will assume that your
terminal /has/ a Meta or <ALT> key and that color is supported. If you
then log in from a terminal without color support, and you have set
MINICOM in your startup (.profile or equivalent) file, and don't want to
re-set your environment variable, you can type 'minicom -c off' and run
without color support for that session.
*configuration*
The /configuration/ argument is more interesting. Normally, minicom gets
its defaults from a file called "minirc.dfl". If you however give an
argument to minicom, it will try to get its defaults from a file called
"minirc./configuration/". So it is possible to create multiple
configuration files, for different ports, different users etc. Most
sensible is to use device names, such as tty1, tty64, sio2 etc. If a
user creates his own configuration file, it will show up in his home
directory as '.minirc.dfl'.
******** Use

Minicom is window based. To popup a window with the function you want,
press Control-A (from now on, we will use C-A to mean Control-A), and
then the function key (a-z or A-Z). By pressing C-A first and then 'z',
a help screen comes up with a short summary of all commands. This escape
key can be altered when minicom is configured (-s option or C-A O), but
we'll stick to Control-A for now.

For every menu the next keys can be used:

*UP*
arrow-up or 'k'

*DOWN*

arrow-down or 'j'

*LEFT*

arrow-left or 'h'

*RIGHT*

arrow-right or 'l'

*CHOOSE*

Enter

*CANCEL*

ESCape.
The screen is divided into two portions: the upper 24 lines are the
terminal-emulator screen. In this window, ANSI or VT100 escape sequences
are interpreted. If there is a line left at the bottom, a status line is
placed there. If this is not possible the status line will be showed
every time you press C-A. On terminals that have a special status line
that will be used if the termcap information is complete /and/ the *-k*
flag has been given.
Possible commands are listed next, in alphabetical order.
*C-A*
Pressing C-A a second time will just send a C-A to the remote system. If
you have changed your "escape character" to something other than C-A,
this works analogously for that character.

*A*

Toggle 'Add Linefeed' on/off. If it is on, a linefeed is added before
every carriage return displayed on the screen.

*B*

Gives you a scroll back buffer. You can scroll up with *u*, down with
*d*, a page up with *b*, a page down with *f*, and if you have them the
*arrow* and *page up/page down* keys can also be used. You can search
for text in the buffer with *s* (case-sensitive) or *S*
(case-insensitive). *N* will find the next occurrence of the string. *c*
will enter citation mode. A text cursor appears and you specify the
start line by hitting Enter key. Then scroll back mode will finish and
the contents with prefix '>' will be sent.

*C*

Clears the screen.

*D*

Dial a number, or go to the dialing directory.

*E*

Toggle local echo on and off (if your version of minicom supports it).

*F*

A break signal is sent to the modem.

*G*

Run script (Go). Runs a login script.

*H*

Hangup.

*I*

Toggle the type of escape sequence that the cursor keys send between
normal and applications mode. (See also the comment about the status
line below).

*J*

Jump to a shell. On return, the whole screen will be redrawn.

*K*

Clears the screen, runs kermit and redraws the screen upon return.

*L*

Turn Capture file on off. If turned on, all output sent to the screen
will be captured in the file too.

*M*

Sends the modem initialization string. If you are online and the DCD
line setting is on, you are asked for confirmation before the modem is
initialized.

*O*

Configure minicom. Puts you in the configuration menu.

*P*

Communication Parameters. Allows you to change the bps rate, parity and
number of bits.

*Q*

Exit minicom without resetting the modem. If macros changed and were not
saved, you will have a chance to do so.

*R*

Receive files. Choose from various protocols (external). If you have the
filename selection window and the prompt for download directory enabled,
you'll get a selection window for choosing the directory for
downloading. Otherwise the download directory defined in the Filenames
and paths menu will be used.

*S*

Send files. Choose the protocol like you do with the receive command. If
you don't have the filename selection window enabled (in the File
transfer protocols menu), you'll just have to write the *filename*(s) in
a dialog window. If you have the selection window enabled, a window will
pop up showing the filenames in your upload directory. You can tag and
untag filenames by pressing spacebar, and move the cursor up and down
with the cursor keys or j/k. The selected filenames are shown
highlighted. Directory names are shown [within brackets] and you can
move up or down in the directory tree by pressing the spacebar twice.
Finally, send the files by pressing ENTER or quit by pressing ESC.

*T*

Choose Terminal emulation: Ansi(color) or vt100. You can also change the
backspace key here, turn the status line on or off, and define delay (in
milliseconds) after each newline if you need that.

*W*

Toggle line-wrap on/off.

*X*

Exit minicom, reset modem. If macros changed and were not saved, you
will have a chance to do so.

*Y*

Paste a file. Reads a file and sends its contests just as if it would be
typed in.

*Z*

Pop up the help screen.
******** Dialing Directory

By pressing C-A D the program puts you in the dialing directory. Select
a command by pressing the capitalized letter or moving cursor right/left
with the arrow keys or the h/l keys and pressing Enter. You can add,
delete or edit entries and move them up and down in the directory list.
By choosing "dial" the phone numbers of the tagged entries, or if
nothing is tagged, the number of the highlighted entry will be dialed.
While the modem is dialing, you can press escape to cancel dialing. Any
other key will close the dial window, but won't cancel the dialing
itself. Your dialing directory will be saved into the file ".dialdir" in
your home directory. You can scroll up and down with the arrow keys, but
you can also scroll complete pages by pressing the PageUp or PageDown
key. If you don't have those, use Control-B (Backward) and Control-F
(Forward). You can use the space bar to *tag* a number of entries and
minicom will rotate trough this list if a connection can't be made. A
'>' symbol is drawn in the directory before the names of the tagged
entries.

The "edit" menu speaks for itself, but I will discuss it briefly here.

*A - Name*
The name for this entry
*B - Number*
and its telephone number.
*C - Dial string #*
Which specific dial string you want to use to connect. There are three
different dial strings (prefixes and suffixes) that can be configured in
the *Modem and dialing* menu.
*D - Local echo*
can be on or off for this system (if your version of minicom supports
it).
*E - Script*
The script that must be executed after a successful connection is made
(see the manual for runscript)
*F - Username*
The username that is passed to the runscript program. It is passed in
the environment string "$LOGIN".
*G - Password*
The password is passed as "$PASS".
*H - Terminal Emulation*
Use ANSI or VT100 emulation.
*I - Backspace key sends*
What code (Backspace or Delete) the backspace key sends.
*J - Linewrap*
Can be on or off.
*K - Line settings*
Bps rate, bits, parity and number of stop bits to use for this
connection. You can choose *current* for the speed, so that it will use
whatever speed is being used at that moment (useful if you have multiple
modems).
*L - Conversion table*
You may specify a character conversion table to be loaded whenever this
entry answers, before running the login script. If this field is blank,
the conversion table stays unchanged.
The edit menu also shows the latest date and time when you called this
entry and the total number of calls there, but doesn't let you change
them. They are updated automatically when you connect.
The moVe command lets you move the highlighted entry up or down in the
dialing directory with the up/down arrow keys or the k and j keys. Press
Enter or ESC to end moving the entry.
******** Configuration

By pressing C-A O you will be thrown into the setup menu.

*Filenames and paths*

This menu defines your default directories.
*A - Download directory*
where the downloaded files go to.
*B - Upload directory*
where the uploaded files are read from.
*C - Script directory*
Where you keep your login scripts.
*D - Script program*
Which program to use as the script interpreter. Defaults to the program
"runscript", but if you want to use something else (eg, /bin/sh or
"expect") it is possible. Stdin and stdout are connected to the modem,
stderr to the screen.
If the path is relative (ie, does not start with a slash) then it's
relative to your home directory, except for the script interpreter.
*E - Kermit program*
Where to find the executable for kermit, and it's options. Some simple
macro's can be used on the command line: '%l' is expanded to the
complete filename of the dial out-device, '%f' is expanded to the serial
port file descriptor and '%b' is expanded to the current serial port
speed.
*F - Logging options*
Options to configure the logfile writing.
*A - File name*
Here you can enter the name of the logfile. The file will be written in
your home directory, and the default value is "minicom.log". If you
blank the name, all logging is turned off.

*B - Log connects and hangups*
This option defines whether or not the logfile is written when the
remote end answers the call or hangs up. Or when you give the hangup
command yourself or leave minicom without hangup while online.

*C - Log file transfers*
Do you want log entries of receiving and sending files.

The 'log' command in the scripts is not affected by logging options B
and C. It is always executed, if you just have the name of the log file
defined.
*File Transfer Protocols*
Protocols defined here will show up when C-A s/r is pressed. "Name" in
the beginning of the line is the name that will show up in the menu.
"Program" is the path to the protocol. "Name" after that defines if the
program needs an argument, e.g. a file to be transmitted. U/D defines if
this entry should show up in the upload or the download menu. Fullscr
defines if the program should run full screen, or that minicom will only
show it's stderr in a window. IO-Red defines if minicom should attach
the program's standard in and output to the modem port or not. "Multi"
tells the filename selection window whether or not the protocol can send
multiple files with one command. It has no effect on download protocols,
and it is also ignored with upload protocols if you don't use the
filename selection window. The old sz and rz are not full screen, and
have IO-Red set. However, there are curses based versions of at least rz
that do not want their stdin and stdout redirected, and run full screen.
All file transfer protocols are run with the UID of the user, and not
with UID=root. '%l', '%f' and '%b' can be used on the command line as
with kermit. Within this menu you can also define if you want to use the
filename selection window when prompted for files to upload, and if you
like to be prompted for the download directory every time the automatic
download is started. If you leave the download directory prompt
disabled, the download directory defined in the file and directory menu
is used.
*Serial port setup*
*A - Serial device*
/dev/tty1 or /dev/ttyS1 for most people. /dev/cua<n> is still possible
under linux, but not recommended any more because these devices are
obsolete and many newly installed systems with kernel 2.2.x or newer
don't have them. Use /dev/ttyS<n> instead. You may also have /dev/modem
as a symlink to the real device.\\
 If you have modems connected to two or more serial ports, you may
specify all of them here in a list separated by space, comma or
semicolon. When Minicom starts, it checks the list until it finds an
available modem and uses that one. (However, you can't specify different
init strings to them ..at least not yet.)\\
 To use a UNIX socket for communication the device name must be prefixed
with "unix#" following by the full path and the filename of the socket.
Minicom will then try to connect to this socket as a client. As long as
it cannot connect to the socket it stays 'offline'. As soon as the
connection establishes, minicom goes 'online'. If the server closes the
socket, minicom switches to 'offline' again.
*B - Lock file location*
On most systems This should be /usr/spool/uucp. Linux systems use
/var/lock. If this directory does not exist, minicom will not attempt to
use lockfiles.
*C - Callin program*
If you have a uugetty or something on your serial port, it could be that
you want a program to be run to switch the modem cq. port into
dialin/dialout mode. This is the program to get into dialin mode.
*D - Callout program*
And this to get into dialout mode.
*E - Bps/Par/Bits*
Default parameters at startup.
If one of the entries is left blank, it will not be used. So if you
don't care about locking, and don't have a getty running on your
modemline, entries B - D should be left blank.
*Modem and Dialing*
Here, the parameters for your modem are defined. I will not explain this
further because the defaults are for generic Hayes modems, and should
work always. This file is not a Hayes tutorial :-) The only things worth
noticing are that control characters can be sent by prefixing them with
a '\^', in which '\^\^' means '\^' itself, and the '\' character must
also be doubled as '\\', because backslash is used specially in the
macro definitions. Some options however, don't have much to do with the
modem but more with the behaviour of minicom itself:
*M - Dial time*
The number of seconds before minicom times out if no connection is
established.
*N - Delay before redial*
Minicom will redial if no connection was made, but it first waits some
time.
*O - Number of tries*
Maximum number of times that minicom attempts to dial.
*P - Drop DTR time*
If you set this to 0, minicom hangs up by sending a Hayes-type hangup
sequence. If you specify a non-zero value, the hangup will be done by
dropping the DTR line. The value tells in seconds how long DTR will be
kept down.
*Q - Auto bps detect*
If this is on, minicom tries to match the dialed party's speed. With
most modern modems this is NOT desirable, since the modem buffers the
data and converts the speed.
*R - Modem has DCD line*
If your modem, and your O/S both support the DCD line (that goes 'high'
when a connection is made) minicom will use it. When you have this
option on, minicom will also NOT start dialing while you are already
online.
*S - Status line shows DTE speed / line speed*
You can toggle the status line to show either the DTE speed (the speed
which minicom uses to communicate with your modem) or the line speed
(the speed that your modem uses on the line to communicate with the
other modem). Notice that the line speed may change during the
connection, but you will still only see the initial speed that the
modems started the connection with. This is because the modem doesn't
tell the program if the speed is changed. Also, to see the line speed,
you need to have the modem set to show it in the connect string.
Otherwise you will only see 0 as the line speed.
*T - Multi-line untag*
You can toggle the feature to untag entries from the dialing directory
when a connection is established to a multi-line BBS. All the tagged
entries that have the same name are untagged.
*Note that a special exception is made for this menu: every user can
change all parameters here, but some of them will not be saved.*
*Screen and keyboard*
*A - Command key is*
the 'Hot Key' that brings you into command mode. If this is set to 'ALT'
or 'meta key', you can directly call commands by alt-key instead of
HotKey-key.
*B - Backspace key sends*
There still are some systems that want a VT100 to send DEL instead of
BS. With this option you can enable that stupidity. (Eh, it's even on by
default...)
*C - Status line is*
Enabled or disabled. Some slow terminals (for example, X-terminals)
cause the status line to jump "up and down" when scrolling, so you can
turn it off if desired. It will still be shown in command-mode.
*D - Alarm sound*
If turned on, minicom will sound an alarm (on the console only) after a
successful connection and when up/downloading is complete.
*E - Foreground Color (menu)*
indicates the foreground color to use for all the configuration windows
in minicom.
*F - Background Color (menu)*
indicates the background color to use for all the configuration windows
in minicom. Note that minicom will not allow you to set foreground and
background colors to the same value.
*G - Foreground Color (term)*
indicates the foreground color to use in the terminal window.
*H - Background Color (term)*
indicates the background color to use in the terminal window. Note that
minicom will not allow you to set foreground and background colors to
the same value.
*I - Foreground Color (stat)*
indicates the foreground color to use in for the status bar.
*J - Background Color (stat)*
indicates the color to use in for the status bar. Note that minicom will
allow you to set the status bar's foreground and background colors to
the same value. This will effectively make the status bar invisible but
if these are your intentions, please see the option
*K - History buffer size*
The number of lines to keep in the history buffer (for backscrolling).
*L - Macros file*
is the full path to the file that holds macros. Macros allow you to
define a string to be sent when you press a certain key. In minicom, you
may define F1 through F10 to send up to 256 characters [this is set at
compile time]. The filename you specify is verified as soon as you hit
ENTER. If you do not have permissions to create the specified file, an
error message will so indicate and you will be forced to re-edit the
filename. If you are permitted to create the file, minicom checks to see
if it already exists. If so, it assumes it's a macro file and reads it
in. If it isn't, well, it's your problem :-) If the file does not exist,
the filename is accepted.
*M - Edit Macros*
opens up a new window which allows you to edit the F1 through F10
macros.
*N - Macros enabled*
- Yes or No. If macros are disabled, the F1-F10 keys will just send the
VT100/VT220 function key escape sequences.
*O - Character conversion*
The active conversion table filename is shown here. If you can see no
name, no conversion is active. Pressing O, you will see the conversion
table edit menu.
*Edit Macros*
Here, the macros for F1 through F10 are defined. The bottom of the
window shows a legend of character combinations that have special
meaning. They allow you to enter special control characters with plain
text by prefixing them with a '\^', in which '\^\^' means '\^' itself.
You can send a 1 second delay with the '\^~' code. This is useful when
you are trying to login after ftp'ing or telnet'ing somewhere. You can
also include your current username and password from the phone directory
in the macros with '\u' and '\p', respectively. If you need the
backslash character in the macro, write it doubled as '\\'. To edit a
macro, press the number (or letter for F10) and you will be moved to the
end of the macro. When editing the line, you may use the left & right
arrows, Home & End keys, Delete & BackSpace, and ESC and RETURN. ESC
cancels any changes made while ENTER accepts the changes.
*Character conversion*
Here you can edit the character conversion table. If you are not an
American, you know that in many languages there are characters that are
not included in the ASCII character set, and in the old times they may
have replaced some less important characters in ASCII and now they are
often represented with character codes above 127. AND there are various
different ways to represent them. This is where you may edit conversion
tables for systems that use a character set different from the one on
your computer.
*A - Load table*
You probably guessed it. This command loads a table from the disk. You
are asked a file name for the table. Predefined tables .mciso, .mcpc8
and .mcsf7 should be included with the program. Table .mciso does no
conversion, .mcpc8 is to be used for connections with systems that use
the 8-bit pc character set, and .mcsf7 is for compatibility with the
systems that uses the good old 7-bit coding to replace the characters
{|}[]\ with the diacritical characters used in Finnish and Swedish.

*B - Save table*
This one saves the active table on the filename you specify.

*C - edit char*
This is where you can make your own modifications to the existing table.
First you are asked the character value (in decimal) whose conversion
you want to change. Next you'll say which character you want to see on
your screen when that character comes from the outside world. And then
you'll be asked what you want to be sent out when you enter that
character from your keyboard.

*D - next screen*
*E - prev screen*
Yeah, you probably noticed that this screen shows you what kind of
conversions are active. The screen just is (usually) too small to show
the whole table at once in an easy-to-understand format. This is how you
can scroll the table left and right.

*F - convert capture*
Toggles whether or not the character conversion table is used when
writing the capture file.

*Save setup as dfl*
Save the parameters as the default for the next time the program is
started. Instead of dfl, any other parameter name may appear, depending
on which one was used when the program was started.
*Save setup as..*
Save the parameters under a special name. Whenever Minicom is started
with this name as an argument, it will use these parameters. This option
is of course privileged to root.
*Exit*
Escape from this menu without saving. This can also be done with ESC.
*Exit from minicom*
Only root will see this menu entry, if he/she started minicom with the
'-s' option. This way, it is possible to change the configuration
without actually running minicom.
******** Status Line

The status line has several indicators, that speak for themselves. The
mysterious APP or NOR indicator probably needs explanation. The VT100
cursor keys can be in two modes: applications mode and cursor mode. This
is controlled by an escape sequence. If you find that the cursor keys do
not work in, say, vi when you're logged in using minicom then you can
see with this indicator whether the cursor keys are in applications or
cursor mode. You can toggle the two with the C-A I key. If the cursor
keys then work, it's probably an error in the remote system's termcap
initialization strings (is).

******** Locales

Minicom has support for local languages. This means you can change most
of the English messages and other strings to another language by setting
the environment variable LANG.

******** Misc

If minicom is hung, kill it with SIGTERM . (This means kill -15, or
since sigterm is default, just plain "kill <minicompid>". This will
cause a graceful exit of minicom, doing resets and everything. You may
kill minicom from a script with the command "! killall -9 minicom"
without hanging up the line. Without the -9 parameter, minicom first
hangs up before exiting.

Since a lot of escape sequences begin with ESC (Arrow up is ESC [ A),
Minicom does not know if the escape character it gets is you pressing
the escape key, or part of a sequence.

An old version of Minicom, V1.2, solved this in a rather crude way: to
get the escape key, you had to press it /twice/.

As of release 1.3 this has bettered a little: now a 1-second timeout is
builtin, like in vi. For systems that have the select() system call the
timeout is 0.5 seconds. And... surprise: a special Linux-dependant
*hack* :-) was added. Now, minicom can separate the escape key and
escape-sequences. To see how dirty this was done, look into wkeys.c. But
it works like a charm!

******** Files

Minicom keeps it's configuration files in one directory, usually
/var/lib/minicom, /usr/local/etc or /etc. To find out what default
directory minicom has compiled in, issue the command /minicom -h/.
You'll probably also find the demo files for *[[runscript]]*(1), and the
examples of character conversion tables either there or in the
subdirectories of /usr/doc/minicom*. The conversion tables are named
something like mc.* in that directory, but you probably want to copy the
ones you need in your home directory as something beginning with a dot.

#+BEGIN_EXAMPLE
    minicom.users
    minirc.*
    $HOME/.minirc.*
    $HOME/.dialdir
    $HOME/minicom.log
    /usr/share/locale/*/LC_MESSAGES/minicom.mo
#+END_EXAMPLE

******** See Also

*[[runscript]]*(1)

******** Bugs

Please report any bugs to
/[[mailto:minicom-devel@lists.alioth.debian.org][minicom-devel@lists.alioth.debian.org]]/.
Thank you!

******** Authors

The original author of minicom is Miquel van Smoorenburg
([[mailto:miquels@cistron.nl][miquels@cistron.nl]]). He wrote versions
up to 1.75.\\
 Jukka Lahtinen ([[mailto:walker@netsonic.fi][walker@netsonic.fi]],
[[mailto:jukkal@despammed.com][jukkal@despammed.com]]) has been
responsible for new versions since 1.78, helped by some other people,
including:\\
 [[mailto:filipg@paranoia.com][filipg@paranoia.com]] wrote the History
buffer searching to 1.79.\\
 Arnaldo Carvalho de Melo
([[mailto:acme@conectiva.com.br][acme@conectiva.com.br]]) did the
internationalization and the Brasilian Portuguese translations.\\
 Jim Seymour
([[mailto:jseymour@jimsun.linxnet.com][jseymour@jimsun.LinxNet.com]])
wrote the multiple modem support and the filename selection window used
since 1.80.\\
 Tomohiro Kubota ([[mailto:kubota@debian.or.jp][kubota@debian.or.jp]])
wrote the Japanese translations and the citation facility, and did some
fixes.\\
 Gael Queri ([[mailto:gqueri@mail.dotcom.fr][gqueri@mail.dotcom.fr]])
wrote the French translations.\\
 Arkadiusz Miskiewicz ([[mailto:misiek@pld.org.pl][misiek@pld.org.pl]])
wrote the Polish translations.\\
 Kim Soyoung ([[mailto:nexti@chollian.net][nexti@chollian.net]]) wrote
the Korean translations.\\
 Jork Loeser
([[mailto:jork.loeser@inf.tu-dresden.de][jork.loeser@inf.tu-dresden.de]])
provided the socket extension.

Most of this man page is copied, with corrections, from the original
minicom README, but some pieces and the corrections are by Michael K.
Johnson.

Jukka Lahtinen ([[mailto:walker@netsonic.fi][walker@netsonic.fi]]) has
added some information of the changes made after version 1.75.

******** Referenced By

*[[ascii-xfr]]*(1), *[[/man/8/gnokiid][gnokiid]]*(8),
*[[/man/4/isdn_audio][isdn_audio]]*(4),
*[[/man/8/picocom][picocom]]*(8), *[[qodem]]*(1),
*[[/man/4/ttyi][ttyi]]*(4), *[[xminicom]]*(1)









-  Site Search ::

-  Library :: [[http://linux.die.net/][linux docs]]
   [[http://linux.die.net/man/][linux man pages]]
   [[http://www.die.net/musings/page_load_time/][page load time]]

-  Toys :: [[http://www.die.net/earth/][world sunlight]]
   [[http://www.die.net/moon/][moon phase]]
   [[http://trace.die.net/][trace explorer]]

-  [[/man/1/][[[/style/back.gif]]]] ::





****** 配置
+ http://blog.csdn.net/bird67/article/details/2127235
******* $ minicom -s

1. Filenames and paths
2. File transfer protocols
3. Serial port setup
   + 设备名 e.g. /dev/ttyUSB0,  /dev/ttyACM0(Arduino)
   + 波特率等
   + *Hardware Flow Control: No* ??

4. Modem and dialing
   我们使用minicom作为超级终端控制路由器等设备, 而不是控制modem, 所以
   需要修改Modem and dialing, 将Init string, Reset string, Hang-up
   string设置为空

5. Screen and keyboard
6. Save setup as dfl
   + default config file
7. Save setup as
8. Exit
9. Exit from Minicom

**** USB
***** lsusb
***** dmesg | grep usb | grep tty
[40205.212182] usb 7-2: ch341-uart converter now attached to ttyUSB0

*** arm family
**** arm family

#+downloaded: /tmp/screenshot.png @ 2015-06-09 17:16:09
 [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_17:16:09.png]]
1. 芯片： 6410, 210，2440
2. arm核： a8, arm11, am9
3. 指令架构：armv7, armv6

2440(arm9(v4))
210(arm11(v6))
210(cortexa8(v7))
**** arm核

#+downloaded: /tmp/screenshot.png @ 2015-06-09 17:22:40
 [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_17:22:40.png]]

arm经典
cortex-m 无操作系统
cortex-r 实时
cortex-a 多媒体

**** 芯片对比
|----------+-------------+---------------------+---------------------|
|          | 2410        | 6440                | 210                 |
|----------+-------------+---------------------+---------------------|
| 处理速度 | 400-500     | 533-667             | 800-1g              |
| 缓存     | 16k         | 16k                 | 32k                 |
| 内在接口 | sdram       | sdram/ddr           | ddr1/ddr2           |
| 支持os   | wince/linux | wince/linux/android | wince/linux/android |
| 其它     | 商业停产    |                     |                     |
|----------+-------------+---------------------+---------------------|

*** 存储器格式(memory format)
**** big-endian format
in big-endian format(), the most significant byte(msb) of a world is
stored at the lowest numbered byte and the least significant byte(lsb)
at the highest numbered byte.

+ big-endian: 大端优先
+ msb：最高有效字节
+ lsb：最低有效字节

#+downloaded: /tmp/screenshot.png @ 2015-07-02 11:42:30
 [[~/Wally/Journal/Figures/embeddedlinux/screenshot_2015-07-02_11:42:30.png]]
**** little-endial format
in little-endian format, the lowest numbered byte in a word is
considered the word's least significant byte, and the highest numbered
byte the most significant.

#+downloaded: /tmp/screenshot.png @ 2015-07-02 11:58:29
 [[~/Wally/Journal/Figures/embeddedlinux/screenshot_2015-07-02_11:58:29.png]]
*** data type
[[file:/media/ben/reserch/document/%e8%8a%af%e7%89%87%e6%89%8b%e5%86%8c/armarchitecturereferencemanual.pdf::%25pdf-1.3%0d][armarchitecturedatatypes]]


+ byte: 8 bits
+ halfword: 16 bits
+ word: 32 bits

*** arm工作模式
[[file:/media/ben/reserch/document/%e8%8a%af%e7%89%87%e6%89%8b%e5%86%8c/armarchitecturereferencemanual.pdf::%25pdf-1.3%0d][armarchitectureprocessormodel]]

processor mode: 权限和资源使用

#+downloaded: /tmp/screenshot.png @ 2015-06-09 18:57:39
 [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_18:57:39.png]]

1. usr: user
2. fiq: 快速中断
3. iro: 普通中断
4. svc: supervisor
5. abt: abort
6. und: undefined
7. sys: system(v4+)


mode changes can be made using the control of sotfware, or may be
brought about by external interrupts or exception processing.(切换)

most application programs will
内核： 运行在svc模式
用户程序： 运行在usr模式

*** arm寄存器

#+downloaded: /tmp/screenshot.png @ 2015-06-09 19:04:21
 [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:04:21.png]]

+ *37 registers*
  + 31 general registers(r0-r15)
    - unbanked registers(不分组，r1-r7)
    - banked registers(分组, r8-r14)
    - r15, pc指针
  + 6 status registers
#+downloaded: /tmp/screenshot.png @ 2015-06-09 19:08:20
 [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:08:20.png]]
**** general registers
+ r13 is normally used as a stack pointer(*sp*)
+ r14 link register(*lr*)
  - 保存函数返回地址
  - 中断返回地址
+ r15 program counter(*pc*)

**** status register
cpsr & spsr


#+downloaded: /tmp/screenshot.png @ 2015-06-09 19:16:54

#+downloaded: /tmp/screenshot.png @ 2015-06-09 19:17:14
 [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:17:14.png]]

+ n: 减法操作结果
+ z: 减法相等时为1
+ i: disable irq
+ e: disable fiq
+ m[4:0]: 处理器模式

*** arm寻址方式
+ 立即数寻址： #号开头

  #+downloaded: /tmp/screenshot.png @ 2015-06-09 19:23:12
   [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:23:12.png]]
+ 寄存器寻址：

  #+downloaded: /tmp/screenshot.png @ 2015-06-09 19:24:50
  [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:24:50.png]]
+ 寄存器间接寻址：方括号

  #+downloaded: /tmp/screenshot.png @ 2015-06-09 19:25:58
  [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:25:58.png]]
+ 基址变址寻址：
  [[
  ~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:27:30.png]]
+ 相对寻址

  #+downloaded: /tmp/screenshot.png @ 2015-06-09 19:29:26
  [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:29:26.png]]

*** arm汇编
**** arm汇编概述
***** 为什么学习汇编
+ bootloader和linux kernel初始化时需
  要使用汇编编写，一是效率高，二是还
  没有c的环境

+ 对效率有特殊要求的地方需要使用汇编

***** arm汇编分类
+ arm标准汇编：适用于arm公司的汇编器，适合在windows平台下使用，如ads
+ gnu汇编：适用于gnu交叉编译工具链中
  的汇编器，适合于linux开发平台

两种汇编相差不多，可以触类旁通

***** 汇编程序框架
#+begin_example
.section .data  ; 初始化的数据段
.section .bbs    ; 未初始化的数据段
.section .text
.global _start   ; 标记_start为全局
_start:               ; 程序入口
         <汇编>
#+end_example

+ 常见框架
  #+begin_example
  .text
  .global _start
  _start:
  #+end_example
+ 示例
  - 汇编代码
    #+begin_example
      .text
      .global _start
      _start:
          mov r1, #1
          mov r2, #2
          mov r3, #3
    #+end_example
  - makefile
    #+begin_example
      all:start.o
              arm-linux-ld -ttext 0x30000000 -o  start.elf $^
              # 写入内在之中，因此生成elf即可，写入flash中则需要生成进制文件
              # 没有使用链接器脚本，直接在makefile中指定内在地址，2440为30000000
      %.o : %.s
              arm-linux-gcc -g -o  $@ $^ -c
      clean:
              rm *.o *.elf
    #+end_example
  - todo 编写并调试简单的汇编程序

**** 指令分类学习

[[~/Wally/Journal/Figures/scrot/8571bvf.png]]

***** 算术和逻辑指令(参考资料：arm指令集.chm)
1. *mov*
   - 大小写：标准arm大写，gnu汇编小写
   - 汇编注释：@开头
   - 作用：mov 从另一个寄存器、被移位的寄存器、或一个立即值装载一个值
     到目的寄存器。
   - 格式：*mov{条件}{s}  <dest>, <op 1>*

2. *mvn*
   - mvn 从另一个寄存器、被移位的寄存器、或一个立即值装载一个值到目的
     寄存器。不同之处是在传送之前位被反转了，所以把一个被取反的值传送
     到一个寄存器中。why 取反？

   - mvn{条件}{s}  <dest>, <op 1>

   - dest = !op_1

3. *sub*
   - 做两个操作数的减法，把结果放置到目的寄存器中。

   - sbc{条件}{s}  <dest>, <op 1>, <op 2>

   - dest = op_1 - op_2 - !carry

   - 差值和被减数不能是立即数

4. *add*
   - 将把两个操作数加起来，把结果放置到目的寄存器中。操作数 1 是一个寄
     存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值

   - add{条件}{s}  <dest>, <op 1>, <op 2>

   - dest = op_1 + op_2

5. *and*
   - 将在两个操作数上进行逻辑与，把结果放置到目的寄存器中；对屏蔽你要
     在上面工作的位很有用。 操作数 1 是一个寄存器，操作数 2 可以是一个
     寄存器，被移位的寄存器，或一个立即值

   - and{条件}{s}  <dest>, <op 1>, <op 2>

   - dest = op_1 and op_2

6. *bic*
   - bic 是在一个字中清除位的一种方法，与 or 位设置是相反的操作。操作
     数 2 是一个 32 位位掩码(mask)。如果如果在掩码中设置了某一位，则清
     除这一位。未设置的掩码位指示此位保持不变。

   - bic{条件}{s}  <dest>, <op 1>, <op 2>

   - dest = op_1 and (!op_2)

   - 标准汇编中数字前缀%表示二进制，gun中使用0b前缀

***** 比较指令
1. *cmp*
   - cmp 允许把一个寄存器的内容如另一个寄存器的内容或立即值进行比较，
     更改状态标志来允许进行条件执行。它进行一次减法，但不存储结果，而
     是正确的更改标志。相减
   - cmp{条件}{p}  <op 1>, <op 2>
   - status = op_1 - op_2
2. *tst*
   - tst 类似于 cmp，不产生放置到目的寄存器中的结果。而是在给出的两个
     操作数上进行操作并把结果反映到状态标志上。按位与
   - tst{条件}{p}  <op 1>, <op 2>
***** 跳转指令
1. *b*
   - b{条件}
     #+begin_example
       示例
       mov r1, #6
       mov r2, # 5
       cmp r1, r2
       bfg branch1
       add r3, r1, r2
       b end
       branch:
           sub r3, r1, r2
       end:
       nop
       if(x>y)
           z = x-y
       else
           z = x+y
     #+end_example
2. *bl*
   - 带链接返回的跳转，即把当前地址复制到lr中，用于函数调用
     示例
     #+begin_example
       mov r1, #2
       mov r2, #3
       bl func1

       func1:
       mov r1, #2
       mov r2 , #3
       mov pc, lr  @ 函数返回
     #+end_example

***** 移位指令
1. lsl
   - logical or arithmetic shift left 逻辑算术左移
rx, lsl #n or
rx, asl #n or
rx, lsl rn or
rx, asl rn
mv r1, r1 , lss #2
ror
(rotate right) 循环右移
rx, ror #n or
rx, ror rn

***** 程序状态字访问指令
*不允许直接修改程序状态寄存器，使用专用指令，先移入通用寄存器，在通用
寄存器中修改，再写入状态寄存器*

1. *msr* （r: register, s: state）
2. *mrs*

eclipse可以监控内存
示例
#+begin_example
mrs r0, cpsr
orr r0, #0b100
msr cpsr, r0
#+end_example

***** 存储器访问指令
1. *ldr*: 内存->寄存器
2. *str*: 寄存器->内存

***** 条件执行
1. eq : 等于
   如果一次比较之后设置了 z 标志。

2. ne : 不等于
   如果一次比较之后清除了 z 标志。

3. vs : 溢出设置
   如果在一次算术操作之后设置了 v 标志，计算的结果不适合放入一个 32bit 目标寄存器中。

4. vc : 溢出清除
   如果清除了 v 标志，与 vs 相反。

5. hi : 高于(无符号)
   如果一次比较之后设置了 c 标志并清除了 z 标志。

6. ls : 低于或同于(无符号)
   如果一次比较操作之后清除了 c 标志或设置了 z 标志。

7. pl : 正号
   如果一次算术操作之后清除了 n。出于定义‘正号’的目的，零是正数的原因是它不是负数...

8. mi : 负号
   如果一次算术操作之后设置了 n 标志。

9. cs : 进位设置
   如果一次算术操作或移位操作之后设置了 c 标志，操作的结果不能表示为
   32bit。你可以把 c 标志当作结果的第 33 位。

10. cc : 进位清除
    与 cs 相反。

11. ge : 大于或等于(有符号)
    如果一次比较之后设置了 n 标志并设置了 v 标志或者清除了 n 标志并清除了 v 标志。

12. gt : 大于(有符号)
    如果一次比较之后设置了 n 标志并设置了 v 标志或者清除了 n 标志并清
    除了 v 标志并且清除了 z 标志。

13. le : 小于或等于(有符号)
    如果一次比较之后设置了 n 标志并清除了 v 标志或者清除了 n 标志并设置了 v 标志并且设置了 z 标志。

14. lt : 小于(有符号)
    如果一次比较之后设置了 n 标志并清除了 v 标志。或者清除了 n 标志并设置了 v 标志。

15. al : 总是
    缺省条件，所以不用明显声明。

16. nv : 从不
    不是特别有用，它表示应当永远不执行这个指令。是穷人的 nop。包含 nv 是为了完整性(与 al 相对)，你不应该在你的代码中使用它。
**** 伪指令
伪指令本身并没有对应的机器码，它只是在编译的时候起作用(宏定义)，或者转
化为其它的实际指令来运行(loop).
***** arm机器码
汇编程序->汇编器->机器码

elf -> objdump -> 机器码

+ 机器码为32位数
+ 被分成多个段

[[~/Wally/Journal/Figures/scrot/8571ofl.png]]

1. cond段， 31-28
   - al: 1110  # 无条件
   - eq: 0000
2. 27-26 保留位，为0
3. i位，立即数标志位， 25
   判断是否为立即数
4. opcode段，操作标志， 24-21
5. s段，20, 是否影响cpsr
6. rn 19-16
7. rd 目的寄存器 15-12
8. shifter_operand, 12位
   - 立即数有范围要求

***** 定义类伪指令
1. *global* 标明全局符号
   gnu arm前面会加一个句点 .global

2. *ascii*
   定义字符串

3. *byte*
   定义字节

4. *word*
   定义字

5. *data*
   存放在数据段
   #+begin_example
     .data
     hello:  # 需要标号
     .ascii "hello world"

     bh:
     .byte 0x1

     add:
     .word 0xff
   #+end_example

   *arm-linum-readelf* 读取elf文件信息

6. *equ*
   类似c中的宏定义
   #+begin_example
     .equ da, 0x89

     mv r0, #da
   #+end_example

7. *align* 数据地址对齐
   #+begin_example
   .align 4
   bh:
   byte 0x1
   #+end_example

***** 操作类伪指令
1. nop
   空操作，进行延时
   mv r0,  r0
2. ldr, 与存储器访问指令同名
   #+begin_example
     mov r0, #0x1ff  ; error: invalid constant
                     ; mov指令使用立即数不能超过8位

     ldr r0, =0x1ff  ; 需要使用=标明立即数, 不能用#
   #+end_example
   实现过程：将立即数先保存到内在中，然后使用ldr指令读入到寄存器中

**** 协处理器访问指令

***** 什么是协处理器

[[~/Wally/Journal/Figures/scrot/8571bpr.png]]

cp: coprecessor
协处理器， arm架构的重要组成部分，如数学协处理器控制数据处理

arm最多支持16个协处理器

cp15: provide additional registers that are used to configure and
control the caches,  mmu,  protectionn system ...
cp15 defines 16 registers

通过寄存器访问

***** 访问协处理器
1. *mcr*
   - c: coprocessor
   - r: register
2. *mrc*

[[~/Wally/Journal/Figures/scrot/8571ozx.png]]

** 51                                                                   :51:
** AVR                                                                 :avr:
*** atmel型号说明

atmel atmega系列芯片型号说明
atmegaxxx xx--xx xx
+ xxx =    8、16、48、128等芯片主型号
+ xx  =  “ p” 低电压、节能技术 ，  “ v”  1.8v-5.5v   不带“v”  2.7-5.5v ,      l   低频率
+ xx  =   20、10 代表时钟频率。
+ xx  =  规格信息：第一位代表封装 p：dip封装， a：tqfp封装， m：mlf封装 第二位字母，表示应用级别。“c”：商业级，“i”：工业级（有铅）、“u”工业级（无铅）。

例如：atmega48pv-10au
代表：atmega48  节能技术 低电压 时钟频率10  tqfp封装 工业级无

atmel attiny系列芯片型号说明
举例：attiny24-20ssu
其中attiny24为主型号
①、型号紧跟的字母，表示电压工作范围。带“v”：1.8-5.5v；若缺省，不带“v”：2.7-5.5v。
　　例：attiny24-20ssu，不带“v”表示工作电压为2.7-5.5v。
②、后缀的数字部分，表示支持的最高系统时钟。
　　例：attiny24-20ssu，“20”表示可支持最高为20mhz的系统时钟。
③、后缀第一（第二）个字母，表示封装。“p”：dip封装，“s”：sop封装，“ss”：ssop封装,“m”：mlf封装。
　　例：attiny24-20ssu，“ss”表示ssop封装。
④、后缀最后一个字母，表示应用级别。“c”：商业级，“i”：工业级（有铅）、“u”工业级（无铅）。
　　例：attiny24-20ssu，“u”表示无铅工业级。attiny24-20ssi，“i”表示有铅工业级。

**** 小结
1. atmel型号名称分为多个字段： atmega+主型号+后缀+时钟频率+封装等
2. avr单片机的型号有所改变，以上可能过时，仅做参考

*** Tutorial                                                     :tutorial:

+ [[http://www.avrvi.com/index_avr.html][AVR 教程]]
+ [[~/Wally/Reference/Textbook/AVR单片机嵌入式系统原理与应用实践.pdf][AVR单片机嵌入式系统原理与应用实践.pdf]]
+ [[http://www.ladyada.net/learn/avr/avrdude.html][Learn AVR]]

** DSP                                                                 :dsp:
*** dsp how                                                           :how:

*dsp只是工具，难得不是这个处理器，而是你在应用他时用的原理，技术。*

** FPGA                                                               :fpga:

** PLC                                                                 :plc:
* hardware                                                         :hardware:
** chip                                                               :chip:
*** 74HC573是锁存器                                        :74hc573:锁存器:

#+BEGIN_EXAMPLE
- State "DONE"       from ""           [2015-11-23 一 21:11] \\
  不用了解得过于详尽，反正都会忘记的，用的时候自然就会知道。但要知道是什
  么
#+END_EXAMPLE

74HC573是拥有八路输出的透明锁存器，输出为三态门，是一种高性能硅栅CMOS
器件。

+ [[http://baike.baidu.com/item/74HC573][百度百科： 74HC573]]
+ [[http://baike.baidu.com/view/629932.htm?fr=ala0_1_1][百度百科： 锁存器]]
+ [[https://app.yinxiang.com/shard/s52/nl/11551545/0731d37a-a288-4dce-926e-4e9e432a534c?title=74HC573%E9%94%81%E5%AD%98%E5%99%A8%E7%94%A8%E6%B3%95%20-%20The%20important%20thing%20in%20life%20is%20to%20have%20a%20great%20aim%20%2C%20and%20the%20determination%20to%20attain%20-%20%E5%BC%80%E6%BA%90%E4%B8%AD%E5%9B%BD%E7%A4%BE%E5%8C%BA][evernote: &4HC573]]

** sensor                                                           :sensor:
*** 步进电机
**** 步进电机
***** 特点
步进电机是一种将电脉冲转化为角位移的执行机构。

当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固
定的角度(称为“步距角”)，它的旋转是以固定的角度一步一步运行的。

+ 可以通过控制脉冲个数来控制角位移量，从而达到准确定位的目的；
+ 同时可以通过控制脉冲频率来控制电机转动的速度和加速度，从而达到调速的
  目的。

步进电机可以作为一种控制用的特种电机，利用其没有积累误差(精度为 100%)
的特点，广泛应用于各种开环控制。

***** 分类
现在比较常用的步进电机包括
1. 反应式步进电机（VR）

   反应式步进电机一般为三相，可实现大转矩输出，步进角一般为 1.5 度，但
   噪声和振动都很大.

   反应式步进电机的转子磁路由软磁材料制成，定子上有多相励磁绕组，利用
   磁导的变化产生转矩。

2. 永磁式步进电机（PM）

   永磁式步进电机一般为两相，转矩和体积较小，步进角一般为 7.5 度 或 15
   度.

3. 混合式步进电机（HB）
   混合式步进电机是指混合了永磁式和反应式的优点。它又分为两相和五相：
   两相步进角一般为 1.8 度而五相步进角一般为 0.72 度。这种步进电机的应
   用最为广泛，

4. 单相式步进电机

***** 参数
****** 步距角
它表示控制系统每发一个步进脉冲信号，电机所转动的角度。

电机出厂时给出了一个步距角的值，如 86BYG250A 型电机给出的值为
0.9°/1.8°（表示半步工作时为 0.9°、整步工作时为 1.8°），这个步距角
可以称之为‘电机固有步距角’，它不一定是电机实际工作时的真正步距角，真
正的步距角和驱动器有关。
****** 相数
是指电机内部的线圈组数，目前常用的有二相、三相、四相、五相步进电机。

电机相数不同，其步距角也不同，一般
+ 二相电机的步距角为 0.9°/1.8°
+ 三相的为 0.75°/1.5°
+ 五相的为 0.36°/0.72°

在没有细分驱动器时，用户主要靠选择不同相数的步进电机来满足自己步距角的
要求。如果使用细分驱动器，则‘相数’将变得没有意义，用户只需在驱动器上
改变细分数，就可以改变步距角。

****** 保持转矩(HOLDING TORQUE)
是指步进电机通电但没有转动时，定子锁住转子的力矩。

它是步进电机最重要的参数之一，通常步进电机在低速时的力矩接近保持转矩。

由于步进电机的输出力矩随速度的增大而不断衰减，输出功率也随速度的增大而
变化，所以保持转矩就成为了衡量步进电机最重要的参数之一。

比如，当人们说 2N.m 的步进电机，在没有特殊说明的情况下是指保持转矩为
2N.m 的步进电机。

**** 驱动

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{~/Tiger/Figures/1503290121.jpg}
\end{figure}


不管是两相四线，两相五线，两相六线步进电机, 内部构造都是如此。至于究竟
是四线，五线，还是六线。就要看A和~A之间，B和B~之间有没有公共端com抽线。
如果a组和b组各自有一个com端，则该步进电机六线，如果a和b组的公共端连在
一起，则是5线的。

要弄清步进电机如何接线，只需把a组和b组分开。用万用表打。

+ 四线：由于四线没有com公共抽线，所以，a和b组是绝对绝缘的，不连通的。
  所以，用万用表测，不连通的是一组。
+ 五线：由于五线中，a和b组的公共端是连接在一起的。用万用表测，当发现有
  一根线和其他几根线的电阻是相当的，那么，这根线就是公共com端。对于驱
  动五线步进电机，公共com端不连接也是可以驱动步进电机的。
+ 六线：a和b组的公共抽线com端是不连通的。同样，用万用表测电阻，发现其
  中一根线和其他两根线阻止是一样的，那么这根线是com端，另2根线就属于一
  组。对于驱动四相六线步进电机，两根公共com端不接先也可以驱动该步进电
  机的。

相关概念
+ 相数：产生不同对极N、S磁场的激磁线圈对数。常用m表示。
+ 拍数：完成一个磁场周期性变化所需脉冲数或导电状态用n表示，或指电机转
  过一个齿距角所需脉冲数，以四相电机为例，有四相四拍运行方式即
  AB-BC-CD-DA-AB，四相八拍运行方式即 A-AB-B-BC-C-CD-D-DA-A.
+ 步距角：对应一个脉冲信号，电机转子转过的角位移用θ表示。θ=360度（转子齿数J*运行拍数），以常规二、四相，转子齿为50齿电机为例。四拍运行时步距角为θ=360度/（50*4）=1.8度（俗称整步），八拍运行时步距角为θ=360度/（50*8）=0.9度（俗称半步）。
+ 定位转矩：电机在不通电状态下，电机转子自身的锁定力矩（由磁场齿形的谐
  波以及机械误差造成的）
+ 静转矩：电机在额定静态电作用下，电机不作旋转运动时，电机转轴的锁定力
  矩。此力矩是衡量电机体积（几何尺寸）的标准，与驱动电压及驱动电源等无
  关。


驱动步进电机，无非是给电机a和b组先轮流给连续的脉冲，步进电机就可以驱动
了。

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{~/Tiger/Figures/1503290149.jpg}
\end{figure}


1. 8拍的方式
   1) 在A与A-正电压，B与B-不给电悬空
   2) 在A与A-正电压，B与B-也给正电压
   3) A与A-不给电压悬空，B与B-正电压
   4) A与A-给负电压，B与B-给正电压
   5) A与A-给负电压，B与B-不给悬空
   6) A与A-给负电压，B与B-给负电压
   7) A与A-不给电悬空，B与B-给负电压
   8) A与给正电压，B与B-给负电压

   按以上八个状态轮流供电，控制一下脉宽应该就可以了。
   四个引脚各一根控制线：A~H表示各线时序
   |----+---+---+---+---+---+---+---+---|
   |    | A | B | C | D | E | F | G | H |
   |----+---+---+---+---+---+---+---+---|
   | A  | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 |
   | A- | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 |
   | B  | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
   | B- | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
   |----+---+---+---+---+---+---+---+---|

2. 4拍的方式
   一般是电流驱动的。 我下面的a~ 和b~ 表示反向电流。
   两相双二拍
   1) 正向
      + ab
      + a~b
      + a~b~
      + ab~
   2) 反向
      + ab
      + ab~
      + a~b~
      + a~b

**** 双极性与单极性驱动电路
单极性 (unipolar) 和双极性 (bipolar) 是步进电机最常采用的两种驱动架构。

单极性驱动电路使用四颗晶体管来驱动步进电机的两组相位，电机结构则如图1
所示包含两组带有中间抽头的线圈，整个电机共有六条线与外界连接。这类电机
有时又称为四相电机，但这种称呼容易令人混淆又不正确，因为它其实只有两个
相位，精确的说法应是双相位六线式步进电机。六线式步进电机虽又称为单极性
步进电机，实际上却能同时使用单极性或双极性驱动电路。



双极性步进电机的驱动电路则如图2所示，它会使用八颗晶体管来驱动两组相位。
双极性驱动电路可以同时驱动四线式或六线式步进电机，虽然四线式电机只能使
用双极性驱动电路，它却能大幅降低量产型应用的成本。双极性步进电机驱动电
路的晶体管数目是单极性驱动电路的两倍，其中四颗下端晶体管通常是由微控制
器直接驱动，上端晶体管则需要成本较高的上端驱动电路。双极性驱动电路的晶
体管只需承受电机电压，所以它不像单极性驱动电路一样需要箝位电路。

**** L6219
The L6219 is a bipolar monolithic integrated circuits intended to
control and drive both winding of a bipolar stepper motor or
bidirectionally control two DC motors.

**** 细分
***** 概念
细分的基本概念为：步进电机通过细分驱动器的驱动，其步距角变小了。

如驱动器工作在 10 细分状态时，其步距角只为‘电机固有步距角’的十分之一，
也就是：当驱动器工作在不细分的整步状态时，控制系统每发一个步进脉冲，电
机转动 1.8°；而用细分驱动器工作在 10 细分状态时，电机只转动了 0.18°。
细分功能完全是由驱动器靠精确控制电机的相电流所产生的，与电机无关.

***** 优点
步进电机的细分技术实质上是一种电子阻尼技术（请参考有关文献），其主要目的是提
高电机的运转精度，实现步进电机步距角的高精度细分。其次，细分技术的附带功能是减弱
或消除步进电机的低频振动，低频振荡是步进电机（尤其是反应式电机）的固有特性，而细
分是消除它的唯一途径，如果步进电机有时要在共振区工作（如走圆弧），选择细分驱动器
是唯一的选择。

驱动器细分后的主要优点为：
+ 完全消除了电机的低频振荡
+ 提高了电机的输出转矩，尤其是对三相反应式电机，其力矩比不细分时提高约 30-40%
+ 提高了电机的分辨率，由于减小了步距角、提高了步距的均匀度，‘提高电机
  的分辨率’是不言而喻的。

***** 技术水平
目前，国内外的步进电动机细分技术的最高微步距细分水平为 25.5″，而随着科学和工
业技术发展，这一细分水平对于目前很多要求 5″以下的微步距角来说，仍远远不能满足要
求。

** storage                                                  :storage:memory:
*** flash                                                           :flash:
**** Nand Flash 和 Nor Flash的区别
***** 区别
NOR和NAND是现在市场上两种主要的非易失闪存技术。Intel于1988年首先开发出
NOR flash技术，彻底改变了原先由EPROM和EEPROM一统天下的局面。紧接着，
1989年，东芝公司发表了NAND flash结构，强调降低每比特的成本，更高的性能，
并且象磁盘一样可以通过接口轻松升级。但是经过了十多年之后，仍然有相当多
的硬件工程师分不清NOR和NAND闪存。

相“flash存储器”经常可以与相“NOR存储器”互换使用。许多业内人士也搞不
清楚NAND闪存技术相对于NOR技术的优越之处，因为大多数情况下闪存只是用来
存储少量的代码，这时NOR闪存更适合一些。而NAND则是高数据存储密度的理想
解决方案。

NOR的特点是芯片内执行(XIP, eXecute In Place)，这样应用程序可以直接在
flash闪存内运行，不必再把代码读到系统RAM中。NOR的传输效率很高，在1～
4MB的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响了它
的性能。

NAND结构能提供极高的单元密度，可以达到高存储密度，并且写入和擦除的速度
也很快。应用NAND的困难在于flash的管理和需要特殊的系统接口。

***** 对比
****** 性能比较
flash闪存是非易失存储器，可以对称为块的存储器单元块进行擦写和再编程。
任何flash器件的写入操作只能在空或已擦除的单元内进行，所以大多数情况下，
在进行写入操作之前必须先执行擦除。NAND器件执行擦除操作是十分简单的，而
NOR则要求在进行擦除前先要将目标块内所有的位都写为0。

由于擦除NOR器件时是以64～128KB的块进行的，执行一个写入/擦除操作的时间
为5s，与此相反，擦除NAND器件是以8～32KB的块进行的，执行相同的操作最多
只需要4ms。

执行擦除时块尺寸的不同进一步拉大了NOR和NADN之间的性能差距，统计表明，
对于给定的一套写入操作(尤其是更新小文件时)，更多的擦除操作必须在基于
NOR的单元中进行。这样，当选择存储解决方案时，设计师必须权衡以下的各项
因素。

+ NOR的读速度比NAND稍快一些。
+ NAND的写入速度比NOR快很多。
+ NAND的4ms擦除速度远比NOR的5s快。
+ 大多数写入操作需要先进行擦除操作。
+ NAND的擦除单元更小，相应的擦除电路更少。

****** 接口差别
NOR flash带有SRAM接口，有足够的地址引脚来寻址，可以很容易地存取其内部
的每一个字节。

NAND器件使用复杂的I/O口来串行地存取数据，各个产品或厂商的方法可能各不
相同。8个引脚用来传送控制、地址和数据信息。

NAND读和写操作采用512字节的块，这一点有点像硬盘管理此类操作，很自然地，
基于NAND的存储器就可以取代硬盘或其他块设备。

****** 容量和成本
NAND flash的单元尺寸几乎是NOR器件的一半，由于生产过程更为简单，NAND结
构可以在给定的模具尺寸内提供更高的容量，也就相应地降低了价格。

NOR flash占据了容量为1～16MB闪存市场的大部分，而NAND flash只是用在8～
128MB的产品当中，这也说明NOR主要应用在代码存储介质中，NAND适合于数据存
储，NAND在CompactFlash、Secure Digital、PC Cards和MMC存储卡市场上所占
份额最大。

****** 可*性和耐用性
采用flahs介质时一个需要重点考虑的问题是可*性。对于需要扩展MTBF的系统来
说，Flash是非常合适的存储方案。可以从寿命(耐用性)、位交换和坏块处理三
个方面来比较NOR和NAND的可*性。

******* 寿命(耐用性)
在NAND闪存中每个块的最大擦写次数是一百万次，而NOR的擦写次数是十万次。
NAND存储器除了具有10比1的块擦除周期优势，典型的NAND块尺寸要比NOR器件小
8倍，每个NAND存储器块在给定的时间内的删除次数要少一些。

******* 位交换
所有flash器件都受位交换现象的困扰。在某些情况下(很少见，NAND发生的次数
要比NOR多)，一个比特位会发生反转或被报告反转了。

一位的变化可能不很明显，但是如果发生在一个关键文件上，这个小小的故障可
能导致系统停机。如果只是报告有问题，多读几次就可能解决了。

当然，如果这个位真的改变了，就必须采用错误探测/错误更正(EDC/ECC)算法。
位反转的问题更多见于NAND闪存，NAND的供应商建议使用NAND闪存的时候，同时
使用EDC/ECC算法。

这个问题对于用NAND存储多媒体信息时倒不是致命的。当然，如果用本地存储设
备来存储操作系统、配置文件或其他敏感信息时，必须使用EDC/ECC系统以确保
可*性。

******* 坏块处理
NAND器件中的坏块是随机分布的。以前也曾有过消除坏块的努力，但发现成品率
太低，代价太高，根本不划算。

NAND器件需要对介质进行初始化扫描以发现坏块，并将坏块标记为不可用。在已
制成的器件中，如果通过可*的方法不能进行这项处理，将导致高故障率。

****** 易于使用
可以非常直接地使用基于NOR的闪存，可以像其他存储器那样连接，并可以在上
面直接运行代码。

由于需要I/O接口，NAND要复杂得多。各种NAND器件的存取方法因厂家而异。

在使用NAND器件时，必须先写入驱动程序，才能继续执行其他操作。向NAND器件
写入信息需要相当的技巧，因为设计师绝不能向坏块写入，这就意味着在NAND器
件上自始至终都必须进行虚拟映射。

****** 软件支持
当讨论软件支持的时候，应该区别基本的读/写/擦操作和高一级的用于磁盘仿真
和闪存管理算法的软件，包括性能优化。

在NOR器件上运行代码不需要任何的软件支持，在NAND器件上进行同样操作时，
通常需要驱动程序，也就是内存技术驱动程序(MTD)，NAND和NOR器件在进行写入
和擦除操作时都需要MTD。

使用NOR器件时所需要的MTD要相对少一些，许多厂商都提供用于NOR器件的更高
级软件，这其中包括M-System的TrueFFS驱动，该驱动被Wind River System、
Microsoft、QNX Software System、Symbian和Intel等厂商所采用。

驱动还用于对DiskOnChip产品进行仿真和NAND闪存的管理，包括纠错、坏块处理
和损耗平衡。

***** 小结
1. Nor和Nand都是闪存(*flash*)技术。
2. Nor读快写慢容量小
3. Nand写快量

** intergrate circuit                                                   :ic:
*** TTL电平信号                                                       :ttl:

TTL电平信号被利用的最多是因为通常数据表示采用二进制规定，+5V等价于逻辑
“1”，0V等价于逻辑“0”，这被称做TTL（晶体管-晶体管逻辑电平）信号系统，
这是计算机处理器控制的设备内部各部分之间通信的标准技术。

TTL电平信号对于计算机处理器控制的设备内部的数据传输是很理想的，首先计
算机处理器控制的设备内部的数据传输对于电源的要求不高以及热损耗也较低，
另外TTL电平信号直接与集成电路连接而不需要价格昂贵的线路驱动器以及接收
器电路；再者，计算机处理器控制的设备内部的数据传输是在高速下进行的，而
TTL接口的操作恰能满足这个要求。TTL型通信大多数情况下，是采用并行数据传
输方式，而并行数据传输对于超过10英尺的距离就不适合了。这是由于可靠性和
成本两面的原因。因为在并行接口中存在着偏相和不对称的问题，这些问题对可
靠性均有影响。

TTL输出高电平>2.4V，输出低电平<0.4V。在室温下，一般输出高电平是3.5V，
输出低电平是0.2V。最小输入高电平和低电平：输入高电平>=2.0V，输入低电平
<=0.8V，噪声容限是0.4V。

TTL门电路是双极型集成电路，与分立元件相比，具有速度快、可靠性高和微型
化等优点。

*** TTL逻辑电路                                                       :ttl:
全称Transistor-Transistor Logic,即BJT-BJT逻辑门电路，是数字电子技术中
常用的一种逻辑门电路，应用较早，技术已比较成熟。TTL主要有BJT（Bipolar
Junction Transistor 即双极结型晶体管，晶体三极管）和电阻构成，具有速度
快的特点。最早的TTL门电路是74系列，后来出现了74H系列，74L系列，
74LS,74AS,74ALS等系列。但是由于TTL功耗大等缺点，正逐渐被CMOS电路取代。

*** 漏极开电路(OD)                                                   :开漏:

*开漏(Open Drain)* ： MOS管的 *漏极* 作为输出(*开*)
开漏电路概念中提到的“漏”就是指MOS FET的漏极。同理，开集电路中的“集”就
是指三极管的集电极。开漏电路就是指以 *MOS FET的漏极为输出的电路* 。一
般的用法是会在漏极外部的电路添加上拉电阻。完整的开漏电路应该由开漏器件
和开漏上拉电阻组成。

[[~/Tiger/Figures/scrot/18640jwg.png]]

*** 达林顿晶体管                                               :transistor:

达灵顿晶体管（英语： *darlington transistor* ），或称达灵顿对
（darlington pair）是电子学中由 *两个（甚至多个）双极性晶体管* （或者其他
类似的集成电路或分立元件）组成的 *复合结构* ，通过这样的结构，经第一个双极
性晶体管放大的电流可以 *进一步被放大。*

这样的结构可以提供一个比其中任意一个双极性晶体管高得多的电流增益。在使
用集成电流芯片的情况里，达灵顿晶体管可以使得芯片比使用两个分立晶体管元
件 *占用更少的空间* ，因为两个晶体管可以共用一个集极。达灵顿晶体管通常被封
装在单一的芯片里，从外面看就像一个双极性晶体管。

[[~/tiger/figures/scrot/18129dtn.png]]

+ b - 基极
+ c - 集电极
+ e - 发射极

**** 小结
成对复合晶体管，功放大，结构小

** miscellaneous
*** 公头和母头

公 : 插头中的插针的部分

母 ：插头中的插槽部分

*** PID                                                               :pid:

pid调节器。工程上常常用在闭环系统中加入pid环节，对系统的传递函数进行修
正，以快速的跟踪变化，消除稳态误差。

pid调节器中的p为比例环节，起放大作用。i为积分环节，可以消灭稳态误差。d
为微分环节，可以加快系统的反映。

直流电机中加入pid调节器，可以实现快速启动。当系统中突发干扰、负载变化
或者使用者主动调速是，pid环节可以帮助电机缩减过渡时间、进入新的稳定状
态。

*** 12mhz的晶振多少个机器周期

1. 概念
   1) 时钟周期
      时钟周期也称为振荡周期，定义为时钟脉冲的倒数（可以这样来理解，时
      钟周期就是单片机外接晶振的倒数，例如12m的晶振，它的时间周期就是
      1/12 us），是计算机中最基本的、最小的时间单位。

   2) 机器周期
      在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，
      每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，这每一
      项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。

   3) 状态周期
      一般情况下，一个机器周期由若干个s周期（状态周期）组成。8051系列
      单片机的一个机器周期同6个s周期（状态周期）组成。前面已说过一个时
      钟周期定义为一个节拍（用p表示），二个节拍定义为一个状态周期（用s
      表示），8051单片机的机器周期由6个状态周期组成，也就是说一个机器
      周期=6个状态周期=12个时钟周期。

   4) 指令周期
      指令周期是执行一条指令所需要的时间，一般由若干个机器周期组成。指
      令不同，所需的机器周期数也不同。对于一些简单的的单字节指令，在取
      指令周期中，指令取出到指令寄存器后，立即译码执行，不再需要其它的
      机器周期。对于一些比较复杂的指令，例如转移指令、乘法指令，则需要
      两个或者两个以上的机器周期。

2. delay
   #+begin_example
      1 void delay10ms(unsigned int c)
      2 {
      3   unsigned char a, b;
      4   for(; c>0; c--){
      5     for(b=38; b>0; b--){
      6       for(a=130; a>0; a--);
      7     }
      8   }
      9 }
   #+end_example

   从计算机的角度分析， 而不要想当然；
   + l3: 定义变量a，b， 即要分配内存空间， 需要2个机器周期(2t)
   + l6: 内循环： 赋值a, 1t; 单次循环包括比较和自减2t. 完成一次外循环
     的时间为 1+130*2
   + l4: 外循环 1 + 38*（1+130*2）
   + 总时间： 2 + 1 + 38*（1+130*2）= 9912(quick-cacl)us = 9.91ms=10ms

* interface
** J-Link                                                            :jlink:
*** openjtag                                                     :openjtag:

**** about

open jtag project is an *open source hardware and software* for a
*high speed usb jtag tool*.

in this site, you can find and download all necesary files to make
your jtag device. the electric schematics, the pcb design including
gerber files, the vhdl project in altera quartus ii format, and the
c++ examples in microsoft visual studio 2005, are free to be
downloaded

**** resources
+ [[http://www.openjtag.org/][homepage]]

** isp                                                                 :isp:
*** 在线刻录(isp)                                                     :isp:

 isp 即(in-system programming)在系统可编程，指电路板上的空白器件可以编
 程写入最终用户代码， 而不需要从电路板上取下器件，已经编程的器件也可
 以用isp 方式擦除或再编程

*** usbisp & usbasp                                         :usbisp:usbasp:
**** usbasp

USBasp is a USB in-circuit programmer for Atmel AVR controllers. It
simply consists of an ATMega88 or an ATMega8 and a couple of passive
components. The programmer uses a firmware-only USB driver, no special
USB controller is needed.

[[http://www.fischl.de/usbasp/][fischl:usbasp]] 官网可下载 固件、原理图及PCB


#+DOWNLOADED: file://~/Wally/Journal/Figures/usbasp_circuit.png @ 2015-12-05 14:36:13
 [[~/Wally/Journal/Figures/日事日毕/usbasp_circuit_2015-12-05_14:36:13.png]]

**** 联系与区别

*谷歌搜索不到 usbisp 的英文资料， avrdude中也没有对 usbisp 的直接支持。*

1. USBISP与USBASP分别是2个德国人的设计,在硬件上基本兼容,但内核软件有不
   同,尽管低层USB都采用开源代码,但上层支持协议不同.USBISP是STK500v2
   conpatible (direct from AVR-Studio useable) 的,直接在AVR STUDIO中支
   持和使用.而USBASP需要使用专用的编程软件.另外ASPISP的更新比USBASP快.

2. 这两者硬件电路相同，固件程序不同；

3. 两者使用的烧录软件不同，USBISP是模拟STK500下载线，所以可以使用AVR
   Stduio开发环境来下载烧录程序；而USBASP不能用AVR Stduio，但是现在网
   上很多支持USBASP的软件，比如PROGISP,AVR flater等。

4. USBISP与并口ISP(STK200/STK300)的比较并口ISP(STK200/STK300)下载线需
   要PC带真正的LPT口,在ICC、CVAVR、BASCOM-AVR中可以直接使用。USBISP使
   用USB口，只能在AVR STUDIO中使用（其它支持的不稳定）USBISP速度稍为慢
   一点（M8模拟USB）

**** reference

+ [[chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/js/main/generateUrlWithTempToken.html?baseUrl=https%3A%2F%2Fapp.yinxiang.com&targetUrl=%2Fshard%2Fs52%2Fnl%2F11551545%2F707ecdc3-6ae1-492d-99d8-6ecdd0215315%2F][USBISP与USBASP]]
+ [[http://www.fischl.de/usbasp/][fischl:usbasp]]

*** 自制USB AVR烧录器:
http://mitchcircuit.wordpress.com/2008/03/13/usbasp-diy/

** 并口                                                               :并口:
*** overview

+ [[https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E7%AB%AF%E5%8F%A3][Wiki: 并口]]

并行端口（Parallel Port），又称平行埠、並列埠、并口，是计算机上数据以
并行方式传递的端口，也就是说至少应该有两条连接线用于传递数据。与只使用
一根线传递数据（这里没有包括用于接地、控制等的连接线）的串行端口相比，
并口在相同的数据传送速率下，并口可以更快地传输数据。所以在21世纪之前，
在需要较大传输速度的地方，例如打印机，并口得到广泛使用。但是随着速度迅
速提高，并口上导线之间数据同步成为一个很难处理的难题，导致并口在速度竞
赛中逐渐被淘汰。目前USB等改进的串口逐渐代替了并口。

[[~/Wally/Journal/Figures/scrot/9465etO.png]]

[[~/Wally/Journal/Figures/scrot/9465r3U.png]]

** UART
*** RS232                                                           :rs232:
**** RS-232 Wiki


*RS-232* 是美国[[/wiki/%E7%94%B5%E5%AD%90%E5%B7%A5%E4%B8%9A%E8%81%94%E7%9B%9F][电子工业联盟]]（EIA）制定的串行数据通信的接口标准。它被广
泛用于计算机串行接口外设连接。


它規定連接[[/wiki/%E9%9B%BB%E7%BA%9C][電纜]]和[[/wiki/%E6%A9%9F%E6%A2%B0][機械]]、[[/wiki/%E9%9B%BB%E6%B0%A3][電氣]]特性、信號功能及傳送過程。其他常用電氣標準還有
[[/wiki/EIA-422][EIA-RS-422-A]]、[[/w/index.php?title=EIA-423&action=edit&redlink=1][EIA-RS-423A]]、[[/wiki/RS-485][EIA-RS-485]]。

由於RS-232-C的重大影響，即使自IBM [[/wiki/PC/AT][PC/AT ]]開始改用9針連接器起，目前已幾
乎不再使用RS-232中規定的25針連接器，但大多數人仍然普遍使用RS-232C來代
表此一介面。

***** 标准的细节

在RS-232标准中，字符是以一序列的位元串来一个接一个的[[/w/index.php?title=%E4%B8%B2%E5%88%97&action=edit&redlink=1][串列]]（serial）方式
傳輸，優點是傳輸線少，配線簡單，傳送距離可以較遠。最常用的编码格式是异
步起停（asynchronous start-stop）格式，它使用一个起始位元后面紧跟7或8
个数据位元（bit），然后是可选的奇偶校验位元，最后是一或两个停止位元。
所以发送一个字符至少需要10位元，带来的一个好的效果是使全部的传输速率，
发送信号的速率以10划分。一个最平常的代替异步起停方式的是使用[[/wiki/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6][高级数据链
路控制]]协议（HDLC）。

在RS-232标准中定义了逻辑一和逻辑零电压级数，以及标准的传输速率和连接器
类型。信号大小在正的和负的3－15v之间。RS-232规定接近零的电平是无效的，
逻辑一规定为负电平，有效负电平的信号状态称为传号marking，它的功能意义
为OFF，逻辑零规定为正电平，有效正电平的信号状态称为空号spacing，它的功
能意义为ON。根据设备供电电源的不同，±5、±10、±12和±15这样的电平都
是可能的。


****** 连接器

RS-232設計之初是用來連接數據機做傳輸之用，也因此它的腳位意義通常也和數
據機傳輸有關。RS-232的设备可以分为数据终端设备（DTE，Data Terminal
Equipment, For example, PC）和数据通信设备（DCE，Data Communication
Equipment）两类，这种分类定义了不同的线路用来发送和接受信号。一般来说，
计算机和终端设备有DTE连接器，调制解调器和打印机有DCE连接器。但是这么说
并不是总是严格正确的，用配线分接器测试连接，或者用试误法来判断电缆是否
工作，常常需要参考相关的文件说明。

RS-232指定了20个不同的信号连接，由25个D-sub（微型D类）管脚构成的DB-25
连接器。

很多设备只是用了其中的一小部分管脚，出于节省资金和空间的考虑不少机器采
用较小的连接器，特别是9管脚的D-sub或者是 *DB-9* 型连接器被广泛使用绝大
多数自IBM的AT机之后的PC机和其他许多设备上。DB-25 和 DB-9 型的连接器在大部
分设备上是雌型，但不是所有的都是这样。

下表中列出的是被较多使用的RS-232中的信号和管脚分配：

#+BEGIN_EXAMPLE
               DE-9 Male（Pin Side）                   DE-9 Female (Pin Side）
                 -------------                          -------------
                 \ 1 2 3 4 5 /                          \ 5 4 3 2 1 /
                  \ 6 7 8 9 /                            \ 9 8 7 6 /
                   ---------                              ---------
#+END_EXAMPLE

| 信号                | DB-25 | DE-9 | EIA/TIA 561 | Yost |
|---------------------+-------+------+-------------+------|
| 公共接地            |     7 |    5 |           4 |  4,5 |
| 发送数据（TD、TXD） |     2 |    3 |           6 |    3 |
| 接受数据（RD、RXD） |     3 |    2 |           5 |    6 |
| 数据终端准备（DTR） |    20 |    4 |           3 |    2 |
| 数据准备好（DSR）   |     6 |    6 |           1 |    7 |
| 请求发送（RTS）     |     4 |    7 |           8 |    1 |
| 清除发送（CTS）     |     5 |    8 |           7 |    8 |
| 数据载波检测（DCD） |     8 |    1 |           2 |    7 |
| 振铃指示（RI）      |    22 |    9 |           1 |   － |

| 腳位 | 簡寫 | 意義                | 說明                           |
|------+------+---------------------+--------------------------------|
| Pin1 | CD   | Carrier Detect      | 數據機通知電腦有載波被偵測到。 |
| Pin2 | RXD  | Receiver            | 接收資料。                     |
| Pin3 | TXD  | Transmit            | 傳送資料。                     |
| Pin4 | DTR  | Data Terminal Ready | 電腦告訴數據機可以進行傳輸。   |
| Pin5 | GND  | Ground              | 地線。                         |
| Pin6 | DSR  | Data Set Ready      | 數據機告訴電腦一切準備就緒。   |
| Pin7 | RTS  | Request To Send     | 電腦要求數據機將資料送出。     |
| Pin8 | CTS  | Clear To Send       | 數據機通知電腦可以傳資料過來。 |
| Pin9 | RI   | Ring Indicator      | 數據機通知電腦有電話進來。     |

TXD DTE->DCE DTE SEND DATA

RXD DCE->DTE DTE RECEIVE DATA

RTS DTE->DCE DTE REQUEST SEND

CTS DCE->DTE ACK TO DTE'S RTS

DSR DCE->DTE DCE IS READY

GND

DCD DCE->DTE DC DETECTED

DTR DTE->DCE DTE IS READY

RI DCE->DTE RING INDICATION

信号的标注是从DTE设备的角度出发的，TD、DTR和RTS信号是由DTE产生的，RD、DSR、CTS、DCD和RI信号是由DCE产生的。接地信号是所有连接都公共的，在Yost的标准中接地信号外部有两个管脚事实上是同一个信号。如果两个通信设备的距离相差的很远或者是有两个不同的供电系统供电，那么地信号在两个设备间会不一样，从而导致通信失败，跟踪描述这样的情形是很困难的。

****** 设置

串行通信在软件设置里需要做多项设置，最常见的设置包括[[/wiki/%E6%B3%A2%E7%89%B9%E7%8E%87][波特率]]（Baud）、奇偶校验（Parity
Check）和停止位（Stop Bit）。

-  波特率（又称[[/wiki/%E9%AE%91%E7%8E%87][鮑率]]）：是指从一设备发到另一设备的波特率，即每秒钟多少符號。典型的波特率是300,
   1200, 2400, 9600, 19200,
   115200等。一般通信两端设备都要设为相同的波特率，但有些设备也可设置为自动检测波特率。

-  奇偶校验（Parity：是用来验证数据的正确性。奇偶校验一般不使用，如果使用，那么既可以做奇校验（Odd
   Parity）也可以做偶校验（Even
   Parity）。奇偶校验是通过修改每一发送字节（也可以限制发送的字节）来工作的。如果不作奇偶校验，那么数据是不会被改变的。在偶校验中，因为奇偶校验位会被相应的置1或0（一般是最高位或最低位），所以数据会被改变以使得所有传送的数位（含字符的各数位和校验位）中“1”的个数为偶数；在奇校验中，所有传送的数位（含字符的各数位和校验位）中“1”的个数为奇数。奇偶校验可以用于接受方检查传输是否发送生错误------如果某一字节中“1”的个数发生了错误，那么这个字节在传输中一定有错误发生。如果奇偶校验是正确的，那么要么没有发生错误要么发生了偶数个的错误。如果使用者選擇資料長度為8位元，則因為沒有多餘的位元可被用來作為同位元，因此就叫做「非奇偶校验（Non
   Parity）」。

-  停止位：是在每个字节传输之后发送的，它用来帮助接受信号方硬件重同步。

RS-232在傳送資料時，並不需要另外使用一條傳輸線來傳送同步訊號，就能正確
的將資料順利傳送到對方，因此叫做「非同步傳輸」，簡稱UART（Universal
Asynchronous Receiver Transmitter），不過必須在每一筆資料的前後都加上
同步訊號，把同步訊號與資料混和之後，使用同一條傳輸線來傳輸。

在串行通信软件设置中D/P/S是常规的符号表示。8/N/1（非常普遍）表明8bit数
据，没有奇偶校验，1bit停止位。数据位可以设置为5、6、7或者8位元（不可以
大於8或小於5），奇偶校验位可以设置为无（N）、奇（O）或者偶（E），奇偶
校验可以使用数据中的位元（bit），所以8/E/1就表示一共8位数据位，其中一
位用来做奇偶校验位。停止位可以是1、1.5或者2位的（1.5是用在波特率为
60wpm的电传打字机上的）。


-  流量控制：当需要发送[[/wiki/%E6%8F%A1%E6%89%8B%E4%BF%A1%E5%8F%B7][握手信号]]或数据完整性检测时需要制定其他设置。公用的组合有RTS/CTS,
   DTR/DSR或者XON/XOFF（实际中不使用连接器管脚而在数据流内插入特殊字符）。

***** 類似規範

-  [[/wiki/%E5%9B%BD%E9%99%85%E7%94%B5%E4%BF%A1%E8%81%94%E7%9B%9F%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84][ITU-T]]（前CCITT）的對應規範，用語不同，但電氣規格幾乎相同

   -  ITU-T V.28

-  具有相似的通信目的，但功能與電氣規範不同

   -  [[/wiki/RS-422][RS-422]]
   -  [[/w/index.php?title=RS-423&action=edit&redlink=1][RS-423]]
   -  [[/wiki/RS-449][RS-449]]
   -  [[/wiki/RS-485][RS-485]]

***** 外部連結

-  [[http://www.zywyn.com.tw/index.php][RS-232 professional maker (ZYWYN.com）]]
-  [[http://www.camiresearch.com/Data_Com_Basics/RS232_standard.html][RS-232 tutorial]]
-  [[http://www.yost.com/Computers/RJ45-serial/][Yost Serial Device Wiring Standard]]
-  [[http://www.acumeninstruments.com/Support/documentation/SerialPortBasics/index.shtml][Serial Port Basics]]
-  [[http://www.lammertbies.nl/comm/info/RS-232.html][RS232 serial port info]]
-  [[http://www.tronisoft.com/rs232info/ASCII_serial_port_crib_sheets.pdf][Printable ASCII Serial Port Crib Sheets]]

**** RS232

- http://c.biancheng.net/cpp/html/1919.html

标准串口，在物理结构上分为 9 针的和 9 孔的，习惯上我们也称之为公头和母
头

[[~/Wally/Journal//Figure/scrot/2983mBR.png]]

RS232 接口一共有 9 个引脚，分别定义是：1、载波检测 DCD；2、接收数据
RXD；3、发送数据 TXD；4、数据终端准备好 DTR；5、信号地线 SG；6、数据准
备好 DSR；7、请求发送 RTS；8、清除发送 CTS；9、振铃提示 RI。我们要让这
个串口和我们单片机进行通信，我们只需要关心其中的 2 脚 RXD、3 脚 TXD 和
5 脚 GND 即可。

虽然这三个引脚的名字和我们单片机上的串口名字一样，但是却不能直接和单片
机对连通信，这是为什么呢？随着我们了解的内容越来越多，我们得慢慢知道，
不是所有的电路都是 5V 代表高电平而 0V 代表低电平的。对于 RS232 标准来
说，它是个反逻辑，也叫做负逻辑。为何叫负逻辑？它的 TXD 和 RXD 的电
压，-3V～-15V 电压代表是 1，+3～+15V 电压代表是 0。低电平代表的是 1，
而高电平代表的是 0，所以称之为负逻辑。因此电脑的 9 针 RS232串口是不能
和单片机直接连接的，需要用一个电平转换芯片 MAX232 来完成.

[[~/Wally/Journal//Figure/scrot/2983zLX.png]]

 RS232 串口和 UART 串口，它们的协议类型是一样的，只是电平标准不同而已，
 而 MAX232 这个芯片起到的就是中间人的作用，它把 UART 电平转换成 RS232
 电平，也把 RS232 电平转换成 UART 电平，从而实现标准 RS232接口和单片机
 UART 之间的通信连接。

**** RS485                                                         :rs485:
***** EIA-485 wiki                                                 :wiki:

*EIA-485*（过去叫做*RS-485*或者*RS485*）是隶属于[[/wiki/OSI%E6%A8%A1%E5%9E%8B][OSI模型]][[/wiki/%E7%89%A9%E7%90%86%E5%B1%82][物理层]]的电气特
性规定为2线，[[/wiki/%E5%8D%8A%E9%9B%99%E5%B7%A5][半双工]]，多点通信的标准。它的电气特性和[[/wiki/RS-232][RS-232]]不大一样。用
缆线两端的[[/wiki/%E7%94%B5%E5%8E%8B][电压]]差值来表示传递信号，1极的电压标识为逻辑1，另一段标识为逻
辑0。两端的电压差最小为0.2V以上时有效，任何不大于12V或者不小于－7V的差
值对接受端都被认为是正确的。

EIA-485仅仅规定了接受端和发送端的电气特性。它没有规定或推荐任何数据协
议。EIA-485可以应用于配置便宜的[[/wiki/%E5%B9%BF%E5%9F%9F%E7%BD%91][广域网]]和采用单机发送，多机接受通信链接。
它提供高速的数据通信速率（10m时35[[/w/index.php?title=Bitrate&action=edit&redlink=1][Mbit/s]]；1200m时100[[/w/index.php?title=Bitrate&action=edit&redlink=1][kbit/s]]1200m）。

EIA-485和[[/wiki/EIA-422][EIA-422]]一样使用双绞线进行高电压差分平衡传输，它可以进行大面积
长距离传输（超过4000[[http://zh.wikipedia.org/wiki/%E8%8B%B1%E5%B0%BA][英尺]]，1200米）。

和EIA-422相对照的是，EIA-422采用不可转换的单发送端，EIA-485的发送端需
要设置为发送模式，这使得EIA-485可以使用双线模式实现真正的多点双向通信。

EIA-485推荐使用在点对点网络中，线型、总线型，不能是星型、环型网络。理
想情况下EIA-485需要2个终接电阻，其阻值要求等于传输电缆的特性阻抗。没有
特性阻抗的话，当所有的设备都静止或者没有能量的时候就会产生噪声，而且线
移需要双端的电压差。没有终接电阻的话，会使得较快速的发送端产生多个数据
信号的边缘，这其中的一些是不正确的。之所以不能使用星型或者环型的拓扑结
构是由于这些结构有不必要的反映，过低或者过高的终接电阻可以产生电磁干扰。

EIA-485在使用四线时可以和EIA-422一样实现[[/wiki/%E5%85%A8%E9%9B%99%E5%B7%A5][全双工]]。EIA-485可以实现真正的
多点通信，在许多情况下并没有什么用处。在某些限制条件下，EIA-485和
EIA-422可以实现相互的连接。

****** 比较

下面的表格列出了RS-485的一些特性和引脚的分配以及和[[/wiki/RS-232][RS-232]]的比较：

| EIA-485                    | [[/wiki/RS-232][RS-232]]                    | [[/w/index.php?title=D-subminiature&action=edit&redlink=1][DB-25]] | [[/w/index.php?title=D-subminiature&action=edit&redlink=1][DE-9]] | [[/w/index.php?title=RJ-50&action=edit&redlink=1][RJ-50]] |
|----------------------------+---------------------------+-------+------+-------|
| Common Ground              | Carrier Detect（DCD）     |     8 |    1 |    10 |
| Clear To Send +（CTS+）    | Received Data (RD)        |     3 |    2 |     9 |
| Ready To Send +（RTS+）    | Transmitted Data (TD)     |     2 |    3 |     8 |
| Received Data +（RxD+）    | Data Terminal Ready (DTR) |    20 |    4 |     7 |
| Received Data -（RxD-）    | Common Ground             |     7 |    5 |     6 |
| Clear To Send -（CTS-）    | Data Set Ready (DSR)      |     6 |    6 |     5 |
| Ready To Send -（RTS-）    | Request To Send (RTS)     |     4 |    7 |     4 |
| Transmitted Data +（TxD+） | Clear To Send (CTS)       |     5 |    8 |     3 |
| Transmitted Data -（TxD-） | Ring Indicator (RI)       |    22 |    9 |     2 |

* board
** Raspberry Pi                                             :raspberry:rasp:
*** 树莓派

**** Intro

树莓派（英语： *Raspberry Pi* ），是一款基于Linux系统的只有信用卡大小
的单板机电脑。

[[/home/ben/Wally/Journal/Figure/scrot/5070Ejz.png]]

1. 单板机电脑
2. 体积小： 85x54(B+)
3. 配置
   1) CPU
      ARM CortexA7-四核 900MHz
   2) 内存
      512(B+)
   3) 接口
      + USB: 4个，支持Hub
      + Ethernet
      + HDMI
      + GPIO： 通用IO，8+
      + UART
      + I2C
      + SPI: 2个带地
      + 电源引脚： 3.3v, 5v
      + HAT规格铺设

   4) 存储
      + SD
      + MMC
      + SDIO/MicroSD卡插槽
   5) 支持系统
      + Debian
      + ArchLinux
      + OpenWrt
      + *Raspbian* （自带系统，基于Linux）

   6) 型号
   A, A+, B,  B+, B2

**** 资源汇总

**** 安装ROS

1. 系统要求： Raspbian
2. 方式： 源码方式

**** 参考资料
1. [[https://zh.wikipedia.org/wiki/%E6%A0%91%E8%8E%93%E6%B4%BE][Wiki: 树莓派]]
2. [[http://post.smzdm.com/p/99210/][树莓派&OpenWrt]]
3. [[http://wiki.ros.org/ROSberryPi/Installing%20ROS%20Indigo%20on%20Raspberry%20Pi][ROS wiki: Installing ROS indigo on the Paspberry Pi]]
4. [[http://blog.csdn.net/crazyquhezheng/article/details/43413231][blog 东方赤龙：树莓派编译安装完整版ROS]]
5. [[http://blog.csdn.net/hcx25909/article/category/1759051][blog 古月居： 树莓派Linux驱动学习系列（不多3篇，仅入门）]]
*** todos

1. [ ] 盒子和配件
2. [ ] gpio使用
3. [ ] 各种通信 uart，i2c, isp
4. [ ] 交叉编译环境ubuntu下
5. [ ] 裸板，即不接显示器、鼠标、键盘、网线等
6. [ ] 与arduino相连
7. [ ] 按键等控制ros等
8. [ ]

*** 安装raspbian

1. 参考文献的选择
   + 有官网的教程优先考虑
   + 有国外的教程优先考虑
   + 国内的博客教程等要慎重选择

2. sd卡的分区和格式化处理
   + df -h
   + sudo fdisk -l
   + sudo fdisk =/dev/sdb=
   + mkfs.vfat 需要格式化成fat文件系统，分区之后为linux文件系统

3. 参考
   + [[https://app.yinxiang.com/shard/s52/nl/11551545/740d3fc2-81e5-4733-b3e3-90631ce11d4d?title=noobs%20for%20raspberry%20pi%20%7c%20rants%20%26%20raves%20%e2%80%93%20the%20blog!][noobs for raspberry pi 2 b]]
   + [[https://app.yinxiang.com/shard/s52/nl/11551545/57510d93-2c8b-488c-9a5c-e0db65c720dd?title=ubuntu%20%e5%ae%89%e8%a3%85%20raspbian%20%e5%88%b0%20raspberry%20pi%20b%2b%20-%20wiki][ubuntu下安装raspbian到raspberry中]]

*** rasp-config

1. 语言、时区、键盘
2. 用户及密码
3. 登录方式

*** 安装ros

1. 源码方式:

   http://wiki.ros.org/rosberrypi/installing%20ros%20indigo%20on%20raspberry%20pi

2. apt方式 for arm board(pi 2):

   http://wiki.ros.org/indigo/installation/ubuntuarm

*** headless

https://www.raspberrypi.org/forums/viewtopic.php?f=91&t=74176

*** ssh 远程登录到 raspberry

ssh pi@192.168.1.25

1. ssh-server (sshd) 默认在 raspberry pi 中启动，所以不用设置
2. 默认的，ssh 会尝试用当前用户作为用户名来连接。所以，需要指定用户名
   pi
3. 先 ping

   #+BEGIN_EXAMPLE
   ping 192.168.1.25
   #+END_EXAMPLE

*** NEXT 自动登录，无需密码
- State "NEXT"       from ""           [2015-12-25 五 16:15] \\
  1. 不便用 GUI 方式设置，使用命令行方式配置
  2. 不登录到 X 桌面，GUI设置中有，但先不尝试

在  raspberry configure 中设置 Autolog

+ http://blog.csdn.net/swliao/article/details/5989203

*** 设置静态 IP

+ http://www.cnblogs.com/keygle/archive/2013/04/27/3048273.html


1. 按照 http://www.cnblogs.com/keygle/archive/2013/04/27/3048273.html
   失败，启动时有问题，进入系统后没有自动连接网

2. 尝试只修改一句,  not ok

   #+BEGIN_EXAMPLE
   iface eth0 inet manual
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
   iface eth0 inet static
   address 192.168.1.27
   #+END_EXAMPLE

3. 系统使用的 wpa
   #+BEGIN_EXAMPLE
   wpa-conf /etc/wpa_supplicant/wap_supplicant.conf
   #+END_EXAMPLE

   其内容

   #+BEGIN_EXAMPLE
     network={
             ssid="A409"
             psk="A409A409A409"
             key_mgmt=WPA-PSK
     }
   #+END_EXAMPLE

4. 不重启系统，而是重启 network

   #+BEGIN_EXAMPLE
   sudo service networking restart
   #+END_EXAMPLE

5. 使用默认的配置，manual 还是动态的

   IP: 192.168.1.25

6. 配置

   #+BEGIN_EXAMPLE
     auto wlan0
     allow-hotplug wlan0
     iface wlan0 inet manual
     wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf
     iface wlan0 inet static
             address 192.168.1.25
             netmask 255.255.255.0
             gateway 192.168.1.1
   #+END_EXAMPLE

   - 桌面任务栏上显示的与 ifconfig 不一致，与后者为准。
   - 可以了，尽管还没有完全配置好

*** 使用蓄电池供电

5V 蓄电池 + 手机 USB 数据线，测试 OK

LED 的指示状态？？？

*** raspberry使用思考

1. 不要瞎折腾，用不着的东西不要装
2. 使用vi，不要装emacs
3. 不要过人热衷，先消停几天，十二月份再玩(2015/11/22)
4. ros也要精简，绝对不要尝试gui
*** 挂载 NFS

问题

#+BEGIN_EXAMPLE
  ~ $ sudo mount -t nfs 192.168.1.3:/home/ben/Wally/Project/catkin_ws catkin_ws/
  mount.nfs: rpc.statd is not running but is required for remote locking.
  mount.nfs: Either use '-o nolock' to keep locks local, or start statd.
  mount.nfs: an incorrect mount option was specified

#+END_EXAMPLE

解决

#+BEGIN_EXAMPLE
 sudo service rpcbind restart
#+END_EXAMPLE

** board: TQ2440                                                    :tq2440:
*** 系统资源

[[~/Wally/Journal/Figures/scrot/5070dLV.png]]

1. 处理器：s3c2440a. arm9
   + 主频400m,  最高533m
   + 内存64m

2. 存储
   + nor flash(2m): 容量小，运行快，价格高
   + nand flash(对应硬盘): 256m
   + sd插槽

3. 接口资源
   + 用户可编程led
   + 用户可编程按键
   + lcd及接口: 4.3寸
   + 音频输入输出
   + gpio：40
   + usb接口： 主/从
   + rs232串口
   + rj45网口
   + jtag
   + 系统总线（什么总线？）
   + cmos

*** 启动方式

+ nor flash
+ nand flash
+ 开关设置

*** 操作系统

+ linux: 30m左右
+ wince:
+ 安装位置： nand flash
+ 安装方式：
  1. jtag烧写引导程序到nor flash
  2. 使用usb下载线下载操作系统到内在中
  3. 把操作系统安装到nand flash

*** 安装系统安装

1. 软件构成
   1) bootlaoder
   2) linux
   3) 文件系统

2. 安装步骤
   1) 使用 jtag 将 引导安装程序 下载到 nor flash
   2) 使用 usb下载线 将操作系统 安装到 nand flash中

3. jtag
   + 嵌入式开发使用交叉开发模型：  宿主机/目标机
   + *jtag常用来对flash等器件进行编程* ， 按连接方式分
     - 并口
     - usb， *jlink*
   + 步骤
     - 选择nor flash启动
     - 连接jlink
     - 打开电源

   + 工具
     - windows: segger:
       - 连接
       - file->open project: *2440.flash* 工程配置文件
       - target -> erase
       - file -> open : uboot(bootloader)
       - target -> program
       - 完成后重启并拔掉jlink线
     - linux:

** Arduino                                                         :arduino:
*** arduino教程
+ tutorials(中): http://www.flamingoeda.com/category/tutorial/
+ tutorials(en): http://www.ladyada.net/learn/arduino/

*** arduino wiki
+ wiki: http://zh.wikipedia.org/wiki/arduino
+ tutorials(中): http://www.flamingoeda.com/category/tutorial/
+ tutorials(en): http://www.ladyada.net/learn/arduino/
+ homepage: http://www.arduino.cc/
+ forum: http://www.arduino.cn/thread-1066-1-1.html
+ 自制usb avr烧录器: http://mitchcircuit.wordpress.com/2008/03/13/usbasp-diy/


**** what
arduino，是一个开放源代码的单芯片微控制器，它使用了atmel avr单片机，采
用了基于开放源代码的软硬件平台，建构于简易输出/输入（simple i/o）界面
板，并且具有使用类似java、c语言的processing/wiring开发环境。

**** features
+ 基于知识共享开放源代码的电路图设计。

+ 免费下载，也可依需求自己修改，但需遵照姓名标示。您必须按照作者或授权
  人所指定的方式，表彰其姓名。

+ 依相同方式分享，若您改变或转变著作，当散布该衍生著作时，您需采用与本
  著作相同或类似的授权条款。

+ arduino 可使用 icsp 线上烧入器，将 bootloader 烧入新的 ic 芯片。

+ 可依据arduino官方网站，取得硬件的设计档，加以调整电路板及元件，以符
  合自己实际设计的需求。

+ 可简单地与感测器，各式各样的电子元件连接，如 红外线、超音波、热敏电
  阻、光敏电阻、伺服马达…等。

+ 支援多样的互动程式，如 adobe flash, max/msp, vvvv, pure data, c,
  processing… 等。

+ 使用低价格的微处理控制器 (atmel avr) (atmega 8,168,328等)。

+ usb 界面，不需外接电源。另外有提供直流(dc)电源输入。

*** install
+ github: https://github.com/arduino/arduino
+ official page: http://www.arduino.cc/


**** overview
1. prounance: a de v no
**** install
+ https://code.google.com/p/arduino/wiki/buildingarduino

***** apt(ok)
***** source code
1. grap from github
2. cd /path/to/arduino/build
3. ant
4. ant run
***** ant run to run arduino --- not convinent

*** arduino family
+ arduino uno
+ arduino mega
+ arduino lilypad
+ arduino nano
+ ...
*** about power
**** power style
arduino boards can be supplied in three different ways:
+ by our computer via the usb cable (5 v is provided)
+ by a battery or a direct external power supply unit (psu) / adapter
+ by attaching a regulated 5 v to the +5 v pin

**** dc adapter requirements
arduino uno and mega can be directly supplied by dc adapter but
this one has to respect some characteristics:
+ the output voltage should be between 9 v and 12 v
+ it should be able to drive at least 250 ma of current
+ it must have a 2.1 mm power plug with center positive

**** when dc adapter?
usually, if you ask yourself about the fact whether to use an adapter or not, it means
you need more current than the usb's 500 ma (practically, ask yourself this question
whether you need around 400 ma).


#+downloaded: /tmp/screenshot.png @ 2015-06-10 14:57:59
 [[~/tiger/figures/141/screenshot_2015-06-10_14:57:59.png]]

**** ttyacm0
acm: usb communication device class - abstract control model

**** arduino & c & c++
arduino toolchain is based on c.

almost all arduino libraries are made using c++ in order to be easily reusable,
which is one of the most important qualities in programming.

**** native library
arduino programs can be divided in three main parts: structure, values
(variables and constants), and functions.


+ http://www.arduino.cc/en/reference/homepage

arduino programs can be divided in three main parts: /structure/,
/values/ (variables and constants), and /functions/.

|--------------------------------------------------------------------+-----------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+-------------------|
| structure                                                          | variables                   | [[http://arduino.cc/en/reference/functiondeclaration][functions]]                                                                                                                                                                                                                                                            |               |                   |
|--------------------------------------------------------------------+-----------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+-------------------|
|                                                                    |                             |                                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/setup][setup]]()                                                         | constants                   | digital i/o                                                                                                                                                                                                                                                          |               |                   |
| -  [[//www.arduino.cc/en/reference/loop][loop]]()                                                          |                             |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    | -  [[//www.arduino.cc/en/reference/constants][high]]                     | [[//www.arduino.cc/en/reference/constants][low]]                                                                                                                                                                                                                                                                  | -  [[//www.arduino.cc/en/reference/pinmode][pinmode]]()  |                   |
| control structures                                                 | -  [[//www.arduino.cc/en/reference/constants][input]]                    | [[//www.arduino.cc/en/reference/constants][output]]                                                                                                                                                                                                                                                               | [[//www.arduino.cc/en/reference/constants][input_pullup]]  | -  [[//www.arduino.cc/en/reference/digitalwrite][digitalwrite]]() |
|                                                                    | -  [[//www.arduino.cc/en/reference/constants][led_builtin]]              | -  [[//www.arduino.cc/en/reference/digitalread][digitalread]]()                                                                                                                                                                                                                                                     |               |                   |
| -  [[//www.arduino.cc/en/reference/if][if]]                                                              | -  [[//www.arduino.cc/en/reference/constants][true]]                     | [[//www.arduino.cc/en/reference/constants][false]]                                                                                                                                                                                                                                                                |               |                   |
| -  [[//www.arduino.cc/en/reference/else][if...else]]                                                       | -  [[//www.arduino.cc/en/reference/integerconstants][integer constants]]        | analog i/o                                                                                                                                                                                                                                                           |               |                   |
| -  [[//www.arduino.cc/en/reference/for][for]]                                                             | -  [[//www.arduino.cc/en/reference/fpconstants][floating point constants]] |                                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/switchcase][switch case]]                                                     |                             | -  [[//www.arduino.cc/en/reference/analogreference][analogreference]]()                                                                                                                                                                                                                                                 |               |                   |
| -  [[//www.arduino.cc/en/reference/while][while]]                                                           | data types                  | -  [[//www.arduino.cc/en/reference/analogread][analogread]]()                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/dowhile][do... while]]                                                     |                             | -  [[//www.arduino.cc/en/reference/analogwrite][analogwrite]]() - /pwm/                                                                                                                                                                                                                                             |               |                   |
| -  [[//www.arduino.cc/en/reference/break][break]]                                                           | -  [[//www.arduino.cc/en/reference/void][void]]                     |                                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/continue][continue]]                                                        | -  [[//www.arduino.cc/en/reference/booleanvariables][boolean]]                  | due & zero only                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/return][return]]                                                          | -  [[//www.arduino.cc/en/reference/char][char]]                     |                                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/goto][goto]]                                                            | -  [[//www.arduino.cc/en/reference/unsignedchar][unsigned char]]            | -  [[//www.arduino.cc/en/reference/analogreadresolution][analogreadresolution]]()                                                                                                                                                                                                                                            |               |                   |
|                                                                    | -  [[//www.arduino.cc/en/reference/byte][byte]]                     | -  [[//www.arduino.cc/en/reference/analogwriteresolution][analogwriteresolution]]()                                                                                                                                                                                                                                           |               |                   |
| further syntax                                                     | -  [[//www.arduino.cc/en/reference/int][int]]                      |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    | -  [[//www.arduino.cc/en/reference/unsignedint][unsigned int]]             | advanced i/o                                                                                                                                                                                                                                                         |               |                   |
| -  [[//www.arduino.cc/en/reference/semicolon][;]] (semicolon)                                                   | -  [[//www.arduino.cc/en/reference/word][word]]                     |                                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/braces][{}]] (curly braces)                                               | -  [[//www.arduino.cc/en/reference/long][long]]                     | -  [[//www.arduino.cc/en/reference/tone][tone]]()                                                                                                                                                                                                                                                            |               |                   |
| -  [[//www.arduino.cc/en/reference/comments][//]] (single line comment)                                        | -  [[//www.arduino.cc/en/reference/unsignedlong][unsigned long]]            | -  [[//www.arduino.cc/en/reference/notone][notone]]()                                                                                                                                                                                                                                                          |               |                   |
| -  [[//www.arduino.cc/en/reference/comments][/ /]] (multi-line comment)                                        | -  [[//www.arduino.cc/en/reference/short][short]]                    | -  [[//www.arduino.cc/en/reference/shiftout][shiftout]]()                                                                                                                                                                                                                                                        |               |                   |
| -  [[//www.arduino.cc/en/reference/define][#define]]                                                         | -  [[//www.arduino.cc/en/reference/float][float]]                    | -  [[//www.arduino.cc/en/reference/shiftin][shiftin]]()                                                                                                                                                                                                                                                         |               |                   |
| -  [[//www.arduino.cc/en/reference/include][#include]]                                                        | -  [[//www.arduino.cc/en/reference/double][double]]                   | -  [[//www.arduino.cc/en/reference/pulsein][pulsein]]()                                                                                                                                                                                                                                                         |               |                   |
|                                                                    | -  [[//www.arduino.cc/en/reference/string][string]] - char array      |                                                                                                                                                                                                                                                                      |               |                   |
| arithmetic operators                                               | -  [[//www.arduino.cc/en/reference/stringobject][string]] - object          | time                                                                                                                                                                                                                                                                 |               |                   |
|                                                                    | -  [[//www.arduino.cc/en/reference/array][array]]                    |                                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/assignment][=]] (assignment operator)                                         |                             | -  [[//www.arduino.cc/en/reference/millis][millis]]()                                                                                                                                                                                                                                                          |               |                   |
| -  [[//www.arduino.cc/en/reference/arithmetic][+ ]] (addition)                                                   | conversion                  | -  [[//www.arduino.cc/en/reference/micros][micros]]()                                                                                                                                                                                                                                                          |               |                   |
| -  [[//www.arduino.cc/en/reference/arithmetic][-]] (subtraction)                                                 |                             | -  [[//www.arduino.cc/en/reference/delay][delay]]()                                                                                                                                                                                                                                                           |               |                   |
| -  [[//www.arduino.cc/en/reference/arithmetic][]] (multiplication) | -  [[//www.arduino.cc/en/reference/charcast][char()]]                   | -  [[//www.arduino.cc/en/reference/delaymicroseconds][delaymicroseconds]]()                                                                                                                                                                                                                                               |               |                   |
| -  [[//www.arduino.cc/en/reference/arithmetic][/]] (division)                                                    | -  [[//www.arduino.cc/en/reference/bytecast][byte()]]                   |                                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/modulo][%]] (modulo)                                                      | -  [[//www.arduino.cc/en/reference/intcast][int()]]                    | math                                                                                                                                                                                                                                                                 |               |                   |
|                                                                    | -  [[//www.arduino.cc/en/reference/wordcast][word()]]                   |                                                                                                                                                                                                                                                                      |               |                   |
| comparison operators                                               | -  [[//www.arduino.cc/en/reference/longcast][long()]]                   | -  [[//www.arduino.cc/en/reference/min][min]]()                                                                                                                                                                                                                                                             |               |                   |
|                                                                    | -  [[//www.arduino.cc/en/reference/floatcast][float()]]                  | -  [[//www.arduino.cc/en/reference/max][max]]()                                                                                                                                                                                                                                                             |               |                   |
| -  [[//www.arduino.cc/en/reference/if][==]] (equal to)                                                   |                             | -  [[//www.arduino.cc/en/reference/abs][abs]]()                                                                                                                                                                                                                                                             |               |                   |
| -  [[//www.arduino.cc/en/reference/if][!=]] (not equal to)                                               | variable scope & qualifiers | -  [[//www.arduino.cc/en/reference/constrain][constrain]]()                                                                                                                                                                                                                                                       |               |                   |
| -  [[//www.arduino.cc/en/reference/if][<]] (less than)                                                   |                             | -  [[//www.arduino.cc/en/reference/map][map]]()                                                                                                                                                                                                                                                             |               |                   |
| -  [[//www.arduino.cc/en/reference/if][>]] (greater than)                                                | -  [[//www.arduino.cc/en/reference/scope][variable scope]]           | -  [[//www.arduino.cc/en/reference/pow][pow]]()                                                                                                                                                                                                                                                             |               |                   |
| -  [[//www.arduino.cc/en/reference/if][<=]] (less than or equal to)                                      | -  [[//www.arduino.cc/en/reference/static][static]]                   | -  [[//www.arduino.cc/en/reference/sqrt][sqrt]]()                                                                                                                                                                                                                                                            |               |                   |
| -  [[//www.arduino.cc/en/reference/if][>=]] (greater than or equal to)                                   | -  [[//www.arduino.cc/en/reference/volatile][volatile]]                 |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    | -  [[//www.arduino.cc/en/reference/const][const]]                    | trigonometry                                                                                                                                                                                                                                                         |               |                   |
| boolean operators                                                  |                             |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    | utilities                   | -  [[//www.arduino.cc/en/reference/sin][sin]]()                                                                                                                                                                                                                                                             |               |                   |
| -  [[//www.arduino.cc/en/reference/boolean][&&]] (and)                                                        |                             | -  [[//www.arduino.cc/en/reference/cos][cos]]()                                                                                                                                                                                                                                                             |               |                   |
| -  [[//www.arduino.cc/en/reference/boolean][                                                                |                             | ]] (or)                                                                                                                                                                                                                                                                | -  [[//www.arduino.cc/en/reference/sizeof][sizeof]]()   | -  [[//www.arduino.cc/en/reference/tan][tan]]()          |
| -  [[//www.arduino.cc/en/reference/boolean][!]] (not)                                                         | -  [[//www.arduino.cc/en/reference/progmem][progmem]]                  |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    |                             | random numbers                                                                                                                                                                                                                                                       |               |                   |
| pointer access operators                                           |                             |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    |                             | -  [[//www.arduino.cc/en/reference/randomseed][randomseed]]()                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/pointer][ dereference operator]]                                           |                             | -  [[//www.arduino.cc/en/reference/random][random]]()                                                                                                                                                                                                                                                          |               |                   |
| -  [[//www.arduino.cc/en/reference/pointer][& reference operator]]                                            |                             |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    |                             | bits and bytes                                                                                                                                                                                                                                                       |               |                   |
| bitwise operators                                                  |                             |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    |                             | -  [[//www.arduino.cc/en/reference/lowbyte][lowbyte]]()                                                                                                                                                                                                                                                         |               |                   |
| -  [[//www.arduino.cc/en/reference/bitwiseand][&]] (bitwise and)                                                 |                             | -  [[//www.arduino.cc/en/reference/highbyte][highbyte]]()                                                                                                                                                                                                                                                        |               |                   |
| -  [[//www.arduino.cc/en/reference/bitwiseand][                                                                | ]] (bitwise or)               |                                                                                                                                                                                                                                                                      | -  [[//www.arduino.cc/en/reference/bitread][bitread]]()  |                   |
| -  [[//www.arduino.cc/en/reference/bitwiseand][\^]] (bitwise xor)                                                |                             | -  [[//www.arduino.cc/en/reference/bitwrite][bitwrite]]()                                                                                                                                                                                                                                                        |               |                   |
| -  [[//www.arduino.cc/en/reference/bitwisexornot][~]] (bitwise not)                                                 |                             | -  [[//www.arduino.cc/en/reference/bitset][bitset]]()                                                                                                                                                                                                                                                          |               |                   |
| -  [[//www.arduino.cc/en/reference/bitshift][<<]] (bitshift left)                                              |                             | -  [[//www.arduino.cc/en/reference/bitclear][bitclear]]()                                                                                                                                                                                                                                                        |               |                   |
| -  [[//www.arduino.cc/en/reference/bitshift][>>]] (bitshift right)                                             |                             | -  [[//www.arduino.cc/en/reference/bit][bit]]()                                                                                                                                                                                                                                                             |               |                   |
|                                                                    |                             |                                                                                                                                                                                                                                                                      |               |                   |
| compound operators                                                 |                             | external interrupts                                                                                                                                                                                                                                                  |               |                   |
|                                                                    |                             |                                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/increment][++]] (increment)                                                  |                             | -  [[//www.arduino.cc/en/reference/attachinterrupt][attachinterrupt]]()                                                                                                                                                                                                                                                 |               |                   |
| -  [[//www.arduino.cc/en/reference/increment][--]] (decrement)                                                  |                             | -  [[//www.arduino.cc/en/reference/detachinterrupt][detachinterrupt]]()                                                                                                                                                                                                                                                 |               |                   |
| -  [[//www.arduino.cc/en/reference/incrementcompound][+=]] (compound addition)                                          |                             |                                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/incrementcompound][-=]] (compound subtraction)                                       |                             | interrupts                                                                                                                                                                                                                                                           |               |                   |
| -  [[//www.arduino.cc/en/reference/incrementcompound][=]] (compound multiplication)                                     |                             |                                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/incrementcompound][/=]] (compound division)                                          |                             | -  [[//www.arduino.cc/en/reference/interrupts][interrupts]]()                                                                                                                                                                                                                                                      |               |                   |
|                                                                    |                             | -  [[//www.arduino.cc/en/reference/nointerrupts][nointerrupts]]()                                                                                                                                                                                                                                                    |               |                   |
| -  [[//www.arduino.cc/en/reference/bitwisecompoundand][&=]] (compound bitwise and)                                       |                             |                                                                                                                                                                                                                                                                      |               |                   |
| -  [[//www.arduino.cc/en/reference/bitwisecompoundor][                                                                | =]] (compound bitwise or)     |                                                                                                                                                                                                                                                                      | communication |                   |
|                                                                    |                             |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    |                             | -  [[//www.arduino.cc/en/reference/serial][serial]]                                                                                                                                                                                                                                                            |               |                   |
|                                                                    |                             | -  [[//www.arduino.cc/en/reference/stream][stream]]                                                                                                                                                                                                                                                            |               |                   |
|                                                                    |                             |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    |                             | usb (32u4 based boards and due/zero only)                                                                                                                                                                                                                            |               |                   |
|                                                                    |                             |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    |                             | -  [[//www.arduino.cc/en/reference/mousekeyboard][keyboard]]                                                                                                                                                                                                                                                          |               |                   |
|                                                                    |                             | -  [[//www.arduino.cc/en/reference/mousekeyboard][mouse]]                                                                                                                                                                                                                                                             |               |                   |
|                                                                    |                             |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    |                             | looking for something else?                                                                                                                                                                                                                                          |               |                   |
|                                                                    |                             |                                                                                                                                                                                                                                                                      |               |                   |
|                                                                    |                             | see the [[//www.arduino.cc/en/reference/libraries][libraries page]] for interfacing with particular types of hardware. try the list of [[http://www.arduino.cc/playground/main/generalcodelibrary][community-contributed code]]. the arduino language is based on c/c++. it links against [[http://www.nongnu.org/avr-libc/user-manual/modules.html][avr libc]] and allows the use of any of its functions; see its [[http://www.nongnu.org/avr-libc/user-manual/index.html][user manual]] for details. |               |                   |
|                                                                    |                             |                                                                                                                                                                                                                                                                      |               |                   |
|--------------------------------------------------------------------+-----------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+-------------------|
*****

**** some very useful included libraries
+ *eeprom* provides functions and classes to read/write in hardware
  storage components. it is very useful to store something beyond the
  power state of the arduino, that is, even when the power is off.
+ *ethernet* helps to make layer 2 and layer 3 communications over an
  ethernet network.
+ *firmata* is used for serial communication.
+ *sd* provides an easy way to read/write sd cards; it is a more
  user-friendly alternative to the eeprom solution.
+ *servo* helps to control servo motors.

**** some external libraries
+ *tlc5940*: used to control a 16-channel, 12-bit led controller
  smoothly
+ *mstimer2*: used to trigger an action that has to be very fast and
  even each 1 ms (this library is also a nice hack of one of the
  hardware timers included inthe chipset)
+ *tone*: used to generate audible square waves

**** serial commnication with arduino
each arduino board has at least one serial port. it can be used by using digital
pins 0 and 1, or directly using the usb connection when you want to use serial
communication with your computer.

on the arduino board, you can read rx and tx on both digital pins 0 and 1
respectively. *tx* means transmit and *rx* means receive; indeed, the most basic serial
communication requires two wires.

**** serial monitoring
for *trace* for debugging

**** serial functions
+ serial.begin()
+ serial.print(val) serial.print(val, format)
+ serial.println()
*** arduino boolean                                               :boolean:
*boolean* : true/false 区分大小写

操作
+ && logical and
+ || logical or
+ ! logical not
+ if()

*** arduino型号
+ arduino *uno* 基本
+ arduino mini/pro mini  体积小
+ arduino *mega* 处理器强大，功能多
+ arduino lilypad 可穿戴的应用设计
+ arduino fio  无线项目设计
+ arduino pro 嵌入式应用设计

*** arduion常用库
1. *eeprom*
   provides functions and classes to read/write in hardware
   storage components. it is very useful to store something beyond the
   power state of the arduino, that is, even when the power is off.

2. *ethernet*
   helps to make layer 2 and layer 3 communications over an
   ethernet network.

3. *firmata*
   used for serial communication.

4. *sd*
   provides an easy way to read/write sd cards; it is a more
   user-friendly alternative to the eeprom solution.

5. *servo*
   helps to control servo motors.

6. *tlc5940*
   used to control a 16-channel, 12-bit led controller
   smoothly

7. *mstimer2*
   used to trigger an action that has to be very fast and
   even each 1 ms (this library is also a nice hack of one of the
   hardware timers included inthe chipset)

8. *tone*
   used to generate audible square waves
*** arduion power 供电
**** power style
arduino boards can be supplied in three different ways:
+ by our computer via the usb cable (5 v is provided)
+ by a battery or a direct external power supply unit (psu) / adapter
+ by attaching a regulated 5 v to the +5 v pin

**** dc adapter requirements
arduino uno and mega can be directly supplied by dc adapter but
this one has to respect some characteristics:
+ the output voltage should be between 9 v and 12 v
+ it should be able to drive at least 250 ma of current
+ it must have a 2.1 mm power plug with center positive

**** when dc adapter?
usually, if you ask yourself about the fact whether to use an adapter or not, it means
you need more current than the usb's 500 ma (practically, ask yourself this question
whether you need around 400 ma).

**** 小结
1. 三种供电方式
2. 适配器的电压电流以及接口类型

*** arduino串口通信
**** serial commnication with arduino
each arduino board has at least one serial port. it can be used by using digital
pins 0 and 1, or directly using the usb connection when you want to use serial
communication with your computer.

on the arduino board, you can read rx and tx on both digital pins 0 and 1
respectively. *tx* means transmit and *rx* means receive; indeed, the most basic serial
communication requires two wires.

**** serial monitoring
for *trace* for debugging

**** serial functions
+ serial.begin()
+ serial.print(val) serial.print(val, format)
+ serial.println()

**** 小结
1. 串口在开发板上对应的针与指示
2. 库函数与配置(?)

*** arduino sevo                                                    :servo:
[[~/tiger/figures/scrot/665pwy.png]]

[[~/tiger/figures/scrot/665oqh.png]]

**** servo
#+begin_latex
  \begin{minted}[frame=single, mathescape]{cpp}
  #include <servo.h>

  servo myservo;                  /* sevo object */

  int angle = 0;

  void setup()
  {
    //  myservo.attach(9);                /* attaches the servo on pin 10 */
    myservo.attach(9, 250, 3000);
  }

  void loop()
  {
    for(angle=0; angle<180; angle+=1){
      myservo.write(angle);
      delay(20);
    }
    for(angle=180; angle>=1; angle-=1){
      myservo.write(angle);
      delay(20);
    }
  }
  \end{minted}
#+end_latex

1. 包含头文件<servo.h>
2. 创建servo对象
3. servo::attach(pin, min, max)
   + pin 舵机信号线连接的引脚，可以使用任何数字引脚
   + min 对应于舵机最小（0°）角度时的脉冲宽度，以微秒为单位，默认544us
   + max 对应于舵机最大（180°）角度的脉冲宽度，以微秒为单位，默认为2400us
   + 典型的舵机只对脉冲的微秒数而不是度数做响应。

*** map                                                               :map:

*map(value, fromlow, fromhigh, tolow, tohigh)*

description
re-maps a number from one range to another. that is, a value of
fromlow would get mapped to tolow, a value of fromhigh to tohigh,
values in-between to values in-between, etc.

参考： [[https://www.arduino.cc/en/reference/map][arduino reference: map]]

* EmbeddedLinux                                               :embeddedlinux:
** overview: 什么是嵌入式Linux

嵌入式的应用主要是几个方向：
1. 系统开发：侧重开发环境搭建、内核原理、 交叉编译等；
2. 嵌入式Linux应用开发：侧重Linux应用编程、内核编译、系统调用；
3. 底层驱动开发：侧重嵌入式Linux系统下的驱动开发、内核的深入分析。

不过初进门者主要往系统开发和应用开发发展，有了相关工作经验再进一步向底
层驱动靠。
1. linux理论知识
   1) 计算机基本理论；
   2) CPU体系结构；
   3) 内存管理；
   4) 文件系统；
   5) 进程调度；
   6) Linux常用操作
2. linux驱动知识
   1) i2c驱动添加使用；
   2) spi驱动添加和读写
   3) io驱动
   4) dma驱动
   5) 中断源
   6) 竞争，并发，阻塞，异步，线程，内存，io，调试
   7) usb
   8) flash，文件系统
   9) 网卡驱动
   10) LCD驱动
3. linux编程知识（指令）
   1) 输入输出，文件,文件夹
   2) 字符串,数据结构，堆栈，链表，（查找）算法，二叉树
   3) 线程: 线程属性，线程同步（锁，信号量， 条件变量）
   4) 进程：守候进程，进程通信－管道，信号，SystemV（消息，共享内存，信号灯），读写锁，套接字
   5) 网络：socket，ftp客户端，tftp客户端，http server，snmp命令
   6) 环境变量，库默认搜索路径，arm-linux-gcc库路径，设置搜索路径，编译流程，lds文件，内联汇编
   7) gcc ,ld, ar, ranlib, objdump, readelf,objcopy工具
   8) make makefile
   9) shell,perl
   10) 设备编程v4l，lcd和overlayer2，串口，并口， mixer, dsp, adc, ts，
       mouse等等

** booterloader                                                 :bootloader:
*** what's  next

[[~/Wally/Journal/Figures/scrot/5970lht.png]]

*** bootloader 设计蓝图
**** bootloader作用
bootloader -> kernel -> root filesystem

引导内核(助推)
**** bootloader设计方法
+ *模仿*

+ 设计从模仿开始。

+ *模仿经典*

**** uboot快速体验
[[~/Wally/Journal/Figures/scrot/5970yrz.png]]

+ 支持多种处理器
+ 支持多种嵌入式操作系统

**** u-boot代码工程建立
1. 自主模式
   uboot自动引导内核

2. 开发模式
   uboot命令 help

**** 建立uboot代码分析工程
*sourceinsight* 阅读代码软件

uboot源码


~/wally/journal/project/embeddedlinux/uboot

*** arm处理器启动流程

s3c2440 s3c6410 s5pv210
**** 2440
***** 启动方式
1. nor flash(2m)
2. nand flash(256m)
   - uboot
   - kernel
   - filesystem
***** 地址布局

手册： nand flash *memory mapping*

*处理器上电，从0地址处取第一条指令*

nand flash 没有统一编址
+ bootram(4k) 映射nandflash前4k, steppingstone
+ 其它部分复制到内存中

[[~/Wally/Journal/Figures/scrot/5970lbf.png]]

[[~/Wally/Journal/Figures/scrot/5970yll.png]]

内存起始地址： 0x3000, 0000

***** 启动流程
**** 6410
***** 启动方式
手册： booting

[[~/Wally/Journal/Figures/scrot/5970_vr.png]]

1. srom(nor)
2. onenand
3. modem
4. irom(internal rom)
   1) nand
   2) sd/mmc

***** 地址布局
[[~/Wally/Journal/Figures/scrot/5970m6x.png]]

1. irom 0x0800, 0000
2. dram 0x5000, 0000
3. 0地址： booting device region by xom setting
   - mirrored region（镜像区域，映射irom、dram设备）

***** 启动流程
s3c6410——internal_rom_booting.pdf

[[~/Wally/Journal/Figures/scrot/5970-db.png]]

**** 210

***** 启动模式
1. irom
   1. sd
2. 串口等

***** 地址映射
[[~/Wally/Journal/Figures/scrot/5970loh.png]]

1. irom
2. 0 address
3. dram

***** 启动过程
[[~/Wally/Journal/Figures/scrot/5970yyn.png]]

irom厂商固化

bl1 : bootloader 1,  max 16kb
bl2 : bootloader 2,  max 80kb

sram？？
sdram内存

* projects
** tq2440

*** LED                                                               :led:

#+INCLUDE: ~/Wally/Project/TQ2440/led

**** why led

初始化完成之前调试手段有限，通常会采用 LED 作为程序的调试的手段

**** 原理图

1. 常见驱动电路

   [[~/Wally/Journal/Figure/scrot/24567auk.png]]

2. GPIO

   [[~/Wally/Journal/Figure/scrot/24567n4q.png]]

   General Purpose Input/Output Ports 通用可编程I/O端口

   两个寄存器

   1) 控制寄存器： 控制作为输入还是输出

   2) 数据寄存器

3. /先设计，而不是直接写程序/

4. TQ2440 引脚

   - nLED_1: GPB5
   - nLED_2: GPB6
   - nLED_3: GPB7
   - nLED_4: GPB8

**** openocd config & connect

1. 配置文件

   #+INCLUDE: ~/.openocd/tq2440.cfg

2. openocd

   #+begin_latex
   \begin{minted}[frame=leftline, mathescape]{text}
    $ openocd -f tq2440.cfg
   \end{minted}
   #+end_latex

3. gdb调试还不行

**** makefile

#+INCLUDE: ~/Wally/Project/TQ2440/led/Makefile

1. arm-linux-gcc -g -o led.o -c led.S

2. arm-linux-ld -Tled.lds -o led.elf led.o

3. arm-linux-objcopy -O binary led.elf led.bin

**** 烧录

*halt -> probe -> write -> resume*

#+BEGIN_EXAMPLE
  > halt
  target state: halted
  target halted in ARM state due to debug-request, current mode: Supervisor
  cpsr: 0x200000d3 pc: 0x0235a224
  MMU: disabled, D-Cache: disabled, I-Cache: disabled
  > nand write 0 /home/wally/Wally/Project/TQ2440/led/led.bin 0
  #0: not probed
  wrote file /home/wally/Wally/Project/TQ2440/led/led.bin to NAND flash 0 up to offset 0x00000000 in 1452519424.000000s (0.000 KiB/s)
  > nand probe 0
  NAND flash device 'NAND 256MiB 3.3V 8-bit (unknown)' found
  > nand write 0 /home/wally/Wally/Project/TQ2440/led/led.bin 0
  wrote file /home/wally/Wally/Project/TQ2440/led/led.bin to NAND flash 0 up to offset 0x00000800 in 2.116011s (0.098 KiB/s)
#+END_EXAMPLE

*** TODO initialization
- State "TODO"       from ""           [2016-01-11 一 21:39] \\
  烧录
**** Exception

***** 异常类型

[[~/Wally/Journal/Figures/scrot/24567mMA.png]]

***** 异常向量

当一种异常发生的时候，ARM处理器会跳转到对应该异常的固定地址去执行异常
处理程序，而这个固定的地址，就称之为 /异常向量/ 。

两组： CP15 协处理器配置为高位时，选择后者。一般都使用前一组。

***** 异常向量表

由七个异常向量及其处理函数跳转关系组成的表即为异常向量表.

#+BEGIN_SRC asm
  _start
    0x00000000: b reset
    0x00000004: ldr pc, _undefined_instruction
    0x00000008: ldr pc, _software_interrupt
    0x00000008: ldr pc, _software_interrupt
    0x0000000c: ldr pc, _prefetch_abort
    0x00000010: ldr pc, _data_abort
    0x00000014: ldr pc, _not_used ; 占位
    0x00000018: ldr pc, _irq
    0x0000001c: ldr pc, _fiq
#+END_SRC

***** 代码

****** start.S
#+include: ~/Wally/Journal/Project/ARM/init/start.S :src asm

****** gboot.lds 链接器脚本
#+include: ~/Wally/Journal/Project/ARM/init/gboot.lds

****** makefile
#+include: ~/Wally/Journal/Project/ARM/init/makefile :src makefile

****** 210 加头

check sum

[[~/Wally/Journal/Figures/scrot/24567zWG.png]]

[[~/Wally/Journal/Figures/scrot/24567AhM.png]]

**** 设置 scv 模式

***** how

[[~/Wally/Journal/Figures/scrot/24567NrS.png]]

Linux/bootloader 工作在 Supervisor(/svc/) 模式

通过程序状态寄存器(/CPSR/)设置 (M[4:0])

[[~/Wally/Journal/Figures/scrot/24567a1Y.png]]

***** 步骤

1) 清零： bic
2) 置1: orr
3) /MRC/ /MSR/ 指令

***** code

#+include: ~/Wally/Journal/Project/ARM/init/start.S :src asm

#+BEGIN_SRC asm
  reset:
          mrc r0, cpsr
          bic r0, r0, #0x1f       ; 清零
          orr r0, r0, #0x13       ; 置一, 0xd3 同时设置 中断和快速中断
          msr cpsr, r0
#+END_SRC
**** 关闭看门狗
***** watchdog

在嵌入式领域，有些系统需要长期运行在无人看守的环境。在运行过程中，难免
不出现系统死机的情况，这时就需要系统自身带有一种自动重启的功能。
/watchdog/ 一般是一个 *硬件模块* ，其作用就是 _在系统死机时，帮助系统
实现自动重启_

***** 工作方式

Watchdog在硬件上实现了 /计时/ 功能，启动计时后，用户（软件）必须在计时结束
前重新开始计时，俗称“ /喂狗/ ”， _如果到超时的时候还没有重新开始计时，
那么它就认为系统是死机了，就自动重动系统_

***** 硬件电路

[[~/Wally/Journal/Figures/scrot/24567n_e.png]]

1. 分频: Prescaler
2. 计数: Down Counter
3. RESET

***** why 关闭看门狗

bootloader 功能比较简单。 不需要循环 喂狗。

***** how: WTCON: watchdog timer control register

[[~/Wally/Journal/Figures/scrot/24567Oex.png]]

***** code

#+include: ~/Wally/Journal/Project/ARM/init/start.S :src asm

#+BEGIN_SRC asm
  #define pWTCON 0x53000000       ; address of watch dog
  disable_watchdog:
          ldr r0, =pWTCON
          mv r1, #0x0
          str r1, [r0]
#+END_SRC

**** 关闭中断

***** how
1. CPSR: I位(中断)、 F位(快速中断) 置1
2. 中断屏蔽寄存器: /INTMASK/:INTERRUPT MASK (INTMSK) REGISTER(2440)

   [[~/Wally/Journal/Figures/scrot/24567AoA.png]]

3. 向量中断6410/240: INTERRUPT ENABLE REGISTER(使能)， /VIC0INTENCLEAR/

***** code
#+include: ~/Wally/Journal/Project/ARM/init/start.S :src asm

**** 关闭 MMU 与 Cache

***** 存储体系

[[~/Wally/Journal/Figures/scrot/24567NyG.png]]

1. 内部寄存器： 速度快，数量少
2. TCM: Cache
3. 辅助存储器： Flash, SD

***** cache

[[~/Wally/Journal/Figures/scrot/24567a8M.png]]

Cache是一种容量小但存取速度非常快的存储器，它保存最近用到的存储器中数
据的拷贝。对于程序员来说，Cache是透明的。它自动决定保存哪些数据、覆盖
哪些数据。按照功能划分

+ /I-Cache/: 指令Cache，用于存放指令
+ /D-Cache/: 数据Cache，用于存放数据

从手册中查阅

[[~/Wally/Journal/Figures/scrot/245670QZ.png]]

***** 虚拟地址

+ /物理地址/: 物理存储单元实际的地址
+ /虚拟地址/: 程序中使用的地址, 映射为物理地址(/MMU/)
  -可以让进程使用更大的空间
  -可以解决冲突

***** MMU

[[~/Wally/Journal/Figures/scrot/24567Bbf.png]]

注： arm11 前后区别

***** code

#+include: ~/Wally/Journal/Project/ARM/init/start.S :src asm

/CP15/ ARM920T

1. 全 I-Cache D-Cache 失效
2. 关闭 I/D-Cache 和 MMU

** avrpro

#+INCLUDE: ~/Wally/Project/avrpro/README.md
#+INCLUDE: ~/Wally/Project/avrpro/ChangeLog.org

- [[~/Wally/Reference/Chip/MCU/Atmega16.pdf][Atmage16]]
- [[~/Wally/Reference/Manual/AvrdudeManual.pdf][AvrdudeManual.pdf]]
- [[~/Wally/Reference/Manual/AvrLibcUserManual-1.8.0.pdf][AvrLibcUserManual-1.8.0.pdf]]

*** LED

#+INCLUDE: ~/Wally/Project/avrpro/src/led/led1.c

#+BEGIN_SRC makefile
  led1.o:led1.c
          avr-gcc -mmcu=atmega16 -c led1.c
  led1.elf:led1.o
          avr-gcc -mmcu=atmega16 -o led1.elf led1.o
  led1.hex:led1.elf
          avr-objcopy -j .text -j .data -O ihex led1.elf led1.hex
  .PHONY:upload
  upload:led1.hex
          sudo avrdude -p m16 -c usbasp -e -U flash:w:"led1.hex"
#+END_SRC

/编译烧录成功，但是没有效果！？/

**** 手记
#+BEGIN_EXAMPLE
  led $ cat makefile
  led1.o:led1.c
          avr-gcc -mmcu=atmega16 -c led.c
  led1.elf:ledl.o
          avr-gcc -mmcu=atmega16 -O led1.elf led1.o
  led1.hex:led1.elf
          avr-objcopy -j .text -j .data -O ihex led1.elf led1.hex
  led $ make led1.o
  avr-gcc -mmcu=atmega16 -c led.c
  avr-gcc: error: led.c: 没有那个文件或目录
  avr-gcc: fatal error: no input files
  compilation terminated.
  make: *** [led1.o] 错误 1
  led $ make led1.o
  avr-gcc -mmcu=atmega16 -c led1.c
  In file included from led1.c:2:0:
  /usr/lib/avr/include/util/delay.h:90:3: warning: #warning "F_CPU not defined for <util/delay.h>" [-Wcpp]
   # warning "F_CPU not defined for <util/delay.h>"
     ^
  /usr/lib/avr/include/util/delay.h:95:3: warning: #warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed" [-Wcpp]
   # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
     ^
  led $ ls
  led1.c  led1.o  makefile  makefile~
  led $ make led1.elf
  make: *** 没有规则可以创建“led1.elf”需要的目标“ledl.o”。 停止。
  led $ make led1.elf
  avr-gcc -mmcu=atmega16 -O led1.elf led1.o
  avr-gcc: error: led1.elf: 没有那个文件或目录
  make: *** [led1.elf] 错误 1
  led $ make led1.elf
  avr-gcc -mmcu=atmega16 -O led1.elf led1.o
  avr-gcc: error: led1.elf: 没有那个文件或目录
  make: *** [led1.elf] 错误 1
  led $ make led1.elf
  avr-gcc -mmcu=atmega16 -o led1.elf led1.o
  led $ ls
  led1.c  led1.elf  led1.o  makefile  makefile~
  led $ make led1.hex
  avr-objcopy -j .text -j .data -o ihex led1.elf led1.hex
  avr-objcopy：无效选项 -- o
  用法：avr-objcopy [选项] 输入文件 [输出文件]
   复制二进制文件，可能在此过程中进行变换
   选项为：
    -I --input-target <bfdname>      Assume input file is in format <bfdname>
    -O --output-target <bfdname>     Create an output file in format <bfdname>
    ...
  avr-objcopy：支持的目标： elf32-avr elf32-little elf32-big srec symbolsrec verilog tekhex binary ihex
  make: *** [led1.hex] 错误 1
  led $
  led $ make led1.hex
  avr-objcopy -j .text -j .data -O ihex led1.elf led1.hex
#+END_EXAMPLE


* progess

** Raspberry 学习

#+BEGIN_EXAMPLE
- State "TODO"       from ""           [2015-11-23 一 15:07]
#+END_EXAMPLE

*** TODO 项目规化
- State "TODO"       from ""           [2015-11-23 一 15:07]

** Arduino 学习

#+BEGIN_EXAMPLE
- State "TOBECONTINED" from ""           [2015-11-23 一 14:57]
#+END_EXAMPLE

*** TODO 项目规化 [0/2]
1. [ ] 教材选择： 《Arduino Cookbook》
2. [ ] 整理已学习内容并制定新的计划

** ARM嵌入式系统开发
*** ARM基础
**** RISC设计思想

RISC是一种设计思想, 旨在设计出一套能在 *高时钟频率* 下 *单周期执行*, *
简单而有效* 的指令集, 设计重点在于降低硬件执行指令的复杂度.
+ 指令集: 单周期
+ 流水线: 并行
+ 寄存器: 通用
+ load-store结构: 外存访问

**** ARM设计思想
***** 客观需求
+ 低功耗
+ 高的代码密度
+ 存储器价格
+ 内核管芯面积(die)

***** 不同于RISC
+ 特定指令周期可变
+ 桶形移位器
+ Thumb 16位
+ 条件执行
+ 增强指令, eg, DSP支持
**** 嵌入式系统的硬件
***** ARM处理器
***** 控制器
+ 存储控制器
+ 中断控制器
  + 标准中断控制器
  +向量中断控制器(VIC): 优先级
***** 存储器
****** 层次
性能trade-off成本
+ cache
+ 主存
+ 辅助存储器

****** 宽度
8/16/32/64

****** 类型
+ ROM: 大宗
+ Flash ROM: 设备固件
+ DRAM: 需要设置控制器
+ SRAM: 高速存储器和cache
+ SDRAM: 同步动态随机访问存储器
***** 外设
*所有的ARM外设都是存储器映射---编程接口是一组对应于某些存储器地址的寄
存器. 这些寄存器的地址是某个特定外设的基地址的偏移量*

***** 总线
1. VS x86
   + x86 PC: PCI, 片间总线
   + ARM: 片上总线
2. 总结层次
   + 物理层: 电气特征, 宽度
   + 协议层(ARM)
3. AMBA(高级微控总线结构)
   + ASB(ARM系统总线)
   + APB(ARM外设总线)
   + AHB(ARM商性能总线)
**** 嵌入式系统的软件
***** 初始化(启动)代码
启动代码使处理器从复位状态进入到操作系统能够运行的状态.
+ 初始化配置
+ 诊断
+ 引导
***** 设备驱动
***** 操作系统
+ 实时操作系统(RTOS)
+ 平台操作系统: Linux
***** 应用程序
