# es.org --- containing notes on embedded system

* Develop Tools
** overview
*** Linux下嵌入式开发工具

1. 编辑

   - Emacs是不二之选

2. 编译

   - 51: sdcc
   - avr: avrgcc
   - arm: gcc工具链

3. 烧录

   - 51: ASEM51
   - avr: avrdude
   - arduino: arduino IDE
   - ARM: OpenOcd
   - DSP(TI): CCS

4. 调试： 同上

5. 仿真： 暂时用不到

6. 电路设计： eagle

*** linux 51 开发                                                      :51:

http://andyhuzhill.github.io/html/shaolu.html
http://forum.ubuntu.org.cn/viewtopic.php?f=97&t=327501
https://www.google.com/?gws_rd=ssl#q=linux+51+%e7%83%a7%e5%bd%95

linux下做单片机必然是没有问题的, 有问题的是windows在中国一统天下.

引用豆瓣的话, stc是一家垃圾的公司。下载协议没有公开，所以，下载器不好
做。

经典的51(at89s52)单片机为何不用, 资料又丰富.

*** Linux 下 AVR 开发环境                                             :avr:

- [[https://app.yinxiang.com/Home.action#n=9c09ae6a-512d-42b1-a8b0-731e9bba8e7f&ses=1&sh=5&sds=5&x=avrdude&][Linux 下 AVR 开发环境搭建]]
- [[http://www.atmel.com/webdoc/AVRLibcReferenceManual/index.html][Atmel: AVR Libc Reference Manual]]


gcc-avr + avr-libc + binutils-avr + avrdude + usbisp

1) MCU: Atmega16
2) 编辑器： Emacs
3) 编译器： gcc-avr
4) 编程器： avrdude
5) 下载器： usbasp
6) 仿真： [[http://savannah.nongnu.org/projects/simulavr/][simulavr]]
7) 调试： avr-gdb, [[http://sourceforge.net/projects/avarice/][AvaRICE]]

#+BEGIN_EXAMPLE
  1 $ avr-
  avr-addr2line   avr-g++         avr-gprof       avr-ranlib
  avr-ar          avr-gcc         avr-ld          avr-readelf
  avr-as          avr-gcc-4.8.1   avr-ld.bfd      avr-size
  avr-c++         avr-gcc-ar      avr-man         avr-strings
  avr-c++filt     avr-gcc-nm      avr-nm          avr-strip
  avr-cpp         avr-gcc-ranlib  avr-objcopy
  avr-elfedit     avr-gcov        avr-objdump
#+END_EXAMPLE

*** ARM IDE                                                           :ide:
**** emide

http://www.emide.org/

**** eclispe                                                     :eclipse:

http://blog.csdn.net/cxw3506/article/details/8292331

1. eclipse: eclipse的本身只是一个框架平台，但是众多插件的支持，使得
   eclipse拥有较好的灵活性。

2. cdt: cdt是eclipse用于扩展eclipse支持c/c++开发的插件。

3. zylin cdt: 支持eclipse用于嵌入式c/c++开发和远程调试的插件

4. yagarto:  yagarto整合了gnu arm的交叉编译工具链，是一个跨平台的 arm
   架构开发平台，是一个 eclipse 的插件。

5. j-link gdb server:  a jtag gdb debug agent run on host

**** ARM Crop

+ rvds
+ ads
+ arm ds development studio

**** keil uvision

**** 小结

ARM IDE 使用 ECLISPE

*** [[http://forum.ubuntu.org.cn/viewtopic.php?f=97&t=327501][Linux系统下去烧录单片机]]                                          :blog:

怎样在Linux系统下去烧录单片机51,avr,pic,fpga等实现实时控制子系统

**** 编辑器

首先介绍一下编辑器，emacs,vi,geany,等通用编辑器，（本人用终端的nano编
辑器），把源代码编辑好之后进入以下环节。

二进制和hex编辑器有 beav, bless, bvi,lfhex等是不错的bin和hex文件的编辑
器。

**** 编译器

其次是用软件把源代码编译成微控制器可以识别的代码，这里必须用的就是sdcc
编译器(Small Device C Compiler)和gcc,gcc-avr，gcc-m68x,等。

＊SDCC 是小型器件c编译器，集成和优化的ANSI- C编译器目标是可以对英特尔
8051，maxium,80DS390，Zilog公司的Z80和摩托罗拉68HC08微控制器。工作是支
持 Microchip的PIC16和PIC18系列的进展。SDCC是自由开放源码软件，在GNU通
用公共许可证（GPL）发布。

编程的语言以c和汇编为主。

gcc就太熟悉了。


还有一些专门针对固定器件的编译器：

1. mcu8051 ide, ASEM51(汇编），UISP, as31, dis51,等是专门针对51系列单片机的编译软件；
2. avra,avarice,arduino ide 等是专业针对avr系列进行编译的软件；
3. pikdev, piklab,gputil(兼容MPASM）等软件是专业针对microchip公司的pic和dspic系列的芯片进行编译和反编译的软件。
4. a56, crasm, biuntils-m68hc1x等是专业针对motorola, freescale 的 编译软件。
5.z80asm , z80dasm是专业针对zilog的 z80器件进行编译的软件。

等等... ... 很有很多

**** 烧录软件和jtag在线调试

把编译的代码可以直接烧录到芯片中，这个是开发的必经之路。必须确定烧录硬
件的可行性和正确性等，然后进行烧录。



1. 51系列的ASEM51支持的最多，http://plit.de/asem-51/derivat.htm， 几乎
   支持所有厂家的8051各个型号芯片。用BOOT-51写入到eeprom.这个软件也是
   教程最完善的一个。

2. MCU 8051 这个IDE包含模拟仿真器，源代码编辑器，汇编器，硬件编程器和
   许多其他工具。是工具最全的51开发环境。
   http://mcu8051ide.sourceforge.net/

3. s51dude,是一个专业的，基于终端的针对AT89S8252，AT89s53的isp烧录软件，
   usbtiny.http://gd.tuwien.ac.at/opsys/linux/debi ... s/s51dude/

4. uisp, 是一个专业的，基于终端的针对AT89S518252，AT89s52的isp烧录软
   件,http://www.nongnu.org/uisp/

5. usbprog,是一个针对usb转rs 232 的一个烧录软件，主要应用到avr 和 arm
   的固件烧录,（有一个固定的硬件）。
   http://www2.embedded-projects.net/index.php?page_id=165

6. arduino是一个有专业电路板（arduino电路板）的avr 的集成开发环境（有
   一个固定硬件）。
   http://www.arduino.cc/

7. avrp是一个针对flash和eeprom的烧录软件，应用到avr 8位系列的单片机和
   at89系列的单片机。
   http://www.colargol.tihlde.hist.no/~jonah/el/avrp.html

8. avrprog是一个针对atmel公司的avr系列的isp烧录软件，基于通过pc的并口
   转串口器件的烧录。
   http://sourceforge.net/projects/avrprog/

9. avrdude是一个针对avr的isp烧录软件，针对rom和eeprom,基于终端操作。
   http://www.nongnu.org/avrdude/

10. gdb avr, 是一个源代码调试软件，基于avr.
    http://packages.debian.org/search?keywords=gdb-avr

11. picp,是一个比MPlab要快的软件，支持PICSTAR，Warp-13 or JuPic等编程
    器。
    http://pp06.sourceforge.net/picp.html

12. pikdev是一个集成开发环境，同时支持并口，串口和usb全系列编程器进行
    烧录pic和dspic全系列的芯片。（piklab是基于pikdev开发的）。
    http://pikdev.free.fr/

13. ARM和FPGA等一些支持jtag的芯片可以直接用openOCD, openwince-jtag,
    urjtag进行调试。
    http://openocd.berlios.de/web/
    http://urjtag.org/

14. TI系列的就可以用TI CCS 5.0.2 进行开发， 详细可见:TI CCS 5.0.1 支持
    linux
    下载地
    址:http://processors.wiki.ti.com/index.php/Category:Code_Composer_Studio_v5

**** 仿真软件和仿真器：同时可以用相关的专业软件进行仿真。

比如emu8051可以仿真51系列，gnusim8085是intel 8085的ide软件，simulavr，
avarice可以仿真avr系列，gpsim,simulpic,nitpic等针对microchip公司的pic
和dspic系列， softgen,是专业针对arm和dsp等进行嵌入仿真的软件，spim是
mips R2000/R3000系列的仿真，coldfire是freescalecoldfire 5206仿真器，
freeHDL是VHDL 在linux 环境下的仿真软件，verilator是一个verilog的仿真软
件，sdcc-ucsim是一个MCS51 family, HC08 and Z80通用的仿真软件，

**** 基础电路设计

qucs是一个不错的基础电路设计和仿真软件。

kicad是一个支持3d仿真的pcb设计软件，　包括原理图和元件库等。也可以选择
eagle, geda, pcb等开源pcb软件。

**** 总结：

到此，相信电子爱好者，同时也是Linux和开源铁杆用户们，可以尽情的去开发

*** [[http://andyhuzhill.github.io/html/shaolu.html][Linux系统下烧录单片机]] :blog:

** avrlibc                                                     :avrlibc:avr:

*** reference                                                    :homepage:

- [[http://www.nongnu.org/avr-libc/][AVR Libc Homepage]]
- [[~/Wally/Reference/Manual/AvrLibcUserManual-1.8.0.pdf][AvrLibcUserManual-1.8.0.pdf]]

*** overview

/AVR Libc/ is a *Free Software* project whose goal is to
_provide a high quality C library for use with GCC on Atmel AVR
microcontrollers_.

Together, /avr-binutils/, /avr-gcc/, and /avr-libc/ form the heart of
the Free Software toolchain for the Atmel AVR microcontrollers.

They are further accompanied by projects for in-system programming
software (/avrdude/), simulation (/simulavr/) and debugging
(/avr-gdb/, AVaRICE).

*** installation                                                    :install:

1. download page: http://download.savannah.gnu.org/releases/avr-libc/

   version: 1.8.1

2. compile

   #+BEGIN_EXAMPLE
   $ ./configure --build=`./config.guess` --host=avr
   #+END_EXAMPLE

   error: avrgcc, 不玩了

   #+BEGIN_EXAMPLE
     configure: error: Wrong C compiler found; check the PATH!
   #+END_EXAMPLE

3. 新得立： 1.8.0

   依赖： gcc-avr, binutils-avr

** avrdude                                                     :avrdude:avr:
*** reference

+ [[http://www.nongnu.org/avrdude/][homepage]]
+ [[~/Wally/Reference/Manual/AvrdudeManual.pdf][AvrdudeManual.pdf]]

*** overview

**** what?

*AVRDUDE* is an utility to *download/upload/manipulate* the ROM and
EEPROM contents of AVR microcontrollers using the in-system
programming technique (*ISP*).

简言之， *AVR在线烧录*

**** features

1. 命令行 -> 自动化，makefile
2. terminal mode
3. 跨平台
4. 支持多烧录器, ISP/JTag/Serial
5. 支持多种格式，hex/bin

**** installation                                                :install:

1. download page: http://download.savannah.gnu.org/releases/avrdude/

   version: 6.2

2. compile

   #+BEGIN_EXAMPLE
   $ ./configure & make & make install
   #+END_EXAMPLE

*** usage
**** help                                                           :help:

#+BEGIN_EXAMPLE
  Usage: avrdude [options]
  Options:
    -p <partno>                Required. Specify AVR device.
    -b <baudrate>              Override RS-232 baud rate.
    -B <bitclock>              Specify JTAG/STK500v2 bit clock period (us).
    -C <config-file>           Specify location of configuration file.
    -c <programmer>            Specify programmer type.
    -D                         Disable auto erase for flash memory
    -i <delay>                 ISP Clock Delay [in microseconds]
    -P <port>                  Specify connection port.
    -F                         Override invalid signature check.
    -e                         Perform a chip erase.
    -O                         Perform RC oscillator calibration (see AVR053).
    -U <memtype>:r|w|v:<filename>[:format]
                               Memory operation specification.
                               Multiple -U options are allowed, each request
                               is performed in the order specified.
    -n                         Do not write anything to the device.
    -V                         Do not verify.
    -u                         Disable safemode, default when running from a script.
    -s                         Silent safemode operation, will not ask you if
                               fuses should be changed back.
    -t                         Enter terminal mode.
    -E <exitspec>[,<exitspec>] List programmer exit specifications.
    -x <extended_param>        Pass <extended_param> to programmer.
    -y                         Count # erase cycles in EEPROM.
    -Y <number>                Initialize erase cycle # in EEPROM.
    -v                         Verbose output. -v -v for more.
    -q                         Quell progress output. -q -q for less.
    -l logfile                 Use logfile rather than stderr for diagnostics.
    -?                         Display this usage.
#+END_EXAMPLE
**** example

$ sudo avrdude -p 8052 -c usbasp -e -U flash:w:'跑马灯.hex'

#+BEGIN_SRC makefile
  main：
      sdcc liushui.c
      # SDCC默认的输出格式是ihx 我们把它转换成hex
      packihx liushui.ihx>liushui.hex
      sudo avrdude -p 8052 -c usbasp -e -U flash:w:liushui.hex
#+END_SRC

*** configure                                                   :configure:

#+include: /etc/avrdude.conf

**** programmer(编程器)
***** list

#+BEGIN_EXAMPLE
  $ avrdude -c foo                # a little tricky

  avrdude: Can't find programmer id "foo"

  Valid programmers are:
    2232HIO          = FT2232H based generic programmer
    4232h            = FT4232H based generic programmer
    89isp            = Atmel at89isp cable
    abcmini          = ABCmini Board, aka Dick Smith HOTCHIP
    alf              = Nightshade ALF-PgmAVR, http://nightshade.homeip.net/
    arduino          = Arduino

#+END_EXAMPLE

***** format example

#+BEGIN_EXAMPLE
#   programmer
#       parent <id>                                 # optional parent
#       id       = <id1> [, <id2> [, <id3>] ...] ;  # <idN> are quoted strings
#       desc     = <description> ;                  # quoted string
#       type     = <type>;                          # programmer type, quoted string
#                          # supported programmer types can be listed by "-c ?type"
#       connection_type = parallel | serial | usb
#       baudrate = <num> ;                          # baudrate for avr910-programmer
#       vcc      = <num1> [, <num2> ... ] ;         # pin number(s)
#       buff     = <num1> [, <num2> ... ] ;         # pin number(s)
#       reset    = <num> ;                          # pin number
#       sck      = <num> ;                          # pin number
#       mosi     = <num> ;                          # pin number
#       miso     = <num> ;                          # pin number
#       errled   = <num> ;                          # pin number
#       rdyled   = <num> ;                          # pin number
#       pgmled   = <num> ;                          # pin number
#       vfyled   = <num> ;                          # pin number
#       usbvid   = <hexnum>;                        # USB VID (Vendor ID)
#       usbpid   = <hexnum>;                        # USB PID (Product ID)
#       usbdev   = <interface>;                     # USB interface or other device info
#       usbvendor = <vendorname>;                   # USB Vendor Name
#       usbproduct = <productname>;                 # USB Product Name
#       usbsn    = <serialno>;                      # USB Serial Number
#
#        To invert a bit, use = ~ <num>, the spaces are important.
#        For a pin list all pins must be inverted.
#        A single pin can be specified as usual = ~ <num>, for lists
#        specify it as follows = ~ ( <num> [, <num2> ... ] ) .
#     ;
#+END_EXAMPLE

**** part
***** format

#+BEGIN_EXAMPLE
  #   part
  #       id               = <id> ;                 # quoted string
  #       desc             = <description> ;        # quoted string
  #       has_jtag         = <yes/no> ;             # part has JTAG i/f
  #       has_debugwire    = <yes/no> ;             # part has debugWire i/f
  #       has_pdi          = <yes/no> ;             # part has PDI i/f
  #       has_tpi          = <yes/no> ;             # part has TPI i/f
  #       devicecode       = <num> ;            # deprecated, use stk500_devcode
  #       stk500_devcode   = <num> ;                # numeric
  #       avr910_devcode   = <num> ;                # numeric
  #       signature        = <num> <num> <num> ;    # signature bytes
  #       chip_erase_delay = <num> ;                # micro-seconds
  #       reset            = dedicated | io;
  ...
#+END_EXAMPLE

***** At89S52(测试没有成功)                                         :at89s52:

+ http://www.avrfreaks.net/forum/writing-at89s52-through-usbasp

Avrdude默认配置中没有用于烧写51单片机的target对象，需要自己配置。

#+BEGIN_EXAMPLE
#------------------------------------------------------------
# Below chips by added by me .. Joy Shukla(joy_shukla@yahoo.in)
# these chips can be programmed with my usbasp programmer(changed atmega8 program)
# after adding avrdude support in this file ..
#------------------------------------------------------------

#------------------------------------------------------------
# AT89S52
#------------------------------------------------------------
part
    id               = "8052";
    desc             = "AT89S52";
    signature        = 0x1E 0x52 0x06;
    chip_erase_delay = 20000;
    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                       "x x x x  x x x x    x x x x  x x x x";

    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
                       "x x x x  x x x x    x x x x  x x x x";

    timeout      = 200;
    stabdelay      = 100;
    cmdexedelay      = 25;
    synchloops      = 32;
    bytedelay      = 0;
    pollindex      = 3;
    pollvalue      = 0x53;
    predelay      = 1;
    postdelay      = 1;
    pollmethod      = 0;

    memory "flash"
        size            = 8192;
        paged           = no;
        min_write_delay = 4000;
        max_write_delay = 9000;
        readback_p1     = 0xff;
        readback_p2     = 0xff;
        read            = "  0   0   1   0    0   0   0   0",
                          "  x   x   x a12  a11 a10  a9  a8",
                          " a7  a6  a5  a4   a3  a2  a1  a0",
                          "  o   o   o   o    o   o   o   o";

        write           = "  0   1   0   0    0   0   0   0",
                          "  x   x   x a12  a11 a10  a9  a8",
                          " a7  a6  a5  a4   a3  a2  a1  a0",
                          "  i   i   i   i    i   i   i   i";
   mode      = 0x21;
   delay      = 12;
      ;

    memory "signature"
        size            = 3;
        read            = "0  0  1  0   1  0  0  0   x  x  x  0   0  0 a1 a0",
                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
      ;
  ;
#+END_EXAMPLE

*** test
**** 自定义 ISP/ASP

1. 参考: programmer usbasp & usbasp-clone

2. benusp

   #+BEGIN_EXAMPLE
     programmer
       id    = "benisp";
       desc  = "Any usbasp clone with correct VID/PID";
       type  = "usbasp";
       connection_type = usb;
       usbvid    = 0x03eb; # VOTI
       usbpid    = 0xc8b4; # Obdev's free shared PID
       #usbvendor  = "";
       #usbproduct = "";
     ;
   #+END_EXAMPLE

3. test(not work)

   #+BEGIN_EXAMPLE
     Ardude $ avrdude -p 8052 -c benasp

     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted
     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted
     avrdude: warning: cannot set sck period. please check for usbasp firmware update.
     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted
     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted
     avrdude: error: programm enable: target doesn't answer. 0
     avrdude: initialization failed, rc=-1
              Double check connections and try again, or use -F to override
              this check.

     avrdude: error: usbasp_transmit: error sending control message: Operation not permitted

     avrdude done.  Thank you.

     Ardude $ sudo avrdude -p 8052 -c benasp

     avrdude: warning: cannot set sck period. please check for usbasp firmware update.
     avrdude: error: programm enable: target doesn't answer. 0
     avrdude: initialization failed, rc=-1
              Double check connections and try again, or use -F to override
              this check.
   #+END_EXAMPLE

   1. 权限
   2. 配置不对

**** ISP测试

接入 USB ISP 后的反应

#+BEGIN_EXAMPLE
Ardude $ lsusb
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
...

Ardude $ lsusb
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
...
Bus 003 Device 003: ID 03eb:c8b4 Atmel Corp.
#+END_EXAMPLE

clk
#+BEGIN_EXAMPLE
   $ sudo avrdude -p 8052 -c benisp

  avrdude: warning: cannot set sck period. please check for usbasp firmware update.
  avrdude: error: programm enable: target doesn't answer. 0
  avrdude: initialization failed, rc=-1
           Double check connections and try again, or use -F to override
           this check.


  avrdude done.  Thank you.
#+END_EXAMPLE

/Warning 只是警告，不是错误/

#+BEGIN_EXAMPLE
avrdude: warning: cannot set sck period. please check for usbasp
firmware update.
#+END_EXAMPLE

**** usbasp测试

***** [[https://detail.tmall.com/item.htm?id=44102479119&spm=a1z09.2.0.0.Qt1XKV&_u=9mb80en1c47][Taobao上有一些资料]]

atmega8a
[[~/Wally/Journal/Figure/scrot/2472pvk.png]]

1.支持AT89S51/52单片机
2.支持AVR所有ASP芯片。
3.输出端口为ATMEL标准端口。
4.有USB取电和目标板支持目标电压5V，可通过跳线帽连接选择。
5.可AUTOSPEED 自动调速固件，下载器会自动跟踪要编程的芯片频率，自动改变速度，达到自动调速。
6.预留 MOSI，MISO，RET，SCK，VCC，GND。 6PIN接口，方便使用者根据需要连接目标板。

7.预留 PROGRAMMING 编程接口，用户可自行升级下载器固件。

编程软件：AVR_fighter,PROGISP1.66,PROGISP1.67,PROGISP1.68编译更低或者
更高软件都行、烧片一气呵成，非常方便。

支持烧写的芯片：

1. 51系列

   + AT89S51
   + AT89S52
   + AT89S53
   + AT89S8253
   + AT89S2051
   + AT89S8252
   + AT89S4051

2. AVR系列

   #+BEGIN_EXAMPLE
     AT90can128 AT90can32

     AT90can64, AT90pwm2, AT90pwm3, AT90s1200, AT90s2313, AT90s2323,
     AT90s2343, AT90s4414, AT90S8515, AT90S8535,  AT90usb1286, AT90usb1287

     Atmega103, Atmega128, Atmega1280, Atmega1281, Atmega16, Atmega161,
     Atmega162, Atmega163, Atmega164, Atmega165, Atmega168, Atmega169,
     Atmega2560, Atmega2561, Atmega32, Atmega323, Atmega324, Atmega325,
     Atmega3250, Atmega3259, Atmega328, Atmega329, Atmega3290, Atmega406,
     Atmega48, Atmega64, Atmega640, Atmega644, Atmega645, Atmega6450,
     Atmega649, Atmega6490, Atmega8, Atmega8515, Atmega8535, Atmega88,


     Attiny11, Attiny12, Attiny13 , Attiny15, Attiny22, Attiny2313,
     Attiny24,Attiny25, Attiny26, Attiny261,  Attiny28, Attiny44,
     Attiny45, Attiny46, Attiny46, Attiny84, Attiny85, Attiny861
   #+END_EXAMPLE

[[~/Wally/Journal/Figure/scrot/247225q.png]]

***** 虚拟机中测试

装驱动：51开发板的资料中有，可以用。

烧录软件: /progisp/

[[~/Wally/Journal/Figure/scrot/2472CYG.png]]

***** Ubuntu中测试

1. usbasp 连接没有问题

2. lsusb 显示的 设备ID与产商ID 与 avrdude 配置文件中的 usbasp-clone 一
   致

3. error

   #+BEGIN_EXAMPLE
     $ sudo avrdude -c usbasp-clone -p 8052

     avrdude: warning: cannot set sck period. please check for usbasp firmware update.
     avrdude: error: programm enable: target doesn't answer. 1
     avrdude: initialization failed, rc=-1
              Double check connections and try again, or use -F to override
              this check.
   #+END_EXAMPLE

***** usbasp可以给单片机供电

*** Arduino 也可以作为编程器(programmer)                          :arduino:

+ http://openrcforums.com/forum/viewtopic.php?f=10&t=1363#p29615
+
  http://blackstufflabs.com/2013/10/24/aggiornare-firmware-usbasp-con-arduino/?lang=zh

*** [[http://blog.zakkemble.co.uk/avrdudess-a-gui-for-avrdude/][avrdudess]]: a GUI for avrdude :avrdude:avrdudess:

1. 直接运行 exe 文件

2. Linux 下使用 /Mono/

   1) Install Mono

      #+BEGIN_EXAMPLE
      # (this is the minimum required, you can do mono-complete for a full install)
      sudo apt-get install libmono-winforms2.0-cil
      #+END_EXAMPLE

   2) Install AVRDUDE

      #+BEGIN_EXAMPLE
      sudo apt-get install avrdude
      #+END_EXAMPLE

   3) Run AVRDUDESS with Mono

      #+BEGIN_EXAMPLE
      mono avrdudess.exe
      #+END_EXAMPLE

      you might have to run as root (/sudo/) so avrdude runs as root
      if you havn’t changed any rules.d stuff

*** AVR Atmega16

#+BEGIN_EXAMPLE
   $ sudo avrdude -p m16 -c usbasp -e
  [sudo] password for ben:

  avrdude: warning: cannot set sck period. please check for usbasp firmware update.
  avrdude: AVR device initialized and ready to accept instructions

  Reading | ################################################## | 100% 0.01s

  avrdude: Device signature = 0x1e9403
  avrdude: erasing chip
  avrdude: warning: cannot set sck period. please check for usbasp firmware update.

  avrdude: safemode: Fuses OK (H:FF, E:99, L:E1)

  avrdude done.  Thank you.

#+END_EXAMPLE

OK,  warning not errors.

** Cross Tool                                                    :crosstool:
*** reference
*** Introduction

1. 交叉编译

    *交叉编译* 通俗地讲就是在一种平台上编译出能运行在体系结构不同的另
   一种平台上的程序。

    比如在PC平台（X86 CPU）上编译出能运行在以ARM为内核的CPU平台上的程
   序，编译得到的程序在X86 CPU平台上是不能运行的，必须放到ARM CPU平台
   上才能运行，虽然两个平台用的都是Linux系统。

2. 本地编译

   相对与交叉编译，平常做的编译叫 *本地编译* ，也就是在当前平台编译，
   编译得到的程序也是在本地执行。

   用来编译这种跨平台程序的编译器就叫交叉编译器，相对来说，用来做本地
   编译的工具就叫本地编译器。

3. why

   在裁减和定制Linux内核用于嵌入式系统之前，由于一般嵌入式开发系统存储
   大小有限，通常都要在性能优越的PC上建立一个用于目标机的交叉编译工具
   链，用该交叉编译工具链在PC上编译目标机上要运行的程序。

4. 交叉编译工具链

   *交叉编译工具链* 是一个由编译器、连接器和解释器组成的综合开发环境。

   交叉编译工具链主要由binutils、gcc和glibc 3个部分组成。有时出于减小
   libc 库大小的考虑，也可以用别的 c 库来代替 glibc，例如 uClibc、
   dietlibc 和 newlib。

*** 构建ARM Linux交叉编译工具链

http://imkongguxiaoren.blog.51cto.com/488693/101897

建立交叉编译工具链是一个相当复杂的过程，如果不想自己经历复杂繁琐的编译
过程，网上有一些编译好的可用的交叉编译工具链可以下载，但就以学习为目的
来说读者有必要学习自己制作一个交叉编译工具链。

1. 目标平台

   构建交叉编译器的第一个步骤就是确定目标平台。

   在GNU系统中，每个目标平台都有一个明确的格式，这些信息用于在构建过程
   中识别要使用的不同工具的正确版本。因此，当在一个特定目标机下运行GCC
   时，GCC便在目录路径中查找包含该目标规范的应用程序路径。GNU的目标规
   范格式为 *CPU-PLATFORM-OS* 。例如x86/i386 目标机名为
   i686-pc-linux-gnu。本章的目的是讲述建立基于ARM平台的交叉工具链，所
   以目标平台名为arm-linux-gnu。

2. 方法

   通常构建交叉工具链有3种方法。

   1) 分步编译和安装交叉编译工具链所需要的库和源代码，最终生成交叉编译
      工具链。该方法相对比较困难，适合想深入学习构建交叉工具链的读者。
      如果只是想使用交叉工具链，建议使用方法二或方法三构建交叉工具链。

   2) 通过Crosstool脚本工具来实现一次编译生成交叉编译工具链，该方法相
      对于方法一要简单许多，并且出错的机会也非常少，建议大多数情况下使
      用该方法构建交叉编译工具链。

   3) 直接通过网上（ftp.arm.kernel.org.uk）下载已经制作好的交叉编译工
      具链。该方法的优点不用多说，当然是简单省事，但与此同时该方法有一
      定的弊端就是局限性太大，因为毕竟是别人构建好的，也就是固定的没有
      灵活性，所以构建所用的库以及编译器的版本也许并不适合你要编译的程
      序，同时也许会在使用时出现许多莫名的错误，建议读者慎用此方法。

*** 分步构建交叉编译链

1. 下载安装包
   + linux-2.6.10.tar.gz   ftp.kernel.org
   + glibc-2.3.2.tar.gz    ftp.gnu.org
   + binutils-2.15.tar.bz2 ftp.gnu.org
   + glibc-linuxthreads-2.3.2.tar.gz ftp.gnu.org
   + gcc-3.3.6.tar.gz      ftp.gnu.org

2. 建立工作目录

   首先建立工作目录，工作目录就是在什么目录下构建交叉工具链，目录的构
   建一般没有特别的要求，可以根据个人喜好建立。

   再在这个工作目录armlinux下建立3个目录 build-tools、kernel 和 tools。
   #+BEGIN_EXAMPLE
   mkdir build-tools kernel tools
   #+END_EXAMPLE

   其中各目录的作用如下。
   + build-tools 用来存放下载的binutils、gcc、glibc等源代码和用来编译
     这些源代码的目录；
   + kernel 用来存放内核源代码；
   + tools 用来存放编译好的交叉编译工具和库文件。

3. 建立环境变量

   该步骤的目的是为了方便重复输入路径，因为重复操作每件相同的事情总会
   让人觉得很麻烦。声明以下环境变量的目的是在之后编译工具库的时候会用
   到，很方便输入，尤其是可以降低输错路径的风险。

   #+BEGIN_EXAMPLE
     # export PRJROOT=/path/to/armlinux
     # export TARGET=arm-linux
     # export PREFIX=$PRJROOT/tools
     # export TARGET_PREFIX=$PREFIX/$TARGET
     # export PATH=$PREFIX/bin:PATH
   #+END_EXAMPLE

4. 编译、安装Binutils

   Binutils 是GNU工具之一，它包括连接器、汇编器和其他用于目标文件和档
   案的工具，它是二进制代码的处理维护工具。安装Binutils工具包含的程序
   有 addr2line、ar、as、c++filt、gprof、ld、nm、objcopy、objdump、
   ranlib、readelf、size、 strings、strip、libiberty、libbfd和
   libopcodes。对这些程序的简单解释如下。

   + addr2line 把程序地址转换为文件名和行号。在命令行中给它一个地址和
     一个可执行文件名，它就会使用这个可执行文件的调试信息指出在给出的
     地址上是哪个文件以及行号。
   + ar 建立、修改、提取归档文件。归档文件是包含多个文件内容的一个大文
     件，其结构保证了可以恢复原始文件内容。
   + as 主要用来编译GNU C编译器gcc输出的汇编文件，产生的目标文件由连接
     器ld连接。
   + c++filt 连接器使用它来过滤 C++ 和 Java 符号，防止重载函数冲突。
   + gprof 显示程序调用段的各种数据。
   + ld 是连接器，它把一些目标和归档文件结合在一起，重定位数据，并连接
     符号引用。通常，建立一个新编译程序的最后一步就是调用ld。
   + nm 列出目标文件中的符号。
   + objcopy 把一种目标文件中的内容复制到另一种类型的目标文件中。
   + objdump 显示一个或者更多目标文件的信息。使用选项来控制其显示的信
     息，它所显示的信息通常只有编写编译工具的人才感兴趣。
   + ranlib 产生归档文件索引，并将其保存到这个归档文件中。在索引中列出
     了归档文件各成员所定义的可重分配目标文件。
   + readelf 显示elf格式可执行文件的信息。
   + size 列出目标文件每一段的大小以及总体的大小。默认情况下，对于每个
     目标文件或者一个归档文件中的每个模块只产生一行输出。
   + strings 打印某个文件的可打印字符串，这些字符串最少4个字符长，也可
     以使用选项-n设置字符串的最小长度。默认情况下，它只打印目标文件初
     始化和可加载段中的可打印字符；对于其他类型的文件它打印整个文件的
     可打印字符。这个程序对于了解非文本文件的内容很有帮助。
   + strip 丢弃目标文件中的全部或者特定符号。
   + libiberty 包含许多GNU程序都会用到的函数，这些程序有getopt、
     obstack、strerror、strtol和strtoul。
   + libbfd 二进制文件描述库。
   + libopcode 用来处理opcodes的库，在生成一些应用程序的时候也会用到它。

   Binutils工具安装依赖于Bash、Coreutils、Diffutils、GCC、Gettext、
   Glibc、Grep、Make、Perl、Sed、Texinfo等工具。

   配置Binutils工具，建议建立一个新的目录用来存放配置和编译文件，这样
   可以使源文件和编译文件独立开，具体操作如下：

   #+BEGIN_EXAMPLE
   # cd $PRJROOT/build-tools
   # mkdir build-binutils
   # cd build-binutils
   # ../ binutils-2.15/configure --target=$TARGET --prefix=$PREFIX
   #+END_EXAMPLE

   其中选项
   + -–target的意思是制定生成的是 arm-linux 的工具
   + --prefix 是指出可执行文件安装的位置。

   执行make make install
   #+BEGIN_EXAMPLE
   # make
   # make install
   #+END_EXAMPLE

5. 获得内核头文件

   编译器需要通过系统内核的头文件来获得目标平台所支持的系统函数调用所
   需要的信息。对于Linux内核，最好的方法是下载一个合适的内核，然后复制
   获得头文件。需要对内核做一个基本的配置来生成正确的头文件；不过，不
   需要编译内核。
   #+BEGIN_EXAMPLE
     # cd $PRJROOT/kernel
     # tar –xvzf linux-2.6.10.tar.gz
     # cd linux-2.6.10
     # make ARCH=arm CROSS_COMPILE=arm-linux- menuconfig
   #+END_EXAMPLE
   其中
   + ARCH=arm表示是以arm为体系结构，
   + CROSS_COMPILE=arm-linux-表示是以arm-linux-为前缀的交叉编译器。
   + 推荐用make menuconfig，也可以用config和xconfig来代替menuconfig，
     这也是内核开发人员用的最多的配置方法。
   + 注意在配置时一定要选择处理器的类型，这里选择三星的S3C2410（System
     Type->ARM System Type->/Samsung S3C2410）
   + 配置完退出并保存，检查一下内核目录中的include/linux/version.h和
     include/linux/autoconf.h文件是不是生成了，这是编译glibc时要用到的，
     如果version.h 和 autoconf.h 文件存在，说明生成了正确的头文件。

   复制头文件到交叉编译工具链的目录，首先需要在
   /home/mike/armlinux/tools/arm-linux目录下建立工具的头文件目录
   inlcude，然后复制内核头文件到此目录下，具体操作如下：
   #+BEGIN_EXAMPLE
   # mkdir –p $TARGET_PREFIX/include
   # cp –r $PRJROOT/kernel/linux-2.6.10/include/linux $TARGET_PREFIX/include
   # cp –r $PRJROOT/kernel/linux-2.6.10/include/asm-arm $TARGET_PREFIX/include/asm
   #+END_EXAMPLE

6. 编译安装boot-trap gcc

   这一步的目的主要是建立arm-linux-gcc工具，注意这个gcc没有glibc库的支
   持，所以只能用于编译内核、BootLoader等不需要C库支持的程序，后面创建
   C库也要用到这个编译器，所以创建它主要是为创建C库做准备，如果只想编
   译内核和BootLoader，那么安装完这个就可以到此结束。安装命令如下：
   #+BEGIN_EXAMPLE
     # cd $PRJROOT/build-tools
     # tar –xvzf gcc-3.3.6.tar.gz
     # mkdir build-gcc
     # cd gcc-3.3.6
     # vi gcc/config/arm/t-linux
   #+END_EXAMPLE

   由于是第一次安装ARM交叉编译工具，没有支持libc库的头文件，所以在
   gcc/config/arm/t- linux文件中给变量TARGET_LIBGCC2_CFLAGS增加操作参
   数选项-Dinhibit_libc -D__gthr_ posix_h来屏蔽使用头文件，否则一般默
   认会使用/usr/inlcude头文件。

   将TARGET_LIBGCC2-CFLAGS = -fomit-frame-pointer –fPIC改为
   TARGET_LIBGCC2- CFLAGS=-fomit-frame-pointer–fPIC -Dinhibit_libc
   -D__gthr_posix_h

   修改完t-linux文件后保存，紧接着执行配置操作，如下命令：

   #+BEGIN_EXAMPLE
     # cd build-gcc
     # ../gcc-3.6.3/configure --target=$TARGET --prefix=$PREFIX \
       --enable-languages=c --disable-threads --disable-shared
   #+END_EXAMPLE

   其中选项
   + --enable-languages=c表示只支持C语言，
   + --disable-threads表示去掉thread功能，这个功能需要glibc的支持。
   + --disable-shared表示只进行静态库编译，不支持共享库编译。

   接下来执行编译和安装操作，命令如下：
   #+BEGIN_EXAMPLE
     # make
     # make install
   #+END_EXAMPLE

   安装完成后，在/home/mike/armlinux/tools/bin下查看，如果
   arm-linux-gcc等工具已经生成，表示boot-trap gcc工具已经安装成功。

7. 未完待续

*** 用Crosstool工具构建交叉工具链
*** 交叉工具链编译 crosstool-ng                                 :crosstool:
**** reference

+ [[http://crosstool-ng.org/][Homepage]]
+ [[http://crosstool-ng.org/][GitHub]]: github上为dev版，非 released 稳定版
+ http://simeneer.blogspot.jp/2015/05/crosstool-ng_13.html
+ http://simeneer.blogspot.jp/2015/05/crosstool-ng.html
+ *《Raspberry 创意项目制作》*

**** 安装 crosstool-ng                                           :install:

1. 下载： 主页下载稳定版

2. 依赖
   + gcc
   + libstdc: 标准C++库
   + libtool
   + make
   + GNU MP
   + gperf: 哈希函数发生器
   + bison: C语法解析器
   + flex: 词法模式识别引擎
   + ncurses: 终端图形库
   + sed: 流编辑器
   + texinfo: 文档生成和解析工具

3. 安装

   #+BEGIN_EXAMPLE
       $ tar xjvf crosstool-ng-1.22.0.tar.bz2
       ...
       $ cd crosstool-ng/

      crosstool-ng $ ./configure --prefix=/opt/crosstool-ng-1.22.0
      ...
      configure: error: missing required tool: help2man

      crosstool-ng $ apt-cache search help2man
      help2man - Automatic manpage generator

      crosstool-ng $ sudo apt-get install help2man
      ...
      crosstool-ng $ ./configure --prefix=/opt/crosstool-ng-1.22.0
      checking ...
      configure: creating ./config.status
      config.status: creating Makefile

      crosstool-ng $ sudo make install

      For auto-completion, do not forget to install 'ct-ng.comp' into
      your bash completion directory (usually /etc/bash_completion.d)
   #+END_EXAMPLE

4. export PATH

   #+BEGIN_SRC sh
   export PATH=$PATH:/opt/crosstool-ng-1.22.0/bin
   #+END_SRC

   *cl-ng*

**** 配置交叉编译器：ct-ng menuconfig
1. sandbox

   #+BEGIN_EXAMPLE
     $ mkdir cross-sandbox
     $ cd cross-sandbox
     $ ct-ng menuconfig
   #+END_EXAMPLE

2. 路径和其它选项(Paths and Misc Options)

   1) 启用 "Try featured marked as EXPERIMENTAL"

   2) Prefix directory

      #+BEGIN_EXAMPLE
        ${HOME}/x-tools/${CT_TARGET}  # 默认
        ${HOME}/.x-tools/${CT_TARGET} # 修改，不喜欢主目录下文件过多
      #+END_EXAMPLE

   3) Number of parallel jobs: 加速构建时间， CPU个数*1.5 (6)

      #+BEGIN_EXAMPLE
        $ cat /proc/cpuinfo | grep processor
        processor       : 0
        processor       : 1
        processor       : 2
        processor       : 3
      #+END_EXAMPLE

3. 目标选项

   1) Target architecture: arm

   2) Endianness: Little endian

      查阅S3C2440手册，其两种模式均支持。至于差异，暂时不管
      [[/home/wally/Wally/Journal/Figures/scrot/49045DS.png]]

   3) Bitness: 32-bit

   4) Architecture level: armv4t

      The S3C2440A offers outstanding features with its CPU core, a
      16/32-bit *ARM920T* RISC processor designed by Advanced RISC
      Machines, Ltd. The ARM920T implements MMU, AMBA BUS, and Harvard
      cache architecture with separate 16KB instruction and 16KB data
      caches, each with an 8-word line length.

      ARM920t的ARM核： armv4t

   5) Emit assembly for CPU: arm920t

   6) Tune for CPU: arm920t

   7) Use specific FPU: floating 相关？？

   8) Floating point：software(no FPU)

      对于很多ARM架构CPU来说是不支持硬浮点运算的，所以选择软件方式有更好
      的兼容性

      S3c2440 没有 *FPA* (Float Point Architecture)，不能进行硬浮点运算,
      而是使用 FPE(Float Point Emulation), 即软浮点。

   9) default instruction set mode: arm

   10) 启用Use EABI

4. 工具链选项(Toolchain Options)

   + Tuple's vendor string: wally

5. 操作系统选项(Operating system)

   + Target OS: linux

   + Linux kernel version:
     - 2.6.32 (简单起见)
     - *使用最新 4.3*

6. 二进制实用工具选项(Binary Utilities Options)

   + Binary format: elf
   + binutils versio: 2.25(最新)

7. C 编译器选项(C Compile Options)

   + C compiler (gcc)

   + 启用 Show linaro versions

   + gcc version：linaro-4.9

   + 启用C++

   + gcc extra config --with-float=hard (NO)

8. C 库选项(C Library Options)

   + C library: glibc
   + glibc version: 2.22（最新的好不好，不知道）

9. gdb 选项

**** 构建 *ct-ng build*

等待下载

然后等待编译, 编译过程十分耗内存。

***** error:Don't set LD_LIBRARY_PATH                             :error:

#+BEGIN_EXAMPLE
[ERROR]  Don't set LD_LIBRARY_PATH. It screws up the build.
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  $ echo $LD_LIBRARY_PATH
  /home/wally/catkin_ws/devel/lib/x86_64-linux-gnu:/home/wally/Wally/Project/catkin_ws/devel/lib/x86_64-linux-gnu:~/catkin_ws/devel/lib/x86_64-linux-gnu:~/Wally/Project/catkin_ws/devel/lib/x86_64-linux-gnu:/opt/ros/jade/lib/x86_64-linux-gnu:/home/wally/catkin_ws/devel/lib:/home/wally/Wally/Project/catkin_ws/devel/lib:~/catkin_ws/devel/lib:~/Wally/Project/catkin_ws/devel/lib:/opt/ros/jade/lib
#+END_EXAMPLE

ROS 配置文件引入了环境变量 LD_LIBRARY_PATH 的原因.

***** error: python is missing or unusable

#+BEGIN_EXAMPLE
  [INFO ]  Installing cross-gdb
  [ERROR]    configure: error: python is missing or unusable
  [ERROR]    make[2]: *** [configure-gdb] Error 1
  [ERROR]    make[1]: *** [all] Error 2
#+END_EXAMPLE

Python 版本问题，ct-ng 使用 python 2.7

/usr/bin/python 链接改为指向 /usr/bin/python2.7

**** export PATH

#+BEGIN_EXAMPLE
   ~ $ ls .x-tools/arm-wally-linux-gnueabi/bin/
  arm-wally-linux-gnueabi-addr2line     arm-wally-linux-gnueabi-gdb
  arm-wally-linux-gnueabi-ar            arm-wally-linux-gnueabi-gprof
  arm-wally-linux-gnueabi-as            arm-wally-linux-gnueabi-ld
  arm-wally-linux-gnueabi-cc            arm-wally-linux-gnueabi-ld.bfd
  arm-wally-linux-gnueabi-c++filt       arm-wally-linux-gnueabi-ldd
  arm-wally-linux-gnueabi-cpp           arm-wally-linux-gnueabi-nm
  arm-wally-linux-gnueabi-ct-ng.config  arm-wally-linux-gnueabi-objcopy
  arm-wally-linux-gnueabi-elfedit       arm-wally-linux-gnueabi-objdump
  arm-wally-linux-gnueabi-gcc           arm-wally-linux-gnueabi-populate
  arm-wally-linux-gnueabi-gcc-4.9.4     arm-wally-linux-gnueabi-ranlib
  arm-wally-linux-gnueabi-gcc-ar        arm-wally-linux-gnueabi-readelf
  arm-wally-linux-gnueabi-gcc-nm        arm-wally-linux-gnueabi-size
  arm-wally-linux-gnueabi-gcc-ranlib    arm-wally-linux-gnueabi-strings
  arm-wally-linux-gnueabi-gcov          arm-wally-linux-gnueabi-strip

#+END_EXAMPLE


#+BEGIN_EXAMPLE
export PATH=$PATH:~/.x-tools/arm-wally-linux-gnueabi/bin
#+END_EXAMPLE

**** 为什么没有 gdb??

配置时没有勾选。
** OpenOCD: Open On-Chip Debugger*                                 :openocd:
*** references

+ [[http://openocd.org/][Homepage]]
+ [[http://sourceforge.net/projects/openocd/][SourceForge]]
+ [[~/Wally/Reference/Guide/OpenocdManual.pdf][OpenocdManual.pdf]]

*** [[http://blog.163.com/brave_smile_heart/blog/static/1872381712012619113640957/][openocd 命令行烧写ARM裸机程序 problems and solutions  ]]           :blog:


以前是用RVDS 的IDE来烧写调试ARM程序的，不过RVDS虽然是集成化的调试工具
调试起来方便，但是有的时候只知其一，不知其二，只知道按部就班的来点击按
钮，忽略了一些本质性的东西。而且RVDS还有一个不好的地方是它只能在
windows平台下运行，不支持Linux OS。为了便于学习Linux，使用Openocd会是
个不错的选择，可以学习gnu 汇编，Makefile编写，工具链命令行使用。   如
果这些命令搞熟悉了，你还可以利用Qt 来做个自己的图形化界面烧写调试工具。
（不过这只是个壳子而已，精髓在于openocd ，所以如果有时间你还可以分析一
下Openocd的源码，因为它是开源的，开源的东西就是好，它可以满足你的好奇
心，虽然有些时候不是我们在玩代码而是代码在玩我们，(*^__^*) ）。好了，
废话不多说了。现列出我碰到的一些问题以及其解决办法，与诸位共享。


前提是你安装好了openocd .  并且Openocd的配置文件也准备好。运行起。


首先我修改了samsung_s3c6410.cfg文件
在samsung_s3c6410.cfg中添加了如下语句

set _NANDNAME $_CHIPNAME.nand
nand device $_NANDNAME s3c6410 $_TARGETNAME
#openocd -f jlink.cfg -f samsung_s3c6410.cfg

运行如下：　

openocd 命令行烧写ARM裸机程序   problems and solutions - Melchior - Melchiors Home
以为ｏｐｅｎｏｃｄ不支持ｓ３ｃ６４１０的ｎａｎｄ擦写功能。于是看了
/board/mini6410.cfg中有段内容如下：　


targets

nand device $_CHIPNAME.flash s3c6400 $_CHIPNAME.cpu

明明是６４１０，为什么要写成6400呢 ，不管了 ，于是试着修改samsung_s3c6410.cfg文件为
set _NANDNAME $_CHIPNAME.nand
nand device $_NANDNAME s3c6400 $_TARGETNAME

结果就ok 了  。

上面一步就完成jlink识别ARM的工作了。而且建立了telnet 服务器端口号 。现在我们要通过telnet与之建立通信 ，好能来使用openocd

#telnet localhost 4444(telnet端口号设置为4444)
openocd 命令行烧写ARM裸机程序   problems and solutions - Melchior - Melchiors Home
> halt
target state: halted
target halted in ARM state due to debug-request, current mode: Supervisor
cpsr: 0x000001d3 pc: 0x00000030
> nand probe 0
NAND flash device 'K9GAG08 2GB NAND 3.3V x8 MLC 2b/cell (Samsung)' found
> nand erase 0 0 0x100000（注：这个值应该是板子nand flash块的整数倍，0x100000为1M空间，足矣）

s3c2440_read_block_data: reading data: 0x8b94260, 0xbfe53d7a, 6
erased blocks 0 to 1 on NAND flash device #0 'K9GAG08 2GB NAND 3.3V x8 MLC 2b/cell'
> nand write 0 led.bin 0
couldn't open led.bin
failed to open 'led.bin' for read access
in procedure 'nand'

solution: 无法读取led.bin，那我们就改为绝对路径来试试  ：　
> nand write 0 /home/melchior/arm-work/1th_led/led.bin 0
> reset
JTAG tap: s3c6410.etb tap/device found: 0x2b900f0f (mfg: 0x787, part: 0xb900, ver: 0x2)
JTAG tap: s3c6410.cpu tap/device found: 0x07b76f0f (mfg: 0x787, part: 0x7b76, ver: 0x0)
found ARM1176

这样就ｏｋ了，ＡＲＭ板子上的ｌｅｄ就亮起来了　。　　

*** intro
**** 为什么使用openocd

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/92b1d2c3-dc84-4924-b267-4ba4df453027?title=openocd%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%83%A7%E5%86%99ARM%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%20problems%20and%20solutions%20-%20Melchior%E7%9A%84%E6%97%A5%E5%BF%97%20-%20%E7%BD%91%E6%98%93%E5%8D%9A%E5%AE%A2][En::OpenOCD烧写ARM裸机程序]]

以前是用 rvds 的ide来烧写调试arm程序的，不过rvds虽然是集成化的
调试工具调试起来方便，但是有的时候只知其一，不知其二，只知道按部就班的
来点击按钮，忽略了一些本质性的东西。而且rvds还有一个不好的地方是它只能
在windows平台下运行，不支持linux os。为了便于学习linux，使用openocd会
是个不错的选择，可以学习gnu 汇编，makefile编写，工具链命令行使用。
如果这些命令搞熟悉了，你还可以利用qt 来做个自己的图形化界面烧写调试工
具。不过这只是个壳子而已，精髓在于openocd ，所以如果有时间你还可以分
析一下openocd的源码，因为它是开源的，开源的东西就是好，它可以满足你的
好奇心，虽然有些时候不是我们在玩代码而是代码在玩我们.

**** installation                                                :install:

1. version

   - apt-get(软件管理中心/新得立): 0.8
   - beta(release): 0.9, bug 修复 + 体验更多特性

2. 源码安装： http://sourceforge.net/projects/openocd/

   #+BEGIN_EXAMPLE
   ./configure & make & make install
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
      $ locate openocd
     ~/.openocd
     ~/.openocd_history
     wally@ openocd-0.9.0 $ which openocd
     /usr/local/bin/openocd
   #+END_EXAMPLE
*** guide                                                           :guide:
**** help
#+BEGIN_EXAMPLE
$ openocd --help
open on-chip debugger 0.9.0 (2015-06-11-20:27)
licensed under gnu gpl v2
for bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
open on-chip debugger
licensed under gnu gpl v2
--help       | -h       display this help
--version    | -v       display openocd version
--file       | -f       use configuration file <name>
--search     | -s       dir to search for config files and scripts
--debug      | -d       set debug level <0-3>
--log_output | -l       redirect log output to file <name>
--command    | -c       run <command>
#+END_EXAMPLE

#+begin_example
#+end_example

默认文件 *openocd.cfg*

#+begin_example
openocd -f config1.cfg -f config2.cfg
#+end_example

搜索顺序
1. the *current* directory
2. *-s* specified
3. *add_script_search_dir* added
4. $home/.openocd
5. $pkgdatadir/site  file:/usr/share/openocd/scripts/
6. $pkgdatadir/scripts

note: *reusing script libraries*

**** hooking up the jtag adapter

1. start with power to your target board *turned off*,  and *nothing
   connected to your jtag adapter*
2. connecting the adapter to the board
3. connecting the adapter to the pc
4. connecting the adapter's power supply if neccessary
5. power on the target board

**** user config files

1. configure files

   */usr/share/openocd/scripts/*

   + interface: for debug adapter
   + board: for board
   + target: the chips which integrate cpus and other jtag taps

     #+BEGIN_EXAMPLE
       source [find interface/jlink.cfg]
       source [find board/stm32.cfg]
     #+END_EXAMPLE

   */usr/share/openocd/scripts 目录下有对应接口(interface下)和芯片
   (target下)的配置文件，尽量复用这些文件*

2. openocd寻找配置文件的顺序

   1) 当前目录
   2) -s选项指定的目录
   3) add_script_search_dir指定的目录
   4) $home/.openocd
   5) openocd脚本目录：$packagedir/scripts(/usr/share/openocd/scripts)

**** running openocd

#+BEGIN_EXAMPLE
openocd -f test.cfg
#+END_EXAMPLE

***** error: unknown param: -variant                              :error:
point: samsung_s3c2440.cfg
方法： 删除

***** error：insert a call to adpter_khz or jtag_rclk to process  :error:

#+BEGIN_EXAMPLE
an adapter speed is not selected in the init script. insert a call to adpter_khz or jtag_rclk to process
#+END_EXAMPLE
point: jlink.cfg
方法：按提示来，增加 adapter_khz 6000


normally, openocd starts running as a daemon(无交互后台程序).once
openocd starts running as a deamon, it waits for connections from
clients(*telnet*, *gdb*, others) and processes the commands issued
through those channels.

**** connecting

在建立了jlink识别arm，而且建立了telnet服务器端口号之后，通过talnet与
target建立连接

#+begin_src sh
telnet localhost 4444(telnet的端口号设置为4444)
#+end_src

*** usage

1. openocd -f tq2440.cfg
2. telnet localhost 4444
3. halt
4. nand probe 0
5. nand erase 0 0 0x100000
6. write

*** 常用命令

**** 目标板状态处理命令(target state handling)

+ poll 查询目标板的当前状态
+ halt 中断目标板的运行
+ resume [address] 恢复目标板的运行，指定地址则从地址处
+ step [address] 单步

**** 断点命令

+ bp <addr> <lenght> [hw] 在地址addr处设置断点，指令长度为length，hw表
  示硬件断点
+ rbp <addr>  删除地址处的断点

**** 内在访问指令

+ mdw <addr> [count] 显示从地址addr开始的count（缺省1）个字（4字节）
+ mdh <addr> [count] 显示从地址addr开始的count个半字（2字节）
+ mdb <addr> [count] 显示从地址addr开始的count个字节

+ mww <addr> <value> 向地址addr写入一个字，值为value
+ mwh <addr> <value> 向地址addr写入一个半字，值为value
+ mwb <addr> <value> 向地址addr写入一个字节，值为value

+ load_image <file> <address> ['bin'|'ihex'|'elf']
  将文件file载入地址为addr的内在，格式有bin, ihex, elf

+ dump_image <file> <address> <size>
  将内存从地址address开始的size字节数据读出，保存到文件file中

+ verify_image <file> <address> ['bin'|'ihex'|'elf']
  将文件file与内存地址address开始的数据进行比较

**** nand

nand: nand flash command group (command valid any time)

+ *nand check_bad_blocks bank_id [offset length]*

   check all or part of nand flash device for bad blocks

+ *nand device bank_id driver target [driver_options ...]*

  defines a new nand bank (configuration command)

+ *nand drivers*

  lists available nand drivers (command valid any time)

+ *nand dump bank_id filename offset length ['oob_raw'|'oob_only']*

  dump from nand flash device

+ *nand erase bank_id [offset length]*

  erase all or subset of blocks on nand flash device

+ *nand info [banknum | first_bank_num last_bank_num]*

  print info about one or more nand flash devices

+ *nand init*

  initialize nand devices (configuration command)

+ *nand list*

  list configured nand flash devices

+ *nand probe bank_id*

  identify nand flash device

+ *nand raw_access bank_id ['enable'|'disable']*

  raw access to nand flash device

+ *nand verify bank_id filename offset ['oob_raw'|'oob_only'|'oob_softecc'|'oob_softecc_kw']*

  verify nand flash device

+ *nand write bank_id filename offset* ['oob_raw'|'oob_only'|'oob_softecc'|'oob_softecc_kw']

  write to nand flash device

**** cpu架构相关命令

+ armv4 reg 打印寄存器的值
+ arm7_9 sw_bkpts <enable|disable> 使能或禁止软件断点
+ arm920t cp15 <num> [value] 显示/修改cp15协处理器的寄存器
+ arm920t md<bhw>_phys <addr> [count] 显示物理地址addr处的内存
+ arm920t mw<bhw>_phys <addr> <value> 修改物理地址addr处的内存
+ arm920t virt2phys <va> 获取虚拟地址va对应的物理地址

**** 其它命令

script <file> 执行file文件中的命令

*** test                                                             :test:
**** 使用openocd连接jlink并烧录程序

1. jlink 端未连接开发板时, 不行，需要连接

   #+begin_example
     $ openocd -f interface/jlink.cfg
     open on-chip debugger 0.9.0 (2015-06-11-20:27)
     licensed under gnu gpl v2
     for bug reports, read
             http://openocd.org/doc/doxygen/bugs.html
     info : j-link arm v8 compiled jan 31 2018 18:34:52
     info : j-link caps 0xb9ff7bbf
     info : j-link hw version 80000
     info : j-link hw type j-link
     info : j-link max mem block 8368
     info : j-link configuration
     info : usb-address: 0x0
     info : kickstart power on jtag-pin 19: 0x0
     info : vref = 0.0 tck = 0 tdi = 0 tdo = 0 tms = 0 srst = 1 trst = 0
     error: vref too low. check target power
     info : j-link jtag interface ready
     error: jlink_tap_execute failed, result 5 (unknown)
     error: an adapter speed is not selected in the init script. insert a call to adapter_khz or jtag_rclk to proceed.
   #+end_example

   vref too low

2. jlink 端连接开发板后
   #+begin_example
     $ openocd -f interface/jlink.cfg
     open on-chip debugger 0.9.0 (2015-06-11-20:27)
     licensed under gnu gpl v2
     for bug reports, read
             http://openocd.org/doc/doxygen/bugs.html
     info : j-link arm v8 compiled jan 31 2018 18:34:52
     info : j-link caps 0xb9ff7bbf
     info : j-link hw version 80000
     info : j-link hw type j-link
     info : j-link max mem block 8368
     info : j-link configuration
     info : usb-address: 0x0
     info : kickstart power on jtag-pin 19: 0x0
     info : vref = 3.287 tck = 1 tdi = 0 tdo = 1 tms = 0 srst = 1 trst = 1
     info : j-link jtag interface ready
     error: jlink_tap_execute failed, result 1 (adaptive clocking timeout)
     error: an adapter speed is not selected in the init script. insert a call to adapter_khz or jtag_rclk to proceed.
   #+end_example

3. 根据提示配置 adapter_khz

   在命令行中使用 "-c adapter_khz 3000" 运行有错误

   在配置文件中配置之后， 运行暂时没有问题

   #+begin_example
   source [find interface/jlink.cfg]
   adapter_khz 3000
   transport select jtag
   #+end_example

   #+begin_example
     openocd $ openocd -f demo.config
     open on-chip debugger 0.9.0 (2015-06-11-20:27)
     licensed under gnu gpl v2
     for bug reports, read
             http://openocd.org/doc/doxygen/bugs.html
     adapter speed: 3000 khz
     jtag
     info : j-link arm v8 compiled jan 31 2018 18:34:52
     info : j-link caps 0xb9ff7bbf
     info : j-link hw version 80000
     info : j-link hw type j-link
     info : j-link max mem block 8368
     info : j-link configuration
     info : usb-address: 0x0
     info : kickstart power on jtag-pin 19: 0x0
     info : vref = 3.287 tck = 1 tdi = 0 tdo = 1 tms = 0 srst = 1 trst = 1
     info : j-link jtag interface ready
     info : clock speed 3000 khz
     warn : there are no enabled taps.  auto probing might not work!!
     info : jtag tap: auto0.tap tap/device found: 0x0032409d (mfg: 0x04e, part: 0x0324, ver: 0x0)
     warn : auto auto0.tap - use "jtag newtap auto0 tap -irlen 4 -expected-id 0x0032409d"
     warn : gdb services need one or more targets defined
   #+end_example

4. 开发板(tq2440)配置，使用 mini2440.cfg

   error:
   #+begin_example
   in procedure 'jtag' called at file "mini2440.cfg", line 124
   #+end_example

   注释掉

   #+begin_example
        adapter speed: 3000 khz
     jtag
     adapter_nsrst_delay: 100
     jtag_ntrst_delay: 100
     trst_and_srst separate srst_gates_jtag trst_push_pull srst_open_drain connect_deassert_srst
     force hard breakpoints
         targetname         type       endian tapname            state
     --  ------------------ ---------- ------ ------------------ ------------
      0* s3c2440.cpu        arm920t    little s3c2440.cpu        unknown
     error: no valid nand flash driver found (0)
     available nand flash controller drivers:
       nonce
       davinci
       lpc3180
       lpc32xx
       orion
       s3c2410
       s3c2412
       s3c2440
       s3c2443
       s3c6400
       mxc
       imx31
       at91sam9
       nuc910
     adapter_nsrst_delay: 100
     jtag_ntrst_delay: 100
     trst_and_srst separate srst_gates_jtag trst_push_pull srst_open_drain connect_deassert_srst
     info : j-link arm v8 compiled jan 31 2018 18:34:52
     info : j-link caps 0xb9ff7bbf
     info : j-link hw version 80000
     info : j-link hw type j-link
     info : j-link max mem block 8368
     info : j-link configuration
     info : usb-address: 0x0
     info : kickstart power on jtag-pin 19: 0x0
     info : vref = 3.287 tck = 1 tdi = 0 tdo = 1 tms = 0 srst = 1 trst = 1
     info : j-link jtag interface ready
     info : clock speed 3000 khz
     info : jtag tap: s3c2440.cpu tap/device found: 0x0032409d (mfg: 0x04e, part: 0x0324, ver: 0x0)
     info : embedded ice version 2
     info : s3c2440.cpu: hardware has 2 breakpoint/watchpoint units

     -------------------------------------------
     --- login with - telnet localhost 4444  ---
     --- then type help_2440                 ---
     -------------------------------------------

     help_2440
   #+end_example

   注意： *error: no valid nand flash driver found (0)*
   *先不管*

5. no valid nand flash driver found(0)


   #+begin_example
         # nand device s3c2440 0
         nand device 0 s3c2440 s3c2440.cpu
   #+end_example

   你的openocd 的版本是最新的0.5版吧，此版的 nand 命令跟以前的不一样了。

   nand device bank_id driver target [driver_options ...]

   我的 target 是 s3c2440.cpu 我改为以下的就好了：
   nand device 0 s3c2440 s3c2440.cpu

   [[http://www.100ask.org/bbs/forum.php?mod=viewthread&tid=2629][reference]]

6. seems ok

   #+begin_example
     adapter speed: 3000 khz
     jtag
     adapter_nsrst_delay: 100
     jtag_ntrst_delay: 100
     trst_and_srst separate srst_gates_jtag trst_push_pull srst_open_drain connect_deassert_srst
     force hard breakpoints
         targetname         type       endian tapname            state
     --  ------------------ ---------- ------ ------------------ ------------
      0* s3c2440.cpu        arm920t    little s3c2440.cpu        unknown
     adapter_nsrst_delay: 100
     jtag_ntrst_delay: 100
     trst_and_srst separate srst_gates_jtag trst_push_pull srst_open_drain connect_deassert_srst
     info : j-link arm v8 compiled jan 31 2018 18:34:52
     info : j-link caps 0xb9ff7bbf
     info : j-link hw version 80000
     info : j-link hw type j-link
     info : j-link max mem block 8368
     info : j-link configuration
     info : usb-address: 0x0
     info : kickstart power on jtag-pin 19: 0x0
     info : vref = 3.287 tck = 1 tdi = 0 tdo = 1 tms = 0 srst = 1 trst = 1
     info : j-link jtag interface ready
     info : clock speed 3000 khz
     info : jtag tap: s3c2440.cpu tap/device found: 0x0032409d (mfg: 0x04e, part: 0x0324, ver: 0x0)
     info : embedded ice version 2
     info : s3c2440.cpu: hardware has 2 breakpoint/watchpoint units

     -------------------------------------------
     --- login with - telnet localhost 4444  ---
     --- then type help_2440                 ---
     -------------------------------------------

     help_2440
   #+end_example

7. telnet

   #+begin_example
     telnet localhost 4444
     trying 127.0.0.1...
     connected to localhost.
     escape character is '^]'.
     open on-chip debugger
   #+end_example

**** 测试

***** halt
halt first

#+begin_example
     nand probe 0
     target not halted
     target not halted
     target must be halted to use s3c24xx nand flash controller
#+end_example

halt
#+begin_example
     > halt
     target state: halted
     target halted in arm state due to debug-request, current mode: supervisor
     cpsr: 0x80000053 pc: 0x33d15980
     mmu: enabled, d-cache: enabled, i-cache: enabled
#+end_example

***** nand probe

probe 探索

#+begin_example
     > nand probe 0
     nand flash device 'nand 256mib 3.3v 8-bit (unknown)' found
#+end_example

***** erase

erase
#+begin_example
     > nand erase 0 0 0x100000  # 应该是板子nand flash块的整数倍
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     s3c2440_read_block_data: reading data: 0x8f146d0, 0xbfe2d366, 6
     erased blocks 0 to 7 on nand flash device #0 'nand 256mib 3.3v 8-bit'
#+end_example

#+BEGIN_EXAMPLE
didn't erase bad block 569; status: 0xe1
erased blocks 0 to 2047 on NAND flash device #0 'NAND 256MiB 3.3V 8-bit'
#+END_EXAMPLE

***** write

绝对路径

#+begin_example
  > nand write  0 ~/wally/journal/project/arm/arm/tq2440/led/led.bin 0
  wrote file ~/wally/journal/project/arm/arm/tq2440/led/led.bin to nand flash 0 up to offset 0x00000800 in 2.092001s (0.099 kib/s)
#+end_example

***** poll

poll 轮询
#+begin_example
  > poll
  background polling: on
  tap: s3c2440.cpu (enabled)
  target state: halted
  target halted in arm state due to debug-request, current mode: supervisor
  cpsr: 0x80000053 pc: 0x33d15980
  mmu: enabled, d-cache: enabled, i-cache: enabled
#+end_example

*** 调试                                                            :debug:

**** 直接使用openocd命令进行调试（如上）

1. telnet localhost 4444
2. openocd命令

**** 使用gdb调试                                                     :gdb:

1. arm-linux-gdb
2. target remote localhost:4444

#+BEGIN_EXAMPLE
~ $ arm-linux-gdb
GNU gdb (Sourcery G++ Lite 2008q3-72) 6.8.50.20080821-cvs
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "--host=i686-pc-linux-gnu --target=arm-none-linux-gnueabi".
For bug reporting instructions, please see:
<https://support.codesourcery.com/GNUToolchain/>.
(gdb) target remote localhost:4444
Remote debugging using localhost:4444
warning: unrecognized item "qSupported" in "qSupported" response
warning: Invalid remote reply: ?
#+END_EXAMPLE

*qSupported* 问题应该是 gdb 版本过低所致。

先不管它。(解决了)

*** TODO Eclisp integrate

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/262d6e1c-b8db-4335-9510-70a1f93b43b5?title=Openocd%20%E5%AE%89%E8%A3%85%E5%B9%B6%E5%9C%A8Eclipse%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%80%9A%E8%BF%87J-Link%E8%B0%83%E8%AF%95][在Eclipse环境下通过J-Link调试程序]]

** sdcc                                                            :sdcc:51:
*** reference

+ [[http://en.wikipedia.org/wiki/small_device_c_compiler][Wiki_En]]
+ [[http://sdcc.sourceforge.net/][SourceForge]]

*** intro
      .....
the _Small........C Compiler_ (/sdcc/) is a free-software, partially
retargetable c com.iler for microcontrollers. it is distributed
under the gnu general public license. the package also contains a
/linker/, /assembler/, /simulator/ and /debugger/.

*** 编译源文件

1. 命令: *$ sdcc sourcefile.c*

2. 输出
   ourcefile.asm - 程序的汇编文件
   sourcefile.lst - 程序的列表文件
   sourcefile.rst - 被链接器更新的列表文件
   sourcefile.sym - 由链接器生成的符号清单
   sourcefile.rel - 由汇编器生成的对象文件，提供给链接器使用
   sourcefile.map - 被链接器更新的最终存储器映射
   sourcefile.mem - 内存的使用情况摘要
   sourcefile.ihx - 用于生成intel hex格式文件模块

3. ihx

   + = intel hex
   + 转换为hex文件: *$ packihx file.ihx -> file.hex*

*** sbit

SDCC兼容 ANIS C 和 ISO C,  /sbit/ 作为一种标准数据类型使用, 而不是像keil那样
在main()的外围定义io(寄存器地址).

相应的, sdcc采用扩展的非anis标准的类型定义寄存器地址, *__sbit*, 以双下
划线作为前缀.

对于一些非ansi c的关键字,sdcc均采用双下滑线开头的方式定
义,如__code,__idata,__sbit......对于单片机引脚的定义sdcc采用了 __at关
键字和十六进制地址.
1. sdcc

   #+begin_example
     __sbit __at 0x80 led0;
     __sbit __at 0x81 led1;
     __sbit __at 0x82 led2;
     __sbit __at 0x83 led3;
   #+end_example

2. keil

   #+begin_example
     sbit p1_0 = p1^1;
   #+end_example

3. 区别

   + SDCC 中的 sbit 和 ^ 都符合 ANIS 标准
   + SDCC 的 __sbit等 在 main() 内使用

*** Note

+ 51输出端口默认输出1

+ 没有while循环也会循环, 可能是编译优化的原因.

** EDA                                                                 :eda:
** Altium Designer                                      :altiumdesigner:eda:

# 又犯病了，这种学习方式要干嘛，一点也没有效率，纯粹浪费时间

*** intro

*Altium Designer*: /PCB/ 设计 & /FPGA/ 开发环境

1988,  ACCEL公司， TANGO软件， EDA先河。
Protel for DOS -> Protel 98 -> Protel 99 -> /Protel 99SE/
-> Protel DXP(2001) -> Protel DXP2004 -> Altium Designer 6.0(2006，初
版)

q最好的教程： /软件手册/

Matlab, CCS等 help 文档十分清晰。

*** install                                                  :installation:
**** [[http://www.cnblogs.com/emouse/p/3483774.html][Altium Designer 13 安装完整元件库]]                              :blog:

Altium Designer更新的非常快，都快赶上chrome了，13出来没多久14又出来了，
之前一直用AD9.4，算是10之前的最后一个版本，也是很经典的一个版本。安装
新版本后看到在目录结构上有些编号，元件库和示例文件从原来的安装根目录调
整到 =C:\Users\Public\Documents\Altium\AD13= 文件夹中，而且元件库也默
认只安装了一部分，包含常用的库和FPGA库，如下图所示。

更多的库可以在线下载（需要自己申请账号）
http://designcontent.live.altium.com/#UnifiedComponents 也可以通过之前
老版本的安装包再安装。

通过之前的老版本安装的方式也很简单，在老的安装包中元件库是单独存在的，
在安装的时候会跟着一起安装，因此可以使用之前的安装包安装。

我用的是AD9.4的安装包，安装路径如下
=I:\AltiumDesignerSummer9Build9.4.0.20159\Setup\Board Level Libraries=
点击Setup.exe即可安装，注意安装的目录，安装完成后即可得到老版本中完整
的元件库。

*** application

1. Foundation

   [[~/Wally/Journal/Figures/scrot/20587mNw.png]]

2. Board Implementation

   [[~/Wally/Journal/Figures/scrot/20587zX2.png]]

3. Embedded Intelligence Implementation

   [[~/Wally/Journal/Figures/scrot/20587yrL.png]]

*** shortcuts

右下角标签页，动态显示

[[~/Wally/Journal/Figures/scrot/20587ZKe.png]]

*** PCB 设计
**** 设计流程

[[~/Wally/Journal/Figures/scrot/20587mUk.png]]

1) EDA设计PCB
2) 加工制作

**** EDA设计流程

[[~/Wally/Journal/Figures/scrot/20587Nz2.png]]

1. 原理图(/SCH/)设计/仿真
   1) 图纸设置
   2) 环境设置
   3) 元件库装载
   4) 放置元件并布局
   5) 原理图布线
   6) 电气检查
   7) NET
   8) 文件存储

2. 网络报表(/NET/)生成， AD可以省略

3. 印制版(/PCB/)设计
   1) 设置环境
   2) 设置PCB设计规则
   3) 放置元件并布局
   4) 布线
   5) 规则检查
   6) 报表生成
   7) 文件存储

高频板/多层板，需要进行SCH仿真，进行信号
低速板(<50M)

**** PCB基本概念

[[~/Wally/Journal/Figures/scrot/20587Awk.png]]

1. 基本材料：FR-4 环氧树脂 FR-5耐热

2. 1u = 0.25mm

3. 层(Layer)
   1) 信号层(一般为35um)
   2) 基层（一般为1.5mm, ）

4. 过孔(Via)

5. 丝印层(Overlay): 板上标识

6. 焊盘： 元器件焊接

7. 飞线

**** 线宽与电流关系

单位 u

弱电电流一般不会达到1A，10u的余度往往足够。

[[~/Wally/Journal/Figures/scrot/20587MOA.png]]

**** 设计准则

1. /抗干扰/

   1) 电源线的设计

      [[~/Wally/Journal/Figures/scrot/20587aLl.png]]

   2) 地线

      [[~/Wally/Journal/Figures/scrot/205870fx.png]]

   3) 元器件配置

      [[~/Wally/Journal/Figures/scrot/20587A-M.png]]

   4) 去耦电容

      [[~/Wally/Journal/Figures/scrot/20587ncf.png]]

   5) 降低噪声

      [[~/Wally/Journal/Figures/scrot/20587O7x.png]]

   6) 其它设计原则

      [[~/Wally/Journal/Figures/scrot/20587aZN.png]]

2. 热设计原则

3. 抗振

4. 可测试

***
*** [[http://blog.chinaunix.net/uid-25148547-id-138696.html][Protel中Cap,Cap2，Cap Pol的区别]]                              :blog:cap:

# 序号	英文简写	元件英文名	元件中文名

|----+--------------+---------------------------------------+----------------------------------------------------|
|  1 | Res semi     | Semiconductor Resistor                | 半导体电阻                                         |
|  2 | Cap semi     | Semiconductor Capacitor               | 半导体电容器                                       |
|  3 | Cap Var      | Variable or                           | Adjustable Capacitor       可变或可调电容          |
|  4 | Cap Pol1     | Polarized Capacitor                   | (Radial)   极化电容（径向）                        |
|  5 | Cap Pol2     | Polarized Capacitor                   | (Axial)    极化电容（轴向）                        |
|  6 | Cap          | Capacitor                             | 电容（径向）                                       |
|  7 | Cap Pol3     | Polarized Capacitor                   | (Surface Mount)    极化电容（表面贴装）            |
|  8 | Cap Feed     | Feed-Through                          | Capacitor 馈通电容                                 |
|  9 | Cap2         | Capacitor                             | 电容                                               |
| 10 | Res Varistor | Varistor (Voltage-Sensitive Resistor) | 压敏电阻（电压敏感电阻）                           |
| 11 | Res Tap      | Tapped Resistor                       | 抽头电阻                                           |
| 12 | Res Thermal  | Thermal Resistor                      | 热敏电阻                                           |
| 13 | Rpot         | Potentiometer Resistor                | （侧调或顶调）电位器                               |
| 14 | Rpot SM      | Square Trimming                       | Potentiometer （顶调）方形电位器                   |
| 15 | Res Bridge   | Resistor Bridge                       | 电阻桥                                             |
| 16 | Bridge1      | Full Wave Diode Bridge                | 整流桥                                             |
| 17 | Bridge2      | Bridge Rectifier                      | 整流桥集成组件（比1封装较大）                      |
| 18 | Res Adj      | Variable Resistor                     | 可变电阻                                           |
| 19 | Res3         | Resistor                              | IPC的高密度贴片电阻                                |
| 20 | D Tunnel2    | Tunnel Diode                          | - Dependent Source Model  隧道二极管 - 依赖源模型  |
| 21 | D Varactor   | Variable Capacitance Diode            | 变容二极管                                         |
| 22 | D Schottky   | Schottky Diode                        | 肖特基二极管                                       |
| 23 | Diode 1N5402 | 3 Amp                                 | General Purpose Rectifier        3放大器通用整流器 |
|----+--------------+---------------------------------------+----------------------------------------------------|

其中，cap，cap2，cap pol1和cap pol2分别如下图所示

#+DOWNLOADED: http://blog.chinaunix.net/attachment/201102/25/25148547_1298643961S8lR.jpg @ 2016-01-23 00:11:22
 [[~/Wally/Journal/Figure/.org-download/Journal/25148547_1298643961S8lR_2016-01-23_00:11:22.jpg]]

其中，径向型电容如下图所示：


#+DOWNLOADED: http://blog.chinaunix.net/attachment/201102/25/25148547_1298604806OTrm.jpg @ 2016-01-23 00:11:45
 [[~/Wally/Journal/Figure/.org-download/Journal/25148547_1298604806OTrm_2016-01-23_00:11:45.jpg]]

轴向型电容如下所示：

#+DOWNLOADED: http://blog.chinaunix.net/attachment/201102/25/25148547_1298604874zIM5.jpg @ 2016-01-23 00:12:05
 [[~/Wally/Journal/Figure/.org-download/Journal/25148547_1298604874zIM5_2016-01-23_00:12:05.jpg]]

有极性电阻为电解电容，无极性电阻为普通电容，电解电容的容量一般比普通电
容的大，在滤波时电解电容用于滤低频，普通电容用于滤高频。

*** [[http://blog.csdn.net/muge0913/article/details/6741064][VCC,VDD,VEE,VSS,VPP 表示的意义]] :blog:

VCC,VDD,VEE,VSS,VPP 表示的意义

*版本一：*

简单说来，可以这样理解：

一、解释

VCC：C=circuit 表示电路的意思, 即接入电路的电压；
 VDD：D=device 表示器件的意思, 即器件内部的工作电压；
 VSS：S=series 表示公共连接的意思，通常指电路公共接地端电压；
 VEE：负电压供电；
 VPP：编程/擦除电压。

二、说明

1、对于数字电路来说，VCC是电路的供电电压,VDD是芯片的工作电压（通常Vcc>Vdd），VSS是接地点。
 2、有些IC既有VDD引脚又有VCC引脚，说明这种器件自身带有电压转换功能。

3、在场效应管（或COMS器件）中，VDD为漏极，VSS为源极，VDD和VSS指的是元件引脚，而不表示供电电压。

*版本二：*

VPP：编程/擦除电压。
 VEE：负电压供电；场效应管的源极（S）
 VSS:地或电源负极

VCC：电源电压（双极器件）；电源电压（74系列数字电路）；声控载波（Voice Controlled Carrier)

VDD:电源电压（单极器件）；电源电压（4000系列数字电 路）；漏极电压（场效应管）

*版本三：*

通常VCC和VDD为电源正，而VEE和VSS为电源负或者地。
 VSS表示连接到场效应管的源极（S）的电源。
 VDD表示连接到场效应管的漏极（D）的电源。
 VEE表示连接到三极管发射极（E）的电源。
 VCC表示连接到三极管集电极（C）的电源。
 它们是这样得名的：

VCC、VDD、VEE、VSS是指芯片、分解电路的电源集结点，详细接电源的极性需视器件材料而定。 VCC一般是指直接连接到集成或分解电路内部的三极管C极，VEE是指连接到集成或分解电路内部三极管的E极。 同样，VDD、VSS就是指连接到集成内部、分解电路的场效应管的D和S极。 例如是采用P沟E/DMOS工艺制成的集成，那么它的VDD就应接电源的负，而VSS应接正电源。

*版本四：*

Vcc和Vee出现在双极型晶体管电路中，和集电极(collector)发射极(emitter)有关，所以一正一负。

Vdd,Vss在MOS电路中出现，和漏级(Drain)，源极(Source)有关，也是一正一负。

Vcc和Vdd是器件的电源端。Vcc是双极器件的正，Vdd多半是单级器件的正（例如：二极管）。下标可以理解为NPN晶体管的集电极C，和PMOS
or
NMOS场效应管的漏极D。同样你可在电路图中看见Vee和Vss，含义一样。因为主流芯片结构是硅NPN所以Vcc通常是正。如果用PNP结构Vcc就为负了。建议选用芯片时一定要看清电气参数。
 单片机中Vpp多数定义为编程电压，有的资料上把Vddf为Flash供电的外部电压



*总结：这四个版本从两个方面讲了VCC、VDD、VEE、VSS、VPP之间的区别，前两个版本一个方面，后两个版本一个方面，互相补充。*

** proteus                                                     :proteus:eda:
*** intro

Proteus 软件是英国 Lab Center Electronics 公司出版的 EDA 工具软件。它
不仅具有其它EDA工具软件的仿真功能，还能仿真单片机及外围器件。它是目前
比较好的仿真单片机及外围器件的工具。

*** ubuntu                                                         :ubuntu:

**** alternatives

+ KiCad (available in the software center)
+ PCB Designer (available in software center)
+ gEDA (available in the software center)
+ Visolate (available in the software center)
+ ktech lab

**** [[http://askubuntu.com/questions/77399/are-there-any-alternative-programs-to-proteus-available][proteus alternative: wine]] :wine:

If you want, you can install Proteus /7.0/ which is functional on Ubuntu
12.04 (32bits) with Wine or PlayonLinux. However, newer versions (7.5
or 8.0) won't work since wine finishes with errors during execution.

Wine is good but not enough for such complex software as Proteus. I
installed CrossOver (based on Wine), and install Proteus on it
successfully.

[[https://www.codeweavers.com/products/][crossover: based on wine,  for Mac, 商业软件]]

**** 虚拟机 Virtualbox

*** reference

+ [[http://opt.zju.edu.cn/weijiyuanli/upload/PROTEUS/Proteus%20VSM%E6%95%99%E7%A8%8B/Proteus%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.htm][Proteus 入门教程]]
+ [[][]]

** Web 相关
*** [[http://lanbing510.info/2015/12/01/Arm-Environment-Problems.html][通过tftp下载文件到开发板]]                           :ftp:tftp:blog_冰蓝:


上位机上编译好可执行文件后需要下载到Arm开发版进行运行，可以通过U盘直接
拷贝（太繁琐），可以使用串口通过rz等下载（串口传输速度太慢，不适用于大
文件），还可以使用网络进行传输。下面介绍如何搭建tftp环境进行开发板和上
位机（Ubuntu）之间的文件传输。

*一、Ubuntu上搭建tftp服务器*

1 安装tftp服务

#+BEGIN_EXAMPLE
    sudo apt-get install tftpd tftp openbsd-inetd
#+END_EXAMPLE

2 配置工作目录

#+BEGIN_EXAMPLE
    sudo gedit /etc/inetd.conf
#+END_EXAMPLE

找到文件里以下部分

#+BEGIN_EXAMPLE
    #:BOOT: TFTP service is provided primarily for booting. Most sites
    # run this only on machines acting as "boot servers."
    #tftp dgram udp wait nobody /usr/sbin/tcpd /usr/sbin/in.tftpd /srv/tftp
#+END_EXAMPLE

将tftp dgram udp wait nobody /usr/sbin/tcpd /usr/sbin/in.tftpd
/srv/tftp这一行解除注释（如果没有此行则进行添加）。

创建tftp服务器的文件目录

#+BEGIN_EXAMPLE
    cd /srv
    sudo mkdir tftp
    sudo chmod 777 /srv/tftp
#+END_EXAMPLE

3 重启xinetd服务

#+BEGIN_EXAMPLE
    sudo /etc/init.d/openbsd-inetd restart
#+END_EXAMPLE

4 本机测试

首先在tftp中新建一个文件

#+BEGIN_EXAMPLE
    cd /srv/tftp
    echo helloworld > helloworld.txt
    cat helloworld.txt #查看helloworld.txt内容，看是否成功创建
#+END_EXAMPLE

然后进入到其他目录，例如home

#+BEGIN_EXAMPLE
    cd ~
    sudo tftp 你的PC机ip #进入tftp
    tftp> get helloworld.txt #取helloworld.txt文件
    tftp> quit
    cat helloworld.txt #查看是否传输成功
#+END_EXAMPLE

*二、Arm开发板上使用tftp下载*

将远程主机上的/srv/tftp/helloworld.txt下载到开发板/opt/下：

#+BEGIN_EXAMPLE
    tftp -l /opt/helloworld.txt -r /srv/tftp/helloworld.txt -g 你的PC机ip
#+END_EXAMPLE

注：tftp命令，-l后跟local file， -r后跟remote
file，-g表示下载，-p表示上传。

如果下载不下来，用ping先检查网络的连通性，如果ping不通，将开发板的ip网段设到Ubuntu同一网段中去。

可使用命令：

#+BEGIN_EXAMPLE
    ifconfig eth0 192.168.1.120 netmask 255.255.255.0 broadcast 192.168.1.255 up
#+END_EXAMPLE

上述命令中ip，netmask，broadcast根据自己Ubuntu上的进行相应更改。

也可编辑interfaces文件，vi /etc/network/interfaces：

#+BEGIN_EXAMPLE
    auto lo
    iface lo inet loopback

    auto eth0
    iface eth0 inet static

    #以下按自己的实际情况改
    address 192.168.1.120
    netmask 255.255.255.0
    gateway 192.168.1.255
#+END_EXAMPLE

编辑完毕重启网络服务即可。

#+BEGIN_EXAMPLE
    service networking restart
#+END_EXAMPLE

** miscellaneous

*** MCU8051                                                       :mcu8051:

**** install                                                     :install:

+ 安装  http://www.moravia-microsystems.com/mcu-8051-ide/

  #+BEGIN_EXAMPLE
    cd build
    cmake ..
    make
    make install
  #+END_EXAMPLE

+ 运行

  + 缺少库

    #+BEGIN_EXAMPLE
    sudo apt-get install tcl8.5 tk8.5 tcllib tclx8.4 libtk-img rxvt-unicode sdcc doxygen itcl3 bwidget tdom
    #+END_EXAMPLE

  + Unable to load library img::png

    #+BEGIN_EXAMPLE
    apt-get install libtk-img
    #+END_EXAMPLE

  + Unable to load library BWidget

    #+BEGIN_EXAMPLE
    apt-get install bwidget
    #+END_EXAMPLE

  + couldn't load file
    "/usr/local/share/mcu8051ide/lib/libitcl3.4.so.Linux

    #+BEGIN_EXAMPLE
    apt-get install itcl3
    #+END_EXAMPLE

  + Unable to load library md5

    #+BEGIN_EXAMPLE
    apt-get install tcllib
    #+END_EXAMPLE

  + Unable to load library tdom

    #+BEGIN_EXAMPLE
    apt-get install tdom
    #+END_EXAMPLE

* MCU
** ARM                                                                 :arm:
*** Register

The ARM processor has a total of 37 registers:
1. 31 general-purpose registers(32-bits) including a program counter.
2. 6 status registers(32-bits)

Registers are arranged in partially overlapping banks(分组), with the
current processor mode controlling which bank is avaliable.


**** General-purpose registers(通用寄存器)

***** R0-R7: the unbanked registers

*Unbanked registers* means that each of them refers to the same 32-bit
 physical register in all processor modes. They are completely
 general-purpose registers, with no special used implied by the
 architecture, and can be used wherever an instruction allows a
 general-pupose register to be specified.

***** R8-R14: the banked registers

Registers R8 to R12 have two banked physical registers each. One is
used in all processor modes other than FIQ mode, and the other is used
in FIQ mode. R8-R12 do not have any dedicated special purposes in the
architecture.

Registers R13 and R14 have six banked physical registers each. One is
used in User and System modes, and each of the remaining five is used
in one of the five exception modes.

R13 is normally used as a stack pointer and is also known as the *SP*.

R14 is known as the Link Register(LR) has two special functions in the
archetecture
+ In each mode, the mode's own version of R14 is used to hold
  subroutine return address
+ When an exception occurs, the appropriate exception mode's version
  of R14 is set to the exception return address.

R15 is used to read or write the Program Counter(PC)

***** R15, the PC,  the program counter
**** Program status registers


+ The Current Program Status Register(*CPRS*) is accessible inall
  processor mode. It contains condition code flags, interrupt disable
  bits, the current processor mode, and other status and control
  information.

+ Each exception mode alse has a Saved Program Status
  Register(*SPSR*), that is used to preserve the value of the CPSR
  when the associated exception occurs.


***** condition code flags
+ N: Negative
+ Z: Zero
+ C: Carry
+ V: oVerflow

***** Mode bits

***** T and J
The T and J bits select the current instruction set'

***** The interrupt disable bits
+ A: disable inprecise data aborts when it is set
+ I: disable IRQ interrupts when set
+ F: disable RIQ interrupts when set

***** E
bit 9(E) controls load and store endianess for data handling.

***** Q

*** 开发工具

**** 链接器脚本

#+BEGIN_SRC latex
\includepdf[pages={1-}, nup=2x4, frame=true, delta={12pt 12pt}]{~/Document/ARM/ARM/2/第2季-裸奔吧-ARM/上学期/专题1-工欲善其事-必先利其器/第4课-链接器脚本/链接器脚本.pdf}
#+END_SRC

+ .lds
+ 链接器语法
+ session(段)
  + 代码段
  + 数据段
  + bbs段
+ . 起始链接地址
+ 对齐 ALIGN(4)
+ 变量
+ 代码段首文件

**** MakeFile

#+BEGIN_SRC latex
\includepdf[pages={1-}, nup=2x4, frame=true, delta={12pt 12pt}]{~/Tiger/Ref/Makefile工程管理.pdf}
#+END_SRC

+ 规则
  + 普通规则：目标-依赖-命令
    - make some_object
  + 伪目标：.PHONY
  + 最终目标
  + 通用规则
+ 变量
  + 定义：无类型
  + 引用：$()
  + 预定义：
    - $^ --- 所有依赖
    - $@ --- 目标
    - $< --- 第一个依赖
+ 去回显 @
+ 重命名
  - MakeFile / makefile
  - -f

**** ARM 嵌入式的童年
***** Linux命令
****** 用户管理
1. useradd [opts] USER
2. userdel [opts] USER
   1) -r /home下的用户目录也被删除
3. passwd [opt] USER    # 修改密码
4. su [opt] USER    # 切换用户
5. groupadd [opt] GROUP
6. groupdel [opt] GROUP

****** 文件与目录
1. ls [opts] DIR/FILE
2. cd DIR
   1) cd ..
   2) cd -
3. cp [opt] FILE
   + -r 拷贝目录
4. mv [opts] SORUCE DES
5. rm [opt] DIR/FILE
   + -r 删除目录
   + -f --force
   + -i 询问
6. chmod [whoe][+|-|=][mode] FILE
   1) who
      + u 所有者
      + g 同组用户
      + o 其它用户
      + a 所有用户
   2) action
      + + 添加某个权限
      + - 取消某个权限
      + = 赋予某个权限
   3) 数字
      + r 4
      + w 2
      + x 1
7. mkdir [opt] DIR
   + -p 父目录不存在则创建
8. du DIR
9. pwd

****** 压缩打包
1. 后缀
   + *.gz <-> gzip
   + *.bz2 <-> bzip2
   + *.tar <-> tar
2. gzip
   1) gzip FILE
   2) gzip -d *.gz
3. bzip2
   1) bzip2 FILE
   2) bzip2 -d *.bz2
4. tar [opt] DIR/
   1) tar cvf DIR
   2) tar xvf *.tar
   3) tar czvf DIR
   4) tar zxvf *.tar.gz

****** 磁盘管理
1. mount [opt] DEVICE DIR
2. umount DIR
3. df [opt]    # 查看磁盘
4. touch FILE    # 创建文件
5. ln [opt] SOURCE LINK
   1) ln file hlink
   2) ln -s file slink
   3) 共同:
      + 与源文件保持同步
      + 不占存储空间
   4) 区别:
      + 删除源文件后, 软链接失效, 硬链接保持原有内容

****** 查找命令
1. find PARH -name FILE
2. grep REX-MODE PATH [opt]   # 路径下文件内容

****** 进程管理
1. ps
   + ps aux
2. kill [opt] pid
3. free [opt]
4. top [opt]    # CPU占有率

****** 杂项
1. 软件管理 rpm(RedHat)
2. 管道 |
3. man CMD
4. shutdown [opt] TIME

***** Linux文本编辑器
****** Emacs
****** Vi
******* 三种模式
1. 命令行模式: 插入模式下键入ESC
2. 插入模式: 命令模式下键入i
3. 底行模式: 命令模式下键入:
******* 命令模式
1. yy: 复制当前行
2. [n]yy: 复制当前光标起的n行
3. p: 粘贴
4. dd: 删除当前行
5. [n]dd: 删除当前行开始的n行
6. /name: 查找
7. G: 移动到文件尾部
8. u: 取消上一个动作
******* 插入模式
******* 底行模式
+ :w --- 保存
+ :q --- 退出
+ :q! --- 强行退出
+ :wq --- 保存退出
+ :w [filenaem] --- 另存
+ :set nu --- 显示行号
+ :set nonu --- 取消显示行号
+ :/
***** Linux网络配置
****** 虚拟机网络模式
1. bridge(桥接模式)
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.7\linewidth]{~/Wally/Journal/Figures/scrot/24643_tw.png}
   \end{figure}

2. NAT(网络地址转换模式)
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.7\linewidth]{~/Wally/Journal/Figures/scrot/24643LMM.png}
   \end{figure}

3. host-only(主机模式)
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.7\linewidth]{~/Wally/Journal/Figures/scrot/24643YWS.png}
   \end{figure}

****** 相关命令
1. ifconfig: 查看网卡信息
2. /etc/init.d/network restart: 重启各网卡
****** Linux网络接口
1. eth0: 系统中的第一块物理网卡
2. lo: 虚拟的回环网卡
3. virbr0: 虚拟网桥
****** 网络设置
文件位置: /etc/sysconfig/network-script/ifcfg-eth0 (好像不对)
***** 远程登录Linux
1. 前提1: 从Windows能够Ping通Linux
2. 前提2: 关闭Linux防火墙
   #+BEGIN_EXAMPLE
     /etc/init.d/iptables stop
   #+END_EXAMPLE
3. 登录
   1) 方式一: CLI
      Putty

***** 文件共享

**** 交叉开发的通信方式
1. 网络：tffp/NFS(网络文件系统)
2. 串口
3. JTAG
4. USB
**** dnw
+ http://blog.csdn.net/u011452544/article/details/39393857
+ http://blog.csdn.net/huanghui167/article/details/8174763
+ https://github.com/Qunero/dnw4linux


1. error: dnw can not open dev secbulk0
   1) sudo?
   2) dev/secbulk0 OR dev/secbulk1(修改dnw源码)

*** 开发环境
**** windows

+ 开发工具： ADS RVDS
  + 做了很多重要工作，如makefile
  + Win&7 64 不兼容
+
**** Linux

+ makefile
+ lds链接器脚本
+ eclispe调试

**** 开发流程

1. 编写祼机程序
2. 调试
3. 生成二进制映像
4. 烧写

**** 交叉工具链

1. arm-linux-gcc 交叉工具编译
   - arm-linux-gcc -g -c led.S
2. arm-linux-ld 链接器脚本
   - arm-linux-ld -Tled.lds -o led.elf led.o
3. arm-linux-objcopy 转换elf为二进制
   - arm-linux-objcopy -O binary led.elf led.bin

4. 使用Makefile集成在一起
**** 烧写
+ Nand flash（相当于硬盘）：祼机程序烧写到Nand中
+ Nor flash: 建立与PC机连接，将文件烧写到Nand中（bootlaoder）

*** 连接方式
**** 串口连接
SecureCRT
- ttyUSB0
- Baudrate： 115200
- 取消勾选RTS/CTS

电脑机箱后的串口坏了，VGA线也坏了
**** JLink

目前在linux下使用jlink有两种方法，一种是用官方提供的linux下的beta版，
一种是使用openocd

***** J-Link(for Linux)
1. 下载安装

   + https://www.segger.com/jlink-software.html

   + Readme：适当修改权限

2.

***** J-Link
l  程序启动后Jlink会升级固件，结果升级的固件无法运行，拔下来之后发现
jlink已经不能用了，没有办法，需要重新刷固件。

1. 使用旧版本驱动软件。

   我发现jlink的升级固件并不是从网上下载的，而是该版本内嵌的固件，每一
   个不同的版本所带的固件也不相同。我下载的是最新的V441g版本，所带的固
   件比我的Jlink上的固件要新不少。从网上下载了V422a版本后，不会提示升
   级固件了，能够正常连接到开发板。另外，我发现，如果Windows下能够正常
   连接的话，Linux下选用和Windows下同样的软件版本，应该就能正常使用了，
   我Windows下正好也是V422a版本。

2. 升级Jlink固件

   如果能想办法把jlink升级到最新的固件，那即便用最新的驱动软件应该也不
   会提示升级固件了。Linux下是不可以了，似乎不能成功，Windows可以试一
   试。下载了Windows版本的Jlink驱动V442b，安装后连接Jlink，果然提示升
   级，升级后发现也不行，固件似乎也不能运行，Jlink Commander 停在了
   “New firmware booted successfully”这里，我的Jlink大概不能兼容最新
   的固件。软件换回V422a版本，重新连接Jlink，竟然发现固件升级成功了，
   而且也可以连接到开发板，简单测试没有发现问题。回到Linux下使用V441g
   版本连接，正常连接。

***** JLink烧写固件

问题：USB识别不了，JLINK上的指示灯也不亮。
原因：内部固件意外损坏或丢失。JLINK是没那么容易坏的，除非用火烧它。即
便是山寨得也是如此。可以通过刷固件得方法解决。

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{~/Wally/Journal/Figures/24343357_1409355462jrsL.jpg}
\end{figure}


1. Jlink 和PC相连的USB线，先拔下，将JLINK断电

2. 利用短接线短接ERASE短接点，然后连接USB线到PC,给JLINK供电

3. 第三步：等待大约5秒钟时间，断开USB线，给JLINK 断电

4. 将短接在ERASE短接点上的短接线拔下，短接到TST短接点上，然后连接USB线
   给JLINK 供电。


5. 等待大约20秒吧，然后断开USB线，给JLINK断电，然后拔掉TST上的短接线。
   上面五步中，短接线连接要稳定，不可以松动。

6. 给JLINK连接上USB线，重新给JLINK供电，这个时候，USB会识别出usb
   device，但是在设备管理其中会显示一个黄色的问号就是缺少驱动的意思，
   因为JLINK现在控制烧写程序的固件都被擦除了，但是它本身就是一个
   AT91SAM7S64测试板，因为JLINK的主控芯片就是这个AT91SAM7S64，接下来我
   们利用ATMEL公司的烧写软件sam-ba_2.10.exe软件烧写新的固件程序。

7. 我们要给JLINK重新烧写固件程序，先安装sam-ba_2.10.exe软件，然后就会
   发现此时JLINK被设备管理器识别为一个AT91测试板的USBdevice，因为此时
   的JLINK没有控制烧写程序的固件，但是它本身的USB和一些程序是正常运行
   的，所以现在就当初AT91的开发板了。

8. 打开sam-ba_2.10.exe软件，选择界面信息如下图，连接选择USB/ARM0，如果
   没有这一选项，重新拔插给JLINK上电，或重启计算机，选择开发板，就要选
   择AT91SAM7S64-EK，因为我的芯片就是这个芯片。然后点击连接按钮。

**** Linux超级终端 minicom
+ http://blog.csdn.net/bird67/article/details/2127235
+ http://www.cnblogs.com/pang123hui/archive/2011/05/30/2309887.html
***** 工具
+ 图形界面
  - cutecom
  - gtkterm
+ 文本界面
  - minicom
***** minicom
****** overview
Linux下的Minicom的功能与Windows下的超级终端功能相似，可以通过串口控制外部的硬件
设备.适于在linux通过超级终端对嵌入式设备行管理.同样也可以使用minicom对外置Modem
进行控制.

HOMEPAGE: https://alioth.debian.org/projects/minicom/

Minicom is a menu driven communications program. It emulates ANSI and
VT102 terminals. It has a dialing directory and auto zmodem download.

安装
1. apt
   #+BEGIN_SRC sh :results output
     apt-cache search minicom
   #+END_SRC

   #+RESULTS:
   : minicom - friendly menu driven serial communication program
   : cutecom - 图形界面的串口调试终端，类似于 minicom

2. 源码
   + 官网下载源码包
   + ./configure make make install
****** 使用
******* 启动
$ minicom
#+BEGIN_EXAMPLE
  Welcome to minicom 2.7

  OPTIONS: I18n
  Compiled on Jun 11 2015, 20:46:06.
  Port /dev/ttyS1, 08:41:48

  Press CTRL-A Z for help on special keys
#+END_EXAMPLE
******* font color
$ minicom -c on

.bashrc: export minicom="minicom -c on"
******* 基本使用
*Commands can be called by CTRL-A <key>*

|----------------------+----------------------+----------------------|
| Dialing directory..D | run script (Go)....G | Clear Screen.......C |
| Send files.........S | Receive files......R | cOnfigure Minicom..O |
| comm Parameters....P | Add linefeed.......A | Suspend minicom....J |
| Capture on/off.....L | Hangup.............H | eXit and reset.....X |
| send break.........F | initialize Modem...M | Quit with no reset.Q |
| Terminal settings..T | run Kermit.........K | Cursor key mode....I |
| lineWrap on/off....W | local Echo on/off..E | Help screen........Z |
| Paste file.........Y | Timestamp toggle...N | scroll Back........B |
| Add Carriage Ret...U |                      |                      |
|----------------------+----------------------+----------------------|

1. 发送

   进入开发板目录， Ctrl-A s 然后选择发送的文件

2. 接收
   sz filename 即可
****** Usage
+ http://linux.die.net/man/1/minicom
******* minicom(1) - Linux man page

******** Name

minicom - friendly serial communication program

******** Synopsis

*minicom* [-somMlwz8] [-c on|off] [-S script] [-d entry]

[-a on|off] [-t term] [-p pty] [-C capturefile] [/configuration/]
******** Description

*minicom* is a communication program which somewhat resembles the
shareware program TELIX but is free with source code and runs under most
unices. Features include dialing directory with auto-redial, support for
UUCP-style lock files on serial devices, a separate script language
interpreter, capture to file, multiple users with individual
configurations, and more.

******** Command-line

*-s*
*S*etup. Root edits the system-wide defaults in /etc/minirc.dfl with
this option. When it is used, minicom does /not/ initialize, but puts
you directly into the configuration menu. This is very handy if minicom
refuses to start up because your system has changed, or for the first
time you run minicom. For most systems, reasonable defaults are already
compiled in.

*-o*

Do not initialize. Minicom will skip the initialization code. This
option is handy if you quitted from minicom without resetting, and then
want to restart a session. It is potentially dangerous though: no check
for lock files etc. is made, so a normal user could interfere with
things like uucp... Maybe this will be taken out later. For now it is
assumed, that users who are given access to a modem are responsible
enough for their actions.

*-m*

Override command-key with the Meta or ALT key. This is the default in
1.80 and it can also be configured in one of minicom's menus, but if you
use different terminals all the time, of which some don't have a Meta or
ALT key, it's handy to set the default command key to Ctrl-A and use
this option when you have a keyboard supporting Meta or ALT keys.
Minicom assumes that your Meta key sends the ESC prefix, not the other
variant that sets the highest bit of the character.

*-M*

Same as -m, but assumes that your Meta key sets the 8th bit of the
character high (sends 128 + character code).

*-z*

Use terminal status line. This only works on terminals that support it
and that have the relevant information in their /termcap/ or /terminfo/
database entry.

*-l*

*L*iteral translation of characters with the high bit set. With this
flag on, minicom will try to translate the IBM line characters to ASCII.
Many PC-unix clones will display character correctly without translation
(Linux in a special mode, Coherent and Sco).

*-L*

Ditto but assume screen uses an ISO8859 character set.

*-w*

Turns line-wrap on at startup by default.

*-a*

*A*ttribute usage. Some terminals, notably Televideo's, have rotten
attribute handling (serial instead of parallel). By default, minicom
uses '-a on', but if you are using such a terminal you can (must!)
supply the option '-a off'. The trailing 'on' or 'off' is needed.

*-t*

*T*erminal type. With this flag, you can override the environment TERM
variable. This is handy for use in the MINICOM environment variable; one
can create a special termcap entry for use with minicom on the console,
that initializes the screen to raw mode so that in conjunction with the
-l flag, the IBM line characters are displayed untranslated.

*-c*

*C*olor usage. Some terminals (such as the Linux console) support color
with the standard ANSI escape sequences. Because there is apparently no
termcap support for color, these escape sequences are hard-coded into
minicom. Therefore this option is off by default. You can turn it on
with '-c on'. This, and the '-m' option, are good candidates to put into
the MINICOM environment variable.

*-S*

*script*. Run the named script at startup. So far, passing username and
password to a startup script is not supported. If you also use the -d
option to start dialing at startup, the -S script will be run BEFORE
dialing the entries specified with -d.

*-d*

*D*ial an entry from the dialing directory on startup. You can specify
an index number, but also a substring of the name of the entry. If you
specify a name that has multiple entries in the directory, they are all
tagged for dialing. You can also specify multiple names or index numbers
by separating them with commas. The dialing will start from the first
entry specified after all other program initialization procedures are
completed.

*-p*

*P*seudo terminal to use. This overrides the terminal port defined in
the configuration files, but only if it is a pseudo tty. The filename
supplied must be of the form (/dev/)tty[p-z/][0-f],
(/dev/)pts[p-z/][0-f] or (/dev/)pty[p-z/][0-f]. For example, /dev/ttyp1,
pts/0 or /dev/ptyp2.

*-C*

*filename*. Open capture file at startup.

*-T*

Disable the display of the online time in the status bar.

*-7*

7bit mode for terminals which aren't 8bit capable. 8bit is default if
the environment is configured for this via LANG or LC_ALL, 7bit
otherwise.

*-8*

8bit characters pass through without any modification. 'Continuous'
means no locate/attribute control sequences are inserted without real
change of locate/attribute. This mode is to display 8bit multi-byte
characters such as Japanese. Not needed in every language with 8bit
characters. (For example displaying Finnish text doesn't need this.)
When *minicom* starts, it first searches the MINICOM environment
variable for command-line arguments, which can be over-ridden on the
command line. Thus, if you have done
MINICOM='-m -c on'\\
 export MINICOM
or the equivalent, and start minicom, minicom will assume that your
terminal /has/ a Meta or <ALT> key and that color is supported. If you
then log in from a terminal without color support, and you have set
MINICOM in your startup (.profile or equivalent) file, and don't want to
re-set your environment variable, you can type 'minicom -c off' and run
without color support for that session.
*configuration*
The /configuration/ argument is more interesting. Normally, minicom gets
its defaults from a file called "minirc.dfl". If you however give an
argument to minicom, it will try to get its defaults from a file called
"minirc./configuration/". So it is possible to create multiple
configuration files, for different ports, different users etc. Most
sensible is to use device names, such as tty1, tty64, sio2 etc. If a
user creates his own configuration file, it will show up in his home
directory as '.minirc.dfl'.
******** Use

Minicom is window based. To popup a window with the function you want,
press Control-A (from now on, we will use C-A to mean Control-A), and
then the function key (a-z or A-Z). By pressing C-A first and then 'z',
a help screen comes up with a short summary of all commands. This escape
key can be altered when minicom is configured (-s option or C-A O), but
we'll stick to Control-A for now.

For every menu the next keys can be used:

*UP*
arrow-up or 'k'

*DOWN*

arrow-down or 'j'

*LEFT*

arrow-left or 'h'

*RIGHT*

arrow-right or 'l'

*CHOOSE*

Enter

*CANCEL*

ESCape.
The screen is divided into two portions: the upper 24 lines are the
terminal-emulator screen. In this window, ANSI or VT100 escape sequences
are interpreted. If there is a line left at the bottom, a status line is
placed there. If this is not possible the status line will be showed
every time you press C-A. On terminals that have a special status line
that will be used if the termcap information is complete /and/ the *-k*
flag has been given.
Possible commands are listed next, in alphabetical order.
*C-A*
Pressing C-A a second time will just send a C-A to the remote system. If
you have changed your "escape character" to something other than C-A,
this works analogously for that character.

*A*

Toggle 'Add Linefeed' on/off. If it is on, a linefeed is added before
every carriage return displayed on the screen.

*B*

Gives you a scroll back buffer. You can scroll up with *u*, down with
*d*, a page up with *b*, a page down with *f*, and if you have them the
*arrow* and *page up/page down* keys can also be used. You can search
for text in the buffer with *s* (case-sensitive) or *S*
(case-insensitive). *N* will find the next occurrence of the string. *c*
will enter citation mode. A text cursor appears and you specify the
start line by hitting Enter key. Then scroll back mode will finish and
the contents with prefix '>' will be sent.

*C*

Clears the screen.

*D*

Dial a number, or go to the dialing directory.

*E*

Toggle local echo on and off (if your version of minicom supports it).

*F*

A break signal is sent to the modem.

*G*

Run script (Go). Runs a login script.

*H*

Hangup.

*I*

Toggle the type of escape sequence that the cursor keys send between
normal and applications mode. (See also the comment about the status
line below).

*J*

Jump to a shell. On return, the whole screen will be redrawn.

*K*

Clears the screen, runs kermit and redraws the screen upon return.

*L*

Turn Capture file on off. If turned on, all output sent to the screen
will be captured in the file too.

*M*

Sends the modem initialization string. If you are online and the DCD
line setting is on, you are asked for confirmation before the modem is
initialized.

*O*

Configure minicom. Puts you in the configuration menu.

*P*

Communication Parameters. Allows you to change the bps rate, parity and
number of bits.

*Q*

Exit minicom without resetting the modem. If macros changed and were not
saved, you will have a chance to do so.

*R*

Receive files. Choose from various protocols (external). If you have the
filename selection window and the prompt for download directory enabled,
you'll get a selection window for choosing the directory for
downloading. Otherwise the download directory defined in the Filenames
and paths menu will be used.

*S*

Send files. Choose the protocol like you do with the receive command. If
you don't have the filename selection window enabled (in the File
transfer protocols menu), you'll just have to write the *filename*(s) in
a dialog window. If you have the selection window enabled, a window will
pop up showing the filenames in your upload directory. You can tag and
untag filenames by pressing spacebar, and move the cursor up and down
with the cursor keys or j/k. The selected filenames are shown
highlighted. Directory names are shown [within brackets] and you can
move up or down in the directory tree by pressing the spacebar twice.
Finally, send the files by pressing ENTER or quit by pressing ESC.

*T*

Choose Terminal emulation: Ansi(color) or vt100. You can also change the
backspace key here, turn the status line on or off, and define delay (in
milliseconds) after each newline if you need that.

*W*

Toggle line-wrap on/off.

*X*

Exit minicom, reset modem. If macros changed and were not saved, you
will have a chance to do so.

*Y*

Paste a file. Reads a file and sends its contests just as if it would be
typed in.

*Z*

Pop up the help screen.
******** Dialing Directory

By pressing C-A D the program puts you in the dialing directory. Select
a command by pressing the capitalized letter or moving cursor right/left
with the arrow keys or the h/l keys and pressing Enter. You can add,
delete or edit entries and move them up and down in the directory list.
By choosing "dial" the phone numbers of the tagged entries, or if
nothing is tagged, the number of the highlighted entry will be dialed.
While the modem is dialing, you can press escape to cancel dialing. Any
other key will close the dial window, but won't cancel the dialing
itself. Your dialing directory will be saved into the file ".dialdir" in
your home directory. You can scroll up and down with the arrow keys, but
you can also scroll complete pages by pressing the PageUp or PageDown
key. If you don't have those, use Control-B (Backward) and Control-F
(Forward). You can use the space bar to *tag* a number of entries and
minicom will rotate trough this list if a connection can't be made. A
'>' symbol is drawn in the directory before the names of the tagged
entries.

The "edit" menu speaks for itself, but I will discuss it briefly here.

*A - Name*
The name for this entry
*B - Number*
and its telephone number.
*C - Dial string #*
Which specific dial string you want to use to connect. There are three
different dial strings (prefixes and suffixes) that can be configured in
the *Modem and dialing* menu.
*D - Local echo*
can be on or off for this system (if your version of minicom supports
it).
*E - Script*
The script that must be executed after a successful connection is made
(see the manual for runscript)
*F - Username*
The username that is passed to the runscript program. It is passed in
the environment string "$LOGIN".
*G - Password*
The password is passed as "$PASS".
*H - Terminal Emulation*
Use ANSI or VT100 emulation.
*I - Backspace key sends*
What code (Backspace or Delete) the backspace key sends.
*J - Linewrap*
Can be on or off.
*K - Line settings*
Bps rate, bits, parity and number of stop bits to use for this
connection. You can choose *current* for the speed, so that it will use
whatever speed is being used at that moment (useful if you have multiple
modems).
*L - Conversion table*
You may specify a character conversion table to be loaded whenever this
entry answers, before running the login script. If this field is blank,
the conversion table stays unchanged.
The edit menu also shows the latest date and time when you called this
entry and the total number of calls there, but doesn't let you change
them. They are updated automatically when you connect.
The moVe command lets you move the highlighted entry up or down in the
dialing directory with the up/down arrow keys or the k and j keys. Press
Enter or ESC to end moving the entry.
******** Configuration

By pressing C-A O you will be thrown into the setup menu.

*Filenames and paths*

This menu defines your default directories.
*A - Download directory*
where the downloaded files go to.
*B - Upload directory*
where the uploaded files are read from.
*C - Script directory*
Where you keep your login scripts.
*D - Script program*
Which program to use as the script interpreter. Defaults to the program
"runscript", but if you want to use something else (eg, /bin/sh or
"expect") it is possible. Stdin and stdout are connected to the modem,
stderr to the screen.
If the path is relative (ie, does not start with a slash) then it's
relative to your home directory, except for the script interpreter.
*E - Kermit program*
Where to find the executable for kermit, and it's options. Some simple
macro's can be used on the command line: '%l' is expanded to the
complete filename of the dial out-device, '%f' is expanded to the serial
port file descriptor and '%b' is expanded to the current serial port
speed.
*F - Logging options*
Options to configure the logfile writing.
*A - File name*
Here you can enter the name of the logfile. The file will be written in
your home directory, and the default value is "minicom.log". If you
blank the name, all logging is turned off.

*B - Log connects and hangups*
This option defines whether or not the logfile is written when the
remote end answers the call or hangs up. Or when you give the hangup
command yourself or leave minicom without hangup while online.

*C - Log file transfers*
Do you want log entries of receiving and sending files.

The 'log' command in the scripts is not affected by logging options B
and C. It is always executed, if you just have the name of the log file
defined.
*File Transfer Protocols*
Protocols defined here will show up when C-A s/r is pressed. "Name" in
the beginning of the line is the name that will show up in the menu.
"Program" is the path to the protocol. "Name" after that defines if the
program needs an argument, e.g. a file to be transmitted. U/D defines if
this entry should show up in the upload or the download menu. Fullscr
defines if the program should run full screen, or that minicom will only
show it's stderr in a window. IO-Red defines if minicom should attach
the program's standard in and output to the modem port or not. "Multi"
tells the filename selection window whether or not the protocol can send
multiple files with one command. It has no effect on download protocols,
and it is also ignored with upload protocols if you don't use the
filename selection window. The old sz and rz are not full screen, and
have IO-Red set. However, there are curses based versions of at least rz
that do not want their stdin and stdout redirected, and run full screen.
All file transfer protocols are run with the UID of the user, and not
with UID=root. '%l', '%f' and '%b' can be used on the command line as
with kermit. Within this menu you can also define if you want to use the
filename selection window when prompted for files to upload, and if you
like to be prompted for the download directory every time the automatic
download is started. If you leave the download directory prompt
disabled, the download directory defined in the file and directory menu
is used.
*Serial port setup*
*A - Serial device*
/dev/tty1 or /dev/ttyS1 for most people. /dev/cua<n> is still possible
under linux, but not recommended any more because these devices are
obsolete and many newly installed systems with kernel 2.2.x or newer
don't have them. Use /dev/ttyS<n> instead. You may also have /dev/modem
as a symlink to the real device.\\
 If you have modems connected to two or more serial ports, you may
specify all of them here in a list separated by space, comma or
semicolon. When Minicom starts, it checks the list until it finds an
available modem and uses that one. (However, you can't specify different
init strings to them ..at least not yet.)\\
 To use a UNIX socket for communication the device name must be prefixed
with "unix#" following by the full path and the filename of the socket.
Minicom will then try to connect to this socket as a client. As long as
it cannot connect to the socket it stays 'offline'. As soon as the
connection establishes, minicom goes 'online'. If the server closes the
socket, minicom switches to 'offline' again.
*B - Lock file location*
On most systems This should be /usr/spool/uucp. Linux systems use
/var/lock. If this directory does not exist, minicom will not attempt to
use lockfiles.
*C - Callin program*
If you have a uugetty or something on your serial port, it could be that
you want a program to be run to switch the modem cq. port into
dialin/dialout mode. This is the program to get into dialin mode.
*D - Callout program*
And this to get into dialout mode.
*E - Bps/Par/Bits*
Default parameters at startup.
If one of the entries is left blank, it will not be used. So if you
don't care about locking, and don't have a getty running on your
modemline, entries B - D should be left blank.
*Modem and Dialing*
Here, the parameters for your modem are defined. I will not explain this
further because the defaults are for generic Hayes modems, and should
work always. This file is not a Hayes tutorial :-) The only things worth
noticing are that control characters can be sent by prefixing them with
a '\^', in which '\^\^' means '\^' itself, and the '\' character must
also be doubled as '\\', because backslash is used specially in the
macro definitions. Some options however, don't have much to do with the
modem but more with the behaviour of minicom itself:
*M - Dial time*
The number of seconds before minicom times out if no connection is
established.
*N - Delay before redial*
Minicom will redial if no connection was made, but it first waits some
time.
*O - Number of tries*
Maximum number of times that minicom attempts to dial.
*P - Drop DTR time*
If you set this to 0, minicom hangs up by sending a Hayes-type hangup
sequence. If you specify a non-zero value, the hangup will be done by
dropping the DTR line. The value tells in seconds how long DTR will be
kept down.
*Q - Auto bps detect*
If this is on, minicom tries to match the dialed party's speed. With
most modern modems this is NOT desirable, since the modem buffers the
data and converts the speed.
*R - Modem has DCD line*
If your modem, and your O/S both support the DCD line (that goes 'high'
when a connection is made) minicom will use it. When you have this
option on, minicom will also NOT start dialing while you are already
online.
*S - Status line shows DTE speed / line speed*
You can toggle the status line to show either the DTE speed (the speed
which minicom uses to communicate with your modem) or the line speed
(the speed that your modem uses on the line to communicate with the
other modem). Notice that the line speed may change during the
connection, but you will still only see the initial speed that the
modems started the connection with. This is because the modem doesn't
tell the program if the speed is changed. Also, to see the line speed,
you need to have the modem set to show it in the connect string.
Otherwise you will only see 0 as the line speed.
*T - Multi-line untag*
You can toggle the feature to untag entries from the dialing directory
when a connection is established to a multi-line BBS. All the tagged
entries that have the same name are untagged.
*Note that a special exception is made for this menu: every user can
change all parameters here, but some of them will not be saved.*
*Screen and keyboard*
*A - Command key is*
the 'Hot Key' that brings you into command mode. If this is set to 'ALT'
or 'meta key', you can directly call commands by alt-key instead of
HotKey-key.
*B - Backspace key sends*
There still are some systems that want a VT100 to send DEL instead of
BS. With this option you can enable that stupidity. (Eh, it's even on by
default...)
*C - Status line is*
Enabled or disabled. Some slow terminals (for example, X-terminals)
cause the status line to jump "up and down" when scrolling, so you can
turn it off if desired. It will still be shown in command-mode.
*D - Alarm sound*
If turned on, minicom will sound an alarm (on the console only) after a
successful connection and when up/downloading is complete.
*E - Foreground Color (menu)*
indicates the foreground color to use for all the configuration windows
in minicom.
*F - Background Color (menu)*
indicates the background color to use for all the configuration windows
in minicom. Note that minicom will not allow you to set foreground and
background colors to the same value.
*G - Foreground Color (term)*
indicates the foreground color to use in the terminal window.
*H - Background Color (term)*
indicates the background color to use in the terminal window. Note that
minicom will not allow you to set foreground and background colors to
the same value.
*I - Foreground Color (stat)*
indicates the foreground color to use in for the status bar.
*J - Background Color (stat)*
indicates the color to use in for the status bar. Note that minicom will
allow you to set the status bar's foreground and background colors to
the same value. This will effectively make the status bar invisible but
if these are your intentions, please see the option
*K - History buffer size*
The number of lines to keep in the history buffer (for backscrolling).
*L - Macros file*
is the full path to the file that holds macros. Macros allow you to
define a string to be sent when you press a certain key. In minicom, you
may define F1 through F10 to send up to 256 characters [this is set at
compile time]. The filename you specify is verified as soon as you hit
ENTER. If you do not have permissions to create the specified file, an
error message will so indicate and you will be forced to re-edit the
filename. If you are permitted to create the file, minicom checks to see
if it already exists. If so, it assumes it's a macro file and reads it
in. If it isn't, well, it's your problem :-) If the file does not exist,
the filename is accepted.
*M - Edit Macros*
opens up a new window which allows you to edit the F1 through F10
macros.
*N - Macros enabled*
- Yes or No. If macros are disabled, the F1-F10 keys will just send the
VT100/VT220 function key escape sequences.
*O - Character conversion*
The active conversion table filename is shown here. If you can see no
name, no conversion is active. Pressing O, you will see the conversion
table edit menu.
*Edit Macros*
Here, the macros for F1 through F10 are defined. The bottom of the
window shows a legend of character combinations that have special
meaning. They allow you to enter special control characters with plain
text by prefixing them with a '\^', in which '\^\^' means '\^' itself.
You can send a 1 second delay with the '\^~' code. This is useful when
you are trying to login after ftp'ing or telnet'ing somewhere. You can
also include your current username and password from the phone directory
in the macros with '\u' and '\p', respectively. If you need the
backslash character in the macro, write it doubled as '\\'. To edit a
macro, press the number (or letter for F10) and you will be moved to the
end of the macro. When editing the line, you may use the left & right
arrows, Home & End keys, Delete & BackSpace, and ESC and RETURN. ESC
cancels any changes made while ENTER accepts the changes.
*Character conversion*
Here you can edit the character conversion table. If you are not an
American, you know that in many languages there are characters that are
not included in the ASCII character set, and in the old times they may
have replaced some less important characters in ASCII and now they are
often represented with character codes above 127. AND there are various
different ways to represent them. This is where you may edit conversion
tables for systems that use a character set different from the one on
your computer.
*A - Load table*
You probably guessed it. This command loads a table from the disk. You
are asked a file name for the table. Predefined tables .mciso, .mcpc8
and .mcsf7 should be included with the program. Table .mciso does no
conversion, .mcpc8 is to be used for connections with systems that use
the 8-bit pc character set, and .mcsf7 is for compatibility with the
systems that uses the good old 7-bit coding to replace the characters
{|}[]\ with the diacritical characters used in Finnish and Swedish.

*B - Save table*
This one saves the active table on the filename you specify.

*C - edit char*
This is where you can make your own modifications to the existing table.
First you are asked the character value (in decimal) whose conversion
you want to change. Next you'll say which character you want to see on
your screen when that character comes from the outside world. And then
you'll be asked what you want to be sent out when you enter that
character from your keyboard.

*D - next screen*
*E - prev screen*
Yeah, you probably noticed that this screen shows you what kind of
conversions are active. The screen just is (usually) too small to show
the whole table at once in an easy-to-understand format. This is how you
can scroll the table left and right.

*F - convert capture*
Toggles whether or not the character conversion table is used when
writing the capture file.

*Save setup as dfl*
Save the parameters as the default for the next time the program is
started. Instead of dfl, any other parameter name may appear, depending
on which one was used when the program was started.
*Save setup as..*
Save the parameters under a special name. Whenever Minicom is started
with this name as an argument, it will use these parameters. This option
is of course privileged to root.
*Exit*
Escape from this menu without saving. This can also be done with ESC.
*Exit from minicom*
Only root will see this menu entry, if he/she started minicom with the
'-s' option. This way, it is possible to change the configuration
without actually running minicom.
******** Status Line

The status line has several indicators, that speak for themselves. The
mysterious APP or NOR indicator probably needs explanation. The VT100
cursor keys can be in two modes: applications mode and cursor mode. This
is controlled by an escape sequence. If you find that the cursor keys do
not work in, say, vi when you're logged in using minicom then you can
see with this indicator whether the cursor keys are in applications or
cursor mode. You can toggle the two with the C-A I key. If the cursor
keys then work, it's probably an error in the remote system's termcap
initialization strings (is).

******** Locales

Minicom has support for local languages. This means you can change most
of the English messages and other strings to another language by setting
the environment variable LANG.

******** Misc

If minicom is hung, kill it with SIGTERM . (This means kill -15, or
since sigterm is default, just plain "kill <minicompid>". This will
cause a graceful exit of minicom, doing resets and everything. You may
kill minicom from a script with the command "! killall -9 minicom"
without hanging up the line. Without the -9 parameter, minicom first
hangs up before exiting.

Since a lot of escape sequences begin with ESC (Arrow up is ESC [ A),
Minicom does not know if the escape character it gets is you pressing
the escape key, or part of a sequence.

An old version of Minicom, V1.2, solved this in a rather crude way: to
get the escape key, you had to press it /twice/.

As of release 1.3 this has bettered a little: now a 1-second timeout is
builtin, like in vi. For systems that have the select() system call the
timeout is 0.5 seconds. And... surprise: a special Linux-dependant
*hack* :-) was added. Now, minicom can separate the escape key and
escape-sequences. To see how dirty this was done, look into wkeys.c. But
it works like a charm!

******** Files

Minicom keeps it's configuration files in one directory, usually
/var/lib/minicom, /usr/local/etc or /etc. To find out what default
directory minicom has compiled in, issue the command /minicom -h/.
You'll probably also find the demo files for *[[runscript]]*(1), and the
examples of character conversion tables either there or in the
subdirectories of /usr/doc/minicom*. The conversion tables are named
something like mc.* in that directory, but you probably want to copy the
ones you need in your home directory as something beginning with a dot.

#+BEGIN_EXAMPLE
    minicom.users
    minirc.*
    $HOME/.minirc.*
    $HOME/.dialdir
    $HOME/minicom.log
    /usr/share/locale/*/LC_MESSAGES/minicom.mo
#+END_EXAMPLE

******** See Also

*[[runscript]]*(1)

******** Bugs

Please report any bugs to
/[[mailto:minicom-devel@lists.alioth.debian.org][minicom-devel@lists.alioth.debian.org]]/.
Thank you!

******** Authors

The original author of minicom is Miquel van Smoorenburg
([[mailto:miquels@cistron.nl][miquels@cistron.nl]]). He wrote versions
up to 1.75.\\
 Jukka Lahtinen ([[mailto:walker@netsonic.fi][walker@netsonic.fi]],
[[mailto:jukkal@despammed.com][jukkal@despammed.com]]) has been
responsible for new versions since 1.78, helped by some other people,
including:\\
 [[mailto:filipg@paranoia.com][filipg@paranoia.com]] wrote the History
buffer searching to 1.79.\\
 Arnaldo Carvalho de Melo
([[mailto:acme@conectiva.com.br][acme@conectiva.com.br]]) did the
internationalization and the Brasilian Portuguese translations.\\
 Jim Seymour
([[mailto:jseymour@jimsun.linxnet.com][jseymour@jimsun.LinxNet.com]])
wrote the multiple modem support and the filename selection window used
since 1.80.\\
 Tomohiro Kubota ([[mailto:kubota@debian.or.jp][kubota@debian.or.jp]])
wrote the Japanese translations and the citation facility, and did some
fixes.\\
 Gael Queri ([[mailto:gqueri@mail.dotcom.fr][gqueri@mail.dotcom.fr]])
wrote the French translations.\\
 Arkadiusz Miskiewicz ([[mailto:misiek@pld.org.pl][misiek@pld.org.pl]])
wrote the Polish translations.\\
 Kim Soyoung ([[mailto:nexti@chollian.net][nexti@chollian.net]]) wrote
the Korean translations.\\
 Jork Loeser
([[mailto:jork.loeser@inf.tu-dresden.de][jork.loeser@inf.tu-dresden.de]])
provided the socket extension.

Most of this man page is copied, with corrections, from the original
minicom README, but some pieces and the corrections are by Michael K.
Johnson.

Jukka Lahtinen ([[mailto:walker@netsonic.fi][walker@netsonic.fi]]) has
added some information of the changes made after version 1.75.

******** Referenced By

*[[ascii-xfr]]*(1), *[[/man/8/gnokiid][gnokiid]]*(8),
*[[/man/4/isdn_audio][isdn_audio]]*(4),
*[[/man/8/picocom][picocom]]*(8), *[[qodem]]*(1),
*[[/man/4/ttyi][ttyi]]*(4), *[[xminicom]]*(1)









-  Site Search ::

-  Library :: [[http://linux.die.net/][linux docs]]
   [[http://linux.die.net/man/][linux man pages]]
   [[http://www.die.net/musings/page_load_time/][page load time]]

-  Toys :: [[http://www.die.net/earth/][world sunlight]]
   [[http://www.die.net/moon/][moon phase]]
   [[http://trace.die.net/][trace explorer]]

-  [[/man/1/][[[/style/back.gif]]]] ::





****** 配置
+ http://blog.csdn.net/bird67/article/details/2127235
******* $ minicom -s

1. Filenames and paths
2. File transfer protocols
3. Serial port setup
   + 设备名 e.g. /dev/ttyUSB0,  /dev/ttyACM0(Arduino)
   + 波特率等
   + *Hardware Flow Control: No* ??

4. Modem and dialing
   我们使用minicom作为超级终端控制路由器等设备, 而不是控制modem, 所以
   需要修改Modem and dialing, 将Init string, Reset string, Hang-up
   string设置为空

5. Screen and keyboard
6. Save setup as dfl
   + default config file
7. Save setup as
8. Exit
9. Exit from Minicom

**** USB
***** lsusb
***** dmesg | grep usb | grep tty
[40205.212182] usb 7-2: ch341-uart converter now attached to ttyUSB0

*** arm family
**** arm family

#+downloaded: /tmp/screenshot.png @ 2015-06-09 17:16:09
 [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_17:16:09.png]]
1. 芯片： 6410, 210，2440
2. arm核： a8, arm11, am9
3. 指令架构：armv7, armv6

2440(arm9(v4))
210(arm11(v6))
210(cortexa8(v7))
**** arm核

#+downloaded: /tmp/screenshot.png @ 2015-06-09 17:22:40
 [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_17:22:40.png]]

arm经典
cortex-m 无操作系统
cortex-r 实时
cortex-a 多媒体

**** 芯片对比
|----------+-------------+---------------------+---------------------|
|          | 2410        | 6440                | 210                 |
|----------+-------------+---------------------+---------------------|
| 处理速度 | 400-500     | 533-667             | 800-1g              |
| 缓存     | 16k         | 16k                 | 32k                 |
| 内在接口 | sdram       | sdram/ddr           | ddr1/ddr2           |
| 支持os   | wince/linux | wince/linux/android | wince/linux/android |
| 其它     | 商业停产    |                     |                     |
|----------+-------------+---------------------+---------------------|

*** 存储器格式(memory format)
**** big-endian format
in big-endian format(), the most significant byte(msb) of a world is
stored at the lowest numbered byte and the least significant byte(lsb)
at the highest numbered byte.

+ big-endian: 大端优先
+ msb：最高有效字节
+ lsb：最低有效字节

#+downloaded: /tmp/screenshot.png @ 2015-07-02 11:42:30
 [[~/Wally/Journal/Figures/embeddedlinux/screenshot_2015-07-02_11:42:30.png]]
**** little-endial format
in little-endian format, the lowest numbered byte in a word is
considered the word's least significant byte, and the highest numbered
byte the most significant.

#+downloaded: /tmp/screenshot.png @ 2015-07-02 11:58:29
 [[~/Wally/Journal/Figures/embeddedlinux/screenshot_2015-07-02_11:58:29.png]]
*** data type
[[file:/media/ben/reserch/document/%e8%8a%af%e7%89%87%e6%89%8b%e5%86%8c/armarchitecturereferencemanual.pdf::%25pdf-1.3%0d][armarchitecturedatatypes]]


+ byte: 8 bits
+ halfword: 16 bits
+ word: 32 bits

*** arm工作模式
[[file:/media/ben/reserch/document/%e8%8a%af%e7%89%87%e6%89%8b%e5%86%8c/armarchitecturereferencemanual.pdf::%25pdf-1.3%0d][armarchitectureprocessormodel]]

processor mode: 权限和资源使用

#+downloaded: /tmp/screenshot.png @ 2015-06-09 18:57:39
 [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_18:57:39.png]]

1. usr: user
2. fiq: 快速中断
3. iro: 普通中断
4. svc: supervisor
5. abt: abort
6. und: undefined
7. sys: system(v4+)


mode changes can be made using the control of sotfware, or may be
brought about by external interrupts or exception processing.(切换)

most application programs will
内核： 运行在svc模式
用户程序： 运行在usr模式

*** arm寄存器

#+downloaded: /tmp/screenshot.png @ 2015-06-09 19:04:21
 [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:04:21.png]]

+ *37 registers*
  + 31 general registers(r0-r15)
    - unbanked registers(不分组，r1-r7)
    - banked registers(分组, r8-r14)
    - r15, pc指针
  + 6 status registers
#+downloaded: /tmp/screenshot.png @ 2015-06-09 19:08:20
 [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:08:20.png]]
**** general registers
+ r13 is normally used as a stack pointer(*sp*)
+ r14 link register(*lr*)
  - 保存函数返回地址
  - 中断返回地址
+ r15 program counter(*pc*)

**** status register
cpsr & spsr


#+downloaded: /tmp/screenshot.png @ 2015-06-09 19:16:54

#+downloaded: /tmp/screenshot.png @ 2015-06-09 19:17:14
 [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:17:14.png]]

+ n: 减法操作结果
+ z: 减法相等时为1
+ i: disable irq
+ e: disable fiq
+ m[4:0]: 处理器模式

*** arm寻址方式
+ 立即数寻址： #号开头

  #+downloaded: /tmp/screenshot.png @ 2015-06-09 19:23:12
   [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:23:12.png]]
+ 寄存器寻址：

  #+downloaded: /tmp/screenshot.png @ 2015-06-09 19:24:50
  [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:24:50.png]]
+ 寄存器间接寻址：方括号

  #+downloaded: /tmp/screenshot.png @ 2015-06-09 19:25:58
  [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:25:58.png]]
+ 基址变址寻址：
  [[
  ~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:27:30.png]]
+ 相对寻址

  #+downloaded: /tmp/screenshot.png @ 2015-06-09 19:29:26
  [[~/Wally/Journal/Figures/142/screenshot_2015-06-09_19:29:26.png]]

*** arm汇编
**** arm汇编概述
***** 为什么学习汇编
+ bootloader和linux kernel初始化时需
  要使用汇编编写，一是效率高，二是还
  没有c的环境

+ 对效率有特殊要求的地方需要使用汇编

***** arm汇编分类
+ arm标准汇编：适用于arm公司的汇编器，适合在windows平台下使用，如ads
+ gnu汇编：适用于gnu交叉编译工具链中
  的汇编器，适合于linux开发平台

两种汇编相差不多，可以触类旁通

***** 汇编程序框架
#+begin_example
.section .data  ; 初始化的数据段
.section .bbs    ; 未初始化的数据段
.section .text
.global _start   ; 标记_start为全局
_start:               ; 程序入口
         <汇编>
#+end_example

+ 常见框架
  #+begin_example
  .text
  .global _start
  _start:
  #+end_example
+ 示例
  - 汇编代码
    #+begin_example
      .text
      .global _start
      _start:
          mov r1, #1
          mov r2, #2
          mov r3, #3
    #+end_example
  - makefile
    #+begin_example
      all:start.o
              arm-linux-ld -ttext 0x30000000 -o  start.elf $^
              # 写入内在之中，因此生成elf即可，写入flash中则需要生成进制文件
              # 没有使用链接器脚本，直接在makefile中指定内在地址，2440为30000000
      %.o : %.s
              arm-linux-gcc -g -o  $@ $^ -c
      clean:
              rm *.o *.elf
    #+end_example
  - todo 编写并调试简单的汇编程序

**** 指令分类学习

[[~/Wally/Journal/Figures/scrot/8571bvf.png]]

***** 算术和逻辑指令(参考资料：arm指令集.chm)
1. *mov*
   - 大小写：标准arm大写，gnu汇编小写
   - 汇编注释：@开头
   - 作用：mov 从另一个寄存器、被移位的寄存器、或一个立即值装载一个值
     到目的寄存器。
   - 格式：*mov{条件}{s}  <dest>, <op 1>*

2. *mvn*
   - mvn 从另一个寄存器、被移位的寄存器、或一个立即值装载一个值到目的
     寄存器。不同之处是在传送之前位被反转了，所以把一个被取反的值传送
     到一个寄存器中。why 取反？

   - mvn{条件}{s}  <dest>, <op 1>

   - dest = !op_1

3. *sub*
   - 做两个操作数的减法，把结果放置到目的寄存器中。

   - sbc{条件}{s}  <dest>, <op 1>, <op 2>

   - dest = op_1 - op_2 - !carry

   - 差值和被减数不能是立即数

4. *add*
   - 将把两个操作数加起来，把结果放置到目的寄存器中。操作数 1 是一个寄
     存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值

   - add{条件}{s}  <dest>, <op 1>, <op 2>

   - dest = op_1 + op_2

5. *and*
   - 将在两个操作数上进行逻辑与，把结果放置到目的寄存器中；对屏蔽你要
     在上面工作的位很有用。 操作数 1 是一个寄存器，操作数 2 可以是一个
     寄存器，被移位的寄存器，或一个立即值

   - and{条件}{s}  <dest>, <op 1>, <op 2>

   - dest = op_1 and op_2

6. *bic*
   - bic 是在一个字中清除位的一种方法，与 or 位设置是相反的操作。操作
     数 2 是一个 32 位位掩码(mask)。如果如果在掩码中设置了某一位，则清
     除这一位。未设置的掩码位指示此位保持不变。

   - bic{条件}{s}  <dest>, <op 1>, <op 2>

   - dest = op_1 and (!op_2)

   - 标准汇编中数字前缀%表示二进制，gun中使用0b前缀

***** 比较指令
1. *cmp*
   - cmp 允许把一个寄存器的内容如另一个寄存器的内容或立即值进行比较，
     更改状态标志来允许进行条件执行。它进行一次减法，但不存储结果，而
     是正确的更改标志。相减
   - cmp{条件}{p}  <op 1>, <op 2>
   - status = op_1 - op_2
2. *tst*
   - tst 类似于 cmp，不产生放置到目的寄存器中的结果。而是在给出的两个
     操作数上进行操作并把结果反映到状态标志上。按位与
   - tst{条件}{p}  <op 1>, <op 2>
***** 跳转指令
1. *b*
   - b{条件}
     #+begin_example
       示例
       mov r1, #6
       mov r2, # 5
       cmp r1, r2
       bfg branch1
       add r3, r1, r2
       b end
       branch:
           sub r3, r1, r2
       end:
       nop
       if(x>y)
           z = x-y
       else
           z = x+y
     #+end_example
2. *bl*
   - 带链接返回的跳转，即把当前地址复制到lr中，用于函数调用
     示例
     #+begin_example
       mov r1, #2
       mov r2, #3
       bl func1

       func1:
       mov r1, #2
       mov r2 , #3
       mov pc, lr  @ 函数返回
     #+end_example

***** 移位指令
1. lsl
   - logical or arithmetic shift left 逻辑算术左移
rx, lsl #n or
rx, asl #n or
rx, lsl rn or
rx, asl rn
mv r1, r1 , lss #2
ror
(rotate right) 循环右移
rx, ror #n or
rx, ror rn

***** 程序状态字访问指令
*不允许直接修改程序状态寄存器，使用专用指令，先移入通用寄存器，在通用
寄存器中修改，再写入状态寄存器*

1. *msr* （r: register, s: state）
2. *mrs*

eclipse可以监控内存
示例
#+begin_example
mrs r0, cpsr
orr r0, #0b100
msr cpsr, r0
#+end_example

***** 存储器访问指令
1. *ldr*: 内存->寄存器
2. *str*: 寄存器->内存

***** 条件执行
1. eq : 等于
   如果一次比较之后设置了 z 标志。

2. ne : 不等于
   如果一次比较之后清除了 z 标志。

3. vs : 溢出设置
   如果在一次算术操作之后设置了 v 标志，计算的结果不适合放入一个 32bit 目标寄存器中。

4. vc : 溢出清除
   如果清除了 v 标志，与 vs 相反。

5. hi : 高于(无符号)
   如果一次比较之后设置了 c 标志并清除了 z 标志。

6. ls : 低于或同于(无符号)
   如果一次比较操作之后清除了 c 标志或设置了 z 标志。

7. pl : 正号
   如果一次算术操作之后清除了 n。出于定义‘正号’的目的，零是正数的原因是它不是负数...

8. mi : 负号
   如果一次算术操作之后设置了 n 标志。

9. cs : 进位设置
   如果一次算术操作或移位操作之后设置了 c 标志，操作的结果不能表示为
   32bit。你可以把 c 标志当作结果的第 33 位。

10. cc : 进位清除
    与 cs 相反。

11. ge : 大于或等于(有符号)
    如果一次比较之后设置了 n 标志并设置了 v 标志或者清除了 n 标志并清除了 v 标志。

12. gt : 大于(有符号)
    如果一次比较之后设置了 n 标志并设置了 v 标志或者清除了 n 标志并清
    除了 v 标志并且清除了 z 标志。

13. le : 小于或等于(有符号)
    如果一次比较之后设置了 n 标志并清除了 v 标志或者清除了 n 标志并设置了 v 标志并且设置了 z 标志。

14. lt : 小于(有符号)
    如果一次比较之后设置了 n 标志并清除了 v 标志。或者清除了 n 标志并设置了 v 标志。

15. al : 总是
    缺省条件，所以不用明显声明。

16. nv : 从不
    不是特别有用，它表示应当永远不执行这个指令。是穷人的 nop。包含 nv 是为了完整性(与 al 相对)，你不应该在你的代码中使用它。
**** 伪指令
伪指令本身并没有对应的机器码，它只是在编译的时候起作用(宏定义)，或者转
化为其它的实际指令来运行(loop).
***** arm机器码
汇编程序->汇编器->机器码

elf -> objdump -> 机器码

+ 机器码为32位数
+ 被分成多个段

[[~/Wally/Journal/Figures/scrot/8571ofl.png]]

1. cond段， 31-28
   - al: 1110  # 无条件
   - eq: 0000
2. 27-26 保留位，为0
3. i位，立即数标志位， 25
   判断是否为立即数
4. opcode段，操作标志， 24-21
5. s段，20, 是否影响cpsr
6. rn 19-16
7. rd 目的寄存器 15-12
8. shifter_operand, 12位
   - 立即数有范围要求

***** 定义类伪指令
1. *global* 标明全局符号
   gnu arm前面会加一个句点 .global

2. *ascii*
   定义字符串

3. *byte*
   定义字节

4. *word*
   定义字

5. *data*
   存放在数据段
   #+begin_example
     .data
     hello:  # 需要标号
     .ascii "hello world"

     bh:
     .byte 0x1

     add:
     .word 0xff
   #+end_example

   *arm-linum-readelf* 读取elf文件信息

6. *equ*
   类似c中的宏定义
   #+begin_example
     .equ da, 0x89

     mv r0, #da
   #+end_example

7. *align* 数据地址对齐
   #+begin_example
   .align 4
   bh:
   byte 0x1
   #+end_example

***** 操作类伪指令
1. nop
   空操作，进行延时
   mv r0,  r0
2. ldr, 与存储器访问指令同名
   #+begin_example
     mov r0, #0x1ff  ; error: invalid constant
                     ; mov指令使用立即数不能超过8位

     ldr r0, =0x1ff  ; 需要使用=标明立即数, 不能用#
   #+end_example
   实现过程：将立即数先保存到内在中，然后使用ldr指令读入到寄存器中

**** 协处理器访问指令

***** 什么是协处理器

[[~/Wally/Journal/Figures/scrot/8571bpr.png]]

cp: coprecessor
协处理器， arm架构的重要组成部分，如数学协处理器控制数据处理

arm最多支持16个协处理器

cp15: provide additional registers that are used to configure and
control the caches,  mmu,  protectionn system ...
cp15 defines 16 registers

通过寄存器访问

***** 访问协处理器
1. *mcr*
   - c: coprocessor
   - r: register
2. *mrc*

[[~/Wally/Journal/Figures/scrot/8571ozx.png]]

** 51                                                                   :51:
** AVR                                                                 :avr:
*** atmel型号说明

atmel atmega系列芯片型号说明
atmegaxxx xx--xx xx
+ xxx =    8、16、48、128等芯片主型号
+ xx  =  “ p” 低电压、节能技术 ，  “ v”  1.8v-5.5v   不带“v”  2.7-5.5v ,      l   低频率
+ xx  =   20、10 代表时钟频率。
+ xx  =  规格信息：第一位代表封装 p：dip封装， a：tqfp封装， m：mlf封装 第二位字母，表示应用级别。“c”：商业级，“i”：工业级（有铅）、“u”工业级（无铅）。

例如：atmega48pv-10au
代表：atmega48  节能技术 低电压 时钟频率10  tqfp封装 工业级无

atmel attiny系列芯片型号说明
举例：attiny24-20ssu
其中attiny24为主型号
①、型号紧跟的字母，表示电压工作范围。带“v”：1.8-5.5v；若缺省，不带“v”：2.7-5.5v。
　　例：attiny24-20ssu，不带“v”表示工作电压为2.7-5.5v。
②、后缀的数字部分，表示支持的最高系统时钟。
　　例：attiny24-20ssu，“20”表示可支持最高为20mhz的系统时钟。
③、后缀第一（第二）个字母，表示封装。“p”：dip封装，“s”：sop封装，“ss”：ssop封装,“m”：mlf封装。
　　例：attiny24-20ssu，“ss”表示ssop封装。
④、后缀最后一个字母，表示应用级别。“c”：商业级，“i”：工业级（有铅）、“u”工业级（无铅）。
　　例：attiny24-20ssu，“u”表示无铅工业级。attiny24-20ssi，“i”表示有铅工业级。

**** 小结
1. atmel型号名称分为多个字段： atmega+主型号+后缀+时钟频率+封装等
2. avr单片机的型号有所改变，以上可能过时，仅做参考

*** Tutorial                                                     :tutorial:

+ [[http://www.avrvi.com/index_avr.html][AVR 教程]]
+ [[~/Wally/Reference/Textbook/AVR单片机嵌入式系统原理与应用实践.pdf][AVR单片机嵌入式系统原理与应用实践.pdf]]
+ [[http://www.ladyada.net/learn/avr/avrdude.html][Learn AVR]]

** DSP                                                                 :dsp:
*** dsp how                                                           :how:

*dsp只是工具，难得不是这个处理器，而是你在应用他时用的原理，技术。*

** FPGA                                                               :fpga:

** PLC                                                                 :plc:
* hardware                                                         :hardware:
** chip                                                               :chip:
*** 74HC573                                                       :74hc573:
**** reference

- TODO manual
- [[http://baike.baidu.com/item/74HC573][百度百科： 74HC573]]
- [[http://baike.baidu.com/view/629932.htm?fr=ala0_1_1][百度百科： 锁存器]]

**** [[http://my.oschina.net/jayzonex/blog/13579?fromerr=1K6znGs4][74HC573锁存器用法]]                                              :blog:

锁存器 介绍

如果单片机的总线接口只作一种用途，不需要接锁存器；如果单片机的总线接口
要作两种用途，就要用两个锁存器。例如：一个口要控制两个LED，对第一个
LED送数据时，“打开”第一个锁存器而“锁住”第二个锁存器，使第二个 LED
上的数据不变。对第二个 LED送数据时，“打开”第二个锁存器而“锁住”第一
个锁存器，使第一个 LED上的数据不变。如果单片机的一个口要做三种用途，则
可用三个锁存器，操作过程相似。然而在实际应用中，我们并不这样做，只用一
个锁存器就可以了，并用一根I/O 口线作为对锁存器的控制之用（接 74373的Ｌ
Ｅ，而ＯＥ可恒接地）。所以，就这一种用法而言，可以把锁存器视为单片机的
I/O 口的扩展器。


74hc573 引脚图


#+DOWNLOADED: http://my.oschina.net/uploads/space/2011/0224/141233_KOut_105484.jpg @ 2016-01-25 15:27:14
 [[~/Wally/Journal/Figure/.org-download/hardware                                                         :hardware:/141233_KOut_105484_2016-01-25_15:27:14.jpg]]



- 1脚是输出使能
- 11脚是锁存使能
- D是输入
- Q是输出
- Ｈ是高电平，L是低
- /OE是1脚 LE是11脚
- /OE 接低电平，使芯片内部数据保持器输出端与芯片8位输出端之间连通。
- LE 端的作用是通过高低电平控制8位输入与内部数据保持器输入端的连通与断
  开。
  - 当 LE = 0 时，P0端口的8位数据线与74HC573内部数据保持器的输入端断开。
  - 当 LE = 1 时，P0端口的8位数据线与74HC573内部数据保持器的输入端连通

**** 74HC573是锁存器                                      :锁存器:

#+BEGIN_EXAMPLE
- State "DONE"       from ""           [2015-11-23 一 21:11] \\
  不用了解得过于详尽，反正都会忘记的，用的时候自然就会知道。但要知道是什
  么
#+END_EXAMPLE

74HC573是拥有八路输出的透明锁存器，输出为三态门，是一种高性能硅栅CMOS
器件。

*** [[http://www.dianziaihaozhe.com/ziliao/929/][三极管8050和8550对管的参数]] :blog:


三极管805

图１　8050和

三极管805

图２　8050和8550三极管SOT-23封装外形和引脚排列

8050和8550三极管在电路应用中经常作为对管来使用，当然很多时候也作为单管应用。8050 为硅材料NPN型三极管；8550 为硅材料PNP型三极管。

8050S 8550S S8050 S8550 参数：
耗散功率0.625W（贴片：0.3W）
集电极电流0.5A
集电极--基极电压40V
集电极--发射极击穿电压25V
特征频率fT 最小150MHZ 典型值产家的目录没给出
按三极管后缀号分为 B C D档贴片为 L H档
放大倍数B85-160 C120-200 D160-300 L100-200 H200-350

C8050 C8550 参数：
耗散功率1W
集电极电流1.5A
集电极--基极电压40V
集电极--发射极击穿电压25V
特征频率fT 最小100MHZ 典型190MHZ
放大倍数：按三极管后缀号分为 B C D档
放大倍数B：85-160 C：120-200 D：160-300

8050SS 8550SS 参数：
耗散功率﻿: 1W(TA=25℃) 2W(TC=25℃)
集电极电流1.5A
集电极--基极电压40V
集电极--发射极击穿电压25V
特征频率fT 最小100MHZ
放大倍数：按三极管后缀号分为 B C D D3 共4档
放大倍数 B：85-160 C：120-200 D：160-300 D3:300-400
引脚排列有EBC ECB两种

SS8050 SS8550 参数：
耗散功率﻿: 1W(TA=25℃) 2W(TC=25℃)
集电极电流1.5A
集电极--基极电压40V
集电极--发射极击穿电压25V
特征频率fT 最小100MHZ
放大倍数：按三极管后缀号分为 B C D 共3档
放大倍数 B：85-160 C：120-200 D：160-300
引脚排列多为EBC

UTC的 S8050 S8550 引脚排列有EBC
8050S 8550S 引脚排列有ECB
这种管子很少见
参数：
耗散功率1W
集电极电流0.7A
集电极--基极电压30V
集电极--发射极击穿电压20V
特征频率fT 最小100MHZ 典型产家的目录没给出
放大倍数：按三极管后缀号分为C D E档
C：120-200 D：160-300 E：280-400

NEC的8050
最大集电极电流(A):0.5 A;
直流电增益:10 to 60;
功耗:625 mW;
最大集电极-发射极电压（VCEO）:25;
频率:150 MHz .

其它的8050
PE8050 硅 NPN 30V 1.5A 1.1W
MC8050 硅 NPN 25V 700mA 200mW 150MHz
CS8050 硅 NPN 25V 1.5A FT=190 *K
3DG8050 硅 NPN 25V 1.5A FT=190 *K
2SC8050 硅 NPN 25V 1.5A FT=190 *K

值得注意的是，在代换相应的8050或8550三极管时，除了型号匹配，放大倍数也是很重要的参数。

** sensor                                                           :sensor:
*** LED                                                               :led:
**** [[http://wiki.mbalib.com/wiki/%E5%8F%91%E5%85%89%E4%BA%8C%E6%9E%81%E7%AE%A1][发光二极管(Light Emitting Diode，LED)]]                          :blog:


***** 什么是发光二极管

*发光二极管*是指当在其整流方向施加电压(称为顺方向)时，有[[/wiki/%E7%94%B5%E6%B5%81][电流]]注入，电子与空穴复合，其一部分能量变换为光并发射的[[/wiki/%E4%BA%8C%E6%9E%81%E7%AE%A1][二极管]]。这种LED由[[/wiki/%E5%8D%8A%E5%AF%BC%E4%BD%93][半导体]]制成，属于固体元件，工作状态稳定、[[/wiki/%E5%8F%AF%E9%9D%A0%E6%80%A7][可靠性]]高，其连续通电时间(寿命)可达10^{5}h以上。^{[[#_note-0][[1]]]}

[[[/w/index.php?title=%E5%8F%91%E5%85%89%E4%BA%8C%E6%9E%81%E7%AE%A1&action=edit&section=2][编辑]]]

***** 发光二极管的参数

发光二极管的主要参数有最大工作电流/I/_{/FM/}和最大反向电压/U/_{/RM/}。

*1．最大工作电流*

最大工作电流/U/_{/RM/}是指发光二极管长期正常工作所允许通过的最大正向电流。使用中不能超过此值，否则将会烧毁发光二极管。

*2．最大反向电压*

最大反向电压/U/_{/RM/}是指发光二极管在不被击穿的前提下，所能承受的最大反向电压。发光二极管的最大反向电压/U/_{/RM/}一般在5V左右，使用中不应使发光二极管承受超过5V的反向电压，否则发光二极管将可能被击穿。

*3．其他参数*

发光二极管还有发光波长、发光强度等参数，一般使用时可不必考虑，只要选择自己喜欢的颜色和形状就可以了。


***** 发光二极管的特点与作用

发光二极管的特点是会发光。发光二极管与普通二极管一样具有单向导电性，当有足够的正向电流通过PN结时，便会发出不同颜色的可见光或红外光。

发光二极管的主要作用是指示和光发射，并可作为稳压管使用。

*1．指示*

(1)发光二极管的典型应用电路如图所示，R为限流电阻，I为通过发光二极管的正向电流。发光二极管的管压降一般比普通二极管大，为2V左右，电源电压必须大于管压降，发光二极管才能正常工作。

(2)发光二极管用于交流电源指示的电路如图所示，VD_1为整流二极管，VD_2为发光二极管，R为限流电阻，T为电源变压器。

*2．光发射*

在红外遥控器、接近开关、光电耦合器等电路中，红外发光二极管担任光发射管，电路如图所示，VT为开关调制[[/wiki/%E6%99%B6%E4%BD%93%E7%AE%A1][晶体管]]，VD为红外发光二极管。信号源通过VT驱动和调制VD，使VD向外发射调制红外光。

*3．稳压*

发光二极管可作为低电压稳压二极管使用。图所示简单并联稳压电路，利用发光二极管VD的管压降，可提供+2V的直流稳压输出。VD同时具有电源指示功能。


*4．发光*

二极管的扫描驱动需要点亮多个发光二极管时，可以采用扫描驱动的方式，以简化电路和节约电能。如图所示，电子开关将电源电压依次快速轮流接入4只发光二极管，只要轮流的速度足够快，看起来这4只发光二极管都一直在亮着。

***** 发光二级管的分类

按发光颜色分，发光二极管分为红色、橙色、绿色(又细分黄绿、标准绿和纯绿)、蓝光等。另外有的发光二极管中包含两种或三种颜色的[[/wiki/%E8%8A%AF%E7%89%87][芯片]]。根据掺或不掺散射剂、有色还是无色，又可分为有色透明、无色透明、有色散射和无色散射四种类型。散射型发光二极管常用来做指示灯。

按发光管出光面特征分为圆灯、方灯、[[/wiki/%E7%9F%A9%E5%BD%A2][矩形]]、面发光管、侧向管、表面安装用微型管等，其中圆形灯按直径分为Φ2mm、Φ4.4mm、Φ5mm、Φ8mm、Φ10mm及Φ20mm等，外形尺寸以Φ3mm、Φ5mml最为常见。国外通常把Φ3mm的发光二极管记作T-1，把Φ5mm的记作T-1(3/4)，把Φ4.4mm的记作T-1(1/4)。

按发光强度和工作电流分有普通亮度的LED(发光强度<10mcd)、超高亮度的LED(发光强度>100mcd)、高亮度的LED(发光强度在10～100mcd间)。

一般LED的工作电流在十几毫安至几十毫安，但低电流LED的工作电流在2mA以下(亮度与普通发光管相同)。

除上述分类方法外．还有按芯片材料分类及按功能分类的方法。

***** 发光二极管的应用^{[[#_note-2][[4]]]}

①电源通断指示发光二极管作为电源通断指示电路，如图所示，通常称为指示灯，在实际应用中给人提供很大的方便。发光二极管的供电电源既可以是直流的也可以是交流的，但必须注意的是．发光二极管是一种电流控制器件，应用中只要[[/wiki/%E4%BF%9D%E8%AF%81][保证]]发光二极管的正向工作电流在所规定的范围之内，它就可以正常发光。具体的工作电流可查阅有关资料。


②数码管是电子技术中应用的主要显示器件，其就是用发光二极管经过一定的排列组成的，如图(a)所示。

这是最常用的七段数码显示。要使它显示0～9的一系列数字只要点亮其内部相应的显示段即可。七段数码显示有共阳极[图(b)]和共阴极[图(c)]之分。数码管的驱动方式有直流驱动和脉冲驱动两种，应用中可任意选择。数码管应用十分广泛，可以说．凡是需要指示或读数的场合，都可采用数码管显示。

*** motor                                                           :motor:
*** 步进电机                                              :motor:stepmotor:
**** 步进电机
***** 特点
步进电机是一种将电脉冲转化为角位移的执行机构。

当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固
定的角度(称为“步距角”)，它的旋转是以固定的角度一步一步运行的。

+ 可以通过控制脉冲个数来控制角位移量，从而达到准确定位的目的；
+ 同时可以通过控制脉冲频率来控制电机转动的速度和加速度，从而达到调速的
  目的。

步进电机可以作为一种控制用的特种电机，利用其没有积累误差(精度为 100%)
的特点，广泛应用于各种开环控制。

***** 分类
现在比较常用的步进电机包括
1. 反应式步进电机（VR）

   反应式步进电机一般为三相，可实现大转矩输出，步进角一般为 1.5 度，但
   噪声和振动都很大.

   反应式步进电机的转子磁路由软磁材料制成，定子上有多相励磁绕组，利用
   磁导的变化产生转矩。

2. 永磁式步进电机（PM）

   永磁式步进电机一般为两相，转矩和体积较小，步进角一般为 7.5 度 或 15
   度.

3. 混合式步进电机（HB）
   混合式步进电机是指混合了永磁式和反应式的优点。它又分为两相和五相：
   两相步进角一般为 1.8 度而五相步进角一般为 0.72 度。这种步进电机的应
   用最为广泛，

4. 单相式步进电机

***** 参数
****** 步距角
它表示控制系统每发一个步进脉冲信号，电机所转动的角度。

电机出厂时给出了一个步距角的值，如 86BYG250A 型电机给出的值为
0.9°/1.8°（表示半步工作时为 0.9°、整步工作时为 1.8°），这个步距角
可以称之为‘电机固有步距角’，它不一定是电机实际工作时的真正步距角，真
正的步距角和驱动器有关。
****** 相数
是指电机内部的线圈组数，目前常用的有二相、三相、四相、五相步进电机。

电机相数不同，其步距角也不同，一般
+ 二相电机的步距角为 0.9°/1.8°
+ 三相的为 0.75°/1.5°
+ 五相的为 0.36°/0.72°

在没有细分驱动器时，用户主要靠选择不同相数的步进电机来满足自己步距角的
要求。如果使用细分驱动器，则‘相数’将变得没有意义，用户只需在驱动器上
改变细分数，就可以改变步距角。

****** 保持转矩(HOLDING TORQUE)
是指步进电机通电但没有转动时，定子锁住转子的力矩。

它是步进电机最重要的参数之一，通常步进电机在低速时的力矩接近保持转矩。

由于步进电机的输出力矩随速度的增大而不断衰减，输出功率也随速度的增大而
变化，所以保持转矩就成为了衡量步进电机最重要的参数之一。

比如，当人们说 2N.m 的步进电机，在没有特殊说明的情况下是指保持转矩为
2N.m 的步进电机。

**** 驱动

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{~/Tiger/Figures/1503290121.jpg}
\end{figure}


不管是两相四线，两相五线，两相六线步进电机, 内部构造都是如此。至于究竟
是四线，五线，还是六线。就要看A和~A之间，B和B~之间有没有公共端com抽线。
如果a组和b组各自有一个com端，则该步进电机六线，如果a和b组的公共端连在
一起，则是5线的。

要弄清步进电机如何接线，只需把a组和b组分开。用万用表打。

+ 四线：由于四线没有com公共抽线，所以，a和b组是绝对绝缘的，不连通的。
  所以，用万用表测，不连通的是一组。
+ 五线：由于五线中，a和b组的公共端是连接在一起的。用万用表测，当发现有
  一根线和其他几根线的电阻是相当的，那么，这根线就是公共com端。对于驱
  动五线步进电机，公共com端不连接也是可以驱动步进电机的。
+ 六线：a和b组的公共抽线com端是不连通的。同样，用万用表测电阻，发现其
  中一根线和其他两根线阻止是一样的，那么这根线是com端，另2根线就属于一
  组。对于驱动四相六线步进电机，两根公共com端不接先也可以驱动该步进电
  机的。

相关概念
+ 相数：产生不同对极N、S磁场的激磁线圈对数。常用m表示。
+ 拍数：完成一个磁场周期性变化所需脉冲数或导电状态用n表示，或指电机转
  过一个齿距角所需脉冲数，以四相电机为例，有四相四拍运行方式即
  AB-BC-CD-DA-AB，四相八拍运行方式即 A-AB-B-BC-C-CD-D-DA-A.
+ 步距角：对应一个脉冲信号，电机转子转过的角位移用θ表示。θ=360度（转子齿数J*运行拍数），以常规二、四相，转子齿为50齿电机为例。四拍运行时步距角为θ=360度/（50*4）=1.8度（俗称整步），八拍运行时步距角为θ=360度/（50*8）=0.9度（俗称半步）。
+ 定位转矩：电机在不通电状态下，电机转子自身的锁定力矩（由磁场齿形的谐
  波以及机械误差造成的）
+ 静转矩：电机在额定静态电作用下，电机不作旋转运动时，电机转轴的锁定力
  矩。此力矩是衡量电机体积（几何尺寸）的标准，与驱动电压及驱动电源等无
  关。


驱动步进电机，无非是给电机a和b组先轮流给连续的脉冲，步进电机就可以驱动
了。

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{~/Tiger/Figures/1503290149.jpg}
\end{figure}


1. 8拍的方式
   1) 在A与A-正电压，B与B-不给电悬空
   2) 在A与A-正电压，B与B-也给正电压
   3) A与A-不给电压悬空，B与B-正电压
   4) A与A-给负电压，B与B-给正电压
   5) A与A-给负电压，B与B-不给悬空
   6) A与A-给负电压，B与B-给负电压
   7) A与A-不给电悬空，B与B-给负电压
   8) A与给正电压，B与B-给负电压

   按以上八个状态轮流供电，控制一下脉宽应该就可以了。
   四个引脚各一根控制线：A~H表示各线时序
   |----+---+---+---+---+---+---+---+---|
   |    | A | B | C | D | E | F | G | H |
   |----+---+---+---+---+---+---+---+---|
   | A  | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 |
   | A- | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 |
   | B  | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
   | B- | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
   |----+---+---+---+---+---+---+---+---|

2. 4拍的方式
   一般是电流驱动的。 我下面的a~ 和b~ 表示反向电流。
   两相双二拍
   1) 正向
      + ab
      + a~b
      + a~b~
      + ab~
   2) 反向
      + ab
      + ab~
      + a~b~
      + a~b

**** 双极性与单极性驱动电路
单极性 (unipolar) 和双极性 (bipolar) 是步进电机最常采用的两种驱动架构。

单极性驱动电路使用四颗晶体管来驱动步进电机的两组相位，电机结构则如图1
所示包含两组带有中间抽头的线圈，整个电机共有六条线与外界连接。这类电机
有时又称为四相电机，但这种称呼容易令人混淆又不正确，因为它其实只有两个
相位，精确的说法应是双相位六线式步进电机。六线式步进电机虽又称为单极性
步进电机，实际上却能同时使用单极性或双极性驱动电路。



双极性步进电机的驱动电路则如图2所示，它会使用八颗晶体管来驱动两组相位。
双极性驱动电路可以同时驱动四线式或六线式步进电机，虽然四线式电机只能使
用双极性驱动电路，它却能大幅降低量产型应用的成本。双极性步进电机驱动电
路的晶体管数目是单极性驱动电路的两倍，其中四颗下端晶体管通常是由微控制
器直接驱动，上端晶体管则需要成本较高的上端驱动电路。双极性驱动电路的晶
体管只需承受电机电压，所以它不像单极性驱动电路一样需要箝位电路。

**** L6219
The L6219 is a bipolar monolithic integrated circuits intended to
control and drive both winding of a bipolar stepper motor or
bidirectionally control two DC motors.

**** 细分
***** 概念
细分的基本概念为：步进电机通过细分驱动器的驱动，其步距角变小了。

如驱动器工作在 10 细分状态时，其步距角只为‘电机固有步距角’的十分之一，
也就是：当驱动器工作在不细分的整步状态时，控制系统每发一个步进脉冲，电
机转动 1.8°；而用细分驱动器工作在 10 细分状态时，电机只转动了 0.18°。
细分功能完全是由驱动器靠精确控制电机的相电流所产生的，与电机无关.

***** 优点
步进电机的细分技术实质上是一种电子阻尼技术（请参考有关文献），其主要目的是提
高电机的运转精度，实现步进电机步距角的高精度细分。其次，细分技术的附带功能是减弱
或消除步进电机的低频振动，低频振荡是步进电机（尤其是反应式电机）的固有特性，而细
分是消除它的唯一途径，如果步进电机有时要在共振区工作（如走圆弧），选择细分驱动器
是唯一的选择。

驱动器细分后的主要优点为：
+ 完全消除了电机的低频振荡
+ 提高了电机的输出转矩，尤其是对三相反应式电机，其力矩比不细分时提高约 30-40%
+ 提高了电机的分辨率，由于减小了步距角、提高了步距的均匀度，‘提高电机
  的分辨率’是不言而喻的。

***** 技术水平
目前，国内外的步进电动机细分技术的最高微步距细分水平为 25.5″，而随着科学和工
业技术发展，这一细分水平对于目前很多要求 5″以下的微步距角来说，仍远远不能满足要
求。

*** PID                                                               :pid:

PID调节器。工程上常常用在闭环系统中加入PID环节，对系统的传递函数进行修
正，以快速的跟踪变化，消除稳态误差。

PID调节器中的P为比例环节，起放大作用。I为积分环节，可以消灭稳态误差。D
为微分环节，可以加快系统的反应。

直流电机中加入PID调节器，可以实现快速启动。当系统中突发干扰、负载变化
或者使用者主动调速是，PID环节可以帮助电机缩减过渡时间、进入新的稳定状
态。

*** 钽电容正负极                                     :cap:电容:钽电容:极性:

#+DOWNLOADED: http://c.hiphotos.baidu.com/zhidao/wh%3D600%2C800/sign=c6a0274c5bb5c9ea62a60be5e5099a38/8601a18b87d6277f6c14237f28381f30e924fc77.jpg @ 2016-02-23 13:41:52
 [[~/Wally/Journal/Figure/.org-download/Journal/8601a18b87d6277f6c14237f28381f30e924fc77_2016-02-23_13:41:51.jpg]]
*** 二极管正负极                                              :二极管:极性:

- [[http://jingyan.baidu.com/album/ceb9fb10ef5df28cad2ba0a0.html?picindex=1][百度经验]]

方法一：对于普通二极管，可以看管体表面，有白线的一端为负极。

[[/home/wally/Wally/Journal/Figure/scrot/2194lmT.png]]

方法二：对于发光二极管，引脚长的为正极，短的为负极。

[[/home/wally/Wally/Journal/Figure/scrot/2194ywZ.png]]


方法三：如果引脚被剪得一样长了，发光二极管管体内部金属极较小的是正极，
大的片状的是负极。

[[/home/wally/Wally/Journal/Figure/scrot/2194_6f.png]]

方法四：如果眼睛近视看不清，也可打开万用表，将旋钮拨到通断档，将红黑表
笔分别接在两个引脚。若有读数，则红表笔一端为正极；若读数为“1”，则黑
表笔一端为正极。

[[/home/wally/Wally/Journal/Figure/scrot/2194MFm.png]]
** supply                                                           :supply:
*** [[http://ticktick.blog.51cto.com/823160/412512/][硬件电源模块设计与思考]]                                           :blog:

最近一直搞嵌入式方面的学习，发现自己在初学嵌入式方面有着很多很多的疑问，
我想大多数没有多少经验的朋友们刚刚踏入嵌入式领域也会有着与我相同的疑问，
因此，我想在此写一系列文章，分享自己在嵌入式学习方面遇到的疑问以及心得，
希望高手们指出文章中的错误，也欢迎与我一样的初学者提出你的疑问我们一起
来学习和讨论，这样大家可以共同进步。

这里，我先简单地介绍一下嵌入式系统的电源模块的设计思路，一般是首先了解
整个系统的各个模块的电压需求，比如I/O模块一般需要3.3V供电，USB模块一般
需要5V供电，一些MCU主芯片往往需要1.2V或者1.8V供电等等，然后选择合适的
板子入口供电电压（下面第一部分主要就是讨论这个板子入口供电电压），然后
再选择相关的稳压芯片进行电压转换以及稳压（下面第二部分讲述的就是怎么样
选择稳压电路），得到板子各个模块的电压供给。那么，嵌入式系统设计中怎么
样选择板子的入口供电电压大小呢?

一、板子入口供电电压大小的选择

如今典型的板子供电往往先让220V交流电经过一个变压器，转换为直流12V或者
5V然后接入板子，当然也有其他供电电压的板子,也有直接接220V交流电并通过
板子内部电桥电路等进行转换的设计,这里我们主要讨论对12V供电和5V供电的选
择问题，即到底选择12V合适呢还是选择5V合适？

首先，我们需要先分析一下我们设计的板子的总功耗是多少（通过对分析每个模
块相关芯片的datasheet，我们可以大致的估算出整个系统的总功耗P）。那么，
在系统总功耗P一定的情况下，板子输入的供电电压U越大，由 P = U * I 可以
知道，板子的输入电流越小，而板子输入电流越小，对板子特别是电源模块的稳
定是有很大帮助的，因此，如今对于很多大功耗的板子都设计为12V供电，也就
是这样一个目的。

但是，如果整个系统的总功耗P并不大，由 P = U * I  可以知道，如果采用较
大的输入电压，板子的输入电流会变小，这样，有可能电流无法达到后级电路的
最小输入电流的要求。

因此，关于板子入口电压的选择，需要进行仔细和综合的考虑，这样才能达到比
较完美的效果。

二、 稳压电路的选择

稳压电路一般实现2个功能，一个是进行电压的转换，得到后级需要的各种电压
大小，另外一个功能顾名思义，就是稳定输出的电压，使电源模块输出给后级的
电压保持相对稳定，使整个系统能够稳定的工作。

我们知道，直流电压的转换有2种方案，一种是采用开关调压器件（switch
regulator），另一种是采用线性调压器件（linear regulator）。开关调压器
件有着更大的输出电流、更高的转换效率，但同时也伴随着更复杂的转换电路和
更高的噪声，而线性转换器件刚刚相反，有着更简单的电路以及更低的噪声。

一般，线性转换器件适合做压差不大的电压转换，比如5V到3.3V，3.3V到1.8V等，
因为，对于线性转换器而言，电压降低的那部分压差主要被用于电阻的发热了，
如果压差比较大，例如12V转5V，这7V的压差全部消耗到电阻发热，不仅电路的
效率低下，而且会产生大量的热量，导致电路不稳定或者相关芯片被烧毁。

那么，像大压差比如12V到5V的转换怎么办呢？当然，一般是采用开关调压器件，
它转换效率高，虽然有比较高的噪声，但是经过特殊的电路进行滤除一般都可以
达到系统的要求，开关调压器件的原理我就不在这里赘述了，可以在网上查找相
关资料。

以上就是我在最近学习嵌入式系统设计过程中关于电源模块设计的思考和总结，
欢迎嵌入式同行提出自己的疑问一起来探讨探讨，共同进步。

** storage                                                  :storage:memory:
*** flash                                                           :flash:
**** Nand Flash 和 Nor Flash的区别
***** 区别
NOR和NAND是现在市场上两种主要的非易失闪存技术。Intel于1988年首先开发出
NOR flash技术，彻底改变了原先由EPROM和EEPROM一统天下的局面。紧接着，
1989年，东芝公司发表了NAND flash结构，强调降低每比特的成本，更高的性能，
并且象磁盘一样可以通过接口轻松升级。但是经过了十多年之后，仍然有相当多
的硬件工程师分不清NOR和NAND闪存。

相“flash存储器”经常可以与相“NOR存储器”互换使用。许多业内人士也搞不
清楚NAND闪存技术相对于NOR技术的优越之处，因为大多数情况下闪存只是用来
存储少量的代码，这时NOR闪存更适合一些。而NAND则是高数据存储密度的理想
解决方案。

NOR的特点是芯片内执行(XIP, eXecute In Place)，这样应用程序可以直接在
flash闪存内运行，不必再把代码读到系统RAM中。NOR的传输效率很高，在1～
4MB的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响了它
的性能。

NAND结构能提供极高的单元密度，可以达到高存储密度，并且写入和擦除的速度
也很快。应用NAND的困难在于flash的管理和需要特殊的系统接口。

***** 对比
****** 性能比较
flash闪存是非易失存储器，可以对称为块的存储器单元块进行擦写和再编程。
任何flash器件的写入操作只能在空或已擦除的单元内进行，所以大多数情况下，
在进行写入操作之前必须先执行擦除。NAND器件执行擦除操作是十分简单的，而
NOR则要求在进行擦除前先要将目标块内所有的位都写为0。

由于擦除NOR器件时是以64～128KB的块进行的，执行一个写入/擦除操作的时间
为5s，与此相反，擦除NAND器件是以8～32KB的块进行的，执行相同的操作最多
只需要4ms。

执行擦除时块尺寸的不同进一步拉大了NOR和NADN之间的性能差距，统计表明，
对于给定的一套写入操作(尤其是更新小文件时)，更多的擦除操作必须在基于
NOR的单元中进行。这样，当选择存储解决方案时，设计师必须权衡以下的各项
因素。

+ NOR的读速度比NAND稍快一些。
+ NAND的写入速度比NOR快很多。
+ NAND的4ms擦除速度远比NOR的5s快。
+ 大多数写入操作需要先进行擦除操作。
+ NAND的擦除单元更小，相应的擦除电路更少。

****** 接口差别
NOR flash带有SRAM接口，有足够的地址引脚来寻址，可以很容易地存取其内部
的每一个字节。

NAND器件使用复杂的I/O口来串行地存取数据，各个产品或厂商的方法可能各不
相同。8个引脚用来传送控制、地址和数据信息。

NAND读和写操作采用512字节的块，这一点有点像硬盘管理此类操作，很自然地，
基于NAND的存储器就可以取代硬盘或其他块设备。

****** 容量和成本
NAND flash的单元尺寸几乎是NOR器件的一半，由于生产过程更为简单，NAND结
构可以在给定的模具尺寸内提供更高的容量，也就相应地降低了价格。

NOR flash占据了容量为1～16MB闪存市场的大部分，而NAND flash只是用在8～
128MB的产品当中，这也说明NOR主要应用在代码存储介质中，NAND适合于数据存
储，NAND在CompactFlash、Secure Digital、PC Cards和MMC存储卡市场上所占
份额最大。

****** 可*性和耐用性
采用flahs介质时一个需要重点考虑的问题是可*性。对于需要扩展MTBF的系统来
说，Flash是非常合适的存储方案。可以从寿命(耐用性)、位交换和坏块处理三
个方面来比较NOR和NAND的可*性。

******* 寿命(耐用性)
在NAND闪存中每个块的最大擦写次数是一百万次，而NOR的擦写次数是十万次。
NAND存储器除了具有10比1的块擦除周期优势，典型的NAND块尺寸要比NOR器件小
8倍，每个NAND存储器块在给定的时间内的删除次数要少一些。

******* 位交换
所有flash器件都受位交换现象的困扰。在某些情况下(很少见，NAND发生的次数
要比NOR多)，一个比特位会发生反转或被报告反转了。

一位的变化可能不很明显，但是如果发生在一个关键文件上，这个小小的故障可
能导致系统停机。如果只是报告有问题，多读几次就可能解决了。

当然，如果这个位真的改变了，就必须采用错误探测/错误更正(EDC/ECC)算法。
位反转的问题更多见于NAND闪存，NAND的供应商建议使用NAND闪存的时候，同时
使用EDC/ECC算法。

这个问题对于用NAND存储多媒体信息时倒不是致命的。当然，如果用本地存储设
备来存储操作系统、配置文件或其他敏感信息时，必须使用EDC/ECC系统以确保
可*性。

******* 坏块处理
NAND器件中的坏块是随机分布的。以前也曾有过消除坏块的努力，但发现成品率
太低，代价太高，根本不划算。

NAND器件需要对介质进行初始化扫描以发现坏块，并将坏块标记为不可用。在已
制成的器件中，如果通过可*的方法不能进行这项处理，将导致高故障率。

****** 易于使用
可以非常直接地使用基于NOR的闪存，可以像其他存储器那样连接，并可以在上
面直接运行代码。

由于需要I/O接口，NAND要复杂得多。各种NAND器件的存取方法因厂家而异。

在使用NAND器件时，必须先写入驱动程序，才能继续执行其他操作。向NAND器件
写入信息需要相当的技巧，因为设计师绝不能向坏块写入，这就意味着在NAND器
件上自始至终都必须进行虚拟映射。

****** 软件支持
当讨论软件支持的时候，应该区别基本的读/写/擦操作和高一级的用于磁盘仿真
和闪存管理算法的软件，包括性能优化。

在NOR器件上运行代码不需要任何的软件支持，在NAND器件上进行同样操作时，
通常需要驱动程序，也就是内存技术驱动程序(MTD)，NAND和NOR器件在进行写入
和擦除操作时都需要MTD。

使用NOR器件时所需要的MTD要相对少一些，许多厂商都提供用于NOR器件的更高
级软件，这其中包括M-System的TrueFFS驱动，该驱动被Wind River System、
Microsoft、QNX Software System、Symbian和Intel等厂商所采用。

驱动还用于对DiskOnChip产品进行仿真和NAND闪存的管理，包括纠错、坏块处理
和损耗平衡。

***** 小结
1. Nor和Nand都是闪存(*flash*)技术。
2. Nor读快写慢容量小
3. Nand写快量

*** [[http://blog.chinaunix.net/uid-20671509-id-1580312.html][存储器分类]]                                           :blog:

**** 按存储介质分

（1）半导体存储器。

存储元件由半导体器件组成的叫半导体存储器。其优点是体积小、功耗低、存取
时间短。其缺点是当电源消失时，所存信息也随即丢失，是一种易失性存储器。

半导体存储器又可按其材料的不同，分为双极型（TTL）半导体存储器和MOS半导
体存储器两种。

前者具有高速的特点，而后者具有高集成度的特点，并且制造简单、成本低廉，

功耗小、故MOS半导体存储器被广泛应用。

（2）磁表面存储器。

磁表面存储器是在金属或塑料基体的表面上涂一层磁性材料作为记录介质，工作
时磁层随载磁体高速运转，用磁头在磁层上进行读写操作，故称为磁表面存储器。

按载磁体形状的不同，可分为磁盘、磁带和磁鼓。现代计算机已很少采用磁鼓。
由于用具有矩形磁滞回线特性的材料作磁表面物质，它们按其剩磁状态的不同而
区分“0”或“1”，而且剩磁状态不会轻易丢失，故这类存储器具有非易失性的
特点。

（3）光盘存储器。

光盘存储器是应用激光在记录介质(磁光材料)上进行读写的存储器，具有非易失
性的特点。光盘记录密度高、耐用性好、可靠性高和可互换性强等。

**** 按存取方式分类

按存取方式可把存储器分为随机存储器、只读存储器、顺序存储器和直接存取存
储器四类。

（1）随机存储器RAM(Random Access Memory)。

RAM是一种可读写存储器，其特点是存储器的任何一个存储单元的内容都可以随
机存取，而且存取时间与存储单元的物理位置无关。计算机系统中的主存都采用
这种随机存储器。由于存储信息原理的不同，

RAM又分为静态RAM(以触发器原理寄存信息)和动态RAM(以电容充放电原理寄存信
息)。

（2）只读存储器ROM(Read only Memory)。

只读存储器是能对其存储的内容读出，而不能对其重新写入的存储器。这种存储
器一旦存入了原始信息后，在程序执行过程中，只能将内部信息读出，而不能随
意重新写入新的信息去改变原始信息。因此，通常用它存放固定不变的程序、常
数以及汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的
一部分，统一构成主存的地址域。

只读存储器分为掩膜型只读存储器MROM（Masked ROM）、可编程只读存储器
PROM(Programmable ROM)、可擦除可编程只读存储器EPROM(Erasable
Programmable ROM)、用电可擦除可编程的只读存储器EEPROM(Electrically
Erasable Programmable ROM)。以及近年来出现了的快擦型存储器Flash
Memory，它具有EEPROM的特点，而速度比EEPROM快得多。

（3）串行访问存储器。

如果对存储单元进行读写操作时，需按其物理位置的先后顺序寻找地址，则这种
存储器叫做串行访问存储器。显然这种存储器由于信息所在位置不同，使得读写
时间均不相同。如磁带存储器，不论信息处在哪个位置，读写时必须从其介质的
始端开始按顺序寻找，故这类串行访问的存储器又叫顺序存取存储器。还有一种
属于部分串行访问的存储器，如磁盘。在对磁盘读写时，首先直接指出该存储器
中的某个小区域(磁道)，然后再顺序寻访，直至找到位置。故其前段是直接访问，
后段是串行访问，也称其为半顺序存取存储器。

**** RAM(Random Access Memory，随机存取存储器)

RAM的特点是：电脑开机时，操作系统和应用程序的所有正在运行的数据和程序
都会放置其中，并且随时可以对存放在里面的数据进行修改和存取。它的工作需
要由持续的电力提供，一旦系统断电，存放在里面的所有数据和程序都会自动清
空掉，并且再也无法恢复。

根据组成元件的不同，RAM内存又分为以下十八种：

01.DRAM（Dynamic RAM，动态随机存取存储器）

这是最普通的RAM，一个电子管与一个电容器组成一个位存储单元，DRAM将每个
内存位作为一个电荷保存在位存储单元中，用电容的充放电来做储存动作，但因
电容本身有漏电问题，因此必须每几微秒就要刷新一次，否则数据会丢失。存取
时间和放电时间一致，约为2~4ms。因为成本比较便宜，通常都用作计算机内的
主存储器。


02.SRAM（Static RAM，静态随机存取存储器）

静态，指的是内存里面的数据可以长驻其中而不需要随时进行存取。每6颗电子
管组成一个位存储单元，因为没有电容器，因此无须不断充电即可正常运作，因
此它可以比一般的动态随机处理内存处理速度更快更稳定，往往用来做高速缓存。


03.VRAM（Video RAM，视频内存）

它的主要功能是将显卡的视频数据输出到数模转换器中，有效降低绘图显示芯片
的工作负担。它采用双数据口设计，其中一个数据口是并行式的数据输出入口，
另一个是串行式的数据输出口。多用于高级显卡中的高档内存。


04.FPM DRAM（Fast Page Mode DRAM，快速页切换模式动态随机存取存储器）

改良版的DRAM，大多数为72Pin或30Pin的模块。传统的DRAM在存取一个BIT的数
据时，必须送出行地址和列地址各一次才能读写数据。而FRM DRAM在触发了行地
址后，如果CPU需要的地址在同一行内，则可以连续输出列地址而不必再输出行
地址了。由于一般的程序和数据在内存中排列的地址是连续的，这种情况下输出
行地址后连续输出列地址就可以得到所需要的数据。FPM将记忆体内部隔成许多
页数Pages，从512B到数KB不等，在读取一连续区域内的数据时，就可以通过快
速页切换模式来直接读取各page内的资料，从而大大提高读取速度。在96年以前，
在486时代和PENTIUM时代的初期，FPM DRAM被大量使用。

05.EDO DRAM（Extended Data Out DRAM，延伸数据输出动态随机存取存储器）

这是继FPM之后出现的一种存储器，一般为72Pin、168Pin的模块。它不需要像
FPM DRAM那样在存取每一BIT数据时必须输出行地址和列地址并使其稳定一段时
间，然后才能读写有效的数据，而下一个BIT的地址必须等待这次读写操作完成
才能输出。因此它可以大大缩短等待输出地址的时间，其存取速度一般比FPM模
式快15%左右。它一般应用于中档以下的Pentium主板标准内存，后期的486系统
开始支持EDO DRAM，到96年后期，EDO DRAM开始执行。。


06.BEDO DRAM（Burst Extended Data Out DRAM，爆发式延伸数据输出动态随机
存取存储器）

这是改良型的EDO DRAM，是由美光公司提出的，它在芯片上增加了一个地址计数
器来追踪下一个地址。它是突发式的读取方式，也就是当一个数据地址被送出后，
剩下的三个数据每一个都只需要一个周期就能读取，因此一次可以存取多组数据，
速度比EDO DRAM快。但支持BEDO DRAM内存的主板可谓少之又少，只有极少几款
提供支持（如VIA APOLLOVP2），因此很快就被DRAM取代了。


07.MDRAM（Multi-Bank DRAM，多插槽动态随机存取存储器）

MoSys公司提出的一种内存规格，其内部分成数个类别不同的小储存库(BANK)，
也即由数个属立的小单位矩阵所构成，每个储存库之间以高于外部的资料速度相
互连接，一般应用于高速显示卡或加速卡中，也有少数主机板用于L2高速缓存中。


08.WRAM（Window RAM，窗口随机存取存储器）

韩国Samsung公司开发的内存模式，是VRAM内存的改良版，不同之处是它的控制
线路有一、二十组的输入/输出控制器，并采用EDO的资料存取模式,因此速度相
对较快，另外还提供了区块搬移功能（BitBlt），可应用于专业绘图工作上。


09.RDRAM（Rambus DRAM，高频动态随机存取存储器）

Rambus公司独立设计完成的一种内存模式，速度一般可以达到500~530MB/s，是
DRAM的10倍以上。但使用该内存后内存控制器需要作相当大的改变，因此它们一
般应用于专业的图形加速适配卡或者电视游戏机的视频内存中。


10.SDRAM（Synchronous DRAM，同步动态随机存取存储器）

这是一种与CPU实现外频Clock同步的内存模式，一般都采用168Pin的内存模组，
工作电压为3.3V。

所谓clock同步是指内存能够与CPU同步存取资料，这样可以取消等待周期，减少
数据传输的延迟，因此可提升计算机的性能和效率。


11.SGRAM（Synchronous Graphics RAM，同步绘图随机存取存储器）

SDRAM的改良版，它以区块Block，即每32bit为基本存取单位，个别地取回或修
改存取的资料，减少内存整体读写的次数，另外还针对绘图需要而增加了绘图控
制器，并提供区块搬移功能（BitBlt），效率明显高于SDRAM。


12.SB SRAM（Synchronous Burst SRAM，同步爆发式静态随机存取存储器）

一般的SRAM是非同步的，为了适应CPU越来越快的速度，需要使它的工作时脉变
得与系统同步，这就是SBSRAM产生的原因。


13.PB SRAM（Pipeline Burst SRAM，管线爆发式静态随机存取存储器）

CPU外频速度的迅猛提升对与其相搭配的内存提出了更高的要求，管线爆发式
SRAM取代同步爆发式SRAM成为必然的选择，因为它可以有效地延长存取时脉，从
而有效提高访问速度。


14.DDR SDRAM（Double Data Rate二倍速率同步动态随机存取存储器）

作为SDRAM的换代产品，它具有两大特点：其一，速度比SDRAM有一倍的提高；其
二，采用了DLL（Delay Locked Loop：延时锁定回路）提供一个数据滤波信号。
这是目前内存市场上的主流模式。


15.SLDRAM （Synchronize Link，同步链环动态随机存取存储器）

这是一种扩展型SDRAM结构内存，在增加了更先进同步电路的同时，还改进了逻
辑控制电路，不过由于技术显示，投入实用的难度不小。


16.CDRAM（CACHED DRAM，同步缓存动态随机存取存储器）

这是三菱电气公司首先研制的专利技术，它是在DRAM芯片的外部插针和内部DRAM
之间插入一个SRAM作为二级CACHE使用。当前，几乎所有的CPU都装有一级CACHE
来提高效率，随着CPU时钟频率的成倍提高，CACHE不被选中对系统性能产生的影
响将会越来越大，而CACHE DRAM所提供的二级CACHE正好用以补充CPU一级CACHE
之不足，因此能极大地提高CPU效率。


17.DDRII (Double Data Rate Synchronous DRAM，第二代同步双倍速率动态随
机存取存储器)

DDRII是DDR原有的SLDRAM联盟于1999年解散后将既有的研发成果与DDR整合之后
的未来新标准。DDRII的详细规格目前尚未确定。


18.DRDRAM (Direct Rambus DRAM)

是下一代的主流内存标准之一，由Rambus公司所设计发展出来，是将所有的接脚
都连结到一个共同的Bus，这样不但可以减少控制器的体积，已可以增加资料传
送的效率。

**** ROM(READ Only Memory，只读存储器)

ROM是线路最简单半导体电路，通过掩模工艺，一次性制造，在元件正常工作的
情况下，其中的代码与数据将永久保存，并且不能够进行修改。一般应用于PC系
统的程序码、主机板上的BIOS (基本输入/输出系统Basic Input/Output
System)等。它的读取速度比RAM慢很多。

根据组成元件的不同，ROM内存又分为以下五种：

1.MASK ROM（掩模型只读存储器）

制造商为了大量生产ROM内存，需要先制作一颗有原始数据的ROM或EPROM作为样
本，然后再大量复制，这一样本就是MASKROM，而烧录在MASK ROM中的资料永远
无法做修改。它的成本比较低。


2.PROM（Programmable ROM，可编程只读存储器）

这是一种可以用刻录机将资料写入的ROM内存，但只能写入一次，所以也被称为
“一次可编程只读存储器”(One Time Progarmming ROM，OTP-ROM)。PROM在出
厂时，存储的内容全为1，用户可以根据需要将其中的某些单元写入数据0(部分
的PROM在出厂时数据全为0，则用户可以将其中的部分单元写入1)，以实现对其
“编程”的目的。


3.EPROM（Erasable Programmable，可擦可编程只读存储器）

这是一种具有可擦除功能，擦除后即可进行再编程的ROM内存，写入前必须先把
里面的内容用紫外线照射它的IC卡上的透明视窗的方式来清除掉。这一类芯片比
较容易识别，其封装中包含有“石英玻璃窗”，一个编程后的EPROM芯片的“石
英玻璃窗”一般使用黑色不干胶纸盖住，以防止遭到阳光直射。


4.EEPROM（Electrically Erasable Programmable，电可擦可编程只读存储器）

功能与使用方式与EPROM一样，不同之处是清除数据的方式，它是以约20V的电压
来进行清除的。另外它还可以用电信号进行数据写入。这类ROM内存多应用于即
插即用（PnP）接口中。


5.Flash Memory（快闪存储器）

这是一种可以直接在主机板上修改内容而不需要将IC拔下的内存，当电源关掉后
储存在里面的资料并不会流失掉，在写入资料时必须先将原本的资料清除掉，然
后才能再写入新的资料，缺点为写入资料的速度太慢。

** intergrate circuit                                                   :ic:
*** [[http://www.jiancool.com/article/62041508632/][TTL]]                                                          :blog:ttl:

**** LS型TTL负载

其中“L”表示低功耗,“S”表示肖特基技术

肖特基（Schottky）二极管是一种快恢复二极管,它属一种低功耗、超高速半导
体器件。其显著的特点为反向恢复时间极短（可以小到几纳秒），正向导通压降
仅0.4V左右。肖特基（Schottky）二极管多用作高频、低压、大电流整流二极管、
续流二极管、保护二极管，也有用在微波通信等电路中作整流二极管、小信号检
波二极管使用。常用在彩电的二次电源整流,高频电源整流中。

**** TTL(逻辑门电路)

全称Transistor-Transistor Logic,即BJT-BJT逻辑门电路，是数字电子技术中
常用的一种逻辑门电路，应用较早，技术已比较成熟。TTL主要有BJT（Bipolar
Junction Transistor 即双极结型晶体管，晶体三极管）和电阻构成，具有速度
快的特点。最早的TTL门电路是74系列，后来出现了74H系列，74L系列，
74LS,74AS,74ALS等系列。但是由于TTL功耗大等缺点，正逐渐被CMOS电路取代。

**** TTL电平信号:

TTL电平信号被利用的最多是因为通常数据表示采用二进制规定，+5V等价于逻辑
“1”，0V等价于逻辑“0”，这被称做TTL（晶体管-晶体管逻辑电平）信号系统，
这是计算机处理器控制的设备内部各部分之间通信的标准技术。

TTL电平信号对于计算机处理器控制的设备内部的数据传输是很理想的，首先计
算机处理器控制的设备内部的数据传输对于电源的要求不高以及热损耗也较低，
另外TTL电平信号直接与集成电路连接而不需要价格昂贵的线路驱动器以及接收
器电路；再者，计算机处理器控制的设备内部的数据传输是在高速下进行的，而
TTL接口的操作恰能满足这个要求。TTL型通信大多数情况下，是采用并行数据传
输方式，而并行数据传输对于超过10英尺的距离就不适合了。这是由于可靠性和
成本两面的原因。因为在并行接口中存在着偏相和不对称的问题，这些问题对可
靠性均有影响。

TTL输出高电平>2.4V，输出低电平<0.4V。在室温下，一般输出高电平是3.5V，
输出低电平是0.2V。最小输入高电平和低电平：输入高电平>=2.0V，输入低电平
<=0.8V，噪声容限是0.4V。

TTL门电路是双极型集成电路，与分立元件相比，具有速度快、可靠性高和微型
化等优点。

*** 漏极开电路(OD)                                                   :开漏:

*开漏(Open Drain)* ： MOS管的 *漏极* 作为输出(*开*)
开漏电路概念中提到的“漏”就是指MOS FET的漏极。同理，开集电路中的“集”就
是指三极管的集电极。开漏电路就是指以 *MOS FET的漏极为输出的电路* 。一
般的用法是会在漏极外部的电路添加上拉电阻。完整的开漏电路应该由开漏器件
和开漏上拉电阻组成。

[[~/Tiger/Figures/scrot/18640jwg.png]]


**** [[https://www.zhihu.com/question/28512432][如何正确的理解漏极开路输出跟推挽输出？]]                        :zhihu:

***** 晶体管
要理解推挽输出，首先要理解好三极管（晶体管）的原理。下面这种三极管有三
个端口，分别是基极（Base）、集电极（Collector）和发射极（Emitter）。下
图是NPN型晶体管。

#+DOWNLOADED: https://pic4.zhimg.com/d9af63f605cbfe1d965457b3faf6607b_b.jpg @ 2016-01-26 15:05:02
 [[~/Wally/Journal/Figure/.org-download/漏极开电路(OD)                                                   :开漏:/d9af63f605cbfe1d965457b3faf6607b_b_2016-01-26_15:05:01.jpg]]


这种三极管是*电流控制*型元器件，注意关键词电流控制。意思就是说，只要基
极B有输入（或输出）电流就可以对这个晶体管进行控制了。

下面请允许我换一下概念，把基极B视为*控制端*，集电极C视为*输入端*，发射
极E视为*输出端*。这里输入输出是指电流流动的方向。

#+DOWNLOADED: https://pic1.zhimg.com/185e372b2285c626dc8a51c0a1a5b510_b.jpg @ 2016-01-26 15:05:25
 [[~/Wally/Journal/Figure/.org-download/漏极开电路(OD)                                                   :开漏:/185e372b2285c626dc8a51c0a1a5b510_b_2016-01-26_15:05:24.jpg]]

当控制端有电流输入的时候，就会有电流从输入端进入并从输出端流出。

#+DOWNLOADED: https://pic1.zhimg.com/99a21f2eb02e9878545e46fb13310048_b.jpg @ 2016-01-26 15:05:29
 [[~/Wally/Journal/Figure/.org-download/漏极开电路(OD)                                                   :开漏:/99a21f2eb02e9878545e46fb13310048_b_2016-01-26_15:05:29.jpg]]

而PNP管正好相反，当有电流从控制端流出时，就会有电流从输入端流到输出端。

#+DOWNLOADED: https://pic2.zhimg.com/d14bfdf1e5821024991f0a9e2305a9b1_b.jpg @ 2016-01-26 15:05:36
 [[~/Wally/Journal/Figure/.org-download/漏极开电路(OD)                                                   :开漏:/d14bfdf1e5821024991f0a9e2305a9b1_b_2016-01-26_15:05:35.jpg]]

***** *推挽电路*

#+DOWNLOADED: https://pic4.zhimg.com/7ef65a8673162ca1793f2efc217424c7_b.jpg @ 2016-01-26 15:05:43
 [[~/Wally/Journal/Figure/.org-download/漏极开电路(OD)                                                   :开漏:/7ef65a8673162ca1793f2efc217424c7_b_2016-01-26_15:05:43.jpg]]

上面的三极管是N型三极管，下面的三极管是P型三极管，请留意控制端、输入端
和输出端。

当Vin电压为V+时，上面的N型三极管控制端有电流输入，Q3导通，于是电流从上
往下通过，提供电流给负载。

#+DOWNLOADED: https://pic4.zhimg.com/d453959d2e0f79b7e7946990ab22c997_b.jpg @ 2016-01-26 15:05:52
 [[~/Wally/Journal/Figure/.org-download/漏极开电路(OD)                                                   :开漏:/d453959d2e0f79b7e7946990ab22c997_b_2016-01-26_15:05:52.jpg]]经过上面的N型三极管提供电流给负载（Rload），这就叫「


当Vin电压为V-时，下面的三极管有电流流出，Q4导通，有点流从上往下流过。

#+DOWNLOADED: https://pic2.zhimg.com/17b5a572b6cb664853b0ef687ccb291d_b.jpg @ 2016-01-26 15:05:58
 [[~/Wally/Journal/Figure/.org-download/漏极开电路(OD)                                                   :开漏:/17b5a572b6cb664853b0ef687ccb291d_b_2016-01-26_15:05:58.jpg]]经过下面的P型三极管提供电流给负载（Rload），这就叫「


以上，这就是*推挽（push-pull）电路*。

***** 开漏

那么什么是开漏呢？这个在我答案一开头给出的「网上资料」里讲得很详细了，我这里也简单写一下。
要理解开漏，可以先理解*开集*。

#+DOWNLOADED: https://pic3.zhimg.com/d1f2f99be3b1a3d75f3fbd11dfc36d62_b.jpg @ 2016-01-26 15:07:14
 [[~/Wally/Journal/Figure/.org-download/漏极开电路(OD)                                                   :开漏:/d1f2f99be3b1a3d75f3fbd11dfc36d62_b_2016-01-26_15:07:14.jpg]]

如图，开集的意思，就是集电极C一端什么都不接，直接作为输出端口。

如果要用这种电路带一个负载，比如一个LED，必须接一个上拉电阻，就像这样。

#+DOWNLOADED: https://pic1.zhimg.com/61588ca0d53f17ad99362cbaea4136a0_b.jpg @ 2016-01-26 15:07:21
 [[~/Wally/Journal/Figure/.org-download/漏极开电路(OD)                                                   :开漏:/61588ca0d53f17ad99362cbaea4136a0_b_2016-01-26_15:07:21.jpg]]当Vin没有电流，Q5断开时，LED亮。

当Vin没有电流，Q5断开时，LED亮。
当Vin流入电流，Q5导通时，LED灭。

开漏电路，就是把上图中的三极管换成*场效应管*（MOSFET）。
N型场效应管各个端口的名称：

#+DOWNLOADED: https://pic4.zhimg.com/27c48e18c718af409c5ebfe264452ce7_b.jpg @ 2016-01-26 15:07:29
 [[~/Wally/Journal/Figure/.org-download/漏极开电路(OD)                                                   :开漏:/27c48e18c718af409c5ebfe264452ce7_b_2016-01-26_15:07:29.jpg]]

场效应管是*电压控制*型元器件，只要对栅极施加电压，DS就会导通。

结型场效应管有一个特性就是它的输入阻抗非常大，这意味着：没有电流从控制
电路流出，也没有电流进入控制电路。没有电流流入或流出，就不会烧坏控制电
路。而双极型晶体管不同，是电流控制性元器件，如果使用开集电路，可能会烧
坏控制电路。这大概就是我们总是听到开漏电路而很少听到开集电路的原因吧？
因为开集电路被淘汰了。

*** 达林顿晶体管                                               :transistor:

达灵顿晶体管（英语： *darlington transistor* ），或称达灵顿对
（darlington pair）是电子学中由 *两个（甚至多个）双极性晶体管* （或者其他
类似的集成电路或分立元件）组成的 *复合结构* ，通过这样的结构，经第一个双极
性晶体管放大的电流可以 *进一步被放大。*

这样的结构可以提供一个比其中任意一个双极性晶体管高得多的电流增益。在使
用集成电流芯片的情况里，达灵顿晶体管可以使得芯片比使用两个分立晶体管元
件 *占用更少的空间* ，因为两个晶体管可以共用一个集极。达灵顿晶体管通常被封
装在单一的芯片里，从外面看就像一个双极性晶体管。

[[~/tiger/figures/scrot/18129dtn.png]]

+ b - 基极
+ c - 集电极
+ e - 发射极

**** 小结
成对复合晶体管，功放大，结构小

*** cap
**** 直插式电阻电容封装与尺寸图解

之前介绍过贴片式电阻电容封装与功率映射关系，本文看一下直插式电阻电容封
装尺寸，由于直插式无源器件体积普遍要比贴片式要大一些，而且直插式器件在
制作PCB时需要打孔，焊接工艺跟贴片式也有差别，较为麻烦，相对而言，直插
式电阻电容多是面向大功率电路应用。本文图文并茂，看完想不懂都难。贴片类
电容电阻请参考文章 [[http://www.metsky.com/archives/162.html][贴片电阻电容封装规格、尺寸和功率对应关系]]。

***** 一、直插式电阻封装及尺寸

直插式电阻封装为AXIAL-xx形式（比如AXIAL-0.3、AXIAL-0.4），后面的xx代表
焊盘中心间距为xx英寸，这一点在网上很多文章都没说清楚，单位为英寸。这个
尺寸肯定比电阻本身要稍微大一点点，常见的固定（色环）电阻如下图：

#+DOWNLOADED: http://www.metsky.com/upload/2010/06/201006231909526562.jpg @ 2016-01-26 14:57:30
 [[~/Wally/Journal/Figure/.org-download/cap/201006231909526562_2016-01-26_14:57:29.jpg]]

常见封装：AXIAL-0.3、AXIAL-0.4、AXIAL-0.5、AXIAL-0.6、AXIAL-0.7、AXIAL-0.8、AXIAL-0.9、AXIAL-1.0。

尺寸大小如下图（AXIAL-0.3，默认焊盘直径为62mil，其中焊孔直径为32mil）：

#+DOWNLOADED: http://www.metsky.com/upload/2010/06/201006232151557941.jpg @ 2016-01-26 14:57:53
 [[~/Wally/Journal/Figure/.org-download/cap/201006232151557941_2016-01-26_14:57:53.jpg]]


另外很多热敏、压敏、光敏、湿敏[[http://www.metsky.com/archives/393.html][电阻 ]]的封装很像个电容，或看起来根本不像个电阻器，如下图，这类电阻可以参照下文的无极电容封装来设计，比如RAD-0.2等等。

#+DOWNLOADED: http://www.metsky.com/upload/2010/06/201006231950353406.jpg @ 2016-01-26 14:58:25
 [[~/Wally/Journal/Figure/.org-download/cap/201006231950353406_2016-01-26_14:58:25.jpg]]

而可调式电阻器封装也很有特点，比如引导的独特性，很多引脚宽度也不能使用传统的圆形，一般都不能按照上述封装进行，需要遵照产品手册进行单独设计。如下图：

#+DOWNLOADED: http://www.metsky.com/upload/2010/06/201006231950305052.jpg @ 2016-01-26 14:58:29
 [[~/Wally/Journal/Figure/.org-download/cap/201006231950305052_2016-01-26_14:58:29.jpg]]

***** 二、直插式电容封装及尺寸

*1、无极电容*

常见的电容分为两种：无极电容和有极电容，典型的无极电容如下：

#+DOWNLOADED: http://www.metsky.com/upload/2010/06/201006232006443677.jpg @ 2016-01-26 14:58:40
 [[~/Wally/Journal/Figure/.org-download/cap/201006232006443677_2016-01-26_14:58:40.jpg]]

无极[[http://www.metsky.com/archives/162.html][电容 ]]封装以RAD标识，有RAD-0.1、RAD-0.2、RAD-0.3、RAD-0.4，后面的数字表示焊盘中心孔间距，如下图所示（示例RAD-0.3）。

#+DOWNLOADED: http://www.metsky.com/upload/2010/06/201006232151592616.jpg @ 2016-01-26 14:58:51
 [[~/Wally/Journal/Figure/.org-download/cap/201006232151592616_2016-01-26_14:58:51.jpg]]


*2、有极电容*

有极电容一般指电解电容，如下图：

#+DOWNLOADED: http://www.metsky.com/upload/2010/06/201006231959009924.jpg @ 2016-01-26 14:58:58
 [[~/Wally/Journal/Figure/.org-download/cap/201006231959009924_2016-01-26_14:58:58.jpg]]

下图是电解电容和固态电容图，这类电容都是标准的封装，但是高度不一定标准，包括很多定制的电容，需根据产品设计特点进行选择。图中灰白色的那种就是，很
多主板上经常吹嘘的所谓的固态电容，固态电容稳定性要稍好一点。

看下面的法拉电容也比较有意思。

#+DOWNLOADED: http://www.metsky.com/upload/2010/06/201006232001501526.jpg @ 2016-01-26 14:59:02
 [[~/Wally/Journal/Figure/.org-download/cap/201006232001501526_2016-01-26_14:59:02.jpg]]

\\

电解电容封装则以RB标识，常见封装有：RB.2/.4、RB.3/.6、RB.4/.8、RB.5/1.0，符号中前面数字表示焊盘中心孔间距，后面数字表示外围尺寸（丝印），单位仍然是英寸，如下图（RB-.3/.6）：

#+DOWNLOADED: http://www.metsky.com/upload/2010/06/201006232152048567.jpg @ 2016-01-26 14:59:05
 [[~/Wally/Journal/Figure/.org-download/cap/201006232152048567_2016-01-26_14:59:05.jpg]]

注：本文实物图来源于Google图片搜索，天缘仅做拼合整理，尺寸图来源为
Protel 99 SE抓图。

** miscellaneous
*** 公头和母头

公 : 插头中的插针的部分

母 ：插头中的插槽部分

最早是谁形容公头母头的已经无从考证 。不过英语里面也是这么叫的，公头
Male，母头Female。

为什么叫公头母头呢？因为凡事与性联系起来，就会产生无穷的想象力创造力和
传播力

针与孔， 凸与凹，公与母，插与被插 。 。。就酱紫。


#+DOWNLOADED: file:///home/wally/Download/2015-10-03%2017-08-10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png @ 2016-01-22 21:31:37
 [[~/Wally/Journal/Figure/.org-download/hardware                                                         :hardware:/2015-10-03%2017-08-10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2016-01-22_21:31:37.png]]

*** PID                                                               :pid:

pid调节器。工程上常常用在闭环系统中加入pid环节，对系统的传递函数进行修
正，以快速的跟踪变化，消除稳态误差。

pid调节器中的p为比例环节，起放大作用。i为积分环节，可以消灭稳态误差。d
为微分环节，可以加快系统的反映。

直流电机中加入pid调节器，可以实现快速启动。当系统中突发干扰、负载变化
或者使用者主动调速是，pid环节可以帮助电机缩减过渡时间、进入新的稳定状
态。

*** 12mhz的晶振多少个机器周期

1. 概念
   1) 时钟周期
      时钟周期也称为振荡周期，定义为时钟脉冲的倒数（可以这样来理解，时
      钟周期就是单片机外接晶振的倒数，例如12m的晶振，它的时间周期就是
      1/12 us），是计算机中最基本的、最小的时间单位。

   2) 机器周期
      在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，
      每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，这每一
      项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。

   3) 状态周期
      一般情况下，一个机器周期由若干个s周期（状态周期）组成。8051系列
      单片机的一个机器周期同6个s周期（状态周期）组成。前面已说过一个时
      钟周期定义为一个节拍（用p表示），二个节拍定义为一个状态周期（用s
      表示），8051单片机的机器周期由6个状态周期组成，也就是说一个机器
      周期=6个状态周期=12个时钟周期。

   4) 指令周期
      指令周期是执行一条指令所需要的时间，一般由若干个机器周期组成。指
      令不同，所需的机器周期数也不同。对于一些简单的的单字节指令，在取
      指令周期中，指令取出到指令寄存器后，立即译码执行，不再需要其它的
      机器周期。对于一些比较复杂的指令，例如转移指令、乘法指令，则需要
      两个或者两个以上的机器周期。

2. delay
   #+begin_example
      1 void delay10ms(unsigned int c)
      2 {
      3   unsigned char a, b;
      4   for(; c>0; c--){
      5     for(b=38; b>0; b--){
      6       for(a=130; a>0; a--);
      7     }
      8   }
      9 }
   #+end_example

   从计算机的角度分析， 而不要想当然；
   + l3: 定义变量a，b， 即要分配内存空间， 需要2个机器周期(2t)
   + l6: 内循环： 赋值a, 1t; 单次循环包括比较和自减2t. 完成一次外循环
     的时间为 1+130*2
   + l4: 外循环 1 + 38*（1+130*2）
   + 总时间： 2 + 1 + 38*（1+130*2）= 9912(quick-cacl)us = 9.91ms=10ms

*** [[http://blog.csdn.net/xiaoweiboy/article/details/6714199][单片机I/O口推挽输出与开漏输出的区别]]                              :blog:

推挽输出:可以输出高,低电平,连接数字器件;

开漏输出:输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行.
适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内).

推挽结构一般是指两个三极管分别受两互补信号的控制,总是在一个三极管导通
的时候另一个截止.

我们先来说说集电极开路输出的结构。集电极开路输出的结构如图1所示，右边
的那个三极管集电极什么都不接，所以叫做集电极开路（左边的三极管为反相之
用，使输入为“0”时，输出也为“0”）。对于图1，当左端的输入为“0”时，
前面的三极管截止（即集电极C跟发射极E之间相当于断开），所以5V电源通过1K
电阻加到右边的三极管上，右边的三极管导通（即相当于一个开关闭合）；当左
端的输入为“1”时，前面的三极管导通，而后面的三极管截止（相当于开关断
开）。

#+DOWNLOADED: http://www.eetop.cn/blog/attachments/2006/11/20061121_db31d8cfd1b54c04acd481b012275d2b.jpg @ 2016-01-25 14:15:46
 [[~/Wally/Journal/Figure/.org-download/Journal/20061121_db31d8cfd1b54c04acd481b012275d2b_2016-01-25_14:15:45.jpg]]

我们将图1简化成图2的样子。图2中的开关受软件控制，“1”时断开，“0”时
闭合。很明显可以看出，当开关闭合时，输出直接接地，所以输出电平为0。而
当开关断开时，则输出端悬空了，即高阻态。这时电平状态未知，如果后面一个
电阻负载（即使很轻的负载）到地，那么输出端的电平就被这个负载拉到低电平
了，所以这个电路是不能输出高电平的。

再看图三。图三中那个1K的电阻即是上拉电阻。如果开关闭合，则有电流从1K电
阻及开关上流过，但由于开关闭其它三个口带内部上拉），当我们要使用输入功
能时，只要将输出口设置为1即可，这样就相当于那个开关断开，而对于P0口来
说，就是高阻态了。

对于漏极开路（OD）输出，跟集电极开路输出是十分类似的。将上面的三极管换
成场效应管即可。这样集电极就变成了漏极，OC就变成了OD，原理分析是一样的。

另一种输出结构是推挽输出。推挽输出的结构就是把上面的上拉电阻也换成一个
开关，当要输出高电平时，上面的开关通，下面的开关断；而要输出低电平时，
则刚好相反。比起OC或者OD来说，这样的推挽结构高、低电平驱动能力都很强。
如果两个输出不同电平的输出口接在一起的话，就会产生很大的电流，有可能将
输出口烧坏。而上面说的OC或OD输出则不会有这样的情况，因为上拉电阻提供的
电流比较小。如果是推挽输出的要设置为高阻态时，则两个开关必须同时断开
（或者在输出口上使用一个传输门），这样可作为输入状态，AVR单片机的一些
IO口就是这种结构。


开漏电路特点及应用

在电路设计时我们常常遇到开漏（open drain）和开集（open
collector）的概念。

所谓开漏电路概念中提到的“漏”就是指MOSFET的漏极。同理，开集电路中的
“集”就是指三极管的集电极。开漏电路就是指以MOSFET的漏极为输出的电路。
一般的用法是会在漏极外部的电路添加上拉电阻。完整的开漏电路应该由开漏器
件和开漏上拉电阻组成。如图1所示：

#+DOWNLOADED: http://img.blog.163.com/photo/CWrVHp5T2Rn_gMeauvIbwA==/5385742204382260745.jpg @ 2016-01-25 14:17:43
 [[~/Wally/Journal/Figure/.org-download/Journal/5385742204382260745_2016-01-25_14:17:43.jpg]]


组成开漏形式的电路有以下几个特点：

1. 利用外部电路的驱动能力，减少IC内部的驱动（或驱动比芯片电源电压高的
   负载）。当IC内部MOSFET导通时，驱动电流是从外部的VCC流经R pull-up ，
   MOSFET到GND。IC内部仅需很下的栅极驱动电流。如图1。

2. 可以将多个开漏输出的Pin，连接到一条线上。形成 “与逻辑”关系。如图1，
   当PIN_A、PIN_B、PIN_C任意一个变低后，开漏线上的逻辑就为0了。这也是
   I2C，SMBus等总线判断总线占用状态的原理。如果作为输出必须接上拉电阻。
   接容性负载时，下降延是芯片内的晶体管，是有源驱动，速度较快；上升延
   是无源的外接电阻，速度慢。如果要求速度高电阻选择要小，功耗会大。所
   以负载电阻的选择要兼顾功耗和速度。

3. 可以利用改变上拉电源的电压，改变传输电平。如图2,IC的逻辑电平由电源
   Vcc1决定，而输出高电平则由Vcc2（上拉电阻的电源电压）决定。这样我们
   就可以用低电平逻辑控制输出高电平逻辑了（这样你就可以进行任意电平的
   转换）。（例如加上上拉电阻就可以提供TTL/CMOS电平输出等。）

   #+DOWNLOADED: http://img.blog.163.com/photo/EIqHbVf0m6bd6V2z3VX4iA==/5385742204382260744.jpg @ 2016-01-25 14:18:55
   [[~/Wally/Journal/Figure/.org-download/Journal/5385742204382260744_2016-01-25_14:18:55.jpg]]

4. 开漏Pin不连接外部的上拉电阻，则只能输出低电平(因此对于经典的51单片
   机的P0口而言，要想做输入输出功能必须加外部上拉电阻，否则无法输出高
   电平逻辑)。一般来说，开漏是用来连接不同电平的器件，匹配电平用的。

5. 标准的开漏脚一般只有输出的能力。添加其它的判断电路，才能具备双向输入、输出的能力。

6. 正常的CMOS输出级是上、下两个管子，把上面的管子去掉就是OPEN-DRAIN了。
   这种输出的主要目的有两个：电平转换、线与。

7. 线与功能主要用于有多个电路对同一信号进行拉低操作的场合，如果本电路
   不想拉低，就输出高电平，因为OPEN-DRAIN上面的管子被拿掉，高电平是靠
   外接的上拉电阻实现的。（而正常的CMOS输出级，如果出现一个输出为高另
   外一个为低时，等于电源短路。）

8. OPEN-DRAIN提供了灵活的输出方式，但是也有其弱点，就是带来上升沿的延
   时。因为上升沿是通过外接上拉无源电阻对负载充电，所以当电阻选择小时
   延时就小，但功耗大；反之延时大功耗小。所以如果对延时有要求，则建议
   用下降沿输出。


应用中需注意：
1. 开漏和开集的原理类似，在许多应用中我们利用开集电路代替开漏电路。例
   如，某输入Pin要求由开漏电路驱动。则我们常见的驱动方式是利用一个三极
   管组成开集电路来驱动它，即方便又节省成本。如图3。

   #+DOWNLOADED: http://img.blog.163.com/photo/X_TpSikFBZLkYIzLqNZR1A==/5385742204382260743.jpg @ 2016-01-25 14:20:06
   [[~/Wally/Journal/Figure/.org-download/Journal/5385742204382260743_2016-01-25_14:20:06.jpg]]

2. 上拉电阻Rpull-up的阻值决定了逻辑电平转换的沿的速度。阻值越大，速度
   越低功耗越小。反之亦然。
   Push-Pull输出就是一般所说的推挽输出，在CMOS电路里面应该较CMOS输出更
   合适，因为在CMOS里面的push－pull输出能力不可能做得双极那么大。输出
   能力看IC内部输出极N管P管的面积。和开漏输出相比，push－pull的高低电
   平由IC的电源低定，不能简单的做逻辑操作等。push－pull是现在CMOS电路
   里面用得最多的输出级设计方式。
   当然open drain也不是没有代价，这就是输出的驱动能力很差。输出的驱动
   能力很差的说法不准确，驱动能力取决于IC中的末级晶体管功率。OD只是带
   来上升沿的延时，因为上升沿是通过外接上拉无源电阻对负载充电的，当电
   阻选择小时延时就小、但功耗大，反之延时大功耗小。OPEN

   DRAIN提供了灵活的输出方式，但也是有代价的，如果对延时有要求，建议用
   下降沿输出。

   电阻小延时小的前提条件是电阻选择的原则应在末级晶体管功耗允许范围内，
   有经验的设计者在使用逻辑芯片时，不会选择1欧姆的电阻作为上拉电阻。在
   脉冲的上升沿电源通过上拉无源电阻对负载充电，显然电阻越小上升时间越
   短，在脉冲的下降沿，除了负载通过有源晶体管放电外，电源也通过上拉电
   阻和导通的晶体管对地形成通路，带来的问题是芯片的功耗和耗电问题。电
   阻影响上升沿，不影响下降沿。如果使用中不关心上升沿，上拉电阻就可选
   择尽可能的大点，以减少对地通路的电流。如果对上升沿时间要求较高，电
   阻大小的选择应以芯片功耗为参考。

*** [[http://www.cnblogs.com/MuyouSome/p/3175806.html][时钟周期、振荡周期、机器周期、CPU周期、状态周期、指令周期、总线周期、任务周期]] :blog:


计算机系统有一系列的“周期”概念，区别、联系地理解这些概念至关重要。以下对*时钟周期、振荡周期、机器周期、CPU周期、状态周期、指令周期、总线周期、任务周期*进行简单介绍。

*周期*

在电子技术中，脉冲信号是一个按一定电压幅度，一定时间间隔连续发出的脉冲信号。脉冲信号之间的时间间隔称为周期；而将在单位时间（如1秒）内所产生的脉冲个数称为频率。频率是描述周期性循环信号（包括脉冲信号）在单位时间内所出现的脉冲数量多少的计量名称；频率的标准计量单位是Hz（赫）。电脑中的系统时钟就是一个典型的频率相当精确和稳定的脉冲信号发生器。



*时钟周期*

时钟周期，一般也称振荡周期（如果晶振的输出没有经过分频就直接作为cpu的工作时钟，则时钟周期就等于振荡周期），即CPU的晶振的工作频率的倒数，是计算机中最基本的、最小的时间单位。通常成为节拍脉冲或者T周期。对于单片机时钟周期，时钟周期是单片机的基本时间单位，*两个振荡周期(时钟周期)组成一个状态周期。*



*振荡周期*（oscillating period）

在衰减振荡中，两个相邻同方向峰值之间的时间称为振荡周期Tp，振荡频率2π/Tp。在相同衰减比下，振荡周期越短或振荡频率越高，则回复时间越短，因此振荡周期(频率)反映系统响应快慢的指标。



*机器周期*

机器周期，一般也叫CPU周期。在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段（如，取指令、存储器读、存储器写等），每一阶段完成一项工作（称为一个基本操作）。完成一个基本操作所需要的时间称为机器周期。一般情况下，一个机器周期由若干个S周期（状态周期）组成。



*CPU周期*

又称机器周期，CPU周期定义为从内存读取一条指令字的最短时间。一个指令周期常由若干CPU周期构成。



*状态周期*

在8051单片机中把一个时钟周期定义为一个节拍（用P表示），二个节拍定义为一个状态周期（用S表示）。

8051系列单片机的一个机器周期同6个S周期（状态周期）组成。一个机器周期包含6个状态周期（S1-S6）,而一个状态周期又包含两个时钟振荡周期（简称时钟周期）。例：8051单片机的机器周期由6个状态周期组成，也就是说一个机器周期=6个状态周期=12个时钟周期。



*指令周期*

指令周期是执行一条指令所需要的时间，即CPU从内存取出一条指令并执行这条指令的时间总和。一般由若干个机器周期组成，从取指令、分析指令到执行完所需的全部时间。指令不同，所需的机器周期数也不同。对于一些简单的的单字节指令，在取指令周期中，指令取出到指令寄存器后，立即译码执行，不再需要其它的机器周期。对于一些比较复杂的指令，例如转移指令、乘法指令，则需要两个或者两个以上的机器周期。通常含一个机器周期的指令称为单周期指令，包含两个机器周期的指令称为双周期指令。



*总线周期*

总线周期通常指的使通过总线完成一次内存读写操作或完成一次输入输出设备的读写操作所必须的时间。由于存储器和I/O端口是挂接在总线上的，CPU对存储器和I/O接口的访问，是通过总线实现的。通常把CPU通过总线对微处理器外部（存储器或I/O接口）进行一次访问所需时间称为一个总线周期。一个总线周期一般包含4个时钟周期，这4个时钟周期分别称4个状态即T1状态、T2状态、T3状态和T4状态。



*任务周期*


周期任务是指计算机系统按一定周期达到并请求运行，每次请求称为任务的一个任务实例，任务实例所属任务的起始时刻称为该任务实例的到达时刻，任务实例被置为就绪态的时刻称为该任务实例的释放时刻。

*** [[http://www.51hei.com/dianzi/300.html][晶振的作用与原理]]       :blog:


每个单片机系统里都有晶振，全程是叫晶体震荡器，在单片机系统里晶振的作用非常大，他结合单片机内部的电路，产生单片机所必须的时钟频率，单片
机的一切指令的执行都是建立在这个基础上的，晶振的提供的时钟频率越高，那单片机的运行速度也就越快。

晶振用一种能把电能和机械能相互转化的晶体在共振的状态下工作，以提供稳定，精确的单频振荡。在通常工作条件下，普通的晶振频率绝对精度可达百万分之
五十。高级的精度更高。有些晶振还可以由外加电压在一定范围内调整频率，称为压控振荡器（VCO）。

晶振的作用是为系统提供基本的时钟信号。通常一个系统共用一个晶振，便于各部分保持同步。有些通讯系统的基频和射频使用不同的晶振，而通过电子调整频
率的方法保持同步。

晶振通常与锁相环电路配合使用，以提供系统所需的时钟频率。如果不同子系统需要不同频率的时钟信号，可以用与同一个晶振相连的不同锁相环来提供。

晶振一般采用如图1a的电容三端式(考毕兹) 交流等效振荡电路；实际的晶振交流等效电路如图1b，其中Cv是用来调节振荡频率，一般用变容二极管加上不
同的反偏电压来实现，这也是压控作用的机理；把晶体的等效电路代替晶体后如图1c。其中Co，C1，L1，RR是晶体的等效电路。


分析整个振荡槽路可知，利用Cv来改变频率是有限的：决定振荡频率的整个槽路电容C=Cbe,Cce,Cv三个电容串联后和Co并联再和C1串联。可以看出：C1越小，
Co越大，Cv变化时对整个槽路电容的作用就越小。因而能“压控”的频率范围也越小。实际上，由于C1很小(1E-15量级)，Co不能忽略(1E-12量级，几PF)。所以，
Cv变大时，降低槽路频率的作用越来越小，Cv变小时，升高槽路频率的作用却越来越大。这一方面引起压控特性的非线性，压控范围越大，非线性就越厉害；另
一方面，分给振荡的反馈电压(Cbe上的电压)却越来越小，最后导致停振。采用泛音次数越高的晶振，其等效电容C1就越小；因此频率的变化范围也就越小。

微控制器的时钟源可以分为两类：基于机械谐振器件的时钟源，如晶振、陶瓷谐振槽路；RC（电阻、电容）振荡器。一种是皮尔斯振荡器配置，适用于晶振
和陶瓷谐振槽路。另一种为简单的分立RC振荡器。

用万用表测量晶体振荡器是否工作的方法：测量两个引脚电压是否是芯片工作电压的一半，比如工作电压是51单片机的+5V则是否是2.5V左右。另外如果用镊
子碰晶体另外一个脚，这个电压有明显变化，证明是起振了的。

晶振的类型有SMD和DIP型，即贴片和插脚型。

先说DIP：常用尺寸有HC-49U/T，HC-49S，UM-1，UM-5，这些都是MHZ单位的。

再说SMD：有0705，0603，0503，0302，这里面又分四个焊点和二个焊点的，对我们公司来说默认的是四个焊点的，两个焊点的材料要求进口，周期长，一般
说两个焊点的做不了。

* interface
** J-Link                                                            :jlink:
*** openjtag                                                     :openjtag:
**** about

open jtag project is an *open source hardware and software* for a
*high speed usb jtag tool*.

in this site, you can find and download all necesary files to make
your jtag device. the electric schematics, the pcb design including
gerber files, the vhdl project in altera quartus ii format, and the
c++ examples in microsoft visual studio 2005, are free to be
downloaded

**** resources
+ [[http://www.openjtag.org/][homepage]]

*** [[http://blog.csdn.net/lithocntlor/article/details/7713511][JTag, JLink及OpenJtag的比较]]                        :blog:jtag:openjtag:


本文简单介绍了JTag,
JLink及OpenJTag的用途，以及区别。同时也介绍了开发机没有并口时，该选择
何种工具进行烧写。所有资料均从网上搜罗而来。

**** JTag

JTag(Joint Test Action Group) 是IEEE1149.1 （Standard Access Port and
Boundary-Scan Architecture)标准.

它最初用来以边界扫描的方式测试印刷电路板，当然它现在仍然这一方面广泛使
用。

JTag的用途：

1. 边界扫描测试
2. 往Flash烧写程序和数据： 可以烧写Nor Falsh 和 Nand Falsh
3. 调试ARM裸机程序，不能调试嵌入式Linux程序


JTag的接口：

JTag接口并没有统一的标准。ARM处理器通常使用2＊10针（部分使用2＊7针）的
JTag接口。

JTag连接Host的一端通常为并口。一般笔记本及台式机都很少有并口接口，而且
市面上买到的USB转并口并不能用于JTag，USB转并口主要是给老式打印机使用的。
这就使得我们很难使用JTag以及笔记本进行烧写。另外的一个缺点是并口JTag的
速率非常低。


JTag的替代品：

Serial Wire Debug（SWD）。

**** JLink

JLink是Segger的产品，[[http://www.segger.com/jlink.html][http://www.segger.com/jlink.html]] 。它是USB接口转
到JTag接口的适配器（adaptor)，并不是真正意义上的仿真器。它采用标准的14
针或者20针的Jtag接口与开发板相连。它支持多种CPU内核（ARM7，

ARM9，Cortex etc.）。对ARM而言，它可能是最受欢迎的适配器。

JLink的功能：
1. 往Flash烧写程序：不支持烧写NAND Flash 参见
   [[http://www.segger2.com/index.php?page=Thread&threadID=144][http://www.segger2.com/index.php?page=Thread&threadID=144]]

2. 支持Windows, Linux以及Mac： 但是Linux及Mac仅支持JLink Commander,
   Command Line GdbServer, 以及shared library。

3. 支持多种调试协议： 如GDB， RDI 等

4. USB转串口功能

JLink的接口：

USB接口，JLink的价格也比较低（当然是山寨的）。

**** OpenJTag

OpenJTag是一个开源项目（包含软件和硬件），采用GNU GPLlicense：
[[http://www.openjtag.org/][http://www.openjtag.org/]] 。同样它也是一个USB接口转JTag接口的适配器，同
样不是真正意义上的仿真器。

OpenJTag的功能：

1. 往Flash烧写程序： 支持NOR Flash 和 NAND Flash

2. 支持Windows以及Linux

3. 能够用在支持GDB调试协议的工具上： 如IAR， Eclipse，但不能用在支持
   RDI调试协议的工具上： 如ADS

4. USB转串口功能

OpenJtag的接口：

USB接口，但是他的价格要比JLink高一些。

** isp                                                                 :isp:
*** 在线刻录(isp)                                                     :isp:

 isp 即(in-system programming)在系统可编程，指电路板上的空白器件可以编
 程写入最终用户代码， 而不需要从电路板上取下器件，已经编程的器件也可
 以用isp 方式擦除或再编程

*** usbisp & usbasp                                         :usbisp:usbasp:
**** usbasp

USBasp is a USB in-circuit programmer for Atmel AVR controllers. It
simply consists of an ATMega88 or an ATMega8 and a couple of passive
components. The programmer uses a firmware-only USB driver, no special
USB controller is needed.

[[http://www.fischl.de/usbasp/][fischl:usbasp]] 官网可下载 固件、原理图及PCB


#+DOWNLOADED: file://~/Wally/Journal/Figures/usbasp_circuit.png @ 2015-12-05 14:36:13
 [[~/Wally/Journal/Figures/日事日毕/usbasp_circuit_2015-12-05_14:36:13.png]]

**** 联系与区别

*谷歌搜索不到 usbisp 的英文资料， avrdude中也没有对 usbisp 的直接支持。*

1. USBISP与USBASP分别是2个德国人的设计,在硬件上基本兼容,但内核软件有不
   同,尽管低层USB都采用开源代码,但上层支持协议不同.USBISP是STK500v2
   conpatible (direct from AVR-Studio useable) 的,直接在AVR STUDIO中支
   持和使用.而USBASP需要使用专用的编程软件.另外ASPISP的更新比USBASP快.

2. 这两者硬件电路相同，固件程序不同；

3. 两者使用的烧录软件不同，USBISP是模拟STK500下载线，所以可以使用AVR
   Stduio开发环境来下载烧录程序；而USBASP不能用AVR Stduio，但是现在网
   上很多支持USBASP的软件，比如PROGISP,AVR flater等。

4. USBISP与并口ISP(STK200/STK300)的比较并口ISP(STK200/STK300)下载线需
   要PC带真正的LPT口,在ICC、CVAVR、BASCOM-AVR中可以直接使用。USBISP使
   用USB口，只能在AVR STUDIO中使用（其它支持的不稳定）USBISP速度稍为慢
   一点（M8模拟USB）

**** reference

+ [[chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/js/main/generateUrlWithTempToken.html?baseUrl=https%3A%2F%2Fapp.yinxiang.com&targetUrl=%2Fshard%2Fs52%2Fnl%2F11551545%2F707ecdc3-6ae1-492d-99d8-6ecdd0215315%2F][USBISP与USBASP]]
+ [[http://www.fischl.de/usbasp/][fischl:usbasp]]

*** 自制USB AVR烧录器:
http://mitchcircuit.wordpress.com/2008/03/13/usbasp-diy/

*** [[http://www.winterland.me/2014/02/28/usbasp-update-firmware/index.html][USBASP固件更新]]

寒假的时候在淘宝上买了两个USBASP下载器，打算用来给 [[http://www.winterland.me/wifi-duino/][WiFi-Duino]] 批量下载固件使用。

和Arduino的JTAG转ISP转换头：

收到东西之后发现电路设计和 [[http://www.fischl.de/usbasp/][公版]] 一模一样，但是固件却不大相同，出于好奇，
买的两只USBASP分别是免驱动的和需要安装驱动的，后来了解到公版的USBASP都
是需要驱动的，免驱型的需要配合特定的烧写软件才能使用，而到货的这个需要
驱动的USBASP，下载时总是提示：

#+BEGIN_EXAMPLE
    avrdude: warning: cannot set sck period. please check for usbasp firmware update.
#+END_EXAMPLE

提示需要更新固件，烧写程序还是没问题的。本来想把那个非公版的USBASP退掉，
然后用别的方法把公版的USBASP固件更新掉，但是看了下JTAG接口线的定义之后，
想到了一个更简单的解决方法:

你没看错，这是把两个USBASP连起来的节奏 : )

JTAG的编程接口用到的是SPI和RESET信号，MISO对MISO，MOSI对MOSI，RESET对
RESET，正好满足了下载固件的条件，使用公版固件的USBASP给另一个烧写程序
即可，不过在这之前要把被烧写的USBASP置为自编程状态（也就是RESET信号由
IO输出改为输入到MCU的RESET引脚），再对比电路图和PCB之后，发现原来自编
程跳线就是标着UP的两个焊盘：

接下来去 [[http://www.fischl.de/usbasp/][公版官网]] 下载最新的固件，使用avrdude或者其他你觉得好用的GUI把
固件下载到USBASP里即可，顺便推荐一个linux下面格外好用的avrdude的GUI：
[[https://github.com/zkemble/AVRDUDESS][avrdudess]]。

然后同样的方法，将另一个USBASP的固件更新到最新版本。便拥有了两个公版的
USBASP...

*** usbasp 访问权限设置                                      :avrdude:udev:

linux下面使用USBASP是不用安装驱动的，但是需要注意更改一下USB设备的
访问权限（除非每次都用sudo运行avrdude），否则会提示：

#+BEGIN_EXAMPLE
    avrdude: error: could not find USB device "USBasp" with vid=0x16c0 pid=0x5dc
#+END_EXAMPLE

解决方法是手动添加udev项目：

#+BEGIN_EXAMPLE
    sudo gedit /etc/udev/rules.d/99-usbasp.rules
#+END_EXAMPLE

贴入如下内容：

#+BEGIN_EXAMPLE
    # USBasp - USB programmer for Atmel AVR controllers
    SUBSYSTEM=="usb", ATTR{product}=="USBasp", ATTR{idProduct}=="05dc", ATTRS{idVendor}=="16c0", MODE="0666"
#+END_EXAMPLE

Close & Save, Reboot 即可。

*** [[http://blackstufflabs.com/2013/10/24/aggiornare-firmware-usbasp-con-arduino/?lang=zh][使用 Arduino 更新固件USBASP]]

我发生过几次，有问题，我的USBASP, 我偶然读到这个错误在监视器:

#+BEGIN_EXAMPLE
“AVRDUDE: 警告: 不能设置SCK周期. 请检查的usbasp固件更新”.
#+END_EXAMPLE

关于菲施尔网站 ([[http://www.fischl.de/usbasp/]])

我是能够找到所需的所有文件，升级设备, 包括最新的固件 [[http://www.fischl.de/usbasp/usbasp.2011-05-28.tar.gz][usbasp.2011-05-28.tar.gz]]

但如何编程的程序员!?

有两条路:

1. 使用第二个程序员的 (另一个USBASP例如)
2. 联合国的Arduino

不具有第二USBASP, 作为一个程序员，最简单的方法是使用Arduino的.

好, Arduino的可以用来作为一个程序员... 你知道吗?


#+DOWNLOADED: file:///home/wally/Desktop/%E6%9B%B4%E6%96%B0%E5%9B%BA%E4%BB%B6USBASP%E4%B8%8EArduino%20%20%E9%BB%91%E8%89%B2%E7%9A%84%E4%B8%9C%E8%A5%BF%E5%AE%9E%E9%AA%8C%E5%AE%A4_files/Image.jpg @ 2016-01-26 15:57:34
 [[~/Wally/Journal/Figure/.org-download/更新固件USBASP与Arduino/Image_2016-01-26_15:57:34.jpg]]

通过Arduino的dell'USBasp的固件进行更新的步骤如下:

1. Aprite您的Arduino IDE, 您的阿尔杜伊诺素描ArduinoISP的与闪过(文件>示
   例>ArduinoISP).

2. Mettete in corto lo Jumper JP2 (在一些旧版本的跳线R8)Vostro成就
   USBASP,以便使自编程模式.

3. 连接您的的Arduino的栖息dell'USBasp的如下:

   #+BEGIN_EXAMPLE
     阿都伊诺 -- USBASP
      5V ---- 2
      GND --- 10
      13 ---- 7 (SCK)
      12 ---- 9 (MISO)
      11 ---- 1 (MOSI)
      10 --- 5 (复位)
   #+END_EXAMPLE

    [[~/Wally/Journal/Figure/.org-download/更新固件USBASP与Arduino/Image%20%5B1%5D_2016-01-26_15:58:55.png]]

   #+DOWNLOADED: file:///home/wally/Desktop/%E6%9B%B4%E6%96%B0%E5%9B%BA%E4%BB%B6USBASP%E4%B8%8EArduino%20%20%E9%BB%91%E8%89%B2%E7%9A%84%E4%B8%9C%E8%A5%BF%E5%AE%9E%E9%AA%8C%E5%AE%A4_files/Image%20%5B1%5D.jpg @ 2016-01-26 15:57:57
    [[~/Wally/Journal/Figure/.org-download/更新固件USBASP与Arduino/Image%20%5B1%5D_2016-01-26_15:57:57.jpg]]

4. 下载并安装AVRDUDESS的 ([[http://blog.zakkemble.co.uk/avrdudess-a-gui-for-avrdude/]])

5. 请点击这种方式的可执行文件和设置参数:

   - 程序员 > 阿都伊诺
   - MCU > Atmega8的 (假设您的USBASP ATmega8的)
   - 端口 > COM3 (取决于你的电脑哪个端口上连接到Arduino的)
   - 波特率 > 19200
   - 档 > 闪光 > 选择你的固件。六角闪光

它应该是这样或多或少:



#+DOWNLOADED: file:///home/wally/Desktop/%E6%9B%B4%E6%96%B0%E5%9B%BA%E4%BB%B6USBASP%E4%B8%8EArduino%20%20%E9%BB%91%E8%89%B2%E7%9A%84%E4%B8%9C%E8%A5%BF%E5%AE%9E%E9%AA%8C%E5%AE%A4_files/Image%20%5B2%5D.png @ 2016-01-26 15:59:25
 [[~/Wally/Journal/Figure/.org-download/更新固件USBASP与Arduino/Image%20%5B2%5D_2016-01-26_15:59:25.png]]


6. 按 “START!” 并交叉手指...

*** [[http://blog.sina.com.cn/s/blog_605f124c0100dzsz.html][AT89S52最小系统和isp并口下载线]]                           :blog:at89s52:


一 最小系统

[[http://photo.blog.sina.com.cn/showpic.html#blogid=605f124c0100dzsz&url=http://s14.sinaimg.cn/orignal/605f124cx6b450b08fe8d&690][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]

小结：复位电路可以暂时省掉，在p1.0接发光二极管的阴极，阳极接5v高电平，确保最小系统可以用，用同学买的实验板下载一测试程序，让接P1.0的发光二极管闪起来。如果可以闪哪么最小系统搭建成功，再接上复位电路。

二 isp下载线

[[http://photo.blog.sina.com.cn/showpic.html#blogid=605f124c0100dzsz&url=http://s4.sinaimg.cn/orignal/605f124cx6b4528355423&690][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]

1、MOSI:数据串行输出 （S51 P1.5脚）， MISO:串行数据输入（S51 P1.6脚），
，SCK:同步控制时钟（S51
P1.7脚），RST接单片机复位脚（当有足够的高电平使S51处于复位状态，它就会开启读写程序功能），
LE:器件的锁存允许，OE:器件的输出允许

2、并口各针脚的功能。
2,3,4,5,6,7,8,9为数据口,可读可写;1,14,16,17为控制口,可读可写;10,11,12,13,15为状态口,只读.18-25接地。

3，目前电脑主要有三种类型的并口：Normal、EPP、ECP。

Normal口是一种低速的并口模式，适合将结果输出送到打印机上。又分为4bit、8bit、半8bit等几类。

EPP口(EnhancedParallelPort)：增强并行口。Intel、Xircom、Zenith和其它一些公司开发的，目的是在外部设备间进行双向通信。自1991年开始笔记本电脑率先配备有EPP口。

ECP口(ExtendedCapabilitiesPort)：扩展并行口。Intel和其它公司开发出EPP口的同时，Microsoft和Hewlett-Packard也开发了一种被称为ECP(扩展并行口)的接口规格。它具有和EPP一样高的速率和双向通信能力，但在多任务环境下，它能使用DMA(直接存储器访问)方式，所需缓冲区也不大。

<1>电脑bios设置：port设置Normal
address设置378（和下载软件对应即可如下图）[[http://photo.blog.sina.com.cn/showpic.html#blogid=605f124c0100dzsz&url=http://s10.sinaimg.cn/orignal/605f124cx6b453ba266a9&690][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]

<2>软件设置：我用的isp v1.3
主要是下载线配置文件根据上面的下载线电路原理图进行设置

;----------------------------EasyIsp-2的引脚定义-------------------------

[引脚控制]
 MOSI=2
 MISO=15
 SCK=5
 RST=16
 LE=17
 OE=1
 R1=3
 R2=4

[锁存控制(LE)]
 Enable=1
 Disable=1

 [输出控制(OE)]
 Enable=0
 Disable=1



;-------------------------------------说明--------------------------------
 ;  --引脚控制--
 ;
你可以定义下载线所使用的并口引脚，只要设置对应的引脚号即可。
 ;  MOSI:数据串行输出  MISO:串行数据输入  SCK:同步控制时钟
 ;  RST:复位  LE:器件的锁存允许  OE:器件的输出允许
 ;  R1,R2:保留为以后扩展用
 ;  注意:18-25引脚都接地
2,3,4,5,6,7,8,9为数据口,可读可写;1,14,16,17为控制
 ;  口,可读可写;10,11,12,13,15为状态口,只读.
 ;  如果引脚=0,表示该引脚无效,不作控制,例如74244的OE=0.
 ;
 ;  --锁存控制--
 ;  如果器件有LE,例如74373的LE,高电平有效低电平无效.所以可以Enable=1
 ;
Disable=0,如果Enable=1,Disable=1,表示LE引脚恒为高电平,Enable=0,Disable=0,
 ;  表示LE引脚恒为低电平
 ;
 ;  --输出控制--

 三 联机 下载

不知道是电源不稳定还是下载线过长（有1.0米）isplay v1.3无法检测到器件
但是可以进行读写擦除 跑马灯根据下载的程序闪起来 还是很爽的 呵呵！

*** [[http://www.waveshare.net/txt/AVR_ISP_Interface.htm][AVR ISP接口定义]]                                              :blog:avr:

AVR的ISP接口是如何定义的？

大部分AVR MCU的ISP数据端口亦为 SCK、MOSI、MISO引脚（如Attiny13/24/2313，Atmega48/88/168，Atmega16/32/162，Atmega8515/8535等），如下：

ISP下载器   AVR端口                  备注
   端口
   MISO       MISO
   VCC        VCC
   SCK        SCK
   MOSI       MOSI
  RESET      RESET
   GND        GND

少部分AVRMCU的ISP数据端口则不是使用这些接口，而是：SCK、PDI、PDO引脚（如ATmega64/128/1281等），如下：

ISP下载器   AVR端口                  备注
   端口
   MISO       PDO
   VCC        VCC
   SCK        SCK
   MOSI       PDI
  RESET      RESET
   GND        GND

以上仅例举出常用的AVR型号的连接方式，若您使用的AVR型号没有被列举到，请查看相关型号的PDF文档，里面的编程章节将有介绍使用ISP时，需连接哪些引脚
。

下面是标准的接口排列：

[10-pin]
ATMEL指定的ISP_10PIN标准接口

[6-pin_]
ATMEL指定的ISP_6PIN标准接口

** 并口                                                               :并口:
*** overview

+ [[https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E7%AB%AF%E5%8F%A3][Wiki: 并口]]

并行端口（Parallel Port），又称平行埠、並列埠、并口，是计算机上数据以
并行方式传递的端口，也就是说至少应该有两条连接线用于传递数据。与只使用
一根线传递数据（这里没有包括用于接地、控制等的连接线）的串行端口相比，
并口在相同的数据传送速率下，并口可以更快地传输数据。所以在21世纪之前，
在需要较大传输速度的地方，例如打印机，并口得到广泛使用。但是随着速度迅
速提高，并口上导线之间数据同步成为一个很难处理的难题，导致并口在速度竞
赛中逐渐被淘汰。目前USB等改进的串口逐渐代替了并口。

[[~/Wally/Journal/Figures/scrot/9465etO.png]]

[[~/Wally/Journal/Figures/scrot/9465r3U.png]]

** UART
*** [[http://www.cnblogs.com/zcshan/archive/2010/12/03/com.html][并口、串口、COM口区别]] :blog:

并口的工作模式：

1：SPP（Standard Parallel
Port）称为标准并口，它是最早出现的并口工作模式，几乎所有使用并口的外设都支持该模式。

2：EPP（Enhanced Parallel Port）称为增强型高速并口，它是在SPP
的基础上发展起来的新型工作模式，也是现在应用最多的并口工作模式，目前市面上的大多数打印机、扫描仪都支持EPP
模式。

3：ECP（ExtendedCapability
Port）即扩充功能并口，它是目前比较先进的并口工作模式，但兼容性问题也比较多，除非您的外设支持ECP
模式，否则不要选择该模式。

串口叫做[[http://baike.baidu.com/view/161117.htm][串行接口 ]]，也称串行通信接口，即COM口。按电气标准及协议来分包括[[http://baike.baidu.com/view/112004.htm][
RS-232]]-C、[[http://baike.baidu.com/view/1940451.htm][RS-422 ]]、[[http://baike.baidu.com/view/196467.htm][RS485 ]]、[[http://baike.baidu.com/view/854.htm][USB ]]等。

RS-232-C、RS-422与RS-485标准只对接口的电气特性做出规定，不涉及接插件、
电缆或协议。USB是近几年发展起来的新型接口标准，主要应用于高速数据传输
领域。

RS-232-C：也称标准串口，是目前最常用的一种串行通讯接口。它是在1970年由美国电子工业协会（EIA）联合贝尔系统、
调制解调器厂家及计算机终端生产厂家共同制定的用于串行通讯的标
准。它的全名是“数据终端设备（DTE）和数据通讯设备（DCE）之间
串行二进制数据交换接口技术标准”。传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座。后来的PC上使用简化了的9芯D型插座。现在应用中25芯插头座已很少采用。现在的[[http://baike.baidu.com/view/2358.htm][电脑]]一般有两个串行口：COM1和COM2，你到计算机后面能看到9针D形接口就是了。现在有很多手机数据线或者物流接收器都采用COM口与计算机相连。

RS-422：为改进RS-232通信距离短、速率低的缺点，RS-422定义了一种平衡通信接口，将传输速率提高到10Mb/s，传输距离延长到4000英尺（速率低于100kb/s时），并允许在一条平衡总线上连接最多10个接收器。RS-422是一种单机发送、多机接收的单向、平衡传输规范，被命名为TIA/EIA-422-A标准。

RS-485：为扩展应用范围，EIA又于1983年在RS-422基础上制定了RS-485标准，增加了多点、双向通信能力，即允许多个发送器连接到同一条总线上，同时增加了发送器的驱动能力和冲突保护特性，扩展了总线共模范围，后命名为TIA/EIA-485-A标准。

Universal Serial
Bus（[[http://baike.baidu.com/view/474321.htm][通用串行总线]])简称USB，是目前电脑上应用较广泛的接口规范，由Intel、Microsoft、Compaq、IBM、NEC、Northern
Telcom等几家大厂商发起的新型外设接口标准。USB接口是电脑主板上的一种四针接口，其中中间两个针传输数据，两边两个针给外设供电。USB接口速度快、连接简单、不需要外接电源，传输速度12Mbps，最新USB2.0可达480Mbps；电缆最大长度5米，USB电缆有4条线，2条信号线，2条电源线，可提供5伏特电源，USB电缆还分屏蔽和非屏蔽两种，屏蔽电缆传输速度可达12Mbps，价格较贵，非屏蔽电缆速度为1.5Mbps，但价格便宜；USB通过串联方式最多可串接127个设备；支持热插拔。

RJ-45接口是以太网最为常用的接口，RJ45是一个常用名称，指的是由IEC
(60)603-7标准化，使用由国际性的接插件标准定义的8个位置(8针)的模块化插孔或者插头。



串口与并口的区别：

串口形容一下就是
一条车道，而并口就是有8个车道同一时刻能传送8位（一个字节）数据。

但是并不是并口快，由于8位通道之间的互相干扰。传输时速度就受到了限制。而且当传输出错时，要同时重新传8个位的数据。串口没有干扰，传输出错后重发一位就可以了。所以要比并口快。串口硬盘就是这样被人们重视的。



交换机的串口:

交换机的串口的英文就是trunk;是用来做下一跳路由转换用的.每个VLAN只有通过与TRUNK的路由指向后才能上外网

*** RS232                                                           :rs232:
**** RS-232 Wiki


*RS-232* 是美国[[/wiki/%E7%94%B5%E5%AD%90%E5%B7%A5%E4%B8%9A%E8%81%94%E7%9B%9F][电子工业联盟]]（EIA）制定的串行数据通信的接口标准。它被广
泛用于计算机串行接口外设连接。


它規定連接[[/wiki/%E9%9B%BB%E7%BA%9C][電纜]]和[[/wiki/%E6%A9%9F%E6%A2%B0][機械]]、[[/wiki/%E9%9B%BB%E6%B0%A3][電氣]]特性、信號功能及傳送過程。其他常用電氣標準還有
[[/wiki/EIA-422][EIA-RS-422-A]]、[[/w/index.php?title=EIA-423&action=edit&redlink=1][EIA-RS-423A]]、[[/wiki/RS-485][EIA-RS-485]]。

由於RS-232-C的重大影響，即使自IBM [[/wiki/PC/AT][PC/AT ]]開始改用9針連接器起，目前已幾
乎不再使用RS-232中規定的25針連接器，但大多數人仍然普遍使用RS-232C來代
表此一介面。

***** 标准的细节

在RS-232标准中，字符是以一序列的位元串来一个接一个的[[/w/index.php?title=%E4%B8%B2%E5%88%97&action=edit&redlink=1][串列]]（serial）方式
傳輸，優點是傳輸線少，配線簡單，傳送距離可以較遠。最常用的编码格式是异
步起停（asynchronous start-stop）格式，它使用一个起始位元后面紧跟7或8
个数据位元（bit），然后是可选的奇偶校验位元，最后是一或两个停止位元。
所以发送一个字符至少需要10位元，带来的一个好的效果是使全部的传输速率，
发送信号的速率以10划分。一个最平常的代替异步起停方式的是使用[[/wiki/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6][高级数据链
路控制]]协议（HDLC）。

在RS-232标准中定义了逻辑一和逻辑零电压级数，以及标准的传输速率和连接器
类型。信号大小在正的和负的3－15v之间。RS-232规定接近零的电平是无效的，
逻辑一规定为负电平，有效负电平的信号状态称为传号marking，它的功能意义
为OFF，逻辑零规定为正电平，有效正电平的信号状态称为空号spacing，它的功
能意义为ON。根据设备供电电源的不同，±5、±10、±12和±15这样的电平都
是可能的。


****** 连接器

RS-232設計之初是用來連接數據機做傳輸之用，也因此它的腳位意義通常也和數
據機傳輸有關。RS-232的设备可以分为数据终端设备（DTE，Data Terminal
Equipment, For example, PC）和数据通信设备（DCE，Data Communication
Equipment）两类，这种分类定义了不同的线路用来发送和接受信号。一般来说，
计算机和终端设备有DTE连接器，调制解调器和打印机有DCE连接器。但是这么说
并不是总是严格正确的，用配线分接器测试连接，或者用试误法来判断电缆是否
工作，常常需要参考相关的文件说明。

RS-232指定了20个不同的信号连接，由25个D-sub（微型D类）管脚构成的DB-25
连接器。

很多设备只是用了其中的一小部分管脚，出于节省资金和空间的考虑不少机器采
用较小的连接器，特别是9管脚的D-sub或者是 *DB-9* 型连接器被广泛使用绝大
多数自IBM的AT机之后的PC机和其他许多设备上。DB-25 和 DB-9 型的连接器在大部
分设备上是雌型，但不是所有的都是这样。

下表中列出的是被较多使用的RS-232中的信号和管脚分配：

#+BEGIN_EXAMPLE
               DE-9 Male（Pin Side）                   DE-9 Female (Pin Side）
                 -------------                          -------------
                 \ 1 2 3 4 5 /                          \ 5 4 3 2 1 /
                  \ 6 7 8 9 /                            \ 9 8 7 6 /
                   ---------                              ---------
#+END_EXAMPLE

| 信号                | DB-25 | DE-9 | EIA/TIA 561 | Yost |
|---------------------+-------+------+-------------+------|
| 公共接地            |     7 |    5 |           4 |  4,5 |
| 发送数据（TD、TXD） |     2 |    3 |           6 |    3 |
| 接受数据（RD、RXD） |     3 |    2 |           5 |    6 |
| 数据终端准备（DTR） |    20 |    4 |           3 |    2 |
| 数据准备好（DSR）   |     6 |    6 |           1 |    7 |
| 请求发送（RTS）     |     4 |    7 |           8 |    1 |
| 清除发送（CTS）     |     5 |    8 |           7 |    8 |
| 数据载波检测（DCD） |     8 |    1 |           2 |    7 |
| 振铃指示（RI）      |    22 |    9 |           1 |   － |

| 腳位 | 簡寫 | 意義                | 說明                           |
|------+------+---------------------+--------------------------------|
| Pin1 | CD   | Carrier Detect      | 數據機通知電腦有載波被偵測到。 |
| Pin2 | RXD  | Receiver            | 接收資料。                     |
| Pin3 | TXD  | Transmit            | 傳送資料。                     |
| Pin4 | DTR  | Data Terminal Ready | 電腦告訴數據機可以進行傳輸。   |
| Pin5 | GND  | Ground              | 地線。                         |
| Pin6 | DSR  | Data Set Ready      | 數據機告訴電腦一切準備就緒。   |
| Pin7 | RTS  | Request To Send     | 電腦要求數據機將資料送出。     |
| Pin8 | CTS  | Clear To Send       | 數據機通知電腦可以傳資料過來。 |
| Pin9 | RI   | Ring Indicator      | 數據機通知電腦有電話進來。     |

TXD DTE->DCE DTE SEND DATA

RXD DCE->DTE DTE RECEIVE DATA

RTS DTE->DCE DTE REQUEST SEND

CTS DCE->DTE ACK TO DTE'S RTS

DSR DCE->DTE DCE IS READY

GND

DCD DCE->DTE DC DETECTED

DTR DTE->DCE DTE IS READY

RI DCE->DTE RING INDICATION

信号的标注是从DTE设备的角度出发的，TD、DTR和RTS信号是由DTE产生的，RD、DSR、CTS、DCD和RI信号是由DCE产生的。接地信号是所有连接都公共的，在Yost的标准中接地信号外部有两个管脚事实上是同一个信号。如果两个通信设备的距离相差的很远或者是有两个不同的供电系统供电，那么地信号在两个设备间会不一样，从而导致通信失败，跟踪描述这样的情形是很困难的。

****** 设置

串行通信在软件设置里需要做多项设置，最常见的设置包括[[/wiki/%E6%B3%A2%E7%89%B9%E7%8E%87][波特率]]（Baud）、奇偶校验（Parity
Check）和停止位（Stop Bit）。

-  波特率（又称[[/wiki/%E9%AE%91%E7%8E%87][鮑率]]）：是指从一设备发到另一设备的波特率，即每秒钟多少符號。典型的波特率是300,
   1200, 2400, 9600, 19200,
   115200等。一般通信两端设备都要设为相同的波特率，但有些设备也可设置为自动检测波特率。

-  奇偶校验（Parity：是用来验证数据的正确性。奇偶校验一般不使用，如果使用，那么既可以做奇校验（Odd
   Parity）也可以做偶校验（Even
   Parity）。奇偶校验是通过修改每一发送字节（也可以限制发送的字节）来工作的。如果不作奇偶校验，那么数据是不会被改变的。在偶校验中，因为奇偶校验位会被相应的置1或0（一般是最高位或最低位），所以数据会被改变以使得所有传送的数位（含字符的各数位和校验位）中“1”的个数为偶数；在奇校验中，所有传送的数位（含字符的各数位和校验位）中“1”的个数为奇数。奇偶校验可以用于接受方检查传输是否发送生错误------如果某一字节中“1”的个数发生了错误，那么这个字节在传输中一定有错误发生。如果奇偶校验是正确的，那么要么没有发生错误要么发生了偶数个的错误。如果使用者選擇資料長度為8位元，則因為沒有多餘的位元可被用來作為同位元，因此就叫做「非奇偶校验（Non
   Parity）」。

-  停止位：是在每个字节传输之后发送的，它用来帮助接受信号方硬件重同步。

RS-232在傳送資料時，並不需要另外使用一條傳輸線來傳送同步訊號，就能正確
的將資料順利傳送到對方，因此叫做「非同步傳輸」，簡稱UART（Universal
Asynchronous Receiver Transmitter），不過必須在每一筆資料的前後都加上
同步訊號，把同步訊號與資料混和之後，使用同一條傳輸線來傳輸。

在串行通信软件设置中D/P/S是常规的符号表示。8/N/1（非常普遍）表明8bit数
据，没有奇偶校验，1bit停止位。数据位可以设置为5、6、7或者8位元（不可以
大於8或小於5），奇偶校验位可以设置为无（N）、奇（O）或者偶（E），奇偶
校验可以使用数据中的位元（bit），所以8/E/1就表示一共8位数据位，其中一
位用来做奇偶校验位。停止位可以是1、1.5或者2位的（1.5是用在波特率为
60wpm的电传打字机上的）。


-  流量控制：当需要发送[[/wiki/%E6%8F%A1%E6%89%8B%E4%BF%A1%E5%8F%B7][握手信号]]或数据完整性检测时需要制定其他设置。公用的组合有RTS/CTS,
   DTR/DSR或者XON/XOFF（实际中不使用连接器管脚而在数据流内插入特殊字符）。

***** 類似規範

-  [[/wiki/%E5%9B%BD%E9%99%85%E7%94%B5%E4%BF%A1%E8%81%94%E7%9B%9F%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84][ITU-T]]（前CCITT）的對應規範，用語不同，但電氣規格幾乎相同

   -  ITU-T V.28

-  具有相似的通信目的，但功能與電氣規範不同

   -  [[/wiki/RS-422][RS-422]]
   -  [[/w/index.php?title=RS-423&action=edit&redlink=1][RS-423]]
   -  [[/wiki/RS-449][RS-449]]
   -  [[/wiki/RS-485][RS-485]]

***** 外部連結

-  [[http://www.zywyn.com.tw/index.php][RS-232 professional maker (ZYWYN.com）]]
-  [[http://www.camiresearch.com/Data_Com_Basics/RS232_standard.html][RS-232 tutorial]]
-  [[http://www.yost.com/Computers/RJ45-serial/][Yost Serial Device Wiring Standard]]
-  [[http://www.acumeninstruments.com/Support/documentation/SerialPortBasics/index.shtml][Serial Port Basics]]
-  [[http://www.lammertbies.nl/comm/info/RS-232.html][RS232 serial port info]]
-  [[http://www.tronisoft.com/rs232info/ASCII_serial_port_crib_sheets.pdf][Printable ASCII Serial Port Crib Sheets]]

**** RS232

- http://c.biancheng.net/cpp/html/1919.html

标准串口，在物理结构上分为 9 针的和 9 孔的，习惯上我们也称之为公头和母
头

[[~/Wally/Journal//Figure/scrot/2983mBR.png]]

RS232 接口一共有 9 个引脚，分别定义是：1、载波检测 DCD；2、接收数据
RXD；3、发送数据 TXD；4、数据终端准备好 DTR；5、信号地线 SG；6、数据准
备好 DSR；7、请求发送 RTS；8、清除发送 CTS；9、振铃提示 RI。我们要让这
个串口和我们单片机进行通信，我们只需要关心其中的 2 脚 RXD、3 脚 TXD 和
5 脚 GND 即可。

虽然这三个引脚的名字和我们单片机上的串口名字一样，但是却不能直接和单片
机对连通信，这是为什么呢？随着我们了解的内容越来越多，我们得慢慢知道，
不是所有的电路都是 5V 代表高电平而 0V 代表低电平的。对于 RS232 标准来
说，它是个反逻辑，也叫做负逻辑。为何叫负逻辑？它的 TXD 和 RXD 的电
压，-3V～-15V 电压代表是 1，+3～+15V 电压代表是 0。低电平代表的是 1，
而高电平代表的是 0，所以称之为负逻辑。因此电脑的 9 针 RS232串口是不能
和单片机直接连接的，需要用一个电平转换芯片 MAX232 来完成.

[[~/Wally/Journal//Figure/scrot/2983zLX.png]]

 RS232 串口和 UART 串口，它们的协议类型是一样的，只是电平标准不同而已，
 而 MAX232 这个芯片起到的就是中间人的作用，它把 UART 电平转换成 RS232
 电平，也把 RS232 电平转换成 UART 电平，从而实现标准 RS232接口和单片机
 UART 之间的通信连接。

**** RS485                                                         :rs485:
***** EIA-485 wiki                                                 :wiki:

*EIA-485*（过去叫做*RS-485*或者*RS485*）是隶属于[[/wiki/OSI%E6%A8%A1%E5%9E%8B][OSI模型]][[/wiki/%E7%89%A9%E7%90%86%E5%B1%82][物理层]]的电气特
性规定为2线，[[/wiki/%E5%8D%8A%E9%9B%99%E5%B7%A5][半双工]]，多点通信的标准。它的电气特性和[[/wiki/RS-232][RS-232]]不大一样。用
缆线两端的[[/wiki/%E7%94%B5%E5%8E%8B][电压]]差值来表示传递信号，1极的电压标识为逻辑1，另一段标识为逻
辑0。两端的电压差最小为0.2V以上时有效，任何不大于12V或者不小于－7V的差
值对接受端都被认为是正确的。

EIA-485仅仅规定了接受端和发送端的电气特性。它没有规定或推荐任何数据协
议。EIA-485可以应用于配置便宜的[[/wiki/%E5%B9%BF%E5%9F%9F%E7%BD%91][广域网]]和采用单机发送，多机接受通信链接。
它提供高速的数据通信速率（10m时35[[/w/index.php?title=Bitrate&action=edit&redlink=1][Mbit/s]]；1200m时100[[/w/index.php?title=Bitrate&action=edit&redlink=1][kbit/s]]1200m）。

EIA-485和[[/wiki/EIA-422][EIA-422]]一样使用双绞线进行高电压差分平衡传输，它可以进行大面积
长距离传输（超过4000[[http://zh.wikipedia.org/wiki/%E8%8B%B1%E5%B0%BA][英尺]]，1200米）。

和EIA-422相对照的是，EIA-422采用不可转换的单发送端，EIA-485的发送端需
要设置为发送模式，这使得EIA-485可以使用双线模式实现真正的多点双向通信。

EIA-485推荐使用在点对点网络中，线型、总线型，不能是星型、环型网络。理
想情况下EIA-485需要2个终接电阻，其阻值要求等于传输电缆的特性阻抗。没有
特性阻抗的话，当所有的设备都静止或者没有能量的时候就会产生噪声，而且线
移需要双端的电压差。没有终接电阻的话，会使得较快速的发送端产生多个数据
信号的边缘，这其中的一些是不正确的。之所以不能使用星型或者环型的拓扑结
构是由于这些结构有不必要的反映，过低或者过高的终接电阻可以产生电磁干扰。

EIA-485在使用四线时可以和EIA-422一样实现[[/wiki/%E5%85%A8%E9%9B%99%E5%B7%A5][全双工]]。EIA-485可以实现真正的
多点通信，在许多情况下并没有什么用处。在某些限制条件下，EIA-485和
EIA-422可以实现相互的连接。

****** 比较

下面的表格列出了RS-485的一些特性和引脚的分配以及和[[/wiki/RS-232][RS-232]]的比较：

| EIA-485                    | [[/wiki/RS-232][RS-232]]                    | [[/w/index.php?title=D-subminiature&action=edit&redlink=1][DB-25]] | [[/w/index.php?title=D-subminiature&action=edit&redlink=1][DE-9]] | [[/w/index.php?title=RJ-50&action=edit&redlink=1][RJ-50]] |
|----------------------------+---------------------------+-------+------+-------|
| Common Ground              | Carrier Detect（DCD）     |     8 |    1 |    10 |
| Clear To Send +（CTS+）    | Received Data (RD)        |     3 |    2 |     9 |
| Ready To Send +（RTS+）    | Transmitted Data (TD)     |     2 |    3 |     8 |
| Received Data +（RxD+）    | Data Terminal Ready (DTR) |    20 |    4 |     7 |
| Received Data -（RxD-）    | Common Ground             |     7 |    5 |     6 |
| Clear To Send -（CTS-）    | Data Set Ready (DSR)      |     6 |    6 |     5 |
| Ready To Send -（RTS-）    | Request To Send (RTS)     |     4 |    7 |     4 |
| Transmitted Data +（TxD+） | Clear To Send (CTS)       |     5 |    8 |     3 |
| Transmitted Data -（TxD-） | Ring Indicator (RI)       |    22 |    9 |     2 |

** Video interface
*** LVDS                                                             :lvds:
**** reference

- [[http://baike.baidu.com/link?url=7BVzHvPMvlyCuLejyh7jlEETSqpq5XaLJBMeVHm3y3KJLh1glCgN_C6yh5k5ZfsqbV4_LGc-khKBCYBLxxKhs_][百度百科]]
- [[http://ieeexplore.ieee.org/xpl/login.jsp?reload=true&tp=&arnumber=503756&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D503756][IEEE 标准]]

**** Lvds :: Low-Voltage Differential Signaling  低电压差分信号

LVDS接口是 *LCD Panel* 通用的接口标准，大多用在7寸以上尺寸的显示屏上。

1994年由美国国家半导体公司提出的一种 *信号传输模式* ，是一种 *电平标
准*  ，LVDS接口又称 *RS-644总线接口* ，是20世纪90年代才出现的一种数据
传输和接口技术。

LVDS即低电压差分信号，这种技术的核心是采用极低的电压摆幅高速差动传输数
据，可以实现点对点或一点对多点的连接，具有低功耗、低误码率、低串扰和低
辐射等特点，其传输介质可以是铜质的PCB连线，也可以是平衡电缆。LVDS在对
信号完整性、低抖动及共模特性要求较高的系统中得到了越来越广泛的应用。


LVDS可采 用CMOS、GaAs或其他技术实现，其供电电压可以从+5V到+3.3V，甚至
更低；其传输介质可以是PCB连线，也可以是特制的电缆。标准推荐的最高数据
传输速率是 *655Mbps* ，而理论上，在一个无衰耗的传输线上，LVDS的最高传
输速率可达 *1.923Gbps*




#+DOWNLOADED: http://h.hiphotos.baidu.com/baike/c0%3Dbaike180%2C5%2C5%2C180%2C60/sign=ae3fe7ee80025aafc73f76999a84c001/b21c8701a18b87d658530a31050828381f30fd8f.jpg @ 2016-01-22 17:18:24
 [[~/Wally/Journal/Figure/.org-download/Journal/b21c8701a18b87d658530a31050828381f30fd8f_2016-01-22_17:18:22.jpg]]

**** advantages

它在提供高数据传输率的同时会有很低的功耗，另外它还有许多其他的优势：

1、低至2V的电源电压兼容性
2、低噪声
3、高噪声抑制能力
4、可靠的信号传输
5、能够集成到系统级IC内
6、使用LVDS技术的的产品数据速率可以从几百Mbps到2Gbps。
7、它是电流驱动的，通过在接收端放置一个负载而得到电压，当电流正向流动，接收端输出为1，反之为0。
8、它的摆幅为250mv-450mv。
9、此技术基于ANSI/TIA/EIA-644LVDS接口标准。

**** LDVS vs HDMI                                                   :hdmi:

- http://www.dxdlw.com/ShowPost.asp?ThreadID=32129
- [[http://zhidao.baidu.com/link?url=ySZsKDG86GR8sONJOFXdH3UkWrHfYOz55TvqjnQmcOwooJlcEeianKLdXYnyWhC9t8SvgojaANRK9X4wrwLO7a][百度知道]]


简单的说HDMI外部设备的连接,LVDS 是用在显示器内部连接.

HDMI (High-Definition Multimedia Interface)，即高清晰度多媒体接口,HDMI
Cable就是連接Maind board HDMI 與外接高清晰度多媒体的線材，而LVDS cable
只是鏈接Maind board 與LCD之間的Cable


HDMI与LVD是两种不同的产品，根本就没有什么相同的地方。


在DisplayPort之前，数字多媒体接口标准经历了多次纷争，逐渐形成了外部连
接(*Box-to-Box*)与内部连接(*Chip-to-Chip*)两块相互独立的阵地。在外部连接方
面，PC已有DVI；而CE方面也有方兴未艾的HDMI；至于内部连接则是约定俗成的
标准——LVDS。


LVDS是低压差分信号，是一种信号传输技术，由美国国家半导体发起的一种信号
传输方式标准。

HDMI是一种接口传输标准，HDMI里面有4对LVDS线，分别传送R、G、B&CLK信号，

DP也是一样，只是HDMI和DP的电平不一样而已。

如果要做DP和HDMI的转换只要做一个电平转换电路只可，RGB&CLK单向，DDC要双
向。当然速率要够高！


目前为止，所有带有HDMI接口的显示器，都是将HDMI信号转换成LVDS给显示屏的。


HDMI： High Definition Multimedia Interface， 这是一种接口技术，主要就
是为了解决接口兼容性的问题；

LVDS： Low-Voltage Differential Signaling 低压差分信号，它虽然也是一种
接口，但更多指的是电气特性方面，解决的也主要是高速传输中出现的问题（噪
音、可靠性、传输速率、时延等）。

两者属于不同层面上的应用。HDMI中包含LVDS总线。

**** 接口定义

20 pin

*** HDMI                                                             :hdmi:

*** [[http://bbs.mydigit.cn/simple/?t523987.html][ HDMI、DVI和VGA之间的区别 ]]                          :blog:hdmi:dvi:vga:

目前在高清设备中，主要的接口有DVI、HDMI、VGA接口，其中VGA传输的是模拟
视频信号，DVI传播的是数字视频信号，HDMI可以同时传输数字视频信号和数字
音频信号。在现在的计算机和电视等设备中，我们经常可以看到这三种接口，很
多用户存在疑问，这三种接口之间有什么区别呢?

DVI接口是在1999年推出的接口标准。DVI接口的传输信号采用全数字格式，与之
对应的是采用模拟信号的VGA接口。VGA和DVI的区别，首先VGA模拟信号的传输比
较麻烦，首先是将电脑内的数字信号转换为模拟信号，将信号发送到LCD显示器，
由显示器再将该模拟信号转换为数字信号，形成画面展示在大家面前。正因为如
此，中间的信号丢失严重，虽然可以通过软件的方法修复部分画面，但是随着显
示器的分辨率越高画面就会越模糊。一般模拟信号在超过1280×1024分辨率以上
的情况下就会出现明显的误差，分辨率越高越严重。

VGA接口应用范围非常广泛，是三种接口中最先推出的标准，VGA(Video
Graphics Array)接口，也叫D-Sub接口。虽然液晶显示器可以直接接收数字信号，
但很多低端产品为了与VGA接口显卡相匹配，因而采用VGA接口。VGA接口是一种D
型接口，上面共有15针空，分成三排，每排五个。VGA接口是显卡上应用最为广
泛的接口类型，绝大多数的显卡都带有此种接口。

HDMI (High-Definition Multimedia Interface) ，常被称作高清晰度多媒体接
口，是终结以往影音分离传输的全新接口，其最大传输速度可达5Gb/s，除影像
数据外，更可同时传输高达8声道的音讯信号。这种非压缩式的数字数据传输，
可有效降低数/类转换所造成的信号干扰与衰减。HDMI是首个支持在单线缆上传
输，不经过压缩的全数字高清晰度、多声道音频和智能格式与控制命令数据的数
字接口。HDMI接口由Silicon Image美国晶像公司倡导，联合索尼、日立、松下、
飞利浦、汤姆逊、东芝等八家著名的消费类电子制造商联合成立的工作组共同开
发的。HDMI最早的接口规范HDMI1.0于2002年12月公布，目前的最高版本是于今
年6月发布的HDMI1.3规范。

HDMI源于DVI接口技术，它们主要是以美国晶像公司的TMDS信号传输技术为核心，
这也就是为何HDMI接口和DVI接口能够通过转接头相互转换的原因。美国晶像公
司是HDMI八个发起者中唯一的集成电路设计制造公司，是高速串行数据传输技术
领域的领导厂商。

目前的高端显卡上一般有VGA、DVI、HDMI接口，一般的显示卡VGA、DVI接口；目
前生产的大屏幕LED显示器上有VGA、HDMI接口（如三星24寸），中型LED显示器
有VGA、DVI接口（比如三星21寸），选购连接线前请注意观察显示卡和显示器接
口的匹配，接口型号不同时，可以选择转接线。

** RS232                                                             :rs232:

*** [[http://blog.sina.com.cn/s/blog_7ca994b80101b08l.html][TTL电平与RS232电平]]                                           :blog:ttl:

之前一直没把他们当回事，真正到用的时候才知道，理解他们很重要。

什么是TTL电平、CMOS电平、RS232电平？它们有什么区别呢？一般说来，CMOS电
平比TTL电平有着更高的噪声容限。

*（一）、TTL电平标准*

输出 L： <0.8V ； H：>2.4V。
输入 L： <1.2V ； H：>2.0V

TTL器件输出低电平要小于0.8V，高电平要大于2.4V。输入，低于1.2V就认为是0，
高于2.0就认为是1。于是TTL电平的输入低电平的噪声容限就只有
(0.8-0)/2=0.4V，高电平的噪声容限为(5-2.4)/2=1.3V。


*（二）、CMOS电平标准*

输出 L： <0.1*Vcc ； H：>0.9*Vcc。
输入 L： <0.3*Vcc ； H：>0.7*Vcc.

由于CMOS电源采用12V，则输入低于3.6V为低电平，噪声容限为1.8V，高于3.5V
为高电平，噪声容限高为1.8V。比TTL有更高的噪声容限。

*（三）、RS232标准*

逻辑1的电平为-3～-15V，逻辑0的电平为+3～+15V，注意电平的定义反相了一次。

** CAN                                                                 :can:
*** CAN总线基础

**** Introduction

- 控制器局域网(Control Area Network)
- 现场总线（何为?)
- 成本低、距离远、速率高
- 独立的CAN控制器或带有CAN控制器的MCU芯片

**** CAN协议

- 与开放互连系统(OSI）模型一致，CAN定义了数据链路层和物理层

  #+DOWNLOADED: file:///home/wally/Desktop/%E3%80%8ACAN%E6%80%BB%E7%BA%BF%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E3%80%8B_files/Image.jpg @ 2016-01-26 14:45:35
  [[~/Wally/Journal/Figure/.org-download/CAN总线基础/Image_2016-01-26_14:45:35.jpg]]

- 两根信号线 CAN_H 和 CAN_L

- 信号使用差分电压

  - 静态时 CAN_H = 2.5v, CNA_L = 2.5v，表逻辑1，称隐形
  - CAN_H = 3.5v, CAN_L = 1.5v，表逻辑0，称显形


#+DOWNLOADED: file:///home/wally/Desktop/%E3%80%8ACAN%E6%80%BB%E7%BA%BF%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E3%80%8B_files/Image%20%5B1%5D.jpg @ 2016-01-26 14:52:15
 [[~/Wally/Journal/Figure/.org-download/CAN总线基础/Image%20%5B1%5D_2016-01-26_14:52:15.jpg]]

**** CAN标准格式和扩展格式

- 标准格式：标志符长度11字节
- 扩展格式：标志符29字节，CAN2.0协议

**** CAN节点

#+DOWNLOADED: file:///home/wally/Desktop/%E3%80%8ACAN%E6%80%BB%E7%BA%BF%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E3%80%8B_files/Image%20%5B2%5D.jpg @ 2016-01-26 14:49:06
 [[~/Wally/Journal/Figure/.org-download/CAN总线基础/Image%20%5B2%5D_2016-01-26_14:49:06.jpg]]

- 构成

  - MCU+CAN控制器+CAN收发器
  - 带CAN控制器的MCU+CAN收发器

- 独立的CAN控制器

  - SJA1000， 通过数据总线与MCU相连
  - MCP2515，通过SPI总线与MCU相连
  - VS MCU中的CAN控制器
    - 优点：移植性好
    - 缺点：硬件电路相对复杂

- CAN收发器

  - PCA82C250, PCA82C251, TJA1050, TJA1040

**** CAN控制器工作原理

#+DOWNLOADED: file:///home/wally/Desktop/%E3%80%8ACAN%E6%80%BB%E7%BA%BF%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E3%80%8B_files/Image%20%5B3%5D.jpg @ 2016-01-26 14:49:54
 [[~/Wally/Journal/Figure/.org-download/CAN总线基础/Image%20%5B3%5D_2016-01-26_14:49:54.jpg]]

- 接口管理逻辑

  - 连接主控制器，解释其命令，并控制CAN寻址
  - 反馈中断信息和状态信息

- CAN核心模块

  - 收报文时，根据CAN规范将串行位流转换为用于接收的并行数据
  - 发送报文时，将并行数据转换为串行位流

- 发送缓冲器

  - 缓冲完整的报文

- 验收滤波器

  - 根据编程设置，过滤掉不需用的报文

- 接收FIFO

  - 缓冲接收到的报文

- 工作模式

  - BasicCAN，仅支持标准模式
  - PeliCAN，支持标准模式和扩展模式

**** CAN收发器

- 隔离CAN收发器
- 通用CAN收发器
- 高速CAN收发器
- 容错CAN收发器

**** CAN总线接口电路保护器件

CAN系统不能受到干扰，也不能干扰其它电子元件，所以CAN系统必须满足电磁干
扰(EMI)和静电放电(ESD)标准的严格要求。

#+DOWNLOADED: file:///home/wally/Desktop/%E3%80%8ACAN%E6%80%BB%E7%BA%BF%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E3%80%8B_files/Image%20%5B4%5D.jpg @ 2016-01-26 14:51:00
 [[~/Wally/Journal/Figure/.org-download/CAN总线基础/Image%20%5B4%5D_2016-01-26_14:51:00.jpg]]


- 共模扼流圈

  共模扼流圈(Common Mode Choke)，也称共模电感，可使系统的EMC性能得到较
  大的提升，确保设备的电磁兼容性，抑制耦合干扰

  - 滤除CAN总线信号线上的共模电磁干扰
  - 令差分信号的高频部分衰减
  - 抑制自身发出的电磁干扰
  - 如， EPCOS B82793芯片

- ESD防护

  CAN总线通常工作在噪声大的环境下，经常会受到静电电压、电压突变脉冲等
  干扰，在设计CAN总线电路时需要选择CAN专用的ESD防护元件。

- CAN总线网络防护

**** CAN通信过程

类似邮递，CAN报文中只有目的地址，无己方地址，数据信息由不同的报文格式
传送，如数据帧、远程帧等。每个CAN节点上的控制器通过过滤器设置自己的地
址。

**** CAN报文格式

- 帧类型

  - 数据帧
  - 远程帧
  - 错误帧
  - 过载帧

- 帧格式

  - 标准格式
  - 扩展格式

- 数据帧组成

  - 帧起始
  - 仲裁场
  - 控制场
  - 数据场
  - CRC场
  - 应答场
  - 帧结尾

**** CAN总线传输介质

- 双绞线
- 光纤

*** [[http://www.21ic.com/app/control/201304/178371.htm][工控领域最流行的九大现场总线]]

- FF现场总线
- LonWorks现场总线
- Profibu现场总线
- CAN现场总线
- Devicenet现场总线
- HART现场总线
- CC-Link现场总线
- WorldFIP现场总线
- INTERBUS现场总线

*** [[http://bbs.ednchina.com/BLOG_ARTICLE_124613.HTM][CAN总线的相关概念]]
                                                                CAN学习手记
**** 题记：

在这信息爆炸的年代，学习一样新的知识，尤其是IT技术的学习，网络是必不可少的。一阵狂搜过后，发现基于CAN总线的介绍确实不少，但是大多好像都雷同
了，也许是不断转贴的结果吧。而且这些知识点也都太零散了，让人看了，尤其是初学者有点找不着北的感觉。所以，本着谦虚好学脚踏实地的菜鸟精神，决定
把网上搜的，书上看的，再添油加醋的做一番比较系统的整理。算是为学习CAN总线理清思路，快速上手打基础吧。

**** 一、什么是CAN总线？

CAN，全称为“Controller Area Network”，即控制器局域网，是国际上应用最广泛的现场总线之一。最初，CAN被设计作为汽车环境中的微控制器通讯，在车载
各电子控制装置ECU之间交换信息，形成汽车电子控制网络。比如：发动机管理系统、变速箱控制器、仪表装备、电子主干系统中，均嵌入CAN控制装置。

一个由CAN 总线构成的单一网络中，理论上可以挂接无数个节点。实际应用中，节点数目受网络硬件的电气特性所限制。例如，当使用Philips P82C250作为CAN
收发器时，同一网络中允许挂接110个节点。CAN 可提供高达1Mbit/s的数据传输速率，这使实时控制变得非常容易。另外，硬件的错误检定特性也增强了CAN的
抗电磁干扰能力。

**** 二、CAN 总线是如何发展的？

CAN最初出现在80年代末的汽车工业中，由德国Bosch公司最先提出。当时，由于消费者对于汽车功能的要求越来越多，而这些功能的实现大多是基于电子操
作的，这就使得电子装置之间的通讯越来越复杂，同时意味着需要更多的连接信号线。提出CAN总线的最初动机就是为了解决现代汽车中庞大的电子控制装置之
间的通讯，减少不断增加的信号线。于是，他们设计了一个单一的网络总线，所有的外围器件可以被挂接在该总线上。1993年，CAN 已成为国际标准ISO11898(
高速应用)和ISO11519（低速应用）。

CAN是一种多主方式的串行通讯总线，基本设计规范要求有高的位速率，高抗电磁干扰性，而且能够检测出产生的任何错误。当信号传输距离达到10Km时，
CAN 仍可提供高达50Kbit/s的数据传输速率。

由于CAN总线具有很高的实时性能，因此，CAN已经在汽车工业、航空工业、工业控制、安全防护等领域中得到了广泛应用。

**** 三、CAN 总线是如何工作的？

CAN通讯协议主要描述设备之间的信息传递方式。CAN层的定义与开放系统互连模型（OSI）一致。每一层与另一设备上相同的那一层通讯。实际的通讯发生在每
一设备上相邻的两层，而设备只通过模型物理层的物理介质互连。CAN的规范定义了模型的最下面两层：数据链路层和物理层。下表中展示了OSI开放式互连模型
的各层。应用层协议可以由CAN用户定义成适合特别工业领域的任何方案。已在工业控制和制造业领域得到广泛应用的标准是DeviceNet，这是为PLC和智能传感
器设计的。在汽车工业，许多制造商都应用他们自己的标准。


| 7 | 应用层   | 最高层。用户、软件、网络终端等之间用来进 |
|   |          | 行信息交换。如：DeviceNet                |
| 6 | 表示层   | 将两个应用不同数据格式的系统信息转化为能 |
|   |          | 共同理解的格式                           |
| 5 | 会话层   | 依靠低层的通信功能来进行数据的有效传递。 |
| 4 | 传输层   | 两通讯节点之间数据传输控制。操作如：数据 |
|   |          | 重发，数据错误修复                       |
| 3 | 网络层   | 规定了网络连接的建立、维持和拆除的协议。 |
|   |          | 如：路由和寻址                           |
| 2 | 数据链路 | 规定了在介质上传输的数据位的排列和组织。 |
|   | 层       | 如：数据校验和帧结构                     |
| 1 | 物理层   | 规定通讯介质的物理特性。如：电气特性和信 |
|   |          | 号交换的解释                             |

CAN能够使用多种物理介质，例如双绞线、光纤等。最常用的就是双绞线。信号使用差分电压传送，两条信号线被称为“CAN_H”和“CAN_L”，静态时均是2.5V左右
，此时状态表示为逻辑“1”，也可以叫做“隐性”。用CAN_H比CAN_L高表示逻辑“0”，称为“显形”，此时，通常电压值为：CAN_H = 3.5V 和CAN_L = 1.5V。

**** 四、CAN 有哪些特性？

CAN具有十分优越的特点，使人们乐于选择。这些特性包括：

1、低成本；

2、极高的总线利用率；

3、很远的数据传输距离(长达10Km)；

4、高速的数据传输速率（高达1Mbit/s）；

5、可根据报文的ID决定接收或屏蔽该报文；

6、可靠的错误处理和检错机制；

7、发送的信息遭到破坏后，可自动重发；

8、节点在错误严重的情况下具有自动退出总线的功能；

9、报文不包含源地址或目标地址，仅用标志符来指示功能信息、优先级信息。

**** Philips制造的CAN芯片有哪些？




| 类别          | 型号      | 备注          |
|---------------+-----------+---------------|
| CAN微控制器   | P87C591   | 替代P87C592   |
|---------------+-----------+---------------|
| CAN独立控制器 | SJA1000   | 替代82C200    |
|---------------+-----------+---------------|
| CAN收发器     | PCA82C250 | 高速CAN收发器 |
|---------------+-----------+---------------|
|               | PCA82C251 | 高速CAN收发器 |
|---------------+-----------+---------------|
|               | PCA82C252 | 容错CAN收发器 |
|---------------+-----------+---------------|
|               | TJA1040   | 高速CAN收发器 |
|---------------+-----------+---------------|
|               | TJA1041   | 高速CAN收发器 |
|---------------+-----------+---------------|
|               | TJA1050   | 高速CAN收发器 |
|---------------+-----------+---------------|
|               | TJA1053   | 容错CAN收发器 |
|---------------+-----------+---------------|
|               | TJA1054   | 容错CAN收发器 |
|---------------+-----------+---------------|
| LIN收发器     | TJA1020   | LIN收发器     |

表2 CAN芯片一览表

**** 六、CAN总线如何进行位仲裁？

CSMA/CD是“载波侦听多路访问/冲突检测”（Carrier Sense Multiple Access with Collision Detect）的缩写。

利用CSMA访问总线，可对总线上信号进行检测，只有当总线处于空闲状态时，才允许发送。利用这种方法，可以允许多个节点挂接到同一网络上。当检测到
一个冲突位时，所有节点重新回到‘监听’总线状态，直到该冲突时间过后，才开始发送。在总线超载的情况下，这种技术可能会造成发送信号经过许多延迟。为
了避免发送时延，可利用CSMA/CD方式访问总线。当总线上有两个节点同时进行发送时，必须通过“无损的逐位仲裁”方法来使有最高优先权的的报文优先发送。
在CAN总线上发送的每一条报文都具有唯一的一个11位或29位数字的ID。CAN总线状态取决于二进制数‘0’而不是‘1’，所以ID号越小，则该报文拥有越高的优先权
。因此一个为全‘0’标志符的报文具有总线上的最高级优先权。可用另外的方法来解释：在消息冲突的位置，第一个节点发送0而另外的节点发送1，那么发送0的
节点将取得总线的控制权，并且能够成功的发送出它的信息。

**** 七、CAN的高层协议

CAN的高层协议（也可理解为应用层协议）是一种在现有的底层协议（物理层和数据链路层）之上实现的协议。高层协议是在CAN规范的基础上发展起来的应
用层。许多系统（像汽车工业）中，可以特别制定一个合适的应用层，但对于许多的行业来说，这种方法是不经济的。一些组织已经研究并开放了应用层标准，
以使系统的综合应用变得十分容易。

一些可使用的CAN高层协议有：

1、制定组织主要高层协议

2、CiA CAL协议

3、CiA CANOpen协议

4、ODVA DeviceNet 协议

5、Honeywell SDS 协议

6、Kvaser CANKingdom协议

**** 八、什么是标准格式CAN和扩展格式CAN？

标准CAN的标志符长度是11位，而扩展格式CAN的标志符长度可达29位。CAN 协议的2.0A版本规定CAN控制器必须有一个11位的标志符。同时，在2.0B版本中规定
，CAN控制器的标志符长度可以是11位或29位。遵循CAN2.0B协议的CAN控制器可以发送和接收11位标识符的标准格式报文或29位标识符的扩展格式报文。如果禁
止CAN2.0B,则CAN 控制器只能发送和接收11位标识符的标准格式报文，而忽略扩展格式的报文结构，但不会出现错误。

目前，Philips公司主要推广的CAN独立控制器均支持CAN2.0B协议，即支持29位标识符的扩展格式报文结构。

**** 九、CAN的报文格式：

（关于这部分内容，对于我下一步要进行编程实验控制CAN总线是很重要的一个知识点。很郁闷的是搜了老半天只看见有文字叙述这部分内容的，不仅说得不系
统完整，而且远没有贴图说明来的具体直观。不过还好，搜到了一份E文版的CAN总线资料，再把这个资料详细看了下，再做了整理，还是用图来说明CAN传输的
报文格式比较容易理解。老外写的东西确实比国内的好，这个不是我吹出来的，有兴趣下了看看就知道了，见附件下载。）

CAN通信是一种点对多点的传输协议，不是基于地址的传统的点对点传输协议。当一个点传输数据时，总线上的其它点都可以为接受方，它们可以通过ID来作出
对总线上传送数据的处理（接收或者丢弃）。并且当数据被正确接收到以后，接收方便会作出应答响应。CAN协议还有一个很实用的功能，就是总线上的任一个
节点可以请求其它节点向其发送数据，这被称作远程发送请求（RTR）。除此以外，CAN协议还有一个优点，当总线新加入一个节点进行通信时无需更改原有的程
序，新节点只要通过ID就可以知道是接收还是丢弃数据。

CAN协议定义了四种不同的帧。

1、数据帧，这个帧被用于当一个节点把信息传送给系统的任何其它节点。数据帧由7个不同的位场组成，即帧起始、仲裁场、控制场、数据场、CRC场、应答场
、帧结束。

2、远程帧，此帧是基于数据帧格式，只要把RTR位设置成远程发送请求（Remote Transmit Request），并且没有数据场。总线上发送此帧后，表示请求接收与
该帧ID相符的数据帧。远程帧由6个不同的位场组成，即帧起始、仲裁场、控制场、CRC场、应答场、帧结束。

3、错误帧，任何单元监测到错误时就发送错误帧。错误帧由两个不同的场组成。第一个场是错误标志，用做为不同站提供错误标志的叠加；第二个场是错误界
定符。

4、超载帧，节点需要增加时间来处理接收到的数据时便发送过载帧。超载帧包括两个位场：超载标志和超载界定符。


#+DOWNLOADED: http://space.ednchina.com/Upload/Blog/2008/6/12/b660798a-b6fd-4593-ac28-57296b8d63db.jpg @ 2016-01-26 17:27:06
 [[~/Wally/Journal/Figure/.org-download/can/b660798a-b6fd-4593-ac28-57296b8d63db_2016-01-26_17:27:06.jpg]]

                                                                图1 帧起始位

    CAN总线传输的起始帧如图1。帧起始标志数据帧或远程帧的起始，由一个单独的“显性”位（0）组成。由控制芯片完成。


#+DOWNLOADED: http://space.ednchina.com/Upload/Blog/2008/6/12/75b862fa-8f9f-400c-b630-20a642f6b249.jpg @ 2016-01-26 17:27:21
 [[~/Wally/Journal/Figure/.org-download/can/75b862fa-8f9f-400c-b630-20a642f6b249_2016-01-26_17:27:21.jpg]]

                                                             图2 标准数据帧格式

#+DOWNLOADED: http://space.ednchina.com/Upload/Blog/2008/6/12/e7054aa0-5ee2-4409-960d-77a63ba27934.jpg @ 2016-01-26 17:27:31
 [[~/Wally/Journal/Figure/.org-download/can/e7054aa0-5ee2-4409-960d-77a63ba27934_2016-01-26_17:27:31.jpg]]

                                                             图3 扩展数据帧格式

由图2和图3可以看到数据帧的两种不同格式，两种格式的差别只是它们的ID位数不同。

1、帧起始。

2、仲裁场，仲裁场包括标识符和远程发送请求位（RTR）。

  对于CAN2.0A标准，标识符的长度为11位。RTR位在数据帧中必须是显性位，而在远程帧必须为隐性位。

  对于CAN2.0，标准格式和扩展格式的仲裁场不同。在标准格式中，仲裁场由11位标识符和远程发送请求位组成。在扩展格式中，仲裁场由29位标识符和替代远
程请求位（SRR）、标志位（IDE）和远程发送请求位组成。

  仲裁场的作用之一是说明数据帧或远程帧发送目的地；之二是指出是数据帧还是远程帧。

3、控制场，控制场由6个位组成，说明数据帧中有效数据的长度。标准帧的最高位是IDE位，扩展帧的最高位是保留位RB1，它们的次高位都是保留位RB0。低四
位是DLC（Data Length Code）位，标识传送的数据字节数（0-8字节）。

4、数据场，数据场由数据帧中的发送数据组成。它可以为0-8个字节。

5、CRC场，CRC场包括CRC序列，这部分由SJA1000控制芯片完成。

6、应答场，应答场长度为两个位，包括应答间隙和应答界定符。由SJA1000控制芯片自动完成。

7、帧结束，每一个数据帧和远程帧均由一标志序列界定，这个标志序列由7个“隐性”位组成。这部分由SJA1000控制芯片自动完成。

仲裁场、控制场、数据场由软件编程配置SJA1000完成；帧起始、CRC场、应答场、帧结束由CAN总线控制芯片SJA1000自动完成。

**** 十、CAN的数据错误检测：

不同于其它总线,CAN协议不能使用应答信息。事实上,它可以将发生的任何错误用信号发出。CAN协议可使用五种检查错误的方法,其中前三种为基于报文内容检
查。

1、循环冗余检查(CRC)

在一帧报文中加入冗余检查位可保证报文正确。接收站通过CRC可判断报文是否有错。

2、帧检查

这种方法通过位场检查帧的格式和大小来确定报文的正确性,用于检查格式上的错误。

3、应答错误

如前所述,被接收到的帧由接收站通过明确的应答来确认。如果发送站未收到应答,那么表明接收站发现帧中有错误,也就是说,ACK场已损坏或网络中的报文无站
接收。CAN协议也可通过位检查的方法探测错误。

4、总线检测

有时,CAN中的一个节点可监测自己发出的信号。因此,发送报文的站可以观测总线电平并探测发送位和接收位的差异。

5、位填充

一帧报文中的每一位都由不归零码表示,可保证位编码的最大效率。然而,如果在一帧报文中有太多相同电平的位,就有可能失去同步。为保证同步,同步沿用位填
充产生。在五个生。在五个连续相等位后,发送站自动插入一个与之互补的补码位;接收时,这个填充位被自动丢掉。例如,五个连续的低电平位后,CAN自动插入一
个高电平位。CAN通过这种编码规则检查错误,如果在一帧报文中有6个相同位,CAN就知道发生了错误。

如果至少有一个站通过以上方法探测到一个或多个错误,它将发送出错标志终止当前的发送。这可以阻止其它站接收错误的报文,并保证网络上报文的一致性。当
大量发送数据被终止后,发送站会自动地重新发送数据。作为规则,在探测到错误后23个位周期内重新开始发送。在特殊场合,系统的恢复时间为31个位周期。

但这种方法存在一个问题,即一个发生错误的站将导致所有数据被终止,其中也包括正确的数据。因此,如果不采取自监测措施,总线系统应采用模块化设计。为此
,CAN协议提供一种将偶然错误从永久错误和局部站失败中区别出来的办法。这种方法可以通过对出错站统计评估来确定一个站本身的错误并进入一种不会对其它
站产生不良影响的运行方法来实现,即站可以通过关闭自己来阻止正常数据因被错误地当成不正确的数据而被终止。

6、CAN可靠性

为防止汽车在使用寿命期内由于数据交换错误而对司机造成危险,汽车的安全系统要求数据传输具有较高的安全性。如果数据传输的可靠性足够高,或者残留下来
的数据错误足够低的话,这一目标不难实现。从总线系统数据的角度看,可靠性可以理解为,对传输过程产生的数据错误的识别能力。

残余数据错误的概率可以通过对数据传输可靠性的统计测量获得。它描述了传送数据被破坏和这种破坏不能被探测出来的概率。残余数据错误概率必须非常小,
使其在系统整个寿命周期内,按平均统计时几乎检测不到。计算残余错误概率要求能够对数据错误进行分类 ,并且数据传输路径可由一模型描述。如果要确定CAN
的残余错误概率,我们可将残留错误的概率作为具有80～90位的报文传送时位错误概率的函数,并假定这个系统中有5～10个站,并且错误率为1/1000,那么最大位
错误概率为10—13数量级。例如,CAN网络的数据传输率最大为1Mbps,如果数据传输能力仅使用50%,那么对于一个工作寿命4000小时、平均报文长度为 80位的系统
,所传送的数据总量为9×1010。在系统运行寿命期内,不可检测的传输错误的统计平均小于10—2量级。换句话说,一个系统按每年365 天,每天工作8小时,每秒错误
率为0. 7计算,那么按统计平均,每1000年才会发生一个不可检测的错误。

CAN网络的基本理论.PDF （英文资料）  [[http://space.ednchina.com/Upload/Blog/2008/6/12/94a925ec-ced9-4996-aa57-116852631139.PDF][PDF     ]]

** PCI                                                                 :pci:
*** [[http://wiki.dzsc.com/info/7158.html][PCI总线的基本概念]]                 :blog:

PCI（Peripheral Component Interconnect）总线总线 的供应商是一种同步的
独立于处理器的32位或64位局部总线。从结构上看，PCI是在CPUCPU 的供应商和
原来的系统总线之间插入的一级总线，具体由一个桥接电路实现对这一层的管理，
并实现上下之间的接口以协调数据的传送。从1992年创立规范到如今，PCI总线
已成为了计算机的一种标准总线。 目录PCI总线的基本概念PCI总线的结构PCI总
线的特点PCI总线的主要功能PCI总线与VL-BUS的比较PCI总线


不同于ISA总线，PCI总线的地址总线与数据总线是分时复用的。这样做的好处是，
一方面可以节省接插件的管脚数，另一方面便于实现突发数据传输。在做数据传
输时，由一个PCI设备做发起者(主控，Initiator或Master)，而另一个PCI设备
做目标(从设备，Target或Slave)。总线上的所有时序的产生与控制，都由
Master来发起。PCI总线在同一时刻只能供一对设备完成传输，这就要求有一个
仲裁机构(Arbiter)，来决定在谁有权力拿到总线的主控权。　　当PCI总线进行
操作时，发起者(Master)先置REQ#，当得到仲裁器(Arbiter)的许可时(GNT#)，
会将FRAME#置低，并在AD总线上放置Slave地址，同时C/BE#放置命令信号，说明
接下来的传输类型。所有PCI总线上设备都需对此地址译码，被选中的设备要置
DEVSEL#以声明自己被选中。然后当IRDY#与TRDY#都置低时，可以传输数据。当
Master数据传输结束前，将FRAME#置高以标明只剩最后一组数据要传输，并在传
完数据后放开IRDY#以释放总线控制权。　　这里我们可以看出，PCI总线的传输
是很高效的，发出一组地址后，理想状态下可以连续发数据，峰值速率为
132MB/s。实际上，目前流行的33M@32bit北桥芯片一般可以做到100MB/s的连续
传输。

** USB                                                                 :usb:
*** USB 颜色

- https://www.google.com.hk/?gws_rd=ssl#newwindow=1&safe=active&q=USB+%E8%BF%9E%E7%BA%BF%E9%A2%9C%E8%89%B2

红线：电源正极（接线上的标识为：+5V或VCC）
白线：负电压数据线（标识为：Data-或USB Port -）
绿线：正电压数据线（标识为：Data+或USB Port +）
黑线：接地（标识为：GROUND或GND）

一般的排列方式是：红白绿黑从左到右

* board
* EmbeddedLinux                                               :embeddedlinux:
** Fundermental
*** 什么是嵌入式Linux

嵌入式的应用主要是几个方向：

1. 系统开发：侧重开发环境搭建、内核原理、 交叉编译等；
2. 嵌入式Linux应用开发：侧重Linux应用编程、内核编译、系统调用；
3. 底层驱动开发：侧重嵌入式Linux系统下的驱动开发、内核的深入分析。

不过初进门者主要往系统开发和应用开发发展，有了相关工作经验再进一步向底
层驱动靠。

1. linux理论知识

   1) 计算机基本理论；
   2) CPU体系结构；
   3) 内存管理；
   4) 文件系统；
   5) 进程调度；
   6) Linux常用操作

2. linux驱动知识

   1) i2c驱动添加使用；
   2) spi驱动添加和读写
   3) io驱动
   4) dma驱动
   5) 中断源
   6) 竞争，并发，阻塞，异步，线程，内存，io，调试
   7) usb
   8) flash，文件系统
   9) 网卡驱动
   10) LCD驱动

3. linux编程知识（指令）

   1) 输入输出，文件,文件夹
   2) 字符串,数据结构，堆栈，链表，（查找）算法，二叉树
   3) 线程: 线程属性，线程同步（锁，信号量， 条件变量）
   4) 进程：守候进程，进程通信－管道，信号，SystemV（消息，共享内存，信号灯），读写锁，套接字
   5) 网络：socket，ftp客户端，tftp客户端，http server，snmp命令
   6) 环境变量，库默认搜索路径，arm-linux-gcc库路径，设置搜索路径，编译流程，lds文件，内联汇编
   7) gcc ,ld, ar, ranlib, objdump, readelf,objcopy工具
   8) make makefile
   9) shell,perl
   10) 设备编程v4l，lcd和overlayer2，串口，并口， mixer, dsp, adc, ts，
       mouse等等

** booterloader                                                 :bootloader:
*** what's  next

[[~/Wally/Journal/Figure/scrot/5970lht.png]]

*** bootloader 设计蓝图
**** bootloader作用
bootloader -> kernel -> root filesystem

引导内核(助推)
**** bootloader设计方法
+ *模仿*

+ 设计从模仿开始。

+ *模仿经典*

**** uboot快速体验
[[~/Wally/Journal/Figures/scrot/5970yrz.png]]

+ 支持多种处理器
+ 支持多种嵌入式操作系统

**** u-boot代码工程建立
1. 自主模式
   uboot自动引导内核

2. 开发模式
   uboot命令 help

**** 建立uboot代码分析工程
*sourceinsight* 阅读代码软件

uboot源码


~/wally/journal/project/embeddedlinux/uboot

*** arm处理器启动流程

s3c2440 s3c6410 s5pv210
**** 2440
***** 启动方式
1. nor flash(2m)
2. nand flash(256m)
   - uboot
   - kernel
   - filesystem
***** 地址布局

手册： nand flash *memory mapping*

*处理器上电，从0地址处取第一条指令*

nand flash 没有统一编址
+ bootram(4k) 映射nandflash前4k, steppingstone
+ 其它部分复制到内存中

[[~/Wally/Journal/Figures/scrot/5970lbf.png]]

[[~/Wally/Journal/Figures/scrot/5970yll.png]]

内存起始地址： 0x3000, 0000

***** 启动流程
**** 6410
***** 启动方式
手册： booting

[[~/Wally/Journal/Figures/scrot/5970_vr.png]]

1. srom(nor)
2. onenand
3. modem
4. irom(internal rom)
   1) nand
   2) sd/mmc

***** 地址布局
[[~/Wally/Journal/Figures/scrot/5970m6x.png]]

1. irom 0x0800, 0000
2. dram 0x5000, 0000
3. 0地址： booting device region by xom setting
   - mirrored region（镜像区域，映射irom、dram设备）

***** 启动流程
s3c6410——internal_rom_booting.pdf

[[~/Wally/Journal/Figures/scrot/5970-db.png]]

**** 210

***** 启动模式
1. irom
   1. sd
2. 串口等

***** 地址映射
[[~/Wally/Journal/Figures/scrot/5970loh.png]]

1. irom
2. 0 address
3. dram

***** 启动过程
[[~/Wally/Journal/Figures/scrot/5970yyn.png]]

irom厂商固化

bl1 : bootloader 1,  max 16kb
bl2 : bootloader 2,  max 80kb

sram？？
sdram内存

* projects
** avrpro
#+INCLUDE: ~/Wally/Project/avrpro/README.md
#+INCLUDE: ~/Wally/Project/avrpro/ChangeLog.org

- [[~/Wally/Reference/Chip/MCU/Atmega16.pdf][Atmage16]]
- [[~/Wally/Reference/Manual/AvrdudeManual.pdf][AvrdudeManual.pdf]]
- [[~/Wally/Reference/Manual/AvrLibcUserManual-1.8.0.pdf][AvrLibcUserManual-1.8.0.pdf]]

*** LED

#+INCLUDE: ~/Wally/Project/avrpro/src/led/led1.c

#+BEGIN_SRC makefile
  led1.o:led1.c
          avr-gcc -mmcu=atmega16 -c led1.c
  led1.elf:led1.o
          avr-gcc -mmcu=atmega16 -o led1.elf led1.o
  led1.hex:led1.elf
          avr-objcopy -j .text -j .data -O ihex led1.elf led1.hex
  .PHONY:upload
  upload:led1.hex
          sudo avrdude -p m16 -c usbasp -e -U flash:w:"led1.hex"
#+END_SRC

/编译烧录成功，但是没有效果！？/

**** 手记
#+BEGIN_EXAMPLE
  led $ cat makefile
  led1.o:led1.c
          avr-gcc -mmcu=atmega16 -c led.c
  led1.elf:ledl.o
          avr-gcc -mmcu=atmega16 -O led1.elf led1.o
  led1.hex:led1.elf
          avr-objcopy -j .text -j .data -O ihex led1.elf led1.hex
  led $ make led1.o
  avr-gcc -mmcu=atmega16 -c led.c
  avr-gcc: error: led.c: 没有那个文件或目录
  avr-gcc: fatal error: no input files
  compilation terminated.
  make: *** [led1.o] 错误 1
  led $ make led1.o
  avr-gcc -mmcu=atmega16 -c led1.c
  In file included from led1.c:2:0:
  /usr/lib/avr/include/util/delay.h:90:3: warning: #warning "F_CPU not defined for <util/delay.h>" [-Wcpp]
   # warning "F_CPU not defined for <util/delay.h>"
     ^
  /usr/lib/avr/include/util/delay.h:95:3: warning: #warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed" [-Wcpp]
   # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
     ^
  led $ ls
  led1.c  led1.o  makefile  makefile~
  led $ make led1.elf
  make: *** 没有规则可以创建“led1.elf”需要的目标“ledl.o”。 停止。
  led $ make led1.elf
  avr-gcc -mmcu=atmega16 -O led1.elf led1.o
  avr-gcc: error: led1.elf: 没有那个文件或目录
  make: *** [led1.elf] 错误 1
  led $ make led1.elf
  avr-gcc -mmcu=atmega16 -O led1.elf led1.o
  avr-gcc: error: led1.elf: 没有那个文件或目录
  make: *** [led1.elf] 错误 1
  led $ make led1.elf
  avr-gcc -mmcu=atmega16 -o led1.elf led1.o
  led $ ls
  led1.c  led1.elf  led1.o  makefile  makefile~
  led $ make led1.hex
  avr-objcopy -j .text -j .data -o ihex led1.elf led1.hex
  avr-objcopy：无效选项 -- o
  用法：avr-objcopy [选项] 输入文件 [输出文件]
   复制二进制文件，可能在此过程中进行变换
   选项为：
    -I --input-target <bfdname>      Assume input file is in format <bfdname>
    -O --output-target <bfdname>     Create an output file in format <bfdname>
    ...
  avr-objcopy：支持的目标： elf32-avr elf32-little elf32-big srec symbolsrec verilog tekhex binary ihex
  make: *** [led1.hex] 错误 1
  led $
  led $ make led1.hex
  avr-objcopy -j .text -j .data -O ihex led1.elf led1.hex
#+END_EXAMPLE

* PROGESS                                                          :PROGRESS:
** NEXT AVR/51
SCHEDULED: <2016-03-09 三 19:30 +1w>
:LOGBOOK:
- State "NEXT"       from "TODO"       [2016-03-04 五 21:29] \\
  计划制定完成
- State "TODO"       from ""           [2016-03-04 五 21:09]
:END:

*** Reference

- [[~/Document/Course/AVR开发板/EM3_V3.0原理图.pdf][开发板原理图]]
- [[http://www.avrvi.com/index_avr.html][AVR系列教程]]
- [[~/Wally/Reference/Textbook/AVR单片机嵌入式系统原理与应用实践.pdf][AVR单片机嵌入式系统原理与应用实践.pdf]]

*** 千里之行

按单片机例程来

#+include: ~/Document/Course/AVR开发板/51单片机例程

1. [ ] 整理 AVR 开发的整个流程, 以及 完成 LED 实验
2. [ ] 2, 3, 4
3. [ ] 5, 6, 7
4. [ ] 8, 9, 10
5. [ ] 11, 12, 13
6. [ ] 14, 15, 16
7. [ ] 17, 28, 19
8. [ ] 20, 21, 22
9. [ ] 23, 24, 25
10. [ ] 26, 27, 28

** TODO RaspberryPi
SCHEDULED: <2016-03-11 五 19:30 +1w>
:LOGBOOK:
- State "TODO"       from ""           [2016-03-04 五 22:01] \\
  整理资料与制定计划
:END:
*** Reference

- [[https://www.raspberrypi.org/][Homepage]]
- [[https://zh.wikipedia.org/wiki/%E6%A0%91%E8%8E%93%E6%B4%BE][Wiki]]
-

*** 千里之行
*** INBOX

1. [X] 盒子和配件
2. [ ] gpio使用
3. [ ] 各种通信 uart，i2c, isp
4. [ ] 交叉编译环境ubuntu下
5. [ ] 裸板，即不接显示器、鼠标、键盘、网线等
6. [ ] 与arduino相连
7. [ ] 按键等控制ros等
8. [ ]

*** NOTE

1. 不要瞎折腾，用不着的东西不要装
2. 使用 vi，不要装 emacs
3. 不要过人热衷，先消停几天，十二月份再玩(2015/11/22)
4. ros也要精简，绝对不要尝试gui

*** Intro                                                           :intro:

树莓派（英语： *Raspberry Pi* ），是一款基于Linux系统的只有信用卡大小
的单板机电脑。

[[/home/wally/Wally/Journal/Figure/scrot/5070Ejz.png]]

1. 单板机电脑
2. 体积小： 85x54(B+)

**** 配置与资源

+ CPU :: ARM CortexA7-四核 900MHz

+ 内存 :: 512M(B+)

+ 接口 ::

  - USB: 4个，支持Hub
  - Ethernet
  - HDMI
  - GPIO： 通用IO，8+
  - UART
  - I2C
  - SPI: 2个带地
  - 电源引脚： 3.3v, 5v
  - HAT规格铺设

+ 存储 ::

  - SD
  - MMC
  - SDIO/MicroSD卡插槽

+ 支持系统 ::

  - Debian
  - ArchLinux
  - OpenWrt
  - *Raspbian* （自带系统，基于Linux）

+ 型号 :: A, A+, B,  B+, B2

*** intallation

**** 安装 Raspbian                                               :install:

1. 参考文献的选择

   1) 有官网的教程优先考虑
   2) 有国外的教程优先考虑
   3) 国内的博客教程等要慎重选择

2. sd卡的分区和格式化处理

   - df -h
   - sudo fdisk -l
   - sudo fdisk =/dev/sdb=
   - mkfs.vfat 需要格式化成fat文件系统，分区之后为linux文件系统

3. 参考

   + [[http://qdosmsq.dunbar-it.co.uk/blog/2013/06/noobs-for-raspberry-pi/][NOOBS For Raspberry Pi 2b]]
   + [[https://app.yinxiang.com/shard/s52/nl/11551545/57510d93-2c8b-488c-9a5c-e0db65c720dd?title=ubuntu%20%e5%ae%89%e8%a3%85%20raspbian%20%e5%88%b0%20raspberry%20pi%20b%2b%20-%20wiki][Ubuntu 下安装 Raspbian 到 Raspberry 中]]

**** [[http://www.programgo.com/article/30302508918/][树莓派(raspberry pi) 系统在SD卡上安装Linux]]                     :blog:

刚刚拿到一只Simon同学出借的树莓派(raspberry pi)
，准备一张4GB的SD卡，准备跑一下Linux。

在Windows 7上用
工具 [[https://launchpad.net/win32-image-writer/+download][Win32DiskImager]]写入img到SD卡上，报错，失败。

好在俺有Linux vmware虚拟机，在虚拟机上搞，执行命令 sudo dd bs=1M
if=2012-12-16-wheezy-raspbian.img  of=/dev/sdb

错误：接电启动树莓派，派上只有红色的Power灯亮，HDMI电视机上没有输出。

原因：在Linux上执行dd命令的时候，应该是把操作系统镜像写到SD卡（硬盘上），
而不是写到某个硬盘分区上。of=/dev/sdb
误写成 of=/dev/sdb1了。

当时写完后，我还纳闷呢，怎么Linux  fdisk上这个SD卡还显示只有一个vfat分
区，而不是多个Linux分区呢。

解决办法：首先fdisk /dev/sdb，删除vfat分区；然后执行dd命令写入镜像  sudo
dd bs=1M if=2012-12-16-wheezy-raspbian.img of=/dev/sdb

# Raspian安装Chrome

1. wget http://goo.gl/go5yx -O install.sh
2. chmod a+x install.sh
3. ./install.sh
4. chrome -disable-ipv6 & (& for running at background)
5. error loading libsmime3.so->try sudo apt-get update then redo step
   3

# Raspian安装中文输入法SCIM (Smart Common Input Method)

1. sudo apt-get install scim-pinyin
2. if some packages can't be downloaded.  try sudo apt-get update
---fix-missing
3. run scim and it will run wihle booting.

#切换到root
$ sudo -s

**** [[http://jingyan.eeboard.com/article/14464][不同操作环境下如何将Raspbian安装到SD卡]]                         :blog:

Raspberry Pi
已经出了一段时间，有相当多的方法将Raspbian安装到你的SD卡。无论你使用Windows，Mac
OS
X或Linux，这篇文章的目的，我们将用非常通用的方法来教你实现它。具体而言，我们将使用dd工具来实现。

***** 如果你使用的是Mac

为了简单起见，我们建议您先清除您的下载文件夹，然后再开始。Raspbian.zip
文件可以从这个[[http://uk.rs-online.com/web/generalDisplay.html?id=raspberrypi][网址]] 下载。一旦你解压映像软件文件后，你需要一个终端应用
程序。

假设你使用的是OS X
10.7或更高版本，可以从应用程序启动它，一旦终端应用程序的启动运行，通过
“cd〜/下载”命令来打开你的下载文件夹：

你现在应该有至少两个文件在您的下载文件夹中。通过键入"ls”来验证“img”文件和"zip”文件是否存在。

接下来让我们看看如何将镜像文件文件放到SD卡。首先，在插入SD卡之前我们需要了解设备的使用情况。

在终端应用程序中键入：“df-h”。您应该会看到一些像这样的输出：


现在，插入你的SD卡并重新运行上面的命令，并注意新的“/
dev/disk1s1”行。这个方便的 - 你需要将其转换为一个原始磁盘的名称。

接下来，我们需要卸载该卷，“DD”工具可以将镜像写入SD卡。这可以通过“sudo
diskutil unmount/ dev/disk1s1”命令。你会得到提示输入系统密码，输入即可。

您现在应该看到最后一行的“卸载卷XXX”，“XXX”是你的卡的名称。现在，我们终于可以将Raspbian.img文件写到SD卡上了。
现在是时候进行转换。无论你的磁盘命名如何（例如，/
dev/disk1s1），去掉“s1”，在“disk”前面加“r”，变成了“/ dev/rdisk1”。
所以，举例来说，“/ dev/disk1s1”=“/ dev/rdisk1”。

然后键入以下内容：“sudo dd bs=1m if=2012-06-15-wheezy-raspbian.img
of=/dev/ YOURDISKNAME"。替换为您的实际原始磁盘名称。

这将需要一段时间来完成。我们可以用“dd”命令，通过将磁盘镜像拖到桌面垃圾箱进行SD卡的安全卸载。这样我们的准备工作就完成了！

***** 如果你用的是Linux

无论你使用的是Linux发行版，请确保有“dd”的工具。 我们在这里假设：
1）有sudo的配置，并熟悉它。 2）安装了fdisk。

我们在Ubuntu进行了测试。从 [[http://www.raspberrypi.org/downloads][这个位置]] 下载Raspbian.zip文件压缩到你主目录
并解压。

启动你的Linux机器上的终端，通过“cd”命令访问你的主目录。键入“unzip
imagename.zip”，您刚刚下载的镜像取代“imagename”。


接下来，我们需要确定您的SD卡目前正在使用的设备名称。插入您的SD卡，输入“sudo
fdisk-L”。

请注意上图中列出的设备

我们的设备是“sdb”，15.9GB的空间。请记下“/ dev /
sdb”下面列出的设备，为了安全写入镜像你要卸载他们。我们看到“/
dev/sdb1”和“/ dev/sdb2”，所以我们运行： sudo umount/ dev/sdb1

sudo umount / dev/sdb2

现在用“dd”工具来写入我们镜像。键入“sudo dd bs
=1M=2012-08-16-wheezy-raspbian.img of= / dev /
sdb”。和上面Mac环境下一样，这将需要几分钟的时间才能完成。

如果你看到如上图所示，那就成功了！

***** 在 Windows环境下

先在Windows系统里安装Win32DiskImager应用程序，Win32DiskImager你可以在
[[http://www.softpedia.com/get/CD-DVD-Tools/Data-CD-DVD-Burning/Win32-Disk-Imager.shtml][这里]] 或 [[https://launchpad.net/win32-image-writer][这里]] 下载。下载好以后我们继续下载Raspbian镜像，从 [[http://www.raspberrypi.org/downloads][这个地方]] 下
载。

Win32DiskImager和Raspbian下载完成后，我们需要解压缩。为了方便，将这两
个文件放到桌面上或一个文件夹里。接着将win32diskimager-binary.zip和
2012-08-16-wheezy-raspbian.zip两个文件解压缩。

然后将SD卡插入读卡连接到电脑，双击Win32DiskImager。

Win32DiskImager加载的时候你会看到一个错误（在Windows 7环境下），如下图：

单击“确定”，应用程序将继续加载。

点击蓝色的文件夹图标，选择Raspbian镜像文件，并确保列出的设备名称与SD卡驱动器盘符相同。

打开你的镜像文件，单击“Write”，“Yes”确认，然后稍等一会。

当镜像写好后，会弹出下图窗口，接下来你就可以安全退出你的SD卡了。

如果你在你的SD卡在写镜像的过程中卡住了，你可以来 [[http://elinux.org/RPi_Easy_SD_Card_Setup][这里]] 寻求解决办法。

**** [[http://wiki.guoruei.org/computer/software/linux/ubuntu-dd-raspbian-to-raspberry-pi-plus][Ubuntu 安装 Raspbian 到 Raspberry Pi B+]]
*** application
**** rasp-config

1. 语言、时区、键盘
2. 用户及密码
3. 登录方式

**** ssh 远程登录到 raspberry                                   :手记:ssh:

ssh pi@192.168.1.25

1. ssh-server (sshd) 默认在 raspberry pi 中启动，所以不用设置

2. 默认的，ssh 会尝试用当前用户作为用户名来连接。所以，需要指定用户名
   pi

3. 先 ping

   #+BEGIN_EXAMPLE
   ping 192.168.1.25
   #+END_EXAMPLE

**** 设置静态 IP                                                 :手记:ip:

+ http://www.cnblogs.com/keygle/archive/2013/04/27/3048273.html


1. 按照 http://www.cnblogs.com/keygle/archive/2013/04/27/3048273.html
   失败，启动时有问题，进入系统后没有自动连接网

2. 尝试只修改一句,  not ok

   #+BEGIN_EXAMPLE
   iface eth0 inet manual
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
   iface eth0 inet static
   address 192.168.1.27
   #+END_EXAMPLE

3. 系统使用的 wpa
   #+BEGIN_EXAMPLE
   wpa-conf /etc/wpa_supplicant/wap_supplicant.conf
   #+END_EXAMPLE

   其内容

   #+BEGIN_EXAMPLE
     network={
             ssid="A409"
             psk="A409A409A409"
             key_mgmt=WPA-PSK
     }
   #+END_EXAMPLE

4. 不重启系统，而是重启 network

   #+BEGIN_EXAMPLE
   sudo service networking restart
   #+END_EXAMPLE

5. 使用默认的配置，manual 还是动态的

   IP: 192.168.1.25

6. 配置

   #+BEGIN_EXAMPLE
     auto wlan0
     allow-hotplug wlan0
     iface wlan0 inet manual
     wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf
     iface wlan0 inet static
             address 192.168.1.25
             netmask 255.255.255.0
             gateway 192.168.1.1
   #+END_EXAMPLE

   - 桌面任务栏上显示的与 ifconfig 不一致，与后者为准。
   - 可以了，尽管还没有完全配置好

**** 使用蓄电池供电

5V 蓄电池 + 手机 USB 数据线，测试 OK

LED 的指示状态？？？

**** 挂载 NFS                                                   :nfs:手记:

问题

#+BEGIN_EXAMPLE
  ~ $ sudo mount -t nfs 192.168.1.3:/home/ben/Wally/Project/catkin_ws catkin_ws/
  mount.nfs: rpc.statd is not running but is required for remote locking.
  mount.nfs: Either use '-o nolock' to keep locks local, or start statd.
  mount.nfs: an incorrect mount option was specified

#+END_EXAMPLE

解决

#+BEGIN_EXAMPLE
 sudo service rpcbind restart
#+END_EXAMPLE

**** NEXT 自动登录，无需密码

- State "NEXT"       from ""           [2015-12-25 五 16:15] \\
  1. 不便用 GUI 方式设置，使用命令行方式配置
  2. 不登录到 X 桌面，GUI设置中有，但先不尝试

在  raspberry configure 中设置 Autolog

+ http://blog.csdn.net/swliao/article/details/5989203

**** headless

https://www.raspberrypi.org/forums/viewtopic.php?f=91&t=74176

*** ROS
**** 安装ROS

- [[http://wiki.ros.org/ROSberryPi/Installing%20ROS%20Indigo%20on%20Raspberry%20Pi][ROS wiki: Installing ROS indigo on the Paspberry Pi]]
- [[http://wiki.ros.org/indigo/installation/ubuntuarm][ROS wiki: Install ArmUbuntu]]
- [[http://blog.csdn.net/crazyquhezheng/article/details/43413231][blog 东方赤龙：树莓派编译安装完整版ROS]]
- [[http://blog.csdn.net/hcx25909/article/category/1759051][blog 古月居： 树莓派Linux驱动学习系列（不多3篇，仅入门）]]


1. 系统要求： Raspbian
2. 方式： 源码方式

** TODO ARM/EmbeddedLinux
SCHEDULED: <2016-03-14 一 19:30 +1w>
:PROPERTIES:
:LAST_REPEAT: [2016-03-09 三 09:51]
:END:
:LOGBOOK:
- State "FAIL"       from "TODO"       [2016-03-09 三 09:51]
- State "TODO"       from ""           [2016-03-04 五 21:59] \\
  回顾整个流程并制定计划
:END:

board: TQ2440

*** Reference
*** 千里之行

- [ ] 整理笔记与参考资料

*** 开发板
**** 系统资源

[[~/Wally/Journal/Figure/scrot/5070dLV.png]]

1. 处理器：s3c2440a. arm9
   + 主频400m,  最高533m
   + 内存64m

2. 存储
   + nor flash(2m): 容量小，运行快，价格高
   + nand flash(对应硬盘): 256m
   + sd插槽

3. 接口资源
   + 用户可编程led
   + 用户可编程按键
   + lcd及接口: 4.3寸
   + 音频输入输出
   + gpio：40
   + usb接口： 主/从
   + rs232串口
   + rj45网口
   + jtag
   + 系统总线（什么总线？）
   + cmos

**** 启动方式

+ nor flash
+ nand flash
+ 开关设置

*** 开发工具链

1. 编辑器 Emacs
2. 编译 gcc-arm
3. 烧录 gtag + openocd
4. 调试 gbd-arm
5. 仿真 暂不需要(2016/03/07)

*** 操作系统相关

+ linux: 30m左右
+ wince:
+ 安装位置： nand flash
+ 安装方式：
  1. jtag烧写引导程序到nor flash
  2. 使用usb下载线下载操作系统到内在中
  3. 把操作系统安装到nand flash

**** 安装系统安装

1. 软件构成
   1) bootlaoder
   2) linux
   3) 文件系统

2. 安装步骤
   1) 使用 jtag 将 引导安装程序 下载到 nor flash
   2) 使用 usb下载线 将操作系统 安装到 nand flash中

3. jtag
   + 嵌入式开发使用交叉开发模型：  宿主机/目标机
   + *jtag常用来对flash等器件进行编程* ， 按连接方式分
     - 并口
     - usb， *jlink*
   + 步骤
     - 选择nor flash启动
     - 连接jlink
     - 打开电源

   + 工具
     - windows: segger:
       - 连接
       - file->open project: *2440.flash* 工程配置文件
       - target -> erase
       - file -> open : uboot(bootloader)
       - target -> program
       - 完成后重启并拔掉jlink线
     - linux:

*** LED                                                               :led:

#+INCLUDE: ~/Wally/Project/TQ2440/led

**** why led

初始化完成之前调试手段有限，通常会采用 LED 作为程序的调试的手段

**** 原理图

1. 常见驱动电路

   [[~/Wally/Journal/Figure/scrot/24567auk.png]]

2. GPIO

   [[~/Wally/Journal/Figure/scrot/24567n4q.png]]

   General Purpose Input/Output Ports 通用可编程I/O端口

   两个寄存器

   1) 控制寄存器： 控制作为输入还是输出

   2) 数据寄存器

3. /先设计，而不是直接写程序/

4. TQ2440 引脚

   - nLED_1: GPB5
   - nLED_2: GPB6
   - nLED_3: GPB7
   - nLED_4: GPB8

**** src

#+INCLUDE: ~/Wally/Project/TQ2440/led/led.S
**** openocd config & connect

1. 配置文件

   #+INCLUDE: ~/.openocd/tq2440.cfg

2. openocd

   #+BEGIN_EXAMPLE
   $ openocd -f tq2440.cfg
   #+END_EXAMPLE

3. gdb调试还不行

**** makefile

#+INCLUDE: ~/Wally/Project/TQ2440/led/Makefile

1. arm-linux-gcc -g -o led.o -c led.S

2. arm-linux-ld -Tled.lds -o led.elf led.o

3. arm-linux-objcopy -O binary led.elf led.bin

**** 烧录

*halt -> probe -> write -> resume*

#+BEGIN_EXAMPLE
  > halt
  target state: halted
  target halted in ARM state due to debug-request, current mode: Supervisor
  cpsr: 0x200000d3 pc: 0x0235a224
  MMU: disabled, D-Cache: disabled, I-Cache: disabled
  > nand write 0 /home/wally/Wally/Project/TQ2440/led/led.bin 0
  #0: not probed
  wrote file /home/wally/Wally/Project/TQ2440/led/led.bin to NAND flash 0 up to offset 0x00000000 in 1452519424.000000s (0.000 KiB/s)
  > nand probe 0
  NAND flash device 'NAND 256MiB 3.3V 8-bit (unknown)' found
  > nand write 0 /home/wally/Wally/Project/TQ2440/led/led.bin 0
  wrote file /home/wally/Wally/Project/TQ2440/led/led.bin to NAND flash 0 up to offset 0x00000800 in 2.116011s (0.098 KiB/s)
#+END_EXAMPLE

*** TODO initialization
- State "TODO"       from ""           [2016-01-11 一 21:39] \\
  烧录
**** Exception

***** 异常类型

[[~/Wally/Journal/Figures/scrot/24567mMA.png]]

***** 异常向量

当一种异常发生的时候，ARM处理器会跳转到对应该异常的固定地址去执行异常
处理程序，而这个固定的地址，就称之为 /异常向量/ 。

两组： CP15 协处理器配置为高位时，选择后者。一般都使用前一组。

***** 异常向量表

由七个异常向量及其处理函数跳转关系组成的表即为异常向量表.

#+BEGIN_SRC asm
  _start
    0x00000000: b reset
    0x00000004: ldr pc, _undefined_instruction
    0x00000008: ldr pc, _software_interrupt
    0x00000008: ldr pc, _software_interrupt
    0x0000000c: ldr pc, _prefetch_abort
    0x00000010: ldr pc, _data_abort
    0x00000014: ldr pc, _not_used ; 占位
    0x00000018: ldr pc, _irq
    0x0000001c: ldr pc, _fiq
#+END_SRC

***** 代码

****** start.S
#+include: ~/Wally/Journal/Project/ARM/init/start.S :src asm

****** gboot.lds 链接器脚本
#+include: ~/Wally/Journal/Project/ARM/init/gboot.lds

****** makefile
#+include: ~/Wally/Journal/Project/ARM/init/makefile :src makefile

****** 210 加头

check sum

[[~/Wally/Journal/Figures/scrot/24567zWG.png]]

[[~/Wally/Journal/Figures/scrot/24567AhM.png]]

**** 设置 scv 模式

***** how

[[~/Wally/Journal/Figures/scrot/24567NrS.png]]

Linux/bootloader 工作在 Supervisor(/svc/) 模式

通过程序状态寄存器(/CPSR/)设置 (M[4:0])

[[~/Wally/Journal/Figures/scrot/24567a1Y.png]]

***** 步骤

1) 清零： bic
2) 置1: orr
3) /MRC/ /MSR/ 指令

***** code

#+include: ~/Wally/Journal/Project/ARM/init/start.S :src asm

#+BEGIN_SRC asm
  reset:
          mrc r0, cpsr
          bic r0, r0, #0x1f       ; 清零
          orr r0, r0, #0x13       ; 置一, 0xd3 同时设置 中断和快速中断
          msr cpsr, r0
#+END_SRC
**** 关闭看门狗
***** watchdog

在嵌入式领域，有些系统需要长期运行在无人看守的环境。在运行过程中，难免
不出现系统死机的情况，这时就需要系统自身带有一种自动重启的功能。
/watchdog/ 一般是一个 *硬件模块* ，其作用就是 _在系统死机时，帮助系统
实现自动重启_

***** 工作方式

Watchdog在硬件上实现了 /计时/ 功能，启动计时后，用户（软件）必须在计时结束
前重新开始计时，俗称“ /喂狗/ ”， _如果到超时的时候还没有重新开始计时，
那么它就认为系统是死机了，就自动重动系统_

***** 硬件电路

[[~/Wally/Journal/Figures/scrot/24567n_e.png]]

1. 分频: Prescaler
2. 计数: Down Counter
3. RESET

***** why 关闭看门狗

bootloader 功能比较简单。 不需要循环 喂狗。

***** how: WTCON: watchdog timer control register

[[~/Wally/Journal/Figures/scrot/24567Oex.png]]

***** code

#+include: ~/Wally/Journal/Project/ARM/init/start.S :src asm

#+BEGIN_SRC asm
  #define pWTCON 0x53000000       ; address of watch dog
  disable_watchdog:
          ldr r0, =pWTCON
          mv r1, #0x0
          str r1, [r0]
#+END_SRC

**** 关闭中断

***** how
1. CPSR: I位(中断)、 F位(快速中断) 置1
2. 中断屏蔽寄存器: /INTMASK/:INTERRUPT MASK (INTMSK) REGISTER(2440)

   [[~/Wally/Journal/Figures/scrot/24567AoA.png]]

3. 向量中断6410/240: INTERRUPT ENABLE REGISTER(使能)， /VIC0INTENCLEAR/

***** code
#+include: ~/Wally/Journal/Project/ARM/init/start.S :src asm

**** 关闭 MMU 与 Cache

***** 存储体系

[[~/Wally/Journal/Figures/scrot/24567NyG.png]]

1. 内部寄存器： 速度快，数量少
2. TCM: Cache
3. 辅助存储器： Flash, SD

***** cache

[[~/Wally/Journal/Figures/scrot/24567a8M.png]]

Cache是一种容量小但存取速度非常快的存储器，它保存最近用到的存储器中数
据的拷贝。对于程序员来说，Cache是透明的。它自动决定保存哪些数据、覆盖
哪些数据。按照功能划分

+ /I-Cache/: 指令Cache，用于存放指令
+ /D-Cache/: 数据Cache，用于存放数据

从手册中查阅

[[~/Wally/Journal/Figures/scrot/245670QZ.png]]

***** 虚拟地址

+ /物理地址/: 物理存储单元实际的地址
+ /虚拟地址/: 程序中使用的地址, 映射为物理地址(/MMU/)
  -可以让进程使用更大的空间
  -可以解决冲突

***** MMU

[[~/Wally/Journal/Figures/scrot/24567Bbf.png]]

注： arm11 前后区别

***** code

#+include: ~/Wally/Journal/Project/ARM/init/start.S :src asm

/CP15/ ARM920T

1. 全 I-Cache D-Cache 失效
2. 关闭 I/D-Cache 和 MMU

** TODO Arduino                                                    :arduino:
SCHEDULED: <2016-03-13 日 19:30 +1w>
:PROPERTIES:
:LAST_REPEAT: [2016-03-06 日 22:43]
:END:
:LOGBOOK:
- State "FAIL"       from "TODO"       [2016-03-06 日 22:43]
- State "TODO"       from ""           [2016-03-04 五 21:58] \\
  计划制定完成
:END:
*** Reference                                  :homepage:github:wiki:forum:

+ [[https://github.com/arduino/arduino][GitHub]]
+ [[http://www.arduino.cc/][Homepage]]
+ [[http://zh.wikipedia.org/wiki/arduino][Wiki]]
+ [[http://www.arduino.cn/thread-1066-1-1.html][forum]]
+ [[http://www.flamingoeda.com/category/tutorial/][tutorials(中)]]
+ [[http://www.ladyada.net/learn/arduino/][tutorials(en)]]
+ [[~/Wally/Reference/Textbook/ArduinoCookbook_En.pdf][ArduinoCookbook_En.pdf]]

*** 千里之行

Arduino Cookbook(先整体阅读每个章节)

- [ ] 整理笔记以及C1, C2
- [ ] C3, C4
- [ ] C5, C6
- [ ] C7, C8
- [ ] C9, C10
- [ ] C11, C12
- [ ] C13, C14
- [ ] C15, C16
- [ ] C17, C18

*** INBOX
*** NOTE
*** intro                                                           :intro:

arduino，是一个 *开放源代码* 的单芯片微控制器，它使用了atmel *avr* 单
片机，采用了基于开放源代码的软硬件平台，建构于简易输出/输入（simple
i/o）界面板，并且具有使用类似java、c语言的 *processing/wiring* 开发环
境。

读音： a de v no

**** features

+ *开源*

  - 基于知识共享开放源代码 的电路图设计。
  - 免费下载，也可依需求自己修改，但需遵照姓名标示。您必须按照作者或授
    权人所指定的方式，表彰其姓名。
  - 依相同方式分享，若您改变或转变著作，当散布该衍生著作时，您需采用与
    本著作相同或类似的授权条款。


+ arduino 可使用 icsp 线上烧入器，将 bootloader 烧入新的 ic 芯片。

+ 可依据arduino官方网站，取得硬件的设计档，加以调整电路板及元件，以符
  合自己实际设计的需求。

+ 可简单地与感测器，各式各样的电子元件连接，如 红外线、超音波、热敏电
  阻、光敏电阻、伺服马达…等。

+ 支援多样的互动程式，如 adobe flash, max/msp, vvvv, pure data, c,
  processing… 等。

+ 使用低价格的微处理控制器 (atmel avr) (atmega 8,168,328等)。

+ usb 界面，不需外接电源。另外有提供直流(dc)电源输入。

**** arduino family(型号)

+ arduino *uno* 基本
+ arduino mini/pro mini  体积小
+ arduino *mega* 处理器强大，功能多
+ arduino lilypad 可穿戴的应用设计
+ arduino fio  无线项目设计
+ arduino pro 嵌入式应用设计

**** install                                                     :install:

+ [[https://code.google.com/p/arduino/wiki/buildingarduino][Building Arduino]]

***** apt(推荐)

#+BEGIN_EXAMPLE
apt-get install arduino
#+END_EXAMPLE

***** source code                                               :compile:

1. grap from github
2. cd /path/to/arduino/build
3. ant
4. ant run

*** about power
**** power suppply style

arduino boards can be supplied in three different ways:
+ by our computer via the usb cable (5 v is provided)
+ by a battery or a direct external power supply unit (psu) / adapter
+ by attaching a regulated 5 v to the +5 v pin

**** dc adapter requirements

arduino uno and mega can be directly supplied by dc adapter but
this one has to respect some characteristics:

+ the output voltage should be between 9 v and 12 v
+ it should be able to drive at least 250 ma of current
+ it must have a 2.1 mm power plug with center positive

**** when dc adapter?

usually, if you ask yourself about the fact whether to use an adapter or not, it means
you need more current than the usb's 500 ma (practically, ask yourself this question
whether you need around 400 ma).

*** syntax
**** arduino & c & c++

Arduino toolchain is based on C.

Almost all arduino *libraries* are made *using c++* in order to be
easily *reusable*,which is one of the most important qualities in
programming.

**** boolean                                                    :boolean:
*boolean* : true/false 区分大小写

操作
+ && logical and
+ || logical or
+ ! logical not
+ if()

**** map                                                             :map:

*map(value, fromlow, fromhigh, tolow, tohigh)*

description
re-maps a number from one range to another. that is, a value of
fromlow would get mapped to tolow, a value of fromhigh to tohigh,
values in-between to values in-between, etc.

参考： [[https://www.arduino.cc/en/reference/map][arduino reference: map]]

**** [[http://blog.csdn.net/yuzhongchun/article/details/11537829][Arduino的数据类型]]                                     :blog:datatype:

# 数据类型         字节     范围                            备注
| void          |      |                              | 只用作函数声明，表示没有返回值              |
| boolean       |      | true,false                   | 每一个布尔变量占一个字节的内存              |
| char          |    1 | -128~127                     |                                             |
| unsigned char |    1 | 0~255                        |                                             |
| byte          |    1 | 0~255                        |                                             |
| int           |    2 | -32768~32767                 | 在Arduino Due上是4个字节                    |
| unsigned int  |    2 | 0~65535                      |                                             |
| word          |    2 | 0~65535                      |                                             |
| long          |    4 | -2147483648~2147483647       |                                             |
| unsigned long |    4 | 0~2\^32-1                    |                                             |
| short         |    2 | -32768~32767                 |                                             |
| float         |    4 | -3.4028235E+38~3.4028235E+38 | 只有6~7位小数精度                           |
| double        |    4 |                              | 在Arduino Due上有8个字节，其余的跟float一样 |
| string        |      |                              | 相当于char类型的数组                        |
| String        |      |                              | object                                      |
| array         |      |                              | 数组                                        |

参考：[[http://arduino.cc/en/Reference/HomePage][http://arduino.cc/en/Reference/HomePage]]

*** Libraries
**** some very useful included libraries

- eeprom :: provides functions and classes to read/write in hardware
     storage components. it is very useful to store something beyond
     the power state of the arduino, that is, even when the power is
     off.

- ethernet :: helps to make layer 2 and layer 3 communications over an
     ethernet network.

- firmata :: is used for serial communication.

- sd :: provides an easy way to read/write sd cards; it is a more
     user-friendly alternative to the eeprom solution.

- servo :: helps to control servo motors.

**** some external libraries

- tlc5940 :: used to control a 16-channel, 12-bit led controller
     smoothly

- mstimer2 :: used to trigger an action that has to be very fast and
     even each 1 ms (this library is also a nice hack of one of the
     hardware timers included inthe chipset)

- tone :: used to generate audible square waves

*** serial communication

**** serial commnication with arduino

each arduino board has at least one serial port. it can be used by using digital
pins 0 and 1, or directly using the usb connection when you want to use serial
communication with your computer.

on the arduino board, you can read rx and tx on both digital pins 0 and 1
respectively. *tx* means transmit and *rx* means receive; indeed, the most basic serial
communication requires two wires.

**** serial monitoring

for *trace* for debugging

**** serial functions

+ serial.begin()
+ serial.print(val) serial.print(val, format)
+ serial.println()

**** 小结

1. 串口在开发板上对应的针与指示
2. 库函数与配置(?)

*** servo                                                             :servo:
**** servo demo

#+BEGIN_SRC cpp
  #include <servo.h>

  servo myservo;                  /* sevo object */

  int angle = 0;

  void setup()
  {
    //  myservo.attach(9);                /* attaches the servo on pin 10 */
    myservo.attach(9, 250, 3000);
  }

  void loop()
  {
    for(angle=0; angle<180; angle+=1){
      myservo.write(angle);
      delay(20);
    }
    for(angle=180; angle>=1; angle-=1){
      myservo.write(angle);
      delay(20);
    }
  }
#+END_SRC

1. 包含头文件<servo.h>

2. 创建servo对象

3. servo::attach(pin, min, max)

   + pin 舵机信号线连接的引脚，可以使用任何数字引脚
   + min 对应于舵机最小（0°）角度时的脉冲宽度，以微秒为单位，默认544us
   + max 对应于舵机最大（180°）角度的脉冲宽度，以微秒为单位，默认为2400us
   + 典型的舵机只对脉冲的微秒数而不是度数做响应。

*** [[http://www.mjoldfield.com/atelier/2009/02/arduino-cli.html][Arduino from the command line]] :blog:

**** Retirement

2013-05-19 : I've let this languish for too long, mainly because I don't
do much with Arduinos now. Happily Sudar Muthu has taken over
maintainance of the code. His github repository is
[[https://github.com/sudar/Arduino-Makefile/]]^{1} though by the magic
of github, the old URL continues to work.

Thanks to Sudar and everyone else who has helped for keeping this alive.

**** Update News

2012-09-17 : After letting this languish for many months there's now
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz][version
0.10.]]^{2} This:

- Supports the Leonardo board.
- Moves the board reset code to Perl (this means you'll need the
   Device::SerialPort module).
- Has new path handling code.

There are other small changes, for more details see the
[[https://github.com/mjoldfield/Arduino-Makefile/commits/master][commit
history.]]^{3}

The new path calculations mean that:

1. Few, if any, paths need to specified in project specific Makefiles.
2. Paths can be grabbed from the environment e.g. from .bashrc.
3. It should be easier to move projects between e.g. Mac & Linux.

However, you'll need to set up some new variables to make this work:

- ARDMK_DIR :: Things which are included in this distribution e.g.
   ard-parse-boards
- ARDUINO_DIR :: Things which are always in the Arduino distribution
   e.g. boards.txt, libraries, &c.
- AVR_TOOLS_DIR :: Things which might be bundled with the Arduino
   distribution, but might come from the system. Most of the toolchain
   is like this: on Linux it's supplied by the system.

Thanks to Dan Villiom Podlaski Christiansen, Tom Hall, Scott Howard,
Kalin Kozhuharov, Rickard Lindberg, Christopher Peplin, Marc
Plano-Lesay, Jared Szechy, and Matthias Urlichs for patches and
comments.

***** Github

You can now grab the source for this from
[[https://github.com/mjoldfield/Arduino-Makefile][github.]]^{4} Besides
my version there are several others under development which offer better
integration with the IDE, support for Microchip's ChipKIT boards, and
other delights.

**** Introduction

The [[http://www.arduino.cc/][Arduino]]^{5} has done much to popularize
microcontrollers for the casual tinkerer. Its success suggests that
there's considerable value in combining a standard microcontroller (the
ATmega) and a GCC based toolchain into an easily digesible package. For
myself, it's certainly easier to just install the latest release of the
Arduino software than worry about building my own cross-compilers,
particularly when it's all new to me and consequently somewhat
confusing.

After working through the toy tutorials though, I found myself wishing
that writing code for the Arduino were more like writing other C
programs. In my case, that means editing it with emacs then building it
with make. I must emphasize that I'm not criticizing the Arduino IDE:
there's nothing wrong with it beyond it not being emacs...

It turns out that others have been along this path before: in the past
the Arduino website had a hopeful sounding ‘Arduino from the Command
Line' article, but it's gone now. There is still
[[http://arduino.cc/en/Hacking/HomePage][some information]]^{6} though
it's more limited.

Without an official Makefile, I wrote my own. You might wonder why I
should embark on such a task. Well:

- I was keen that all of my objects and random other files were
   completely separate from the main Arduino stuff in the applet
   directory.
- Although I wanted to be able to build Arduino sketches, I also wanted
   a suitable jumping-off point for code which didn't use wiring. In
   other words, to regard the Arduino software as a convenient way to
   get the AVR GCC toolchain.
- Rather than dumping a big Makefile in each sketch directory, I wanted
   to have a few definitions in the directory which then included a
   large project-independent file from elsewhere.

Finally, one of the things I enjoy about writing code for
microcontrollers is the sense of continuity between the hardware
datasheets published by the chip manufacturer and the code I write (by
contrast if you're writing code on Linux there's a vast gulf between the
code executing printf and stuff appearing on the screen). Writing my own
Makefile seemed a good way to make sure I understood what was going on.

So to the Makefile. Obviously it owes a great debt to the people who
wrote the Makefile shipped with the Arduino IDE and here's the credit
list from that file:

#+BEGIN_EXAMPLE
    # Arduino 0011 Makefile
    # Arduino adaptation by mellis, eighthave, oli.keller
#+END_EXAMPLE

Thanks then to mellis, eighthavem and oli.keller.

**** Installation instructions

If you're using Debian or Ubuntu, then just grab the arduino-mk package.

You should then set up environment variables thus:

#+BEGIN_EXAMPLE
    ARDUINO_DIR   = /usr/share/arduino
    ARDMK_DIR     = /usr
    AVR_TOOLS_DIR = /usr
#+END_EXAMPLE

Otherwise, you'll need to download
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz][the
tarball containing the Makefile,]]^{7} unpack it, and then copy the
files somewhere sensible:

#+BEGIN_EXAMPLE
    $ wget http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz
    $ tar xzvf arduino-mk_0.10.tar.gz
    $ cp arduino-mk-0.10/arduino-mk/Arduino.mk /usr/local/arduino/Arduino.mk
    $ cp arduino-mk-0.10/bin/* /usr/local/bin
#+END_EXAMPLE

The next step is to set up environment variables which point to the
different files.

On the Mac you might want to set:

#+BEGIN_EXAMPLE
    ARDUINO_DIR   = /Applications/Arduino.app/Contents/Resources/Java
    ARDMK_DIR     = /usr/local
#+END_EXAMPLE

On Linux, where the toolchain is installed in /usr, you might prefer:

#+BEGIN_EXAMPLE
    ARDUINO_DIR   = /usr/share/arduino
    ARDMK_DIR     = /usr/local
    AVR_TOOLS_DIR = /usr
#+END_EXAMPLE

The final step is to create a small Makefile for the sketch you actually
want to build. Let's build the
[[http://arduino.cc/en/Tutorial/WebServer][WebServer example]]^{8} from
the Arduino distribution: it's a good example because software-wise it's
as complicated as the stardard examples get, but you can just plug the
hardware together.

Create a new directory and copy the WebServer.ino file into it.

*Note: If you're using version 1.0 of the Arduino software, you'll need
to make sure that the sketch's name ends in .ino and not .pde.*

Now this we'll add a Makefile:

#+BEGIN_EXAMPLE
    BOARD_TAG    = uno
    ARDUINO_PORT = /dev/cu.usb*

    ARDUINO_LIBS = Ethernet Ethernet/utility SPI

    include /usr/local/arduino/Arduino.mk
#+END_EXAMPLE

Hopefully these will be self-explanatory but in case they're not:

- BOARD_TAG :: A tag identifying which type of Arduino you're using.
   This only works in version 0.6 and later.
- ARDUINO_PORT :: The port where the Arduino can be found (only needed
   when uploading) If this expands to several ports, the first will be
   used.
- ARDUINO_LIBS :: A list of any libraries used by the sketch---we
   assume these are in $(ARDUINO_DIR)/hardware/libraries.

Until version 0.8 you had to specify a TARGET name which set the
basename for the executables. You still /can/ do this, but it's not
necessary: thanks to a patch from Daniele Vergini it now defaults to the
name of the current directory.

In the past, the following options were used, and indeed you can still
use them. However it's probably better to use set BOARD_TAG and let the
Makefile look up the values in boards.txt:

- MCU :: The target processor (atmega168 for the Duemilanove).
- F_CPU :: The target's clock speed (16000000 for the Duemilanove).
- AVRDUDE_ARD_PROGRAMMER :: The protocol avrdude speaks---defaults to
   stk500v1.
- AVRDUDE_ARD_BAUDRATE :: The rate at which we talk to the
   board---defaults to 19,200.

***** BOARD_TAG

Makefiles before version 0.5 had to specify which processor and speed
the target used. For standard boards, this information can be found in
the boards.txt file, so it seemed sensible to use that instead.

Now, one need only define BOARD_TAG to match the target hardware and it
should work. Internally the Makefile invokes ard-parse-boards---a small
Perl utility included with the software---which parses board.txt.

If you're not sure which board tag you need, ard-parse-board will dump a
full list:

#+BEGIN_EXAMPLE
    $ ard-parse-boards --boards
    Tag          Board Name
    atmega168    Arduino NG or older w/ ATmega168
    atmega328    Arduino Duemilanove or Nano w/ ATmega328
    atmega8      Arduino NG or older w/ ATmega8
    bt           Arduino BT w/ ATmega168
    bt328        Arduino BT w/ ATmega328
    diecimila    Arduino Diecimila, Duemilanove, or Nano w/ ATmega168
    fio          Arduino Fio
    lilypad      LilyPad Arduino w/ ATmega168
    lilypad328   LilyPad Arduino w/ ATmega328
    mega         Arduino Mega (ATmega1280)
    mega2560     Arduino Mega 2560
    mini         Arduino Mini
    pro          Arduino Pro or Pro Mini (3.3V, 8 MHz) w/ ATmega168
    pro328       Arduino Pro or Pro Mini (3.3V, 8 MHz) w/ ATmega328
    pro5v        Arduino Pro or Pro Mini (5V, 16 MHz) w/ ATmega168
    pro5v328     Arduino Pro or Pro Mini (5V, 16 MHz) w/ ATmega328
    uno          Arduino Uno
#+END_EXAMPLE

If you don't set it, BOARD_TAG defaults to uno.

You can, of course, continue to set F_CPU and MCU directly should you
prefer that.

***** ARDUINO_LIBS

Early (up to and including version 0.4) of this Makefile didn't really
support this (despite claims to the contrary). Happily various kind
people sorted out the problem, one of whom patched the Debian and Ubuntu
version.

In the official IDE, it's enough to select the library from a menu: this
puts the relevant #include into the Sketch and adds the necessarily
linker tweaks too.

In this Makefile, you'll need to both add the #include yourself and
append the directories which contain the library to the ARDUINO_LIBS
variable. Often these will both have the same name, though it's worth
noting that the #include refers to a single file, but the ARDUINO_LIBS
entry refers to an entire directory of source files.

However, care is needed if the library's source files aren't in a single
directory. For example, the webserver example uses the
[[http://www.arduino.cc/en/Reference/Ethernet][Ethernet library]]^{9}
and we needed to include both Ethernet and Ethernet/utility in
ARDUINO_LIBS.

If you omit the .../utility library, you'll get messy looking link
errors from the bowels of the Ethernet library. The SPI and Wire
libraries are like this too!

**** Building

If you're used to Unix then this is easy:

#+BEGIN_EXAMPLE
    $ make
    ...
#+END_EXAMPLE

The output is pretty verbose, but I think it should be obvious if it
worked. After building you'll see a new directory has been created which
contains all the object files: build-uno. Since version 0.10, if you
rebuild the software with a different BOARD_TAG, you'll get a different
directory name.

#+BEGIN_EXAMPLE
    $ $ ls -lR
    total 16
    -rw-r--r--   1 mjo  staff   263 12 Feb 11:06 Makefile
    -rw-r--r--   1 mjo  staff  2308 12 Feb 10:57 WebServer.ino
    drwxr-xr-x  28 mjo  staff   952 12 Feb 11:07 build-uno
#+END_EXAMPLE

***** build-uno

Let's peek inside the build-uno directory:

#+BEGIN_EXAMPLE
    $ ls -l build-uno
    total 2136
    -rw-r--r--  1 mjo  staff    2292 12 Feb 11:07 CDC.o
    -rw-r--r--  1 mjo  staff    2292 12 Feb 11:07 HID.o
    -rw-r--r--  1 mjo  staff   23452 12 Feb 11:07 HardwareSerial.o
    -rw-r--r--  1 mjo  staff   16008 12 Feb 11:07 IPAddress.o
    -rw-r--r--  1 mjo  staff   40012 12 Feb 11:07 Print.o
    -rw-r--r--  1 mjo  staff   21068 12 Feb 11:07 Stream.o
    -rw-r--r--  1 mjo  staff   16580 12 Feb 11:07 Tone.o
    -rw-r--r--  1 mjo  staff    2300 12 Feb 11:07 USBCore.o
    -rw-r--r--  1 mjo  staff    6048 12 Feb 11:06 WInterrupts.o
    -rw-r--r--  1 mjo  staff    7068 12 Feb 11:07 WMath.o
    -rw-r--r--  1 mjo  staff   79196 12 Feb 11:07 WString.o
    -rw-r--r--  1 mjo  staff    2329 12 Feb 10:57 WebServer.cpp
    -rw-r--r--  1 mjo  staff    1920 12 Feb 11:06 WebServer.d
    -rw-r--r--  1 mjo  staff   11324 12 Feb 11:06 WebServer.o
    -rwxr-xr-x  1 mjo  staff  193852 12 Feb 11:07 WebServer.elf
    -rw-r--r--  1 mjo  staff   28572 12 Feb 11:07 WebServer.hex
    -rw-r--r--  1 mjo  staff    1920 12 Feb 11:08 depends.mk
    -rw-r--r--  1 mjo  staff  541002 12 Feb 11:07 libcore.a
    drwxr-xr-x  4 mjo  staff     136 12 Feb 10:57 libs
    -rw-r--r--  1 mjo  staff    3616 12 Feb 11:07 main.o
    <-rw-r--r--  1 mjo  staff    5544 12 Feb 11:07 new.o
    -rw-r--r--  1 mjo  staff    9780 12 Feb 11:06 wiring.o
    -rw-r--r--  1 mjo  staff    7024 12 Feb 11:06 wiring_analog.o
    -rw-r--r--  1 mjo  staff    9704 12 Feb 11:06 wiring_digital.o
    -rw-r--r--  1 mjo  staff    7056 12 Feb 11:06 wiring_pulse.o
    -rw-r--r--  1 mjo  staff    5736 12 Feb 11:06 wiring_shift.o

    ./build-uno/libs:
    total 0
    drwxr-xr-x  9 mjo  staff  306 12 Feb 11:07 Ethernet
    drwxr-xr-x  3 mjo  staff  102 12 Feb 11:07 SPI

    ./build-uno/libs/Ethernet:
    total 392
    -rw-r--r--  1 mjo  staff  24836 12 Feb 11:07 Dhcp.o
    -rw-r--r--  1 mjo  staff  23112 12 Feb 11:07 Dns.o
    -rw-r--r--  1 mjo  staff  33008 12 Feb 11:07 Ethernet.o
    -rw-r--r--  1 mjo  staff  42000 12 Feb 11:07 EthernetClient.o
    -rw-r--r--  1 mjo  staff  19420 12 Feb 11:07 EthernetServer.o
    -rw-r--r--  1 mjo  staff  41244 12 Feb 11:07 EthernetUdp.o
    drwxr-xr-x  4 mjo  staff    136 12 Feb 11:07 utility

    ./build-uno/libs/Ethernet/utility:
    total 152
    -rw-r--r--  1 mjo  staff  40480 12 Feb 11:07 socket.o
    -rw-r--r--  1 mjo  staff  34840 12 Feb 11:07 w5100.o

    ./build-uno/libs/SPI:
    total 16
    -rw-r--r--  1 mjo  staff  6812 12 Feb 11:07 SPI.o
#+END_EXAMPLE

Most of the files in here are object files for the wiring library. What
about the others ?

- WebServer.cpp :: This is the .pde sketch file with a small main
   program prepended and a suitable #include prepended.
- WebServer.d :: This tracks the dependencies used by WebServer.pde
- WebServer.elf :: This is executable produced by the linker
- WebServer.hex :: This is a hex dump of (the code part) of the
   executable in a format understood by the Arduino's bootloader.
- WebServer.o :: The object file we got by compiling WebServer.cpp.
- depends.mk :: A single file containing all the dependency relations
   (it's the concatentation of all the .d files).
- libcore.a :: Rather than link all the system supplied objects
   directly, we build them into this library first, then link against
   it.

**** Uploading code

This is easy:

#+BEGIN_EXAMPLE
    $ make upload
#+END_EXAMPLE

**** Uploading via ISP

If you're using target hardware which doesn't have a bootloader then you
might want to use ISP to upload the code. Though you'll obviously need
some extra hardware to do this.

Assuming that avrdude supports your programmer though, you'll only need
to make a few changes to the Makefile to tell avrdude where it can find
the programmer and how to talk to it:

#+BEGIN_EXAMPLE
    ISP_PORT         = /dev/ttyACM0
    ISP_PROG         = -c stk500v2
#+END_EXAMPLE

Then to upload:

#+BEGIN_EXAMPLE
    $ make ispload
#+END_EXAMPLE

***** Fuses

You might need to change the fuse settings when programming, though some
care needs to be taken here or you might irreversibly damage the chip.

Normally the fuse settings are chosen from the boards.txt file to match
the value of BOARD_TAG (assuming you're running version 0.6 or higher),
but you can set them yourself:

#+BEGIN_EXAMPLE
    ISP_LOCK_FUSE_PRE  = 0x3f
    ISP_LOCK_FUSE_POST = 0xcf
    ISP_HIGH_FUSE      = 0xdf
    ISP_LOW_FUSE       = 0xff
    ISP_EXT_FUSE       = 0x01
#+END_EXAMPLE

**** Growing the project

There a couple of obvious things to do now. You might want to edit the
sketch. That's easy: just edit the .ino file and run make again.

Alternatively you might want to add some more source files to the
project. That's easy too: the Makefile understands C, C++ and assembler
files in the source directory (with .c, .cpp, and .s extensions).
Everything *should* just work.

**** Wiring-less development

Finally you might want to develop code which isn't linked against the
Wiring library. There's some scope for this: just set NO_CORE in the
Makefile e.g.

#+BEGIN_EXAMPLE
    NO_CORE = 1
#+END_EXAMPLE

**** Bugs and problems

- The Makefile isn't very elegant.
- When compiling the sketch file, the compiler actually sees the .cpp
   file derived from it. Accordingly the line numbers of any errors will
   be wrong (but not by that much).
- The Makefile doesn't do some of the things that the Makefile
   distributed with the Arduino software does e.g. generating COFF
   files. I worry that some of these might be important.
- This hasn't been used very much yet, even by me. I'm writing this now
   as much for my benefit as anyone else's, though I'd be delighted to
   know if anyone else finds it useful.

**** Changelog

***** 2010-05-21,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.3.tar.gz][version
0.3]]^{10}

- Tidied up the licensing, making it clear that it's released under
   LGPL 2.1.
- [[http://hands.com/~phil/][Philip Hands]]^{11} sent me some code to
   reset the Arduino by dropping DTR for 100ms, and I added it.
- Tweaked the Makefile to handle version 0018 of the Arduino software
   which now includes main.cpp. Accordingly we don't need to---and
   indeed must not---add main.cxx to the .pde sketch file. The paths
   seem to have changed a bit too.

***** 2010-05-24,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.4.tar.gz][version
0.4]]^{12}

- Tweaked rules for the reset target on Philip Hands' advice.

***** 2011-06-23,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.5.tar.gz][version
0.5]]^{13}

- Imported changes from Debian/Ubuntu, which incorporate a patch from
   Stefan Tomanek so that libraries would be compiled too.

Note: Many other people sent me similar patches, but I didn't get around
to using them. In the end, I took the patch from Debian and Ubuntu:
there seems merit in not forking the code and using a tested version.
So, thanks and apologies to Nick Andrew, Leandro Coletto Biazon, Thibaud
Chupin, Craig Hollabaugh, Johannes H. Jensen, Fabien Le Lez, Craig
Leres, and Mark Sproul.

***** 2011-06-23,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.6.tar.gz][version
0.6]]^{14}

- Added ard-parse-boards. Mark Sproul suggested doing something like
   this ages ago, but I've only recently looked at it in detail.
- Fabien Le Lez reported that one needs to link with -lc to avoid
   [[http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1290294587][linker
   errors.]]^{15}

***** Unreleased,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.7.tar.gz][version
0.7]]^{16}

- Added -lm to the linker options, and -F to stty.

***** 2012-02-12,
[[http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.8.tar.gz][version
0.8]]^{17}

- Patches for version 1.0 of the Arduino IDE. Older versions might
   still work, but I've not tested it.
- A change to the build process: rather than link all the system
   objects directly into the executable, bundle them in a library first.
   This should make the final executable smaller.
- If TARGET isn't explicitly set, default to the current directory
   name. Thanks to Daniele Vergini for this patch.
- Add support for .c files in system libraries: Dirk-Willem van Gulik
   and Evan Goldenberg both reported this and provided patches in the
   same spirit.
- Added a size target as suggested by Alex Satrapa.

***** Later versions

Please consult the
[[https://github.com/mjoldfield/Arduino-Makefile/commits/master][commit
history]]^{18} on github.

**** Similar work

It's not a derivative of this, but Alan Burlison has written
[[http://bleaklow.com/2010/06/04/a_makefile_for_arduino_sketches.html][a
similar thing.]]^{19}

Alan's Makefile was used in
[[http://pragprog.com/magazines/2011-04/advanced-arduino-hacking][a
Pragmatic Programmer's article.]]^{20}

Rei Vilo wrote to tell me that he's using the Makefile ina Xcode 4
template called [[http://embedxcode.weebly.com][embedXcode.]]^{21}
Apparently it supports many platforms and boards, including AVR-based
Arduino, AVR-based Wiring, PIC32-based chipKIT, MSP430-based LaunchPad
and ARM3-based Maple.

**** References

- 1. https://github.com/sudar/Arduino-Makefile/
- 2.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz
- 3. https://github.com/mjoldfield/Arduino-Makefile/commits/master
- 4. https://github.com/mjoldfield/Arduino-Makefile
- 5. http://www.arduino.cc/
- 6. http://arduino.cc/en/Hacking/HomePage
- 7.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.10.tar.gz
- 8. http://arduino.cc/en/Tutorial/WebServer
- 9. http://www.arduino.cc/en/Reference/Ethernet
- 10.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.3.tar.gz
- 11. http://hands.com/~phil/
- 12.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.4.tar.gz
- 13.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.5.tar.gz
- 14.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.6.tar.gz
- 15. http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1290294587
- 16.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.7.tar.gz
- 17.
   http://www.mjoldfield.com/atelier/2009/02/acli/arduino-mk_0.8.tar.gz
- 18. https://github.com/mjoldfield/Arduino-Makefile/commits/master
- 19.
   http://bleaklow.com/2010/06/04/a_makefile_for_arduino_sketches.html
- 20. http://pragprog.com/magazines/2011-04/advanced-arduino-hacking
- 21. http://embedxcode.weebly.com
