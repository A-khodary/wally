* Algorithms                                                     :algorithms:
** Algorithms Tutorials                                           :tutorial:
*** 数据结构与算法分析

**** 选择问题(Selection Problem)
****** 问题描述
有一组N个数，要确定其第k个最大者
+ 输入： 数组A
+ 输出： 第k个最大数
****** 解法一
先排序，然后返回索引为k的元素
******* 伪代码
#+BEGIN_SRC latex
  \begin{algorithm}[ht]
    SORT-SELECT(A, k)
    \KwData{A: 数组， k: integer}
    SORT(A)
    return A[k]
  \end{algorithm}
#+END_SRC
******* 实现
#+BEGIN_SRC latex

  \begin{cpp}
    template<class T>
    T sort_select(T arr[], size_t len, size_t k)
    {
      if(len < k){
        return -1;
      }

      // bubble sort
      for(int i=0; i<len; i++){
        bool no_swap = true;
        for(int j=0; j<len-i-1; j++)
        if(arr[j] < arr[j+1]){
          T temp = arr[j];
          arr[j] = arr[j+1];
          arr[j+1] = temp;
          no_swap = false;
        }

        if(no_swap)
        break;
      }
      return arr[k-1];
    }
  \end{cpp}
#+END_SRC
****** 解法二
先读入前k个元素并排序，接着将剩下的元素逐个读入，替换适当位置的元素或舍
弃。最终返回第k个元素
******* 伪代码
#+BEGIN_SRC latex
  \begin{algorithm}[ht]
    OPTIMIZED-SORT-SELECT
    \KwData{A: array, k: index}
    \KwOut{第k大元素}
    \BlankLine
    \Begin{
      \For{i=1 \KwTo k}{
        B[i] = A[i]
      }
      SORT(B)
      \For{i=k+1 \KwTo A.length}{
        j = k
        key = A[i]
        \While{key>B[j] AND j>0}{
          B[j]=B[j-1]
          j = j-1
        }
        B[j-1] = key
      }
      RETURN B[k]
    }
  \end{algorithm}
#+END_SRC
******* 实现
#+BEGIN_SRC latex

  \begin{cpp}
    template<class T>
    T optimized_sort_select(T arr[], size_t len, size_t k)
    {
      if(len < k)
      return -1;

      T brr[k];
      for(int i=0; i<k; i++)
      brr[i] = arr[i];

      // insert-sort
      for(int i=1; i<k; i++){
        T key = brr[i];
        int j = i-1;
        while(brr[j]<key && j>=0){
          brr[j+1] = brr[j];
          j--;
        }
        brr[j+1] = key;
      }

      for(int i=k; i<len; i++){
        int j = k-1;
        T key = arr[i];
        while(brr[j]<key && j>=0){
          brr[j]=brr[j-1];
          j--;
        }
        brr[j+1] = key;
      }
      return brr[k-1];
    }
  \end{cpp}
#+END_SRC
****** 算法的性能
length=1000万，k=5000,000时，两种算法都不能在合理的时间内完成（每种算
法都需要计算机处理若干天才能完成）
存在另外一种算法可以在1s左右给出答案。
**** C++类
***** 基本class语法
+ 学习类的程序风格
+ 文件以下划线连接的小写字母单词命名
+ 类使用驼峰式命名
+ 类的方法使用小写字母q命名
+ 合理的注释是必要的
#+BEGIN_SRC latex
  \begin{cpp}
    /**
    ,* A class for simulating an integer memory cell
    ,*/

    class IntCell
    {
      /**
      ,* Construct the IntCell
      ,* Initial value is 0
      ,*/
      IntCell(){
        storedValue = 0;
      }

      /**
      ,* Construct the IntCell
      ,* Initial value is initialValue
      ,*/
      IntCell(int initialValue){
        storedValue = initialValue;
      }

      /**
      ,* Return the stored value
      ,*/
      int read(){
        return storedValue;
      }

      /**
      ,* Change the stored value
      ,*/
      void write(int x){
        storedValue = x;
      }

      private:
      int storedValue;
    };

  \end{cpp}
#+END_SRC

***** 特别的构造函数和访问函数
#+BEGIN_SRC latex
  \begin{cpp}
    /**
    ,* A class for simulating an integer memory cell.
    ,*/

    class IntCellOptimized
    {
      public:
      explicit IntCellOptimized(int initialValue=0)
      : storedvalue(initialvalue) {}
      int read() const{
        return storedValue;
      }
      void write(int x){
        storedValue = x;
      }

      private:
      int storedValue;

    };



  \end{cpp}
#+END_SRC


****** 四项优化
1. 使用默认参数（default parameter）

2. 初始化列表
   1) 在数据成员是具有复杂初始化过程的类类型时，使用初始化列表代替代码
      体中的赋值语句可以节省许多时间
   2) 如果一个数据成员是const（在对象被构造后就不能再改变），数据成员
      的值只能在初始化列表中时行初始化
   3) 如果一具数据成员是不具有零参数构造函数的类类型时，该数据成员的初
      始化也必须在初始化列表中进行

3. explicit构造函数
   1) 所有单参数的构造函数都必须是explicit的，以避免后台的类型转换；
   2) 否则一些宽松的规则将允许在没有显式类型转换操作的情况下进行类型转换
   3) 通常单构造函数定义了一个隐式类型转换(impllicit type conversion)，该转换创建一个临时对象，从而使赋值变得兼容
   4) IntCell obj; obj = 37; // should not compile, 会转换为IntCell temp = 37; obj = temp;

4. 常量成员函数
   1) 在C++中每个成员函数都被标记为访问函数(accessor)或者修改函数(mutator)
   2) 函数声明可以在不同的情况下以不同的方式使用const关键字，只有跟在结尾圆括号后面的const才标记一个访问函数

****** 其它优化
1. 预处理指令，防止多次包括同一文件 #ifndef IntCell_H #define IntCell_H #endif
2. 接口与实现分离
   1) 签名一致
   2) 默认参数仅在接口中被定义，在实现中被忽略

***** vector和string
C++标准定义了两个类vector和string。
*如果可能，应尽量避免使用C++内置数组和字符串。*

****** 内置数组带来的麻烦
内置数组的问题在于其行为与基本对象不同
+ 不能使用=复制
+ 不能记忆本身长度
+ 不能对索引进行边界检查

** Sort                                                               :sort:
** Select                                                           :select:
** 插值
** Math Relatd
*** 不确定性椭圆的绘制                                  :math:椭圆:algorithm:
1. input
   1) center 椭圆圆心
   2) angle 长轴倾斜角度
   3) a 长轴半径
   4) b 短轴半径
2. output： 构成椭圆的点的集合
3. 伪代码
   #+begin_src latex
     \begin{algorithm}
     \caption{生成不确定椭圆的散点集合}
     \kwin{center, angle, a, b}
     \kwout{points}
     ax = a*cos(angle)
     ay = a*sin(angle)
     bx = b*sin(angle)
     by = b*cos(angle)

     points = null
     cx = center[1]
     cy = center[2]

     \for{theta = 0:0.01*pi:2*pi}{
       c = cos(theta)
       s = sin(theta)
       x = cx + c*ax - s*bx
       y = cy + c*ay + s*by
       points.append(x,y)
     }
     \return{points}
     \end{algorithm}
   #+end_src

4. 实现
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{py}
         @staticmethod
         def get_ellipse_points(center, main_axis_angle, radius1, radius2,
                                start_angle = 0.0, end_angle = 2 * pi):
             """generate points of an ellipse, for drawing (y axis down)."""
             points = []
             ax = radius1 * cos(main_axis_angle)
             ay = radius1 * sin(main_axis_angle)
             bx = - radius2 * sin(main_axis_angle)
             by = radius2 * cos(main_axis_angle)
             n_full = 40  # number of points on full ellipse.
             n = int(ceil((end_angle - start_angle) / (2 * pi) * n_full))
             n = max(n, 1)
             increment = (end_angle - start_angle) / n
             for i in xrange(n + 1):
                 a = start_angle + i * increment
                 c = cos(a)
                 s = sin(a)
                 x = c*ax + s*bx + center[0]
                 y = - c*ay - s*by + center[1]
                 points.append((x,y))
             return points
     \end{minted}
   #+end_latex

*** 埃氏筛法求素数序列                                       :素数:algorithm:
计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：

首先，列出从2开始的所有自然数，构造一个序列：

2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...

取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：

3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...

取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：

5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...

取新序列的第一个数5，然后用5把序列的5的倍数筛掉：

7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...

不断筛下去，就可以得到所有的素数。

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def _odd_iter():
    n = 1
    while true:
        n = n + 2
        yield n


def _not_divisible(n):
    return lambda x: x % n > 0


def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while true:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列


# 打印1000以内的素数:
for n in primes():
    if n < 1000:
        print(n)
    else:
        break
\end{minted}
#+end_latex

*以上程序运行有问题*

* DataStructure                                               :datastructure:
** List                                                               :list:

** Tree                                                               :tree:
** Graph                                                             :graph:
* Progress                                                         :progress:
** 算法导论
*** 项目规化 [1/3]
- state "tobecontined" from "todo"       [2015-11-23 一 14:37]
- state "todo"       from ""           [2015-11-23 一 14:36]


1. [ ] 为什么要学习算法，我想过这个问题么？
2. [x] 教材选择： 《算法导论》
3. [ ] 整理已学习的内容
4. [ ] 学习计划

*** TODO Stression
**** Objective

+ [ ] 方阵的一般乘法算法的伪代码和Python实现
+ [ ] 方阵的一般分治
+ [ ] 方阵的Strassen乘法
+ [ ] 将以上算法推广到一般矩阵乘法

**** Notes

+ 优先使用 Python 实现算法，使用 C++ 容易过度关注语言本身的细节
+ 写的代码要有良好的歌读性，

**** 普通方阵乘法：Square-Matrix-Mutltiply(A, B)
***** 伪代码(preudo-code)

#+BEGIN_SRC latex
  \begin{algorithm}[H]
  SQUARE-MATRIX-MULTIPLY(A, B)\;
  n = A.rows\;
  let C be a new nxn matrix\;
  \For{i = 1 \KwTo n}{
    \For{j = 1 \KwTo n}{
      $C_{ij} = 0$
      \For{k = 1 \KwTo n}{
        $C_{ij} = C_{ij} + A_{ik}\cdot{B_{kj}}$
  }
  }
  }
  \Return C
  \end{algorithm}


#+END_SRC

***** Python实现
#+INCLUDE: ~/Wally/Journal/Project/Algorithm/SplitAndonquer/strassen.py :src python


** 数据结构

#+BEGIN_EXAMPLE
- state "tobecontined" from ""           [2015-11-23 一 14:39]
  算法与数据结构分不开
#+END_EXAMPLE


- 教材： [[~/Document/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90C%2B%2B%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%89%E7%89%88.pdf][数据结构与算法分析]]

*** 项目规化 [1/4]
- state "tobecontined" from ""           [2015-11-23 一 14:39]

1. [ ] 思考： 为什么学习数据结构？
2. [x] 教材选择： 《数据结构与算法分析：c++描述》
3. [ ] 整理已学习内容
4. [ ] 学习计划

*** 引论
**** 选择问题(selection problem)                     :selection:algorithm:

***** 问题描述

有一组n个数，要确定其第k个最大者
+ 输入： 数组a
+ 输出： 第k个最大数

***** 算法一

先排序，然后返回索引为k的元素

#+begin_src latex
  \begin{algorithm}[ht]
    sort-select(a, k)
    \kwdata{a: 数组， k: integer}
    sort(a)
    return a[k]
  \end{algorithm}
#+end_src

***** 算法二

先读入前k个元素并排序，接着将剩下的元素逐个读入，替换适当位置的元素或舍
弃。最终返回第k个元素

#+begin_src latex
  \begin{algorithm}[ht]
    optimized-sort-select
    \kwdata{a: array, k: index}
    \kwout{第k大元素}
    \blankline
    \begin{
      \for{i=1 \kwto k}{
        b[i] = a[i]
      }
      sort(b)
      \for{i=k+1 \kwto a.length}{
        j = k
        key = a[i]
        \while{key>b[j] and j>0}{
          b[j]=b[j-1]
          j = j-1
        }
        b[j-1] = key
      }
      return b[k]
    }
  \end{algorithm}
#+end_src

***** 实现

#+include: ~/Wally/Journal/Project/Algorithm/selects.h :src cpp

***** 算法的性能

length=1000万，k=5000,000时，两种算法都不能在合理的时间内完成（每种算
法都需要计算机处理若干天才能完成）
存在另外一种算法可以在1s左右给出答案。

**** c++类
***** 基本class语法

+ 学习类的程序风格
+ 文件以下划线连接的小写字母单词命名
+ 类使用驼峰式命名
+ 类的方法使用小写字母q命名
+ 合理的注释是必要的

#+begin_src latex
  \begin{cpp}
    /**
    ,* a class for simulating an integer memory cell
    ,*/

    class intcell
    {
      /**
      ,* construct the intcell
      ,* initial value is 0
      ,*/
      intcell(){
        storedvalue = 0;
      }

      /**
      ,* construct the intcell
      ,* initial value is initialvalue
      ,*/
      intcell(int initialvalue){
        storedvalue = initialvalue;
      }

      /**
      ,* return the stored value
      ,*/
      int read(){
        return storedvalue;
      }

      /**
      ,* change the stored value
      ,*/
      void write(int x){
        storedvalue = x;
      }

      private:
      int storedvalue;
    };

  \end{cpp}
#+end_src

***** 特别的构造函数和访问函数

#+begin_src latex
  \begin{cpp}
    /**
    ,* a class for simulating an integer memory cell.
    ,*/

    class intcelloptimized
    {
      public:
      explicit intcelloptimized(int initialvalue=0)
      : storedvalue(initialvalue) {}
      int read() const{
        return storedvalue;
      }
      void write(int x){
        storedvalue = x;
      }

      private:
      int storedvalue;

    };

  \end{cpp}
#+end_src


****** 四项优化
1. 使用默认参数（default parameter）

2. 初始化列表
   1) 在数据成员是具有复杂初始化过程的类类型时，使用初始化列表代替代码
      体中的赋值语句可以节省许多时间
   2) 如果一个数据成员是const（在对象被构造后就不能再改变），数据成员
      的值只能在初始化列表中时行初始化
   3) 如果一具数据成员是不具有零参数构造函数的类类型时，该数据成员的初
      始化也必须在初始化列表中进行

3. explicit构造函数
   1) 所有单参数的构造函数都必须是explicit的，以避免后台的类型转换；
   2) 否则一些宽松的规则将允许在没有显式类型转换操作的情况下进行类型转换
   3) 通常单构造函数定义了一个隐式类型转换(impllicit type conversion)，该转换创建一个临时对象，从而使赋值变得兼容
   4) intcell obj; obj = 37; // should not compile, 会转换为intcell temp = 37; obj = temp;

4. 常量成员函数
   1) 在c++中每个成员函数都被标记为访问函数(accessor)或者修改函数(mutator)
   2) 函数声明可以在不同的情况下以不同的方式使用const关键字，只有跟在结尾圆括号后面的const才标记一个访问函数

****** 其它优化
1. 预处理指令，防止多次包括同一文件 #ifndef intcell_h #define intcell_h #endif
2. 接口与实现分离
   1) 签名一致
   2) 默认参数仅在接口中被定义，在实现中被忽略

***** vector和string

c++标准定义了两个类vector和string。

*如果可能，应尽量避免使用c++内置数组和字符串。*

****** 内置数组带来的麻烦

内置数组的问题在于其行为与基本对象不同
+ 不能使用=复制
+ 不能记忆本身长度
+ 不能对索引进行边界检查

*** 表、栈和队列                                              :vector:list:

最基本的3种数据结构， *每一个有意义的程序都将明晰地至少使用一个这样的
数据结构*

**** 抽象数据类型

抽象数据类型(abstract date type, *ADT*)是带有一组操作的一些对象的集合。

抽象数据类型是数学的抽象：在ADT的定义中根本没有提到这组操作是如何实现
的。

e.g. 表、集合、图

**** 表ADT
***** 表ADT

表ADT： A_{0}, A_{1}, ..., A_{n-a}

表的大小(size)。

n=0, 空表(empty list)

A_{i} *后继* A_{i-1}; A_{i-1} *前驱* A_{i}

表的操作：
1. printList
2. makeEmpty
3. find
4. insert
5. remove
6. findKth

***** 表的简单数组实现

vector类

1. printList 线性时间
2. findKth 常数时间
3. insert/delete: O(N)
   1) 最坏的情况，在表头（位置0）插入删除元素，N
   2) 最好的情况，在表尾插入删除元素，O(1)
   3) 平均：线性时间

在许多情况，表是
1) 通过在 *末尾插入* 元素来 *建立* 的
2) 之后只有数组访问发生
这样，数组实现是适合和。

如果插入和删除都发生在表中的话，特别是前端的话，数组就不是一个好选择了。

***** 链表

为了避免插入和删除的线性开销 -> 表可以不连续存储。

[[~/Wally/Journal/Figure/scrot/59702FS.png]]

1. printList或find(x) 线性时间，但比数组要大

2. findKth(i) 以明显的遍历链表实现O(i)

   - 因此，调用findKth常常以排序（按i）方式进行

**** STL中的向量和表

Standard Template Library标准模板库。 集合(collection) 或 容器
(container)

表ADT的两种流行的实现

1. *vector*
   1) 优势： 在常量时间里是可索引的
   2) 缺点： 插入新项或者删除已有项的代价是高昂的，除非是在末端发生

2. *list* 双向链表
   1) 优点： 变化发生位置已知的话，插入新项和删除已有项的代价是很小的
   2) 缺点： 不容易索引

两者在查找时的效率都是很低的。

方法：

1. 公共的方法（所有STL）
   + int size() const
   + void clear()
   + bool empty

2. 常量时间内在末尾插入或者删除项
   + void push_back(const Object& x)
   + void pop_back()

3. 在常量时间内访问前端的项
   + const Object& back() const
   + const Object& front() const

4. 双向链表list特有的，对前端高效地改变
   + void push_front(const Object & x): 在list的前端加x
   + void pop_front(): 在list对象的前端删除对象

5. vector特有的方法
   + Object& operator[] (int idx)
   + Object& at(int idx)
   + int capacity() const
   + void reserve(int newCapacity): 设定新的容量

***** 迭代器

对于在表中插入删除的操作需要 *位置标记*,  -> 内置类型 *iterator* 给出
位置。

问题:
1) 如何得到迭代器
2) 迭代器可以执行什么操作（方法）
3) 哪些表ADT方法需要迭代器作为形参

****** 获得迭代器

+ iterator begin()
+ iterator end()  // 返回 *边界之外*

****** 迭代器方法

+ itr++ 和 ++itr
+ *itr
+ == 和 ！=

#+begin_latex
\begin{minted}[frame=single, mathescape]{cpp}
for(vector<int>::iterator itr = v.begin(); itr != v.end; ++itr){
}
\end{minted}
#+end_latex

或

#+begin_latex
\begin{minted}[frame=single, mathescape]{cpp}
vector<int>::iterator itr = v.begin()
while(itr != v.end()){
    cout << *itr++ << endl;
}
\end{minted}
#+end_latex

注：
- 后置自增运算符(++)优先级高于解引用(*)运算符，
- 后置自增运算符(++)表达式的返回值为原值，副作用是加1

****** 需要迭代器的容器操作

1. iterator insert(iterator pos, const Object& x)
   - 添加x到表中迭代器pos所指向的位置之前的位置
   - 对于list是常量时间，对于vector不是
   - 返回值是一个指向插入位置的迭代器

2. iterator erase(iterator pos)
   - 删除迭代器所给位置的对象
   - 对于list是常量时间，对于vector不是
   - 返回值是调用之前pos所指向元素的下一个元素的位置，这个操作使pos失
     效

3. iterator erase(iterator start,  iterator end)

表ADT的通用函数模板

[[~/Wally/Journal/Figure/scrot/5970DQY.png]]

****** const_iterator

1. iterator begin()
2. const_iterator begin() const
3. iterator end()
4. const_iterator end() const

方法的定常性(后置const修饰符)是标号(函数签名)的一部分。

**** 向量实现

***** Vector类需求分析

1. 数组的特性
   1) 数组就是指向一块内存的指针变量
   2) 内存块可以使用new[]来分配，相应地必须使用delete[]来释放
   3) 内在块的大小不能改变（但是可以定义一个新的具有更大内存块的数组，
      并且用原来的数组进行初始化）

2. Vector需求分析
   1) 存储基本数组和数组容量
   2) 三大函数
      - 复制构造函数和operator=深复制
      - 析构函数回收基本数组
   3) resize改变大小，reserve改变容量
      - 为新的数组分配一块新的内存块
      - 复制旧内存块到新的内存块
      - 释放旧的内存块
   4) operator[]
      - 访问函数
      - 修改函数
   5) size, empty, clear, back, pop_back, push_back(调用reserve增大容
      量)
   6) 支持嵌套的iterator和const_iterator类型，和begin和end方法

***** 实现

#+INCLUDE: ~/Wally/Journal/Project/DataStructure/Vector.h :src cpp


**** 栈
**** 队列

*** 树
CLOCK: [2015-12-06 日 16:09]

**** Tree

***** 表 VS 树
对于大量数据， _线性表的访问时间太长_ ，不宜使用。

*树* 的大部分操作的平均运行时间为 /O(logN)/

/二叉查找树(binary search tree)/, 是 *set* 和 *map* 的实现基础。

应用：
- 文件系统
- 表达式树
- set/map

***** 基本概念

1. /树(tree)/: 由根结点以及零个或多个子树组成 （递归定义）
2. /根(root)/
3. /边(edge)/: 每个树由N个结点和N-1条边组成
4. /儿子(child)/
5. /父亲(parent)/
6. /叶结点(leaf)/
7. /兄弟结点(sibling)/
8. /祖父(grandparent)/
9. /孙子(grandchild)/
10. /祖先(ancestor)/
11. /后裔(descendant)/
12. /真祖先(proper ancestor)/
13. /真后裔(proper descendant)/
14. /路径(path)/: 从祖先到后裔的唯一路径
15. /长(length)/: 路径的条数
16. /深度(depth)/: 根到结点的长，根深度为0
17. /高度(height)/: 结点到叶子的最长路径的长，树叶的高度为0

***** 树的实现

将每个结点所有的儿子放在树结点的 *链表* 中。

#+BEGIN_SRC cpp
  /// \brief 一般树的实现
  ///
  /// 普通树直接存储所有子结点的链接会浪费许多空间
  struct TreeNode{
    Object element;
    TreeNode *firstChild;         ///< 指向儿子
    TreeNode *nextSibling;        ///< 指向兄弟
  }
#+END_SRC

***** 树的遍历

****** 前序遍历(preorder traversal)

/对结点的处理是在它的所有儿子结点处理之前进行的/

应用： 遍历目录



****** 后向遍历
