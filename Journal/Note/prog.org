* C++                                                                   :cpp:
** C                                                                   :c:
*** assert                                                         :assert:

1. *macro*
2. <cassert> <assert.h>
3. if the argument expression equal zero,
   1) a *message* is written to standard error
   2) *abort* is called, terminating the program execution
4. message: assertion failed: expression, file /filename/, line /linenumber/
5. #define ndebug before #include  to disable.
6. *therefore,  this macro is designed to capture programming errors,
   not user or run-time error*

** C++ General
*** Linux C++ 多线程                                         :linux:thread:
**** why 线程
1. 节省空间时间
2. 通信机制（方便）
**** Linux下的多线程
***** pthread
遵循POSIX线程接口， *pthread*,
头文件： <pthread.h>
库文件： libpthread.a
方法：clone()， 类似fork()

#+begin_latex
\begin{minted}[frame=single, mathescape]{cpp}
#include <iostream>
#include <unistd.h>
#include <pthread.h>

using namespace std;

void *thread(void *ptr){
  for(int i=0; i<3; i++){
    sleep(1);
    cout << "This is a pthread."  << endl;
  }

  return 0;
}

int main(int argc, char *argv[])
{
  pthread_t id;
  int ret = pthread_create(&id, NULL, thread, NULL);
  if(ret){
    cout << "Created pthread error!" << endl;
    return -1;
  }
  for(int i=0; i<3; i++){
    cout << "This is the main process." << endl;
    sleep(1);
  }
  pthread_join(id, NULL);
  return 0;
}

\end{minted}
#+end_latex

***** g++ 编译
#+begin_latex
\begin{minted}[frame=single, mathescape]{sh}
g++ thread.cpp  # 链接错误
g++ -lpthread thread.cpp  # 链接错误
g++ thread.cpp -lpthread  # 正确
g++ -pthread thread.cpp  # 正确
\end{minted}
#+end_latex

1. *实际的做法应该是在代码文件后面添加次选项。*
2. -lpthread VS -pthread
   1) -lpthread 传统的，老式的
   2) 可见编译选项中指定 -pthread 会附加一个宏定义 *-D_REENTRANT* ，该宏
      会导致 libc 头文件选择那些thread-safe的实现；链接选项中指定
      -pthread 则同 -lpthread 一样，只表示链接 POSIX thread 库。由于
      libc 用于适应 thread-safe 的宏定义可能变化，因此在编译和链接时都
      使用 -pthread 选项而不是传统的 -lpthread 能够保持向后兼容，并提
      高命令行的一致性。

***** 常用函数

1. *pthread_t* 线程标识符
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{cpp}
        typedef unsigned long int pthread$_t;
     \end{minted}
   #+end_latex

2. *pthread_create* 创建线程
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{cpp}
     extern int pthread_create (pthread_t *__restrict __newthread,
                                const pthread_attr_t *__restrict __attr,
                                void *(*__start_routine) (void *),
                                void *__restrict __arg) __THROWNL __nonnull ((1, 3));
     \end{minted}
   #+end_latex
   1) arg1： 指向线程标识符的指针
   2) arg2： 设置线程属性，NULL表示默认
   3) arg3： 线程运行函数的起始地址
   4) arg4： 运行函数的参数，NULL表示零参
   5) 返回值： 0表示创建线程成功，失败则返回其它。
      + EAGAIN: 系统限制创建线程
      + EINVAL: 线程属性值非法

3. *pthread_join* 用来等待一个线程的结束
   #+begin_latex
   \begin{minted}[frame=single, mathescape]{cpp}
   extern int pthread_join (pthread_t __th, void **__thread_return);
   \end{minted}
   #+end_latex
   1) arg1: 线程标识符指针
   2) arg2: 用户定义的指针，用来存储被等待线程的返回值。

4. *pthread_exit*

***** 线程属性

对于大多数程序来说，默认属性(NULL)就足够了。线程属性包括：是否绑定、是
否分离、堆栈地址、堆栈大小、优先级。默认的属性为非绑定、非分离、缺省1M
的堆栈、与父进程同样级别的优先级。

属性结构 *pthread_attr_t* 定义在头文件<pthread.h>中。

属性值不能直接设置，必须使用相关函数。
+ pthread_attr_init
+ pthread_attr_setscope等

** C++11                                                             :cpp11:
*** DONE [[https://app.yinxiang.com/shard/s52/nl/11551545/bbef3800-db30-4966-bc75-ce63217e2d19/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D1517559bd9e%3AS%3D4f423340d7084977e2b162680fdfe6c9][C++11 Thread]]                                        :thread:cpp11:
- State "DONE"       from ""           [2015-12-06 日 11:24] \\
  仅限了解

C++11标准 /直接提供了并发编程的支持/ ，这是C++新标准中非常重要的部分，
可以极大的提高程序的 /可移植性/ 。

以前的多线程编程基本上依赖于特定的操作系统，比如Linux环境下使用
/pthread/ 库。

*** [[https://app.yinxiang.com/shard/s52/nl/11551545/7bb2be9a-d487-4905-9fcd-f69f48ecc287?title=%E3%80%90C%2B%2B11%E3%80%91%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94auto%E7%9A%84%E4%BD%BF%E7%94%A8%20-%20%E6%B8%85%E9%A3%8E%E5%B0%8F%E9%98%81%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET][auto关键字]]                                                 :auto:cpp11:

有些高级特性知道即可，不需用完全掌握。

c++11中引入的auto主要有两种用途：
+ *自动类型推断*
+ *返回值占位*

auto在c++98中的标识临时变量的语义，由于使用极少且多余，在c++11中已被删
除。前后两个标准的auto，完全是两个概念。

*** DONE [[https://app.yinxiang.com/shard/s52/nl/11551545/49063b6f-c21c-4663-9120-3bbf64c00fc7?title=C%2B%2B11%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0(lambda%E5%87%BD%E6%95%B0%2Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F)%20-%20Augusdi%E7%9A%84%E4%B8%93%E6%A0%8F%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET][C++匿名函数]]                                         :cpp11:lambda:
- State "DONE"       from ""           [2015-12-06 日 11:28] \\
  仅限了解，需要时再查阅，反正也记不住

C++11提供了对匿名函数的支持,称为Lambda函数(也叫Lambda表达式). Lambda表
达式具体形式如下:

#+begin_latex
\begin{minted}[frame=leftline, mathescape]{text}
[capture](parameters)->return-type{body}
\end{minted}
#+end_latex

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{cpp}
  [](int i){return i%2;}
  \end{minted}
#+end_latex
　　　　

** C++Tutorials                                                   :tutorial:
*** c++ primer
** Gcc                                                                 :gcc:
*** DONE [#B] gcc简介
DEADLINE: <2015-03-15 日>
- State "DONE"       from "START"      [2015-03-03 二 21:32]
- State "START"      from "TODO"       [2015-03-03 二 20:40]
- State "TODO"       from ""           [2015-03-01 日 12:30]
 Date:<2015-02-27 五>

**** 简介
GCC 的意思也只是 *GNU C Compiler* 而已。经过了这么多年的发展，GCC 已经不仅
仅能支持 C 语言；它现在还支持 Ada 语言、C++ 语言、Java 语言、Objective C
语言、Pascal 语言、COBOL语言，以及支持函数式编程和逻辑编程的 Mercury 语
言，等等。而 GCC 也不再单只是 GNU C 语言编译器的意思了，而是变成了
*GNU Compiler Collection* 也即是 GNU 编译器家族的意思了。另一方面，说
到 GCC 对于操作系统平台及硬件平台支持，概括起来就是一句话：无所不在。
**** 简单编译
#+BEGIN_EXAMPLE
  #include <stdio.h>
  int main(void)
  {
      printf("Hello World!\n");
      return 0;
  }
#+END_EXAMPLE

编译(一步到位): *$ gcc test.c -o test*

实质上，上述编译过程是分为四个阶段进行的，即
+ 预处理(也称预编译，Preprocessing)
+ 编译(Compilation)
+ 汇编 (Assembly)
+ 连接(Linking)

***** 预处理 -E
*$ gcc -E test.c -o test.i 或 gcc -E test.c*
#+BEGIN_EXAMPLE
  # 1 "test.c"
  # 1 "<command-line>"
  # 1 "/usr/include/stdc-predef.h" 1 3 4
  # 1 "<command-line>" 2
  # 1 "test.c"
  # 1 "/usr/include/stdio.h" 1 3 4
  # 27 "/usr/include/stdio.h" 3 4
  # 1 "/usr/include/features.h" 1 3 4
  # 374 "/usr/include/features.h" 3 4

  ...

  typedef unsigned char __u_char;
  typedef unsigned short int __u_short;
  typedef unsigned int __u_int;
  typedef unsigned long int __u_long;

  ...

  int main(void)
  {
      printf("Hello World!\n");
      return 0;
  }
#+END_EXAMPLE
+ test.i是test.c经过预处理之后的代码, 本列中预处理的结果是把stdio.h文
  件中的内容插入到test.c中.
+ gcc的 *-E* 选项，可以让编译器在预处理后停止，并输出预处理结果。

***** 编译为汇编代码(Compile) -S
*$ gcc -S test.i -o test.s*

+ 预处理之后，可直接对生成的test.i文件编译，生成汇编代码
+ gcc的-S选项，表示在程序编译期间，在生成汇编代码后，停止，-o输出汇编
  代码文件。

***** 汇编(Assembly) -c
*gas汇编器负责将汇编代码编译为目标文件*

*$ gcc -c test.s -o test.o*
***** 连接(Linking)
*$ gcc test.o -o test*

*gcc连接器* 是gas提供的，负责:
+ *将程序的目标文件与所需的所有附加的目标文件连接起来*
+ *最终生成可执行文件*
+ 附加的目标文件包括
  - *静态连接库*
  - *动态连接库*

**** 编译多个文件
通常整个程序是由多个源文件组成的，相应地也就形成了多个编译单元，使用GCC
能够很好地管理这些编译单元。假设有一个由test1.c和 test2.c两个源文件组成
的程序，为了对它们进行编译，并最终生成可执行程序test，可以使用下面这条命
令：

*$ gcc test1.c test2.c -o test*

如果同时处理的文件不止一个，GCC仍然会按照预处理、编译和链接的过程依次进
行。如果深究起来，上面这条命令大致相当于依次执行如下三条命令：

gcc -c test1.c -o test1.o
gcc -c test2.c -o test2.o
gcc test1.o test2.o -o test

**** 检错
***** -pedantic
*$ gcc -pedantic illcode.c -o illcode*

-pedantic编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅
只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，-pedantic选项能
够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有
ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提
出警告。

除了-pedantic之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些
选项大多以-W开头，其中最有价值的当数-Wall了，使用它能够使GCC产生尽可能多
的警告信息。
***** -Wall
*$ gcc -Wall illcode.c -o illcode*

+ *GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误
  的栖身之所。*
+ *一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持
  标准、健壮的特性。*
+ *所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！*

***** -Werror
*$ gcc -Werror test.c -o test*

在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停.

**** 库文件连接
开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助
许多函数库的支持才能够完成相应的功能。

从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、
dll）的集合。

Linux下的大多数函数都
+ 默认将头文件放到/usr/include/目录下，
+ 库文件则放到/usr/lib/目录下；
+ Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以
  及系统文件夹下。

但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的
办法来查找所需要的头文件和库文件。

例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官
网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面
包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件
libmysqlclient.so

其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/
mysql/lib

***** 编译成可执行文件
首先我们要进行编译test.c为目标文件，这个时候需要执行

*$ gcc –c –I /usr/dev/mysql/include test.c –o test.o*

***** 链接
最后我们把所有目标文件链接成可执行文件:

*$ gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test*

Linux下的库文件分为两大类分别是
+ 动态链接库（通常以.so结尾）
+ 静态链接库（通常以.a结尾）
+ 二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译
  时静态加载的。

***** 强制链接时使用静态链接库 -static
默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考
虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态
链接库。

在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和
libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:

*$ gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test*

***** 静态库链接时搜索路径顺序：
1. ld会去找GCC命令中的参数-L
2. 再找gcc的环境变量LIBRARY_PATH
3. 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程
   序内的

***** 动态链接时、执行时搜索路径顺序:
1. 编译目标代码时指定的动态库搜索路径
2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径
3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径
4. 默认的动态库搜索路径/lib
5. 默认的动态库搜索路径/usr/lib

***** 有关环境变量：
+ *LIBRARY_PATH*: 指定程序静态链接库文件搜索路径
+ *LD_LIBRARY_PATH*: 指定程序动态链接库文件搜索路径
*** DONE [#B] gcc头文件
DEADLINE: <2015-03-15 日>
- State "DONE"       from "TODO"       [2015-03-04 三 01:09]
- State "TODO"       from ""           [2015-03-01 日 12:31]
 Date:<2015-02-27 五>

参考:
+ http://blog.sina.com.cn/s/blog_6f4e385c0101ksu0.html

gcc寻找头文件的路径(按照1->2->3的顺序)

1. 在gcc编译源文件的时候，通过参数-I指定头文件的搜索路径
   + 如果指定路径有多个路径时，则按照指定路径的顺序搜索头文件。
   + 命令形式如：“gcc -I  /path/where/theheadfile/in sourcefile.c“
   + 这里源文件的路径可以是绝对路径，也可以是相对路径
2. 通过查找gcc的环境变
   量 *C_INCLUDE_PATH*,  *CPLUS_INCLUDE_PATH*, *OBJC_INCLUDE_PATH* 来
   搜索头文件位置。
3. 再找内定目录搜索，分别是
   + /usr/include
   + /usr/local/include
   + /usr/lib/gcc-lib/i386-linux/2.95.2/include

   最后一行是gcc程序的库文件地址，各个用户的系统上可能不一样。

gcc还有一个参数： *-nostdinc*,它使编译器不再系统缺省的头文件目录里面找
头文件，一般和-I联合使用，明确限定头文件的位置。
在编译驱动模块时，由于非凡的需求必须强制GCC不搜索系统默认路径，也就是
不搜索/usr/include要用参数-nostdinc，还要自己用-I参数来指定内核头文件
路径，这个时候必须在Makefile中指定。
** Gdb                                                                 :gdb:
*** GDB入门
+ /home/ben/Document/C++/GDB教程详解.pdf

**** 使用GDB
1. 功能
   GDB是GNU开源项目组织发布的一个强大的UNIX下的程序调试工具。
   + 启动程序，并按照自定义的要求随心所欲地运行程序
   + 设置断点
   + 查看程序状态
   + 动态改变程序的执行环境

2. GDB VS 图形界面工具(VC, BCB): 寸有所长，尺有所短

3. 基本命令
   + b, break  --- 设置断点
     + b Line
     + b Func
   + info break --- 查看断点编号
   + r, run --- 从开始处运行程序
   + c, continue --- 继续运行程序
   + n, next --- 下一条语句
   + p Var --- 打印变量
   + bt  --- 查看函数堆栈
   + finish --- 退出函数
   + q --- 退出gdb
   + 支持TAB键补全

4. 使用GDB
   1. 编译时添加调试信息
      + gcc -g hello.c
      + g++ -g hello.cpp
      + 如果没有选项-g， 调试时将看不见函数名、变量名等，取而代之的是
        运行时的内在地址
   2. 启动gdb
      + gdb <program>
      + gdb <program> core(???) : 同时调试一个运行程序和core文件
      + gdb <program> <PID> : 指定程序的进程ID
      + program应该在PATH环境变量中搜索得到。
   3. 开头选项
      + -symbols, -s <file> : 从文件中读取符号表
      + -se file : 从指定文件中读取符号表信息，并用在可执行程序中
      + -core, -c <file> : 调试时core dump的文件
      + -d <directory> : 增加一个源文件的搜索路径， 默认路径为PATH所定
        义的路径
      + -help : 查看帮助
**** GDB中运行UNIX的shell命令
1. shell <command>
   + 默认使用 /bin/sh
   + 在Windows中使用Command.exe或cmd.exe
2. make <make-args>
   + 重新build程序
   + 等价于: shell make <make-args>
**** 在GDB中运行程序
1. 查看源文件
   + 启动GDB后，GDB会在PATH路径和当前目录下搜索<program>的源文件
   + 使用l或list命令查看源代码，以确认GDB是否读到源文件
2. 运行程序
   1) 设置运行参数
      + set args ARGS ...
      + show args
   2) 运行路径
      + path <dir>
      + show paths
      + set environment var[=value]
      + show environment [var]
   3) 工作目录
      + cd <dir>
      + pwd
   4) 程序的输入输出
      + info terminal  # 显示终端模式
      + run > outfile  # 重定向
      + tty /dev/ttyb  # 指定输入输出的终设备

**** 调试已运行的程序
1. 方式1
   1) ps  # 查看程序PID
   2) gdb <program> PID  # 挂接正在运行的程序
2. 方式2
   1) gdb <program>  # 关联源代码
   2) attach PID  # 挂接进程
   3) detach PID  # 取消挂接的进程
**** 暂停/恢复程序运行
***** 暂停方式
+ 断点(BreakPoint)
+ 观察点(WatchPoint)
+ 捕捉点(CatchPoint)
+ 信号(Signal)
+ 线程停止(Thread Stops)
***** 设置断点
1. break <function>
2. break <linenum>
3. break +offset
4. break -offset
5. break filename:function
6. break *address  # 在程序运行和内在地址处
7. break   # 没有参数表示在下一条指令处
8. break if <condition>  # 条件成立时停住
***** 查看断点
+ info breakpoints [n]
+ info break [n]
***** 设置捕捉点(CatchPoint)
设置捕捉点来捕捉程序运行时的一些事件。如：载入共享库或是C++异常

catch <event>
+ throw : C++抛出的异常
+ catch : C++捕捉的异常
+ exec : 调用系统调用exec
+ fork : 调用系统调用fork
+ vfork : 调用系统调用vfork
+ load <libname> : 载入共享库时
+ unload <libname> : 卸载共享库时

tcatch <even>  # 只设置一次捕捉点， 当程序停住后，捕捉点被自动删除
***** 维护停止点
+ clear
+ clear <function>
+ clear <filename:function>
+ clear <linenum>
+ clear <filename:linenum>
+ delete [breakpoints] [range] # 不指定断点号则删除全部， 简写为d
+ disable [breakpoints] [range]  # dis
+ enable [breakpoints] [range]
+ enable [breakpoints] once range  # 停止一次后disable
+ enable [breakpoints] delete range  # 停止一次后删除
***** 停止条件维护
+ break和watch支持if, catch不支持if
+ condition <bnum> <expression>  # 修改断点号的停止条件
+ condition <bnum>  # 清除断点号的停止条件
+ igore <bnum>  <count>  # 忽略停止条件指定次数
***** 为停止点设置运行命令
+ 行自动化调试
+ 格式：
  #+BEGIN_EXAMPLE
    commands [bnum]
    ...command-list...
    end
  #+END_EXAMPLE
+ 例程
  #+BEGIN_EXAMPLE
    break foo if x>0
    comomands
    prinft "x if %d\n", x  # 打印变量值
    continue  # 继续运行程序
    end
  #+END_EXAMPLE
***** 断点菜单
在 C++ 中，可能会重复出现同一个名字的函数若干次（函数重载），在这种情
况下， break<function> 不能告诉 GDB 要停在哪个函数的入口。当然，你可以
使用 break <function(type)> 也就是把函数的参数类型告诉 GDB ，以指定一
个函数。否则的话， GDB 会给你列出一个断点菜单供你选择你所需要的断点。
你只要输入你菜单列表中的编号就可以了
#+BEGIN_EXAMPLE
  (gdb)b String::after
  [0] cancel
  [1] all
  [2] file:String.cc; line number:867
  [3] file:String.cc; line number:860
  [4] file:String.cc; line number:875
  [5] file:String.cc; line number:853
  [6] file:String.cc; line number:846
  [7] file:String.cc; line number:735
  > 2 4 6
  Breakpoint 1 at 0xb26c: file String.cc, line 867.
  Breakpoint 2 at 0xb344: file String.cc, line 875.
  Breakpoint 3 at 0xafcc: file String.cc, line 846.
  Multiple breakpoints were set.
  Use the "delete" command to delete unwanted
   breakpoints.
  (gdb)
#+END_EXAMPLE
***** 恢复运行和单步调试
1. 恢复运行
   + continue [ignore-count]
   + c [ignore-count]
   + gf [ignore-count]
2. 单步踊跃
   + step <count>  # 存在函数调用时进入函数
   + next <count>
   + set step-mode
   + set step-mode on
   + set step-mode off
3. 其它
   + finish  # 运行程序，直到当前函数返回
   + until, u  # 运行程序直到退出循环体
   + stepi, si  # *单步跟踪一条机器指令*
   + nexti, ni
   + display/i $pc  # 单步跟踪后打印程序代码和汇编代码
***** TODO 信号
**** TODO 查看源程序
- State "TODO"       from ""           [2015-04-20 一 19:24]
**** TODO 查看运行时数据
**** TODO 改变程序的执行
**** TODO 在不同语言中使用GDB
*** GDB常用命令                                                       :gdb:
**** 启动/退出

+ gdb [FILE] 或xxx-xxxx-xxxx-xxxx-gdb [FILE]：x表示前缀字符，启动gdb，调试FILE(也可以先不指定文件)。

+ quit 退出gdb。

**** 连接操作

+ target remote ip:port ：远程连接，ip表示主机IP地址或主机名(如localhost)，port表示端口号，即配置脚本中gdb_port指定端口号。

**** 文件操作

+ *file* <FILE> ：载入文件FILE，注意：不会下载到目标板上。
+ *load* [FILE] ：把文件下载到目标板上，如果不指定FILE，则下载之前指定过的(比如file 命令指定的，或是gdb 运行时指定的文件)。

**** 查看源程序

+ *list <FUNCTION>* ： 列出某个函数FUNCTION。
+ *list <LINENUM>* ：以当前源文件的某行LINENUM为中间显示一段源程序。
+ *list*  接着前一次继续显示。
+ *break *<address>* ：在某个地址上设置断点，比如 break *0x84。
+ *list -* ：显示前一次之前的源程序。
+ *list <FILENAME:FUNCTION>或list <FILENAME:LINENUM>* ：显示指定文件的一段程序。
+ *info source* ： 查看当前源程序。
+ *info stack* ：查看堆栈信息。
+ *info args* ： 查看当前的参数。

**** 断点操作

+ *break <FUNCTION>* ：在函数入口设置断点。
+ *break <LINENUM>* ：在当前源文件的某一行上设置断点。
+ *break <FILENAME:LINENUM>* ：在指定源文件的某一行上设置断点。
+ *info br* ：查看断点。
+ *delete <number>* ： 删除断点。
+ *diable <number>* ： 禁止断点。
+ *enable <number>* ：使能断点。

**** 监视点(watch)操作

+ *watch <EXPRESSION>* ：当指定变量被写时，程序被停止。
+ *rwatch <EXPRESSION>* ：当指定变量被读时，程序被停止。

**** 数据操作

+ *print < EXPRESSION >* ：查看数据。
+ *set varible=value* ：设置变量。
+ *x /NFU ADDR* ： 检查内存值。
  - *N* 代表重复数
  - *F* 代表输出格式
    + *x* ：16 进制整数格式
    + *d* ：有符号十进制整数格式
    + *u* ：无符号十进制整数格式
    + *f* ：浮点数格式
  - *U* 代表输出格式* ：
    + *b* ：字节(byte)
    + *h* ：双字节数值
    + *w* ：四字节数值
    + *g* ：八字节数值

  比如“x /4ub 0x0”将会显示0 地址开始到4 个字节。

**** 执行程序

+ *step* ：单步执行，会跟踪进入一个函数。
+ *next* ：单步执行，指令则不会进入函数。
+ *nexti* ：单步执行，执行一条汇编指令。
+ *continue* 继续执行程序，加载程序后也可以用来启动程序

**** 帮助

+ *help [command]* ：列出帮助信息，或是列出某个命令的帮助信息。

**** 其他命令

+ *monitor <command …>* ：调用gdb 服务器软件的命令，比如：“monitor mdw 0x0”就是调用openocd 本身的命令“mdw 0x0”。

** Boost                                                             :boost:
*** What is boost?
Boost是一套开放源代码的、高度可移植的C++库，在C++社区中被成为“准标准
库”。
_要想成为高手，一定要多读高手编写的代码。_ Boost库的代码相当清晰、注释
合理、明明规范，绝对是适合阅读的规范(STL则不然)。
Boost的内容广泛，包括 *数值计算、泛型编程、元编程、智能指针、类型转换
等*

C++的编程范式（Paradigm）
+ 过程式编程（prodedural programming）
+ 面向对象的编程（oop）
+ 泛型编程（generic programming）

e.g.
- 类型转换 —— Boost.lexical_cast
- 复杂文本处理 —— Boost.Tokenizer, Boost.Regex
- 语法分析 —— Boost.Spirit
- 函数反射和组合 —— Boost.Bind
- 函数式编程 —— Boost.Lambda
- 静态断言 ——　 MPL
- 数学　——　Ｂoost.Math, Boost.Graph, Quaternion, MultiArray, Random, Rational
- Python ——　Boost.Python

*** Boost库简介
|------------------------------+---------------------------|
| 字符串和文本处理　｜         |                           |
|------------------------------+---------------------------|
| Boost.Regex                  | 正则表达式处理            |
| Boost.Spirit                 | 解析器生成框架            |
| Boost.String_algo            | 字符串相关算法，对STL扩展 |
| Boost.Tokenizer              | 字符序列拆分              |
|------------------------------+---------------------------|
| 数据结构、容器、迭代器和算法 |                           |
|------------------------------+---------------------------|
| Boost.Any                    | 对任意类型的值进行类型安全的存取 |
| Boost.Array                  |                                  |

*** boost学习指南
**** 简介
Boost是一套开放源代码、高度可移植的C++库.

boost是一个准标准库，相当于STL的延续和扩充，它的设计理念和STL比较接近，
都是 *利用泛型让复用达到最大化* 。不过对比STL，boost更加实用。STL集中
在算法部分，而boost包含了不少工具类，可以完成比较具体的工作。

boost主要包含一下几个大类：
+ 字符串及文本处理
+ 容器
+ 迭代子 (Iterator)
+ 算法
+ 函数对象和高阶编程
+ 泛型编程
+ 模板元编程
+ 预处理元编程
+ 并发编程
+ 数学相关纠错和测试
+ 数据结构
+ 输入/输出
+ 跨语言支持
+ 内存相关
+ 语法分析
+ 杂项

e.g
+ conversion/lexcial_cast: 数值类型和字符串的转换
+ format: 流的printf-like
+ regex: 正则表达式
+ tokenizer
+ array
+ dynamic_bitset
+ graph
+ mulit_array
+ thread(基于Posix线程)
+ static_assert
+ test
+ concept_check
+ any
+ compresed_pair
+ tuple
+ pyhon
+ pool： 内存池
+ smart_ptr: 智能指针
+ date_time(跨平台)
+ timer
+ uitlity

**** 入门
*想成为高手，一定要多读高手写的源代码*.Boost库的代码则相当清晰，注释合
理，命名规范，绝对是适合阅读的典范。同时，Boost内容广泛，数值计算、泛
型编程、元编程、平台API

**** lexical_cast
***** 字符串->数值
1. 标准C库函数
   1) "123" -> (int)123: *atoi*
   2) "123" -> (long)123: *atol*
   3) "123.12" -> (double)123.12: *atod*
   4) "123.12" -> (long double)123.12: *atold*

2. 标准库string

   string -> const char* -> ato*(把陌生的问题转换为熟悉的问题)

3. lexical_cast

   1) 头文件: #include <boost/lexical_cast.hpp>

   2) eg

     #+header: :exports both
     #+header: :tangle /home/ben/Tiger/Journal/src/1503312016.cpp
     #+BEGIN_SRC C++
       #include <iostream>
       #include <boost/lexical_cast.hpp>

       int main(int argc, char *argv[])
       {
         using boost::lexical_cast;
         int a = lexical_cast<int>("123");
         double b = lexical_cast<double>("123.12");
         std::cout << a << std::endl;
         std::cout << b << std::endl;
         return 0;
       }

     #+END_SRC

     #+RESULTS:
     |    123 |
     | 123.12 |

***** 数值->字符串
1. 标准C函数库没有类似atol的提供方法.

2. 使用sprintf
   #+BEGIN_EXAMPLE
   sprintf(s, "%f", 123.12);
   #+END_EXAMPLE

3. lexical_cast

   #+header: :exports both
   #+header: :tangle /home/ben/Tiger/Journal/src/1503312028.cpp
   #+BEGIN_SRC C++
     #include <string>
     #include <boost/lexical_cast.hpp>

     int main(int argc, char *argv[])
     {
       using std::string;
       const double d = 123.123456789;
       string s = boost::lexical_cast<string>(d);
       std::cout << s << std::endl;
       return 0;
     }
   #+END_SRC

   #+RESULTS:
   : 123.123456789

***** 异常
如果转换失败，则会有异常bad_lexical_cast抛出。该异常类是标准异常类
bad_cast的子类

注: org-babel只能捕获标准输出, 异常和错误暂时不支持, 或者说我不知道.

#+header: :exports both
#+header: :tangle /home/ben/Tiger/Journal/src/1503312033.cpp
#+BEGIN_SRC C++
  #include <iostream>
  #include <boost/lexical_cast.hpp>

  int main(int argc, char *argv[])
  {
    using std::cout;
    using std::endl;
    int i;
    try{
      i = boost::lexical_cast<int>("abcd");
    }
    catch(boost::bad_lexical_cast& e){
      cout << e.what() << endl;
      cout << "error in casting" << endl;
      return 1;
    }
    cout << i << endl;
    return 0;
  }

#+END_SRC

#+RESULTS:

ERROR: bad lexical cast: source type value could not be interpreted as
target error in casting.

***** 注意事项
1. 输入数据必须完整转换, 否则会抛出异常.eg.
   #+BEGIN_EXAMPLE
   boost::lexical_cast<int>("123.123").
   #+END_EXAMPLE
2. 浮点数的精度问题

   经验证, 新的版本已经排除了精度限制的bug.

**** 智能指针
***** 简介
智能指针是存储指向动态分配（堆）对象指针的类。除了能够在适当的时间自动删除指向的对
象外，他们的工作机制很像C++的内置指针。智能指针在面对异常的时候格外有用，因为他们
能够确保正确的销毁动态分配的对象。他们也可以用于跟踪被多用户共享的动态分配对象。
事实上，智能指针能够做的还有很多事情，例如处理线程安全，提供写时复制，确保协议，并
且提供远程交互服务。

智能指针的大部分使用是用于生存期控制，阶段控制。它们使用operator->和
operator*来生成原始指针，这样智能指针看上去就像一个普通指针。

***** 分类
+ scoped_ptr: 单个对象的唯一所有权
+ scoped_array: 处理数组
+ shared_ptr: 允许共享对象的所有权
+ shared_array: 允许共享数组所有权

***** TODO shared_ptr

**** TODO Thread

*** DONE 超越C++标准库Boost
- State "DONE"       from "TODO"       [2015-04-24 五 21:20]
**** DONE Boost:Smart_ptr
SCHEDULED: <2015-04-05 日>
- State "DONE"       from "TODO"       [2015-04-13 一 22:16]
***** smart_ptr库

+ shared_prt : 共享所有权(shared ownership)
+ weak_ptr : 共享资源
+ scoped_ptr/scoped_array : 限制作用域 , 异常安全的(expction-safe)
***** when
+ 资源的共享所有权

  共享所有权(shared ownership)指两个或多个对象必须同时使用第三个对象时
  的情况(何时释放？)

+ 编写异常安全的代码

  动态分配的对象，在异常抛出时不会删除该对象。

+ 避免常见的错误，如资源泄漏

***** 智能指针scoped_ptr

****** 头文件
+ boost/scoped_ptr.hpp
+ 不能转移所有权，即不能复制或赋值
+ 轻量级

****** 成员
1. 构造函数
   + explicit scoped_ptr(T* p=0)
   + 类型T不必是完整的，只需要对T进行前声明即可

2. ～scoped_ptr()

3. void reset()
   + 重置

4. T &openrator*() const
   + 返回智能指针存储的指针指向的对象的引用

   + 注： 不允许空的引用

5. T* operator->()const
   + 返回智能指针所存储的指针

   + 空指针会抛出异常

6. T* get() const
   + 返回智能指针所存储的指针，直接操作裸指针(raw pointer)

7. void swap(scoped_ptr& b)
   + 交换

****** 使用
智能指针scoped_ptr的使用方法与普通指针的用法没有多大区别，最重要的一点
是不必再记着在指针上调用delete函数， 也不允许复制。

***** scoped_array

***** shared_ptr

***** shared_array

***** intrucsive_ptr
shared_ptr的侵入式版本， 暂时不看。

***** weak_ptr
shared_ptr的观察者， 不懂。
**** Convention库
+ 提供可理解、可维护以及一致的多态转换(polymorphic convention)
+ 静态向下转换(downcast)使用比static_cast更安全的构造
+ 保持值范围(range-preserving)的数值转换
+ 正确且可重用的词汇转换

***** polymorphic_cast
+ 头文件: "boost/cast.hpp"
+ dynamic_cast的引用(空引用抛出异常)和指针(空指针返回空)的不一致性
+ 针对指针的版本
+ 向下转换(向基类)
+ 交叉转换(crosscast)，即从一个基类到另外一个基类的转换
+ 如果不认为失败的多态指针转换是错误的话，那么就应该使用dynamic_cast

***** polymorphic_downcast
+ "boost/cast.hpp"
+ dynamic_cast效率低，static_cast风险大
+ 发布模式 VS 调试模式

***** numeric_cast
+ "boost/cast.hpp"
+ 整型转换的范围问题
  - C++，转换依赖于实现
  - boost, 抛出bad_numeric_cast异常
+ 无符号整型
  - 任何数值都可以合法地赋值给无符号整型
  - 范围
  - 符号，即负数转换
+ 浮点数
  - double -> float, 精度损失，boost不会抛出异常
  - 浮点 -> 整型， 截断后判断范围

***** lexical_cast
+ "boost/lexical_cast.hpp"
+ 词法转换
+ bad_lexical_cast异常
+ 要求：
  - 源类型是可流输出的(OutputStreamable)
  - 目标类型是可流输入的(InputStreamable)
  - 两者都是可复制构造的(CopyConstructible)

**** DONE Utility
SCHEDULED: <2015-04-08 三>
- State "DONE"       from "TODO"       [2015-04-14 二 14:59]
- State "TODO"       from "TODO"       [2015-04-14 二 14:59]
***** BOOST_STATIC_ASSERT
+ "boost/static_assert.hpp"
+ 编译时断言
+ BOOST_STATIC_ASSERT 宏
+ 类和函数的参数化判断

***** checked_delete
+ "boost/checked_delete.hpp"
+ 在删除动态对象时，必须调用它的析构函数，如果类型是不完整的，即只有声
  明没有定义，那么就有可能没有调用函数，这是一种潜在的危险状态。(编译
  时可能没有警告提示)
+ checked_delete 确保类型是完整的，在编译时提示错误
+ checked_array_delete
+ 没有运行时的额外开销

***** noncopyable
+ "boost/utility.hpp"
+ 作为基类使继承类不可复制或进行赋值
  + 编译器自动提供复制构造函数和赋值运算符
  + 当类拥有不能复制或不能赋值的基类或成员函数时，编译器造成的复制构造
    函数和赋值运算符就会不可用
  + 以私有方式继承(默认)，因为继承关系不明显
+ 原理：基类中定义复制构造函数和赋值运算符为私有访问，因而不可访问
+ 也可以自行以私有方式定义两者，但意图不清晰，而且麻烦
+ Big Three *析构函数，复制构造函数和赋值运算符总要同时出现*

***** addressof
+ "boost/utility.hpp"
+ 重载operator&是可能的，但一定是邪恶的
+ addressof(ptr)

***** enable_if
没看

**** Operator
Boost.Operator允许只定义比较运算符或算术运算符的一个子集，然后可以基于
所提供的运算符自动定义其它的运算符。

Boost.Operator为适用于不同操作的抽象概念提供了显式的命名。基类的合集。

***** Operator库
头文件："boost/operators.hpp"  ---  基类的合集
1. less_than_comparable
   + bool operator<(const T&, const T&) (*)
   + bool operator>(const T&, const T&)
   + bool operator<=(const T&, const T&)
   + bool operator>=(const T&, const T&)

2. equailty_comparable
   + bool operator==(const T&, const T&) (*)
   + bool operator!=(const T&, const T&)

3. addable
   + T operator+(const T&, const T&)
   + T operator+=(const T&)  (*)

4. subtractable
   + T operator-(const T&, const T&)
   + T operator-=(const T&)  (*)

5. orable
   + T operator|(const T&, const T&)
   + T operator|=(const T&, const T&)  (*)

6. andable
   + T operator&(const T&, const T&)
   + T operator&=(const T&, const T&)  (*)

7. incrementable
   + T& operator++(T&)  (*)
   + T& operator++(T&,int)

8. decrementable
   + T& operator--(T&)  (*)
   + T& operator--(T&,int)

9. equivalent
   + bool operator<(const T&, const T&)  (*)
   + bool operator+=(const T&, const T&)

10. 解引用
    1) dereferenceable
       + P operator->() const;
       + R operator*() const;  (*)
    2) indexable
       + R operator[](D) const;
       + R operator+(const T&, D)  (*)

11. 组合

***** 使用： 通过继承基类
#+BEGIN_EXAMPLE
class some_class : boost::equivalent<some_class>
#+END_EXAMPLE
把派生类作为模板传递给基类，称为Barton-Nackmann技巧

**** DONE Regex
SCHEDULED: <2015-04-12 日>
- State "DONE"       from "TODO"       [2015-04-16 四 21:00]

+ 为C++提供正则表达式(regular expression)的支持
+ 提高输入验证(input validation)的健壮性
+ Regex是最著名的C++正则表达式库之一

***** Regex库
+ 头文件: "boost/regex.hpp"
+ 核心类: basic_regex
  + basic_regex(const charT*p, flag_type f)
    + bad_expression / regex_error（异常）
+ regex_math()
+ regex_search()
+ regex_replace

***** 使用

****** 元字符
- .  任意字符
- =\d=  数字 (注意需要转义)
- =\w=  单词字符
- [abc]
- [a-zA-Z]
- * (>=0)
- + (>=1)
- =\s=  空格
- ()
- =\= 后向引用(back reference)

****** 匹配
+ boost::regex_match(str, reg)
+ g++ main.cpp -lboost_regex

****** 查找
+ match_result对象用来报告匹配结果
  + typedef match_result<const char*> cmatch
  + typedef match_result<const wchar_t> wcmatch
  + typedef match_result<std::string::const_iterator> smatch
  + typedef match_result<std::wstring::const_iterator> wmatch
+ bool boost::regex_search(str, match_results, reg)
+ bool boost::regex_search(iter1, iter2, match_result, reg)
  #+BEGIN_EXAMPLE
      std::string::const_iterator it = s.begin();
      std::string::const_iterator end = s.end();

      while(boost::regex_search(it, end, m, reg)){
        m[1].matched ? ++new_counter : ++delete_counter;
        it = m[0].second;  # 每匹配一次，把范围起始点更新为上一次匹配的结束点
      }
  #+END_EXAMPLE

****** 替换
+ boost::regex_replace(str, reg, str_or_占位)
+ $NUM占位， reg中的后向引用序号
+ flag:
  - boost::icase --- ignore case
  - boost::regex::perl --- ?
#+BEGIN_EXAMPLE
    boost::regex reg("(Colo)(u)(r)", boost::regex::icase | boost::regex::perl);
    std::string s = "Colour, colours, color, colourize";

    s = boost::regex_replace(s, reg, "$1$3");
    std::cout << s;
#+END_EXAMPLE

**** any
***** any类
+ "boost/any.hpp"
+ any类允许对任意类型进行类型安全的存储和检测。
+ any所存储类的要求：
  - 可复制构造(CopyCOnstructible)
  - 析构函数不抛出异常：所有析构都应如此
  - 可赋值(Assignable)
+ 成员
  + any()
  + any(const any& oter)
  + template<typename ValueType> any(const ValueType)
  + ~any()
    + 裸指针(raw pointer)应包装在shared_ptr中
  + any swap(any& other)
  + template<typename ValueType> any& operator=(const ValueType& value)
  + bool empty() const
  + const std::type_info& type() const
+ 自由函数
  + 只有在知道
  + template<typename ValueType> ValueType any_cast(const any& operand)
    + 类型不符则抛出异常
  + template<typename ValueType> const ValueType* any_cast(const any* operand)
    + 类型不符返回空指针
    + 如果失败不代表错误时应该使用指针形式的any_cast
  + template<typename ValueType> ValueType* any_cast(any* operand)
+ 异常: bad_any_cast
***** 存储任意类型
使用any类将异构类型存储到容器中是一种最常见的方法。

#+header: :exports both
#+header: :tangle /home/ben/Project/C++/Boost/BeyondSTL/Any/any1.cpp
#+BEGIN_SRC cpp
  #include <iostream>
  #include <string>
  #include <utility>
  #include <vector>
  #include <boost/any.hpp>

  class A{
  public:
    void some_function(){std::cout << "A::some_function()\n";}
  };

  class B{
  public:
    void some_function(){std::cout << "B::some_function()\n";}
  };

  class C{
  public:
    void some_function(){std::cout << "C::some_function()\n";}
  };

  int main(){
    std::cout << "Example of using any. \n\n";

    std::vector<boost::any> store_anything;

    store_anything.push_back(A());
    store_anything.push_back(B());
    store_anything.push_back(C());

    // while we're at it, let's add a few other things as well
    store_anything.push_back(std::string("This is fantastic! "));
    store_anything.push_back(3);
    store_anything.push_back(std::make_pair(true, 7.92));

    void print_any(boost::any& a);

    std::for_each(
      store_anything.begin(),
      store_anything.end(),
      print_any);

  }

  void print_any(boost::any& a){
    if(A* pA=boost::any_cast<A>(&a)){
      pA->some_function();
    }
    else if(B* pB=boost::any_cast<B>(&a)){
      pB->some_function();
    }
    else if (C* pC=boost::any_cast<C>(&a)){
      pC->some_function();
    }
    else{
      try{
        std::cout << boost::any_cast<std::string>(a) << '\n';
      }
      catch(boost::bad_any_cast&){
        std::cout << "Oops!\n";
      }
    }
  }
#+END_SRC

#+RESULTS:
| Example            | of | using      | any. |
|                    |    |            |      |
| A::some_function() |    |            |      |
| B::some_function() |    |            |      |
| C::some_function() |    |            |      |
| This               | is | fantastic! |      |
| Oops!              |    |            |      |
| Oops!              |    |            |      |

***** 属性类
#+header: :exports both
#+header: :tangle /home/ben/Project/C++/Boost/BeyondSTL/Any/any2.cpp
#+BEGIN_SRC cpp
  #include <iostream>
  #include <string>
  #include <vector>
  #include <algorithm>
  #include <boost/any.hpp>

  class property{
    boost::any value_;
    std::string name_;

  public:
    property(const std::string& name, const boost::any& value)
      : name_(name), value_(value){}

    std::string name() const { return name_; }
    boost::any& value() {return value_; }

    friend bool operator< (const property&  lhs, const property& rhs){
      return lhs.name_ < rhs.name_;
    }
  };

  void print_names(const property& p){
    std::cout << p.name() << "\n";
  }

  int main(){
    std::cout << "Example of using any for storing properties.\n";

    std::vector<property> properties;
    properties.push_back(property("B", 30));
    properties.push_back(property("A", std::string("Thirty something")));
    properties.push_back(property("C", 3.1415));

    std::sort(properties.begin(), properties.end());

    std::for_each(properties.begin(), properties.end(), print_names);

    std::cout << "\n";

    std::cout << boost::any_cast<std::string>(properties[0].value()) << std::endl;
    std::cout << boost::any_cast<int>(properties[1].value()) << std::endl;
    std::cout << boost::any_cast<double>(properties[2].value()) << std::endl;
  }
#+END_SRC

#+RESULTS:
| Example | of        | using | any | for | storing | properties. |
| A       |           |       |     |     |         |             |
| B       |           |       |     |     |         |             |
| C       |           |       |     |     |         |             |
|         |           |       |     |     |         |             |
| Thirty  | something |       |     |     |         |             |
| 30      |           |       |     |     |         |             |
| 3.1415  |           |       |     |     |         |             |

Note:
+ for_each
+ 类的构造函数参数为 const boost::any&, 缺少 const 修饰符会导致编译错
  误

***** 在any中存储指针
祼指针(void*)的销毁不需要对祼指针调用delete或delete[],而使用any会保留
存储对象的一份副本，这份副本与any一起销毁。因此，使用any存储指针问题重
重。更好的办法是使用智能指针smart_ptr.

#+header: :exports both
#+header: :tangle /home/ben/Project/C++/Boost/BeyondSTL/Any/any3.cpp
#+BEGIN_SRC cpp
  #include <iostream>
  #include <string>
  #include <algorithm>
  #include <vector>
  #include <boost/any.hpp>
  #include <boost/shared_ptr.hpp>

  class A{
  public:
    virtual ~A(){std::cout << "A::~A()\n";}

    void not_virtual(){std::cout << "A::not_virtual()\n";}
    virtual void is_virtual(){std::cout << "A::is_virtual()\n";}
  };


  class B : public a{
  public:
    void not_virtual(){std::cout << "B::not_virtual()\n";}
    virtual void is_virtual(){std::cout << "B::is_virtual()\n";}
  };

  void foo(boost::any& a){
    std::cout << "\n";
    // Try boost::shared_ptr<A>
    try{
      boost::shared_ptr<A> ptr = boost::any_cast<boost::shared_ptr<A> >(a);
      std::cout << "This any contained a boost::shared_ptr<A>\n";
      ptr->is_virtual();
      ptr->not_virtual();
      return;
    }
    catch(boost::bad_any_cast& e){}

    try{
      boost::shared_ptr<B> ptr = boost::any_cast<boost::shared_ptr<B> >(a);
      std::cout << "This any contained a boost::shared_ptr<B>\n";
      ptr->is_virtual();
      ptr->not_virtual();
      return;
    }
    catch(boost::bad_any_cast& e){}


    std::cout << "The any didn't contain anything that \
                  concerns this function.\n";
  }


  int main(){
    std::cout << "Example of any and shared_ptr\n";

    boost::any a1(boost::shared_ptr<A>(new A));
    boost::any a2(std::string("Just a string"));
    {
      boost::any b1(boost::shared_ptr<A>(new B));
      boost::any b2(boost::shared_ptr<B>(new B));
      std::vector<boost::any> vec;

      vec.push_back(a1);
      vec.push_back(a2);
      vec.push_back(b1);
      vec.push_back(b2);

      std::for_each(vec.begin(), vec.end(), foo);
      std::cout << "\n";
    }
    std::cout << "any's b1 and b2 have been destoryed which means\n""that the shared_ptr' reference counts become zero\n";

  }
#+END_SRC

#+RESULTS:
| Example          | of  | any         | and       | shared_ptr           |        |           |       |           |
|                  |     |             |           |                      |        |           |       |           |
| This             | any | contained   | a         | boost::shared_ptr<A> |        |           |       |           |
| A::is_virtual()  |     |             |           |                      |        |           |       |           |
| A::not_virtual() |     |             |           |                      |        |           |       |           |
|                  |     |             |           |                      |        |           |       |           |
| The              | any | didn't      | contain   | anything             | that   | concerns  | this  | function. |
|                  |     |             |           |                      |        |           |       |           |
| This             | any | contained   | a         | boost::shared_ptr<A> |        |           |       |           |
| B::is_virtual()  |     |             |           |                      |        |           |       |           |
| A::not_virtual() |     |             |           |                      |        |           |       |           |
|                  |     |             |           |                      |        |           |       |           |
| This             | any | contained   | a         | boost::shared_ptr<B> |        |           |       |           |
| B::is_virtual()  |     |             |           |                      |        |           |       |           |
| B::not_virtual() |     |             |           |                      |        |           |       |           |
|                  |     |             |           |                      |        |           |       |           |
| A::~A()          |     |             |           |                      |        |           |       |           |
| A::~A()          |     |             |           |                      |        |           |       |           |
| any's            | b1  | and         | b2        | have                 | been   | destoryed | which | means     |
| that             | the | shared_ptr' | reference | counts               | become | zero      |       |           |
| A::~A()          |     |             |           |                      |        |           |       |           |

**** Tuple
+ C++ 允许返回一个值
+ 可以使用struct和class包装
+ 避免复制大对象,使用指针或引用
+ 使用非const的指针或引用参数
+ --> Tuple
  - <= 10
  - 效率较struct不低

***** Tuple库
1. 头文件
   + "boost/tuple/tuple.hpp" --- 核心部分
   + "boost/tuple/tuple_io.hpp" --- 输入输出
   + "boost/tuple/tuple_comparison.hpp" --- 关系运算
   + 将库分散在不同的头文件可以减少编译时间, 仅包含需要的
2. 成员
   + 构造函数
   + 赋值 =
   + get()函数
3. 自由函数
   + make_tuple()
   + tie()
4. 关系运算符
   + ==
   + !=
   + <等
   + 要求
     - 长度相同
     - 每对元素支持同一个关系运算符

***** 使用
****** 构造
1. 构造函数: 声明类型, 以及提供初始值
   + boost::tuple(int, double, std::string) tru(1, 3.14, "hello")
   + 缺省初始值则使用对应类型的默认构造函数
2. make_pair()自动推断元素类型
   + 默认为非const,非引用类型,即最简单最基本的参数类型
     #+BEGIN_EXAMPLE
       int plain = 42;
       int& ref = plain;
       const int& cref=ref;

       boost::make_tuple(plain)
       boost::make_tuple(ref)
       boost::make_tuple(cref)
     #+END_EXAMPLE
     三者所创建的tuple都将拥有一个int类型的元素
   + boost::ref()使tuple元素成为引用类型
     #+BEGIN_EXAMPLE
       boost::make_tuple(boost::ref(plain));
       boost::make_tuple(boost::ref(ref));
       boost::make_tuple(boost::ref(cref))
     #+END_EXAMPLE
   + boost::cref()使tuple元素成为const引用类型
   + ref和cref本是Tuple库的一部分,后来由于其通用性,将其移出去成为独立
     的库
****** 访问
#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/tuple/tuple1.cpp
  #include <iostream>
  #include <string>

  #include <boost/tuple/tuple.hpp>

  int main(){
    boost::tuple<int, double, std::string>
      triple(42, 3.14, "The amazing tuple!");

    int i = boost::tuples::get<0>(triple);
    double d = triple.get<1>();
    std::string s = boost::get<2>(triple);
    std::cout << i << "," << d << "," << s << std::endl;
  }
#+END_SRC

#+RESULTS:
| 42 | 3.14 | The amazing tuple! |

1. template <int I, class T1, class T2, ..., class TN> RI
   get(tuple<T1, T2, ..., TN>t)
   + 位于命名空间tuples, 后者位于命名空间boost
2. 成员函数
   TIndex& get<int Index>()
3. boost::get()??
****** COMMENT 赋值和构造
+ tuple是可以被赋值和复制构造的
+ 元素数量相同
+ 源tuple的元素必须能被转换成目标tuple的元素
#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/tuple/tuple2.cpp
  #include <iostream>
  #include <string>

  #include <boost/tuple/tuple.hpp>


  class base{
  public:
    virtual ~base(){};
    virtual void test(){
      std::cout << "base::test()\n";
    }
  };

  class derived : public base{
  public:
    virtual void test(){
      std::cout << "derived::test()\n";
    }
  };


  int main(){
    boost::tuple<int, std::string, derived> tup1(-5, "Tuple");
    boost::tuple<int, std::string, base> tup2;

    tup2 = tup1;                  // 元组赋值

    tup2.get<2>().test();
    std::cout << "Interesting value: " << tup2.get<0>() << std::endl;

    boost::tuple<double, std::string, base> tup3(tup2); // 元组复制构造
    tup3.get<0>() = 3.14;                               // 元素赋值
    std::cout << tup3.get<0>() << std::endl;


    // 使用指针保存多态
    derived d;
    boost::tuple<int, std::string, derived*>
      tup4(-5, "Tuples", &d);
    boost::tuple<unsigned int, std::string, base*> tup5;
    tup5 = tup4;
    tup5.get<2>()->test();
    std::cout << tup5.get<0>() << std::endl;

    // 引用不能赋值, 可以通过复制构造传递
    boost::tuple<int, std::string, derived&> tup6(123, "Example", d);
    boost::tuple<unsigned int, std::string, base&> tup7(tup6);
    tup7.get<2>().test();

  }

#+END_SRC

#+RESULTS:
| base::test()    |        |    |
| Interesting     | value: | -5 |
| 3.14            |        |    |
| derived::test() |        |    |
| 4294967291.0    |        |    |
| derived::test() |        |    |

Note:
1. 破坏多态 --> 使用引用或指针
2. 数值转换精度损失或正负溢出 --> 使用boost.Conversion库
3. const Tuple的元素中const类型,因而无法赋值
4. 在tuple最好使用智能指针
****** 比较
+ "boost/tuple/tuple_comparison.hpp"
+ 比较是简化的,即依次比较对应元素, 结果一旦明确便立刻返回
+ 支持的比较包括: ==, !=, <, >, <=, >=
+ 支持比较的一个重要方面就是可以进行排序,这意味着它们可以存储在关联窗
  容器中.
+ 当需要根据tuple中的某一元素进行排序时,可以使用一个简单的泛型方法实现

#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/tuple/tuple3.cpp
  #include <iostream>
  #include <vector>
  #include <boost/tuple/tuple.hpp>
  #include <boost/tuple/tuple_comparison.hpp>

  template <int Index> class element_less{
  public:
    template <typename Tuple>
    bool operator()(const Tuple& lhs, const Tuple& rhs) const {
      return boost::get<Index>(lhs)<boost::get<Index>(rhs);
    }
  };

  int main(){
    typedef boost::tuple<short, int, long, float, double, long double> num_tuple;

    std::vector<num_tuple> vec;
    vec.push_back(num_tuple(6,2));
    vec.push_back(num_tuple(7,1));
    vec.push_back(num_tuple(5));

    std::sort(vec.begin(), vec.end(), element_less<1>());

    std::cout << "After sorting:\n " <<
      vec[0].get<0>() << '\n' <<
      vec[1].get<0>() << '\n' <<
      vec[2].get<0>() << '\n';

  }


#+END_SRC

#+RESULTS:
| After | sorting: |
|     5 |          |
|     7 |          |
|     6 |          |
****** 将tuple元素绑定到变量
Boost.Tuple库的一个便利特性就是可以将tuple"绑定"到变量。绑定者就是重载
的函数模板boost::tie所创建的tuple， 它的所有元素都是非const的引用类型。
因此必须使用左值(lvalue)初始化tie，从而tie的参数也必须是非const的引用
类型。

#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/tuple/tuple4.cpp
  #include <iostream>
  #include <boost/tuple/tuple.hpp>
  #include <boost/math/common_factor.hpp>

  boost::tuple<int, int> gcd_lcm(int val1, int val2){
    return boost::make_tuple(
                             boost::math::gcd(val1, val2),
                             boost::math::lcm(val1, val2));
  }

  int main(){
    // The old way
    boost::tuple<int, int> tup;
    tup = gcd_lcm(12, 18);
    int gcd = tup.get<0>();
    int lcm = tup.get<1>();

    std::cout << "Greatest common divisor: " << gcd << '\n';
    std::cout << "Least common multiple: " << lcm << '\n';

    // The new way
    boost::tie(gcd, lcm) = gcd_lcm(15, 20);

    std::cout << "Greatest common divisor: " << gcd << '\n';
    std::cout << "Least common multiple: " << lcm << '\n';

  }
#+END_SRC

#+RESULTS:
| Greatest | common | divisor:  |  6 |
| Least    | common | multiple: | 36 |
| Greatest | common | divisor:  |  5 |
| Least    | common | multiple: | 60 |

+ tuple中有一个特殊对象 *boost::tuples::ignore* ，它可以忽略一个tuple
  元素的值，进而只绑定感兴趣的元素。
+ tie也适用于std::pair对象

****** tuple的流操作
tuple库支持输入和输出流操作，重载了 >> 和 << 运算符，tuple还有一些操纵
符(manipulator)用于改变输入和输出流操作的默认分隔符。

#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/tuple/tuple5.cpp
  #include <iostream>
  #include <boost/tuple/tuple.hpp>
  #include <boost/tuple/tuple_io.hpp>

  int main(){
    boost::tuple<int, double> tup1;
    boost::tuple<long, long, long> tup2;

    std::cout << "Enter an int and a double as (1 2.3):\n";
    std::cin >> tup1;

    std::cout << "Enter three int as |1.2.3|:\n";
    std::cin >> boost::tuples::set_open('|') >> boost::tuples::set_close('|') >>
      boost::tuples::set_delimiter('.') >> tup2;

    std::cout << "Here they are:\n"
              << tup1 << '\n'
              << boost::tuples::set_open('\"')
              << boost::tuples::set_close('\"')
              << boost::tuples::set_delimiter('-');
    std::cout << tup2 << '\n';

  }
#+END_SRC

#+RESULTS:
| Enter | an    | int  | and | a | double | as | (1 | 2.3): |
| Enter | three | int  | as  |   |  1.2.3 | :  |    |       |
| Here  | they  | are: |     |   |        |    |    |       |
| (0    | 0)    |      |     |   |        |    |    |       |
| 0-0-0 |       |      |     |   |        |    |    |       |

**** DONE Bind
SCHEDULED: <2015-04-19 日>
- State "DONE"       from "TODO"       [2015-04-20 一 11:13]

+ 使用标准库的算法时，常常需要提供一个函数或函数对象，这是一个定制算法
  行为的绝好立法。
+ 标准库的bind1st,bind2nd不够用，且语法混乱
+ 泛型绑定器(generalized binder)是一种lambda表达式，通过函数组合，可以
  在调用点构造一个局部的、未命名的函数
  - 减少代码数量
  - 使代码容易理解
  - 行为的局部化

***** bind库
+ "boost/bind.hpp"
+ Bind库创建绑定到函数(自由函数或成员函数)的函数对象
+ 参数数量可以修改
+ 参数顺序可以重新排列
+ 作为用户不直接使用除了bind函数以外的任何对象
+ 参数占位符(placeholder)_1,_2等位于未命名空间，不需要using等进行声明
+ 最多支持9个占位符

***** 绑定普通函数
+ (boost::bind(&func, placeholder))(arugments)
+ 一个表达式可以多次使用同一个占位符
#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/bind/bind1.cpp
  #include <iostream>
  #include <boost/bind.hpp>

  void nine_arguments(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8, int i9){
    std::cout << i1 << i2 << i3 << i4 << i5
              << i6 << i7 << i8 << i9 << std::endl;
  }

  int main(){
    int i1=1, i2=2, i3=3, i4=4, i5=5, i6=6, i7=7, i8=8, i9=9;
    (boost::bind(&nine_arguments, _9, _2, _1, _6, _3, _8, _4, _5, _7))(i1, i2, i3, i4, i5, i6, i7, i8, i9);
  (boost::bind(&nine_arguments, _1, _1, _1, _6, _3, _8, _4, _5, _7))(i1, i2, i3, i4, i5, i6, i7, i8, i9);
  }

#+END_SRC

#+RESULTS:
| 921638457.0 |
|   111638457 |

***** 调用成员函数
#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/bind/bind2.cpp
  #include <iostream>
  #include <string>
  #include <vector>
  #include <algorithm>
  #include <boost/bind.hpp>
  #include <boost/shared_ptr.hpp>

  class status{
    std::string name_;
    bool ok_;

  public:
    status(const std::string& name):name_(name), ok_(true){}

    void break_it(){
      ok_=false;
    }

    bool is_broken() const{
      return ok_;
    }

    void report() const{
      std::cout << name_ << " is "
                << (ok_ ? "working nominally" : "terribly broken") << std::endl;
    }
  };

  int main(){
    std::vector<status> statuses;
    statuses.push_back(status("status 1"));
    statuses.push_back(status("status 2"));
    statuses.push_back(status("status 3"));
    statuses.push_back(status("statue 4"));

    statuses[1].break_it();
    statuses[2].break_it();

    // 使用for循环+迭代器，冗长，效率低（多次调用status.end()）
    for(std::vector<status>::iterator it=statuses.begin(); it!=statuses.end(); ++it){
      it->report();
    }

    std::cout << std::endl;

    // 使用for_each（包含在头文件algorithm中）
    // 元素是以值的方式存储的，需要使用适配器mem_fun_ref
    std::for_each(statuses.begin(), statuses.end(), std::mem_fun_ref(&status::report));

    std::cout << std::endl;

    // 使用Bind库， _1是必须的
    std::for_each(statuses.begin(), statuses.end(), boost::bind(&status::report, _1));

    std::cout << std::endl;

    // 使用指针方式
    std::vector<status*> p_statuses;
    p_statuses.push_back(new status("status 1"));
    p_statuses.push_back(new status("status 2"));
    p_statuses.push_back(new status("status 3"));
    p_statuses.push_back(new status("status 4"));

    p_statuses[1]->break_it();
    p_statuses[2]->break_it();

    // mem_fun适配器，
    std::for_each(p_statuses.begin(), p_statuses.end(), std::mem_fun(&status::report));

    std::cout << std::endl;

    // 语义一致的Boost.Bind库
    std::for_each(p_statuses.begin(), p_statuses.end(), boost::bind(&status::report, _1));

    std::cout << std::endl;
    // 使用智能指针
    std::vector<boost::shared_ptr<status> > s_statuses;
    s_statuses.push_back(
                         boost::shared_ptr<status>(new status("status 1")));
    s_statuses.push_back(
                         boost::shared_ptr<status>(new status("status 2")));
    s_statuses.push_back(
                         boost::shared_ptr<status>(new status("status 3")));
    s_statuses.push_back(
                         boost::shared_ptr<status>(new status("status 4")));

    s_statuses[1] -> break_it();
    s_statuses[2] -> break_it();

    // 标准库没有提供适用于智能指针的适配器，Boost.Bind则对类型没有要求
    std::for_each(s_statuses.begin(),
                  s_statuses.end(),
                  boost::bind(&status::report, _1));

  }
#+END_SRC

#+RESULTS:
| status | 1 | is | working  | nominally |
| status | 2 | is | terribly | broken    |
| status | 3 | is | terribly | broken    |
| statue | 4 | is | working  | nominally |
|        |   |    |          |           |
| status | 1 | is | working  | nominally |
| status | 2 | is | terribly | broken    |
| status | 3 | is | terribly | broken    |
| statue | 4 | is | working  | nominally |
|        |   |    |          |           |
| status | 1 | is | working  | nominally |
| status | 2 | is | terribly | broken    |
| status | 3 | is | terribly | broken    |
| statue | 4 | is | working  | nominally |
|        |   |    |          |           |
| status | 1 | is | working  | nominally |
| status | 2 | is | terribly | broken    |
| status | 3 | is | terribly | broken    |
| status | 4 | is | working  | nominally |
|        |   |    |          |           |
| status | 1 | is | working  | nominally |
| status | 2 | is | terribly | broken    |
| status | 3 | is | terribly | broken    |
| status | 4 | is | working  | nominally |
|        |   |    |          |           |
| status | 1 | is | working  | nominally |
| status | 2 | is | terribly | broken    |
| status | 3 | is | terribly | broken    |
| status | 4 | is | working  | nominally |

+ Boost.Bind提供了语法一致的函数绑定
+ 类型一致
+ 当绑定到成员函数时，第一个占位符必须是成员函数所在类的一个实例
  + 因而，Bind最多支持8个参数的成员函数，第一个传递对象

#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/bind/bind3.cpp
  #include <iostream>
  #include <string>
  #include <boost/bind.hpp>


  class some_class{
  public:
    typedef void result_type;
    void print_string(const std::string s){
      std::cout << s << std::endl;
    }
  };

  void print_string(const std::string s){
    std::cout << s << std::endl;
  }

  int main(){
    (boost::bind(&print_string,_1))("Hello func");

    some_class sc;
    (boost::bind(&some_class::print_string, _1, _2))(sc, "Hello mem");

    // OR
    (boost::bind(&some_class::print_string, some_class(), _1))("Hello mem");
  }
#+END_SRC

#+RESULTS:
| Hello | func |
| Hello | mem  |
| Hello | mem  |



***** 函数组合
#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/bind/bind5.cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>            // std::count_if, std::find_if
  #include <boost/bind.hpp>

  int main(){
    std::vector<int> ints;
    ints.push_back(7);
    ints.push_back(4);
    ints.push_back(12);
    ints.push_back(10);

    int count = std::count_if(
                              ints.begin(),
                              ints.end(),
                              boost::bind(
                                          std::logical_and<bool>(),
                                          boost::bind(std::greater<int>(), _1, 5),
                                          boost::bind(std::less_equal<int>(), _1, 10)));
    std::cout << count << '\n';

    std::vector<int>::iterator int_it=std::find_if(
                                                   ints.begin(),
                                                   ints.end(),
                                                   boost::bind(std::logical_and<bool>(),
                                                               boost::bind(std::greater<int>(), _1, 5),
                                                               boost::bind(std::less_equal<int>(), _1, 10)));

    if(int_it != ints.end()){
      std::cout << *int_it << '\n';
    }
  }
#+END_SRC

#+RESULTS:
| 2 |
| 7 |

***** 动态排序标准
+ 对容器的元素进行排序时，有时需要创建一个定义排序标准的函数对象，即谓
  语
+ 通过bind可以很容易地 *在调用点(callsite)创建所需的谓语*
  + 容易理解
  + 易维护
#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/bind/bind4.cpp
  #include <iostream>
  #include <string>
  #include <algorithm>
  #include <functional>
  #include <vector>
  #include <boost/bind.hpp>


  class person_info{
    std::string name_;
    std::string surname_;
    unsigned int age_;

  public:
    person_info(
                const std::string& n,
                const std::string& s,
                unsigned int age)
      : name_(n), surname_(s), age_(age){}

    std::string name() const{
      return name_;
    }

    std::string surname() const{
      return surname_;
    }

    unsigned int age() const{
      return age_;
    }

    friend std::ostream& operator<<(std::ostream& os, const person_info& pi){
      os << pi.name() << ' ' << pi.surname() << ' ' << pi.age() << '\n';
      return os;
    }
  };

  // 公共继承自std::binary_function
  class person_info_age_less_than :
    public std::binary_function<person_info, person_info, bool>{
  public:
    bool operator()(
                    const person_info& p1, const person_info& p2){
      return p1.age() < p2.age();
    }
  };

  int main(){
    std::vector<person_info> vec;
    vec.push_back(person_info("Little", "John", 30));
    vec.push_back(person_info("Friar", "Tuck", 50));
    vec.push_back(person_info("Robin", "Hood", 40));

    std::sort(
             vec.begin(),
             vec.end(),
             person_info_age_less_than());

    std::cout << vec[0] << std::endl
              << vec[1] << std::endl;

    std::vector<person_info> vec1;
    vec1.push_back(person_info("Little", "John", 30));
    vec1.push_back(person_info("Friar", "Tuck", 50));
    vec1.push_back(person_info("Robin", "Hood", 40));

    std::sort(vec1.begin(),
              vec1.end(),
              boost::bind<bool>(std::less<unsigned int>(),
                                boost::bind(&person_info::age, _1),
                                boost::bind(&person_info::age, _2)));
    std::cout << vec1[0] << std::endl
              << vec1[1] << std::endl;

  }
#+END_SRC

#+RESULTS:
| Little | John | 30 |
|        |      |    |
| Robin  | Hood | 40 |
|        |      |    |
| Little | John | 30 |
|        |      |    |
| Robin  | Hood | 40 |

1. 绑定逻辑操作
   #+BEGIN_EXAMPLE
   boost::bind<bool>(std::less<unsigned int>(), _1, _2)
   #+END_EXAMPLE
   + 显式地增加返回类型
2. 绑定操作的参数
   #+BEGIN_EXAMPLE
     boost::bind<bool>(std::less<unsigned int>(),
                    boost::bind(&person_info::age, _1),
                    boost::bind(&person_info::age, _2));
   #+END_EXAMPLE

**** DONE Boost:Lambda
- State "DONE"       from "TODO"       [2015-04-22 三 16:47]
+ 在调用点定义未命名函数
+ 函数式编程(functional programming)：通过模板实现
+ 避免代码膨胀和功能分散
+ 几乎所有的标准库算法都有一个接受函数对象的版本，lambda表达式定义简单
  的函数对象
+ 在调用的地方定义函数或函数对象，这样快，容易维护

***** 头文件
+ "boost/lambda/lambda.hpp": 核心库
+ "boost/lambda/if.hpp": 定义了相当于if的lambda以及条件操作符
+ "boost/lambda/loops.hpp": 定义了循环结构
+ "boost/lambda/switch.hpp"
+ "boost/lambda/construct.hpp": new/delete
+ "boost/lambda/casts.hpp"
+ "boost/lambda/exception.hpp"
+ "boost/lambda/algorith.hpp"
+ "boost/lambda/numeric.hpp"

***** 更改占位符名称
+ boost::lambda::placeholderX_type (X = 1, 2, 3)
#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/lambda/lambda4.cpp
  #include <iostream>
  #include <vector>
  #include <string>
  #include <boost/lambda/lambda.hpp>

  boost::lambda::placeholder1_type Arg1;
  boost::lambda::placeholder2_type Arg2;
  boost::lambda::placeholder3_type Arg3;

  template <typename T, typename Opertation>
  void for_all(T& t, Opertation Op){
    std::for_each(t.begin(), t.end(), Op);
  }

  int main(){
    std::vector<std::string> vec;
    vec.push_back("What are");
    vec.push_back("the names");
    vec.push_back("of the");
    vec.push_back("placeholders?");
    for_all(vec, std::cout<< Arg1 << " ");
    std::cout << "\nArg1, Arg2, and Arg3!";
  }
#+END_SRC
***** 简单使用
+ lambda表达式也称匿名函数(unnamed function)
+ 创建lambda表达式时没有关键字，占位符的出现表示这是一个lambda表达式
+ using boost::lambda
#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/lambda/lambda1.cpp
  #include <iostream>
  #include <boost/lambda/lambda.hpp>
  #include <boost/function.hpp>

  int main(){
    using namespace boost::lambda;
    (std::cout << _1 << " " << _3 << " " << _2 << "!\n")("Hello", "friend", "my");
    boost::function<void(int, int, int)> f = std::cout << _1 << "*" << _2 << "+" << _3
                                                       << "=" << _1*_2+_3 << "\n";
    f(1, 2, 3);
    f(3, 2, 1);
  }
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Boost/BeyondSTL/Lambda/lambda2.cpp
  #include <iostream>
  #include <string>
  #include <map>
  #include <algorithm>
  #include <boost/lambda/lambda.hpp>
  #include <boost/lambda/bind.hpp>

  int main(){
    using namespace boost::lambda;
    typedef std::map<int, std::string> type;
    type keys_and_values;
    keys_and_values[2] = "Less than pi";
    keys_and_values[42] = "You tell me";
    keys_and_values[0] = "Nothing if you ask me";

    std::cout << "What's wrong with the following expression?\n";

    std::for_each(
                  keys_and_values.begin(),
                  keys_and_values.end(),
                  std::cout << "key=" << bind(&type::value_type::first, _1)
                  << ", value=" << bind(&type::value_type::second, _1) << '\n');

    std::cout << "\n...and why does this work as expected?\n";
    std::for_each(
                  keys_and_values.begin(),
                  keys_and_values.end(),
                  std::cout << constant("key=") <<
                  bind(&type::value_type::first, _1) << ", value="
                  << bind(&type::value_type::second, _1) << '\n');
    std::cout << '\n';
    (std::cout << "keys_and_values.size()=" << bind(&type::size, _1)
     << "\nKeys_and_values.max_size()=" << bind(&type::max_size, _1))(keys_and_values);
  }
#+END_SRC
+ std::cout << "key="仅仅是个表达式，不是lambda表达式(前面也没有占位符
  来作为operator<<的参数使其成为一个有效的lambda表达式)
+ constant函数创建一个无参函数对象仅保存其参数，然后在调用时返回

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Boost/BeyondSTL/Lambda/lambda3.cpp
  #include <iostream>
  #include <boost/lambda/lambda.hpp>
  #include <boost/lambda/bind.hpp>

  class double_it{
  public:
    int operator()(int i) const{
      return i*2;
    }
  };

  int main(){
    using namespace boost::lambda;
    double_it d;
    int i = 12;
    // If you uncomment the following expression
    // the compiler will complain;
    // it;s just not possible to dedece the return type
    // of the function call operator of double_it
    // (std::cout << _1 << "*2" << (bind(d, _1)))(i);
    (std::cout << _1 << "*2=" << (bind<int>(d, _1)))(i);
    (std::cout << _1 << "*2=" << (ret<int>(bind(d, _1))))(i);
  }
#+END_SRC
+ 绑定自由函数和成员函数的语法一致， 不需要显式表明函数返回类型
+ 当被绑定的是函数对象时，不能推测其返回类型
  + 将返回类型作为参数模板传递给bind,来关闭返回类型推断系统
  + 使用ret括住不能进行自动推断的lambda/bind表达式

***** 给常量和变量命名
+ constant
+ var
+ boost::lambda::constant_type<T>::type
+ boost::lambda::var_type<T>::type

#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/lambda/lambda5.cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <boost/lambda/lambda.hpp>

  template <typename T, typename Opertation>
  void for_all(T& t, Opertation Op){
    std::for_each(t.begin(), t.end(), Op);
  }

  int main(){
    using boost::lambda::constant;
    using boost::lambda::constant_type;

    constant_type<char>::type newline(constant('\n'));
    constant_type<char>::type space(constant(' '));
    boost::lambda::placeholder1_type _;
    std::vector<int> vec;
    vec.push_back(0);
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);
    vec.push_back(4);
    for_all(vec, std::cout << space << _ << newline);
    for_all(vec, std::cout << constant(' ') << _ << constant('\n'));
  }
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Boost/BeyondSTL/Lambda/lambda6.cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <boost/lambda/lambda.hpp>

  template<typename T> class memorizer{
    std::vector<T> vec_;
  public:
    memorizer& operator=(const T& t){
      vec_.push_back(t);
      return *this;
    }
    void clear(){
      vec_.clear();
    }
    void report() const{
      using boost::lambda::_1;
      std::for_each(vec_.begin(),
                    vec_.end(),
                    std::cout << _1 << ",");
    }
  };

  int main(){
    using boost::lambda::var_type;
    using boost::lambda::var;
    using boost::lambda::_1;
    std::vector<int> vec;
    vec.push_back(0);
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);
    vec.push_back(4);
    memorizer<int> m;
    var_type<memorizer<int> >::type mem(var(m));
    std::for_each(vec.begin(), vec.end(), mem=_1);
    m.report();
    m.clear();
    std::for_each(vec.begin(), vec.end(),var(m)=_1);
    m.report();
  }
#+END_SRC
注：
#+BEGIN_EXAMPLE
constant_type<const char (&) [6]>::type hello(constant("hello"));
constant_type<std::string>::type hello(constant("hello"));
#+END_EXAMPLE
char*, const char* 不正确, 应声明为含有六个字符的数组的常量引用
***** ptr_fun mem_fun
+ lambda提供语法一致的函数和成员函数绑定， 无须记住标准库的ptr_fun和
  mem_fun

#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/lambda/lambda7.cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <functional>
  #include <boost/lambda/lambda.hpp>
  #include <boost/lambda/bind.hpp>

  void plain_function(int i){
    std::cout << "void plain_function(" << i << ")\n";
  }

  class some_class{
  public:
    void member_function(int i) const{
      std::cout << "void member_function(" << i << ")\n";
    }
  };


  int main(){
    std::vector<int> vec(3);
    vec[0] = 12;
    vec[1] = 10;
    vec[2] = 7;
    some_class sc;
    some_class* psc=&sc;

    // bind to a free function using ptr_fun
    std::for_each(vec.begin(),
                  vec.end(),
                  std::ptr_fun(plain_function));
    // bind to a member function using mem_fun_ref
    std::for_each(vec.begin(),
                  vec.end(),
 p                 std::bind1st(
                               std::mem_fun_ref(&some_class::member_function), sc));
    // bind to a member function using mem_fun
    std::for_each(vec.begin(),
                  vec.end(),
                  std::bind1st(
                               std::mem_fun(&some_class::member_function), psc));
    using namespace boost::lambda;
    std::for_each(vec.begin(),
                  vec.end(),
                  bind(&plain_function, _1));
    std::for_each(vec.begin(),
                  vec.end(),
                  bind(&some_class::member_function, sc, _1));
    std::for_each(vec.begin(),
                  vec.end(),
                  bind(&some_class::member_function, psc, _1));

  }
#+END_SRC

***** 无须functional的算术操作
+ Boost.Lambda支持C++中所有的算术操作符，因此几乎不再需要为了算术函数
  对象而包含<functional>
#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/lambda/lambda8.cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <functional>
  #include <boost/lambda/lambda.hpp>
  #include <boost/lambda/bind.hpp>

  int main(){
    using namespace boost::lambda;
    std::vector<int> vec(3);
    vec[0]=12;
    vec[1]=10;
    vec[2]=7;

    // Transform using std::bind1st and std::plus
    std::transform(vec.begin(),
                  vec.end(),
                  vec.begin(),
                  std::bind1st(std::plus<int>(), 4));
    // Transform using a lambda expression
    std::transform(vec.begin(),
                   vec.end(),
                   vec.begin(),
                   _1-=4);
  }
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Boost/BeyondSTL/Lambda/lambda9.cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <boost/lambda/lambda.hpp>

  int main(){
    using namespace boost::lambda;
    std::vector<int> vec(3);
    vec[0]=1;
    vec[1]=2;
    vec[2]=3;
    std::for_each(vec.begin(), vec.end(), _1+=10);
    std::for_each(vec.begin(), vec.end(), _1-=10);
    std::for_each(vec.begin(), vec.end(), _1*=10);
    std::for_each(vec.begin(), vec.end(), _1/=2);
    std::for_each(vec.begin(), vec.end(), _1%=3);
  }
#+END_SRC

***** 编写可读的谓词

**** Function
+ 为后续的调用存储函数指针和函数对象

***** Function库
1. "boost/function.hpp"
   + 包含可以拥有0～10个参数的函数原型，相应于function/functionN.hpp

2. 声明
   1) 首先语法(preferred syntax)的声明
      #+BEGIN_EXAMPLE
        boost::function<bool (int)> f;
        boost::function<bool (int, double)> f;
      #+END_EXAMPLE
      + 包括签名和返回类型
      + 语法接近函数声明
   2) 兼容语法的声明
      #+BEGIN_EXAMPLE
        boost::function1<bool, int> f;
        boost::function2<bool, int, double> f;
      #+END_EXAMPLE
      + 有数字后缀
      + 兼容更多的编译器
3. 成员
   1) 构造

   2) 赋值=

   3) bool empty const;

   4) void clear(), 赋值更好

   5) result_type operator()(Arg1 a1, Arg2 a2, ...) const


*****
*** boost::shared_ptr                                          :shared_ptr:
shared_prt *引用数智能指针* ： 负责在不使用实例时删除它指向的对象
(pointee)，并且它可以自由地共享它指向的对象。

boost.smart_ptr库中最重要的、最有价值的、最有用的组成部分，最像指针的
“智能指针“。

shared_ptr 包装了 *new* 操作符在 *堆* 上分配的 *动态对象* ，实现的是
*引用计数型的智能指针* ， 可以被自由地拷贝和赋值，在任意地方共享它，当
没有代码使用（引用计算为0）时，它才删除被包装的动态分配的对象。

**** 例1. 简单应用
#+begin_latex
\begin{minted}{cpp}
void test(){
  boost::shared_ptr<int> sp(new int(10));
  assert(sp.unique());
  boost::shared_ptr<int> sp2 = sp;
  assert(sp == sp2 && sp.use_count() == 2);

  *sp2 = 100;
  assert(*sp == 100);
  sp.reset();
  assert(!sp);
}
\end{minted}
#+end_latex

1. assert头文件<cassert>或 <assert.h>

**** 例2. 类
#+begin_latex
\begin{minted}{cpp}
class shared
{
private:
  boost::shared_ptr<int> p;

public:
  shared(boost::shared_ptr<int> p_) : p(p_){}
  void print(){
    std::cout << "count:" << p.use_count()
	      << " v= " << *p << std::endl;
  }
};

void print_func(boost::shared_ptr<int> p){
  std::cout << "count: "<< p.use_count()
	    << " v=" << *p << std::endl;
}

int main(int argc, char *argv[])
{
  test();

  boost::shared_ptr<int> p(new int(1000));
  shared s1(p), s2(p);
  s1.print();
  s2.print();
  *p = 20;
  print_func(p);
  s1.print();

  return 0;
}

\end{minted}
#+end_latex
#+BEGIN_EXAMPLE
count:3 v=1000
count:3 v=1000
count:4 v=20
count:3 v=20
#+END_EXAMPLE

/print_func(p)  why 4?/
/p初始化之后其use_count为2, 又是为何？/

#+begin_latex
\begin{minted}{cpp}
  boost::shared_ptr<int> p(new int(1000));
  std::cout << "count:"<< p.use_count()
	    << " v=" << *p << std::endl;
  assert(p.unique());
  print_func(p);
\end{minted}
#+end_latex

#+BEGIN_EXAMPLE
count:1 v=1000
count:2 v=1000
#+END_EXAMPLE

*问题在于函数参数的传递*

**** 例3. 应用于标准容器

***** 方式1： 将窗口作为shared_ptr管理的对象，e.g. shared_ptr<list<T>>
这样容器可以被安全地共享

***** 方式2： 将shared_ptr作为容器的元素，e.g. vector<shared_ptr<T>>
1. shared_ptr支持拷贝和比较操作，符合标准容器对元素的要求
2. 标准窗口不能容纳auto_ptr，C++标准特别的规定
3. 标准容器不能容纳scoped_ptr，scopted_ptr不能拷贝和比较
4. 标准容器可以容纳原始指针，但这就丧失了标准容器的许多好处，因为标准
   容器无法自动管理类型为指针的元素，必须编写额外的大量代码来保证指针
   最终被正确删除。

#+begin_latex
\begin{minted}{cpp}
  typedef std::vector<boost::shared_ptr<int> > vs;
  vs v(10);
  int i = 0;
  for(vs::iterator pos = v.begin(); pos != v.end(); ++pos){
    (*pos) = boost::make_shared<int>(++i);
    std::cout << *(*pos) << ",";
  }
  std::cout << std::endl;
  boost::shared_ptr<int> pp = v[9];
  *pp = 100;
  std::cout << *v[9] << std::endl;
  return 0;
\end{minted}
#+end_latex

1. typedef：声明boost::shared_ptr<T>变量比较麻烦，所以一般使用typedef
   进行定义别名
2. boost::make_shared()是工厂函数，包含在头文件<boost/make_shared.hpp>
   中
3. *(*pos)可以写成 **pos, 但前者更清晰


**** cpp reference

***** shared_ptr
1. manage the storage of a pointer
   1) providing a limited garbage-collection facility
   2) shareing that management iwth other objects

2. share_ptr object can *only share ownership by copying their value*
   1) If two shared_ptr are contructed of made from the same pointer,
      they will both owning the pointer without sharing it,  causing
      potential access problems when one of them relaeses it and
      leaving the other pointing to an invalid location.

3. *aliasing*
   shared_ptr objects can share ownership over a pointer while at the
   same time pointing to another object.(?)

4. empty shared_prt OR null shared_ptr

** C++Reference
*** srand
**** Initialize random number generator
void srand (unsigned int seed);
<cstdlib> (stdlib.h)

The pseudo-random number generator is initialized using the argument
passed as seed.

For every different seed value used in a call to srand, the
pseudo-random number generator can be expected to generate a different
succession of results in the subsequent calls to rand.

Two different initializations with the same seed will generate the
same succession of results in subsequent calls to rand.

If seed is set to 1, the generator is reinitialized to its initial
value and produces the same values as before any call to rand or
srand.

In order to generate random-like numbers, srand is usually initialized
to some distinctive runtime value, like the value returned by function
time (declared in header <ctime>). This is distinctive enough for most
trivial randomization needs.
** Class
*** 虚析构函数
#+begin_latex
\begin{cpp}
#include <iostream>

class Base{
public:
  Base(){};
  ~Base(){};
  virtual void do_something(){std::cout << "Do something in class Base" << std::endl;
  }
};

class Derived: public Base
{
public:
  Derived(){};
  ~Derived(){std::cout << "Output from the destructor of class Derived" << std::endl;}

  void do_something(){std::cout << "do something in class Derived" << std::endl; }
};


int main(int argc, char *argv[])
{
  Base *pTest = new Derived;	// 指向派生类对象的基类指针
  pTest->do_something();
  delete pTest;			// 必须的，不然不会释放资源，也不会调用析构函数
  return 0;
}

\end{cpp}
#+end_latex

1. output
   do something in class Derived
   Output from the destructor of class Derived

2. 改为 Derived *pTest = new Derived;
   do something in class Derived
   Output from the destructor of class Derived

3. 去掉delete pTest
   do something in class Derived

4. *去掉基类析构函数的virtual*
   do something in class Derived


所以虚析构函数的作用是为了 *当用一个基类的指针删除派生类对象时，派生类
的析构函数会被调用*

当类里有虚函数时，编译器会给类添加一个 *虚函数表* ， 里面用来存放 *虚
函数指针* ， 这样会增加类的存储空间。 因而，只有当一个类 *被用作为基
类* 时，才把析构函数写成虚函数。


参考：[[http://blog.csdn.net/starlee/article/details/619827]]

** STL                                                                 :stl:
*** C++                                                               :cpp:
**** STL map
***** class map
***** constructor
#+begin_latex
\begin{cpp}
bool fncomp(char lhs, char rhs){return lhs<rhs;}

struct classcomp{
  bool operator()(const char& lhs, const char& rhs) const{
    return lhs<rhs;
  }
};

void construct(){
  std::map<char, int> first;

  first['a'] = 10;
  first['b'] = 30;
  first['c'] = 50;
  first['d'] = 70;

  std::map<char, int> second(first.begin(), first.end());

  std::map<char, int> third(second);

  std::map<char, int, classcomp> fourth; // class as Compare

  bool(*fn_pt)(char, char)=fncomp;
  std::map<char, int, bool(*)(char, char)>fifth(fn_pt); // function pointer as Compare
}
\end{cpp}
#+end_latex

***** std::map::at
+ mapped_type& at (const key_type& k);
+ const mapped_type& at (const key_type& k) const;

+ Access element
  - *Returns a reference to the mapped value* of the element
    identified with key k.
  - If k does not match the key of any element in the container, the
    function throws an *out_of_range exception*.

#+begin_latex
\begin{cpp}
void at(){
  std::map<std::string, int> mymap = {
    {"alpha", 0},
    {"beta", 0},
    {"gamma", 0}};


  mymap.at("alpha") = 30;
  mymap.at("beta") = 20;
  mymap.at("gamma") = 10;

  for(auto& x:mymap){
    std::cout < x.first << ":" << x.second << "\n";
  }
}
\end{cpp}
#+end_latex

error: in C++98 ‘mymap’ must be initialized by constructor, not by
‘{...}’   };

error: ISO C++ forbids declaration of ‘x’ with no type [-fpermissive]
   for(auto& x:mymap){

***** std::map::begin/end
Return iterator to begining
#+begin_latex
\begin{cpp}
void begin(){
  std::map<char, int> mymap;
  mymap['a'] = 100;
  mymap['b'] = 200;
  mymap['c'] = 300;

  // show content
  for(std::map<char, int>::iterator it=mymap.begin(); it!=mymap.end(); ++it){
    std::cout << it->first << "=>" << it->second << "\n";
  }
}
\end{cpp}
#+end_latex

***** std::map::cbegin/cend
Return const_iterator to beginning
Note: *C++11*
#+begin_latex
\begin{cpp}
void cbegin(){
  std::map<char, int> mymap;
  mymap['a'] = 100;
  mymap['b'] = 200;
  mymap['c'] = 300;

  // show content
  for(auto it=mymap.cbegin(); it!=mymap.cend(); ++it){
    std::cout << "[" << (*it).first << ":" << (*it).second << "\n";
  }
}
\end{cpp}
#+end_latex

***** std::map::clear
Clear content

***** std::map::empty
Test whether container is empty

#+begin_latex
\begin{cpp}
void empty(){
   std::map<char, int> mymap;
  mymap['a'] = 100;
  mymap['b'] = 200;
  mymap['c'] = 300;

  while(!mymap.empty()){
    std::cout << mymap.begin()->first << "=>" << mymap.begin()->second << '\n';
    mymap.erase(mymap.begin());
  }
}

\end{cpp}
#+end_latex

***** std::map::erase
1) void erase (iterator position);
2) size_type erase (const key_type& k);
3) void erase (iterator first, iterator last);

Erase elements

#+begin_latex
\begin{cpp}
void erase(){
  std::map<char, int> mymap;
  mymap['a'] = 100;
  mymap['b'] = 200;
  mymap['c'] = 300;
  mymap['d'] = 400;
  mymap['e'] = 500;
  mymap['f'] = 600;

  std::map<char,int>::iterator it;

  it = mymap.find('b');
  mymap.erase(it);

  mymap.erase('c');

  it=mymap.find('e');
  mymap.erase(it, mymap.end());

  for(it=mymap.begin(); it!=mymap.end(); ++it){
    std::cout << it->first << "=>" << it->second << "\n";
  }

}
\end{cpp}
#+end_latex

***** std::map::find
1) iterator find (const key_type& k);
2) const_iterator find (const key_type& k) const;
3) Find iterator to element

***** std::map::insert

***** std::map::size
size_type size() const;


***** std::map::count
Count elements with a specific key
Return 1(found) or 0 otherwise

#+begin_latex
\begin{cpp}
void count(){
  std::map<char, int> mymap;
  mymap['a'] = 100;
  mymap['b'] = 200;
  mymap['c'] = 300;

  char c;
  for(c='a'; c<'h'; c++){
    std::cout << c;
    if(mymap.count(c)>0)
      std::cout << " is an element of mymap.\n";
    else
      std::cout << " is not an element of mymap.\n";
  }
}
\end{cpp}
#+end_latex

***** std::map::crbegin/crend
Return const_reverse_iterator to reverse beginning
C++11

*****

**** TOBECONTINED STL algorithm                                      :cpp:
- state "tobecontined" from "todo"       [2015-11-04 三 16:09]

the header <algorithm> defines a collection of functions especially
designed to be used on *ranges* of elements.


a range is any sequence of objects that can be accessed through
*iterators* or pointers, such as an array or an instance of some of the
stl containers. notice though, that algorithms operate through
iterators *directly on the values*, not affecting in any way the
structure of any possible container (it never affects the size or
storage allocation of the container).

***** all_of
+ template <class InputIterator, class UnaryPredicate>
  bool all_of(InputIterator first, InputIterator last, UnaryPredicate pred);

+ Test condition on all elements in range

#+begin_latex
\begin{cpp}
void all_of(){
  std::array<int, 8> foo = {3, 5, 7, 11, 13, 15, 17, 19};

  if(std::all_of(foo.begin(), foo.end(), [](int i){return i%2;}))
    std::cout << "All the elements are odd numbers.\n";
}
\end{cpp}
#+end_latex

#include <array>

error: #error This file requires compiler and library support for the
ISO C++ 2011 standard. This support is currently experimental, and
must be enabled with the *-std=c++11 or -std=gnu++11* compiler
options.

***** any_of
+ template <class InputIterator, class UnaryPredicate>
  bool any_of (InputIterator first, InputIterator last, UnaryPredicate pred);

+ Test if any element in range fulfills condition

#+begin_latex
\begin{cpp}
void any_of(){
  std::array<int, 7> foo = {0, 1, -1, 3, -3, 5, -5};

  if(std::any_of(foo.begin(), foo.end(), [](int i){return i<0;}))
    std::cout << "There are negative elements in the range.\n";
}
\end{cpp}
#+end_latex

***** none_of
+ template <class InputIterator, class UnaryPredicate>
  bool none_of (InputIterator first, InputIterator last, UnaryPredicate pred);

+ Test if no elements fulfill condition

***** for_each
+ template <class InputIterator, class Function>
   Function for_each (InputIterator first, InputIterator last, Function fn);

+ Apply function to range

#+begin_latex
\begin{cpp}
void myfunction(int i){
  std::cout << ' ' << i;
}

struct myclass{
  void operator()(int i){std::cout << ' ' << i;}
}myobject;

void for_each(){
  std::vector<int> myvector;
  myvector.push_back(10);
  myvector.push_back(20);
  myvector.push_back(30);

  std::cout << "myvector contains: ";
  for_each(myvector.begin(), myvector.end(), myfunction);
  std::cout << '\n';

  std::cout << "myvector contains: ";
  for_each(myvector.begin(), myvector.end(), myobject);
  std::cout << '\n';
}
\end{cpp}
#+end_latex

***** find
+ template <class InputIterator, class T>
   InputIterator find (InputIterator first, InputIterator last, const T& val);

+ Find value in range

+ Returns an *iterator to the first element* in the range [first,last)
  that compares equal to val. If no such element is found, the
  function returns *last*.

#+begin_latex
\begin{cpp}
void find(){
  // using std::find with array and pointer
  int myints[] = {10, 20, 30, 40};
  int* p;

  p = std::find(myints, myints+4, 30);
  if(p != myints+4)
    std::cout << "Element found in myints:" << *p << std::endl;
  else
    std::cout << "Element not found in myints.\n";

  // using std::find with vector and iterator:
  std::vector<int>myvector(myints, myints+4);
  std::vector<int>::iterator it;

  it = find(myvector.begin(), myvector.end(), 30);
  if( it != myvector.end())
    std::cout << "Element found in myvector" << std::endl;
  else
    std::cout << "Element not found in myvector" << std::endl;

}
\end{cpp}
#+end_latex



**** g++ C98? C11
*-std=c++11 or -std=gnu++11*
** Qt                                                                   :qt:
*** assistant
使用源码安装qt时，assistant没有内容？
+ sudo apt-get install libqtassistantclient qt-assistant-compat qt5-doc qttools5-dev-tools
+ sudo apt-get install --no-install-recommands install

Qt assistant只是一个阅读帮助文档的工具，它可以添加qch格式的帮助文档，
并不是只能添加Qt的帮助文档。

所以如果你需要阅读文档的话就需要先将自己的文档添加到这个工具里面，帮助
文档应该是在Documentation目录下，也就是一些.qch文件，至于怎么添加方法
如下：

打开assistant，选择菜单Edit->preferences，这个时候弹出如下对话框

qt5源码中没有找到qt压缩帮助文档(*.qch)

audo apt-get install qt5-doc

*** QT环境变量设置
+ http://blog.sina.com.cn/s/blog_ad91f9bc01018as9.html

#+BEGIN_EXAMPLE
  #QT Settings
  export  QTDIR=QT安装目录
  export   PATH=$QTDIR/bin:$PATH
  export  LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH  # 这个待定
  export   MANPATH=$QTDIR/doc/man:$MANPATH
  #End QT Settings
#+END_EXAMPLE
*** Qt API
**** QWidget
1. const QPalette &	QWidget::palette() const
2. void	QWidget::setPalette(const QPalette &)
**** QTextEdit
**** QFontDialog
1. QFont QFontDialog::​getFont(bool * ok, const QFont & initial,
   QWidget * parent = 0, const QString & title = QString(),
   FontDialogOptions options = 0)

   Executes a modal font dialog and returns a font.

   If the user clicks OK, the selected font is returned. If the user
   clicks Cancel, the initial font is returned.

   The dialog is constructed with the given parent and the options
   specified in options. title is shown as the window title of the
   dialog and initial is the initially selected font. If the ok
   parameter is not-null, the value it refers to is set to true if the
   user clicks OK, and set to false if the user clicks Cancel.
**** QPalette
1. const QColor & QPalette::​color(ColorRole role) const

   Returns the color that has been set for the given color role in the
   current ColorGroup.

2. void QPalette::​setColor(ColorRole role, const QColor & color)

   This is an overloaded function.

   Sets the color used for the given color role, in all color groups,
   to the specified solid color.

**** QColorDialog
1. QColor QColorDialog::​getColor(const QColor & initial = Qt::white,
   QWidget * parent = 0, const QString & title = QString(),
   ColorDialogOptions options = 0)    [static]

   Pops up a modal color dialog with the given window title (or
   "Select Color" if none is specified), lets the user choose a color,
   and returns that color. The color is initially set to initial. The
   dialog is a child of parent. It returns an invalid (see
   QColor::isValid()) color if the user cancels the dialog.
**** QErrormessage
1. void QErrorMessage::​showMessage(const QString & message)
2.
**** QFontDialog
**** QFileDialog
1. QString QFileDialog::​getOpenFileName(QWidget * parent = 0, const
   QString & caption = QString(), const QString & dir = QString(),
   const QString & filter = QString(), QString * selectedFilter = 0,
   Options options = 0)

   This is a convenience static function that returns an existing file
   selected by the user. If the user presses Cancel, it returns a null
   string.
**** QInputDialog
1. QString QInputDialog::​getText(QWidget * parent, const QString &
   title, const QString & label, QLineEdit::EchoMode mode =
   QLineEdit::Normal, const QString & text = QString(), bool * ok = 0,
   Qt::WindowFlags flags = 0, Qt::InputMethodHints inputMethodHints =
   Qt::ImhNone)

   Static convenience function to get a string from the user.

   title is the text which is displayed in the title bar of the
   dialog. label is the text which is shown to the user (it should say
   what should be entered). text is the default text which is placed
   in the line edit. mode is the echo mode the line edit will
   use. inputMethodHints is the input method hints that will be used
   in the edit widget if an input method is active.

   If ok is nonnull *a ok will be set to true if the user pressed OK
   and to false if the user pressed Cancel. The dialog's parent is
   parent. The dialog will be modal and uses the specified widget
   flags.

   If the dialog is accepted, this function returns the text in the
   dialog's line edit. If the dialog is rejected, a null QString is
   returned.
**** QPrinter
+ Header:	#include <QPrinter>
+ qmake:	 QT += printsupport
+ Inherits:	QPagedPaintDevice.
**** QPrintDialog
+ Header:	#include <QPrintDialog>
+ qmake:	 QT += printsupport
+ Inherits:	QAbstractPrintDialog.
**** ToTar
1. T qobject_cast(QObject * object)

   Returns the given object cast to type T if the object is of type T
   (or of a subclass); otherwise returns 0. If object is 0 then it
   will also return 0.

   The class T must inherit (directly or indirectly) QObject and be
   declared with the Q_OBJECT macro.

2. QObject * SignalEvent::​sender() const

   Returns the object that emitted the signal.







5. 对话框
   + QColorDialog
   + QErrorMessage

*** ABORT [#C] QT qmake
DEADLINE: <2015-03-22 日>

- State "TODO"       from ""           [2015-03-04 三 14:31]
 Date:<2015-02-27 五>

 http://wenku.baidu.com/link?url=2wt6Gds-Rbr0FHV5SwwT5xlFOPbiXASxPAr_8wQbEF2js9VYO-KOJLHY_MawQBYvfJ3p3yQB-xm7moQzi0WAq7fjcwBBS6KBtbdsqxBMoja
*** DONE QT error: collect2: ld returned 1 exit status
- State "DONE"       from "TODO"       [2015-02-24 二 19:43]
- State "TODO"       from ""           [2015-02-24 二 19:40]

参考:http://blog.csdn.net/lincyang/article/details/5779464

Another reason might be that your source is incomplete and calls method
DECLARATIONS that get called but the method IMPLEMENTATIONS are
missing.

Declaration is the stuff that you usually put in a header file (method
signature without body)
Implementation is the signature with body.

简言之,头文件中的声明没有在源文件中实现.

*** DONE QT:tr
- State "DONE"       from "TODO"       [2015-02-24 二 19:39]
- State "TODO"       from ""           [2015-02-24 二 19:14]

参考: http://blog.csdn.net/mfc11/article/details/6591134

**** 问题与解决
在论坛中漂，经常遇到有人遇到tr相关的问题。用tr的有两类人：
  + (1)因为发现中文老出问题，然后搜索，发现很多人用tr，于是他也开始用tr
  + (2)另一类人，确实是出于国际化的需要，将需要在界面上显示的文件都用tr
    包起来，这有分两种：
    - (2a) 用tr包住英文(最最推荐的用法，源码英文，然后提供英文到其他
      语言的翻译包)
    - (2b) 用tr包住中文(源码用中文，然后提供中文到其他语言的翻译包)
      [[http://blog.csdn.net/dbzhang800/archive/2011/04/19/6334852.aspx][Qt国际化（源码含中文时）的点滴分析]]

注意哦，如果你正在用tr包裹中文字符，却不属于(2b)，那么，这是个信号：
  + 你在误用tr
  + 你需要的是QString，而不是tr
**** tr函数的作用
tr是用来实现国际化的.

tr是经过多级函数调用才实现翻译操作,因而是有代价的,没有必要的时候最好不
要使用.
**** QString的中文问题
***** 问题
+ QString 采用的unicode，在中文支持上不存在任何问题
+ "我是中文" 这是传统的 const char * 的窄字符串
+ 当将窄字符串赋值到QString时，我们需要告诉它我们的窄串采用的何种编码
  (gbk?、utf-8?)
+ 究竟何种编码主要取决于我们的源代码文件的编码(windows上一般是gbk，其
  他平台一般utf-8)

#+BEGIN_EXAMPLE
  QString s1 = "我是中文";
  QString s2("我是中文");
  QString s3;
  s3 = "我是中文"
#+END_EXAMPLE

+ s1、s2 用的是QString的构造函数QString ( const char * str )
+ s3 用的是QString的赋值操作符 QString & operator=( const char * str)

如果不指定编码，s1,s2,s3将全部都是(国内大多数人所称的)乱码。因为QString
将这些const char *按照latin1来解释的，而不是用户期待的gbk或utf8。

***** 解决
QTextCodec::setCodecForCStrings(QTextCodec::codecForName("GB2312"));
QTextCodec::setCodecForCStrings(QTextCodec::codecForName("UTF-8"))
这两条语句中的一条可以解决问题，至于如何选择，此处不再重复。

**** tr定义
参考文献中解释详实
*** DONE QT BEGIN_NAMESPACE
- State "DONE"       from "TODO"       [2015-02-24 二 19:13]
- State "TODO"       from ""           [2015-02-24 二 19:03]

参考:http://no001.blog.51cto.com/1142339/389798/
**** 使用
#+BEGIN_EXAMPLE
  #ifndef WINDOW_H
  #define WINDOW_H

  #include <QSystemTrayIcon>
  #include <QDialog>

  QT_BEGIN_NAMESPACE
  class QAction;
  class QCheckBox;
  class QComboBox;
  class QGroupBox;
  class QLabel;
  class QLineEdit;
  class QMenu;
  class QPushButton;
  class QSpinBox;
  class QTextEdit;
  QT_END_NAMESPACE

  //! [0]
  class Window : public qdialog
  {
  Q_OBJECT

  public:
  Window();
  ……

  ｝
#+END_EXAMPLE
**** 宏定义
#+BEGIN_EXAMPLE
  #define QT_BEGIN_NAMESPACE namespace QT_NAMESPACE{
  #define QT_END_NAMESPACE }
#+END_EXAMPLE

**** 作用
在头文件中尽量减少引用其它头文件,这样可加快编译速度.
**** 约束
在头文件中仅使用这些类的指针声明,而没有实例化.

*** Qt Assistant
http://qt-project.org/doc/qt-4.8-snapshot/assistant-manual.html
https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0CB4QFjAA&url=http%3A%2F%2Fblog.morpheuz.cc%2F01%2F07%2F2008%2Fqt-assistant-emacs%2F&ei=XKwLVb-hHpDtoASky4GQCQ&usg=AFQjCNEiIgBsGpZWAMByiSqhyJ_4HOu1fA&sig2=9BHnXLzV3e3dZt3tWiALng

*** Qt帮助系统
http://blog.csdn.net/sf2gis2/article/details/43988461
http://blog.csdn.net/sf2gis2/article/details/43988461

*** moc 元对象编译器
+ http://www.eefocus.com/book/09-04/714961276059621.html


moc工具可以看成是一个C++预处理程序，用来扩展C++的特性，比如Qt的信号和
槽的机制，它并不是标准C++的特性，但经过moc的预处理之后，所有信号和槽相
关的代码都被“翻译”成了标准的C++，从而能够被gcc等编译。

1. 在Makefile中使用moc

   我们通常使用Qt提供的qmake工具来自动生成Makefile，这样做的好处是不用
   自己手动去添加很多Qt需要的规则，比如调用moc工具等。

   如果在某些情况下需要手动编写Makefile时，我们可以用下面的规则来调用
   moc:
   #+BEGIN_EXAMPLE
   moc_%.cpp: %.h
   moc $< -o $@
   #+END_EXAMPLE

   根据Makefile的规则，这里的含义是对所有头文件*.h，利用moc进行处理并
   得到moc_*.cpp。生成moc_*.cpp之后不要忘记你还同样需要对它进行编译和
   链接，所以你需要将它加到SOURCES和OBJECTS（可能是其他类似含义的变量）
   中。

2. moc用法详解

   moc支持的如下所示的一些命令行选项：
   + -o file

     将输出写到参数file（不指定的话将写到标准输出）。

   + -f [<file>]

     强制在输出文件中生成#include声明。这个选项在你的头文件没有遵循标准命
     名法则的时候才有用——当头文件的扩展名以H或h开始时，#include声明会自动
     生成，不需要使用-f 选项。文件名<file>为可选项。

   + -i

     不在输出文件中生成#include声明，与-f正好相反。当一个C++文件包含一个
     或多个类声明的时候可能用到。

   + -nw

     不产生任何警告。不建议使用。

   + -p <path>

     在元对象编译器生成的#include声明的文件名称中添加路径<path>/。

   + -I <dir>

     在头文件的包含路径中添加<dir>目录。

   + -E

     不生成元对象相关代码（仅用于预编译）

   + -D<macro>[=<def>]

     定义宏<macro>，或者定义宏<macro>=<def>，后者为可选项

   + -U<macro>

     取消宏<macro>的定义

   + -h

     显示moc的用法和选项

   + -v

     显示moc的版本

3. 忽略代码段
   我们还可以使用”#ifndef Q_MOC_RUN”来告诉moc工具不要处理某些代码。
   比如：
   #+BEGIN_EXAMPLE
   #ifndef Q_MOC_RUN
   ...
   #endif
   #+END_EXAMPLE
   则moc会忽略定义在省略号部分的代码。

   This prevents a MOC error with versions of boost >= 1.48
*** Qt Creator Emacs Bindings
+ http://hahack.com/wiki/qt-skills.html
+ https://github.com/fberger/emacskeys/blob/master/README.markdown
*** QT assistant
使用源码安装qt时，assistant没有内容？
+ sudo apt-get install libqtassistantclient qt-assistant-compat qt5-doc qttools5-dev-tools
+ sudo apt-get install --no-install-recommands install

Qt assistant只是一个阅读帮助文档的工具，它可以添加qch格式的帮助文档，
并不是只能添加Qt的帮助文档。

所以如果你需要阅读文档的话就需要先将自己的文档添加到这个工具里面，帮助
文档应该是在Documentation目录下，也就是一些.qch文件，至于怎么添加方法
如下：

打开assistant，选择菜单Edit->preferences，这个时候弹出如下对话框

qt5源码中没有找到qt压缩帮助文档(*.qch)

audo apt-get install qt5-doc

** OpenGL                                                           :opengl:
*** opencv编译时链接错误                                              :ldd:
*问题在于ros的库，覆盖了opencv的库*

*source /opt/ros/indigo/setup.bash* 前
#+begin_example
pkg-config opencv --libs


~ $ cd wally/journal/project/ros/opencv/
/usr/lib/i386-linux-gnu/libopencv_calib3d.so
/usr/lib/i386-linux-gnu/libopencv_contrib.so
/usr/lib/i386-linux-gnu/libopencv_core.so
/usr/lib/i386-linux-gnu/libopencv_features2d.so
/usr/lib/i386-linux-gnu/libopencv_flann.so
/usr/lib/i386-linux-gnu/libopencv_gpu.so
/usr/lib/i386-linux-gnu/libopencv_highgui.so
/usr/lib/i386-linux-gnu/libopencv_imgproc.so
/usr/lib/i386-linux-gnu/libopencv_legacy.so
/usr/lib/i386-linux-gnu/libopencv_ml.so
/usr/lib/i386-linux-gnu/libopencv_objdetect.so
/usr/lib/i386-linux-gnu/libopencv_ocl.so
/usr/lib/i386-linux-gnu/libopencv_photo.so
/usr/lib/i386-linux-gnu/libopencv_stitching.so
/usr/lib/i386-linux-gnu/libopencv_superres.so
/usr/lib/i386-linux-gnu/libopencv_ts.so
/usr/lib/i386-linux-gnu/libopencv_video.so
/usr/lib/i386-linux-gnu/libopencv_videostab.so -lopencv_calib3d
-lopencv_contrib -lopencv_core -lopencv_features2d -lopencv_flann
-lopencv_gpu -lopencv_highgui -lopencv_imgproc -lopencv_legacy
-lopencv_ml -lopencv_objdetect -lopencv_ocl -lopencv_photo
-lopencv_stitching -lopencv_superres -lopencv_ts -lopencv_video
-lopencv_videostab
#+end_example

*source /opt/ros/indigo/setup.bash* 后
#+begin_example
/opt/ros/indigo/lib/libopencv_calib3d.so
/opt/ros/indigo/lib/libopencv_core.so
/opt/ros/indigo/lib/libopencv_features2d.so
/opt/ros/indigo/lib/libopencv_flann.so
/opt/ros/indigo/lib/libopencv_highgui.so
/opt/ros/indigo/lib/libopencv_imgcodecs.so
/opt/ros/indigo/lib/libopencv_imgproc.so
/opt/ros/indigo/lib/libopencv_ml.so
/opt/ros/indigo/lib/libopencv_objdetect.so
/opt/ros/indigo/lib/libopencv_photo.so
/opt/ros/indigo/lib/libopencv_shape.so
/opt/ros/indigo/lib/libopencv_stitching.so
/opt/ros/indigo/lib/libopencv_superres.so
/opt/ros/indigo/lib/libopencv_ts.a
/opt/ros/indigo/lib/libopencv_video.so
/opt/ros/indigo/lib/libopencv_videoio.so
/opt/ros/indigo/lib/libopencv_videostab.so
/opt/ros/indigo/lib/libopencv_viz.so
#+end_example

**** g++
g++编译：  *g++ main.cpp -lopencv_core -lopencv_highgui*
-llibs 一定要在源文件后


**** cmake

CMakeLists.txt
#+BEGIN_EXAMPLE
cmake_minimum_required(VERSION 2.8)
project( DisplayImage )
find_package( OpenCV REQUIRED )
include_directories (${OpenCV_INCLUDE_DIRS})  # 这句官网上没有
add_executable( DisplayImage hello_opencv.cpp )
target_link_libraries( DisplayImage ${OpenCV_LIBS} )
#+END_EXAMPLE


** C++拾遗
*** 几个C++线性函数开源库(Matrix)
+ boost/uBLAS
+ Eigen
+ Armadillo
+ blitz++
+ IT++
+ meschach
*** 函数return
1. 函数执行return语句后就会退出，可以利用这个特性在函数开始处进行异常
   处理。

2. 常见错误：遗漏返回值

   1) 函数的每个分支都应有一个返回值

   2) 如果函数包含if-else分支，要保证其中的每个分支都有返回值。

*** DONE atoll
- State "DONE"       from "TODO"       [2015-03-16 一 11:58]
- State "TODO"       from ""           [2015-03-16 一 11:27]
Reference:
+ http://www.cplusplus.com/reference/cstdlib/atoll/
+ http://blog.sina.com.cn/s/blog_674b5aae0100nqpt.html

**** atoll
long long int atoll ( const char * str );
Convert string to long long integer
Parses the C-string str interpreting its content as an integral number, which is returned as a value of type long long int.

This function operates like atol to interpret the string, but produces
numbers of type long long int (see atol for details on the
interpretation process).

**** Parameters
str: C-string containing the representation of an integral number.

**** Return Value
On success, the function returns the converted integral number as a
long long int value.

If no valid conversion could be performed, a zero value is returned.

If the converted value would be out of the range of representable
values by a long long int, it causes undefined behavior. See strtoll
for a more robust cross-platform alternative when this is a
possibility.
#+BEGIN_EXAMPLE
  /* atoll example */
  #include <stdio.h>      /* printf, fgets */
  #include <stdlib.h>     /* atoll */

  int main ()
  {
    long long int lli;
    char buffer[256];
    printf ("Enter a long number: ");
    fgets (buffer, 256, stdin);
    lli = atoll(buffer);
    printf ("The value entered is %lld. Its double is %lld.\n",lli,lli*2);
    return 0;
  }
#+END_EXAMPLE

Output:

#+BEGIN_EXAMPLE
  Enter a number: 9275806
  The value entered is 9275806. Its double is 18551612.
#+END_EXAMPLE

**** Data races
The array pointed by str is accessed.

**** Exceptions (C++)
No-throw guarantee: this function never throws exceptions.

If str does not point to a valid C-string, or if the converted value
would be out of the range of values representable by a long long int,
it causes undefined behavior.

**** See also
+ *atoi* Convert string to integer (function )
+ *atol* Convert string to long integer (function )
+ *strtoll* Convert string to long long integer (function )

**** 注:
atoll是c99标准加入的函数，在编译的时候可能要打开C99标准的编译选项 -std=c99。

另外，必须包含 *stdlib.h(C)* / *stdlib(C++)* 头文件，否则会出错。

*** rhs lhs                                                           :rhs:
lhs指的是==运算符左边的操作数 left hand side
rhs指的是==运算符右边的操作数 right hand side
运算符重载时常用

*** C++ 匿名函数                                                   :lambda:
http://blog.csdn.net/augusdi/article/details/11773943

c++11提供了对匿名函数的支持,称为lambda函数(也叫lambda表达式). lambda表
达式具体形式如下:
*[capture](parameters)->return-type{body}*

如果没有参数,空的圆括号()可以省略.返回值也可以省略,如果函数体只由一条
return语句组成或返回类型为void的话.形如:
*[capture](parameters){body}*

*** C++ 函数声明前的宏                                              :macro:

+ Windows api 经常这么干。。。

+ 对函数修饰。

+ *为了不同平台的可移植性，比如WINDOWS 的DLL*

+ Windows中dll导出的函数貌似需要特别说明，大概是为此准备的

**** Reference

+ [[http://bbs.chinaunix.net/thread-3578773-1-1.html]]

** C++Project                                                      :project:
* Python                                                             :python:
** Fundamental
*** python install                                                :install:

- https://www.python.org/downloads/

version 3.5


READEM

#+BEGIN_EXAMPLE
  On Unix, Linux, BSD, OSX, and Cygwin:

      ./configure
      make
      make test
      sudo make install
#+END_EXAMPLE

**** 修改软链

#+BEGIN_EXAMPLE
  wally@ Python-3.5.1 $ python  --version
  Python 2.7.9
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/py
  pydoc3             python3            python3.5-config   python3.5m-config  pyvenv
  pydoc3.5           python3.5          python3.5m         python3-config     pyvenv-3.5
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/py
  pydoc3             python3            python3.5-config   python3.5m-config  pyvenv
  pydoc3.5           python3.5          python3.5m         python3-config     pyvenv-3.5
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/python /usr/bin/python
  [sudo] password for wally:
  ln: 无法创建符号链接"/usr/bin/python": 文件已存在
  wally@ Python-3.5.1 $ ls -l /usr/bin/python
  lrwxrwxrwx 1 root root 9  1月  9 16:07 /usr/bin/python -> python2.7
  wally@ Python-3.5.1 $ sudo rm /usr/bin/python
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/python3 /usr/bin/python
  wally@ Python-3.5.1 $ python --version
  Python 3.5.1
#+END_EXAMPLE

*** 模块安装                                               :module:package:
+ http://www.douban.com/group/topic/40892505/


**** sys.append
自己写的模块，可以直接添加到路径下。这样就可以直接调用。
#+BEGIN_EXAMPLE
import sys
sys.path.append("/home/username/")
#+END_EXAMPLE

**** 单文件模块
直接把文件拷贝到$python_dir/lib

**** 网上下载的第三方库

一般解压后，找setup.py文件，运行python setup.py install。
#+BEGIN_EXAMPLE
     $ tar xfz MySQL-python-1.2.1.tar.gz
     $ cd MySQL-python-1.2.1
     $ # edit site.cfg if necessary
     $ python setup.py build
     $ sudo python setup.py install # or su first
#+END_EXAMPLE

**** egg文件                                                         :egg:
1) 下载ez_setup.py,运行python ez_setup
2) easy_install *.egg

**** pip                                                     :pip:
https://pypi.python.org/pypi/pip

Pip 是安装python包的工具，提供了安装包，列出已经安装的包，升级包以及卸
载包的功能。

Pip 是对easy_install的取代，提供了和easy_install相同的查找包的功能，因
此可以使用easy_install安装的包也同样可以使用pip进行安装。


***** 安装Pip

Pip的安装可以通过源代码包，easy_install或者脚本。

源代码方式：
#+BEGIN_EXAMPLE
  $ wget https://pypi.python.org/packages/source/p/pip/pip-1.2.1.tar.gz （替换为最新的包）
  $ tar xzf pip-1.2.1.tar.gz
  $ cd pip-1.2.1.tar.gz
  $ python setup.py install
#+END_EXAMPLE

easy_install:
#+BEGIN_EXAMPLE
  $ easy_install pip
#+END_EXAMPLE

get_pip.py 脚本：
#+BEGIN_EXAMPLE
  $ curl -0 https://raw.github.com/pypa/pip/master/contrib/get-pip.py
  $ sudo python get-pip.py
#+END_EXAMPLE

***** Pip的使用

1. 安装package
   #+BEGIN_EXAMPLE
     $ pip install Markdown
   #+END_EXAMPLE

2. 列出安装的packages
   #+BEGIN_EXAMPLE
     $ pip freeze
   #+END_EXAMPLE

3. 安装特定版本的package: 通过使用==, >=, <=, >, <来指定一个版本
   号。
   #+BEGIN_EXAMPLE
     $ pip install 'Markdown<2.0'
     $ pip install 'Markdown>2.0,<2.0.3'
   #+END_EXAMPLE

4. 升级包: 升级包到当前最新的版本，可以使用-U 或者 --upgrade
   #+BEGIN_EXAMPLE
     $ pip install -U Markdown
   #+END_EXAMPLE

5. 卸载包
   #+BEGIN_EXAMPLE
     $ pip uninstall Markdown
   #+END_EXAMPLE

6. 查询包
   #+BEGIN_EXAMPLE
     pip search "Markdown"
   #+END_EXAMPLE

7. *安装位置：~/.local/bin*
**** windows平台下，可以找对应python版本的exe安装包。            :windows:

比如，python2.7.3下 MySQL-python-1.2.3.win32-py2.7.exe，或
MySQL-python-1.2.3.win-amd64-py2.7.exe

*** 如何查看当前Python安装的所有包                                   :module:
**** pip list                                                        :pip:
pip list

#+BEGIN_SRC sh :results output :export both
pip --help
#+END_SRC

#+RESULTS:
#+begin_example

Usage:
  pip <command> [options]

Commands:
  install                     Install packages. with -U,  update
  uninstall                   Uninstall packages.
  freeze                      Output installed packages in requirements format.
  list                        List installed packages.
  show                        Show information about installed packages.
  search                      Search PyPI for packages.
  wheel                       Build wheels from your requirements.
  zip                         DEPRECATED. Zip individual packages.
  unzip                       DEPRECATED. Unzip individual packages.
  help                        Show help for commands.
#+end_example


#+BEGIN_SRC sh :results output :export both
pip list
#+END_SRC

#+RESULTS:
#+begin_example
adium-theme-ubuntu (0.3.4)
apsw (3.8.2.post1)
apt-xapian-index (0.45)
arandr (0.1.7.1)
archmage (0.2.4)
astroid (1.3.6)
BeautifulSoup (3.2.1)
bzr (2.7.0.dev1)
catkin-pkg (0.2.8)
chardet (2.0.1)
CherryPy (3.2.2)
chm2pdf (0.9)
colorama (0.2.5)
command-not-found (0.3)
configobj (4.7.2)
cssselect (0.9.1)
cssutils (0.9.10)
cwiid (0.6.0)
debtagshw (0.1)
defer (1.0.6)
dirspec (13.10)
distribute (0.6.28)
dnspython (1.11.1)
docutils (0.11)
duplicity (0.6.23)
email (4.0.2)
empy (3.1)
enum (0.4.6)
feedparser (5.1.3)
flake8 (2.4.1)
html5lib (0.999)
httplib2 (0.8)
importmagic (0.1.3)
keyring (3.5)
launchpadlib (1.10.2)
lazr.restfulclient (0.13.3)
lazr.uri (1.0.3)
lockfile (0.8)
logilab-common (0.63.2)
lxml (3.3.3)
Mako (0.9.1)
Markdown (2.4)
MarkupSafe (0.18)
matplotlib (1.3.1)
mccabe (0.3)
mechanize (0.2.5)
mercurial (2.8.2)
MySQL-python (1.2.4b4)
netifaces (0.8)
nose (1.3.1)
numpy (1.8.2)
oauth (1.0.1)
oauthlib (0.6.1)
oneconf (0.3.7)
PAM (0.4.2)
paramiko (1.10.1)
pep8 (1.5.7)
pexpect (3.1)
Pillow (2.3.0)
pip (6.1.1)
piston-mini-client (0.7.5)
psutil (1.2.1)
PyAssimp (3.0.1264)
PyBluez (0.18)
pychm (0.8.4)
pycrypto (2.6.1)
pycups (1.9.66)
pycurl (7.19.3)
pydot (1.0.28)
pyflakes (0.8.1)
Pygments (1.6)
pygobject (3.12.0)
pygpgme (0.3)
pylint (1.4.3)
Pymacs (0.25)
pymongo (2.6.3)
PyOpenGL (3.0.2)
pyOpenSSL (0.13)
pyparsing (2.0.1)
pyserial (2.6)
pysmbc (1.0.14.1)
python-apt (0.9.3.5ubuntu1)
python-dateutil (1.5)
python-debian (0.1.21-nmu2ubuntu2)
pytz (2012rc0)
pyxdg (0.25)
PyYAML (3.10)
reportlab (3.0)
repoze.lru (0.6)
requests (2.2.1)
roman (2.0.0)
rope (0.10.2)
rosdep (0.11.2)
rosdistro (0.4.2)
rosinstall (0.7.5)
rospkg (1.0.35)
Routes (2.0)
SecretStorage (2.0.0)
sessioninstaller (0.0.0)
setuptools (3.3)
shadowsocks (2.8.2)
simplejson (3.3.1)
six (1.5.2)
software-center-aptd-plugins (0.0.0)
ssh-import-id (3.21)
system-service (0.1.6)
Twisted-Core (13.2.0)
Twisted-Web (13.2.0)
urllib3 (1.7.1)
uTidylib (0.2)
vboxapi (1.0)
vcstools (0.1.36)
VTK (5.8.0)
wadllib (1.3.2)
WebOb (1.3.1)
wstool (0.1.6)
wxPython (2.8.12.1)
wxPython-common (2.8.12.1)
xdiagnose (3.6.3build2)
zope.interface (4.0.5)
#+end_example

**** help('module')

#+BEGIN_SRC python :results output :export both
help('modules')
#+END_SRC

#+RESULTS:
#+begin_example

Please wait a moment while I gather a list of all available modules...

DEBUG:oneconf.distributor:get_distro: 'Ubuntu'
ANSI                archmod             heapq               resource
BaseHTTPServer      argparse            hgext               rexec
Bastion             array               hmac                rfc822
BeautifulSoup       ast                 hotshot             rlcompleter
BeautifulSoupTests  astroid             hpmudext            robotparser
CDROM               asynchat            html5lib            roman
CGIHTTPServer       asyncore            htmlentitydefs      rope
Canvas              atexit              htmllib             rosdep2
CommandNotFound     atk                 httplib             rosdistro
ConfigParser        audiodev            httplib2            rosinstall
Cookie              audioop             ibus                rospkg
Crypto              axi                 ihooks              routes
DLFCN               base64              imageop             runpy
Dialog              bdb                 imaplib             samba
DocXMLRPCServer     binascii            imghdr              scanext
FSM                 binhex              imp                 sched
FileDialog          bisect              importlib           screen
FixTk               bluetooth           importmagic         screenlayout
HTMLParser          bonobo              imputil             secretstorage
IN                  boost               indicator_keyboard  select
Image               bsddb               inspect             serial
ImageChops          bson                io                  sessioninstaller
ImageColor          bz2                 itertools           sets
ImageCrackCode      bzrlib              json                setuptools
ImageDraw           cPickle             keybinder           sgmllib
ImageEnhance        cProfile            keyring             sha
ImageFile           cStringIO           keyword             shadowsocks
ImageFileIO         cairo               launchpadlib        shelve
ImageFilter         calendar            lazr                shlex
ImageFont           catkin_pkg          ldb                 shutil
ImageGL             cgi                 lib2to3             signal
ImageGrab           cgitb               libxml2             simplejson
ImageMath           chardet             libxml2mod          sip
ImageOps            cherrypy            linecache           sipconfig
ImagePalette        chm                 linuxaudiodev       sipconfig_nd
ImagePath           chunk               locale              sipdistutils
ImageQt             cmath               lockfile            site
ImageSequence       cmd                 logging             sitecustomize
ImageStat           code                logilab             six
ImageTk             codecs              lsb_release         smbc
ImageWin            codeop              lxml                smtpd
MimeWriter          collections         macpath             smtplib
MySQLdb             colorama            macurl2path         sndhdr
ORBit               colorsys            mailbox             socket
OpenGL              commands            mailcap             softwarecenter_aptd_plugins
OpenSSL             compileall          mako                softwareproperties
PAM                 compiler            markdown            spwd
PIL                 configobj           markupbase          sqlite3
PSDraw              contextlib          markupsafe          sre
PngImagePlugin      cookielib           marshal             sre_compile
PyKate4             copy                math                sre_constants
PyQt4               copy_reg            matplotlib          sre_parse
PySide              crypt               mccabe              ssl
Queue               cssselect           md5                 stat
ScrolledText        cssutils            mechanize           statvfs
SimpleDialog        csv                 mercurial           string
SimpleHTTPServer    ctypes              mhlib               stringold
SimpleXMLRPCServer  cups                mimetools           stringprep
SocketServer        cupsext             mimetypes           strop
StringIO            cupshelpers         mimify              struct
TYPES               curl                mmap                subprocess
Tix                 curses              modulefinder        sunau
Tkconstants         cv                  mpl_toolkits        sunaudio
Tkdnd               cv2                 multifile           symbol
Tkinter             cwiid               multiprocessing     symtable
UbuntuSystemService datetime            mutex               sys
UserDict            dateutil            netifaces           sysconfig
UserList            dbhash              netrc               syslog
UserString          dbm                 new                 tabnanny
_LWPCookieJar       dbus                nis                 talloc
_MozillaCookieJar   deb822              nntplib             tarfile
__builtin__         debconf             nose                tdb
__future__          debian              ntdb                telnetlib
_abcoll             debian_bundle       ntpath              tempfile
_ast                debtagshw           nturl2path          termios
_bisect             decimal             numbers             test
_bsddb              defer               numpy               textwrap
_codecs             difflib             oauth               this
_codecs_cn          dircache            oauthlib            thread
_codecs_hk          dirspec             oneconf             threading
_codecs_iso2022     dis                 opcode              tidy
_codecs_jp          distlib             operator            time
_codecs_kr          distutils           optparse            timeit
_codecs_tw          dl                  os                  tkColorChooser
_collections        dns                 os2emxpath          tkCommonDialog
_csv                doctest             ossaudiodev         tkFileDialog
_ctypes             docutils            pango               tkFont
_ctypes_test        dot_parser          pangocairo          tkMessageBox
_curses             drv_libxml2         paramiko            tkSimpleDialog
_curses_panel       dsextras            parser              toaiff
_dbus_bindings      dumbdbm             pcardext            token
_dbus_glib_bindings dummy_thread        pdb                 tokenize
_elementtree        dummy_threading     pep8                trace
_functools          duplicity           pexpect             traceback
_hashlib            easy_install        pickle              ttk
_heapq              em                  pickletools         tty
_hotshot            email               pip                 turtle
_io                 encodings           pipes               twisted
_json               encutils            piston_mini_client  types
_locale             enum                pkg_resources       ubuntu_sso
_lsprof             errno               pkgutil             unicodedata
_markerlib          exceptions          platform            unittest
_md5                fcntl               plistlib            urllib
_multibytecodec     fdpexpect           popen2              urllib2
_multiprocessing    feedparser          poplib              urllib3
_mysql              filecmp             posix               urlparse
_mysql_exceptions   fileinput           posixfile           user
_osx_support        flake8              posixpath           uu
_psutil_linux       fnmatch             pprint              uuid
_psutil_posix       formatter           profile             validate
_pyio               fpectl              pstats              vboxapi
_random             fpformat            psutil              vcstools
_sha                fractions           pty                 vte
_sha256             ftplib              pwd                 vtk
_sha512             functools           pxssh               wadllib
_smbc               future_builtins     py_compile          warnings
_socket             gc                  pyassimp            wave
_sqlite3            gconf               pyclbr              weakref
_sre                gdbm                pycurl              webbrowser
_ssl                genericpath         pydoc               webob
_strptime           getopt              pydoc_data          whichdb
_struct             getpass             pydot               wsgiref
_symtable           gettext             pyexpat             wstool
_sysconfigdata      gi                  pyflakes            wx
_sysconfigdata_nd   gio                 pygments            wxPython
_testcapi           glib                pygst               wxversion
_threading_local    glob                pygtk               xapian
_tkinter            gnome               pygtkcompat         xdg
_warnings           gnomecanvas         pylab               xdiagnose
_weakref            gnomekeyring        pylint              xdrlib
_weakrefset         gnomevfs            pymongo             xml
_yaml               gobject             pynotify            xmllib
abc                 gpgme               pyparsing           xmlrpclib
aifc                gridfs              pytz                xxsubtype
antigravity         grp                 quopri              yaml
anydbm              gst                 random              zeitgeist
apsw                gstoption           re                  zipfile
apt                 gtk                 readline            zipimport
apt_inst            gtkunixprint        reportlab           zlib
apt_pkg             gtweak              repoze              zope
aptdaemon           gzip                repr
aptsources          hashlib             requests

Enter any module name to get more help.  Or, type "modules spam" to search
for modules whose descriptions contain the word "spam".

#+end_example

*** 下划线                                                       :underscore:

**** reference

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/60eda8d9-fbf4-4999-bc36-c6abc7df198d?title=%E8%AF%A6%E8%A7%A3Python%E4%B8%AD%E7%9A%84%E4%B8%8B%E5%88%92%E7%BA%BF%20-%20Python%20-%20%E4%BC%AF%E4%B9%90%E5%9C%A8%E7%BA%BF][Python中的下划线]]
+ [[http://shahriar.svbtle.com/underscores-in-python][underscores in python]]

**** 在解释器中，表示上一条执行的语句的结果

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{text}
  >>> _
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  NameError: name '_' is not defined
  >>> 42
  42
  >>> _
  42
  >>> 'alright' if _ else ':('
  'alright'
  >>> _
  'alright'

  \end{minted}
#+end_latex

**** 作为一个临时变量, 不感兴趣，仅用来占位，以后也不会用到

#+begin_latex
\begin{minted}[frame=leftline, mathescape]{py}
rlist, _, _ = select.select([sys.stdin], [], [], 0.1)
\end{minted}
#+end_latex

**** 名称中的下划线

1. 名称前的单下划线： 表示“私有”属性

2. 名称前的双下划线： 对解释器有特殊意义，为了避免与子类定义的名称冲突
   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{text}
     >>> class A(object):
     ... def _internal_use(self):
       File "<stdin>", line 2
         def _internal_use(self):
           ^
     IndentationError: expected an indented block
     >>> class A(object):
     ...     def _internal_use(self):
     ...             pass
     ...     def __method_name(self):
     ...             pass
     ...
     >>> dir(A)
     ['_A__method_name', ... '_internal_use']

     \end{minted}
   #+end_latex

3. 名称前后的双下划线： Python中的特殊名称，惯例。

*** IPython Introduction                                    :ipython:intro:
IPython 1.2.1 -- An enhanced Interactive Python.

ipython 是一个 python 的交互式 shell，比默认的python shell 好用得多，支
持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能
和函数。在ubuntu 下只要 sudo apt-get install ipython 就装好了，通过
ipython 启动。

1. %打头的Magic函数
2. !打头的shell命令
3. ipython notebook


Ubuntu下安装： sudo apt-get ipython
开源(BSD): 当然也可以源码安装，但是何必。
**** 参考
+ [[http://ipython.org/][ipython homepage]]
+ [[http://baike.baidu.com/link?url=7-XcxpZSu0jq6nvaEnMk4JFIV-5_SjX7WRN5a5zyxyyv1HiUBpiS2HsTndW9SZYUh2apmjYWWatpJZHEigLidK][百度百科]]
+
  [[http://baike.baidu.com/link?url=7-XcxpZSu0jq6nvaEnMk4JFIV-5_SjX7WRN5a5zyxyyv1HiUBpiS2HsTndW9SZYUh2apmjYWWatpJZHEigLidK][ipython简介]]
*** 在函数中导入模块 有什么好处
- State "DONE"       from "TODO"       [2015-12-04 五 09:53]
CLOCK: [2015-12-04 五 09:48]--[2015-12-04 五 09:53] =>  0:05
 <2015-12-03 四>
 [[file:~/Wally/Journal/Project/Python/termios/test.py::import%20termios,%20sys%20#%20%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97][file:~/Wally/Journal/Project/Python/termios/test.py::import termios,
 sys # 在函数中导入模块]]

**** Q & A
PEP 08 states:

*Imports are always put at the top of the file* , just after any
module comments and docstrings, and before module globals and
constants.

However if the class/method/function that I am importing is only used
in rare cases, surely it is more efficient to do the import when it is
needed?

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{py}
  class SomeClass(object):

      def not_often_called(self)
          from datetime import datetime
          self.datetime = datetime.now()
  more efficient than this?

  from datetime import datetime

  class SomeClass(object):

      def not_often_called(self)
          self.datetime = datetime.now()
  \end{minted}
#+end_latex


Anwser:


Module importing is quite fast, but not instant. This means that:

1. Putting the imports at the top of the module is fine, because it's
   a trivial cost that's only paid once.

2. Putting the imports within a function will cause calls to that
   function to take longer.

*So if you care about efficiency, put the imports at the top.* Only move
them into a function if your profiling shows that would help (you did
profile to see where best to improve performance, right??)

**** 小结

在文件开头处导入模块只会导入一次，而在函数中导入模块，每次调用函数时都
会导入一次（而且并不需要），所以关乎效率。

**** Reference

+ [[http://stackoverflow.com/questions/128478/should-python-import-statements-always-be-at-the-top-of-a-module][Stackoverflow: Should Python import statements always be at the top
  of a module]]

** syntax
*** with as                                                          :withas:

1. 用来代替传统的 try...finally语句

2. 更加优雅

3. 常用于文件处理句柄

   #+BEGIN_SRC python
      # file handler
     file = open('/tmp/foo.txt')
     data = file.read()
     file.close()
     # IOError: [Errno 13] Permission denied: '/tmp/foo.txt'

     # try
     file = open('/tmp/foo.txt')     #
     try:
         data = file.read()
     finally:
         file.close()

     # with...as
     with open('/tmp/foo.txt') as file:
         data = file.read()
   #+END_SRC

   Note: 处理的是 read 方法的异常，而不是 open 方法的异常

4. 要求对象有 =__enter__()= 和 =__exit__()= 两个方法

5. 运行流程
   1) =__enter__()=方法被执行
   2) 返回值被赋值给变量
   3) 执行代码块
   4) =__exit()__=方法被调用
   #+begin_latex
   \begin{listing}
     \begin{minted}[frame=single, mathescape]{py}
     # with...as
     with open('/tmp/foo.txt') as file:
         data = file.read()


     class Sample:
         def __enter__(self):
             print " In __enter__()"
             return "Foo"

         def __exit__(self, type, value, trace):
             print "In __exit__()"


     def get_sample():
         return Sample()


     with get_sample() as sample:
         print "sample:", sample

     # 运行结果
     # In __enter__()
     # sample: Foo
     # In __exit__()
     \end{minted}
   \end{listing}
   #+end_latex

6. 优点
   with真正强大之处在于它可以异常处理， =__exit()__= 方法有三个参数，
   *val, type, trace*, 异常处理中相当有用。
   #+begin_latex
\begin{listing}
     \begin{minted}[frame=single, mathescape]{py}
     class Sample:
         def __enter__(self):
             return self

         def __exit__(self, type, value, trace):
             print "type: ", type
             print "value: ", value
             print "trace: ", trace

         def do_something(self):
             bar = 1/0
             return bar + 10

     with Sample() as sample:
         sample.do_something()

     # type:  <type 'exceptions.ZeroDivisionError'>
     # value:  integer division or modulo by zero
     # trace:  <traceback object at 0xb7059cac>
     # Traceback (most recent call last):
     #   File "<stdin>", line 1, in <module>
     #   File "/home/ben/Wally/Journal/Project/Python/Tutorials/withas/withas.py", line 59, in <module>
     #     sample.do_something()
     #   File "/home/ben/Wally/Journal/Project/Python/Tutorials/withas/withas.py", line 55, in do_something
     #     bar = 1/0
     # ZeroDivisionError: integer division or modulo by zero
     \end{minted}
\end{listing}
   #+end_latex

7. 小结
   *Python的with语句是提供一个有效的机制，让代码更简练，同时在异常产生
   时，清理工作更简单*


8. 参考文献
   + [[https://app.yinxiang.com/shard/s52/nl/11551545/e0245473-6a55-4bd0-9b11-28ee558c06fc?title=%E7%90%86%E8%A7%A3Python%E7%9A%84With%E8%AF%AD%E5%8F%A5%20-%20train%E7%9A%84%E4%B8%93%E6%A0%8F%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET][Understanding Python's 'with' Statement]]

** Tutorials                                                       :tutorial:
*** Python网络教程
**** python简介
***** What's Python?
python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣
诞节而编写的一门变成语言。

python提供了丰富完善的基础代码哭，覆盖了网络、文件、GUI、数据库、文本等大量
内容，被形象地称作“内置电池”（batteries included）。

除了内置的库外，Python还有大量的第三方库。

许多大型网站是用Python开发的，例如YouTube,Instgram,豆瓣等。很多大公司，包括
Google、Yahoo、NASA（美国航空航天局）都大量使用Python。

***** Python应用：
+ 网络应用，包括网络、后台服务等等
+ 日常需用的小工具，如脚本任务等
+ 把其它语言的程序再包装起来，方便使用
***** Python缺点
+ 速度慢
+ 代码不能加密

***** 第一个Python程序

在交互式环境下，Python类似Matlab.
$ print 'hello, world.‘      # print函数打印字符串
$ RET                        # 回车执行代码
Python使用但引号或双引号将字符串括起，但不能浑用。

$ exit()    # 退出Python交互式环境

***** 使用文本编辑器
window下推荐Sublime Text, UtralEdit 和Notepad++.哪个都好，但是绝对不能使用
word和windows自带的记事本，记事本会自作聪明地在文件开始的地方加上几个特殊字
符(UTF-8 BOM)，结果会导致程序出现莫名其妙的错误。

Python程序的后缀名为.py。

Linux下在.py文件首行加上
#!/usr/bin/env python
选择运行程序的解释器，可以直接运行Python程序。
$ chmod a+x hello.py        # 修改权限

***** 输入输出                                                       :io:
print()        # 输出函数
raw_input()    # 输入函数

**** python语法基础
***** 句法
Python采用缩进方式
Python使用#注释
当语句以冒号结束时，缩进语句视为代码块E
Python程序是大小写敏感的

关于缩进：
+ 好处是强迫你格式化代码，约定俗称的是，应该使用四个空格缩进
+ 另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若
  干函数，从而得到缩进较少的代码
+ 复制-粘贴失效，粘贴的代码必须检查缩进是否正确

***** Python数据类型

Python内置支持的数据类型包括整型、浮点型、字符串、布尔值、空值、变量、常量
等。

字符串是使用\进行转义。
r''表示内部字符默认不转义。
'''..'''可格式化多行字符串

布尔型只有两个值：True和False。支持的运算包括and、or和not运算。

空值是Python里的一个特殊的是，用None表示。

Python语言中变量本身类型不固定，为动态语言，非墙类型语言，与Matlab类似。

常量名通常全部大写。

***** 字符串和编码                                      :string:encoding:
ASCII码是最早的编码表，涵盖127个字符，包括大小写英文字母，数字和一些符号。
中国汉字的编码为GB2312。
Unicode编码是为了解决这种编码方式不一导致多语言混合文本中显示乱码的问题。
Unicode将所有的语言都统一放在同一套编码中，其标准在不断发展，最常用的是两个
字节表示一个字符。现在大多数操作系统和编程语言都支持Unicode。

新的问题：对于全部是英文的文本，Unicode编码比ASCII编码需要多一倍的存储空间，
在存储和传输上不划算。
UTF-8编码为可变长编码，根据字符不同将其编码成1-6个字节。常用的英文被编码成
一个字节，汉字被编码成三个自己，只有很生僻的字符才会被编码为4-6个字节。

现代计算机系统通用的字符编码工作方式：在计算机内存中，统一使用unicode编码，
当需要保存到硬盘或者需要传输时，就转换为UTF-8。
用记事本编辑时，从文件中读取UTF-8字符并转换为Unicode字符存储在内存中，编辑
完成后保存时再转换为UTF-8把保存到文件。

Python的诞生早于Unicode标准。因此早期的Python只支持ASCII。
Python对Unicode的支持，以Unicode表示的字符串用u''表示。
字符串的encode(''utf-8)方法将编码转换为UTF-8编码。
len()函数返回字符串长度。
字符串的decode('utf-8')方法将UTF-8编码转换为Unicode编码。

由于Python源代码也是一个文本文件，所以当其中包含中文是，在保存源代码是就需
要务必制定保存为UTF-8编码。当Python解释起读取源代码是，为了让他按UTF-8编码
读取，通常需要在文件开头加上这两行。
#!/usr/bin/env python
# -*- coding: uft-8 -*-
第一行是为了告诉Linux/OS X系统，这是一个Python可执行程序，windows系统会忽略
这个注释；
第二行注释是为了告诉Python解释起，按照UTF-8编码读取代码
***** 格式化字符串                                               :string:
在Python中，格式化字符床的方式与C是一致的，用%实现。
常见的占位符有：
|----+--------------|
| %d | 整数         |
| %f | 浮点数       |
| %s | 字符串       |
| %x | 十六进制整数 |
|----+--------------|
当不确定使用什么占位符是， %s用呀u年起作用，它会把任何数据类型转换为字符串。

***** list                                                     :listings:
list是Python内置的一种数据类型，即线性列表。list是一种有序的集合，可以随时
添加或删除元素。
list类似Matlab中的数组，使用中括号初始化。
len()函数返回list的长度，即元素个数。
可以使用下标索引list的元素，索引从0开始。
当索引超出范围是，Python会报IndexError错误。
除了下标位置索引外，list还支持倒序索引，最后一个元素索引值-1,倒数第二个元素
所以-2,以此类推。
append(e)方法可以往list中追加元素e到末尾。
append(i,e)方法在指定位置追加元素e。
pop()方法删除list末尾元素。
pop(i)方法删除指定位置的元素。
使用直接赋值的方法，可以毛某个元素替换为其他值。
list里面的元素类型可以不同。
list的元素也可以是另外一个list。
[]是空list，不包含任何元素，长度为0。

与Matlab内置数组的对比：
  + matlab内置数组可以是多维，list只有一维；
  + 都支持动态扩展，但list需要使用特定方法，而matlab内置数组可以直接用下标进
    行扩展
  + matlab内置数组是数组，而list是链表（支持在特定位置插入）

***** tuple                                                       :tuple:
tuple也是Python内置的一种有序链表，使用小括号进行初始化，一旦初始化后，
tuple就不能修改。
因此，tuple没有append，insert等方法，可以通过下标索引，但不能赋值城另外元素。
这样做是为了使代码更加安全。
tuple在声明时必须初始化。
可以使用t=()定义空的tuple。
定义只有一个元素的tuple时需要一定技巧：
t = (1)    # 定义的不是tuple，而是1这个数。
t = (1,)   # Python在定义只有一个元素的tuple时必须加一个逗号，以消除歧义
# Python在显示时也会加一个逗号
当tuple中包含list元素时，该tuple即为可变的，可以使用list方法对list本身进行
修改。可以看出，所谓tuple的不变性，指的是其指向（指针）的不变性，而非绝对不
变。

***** 条件判断                                                       :if:
Python支持if/if...else.../if...elseif...else...等形式的条件判断。
注：python语句尾不需用使用分号表示结束，回车本身即表示结束，记住python是按
缩进进行语法编排。

***** 循环                                                          :for:
Python支持的循环有两种。
一种是for...in循环,依次把list或tuple中的每个元素迭代出来。
range(n)函数可以生成0-(n-1）的list。
第二种循环是while循环。
注：raw_input()函数返回的永远是字符串，在使用前需要按需进行类型转换。

***** dict                                                         :dict:
Python内置了字典，即对dict的支持，dict全程Dictionary,在其它语言中也称为map，
使用键-值（key-value）存储，具有极快的查找速度。
eg. d = {'Michael':95, 'Bob':75}
dict按照字典的方式进行查找，list按照线性方式进行查找，因此dict的查找效率要
远高于list，尤其是数据量大的时候。
dict按键值key索引，中括号括起。当索引键值不存在时，中断KeyError.
要避免KeyError,可以使用两种办法：
 + 通过in判断key是否存在， eg. 'Tom' in d  # 返回False
 + 使用dict的方法get(key),不存在时返回None，或get(key, Val)方法，不存在时返
   回Val

注：返回None时Python交互式命令行不现实结果。
pop(key)方法从dict中删除对应键值的元素。
dict内部存放的顺序与key放入的顺序没有关系。

dict和list的比较：
  + 查找和插入的速度极快，不会随着key增加而增加
  + 需要占用的内存多
即，dict是用空间换取时间的一种办法。

dict可以用在需要告诉查找的很多地方，在Python中几乎无处不在，正确使用dict十分
重要。需要牢记的第一条就是dict的key必须是*不可变对象*。因为dict使用哈希算法
（Hash）通过key计算位置。
在Python中，字符串、整数都是不可变对象，可以用作key，list是可变的，因而不能
用作key。

***** set                                                           :set:
set是一组key的集合，可以看成数学意义上的无序无重复的元素的集合。
set创建时使用list进行初始化，eg. s=set([1,2,3])
重复元素在set中会自动被过滤。
add(key)方法向set中添加元素。
remove(key)方法可以删除元素。
set可以做数学意义上的交集和并集，即 & 运算和 | 运算。
set和dict的唯一区别仅在于没有存储对应的value，set同样以不可变对象作为键。

***** 不可变对象
对于可变对象，如list，其操作会改变list内部的内容。
而对不可变对象，如str，其操作不会改变其内容。
eg. a = 'abc'
a.replace('a', 'A')  # 返回另外一个str对象，而不是改变a本身
即，对于不可变对象，调用对象自身方法，不会改变对象自身的内容，而是这些方法
创建新的对象并返回。

***** 函数                                                     :function:
数据类型转换的函数有int(), str(), unicode(),bool()等。
函数名其实就是一个函数对象的应用，完全可以把函数名赋给一个变量，相当于给这
个函数起了一个别名。  这个很有趣。
eg. a = abs   # 将变量a指向abs

****** 定义函数
  在Python中使用def语句定义一个函数，一次写出函数名、空号、参数、冒号，然后
  在缩进块中编写函数体，函数的返回值使用return语句返回。
  如果没有return语句，函数执行完毕后返回None。
****** 空函数
  def nop()：
    pass
  pass语句什么都不做，通常用作占位符，pass也可以用在其他语句中。
****** 参数检查
  调用函数是，如果参数个数不对，python解释器会自动检查出来，并抛出TypeError
  错误。
  而如果参数类型不对，Pyhon解释器则无法检查。因此，完善的函数定义需要对参数
  类型进行检查。
  eg.
     def my_abs(x):
         if not isinstance(x, (int, float))
             raise TypeError('Wrong operand type')
         if x >= 0:
             return x
         else:
             return -x
****** 多个返回值
  Python中函数可以返回多个值。
  但这是一种假象，实际上是通过tuple实现的，返回的仍然是单一值，只是书写起来
  方便。
****** 默认参数
Python函数定义支持默认参数。默认参数可以简化函数的调用。设置默认参数时，
需要注意：
  - 必选参数在前，默认参数在后
  - 当有多个默认参数时，变化大的参数放在前面，变化小的放在后面

默认参数最大的好处就是能降低函数调用的难度。
有多个默认参数是，调用是，既可以按顺序提供默认参数，也可以不按顺序提供部
分默认参数，此时需要把参数名写上。

默认参数使用不当会掉入陷阱。因为Python在定义函数的时候，默认参数L的值就被
计算出来了，默认参数也是一个变量。如果改变默认参数的内容，下次调用是，默
认参数就会改变。
所以，定义默认参数必须只想不变对象。
****** 可变参数
Python函数定义支持可变参数，只要在参数之前加上一个*号，在函数内部，该参数
接收到的就是一个tuple。调用时可向该参数传递任意个参数，包括0个参数。
list和tuple可以传递给可变参数，前面需要加上*
****** 关键字参数
关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部会自
动组装为dict.使用两个星号*后接参数名定义关键字参数。

在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这四
种参数可以任意组合使用，但参数定义的顺序必须是：必选参数，默认参数，可变
参数，关键字参数。
****** 递归
在函数内部可以调用其他函数。如果一个函数在内部调用函数自身，这个函数就是
递归函数。
Python递归支持递归。
递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环
的方式实现。
使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种
数据结构实现的，每当进入一个函数调用，栈就会增加一层栈帧，每当函数返回时，
栈就会减一层栈帧。由于栈的大小不是无限的，所以递归调用的次数过多会导致栈
溢出。
解决递归调用栈溢出的方法是通过尾递归优化，使递归本身无论调用多少次，都只
占用一个栈帧，不会出现栈溢出的情况。
遗憾的是，大多数变成语言没有对尾递归做优化，Python解释器也没有做优化，所
急，即使把函数改成尾递归方式，也会导致栈溢出。

***** 切片
Python通过切片进行范围索引，切片操作符为:(冒号)。
切片操作支持正序、逆序和定义增量。
list，tuple支持切片索引，返回对象。
字符串和Unicode字符串同样支持切片操作，返回结果仍是字符串。

***** 迭代
Python的for...in迭代(Iteration)的抽象程度要高于其他高级语言的for循环，不需
要通过下标完成，可以作用在list或tuple对象，以及其它可迭代对象上，即使该对象
是没有下标的，比如dict。

****** 字典的迭代
  for key in d    # 按关键字迭代
  for value in d.itervalues()    # 按值迭代
  for key, value in d.iteritems()    # 按关键字和值迭代

****** 字符串的迭代
  for ch in str

通过collections模块的Iterable类型可以判断一个对象是否为可迭代对象。
eg.    isinstance('abc', Iterable)    # True

enumerate()函数可以把一个list对象变成索引-元素对。
eg.  for i, value in enumerate(['a', 'b', 'c'])

***** 列表生成式
列表生成式可以用一行语句代替使用循环生成列表。
eg.  [x * x for x in range(1, 11)]
列表生成式还可以加上if判断
eg.  [x*x for x in range(1,11) if x%2 == 0]
可以使用两层循环的列表生成式，生成全排列。
eg.  [m+n for m in 'ABC' for n in 'XYZ']
三层和三层以上的循环就很少用到了。

运用列表生成式可以写出非常简洁的代码。
eg.  import os    # 导入os模块
[d for d in os.listdir('.')]    # 列出文件和目录

for循环可以同时使用两个甚至多个变量，因此列表生成式也可以使用两个变量生成
list
eg.  [k, v for k, v in d.iteritems()]

字符串的lower()方法将所有字符变成小写，对应应该有upper()方法。
使用内建的isinstance函数可以判断一个变量是不是字符串。
eg.  isinstance('123', str)

***** 生成器
如果列表元素可以按照某种算法推算出来，那么就可以在循环过程中不断推算出后续的元素，
这样就不必创建完整的list，从而节省空间。在Pthon中，这种一边循环一边计算的机制成
为*生成器（Generator）*
原因之一在于Python较其它语言高级，for...in循环中使用可迭代变量，如list,tuple等，
而不是索引值。

Python中创建generator有很多方法。
其中之一，只要把列表生成式的[]改为()即可
eg.   g = (x*x for x in range(10))

使用next()方法可以依次遍历generator中的列表元素。generator保存的是算法，每次调用
next()就会计算下一个元素的值，知道计算到最后一个元素，没有更多的元素时，抛出
StopIteration错误。
使用next()方法比较笨拙。由于generator是可迭代变量，因此可以使用for循环进行遍历。

当算法复杂使用列表生成式形式无法实现generator时，可以使用函数实现，这是创建
generator的另一中方法。
比如，斐波那契数列
    def fib(max)
        n, a, b = 0, 0, 1
        while n<max
            yeild b
            a, b = b, a+b
            n = n+1
generator使用yield关键字。这与一般函数的执行流程不一样。generator生成函数，在每
次调用next()时会执行，遇到yield语句返回，再次执行是从上次返回的yield语句处继续执
行。

***** 函数式编程

函数是Python内建支持的一种封装，通过把大段代码拆成函数，通过一层一层的函数调用，
就可以把复杂的任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数是
面向过程设计的基本单元。

计算机(Computer)和计算(Compute)
在计算机层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，汇编
语言是最贴近计算机的语言。
而计算是指数学意义上的计算，越是抽象的计算，离计算机硬件越远。

对应到编程语言，就是越低级的语言，越贴机计算机，抽象程度越低，执行效率越高，如C。
越高级的语言，越贴机计算，抽象程度越高，执行效率越低，如lisp语言。

函数式编程（Functional Programming）是一种抽象程度很高的编程范式，纯粹的函数式编
程语言没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数
没有副作用。
函数式编程的一个特点就是，允许函数本身作为参数传递给另外一个函数，还允许返回一个
函数。

Python对函数式编程提供部分支持。
***** 高阶函数（higher-order function）

函数本身可以赋值给变量，即，变量可以指向函数。
函数名本身也是变量，是指向函数的变量。
因此，函数名可以作为一个变量传递给另外一个函数。
一个函数接收另外一个函数作为参数，这种函数称之为高阶函数。
把函数作为参数传递，这样的函数成为高阶函数，这是一种函数式编程范式。
***** map/reduce
map是典型的高阶函数之一。map()函数接收两个参数，第一个是函数，第二个是序列，map
将传入的函数依次作用到序列的每一个元素，并把结果作为新的list返回。

reduce函数接收两个参数，第一个参数是函数，第二个参数是序列。作为参数传递的函数接
必须接收两个参数，reduce把该函数依次累积作用到序列上。
eg.  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
***** filter

filter()函数接收一个函数和一个序列，将传入的函数依次作用于列表的每一个元素，然后
根据返回值是True还是False决定保留还是丢弃该元素。
可见，filter()这个高阶函数，关键在于正确实现一个“筛选”函数。
***** sort

排序也是程序中经常用到的算法。无论是使用冒泡排序还是快速排序，排序的核心是比较两
个元素的大小。数字可以直接比较，但是其他类型变量如字符串、dict等，直接对其进行比
较是没有数学意义的，因此比较的机制必须通过函数抽象出来。
通常规定，对于两个元素，如果x>y，则返回1;如果x==y,则返回0;如果x<y,则返回-1。这样，
排序算法就不用关心具体的比较过程，而是根据比较的结果直接排序。

Python内置的sorted()函数可以直接对list进行排序。
同时，sorted()也是一个高阶函数，她可以接收一个比较函数作为第二个参数，来实现对第
一个参数（列表）的自定义排序。

***** 返回函数

高阶函数除了可以接收函数作为参数外，还可以把函数作为结果返回。
***** 匿名函数

当我们在传递函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。
eg.  map(lambda x : x*x, [1,2,3])
关键字lambda表示匿名函数，冒号前面的变量表示函数参数。
匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的计算结
果。
用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个
函数对象，因此可以吧匿名函数赋值个一个变量，在利用该变量调用该函数。
同样，也可以把匿名函数作为返回值返回。

Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数
***** 装饰器
函数对象有一个_name_属性，可以拿到函数的名字。

本质上，装饰器就是一个返回函数的高阶函数。
使用Python中的@语法，把decorator至于函数的定义处
***** 偏函数                                                    :partial:

Python的functools模块提供了很多有用的功能，其中一个就是偏函数(Partial function).
eg.    import functools
       int2 - functools.partial(int, 2)
functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），
返回一个新函数，调佣这个函数会更便捷。

创建偏函数时，实际上可以接收函数对象、 *args和 **kw这三个参数。

***** 模块                                                       :module:

为了编写可维护的代码，我们把很多函数分组，分别放在不同的文件里，这样每个文件中包
含的代码就相对较少，很多编程语言都采用这种组织代码的方式，在Python中，一个.py文
件就称之为一个模块(Module).
使用模块最大的好处就是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一
个模块编写完成后，就可以被其他地方引用。使用模块还可以避免函数名和变量名冲突，相
同名字的函数和变量完全可以分别存放在不同的模块之中。

为了避免模块名冲突，Python引入了按目录来组织模块的方法，称之为包(Package).
每个包目录下面都会有一个_init_.py文件，这个文件是必须存在的，否则，Python就会把
这个目录当作普通目录，而不是一个包。
可以有多级目录，组成多级层次的包结构。
***** 使用模块

模块的标准文件模板
#+BEGIN_EXAMPLE
  #!/usr/bin/env python              # 解释器
  # -*- coding: utf-8 -*-            # 编码方式
  ‘a test module’       # 任何模块代码的第一个字符串都被视为模块的文档注释
  __author__ = 'Ben'            # 作者名

  import sys                    # 导入模板

  def test():
      ……

  if __name__ == '__main__'
      test()

#+END_EXAMPLE


当在命令行运行hello模块文件时，Python解释器会把一个特殊变量__name__置为__main__，
而如果在其他地方导入该模块时。if判断将失效。因此，这种if测试可以让一个模块通过命
令行运行是执行一些额外的代码，最常见的就是运行测试。

导入模块时，可以使用别名。这样，可以在运行是根据当前环境选择最适合的模块。比如
Pyhton标准库一般会提供StringIO和cStringIO两个库，后者使用C写的，因而更快
try:
    import cStringIO as StringIO
except ImportErrir:
    import StringIO

作用域
有些函数和变量我们希望仅在模块内部使用，在Python中，是通过_前缀实现的。这是编程
习惯上的约定俗成，而不是强制性的不可访问。
特殊变量用__xxx__形式定义，可以被引用，但是有特殊用途。
***** 使用 *_future_*

Python提供了_future_模块,可以把新版本的特性导入到当前版本.
e.g.
Phthon 3.x中字符串均为Unicode编码,使用前缀b'string'表str
Phtyon 2.7中字符串为ASCII编码,使用前缀u'string'表unicode
#+BEGIN_EXAMPLE
  from _future_ import unicode_literals
  print '\'xxx\' is unicode?', isinstance('xxx', unicode)
  print 'u\'xxx\' is unicode?', isinstance(u'xxx', unicode)
  print '\'xxx\' is str?', isinstance('xxx', str)
  print 'b\'xxx\' is str?', isinstance(b'xxx', str)
#+END_EXAMPLE

e.g.
Python 2.x中除法为 *地板除*, 即整数相除,结果仍为整数.要做精确除法,必须
把其中一个写成浮点数.
Python 3.x中,所有的除法都是精确除法,地板除用 *//* 表示.
#+BEGIN_EXAMPLE
  from _future_ import division

  print '10 / 3 =', 10 / 3
  print '10.0 / 3 =', 10.0 / 3
  print '10 // 3 =', 10 // 3
#+END_EXAMPLE

**** 面向对象
***** *面向对象编程*
[[http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868200385680e8cf932dba9433ea367de9aba2b4784000#001414673847034cbe36eb363bd4a2eb91fee53912a7de7000][link]]
面向对象编程 *Object Oriented Programming*, 简称 *OOP*,是一种程序设计
思想.OOP把对象作为程序的基本单元,一个对象包含了数据和操作数据的函数.
在Python中,所有数据类型都可以视为对象,也可以自定义对象.
#+BEGIN_EXAMPLE
  # 面向过程
  std1 = {'name': 'Michael', 'score':98}
  std2 = {'name': 'Bob', 'score':81}
  def print_score(std):
      print '%s: %s ' % (std['name'], std['score'])

  # 面向对象
  class Student(object):
      def __init__(self, name, score):
          self.name = name
          self.score = score

      def print_score(self):
          print '%s: %s ' % (self.name, self.score)

  bart = Student('Bart Simpson', 59)
  lisa = Student('Lisa Simpson', 87)
  bart.print_score()
  lisa.print_score()
#+END_EXAMPLE

*数据封装,继承和多态是面向对象的三大特点*

***** 类和实例

[[http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138682004077376d2d7f8cc8a4e2c9982f92788588322000#main][link]]
*类(class)是抽象的模板,实例(instance)是根据模板创建出来的具体对象*
*每个对象拥有相同的方法,但各自的数据可能不同*
class Student(object)
在Python中,定义类是通过关键字class,后面接着的是类名,类名通常以大写开
头,object表父类.通常,如果没有合适的父类,就使用object类,这是所有类最终
都会继承的类.

*__init__* 是特殊的方法,通过它,在创建实例时,把必须绑定的属性填写进去.
__init_方法的第一个参数永远是self,表示创建的实例的本身.
有了__init__方法,在创建实例的时候,必须传入与其相匹配的参数,但self不需
要,Prthon解释器会自动把实例变量传进去.

类的方法的第一个参数永远是实例变量self,并且调用时不用传递该参数.

***** 访问限制

[[http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820042500060e2921830a4adf94fb31bcea8d6f5c000#001402635178014df9b8db22892435d8ba20f9f0acc5d01000][link]]
在Python中以双下划线开头的属性为 *私有变量(private)*,只有在内部可以访
问.可以增加get和set方法获取和修改该属性,在方法中,可以做参数检查.
类似__xxx__的变量为特殊变量,不是private.
以单下划线开头的变量,可以在外部访问,但约定俗成为私有变量.

*** TOBECONTINED [#C] Python核心编程                       :project:
**** Python入门

***** 什么是Python
Python是一门 *优雅* 而 *健壮* 的编程语言.
+ 继承传统编译语言的强大性和通用性
+ 借鉴简单脚本和解释语言的易用性

*只有你想不到的,没有Python做不到的*

***** 起源

1989, Guido van Rossum(贵铎.范.罗萨姆).
像C ,C++,Lisp,Java和Perl一样,Python来自于某个研究项目.

***** 特点                                                      :feature:
+ 高级
  机器语言->汇编语言->C,Fortan等高级语言->C++,Java等现代编译语
  言->Perl,Python等解释型脚本语言.
  Python具有高级的数据结构(列表,字典等),减少了"框架"开发需要的时间.

+ 面向对象
  面向对象为数据与逻辑相分离的结构化和过程化编程添加了新的活力.Python
  面向对象的特性是与生俱来的,同时Python融汇了多种编程风格.

+ 可升级
  Python提倡简洁的代码设计,高级的数据结构和模块化的组件.

+ 可扩展
  Python使用文件和模块对代码进行组织，对于所有模块，Python的访问语法是
  相同的。在一些特别强调性能的地方，可以作为Python扩展使用C重写，这些
  接口和纯Python接口是一样的。

+ 可移植
  Python是用C写的,C的可移植性使得Python可以运行在任何带有ANSI C编译器
  的平台上.

+ 易学
+ 易读
+ 易维护
+ 健壮性
+ 内存管理器
+ 解释性和字节编译性

***** Python的运行方式
****** 交互式的启动解释器
学习Python的最好方式就是在交互式解释器中练习。
****** 运行Python脚本
+ 在命令行上通过解释器执行
  #+BEGIN_EXAMPLE
  $ python script.py
  #+END_EXAMPLE
+ 自动执行Python解释器
  脚本文件首行：
  *#!/usr/bin/python*
  或
  */usr/bin/env python*

***** 比较Python
****** VS Perl
Perl最大的优势在于它的 *字符串匹配能力*,其提供了一个十分强大的正则表达
式匹配引擎.这使得Perl实际上成为一种用于过滤,识别和抽取字符串文本的语
言.Python的正则表达式引擎很大程度上是基于Perl的.
****** VS Java
Jython是一个完全使用Java开发的Python解释器.
****** VS Ruby
****** VS Tcl
**** Python起步

Python中有两种方式完成你的要求
+ *语句*: 使用关键字组成命令,告诉Python解释器做什么
+ *表达式*: 没有关键字,使用运算符或函数

***** print语句                                                   :print:

在交互式解释器中,查看变量内容:
+ 使用print语句显示变量的字符串表示
+ 仅使用变量名查看其原始值

注: 仅使用变量名时,输出的字符串是用单引号括起来的.

下划线 *_* 在解释器中有特别含义,表示最后一个表达式的值.

Python中的print语句,与格式化运算符(%)结合使用可实现字符串的替换功能.
#+BEGIN_SRC python :results output
print "%s is number %d" % ("Python", 1)
#+END_SRC

#+RESULTS:
: Python is number 1

*>>* 符号用于重定向.

#+BEGIN_SRC python :results output
import sys
print >> sys.stderr, 'Fatal error: invalid input!'
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
  logfile = open('./python/tmp/mylog.txt', 'a')
  print >> logfile, 'Fatal error: invalid inputg'
  logfile.close()
  #+END_SRC

#+RESULTS:
: None

***** raw_input()程序输入                                         :input:
input()
raw_input()

**** 字典                                                           :dict:

***** 映射类型:字典
****** 创建
+ 赋值
  #+BEGIN_EXAMPLE
      dict1 = {}
      dict2 = {'name':'earth', 'port':80}
  #+END_EXAMPLE
  字典的键可以混用数字字符串
  #+BEGIN_EXAMPLE
    dict3 = {}
    dict3[1] = 'abc'
    dict3['1'] = 3.14159
    dict3[3.2] = 'xyz'
  #+END_EXAMPLE
+ 工厂函数dict
  #+BEGIN_EXAMPLE
      fdict = dict((['x', 1], ['y', 2]))
  #+END_EXAMPLE
+ 内建方法fromkeys()
  #+BEGIN_EXAMPLE
    ddict = {}.fromkeys(('x', 'y'), -1)
    edict = {}.fromkeys(('foo', 'bar'))
  #+END_EXAMPLE
****** 访问
+ 循环查看字典的键来遍历一个字典
  #+BEGIN_EXAMPLE
    for key in dict2.keys():
        print "key=%s, value=%s" % (key, dict2[key])
  #+END_EXAMPLE
+ 使用迭代器访问序列对象(字典和文件等)
  #+BEGIN_EXAMPLE
    for key in dict2:
        print "key=%s, value=%s" % (key, dict2[key])
  #+END_EXAMPLE
+ 方括号索引键访问某个元素的值
  #+BEGIN_EXAMPLE
    dict2['name']
  #+END_EXAMPLE
  键"溢出"会产生 *KeyError* 错误.
  检测字典中是否存在某个键,可使用 *has_key()* 方法(将弃用). 更好的方法
  是使用 *in* 或 *not in* 操作符.
  #+BEGIN_EXAMPLE
  dict2.has_key("server")
  "server" in dict2
  #+END_EXAMPLE

****** 更新
+ 添加一个新的的数据项(即,一个键-值对)
+ 修改一个已存在的数据项
+ 删除一个已存在的数据项

#+BEGIN_EXAMPLE
  dict2['name'] = 'venus'
  dict2['port'] = 6969
  dict2['arch'] = 'sunos5'
#+END_EXAMPLE

update()方法将到整个字典的内容添加到另一个字典中.

在格式化字符串中使用字典:
#+BEGIN_EXAMPLE
  print "host %(name)s is running on port %(port)d" % dict2
#+END_EXAMPLE
****** 删除
删除整个字典的操作并不常见,通常只是删除字典中的单个元素或是清除整个字
典的内容.
#+BEGIN_EXAMPLE
  dict2.pop('arch')               # 删除并返回对应的条目
  del dict2["name"]               # 删除条目
  dict2.clear()                   # 清空字典
  del dict2                       # 删除字典
#+END_EXAMPLE
***** 映射类型操作符
字典可以和所有的标准类型操作符一起工作,但 *不支持拼接(concatenation)和*
*重复(repetition)* 等操作.
****** 标准类型操作符
****** 映射类型操作符
键查找操作符 *[]*
键成员关系操作符 *in, not in*
***** 映射类型的内建函数和工厂函数
****** 标准类型函数
*type()* 工厂函数,返回字典类型
*str()* 工厂函数,返回字符串表示
*cmp()* 工厂函数,比较两个字典:首先是字典大小,然后是键,最后是值.

cmp()算法:
1) 比较字典长度
2) 比较字典的键
3) 比较字典的值
4) Exact Match

****** 映射类型相关函数
******* dict()
+ 无参数: 生成空字典
+ 可迭代对象(序列,迭代器等):每个可迭代的元素必须成对出现.
  #+BEGIN_EXAMPLE
    dict(zip(('x', 'y'), (1, 2)))
    dict([['x', 1], ['y', 2]])
    dict([('xy'[i-1], i) for i in range(1,3)])
  #+END_EXAMPLE
+ 映射对象(字典等): 原对象的浅复制版本,等价于copy()方法,但慢.
   #+BEGIN_EXAMPLE
     dict4 = dict(dict3)
     dict5 = dict3.copy()
   #+END_EXAMPLE
+ 接受关键字参数字典(函数操作符)
  #+BEGIN_EXAMPLE
    dict(x=1, y=2, z=3)
  #+END_EXAMPLE
******* len()
******* hash() 返回对象的哈希值,判断一个对象是否是可哈希的,即是否可以作为一个字典的键.
非可哈希类型参数传递给hash()方法,会产生一个TypeError错误.

***** 映射类型内建方法
****** has_key()
****** keys() 返回所有键组成的列表
****** values() 返回所有值组成的列表
****** items() 返回所有(键,值)组成的列表
****** clear() 清空字典
****** copy() 浅复制
****** fromkeys(seq, val=None)
****** get(key, defalut=None)
****** iter()
****** pop(key[,default])
****** setdefault(key, default=None)
****** update(dict) 添加
***** 字典的键
字典的值没有任何限制,可以是任意Python对象.但是,字典的键是有类型限制的.
****** 不允许一个键对应多个值
当有冲突时,取最后的赋值.Python不会检查键的冲突行为(考虑效率).
****** 键必须是可哈希的
大多数Python可以作为键,但它们必须是可哈希的(列表字典等不可哈希).
所有不可变类型都是可哈希的.

*注:所有值相同的数字表示相同的键*, e.g. 整型1和浮点数1.0的哈希值相同.

某些可变对象是可哈希的,但很少.

数字和字符串最常用作字典的键.元组不可变,但不是一成不变,作为键使用必须
加以限制:元组中只有包括像数字,字符串这样的不可变参数时才能作为有效的键

**** 集合                                                      :set:
***** 集合类型
****** What?
*set*: 数学上,把由不同元素组成的集合称为set.
set elements: 集合元素.

*(Sets)是Python的内置数据类型. 集合对象是一组无序排列的可哈希的值*,集合成
员可做为字典的键.
******* 操作
+ in, not in
+ len()
+ for迭代
+ 不支持slice切片
+ 不支持keys键索引

******* 类型
+ *可变集合(set)*: 可以添加和删除元素,不可哈希
+ *不可变集合(frozenset)*: 不可更改,有哈希值
******* Sets
Python version >= 2.4
******* 集合操作符

****** 创建与赋值
集合没有特殊的语法格式, *工厂方法set()和frozenset()是唯一的创建方法*
#+BEGIN_EXAMPLE
  >>> s = set('cheeseshop')
  >>> s
  set(['c', 'e', 'h', 'o', 'p', 's'])
  >>> t = frozenset("bookshop")
  >>> t
  frozenset(['b', 'h', 'k', 'o', 'p', 's'])
  >>> type(t)
  <type 'frozenset'>
  >>> type(s)
  <type 'set'>
  >>> len(s)
  6
  >>> s == t
  False
#+END_EXAMPLE
****** 访问
+ 遍历
+ 检查某个元素是否存在

#+BEGIN_EXAMPLE
  >>> "k" in s
  False
  >>> "k" in t
  True
  >>> "c" not in t
  True
  >>> for i in s:
  ... print i
  ...
  c
  e
  h
  o
  p
  s
#+END_EXAMPLE
****** 更新
使用集合的建方法,frozenset不可更改
#+BEGIN_EXAMPLE
  >>> s.add("x")
  >>> s
  set(['c', 'e', 'h', 'o', 'p', 's', 'x'])
  >>> s.update("pypi")
  >>> s
  set(['c', 'e', 'i', 'h', 'o', 'p', 's', 'y', 'x'])
  >>> s -= set('pypi')
  >>> s
  set(['c', 'e', 'h', 'o', 's', 'x'])
  >>> t.add("z")
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  AttributeError: 'frozenset' object has no attribute 'add'
#+END_EXAMPLE
****** 删除
+ 删除元素: 内建方法
+ 删除集合对象
  - 超出使用域
  - del命令

#+BEGIN_EXAMPLE
>>> del s
>>>
#+END_EXAMPLE

***** 集合类型操作符
****** 标准类型操作符
******* 成员关系(in, not in)
******* 集合等价/不等价(==, !=)
#+BEGIN_EXAMPLE
  >>> set("posh") == set("shop")
  True
  >>> set("posh") == frozenset("shop")
  True
#+END_EXAMPLE
******* 子集/超集(<, <=, >, >=)
+ <  严格子集
+ <= 非严格子集
+ >  严格超集
+ >= 非严格超集

#+BEGIN_EXAMPLE
  >>> set("posh") == frozenset("shop")
  True
  >>> set("shop") < set("shop")
  False
  >>> set("shop") <= set("posh")
  True
#+END_EXAMPLE

****** 集合类型操作符
******* 联合(|)
+ 联合(union) 等价于集合的OR.
+方法union()

#+BEGIN_EXAMPLE
  >>> s | t
  set(['c', 'b', 'e', 'h', 'k', 'o', 'p', 's'])
#+END_EXAMPLE

******* 交集(&)
+ 等价于集合的AND操作
+ 方法: intersection()
#+BEGIN_EXAMPLE
  >>> s & t
  set(['h', 's', 'o', 'p'])
#+END_EXAMPLE

******* 差补(-)
+ 方法: difference()

#+BEGIN_EXAMPLE
  >>> s - t
  set(['c', 'e'])
#+END_EXAMPLE
******* 对称差分(^)
+ 等价于集合的XOR异或
+ 方法: symmetric_difference()

#+BEGIN_EXAMPLE
  >>> s ^ t
  set(['b', 'e', 'k', 'c'])
#+END_EXAMPLE

******* 混合集合类型操作
+ 左右类型相同(set/frozenset)时,类型不变
+ 左右类型不一致时,结果类型与左操作数相同

******* 加号"+"不是集合类型的运算符
#+BEGIN_EXAMPLE
  >>> s + t
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  TypeError: unsupported operand type(s) for +: 'set' and 'frozenset'
#+END_EXAMPLE
****** 可变集合类型操作符
******* Update (|=)
方法: update()
******* 交集(&=)
方法: intersection_update.
******* 差更新(-=)
方法: difference_update()
******* 对称差分更新(^=)
方法: symmetric_difference_update()

***** 内建函数
****** 标准类型函数
******* len()
****** 集合类型工厂函数
******* set() and frozenset()
#+BEGIN_EXAMPLE
  >>> set()
  set([])
  >>> set([])
  set([])
  >>> set("shop")
  set(['h', 's', 'o', 'p'])
  >>> frozenset(["foo", "bar"])
  frozenset(['foo', 'bar'])
  >>> f = open("numbers", "w")
  >>> for i in range(5)
    File "<stdin>", line 1
      for i in range(5)
                      ^
  SyntaxError: invalid syntax
  >>> for i in range(5):
  ...  f.write("%d\n" % i)
  ...
  >>> f.close()
  >>> f = open("numbers", "r")
  >>> set(f)
  set(['0\n', '3\n', '1\n', '4\n', '2\n'])
  >>> f.close
  <built-in method close of file object at 0xb7493288>
  >>> f.close()
#+END_EXAMPLE
***** 内建方法
****** 方法
+ s.issubset(t)
+ s.issuperset(t)
+ s.union(t)
+ s.intersection(t)
+ s.difference(t)
+ s.symmetric_diffrence(t)
+ s.copy()  返回一个新集合,浅复制,比工厂函数要快
****** 可变集合的方法
+ add()
+ remove()
+ discard()
+ pop()
+ clear()
  **** HALT 条件与循环


Reference: P189-P209
**** 条件
***** if语句
#+BEGIN_EXAMPLE
  if expression:
     expr_true_suite
#+END_EXAMPLE

+ 多重条件表达式使用布尔操作符 *and, or 和 not*
+ 单一语句的代码块可以与if语句写在同一行,但降低了可阅读性

***** else语句
#+BEGIN_EXAMPLE
  if expressin:
     expr_true_suite
  else:
     expr_false_suite
#+END_EXAMPLE

+ Python使用缩进有效地避免了"悬挂else(dangling else)"问题.
  #+BEGIN_EXAMPLE
    if(balance > 0.00)
        if(((balance-amt)>min_bal) && (atm_cashout()==1))
            printf("Here is your cash; please take all bills.")
    else
        printf("Your balance is zero or negative.")
  #+END_EXAMPLE

***** elif语句
#+BEGIN_EXAMPLE
  if expr1:
      expr1_true-suite
  elif expr2:
      expr2_true_suite
  elif expr3:
      expr3_ture_suite
  else:
      none_true_suite
#+END_EXAMPLE

当前Python版本不支持switch/case语句.

***** 条件表达式(三元操作符)
*X if C else Y*

**** 循环
***** While语句
#+BEGIN_EXAMPLE
  While expr:
      suite_to_repeat
#+END_EXAMPLE

***** for语句
for语句是Python最强大的循环结构,与传统语言中的for不同.
#+BEGIN_EXAMPLE
  for iter_var in iterable:
      suite_to_repeat
#+END_EXAMPLE
****** 用于序列类型
+ 迭代字符串
+ 迭代序列项
+ 迭代序列索引
+ 迭代项和索引, 内建函数 *enumerate()*
****** 用于迭代器
用for循环访问迭代器和访问序列方法类似,区别是能做更多的事情.

迭代器有一个 *next()* 方法.

****** range()内建函数
+ 完整语法: *range(start, end, step=1)*
+ 简略语法:
  + range(end)    # start=0, step=1
  + range(start, end)  # step=1
+ 注: range()有两种语法

注: step不能为零,否则会发生错误

****** xrange()
+ 与range()类似, 更适用大范围
+ 不会在内存中创建列表的完整拷贝
+ 只能在for循环中使用
+ 性能比range()高
+ 返回可迭代对象,但不是列表也不是迭代器

****** 序列相关的内建函数
+ sorted() 返回列表
+ zip()  返回列表
+ reversed()  返回迭代器
+ enumerate()  返回迭代器

***** break语句
类似C中的传统break

***** continue语句

***** pass语句
有些地方语法上要求有代码, 而Python中没有对应C中的大括号或分号来表示不
做任何事情, 因此, *Python提供了pass语句,它不做任何事情,即NOP*

pass同样可以作为开发中的小技巧,标记你后来要完成的代码.
***** for-else & while-else
else用于循环后处理(post-processing), 只要循环是正常结束的(不是通过
break语句), else子句就会执行.
***** 迭代器和iter()
从根本上讲, *迭代器就是有一个next()方法的对象*
+ iter()
+ reversed()
+ enumerate()
+ any()
+ all()

#+BEGIN_EXAMPLE
  >>> myTuple = (123, 'xyz',45.67)
  >>> i = iter(myTuple)
  >>> i.next()
  123
  >>> i.next()
  'xyz'
  >>> i.next()
  45.67
  >>> i.next()
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  StopIteration
#+END_EXAMPLE

****** 字典
字典迭代器会遍历字典的键
+ for eachKey in myDick.keys()
+ *for eachKey in myDick*

内建方法:
+ iterkeys()
+ itervalues()
+ iteritems()

****** 文件
文件对象生成的迭代器会自动调用readline()方法,循环访问文本文件的所有行..
+ *for eachLine in myFiles*
+ for eachLine in myFiles.readlines()

****** 可变对象和迭代器
*在迭代可变对象的时候修改它们并不是好主意*

****** iter
+ iter(obj)
+ iter(func, sentinel), 重复调用func直到迭代器的下一个值等于sentinel.

****** 列表解析

**** 文件和输入输出                                          :file:

***** 文件对象
文件对象不仅可以用来访问普通的磁盘文件，也可以访问任何其它类型抽象层面
上的”文件“ (*类文件*)。如 url, process等。

文件只是连续的字节流。
***** 文件内建函数
1. open()
   1) 语法
      file_object = open(file_name, access_mode="r", buffering=-1)
   2) access_mode
      + r
      + w
      + a
      + b(二进制，对于Linux可有可无)
      + U(通用换行符)
   3) buffering
      + 0 不缓冲
      + 1 只缓冲一行数据
      + -1
2. file()
   file函数与open具有相同的功能，可任意替换。
3. 通用换行符支持(UNS: Universe Newline Support)
   + Unix: \textbackslash{}n
   + Window: \textbackslash{}r\textbackslash{}n
   + 旧的OS X: \textbackslash{}r
   + 所有的行分隔符被替换为NEWLINE(\textbackslash{}n)
   + 文件的newline属性会标记为文件中的换行符
   + 默认打开

***** 文件内建方法
****** 输入
+ read(size=-1)
+ readline(size=-1): 保留换行符
+ readlines()： 读取剩余的所有的行并返回为字符串
+ xreadlines(): xreadlines模块中，性能高，但迭代更加优越
****** 输出
+ write(str)
+ writelines(str_list)

#+BEGIN_SRC sh :exports none
echo "foo" >> src/1504091737.txt
echo "bar" >> src/1504091737.txt
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :exports both :results output
  f = open("/home/ben/Tiger/Journal/src/1504091737.txt", "r")
  data = [line.strip() for line in f.readlines()]
  print data
  f.close()
#+END_SRC

#+RESULTS:
: ['foo', 'bar']

****** 文件内移动
+ seek(offset, base=0)
+ base
  + 0 文件开头
  + 1 当前位置
  + 2 文件末尾

****** 文件迭代
+ iter(file)
+ for line in f:

\lstinputlisting{/home/ben/Project/Python/CorePythonProgramming/20150409182306.py}
\lstinputlisting{/home/ben/Project/Python/CorePythonProgramming/20150409200328.py}

****** 行分隔符和其它文件操作系统的差异
1. 行分隔符
   + POSIX : \textbackslash{}n
   + DOS/Win32: \textbackslash{}r\textbackslash{}n
   + 旧的MacOS： \textbackslash{}r
2. 路径分隔符
   + POSIX: /
   + DOS/Windows: \
   + 旧的MacOS: :
3. os模块提供的有用属性
   1) linesep: 行分隔符
   2) sep: 文件路径名分隔符
   3) pathsep: 文件路径的分隔符
   4) curdir: 当前工作目录
   5) pardir: 父目录


****** 其它杂项
1. close()

   良好的编程习惯要求在重新赋另一个文件对象之前关闭这个文件。

2. tell()

3. truncate(size)
   将文本文件截取到size处，size默认为当前位置
***** 文件内建属性
+ file.closed
+ file.encoding
+ file.mode
+ file.name
+ file.newlines

***** 标准文件
sys模块提供了标准文件的句柄
+ sys.stdin  标准输入
+ sys.stdout 标准输出
+ sys.stderr 标准错误
***** 命令行参数
+ sys.argv属性提供了对命令行参数的访问，以列表的形式
+ argc即len(argv)

\lstinputlisting{/home/ben/Project/Python/CorePythonProgramming/20150409202529.txt}

***** 文件系统

****** os
1. 文件处理
   + mkfifo()/mknod()
   + remove()/unlink()
   + rename()/renames()
   + stat()
   + symlink()
   + utime()
   + tmpfile()
   + walk(): 生成目录树下的所有文件名
2. 目录
   + chdir()/fchdir()
   + chroot()
   + listdir()
   + getcwd()/getcwdu()
   + mkdir()/mkdirs()
   + rmdir()/removedirs()
3. 访问权限
   + access()
   + chmod()
   + chown()/lchown()
   + umask()
4. 文件描述符
   + open()
   + read()/write()
   + dup()/dup2()
5. 设备号
   + makedev()
   + major()/minor()

****** os.path
1. 分隔
   + basename()
   + dirname()
   + join()
   + split()
   + splitdrive()
   + splittext()
2. 信息
   + getatime()
   + getctime()
   + getmtime()
   + getsize()
3. 查询
   + exists()
   + isabs()
   + isdir()
   + isfile()
   + islink()
   + ismount()
   + samefile()
***** 文件执行
***** 永久存储模块
***** 相关模块
**** 异常                                                      :exception:

***** 错误与异常
1. 错误
   + 语法错误
   + 逻辑错误

2. 异常

   异常是因为程序出现了错误而在正常控制流以外采取的行为。
***** Python 异常
+ NameError
+ ZeroDevisionError
+ SyntaxError
+ IndexError
+ KeyError
+ IOError
+ AttributeError
+ ValueError
+ TypeError
***** 异常检测和处理
****** try-except
#+BEGIN_EXAMPLE
  try:
      try_suite    # watch exceptions here
  except Exception[,reason]:
      except_suite # exception-handling code
#+END_EXAMPLE
****** 多个except语句
#+BEGIN_EXAMPLE
  try:
      try_suite    # watch exceptions here
  except Exception1[,reason1]:
      except_suite1 # exception-handling code
  except Exception2[,reason2]:
      except_suite2
  ...
#+END_EXAMPLE
****** 处理多个异常的except语句
#+BEGIN_EXAMPLE
  except (Exception1, Exception2)[,reason]
         suit_for_Exception1_and_Exception2
#+END_EXAMPLE
****** COMMENT 捕获所有异常
#+BEGIN_EXAMPLE
  try:
      :
  except Exception, e:
      # error occurred
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  try:
      :
  except:    # 裸except，不推荐
      # erro occurred
#+END_EXAMPLE

- BaseException
  - KeyboardInterrupt
  - SystemExit
  - Exception
    - all others
****** else子句
****** finally子句
****** try-finally
***** 上下文管理
#+BEGIN_EXAMPLE
  with context_expr [as var]:
       with_suite
#+END_EXAMPLE

with语句仅能用于支持上下文管理(context management)的对象。
+ file
+ decimal.Context
+ thread.LockType
+ threading.Lock
+ threading.RLock
+ threading.Conditin
+ threading.Semaphore
+ threading.BoundedSemaphore

#+BEGIN_EXAMPLE
  with open('/etc/passwd', 'r') as f:
       for eachline in f:
           # ... do stuff with eachline of f
#+END_EXAMPLE
***** 触发异常
****** raise语句
raise [SomeException [,args [,traceback]]]

**** 模块                                                         :module:
***** 搜索路径
+ 环境变量：PYTHONPATH
  + shell: echo PYTHONPATH
  + python: sys.path(列表)
    + append(PATH)
***** 名称空间
+ 局部空间
+ 全局空间
+ 内建名称空间
***** 导入模块
import module1[,module2, [... moduleN]]

+ Pyhon标准库模块
+ Pyhon第三方模块
+ 应用程序自定义模块
***** from-import
from module import name1 [, name2 [...nameN]]
注： from module import * 不是好的编程风格。
****** 多行导入
#+BEGIN_EXAMPLE
  from moudle import name1, \
                     name2, name3
#+END_EXAMPLE
***** import-as
重新绑定名称
***** __future__
from __future__ import new_features

只import __future__ 不会有任何作用。
***** 从zip文件中导入
将zip归档文件当作目录处理。
***** 模块内建函数
import语句实际调用__import__()函数完成工作。
***** reload()
***** 包
包含模块文件的文件夹，即模块的组织形式。

#+BEGIN_EXAMPLE
  #!/usr/bin/env python
  # -*- coding: UTF-8 -*-
#+END_EXAMPLE

**** Python:13

+ 新式类(推荐)与经典类
  - 声明的不同
  - 属性的不同
+ 命名规范
+ 属性
  - 数据属性
  - 方法
  - 查看
    - dir():内建方法
    - __dict__: 属性
+ “构造器”：__init__
+ "this": self
+ 特殊属性：
  - __name__
  - __doc__
  - __bases__ : 所有父类构成的元组
  - __dict__ : 所有属性构成的字典
  - __module : 类所在的模块
  - __class__ : 实例对应的类(仅新式类)

*** Python学习
**** Python基础
作者： *Guido van Rossum（龟叔）*

TIOBE排行

龟叔给Python的定位： *优雅、明确、简单*

输入 *input()* ： birth = input("birth: ")

*r"" 不转义*

布尔值： *True* *False*

布尔运算： *and or not*

空值： *None*

*动态语言* ： 变量类型不固定的语言。

Python中通常使用 *全部大写* 的变量名表示 *常量*

*/ 为一般除法， // 为地板除法 % 取余*

编码： ASCII, Unicode, *UTF-8* --- 在计算机内存中统一使用Unicode编码，
当需要保存到硬盘或需要传输时，就转换为UTF-8。

*ord* 将字符转换为整型编码， *chr* 将编码转换为对应字符。

*len()* 函数返回字符串长度

指定保存为UTF-8编码
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
#!/usr/env/bin python
# -*- coding: utf-8 -*-
\end{minted}
#+end_latex

**** list, tuple, dict, set
***** list                                                     :listings:
list方法
1. append(element)
2. pop() 删除尾部元素
3. pop(i) 删除索引元素

***** tuple                                                       :tuple:
长度为1的tuple类型定义, *显示地使用逗号*
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
t = (1)  # 定义整数1
t = (1, ) # 定义tuple
\end{minted}
#+end_latex

*int()* 转换字符串为整数

***** dict                                                         :dict:
*字典-dict-map(其它语言)-(key:value)*
- 查找速度快，使用索引表
- list则不然，需要遍历

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
d = {'michael':95, 'bob':75, 'tracy':85}  # 初始化
d['adam'] = 67  # 也可以

# 判断key是否存在
'thomas' in d  # in 操作，返回布尔值
d.get('thomas')  # 存在则返回对应值，不存在返回none
d.get('thomas', -1)  # 不存在返回指定值, 但并不增加键
\end{minted}
#+end_latex

*dict vs list*  *以空间换时间*
+ 查找和插入速度快， 不会随着key的增加而增加
+ 需用占用大量内存
+ dict用在需要高速查找的地方

dict的键key必须是 *不可变对象* ,  如字符串、整数等，list则不行
通过key计算位置的算法，称为 *哈希算法(hash)*

***** set                                                     :setlength:
*集合set* 是一组没有重复的 key 值, 可以做集合上的交集、并集等运算。
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
s = {1,2,3,4,4}
s = set([1, 2, 3])
s.add(4)
s.remove(4)
\end{minted}
#+end_latex

**** 函数                                                       :function:
***** 定义
*函数别名： a=abs*

函数定义
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def func(args):
    body
\end{minted}
#+end_latex

空函数: *pass占位符*
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def nop():
    pass
\end{minted}
#+end_latex

参数类型检查与抛出异常
+ *isinstance*
+ *raise*
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x >= 0:
        return x
    else:
        return -x
\end{minted}
#+end_latex

***** 参数
1. 位置参数（普通参数、必选参数）
2. 默认参数（必须为不可变对象）
3. 可变参数（传入的参数个数是可变的, *号开头）
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{py}
     def calc(*numbers):
         sum = 0
         for n in numbers:
             sum = sum + n
         return sum

     sum1 = calc(1)
     sum2 = calc(1,2)

     l = [1, 2, 3]
     sum3 = calc(l[1], l[2], l[3])
     sum4 = calc(*sum)   # *开头传入list或tuple
     \end{minted}
   #+end_latex
4. 关键字参数(**开头，可以扩展函数的功能)
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{py}
     def person(name, age, **kw):
         if 'city' in kw:
             pass
         if 'job' in kw:
             pass
         print('name', name, 'age:', age, 'other:', kw)
     \end{minted}
   #+end_latex
   + 可变参数允许传入0个或多个任意参数，这些可变参数在调用时自动组装成
     *一个tuple*
   + 关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数在函数
     内部会自动组装成一个dict
5. 命名关键字参数(使用分割符*)
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{py}
     def person(name, age, *, city="Beijing", job):
         print(name, age, city, job)
     \end{minted}
   #+end_latex
   命名关键字参数必须传入参数名，这和位置参数不同。

6. 组合参数顺序
   必选参数->默认参数->可变参数/命名关键字参数->关键字参数

***** 递归函数
递归函数需要防止栈溢出。

*尾递归优化* 在函数返回的时候调用自身，并且，return语句不能包含表达式。
尾递归优化仅使用一个栈桢。尾递归事实上和循环是等价的，没有循环语句的编
程语言只能通过尾递归实现循环。

Python解释器没有针对尾递归进行优化。

**** 序列                                                       :listings:
***** 迭代

dict默认迭代key
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
for key in d:
    pass
for value in d.values():
    pass
for k, v in d.items():
    pass
\end{minted}
#+end_latex

for-in可用于任何可迭代对象。
使用collection模块中的Iterable类型可以判断对象是否可迭代
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
from collections import Iterable
isinstance(obj, Iterable)
\end{minted}
#+end_latex

*enumerate* 函数可以把一个list对象变成索引-元素对
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
for i, value in enumerate(alist):
    pass
\end{minted}
#+end_latex

***** 列表生成式(List comperhensions)
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
[x*x for x in range(1, 11)]  # 表达式+for-in循环
[x*x for x in range(1, 11) if x%2 == 0]  # 条件判断
[m+n for m in 'ABC' for n in 'XYZ]  # 两层
\end{minted}
#+end_latex

***** 生成器(generator)
generator保存的是 *算法*
*一边循环一边计算, 节省内存空间*
使用next方法可以获取generator的下一个元素。

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
L = [x*x for x in range(10)]  # L是一个列表
G = (x*x for x in range(10))  # G是一个generator
next(G)
\end{minted}
#+end_latex

*generator也是可迭代对象，因而可以使用for-in*
#+BEGIN_EXAMPLE
>>> g = (x*x for x  in range(10))
>>> next(g)
0
>>> next(g)
1
>>> for n in g:
...     print n
...
4
9
16
25
36
49
64
81
>>>
#+END_EXAMPLE

*yeild* 生成器的另一种定义方法
#+begin_latex
  \begin{minted}[frame=single, mathescape]{py}
  def fib_func(max):
      n, a, b = 0, 0, 1
      while n < max:
          print b
          a, b = b, a+b
          n = n + 1
      return 'done'


  def fib_gen(max):
      n, a, b = 0, 0, 1
      while n < max:
          yield b
          a, b = b, a+b
          n = n+1
      return 'done'
  \end{minted}
#+end_latex

generator与函数的执行流程
+ 函数是顺序执行，遇到return语句或者最后一行函数语句就返回。
+ 而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，
  再次执行时从上次返回的yield语句处继续执行。

***** 迭代器
*可迭代对象(Iterable)*
+ 集合数据类型： list, tuple, dict, set, str
+ generator

生成器还可以用于next()函数。能够被next()函数不断调用并返回下一个值，直
到最后抛出一个StopIteration错误的对象称为 *迭代器(iterator)*

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
from collections import Iterator
isinstance((x for x in range(10)), Iterator)  # True
isinstance([x for x in range(10)], Iterator)  # False
\end{minted}
#+end_latex

+ 生成器都是Iterator
+ list、 dict、 str不是，可以使用iter()函数将其转换为Iterator

Iterator对象表示的是一个 *数据流* 。

**** 函数式编程
越低级的语言，越贴近计算机，抽象程度越低，执行效率越高；
越高级的语言，越贴近计算， 抽象程度越高，执行效率越低。

函数式编程是一种抽象程度很高的编程范式。
+ 没有变量
+ 输入确定，输出即确定（没有副作用）
+ 允许传递和返回函数

***** map/reduce
map()接收两个参数，第一个是函数，第二个是Iterable,  *map将传递的函数依次
作用于序列的每一个元素，并把结果作为新的iterator返回。*

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
list(map(str, [1, 2, 3, 4, 5]))
\end{minted}
#+end_latex

map *高阶函数*

*reduce* 把一个函数作用在一个序列上，这个函数必须接收两个参数，reduce
把结果继续和序列的下一个元素作累积计算
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
from functools import reduce
def fn(x, y):
    return x*10 + y
reduce(fn, [1, 3, 5, 7, 9])
\end{minted}
#+end_latex

***** filter
filter函数用于过滤序列。
filter作用于一个函数和一个序列，把传入的函数依次作用于每个元素，然后根
据返回值是True还是False决定保留还是放弃该元素。

filter返回的是一个Iterator，也就是一个 *惰性序列* ,  所以要强迫
filter()完成计算结果，需要用list()函数获得所有结果并返回list对象。

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 3, 4, 5, 6, 7]))
\end{minted}
#+end_latex

***** sorted
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
sorted([25, 36, 12, 56, 18])
\end{minted}
#+end_latex

sorted也是一个高阶函数， 可以接收一个key函数实现自定义的排序
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
sorted([25, 36, 12, 56, 18], key=abs)
sorted('bob', 'about', 'Zoo', 'Credit',  key=str.lower)
\end{minted}
#+end_latex
*Z的ASCII值比a的小*

***** 返回函数
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax += n
        return ax
    return sum
\end{minted}
#+end_latex

#+BEGIN_EXAMPLE
>>> f = web_tutorial.lazy_sum(1, 2, 3, 4)
>>> f
<function sum at 0xb7114c6c>
>>> f()
10
#+END_EXAMPLE

***** 匿名函数
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
lambda x:x*x
\end{minted}
#+end_latex
冒号前面表示参数

匿名函数也是一个函数对象，因而可以赋值给一个变量。

也可以把匿名函数作为返回值老进行返回
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def build(x, y):
    return lambda： x*x + y:y
\end{minted}
#+end_latex

Python对匿名函数支持有限。

***** 装饰器
函数也是一个对象
+ 可以被赋值给变量，并通过变量调用
+ 有属性
  - __name__ 函数的名字

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def now():
    print('2015-11-19')

f = now
f()
print now.__name__
\end{minted}
#+end_latex

在代码运行期间动态增加功能的方式，称为 *装饰器(Decorator)*
本质上，decorator是一个返回函数的高阶函数。

@修饰，放在函数定义之前。

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def log(func):
    def wrapper(*arg, **kw):
        print('call %s()' % func.__name__)
        return func(*arg, **kw)
    return wrapper

@log
def now():
    print('2015-11-19')

# call now()
# 2015-11-19
\end{minted}
#+end_latex


******* 偏函数
*functools* 模块的 *partial*

所为偏函数，就是把一个函数的某些参数给固定住（也就是默认值），返回一个
新的函数，调用这个函数会更简单。

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
import functools

int2 = functools.partial(int, base=2)
print int2('100')
\end{minted}
#+end_latex

**** 模块                                                         :module:
***** 模块
一个.py文件就是一个 *模块* 。
+ 便于维护
+ 避免名字冲突


*包（package）* 避免模块文件名冲突， 模块文件置于包(目录)下。

*__init__.py* 在于与否用于区分普通目录还是包目录， 可以是空文件，与可
以有Python代码（本身就是一个模块）

可以有 *多级* 包目录

***** 使用模块
import

__xxx__ 特殊变量，可以被引用，但有特殊用途

__xxx _xxx 非公开变量或函数，不应该在外部直接引用

Python没有一种方法可以完全限制访问private函数或变量

***** 安装第三方模块
*pip*

注册网站： https://pypi.python.org/pypi

常用模块
+ numpy 科学计算
+ mysql-connector-python
+ jinja2 生成文本
+ Pillow 处理图片

***** 模块搜索路径
1. *sys.path* 变量
   #+BEGIN_EXAMPLE
     >>> import sys
     >>> sys.path
     ['',
     '/usr/local/lib/python2.7/dist-packages/distribute-0.6.28-py2.7.egg',
     '/usr/local/lib/python2.7/dist-packages/MySQL_python-1.2.4b4-py2.7-linux-i686.egg',
     '/usr/local/lib/python2.7/dist-packages/pip-6.1.1-py2.7.egg',
     '/usr/lib/python2.7', '/usr/lib/python2.7/plat-i386-linux-gnu',
     '/usr/lib/python2.7/lib-tk', '/usr/lib/python2.7/lib-old',
     '/usr/lib/python2.7/lib-dynload',
     '/home/ben/.local/lib/python2.7/site-packages',
     '/usr/local/lib/python2.7/dist-packages',
     '/usr/lib/python2.7/dist-packages',
     '/usr/lib/python2.7/dist-packages/PILcompat',
     '/usr/lib/python2.7/dist-packages/gst-0.10',
     '/usr/lib/python2.7/dist-packages/gtk-2.0',
     '/usr/lib/pymodules/python2.7',
     '/usr/lib/python2.7/dist-packages/ubuntu-sso-client',
     '/usr/lib/python2.7/dist-packages/wx-2.8-gtk2-unicode']

   #+END_EXAMPLE

2. 添加
   1) sys.path.append(PATH)

   2) 设置环境变量 *PYTHONPATH*

**** 面向对象编程 OOP                                              :class:
***** 变量类型

私有变量： 双下划线开头 __xxx
_xxx， 单下划线开头，“我不是私有变量，但不要随便访问”
__xxx__,  特殊变量，可以访问

***** 多态优点

[[/home/ben/Wally/Journal/Figure/scrot/665GXj.png]]

***** 获取对象信息
1. type() 基本数据类型
2. import types type() 函数对象
3. *isinstance* 类对象
4. *dir()* 获取一个对象的所有属性和方法
5. hasattri 测试对象是否有属性

***** 实例属性和类属性
Python是动态语言，根据类创建的实例可以任意绑定属性
+ 通过实例对象
+ 通过self

类本身中可以定义属性(*类属性*)，类属性可以通过实例访问。

类属性和实例属性不要同名，会屏蔽。

***** __slots__
同样可以给实例绑定方法, 使用 *types* 模块中的 *MethodType* 函数。
给一个实例绑定的方法，对另一个实例不起作用。
可以给类绑定方法
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
class Student(object):
    pass

s = Student()
def set_age(self, age):
    self.age = age

from types import MethodType
s.set_age = MethodType(set_age, s)
Student.set_age = MethodType(set_age, Student)
s1 = Student()
s1.set_age(18)
\end{minted}
#+end_latex

在类定义时添加特殊的变量 *__slots__* ，限制实例的属性，
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
class Student(object):
    __slots__ = ('name', 'age')
\end{minted}
#+end_latex

__slots__仅对当前类有效，对继承的子类无效。

***** @property
@property 装饰器， 将一个getter方法变成一个属性，本身又创建了另外一个
setter装饰器。

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
class Student(object):
    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0~100')
        self._score = value


## 像属性一样调用方法
s = Student()
s.score = 90                    # OK 实际转换为s.set_score(90)
print s.score                   # OK 实际 转换为s.get_score()
\end{minted}
#+end_latex

不定义setter方法，就是一个只读属性。

***** 定制类
+ __slots__
+ __len__
+ __str__
+ __repr__
+ __iter__ __next__
+ __getitem__
+ __getattr__
+ __call__: obj()

***** 枚举类定义常量
enum模块的 *Enum* 类

pip install enum

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
\end{minted}
#+end_latex

也可以通过继承实现

***** 使用元类
****** type
动态语言和静态语言的最大的不同，就是 *函数和类的定义，不是在编译时定义
的，而是在运动时定义的*

动态创建的方法是 type()

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def fn(self, name='world'):
    print('Hello, %s' % name)

Hello = type('Hello',           # 类名
             (object,),         # 单元素Tuple
             dict(hello=fn))    # 方法名与函数绑定
\end{minted}
#+end_latex

通过type()创建的函数和直接写class是完全一样的，因为Python解释器在遇到
class定义时，仅仅是扫描class下定义的语法，然后调用type()函数创建class.

****** metaclass 元类
类的抽象，即可以根据metaclass创建出类，就像对象和类的关系。

**** 错误处理                                                  :exception:

***** try...except...finally
用错误码（即返回值中包含错误信息）表示是否出错十分不便。
高级语言都内置了一套 *try...excpet...finally...* 的错误处理机制。

当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出
错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，
执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完
毕。

错误类：
+ BaseException
+ ValueError
+ ZeroDivisionError

***** 记录错误

*logging* 模块

import logging
logging.exception(e)

***** 抛出错误
raise

**** 调试                                                          :debug:
1. print()
2. assert
3. logging
4. pdb

** Debug                                                              :debug:
*** pdb调试                                                           :pdb:
+ https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/
+ http://yanam0518.blog.163.com/blog/static/7289583201210284315680/


debug对于任何开发人员都是一项非常重要的技能，它能帮助我们准确地定位错
误，发现程序中的bug。

pdb是python自带的一个包，为python程序提供了一种交互式的源代码调试功能，
主要特性包括设置断点、单步调试、进入函数调试、查看当前代码、查看栈片段、
动态改变变量的值等。

**** pdb常用命令
+ b  break    设置断点
+ c  continue 继续执行程序
+ l  list     查看当前行的代码片段
+ s  step     进入函数
+ r  return   执行代码直到从当前函数中返回
+ n  next     执行下一行
+ q  exit     中止并退出
+ pp          打印变量值
+ help        帮助


1. 运行 python -m pdb myscript.py
   (Pdb) 会自动停在第一行，等待调试,这时你可以看看 帮助
   (Pdb) h

2. 断点设置
   + (Pdb)b 10           # 断点设置在本py的第10行,或
   + (Pdb)b ots.py:20    # 断点设置到 ots.py第20行
   + (Pdb)b              # 查看断点编号
   + (Pdb)cl 2           # 删除第2个断点

3. 运行
   + (Pdb)n    # 单步运行
   + (Pdb)s    # 细点运行 也就是会下到，方法
   + (Pdb)c    # 跳到下个断点

4. 查看
   + (Pdb)p param    #查看当前 变量值
   + (Pdb)l          #查看运行到某处代码
   + (Pdb)a          #查看全部栈内变量

5. 如果是在 命令行里的调试为：
   #+BEGIN_EXAMPLE
     import pdb
     def tt():
     pdb.set_trace()
     for i in range(1, 5):
     print i
   #+END_EXAMPLE

*** gdb python                                                 :gdb:python:

**** why debugging python with GDB

There are types of bugs that are difficult to debug from within
Python:

- segfaults (not uncaught Python exceptions)
- hung processes (in cases where you can't get a Python traceback or
  debug with pdb)
- out of control daemon processes

In these cases, you can try gdb.

_也就是说，一般情况下使用 PDB 就足够了。只有特殊情况下才需要祭出上古神
器_

**** 简单使用

1. interactively

   #+BEGIN_EXAMPLE
     $ gdb python
     (gdb) run <program>.py <arguments>
   #+END_EXAMPLE

2. automatic:

   #+BEGIN_EXAMPLE
   $ gdb -ex r --args python <programname>.py <arguments>
   #+END_EXAMPLE

3. already running

   #+BEGIN_EXAMPLE
   $ gdb python <pid of running process>
   #+END_EXAMPLE

**** Reference

- [[https://wiki.python.org/moin/DebuggingWithGdb][PythonWiki]]
- [[http://www.cnblogs.com/dkblog/p/3806277.html][使用gdb调试Python进程]]

** TKinter                                                     :tkinter:gui:
*** TK

**** Intro

1. GUI toolkit: *TK*
   + Tcl(Tool Command Language)
   + *cross-platform*, portability, flexibility
   + ported to a variety of other scripting languages
     - Perl(Perl/TK)
     - Ruby(Ruby/TK)
     - Python(Tkinter)

2. Python interface: *Tkinter*, short of "Tk interface"
   Python+TK

**** Main steps

1. /import Tkinter/ or /from Tkinter import */
2. Create a top-level *windowing* object
3. Build all your GUI *components* on top of windowing object
4. Connect these GUI components to the underlying application code
5. Enter the main loop
   #+begin_latex
   \begin{minted}{py}
   Tkinter.mainloop()
   \end{minted}
   #+end_latex

**** Intro

1. top-level window object : *root window*
   #+begin_latex
   \begin{minted}{python}
   top = Tkinter.Tk()
   \end{minted}
   #+end_latex

2. *widgets* : standalone or containers

3. *Events* & *Callback* : event-driven processing

4. Geometry managers: Pack & Grid

**** Top-Level Window: Tkinter.Tk()
class
**** Widgets

15 types of widgets

[[/home/ben/Wally/Journal/Figure/scrot/15937ZoG.png]]

**** Default arguments are your friend

These defaults were chosen carefully. They were created with an
optimized set of default arguments as a general rule. Only when you
know how to exactly customize your widgets should you use values other
than the default.

**** hello world
#+begin_latex
\begin{minted}{py}
#!/usr/bin/env python

import Tkinter


top = Tkinter.Tk()
label = Tkinter.Label(top, text="Hello World!")
label.pack()
Tkinter.mainloop()

\end{minted}
#+end_latex
**** hello world button
#+begin_latex
\begin{minted}{py}
#!/usr/bin/env python

import Tkinter

top = Tkinter.Tk()
quit = Tkinter.Button(top, text="Hello World!", command=top.quit)
quit.pack()
Tkinter.mainloop()

\end{minted}
#+end_latex

note: 从Emacs IDE运行程序点击按钮无反应，不知为何。 从命令行启动没有这
个问题。
**** hello world 3
#+begin_latex
\begin{minted}{python}
#!/usr/bin/env python

import Tkinter

top = Tkinter.Tk()

hello = Tkinter.Label(top, text='Hello World!')
hello.pack()

quit = Tkinter.Button(top, text='QUIT', command=top.quit, bg='red', fg='white')
quit.pack(fill=Tkinter.X, expand=1)

Tkinter.mainloop()
\end{minted}
#+end_latex

1. /fill/
2. /expand/

**** hello world scale
#+begin_latex
\begin{minted}{py}
#!/usr/bin/env python

import Tkinter

def resize(ev=None):
    label.config(font='Helvetica -%d bold' % scale.get())

top = Tkinter.Tk()
top.geometry('250x150')

label = Tkinter.Label(top, text='Hello World!',
                      font='Helvetica -12 bold')
label.pack(fill=Tkinter.Y, expand=1)

scale = Tkinter.Scale(top, from_=10, to=40,
                      orient=Tkinter.HORIZONTAL, command=resize)
scale.set(12)
scale.pack(fill=Tkinter.X, expand=1)

quit = Tkinter.Button(top, text='QUIT', command=top.quit,
                      activeforeground='white', activebackground='white')
quit.pack()

Tkinter.mainloop()

\end{minted}
#+end_latex

**** PFA
Partial Funtion Application

PFAs are not limited to just functions. They work with any "callable",
i.e., classes, methods, or callable instances.

GUI programming makes a great use case

#+begin_latex
\begin{minted}{py}
#!/usr/bin/env python

from functools import partial as pto
from Tkinter import Tk, Button, X
from tkMessageBox import showinfo, showwarning, showerror


WARN = 'warn'
CRIT = 'crit'
REGU = 'regu'

SIGNS = {
    'do not enter': CRIT,
    'raidroad crossing': WARN,
    '55\nspeed limit': REGU,
    'wrong way': CRIT,
    'merging traffic': WARN,
    'one way': REGU
}

critCB = lambda: showerror('Error', 'Error Button Pressed')
warnCB = lambda: showwarning('Warning', 'Warning Button Pressed')
infoCB = lambda: showinfo('Info', 'Info Button Pressed')

top = Tk()
top.title('Road Signs')
Button(top, text='QUIT', command=top.quit,
       bg='red', fg='white').pack()
MyButton = pto(Button, top)
CritButton = pto(MyButton, command=critCB, bg='white', fg='red')
WarnButton = pto(MyButton, command=warnCB, bg='goldenrod1')
ReguButton = pto(MyButton, command=infoCB, bg='white')

for eachSign in SIGNS:
    signType = SIGNS[eachSign]
    cmd = '%sButton(text=%r%s).pack(fill=X, expand=True)' % (
        signType.title(), eachSign, '.upper()' if signType == CRIT else '.title()')
    eval(cmd)

top.mainloop()

\end{minted}
#+end_latex

1. partile
2. eval('str')
3. str.title() & upper()
   S.title() -> string
   Return a titlecased version of S, i.e. words start with uppercase
   characters, all remaining cased characters have lowercase.
4. if...else 对应 :?操作符

*** 定义类
#+begin_latex
\begin{minted}{py}
#!/usr/bin/env python

import os
from time import sleep
from Tkinter import *


class DirList(object):
\end{minted}
#+end_latex

*** main
#+begin_latex
\begin{minted}{py}
def main():
    d = DirList(os.curdir)
    mainloop()


if __name__ == '__main__':
    main()
\end{minted}
#+end_latex

*** __init__

**** 声明
#+begin_latex
\begin{minted}{py}
 def __init__(self, initdir=None):
\end{minted}
#+end_latex

**** top
#+begin_latex
\begin{minted}{py}
self.top = Tk()
        self.label = Label(self.top,
                           text='Directory Lister v1.1')
        self.label.pack()
\end{minted}
#+end_latex

**** core attibute StringVar
#+begin_latex
\begin{minted}{py}
 self.cwd = StringVar(self.top)
\end{minted}
#+end_latex
Help on class *StringVar* in module Tkinter:

class StringVar(Variable): Value holder for strings variables.

+ get(self): Return value of variable as string.

+ set(self, value): Set the variable to VALUE.

**** frame listbox
#+begin_latex
\begin{minted}{py}
 self.dirfm = Frame(self.top)
 self.dirsb = Scrollbar(self.dirfm)
 self.dirsb.pack(side=RIGHT, fill=Y)
 self.dirs = Listbox(self.dirfm, height=15,
                     width=50, yscrollcommand=self.dirsb.set)
 self.dirs.bind('<Double-1>', self.setDirAndGo)
 self.dirsb.config(command=self.dirs.yview)
 self.dirs.pack(side=LEFT, fill=BOTH)
 self.dirfm.pack()
\end{minted}
#+end_latex
1. Frame类
2. Listbox类
3. bind方法？？
   绑定事件到方法(evnet handler)
   - 事件：字符串
     - '<Double-1>'
     - '<Return>'
4. config方法？？

**** Entry  文本框
#+begin_latex
\begin{minted}{py}
self.dirn = Entry(self.top, width=50,
                  textvariable=self.cwd)
self.dirn.bind('<Return>', self.doLS)
self.dirn.pack()
\end{minted}
#+end_latex

**** Buttom group
#+begin_latex
\begin{minted}{py}
self.bfm = Frame(self.top)
self.clr = Button(self.bfm, text='Clear',
                  command=self.clrDir,
                  activeforeground='white',
                  activebackground='blue')
self.ls = Button(self.bfm, text='List Directory',
                 command=self.doLS,
                 activeforeground='white',
                 activebackground='green')
self.quit = Button(self.bfm, text='Quit',
                   command=self.top.quit,
                   activeforeground='white',
                   activebackground='red')
self.clr.pack(side=LEFT)
self.ls.pack(side=LEFT)
self.quit.pack(side=LEFT)
self.bfm.pack()
\end{minted}
#+end_latex

**** Method
#+begin_latex
  \begin{minted}{py}
      def doLS(self, ev=None):
          error = ''
          tdir = self.cwd.get()
          if not tdir:
              tdir = os.curdir

          if not os.path.exists(tdir):
              error = tdir + ': no such file'
          elif not os.path.isdir(tdir):
              error = tdir + ': not a directory'

          if error:
              self.cwd.set(error)
              self.top.update()
              sleep(2)
              if not (hasattr(self, 'last') and self.last):
                  self.last = os.curdir
              self.cwd.set(self.last)
              self.dirs.config(selectbackground='LightSkyBlue')
              self.top.update()
              return

          self.cwd.set('FETCHING DIRECTORY CONTENTS...')
          self.top.update()
          dirlist = os.listdir(tdir)
          dirlist.sort()
          os.chdir(tdir)
          self.dir1.config(text=os.getcwd())
          self.dirs.delete(0, END)

          self.dirs.insert(END, os.pardir)
          for eachFile in dirlist:
              self.dirs.insert(END, eachFile)
          self.cwd.set(os.curdir)
          self.dirs.config(selectbackground='LightSkyBlue')

  \end{minted}
#+end_latex

***** os 方法和属性
+ os.curdir
+ os.pardir
+ os.getwd()
+ os.listdir()
+ os.path.exists(s)
+ os.path.isdir(s)

***** Entry方法
+ config
+ insert
+ delete

***** hasattri

** matplotlib                                                   :matplotlib:
*** Reference

+ http://old.sebug.net/paper/books/scipydoc/matplotlib_intro.html
+ http://matplotlib.org/gallery.html

** Email                                                             :email:
clock: [2015-11-22 日 23:59]--[2015-11-23 一 00:40] =>  0:41

*** email
1. module

  #+begin_latex
    \begin{minted}{py}
    import smtplib

    from email import encoders
    from email.header import header
    from email.mime.text import mimetext
    from email.mime.multipart import mimemultipart
    from email.mime.base import mimebase
    from email.utils import parseaddr, formataddr
    \end{minted}
  #+end_latex

2. formataddr
   *formataddr(pair)*
   the inverse of parseaddr(), this takes a 2-tuple of the form
   (realname, email_address) and returns the string value suitable
   for an rfc 2822 from, to or cc header.

   *parseaddr(addr)*

   #+begin_latex
     \begin{minted}{py}
     def _format_addr(s):
         name, addr = parseaddr(s)
         return formataddr((header(name, 'utf-8').encode(), addr))
     \end{minted}
   #+end_latex

3. mimemultipart
   #+begin_latex
     \begin{minted}{py}
     ## 构造邮件对象
     msg = mimemultipart()
     # 发送地址
     msg['from'] = _format_addr("ben<%s>" % from_addr)
     # 接收地址
     msg['to'] = _format_addr('qq<%s>' % to_addr)
     # 主题
     msg['subject'] = header("测试python email", 'utf-8').encode()

     # 正文
     msg.attach(mimetext('hello python', 'plain', 'utf-8'))

     # 附件
     with open('/home/tiger/wally/journal/journal.pdf', 'rb') as f:
         mime = mimebase('pdf', 'pdf', filename='journal.pdf')
         mime.add_header('content-disposition', 'attachment', filename='journal.pdf')
         mime.add_header('content-id', '<0>')
         mime.add_header('x-attachment-id', '0')
         # 把附件的内容读进来:
         mime.set_payload(f.read())
         # 用base64编码:
         encoders.encode_base64(mime)
         # 添加到mimemultipart:
         msg.attach(mime)
     \end{minted}
   #+end_latex

*** smtplib                                                          :smtp:
#+begin_latex
  \begin{minted}{py}
  ## 发送邮件
  # stmp_server = none              ####### todo
  stmp_server = "smtp.163.com"
  port = 25
  server = smtplib.smtp(stmp_server, 25)
  server.set_debuglevel(1)
  server.login(from_addr, passwd)
  server.sendmail(from_addr, [to_addr], msg.as_string())
  \end{minted}
#+end_latex

1. constructor smtp(server, port)
2. smtp::set_debuglevel(1)
3. smtp::login(addr,  passwd)
4. smtp::sendmail(from,  to_list,  *msg.as_string()*)

** args                                                           :argv:sys:

python中的命令行参数
python中有一个模块 *sys* ， *sys.argv* 这个属性提供了对命令行参数的访
问。命令行参数是调用某个程序时除程序名外的其他参数。

- /sys.argv/ 是命令行参数的列表
- /len(sys.argv)/ 是命令行参数的个数

#+BEGIN_SRC python
#! /usr/bin/env python
# -*- encoding:utf-8 -*-

import sys

for arg in sys.argv:
    print arg
#+END_SRC

#+begin_example
  args $ python args.py 1 2 3
  args.py
  1
  2
  3
#+end_example

** datetime                                             :date:time:datetime:

#+begin_example
  >>> dir(datetime)
  ['maxyear', 'minyear', '__doc__', '__file__', '__name__',
  '__package__', 'date', 'datetime', 'datetime_capi', 'time',
  'timedelta', 'tzinfo']

  >>> dir(datetime.datetime)
  ['__add__', '__class__', '__delattr__', '__doc__', '__eq__',
  '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__',
  '__init__', '__le__', '__lt__', '__ne__', '__new__', '__radd__',
  '__reduce__', '__reduce_ex__', '__repr__', '__rsub__', '__setattr__',
  '__sizeof__', '__str__', '__sub__', '__subclasshook__', 'astimezone',
  'combine', 'ctime', 'date', 'day', 'dst', 'fromordinal',
  'fromtimestamp', 'hour', 'isocalendar', 'isoformat', 'isoweekday',
  'max', 'microsecond', 'min', 'minute', 'month', 'now', 'replace',
  'resolution', 'second', 'strftime', 'strptime', 'time', 'timetuple',
  'timetz', 'today', 'toordinal', 'tzinfo', 'tzname',
  'utcfromtimestamp', 'utcnow', 'utcoffset', 'utctimetuple', 'weekday',
  'year']

#+end_example

+ 模块： *datetime*
+ 类： *datetime*
  - strftime
+ 方法: now() 返回datetime对象


#+begin_latex
  \begin{minted}{py}
  import datetime

  now = datetime.datetime.now()
  print now.strftime("%y%m%d")
  \end{minted}
#+end_latex

** termios:Low-level terminal control interface.                   :termios:

This module provides an interface to the POSIX calls for tty I/O
control.

All functions in this module take a *file descriptor fd* as their first
argument. This can be an integer file descriptor, such as returned by
*sys.stdin.fileno()*, or a file object, such as *sys.stdin* itself.

[[/home/ben/Wally/Journal/Figure/scrot/4904FSb.png]]

*** example
#+INCLUDE: ~/Wally/Journal/Project/Python/termios/test.py :src python

输入密码时不可见

** tty:Terminal control functions                                      :tty:

The *tty* module defines functions for putting the tty into cbreak and
raw modes.

1. what is tty?
2. what is cbreak mode?
3. what is raw mode?

+Because it requires the termios module, it will work only on Unix+

[[/home/ben/Wally/Journal/Figure/scrot/4904TrQ.png]]

*** 终端模式                                                         :term:

终端I/O有两种不同的工作方式：
1. 规范方式输入处理。在这种方式中，终端输入以行为单位进行处理。对于每
   个读要求，终端驱动程序最多返回一行。
2. 非规范方式输入处理。输入字符不以行为单位进行装配。

如果不作特殊处理，则默认方式是规范方式。

V7和BSD类的终端驱动程序支持三种终端输入方式：
+ 精细加工方式(输入装配成行，并对特殊字符进行处理)；
+ 原始方式(输入不装配成行，也不对特殊字符进行处理)；
+ cbreak方式(输入不装配成行，但对某些特殊字符进行处理)。

**** reference

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/3300d5e1-d8a3-48df-8ff1-bc4be441f46d?title=%E7%BB%88%E7%AB%AFI%2FO%20termios%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%20tcsetattr%E8%AE%BE%E7%BD%AE%20-%20dartagnan%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD][CNDS: 终端I/O termios属性设置 tcsetattr]]
** select: waiting for I/O completion                               :select:

This module provides access to the *select()* and *poll()* functions
available in most operating systems, epoll() available on Linux 2.5+
and kqueue() available on most BSD. Note that on Windows, it only
works for sockets; on other operating systems, it also works for other
file types (in particular, on Unix.

[[/home/ben/Wally/Journal/Figure/scrot/4904tNF.png]]
*
** os                                                                   :os:
*** os 方法和属性
+ os.curdir

+ os.pardir

+ os.getwd()

+ os.listdir()

  #+begin_latex
    \begin{minted}[frame=leftline, mathescape]{text}
    >>> help(os.listdir)
    Help on built-in function listdir in module posix:

    listdir(...)
        listdir(path) -> list_of_strings

        Return a list containing the names of the entries in the directory.

            path: path of directory to list

        The list is in arbitrary order.  It does not include the special
        entries '.' and '..' even if they are present in the directory.
    \end{minted}
  #+end_latex

+ os.path.exists(s)

+ os.path.isdir(s)

*** file path                                                     :file:os:
#+begin_example
  dir(os.path)
  ['__all__', '__builtins__', '__doc__', '__file__', '__name__',

  '__package__', '_joinrealpath', '_unicode', '_uvarprog', '_varprog',
  'abspath', 'altsep', 'basename', 'commonprefix', 'curdir', 'defpath',
  'devnull', 'dirname', 'exists', 'expanduser', 'expandvars', 'extsep',
  'genericpath', 'getatime', 'getctime', 'getmtime', 'getsize', 'isabs',
  'isdir', 'isfile', 'islink', 'ismount', 'join', 'lexists', 'normcase',
  'normpath', 'os', 'pardir', 'pathsep', 'realpath', 'relpath',
  'samefile', 'sameopenfile', 'samestat', 'sep', 'split', 'splitdrive',
  'splitext', 'stat', 'supports_unicode_filenames', 'sys', 'walk',
  'warnings']

#+end_example

** Numpy                                                             :numpy:
*** DONE Python Numpy入门
- State "DONE"       from "TODO"       [2015-12-02 三 14:25] \\
  不用看得过于细致，用的时候自然知道。
CLOCK: [2015-12-02 三 14:09]--[2015-12-02 三 14:25] =>  0:16
+ http://reverland.org/python/2012/08/22/numpy/
+ 教材

**** 基础

***** 数组属性
NumPy的数组类为 *ndarray*, 对象属性有
+ ndarray.ndim: 数组的秩
+ ndarray.shape： 数组的秩的大小
+ ndarray.size：数组元素的总个数
+ ndarray.dtype：数组元素对象的类型
+ ndarray.itemsize：数组中每个元素的字节大小
+ ndarray.data：包含实际数组的缓冲区

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
  from numpy import *
  a = arange(15).reshape(3,5)
  print a

#+END_SRC

#+RESULTS:
:
: >>> [[ 0  1  2  3  4]
:  [ 5  6  7  8  9]
:  [10 11 12 13 14]]

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
a.shape
#+END_SRC

#+RESULTS:
: (3, 5)

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
a.ndim
#+END_SRC

#+RESULTS:
: 2

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
a.dtype.name
#+END_SRC

#+RESULTS:
: 'int32'

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
a.itemsize
#+END_SRC

#+RESULTS:
: 4

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
type(a)
#+END_SRC

#+RESULTS:
: <type 'numpy.ndarray'>

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
b = array([6, 7, 8])
b
type(b)
#+END_SRC

#+RESULTS:
:
: array([6, 7, 8])
: <type 'numpy.ndarray'>

***** 创建数组
1. 从列表或元组中

   #+BEGIN_SRC python :results output :exports both :session p1411
     from numpy import *

     a = array([2, 3, 4])
     a
     a.dtype

     b = array([1.2, 3.5, 3.1])
     b.dtype
   #+END_SRC

   #+RESULTS:
   :
   : >>> >>> array([2, 3, 4])
   : dtype('int32')
   : >>> >>> dtype('float64')

   #+BEGIN_SRC python :results output :exports both :session p1411
     b  = array([(1.5, 2, 3), (4, 5, 6)] )
     print b
   #+END_SRC

   #+RESULTS:
   :
   : [[ 1.5  2.   3. ]
   :  [ 4.   5.   6. ]]

   显式指定数组数据类型
   #+BEGIN_SRC python :results output :exports both :session p1411
     c = array([[1,2], [3, 4]], dtype=complex)
     print c
   #+END_SRC

   #+RESULTS:
   :
   : [[ 1.+0.j  2.+0.j]
   :  [ 3.+0.j  4.+0.j]]

2. 占位函数
   + zeros，全0
   + ones，全1
   + empty, 随机

   #+BEGIN_SRC python :results output :exports both :session p1417
   from numpy import *

   zeros((3, 4))
   #+END_SRC

   #+RESULTS:
   :
   : >>> array([[ 0.,  0.,  0.,  0.],
   :        [ 0.,  0.,  0.,  0.],
   :        [ 0.,  0.,  0.,  0.]])

   #+BEGIN_SRC python :results output :exports both :session p1417
   ones((2,3,4), dtype=int16)
   #+END_SRC

   #+RESULTS:
   : array([[[1, 1, 1, 1],
   :         [1, 1, 1, 1],
   :         [1, 1, 1, 1]],
   :
   :        [[1, 1, 1, 1],
   :         [1, 1, 1, 1],
   :         [1, 1, 1, 1]]], dtype=int16)

   #+BEGIN_SRC python :results output :exports both :session p1417
   empty((2,3))
   #+END_SRC

   #+RESULTS:
   : array([[ -1.16708973e-041,   7.32845376e+025,   1.71130458e+059],
   :        [  1.79918168e+035,   7.89614618e+150,   3.18291433e-023]])

3. arange 类似 range

** style                                                             :style:
*** [[http://damnever.github.io/2015/04/24/PEP8-style-guide-for-python-code/][Python编程风格]]                                                    :pep:

*** [[https://github.com/onlytiancai/codesnip/blob/master/mypost/How_to_write_high-quality_python_program.md][如何编写高质量的python程序]]

**** 目录

1. 代码规范
2. 空白项目模版
3. 单元测试
4. 文档
5. 打包
6. 小结

**** 代码规范

首先阅读下面的两份规范，并深入理解。

-  [[http://www.python.org/dev/peps/pep-0008/][Python社区官方建议采用的Python编码风格:PEP8]][[http://wiki.woodpecker.org.cn/moin/PythonCodingRule][中文版]]
-  [[http://google-styleguide.googlecode.com/svn/trunk/pyguide.html][Google SoC 建议的 Python 编码风格:Google Python Style Guide]][[http://www.elias.cn/Python/PythonStyleGuide][中文版]]

写出规范的代码是写出高质量代码的第一步，并且有助于培养仔细的习惯。

为了培养规范写代码的习惯，可以安装[[http://pypi.python.org/pypi/flake8/][flake8 ]]这个工具，它不仅可以检查代码
风格是否符合官方建议（PEP8），而且还能找出潜在的隐患（用Pyflakes做语法
分析），更逆天的是还能检测到你有些函数写的太复杂（代码圈复杂度）了，更
更逆天的是可以设置git commit之前必须通过这些检查。

当然具体操作需要根据自己的项目进行一些定制，比如可以忽略E501，W293。

**** 空白项目模版

好的开始是成功的一半，写python代码就从[[https://github.com/onlytiancai/pyempty][pyempty]]开始吧。

在github上看一下那些经典的项目，[[https://github.com/webpy/webpy][web.py]], [[https://github.com/mitsuhiko/flask][flask]], [[https://github.com/jcrocholl/pep8/blob/master/pep8.py][pep8]]， 他们的项目目录都
很规范，综合借鉴了一些项目的特点，我写了这个pyempty项目。

1. *README.md* 这里写你项目的简介，quick

   start等信息，虽然distutils要求这个文件没有后缀名，但github上如果后
   缀是.md的话可以直接转换成html显示。

2. *ChangeLog.txt*

   该文件存放程序各版本的变更信息，也有一定的格式，
   参考 [[https://github.com/webpy/webpy/blob/master/ChangeLog.txt][web.py的ChangeLog.txt]]

3. *LICENES.txt* 这里存放你项目使用的协议，不要编写自己的协议。

4. *requirements.txt*

   如果你的项目需要依赖其它的python第三方库，在这里一行一个写出来，可能pip
   install的时候能自动帮你安装

5. *setup.py* 安装脚本，后面详细介绍

6. *docs*

   里面存放你的项目文档，如概要设计，详细设计，维护文档，pydoc自动生成
   的文档等，强烈推荐大家使用MarkDown格式编写文档

7. *src*

   这个目录里存放项目模块的主要代码，尽量不要把模块目录直接放到根目录，
   模块代码目录可以在setup.py里指定的

8. *tests*

   这个目录存放所有单元测试，性能测试脚本，单元测试的文件确保以test\_
   做前缀，这样distutils会自动打包这些文件，并且用
   =python -m unittest discover -s ./ -p 'test_*.py' -v=
   可以直接执行这些测试

**** 单元测试

Martin Fowler：
/在你不知道如何测试代码之前，就不该编写程序。而一旦你完成了程序，测试
代码也应该完成。除非测试成功，你不能认为你编写出了可以工作的程序。/

我们有很多理由不写单元测试，归根结底是懒，虽然[[http://www.cnblogs.com/onlytiancai/archive/2010/05/26/1744108.html][代码大全上说]]：

大部分研究都发现，检测比测试的成本更小。NASA软件工程实验室的一项研究发
现，阅读代码每小时能够检测出来的缺陷要比测试高出80%左右(Basili and
Selby 1987)。后来，IBM的一项研究又发现，检查发现的一个错误只需要3.5个
工作时，而测试则需要花费15-25个工作时（Kaplan 1995)。

但是单元测试还是让别人相信你的代码有很高质量的最有力证据。

好了，请详细阅读：

1. [[http://woodpecker.org.cn/diveintopython3/unit-testing.html][深入python3.0: 单元测试-2.x也适用]]
2. [[http://docs.python.org/library/unittest.html][Unit testing framework]][[http://www.ibm.com/developerworks/cn/linux/l-pyunit/index.html][不完整中文版]]

**** 文档

敏捷开发不是提倡什么文档也不写，没有文档就没有传承和积累，轮岗或新人接
手任务就会遇到很大的麻烦，所以我决定每个项目最少要写以下文档：

1. *nalysis.model.md*

   概要设计文档，不同于README.md文件，该文档应该写于项目开发之前，把项
   目有哪些功能，大概分几个模块等项目整体概述信息写一下。

2. *design.model.md*

   详细设计文档，不用太详细，至少把项目依赖哪些东西，谁依赖这个项目，
   重要算法流程描述，代码整体结构等写出来。

3. *maintain.md*

   维护文档，这个我觉得最重要，你的服务都记录哪些日志，需要监控哪些业
   务指标，如何重启，有哪些配置项等，没这些东西，你的项目很难运维。

上面这些文档都是项目全局性的文档，不适合写在docstring或注视里，所以要
有单独的文档。

**** 打包

python有专门的模块打包系统[[http://docs.python.org/library/distutils.html][distutils]]， 你可以用这套机制把你的代码打包并
分发到 [[http://pypi.python.org/pypi][Pypi]] 上，这样任何人都可以用 [[http://pypi.python.org/pypi/pip][pip]] 或 [[http://pypi.python.org/pypi/setuptools][easy\_install]] 安装你的模块。

如果你开发的是内部项目，还可以用 [[http://pypi.python.org/pypi/mypypi][mypypi]] 架设私有的pypi，然后把项目的大
的版本更新发布到内部的pypi上，配置管理人员和运维人员可以很方便的从pypi
上拉取代码安装到测试环境或生产环境。

发布大版本的时候要给版本命名及编写ChangeList，可以参考[[https://github.com/chunzi/progit/blob/master/zh/05-distributed-git/01-chapter5.markdown][GitPro的相关章节]],
主要记住以下几个命令。

#+BEGIN_EXAMPLE
    git tag -a v0.1 -m 'my test tag'  #给大版本命名，打Tag
    git describe master #给小版本命名,Git将会返回一个字符串，由三部分组成：最近一次标定的版本号，加上自那次标定之后的提交次数，再加上一段SHA-1值
    git shortlog --no-merges master --not v0.1 #生成版本简报,ChangeList
#+END_EXAMPLE

python有自己的打包机制，所以一般不要用=git archive=命令。

当然大版本管理用pypi管理比较合适，小的bug fix，紧急上线等好多公司都是
用git直接从生产环境拉代码更新，因为git,svn等可以很方便的撤销某次更新，
回滚到某个位置。

如何管理好大版本上线和小的紧急上线，我还没理清思路，欢迎大家参与讨论。

关于打包，请阅读如下链接：

1. [[http://www.ibm.com/developerworks/cn/opensource/os-pythonpackaging/][Python 打包指南]]
2. [[http://woodpecker.org.cn/diveintopython3/packaging.html][深入Python3.0:打包 Python 类库]]
3. [[http://docs.python.org/release/3.1.5/distutils/sourcedist.html#manifest][python打包:分发指定文件]]

**** 小结

以上是最近学到的一些东西的总结，欢迎大家一起讨论。

**** reference

+ https://github.com/onlytiancai/pyempty
+ http://www.cnblogs.com/harrychinese/p/python_project_structure.html

*** DONE [[http://www.crifan.com/try_use_doxygen_to_generate_doc_for_python/][python doxygen]]                                           :doxygen:
- State "DONE"       from ""           [2015-12-07 一 14:00]

**** [[https://blogs.cs.st-andrews.ac.uk/jfdm/][Documenting Python using Doxygen]]
***** type of documents

On and off I have been developing a little Python module to provide
KP-ABE and CP-ABE functionality to developers. _One important aspect
is that of documentation_. Any decent project needs to provide both
User and Developerdocumentation. /User documentation/ is outward facing and tells
users how to use the project, and /Developer documentation/ is inward
facing and tells developers how the project is structured. Developer
documentation is also know as reference documentation. Interestingly,
user documentation can be further divided into two groups: User---for
when the user is just a ‘plain-dumb-user'; and Dev-User---when the
project produces something for use by other developers i.e. an library.
Often Dev-User documentation is just reference documentation. This post
is concerned with reference documentation.

***** documentation tools

For documenting API's and libraries different languages have different
tools:

-  Java has [[http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html][Javadoc]], and [[http://www.stack.nl/~dimitri/doxygen/][Doxygen]]
-  Python has [[http://epydoc.sourceforge.net/][epydoc]], [[https://pypi.python.org/pypi/pydoctor/0.4][pydoctor]], [[http://pydoc.org/][pydoc]], [[http://sphinx-doc.org/][sphinx]], and Doxygen
-  C has ...   [[https://developer.gnome.org/gtk-doc-manual/stable/][gtk-doc]],...,
-  For design there is always plantuml.

***** document format
For user documentation, which is not generally tied to a specific
programming language there are different formats:

-  /LaTeX/
-  Sphinx
-  ASCIIDOC
-  Markdown
-  reST
-  DocBook

For developer facing documentation, one can use a combination of the
above tools. Especially, when producing UML diagrams.

***** 文档化工具中的瑞士军刀( SwissArmy Knife)

When I develop code I try to use doxygen everywhere I go, Doxygen is
/cross language/ and _provides a nice means to produce:
End-User,Developer-User, and Developer documentation_ in HTML, MAN
Pages, LaTeX, RTF, and XML; and across multiple languages(/multi
formats/). This is handed is you are dropping down into C. Moreover,
doxygen has built in support for /LaTeX formula within
documentation/.
Furthermore, recent versions of doxygen
allow for the use of Markdown, and inclusion of Markdown formatted
files. It is essentially the *SwissArmy Knife* of documentation.

***** doxygen for python

However, when developing in Python the preferred documentation tool is
/sphinx/, and relies on /reST/ mark up in python /docstrings/, and other
files to produce both reference documentation, and user documentation. I
find the approach messy, especially reST.

Helaas, Doxygen doesn't want to play nice, and prefers to have its
documentation place in special comment blocks above method definitions
i.e.

#+BEGIN_EXAMPLE
  ##
  # Print message to STDOUT
  # @param msg The message to be printed
  #
  def print_message(msg):
      print(msg);
#+END_EXAMPLE

and not in docstrings. Luckily there is the
[[http://code.foosel.org/doxypy][doxypy]] filter that allows one to tell
doxygen to look in docstrings. Thus, the above snippet can now become:

#+BEGIN_EXAMPLE
    def print_message(msg):
    """ Print message to STDOUT
    @param msg The message to be printed.
    """
        print(msg);
#+END_EXAMPLE

To get python and doxygen working nicely together, aside from the
standard settings, the following configuration settings are also
recommended/required:

****** settings

#+BEGIN_EXAMPLE
    INPUT_FILTER = "python /path/to/doxypy.py"
    FILTER_SOURCE_FILES = YES
    HIDE_UNDOC_RELATIONS = NO
    OPTIMIZE_OUTPUT_JAVA = YES
    JAVADOC_AUTOBRIEF = YES
    MULTILINE_CPP_IS_BRIEF = YES
    DETAILS_AT_TOP = YES
    EXTRACT_ALL = YES
    EXTRACT_STATIC = YES
    SHOW_DIRECTORIES = YES
    SOURCE_BROWSER = YES
    ALPHABETICAL_INDEX = YES
    COLS_IN_ALPHA_INDEX = 8
    TOC_EXPAND = YES
    DISABLE_INDEX = YES
    GENERATE_TREEVIEW = YES
#+END_EXAMPLE

Of note, with the latest version of Doxygen you can reference a markdown
file as the mainpage.

**** [[http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html#pythonblocks][doxygen doc]]

#+BEGIN_SRC python
  ## @package pyexample
  #  Documentation for this module.
  #
  #  More details.

  ## Documentation for a function.
  #
  #  More details.
  def func():
      pass

  ## Documentation for a class.
  #
  #  More details.
  class PyClass:

      ## The constructor.
      def __init__(self):
          self._memVar = 0;

      ## Documentation for a method.
      #  @param self The object pointer.
      def PyMethod(self):
          pass

      ## A class variable.
      classVar = 0;

      ## @var _memVar
      #  a member variable
#+END_SRC

**** [[https://pypi.python.org/pypi/doxypy/0.3][doxypy]]                                                       :doxypy:

*doxypy* is an input /filter/ for Doxygen. It preprocesses python
files so that docstrings of classes and functions are reformatted into
Doxygen-conform documentation blocks.

** Python Project                                                   :project:
* Bash                                                                 :bash:
** Bash基础
*** intro

bash(Bourne Again Shell)是一种 *命令解释器*,同时也是一门 *高级编程语
言*

+ 作为命令解释器,bash通过提示符响应并处理用户在命令行界面上输入的命令.
+ 作为编程语言,bash处理存放在 *shell脚本文件* 中的命令.

*** shell简介                                          :shell:env:terminal:

shell，俗称壳（用来区别于核），是指提供给使用者使用的界面的软件。常见的shell
有ash,bash,ksh,csh,zch。bash是Linux系统默认的shell，一共有40个内部命令。
与Linux内核类似，shell仅提供了用户与计算机交互的指令，而其具体的命令行输入输
出要通过终端（Terminal）完成，在Linux操作系统中，用户可以自定义终端来完成相应
工作。

#+BEGIN_SRC sh
echo $SHELL    # 查看shell类型
#+END_SRC

#+RESULTS:
: /bin/bash

shell的工作方式包括：

+ 命令行工作方式：shell识别并且对用输入的字符串进行响应，通常也称为“交互式工
  作方式”。

+ 编程语言工作方式：shell同样是一种编程语言，可以写成脚本文件。

shell启动时，先读取 */etc/bash.bashrc* 文件对操作系统进行配置，然后读
取 *~/.bashrc* 文件对当前用户配置。

和shell启动相关的文件有：

+ /.bashrc_profile/: 该文件只能被登陆用户对应的shell读取
+ /.bashrc/: 该文件被启动的所有shell读取
+ /.bash_logout/: bash退出是执行该文件

在X Window中运行的终端实际上是一种虚拟终端（哑终端）。

可以通过 _Ctrl+Alt+Fn_ 进入真实终端。

在启动Ubuntu系统时，会启动 *7* 个终端，其中1-6号终端均是直接运行的一个
真实终端， 第7号终端给X Window使用。Alt+F7 从1-6号终端切换到X Window。

Unix shell
+ sh shell: Bourne Shell,旱期的UNIX shell, AT&T贝尔实验室
+ bash shell: 扩展并兼容Bourne Shell
+ dash shell: 体积小,加载和脚本执行速度快于bash
+ Korn shell: 类似bash

*POSIX(Portable Operating System Interface)*,可移植操作系统接口.

*** 初始化文件                                                      :shell:

当启动shell时,它将运行初始化文件初始化自己.

**** 登录shell

登录shell属于交互式shell.首先执行 */etc/profile* 中的命令,然后依次
查找 *~/.bash_profile*, *~/.bash_login*, *~/.profile*,并执行找到的
首个文件的命令.

用户注销时,bash执行 *~/.bash_logout* 中的命令.

**** 交互式登录shell

交互式登录shell执行 *~/.bashrc* 文件中的命令.

**** 非交互式shell

从登录shell继承shell变量. 比如，terminal 中 C-M-t.

**** 句点(.)或source:在当前shell中运行初始化文件                  :source:

*** 符号命令                                                       :symbol:

Bourne Again Shell以使用多种方式使用符号(,),[,]和$

|------+--------------------------|
| ()   | 子shell                  |
| $()  | 命令替换                 |
| (()) | 算术表达式计算,let同义词 |
| [ ]  | test命令                 |
| [[]] | 条件表达式               |
|------+--------------------------|

*** shell脚本

shell脚本是包含可执行shell命令的文件.除了使用用户在命令行下的命令
外,shell脚本还可以使用控制流命令(控制结构).shell一条接着一条解释并执行
shell脚本中的命令.

*** 通配符

Shell和用户交互是以字符串形式存在的命令和命令输出反馈的方式进行的，在Linux命
令行中输入的第一个字符串必须是一个命令的名字，第二个字符串是命令的选项或参数。
命令行的每个字符串必须由空格或TAB分开。

$ CMD OPTION ARG

shell的通配符用于模式匹配，如文件名匹配，路径名搜索和字符串查找等。常用的通配
符包括：

- * 匹配任意长度的字符串，但文件名中的圆点(.)和路径名中的斜线(/)必须是
  显式的，  即不能用通配符替代它们。

- ? 匹配一个字符

- [] 指定字符范围，字符范围可以由字符串构成，也可以由表示限定范围的起
  始字符、终止字符及中间连字符(-)组成。

  - 中间连字符(-)仅在方括号中有效

  - _* 和 ? 在方括号内失去通配功能_

*** shell 中的引号

1) /单引号/ ： 由单引号括起的字符均当作普通字符使用

   eg.   $ echo '$PATH'    # 输出$PATH字符串，而不是变量PATH的值

2) /双引号：/ 双引号的作用与单引号类似，区别在于它没有那么严格。单引号告
   诉shell

   忽略所有的特殊字符，而双引号只要求忽略大多数字符，不会忽略双引号中3种特殊字
   符： /$, \ 和 `(反引号)/

   eg.
   #+BEGIN_SRC sh
     x=*    # 定义变量x
     echo $*    # 显示x的值，即*通配的当前目录下的所有文件名
     echo '$x'  # 返回单引号中字符串内容，不加任何解释，即$x
     echo "$x"  # 对变量名进行替换，但不会解释替换的内容即*
   #+END_SRC

   Shell赋值的先后顺序：shell先进行变量替换，再进行文件名（通配符）替换，最后将
   这些替换值作为参数传递给命令。

3) /反引号/: 反引号（`）对应的键通常位于键盘的左上角。反引号括起来的字串会被当作
   shell命令行进行解释，并以解释的标准输出结果代替整个反引号
   eg.   $ ehco `pwd`
   反引号可以嵌套使用，但嵌套时内层的反引号必须使用\进行转义。

shell以#开始注释

*** separating and grouping cmds

- ; and LF separate cmds
- \ continues a cmd
- | pipe cmds
- & execute cmd background
- () group commands

*** manipulate the directory stack                               :dirs:file:

1. /dirs/    # display the *dir stack*

2. /pushd/

   #+BEGIN_SRC sh
     pushd path/to/new/dir     # add new to stack
     pushd                     # swap top with the 2ed dir, and cd that
     pushd +n                  # swap top with the (n-1)th dir, and cd that
   #+END_SRC

3. /popd/

   #+BEGIN_SRC sh
     popd                            # remove the top from the stack
     popd +n                         # remove the (n-1)th from the stack
   #+END_SRC

*** declare 限定属性                                                :declare:

*declare* 或typeset内建命令(它们是完全相同的)可以用来 *限定变量的属性*

这是在某些编程语言中使用的定义类型不严格的方式。命令declare是bash版本2
之后才有的。

1. -r 只读(类似C常量)
2. -i 整型
3. -f 函数
4. -a 数组

**** 参考

+
  [[https://app.yinxiang.com/shard/s52/nl/11551545/b034cc4d-6ffe-4915-b86b-59266c88898d?title=linux%20bash%20shell%E4%B9%8Bdeclare%20-%20fhefh%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD][bash:declare]]
*** 特殊符号                                                   :symbol:env:

- \   命令续行
- #!  指定 shell
- $0  当前脚本的文件名
- $n  传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。
- $#  传递给脚本或函数的参数个数。
- $*  传递给脚本或函数的所有参数。
- $@  传递给脚本或函数的所有参数。
- $?  上个命令的退出状态，或函数的返回值。
- $$  当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。

**** [[http://c.biancheng.net/cpp/view/2739.html][$* 和 $@ 的区别]]

$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(" ")包含时，都以
"$1" "$2" … "$n" 的形式输出所有参数。

当它们被双引号(" ")包含时，
- _$* 会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数_
- _$@ 会将各个参数分开，以"$1" "$2" … "$n" 的形式输出所有参数_

** 输入输出
*** read                                                               :read:

**** reference

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/88a056bd-f935-41c5-8d72-b6e324579744?title=bash之read命令 - xiangzi888 - 博客园][EN::bash read]]

**** read

read命令接收标准输入(键盘)的输入，或者其它文件描述符的输入。
得到输入后，read命令将数据放在一个标准变量中。

**** 基本读取

#+BEGIN_SRC sh
#!/bin/sh
echo -n "Enter your name: "
read name
echo "hello $name"
exit 0
#+END_SRC

**** -p 提示

#+BEGIN_SRC sh
read -p "Enter your name: " name
#+END_SRC

#+RESULTS: read_with_promopt

**** 多个变量

READ后面可以有多个变量。

**** 不指定变量

放置在环境变量 /REPLY/ 中（小写不行）

#+BEGIN_SRC sh
#!/bin/sh

read -p "Enter your name: "
echo $REPLY
#+END_SRC

**** -t 计时输入

脚本可能会停下来一直等待用户输入。
-t <n>  # 指定秒数
当计时满时， read命令返回非零值(零值为正常退出)

#+BEGIN_SRC sh
#!/bin/sh
if read -t 5 -p "Please enter your name:" name
then
    echo "Hello $name"
else
    echo "Sorry, too slow"
fi
exit 0
#+END_SRC

**** -n<N> 设置输入字符个数


#+BEGIN_SRC sh
#!/bin/bash

read -n1 -p "Do you want to continue[Y/N]?" answer
case $answer in
    Y|y)
	echo "fine, contine";;
    N|n)
	echo "ok, goodbye";;
    *)
	echo "error choice"
esac
exit 0
#+END_SRC

**** -s 默读，即不显示

#+BEGIN_SRC sh
  #!/bin/bash

  read -s -p "Enter your passwd: " pass
  echo "your password is $pass"
  exit 0
#+END_SRC

**** 读取文件

每次调用调用read命令都会读取文件中折一行文本。

当文件没有可读的行时，read命令将以非零状态退出。

/最常用的方法是对文件使用cat命令并通过管道将结果直接传送给包含read命令的while命令/

#+BEGIN_SRC sh
  #!/bin/sh

  touch temp
  declare -i count=5
  while [ $count -gt 0 ]
  do
      echo $count >> temp
      count=$(($count-1))
  done

  cat temp | while read line
             do
                 echo "$count: $line"
                 count=$(($count+1))
             done
  exit 0
#+END_SRC

** Debug
*** 专用调试器 *bashdb*                                             :debug:
+ homepage: http://bashdb.sourceforge.net/


the bash debugger project is a source-code debugger for bash that
follows the gdb command syntax.

1. name
   + bashdb - bash debugger script

2. synopsis
   + bashdb [options] [--] script-name [script options]
   + bashdb [options] -c execution-string
   + bash --debugger [bash-options...] script-name [script options]

3. install
   1) apt
      #+begin_src sh :exports both
      apt-cache search bashdb
      #+end_src

      #+results:
      : bashdb - bash debugger

   2) sourcecode
      + https://sourceforge.net/projects/bashdb/files/bashdb/

*** 调试
**** -x 选项

可以让bash打印出你脚本执行的过程中的所有语句

#+header: :exports code
#+header: :tangle /tmp/bash_debug.sh
#+BEGIN_SRC sh
  #!/bin/bash
  echo "Hello $USER"
  echo "Today is $(date +'%Y-%m-%d')"
#+END_SRC

#+BEGIN_SRC sh :exports code :results output
bash -x /tmp/bash_debug.sh
#+END_SRC

#+BEGIN_EXAMPLE
  + echo 'Hello ben'
  Hello ben
  ++ date +%Y-%m-%d
  + echo 'Today is 2015-04-30'
  Today is 2015-04-30
#+END_EXAMPLE

**** 显示行号
修改变量： *PS4*
#+BEGIN_SRC sh exports code
export PS4='+${BASH_SOURCE}:${LINENO}:${FUNCNAME[0]}: '
bash -x /tmp/bash_debug.sh
#+END_SRC

#+BEGIN_EXAMPLE
+/tmp/bash_debug.sh:3:main: echo 'Hello ben'
Hello ben
++/tmp/bash_debug.sh:4:main: date +%Y-%m-%d
+/tmp/bash_debug.sh:4:main: echo 'Today is 2015-04-30'
Today is 2015-04-30
#+END_EXAMPLE

**** 调试部分脚本
+ 开始： set -x
+ 结束： set +x

#+BEGIN_SRC sh :tangle /tmp/bash_debug.sh
  #!/bin/bash
  echo "helle ${USER}"
  set -x
  echo "Today is $(date +%Y-%m-%d)"
  set +x
#+END_SRC

#+BEGIN_EXAMPLE
  bash /tmp/bash_setup.sh

  helle ben
  ++/tmp/bash_debug.sh:5:main: date +%Y-%m-%d
  +/tmp/bash_debug.sh:5:main: echo 'Today is 2015-04-30'
  Today is 2015-04-30
  +/tmp/bash_debug.sh:6:main: set +x
#+END_EXAMPLE

** 结构语句
*** if-else                                                            :if:

if/else是通过判断选择执行或者执行部分代码，可以根据变量、文件名、命令
是否执行成功等很多条件进行判断，他的格式如下：

#+BEGIN_EXAMPLE
  if condition
  then
      statements
  [elif condition
      then statements. ..]
  [else
      statements ]
  fi
#+END_EXAMPLE

和C程序不一样， _bash的判断不是通过boolean，而是通过statement，也就是
执行命令后的最终状态（exit status）_ 。所有的Linux命令，无论你是代码是C还
是脚本，执行完，都返回一个整数通知他的调用这，这就是exit status，通常0
表示OK，其他（1-255）表示错误。这只是通常的情况，例如diff，0表示你no
difference，1表示difference，2表示错误。if判断statements的最后一个的
exit status，通常我们只放一个statement，如果为0，表示true，否则表示
false。

执行下一条命令会冲掉原来exit status。可以使用$?来查看上一命令执行的结
果。

**** reference

- http://blog.csdn.net/flowingflying/article/details/5069646

*** case语句                                                           :case:

bash 中的 switch-case 语句。

**** 语法

#+BEGIN_SRC sh
  case EXPRESSION in
  CASE1) COMMAND-LIST;;
  CASE2) COMMAND-LIST;;
  ...
  CASEN) COMMAND-LIST;;
  esac
#+END_SRC

- 每个分支是一个符合 /pattern/ 的表达式。
- 在 COMMAND-LIST 中首先符合的的命令就执行。
- /“|”/ 符号用来分割多个pattern，
- /“)”/ 操作符中断一个pattern。
- 每个分支加上他们的后继命令称作一个 子句 。每个 子句 必须以 /“;;”/ 结尾。
- 每个 case 语句以 /esac/ 语句结束。


**** 例子

#+BEGIN_SRC sh
  #!/bin/bash

  # This script does a very simple test for checking disk space.

  space=`df -h | awk '{print $5}' | grep % | grep -v Use | sort -n | tail -1 | cut -d "%" -f1 -`

  case $space in
  [1-6]*)
    Message="All is quiet."
    ;;
  [7-8]*)
    Message="Start thinking about cleaning out some stuff.  There's a partition that is $space % full."
    ;;
  9[1-8])
    Message="Better hurry with that new disk...  One partition is $space % full."
    ;;
  99)
    Message="I'm drowning here!  There's a partition at $space %!"
    ;;
  ,,*)
    Message="I seem to be running with an nonexitent amount of disk space..."
    ;;
  esac

  echo $Message | mail -s "disk report `date`" anny
#+END_SRC


- 初始脚本通常利用 case 语句来启动，停止和查询系统服务

** 字符串
*** 取长度

#+BEGIN_SRC sh
  str="abcd"
  expr length $str   # method 1
  echo ${#str}       # method 2
  expr "$str" : ".*" # method 3
#+END_SRC

#+RESULTS:
| 4 |
| 4 |
| 4 |

好像一般使用第二种

*** 子串长度

#+BEGIN_SRC sh
  str="abc"
  expr index $str "a"  # 1
  expr index $str "b"  # 2
  expr index $str "x"  # 0
  expr index $str ""   # 0
#+END_SRC

#+RESULTS:

*** 选取子串

#+BEGIN_SRC sh :exports code
  str="abcdef"
  expr substr "$str" 1 3  # 从第一个位置开始取3个字符， abc
  expr substr "$str" 2 5  # 从第二个位置开始取5个字符， bcdef
  expr substr "$str" 4 5  # 从第四个位置开始取5个字符， def

  echo ${str:2}           # 从第二个位置开始提取字符串， bcdef
  echo ${str:2:3}         # 从第二个位置开始提取3个字符, bcd
  echo ${str:(-6):5}        # 从倒数第二个位置向左提取字符串, abcde
  echo ${str:(-4):3}      # 从倒数第二个位置向左提取6个字符, cde
#+END_SRC

#+RESULTS:
| abc   |
| bcdef |
| def   |
| cdef  |
| cde   |
| abcde |
| cde   |

*** 截取/删除子串

#+BEGIN_SRC sh :exports code
  str="abbc,def,ghi,abcjkl"
  echo ${str#a*c}     # 输出,def,ghi,abcjkl  一个井号(#) 表示从左边截取掉最短的匹配 (这里把abbc字串去掉）
  echo ${str##a*c}    # 输出jkl，             两个井号(##) 表示从左边截取掉最长的匹配 (这里把abbc,def,ghi,abc字串去掉)
  echo ${str#"a*c"}   # 输出abbc,def,ghi,abcjkl 因为str中没有"a*c"子串
  echo ${str##"a*c"}  # 输出abbc,def,ghi,abcjkl 同理
  echo ${str#*a*c*}   # 空
  echo ${str##*a*c*}  # 空
  echo ${str#d*f)     # 输出abbc,def,ghi,abcjkl,
  echo ${str#*d*f}    # 输出,ghi,abcjkl

  echo ${str%a*l}     # abbc,def,ghi  一个百分号(%)表示从右边截取最短的匹配
  echo ${str%%b*l}    # a             两个百分号表示(%%)表示从右边截取最长的匹配
  echo ${str%a*c}     # abbc,def,ghi,abcjkl
#+END_SRC

可以这样记忆, 井号（#）通常用于表示一个数字，它是放在前面的；百分
号（%）卸载数字的后面; 或者这样记忆，在键盘布局中，井号(#)总是位于
百分号（%）的左边(即前面)    :-)

*** 串匹配与替换

#+BEGIN_SRC sh :exports code
  str="apple, tree, apple tree"
  echo ${str/apple/APPLE}   # 替换第一次出现的apple
  echo ${str//apple/APPLE}  # 替换所有apple

  echo ${str/#apple/APPLE}  # 如果字符串str以apple开头，则用APPLE替换它
  echo ${str/%apple/APPLE}  # 如果字符串str以apple结尾，则用APPLE替换它
#+END_SRC

*** 比较

#+BEGIN_SRC sh :exports code
  [[ "a.txt" == a* ]]        # 逻辑真 (pattern matching)
  [[ "a.txt" =~ .*\.txt ]]   # 逻辑真 (regex matching)
  [[ "abc" == "abc" ]]       # 逻辑真 (string comparision)
  [[ "11" < "2" ]]           # 逻辑真 (string comparision), 按ascii值比较
#+END_SRC

*** 连接

#+BEGIN_SRC sh :exports code
  s1="hello"
  s2="world"
  echo ${s1}${s2}   # 当然这样写 $s1$s2 也行，但最好加上大括号
#+END_SRC

*** 命令行环境变量
+ http://www.blogbus.com/fbirdzp-logs/37423250.html
+ http://m.blog.csdn.net/blog/u012485637/43668549

通过设置环境变量PS1、PS2、PS3以及PS4来自定义用户命令行的字符显示。如果
要长期永久性修改提示符，可以将修改提示符的命令添加到$HOME/.profile或
$HOME/.bash_profile 或 ￥HOME/.bashrc文件中。

default value:
+ $PS1: =\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$=
+ $PS2: =>=
+ $PS3: None
+ $PS4: =+=

**** PS1 默认提示符
+
  http://www.linuxnix.com/2013/04/linuxunix-shell-ps1-prompt-explained-in-detail.html

可以通过修改Linux下的默认提示符，使其更加实用。
+ =\u=: 用户名
+ =\h=: 主机名
+ =\w=: 当前目录的完整路径
  - 主目录下的时候，只会显示～
+ 在PS1值之后有一个空格。从个人角度来讲，使用这个空格可以增加一定的可
  读性。

+ =\d= – the date in "Weekday Month Date" format (e.g., "Tue May 26")
+ =\e= – an ASCII escape character (033)
+ =\h= – the hostname up to the first .
+ =\H= – the full hostname
+ =\j= – the number of jobs currently run in background
+ =\l= – the basename of the shells terminal device name
+ =\n= – newline
+ =\r= – carriage return
+ =\s= – the name of the shell, the basename of $0 (the portion following the final slash)
+ =\t= – the current time in 24-hour HH:MM:SS format
+ =\T= – the current time in 12-hour HH:MM:SS format
+ =\@= – the current time in 12-hour am/pm format
+ =\A= – the current time in 24-hour HH:MM format
+ =\u= – the username of the current user
+ =\v= – the version of bash (e.g., 4.00)
+ =\V= – the release of bash, version + patch level (e.g., 4.00.0)
+ =\w= – Complete path of current working directory
+ =\W= – the basename of the current working directory
+ =\!= – the history number of this command
+ =\#= – the command number of this command
+ =\$= – if the effective UID is 0, a #, otherwise a $
+ =\nnn= – the character corresponding to the octal number nnn
+ =\\= – a backslash
+ =\[= – begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
+ =\]= – end a sequence of non-printing characters

我的配置：
#+BEGIN_EXAMPLE
export PS1="\W$ "
#+END_EXAMPLE

**** PS2 副提示符变量
一个非常长的命令可以通过在末尾加"=\="使其分行显示。多行命令的默认提示
符是">"。

**** PS3 定制shell脚本的select提示
**** PS4 定制调试模式的提示符
+ $0 显示当前的脚本名
+ $LINENO 显示的当前的行号

** 文件目录                                                            :file:
*** reference

- [[read -r line < file][EN::Bash One-Liners Explained（一）：文件处理]]

*** 清空文件内容

#+BEGIN_SRC sh
> file
#+END_SRC

这一行命令用到了输出重定向操作符>。输出重定向发生时，文件会被打开准备
写入。如果此时文件不存在则先创建，存在则将其大小截取为0。这里我们并没
有重定向写任何内容到文件中，所以文件依然保持为空。

如果你想替换文件的内容，或者创建一个包含指定内容的文件，可以运行下面的
命令：

#+BEGIN_SRC sh
echo "some string" > file
#+END_SRC

*** 追加内容到文件

#+BEGIN_SRC sh
echo "foo bar baz" >> file
#+END_SRC

这一行命令用到了另外一个输出重定向操作符>>，该操作符将内容追加到文件
。同样地，如果文件不存在则先创建它。追加的内容之后，紧跟着换行符。如
果你不想要追加换行符，在执行echo命令时可以指定-n选项：

#+BEGIN_SRC sh
echo -n "foo bar baz" >> file
#+END_SRC

*** 读取文件的首行并赋值给变量

#+BEGIN_SRC sh
read -r line < file
#+END_SRC

这一行命令用到了 Bash 的内置命令read，和输入重定向操作符<。read命令
从标准输入中读取一行，并将内容保存到变量line中。在这里，-r选项保证读
入的内容是原始的内容，意味着反斜杠转义的行为不会发生。输入重定向操作
符< file打开并读取文件file，然后将它作为read命令的标准输入。

记住， _read 命令会删除包含在 /IFS/ 变量中出现的所有字符_

*IFS* 的全称是Internal Field Separator，Bash 根据 IFS 中定义的字符来分
隔单词。

在这里，read命令读入的行被分隔成多个单词。默认情况下，IFS包含空格，制表
符和回车，这意味着开头和结尾的空格和制表符都会被删除。如果你想保留这
些符号，可以通过设置IFS为空来完成：

#+BEGIN_SRC sh
IFS=
read -r line < file
#+END_SRC

IFS 的变化仅会影响当前的命令，这行命令可以保证读入原始的首行内容到变
量line中，同时行首与行尾的空白字符被保留。

另外一种读取文件首行内容，并赋值给变量的方法是:

#+BEGIN_SRC sh
line=$(head -1 file)
#+END_SRC

这里用到了命令替换操作符 $(...)，它运行括号里的命令并且将输出返回。这
个例子中，命令是head -1 file，输出的内容是文件的首行。输入然后通过等
号赋值给变量line。$(...)的等价写法是`...`，所以也可以换成下面这样：

#+BEGIN_SRC sh
line=`head -1 file`
#+END_SRC

不过，在 Bash 中$(...)用法更加推荐，因为它看起来更加整洁，并且容易嵌
套使用。

*** 依次读入文件每一行

#+BEGIN_SRC sh
while read -r line; do
    # do something with $line
done < file
#+END_SRC

这是一种正确的读取文件内容的做法，read命令放在while循环中。当read命
令遇到文件结尾时（EOF），它会返回一个正值，导致循环判断失败终止。

记住，read命令会删除首尾多余的空白字符，所以如果你想保留，请设置 IFS
为空值:

#+BEGIN_SRC sh
while IFS= read -r line; do
    # do something with $line
done < file
#+END_SRC

如果你不想将 "< file" 放在最后，可以通过管道将文件的内容输入到 while
循环中：

#+BEGIN_SRC sh
cat file | while IFS= read -r line; do
    # do something with $line
done
#+END_SRC

*** 随机读取一行并赋值给变量


#+BEGIN_SRC sh
read -r random_line < <(shuf file)
#+END_SRC

Bash 中并没有提供一种直接的方法来随机读取文件的某一行内容，所以这里
需要利用外部程序。在最新的一些 Linux 系统上，GNU Coreutils 包中提供
的 /shuf/ 命令可以满足我们的需求。

这一行命令中用到了进程替换（process substitution）操作符<(...)。进程
替换操作会创建一个匿名的管道文件，并将进程命令的标准输出连接到管道的
写一端。然后 Bash 开始执行进程替换中的命令，然后将整个进程替换的表达
式替换成匿名管道的文件名。

当 Bash 看到<(shuf file)时，它首先打开一个特殊的文件/dev/fd/n，这里
的n是一个空闲的文件描述符，然后执行shuf file命令，将标准输出连接到/
dev/fd/n，并且替换<(shuf file) 为/dev/fd/n，因此实际的命令会变成:


#+BEGIN_SRC sh
read -r random_line < /dev/fd/n
#+END_SRC

结果会读取洗牌后的文件的第一行内容。

另外一种做法是，使用 GNU sort 命令，它提供的-R选项可以随机排序文件：

#+BEGIN_SRC sh
read -r random_line < <(sort -R file
#+END_SRC

或者，同前面一样，将结果赋值给变量：

#+BEGIN_EXAMPLE
$ random_line=$(sort -R file | head -1)
#+END_EXAMPLE

这里，我们首先通过sort -R随机排序文件，然后通过head -1 读取文件的第
一行。

*** 保存文件的大小到变量

#+BEGIN_SRC sh
size=$(wc -c < file)
#+END_SRC

这一行命令中用到了第3点中介绍的命令替换操作$(...)，它运行里面的命令
并将结果获取回来。在这个例子中，命令是wc -c < file，它输出文件的字节
数。这个结果最终会赋值给变量size。

*** 从文件路径中获取文件名

假设，你有一个文件，它的路径为/path/to/file.ext，然后你要从中获取文
件名，在这里是file.ext。你要怎么做？一个好的方法是通过参数展开（
parameter expansion）功能：

#+BEGIN_SRC sh
filename=${path##*/}
#+END_SRC

这一行命令使用了参数展开的语法：${var##pattern} ，它从$var字符串开始
处开始匹配pattern。如果能够匹配成功，将最长匹配的内容删除后再返回。

在这个例子中，匹配的模式是*/，它尝试匹配/path/to/file.ext的开始部分
，正如前面所说，这里是贪婪匹配，所以它能够匹配到最后一个斜杠为止，即
匹配的内容是/path/to/。所以当把匹配的内容删除后，返回的内容就是文件
名file.ext。

*** 从文件路径中获取目录名

和上面一样类似，这次你要从路径/path/to/file.txt中获取目录名/path/to
。你可以继续通过参数展开功能来完成这个任务：

#+BEGIN_SRC
dirname=${path%/*}
#+END_SRC

这次的用法是${var%pattern}，它从$var的结尾处匹配/*。如果能够成功匹配
，将最短匹配的内容删除再返回。

在这个例子中，匹配的模式是/*，它能够匹配/file.ext部分，删除这部分内
容后返回的就是目录名称。

*** 快速拷贝文件

假设你要将文件/path/to/fil拷贝到/path/to/file_copy，一般情况下，大多
数人会这么来写：

#+BEGIN_SRC sh
cp /path/to/file /path/to/file_copy
#+END_SRC


不过，你可以利用括号展开（brace expansion）{...}功能:

#+BEGIN_SRC sh
cp /path/to/file{,_copy}
#+END_SRC


括号展开可以生成任意字符串的组合，在这个例子中，/path/to/file
{,_copy}最终生成/path/to/file /path/to/file_copy。所以上面这行命令最
终发型成: cp /path/to/file /path/to/file_copy

类似地，你可以执行下面的命令快速的移动文件：

#+BEGIN_SRC sh
mv /path/to/file{,_old}
#+END_SRC

这行命令展开后就变成了： mv /path/to/file /path/to/file_old

** 逻辑运算                                                          :logic:
*** 逻辑运算符
**** 文件与目录

+ -f  『文件』是否存在
+ -d  『目录』是否存在
+ -b  是否为一个『 block 文件』
+ -c  是否为一个『 character 文件』
+ -S  是否为一个『 socket 标签文件』
+ -L  是否为一个『 symbolic link 的文件』
+ -e  『某个东西』是否存在

**** 程序

+ -G  判断是否由 GID 所执行的程序所拥有
+ -O  判断是否由 UID 所执行的程序所拥有
+ -p  判断是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！）

**** 文件属性

+ -r  判断是否为可读的属性
+ -w  判断是否为可以写入的属性
+ -x  判断是否为可执行的属性
+ -s  判断是否为『非空白文件』
+ -u  判断是否具有『 SUID 』的属性
+ -g  判断是否具有『 SGID 』的属性
+ -k  判断是否具有『 sticky bit 』的属性

**** 两个文件之间的判断与比较

+ -nt  第一个文件比第二个文件新
+ -ot  第一个文件比第二个文件旧
+ -ef  第一个文件与第二个文件为同一个文件（ link 之类的文件）

**** 逻辑的『和(and)』『或(or)』

+ &&  逻辑的 AND 的意思
+ ||  逻辑的 OR 的意思

**** 比较

+ =  等于应用于：整型或字符串比较如果在[] 中，只能是字符串
+ !=  不等于应用于：整型或字符串比较如果在[] 中，只能是字符串
+ <  小于应用于：整型比较在[] 中，不能使用表示字符串
+ >  大于应用于：整型比较在[] 中，不能使用表示字符串
+ -eq  等于应用于：整型比较
+ -ne  不等于应用于：整型比较
+ -lt  小于应用于：整型比较
+ -gt  大于应用于：整型比较
+ -le  小于或等于应用于：整型比较
+ -ge  大于或等于应用于：整型比较
+ -a  双方都成立（and）逻辑表达式 –a 逻辑表达式
+ -o  单方成立（or）逻辑表达式 –o 逻辑表达式
+ -z  空字符串
+ -n  非空字符串

*** 逻辑表达式
**** test

+ 格式： test EXPRESSTION
+ 注：所有字符与逻辑运算符直接使用空格分开，不能连到一起

**** []表达式

- 格式： [ EXPRESSION ]

- _方括号开之后的空格和闭之前的空格是必须有_

- 常见的 >, < 需要加转义字符，表示字符串大小比较，以acill码位置作为比
  较。不直接支持 < >运算符

- 逻辑运算符 || && 它需要用 -a[and] –o[or]表示

**** [[]]表达式

[[]] 运算符只是[]运算符的扩充。能够支持<,>符号运算不需要转义符，它还是

以字符串比较大小。里面支持逻辑运算符：|| &&

*** 逻辑运算

+ &&  与
+ ||  或
+ ！  非

*** 算术运算比较运算符

bash自身不能比较浮点数

1. *-eq*: 等于

   #+BEGIN_SRC sh
     m=1; n=1;
     if [ $m -eq $n ]
        then
            echo $m equals $n
     else
         echo $m not equals $n
     fi
   #+END_SRC

   #+RESULTS:
   : 1 equals 1


   #+BEGIN_SRC sh
     declare -i m=1
     declare -i n=1

     if [ $m -eq $n ]
        then
            echo "${m} equals ${n}"
     else
         echo $m not equals $n
     fi
   #+END_SRC

   #+RESULTS:
   : 1 equals 1

2. *-ne*: 不等于

   #+BEGIN_SRC sh
   [ 100   -ne $num1 ]
   #+END_SRC

3. *-lt*: 小于

   #+BEGIN_SRC sh
   [ 100   -lt `expr $num1 + $num2` ]
   #+END_SRC

4. *-le*: 小于或等于

   #+BEGIN_SRC sh
   [ 100   -le `expr $num1 \* $num2` ]
   #+END_SRC

5. *-gt*: 大于

   #+BEGIN_SRC sh
   [ 100   -gt `expr $num1 / $num2` ]
   #+END_SRC

6. *-ge*: 大于或等于

   #+BEGIN_SRC sh
   [ 100   -ge `expr $num1 % $num2` ]
   #+END_SRC

*** 字符串比较                                                     :string:

1. *-z string*

   如果 string 长度为零，则为真

   #+BEGIN_SRC sh
   [ -z "`ps aux | grep mysql`" ]
   #+END_SRC

2. *-n string*

   如果 string 长度非零，则为真

   #+BEGIN_SRC sh
   [ -n "$string" ]
   #+END_SRC

   注: $string 一定要放在双引号里面 "$string"，否则使用 -n -z 的结果都
   为真！

3. *string1 != string2*

   如果 string1 与 string2 不同，则为真

   #+BEGIN_SRC sh
   [ "$str1" != "Snail" ]
   #+END_SRC

4. *string1 == string2*

   如果 string1 与 string2 相同，则为真

   #+BEGIN_SRC sh
   [ "$str1" == "$str2" ]
   #+END_SRC

   注：使用 "=" 也可以，在严格的 POSIX 兼容下使用

5. *string1  string2* (?)

   如果 string1 按字典顺序比较大于 string2，则为真

*** 文件比较                                                         :file:

1. *-a filename*

   如果 filename 存在，则为真

   #+BEGIN_SRC sh
   [ -e $HOME/.bashrc ]
   #+END_SRC

2. *-e filename*

   同上

3. *-b filename*

   如果 filename 存在，并且是块文件，则为真

   #+BEGIN_SRC sh
   [ -e /dev/loop0 ]
   #+END_SRC

4. *-c filename*

   如果 filename 存在，并且是字符文件，则为真
   #+BEGIN_EXAMPLE
     [ -e /dev/ttyS0 ]
   #+END_EXAMPLE

5. *-d filename*

   如果 filename 存在，并且为目录，则为真

   #+BEGIN_SRC sh
     [ -d /home/snail ]
   #+END_SRC

6. *-f filename*

   如果 filename 存在，并且为常规文件，则为真

   #+BEGIN_SRC sh
     [ -f /dev/ttyS0 ]
   #+END_SRC

7. *-g filename*

   如果 filename 存在，并且为set-group-id，为真

   #+BEGIN_SRC sh
     [ -f $HOME/ak47 ]
   #+END_SRC

8. *-h filename*

   如果 filename 存在，并且为符号连接，则为真

   #+BEGIN_SRC sh
     [ -h /bin/vi ]
   #+END_SRC

9. *-L filename*

   同上

10. *-k filename*

    如果 filename 存在，并且设置了sticky位，为真

    #+BEGIN_SRC sh
      [ -k /bin/ping ]
    #+END_SRC

11. *-p filename*

    如果 filename 存在，并且为有名管道(FIFO)，真

    #+BEGIN_SRC sh
      [ -p /tmp/pipe ]
    #+END_SRC

12. *-r filename*

    如果 filename 存在，并且可读，则为真

    #+BEGIN_SRC sh
      [ -r /etc/passwd ]
    #+END_SRC

13. *-s filename*

    如果 filename 存在，并且大小不为零，为真

    #+BEGIN_SRC sh
      [ -s ./none-zero ]

    #+END_SRC

14. *-u filename*

    如果 filename 存在，并且为set-user-id，为真

    #+BEGIN_SRC sh
      [ -f $HOME/ak47 ]
    #+END_SRC

15. *-w filename*

    如果 filename 存在，并且可写，则为真

    #+BEGIN_SRC sh
      [ -w /var/log/mail ]
    #+END_SRC

16. *-x filename*

    如果 filename 存在，并且可执行，则为真
    #+BEGIN_EXAMPLE
      [ -x ./start.sh ]
    #+END_EXAMPLE

17. -t fd

    如果文件描述符被打开并指向一个终端，则为真

    #+BEGIN_SRC sh
      [ -t /proc/1/fd/10 ]
    #+END_SRC
    【提示】在 /proc/进程号/fd 下可以找到文件描述符

18. -O filename

    如果 filename 存在，并且被有效用户ID所拥有，则为真

19. -G filename

    如果 filename 存在，并且被有效组ID所拥有，则为真

20. -S filename

    如果 filename 存在，并且为一个socket，则为真

    #+BEGIN_SRC sh
      [ -S /tmp/mysql.sock ]
    #+END_SRC

21. -N filename

    如果 filename 存在，并且在上次读取后被修改过，则为真

22. -o optname

    如果 shell 选项 optname 被开启，则为真

    【提示】使用 set -o 来查看

23. file1 -nt file2

    如果 file1 比 file2 新，或者 file1 存在 file2 不存在，则为真

24. file1 -ot file2

    如果 file1 比 file2 旧，或者 file2 存在 file1 不存在，则为真

25. file1 -ef file2

    如果 file1 和 file2 都指向同样的设备(device)和索引节点号(inode
    numbers)，则为真

    【提示】查看文件的索引节点可以用 ls -i 选项

** 日期时间
*** date

1) 格式： date [opts] [+format]
2) format
   - %H
   - %M
   - %s
   - %y
   - %Y
   - %m
   - %d
   - ...
   - 不加+，表示设定时间，格式为MMDDhhmm[CC][YY][.ss]

** 编程风格
*** [[https://app.yinxiang.com/shard/s52/nl/11551545/127c59e2-466d-4355-a17a-d2773f179faa/?csrfBusterToken%3DU%253Db04339%253AP%253D%252F%253AE%253D151a5c2ee1b%253AS%253D15929e085232fb21d53ac9a74c115954][bash 编程规范]]                                                   :style:
**** reference
+ [[https://app.yinxiang.com/shard/s52/nl/11551545/127c59e2-466d-4355-a17a-d2773f179faa?title=Shell%20%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC][bash 编码风格]]

*** document & doxygen                                            :doxygen:

http://stackoverflow.com/questions/1190427/shell-documentation-bash-ksh

Q: is there a tool out there similar to Javadoc or POD for shell
scripting?

A:
No, but you can try to abuse of doxygen

/不考虑/

* LaTeX                                                               :latex:
** LaTeX
*** LaTeX简介
**** latex简史
***** LaTeX历史
1. 排版系统
   排版软件基本上可以分为两类:
   - 文字处理软件,如Word,所见即所得
   - 格式化排版程序,TeX
2. Tex
   1) What?
      TeX是由著名计算机专家D.E.Knuth(高纳德)研发的特别适合排版科技文献
      和书籍的格式化排版程序.
      TeX内核相当稳定,基本零bug,当前版本号3.141592
   2) 特点
      - TeX由Pascal语言编写
      - 开放源代码
      - 功能强大,几乎可以排版任何格式的文献
      - 对数学公式的排版是最好的
      - 支持命令宏,可扩展
      - 跨平台,可移植
      - 排版结果dvi文件与输出设备无关
      - TeX源码为文本文件
   3) What's LaTeX?
      TeX + 宏包,
      Leslie Lamport于1985年开发
   4) What's LaTex2e?
      优化内核的LaTeX
   5) 文稿产生过程
      + step 1: 编写源码文件
      + step 2: 使用latex命令编译文件
        源文件经过编译后,系统自动生成三个文件:
        - log文件:编译信息
        - aux文件:辅助信息
        - dvi文件::排版之后的格式化文件,设备无关,但包含字库信息
      + step 3: 输出成PS/PDF文件
**** latex的特点
**** latex的缺点
**** TeX,LaTeX,xeTeX与xeLaTeX
[[http://www.linuxidc.com/Linux/2012-05/61546.htm#printBody]]
1. LaTeX, TeX, xeLaTeX,xeTeX的关系
   *LaTeX* 是TeX的一种格式(format),是建立在TeX基础之上的宏语言,也就是说,
   每一个LaTeX命令实际上最后都会被解释转换成几个甚至上百个TeX命令.
   *XeTeX* 是一种使用Unicode的TeX排版引擎,并支持一些现代化字体技术,例如
   OpenType.其作者和维护者是Jonathan Kew,并以X11自由软件许可证发布.它
   原生支持UTF-8编码.XeTeX可以在不进行额外配置的情况下直接使用操作系统
   中安装的字体,因此可以直接利用OpenType,Graphite中的高级特性,例如额外
   的字形,花体,合体,可变的文本粗细等等.
   *XeLaTeX* 是使用LaTeX的排版引擎,命令行下直接使用 /xelatex *.tex/ 就
   会产生对应的PDF文件.
2. LaTeX和"所见即所得"排版工具的比较
   + 优点
     - 提供专业级的排版设计,使你的文档开起来如同印刷好的一样.
     - 可以更方便地排版数学公式
     - 用户仅仅需要掌握少数容易理解的,用来说明文档逻辑结构的命令,而无
       须对实际的页面设计做胡乱的修补.
     - 可以很容易的生成脚注,索引,目录和参考文献等复杂的结构.
     - 有大量的免费的可添加宏集,协助你完成许多基本的LaTeX未直接支持的
       排版任务.
     - LaTeX鼓励作者写作具有良好结构的文章,因为LaTeX就是通过详细地说明
       文章的结构进行排版工作的.
     - TeX作为LaTeX的格式化引擎是免费软件,且具有极高的可移植性,因此,它
       几乎可以在任何硬件平台上运行.
   + 缺点
     - 对于出卖灵魂的人来说,LaTeX不能很好地工作.
     - 尽管在预先定义好的版面中可以调节一些参数,设计全新的版面还是很困
       难的,需要耗费大量的时间.
     - LaTeX不适合于排版非结构化,无序的文档
     - 即使有一个令人振奋的开始,但你也有可能无法完全掌握其精髓.
3.
**** ctex中文套装简介
*** LaTeX基础
**** 源文件的结构
   #+BEGIN_EXAMPLE
     \documeen{class}
        导言
     \begin{document}
        主体正文
     \end{document}
   #+END_EXAMPLE


   LaTeX源文件是一个纯文本文件必须包含导言部分(preamble)和主体部分
   (body).
   导言部分通常是一些命令的集合,它们定义了文稿的整体结构,比如文稿的格
   式,版面的高度和宽度,行距和缩格,页面及页码的形式,页眉页脚旁注的形式
   等.导言至少要包含\document命令,它定义了文稿的类型是书本文章还是其它
   形式.导言的命令具有整体效能.

**** 命令
1. 命令
   1) 由命令前导符"\textbackslash{}"加若干字母组成,字母区分大小写,终止于空格、数字或
      其它非字母符号。
   2) 或由命令前导符“\textbackslash{}”加一个特殊符号
   3) LaTeX命令忽略之后的所有空白. *{}*
   4) 命令参数置于{}中
**** 文类
1. 源文件类型
   #+BEGIN_EXAMPLE
     \document[options]{class}
   #+END_EXAMPLE

   1) 类型class
      - article 文章
      - report  报告
      - book    书本
      - letter  书信
      - slider  幻灯片
   2) 选项options
      参数选项之间使用逗号隔开
      - 10pt, 11pt, 12pt  字体大小,默认10pt
      - a4paper,letterpaper  纸张尺寸
      - fleqn  数学公式左对齐
      - leqno  数学公式标号放在左边
      - titlepaper,notitlepaper  标题后是否另起一页
      - twocolumn  双栏
      - twoside,oneside 双面/单面
      - openright,openany  新的一章从右页开始/左右
**** 宏包
   #+BEGIN_EXAMPLE
     /usepackage[options]{package}
   #+END_EXAMPLE
**** 模式
**** 符号
***** 保留字符
|------+-------------------------------+-------------------------------------------------------|
| 字符 | 说明                          | 输出命令                                              |
|------+-------------------------------+-------------------------------------------------------|
| $    | 进入退出数学模式              | \textbackslash{}$                                     |
| &    | 表格中分割行的列线            | \textbackslash{}&                                     |
| %    | 注释符号                      | \textbackslash{}%                                     |
| #    | #1,...,#9用来定义命令参数个数 | \textbackslash{}#                                     |
| _    | 下标                          | \textbackslash{}_                                     |
| {    | 分组起始                      | \textbackslash{}{                                     |
| }    | 分组结止                      | \textbackslash{}}                                     |
| ~    | 不可断行的空格                | \textbackslash{}~{} or \textbackslash{}textasciitilde |
| ^    | 下标                          | \textbackslash{}^ or \textbackslash{}textasciicircum  |
|------+-------------------------------+-------------------------------------------------------|

**** 长度设置
1. 长度
   在LaTeX中经常用到长度的概念.最简单的长度是一个进制数(可正可负)加上
   一个长度单位.
   常用的长度单位
    |----+------+---------------|
    | mm | 毫米 | 1mm~=1/25in   |
    | cm | 厘米 | 1cm=10mm      |
    | in | 英寸 | 1in=25.4mm    |
    | pt | 点   | 1pt=1/72.27in |
    | bp | 大点 | 1bp=1/72in    |
    | pc | pico | 1pc=12pt      |
    | em |      | 大写字母M高度 |
    | ex |      | 小写字母x高度 |
    |----+------+---------------|
    *\textbackslash{}fill*
    *\textbackslash{}strench{n}*
    *\textbackslash{}newlength{\textbackslash{}cmd}*
    *\textbackslash{}setlength{\textbackslash{}cmd}{长度}*
    *\textbackslash{}addtolength{\textbackslash{}cmd}{长度}*
**** 盒子
**** 计数器
**** 交叉引用
**** 环境
***** 环境语法:
#+BEGIN_EXAMPLE
   \begin{env} some-text \end{env}
#+END_EXAMPLE
e.g.
   - center/flushleft/flushright  居中,左对齐,右对齐
   - quote
   - math
   - itemise  列表
   - tabular  表格
   - figure   图形
   环境支持嵌套
***** 浮动环境
1. 浮动环境
   1) figure 图
   2) table 表
2. 语法
   #+BEGIN_EXAMPLE
     \begin{figure}[位置选项]
     插图命令或绘图环境
     \caption[目录标题内容]{标题内容}
     \end{figure}
   #+END_EXAMPLE
   #+BEGIN_EXAMPLE
     \begin{table}[位置选项]
     \caption[目录标题内容]{标题内容}
     表格环境
     \end{table}
   #+END_EXAMPLE
3. 位置选项
   + h: here
   + t: top
   + b: bottom
   + p: page of float
   + !:
***** DONE TeX 诗歌抄录
- State "DONE"       from "TODO"       [2015-03-02 一 22:41]
- State "TODO"       from ""           [2015-02-28 六 15:33]

诗歌环境 *verse* 也是一种引用环境,其中文本两端也都有相同宽度的缩进.
#+BEGIN_EXAMPLE
  \begin{verse}
  Line 1st \\
  Line 2nd \\
  \end{verse}
#+END_EXAMPLE

\begin{verse}
In me, past, present, future meet,\\
To hold long chiding conference.\\
My lusts usurp the present tense,\\
And strangle Reason in his seat.\\
My loves leap through the future's fence\\
To dance with dream-enfranchised feet.\\
In me the cave-man clasps the seer,\\
And garlanded Apollo goes\\
Chanting to Abraham's dear ear.\\
In me the tiger sniffs the rose.\\
Look in my heart, kind friends, ant tremble.\\
Since there your elements assemble.\\
\end{verse}
***** 抄录环境
1. latex
   #+BEGIN_EXAMPLE
   \begin{verbatim} ... \ end{verbatim}
   \begin{verbatim*} ... \ end{verbatim*}
   #+END_EXAMPLE
   两者的不同之处在于后者将空格显式显示出来
   #+BEGIN_EXAMPLE
   \verb  将较短的一行原封不动的显示出来
   \verb*
   #+END_EXAMPLE
***** 音标
#+BEGIN_SRC latex
\LaTeX 中音标的输入是通过调用\textbf{tipa}宏包实现的.\\
\indent \textbf{\textbackslash usepackage{tipa}}\footnote{该宏包可能与
  其它宏包有所冲突,需适当调整位置}\\
如果是在xeLaTeX 中使用tipa宏包,则需要在导言中加入
\textbf{\textbackslash setmainfont\{Times New Roman\}}或其它能将西文字体设置为
Times New Roman的命令,否则某些音标符号将无法显示.

\begin{tabular}{|l|l|l|l|l|l|}
  \hline
  音标 & \LaTeX 表达式 & 音标 & \LaTeX 表达式 & 音标 & \LaTeX 表达式\\
  \hline
  \i & \textbackslash i & \textdyoghlig & \textbackslash textdyoghlig
                                              & \textscripta &
                                                               \textbackslash textscripta \\
  \ae & \textbackslash ae & \textturnv & \textbackslash textturnv
                                              & \dh & \textbackslash
                                                      dh \\
  \j & \textbackslash j & \textschwa & \textbackslash textschwa &
                                                                  \textepsilon &
                                                                                 \textbackslash textepsilon \\
  \textdzlig & \textbackslash textdzlig & \textscriptg &
                                                         \textbackslash
                                                         textscriptg
                                              & \textopeno &
                                                             \textbackslash textopeno \\
  \textesh & \textbackslash textesh & \texttheta & \textbackslash
                                                   texttheta &
                                                               \textyogh
                                                     & \textbackslash
                                                       textyogh \\
  \textteshlig & \textbackslash textteshlig & \textupsilon &
                                                             \textbackslash
                                                             textupsilon
                                              & \ng & \textbackslash
                                                      ng \\
  \textprimstress(重音) & \textbackslash textprimstress &
                                                          \textsecstress(
                                                          次重
                                                          音) &
                                                                \textbackslash
                                                                textsecstress&
                                                                               \textlengthmark
                                                     & \textbackslash textlengthmark\\
  \hline

\end{tabular}

上表未列出的音标大多可以直接由键盘输入而不需要任何\LaTeX 指令,或者可由
以上音标的\LaTeX 表达式组合拼接而成.

另外,在英文文章也经常出现一些字母上面加两个点的字母,例如
Sch\"o{}dinger(薛定谔),na\"i{}ve等,这也可由\LaTeX 实现.

\begin{tabular}{ll}
  \hline
  \"o & \textbackslash "o \\
  \"i & \textbackslash "i \\
  \"u & \textbackslash "u \\
  \hline
\end{tabular}

\textbf{注}:反斜杠\textbackslash 后面的一定是\textbf{英文标点的双引号}.

以上仅仅是英语普遍使用的音标符号,其它IPA(国际音标符号)的\LaTeX 表达式
请参考tipa宏包的说明文档\textbf{tipaman.pdf(texlive安装目录中包含宏包
  的说明文档,学会搜索使用)}.
#+END_SRC
**** 注释
% 行注释
环境comment,来自vebatim包.
**** 加减乘除
**** 条件判断
**** 注释与提示
**** 颜色
***** 颜色
#+BEGIN_SRC latex
使用颜色可以显著提高论文的表达能力和阅读效果.由于历史原因\LaTeX 本身不具备颜色处理能力,故而需要调用Uwe Kern编写的颜
色宏包\textbf{xcolor},具有以下特性:
\begin{itemize}
\item 支持多种颜色模式
\item 可生成任意颜色
\item 可以对各种文本元素的前景(文字,线条等)和背景分别着色.
\end{itemize}

\begin{enumerate}
\item 颜色模式

  \begin{itemize}
  \item \textbf{灰度模式gray}

    \textbf{[gray]\{0.75\}},\textbf{xcolor}中灰度范围0\~{}1.

  \item \textbf{三基色模式rgb}

    \textbf{[rgb]\{0.75,0.5,0.25\}},基色(red,green,blue)比例范围0\~{}1.

  \item \textbf{三基色模式RGB}

    \textbf{[RGB]\{191,127,64\}},基色范围0\~{}255.

  \item 四分色模式cmyk

    \textbf{[cmyk]\{0,0,1,0.5\}},基色(青色cyan,红紫色magenta,黄色
    yellow,黑色black)比例范围0\~{}1.
  \end{itemize}


\item 颜色宏包的选项
  \begin{itemize}
  \item dvipsnames,调用颜色定义文件dvipsnam.def,其中定义了68种cmyk颜
    色.
  \item svgnames,调用颜色定义文件svgnam.def,其中定义了151种rgb颜色.
  \item x11names,调用颜色定义文件x11nam.def,其中定义了317种rgb颜色.
  \item table,自动调用彩色表格宏包colortbl,并可使用xcolor提供的表格行
    背景颜色命令 \textbackslash rowcolors.
  \end{itemize}


\item 颜色的定义
  常用颜色有:\textcolor{red}{red} \textcolor{green}{green},
  \textcolor{blue},\textcolor{yellow}{yellow},\textcolor{black}{black},\textcolor{gray}{gray}
  等.

  \textbf{\textbackslash{}definecolor\{颜色\}\{模式\}\{定义\}}用于定义
  新的颜色,如\\
  \textbackslash{}definecolor\{mycolor\}\{gray\}\{.65\}


\item 颜色表达式

  \textbf{颜色1!百分比1!颜色2!百分比2!...}按照比例混合颜色.


\item 颜色使用命令

  \begin{itemize}
  \item \textbf{color}

    \textbf{\textbackslash{}color\{颜色\}}和 \textbf{\textbackslash{}color\{模
      式\}\{定义\}}声明颜色命令可改变其后的各种文本元素,如文本,标题,线段,
    表格和数学公式等.


  \item \textbf{textcolor}

    \textbf{\textbackslash{}textcolor\{颜色\}\{对象\}}和 \textbf{\textbackslash{}textcolor[模
      式]\{定义\}\{对象\}}将参数对象(文本,标题,线段,表格,数学公式等)设置为一定
    颜色.

  \item \textbf{colorbox}

    \textbf{\textbackslash{}colorbox\{颜色\}\{对象\}} 和 \textbf{\textbackslash{}colorbox[模
      式]\{定义\}\{对象\}}为对象设置背景颜色.

    \textbf{\textbackslash{}fcolorbox\{边框颜色\}\{背景颜色\}\{对象\}} 和
    \textbf{\textbackslash{}fcolorbox[模式]\{边框颜色定义\}\{背景颜色定义\}\{对象\}},同时
    设置边框颜色.


  \item \textbf{pagecolor}

    \textbf{\textbackslash{}pagecolor\{颜色\}}和 \textbf{\textbackslash{}pagec[模式]\{定义\}}用于
    设置其后的页面背景颜色.

  \item \textbf{normalcolor}

    \textbf{\textbackslash{}normalcolor{}}命令将字体颜色转变为导言最后定义的字体颜
    色.

  \end{itemize}

\end{enumerate}

#+END_SRC
**** \LaTeX 中的长度                                              :length:

1. tex中的长度
   + *mm*    毫米
   + *cm*    厘米
   + *in*    英寸＝2.54cm＝72.27pt
   + *pt*    点(默认)
   + *em*    大写字母m的宽度
   + *ex*    小写字母x的高度

2. 参考
   + [[https://app.yinxiang.com/shard/s52/nl/11551545/2732e9a9-3a82-48d9-8610-796c092ae88b?title=latex%e5%91%bd%e4%bb%a4%e9%80%9f%e6%9f%a5%e6%89%8b%e5%86%8c-fruitfly1026-chinaunix%e5%8d%9a%e5%ae%a2][blog]]

*** 字体
**** 字体的属性
**** 字体设置命令
**** 字体尺寸命令
**** 局部字体修改
**** 常用字族
**** 字体定义文件
**** 字体属性命令
**** 全文字体修改
**** 中文字体
**** 任意尺寸字体
*** 版面设计
**** 版面
***** 版面
#+BEGIN_SRC latex
\begin{enumerate}
\item 版面设计

  \LaTeX 版面设计复杂而精细。

版面图示宏包layout中\textbackslash layout命令可在命令处生成当前版面位置及尺寸的示意图。

版面设置宏包geomtry
\begin{verbatim}
  \usepackage[text={140mm,240mm}]{geometry}
\end{verbatim}
\item 多栏排版
  \textbackslash onecolumn 单栏命令
  \textbackslash twocolumn 双栏命令
\item 页眉和页脚
  \LaTeX 系统提供4种版式
  \begin{itemize}
  \item empty 页眉和页脚为空
  \item plain 页眉为空，页脚中间是页码
  \item headings 页眉内容为页码和节标题
  \item myheadings 格式与headings一致，内容自定义
  \end{itemize}
  使用\textbf{\textbackslash pagestyle\{版式\}}设定版式。
  使用\textbf{\textbackslash thispackage\{版式\}}设定当前页版式。
\end{enumerate}
#+END_SRC
**** 文本格式
***** DONE [#B] 上划线怎么输入?
DEADLINE: <2015-03-15 日>
- State "DONE"       from "TODO"       [2015-03-17 二 11:22]
- State "TODO"       from ""           [2015-03-04 三 14:29]
 Date:<2015-02-27 五>
 Link:[[file:~/Tiger/DTL/TODO.org::*]] (Y/N)

 Math Accent
 \begin{math}
 \bar{abv}
 \end{math}

 Note: \textbackslash{}bar 命令仅能在math环境中使用, 而且只支持单个字
  母, 多个字母则居中.

***** 空白
+ *\textbackslash{}hspace{length}*
+ *\textbackslash{}hspace**
+ *\textbackslash{}vspace*
+ *\textbackslash{}vspace**
***** 下划线
#+BEGIN_SRC latex
\begin{itemize}
\item 系统命令\\
 \textbf{\textbackslash underline{文本}} 不能中断。
\item 宏包ulem
  \begin{itemize}
  \item \textbackslash uline{下划线}
  \item \textbackslash uuline{双下划线}
  \item \textbackslash uwave{波浪下划线}
  \item \textbackslash sout{删除线}
  \item \textbackslash xout{删除线}
  \end{itemize}

\item 宏包CJKfntef
  宏包ctex使用选项\textbf{fntef}
  \begin{itemize}
  \item \textbackslash CJKunderdot{点}
  \item \textbackslash CJKunderline{下划线}
  \item \textbackslash CJKunderdblline{双下划线}
  \item \textbackslash CJKunderwave{波浪线}
  \item \textbackslash CJKsout{删除线}
  \item \textbackslash CJKxout{删除线}
  \end{itemize}
  除此之外，CJKfntef提供了六条颜色命令
  \begin{itemize}
  \item \textbackslash CJKundercolor
  \item \textbackslash CJKunderdbllinecolor
  \item \textbackslash CJKunderlinecolor
  \item \textbackslash CJKsoutcolor
  \item \textbackslash CJKxoutcolor
  \item \textbackslash CJKunderwavecolor
  \end{itemize}
  默认圆点和取消线为红色，其它为蓝色。需要在ctex前调用宏包xcolor。
\begin{verbatim}
\renewcommand{\CJKunderline}{\color{color}}
\end{verbatim}
  可重定义颜色。
\end{itemize}
#+END_SRC
**** 多栏排版
**** 版式——页眉与页脚
*** 标题
**** 论文题名
**** 层次标题
**** 层次标题格式的修改
**** 图表标题
**** 图表标题格式的修改
*** 表格
**** 无框线表格环境tabbing
在LaTeX系统中,提供了两种方法将数据以行和列的形式整齐地排列,一种是利用
*tabbing* 环境,另一种是利用 *tabular* 和 *array* 环境.

|------------------------+---------------------------------|
| *\=*                   | 设置第一行TAB站点               |
| *\>*                   | 设置后续行TAB站点               |
| \\                     | 换行                            |
| \textbackslash{}kill   | 替换首行换行符,使该行内容不显示 |
| \textbackslash{}hspace | 设置列宽                        |
| \textbackslash{}'      | 右对齐                          |
|------------------------+---------------------------------|
   tabbing环境可以创建各式各样的表格,如果与盒子结合起来使用也可以创建
   带框的表格,但使用起来十分复杂.LaTeX提供了tabular,tabular*和array环
   境,实现各种有框和无框表格.

**** tabular
   \textbackslash{}begin{tabular}[位置]{列格式}表格行 \textbackslash{}end{tabular}
   \textbackslash{}begin{tabular*}[宽度][位置]{列格式}表格行 \textbackslash{}end{tabular*}
   \textbackslash{}begin{array}[位置]{列格式}表格行 \textbackslash{}end{array}

   + 位置:表格与表格之外文字在垂直方向的对齐方式,t,c,b
   + 列格式
     |--------------+--------------|
     | l            | 左对齐       |
     | c            | 居中对齐     |
     | r            | 右对齐       |
     | p{width}     |              |
     | 单坚线       | 画一条垂直线 |
     | 双坚线       | 画两条垂直线 |
     | @{文本}      | @-表达式     |
     | *{num}{cols} | 重复格式     |
     |--------------+--------------|
   + 表格行
     每一行使用换行符//来结束,每一行的不同列使用&分开
     |----------------------------+--------------------------------|
     | \textbackslash{}hline                     | 插入一条水平线,须置于u两行之间 |
     | \textbackslash{}cline{n-m}                | 第n列到第m列画一条水平线       |
     | \textbackslash{}multicolumn{n}{col}{文本} | 文本占据n列                    |
     | \textbackslash{}vline                     | 画一条与行等高的垂直线         |
     |----------------------------+--------------------------------|
**** 数组宏包array
**** 跨行表格宏包multirow
**** 跨页表格宏包iongtable
**** 多页表格宏包supertabular
**** 可调列宽表格宏包tabularx
**** 表格线宏包booktabs
**** 小数点对齐宏包dcolumn
**** 对角线宏包slashbox
**** 彩色表格宏包colortbl
**** 颜色宏包xcolor的行颜色命令
**** 表格的整体缩放
**** 表格的使用
*** 列表
**** 常规列表
**** 排序列表
**** 解说列表
**** 嵌套列表
**** 列表宏包paralist
**** 通用列表环境list
**** 通用列表环境trivlist

*** 插图
**** 图形的种类
#+BEGIN_SRC latex
  图形存储的格式很多，一般可以分为两大类：\textbf{位图图形}和\textbf{向量图形}。
  \begin{itemize}
  \item 位图图形：即点阵图形，技术上称栅格图形。相关术语：分辨率，色深，无损/有损压缩。
  \item 向量图形：使用数学公式定义的线段和曲线定义的图形，分辨率无关。
  \end{itemize}
  \textbf{注}：计算机显示器只能用网格显示图像，所以不论位图还是向量图，在屏幕上均以像素的方式显示图形。
  位图和向量图的区别：
  \begin{itemize}
  \item 分辨率相关与否。
  \item 存储空间大小，位图存储的是像素的位置和色深，向量图存储的是各种向量的算法。
  \item 位图适合复杂的图形和照片，向量图适合工程设计图等。
  \end{itemize}

  \LaTeX 直接支持的图形格式：
  \begin{itemize}
  \item \textbf{EPS}
  \item \textbf{PS}
  \item \textbf{JPG}
  \item \textbf{PNG}
  \item \textbf{PDF}
  \end{itemize}
#+END_SRC
**** 图形的插入
A picture is worth thousand words.一图胜千言：一幅图形可以简单明确地表达很多错综复杂、千言万语都难以描述的事物信息。另一方面，有些文字传达的意境和感受是图形难以替代的，如“大漠孤烟直，长河落日圆”。所以，\textbf{一篇优秀的论文应该图文并茂，相得益彰}。

\LaTeX 宏包可以绘制复杂的图形，但不直观。通常会先使用强大的可视绘图工具把图形画好，然后插入到\LaTeX 源文件中。
#+END_SRC
***** graphicx
1. 宏包: graphicx
2. 命令: includegraphics
3. 格式:
   #+BEGIN_EXAMPLE
     \includegraphics[参数1=选项, 参数2=选项,...]{图形文件}
   #+END_EXAMPLE
4. 选项
   1) 外形
      + height
      + weight
      + scale: 负值表示同时旋转180度
      + angle: 正逆
      + origin: 旋转中心
   2) 裁切
      + viewport
      + trim
   3) 开关
      + keepaspectratio
      + clip
      + draft
      + final

***** 图形插入
#+BEGIN_SRC latex
  插图宏包：\textbf{graphicx}。最常用的插图命令是：
  \begin{center}
\begin{verbatim}
\includegraphics[参数选项]{插图}
\end{verbatim}
  \end{center}

  其中，插图包括扩展名。可选参数包括外形参数、裁切参数和布尔参数。
  \begin{itemize}
  \item 由于插图命令既不会结束当前行也不会结束当前段，所以可以把图形插入到某一段落的文本行内。
\begin{verbatim}
这是行内插图\includegraphics{linux-logo.jpg}，不好。
\end{verbatim}
    这是行内插图\includegraphics[scale=0.3]{/home/ben/Picture/logo/linux-logo.jpg}，不好。

  \item 无论是在段落之中还是段落之间，通常应该将插图置于单独一行之中。
\begin{verbatim}
\begin{center}
  \includegraphics{/home/ben/Picture/logo/linux-logo.jpg}
\end{center}
\end{verbatim}
    \begin{center}
      \includegraphics[scale=0.3]{/home/ben/Picture/logo/linux-logo.jpg}
    \end{center}

  \item 论文中每幅都应在其前的正文中明确提及，即每幅插图的序号都应在其前的正文中被引用。因此，插图都是置于图形浮动环境，这样可使用图表标题命令为插图生成带有序号的标题，也可以在该命令中使用交叉引用命令，还可以将插图标题编入插图目录。
\begin{verbatim}
图\ref{fig:1}是JPG格式的图形。
\begin{figure}[!ht]
  \centering
  \includegraphics{/home/ben/Picture/logo/linux-logo.jpg}
  \caption{插图标题}
\end{figure}
\end{verbatim}
    图是JPG格式的图形。
    \begin{figure}[!ht]
      \centering
      \includegraphics[scale=0.3]{/home/ben/Picture/logo/linux-logo.jpg}
      \caption{插图标题\label{fig:1}}
    \end{figure}
  \end{itemize}
#+END_SRC
**** 图文绕排
**** 页面背景
**** 图形处理
**** 浮动体组
**** DONE 数学图形 一份不太简短的LaTeX介绍 P76
- State "DONE"       from "TODO"       [2015-11-06 五 10:02]
basic environment : *picture*.
extension package: *epic*, *eepic*, *pstricks*
Graphical tool: *MetaPost*(a user's manual for metapost)

***** picture
#+BEGIN_EXAMPLE
\setlength{\unitlength}{5cm}
\begin{picture}(x, y)...\end{picture}
\begin{picture}(x, y)(x0, y0)...\end{picture}
#+END_EXAMPLE

- x, y: rectuangular space
- x0, y0: bottom left corner, optional

#+BEGIN_EXAMPLE
\put(x, y){object}
\multiput(x, y)(dx, dy){n}{object}
\qbezier{x1, y1}{x2, y2}{x3, y3}
#+END_EXAMPLE



***** Line segments
#+BEGIN_EXAMPLE
\put(x, y){\line(x1, y1){length}}
#+END_EXAMPLE
- a direction vector
- a length

[[/home/ben/Wally/Journal/Figure/scrot/20724lvg.png]]

***** arrows
#+BEGIN_EXAMPLE
\put(x, y){\vector(x1, y1){length}}
#+END_EXAMPLE

[[/home/ben/Wally/Journal/Figure/scrot/20724Yla.png]]

***** circles
#+BEGIN_EXAMPLE
\put(x, y){\circle{diameter}}
#+END_EXAMPLE
- center: x, y
- diameter: /diameter/
- circle* : filled circle

[[/home/ben/Wally/Journal/Figure/scrot/20724LbU.png]]

***** text and formulas

[[/home/ben/Wally/Journal/Figure/scrot/20724-QO.png]]

***** multiput
#+BEGIN_EXAMPLE
\multiput(x, y)(dx, dy){n}{object}
#+END_EXAMPLE
- starting point
- translation vector
- number
- object

***** oval
#+BEGIN_EXAMPLE
\put(x, y){\oval(w, h)}
\put(x, y){\oval(w, h)[position]}
#+END_EXAMPLE
- center: x, y
- width: w
- height: h
[[/home/ben/Wally/Journal/Figure/scrot/20724y5m.png]]

***** multiple use of Predefined pictures boxes
#+BEGIN_EXAMPLE
\newsavebox{name}
\savebox{name}(with, height)[position]{content}
\put(x, y)\usebox{name}
#+END_EXAMPLE
[[/home/ben/Wally/Journal/Figure/scrot/20724_Dt.png]]

***** quadratic Bezeer Curves

[[/home/ben/Wally/Journal/Figure/scrot/20724MOz.png]]

***** XY-pic
*drawing diagrams*
#+BEGIN_EXAMPLE
\usepackage[options]{xy}
#+END_EXAMPLE

*** 正文
**** 摘要
**** 目录
**** 脚注
**** 尾注
**** 边注
#+BEGIN_SRC latex
  边注与脚注功能类似，都是对正文内容解释补充。不同在于位置不同，字体与正文相同，没有序号。

  边注使用命令

  \begin{verbatim}
  \marginpar[左边注释]{右边注释}
  \end{verbatim}


  单页/双页以及双栏排版时的使用和注释位置不同。

  边注的第一行与边注命令所在行平齐，即基线对齐。

  边注宽度有限，应简短明确，比如只是一个符号。

  边注中可以使用图表。

#+END_SRC
**** 索引
**** 术语表

**** 链接
**** 行号
**** 附录
*** 编译
**** 编译方法
**** 宏包安装
**** 文件类型说明
**** 错误信息与警告信息
**** 子源文件
#+BEGIN_SRC latex
参考:<LaTeX2e完全学习手册> P419-P421
对于中长篇论文,最好采用\textbf{主源文件与子源文件的模块方式}进行组织管
理.

\textbf{\textbackslash{}include\{子源文件名\}}命令将子源文件调入到主源
文件中.子源文件的扩展名是.tex,在包含命令中可以省略.子源文件不需要导言,
通常是以章命令\textbackslash{}chapter开头的源文件.

\textbf{\textbackslash{}input{文件名}}命令可以将子源文件\textbf{或其它
  文件调入到主源文件中},如果是子源文件则扩展名.tex可以省略,否则文件必
须带有扩展名.

\textbf{\textbackslash{}includeonly\{子源文件1,子源文件2...\}}在导言中
使用,选择子源文件对编译进行控制,即只编译指定子源文件.命令中指定的子源
文件必须在正文中由命令include包含.相比注释掉其它子源文件的方法,使用该
命令支持交叉引用等.

\textbackslash{}include与\textbackslash{}input命令的区别\\
\begin{tabular}{ll}
  \hline
  \textbackslash{}include & \textbackslash{}input\\
  \hline
  只能在正文中使用 & 正文导言均可\\
  新起一页 & 不起新页\\
  编译为子源文件输出.aux & 编译时无.aux文件输出\\
  不能嵌套,但可改用\textbackslash{}input命令 & 可以嵌套,也可以包含
                                               \textbackslash{}include
                                               命令\\
  命令 \textbackslash{}includeonly对其有效 & 无效\\
  只能调用.tex子源文件 & 同时可以调用其它文件\\
  调入子源文件后还要另起新页 & 不起新页\\
  没有找到子源文件,只给出警告信息 & 中止编译,提示错误\\
  \hline
\end{tabular}

通常\textbackslash{}include命令仅用在主源文件正文中调入章或节的子源文
件,\textbackslash{}input命令则比较灵活.
#+END_SRC
***** 长文件的编写

在编写有许多章节的长篇书本或文章时,一个比较好的方法是分别编写各章节并
把它们保存在不同的文件中,然后在LaTeX中调用这些文件.不需要将这些文件分
别编译,LaTeX会将它们放入源文件中一并处理.

#+BEGIN_EXAMPLE
\include{filename}
#+END_EXAMPLE

filename不包含扩展名
LaTeX编译时会另起新页

#+BEGIN_EXAMPLE
\includeonly{filename1,filename2}
#+END_EXAMPLE

该命令必须用在源文件的导言部分.
文件名与逗号之间不能有空格.

#+BEGIN_EXAMPLE
\input{filename}
#+END_EXAMPLE

不另起新页
文件名可以包含扩展名.
**** 命令的脆弱与坚强
**** 宏包冲突
**** 文件合并
**** 编译技巧
*** 浮动体
**** 浮动体的控制参数
**** 浮动体的位置调整
*** 文件后缀                                                         :后缀:
**** 配置文件

|----+------------------------------------|
|.afm| Adobe Type1字体描述文件,ASCII格式。|
|.bak| 备份文件,当源文件.tex存盘时由系统自动创建。|
|.bib| 文献数据库。|
|.cfg| 供类包或宏包调用的配置文件。|
|.cls| 稿件类型文件,可用命令\documentclass调用。|
|.doc| 类包或宏包的说明文件。|
|.dtx| 包含类或宏包及其说明文件的文件,需用同名.ins文件或docstrip工具分解。|
|.fd| 字体定义文件,定义某一字族,用于L A TEX字体寻找。|
|.ins| 同名.dtx的分解文件,用PDFL A TEX编译,可得到sty或cls等类型文件。|
|.map| 字体名称与.tfm文件之间的字体映射文件。|
|.mbs| 主控文件,包含全部文献样式命令,用于生成.bst文献样式文件。|
|.mf| METAFONT字体描述文件,Knuth教授创立的矢量字体。|
|.pfa| Type 1字体文件,ASCII格式,一种高品质矢量字体,越放大越清晰。|
|.pfb| Type 1字体文件,二进制格式。|
|.pk| pk字体,一种点阵字体,用于dvi文件预览等。|
|.pl| 字体属性列表,可读的字体描述文件。|
|.sfd| 子字库定义文件。|
|.sty| 宏包文件,可用命令\usepackage调用。|
|.tex| L A TEX源文件。|
|.tfm| 字体描述文件,设定字体的宽、高和间距等,L A TEX用以规划页面。|
|.ttf| Truetype字体,Windows系统使用的一种全真字体。|
|.vf| TEX虚拟字体|
|.vpl| 虚拟属性列表,可读的虚拟字体文件。|
|----+----------------------------------|

**** 编译文件

|------+---------------------------------------------------------------------|
| .aux | 引用标记记录文件,用于再次编译时生成参考文献和超链接等。             |
| .bbl | 由BibTEX编辑.bib后创建的文献文件,再次编译时带入源文件生成文献列表。 |
| .blg | BibTEX处理过程记录文件。                                            |
| .dbj | 批处理文件,由makebst工具在创建.bst文献样式文件时生成。              |
| .dvi | 由L A TEX对.tex源文件编译后创建的输出文件,含有字库信息。            |
| .glo | 术语标记记录文件,用于再次编译时生成术语表。                         |
| .idx | 索引资料记录文件,可用makeindex排序后创建索引文件.ind。              |
| .ilg | makeindex处理过程记录文件。                                         |
| .ind | makeindex对.idx排序后创建的索引文件,再次编译时带入源文件生成索引。  |
| .lof | 图形标题记录文件,用于再次编译时生成图形目录。                       |
| .log | 编译过程记录文件,记录编译时出现的提示、警告和错误信息。             |
| .lot | 表格标题记录文件,用于再次编译时生成表格目录。                       |
| .pdf | 由PDFL A TEX对.tex或dvipdf对.dvi或pspdf对.ps编译后创建的图形文件。  |
| .ps  | 由dvips对.dvi文件编译后创建的图形文件。                             |
| .toc | 章节标题记录文件,用于再次编译时生成章节目录。                       |
|------+---------------------------------------------------------------------|

** 命令                                                                :cmd:
*** =\relax=                                                        :relax:
[[https://app.yinxiang.com/shard/s52/nl/11551545/aab18c55-3eab-42d6-ae48-6fb594474634?title=what%20is%20the%20difference%20between%20%5crelax%20and%20%7b%7d%3f][stackexchange: relax and {}]]

[[http://tex.stackexchange.com/questions/96501/what-does-relax-do][stackexchange： what does relax do?]]

it is what's called a *no-op*: it does nothing, and it's used in various
places where you don't want anything done, but the syntax requires
something. tex's rules also dictate that in an =\if= statement, an
undefined macro will compare equal to =\relax=. so it's sort of a
general-purpose nothing.


=\relax= does nothing by itself, it is a safe command to stop
expansion of another command. some examples:

+ (plain tex) =\hskip 5pt\relax=
  in the absence of =\relax=, the =\hskip= will keep looking for plus
  or minus

+ (latex) at the end of a line, =\\ \relax [...]=
  will prevent what is in braces from being interpreted as a dimension
  that would add vertical space

*** \textbackslash{}newenvironment                         :newenvironment:

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\newenvironment{envname}[narg]{def1}{def2}
\end{minted}
#+end_latex

defines a new environment,  optionally with some number of arguments
*narg*. *def1* is executed when the environment is entered and *def2*
is executed when it is exited.

*** \LaTeX 名字命令                                          :renewcommand:
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \renewcommand{\contentsname}{目\qquad 录}
  \renewcommand\listfigurename{插\ 图\ 目\ 录}
  \renewcommand\listtablename{表\ 格\ 目\ 录}
  \renewcommand\bibname{参\ 考\ 文\ 献}
  \renewcommand{\figurename}{图}
  \renewcommand{\tablename}{表}
  \end{minted}
#+end_latex

*** \textbackslash{}setlength                                   :setlength:

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\setlength{\nl}{length}
\end{minted}
#+end_latex

sets value of length command *\textbackslash{}nl* to *length*

+ 参考
  - [[file:~/document/programming/tex/latex%e5%91%bd%e4%bb%a4%e9%80%9f%e6%9f%a5%e6%89%8b%e5%86%8c.pdf::trailer%0d<<%0d/size%20122%0d/info%20116%200%20r%20%0d/root%20115%200%20r%20%0d/prev%20304023%20%0d/id%5b<34f5bfc030aea1e56aea670e2be665ff><c4ee31aa4c02bc5316e5a8813d952c58>%5d%0d>>%0dstartxref%0d308437%0d%25%25eof%0d][latex命令速查手册]]

*** \textbackslash{}newcommand                                 :newcommand:

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\newcommand{\cs}[narg]{def}
\end{minted}
#+end_latex

define a new control sequence *\textbackslash{}cs* with defintion *def*.

optionally,  /narg/ is the number of arguments,  indicated in *def* as
#1,  #2, etc.

+ 参考
  [[file:~/document/programming/tex/latex%e5%91%bd%e4%bb%a4%e9%80%9f%e6%9f%a5%e6%89%8b%e5%86%8c.pdf::trailer%0d<<%0d/size%20122%0d/info%20116%200%20r%20%0d/root%20115%200%20r%20%0d/prev%20304023%20%0d/id%5b<34f5bfc030aea1e56aea670e2be665ff><c4ee31aa4c02bc5316e5a8813d952c58>%5d%0d>>%0dstartxref%0d308437%0d%25%25eof%0d][latex命令速查手册]]
*** \textbackslash{}definecolor                               :definecolor:
*** \textbackslash{}renewcommand                             :renewcommand:

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\renewcommand{\cs}[narg]{def}
\end{minted}
#+end_latex

redefines an existing control sequence *\textbackslash{}cs*  with
definition *def*

optionally,  /narg/ is the number of arguments,  indicated in *def* as
#1, #2, etc.

*** \textbackslash{}parindent                                   :parindent:

*paragraph indent*

horizontal indentation added at the begining of paragraph.

*** \textbackslash{}floatsep                                     :floatsep:

*float seperation*

distance between floats that appear at the top or bottom of a text
page

*** self defined conditions                                         :newif:

you can create new conditionals (as a kind of boolean variables) with
the *\textbackslash{}newif* command. with this self defined conditionals you can
control the output of your code in an elegant way. the best way to
illustrate the use of conditionals is through an example.

two versions of a document must be generated. one version for group a
the other one for the rest of people (i.e. not belonging to group a):

1. we use \textbackslash{}newif to define our conditional
   (i.e. boolean variable).
   #+begin_latex
   \begin{minted}[frame=single, mathescape]{latex}
   \newif\ifgroupa
   \end{minted}
   #+end_latex

2. in the following way we set a value (true or false) for our
   conditional
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{latex}
       \groupatrue % or
       \groupafalse
       that is:

       \<conditionalsname>true
       \<conditionalsname>false
     \end{minted}
   #+end_latex
   depending on which value we want to set in our conditional.

3. now we can use our conditional anywhere after in an if control
   structure.
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{py}
       \ifgroupa
       % here we write the code of the document that is
       % intended for the group a
       \else
       % here we write the code of the document that is
       % intended for the rest of the people
       \fi
     \end{minted}
   #+end_latex

   a full example is:
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{py}
     \newif\ifdirector

     %i set the conditional to false
     \directorfalse

     \ifdirector
      i write something for the director.
     \else
      i write something for common people.
     \fi
     \end{minted}
   #+end_latex

   i write something for common people.

4. 参考
   + [[https://en.wikibooks.org/wiki/latex/plain_tex][wikibook:latex]]

** 数学式                                                 :math:fomula:公式:

在科技论文中经常要用到分式,根式,行列式和微积分方程以及证明,定理等数学
表达式,统称为 *数学式*.TeX 就是因数学式而生,LaTeX 就是为数学式而长,排
版数学式乃是 LaTeX 的最强项,而且是越复杂越能显示出它的优越性.再辅以相
关的数学宏包,尤其是 *amsmath* 公式宏包,将大幅地扩充 LaTeX 的排版功能,
使排版效果更为精美和专业.

*** 数学模式
在 LaTeX 中最常用的模式主要有文本模式和数学模式. *数学模式* 又可分
为 *行内公式(inline math)* 和 *行外公式(display math)*.

**** 行内公式
LaTeX 提供了三种方法编写行内公式
: (1) $ ... $
: (2) \textbackslash{}(... \textbackslash{})
: (3)\textbackslash{}begin{math}...\textbackslash{}end{math}

#+BEGIN_SRC latex
$y^{2}=2px$
\(y^{2}=2px\)
\begin{math} y^{2}=2px \end{math}
#+END_SRC

三种方法的排版结果完全相同,第一种方法比较常用,因为它 *性格坚强*.

如果行内公式较长,系统会在=,>,<等关系符和+,-等二元符处自动换行.

花括号中的数学式无法中断换行,只能完整地从左到右排列,直到凸进右边空.

在换行位置附近若无二元符,行内公式也无法中断.
**** 行间公式
LaTeX 提供三种方法编写行间公式.
#+BEGIN_EXAMPLE
(1) \$\$...\$\$
(2) \textbackslash{}[...\textbackslash{}]
(3) \textbackslash{}begin{displaymath}...\textbackslash{}end{displaymath}
#+END_EXAMPLE

三种方法排版效果相同,第三种使用环境变命令,起止明确.

*注:在数学模式中不能有空行或\par换段命令,否则系统将提示出错*

*** 常用数学宏包
+ 宏包套件ams
+ 公式宏包 *amsmath*
+ 宏包套件amsfonts
+ 宏包套件mh

*** 常用数学宏包
*** 数学符号
**** DONE 加减号怎么输入?
DEADLINE: <2015-03-15 日>
- State "DONE"       from "TODO"       [2015-03-17 二 11:16]
- State "TODO"       from ""           [2015-03-04 三 14:29]
 Date:<2015-02-27 五>

 \textbackslash{}pm

 \pm
注: \textbackslash{}pm 是 LaTeX中的命令, 但从org导出为tex会"变成"
\textbackslash{}textpm, pdf结果一致, 但不明所以.
**** TeX 数学符号列表
参考:

Note: 自己输入
***** Hebrew(希伯来) letter
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669dYH.png}
\end{center}
***** 希腊字母
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669qiN.png}
\end{center}

\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/136693sT.png}
\end{center}
***** LaTeX binary relation(二元关系)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669RBg.png}
\end{center}
***** AMS binary relations(二元关系)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669eLm.png}
\end{center}

\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/136694fy.png}
\end{center}

***** AMS negate binary relation
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669qpB.png}
\end{center}

***** binary operation(二元操作)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/136693zH.png}
\end{center}
+ The first part contains the binary operations in LaTeX.
+ The second part requires the latexsym package
+ The third part contains the AMD addition. They requires the amssymb
  package.
+ The symbol \textbackslash{}And requires the amsmath package
***** Arrows(箭头)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669E-N.png}
\end{center}
+ The top part contains the symbols provided by LaTeX. The last
  command, \textbackslash{}leadsto, requires the latexsym package
+ The middle table contain the AMS arrows. They require the amssymb
  package.
+ The bottom table lists the negated arrow symbols. They require
  amssymb.
***** Miscellaneous symbols
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669RIU.png}
\end{center}
***** Math spacing commands
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669eSa.png}
\end{center}
***** Delilmiters(定界符)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669rcg.png}
\end{center}

\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/136694mm.png}
\end{center}
***** Operators(操作符)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669Fxs.png}
\end{center}

\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669S7y.png}
\end{center}

***** Math accents
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669EFC.png}
\end{center}
***** Math font commands
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669RPI.png}
\end{center}

**** TeX 文本符号列表
***** Spectial text characters(保留字符)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669eZO.png}
\end{center}
***** Text accents
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669rjU.png}
\end{center}
***** Some European characters(欧洲字符)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/136694ta.png}
\end{center}
***** Extra text symbol
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669F4g.png}
\end{center}
***** Text spacing commands
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669SCn.png}
\end{center}
***** Text font commands
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669fMt.png}
\end{center}
***** Text font size changes
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669sWz.png}
\end{center}
***** AMS text font size changes
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669egC.png}
\end{center}

*** 公式环境
*** 矩阵环境
*** 定理环境
*** 交换图
*** 数学字体
*** 精细调整
*** 单边大括号
#+BEGIN_EXAMPLE
  \left\{
      \begin{array}{l}
        r=\alpha(R+\omega) \\
        l=\alpha\cdot R
      \end{array}
    \right.
#+END_EXAMPLE
*注意right后面的句点，不可以缺少。*
*** 公式组与多行公式                                                   :多行公式:
**** 公式组 eqarray
[[/home/ben/Wally/Journal/Figure/scrot/3297vLy.png]]

[[/home/ben/Wally/Journal/Figure/scrot/3297hVB.png]]
**** 多行公式 align

align*不生成公式序号

[[/home/ben/Wally/Journal/Figure/scrot/3297ufH.png]]
*** 梯度                                                                 :梯度:

=\nabla=

** LaTeX拾遗

*** 数学宏包amsmath要在ctex宏包后面包含，否则会出现错误，不知为何

*** Typesetting Mathematical Formulae
**** inline & within a paragraph
1. inline
   + \textbackslash{}(...\textbackslash{})
   + $...$
   + \textbackslash{}begin{math}...\textbackslash{}end{math}
2. within a paragraph
   + \textbackslash{}[...\textbackslash{}]
   + \textbackslash{}begin{displaymath}...\textbackslash{}end{displaymath}
   + \textbackslash{}{equation}...\textbackslash{}{equation}
     + enumerate
     + refer
     #+BEGIN_SRC latex :exports both
     \begin{equation}
     \label{eq:eps}
     \epsilon > 0
     \end{equation}
     From (\ref{eq:eps}), we gather \ldots{}
     From \eqref{eq:eps}, we do the same.
     #+END_SRC
3. difference in typesetting style between equations that are typeset
   and those that are displayed
   + typeset
     #+BEGIN_SRC latex :exports both
       $\lim_{n \to \infty}
       \sum_{k=1}^n \frac{1}{k^2}
       = \frac{\pi^2}{6}$
     #+END_SRC
   + display
     #+BEGIN_SRC latex :exports both
       \begin{displaymath}
         \lim_{n \to \infty}
         \sum_{k=1}^n \frac{1}{k^2}
         = \frac{\pi^2}{6}
       \end{displaymath}
     #+END_SRC

**** difference between /math mode/ and /text mode/
+ Most space and line breaks do not have any significance, as all
  spaces are either logically from the mathematical expressions, or
  have to be specified with special command such as \textbackslash{},,
  \textbackslash{}quad or \textbackslash{}qquad.
+ Empty lines are not allowed. Only one paragraph per formulas
+ Each letter is consider to be the name of a variable and will be
  typeset as such. If you want to typeset normal text with in a
  formular(normal upright and normal spacing) then you have to enter
  the text using the \textbackslash{}textrm{...} commands.
  #+BEGIN_SRC latex :exports both
    \begin{equation}
      \forall x \in \mathbf{R}: \qquad x^{2} \geq 0
    \end{equation}
  #+END_SRC

  #+RESULTS:
  #+BEGIN_LaTeX
  \begin{equation}
    \forall x \in \mathbf{R}: \qquad x^{2} \gep 0
  \end{equation}
  #+END_LaTeX

  #+BEGIN_SRC latex :exports both
    \begin{equation}
      x^{2} \geq 0\qquad \textrm{for all } x \in \mathbf{R}
    \end{equation}
  #+END_SRC

  #+RESULTS:
  #+BEGIN_LaTeX
  \begin{equation}
    x^{2} \geq 0\qquad \textrm{for all} x \in \mathbf{R}
  \end{equation}
  #+END_LaTeX

*** TeX 宏包安装

http://www.xuebuyuan.com/1673310.html

1. 傻瓜式安装

   下载.cls或者.sty格式的文件，直接放在编译的目录下与主文件一起运行。

2. 宏包管理器
   + TeXLive: tlmgr
     + $ tlmgr install <pkg> ...
     + $ tlmgr remove <pkg> ...
   + MikTeX
3. 手动安装

   手动安装相对前两种方式要稍微复杂些。如果你下载的宏包里包含sty等格式
   的必需文件，说明宏包已经经过编译了，可以直接跳到第三步；如果没有，
   对于较复杂的包，一般包含五个步骤：

   1) 提取文件

      在下载的宏包里找到后缀名为.ins格式的文件，然后运行“latex
      yourfilename.ins”命令或者用Latex发行版打开ins文件进行编译。此步
      骤可以从dtx格式的文件中提取制定的内容并生成需要的文件。

   2) 创建文档

      接着利用dtx文件创建说明文档，运行命令“latex yourfilename.dtx”。
      此步骤可以创建一个dvi格式的说明文档，以说明该宏包的功能。

   3) 安装文件
      此步是最关键的一步，也是容易出错的一步。此步骤的作用是将生成的必
      需文件，如cls文件和sty文件放到合适的本地位置，以便Latex发行版能
      够找到。

      在Tex及其衍生物中，所谓合适的本地位置，就是以 *TDS* (Tex
      Directory Structure)规则组织的文件夹及其子文件夹，也就是一个自定
      义的目录。一般情况，这个自定义的目录最上层的名字为texmf-local或
      者texmf。在不同的发行版本下，具体也不一样.

      TDS定义了不同类型的文件存放的位置不同。比如sty格式文件，一般放在
      texmf/tex/latex下不同的文件夹下，文件夹的名字即是宏包的名字。下
      面的表格中给出了文件存放的规则：

      |--------+---------------------------------+---------------------------------------|
      | Type   | Directory (under texmf/         | Description                           |
      |        |  or texmf-local/)               |                                       |
      |--------+---------------------------------+---------------------------------------|
      | .afm   | fonts/afm/foundry/typeface      | Adobe Font Metrics for Type 1 fonts   |
      | .bst   | bibtex/bst/packagename          | BibTeX style                          |
      | .cls   | tex/latex/base                  | Document class file                   |
      | .dvi   | doc                             | package documentation                 |
      | .enc   | fonts/enc                       | Font encoding                         |
      | .fd    | tex/latex/mfnfss                | Font Definition files for METAFONT    |
      | fonts  |                                 |                                       |
      | .fd    | tex/latex/psnfss                | Font Definition files for PostScript  |
      |        |                                 | Type 1 fonts                          |
      | .map   | fonts/map/                      | Font mapping files                    |
      | .mf    | fonts/source/public/typeface    | METAFONT outline                      |
      | .pdf   | doc                             | package documentation                 |
      | .pfb   | fonts/type1/foundry/typeface    | PostScript Type 1 outline             |
      | .sty   | tex/latex/packagename           | Style file: the normal package        |
      |        |                                 | content                               |
      | .tex   | doc                             | TeX source for package documentation  |
      | .tex   | tex/plain/packagename           | Plain TeX macro files                 |
      | .tfm   | fonts/tfm/foundry/typeface      | TeX Font Metrics for METAFONT and     |
      |        |                                 | Type 1 fonts                          |
      | .ttf   | fonts/truetype/foundry/typeface | TrueType font                         |
      | .vf    | fonts/vf/foundry/typeface       | TeX virtual fonts                     |
      | others | tex/latex/packagename           | other types of file unless instructed |
      |        |                                 | otherwise                             |
      |--------+---------------------------------+---------------------------------------|

   4) 更新索引

      最后更新Latex发行版的索引文件，以便Latex发行版能找到新安装的
      宏包。不同的发行版使用了不同的索引器.

   5) 更新字体映射图

      如果一个宏包还顺带安装了一些字体，还应该更新字体的映射[[http://www.tug.org/fonts/fontinstall.html][here]].

*** latex 宏包编写与解包
**** 编写宏包
1. 目的: 广泛传播和正确使用并便于他人修改完善
2. 要求: 包程序应当易于阅读
   1) 在编写宏包时，总要先说明编写的原因、目的和用途，
   2) 然后开始编写具体宏命令程序；
   3) 在一些繁琐复杂的内部命令处，附加详细的注释；
   4) 专门提供给用户使用的命令或环境，都给出使用说明，
   5) 或举例说明使用方法。
3. 最终写成的宏包文件是合三为一的程序说明文件，这种编程方式被称作文学
   化编程.
   + 宏命令程序
   + 程序说明
   + 使用说明
4. 应用
   在实际应用中
   + 有些人出于研究借鉴的目的对这种合成文件很感兴趣
   + 有些人只想看看该宏包的说明
   + 更多的人只关心宏包的使用。
**** 辅助编写的工具宏包
1. *doc*: 编写宏包文件的宏包，它定义了一组宏包文件编辑环境和命令
2. *ltxdoc*: 用于排版 LaTeX 源文件的类型文件包
3. *docstrip*: 文件分解工具，定义了一组文件输入和分类创建命令。
**** 使用
1. 文件后缀说明
   1) *.dtx*: 包含类或宏包及其说明文件的文件，需用同名.ins文件或
      docstrip工具分解。
   2) *.ins*: 同名.dtx的分解文件，用PDFLATEX编译，可得到sty或cls等类型
      文件。
   3) *.sty*: 宏包文件，可用命令 \textbackslash{}usepackage调用。
   4) *.cls*: 稿件类型文件，可用命令 \textbackslash{}documentclass调用。
   5) *.cfg*: 供类包或宏包调用的配置文件
   6) *.bib*: 文献数据库
2. 生成说明文档

   *$ pdf file.dtx*

   运行 PDFLaTeX 编译 iuthesis.dtx，得到 iuthesis.pdf，用 Adobe 打开，
   这是一篇包括 iuthesis 类包程序及其说明的程序说明文件，说明章节和每
   行命令都有分类序号，这既便于程序阅读又不影响日后程序或说明的修改升
   级。有些复杂的程序说明文件还有目录、索引和术语表等，也就是说 LaTeX
   的所有功能都可以在此体现。

3. 仅类包的说明文字

   在dtx文件导言区加入 \textbackslash{}OnlyDescription 命令，再用
   PDFLaTeX 编译dtx文件，得到的pdf文件中就只有该类包的说明文字了。

4. 生成宏包命令程序

   1) 调用 docstrip 工具，分解dtx文件。运行 latex docstrip

   2) 用 PDFLaTeX 对其编译ins文件，就会自动创建类包文件cls文件。

      其实*.ins 安装文件的内容非常简单，主要就两句话.

   3) 说明

      很多大型程序说明文件的源文件.dtx 含有类包程序.cls、宏包程序
      .sty、说明或格式程序.tex 和配置程序.cfg 等多种程序，使用.ins
      安装文件的好处就在于它能够一次性自动地完成对.dtx 文件的分类重建
      工作。本例就同时还分解出 iuthesis.tex，经编译后得到的 PDF 文件中
      只有该类包的说明。

      很多数情况.dtx 和.ins 都是成对出现的；如果找不到.ins，可以打
      开.dtx 文件，根据里面的各种程序界定标记，使用第一种方法手工解包。
      现在有很多.dtx 文件已将.ins 的内容并入其中，这样用 PDFLaTeX 对
      其编译，就会自动同时创建出程序说明文件.pdf 和宏包文件.sty 或类
      包文件.cls 等相关文件。

*** DONE latex2html: LaTeX 转成 Word
DEADLINE: <2015-03-08 日>
- State "DONE"       from "waiting"    [2015-03-09 一 19:45] \\
  掌握基本使用,有待研究细节,参考手册,了解常用控制选项的使用
- State "waiting"    from ""           [2015-02-26 四 15:00] \\
  latex2html安装文件太大,需要返校之后安装.
参考:
+ [[http://zhidao.baidu.com/link?url=81iKOAaTCNYG0-Wej-I2TwGNHmTBytvj7M6GeEpb1KdHWqUE1eqLyQtYcdZqjtnlc97r3bSZyg1ZEAOAsORhuox3q33i3PdbEug-d2AmX6u][百度知道]]
+ [[http://bbs.ctex.org/forum.php?mod=viewthread&tid=7861][ctex latex2html中文]]
+ [[http://www.latex2html.org/][latex2html HOMEPAGE]]

**** why
论文给导师修改又产生了很多麻烦。PDF上直接加Note可读性很差。最好还是能
尽量保持公式、图形、Reference的完整性，然后直接转成Word，然后导师在
Word上用审阅模式修改，我们自己在Latex对应修改。这样导师就不用面对丑陋
的Latex源码了。
**** how
简单的说，我们可以这样做：
1) 我们用Latex书写论文
2) 我们转成Word给导师
3) 导师使用Word的审阅功能，修改论文
4) 我们对照修改的地方直接修改Latex
5) 最后生成修改后的PDF。

以Ubuntu的Linux系统如下：
1. 安装Latex: sudo apt-get install texlive
2. 安装latex2html: sudo apt-get install latex2html
3. 把论文从Latex转换为html: *latex2html -split +0 input.tex*
   (input.tex是我们的论文tex文件)
4. 这时在当前目录下多出一个input目录，大家可以弄到Windows里。（相信大
   家都有一个Linux的远程机器）
5. 这个目录就是所有的html文件，找到index.html，右键用Word打开。
6. 在word里另存为.doc或者docx文件。
7. 把word文档发给导师，等那些让人心惊肉跳的红字和note吧。。。

大功告成，这样比Acrobat Pro转为word文档在格式上更加安全。所有公式、图
片、表格、算法都会被变为图片或者相应格式，在word里显示没有任何问题。

(注意：使用这种办法，要求你的tex可以在latex编译出dvi没有问题，也就是说
使用eps图片的没有问题，但是使用pdf，jpg图片格式的，由于使用pdflatex命
令编译出PDF。这个方法就不行了，需要手动改一下html文件)。

（EPS[fn:1502261439]图片问题，我一般使用ImageMagic去批处理的转jpg，pdf
到eps，然后在tex文件里引用eps图片，这样就规避了无论用pdflatex或者latex
都可以编译出正确的pdf和dvi，那么Latex2html就没有任何问题了）

**** latex2html
***** what
LATEX2HTML is a convertor written in Perl that converts LATEX
documents to HTML. This way e.g. scientific papers - primarily typeset
for printing - can be put on the Web for online viewing.

LATEX2HTML does also a good job in rapid web site deployment. These
pages are generated from a single LATEX source.

It is designed to run on UNIX-like systems (e.g. Linux, Solaris, IRIX,
Dec Unix, HP-UX, AIX) as well as Windows (95, 98, NT)
***** 下载
+ A Perl program
+ translates LATEX into HTML
+ optionally creating separate HTML files corresponding toeach unit
  (e.g., section) of the document.

LATEX2HTML proceeds by interpreting LATEX (to the best of its
abilities). It contains definitions from a wide variety of
classes and packages, and users may add further definitions by
writing Perl scripts that provide information about
class/package commands.
[[http://www.ctan.org/pkg/latex2html/][ctan:latex2html]]
***** 使用
****** 中文问题
直接使用命令行 *latex2html src.tex* 生成的html文档存在中文乱码的问题,
需要进行设置.
latex2html支持中文: CJK 和 Ctex。
+ 在工作目录下建立文件 “.latex2html-init”
+ 在其中写入： *$charset = gb2312*
+ 2. 增加一些编译选项(注:不加也行):
  *latex2html -iso_language CN -html_version 4.0,unicode src.tex*
+ 注意另一个微妙的事情：若你的源文件是在DOS/Windows 所写的，空行可能不
  被识别为段分割。你可以使用 dos2unix把你的源文件处理一下。

*** DONE LaTeX 转成 Word
DEADLINE: <2015-03-08 日>
- State "DONE"       from "waiting"    [2015-03-10 二 00:59]
- State "waiting"    from ""           [2015-02-26 四 15:00] \\
  latex2html安装文件太大,需要返校之后安装.
参考:
+ [[http://zhidao.baidu.com/link?url=81iKOAaTCNYG0-Wej-I2TwGNHmTBytvj7M6GeEpb1KdHWqUE1eqLyQtYcdZqjtnlc97r3bSZyg1ZEAOAsORhuox3q33i3PdbEug-d2AmX6u][百度知道]]
+ [[http://blog.sina.com.cn/s/blog_4d72d6e70100otue.html][latex2html配置windows下]]
+ [[http://www.latex2html.org/][latex2html HOMEPAGE]]

**** why
论文给导师修改又产生了很多麻烦。PDF上直接加Note可读性很差。最好还是能
尽量保持公式、图形、Reference的完整性，然后直接转成Word，然后导师在
Word上用审阅模式修改，我们自己在Latex对应修改。这样导师就不用面对丑陋
的Latex源码了。
**** how
简单的说，我们可以这样做：
1) 我们用Latex书写论文
2) 我们转成Word给导师
3) 导师使用Word的审阅功能，修改论文
4) 我们对照修改的地方直接修改Latex
5) 最后生成修改后的PDF。

以Ubuntu的Linux系统如下：
1. 安装Latex: sudo apt-get install texlive
2. 安装latex2html: sudo apt-get install latex2html
3. 把论文从Latex转换为html: *latex2html -split +0 input.tex*
   (input.tex是我们的论文tex文件)
4. 这时在当前目录下多出一个input目录，大家可以弄到Windows里。（相信大
   家都有一个Linux的远程机器）
5. 这个目录就是所有的html文件，找到index.html，右键用Word打开。
6. 在word里另存为.doc或者docx文件。
7. 把word文档发给导师，等那些让人心惊肉跳的红字和note吧。。。

大功告成，这样比Acrobat Pro转为word文档在格式上更加安全。所有公式、图
片、表格、算法都会被变为图片或者相应格式，在word里显示没有任何问题。

(注意：使用这种办法，要求你的tex可以在latex编译出dvi没有问题，也就是说
使用eps图片的没有问题，但是使用pdf，jpg图片格式的，由于使用pdflatex命
令编译出PDF。这个方法就不行了，需要手动改一下html文件)。

（EPS[fn:1502261439]图片问题，我一般使用ImageMagic去批处理的转jpg，pdf
到eps，然后在tex文件里引用eps图片，这样就规避了无论用pdflatex或者latex
都可以编译出正确的pdf和dvi，那么Latex2html就没有任何问题了）

**** latex2html
***** what
LATEX2HTML is a convertor written in Perl that converts LATEX
documents to HTML. This way e.g. scientific papers - primarily typeset
for printing - can be put on the Web for online viewing.

LATEX2HTML does also a good job in rapid web site deployment. These
pages are generated from a single LATEX source.

It is designed to run on UNIX-like systems (e.g. Linux, Solaris, IRIX,
Dec Unix, HP-UX, AIX) as well as Windows (95, 98, NT) systems.

>>>>>>> f82386b584a83dd6cc85a4bedd2ca78f13409ffc
*** ctan                                                             :ctan:

+ [[http://www.ctan.org/][Ctan homepage]]

CTAN是“Comprehensive TeX Archive Network”的首字缩写，为世界上最主要
的TeX资源集散网站，搜集了关于TeX的各种文件与软件等等。Perl的资源集散网
站CPAN即是基于CTAN的模式诞生与运作。

*** LaTeX PDF 动画                                               :pdf:动画:
+ http://pages.uoregon.edu/noeckel/PDFmovie.html
+ http://bbs.ctex.org/forum.php?mod=viewthread&tid=38009

*** TeX 文件后缀说明
**** 配置文件

|------+----------------------------------------------------------------------|
| .afm | Adobe Type1字体描述文件，ASCII格式。                                 |
|------+----------------------------------------------------------------------|
| .bak | 备份文件，当源文件.tex存盘时由系统自动创建。                         |
|------+----------------------------------------------------------------------|
| .bib | 文献数据库。                                                         |
|------+----------------------------------------------------------------------|
| .cfg | 供类包或宏包调用的配置文件。                                         |
|------+----------------------------------------------------------------------|
| .cls | 稿件类型文件，可用命令\documentclass调用。                           |
|------+----------------------------------------------------------------------|
| .doc | 类包或宏包的说明文件。                                               |
|------+----------------------------------------------------------------------|
| .dtx | 包含类或宏包及其说明文件的文件，需用同名.ins文件或docstrip工具分解。 |
|------+----------------------------------------------------------------------|
| .fd  | 字体定义文件，定义某一字族，用于 \LaTeX 字体寻找。                   |
|------+----------------------------------------------------------------------|
| .ins | 同名.dtx的分解文件，用PDF \LaTeX 编译，可得到sty或cls等类型文件。    |
|------+----------------------------------------------------------------------|
| .map | 字体名称与.tfm文件之间的字体映射文件。                               |
|------+----------------------------------------------------------------------|
| .mbs | 主控文件，包含全部文献样式命令，用于生成.bst文献样式文件。           |
|------+----------------------------------------------------------------------|
| .mf  | METAFONT字体描述文件，Knuth教授创立的矢量字体。                      |
|------+----------------------------------------------------------------------|
| .pfa | Type 1字体文件，ASCII格式，一种高品质矢量字体，越放大越清晰。        |
|------+----------------------------------------------------------------------|
| .pfb | Type 1字体文件，二进制格式。                                         |
|------+----------------------------------------------------------------------|
| .pk  | pk字体，一种点阵字体，用于dvi文件预览等。                            |
|------+----------------------------------------------------------------------|
| .pl  | 字体属性列表，可读的字体描述文件。                                   |
|------+----------------------------------------------------------------------|
| .sfd | 子字库定义文件。                                                     |
|------+----------------------------------------------------------------------|
| .sty | 宏包文件，可用命令 \textbackslash{}usepackage调用。                                 |
|------+----------------------------------------------------------------------|
| .tex | \LaTeX 源文件。                                                      |
|------+----------------------------------------------------------------------|
| .tfm | 字体描述文件，设定字体的宽、高和间距等， \LaTeX 用以规划页面。       |
|------+----------------------------------------------------------------------|
| .ttf | Truetype字体，Windows系统使用的一种全真字体。                        |
|------+----------------------------------------------------------------------|
| .vf  | TEX虚拟字体                                                          |
|------+----------------------------------------------------------------------|
| .vpl | 虚拟属性列表，可读的虚拟字体文件。                                   |
|------+----------------------------------------------------------------------|


**** 在源文件编译过程中创建的文件

|----+---------------------------------------------------------|
|.aux| 引用标记记录文件，用于再次编译时生成参考文献和超链接等。|
|----+---------------------------------------------------------|
|.bbl| .blg 由BibTEX编辑.bib后创建的文献文件，再次编译时带入源文件生成文献列表。|
|----+--------------------------------------------------------------------------|
|BibTEX|处理过程记录文件。|
|------+------------------|
|.dbj| 批处理文件，由makebst工具在创建.bst文献样式文件时生成。|
|----+--------------------------------------------------------|
|.dvi| 由 \LaTeX 对.tex源文件编译后创建的输出文件，含有字库信息。|
|----+-----------------------------------------------------------|
|.glo| 术语标记记录文件，用于再次编译时生成术语表。|
|----+---------------------------------------------|
|.idx| 索引资料记录文件，可用makeindex排序后创建索引文件.ind。|
|----+--------------------------------------------------------|
|.ilg| makeindex处理过程记录文件。|
|----+----------------------------|
|.ind| makeindex对.idx排序后创建的索引文件，再次编译时带入源文件生成索引。|
|----+--------------------------------------------------------------------|
|.lof| 图形标题记录文件，用于再次编译时生成图形目录。|
|----+-----------------------------------------------|
|.log| 编译过程记录文件，记录编译时出现的提示、警告和错误信息。|
|----+---------------------------------------------------------|
|.lot| 表格标题记录文件，用于再次编译时生成表格目录。|
|----+-----------------------------------------------|
|.pdf| 由PDF \LaTeX 对.tex或dvipdf对.dvi或pspdf对.ps编译后创建的图形文件。|
|----+--------------------------------------------------------------------|
|.ps| 由dvips对.dvi文件编译后创建的图形文件。|
|---+----------------------------------------|
|.toc| 章节标题记录文件，用于再次编译时生成章节目录。|
|----+-----------------------------------------------|

*** Can we make a love heart with LaTeX

+
  http://tex.stackexchange.com/questions/139733/can-we-make-a-love-heart-with-latex

[[/home/ben/Wally/Journal//Figure/scrot/2959ite.png]]

** Note
*** tipa宏包是用来排版国际音标的，使用tipa宏包可能会与数学公式有所冲突

** ctex
*** ctex字体 font-not-found winfonts, 不推荐

参考: [[http://albertcn.blog.163.com/blog/static/2094201452013521105128316/#crayon-51c3bb178fb44797891969-7][font-not-found]]

#+BEGIN_EXAMPLE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! fontspec error: "font-not-found"
!
! The font "[SIMKAI.TTF]" cannot be found.
!
! See the fontspec documentation for further information.
!
! For immediate help type H &lt;return&gt;.
!...............................................
#+END_EXAMPLE

解决方案: 修改texlive的ctex包的配置文件：

*/usr/local/texlive/2014/texmf-dist/tex/latex/ctex/fontset/ctex-xecjk-winfonts.def*

** TeXLive                                                         :texlive:
*** [[http://seisman.info/install-texlive-under-linux.html][Linux下安装TeXLive 2015]]                                       :install:
**** [[#id8][依赖包]]

-  安装过程中需要调用Perl的模块 =Digest::MD5= 来检测ISO文件的完整性；
-  升级过程中界面需要调用Perl的模块 =Tk= ；

CentOS:

#+BEGIN_EXAMPLE
    $ sudo yum install perl-Digest-MD5 perl-Tk
#+END_EXAMPLE

Ubuntu:

#+BEGIN_EXAMPLE
    $ sudo apt-get install libdigest-perl-md5-perl perl-tk
#+END_EXAMPLE

**** [[#id9][安装]]

***** [[#id10][下载]]

下载地址：

-  官方镜像:
   [[http://mirrors.ctan.org/systems/texlive/Images/texlive2015.iso]]
-  USTC镜像：
   [[http://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/texlive2015.iso]]

Linux下可以用wget、axel，windows下可以用迅雷，怎么快怎么来。

***** [[#id11][挂载ISO镜像]]

 #+BEGIN_EXAMPLE
     $ su
     # mount -o loop texlive2015.iso  /mnt/
     # cd /mnt
     # ./install-tl
 #+END_EXAMPLE


出现选项后，输入 =I=
直接安装（也可以更改选项）。不出意外的话，5分钟应该就OK了，然后退出root用户。

***** [[#id12][环境变量]]

在当前用户的 =~/.bashrc= 中加入如下语句：

 #+BEGIN_EXAMPLE
     # TeX Live 2015
     export MANPATH=${MANPATH}:/usr/local/texlive/2015/texmf-dist/doc/man
     export INFOPATH=${INFOPATH}:/usr/local/texlive/2015/texmf-dist/doc/info
     export PATH=${PATH}:/usr/local/texlive/2015/bin/x86_64-linux
 #+END_EXAMPLE


***** [[#id13][卸载ISO镜像]]

 #+BEGIN_EXAMPLE
     1
     2
 #+END_EXAMPLE

 #+BEGIN_EXAMPLE
     $ cd
     $ sudo umount /mnt/
 #+END_EXAMPLE

**** [[#id14][更新TeXLive]]

可以使用如下命令更新TeXLive宏包：


 #+BEGIN_EXAMPLE
     $ su
     # 更新TeXLive包管理器tlmgr
     # tlmgr update --self
     # 更新TeXLive的全部包
     # tlmgr update --all
 #+END_EXAMPLE


默认情况下，会自动搜索合适的镜像来更新，也可以使用 =--repository=
选项指定了要使用哪一个CTAN镜像。

比如USTC镜像:

#+BEGIN_EXAMPLE
    # tlmgr update --self --repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet/
    # tlmgr update --all --repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet/
#+END_EXAMPLE

比如阿里云镜像:

#+BEGIN_EXAMPLE
    # tlmgr update --self --repository http://mirrors.aliyun.com/CTAN/systems/texlive/tlnet/
    # tlmgr update --all --repository http://mirrors.aliyun.com/CTAN/systems/texlive/tlnet/
#+END_EXAMPLE

如果希望在图形界面下升级，可以使用如下命令调出tlmgr的中文图形界面：

 #+BEGIN_EXAMPLE
     $ su
     # tlmgr --gui --gui-lang zh_CN
 #+END_EXAMPLE

**** [[#id15][安装额外的字体]]

TeXLive 2015在使用xeLaTeX处理中文时，有自己的默认字体。大多数Linux发行版下，都使用自带的Fandol字体。

如果想要使用Windows字体，可以将字体文件复制到 =~/.fonts=
目录下，并在tex源码中指定字体选项即可。

*.local/share/fonts 文件夹*

**** [[#id16][修订历史]]

-  2013-07-11：初稿；
-  2014-07-06：修改为TeXLive2014，并删除中文字体部分；
-  2015-03-08：新增“安装依赖”；
-  2015-03-15：使用命令行更新包；
-  2015-03-20：指定更新源以及GUI更新；
-  2015-06-13：更新至TeXLive 2015；

So what do you think? Did I miss something? Is any part unclear? Leave
your comments below.

[[http://seisman.info/install-texlive-under-linux.html#disqus_thread][Comments]]

Please enable JavaScript to view the
[[http://disqus.com/?ref_noscript][comments powered by Disqus.]]

[[http://disqus.com][comments powered by Disqus]]

--------------

**** Related Posts:

-  [[http://seisman.info/terms-about-tex.html][与TeX相关的一些名词]]
-  [[http://seisman.info/perl-plenv.html][Perl多版本共存之plenv]]
-  [[http://seisman.info/install-gmt5-under-linux.html][GMT 5.1.2在Linux下的安装]]
-  [[http://seisman.info/mini-template-for-xeCJK.html][使用xeCJK解决中文问题的最小模板]]
-  [[http://seisman.info/install-gmt5-under-windows.html][GMT 5.1.2在Windows下的安装]]

*** 文档位置

1. /usr/local/texlive/2014/texmf-dist/tex/latex/

2. 修改读写权限

   #+BEGIN_EXAMPLE
   sudo chmod -R a+w /usr/local/texlive/2014/texmf-dist/tex/latex/
   #+END_EXAMPLE

*** TeXLive安装与卸载                                           :uninstall:
[[http://tex.stackexchange.com/questions/95483/how-to-remove-everything-related-to-tex-live-for-fresh-install-on-ubunt][卸载]]
[[http://www.tug.org/texlive/acquire.html][org-download]]
[[http://www.cnblogs.com/lienhua34/p/3675027.html][安装]]: 包含中文配置,比较翔实
[[https://wiki.archlinux.org/index.php/TeXLive_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)][texlive-archlinux]]
[[http://www.xuebuyuan.com/1673310.html][宏包安装]]
texlive安装包默认携带了ctex宏包,目录为
/usr/local/texlive/2014/texmf-dist/tex/latex/ctex
默认ctex包使用window字体,因而在Linux中会导致编译失败,所以要对ctex进行
字体配置.
ctex宏包提供三个字体选项:nonfonts, adobefonts和winfonts,默认使用的是
winfonts.如果tex源文件中没有使用其他选项修改字体配置,则需要操作系统安
装有中文Windows操作系统自带的四种TrueType字体:宋体(simsum),黑体
(simhei),仿宋体(simfang),楷体(simkai).
如果使etadobefonts选项,则需要操作系统安装Adobe公司的四种OpenType字
体:Adobe 宋体, Adobe 黑体, Adobe 仿宋, Adobe 楷体.

nonfonts选项使用Ubuntu自带字体.
#+BEGIN_EXAMPLE
%% mylinuxfonts.sty
\ProvidesPackage{mylinuxfonts}
\setCJKmainfont[ItalicFont={AR PL UKai CN}]{AR PL UMing CN} %设置中文默认字体
\setCJKsansfont{WenQuanYi Zen Hei}
\setCJKmonofont{WenQuanYi Zen Hei Mono}
\endinput
#+END_EXAMPLE

*** 字体

[[http://www.cnblogs.com/lienhua34/p/3675027.html][安装]]: 包含中文配置,比较翔实

texlive安装包默认携带了ctex宏包,目录为
/usr/local/texlive/2014/texmf-dist/tex/latex/ctex
默认ctex包使用window字体,因而在Linux中会导致编译失败,所以要对ctex进行
字体配置.
ctex宏包提供三个字体选项:
+ nonfonts
+ adobefonts
+ winfonts, 默认使用winfonts.如果tex源文件中没有使用其他选项修改字体配
  置,则需要操作系统安装有中文Windows操作系统自带的四种TrueType字体:宋
  体(simsum),黑体(simhei),仿宋体(simfang),楷体(simkai).

如果使etadobefonts选项,则需要操作系统安装Adobe公司的四种OpenType字
体:Adobe 宋体, Adobe 黑体, Adobe 仿宋, Adobe 楷体.

nonfonts选项使用Ubuntu自带字体.
e.g.
#+BEGIN_EXAMPLE
\documentclass[nofonts]{ctexart}
\setCJKmainfont[ItalicFont={AR PL UKai CN}]{AR PL UMing CN} %设置中文默认字体
\setCJKsansfont{WenQuanYi Zen Hei}
\setCJKmonofont{WenQuanYi Zen Hei Mono}
\begin{document}
您好, \LaTeX!
你好,中文!
\end{document}
#+END_EXAMPLE

设置成模板文件(todo: )
#+BEGIN_EXAMPLE
%% mylinuxfonts.sty
\ProvidesPackage{mylinuxfonts}
\setCJKmainfont[ItalicFont={AR PL UKai CN}]{AR PL UMing CN} %设置中文默认字体
\setCJKsansfont{WenQuanYi Zen Hei}
\setCJKmonofont{WenQuanYi Zen Hei Mono}
\endinput
#+END_EXAMPLE
*** TeXLive拾遗

#+BEGIN_SRC latex
在texlive安装目录(/usr/local/texlive/2014/)下,有\textbf{doc.html}文档
该文档中包含所有安装包的帮助文档索引.
#+END_SRC

** listing                                                         :listing:
http://blog.sina.com.cn/s/blog_5e16f1770100fw83.html
http://blog.sina.com.cn/s/blog_5e16f1770100nwi5.html

*** 博客教程
listings 是专用于代码排版的 LaTeX 宏包，可对关键词、注释和字符串等使用不同的
字体和颜色或颜色，也可以为代码添加边框、背景等风格。

1. 基本用法

   注意，要使用 listings 宏包提供的语法高亮，需要 xcolor 宏包支持。

2. 边框

   listings宏包为代码边框提供了很多风格，大体可分为带有阴影的边框与圆
   角边框。这里仅仅给出一个阴影边框的示例，至于其它边框风格，可查阅
   listings 宏包文档，里面给出了一些示例。

*** Listings Manual
**** Typesetting listings
1. Code snippets: \textbackslash{}lstinline
2. Displayed code: lstlisting environment
3. Stand alone file: \textbackslash{}lstinputlisting
**** Software license
LaTeX Project Public License
**** Package loading
+ \textbackslash{}usepackage[options]{listings}
+ \textbackslash{}lstloadlanguages{commma-sperated-list-of-languages}
  + language form: [dialect]language
  + examples
    - C++(ANSI, GNU, ISO, Visual)
    - C(ANSI, Handel, Objective, Sharp)
    - bash
    - Octave
    - Pythone

*** lstlisting 选项
+ language=[ANSI]C,               % 程序语言名称
+ basicstyle=\footnotesize,       % 基本字体的字号
+ numbers=left,                   % 行号位置
+ numberstyle=\footnotesize,      % 行号字体的字号
+ stepnumber=2,                   % 行号的显示步长
+ numbersep=5pt,                  % 行号与代码间距
+ showspaces=false,               % 显示空格
+ showstringspaces=false,         % 字符串中显示空格
+ showtabs=false,                 % 显示 TAB
+ frame=single,                   % 显示边框
+ tabsize=2,                      %  TAB 被当作两个空格
+ captionpos=b,                   % 标题位置
+ breaklines=false,               % 自动断行
+ breakatwhitespace=false,        % 断行只在空格处
+ escapeinside={\%*}{*)}          % 添加注释，暂时离开 listings
+ extendedchars=false
+ frame=shadowbox, %把代码用带有阴影的框圈起来
+ commentstyle=\color{red!50!green!50!blue!50},%浅灰色的注释
+ rulesepcolor=\color{red!20!green!20!blue!20},%代码块边框为淡青色
+ keywordstyle=\color{blue!90}\bfseries, %代码关键字的颜色为蓝色，粗体
+ showstringspaces=false,%不显示代码字符串中间的空格标记
+ stringstyle=\ttfamily, % 代码字符串的特殊格式
+ keepspaces=true, %
+ breakindent=22pt, %
+ numbers=left,%左侧显示行号
+ stepnumber=1,%
+ numberstyle=\tiny, %行号字体用小号
+ basicstyle=\footnotesize, %
+ showspaces=false, %
+ flexiblecolumns=true, %
+ breaklines=true, %对过长的代码自动换行
+ breakautoindent=true,%
+ breakindent=4em, %
+ aboveskip=1em, %代码块边框 %% added by
+ fontadjust,
+ captionpos=t,
+ framextopmargin=2pt,framexbottommargin=2pt,abovecaptionskip=-3pt,belowcaptionskip=3pt,
+ xleftmargin=4em,xrightmargin=4em, % 设定listing左右的空白
+ texcl=true  % 设定中文冲突，断行，列模式，数学环境输入，listing数字的样式
+ extendedchars=false,columns=flexible,mathescape=true
+ % numbersep=-1em

*** XML
listing宏包支持XML高亮显示,  but the definition are preliminary（初步
的， 预备的），所以需要进行进一步的配置
#+BEGIN_EXAMPLE
  \definecolor{gray}{rgb}{0.4,0.4,0.4}
  \definecolor{darkblue}{rgb}{0.0,0.0,0.6}
  \definecolor{cyan}{rgb}{0.0,0.6,0.6}

  \lstdefinelanguage{XML}{
      morestring=[b]",
      morestring=[s]{>}{<},
      morecomment=[s]{<?}{?>},
      stringstyle=\color{black},
      identifierstyle=\color{darkblue},
      keywordstyle=\color{cyan},
      morekeywords={xmlns,version,type}% list your attributes here
      *此处不能有空行*
  }
  \lstnewenvironment{XML}[1][]{
    \lstset{
      language=XML,
      basicstyle=\ttfamily,
      columns=fullflexible,
      showstringspaces=false,
      commentstyle=\color{gray}\upshape *逗号少了*
      framexleftmargin=1mm,
      framextopmargin=1mm,
      frame=shadowbox,
      rulesepcolor=\color{blue},#1, *逗号多了*
    }
  }{}
#+END_EXAMPLE

#+BEGIN_SRC latex
    \begin{XML}
      <person age="22" sex="female">Ann</person>
    \end{XML}

     % \begin{minted}{xml}
     %   <xml>
     %   <person age="22" sex="female">Ann</person>
     %   <\xml>
     % \end{minted}
#+END_SRC




minted宏包也可以
** algorithm2e                                                 :algorithm2e:
*** 宏包： *algorithm2e*
+ 环境： *algorithm*
+ 选项
  - boxed 边框
  - lined 在某一算法的起始与结束之间排印一条垂直线，以标示作用范围
  - linesnumbered 增加行号，不包括注释
  - vlined 同lined
+ 算法环境被定义为浮动环境
  #+BEGIN_EXAMPLE
    \begin{algorithm}[位置]
    算法
    \end{algorithm}
  #+END_EXAMPLE
+ 位置选项
  - 同浮动环境table相同
  - H 强制将算法内容就地放置
  - algorithm* 双栏格式中跨栏编排

*** 命令
**** 基本命令

[[/home/ben/Wally/Journal/Figure/scrot/6757est.png]]

**** 标题命令

[[/home/ben/Wally/Journal/Figure/scrot/6757dAD.png]]

**** 输入输出命令

[[/home/ben/Wally/Journal/Figure/scrot/6757qKJ.png]]

[[/home/ben/Wally/Journal/Figure/scrot/67573UP.png]]

**** 条件命令

[[/home/ben/Wally/Journal/Figure/scrot/6757EfV.png]]

**** 关键词命令

[[/home/ben/Wally/Journal/Figure/scrot/6757Rpb.png]]

*** Example
#+BEGIN_SRC latex
  \begin{algorithm}[ht]
    \KwData{a, b, c, i: integer}
    \Begin{
      clrscr\;
      \For{i:=100 \KwTo 999}{
        c:=i mod 10; \tcp{取个位数}
        b:=(i div 10) mod 10 \;
        a:=i dvi 100\;
        \If{i=a*a*a+b*b*b+c*c*c}{writeln{i:6}}
      }
    }
  \end{algorithm}
#+END_SRC
*** LaTeX algorithm2e if else if else
\textbackslash{}uIf
\textbackslash{}uElseIf
\textbackslash{}Else

[[/home/ben/Wally/Journal/Figure/scrot/15486GUj.png]]
[[/home/ben/Wally/Journal/Figure/scrot/15486Tep.png]]

*** DONE algorithm2e 什么错误
- State "DONE"       from "TODO"       [2015-11-05 四 14:59]

答案： *下划线*,  /algorithm环境中不能下划线？？？/
#+BEGIN_EXAMPLE
  \begin{algorithm}
    \textbf{FIND\_CYLINDERS(scan, jump)}
    \KwIn{scan: 扫描线数组，每个元素对应一个距离信息, jump: 微分的跳动阈
      值}
    \KwOut{cylinders: 特征点结构数组，每个元素对应一个包含索引和距离
      的结构}
    on_cylinder = FALSE
    sum_ray = 0
    sum_index = 0\tcp{索引和}
    sum_depth = 0\tcp{距离和}
    cylinders=[]
    n = 0                         % 特征点个数
    derivate=COMPUTE_DERIVATIVES(scan)
    \For{i=1 \KwTo scan.length}{
      \If{derivative[i] < -jump\tcp{下降沿，开始计数}}{
        sum_ray = 0
        sum_index = 0
        sum_depth = 0
        on_cylinder = TRUE
      }
      \tcp{注意条件分支结构}
      \eIf{derivate[i] > jump AND on_cylinder \tcp{上升沿，结束计数}}{
        n = n+1
        cylinders[i]=struct(sum_index/sum_ray, sum_depth/sum_ray)
      }{
        \If{scan[i] > mindist}{
          sum_ray = sum_ray+1
          sum_index = sum_index+i
          sum_depth = sum_depth+scan[i]
        }
      }
    }
    \Return{cylinders}
  \end{algorithm}
#+END_EXAMPLE

*** DONE algorithm2e escape-math
- State "DONE"       from "TODO"       [2015-12-08 二 13:10]

[[~/Document/Programming/TeX/doc/algorithm2e.pdf][algorithm2e]]

algorithm环境内直接支持 数学模式

非宏开头的行要以 /=\;=/ 结束

在 /数学模式 =$$=/ 下可以使用下划线

** Minted                                                           :minted:
*** DONE Minted宏包配置
- State "DONE"       from "TODO"       [2015-11-08 日 15:46]
*支持许多种语言*

! Package minted Error: You must have `pygmentize' installed to use
this package.
! LaTeX Error: File `journal.pyg' not found.

! Package minted Error: You must invoke LaTeX with the -shell-escape
flag.


暂时不知道原因
可能是某个软件安装或配置问题，也可能是某个宏包没有安装的问题


需要注意的是，运行的时候需要加一个参数即： *-shell-escape*  ，如若是使
用pdflatex编译，即：pdflatex -shell-escape  filename

也就是说, 直接使用Emacs tex-mode 默认的命令会出现错误。

**** AucTeX+Minted
http://stackoverflow.com/questions/3300497/using-minted-source-code-latex-package-with-emacs-auctex

#+BEGIN_SRC emacs-lisp
  ;; not work, not know why
  ;; (add-hook 'TeX-mode-hook
  ;;   (lambda ()
  ;;     (setq TeX-command-extra-options "-shell-escape")
  ;;   )
  ;;   )

  (eval-after-load "tex"
    '(setcdr (assoc "LaTeX" TeX-command-list)
            '("%`%l%(mode) -shell-escape%' %t"
            TeX-run-TeX nil (latex-mode doctex-mode) :help "Run LaTeX")
      )
    )
#+END_SRC

#+begin_latex
\begin{minted}{lisp}
;; not work, not know why
;; (add-hook 'TeX-mode-hook
;;   (lambda ()
;;     (setq TeX-command-extra-options "-shell-escape")
;;   )
;;   )

(eval-after-load "tex"
  '(setcdr (assoc "LaTeX" TeX-command-list)
          '("%`%l%(mode) -shell-escape%' %t"
          TeX-run-TeX nil (latex-mode doctex-mode) :help "Run LaTeX")
    )
  )
\end{minted}
#+end_latex



#+begin_src latex
  \begin{minted}{c}
    #include <stdio.h>

    main(){
      int a = 0;
      printf("Hello,  Minted");
    }

  \end{minted}
#+end_src

**** pygment
homepage: http://pygments.org/

支持的语言： *pygmentize -L lexers*,  >300

+ python(py, python)
+ c(c)
+ cpp(cpp)
+ cmake(cmake)
+ makefile(make, makefile)
+ bash(bash, sh)
+ yaml(yaml)
+ asm(nasm)
+ lisp(newlisp)
+ latex

#+BEGIN_EXAMPLE
  $ pygmentize -L lexers | grep cmake
  ,* cmake:
      CMake (filenames *.cmake, CMakeLists.txt)

  $ pygmentize -L lexers | grep python
  ,* antlr-python:
  ,* python, py, sage:
  ,* python3, py3:

  $ pygmentize -L lexers | grep makefile
  ,* make, makefile, mf, bsdmake:
      Makefile (filenames *.mak, Makefile, makefile, Makefile.*, GNUmakefile)

  $ pygmentize -L lexers | grep bash
  ,* bash, sh, ksh:
      Bash (filenames *.sh, *.ksh, *.bash, *.ebuild, *.eclass, .bashrc, bashrc, .bash_*, bash_*)j

  $ pygmentize -L lexers | grep yaml
  ,* yaml:
      YAML (filenames *.yaml, *.yml)

  $ pygmentize -L lexers | grep asm
      aspx-cs (filenames *.aspx, *.asax, *.ascx, *.ashx, *.asmx, *.axd)
      aspx-vb (filenames *.aspx, *.asax, *.ascx, *.ashx, *.asmx, *.axd)
  ,* nasm:
      NASM (filenames *.asm, *.ASM)
  $ pygmentize -L lexers | grep lisp
  ,* common-lisp, cl:
      Common Lisp (filenames *.cl, *.lisp, *.el)
  ,* newlisp:

  $ pygmentize -L lexers | grep latex
  ,* tex, latex:

#+END_EXAMPLE

*注： 当minted环境设置的语言不是当前所支持的，编译时不会报错，只是编译
的结果为空白PDF*

**** org 配置
#+BEGIN_SRC emacs-lisp
  (setq org-structure-template-alist
        '(("s" "#+BEGIN_SRC ?\n\n#+END_SRC" "<src lang=\"?\">\n\n</src>")
         ("e" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE" "<example>\n?\n</example>")
         ("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE" "<quote>\n?\n</quote>")
         ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE" "<verse>\n?\n</verse>")
         ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM" "<verbatim>\n?\n</verbatim>")
         ("c" "#+BEGIN_CENTER\n?\n#+END_CENTER" "<center>\n?\n</center>")
         ("l" "#+begin_src latex\n?\n#+end_src" )
         ("L" "#+LaTeX: " "<literal style=\"latex\">?</literal>")
         ("h" "#+BEGIN_HTML\n?\n#+END_HTML" "<literal style=\"html\">\n?\n</literal>")
         ("H" "#+HTML: " "<literal style=\"html\">?</literal>")
         ;; ("a" "#+BEGIN_ASCII\n?\n#+END_ASCII" "")
         ("A" "#+ASCII: " "")
         ("i" "#+INDEX: ?" "#+INDEX: ?")
         ("I" "#+INCLUDE: %file ?" "<include file=%file markup=\"?\">")
         ;; ("p" "#+begin_latex\n\\begin{python}\n?\n\\end{python}\n#+end_latex")
         ;; ("c" "#+begin_latex\n\\begin{cpp}\n?\n\\end{cpp}\n#+end_latex")
         ;; ("k" "\\left[?\\right]")
         ;; ("K" "\\left\{?\\right\}")
         ;; ("a" "#+begin_latex\n\\begin{algorithm}\n?\n\\end{algorithm}\n#+end_latex")
         ;; ("x" "#+begin_latex\n\\begin{xml}\n?\n\\end{xml}\n#+end_latex")
         ("m" "#+begin_latex\n\\begin{minted}{?}\n\n\\end{minted}\n#+end_latex")
         )
        )
#+END_SRC

org #+ 块支持嵌套。

*** Minted配置选项
1. mathescape
   [[/home/ben/Wally/Journal/Figure/scrot/5970lUr.png]]
2. gobble
   [[/home/ben/Wally/Journal/Figure/scrot/5970yex.png]]
3. frame
   [[/home/ben/Wally/Journal/Figure/scrot/5970koA.png]]
4. 其它
   [[/home/ben/Wally/Journal/Figure/scrot/5970xyG.png]]

   [[/home/ben/Wally/Journal/Figure/scrot/5970-8M.png]]


#+begin_latex
\begin{minted}[frame=single]{cpp}
hello world.
\end{minted}
#+end_latex

*** minted latex                                                    :latex:
#+BEGIN_EXAMPLE
  $ pygmentize -L lexers | grep latex
  tex, latex:
#+END_EXAMPLE

*** cmake                                                           :cmake:

minted *语言类型统一小写*
#+BEGIN_SRC sh :results output :exports both
pygmentize -L lexers | grep cmake
#+END_SRC

#+RESULTS:
: * cmake:
:     CMake (filenames *.cmake, CMakeLists.txt)

*** Minted float                                                    :float:

**** 使用float定义新的浮动体，失败，可能行
#+begin_example
\newfloat{minted}{h}{minted}


\begin{minted}[frame=single, mathescape]{py}
import os
print 'hello floating minted'
\end{minted}
#+end_example

+*not ok*+

**** 使用listing环境包装minted
[[/home/ben/Wally/Journal/Figure/scrot/18640JOs.png]]
#+begin_example
\begin{listing}
  \begin{minted}[frame=single, mathescape]{py}
  import os
  print 'hello floating minted'
  \end{minted}
\end{listing}
#+end_example

#+begin_latex
\begin{listing}
  \begin{minted}[frame=single, mathescape]{py}
  import os
  print 'hello floating minted'
  \end{minted}
\end{listing}
#+end_latex




*** DONE example导出PDF加框 minted text
- State "DONE"       from "TODO"       [2015-11-27 五 17:23]
 <2015-11-26 四>
 [[file:~/Wally/Journal/journal.org::*lidar%EF%BC%9A%20ok][lidar： ok]]

1. plain
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{text}
     #+BEGIN_EXAMPLE
           (defun org-xor (a b)
                 "Exclusive or."
                 (if a (not b) b))
     #+END_EXAMPLE
     \end{minted}
   #+end_latex

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{latex}
     \begin{verbatim}
     (defun org-xor (a b)
           "Exclusive or."
           (if a (not b) b))
     \end{verbatim}
     \end{minted}
   #+end_latex

   [[/home/ben/Wally/Journal/Figure/scrot/30792ZiT.png]]

2. -n get lines numbered

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{text}
     ,#+BEGIN_EXAMPLE -n
           (defun org-xor (a b)
                 "Exclusive or."
                 (if a (not b) b))
     ,#+END_EXAMPLE
     \end{minted}
   #+end_latex

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{latex}
     \begin{verbatim}
     1  (defun org-xor (a b)
     2        "Exclusive or."
     3        (if a (not b) b))
     \end{verbatim}
     \end{minted}
   #+end_latex

   [[/home/ben/Wally/Journal/Figure/scrot/30792ZpH.png]]

3. +n contine last example block

4. 使用Example块解决不了, 使用 Minted *text*

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{text}
        #+BEGIN_EXAMPLE -i
           (defun org-xor (a b)
                 "Exclusive or."
                 (if a (not b) b))
        #+END_EXAMPLE
     \end{minted}
   #+end_latex

*** minted 手册                                                    :minted:

**** -shell-escape
**** code
+
+ =\mint[hoptionsi]{hlanguagei}/hcodei/=
+ =\inputminted[hoptionsi]{hlanguagei}{hfilenamei}=
**** using different styles
1. *=\usemintedstyle{NAME}=*
2. *pygmentize -L styles*
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{text}
      $ pygmentize -L styles
     Pygments version 1.6, (c) 2006-2013 by Georg Brandl.

     Styles:
     ~~~~~~~
     ,* monokai:
         This style mimics the Monokai color scheme.
     ,* manni:
         A colorful style, inspired by the terminal highlighting style.
     ,* rrt:
         Minimalistic "rrt" theme, based on Zap and Emacs defaults.
     ,* perldoc:
         Style similar to the style used in the perldoc code blocks.
     ,* borland:
         Style similar to the style used in the borland IDEs.
     ,* colorful:
         A colorful style, inspired by CodeRay.
     ,* default:
         The default style (inspired by Emacs 22).
     ,* murphy:
         Murphy's style from CodeRay.
     ,* vs:

     ,* trac:
         Port of the default trac highlighter design.
     ,* tango:
         The Crunchy default Style inspired from the color palette from the Tango Icon Theme Guidelines.
     ,* fruity:
         Pygments version of the "native" vim theme.
     ,* autumn:
         A colorful style, inspired by the terminal highlighting style.
     ,* bw:

     ,* emacs:
         The default style (inspired by Emacs 22).
     ,* vim:
         Styles somewhat like vim 7.0
     ,* pastie:
         Style similar to the pastie default style.
     ,* friendly:
         A modern style based on the VIM pyte theme.
     ,* native:
         Pygments version of the "native" vim theme.

     \end{minted}
   #+end_latex

**** supported languages

*pygmentize -L lexers*

#+begin_latex
\begin{minted}[frame=left, mathescape]{py}

\end{minted}
#+end_latex

** float                                                             :float:
*** DONE LaTeX 自定义浮动体                                         :float:
- State "DONE"       from "TODO"       [2015-11-23 一 17:23]
CLOCK: [2015-11-23 一 17:01]--[2015-11-23 一 17:23] =>  0:22

1. 宏包： *float*
2. 新的选项: H
3. 命令: *\textbackslash{}* 创建新的浮动体
   =\newfloat{<type>}{<placement>}{<ext>}[<within>]=
** tkiz                                                               :tkiz:
*** LaTeX 绘制算法流程图                            :flowchart:tkiz:流程图:

**** flowchart

*flowchart* 宏包根据 IBM 提出的流程图标准，定义了流程图中最常用的五种标
准形状，包括：

1. PROCESS: 一切函数过程
2. DECESION: 条件判断
3. PREDEFINED　PROCESS：预定义过程
4. STORAGE: 数据存储
5. TERMINAL: 开始，结束


使用 flowchart 和 TikZ 绘制流程图，主要包括两个步骤：

1. _绘制流程图的具体形状_

   该过程主要是利用 flowchart 宏包的预定义形状，根据流程图具体需要实例
   化，即定义形状的大小，高度宽度等信息。定义形状时，有一点需要注意的
   是，在需要使用折线时，需要定义折线的转折点，如示例中的 point1 。

2. _将形状使用线连接，得到流程图_

   这部分比较简单，只要记住线和箭头的表示方法即可

#+BEGIN_SRC latex
   %!TEX program = xelatex

  \documentclass[UTF8]{ctexart}
  \usepackage{tikz,mathpazo}
  \usetikzlibrary{shapes.geometric, arrows}
  \usepackage{flowchart}
  \begin{document}
  \begin{tikzpicture}[font={\sf \small}]
  \def \smbwd{2cm}
  \thispagestyle{empty}

   %定义流程图的具体形状
  \node (start) at (0,0) [draw, terminal,minimum width=\smbwd, minimum height=0.5cm] {开始};      % 定义开始
  \node (getdata) at (0,-1.5) [draw, predproc, align=left,minimum width=\smbwd,minimum height=1cm] {读取数据};        %定义预处理过程，读取数据
  \node (decide) at (0,-3.5) [draw, decision, minimum width=\smbwd, minimum height=1cm] {判断条件};    %定义判断条件
  \node (storage) at (0,-5.5) [draw, storage, minimum width=\smbwd, minimum height=1cm] {数据存储};     %定义数据存储
  \node (process) at (3,-5.5) [draw, process, minimum width=\smbwd, minimum height=1cm] {处理过程};      %定义处理过程
  \coordinate (point1) at (0,-6.75);
  \node (end) at (0,-7.75) [draw, terminal,minimum width=\smbwd,minimum height=0.5cm] {结束};        %定义结束

   %连接定义的形状，绘制流程图--表示垂直线，|表示箭头方向
  \draw[->] (start) -- (getdata);
  \draw[->] (getdata) -- (decide);
  \draw[->] (decide) -| node[above]{是} (process);
  \draw[->] (decide) -- node[above]{否}(storage);
  \draw[->] (process) |- (point1);
  \draw[->] (storage) -- (point1) -- (end);
  \end{tikzpicture}
  \end{document}
#+END_SRC

[[/home/ben/Wally/Journal//Figure/scrot/30928L9H.png]]

**** tkiz

直接使用 TikZ 强大的绘图功能来实现流程图的绘制。

比较两个方法的代码可知，相比使用 flowchart 宏包，直接使用 TikZ 绘制流
程图多了定义基本形状一步。但通过 TikZ 自己定义基本形状，流程图的可定制
性更好，可以根据具体需要，定义多种流程图形状。另外一个使用 flowchart
宏包来绘制，最终还是需要用到 TikZ 语法，也不见得有多简单。

/推荐使用 TikZ 直接绘制流程图/


#+BEGIN_SRC latex
   %!TEX program = xelatex
  \documentclass[UTF8]{ctexart}
  \usepackage{tikz,mathpazo}
  \usetikzlibrary{shapes.geometric, arrows}
  \begin{document}
  \thispagestyle{empty}
   % 流程图定义基本形状
  \tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
  \tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
  \tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
  \tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
  \tikzstyle{arrow} = [thick,->,>=stealth]

  \begin{tikzpicture}[node distance=2cm]
   %定义流程图具体形状
  \node (start) [startstop] {Start};
  \node (in1) [io, below of=start] {Input};
  \node (pro1) [process, below of=in1] {Process 1};
  \node (dec1) [decision, below of=pro1, yshift=-0.5cm] {Decision 1};
  \node (pro2a) [process, below of=dec1, yshift=-0.5cm] {Process 2a};
  \node (pro2b) [process, right of=dec1, xshift=2cm] {Process 2b};
  \node (out1) [io, below of=pro2a] {Output};
  \node (stop) [startstop, below of=out1] {Stop};

   %连接具体形状
  \draw [arrow](start) -- (in1);
  \draw [arrow](in1) -- (pro1);
  \draw [arrow](pro1) -- (dec1);
  \draw [arrow](dec1) -- (pro2a);
  \draw [arrow](dec1) -- (pro2b);
  \draw [arrow](dec1) -- node[anchor=east] {yes} (pro2a);
  \draw [arrow](dec1) -- node[anchor=south] {no} (pro2b);
  \draw [arrow](pro2b) |- (pro1);
  \draw [arrow](pro2a) -- (out1);
  \draw [arrow](out1) -- (stop);
  \end{tikzpicture}
  \end{document}
#+END_SRC

[[/home/wally/Wally/Journal//Figure/scrot/30928YHO.png]]

**** reference

+ http://elegantlatex.org/2014/08/03/latex-flowchart/

** Packages                                                        :package:
*** pdfpages                                                 :pdfpages:pdf:
**** package: pdfpages
*pdfpages* : include multiple pdf pages in latex

**** package options
+ final: insert pages
+ draft: insert PDF filename with a box
+ enable-survey
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\usepackage[final]{pdfpages}
\end{minted}
#+end_latex

**** \textbackslash{}includepdf
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\includepdf[key=val]{filename}
\end{minted}
#+end_latex

***** main Options
1. *pages*
   selects pages to insert, a comma separated list
   e.g. pages={3, {}, 8-11, 15} 空花括号表空白页

2. *nup*
   put multipages  onto each sheet of paper, default 1x1
   e.g nup=4x2

3. landscape


***** Layout options
1. delta
   put some horizontal and vertical *space* between the logical pages.
   default: delat=0 0(seperated by space)

2. offset

3. frame

4. column


**** 参考
+ [[http://tex.stackexchange.com/questions/91440/how-to-include-multiple-pages-in-latex][stackexchange]]
+
  [[file:/usr/local/texlive/2014/texmf-dist/doc/latex/pdfpages/pdfpages.pdf::%25PDF-1.5][latex:pdfpages]]
*** Moderncv                                                     :moderncv:
+ http://www.cnblogs.com/panpei/archive/2013/02/13/2910680.html
+

modercv：http://www.ctan.org/tex-archive/macros/latex/contrib/moderncv

moderncv: a modern curriculum vitae class.

contained in tex live as moderncv

tex: /usr/local/2014/texmf-dist/tex/latex/moderncv
doc: /usr/local/2014/texmf-dist/doc/latex/moderncv

**** error: Font Awesome not found

解决：
#+BEGIN_EXAMPLE
\defaultfontfeatures{Path=/usr/local/texlive/2014/texmf-dist/fonts/opentype/public/fontawesome/}
\usepackage{fontawesome}
#+END_EXAMPLE

或 apt-get install texlive-font-extra

**** error name{}{}有两个参数，而不是一个，中文后者使用空括号即可

*** ulem                                                             :ulem:

- https://www.ctan.org/pkg/ulem

The package provides an =\ul= (underline) command which will break
over line ends; this technique may be used to replace =\em= (both in
that form and as the =\emph= command), so as to make output look as if
it comes from a typewriter. The package also offers =double and
wavy underlining, and striking out= (line through words) and
crossing out (/// over words).

** beamer                                                           :beamer:
*** beamer入门
**** reference

+ [[~/Document/Programming/TeX/Beamer/Beamer快速入门中文教程.chm][Beamer入门教程]]
+ [[https://bitbucket.org/rivanvx/beamer/wiki/Home][homepage]]
+ [[~/Document/Programming/TeX/Beamer/beameruserguide.pdf][Beamer User Guide]]

**** intro                                                         :intro:

1. *beamer* class

   Beamer 是 LaTeX 的一个用于创建幻灯片的文档类, 输出格式默认为PDF.

   \mint{latex}|\documentclass{beamer}|

2. *frame* environment

   在Beamer中, 基本环境是帧(*frame*)环境，即指幻灯片(slide), 其格式为:

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{latex}
     \begin{frame}{frame_title}
       ...
     \end{frame}
     \end{minted}
   #+end_latex

**** Beamer 主题

***** theme

主题可以设置: 常规列表(itemized list)和排序列表(enumerated list)的标记
(marker)或项目符号, 包含日期和幻灯片序号和其它信息的底边导航条等。

\mint{latex}|\usetheme{THEME}|

主题位置： /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes

#+BEGIN_SRC sh :results output :exports both
ls -l /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes
#+END_SRC

#+RESULTS:
: 总用量 20
: drwxr-xr-x 2 root root 4096  4月  3  2015 color
: drwxr-xr-x 2 root root 4096  4月  3  2015 font
: drwxr-xr-x 2 root root 4096  4月  3  2015 inner
: drwxr-xr-x 2 root root 4096  4月  3  2015 outer
: drwxr-xr-x 3 root root 4096  4月  3  2015 theme

***** 主要主题(major theme)

Beamer标准主题按城市名称命名.

#+BEGIN_SRC sh :results output :exports both
ls /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes/theme
#+END_SRC

#+RESULTS:
#+begin_example
beamerthemeAnnArbor.sty
beamerthemeAntibes.sty
beamerthemeBergen.sty
beamerthemeBerkeley.sty
beamerthemeBerlin.sty
beamerthemeBoadilla.sty
beamerthemeboxes.sty
beamerthemeCambridgeUS.sty
beamerthemeCopenhagen.sty
beamerthemeDarmstadt.sty
beamerthemedefault.sty
beamerthemeDresden.sty
beamerthemeEastLansing.sty
beamerthemeFrankfurt.sty
beamerthemeGoettingen.sty
beamerthemeHannover.sty
beamerthemeIlmenau.sty
beamerthemeJuanLesPins.sty
beamerthemeLuebeck.sty
beamerthemeMadrid.sty
beamerthemeMalmoe.sty
beamerthemeMarburg.sty
beamerthemeMontpellier.sty
beamerthemePaloAlto.sty
beamerthemePittsburgh.sty
beamerthemeRochester.sty
beamerthemeSingapore.sty
beamerthemeSzeged.sty
beamerthemeWarsaw.sty
compatibility
#+end_example

***** 次要主题(*minor themes*)

次要主题控制幻灯片外观的某些部分, 可以调用一个或多个次要主题。次要主题
分为四类:

1. 外部主题(*outer themes*):

   控制幻灯片的装饰（decorations），如显示在顶边节（header sections）
   和底边节（footer sections）中的文本和图形。

   #+BEGIN_SRC sh :results output :exports both
     ls /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes/outer
   #+END_SRC

   #+RESULTS:
   : beamerouterthemedefault.sty
   : beamerouterthemeinfolines.sty
   : beamerouterthememiniframes.sty
   : beamerouterthemeshadow.sty
   : beamerouterthemesidebar.sty
   : beamerouterthemesmoothbars.sty
   : beamerouterthemesmoothtree.sty
   : beamerouterthemesplit.sty
   : beamerouterthemetree.sty

   eg. 添加3-D 阴影到某些顶边元素。

   \mint{latex}|\useoutertheme{shadow}|

2. 内部主题(*inner themes*)

   控制幻灯片的装饰的内部区域，如常规列表（itemization lists）的标记/
   弹头，还有放置在定理周围的盒子。

   #+BEGIN_SRC sh :results output :exports both
     ls /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes/inner
   #+END_SRC

   #+RESULTS:
   : beamerinnerthemecircles.sty
   : beamerinnerthemedefault.sty
   : beamerinnerthemeinmargin.sty
   : beamerinnerthemerectangles.sty
   : beamerinnerthemerounded.sty

   \mint{latex}|\useinnertheme{}|
3. 字体主题(*font themes*)

   控制幻灯片不同元素的字形和字体尺寸。

   #+BEGIN_SRC sh :results output :exports both
     ls /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes/font
   #+END_SRC

   #+RESULTS:
   : beamerfontthemedefault.sty
   : beamerfontthemeprofessionalfonts.sty
   : beamerfontthemeserif.sty
   : beamerfontthemestructurebold.sty
   : beamerfontthemestructureitalicserif.sty
   : beamerfontthemestructuresmallcapsserif.sty

   eg. 将文档的 字体更改为衬线体（serif）。（默认为无衬线体。）
   \mint{latex}|\useinnertheme{serif}|

4. 颜色主题(*color themes*)

   控制标题、帧标题、常规列表子弹以及幻灯片其它元素的颜色。

   #+BEGIN_SRC sh :results output :exports both
     ls /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes/color
   #+END_SRC

   #+RESULTS:
   #+begin_example
   beamercolorthemealbatross.sty
   beamercolorthemebeaver.sty
   beamercolorthemebeetle.sty
   beamercolorthemecrane.sty
   beamercolorthemedefault.sty
   beamercolorthemedolphin.sty
   beamercolorthemedove.sty
   beamercolorthemefly.sty
   beamercolorthemelily.sty
   beamercolorthememonarca.sty
   beamercolorthemeorchid.sty
   beamercolorthemerose.sty
   beamercolorthemeseagull.sty
   beamercolorthemeseahorse.sty
   beamercolorthemesidebartab.sty
   beamercolorthemespruce.sty
   beamercolorthemestructure.sty
   beamercolorthemewhale.sty
   beamercolorthemewolverine.sty
   #+end_example

   eg. 改变 Beamer 的默认颜色。
   \mint{latex}|\usecolortheme{crane}|

**** 帧工具

***** 结构色
1. 结构色

   Beamer 演示稿的大部分有颜色的部分由结构（structure）提取颜色
   （abstract color）后绘制（draw）。通过更改结构（structure）你可以改
   变 Beamer 稿的全部颜色。

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{latex}
     \documentclass{beamer}
       \usecolortheme[named=Brown]{structure}
       \usetheme[height=7mm]{Rochester}
     \end{minted}
   #+end_latex

   + 结构（structure）会影响多个项目（items），包括子弹（bullets）
     和导航图标。

   + 颜色 “Brown” 只是下列文件中定义的大量颜色名（color names）的一
     个。
     \textbackslash{}documentclass 的 xcolor=dvipsnames 选项将这些颜色
     名带入 Beamer。

     #+BEGIN_SRC sh :results output :exports code
       cat /usr/share/texlive/texmf-dist/tex/latex/graphics/dvipsnam.def
     #+END_SRC

     #+RESULTS:
     #+begin_example
     %%
     %% This is file `dvipsnam.def',
     %% generated with the docstrip utility.
     %%
     %% The original source files were:
     %%
     %% drivers.dtx  (with options: `dvipsnames')
     %%
     %% drivers.dtx Copyright (C) 1994      David Carlisle Sebastian Rahtz
     %%             Copyright (C) 1995 1996 1997 1998 1999 David Carlisle
     %%
     %% This file is part of the Standard LaTeX `Graphics Bundle'.
     %% It may be distributed under the terms of the LaTeX Project Public
     %% License, as described in lppl.txt in the base LaTeX distribution.
     %% Either version 1.3 or, at your option, any later version.
     %%
     \ProvidesFile{dvipsnam.def}
             [1999/02/16 v3.0i Driver-dependant file (DPC,SPQR)]
     \DefineNamedColor{named}{GreenYellow}   {cmyk}{0.15,0,0.69,0}
     \DefineNamedColor{named}{Yellow}        {cmyk}{0,0,1,0}
     \DefineNamedColor{named}{Goldenrod}     {cmyk}{0,0.10,0.84,0}
     \DefineNamedColor{named}{Dandelion}     {cmyk}{0,0.29,0.84,0}
     \DefineNamedColor{named}{Apricot}       {cmyk}{0,0.32,0.52,0}
     \DefineNamedColor{named}{Peach}         {cmyk}{0,0.50,0.70,0}
     \DefineNamedColor{named}{Melon}         {cmyk}{0,0.46,0.50,0}
     \DefineNamedColor{named}{YellowOrange}  {cmyk}{0,0.42,1,0}
     \DefineNamedColor{named}{Orange}        {cmyk}{0,0.61,0.87,0}
     \DefineNamedColor{named}{BurntOrange}   {cmyk}{0,0.51,1,0}
     \DefineNamedColor{named}{Bittersweet}   {cmyk}{0,0.75,1,0.24}
     \DefineNamedColor{named}{RedOrange}     {cmyk}{0,0.77,0.87,0}
     \DefineNamedColor{named}{Mahogany}      {cmyk}{0,0.85,0.87,0.35}
     \DefineNamedColor{named}{Maroon}        {cmyk}{0,0.87,0.68,0.32}
     \DefineNamedColor{named}{BrickRed}      {cmyk}{0,0.89,0.94,0.28}
     \DefineNamedColor{named}{Red}           {cmyk}{0,1,1,0}
     \DefineNamedColor{named}{OrangeRed}     {cmyk}{0,1,0.50,0}
     \DefineNamedColor{named}{RubineRed}     {cmyk}{0,1,0.13,0}
     \DefineNamedColor{named}{WildStrawberry}{cmyk}{0,0.96,0.39,0}
     \DefineNamedColor{named}{Salmon}        {cmyk}{0,0.53,0.38,0}
     \DefineNamedColor{named}{CarnationPink} {cmyk}{0,0.63,0,0}
     \DefineNamedColor{named}{Magenta}       {cmyk}{0,1,0,0}
     \DefineNamedColor{named}{VioletRed}     {cmyk}{0,0.81,0,0}
     \DefineNamedColor{named}{Rhodamine}     {cmyk}{0,0.82,0,0}
     \DefineNamedColor{named}{Mulberry}      {cmyk}{0.34,0.90,0,0.02}
     \DefineNamedColor{named}{RedViolet}     {cmyk}{0.07,0.90,0,0.34}
     \DefineNamedColor{named}{Fuchsia}       {cmyk}{0.47,0.91,0,0.08}
     \DefineNamedColor{named}{Lavender}      {cmyk}{0,0.48,0,0}
     \DefineNamedColor{named}{Thistle}       {cmyk}{0.12,0.59,0,0}
     \DefineNamedColor{named}{Orchid}        {cmyk}{0.32,0.64,0,0}
     \DefineNamedColor{named}{DarkOrchid}    {cmyk}{0.40,0.80,0.20,0}
     \DefineNamedColor{named}{Purple}        {cmyk}{0.45,0.86,0,0}
     \DefineNamedColor{named}{Plum}          {cmyk}{0.50,1,0,0}
     \DefineNamedColor{named}{Violet}        {cmyk}{0.79,0.88,0,0}
     \DefineNamedColor{named}{RoyalPurple}   {cmyk}{0.75,0.90,0,0}
     \DefineNamedColor{named}{BlueViolet}    {cmyk}{0.86,0.91,0,0.04}
     \DefineNamedColor{named}{Periwinkle}    {cmyk}{0.57,0.55,0,0}
     \DefineNamedColor{named}{CadetBlue}     {cmyk}{0.62,0.57,0.23,0}
     \DefineNamedColor{named}{CornflowerBlue}{cmyk}{0.65,0.13,0,0}
     \DefineNamedColor{named}{MidnightBlue}  {cmyk}{0.98,0.13,0,0.43}
     \DefineNamedColor{named}{NavyBlue}      {cmyk}{0.94,0.54,0,0}
     \DefineNamedColor{named}{RoyalBlue}     {cmyk}{1,0.50,0,0}
     \DefineNamedColor{named}{Blue}          {cmyk}{1,1,0,0}
     \DefineNamedColor{named}{Cerulean}      {cmyk}{0.94,0.11,0,0}
     \DefineNamedColor{named}{Cyan}          {cmyk}{1,0,0,0}
     \DefineNamedColor{named}{ProcessBlue}   {cmyk}{0.96,0,0,0}
     \DefineNamedColor{named}{SkyBlue}       {cmyk}{0.62,0,0.12,0}
     \DefineNamedColor{named}{Turquoise}     {cmyk}{0.85,0,0.20,0}
     \DefineNamedColor{named}{TealBlue}      {cmyk}{0.86,0,0.34,0.02}
     \DefineNamedColor{named}{Aquamarine}    {cmyk}{0.82,0,0.30,0}
     \DefineNamedColor{named}{BlueGreen}     {cmyk}{0.85,0,0.33,0}
     \DefineNamedColor{named}{Emerald}       {cmyk}{1,0,0.50,0}
     \DefineNamedColor{named}{JungleGreen}   {cmyk}{0.99,0,0.52,0}
     \DefineNamedColor{named}{SeaGreen}      {cmyk}{0.69,0,0.50,0}
     \DefineNamedColor{named}{Green}         {cmyk}{1,0,1,0}
     \DefineNamedColor{named}{ForestGreen}   {cmyk}{0.91,0,0.88,0.12}
     \DefineNamedColor{named}{PineGreen}     {cmyk}{0.92,0,0.59,0.25}
     \DefineNamedColor{named}{LimeGreen}     {cmyk}{0.50,0,1,0}
     \DefineNamedColor{named}{YellowGreen}   {cmyk}{0.44,0,0.74,0}
     \DefineNamedColor{named}{SpringGreen}   {cmyk}{0.26,0,0.76,0}
     \DefineNamedColor{named}{OliveGreen}    {cmyk}{0.64,0,0.95,0.40}
     \DefineNamedColor{named}{RawSienna}     {cmyk}{0,0.72,1,0.45}
     \DefineNamedColor{named}{Sepia}         {cmyk}{0,0.83,1,0.70}
     \DefineNamedColor{named}{Brown}         {cmyk}{0,0.81,1,0.60}
     \DefineNamedColor{named}{Tan}           {cmyk}{0.14,0.42,0.56,0}
     \DefineNamedColor{named}{Gray}          {cmyk}{0,0,0,0.50}
     \DefineNamedColor{named}{Black}         {cmyk}{0,0,0,1}
     \DefineNamedColor{named}{White}         {cmyk}{0,0,0,0}
     \endinput
     %%
     %% End of file `dvipsnam.def'.
#+end_example

2. 指定RGB
   可以通过指定它们的 RGB 构成来定义你自已的颜色。每一 RGB 构成必需在
   0–255 的范围内。
   #+BEGIN_EXAMPLE
     \documentclass{beamer}
     \usecolortheme[RGB={205,173,0}]{structure}   % 暗金
     \usetheme[height=7mm]{Rochester}
   #+END_EXAMPLE

   + RGB 构成可以是 0–255 范围内的整数，也可以是 0.00–1.00 范围
     内的小数。如果用小数表示，需用小写的 rgb 选项，如：
     rgb={0.2264,0.1561,0.0000}.

3. 直接使用结构色

   通过使用 *\textbackslash{}structure{a colored text}* 命令可以取得有
   趣的动态效果。给定的文本将依据结构色显示出相应的颜色。当改变结构色
   如将蓝色改成金色时，文本的颜色也因此而改变。

***** 条目标记

罗切斯特（Rochester）主题在常规列表（itemized lists）和排序列表
（numerated lists）中用了方形标记（square markers ）。

将方形标记更改为仿三维球形标记。

\mint{latex}|\setbeamertemplate{items}[ball]|

命令 *=\setbeamertemplate{items}=* 的可能选项有：
- ball: 仿三维球形
- circle: 二维（平面）圆圈
- rectangle: 矩形
- default: 三角形

***** 圆角框和阴影

要将围绕定理的盒子改成圆角并添加阴影

\mint{latex}|\setbeamertemplate{blocks}[rounded][shadow=true]|

***** 去掉导航图标

[[/home/ben/Wally/Journal/Figure/scrot/31690oTc.png]]

大部分 Beamer 主题都在幻灯片中放置了一行导航图标（navigation icons）。
（上述幻灯片底部边缘的那些小标记）。我认为这些图标漂亮但没什么用处且会
分散注意力。可以在文档中添加命令使这些导航图标不出现

\mint{latex}|\setbeamertemplate{navigation symbols}{}|

***** 添加底部导航条

底边导航条（footline）是幻灯片底部的狭窄长条，在这里，可以显示作者姓名、
演示稿的标题、幻灯片序号、其它有用的信息。

大部分底边导航条的信息摘自于导言区提供的数据如 =\author= 、=\title= 等。

Beamer 主题博阿迪利亚（Boadilla）和马德里（Madrid）默认情况下提供了这
样一个底边导航条。

可以使用命令

\mint{latex}|\useoutertheme{infolines}|

注意：这是 Beamer 的一个特殊癖性（bug的礼貌说法），即：

*=\useoutertheme{infolines}=* 必需放在
*=\usetheme[height=7mm]{Rochester}=* 之前。如果你搞反了顺序，幻灯片的
标题将被删除。

**** 帧元素

***** 封面

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
    \title[A short proof]{A short proof of Fermat's Last Theorem}
    \subtitle[Errors]{Estimation of numerical errors}
    \author[R. Rostamian]{Rouben Rostamian}
    \institute[UMBC]{
      Department of Mathematics and Statistics\\
      University of Maryland, Baltimore County\\
      Baltimore, Maryland 21250\\[1ex]
      \texttt{rostamian@umbc.edu}
    }
    \date[November 2004]{November 26, 2004}
    \begin{document}
    \begin{frame}[plain]
      \titlepage
    \end{frame}
   \end{document}
  \end{minted}
#+end_latex

1. 封面元素
   + title
   + subtitle
   + author
   + institute
   + data

2. 可选参数

   可选参数为缩写形式(short forms)，用在封面以后幻灯片的页脚处。必选参
   数为全称形式(long forms), 出现在封面上， 如果没有可选参数则也出现在
   后续幻灯片的页脚处。

3. plain限定项

   plain选项用于生成封面(titlepage)。如果没有该限定项，则封面就会装饰
   有页眉和页脚。

   plain可用于任意帧。

   \mint{latex}|\begin{frame}[plain]|

***** 图片

Beamer可以识别 pdf, png 和 jpg 格式的图像。

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\linewidth]{/path/to/image}
  \end{figure}
  \end{minted}
#+end_latex

***** 叠层
也许Beamer最有趣的效果是叠层(overlays), 它可以让幻灯片逐渐显示。在
Beamer中，要达到双层效果很简单，只需要在暂停显示的专访放置命令
*=\pause=* 即可。

=\pause= 命令不受常规列表的约束，可以在幻灯片任意地方使用。

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \begin{frame}{Outline of the talk}

  \begin{itemize}
    \item Introduction
    \pause
    \item Statement of the main theorem
    \pause
    \item Technical lemmata
    \pause
    \item Proof of the main theorem
    \pause
    \item Conclusions
  \end{itemize}

  \end{frame}
  \end{minted}
#+end_latex

***** 超链接导航(Hyperlinks)

****** 导航

目标(target)幻灯片中在 =\begin{frame}= 命令处增加 *[label=LABEL]* 标签
(tag)选项。

源幻灯片中使用命令 *=\hyperlink{LABELF}{here}=* 插入超链接。
\mint{latex}|{LABEL}{COMMENT}|

默认超链接文字显示为普通文本，可以在导言中使用 *hypersetup* 命令设置。

\mint{latex}|\hypersetup{colorlinks=true,linkcolor=red}|

超链接可以使用Beamer按钮.

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \hyperlink{LABEL}{beamerbutton{COMMENT}}
  \hyperlink{LABEL}{\beamergotobutton{COMMENT}}
  \hyperlink{LABEL}{beamerskipbutton{COMMENT}}
  \hyperlink{LABEL}{beamerturnbutton{COMMENT}}
  \end{minted}
#+end_latex

****** 返回到呼叫页

+ Acrobat Reader: M-LEFT
+ Xpdf: b

***** 定理
Beamer预定义了以下几个 LaTeX 环境：
+ theorem
+ corollary (推论)
+ definition
+ example
+ proof

Beamer主题控制着这些环境的呈现(render).

事实上，这些环境是由 amsmath 宏包定义的， Beamer自动加载该宏包。

***** 添加脚注

标准的 LaTeX 命令 *=\footnote=* 可以在幻灯片中添加脚注，但其更适合要打
印的页面而非幻灯片，脚注编号和分隔线(separator line)会放在幻灯片中不适
当的位置。

LaTeX 宏包 *textpos* 可以在页面的任意的预定义的地方放置对象(objects),
可以用来为幻灯片添加脚注类文本(footnote-like).

**** 帧布局
***** 分栏 : colums环境和嵌套的column环境

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  begin{frame}{Splitting a slide into columns}
  The line you are reading goes all the way across the slide.
  From the left margin to the right margin.  Now we are going
  the split the slide into two columns.
  \bigskip
  \begin{columns}
    \begin{column}{0.5\textwidth}
      Here is the first column.  We put an itemized list in it.
      \begin{itemize}
        \item This is an item
        \item This is another item
        \item Yet another item
      \end{itemize}
    \end{column}
    \begin{column}{0.3\textwidth}
      Here is the second column.  We will put a picture in it.
      \centerline{\includegraphics[width=0.7\textwidth]{image2.png}}
    \end{column}
  \end{columns}
  \bigskip
  The line you are reading goes all the way across the slide.
  From the left margin to the right margin.
  \end{frame}
  \end{minted}
#+end_latex

1. Note
   1) 要确保栏的总宽度不能超过幻灯片的宽度，即 *=textwidth=*
   2) 每一栏中，变量 =textwidth= 会被重定义。
   3) 也可以指定分栏的绝对宽度， Beamer幻灯片的尺寸为 *128mm x 96mm*
      \mint{latex}|begin{column}{30mm}|

2. 垂直对齐
   \mint{latex}|\begin{columns}[t]|
   + center-aligned(c): default
   + top-aligned(t): e.g. \textbackslash{}begin{columns}[t]
   + bottom-aligned(a)

3. 图像的垂直对齐

   图像默认以底部作为参照点(reference point).如果想要以顶部为参照点，
   则要使用columns环境的 [T] 选项。

***** 垂直对齐

Beamer 幻灯片的内容是垂直对齐的。

frame环境的选项 t,c,b分别使幻灯片的内容以幻灯片的顶部、中部和底部对齐，
默认为c。
\mint{latex}|\begin{frame}[t]{title}|

也可以给文类beamer增加对齐选项，使其使用于所有幻灯片。
\mint{latex}|\documentclass[t]{beamer}|
***** 缩小以适合
要缩小（squeeze）Beamer 幻灯片中的少量额外材料，你必须为该幻灯片指定一
个缩小因子(shrink-factor)，如下所示：

\mint{latex}|\begin{frame}[shrink=5]{Frame title}|

这将按比例缩小幻灯片的内容至少5% ，如果需要，还能缩小更多，直至内容完
全能被幻灯片所容纳。

为达到最佳效果，你指定的缩小因子应尽可能接近所需的数值。如果你指定的缩
小因子的值不合适，Beamer 将发出警告。调整缩小因子直至警告消失。然而，
幻灯片的水平间隙（horizontal spacing）将不是最佳的。

你不应滥用这个缩小功能——少量的缩小不会引人注意，到处都使用了缩小就会让
人看着不愉快。

可以替代这个缩小功能的是，可以考虑重写幻灯片的内容，或将内容分入两张幻
灯片中。

***** 改变页边距
*Beamer 幻灯片的尺寸是 128mm × 96mm。这个尺寸是固定的不能修改。*

然而，左右两侧的页边距（margins）却可以更改。左右两侧的页边距默认设定是 1cm 。

在下面的例子中，我们将左右两侧的页边距分别更改为 6mm 和 2mm。

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \setbeamersize{text margin left=6mm}
  \setbeamersize{text margin right=2mm}
  \end{minted}
#+end_latex

上述两条命令可以合并成一条，如下所示：

\mint{latex}|\setbeamersize{text margin left=6mm, text margin right=2mm}|

**** 字体

***** 默认字体尺寸

Beamer的默认字体尺寸是 *11 points*. 可以给文类beamer添加选项进而修改默
认字体尺寸，可选的有 8, 9, 10, 11, 12, 14, 17, 20pt.

\mint{latex}|\documentclass[14pt]{beamer}|

***** 默认的文本颜色

Beamer 的普通文本的颜色为白色背景黑色文字。 在导言区使用命令
*=\setbeamercolor=* 可以对文本颜色进行设置。

\mint{latex}|\setbeamercolor{normal text}{fg=purple}|

*fg* 用于设定普通文本(normal text)的前景色(foreground), *bg* 用于设置
普通文本的背景色。

注： 幻灯片的背景色继承于普通文本的背景色， 因此改变普通文本的背景色必
定改变幻灯片的背景色。

普通文本指幻灯片中的主体文本。幻灯片的页眉页脚不是普通文本，由结构
(structure)色控制。

\mint{latex}|\setbeamercolor{structure}{fg=purple}|

***** 结构字体和字体主题

****** 结构字体

Beamer 的结构字体(structure font)确定用于演示稿的结构元素，如页眉、页
脚和其它封面条目的字体。

\mint{latex}|\setbeamerfont{sturcture}{family=\rmfamily shape=\itshape, series=\bfseries}|

****** 字体主题

Beamer提供了字体选项的预定义设置， 它不仅影响结构元素，而且影响普通文
本和数学式。

\mint{latex}|\usefonttheme{serif}|
**** 颜色
Beamer 借助于一个外部工具处理颜色，该外部工具是一个名为 *xcolor* 的宏包。
Beamer 默认加载 xcolor，因而你无需加载它。默认加载 xcolor 宏包后，下列
颜色可用：

[[/home/ben/Wally/Journal/Figure/scrot/19740X3z.png]]


***** dvips宏包命名的颜色

Xcolor 宏包可以读取来自dvipsnam.def 文件的扩展的色名集（extended set
of color names ）。许多 LaTeX 分发版提供了dvipsnam.def 文件。

要在 Beamer 中使用该扩展的色名集，请按以下方式调用 Beamer：

\mint{latex}|\documentclass[xcolor=dvipsnames]{beamer}|

[[/home/ben/Wally/Journal/Figure/scrot/19740WLJ.png]]

***** SVG宏包命名的颜色
Xcolor 能读取来自文件 svgnam.def 的更大的色名集，多 LaTeX 分发版提供了
svgnam.def文件。
p
要在 Beamer 中使用该扩展的色名集，请按以下方式调用 Beamer：

\mint{latex}|\documentclass[xcolor=svgnames]{beamer}|

***** 混合色
xcolor 宏包提供了一个工具，用它可以混合任何色集以得到不同的颜色比例，
就象你在油画中混合颜色一样。

我们指定一个混合色组成为 A!n!B，即颜色A占n%，颜色B占(100-n) %。在
Beamer 中，A!n!B 表达式可以用在预期颜色名的地方。表达式 A!n 是
A!n!white 的简写形式。下面是一些例子。

[[/home/ben/Wally/Journal/Figure/scrot/19740jVP.png]]

***** 自定义颜色
除上述的机制外，就象LaTeX 手册记录的那样，你可以用 =\definecolor= 命令
定义颜色，加载color 宏包后并使 =\definecolor= 可用。

可以通过指定 RGB（Red Green Blue 即红绿蓝）的组成来指定颜色，
RGB组成用 0 到 1 的小数表示，如下所示：
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\definecolor{mygold}{rgb}{0.85, 0.60, 0.00}  % 注意用小写的 rgb
\end{minted}
#+end_latex

另外，RGB 的组成也可以用 0 到 255 之间的整数表示，如下所示：
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\definecolor{mygold}{RGB}{217, 153, 0}       % 注意用大写的 RGB
\end{minted}
#+end_latex


***** 有色文本，高亮和盒子

****** 有色文本
Beamer中的有色文本用的是标准的 LaTeX 命令 *=\textcolor=* 生成的

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\textcolor{blue}{This ia in blue}
\end{minted}
#+end_latex

****** 高亮
*=\colorbox=* 命令指定文本的背景色，即底纹。

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\colorbox{yellow}{This text is highlieghted in yellow}
\end{minted}
#+end_latex

****** 盒子
*=\fcolorbox=* 将文本框起来。
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\fcolorbox{red}{yellow}{A yello box with red borders}
\end{minted}
#+end_latex

+ =\setlength{\fboxrule}{4pt}= 设置框的宽度
+ =\setlength{\fboxsep}{0pt}设置框与被框对象的间隔。

***** 幻灯片背景
Beamer默认的幻灯片背景是白色。

****** 设置为固定的颜色(solid)
设为淡品红色
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\setbeamercolor{normal text}{bg=red!12}
\end{minted}
#+end_latex

****** 渐变色

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\setbeamertemplate{background canvas}[vertical shading][bottom=red!20,top=yellow!30]
\end{minted}
#+end_latex

****** 叠加网格

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\setbeamertemplate{background}[grid][step=5mm,color=blue]
\end{minted}
#+end_latex

****** 使用图像作为背景
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\setbeamertemplate{background canvas}{\includegraphics
        [width=\paperwidth,height=\paperheight]{alps.jpg}}
\end{minted}
#+end_latex

注意：Beamer 幻灯片的长宽比是 4:3，因此你的背景图片的长宽比最好也是
4:3，否则，在拉伸图片填满幻灯片时，背景图片会变形。

****** 设定单张幻灯片背景
要将背景设置限定在单张幻灯片，请将命令 =\setbeamertemplate{background canvas}{...}= 放在大括号中，
如下所示：

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  { % 大括号限定 \setbeamertemplate 的范围
  \setbeamertemplate{navigation symbols}{}  % 可选地隐藏导航按钮
  \setbeamertemplate{background canvas}{\includegraphics
          [width=\paperwidth,height=\paperheight]{alps.jpg}}
  \begin{frame}[plain]
  ...
  \end{frame}
  } % 结束大括号
  \end{minted}
#+end_latex

****** 注意
精美的背景色、阴景及图像可以使你的幻灯片看上去很漂亮，但也会使人分心。
请在你的演示稿中恰如其分地应用这些设计（devices）。

*** beamer ppt                                                        :ppt:
+
   http://tex.stackexchange.com/questions/21986/export-beamer-slides-to-powerpoint-openoffice-impress-keynote-editable-format
+ http://superuser.com/questions/268244/how-to-convert-pdf-to-ppt-or-odp


"beamer can export to PDF or PS", beamer doesn't export anything. It
is a LaTeX class and LaTeX compiles the document to PDF (pdflatex) or
DVI (latex) which then is mostly converted to PS. There is of course
no powerpointlatex, so you will need to convert the PDF or PS somehow
to a format PP can read, which would be RTF (Rich Text Format) or some
Windows vector format like EMF or WMF. However, I would do it either
with one or the other software. They do not mix well.

**** pdf to ppt
+  [[http://superuser.com/questions/268244/how-to-convert-pdf-to-ppt-or-odp][cnvert pdf to ppt]]

The desired result can also be achieved without proprietary tools. If
you have GhostScript installed, you can convert your PDF presentation
into a set of JPG images using:

#+begin_latex
  \begin{minted}[frame=single, mathescape]{sh}
  gs -dNOPAUSE -dBATCH -dSAFER -dGraphicsAlphaBits=4 -dTextAlphaBits=4 \
     -sDEVICE=jpeg -r300 -sOutputFile='page-%00d.jpg' YOURFILE.pdf
  \end{minted}
#+end_latex

Then, with the plugin for OpenOffice/LibreOffice create a presentation
where each image fills exactly one slide. You can also easily keep the
order of the pages by choosing the plugin option "natural sorting".、

*Edit -> Link -> 断开链接*  否则以链接形式插入。
*** DONE Beamer in orgmode                                     :beamer:org:
- State "DONE"       from "TODO"       [2015-12-02 三 16:02] \\
  用以致学，需要用的时候再学
**** reference

+ [[http://orgmode.org/worg/exporters/beamer/tutorial.html][orgmode tutorial for beamer]]
+ [[http://orgmode.org/manual/Beamer-export.html][orgmode manual: export to beamer]]
+ http://www.latexstudio.net/org-beamer-cn-template/

**** insert template
*C-c C-e #*  insert default template

**** Beamer specific settings
+ #+startup:beamer
+ #+LaTeX_CLASS: beamer
+ #+LaTeX_CLASS_OPTIONS: [bigger]
+ #+BEAMER_FRAME_LEVEL:2
  - Note: Beamer also makes user of LaTeX sectioning to group frames
+ #+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args)
  %4BEAMER_col(Col) %10BEAMER_extra(Extra)
**** a simple slide
#+BEGIN_EXAMPLE
  ,* Introduction
  ,** A simple slide
  This slide consists of some text with a number of bullet points:

  - the first, very @important@, point!
  - the previous point shows the use of the special markup which
    translates to the Beamer specific /alert/ command for highlighting
    text.


  The above list could be numbered or any other type of list and may
  include sub-lists.
#+END_EXAMPLE
**** block
+ M-x org-beamer-mode
+ C-c C-b

#+BEGIN_EXAMPLE
  ,** Two columns

  ,*** A block                                           :B_ignoreheading:BMCOL:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :BEAMER_col: 0.4
      :END:
      - this slide consists of two columns
      - the first (left) column has no heading and consists of text
      - the second (right) column has an image and is enclosed in an
        @example@ block

  ,*** A screenshot                                            :BMCOL:B_example:
      :PROPERTIES:
      :BEAMER_col: 0.6
      :BEAMER_env: example
      :END:
  ,    #+ATTR_LATEX: width=\textwidth
      [[file://../../images/org-beamer/a-simple-slide.png]]
#+END_EXAMPLE

Note
+ B_ignoreheading: ignore heading
+ #+ATTR_LATEX: set atttibute
**** export
C-c C-e l b

** thesis

** miscellaneous

* Matlab                                                             :matlab:
** fundermental
*** Ubuntu支持                                                     :ubuntu:

+ http://blog.csdn.net/lanbing510/article/details/41698285
+ http://neuro.debian.net/blog/2013/2013-05-31_matlab_64bit_on_32bit.html
+ https://help.ubuntu.com/community/MultiArch
+ http://stackoverflow.com/questions/28039025/how-to-install-64-bit-matlab-in-32-bit-ubuntu


Note:
1) Matlab对32位的支持越来越少
2) 在32位Ubuntu上安装64位软件几乎是不可能的(debian的可能)，没有必要瞎折腾
3) Python可以完全替代Matlab

*** [[http://lanbing510.info/2014/12/03/Linux-Matlab.html][Matlab 安装]]                                                   :install:

1. 从[[http://pan.baidu.com/s/1o6qKdxo#path=%252Fmatlab][这里]]下载Matlab2014的Linux版本及破解文件。

   - note: 两个 rar 文件，只需使用 unrar 解压其中一个即可，会自动解压
     另外一个。

2. 下载完成后将iso文件挂载到Linux进行安装。

   #+BEGIN_EXAMPLE
    sudo mkdir /media/matlab
    mount -o loop [path][filename].iso /media/matlab
    cd /media/matlab
    sudo ./install
   #+END_EXAMPLE

  - ./install 触发的是 GUI 方式，而不是命令行方式

3. 安装过程中使用readme.txt中的序列号。

4. 破解

   1) 安装完成后使用crack下的 license进行激活；

   2) 将crack文件夹下的libmwservices.so copy到 /usr/local/MATLAB/R2014A/bin/glnxa64。

5. 完成安装，命令行下使用sudo matlab即可启动使用。

** syntax
*** Matlab续行符                                                   :续行符:

续行符，也就是三个点：...

** index

*** residue                                                       :residue:
[r, p, k] = residue(num, den)
+ r 留数
+ p 级数
+ k 直接数(?)

#+BEGIN_SRC latex
  \begin{displaymath}
    \frac{A(s)}{B(s)}=C(s)+\frac{k}{x-p}
  \end{displaymath}
#+END_SRC

** miscellaneous
*** MATLAB与VC混合编程                                                 :vc:

1. 使用matcom将m文件编译成C++文件，或可执行二进制文件，或库文件dll
2. COM(Component Object Model)接口方法，不支持脚本，仅支持函数，实现简
   单，通用性强，推荐。
3. 直接调用Matlab的C/C++库
4. 用Matlab自带的Matlab Compiler, 即命令mcc，将m文件编译成动态链接库等。
5. 通过Matlab Engine方式，使用C/S(客户机/服务器)模式，Matlab作为后台服
   务器，C程序作为前台客户机，效率不高。
6. 混合使用以上方法

* CMake                                                               :cmake:
** reference

- [[http://www.cmake.org/][Homepage]]
- [[https://github.com/Kitware/CMake][Github]]

** fundermental

*** installation from source code                                 :install:

https://github.com/Kitware/CMake

#+BEGIN_EXAMPLE
$ ./bootstrap && make && make install
#+END_EXAMPLE

** CMake手册
*** 指令
**** ADD_DEFINITIONS

向C/C++编译器添加-D定义

eg.
#+BEGIN_EXAMPLE
ADD_DEFINITONS(-DENABLE_DEBUG -DABC)
#+END_EXAMPLE
参数之间使用空格分割.
如果代码中定义了#ifdef ENABLE_DEBUG  #endif, 这块代码就会生效.

其它编译器开关可以通过 *CMAKE_C_FLAGS* 和 *CMAKE_CXX_FLAGS* 变量设
置.


**** ADD_DEPENDENCIES

定义target秘依赖的其它target, 确保编译本target之前,

其它的target已经被构建.

#+BEGIN_EXAMPLE
  ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...)
#+END_EXAMPLE

**** ADD_EXECUTABLE
定义生成的可执行文件名称, 及源文件列表.
可执行文件名与工程名无关, eg. HELLO hello
**** ADD_LIBRARY
+ 格式
  #+BEGIN_EXAMPLE
    ADD_LIBRARY(libname [SHARED | STATIC | MODULE]
                [EXCLUDE_FROM_ALL]
                source1 source2 ...)
  #+END_EXAMPLE
+ 类型:
  + SHARED: 动态库, 后缀 *.so*
  + STATIC: 静态库, 后缀 *.a*
  + MODELE: 在使用dyld的系统中有效, 如果不支持dyld, 则被当作SHARED对待.
**** ADD_SUBDIRECTORY
+ 向工程中添加存放源文件的目录, 并指定中间二进制文件和目标二进制
  文件的存放位置
+ 格式: *ADD_SUBDIRECTORY(source_dir [binary_dir]
  [EXCLUDE_FROM_ALL])*
  + EXCLUDE_FROM_ALL的含义是将这个目录从编译过程
  + 省略binary_dir,则编译结果将存放到build/src目录下, 指定bin后,
    相当于编译时将src重命名为bin, 所有的 *中间结果和目标二进制*
    都将存放在bin中
**** ADD_TEST
ADD_TEST(testname Exename arg1 arg2 ...)
+ testname 自定义的test名称
+ Exebane  可以是构建的目标文件名, 也可以是外部脚本等
+ arg是传递给可执行文件的参数
+ 没有ENABLE_TESTING指令, 任何ADD_TEST都是无效的
+ 生成Makefile后, 可以运行make test来执行测试

**** AUX_ADD_DIRECTOR
AUX_ADD_DIRECTORY(dir VARIBALE)

发现一个目录下的所有的源文件并将列表存储在一个变量中

**** CMAKE_MINIMUM_REQUIRED
CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR])

**** ENABLE_TESTING
ENABLE_TESTING指令用来控制Makefile是否构建test目标, 语法简单不带任
何参数, ENABLE_TESTING(), 一般放在工程的主CMakeLists.txt中.
**** EXEC_PROGRAM
在CMakeLists.txt处理过程中执行命令, 并不会在生成的Makefile中执行.
#+BEGIN_EXAMPLE
  EXEC_PROGRAM(Executable [dir in which to run]
                          [ARGS <arguments to executable]
                          [OUTPUT_VARIBLE <var>]
                          [RETURN_VALUE <var>])
#+END_EXAMPLE

**** FILE 文件操作指令
#+BEGIN_EXAMPLE
  FILE(WRITE filename "message to write"...)
  FILE(APPEND filename "messag to write"...)
  FILE(READ filename variable)
  FILE(GLOB variable [RELATIVE path] [globbing expressions]...)
  FILE(GLOB_RECURSE variable [RELATIVE path]
                    [globbing expressions]...)
  FILE(REMOVE [derectory])
  FILE(REMOVE_RECURSE [directory])
  FILE(MAKE_DIRECTORY [directory])
  FILE(RELATIVE_PATH variable directory file)
  FILE(TO_MAKE_PATH path result)
  FILE(TO_NATIVE_PAHT path result)
#+END_EXAMPLE

**** FIND_LIBARAY
**** FIND_PACKAGE
#+BEGIN_EXAMPLE
  FIND_PACHAGE(<name> [major.minor] [QUIET] [NO_MODULE]
                      [[REQUIRED | COMPONENTS] [compenents...]])
#+END_EXAMPLE

**** FIND_PATH
+ 功能: 用来指定在路径中搜索文件名
+ 语法:
  #+BEGIN_EXAMPLE
    FIND_PATH(myHeader NAMES filename PATHS patsh)
  #+END_EXAMPLE

+ 省略路径则使用CMAKE_INCLUDE_PATH中定义的路径.

+ 注:如果不使用FIND_PAHT,CMAKE_INCLUDE_PATH变量的设置是没有作用的,
  它不会为编译器命令添加参数 -I <CMAKE_INCLUDE_PATH>的.
**** FIND_PATH
FIND_PATH(<VAR> name path1 path2 ...)
**** FIND_PROGRAM
FIND_PROGRAM(<VAR> name path1 path2 ...)
**** GET_TARGET_PROPERTY
+ 格式: GET_TARGET_PROPERTY(VAR target property)
+ e.g.
  #+BEGIN_EXAMPLE
    GET_TARGET_PROPERTY(OUTPUT_VALUE hello_static OUTPUT_NAME)
    MESSAGE(STATUS "This is the hello_static OUTPUT_NAME:"${OUTPUT_VALUE})
  #+END_EXAMPLE
**** INCLUDE
用来载入CMakeLists.txt文件或预定义的cmake模块
#+BEGIN_EXAMPLE
  INCLUDE(file [OPTIONAL])
  INCLUDE(module [OPTIONAL])
#+END_EXAMPLE
+ OPTIONAL参数用来设置文件不存在也不会产生错误
+ 模块将在CMAKE_MODULE_PATH中搜索并载入
+ 载入的内容将在处理到INCLUDE语句时直接执行
**** INCLUDE_DIRECTORIES
+ 引入头文件搜索路径
+ 语法:
  #+BEGIN_EXAMPLE
    INCLUDE_DERECTORIES([AFTER|BEFORE] [SYSTEM]
                        dir1 dir2 ....         )
  #+END_EXAMPLE
+ 路径中包含空格时需要使用双引号括起来
+ 默认追加到当前的头文件搜索路径的后面
  + CMAKE_INCLUDE_DIRECTORIES_BEFORE 设为 on 时, 追加到前
  + 使用 AFTER | BEFORE 参数改变行为
**** INSTALL指令
*INSTALL* 指令用于定义安装规则, 安装的内容可以包括目标二进制, 动态库,
静态库, 目录, 脚本等.

1. INSTALL 目标文件
   格式:
   #+BEGIN_EXAMPLE
     INSTALL(TARGET targets ...
             [[ARCHIVE | LIBRARY | RUNTIME]
                       [DESTINATION <dir>]
                       [PREMISSIONS premissions...]
                       [CONFIGURATIONS [Debug | Release ...]]
                       [COMPONENT <component>]
                       [OPTIONAL]
                       ] [...])
   #+END_EXAMPLE
   + 目标类型:
     + ARCHIVE: 特指静态库
     + LIBRATY: 动态库
     + RUNTIME: 可执行目标二进制文件
   + DESTINATION: 定义安装路径
     + 以"/"开头, 表绝对路径, CMAKE_INSTALL_PREFIX无效
     + 否则表相对路径, 此时安装路径为:
       ${CMAKE_INSTALL_PREFIX}/<DESTINATION>

   #+BEGIN_EXAMPLE
   INSTALL(TARGETS myrun mylib mystaticlib
   RUNTIME DESTINATION bin
   LIBRARY DESTINATION lib
   ARCHIVE DESTINATION libstatic)
   #+END_EXAMPLE

   注: 不需要关心TARGETS具体生成的路径, 只要写上TARGETS的名称就可以
   了.
2. INSTALL 普通文件
   + 格式:
      #+BEGIN_EXAMPLE
        INSTALL(FILES files... DESTINATION <dir>
                [PREMISSION premission ...]
                [CONFIGURATIONS [Debug|Release|...]]
                [COMPONENT <component>]
                [RENAME <name>] [OPTIONAL])
     #+END_EXAMPLE

   + 功能: 安装一般文件, 并可指定访问权限, 文件名是此指令所在路径下
     的相对路径. 默认权限为: OWNER_WRITE, OWNER_READ, GROUP_READ,
     和WORLD_READ, 即644.
3. 非目标文件的可执行程序安装(脚本等)
   + 格式:
     #+BEGIN_EXAMPLE
        INSTALL(PROGRAMS files... DESTINATION <dir>
                [PREMISSION premission ...]
                [CONFIGURATIONS [Debug|Release|...]]
                [COMPONENT <component>]
                [RENAME <name>] [OPTIONAL])
     #+END_EXAMPLE
     和FIFLES使用方法一样, 权限不同, 为755
4. 目录的安装
   #+BEGIN_EXAMPLE
     INSTALL(DIRECTORY dirs... DESTINATION <dir>
             [FILE_PREMISSIONS premissions...]
             [DIRECTORY_PREMISSIONS permissions...]
             [USE_SOURCE_PREMISSIONS]
             [CONFIGURATIONS [Debug|Release|...]]
             [COMPONENT <component>]
             [[PATTERN <pattern> | REGEX <regex>]
              [EXCLUDE] [PREMISSIONS <permissions...]]
             [...])
   #+END_EXAMPLE
   + DIRECTORY后面连接的是所有Source目录的相对路径, abc/ 和 abc 有
     很大区别
   + PATTERN 表示使用正则表达式过滤
   + PREMISSIONS 表示过滤后的文件权限
5. 安装脚本
   #+BEGIN_EXAMPLE
     INSTALL([SCRIPT <file>] [CODE <code>] [...])
   #+END_EXAMPLE
   + SCRIPT 用于安装时调用cmake脚本文件, abc.cmake
   + INSTALL 用于执行CMake指令, 必须使用双引号括起来
     eg.
     #+BEGIN_EXAMPLE
       INSTALL(CODE "MESSAGE(\\"Sample install message\")")
     #+END_EXAMPLE

**** LINK_DIRECTORIES
**** LINK_LIBRARIES
+ 添加共享库
+ 语法:
  + LINK_DIRECTORIES(dir1 dir2 ...)
    添加非标准的共享库的搜索路径.
  + TARGET_LINK_LIBRARIES
    #+BEGIN_EXAMPLE
      TARGET_LINK_LIBRARIES(target library1
                            <debug | optimized> library2
                            ...)
    #+END_EXAMPLE
    为target(可执行文件或共享库等)
+ eg. 链接到动态库
  #+BEGIN_EXAMPLE
    TARGET_LINK_LIBRARIES(main hello)
    # OR
    TARGET_LINK_LIBRARIES(main libhello.so)
  #+END_EXAMPLE
**** MESSAGE

+ 格式: MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR], "message to
  display")
  + SEND_ERROR: 产生错误, 生成过程被跳过
  + STATUS: 输出前缀为"-"的信息
  + FATAL_ERROR: 立即终止所有cmake过程
**** PORJECT
+ 格式: PROJECT(projectname [CXX] [C] [Java])
+ 功能: 指定工程名称, 和工程支持的语言, 语言列表可选, 默认表示支持
  所有.
+ 说明:
  + 隐式定义了两个变量: *projectname_SOURCE_DIR* 和
    *projectname_BINARY_DIR*, 内部编译时, 指向工程目录
  + 预定义 *PROJECT_SOURCE_DIR* 和 *PROJECT_BINARY_DIR*, 分别与上述
    两个变量等价.
**** SET
+ 格式: SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])

**** SET_TARGET_PROPERTIES
+ 语法
  #+BEGIN_EXAMPLE
    SET_TARGET_PROPERTIES(target1 targets ...
                          PROPERTIES prop1 value1
                                     prop2 value2)
  #+END_EXAMPLE
+ 该指令可以用于设置输出的名称, 对于动态库, 还可以 指定其动态库版本
  和API版本.
+ eg. 动态库和静态库同名
  #+BEGIN_EXAMPLE
    SET(LIBHELLO_SRC hello.c)
    SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
    ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
    ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})
    SET_TARGET_PROPERTY(hello_static PROPERTIES OUTPUT_NAME "hello")
  #+END_EXAMPLE
+ eg 版本号
  #+BEGIN_EXAMPLE
  SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)
#+END_EXAMPLE
   + VERSION: 指代动态库版本号
   + SOVERSION: 指代API版本
**** SUBDIR
SUBDIR(dir1 dir2 ...) 一次添加多个子目录, 但已不推荐使用

**** 控制指令
***** IF
   #+BEGIN_EXAMPLE
     IF(expression)
         # THEN section
         COMMAND1(ARGS ...)
         COMMAND2(ARGS ...)
         ...
     ELSE(expression)
         # ELSE sectioono
         COMMAND1(ARGS ...)
         COMMAND2(ARGS ...)
         ...
     ENDIF(expression)
   #+END_EXAMPLE
   凡是出现IF的地方一定要对应有ENDIF, 出现ELSEIF的地方, ENDIF是可选的.

   + IF(var): 变量不是: 空, 0, N, NO, OFF, FALSE, NOTFOUND或
     <var>_NOTFOUND时, 表达式为真
   + IF(NOT var)
   + IF(var1 AND var2)
   + IF(var1 OR var2)
   + IF(COMMAND cmd), 当给定的cmd确实是命令且可以调用时为真
   + IF(EXISTS dir/file) 目录或文件存在时为真
   + IF(fileq1 IS_NEWER_THAN file2)
   + IF(ID_DIRECTORY dirname)
   + IF(variable MATCHES regex)
   + IF(string MATCHED regex)

   + IF(varible LESS number)
   + IF(string LESS number)
   + IF(variable GREATER number)
   + IF(string GREATER number)
   + IF(variable EQUAL number)
   + IF(string EQUAL number)

   + IF(var/str STRLESS/STRGREATER/STREQUAL string)

   + IF(DEFINED variable)

   #+BEGIN_EXAMPLE
     IF(WIN32)
         MESSAGE(STATUS "This is windows")
     ELSE(WIN32)     # 容易造成歧义
         MESSAGE(STATUS "This is not windows")
     END(IF)
   #+END_EXAMPLE

   使用开关: *CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS*
   #+BEGIN_EXAMPLE
     SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)

     IF(WIN32)
     ELSE()
     ENDIF()
   #+END_EXAMPLE

***** WHILE
   #+BEGIN_EXAMPLE
     WHILE(condition)
         COMMAND1(ARGS ...)
         COMMAND2(ARGS ...)
         ...
     ENDWHILE(condition)
   #+END_EXAMPLE

***** FOREACH
   1) 列表
      #+BEGIN_EXAMPLE
        FOREACH(loop_var arg1 arg2 ...)
            COMMAND1(ARGS ...)
            COMMAND2(ARGS ...)
            ....
        ENDFOREACH(loop_var)
      #+END_EXAMPLE
      eg.
      #+BEGIN_EXAMPLE
        AUX_SOURCE_DIRECTORY(. SRC_LIST)
        FOREACH(F ${SRC_LIST})
            MESSAGE(${F})
        ENDFOREACH(F)
      #+END_EXAMPLE

   2) 范围
      #+BEGIN_EXAMPLE
        FOREACH(loop_var RANGE total)
        ENDFOREACH(loop_var)
      #+END_EXAMPLE
      从0到total以1步进

   3) 范围和步进
      #+BEGIN_EXAMPLE
        FOREACH(loop_var RANGE start stop [step])
        ENDFOREACH(loop_var)
      #+END_EXAMPLE

   4) 该指令需要注意的是, 直到遇到了ENDFOREACH指令, 整个语句块才会被真
      正的执行.

*** 变量
**** CMAKE_BINARY_DIR, PROJECT_BINARY_DIR, <projectname>_BINARY_DIR
+ in-source: 工程顶层目录
+ out-of-source: 编译目录
**** CMAKE_CURRENT_BINARY_DIR
+ in-source: CMAKE_CURRENT_SOURCE_DIR
+ out-of--source: target编译目录
+ 注: ADD_SUBDIRECTORY(src bin)可以改变该变量
+ 注:SET(EXECUTABLE_OUTPUT_PATH <path>)不会影响该变量
**** CMAKE_CURRENT_LIST_FILE
输出调用该变量的CMakeLists.txt的完整路径
**** CMAKE_CURRENT_LIST_LINE
输出调用该变量所在的行
**** CMAKE_CURRENT_SOURCE_DIR
当前CMakeLists.txt所在目录
**** CMAKE_INSTALL_PREFIX
CMAKE_INSTALL_PREFIX 的默认定义为 */usr/local*
#+BEGIN_EXAMPLE
  cmake -DCMAKE_INSTALL_PREFIX=/usr
#+END_EXAMPLE
**** CMAKE_MODULE_PATH
定义cmake模块所在路径
   + 杂的工程需要使用模块
   + SET定义
   + 使用INCLUDE指令调用．
**** CMAKE_SOURCE_DIR, PROJECT_SOURCE_DIR, <projectname>_SOURCE_DIR
工程顶层目录
**** EXECUTABLE_OUT_PATH
EXECUTABLE_OUTPUT_PATH指定目标二进制的位置和共享库的位置(不包括编译生
成的中间文件)
#+BEGIN_EXAMPLE
  SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
#+END_EXAMPLE
注: *在哪里ADD_EXECUTABLE, 如果需要改变目标文件存放目录,就在哪里加入上
述定义*

**** LIBRARY_OUTPUT_PATH
LIBRARY_OUTPUT_PATH指定目标二进制的位置和共享库的位置(不包括编译生成的
中间文件)
#+BEGIN_EXAMPLE
  SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
#+END_EXAMPLE
注: *在哪里ADD_LIBRARY, 如果需要改变目标文件存放目录,就在哪里加入上述
定义*

**** PROJECT_NAME
返回PROJECT定义的名称
**** 开头选项
***** CMAKE_ALLOW_LOOSE_CONSTRUCTS
控制IF ELSE书写方式
***** BUILD_SHARE_LIBS
控制默认的库编译方式，　默认为静态库
eg
#+BEGIN_EXAMPLE
 SET(BUILD_SHARED_LIBS on)
#+END_EXAMPLE
***** CMAKE_C_FLAGS
设置C编译选项，也可以使用ADD_DEFINITIONS()添加
***** CMAKE_CXX_FLAGS
设置C++编译选项，也可以使用ADD_DEFINTIONS()添加．
**** 系统信息
***** CMAKE_MAJOR_VERSION
主版本号， *2*.4.6
***** CMAKE_MINOR_VERSION
次版本号， 2. *4*.6
***** CMAKE_PATCH_VERSION
补丁等级， 2.4. *6*
***** CMAKE_SYSTEM
系统名称，如Linux-2.6.22
***** CMAKE_SYSTEM_NAME
不包含版本号
***** CMAKE_SYSTEM_VERSION
系统版本号
***** CMAKE_SYSTEM_PROCESSOR
处理器名称　eg. i686
***** UNIX
类UNIX平台下为TRUE,包括OS X和cygwin
***** WIN32
Win32平台下为TRUE，包括cygwin
*** 环境变量
**** CMAKE_INCLUDE_CURRENT_DIR
自动添加CMAKE_CURRENT_BINARY_DIR和CMAKE_CURRENT_SOURCR_DIR到当前处
理的CMakeLists.txt
**** CMAKE_INCLUDE_DIRECTORY_PROJECT_BEFORE
工程提供的头文件目录始终置于系统头文件之前

**** CMAKE_INCLUDE_PATH
**** CMAKE_LIBRARY_PATH
**** 设置 *SET{ENV{变量名}　值}*
**** 调用: *$ENV{}*
   eg.
   #+BEGIN_EXAMPLE
   MESSAGE(STATUS "HOME dir: $ENV(HOME)")
   #+END_EXAMPLE
** Quick Guide: CMake Practice                                       :guide:

[[~/Wally/Reference/Guide/CMakePractice.pdf][CMakePractice.pdf]]

*** CMake简介

1. 特点:
   + 开放源代码
   + 跨平台, 生成native编译配置文件
     + Linux/Unix -> makefile
     + MacOX -> xcode
     + Windows -> MSVC
   + 能够管理大型项目, eg. KED4
   + 简化编译过程: cmake+make
   + 高效率
   + 可扩展

2. 问题
   + CMake简单,但不很简单
   + CMake本身就是编程

3. 建议

   + 无项目需求则无必要学习, CMake的学习过程就是实践的过程
   + 小工程则直接编写编写makefile
   + C/C++/Java外不要使用cmake
   + 仅仅使用qt编程, 没有必要使用cmake, qmake更优

*** helloworld
**** CMakeLists.txt
*CMakeLists.txt* 注意大小写.
#+BEGIN_EXAMPLE
PROJECT(HELLO)
SET(SRC main.c)
MESSAGE(STATUS "This is BINARY dir " ${HELLO_BINARY_DIR})
MESSAGE(STATUS "This is SOURCE dir" ${HELLO_SOURCE_DIR})
ADD_EXECUTABLE(hello  ${SRC_LIST})
#+END_EXAMPLE
1. PORJECT
   + 格式: PROJECT(projectname [CXX] [C] [Java])
   + 功能: 指定工程名称, 和工程支持的语言, 语言列表可选, 默认表示支持
     所有.
   + 说明:
     + 隐式定义了两个变量: *projectname_SOURCE_DIR* 和
       *projectname_BINARY_DIR*, 内部编译时, 指向工程目录
     + 预定义 *PROJECT_SOURCE_DIR* 和 *PROJECT_BINARY_DIR*, 分别与上述
       两个变量等价.
2. SET
   + 格式: SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])
3. MESSAGE
   + 格式: MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR], "message to
     display")
     + SEND_ERROR: 产生错误, 生成过程被跳过
     + STATUS: 输出前缀为"-"的信息
     + FATAL_ERROR: 立即终止所有cmake过程
4. ADD_EXECUTABLE
   定义生成的可执行文件名称, 及源文件列表.
   可执行文件名与工程名无关, eg. HELLO hello
5. 变量引用方式
   *${VAR}*

**** 编译
#+BEGIN_EXAMPLE
$ cmake .
$ make VERBOSE=1
#+END_EXAMPLE

**** 基本语法规则
1. 变量使用 ${} 引用, IF控制语句中可直接使用变量名
2. 指令(参数1 参数2 ...)
   + 参数使用括号括起
   + 参数之间使用 *空格 或 分号* 隔开
     eg. ADD_EXECUTABLE(hello main.c; func.c)
3. 指令是大小写无关的, 参数和变量是大小写相关的, *建议全部使用大写指
   令*
4. 文件名可以使用双引号括起, 也可以不用, 只有当文件名中包含空格时才必
   须使用双引号
   + e.g.  SET(SRC_LIST "fu nc.c")
5. 源文件后缀名可以省略, 当然最好不要偷懒.

**** 清理工程
跟经典的autotools系列工具一样: *make clean*

注: make distclean 用于清理构建过程中产生的中间文件, 但CMake不支持.

**** 内部构建 和 外部构建
+ 内部构建(in-source build)
+ 外部构建(out-of-source build): cmake强烈推荐

外部构建对原有工程没有任何影响, 所有动作全部都发生在编译目录中
#+BEGIN_EXAMPLE
$ mdir build
$ cd build
$ cmake ..
#+END_EXAMPLE
通过外部进行工程构建, PROJECT_SOURCE_DIR仍然指代工程目录,
PROJECT_BINARY_DIR指代编译目录build

*** 更好一点的helloworld
**** 没有最好, 只有更好
+ *src* 目录放置源代码
+ *doc* 目录放置工程文档
+ *COPYRIGHT* 和 *README* 文本文件
+ *runhello.sh* 脚本文件, 用以调用hello二进制
+ *bin* 目录放置目标文件
+ 安装文件:
  + 将hello二进制与runhello.sh安装至 */usr/bin*
  + 将doc目录的内容以及COPYRIGHT和READEM安装至
    */usr/share/doc/cmake/t2*

**** helloworld工程
1. 工程目录hello
   + CMakeLists.txt
     #+BEGIN_EXAMPLE
     ADD_SUBDIRECTORY(hello main.c)
     #+END_EXAMPLE
2. src
   + CMakeLists.txt
     #+BEGIN_EXAMPLE
     PORJECT(HELLO)
     ADD_SUBDIRECTORY(src bin)
     #+END_EXAMPLE
   + *ADD_SUBDIRECTORY*
     + 向工程中添加存放源文件的目录, 并指定中间二进制文件和目标二进制
       文件的存放位置
     + 格式: *ADD_SUBDIRECTORY(source_dir [binary_dir]
       [EXCLUDE_FROM_ALL])*
       + EXCLUDE_FROM_ALL的含义是将这个目录从编译过程
       + 省略binary_dir,则编译结果将存放到build/src目录下, 指定bin后,
         相当于编译时将src重命名为bin, 所有的 *中间结果和目标二进制*
         都将存放在bin中
   + SUBDIR
     SUBDIR(dir1 dir2 ...) 一次添加多个子目录, 但已不推荐使用
3. bin
   可以通过指定 *EXECUTABLE_OUTPUT_PATH* 和 *LIBRARY_OUTPUT_PATH* 来最
   终指定目标二进制的位置和共享库的位置(不包括编译生成的中间文件)
   #+BEGIN_EXAMPLE
     SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
     SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
   #+END_EXAMPLE
   *在哪里ADD_EXECUTABLE或ADD_LIBRARY, 如果需要改变目标文件存放目录,就
   在哪里加入上述定义*
4. 安装
   1) 安装方式:
      + 编译代码后使用make install安装
        + 默认安装到/usr/bin
        + 使用 *DESTDIR* 指定: make install DESTDIR=/tmp/test/bin
      + 打包时指定目录安装(Makefile), 稍微复杂的还要定义PREFIX
        #+BEGIN_EXAMPLE
          DESTDIR=
          PREFIX=/usr
          install:
                  mkdir -p $(DESTDIR)/$(PREFIX)/bin
                  install -m 755 hello $(DESTDIR)/$(PREFIX)/bin
        #+END_EXAMPLE
   2) cmake
      + INSTALL指令
        *INSTALL* 指令用于定义安装规则, 安装的内容可以包括目标二进制,
        动态库, 静态库, 目录, 脚本等.
      + 变量 CMAKE_INSTALL_PREFIX
      + cmake -DCMAKE_INSTALL_PREFIX=/usr
   3) INSTALL 目标文件
      格式:
      #+BEGIN_EXAMPLE
        INSTALL(TARGET targets ...
                [[ARCHIVE | LIBRARY | RUNTIME]
                          [DESTINATION <dir>]
                          [PREMISSIONS premissions...]
                          [CONFIGURATIONS [Debug | Release ...]]
                          [COMPONENT <component>]
                          [OPTIONAL]
                          ] [...])
      #+END_EXAMPLE
      + 目标类型:
        + ARCHIVE: 特指静态库
        + LIBRATY: 动态库
        + RUNTIME: 可执行目标二进制文件
      + DESTINATION: 定义安装路径
        + 以"/"开头, 表绝对路径, CMAKE_INSTALL_PREFIX无效
        + 否则表相对路径, 此时安装路径为:
          ${CMAKE_INSTALL_PREFIX}/<DESTINATION>

      #+BEGIN_EXAMPLE
      INSTALL(TARGETS myrun mylib mystaticlib
      RUNTIME DESTINATION bin
      LIBRARY DESTINATION lib
      ARCHIVE DESTINATION libstatic)
      #+END_EXAMPLE

      注: 不需要关心TARGETS具体生成的路径, 只要写上TARGETS的名称就可以
      了.
   4) INSTALL 普通文件
      + 格式:
         #+BEGIN_EXAMPLE
           INSTALL(FILES files... DESTINATION <dir>
                   [PREMISSION premission ...]
                   [CONFIGURATIONS [Debug|Release|...]]
                   [COMPONENT <component>]
                   [RENAME <name>] [OPTIONAL])
        #+END_EXAMPLE

      + 功能: 安装一般文件, 并可指定访问权限, 文件名是此指令所在路径下
        的相对路径. 默认权限为: OWNER_WRITE, OWNER_READ, GROUP_READ,
        和WORLD_READ, 即644.
   5) 非目标文件的可执行程序安装(脚本等)
      + 格式:
        #+BEGIN_EXAMPLE
           INSTALL(PROGRAMS files... DESTINATION <dir>
                   [PREMISSION premission ...]
                   [CONFIGURATIONS [Debug|Release|...]]
                   [COMPONENT <component>]
                   [RENAME <name>] [OPTIONAL])
        #+END_EXAMPLE
        和FIFLES使用方法一样, 权限不同, 为755
   6) 目录的安装
      #+BEGIN_EXAMPLE
        INSTALL(DIRECTORY dirs... DESTINATION <dir>
                [FILE_PREMISSIONS premissions...]
                [DIRECTORY_PREMISSIONS permissions...]
                [USE_SOURCE_PREMISSIONS]
                [CONFIGURATIONS [Debug|Release|...]]
                [COMPONENT <component>]
                [[PATTERN <pattern> | REGEX <regex>]
                 [EXCLUDE] [PREMISSIONS <permissions...]]
                [...])
      #+END_EXAMPLE
      + DIRECTORY后面连接的是所有Source目录的相对路径, abc/ 和 abc 有
        很大区别
      + PATTERN 表示使用正则表达式过滤
      + PREMISSIONS 表示过滤后的文件权限
   7) 安装脚本
      #+BEGIN_EXAMPLE
        INSTALL([SCRIPT <file>] [CODE <code>] [...])
      #+END_EXAMPLE
      + SCRIPT 用于安装时调用cmake脚本文件, abc.cmake
      + INSTALL 用于执行CMake指令, 必须使用双引号括起来
        eg.
        #+BEGIN_EXAMPLE
          INSTALL(CODE "MESSAGE(\\"Sample install message\")")
        #+END_EXAMPLE
5. helloworld
   1) doc/hello.txt
      + 方式1: 在doc目录下建立CMakeLists.txt,并通过ADD_SUBDIRECTORY加
        入到工程中

      + 方式2: 在工程目录的CMakeLists.txt完成
        #+BEGIN_EXAMPLE
          INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake/t2)
        #+END_EXAMPLE
   2) runhello.sh
      #+BEGIN_EXAMPLE
        # 在工程目录的CMakeLists.txt
        INSATLL(PROGRAMS runhello.sh DESTINATION bin)
      #+END_EXAMPLE
   3) COPYRIGHT 和 README
      #+BEGIN_EXAMPLE
        # 在工程目录的CMakeLists.txt
        INSTALL(FIFES COPYRIGHT README DESTINATION share/doc/cmake/t2)
      #+END_EXAMPLE
   4) 安装
      #+BEGIN_EXAMPLE
        $ cmake -DCMAKE_INSTALL_PREFIX=/tmp/t2/usr ..
        $ make
        $ make install
      #+END_EXAMPLE
6. CMAKE_INSTALL_PREFIX 的默认定义为 */usr/local*
*** 静态库和动态链接库
**** 建立共享库
1. 工程CMakeLists.txt
   #+BEGIN_EXAMPLE
     PROJECT(HELLOLIB)
     ADD_SUBDIRECTORY(lib)
   #+END_EXAMPLE
2. lib CMakeLists.txt
   --lib
     \ -- hello.c
     \ -- hello.h
     \ -- CMakeLists.txt
   #+BEGIN_EXAMPLE
     SET(LIBHELLO_SRC hello.c)
     ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
   #+END_EXAMPLE
3. *SET(LIBRARY_OUTPUT_PATH <path>)* 指定链接库位置
4. 生成的库自动添加前缀 *lib* 和 相应后缀, eg. hello -> libhello.so
**** *ADD_LIBRARY*
+ 格式
  #+BEGIN_EXAMPLE
    ADD_LIBRARY(libname [SHARED | STATIC | MODULE]
                [EXCLUDE_FROM_ALL]
                source1 source2 ...)
  #+END_EXAMPLE
+ 类型:
  + SHARED: 动态库, 后缀 *.so*
  + STATIC: 静态库, 后缀 *.a*
  + MODELE: 在使用dyld的系统中有效, 如果不支持dyld, 则被当作SHARED对待.
**** 静态库
1. 静态链接库和动态链接库的名称应该是一致的, 只不过后缀名是 *.a* 罢了.
2. lib CMakeLists.txt
   #+BEGIN_EXAMPLE
     SET(LIBHELLO_SRC hello.c)
     SET(LIBRARY_OUTPUT_PATH .)
     ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
     ADD_LIBRARY(hello STATIC ${LIBHELLO_SRC})
   #+END_EXAMPLE
   注: target名称是唯一的, 生成同名的静态库的动态库不能通过ADD_LIBRARY
   实现.
3. SET_TARGET_PROPERTIES
   + 语法
     #+BEGIN_EXAMPLE
       SET_TARGET_PROPERTIES(target1 targets ...
                             PROPERTIES prop1 value1
                                        prop2 value2)
     #+END_EXAMPLE
   + 该指令可以用于设置输出的名称, 对于动态库, 还可以 指定其动态库版本
     和API版本.
   + CMakeLists.txt
     #+BEGIN_EXAMPLE
       SET(LIBHELLO_SRC hello.c)
       SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
       ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
       ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})
       SET_TARGET_PROPERTY(hello_static PROPERTIES OUTPUT_NAME "hello")
     #+END_EXAMPLE
4. GET_TARGET_PROPERTY
   + 格式: GET_TARGET_PROPERTY(VAR target property)
   + e.g.
     #+BEGIN_EXAMPLE
       GET_TARGET_PROPERTY(OUTPUT_VALUE hello_static OUTPUT_NAME)
       MESSAGE(STATUS "This is the hello_static OUTPUT_NAME:"${OUTPUT_VALUE})
     #+END_EXAMPLE
     注: *warning* Argument not separated from preceding token by
     whitespace.
**** 动态库版本号
按照规则, 动态库是应该包含一个版本号的.
#+BEGIN_EXAMPLE
  libhello.so.1.2
  libhello.so -> libhello.so.1
  libhello.so.1 -> libhello.so.1.2
#+END_EXAMPLE
注: 此处 *->* 表文件link
#+BEGIN_EXAMPLE
  SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)
#+END_EXAMPLE
+ VERSION: 指代动态库版本号
+ SOVERSION: 指代API版本
**** 安装共享库和头文件
我们需要将 *.a, .so.x, 以及头文件* 安装到系统目录中, 才能真正让别人开
发使用
+ hello.a hello.so.1.2 -> <prefix>/lib/
+ hello.h -> <prefix>/include/hello

#+BEGIN_EXAMPLE
  INSTALL(TARGETS hello hello_static
          LIBRARY DESTINATION lib
          ARCHIVE DESTINATION lib)
  INSTALL(FILES hello.h
          DESTINATION include/hello)
#+END_EXAMPLE
*** 如何使用外部共享库和头文件
**** 引入头文件搜索路径
+ make错误: /fatal error: hello.h: 没有那个文件或目录/
+ 命令: *INCLUDE_DIRECTORIES*
+ 语法:
  #+BEGIN_EXAMPLE
    INCLUDE_DERECTORIES([AFTER|BEFORE] [SYSTEM]
                        dir1 dir2 ....         )
  #+END_EXAMPLE
+ 路径中包含空格时需要使用双引号括起来
+ 默认追加到当前的头文件搜索路径的后面
  + CMAKE_INCLUDE_DIRECTORIES_BEFORE 设为 on 时, 追加到前
  + 使用 AFTER | BEFORE 参数改变行为
**** 为target添加共享库
+ make错误: /对‘HelloFunc’未定义的引用/
+ 命令: *LINK_DIRECTORIES* & *TARGET_LINK_LIBRARIES*
+ 语法:
  + LINK_DIRECTORIES(dir1 dir2 ...)
    添加非标准的共享库的搜索路径.
  + TARGET_LINK_LIBRARIES
    #+BEGIN_EXAMPLE
      TARGET_LINK_LIBRARIES(target library1
                            <debug | optimized> library2
                            ...)
    #+END_EXAMPLE
    为target(可执行文件或共享库等)
+ 链接到动态库
  #+BEGIN_EXAMPLE
    TARGET_LINK_LIBRARIES(main hello)
    # OR
    TARGET_LINK_LIBRARIES(main libhello.so)
  #+END_EXAMPLE

  查看链接: *$ ldd src/main*
  #+BEGIN_EXAMPLE
    linux-gate.so.1 =>  (0xb77d3000)
    libhello.so.1 => /usr/lib/libhello.so.1 (0xb779f000)
    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb75f1000)
    /lib/ld-linux.so.2 (0xb77d4000)
  #+END_EXAMPLE

+ 链接到静态库
  #+BEGIN_EXAMPLE
    TARGET_LINK_LIBRARIES(main libhello.a)
  #+END_EXAMPLE
  查看链接: *$ ldd src/main*
  #+BEGIN_EXAMPLE
    linux-gate.so.1 =>  (0xb7711000)
    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7532000)
    /lib/ld-linux.so.2 (0xb7712000)
  #+END_EXAMPLE

**** 特殊的环境变量 *CMAKE_INCLUDE_PATH* 和 *CMAKE_LIBRARY_PATH*
这两个 *是环境变量, 而不是cmake变量*, 使用方法是在bash中使用export设置.
1. 智能版的 INCLUDE_DIRECTORIES
   #+BEGIN_EXAMPLE
     $ export CMAKE_INCLUDE_PATH=/usr/include/hello
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     FIND_PATH(myHeader hello.h)
     IF(myHeader)
     INCLUDE_DIRECTORIES(${myHeader})
     ENDIF(myHeader)
   #+END_EXAMPLE

2. FIND_PATH
   + 功能: 用来指定在路径中搜索文件名
   + 语法:
     #+BEGIN_EXAMPLE
       FIND_PATH(myHeader NAMES filename PATHS patsh)
     #+END_EXAMPLE

     省略路径则使用CMAKE_INCLUDE_PATH中定义的路径.

     注:如果不使用FIND_PAHT,CMAKE_INCLUDE_PATH变量的设置是没有作用的,
     它不会为编译器命令添加参数 -I <CMAKE_INCLUDE_PATH>的.
3. FIND_LIBARAY
   同样, CMAKE_LIBRARY_PATH可以用在FIND_LIBRARY.

   因为这些变量直接为FIND_w指令所使用, 所以其对所有使用FIND_指令的
   cmake的模块都有益.

*** 常用变量和常用环境变量
**** CMake变量引用
${}
**** CMake自定义变量
1. 隐式 eg. PROJECT隐式定义两个变量
2. 显式 *SET* 指令
**** CMake常用变量
1. CMAKE_BINARY_DIR, PROJECT_BINARY_DIR, <projectname>_BINARY_DIR
   + in-source: 工程顶层目录
   + out-of-source: 编译目录
2. CMAKE_SOURCE_DIR, PROJECT_SOURCE_DIR, <projectname>_SOURCE_DIR
   工程顶层目录
3. CMAKE_CURRENT_SOURCE_DIR 当前CMakeLists.txt所在目录
4. CMAKE_CURRENT_BINARY_DIR
   + in-source: CMAKE_CURRENT_SOURCE_DIR
   + out-of--source: target编译目录
   + 注: ADD_SUBDIRECTORY(src bin)可以改变该变量
   + 注:SET(EXECUTABLE_OUTPUT_PATH <path>)不会影响该变量
5. CMAKE_CURRENT_LIST_FILE  输出调用该变量的CMakeLists.txt的完整路径
6. CMAKE_CURRENT_LIST_LINE  输出调用该变量所在的行
7. CMAKE_MODULE_PATH  定义cmake模块所在路径
   + 杂的工程需要使用模块
   + SET定义
   + 使用INCLUDE指令调用．
8. EXECUTABLE_OUTPUT_PATH
9. LIBRARY_OUTPUT_PATH
10. PROJECT_NAME  返回PROJECT定义的名称

**** CMake调用环境变量　
1. 调用: *$ENV{}*
   eg.
   #+BEGIN_EXAMPLE
   MESSAGE(STATUS "HOME dir: $ENV(HOME)")
   #+END_EXAMPLE
2. 设置 *SET{ENV{变量名}　值}*
3. CMAKE_INCLUDE_CURRENT_DIR
   自动添加CMAKE_CURRENT_BINARY_DIR和CMAKE_CURRENT_SOURCR_DIR到当前处
   理的CMakeLists.txt
4. CMAKE_INCLUDE_DIRECTORY_PROJECT_BEFORE
   工程提供的头文件目录始终置于系统头文件之前
5. CMAKE_INCLUDE_PATH
6. CMAKE_LIBRARY_PATH

**** 系统信息
1. CMAKE_MAJOR_VERSION  主版本号， *2*.4.6
2. CMAKE_MINOR_VERSION  次版本号， 2. *4*.6
3. CMAKE_PATCH_VERSION  补丁等级， 2.4. *6*
4. CMAKE_SYSTEM  系统名称，如Linux-2.6.22
5. CMAKE_SYSTEM_NAME 不包含版本号
6. CMAKE_SYSTEM_VERSION 系统版本号
7. CMAKE_SYSTEM_PROCESSOR  处理器名称　eg. i686
8. UNIX 类UNIX平台下为TRUE,包括OS X和cygwin
9. WIN32 Win32平台下为TRUE，包括cygwin

**** 主要开关选项
1. CMAKE_ALLOW_LOOSE_CONSTRUCTS 控制IF ELSE书写方式
2. BUILD_SHARE_LIBS  控制默认的库编译方式，　默认为静态库
   eg
   #+BEGIN_EXAMPLE
   SET(BUILD_SHARED_LIBS on)
   #+END_EXAMPLE
3. CMAKE_C_FLAGS 设置C编译选项，也可以使用ADD_DEFINITIONS()添加
4. CMAKE_CXX_FLAGS  设置C++编译选项，也可以使用ADD_DEFINTIONS()添加．
*** CMake常用指令

*CMake即编程*

**** 基本指令
1. ADD_DEFINITIONS 向C/C++编译器添加-D定义
   eg.
   #+BEGIN_EXAMPLE
   ADD_DEFINITONS(-DENABLE_DEBUG -DABC)
   #+END_EXAMPLE
   参数之间使用空格分割.
   如果代码中定义了#ifdef ENABLE_DEBUG  #endif, 这块代码就会生效.

   其它编译器开关可以通过 *CMAKE_C_FLAGS* 和 *CMAKE_CXX_FLAGS* 变量设
   置.

2. ADD_DEPENDENCIES 定义target秘依赖的其它target, 确保编译本target之前,
   其它的target已经被构建.
   #+BEGIN_EXAMPLE
     ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...)
   #+END_EXAMPLE

3. ADD_EXECUTABLE, ADD_LIBRARY, ADD_SUBDIRECTORY

4. ADD_TEST & ENABLE_TESTING
   ENABLE_TESTING指令用来控制Makefile是否构建test目标, 语法简单不带任
   何参数, ENABLE_TESTING(), 一般放在工程的主CMakeLists.txt中.

   ADD_TEST(testname Exename arg1 arg2 ...)
   + testname 自定义的test名称
   + Exebane  可以是构建的目标文件名, 也可以是外部脚本等
   + arg是传递给可执行文件的参数
   + 没有ENABLE_TESTING指令, 任何ADD_TEST都是无效的
   + 生成Makefile后, 可以运行make test来执行测试
5. AUX_ADD_DIRECTORY(dir VARIBALE)
   发现一个目录下的所有的源文件并将列表存储在一个变量中

6. CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR])

7. EXEC_PROGRAM
   在CMakeLists.txt处理过程中执行命令, 并不会在生成的Makefile中执行.
   #+BEGIN_EXAMPLE
     EXEC_PROGRAM(Executable [dir in which to run]
                             [ARGS <arguments to executable]
                             [OUTPUT_VARIBLE <var>]
                             [RETURN_VALUE <var>])
   #+END_EXAMPLE

8. FILE 文件操作指令
   #+BEGIN_EXAMPLE
     FILE(WRITE filename "message to write"...)
     FILE(APPEND filename "messag to write"...)
     FILE(READ filename variable)
     FILE(GLOB variable [RELATIVE path] [globbing expressions]...)
     FILE(GLOB_RECURSE variable [RELATIVE path]
                       [globbing expressions]...)
     FILE(REMOVE [derectory])
     FILE(REMOVE_RECURSE [directory])
     FILE(MAKE_DIRECTORY [directory])
     FILE(RELATIVE_PATH variable directory file)
     FILE(TO_MAKE_PATH path result)
     FILE(TO_NATIVE_PAHT path result)
   #+END_EXAMPLE

9. INCLUDE
   用来载入CMakeLists.txt文件或预定义的cmake模块
   #+BEGIN_EXAMPLE
     INCLUDE(file [OPTIONAL])
     INCLUDE(module [OPTIONAL])
   #+END_EXAMPLE
   + OPTIONAL参数用来设置文件不存在也不会产生错误
   + 模块将在CMAKE_MODULE_PATH中搜索并载入
   + 载入的内容将在处理到INCLUDE语句时直接执行

**** INSTALL
**** FIND_指令
1. FIND_FILE(<VAR> name1 path1 path2 ...)
   VAR变量代表找到的文件全路径
2. FIND_LIBRARY(<VAR> name path1 path2 ...)
3. FIND_PATH(<VAR> name path1 path2 ...)
4. FIND_PROGRAM(<VAR> name path1 path2 ...)
5. FIND_PACKAGE
   #+BEGIN_EXAMPLE
     FIND_PACHAGE(<name> [major.minor] [QUIET] [NO_MODULE]
                         [[REQUIRED | COMPONENTS] [compenents...]])
   #+END_EXAMPLE

**** COMMENT 控制指令
1. IF
   #+BEGIN_EXAMPLE
     IF(expression)
         # THEN section
         COMMAND1(ARGS ...)
         COMMAND2(ARGS ...)
         ...
     ELSE(expression)
         # ELSE sectioono
         COMMAND1(ARGS ...)
         COMMAND2(ARGS ...)
         ...
     ENDIF(expression)
   #+END_EXAMPLE
   凡是出现IF的地方一定要对应有ENDIF, 出现ELSEIF的地方, ENDIF是可选的.

   + IF(var): 变量不是: 空, 0, N, NO, OFF, FALSE, NOTFOUND或
     <var>_NOTFOUND时, 表达式为真
   + IF(NOT var)
   + IF(var1 AND var2)
   + IF(var1 OR var2)
   + IF(COMMAND cmd), 当给定的cmd确实是命令且可以调用时为真
   + IF(EXISTS dir/file) 目录或文件存在时为真
   + IF(fileq1 IS_NEWER_THAN file2)
   + IF(ID_DIRECTORY dirname)
   + IF(variable MATCHES regex)
   + IF(string MATCHED regex)

   + IF(varible LESS number)
   + IF(string LESS number)
   + IF(variable GREATER number)
   + IF(string GREATER number)
   + IF(variable EQUAL number)
   + IF(string EQUAL number)

   + IF(var/str STRLESS/STRGREATER/STREQUAL string)

   + IF(DEFINED variable)

   #+BEGIN_EXAMPLE
     IF(WIN32)
         MESSAGE(STATUS "This is windows")
     ELSE(WIN32)     # 容易造成歧义
         MESSAGE(STATUS "This is not windows")
     END(IF)
   #+END_EXAMPLE

   使用开关: *CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS*
   #+BEGIN_EXAMPLE
     SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)

     IF(WIN32)
     ELSE()
     ENDIF()
   #+END_EXAMPLE

2. WHILE
   #+BEGIN_EXAMPLE
     WHILE(condition)
         COMMAND1(ARGS ...)
         COMMAND2(ARGS ...)
         ...
     ENDWHILE(condition)
   #+END_EXAMPLE

3. FOREACH
   1) 列表
      #+BEGIN_EXAMPLE
        FOREACH(loop_var arg1 arg2 ...)
            COMMAND1(ARGS ...)
            COMMAND2(ARGS ...)
            ....
        ENDFOREACH(loop_var)
      #+END_EXAMPLE
      eg.
      #+BEGIN_EXAMPLE
        AUX_SOURCE_DIRECTORY(. SRC_LIST)
        FOREACH(F ${SRC_LIST})
            MESSAGE(${F})
        ENDFOREACH(F)
      #+END_EXAMPLE

   2) 范围
      #+BEGIN_EXAMPLE
        FOREACH(loop_var RANGE total)
        ENDFOREACH(loop_var)
      #+END_EXAMPLE
      从0到total以1步进

   3) 范围和步进
      #+BEGIN_EXAMPLE
        FOREACH(loop_var RANGE start stop [step])
        ENDFOREACH(loop_var)
      #+END_EXAMPLE

   4) 该指令需要注意的是, 直到遇到了ENDFOREACH指令, 整个语句块才会被真
      正的执行.

*** 模块的使用和自定义模块

**** 使用CMake提供的FindCURL模块
对于系统预定义的Find<name>.cmake模块, 使用方法如下:
#+BEGIN_EXAMPLE
  FIND_PACKAGE(CURL)
  IF(CURL_FOUND)
      INCLUDE_DIRECTORIES(${CURL_INCLUDE_DIR})
      TARGET_LINK_LIBRARIES(curltest ${CURL_LIBRARY})
      MESSAGE(STATUS "the path to curl lib is"${CURL_INCLUDE_DIR})
  ELSE(CURL_FOUND)
      MESSAGE(FATAL_ERROR "CURL library not found")
  ENDIF(CURL_FOUND)
#+END_EXAMPLE

每一个模块都会定义以下几个变量:
+ <name>_FOUND: 判断模块是否被找到
+ <name>_INCLUDE_DIR / <name>_INCLUDES
+ <name>_LIBRARY / <name>_LIBRARIES

**** 自定义cmake模块
工程目录下cmake文件夹 t6/cmake/FindHELLO.cmake
#+BEGIN_EXAMPLE
  FIND_PATH(HELLO_INCLUDE_PATH hello.h /usr/include/hello /usr/local/include/hello)
  FIND_LIBRARY(HELLO_LIBRARY NAMES hello PATH /usr/lib /usr/local/lib)

  IF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY)
      SET(HELLO_FOUND TRUE)
  ENDIF(HELLO_INCLUDE_DIR AND hello_LIBRARY)

  IF(HELLO_FOUND)
      IF(NOT HELLO_FIND_QUIETLY)
          MESSAGE(STATUS "Found Hello: ${HELLO_LIBRARY})
      ENDIF(NOT HELLO_FIND_QUIETLY)
  ELSE(HELLO_FOUND)
      IF(HELLO_FIND_REQUIRED)
          MESSAGE(fatal_ERROR "Cound not find hello library)
      ENDIF(HELLO_FIND_REQUIRED)
  ENDIF(HELLO_FOUND)
#+END_EXAMPLE

工程主CMakeLists.txt
#+BEGIN_EXAMPLE
  SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
#+END_EXAMPLE
** index                                                             :index:

* Programming
** Related
*** 编程思考

- [[https://app.yinxiang.com/shard/s52/nl/11551545/02044f51-cf77-477f-81a7-29a8b3709614/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D151bf877d35%3AS%3Deb395398c5b3074abfd91773aebe29cc][EN::十年学会程序设计]]

*** foo bar是什么意思
+ http://www.cnblogs.com/awpatp/archive/2011/02/27/1966380.html
+ http://en.wikipedia.org/wiki/Foobar


术语foobar, foo, bar, baz 和qux经常在计算机编程或计算机相关的文档中被
用作占位符的名字。当变量，函数，或命令本身不太重要的时候，foobar, foo,
bar, baz 和qux就被用来充当这些实体的名字，这样做的目的仅仅是阐述一个概
念，说明一个想法。这些术语本身相对于使用的场景来说没有任何意义。Foobar
经常被单独使用；而当需要多个实体举例的时候，foo，bar，和baz则经常被按
顺序使用。
*** LAMP

LAMP是指一组通常一起使用来运行动态网站或者服务器的自由软件名称首字母缩写：
+ Linux，操作系统
+ Apache，网页服务器
+ MariaDB或MySQL，数据库管理系统（或者数据库服务器）
+ PHP、Perl或Python，脚本语言

*** 编程风格
1. 重视函数的重用性

2. 必须注释函数的功能
   1) 函数注释描述的是想法，而非具体实现，因而更有价值。
   2) 在实际编程中，十分简单的函数是很少见的。
   3) 单个变量并不都需要注释，因为有时变量本身就带有自注释性。
*** R语言                                                               :r:
r is a *language* and *environment* for *statistical computing* and
*graphics*.

+ [[https://www.r-project.org/][r homepage]]
+ [[https://www.quora.com/how-can-i-become-a-data-scientist?redirected_qid=59455][quora: how can i become a data scientist? ]]
+ [[http://www.zipfianacademy.com/blog/post/46864003608/a-practical-intro-to-data-science][a practical intro to data science]]
+ [[http://cos.name/][统计之都]]
+ [[http://www.itongji.cn/article/053121432013.html][r资料大全]]
+ [[http://www.biosino.org/r/r-doc/][r文档]]
+ [[http://www.r-bloggers.com/lang/chinese/1224][r精选十二宫]]
+ [[http://www.zhihu.com/question/20388507][r和python的对比]]


有关概率统计、数据分析挖掘、机器学习等等，你不是要成为全才么？！

对于金融量化分析而言，matlab r python这几个里面，感觉r最不好用，python
装个numpy scipy pandas 基本可以替代matlab+r，而matlab在矩阵运算上，科
学计算库上，语法简洁性上r又没法比。。在专门统计领域，基本行业内都是用
sas在跑。

r主要在学术界流行，python(numpy scipy)在工程方便比较实用。

python是个综合语言（这里特指指cpython解释器），numpy scipy是数值计算的
扩展包，pandas是主要用来做数据处理（numpy依赖），sympy做符号计算（类似
mathematica？）

*** 回车与换行

**** 换行(Line Feed)
换行好理解，就是跳到下一行嘛

**** 回车(carriage return)

在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩
意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要
用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，
那么这个字符将丢失。

于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字
符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换
行”，告诉打字机把纸向下移一行。

这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。

后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，
一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现
了分歧。

**** 不同系统的回车与换行

#+BEGIN_EXAMPLE

#+END_EXAMPLE

**** 小结
1. 回车的来历
2. 不同系统中的使用的符号
3. 导致的问题

*** 正斜杠与反斜杠
+ 正斜杠，又称左斜杠，符号是 "/"
+ 反斜杠，也称右斜杠，符号是 "\"
+ 巧记： 斜的第一划为正，第二划为反
*** clang
+ http://clang.llvm.org/

**** what?
+ http://zh.wikipedia.org/wiki/Clang
+ http://zh.wikipedia.org/wiki/LLVM
+
Clang（发音为/ˈklæŋ/类似英文单字clang） 是一个C、C++、Objective-C和
Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后
端。它的目标是提供一个GNU编译器套装（GCC）的替代品。源代码授权是使用类
BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。

LLVM，一个自由软件项目，是一种编译器的基础建设，以C++写成。它是为了任
意一种编程语言写成的程序，利用虚拟技术，创造出编译时期，链结时期，运行
时期以及“闲置时期”的最优化。它最早是以C/C++为实现对象，目前它支持了
包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java bytecode、
Objective-C、Swift、Python、Ruby、Rust、Scala以及C♯.

**** Install
1. apt-get
2. Source code: http://clang.llvm.org/get_started.html

****

** Doxygen                                                         :doxygen:

*** reference

-  [[http://www.stack.nl/~dimitri/doxygen/index.html][Homepage]]

*** install                                                       :install:

apt-get

*** guide                                                           :guide:
**** what

Doxygen is the de facto /standard tool/ for generating /documentation/
from annotated C++ sources, but it also supports other popular
programming languages such as C, Objective-C, C#, PHP, Java, Python,
IDL (Corba, Microsoft, and UNO/OpenOffice flavors), Fortran, VHDL,
Tcl, and to some extent D.

**** 特性 & why

+ 文档生成器
+ 多语言
+ 跨平台
+ 输出多种格式
+ 支持多种注释风格
+ 自由软件

**** 工件流程

[[/home/ben/Wally/Journal/Figure/scrot/14780asM.png]]

**** usage

1. 生成文档
   1) 生成配置文件： /doxygen -g <cfg-file>/ 默认名 /Doxyfile/
   2) 修改配置文件
   3) 生成文档: /doxygen [cfg-file]/

2. 生成不含注释的文件: /doxygen -s/

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{text}
   $ doxygen -h
  Doxygen version 1.8.9.1
  Copyright Dimitri van Heesch 1997-2015

  You can use doxygen in a number of ways:

  1) Use doxygen to generate a template configuration file:
      doxygen [-s] -g [configName]

      If - is used for configName doxygen will write to standard output.

  2) Use doxygen to update an old configuration file:
      doxygen [-s] -u [configName]

  3) Use doxygen to generate documentation using an existing configuration file:
      doxygen [configName]

      If - is used for configName doxygen will read from standard input.

  4) Use doxygen to generate a template file controlling the layout of the
     generated documentation:
      doxygen -l [layoutFileName.xml]

  5) Use doxygen to generate a template style sheet file for RTF, HTML or Latex.
      RTF:        doxygen -w rtf styleSheetFile
      HTML:       doxygen -w html headerFile footerFile styleSheetFile [configFile]
      LaTeX:      doxygen -w latex headerFile footerFile styleSheetFile [configFile]

  6) Use doxygen to generate a rtf extensions file
      RTF:   doxygen -e rtf extensionsFile

  If -s is specified the comments of the configuration items in the config file will be omitted.
  If configName is omitted `Doxyfile' will be used as a default.

  -v print version string
  \end{minted}
#+end_latex

**** 配置选项

|------------------------------+--------------------------------------------------|
| PROJECT = my_proj            | 项目名称                                         |
| DOXYGEN_ENCODING = UTF-8     | 文件编码格式, UTF/GB2312                         |
| PROJECT_NUMBER = 1.0         | 文档版本号                                       |
| OUTPUT_DIRECTORY = "doc/"    | 输出目录                                         |
| OUTPUT_LANGUAGE = Chinese    | 程序文档广语言环境                               |
| OPTIMIZED_OUTPUT_FOR_C = YES | C文档, 否则C++                                   |
| TYPEDEF_HIDES_STRUCT = YES   | typedef定义的结构体只按typedef定义的类型名文档化 |
| HIDE_SCOPE_NAMES = YES       | C++中为NO,                                       |
| QUIET = YES                  | 只有警告或错误时才输出提示信息                   |
| INPUT_ENCODING               | 输入文件编码                                     |
| FILE_PATTERNS = *.h          | 只对头文件文档化                                 |
| RECURSIVE = YES              | 递归子目录                                       |
| EXAMPLE_PATH = example/      | 示例程序目录                                     |
| REFERENCED_BY_RELATION = YES | 显示函数调用关系                                 |
| REFERENCE_RELATION = YES     |                                                  |
| REFERENCE_LINK_SOURCE = YES  |                                                  |
| GENERATE_LATEX = NO          | 不生成程序latex文档                              |
| HAVE_DOT = YES               | 允许图例形式显示函数调用关系                     |
| CALL_GRAPH = YES             |                                                  |
| CALLER_GRAPH = YES           |                                                  |
|------------------------------+--------------------------------------------------|

**** 测试

使用默认配置

生成了 html(包含 索引页 /index/) 和 latex(包含 /makefile/ ) 两个子目录

/RECURSIVE/  配置为 YES 递归包含子目录
*** Doxygen注释

1. 文件注释

   文件用途,作者,创建修改日期等. eg.

   [[/home/ben/Wally/Journal/Figure/scrot/14780n2S.png]]

   注释关键字
   + @file
   + @brief
   + @author
   + @data
   + @version
   + ...
   + 关键字后必须有空格
   + 简要描述与详细描述之间隔一个空行

2. 函数注释

   [[/home/ben/Wally/Journal/Figure/scrot/147800AZ.png]]

   [[/home/ben/Wally/Journal/Figure/scrot/14780BLf.png]]

   [[/home/ben/Wally/Journal/Figure/scrot/14780OVl.png]]

   注: @return等关键字与示例之间至少隔一个空行.

3. 结构体注释

   结构体,枚举,联合等注释

   [[/home/ben/Wally/Joural/Figures/scrot/14780bfr.png]]

   [[/home/ben/Wally/Journal/Figure/scrot/14780opx.png]]

*** [[http://blog.csdn.net/czyt1988/article/details/8901191][Doxygen注释风格]]

下载国外的源代码，往往能看到附带的说明文档，文档都有详细的说明，大部分
文档都可以通过doxygen这个跨平台软件生成，doxygen并不能随便读取你的C++
的注释,必须按照一定的规则才能生成，所以在编写代码时，一定要按照标准写
注释，否则会为以后带来许多麻烦。

_c++不推荐c语言式的/* */风格注释_ ，这里，除了文件头使用这种注释外其余
到使用C++风格的注释。

**** 头文件

#+BEGIN_EXAMPLE
  /*!
  ,* \file Ctext.h
  ,* \brief 概述
  ,*
  ,*详细概述
  ,*
  ,* \author 作者名字
  ,* \version 版本号(maj.min，主版本.分版本格式)
  ,* \date 日期
  */
#+END_EXAMPLE

**** 命名空间

#+BEGIN_EXAMPLE
  /// \brief 命名空间的简单概述
  ///
  ///命名空间的详细概述
  namespace text
  {
   ……
  }
#+END_EXAMPLE

**** 类说明

#+BEGIN_EXAMPLE
  /// \brief Ctext的doxygen测试
  ///
  /// 作doxygen测试用
  class Ctext
  {
  }
#+END_EXAMPLE

注：
+ 如果想生成私有成员（doxygen默认不生成私有成员），可以如下设置选择
  Expert标签的Build项，勾选EXTRACT_PRIVATE即可

**** 函数说明

1. 方法1

   #+BEGIN_EXAMPLE
     /// \brief 函数简要说明-测试函数
     /// \param n1 参数1
     /// \param c2 参数2
     /// \return 返回说明
     bool text(int n1,Ctext c2);
   #+END_EXAMPLE

2. 方法2

   #+BEGIN_EXAMPLE
     /// \brief 函数简要说明-测试函数
     ///
     /// 函数详细说明，这里写函数的详细说明信息，说明可以换行
     /// ，如这里所示，同时需要注意的是详细说明和简要说明之间必须空一行
     /// ，详细说明之前不需要任何标识符
     /// \param n1 参数1说明
     /// \param c2 参数2说明
     /// \return 返回说明
     /// \see text
     bool text2(int n1,Ctext c2);
   #+END_EXAMPLE

3. 原则

   + 函数详细注释位于头文件，cpp文件只对函数做简明注释
   + cpp文件不做///的注释，否则会和头文件重叠
   +

**** 变量和枚举

#+BEGIN_EXAMPLE
  int m_a;     ///< 成员变量1m_a说明
  double m_b; ///< 成员变量2m_b说明


  /// \brief 成员变量m_c简要说明
  ///
  /// 成员变量m_c的详细说明，这里可以对变量进行
  ///详细的说明和描述，具体方法和函数的标注是一样的
  float m_c;


  /// \brief xxx枚举变量的简要说明
  ///
  /// xxx枚举变量的详细说明--枚举变量的详细说明和函数的详细说明
  ///的写法是一致的。每个枚举变量下可以进行单独说明
  enum{
          em_1,///< 枚举值1的说明
          em_2,///< 枚举值2的说明
          em_3 ///< 枚举值3的说明
  };
#+END_EXAMPLE

+ 变量注释用///< 对变量进行说明，对于详细信息可以加
  \textbackslash{}brief

+ 如果变量需要详细说明的可已按照m_c的写法写，注意，m_b和m_c之间一定需
  要空行

**** 中文问题

中文有时候是乱码。

对于vs2010的文档，默认是gb2312，可以设置Expert标签的Project项目的
DOXYFILE_ENCODING 为 GB18030 INPUT_ENCODING 为 GB18030

另外Project项目的生成语言（OUTPUT_LANGUAGE）选择Chinese

对于其他的代码文件如果中文乱码，可以用文本编辑器转换代码文本编码为
UTF-8带BOM的（注意这有可能影响代码，所以转换编码时要备份），再进行导出。
*** note                                                             :note:

1. PDF vs HTML

   更喜欢 PDF，可以标注、搜索方便等

2. API vs Source Code

   更喜欢后者！

** 正则表达式                                                       :regexp:
*** [[http://www.jb51.net/tools/zhengze.html][正则表达式入门]]

**** regexp

在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的
需要。正则表达式就是用于描述这些规则的工具。换句话说， *正则表达式就是
记录文本规则的代码*

注:  _通配符不是正则表达式_

/正则表达式引擎/ 通常会提供一个“测试指定的字符串是否匹配一个正则表达式”
的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。

这里的 *匹配是指是字符串里有没有符合表达式规则的部分* 。如果不使用^和$
的话，对于\textbackslash{}d{5,12}而言，使用这样的方法就只能保证字符串
里包含5到12连续位数字，而不是整个字符串就是5到12位数字。

**** 元字符 Metacharacter                           :元字符:metacharacter:

- \b  开头或结尾, 也就是单词的分界

  通常英文的单词是由空格，标点符号或者换行来分隔的，但是 \b 并不匹配这词
  分隔字符中的任何一个，它 *只匹配一个位置*

- .  匹配除换行符外的所有字符

- *  表示前面的内容可以重复任意次,包括零次

- +  表示前面的内容可以重复一次可更多次

- ?  表示前面内容重复一次可零次

- \n  匹配换行符

- \d  匹配一位数字

- {n}  表示前面的内容必须连续匹配n次

- {m,n}  表示前面的内容必须重复不少于m次不多于n次

- \s  匹配任意的空白符,包括空格,制表符,换行符, 中文全角空格

- \w  匹配字母,数字,下划线或汉字

- ^  匹配字符串的开始

  正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的
  意义就变成了匹配行的开始处和结束处。

- $  匹配字符串的结束

- ()  分组

  |----------+--------------+------------------------------------------------|
  | 分组     | (exp)        | 匹配exp,并捕获文本到自动命名的组里             |
  |----------+--------------+------------------------------------------------|
  | 捕获     | (?<name>exp) | 匹配exp,并捕获文本到名称为name的组里，         |
  |          |              | 可以写成(?'name'exp)                           |
  |          | (?:exp)      | 匹配exp,不捕获匹配的文本，也不给此分组分配组号 |
  |----------+--------------+------------------------------------------------|
  | 零宽断言 | (?=exp)      | 匹配exp前面的位置                              |
  |          | (?<=exp)     | 匹配exp后面的位置                              |
  |          | (?!exp)      | 匹配后面跟的不是exp的位置                      |
  |          | (?<!exp)     | 匹配前面不是exp的位置                          |
  |----------+--------------+------------------------------------------------|
  | 注释     | (?#comment)  | 用于提供注释让人阅读                           |
  |----------+--------------+------------------------------------------------|

+ []

+ \W  匹配任意不是字母，数字，下划线，汉字的字符

+ \S  匹配任意不是空白符的字符

+ \D  匹配任意非数字的字符

+ \B  匹配不是单词开头或结束的位置

+ [^x]  匹配除了x以外的任意字符

+ [^aeiou]  匹配除了aeiou这几个字母以外的任意字符*

**** 字符转义

使用 \ 对元字符进行转义, 如 \., \*, \\.

**** 重复

|-------+------------------|
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ?     | 重复零次或一次   |
| {n}   | 重复n次          |
| {n,}  | 重复n次或更多次  |
| {n,m} | 重复n到m次       |
|-------+------------------|

**** 字符合集  方括号括起

+ [aeiou]  匹配元音字母
+ [0-9]    等价于 \d.
+ [a-z0-9Z-Z] 等价于 \w.

**** 分枝条件 |

"|" 把不同的规则分隔开.

#+BEGIN_EXAMPLE
\d{5}-\d{4}|\d{5}
#+END_EXAMPLE

这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9
位数字。

*注:使用分枝条件时，要注意各个条件的顺序。原因是匹配分枝条件时，将会从左到右
地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。*

如果你把它改成 的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。

#+BEGIN_EXAMPLE
\d{5}|\d{5}-\d{4}
#+END_EXAMPLE

**** 分组

我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要
重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可
以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有
介绍)。

eg.

#+BEGIN_EXAMPLE
(\d{1,3}\.){3}\d{1,3}
#+END_EXAMPLE

是一个简单的IP地址匹配表达式。

**** 反义

+ \W  匹配任意不是字母，数字，下划线，汉字的字符
+ \S  匹配任意不是空白符的字符
+ \D  匹配任意非数字的字符
+ \B  匹配不是单词开头或结束的位置
+ [^x]  匹配除了x以外的任意字符
+ [^aeiou]  匹配除了aeiou这几个字母以外的任意字符

eg.

#+BEGIN_EXAMPLE
<a[^>]+>
#+END_EXAMPLE

匹配用尖括号括起来的以a开头的字符串。

**** 向后引用

后向引用用于重复搜索前面某个分组匹配的文本。

*使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获
的内容)可以在表达式或其它程序中作进一步的处理。*

默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括
号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

eg

#+BEGIN_EXAMPLE
\b(\w+)\b\s+\1 \b
#+END_EXAMPLE

可以用来匹配重复的单词，像go go, 或者kitty kitty。

- 分组0对应整个正则表达式

- 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第
  二遍  只给命名组分配---因此所有命名组的组号都大于未命名的组号

- 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．

- 可以自己指定子表达式的组名,使用这样的语法：
  *(?<NAME>\w+)* 或 *(?'NAME'\w+)*

- 要反向引用这个分组捕获的内容，使用 *\k<NAME>*

**** 注释

小括号的另一种用途是用来包含注释

#+BEGIN_EXAMPLE
(?#comment)
#+END_EXAMPLE

**** 选项

+ 忽略模式里的空白符, 这样可以在编写表达式时能任意添加空格
+ 忽略大小写
+ 多行模式/单行模式
+ 示式捕获

**** 贪婪模式

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能
得到匹配的前提下） _匹配尽可能多的字符_ 。这被称为 /贪婪匹配/ 。

有时，我们更需要 /懒惰匹配/ ，也就是匹配尽可能少的字符。

/只要在重复限定符后面加上一个问号 ?/

- *?	重复任意次，但尽可能少重复
- +?	重复1次或更多次，但尽可能少重复
- ??	重复0次或1次，但尽可能少重复
- {n,m}?	重复n到m次，但尽可能少重复
- {n,}?	重复n次以上，但尽可能少重复

#+BEGIN_EXAMPLE
a.*?b
#+END_EXAMPLE

匹配最短的，以a开始，以b结束的字符串。

** PHP                                                                 :php:
*** PHP安装配置
**** Reference

+ [[http://php.net/][Homepage]]
+ [[http://php.net/manual/en/index.php][Manual]]
+ [[https://wiki.php.net/][Wiki]]

**** intro

PHP（全称：PHP：Hypertext Preprocessor，即“PHP：超文本预处理器”）是
一种开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入HTML中使用。

+ 内嵌，动态网页
+ 脚本语言
+ 服务器端技术
+ 开源
+ 跨平台

**** 安装

+ 源码安装： ./configure make make install

*** php5

+ 配置文件: /usr/local/apache/conf/httpd.conf
+ LoadModule php5_module module/libphp5.so  # 不一定一模一样
+ AddType application/x-httpd-php .php .phtml .php3
+ AddType application/x-httpd-php-source .phps

** awk                                                                 :awk:
*** awk入门
+ http://coolshell.cn/articles/9070.html
+ http://www.gnu.org/software/gawk/manual/gawk.html
+ http://zh.wikipedia.org/wiki/Awk
+ http://net.pku.edu.cn/~yhf/tutorial/awk_manual.html

**** what
AWK是一种处理文本文件的语言。它将文件作为记录序列处理。在一般情况下，
文件内容的每行都是一个记录。每行内容都会被分割成一系列的域，因此，我们
可以认为一行的第一个词为第一个域，第二个词为第二个，以此类推。AWK程序
是由一些处理特定模式的语句块构成的。AWK一次可以读取一个输入行。对每个
输入行，AWK解释器会判断它是否符合程序中出现的各个模式，并执行符合的模
式所对应的动作。

gawk是AWK的GNU版本。

**** why
1. 基于文本的样式扫描和处理是我们经常做的工作，awk所做的工作有些象数据
   库，但与数据库不同的是，它处理的是文本文件

2. awk是一个简单的工具，当然这是相对于 其强大的功能来说的

3. awk是一个容易 获得的工具

4. 如果你 要处理与文本样式扫描相关的工作，awk应该是你的第一选择。在这
   里有一个可遵循的一般原则：如果你用普通的shell工具或shell script有困
   难的话，试试awk,如果awk仍不能解决问题，则便用C语言，如果C语言仍然失
   败，则移至C++。

**** awk调用方式
1. 命令行
2. script
   1) akw -f [file.awk]
   2) 命令解释器： #!/bin/awk -f 并赋予可执行权限

**** awk语法
1. 格式： *awk [-F re] [parameter] ['prog'] [-f progfile] [in_file ...]*
2. 参数说明
   + -F re: 允许awj更改字段分隔符
   + parameter: 为不同变量赋值
   + 'prog': awk程序语句段，必须使用单引号括起，以防shell解释
   + -f progfile: 调用并执行progfile程序文件
   + in_file: 输入文件，允许多个，缺省时为标准输入，支持输入输出重定向

**** 记录，字段，内置变量
awk处理的工作与数据库的处理方式有相同之处，其相同处之一就是awk支持对记
录和字段的处理，其中对字段的处理是grep和sed不能实现的，这也是awk优于二
者的原因之一。

在awk中，缺省的情况下总是将文本文件中的一行视为一个 *记录* ，而将一行
中的某一部分作为记录中的一个 *字段* 。

为了操 作这些不同的字段，awk借用shell的方法， *用$1,$2,$3...这样的方式
来顺序地表示行（记录）中的不同字段* 。
特殊地， *awk用$0表示整个 行（记录）* 。

不同的字段之间是用称作 *分隔符* 的字符分隔开的, 系统默认的分隔符是空格。
awk允许在命令行中用 *-F re* 的形式来改变这个分隔符。

事实上，awk用一个 *内置的变量*  *FS* 来记忆这个分隔符。awk中有好几个这
样的内置变量，例如，
+ 记录分隔符变量 *RS*
+ 当前工作的记录数 *NR* 等


e.g. 显示文本文件myfile中第七行到第十五行中以字符%分隔的第一字段，第三
字段和第七字段
#+BEGIN_EXAMPLE
awk -F % 'NR==7，NR==15 {printf $1 $3 $7}'
#+END_EXAMPLE

**** awk内置函数
awk吸收了某些优秀的程序设计语言（例如C）语言的许多优点。这些优点之一就
是内置函数的使用，awk定义并 支持了一系列的内置函数，由于这些函数的使用，
使得awk提供的功能更为完善和强大。

**** 在命令行使用awk
1. 正则匹配
   #+BEGIN_SRC sh :exports code
   awk '/sun/{print}' mydoc # 显示含有"sun"的所有行
   #+END_SRC
   + 显示整个记录是awk的缺省动作，所以可以省略action项
     #+BEGIN_SRC sh :export code
     awk '/sun/' mydoc
     #+END_SRC

   #+BEGIN_SRC sh :exports code
   awk '/[Ss]un/, /[Mm]oon/ {print}' myfile
   #+END_SRC

** lua                                                                 :lua:
*** lua简介
http://zh.wikipedia.org/wiki/Lua

1. what?
   Lua（英语发音：/ˈluːə/）程序设计语言是一个简洁、轻量、可扩展的脚本
   语言，是葡萄牙语中“Lua”（月亮）的意思。

2. Features
   + 轻量
     - Lua体积小、启动速度快
     - 编译后仅仅一百余K
     - 和许多“大而全”的语言不一样，网路通讯、图形界面等都没有默认提
       供。但是Lua可以很容易地被扩展：由宿主语言（通常是C或C++）提供这
       些功能，Lua可以使用它们，就像是本来就内置的功能一样。事实上，现
       在已经有很多成熟的扩展模块可供选用。
   + 使用标准C语言编写
   + 开源： 以源代码形式开放
   + 可嵌入： ，可以很方便的嵌入别的程序里。
   + 多重编程范式：
     - 元特性：它只提供了很小的一个特性集合来满足不同编程范式的需要
     - 可“模拟”继承和类
     - 支持函数式编程
   + 原生支持的数据类型非常之少
     - 数字（缺省是双精度浮点数，可配置）
     - 布尔量
     - 字符串
     - 表
     - 子程序
     - 协程（coroutine）
     - 用户自定义数据
   + 处理表和字符串的效率非常之高，加上元表的支持，开发者可以高效的模
     拟出需要的复杂数据类型（比如集合、数组等）。
   + 个动态弱类型语言
   + 支持增量式垃圾收集策略
   + 有内建的，与操作系统无关的协作式多线程（coroutine）支持
   + Lua可以用于嵌入式硬件
** XML                                                                 :xml:
*** xmlns
xmlns是XML Namespaces的缩写，中文名称是XML（标准通用标记语言的子集）命
名空间。

使用的规则为，首先定义命名空间xmlns:namespace-prefix="namespaceURI"。
Android中xml中的使用是：xmlns:前缀=http://schemas.android.com/apk/res/
应用程序包路径；然后使用的时候按格式：namespace-prefix（前缀）：属性


如果使用xmlns，则xmlns的定义必须放在最外层开始的的标记中

当命名空间被定义之后，所有带有相同前缀的子元素都会与同一个命名空间相关
联。避免XML解析器对xml解析时的发送名字冲突，这就是使用xmlns的必要性。
当自定义的View有自己的属性的时候，就用到xmlns来定义一个命名空间。
*** xmlns 命名空间机制                                              :xmlns:
xmlns是 *xml namespaces* 的缩写，中文名称是xml（标准通用标记语言的子集）
命名空间。

使用的规则为，首先定义命名空间xmlns:namespace-prefix="namespaceuri"。
android中xml中的使用是：xmlns:前缀=http://schemas.android.com/apk/res/
应用程序包路径；然后使用的时候按格式：namespace-prefix（前缀）：属性

如果使用xmlns，则xmlns的定义必须放在最外层开始的的标记中

*当命名空间被定义之后，所有带有相同前缀的子元素都会与同一个命名空间相
关联, 避免xml解析器对xml解析时的发送名字冲突*

这就是使用xmlns的必要性。
当自定义的view有自己的属性的时候，就用到xmlns来定义一个命名空间。

** HTML                                                               :html:
** YAML                                                               :yaml:
** Markdown                                                       :markdown:
*** DONE markdown 入门                                           :markdown:
- State "DONE"       from "TODO"       [2015-12-17 四 21:00] \\
  了解基本语法
- State "TODO"       from ""           [2015-12-17 四 19:48] \\
  1. 使用 Markdown 语言写 README
  2. 使用 Markdown 写博客，或者将 Org 转换成 markdown

**** reference

+ [[https://github.com/LearnShare/Learning-Markdown][GitHub: Learning Markdown]]

**** Intro

1. about Markdown
   1) 轻量级标记语言
   2) John Gruber
   3) 使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者
      HTML）文档

2. why markdown

**** hello markdown



#+BEGIN_SRC markdown
  Hello
  ===

  I like [Google](https://www.google.com/)
#+END_SRC

后缀名通常为 .md 或 .markdown

**** Syntax

http://daringfireball.net/projects/markdown/syntax

***** 段落与换行

#+BEGIN_SRC markdown
  段落与换行
  ====

  1\. 段落的前后必须是空行：

  空行指的是行内什么都没有，或者只有空白符（空格或制表符）

  相邻两行文本，如果中间没有空行
  会显示在一行中（换行符被转换为空格）

  2\. 如果需要在段落内加入换行（`<br>`）：

  可以在前一行的末尾加入至少两个空格
  然后换行写其它的文字

  3\. Markdown 中的多数区块都需要在两个空行之间。
#+END_SRC

***** 标题: ==== ---- ####

#+BEGIN_SRC markdown
  标题
  ====

  1. Setext 形式
  ----

  ```markdown
  H1
  ====

  H2
  ----
  ```

  H1
  ====

  H2
  ----

  >`=` 和 `-` 的数量是没有限制的。通常的做法是使其和标题文本的长度相同，这样看起来比较舒服。或者可以像我一样，用四个 `-` 或 `=`。
  >Setext 形式只支持 `h1` 和 `h2` 两种标题。

  2. atx 形式
  ----

  ① 可以用对称的 `#` 包括文本：

  ```markdown
  ####H4####

  #####H5#####
  ```

  ####H4

  #####H5

  ② 也可以只在左边使用 `#`：

  ```markdown
  ####H4

  #####H5
  ```

  ####H4

  #####H5

  ③ 成对的 `#` 左侧和只在左边使用的 `#` 左侧都不可以有任何空白，但其内侧可以使用空白。

  ```markdown
   ###左侧使用了空格###

  #### 内侧使用了空格
  ```

   ###左侧使用了空格###

  #### 内侧使用了空格

  >在这一点上，可能各种 Markdown 的实现会有不同的结果，不过仍然需要我们遵守语法规则。
#+END_SRC

***** 引用: >

#+BEGIN_SRC markdown
  引用
  ====

  1. 引用内容
  ----

  在段落或其他内容前使用 `>` 符号，就可以将这段内容标记为 '引用' 的内容（`<blockquote>`）：

  ```markdown
  >引用内容
  ```

  >引用内容

  2. 多行引用
  ----

  ```markdown
  >多行引用
  >可以在每行前加 `>`
  ```

  >多行引用
  >可以在每行前加 `>`

  ```markdown
  >如果仅在第一行使用 `>`，
  后面相邻的行即使省略 `>`，也会变成引用内容
  ```

  >如果仅在第一行使用 `>`，
  后面相邻的行即使省略 `>`，也会变成引用内容

  ```markdown
  >如果引用内容需要换行，
  >可以在行尾添加两个空格
  >
  >或者在引用内容中加一个空行
  ```

  >如果引用内容需要换行，
  >可以在行尾添加两个空格
  >
  >或者在引用内容中加一个空行

  3. 嵌套引用
  ----

  ```markdown
  >也可以在引用中
  >>使用嵌套的引用
  ```

  >也可以在引用中
  >>使用嵌套的引用

  4. 其他 Markdown
  ----

  ```markdown
  >在引用中可以使用使用其他任何 *Markdown* 语法
  ```

  >在引用中可以使用使用其他任何 *Markdown* 语法
#+END_SRC
***** 列表: 有点类似 org-mode

#+BEGIN_SRC markdown
  列表
  ====

  无序列表
  ----

  ```markdown
  ,* 可以使用 `*` 作为标记
  + 也可以使用 `+`
  - 或者 `-`
  ```

  ,* 可以使用 `*` 作为标记
  + 也可以使用 `+`
  - 或者 `-`

  有序列表
  ----

  ```markdown
  1. 有序列表以数字和 `.` 开始；
  3. 数字的序列并不会影响生成的列表序列；
  4. 但仍然推荐按照自然顺序（1.2.3...）编写。
  ```

  1. 有序列表以数字和 `.` 开始；
  3. 数字的序列并不会影响生成的列表序列；
  4. 但仍然推荐按照自然顺序（1.2.3...）编写。

  嵌套的列表
  ----

  ```markdown
  1. 第一层
    + 1-1
    + 1-2
  2. 无序列表和有序列表可以随意相互嵌套
    1. 2-1
    2. 2-2
  ```

  1. 第一层
    + 1-1
    + 1-2
  2. 无序列表和有序列表可以随意相互嵌套
    1. 2-1
    2. 2-2

  语法和用法
  ----

  1. 无序列表项的开始是：符号 空格；
  2. 有序列表项的开始是：数字 `.` 空格；
  3. 空格至少为一个，多个空格将被解析为一个；
  4. 如果仅需要在行前显示数字和 `.`：

  ```markdown
  05\. 可以使用：数字\. 来取消显示为列表
  ```

  05\. 可以使用：数字\\. 来取消显示为列表

  >`\*` 的语法专门用来显示 Markdown 语法中使用的特殊字符，参考 [字符转义](blackslash-escapes.md)
#+END_SRC

***** 代码：反引号

#+BEGIN_SRC markdown
  代码
  ====

  代码块
  ----

  可以使用缩进来插入代码块：

      <html> // Tab开头
          <title>Markdown</title>
      </html> // 四个空格开头

  代码块前后需要有至少一个空行，且每行代码前需要有至少一个 Tab 或四个空格；

  行内代码
  ----

  也可以通过 \`\`，插入行内代码（\` 是 `Tab` 键上边、数字 `1` 键左侧的那个按键）：

  例如 `<title>Markdown</title>`

  转换规则
  ----

  代码块中的文本（包括 Markdown 语法）都会显示为原始内容，而特殊字符会被转换为 HTML [字符实体](https://zh.wikipedia.org/wiki/XML%E4%B8%8EHTML%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93%E5%BC%95%E7%94%A8%E5%88%97%E8%A1%A8)。
#+END_SRC

***** 分隔线: * - _

#+BEGIN_SRC markdown
  分隔线
  ====

  1\. 可以在一行中使用三个或更多的 `*`、`-` 或 `_` 来添加分隔线（`<hr>`）：

  ```markdown
  ,***
  ------
  ___
  ```

  ,***
  ------
  ___

  2\. 多个字符之间可以有空格（空白符），但不能有其他字符：

  ```markdown
  ,* * *
  - - -
  ```

  ,* * *
  - - -
#+END_SRC

***** 超链接 []() / [][] / <>

#+BEGIN_SRC markdown
  超链接
  ====

  行内式
  ----

  格式为 `[link text](URL 'title text')`。

  ① 普通链接：

  ```markdown
  [Google](http://www.google.com/)
  ```

  [Google](http://www.google.com/)

  ② 指向本地文件的链接：

  ```markdown
  [icon.png](./images/icon.png)
  ```

  [icon.png](./images/icon.png)

  ③ 包含 'title' 的链接:

  ```markdown
  [Google](http://www.google.com/ "Google")
  ```

  [Google](http://www.google.com/ "Google")

  >title 使用 ' 或 " 都是可以的。

  参考式
  ----

  参考式链接的写法相当于行内式拆分成两部分，并通过一个 *识别符* 来连接两部分。参考式能尽量保持文章结构的简单，也方便统一管理 URL。

  ① 首先，定义链接：

  ```markdown
  [Google][link]
  ```

  [Google][link]

  第二个方括号内为链接独有的 *识别符*，可以是字母、数字、空白或标点符号。识别符是 *不区分大小写* 的；

  ② 然后定义链接内容：

  ```markdown
  [link]: http://www.google.com/ "Google"
  ```

  [link]: http://www.google.com/ "Google"

  其格式为：`[识别符]: URL 'title'`。

  >其中，URL可以使用 <\> 包括起来，title 可以使用 ""、''、() 包括（考虑到兼容性，建议使用引号），title 部分也可以换行来写；

  >链接内容的定义可以放在同一个文件的 *任意位置*；

  ③ 也可以省略 *识别符*，使用链接文本作为 *识别符*：

  ```markdown
  [Google][]
  [Google]: http://www.google.com/ "Google"
  ```

  [Google][]
  [Google]: http://www.google.com/ "Google"

  >参考式相对于行内式有一个明显的优点，就是可以在多个不同的位置引用同一个 URL。

  自动链接
  ----

  使用 `<>` 包括的 URL 或邮箱地址会被自动转换为超链接：

  ```markdown
  <http://www.google.com/>

  <123@email.com>
  ```

  <http://www.google.com/>

  <123@email.com>

  该方式适合行内较短的链接，会使用 URL 作为链接文字。邮箱地址会自动编码，以逃避抓取机器人。
#+END_SRC

***** 图像: !LINK

#+BEGIN_SRC markdown
  图像
  ====

  插入图片的语法和插入超链接的语法基本一致，只是在最前面多一个 `!`。也分为行内式和参考式两种。

  行内式
  ----

  ```markdown
  ![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 "GitHub,Social Coding")
  ```

  ![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 "GitHub,Social Coding")

  方括号中的部分是图片的替代文本，括号中的 'title' 部分和链接一样，是可选的。

  参考式
  ----

  ```markdown
  ![GitHub][github]

  [github]: https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 "GitHub,Social Coding"
  ```

  ![GitHub][github]

  [github]: https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 "GitHub,Social Coding"

  指定图片的显示大小
  ----

  Markdown 不支持指定图片的显示大小，不过可以通过直接插入`<img />`标签来指定相关属性：

  ```html
  <img src="https://avatars2.githubusercontent.com/u/3265208?v=3&s=100" alt="GitHub" title="GitHub,Social Coding" width="50" height="50" />
  ```

  <img src="https://avatars2.githubusercontent.com/u/3265208?v=3&s=100" alt="GitHub" title="GitHub,Social Coding" width="50" height="50" />
#+END_SRC

***** 强调: *emph* _emph_

#+BEGIN_SRC markdown
  强调
  ====

  1\. 使用 `* *` 或 `_ _` 包括的文本会被转换为 `<em></em>` ，通常表现为斜体：

  ```markdown
  这是用来 *演示* 的 _文本_
  ```

  这是用来 *演示* 的 _文本_

  2\. 使用 `** **` 或 `__ __` 包括的文本会被转换为 `<strong></strong>`，通常表现为加粗：

  ```markdown
  这是用来 **演示** 的 __文本__
  ```

  这是用来 **演示** 的 __文本__

  3\. 用来包括文本的 `*` 或 `_` 内侧不能有空白，否则 `*` 和 `_` 将不会被转换（不同的实现会有不同的表现）：

  ```markdown
  这是用来 * 演示* 的 _文本 _
  ```

  这是用来 * 演示* 的 _文本 _

  4\. 如果需要在文本中显示成对的 `*` 或 `_`，可以在符号前加入 `\` 即可：

  ```markdown
  这是用来 \*演示\* 的 \_文本\_
  ```

  这是用来 \*演示\* 的 \_文本\_

  5\. `*`、`**`、`_` 和 `__` 都必须 *成对使用* 。
#+END_SRC
***** 字符转义: \

#+BEGIN_SRC markdown
  字符转义
  ====

  反斜线（`\`）用于插入在 Markdown 语法中有特殊作用的字符。

  ```markdown
  这是用来 *演示* 的 _文本_

  这是用来 \*演示\* 的 \_文本\_
  ```

  这是用来 *演示* 的 _文本_

  这是用来 \*演示\* 的 \_文本\_

  这些字符包括：

  ```
  \
  `
  ,*
  _
  {}
  []
  ()
  #
  +
  -
  .
  !
  ```
#+END_SRC

**** 格式转换
Markdown 文档可以方便地转换为 HTML、Word、PDF 等格式的文档。这些转换既
可以通过你正在使用的 Markdown 编辑器完成，也可以通过一些命令行工具（如
Pandoc、Gitbook）来完成，甚至可以用你熟悉的语言编程实现。

***** HTML

#+BEGIN_SRC markdown
  转换为 HTML 文档
  ====

  MdCharm
  ----

  选择 'File', 'Export to...'，勾选 'HTML', 点击 'Browser...' 选择导出目录并输入导出的文件名，点击 'OK'，即可将当前的 Markdown 文档转换为 HTML 文档。

  如果不满意 HTML 文档的样式，可以在设置中自定义 CSS。

  Pandoc
  ----

  参考 [Installing](http://pandoc.org/installing.html) 安装 Pandoc。

  打开命令行，进入文档所在目录：

  ```
  cd /path/to/file/
  ```

  执行下面的命令，将 Markdown 转换为 HTML：

  ```
  pandoc -o hello.html hello.md
  ```

  >默认的转换，只是将 Markdown 内容转换为 HTML 标签，所以只能看到浏览器的默认样式。

  可以执行下面的命令，为导出的 HTML 添加自定义样式：

  ```
  pandoc -o hello.html -c style.css hello.md
  ```

  >`style.css` 仍然是以 `<link>` 的方式关联到 HTML 文档中的，所以在发布的时候需要将 CSS 一同发布出去。
#+END_SRC

***** PDF

#+BEGIN_SRC markdown
  转换为 PDF 文档
  ====

  MdCharm
  ----

  与导出 HTML 文档类似，选择 'File', 'Export to...'，勾选 'PDF', 点击 'Browser...' 选择导出目录并输入导出的文件名，点击 'OK'，即可将当前的 Markdown 文档转换为 PDF 文档。

  如果不满意 PDF 文档的样式，可以在设置中自定义 CSS。

  Pandoc
  ----

  使用 Pandoc 导出 PDF 文档，需要先安装某个 LaTeX 引擎（参考 [Creating a PDF](http://pandoc.org/README.html#creating-a-pdf)）。然后执行命令：

  ```
  pandoc -o hello.pdf hello.md
  ```

  当然，也可以通过 `-c style.css` 来指定样式文件。

  Chrome
  ----

  在将 Markdown [转换为 HTML 文档](html.md) 之后，可以通过 [Chrome 浏览器](https://www.google.com/chrome/) 打开它。选择 '打印'（Ctrl+P），然后更改 '目标打印机' 为 '另存为 PDF'，再进行一些设置后，即可保存为 PDF 文档。

#+END_SRC

***** Word

#+BEGIN_SRC markdown
  转换为 Word 文档
  ====

  复制粘贴
  ----

  在导出为 HTML 文档之后，可以（在浏览器中）手动复制 HTML 页面的内容，然后粘贴到 Word 文档中，保存即可。

  Pandoc
  ----

  执行下面的命令，即可将 Markdown 文档转换为 Word 文档：

  ```
  pandoc -o hello.docx hello.md
  ```
#+END_SRC

**** 小结

markdown 写 HTML

*** note

Markdown 表格与标题之间必须有一个空行， 否则表格无效

** TCL                                                                 :tcl:
*** TCL & Jim-TCL

+ http://www.tcl.tk/
+ http://jim.tcl.tk

**** what is tcl? （工具命令语言）
Tcl (Tool Command Language) is a very powerful but easy to learn
dynamic programming language, suitable for a very wide range of uses,
including web and desktop applications, networking, administration,
testing and many more. Open source and business-friendly, Tcl is a
mature yet evolving language that is truly cross platform, easily
deployed and highly extensible.

Tk is a graphical user interface toolkit that takes developing desktop
applications to a higher level than conventional approaches. Tk is the
standard GUI not only for Tcl, but for many other dynamic languages,
and can produce rich, native applications that run unchanged across
Windows, Mac OS X, Linux and more.

小结：
1. 一门语言
2. 动态脚本
3. 可扩展
4. 开源
5. 平台独立
6. tk是基于tcl的图形界面开发工具包

补充：
1. TCL念作“踢叩” "tickle"
2. Python的GUI接口

**** jim-tcl

Jim is an opensource small-footprint implementation of the Tcl
programming language. It implements a large subset of Tcl and adds new
features like references with garbage collection, closures, built-in
Object Oriented Programming system, Functional Programming commands,
first-class arrays and UTF-8 support. All this with a binary size of
about 100-200kB (depending upon selected options).

The Jim core is very stable. Jim passes over 3000 unit tests and many
Tcl programs run unmodified. Jim is highly modular with the possiblity
to configure many components as loadable modules, or omitted
entirely. A number of extensions are included with Jim which may be
built as loadable modules.

Jim cross compiles easily and is in use in many embedded
environments. It runs under many operating systems, including Linux,
FreeBSD, QNX, eCos, Windows (cygwin and mingw32).

Jim has built-in command line editing for the interactive shell,
jimsh.

小结：
+ Jim-tcl是tcl语言的实现
+ 开源
+ 在tcl之上增加了许多特性
  - 垃圾回收
  - 面向对象
  - UTF-8
  - 函数式编程
+ 小巧
+ 稳定
+ 跨平台

**** tcl vs jimtcl

Jim-Tcl has far fewer features. Jim-Tcl is several dozens of .C adn .H
files and implements the basic Tcl command set. In contrast: Tcl 8.6
is a 4.2MB .zip ifle contraining 1540 files.

Jim-Tcl面向嵌入编程。

**** 小结
1. TCL是一门编程语言，了解即可，不用深入
2. JIM-TCL是TCL语言的一个实现， *简洁，可以在应用在嵌入式开发中*

** Make                                                              :make:
*** make -jn

多线程编译

用于多cpu的系统编译，n一般是cpu个数的2倍。

** 其它语言
*** DONE flex & bison 工具                                 :flex:bison:gnu:
- State "DONE"       from "TODO"       [2015-11-23 一 21:02] \\
  了解即可，不必深入

http://blog.csdn.net/wxdao/article/details/16359365

什么是Flex和Bison？

Flex是一个词法分析器，是unix lex的gnu克隆，作用是把"词"抽象成符号，供
程序识别

Bison则是一个文法分析器（也是unix yacc的gnu克隆），语法就是在这里定义，
是语言设计的核心

这两巨头不但可以应付复杂的语法处理，也可以拿来制作简单的分析器，如配置
文件等

* SQL                                                                   :sql:
** General
*** 数据库概述                                                   :database:
**** 数据存储方式
1. 人工管理
2. 文件系统
3. 数据库系统
**** 数据库范式
即数据库应该遵循的规则，关系数据库的范式
+ 第一范式(1NF)
+ 第二范式(2NF)
+ 第三范式(3NF)
+ BCN范式(BCNF)
**** SQL语言
SQL(Structured Query Language)，结构化查询语言，数据库管理系统通过SQL
语言来管理数据库中的数据。分三部分：
+ 数据定义语言(DDL)
+ 数据操作语言(DML)
+ 数据控制语言(DCL)
**** 为什么要使用MySQL
+ 开源
+ 跨平台
+ 价格优势
+ 功能强大且使用方便
**** 常见的数据库系统
+ 甲骨文的 Oracle
+ IBM 的 DB2
+ 微软的 Access 和 SQL Server
+ 开源的 PostgreSQL
+ MySQL
+ 文件数据库 SQLite
+ 内在数据库 HQL
**** 小结
1. 数据存储方式变革
2. SQL语言3类
3. 常用数据库以及选择
*** 事务的属性
事务（Transaction）具有以下四个标准属性，通常根据首字母缩写为 ACID：

+ *原子性* （Atomicity）：确保工作单位内的所有操作都成功完成，否则，事
  务会在出现故障时终止，之前的操作也会回滚到以前的状态。
+ *一致性* （Consistency)：确保数据库在成功提交的事务上正确地改变状态。
+ *隔离性* （Isolation）：使事务操作相互独立和透明。
+ *持久性* （Durability）：确保已提交事务的结果或效果在系统发生故障的
  情况下仍然存在。

** MySQL                                                             :mysql:
*** MySQL简介
**** MySQL
from wiki:

MySQL,原本是一个开放源代码的关系数据库管理系统，原开发者为瑞典的MySQL
AB公司，该公司于2008年被昇阳微系统（Sun Microsystems）收购。2009年，甲
骨文公司（Oracle）收购昇阳微系统公司，MySQL成为Oracle旗下产品。

MySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，
因此被广泛地应用在Internet上的中小型网站中。随着MySQL的不断成熟，它也
逐渐用于更多大规模网站和应用，比如维基百科、Google和Facebook等网站。非
常流行的开源软件组合LAMP中的“M”指的就是MySQL。

但被甲骨文公司收购后，Oracle大幅调涨MySQL商业版的售价，且甲骨文公司不
再支持另一个自由软件项目OpenSolaris的发展，因此导致自由软件社区们对于
Oracle是否还会持续支持MySQL社区版（MySQL之中唯一的免费版本）有所隐忧，
因此原先一些使用MySQL的开源软件逐渐转向其它的数据库。例如维基百科已于
2013年正式宣布将从MySQL迁移到MariaDB数据库。

**** MariaDB
from wiki:

MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL
授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL
闭源的潜在风险，因此社区采用分支的方式来避开这个风险

MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代
替品。在存储引擎方面，10.0.9版起使用XtraDB（名称代号为Aria）来代替
MySQL的InnoDB。

MariaDB由MySQL的创始人麦克尔·维德纽斯主导开发，他早前曾以10亿美元的价
格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，
MySQL的所有权也落入Oracle的手中。MariaDB名称来自麦克尔·维德纽斯的女儿
玛丽亚（英语：Maria）的名字。

*** mysql安装
+ http://blog.fens.me/linux-mysql-install/
+ http://wiki.ubuntu.org.cn/MySQL%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97

**** 源码安装
+ http://blog.sina.com.cn/s/blog_6d39ac7e0101cq48.html
+ ftp://mirror.switch.ch/mirror/mysql/Downloads/MySQL-5.6/

安装成功，但是make uninstall失败

**** apt安装服务器
+ $ sudo apt-get install mysql-server  # 安装的时候会自动安装client
+ $ sudo apt-get install mysql-<VERSION>-client
+ 测试： $ mysqladmin --version

*** MySQL基础
**** 什么是MySQL

***** 数据库相关概念
+ 关系
+ 数据库系统
+ 数据表
+ 记录
+ 字段
+ 查询
+ SQL
+ 索引
+ 键

***** MySQL功能
+ 关系数据库系统
+ 客户/服务器体系
+ SQL兼容
+ 子查询
+ 视图
+ Unicode
+ 全文搜索
+ 外键约束
+ GIS
+ ODBC
+ 跨平台/平台独立： Linux, Windows, MacOS
+ 多语言：C/C++, Java, Perl, PHP, Python
+ 速度

***** MySQL不足
+ 数据表锁定
+ 不能热备份
+ 不支持自定义数据结构
+ 对XML支持不好
+ 没有OLAP(online analytical processing)功能
+ GIS支持不完善

**** mysql, mysqladmin和mysqldump
***** mysql
mysql只是用来与MySQL服务器交互的一种客户端程序， 只支持文本模式。

1. 启动
   1) 命令：$ mysql [options] [database]
   2) 选项
      + -u name 或 -usr=name
      + -p 提示输入密码
      + -P 端口
      + -protocol=name
      + -default-character-set
2. 交互式使用mysql
   + 选项--i-am-a-dummy:防止新手失误对数据库造成不可恢复的破坏
   + 命令
     |-----------------------+--------------+----------------------------|
     | \c     | clear        | 放弃正在输入的命令         |
     | \h     | help         | 显示命令清单               |
     | \q     | exit/quit    |                            |
     | \s     | status       |                            |
     | \T f   | tee file     | 把输入输出记载到指定文件中 |
     | \t     | notee        |                            |
     | \u  db | use datebase | 另行指定一个数据库         |
     | \. fn  | source file  | 读取并指定文件的SQL命令，命令必须以分号隔开 |
     |-----------------------+--------------+---------------------------------------------|
     注：
     + 简写形式只能用于行中或行尾，行首需要使用完整形式

3. 使用技巧
   + tab补全
   + 快捷键，与Emacs一致
   + 个人配置文件： ~/.my.cnf
   + 字符集: unicode
4. 处理SQL文件
   #+BEGIN_EXAMPLE
   mysql [options] database < file.sql
   #+END_EXAMPLE
   + .sql后缀不是必要的

***** mysqladmin
系统管理任务

***** mysqldump
创建备份

***** 图形用户界面
+ MySQL Adminstrator
+ MySQL Query Browser

**** MySQL初始化
+ MySQL安装后，默认的root用户密码为空
  - mysqladmin -u root password "xxxxxx"
+ 使用mysql连接到MySQL服务器
  - mysql -u root -p
+ Linux系统启动时启动MySQL，在/etc/rc.local文件添加：(没有验证)
  - /etc/init.d/mysql start
  - 将mysqld二进制文件添加到/etc/init.d/目录中

**** MySQL管理
+ 查看MySQL服务器是否启动： ps -ef | grep mysqld
+ 启动MySQL: $ /usr/bin/safe_mysqld &
+ 关闭MySQL: $ /usr/bin/mysqlmin -u root -p shutdown
+ 添加用户: 在mysql数据库的 *user表* 添加新的用户
  + INSERT INTO user ...
    \begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\linewidth]{/home/ben/Wally/Journal/Figure/scrot/2878erz.png}
    \end{figure}

    - select_priv
    - insert_priv
    - update_priv
    - delete_priv
    - create_priv
    - drop_priv
    - reload_priv
    - shutdown_priv
    - process_priv
    - file_priv
    - grant_priv
    - references_priv
    - index_priv
    - aler_priv

  + GRAND ...
    \begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\linewidth]{/home/ben/Wally/Journal/Figure/scrot/2878Q1C.png}
    \end{figure}

  + 注：MySQL语句以分号作为结束标识

+ 配置文件 */etc/mysql/my.cnf*

+ 常用命令
  - USE <database>
  - SHOW DATABASES
  - SHOW TABLES
  - SHOW COLUMNS FORM <table>
  - SHOW INDEX FROM <table>
  - SHOW TABLE STATUS LIKE <TABLE>\G

**** MySQl PHP 语法
+ PHP MySQL函数以mysql为前缀，eg.
  - mysqli_connect($connect);
  - mysqli_query($connect, "SQL statement");
  - mysql_fetch_array();
  - mysql_connect()
  - mysql_close()

**** MySQL连接
1. 二进制形式： $mysql -u root -p
2. PHP脚本：mysql_connect()
   + 语法： connection mysql_connect(server, user, passwd, new_link, client_flag)
   + server
     - 可选，规定要连接的服务器
     - 可以包括端口号, 如， hostname:port
     - 或本地套接字的路径，/path/to/socket
     - 默认为 localhost:3306
   + user，用户名，可选，默认为服务器进程所有者的用户名
   + passwd,密码，可选，默认为空
   + new_link，可选
   + client_flag， 可选

**** MySQL PHP
+ 启动MySQL服务: /etc/init.d/mysql start
+ 登录MySQL： mysql -u root -p


1. 二进制形式： $mysql -u root -p
2. PHP脚本：mysql_connect()
   + 语法： connection mysql_connect(server, user, passwd, new_link, client_flag)
   + server
     - 可选，规定要连接的服务器
     - 可以包括端口号, 如， hostname:port
     - 或本地套接字的路径，/path/to/socket
     - 默认为 localhost:3306
   + user，用户名，可选，默认为服务器进程所有者的用户名
   + passwd,密码，可选，默认为空
   + new_link，可选
   + client_flag， 可选

#+BEGIN_SRC html :tangle /home/ben/.apache/mysql_conn.php
  <html>
    <head>
      <title>Connecting MySQL Server</title>
    </head>
    <body>
      <?php
        $dbhost = "localhost:3306";
        $dbuser = "root";
        $dbpass = "t910112";
        $conn = mysql_connect($dbhost, $dbuser, $dbpass);
        if(! $conn)
        die('Could not connect:' . mysql_error());
        echo "Connected successfully";
        mysql_close($conn);
      ?>
    </body>
  </html>
#+END_SRC

**** MySQL创建数据库
+ create database <DATABASE>
+ bool mysql_query(sql, connection)

#+BEGIN_SRC html :tangle /home/ben/.apache/mysql_create.php
  <html>
    <head>
      <title>Creating MySQL Database</title>
    </head>
    <body>
      <?php
        $dbhost = "localhost:3306";
        $dbuser = "root";
        $dbpass = "t910112";
        $conn = mysql_connect($dbhost, $dbuser, $dbpass);
        if(! $conn)
            die("Could not connect:" . mysql_error());
        echo 'Connected successfully<br />';
        $sql = "CREATE DATABASE TUTORIAL";
        $retval=mysql_query($sql, $conn);
        if(! $retval)
            die("Could not create database" . mysql_error());
        echo "Datebase TUTORIAL created successfully";
        mysql_close($conn);
      ?>
    </body>
  </html>
#+END_SRC

**** MySQL 删除数据库
+ drop database <DATABASE>
#+BEGIN_SRC html :tangle /home/ben/.apache/mysql_drop.php
  <html>
    <head>
      <title>Creating MySQL Database</title>
    </head>
    <body>
      <?php
        $dbhost = "localhost:3306";
        $dbuser = "root";
        $dbpass = "t910112";
        $conn = mysql_connect($dbhost, $dbuser, $dbpass);
        if(! $conn)
            die("Could not connect:" . mysql_error());
        echo 'Connected successfully<br />';
        $sql = "DROP DATABASE TUTORIAL";
        $retval=mysql_query($sql, $conn);
        if(! $retval)
            die("Could not create database" . mysql_error());
        echo "Datebase TUTORIAL dropped successfully";
        mysql_close($conn);
      ?>
    </body>
  </html>
#+END_SRC

**** MySQL 选择数据库
+ use <DATABASE>
+ bool mysql_select_db(db_name, connection);

#+BEGIN_SRC html :tangle /home/ben/.apache/mysql_select.php
  <html>
    <head>
      <title>Creating MySQL Database</title>
    </head>
    <body>
      <?php
        $dbhost = "localhost:3306";
        $dbuser = "root";
        $dbpass = "t910112";
        $conn = mysql_connect($dbhost, $dbuser, $dbpass);
        if(! $conn)
            die("Could not connect:" . mysql_error());
        echo 'Connected successfully<br />';
        $select = mysql_select_db("mysql");
        if($select)
            echo "succeed!";
        mysql_close($conn);
      ?>
    </body>
  </html>
#+END_SRC
**** MySQL 数据类型
1. 数值类型
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.8\linewidth]{/home/ben/Wally/Journal/Figure/scrot/18694PAw.png}
   \end{figure}

   + SQL标准类型： INTERGER, SMALLINT, DECIMAL, NUMERIC, FLOAT, REAL, DOUBLE
   + 扩展类型：TINYINT, MEDIUMINT, BIGINT

2. 日期和时间
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.8\linewidth]{/home/ben/Wally/Journal/Figure/scrot/18694cK2.png}
   \end{figure}

3. 字符串类型
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.8\linewidth]{/home/ben/Wally/Journal/Figure/scrot/18694OUF.png}
   \end{figure}

   + CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度
     和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写
     转换。

   + BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字
     符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符
     字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。

   + BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：
     MEDIUMBLOB LONGBLOB TINYBLOB BLOB. 它们只是可容纳值的最大长度不同。

   + 有4种TEXT类型：TINYTEXT TEXT MEDIUMTEXT和LONGTEXT。这些对应4种
     BLOB类型，有相同的最大长度和存储需求。
**** MySQL 创建数据表
+ 创建MySQL数据表需要以下信息
  - 表名
  - 表字段名
  - 定义每个表字段
+ create table TABLE_NAME {COLUMN_NAME, COLUMN_TYPE};
  \begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\linewidth]{/home/ben/Wally/Journal/Figure/scrot/18694beL.png}
  \end{figure}

  - 如果你不想字段为 *NULL* 可以设置字段的属性为 *NOT NULL* ，在操作数
    据库时如果输入该字段的数据为NULL，就会报错
  - *AUTO_INCREMENT* 定义列为自增的属性，一般用于主键，数值会自动加1
  - *PRIMARY KEY* 关键字用于定义列为主键。可以使用多列来定义主键，列间
    以逗号分隔。

+ bool my_query(sql, connection)

#+BEGIN_SRC html :tangle /home/ben/.apache/mysql_create_table.php
  <html>
    <head>
      <title>Creating MySQL Database</title>
    </head>
    <body>
      <?php
        $dbhost = "localhost:3306";
        $dbuser = "root";
        $dbpass = "t910112";
        $conn = mysql_connect($dbhost, $dbuser, $dbpass);
        if(! $conn)
            die("Could not connect:" . mysql_error());
        echo 'Connected successfully<br />';
        $sql = "CREATE DATABASE TUTORIAL";
        $create = mysql_query($sql, $conn);
        if(! $create)
            die("failed to create datebase" . mysql_error());
        $sql = "create table tutorials_tbl(" .
               "tutorial_id INT NOT NULL AUTO_INCREMENT, " .
               "tutorial_title VARCHAR(100) NOT NULL, " .
               "tutorial_author VARCHAR(40) NOT NULL, " .
               "submission_date DATE, " .
               "PRIMARY KEY (tutorial_id)); ";
        mysql_select_db("TUTORIAL");
        $retval = mysql_query($sql, $conn);
        if(! $retval)
            die("Could not create table: " . mysql_error());
        echo "Table created successfully";
        mysql_close($conn);
      ?>
    </body>
  </html>
#+END_SRC
**** MySQL 插入数据
+ MySQL语法
  #+BEGIN_EXAMPLE
    INSERT INTO tabel_NAME (filed1, field2, ..., fieldN)
                           VALUE
                           (value1, value2, ..., valueE);
  #+END_EXAMPLE
  + 如果数据是字符型，必须使用单引号或者双引号，如："value"。
+ bool mysql_query(sql, connection)
*** SQLite
**** what
SQLite是一个进程内的库，实现了 *数据库引擎*
+ 自给自足的
+ 零配置的
+ 无服务器的
+ 事务性的

**** why
+ 不需要单独的服务器进程
+ 零配置
+ 以文件形式存储
+ 轻量级，小于400k
+ 自给自足，不需要外部依赖
+ 支持SQL92的大多数查询语言的功能
+ 开源
+ 跨平台

**** SQLite命令
1. 数据定义语言 DDL
   + CREATE
   + ALTER
   + DROP
2. 数据操作语言
   + INSERT
   + UPDATE
   + DELETE
3. 数据查询语言
   + SELECT

**** 安装
1. apt-get
2. source code*

**** 常用命令
+ 以句点开头
+ 不以分号结束

e.g.
- .help
- .show
- .schema

**** SQLite语法
1. 不区分大小写
2. 注释 --开头或者/*COMMENT*/
3. SQL语句以关键字开头，分号结束

**** SQLite数据类型
1. 数据类
2. Affinity类型

**** 创建数据库
#+BEGIN_EXAMPLE
$ sqlite3 testDB.db
>.database  -- 查看数据库信息
>.quit -- 退出
$ sqlite3 testDB.db .dump > test.sql -- 保存到文本文件中
#+END_EXAMPLE

**** 附加数据库
sqlite>ATTATCH DATABASE 'DatabaseName' as 'AliasName';

main和temp是保留名称

**** 分离数据库
sqlite>DETACH DATABASE 'AliasName'

**** 创建表
#+BEGIN_EXAMPLE
CREATE TABLE database_name.table_name(
   column1 datatype  PRIMARY KEY(one or more columns),
   column2 datatype,
   column3 datatype,
   .....
   columnN datatype,
);
#+END_EXAMPLE

e.g.
#+BEGIN_EXAMPLE
sqlite> CREATE TABLE COMPANY(
   ID INT PRIMARY KEY     NOT NULL,  -- NOT NULL 用于约束字段不能为NULL
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);

#+END_EXAMPLE

>.tables -- 列出表
>.schema COMPANY -- 查看表

**** 删除表
>DROP TABLE database_name.table_name;

**** INSERT
#+BEGIN_EXAMPLE
INSERT INTO TABLE_NAME (column1, column2, column3,...columnN) \
VALUES (value1, value2, value3,...valueN);
#+END_EXAMPLE

#+BEGIN_EXAMPLE
INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);
#+END_EXAMPLE

#+BEGIN_EXAMPLE
INSERT INTO first_table_name [(column1, column2, ... columnN)]
   SELECT column1, column2, ...columnN
   FROM second_table_name
   [WHERE condition];
#+END_EXAMPLE

**** SELECT
SELECT column1, column2, columnN FROM table_name;

>.header on
>.mode column
>.width 10, 20, 10 -- 输出设置


** SQLite                                                           :sqlite:
*** SQLite                                                       :tutorial:
**** what
SQLite是一个进程内的库，实现了 *数据库引擎*
+ 自给自足的
+ 零配置的
+ 无服务器的
+ 事务性的

**** why
+ 不需要单独的服务器进程
+ 零配置
+ 以文件形式存储
+ 轻量级，小于400k
+ 自给自足，不需要外部依赖
+ 支持SQL92的大多数查询语言的功能
+ 开源
+ 跨平台

**** SQLite命令
1. 数据定义语言 DDL
   + CREATE
   + ALTER
   + DROP
2. 数据操作语言
   + INSERT
   + UPDATE
   + DELETE
3. 数据查询语言
   + SELECT

**** 安装
1. apt-get
2. source code*

**** 常用命令
+ 以句点开头
+ 不以分号结束

e.g.
- .help
- .show
- .schema

**** SQLite语法
1. 不区分大小写
2. 注释 --开头或者/*COMMENT*/
3. SQL语句以关键字开头，分号结束

**** SQLite数据类型
1. 数据类
2. Affinity类型

**** 创建数据库
#+BEGIN_EXAMPLE
$ sqlite3 testDB.db
>.database  -- 查看数据库信息
>.quit -- 退出
$ sqlite3 testDB.db .dump > test.sql -- 保存到文本文件中
#+END_EXAMPLE

**** 附加数据库
sqlite>ATTATCH DATABASE 'DatabaseName' as 'AliasName';

main和temp是保留名称

**** 分离数据库
sqlite>DETACH DATABASE 'AliasName'

**** 创建表
#+BEGIN_EXAMPLE
CREATE TABLE database_name.table_name(
   column1 datatype  PRIMARY KEY(one or more columns),
   column2 datatype,
   column3 datatype,
   .....
   columnN datatype,
);
#+END_EXAMPLE

e.g.
#+BEGIN_EXAMPLE
sqlite> CREATE TABLE COMPANY(
   ID INT PRIMARY KEY     NOT NULL,  -- NOT NULL 用于约束字段不能为NULL
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);

#+END_EXAMPLE

>.tables -- 列出表
>.schema COMPANY -- 查看表

**** 删除表
>DROP TABLE database_name.table_name;

**** INSERT
#+BEGIN_EXAMPLE
INSERT INTO TABLE_NAME (column1, column2, column3,...columnN) \
VALUES (value1, value2, value3,...valueN);
#+END_EXAMPLE

#+BEGIN_EXAMPLE
INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);
#+END_EXAMPLE

#+BEGIN_EXAMPLE
INSERT INTO first_table_name [(column1, column2, ... columnN)]
   SELECT column1, column2, ...columnN
   FROM second_table_name
   [WHERE condition];
#+END_EXAMPLE

**** SELECT
SELECT column1, column2, columnN FROM table_name;

>.header on
>.mode column
>.width 10, 20, 10 -- 输出设置

*** SQLite

SQLite 是一个自持的（self-contained）、无服务器的、零配置的、事务型的
关系型数据库引擎。因为他很小，所以也可以作为嵌入式数据库内建在你的应用
程序中。SQLite 被应用在 Solaris 10操作系统、Mac OS 操作系统、iPhone 和
Skype 中。QT4 、Python 、 PHP 都默认支持 SQLite ，Firefox Amarok 等流
行的应用程序在内部也使用了 SQLite.

SQLite数据库引擎实现了主要的SQL-92标准，引擎本身只有一个文件，大小不到
300k ，但是并不作为一个独立的进程运行，而是动态或者静态的链接到其他应
用程序中。它生成的数据库文件是一个普通的磁盘文件，可以放置在任何目录下。
SQLite 本身是C语言开发的，开源也跨平台，并且被所有的主流编程语言支持。

1. 基本命令
   1) sqlite3
   2) .help  帮助命令，所有的命令都是以句点开头
   3) .quit/.exit 退出命令
2.
* progress
** GNU Make

#+BEGIN_EXAMPLE
- State "TOBECONTINED" from "TODO"       [2015-11-23 一 14:34]
- State "TODO"       from ""           [2015-11-23 一 14:12] \\
  Make学习之路
#+END_EXAMPLE

*** 项目规化
1. 学习教材： 《GNU Make项目管理》
2. 学习计划： *按章节来* ，教材布局合理，由浅入深，内容均布
   1) 首先无笔记式地阅读书籍，计划平均 *1小时*
      - 不圈不点
      - 不实现程序
      - 遇到不会但不是核心的东西暂时不管
   2) 阅读电子版书籍，计划平均 *1.5小时*
      - 实现源码
      - 做ORG-笔记
      - 将不会但不相关的知识使用 *org-capture* 添加到待为事项中，等有
        时间处理
   3) *小结* 并 规化下一步

*** make 入门
- State "TOBECONTINED" from ""           [2015-11-23 一 17:25]
CLOCK: [2015-11-20 五 18:31]--[2015-11-20 五 19:43] =>  1:12
CLOCK: [2015-11-20 五 10:12]--[2015-11-20 五 11:24] =>  1:12

**** minted for makefile                                          :minted:
#+begin_example
  $ pygmentize -l lexers | grep make
  ,* basemake:
  ,* cmake:
      cmake (filenames *.cmake, cmakelists.txt)
  ,* make, makefile, mf, bsdmake:
      makefile (filenames *.mak, makefile, makefile, makefile.*, gnumakefile)
#+end_example

*make,  makefile,  mf*

**** make VS scripts
相对于脚本，make的优点是：
*你可以把程序中各元素之间的关系告诉make，然后make会根据这些关系和时间
戳判断应该重新进行哪些步骤，以及产生你所需要的程序*

**** 规则(rule)
1) 工作目标(target)
2) 必要条件(prerequisite)
3) 命令(command)

#+begin_latex
  \begin{minted}[frame=single, mathescape]{mf}
  target:prereq1 prereq2
      commands
  \end{minted}
#+end_latex

e.g.
#+begin_latex
\begin{minted}[frame=single, mathescape]{mf}
foo.o: foo.c foo.h
    gcc -c foo.c
\end{minted}
#+end_latex

运行过程中任何错误都会使make终止工作目标的建立并结束运行。

demo1

** 数据库学习

#+BEGIN_EXAMPLE
- State "TODO"       from ""           [2015-11-23 一 14:48] \\
  数据库的学习可能有必要
#+END_EXAMPLE

*** TODO 项目规化 [1/1]

1. [X] 数据库选择: MySQL 还是 SQLite（优点之一，无后台服务，可以应用于嵌入
   式中）
2. [ ]必要性在哪： *没有找到切切实实的应用之前不要开始*
** Qt 学习
*** 项目规化
*** Chapter 1
**** Hello Qt
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/helloqt/helloqt.cpp
  #include <QApplication>
  #include <QLabel>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QLabel* label = new QLabel("Hello Qt!");
    label->show();
    return app.exec();
  }
#+END_SRC

+ 窗口部件(widget)是指用户界面的一个可视化元素，该词源于"window
  gadget"（窗口配件），相当于Window系统术语的”控件”(control)和”容
  器”(container).
+ QApplication对象用于管理整个应用程序所用到的资源，以argc和argv为参
  数，也就是说，Qt支持自己的一些命令行参数。
+ 绝大多数应用程序都会使用一个QMainWindow或一个QDialog作为它的窗口，但
  Qt是如此灵活，以至于任意窗口部件都可以用作窗口。
+ show()方法使部件可见，在创建窗口部件时标签通常都是隐藏的，这样允许先
  进行设置再显示，避免闪烁。
+ app.exec()方法使程序进入事件循环状态，这是一种等待状态，程序会等候用
  户的动作。

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/helloqt2/helloqt.cpp
  #include <QApplication>
  #include <QLabel>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QLabel* label = new QLabel("<h2><i>Hello</i><font color=red>Qt!</font></h2>");

    label->show();
    return app.exec();
  }
#+END_SRC

+ 通过使用一些简单的HTML样式格式，就可以轻松地把Qt应用程序的用户接口变
  得丰富多彩。
**** 建立连接
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/quit/quit.cpp
  #include <QApplication>
  #include <QPushButton>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QPushButton *button = new QPushButton("quit");
    QObject::connect(button, SIGNAL(clicked()), &app, SLOT(quit()));
    button->show();
    return app.exec();
  }

#+END_SRC

**** 窗口部件的布局
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/age/age.cpp
  #include <QApplication>
  #include <QHBoxLayout>
  #include <QSpinBox>
  #include <QSlider>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QWidget* window = new QWidget;
    window->setWindowTitle("Enter your age:");

    QSpinBox* spinBox = new QSpinBox;
    QSlider* slider = new QSlider(Qt::Horizontal);
    spinBox->setRange(0, 130);
    slider->setRange(0, 130);

    QObject::connect(spinBox, SIGNAL(valueChanged(int)),
                     slider, SLOT(setValue(int)));
    QObject::connect(slider, SIGNAL(valueChanged(int)),
                     spinBox, SLOT(setValue(int)));

    QHBoxLayout* layout = new QHBoxLayout;
    layout->addWidget(spinBox);
    layout->addWidget(slider);
    window->setLayout(layout);
    window->show();
    return app.exec();
  }
#+END_SRC

Qt有三个主要的布局管理器：
+ QHBoxLayout
+ QVBoxLayout
+ QGridLayout

**** 窗口部件的风格
Qt应用程序在每个平台上都可以看起来像本地程序一样，Qt是通过所模拟平台的
外观来实现这一点的，而不是针对某个特殊平台的封闭或者一个工具包中的窗口
部件集。
+ Plastique(KDE)
+ Cleanlooks(GNOME)
+ CDE
+ motif
+ Windows(仅能在本地平台上有效，因为需要依赖平台的主题引擎，下同)
+ Windows XP
+ Windows Vista
+ Mac


在X11下，可以在命令行设置程序窗口风格
#+BEGIN_EXAMPLE
./out -style motif
#+END_EXAMPLE

*** 创建对话框
**** 子类化QDialog
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/finddialog.h
  #ifndef FINDDIALOG_H
  #define FINDDIALOG_H

  #include <QDialog>

  class QCheckBox;
  class QLabel;
  class QLineEdit;
  class QPushButton;

  class FindDialog : public QDialog{
    Q_OBJECT

  public:
    FindDialog(QWidget *parent=0);

  signals:
    void findNext(const QString& str, Qt::CaseSensitivity cs);
    void findPrevious(const QString& str, Qt::CaseSensitivity cs);

  private slots:
    void findClicked();
    void enableFindButton(const QString& text);

  private:
    QLabel *label;
    QLineEdit *lineEdit;
    QCheckBox *caseCheckBox;
    QCheckBox *backwardCheckBox;
    QPushButton *findButton;
    QPushButton *closeButton;
  };

  #endif
#+END_SRC

+ 前置声明(forward declaration)告诉C++编译器类的存在，而不用提供类定义
  的所有细节
+ 前置声明的类型在头文件中使用指针声明
+ 编译速度快
+ FindDialog(QWidget *parent=0)为典型的Qt窗口部件构造函数定义方式，
  parent参数指定部件的父窗口，默认为空指针，即没有父对象。
+ 对于所有使用信号和槽的类，在类定义开始处的 Q_OBJECT 宏是必须的。
+ signals部分定义信号，signals实际上是一个宏，C++预处理器会在编译程序
  前将其转换为标准C++代码
+ Qt::CaseSensitivity是枚举类型
  - Qt::CaseSensitive
  - Qt::CaseInsensitive
+ slots部分定义槽，也是宏

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/finddialog.cpp
  #include <QtWidgets>
  #include "finddialog.h"

  FindDialog::FindDialog(QWidget *parent)
    : QDialog(parent)
  {
    label = new QLabel("Find &What:");
    lineEdit = new QLineEdit;
    label->setBuddy(lineEdit);

    caseCheckBox = new QCheckBox("Match &case");
    backwardCheckBox = new QCheckBox("Search &backward");

    findButton = new QPushButton("&Find");
    findButton->setDefault(true);
    findButton->setEnabled(false);

    closeButton = new QPushButton("&Close");

    connect(lineEdit, SIGNAL(textChanged(const QString&)),
            this, SLOT(enableFindButton(const QString&)));
    connect(findButton, SIGNAL(clicked()),
            this, SLOT(findClicked()));
    connect(closeButton, SIGNAL(clicked()),
            this, SLOT(close()));

    QHBoxLayout *topLeftLayout = new QHBoxLayout;
    topLeftLayout->addWidget(label);
    topLeftLayout->addWidget(lineEdit);

    QVBoxLayout *leftLayout = new QVBoxLayout;
    leftLayout->addLayout(topLeftLayout);
    leftLayout->addWidget(caseCheckBox);
    leftLayout->addWidget(backwardCheckBox);

    QVBoxLayout *rightLayout = new QVBoxLayout;
    rightLayout->addWidget(findButton);
    rightLayout->addWidget(closeButton);
    rightLayout->addStretch();

    QHBoxLayout *mainLayout = new QHBoxLayout;
    mainLayout->addLayout(leftLayout);
    mainLayout->addLayout(rightLayout);
    setLayout(mainLayout);

    setWindowTitle("Find");
    setFixedHeight(sizeHint().height());
  }


  void FindDialog::findClicked(){
    QString text = lineEdit->text();
    Qt::CaseSensitivity cs =
      caseCheckBox->isChecked() ? Qt::CaseSensitive
      : Qt::CaseInsensitive;
    if(backwardCheckBox->isChecked()){
      emit findPrevious(text, cs);
    }else{
      emit findNext(text, cs);
    }
  }

  void FindDialog::enableFindButton(const QString &text){
    findButton->setEnabled(!text.isEmpty());
  }

#+END_SRC
+ #include <QtWidgets>包含所有窗口部件，但在一个头文件中包含一个在的头文
  件着实不是一个好的编程习惯。
  + Qt4 $include <QtGui>
+ 构造函数中把parent参数传递给基类的构造函数
+ tr()函数表示翻译，有时是不错的选择
+ &操作符表快捷键(Alt+W)
+ 所谓“伙伴”(buddy)，就是一个窗口部件，它可以在按下标签的快捷键时接
  收焦点(focus).
+ setDefault()设定默认按钮(default button), 即当用户按下Enter键时对应
  的按钮。
+ 通过 QHBoxLaytout,QVBoxLayout,QGridLayout的不同嵌套组合，可以构建出
  相当复杂的对话框。
+ addStrentch方法增加分隔符(伸展器)，用来占据空白区域
+ 当将子布局对象添加到父布局对象，子布局对象就会重新定义自己的父对象。
  它所有的子窗口部件都会重新定义自己的父对象。
+ QWidget::sizeHint()方法返回部件“理想”的尺寸大小
+ 创建窗口对象使用的是new，所以需要调用delete来析构。但这样不是必须的，
  Qt在删除对象时会自动删除所有的子对象
+ emit是Qt扩展的关键字，像其它Qt扩展一样，它也会被C++预处理器转换为标
  准的C++代码

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>

  #include "finddialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    FindDialog *dialog = new FindDialog;
    dialog->show();
    return app.exec();
  }

#+END_SRC

+ 为了使 *moc* 能够正常运行，必须把类定义从实现文件中分离出来并放到头
  文件中
+ 必须对使用了Q_OBJECT宏的类运行moc(qmake),否则会出现不明确的错误信息。
+ 默认的Tab键顺序是创建窗口部件的顺序，可以使用QWidget::setTabOrder()
  方法设置
+ 提供一种合理的Tab键顺序的键盘快捷键可以确保不愿（或者不能）使用鼠标
  的用户能够充分享受应用程序提供的全部功能。完全通过键盘控制应用程序也
  深受快速输入人员的赞赏。

**** 信号和槽
1. 槽
   + 可以是虚函数
   + 可以被重载
   + 可以是公有的，私有的，保护的
   + 可以被其它成员函数直接调用
   + 参数可以是任意类型
   + *槽可以与信号连接*
2. connect(sender, SIGNAL(signal), receiver, SLOT(slot))
   + sender, receiver是指向QObject的指针
   + signal和slot是不带参数的函数名
3. 机制
   + 一个信号可以连接多个槽
     + 发射信号时，会以不确定的顺序一个接一个调用关联的槽
   + 多个信号可以关联一个槽
   + 一个信号可以与另外一个信号关联
     #+BEGIN_EXAMPLE
       connect(lineEdit, SIGNAL(textChanged(const QString&))
               this, SIGNAL(updateRecord(const QString&)))
     #+END_EXAMPLE
   + 连接可以被移除
     + 很少用，当删除对象时，Qt会自动移除和这个对象相关的所有关联。
4. 注意
   + 信号和槽的参数必有有相同的顺序和相同的类型
   + 信号的参数比槽多时，多余参数会为被忽略
   + 不匹配则警告
   + 信号和槽机制是由QObject实现，并不只是局限于图形界面编程

**** Qt的对象系统
moc(meta-object system), 对C++的重要扩展。
+ 信号和槽
+ 内省
**** 快速设计对话框
Qt的设计初衷是为了能够直观并且友好也进行 *手工编码* ，并且对于程序员来
说， 编写C++源代码开发整个Qt应用程序并不稀奇。

QtDesigner提供了Qt的可视化编码方式。

手工编码和使用QtDesigner在创建对话框时的基本步骤是一致的
1. 创建并初始化子窗口部件
2. 把子窗口部件放到布局中
3. 设置Tab键顺序
4. 建立信号的槽的连接
5. 实现对话框自定义的槽

***** 使用QtDesigner设计对话框并保存为 ui 文件
+ filename.ui
+ Qt用户界面编译器(user interface compiler, uic) 将ui文件转换为C++代码
  + $ uic filename.ui
  + ui_filename.h
    + 头文件中包含了Ui::GoToCellDialog的定义(GoTocelldialog为
      QtDesigner设计的窗体的顶层部件的objectName)
    + setupUi()函数用于初始化窗体

****** 直接使用
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>
  #include <QDialog>

  #include "ui_gotocelldialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);

    Ui::GoToCellDialog ui;
    QDialog *dialog = new Dialog;
    ui.setupUi(dialog);
    dialog.show();
    return app.exec();
  }

#+END_SRC

+ 什么也做不了

****** 多继承：最简捷
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/gotocelldialog.h
  #ifndef GOTOCELLDIALOG_H
  #define GOTOCELLDIALOG_H

  #include <QDialog>

  #include "ui_gotocelldialog.h"

  class GoToCellDialog : public QDialog, public Ui::GoToCellDialog{
    Q_OBJECT

  public:
    GoToCellDialog(QWidget *parent=0);

  private slots:
    void on_lineEdit_textChanged();
  };

  #endif
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/gotocelldialog.cpp
  #include <QtWidgets>

  #include "gotocelldialog.h"

  GoToCellDialog::GoToCellDialog(QWidget *parent)
    : QDialog(parent)
  {
    setupUi(this);

    QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");
    lineEdit->setValidator(new QRegExpValidator(regExp, this));

    connect(okButton, SIGNAL(clicked()), this, SLOT(accept()));
    connect(cancelButton, SIGNAL(clicked()), this, SLOT(reject()));
  }

  void GoToCellDialog::on_lineEdit_textChanged(){
    okButton->setEnabled(lineEdit->hasAcceptableInput());
  }
#+END_SRC

+ setUp()还会自动将那些符合on_objectName_signalName()命名惯例的任意槽
  与相应的objectName的signalName()信号连接到一起。
+ Qt提供了三种内置检验器类:
  - QIntValidator
  - QDoubleValidator
  - QRegExpValidator
+ 通过this传递绘QRegExpValidator的构造函数，使它成为窗口的子对象，这样
  就可以不用担心有关删除QRegExpValidator的事情了，当删除它的父对象时，
  会被自动删除。
+ Qt的父子对象机制是在QObject中实现的。很大程度上简化了内在管理的工作，
  降低了内在泄漏的风险。需要明确删除的是那些使用new创建并且没有父对象
  的对象。
+ accept()和reject()槽都可以关闭对话框，前者将QDialog::Accepted置1,后
  者置0.

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>

  #include "gotocelldialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    GoToCellDialog *dialog = new GoToCellDialog;
    dialog->show();
    return app.exec();
  }

#+END_SRC

+ 注：org tangle不会覆盖已存在的文件

**** 改变对话框的形状
+ 扩展对话框(extension dialog)
+ 多页对话框(multi-page dialog)

***** 扩展对话框

Qt Designer允许我们在构成同一窗体的不同部分内的窗口部件之间建立连接。
+ Edit -> Edit Signals/Slots 进入设置连接模式。

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/sortdialog.h
  #ifndef SORTDIALOG_H
  #define SORTDIALOG_H

  #include <QDialog>

  #include "ui_sortdialog.h"

  class SortDialog : public QDialog, public Ui::SortDialog{
    Q_OBJECT

  public:
    SortDialog(QWidget *parent=0);
    void setColumnRange(QChar first, QChar last);
  };

  #endif
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/sortdialog.cpp
  #include <QtWidgets>

  #include "sortdialog.h"

  SortDialog::SortDialog(QWidget *parent)
    : QDialog(parent)
  {
    setupUi(this);

    secondaryGroupBox->hide();
    tertiaryGroupBox->hide();
    layout()->setSizeConstraint(QLayout::SetFixedSize);

    setColumnRange('A', 'Z');
  }

  void SortDialog::setColumnRange(QChar first, QChar last){
    primaryColumnCombo->clear();
    secondaryColumnCombo->clear();
    tertiaryColumnCombo->clear();

    secondaryColumnCombo->addItem("None");
    tertiaryColumnCombo->addItem("None");
    primaryColumnCombo->setMinimumSize(
                                       secondaryColumnCombo->sizeHint());

    QChar ch = first;
    while(ch <= last){
      primaryColumnCombo->addItem(QString(ch));
      secondaryColumnCombo->addItem(QString(ch));
      tertiaryColumnCombo->addItem(QString(ch));
      ch = ch.unicode()+1;
    }
  }
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/main.cpp
  #include <QApplication>

  #include "sortdialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    SortDialog *dialog = new SortDialog;
    dialog->setColumnRange('C', 'F');
    dialog->show();
    return app.exec();
  }

#+END_SRC

***** 多页对话框
+ QTabWidget
+ QListWidget
+ QStackedWidget


**** 动态对话框
+ 动态对话框(dynamic dialog)就是在程序运行时使用的从Qt设计师的.ui文件
  创建而来的那些对话框。
+ 运行时加载，而非先使用uic将ui文件转换为C++代码
+ 使用QUiLoader类载入ui文件
  #+BEGIN_EXAMPLE
    QUiLoader uiLoader;
    QFile file("sortdialog.ui");
    QWidget *sortDialog = uiLoader.load(&file);
    if(sortDialog){
        ...
    }
  #+END_EXAMPLE
+ 使用QObject::findChild<T>()来访问窗体中的各个子窗口部件
  #+BEGIN_EXAMPLE
    QComboBox *primaryColumnCombo =
              sortDialog->findChild<QCombobox *>("primaryColumnCombo");
    if(primaryColumncombo){
        ...
    }
  #+END_EXAMPLE
+ 对于MSVC 6, 须使用全局函数qFindChild()函数代替
+ QUiLoader类放在一个独立的类库中，需要在pro文件中加入 CONFIG += uitools

**** 内置的窗口部件和对话框
1. 按钮
   + QPushButton
   + QToolButton
   + QRadioButton
   + QCheckButton
2. 容器
   + QGroupBox
   + QFrame
3. 多页窗口部件
   + QTabWidget
   + QToobBox
4. 项视图窗口部件
   + QListView(列表/图标)
   + QTreeView
   + QTabView
5. 显示窗口部件
   + QLabel(应用最多，显示普通文本，HTML，图片)
   + QLCDNumber
   + QProgressBar
   + QTextBrowser
6. 输入窗口部件
   + QLineEdit
   + QTextEdit
   + QSpinBox
   + QDoubleSpinBox
   + QComboBox
   + QDateEdit
   + QTimerEdit
   + QDateTimeEdit
   + QScrollBar
   + QSlider
   + QDial
7. 对话框
   + QInputDialog
   + QProgressDialog
   + QMessageBox
   + QErrorMessage
   + QColorDialog
   + QFontDialog
   + QPageSetupDialog
   + QFileDialog
   + QPrintDialog
8. 向导
   + QWizard
9. 富文本引擎
   Qt库含有一个富文本引擎(rich text engine)，用于格式化文本的显示和编
   辑。

* Project
** toolbox

#+include: ~/Wally/Project/toolbox/README.md
#+include: ~/Wally/Project/toolbox/ChangeLog.txt

*** DONE Links to pdf
- State "DONE"       from ""           [2015-12-18 五 09:45] \\
  1) wkhtmltopdf 原生支持多个网页，只要在命令行中依次给出 url 即可，用不
     着写这样麻烦劣质的东西
  2) 使用英文注释，不要使用中文注释
  3) 不要在代码中加入无关的东西，注释中不要添加关于语言的用法，这是笔记
     的事情


#+BEGIN_SRC sh
  #! /bin/bash

  ## 功能
  ##    1. 使用wkhtmltopdf将多个网页转换为pdf
  ##    2. 使用gs合并生成的多个PDF
  ##    3. 使用pdfoutline合并的PDF生成目录

  ## 格式： links2pdf index
  ## 输入： index为文件，包含链接和章节信息
  ##       index每行为一个链接
  ##       line: link---chapter---level


  ## version 0.2 --- 添加注释
  ## version 0.3 --- 类似CMake的外部编译，在目录build下进行

  index=$1
  builddir=links2pdf_build
  mkdir $builddir
  cd $builddir
  cp ../$index .

  > outline                       # 利用重定向生成空文件
  declare -i counter=0            # 限制变量counter的属性为整型，counter用于计算章节数
  declare -i page=1               # page用于跟踪页数
  cat $index | while read -r line
  do
      counter=counter+1           # "整型"变量可以直接进行数值计算， 一般变量需要通过$(())

      # ${} 字符串处理
      link=${line%%\ *}           # %去尾，双%匹配最长，即删除尾部与模式匹配的最大子字符串
      level=${line##*\ }          # #支头，双#匹配最长，即删除头部与模式匹配的最大子字符串
      # range=$((len3-len1-len2-2))       # range???  len<N>??? 明显多余
      link_chapter=${line%\ *}    # %去尾，单%匹配最短，即删除尾部与模式匹配的最小子字符串

      # #去头，单#匹配最短，即删除头部与模式匹配的最小子字符串
      # 前提是link中无空格，章节中可能存在空格
      chapter=${link_chapter#*\ }

      # 9是幻数，含义是小于10的章节索引有前缀0，即01,02... 便于gs排序
      if test ${counter} -gt 9    # test 或 [ condition ]
         then
                 wkhtmltopdf --no-outline $link $counter.pdf; # HTML to PDF
                 Pages=$(pdfinfo $counter.pdf | grep Pages);  # $() 或 反引号`` 执行shell命令并c返回
                 num=${Pages##*\ };
      else
          wkhtmltopdf --no-outline $link 0${counter}.pdf;
          Pages=$(pdfinfo 0${counter}.pdf | grep Pages);
          num=${Pages##*\ };
      fi
      echo "$level $page $chapter" >> outline
      page=$((page+num))          # $(()) 数值运算，变量page已经声明为“整型”，也可以不包裹
  done


  # gs
  gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=out.pdf  *.pdf

  # pdfoutline
  pdfoutline out.pdf outline output.pdf

  # 删除文件
  mv output.pdf ..
  cd ..
  rm -rf $builddir

#+END_SRC

*** Track 规范化 standardize file name                     :filename:stdfn:
- State "Track"      from ""           [2015-12-18 五 10:48] \\
  1. 小结
     + 文件命名要有规范，最好不要仅使用下划线连接几个单词，好丑
     + 不要使用中文注释

  2. TODOs
     + 多个路径参数
     + 参数检查
     + 递归遍历
     + 使用正则替换所有除下划线、数字和字母外的所有特殊字符为下划线

#+INCLUDE: ~/Wally/Project/toolbox/src/stdfn.sh

*** convert pptx to pdf in batch                             :ppt:pptx:pdf:

#+INCLUDE: ~/Wally/Project/toolbox/src/pptx2pdf.sh

*** merge PDFs with outline

#+INCLUDE: ~/Wally/Project/toolbox/src/mergepdfs.sh

*** NEXT remove backfile ended with ~ recursively
- State "NEXT"       from ""           [2015-12-20 日 23:03] \\
  not working well. ls may be the problem

#+INCLUDE: ~/Wally/Project/toolbox/src/debackup.sh

*** NEXT project
- State "NEXT"       from "TODO"       [2015-12-21 一 19:17] \\
  写了简单的 project 脚本，仅生成 .projectile, README.md, ChangeLog.txt
  文件和 test 目录
- State "TODO"       from ""           [2015-12-18 五 11:44] \\
  更简洁些，不要多余的功能

#+INCLUDE: ~/Wally/Project/toolbox/src/project.sh

**** project
#+BEGIN_SRC sh
   #! /bin/sh

  # tagerill_update_project.sh

  # version 1.0
  # This is a bash script to initialize a new project of common sense
  # It mainly finishes the following tasks
  # 1. create a new root directory that named by the first arguments
  # 2. create a README file containing information like timestamps,
  #    author, email, license and so on
  # 3. create a .projectile file for the convinence of Projectile to manage it
  #
  # version 1.1
  # add the function of update a project
  #
  # Usage
  # tagerill_new_project.sh <PROJECT> [COMMENT_STR]
  #
  # TODO
  # [ ] select a rule of naming versions & update the version information


  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "error: wrong number of arguments"
      echo "usage: tagerill_new_project.sh <PROJECT> [COMMENT_STR]"
      exit -1
  fi


  project=$1
  comments=""
  if [ $# -eq 3 ]
  then
      comments=$2
  fi

  # update the project
  if [ -d $project ]
  then
     cd $project
     echo >> README
     echo -n "MODIFICATION:" >> README
     date +%Y/%m/%d-%H:%M >> README
     # TODO： 变更版本信息
     if [ $# -eq 3 ]
     then
         echo "COMMENT: $comments" >> README
     fi
     echo "Project: $project updated."
     exit 0
  fi


  # create a new project
  # root workspace
  mkdir $project

  # README
  cd $project
  touch README
  echo "PROJECT: $project" >> README
  echo "VERSION: v1.0"
  echo -n "TIME: " >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "License: GPL v3.0" >> README

  # .projectile
  touch .projectile

  #
  echo "Project: $project has been created"

  exit 0

#+END_SRC

**** cpp

#+BEGIN_SRC sh
  #! /bin/sh

  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "Usage: cpp_pro.sh PROJECT"
      exit 1
  fi

  project=$1
  mkdir $project
  cd $project
  touch README COPYRIGHT TODO Makefile
  mkdir bin src include lib

  # README
  echo PROJECT: $project >> README
  echo -n TIME: >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "LICENSE: GPL v3.0" >> README

  # TODO
  echo [ ] >> TODO
  echo [ ] >> TODO
  echo [ ] >> TODO
#+END_SRC

**** cmake

#+BEGIN_SRC sh
  #! /bin/bash

  # 参数检查
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "usage: cmake_pro.sh PROJECT"
      exit
  fi

  project=$1
  mkdir $project
  cd $project
  # 目录结构
  mkdir src scripts build lib bin doc

  # 根目录下文件
  touch CMakeLists.txt
  echo "CMAKE_MINIMUM_REQUIRED(VERSION 3.2)" >> CMakeLists.txt
  echo "PROJECT($project)" >> CMakeLists.txt
  echo "ADD_SUBDIRECTORY(src bin)" >> CMakeLists.txt
  echo "ADD_SUBDIRECTORY(scripts)" >> CMakeLists.txt

  touch README COPYRIGHT TODO
  echo "PROJECT: $project" >> README
  echo -n "TIME: " >> README
  date +%Y/%M/%d-%H:%m >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README

  # TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO

  # src
  cd src
  touch CMakeLists.txt

  # scripts
  cd ../scripts
  touch CMakeLists.txt
  echo "# INSTALL(PROGRAMS project DESTINATION bin)" >> CMakeLists.txt
#+END_SRC

**** arduino

#+BEGIN_SRC sh
  #! /bin/bash

  # 参数个数检查
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of argument"
      echo "usage: ardpro PROJECT"
      exit
  fi

  project=$1
  mkdir $project                  # 创建目录
  cd $project
  touch README COPYRIGHT TODO Makefile $project.ino

  # README
  echo PROJECT: $project >> README
  echo -n TIME: >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "LICENSE: GPL v3.0" >> README

  # TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO

  # Makefile
  echo "BOARD_TAG = uno" >> Makefile
  echo "ARDUINO_LIBS = " >> Makefile
  echo "MONITOR_PORT = /dev/ttyACM0" >> Makefile
  echo "include /usr/share/arduino/Arduino.mk" >> Makefile
#+END_SRC

**** bash

#+BEGIN_SRC sh
  #! /bin/bash

  # Function: Create a new bash project
  # Usage: bash_pro.sh
  # Input: Project name
  # Output: Name


  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "Usage: bash_pro.sh PROJECT"
      exit
  fi

  project=$1
  mkdir $project
  cd $project
  touch README LICENSE TODO Makefile      # Files
  mkdir scripts bin               # Contents

  # REAMDE
  echo "Project: $project" >> README
  echo -n "Time: " >> README
  date +%Y/%m/%d-%H:%m >> README
  echo "Author: Wally" >> README
  echo "Email: buaaben@163.com" >> README
#+END_SRC

**** CMakelists.txt

#+BEGIN_SRC cmake
  CMAKE_MINIMUM_REQUIRED(VERSION 3.2)
  PROJECT(bash_pro)
  ADD_SUBDIRECTORY(src bin)
  ADD_SUBDIRECTORY(scripts)

  INSTALL(PROGRAMS bash_pro.sh DESTINATION bin)
#+END_SRC
*** TODO routine


#+INCLUDE: ~/Wally/Project/toolbox/src/routine.sh

TODOs
+ [ ] [[file:~/Wally/Project/toolbox/src/routine.sh::path=$1%20#%20path%20need%20to%20be%20absolute][check path]]




#+BEGIN_SRC sh
  #! /bin/sh

  # 执行git, pdf, clean等日常工作
  # 根据时间和地点完成不同的任务

  home=tiger                      # 用户名
  office=ben
  host=`echo $HOSTNAME`
  ws=$HOME/Wally/Journal  # workspace
  emacs_settings_ws="/home/${host}/.emacs.d"


  time=`date +%H`

  cmd=$1

  # if [ $time -gt $line ]                # in the evening
  # then
  #     if [ $host == $office ]   # at office
  #     then
  #       # clean
  #       touch tmpfile
  #       rm `ls . | grep -E "*~$|*.out$|*.log$|*.toc$|*.aux$|^tmpfile$"`
  #       # git push
  #       git add --ignore-removal .
  #       git commit -m "committed automatically by script at $office `date +%H%M`"
  #       git push origin master

  #       # pdf
  #       journal=journal.pdf
  #       if [ -e $journal ]
  #       then
  #           mv journal.pdf "PDFs/`date +%Y%m%d`.pdf"
  #       fi
  #     elif [ $host == $home ]                   # at home
  #     then
  #       # git pull
  #       git pull
  #       git merge origin/master
  #     fi
  # else                          # in the morning
  #     if [ $host == $office ]
  #     then
  #       # git pull
  #       git pull
  #       git merge origin/home
  #     elif [ $host == $home ]
  #     then
  #       # git push
  #       git add --ignore-removal .
  #       git commit -m "committed automatically by script at $home at `date +%H:%M`"
  #       git push origin home
  #     fi
  # fi


  if [ $cmd = "push" ]
  then
      cd $ws
      git add --ignore-removal .
      git commit -m "committed automatically by script at $home at `date +%H:%M`"
      git push origin master

      if [ $host = $office ]
      then
          cd $emacs_settings_ws
          git add settings.org
          git add elpa/yasnippet-20150323.311/snippets/
          git commit -m "committed automatically by script at $home at `date +%H:%M`"
          git push origin master

          thesis_ws="~/Wally/GraduationProject/Thesis"
          cd $thesis_ws
          git add .
          git commit -m "committed automatically by script at $home at `date +%H:%M`"
      fi
  elif [ $cmd = "pull" ]
  then
      cd $ws
      git pull
  fi


  # 命令行参数为密码
  # if [ $# -eq 1 ]
  # then
  #     passwd=$1
  #     python email_evernote.py $passwd
  # fi

  # dict

#+END_SRC

*** TODO email

#+BEGIN_SRC python
  #! /usr/bin/env python
  # -*- encoding:utf-8 -*-

  import smtplib

  from email import encoders
  from email.header import Header
  from email.mime.text import MIMEText
  from email.mime.multipart import MIMEMultipart
  from email.mime.base import MIMEBase
  from email.utils import parseaddr, formataddr

  import sys, datetime, os

  if len(sys.argv) < 2:
      print "done nothing. If a email needs to be delieved, please confirm and provide the passwd"
      exit(0)

  def _format_addr(s):
      name, addr = parseaddr(s)
      return formataddr((Header(name, 'utf-8').encode(), addr))

  pdf_file = "%s.pdf" % datetime.datetime.now().strftime("%Y%m%d")
  path = "/home/ben/Wally/Journal/PDFs/"
  filename = path + pdf_file

  from_addr = "buaaben@163.com"
  passwd = sys.argv[1]            # 从命令行获取密码
  to_addr = "buaaben.fa289a0@m.yinxiang.com"

  # 构造邮件对象
  msg = MIMEMultipart()
  # 发送地址
  msg['From'] = _format_addr("Ben<%s>" % from_addr)
  # 接收地址
  msg['To'] = _format_addr('Evernote<%s>' % to_addr)
  # 主题
  msg['Subject'] = Header("%s @Tagerill #journal" %
                          datetime.datetime.now().strftime("%Y%m%d"),
                          'utf-8').encode()

  # 时间戳
  now = datetime.datetime.now().strftime('%Y/%m/%d-%H:%M')
  msg.attach(MIMEText('Generated automatically by python script at %s' % now,
                      'plain', 'utf-8'))
  # 正文
  with open("/home/ben/dic.txt", 'r+') as f:
      voc = f.read()
      msg.attach(MIMEText('Vacabularies for today are as following: %s' % voc,
                          'plain', 'utf-8'))
      null = ''
      f.write(null)

  # 附件
  if os.path.exists(filename):
      with open(filename, 'rb') as f:
          mime = MIMEBase('PDF', 'pdf', filename='journal.pdf')
          mime.add_header('Content-Disposition', 'attachment',
                          filename='journal.pdf')
          mime.add_header('Content-ID', '<0>')
          mime.add_header('X-Attachment-Id', '0')

          # 把附件的内容读进来:
          mime.set_payload(f.read())
          # 用Base64编码:
          encoders.encode_base64(mime)
          # 添加到MIMEMultipart:
          msg.attach(mime)

  # 发送邮件
  # stmp_server = None              ####### TODO
  stmp_server = "smtp.163.com"
  port = 25
  server = smtplib.SMTP(stmp_server, 25)
  server.set_debuglevel(1)
  server.login(from_addr, passwd)
  server.sendmail(from_addr, [to_addr], msg.as_string())

#+END_SRC
