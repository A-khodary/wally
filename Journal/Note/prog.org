* C++                                                                   :CPP:
** reference

- [[http://www.cplusplus.com/][cplusplus]]
- [[~/Wally/Reference/Textbook/C++Primer_Zh_4th.pdf][C++Primer_Zh_4th.pdf]]
- [[~/Wally/Reference/Textbook/EffectiveC++.pdf][EffectiveC++.pdf]]
- [[~/Wally/Reference/Textbook/TheC++ProgrammingLanguage.pdf][The C++ProgrammingLanguage.pdf]]

** Tutorials                                                       :tutorial:
*** c++ primer

** datatype                                                  :blog:datatype:
*** [[http://www.cnblogs.com/li-hao/archive/2013/02/27/2935100.html][size_t类型]] :blog:

size_t 为了增强程序的可移植性，便有了size_t ，不同系统上，定义size_t可能不一样。

经测试发现，在32位系统中size_t是4字节的，在64位系统中，size_t是8字节的，这样利用该类型可以增加程序移植性。

*size_t的定义 *

它的定义在/usr/include/linux/types.h

  *typedef _kernel_size_t size_t;*



*跟体系结构相关 *

而__kernel_size_t 定义在 /usr/include/asm/posix_types.h

安装的是内核的源码

*asm-i386/posix_types.h*

 *typedef unsigned int __kernel_size_t;*

*asm-1a64/posix_types.h*

*typedef unsigned long kernel_size_t;*



size_t一般用来表示一种计数，比如有多少东西被拷贝等。例如：sizeof操作符的结果类型是size_t，该类型保证能容纳实现所建立的最大对象的字节大小。
它的意义大致是“适于计量内存中可容纳的数据项目个数的无符号整数类型”。所以，它在数组下标和内存管理函数之类的地方广泛使用。

** Thread                                                           :thread:
*** Linux C++ 多线程                                                :LINUX:
**** why 线程

1. 节省空间时间
2. 通信机制（方便）
**** Linux下的多线程
***** pthread
遵循POSIX线程接口， *pthread*,
头文件： <pthread.h>
库文件： libpthread.a
方法：clone()， 类似fork()

#+begin_latex
\begin{minted}[frame=single, mathescape]{cpp}
#include <iostream>
#include <unistd.h>
#include <pthread.h>

using namespace std;

void *thread(void *ptr){
  for(int i=0; i<3; i++){
    sleep(1);
    cout << "This is a pthread."  << endl;
  }

  return 0;
}

int main(int argc, char *argv[])
{
  pthread_t id;
  int ret = pthread_create(&id, NULL, thread, NULL);
  if(ret){
    cout << "Created pthread error!" << endl;
    return -1;
  }
  for(int i=0; i<3; i++){
    cout << "This is the main process." << endl;
    sleep(1);
  }
  pthread_join(id, NULL);
  return 0;
}

\end{minted}
#+end_latex

***** g++ 编译
#+begin_latex
\begin{minted}[frame=single, mathescape]{sh}
g++ thread.cpp  # 链接错误
g++ -lpthread thread.cpp  # 链接错误
g++ thread.cpp -lpthread  # 正确
g++ -pthread thread.cpp  # 正确
\end{minted}
#+end_latex

1. *实际的做法应该是在代码文件后面添加次选项。*
2. -lpthread VS -pthread
   1) -lpthread 传统的，老式的
   2) 可见编译选项中指定 -pthread 会附加一个宏定义 *-D_REENTRANT* ，该宏
      会导致 libc 头文件选择那些thread-safe的实现；链接选项中指定
      -pthread 则同 -lpthread 一样，只表示链接 POSIX thread 库。由于
      libc 用于适应 thread-safe 的宏定义可能变化，因此在编译和链接时都
      使用 -pthread 选项而不是传统的 -lpthread 能够保持向后兼容，并提
      高命令行的一致性。

***** 常用函数

1. *pthread_t* 线程标识符
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{cpp}
        typedef unsigned long int pthread$_t;
     \end{minted}
   #+end_latex

2. *pthread_create* 创建线程
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{cpp}
     extern int pthread_create (pthread_t *__restrict __newthread,
                                const pthread_attr_t *__restrict __attr,
                                void *(*__start_routine) (void *),
                                void *__restrict __arg) __THROWNL __nonnull ((1, 3));
     \end{minted}
   #+end_latex
   1) arg1： 指向线程标识符的指针
   2) arg2： 设置线程属性，NULL表示默认
   3) arg3： 线程运行函数的起始地址
   4) arg4： 运行函数的参数，NULL表示零参
   5) 返回值： 0表示创建线程成功，失败则返回其它。
      + EAGAIN: 系统限制创建线程
      + EINVAL: 线程属性值非法

3. *pthread_join* 用来等待一个线程的结束
   #+begin_latex
   \begin{minted}[frame=single, mathescape]{cpp}
   extern int pthread_join (pthread_t __th, void **__thread_return);
   \end{minted}
   #+end_latex
   1) arg1: 线程标识符指针
   2) arg2: 用户定义的指针，用来存储被等待线程的返回值。

4. *pthread_exit*

***** 线程属性

对于大多数程序来说，默认属性(NULL)就足够了。线程属性包括：是否绑定、是
否分离、堆栈地址、堆栈大小、优先级。默认的属性为非绑定、非分离、缺省1M
的堆栈、与父进程同样级别的优先级。

属性结构 *pthread_attr_t* 定义在头文件<pthread.h>中。

属性值不能直接设置，必须使用相关函数。
+ pthread_attr_init
+ pthread_attr_setscope等

*** [[http://www.cnblogs.com/youtherhome/archive/2013/03/17/2964195.html][Linux C++的多线程编程]] :blog:LINUX:

**** 引言

*线程（thread）*技术早在60年代就被提出，但真正应用多线程到操作系统中去，是在80年代中期，solaris是这方面的佼佼者。传统的Unix也支持线程的概念，但是在一个*进程（process）*中只允许有一个线程，这样多线程就意味着多进程。现在，多线程技术已经被许多操作系统所支持，包括Windows/NT，当然，也包括Linux。
为什么有了进程的概念后，还要再引入线程呢？使用多线程到底有哪些好处？什么的系统应该选用多线程？我们首先必须回答这些问题。
使用多线程的理由之一是和进程相比，它是一种非常"节俭"的多任务操作方式。我们知道，在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。
使用多线程的理由之二是线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。
除了以上所说的优点外，不和进程比较，多线程程序作为一种多任务、并发的工作方式，当然有以下的优点：
1)
提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time
consuming）置于一个新的线程，可以避免这种尴尬的情况。
2)
使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。
3)
改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。
下面我们先来尝试编写一个简单的多线程程序。

**** 简单的多线程编程

Linux系统下的多线程遵循POSIX线程接口，称为*pthread*。编写Linux下的多线程程序，需要使用头文件pthread.h，连接时需要使用库libpthread.a。顺便说一下，Linux下pthread的实现是通过系统调用clone()来实现的。clone()是Linux所特有的系统调用，它的使用方式类似fork，关于clone()的详细情况，有兴趣的读者可以去查看有关文档说明。下面我们展示一个最简单的多线程程序threads.cpp。

#+BEGIN_EXAMPLE
    //Threads.cpp
    #include <iostream>
    #include <unistd.h>
    #include <pthread.h>
    using namespace std;

    void *thread(void *ptr)
    {
        for(int i = 0;i < 3;i++) {
            sleep(1);
            cout << "This is a pthread." << endl;
        }
        return 0;
    }

    int main() {
        pthread_t id;
        int ret = pthread_create(&id, NULL, thread, NULL);
        if(ret) {
            cout << "Create pthread error!" << endl;
            return 1;
        }
        for(int i = 0;i < 3;i++) {
            cout <<  "This is the main process." << endl;
            sleep(1);
        }
        pthread_join(id, NULL);
        return 0;
    }
#+END_EXAMPLE

我们编译并运行此程序，可以得到如下结果：
This is the main process.
This is a pthread.
This is the main process.
This is the main process.
This is a pthread.
This is a pthread.
再次运行，我们可能得到如下结果：
This is a pthread.
This is the main process.
This is a pthread.
This is the main process.
This is a pthread.
This is the main process.

前后两次结果不一样，这是两个线程争夺CPU资源的结果。上面的示例中，我们使用到了两个函数，pthread_create和pthread_join，并声明了一个pthread_t型的变量。
pthread_t在头文件/usr/include/bits/pthreadtypes.h中定义：

#+BEGIN_EXAMPLE
    typedef unsigned long int pthread_t;
#+END_EXAMPLE

它是一个线程的标识符。函数pthread_create用来创建一个线程，它的原型为：

#+BEGIN_EXAMPLE
    extern int pthread_create __P ((pthread_t *__thread, __const pthread_attr_t *__attr,
    void *(*__start_routine) (void *), void *__arg));
#+END_EXAMPLE

第一个参数为指向线程标识符的指针，第二个参数用来设置线程属性，第三个参数是线程运行函数的起始地址，最后一个参数是运行函数的参数。这里，我们的函数thread不需要参数，所以最后一个参数设为空指针。第二个参数我们也设为空指针，这样将生成默认属性的线程。对线程属性的设定和修改我们将在下一节阐述。当创建线程成功时，函数返回0，若不为0则说明创建线程失败，常见的错误返回代码为EAGAIN和EINVAL。前者表示系统限制创建新的线程，例如线程数目过多了；后者表示第二个参数代表的线程属性值非法。创建线程成功后，新创建的线程则运行参数三和参数四确定的函数，原来的线程则继续运行下一行代码。
函数pthread_join用来等待一个线程的结束。函数原型为：

#+BEGIN_EXAMPLE
    extern int pthread_join __P ((pthread_t __th, void **__thread_return));
#+END_EXAMPLE

第一个参数为被等待的线程标识符，第二个参数为一个用户定义的指针，它可以用来存储被等待线程的返回值。这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回。一个线程的结束有两种途径，一种是象我们上面的例子一样，函数结束了，调用它的线程也就结束了；另一种方式是通过函数pthread_exit来实现。它的函数原型为：

#+BEGIN_EXAMPLE
    extern void pthread_exit __P ((void *__retval)) __attribute__ ((__noreturn__));
#+END_EXAMPLE

唯一的参数是函数的返回代码，只要pthread_join中的第二个参数thread_return不是NULL，这个值将被传递给thread_return。最后要说明的是，一个线程不能被多个线程等待，否则第一个接收到信号的线程成功返回，其余调用pthread_join的线程则返回错误代码ESRCH。
在这一节里，我们编写了一个最简单的线程，并掌握了最常用的三个函数pthread_create，pthread_join和pthread_exit。下面，我们来了解线程的一些常用属性以及如何设置这些属性。

**** 修改线程的属性

在上一节的例子里，我们用pthread_create函数创建了一个线程，在这个线程中，我们使用了默认参数，即将该函数的第二个参数设为NULL。的确，对大多数程序来说，使用默认属性就够了，但我们还是有必要来了解一下线程的有关属性。
属性结构为pthread_attr_t，它同样在头文件/usr/include/pthread.h中定义，喜欢追根问底的人可以自己去查看。属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。属性对象主要包括是否绑定、是否分离、堆栈地址、堆栈大小、优先级。默认的属性为非绑定、非分离、缺省1M的堆栈、与父进程同样级别的优先级。
关于线程的绑定，牵涉到另外一个概念：轻进程（LWP：Light Weight
Process）。轻进程可以理解为内核线程，它位于用户层和系统层之间。系统对线程资源的分配、对线程的控制是通过轻进程来实现的，一个轻进程可以控制一个或多个线程。默认状况下，启动多少轻进程、哪些轻进程来控制哪些线程是由系统来控制的，这种状况即称为非绑定的。绑定状况下，则顾名思义，即某个线程固定的"绑"在一个轻进程之上。被绑定的线程具有较高的响应速度，这是因为CPU时间片的调度是面向轻进程的，绑定的线程可以保证在需要的时候它总有一个轻进程可用。通过设置被绑定的轻进程的优先级和调度级可以使得绑定的线程满足诸如实时反应之类的要求。
设置线程绑定状态的函数为pthread_attr_setscope，它有两个参数，第一个是指向属性结构的指针，第二个是绑定类型，它有两个取值：PTHREAD_SCOPE_SYSTEM（绑定的）和PTHREAD_SCOPE_PROCESS（非绑定的）。下面的代码即创建了一个绑定的线程。

#+BEGIN_EXAMPLE
    #include <pthread.h>
    pthread_attr_t attr;
    pthread_t tid;
    /*初始化属性值，均设为默认值*/
    pthread_attr_init(&attr);
    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
    pthread_create(&tid, &attr, (void *) my_function, NULL);
#+END_EXAMPLE

线程的分离状态决定一个线程以什么样的方式来终止自己。在上面的例子中，我们采用了线程的默认属性，即为非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。设置线程分离状态的函数为pthread_attr_setdetachstate（pthread_attr_t
*attr, int
detachstate）。第二个参数可选为PTHREAD_CREATE_DETACHED（分离线程）和
PTHREAD
_CREATE_JOINABLE（非分离线程）。这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timewait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait（）之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。

另外一个可能常用的属性是线程的优先级，它存放在结构sched_param中。用函数pthread_attr_getschedparam和函数pthread_attr_setschedparam进行存放，一般说来，我们总是先取优先级，对取得的值修改后再存放回去。下面即是一段简单的例子。

#+BEGIN_EXAMPLE
    #include <pthread.h>
    #include <sched.h>
    pthread_attr_t attr;
    pthread_t tid;
    sched_param param;
    int newprio=20;
    pthread_attr_init(&amp;attr);
    pthread_attr_getschedparam(&attr, &param);
    param.sched_priority=newprio;
    pthread_attr_setschedparam(&attr, &param);
    pthread_create(&tid, &attr, (void *)myfunction, myarg);
#+END_EXAMPLE

**** 线程的数据处理
和进程相比，线程的最大优点之一是数据的共享性，各个进程共享父进程处沿袭的数据段，可以方便的获得、修改数据。但这也给多线程编程带来了许多问题。我们必须当心有多个不同的进程访问相同的变量。许多函数是不可重入的，即同时不能运行一个函数的多个拷贝（除非使用不同的数据段）。在函数中声明的静态变量常常带来问题，函数的返回值也会有问题。因为如果返回的是函数内部静态声明的空间的地址，则在一个线程调用该函数得到地址后使用该地址指向的数据时，别的线程可能调用此函数并修改了这一段数据。在进程中共享的变量必须用关键字volatile来定义，这是为了防止编译器在优化时（如gcc中使用-OX参数）改变它们的使用方式。为了保护变量，我们必须使用信号量、互斥等方法来保证我们对变量的正确使用。下面，我们就逐步介绍处理线程数据时的有关知识。

***** 线程数据

在单线程的程序里，有两种基本的数据：全局变量和局部变量。但在多线程程序里，还有第三种数据类型：线程数据（TSD:
Thread-Specific
Data）。它和全局变量很象，在线程内部，各个函数可以象使用全局变量一样调用它，但它对线程外部的其它线程是不可见的。这种数据的必要性是显而易见的。例如我们常见的变量errno，它返回标准的出错信息。它显然不能是一个局部变量，几乎每个函数都应该可以调用它；但它又不能是一个全局变量，否则在A线程里输出的很可能是B线程的出错信息。要实现诸如此类的变量，我们就必须使用线程数据。我们为每个线程数据创建一个键，它和这个键相关联，在各个线程里，都使用这个键来指代线程数据，但在不同的线程里，这个键代表的数据是不同的，在同一个线程里，它代表同样的数据内容。
和线程数据相关的函数主要有4个：创建一个键；为一个键指定线程数据；从一个键读取线程数据；删除键。
创建键的函数原型为：

#+BEGIN_EXAMPLE
    extern int pthread_key_create __P ((pthread_key_t *__key,void (*__destr_function) (void *)));
#+END_EXAMPLE

第一个参数为指向一个键值的指针，第二个参数指明了一个destructor函数，如果这个参数不为空，那么当每个线程结束时，系统将调用这个函数来释放绑定在这个键上的内存块。这个函数常和函数pthread_once
((pthread_once_t*once_control, void (*initroutine)
(void)))一起使用，为了让这个键只被创建一次。函数pthread_once声明一个初始化函数，第一次调用pthread_once时它执行这个函数，以后的调用将被它忽略。

在下面的例子中，我们创建一个键，并将它和某个数据相关联。我们要定义一个函数createWindow，这个函数定义一个图形窗口（数据类型为Fl_Window
*，这是图形界面开发工具FLTK中的数据类型）。由于各个线程都会调用这个函数，所以我们使用线程数据。

#+BEGIN_EXAMPLE
    /* 声明一个键*/
    pthread_key_t myWinKey;
    /* 函数 createWindow */
    void createWindow ( void ) {
        Fl_Window * win;
        static pthread_once_t once= PTHREAD_ONCE_INIT;
        /* 调用函数createMyKey，创建键*/
        pthread_once ( & once, createMyKey) ;
        /*win指向一个新建立的窗口*/
        win=new Fl_Window( 0, 0, 100, 100, "MyWindow");
        /* 对此窗口作一些可能的设置工作，如大小、位置、名称等*/
        setWindow(win);
        /* 将窗口指针值绑定在键myWinKey上*/
        pthread_setpecific ( myWinKey, win);
    }

    /* 函数 createMyKey，创建一个键，并指定了destructor */
    void createMyKey ( void ) {
        pthread_keycreate(&myWinKey, freeWinKey);
    }

    /* 函数 freeWinKey，释放空间*/
    void freeWinKey ( Fl_Window * win){
        delete win;
    }
#+END_EXAMPLE

这样，在不同的线程中调用函数createMyWin，都可以得到在线程内部均可见的窗口变量，这个变量通过函数pthread_getspecific得到。在上面的例子中，我们已经使用了函数pthread_setspecific来将线程数据和一个键绑定在一起。这两个函数的原型如下：

#+BEGIN_EXAMPLE
    extern int pthread_setspecific __P ((pthread_key_t __key,__const void *__pointer));
    extern void *pthread_getspecific __P ((pthread_key_t __key));
#+END_EXAMPLE

这两个函数的参数意义和使用方法是显而易见的。要注意的是，用pthread_setspecific为一个键指定新的线程数据时，必须自己释放原有的线程数据以回收空间。这个过程函数pthread_key_delete用来删除一个键，这个键占用的内存将被释放，但同样要注意的是，它只释放键占用的内存，并不释放该键关联的线程数据所占用的内存资源，而且它也不会触发函数pthread_key_create中定义的destructor函数。线程数据的释放必须在释放键之前完成。



***** 互斥锁

互斥锁用来保证一段时间内只有一个线程在执行一段代码。必要性显而易见：假设各个线程向同一个文件顺序写入数据，最后得到的结果一定是灾难性的。
我们先看下面一段代码。这是一个读/写程序，它们公用一个缓冲区，并且我们假定一个缓冲区只能保存一条信息。即缓冲区只有两个状态：有信息或没有信息。

#+BEGIN_EXAMPLE
    void reader_function ( void );
    void writer_function ( void );
    char buffer;
    int buffer_has_item=0;
    pthread_mutex_t mutex;
    struct timespec delay;

    void main ( void ){
        pthread_t reader;
        /* 定义延迟时间*/
        delay.tv_sec = 2;
        delay.tv_nec = 0;
        /* 用默认属性初始化一个互斥锁对象*/
        pthread_mutex_init (&mutex,NULL);
        pthread_create(&reader, pthread_attr_default, (void *)&reader_function), NULL);
        writer_function( );
    }

    void writer_function (void){
        while(1){
            /* 锁定互斥锁*/
            pthread_mutex_lock (&mutex);
            if (buffer_has_item==0){
                buffer=make_new_item( );
                buffer_has_item=1;
            }
            /* 打开互斥锁*/
            pthread_mutex_unlock(&mutex);
            pthread_delay_np(&delay);
        }
    }

    void reader_function(void){
        while(1){
            pthread_mutex_lock(&mutex);
            if(buffer_has_item==1){
                consume_item(buffer);
                buffer_has_item=0;
            }
            pthread_mutex_unlock(&mutex);
            pthread_delay_np(&delay);
        }
    }
#+END_EXAMPLE

这里声明了互斥锁变量mutex，结构pthread_mutex_t为不公开的数据类型，其中包含一个系统分配的属性对象。函数pthread_mutex_init用来生成一个互斥锁。NULL参数表明使用默认属性。如果需要声明特定属性的互斥锁，须调用函数pthread_mutexattr_init。函数pthread_mutexattr_setpshared和函数pthread_mutexattr_settype用来设置互斥锁属性。前一个函数设置属性pshared，它有两个取值，PTHREAD_PROCESS_PRIVATE和PTHREAD_PROCESS_SHARED。前者用来不同进程中的线程同步，后者用于同步本进程的不同线程。在上面的例子中，我们使用的是默认属性PTHREAD_PROCESS_
PRIVATE。后者用来设置互斥锁类型，可选的类型有PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE和PTHREAD
_MUTEX_DEFAULT。它们分别定义了不同的上锁、解锁机制，一般情况下，选用最后一个默认属性。
pthread_mutex_lock声明开始用互斥锁上锁，此后的代码直至调用pthread_mutex_unlock为止，均被上锁，即同一时间只能被一个线程调用执行。当一个线程执行到pthread_mutex_lock处时，如果该锁此时被另一个线程使用，那此线程被阻塞，即程序将等待到另一个线程释放此互斥锁。在上面的例子中，我们使用了pthread_delay_np函数，让线程睡眠一段时间，就是为了防止一个线程始终占据此函数。
上面的例子非常简单，就不再介绍了，需要提出的是在使用互斥锁的过程中很有可能会出现死锁：两个线程试图同时占用两个资源，并按不同的次序锁定相应的互斥锁，例如两个线程都需要锁定互斥锁1和互斥锁2，a线程先锁定互斥锁1，b线程先锁定互斥锁2，这时就出现了死锁。此时我们可以使用函数pthread_mutex_trylock，它是函数pthread_mutex_lock的非阻塞版本，当它发现死锁不可避免时，它会返回相应的信息，程序员可以针对死锁做出相应的处理。另外不同的互斥锁类型对死锁的处理不一样，但最主要的还是要程序员自己在程序设计注意这一点。

***** 条件变量

前一节中我们讲述了如何使用互斥锁来实现线程间数据的共享和通信，互斥锁一
个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞
和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起使用。
使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的
互斥锁并等待条件发生变化。一旦其它的某个线程改变了条件变量，它将通知相
应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定
互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线承间的同步。

条件变量的结构为pthread_cond_t，函数pthread_cond_init（）被用来初始化
一个条件变量。它的原型为：


#+BEGIN_EXAMPLE
    extern int pthread_cond_init __P ((pthread_cond_t *__cond,__const pthread_condattr_t *__cond_attr));
#+END_EXAMPLE

其中cond是一个指向结构pthread_cond_t的指针，cond_attr是一个指向结构pthread_condattr_t的指针。结构pthread_condattr_t是条件变量的属性结构，和互斥锁一样我们可以用它来设置条件变量是进程内可用还是进程间可用，默认值是PTHREAD_
PROCESS_PRIVATE，即此条件变量被同一进程内的各个线程使用。注意初始化条件变量只有未被使用时才能重新初始化或被释放。释放一个条件变量的函数为pthread_cond_
destroy（pthread_cond_t cond）。　
函数pthread_cond_wait（）使线程阻塞在一个条件变量上。

它的函数原型为：

#+BEGIN_EXAMPLE
    extern int pthread_cond_wait __P ((pthread_cond_t *__cond,
    pthread_mutex_t *__mutex));
#+END_EXAMPLE

线程解开mutex指向的锁并被条件变量cond阻塞。线程可以被函数pthread_cond_signal和函数pthread_cond_broadcast唤醒，但是要注意的是，条件变量只是起阻塞和唤醒线程的作用，具体的判断条件还需用户给出，例如一个变量是否为0等等，这一点我们从后面的例子中可以看到。线程被唤醒后，它将重新检查判断条件是否满足，如果还不满足，一般说来线程应该仍阻塞在这里，被等待被下一次唤醒。这个过程一般用while语句实现。
另一个用来阻塞线程的函数是pthread_cond_timedwait()，它的原型为：

#+BEGIN_EXAMPLE
    extern int pthread_cond_timedwait __P ((pthread_cond_t *__cond,
    pthread_mutex_t *__mutex, __const struct timespec *__abstime));
#+END_EXAMPLE

它比函数pthread_cond_wait()多了一个时间参数，经历abstime段时间后，即使条件变量不满足，阻塞也被解除。
函数pthread_cond_signal()的原型为：
extern int pthread_cond_signal __P ((pthread_cond_t
*__cond));
它用来释放被阻塞在条件变量cond上的一个线程。多个线程阻塞在此条件变量上时，哪一个线程被唤醒是由线程的调度策略所决定的。要注意的是，必须用保护条件变量的互斥锁来保护这个函数，否则条件满足信号又可能在测试条件和调用pthread_cond_wait函数之间被发出，从而造成无限制的等待。下面是使用函数pthread_cond_wait()和函数

#+BEGIN_EXAMPLE
    pthread_cond_signal()的一个简单的例子。
    pthread_mutex_t count_lock;
    pthread_cond_t count_nonzero;
    unsigned count;
    decrement_count () {
        pthread_mutex_lock (&count_lock);
        while(count==0)
            pthread_cond_wait( &count_nonzero, &count_lock);
        count=count -1;
        pthread_mutex_unlock (&count_lock);
    }

    increment_count(){
        pthread_mutex_lock(&count_lock);
        if(count==0)
            pthread_cond_signal(&count_nonzero);
        count=count+1;
        pthread_mutex_unlock(&count_lock);
    }
#+END_EXAMPLE

count值为0时，decrement函数在pthread_cond_wait处被阻塞，并打开互斥锁count_lock。此时，当调用到函数increment_count时，pthread_cond_signal（）函数改变条件变量，告知decrement_count（）停止阻塞。读者可以试着让两个线程分别运行这两个函数，看看会出现什么样的结果。
函数pthread_cond_broadcast（pthread_cond_t
*cond）用来唤醒所有被阻塞在条件变量cond上的线程。这些线程被唤醒后将再次竞争相应的互斥锁，所以必须小心使用这个函数。


***** 信号量
信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。当公共资源增加时，调用函数sem_post（）增加信号量。只有当信号量值大于０时，才能使用公共资源，使用后，函数sem_wait（）减少信号量。函数sem_trywait（）和函数pthread_
mutex_trylock（）起同样的作用，它是函数sem_wait（）的非阻塞版本。下面我们逐个介绍和信号量有关的一些函数，它们都在头文件/usr/include/semaphore.h中定义。
信号量的数据类型为结构sem_t，它本质上是一个长整型的数。函数sem_init（）用来初始化一个信号量。它的原型为：
extern int sem_init __P ((sem_t *__sem, int __pshared,
unsigned int __value));
sem为指向信号量结构的一个指针；pshared不为０时此信号量在进程间共享，否则只能为当前进程的所有线程共享；value给出了信号量的初始值。
函数sem_post( sem_t *sem
)用来增加信号量的值。当有线程阻塞在这个信号量上时，调用这个函数会使其中的一个线程不在阻塞，选择机制同样是由线程的调度策略决定的。
函数sem_wait( sem_t *sem
)被用来阻塞当前线程直到信号量sem的值大于0，解除阻塞后将sem的值减一，表明公共资源经使用后减少。函数sem_trywait
( sem_t *sem
)是函数sem_wait（）的非阻塞版本，它直接将信号量sem的值减一。
函数sem_destroy(sem_t *sem)用来释放信号量sem。
下面我们来看一个使用信号量的例子。在这个例子中，一共有4个线程，其中两个线程负责从文件读取数据到公共的缓冲区，另两个线程从缓冲区读取数据作不同的处理（加和乘运算）。

#+BEGIN_EXAMPLE
    /* File sem.c */
    #include <stdio.h>
    #include <pthread.h>
    #include <semaphore.h>
    #define MAXSTACK 100
    int stack[MAXSTACK][2];
    int size=0;
    sem_t sem;

    /* 从文件1.dat读取数据，每读一次，信号量加一*/
    void ReadData1(void){
        FILE *fp=fopen("1.dat","r");
        while(!feof(fp)){
            fscanf(fp,"%d %d",&stack[size][0],&stack[size][1]);
            sem_post(&sem);
            ++size;
        }
        fclose(fp);
    }

    /*从文件2.dat读取数据*/
    void ReadData2(void){
        FILE *fp=fopen("2.dat","r");
        while(!feof(fp)){
            fscanf(fp,"%d %d",&stack[size][0],&stack[size][1]);
            sem_post(&sem);
            ++size;
        }
        fclose(fp);
    }
    /*阻塞等待缓冲区有数据，读取数据后，释放空间，继续等待*/
    void HandleData1(void){
        while(1){
            sem_wait(&sem);
            printf("Plus:%d+%d=%d\n",stack[size][0],stack[size][1],
            stack[size][0]+stack[size][1]);
            --size;
        }
    }

    void HandleData2(void){
        while(1){
            sem_wait(&sem);
            printf("Multiply:%d*%d=%d\n",stack[size][0],stack[size][1],
            stack[size][0]*stack[size][1]);
            --size;
        }
    }

    int main(void){
        pthread_t t1,t2,t3,t4;
        sem_init(&sem,0,0);
        pthread_create(&t1,NULL,(void *)HandleData1,NULL);
        pthread_create(&t2,NULL,(void *)HandleData2,NULL);
        pthread_create(&t3,NULL,(void *)ReadData1,NULL);
        pthread_create(&t4,NULL,(void *)ReadData2,NULL);
        /* 防止程序过早退出，让它在此无限期等待*/
        pthread_join(t1,NULL);
    }
#+END_EXAMPLE

在Linux下，我们用命令gcc -lpthread sem.c -o sem生成可执行文件sem。
我们事先编辑好数据文件1.dat和2.dat，假设它们的内容分别为1 2 3 4 5 6 7 8
9 10和 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 ，我们运行sem，得到如下的结果：
Multiply:-1*-2=2
Plus:-1+-2=-3
Multiply:9*10=90
Plus:-9+-10=-19
Multiply:-7*-8=56
Plus:-5+-6=-11
Multiply:-3*-4=12
Plus:9+10=19
Plus:7+8=15
Plus:5+6=11

从中我们可以看出各个线程间的竞争关系。而数值并未按我们原先的顺序显示出
来这是由于size这个数值被各个线程任意修改的缘故。这也往往是多线程编程要
注意的问题。

**** 小结

多线程编程是一个很有意思也很有用的技术，使用多线程技术的网络蚂蚁是目前
最常用的下载工具之一，使用多线程技术的grep比单线程的grep要快上几倍，类
似的例子还有很多。希望大家能用多线程技术写出高效实用的好程序来。

*** [[http://www.cnblogs.com/finlay/p/pthread_create%e6%9c%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e5%bc%95%e7%94%a8.html][编译 Linux 程序出现“对‘pthread_create'未定义的引用”]] :blog:pthread:error:

在学习Linux程序设计POXIS线程的时候，编译一个段简单的代码，就出现下面的错误：

#+BEGIN_EXAMPLE
    1 /tmp/cc2FQJTh.o：在函数‘main’中：
    2 1-thread.c:(.text+0x29)：对‘pthread_create’未定义的引用
    3 1-thread.c:(.text+0x67)：对‘pthread_join’未定义的引用
    4 collect2: 错误： ld 返回 1
#+END_EXAMPLE

可是在我的代码中已经包含了pthread.h，这是什么回事呢，百度一下，*发现网
上大部分的解决办法是在gcc编译命令加上选项：lpthread。*

#+BEGIN_EXAMPLE
    1 gcc -o pthread -lpthread pthread.c
#+END_EXAMPLE

但我照着网上的方法试试，发现还是不行，错误提示与原来相同。后来才发现是
我自己错了，我是在目标代码文件前加上-lpthread。但实际的做法应该是在代
码文件后面添加次选项。

#+BEGIN_EXAMPLE
    1 finlay@finlay-Lenovo-G470:~/文档/程序设计/Linux程序设计/12章$ gcc 1-thread.c -lpthread
    2 #成功！
    3 finlay@finlay-Lenovo-G470:~/文档/程序设计/Linux程序设计/12章$ gcc -lpthread -Wall 1-thread.c
    4 #失败！
    5 /tmp/ccE6dosW.o：在函数‘main’中：
    6 1-thread.c:(.text+0x29)：对‘pthread_create’未定义的引用
    7 1-thread.c:(.text+0x67)：对‘pthread_join’未定义的引用
    8 collect2: 错误： ld 返回 1
#+END_EXAMPLE

但是还有一个什么有趣的现象，如下：

#+BEGIN_EXAMPLE
    1 finlay@finlay-Lenovo-G470:~/文档/程序设计/Linux程序设计/12章$ gcc -pthread 1-thread.c
    2 #成功！
    3 finlay@finlay-Lenovo-G470:~/文档/程序设计/Linux程序设计/12章$ gcc -lpthread 1-thread.c
    4 #失败！
    5 /tmp/ccbr6m7v.o：在函数‘main’中：
    6 1-thread.c:(.text+0x29)：对‘pthread_create’未定义的引用
    7 1-thread.c:(.text+0x67)：对‘pthread_join’未定义的引用
    8 collect2: 错误： ld 返回 1
#+END_EXAMPLE

那么，-pthread与-lpthread的区别是什么呢？我们可以在verbose模式下执行一
下对应的gcc命令行看出来。下面是老式的直接加

-lpthread 链接选项的输出结果：

#+BEGIN_EXAMPLE
    $ gcc -v -c x.c
    ...
    /usr/lib/gcc/i486-linux-gnu/4.2.4/cc1 -quiet -v x.c -quiet -dumpbase x.c
    -mtune=generic -auxbase x -version -fstack-protector -fstack-protector -o /tmp/cch4ASTF.s
    ...
    as --traditional-format -V -Qy -o x.o /tmp/cch4ASTF.s
    ...
    $ gcc -v x.o -ox -lpthread
    ...
     /usr/lib/gcc/i486-linux-gnu/4.2.4/collect2 --eh-frame-hdr -m elf_i386 --hash-style=both
    -dynamic-linker /lib/ld-linux.so.2 -ox
    /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crt1.o
    /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crti.o
    /usr/lib/gcc/i486-linux-gnu/4.2.4/crtbegin.o
    -L/opt/intel/Compiler/11.1/046/tbb/ia32/cc4.1.0_libc2.4_kernel2.6.16.21/lib/../lib
    -L/usr/lib/gcc/i486-linux-gnu/4.2.4
    -L/usr/lib/gcc/i486-linux-gnu/4.2.4
    -L/usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib
    -L/lib/../lib
    -L/usr/lib/../lib
    -L/opt/intel/Compiler/11.1/046/lib/ia32
    -L/opt/intel/Compiler/11.1/046/tbb/ia32/cc4.1.0_libc2.4_kernel2.6.16.21/lib
    -L/usr/lib/gcc/i486-linux-gnu/4.2.4/../../..
    x.o -lpthread -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc
    --as-needed -lgcc_s --no-as-needed
    /usr/lib/gcc/i486-linux-gnu/4.2.4/crtend.o /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crtn.o
#+END_EXAMPLE

下面是在编译和链接时分别指定 -pthread 选项的输出结果：

#+BEGIN_EXAMPLE
     1 $ gcc -v -pthread -c x.c
     2 ...
     3 /usr/lib/gcc/i486-linux-gnu/4.2.4/cc1 -quiet -v <strong>-D_REENTRANT</strong>
     4  x.c -quiet -dumpbase x.c
     5 -mtune=generic -auxbase x -version -fstack-protector -fstack-protector -o /tmp/cc205IQf.s
     6 ...
     7 as --traditional-format -V -Qy -o x.o /tmp/cc205IQf.s
     8 ...
     9 $ gcc -v x.o -ox -pthread
    10 /usr/lib/gcc/i486-linux-gnu/4.2.4/collect2 --eh-frame-hdr -m elf_i386 --hash-style=both
    11 -dynamic-linker /lib/ld-linux.so.2 -ox
    12 /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crt1.o
    13 /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crti.o
    14 /usr/lib/gcc/i486-linux-gnu/4.2.4/crtbegin.o
    15 -L/opt/intel/Compiler/11.1/046/tbb/ia32/cc4.1.0_libc2.4_kernel2.6.16.21/lib/../lib
    16 -L/usr/lib/gcc/i486-linux-gnu/4.2.4
    17 -L/usr/lib/gcc/i486-linux-gnu/4.2.4
    18 -L/usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib
    19 -L/lib/../lib
    20 -L/usr/lib/../lib
    21 -L/opt/intel/Compiler/11.1/046/lib/ia32
    22 -L/opt/intel/Compiler/11.1/046/tbb/ia32/cc4.1.0_libc2.4_kernel2.6.16.21/lib
    23 -L/usr/lib/gcc/i486-linux-gnu/4.2.4/../../..
    24 x.o -lgcc --as-needed -lgcc_s --no-as-needed <strong>-lpthread</strong>
    25  -lc -lgcc
    26 --as-needed -lgcc_s --no-as-needed
    27 /usr/lib/gcc/i486-linux-gnu/4.2.4/crtend.o /usr/lib/gcc/i486-linux-gnu/4.2.4/../../../../lib/crtn.o
#+END_EXAMPLE

所以可见编译选项中指定 -pthread
会附加一个宏定义 *-D_REENTRANT* ，该宏会导致 libc
头文件选择那些thread-safe的实现；链接选项中指定 -pthread 则同 -lpthread
一样，只表示链接 POSIX thread 库。由于 libc 用于适应 thread-safe
的宏定义可能变化，因此在编译和链接时都使用 -pthread 选项而不是传统的
-lpthread 能够保持向后兼容，并提高命令行的一致性。

** Class                                                             :class:
*** [[http://blog.csdn.net/starlee/article/details/619827][C++中虚析构函数的作用]] :blog:virtual:

我们知道，用C++开发的时候，用来做基类的类的析构函数一般都是虚函数。可
是，为什么要这样做呢？下面用一个小例子来说明：

有下面的两个类：

#+BEGIN_SRC cpp
class ClxBase
{
public:
 ClxBase() {};
 virtual ~ClxBase() {};

 virtual void DoSomething() { cout << "Do something in class ClxBase!" << endl; };
};

class ClxDerived : public ClxBase
{
public:
 ClxDerived() {};
 ~ClxDerived() { cout << "Output from the destructor of class ClxDerived!" << endl; };

 void DoSomething() { cout << "Do something in class ClxDerived!" << endl; };
};

#+END_SRC

代码

#+BEGIN_SRC cpp
ClxBase *pTest = new ClxDerived;
pTest->DoSomething();
delete pTest;
#+END_SRC


的输出结果是：

#+BEGIN_EXAMPLE
Do something in class ClxDerived!
Output from the destructor of class ClxDerived!
#+END_EXAMPLE

这个很简单，非常好理解。

但是，如果把类ClxBase析构函数前的virtual去掉，那输出结果就是下面的样子了：

#+BEGIN_EXAMPLE
Do something in class ClxDerived!
#+END_EXAMPLE

也就是说，类ClxDerived的析构函数根本没有被调用！一般情况下类的析构函数
里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。我想所有
的C++程序员都知道这样的危险性。当然，如果在析构函数中做了其他工作的话，
那你的所有努力也都是白费力气。

所以，文章开头的那个问题的答案就是－－这样做是为了当用一个基类的指针删
除一个派生类的对象时，派生类的析构函数会被调用。

当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时
候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类
的存储空间。所以，只有当一个类被用来作为基类的时候，才把析构函数写成虚
函数。

*** 虚析构函数
#+begin_latex
\begin{cpp}
#include <iostream>

class Base{
public:
  Base(){};
  ~Base(){};
  virtual void do_something(){std::cout << "Do something in class Base" << std::endl;
  }
};

class Derived: public Base
{
public:
  Derived(){};
  ~Derived(){std::cout << "Output from the destructor of class Derived" << std::endl;}

  void do_something(){std::cout << "do something in class Derived" << std::endl; }
};


int main(int argc, char *argv[])
{
  Base *pTest = new Derived;	// 指向派生类对象的基类指针
  pTest->do_something();
  delete pTest;			// 必须的，不然不会释放资源，也不会调用析构函数
  return 0;
}

\end{cpp}
#+end_latex

1. output
   do something in class Derived
   Output from the destructor of class Derived

2. 改为 Derived *pTest = new Derived;
   do something in class Derived
   Output from the destructor of class Derived

3. 去掉delete pTest
   do something in class Derived

4. *去掉基类析构函数的virtual*
   do something in class Derived


所以虚析构函数的作用是为了 *当用一个基类的指针删除派生类对象时，派生类
的析构函数会被调用*

当类里有虚函数时，编译器会给类添加一个 *虚函数表* ， 里面用来存放 *虚
函数指针* ， 这样会增加类的存储空间。 因而，只有当一个类 *被用作为基
类* 时，才把析构函数写成虚函数。


参考：[[http://blog.csdn.net/starlee/article/details/619827]]

** Array                                                             :array:
*** [[http://blog.sina.com.cn/s/blog_6f26189101012111.html][C++中如何使函数返回数组]] :blog:

在C++中，数组不是一种类型，因此不能被直接返回。一般有两种方法来返回一个数组。

1. 返回一个指向数组的指针

 #include<iostream>
 using namespace std;

int* Array()
 {
  int *a;
  a=new int [10];

 for(int i=0;i<10;i++)
  {
  a[i]=i+1;
   cout<<a[i]<<" ";
  }
  cout<<endl;
  return a;
 }

void main()
 {
  int *b;
  b=Array();

  for(int i=0;i<10;i++)
  cout<<b[i]<<" ";
   cout<<endl;
 }

2.
返回一个结构的形式。这种形式相对较安全，可以避免忘记释放指针而造成内存泄露，也可以避免访问悬挂指针造成的错误。但缺点是由于结构是先拷贝再返回，因此如果结构较大时，会影响效率和占用较大内存。

 #include<iostream>
 using namespace std;
 class tag
 {
   public:
  int a[10];
 }X;

class tag Array()
 {
  for(int i=0;i<10;i++)
  {
  X.a[i]=i+1;
   cout<<X.a[i]<<" ";
  }
  cout<<endl;
  return X;
 }

void main()
 {
  class tag Y=Array();
  for(int i=0;i<10;i++)
  {
   cout<<Y.a[i]<<" ";
  }
   cout<<endl;
 }

*** [[http://www.cnblogs.com/yangxi/archive/2011/09/18/2180759.html][怎样让函数返回数组]] :blog:

这个问题属于非常初级的问题，但是对于初学不知道的人可能会比较头疼。C++中函数是不能直接返回一个数组的，但是数组其实就是指针，所以可以让函数返回指针来实现。比如一个矩阵相乘的函数，很容易地我们就写成：

#+BEGIN_EXAMPLE
     1 #include <iostream> 2  3 using namespace std; 4  5 float* MultMatrix(float A[4], float B[4]) 6 { 7     float M[4]; 8     M[0] = A[0]*B[0] + A[1]*B[2]; 9     M[1] = A[0]*B[1] + A[1]*B[3];10     M[2] = A[2]*B[0] + A[3]*B[2];11     M[3] = A[2]*B[1] + A[3]*B[3];12 13     return M;14 }15 16 int main()17 {18     float A[4] = { 1.75, 0.66, 0, 1.75 };19     float B[4] = {1, 1, 0, 0};20     float *M = MultMatrix(A, B);21     cout << M[0] << " " << M[1] << endl;22     cout << M[2] << " " << M[3] << endl;23 24     return 0;25 }
#+END_EXAMPLE

但是运行后发现结果是：1.75 1.75
  6.51468e-039 3.76489e-039

根本不是想要的结果。于是我们在函数中也加上显示代码，看看是不是计算的问题，得到结果：

1.75 1.75
0 0
1.75 1.75
1.96875 1.75

发现计算的结果是正确的，但返回后就变了，而且跟上次的结果不一样。这是为什么呢？

因为在函数中定义的数组M在函数执行完后已经被系统释放掉了，所以在调用函数中得到的结果当然不是计算后的结果。有一个解决办法就是动态分配内存，在函数中new一个数组，这样就不会被释放掉了。

于是就应该将

7 　　 float M[4];

改为：

7　　float *M = new float[4];

修改运行后得到结果：

1.75 1.75
0 0
1.75 1.75
0 0

正确。但是我们这样并没有将自己申请的空间释放掉，如果我们在函数内释放的话结果就会跟开始时的一样了。

看看我们的调用代码：

20 　　 float *M = MultMatrix(A, B);

这样其实是将M指针指向了函数中M数组的首地址，我们可以将M指针释放，效果和释放申请的M数组是一样的，因为它们指向的是同一片内存空间。于是代码就修改为：

#+BEGIN_EXAMPLE
     1 #include <iostream> 2  3 using namespace std; 4  5 float* MultMatrix(float A[4], float B[4]) 6 { 7     float *M = new float[4]; 8     M[0] = A[0]*B[0] + A[1]*B[2]; 9     M[1] = A[0]*B[1] + A[1]*B[3];10     M[2] = A[2]*B[0] + A[3]*B[2];11     M[3] = A[2]*B[1] + A[3]*B[3];12     cout << M[0] << " " << M[1] << endl;13     cout << M[2] << " " << M[3] << endl;14 15     return M;16 }17 18 int main()19 {20     float A[4] = { 1.75, 0.66, 0, 1.75 };21     float B[4] = {1, 1, 0, 0};22     float *M = MultMatrix(A, B);23     cout << M[0] << " " << M[1] << endl;24     cout << M[2] << " " << M[3] << endl;25     delete[] M;26 27     return 0;28 }
#+END_EXAMPLE

运行结果：

1.75 1.75
0 0
1.75 1.75
0 0
没有问题，new的空间也delete掉了。

鉴于下面大牛们的建议，我将程序修改如下，大家看可否：

#+BEGIN_EXAMPLE
     1 #include <iostream> 2  3 using namespace std; 4  5 void MultMatrix(float M[4], float A[4], float B[4]) 6 { 7     M[0] = A[0]*B[0] + A[1]*B[2]; 8     M[1] = A[0]*B[1] + A[1]*B[3]; 9     M[2] = A[2]*B[0] + A[3]*B[2];10     M[3] = A[2]*B[1] + A[3]*B[3];11 12     cout << M[0] << " " << M[1] << endl;13     cout << M[2] << " " << M[3] << endl;14 }15 16 int main()17 {18     float A[4] = { 1.75, 0.66, 0, 1.75 };19     float B[4] = {1, 1, 0, 0};20 21     float *M = new float[4];22     MultMatrix(M, A, B);23 24     cout << M[0] << " " << M[1] << endl;25     cout << M[2] << " " << M[3] << endl;26     delete[] M;27 28     return 0;29 }
#+END_EXAMPLE

至于数组类和智能智能我还需要继续学习，多谢大家关注！

** Point                                                             :point:
*** [[http://blog.chinaunix.net/uid-23860671-id-150499.html][常指针和指向常量的指针 ]] :blog:

1 常量指针！如 int b, c; int * const a = &b;

表示a是一个常量指针它指向变量b的内存。但是因为是常量指针所以不能再用a
指向其他变量，如 a = &c; 错误！可以修改指向内存的值，如:*a = 20; BTW
常量指针声明的时候必须向我那样赋初值。


2 指向常量的指针！如 int b, c; int const *a; a = &b; a = &c;

都可以，唯独它指向的内存不能被修改。如：*a=20;这是违法的！错误！

这就是主要区别！

BTW 还有一个记住他们不同形式的技巧！看const关键字，他后面的不可修改，
如int * const a = &b; 后面是a,则说明a不能修改！

int const * a = &b;后面是*a则说明*a不可被修改！

在好多书上或MSDN是经常用 const int a=5;
int b=6;
const int *p=&b;

其实 const int* 和int const* 一样，就是常指针 也就是它所指向的数据（在
这是int）是常量，它自己的数据类型是const int*

还有const int *p=&b;是可以的 虽然b不是常量。

但是  const int a=6;
      int *p=&a;
会报错，因为它消除了a的const属性


*******我们可以总结一下********

1.  对于常量（符号常量）和常指针、常引用常对象声明都是一样的

定义格式： *const 数据类型  常量名=常量值；*
或  *数据类型 const 常量名=常量值；*

例如：

const int a=7; 或 int const a=7;（符号常量）
int b=5;
const int *p=&b;  或 int const *p=&b;(常指针）
const int &m=b;（常引用）
const Point pt; 或 Point const pt; //常对象不能更新

常指针和常引用在功能上有所限制，就是不能通过他们更改其指向的变量的数据（值）

2. 指针常量

定义格式： *数据类型 *const 指针常量=常量值；*
如char ch,*const pch=&ch;(我是一步完成的，你也可以分开）
也就是说这个指针本身是个常量，不可改变，即它所指向的地址是固定的。但，ch是可以改变的。

补充：

如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改
变，就应使用常引用。常引用声明方式：const 类型标识符 &引用名=目标变量
名；

例1

#+BEGIN_EXAMPLE
int a ;
const int &ra=a;
ra=1; //错误
a=1; //正确
#+END_EXAMPLE

例2

#+BEGIN_EXAMPLE
string foo( );
void bar(string & s);
#+END_EXAMPLE

那么下面的表达式将是非法的：

#+BEGIN_EXAMPLE
bar(foo( ));
bar("hello world");
#+END_EXAMPLE

原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临
时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转
换为非const类型，这是非法的。

引用型参数应该在能被定义为const的情况下，尽量定义为const 。

*** [[http://www.cnblogs.com/gmh915/archive/2010/06/11/1756067.html][指针函数与函数指针的区别]] :blog:function:

一、

在学习arm过程中发现这“指针函数”与“函数指针”容易搞错，所以今天，我自己想一次把它搞清楚，找了一些资料，首先它们之间的定义：

1、指针函数是指带指针的函数，即本质是一个函数。函数返回类型是某一类型的指针

  类型标识符  *函数名(参数表)

  int *f(x，y);



首先它是一个函数，只不过这个函数的返回值是一个地址值。函数返回值必须用同类型的指针变量来接受，也就是说，指针函数一定有函数返回值，而且，在主调函数中，函数返回值必须赋给同类型的指针变量。

表示：

float *fun();

float *p;

p = fun(a);

注意指针函数与函数指针表示方法的不同，千万不要混淆。最简单的辨别方式就是看函数名前面的指针*号有没有被括号（）包含，如果被包含就是函数指针，反之则是指针函数。

来讲详细一些吧！请看下面

 指针函数：
 当一个函数声明其返回值为一个指针时，实际上就是返回一个地址给调用函数，以用于需要指针或地址的表达式中。
 格式：
 类型说明符 * 函数名(参数)
 当然了，由于返回的是一个地址，所以类型说明符一般都是int。
 例如：int *GetDate();
 int * aaa(int,int);
 函数返回的是一个地址值，经常使用在返回数组的某一元素地址上。

 int * GetDate(int wk,int dy);

 main()
 {
 int wk,dy;
 do
 {
 printf(Enter week(1-5)day(1-7)\n);
 scanf(%d%d,&wk,&dy);
 }
 while(wk<1||wk>5||dy<1||dy>7);
 printf(%d\n,*GetDate(wk,dy));
 }

 int * GetDate(int wk,int dy)
 {
 static int calendar[5][7]=
 {
 {1,2,3,4,5,6,7},
 {8,9,10,11,12,13,14},
 {15,16,17,18,19,20,21},
 {22,23,24,25,26,27,28},
 {29,30,31,-1}
 };
 return &calendar[wk-1][dy-1];
 }
 程序应该是很好理解的，子函数返回的是数组某元素的地址。输出的是这个地址里的值。







2、函数指针是指向函数的指针变量，即本质是一个指针变量。

int (*f) (int x); /* 声明一个函数指针 */

f=func; /* 将func函数的首地址赋给指针f */



指向函数的指针包含了函数的地址，可以通过它来调用函数。声明格式如下：
 类型说明符 (*函数名)(参数)
 其实这里不能称为函数名，应该叫做指针的变量名。这个特殊的指针指向一个返回整型值的函数。指针的声明笔削和它指向函数的声明保持一致。
 指针名和指针运算符外面的括号改变了默认的运算符优先级。如果没有圆括号，就变成了一个返回整型指针的函数的原型声明。
 例如：
 void (*fptr)();
 把函数的地址赋值给函数指针，可以采用下面两种形式：
 fptr=&Function;
 fptr=Function;
 取地址运算符&不是必需的，因为单单一个函数标识符就标号表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。
 可以采用如下两种方式来通过指针调用函数：
 x=(*fptr)();
 x=fptr();
 第二种格式看上去和函数调用无异。但是有些程序员倾向于使用第一种格式，因为它明确指出是通过指针而非函数名来调用函数的。下面举一个例子：

 void (*funcp)();
 void FileFunc(),EditFunc();

 main()
 {
 funcp=FileFunc;
 (*funcp)();
 funcp=EditFunc;
 (*funcp)();
 }

 void FileFunc()
 {
 printf(FileFunc\n);
 }

 void EditFunc()
 {
 printf(EditFunc\n);
 }

 程序输出为：
 FileFunc
 EditFunc



主要的区别是一个是指针变量，一个是函数。在使用是必要要搞清楚才能正确使用



二、指针的指针
 指针的指针看上去有些令人费解。它们的声明有两个星号。例如：
 char ** cp;
 如果有三个星号，那就是指针的指针的指针，四个星号就是指针的指针的指针的指针，依次类推。当你熟悉了简单的例子以后，就可以应付复杂的情况了。当然，实际程序中，一般也只用到
二级指针，三个星号不常见，更别说四个星号了。
 指针的指针需要用到指针的地址。
 char c='A';
 char *p=&c;
 char **cp=&p;
 通过指针的指针，不仅可以访问它指向的指针，还可以访问它指向的指针所指向的数据。下面就是几个这样的例子：
 char *p1=*cp;
 char c1=**cp;
 你可能想知道这样的结构有什么用。利用指针的指针可以允许被调用函数修改局部指针变量和处理指针数组。

 void FindCredit(int **);

 main()
 {
 int vals[]={7,6,5,-4,3,2,1,0};
 int *fp=vals;
 FindCredit(&fp);
 printf(%d\n,*fp);
 }

 void FindCredit(int ** fpp)
 {
 while(**fpp!=0)
 if(**fpp<0) break;
 else (*fpp)++;
 }

 首先用一个数组的地址初始化指针fp，然后把该指针的地址作为实参传递给函数FindCredit()。FindCredit()函数通过表达式**fpp间接地得到数组中的数据。为遍历数组以找到一个负值，FindCredit()函数进行自增运算的对象是调用者的指向数组的指针，而不是它自己的指向调用者指针的指针。语句(*fpp)++就是对形参指针指向的指针进行自增运算的。但是因为*运算符高于++运算符，所以圆括号在这里是必须的，如果没有圆括号，那么++运算符将作用于二重指针fpp上。

三、指向指针数组的指针
 指针的指针另一用法旧处理指针数组。有些程序员喜欢用指针数组来代替多维数组，一个常见的用法就是处理字符串。

 char *Names[]=
 {
 Bill,
 Sam,
 Jim,
 Paul,
 Charles,
 0
 };

 main()
 {
 char **nm=Names;
 while(*nm!=0) printf(%s\n,*nm++);
 }

 先用字符型指针数组Names的地址来初始化指针nm。每次printf()的调用都首先传递指针nm指向的字符型指针，然后对nm进行自增运算使其指向数组的下一个元素(还是指针)。注意完成上述认为的语法为*nm++，它首先取得指针指向的内容，然后使指针自增。
 注意数组中的最后一个元素被初始化为0，while循环以次来判断是否到了数组末尾。具有零值的指针常常被用做循环数组的终止符。程序员称零值指针为空指针(NULL)。采用空指针作为终止符，在树种增删元素时，就不必改动遍历数组的代码，因为此时数组仍然以空指针作为结束。

** template                                                       :template:
*** [[http://www.cnblogs.com/gw811/archive/2012/10/25/2738929.html][C++ 模板详解（一）]] :blog:


模板是C++支持*参数化*多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。

模板是一种对*类型*进行*参数化*的工具；

通常有两种形式：*函数模板*和*类模板*；

函数模板针对仅*参数类型*不同的*函数*；

类模板针对仅*数据成员*和*成员函数类型*不同的类。

*使用模板的目的就是能够让程序员编写与类型无关的代码。*比如编写了一个交换两个整型int
类型的swap函数，这个函数就只能实现*int*
型，对*double*，字符这些类型无法实现，要实现这些类型的交换就要重新编写另一个*swap*函数。使用模板的目的就是要让这程序的实现与类型无关，比如一个*swap*模板函数，即可以实现*int*
型，又可以实现double型的交换。模板可以应用于函数和类。下面分别介绍。

*注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。*



****  一、函数模板通式

--------------

*1、函数模板的格式：*

*template <class 形参名，class 形参名，......> 返回类型
函数名(参数列表)*

*　　　{*

*　　　　　　函数体*

*　　　}*

其中*template*和*class*是关见字，*class*可以用*typename*
关见字代替，在这里*typename
和class没区别*，<>括号中的参数叫*模板形参*，模板形参和函数形参很相像，*模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。*模板形参需要调用该模板函数时提供的模板实参来初始化模板形参，一旦编译器确定了实际的模板实参类型就称他实例化了函数模板的一个实例。比如*swap*的模板函数形式为

*template <class T> void swap(T& a, T& b){}，*

当调用这样的模板函数时类型T就会被被调用时的类型所代替，比如*swap(a,b)*其中*a*和*b*是*int*
型，这时模板函数swap中的形参*T*就会被*int*
所代替，模板函数就变为*swap(int &a, int
&b)*。而当*swap(c,d)*其中*c*和*d*是*double*类型时，模板函数会被替换为*swap(double
&a, double &b)*，这样就实现了函数的实现与类型无关的代码。

2、注意：对于函数模板而言不存在 *h(int,int)*
这样的调用，*不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行*，即只能进行
*h(2,3)* 这样的调用，或者*int a, b; h(a,b)*。

*函数模板的示例演示将在下文中涉及！*

**** 二、类模板通式

--------------

1、类模板的格式为：

*　　　　template<class  形参名，class 形参名，...>  class 类名*

*　　　　{ ... };*

类模板和函数模板都是以*template*开始后接模板形参列表组成，模板形参不能为空，*一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。*比如

*template<class T> class A{public: T a; T b; T hy(T c, T &d);};*

在类*A*中声明了两个类型为*T*的成员变量*a*和*b*，还声明了一个返回类型为*T*带两个参数类型为*T*的函数*hy*。

2、类模板对象的创建：比如一个模板类*A*，则使用类模板创建对象的方法为*A<int>
m;*在类*A*后面跟上一个*<>*尖括号并在里面填上相应的类型，这样的话类*A*中凡是用到模板形参的地方都会被*int*
所代替。当类模板有两个模板形参时创建对象的方法为*A<int, double>
m;*类型之间用逗号隔开。

3、对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如*A<2>
m;*用这种方法把模板形参设置为*int*是错误的（*编译错误：error C2079: 'a'
uses undefined class
'A<int>'*），*类模板形参不存在实参推演的问题。*也就是说不能把整型值*2*推演为*int*
型传递给模板形参。要把类模板形参调置为*int* 型必须这样指定*A<int> m*。

4、在类模板外部定义成员函数的方法为：

*template<模板形参列表> 函数返回类型
类名<模板形参名>::函数名(参数列表){函数体}，*

比如有两个模板形参*T1*，*T2*的类*A*中含有一个*void
h()*函数，则定义该函数的语法为：

*　template<class T1,class T2> void A<T1,T2>::h(){}。*

注意：当在类外面定义类的成员时*template*后面的模板形参应与要定义的类的模板形参一致。

5、再次提醒注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在*main*函数中声明或定义一个模板。



**** 三、模板的形参

--------------

*有三种类型的模板形参：类型形参，非类型形参和模板形参。*

***** 　　1、类型形参

1.1
、类型模板形参：*类型形参由关见字class或typename后接说明符构成*，如*template<class
T> void h(T
a){}*;其中*T*就是一个类型形参，类型形参的名字由用户自已确定。*模板形参表示的是一个未知的类型*。模板类型形参可作为类型说明符用在模板中的任何地方，与内置类型说明符或类类型说明符的使用方式完全相同，即可以用于指定返回类型，变量声明等。

*作者原版：1.2、*
不能为同一个模板类型形参指定两种不同的类型，比如*template<class T>void
h(T a, T b){}，*语句调用*h(2,
3.2)*将出错，因为该语句给同一模板形参*T*指定了两种类型，第一个实参*2*把模板形参T指定为*int*，而第二个实参*3.2*把模板形参指定为*double*，两种类型的形参不一致，会出错。*（针对函数模板）*

作者原版：1.2针对函数模板是正确的，但是忽略了类模板。下面将对类模板的情况进行补充。

*本人添加1.2补充版（针对于类模板）、*当我们声明类对象为：*A<int>
a*，比如*template<class T>T g(T a, T b){}*，语句调用*a.g(2,
3.2)*在编译时不会出错，但会有警告，因为在声明类对象的时候已经将*T*转换为*int*类型，而第二个实参*3.2*把模板形参指定为*double*，在运行时，会对*3.2*进行强制类型转换为*3*。当我们声明类的对象为：*A<double>
a*,此时就不会有上述的警告，因为从*int*到*double*是自动类型转换。

*演示示例１：*

*　　TemplateDemo.h*

#+BEGIN_EXAMPLE
     1 #ifndef TEMPLATE_DEMO_HXX
     2 #define TEMPLATE_DEMO_HXX
     3
     4 template<class T> class A{
     5     public:
     6         T g(T a,T b);
     7         A();
     8 };
     9
    10 #endif
#+END_EXAMPLE

*　　TemplateDemo.cpp*

#+BEGIN_EXAMPLE
     1 #include<iostream.h>
     2 #include "TemplateDemo.h"
     3
     4 template<class T> A<T>::A(){}
     5
     6 template<class T> T A<T>::g(T a,T b){
     7     return a+b;
     8 }
     9
    10 void main(){
    11     A<int> a;
    12     cout<<a.g(2,3.2)<<endl;
    13 }
#+END_EXAMPLE

*　　编译结果：*

#+BEGIN_EXAMPLE
    1 --------------------Configuration: TemplateDemo - Win32 Debug--------------------
    2 Compiling...
    3 TemplateDemo.cpp
    4 G:\C++\CDaima\TemplateDemo\TemplateDemo.cpp(12) : warning C4244: 'argument' : conversion from 'const double' to 'int', possible loss of data
    5
    6 TemplateDemo.obj - 0 error(s), 1 warning(s)
#+END_EXAMPLE

*运行结果：　　　　　　5　　*

我们从上面的测试示例中可以看出，并非作者原作中的那么严密！此处仅是本人跟人测试结果！请大家本着实事求是的态度，自行验证！



***** 　　2、非类型形参

2.1
、非类型模板形参：*模板的非类型形参也就是内置类型形参*，如*template<class
T, int a> class B{};*其中*int a*就是非类型的模板形参。

2.2、
非类型形参在模板定义的内部是常量值，也就是说非类型形参在模板的内部是常量。

*2.3、
非类型*模板*的形参只能是整型，指针和引用，像double，String, String
**这样的类型是不允许的。*但是*double &，double
*，*对象的引用或指针是正确的。

2.4、
*调用非类型模板形参的实参必须是一个常量表达式*，即他必须能在编译时计算出结果。

2.5
、注意：*任何局部对象，局部变量，局部对象的地址，局部变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参*。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能用作非类型模板形参的实参。

2.6、
*全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参*。

2.7
、*sizeof*表达式的结果是一个常量表达式，也能用作非类型模板形参的实参。

2.8
、当模板的形参是整型时调用该模板时的实参必须是整型的，且在编译期间是常量，比如*template
<class T, int a> class A{};*如果有*int b，这时A<int, b>
m;*将出错，因为*b*不是常量，如果*const int b，这时A<int, b>
m*;就是正确的，因为这时*b*是常量。

*2.9
、非类型形参一般不应用于函数模板中*，比如有函数模板*template<class T,
int a> void h(T
b){}*，若使用*h(2)*调用会出现无法为非类型形参a推演出参数的错误，对这种模板函数可以用显示模板实参来解决，如用h<int,
3>(2)这样就把非类型形参a设置为整数3。显示模板实参在后面介绍。

2.10、 非类型模板形参的形参和实参间所允许的转换
*　　　　　　1、允许从数组到指针，从函数到指针的转换。如：template <int
*a> class A{}; int b[1]; A<b> m;即数组到指针的转换*
*　　　　　　2、const修饰符的转换。如：template<const int *a> class A{};
int b; A<&b> m;  即从int *到const int *的转换。*
*　　　　　　3、提升转换。如：template<int a> class A{}; const short
b=2; A<b> m; 即从short到int 的提升转换*
*　　　　　　4、整值转换。如：template<unsigned int a> class A{};  A<3>
m; 即从int 到unsigned int的转换。*
*　　　　　　5、常规转换。*

*非类型形参演示示例1：*

*由用户自己亲自指定栈的大小，并实现栈的相关操作。*

*　　TemplateDemo.h*

#+BEGIN_EXAMPLE
     1 #ifndef TEMPLATE_DEMO_HXX
     2 #define TEMPLATE_DEMO_HXX
     3
     4 template<class T,int MAXSIZE> class Stack{//MAXSIZE由用户创建对象时自行设置
     5     private:
     6         T elems[MAXSIZE];    // 包含元素的数组
     7         int numElems;    // 元素的当前总个数
     8     public:
     9         Stack();    //构造函数
    10         void push(T const&);    //压入元素
    11         void pop();        //弹出元素
    12         T top() const;    //返回栈顶元素
    13         bool empty() const{     // 返回栈是否为空
    14             return numElems == 0;
    15         }
    16         bool full() const{    // 返回栈是否已满
    17             return numElems == MAXSIZE;
    18         }
    19 };
    20
    21 template <class T,int MAXSIZE>
    22 Stack<T,MAXSIZE>::Stack():numElems(0){     // 初始时栈不含元素
    23     // 不做任何事情
    24 }
    25
    26 template <class T,int MAXSIZE>
    27 void Stack<T, MAXSIZE>::push(T const& elem){
    28     if(numElems == MAXSIZE){
    29         throw std::out_of_range("Stack<>::push(): stack is full");
    30     }
    31     elems[numElems] = elem;   // 附加元素
    32     ++numElems;               // 增加元素的个数
    33 }
    34
    35 template<class T,int MAXSIZE>
    36 void Stack<T,MAXSIZE>::pop(){
    37     if (numElems <= 0) {
    38         throw std::out_of_range("Stack<>::pop(): empty stack");
    39     }
    40     --numElems;               // 减少元素的个数
    41 }
    42
    43 template <class T,int MAXSIZE>
    44 T Stack<T,MAXSIZE>::top()const{
    45     if (numElems <= 0) {
    46         throw std::out_of_range("Stack<>::top(): empty stack");
    47     }
    48     return elems[numElems-1];  // 返回最后一个元素
    49 }
    50
    51 #endif
#+END_EXAMPLE

*　　TemplateDemo.cpp*

#+BEGIN_EXAMPLE
     1 #include<iostream.h>
     2 #include <iostream>
     3 #include <string>
     4 #include <cstdlib>
     5 #include "TemplateDemo.h"
     6
     7 int main(){
     8     try {
     9         Stack<int,20>  int20Stack;  // 可以存储20个int元素的栈
    10         Stack<int,40>  int40Stack;  // 可以存储40个int元素的栈
    11         Stack<std::string,40> stringStack; // 可存储40个string元素的栈
    12
    13         // 使用可存储20个int元素的栈
    14         int20Stack.push(7);
    15         std::cout << int20Stack.top() << std::endl;    //7
    16         int20Stack.pop();
    17
    18         // 使用可存储40个string的栈
    19         stringStack.push("hello");
    20         std::cout << stringStack.top() << std::endl;    //hello
    21         stringStack.pop();
    22         stringStack.pop();    //Exception: Stack<>::pop<>: empty stack
    23         return 0;
    24     }
    25     catch (std::exception const& ex) {
    26         std::cerr << "Exception: " << ex.what() << std::endl;
    27         return EXIT_FAILURE;  // 退出程序且有ERROR标记
    28     }
    29 }
#+END_EXAMPLE

*　　运行结果：*

[[http://pic002.cnblogs.com/images/2012/416402/2012102509100898.jpg]]

 *非类型形参演示示例2：*

*　　TemplateDemo01.h*

#+BEGIN_EXAMPLE
     1 #ifndef TEMPLATE_DEMO_O1
     2 #define TEMPLATE_DEMO_01
     3
     4 template<typename T> class CompareDemo{
     5     public:
     6         int compare(const T&, const T&);
     7 };
     8
     9 template<typename T>
    10 int CompareDemo<T>::compare(const T& a,const T& b){
    11     if((a-b)>0)
    12         return 1;
    13     else if((a-b)<0)
    14         return -1;
    15     else
    16         return 0;
    17 }
    18
    19 #endif
#+END_EXAMPLE

*　　TemplateDemo01.cpp*

#+BEGIN_EXAMPLE
    1 #include<iostream.h>
    2 #include "TemplateDemo01.h"
    3
    4 void main(){
    5     CompareDemo<int> cd;
    6     cout<<cd.compare(2,3)<<endl;
    7 }
#+END_EXAMPLE

*　　运行结果：　　　　　-1　*

#+BEGIN_EXAMPLE
    1 #include<iostream.h>
    2 #include "TemplateDemo01.h"
    3
    4 void main(){
    5     CompareDemo<double> cd;
    6     cout<<cd.compare(3.2,3.1)<<endl;
    7 }
#+END_EXAMPLE

*　运行结果：　　　　　　1　　*

*TemplateDemo01.h* *改动如下：*

#+BEGIN_EXAMPLE
     1 #ifndef TEMPLATE_DEMO_O1
     2 #define TEMPLATE_DEMO_01
     3
     4 template<typename T> class CompareDemo{
     5     public:
     6         int compare(T&, T&);
     7 };
     8
     9 template<typename T>
    10 int CompareDemo<T>::compare(T& a,T& b){
    11     if((a-b)>0)
    12         return 1;
    13     else if((a-b)<0)
    14         return -1;
    15     else
    16         return 0;
    17 }
    18
    19 #endif
#+END_EXAMPLE

*　　TempalteDemo01.cpp*

#+BEGIN_EXAMPLE
    1 #include<iostream.h>
    2 #include "TemplateDemo01.h"
    3
    4 void main(){
    5     CompareDemo<int> cd;
    6     int a=2,b=3;
    7     cout<<cd.compare(a,b)<<endl;
    8 }
#+END_EXAMPLE



 *非类型形参演示示例3：*

*　　TemplateDemo02.cpp*

#+BEGIN_EXAMPLE
     1 #include<iostream.h>
     2
     3 template<typename T>
     4 const T& max(const T& a,const T& b){
     5     return a>b ? a:b;
     6 }
     7
     8 void main(){
     9     cout<<max(2.1,2.2)<<endl;//模板实参被隐式推演成double
    10     cout<<max<double>(2.1,2.2)<<endl;//显示指定模板参数。
    11     cout<<max<int>(2.1,2.2)<<endl;//显示指定的模板参数，会将函数函数直接转换为int。
    12 }
#+END_EXAMPLE

*　　运行结果：*

[[http://pic002.cnblogs.com/images/2012/416402/2012102515230328.jpg]]

#+BEGIN_EXAMPLE
    cout<<max<int>(2.1,2.2)<<endl;//显示指定的模板参数，会将函数函数直接转换为int。此语句会出现警告：
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    1 --------------------Configuration: TemplateDemo02 - Win32 Debug--------------------
    2 Compiling...
    3 TemplateDemo02.cpp
    4 G:\C++\CDaima\TemplateDemo02\TemplateDemo02.cpp(11) : 　　warning C4244: 'argument' : conversion from 'const double' to 'const int', possible loss of data
    5 G:\C++\CDaima\TemplateDemo02\TemplateDemo02.cpp(11) : 　　warning C4244: 'argument' : conversion from 'const double' to 'const int', possible loss of data
    6
    7 TemplateDemo02.obj - 0 error(s), 2 warning(s)
#+END_EXAMPLE

*** 使用模板则函数声明与实现不要分离                                 :blog:

main.cpp:(.text+0x4f)：对‘void bubble_sort<double>(double*, unsigned int)’未定义的引用
collect2: error: ld returned 1 exit status

** keywords 或 类关键字

*** typedef                                                       :typedef:
**** [[http://www.cnblogs.com/charley_yang/archive/2010/12/15/1907384.html][C++ typedef用法小结 （※不能不看※）]] :blog:

*第一、四个用途*

*用途一：*

定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。比如：
char* pa, pb; //
这多数不符合我们的意图，它只声明了一个指向字符变量的指针，
// 和一个字符变量；
以下则可行：
typedef char* PCHAR; // 一般用大写
PCHAR pa, pb; // 可行，同时声明了两个指向字符变量的指针
虽然：
char *pa, *pb;
也可行，但相对来说没有用typedef的形式直观，尤其在需要大量指针的地方，typedef的方式更省事。

*用途二：*

用在旧的C的代码中（具体多旧没有查），帮助struct。以前的代码中，声明struct新对象时，必须要带上struct，即形式为：
struct 结构名 对象名，如：
struct tagPOINT1
{
int x;
int y;
};
struct tagPOINT1 p1;

而在C++中，则可以直接写：结构名 对象名，即：
tagPOINT1 p1;

估计某人觉得经常多写一个struct太麻烦了，于是就发明了：
typedef struct tagPOINT
{
int x;
int y;
}POINT;

POINT p1; //
这样就比原来的方式少写了一个struct，比较省事，尤其在大量使用的时候

或许，在C++中，typedef的这种用途二不是很大，但是理解了它，对掌握以前的旧代码还是有帮助的，毕竟我们在项目中有可能会遇到较早些年代遗留下来的代码。

*用途三：*

用typedef来定义与平台无关的类型。
比如定义一个叫 REAL
的浮点类型，在目标平台一上，让它表示最高精度的类型为：
typedef long double REAL;
在不支持 long double 的平台二上，改为：
typedef double REAL;
在连 double 都不支持的平台三上，改为：
typedef float REAL;
也就是说，当跨平台时，只要改下 typedef
本身就行，不用对其他源码做任何修改。
标准库就广泛使用了这个技巧，比如size_t。
另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健（虽然用宏有时也可以完成以上的用途）。

*用途四：*

为复杂的声明定义一个新的简单的别名。方法是：在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例：

1. 原声明：int *(*a[5])(int, char*);
变量名为a，直接用一个新别名pFun替换a就可以了：
typedef int *(*pFun)(int, char*);
原声明的最简化版：
pFun a[5];

2. 原声明：void (*b[10]) (void (*)());
变量名为b，先替换右边部分括号里的，pFunParam为别名一：
typedef void (*pFunParam)();
再替换左边的变量b，pFunx为别名二：
typedef void (*pFunx)(pFunParam);
原声明的最简化版：
pFunx b[10];

3. 原声明：doube(*)() (*e)[9];
变量名为e，先替换左边部分，pFuny为别名一：
typedef double(*pFuny)();
再替换右边的变量e，pFunParamy为别名二
typedef pFuny (*pFunParamy)[9];
原声明的最简化版：
pFunParamy e;

理解复杂声明可用的“右左法则”：
从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：
int (*func)(int *p);
首先找到变量名func，外面有一对圆括号，而且左边是一个*号，这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明(*func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int*类型的形参，返回值类型是int。
int (*func[5])(int *);
func右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的*不是修饰func，而是修饰func[5]的，原因是[]运算符优先级比*高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指针，它指向的函数具有int*类型的形参，返回值类型为int。

也可以记住2个模式：
type (*)(....)函数指针
type (*)[]数组指针

*第二、两大陷阱*

*陷阱一：*

记住，typedef是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。比如：
先定义：
typedef char* PSTR;
然后：
int mystrcmp(const PSTR, const PSTR);

const PSTR实际上相当于const char*吗？不是的，它实际上相当于char*
const。
原因在于const给予了整个指针本身以常量性，也就是形成了常量指针char*
const。
简单来说，记住当const和typedef一起出现时，typedef不会是简单的字符串替换就行。

*陷阱二：*

typedef在语法上是一个存储类的关键字（如auto、extern、mutable、static、register等一样），虽然它并不真正影响对象的存储特性，如：
typedef static int INT2; //不可行
编译将失败，会提示“指定了一个以上的存储类”。

*以上资料出自：*[[http://blog.sina.com.cn/s/blog_4826f7970100074k.html]]
作者：赤龙

*第三、typedef 与 #define的区别*

案例一：

通常讲，typedef要比#define要好，特别是在有指针的场合。请看例子：

typedef char *pStr1;

#define pStr2 char *;

pStr1 s1, s2;

pStr2 s3, s4;

在上述的变量定义中，s1、s2、s3都被定义为char
*，而s4则定义成了char，不是我们所预期的指针变量，根本原因就在于#define只是简单的字符串替换而typedef则是为一个类型起新名字。

案例二：

下面的代码中编译器会报一个错误，你知道是哪个语句错了吗？

typedef char * pStr;

char string[4] = "abc";

const char *p1 = string;

const pStr p2 = string;

p1++;

p2++;

是p2++出错了。这个问题再一次提醒我们：typedef和#define不同，它不是简单的文本替换。上述代码中const
pStr p2并不等于const char * p2。const pStr p2和const long
x本质上没有区别，都是对变量进行只读限制，只不过此处变量p2的数据类型是我们自己定义的而不是系统固有类型而已。因此，const
pStr p2的含义是：限定数据类型为char *的变量p2为只读，因此p2++错误。

*第四部分资料：使用 typedef 抑制劣质代码*

作者：Danny Kalev
编译：MTT 工作室

原文出处：Using typedef to Curb Miscreant Code

*摘要：*Typedef
声明有助于创建平台无关类型，甚至能隐藏复杂和难以理解的语法。不管怎样，使用
typedef 能为代码带来意想不到的好处，通过本文你可以学习用 typedef
避免缺欠，从而使代码更健壮。

typedef 声明，简称 typedef，为现有类型创建一个新的名字。比如人们常常使用
typedef 来编写更美观和可读的代码。所谓美观，意指 typedef
能隐藏笨拙的语法构造以及平台相关的数据类型，从而增强可移植性和以及未来的可维护性。本文下面将竭尽全力来揭示
typedef 强大功能以及如何避免一些常见的陷阱。

Q：如何创建平台无关的数据类型，隐藏笨拙且难以理解的语法?

A： 使用 typedefs 为现有类型创建同义字。

*定义易于记忆的类型名*
typedef
使用最多的地方是创建易于记忆的类型名，用它来归档程序员的意图。类型出现在所声明的变量名字中，位于
''typedef'' 关键字右边。例如：

#+BEGIN_EXAMPLE
    typedef int size;
#+END_EXAMPLE

此声明定义了一个 int 的同义字，名字为 size。注意 typedef
并不创建新的类型。它仅仅为现有类型添加一个同义字。你可以在任何需要 int
的上下文中使用 size：

#+BEGIN_EXAMPLE
    void measure(size * psz); size array[4];size len = file.getlength();std::vector <size> vs;
#+END_EXAMPLE

typedef
还可以掩饰符合类型，如指针和数组。例如，你不用象下面这样重复定义有 81
个字符元素的数组：

#+BEGIN_EXAMPLE
    char line[81];char text[81];
#+END_EXAMPLE

定义一个 typedef，每当要用到相同类型和大小的数组时，可以这样：

#+BEGIN_EXAMPLE
    typedef char Line[81]; Line text, secondline;getline(text);
#+END_EXAMPLE

同样，可以象下面这样隐藏指针语法：

#+BEGIN_EXAMPLE
    typedef char * pstr;int mystrcmp(pstr, pstr);
#+END_EXAMPLE

这里将带我们到达第一个 typedef 陷阱。标准函数 strcmp()有两个‘const char
*'类型的参数。因此，它可能会误导人们象下面这样声明 mystrcmp()：

#+BEGIN_EXAMPLE
    int mystrcmp(const pstr, const pstr);
#+END_EXAMPLE

这是错误的，按照顺序，‘const pstr'被解释为‘char * const'（一个指向 char
的常量指针），而不是‘const char *'（指向常量 char
的指针）。这个问题很容易解决：

#+BEGIN_EXAMPLE
    typedef const char * cpstr; int mystrcmp(cpstr, cpstr); // 现在是正确的
#+END_EXAMPLE

*记住：*不管什么时候，只要为指针声明 typedef，那么都要在最终的 typedef
名称中加一个 const，以使得该指针本身是常量，而不是对象。

*代码简化*
上面讨论的 typedef 行为有点像 #define
宏，用其实际类型替代同义字。不同点是 typedef
在编译时被解释，因此让编译器来应付超越预处理器能力的文本替换。例如：

#+BEGIN_EXAMPLE
    typedef int (*PF) (const char *, const char *);
#+END_EXAMPLE

这个声明引入了 PF 类型作为函数指针的同义字，该函数有两个 const char *
类型的参数以及一个 int
类型的返回值。如果要使用下列形式的函数声明，那么上述这个 typedef
是不可或缺的：

#+BEGIN_EXAMPLE
    PF Register(PF pf);
#+END_EXAMPLE

Register() 的参数是一个 PF
类型的回调函数，返回某个函数的地址，其署名与先前注册的名字相同。做一次深呼吸。下面我展示一下如果不用
typedef，我们是如何实现这个声明的：

#+BEGIN_EXAMPLE
    int (*Register (int (*pf)(const char *, const char *))) (const char *, const char *);
#+END_EXAMPLE

很少有程序员理解它是什么意思，更不用说这种费解的代码所带来的出错风险了。显然，这里使用
typedef
不是一种特权，而是一种必需。持怀疑态度的人可能会问：“OK，有人还会写这样的代码吗？”，快速浏览一下揭示
*//* signal()函数的头文件 <csinal>，一个有同样接口的函数。

*typedef 和存储类关键字（storage class specifier）*
这种说法是不是有点令人惊讶，typedef 就像
auto，extern，mutable，static，和 register
一样，是一个存储类关键字。这并是说 typedef
会真正影响对象的存储特性；它只是说在语句构成上，typedef 声明看起来象
static，extern 等类型的变量声明。下面将带到第二个陷阱：

#+BEGIN_EXAMPLE
    typedef register int FAST_COUNTER; // 错误
#+END_EXAMPLE

编译通不过。问题出在你不能在声明中有多个存储类关键字。因为符号 typedef
已经占据了存储类关键字的位置，在 typedef 声明中不能用
register（或任何其它存储类关键字）。

*促进跨平台开发*
typedef
有另外一个重要的用途，那就是定义机器无关的类型，例如，你可以定义一个叫
REAL 的浮点类型，在目标机器上它可以i获得最高的精度：

#+BEGIN_EXAMPLE
    typedef long double REAL;
#+END_EXAMPLE

在不支持 long double 的机器上，该 typedef 看起来会是下面这样：

#+BEGIN_EXAMPLE
    typedef double REAL;
#+END_EXAMPLE

并且，在连 double 都不支持的机器上，该 typedef 看起来会是这样： 、

#+BEGIN_EXAMPLE
    typedef float REAL;
#+END_EXAMPLE

你不用对源代码做任何修改，便可以在每一种平台上编译这个使用 REAL
类型的应用程序。唯一要改的是 typedef
本身。在大多数情况下，甚至这个微小的变动完全都可以通过奇妙的条件编译来自动实现。不是吗?
标准库广泛地使用 typedef 来创建这样的平台无关类型：size_t，ptrdiff 和
fpos_t 就是其中的例子。此外，象 std::string 和 std::ofstream 这样的
typedef
还隐藏了长长的，难以理解的模板特化语法，例如：basic_string<char,
char_traits<char>，allocator<char>> 和 basic_ofstream<char,
char_traits<char>>。

*** static                                                         :static:
**** [[http://www.cnblogs.com/dc10101/archive/2007/08/22/865556.html][static的作用]] :blog:

在C语言中，static的字面意思很容易把我们导入歧途，其实它的作用有三条。

（1）先来介绍它的第一条也是最重要的一条：隐藏。

当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。为理解这句话，我举例来说明。我们要同时编译两个源文件，一个是a.c，另一个是main.c。

下面是a.c的内容

char a = 'A'; // global variable
 void msg()
 {
  printf("Hello\n");
 }



下面是main.c的内容

int main(void)
 {
  extern char a; // extern variable must be declared before use
  printf("%c ", a);
  (void)msg();
  return 0;
 }



程序的运行结果是：

A Hello

你可能会问：为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。

如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。Static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用。

（2）static的第二个作用是保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见，但我还是举一个例子。

#include <stdio.h>

 int fun(void){
  static int count = 10; // 事实上此赋值语句从来没有执行过
  return count--;
 }

 int count = 1;

 int main(void)
 {
  printf("global\t\tlocal static\n");
  for(; count <= 10; ++count)
  printf("%d\t\t%d\n", count, fun());

  return 0;
 }



程序的运行结果是：

global  local static

1  10

2  9

3  8

4  7

5  6

6  5

7  4

8   3

9  2

10  1



（3）static的第三个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加'\0'太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是'\0'。不妨做个小实验验证一下。

#include <stdio.h>

 int a;

 int main(void)
 {
  int i;
  static char str[10];

  printf("integer: %d; string: (begin)%s(end)", a, str);

  return 0;
 }

程序的运行结果如下

integer: 0; string: (begin)(end)

最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。

*** mutable                                                       :mutable:
**** [[http://www.cnblogs.com/chenyuming507950417/archive/2012/01/05/2313647.html][C++关键字mutable]] :blog:

Mutable

（1）mutable的意思是“可变的，易变的”，跟C++中的const是反义词。

（2）在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中

实例说明：

#+BEGIN_EXAMPLE
    #include <iostream>using namespace std;class TestMutable{public:    TestMutable(){i=0;}    int Output() const    {        return i++; //error C2166: l-value specifies const object    }private:    int i;};int main(){   TestMutable testMutable;   cout<<testMutable.Output()<<endl;   return 0;}
#+END_EXAMPLE

显然i++在const修饰的函数里是编译通不过的。

#+BEGIN_EXAMPLE
    #include <iostream>using namespace std;class TestMutable{public:    TestMutable(){i=0;}    int Output() const    {        return i++;     }private:    mutable int i;};int main(){   TestMutable testMutable;   cout<<testMutable.Output()<<endl;   return 0;}
#+END_EXAMPLE

在 int i 前面加上
mutable上面就能编译通过了，马上可以看出关键字mutable的作用了。

*** null                                                             :null:
**** Q&A [[http://www.cnblogs.com/pmars/archive/2012/10/16/2725511.html][c和c++中NULL和0的区别]] :blog:qa:

***** 什么是空指针常量（null pointer constant）?

[6.3.2.3-3] An integer constant expression with the value 0, or such an
expression cast to type void *, is called a null pointer constant.

这里告诉我们：0、0L、'\0'、3 - 3、0 * 17 （它们都是“integer constant
expression”）以及 (void*)0 （tyc：
我觉得(void*)0应该算是一个空指针吧，更恰当一点）等都是空指针常量（注意
(char*) 0
不叫空指针常量，只是一个空指针值）。至于系统选取哪种形式作为空指针常量使用，则是实现相关的。一般的
C 系统选择 (void*)0 或者 0 的居多（也有个别的选择 0L）；至于 C++
系统，由于存在严格的类型转化的要求，void* 不能象 C
中那样自由转换为其它指针类型，所以通常选 0 作为空指针常量（tyc:
C++标准推荐），而不选择 (void*)0。

***** 什么是空指针（null pointer）?

[6.3.2.3-3] If a null pointer constant is converted to a pointer type,
the resulting pointer, called a null pointer, is guaranteed to compare
unequal to a pointer to any object or function.

因此，如果 p 是一个指针变量，则 p = 0;、p = 0L;、p = '\0';、p = 3 -
3;、p = 0 * 17; 中的任何一种赋值操作之后（对于 C 来说还可以是 p =
(void*)0;）， p
都成为一个空指针，由系统保证空指针不指向任何实际的对象或者函数。反过来说，任何对象或者函数的地址都不可能是空指针。（tyc:
比如这里的(void*)0就是一个空指针。把它理解为null pointer还是null pointer
constant会有微秒的不同，当然也不是紧要了）

***** 什么是 NULL？

[6.3.2.3-Footnote] The macro NULL is defined in <stddef.h> (and other
headers) as a null pointer constant

即 NULL
是一个标准规定的宏定义，用来表示空指针常量。因此，除了上面的各种赋值方式之外，还可以用
p = NULL; 来使 p 成为一个空指针。（tyc：很多系统中的实现：#define NULL
(void*)0，与这里的“a null pointer constant”并不是完全一致的）

***** 空指针（null pointer）指向了内存的什么地方（空指针的内部实现）？

标准并没有对空指针指向内存中的什么地方这一个问题作出规定，也就是说用哪个具体的地址值（0x0
地址还是某一特定地址）表示空指针取决于系统的实现。我们常见的空指针一般指向
0 地址，即空指针的内部用全 0 来表示（zero null
pointer，零空指针）；也有一些系统用一些特殊的地址值或者特殊的方式表示空指针（nonzero
null pointer，非零空指针），具体请参见C FAQ。

幸运的是，在实际编程中不需要了解在我们的系统上空指针到底是一个 zero null
pointer 还是 nonzero null
pointer，我们只需要了解一个指针是否是空指针就可以了------编译器会自动实现其中的转换，为我们屏蔽其中的实现细节。注意：不要把空指针的内部表示等同于整数
0 的对象表示------如上所述，有时它们是不同的。

***** 如何判断一个指针是否是一个空指针？

这可以通过与空指针常量或者其它的空指针的比较来实现（注意与空指针的内部表示无关）。例如，假设
p 是一个指针变量，q 是一个同类型的空指针，要检查 p
是否是一个空指针，可以采用下列任意形式之一------它们在实现的功能上都是等价的，所不同的只是风格的差别。

指针变量 p 是空指针的判断：

if ( p == 0 )

if ( p == '\0' )

if ( p == 3 - 3 )

if ( p == NULL )  /* 使用 NULL 必须包含相应的标准库的头文件 */

if ( NULL == p )

if ( !p )

if ( p == q )

...

指针变量 p 不是空指针的判断：

if ( p != 0 )

if ( p != '\0' )

if ( p != 3 - 3 )

if ( p != NULL )  /* 使用 NULL 必须包含相应的标准库的头文件 */

if ( NULL != p )

if ( p )

if ( p != q )

...

***** 可以用 memset 函数来得到一个空指针吗？

这个问题等同于：如果 p 是一个指针变量，那么

memset( &p, 0, sizeof(p) ); 和 p = 0;

是等价的吗？

答案是否定的，虽然在大多数系统上是等价的，但是因为有的系统存在着“非零空指针”
（nonzero null
pointer），所以这时两者不等价。由于这个原因，要注意当想将指针设置为空指针的时候不应该使用
memset，而应该用空指针常量或空指针对指针变量赋值或者初始化的方法。

***** 可以定义自己的 NULL 的实现吗？兼答"NULL 的值可以是 1、2、3等值吗？"类似问题

[7.1.3-2] If the program declares or defines an identifier in a context
in which it is reserved (other than as allowed by 7.1.4), or defines a
reserved identifier as a macro name, the behavior is undefined.

NULL 是标准库中的一个符合上述条件的 reserved identifier
（保留标识符）。所以，如果包含了相应的标准头文件而引入了 NULL
的话，则再在程序中重新定义 NULL
为不同的内容是非法的，其行为是未定义的。也就是说，如果是符合标准的程序，其
NULL 的值只能是 0，不可能是除 0 之外的其它值，比如 1、2、3 等。

***** malloc 函数在分配内存失败时返回 0 还是 NULL？

malloc 函数是标准 C
规定的库函数。在标准中明确规定了在其内存分配失败时返回的是一个 “null
pointer”（空指针）：

[7.20.3-1] If the space cannot be allocated, a null pointer is returned.

对于空指针值，一般的文档（比如 man）中倾向于用 NULL 表示，而没有直接说成
0。但是我们应该清楚：对于指针类型来说，返回 NULL 和 返回 0
是完全等价的，因为 NULL 和 0 都表示 “null
pointer”（空指针）。（tyc：一般系统中手册中都返回NULL，那我们就用NULL吧）

另外，附C FAQ上关于null pointer的解释：C FAQ：null pointer

***** 参考：

[[http://topic.csdn.net/u/20121009/09/947a37cc-cb05-4f42-b889-a26e7253325e.html][NULL与0是否有区别？？（CSDN）]]

[[http://wenku.baidu.com/view/250567c08bd63186bcebbcc0.html][c和c++中NULL和0的区别（文库）]]

*** sizeof                                                         :sizeof:
**** [[http://www.cnblogs.com/wanghetao/archive/2012/04/04/2431760.html][sizeof和sizeof(string)的问题]] :blog:

今天看《程序员面试宝典》一书（为了应付将要到来的微软笔试），看到了sizeof(string)这个问题。在Dev
C++上测试的结果是4，很不明白。上网搜了一下，得到如下结果：

string strArr1[]={"Trend", "Micro", "Soft"};

sizeof(strArr1)=12



转自：[[http://apps.hi.baidu.com/share/detail/30398570]]

关于sizeof(string)，今天看那本面试宝典的时候看到这个表达式，有点吃惊，书上写着sizeof(string)=4;当时很纳闷，难道分配4个字节大小的内存给string吗？查阅了相关资料得出结论：string的实现在各库中可能有所不同，但是在同一库中相同一点是，无论你的string里放多长的字符串，它的sizeof()都是固定的，字符串所占的空间是从堆中动态分配的，与sizeof()无关。

sizeof(string)=4可能是最典型的实现之一，不过也有sizeof()为12、32字节的库实现。
但是VC6.0测试后sizeof(string)=16.还是跟编译器有关

#include<iostream>
using namespace std;
void main(void)
{
string a[] = {"aaaaa","bbbb","ccc"};
int x = sizeof(a);
int y = sizeof(string);
cout << x << endl;
cout << y << endl;
}

运行结果：

[[file:///C:/DOCUME~1/stoneboy/LOCALS~1/Temp/B59W8R[2QW0H)63MOX0[8UU.jpg]]

关于sizeof更多的用法摘自：[[http://hi.baidu.com/haijiaoshu/blog/item/a269f527706b910a908f9d5b.html]]

1、什么是sizeof

  首先看一下sizeof在msdn上的定义：

  The sizeof keyword gives the amount of storage, in bytes, associated
with a variable or a type (including aggregate types). This keyword
returns a value of type size_t.


看到return这个字眼，是不是想到了函数？错了，sizeof不是一个函数，你见过给一个函数传参数，而不加括号的吗？sizeof可以，所以sizeof不是函数。网上有人说sizeof是一元操作符，但是我并不这么认为，因为sizeof更像一个特殊的宏，它是在编译阶段求值的。举个例子：



cout<<sizeof(int)<<endl; // 32位机上int长度为4

cout<<sizeof(1==2)<<endl; // == 操作符返回bool类型，相当于
cout<<sizeof(bool)<<endl;

  在编译阶段已经被翻译为：

cout<<4<<endl;

cout<<1<<endl;

  这里有个陷阱，看下面的程序：

int a = 0;

cout<<sizeof(a=3)<<endl;

cout<<a<<endl;


输出为什么是4，0而不是期望中的4，3？？？就在于sizeof在编译阶段处理的特性。由于sizeof不能被编译成机器码，所以sizeof作用范围内，也就是()里面的内容也不能被编译，而是被替换成类型。=操作符返回左操作数的类型，所以a=3相当于int，而代码也被替换为：

int a = 0;

cout<<4<<endl;

cout<<a<<endl;


所以，sizeof是不可能支持链式表达式的，这也是和一元操作符不一样的地方。


结论：不要把sizeof当成函数，也不要看作一元操作符，把他当成一个特殊的编译预处理。

2、sizeof的用法

  sizeof有两种用法：



  （1）sizeof(object)

  也就是对对象使用sizeof，也可以写成sizeof object 的形式。例如：

  （2）sizeof(typename)

  也就是对类型使用sizeof，注意这种情况下写成sizeof
typename是非法的。下面举几个例子说明一下：



int i = 2;

cout<<sizeof(i)<<endl; // sizeof(object)的用法，合理

cout<<sizeof i<<endl; // sizeof object的用法，合理

cout<<sizeof 2<<endl; // 2被解析成int类型的object, sizeof
object的用法，合理

cout<<sizeof(2)<<endl; // 2被解析成int类型的object,
sizeof(object)的用法，合理

cout<<sizeof(int)<<endl;// sizeof(typename)的用法，合理

cout<<sizeof int<<endl; // 错误！对于操作符，一定要加()

  可以看出，加()是永远正确的选择。

  结论：不论sizeof要对谁取值，最好都加上()。

3、数据类型的sizeof

（1）C++固有数据类型

  32位C++中的基本数据类型，也就char,short int(short),int,long
int(long),float,double, long double

大小分别是：1，2，4，4，4，8, 10。

  考虑下面的代码：

cout<<sizeof(unsigned int) == sizeof(int)<<endl; // 相等，输出 1

  unsigned影响的只是最高位bit的意义，数据长度不会被改变的。

  结论：unsigned不能影响sizeof的取值。

（2）自定义数据类型

  typedef可以用来定义C++自定义类型。考虑下面的问题：

typedef short WORD;

typedef long DWORD;

cout<<(sizeof(short) == sizeof(WORD))<<endl; // 相等，输出1

cout<<(sizeof(long) == sizeof(DWORD))<<endl; // 相等，输出1

  结论：自定义类型的sizeof取值等同于它的类型原形。

（3）函数类型

  考虑下面的问题：

int f1(){return 0;};

double f2(){return 0.0;}

void f3(){}

cout<<sizeof(f1())<<endl; // f1()返回值为int，因此被认为是int

cout<<sizeof(f2())<<endl; // f2()返回值为double，因此被认为是double

cout<<sizeof(f3())<<endl; // 错误！无法对void类型使用sizeof

cout<<sizeof(f1)<<endl;  // 错误！无法对函数指针使用sizeof

cout<<sizeof*f2<<endl;  //
*f2，和f2()等价，因为可以看作object，所以括号不是必要的。被认为是double

  结论：对函数使用sizeof，在编译阶段会被函数返回值的类型取代，

4、指针问题

  考虑下面问题：



cout<<sizeof(string*)<<endl; // 4

cout<<sizeof(int*)<<endl; // 4

cout<<sizof(char****)<<endl; // 4


可以看到，不管是什么类型的指针，大小都是4的，因为指针就是32位的物理地址。

  结论：只要是指针，大小就是4。（64位机上要变成8也不一定）。


顺便唧唧歪歪几句，C++中的指针表示实际内存的地址。和C不一样的是，C++中取消了模式之分，也就是不再有small,middle,big,取而代之的是统一的flat。flat模式采用32位实地址寻址，而不再是c中的
segment:offset模式。举个例子，假如有一个指向地址
f000:8888的指针，如果是C类型则是8888(16位,
只存储位移，省略段)，far类型的C指针是f0008888(32位，高位保留段地址，地位保留位移),C++类型的指针是f8888(32位，相当于段地址*16
+ 位移，但寻址范围要更大)。

5、数组问题

  考虑下面问题：

char a[] = "abcdef";

int b[20] = {3, 4};

char c[2][3] = {"aa", "bb"};



cout<<sizeof(a)<<endl; // 7

cout<<sizeof(b)<<endl; // 20*4=80

cout<<sizeof(c)<<endl; // 6




数组a的大小在定义时未指定，编译时给它分配的空间是按照初始化的值确定的，也就是7。c是多维数组，占用的空间大小是各维数的乘积，也就是6。可以看出，数组的大小就是他在编译时被分配的空间，也就是各维数的乘积*数组元素的大小。

  结论：数组的大小是各维数的乘积*数组元素的大小。

  这里有一个陷阱：

int *d = new int[10];

cout<<sizeof(d)<<endl; // 4


d是我们常说的动态数组，但是他实质上还是一个指针，所以sizeof(d)的值是4。

  再考虑下面的问题：

double* (*a)[3][6];



cout<<sizeof(a)<<endl;  // 4

cout<<sizeof(*a)<<endl;  // 72

cout<<sizeof(**a)<<endl; // 24

cout<<sizeof(***a)<<endl; // 4

cout<<sizeof(****a)<<endl; // 8

  a是一个很奇怪的定义，他表示一个指向
double*[3][6]类型数组的指针。既然是指针，所以sizeof(a)就是4。


既然a是执行double*[3][6]类型的指针，*a就表示一个double*[3][6]的多维数组类型，因此sizeof(*a)=3*6*sizeof(double*)=72。同样的，**a表示一个double*[6]类型的数组，所以sizeof(**a)=6*sizeof(double*)=24。***a就表示其中的一个元素，也就是double*了，所以sizeof(***a)=4。至于****a，就是一个double了，所以sizeof(****a)=sizeof(double)=8。

6、向函数传递数组的问题。

  考虑下面的问题：

#include <iostream>

using namespace std;

int Sum(int i[])

{

int sumofi = 0;

for (int j = 0; j < sizeof(i)/sizeof(int); j++) //实际上，sizeof(i) = 4

{

  sumofi += i[j];

}

return sumofi;

}

int main()

{

int allAges[6] = {21, 22, 22, 19, 34, 12};

cout<<Sum(allAges)<<endl;

system("pause");

return 0;

}


Sum的本意是用sizeof得到数组的大小，然后求和。但是实际上，传入自函数Sum的，只是一个int
类型的指针，所以sizeof(i)=4，而不是24，所以会产生错误的结果。解决这个问题的方法使是用指针或者引用。

  使用指针的情况：

int Sum(int (*i)[6])

{

int sumofi = 0;

for (int j = 0; j < sizeof(*i)/sizeof(int); j++) //sizeof(*i) = 24

{

  sumofi += (*i)[j];

}

return sumofi;

}

int main()

{

int allAges[] = {21, 22, 22, 19, 34, 12};

cout<<Sum(&allAges)<<endl;

system("pause");

return 0;

}

  在这个Sum里，i是一个指向i[6]类型的指针，注意，这里不能用int Sum(int
(*i)[])声明函数，而是必须指明要传入的数组的大小，不然sizeof(*i)无法计算。但是在这种情况下，再通过sizeof来计算数组大小已经没有意义了，因为此时大小是指定为6的。

使用引用的情况和指针相似：

int Sum(int (&i)[6])

{

int sumofi = 0;

for (int j = 0; j < sizeof(i)/sizeof(int); j++)

{

  sumofi += i[j];

}

return sumofi;

}

int main()

{

int allAges[] = {21, 22, 22, 19, 34, 12};

cout<<Sum(allAges)<<endl;

system("pause");

return 0;

}


这种情况下sizeof的计算同样无意义，所以用数组做参数，而且需要遍历的时候，函数应该有一个参数来说明数组的大小，而数组的大小在数组定义的作用域内通过sizeof求值。因此上面的函数正确形式应该是：

#include <iostream>

using namespace std;

int Sum(int *i, unsigned int n)

{

int sumofi = 0;

for (int j = 0; j < n; j++)

{

  sumofi += i[j];

}

return sumofi;

}

int main()

{

int allAges[] = {21, 22, 22, 19, 34, 12};

cout<<Sum(i, sizeof(allAges)/sizeof(int))<<endl;

system("pause");

return 0;

}

7、字符串的sizeof和strlen

  考虑下面的问题：

char a[] = "abcdef";

char b[20] = "abcdef";

string s = "abcdef";

cout<<strlen(a)<<endl;  // 6，字符串长度

cout<<sizeof(a)<<endl;  // 7，字符串容量

cout<<strlen(b)<<endl;  // 6，字符串长度

cout<<sizeof(b)<<endl;  // 20，字符串容量

cout<<sizeof(s)<<endl;  // 12,
这里不代表字符串的长度，而是string类的大小

cout<<strlen(s)<<endl;  // 错误！s不是一个字符指针。

a[1] = '\0';

cout<<strlen(a)<<endl;  // 1

cout<<sizeof(a)<<endl;  // 7，sizeof是恒定的


strlen是寻找从指定地址开始，到出现的第一个0之间的字符个数，他是在运行阶段执行的，而sizeof是得到数据的大小，在这里是得到字符串的容量。所以对同一个对象而言，sizeof的值是恒定的。string是C++类型的字符串，他是一个类，所以sizeof(s)表示的并不是字符串的长度，而是类string的大小。strlen(s)根本就是错误的，因为strlen的参数是一个字符指针，如果想用strlen得到s字符串的长度，应该使用sizeof(s.c_str())，因为string的成员函数c_str()返回的是字符串的首地址。实际上，string类提供了自己的成员函数来得到字符串的容量和长度，分别是Capacity()和Length()。string封装了常用了字符串操作，所以在C++开发过程中，最好使用string代替C类型的字符串。

8、从union的sizeof问题看cpu的对界

  考虑下面问题：（默认对齐方式）

union u

{

  double a;

  int b;

};

union u2

{

  char a[13];

  int b;

};

union u3

{

  char a[13];

  char b;

};

cout<<sizeof(u)<<endl;  // 8

cout<<sizeof(u2)<<endl;  // 16

cout<<sizeof(u3)<<endl;  // 13


都知道union的大小取决于它所有的成员中，占用空间最大的一个成员的大小。所以对于u来说，大小就是最大的double类型成员a了，所以sizeof(u)=sizeof(double)=8。但是对于u2和u3，最大的空间都是char[13]类型的数组，为什么u3的大小是13，而u2是16呢？关键在于u2中的成员int
b。由于int类型成员的存在，使u2的对齐方式变成4，也就是说，u2的大小必须在4的对界上，所以占用的空间变成了16（最接近13的对界）。


结论：复合数据类型，如union，struct，class的对齐方式为成员中对齐方式最大的成员的对齐方式。


顺便提一下CPU对界问题，32的C++采用8位对界来提高运行速度，所以编译器会尽量把数据放在它的对界上以提高内存命中率。对界是可以更改的，使用#pragma
pack(x)宏可以改变编译器的对界方式，默认是8。C++固有类型的对界取编译器对界方式与自身大小中较小的一个。例如，指定编译器按2对界，int类型的大小是4，则int的对界为2和4中较小的2。在默认的对界方式下，因为几乎所有的数据类型都不大于默认的对界方式8（除了long
double），所以所有的固有类型的对界方式可以认为就是类型自身的大小。更改一下上面的程序：

#pragma pack(2)

union u2

{

  char a[13];

  int b;

};

union u3

{

  char a[13];

  char b;

};

#pragma pack(8)

cout<<sizeof(u2)<<endl;  // 14

cout<<sizeof(u3)<<endl;  // 13


由于手动更改对界方式为2，所以int的对界也变成了2，u2的对界取成员中最大的对界，也是2了，所以此时sizeof(u2)=14。

  结论：C++固有类型的对界取编译器对界方式与自身大小中较小的一个。

9、struct的sizeof问题


因为对齐问题使结构体的sizeof变得比较复杂，看下面的例子：(默认对齐方式下)

struct s1

{

  char a;

  double b;

  int c;

  char d;

};

struct s2

{

  char a;

  char b;

  int c;

  double d;

};

cout<<sizeof(s1)<<endl; // 24

cout<<sizeof(s2)<<endl; // 16


同样是两个char类型，一个int类型，一个double类型，但是因为对界问题，导致他们的大小不同。计算结构体大小可以采用元素摆放法，我举例子说明一下：首先，CPU判断结构体的对界，根据上一节的结论，s1和s2的对界都取最大的元素类型，也就是double类型的对界8。然后开始摆放每个元素。


对于s1，首先把a放到8的对界，假定是0，此时下一个空闲的地址是1，但是下一个元素d是double类型，要放到8的对界上，离1最接近的地址是8了，所以d被放在了8，此时下一个空闲地址变成了16，下一个元素c的对界是4，16可以满足，所以c放在了16，此时下一个空闲地址变成了20，下一个元素d需要对界1，也正好落在对界上，所以d放在了20，结构体在地址21处结束。由于s1的大小需要是8的倍数，所以21-23的空间被保留，s1的大小变成了24。


对于s2，首先把a放到8的对界，假定是0，此时下一个空闲地址是1，下一个元素的对界也是1，所以b摆放在1，下一个空闲地址变成了2；下一个元素c的对界是4，所以取离2最近的地址4摆放c，下一个空闲地址变成了8，下一个元素d的对界是8，所以d摆放在8，所有元素摆放完毕，结构体在15处结束，占用总空间为16，正好是8的倍数。


这里有个陷阱，对于结构体中的结构体成员，不要认为它的对齐方式就是他的大小，看下面的例子：

struct s1

{

  char a[8];

};

struct s2

{

  double d;

};

struct s3

{

  s1 s;

  char a;

};

struct s4

{

  s2 s;

  char a;

};

cout<<sizeof(s1)<<endl; // 8

cout<<sizeof(s2)<<endl; // 8

cout<<sizeof(s3)<<endl; // 9

cout<<sizeof(s4)<<endl; // 16;


s1和s2大小虽然都是8，但是s1的对齐方式是1，s2是8（double），所以在s3和s4中才有这样的差异。


所以，在自己定义结构体的时候，如果空间紧张的话，最好考虑对齐因素来排列结构体里的元素。

10、不要让double干扰你的位域


在结构体和类中，可以使用位域来规定某个成员所能占用的空间，所以使用位域能在一定程度上节省结构体占用的空间。不过考虑下面的代码：

struct s1

{

  int i: 8;

  int j: 4;

  double b;

  int a:3;

};

struct s2

{

  int i;

  int j;

  double b;

  int a;

};

struct s3

{

  int i;

  int j;

  int a;

  double b;

};

struct s4

{

  int i: 8;

  int j: 4;

  int a:3;

  double b;

};

cout<<sizeof(s1)<<endl;  // 24

cout<<sizeof(s2)<<endl;  // 24

cout<<sizeof(s3)<<endl;  // 24

cout<<sizeof(s4)<<endl;  // 16


可以看到，有double存在会干涉到位域（sizeof的算法参考上一节），所以使用位域的的时候，最好把float类型和double类型放在程序的开始或者最后。

** IO                                                                   :io:
*** [[http://c.biancheng.net/cpp/biancheng/view/2227.html][C++格式化输出，C++输出格式控制]] :blog:

在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采
取默认的格式，但有时希望数据按指定的格式输出，如要求以十六进制或八进制
形式输出一个 整数，对输出的小数只保留两位小数等。有两种方法可以达到此
目的。一种是我们已经介绍过的使用控制符的方法（详情请查看：C++输入cout
与输出cin）；第2种是使用流对象的有关成员函数。分别叙述如下。

**** 使用控制符控制输出格式

控制格式的使用方法这里不再赘述，仅举例说明，详情请查看：C++输入cout与
输出cin。

[例13.2] 用控制符控制输出格式。

#+BEGIN_EXAMPLE
#include <iostream>
#include <iomanip>//不要忘记包含此头文件
using namespace std;
int main()
{
   int a;
   cout<<"input a:";
   cin>>a;
   cout<<"dec:"<<dec<<a<<endl;  //以十进制形式输出整数
   cout<<"hex:"<<hex<<a<<endl;  //以十六进制形式输出整数a
   cout<<"oct:"<<setbase(8)<<a<<endl;  //以八进制形式输出整数a
   char *pt="China";  //pt指向字符串"China"
   cout<<setw(10)<<pt<<endl;  //指定域宽为,输出字符串
   cout<<setfill('*')<<setw(10)<<pt<<endl;  //指定域宽,输出字符串,空白处以'*'填充
   double pi=22.0/7.0;  //计算pi值
   //按指数形式输出,8位小数
   cout<<setiosflags(ios::scientific)<<setprecision(8);
   cout<<"pi="<<pi<<endl;  //输出pi值
   cout<<"pi="<<setprecision(4)<<pi<<endl;  //改为位小数
   cout<<"pi="<<setiosflags(ios::fixed)<<pi<<endl;  //改为小数形式输出
   return 0;
}
#+END_EXAMPLE

运行结果如下：
input a:34↙(输入a的值)
dec:34                   (十进制形式)
hex:22                   (十六进制形式)
oct:42                   (八进制形式)
         China               (域宽为)
*****China               (域宽为,空白处以'*'填充)
pi=3.14285714e+00        (指数形式输出,8位小数)
pi=3.1429e+00            (指数形式输出,4位小数)
pi=3.143                 (小数形式输出,精度仍为)

**** 用流对象的成员函数控制输出格式

除了可以用控制符来控制输出格式外，还可以通过调用流对象cout中用于控制输
出格式的成员函数来控制输出格式。用于控制输出格式的常用的成员函数见表
13.4。

表13.4 用于控输出格式的流成员函数

流成员函数	与之作用相同的控制符	作用
precision(n)	setprecision(n)	设置实数的精度为n位
width(n)	setw(n)	设置字段宽度为n位
fill(c)	setfill(c)	设置填充宇符c
setf()	setiosflags()	设置输出格式状态，括号中应给出格式状态，内容与控制符setiosflags括号中的内容相同，如表13.5所示
unsetf()	resetioflags()	终止已设置的输出格式状态，在括号中应指定内容

流成员函数setf和控制符setiosflags括号中的参数表示格式状态，它是通过格
式标志来指定的。格式标志在类ios中被定义为枚举值。因此在引用这些格式标
志时要在前面加上类名ios和域运算符“::”。格式标志见表13.5。


表13.5 设置格式状态的格式标志
格式标志	作用
ios::left	输出数据在本域宽范围内向左对齐
ios::right	输出数据在本域宽范围内向右对齐
ios::internal	数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充
ios::dec	设置整数的基数为10
ios::oct	设置整数的基数为8
ios::hex	设置整数的基数为16
ios::showbase	强制输出整数的基数(八进制数以0打头，十六进制数以0x打头)
ios::showpoint	强制输出浮点数的小点和尾数0
ios::uppercase	在以科学记数法格式E和以十六进制输出字母时以大写表示
ios::showpos	对正数显示“+”号
ios::scientific	浮点数以科学记数法格式输出
ios::fixed	浮点数以定点格式(小数形式)输出
ios::unitbuf	每次输出之后刷新所有的流
ios::stdio	每次输出之后清除stdout, stderr

[例13.3] 用流控制成员函数输出数据。

#+BEGIN_EXAMPLE
#include <iostream>
using namespace std;
int main( )
{
   int a=21
   cout.setf(ios::showbase);//显示基数符号(0x或)
   cout<<"dec:"<<a<<endl;         //默认以十进制形式输出a
   cout.unsetf(ios::dec);         //终止十进制的格式设置
   cout.setf(ios::hex);           //设置以十六进制输出的状态
   cout<<"hex:"<<a<<endl;         //以十六进制形式输出a
   cout.unsetf(ios::hex);         //终止十六进制的格式设置
   cout.setf(ios::oct);           //设置以八进制输出的状态
   cout<<"oct:"<<a<<endl;         //以八进制形式输出a
   cout.unseft(ios::oct);
   char *pt="China";              //pt指向字符串"China"
   cout.width(10);                //指定域宽为
   cout<<pt<<endl;                //输出字符串
   cout.width(10);                //指定域宽为
   cout.fill('*');                //指定空白处以'*'填充
   cout<<pt<<endl;                //输出字符串
   double pi=22.0/7.0;            //输出pi值
   cout.setf(ios::scientific);    //指定用科学记数法输出
   cout<<"pi=";                   //输出"pi="
   cout.width(14);                //指定域宽为
   cout<<pi<<endl;                //输出pi值
   cout.unsetf(ios::scientific); //终止科学记数法状态
   cout.setf(ios::fixed);        //指定用定点形式输出
   cout.width(12);               //指定域宽为
   cout.setf(ios::showpos);      //正数输出“+”号
   cout.setf(ios::internal);     //数符出现在左侧
   cout.precision(6);            //保留位小数
   cout<<pi<<endl;               //输出pi,注意数符“+”的位置
   return 0;
}
#+END_EXAMPLE

运行情况如下：
dec:21(十进制形式)
hex:0x15                 (十六进制形式,以x开头)
oct:025                  (八进制形式,以开头)
         China               (域宽为)
*****China               (域宽为,空白处以'*'填充)
pi=**3.142857e+00        (指数形式输出,域宽,默认位小数)
+***3.142857             (小数形式输出,精度为,最左侧输出数符“+”)

对程序的几点说明：

1) 成员函数width(n)和控制符setw(n)只对其后的第一个输出项有效。如：
    cout. width(6);
    cout <<20 <<3.14<<endl;
输出结果为 203.14

在输出第一个输出项20时，域宽为6，因此在20前面有4个空格，在输出3.14时，width (6)已不起作用，此时按系统默认的域宽输出（按数据实际长度输出）。如果要求在输出数据时都按指定的同一域宽n输出，不能只调用一次width(n)，而必须在输出每一项前都调用一次width(n>，上面的程序中就是这样做的。

2) 在表13.5中的输出格式状态分为5组，每一组中同时只能选用一种（例如dec、hex和oct中只能选一，它们是互相排斥的）。在用成员函数setf和控制符setiosflags设置输出格式状态后，如果想改设置为同组的另一状态，应当调用成员函数unsetf（对应于成员函数self）或resetiosflags（对应于控制符setiosflags），先终止原来设置的状态。然后再设置其他状态，大家可以从本程序中看到这点。程序在开始虽然没有用成员函数self和控制符setiosflags设置用dec输出格式状态，但系统默认指定为dec，因此要改变为hex或oct，也应当先用unsetf 函数终止原来设置。如果删去程序中的第7行和第10行，虽然在第8行和第11行中用成员函数setf设置了hex和oct格式，由于未终止dec格式，因此hex和oct的设置均不起作用，系统依然以十进制形式输出。

同理，程序倒数第8行的unsetf 函数的调用也是不可缺少的。

3) 用setf 函数设置格式状态时，可以包含两个或多个格式标志，由于这些格式标志在ios类中被定义为枚举值，每一个格式标志以一个二进位代表，因此可以用位或运算符“|”组合多个格式标志。如倒数第5、第6行可以用下面一行代替：
    cout.setf(ios::internal I ios::showpos);  //包含两个状态标志，用"|"组合

4) 可以看到：对输出格式的控制，既可以用控制符(如例13.2)，也可以用cout流的有关成员函数(如例13.3)，二者的作用是相同的。控制符是在头文件iomanip中定义的，因此用控制符时，必须包含iomanip头文件。cout流的成员函数是在头文件iostream 中定义的，因此只需包含头文件iostream，不必包含iomanip。许多程序人员感到使用控制符方便简单，可以在一个cout输出语句中连续使用多种控制符。

** C++11                                                             :cpp11:
*** auto
**** [[https://app.yinxiang.com/shard/s52/nl/11551545/7bb2be9a-d487-4905-9fcd-f69f48ecc287?title=%E3%80%90C%2B%2B11%E3%80%91%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94auto%E7%9A%84%E4%BD%BF%E7%94%A8%20-%20%E6%B8%85%E9%A3%8E%E5%B0%8F%E9%98%81%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET][auto关键字]]                                                     :auto:

有些高级特性知道即可，不需用完全掌握。

c++11中引入的auto主要有两种用途：
+ *自动类型推断*
+ *返回值占位*

auto在c++98中的标识临时变量的语义，由于使用极少且多余，在c++11中已被删
除。前后两个标准的auto，完全是两个概念。

**** [[http://blog.csdn.net/huang_xw/article/details/8760403][【C++11】新特性------auto的使用]]                                   :blog:

C++11中引入的auto主要有两种用途：自动类型推断和返回值占位。auto在C++98
中的标识临时变量的语义，由于使用极少且多余，在C++11中已被删除。前后两
个标准的auto，完全是两个概念。

***** 自动类型推断


auto自动类型推断，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推断，可以大大简化我们的编程工作。下面是一些使用auto的例子。

#+BEGIN_EXAMPLE
    #include <vector>
    #include <map>

    using namespace std;

    int main(int argc, char *argv[], char *env[])
    {
    //  auto a;                 // 错误，没有初始化表达式，无法推断出a的类型
    //  auto int a = 10;        // 错误，auto临时变量的语义在C++11中已不存在, 这是旧标准的用法。

        // 1. 自动帮助推导类型
        auto a = 10;
        auto c = 'A';
        auto s("hello");

        // 2. 类型冗长
        map<int, map<int,int> > map_;
        map<int, map<int,int>>::const_iterator itr1 = map_.begin();
        const auto itr2 = map_.begin();
        auto ptr = []()
        {
            std::cout << "hello world" << std::endl;
        };

        return 0;
    };

    // 3. 使用模板技术时，如果某个变量的类型依赖于模板参数，
    // 不使用auto将很难确定变量的类型（使用auto后，将由编译器自动进行确定）。
    template <class T, class U>
    void Multiply(T t, U u)
    {
       auto v = t * u;
    }
#+END_EXAMPLE

***** 返回值占位

#+BEGIN_EXAMPLE
    template <typename T1, typename T2>
    auto compose(T1 t1, T2 t2) -> decltype(t1 + t2)
    {
       return t1+t2;
    }
    auto v = compose(2, 3.14); // v's type is double
#+END_EXAMPLE

***** 使用注意事项

①我们可以使用valatile，pointer（*），reference（&），rvalue
reference（&&） 来修饰auto

#+BEGIN_EXAMPLE
    auto k = 5;
    auto* pK = new auto(k);
    auto** ppK = new auto(&k);
    const auto n = 6;
#+END_EXAMPLE

②用auto声明的变量必须初始化

#+BEGIN_EXAMPLE
    auto m; // m should be intialized
#+END_EXAMPLE

③auto不能与其他类型组合连用

#+BEGIN_EXAMPLE
    auto int p; // 这是旧auto的做法。
#+END_EXAMPLE

④函数和模板参数不能被声明为auto

#+BEGIN_EXAMPLE
    void MyFunction(auto parameter){} // no auto as method argument

    template<auto T> // utter nonsense - not allowed
    void Fun(T t){}
#+END_EXAMPLE

⑤定义在堆上的变量，使用了auto的表达式必须被初始化

#+BEGIN_EXAMPLE
    int* p = new auto(0); //fine
    int* pp = new auto(); // should be initialized

    auto x = new auto(); // Hmmm ... no intializer

    auto* y = new auto(9); // Fine. Here y is a int*
    auto z = new auto(9); //Fine. Here z is a int* (It is not just an int)
#+END_EXAMPLE

⑥以为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid

#+BEGIN_EXAMPLE
    int value = 123;
    auto x2 = (auto)value; // no casting using auto

    auto x3 = static_cast<auto>(value); // same as above
#+END_EXAMPLE

⑦定义在一个auto序列的变量必须始终推导成同一类型

#+BEGIN_EXAMPLE
    auto x1 = 5, x2 = 5.0, x3='r';  // This is too much....we cannot combine like this
#+END_EXAMPLE

⑧auto不能自动推导成CV-qualifiers（constant & volatile
qualifiers），除非被声明为引用类型

#+BEGIN_EXAMPLE
    const int i = 99;
    auto j = i;       // j is int, rather than const int
    j = 100           // Fine. As j is not constant

    // Now let us try to have reference
    auto& k = i;      // Now k is const int&
    k = 100;          // Error. k is constant

    // Similarly with volatile qualifer
#+END_EXAMPLE

⑨auto会退化成指向数组的指针，除非被声明为引用

#+BEGIN_EXAMPLE
    int a[9];
    auto j = a;
    cout<<typeid(j).name()<<endl; // This will print int*

    auto& k = a;
    cout<<typeid(k).name()<<endl; // This will print int [9]
#+END_EXAMPLE

*** lambda                                                         :lambda:
**** [[http://blog.csdn.net/augusdi/article/details/11773943][C++11中的匿名函数(lambda函数,lambda表达式)]]                     :blog:

这篇文章是根据维基百科整理来的,原文请看:[[http://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B][http://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B]]

C++11提供了对匿名函数的支持,称为Lambda函数(也叫Lambda表达式).
Lambda表达式具体形式如下:

[capture](parameters)->return-type{body}

如果没有参数,空的圆括号()可以省略.返回值也可以省略,如果函数体只由一条return语句组成或返回类型为void的话.形如:

 　 [capture](parameters){body}

下面举了几个Lambda函数的例子: 　　　　

#+BEGIN_EXAMPLE
    [](int x, int y) { return x + y; } // 隐式返回类型
    [](int& x) { ++x; }   // 没有return语句 -> lambda 函数的返回类型是'void'
    []() { ++global_x; }  // 没有参数,仅访问某个全局变量
    []{ ++global_x; }     // 与上一个相同,省略了()
#+END_EXAMPLE

可以像下面这样显示指定返回类型:

#+BEGIN_EXAMPLE
    [](int x, int y) -> int { int z = x + y; return z; }
#+END_EXAMPLE

在这个例子中创建了一个临时变量z来存储中间值.
和普通函数一样,这个中间值不会保存到下次调用.
什么也不返回的Lambda函数可以省略返回类型, 而不需要使用 -> void 形式.
Lambda函数可以引用在它之外声明的变量. 这些变量的集合叫做一个闭包.
闭包被定义在Lambda表达式声明中的方括号[]内.
这个机制允许这些变量被按值或按引用捕获.下面这些例子就是:

#+BEGIN_EXAMPLE
    []        //未定义变量.试图在Lambda内使用任何外部变量都是错误的.
    [x, &y]   //x 按值捕获, y 按引用捕获.
    [&]       //用到的任何外部变量都隐式按引用捕获
    [=]       //用到的任何外部变量都隐式按值捕获
    [&, x]    //x显式地按值捕获. 其它变量按引用捕获
    [=, &z]   //z按引用捕获. 其它变量按值捕获
#+END_EXAMPLE

接下来的两个例子演示了Lambda表达式的用法.

#+BEGIN_EXAMPLE
    std::vector<int> some_list;
    int total = 0;
    for (int i=0;i<5;++i) some_list.push_back(i);
    std::for_each(begin(some_list), end(some_list), [&total](int x)
    {
        total += x;
    });
#+END_EXAMPLE

此例计算list中所有元素的总和. 变量total被存为lambda函数闭包的一部分.
因为它是栈变量(局部变量)total的引用,所以可以改变它的值.

#+BEGIN_EXAMPLE
    std::vector<int> some_list;
      int total = 0;
      int value = 5;
      std::for_each(begin(some_list), end(some_list), [&, value, this](int x)
      {
        total += x * value * this->some_func();
      });
#+END_EXAMPLE

此例中total会存为引用, value则会存一份值拷贝. 对this的捕获比较特殊,
它只能按值捕获.
this只有当包含它的最靠近它的函数不是静态成员函数时才能被捕获.对protect和priviate成员来说,
这个lambda函数与创建它的成员函数有相同的访问控制.
如果this被捕获了,不管是显式还隐式的,那么它的类的作用域对Lambda函数就是可见的.
访问this的成员不必使用this->语法,可以直接访问.
不同编译器的具体实现可以有所不同,但期望的结果是:按引用捕获的任何变量,lambda函数实际存储的应该是这些变量在创建这个lambda函数的函数的栈指针,而不是lambda函数本身栈变量的引用.
不管怎样, 因为大数lambda函数都很小且在局部作用中,
与候选的内联函数很类似, 所以按引用捕获的那些变量不需要额外的存储空间.
如果一个闭包含有局部变量的引用,在超出创建它的作用域之外的地方被使用的话,这种行为是未定义的!
lambda函数是一个依赖于实现的函数对象类型,这个类型的名字只有编译器知道.
如果用户想把lambda函数做为一个参数来传递,
那么形参的类型必须是模板类型或者必须能创建一个std::function类似的对象去捕获lambda函数.使用
auto关键字可以帮助存储lambda函数,

#+BEGIN_EXAMPLE
    auto my_lambda_func = [&](int x) { /*...*/ };
    auto my_onheap_lambda_func = new auto([=](int x) { /*...*/ });
#+END_EXAMPLE

这里有一个例子,
把匿名函数存储在变量,数组或vector中,并把它们当做命名参数来传递

#+BEGIN_EXAMPLE
    #include<functional>
    #include<vector>
    #include<iostream>
    double eval(std::function<double(double)> f, double x = 2.0){return f(x);}
    int main()
    {
         std::function<double(double)> f0    = [](double x){return 1;};
         auto                          f1    = [](double x){return x;};
         decltype(f0)                  fa[3] = {f0,f1,[](double x){return x*x;}};
         std::vector<decltype(f0)>     fv    = {f0,f1};
         fv.push_back                  ([](double x){return x*x;});
         for(int i=0;i<fv.size();i++)  std::cout << fv[i](2.0) << "\n";
         for(int i=0;i<3;i++)          std::cout << fa[i](2.0) << "\n";
         for(auto &f : fv)             std::cout << f(2.0) << "\n";
         for(auto &f : fa)             std::cout << f(2.0) << "\n";
         std::cout << eval(f0) << "\n";
         std::cout << eval(f1) << "\n";
         return 0;
    }
#+END_EXAMPLE

一个没有指定任何捕获的lambda函数,可以显式转换成一个具有相同声明形式函数指针.所以,像下面这样做是合法的:

#+BEGIN_EXAMPLE
    auto a_lambda_func = [](int x) { /*...*/ };
    void(*func_ptr)(int) = a_lambda_func;
    func_ptr(4); //calls the lambda.
#+END_EXAMPLE

**** DONE [[https://app.yinxiang.com/shard/s52/nl/11551545/49063b6f-c21c-4663-9120-3bbf64c00fc7?title=C%2B%2B11%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0(lambda%E5%87%BD%E6%95%B0%2Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F)%20-%20Augusdi%E7%9A%84%E4%B8%93%E6%A0%8F%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET][C++匿名函数]]                                             :lambda:

- State "DONE"       from ""           [2015-12-06 日 11:28] \\
  仅限了解，需要时再查阅，反正也记不住

C++11提供了对匿名函数的支持,称为Lambda函数(也叫Lambda表达式). Lambda表
达式具体形式如下:

#+begin_latex
\begin{minted}[frame=leftline, mathescape]{text}
[capture](parameters)->return-type{body}
\end{minted}
#+end_latex

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{cpp}
  [](int i){return i%2;}
  \end{minted}
#+end_latex
　　　　

*** [[http://noalgo.info/790.html][C++11多线程]]                                               :blog:thread:

**** 多线程

C++11中使用多线程非常简单，直接使用头文件thread中的thread类型即可创建一个线程，具体例子如下所示，该程序是一个多线程版本的Hello
World程序。
 注意，这里使用了C++11中的lambda匿名函数，如果对此不是很了解，请先阅读
[[http://noalgo.info/787.html][C++11中的lambda表达式]]。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    using namespace std;

    int main()
    {
      //线程函数无参数
        thread t([](){ cout << "Hello World!" << endl; });
        t.join(); //t1线程调用t2.join()，表示t1要等到t2结束后才能继续执行
    }
#+END_EXAMPLE

这里涉及到多线程环境中父子线程的关系问题。一般操作系统中，当主线程执行完毕退出时，无论子线程是否执行完毕，所有的子线程都会终止。而当子线程先退出时，无论是执行完毕正常退出还是以其他方式异常终止，线程均会进入终止态（僵死态），此时线程分配的系统资源还没有释放，线程仍作为一个线程实体存在于操作系统中。如果我们就这样不管这个子线程，那么它占用的系统资源（如动态申请的内存、打开的文件等）将一直被占据，造成资源的浪费。此时可以通过定义以下两种父子线程关系进行解决：

- 可会和（joinable）：主线程必须显示等待子线程，只有子线程结束后，主线程才继续执行后面的操作。
- 相分离（detached）：父子线程分离，主线程无须等待子线程完成，子线程一旦进入终止态后系统立即销毁线程以及回收资源。

以上的线程函数是无参数的，C++中还可以方便地给线程函数传递参数.

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    using namespace std;

    int main()
    {
        //线程函数带参数，传值
        thread t([](string s){ cout << s << endl; }, "Hello World!");
        t.join();
    }
#+END_EXAMPLE

以上带参数的线程函数是按值传递的，如果需要按引用传递，则使用方法稍微有点不同。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    using namespace std;

    int main()
    {
        int i = 0;
        //线程函数带参数，传引用
        thread t([](int &x){ cout << x++ << endl; }, ref(i)); //需要使用std::ref
        t.join();
        cout << i << endl;
    }
#+END_EXAMPLE

thread头文件的this_thread命名空间定义了几个有用的函数：

- get_id：返回当前的线程id。
- yield：在处于等待状态时，可以让调度器先运行其他可用的线程。
- sleep_for：阻塞当前线程，时间不少于参数指定的时间。
- sleep_util：阻塞当前线程，时间为参数指定的时间。

简单的使用方法如下：

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    using namespace std;

    void f()
    {
        cout << "Thread ID: " << this_thread::get_id() << endl;
        this_thread::sleep_for(chrono::seconds(3));
    }

    int main()
    {
        thread t(f);
        t.join();
    }
#+END_EXAMPLE

**** 互斥锁

多线程编程一般避免不了同步的问题，C++11这里也提供了非常方便的方法来进行解决。标准中提供了一下四种互斥锁，分别是：

- Mutex：基本的Mutex类，提供了核心函数lock()和unlock()。
- Recursive_mutex：递归Mutex类，允许在同一个线程中对一个互斥量的多次请求。一般在项目模块分工中可以使用，这样即使其他人使用了同样的锁也不会导致死锁。
- Timed_mutex：定时递归Mutex类，除了递归，还可以在某个时间段里或者某个时刻到达之间获取该互斥量。当一个线程在临界区操作的时间非常长，可以用定时锁指定时间。
- Recursive_timed_mutex：定时递归Mutex类，综合timed_mutex和recuseive_mutex。

下面是一个使用基本锁的小例子，该程序会按顺序输出5对enter和leave，分别对应5个线程。如果注释掉函数f中mt的lock和unlock函数，则线程没有同步，此时先输出5句enter，然后5s后再输出5句leave。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <thread>
    #include <string>
    #include <mutex>
    #include <vector>
    using namespace std;

    mutex mt;

    void f()
    {
        mt.lock();
        cout << "Enter Critical Section" << endl;
        this_thread::sleep_for(chrono::seconds(5));
        cout << "Leave Critical Section" << endl;
        mt.unlock();
    }

    int main()
    {
        vector<thread> v(5);
        for (auto &i : v) i = thread(f);
        for (auto &i : v) i.join();
    }
#+END_EXAMPLE

**** 条件变量

条件变量condition_variable也可以进行线程之间的通信，当一个线程要等待另一个线程完成某个操作时，可以使用条件变量进行实现。条件变量可以将一个或多个线程进入阻塞状态，直到收到另外一个线程的通知，或者超时才能退出阻塞状态。

一个线程等待某个条件满足，其首先获得一个unique_lock锁。该锁将会传递给wait()方法，然后wait()方法会释放互斥量并将该线程暂停，直到条件变量得到相应的信号。当接受到信号，线程被唤醒后，该锁就又被重新获得了。

另外一个线程发送信号使得条件满足。其通过调用notify_one()来发送通知，会将处于阻塞状态的等待该条件获得信号的线程中的某一个线程（任意一个线程）恢复执行；还可以通过调用notify_all()将等待该条件的所以线程唤醒。

下面是一个使用条件变量的简单例子。该程序中f1等待某个条件，该条件在f2输出并且睡眠2s后才得到满足，之后f1才能够进行输出。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <mutex>
    #include <thread>
    #include <condition_variable>
    using namespace std;

    mutex mt;
    condition_variable cv;

    void f1()
    {
        unique_lock<mutex> lock(mt);
        cv.wait(lock);
        cout << "F1 says Hi" << endl;
    }

    void f2()
    {
        cout << "F2 says Hi" << endl;
        this_thread::sleep_for(chrono::seconds(2));
        cv.notify_all();
    }

    int main()
    {
        thread t1(f1);
        this_thread::sleep_for(chrono::seconds(2));
        thread t2(f2);
        t1.join(), t2.join();
    }
#+END_EXAMPLE

**** Future

C++11中的future是标准库提供的一种用于获取异步操作的结果的机制，其可以调用一个函数，然后转而做其他的事情，让函数自己在一边执行，当需要的时候再回过头来获取该函数计算的结果。另外，其还可以延迟异步操作中异常(Exception)的抛出。
 下面是一个简单的例子。

#+BEGIN_EXAMPLE
    #include <iostream>
    #include <future>
    using namespace std;

    int main()
    {
        future<int> f = async([]()->int { return 42; });
        this_thread::sleep_for(chrono::seconds(2));
        cout << "The answer to life the universe and everything is: " << f.get() << endl;
    }
#+END_EXAMPLE

*** [[http://blog.csdn.net/kof2001kop/article/details/7425186][在函数内定义“局部函数”]]                                         :blog:


在函数里也能定义函数？呵呵，这当然是不能的，但函数对象却是可以的。如果
用旧的方法去定义一个函数对象，那就还要自己先编写一个函数类，这样还不够
方便。

但C++11发布后，在函数内简便地定义“函数”（其实是函数对象）就成为了可
能：


#+BEGIN_EXAMPLE
    #include <iostream>

    int main()
    {
        auto a = [](){std::cout << "Lambda is flexible!";};
        a();    //MinGW或VC10.0通过编译，显示结果：Lambda is flexible!
        return 0;
    }
#+END_EXAMPLE

上面代码中的auto并不是旧标准中自动变量的意思（自动分配和自动释放空间），
它在C++11中赋予了新的功能：当变量被声明时，从变量的初始化值中推出并指
定变量的类型。Lambda由于产生的是无名的函数对象，所以它并不能直接在函数
中被调用。但如果“把这无名的函数对象起个别名”，那么就可以通过别名来调
用了。

不得不承认，新的标准C++11的确使C++的用法更灵活了，或者说能把繁杂的代码
简化了。

** C                                                                   :c:
*** assert                                                         :assert:

1. *macro*
2. <cassert> <assert.h>
3. if the argument expression equal zero,
   1) a *message* is written to standard error
   2) *abort* is called, terminating the program execution
4. message: assertion failed: expression, file /filename/, line /linenumber/
5. #define ndebug before #include  to disable.
6. *therefore,  this macro is designed to capture programming errors,
   not user or run-time error*

*** [[http://blog.csdn.net/hguisu/article/details/7470695][C语言中的宏定义]] :blog:



[[http://blog.csdn.net/hguisu/article/category/1080443][作者同类文章]]/X/

版权声明：本文为博主原创文章，未经博主允许不得转载。

***

1. 简单宏定义

简单的宏定义有如下格式：

[#define指令（简单的宏）]　　#define  标识符替换列表

替换列表是一系列的C语言记号，包括标识符、关键字、数、字符常量、字符串字面量、运算符和标点符号。当预处理器遇到一个宏定义时，会做一个
“标识符”代表“替换列表”的记录。在文件后面的内容中，不管标识符在任何位置出现，预处理器都会用替换列表代替它。

不要在宏定义中放置任何额外的符号，否则它们会被作为替换列表的一部分。一种常见的错误是在宏定义中使用 = ：

#+BEGIN_EXAMPLE
#define N = 100       /*** WRONG ***/
int a[N];            /* 会成为 int a[= 100]; */
#+END_EXAMPLE

在上面的例子中，我们（错误地）把N定义成一对记号（= 和100）。

在宏定义的末尾使用分号结尾是另一个常见错误：

#+BEGIN_EXAMPLE
#define N 100;       /*** WRONG ***/
int a[N];            /*    become int a[100;]; */
#+END_EXAMPLE

这里N被定义为100和;两个记号。

在一个宏定义中，编译器可以检测到绝大多数由多余符号所导致的错误。但不幸的是，编译器会将每一处使用这个宏的地方标为错误，而不会直接找到错误的根源------宏定义本身，因为宏定义已经被预处理器删除了。

简单的宏主要用来定义那些被Kernighan和Ritchie称为“明示常量”（manifest
constant）的东西。使用宏，我们可以给数值、字符和字符串命名。

#+BEGIN_EXAMPLE
    #define STE_LEN 80

    #defineTRUE     1

    #defineFALSE    0

    #definePI        3.14159

    #defineCR        '\r'

    #defineEOS       '\0'
#+END_EXAMPLE

使用#define来为常量命名有许多显著的优点：

1)
、 程序会更易读。一个认真选择的名字可以帮助读者理解常量的意义。否则，程序将包含大量的“魔法数”，使读者难以理解。

2)
、 程序会更易于修改。我们仅需要改变一个宏定义，就可以改变整个程序中出现的所有该常量的值。“硬编码的”常量会更难于修改，特别是有时候当他们以稍微不同的形式出现时。（例如，如果一个程序包含一个长度为100的数组，它可能会包含一个从0到99的循环。如果我们只是试图找到所有程序中出现的100，那么就会漏掉99。）

3)
、可以帮助避免前后不一致或键盘输入错误。假如数值常量3.14159在程序中大量出现，它可能会被意外地写成3.1416或3.14195。

虽然简单的宏常用于定义常量名，但是它们还有其他应用。

4)
、可以对C语法做小的修改。实际上，我们可以通过定义宏的方式给C语言符号添加别名，从而改变C语言的语法。例如，对于习惯使用Pascal的begin和end（而不是C语言的{和}）的程序员，可以定义下面的宏：

#+BEGIN_EXAMPLE
    #define BEGIN  {

    #define END    }
#+END_EXAMPLE

我们甚至可以发明自己的语言。例如，我们可以创建一个LOOP“语句”，来实现一个无限循环：

#define LOOP  for (;;)

当然，改变C语言的语法通常不是个好主意，因为它会使程序很难被其他程序员所理解。

5) 、对类型重命名。在5.2节中，我们通过重命名int创建了一个Boolean类型：

#+BEGIN_EXAMPLE
    #define BOOL int
#+END_EXAMPLE

虽然有些程序员会使用宏定义的方式来实现此目的，但类型定义（7.6节）仍然是定义新类型的最佳方法。

6)
、控制条件编译。如将在14.4节中看到的那样，宏在控制条件编译中起重要的作用。例如，在程序中出现的宏定义可能表明需要将程序在“调试模式”下进行编译，来使用额外的语句输出调试信息：

#+BEGIN_EXAMPLE
    #define DEBUG
#+END_EXAMPLE

这里顺便提一下，如上面的例子所示，宏定义中的替换列表为空是合法的。

当宏作为常量使用时，C程序员习惯在名字中只使用大写字母。但是并没有如何将用于其他目的的宏大写的统一做法。由于宏（特别是带参数的宏）可能是程序中错误的来源，所以一些程序员更喜欢使用大写字母来引起注意。其他人则倾向于小写，即按照Kernighan和Ritchie编写的/The
C Programming Language/一书中的样式。

***

2. 带参数的宏

带参数的宏定义有如下格式：

[#define指令---带参数的宏]　　#define 标识符（/x/_{1},
/x/_{2},...,/x_{n}/）替换列表

其中/x/_{1},
/x/_{2},...,/x_{n}/是标识符（宏的参数）。这些参数可以在替换列表中根据需要出现任意次。

在宏的名字和左括号之间必须没有空格。如果有空格，预处理器会认为是在定义一个简单的宏，其中（/x/_{1},/x/_{2},...,/x_{n}/）是替换列表的一部分。

当预处理器遇到一个带参数的宏，会将定义存储起来以便后面使用。在后面的程序中，如果任何地方出现了标识符（/y/_{1},/y/_{2},...,/y_{n}/）格式的宏调用（其中/y/_{1},/y/_{2},...,/y_{n}/是一系列标记），预处理器会使用替换列表替代，并使用/y/_{1}替换/x/_{1}，/y/_{2}替换/x/_{2}，依此类推。

例如，假定我们定义了如下的宏：

#+BEGIN_EXAMPLE
    #define MAX(x,y)    ((x)>(y) ? (x) :(y))

    #define IS_EVEN(n)   ((n)%2==0)
#+END_EXAMPLE

现在如果后面的程序中有如下语句：

#+BEGIN_EXAMPLE
    i = MAX(j+k, m-n);

    if (IS_EVEN(i)) i++;
#+END_EXAMPLE

预处理器会将这些行替换为

#+BEGIN_EXAMPLE
    i = ((j+k)>(m-n)?(j+k):(m-n));
    if (((i)%2==0)) i++;
#+END_EXAMPLE

如这个例子所显示的，带参数的宏经常用来作为一些简单的函数使用。MAX类似一个从两个值中选取较大的值的函数。IS_EVEN则类似于另一种函数，该函数当参数为偶数时返回1，否则返回0。

下面的例子是一个更复杂的宏：

#+BEGIN_EXAMPLE
    #define TOUPPER(c)('a'<=(c)&&(c)<='z'?(c)-'a'+'A':(c))
#+END_EXAMPLE

这个宏检测一个字符c是否在'a'与'z'之间。如果在的话，这个宏会用'c'减去'a'再加上'A'，来计算出c所对应的大写字母。如果c不在这个范围，就保留原来的c。像这样的字符处理的宏非常有用，所以C语言库在<ctype.h>（23.4节）中提供了大量的类似的宏。其中之一就是toupper，与我们上面的TOUPPER例子作用一致（但会更高效，可移植性也更好）。

带参数的宏可以包含空的参数列表，如下例所示：

#+BEGIN_EXAMPLE
    #define getchar() getc(stdin)
#+END_EXAMPLE

空的参数列表不是一定确实需要，但可以使getchar更像一个函数。（没错，这就是<stdio.h>中的getchar，getchar的确就是个宏，不是函数------虽然它的功能像个函数。）

  *使用带参数的宏替代实际的函数的优点*：

1) 、
程序可能会稍微快些。一个函数调用在执行时通常会有些额外开销------存储上下文信息、复制参数的值等。而一个宏的调用则没有这些运行开销。

2) 、
宏会更“通用”。与函数的参数不同，宏的参数没有类型。因此，只要预处理后的程序依然是合法的，宏可以接受任何类型的参数。例如，我们可以使用MAX宏从两个数中选出较大的一个，数的类型可以是int，long
int，float，double等等。

 *但是带参数的宏也有一些缺点。*

1) 、
编译后的代码通常会变大。每一处宏调用都会导致插入宏的替换列表，由此导致程序的源代码增加（因此编译后的代码变大）。宏使用得越频繁，这种效果就越明显。当宏调用嵌套时，这个问题会相互叠加从而使程序更加复杂。思考一下，如果我们用MAX宏来找出3个数中最大的数会怎样？

#+BEGIN_EXAMPLE
    n = MAX(i, MAX(j,k));
#+END_EXAMPLE

下面是预处理后的这条语句：

#+BEGIN_EXAMPLE
    n=((i)>(((j)>(k)?(j):(k)))?(i):(((j)>(k)?(j):(k))));
#+END_EXAMPLE

2)
、宏参数没有类型检查。当一个函数被调用时，编译器会检查每一个参数来确认它们是否是正确的类型。如果不是，或者将参数转换成正确的类型，或者由编译器产生一个出错信息。预处理器不会检查宏参数的类型，也不会进行类型转换。

3)
、无法用一个指针来指向一个宏。如在17.7节中将看到的，C语言允许指针指向函数。这一概念在特定的编程条件下非常有用。宏会在预处理过程中被删除，所以不存在类似的“指向宏的指针”。因此，宏不能用于处理这些情况。

4)
、宏可能会不止一次地计算它的参数。函数对它的参数只会计算一次，而宏可能会计算两次甚至更多次。如果参数有副作用，多次计算参数的值可能会产生意外的结果。考虑下面的例子，其中MAX的一个参数有副作用：

#+BEGIN_EXAMPLE
    n = MAX(i++, j);
#+END_EXAMPLE

下面是这条语句在预处理之后的结果：

#+BEGIN_EXAMPLE
    n =((i++)>(j)?(i++):(j));
#+END_EXAMPLE

如果i大于j，那么i可能会被（错误地）增加了两次，同时n可能被赋予了错误的值。

由于多次计算宏的参数而导致的错误可能非常难于发现，因为宏调用和函数调用看起来是一样的。更糟糕的是，这类宏可能在大多数情况下正常工作，仅在特定参数有副作用时失效。为了自保护，最好避免使用带有副作用的参数。

带参数的宏不仅适用于模拟函数调用。他们特别经常被作为模板，来处理我们经常要重复书写的代码段。如果我们已经写烦了语句

#+BEGIN_EXAMPLE
    printf("%d"\n, x);
#+END_EXAMPLE

因为每次要显示一个整数x都要使用它。我们可以定义下面的宏，使显示整数变得简单些：

#+BEGIN_EXAMPLE
    #define PRINT_INT(x)    printf("%d\n", x)
#+END_EXAMPLE

一旦定义了PRINT_INT，预处理器会将这行

#+BEGIN_EXAMPLE
    PRINT_INT(i/j);
    //转换为
    printf("%d\n", i/j);
#+END_EXAMPLE

***

3. #运算符


 宏定义可以包含两个运算符：#和##。*编译器不会识别这两种运算符相反，它们会在预处理时被执行*。

#运算符将一个宏的参数转换为字符串字面量*(*字符串字面量（string
literal）是指双引号引住的一系列字符，双引号中可以没有字符，可以只有一个字符，也可以有很多个字符),，
简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号. 它仅允许出现在带参数的宏的替换列表中。（一些C程序员将#操作理解为“stringization（字符串化）”；其他人则认为这实在是对英语的滥用。）用比较官方的话说就是将语言符号(Token)转化为字符串。


#运算符有大量的用途，这里只来讨论其中的一种。假设我们决定在调试过程中使用PRINT_INT宏作为一个便捷的方法，来输出一个整型变量或表达式的值。#运算符可以使PRINT_INT为每个输出的值添加标签。下面是改进后的PRINT_INT：

#+BEGIN_EXAMPLE
    #define PRINT_INT(x) printf(#x " = %d\n", x)
#+END_EXAMPLE

x之前的#运算符通知预处理器根据PRINT_INT的参数创建一个字符串字面量。因此，调用

#+BEGIN_EXAMPLE
    PRINT_INT(i/j);
    //会变为
    printf("i/j" " = %d\n", i/j);
#+END_EXAMPLE

在C语言中相邻的字符串字面量会被合并，因此上边的语句等价于：

#+BEGIN_EXAMPLE
    printf("i/j = %d\n", i/j);
#+END_EXAMPLE

当程序执行时，printf函数会同时显示表达式i/j和它的值。例如，如果i是11，j是2的话，输出为

i/j = 5

TIPI例子：

#+BEGIN_EXAMPLE
    #define STR(x) #x

    int main(int argc char** argv)
    {
        printf("%s\n", STR(It's a long string)); // 输出 It's a long str
        return 0;
    }
#+END_EXAMPLE

***

4. ##运算符


 在C语言的宏中，"##"被称为 连接符（concatenator），*它是一种预处理运算符*，
用来把两个语言符号(Token)组合成单个语言符号。
这里的语言符号不一定是宏的变量。并且双井号不能作为第一个或最后一个元素存在.

##运算符可以将两个记号（例如标识符）“粘”在一起，成为一个记号。（无需惊讶，##运算符被称为“记号粘合”。）如果其中一个操作数是宏参数，“粘合”会在当形式参数被相应的实际参数替换后发生。考虑下面的宏：

如下例子:当MK_ID被调用时（比如MK_ID(1)），预处理器首先使用自变量（这个例子中是1）替换参数n。接着，预处理器将i和1连接成为一个记号（i1）。下面的声明使用MK_ID创建了3个标识符：

#+BEGIN_EXAMPLE
    #define MK_ID(n) i##n
    int MK_ID(1), MK_ID(2), MK_ID(3);
    //预处理后声明变为：
    int i1, i2, i3;
#+END_EXAMPLE


##运算符不属于预处理器经常使用的特性。实际上，想找到一些使用它的情况是比较困难的。为了找到一个有实际意义的##的应用，我们来重新思考前面提到过的MAX宏。如我们所见，当MAX的参数有副作用时会无法正常工作。一种解决方法是用MAX宏来写一个max函数。遗憾的是，往往一个max函数是不够的。我们可能需要一个实际参数是int值的max函数，还需要参数为float值的max函数，等等。除了实际参数的类型和返回值的类型之外，这些函数都一样。因此，这样定义每一个函数似乎是个很蠢的做法。


 解决的办法是定义一个宏，并使它展开后成为max函数的定义。宏会有唯一的参数type，它表示形式参数和返回值的类型。这里还有个问题，如果我们是用宏来创建多个max函数，程序将无法编译。（C语言不允许在同一文件中出现两个同名的函数。）为了解决这个问题，我们是用##运算符为每个版本的max函数构造不同的名字。下面的例子：请注意宏的定义中是如何将type和_max相连来形成新函数名的。假如我们需要一个针对float值的max函数。

#+BEGIN_EXAMPLE
    #define GENERIC_MAX (type)           \
    type type##_max(type x,  type y)    \
    {                                      \
      return x > y ? x :y;              \
    }
    GENERIC_MAX(float)
#+END_EXAMPLE

//预处理器会将这行展开为下面的代码：
 float float_max(float x, float y) { return x > y ? x :y; }

再如：

#+BEGIN_EXAMPLE
    #define PHP_FUNCTION            ZEND_FUNCTION
    #define ZEND_FUNCTION(name)             ZEND_NAMED_FUNCTION(ZEND_FN(name))
    #define ZEND_FN(name) zif_##name
    #define ZEND_NAMED_FUNCTION(name)       void name(INTERNAL_FUNCTION_PARAMETERS)
    #define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value, zval **return_value_ptr, \
    zval *this_ptr, int return_value_used TSRMLS_DC

    PHP_FUNCTION(count);
#+END_EXAMPLE


 //  预处理器处理以后， PHP_FUCNTION(count);就展开为如下代码

#+BEGIN_EXAMPLE
    void zif_count(int ht, zval *return_value, zval **return_value_ptr,
            zval *this_ptr, int return_value_used TSRMLS_DC)
#+END_EXAMPLE

宏ZEND_FN(name)中有一个"##"，它的作用一如之前所说，是一个连接符，将zif和宏的变量name的值连接起来。
以这种连接的方式以基础，多次使用这种宏形式，可以将它当作一个代码生成器，这样可以在一定程度上减少代码密度，
我们也可以将它理解为一种代码重用的手段，间接地减少不小心所造成的错误。

***

5. 宏的通用属性

现在我们已经讨论过简单的宏和带参数的宏了，我们来看一下它们都需要遵守的规则。
 1)
、宏的替换列表可以包含对另一个宏的调用。例如，我们可以用宏PI来定义宏TWO_PI：
 #definePI      3.14159
 #defineTWO_PI  (2*PI)

当预处理器在后面的程序中遇到TWO_PI时，会将它替换成（2*PI）。接着，预处理器会重新检查替换列表，看它是否包含其他宏的调用（在这个例子中，调用了宏PI）。预处理器会不断重新检查替换列表，直到将所有的宏名字都替换掉为止。


 2)
、预处理器只会替换完整的记号，而不会替换记号的片断。因此，预处理器会忽略嵌在标识符名、字符常量、字符串字面量之中的宏名。例如，假设程序含有如下代码行：

#+BEGIN_EXAMPLE
    #define SIZE 256
    int BUFFER_SIZE;
    if (BUFFER_SIZE> SIZE)
       puts("Error ： SIZEexceeded");
    //预处理后，这些代码行会变为：
    int BUFFER_SIZE;
    if (BUFFER_SIZE> 256)
      puts("Error ：SIZEexceeded");
#+END_EXAMPLE

标识符BUFFER_ZISE和字符串"Error:SIZE
exceeded"没有被预处理影响，虽然它们都包含SIZE。

3)
、一个宏定义的作用范围通常到出现这个宏的文件末尾。由于宏是由预处理器处理的，他们不遵从通常的范围规则。一个定义在函数中的宏并不是仅在函数内起作用，而是作用到文件末尾。

4)
、宏不可以被定义两遍，除非新的定义与旧的定义是一样的。小的间隔上的差异是允许的，但是宏的替换列表（和参数，如果有的话）中的记号都必须一致。

5) 、宏可以使用#undef指令“取消定义”。#undef指令有如下形式：
 [#undef指令]　　#undef  标识符
 其中标识符是一个宏名。例如，指令
 #undef N

会删除宏N当前的定义。（如果N没有被定义成一个宏，#undef指令没有任何作用。）#undef指令的一个用途是取消一个宏的现有定义，以便于重新给出新的定义。

***

6. 宏定义中圆括号


在我们前面定义的宏的替换列表中有大量的圆括号。确实需要它们吗？答案是绝对需要。如果我们少用几个圆括号，宏可能有时会得到意料之外的------而且是不希望有的结果。*对于在一个宏定义中哪里要加圆括号有两条规则要遵守：*

首先，如果宏的替换列表中有运算符，那么始终要将替换列表放在括号中：

#define TWO_PI (2*3.14159)
 其次，如果宏有参数，每次参数在替换列表中出现时都要放在圆括号中：
 #define SCALE(x) ((x)*10)

没有括号的话，我们将无法确保编译器会将替换列表和参数作为完整的表达式。编译器可能会不按我们期望的方式应用运算符的优先级和结合性规则。

为了展示为替换列表添加圆括号的重要性，考虑下面的宏定义，其中的替换列表没有添加圆括号：
 #define TWO_PI 2*3.14159
   /* 需要给替换列表加圆括号 */
 在预处理时，语句
 conversion_factor = 360/TWO_PI;
 //变为
 conversion_factor = 360/2*3.14159;
 除法会在乘法之前执行，产生的结果并不是期望的结果。

当宏有参数时，仅给替换列表添加圆括号是不够的。参数的每一次出现都要添加圆括号。例如，假设SCALE定义如下：
 #define SCALE(x) (x*10)   /* 需要给x添加括号 */
 在预处理过程中，语句
 j = SCALE(i+1);
 变为
 j = (i+1*10);
 由于乘法的优先级比加法高，这条语句等价于
 j = i+10;
 当然，我们希望的是
 j = (i+1)*10;

在宏定义中缺少圆括号会导致C语言中最让人讨厌的错误。程序通常仍然可以编译通过，而且宏似乎也可以工作，仅在少数情况下会出错。

***

7. 创建较长的宏

***** 1. 较长的宏中的逗号运算符


在创建较长的宏时，逗号运算符会十分有用。特别是可以使用逗号运算符来使替换列表包含一系列表达式。例如，下面的宏会读入一个字符串，再把字符串显示出来：

#define ECHO(s) (get(s), puts(s))


gets函数和puts函数的调用都是表达式，因此使用逗号运算符连接它们是合法的。我们甚至可以把ECHO宏当作一个函数来使用：
 ECHO(str);   /* 替换为 (gets(str), puts(str)); */

除了使用逗号运算符，我们也许还可以将gets函数和puts函数的调用放在大括号中形成复合语句：
 #define ECHO(s)  { gets(s);  puts(s);  }
 遗憾的是，这种方式并不奏效。假如我们将ECHO宏用于下面的if语句：

#+BEGIN_EXAMPLE
    if (echo_flag)
      ECHO(str);
    else
      gets(str);
    //将ECHO宏替换会得到下面的结果：
    if (echo_flag)
      { gets(str); puts(str);  };
    else
      gets(str);
#+END_EXAMPLE


 编译器会将头两行作为完整的if语句：

#+BEGIN_EXAMPLE
    if (echo_flag)
      { gets(str);  puts(str);  }
#+END_EXAMPLE


编译器会将跟在后面的分号作为空语句，并且对else子句产生出错信息，因为它不属于任何if语句。我们可以通过记住永远不要在ECHO宏后面加分号来解决这个问题。但是这样做会使程序看起来有些怪异。逗号运算符可以解决ECHO宏的问题，但并不能解决所有宏的问题。假如一个宏需要包含一系列的语句，而不仅仅是一系列的表达式，这时逗号运算符就起不到帮助的作用了。因为它只能连接表达式，不能连接语句。解决的方法是将语句放在do循环中，并将条件设置为假：

***** *2. 宏定义中的do-while循环do *

do循环必须始终随跟着一个分号，因此我们不会遇到在if语句中使用宏那样的问题了。为了看到这个技巧（嗯，应该说是技术）的实际作用，让我们将它用于ECHO宏中：

#+BEGIN_EXAMPLE
    #define ECHO(s)       \
          do{           \
               gets (s) ;      \
               puts (s) ;      \
          } while  (0)
#+END_EXAMPLE

当使用ECHO宏时，一定要加分号：
 ECHO(str);
   /* becomes do {  gets(str); puts(str); } while (0);  */
 为什么在宏定义时需要使用do-while语句呢?
我们知道do-while循环语句是先执行循环体再判断条件是否成立，
所以说至少会执行一次。当使用do{
}while(0)时由于条件肯定为false，代码也肯定只

 执行一次， 肯定只执行一次的代码为什么要放在do-while语句里呢?
这种方式适用于宏定义中存在多语句的情况。 如下所示代码：

#+BEGIN_EXAMPLE
    #define TEST(a, b)  a++;b++;

    if (expr)
        TEST(a, b);
    else
        do_else();
    代码进行预处理后，会变成：
    if (expr)
        a++;b++;
    else
        do_else();
#+END_EXAMPLE




这样if-else的结构就被破坏了if后面有两个语句，这样是无法编译通过的，那为什么非要do-while而不是简单的用{}括起来呢。
这样也能保证if后面只有一个语句。例如上面的例子，在调用宏TEST的时候后面加了一个分号，
虽然这个分号可有可无， 但是出于习惯我们一般都会写上。
那如果是把宏里的代码用{}括起来，加上最后的那个分号。 还是不能通过编译。
所以一般的多表达式宏定义中都采用do-while(0)的方式。

***** *3. "空操作"的定义*


了解了do-while循环在宏中的作用，再来看"空操作"的定义。在PHP源码中，由于PHP需要考虑到平台的移植性和不同的系统配置，
所以需要在某些时候把一些宏的操作定义为空操作。例如在sapi\thttpd\thttpd.c

文件中的VEC_FREE():

#+BEGIN_EXAMPLE
    #ifdef SERIALIZE_HEADERS
        # define VEC_FREE() smart_str_free(&vec_str)
    #else
        # define VEC_FREE() do {} while (0)
    #endif
#+END_EXAMPLE



这里涉及到条件编译，在定义了SERIALIZE_HEADERS宏的时候将VEC_FREE()定义为如上的内容，而没有定义时，
不需要做任何操作，所以后面的宏将VEC_FREE()定义为一个空操作，不做任何操作，通

 常这样来保证一致性， 或者充分利用系统提供的功能。

有时也会使用如下的方式来定义“空操作”，这里的空操作和上面的还是不一样，例如很常见的Debug日志打印宏：

#+BEGIN_EXAMPLE
    #ifdef DEBUG
    #   define LOG_MSG printf
    #else
    #   define LOG_MSG(...)
    #endif
#+END_EXAMPLE



在编译时如果定义了DEBUG则将LOG_MSG当做printf使用，而不需要调试，正式发布时则将LOG_MSG()宏定义为空，
由于宏是在预编译阶段进行处理的，所以上面的宏相当于从代码中删除了。


上面提到了两种将宏定义为空的定义方式，看上去一样，实际上只要明白了宏都只是简单的代码替换就知道该如何选择了。

***

8. 预定义宏

在C语言中预定义了一些有用的宏，*见*表预定义宏**。这些宏主要是提供当前编译的信息。宏__LINE__和__STDC__是整型常量，其他3个宏是字符串字面量。
 *表预定义宏:*
 __LINE__      被编译的文件的行数
 __FILE__      被编译的文件的名字
 __DATE__    编译的日期（格式"Mmm dd yyyy"）
 __TIME__    编译的时间（格式"hh:mm:ss"）
 __STDC__  如果编译器接受标准C，那么值为1



1)、 __DATE__宏和__TIME__宏指明程序编译的时间。例如，假设程序以下面的语句开始：

printf("Wacky Windows (c) 1996 Wacky Software, Inc.\n");

printf("Compiled on %s at %s\n", __DATE__,__TIME__);

 每次程序开始执行，程序都会显示下面两行：
 Wacky Windows (c) 1996 Wacky Software, Inc.
 Compiled on Dec 23 1996 at 22:18:48
 这样的信息可以帮助区分同一个程序的不同版本。

2)、我们可以使用__LINE__宏和__FILE__宏来找到错误。考虑下面这个检测被零除的除法的发生位置的问题。当一个C程序因为被零除而导致中止时，通常没有信息指明哪条除法运算导致错误。下面的宏可以帮助我们查明错误的根源：
 #define CHECK_ZERO(divisor)  \
   if (divisor == 0)  \
     printf("*** Attempt to divide byzero on line %d  "  \
             "of file %s  ***\n",__LINE__, __FILE__)
 CHECK_ZERO宏应该在除法运算前被调用：
 CHECK_ZERO(j);
 k = i / j;
 如果j是0，会显示出如下形式的信息：
 *** Attempt to divide by zero on line 9 of file FOO.c ***

类似这样的错误检测的宏非常有用。实际上，C语言库提供了一个通用的、用于错误检测的宏------assert宏
  再如：
 #line 838 "Zend/zend_language_scanner.c"

 #line预处理用于改变当前的行号（__LINE__）和文件名（__FILE__）。
如上所示代码，将当前的行号改变为838，文件名Zend/zend_language_scanner.c
它的作用体现在编译器的编写中，我们知道

 编译器对C 源码编译过程中会产生一些中间文件，通过这条指令，
可以保证文件名是固定的，不会被这些中间文件代替，有利于进行调试分析。



***

9. C语言中常用的宏

*01: 防止一个头文件被重复包含*

 #ifndef COMDEF_H
 #define COMDEF_H
 //头文件内容
 #endif
 *02: 重新定义一些类型*

防止由于各种平台和编译器的不同,而产生的类型字节数差异,方便移植。

typedef  unsigned char      boolean;     /* Boolean value type. */
 typedef  unsigned long int  uint32;      /* Unsigned 32 bit value */
 typedef  unsigned short     uint16;      /* Unsigned 16 bit value */
 typedef  unsigned char      uint8;       /* Unsigned 8  bit value */
 typedef  signed long int    int32;       /* Signed 32 bit value */
 typedef  signed short       int16;       /* Signed 16 bit value */
 typedef  signed char        int8;        /* Signed 8  bit value */

 //下面的不建议使用
 typedef  unsigned char     byte;         /* Unsigned 8  bit value type.
*/
 typedef  unsigned short    word;         /* Unsinged 16 bit value type.
*/
 typedef  unsigned long     dword;        /* Unsigned 32 bit value type.
*/
 typedef  unsigned char     uint1;        /* Unsigned 8  bit value type.
*/
 typedef  unsigned short    uint2;        /* Unsigned 16 bit value type.
*/
 typedef  unsigned long     uint4;        /* Unsigned 32 bit value type.
*/
 typedef  signed char       int1;         /* Signed 8  bit value type.
*/
 typedef  signed short      int2;         /* Signed 16 bit value type.
*/
 typedef  long int          int4;         /* Signed 32 bit value type.
*/
 typedef  signed long       sint31;       /* Signed 32 bit value */
 typedef  signed short      sint15;       /* Signed 16 bit value */
 typedef  signed char       sint7;        /* Signed 8  bit value */

 *03: 得到指定地址上的一个字节或字*
 #define  MEM_B(x) (*((byte *)(x)))
 #define  MEM_W(x) (*((word *)(x)))

*04: 求最大值和最小值*

#define  MAX(x,y) (((x)>(y)) ? (x) : (y))
 #define  MIN(x,y) (((x) < (y)) ? (x) : (y))

*05: 得到一个field在结构体(struct)中的偏移量*

#define FPOS(type,field) ((dword)&((type *)0)->field)

*06: 得到一个结构体中field所占用的字节数*
 #define FSIZ(type,field) sizeof(((type *)0)->field)

*07: 按照LSB格式把两个字节转化为一个Word*

#define FLIPW(ray) ((((word)(ray)[0]) * 256) + (ray)[1])

*08: 按照LSB格式把一个Word转化为两个字节*
 #define FLOPW(ray,val) (ray)[0] = ((val)/256); (ray)[1] = ((val) &
0xFF)

*09: 得到一个变量的地址（word宽度）*

#define B_PTR(var)  ((byte *) (void *) &(var))
 #define W_PTR(var)  ((word *) (void *) &(var))

 *10: 得到一个字的高位和低位字节*
 #define WORD_LO(xxx)  ((byte) ((word)(xxx) & 255))
 #define WORD_HI(xxx)  ((byte) ((word)(xxx) >> 8))

 *11: 返回一个比X大的最接近的8的倍数*
 #define RND8(x) ((((x) + 7)/8) * 8

*12: 将一个字母转换为大写*

#define UPCASE(c) (((c)>='a' && (c) <= 'z') ? ((c) -- 0×20) : (c))

*13: 判断字符是不是10进值的数字*

#define  DECCHK(c) ((c)>='0' && (c)<='9')

*14: 判断字符是不是16进值的数字*

#define HEXCHK(c) (((c) >= '0' && (c)<='9') ((c)>='A' && (c)<= 'F') \
 ((c)>='a' && (c)<='f'))

 *15: 防止溢出的一个方法*
 #define INC_SAT(val) (val=((val)+1>(val)) ? (val)+1 : (val))

 *16: 返回数组元素的个数*
 #define ARR_SIZE(a)  (sizeof((a))/sizeof((a[0])))

 *17: 返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2\^n)*
 #define MOD_BY_POWER_OF_TWO( val, mod_by ) ((dword)(val) &
(dword)((mod_by)-1))

 *18: 对于IO空间映射在存储空间的结构,输入输出处理*
 #define inp(port) (*((volatile byte *)(port)))
 #define inpw(port) (*((volatile word *)(port)))
 #define inpdw(port) (*((volatile dword *)(port)))
 #define outp(port,val) (*((volatile byte *)(port))=((byte)(val)))
 #define outpw(port, val) (*((volatile word *)(port))=((word)(val)))
 #define outpdw(port, val) (*((volatile dword
*)(port))=((dword)(val)))

 *19: 使用一些宏跟踪调试*
 ANSI标准说明了五个预定义的宏名。它们是：
 __LINE__
 __FILE__
 __DATE__
 __TIME__
 __STDC__

 C++中还定义了 __cplusplus

如果编译器不是标准的,则可能仅支持以上宏名中的几个,或根本不支持。记住编译程序也许还提供其它预定义的宏名。
 __LINE__ 及 __FILE__
宏指示，#line指令可以改变它的值，简单的讲，编译时，它们包含程序的当前行数和文件名。
 __DATE__
宏指令含有形式为月/日/年的串,表示源文件被翻译到代码时的日期。
 __TIME__ 宏指令包含程序编译的时间。时间用字符串表示，其形式为：
分：秒
 __STDC__
宏指令的意义是编译时定义的。一般来讲，如果__STDC__已经定义，编译器将仅接受不包含任何非标准扩展的标准C/C++代码。如果实现是标准的,则宏__STDC__含有十进制常量1。如果它含有任何其它数,则实现是非标准的。
 __cplusplus
与标准c++一致的编译器把它定义为一个包含至少6为的数值。与标准c++不一致的编译器将使用具有5位或更少的数值。

 可以定义宏,例如:当定义了_DEBUG,输出数据信息和所在文件所在行
 #ifdef _DEBUG
 #define DEBUGMSG(msg,date)
printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)
 #else
 #define DEBUGMSG(msg,date)
 #endif
 *20： 宏定义防止错误使用小括号包含。*
 例如：
 有问题的定义：#define DUMP_WRITE(addr,nr) {memcpy(bufp,addr,nr); bufp
+= nr;}
 应该使用的定义： #difne DO(a,b) do{a+b;a++;}while(0)
 例如：

#+BEGIN_EXAMPLE
    if(addr)
        DUMP_WRITE(addr,nr);
    else
        do_somethong_else();
    //宏展开以后变成这样:
    if(addr)
        {memcpy(bufp,addr,nr); bufp += nr;};
    else
        do_something_else();
#+END_EXAMPLE


 gcc
在碰到else前面的“；”时就认为if语句已经结束，因而后面的else不在if语句中。而采用do{}
while(0)的定义，在任何情况下都没有问题。而改为 #difne DO(a,b)
do{a+b;a++;}while(0) 的定义则在任何情况下都不会出错。

*** [[http://www.cnblogs.com/pharen/archive/2012/02/06/2340257.html][C语言的布尔类型]] :blog:

在C语言标准(C89)没有定义布尔类型，所以C语言判断真假时以0为假，非0为真。所以我们通常使用逻辑变量的做法：

#+BEGIN_EXAMPLE
    //定义一个int类型变量，当变量值为0时表示false，值为1时表示trueint flag;flag = 0;//......flag = 1;if( flag ){//......}
#+END_EXAMPLE



但这种做法不直观，而且没有明确flag一定是布尔值。所以我们又借助C语言的宏定义：

#+BEGIN_EXAMPLE
    //宏定义布尔类型#define BOOL int#define TRUE 1#define FALSE 0//定义一个布尔变量BOOL flag = FALSE;
#+END_EXAMPLE



这种方法虽然直观，但依然是换汤不换药，变量flag在编译器看来依然是int类型。

新版本总会改进一些不好的地方，所以在最新的C语言标准(C99)解决了布尔类型的问题。C99提供了_Bool
型，所以布尔类型可以声明为 _Bool flag。

_Bool依然仍是整数类型，但与一般整型不同的是，_Bool变量只能赋值为0或1，非0的值都会被存储为1。

C99还提供了一个头文件 <stdbool.h>
定义了bool代表_Bool，true代表1，false代表0。只要导入 stdbool.h
，就能非常方便的操作布尔类型了。

#+BEGIN_EXAMPLE
    //导入 stdbool.h 来使用布尔类型#include <stdbool.h>#include <stdio.h>//计算n!,n的值在main中定义int main(void){    int n = 10;    //计算叠乘数    int sum = 1; //用来存放叠乘的结果    bool flag = false;    //叠乘标记        int num = n;    //循环次数    while( !flag )    {        sum = sum * (num--);        //当num=1时结束循环        if( num == 1)        {            flag = true;        }    }    printf ("%d的叠乘值为 %d \n", n, sum);    return 0;}
#+END_EXAMPLE

** index                                                             :index:
*** srand
**** Initialize random number generator
void srand (unsigned int seed);
<cstdlib> (stdlib.h)

The pseudo-random number generator is initialized using the argument
passed as seed.

For every different seed value used in a call to srand, the
pseudo-random number generator can be expected to generate a different
succession of results in the subsequent calls to rand.

Two different initializations with the same seed will generate the
same succession of results in subsequent calls to rand.

If seed is set to 1, the generator is reinitialized to its initial
value and produces the same values as before any call to rand or
srand.

In order to generate random-like numbers, srand is usually initialized
to some distinctive runtime value, like the value returned by function
time (declared in header <ctime>). This is distinctive enough for most
trivial randomization needs.
** Miscellaneous
*** 几个C++线性函数开源库(Matrix)
+ boost/uBLAS
+ Eigen
+ Armadillo
+ blitz++
+ IT++
+ meschach
*** 函数return
1. 函数执行return语句后就会退出，可以利用这个特性在函数开始处进行异常
   处理。

2. 常见错误：遗漏返回值

   1) 函数的每个分支都应有一个返回值

   2) 如果函数包含if-else分支，要保证其中的每个分支都有返回值。

*** DONE atoll
- State "DONE"       from "TODO"       [2015-03-16 一 11:58]
- State "TODO"       from ""           [2015-03-16 一 11:27]
Reference:
+ http://www.cplusplus.com/reference/cstdlib/atoll/
+ http://blog.sina.com.cn/s/blog_674b5aae0100nqpt.html

**** atoll
long long int atoll ( const char * str );
Convert string to long long integer
Parses the C-string str interpreting its content as an integral number, which is returned as a value of type long long int.

This function operates like atol to interpret the string, but produces
numbers of type long long int (see atol for details on the
interpretation process).

**** Parameters
str: C-string containing the representation of an integral number.

**** Return Value
On success, the function returns the converted integral number as a
long long int value.

If no valid conversion could be performed, a zero value is returned.

If the converted value would be out of the range of representable
values by a long long int, it causes undefined behavior. See strtoll
for a more robust cross-platform alternative when this is a
possibility.
#+BEGIN_EXAMPLE
  /* atoll example */
  #include <stdio.h>      /* printf, fgets */
  #include <stdlib.h>     /* atoll */

  int main ()
  {
    long long int lli;
    char buffer[256];
    printf ("Enter a long number: ");
    fgets (buffer, 256, stdin);
    lli = atoll(buffer);
    printf ("The value entered is %lld. Its double is %lld.\n",lli,lli*2);
    return 0;
  }
#+END_EXAMPLE

Output:

#+BEGIN_EXAMPLE
  Enter a number: 9275806
  The value entered is 9275806. Its double is 18551612.
#+END_EXAMPLE

**** Data races
The array pointed by str is accessed.

**** Exceptions (C++)
No-throw guarantee: this function never throws exceptions.

If str does not point to a valid C-string, or if the converted value
would be out of the range of values representable by a long long int,
it causes undefined behavior.

**** See also
+ *atoi* Convert string to integer (function )
+ *atol* Convert string to long integer (function )
+ *strtoll* Convert string to long long integer (function )

**** 注:
atoll是c99标准加入的函数，在编译的时候可能要打开C99标准的编译选项 -std=c99。

另外，必须包含 *stdlib.h(C)* / *stdlib(C++)* 头文件，否则会出错。

*** rhs lhs                                                           :rhs:
lhs指的是==运算符左边的操作数 left hand side
rhs指的是==运算符右边的操作数 right hand side
运算符重载时常用

*** C++ 匿名函数                                                   :lambda:
http://blog.csdn.net/augusdi/article/details/11773943

c++11提供了对匿名函数的支持,称为lambda函数(也叫lambda表达式). lambda表
达式具体形式如下:
*[capture](parameters)->return-type{body}*

如果没有参数,空的圆括号()可以省略.返回值也可以省略,如果函数体只由一条
return语句组成或返回类型为void的话.形如:
*[capture](parameters){body}*

*** C++ 函数声明前的宏                                              :macro:

+ Windows api 经常这么干。。。

+ 对函数修饰。

+ *为了不同平台的可移植性，比如WINDOWS 的DLL*

+ Windows中dll导出的函数貌似需要特别说明，大概是为此准备的

**** Reference

+ [[http://bbs.chinaunix.net/thread-3578773-1-1.html]]

** Q&A                                                                  :qa:
*** *(int*)0=0                                                       :blog:

*（int *）0 = 0
C语言中(int *)表示将操作对象强制类型转换为int *类，即整形指针，这里是将0转换为int *，所以返回值还是0，不过类型发生了强制转换，成为int *型。你可以这样想象，有一个指向NULL的int *指针，和这个地方的(int *)0是等价的，因为当行ansi/iso-c99标准规定NULL指针为0x00000000，即内存中的“第0号地址”。


故意引发CPU异常,进入操作系统SEH处理。


0地址是linux系统内核特别定义的一个地址，专门指向空指针，用来捕捉空指针读写的错误。

** Project                                                          :project:
* Python                                                             :PYTHON:
** reference                                                      :homepage:

*** 教材                                                         :textbook:

- Python Programming for absolute beginner, Michael Dawson
- Learning python, Mark Lutz
- Practical Python, Magnus Lie Hetland
- Dive into Python, Mark Pilgrim
- Python standard Library, Fredrik Lundh
- Programming Python, Mark Lutz
- Python Essential Reference, David Beazley
- Python in a Nutshell, Alex Marteli
- Python and XML
- Jython Essential
- Game Programming with Python, Riley
- Python Web Programming, Steve Holden
- www.python.org/doc
- pydoc.org

** Fundamental
*** python install                                                :install:

- https://www.python.org/downloads/

version 3.5


READEM

#+BEGIN_EXAMPLE
  On Unix, Linux, BSD, OSX, and Cygwin:

      ./configure
      make
      make test
      sudo make install
#+END_EXAMPLE

**** 修改软链

#+BEGIN_EXAMPLE
  wally@ Python-3.5.1 $ python  --version
  Python 2.7.9
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/py
  pydoc3             python3            python3.5-config   python3.5m-config  pyvenv
  pydoc3.5           python3.5          python3.5m         python3-config     pyvenv-3.5
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/py
  pydoc3             python3            python3.5-config   python3.5m-config  pyvenv
  pydoc3.5           python3.5          python3.5m         python3-config     pyvenv-3.5
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/python /usr/bin/python
  [sudo] password for wally:
  ln: 无法创建符号链接"/usr/bin/python": 文件已存在
  wally@ Python-3.5.1 $ ls -l /usr/bin/python
  lrwxrwxrwx 1 root root 9  1月  9 16:07 /usr/bin/python -> python2.7
  wally@ Python-3.5.1 $ sudo rm /usr/bin/python
  wally@ Python-3.5.1 $ sudo ln -s /usr/local/bin/python3 /usr/bin/python
  wally@ Python-3.5.1 $ python --version
  Python 3.5.1
#+END_EXAMPLE

*** 环境变量                                                          :env:

执行以上操作后，Python会安装在 /usr/local/bin 目录中，Python库安装在
/usr/local/lib/pythonXX，XX为你使用的Python的版本号。

http://www.runoob.com/python/python-install.html

- PYTHONPATH :: PYTHONPATH是Python搜索路径，默认我们import的模块都会从
     PYTHONPATH里面寻找。

- PYTHONSTARTUP :: Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行
     此文件中变量指定的执行代码。

- PYTHONCASEOK :: 加入PYTHONCASEOK的环境变量, 就会使python导入模块的时
     候不区分大小写.

- PYTHONHOME :: 另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或
     PYTHONPATH目录中，使得两个模块库更容易切换。

*** 模块安装                                               :module:package:
+ http://www.douban.com/group/topic/40892505/

**** sys.append
自己写的模块，可以直接添加到路径下。这样就可以直接调用。
#+BEGIN_EXAMPLE
import sys
sys.path.append("/home/username/")
#+END_EXAMPLE

**** 单文件模块

直接把文件拷贝到$python_dir/lib

**** 网上下载的第三方库

一般解压后，找setup.py文件，运行python setup.py install。
#+BEGIN_EXAMPLE
     $ tar xfz MySQL-python-1.2.1.tar.gz
     $ cd MySQL-python-1.2.1
     $ # edit site.cfg if necessary
     $ python setup.py build
     $ sudo python setup.py install # or su first
#+END_EXAMPLE

**** egg文件                                                         :egg:
1) 下载ez_setup.py,运行python ez_setup
2) easy_install *.egg

**** pip                                                     :pip:

https://pypi.python.org/pypi/pip

Pip 是安装python包的工具，提供了安装包，列出已经安装的包，升级包以及卸
载包的功能。

Pip 是对easy_install的取代，提供了和easy_install相同的查找包的功能，因
此可以使用easy_install安装的包也同样可以使用pip进行安装。


***** 安装Pip

Pip的安装可以通过源代码包，easy_install或者脚本。

源代码方式：

#+BEGIN_EXAMPLE
  $ wget https://pypi.python.org/packages/source/p/pip/pip-1.2.1.tar.gz （替换为最新的包）
  $ tar xzf pip-1.2.1.tar.gz
  $ cd pip-1.2.1.tar.gz
  $ python setup.py install
#+END_EXAMPLE

easy_install:

#+BEGIN_EXAMPLE
  $ easy_install pip
#+END_EXAMPLE

get_pip.py 脚本：

#+BEGIN_EXAMPLE
  $ curl -0 https://raw.github.com/pypa/pip/master/contrib/get-pip.py
  $ sudo python get-pip.py
#+END_EXAMPLE

***** Pip的使用

1. 安装package
   #+BEGIN_EXAMPLE
     $ pip install Markdown
   #+END_EXAMPLE

2. 列出安装的packages
   #+BEGIN_EXAMPLE
     $ pip freeze
   #+END_EXAMPLE

3. 安装特定版本的package: 通过使用==, >=, <=, >, <来指定一个版本
   号。
   #+BEGIN_EXAMPLE
     $ pip install 'Markdown<2.0'
     $ pip install 'Markdown>2.0,<2.0.3'
   #+END_EXAMPLE

4. 升级包: 升级包到当前最新的版本，可以使用-U 或者 --upgrade
   #+BEGIN_EXAMPLE
     $ pip install -U Markdown
   #+END_EXAMPLE

5. 卸载包
   #+BEGIN_EXAMPLE
     $ pip uninstall Markdown
   #+END_EXAMPLE

6. 查询包
   #+BEGIN_EXAMPLE
     pip search "Markdown"
   #+END_EXAMPLE

7. *安装位置：~/.local/*

***** [[http://jyd.me/linux/pip-install-to-different-home/][pip 安装到指定位置]]

用户目录下面，.pip目录下建立pip.conf文件。

#+BEGIN_EXAMPLE
[install]
install-option=--prefix=~/.local
#+END_EXAMPLE

然后pip的库就安装到用户目录下的.local下面了

**** windows平台下，可以找对应python版本的exe安装包。            :windows:

比如，python2.7.3下 MySQL-python-1.2.3.win32-py2.7.exe，或
MySQL-python-1.2.3.win-amd64-py2.7.exe

*** [[http://www.douban.com/group/topic/40892505/][python安装模块的多种方法。]] :blog:

1、自己写的模块，可以直接添加到路径下。这样就可以直接调用。
import sys
sys.path.append("/home/username/")

2、单文件模块

直接把文件拷贝到$python_dir/lib

3、网上下载的第三方库，一般解压后，找setup.py文件
运行python setup.py install

4、 egg文件

1) 下载ez_setup.py,运行python ez_setup

2) easy_install *.egg

5、pip安装方法

Pip 是安装python包的工具，提供了安装包，列出已经安装的包，升级包以及卸载包的功能。

Pip 是对easy_install的取代，提供了和easy_install相同的查找包的功能，因此可以使用easy_install安装的包也同样可以使用pip进行安装。



安装Pip

Pip的安装可以通过源代码包，easy_install或者脚本。

下面介绍一下各种安装方法：

源代码方式：

$ wget https://pypi.python.org/packages/source/p/pip/pip-1.2.1.tar.gz （替换为最新的包）
$ tar xzf pip-1.2.1.tar.gz
$ cd pip-1.2.1.tar.gz
$ python setup.py install

easy_install:

$ easy_install pip

get_pip.py 脚本：

$ curl -0 https://raw.github.com/pypa/pip/master/contrib/get-pip.py

$ sudo python get-pip.py



OK, 下面来看一下Pip的使用

安装package

$ pip install Markdown

列出安装的packages

$ pip freeze

安装特定版本的package

通过使用==, >=, <=, >, <来指定一个版本号。

$ pip install 'Markdown<2.0'

$ pip install 'Markdown>2.0,<2.0.3'

升级包

升级包到当前最新的版本，可以使用-U 或者 --upgrade

$ pip install -U Markdown

卸载包

$ pip uninstall Markdown

查询包

pip search "Markdown"

6、特殊库的安装（一个科学计算库Enthought Python Distribution的安装）

Enthought Python Distribution在ubuntu下安装的测试，应一个网友的请求，问怎么安装这个库，从官方网站上下载了一个文件

epd_free-7.3-2-rh5-x86.sh，遮个文件是sh 格式的文件，用sudo bash epd_free-7.3-2-rh5-x86.sh 运行这个文件，出现很多权限的阅读，点回车，不要连续点

需要点一次看一下，最后出现一个同一不同一它的版权声明，输入"yes",再下来是让选择安装的目录，点回车，就安装在当前目录下。

这样就安装好了。

当前目录下输入

>>> ipython --pylab

就出来

Python 2.7.3 (default, Apr 20 2012, 22:44:07)
Type "copyright", "credits" or "license" for more information.

IPython 0.12.1 -- An enhanced Interactive Python.
? -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help -> Python's own help system.
object? -> Details about 'object', use 'object??' for extra details.

Welcome to pylab, a matplotlib-based Python environment [backend: TkAgg].
For more information, type 'help(pylab)'.

再这样调用。这个库由于我工作上用不上，所以也不需要进一步的研究。

In [1]: from scipy import *

In [2]: a=zeros(1000)

In 3]: a[:100]=1

In [4: b=fft(a)

In [5]: plot(abs(b))


7、windows平台下，可以找对应python版本的exe安装包。

比喻：python2.7.3下 MySQL-python-1.2.3.win32-py2.7.exe

或 MySQL-python-1.2.3.win-amd64-py2.7.exe

*** 如何查看当前Python安装的所有包                                   :module:
**** pip list                                                        :pip:
pip list

#+BEGIN_SRC sh :results output :export both
pip --help
#+END_SRC

#+RESULTS:
#+begin_example

Usage:
  pip <command> [options]

Commands:
  install                     Install packages. with -U,  update
  uninstall                   Uninstall packages.
  freeze                      Output installed packages in requirements format.
  list                        List installed packages.
  show                        Show information about installed packages.
  search                      Search PyPI for packages.
  wheel                       Build wheels from your requirements.
  zip                         DEPRECATED. Zip individual packages.
  unzip                       DEPRECATED. Unzip individual packages.
  help                        Show help for commands.
#+end_example


#+BEGIN_SRC sh :results output :export both
pip list
#+END_SRC

#+RESULTS:
#+begin_example
adium-theme-ubuntu (0.3.4)
apsw (3.8.2.post1)
apt-xapian-index (0.45)
arandr (0.1.7.1)
archmage (0.2.4)
astroid (1.3.6)
BeautifulSoup (3.2.1)
bzr (2.7.0.dev1)
catkin-pkg (0.2.8)
chardet (2.0.1)
CherryPy (3.2.2)
chm2pdf (0.9)
colorama (0.2.5)
command-not-found (0.3)
configobj (4.7.2)
cssselect (0.9.1)
cssutils (0.9.10)
cwiid (0.6.0)
debtagshw (0.1)
defer (1.0.6)
dirspec (13.10)
distribute (0.6.28)
dnspython (1.11.1)
docutils (0.11)
duplicity (0.6.23)
email (4.0.2)
empy (3.1)
enum (0.4.6)
feedparser (5.1.3)
flake8 (2.4.1)
html5lib (0.999)
httplib2 (0.8)
importmagic (0.1.3)
keyring (3.5)
launchpadlib (1.10.2)
lazr.restfulclient (0.13.3)
lazr.uri (1.0.3)
lockfile (0.8)
logilab-common (0.63.2)
lxml (3.3.3)
Mako (0.9.1)
Markdown (2.4)
MarkupSafe (0.18)
matplotlib (1.3.1)
mccabe (0.3)
mechanize (0.2.5)
mercurial (2.8.2)
MySQL-python (1.2.4b4)
netifaces (0.8)
nose (1.3.1)
numpy (1.8.2)
oauth (1.0.1)
oauthlib (0.6.1)
oneconf (0.3.7)
PAM (0.4.2)
paramiko (1.10.1)
pep8 (1.5.7)
pexpect (3.1)
Pillow (2.3.0)
pip (6.1.1)
piston-mini-client (0.7.5)
psutil (1.2.1)
PyAssimp (3.0.1264)
PyBluez (0.18)
pychm (0.8.4)
pycrypto (2.6.1)
pycups (1.9.66)
pycurl (7.19.3)
pydot (1.0.28)
pyflakes (0.8.1)
Pygments (1.6)
pygobject (3.12.0)
pygpgme (0.3)
pylint (1.4.3)
Pymacs (0.25)
pymongo (2.6.3)
PyOpenGL (3.0.2)
pyOpenSSL (0.13)
pyparsing (2.0.1)
pyserial (2.6)
pysmbc (1.0.14.1)
python-apt (0.9.3.5ubuntu1)
python-dateutil (1.5)
python-debian (0.1.21-nmu2ubuntu2)
pytz (2012rc0)
pyxdg (0.25)
PyYAML (3.10)
reportlab (3.0)
repoze.lru (0.6)
requests (2.2.1)
roman (2.0.0)
rope (0.10.2)
rosdep (0.11.2)
rosdistro (0.4.2)
rosinstall (0.7.5)
rospkg (1.0.35)
Routes (2.0)
SecretStorage (2.0.0)
sessioninstaller (0.0.0)
setuptools (3.3)
shadowsocks (2.8.2)
simplejson (3.3.1)
six (1.5.2)
software-center-aptd-plugins (0.0.0)
ssh-import-id (3.21)
system-service (0.1.6)
Twisted-Core (13.2.0)
Twisted-Web (13.2.0)
urllib3 (1.7.1)
uTidylib (0.2)
vboxapi (1.0)
vcstools (0.1.36)
VTK (5.8.0)
wadllib (1.3.2)
WebOb (1.3.1)
wstool (0.1.6)
wxPython (2.8.12.1)
wxPython-common (2.8.12.1)
xdiagnose (3.6.3build2)
zope.interface (4.0.5)
#+end_example

**** help('module')

#+BEGIN_SRC python :results output :export both
help('modules')
#+END_SRC

#+RESULTS:
#+begin_example

Please wait a moment while I gather a list of all available modules...

DEBUG:oneconf.distributor:get_distro: 'Ubuntu'
ANSI                archmod             heapq               resource
BaseHTTPServer      argparse            hgext               rexec
Bastion             array               hmac                rfc822
BeautifulSoup       ast                 hotshot             rlcompleter
BeautifulSoupTests  astroid             hpmudext            robotparser
CDROM               asynchat            html5lib            roman
CGIHTTPServer       asyncore            htmlentitydefs      rope
Canvas              atexit              htmllib             rosdep2
CommandNotFound     atk                 httplib             rosdistro
ConfigParser        audiodev            httplib2            rosinstall
Cookie              audioop             ibus                rospkg
Crypto              axi                 ihooks              routes
DLFCN               base64              imageop             runpy
Dialog              bdb                 imaplib             samba
DocXMLRPCServer     binascii            imghdr              scanext
FSM                 binhex              imp                 sched
FileDialog          bisect              importlib           screen
FixTk               bluetooth           importmagic         screenlayout
HTMLParser          bonobo              imputil             secretstorage
IN                  boost               indicator_keyboard  select
Image               bsddb               inspect             serial
ImageChops          bson                io                  sessioninstaller
ImageColor          bz2                 itertools           sets
ImageCrackCode      bzrlib              json                setuptools
ImageDraw           cPickle             keybinder           sgmllib
ImageEnhance        cProfile            keyring             sha
ImageFile           cStringIO           keyword             shadowsocks
ImageFileIO         cairo               launchpadlib        shelve
ImageFilter         calendar            lazr                shlex
ImageFont           catkin_pkg          ldb                 shutil
ImageGL             cgi                 lib2to3             signal
ImageGrab           cgitb               libxml2             simplejson
ImageMath           chardet             libxml2mod          sip
ImageOps            cherrypy            linecache           sipconfig
ImagePalette        chm                 linuxaudiodev       sipconfig_nd
ImagePath           chunk               locale              sipdistutils
ImageQt             cmath               lockfile            site
ImageSequence       cmd                 logging             sitecustomize
ImageStat           code                logilab             six
ImageTk             codecs              lsb_release         smbc
ImageWin            codeop              lxml                smtpd
MimeWriter          collections         macpath             smtplib
MySQLdb             colorama            macurl2path         sndhdr
ORBit               colorsys            mailbox             socket
OpenGL              commands            mailcap             softwarecenter_aptd_plugins
OpenSSL             compileall          mako                softwareproperties
PAM                 compiler            markdown            spwd
PIL                 configobj           markupbase          sqlite3
PSDraw              contextlib          markupsafe          sre
PngImagePlugin      cookielib           marshal             sre_compile
PyKate4             copy                math                sre_constants
PyQt4               copy_reg            matplotlib          sre_parse
PySide              crypt               mccabe              ssl
Queue               cssselect           md5                 stat
ScrolledText        cssutils            mechanize           statvfs
SimpleDialog        csv                 mercurial           string
SimpleHTTPServer    ctypes              mhlib               stringold
SimpleXMLRPCServer  cups                mimetools           stringprep
SocketServer        cupsext             mimetypes           strop
StringIO            cupshelpers         mimify              struct
TYPES               curl                mmap                subprocess
Tix                 curses              modulefinder        sunau
Tkconstants         cv                  mpl_toolkits        sunaudio
Tkdnd               cv2                 multifile           symbol
Tkinter             cwiid               multiprocessing     symtable
UbuntuSystemService datetime            mutex               sys
UserDict            dateutil            netifaces           sysconfig
UserList            dbhash              netrc               syslog
UserString          dbm                 new                 tabnanny
_LWPCookieJar       dbus                nis                 talloc
_MozillaCookieJar   deb822              nntplib             tarfile
__builtin__         debconf             nose                tdb
__future__          debian              ntdb                telnetlib
_abcoll             debian_bundle       ntpath              tempfile
_ast                debtagshw           nturl2path          termios
_bisect             decimal             numbers             test
_bsddb              defer               numpy               textwrap
_codecs             difflib             oauth               this
_codecs_cn          dircache            oauthlib            thread
_codecs_hk          dirspec             oneconf             threading
_codecs_iso2022     dis                 opcode              tidy
_codecs_jp          distlib             operator            time
_codecs_kr          distutils           optparse            timeit
_codecs_tw          dl                  os                  tkColorChooser
_collections        dns                 os2emxpath          tkCommonDialog
_csv                doctest             ossaudiodev         tkFileDialog
_ctypes             docutils            pango               tkFont
_ctypes_test        dot_parser          pangocairo          tkMessageBox
_curses             drv_libxml2         paramiko            tkSimpleDialog
_curses_panel       dsextras            parser              toaiff
_dbus_bindings      dumbdbm             pcardext            token
_dbus_glib_bindings dummy_thread        pdb                 tokenize
_elementtree        dummy_threading     pep8                trace
_functools          duplicity           pexpect             traceback
_hashlib            easy_install        pickle              ttk
_heapq              em                  pickletools         tty
_hotshot            email               pip                 turtle
_io                 encodings           pipes               twisted
_json               encutils            piston_mini_client  types
_locale             enum                pkg_resources       ubuntu_sso
_lsprof             errno               pkgutil             unicodedata
_markerlib          exceptions          platform            unittest
_md5                fcntl               plistlib            urllib
_multibytecodec     fdpexpect           popen2              urllib2
_multiprocessing    feedparser          poplib              urllib3
_mysql              filecmp             posix               urlparse
_mysql_exceptions   fileinput           posixfile           user
_osx_support        flake8              posixpath           uu
_psutil_linux       fnmatch             pprint              uuid
_psutil_posix       formatter           profile             validate
_pyio               fpectl              pstats              vboxapi
_random             fpformat            psutil              vcstools
_sha                fractions           pty                 vte
_sha256             ftplib              pwd                 vtk
_sha512             functools           pxssh               wadllib
_smbc               future_builtins     py_compile          warnings
_socket             gc                  pyassimp            wave
_sqlite3            gconf               pyclbr              weakref
_sre                gdbm                pycurl              webbrowser
_ssl                genericpath         pydoc               webob
_strptime           getopt              pydoc_data          whichdb
_struct             getpass             pydot               wsgiref
_symtable           gettext             pyexpat             wstool
_sysconfigdata      gi                  pyflakes            wx
_sysconfigdata_nd   gio                 pygments            wxPython
_testcapi           glib                pygst               wxversion
_threading_local    glob                pygtk               xapian
_tkinter            gnome               pygtkcompat         xdg
_warnings           gnomecanvas         pylab               xdiagnose
_weakref            gnomekeyring        pylint              xdrlib
_weakrefset         gnomevfs            pymongo             xml
_yaml               gobject             pynotify            xmllib
abc                 gpgme               pyparsing           xmlrpclib
aifc                gridfs              pytz                xxsubtype
antigravity         grp                 quopri              yaml
anydbm              gst                 random              zeitgeist
apsw                gstoption           re                  zipfile
apt                 gtk                 readline            zipimport
apt_inst            gtkunixprint        reportlab           zlib
apt_pkg             gtweak              repoze              zope
aptdaemon           gzip                repr
aptsources          hashlib             requests

Enter any module name to get more help.  Or, type "modules spam" to search
for modules whose descriptions contain the word "spam".

#+end_example

*** 下划线                                                       :underscore:

**** reference

+ [[http://python.jobbole.com/81129/][Python中的下划线]]
+ [[http://shahriar.svbtle.com/underscores-in-python][underscores in python]]

**** 在解释器中，表示上一条执行的语句的结果

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{text}
  >>> _
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  NameError: name '_' is not defined
  >>> 42
  42
  >>> _
  42
  >>> 'alright' if _ else ':('
  'alright'
  >>> _
  'alright'

  \end{minted}
#+end_latex

**** 作为一个临时变量, 不感兴趣，仅用来占位，以后也不会用到

#+begin_latex
\begin{minted}[frame=leftline, mathescape]{py}
rlist, _, _ = select.select([sys.stdin], [], [], 0.1)
\end{minted}
#+end_latex

**** 名称中的下划线

1. 名称前的单下划线： 表示“私有”属性

2. 名称前的双下划线： 对解释器有特殊意义，为了避免与子类定义的名称冲突
   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{text}
     >>> class A(object):
     ... def _internal_use(self):
       File "<stdin>", line 2
         def _internal_use(self):
           ^
     IndentationError: expected an indented block
     >>> class A(object):
     ...     def _internal_use(self):
     ...             pass
     ...     def __method_name(self):
     ...             pass
     ...
     >>> dir(A)
     ['_A__method_name', ... '_internal_use']

     \end{minted}
   #+end_latex

3. 名称前后的双下划线： Python中的特殊名称，惯例。

*** 在函数中导入模块 有什么好处
- State "DONE"       from "TODO"       [2015-12-04 五 09:53]
CLOCK: [2015-12-04 五 09:48]--[2015-12-04 五 09:53] =>  0:05
 <2015-12-03 四>
 [[file:~/Wally/Journal/Project/Python/termios/test.py::import%20termios,%20sys%20#%20%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97][file:~/Wally/Journal/Project/Python/termios/test.py::import termios,
 sys # 在函数中导入模块]]

**** Q & A
PEP 08 states:

*Imports are always put at the top of the file* , just after any
module comments and docstrings, and before module globals and
constants.

However if the class/method/function that I am importing is only used
in rare cases, surely it is more efficient to do the import when it is
needed?

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{py}
  class SomeClass(object):

      def not_often_called(self)
          from datetime import datetime
          self.datetime = datetime.now()
  more efficient than this?

  from datetime import datetime

  class SomeClass(object):

      def not_often_called(self)
          self.datetime = datetime.now()
  \end{minted}
#+end_latex


Anwser:


Module importing is quite fast, but not instant. This means that:

1. Putting the imports at the top of the module is fine, because it's
   a trivial cost that's only paid once.

2. Putting the imports within a function will cause calls to that
   function to take longer.

*So if you care about efficiency, put the imports at the top.* Only move
them into a function if your profiling shows that would help (you did
profile to see where best to improve performance, right??)

**** 小结

在文件开头处导入模块只会导入一次，而在函数中导入模块，每次调用函数时都
会导入一次（而且并不需要），所以关乎效率。

**** Reference

+ [[http://stackoverflow.com/questions/128478/should-python-import-statements-always-be-at-the-top-of-a-module][Stackoverflow: Should Python import statements always be at the top
  of a module]]

** syntax
*** with as                                                   :withas:with:

**** [[/suwei19870312/article/details/23258495][理解Python的With语句]]

***** With语句是什么？
Python’s with statement provides a very convenient way of dealing
with the situation where you have to do a setup and teardown to make
something happen. A very good example for this is the situation where
you want to gain a handler to a file, read data from the file and the
close the file handler.

有一些任务，可能事先需要设置，事后做清理工作。对于这种场景，Python的
with语句提供了一种非常方便的处理方式。一个很好的例子是文件处理，你需要
获取一个文件句柄，从文件中读取数据，然后关闭文件句柄。

Without the with statement, one would write something along the lines
of:

如果不用with语句，代码如下：

#+BEGIN_EXAMPLE
file = open("/tmp/foo.txt")
data = file.read()
file.close()
#+END_EXAMPLE

这里有两个问题。一是可能忘记关闭文件句柄；二是文件读取数据发生异常，没
有进行任何处理。

下面是处理异常的加强版本：

#+BEGIN_EXAMPLE
file = open("/tmp/foo.txt")
try:
    data = file.read()
finally:
    file.close()
#+END_EXAMPLE

虽然这段代码运行良好，但是太冗长了。这时候就是with一展身手的时候了。除
了有更优雅的语法，with还可以很好的处理上下文环境产生的异常。下面是with

#+BEGIN_EXAMPLE
with open("/tmp/foo.txt")
 as file: data = file.read()
#+END_EXAMPLE

***** with如何工作？

while this might look like magic, the way Python handles with is more
clever than magic. The basic idea is that the statement after with has
to evaluate an object that responds to an __enter__() as well as an
__exit__() function.

这看起来充满魔法，但不仅仅是魔法，Python对with的处理还很聪明。基本思想
是with所求值的对象必须有一个__enter__()方法，一个__exit__()方法。

After the statement that follows with is evaluated, the __enter__()
function on the resulting object is called. The value returned by this
function is assigned to the variable following as. After every
statement in the block is evaluated, the __exit__() function is
called.

紧跟with后面的语句被求值后，返回对象的__enter__()方法被调用，这个方法
的返回值将被赋值给as后面的变量。当with后面的代码块全部被执行完之后，将
调用前面返回对象的__exit__()方法。


This can be demonstrated with the following example:
下面例子可以具体说明with如何工作：

#+BEGIN_EXAMPLE
  #!/usr/bin/env
   python
  #
   with_example01.py


  class Sample:
      def __enter__(self):
          print "In
   __enter__()"
          return "Foo"

      def __exit__(self, type,
   value, trace):
          print "In
   __exit__()"


  def get_sample():
      return Sample()


  with
   get_sample() as sample:
      print "sample:",
   sample
#+END_EXAMPLE
运行代码，输出如下1234bash-3.2$

#+BEGIN_EXAMPLE
bash-3.2$
 ./with_example01.py
In
 __enter__()
sample:
 Foo
In
 __exit__()
#+END_EXAMPLE

As you can see,
The __enter__() function is executed
The value returned by it - in this case "Foo" is assigned to sample
The body of the block is executed, thereby printing the value of sample ie. "Foo"
The __exit__() function is called.
What makes with really powerful is the fact that it can handle
exceptions. You would have noticed that the __exit__() function for
Sample takes three arguments - val, type and trace. These are useful
in exception handling. Let’s see how this works by modifying the
above example.

正如你看到的，
1. __enter__()方法被执行
2. __enter__()方法返回的值 - 这个例子中是"Foo"，赋值给变量'sample'
3. 执行代码块，打印变量"sample"的值为 "Foo"
4. __exit__()方法被调用

with真正强大之处是它可以处理异常。可能你已经注意到Sample类的__exit__方
法有三个参数- val, type 和 trace。 这些参数在异常处理中相当有用。我们
来改一下代码，看看具体如何工作的。

#+BEGIN_EXAMPLE
  #!/usr/bin/env
   python
  #
   with_example02.py


  class Sample:
      def __enter__(self):
          return self

      def __exit__(self, type,
   value, trace):
          print "type:", type
          print "value:",
   value
          print "trace:",
   trace

      def do_something(self):
          bar = 1/0
          return bar + 10

  with
   Sample() as sample:
      sample.do_something()
#+END_EXAMPLE
Notice how in this example, instead of get_sample(), with takes
Sample(). It does not matter, as long as the statement that follows
with evaluates to an object that has an __enter__() and __exit__()
functions. In this case, Sample()’s __enter__() returns the newly
created instance of Sample and that is what gets passed to sample.

这个例子中，with后面的get_sample()变成了Sample()。这没有任何关系，只要
紧跟with后面的语句所返回的对象有__enter__()和__exit__()方法即可。此例
中，Sample()的__enter__()方法返回新创建的Sample对象，并赋值给变量
sample。

When executed:
代码执行后：
#+BEGIN_EXAMPLE
bash-3.2$
 ./with_example02.py
type:
 <type 'exceptions.ZeroDivisionError'>
value:
 integer division or modulo
 by zero
trace:
 <traceback object at 0x1004a8128>
Traceback
 (most recent call last):
  File "./with_example02.py",
 line 19, in <module>
    sample.do_something()
  File "./with_example02.py",
 line 15, in do_something
    bar = 1/0
ZeroDivisionError:
 integer division or modulo
 by zero
#+END_EXAMPLE

Essentially, if there are exceptions being thrown from anywhere inside
the block, the __exit__() function for the object is called. As you
can see, the type, value and the stack trace associated with the
exception thrown is passed to this function. In this case, you can see
that there was a ZeroDivisionError exception being thrown. People
implementing libraries can write code that clean up resources, close
files etc. in their __exit__() functions.

实际上，在with后面的代码块抛出任何异常时，__exit__()方法被执行。正如例
子所示，异常抛出时，与之关联的type，value和stack trace传给__exit__()方
法，因此抛出的ZeroDivisionError异常被打印出来了。开发库时，清理资源，
关闭文件等等操作，都可以放在__exit__方法当中。

Thus, Python’s with is a nifty construct that makes code a little
less verbose and makes cleaning up during exceptions a bit easier.

因此，Python的with语句是提供一个有效的机制，让代码更简练，同时在异常产
生时，清理工作更简单。

I have put the code examples given here on Github.
示例代码可以在Github上面找到。

译注：本文原文见 Understanding Python's "With" Statement

*** [[http://www.cnblogs.com/QLeelulu/archive/2009/09/20/1570292.html][Python的bool类型]]                                                 :blog:

写习惯了C#的代码，在想要将一个字符串'False'转换为bool型的时候，很自然的写了如下的Python代码：

[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_2.png][[[http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb.png]]]]

看到上面的结果了没？是True。突然记起Python中除了''、""、0、()、[]、{}、None为False之外，其他的都是True。也就是说上面的'False'就是一个不为空的字符串，所以结果就为True了。

为了深入了解下Python的bool类型，就看了下说明：

#+BEGIN_EXAMPLE
>>> help(True)
Help on bool object:

class bool(int)
 |  bool(x) -> bool
 |
 |  Returns True when the argument x is true, False otherwise.
 |  The builtins True and False are the only two instances of the class
bool.
 |  The class bool is a subclass of the class int, and cannot be
subclassed.
 |
 |  Method resolution order:
 |  bool
 |  int
 |  object
 |
 |  Methods defined here:
 |
 |  __and__(...)
 |  x.__and__(y) <==> x&y
 |
 |  __or__(...)
 |  x.__or__(y) <==> x|y
#+END_EXAMPLE

可以看到bool是int的子类来的，并且不可以子类化：

#+DOWNLOADED: http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_1.png @ 2016-01-25 17:19:21
 [[~/Wally/Journal/Figure/.org-download/Python                                                             :PYTHON:/image_thumb_1_2016-01-25_17:19:21.png]]]]

因为bool为int的子类，所以用1表示True，0表示False：

#+DOWNLOADED: http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_2.png @ 2016-01-25 17:19:26
 [[~/Wally/Journal/Figure/.org-download/Python                                                             :PYTHON:/image_thumb_2_2016-01-25_17:19:26.png]]]]

看到上面2==True是为false的。但是我们看下面的代码：

#+DOWNLOADED: http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_3.png @ 2016-01-25 17:19:30
 [[~/Wally/Journal/Figure/.org-download/Python                                                             :PYTHON:/image_thumb_3_2016-01-25_17:19:30.png]]]]

我们看到True被打印出来了，我想这样是因为if语句会在内部去调用bool()方法：

#+DOWNLOADED: http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_4.png @ 2016-01-25 17:19:34
 [[~/Wally/Journal/Figure/.org-download/Python                                                             :PYTHON:/image_thumb_4_2016-01-25_17:19:34.png]]]]

因为bool是继承自int类型的，所以我猜想在比较的时候最终是会转换为0和1来比较的，就像：

#+DOWNLOADED: http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_5.png @ 2016-01-25 17:19:40
 [[~/Wally/Journal/Figure/.org-download/Python                                                             :PYTHON:/image_thumb_5_2016-01-25_17:19:40.png]]]]

(注：这里只是猜想，未经证实)

既然bool是继承自int类型的所以很自然bool类型是支持数学运算的：

#+DOWNLOADED: http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_6.png @ 2016-01-25 17:19:44
 [[~/Wally/Journal/Figure/.org-download/Python                                                             :PYTHON:/image_thumb_6_2016-01-25_17:19:44.png]]]]

最后，我能想到的判断字符串是否有'False'的就是：

#+DOWNLOADED: http://images.cnblogs.com/cnblogs_com/QLeelulu/WindowsLiveWriter/Pythonbool_B3A/image_thumb_7.png @ 2016-01-25 17:19:47
 [[~/Wally/Journal/Figure/.org-download/Python                                                             :PYTHON:/image_thumb_7_2016-01-25_17:19:47.png]]]]

不知道是否有更好的方法呢？

*** Python 续行                                                      :blog:

变量的赋值是一条被分成了多行的命令, 用反斜线 (“\”) 作为续行符。 注意：

当一条命令用续行符 (“\”) 分割成多行时, 后续的行可以以任何方式缩近,
此时 Python 通常的严格的缩近规则无需遵守。

如果您的 Python IDE 自由对后续行进行了缩近, 您应该把它当成是缺省处理,
除非您有特别的原因不这么做。 严格地讲, 在小括号, 方括号或大括号中的表
达式 (如 定义一个 dictionary) 可以用或者不用续行符 (“\”) 分割成多行。
甚至在不是必需的时候, 我也喜欢使用续行符, 因为我认为这样会让代码读起来
更容易, 但那只是风格的问题。

** Tutorials                                                       :tutorial:
*** Python网络教程
**** python简介
***** What's Python?
python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣
诞节而编写的一门变成语言。

python提供了丰富完善的基础代码哭，覆盖了网络、文件、GUI、数据库、文本等大量
内容，被形象地称作“内置电池”（batteries included）。

除了内置的库外，Python还有大量的第三方库。

许多大型网站是用Python开发的，例如YouTube,Instgram,豆瓣等。很多大公司，包括
Google、Yahoo、NASA（美国航空航天局）都大量使用Python。

***** Python应用：
+ 网络应用，包括网络、后台服务等等
+ 日常需用的小工具，如脚本任务等
+ 把其它语言的程序再包装起来，方便使用
***** Python缺点
+ 速度慢
+ 代码不能加密

***** 第一个Python程序

在交互式环境下，Python类似Matlab.
$ print 'hello, world.‘      # print函数打印字符串
$ RET                        # 回车执行代码
Python使用但引号或双引号将字符串括起，但不能浑用。

$ exit()    # 退出Python交互式环境

***** 使用文本编辑器
window下推荐Sublime Text, UtralEdit 和Notepad++.哪个都好，但是绝对不能使用
word和windows自带的记事本，记事本会自作聪明地在文件开始的地方加上几个特殊字
符(UTF-8 BOM)，结果会导致程序出现莫名其妙的错误。

Python程序的后缀名为.py。

Linux下在.py文件首行加上
#!/usr/bin/env python
选择运行程序的解释器，可以直接运行Python程序。
$ chmod a+x hello.py        # 修改权限

***** 输入输出                                                       :io:
print()        # 输出函数
raw_input()    # 输入函数

**** python语法基础
***** 句法
Python采用缩进方式
Python使用#注释
当语句以冒号结束时，缩进语句视为代码块E
Python程序是大小写敏感的

关于缩进：
+ 好处是强迫你格式化代码，约定俗称的是，应该使用四个空格缩进
+ 另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若
  干函数，从而得到缩进较少的代码
+ 复制-粘贴失效，粘贴的代码必须检查缩进是否正确

***** Python数据类型

Python内置支持的数据类型包括整型、浮点型、字符串、布尔值、空值、变量、常量
等。

字符串是使用\进行转义。
r''表示内部字符默认不转义。
'''..'''可格式化多行字符串

布尔型只有两个值：True和False。支持的运算包括and、or和not运算。

空值是Python里的一个特殊的是，用None表示。

Python语言中变量本身类型不固定，为动态语言，非墙类型语言，与Matlab类似。

常量名通常全部大写。

***** 字符串和编码                                      :string:encoding:
ASCII码是最早的编码表，涵盖127个字符，包括大小写英文字母，数字和一些符号。
中国汉字的编码为GB2312。
Unicode编码是为了解决这种编码方式不一导致多语言混合文本中显示乱码的问题。
Unicode将所有的语言都统一放在同一套编码中，其标准在不断发展，最常用的是两个
字节表示一个字符。现在大多数操作系统和编程语言都支持Unicode。

新的问题：对于全部是英文的文本，Unicode编码比ASCII编码需要多一倍的存储空间，
在存储和传输上不划算。
UTF-8编码为可变长编码，根据字符不同将其编码成1-6个字节。常用的英文被编码成
一个字节，汉字被编码成三个自己，只有很生僻的字符才会被编码为4-6个字节。

现代计算机系统通用的字符编码工作方式：在计算机内存中，统一使用unicode编码，
当需要保存到硬盘或者需要传输时，就转换为UTF-8。
用记事本编辑时，从文件中读取UTF-8字符并转换为Unicode字符存储在内存中，编辑
完成后保存时再转换为UTF-8把保存到文件。

Python的诞生早于Unicode标准。因此早期的Python只支持ASCII。
Python对Unicode的支持，以Unicode表示的字符串用u''表示。
字符串的encode(''utf-8)方法将编码转换为UTF-8编码。
len()函数返回字符串长度。
字符串的decode('utf-8')方法将UTF-8编码转换为Unicode编码。

由于Python源代码也是一个文本文件，所以当其中包含中文是，在保存源代码是就需
要务必制定保存为UTF-8编码。当Python解释起读取源代码是，为了让他按UTF-8编码
读取，通常需要在文件开头加上这两行。
#!/usr/bin/env python
# -*- coding: uft-8 -*-
第一行是为了告诉Linux/OS X系统，这是一个Python可执行程序，windows系统会忽略
这个注释；
第二行注释是为了告诉Python解释起，按照UTF-8编码读取代码
***** 格式化字符串                                               :string:
在Python中，格式化字符床的方式与C是一致的，用%实现。
常见的占位符有：
|----+--------------|
| %d | 整数         |
| %f | 浮点数       |
| %s | 字符串       |
| %x | 十六进制整数 |
|----+--------------|
当不确定使用什么占位符是， %s用呀u年起作用，它会把任何数据类型转换为字符串。

***** list                                                     :listings:
list是Python内置的一种数据类型，即线性列表。list是一种有序的集合，可以随时
添加或删除元素。
list类似Matlab中的数组，使用中括号初始化。
len()函数返回list的长度，即元素个数。
可以使用下标索引list的元素，索引从0开始。
当索引超出范围是，Python会报IndexError错误。
除了下标位置索引外，list还支持倒序索引，最后一个元素索引值-1,倒数第二个元素
所以-2,以此类推。
append(e)方法可以往list中追加元素e到末尾。
append(i,e)方法在指定位置追加元素e。
pop()方法删除list末尾元素。
pop(i)方法删除指定位置的元素。
使用直接赋值的方法，可以毛某个元素替换为其他值。
list里面的元素类型可以不同。
list的元素也可以是另外一个list。
[]是空list，不包含任何元素，长度为0。

与Matlab内置数组的对比：
  + matlab内置数组可以是多维，list只有一维；
  + 都支持动态扩展，但list需要使用特定方法，而matlab内置数组可以直接用下标进
    行扩展
  + matlab内置数组是数组，而list是链表（支持在特定位置插入）

***** tuple                                                       :tuple:
tuple也是Python内置的一种有序链表，使用小括号进行初始化，一旦初始化后，
tuple就不能修改。
因此，tuple没有append，insert等方法，可以通过下标索引，但不能赋值城另外元素。
这样做是为了使代码更加安全。
tuple在声明时必须初始化。
可以使用t=()定义空的tuple。
定义只有一个元素的tuple时需要一定技巧：
t = (1)    # 定义的不是tuple，而是1这个数。
t = (1,)   # Python在定义只有一个元素的tuple时必须加一个逗号，以消除歧义
# Python在显示时也会加一个逗号
当tuple中包含list元素时，该tuple即为可变的，可以使用list方法对list本身进行
修改。可以看出，所谓tuple的不变性，指的是其指向（指针）的不变性，而非绝对不
变。

***** 条件判断                                                       :if:
Python支持if/if...else.../if...elseif...else...等形式的条件判断。
注：python语句尾不需用使用分号表示结束，回车本身即表示结束，记住python是按
缩进进行语法编排。

***** 循环                                                          :for:
Python支持的循环有两种。
一种是for...in循环,依次把list或tuple中的每个元素迭代出来。
range(n)函数可以生成0-(n-1）的list。
第二种循环是while循环。
注：raw_input()函数返回的永远是字符串，在使用前需要按需进行类型转换。

***** dict                                                         :dict:
Python内置了字典，即对dict的支持，dict全程Dictionary,在其它语言中也称为map，
使用键-值（key-value）存储，具有极快的查找速度。
eg. d = {'Michael':95, 'Bob':75}
dict按照字典的方式进行查找，list按照线性方式进行查找，因此dict的查找效率要
远高于list，尤其是数据量大的时候。
dict按键值key索引，中括号括起。当索引键值不存在时，中断KeyError.
要避免KeyError,可以使用两种办法：
 + 通过in判断key是否存在， eg. 'Tom' in d  # 返回False
 + 使用dict的方法get(key),不存在时返回None，或get(key, Val)方法，不存在时返
   回Val

注：返回None时Python交互式命令行不现实结果。
pop(key)方法从dict中删除对应键值的元素。
dict内部存放的顺序与key放入的顺序没有关系。

dict和list的比较：
  + 查找和插入的速度极快，不会随着key增加而增加
  + 需要占用的内存多
即，dict是用空间换取时间的一种办法。

dict可以用在需要告诉查找的很多地方，在Python中几乎无处不在，正确使用dict十分
重要。需要牢记的第一条就是dict的key必须是*不可变对象*。因为dict使用哈希算法
（Hash）通过key计算位置。
在Python中，字符串、整数都是不可变对象，可以用作key，list是可变的，因而不能
用作key。

***** set                                                           :set:
set是一组key的集合，可以看成数学意义上的无序无重复的元素的集合。
set创建时使用list进行初始化，eg. s=set([1,2,3])
重复元素在set中会自动被过滤。
add(key)方法向set中添加元素。
remove(key)方法可以删除元素。
set可以做数学意义上的交集和并集，即 & 运算和 | 运算。
set和dict的唯一区别仅在于没有存储对应的value，set同样以不可变对象作为键。

***** 不可变对象
对于可变对象，如list，其操作会改变list内部的内容。
而对不可变对象，如str，其操作不会改变其内容。
eg. a = 'abc'
a.replace('a', 'A')  # 返回另外一个str对象，而不是改变a本身
即，对于不可变对象，调用对象自身方法，不会改变对象自身的内容，而是这些方法
创建新的对象并返回。

***** 函数                                                     :function:
数据类型转换的函数有int(), str(), unicode(),bool()等。
函数名其实就是一个函数对象的应用，完全可以把函数名赋给一个变量，相当于给这
个函数起了一个别名。  这个很有趣。
eg. a = abs   # 将变量a指向abs

****** 定义函数
  在Python中使用def语句定义一个函数，一次写出函数名、空号、参数、冒号，然后
  在缩进块中编写函数体，函数的返回值使用return语句返回。
  如果没有return语句，函数执行完毕后返回None。
****** 空函数
  def nop()：
    pass
  pass语句什么都不做，通常用作占位符，pass也可以用在其他语句中。
****** 参数检查
  调用函数是，如果参数个数不对，python解释器会自动检查出来，并抛出TypeError
  错误。
  而如果参数类型不对，Pyhon解释器则无法检查。因此，完善的函数定义需要对参数
  类型进行检查。
  eg.
     def my_abs(x):
         if not isinstance(x, (int, float))
             raise TypeError('Wrong operand type')
         if x >= 0:
             return x
         else:
             return -x
****** 多个返回值
  Python中函数可以返回多个值。
  但这是一种假象，实际上是通过tuple实现的，返回的仍然是单一值，只是书写起来
  方便。
****** 默认参数
Python函数定义支持默认参数。默认参数可以简化函数的调用。设置默认参数时，
需要注意：
  - 必选参数在前，默认参数在后
  - 当有多个默认参数时，变化大的参数放在前面，变化小的放在后面

默认参数最大的好处就是能降低函数调用的难度。
有多个默认参数是，调用是，既可以按顺序提供默认参数，也可以不按顺序提供部
分默认参数，此时需要把参数名写上。

默认参数使用不当会掉入陷阱。因为Python在定义函数的时候，默认参数L的值就被
计算出来了，默认参数也是一个变量。如果改变默认参数的内容，下次调用是，默
认参数就会改变。
所以，定义默认参数必须只想不变对象。
****** 可变参数
Python函数定义支持可变参数，只要在参数之前加上一个*号，在函数内部，该参数
接收到的就是一个tuple。调用时可向该参数传递任意个参数，包括0个参数。
list和tuple可以传递给可变参数，前面需要加上*
****** 关键字参数
关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部会自
动组装为dict.使用两个星号*后接参数名定义关键字参数。

在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这四
种参数可以任意组合使用，但参数定义的顺序必须是：必选参数，默认参数，可变
参数，关键字参数。
****** 递归
在函数内部可以调用其他函数。如果一个函数在内部调用函数自身，这个函数就是
递归函数。
Python递归支持递归。
递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环
的方式实现。
使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种
数据结构实现的，每当进入一个函数调用，栈就会增加一层栈帧，每当函数返回时，
栈就会减一层栈帧。由于栈的大小不是无限的，所以递归调用的次数过多会导致栈
溢出。
解决递归调用栈溢出的方法是通过尾递归优化，使递归本身无论调用多少次，都只
占用一个栈帧，不会出现栈溢出的情况。
遗憾的是，大多数变成语言没有对尾递归做优化，Python解释器也没有做优化，所
急，即使把函数改成尾递归方式，也会导致栈溢出。

***** 切片
Python通过切片进行范围索引，切片操作符为:(冒号)。
切片操作支持正序、逆序和定义增量。
list，tuple支持切片索引，返回对象。
字符串和Unicode字符串同样支持切片操作，返回结果仍是字符串。

***** 迭代
Python的for...in迭代(Iteration)的抽象程度要高于其他高级语言的for循环，不需
要通过下标完成，可以作用在list或tuple对象，以及其它可迭代对象上，即使该对象
是没有下标的，比如dict。

****** 字典的迭代
  for key in d    # 按关键字迭代
  for value in d.itervalues()    # 按值迭代
  for key, value in d.iteritems()    # 按关键字和值迭代

****** 字符串的迭代
  for ch in str

通过collections模块的Iterable类型可以判断一个对象是否为可迭代对象。
eg.    isinstance('abc', Iterable)    # True

enumerate()函数可以把一个list对象变成索引-元素对。
eg.  for i, value in enumerate(['a', 'b', 'c'])

***** 列表生成式
列表生成式可以用一行语句代替使用循环生成列表。
eg.  [x * x for x in range(1, 11)]
列表生成式还可以加上if判断
eg.  [x*x for x in range(1,11) if x%2 == 0]
可以使用两层循环的列表生成式，生成全排列。
eg.  [m+n for m in 'ABC' for n in 'XYZ']
三层和三层以上的循环就很少用到了。

运用列表生成式可以写出非常简洁的代码。
eg.  import os    # 导入os模块
[d for d in os.listdir('.')]    # 列出文件和目录

for循环可以同时使用两个甚至多个变量，因此列表生成式也可以使用两个变量生成
list
eg.  [k, v for k, v in d.iteritems()]

字符串的lower()方法将所有字符变成小写，对应应该有upper()方法。
使用内建的isinstance函数可以判断一个变量是不是字符串。
eg.  isinstance('123', str)

***** 生成器
如果列表元素可以按照某种算法推算出来，那么就可以在循环过程中不断推算出后续的元素，
这样就不必创建完整的list，从而节省空间。在Pthon中，这种一边循环一边计算的机制成
为*生成器（Generator）*
原因之一在于Python较其它语言高级，for...in循环中使用可迭代变量，如list,tuple等，
而不是索引值。

Python中创建generator有很多方法。
其中之一，只要把列表生成式的[]改为()即可
eg.   g = (x*x for x in range(10))

使用next()方法可以依次遍历generator中的列表元素。generator保存的是算法，每次调用
next()就会计算下一个元素的值，知道计算到最后一个元素，没有更多的元素时，抛出
StopIteration错误。
使用next()方法比较笨拙。由于generator是可迭代变量，因此可以使用for循环进行遍历。

当算法复杂使用列表生成式形式无法实现generator时，可以使用函数实现，这是创建
generator的另一中方法。
比如，斐波那契数列
    def fib(max)
        n, a, b = 0, 0, 1
        while n<max
            yeild b
            a, b = b, a+b
            n = n+1
generator使用yield关键字。这与一般函数的执行流程不一样。generator生成函数，在每
次调用next()时会执行，遇到yield语句返回，再次执行是从上次返回的yield语句处继续执
行。

***** 函数式编程

函数是Python内建支持的一种封装，通过把大段代码拆成函数，通过一层一层的函数调用，
就可以把复杂的任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数是
面向过程设计的基本单元。

计算机(Computer)和计算(Compute)
在计算机层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，汇编
语言是最贴近计算机的语言。
而计算是指数学意义上的计算，越是抽象的计算，离计算机硬件越远。

对应到编程语言，就是越低级的语言，越贴机计算机，抽象程度越低，执行效率越高，如C。
越高级的语言，越贴机计算，抽象程度越高，执行效率越低，如lisp语言。

函数式编程（Functional Programming）是一种抽象程度很高的编程范式，纯粹的函数式编
程语言没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数
没有副作用。
函数式编程的一个特点就是，允许函数本身作为参数传递给另外一个函数，还允许返回一个
函数。

Python对函数式编程提供部分支持。
***** 高阶函数（higher-order function）

函数本身可以赋值给变量，即，变量可以指向函数。
函数名本身也是变量，是指向函数的变量。
因此，函数名可以作为一个变量传递给另外一个函数。
一个函数接收另外一个函数作为参数，这种函数称之为高阶函数。
把函数作为参数传递，这样的函数成为高阶函数，这是一种函数式编程范式。
***** map/reduce
map是典型的高阶函数之一。map()函数接收两个参数，第一个是函数，第二个是序列，map
将传入的函数依次作用到序列的每一个元素，并把结果作为新的list返回。

reduce函数接收两个参数，第一个参数是函数，第二个参数是序列。作为参数传递的函数接
必须接收两个参数，reduce把该函数依次累积作用到序列上。
eg.  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
***** filter

filter()函数接收一个函数和一个序列，将传入的函数依次作用于列表的每一个元素，然后
根据返回值是True还是False决定保留还是丢弃该元素。
可见，filter()这个高阶函数，关键在于正确实现一个“筛选”函数。
***** sort

排序也是程序中经常用到的算法。无论是使用冒泡排序还是快速排序，排序的核心是比较两
个元素的大小。数字可以直接比较，但是其他类型变量如字符串、dict等，直接对其进行比
较是没有数学意义的，因此比较的机制必须通过函数抽象出来。
通常规定，对于两个元素，如果x>y，则返回1;如果x==y,则返回0;如果x<y,则返回-1。这样，
排序算法就不用关心具体的比较过程，而是根据比较的结果直接排序。

Python内置的sorted()函数可以直接对list进行排序。
同时，sorted()也是一个高阶函数，她可以接收一个比较函数作为第二个参数，来实现对第
一个参数（列表）的自定义排序。

***** 返回函数

高阶函数除了可以接收函数作为参数外，还可以把函数作为结果返回。
***** 匿名函数

当我们在传递函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。
eg.  map(lambda x : x*x, [1,2,3])
关键字lambda表示匿名函数，冒号前面的变量表示函数参数。
匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的计算结
果。
用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个
函数对象，因此可以吧匿名函数赋值个一个变量，在利用该变量调用该函数。
同样，也可以把匿名函数作为返回值返回。

Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数
***** 装饰器
函数对象有一个_name_属性，可以拿到函数的名字。

本质上，装饰器就是一个返回函数的高阶函数。
使用Python中的@语法，把decorator至于函数的定义处
***** 偏函数                                                    :partial:

Python的functools模块提供了很多有用的功能，其中一个就是偏函数(Partial function).
eg.    import functools
       int2 - functools.partial(int, 2)
functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），
返回一个新函数，调佣这个函数会更便捷。

创建偏函数时，实际上可以接收函数对象、 *args和 **kw这三个参数。

***** 模块                                                       :module:

为了编写可维护的代码，我们把很多函数分组，分别放在不同的文件里，这样每个文件中包
含的代码就相对较少，很多编程语言都采用这种组织代码的方式，在Python中，一个.py文
件就称之为一个模块(Module).
使用模块最大的好处就是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一
个模块编写完成后，就可以被其他地方引用。使用模块还可以避免函数名和变量名冲突，相
同名字的函数和变量完全可以分别存放在不同的模块之中。

为了避免模块名冲突，Python引入了按目录来组织模块的方法，称之为包(Package).
每个包目录下面都会有一个_init_.py文件，这个文件是必须存在的，否则，Python就会把
这个目录当作普通目录，而不是一个包。
可以有多级目录，组成多级层次的包结构。
***** 使用模块

模块的标准文件模板
#+BEGIN_EXAMPLE
  #!/usr/bin/env python              # 解释器
  # -*- coding: utf-8 -*-            # 编码方式
  ‘a test module’       # 任何模块代码的第一个字符串都被视为模块的文档注释
  __author__ = 'Ben'            # 作者名

  import sys                    # 导入模板

  def test():
      ……

  if __name__ == '__main__'
      test()

#+END_EXAMPLE


当在命令行运行hello模块文件时，Python解释器会把一个特殊变量__name__置为__main__，
而如果在其他地方导入该模块时。if判断将失效。因此，这种if测试可以让一个模块通过命
令行运行是执行一些额外的代码，最常见的就是运行测试。

导入模块时，可以使用别名。这样，可以在运行是根据当前环境选择最适合的模块。比如
Pyhton标准库一般会提供StringIO和cStringIO两个库，后者使用C写的，因而更快
try:
    import cStringIO as StringIO
except ImportErrir:
    import StringIO

作用域
有些函数和变量我们希望仅在模块内部使用，在Python中，是通过_前缀实现的。这是编程
习惯上的约定俗成，而不是强制性的不可访问。
特殊变量用__xxx__形式定义，可以被引用，但是有特殊用途。
***** 使用 *_future_*

Python提供了_future_模块,可以把新版本的特性导入到当前版本.
e.g.
Phthon 3.x中字符串均为Unicode编码,使用前缀b'string'表str
Phtyon 2.7中字符串为ASCII编码,使用前缀u'string'表unicode
#+BEGIN_EXAMPLE
  from _future_ import unicode_literals
  print '\'xxx\' is unicode?', isinstance('xxx', unicode)
  print 'u\'xxx\' is unicode?', isinstance(u'xxx', unicode)
  print '\'xxx\' is str?', isinstance('xxx', str)
  print 'b\'xxx\' is str?', isinstance(b'xxx', str)
#+END_EXAMPLE

e.g.
Python 2.x中除法为 *地板除*, 即整数相除,结果仍为整数.要做精确除法,必须
把其中一个写成浮点数.
Python 3.x中,所有的除法都是精确除法,地板除用 *//* 表示.
#+BEGIN_EXAMPLE
  from _future_ import division

  print '10 / 3 =', 10 / 3
  print '10.0 / 3 =', 10.0 / 3
  print '10 // 3 =', 10 // 3
#+END_EXAMPLE

**** 面向对象
***** *面向对象编程*
[[http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868200385680e8cf932dba9433ea367de9aba2b4784000#001414673847034cbe36eb363bd4a2eb91fee53912a7de7000][link]]
面向对象编程 *Object Oriented Programming*, 简称 *OOP*,是一种程序设计
思想.OOP把对象作为程序的基本单元,一个对象包含了数据和操作数据的函数.
在Python中,所有数据类型都可以视为对象,也可以自定义对象.
#+BEGIN_EXAMPLE
  # 面向过程
  std1 = {'name': 'Michael', 'score':98}
  std2 = {'name': 'Bob', 'score':81}
  def print_score(std):
      print '%s: %s ' % (std['name'], std['score'])

  # 面向对象
  class Student(object):
      def __init__(self, name, score):
          self.name = name
          self.score = score

      def print_score(self):
          print '%s: %s ' % (self.name, self.score)

  bart = Student('Bart Simpson', 59)
  lisa = Student('Lisa Simpson', 87)
  bart.print_score()
  lisa.print_score()
#+END_EXAMPLE

*数据封装,继承和多态是面向对象的三大特点*

***** 类和实例

[[http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138682004077376d2d7f8cc8a4e2c9982f92788588322000#main][link]]
*类(class)是抽象的模板,实例(instance)是根据模板创建出来的具体对象*
*每个对象拥有相同的方法,但各自的数据可能不同*
class Student(object)
在Python中,定义类是通过关键字class,后面接着的是类名,类名通常以大写开
头,object表父类.通常,如果没有合适的父类,就使用object类,这是所有类最终
都会继承的类.

*__init__* 是特殊的方法,通过它,在创建实例时,把必须绑定的属性填写进去.
__init_方法的第一个参数永远是self,表示创建的实例的本身.
有了__init__方法,在创建实例的时候,必须传入与其相匹配的参数,但self不需
要,Prthon解释器会自动把实例变量传进去.

类的方法的第一个参数永远是实例变量self,并且调用时不用传递该参数.

***** 访问限制

[[http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820042500060e2921830a4adf94fb31bcea8d6f5c000#001402635178014df9b8db22892435d8ba20f9f0acc5d01000][link]]
在Python中以双下划线开头的属性为 *私有变量(private)*,只有在内部可以访
问.可以增加get和set方法获取和修改该属性,在方法中,可以做参数检查.
类似__xxx__的变量为特殊变量,不是private.
以单下划线开头的变量,可以在外部访问,但约定俗成为私有变量.

*** TOBECONTINED [#C] Python核心编程                       :project:
**** Python入门

***** 什么是Python
Python是一门 *优雅* 而 *健壮* 的编程语言.
+ 继承传统编译语言的强大性和通用性
+ 借鉴简单脚本和解释语言的易用性

*只有你想不到的,没有Python做不到的*

***** 起源

1989, Guido van Rossum(贵铎.范.罗萨姆).
像C ,C++,Lisp,Java和Perl一样,Python来自于某个研究项目.

***** 特点                                                      :feature:
+ 高级
  机器语言->汇编语言->C,Fortan等高级语言->C++,Java等现代编译语
  言->Perl,Python等解释型脚本语言.
  Python具有高级的数据结构(列表,字典等),减少了"框架"开发需要的时间.

+ 面向对象
  面向对象为数据与逻辑相分离的结构化和过程化编程添加了新的活力.Python
  面向对象的特性是与生俱来的,同时Python融汇了多种编程风格.

+ 可升级
  Python提倡简洁的代码设计,高级的数据结构和模块化的组件.

+ 可扩展
  Python使用文件和模块对代码进行组织，对于所有模块，Python的访问语法是
  相同的。在一些特别强调性能的地方，可以作为Python扩展使用C重写，这些
  接口和纯Python接口是一样的。

+ 可移植
  Python是用C写的,C的可移植性使得Python可以运行在任何带有ANSI C编译器
  的平台上.

+ 易学
+ 易读
+ 易维护
+ 健壮性
+ 内存管理器
+ 解释性和字节编译性

***** Python的运行方式
****** 交互式的启动解释器
学习Python的最好方式就是在交互式解释器中练习。
****** 运行Python脚本
+ 在命令行上通过解释器执行
  #+BEGIN_EXAMPLE
  $ python script.py
  #+END_EXAMPLE
+ 自动执行Python解释器
  脚本文件首行：
  *#!/usr/bin/python*
  或
  */usr/bin/env python*

***** 比较Python
****** VS Perl
Perl最大的优势在于它的 *字符串匹配能力*,其提供了一个十分强大的正则表达
式匹配引擎.这使得Perl实际上成为一种用于过滤,识别和抽取字符串文本的语
言.Python的正则表达式引擎很大程度上是基于Perl的.
****** VS Java
Jython是一个完全使用Java开发的Python解释器.
****** VS Ruby
****** VS Tcl
**** Python起步

Python中有两种方式完成你的要求
+ *语句*: 使用关键字组成命令,告诉Python解释器做什么
+ *表达式*: 没有关键字,使用运算符或函数

***** print语句                                                   :print:

在交互式解释器中,查看变量内容:
+ 使用print语句显示变量的字符串表示
+ 仅使用变量名查看其原始值

注: 仅使用变量名时,输出的字符串是用单引号括起来的.

下划线 *_* 在解释器中有特别含义,表示最后一个表达式的值.

Python中的print语句,与格式化运算符(%)结合使用可实现字符串的替换功能.
#+BEGIN_SRC python :results output
print "%s is number %d" % ("Python", 1)
#+END_SRC

#+RESULTS:
: Python is number 1

*>>* 符号用于重定向.

#+BEGIN_SRC python :results output
import sys
print >> sys.stderr, 'Fatal error: invalid input!'
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
  logfile = open('./python/tmp/mylog.txt', 'a')
  print >> logfile, 'Fatal error: invalid inputg'
  logfile.close()
  #+END_SRC

#+RESULTS:
: None

***** raw_input()程序输入                                         :input:
input()
raw_input()

**** 字典                                                           :dict:

***** 映射类型:字典
****** 创建
+ 赋值
  #+BEGIN_EXAMPLE
      dict1 = {}
      dict2 = {'name':'earth', 'port':80}
  #+END_EXAMPLE
  字典的键可以混用数字字符串
  #+BEGIN_EXAMPLE
    dict3 = {}
    dict3[1] = 'abc'
    dict3['1'] = 3.14159
    dict3[3.2] = 'xyz'
  #+END_EXAMPLE
+ 工厂函数dict
  #+BEGIN_EXAMPLE
      fdict = dict((['x', 1], ['y', 2]))
  #+END_EXAMPLE
+ 内建方法fromkeys()
  #+BEGIN_EXAMPLE
    ddict = {}.fromkeys(('x', 'y'), -1)
    edict = {}.fromkeys(('foo', 'bar'))
  #+END_EXAMPLE
****** 访问
+ 循环查看字典的键来遍历一个字典
  #+BEGIN_EXAMPLE
    for key in dict2.keys():
        print "key=%s, value=%s" % (key, dict2[key])
  #+END_EXAMPLE
+ 使用迭代器访问序列对象(字典和文件等)
  #+BEGIN_EXAMPLE
    for key in dict2:
        print "key=%s, value=%s" % (key, dict2[key])
  #+END_EXAMPLE
+ 方括号索引键访问某个元素的值
  #+BEGIN_EXAMPLE
    dict2['name']
  #+END_EXAMPLE
  键"溢出"会产生 *KeyError* 错误.
  检测字典中是否存在某个键,可使用 *has_key()* 方法(将弃用). 更好的方法
  是使用 *in* 或 *not in* 操作符.
  #+BEGIN_EXAMPLE
  dict2.has_key("server")
  "server" in dict2
  #+END_EXAMPLE

****** 更新
+ 添加一个新的的数据项(即,一个键-值对)
+ 修改一个已存在的数据项
+ 删除一个已存在的数据项

#+BEGIN_EXAMPLE
  dict2['name'] = 'venus'
  dict2['port'] = 6969
  dict2['arch'] = 'sunos5'
#+END_EXAMPLE

update()方法将到整个字典的内容添加到另一个字典中.

在格式化字符串中使用字典:
#+BEGIN_EXAMPLE
  print "host %(name)s is running on port %(port)d" % dict2
#+END_EXAMPLE
****** 删除
删除整个字典的操作并不常见,通常只是删除字典中的单个元素或是清除整个字
典的内容.
#+BEGIN_EXAMPLE
  dict2.pop('arch')               # 删除并返回对应的条目
  del dict2["name"]               # 删除条目
  dict2.clear()                   # 清空字典
  del dict2                       # 删除字典
#+END_EXAMPLE
***** 映射类型操作符
字典可以和所有的标准类型操作符一起工作,但 *不支持拼接(concatenation)和*
*重复(repetition)* 等操作.
****** 标准类型操作符
****** 映射类型操作符
键查找操作符 *[]*
键成员关系操作符 *in, not in*
***** 映射类型的内建函数和工厂函数
****** 标准类型函数
*type()* 工厂函数,返回字典类型
*str()* 工厂函数,返回字符串表示
*cmp()* 工厂函数,比较两个字典:首先是字典大小,然后是键,最后是值.

cmp()算法:
1) 比较字典长度
2) 比较字典的键
3) 比较字典的值
4) Exact Match

****** 映射类型相关函数
******* dict()
+ 无参数: 生成空字典
+ 可迭代对象(序列,迭代器等):每个可迭代的元素必须成对出现.
  #+BEGIN_EXAMPLE
    dict(zip(('x', 'y'), (1, 2)))
    dict([['x', 1], ['y', 2]])
    dict([('xy'[i-1], i) for i in range(1,3)])
  #+END_EXAMPLE
+ 映射对象(字典等): 原对象的浅复制版本,等价于copy()方法,但慢.
   #+BEGIN_EXAMPLE
     dict4 = dict(dict3)
     dict5 = dict3.copy()
   #+END_EXAMPLE
+ 接受关键字参数字典(函数操作符)
  #+BEGIN_EXAMPLE
    dict(x=1, y=2, z=3)
  #+END_EXAMPLE
******* len()
******* hash() 返回对象的哈希值,判断一个对象是否是可哈希的,即是否可以作为一个字典的键.
非可哈希类型参数传递给hash()方法,会产生一个TypeError错误.

***** 映射类型内建方法
****** has_key()
****** keys() 返回所有键组成的列表
****** values() 返回所有值组成的列表
****** items() 返回所有(键,值)组成的列表
****** clear() 清空字典
****** copy() 浅复制
****** fromkeys(seq, val=None)
****** get(key, defalut=None)
****** iter()
****** pop(key[,default])
****** setdefault(key, default=None)
****** update(dict) 添加
***** 字典的键
字典的值没有任何限制,可以是任意Python对象.但是,字典的键是有类型限制的.
****** 不允许一个键对应多个值
当有冲突时,取最后的赋值.Python不会检查键的冲突行为(考虑效率).
****** 键必须是可哈希的
大多数Python可以作为键,但它们必须是可哈希的(列表字典等不可哈希).
所有不可变类型都是可哈希的.

*注:所有值相同的数字表示相同的键*, e.g. 整型1和浮点数1.0的哈希值相同.

某些可变对象是可哈希的,但很少.

数字和字符串最常用作字典的键.元组不可变,但不是一成不变,作为键使用必须
加以限制:元组中只有包括像数字,字符串这样的不可变参数时才能作为有效的键

**** 集合                                                      :set:
***** 集合类型
****** What?
*set*: 数学上,把由不同元素组成的集合称为set.
set elements: 集合元素.

*(Sets)是Python的内置数据类型. 集合对象是一组无序排列的可哈希的值*,集合成
员可做为字典的键.
******* 操作
+ in, not in
+ len()
+ for迭代
+ 不支持slice切片
+ 不支持keys键索引

******* 类型
+ *可变集合(set)*: 可以添加和删除元素,不可哈希
+ *不可变集合(frozenset)*: 不可更改,有哈希值
******* Sets
Python version >= 2.4
******* 集合操作符

****** 创建与赋值
集合没有特殊的语法格式, *工厂方法set()和frozenset()是唯一的创建方法*
#+BEGIN_EXAMPLE
  >>> s = set('cheeseshop')
  >>> s
  set(['c', 'e', 'h', 'o', 'p', 's'])
  >>> t = frozenset("bookshop")
  >>> t
  frozenset(['b', 'h', 'k', 'o', 'p', 's'])
  >>> type(t)
  <type 'frozenset'>
  >>> type(s)
  <type 'set'>
  >>> len(s)
  6
  >>> s == t
  False
#+END_EXAMPLE
****** 访问
+ 遍历
+ 检查某个元素是否存在

#+BEGIN_EXAMPLE
  >>> "k" in s
  False
  >>> "k" in t
  True
  >>> "c" not in t
  True
  >>> for i in s:
  ... print i
  ...
  c
  e
  h
  o
  p
  s
#+END_EXAMPLE
****** 更新
使用集合的建方法,frozenset不可更改
#+BEGIN_EXAMPLE
  >>> s.add("x")
  >>> s
  set(['c', 'e', 'h', 'o', 'p', 's', 'x'])
  >>> s.update("pypi")
  >>> s
  set(['c', 'e', 'i', 'h', 'o', 'p', 's', 'y', 'x'])
  >>> s -= set('pypi')
  >>> s
  set(['c', 'e', 'h', 'o', 's', 'x'])
  >>> t.add("z")
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  AttributeError: 'frozenset' object has no attribute 'add'
#+END_EXAMPLE
****** 删除
+ 删除元素: 内建方法
+ 删除集合对象
  - 超出使用域
  - del命令

#+BEGIN_EXAMPLE
>>> del s
>>>
#+END_EXAMPLE

***** 集合类型操作符
****** 标准类型操作符
******* 成员关系(in, not in)
******* 集合等价/不等价(==, !=)
#+BEGIN_EXAMPLE
  >>> set("posh") == set("shop")
  True
  >>> set("posh") == frozenset("shop")
  True
#+END_EXAMPLE
******* 子集/超集(<, <=, >, >=)
+ <  严格子集
+ <= 非严格子集
+ >  严格超集
+ >= 非严格超集

#+BEGIN_EXAMPLE
  >>> set("posh") == frozenset("shop")
  True
  >>> set("shop") < set("shop")
  False
  >>> set("shop") <= set("posh")
  True
#+END_EXAMPLE

****** 集合类型操作符
******* 联合(|)
+ 联合(union) 等价于集合的OR.
+方法union()

#+BEGIN_EXAMPLE
  >>> s | t
  set(['c', 'b', 'e', 'h', 'k', 'o', 'p', 's'])
#+END_EXAMPLE

******* 交集(&)
+ 等价于集合的AND操作
+ 方法: intersection()
#+BEGIN_EXAMPLE
  >>> s & t
  set(['h', 's', 'o', 'p'])
#+END_EXAMPLE

******* 差补(-)
+ 方法: difference()

#+BEGIN_EXAMPLE
  >>> s - t
  set(['c', 'e'])
#+END_EXAMPLE
******* 对称差分(^)
+ 等价于集合的XOR异或
+ 方法: symmetric_difference()

#+BEGIN_EXAMPLE
  >>> s ^ t
  set(['b', 'e', 'k', 'c'])
#+END_EXAMPLE

******* 混合集合类型操作
+ 左右类型相同(set/frozenset)时,类型不变
+ 左右类型不一致时,结果类型与左操作数相同

******* 加号"+"不是集合类型的运算符
#+BEGIN_EXAMPLE
  >>> s + t
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  TypeError: unsupported operand type(s) for +: 'set' and 'frozenset'
#+END_EXAMPLE
****** 可变集合类型操作符
******* Update (|=)
方法: update()
******* 交集(&=)
方法: intersection_update.
******* 差更新(-=)
方法: difference_update()
******* 对称差分更新(^=)
方法: symmetric_difference_update()

***** 内建函数
****** 标准类型函数
******* len()
****** 集合类型工厂函数
******* set() and frozenset()
#+BEGIN_EXAMPLE
  >>> set()
  set([])
  >>> set([])
  set([])
  >>> set("shop")
  set(['h', 's', 'o', 'p'])
  >>> frozenset(["foo", "bar"])
  frozenset(['foo', 'bar'])
  >>> f = open("numbers", "w")
  >>> for i in range(5)
    File "<stdin>", line 1
      for i in range(5)
                      ^
  SyntaxError: invalid syntax
  >>> for i in range(5):
  ...  f.write("%d\n" % i)
  ...
  >>> f.close()
  >>> f = open("numbers", "r")
  >>> set(f)
  set(['0\n', '3\n', '1\n', '4\n', '2\n'])
  >>> f.close
  <built-in method close of file object at 0xb7493288>
  >>> f.close()
#+END_EXAMPLE
***** 内建方法
****** 方法
+ s.issubset(t)
+ s.issuperset(t)
+ s.union(t)
+ s.intersection(t)
+ s.difference(t)
+ s.symmetric_diffrence(t)
+ s.copy()  返回一个新集合,浅复制,比工厂函数要快
****** 可变集合的方法
+ add()
+ remove()
+ discard()
+ pop()
+ clear()
  **** HALT 条件与循环


Reference: P189-P209
**** 条件
***** if语句
#+BEGIN_EXAMPLE
  if expression:
     expr_true_suite
#+END_EXAMPLE

+ 多重条件表达式使用布尔操作符 *and, or 和 not*
+ 单一语句的代码块可以与if语句写在同一行,但降低了可阅读性

***** else语句
#+BEGIN_EXAMPLE
  if expressin:
     expr_true_suite
  else:
     expr_false_suite
#+END_EXAMPLE

+ Python使用缩进有效地避免了"悬挂else(dangling else)"问题.
  #+BEGIN_EXAMPLE
    if(balance > 0.00)
        if(((balance-amt)>min_bal) && (atm_cashout()==1))
            printf("Here is your cash; please take all bills.")
    else
        printf("Your balance is zero or negative.")
  #+END_EXAMPLE

***** elif语句
#+BEGIN_EXAMPLE
  if expr1:
      expr1_true-suite
  elif expr2:
      expr2_true_suite
  elif expr3:
      expr3_ture_suite
  else:
      none_true_suite
#+END_EXAMPLE

当前Python版本不支持switch/case语句.

***** 条件表达式(三元操作符)
*X if C else Y*

**** 循环
***** While语句
#+BEGIN_EXAMPLE
  While expr:
      suite_to_repeat
#+END_EXAMPLE

***** for语句
for语句是Python最强大的循环结构,与传统语言中的for不同.
#+BEGIN_EXAMPLE
  for iter_var in iterable:
      suite_to_repeat
#+END_EXAMPLE
****** 用于序列类型
+ 迭代字符串
+ 迭代序列项
+ 迭代序列索引
+ 迭代项和索引, 内建函数 *enumerate()*
****** 用于迭代器
用for循环访问迭代器和访问序列方法类似,区别是能做更多的事情.

迭代器有一个 *next()* 方法.

****** range()内建函数
+ 完整语法: *range(start, end, step=1)*
+ 简略语法:
  + range(end)    # start=0, step=1
  + range(start, end)  # step=1
+ 注: range()有两种语法

注: step不能为零,否则会发生错误

****** xrange()
+ 与range()类似, 更适用大范围
+ 不会在内存中创建列表的完整拷贝
+ 只能在for循环中使用
+ 性能比range()高
+ 返回可迭代对象,但不是列表也不是迭代器

****** 序列相关的内建函数
+ sorted() 返回列表
+ zip()  返回列表
+ reversed()  返回迭代器
+ enumerate()  返回迭代器

***** break语句
类似C中的传统break

***** continue语句

***** pass语句
有些地方语法上要求有代码, 而Python中没有对应C中的大括号或分号来表示不
做任何事情, 因此, *Python提供了pass语句,它不做任何事情,即NOP*

pass同样可以作为开发中的小技巧,标记你后来要完成的代码.
***** for-else & while-else
else用于循环后处理(post-processing), 只要循环是正常结束的(不是通过
break语句), else子句就会执行.
***** 迭代器和iter()
从根本上讲, *迭代器就是有一个next()方法的对象*
+ iter()
+ reversed()
+ enumerate()
+ any()
+ all()

#+BEGIN_EXAMPLE
  >>> myTuple = (123, 'xyz',45.67)
  >>> i = iter(myTuple)
  >>> i.next()
  123
  >>> i.next()
  'xyz'
  >>> i.next()
  45.67
  >>> i.next()
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  StopIteration
#+END_EXAMPLE

****** 字典
字典迭代器会遍历字典的键
+ for eachKey in myDick.keys()
+ *for eachKey in myDick*

内建方法:
+ iterkeys()
+ itervalues()
+ iteritems()

****** 文件
文件对象生成的迭代器会自动调用readline()方法,循环访问文本文件的所有行..
+ *for eachLine in myFiles*
+ for eachLine in myFiles.readlines()

****** 可变对象和迭代器
*在迭代可变对象的时候修改它们并不是好主意*

****** iter
+ iter(obj)
+ iter(func, sentinel), 重复调用func直到迭代器的下一个值等于sentinel.

****** 列表解析

**** 文件和输入输出                                          :file:

***** 文件对象
文件对象不仅可以用来访问普通的磁盘文件，也可以访问任何其它类型抽象层面
上的”文件“ (*类文件*)。如 url, process等。

文件只是连续的字节流。
***** 文件内建函数
1. open()
   1) 语法
      file_object = open(file_name, access_mode="r", buffering=-1)
   2) access_mode
      + r
      + w
      + a
      + b(二进制，对于Linux可有可无)
      + U(通用换行符)
   3) buffering
      + 0 不缓冲
      + 1 只缓冲一行数据
      + -1
2. file()
   file函数与open具有相同的功能，可任意替换。
3. 通用换行符支持(UNS: Universe Newline Support)
   + Unix: \textbackslash{}n
   + Window: \textbackslash{}r\textbackslash{}n
   + 旧的OS X: \textbackslash{}r
   + 所有的行分隔符被替换为NEWLINE(\textbackslash{}n)
   + 文件的newline属性会标记为文件中的换行符
   + 默认打开

***** 文件内建方法
****** 输入
+ read(size=-1)
+ readline(size=-1): 保留换行符
+ readlines()： 读取剩余的所有的行并返回为字符串
+ xreadlines(): xreadlines模块中，性能高，但迭代更加优越
****** 输出
+ write(str)
+ writelines(str_list)

#+BEGIN_SRC sh :exports none
echo "foo" >> src/1504091737.txt
echo "bar" >> src/1504091737.txt
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :exports both :results output
  f = open("/home/ben/Tiger/Journal/src/1504091737.txt", "r")
  data = [line.strip() for line in f.readlines()]
  print data
  f.close()
#+END_SRC

#+RESULTS:
: ['foo', 'bar']

****** 文件内移动
+ seek(offset, base=0)
+ base
  + 0 文件开头
  + 1 当前位置
  + 2 文件末尾

****** 文件迭代
+ iter(file)
+ for line in f:

\lstinputlisting{/home/ben/Project/Python/CorePythonProgramming/20150409182306.py}
\lstinputlisting{/home/ben/Project/Python/CorePythonProgramming/20150409200328.py}

****** 行分隔符和其它文件操作系统的差异
1. 行分隔符
   + POSIX : \textbackslash{}n
   + DOS/Win32: \textbackslash{}r\textbackslash{}n
   + 旧的MacOS： \textbackslash{}r
2. 路径分隔符
   + POSIX: /
   + DOS/Windows: \
   + 旧的MacOS: :
3. os模块提供的有用属性
   1) linesep: 行分隔符
   2) sep: 文件路径名分隔符
   3) pathsep: 文件路径的分隔符
   4) curdir: 当前工作目录
   5) pardir: 父目录


****** 其它杂项
1. close()

   良好的编程习惯要求在重新赋另一个文件对象之前关闭这个文件。

2. tell()

3. truncate(size)
   将文本文件截取到size处，size默认为当前位置
***** 文件内建属性
+ file.closed
+ file.encoding
+ file.mode
+ file.name
+ file.newlines

***** 标准文件
sys模块提供了标准文件的句柄
+ sys.stdin  标准输入
+ sys.stdout 标准输出
+ sys.stderr 标准错误
***** 命令行参数
+ sys.argv属性提供了对命令行参数的访问，以列表的形式
+ argc即len(argv)

\lstinputlisting{/home/ben/Project/Python/CorePythonProgramming/20150409202529.txt}

***** 文件系统

****** os
1. 文件处理
   + mkfifo()/mknod()
   + remove()/unlink()
   + rename()/renames()
   + stat()
   + symlink()
   + utime()
   + tmpfile()
   + walk(): 生成目录树下的所有文件名
2. 目录
   + chdir()/fchdir()
   + chroot()
   + listdir()
   + getcwd()/getcwdu()
   + mkdir()/mkdirs()
   + rmdir()/removedirs()
3. 访问权限
   + access()
   + chmod()
   + chown()/lchown()
   + umask()
4. 文件描述符
   + open()
   + read()/write()
   + dup()/dup2()
5. 设备号
   + makedev()
   + major()/minor()

****** os.path
1. 分隔
   + basename()
   + dirname()
   + join()
   + split()
   + splitdrive()
   + splittext()
2. 信息
   + getatime()
   + getctime()
   + getmtime()
   + getsize()
3. 查询
   + exists()
   + isabs()
   + isdir()
   + isfile()
   + islink()
   + ismount()
   + samefile()
***** 文件执行
***** 永久存储模块
***** 相关模块
**** 异常                                                      :exception:

***** 错误与异常
1. 错误
   + 语法错误
   + 逻辑错误

2. 异常

   异常是因为程序出现了错误而在正常控制流以外采取的行为。
***** Python 异常
+ NameError
+ ZeroDevisionError
+ SyntaxError
+ IndexError
+ KeyError
+ IOError
+ AttributeError
+ ValueError
+ TypeError
***** 异常检测和处理
****** try-except
#+BEGIN_EXAMPLE
  try:
      try_suite    # watch exceptions here
  except Exception[,reason]:
      except_suite # exception-handling code
#+END_EXAMPLE
****** 多个except语句
#+BEGIN_EXAMPLE
  try:
      try_suite    # watch exceptions here
  except Exception1[,reason1]:
      except_suite1 # exception-handling code
  except Exception2[,reason2]:
      except_suite2
  ...
#+END_EXAMPLE
****** 处理多个异常的except语句
#+BEGIN_EXAMPLE
  except (Exception1, Exception2)[,reason]
         suit_for_Exception1_and_Exception2
#+END_EXAMPLE
****** COMMENT 捕获所有异常
#+BEGIN_EXAMPLE
  try:
      :
  except Exception, e:
      # error occurred
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  try:
      :
  except:    # 裸except，不推荐
      # erro occurred
#+END_EXAMPLE

- BaseException
  - KeyboardInterrupt
  - SystemExit
  - Exception
    - all others
****** else子句
****** finally子句
****** try-finally
***** 上下文管理
#+BEGIN_EXAMPLE
  with context_expr [as var]:
       with_suite
#+END_EXAMPLE

with语句仅能用于支持上下文管理(context management)的对象。
+ file
+ decimal.Context
+ thread.LockType
+ threading.Lock
+ threading.RLock
+ threading.Conditin
+ threading.Semaphore
+ threading.BoundedSemaphore

#+BEGIN_EXAMPLE
  with open('/etc/passwd', 'r') as f:
       for eachline in f:
           # ... do stuff with eachline of f
#+END_EXAMPLE
***** 触发异常
****** raise语句
raise [SomeException [,args [,traceback]]]

**** 模块                                                         :module:
***** 搜索路径
+ 环境变量：PYTHONPATH
  + shell: echo PYTHONPATH
  + python: sys.path(列表)
    + append(PATH)
***** 名称空间
+ 局部空间
+ 全局空间
+ 内建名称空间
***** 导入模块
import module1[,module2, [... moduleN]]

+ Pyhon标准库模块
+ Pyhon第三方模块
+ 应用程序自定义模块
***** from-import
from module import name1 [, name2 [...nameN]]
注： from module import * 不是好的编程风格。
****** 多行导入
#+BEGIN_EXAMPLE
  from moudle import name1, \
                     name2, name3
#+END_EXAMPLE
***** import-as
重新绑定名称
***** __future__
from __future__ import new_features

只import __future__ 不会有任何作用。
***** 从zip文件中导入
将zip归档文件当作目录处理。
***** 模块内建函数
import语句实际调用__import__()函数完成工作。
***** reload()
***** 包
包含模块文件的文件夹，即模块的组织形式。

#+BEGIN_EXAMPLE
  #!/usr/bin/env python
  # -*- coding: UTF-8 -*-
#+END_EXAMPLE

**** Python:13

+ 新式类(推荐)与经典类
  - 声明的不同
  - 属性的不同
+ 命名规范
+ 属性
  - 数据属性
  - 方法
  - 查看
    - dir():内建方法
    - __dict__: 属性
+ “构造器”：__init__
+ "this": self
+ 特殊属性：
  - __name__
  - __doc__
  - __bases__ : 所有父类构成的元组
  - __dict__ : 所有属性构成的字典
  - __module : 类所在的模块
  - __class__ : 实例对应的类(仅新式类)

*** Python学习
**** Python基础
作者： *Guido van Rossum（龟叔）*

TIOBE排行

龟叔给Python的定位： *优雅、明确、简单*

输入 *input()* ： birth = input("birth: ")

*r"" 不转义*

布尔值： *True* *False*

布尔运算： *and or not*

空值： *None*

*动态语言* ： 变量类型不固定的语言。

Python中通常使用 *全部大写* 的变量名表示 *常量*

*/ 为一般除法， // 为地板除法 % 取余*

编码： ASCII, Unicode, *UTF-8* --- 在计算机内存中统一使用Unicode编码，
当需要保存到硬盘或需要传输时，就转换为UTF-8。

*ord* 将字符转换为整型编码， *chr* 将编码转换为对应字符。

*len()* 函数返回字符串长度

指定保存为UTF-8编码
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
#!/usr/env/bin python
# -*- coding: utf-8 -*-
\end{minted}
#+end_latex

**** list, tuple, dict, set
***** list                                                     :listings:
list方法
1. append(element)
2. pop() 删除尾部元素
3. pop(i) 删除索引元素

***** tuple                                                       :tuple:
长度为1的tuple类型定义, *显示地使用逗号*
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
t = (1)  # 定义整数1
t = (1, ) # 定义tuple
\end{minted}
#+end_latex

*int()* 转换字符串为整数

***** dict                                                         :dict:
*字典-dict-map(其它语言)-(key:value)*
- 查找速度快，使用索引表
- list则不然，需要遍历

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
d = {'michael':95, 'bob':75, 'tracy':85}  # 初始化
d['adam'] = 67  # 也可以

# 判断key是否存在
'thomas' in d  # in 操作，返回布尔值
d.get('thomas')  # 存在则返回对应值，不存在返回none
d.get('thomas', -1)  # 不存在返回指定值, 但并不增加键
\end{minted}
#+end_latex

*dict vs list*  *以空间换时间*
+ 查找和插入速度快， 不会随着key的增加而增加
+ 需用占用大量内存
+ dict用在需要高速查找的地方

dict的键key必须是 *不可变对象* ,  如字符串、整数等，list则不行
通过key计算位置的算法，称为 *哈希算法(hash)*

***** set                                                     :setlength:
*集合set* 是一组没有重复的 key 值, 可以做集合上的交集、并集等运算。
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
s = {1,2,3,4,4}
s = set([1, 2, 3])
s.add(4)
s.remove(4)
\end{minted}
#+end_latex

**** 函数                                                       :function:
***** 定义
*函数别名： a=abs*

函数定义
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def func(args):
    body
\end{minted}
#+end_latex

空函数: *pass占位符*
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def nop():
    pass
\end{minted}
#+end_latex

参数类型检查与抛出异常
+ *isinstance*
+ *raise*
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x >= 0:
        return x
    else:
        return -x
\end{minted}
#+end_latex

***** 参数
1. 位置参数（普通参数、必选参数）
2. 默认参数（必须为不可变对象）
3. 可变参数（传入的参数个数是可变的, *号开头）
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{py}
     def calc(*numbers):
         sum = 0
         for n in numbers:
             sum = sum + n
         return sum

     sum1 = calc(1)
     sum2 = calc(1,2)

     l = [1, 2, 3]
     sum3 = calc(l[1], l[2], l[3])
     sum4 = calc(*sum)   # *开头传入list或tuple
     \end{minted}
   #+end_latex
4. 关键字参数(**开头，可以扩展函数的功能)
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{py}
     def person(name, age, **kw):
         if 'city' in kw:
             pass
         if 'job' in kw:
             pass
         print('name', name, 'age:', age, 'other:', kw)
     \end{minted}
   #+end_latex
   + 可变参数允许传入0个或多个任意参数，这些可变参数在调用时自动组装成
     *一个tuple*
   + 关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数在函数
     内部会自动组装成一个dict
5. 命名关键字参数(使用分割符*)
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{py}
     def person(name, age, *, city="Beijing", job):
         print(name, age, city, job)
     \end{minted}
   #+end_latex
   命名关键字参数必须传入参数名，这和位置参数不同。

6. 组合参数顺序
   必选参数->默认参数->可变参数/命名关键字参数->关键字参数

***** 递归函数
递归函数需要防止栈溢出。

*尾递归优化* 在函数返回的时候调用自身，并且，return语句不能包含表达式。
尾递归优化仅使用一个栈桢。尾递归事实上和循环是等价的，没有循环语句的编
程语言只能通过尾递归实现循环。

Python解释器没有针对尾递归进行优化。

**** 序列                                                       :listings:
***** 迭代

dict默认迭代key
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
for key in d:
    pass
for value in d.values():
    pass
for k, v in d.items():
    pass
\end{minted}
#+end_latex

for-in可用于任何可迭代对象。
使用collection模块中的Iterable类型可以判断对象是否可迭代
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
from collections import Iterable
isinstance(obj, Iterable)
\end{minted}
#+end_latex

*enumerate* 函数可以把一个list对象变成索引-元素对
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
for i, value in enumerate(alist):
    pass
\end{minted}
#+end_latex

***** 列表生成式(List comperhensions)
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
[x*x for x in range(1, 11)]  # 表达式+for-in循环
[x*x for x in range(1, 11) if x%2 == 0]  # 条件判断
[m+n for m in 'ABC' for n in 'XYZ]  # 两层
\end{minted}
#+end_latex

***** 生成器(generator)
generator保存的是 *算法*
*一边循环一边计算, 节省内存空间*
使用next方法可以获取generator的下一个元素。

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
L = [x*x for x in range(10)]  # L是一个列表
G = (x*x for x in range(10))  # G是一个generator
next(G)
\end{minted}
#+end_latex

*generator也是可迭代对象，因而可以使用for-in*
#+BEGIN_EXAMPLE
>>> g = (x*x for x  in range(10))
>>> next(g)
0
>>> next(g)
1
>>> for n in g:
...     print n
...
4
9
16
25
36
49
64
81
>>>
#+END_EXAMPLE

*yeild* 生成器的另一种定义方法
#+begin_latex
  \begin{minted}[frame=single, mathescape]{py}
  def fib_func(max):
      n, a, b = 0, 0, 1
      while n < max:
          print b
          a, b = b, a+b
          n = n + 1
      return 'done'


  def fib_gen(max):
      n, a, b = 0, 0, 1
      while n < max:
          yield b
          a, b = b, a+b
          n = n+1
      return 'done'
  \end{minted}
#+end_latex

generator与函数的执行流程
+ 函数是顺序执行，遇到return语句或者最后一行函数语句就返回。
+ 而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，
  再次执行时从上次返回的yield语句处继续执行。

***** 迭代器
*可迭代对象(Iterable)*
+ 集合数据类型： list, tuple, dict, set, str
+ generator

生成器还可以用于next()函数。能够被next()函数不断调用并返回下一个值，直
到最后抛出一个StopIteration错误的对象称为 *迭代器(iterator)*

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
from collections import Iterator
isinstance((x for x in range(10)), Iterator)  # True
isinstance([x for x in range(10)], Iterator)  # False
\end{minted}
#+end_latex

+ 生成器都是Iterator
+ list、 dict、 str不是，可以使用iter()函数将其转换为Iterator

Iterator对象表示的是一个 *数据流* 。

**** 函数式编程
越低级的语言，越贴近计算机，抽象程度越低，执行效率越高；
越高级的语言，越贴近计算， 抽象程度越高，执行效率越低。

函数式编程是一种抽象程度很高的编程范式。
+ 没有变量
+ 输入确定，输出即确定（没有副作用）
+ 允许传递和返回函数

***** map/reduce
map()接收两个参数，第一个是函数，第二个是Iterable,  *map将传递的函数依次
作用于序列的每一个元素，并把结果作为新的iterator返回。*

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
list(map(str, [1, 2, 3, 4, 5]))
\end{minted}
#+end_latex

map *高阶函数*

*reduce* 把一个函数作用在一个序列上，这个函数必须接收两个参数，reduce
把结果继续和序列的下一个元素作累积计算
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
from functools import reduce
def fn(x, y):
    return x*10 + y
reduce(fn, [1, 3, 5, 7, 9])
\end{minted}
#+end_latex

***** filter
filter函数用于过滤序列。
filter作用于一个函数和一个序列，把传入的函数依次作用于每个元素，然后根
据返回值是True还是False决定保留还是放弃该元素。

filter返回的是一个Iterator，也就是一个 *惰性序列* ,  所以要强迫
filter()完成计算结果，需要用list()函数获得所有结果并返回list对象。

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 3, 4, 5, 6, 7]))
\end{minted}
#+end_latex

***** sorted
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
sorted([25, 36, 12, 56, 18])
\end{minted}
#+end_latex

sorted也是一个高阶函数， 可以接收一个key函数实现自定义的排序
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
sorted([25, 36, 12, 56, 18], key=abs)
sorted('bob', 'about', 'Zoo', 'Credit',  key=str.lower)
\end{minted}
#+end_latex
*Z的ASCII值比a的小*

***** 返回函数
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax += n
        return ax
    return sum
\end{minted}
#+end_latex

#+BEGIN_EXAMPLE
>>> f = web_tutorial.lazy_sum(1, 2, 3, 4)
>>> f
<function sum at 0xb7114c6c>
>>> f()
10
#+END_EXAMPLE

***** 匿名函数
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
lambda x:x*x
\end{minted}
#+end_latex
冒号前面表示参数

匿名函数也是一个函数对象，因而可以赋值给一个变量。

也可以把匿名函数作为返回值老进行返回
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def build(x, y):
    return lambda： x*x + y:y
\end{minted}
#+end_latex

Python对匿名函数支持有限。

***** 装饰器
函数也是一个对象
+ 可以被赋值给变量，并通过变量调用
+ 有属性
  - __name__ 函数的名字

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def now():
    print('2015-11-19')

f = now
f()
print now.__name__
\end{minted}
#+end_latex

在代码运行期间动态增加功能的方式，称为 *装饰器(Decorator)*
本质上，decorator是一个返回函数的高阶函数。

@修饰，放在函数定义之前。

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def log(func):
    def wrapper(*arg, **kw):
        print('call %s()' % func.__name__)
        return func(*arg, **kw)
    return wrapper

@log
def now():
    print('2015-11-19')

# call now()
# 2015-11-19
\end{minted}
#+end_latex


******* 偏函数
*functools* 模块的 *partial*

所为偏函数，就是把一个函数的某些参数给固定住（也就是默认值），返回一个
新的函数，调用这个函数会更简单。

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
import functools

int2 = functools.partial(int, base=2)
print int2('100')
\end{minted}
#+end_latex

**** 模块                                                         :module:
***** 模块
一个.py文件就是一个 *模块* 。
+ 便于维护
+ 避免名字冲突


*包（package）* 避免模块文件名冲突， 模块文件置于包(目录)下。

*__init__.py* 在于与否用于区分普通目录还是包目录， 可以是空文件，与可
以有Python代码（本身就是一个模块）

可以有 *多级* 包目录

***** 使用模块
import

__xxx__ 特殊变量，可以被引用，但有特殊用途

__xxx _xxx 非公开变量或函数，不应该在外部直接引用

Python没有一种方法可以完全限制访问private函数或变量

***** 安装第三方模块
*pip*

注册网站： https://pypi.python.org/pypi

常用模块
+ numpy 科学计算
+ mysql-connector-python
+ jinja2 生成文本
+ Pillow 处理图片

***** 模块搜索路径
1. *sys.path* 变量
   #+BEGIN_EXAMPLE
     >>> import sys
     >>> sys.path
     ['',
     '/usr/local/lib/python2.7/dist-packages/distribute-0.6.28-py2.7.egg',
     '/usr/local/lib/python2.7/dist-packages/MySQL_python-1.2.4b4-py2.7-linux-i686.egg',
     '/usr/local/lib/python2.7/dist-packages/pip-6.1.1-py2.7.egg',
     '/usr/lib/python2.7', '/usr/lib/python2.7/plat-i386-linux-gnu',
     '/usr/lib/python2.7/lib-tk', '/usr/lib/python2.7/lib-old',
     '/usr/lib/python2.7/lib-dynload',
     '/home/ben/.local/lib/python2.7/site-packages',
     '/usr/local/lib/python2.7/dist-packages',
     '/usr/lib/python2.7/dist-packages',
     '/usr/lib/python2.7/dist-packages/PILcompat',
     '/usr/lib/python2.7/dist-packages/gst-0.10',
     '/usr/lib/python2.7/dist-packages/gtk-2.0',
     '/usr/lib/pymodules/python2.7',
     '/usr/lib/python2.7/dist-packages/ubuntu-sso-client',
     '/usr/lib/python2.7/dist-packages/wx-2.8-gtk2-unicode']

   #+END_EXAMPLE

2. 添加
   1) sys.path.append(PATH)

   2) 设置环境变量 *PYTHONPATH*

**** 面向对象编程 OOP                                              :class:
***** 变量类型

私有变量： 双下划线开头 __xxx
_xxx， 单下划线开头，“我不是私有变量，但不要随便访问”
__xxx__,  特殊变量，可以访问

***** 多态优点

[[/home/ben/Wally/Journal/Figure/scrot/665GXj.png]]

***** 获取对象信息
1. type() 基本数据类型
2. import types type() 函数对象
3. *isinstance* 类对象
4. *dir()* 获取一个对象的所有属性和方法
5. hasattri 测试对象是否有属性

***** 实例属性和类属性
Python是动态语言，根据类创建的实例可以任意绑定属性
+ 通过实例对象
+ 通过self

类本身中可以定义属性(*类属性*)，类属性可以通过实例访问。

类属性和实例属性不要同名，会屏蔽。

***** __slots__
同样可以给实例绑定方法, 使用 *types* 模块中的 *MethodType* 函数。
给一个实例绑定的方法，对另一个实例不起作用。
可以给类绑定方法
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
class Student(object):
    pass

s = Student()
def set_age(self, age):
    self.age = age

from types import MethodType
s.set_age = MethodType(set_age, s)
Student.set_age = MethodType(set_age, Student)
s1 = Student()
s1.set_age(18)
\end{minted}
#+end_latex

在类定义时添加特殊的变量 *__slots__* ，限制实例的属性，
#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
class Student(object):
    __slots__ = ('name', 'age')
\end{minted}
#+end_latex

__slots__仅对当前类有效，对继承的子类无效。

***** @property
@property 装饰器， 将一个getter方法变成一个属性，本身又创建了另外一个
setter装饰器。

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
class Student(object):
    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0~100')
        self._score = value


## 像属性一样调用方法
s = Student()
s.score = 90                    # OK 实际转换为s.set_score(90)
print s.score                   # OK 实际 转换为s.get_score()
\end{minted}
#+end_latex

不定义setter方法，就是一个只读属性。

***** 定制类
+ __slots__
+ __len__
+ __str__
+ __repr__
+ __iter__ __next__
+ __getitem__
+ __getattr__
+ __call__: obj()

***** 枚举类定义常量
enum模块的 *Enum* 类

pip install enum

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
\end{minted}
#+end_latex

也可以通过继承实现

***** 使用元类
****** type
动态语言和静态语言的最大的不同，就是 *函数和类的定义，不是在编译时定义
的，而是在运动时定义的*

动态创建的方法是 type()

#+begin_latex
\begin{minted}[frame=single, mathescape]{py}
def fn(self, name='world'):
    print('Hello, %s' % name)

Hello = type('Hello',           # 类名
             (object,),         # 单元素Tuple
             dict(hello=fn))    # 方法名与函数绑定
\end{minted}
#+end_latex

通过type()创建的函数和直接写class是完全一样的，因为Python解释器在遇到
class定义时，仅仅是扫描class下定义的语法，然后调用type()函数创建class.

****** metaclass 元类
类的抽象，即可以根据metaclass创建出类，就像对象和类的关系。

**** 错误处理                                                  :exception:

***** try...except...finally
用错误码（即返回值中包含错误信息）表示是否出错十分不便。
高级语言都内置了一套 *try...excpet...finally...* 的错误处理机制。

当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出
错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，
执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完
毕。

错误类：
+ BaseException
+ ValueError
+ ZeroDivisionError

***** 记录错误

*logging* 模块

import logging
logging.exception(e)

***** 抛出错误
raise

**** 调试                                                          :debug:
1. print()
2. assert
3. logging
4. pdb

** Class                                                             :class:
*** [[http://yaxin-cn.github.io/Python/classmethod-and-staticmethod-in-python.html][Python中的类方法和静态方法]]                         :blog:static:method:


Python类中有两个特殊的修饰符@classmethod和@staticmethod(即类方法和静态方法),
想要理解需要先理解类属性和实例属性的感念

**** 类属性和实例属性

看下面的代码

#+BEGIN_EXAMPLE
    >>> class TestProperty(object):
    ...     class_property = "class property"
    ...
    ...     def __init__(self):
    ...         self.instance_property = "instance property"
    >>>
    >>> test_property = TestProperty()
    >>> # 实例可以访问实例属性和类属性
    >>> print test_property.class_property
    class property
    >>> print test_property.instance_property
    instance property
    >>> # 类可以访问类属性
    >>> print TestProperty.class_property
    class property
    >>> # 但不可以访问实例属性
    >>> print TestProperty.instance_property
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    AttributeError: type object 'TestProperty' has no attribute 'instance_property'
    >>> # 注意下面的报错
    >>> del test_property.class_property
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    AttributeError: class_property
#+END_EXAMPLE

总结起来就是:

1. *实例属性*的初始化在=__init__=构造器方法中进行(当然也可以通过其它方法赋值)
2. *类实例*可以访问实例属性和类属性
3. 通过类本身则能访问类属性,无法访问实例属性
4. 类属性与类实例没有任何关系
5. 类属性其实就是其它语言中的静态变量(变量前加static)
6. 为什么要有类属性, 一句话*命名空间*

**** 类方法和静态方法

#+BEGIN_EXAMPLE
    >>> class TestMethod(object):
    ...     class_property = "class property"
    ...     def __init__(self):
    ...         self.instance_property = "instance property"
    ...     def instance_method(self, arvg):
    ...         print "instance_method(%s, %s)" % (self, arvg)
    ...         print "instance property: ", self.instance_property
    ...     @classmethod
    ...     def class_method(cls, arvg):
    ...         print "class_method(%s, %s)" % (cls, arvg)
    ...         print "class property: ", cls.class_property
    ...     @staticmethod
    ...     def static_method(arvg):
    ...         print "static_method(%s)" % arvg
    ...
    >>>
    >>> test_method = TestMethod()
    >>> # 执行普通方法, 打印出实例的内存地址和实例属性
    >>> test_method.instance_method("Hello")
    instance_method(<__main__.TestMethod object at 0x7fd8fc56eb90>, Hello)
    instance property:  instance property
    >>> # 执行类方法
    >>> # 通过实例访问, 打印出类本身和类属性
    >>> test_method.class_method("Hello")
    class_method(<class '__main__.TestMethod'>, Hello)
    class property:  class property
    >>> # 通过类直接访问, 同上
    >>> TestMethod.class_method("Hello")
    class_method(<class '__main__.TestMethod'>, Hello)
    class property:  class property
    >>> # 执行静态方法
    >>> # 通过实例访问, 打印出静态方法本身
    >>> test_method.static_method("Hello")
    static_method(Hello)
    >>> # 通过类直接访问, 同上
    >>> TestMethod.static_method("Hello")
    static_method(Hello)
#+END_EXAMPLE

可以看出类方法中=cls=代表的是类本身,
如果将类方法中的访问类属性的cls去掉, 则会报出/NameError/的错误

#+BEGIN_EXAMPLE
    >>> class TestMethod(object):
    ...     class_property = "class property"
    ...     @classmethod
    ...     def class_method(cls, arvg):
    ...         print "class property: ", cls.class_property
    ...
    >>> TestMethod.class_method("Hello")
    class property:
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 5, in class_method
    NameError: global name 'class_property' is not defined
#+END_EXAMPLE

1. *类方法是为了访问类属性更加方便*
2. 类方法和静态方法可以通过类和实例来访问,效果是相同的
3. 静态方法跟普通函数没有什么区别

可以通过在实例方法中直接通过=TestMethod.class_property=来访问,
但是这样不方便也不好维护(如果类名称改了,就会出错),
也可以使用=self.class_property=来访问, 但注意,
实例本身获取的并不应该是类属性即=TestMethod.class_property=,
只是因为实例中并没有=class_property=这个变量,
而是通过查找类属性,发现有同名变量,然后打印出来,通过上面无法实例无法删除类属性是可以看出来的.
当然,如果不信,可以看下面的例子

#+BEGIN_EXAMPLE
    >>> class TestMethod(object):
    ...     class_property = "class property"
    ...     def __init__(self):
    ...         pass
    ...
    >>> test_method = TestMethod()
    >>> id(test_method.class_property)
    140488040794968
    >>> id(TestMethod.class_property)
    140488040794968
    >>> print test_method.class_property
    class property
    >>> test_method.class_property = test_method.class_property + "!!!"
    >>> print test_method.class_property
    class property!!!
    >>> print TestMethod.class_property
    class property
    >>> id(test_method.class_property)
    140488040795080
    >>> id(TestMethod.class_property)
    140488040794968
#+END_EXAMPLE

** file                                                               :file:
*** [[http://www.cnblogs.com/rollenholt/archive/2012/04/23/2466179.html][关于python文件操作]]                                               :blog:

总是记不住API。昨晚写的时候用到了这些，但是没记住，于是就索性整理一下吧：

python中对文件、文件夹（文件操作函数）的操作需要涉及到 os 模块和
shutil 模块。

**** 常用函数

得到当前工作目录，即当前Python脚本工作的目录路径: *os.getcwd()*

返回指定目录下的所有文件和目录名: *os.listdir()*

函数用来删除一个文件: *os.remove()*

删除多个目录： *os.removedirs（r“c：\python”）*

检验给出的路径是否是一个文件： *os.path.isfile()*

检验给出的路径是否是一个目录： *os.path.isdir()*

判断是否是绝对路径： *os.path.isabs()*

检验给出的路径是否真地存: *os.path.exists()*

返回一个路径的目录名和文件名:  *os.path.split()*
eg
#+BEGIN_EXAMPLE
os.path.split('/home/swaroop/byte/code/poem.txt')
#+END_EXAMPLE
结果：('/home/swaroop/byte/code', 'poem.txt')

分离扩展名： *os.path.splitext()*

获取路径名： *os.path.dirname()*

获取文件名： *os.path.basename()*

运行shell命令:  *os.system()*

读取和设置环境变量: *os.getenv() 与os.putenv()*

给出当前平台使用的行终止符: *os.linesep*
Windows使用'\r\n'，Linux使用'\n'而Mac使用'\r'

指示你正在使用的平台： *os.name *
对于Windows，它是'nt'，而对于Linux/Unix用户，它是'posix'

重命名： *os.rename（old， new）*

创建多级目录： *os.makedirs（r“c：\python\test”）*

创建单个目录： *os.mkdir（“test”）*

获取文件属性： *os.stat（file）*

修改文件权限与时间戳： *os.chmod（file）*

终止当前进程： *os.exit（）*

获取文件大小： *os.path.getsize（filename）*

**** 文件操作
*os.mknod("test.txt")*  创建空文件
*fp = open("test.txt",w)*  直接打开一个文件，如果文件不存在则创建文件

关于open 模式：

- w :: 以写方式打开，
- a :: 以追加模式打开 (从 EOF 开始, 必要时创建新文件)
- r+ :: 以读写模式打开
- w+ :: 以读写模式打开 (参见 w )
- a+ :: 以读写模式打开 (参见 a )
- rb :: 以二进制读模式打开
- wb :: 以二进制写模式打开 (参见 w )
- ab :: 以二进制追加模式打开 (参见 a )
- rb+ :: 以二进制读写模式打开 (参见 r+ )
- wb+ :: 以二进制读写模式打开 (参见 w+ )
- ab+ :: 以二进制读写模式打开 (参见 a+ )

*fp.read([size])* #size为读取的长度，以byte为单位

*fp.readline([size])* #读一行，如果定义了size，有可能返回的只是一行的一部分

*fp.readlines([size])* #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。

*fp.write(str)* #把str写到文件中，write()并不会在str后加上一个换行符

*fp.writelines(seq)* #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。

*fp.close()* #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。
如果一个文件在关闭后还对其进行操作会产生ValueError

*fp.flush()* #把缓冲区的内容写入硬盘

*fp.fileno()* #返回一个长整型的”文件标签“

*fp.isatty()* #文件是否是一个终端设备文件（unix系统中的）

*fp.tell()*
#返回文件操作标记的当前位置，以文件的开头为原点

*fp.next()* #返回下一行，并将文件操作标记位移到下一行。把一个file用于for ... in
file这样的语句时，就是调用next()函数来实现遍历的。

*fp.seek(offset[,whence])* #将文件打操作标记移到offset的位置。这个
offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参
数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。
2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每
次进行写操作时，文件操作标记会自动返回到文件末尾。

*fp.truncate([size])*  #把文件裁成规定的大小，默认的是裁到当前文件操作
标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，
也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。

**** 目录操作
*os.mkdir("file")*  创建目录

复制文件：
*shutil.copyfile("oldfile","newfile")*
oldfile和newfile都只能是文件
*shutil.copy("oldfile","newfile") *
oldfile只能是文件夹，newfile可以是文件，也可以是目标目录

复制文件夹：
*shutil.copytree("olddir","newdir")*
olddir和newdir都只能是目录，且newdir必须不存在

重命名文件（目录）
*os.rename("oldname","newname")*  文件或目录都是使用这条命令

移动文件（目录）
*shutil.move("oldpos","newpos")*

删除文件
*os.remove("file")*

删除目录
*os.rmdir("dir")* 只能删除空目录
*shutil.rmtree("dir")*  空目录、有内容的目录都可以删

转换目录
*os.chdir("path")* 换路径

**** 相关例子                                                    :example:

 将文件夹下所有图片名称加上'_fc'

 #+BEGIN_SRC python
   # -*- coding:utf-8 -*-
   import re
   import os
   import time
   #str.split(string)分割字符串
   #'连接符'.join(list) 将列表组成字符串
   def change_name(path):
       global i
     if not os.path.isdir(path) and not os.path.isfile(path):
     return False
     if os.path.isfile(path):
         file_path = os.path.split(path) #分割出目录与文件
         lists = file_path[1].split('.') #分割出文件与文件扩展名
         file_ext = lists[-1] #取出后缀名(列表切片操作)
         img_ext = ['bmp','jpeg','gif','psd','png','jpg']
     if file_ext in img_ext:
         os.rename(path,file_path[0]+'/'+lists[0]+'_fc.'+file_ext)
         i+=1 #注意这里的i是一个陷阱
         #或者
         #img_ext = 'bmp|jpeg|gif|psd|png|jpg'
         #if file_ext in img_ext:
         #  print('ok---'+file_ext)
     elif os.path.isdir(path):
     for x in os.listdir(path):

   change_name(os.path.join(path,x)) #os.path.join()在路径处理上很有用

   img_dir = 'D:\\xx\\xx\\images'
   img_dir = img_dir.replace('\\','/')
   start = time.time()
   i = 0
   change_name(img_dir)
   c = time.time() - start
   print('程序运行耗时:%0.2f'%(c))
   print('总共处理了 %s 张图片'%(i))

 #+END_SRC


输出结果：

程序运行耗时:0.11
总共处理了 109 张图片
** Debug                                                              :debug:
*** pdb调试                                                           :pdb:
+ https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/
+ http://yanam0518.blog.163.com/blog/static/7289583201210284315680/


debug对于任何开发人员都是一项非常重要的技能，它能帮助我们准确地定位错
误，发现程序中的bug。

pdb是python自带的一个包，为python程序提供了一种交互式的源代码调试功能，
主要特性包括设置断点、单步调试、进入函数调试、查看当前代码、查看栈片段、
动态改变变量的值等。

**** pdb常用命令
+ b  break    设置断点
+ c  continue 继续执行程序
+ l  list     查看当前行的代码片段
+ s  step     进入函数
+ r  return   执行代码直到从当前函数中返回
+ n  next     执行下一行
+ q  exit     中止并退出
+ pp          打印变量值
+ help        帮助


1. 运行 python -m pdb myscript.py
   (Pdb) 会自动停在第一行，等待调试,这时你可以看看 帮助
   (Pdb) h

2. 断点设置
   + (Pdb)b 10           # 断点设置在本py的第10行,或
   + (Pdb)b ots.py:20    # 断点设置到 ots.py第20行
   + (Pdb)b              # 查看断点编号
   + (Pdb)cl 2           # 删除第2个断点

3. 运行
   + (Pdb)n    # 单步运行
   + (Pdb)s    # 细点运行 也就是会下到，方法
   + (Pdb)c    # 跳到下个断点

4. 查看
   + (Pdb)p param    #查看当前 变量值
   + (Pdb)l          #查看运行到某处代码
   + (Pdb)a          #查看全部栈内变量

5. 如果是在 命令行里的调试为：
   #+BEGIN_EXAMPLE
     import pdb
     def tt():
     pdb.set_trace()
     for i in range(1, 5):
     print i
   #+END_EXAMPLE

*** gdb python                                                 :gdb:python:

**** why debugging python with GDB

There are types of bugs that are difficult to debug from within
Python:

- segfaults (not uncaught Python exceptions)
- hung processes (in cases where you can't get a Python traceback or
  debug with pdb)
- out of control daemon processes

In these cases, you can try gdb.

_也就是说，一般情况下使用 PDB 就足够了。只有特殊情况下才需要祭出上古神
器_

**** 简单使用

1. interactively

   #+BEGIN_EXAMPLE
     $ gdb python
     (gdb) run <program>.py <arguments>
   #+END_EXAMPLE

2. automatic:

   #+BEGIN_EXAMPLE
   $ gdb -ex r --args python <programname>.py <arguments>
   #+END_EXAMPLE

3. already running

   #+BEGIN_EXAMPLE
   $ gdb python <pid of running process>
   #+END_EXAMPLE

**** Reference

- [[https://wiki.python.org/moin/DebuggingWithGdb][PythonWiki]]
- [[http://www.cnblogs.com/dkblog/p/3806277.html][使用gdb调试Python进程]]

*** [[http://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/index.html][Python 代码调试技巧]]                                          :blog:ibm:

Debug
对于任何开发人员都是一项非常重要的技能，它能够帮助我们准确的定位错误，发现程序中的
bug。python 提供了一系列 debug
的工具和包，可供我们选择。本文将主要阐述如何利用 python debug
相关工具进行 debug。

**** 使用 pdb 进行调试

pdb 是 python 自带的一个包，为 python
程序提供了一种交互的源代码调试功能，主要特性包括设置断点、单步调试、进入函数调试、查看当前代码、查看栈片段、动态改变变量的值等。pdb
提供了一些常用的调试命令，详情见表 1。

***** 表 1. pdb 常用命令

命令

解释

break 或 b 设置断点

设置断点

continue 或 c

继续执行程序

list 或 l

查看当前行的代码段

step 或 s

进入函数

return 或 r

执行代码直到从当前函数返回

exit 或 q

中止并退出

next 或 n

执行下一行

pp

打印变量的值

help

帮助

下面结合具体的实例讲述如何使用 pdb 进行调试。

***** 清单 1. 测试代码示例

#+BEGIN_EXAMPLE
    import pdb
     a = "aaa"
     pdb.set_trace()
     b = "bbb"
     c = "ccc"
     final = a + b + c
     print final
#+END_EXAMPLE

开始调试：直接运行脚本，会停留在 pdb.set_trace() 处，选择 n+enter
可以执行当前的 statement。在第一次按下了 n+enter 之后可以直接按 enter
表示重复执行上一条 debug 命令。

***** 清单 2. 利用 pdb 调试

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]#  python epdb1.py
     > /root/epdb1.py(4)?()
     -> b = "bbb"
     (Pdb) n
     > /root/epdb1.py(5)?()
     -> c = "ccc"
     (Pdb)
     > /root/epdb1.py(6)?()
     -> final = a + b + c
     (Pdb) list
      1     import pdb
      2     a = "aaa"
      3     pdb.set_trace()
      4     b = "bbb"
      5     c = "ccc"
      6  -> final = a + b + c
      7     print final
     [EOF]
     (Pdb)
     [EOF]
     (Pdb) n
     > /root/epdb1.py(7)?()
     -> print final
     (Pdb)
#+END_EXAMPLE

退出 debug：使用 quit 或者 q 可以退出当前的 debug，但是 quit
会以一种非常粗鲁的方式退出程序，其结果是直接 crash。

***** 清单 3. 退出 debug

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]#  python epdb1.py
     > /root/epdb1.py(4)?()
     -> b = "bbb"
     (Pdb) n
     > /root/epdb1.py(5)?()
     -> c = "ccc"
     (Pdb) q
     Traceback (most recent call last):
      File "epdb1.py", line 5, in ?
        c = "ccc"
      File "epdb1.py", line 5, in ?
        c = "ccc"
      File "/usr/lib64/python2.4/bdb.py", line 48, in trace_dispatch
        return self.dispatch_line(frame)
      File "/usr/lib64/python2.4/bdb.py", line 67, in dispatch_line
        if self.quitting: raise BdbQuit
     bdb.BdbQuit
#+END_EXAMPLE

打印变量的值：如果需要在调试过程中打印变量的值，可以直接使用 p
加上变量名，但是需要注意的是打印仅仅在当前的 statement
已经被执行了之后才能看到具体的值，否则会报 NameError: <
exceptions.NameError ... ....> 错误。

***** 清单 4. debug 过程中打印变量

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]#  python epdb1.py
     > /root/epdb1.py(4)?()
     -> b = "bbb"
     (Pdb) n
     > /root/epdb1.py(5)?()
     -> c = "ccc"
     (Pdb) p b
    'bbb'
     (Pdb)
    'bbb'
     (Pdb) n
     > /root/epdb1.py(6)?()
     -> final = a + b + c
     (Pdb) p c
    'ccc'
     (Pdb) p final
     *** NameError: <exceptions.NameError instance at 0x1551b710 >
     (Pdb) n
     > /root/epdb1.py(7)?()
     -> print final
     (Pdb) p final
    'aaabbbccc'
     (Pdb)
#+END_EXAMPLE

使用 c 可以停止当前的 debug 使程序继续执行。如果在下面的程序中继续有
set_statement() 的申明，则又会重新进入到 debug 的状态，读者可以在代码
print final 之前再加上 set_trace() 验证。

***** 清单 5. 停止 debug 继续执行程序

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]#  python epdb1.py
     > /root/epdb1.py(4)?()
     -> b = "bbb"
     (Pdb) n
     > /root/epdb1.py(5)?()
     -> c = "ccc"
     (Pdb) c
     aaabbbccc
#+END_EXAMPLE

显示代码：在 debug
的时候不一定能记住当前的代码块，如要要查看具体的代码块，则可以通过使用
list 或者 l 命令显示。list 会用箭头 -> 指向当前 debug 的语句。

***** 清单 6. debug 过程中显示代码

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]#  python epdb1.py
     > /root/epdb1.py(4)?()
     -> b = "bbb"
     (Pdb) list
      1     import pdb
      2     a = "aaa"
      3     pdb.set_trace()
      4  -> b = "bbb"
      5     c = "ccc"
      6     final = a + b + c
      7     pdb.set_trace()
      8     print final
     [EOF]
     (Pdb) c
     > /root/epdb1.py(8)?()
     -> print final
     (Pdb) list
      3     pdb.set_trace()
      4     b = "bbb"
      5     c = "ccc"
      6     final = a + b + c
      7     pdb.set_trace()
      8  -> print final
     [EOF]
     (Pdb)
#+END_EXAMPLE

在使用函数的情况下进行 debug

***** 清单 7. 使用函数的例子

#+BEGIN_EXAMPLE
    import pdb
     def combine(s1,s2):      # define subroutine combine, which...
        s3 = s1 + s2 + s1    # sandwiches s2 between copies of s1, ...
        s3 = '"' + s3 +'"'   # encloses it in double quotes,...
        return s3            # and returns it.
     a = "aaa"
     pdb.set_trace()
     b = "bbb"
     c = "ccc"
     final = combine(a,b)
     print final
#+END_EXAMPLE

如果直接使用 n 进行 debug 则到 final=combine(a,b)
这句的时候会将其当做普通的赋值语句处理，进入到 print
final。如果想要对函数进行 debug 如何处理呢 ? 可以直接使用 s
进入函数块。函数里面的单步调试与上面的介绍类似。如果不想在函数里单步调试可以在断点处直接按
r 退出到调用的地方。

***** 清单 8. 对函数进行 debug

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]# python epdb2.py
     > /root/epdb2.py(10)?()
     -> b = "bbb"
     (Pdb) n
     > /root/epdb2.py(11)?()
     -> c = "ccc"
     (Pdb) n
     > /root/epdb2.py(12)?()
     -> final = combine(a,b)
     (Pdb) s
     --Call--
     > /root/epdb2.py(3)combine()
     -> def combine(s1,s2):      # define subroutine combine, which...
     (Pdb) n
     > /root/epdb2.py(4)combine()
     -> s3 = s1 + s2 + s1    # sandwiches s2 between copies of s1, ...
     (Pdb) list
      1     import pdb
      2
      3     def combine(s1,s2):      # define subroutine combine, which...
      4  ->     s3 = s1 + s2 + s1    # sandwiches s2 between copies of s1, ...
      5         s3 = '"' + s3 +'"'   # encloses it in double quotes,...
      6         return s3            # and returns it.
      7
      8     a = "aaa"
      9     pdb.set_trace()
     10     b = "bbb"
     11     c = "ccc"
     (Pdb) n
     > /root/epdb2.py(5)combine()
     -> s3 = '"' + s3 +'"'   # encloses it in double quotes,...
     (Pdb) n
     > /root/epdb2.py(6)combine()
     -> return s3            # and returns it.
     (Pdb) n
     --Return--
     > /root/epdb2.py(6)combine()->'"aaabbbaaa"'
     -> return s3            # and returns it.
     (Pdb) n
     > /root/epdb2.py(13)?()
     -> print final
     (Pdb)
#+END_EXAMPLE

在调试的时候动态改变值
。在调试的时候可以动态改变变量的值，具体如下实例。需要注意的是下面有个错误，原因是
b 已经被赋值了，如果想重新改变 b 的赋值，则应该使用！ B。

***** 清单 9. 在调试的时候动态改变值

#+BEGIN_EXAMPLE
    [root@rcc-pok-idg-2255 ~]# python epdb2.py
     > /root/epdb2.py(10)?()
     -> b = "bbb"
     (Pdb) var = "1234"
     (Pdb) b = "avfe"
     *** The specified object '= "avfe"' is not a function
     or was not found along sys.path.
     (Pdb) !b="afdfd"
     (Pdb)
#+END_EXAMPLE

pdb
调试有个明显的缺陷就是对于多线程，远程调试等支持得不够好，同时没有较为直观的界面显示，不太适合大型的
python 项目。而在较大的 python
项目中，这些调试需求比较常见，因此需要使用更为高级的调试工具。接下来将介绍
PyCharm IDE 的调试方法 .

**** 使用 PyCharm 进行调试

PyCharm 是由 JetBrains 打造的一款 Python IDE，具有语法高亮、Project
管理、代码跳转、智能提示、自动完成、单元测试、版本控制等功能，同时提供了对
Django 开发以及 Google App Engine 的支持。分为个人独立版和商业版，需要
license 支持，也可以获取免费的 30 天试用。试用版本的 Pycharm
可以在官网上下载，下载地址为：http://www.jetbrains.com/pycharm/download/index.html。
PyCharm
同时提供了较为完善的调试功能，支持多线程，远程调试等，可以支持断点设置，单步模式，表达式求值，变量查看等一系列功能。PyCharm
IDE 的调试窗口布局如图 1 所示。

***** 图 1. PyCharm IDE 窗口布局

[[image001.gif]]

下面结合实例讲述如何利用 PyCharm
进行多线程调试。具体调试所用的代码实例见清单 10。

***** 清单 10. PyCharm 调试代码实例

#+BEGIN_EXAMPLE
    __author__ = 'zhangying'
     #!/usr/bin/python
     import thread
     import time
     # Define a function for the thread
     def print_time( threadName, delay):
        count = 0
        while count <  5:
            count += 1
            print "%s: %s" % ( threadName, time.ctime(time.time()) )
     def check_sum(threadName,valueA,valueB):
        print "to calculate the sum of two number her"
        result=sum(valueA,valueB)
        print "the result is" ,result;
     def sum(valueA,valueB):
        if valueA >0 and valueB>0:
            return valueA+valueB
     def readFile(threadName, filename):
        file = open(filename)
        for line in file.xreadlines():
            print line
     try:
        thread.start_new_thread( print_time, ("Thread-1", 2, ) )
        thread.start_new_thread( check_sum, ("Thread-2", 4,5, ) )
        thread.start_new_thread( readFile, ("Thread-3","test.txt",))
     except:
        print "Error: unable to start thread"
     while 1:
     #   print "end"
        pass
#+END_EXAMPLE

在调试之前通常需要设置断点，断点可以设置在循环或者条件判断的表达式处或者程序的关键点。设置断点的方法非常简单：在代码编辑框中将光标移动到需要设置断点的行，然后直接按
Ctrl+F8 或者选择菜单"Run"->"Toggle Line Break
Point"，更为直接的方法是双击代码编辑处左侧边缘，可以看到出现红色的小圆点（如图
2）。当调试开始的时候，当前正在执行的代码会直接显示为蓝色。下图中设置了三个断点，蓝色高亮显示的为正在执行的代码。

***** 图 2. 断点设置

[[image002.jpg]]

表达式求值：在调试过程中有的时候需要追踪一些表达式的值来发现程序中的问题，Pycharm
支持表达式求值，可以通过选中该表达式，然后选择“Run”->”Evaluate
Expression”，在出现的窗口中直接选择 Evaluate 便可以查看。

Pychar 同时提供了 Variables 和 Watches
窗口，其中调试步骤中所涉及的具体变量的值可以直接在 variable 一栏中查看。

***** 图 3. 变量查看

[[image003.jpg]]

如果要动态的监测某个变量可以直接选中该变量并选择菜单”Run”->”Add
Watch”添加到 watches
栏中。当调试进行到该变量所在的语句时，在该窗口中可以直接看到该变量的具体值。

***** 图 4. 监测变量

[[image004.jpg]]

对于多线程程序来说，通常会有多个线程，当需要 debug
的断点分别设置在不同线程对应的线程体中的时候，通常需要 IDE
有良好的多线程调试功能的支持。 Pycharm
中在主线程启动子线程的时候会自动产生一个 Dummy
开头的名字的虚拟线程，每一个 frame 对应各自的调试帧。如图
5，本实例中一共有四个线程，其中主线程生成了三个线程，分别为
Dummy-4,Dummy-5,Dummy-6. 其中 Dummy-4 对应线程 1，其余分别对应线程 2
和线程 3。

***** 图 5. 多线程窗口

[[image005.jpg]]

当调试进入到各个线程的子程序时，Frame 会自动切换到其所对应的
frame，相应的变量栏中也会显示与该过程对应的相关变量，如图
6，直接控制调试按钮，如 setp in，step over 便可以方便的进行调试。

***** 图 6. 子线程调试

[[image006.jpg]]

查看[[image006_lg.jpg][大图]]。

**** 使用 PyDev 进行调试

PyDev 是一个开源的的 plugin，它可以方便的和 Eclipse
集成，提供方便强大的调试功能。同时作为一个优秀的 Python IDE
还提供语法错误提示、源代码编辑助手、Quick Outline、Globals
Browser、Hierarchy View、运行等强大功能。下面讲述如何将 PyDev 和 Eclipse
集成。在安装 PyDev 之前，需要先安装 Java 1.4 或更高版本、Eclipse 以及
Python。 第一步：启动 Eclipse，在 Eclipse 菜单栏中找到 Help 栏，选择
Help > Install New Software，并选择 Add button，添加 Ptdev 的下载站点
http://pydev.org/updates。选择 PyDev 之后完成余下的步骤便可以安装
PyDev。

***** 图 7. 安装 PyDev

[[image007.jpg]]

安装完成之后需要配置 Python 解释器，在 Eclipse 菜单栏中，选择 Window >
Preferences > Pydev > Interpreter -- Python。Python 安装在 C:\Python27
路径下。单击 New，选择 Python 解释器
python.exe，打开后显示出一个包含很多复选框的窗口，选择需要加入系统
PYTHONPATH 的路径，单击 OK。

***** 图 8. 配置 PyDev

[[image008.jpg]]

在配置完 Pydev 之后，可以通过在 Eclipse 菜单栏中，选择 File > New >
Project > Pydev >Pydev Project，单击 Next 创建 Python
项目，下面的内容假设 python 项目已经创建，并且有个需要调试的脚本
remote.py（具体内容如下），它是一个登陆到远程机器上去执行一些命令的脚本，在运行的时候需要传入一些参数，下面将详细讲述如何在调试过程中传入参数
.

***** 清单 11. Pydev 调试示例代码

#+BEGIN_EXAMPLE
     #!/usr/bin/env python
     import os
     def telnetdo(HOST=None, USER=None, PASS=None, COMMAND=None): #define a function
         import telnetlib, sys
         if not HOST:
             try:
                 HOST = sys.argv[1]
                 USER = sys.argv[2]
                 PASS = sys.argv[3]
                 COMMAND = sys.argv[4]
             except:
                 print "Usage: remote.py host user pass command"
                 return
         tn = telnetlib.Telnet() #
         try:
             tn.open(HOST)
         except:
             print "Cannot open host"
             return
         tn.read_until("login:")
         tn.write(USER + '\n')
         if PASS:
             tn.read_until("Password:")
             tn.write(PASS + '\n')
             tn.write(COMMAND + '\n')
             tn.write("exit\n")
             tmp = tn.read_all()
             tn.close()
             del tn
             return tmp

     if __name__ == '__main__':
         print telnetdo()
#+END_EXAMPLE

在调试的时候有些情况需要传入一些参数，在调试之前需要进行相应的配置以便接收所需要的参数，选择需要调试的程序（本例
remote.py），该脚本在 debug
的过程中需要输入四个参数：host，user，password 以及命令。在 eclipse
的工程目录下选择需要 debug 的程序，单击右键，选择“Debug As”->“Debug
Configurations”，在 Arguments Tab 页中选择“Variables”。如下 图 9 所示 .

***** 图 9. 配置变量

[[image009.gif]]

在窗口”Select Variable”之后选择“Edit Varuables”
，出现如下窗口，在下图中选择”New”
并在弹出的窗口中输入对应的变量名和值。特别需要注意的是在值的后面一定要有空格，不然所有的参数都会被当做第一个参数读入。

***** 图 10. 添加具体变量

[[image010.gif]]

按照以上方式依次配置完所有参数，然后在”select
variable“窗口中安装参数所需要的顺序依次选择对应的变量。配置完成之后状态如下图
11 所示。

***** 图 11. 完成配置

[[image011.jpg]]

选择 Debug 便可以开始程序的调试，调试方法与 eclipse
内置的调试功能的使用相似，并且支持多线程的
debug，这方面的文章已经有很多，读者可以自行搜索阅读，或者参考”使用
Eclipse 平台进行调试“一文。

**** 使用日志功能达到调试的目的

日志信息是软件开发过程中进行调试的一种非常有用的方式，特别是在大型软件开发过程需要很多相关人员进行协作的情况下。开发人员通过在代码中加入一些特定的能够记录软件运行过程中的各种事件信息能够有利于甄别代码中存在的问题。这些信息可能包括时间，描述信息以及错误或者异常发生时候的特定上下文信息。
最原始的 debug 方法是通过在代码中嵌入 print
语句，通过输出一些相关的信息来定位程序的问题。但这种方法有一定的缺陷，正常的程序输出和
debug 信息混合在一起，给分析带来一定困难，当程序调试结束不再需要 debug
输出的时候，通常没有很简单的方法将 print
的信息屏蔽掉或者定位到文件。python 中自带的 logging
模块可以比较方便的解决这些问题，它提供日志功能，将 logger 的 level
分为五个级别，可以通过 Logger.setLevel(lvl) 来设置。默认的级别为
warning。

***** 表 2. 日志的级别

Level

使用情形

DEBUG

详细的信息，在追踪问题的时候使用

INFO

正常的信息

WARNING

一些不可预见的问题发生，或者将要发生，如磁盘空间低等，但不影响程序的运行

ERROR

由于某些严重的问题，程序中的一些功能受到影响

CRITICAL

严重的错误，或者程序本身不能够继续运行

logging lib 包含 4 个主要对象

- logger:logger
   是程序信息输出的接口。它分散在不同的代码中使得程序可以在运行的时候记录相应的信息，并根据设置的日志级别或
   filter 来决定哪些信息需要输出并将这些信息分发到其关联的
   handler。常用的方法有 Logger.setLevel()，Logger.addHandler()
   ，Logger.removeHandler() ，Logger.addFilter() ，Logger.debug(),
   Logger.info(), Logger.warning(), Logger.error()，getLogger()
   等。logger 支持层次继承关系，子 logger 的名称通常是父 logger.name
   的方式。如果不创建 logger 的实例，则使用默认的 root logger，通过
   logging.getLogger() 或者 logging.getLogger("") 得到 root logger
   实例。
- Handler:Handler
   用来处理信息的输出，可以将信息输出到控制台，文件或者网络。可以通过
   Logger.addHandler() 来给 logger 对象添加 handler，常用的 handler 有
   StreamHandler 和 FileHandler 类。StreamHandler 发送错误信息到流，而
   FileHandler 类用于向文件输出日志信息，这两个 handler 定义在 logging
   的核心模块中。其他的 hander 定义在 logging.handles 模块中，如
   HTTPHandler,SocketHandler。
- Formatter:Formatter 则决定了 log 信息的格式 , 格式使用类似于 %(<
   dictionary key >)s 的形式来定义，如'%(asctime)s - %(levelname)s -
   %(message)s'，支持的 key 可以在 python 自带的文档 LogRecord
   attributes 中查看。
- Filter:Filter 用来决定哪些信息需要输出。可以被 handler 和 logger
   使用，支持层次关系，比如如果设置了 filter 为名称为 A.B 的
   logger，则该 logger 和其子 logger 的信息会被输出，如 A.B,A.B.C.

***** 清单 12. 日志使用示例

#+BEGIN_EXAMPLE
    import logging
     LOG1=logging.getLogger('b.c')
     LOG2=logging.getLogger('d.e')
     filehandler = logging.FileHandler('test.log','a')
     formatter = logging.Formatter('%(name)s %(asctime)s %(levelname)s %(message)s')
     filehandler.setFormatter(formatter)
     filter=logging.Filter('b')
     filehandler.addFilter(filter)
     LOG1.addHandler(filehandler)
     LOG2.addHandler(filehandler)
     LOG1.setLevel(logging.INFO)
     LOG2.setLevel(logging.DEBUG)
     LOG1.debug('it is a debug info for log1')
     LOG1.info('normal infor for log1')
     LOG1.warning('warning info for log1:b.c')
     LOG1.error('error info for log1:abcd')
     LOG1.critical('critical info for log1:not worked')
     LOG2.debug('debug info for log2')
     LOG2.info('normal info for log2')
     LOG2.warning('warning info for log2')
     LOG2.error('error:b.c')
     LOG2.critical('critical')
#+END_EXAMPLE

上例设置了 filter b，则 b.c 为 b 的子 logger，因此满足过滤条件该 logger
相关的日志信息会 被输出，而其他不满足条件的 logger（这里是
d.e）会被过滤掉。

***** 清单 13. 输出结果

#+BEGIN_EXAMPLE
    b.c 2011-11-25 11:07:29,733 INFO normal infor for log1
     b.c 2011-11-25 11:07:29,733 WARNING warning info for log1:b.c
     b.c 2011-11-25 11:07:29,733 ERROR error info for log1:abcd
     b.c 2011-11-25 11:07:29,733 CRITICAL critical info for log1:not worked
#+END_EXAMPLE

logging
的使用非常简单，同时它是线程安全的，下面结合多线程的例子讲述如何使用
logging 进行 debug。

***** 清单 14. 多线程使用 logging

#+BEGIN_EXAMPLE
    logging.conf
     [loggers]
     keys=root,simpleExample

     [handlers]
     keys=consoleHandler

     [formatters]
     keys=simpleFormatter

     [logger_root]
     level=DEBUG
     handlers=consoleHandler

     [logger_simpleExample]
     level=DEBUG
     handlers=consoleHandler
     qualname=simpleExample
     propagate=0

     [handler_consoleHandler]
     class=StreamHandler
     level=DEBUG
     formatter=simpleFormatter
     args=(sys.stdout,)

     [formatter_simpleFormatter]
     format=%(asctime)s - %(name)s - %(levelname)s - %(message)s
     datefmt=

     code example:
     #!/usr/bin/python
     import thread
     import time
     import logging
     import logging.config
     logging.config.fileConfig('logging.conf')
     # create logger
     logger = logging.getLogger('simpleExample')
     # Define a function for the thread
     def print_time( threadName, delay):
         logger.debug('thread 1 call print_time function body')
         count = 0
         logger.debug('count:%s',count)
#+END_EXAMPLE

**** 总结

全文介绍了 python 中 debug 的几种不同的方式，包括 pdb 模块、利用 PyDev
和 Eclipse 集成进行调试、PyCharm 以及 Debug 日志进行调试，希望能给相关
python 使用者一点参考。更多关于 python debugger 的资料可以参见参考资料。

**** 参考资料

***** 学习

- 参考 [[http://www.python.org/doc/][Tutorial Python]]查看 Python   的官方文档。
- 参考 [[http://docs.python.org/library/logging.html][Python Logging]]文档获取更多的 logging 使用信息。
- 在 [[http://www.ibm.com/developerworks/cn/linux/][developerWorks Linux 专区]] 寻找为 Linux 开发人员（包括
   [[http://www.ibm.com/developerworks/cn/linux/newto/][Linux 新手入门]]）准备的更多参考资料，查阅我们   [[http://www.ibm.com/developerworks/cn/linux/best2009/index.html][最受欢迎的文章和教程]]。
- 在 developerWorks 上查阅所有 [[http://www.ibm.com/developerworks/cn/views/linux/libraryview.jsp?search_by=Linux+%E6%8A%80%E5%B7%A7][Linux 技巧]] 和 [[http://www.ibm.com/developerworks/cn/views/linux/libraryview.jsp?type_by=%E6%95%99%E7%A8%8B][Linux 教程]]。
- 随时关注 developerWorks [[http://www.ibm.com/developerworks/cn/offers/techbriefings/][技术活动]]和[[http://www.ibm.com/developerworks/cn/swi/][网络广播]]。

***** 讨论

- 参考 [[http://wiki.python.org/moin/PythonDebuggers][Python Debugger 博客 ]]获取更多的 Python debug 信息。
- 加入 [[http://www.ibm.com/developerworks/cn/community/][developerWorks 中文社区]]，developerWorks 社区是一个面向全球 IT
  专业人员，可以提供博客、书签、wiki、群组、联系、共享和协作等社区功能
  的专业社交网络社区。

- 加入 [[https://www.ibm.com/developerworks/mydeveloperworks/groups/service/html/communityview?communityUuid=38997896-bb16-451a-aa97-189a27a3cd5a/?lang=zh][IBM 软件下载与技术交流群组]]，参与在线交流。

** TKinter                                                     :tkinter:gui:
*** TK

**** Intro

1. GUI toolkit: *TK*
   + Tcl(Tool Command Language)
   + *cross-platform*, portability, flexibility
   + ported to a variety of other scripting languages
     - Perl(Perl/TK)
     - Ruby(Ruby/TK)
     - Python(Tkinter)

2. Python interface: *Tkinter*, short of "Tk interface"
   Python+TK

**** Main steps

1. /import Tkinter/ or /from Tkinter import */
2. Create a top-level *windowing* object
3. Build all your GUI *components* on top of windowing object
4. Connect these GUI components to the underlying application code
5. Enter the main loop
   #+begin_latex
   \begin{minted}{py}
   Tkinter.mainloop()
   \end{minted}
   #+end_latex

**** Intro

1. top-level window object : *root window*
   #+begin_latex
   \begin{minted}{python}
   top = Tkinter.Tk()
   \end{minted}
   #+end_latex

2. *widgets* : standalone or containers

3. *Events* & *Callback* : event-driven processing

4. Geometry managers: Pack & Grid

**** Top-Level Window: Tkinter.Tk()
class
**** Widgets

15 types of widgets

[[/home/ben/Wally/Journal/Figure/scrot/15937ZoG.png]]

**** Default arguments are your friend

These defaults were chosen carefully. They were created with an
optimized set of default arguments as a general rule. Only when you
know how to exactly customize your widgets should you use values other
than the default.

**** hello world
#+begin_latex
\begin{minted}{py}
#!/usr/bin/env python

import Tkinter


top = Tkinter.Tk()
label = Tkinter.Label(top, text="Hello World!")
label.pack()
Tkinter.mainloop()

\end{minted}
#+end_latex
**** hello world button
#+begin_latex
\begin{minted}{py}
#!/usr/bin/env python

import Tkinter

top = Tkinter.Tk()
quit = Tkinter.Button(top, text="Hello World!", command=top.quit)
quit.pack()
Tkinter.mainloop()

\end{minted}
#+end_latex

note: 从Emacs IDE运行程序点击按钮无反应，不知为何。 从命令行启动没有这
个问题。
**** hello world 3
#+begin_latex
\begin{minted}{python}
#!/usr/bin/env python

import Tkinter

top = Tkinter.Tk()

hello = Tkinter.Label(top, text='Hello World!')
hello.pack()

quit = Tkinter.Button(top, text='QUIT', command=top.quit, bg='red', fg='white')
quit.pack(fill=Tkinter.X, expand=1)

Tkinter.mainloop()
\end{minted}
#+end_latex

1. /fill/
2. /expand/

**** hello world scale
#+begin_latex
\begin{minted}{py}
#!/usr/bin/env python

import Tkinter

def resize(ev=None):
    label.config(font='Helvetica -%d bold' % scale.get())

top = Tkinter.Tk()
top.geometry('250x150')

label = Tkinter.Label(top, text='Hello World!',
                      font='Helvetica -12 bold')
label.pack(fill=Tkinter.Y, expand=1)

scale = Tkinter.Scale(top, from_=10, to=40,
                      orient=Tkinter.HORIZONTAL, command=resize)
scale.set(12)
scale.pack(fill=Tkinter.X, expand=1)

quit = Tkinter.Button(top, text='QUIT', command=top.quit,
                      activeforeground='white', activebackground='white')
quit.pack()

Tkinter.mainloop()

\end{minted}
#+end_latex

**** PFA
Partial Funtion Application

PFAs are not limited to just functions. They work with any "callable",
i.e., classes, methods, or callable instances.

GUI programming makes a great use case

#+begin_latex
\begin{minted}{py}
#!/usr/bin/env python

from functools import partial as pto
from Tkinter import Tk, Button, X
from tkMessageBox import showinfo, showwarning, showerror


WARN = 'warn'
CRIT = 'crit'
REGU = 'regu'

SIGNS = {
    'do not enter': CRIT,
    'raidroad crossing': WARN,
    '55\nspeed limit': REGU,
    'wrong way': CRIT,
    'merging traffic': WARN,
    'one way': REGU
}

critCB = lambda: showerror('Error', 'Error Button Pressed')
warnCB = lambda: showwarning('Warning', 'Warning Button Pressed')
infoCB = lambda: showinfo('Info', 'Info Button Pressed')

top = Tk()
top.title('Road Signs')
Button(top, text='QUIT', command=top.quit,
       bg='red', fg='white').pack()
MyButton = pto(Button, top)
CritButton = pto(MyButton, command=critCB, bg='white', fg='red')
WarnButton = pto(MyButton, command=warnCB, bg='goldenrod1')
ReguButton = pto(MyButton, command=infoCB, bg='white')

for eachSign in SIGNS:
    signType = SIGNS[eachSign]
    cmd = '%sButton(text=%r%s).pack(fill=X, expand=True)' % (
        signType.title(), eachSign, '.upper()' if signType == CRIT else '.title()')
    eval(cmd)

top.mainloop()

\end{minted}
#+end_latex

1. partile
2. eval('str')
3. str.title() & upper()
   S.title() -> string
   Return a titlecased version of S, i.e. words start with uppercase
   characters, all remaining cased characters have lowercase.
4. if...else 对应 :?操作符

*** 定义类
#+begin_latex
\begin{minted}{py}
#!/usr/bin/env python

import os
from time import sleep
from Tkinter import *


class DirList(object):
\end{minted}
#+end_latex

*** main
#+begin_latex
\begin{minted}{py}
def main():
    d = DirList(os.curdir)
    mainloop()


if __name__ == '__main__':
    main()
\end{minted}
#+end_latex

*** __init__

**** 声明
#+begin_latex
\begin{minted}{py}
 def __init__(self, initdir=None):
\end{minted}
#+end_latex

**** top
#+begin_latex
\begin{minted}{py}
self.top = Tk()
        self.label = Label(self.top,
                           text='Directory Lister v1.1')
        self.label.pack()
\end{minted}
#+end_latex

**** core attibute StringVar
#+begin_latex
\begin{minted}{py}
 self.cwd = StringVar(self.top)
\end{minted}
#+end_latex
Help on class *StringVar* in module Tkinter:

class StringVar(Variable): Value holder for strings variables.

+ get(self): Return value of variable as string.

+ set(self, value): Set the variable to VALUE.

**** frame listbox
#+begin_latex
\begin{minted}{py}
 self.dirfm = Frame(self.top)
 self.dirsb = Scrollbar(self.dirfm)
 self.dirsb.pack(side=RIGHT, fill=Y)
 self.dirs = Listbox(self.dirfm, height=15,
                     width=50, yscrollcommand=self.dirsb.set)
 self.dirs.bind('<Double-1>', self.setDirAndGo)
 self.dirsb.config(command=self.dirs.yview)
 self.dirs.pack(side=LEFT, fill=BOTH)
 self.dirfm.pack()
\end{minted}
#+end_latex
1. Frame类
2. Listbox类
3. bind方法？？
   绑定事件到方法(evnet handler)
   - 事件：字符串
     - '<Double-1>'
     - '<Return>'
4. config方法？？

**** Entry  文本框
#+begin_latex
\begin{minted}{py}
self.dirn = Entry(self.top, width=50,
                  textvariable=self.cwd)
self.dirn.bind('<Return>', self.doLS)
self.dirn.pack()
\end{minted}
#+end_latex

**** Buttom group
#+begin_latex
\begin{minted}{py}
self.bfm = Frame(self.top)
self.clr = Button(self.bfm, text='Clear',
                  command=self.clrDir,
                  activeforeground='white',
                  activebackground='blue')
self.ls = Button(self.bfm, text='List Directory',
                 command=self.doLS,
                 activeforeground='white',
                 activebackground='green')
self.quit = Button(self.bfm, text='Quit',
                   command=self.top.quit,
                   activeforeground='white',
                   activebackground='red')
self.clr.pack(side=LEFT)
self.ls.pack(side=LEFT)
self.quit.pack(side=LEFT)
self.bfm.pack()
\end{minted}
#+end_latex

**** Method
#+begin_latex
  \begin{minted}{py}
      def doLS(self, ev=None):
          error = ''
          tdir = self.cwd.get()
          if not tdir:
              tdir = os.curdir

          if not os.path.exists(tdir):
              error = tdir + ': no such file'
          elif not os.path.isdir(tdir):
              error = tdir + ': not a directory'

          if error:
              self.cwd.set(error)
              self.top.update()
              sleep(2)
              if not (hasattr(self, 'last') and self.last):
                  self.last = os.curdir
              self.cwd.set(self.last)
              self.dirs.config(selectbackground='LightSkyBlue')
              self.top.update()
              return

          self.cwd.set('FETCHING DIRECTORY CONTENTS...')
          self.top.update()
          dirlist = os.listdir(tdir)
          dirlist.sort()
          os.chdir(tdir)
          self.dir1.config(text=os.getcwd())
          self.dirs.delete(0, END)

          self.dirs.insert(END, os.pardir)
          for eachFile in dirlist:
              self.dirs.insert(END, eachFile)
          self.cwd.set(os.curdir)
          self.dirs.config(selectbackground='LightSkyBlue')

  \end{minted}
#+end_latex

***** os 方法和属性
+ os.curdir
+ os.pardir
+ os.getwd()
+ os.listdir()
+ os.path.exists(s)
+ os.path.isdir(s)

***** Entry方法
+ config
+ insert
+ delete

***** hasattri

** matplotlib                                                   :matplotlib:
*** Reference

+ http://old.sebug.net/paper/books/scipydoc/matplotlib_intro.html
+ http://matplotlib.org/gallery.html
*** [[http://old.sebug.net/paper/books/scipydoc/matplotlib_intro.html#artist][matplotlib-绘制精美的图表]]                                        :blog:

[[http://matplotlib.sourceforge.net/][matplotlib]] 是python最著名的绘图库，它提供了一整套和matlab相似的命令API，
十分适合交互式地进行制图。而且也可以方便地将它作为绘图控件，嵌入GUI应
用程序中。


它的文档相当完备，并且
[[http://matplotlib.sourceforge.net/gallery.html][Gallery页面]]
中有上百幅缩略图，打开之后都有源程序。因此如果你需要绘制某种类型的图，只需要在这个页面中浏览/复制/粘贴一下，基本上都能搞定。

本章节作为matplotlib的入门介绍，将较为深入地挖掘几个例子，从中理解和学习matplotlib绘图的一些基本概念。

**** 快速绘图

matplotlib的pyplot子库提供了和matlab类似的绘图API，方便用户快速绘制2D图表。让我们先来看一个简单的例子：

#+BEGIN_EXAMPLE
    # -*- coding: utf-8 -*-
    import numpy as np
    import matplotlib.pyplot as plt

    x = np.linspace(0, 10, 1000)
    y = np.sin(x)
    z = np.cos(x**2)

    plt.figure(figsize=(8,4))
    plt.plot(x,y,label="$sin(x)$",color="red",linewidth=2)
    plt.plot(x,z,"b--",label="$cos(x^2)$")
    plt.xlabel("Time(s)")
    plt.ylabel("Volt")
    plt.title("PyPlot First Example")
    plt.ylim(-1.2,1.2)
    plt.legend()
    plt.show()
#+END_EXAMPLE

调用pyplot库快速将数据绘制成曲线图

matplotlib中的快速绘图的函数库可以通过如下语句载入：

#+BEGIN_EXAMPLE
    import matplotlib.pyplot as plt
#+END_EXAMPLE

pylab模块

matplotlib还提供了名为pylab的模块，其中包括了许多numpy和pyplot中常用的函数，方便用户快速进行计算和绘图，可以用于IPython中的快速交互式使用。

接下来调用figure创建一个绘图对象，并且使它成为当前的绘图对象。

#+BEGIN_EXAMPLE
    plt.figure(figsize=(8,4))
#+END_EXAMPLE

也可以不创建绘图对象直接调用接下来的plot函数直接绘图，matplotlib会为我们自动创建一个绘图对象。如果需要同时绘制多幅图表的话，可以是给figure传递一个整数参数指定图标的序号，如果所指定序号的绘图对象已经存在的话，将不创建新的对象，而只是让它成为当前绘图对象。

通过figsize参数可以指定绘图对象的宽度和高度，单位为英寸；dpi参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80。因此本例中所创建的图表窗口的宽度为8*80
= 640像素。

但是用工具栏中的保存按钮保存下来的png图像的大小是800*400像素。这是因为保存图表用的函数savefig使用不同的DPI配置，savefig函数也有一个dpi参数，如果不设置的话，将使用matplotlib配置文件中的配置，此配置可以通过如下语句进行查看，关于配置文件将在后面的章节进行介绍：

#+BEGIN_EXAMPLE
    >>> import matplotlib
    >>> matplotlib.rcParams["savefig.dpi"]
    100
#+END_EXAMPLE

下面的两行程序通过调用plot函数在当前的绘图对象中进行绘图：

#+BEGIN_EXAMPLE
    plt.plot(x,y,label="$sin(x)$",color="red",linewidth=2)
    plt.plot(x,z,"b--",label="$cos(x^2)$")
#+END_EXAMPLE

plot函数的调用方式很灵活，第一句将x,y数组传递给plot之后，用关键字参数指定各种属性：

- *label* :
   给所绘制的曲线一个名字，此名字在图示(legend)中显示。只要在字符串前后添加"$"符号，matplotlib就会使用其内嵌的latex引擎绘制的数学公式。
- *color* : 指定曲线的颜色
- *linewidth* : 指定曲线的宽度

第二句直接通过第三个参数"b--"指定曲线的颜色和线型，这个参数称为格式化参数，它能够通过一些易记的符号快速指定曲线的样式。其中b表示蓝色，"--"表示线型为虚线。在IPython中输入
"plt.plot?" 可以查看格式化字符串的详细配置。

接下来通过一系列函数设置绘图对象的各个属性：

#+BEGIN_EXAMPLE
    plt.xlabel("Time(s)")
    plt.ylabel("Volt")
    plt.title("PyPlot First Example")
    plt.ylim(-1.2,1.2)
    plt.legend()
#+END_EXAMPLE

- *xlabel* : 设置X轴的文字
- *ylabel* : 设置Y轴的文字
- *title* : 设置图表的标题
- *ylim* : 设置Y轴的范围
- *legend* : 显示图示

最后调用plt.show()显示出我们创建的所有绘图对象。

***** 配置属性

matplotlib所绘制的图的每个组成部分都对应有一个对象，我们可以通过调用这些对象的属性设置方法set_*或者pyplot的属性设置函数setp设置其属性值。例如plot函数返回一个
matplotlib.lines.Line2D
对象的列表，下面的例子显示如何设置Line2D对象的属性：

#+BEGIN_EXAMPLE
    >>> import numpy as np
    >>> import matplotlib.pyplot as plt
    >>> x = np.arange(0, 5, 0.1)
    >>> line, = plt.plot(x, x*x) # plot返回一个列表，通过line,获取其第一个元素
    >>> # 调用Line2D对象的set_*方法设置属性值
    >>> line.set_antialiased(False)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    >>> # 同时绘制sin和cos两条曲线，lines是一个有两个Line2D对象的列表
    >>> lines = plt.plot(x, np.sin(x), x, np.cos(x)) #
    >>> # 调用setp函数同时配置多个Line2D对象的多个属性值
    >>> plt.setp(lines, color="r", linewidth=2.0)
#+END_EXAMPLE

这段例子中，通过调用Line2D对象line的set_antialiased方法，关闭对象的反锯齿效果。或者通过调用plt.setp函数配置多个Line2D对象的颜色和线宽属性。

同样我们可以通过调用Line2D对象的get_*方法，或者plt.getp函数获取对象的属性值：

#+BEGIN_EXAMPLE
    >>> line.get_linewidth()
    1.0
    >>> plt.getp(lines[0], "color") # 返回color属性
    'r'
    >>> plt.getp(lines[1]) # 输出全部属性
    alpha = 1.0
    animated = False
    antialiased or aa = True
    axes = Axes(0.125,0.1;0.775x0.8)
    ... ...
#+END_EXAMPLE

注意getp函数只能对一个对象进行操作，它有两种用法：

- 指定属性名：返回对象的指定属性的值
- 不指定属性名：打印出对象的所有属性和其值

matplotlib的整个图表为一个Figure对象，此对象在调用plt.figure函数时返回，我们也可以通过plt.gcf函数获取当前的绘图对象：

#+BEGIN_EXAMPLE
    >>> f = plt.gcf()
    >>> plt.getp(f)
    alpha = 1.0
    animated = False
    ...
#+END_EXAMPLE

Figure对象有一个axes属性，其值为AxesSubplot对象的列表，每个AxesSubplot对象代表图表中的一个子图，前面所绘制的图表只包含一个子图，当前子图也可以通过plt.gca获得：

#+BEGIN_EXAMPLE
    >>> plt.getp(f, "axes")
    [<matplotlib.axes.AxesSubplot object at 0x05CDD170>]
    >>> plt.gca()
    <matplotlib.axes.AxesSubplot object at 0x05CDD170>
#+END_EXAMPLE

用plt.getp可以发现AxesSubplot对象有很多属性，例如它的lines属性为此子图所包括的
Line2D 对象列表：

#+BEGIN_EXAMPLE
    >>> alllines = plt.getp(plt.gca(), "lines")
    >>> alllines
    <a list of 3 Line2D objects>
    >>> alllines[0] == line # 其中的第一条曲线就是最开始绘制的那条曲线
    True
#+END_EXAMPLE

通过这种方法我们可以很容易地查看对象的属性和它们之间的包含关系，找到需要配置的属性。

**** 绘制多轴图

一个绘图对象(figure)可以包含多个轴(axis)，在Matplotlib中用轴表示一个绘图区域，可以将其理解为子图。上面的第一个例子中，绘图对象只包括一个轴，因此只显示了一个轴(子图)。我们可以使用subplot函数快速绘制有多个轴的图表。subplot函数的调用形式如下：

#+BEGIN_EXAMPLE
    subplot(numRows, numCols, plotNum)
#+END_EXAMPLE

subplot将整个绘图区域等分为numRows行 *
numCols列个子区域，然后按照从左到右，从上到下的顺序对每个子区域进行编号，左上的子区域的编号为1。如果numRows，numCols和plotNum这三个数都小于10的话，可以把它们缩写为一个整数，例如subplot(323)和subplot(3,2,3)是相同的。subplot在plotNum指定的区域中创建一个轴对象。如果新创建的轴和之前创建的轴重叠的话，之前的轴将被删除。

下面的程序创建3行2列共6个轴，通过axisbg参数给每个轴设置不同的背景颜色。

#+BEGIN_EXAMPLE
    for idx, color in enumerate("rgbyck"):
        plt.subplot(320+idx+1, axisbg=color)
    plt.show()
#+END_EXAMPLE

[[_images/pyplot_subplot01.png]]

用subplot函数将Figure分为六个子图区域

如果希望某个轴占据整个行或者列的话，可以如下调用subplot：

#+BEGIN_EXAMPLE
    plt.subplot(221) # 第一行的左图
    plt.subplot(222) # 第一行的右图
    plt.subplot(212) # 第二整行
    plt.show()
#+END_EXAMPLE

[[_images/pyplot_subplot02.png]]

将Figure分为三个子图区域

当绘图对象中有多个轴的时候，可以通过工具栏中的Configure
Subplots按钮，交互式地调节轴之间的间距和轴与边框之间的距离。如果希望在程序中调节的话，可以调用subplots_adjust函数，它有left,
right, bottom, top, wspace,
hspace等几个关键字参数，这些参数的值都是0到1之间的小数，它们是以绘图区域的宽高为1进行正规化之后的坐标或者长度。

**** 配置文件

一幅图有许多需要配置的属性，例如颜色、字体、线型等等。我们在绘图时，并没有一一对这些属性进行配置，许多都直接采用了Matplotlib的缺省配置。Matplotlib将缺省配置保存在一个文件中，通过更改这个文件，我们可以修改这些属性的缺省值。

Matplotlib 使用配置文件 matplotlibrc 时的搜索顺序如下：

- *当前路径* : 程序的当前路径
- *用户配置路径* : 通常为
   HOME/.matplotlib/，可以通过环境变量MATPLOTLIBRC修改
- *系统配置路径* : 保存在 matplotlib的安装目录下的 mpl-data 下

通过下面的语句可以获取用户配置路径：

#+BEGIN_EXAMPLE
    >>> import matplotlib
    >>> matplotlib.get_configdir()
    'C:\\Documents and Settings\\zhang\\.matplotlib'
#+END_EXAMPLE

通过下面的语句可以获得目前使用的配置文件的路径：

#+BEGIN_EXAMPLE
    >>> import matplotlib
    >>> matplotlib.matplotlib_fname()
    'C:\\Python26\\lib\\site-packages\\matplotlib\\mpl-data\\matplotlibrc'
#+END_EXAMPLE

由于在当前路径和用户配置路径中都没有找到位置文件，因此最后使用的是系统配置路径下的配置文件。如果你将matplotlibrc复制一份到脚本的当前目录下：

#+BEGIN_EXAMPLE
    >>> import os
    >>> os.getcwd()
    'C:\\zhang\\doc'
#+END_EXAMPLE

复制配置文件之后再运行:

#+BEGIN_EXAMPLE
    >>> matplotlib.matplotlib_fname()
    'C:\\zhang\\doc\\matplotlibrc'
#+END_EXAMPLE

如果你用文本编辑器打开此配置文件的话，你会发现它实际上是定义了一个字典。为了对众多的配置进行区分，关键字可以用点分开。

配置文件的读入可以使用 rc_params 函数，它返回一个配置字典：

#+BEGIN_EXAMPLE
    >>> matplotlib.rc_params()
    {'agg.path.chunksize': 0,
     'axes.axisbelow': False,
     'axes.edgecolor': 'k',
     'axes.facecolor': 'w',
     ... ...
#+END_EXAMPLE

在matplotlib模块载入的时候会调用rc_params，并把得到的配置字典保存到rcParams变量中：

#+BEGIN_EXAMPLE
    >>> matplotlib.rcParams
    {'agg.path.chunksize': 0,
    'axes.axisbelow': False,
    ... ...
#+END_EXAMPLE

matplotlib将使用rcParams中的配置进行绘图。用户可以直接修改此字典中的配置，所做的改变会反映到此后所绘制的图中。例如下面的脚本所绘制的线将带有圆形的点标识符：

#+BEGIN_EXAMPLE
    >>> matplotlib.rcParams["lines.marker"] = "o"
    >>> import pylab
    >>> pylab.plot([1,2,3])
    >>> pylab.show()
#+END_EXAMPLE

为了方便配置，可以使用rc函数，下面的例子同时配置点标识符、线宽和颜色：

#+BEGIN_EXAMPLE
    >>> matplotlib.rc("lines", marker="x", linewidth=2, color="red")
#+END_EXAMPLE

如果希望恢复到缺省的配置(matplotlib载入时从配置文件读入的配置)的话，可以调用
rcdefaults 函数。

#+BEGIN_EXAMPLE
    >>> matplotlib.rcdefaults()
#+END_EXAMPLE

如果手工修改了配置文件，希望重新从配置文件载入最新的配置的话，可以调用：

#+BEGIN_EXAMPLE
    >>> matplotlib.rcParams.update( matplotlib.rc_params() )
#+END_EXAMPLE

**** Artist对象

matplotlib API包含有三层：

- *backend_bases.FigureCanvas* : 图表的绘制领域
- *backend_bases.Renderer* : 知道如何在FigureCanvas上如何绘图
- *artist.Artist* : 知道如何使用Renderer在FigureCanvas上绘图

FigureCanvas和Renderer需要处理底层的绘图操作，例如使用wxPython在界面上绘图，或者使用PostScript绘制PDF。Artist则处理所有的高层结构，例如处理图表、文字和曲线等的绘制和布局。通常我们只和Artist打交道，而不需要关心底层的绘制细节。

Artists分为简单类型和容器类型两种。简单类型的Artists为标准的绘图元件，例如Line2D、
Rectangle、 Text、AxesImage
等等。而容器类型则可以包含许多简单类型的Artists，使它们组织成一个整体，例如Axis、
Axes、Figure等。

直接使用Artists创建图表的标准流程如下：

- 创建Figure对象
- 用Figure对象创建一个或者多个Axes或者Subplot对象
- 调用Axies等对象的方法创建各种简单类型的Artists

下面首先调用pyplot.figure辅助函数创建Figure对象，然后调用Figure对象的add_axes方法在其中创建一个Axes对象，add_axes的参数是一个形如[left,
bottom, width,
height]的列表，这些数值分别指定所创建的Axes对象相对于fig的位置和大小，取值范围都在0到1之间：

#+BEGIN_EXAMPLE
    >>> import matplotlib.pyplot as plt
    >>> fig = plt.figure()
    >>> ax = fig.add_axes([0.15, 0.1, 0.7, 0.3])
#+END_EXAMPLE

然后我们调用ax的plot方法绘图，创建一条曲线，并且返回此曲线对象(Line2D)。

#+BEGIN_EXAMPLE
    >>> line, = ax.plot([1,2,3],[1,2,1])
    >>> ax.lines
    [<matplotlib.lines.Line2D object at 0x0637A3D0>]
    >>> line
    <matplotlib.lines.Line2D object at 0x0637A3D0>
#+END_EXAMPLE

ax.lines是一个为包含ax的所有曲线的列表，后续的ax.plot调用会往此列表中添加新的曲线。如果想删除某条曲线的话，直接从此列表中删除即可。

Axes对象还包括许多其它的Artists对象，例如我们可以通过调用set_xlabel设置其X轴上的标题：

#+BEGIN_EXAMPLE
    >>> ax.set_xlabel("time")
#+END_EXAMPLE

如果我们查看set_xlabel的源代码的话，会发现它是通过调用下面的语句实现的：

#+BEGIN_EXAMPLE
    self.xaxis.set_label_text(xlabel)
#+END_EXAMPLE

如果我们一直跟踪下去，会发现Axes的xaxis属性是一个XAxis对象：

#+BEGIN_EXAMPLE
    >>> ax.xaxis
    <matplotlib.axis.XAxis object at 0x06343230>
#+END_EXAMPLE

XAxis的label属性是一个Text对象：

#+BEGIN_EXAMPLE
    >>> ax.xaxis.label
    <matplotlib.text.Text object at 0x06343290>
#+END_EXAMPLE

而Text对象的_text属性为我们设置的值：

#+BEGIN_EXAMPLE
    >>> ax.xaxis.label._text
    'time'
#+END_EXAMPLE

这些对象都是Artists，因此也可以调用它们的属性获取函数来获得相应的属性：

#+BEGIN_EXAMPLE
    >>> ax.xaxis.label.get_text()
    'time'
#+END_EXAMPLE

***** Artist的属性

图表中的每个元素都用一个matplotlib的Artist对象表示，而每个Artist对象都有一大堆属性控制其显示效果。例如Figure对象和Axes对象都有patch属性作为其背景，它的值是一个Rectangle对象。通过设置此它的一些属性可以修改Figrue图表的背景颜色或者透明度等属性，下面的例子将图表的背景颜色设置为绿色：

#+BEGIN_EXAMPLE
    >>> fig = plt.figure()
    >>> fig.show()
    >>> fig.patch.set_color("g")
    >>> fig.canvas.draw()
#+END_EXAMPLE

patch的color属性通过set_color函数进行设置，属性修改之后并不会立即反映到图表的显示上，还需要调用fig.canvas.draw()函数才能够更新显示。

下面是Artist对象都具有的一些属性：

- alpha : 透明度，值在0到1之间，0为完全透明，1为完全不透明
- animated : 布尔值，在绘制动画效果时使用
- axes : 此Artist对象所在的Axes对象，可能为None
- clip_box : 对象的裁剪框
- clip_on : 是否裁剪
- clip_path : 裁剪的路径
- contains : 判断指定点是否在对象上的函数
- figure : 所在的Figure对象，可能为None
- label : 文本标签
- picker : 控制Artist对象选取
- transform : 控制偏移旋转
- visible : 是否可见
- zorder : 控制绘图顺序

Artist对象的所有属性都通过相应的 get_* 和 set_*
函数进行读写，例如下面的语句将alpha属性设置为当前值的一半：

#+BEGIN_EXAMPLE
    >>> fig.set_alpha(0.5*fig.get_alpha())
#+END_EXAMPLE

如果你想用一条语句设置多个属性的话，可以使用set函数：

#+BEGIN_EXAMPLE
    >>> fig.set(alpha=0.5, zorder=2)
#+END_EXAMPLE

使用前面介绍的 matplotlib.pyplot.getp
函数可以方便地输出Artist对象的所有属性名和值。

#+BEGIN_EXAMPLE
    >>> plt.getp(fig.patch)
        aa = True
        alpha = 1.0
        animated = False
        antialiased or aa = True
        ... ...
#+END_EXAMPLE

***** Figure容器

现在我们知道如何观察和修改已知的某个Artist对象的属性，接下来要解决如何找到指定的Artist对象。前面我们介绍过Artist对象有容器类型和简单类型两种，这一节让我们来详细看看容器类型的内容。

最大的Artist容器是matplotlib.figure.Figure，它包括组成图表的所有元素。图表的背景是一个Rectangle对象，用Figure.patch属性表示。当你通过调用add_subplot或者add_axes方法往图表中添加轴(子图时)，这些子图都将添加到Figure.axes属性中，同时这两个方法也返回添加进axes属性的对象，注意返回值的类型有所不同，实际上AxesSubplot是Axes的子类。

#+BEGIN_EXAMPLE
    >>> fig = plt.figure()
    >>> ax1 = fig.add_subplot(211)
    >>> ax2 = fig.add_axes([0.1, 0.1, 0.7, 0.3])
    >>> ax1
    <matplotlib.axes.AxesSubplot object at 0x056BCA90>
    >>> ax2
    <matplotlib.axes.Axes object at 0x056BC910>
    >>> fig.axes
    [<matplotlib.axes.AxesSubplot object at 0x056BCA90>,
    <matplotlib.axes.Axes object at 0x056BC910>]
#+END_EXAMPLE

为了支持pylab中的gca()等函数，Figure对象内部保存有当前轴的信息，因此不建议直接对Figure.axes属性进行列表操作，而应该使用add_subplot,
add_axes,
delaxes等方法进行添加和删除操作。但是使用for循环对axes中的每个元素进行操作是没有问题的，下面的语句打开所有子图的栅格。

#+BEGIN_EXAMPLE
    >>> for ax in fig.axes: ax.grid(True)
#+END_EXAMPLE

Figure对象可以拥有自己的文字、线条以及图像等简单类型的Artist。缺省的坐标系统为像素点，但是可以通过设置Artist对象的transform属性修改坐标系的转换方式。最常用的Figure对象的坐标系是以左下角为坐标原点(0,0)，右上角为坐标(1,1)。下面的程序创建并添加两条直线到fig中：

#+BEGIN_EXAMPLE
    >>> from matplotlib.lines import Line2D
    >>> fig = plt.figure()
    >>> line1 = Line2D([0,1],[0,1], transform=fig.transFigure, figure=fig, color="r")
    >>> line2 = Line2D([0,1],[1,0], transform=fig.transFigure, figure=fig, color="g")
    >>> fig.lines.extend([line1, line2])
    >>> fig.show()
#+END_EXAMPLE

[[_images/pyplot_artist01.png]]

在Figure对象中手工绘制直线

注意为了让所创建的Line2D对象使用fig的坐标，我们将fig.TransFigure赋给Line2D对象的transform属性；为了让Line2D对象知道它是在fig对象中，我们还设置其figure属性为fig；最后还需要将创建的两个Line2D对象添加到fig.lines属性中去。

Figure对象有如下属性包含其它的Artist对象：

- axes : Axes对象列表
- patch : 作为背景的Rectangle对象
- images : FigureImage对象列表，用来显示图片
- legends : Legend对象列表
- lines : Line2D对象列表
- patches : patch对象列表
- texts : Text对象列表，用来显示文字

***** Axes容器

Axes容器是整个matplotlib库的核心，它包含了组成图表的众多Artist对象，并且有许多方法函数帮助我们创建、修改这些对象。和Figure一样，它有一个patch属性作为背景，当它是笛卡尔坐标时，patch属性是一个Rectangle对象，而当它是极坐标时，patch属性则是Circle对象。例如下面的语句设置Axes对象的背景颜色为绿色：

#+BEGIN_EXAMPLE
    >>> fig = plt.figure()
    >>> ax = fig.add_subplot(111)
    >>> ax.patch.set_facecolor("green")
#+END_EXAMPLE

当你调用Axes的绘图方法（例如plot），它将创建一组Line2D对象，并将所有的关键字参数传递给这些Line2D对象，并将它们添加进Axes.lines属性中，最后返回所创建的Line2D对象列表：

#+BEGIN_EXAMPLE
    >>> x, y = np.random.rand(2, 100)
    >>> line, = ax.plot(x, y, "-", color="blue", linewidth=2)
    >>> line
    <matplotlib.lines.Line2D object at 0x03007030>
    >>> ax.lines
    [<matplotlib.lines.Line2D object at 0x03007030>]
#+END_EXAMPLE

注意plot返回的是一个Line2D对象的列表，因为我们可以传递多组X,Y轴的数据，一次绘制多条曲线。

与plot方法类似，绘制直方图的方法bar和绘制柱状统计图的方法hist将创建一个Patch对象的列表，每个元素实际上都是Patch的子类Rectangle，并且将所创建的Patch对象都添加进Axes.patches属性中：

#+BEGIN_EXAMPLE
    >>> ax = fig.add_subplot(111)
    >>> n, bins, rects = ax.hist(np.random.randn(1000), 50, facecolor="blue")
    >>> rects
    <a list of 50 Patch objects>
    >>> rects[0]
    <matplotlib.patches.Rectangle object at 0x05BC2350>
    >>> ax.patches[0]
    <matplotlib.patches.Rectangle object at 0x05BC2350>
#+END_EXAMPLE

一般我们不会直接对Axes.lines或者Axes.patches属性进行操作，而是调用add_line或者add_patch等方法，这些方法帮助我们完成许多属性设置工作：

#+BEGIN_QUOTE
  #+BEGIN_EXAMPLE
      >>> fig = plt.figure()
      >>> ax = fig.add_subplot(111)
      >>> rect = matplotlib.patches.Rectangle((1,1), width=5, height=12)
      >>> print rect.get_axes() # rect的axes属性为空
      None
      >>> rect.get_transform() # rect的transform属性为缺省值
      BboxTransformTo(Bbox(array([[  1.,   1.],
             [  6.,  13.]])))
      >>> ax.add_patch(rect) # 将rect添加进ax
      <matplotlib.patches.Rectangle object at 0x05C34E50>
      >>> rect.get_axes() # 于是rect的axes属性就是ax
      <matplotlib.axes.AxesSubplot object at 0x05C09CB0>
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> # rect的transform属性和ax的transData相同
      >>> rect.get_transform()
      ... # 太长，省略
      >>> ax.transData
      ... # 太长，省略
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> ax.get_xlim() # ax的X轴范围为0到1，无法显示完整的rect
      (0.0, 1.0)
      >>> ax.dataLim._get_bounds() # 数据的范围和rect的大小一致
      (1.0, 1.0, 5.0, 12.0)
      >>> ax.autoscale_view() # 自动调整坐标轴范围
      >>> ax.get_xlim() # 于是X轴可以完整显示rect
      (1.0, 6.0)
      >>> plt.show()
  #+END_EXAMPLE
#+END_QUOTE

通过上面的例子我们可以看出，add_patch方法帮助我们设置了rect的axes和transform属性。

下面详细列出Axes包含各种Artist对象的属性：

- artists : Artist对象列表
- patch : 作为Axes背景的Patch对象，可以是Rectangle或者Circle
- collections : Collection对象列表
- images : AxesImage对象列表
- legends : Legend对象列表
- lines : Line2D对象列表
- patches : Patch对象列表
- texts : Text对象列表
- xaxis : XAxis对象
- yaxis : YAxis对象

下面列出Axes的创建Artist对象的方法：

| Axes的方法     | annotate   | bars        | errorbar            | fill      | hist        | imshow      | legend    | plot     | scatter             | text    |
| 所创建的对象   | Annotate   | Rectangle   | Line2D, Rectangle   | Polygon   | Rectangle   | AxesImage   | Legend    | Line2D   | PolygonCollection   | Text    |
| 添加进的列表   | texts      | patches     | lines,patches       | patches   | patches     | images      | legends   | lines    | Collections         | texts   |

下面以绘制散列图(scatter)为例，验证一下：

#+BEGIN_EXAMPLE
    >>> fig = plt.figure()
    >>> ax = fig.add_subplot(111)
    >>> t = ax.scatter(np.random.rand(20), np.random.rand(20))
    >>> t # 返回值为CircleCollection对象
    <matplotlib.collections.CircleCollection object at 0x06004230>
    >>> ax.collections # 返回的对象已经添加进了collections列表中
    [<matplotlib.collections.CircleCollection object at 0x06004230>]
    >>> fig.show()
    >>> t.get_sizes() # 获得Collection的点数
    20
#+END_EXAMPLE

[[_images/pyplot_artist02.png]]

用scatter函数绘制散列图

***** Axis容器

Axis容器包括坐标轴上的刻度线、刻度文本、坐标网格以及坐标轴标题等内容。刻度包括主刻度和副刻度，分别通过Axis.get_major_ticks和Axis.get_minor_ticks方法获得。每个刻度线都是一个XTick或者YTick对象，它包括实际的刻度线和刻度文本。为了方便访问刻度线和文本，Axis对象提供了get_ticklabels和get_ticklines方法分别直接获得刻度线和刻度文本：

#+BEGIN_QUOTE
  #+BEGIN_EXAMPLE
      >>> pl.plot([1,2,3],[4,5,6])
      [<matplotlib.lines.Line2D object at 0x0AD3B670>]
      >>> pl.show()
      >>> axis = pl.gca().xaxis
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> axis.get_ticklocs() # 获得刻度的位置列表
      array([ 1. ,  1.5,  2. ,  2.5,  3. ])
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> axis.get_ticklabels() # 获得刻度标签列表
      <a list of 5 Text major ticklabel objects>
      >>> [x.get_text() for x in axis.get_ticklabels()] # 获得刻度的文本字符串
      [u'1.0', u'1.5', u'2.0', u'2.5', u'3.0']
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> axis.get_ticklines() # 获得主刻度线列表，图的上下刻度线共10条
      <a list of 10 Line2D ticklines objects>
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> axis.get_ticklines(minor=True) # 获得副刻度线列表
      <a list of 0 Line2D ticklines objects>
  #+END_EXAMPLE
#+END_QUOTE

获得刻度线或者刻度标签之后，可以设置其各种属性，下面设置刻度线为绿色粗线，文本为红色并且旋转45度：

#+BEGIN_QUOTE
  #+BEGIN_EXAMPLE
      >>> for label in axis.get_ticklabels():
      ...     label.set_color("red")
      ...     label.set_rotation(45)
      ...     label.set_fontsize(16)
      ...
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
      >>> for line in axis.get_ticklines():
      ...     line.set_color("green")
      ...     line.set_markersize(25)
      ...     line.set_markeredgewidth(3)
  #+END_EXAMPLE
#+END_QUOTE

最终的结果图如下：

[[_images/pyplot_axis01.png]]

手工配置X轴的刻度线和刻度文本的样式

上面的例子中，获得的副刻度线列表为空，这是因为用于计算副刻度的对象缺省为NullLocator，它不产生任何刻度线；而计算主刻度的对象为AutoLocator，它会根据当前的缩放等配置自动计算刻度的位置：

#+BEGIN_EXAMPLE
    >>> axis.get_minor_locator() # 计算副刻度的对象
    <matplotlib.ticker.NullLocator instance at 0x0A014300>
    >>> axis.get_major_locator() # 计算主刻度的对象
    <matplotlib.ticker.AutoLocator instance at 0x09281B20>
#+END_EXAMPLE

我们可以使用程序为Axis对象设置不同的Locator对象，用来手工设置刻度的位置；设置Formatter对象用来控制刻度文本的显示。下面的程序设置X轴的主刻度为pi/4，副刻度为pi/20，并且主刻度上的文本以pi为单位：

#+BEGIN_EXAMPLE
    # -*- coding: utf-8 -*-
    import matplotlib.pyplot as pl
    from matplotlib.ticker import MultipleLocator, FuncFormatter
    import numpy as np
    x = np.arange(0, 4*np.pi, 0.01)
    y = np.sin(x)
    pl.figure(figsize=(8,4))
    pl.plot(x, y)
    ax = pl.gca()

    def pi_formatter(x, pos):
        """
        比较罗嗦地将数值转换为以pi/4为单位的刻度文本
        """
        m = np.round(x / (np.pi/4))
        n = 4
        if m%2==0: m, n = m/2, n/2
        if m%2==0: m, n = m/2, n/2
        if m == 0:
            return "0"
        if m == 1 and n == 1:
            return "$\pi$"
        if n == 1:
            return r"$%d \pi$" % m
        if m == 1:
            return r"$\frac{\pi}{%d}$" % n
        return r"$\frac{%d \pi}{%d}$" % (m,n)

    # 设置两个坐标轴的范围
    pl.ylim(-1.5,1.5)
    pl.xlim(0, np.max(x))

    # 设置图的底边距
    pl.subplots_adjust(bottom = 0.15)

    pl.grid() #开启网格

    # 主刻度为pi/4
    ax.xaxis.set_major_locator( MultipleLocator(np.pi/4) )

    # 主刻度文本用pi_formatter函数计算
    ax.xaxis.set_major_formatter( FuncFormatter( pi_formatter ) )

    # 副刻度为pi/20
    ax.xaxis.set_minor_locator( MultipleLocator(np.pi/20) )

    # 设置刻度文本的大小
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize(16)
    pl.show()
#+END_EXAMPLE

关于刻度的定位和文本格式的东西都在matplotlib.ticker中定义，程序中使用到如下两个类：

- *MultipleLocator* : 以指定值的整数倍为刻度放置刻度线
- *FuncFormatter* :
   使用指定的函数计算刻度文本，他会传递给所指定的函数两个参数：刻度值和刻度序号，程序中通过比较笨的办法计算出刻度值所对应的刻度文本

此外还有很多预定义的Locator和Formatter类，详细内容请参考相应的API文档。

[[_images/pyplot_axis02.png]]

手工配置X轴的刻度线的位置和文本，并开启副刻度

** Email                                                             :email:
clock: [2015-11-22 日 23:59]--[2015-11-23 一 00:40] =>  0:41

*** email
1. module

  #+begin_latex
    \begin{minted}{py}
    import smtplib

    from email import encoders
    from email.header import header
    from email.mime.text import mimetext
    from email.mime.multipart import mimemultipart
    from email.mime.base import mimebase
    from email.utils import parseaddr, formataddr
    \end{minted}
  #+end_latex

2. formataddr
   *formataddr(pair)*
   the inverse of parseaddr(), this takes a 2-tuple of the form
   (realname, email_address) and returns the string value suitable
   for an rfc 2822 from, to or cc header.

   *parseaddr(addr)*

   #+begin_latex
     \begin{minted}{py}
     def _format_addr(s):
         name, addr = parseaddr(s)
         return formataddr((header(name, 'utf-8').encode(), addr))
     \end{minted}
   #+end_latex

3. mimemultipart
   #+begin_latex
     \begin{minted}{py}
     ## 构造邮件对象
     msg = mimemultipart()
     # 发送地址
     msg['from'] = _format_addr("ben<%s>" % from_addr)
     # 接收地址
     msg['to'] = _format_addr('qq<%s>' % to_addr)
     # 主题
     msg['subject'] = header("测试python email", 'utf-8').encode()

     # 正文
     msg.attach(mimetext('hello python', 'plain', 'utf-8'))

     # 附件
     with open('/home/tiger/wally/journal/journal.pdf', 'rb') as f:
         mime = mimebase('pdf', 'pdf', filename='journal.pdf')
         mime.add_header('content-disposition', 'attachment', filename='journal.pdf')
         mime.add_header('content-id', '<0>')
         mime.add_header('x-attachment-id', '0')
         # 把附件的内容读进来:
         mime.set_payload(f.read())
         # 用base64编码:
         encoders.encode_base64(mime)
         # 添加到mimemultipart:
         msg.attach(mime)
     \end{minted}
   #+end_latex

*** smtplib                                                          :smtp:
#+begin_latex
  \begin{minted}{py}
  ## 发送邮件
  # stmp_server = none              ####### todo
  stmp_server = "smtp.163.com"
  port = 25
  server = smtplib.smtp(stmp_server, 25)
  server.set_debuglevel(1)
  server.login(from_addr, passwd)
  server.sendmail(from_addr, [to_addr], msg.as_string())
  \end{minted}
#+end_latex

1. constructor smtp(server, port)
2. smtp::set_debuglevel(1)
3. smtp::login(addr,  passwd)
4. smtp::sendmail(from,  to_list,  *msg.as_string()*)

** args                                                           :argv:sys:

python中的命令行参数
python中有一个模块 *sys* ， *sys.argv* 这个属性提供了对命令行参数的访
问。命令行参数是调用某个程序时除程序名外的其他参数。

- /sys.argv/ 是命令行参数的列表
- /len(sys.argv)/ 是命令行参数的个数

#+BEGIN_SRC python
#! /usr/bin/env python
# -*- encoding:utf-8 -*-

import sys

for arg in sys.argv:
    print arg
#+END_SRC

#+begin_example
  args $ python args.py 1 2 3
  args.py
  1
  2
  3
#+end_example

** datetime                                              :date:time:datetime:
*** dir

#+begin_example
  >>> dir(datetime)
  ['maxyear', 'minyear', '__doc__', '__file__', '__name__',
  '__package__', 'date', 'datetime', 'datetime_capi', 'time',
  'timedelta', 'tzinfo']

  >>> dir(datetime.datetime)
  ['__add__', '__class__', '__delattr__', '__doc__', '__eq__',
  '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__',
  '__init__', '__le__', '__lt__', '__ne__', '__new__', '__radd__',
  '__reduce__', '__reduce_ex__', '__repr__', '__rsub__', '__setattr__',
  '__sizeof__', '__str__', '__sub__', '__subclasshook__', 'astimezone',
  'combine', 'ctime', 'date', 'day', 'dst', 'fromordinal',
  'fromtimestamp', 'hour', 'isocalendar', 'isoformat', 'isoweekday',
  'max', 'microsecond', 'min', 'minute', 'month', 'now', 'replace',
  'resolution', 'second', 'strftime', 'strptime', 'time', 'timetuple',
  'timetz', 'today', 'toordinal', 'tzinfo', 'tzname',
  'utcfromtimestamp', 'utcnow', 'utcoffset', 'utctimetuple', 'weekday',
  'year']

#+end_example

+ 模块： *datetime*
+ 类： *datetime*
  - strftime
+ 方法: now() 返回datetime对象


#+begin_latex
  \begin{minted}{py}
  import datetime

  now = datetime.datetime.now()
  print now.strftime("%y%m%d")
  \end{minted}
#+end_latex

*** [[http://www.wklken.me/posts/2015/03/03/python-base-datetime.html#1-datetime][Python-基础-时间日期处理小结]]                                     :blog:

#+BEGIN_EXAMPLE
          _       _       _   _
         | |     | |     | | (_)
       __| | __ _| |_ ___| |_ _ _ __ ___   ___
      / _` |/ _` | __/ _ \ __| | '_ ` _ \ / _ \
     | (_| | (_| | ||  __/ |_| | | | | | |  __/
      __,_|__,_|_____|__|_|_| |_| |_|___|
#+END_EXAMPLE

原则, 以 =datetime= 为中心, 起点或中转, 转化为目标对象,
涵盖了大多数业务场景中需要的日期转换处理

步骤:

1. 掌握几种对象及其关系
2. 了解每类对象的基本操作方法
3. 通过转化关系转化

**** 涉及对象
***** datetime

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> now = datetime.datetime.now()
    >>> now
    datetime.datetime(2015, 1, 12, 23, 9, 12, 946118)
    >>> type(now)
    <type 'datetime.datetime'>
#+END_EXAMPLE

***** timestamp

#+BEGIN_EXAMPLE
    >>> import time
    >>> time.time()
    1421075455.568243
#+END_EXAMPLE

***** time tuple

#+BEGIN_EXAMPLE
    >>> import time
    >>> time.localtime()
    time.struct_time(tm_year=2015, tm_mon=1, tm_mday=12, tm_hour=23, tm_min=10, tm_sec=30, tm_wday=0, tm_yday=12, tm_isdst=0)
#+END_EXAMPLE

***** string

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    '2015-01-12 23:13:08'
#+END_EXAMPLE

***** date

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().date()
    datetime.date(2015, 1, 12)
#+END_EXAMPLE

**** datetime基本操作
***** 获取当前datetime

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now()
    datetime.datetime(2015, 1, 12, 23, 26, 24, 475680)
#+END_EXAMPLE

***** 获取当天date

#+BEGIN_EXAMPLE
    >>> datetime.date.today()
    datetime.date(2015, 1, 12)
#+END_EXAMPLE

***** 获取明天/前N天

明天

#+BEGIN_EXAMPLE
    >>> datetime.date.today() + datetime.timedelta(days=1)
    datetime.date(2015, 1, 13)
#+END_EXAMPLE

三天前

#+BEGIN_EXAMPLE
    >>> datetime.datetime.now()
    datetime.datetime(2015, 1, 12, 23, 38, 55, 492226)
    >>> datetime.datetime.now() - datetime.timedelta(days=3)
    datetime.datetime(2015, 1, 9, 23, 38, 57, 59363)
#+END_EXAMPLE

***** 获取当天开始和结束时间(00:00:00 23:59:59)

#+BEGIN_EXAMPLE
    >>> datetime.datetime.combine(datetime.date.today(), datetime.time.min)
    datetime.datetime(2015, 1, 12, 0, 0)
    >>> datetime.datetime.combine(datetime.date.today(), datetime.time.max)
    datetime.datetime(2015, 1, 12, 23, 59, 59, 999999)
#+END_EXAMPLE

***** 获取两个datetime的时间差

#+BEGIN_EXAMPLE
    >>> (datetime.datetime(2015,1,13,12,0,0) - datetime.datetime.now()).total_seconds()
    44747.768075
#+END_EXAMPLE

***** 获取本周/本月/上月最后一天

本周

#+BEGIN_EXAMPLE
    >>> today = datetime.date.today()
    >>> today
    datetime.date(2015, 1, 12)
    >>> sunday = today + datetime.timedelta(6 - today.weekday())
    >>> sunday
    datetime.date(2015, 1, 18)
#+END_EXAMPLE

本月

#+BEGIN_EXAMPLE
    >>> import calendar
    >>> today = datetime.date.today()
    >>> _, last_day_num = calendar.monthrange(today.year, today.month)
    >>> last_day = datetime.date(today.year, today.month, last_day_num)
    >>> last_day
    datetime.date(2015, 1, 31)
#+END_EXAMPLE

获取上个月的最后一天(可能跨年)

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> today = datetime.date.today()
    >>> first = datetime.date(day=1, month=today.month, year=today.year)
    >>> lastMonth = first - datetime.timedelta(days=1)
#+END_EXAMPLE

**** 关系转换                                                    :example:

几个关系之间的转化

=Datetime Object / String / timestamp / time tuple=

***** datetime <=> string

datetime -> string

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    '2015-01-12 23:13:08'
#+END_EXAMPLE

string -> datetime

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.strptime("2014-12-31 18:20:10", "%Y-%m-%d %H:%M:%S")
    datetime.datetime(2014, 12, 31, 18, 20, 10)
#+END_EXAMPLE

--------------

***** datetime <=> timetuple

datetime -> timetuple

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().timetuple()
    time.struct_time(tm_year=2015, tm_mon=1, tm_mday=12, tm_hour=23, tm_min=17, tm_sec=59, tm_wday=0, tm_yday=12, tm_isdst=-1)
#+END_EXAMPLE

timetuple -> datetime

#+BEGIN_EXAMPLE
    timetuple => timestamp => datetime [看后面datetime<=>timestamp]
#+END_EXAMPLE

--------------

***** datetime <=> date

datetime -> date

#+BEGIN_EXAMPLE
    >>> import datetime
    >>> datetime.datetime.now().date()
    datetime.date(2015, 1, 12)
#+END_EXAMPLE

date -> datetime

#+BEGIN_EXAMPLE
    >>> datetime.date.today()
    datetime.date(2015, 1, 12)
    >>> today = datetime.date.today()
    >>> datetime.datetime.combine(today, datetime.time())
    datetime.datetime(2015, 1, 12, 0, 0)
    >>> datetime.datetime.combine(today, datetime.time.min)
    datetime.datetime(2015, 1, 12, 0, 0)
#+END_EXAMPLE

--------------

***** datetime <=> timestamp

datetime -> timestamp

#+BEGIN_EXAMPLE
    >>> now = datetime.datetime.now()
    >>> timestamp = time.mktime(now.timetuple())
    >>> timestamp
    1421077403.0
#+END_EXAMPLE

timestamp -> datetime

#+BEGIN_EXAMPLE
    >>> datetime.datetime.fromtimestamp(1421077403.0)
    datetime.datetime(2015, 1, 12, 23, 43, 23)
#+END_EXAMPLE

** termios:Low-level terminal control interface.                   :termios:

*** intro

This module provides an interface to the POSIX calls for tty I/O
control.

All functions in this module take a *file descriptor fd* as their first
argument. This can be an integer file descriptor, such as returned by
*sys.stdin.fileno()*, or a file object, such as *sys.stdin* itself.

[[/home/ben/Wally/Journal/Figure/scrot/4904FSb.png]]

*** example
#+INCLUDE: ~/Wally/Journal/Project/Python/termios/test.py :src python

输入密码时不可见

*** [[http://www.cnblogs.com/dartagnan/archive/2013/04/25/3042417.html][termios属性设置 tcsetattr设置]]                                    :blog:

终端I/O有两种不同的工作方式：

1. 规范方式输入处理。在这种方式中，终端输入以行为单位进行处理。对于每个读要求，终端驱动程序最多返回一行。
2. 非规范方式输入处理。输入字符不以行为单位进行装配。

如果不作特殊处理，则默认方式是规范方式。

V7和BSD类的终端驱动程序支持三种终端输入方式：

1. 精细加工方式(输入装配成行，并对特殊字符进行处理)；
2. 原始方式(输入不装配成行，也不对特殊字符进行处理)；
3. cbreak方式(输入不装配成行，但对某些特殊字符进行处理)。

**** termios结构

#+BEGIN_SRC cpp
struct termios {
 tcflag_t c_iflag; /* Input modes */
 tcflag_t c_oflag; /* Output modes */
 tcflag_t c_cflag; /* Control modes */
 tcflag_t c_lflag; /* Local modes */
 cc_t c_cc[NCCS]; /* Control characters */
};
#+END_SRC


各个字段的选项如下(不是所有UNIX系统都支持)：

***** c_iflag：

- BRKINT：接到BREAK时产生SIGINT；
- ICRNL：将输入的CR转换为NL；
- IGNBRK：忽略BREAK条件；
- IGNCR：忽略CR；
- IGNPAR：忽略奇偶错字符；
- IMAXBEL：在输入队列空时振铃；
- INLCR：将输入的NL转换为CR；
- INPCK：打开输入奇偶校验；
- ISTRIP：剥除输入字符的第8位；
- IUCLC：将输入的大写字符转换成小写字符(仅SVR4)；
- IXANY：使任一字符都重新起动输出；
- IXOFF：使起动/停止输入控制流起作用；
- IXON：使起动/停止输出控制流起作用；
- PARMRK：标记奇偶错；

***** c_oflag：

- BSDLY：退格延迟屏蔽(仅SVR4)；
- CRDLY：CR延迟屏蔽(仅SVR4)；
- FFDLY：换页延迟屏蔽(仅SVR4)；
- NLDLY：NL延迟屏蔽(仅SVR4)；
- OCRNL：将输出的CR转换为NL(仅SVR4)；
- OFDEL：填充符为DEL，否则为NUL(仅SVR4)；
- OFILL：对于延迟使用填充符(仅SVR4)；
- OLCUC：将输出的小写字符转换为大写字符(仅SVR4)；
- ONLCR：将NL转换为CR-NL；
- ONLRET：NL执行CR功能(仅SVR4)；
- ONOCR：在0列不输出CR(仅SVR4)；
- ONOEOT：在输出中删除EOT字符(仅4.3+BSD)；
- OPOST：执行输出处理；
- OXTABS：将制表符扩充为空格(仅4.3+BSD)；
- TABDLY：水平制表符延迟屏蔽(仅SVR4)；
- VTDLY：垂直制表符延迟屏蔽(仅SVR4)；

***** c_cflag：

- CCTS_OFLOW：输出的CTS流控制(仅4.3+BSD)；
- CIGNORE：忽略控制标志(仅4.3+BSD)；
- CLOCAL：忽略解制解调器状态行；
- CREAD：启用接收装置；
- CRTS_IFLOW：输入的RTS流控制(仅4.3+BSD)；
- CSIZE：字符大小屏蔽；
- CSTOPB：送两个停止位，否则为1位；
- HUPCL：最后关闭时断开；
- MDMBUF：经载波的流控输出(仅4.3+BSD)；
- PARENB：进行奇偶校；
- PARODD：奇校，否则为偶校；

***** c_lflag：

- ALTWERASE：使用替换WERASE算法(仅4.3+BSD)；
- ECHO：进行回送；
- ECHOCTL：回送控制字符为\^(char)；
- ECHOE：可见擦除符；
- ECHOK：回送kill符；
- ECHOKE：kill的可见擦除；
- ECHONL：回送NL；
- ECHOPRT：硬拷贝的可见擦除方式；
- FLUSHO：刷清输出；
- ICANON：规范输入；
- IEXTEN：使扩充的输入字符处理起作用；
- ISIG：使终端产生的信号起作用；
- NOFLSH：在中断或退出键后不刷清；
- NOKERNINFO：STATUS不使内核输出(仅4.3+BSD)；
- PENDIN：重新打印；
- TOSTOP：对于后台输出发送SIGTTOU；
- XCASE：规范大/小写表示(仅SVR4)；

所有列出的选择标志(除屏蔽标志外)都用一或多位表示，而屏蔽标志则定义多位。屏蔽标志有一个定义名，每个值也有一个名字。例如，为了设置字符长度，首先用字符长度屏蔽标志CSIZE将表示字符长度的位清0，然后设置下列值之一：CS5、CS6、CS7或CS8。由SVR4支持的6个延迟值也有屏蔽标志：BSDLY、CRDLY、FFDLY、NLDLY、TABDLY和VTDLY。

各个标志的含义如下：

- ALTWERASE：(c_lflag,
   4.3+BSD)此标志设置时，若输入了WERASE字符，则使用一个替换的字擦除算法。它不是向后移动到前一个白空字符为止，而是向后移动到第一个非字母、数字符为止。
- BRKINT：(c_iflag,
   POSIX.1)若此标志设置，而IGNBRK未设置，则在接到BREAK时，输入、输出队列被刷清，并产生一个SIGINT信号。如果此终端设备是一个控制终端，则将此信号送给前台进程组各进程。如果IGNBRK和BRKINT都没有设置，但是设置了PARMRK，则BREAK被读作为三个字节序列/377，/0和/0，如果PARMRK也没有设置，则BREAK被读作为单个字符/0。
- BSDLY：(c_oflag, SVR4)退格延迟屏蔽，此屏蔽的值是BS0或BS1。
- CCTS_OFLOW：(c_cflag, 4.3+BSD)输出的CTS流控制。
- CIGNORE：(c_cflag, 4.3+BSD)忽略控制标志。
- CLOCAL：(c_cflag,
   POSIX.1)如若设置，则忽略调制解调器状态线。这通常意味着该设备是本地连接的。若此标志未设置，则打开一个终端设备常常会阻塞到调制解调器回应。
- CRDLY：(c_oflag, SVR4)回车延迟屏蔽。此屏蔽的值是CR0、CR1、CR2和CR3。
- CREAD：(c_cflag, POSIX.1)如若设置，则接收装置被启用，可以接收字符。
- CRTS_IFLOW：(c_cflag, 4.3+BSD)输入的RTS流控制。
- CSIZE：(c_cflag,
   POSIX.1)此字段是一个屏蔽标志，它指明发送和接收的每个字节的位数。此长度不包括可能有的奇偶校验位。由此屏蔽定义的字段值是CS5、CS6、CS7和CS8，分别表示每个字节包含5、6、7和8位。
- CSTOPB：(c_cflag,
   POSIX.1)如若设置，则使用两位作为停止位，否则只使用一位作为停止位。
- ECHO：(c_lflag,
   POSIX.1)如若设置，则将输入字符回送到终端设备。在规范方式和非规范方式下都可以回送字符。
- ECHOCTL：(c_lflag, SVR4和4.3+BSD)如若设置并且ECHO也设置，则除ASCII
   TAB、ASCII
   NL、START和STOP字符外，其他ASCII控制符(ASCII字符集中的0～037)都被回送为\^X，其中，X是相应控制字符代码值加0100所构成的字符。这就意味着ASCII
   Ctrl-A字符(01)被回送为\^A。ASCII
   DELETE字符(0177)则回送为\^?。如若此标志未设置，则ASCII控制字符按其原样回送。如同ECHO标志，在规范方式和非规范方式下此标志对控制字符回送都起作用。应当了解的是：某些系统回送EOF字符产生的作用有所不同，其原因是EOF的典型值是Ctrl-D，而这是ASCII
   EOT字符，它可能使某些终端挂断。
- ECHOE：(c_lflag,
   POSIX.1)如若设置并且ICANON也设置，则ERASE字符从显示中擦除当前行中的最后一个字符。这通常是在终端驱动程序中写三个字符序列：退格，空格，退格实现的。如若支持WERASE字符，则ECHOE用一个或若干个上述三字符序列擦除前一个字。如若支持ECHOPRT标志，则在这里所说明的ECHOE动作假定ECHOPRT标志没有设置。
- ECHOK：(c_lflag,
   POSIX.1)如若设置并且ICANON也设置，则KILL字符从显示中擦除当前行，或者输出NL字符(用以强调已擦除整个行)。如若支持ECHOKE标志，则这里的说明假定ECHOKE标志没有设置。
- ECHOKE：(c_lflag,
   SVR4和4.3+BSD)如若设置并且ICANON也设置，则回送KILL字符的方式是擦去行中的每一个字符。擦除每个字符的方法则由ECHOE和ECHOPRT标志选择。
- ECHONL：(c_lflag,
   POSIX.1)如若设置并且ICANON也设置，即使没有设置ECHO也回送NL字符。
- ECHOPRT：(c_lflag,
   SVR4和4.3+BSD)如若设置并且ICANON和ECHO也都设置，则ERASE字符(以及WERASE字符，若受到支持)使所有正被擦除的字符按它们被擦除的方式打印。在硬拷贝终端上这常常是有用的，这样可以确切地看到哪些字符正被擦去。
- FFDLY：(c_oflag, SVR4)换页延迟屏蔽。此屏蔽标志值是FF0或FF1。
- FLUSHO：(c_lflag,
   SVR4和4.3+BSD)如若设置，则刷清输出。当键入DISCARD字符时设置此标志，当键入另一个DISCARD字符时，此标志被清除。设置或清除此终端标志也可设置或清除此条件。
- HUPCL：(c_cflag,
   POSIX.1)如若设置，则当最后一个进程关闭此设备时，调制解调器控制线降至低电平(也就是调制解调器的连接断开)。
- ICANON：(c_lflag,
   POSIX.1)如若设置，则按规范方式工作。这使下列字符起作用：EOF、EOL、EOL2、ERASE、KILL、REPRINT、STATUS和WERASE。输入字符被装配成行。如果不以规范方式工作，则读请求直接从输入队列取字符。在至少接到MIN个字节或已超过TIME值之前，read将不返回。
- ICRNL：(c_iflag,
   POSIX.1)如若设置并且IGNCR未设置，即将接收到的CR字符转换成一个NL字符。
- IEXTEN：(c_lflag,
   POSIX.1)如若设置，则识别并处理扩充的、实现定义的特殊字符。
- IGNBRK：(c_iflag,
   POSIX.1)在设置时，忽略输入中的BREAK条件。关于BREAK条件是产生信号还是被读作为数据，请见BRKINT。
- IGNCR：(c_iflag,
   POSIX.1)如若设置，忽略接收到的CR字符。若此标志未设置，而设置了ICRNL标志则将接收到的CR字符转换成一个NL字符。
- IGNPAR：(c_iflag,
   POSIX.1)在设置时，忽略带有结构错误(非BREAK)或奇偶错的输入字节。
- IMAXBEL：(c_iflag, SVR4和4.3+BSD)当输入队列满时响铃。
- INLCR：(c_iflag, POSIX.1)如若设置，则接收到的NL字符转换成CR字符。
- INPCK：(c_iflag,
   POSIX.1)当设置时，使输入奇偶校验起作用。如若未设置INPCK，则使输入奇偶校验不起作用。奇偶“产生和检测”和“输入奇偶性检验”是不同的两件事。奇偶位的产生和检测是由PARENB标志控制的。设置该标志后使串行界面的设备驱动程序对输出字符产生奇偶位，对输入字符则验证其奇偶性。标志PARODD决定该奇偶性应当是奇还是偶。如果一个其奇偶性为错的字符已经来到，则检查INPCK标志的状态。若此标志已设置，则检查IGNPAR标志(以决定是否应忽略带奇偶错的输入字节)，若不应忽略此输入字节，则检查PARMRK标志以决定向读进程应传送那种字符。
- ISIG：(c_lflag,
   POSIX.1)如若设置，则判别输入字符是否是要产生终端信号的特殊字符(INTR，QUIT，SUSP和DSUSP)，若是，则产生相应信号。
- ISTRIP：(c_iflag,
   POSIX.1)当设置时，有效输入字节被剥离为7位。当此标志未设置时，则保留全部8位。
- IUCLC：(c_iflag, SVR4)将输入的大写字符映射为小写字符。
- IXANY：(c_iflag, SVR4和4.3+BSD)使任一字符都能重新起动输出。
- IXOFF：(c_iflag,
   POSIX.1)如若设置，则使起动-停止输入控制起作用。当终端驱动程序发现输入队列将要填满时，输出一个STOP字符。此字符应当由发送数据的设备识别，并使该设备暂停。此后，当已对输入队列中的字符进行了处理后，该终端驱动程序将输出一个START字符，使该设备恢复发送数据。
- IXON：(c_iflag,
   POSIX.1)如若设置，则使起动-停止输出控制起作用。当终端驱动程序接收到一个STOP字符时，输出暂停。在输出暂停时，下一个START字符恢复输出。如若未设置此标志，则START和STOP字符由进程读作为一般字符。
- MDMBUF：(c_cflag, 4.3+BSD)按照调制解调器的载波标志进行输出流控制。
- NLDLY：(c_oflag, SVR4)新行延迟屏蔽。此屏蔽的值是NL0和NL1。
- NOFLSH：(c_lflag,
   POSIX.1)按系统默认，当终端驱动程序产生SIGINT和SIGQUIT信号时，输入、出队列都被刷新。另外，当它产生SIGSUSP信号时，输入队列被刷新。如若设置了NOFLSH标志，则在这些信号产生时，不对输入、出队列进行刷新。
- NOKERNINFO：(c_lflag,
   4.3+BSD)当设置时，此标志阻止STATUS字符使前台进程组的状态信息显示在终端上。但是不论本标志是否设置，STATUS字符使SIGINFO信号送至前台进程组中的所有进程。
- OCRNL：(c_oflag, SVR4)如若设置，将输出的CR字符映照为NL。
- OFDEL：(c_oflag, SVR4)如若设置，则输出填充字符是ASCII
   DEL，否则它是ASCII NUL，见OFILL标志。
- OFILL：(c_oflag, SVR4)如若设置，则为实现延迟，发送填充字符(ASCII
   DEL或ASCII
   NUL，见OFDEL标志)，而不使用时间延迟。见6个延迟屏蔽：BSDLY，CRDLY，FFDLY，NLDLY，TABDLY以及VTDLY。
- OLCUC：(c_oflag, SVR4)如若设置，将小写字符映射为大写。
- ONLCR：(c_oflag, SVR4和4.3+BSD)如若设置，将输出的NL字符映照为CR-NL。
- ONLRET：(c_oflag, SVR4)如若设置，则输出的NL字符将执行回车功能。
- ONOCR：(c_oflag, SVR4)如若设置，则在0列不输出CR。
- ONOEOT：(c_oflag,
   4.3+BSD)如若设置，则在输出中删除EOT字符(\^D)。在将Ctrl-D解释为挂断的终端上这可能是需要的。
- OPOST：(c_oflag, POSIX.1)如若设置，则进行实现定义的输出处理。
- OXTABS：(c_oflag,
   4.3+BSD)如若设置，制表符在输出中被扩展为空格。这与将水平制表延迟(TABDLY)设置为XTABS或TAB3产生同样效果。
- PARENB：(c_cflag,
   POSIX.1)如若设置，则对输出字符产生奇偶位，对输入字符则执行奇偶性检验。若PARODD已设置，则奇偶校验是奇校验，否则是偶校验。也见INPCK、IGNPAR和PARMRK标志部分。
- PARMRK：(c_iflag,
   POSIX.1)，当设置时，并且IGNPAR未设置，则结构性错(非BREAK)和奇偶错的字节由进程读作为三个字符序列/377,
   /0和X，其中X是接收到的具有错误的字节。如若ISTRIP未设置，则一个有效的/377被传送给进程时为/377，/377。如若IGNPAR和PARMRK都未设置，则结构性错和奇偶错的字节都被读作为一个字符/0。
- PARODD：(c_cflag,
   POSIX.1)如若设置，则输出和输入字符的奇偶性都是奇，否则为偶。注意，PARENB标志控制奇偶性的产生和检测。
- PENDIN：(c_lflag,
   SVR4和4.3+BSD)如若设置，则在下一个字符输入时，尚未读的任何输入都由系统重新打印。这一动作与键入REPRINT字符时的作用相类似。
- TABDLY：(c_oflag,
   SVR4)水平制表延迟屏蔽。此屏蔽的值是TAB0、TAB1、TAB2或TAB3。XTABS的值等于TAB3。此值使系统将制表符扩展成空格。系统假定制表符所扩展的空格数到屏幕上最近一个8的倍数处为止。不能更改此假定。
- TOSTOP：(c_lflag,
   POSIX.1)如若设置，并且该实现支持作业控制，则将信号SIGTTOU送到试图与控制终端的一个后台进程的进程组。按默认，此信号暂停该进程组中所有进程。如果写控制终端的进程忽略或阻塞此信号，则终端驱动程序不产生此信号。
- VTDLY：(c_oflag, SVR4)垂直制表延迟屏蔽。此屏蔽的值是VT0或VT1。
- XCASE：(c_lflag,
   SVR4)如若设置，并且ICANON也设置，则认为终端是大写终端，所以输入都变换为小写。为了输入一个大写字符，在其前加一个/。与之类似，输出一个大写字符也在其前加一个/(这一标志已经过时，现在几乎所有终端都支持大、小写字符)。

**** 终端特殊输入字符
**** POSIX终端I/O函数

| tcgetattr         | 取属性(termios结构)；     |
| tcsetattr         | 设置属性(termios结构)；   |
| cfgetispeed    | 得到输入速度；            |
| cfgetospeed       | 得到输出速度；            |
| cfsetispeed       | 设置输入速度；            |
| cfsetospeed       | 设置输出速度；            |
| tcdrain           | 等待所有输出都被传输；    |
| tcflow            | 挂起传输或接收；          |
| tcflush           | 刷清未决输入和/或输出；   |
| tcsendbreak       | 送BREAK字符；             |
| tcgetpgrp         | 得到前台进程组ID；        |
| tcsetpgrp         | 设置前台进程组ID；        |

**** tcgetattr和tcsetattr

#+BEGIN_EXAMPLE
    #include <termios.h> int tcgetattr(int filedes, struct termios *termptr); int tcsetattr(int filedes, int opt, const struct termios *termptr); 两个函数返回：若成功则为0，若出错则为-1
#+END_EXAMPLE

这两个函数都有一个指向termios结构的指针作为其参数，它们返回当前终端的属性，或者设置该终端的属性。因为这两个函数只对终端设备进行操作，所以若filedes并不引用一个终端设备则出错返回，errno设置为ENOTTY。

tcsetattr的参数opt使我们可以指定在什么时候新的终端属性才起作用。opt可以指定为下列常数中的一个：

- TCSANOW：更改立即发生；
- TCSADRAIN：发送了所有输出后更改才发生。若更改输出参数则应使用此选择项。
- TCSAFLUSH：发送了所有输出后更改才发生。更进一步，在更改发生时未读的所有输入数据都被删除(刷清)。

tcsetattr函数的返回值易于产生混淆。如果它执行了任意一种所要求的动作，即使未能执行所有要求的动作，它也返回0(表示成功)。如果该函数返回0，则我们有责任检查该函数是否执行了所有要求的动作。这就意味着，在调用tcsetattr设置所希望的属性后，需调用tcgetattr，然后将实际终端属性与所希望的属性相比较，以检测两者是否有区别。

**** 波特率函数

波特率(baudrate)是一个历史沿用的术语，现在它指的是“位/每秒”。虽然大
多数终端设备对输入和输出使用同一波特率，但是只要硬件许可，可以将它们设
置为两个不同值。

#+BEGIN_EXAMPLE
    #include <termios.h> speed_t cfgetispeed(const struct termios *termptr); speed_t cfgetospeed(const struct termios *termptr); 两个函数返回：波特率值 int cfsetispeed(struct termios *termptr, speed_t speed); int cfsetospeed(struct termios *termptr, speed_t speed); 两个函数返回：若成功为0，出错为-1
#+END_EXAMPLE

两个cfget函数的返回值，以及两个cfset函数的speed参数都是下列常数之一：
B50、B75、B110、B134、B150、B200、B300、B600、B1200、B1800、B2400、
B4800、B9600、B19200或B38400。常数B0表示“挂断”。在调用tcsetattr时将
输出波特率指定为B0，则调制解调器的控制线就不再起作用。

使用这些函数时，应当理解输入、输出波特率是存放在termios结构中的。在调
用任一cfget函数之前，先要用tcgetattr获得设备的termios结构。与此类似，
在调用任一cfset函数后，应将波特率设置到termios结构中。为使这种更改影响
到设备，应当调用tcsetattr函数。如果所设置的波特率有错，则在调用
tcsetattr之前，不会发现这种错误。

**** 行控制函数

#+BEGIN_EXAMPLE
    #include <termios.h> int tcdrain(int filedes); int tcflow(int filedes, int action); int tcflush(int filedes, int queue); int tcsendbreak(int filedes, int duration); 四个函数返回：若成功则为0，若出错则为-1
#+END_EXAMPLE

其中，参数filedes引用一个终端设备，否则出错返回，errno设置为ENOTTY。

tcdrain函数等待所有输出都被发送。

tcflow用于对输入和输出流控制进行控制。action参数应当是下列四个值之一：

- TCOOFF：输出被挂起；
- TCOON：以前被挂起的输出被重新起动；
- TCIOFF：系统发送一个STOP字符。这将使终端设备暂停发送数据；
- TCION：系统发送一个START字符。这将使终端恢复发送数据。

tcflush函数刷清(抛弃)输入缓存(终端驱动程序已接收到，但用户程序尚未读)或输出缓存(用户程序已经写，但尚未发送)。queue参数应当是下列三个常数之一：

- TCIFLUSH：刷清输入队列；
- TCOFLUSH：刷清输出队列；
- TCIOFLUSH：刷清输入、输出队列；

tcsendbreak函数在一个指定的时间区间内发送连续的0位流。若duration参数为0，则此种发送延续0.25~
0.5秒之间。POSIX.1说明若duration非0，则发送时间依赖于实现。

**** 终端标识函数

POSIX.1提供了一个运行时函数，可被调用来决定控制终端的名字:

#+BEGIN_EXAMPLE
    #include <stdio.h> char * ctermid(char *ptr);
#+END_EXAMPLE

如果ptr是非空，则它被认为是一个指针，指向长度至少为L_ctermid字节的数组，进程的控制终端名存放在该数组中。常数L_ctermid定义在<stdio.h>中。若ptr是一个空指针，则该函数为数组(通常作为静态变量)分配空间。同样，进程的控制终端名存放在该数组中。

在这两种情况中，该数组的起始地址被作为函数值返回。因为大多数UNIX系统都使用/dev/tty作为控制终端名，所以此函数的主要作用是帮助提高向其他操作系统的可移植性。

其他终端标识函数还有：

#+BEGIN_EXAMPLE
    #include <unistd.h> int isatty(int filedes); 返回：若为终端设备则为1(真)，否则为0(假) char *ttyname(int filedes); 返回：指向终端路径名的指针，若出错则为NULL
#+END_EXAMPLE

如果文件描述符引用一个终端设备，则isatty返回真，而ttyname则返回在该文件描述符上打开的终端设备的路径名。

**** 规范方式

规范方式发一个读请求，当一行已经输入后，终端驱动程序即返回。许多条件造成读返回：

- 所要求的字节数已读到时读即返回。无需读一个完整的行。如果读了部分行，那么也不会丢失任何信息―下一次读从前一次读的停止处开始。
- 当读到一个行定界符时，读返回。在规范方式中，下列字符被解释为“行结束”：NL、EOL、EOL2和EOF。另外，如若已设置ICRNL，但未设置IGNCR，则CR字符的作用与NL字符一样，所以它也终止一行。在这五个行定界符中，其中只有一个EOF符在终端驱动程序对其进行处理后即被删除。其他四个字符则作为该行的最后一个字符返回调用者。
- 如果捕捉到信号而且该函数并不自动再起动，则读也返回。

**** 非规范方式

将termios结构中c_lflag字段的ICANON标志关闭就使终端处于非规范方式。在非规范方式中，输入数据不装配成行，不处理下列特殊字符：ERASE、KILL、EOF、NL、EOL、EOL2、CR、REPRINT、STATUS和WERASE。

在非规范方式下，由于不是每次返回一行，解决读的方法是：当已读了指定量的数据后，或者已经过了给定量的时间后，即通知系统返回。

这种技术使用termios结构中c_cc数组的两个变量：MIN和TIME。c_cc数组中的这两个元素的下标名为：VMIN和VTIME。

MIN说明一个read返回前的最小字节数。TIME说明等待数据到达的分秒数(秒的1/10为分秒)。有下列四种情形：

- *情形A：MIN > 0, TIME >
   0*。TIME说明一个字节间的计时器，在接到第一个字节时才起动它。在该计时器超时之前，若已接到MIN个字节，则read返回MIN个字节。如果在接到MIN个字节之前，该计时器已超时，则read返回已接收到的字节(因为只有在接到第一个字节时才起动，所以在计时器超时时，至少返回1个字节)。在这种情形中，在接到第一个字节之前，调用者阻塞。如果在调用read时数据已经可用，则这如同在read后，数据立即被接收到一样。
- *情形B：MIN > 0 , TIME = =
   0*。已经接到了MIN个字节时，read才返回。这可以造成read无限期的阻塞。
- *情形C：MIN = = 0，TIME >
   0*。TIME指定了一个调用read时起动的读计时器。(与情形A相比较，两者是不同的)。在接到1个字节或者该计时器超时时，read即返回。如果是计时器超时，则read返回0。
- *情形D ：MIN = = 0，TIME = =
   0*。如果有数据可用，则read最多返回所要求的字节数。如果无数据可用，则read立即返回0。

在所有这些情形中，MIN只是最小值。如果程序要求的数据多于MIN个字节，那么它可能能接收到所要求的字节数。这也适用于MIN
= = 0的情形A和B。

**** break方式和raw方式

对cbreak方式的定义是：

- 非规范方式。这种方式不对某些输入特殊字符进行处理。这种方式仍对信号进行处理，所以用户可以键入任一终端产生的信号。调用者应当捕捉这些信号，否则这种信号就可能终止程序，并且终端将仍处于cbreak方式。作为一般规则，在编写更改终端方式的程序时，应当捕捉大多数信号，以便在程序终止前恢复终端方式；
- 关闭回送(ECHO)标志；
- 每次输入一个字节。为此将MIN设置为1，将TIME设置为0。至少有一个字节可用时，read再返回。

对原始方式的定义是：

- 非规范方式。另外，还关闭了对信号产生字符(ISIG)和扩充输入字符的处理(IEXTEN)。关闭BRKINT，这样就使BREAK字符不再产生信号；
- 关闭回送(ECHO)标志；
- 关闭ICRNL、INPCK、ISTRIP和IXON标志。于是：不再将输入的CR字符变换为NL(ICRNL)、使输入奇偶校验不起作用(INPCK)、不再剥离输入字节的第8位(ISTRIP)、不进行输出流控制(IXON)；
- 8位字符(CS8)，不产生奇偶位，不进行奇偶性检测(PARENB)；
- 禁止所有输出处理(OPOST)；
- 每次输入一个字节(MIN = 1，TIME = 0)。

**** 终端窗口

内核为每个终端和伪终端保存一个winsize结构：

#+BEGIN_EXAMPLE
struct winsize {
 unsigned short ws_row; /* rows, in characters */
 unsigned short ws_col; /* columns, in character */
 unsigned short ws_xpixel; /* horizontal size, pixels */
 unsigned short ws_ypixel; /* vertical size, pixels */
};
#+END_EXAMPLE

此结构的作用是：

1. 用ioctl的TIOCGWINSZ命令可以取此结构的当前值。
2. 用ioctl的TIOCSWINSZ命令可以将此结构的新值存放到内核中。如果此新值与存放在内核中的当前值不同，则向前台进程组发送SIGWINCH信号。此信号的系统默认动作是忽略。
3. 除了存放此结构的当前值以及在此值改变时产生一个信号以外，内核对该结构不进行任何其他操作。对结构中的值进行解释完全是应用程序的工作。

提供这种功能的目的是，当窗口大小发生变化时通知应用程序(例如vi编辑程序)。应用程序接到此信号后，它可以取得窗口大小的新值，然后重绘屏幕。

** tty:Terminal control functions                                      :tty:

The *tty* module defines functions for putting the tty into cbreak and
raw modes.

1. what is tty?
2. what is cbreak mode?
3. what is raw mode?

+Because it requires the termios module, it will work only on Unix+

[[/home/ben/Wally/Journal/Figure/scrot/4904TrQ.png]]

*** 终端模式                                                         :term:

终端I/O有两种不同的工作方式：
1. 规范方式输入处理。在这种方式中，终端输入以行为单位进行处理。对于每
   个读要求，终端驱动程序最多返回一行。
2. 非规范方式输入处理。输入字符不以行为单位进行装配。

如果不作特殊处理，则默认方式是规范方式。

V7和BSD类的终端驱动程序支持三种终端输入方式：
+ 精细加工方式(输入装配成行，并对特殊字符进行处理)；
+ 原始方式(输入不装配成行，也不对特殊字符进行处理)；
+ cbreak方式(输入不装配成行，但对某些特殊字符进行处理)。

**** reference

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/3300d5e1-d8a3-48df-8ff1-bc4be441f46d?title=%E7%BB%88%E7%AB%AFI%2FO%20termios%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%20tcsetattr%E8%AE%BE%E7%BD%AE%20-%20dartagnan%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD][CNDS: 终端I/O termios属性设置 tcsetattr]]
** select: waiting for I/O completion                               :select:

This module provides access to the *select()* and *poll()* functions
available in most operating systems, epoll() available on Linux 2.5+
and kqueue() available on most BSD. Note that on Windows, it only
works for sockets; on other operating systems, it also works for other
file types (in particular, on Unix.

[[/home/ben/Wally/Journal/Figure/scrot/4904tNF.png]]
*
** os                                                                   :os:
*** os 方法和属性
+ os.curdir

+ os.pardir

+ os.getwd()

+ os.listdir()

  #+begin_latex
    \begin{minted}[frame=leftline, mathescape]{text}
    >>> help(os.listdir)
    Help on built-in function listdir in module posix:

    listdir(...)
        listdir(path) -> list_of_strings

        Return a list containing the names of the entries in the directory.

            path: path of directory to list

        The list is in arbitrary order.  It does not include the special
        entries '.' and '..' even if they are present in the directory.
    \end{minted}
  #+end_latex

+ os.path.exists(s)

+ os.path.isdir(s)

*** file path                                                     :file:os:
#+begin_example
  dir(os.path)
  ['__all__', '__builtins__', '__doc__', '__file__', '__name__',

  '__package__', '_joinrealpath', '_unicode', '_uvarprog', '_varprog',
  'abspath', 'altsep', 'basename', 'commonprefix', 'curdir', 'defpath',
  'devnull', 'dirname', 'exists', 'expanduser', 'expandvars', 'extsep',
  'genericpath', 'getatime', 'getctime', 'getmtime', 'getsize', 'isabs',
  'isdir', 'isfile', 'islink', 'ismount', 'join', 'lexists', 'normcase',
  'normpath', 'os', 'pardir', 'pathsep', 'realpath', 'relpath',
  'samefile', 'sameopenfile', 'samestat', 'sep', 'split', 'splitdrive',
  'splitext', 'stat', 'supports_unicode_filenames', 'sys', 'walk',
  'warnings']

#+end_example

** Numpy                                                             :numpy:
*** DONE Python Numpy入门
- State "DONE"       from "TODO"       [2015-12-02 三 14:25] \\
  不用看得过于细致，用的时候自然知道。
CLOCK: [2015-12-02 三 14:09]--[2015-12-02 三 14:25] =>  0:16

+ http://reverland.org/python/2012/08/22/numpy/
+ 教材

**** fundermental

***** installation


***** 数组属性
NumPy的数组类为 *ndarray*, 对象属性有
+ ndarray.ndim: 数组的秩
+ ndarray.shape： 数组的秩的大小
+ ndarray.size：数组元素的总个数
+ ndarray.dtype：数组元素对象的类型
+ ndarray.itemsize：数组中每个元素的字节大小
+ ndarray.data：包含实际数组的缓冲区

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
  from numpy import *
  a = arange(15).reshape(3,5)
  print a

#+END_SRC

#+RESULTS:
:
: >>> [[ 0  1  2  3  4]
:  [ 5  6  7  8  9]
:  [10 11 12 13 14]]

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
a.shape
#+END_SRC

#+RESULTS:
: (3, 5)

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
a.ndim
#+END_SRC

#+RESULTS:
: 2

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
a.dtype.name
#+END_SRC

#+RESULTS:
: 'int32'

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
a.itemsize
#+END_SRC

#+RESULTS:
: 4

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
type(a)
#+END_SRC

#+RESULTS:
: <type 'numpy.ndarray'>

#+HEADERS: :session p1401
#+BEGIN_SRC python :results output :exports both
b = array([6, 7, 8])
b
type(b)
#+END_SRC

#+RESULTS:
:
: array([6, 7, 8])
: <type 'numpy.ndarray'>

***** 创建数组
1. 从列表或元组中

   #+BEGIN_SRC python :results output :exports both :session p1411
     from numpy import *

     a = array([2, 3, 4])
     a
     a.dtype

     b = array([1.2, 3.5, 3.1])
     b.dtype
   #+END_SRC

   #+RESULTS:
   :
   : >>> >>> array([2, 3, 4])
   : dtype('int32')
   : >>> >>> dtype('float64')

   #+BEGIN_SRC python :results output :exports both :session p1411
     b  = array([(1.5, 2, 3), (4, 5, 6)] )
     print b
   #+END_SRC

   #+RESULTS:
   :
   : [[ 1.5  2.   3. ]
   :  [ 4.   5.   6. ]]

   显式指定数组数据类型
   #+BEGIN_SRC python :results output :exports both :session p1411
     c = array([[1,2], [3, 4]], dtype=complex)
     print c
   #+END_SRC

   #+RESULTS:
   :
   : [[ 1.+0.j  2.+0.j]
   :  [ 3.+0.j  4.+0.j]]

2. 占位函数
   + zeros，全0
   + ones，全1
   + empty, 随机

   #+BEGIN_SRC python :results output :exports both :session p1417
   from numpy import *

   zeros((3, 4))
   #+END_SRC

   #+RESULTS:
   :
   : >>> array([[ 0.,  0.,  0.,  0.],
   :        [ 0.,  0.,  0.,  0.],
   :        [ 0.,  0.,  0.,  0.]])

   #+BEGIN_SRC python :results output :exports both :session p1417
   ones((2,3,4), dtype=int16)
   #+END_SRC

   #+RESULTS:
   : array([[[1, 1, 1, 1],
   :         [1, 1, 1, 1],
   :         [1, 1, 1, 1]],
   :
   :        [[1, 1, 1, 1],
   :         [1, 1, 1, 1],
   :         [1, 1, 1, 1]]], dtype=int16)

   #+BEGIN_SRC python :results output :exports both :session p1417
   empty((2,3))
   #+END_SRC

   #+RESULTS:
   : array([[ -1.16708973e-041,   7.32845376e+025,   1.71130458e+059],
   :        [  1.79918168e+035,   7.89614618e+150,   3.18291433e-023]])

3. arange 类似 range

*** [[http://reverland.org/python/2012/08/22/numpy/index.html][试验性NumPy教程(译)]]                                 :translation:guide:

原文来自 [[http://scipy.org/Tentative_NumPy_Tutorial][Tentative NumPy Tutorial]]

**** 先决条件

在阅读这个教程之前，你多少需要知道点python。如果你想重新回忆下，请看看[[http://docs.python.org/tut/][Python
Tutorial]].

如果你想要运行教程中的示例，你至少需要在你的电脑上安装了以下一些软件:

-  [[http://www.python.org/][Python]]
-  [[http://numpy.scipy.org/][NumPy]]

这些是可能对你有帮助的:

-  [[http://ipython.scipy.org/][ipython]]是一个净强化的交互Python
   Shell，对探索NumPy的特性非常方便。
-  [[http://matplotlib.sourceforge.net/][matplotlib]]将允许你绘图
-  [[http://scipy.org/][Scipy]]在NumPy的基础上提供了很多科学模块

**** 基础篇

NumPy的主要对象是同种元素的多维数组。这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格(通常是元素是数字)。在NumPy中维度(dimensions)叫做轴(axes)，轴的个数叫做秩(rank)。

例如，在3D空间一个点的坐标=[1, 2, 3]=是一个秩为1的数组，因为它只有一个轴。那个轴长度为3.又例如，在以下例子中，数组的秩为2(它有两个维度).第一个维度长度为2,第二个维度长度为3.

#+BEGIN_EXAMPLE
    [[ 1., 0., 0.],
     [ 0., 1., 2.]]
#+END_EXAMPLE

NumPy的数组类被称作/ndarray/。通常被称作数组。注意numpy.array和标准Python库类array.array并不相同，后者只处理一维数组和提供少量功能。更多重要ndarray对象属性有：

-  ndarray.ndim

   数组轴的个数，在python的世界中，轴的个数被称作秩

-  ndarray.shape

   数组的维度。这是一个指示数组在每个维度上大小的整数元组。例如一个n排m列的矩阵，它的shape属性将是(2,3),这个元组的长度显然是秩，即维度或者ndim属性

-  ndarray.size

   数组元素的总个数，等于shape属性中元组元素的乘积。

-  ndarray.dtype

   一个用来描述数组中元素类型的对象，可以通过创造或指定dtype使用标准Python类型。另外NumPy提供它自己的数据类型。

-  ndarray.itemsize

   数组中每个元素的字节大小。例如，一个元素类型为float64的数组itemsiz属性值为8(=64/8),又如，一个元素类型为complex32的数组item属性为4(=32/8).

-  ndarray.data

   包含实际数组元素的缓冲区，通常我们不需要使用这个属性，因为我们总是通过索引来使用数组中的元素。

***** 一个例子[[在python的交互环境或ipython中][\^1]]

#+BEGIN_EXAMPLE
    >>> from numpy  import *
    >>> a = arange(15).reshape(3, 5)
    >>> a
    array([[ 0,  1,  2,  3,  4],
           [ 5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14]])
    >>> a.shape
    (3, 5)
    >>> a.ndim
    2
    >>> a.dtype.name
    'int32'
    >>> a.itemsize
    4
    >>> a.size
    15
    >>> type(a)
    numpy.ndarray
    >>> b = array([6, 7, 8])
    >>> b
    array([6, 7, 8])
    >>> type(b)
    numpy.ndarray
#+END_EXAMPLE

***** 创建数组

有好几种创建数组的方法。

例如，你可以使用=array=函数从常规的Python列表和元组创造数组。所创建的数组类型由原序列中的元素类型推导而来。

#+BEGIN_EXAMPLE
    >>> from numpy  import *
    >>> a = array( [2,3,4] )
    >>> a
    array([2, 3, 4])
    >>> a.dtype
    dtype('int32')
    >>> b = array([1.2, 3.5, 5.1])
    >>> b.dtype
    dtype('float64')
#+END_EXAMPLE

一个常见的错误包括用多个数值参数调用=array=而不是提供一个由数值组成的列表作为一个参数。

#+BEGIN_EXAMPLE
    >>> a = array(1,2,3,4)    # WRONG

    >>> a = array([1,2,3,4])  # RIGHT
#+END_EXAMPLE

数组将序列包含序列转化成二维的数组，序列包含序列包含序列转化成三维数组等等。

#+BEGIN_EXAMPLE
    >>> b = array( [ (1.5,2,3), (4,5,6) ] )
    >>> b
    array([[ 1.5,  2. ,  3. ],
           [ 4. ,  5. ,  6. ]])
#+END_EXAMPLE

数组类型可以在创建时显示指定

#+BEGIN_EXAMPLE
    >>> c = array( [ [1,2], [3,4] ], dtype=complex )
    >>> c
    array([[ 1.+0.j,  2.+0.j],
           [ 3.+0.j,  4.+0.j]])
#+END_EXAMPLE

通常，数组的元素开始都是未知的，但是它的大小已知。因此，NumPy提供了一些使用占位符创建数组的函数。这最小化了扩展数组的需要和高昂的运算代价。

函数=function=创建一个全是0的数组，函数=ones=创建一个全1的数组，函数=empty=创建一个内容随机并且依赖与内存状态的数组。默认创建的数组类型(dtype)都是float64。

#+BEGIN_EXAMPLE
    >>> zeros( (3,4) )
    array([[0.,  0.,  0.,  0.],
           [0.,  0.,  0.,  0.],
           [0.,  0.,  0.,  0.]])
    >>> ones( (2,3,4), dtype=int16 )                # dtype can also be specified
    array([[[ 1, 1, 1, 1],
            [ 1, 1, 1, 1],
            [ 1, 1, 1, 1]],
           [[ 1, 1, 1, 1],
            [ 1, 1, 1, 1],
            [ 1, 1, 1, 1]]], dtype=int16)
    >>> empty( (2,3) )
    array([[  3.73603959e-262,   6.02658058e-154,   6.55490914e-260],
           [  5.30498948e-313,   3.14673309e-307,   1.00000000e+000]])
#+END_EXAMPLE

为了创建一个数列，NumPy提供一个类似arange的函数返回数组而不是列表:

#+BEGIN_EXAMPLE
    >>> arange( 10, 30, 5 )
    array([10, 15, 20, 25])
    >>> arange( 0, 2, 0.3 )                 # it accepts float arguments
    array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8])
#+END_EXAMPLE

当=arange=使用浮点数参数时，由于有限的浮点数精度，通常无法预测获得的元素个数。因此，最好使用函数=linspace=去接收我们想要的元素个数来代替用range来指定步长。

其它函数array, zeros, zeros_like, ones, ones_like, empty, empty_like,
arange, linspace, rand, randn, fromfunction,
fromfile参考：[[http://scipy.org/Numpy_Example_List][NumPy示例]]

***** 打印数组

当你打印一个数组，NumPy以类似嵌套列表的形式显示它，但是呈以下布局：

-  最后的轴从左到右打印
-  次后的轴从顶向下打印
-  剩下的轴从顶向下打印，每个切片通过一个空行与下一个隔开

一维数组被打印成行，二维数组成矩阵，三维数组成矩阵列表。

#+BEGIN_EXAMPLE
    >>> a = arange(6)                         # 1d array
    >>> print a
    [0 1 2 3 4 5]
    >>>
    >>> b = arange(12).reshape(4,3)           # 2d array
    >>> print b
    [[ 0  1  2]
     [ 3  4  5]
     [ 6  7  8]
     [ 9 10 11]]
    >>>
    >>> c = arange(24).reshape(2,3,4)         # 3d array
    >>> print c
    [[[ 0  1  2  3]
      [ 4  5  6  7]
      [ 8  9 10 11]]

     [[12 13 14 15]
      [16 17 18 19]
      [20 21 22 23]]]
#+END_EXAMPLE

查看形状操作一节获得有关reshape的更多细节

如果一个数组用来打印太大了，NumPy自动省略中间部分而只打印角落

#+BEGIN_EXAMPLE
    >>> print arange(10000)
    [   0    1    2 ..., 9997 9998 9999]
    >>>
    >>> print arange(10000).reshape(100,100)
    [[   0    1    2 ...,   97   98   99]
     [ 100  101  102 ...,  197  198  199]
     [ 200  201  202 ...,  297  298  299]
     ...,
     [9700 9701 9702 ..., 9797 9798 9799]
     [9800 9801 9802 ..., 9897 9898 9899]
     [9900 9901 9902 ..., 9997 9998 9999]]
#+END_EXAMPLE

禁用NumPy的这种行为并强制打印整个数组，你可以设置printoptions参数来更改打印选项。

#+BEGIN_EXAMPLE
    >>> set_printoptions(threshold='nan')
#+END_EXAMPLE

***** 基本运算

数组的算术运算是按元素的。新的数组被创建并且被结果填充。

#+BEGIN_EXAMPLE
    >>> a = array( [20,30,40,50] )
    >>> b = arange( 4 )
    >>> b
    array([0, 1, 2, 3])
    >>> c = a-b
    >>> c
    array([20, 29, 38, 47])
    >>> b**2
    array([0, 1, 4, 9])
    >>> 10*sin(a)
    array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])
    >>> a<35
    array([True, True, False, False], dtype=bool)
#+END_EXAMPLE

不像许多矩阵语言，NumPy中的乘法运算符=*=指示按元素计算，矩阵乘法可以使用=dot=函数或创建矩阵对象实现(参见教程中的矩阵章节)

#+BEGIN_EXAMPLE
    >>> A = array( [[1,1],
    ...             [0,1]] )
    >>> B = array( [[2,0],
    ...             [3,4]] )
    >>> A*B                         # elementwise product
    array([[2, 0],
           [0, 4]])
    >>> dot(A,B)                    # matrix product
    array([[5, 4],
           [3, 4]])
#+END_EXAMPLE

有些操作符像=+==和=*==被用来更改已存在数组而不创建一个新的数组。

#+BEGIN_EXAMPLE
    >>> a = ones((2,3), dtype=int)
    >>> b = random.random((2,3))
    >>> a *= 3
    >>> a
    array([[3, 3, 3],
           [3, 3, 3]])
    >>> b += a
    >>> b
    array([[ 3.69092703,  3.8324276 ,  3.0114541 ],
           [ 3.18679111,  3.3039349 ,  3.37600289]])
    >>> a += b                                  # b is converted to integer type
    >>> a
    array([[6, 6, 6],
           [6, 6, 6]])
#+END_EXAMPLE

当运算的是不同类型的数组时，结果数组和更普遍和精确的已知(这种行为叫做upcast)。

#+BEGIN_EXAMPLE
    >>> a = ones(3, dtype=int32)
    >>> b = linspace(0,pi,3)
    >>> b.dtype.name
    'float64'
    >>> c = a+b
    >>> c
    array([ 1.        ,  2.57079633,  4.14159265])
    >>> c.dtype.name
    'float64'
    >>> d = exp(c*1j)
    >>> d
    array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,
           -0.54030231-0.84147098j])
    >>> d.dtype.name
    'complex128'
#+END_EXAMPLE

许多非数组运算，如计算数组所有元素之和，被作为ndarray类的方法实现

#+BEGIN_EXAMPLE
    >>> a = random.random((2,3))
    >>> a
    array([[ 0.6903007 ,  0.39168346,  0.16524769],
           [ 0.48819875,  0.77188505,  0.94792155]])
    >>> a.sum()
    3.4552372100521485
    >>> a.min()
    0.16524768654743593
    >>> a.max()
    0.9479215542670073
#+END_EXAMPLE

这些运算默认应用到数组好像它就是一个数字组成的列表，无关数组的形状。然而，指定=axis=参数你可以吧运算应用到数组指定的轴上：

#+BEGIN_EXAMPLE
    >>> b = arange(12).reshape(3,4)
    >>> b
    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11]])
    >>>
    >>> b.sum(axis=0)                            # sum of each column
    array([12, 15, 18, 21])
    >>>
    >>> b.min(axis=1)                            # min of each row
    array([0, 4, 8])
    >>>
    >>> b.cumsum(axis=1)                         # cumulative sum along each row
    array([[ 0,  1,  3,  6],
           [ 4,  9, 15, 22],
           [ 8, 17, 27, 38]])
#+END_EXAMPLE

***** 通用函数(ufunc)

NumPy提供常见的数学函数如=sin=,=cos=和=exp=。在NumPy中，这些叫作“通用函数”(ufunc)。在NumPy里这些函数作用按数组的元素运算，产生一个数组作为输出。

#+BEGIN_EXAMPLE
    >>> B = arange(3)
    >>> B
    array([0, 1, 2])
    >>> exp(B)
    array([ 1.        ,  2.71828183,  7.3890561 ])
    >>> sqrt(B)
    array([ 0.        ,  1.        ,  1.41421356])
    >>> C = array([2., -1., 4.])
    >>> add(B, C)
    array([ 2.,  0.,  6.])
#+END_EXAMPLE

更多函数all, alltrue, any, apply along axis, argmax, argmin, argsort,
average, bincount, ceil, clip, conj, conjugate, corrcoef, cov, cross,
cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum,
mean, median, min, minimum, nonzero, outer, prod, re, round, sometrue,
sort, std, sum, trace, transpose, var, vdot, vectorize, where
参见:[[http://scipy.org/Numpy_Example_List][NumPy示例]]

***** 索引，切片和迭代

/一维/数组可以被索引、切片和迭代，就像[[http://docs.python.org/tutorial/introduction.html#SECTION005140000000000000000][列表]]和其它Python序列。

#+BEGIN_EXAMPLE
    >>> a = arange(10)**3
    >>> a
    array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])
    >>> a[2]
    8
    >>> a[2:5]
    array([ 8, 27, 64])
    >>> a[:6:2] = -1000    # equivalent to a[0:6:2] = -1000; from start to position 6, exclusive, set every 2nd element to -1000
    >>> a
    array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])
    >>> a[ : :-1]                                 # reversed a
    array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])
    >>> for i in a:
    ...         print i**(1/3.),
    ...
    nan 1.0 nan 3.0 nan 5.0 6.0 7.0 8.0 9.0
#+END_EXAMPLE

/多维/数组可以每个轴有一个索引。这些索引由一个逗号分割的元组给出。

#+BEGIN_EXAMPLE
    >>> def f(x,y):
    ...         return 10*x+y
    ...
    >>> b = fromfunction(f,(5,4),dtype=int)
    >>> b
    array([[ 0,  1,  2,  3],
           [10, 11, 12, 13],
           [20, 21, 22, 23],
           [30, 31, 32, 33],
           [40, 41, 42, 43]])
    >>> b[2,3]
    23
    >>> b[0:5, 1]                       # each row in the second column of b
    array([ 1, 11, 21, 31, 41])
    >>> b[ : ,1]                        # equivalent to the previous example
    array([ 1, 11, 21, 31, 41])
    >>> b[1:3, : ]                      # each column in the second and third row of b
    array([[10, 11, 12, 13],
           [20, 21, 22, 23]])
#+END_EXAMPLE

当少于轴数的索引被提供时，确失的索引被认为是整个切片：

#+BEGIN_EXAMPLE
    >>> b[-1]                                  # the last row. Equivalent to b[-1,:]
    array([40, 41, 42, 43])
#+END_EXAMPLE

=b[i]=中括号中的表达式被当作=i=和一系列=:=，来代表剩下的轴。NumPy也允许你使用“点”像=b[i,...]=。

/点/(...)代表许多产生一个完整的索引元组必要的分号。如果x是秩为5的数组(即它有5个轴)，那么:

-  x[1,2,...] 等同于 x[1,2,:,:,:],
-  x[...,3] 等同于 x[:,:,:,:,3]
-  x[4,...,5,:] 等同 x[4,:,:,5,:].

#+BEGIN_EXAMPLE
    <!--￼0-->
    >>> c = array( [ [[  0,  1,  2],      # a 3D array (two stacked 2D arrays)
    ...               [ 10, 12, 13]],
    ...
    ...              [[100,101,102],
    ...               [110,112,113]] ] )
    >>> c.shape
    (2, 2, 3)
    >>> c[1,...]                          # same as c[1,:,:] or c[1]
    array([[100, 101, 102],
           [110, 112, 113]])
    >>> c[...,2]                          # same as c[:,:,2]
    array([[  2,  13],
           [102, 113]])
    ```
#+END_EXAMPLE

/迭代/多维数组是就第一个轴而言的:[[0轴][\^2]]

#+BEGIN_EXAMPLE
    >>> for row in b:
    ...         print row
    ...
    [0 1 2 3]
    [10 11 12 13]
    [20 21 22 23]
    [30 31 32 33]
    [40 41 42 43]
#+END_EXAMPLE

然而，如果一个人想对每个数组中元素进行运算，我们可以使用flat属性，该属性是数组元素的一个迭代器:

#+BEGIN_EXAMPLE
    >>> for element in b.flat:
    ...         print element,
    ...
    0 1 2 3 10 11 12 13 20 21 22 23 30 31 32 33 40 41 42 43
#+END_EXAMPLE

更多[], ..., newaxis, ndenumerate, indices, index exp
参考[[http://scipy.org/Numpy_Example_List][NumPy示例]]

**** 形状操作

***** 更改数组的形状

一个数组的形状由它每个轴上的元素个数给出：

#+BEGIN_EXAMPLE
    >>> a = floor(10*random.random((3,4)))
    >>> a
    array([[ 7.,  5.,  9.,  3.],
           [ 7.,  2.,  7.,  8.],
           [ 6.,  8.,  3.,  2.]])
    >>> a.shape
    (3, 4)
#+END_EXAMPLE

一个数组的形状可以被多种命令修改：

#+BEGIN_EXAMPLE
    >>> a.ravel() # flatten the array
    array([ 7.,  5.,  9.,  3.,  7.,  2.,  7.,  8.,  6.,  8.,  3.,  2.])
    >>> a.shape = (6, 2)
    >>> a.transpose()
    array([[ 7.,  9.,  7.,  7.,  6.,  3.],
           [ 5.,  3.,  2.,  8.,  8.,  2.]])
#+END_EXAMPLE

由=ravel()=展平的数组元素的顺序通常是“C风格”的，就是说，最右边的索引变化得最快，所以元素a[0,0]之后是a[0,1]。如果数组被改变形状(reshape)成其它形状，数组仍然是“C风格”的。NumPy通常创建一个以这个顺序保存数据的数组，所以=ravel()=将总是不需要复制它的参数[[即self，它自己][\^3]]。但是如果数组是通过切片其它数组或有不同寻常的选项时，它可能需要被复制。函数=reshape()=和=ravel()=还可以被同过一些可选参数构建成FORTRAN风格的数组，即最左边的索引变化最快。

=reshape=函数改变参数形状并返回它，而=resize=函数改变数组自身。

#+BEGIN_EXAMPLE
    >>> a
    array([[ 7.,  5.],
           [ 9.,  3.],
           [ 7.,  2.],
           [ 7.,  8.],
           [ 6.,  8.],
           [ 3.,  2.]])
    >>> a.resize((2,6))
    >>> a
    array([[ 7.,  5.,  9.,  3.,  7.,  2.],
           [ 7.,  8.,  6.,  8.,  3.,  2.]])
#+END_EXAMPLE

如果在改变形状操作中一个维度被给做-1，其维度将自动被计算

更多 shape, reshape, resize, ravel
参考[[http://scipy.org/Numpy_Example_List][NumPy示例]]

***** 组合(stack)不同的数组

几种方法可以沿不同轴将数组堆叠在一起：

#+BEGIN_EXAMPLE
    >>> a = floor(10*random.random((2,2)))
    >>> a
    array([[ 1.,  1.],
           [ 5.,  8.]])
    >>> b = floor(10*random.random((2,2)))
    >>> b
    array([[ 3.,  3.],
           [ 6.,  0.]])
    >>> vstack((a,b))
    array([[ 1.,  1.],
           [ 5.,  8.],
           [ 3.,  3.],
           [ 6.,  0.]])
    >>> hstack((a,b))
    array([[ 1.,  1.,  3.,  3.],
           [ 5.,  8.,  6.,  0.]])
#+END_EXAMPLE

函数=column_stack=以列将一维数组合成二维数组，它等同与=vstack=对一维数组。

#+BEGIN_EXAMPLE
    >>> column_stack((a,b))   # With 2D arrays
    array([[ 1.,  1.,  3.,  3.],
           [ 5.,  8.,  6.,  0.]])
    >>> a=array([4.,2.])
    >>> b=array([2.,8.])
    >>> a[:,newaxis]  # This allows to have a 2D columns vector
    array([[ 4.],
           [ 2.]])
    >>> column_stack((a[:,newaxis],b[:,newaxis]))
    array([[ 4.,  2.],
           [ 2.,  8.]])
    >>> vstack((a[:,newaxis],b[:,newaxis])) # The behavior of vstack is different
    array([[ 4.],
           [ 2.],
           [ 2.],
           [ 8.]])
#+END_EXAMPLE

=row_stack=函数，另一方面，将一维数组以行组合成二维数组。

对那些维度比二维更高的数组，=hstack=沿着第二个轴组合，=vstack=沿着第一个轴组合,=concatenate=允许可选参数给出组合时沿着的轴。

/Note/

在复杂情况下，=r_[]=和=c_[]=对创建沿着一个方向组合的数很有用，它们允许范围符号(“:”):

#+BEGIN_EXAMPLE
    >>> r_[1:4,0,4]
    array([1, 2, 3, 0, 4])
#+END_EXAMPLE

当使用数组作为参数时，=r_=和=c_=的默认行为和=vstack=和=hstack=很像，但是允许可选的参数给出组合所沿着的轴的代号。

更多函数hstack , vstack, column_stack , row_stack , concatenate , c_
, r_\\
参见[[http://scipy.org/Numpy_Example_List][NumPy示例]].

***** 将一个数组分割(split)成几个小数组

使用=hsplit=你能将数组沿着它的水平轴分割，或者指定返回相同形状数组的个数，或者指定在哪些列后发生分割:

#+BEGIN_EXAMPLE
    >>> a = floor(10*random.random((2,12)))
    >>> a
    array([[ 8.,  8.,  3.,  9.,  0.,  4.,  3.,  0.,  0.,  6.,  4.,  4.],
           [ 0.,  3.,  2.,  9.,  6.,  0.,  4.,  5.,  7.,  5.,  1.,  4.]])
    >>> hsplit(a,3)   # Split a into 3
    [array([[ 8.,  8.,  3.,  9.],
           [ 0.,  3.,  2.,  9.]]), array([[ 0.,  4.,  3.,  0.],
           [ 6.,  0.,  4.,  5.]]), array([[ 0.,  6.,  4.,  4.],
           [ 7.,  5.,  1.,  4.]])]
    >>> hsplit(a,(3,4))   # Split a after the third and the fourth column
    [array([[ 8.,  8.,  3.],
           [ 0.,  3.,  2.]]), array([[ 9.],
           [ 9.]]), array([[ 0.,  4.,  3.,  0.,  0.,  6.,  4.,  4.],
           [ 6.,  0.,  4.,  5.,  7.,  5.,  1.,  4.]])]
#+END_EXAMPLE

=vsplit=沿着纵向的轴分割，=array split=允许指定沿哪个轴分割。

**** 复制和视图

当运算和处理数组时，它们的数据有时被拷贝到新的数组有时不是。这通常是新手的困惑之源。这有三种情况:

***** 完全不拷贝

简单的赋值不拷贝数组对象或它们的数据。

#+BEGIN_EXAMPLE
    >>> a = arange(12)
    >>> b = a            # no new object is created
    >>> b is a           # a and b are two names for the same ndarray object
    True
    >>> b.shape = 3,4    # changes the shape of a
    >>> a.shape
    (3, 4)
#+END_EXAMPLE

Python 传递不定对象作为参考[[形参][\^4]]，所以函数调用不拷贝数组。

#+BEGIN_EXAMPLE
    >>> def f(x):
    ...     print id(x)
    ...
    >>> id(a)                           # id is a unique identifier of an object
    148293216
    >>> f(a)
    148293216
#+END_EXAMPLE

***** 视图(view)和浅复制

不同的数组对象分享同一个数据。视图方法创造一个新的数组对象指向同一数据。

#+BEGIN_EXAMPLE
    >>> c = a.view()
    >>> c is a
    False
    >>> c.base is a                        # c is a view of the data owned by a
    True
    >>> c.flags.owndata
    False
    >>>
    >>> c.shape = 2,6                      # a's shape doesn't change
    >>> a.shape
    (3, 4)
    >>> c[0,4] = 1234                      # a's data changes
    >>> a
    array([[   0,    1,    2,    3],
           [1234,    5,    6,    7],
           [   8,    9,   10,   11]])
#+END_EXAMPLE

切片数组返回它的一个视图：

#+BEGIN_EXAMPLE
    >>> s = a[ : , 1:3]     # spaces added for clarity; could also be written "s = a[:,1:3]"
    >>> s[:] = 10           # s[:] is a view of s. Note the difference between s=10 and s[:]=10
    >>> a
    array([[   0,   10,   10,    3],
           [1234,   10,   10,    7],
           [   8,   10,   10,   11]])
#+END_EXAMPLE

**** 深复制

这个复制方法完全复制数组和它的数据。

#+BEGIN_EXAMPLE
    >>> d = a.copy()                          # a new array object with new data is created
    >>> d is a
    False
    >>> d.base is a                           # d doesn't share anything with a
    False
    >>> d[0,0] = 9999
    >>> a
    array([[   0,   10,   10,    3],
           [1234,   10,   10,    7],
           [   8,   10,   10,   11]])
#+END_EXAMPLE

***** 函数和方法(method)总览

这是个NumPy函数和方法分类排列目录。这些名字链接到[[http://scipy.org/Numpy_Example_List][NumPy示例]],你可以看到这些函数起作用。[[0轴][\^5]]

/创建数组/

#+BEGIN_EXAMPLE
    arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r , zeros, zeros_like
#+END_EXAMPLE

/转化/

#+BEGIN_EXAMPLE
    astype, atleast 1d, atleast 2d, atleast 3d, mat
#+END_EXAMPLE

/操作/

#+BEGIN_EXAMPLE
    array split, column stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack
#+END_EXAMPLE

/询问/

#+BEGIN_EXAMPLE
    all, any, nonzero, where
#+END_EXAMPLE

/排序/

#+BEGIN_EXAMPLE
    argmax, argmin, argsort, max, min, ptp, searchsorted, sort
#+END_EXAMPLE

/运算/

#+BEGIN_EXAMPLE
    choose, compress, cumprod, cumsum, inner, fill, imag, prod, put, putmask, real, sum
#+END_EXAMPLE

/基本统计/

#+BEGIN_EXAMPLE
    cov, mean, std, var
#+END_EXAMPLE

/基本线性代数/

#+BEGIN_EXAMPLE
    cross, dot, outer, svd, vdot
#+END_EXAMPLE

**** 进阶

***** 广播法则(rule)

广播法则能使通用函数有意义地处理不具有相同形状的输入。

广播第一法则是，如果所有的输入数组维度不都相同，一个“1”将被重复地添加在维度较小的数组上直至所有的数组拥有一样的维度。

广播第二法则确定长度为1的数组沿着特殊的方向表现地好像它有沿着那个方向最大形状的大小。对数组来说，沿着那个维度的数组元素的值理应相同。

应用广播法则之后，所有数组的大小必须匹配。更多细节可以从这个[[http://scipy.org/EricsBroadcastingDoc][文档]]找到。

**** 花哨的索引和索引技巧

NumPy比普通Python序列提供更多的索引功能。除了索引整数和切片，正如我们之前看到的，数组可以被整数数组和布尔数组索引。

***** 通过数组索引

#+BEGIN_EXAMPLE
    >>> a = arange(12)**2                          # the first 12 square numbers
    >>> i = array( [ 1,1,3,8,5 ] )                 # an array of indices
    >>> a[i]                                       # the elements of a at the positions i
    array([ 1,  1,  9, 64, 25])
    >>>
    >>> j = array( [ [ 3, 4], [ 9, 7 ] ] )         # a bidimensional array of indices
    >>> a[j]                                       # the same shape as j
    array([[ 9, 16],
           [81, 49]])
#+END_EXAMPLE

当被索引数组a是多维的时，每一个唯一的索引数列指向a的第一维[[0轴][\^5]]。以下示例通过将图片标签用调色版转换成色彩图像展示了这种行为。

#+BEGIN_EXAMPLE
    >>> palette = array( [ [0,0,0],                # black
    ...                    [255,0,0],              # red
    ...                    [0,255,0],              # green
    ...                    [0,0,255],              # blue
    ...                    [255,255,255] ] )       # white
    >>> image = array( [ [ 0, 1, 2, 0 ],           # each value corresponds to a color in the palette
    ...                  [ 0, 3, 4, 0 ]  ] )
    >>> palette[image]                            # the (2,4,3) color image
    array([[[  0,   0,   0],
            [255,   0,   0],
            [  0, 255,   0],
            [  0,   0,   0]],
           [[  0,   0,   0],
            [  0,   0, 255],
            [255, 255, 255],
            [  0,   0,   0]]])
#+END_EXAMPLE

我们也可以给出不不止一维的索引，每一维的索引数组必须有相同的形状。

#+BEGIN_EXAMPLE
    >>> a = arange(12).reshape(3,4)
    >>> a
    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11]])
    >>> i = array( [ [0,1],                        # indices for the first dim of a
    ...              [1,2] ] )
    >>> j = array( [ [2,1],                        # indices for the second dim
    ...              [3,3] ] )
    >>>
    >>> a[i,j]                                     # i and j must have equal shape
    array([[ 2,  5],
           [ 7, 11]])
    >>>
    >>> a[i,2]
    array([[ 2,  6],
           [ 6, 10]])
    >>>
    >>> a[:,j]                                     # i.e., a[ : , j]
    array([[[ 2,  1],
            [ 3,  3]],
           [[ 6,  5],
            [ 7,  7]],
           [[10,  9],
            [11, 11]]])
#+END_EXAMPLE

自然，我们可以把i和j放到序列中(比如说列表)然后通过list索引。

#+BEGIN_EXAMPLE
    >>> l = [i,j]
    >>> a[l]                                       # equivalent to a[i,j]
    array([[ 2,  5],
           [ 7, 11]])
#+END_EXAMPLE

然而，我们不能把i和j放在一个数组中，因为这个数组将被解释成索引a的第一维。

#+BEGIN_EXAMPLE
    >>> s = array( [i,j] )
    >>> a[s]                                       # not what we want
    ---------------------------------------------------------------------------
    IndexError                                Traceback (most recent call last)
    <ipython-input-100-b912f631cc75> in <module>()
    ----> 1 a[s]

    IndexError: index (3) out of range (0<=index<2) in dimension 0
    >>>
    >>> a[tuple(s)]                                # same as a[i,j]
    array([[ 2,  5],
           [ 7, 11]])
#+END_EXAMPLE

另一个常用的数组索引用法是搜索时间序列最大值[[我也不知道在翻译什么了……][\^6]]。

#+BEGIN_EXAMPLE
    >>> time = linspace(20, 145, 5)                 # time scale
    >>> data = sin(arange(20)).reshape(5,4)         # 4 time-dependent series
    >>> time
    array([  20.  ,   51.25,   82.5 ,  113.75,  145.  ])
    >>> data
    array([[ 0.        ,  0.84147098,  0.90929743,  0.14112001],
           [-0.7568025 , -0.95892427, -0.2794155 ,  0.6569866 ],
           [ 0.98935825,  0.41211849, -0.54402111, -0.99999021],
           [-0.53657292,  0.42016704,  0.99060736,  0.65028784],
           [-0.28790332, -0.96139749, -0.75098725,  0.14987721]])
    >>>
    >>> ind = data.argmax(axis=0)                   # index of the maxima for each series
    >>> ind
    array([2, 0, 3, 1])
    >>>
    >>> time_max = time[ ind]                       # times corresponding to the maxima
    >>>
    >>> data_max = data[ind, xrange(data.shape[1])] # => data[ind[0],0], data[ind[1],1]...
    >>>
    >>> time_max
    array([  82.5 ,   20.  ,  113.75,   51.25])
    >>> data_max
    array([ 0.98935825,  0.84147098,  0.99060736,  0.6569866 ])
    >>>
    >>> all(data_max == data.max(axis=0))
    True
#+END_EXAMPLE

你也可以使用数组索引作为目标来赋值：

#+BEGIN_EXAMPLE
    >>> a = arange(5)
    >>> a
    array([0, 1, 2, 3, 4])
    >>> a[[1,3,4]] = 0
    >>> a
    array([0, 0, 2, 0, 0])
#+END_EXAMPLE

然而，当一个索引列表包含重复时，赋值被多次完成，保留最后的值：

#+BEGIN_EXAMPLE
    >>> a = arange(5)
    >>> a[[0,0,2]]=[1,2,3]
    >>> a
    array([2, 1, 3, 3, 4])
#+END_EXAMPLE

这足够合理，但是小心如果你想用Python的=+==结构，可能结果并非你所期望：

#+BEGIN_EXAMPLE
    >>> a = arange(5)
    >>> a[[0,0,2]]+=1
    >>> a
    array([1, 1, 3, 3, 4])
#+END_EXAMPLE

即使0在索引列表中出现两次，索引为0的元素仅仅增加一次。这是因为Python要求=a+=1=和=a=a+1=等同。

***** 通过布尔数组索引

当我们使用整数数组索引数组时，我们提供一个索引列表去选择。通过布尔数组索引的方法是不同的我们显式地选择数组中我们想要和不想要的元素。

我们能想到的使用布尔数组的索引最自然方式就是使用和原数组一样形状的布尔数组。

#+BEGIN_EXAMPLE
    >>> a = arange(12).reshape(3,4)
    >>> b = a > 4
    >>> b                                          # b is a boolean with a's shape
    array([[False, False, False, False],
           [False, True, True, True],
           [True, True, True, True]], dtype=bool)
    >>> a[b]                                       # 1d array with the selected elements
    array([ 5,  6,  7,  8,  9, 10, 11])
#+END_EXAMPLE

这个属性在赋值时非常有用：

#+BEGIN_EXAMPLE
    >>> a[b] = 0                                   # All elements of 'a' higher than 4 become 0
    >>> a
    array([[0, 1, 2, 3],
           [4, 0, 0, 0],
           [0, 0, 0, 0]])
#+END_EXAMPLE

你可以参考[[http://scipy.org/Tentative_NumPy_Tutorial/Mandelbrot_Set_Example][曼德博集合示例]]看看如何使用布尔索引来生成曼德博集合的图像。

第二种通过布尔来索引的方法更近似于整数索引；对数组的每个维度我们给一个一维布尔数组来选择我们想要的切片。

#+BEGIN_EXAMPLE
    >>> a = arange(12).reshape(3,4)
    >>> b1 = array([False,True,True])             # first dim selection
    >>> b2 = array([True,False,True,False])       # second dim selection
    >>>
    >>> a[b1,:]                                   # selecting rows
    array([[ 4,  5,  6,  7],
           [ 8,  9, 10, 11]])
    >>>
    >>> a[b1]                                     # same thing
    array([[ 4,  5,  6,  7],
           [ 8,  9, 10, 11]])
    >>>
    >>> a[:,b2]                                   # selecting columns
    array([[ 0,  2],
           [ 4,  6],
           [ 8, 10]])
    >>>
    >>> a[b1,b2]                                  # a weird thing to do
    array([ 4, 10])
#+END_EXAMPLE

注意一维数组的长度必须和你想要切片的维度或轴的长度一致，在之前的例子中，b1是一个秩为1长度为三的数组(a的行数)，b2(长度为4)与a的第二秩(列)相一致。[[上面最后一个例子，b1和b2中的true个数必须一致][\^7]]

***** ix_()函数

=ix_=函数可以为了获得[[http://zh.wikipedia.org/wiki/%E5%A4%9A%E5%85%83%E7%BB%84][多元组]]的结果而用来结合不同向量。例如，如果你想要用所有向量a、b和c元素组成的三元组来计算=a+b*c=：

#+BEGIN_EXAMPLE
    >>> a = array([2,3,4,5])
    >>> b = array([8,5,4])
    >>> c = array([5,4,6,8,3])
    >>> ax,bx,cx = ix_(a,b,c)
    >>> ax
    array([[[2]],

           [[3]],

           [[4]],

           [[5]]])
    >>> bx
    array([[[8],
            [5],
            [4]]])
    >>> cx
    array([[[5, 4, 6, 8, 3]]])
    >>> ax.shape, bx.shape, cx.shape
    ((4, 1, 1), (1, 3, 1), (1, 1, 5))
    >>> result = ax+bx*cx
    >>> result
    array([[[42, 34, 50, 66, 26],
            [27, 22, 32, 42, 17],
            [22, 18, 26, 34, 14]],
           [[43, 35, 51, 67, 27],
            [28, 23, 33, 43, 18],
            [23, 19, 27, 35, 15]],
           [[44, 36, 52, 68, 28],
            [29, 24, 34, 44, 19],
            [24, 20, 28, 36, 16]],
           [[45, 37, 53, 69, 29],
            [30, 25, 35, 45, 20],
            [25, 21, 29, 37, 17]]])
    >>> result[3,2,4]
    17
    >>> a[3]+b[2]*c[4]
    17
#+END_EXAMPLE

你也可以实行如下简化：

#+BEGIN_EXAMPLE
    def ufunc_reduce(ufct, *vectors):
        vs = ix_(*vectors)
        r = ufct.identity
        for v in vs:
            r = ufct(r,v)
        return r
#+END_EXAMPLE

然后这样使用它：

#+BEGIN_EXAMPLE
    >>> ufunc_reduce(add,a,b,c)
    array([[[15, 14, 16, 18, 13],
            [12, 11, 13, 15, 10],
            [11, 10, 12, 14,  9]],
           [[16, 15, 17, 19, 14],
            [13, 12, 14, 16, 11],
            [12, 11, 13, 15, 10]],
           [[17, 16, 18, 20, 15],
            [14, 13, 15, 17, 12],
            [13, 12, 14, 16, 11]],
           [[18, 17, 19, 21, 16],
            [15, 14, 16, 18, 13],
            [14, 13, 15, 17, 12]]])
#+END_EXAMPLE

这个reduce与ufunc.reduce(比如说add.reduce)相比的优势在于它利用了广播法则，避免了创建一个输出大小乘以向量个数的参数数组。[[我不怎么明白……总之避免创建一个很大的数组。][\^8]]

***** 用字符串索引

参见[[http://www.scipy.org/RecordArrays][RecordArray]]。

**** 线性代数

继续前进，基本线性代数包含在这里。

***** 简单数组运算

参考numpy文件夹中的linalg.py获得更多信息

#+BEGIN_EXAMPLE
    >>> from numpy import *
    >>> from numpy.linalg import *

    >>> a = array([[1.0, 2.0], [3.0, 4.0]])
    >>> print a
    [[ 1.  2.]
     [ 3.  4.]]

    >>> a.transpose()
    array([[ 1.,  3.],
           [ 2.,  4.]])

    >>> inv(a)
    array([[-2. ,  1. ],
           [ 1.5, -0.5]])

    >>> u = eye(2) # unit 2x2 matrix; "eye" represents "I"
    >>> u
    array([[ 1.,  0.],
           [ 0.,  1.]])
    >>> j = array([[0.0, -1.0], [1.0, 0.0]])

    >>> dot (j, j) # matrix product
    array([[-1.,  0.],
           [ 0., -1.]])

    >>> trace(u)  # trace
     2.0

    >>> y = array([[5.], [7.]])
    >>> solve(a, y)
    array([[-3.],
           [ 4.]])

    >>> eig(j)
    (array([ 0.+1.j,  0.-1.j]),
    array([[ 0.70710678+0.j,  0.70710678+0.j],
           [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]]))
    Parameters:
        square matrix

    Returns
        The eigenvalues, each repeated according to its multiplicity.

        The normalized (unit "length") eigenvectors, such that the
        column ``v[:,i]`` is the eigenvector corresponding to the
        eigenvalue ``w[i]`` .
#+END_EXAMPLE

***** 矩阵类

这是一个关于矩阵类的简短介绍。

#+BEGIN_EXAMPLE
    >>> A = matrix('1.0 2.0; 3.0 4.0')
    >>> A
    [[ 1.  2.]
     [ 3.  4.]]
    >>> type(A)  # file where class is defined
    <class 'numpy.matrixlib.defmatrix.matrix'>

    >>> A.T  # transpose
    [[ 1.  3.]
     [ 2.  4.]]

    >>> X = matrix('5.0 7.0')
    >>> Y = X.T
    >>> Y
    [[5.]
     [7.]]

    >>> print A*Y  # matrix multiplication
    [[19.]
     [43.]]

    >>> print A.I  # inverse
    [[-2.   1. ]
     [ 1.5 -0.5]]

    >>> solve(A, Y)  # solving linear equation
    matrix([[-3.],
            [ 4.]])
#+END_EXAMPLE

***** 索引：比较矩阵和二维数组

注意NumPy中数组和矩阵有些重要的区别。NumPy提供了两个基本的对象：一个N维数组对象和一个通用函数对象。其它对象都是建构在它们之上的。特别的，矩阵是继承自NumPy数组对象的二维数组对象。对数组和矩阵，索引都必须包含合适的一个或多个这些组合：整数标量、省略号(ellipses)、整数列表;布尔值，整数或布尔值构成的元组，和一个一维整数或布尔值数组。矩阵可以被用作矩阵的索引，但是通常需要数组、列表或者其它形式来完成这个任务。

像平常在Python中一样，索引是从0开始的。传统上我们用矩形的行和列表示一个二维数组或矩阵，其中沿着0轴的方向被穿过的称作行，沿着1轴的方向被穿过的是列。[[水平是1轴，垂直是0轴。][\^9]]

让我们创建数组和矩阵用来切片：

#+BEGIN_EXAMPLE
    >>> A = arange(12)
    >>> A
    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
    >>> A.shape = (3,4)
    >>> M = mat(A.copy())
    >>> print type(A),"  ",type(M)
    <type 'numpy.ndarray'>    <class 'numpy.core.defmatrix.matrix'>
    >>> print A
    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]]
    >>> print M
    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]]
#+END_EXAMPLE

现在，让我们简单的切几片。基本的切片使用切片对象或整数。例如，=A[:]=和=M[:]=的求值将表现得和Python索引很相似。然而要注意很重要的一点就是NumPy切片数组/不/创建数据的副本;切片提供统一数据的视图。

#+BEGIN_EXAMPLE
    >>> print A[:]; print A[:].shape
    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]]
    (3, 4)
    >>> print M[:]; print M[:].shape
    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]]
    (3, 4)
#+END_EXAMPLE

现在有些和Python索引不同的了：你可以同时使用逗号分割索引来沿着多个轴索引。

#+BEGIN_EXAMPLE
    >>> print A[:,1]; print A[:,1].shape
    [1 5 9]
    (3,)
    >>> print M[:,1]; print M[:,1].shape
    [[1]
     [5]
     [9]]
    (3, 1)
#+END_EXAMPLE

注意最后两个结果的不同。对二维数组使用一个冒号产生一个一维数组，然而矩阵产生了一个二维矩阵。[[`type(M[:,1])`和`type(A[:,1])`你可以看到是这样。][\^10]]例如，一个=M[2,:]=切片产生了一个形状为(1,4)的矩阵，相比之下，一个数组的切片总是产生一个最低可能维度[[什么叫尽可能低的维度？不懂。][\^11]]的数组。例如，如果C是一个三维数组，=C[...,1]=产生一个二维的数组而=C[1,:,1]=产生一个一维数组。从这时开始，如果相应的矩阵切片结果是相同的话，我们将只展示数组切片的结果。

假如我们想要一个数组的第一列和第三列，一种方法是使用列表切片：

#+BEGIN_EXAMPLE
    >>> A[:,[1,3]]
    array([[ 1,  3],
           [ 5,  7],
           [ 9, 11]])
#+END_EXAMPLE

稍微复杂点的方法是使用=take()=方法(method):

#+BEGIN_EXAMPLE
    >>> A[:,].take([1,3],axis=1)
    array([[ 1,  3],
           [ 5,  7],
           [ 9, 11]])
#+END_EXAMPLE

如果我们想跳过第一行，我们可以这样：

#+BEGIN_EXAMPLE
    >>> A[1:,].take([1,3],axis=1)
    array([[ 5,  7],
           [ 9, 11]])
#+END_EXAMPLE

或者我们仅仅使用=A[1:,[1,3]]=。还有一种方法是通过矩阵向量积(叉积)。

#+BEGIN_EXAMPLE
    >>> A[ix_((1,2),(1,3))]
    array([[ 5,  7],
           [ 9, 11]])
#+END_EXAMPLE

为了读者的方便，再次写下之前的矩阵：

#+BEGIN_EXAMPLE
    >>> print A
    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]]
#+END_EXAMPLE

现在让我们做些更复杂的。比如说我们想要保留第一行大于1的列。一种方法是创建布尔索引：

#+BEGIN_EXAMPLE
    >>> A[0,:]>1
    array([False, False, True, True], dtype=bool)
    >>> A[:,A[0,:]>1]
    array([[ 2,  3],
           [ 6,  7],
           [10, 11]])
#+END_EXAMPLE

就是我们想要的！但是索引矩阵没这么方便。

#+BEGIN_EXAMPLE
    >>> M[0,:]>1
    matrix([[False, False, True, True]], dtype=bool)
    >>> M[:,M[0,:]>1]
    matrix([[2, 3]])
#+END_EXAMPLE

这个过程的问题是用“矩阵切片”来切片产生一个矩阵[[用矩阵切片][\^12]]，但是矩阵有个方便的=A=属性，它的值是数组呈现的。所以我们仅仅做以下替代：

#+BEGIN_EXAMPLE
    >>> M[:,M.A[0,:]>1]
    matrix([[ 2,  3],
            [ 6,  7],
            [10, 11]])
#+END_EXAMPLE

如果我们想要在矩阵两个方向有条件地切片，我们必须稍微调整策略，代之以：

#+BEGIN_EXAMPLE
    >>> A[A[:,0]>2,A[0,:]>1]
    array([ 6, 11])
    >>> M[M.A[:,0]>2,M.A[0,:]>1]
    matrix([[ 6, 11]])
#+END_EXAMPLE

我们需要使用向量积=ix_=:

#+BEGIN_EXAMPLE
    >>> A[ix_(A[:,0]>2,A[0,:]>1)]
    array([[ 6,  7],
           [10, 11]])
    >>> M[ix_(M.A[:,0]>2,M.A[0,:]>1)]
    matrix([[ 6,  7],
            [10, 11]])
#+END_EXAMPLE

**** 技巧和提示

下面我们给出简短和有用的提示。

***** “自动”改变形状

更改数组的维度，你可以省略一个尺寸，它将被自动推导出来。

#+BEGIN_EXAMPLE
    >>> a = arange(30)
    >>> a.shape = 2,-1,3  # -1 means "whatever is needed"
    >>> a.shape
    (2, 5, 3)
    >>> a
    array([[[ 0,  1,  2],
            [ 3,  4,  5],
            [ 6,  7,  8],
            [ 9, 10, 11],
            [12, 13, 14]],
           [[15, 16, 17],
            [18, 19, 20],
            [21, 22, 23],
            [24, 25, 26],
            [27, 28, 29]]])
#+END_EXAMPLE

***** 向量组合(stacking)

我们如何用两个相同尺寸的行向量列表构建一个二维数组？在MATLAB中这非常简单：如果x和y是两个相同长度的向量，你仅仅需要做=m=[x;y]=。在NumPy中这个过程通过函数=column_stack=、=dstack=、=hstack=和=vstack=来完成，取决于你想要在那个维度上组合。例如：

#+BEGIN_EXAMPLE
    x = arange(0,10,2)                     # x=([0,2,4,6,8])
    y = arange(5)                          # y=([0,1,2,3,4])
    m = vstack([x,y])                      # m=([[0,2,4,6,8],
                                           #     [0,1,2,3,4]])
    xy = hstack([x,y])                     # xy =([0,2,4,6,8,0,1,2,3,4])
#+END_EXAMPLE

二维以上这些函数背后的逻辑会很奇怪。

参考[[http://scipy.org/NumPy_for_Matlab_Users][写个Matlab用户的NumPy指南]]并且在这里添加你的新发现:
)

***** 直方图(histogram)

NumPy中=histogram=函数应用到一个数组返回一对变量：直方图数组和箱式向量。注意：=matplotlib=也有一个用来建立直方图的函数(叫作=hist=,正如matlab中一样)与NumPy中的不同。主要的差别是=pylab.hist=自动绘制直方图，而=numpy.histogram=仅仅产生数据。

#+BEGIN_EXAMPLE
    import numpy
    import pylab
    # Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2
    mu, sigma = 2, 0.5
    v = numpy.random.normal(mu,sigma,10000)
    # Plot a normalized histogram with 50 bins
    pylab.hist(v, bins=50, normed=1)       # matplotlib version (plot)
    pylab.show()
    # Compute the histogram with numpy and then plot it
    (n, bins) = numpy.histogram(v, bins=50, normed=True)  # NumPy version (no plot)
    pylab.plot(.5*(bins[1:]+bins[:-1]), n)
    pylab.show()
#+END_EXAMPLE

**** 参考文献

-  The [[http://docs.python.org/tut/tut.html][Python tutorial]].
-  The [[http://scipy.org/Numpy_Example_List][Numpy Example List]].
-  The nonexistent [[http://scipy.org/NumPy_Tutorial][NumPy Tutorial]] at scipy.org, where we can find the old Numeric documentation.
-  The [[http://www.tramy.us/][Guide to NumPy]] book.
-  The [[http://scipy.org/SciPy_Tutorial][SciPy Tutorial]] and a [[http://www.rexx.com/~dkuhlman/scipy_course_01.html][SciPy course online]]
-  [[http://scipy.org/NumPy_for_Matlab_Users][NumPy for Matlab Users]].
-  A [[http://mathesaurus.sf.net/][matlab, R, IDL, NumPy/SciPy dictionary]].

** style                                                             :style:

*** [[http://damnever.github.io/2015/04/24/PEP8-style-guide-for-python-code/][PEP 8 - Python 编码风格指南(Style Guide for Python Code)]]          :pep:

By Damnever on April 24, 2015

初次翻译，还请指教！

原文链接：[[https://www.python.org/dev/peps/pep-0008/][Style Guide for Python Code]]

原文作者：Guido van Rossum , Barry Warsaw , Nick Coghlan

**** 介绍

这份文档给出的代码约定适用于主要的 Python 发行版所有标准库中的 Python
代码。请参阅相似的 PEP 信息，其用于描述实现 Python 的 C 代码规范。

这份文档和 [[https://www.python.org/dev/peps/pep-0257][PEP 257]](文档字符串约定) 改编自 Guido 的 Python 风格指南原文，从 Barry
的风格指南里添加了一些东西。

随着时间的推移，这份额外约定的风格指南已经被认可了，过去的约定由于语言
自身的发展被淘汰了。

许多项目有它们自己的编码风格指南。如果有冲突，优先考虑项目规定的编码指南。

**** 愚蠢的一致性是无脑的妖怪（A Foolish Consistency is the Hobgoblin of Little Minds）

Guido 的一个主要见解是读代码多过写代码。这里提供指南的意图是强调代码可
读性的重要性，并且使大多数Python 代码保持一致性。如 [[https://www.python.org/dev/peps/pep-0020][PEP 20]] 所述，“Readability
counts”。

风格指南是关于一致性的。风格一致对于本指南来说是重要的，对一个项目来说
是更重要的，对于一个模块或者方法来说是最重要的。

但是最最重要的是：知道什么时候应该破例--有时候这份风格指南就是不适用。
有疑问时，用你最好的判断力，对比其它的例子来确定这是不是最好的情况，并
且不耻下问。

特别说明：不要为了遵守这份风格指南而破坏代码的向后兼容性。

这里有一些好的理由去忽略某个风格指南：

1. 当应用风格指南的时候使代码更难读了，对于严格依循风格指南的约定去读
   代码的人也是不应该的。

2. 为了保持和风格指南的一致性同时也打破了现有代码的一致性（可能是历史
   原因）--虽然这也是一个整理混乱代码的机会（现实中的 XP 风格）。

3. 因为问题代码的历史比较久远，修改代码就没有必要性了。

4. 当代码需要与旧版本的 Python 保持兼容，而旧版 Python 又不支持风格指
   南中提到的特性的时候。
**** 代码排版

***** 缩进

每层缩进使用4个空格。

续行要么与圆括号、中括号、花括号这样的被包裹元素保持垂直对齐，要么放在
Python
的隐线（注：应该是相对于def的内部块）内部，或者使用悬挂缩进[[#id3][5]]。使用悬挂缩进的注意事项：第一行不能有参数，用进一步的缩进来把其他行区分开。

好的：

#+BEGIN_EXAMPLE
    # Aligned with opening delimiter.
    foo = long_function_name(var_one, var_two,
                             var_three, var_four)

    # More indentation included to distinguish this from the rest.
    def long_function_name(
            var_one, var_two, var_three,
            var_four):
        print(var_one)

    # Hanging indents should add a level.
    foo = long_function_name(
        var_one, var_two,
        var_three, var_four)
#+END_EXAMPLE

不好的：

#+BEGIN_EXAMPLE
    # Arguments on first line forbidden when not using vertical alignment.
    foo = long_function_name(var_one, var_two,
        var_three, var_four)

    # Further indentation required as indentation is not distinguishable.
    def long_function_name(
        var_one, var_two, var_three,
        var_four):
        print(var_one)
#+END_EXAMPLE

4空格规则是可选的：

#+BEGIN_EXAMPLE
    # Hanging indents *may* be indented to other than 4 spaces.
    foo = long_function_name(
      var_one, var_two,
      var_three, var_four)
#+END_EXAMPLE

当 if
语句的条件部分足够长，需要将它写入到多个行，值得注意的是两个连在一起的关键字（i.e.
if），添加一个空格，给后续的多行条件添加一个左括号形成自然地4空格缩进。如果和嵌套在
if
语句内的缩进代码块产生了视觉冲突，也应该被自然缩进4个空格。这份增强建议书对于怎样（或是否）把条件行和
if
语句的缩进块在视觉上区分开来是没有明确规定的。可接受的情况包括，但不限于：

#+BEGIN_EXAMPLE
    # No extra indentation.
    if (this_is_one_thing and
        that_is_another_thing):
        do_something()

    # Add a comment, which will provide some distinction in editors
    # supporting syntax highlighting.
    if (this_is_one_thing and
        that_is_another_thing):
        # Since both conditions are true, we can frobnicate.
        do_something()

    # Add some extra indentation on the conditional continuation line.
    if (this_is_one_thing
            and that_is_another_thing):
        do_something()
#+END_EXAMPLE

在多行结构中的右圆括号、右中括号、右大括号应该放在最后一行的第一个非空白字符的正下方，如下所示：

#+BEGIN_EXAMPLE
    my_list = [
        1, 2, 3,
        4, 5, 6,
        ]
    result = some_function_that_takes_arguments(
        'a', 'b', 'c',
        'd', 'e', 'f',
        )
#+END_EXAMPLE

或者放在多行结构的起始行的第一个字符正下方，如下：

#+BEGIN_EXAMPLE
    my_list = [
        1, 2, 3,
        4, 5, 6,
    ]
    result = some_function_that_takes_arguments(
        'a', 'b', 'c',
        'd', 'e', 'f',
    )
#+END_EXAMPLE

***** 制表符还是空格？

空格是首选的缩进方法。

制表符（Tab）应该被用在那些以前就使用了制表符缩进的地方。

Python 3 不允许混合使用制表符和空格来缩进代码。

混合使用制表符和空格缩进的 Python 2 代码应该改为只使用空格。

当使用=-t=选项来调用 Python 2
的命令行解释器的时候，会对混合使用制表符和空格的代码发出警告。当使用=-tt=选项的时候，这些警告会变成错误。这些选项是强烈推荐的！

***** 每行最大长度

限制每行的最大长度为79个字符。

对于那些约束很少的文本结构（文档字符串或注释）的长块，应该限制每行长度为72个字符。

限制编辑窗口的宽度使并排打开两个窗口成为可能，使用通过代码审查工具时，也能很好的通过相邻列展现不同代码版本。

一些工具的默认换行设置打乱了代码的可视结构，使其更难理解。限制编辑器窗口宽为80来避免自动换行，即使有些编辑工具在换行的时候会在最后一列放一个标识符。一些基于
Web 的工具可能根本就不提供动态换行。

一些团队更倾向于长的代码行。对于达成了一致意见来统一代码的团队而言，把行提升到80~100的长度是可接受的（实际最大长度为99个字符），注释和文档字符串的长度还是建议在72个字符内。

Python
标准库是非常专业的，限制最大代码长度为79个字符（注释和文档字符串最大长度为72个字符）。

首选的换行方式是在括号（小中大）内隐式换行（非续行符=\=）。长行应该在括号表达式的包裹下换行。这比反斜杠作为续行符更好。

反斜杠有时仍然适用。例如，多个很长的=with=语句不能使用隐式续行，因此反斜杠是可接受的。

#+BEGIN_EXAMPLE
    with open('/path/to/some/file/you/want/to/read') as file_1, \
         open('/path/to/some/file/being/written', 'w') as file_2:
        file_2.write(file_1.read())
#+END_EXAMPLE

（见前面关于[[https://www.python.org/dev/peps/pep-0008/#multiline-if-statements][多行=if=语句]]的讨论来进一步思考这种多行=with=语句该如何缩进）

另一种使用反斜杠续行的案例是=assert=语句。

确保续行的缩进是恰到好处的。遇到二元操作符，首选的断行位置是操作符的后面而不是前面。这有一些例子：

#+BEGIN_EXAMPLE
    class Rectangle(Blob):

        def __init__(self, width, height,
                     color='black', emphasis=None, highlight=0):
            if (width == 0 and height == 0 and
                    color == 'red' and emphasis == 'strong' or
                    highlight > 100):
                raise ValueError("sorry, you lose")
            if width == 0 and height == 0 and (color == 'red' or
                                               emphasis is None):
                raise ValueError("I don't think so -- values are %s, %s" %
                                 (width, height))
            Blob.__init__(self, width, height,
                          color, emphasis, highlight)
#+END_EXAMPLE

***** 空行

顶级函数和类定义上下使用两个空行分隔。

类内的方法定义使用一个空行分隔。

可以使用额外的空行（有节制的）来分隔相关联的函数组。在一系列相关联的单行代码中空行可以省略（e.g.
一组虚拟的实现）。

在函数中使用空白行（有节制的）来表明逻辑部分。

Python 接受使用换页符（i.e.
=Ctrl+L=）作为空格；许多工具都把=Ctrl+L=作为分页符，因此你可以用它们把你的文件中相似的章节分页。注意，一些编辑器和基于
Web
的代码查看工具可能不把=Ctrl+L=看做分页符，而是在这个位置放一个其它的符号。

***** 源文件编码

在核心 Python 发布版中的代码应该总是使用=UTF-8=编码（或者在 Python 2
中使用=ASCII=）。

使用=ASCII=(Python 2)或=UTF-8=(Python
3)的文件不需要有编码声明（注：它们是默认的）。

在标准库中，非缺省的编码应该仅仅用于测试目的，或者注释或文档字符串中的作者名包含非=ASCII=码字符；否则，优先使用=\x=、=\u=、=\U=或者=\N=来转义字符串中的非=ASCII=数据。

对于 Python 3.0
和之后的版本，以下是有关标准库的政策（见[[https://www.python.org/dev/peps/pep-3131][PEP
3131]]）：所有 Python
标准库中的标识符/必须/使用只含=ASCII=的标识，并且/应该/使用英语单词只要可行（在多数情况下，缩略语和技术术语哪个不是英语）。此外，字符串和注释也必须是=ASCII=。仅有的例外是：(a)测试用例测试非=ASCII=特性时，(b)作者名。作者的名字不是基于拉丁字母的必须提供他们名字的拉丁字母音译。

面向全球用户的开源项目，鼓励采取相似的政策。

***** 导包

-  =import=不同的模块应该独立一行，如：

   好的:

#+BEGIN_EXAMPLE
    import os
    import sys
#+END_EXAMPLE

  不好的:

#+BEGIN_EXAMPLE
    import sys, os
#+END_EXAMPLE

  这样也是可行的：

#+BEGIN_EXAMPLE
    from subprocess import Popen, PIPE
#+END_EXAMPLE

-  =import=语句应该总是放在文件的顶部，在模块注释和文档字符串之下，在模块全局变量和常量之前。

   =import=语句分组顺序如下：

   1. 导入标准库模块
   2. 导入相关第三方库模块
   3. 导入当前应用程序/库模块

   每组之间应该用空行分开。

   然后用=__all__=声明本文件内的模块。

-  绝对导入是推荐的，它们通常是更可读的，并且在错误的包系统配置（如一个目录包含一个以=os.path=结尾的包）下有良好的行为倾向（至少有更清晰的错误消息）：

#+BEGIN_EXAMPLE
    import mypkg.sibling
    from mypkg import sibling
    from mypkg.sibling import example
#+END_EXAMPLE

  当然，相对于绝对导入，相对导入是个可选替代，特别是处理复杂的包结构时，绝对导入会有不必要的冗余：

#+BEGIN_EXAMPLE
    from . import sibling
    from .sibling import example
#+END_EXAMPLE

  标准库代码应该避免复杂的包结构，并且永远使用绝对导入。

  应该从不使用隐式的相对导入，而且在 Python 3 中已经被移除。

-  从一个包含类的模块导入类时，这样写通常是可行的：

#+BEGIN_EXAMPLE
    from myclass import MyClass
    from foo.bar.yourclass import YourClass
#+END_EXAMPLE

  如果上面的方式会本地导致命名冲突，则这样写：

#+BEGIN_EXAMPLE
    import myclass
    import foo.bar.yourclass
#+END_EXAMPLE

  以=myclass.MyClass=和=foo.bar.yourclass.YourClass=这样的方式使用。

-  应该避免通配符导入（=from <module> import *=），这会使名称空间里存在的名称变得不清晰，迷惑读者和自动化工具。这里有一个可辩护的通配符导入用例，，重新发布一个内部接口作为公共
   API 的一部分（例如，使用纯 Python
   实现一个可选的加速器模块的接口，但并不能预知这些定义会被覆盖）。

   当以这种方式重新发布名称时，下面关于公共和内部接口的指南仍然适用。

--------------

**** 字符串引号

在 Python
里面，单引号字符串和双引号字符串是相同的。这份指南对这个不会有所建议。选择一种方式并坚持使用。一个字符串同时包含单引号和双引号字符时，用另外一种来包裹字符串，而不是使用反斜杠来转义，以提高可读性。

对于三引号字符串，总是使用双引号字符来保持与文档字符串约定的一致性（[[https://www.python.org/dev/peps/pep-0257][PEP 257]]）。

**** 表达式和语句中的空格

***** 不能忍受的情况

避免在下列情况中使用多余的空格：

-  与括号保持紧凑（小括号、中括号、大括号）：

#+BEGIN_EXAMPLE
    Yes: spam(ham[1], {eggs: 2})
    No:  spam( ham[ 1 ], { eggs: 2 } )
#+END_EXAMPLE

-  与后面的逗号、分号或冒号保持紧凑：

#+BEGIN_EXAMPLE
    Yes: if x == 4: print x, y; x, y = y, x
    No:  if x == 4 : print x , y ; x , y = y , x
#+END_EXAMPLE

-  切片内的冒号就像二元操作符一样，任意一侧应该被等同对待（把它当做一个极低优先级的操作）。在一个可扩展的切片中，冒号两侧必须有相同的空格数量。例外：切片参数省略时，空格也省略。

   好的：

#+BEGIN_EXAMPLE
    ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
    ham[lower:upper], ham[lower:upper:], ham[lower::step]
    ham[lower+offset : upper+offset]
    ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
    ham[lower + offset : upper + offset]
#+END_EXAMPLE

  不好的：

#+BEGIN_EXAMPLE
    ham[lower + offset:upper + offset]
    ham[1: 9], ham[1 :9], ham[1:9 :3]
    ham[lower : : upper]
    ham[ : upper]
#+END_EXAMPLE

-  函数名与其后参数列表的左括号应该保持紧凑：

#+BEGIN_EXAMPLE
    Yes: spam(1)
    No:  spam (1)
#+END_EXAMPLE

-  与切片或索引的左括号保持紧凑：

#+BEGIN_EXAMPLE
    Yes: dct['key'] = lst[index]
    No:  dct ['key'] = lst [index]
#+END_EXAMPLE

-  在复制操作符（或其它）的两侧保持多余一个的空格：

   好的：

#+BEGIN_EXAMPLE
    x = 1
    y = 2
    long_variable = 3
#+END_EXAMPLE

  不好的：

#+BEGIN_EXAMPLE
    x             = 1
    y             = 2
    long_variable = 3
#+END_EXAMPLE

***** 其他建议

-  总是在这些二元操作符的两侧加入一个空格：赋值(=)，增量赋值(+=, -=
   etc.)，比较(==, <, >, !=, <>, <=, >=, in, not in, is, is
   not)，布尔运算(and, or, not)。

-  在不同优先级之间，考虑在更低优先级的操作符两侧插入空格。用你自己的判断力；但不要使用超过一个空格，并且在二元操作符的两侧有相同的空格数。

   好的：

#+BEGIN_EXAMPLE
    i = i + 1
    submitted += 1
    x = x*2 - 1
    hypot2 = x*x + y*y
    c = (a+b) * (a-b)
#+END_EXAMPLE

  不好的：

#+BEGIN_EXAMPLE
    i=i+1
    submitted +=1
    x = x * 2 - 1
    hypot2 = x * x + y * y
    c = (a + b) * (a - b)
#+END_EXAMPLE

-  不要在关键值参数或默认值参数的等号两边加入空格。

   好的：

#+BEGIN_EXAMPLE
    def complex(real, imag=0.0):
        return magic(r=real, i=imag)
#+END_EXAMPLE

  不好的：

#+BEGIN_EXAMPLE
    def complex(real, imag = 0.0):
        return magic(r = real, i = imag)
#+END_EXAMPLE

-  【注：Python
   3】带注释的函数定义中的等号两侧要各插入空格。此外，在冒号后用一个单独的空格，也要在表明函数返回值类型的=->=左右各插入一个空格。

   好的：

#+BEGIN_EXAMPLE
    def munge(input: AnyStr):
    def munge(sep: AnyStr = None):
    def munge() -> AnyStr:
    def munge(input: AnyStr, sep: AnyStr = None, limit=1000):
#+END_EXAMPLE

  不好的：

#+BEGIN_EXAMPLE
    def munge(input: AnyStr=None):
    def munge(input:AnyStr):
    def munge(input: AnyStr)->PosInt:
#+END_EXAMPLE

-  打消使用复合语句（多条语句在同一行）的念头。

   好的：

#+BEGIN_EXAMPLE
    if foo == 'blah':
        do_blah_thing()
    do_one()
    do_two()
    do_three()
#+END_EXAMPLE

  宁可不：

#+BEGIN_EXAMPLE
    if foo == 'blah': do_blah_thing()
    do_one(); do_two(); do_three()
#+END_EXAMPLE

-  有时候把 =if/for/while=
   和一个小的主体放在同一行也是可行的，千万不要在有多条语句的情况下这样做。此外，还要避免折叠，例如长行。

   宁可不：

#+BEGIN_EXAMPLE
    if foo == 'blah': do_blah_thing()
    for x in lst: total += x
    while t < 10: t = delay()
#+END_EXAMPLE

  绝对不：

#+BEGIN_EXAMPLE
    if foo == 'blah': do_blah_thing()
    else: do_non_blah_thing()

    try: something()
    finally: cleanup()

    do_one(); do_two(); do_three(long, argument,
                                 list, like, this)

    if foo == 'blah': one(); two(); three()
#+END_EXAMPLE

--------------

**** 注释

与代码相矛盾的注释不如没有。注释总是随着代码的变更而更新。

注释应该是完整的句子。如果注释是一个短语或语句，第一个单词应该大写，除非是一个开头是小写的标识符（从不改变标识符的大小写）。

如果注释很短，末尾的句点可以省略。块注释通常由一个或多个有完整句子的段落组成，并且每个句子应该由句点结束。

你应该在一个句子的句点后面用两个空格。

写英语时，遵循《Strunk and
White》（注：《英文写作指南》，参考[[https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=13&cad=rja&uact=8&ved=0CJgBEJoTKAAwDA&url=http%3A%2F%2Fzh.wikipedia.org%2Fzh-cn%2F%25E8%258B%25B1%25E6%2596%2587%25E5%2586%2599%25E4%25BD%259C%25E6%258C%2587%25E5%258D%2597&ei=WGU7VaiiJITxoATO4YCwAw&usg=AFQjCNE3ld8HgP5OVy1WUoMQ_vVsUT8-Ng&sig2=vcim1a38TCK3svBegulR4w][维基百科]]）。

来自非英语国家的程序员：请用英语写注释，除非你120%确定你的代码永远不会被那些不说你的语言的人阅读。

***** 块注释

块注释通常用来说明跟随在其后的代码，应该与那些代码有相同的缩进层次。块注释每一行以=#=起头，并且=#=后要跟一个空格（除非是注释内的缩进文本）。

***** 行内注释

有节制的使用行内注释。

一个行内注释与语句在同一行。行内注释应该至少与语句相隔两个空格。以=#=打头，=#=后接一个空格。

无谓的行内注释如果状态明显，会转移注意力。不要这样做：

#+BEGIN_EXAMPLE
    x = x + 1                 # Increment x
#+END_EXAMPLE

但有的时候，这样是有用的：

#+BEGIN_EXAMPLE
    x = x + 1                 # Compensate for border
#+END_EXAMPLE

***** 文档字符串

编写良好的文档字符串（a.k.a “docstring”）的约定常驻在
[[https://www.python.org/dev/peps/pep-0257][PEP 257]]

-  为所有的公共模块、函数、类和方法编写文档字符串。对于非公共的方法，文档字符串是不必要的，但是也应该有注释来说明代码是干什么的。这个注释应该放在方法声明的下面。

-  [[https://www.python.org/dev/peps/pep-0257][PEP 257]]
   描述了良好的文档字符串的约定。注意，文档字符串的结尾="""=应该放在单独的一行，例如：

#+BEGIN_EXAMPLE
    """Return a foobang

    Optional plotz says to frobnicate the bizbaz first.
    """
#+END_EXAMPLE

-  对于单行的文档字符串，把结尾="""=放在同一行。

--------------

**** 版本注记

如果必须要 Subversion，CVS 或 RCS 标记在你的源文件里，像这样做：

#+BEGIN_EXAMPLE
    __version__ = "$Revision$"
    # $Source$
#+END_EXAMPLE

这几行应该在模块的文档字符串后面，其它代码的前面，上下由一个空行分隔。

--------------

**** 命名约定

Python 库的命名规则有点混乱，因此我们永远也不会使其完全一致的 --
不过，这里有一些当前推荐的命名标准。新的模块和包（包括第三方框架）应该按照这些标准来命名，但是已存在库有不同的风格，内部一致性是首选。

***** 覆盖原则

API 里对用户可见的公共部分应该遵循约定，反映的是使用而不是实现。

***** 规定：命名约定

有许多不同的命名风格。这有助于识别正在使用的命名风格，独立于它们的用途。

下面的命名风格通常是有区别的：

-  b (一个小写字母)
-  B (一个大写字母)
-  lowercase
-  lower_case_with_underscores
-  UPPERCASE
-  UPPER_CASE_WITH_UNDERSCORES
-  CapitalizedWords (又叫 CapWords，或者 CamelCase(骆驼命名法) --
   如此命名因为字母看起来崎岖不平[[#id4][[3]]])。有时候也叫 StudlyCaps。

  注意：在 CapWords
使用缩略语时，所有缩略语的首字母都要大写。因此=HTTPServerError=比=HttpServerError=要好。

-  mixedCase (和上面不同的是首字母小写)
-  Capitalized_Words_With_Underscores (丑陋无比！)

也有种风格用独一无二的短前缀来将相似的命名分组。在 Python
里用的不是很多，但是为了完整性被提及。例如，=os.stat()=函数返回一个元组，通常有像=st_mode=，=st_size=，=st_mtime=等名字。（强调与
POSIX 系统调用的字段结构一致，有助于程序员对此更熟悉）

X11 库的所有公共函数都用 X 打头。在 Python
中这种风格被认为是不重要的，因为属性和方法名的前缀是一个对象，函数名的前缀为一个模块名。

此外，下面的特许形式用一个前导或尾随的下划线进行识别（这些通常可以和任何形式的命名约定组合）：

-  _single_leading_underscore
   ：仅内部使用的标识，如=from M import *=不会导入像这样一下划线开头的对象。

-  single_trailing_underscore_ : 通常是为了避免与 Python
   规定的关键字冲突，如=Tkinter.Toplevel(master, class_='ClassName')=。

-  __double_leading_underscore :
   命名一个类属性，调用的时候名字会改变（在类=FooBar=中，=__boo=变成了=_FooBar__boo=；见下）。

-  *double_leading_and_trailing_underscore*
   ：”魔术”对象或属性，活在用户控制的命名空间里。例如，=__init__=，=__import__=和=__file__=。永远不要像这种方式命名；只把它们作为记录。

***** 规定：命名约定

****** 应该避免的名字

永远不要使用单个字符=l=(小写字母 el)，=O=(大写字母 oh)，或=I=(大写字母
eye)作为变量名。

在一些字体中，这些字符是无法和数字=1=和=0=区分开的。试图使用=l=时用=L=代替。

****** 包和模块名

模块名应该短，且全小写。如果能改善可读性，可以使用下划线。Python
的包名也应该短，全部小写，但是不推荐使用下划线。

因为模块名就是文件名，而一些文件系统是大小写不敏感的，并且自动截断长文件名，所以给模块名取一个短小的名字是非常重要的
-- 在 Unix 上这不是问题，但是把代码放到老版本的 Mac， Windows，或者 DOS
上就可能变成一个问题了。

用 C/C++ 给 Python 写一个高性能的扩展(e.g. more object
oriented)接口的时候，C/C++ 模块名应该有一个前导下划线。

****** 类名

类名通常使用 CapWords 约定。

The naming convention for functions may be used instead in cases where
the interface is documented and used primarily as a callable.

注意和内建名称的区分开：大多数内建名称是一个单独的单词（或两个单词一起），CapWords
约定只被用在异常名和内建常量上。

****** 异常名

因为异常应该是类，所以类名约定在这里适用。但是，你应该用=Error=作为你的异常名的后缀（异常实际上是一个错误）。

****** 全局变量名

（我们希望这些变量仅仅在一个模块内部使用）这个约定有关诸如此类的变量。

若被设计的模块可以通过=from M import *=来使用，它应该使用=__all__=机制来表明那些可以可导出的全局变量，或者使用下划线前缀的全局变量表明其是模块私有的。

****** 函数名

函数名应该是小写的，有必要的话用下划线来分隔单词提高可读性。

混合大小写仅仅在上下文都是这种风格的情况下允许存在（如thread.py），这是为了维持向后兼容性。

****** 函数和方法参数

总是使用=self=作为实例方法的第一个参数。

总是使用=cls=作为类方法的第一个参数。

如果函数参数与保留关键字冲突，通常最好在参数后面添加一个尾随的下划线，而不是使用缩写或胡乱拆减。因此=class_=比=clss=要好。（或许避免冲突更好的方式是使用近义词）

****** 方法名和实例变量

用函数名的命名规则：全部小写，用下划线分隔单词提高可读性。

用一个且有一个前导的下划线来表明非公有的方法和实例变量。

为了避免与子类变量或方法的命名冲突，用两个前导下划线来调用 Python
的命名改编规则。

Python
命名改编通过添加一个类名：如果类=Foo=有一个属性叫=__a=，它不能被这样=Foo.__a=访问（执着的人可以通过这样=Foo._Foo__a=来访问）通常，双前导的下划线应该仅仅用来避免与其子类属性的命名冲突。

注意：这里有一些争议有关=__names=的使用（见下文）。

****** 常量

常量通常是模块级的定义，全部大写，单词之间以下划线分隔。例如=MAX_OVERFLOW=和=TOTAL=。

****** 继承的设计

总是决定一个类的方法和变量（属性）是应该公有还是非公有。如果有疑问，选择非公有；相比把共有属性变非公有，非公有属性变公有会容易得多。

公有属性是你期望给那些与你的类无关的客户端使用的，你应该保证不会出现不向后兼容的改变。非公有的属性是你不打算给其它第三方使用的；你不需要保证非公有的属性不会改变甚至被移除也是可以的。

我们这里不适用“私有”这个术语，因为在 Python
里没有真正的私有属性（一般没有不必要的工作量）。

另一种属性的分类是“子类
API”的一部分（通常在其它语言里叫做“Protected”）。一些类被设计成被继承的，要么扩展要么修改类的某方面行为。设计这样一个类的时候，务必做出明确的决定，哪些是公有的，其将会成为子类
API 的一部分，哪些仅仅是用于你的基类的。

处于这种考虑，给出 Pythonic 的指南：

-  共有属性不应该有前导下划线。
-  如果你的公有属性与保留关键字发生冲突，在你的属性名后面添加一个尾随的下划线。这比使用缩写或胡乱拆减要好。（尽管这条规则，已知某个变量或参数可能是一个类情况下，=cls=是首选的命名，特别是作为类方法的第一个参数）

  注意一：见上面推荐的类方法参数命名方式。

-  对于简单的公有数据属性，最好的方式是暴露属性名，不要使用复杂的访问属性/修改属性的方法。记住，Python
   提供了捷径去提升特性，如果你发现简单的数据属性需要增加功能行为。在这种情况下，使用=properties=把功能实现隐藏在简单的数据属性访问语法下面。

  注意一：=properties=仅仅在新式类下工作。
  注意二：尽量保持功能行为无边际效应，然而如缓存有边际效应也是好的。
  注意三：避免为计算开销大的操作使用=properties=；属性标记使调用者相信这样来访问（相对来说）是开销很低的。

-  如果你的类是为了被继承，你有不想让子类使用的属性，给属性命名时考虑给它们加上双前导下划线，不要加尾随下划线。这会调用
   Python
   的名称重整算法，把类名加在属性名前面。避免了命名冲突，当子类不小心命名了和父类属性相同名称的时候。

  注意一：注意只是用了简单的类名来重整名字，因此如果子类和父类同名的时候，你仍然有能力避免冲突。

  注意二：命名重整有确定的用途，例如调试和=__getattr__()=，就不太方便。命名重整算法是有据可查的，易于手动执行。

  注意三：不是每个人都喜欢命名重整。尽量平衡名称的命名冲突与面向高级调用者的潜在用途。

**** 公共和内部接口

保证所有公有接口的向后兼容性。用户能清晰的区分公有和内部接口是重要的。

文档化的接口考虑公有，除非文档明确的说明它们是暂时的，或者内部接口不保证其的向后兼容性。所有的非文档化的应该被假设为非公开的。

为了更好的支持内省，模块应该用=__all__=属性来明确规定公有 API
的名字。设置=__all__=为空=list=表明模块没有公有 API。

甚至与=__all__=设置相当，内部接口（包、模块、类、函数、属性或者其它的名字）应该有一个前导的下划线前缀。

被认为是内部的接口，其包含的任何名称空间（包、模块或类）也被认为是内部的。

导入的名称应始终视作一个实现细节。其它模块不能依赖间接访问这些导入的名字，除非它们是包含模块的
API
明确记载的一部分，例如=os.path=或一个包的=__init__=模块暴露了来自子模块的功能。

--------------

**** 程序编写建议

-  代码的编写方式不能对其它 Python
   的实现（PyPy、Jython、IronPython、Cython、Psyco，诸如此类的）不利。

   例如，不要依赖于 CPython
   在字符串拼接时的优化实现，像这种语句形式=a += b=和=a = a + b=。即使是
   CPython（仅对某些类型起作用）
   这种优化也是脆弱的，不是在所有的实现中都不使用引用计数。在库中性能敏感的部分，用=''.join=形式来代替。这会确保在所有不同的实现中字符串拼接是线性时间的。

-  比较单例，像=None=应该用=is=或=is not=，从不使用====操作符。

   当你的真正用意是=if x is not None=的时候，当心=if x=这样的写法 --
   例如，测试一个默认值为=None=的变量或参数是否设置成了其它值，其它值可能是那些布尔值为
   false 的类型（如空容器）。

-  用=is not=操作符而不是=not ... is=。虽然这两个表达式是功能相同的，前一个是更可读的，是首选。

   好的:

#+BEGIN_EXAMPLE
    if foo is not None:
#+END_EXAMPLE

  不好的:

#+BEGIN_EXAMPLE
    if not foo is None:
#+END_EXAMPLE

-  用富比较实现排序操作的时候，实现所有六个比较操作符（ =__eq__= 、
   =__ne__= 、 =__lt__= , =__le__= , =__gt__= ,
   =__ge__=）是更好的，而不是依赖其它仅仅运用一个特定比较的代码

   为了最大限度的减少工作量，=functools.total_ordering()=装饰器提供了一个工具去生成缺少的比较方法。

   [[https://www.python.org/dev/peps/pep-0207][PEP 207]] 说明了 Python
   假定的所有反射规则。因此，解释器可能交换=y > x=与=x < y=，=y >= x=与=x <= y=，也可能交换=x == y=和=x != y=。=sort()=和=min()=操作肯定会使用=<=操作符，=max()=函数肯定会使用=>=操作符。当然，最好是六个操作符都实现，以便不会在其它上下文中有疑惑。

-  始终使用=def=语句来代替直接绑定了一个=lambda=表达式的赋值语句。

   好的:

#+BEGIN_EXAMPLE
    def f(x): return 2*x
#+END_EXAMPLE

  不好的:

#+BEGIN_EXAMPLE
    f = lambda x: 2*x
#+END_EXAMPLE

  第一种形式意味着函数对象的名字是'f'而不是''的。通常这对异常追踪和字符串表述是更有用的。使用赋值语句消除的唯一好处，`lambda`表达式可以提供一个显示的`def`语句不能提供的，如，`lambda`能镶嵌在一个很长的表达式里。

-  异常类应派生自=Exception=而不是=BaseException=。直接继承自=BaseException=是为=Exception=保留的，如果从=BaseException=继承，捕获到的错误总是错的。

   设计异常结构层次，应基于那些可能出现异常的代码，而不是在出现异常后的。编码的时候，以回答“出了什么问题？”为目标，而不是仅仅指出“这里出现了问题”（见
   [[https://www.python.org/dev/peps/pep-3151][PEP 3151]]
   一个内建异常结构层次的例子）。

   类的命名约定适用于异常，如果异常类是一个错误，你应该给异常类加一个后缀=Error=。用于非本地流程控制或者其他形式的信号的非错误异常不需要一个特殊的后缀。

-  适当的使用异常链。在 Python 3
   里，=raise X from Y=用于表明明确的替代者，不丢失原有的回溯信息。

   有意替换一个内部的异常时（在 Python 2 用=raise X=，Python 3.3+
   用=raise X from None=），确保相关的细节全部转移给了新异常（例如，把=KeyError=变成=AttributeError=时保留属性名，或者把原始异常的错误信息嵌在新异常里）。

-  在 Python 2
   里抛出异常时，用=raise ValueError('message')=代替旧式的=raise ValueError, 'message'=。

   在 Python 3 之后的语法里，旧式的异常抛出方式是非法的。

   使用括号形式的异常意味着，当你传给异常的参数过长或者包含字符串格式化时，你就不需要使用续行符了，这要感谢括号！

-  捕获异常时，尽可能使用明确的异常，而不是用一个空的=except:=语句。

   例如，用：

#+BEGIN_EXAMPLE
    try:
        import platform_specific_module
    except ImportError:
        platform_specific_module = None
#+END_EXAMPLE

  一个空的=except:=语句将会捕获到=SystemExit=和=KeyboardInterrupt=异常，很难区分程序的中断到底是=Ctrl+C=还是其他问题引起的。如果你想捕获程序的所有错误，使用=except Exception:=(空=except:=等同于=except BaseException=)。

  一个好的经验是限制使用空=except=语句，除了这两种情况：

1. 如果异常处理程序会打印出或者记录回溯信息；至少用户意识到错误的存在。
2. 如果代码需要做一些清理工作，但后面用=raise=向上抛出异常。=try .. finally=是处理这种情况更好的方式。

-  绑定异常给一个名字时，最好使用 Python 2.6
   里添加的明确的名字绑定语法：

#+BEGIN_EXAMPLE
    try:
        process_data()
    except Exception as exc:
        raise DataProcessingFailedError(str(exc))
#+END_EXAMPLE

Python 3 只支持这种语法，避免与基于逗号的旧式语法产生二义性。

-  捕获操作系统错误时，最好使用 Python 3.3
   里引进的明确的异常结构层次，而不是自省的=errno=值。

-  此外，对于所有的=try/except=语句来说，限制=try=里面有且仅有绝对必要的代码。在强调一次，这能避免屏蔽错误。

   好的：

#+BEGIN_EXAMPLE
    try:
        value = collection[key]
    except KeyError:
        return key_not_found(key)
    else:
        return handle_value(value)
#+END_EXAMPLE

  不好的：

#+BEGIN_EXAMPLE
    try:
        # Too broad!
        return handle_value(collection[key])
    except KeyError:
        # Will also catch KeyError raised by handle_value()
        return key_not_found(key)
#+END_EXAMPLE

-  当资源是本地的特定代码段，用=with=语句确保其在使用后被立即干净的清除了，=try/finally=也是也接受的。

-  当它们做一些除了获取和释放资源之外的事的时候，上下文管理器应该通过单独的函数或方法调用。例如：

   好的：

#+BEGIN_EXAMPLE
    with conn.begin_transaction():
        do_stuff_in_transaction(conn)
#+END_EXAMPLE

  不好的：

#+BEGIN_EXAMPLE
    with conn:
        do_stuff_in_transaction(conn)
#+END_EXAMPLE

  第二个例子没有提供任何信息来表明=__enter__=和=__exit__=方法在完成一个事务后做了一些除了关闭连接以外的其它事。在这种情况下明确是很重要的。

-  坚持使用=return=语句。函数内的=return=语句都应该返回一个表达式，或者=None=。如果一个=return=语句返回一个表达式，另一个没有返回值的应该用=return None=清晰的说明，并且在一个函数的结尾应该明确使用一个=return=语句（如果有返回值的话）。

   好的：

#+BEGIN_EXAMPLE
    def foo(x):
        if x >= 0:
            return math.sqrt(x)
        else:
            return None

    def bar(x):
        if x < 0:
            return None
        return math.sqrt(x)
#+END_EXAMPLE

  不好的：

#+BEGIN_EXAMPLE
    def foo(x):
        if x >= 0:
            return math.sqrt(x)

    def bar(x):
        if x < 0:
            return
        return math.sqrt(x)
#+END_EXAMPLE

-  用字符串方法代替字符串模块。

   字符串方法总是更快，与 unicode 字符串共享
   API。如果需要向后兼容性覆盖这个规则，需要 Python 2.0 以上的版本。

-  用=''.startswith()=和=''.endswith()=代替字符串切片来检查前缀和后缀。

   =startswith()=和=endswith()=是更简洁的，不容易出错的。例如：

#+BEGIN_EXAMPLE
    Yes: if foo.startswith('bar'):
    No:  if foo[:3] == 'bar':
#+END_EXAMPLE

-  对象类型的比较应该始终使用=isinstance()=而不是直接比较。

#+BEGIN_EXAMPLE
    Yes: if isinstance(obj, int):

    No:  if type(obj) is type(1):
#+END_EXAMPLE

  当比较一个对象是不是字符串时，记住它有可能也是一个 unicode 字符串！在
Python 2
里面，=str=和=unicode=有一个公共的基类叫=basestring=，因此你可以这样做：

#+BEGIN_EXAMPLE
    if isinstance(obj, basestring):
#+END_EXAMPLE

  注意，在 Python 3
里面，=unicode=和=basestring=已经不存在了（只有=str=），=byte=对象不再是字符串的一种（被一个整数序列替代）。

-  对于序列（字符串、列表、元组）来说，空的序列为=False=：

   好的：

#+BEGIN_EXAMPLE
    if not seq:
    if seq:
#+END_EXAMPLE

  不好的：

#+BEGIN_EXAMPLE
    if len(seq):
    if not len(seq):
#+END_EXAMPLE

-  不要让字符串对尾随的空格有依赖。这样的尾随空格是视觉上无法区分的，一些编辑器（or
   more recently, reindent.py）会将其裁剪掉。

-  不要用====比较=True=和=False=。

#+BEGIN_EXAMPLE
    Yes:   if greeting:
    No:    if greeting == True:
    Worse: if greeting is True:
#+END_EXAMPLE

-  Python
   标准库将不再使用函数标注，以至于给特殊的标注风格给一个过早的承若。代替的，这些标注是留给用户去发现和体验的有用的标注风格。

   建议第三方实验的标注用相关的修饰符指示标注应该如何被解释。

   早期的核心开发者尝试用函数标注显示不一致、特别的标注风格。例如：

   -  =[str]=是很含糊的，它可能代表一个包含字符串的列表，也可能代表一个为字符串或为空的值。

   -  =open(file:(str,bytes))=可能用来表示=file=的值可以是一个=str=或者=bytes=，也可能用来表示=file=的值是一个包含=str=和=bytes=的二元组。

   -  标注=seek(whence:int)=体现了一个过于明确又不够明确的混合体：=int=太严格了（有=__index__=的应该被允许），又不够严格（只有0,1,2是被允许的）。同样的，标注=write(b: byte)=太严格了（任何支持缓存协议的都应该被允许）。

   -  像=read1(n: int=None)=这样的标注自我矛盾，因为=None=不是=int=。像=source_path(self, fullname:str) -> object=标注是迷惑人的，返回值到底是应该什么类型？

   -  除了上面之外，在具体类型和抽象类型的使用上是不一致的：=int=对=integral=（整数），=set/fronzenset=对=MutableSet/Set=。

   -  不正确的抽象基类标注规格。例如，集合之间的操作需要另一个对象是集合的实例，而不只是一个可迭代序列。

   -  另一个问题是，标注成为了规范的一部分，但却没有经受过考验。

   -  在大多数情况下，文档字符串已经包括了类型规范，比函数标注更清晰。在其余的情况下，一旦标注被移除，文档字符串应该被完善。

   -  观察到的函数标注太标新立异了，相关的系统不能一致的处理自动类型检查和参数验证。离开这些标注的代码以后很难做出更改，使自动化工具可以支持。

--------------

脚注：

[[#id33][[5]]] ：Hanging indentation is a type-setting style where all
the lines in a paragraph are indented except the first line. In the
context of Python, the term is used to describe a style where the
opening parenthesis of a parenthesized statement is the last
non-whitespace character of the line, with subsequent lines being
indented until the closing parenthesis.

--------------

**** 参考文献

[[https://www.python.org/dev/peps/pep-0007][PEP 7]] ,Style Guide for C Code, van Rossum

Barry's GNU Mailman style guide [[http://barry.warsaw.us/software/STYLEGUIDE.txt]]

[[http://www.wikipedia.com/wiki/CamelCase]]

[[https://www.python.org/dev/peps/pep-0008][PEP 8]] modernisation, July 2013 [[http://bugs.python.org/issue18472]]

**** 版权

This document has been placed in the public domain.

Source: [[https://hg.python.org/peps/file/tip/pep-0008.txt]]

*** [[https://github.com/onlytiancai/codesnip/blob/master/mypost/How_to_write_high-quality_python_program.md][如何编写高质量的python程序]]

**** 目录

1. 代码规范
2. 空白项目模版
3. 单元测试
4. 文档
5. 打包
6. 小结

**** 代码规范

首先阅读下面的两份规范，并深入理解。

-  [[http://www.python.org/dev/peps/pep-0008/][Python社区官方建议采用的Python编码风格:PEP8]][[http://wiki.woodpecker.org.cn/moin/PythonCodingRule][中文版]]
-  [[http://google-styleguide.googlecode.com/svn/trunk/pyguide.html][Google SoC 建议的 Python 编码风格:Google Python Style Guide]][[http://www.elias.cn/Python/PythonStyleGuide][中文版]]

写出规范的代码是写出高质量代码的第一步，并且有助于培养仔细的习惯。

为了培养规范写代码的习惯，可以安装[[http://pypi.python.org/pypi/flake8/][flake8 ]]这个工具，它不仅可以检查代码
风格是否符合官方建议（PEP8），而且还能找出潜在的隐患（用Pyflakes做语法
分析），更逆天的是还能检测到你有些函数写的太复杂（代码圈复杂度）了，更
更逆天的是可以设置git commit之前必须通过这些检查。

当然具体操作需要根据自己的项目进行一些定制，比如可以忽略E501，W293。

**** 空白项目模版

好的开始是成功的一半，写python代码就从[[https://github.com/onlytiancai/pyempty][pyempty]]开始吧。

在github上看一下那些经典的项目，[[https://github.com/webpy/webpy][web.py]], [[https://github.com/mitsuhiko/flask][flask]], [[https://github.com/jcrocholl/pep8/blob/master/pep8.py][pep8]]， 他们的项目目录都
很规范，综合借鉴了一些项目的特点，我写了这个pyempty项目。

1. *README.md* 这里写你项目的简介，quick

   start等信息，虽然distutils要求这个文件没有后缀名，但github上如果后
   缀是.md的话可以直接转换成html显示。

2. *ChangeLog.txt*

   该文件存放程序各版本的变更信息，也有一定的格式，
   参考 [[https://github.com/webpy/webpy/blob/master/ChangeLog.txt][web.py的ChangeLog.txt]]

3. *LICENES.txt* 这里存放你项目使用的协议，不要编写自己的协议。

4. *requirements.txt*

   如果你的项目需要依赖其它的python第三方库，在这里一行一个写出来，可能pip
   install的时候能自动帮你安装

5. *setup.py* 安装脚本，后面详细介绍

6. *docs*

   里面存放你的项目文档，如概要设计，详细设计，维护文档，pydoc自动生成
   的文档等，强烈推荐大家使用MarkDown格式编写文档

7. *src*

   这个目录里存放项目模块的主要代码，尽量不要把模块目录直接放到根目录，
   模块代码目录可以在setup.py里指定的

8. *tests*

   这个目录存放所有单元测试，性能测试脚本，单元测试的文件确保以test\_
   做前缀，这样distutils会自动打包这些文件，并且用
   =python -m unittest discover -s ./ -p 'test_*.py' -v=
   可以直接执行这些测试

**** 单元测试

Martin Fowler：
/在你不知道如何测试代码之前，就不该编写程序。而一旦你完成了程序，测试
代码也应该完成。除非测试成功，你不能认为你编写出了可以工作的程序。/

我们有很多理由不写单元测试，归根结底是懒，虽然[[http://www.cnblogs.com/onlytiancai/archive/2010/05/26/1744108.html][代码大全上说]]：

大部分研究都发现，检测比测试的成本更小。NASA软件工程实验室的一项研究发
现，阅读代码每小时能够检测出来的缺陷要比测试高出80%左右(Basili and
Selby 1987)。后来，IBM的一项研究又发现，检查发现的一个错误只需要3.5个
工作时，而测试则需要花费15-25个工作时（Kaplan 1995)。

但是单元测试还是让别人相信你的代码有很高质量的最有力证据。

好了，请详细阅读：

1. [[http://woodpecker.org.cn/diveintopython3/unit-testing.html][深入python3.0: 单元测试-2.x也适用]]
2. [[http://docs.python.org/library/unittest.html][Unit testing framework]][[http://www.ibm.com/developerworks/cn/linux/l-pyunit/index.html][不完整中文版]]

**** 文档

敏捷开发不是提倡什么文档也不写，没有文档就没有传承和积累，轮岗或新人接
手任务就会遇到很大的麻烦，所以我决定每个项目最少要写以下文档：

1. *nalysis.model.md*

   概要设计文档，不同于README.md文件，该文档应该写于项目开发之前，把项
   目有哪些功能，大概分几个模块等项目整体概述信息写一下。

2. *design.model.md*

   详细设计文档，不用太详细，至少把项目依赖哪些东西，谁依赖这个项目，
   重要算法流程描述，代码整体结构等写出来。

3. *maintain.md*

   维护文档，这个我觉得最重要，你的服务都记录哪些日志，需要监控哪些业
   务指标，如何重启，有哪些配置项等，没这些东西，你的项目很难运维。

上面这些文档都是项目全局性的文档，不适合写在docstring或注视里，所以要
有单独的文档。

**** 打包

python有专门的模块打包系统[[http://docs.python.org/library/distutils.html][distutils]]， 你可以用这套机制把你的代码打包并
分发到 [[http://pypi.python.org/pypi][Pypi]] 上，这样任何人都可以用 [[http://pypi.python.org/pypi/pip][pip]] 或 [[http://pypi.python.org/pypi/setuptools][easy\_install]] 安装你的模块。

如果你开发的是内部项目，还可以用 [[http://pypi.python.org/pypi/mypypi][mypypi]] 架设私有的pypi，然后把项目的大
的版本更新发布到内部的pypi上，配置管理人员和运维人员可以很方便的从pypi
上拉取代码安装到测试环境或生产环境。

发布大版本的时候要给版本命名及编写ChangeList，可以参考[[https://github.com/chunzi/progit/blob/master/zh/05-distributed-git/01-chapter5.markdown][GitPro的相关章节]],
主要记住以下几个命令。

#+BEGIN_EXAMPLE
    git tag -a v0.1 -m 'my test tag'  #给大版本命名，打Tag
    git describe master #给小版本命名,Git将会返回一个字符串，由三部分组成：最近一次标定的版本号，加上自那次标定之后的提交次数，再加上一段SHA-1值
    git shortlog --no-merges master --not v0.1 #生成版本简报,ChangeList
#+END_EXAMPLE

python有自己的打包机制，所以一般不要用=git archive=命令。

当然大版本管理用pypi管理比较合适，小的bug fix，紧急上线等好多公司都是
用git直接从生产环境拉代码更新，因为git,svn等可以很方便的撤销某次更新，
回滚到某个位置。

如何管理好大版本上线和小的紧急上线，我还没理清思路，欢迎大家参与讨论。

关于打包，请阅读如下链接：

1. [[http://www.ibm.com/developerworks/cn/opensource/os-pythonpackaging/][Python 打包指南]]
2. [[http://woodpecker.org.cn/diveintopython3/packaging.html][深入Python3.0:打包 Python 类库]]
3. [[http://docs.python.org/release/3.1.5/distutils/sourcedist.html#manifest][python打包:分发指定文件]]

**** 小结

以上是最近学到的一些东西的总结，欢迎大家一起讨论。

**** reference

+ https://github.com/onlytiancai/pyempty
+ http://www.cnblogs.com/harrychinese/p/python_project_structure.html

*** [[http://www.crifan.com/try_use_doxygen_to_generate_doc_for_python/][python doxygen]]                                                  :doxygen:

**** [[https://blogs.cs.st-andrews.ac.uk/jfdm/][Documenting Python using Doxygen]]
***** type of documents

On and off I have been developing a little Python module to provide
KP-ABE and CP-ABE functionality to developers. _One important aspect
is that of documentation_. Any decent project needs to provide both
User and Developerdocumentation. /User documentation/ is outward facing and tells
users how to use the project, and /Developer documentation/ is inward
facing and tells developers how the project is structured. Developer
documentation is also know as reference documentation. Interestingly,
user documentation can be further divided into two groups: User---for
when the user is just a ‘plain-dumb-user'; and Dev-User---when the
project produces something for use by other developers i.e. an library.
Often Dev-User documentation is just reference documentation. This post
is concerned with reference documentation.

***** documentation tools

For documenting API's and libraries different languages have different
tools:

-  Java has [[http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html][Javadoc]], and [[http://www.stack.nl/~dimitri/doxygen/][Doxygen]]
-  Python has [[http://epydoc.sourceforge.net/][epydoc]], [[https://pypi.python.org/pypi/pydoctor/0.4][pydoctor]], [[http://pydoc.org/][pydoc]], [[http://sphinx-doc.org/][sphinx]], and Doxygen
-  C has ...   [[https://developer.gnome.org/gtk-doc-manual/stable/][gtk-doc]],...,
-  For design there is always plantuml.

***** document format
For user documentation, which is not generally tied to a specific
programming language there are different formats:

-  /LaTeX/
-  Sphinx
-  ASCIIDOC
-  Markdown
-  reST
-  DocBook

For developer facing documentation, one can use a combination of the
above tools. Especially, when producing UML diagrams.

***** 文档化工具中的瑞士军刀( SwissArmy Knife)

When I develop code I try to use doxygen everywhere I go, Doxygen is
/cross language/ and _provides a nice means to produce:
End-User,Developer-User, and Developer documentation_ in HTML, MAN
Pages, LaTeX, RTF, and XML; and across multiple languages(/multi
formats/). This is handed is you are dropping down into C. Moreover,
doxygen has built in support for /LaTeX formula within
documentation/.
Furthermore, recent versions of doxygen
allow for the use of Markdown, and inclusion of Markdown formatted
files. It is essentially the *SwissArmy Knife* of documentation.

***** doxygen for python

However, when developing in Python the preferred documentation tool is
/sphinx/, and relies on /reST/ mark up in python /docstrings/, and other
files to produce both reference documentation, and user documentation. I
find the approach messy, especially reST.

Helaas, Doxygen doesn't want to play nice, and prefers to have its
documentation place in special comment blocks above method definitions
i.e.

#+BEGIN_EXAMPLE
  ##
  # Print message to STDOUT
  # @param msg The message to be printed
  #
  def print_message(msg):
      print(msg);
#+END_EXAMPLE

and not in docstrings. Luckily there is the
[[http://code.foosel.org/doxypy][doxypy]] filter that allows one to tell
doxygen to look in docstrings. Thus, the above snippet can now become:

#+BEGIN_EXAMPLE
    def print_message(msg):
    """ Print message to STDOUT
    @param msg The message to be printed.
    """
        print(msg);
#+END_EXAMPLE

To get python and doxygen working nicely together, aside from the
standard settings, the following configuration settings are also
recommended/required:

****** settings

#+BEGIN_EXAMPLE
    INPUT_FILTER = "python /path/to/doxypy.py"
    FILTER_SOURCE_FILES = YES
    HIDE_UNDOC_RELATIONS = NO
    OPTIMIZE_OUTPUT_JAVA = YES
    JAVADOC_AUTOBRIEF = YES
    MULTILINE_CPP_IS_BRIEF = YES
    DETAILS_AT_TOP = YES
    EXTRACT_ALL = YES
    EXTRACT_STATIC = YES
    SHOW_DIRECTORIES = YES
    SOURCE_BROWSER = YES
    ALPHABETICAL_INDEX = YES
    COLS_IN_ALPHA_INDEX = 8
    TOC_EXPAND = YES
    DISABLE_INDEX = YES
    GENERATE_TREEVIEW = YES
#+END_EXAMPLE

Of note, with the latest version of Doxygen you can reference a markdown
file as the mainpage.

**** [[http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html#pythonblocks][doxygen doc]]

#+BEGIN_SRC python
  ## @package pyexample
  #  Documentation for this module.
  #
  #  More details.

  ## Documentation for a function.
  #
  #  More details.
  def func():
      pass

  ## Documentation for a class.
  #
  #  More details.
  class PyClass:

      ## The constructor.
      def __init__(self):
          self._memVar = 0;

      ## Documentation for a method.
      #  @param self The object pointer.
      def PyMethod(self):
          pass

      ## A class variable.
      classVar = 0;

      ## @var _memVar
      #  a member variable
#+END_SRC

**** [[https://pypi.python.org/pypi/doxypy/0.3][doxypy]]                                                       :doxypy:

*doxypy* is an input /filter/ for Doxygen. It preprocesses python
files so that docstrings of classes and functions are reformatted into
Doxygen-conform documentation blocks.

** ipython                                                         :ipython:
*** Reference                                                    :homepage:

- [[http://ipython.org/][Homepage]]

*** IPython Introduction                                            :intro:

- [[http://baike.baidu.com/link?url=7-XcxpZSu0jq6nvaEnMk4JFIV-5_SjX7WRN5a5zyxyyv1HiUBpiS2HsTndW9SZYUh2apmjYWWatpJZHEigLidK][ipython简介]]

IPython 1.2.1 -- An enhanced Interactive Python.

ipython 是一个 python 的交互式 shell，比默认的python shell 好用得多，支
持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能
和函数。在ubuntu 下只要 sudo apt-get install ipython 就装好了，通过
ipython 启动。

1. %打头的Magic函数
2. !打头的shell命令
3. ipython notebook


Ubuntu下安装： sudo apt-get ipython

开源(BSD): 当然也可以源码安装，但是何必。

*** [[http://hyry.dip.jp/tech/slice/slice.html/35][IPython Notebook简介]]                               :blog:notebook:math:

IPython notebook目前已经成为用Python做教学、计算、科研的一个重要工具。本文介绍IPython
notebook的一些基本用法，以及如何使用它调试Cython程序。

IPython
Notebook使用浏览器作为界面，向后台的IPython服务器发送请求，并显示结果。在浏览器的界面中使用单元(Cell)保存各种信息。Cell有多种类型，经常使用的有表示格式化文本的[[http://daringfireball.net/projects/markdown/][Markdown]]单元，和表示代码的Code单元。

每个代码单元都有一个输出区域，在Code单元中输入代码，按 Shift-Enter
将运行此代码，代码中最后一个表达式的值将输出区域显示。如果希望屏蔽输出，可以在最后一条语句之后添加一个分号：”;”。此外，代码中还可以使用print语句在输出区域中显示信息。

在Markdown单元中还可以直接使用Html和Javascript。

**** 数学公式

在Markdown单元中可以使用LaTeX表示数学公式。数学公式的显示使用MathJax，
缺省情况下，MathJax从网络上下载，如果希望离线使用它，需要在IPython
Notebook中输入如下代码，把MathJax安装到本地磁盘中：

#+BEGIN_EXAMPLE
    from IPython.external.mathjax import install_mathjax
    install_mathjax()
#+END_EXAMPLE

Code单元的输出也可以显示为数学公式，例如在单元中输入如下代码，将显示为数学公式：

#+BEGIN_EXAMPLE
    from IPython.display import Latex
    Latex(r"$\sqrt{x^2+y^2}$")
#+END_EXAMPLE

SymPy的表达式也可以显示为LaTex，例如：

#+BEGIN_EXAMPLE
    %load_ext sympyprinting
    from sympy import *
    x, y = symbols("x,y")
    sqrt(x**2+y**2)
#+END_EXAMPLE

以%开头的为IPython的命令(Magic
Command)，这里通过%load_ext命令载入sympyprinting扩展插件，载入此插件之后，所有的SymPy表达式都显示为数学公式。

**** 各种显示

IPython.display模块中提供了许多显示Python返回值的类，例如下面的代码用Image类显示”python.png”图片，缺省路径为Notebook文件所在的目录：

#+BEGIN_EXAMPLE
    from IPython.display import Image
    Image(filename="python.png")
#+END_EXAMPLE

Image还可以用来显示表示图像的字符串。例如下面的代码通过cv2的imencode()将NumPy数组转换为一个表示PNG图像数据的数组，然后将此数组转换为字符串之后通过Image()将显示为图像：

#+BEGIN_EXAMPLE
    import cv2
    import numpy as np
    from IPython.display import Image
    img = np.random.randint(0,255,(250,250,3))
    cv2.blur(img, (11,11), img)
    r, dat = cv2.imencode(".png",img)
    Image(dat.tostring())
#+END_EXAMPLE

此外，还可以通过HTML和Javascript将Python代码的输出显示为Html，或者作为Javascript运行。

#+BEGIN_EXAMPLE
    from IPython.display import Javascript
    Javascript("alert('ok')")
#+END_EXAMPLE

将在浏览器中运行Javascript代码。

**** Magic命令

IPython中Magic命令有两种执行方式，以%开始的命令被称为行命令，它只对单行有效，以%%开头的为单元命令，它放在单元的第一行，对整个单元有效。例如*timeit*命令可以快速测试代码的执行效率，它可以作为行命令或者单元命令。

#+BEGIN_EXAMPLE
    %timeit 1 + 1
    %timeit 1.0 + 1.0
    %timeit "1" + "1"
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    10000000 loops, best of 3: 52 ns per loop
    10000000 loops, best of 3: 53.4 ns per loop
    10000000 loops, best of 3: 50.9 ns per loop
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    %%timeit
    s = 0
    for i in xrange(100):
        s += i
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    100000 loops, best of 3: 11 us per loop
#+END_EXAMPLE

每个Magic命令都可以指定参数，可以输入=timeit?=查看其帮助文档。下面让我们看看一些常用的Magic命令。

*%pylab*命令将载入numpy和pylab，并且将这两个模块中的名字载入到全局名字空间中。缺省参数时，它使用matplotlib的缺省界面库显示图表，如果带*inline*参数则将图表作为图像插入到Notebook中。使用界面库显示图像时可以使用交互工具，而将图表直接插入到Notebook中则有利于编写文档。

下面的例子，=plot=和=random=是从pylab和numpy中载入的。

#+BEGIN_EXAMPLE
    %pylab inline
    plot(random.randn(100));
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    Welcome to pylab, a matplotlib-based Python environment [backend: module://IPython.zmq.pylab.backend_inline].
    For more information, type 'help(pylab)'.
#+END_EXAMPLE


*%load*可以从文件或者网址载入代码到一个新的单元中，例如下面载入某个matplotlib的示例程序，并执行：

#+BEGIN_EXAMPLE
    %load http://matplotlib.org/mpl_examples/pylab_examples/histogram_demo.py
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    #!/usr/bin/env python
    import numpy as np
    import matplotlib.mlab as mlab
    import matplotlib.pyplot as plt

    mu, sigma = 100, 15
    x = mu + sigma*np.random.randn(10000)

    # the histogram of the data
    n, bins, patches = plt.hist(x, 50, normed=1, facecolor='green', alpha=0.75)

    # add a 'best fit' line
    y = mlab.normpdf( bins, mu, sigma)
    l = plt.plot(bins, y, 'r--', linewidth=1)

    plt.xlabel('Smarts')
    plt.ylabel('Probability')
    plt.title(r'$\mathrm{Histogram\ of\ IQ:}\ \mu=100,\ \sigma=15$')
    plt.axis([40, 160, 0, 0.03])
    plt.grid(True)

    plt.show()
#+END_EXAMPLE

*%prun*用于代码的执行性能分析，可以作为行命令和单元命令使用。下面的程序分析=numpy.linalg.det()=的性能：

#+BEGIN_EXAMPLE
    %%prun
    for i in xrange(100):
        linalg.det(random.rand(10,10))
#+END_EXAMPLE

其输出如下：

#+BEGIN_EXAMPLE
    3402 function calls in 0.096 seconds

    Ordered by: internal time

    ncalls  tottime  percall  cumtime  percall filename:lineno(function)
       100    0.032    0.000    0.091    0.001 linalg.py:1560(slogdet)
       300    0.022    0.000    0.022    0.000 {method 'reduce' of 'numpy.ufunc' objects}
       200    0.011    0.000    0.012    0.000 numeric.py:167(asarray)
       100    0.006    0.000    0.006    0.000 linalg.py:84(_realType)
       100    0.005    0.000    0.005    0.000 linalg.py:151(_assertRank2)
       ...
#+END_EXAMPLE

*%load_ext*载入IPython的扩展模块，通过它可以载入更多的Magic命令。下面我们载入*cythonmagic*模块，并使用*%%cython*命令编译一个高效的频率统计函数=count()=。

#+BEGIN_EXAMPLE
    %load_ext cythonmagic
#+END_EXAMPLE

**** 测试Cython代码

Cython的代码基本和Python的代码类似，但是可以使用类型声明，Cython可以使用这些类型声明产生更高效的C语言代码，并编译成Python的扩展模块。使用*%%cython*命令简化了编译扩展模块的过程，它会自动创建C语言程序，编译并载入。由于扩展模块无法卸载，因此IPython采用的策略是每次编译不同的代码都会产生一个全新的扩展模块。方便我们不退出Python环境即可运行新的代码。

#+BEGIN_EXAMPLE
    %%cython
    def count(list data):
        cdef:
            dict result = {}
            int i, length = len(data)
            object item

        for i in range(length):
            item = data[i]
            if item in result:
                (<list> result[item]).append(i)
            else:
                result[item] = [i]
        return result
#+END_EXAMPLE

下面是=count()=的Python版本。

#+BEGIN_EXAMPLE
    from collections import defaultdict
    def countpy(data):
        result = defaultdict(list)
        for i,item in enumerate(data):
            result[item].append(i)
        return result
#+END_EXAMPLE

先测试二者的结果是否相同：

#+BEGIN_EXAMPLE
    import random
    data = [random.randint(0,100) for _ in xrange(10000)]
    count(data) == countpy(data)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    True
#+END_EXAMPLE

然后测试它们的执行速度，可以看出Cython版本比Python的要快2倍多。在这个测试中，Cython程序也同样使用列表和字典等对象，但是由于可以直接调用Python的C
API，因此Cython版本的效率能提高几倍。如果只是单纯的数值运算，Cython能将程序提升到与C语言相近的速度。

#+BEGIN_EXAMPLE
    %timeit countpy(data)
    %timeit count(data)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    100 loops, best of 3: 4.52 ms per loop
    1000 loops, best of 3: 1.8 ms per loop
#+END_EXAMPLE

** scrapy

*** reference                                             :github:homepage:

- [[http://scrapy.org/][Homepage]]
- [[https://github.com/scrapy/scrapy][GitHub]]
- [[https://scrapy-chs.readthedocs.org/zh_CN/0.24/index.html][中文 Doc]]

*** intro                                                           :intro:
**** overview                                                   :overview:

#+BEGIN_QUOTE Homepage
An open source and collaborative framework for extracting the data you
need from websites. In a fast, simple, yet extensible way.
#+END_QUOTE

#+BEGIN_QUOTE GitHub
Scrapy is a fast high-level web crawling and web scraping framework,
used to crawl websites and extract structured data from their
pages. It can be used for a wide range of purposes, from data mining
to monitoring and automated testing.
#+END_QUOTE

version 1.0(2016/01/28)

**** 出发点

使用 wget 爬虫博客受挫.

**** install                                                     :install:

https://scrapy-chs.readthedocs.org/zh_CN/0.24/intro/install.html

http://doc.scrapy.org/en/latest/topics/ubuntu.html (update)

1. pip
2. apt-get install python-scrapy

   #+BEGIN_EXAMPLE
     $ scrapy version
     Scrapy 0.24.2
   #+END_EXAMPLE

*** scrapy tutorial

#+include: ~/Wally/Project/scrapy_tutorial/tutorial/tutorial

** Project
*** [[http://lanbing510.info/2015/09/21/ClassifyPictures.html][按拍摄日期一键归类照片 Python]]                               :blog_冰蓝:

冰蓝思考的地方

**** 出发点

--------------

手机里的照片好久没整理，最近提示没空间，自己一般都是按年月将照片保存，看到铺天盖地的照片，整个心都醉了。

于是写了下面这个脚本，一键归类所有的照片，按照拍摄日期归类到年月相应的文件夹。再也不用担心整理照片了！

**** 干货

#+BEGIN_SRC python
    # -*- coding: gbk -*-

    """
    功能：对照片按照拍摄时间进行归类
    使用方法：将脚本和照片放于同一目录，双击运行脚本即可
    作者：冰蓝
    """

    import shutil
    import os
    import time
    import exifread


    class ReadFailException(Exception):
        pass

    def getOriginalDate(filename):
        try:
            fd = open(filename, 'rb')
        except:
            raise ReadFailException, "unopen file[%s]\n" % filename
        data = exifread.process_file( fd )
        if data:
            try:
                t = data['EXIF DateTimeOriginal']
                return str(t).replace(":",".")[:7]
            except:
                pass
        state = os.stat(filename)
        return time.strftime("%Y.%m", time.localtime(state[-2]))


    def classifyPictures(path):
        for root,dirs,files in os.walk(path,True):
            dirs[:] = []
            for filename in files:
                filename = os.path.join(root, filename)
                f,e = os.path.splitext(filename)
                if e.lower() not in ('.jpg','.png','.mp4'):
                    continue
                info = "文件名: " + filename + " "
                t=""
                try:
                    t = getOriginalDate( filename )
                except Exception,e:
                    print e
                    continue
                info = info + "拍摄时间：" + t + " "
                pwd = root +'\\'+ t
                dst = pwd + '\\' + filename
                if not os.path.exists(pwd ):
                    os.mkdir(pwd)
                print info, dst
                shutil.copy2( filename, dst )
                os.remove( filename )

    if __name__ == "__main__":
        path = "."
        classifyPictures(path)
#+END_SRC

 以上。

* Bash                                                                 :BASH:
** Bash基础
*** intro

bash(Bourne Again Shell)是一种 *命令解释器*,同时也是一门 *高级编程语
言*

+ 作为命令解释器,bash通过提示符响应并处理用户在命令行界面上输入的命令.
+ 作为编程语言,bash处理存放在 *shell脚本文件* 中的命令.

*** shell简介                                          :shell:env:terminal:

shell，俗称壳（用来区别于核），是指提供给使用者使用的界面的软件。常见的shell
有ash,bash,ksh,csh,zch。bash是Linux系统默认的shell，一共有40个内部命令。
与Linux内核类似，shell仅提供了用户与计算机交互的指令，而其具体的命令行输入输
出要通过终端（Terminal）完成，在Linux操作系统中，用户可以自定义终端来完成相应
工作。

#+BEGIN_SRC sh
echo $SHELL    # 查看shell类型
#+END_SRC

#+RESULTS:
: /bin/bash

shell的工作方式包括：

+ 命令行工作方式：shell识别并且对用输入的字符串进行响应，通常也称为“交互式工
  作方式”。

+ 编程语言工作方式：shell同样是一种编程语言，可以写成脚本文件。

shell启动时，先读取 */etc/bash.bashrc* 文件对操作系统进行配置，然后读
取 *~/.bashrc* 文件对当前用户配置。

和shell启动相关的文件有：

+ /.bashrc_profile/: 该文件只能被登陆用户对应的shell读取
+ /.bashrc/: 该文件被启动的所有shell读取
+ /.bash_logout/: bash退出是执行该文件

在X Window中运行的终端实际上是一种虚拟终端（哑终端）。

可以通过 _Ctrl+Alt+Fn_ 进入真实终端。

在启动Ubuntu系统时，会启动 *7* 个终端，其中1-6号终端均是直接运行的一个
真实终端， 第7号终端给X Window使用。Alt+F7 从1-6号终端切换到X Window。

Unix shell
+ sh shell: Bourne Shell,旱期的UNIX shell, AT&T贝尔实验室
+ bash shell: 扩展并兼容Bourne Shell
+ dash shell: 体积小,加载和脚本执行速度快于bash
+ Korn shell: 类似bash

*POSIX(Portable Operating System Interface)*,可移植操作系统接口.

*** 初始化文件                                                      :shell:

当启动shell时,它将运行初始化文件初始化自己.

**** 登录shell

登录shell属于交互式shell.首先执行 */etc/profile* 中的命令,然后依次
查找 *~/.bash_profile*, *~/.bash_login*, *~/.profile*,并执行找到的
首个文件的命令.

用户注销时,bash执行 *~/.bash_logout* 中的命令.

**** 交互式登录shell

交互式登录shell执行 *~/.bashrc* 文件中的命令.

**** 非交互式shell

从登录shell继承shell变量. 比如，terminal 中 C-M-t.

**** 句点(.)或source:在当前shell中运行初始化文件                  :source:

*** 符号命令                                                       :symbol:

Bourne Again Shell以使用多种方式使用符号(,),[,]和$

|------+--------------------------|
| ()   | 子shell                  |
| $()  | 命令替换                 |
| (()) | 算术表达式计算,let同义词 |
| [ ]  | test命令                 |
| [[]] | 条件表达式               |
|------+--------------------------|

*** 变量                                                         :variable:
**** [[/a/1190000002539169][玩转Bash变量]]                                                   :blog:

注意本文讨论的是 Bash，而不一定是 /bin/sh 所链接的那个 shell。这里出现的所
有代码片段，默认在顶上都添加了 =#!/bin/bash= 。


***** 一门自带混淆的语言

#+BEGIN_SRC bash
    while (( $# )); do
        case $1 in
            -a*)
                # Error checking
                [[ ${1#-a} ]] || { echo "bash: ${FUNCNAME[0]}: \`$1': missing"\
                    "number specifier" 1>&2; return 1; }
                printf %d "${1#-a}" &> /dev/null || { echo "bash:"\
                    "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2
                return 1; }
                # Assign array of -aN elements
                [[ "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) &&
                    shift $((${1#-a} + 2)) || { echo "bash: ${FUNCNAME[0]}:"\
                    "\`$1${2+ }$2': missing argument(s)" 1>&2; return 1; }
                ;;
            -v)
                # Assign single value
                [[ "$2" ]] && unset -v "$2" && eval $2=\"\$3\" &&
                    shift 3 || { echo "bash: ${FUNCNAME[0]}: $1: missing"\
                    "argument(s)" 1>&2; return 1; }
                ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2
                return 1 ;;
        esac
    done
#+END_src

如果你觉得阅读上面的Bash代码，就像阅读段子一样顺畅，那么是时候关掉这个
页面，去做别的更有意义的行为，比如去喝个水什么的。

如果你觉得上面的Bash代码犹如鬼画符，并且实际生活中不得不面对它，那么就看下去吧。

***** Bash变量操作

正式开始正文内容。

想要在一篇文章里，讲述要看懂开篇代码所需的所有知识点，这是不自量力的行
为。因此，本文将讲且仅讲Bash中操作变量的方法。所以，即使你看完了这篇文
章，你多半还是看不懂开篇的代码。


不过看完这篇文章之后，你对Bash的变量操作会有更为深入的认识。而且更重要
的是，Bash之于你，不再是怎么也看不清摸不透。下一次要写脚本的时候，你也
将更加坚定地下定决心
#+BEGIN_EXAMPLE
------ 人生苦短，我用Python/Ruby。
#+END_EXAMPLE

****** 严格意义上的Bash变量类型

Bash变量只有两种类型，字符串和数组。不过从严格意义上，Bash没有变量类型。
Bash中的变量，在运行的时候会被展开成其对应的值（字符串）。你可以把它看
做C/C++中的宏定义，或者一些模板语言中的占位符。


一般情况下，变量通过 = 赋值，注意 = 两边不要留空格。有些好孩子，已经养
成了符号两端留空格的习惯，结果当开始写Bash的时候，他们抓狂了。

要想访问变量，只需在变量名前面添加 =$= ，解释器就会对它进行展开。如果
该变量并不存在，解释器会把它展开成“”。

#+BEGIN_EXAMPLE
    me=spacewander
    echo $me
    echo $who
#+END_EXAMPLE

****** 来自命令行的你

作为脚本语言，第一要义当然是要随时随地获取到命令行输入啦。

在Bash中，使用 =$1= 可以获取命令行输入的第一个参数， =$2= 可以获取命令
行输入的第2个参数， =$3= 可以获取命令行输入的第......

你看，$1到 $10000 的用法就这么交代完了。Bash还是挺有逻辑的嘛。

顺便一提， =$0= 获取的脚本的名字（其实就是其他语言中的第0个参数），
=$@= 获取所有的参数， =$#= 获取参数的数目。记住 =@= 和 =#= 这两个符号，
在Bash这一神秘的符文体系中，前者表示全部参数，后者表示参数的数目。


****** 展开，然后Bomb！

假如Bash变量中含有空白字符，或者含有特殊字符，比如 =*= ，展开后会污染
到外面的字符串，结果就是*Bomb*。

比如

#+BEGIN_EXAMPLE
    Oops='*'
    # '*'解释成所有匹配的文件名
    echo $Oops
    # 所以需要加双引号括起来
    echo "$Oops"
    # 加单引号会怎样呢？
    echo '$Oops'
#+END_EXAMPLE

上面的代码值得一试。

另外一种Bomb的可能是，变量后面需要接其它字符串，比如=$FRUITs=。如果想
让解释器识别成=$FRUIT=变量，而不是=$FRUITs=，需要用花括号括起来，像
=${FRUIT}s=

****** 数组和关联数组

Bash中可以使用两种容器。
一种是数组，另一种是关联数组，类似于其他语言中的Map/Hash/Dict。
声明数组的常用语法：  =declare -a ARY= 或者 =ARY=(1 2 3)=
声明关联数组的唯一语法： =declare -A MAP=

赋值的语法：

直接 =ARY[N]= VALUE =，N可以是数字索引也可以是键。关联数组可以使用
MAP=([x]=a [y]=b) 进行多项赋值，注意这是赋值的语句而不是声明。

亲测数组中的索引不一定要按顺序来，你可以先给2和3上的元素赋值。（同样算
是弱类型的Javascript也支持这种无厘头赋值，这算通病么？）

往现有数组批量添加元素：

#+BEGIN_EXAMPLE
    ARY+=(a b c)
    MAP+=([a]=1 [b]=2)
#+END_EXAMPLE

取值：

#+BEGIN_EXAMPLE
    ${ARY[INDEX]}
    ${MAP[KEY]}
#+END_EXAMPLE

注意花括号的使用

=${A[@]}= 展开成所有的变量，而获取数组长度使用 =${#A[@]}=

切片：
=${ARY[@]:N:M}= N是offset而M是length

返回索引，相当于keys()：
=${!MAP[@]}=

试试下面的代码：

#+BEGIN_EXAMPLE
    declare -a ARY
    declare -A MAP
    MAP+=([a]=1 [b]=2)
    ARY+=(a b c)

    echo ${ARY[1]}
    echo ${MAP[a]}
    echo "${ARY[@]}"
    echo "${MAP[@]}"
    echo "${ARY[@]:0:1}"
    echo ${#ARY[@]}
    echo "${!MAP[@]}"

    ARY[4]=a
    echo ${ARY[@]}
    echo ${ARY[3]}
#+END_EXAMPLE

****** 变量（字符串）变换

Bash中的变量变换，大体是${变量[操作符]}的形式

******* 大小写变换

#+BEGIN_EXAMPLE
    HI=HellO

    echo "$HI" # HellO
    echo ${HI^} # HellO
    echo ${HI^^} # HELLO
    echo ${HI,} # hellO
    echo ${HI,,} # hello
    echo ${HI~} # hellO
    echo ${HI~~} #hELLo
#+END_EXAMPLE

=^= 大写， =,=  小写，  =~= 大小写切换

重复一次只修改首字母，重复两次则应用于所有字母。

混着用会怎样？
=echo ${HI^,^} # HellO=

看来是不行的×_×

******* 移除匹配的字符串

=%xx= 从后往前，开始匹配，移除匹配的内容
=%%xx= 跟上面的差不多，不过这是贪婪匹配
=#xx= 从前往后，开始匹配，移除匹配的内容
=##xx= 跟上面的差不多，不过这是贪婪匹配

这个比较难理解，不过看下面几个例子应该能明白了。

#+BEGIN_EXAMPLE
    FILENAME=/home/spacewander/param.sh
    echo ${FILENAME%/*} # /home/spacewander
    echo ${FILENAME%%/*} #
    echo ${FILENAME#*/} # home/spacewander/param.sh
    echo ${FILENAME##*/} # param.sh
#+END_EXAMPLE

******* 查找并替换

=/MATCH/VALUE= 替换第一个匹配的内容。
=//MATCH/VALUE= 替换匹配的内容

#+BEGIN_EXAMPLE
    echo ${FILENAME/home/office} # /office/spacewander/param.sh
    echo ${FILENAME//s/S} # /home/Spacewander/param.Sh
#+END_EXAMPLE

****** 其它字符串操作

获取变量（字符串）长度： =${#FILENAME}=

字符串切片：跟数组切片是同样的语法， =${STR:offset:len}=

#+BEGIN_EXAMPLE
    TEXT=这个程序充满了BUG!
    echo ${TEXT:0:8}
    echo ${TEXT:4}

    # 你还可以使用负数作为offset，这时候就是从后往前算起。注意负数要用括号括起来，避免冲突。
    echo ${TEXT:(-4)}
#+END_EXAMPLE

****** 关于变量，其它的内容

Bash中有一项特性，你可以方便地检查某个变量是否设置了，如果没有设置，就
赋予一个默认值。尤其在处理环境变量的时候，这项特性会让你感到欣慰。

语法是 =${VAR:= VALUE} =或者= ${VAR: =VALUE}= 。此外，还有一个相似的语
法， =${VAR:=VALUE}= 和 =${VAR：=VALUE}= 。

下面展示下两者的区别

#+BEGIN_EXAMPLE
    # expand to default variable
    echo ${NULL-"Not null"} # Not null
    echo ${NULL} #

    # set default variable
    echo ${NIL="Not nil"} # Not nil
    echo ${NIL} # Not nil
#+END_EXAMPLE

可以看出，前者只是当变量不存在时，展开成指定的值。而后者在变量不存在时，
将变量的值设置为指定值。

最后介绍一个，当目标变量不存在时，指定报错信息的语法。

#+BEGIN_EXAMPLE
    echo ${TARGET?Not Found} # 当$TARGET不存在时，显示TARGET: Not Found，并结束程序。
#+END_EXAMPLE

*** shell脚本

shell脚本是包含可执行shell命令的文件.除了使用用户在命令行下的命令
外,shell脚本还可以使用控制流命令(控制结构).shell一条接着一条解释并执行
shell脚本中的命令.

*** 通配符                                                       :wildcard:

Shell和用户交互是以字符串形式存在的命令和命令输出反馈的方式进行的，在Linux命
令行中输入的第一个字符串必须是一个命令的名字，第二个字符串是命令的选项或参数。
命令行的每个字符串必须由空格或TAB分开。

$ CMD OPTION ARG

shell的通配符用于模式匹配，如文件名匹配，路径名搜索和字符串查找等。常用的通配
符包括：

- * 匹配任意长度的字符串，但文件名中的圆点(.)和路径名中的斜线(/)必须是
  显式的，  即不能用通配符替代它们。

- ? 匹配一个字符

- [] 指定字符范围，字符范围可以由字符串构成，也可以由表示限定范围的起
  始字符、终止字符及中间连字符(-)组成。

  - 中间连字符(-)仅在方括号中有效

  - _* 和 ? 在方括号内失去通配功能_

**** [[http://www.cnblogs.com/ggjucheng/archive/2012/10/30/2746963.html][bash的通配符与特殊符号]]                                         :blog:

在 bash 的操作环境中还有一个非常有用的功能，那就是通配符 (wildcard) ！
我们利用 bash 处理数据就更方便了！底下我们列出一些常用的通配符喔：

| 符号   | *                                 | ?                            | [ ]                                                                                                                       | [ - ]                                                                                                                       | [\^ ]                                                                                                                                     |
| 意义   | 代表『 0 个到无穷多个』任意字符   | 代表『一定有一个』任意字符   | 同样代表『一定有一个在括号内』的字符(非任意字符)。例如 [abcd] 代表『一定有一个字符， 可能是 a, b, c, d 这四个任何一个』   | 若有减号在中括号内时，代表『在编码顺序内的所有字符』。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！   | 若中括号内的第一个字符为指数符号 (\^) ，那表示『反向选择』，例如 [\^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。   |

接下来让我们利用通配符来玩些东西吧！首先，利用通配符配合 ls 找檔名看看：

#+BEGIN_EXAMPLE
    [root@www ~]# LANG=C              <==由于与编码有关，先配置语系一下

    范例一：找出 /etc/ 底下以 cron 为开头的档名
    [root@www ~]# ll -d /etc/cron*    <==加上 -d 是为了仅显示目录而已

    范例二：找出 /etc/ 底下文件名『刚好是五个字母』的文件名
    [root@www ~]# ll -d /etc/?????    <==由于 ? 一定有一个，所以五个 ? 就对了

    范例三：找出 /etc/ 底下文件名含有数字的文件名
    [root@www ~]# ll -d /etc/*[0-9]*  <==记得中括号左右两边均需 *

    范例四：找出 /etc/ 底下，档名开头非为小写字母的文件名：
    [root@www ~]# ll -d /etc/[^a-z]*  <==注意中括号左边没有 *

    范例五：将范例四找到的文件复制到 /tmp 中
    [root@www ~]# cp -a /etc/[^a-z]* /tmp
#+END_EXAMPLE



除了通配符之外，bash 环境中的特殊符号有哪些呢？底下我们先汇整一下：

| 符号   | #                                                                      | \                                                | |                                                   | ;                                                                 | ~              | $                                                  | &                                              | !                                     | /                          | >, >>                                              | <, <<                                         | ' '                            | " "                    | ` `                                                | ( )                             | { }                        |
| 内容   | 批注符号：这个最常被使用在 script 当中，视为说明！在后的数据均不运行   | 跳脱符号：将『特殊字符或通配符』还原成一般字符   | 管线 (pipe)：分隔两个管线命令的界定(后两节介绍)；   | 连续命令下达分隔符：连续性命令的界定 (注意！与管线命令并不相同)   | 用户的家目录   | 取用变量前导符：亦即是变量之前需要加的变量取代值   | 工作控制 (job control)：将命令变成背景下工作   | 逻辑运算意义上的『非』 not 的意思！   | 目录符号：路径分隔的符号   | 数据流重导向：输出导向，分别是『取代』与『累加』   | 数据流重导向：输入导向 (这两个留待下节介绍)   | 单引号，不具有变量置换的功能   | 具有变量置换的功能！   | 两个『 ` 』中间为可以先运行的命令，亦可使用 $( )   | 在中间为子 shell 的起始与结束   | 在中间为命令区块的组合！   |

以上为 bash
环境中常见的特殊符号汇整！理论上，你的『档名』尽量不要使用到上述的字符啦！


*** shell 中的引号

1) /单引号/ ： 由单引号括起的字符均当作普通字符使用

   eg.   $ echo '$PATH'    # 输出$PATH字符串，而不是变量PATH的值

2) /双引号：/ 双引号的作用与单引号类似，区别在于它没有那么严格。单引号告
   诉shell

   忽略所有的特殊字符，而双引号只要求忽略大多数字符，不会忽略双引号中3种特殊字
   符： /$, \ 和 `(反引号)/

   eg.
   #+BEGIN_SRC sh
     x=*    # 定义变量x
     echo $*    # 显示x的值，即*通配的当前目录下的所有文件名
     echo '$x'  # 返回单引号中字符串内容，不加任何解释，即$x
     echo "$x"  # 对变量名进行替换，但不会解释替换的内容即*
   #+END_SRC

   Shell赋值的先后顺序：shell先进行变量替换，再进行文件名（通配符）替换，最后将
   这些替换值作为参数传递给命令。

3) /反引号/: 反引号（`）对应的键通常位于键盘的左上角。反引号括起来的字串会被当作
   shell命令行进行解释，并以解释的标准输出结果代替整个反引号
   eg.   $ ehco `pwd`
   反引号可以嵌套使用，但嵌套时内层的反引号必须使用\进行转义。

shell以#开始注释

*** separating and grouping cmds

- ; and LF separate cmds
- \ continues a cmd
- | pipe cmds
- & execute cmd background
- () group commands

*** manipulate the directory stack                               :dirs:file:

1. /dirs/    # display the *dir stack*

2. /pushd/

   #+BEGIN_SRC sh
     pushd path/to/new/dir     # add new to stack
     pushd                     # swap top with the 2ed dir, and cd that
     pushd +n                  # swap top with the (n-1)th dir, and cd that
   #+END_SRC

3. /popd/

   #+BEGIN_SRC sh
     popd                            # remove the top from the stack
     popd +n                         # remove the (n-1)th from the stack
   #+END_SRC

*** declare                                                       :declare:
**** declare 限定属性

*declare* 或typeset内建命令(它们是完全相同的)可以用来 *限定变量的属性*

这是在某些编程语言中使用的定义类型不严格的方式。命令declare是bash版本2
之后才有的。

1. -r 只读(类似C常量)
2. -i 整型
3. -f 函数
4. -a 数组

***** 参考

+ [[*%5B%5Bhttp://www.cnblogs.com/fhefh/archive/2011/04/22/2024857.html%5D%5Blinux%20bash%20shell%E4%B9%8Bdeclare%5D%5D][linux bash shell之declare*]]

**** [[http://www.cnblogs.com/fhefh/archive/2011/04/22/2024857.html][linux bash shell之declare]]                                      :blog:


/declare/或/typeset/内建命令(它们是完全相同的)可以用来限定变量的属性.这是在某些编程语言中使用的定义类型不严格的方式。命令*declare*是bash版本2之后才有的。命令*typeset*也可以在ksh脚本中运行。

*declare/typeset 选项*

- -r =只读=
  #+BEGIN_EXAMPLE
  1 declare -r var1
  #+END_EXAMPLE

  (=declare -r var1=与=readonly var1=作用相同)

  这大致和C的*const*限定词相同.一个试图改变只读变量值的操作将会引起错误信息而失败.

- -i =整数=
  #+BEGIN_EXAMPLE
                        1 declare -i number
                        2 # 脚本余下的部分会把"number"当作整数看待.
                        3
                        4 number=3
                        5 echo "Number = $number"     # Number = 3
                        6
                        7 number=three
                        8 echo "Number = $number"     # Number = 0
                        9 # 脚本尝试把字符串"three"作为整数来求值(译者注：当然会失败，所以出现值为0).
  #+END_EXAMPLE

  某些算术计算允许在被声明为整数的变量中完成，而不需要特别使用expr或let来完成。

  #+BEGIN_EXAMPLE
           1 n=6/3
           2 echo "n = $n"       # n = 6/3
           3
           4 declare -i n
           5 n=6/3
           6 echo "n = $n"       # n = 2
  #+END_EXAMPLE

- -a =数组=
  #+BEGIN_EXAMPLE
                        1 declare -a indices
  #+END_EXAMPLE

  变量=indices=会被当作数组.

- -f =函数=
  #+BEGIN_EXAMPLE
                        1 declare -f
  #+END_EXAMPLE

  在脚本中没有带任何参数的=declare -f= 会列出所有在此脚本前面已定义的函数出来。

  #+BEGIN_EXAMPLE
           1 declare -f function_name
  #+END_EXAMPLE

  而=declare -f function_name=则只会列出指定的函数.

- -x export
  #+BEGIN_EXAMPLE
                        1 declare -x var3
  #+END_EXAMPLE

  这样将声明一个变量作为脚本的环境变量而被导出。

- -x var=$value
  #+BEGIN_EXAMPLE
                            1 declare -x var3=373
  #+END_EXAMPLE

  *declare* 命令允许在声明变量类型的时候同时给变量赋值。

  例子 9-21. 用 declare 来声明变量类型

  #+BEGIN_EXAMPLE
        1 #!/bin/bash
        2
        3 func1 ()
        4 {
        5 echo This is a function.
        6 }
        7
        8 declare -f        # 列出上面的函数.
        9
       10 echo
       11
       12 declare -i var1   # var1是一个整数.
       13 var1=2367
       14 echo "var1 declared as $var1"
       15 var1=var1+1       # 整数声明后，不需要使用'let'.
       16 echo "var1 incremented by 1 is $var1."
       17 # 试图将已声明为整数的变量的值更改为浮点值.
       18 echo "Attempting to change var1 to floating point value, 2367.1."
       19 var1=2367.1       # 引起一个错误信息，此变量的值保持原样.
       20 echo "var1 is still $var1"
       21
       22 echo
       23
       24 declare -r var2=13.36         # 'declare'允许设置变量的属性，
       25                               #+ 同时也给变量赋值.
       26 echo "var2 declared as $var2" # 试图更改只读变量的值.
       27 var2=13.37                    # 引起错误，并且从脚本退出.
       28
       29 echo "var2 is still $var2"    # 这行不会被执行.
       30
       31 exit 0                        # 脚本不会从这儿退出.
  #+END_EXAMPLE

*** 特殊符号                                                   :symbol:env:

- \   命令续行
- #!  指定 shell
- $0  当前脚本的文件名
- $n  传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。
- $#  传递给脚本或函数的参数个数。
- $*  传递给脚本或函数的所有参数。
- $@  传递给脚本或函数的所有参数。
- $?  上个命令的退出状态，或函数的返回值。
- $$  当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。

**** [[http://c.biancheng.net/cpp/view/2739.html][$* 和 $@ 的区别]]

$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(" ")包含时，都以
"$1" "$2" … "$n" 的形式输出所有参数。

当它们被双引号(" ")包含时，
- _$* 会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数_
- _$@ 会将各个参数分开，以"$1" "$2" … "$n" 的形式输出所有参数_

**** [[http://www.cnblogs.com/xuxm2007/archive/2011/10/20/2218846.html][shell脚本中一些特殊符号]]                                        :blog:

在shell中常用的特殊符号罗列如下：

# ;   ;; . , / \\ 'string'| !   $   ${}   $? $$   $*

\"string\"* **   ? : ^ $#   $@ `command`{}   [] [[]] ()   (())

||   && {xx,yy,zz,...}~   ~+   ~-   &   \\<...\\>   + - %=   ==   !=


# 井号 (comments)
这几乎是个满场都有的符号，除了先前已经提过的\"第一行\"
#!/bin/bash
井号也常出现在一行的开头，或者位于完整指令之后，这类情况表示符号后面的是注解文字，不会被执行。
# This line is comments.
echo \"a = $a\" # a = 0
由于这个特性，当临时不想执行某行指令时，只需在该行开头加上 # 就行了。这常用在撰写过程中。
#echo \"a = $a\" # a = 0
如果被用在指令中，或者引号双引号括住的话，或者在倒斜线的后面，那他就变成一般符号，不具上述的特殊功能。


~ 帐户的 home 目录
算是个常见的符号，代表使用者的 home 目录：cd ~；也可以直接在符号后加上某帐户的名称：cd ~user或者当成是路径的一部份：~/bin
~+ 当前的工作目录，这个符号代表当前的工作目录，她和内建指令 pwd的作用是相同的。
# echo ~+/var/log
~- 上次的工作目录，这个符号代表上次的工作目录。
# echo ~-/etc/httpd/logs


; 分号 (Command separator)
在 shell 中，担任\"连续指令\"功能的符号就是\"分号\"。譬如以下的例子：cd ~/backup ; mkdir startup ;cp ~/.* startup/.


;; 连续分号 (Terminator)
专用在 case 的选项，担任 Terminator 的角色。
case \"$fop\" inhelp) echo \"Usage: Command -help -version filename\";;version) echo \"version 0.1\" ;;esac


. 逗号 (dot,就是“点”)
在 shell 中，使用者应该都清楚，一个 dot 代表当前目录，两个 dot 代表上层目录。
CDPATH=.:~:/home:/home/web:/var:/usr/local
在上行 CDPATH 的设定中，等号后的 dot 代表的就是当前目录的意思。
如果档案名称以 dot 开头，该档案就属特殊档案，用 ls 指令必须加上 -a 选项才会显示。除此之外，在 regularexpression 中，一个 dot 代表匹配一个字元。


'string' 单引号 (single quote)
被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量替换。
heyyou=homeecho '$heyyou' # We get $heyyou


\"string\" 双引号 (double quote)
被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。
heyyou=homeecho \"$heyyou\" # We get home

`command` 倒引号 (backticks)
在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。
fdv=`date +%F`echo \"Today $fdv\"
在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。


, 逗点 (comma，标点中的逗号)
这个符号常运用在运算当中当做\"区隔\"用途。如下例
#!/bin/bashlet \"t1 = ((a = 5 + 3, b = 7 - 1, c = 15 / 3))\"echo \"t1= $t1, a = $a, b = $b\"


/ 斜线 (forward slash)
在路径表示时，代表目录。
cd /etc/rc.dcd ../..cd /
通常单一的 / 代表 root 根目录的意思；在四则运算中，代表除法的符号。
let \"num1 = ((a = 10 / 2, b = 25 / 5))\"


\\ 倒斜线
在交互模式下的escape 字元，有几个作用；放在指令前，有取消 aliases的作用；放在特殊符号前，则该特殊符号的作用消失；放在指令的最末端，表示指令连接下一行。
# type rmrm is aliased to `rm -i'# \\rm ./*.log
上例，我在 rm 指令前加上 escape 字元，作用是暂时取消别名的功能，将 rm 指令还原。
# bkdir=/home# echo \"Backup dir, \\$bkdir = $bkdir\"Backup dir,$bkdir = /home
上例 echo 内的 \\$bkdir，escape 将 $ 变数的功能取消了，因此，会输出 $bkdir，而第二个 $bkdir则会输出变数的内容 /home。


| 管道 (pipeline)
pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。
who | wc -l
善用这个观念，对精简 script 有相当的帮助。


! 惊叹号(negate or reverse)
通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表\"不等于\"
if [ \"$?\" != 0 ]thenecho \"Executes error\"exit 1fi
在规则表达式中她担任 \"反逻辑\" 的角色
ls a[!0-9]
上例，代表显示除了a0, a1 .... a9 这几个文件的其他文件。


: 冒号
在 bash 中，这是一个内建指令：\"什么事都不干\"，但返回状态值 0。
:
echo $? # 回应为 0
: > f.$$
上面这一行，相当于 cat /dev/null >f.$$。不仅写法简短了，而且执行效率也好上许多。
有时，也会出现以下这类的用法
: ${HOSTNAME?} ${USER?} ${MAIL?}
这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或 if这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。


? 问号 (wild card)
在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字元，但不包含 null 字元。
# ls a?a1
善用她的特点，可以做比较精确的档名匹配。


 * 星号 (wild card)
相当常用的符号。在文件名扩展(Filename expansion)上，她用来代表任何字元，包含 null 字元。
# ls a*a a1 access_log
在运算时，它则代表 \"乘法\"。
let \"fmult=2*3\"
除了内建指令 let，还有一个关于运算的指令expr，星号在这里也担任\"乘法\"的角色。不过在使用上得小心，他的前面必须加上escape 字元。


 ** 次方运算
两个星号在运算时代表 \"次方\" 的意思。
let \"sus=2**3\"echo \"sus = $sus\" # sus = 8


$ 钱号(dollar sign)
变量替换(Variable Substitution)的代表符号。
vrs=123echo \"vrs = $vrs\" # vrs = 123
另外，在 Regular Expressions 里被定义为 \"行\" 的最末端 (end-of-line)。这个常用在grep、sed、awk 以及 vim(vi) 当中。


${} 变量的正规表达式
bash 对 ${} 定义了不少用法。以下是取自线上说明的表列
   ${parameter:-word}   ${parameter:=word}   ${parameter:?word}   ${parameter:+word}   ${parameterffset}   ${parameterffset:length}   ${!prefix*}   ${#parameter}   ${parameter#word}   ${parameter##word}   ${parameter%word}   ${parameter%%word}   ${parameter/pattern/string}   ${parameter//pattern/string}


$*
$* 引用script的执行引用变量，引用参数的算法与一般指令相同，指令本身为0，其后为1，然后依此类推。引用变量的代表方式如下：
$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}.....
个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住。
$* 则是代表所有引用变量的符号。使用时，得视情况加上双引号。
echo \"$*\"
还有一个与 $* 具有相同作用的符号，但效用与处理方式略为不同的符号。


$@
$@ 与 $* 具有相同作用的符号，不过她们两者有一个不同点。
符号 $* 将所有的引用变量视为一个整体。但符号 $@ 则仍旧保留每个引用变量的区段观念。

$#
这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。
echo \"$#\"


$? 状态值 (status variable)
一般来说，UNIX(linux) 系统的进程以执行系统调用exit()来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行状态。
一般指令程序倘若执行成功，其回传值为 0；失败为 1。
tar cvfz dfbackup.tar.gz /home/user > /dev/nullecho\"$?\"$$
由于进程的ID是唯一的，所以在同一个时间，不可能有重复性的 PID。有时，script会需要产生临时文件，用来存放必要的资料。而此script亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠。唯有产生动态文件名，才能符合需要。符号$$或许可以符合这种需求。它代表当前shell 的 PID。
echo \"$HOSTNAME, $USER, $MAIL\" > ftmp.$$
使用它来作为文件名的一部份，可以避免在同一时间，产生相同文件名的覆盖现象。
ps: 基本上，系统会回收执行完毕的 PID，然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法，如果script 执行完毕后仍不加以清除，会产生其他问题。

(   ) 指令群组 (command group)
用括号将一串连续指令括起来，这种用法对 shell 来说，称为指令群组。如下面的例子：(cd ~ ; vcgh=`pwd` ;echo $vcgh)，指令群组有一个特性，shell会以产生 subshell来执行这组指令。因此，在其中所定义的变数，仅作用于指令群组本身。我们来看个例子
# cat ftmp-01#!/bin/basha=fsh(a=incg ; echo -e \"\\n $a \\n\")echo $a#./ftmp-01incgfsh
除了上述的指令群组，括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape字元才能使用的场合，如运算式。


(( ))
这组符号的作用与 let 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let指令要好许多。
#!/bin/bash(( a = 10 ))echo -e \"inital value, a = $a\\n\"(( a++))echo \"after a++, a = $a\"

{ } 大括号 (Block of code)
有时候 script 当中会出现，大括号中会夹着一段或几段以\"分号\"做结尾的指令或变数设定。
# cat ftmp-02#!/bin/basha=fsh{a=inbc ; echo -e \"\\n $a \\n\"}echo $a#./ftmp-02inbcinbc
这种用法与上面介绍的指令群组非常相似，但有个不同点，它在当前的 shell 执行，不会产生 subshell。
大括号也被运用在 \"函数\" 的功能上。广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写 script也是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。

此外，大括号还有另一种用法，如下
{xx,yy,zz,...}
这种大括号的组合，常用在字串的组合上，来看个例子
mkdir {userA,userB,userC}-{home,bin,data}
我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data, userC-home, userC-bin,userC-data，这几个目录。这组符号在适用性上相当广泛。能加以善用的话，回报是精简与效率。像下面的例子
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
如果不是因为支援这种用法，我们得写几行重复几次呀！


[   ] 中括号
常出现在流程控制中，扮演括住判断式的作用。if [ \"$?\" != 0 ]thenecho \"Executes error\"exit1fi
这个符号在正则表达式中担任类似 \"范围\" 或 \"集合\" 的角色
rm -r 200[1234]
上例，代表删除 2001, 2002, 2003, 2004 等目录的意思。


[[ ]]
这组符号与先前的 [] 符号，基本上作用相同，但她允许在其中直接使用 || 与&& 逻辑等符号。
#!/bin/bashread akif [[ $ak > 5 || $ak< 9 ]]thenecho $akfi


|| 逻辑符号
这个会时常看到，代表 or 逻辑的符号。


&& 逻辑符号
这个也会常看到，代表 and 逻辑的符号。


& 后台工作
单一个& 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。
tar cvfz data.tar.gz data > /dev/null&

\\<...\\> 单字边界
这组符号在规则表达式中，被定义为\"边界\"的意思。譬如，当我们想找寻 the 这个单字时，如果我们用
grep the FileA
你将会发现，像 there 这类的单字，也会被当成是匹配的单字。因为 the 正巧是 there的一部份。如果我们要必免这种情况，就得加上 \"边界\" 的符号
grep '\\' FileA


+ 加号 (plus)
在运算式中，她用来表示 \"加法\"。
expr 1 + 2 + 3
此外在规则表达式中，用来表示\"很多个\"的前面字元的意思。
# grep '10\\+9' fileB109100910000910000931010009#这个符号在使用时，前面必须加上escape 字元。


- 减号 (dash)
在运算式中，她用来表示 \"减法\"。
expr 10 - 2
此外也是系统指令的选项符号。
ls -expr 10 - 2
在 GNU 指令中，如果单独使用 - 符号，不加任何该加的文件名称时，代表\"标准输入\"的意思。这是 GNU指令的共通选项。譬如下例
tar xpvf -
这里的 - 符号，既代表从标准输入读取资料。
不过，在 cd 指令中则比较特别
cd -
这代表变更工作目录到\"上一次\"工作目录。


% 除法 (Modulo)
在运算式中，用来表示 \"除法\"。
expr 10 % 2
此外，也被运用在关于变量的规则表达式当中的下列
${parameter%word}${parameter%%word}
一个 % 表示最短的 word 匹配，两个表示最长的 word 匹配。


= 等号 (Equals)
常在设定变数时看到的符号。
vara=123echo \" vara = $vara\"
或者像是 PATH 的设定，甚至应用在运算或判断式等此类用途上。


== 等号 (Equals)
常在条件判断式中看到，代表 \"等于\" 的意思。
if [ $vara == $varb ]
...下略

!= 不等于
常在条件判断式中看到，代表 \"不等于\" 的意思。
if [ $vara != $varb ]
...下略


^
这个符号在规则表达式中，代表行的 \"开头\" 位置，在[]中也与\"!\"(叹号)一样表示“非”


输出/输入重导向
> >>   <   <<   :>   &>   2&>   2<>>&   >&2

文件描述符(File Descriptor)，用一个数字（通常为0-9）来表示一个文件。
常用的文件描述符如下：
文件描述符     名称     常用缩写 默认值
0        标准输入 stdin    键盘
1        标准输出 stdout     屏幕
2    标准错误输出   stderr     屏幕
我们在简单地用<或>时，相当于使用 0< 或 1>（下面会详细介绍）。
 * cmd > file
把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，使用bash的noclobber选项可以防止复盖原有文件。
 * cmd >> file
把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件後面。
 * cmd < file
使cmd命令从file读入
 * cmd << text
从命令行读取输入，直到一个与text相同的行结束。除非使用引号把输入括起来，此模式将对输入内容进行shell变量替换。如果使用<<- ，则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考後面的例子。
 * cmd <<< word
把word（而不是文件word）和後面的换行作为输入提供给cmd。
 * cmd <> file
以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。
 * cmd >| file
功能同>，但即便在设置了noclobber时也会复盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用>!实现这一功能。
: > filename    把文件\"filename\"截断为0长度.# 如果文件不存在, 那么就创建一个0长度的文件(与'touch'的效果相同).
cmd >&n 把输出送到文件描述符n
cmd m>&n 把输出 到文件符m的信息重定向到文件描述符n
cmd >&- 关闭标准输出
cmd <&n 输入来自文件描述符n
cmd m<&n m来自文件描述各个n
cmd <&- 关闭标准输入
cmd <&n- 移动输入文件描述符n而非复制它。（需要解释）
cmd >&n- 移动输出文件描述符 n而非复制它。（需要解释）
注意： >&实际上复制了文件描述符，这使得cmd > file 2>&1与cmd 2>&1 >file的效果不一样。

 http://hi.baidu.com/hellosimple/blog/item/559483f1f1c0e95e352acc89.html



 http://blog.csdn.net/mqboss/article/details/6549176

1、{} 大括号：
用法一：通配符扩展
代码:
ls my_{finger,toe}s

这条命令相当于如下命令的组合：
代码:
ls my_fingers my_toes
mkdir {userA,userB,userC}-{home,bin,data}

我们将得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data,userC-home, userC-bin, userC-data，这几个目录
用法二：可用于语句块的构造，语句之间用回车隔开。如果你想在某些使用单个语句的地方（比如在AND或OR列表中）使用多条语句，你可以把它们括在花括号{}中来构造一个语句块。
代码:
grep -v "$cdcatnum" $strack_file > $temp_file
cat $temp_file > $strack_file
echo
cat -n file1

(注：以上大括号中的四句命令够成了一个语句块)
用法三：参数扩展
代码:
${name:-default} 使用一个默认值（一般是空值）来代替那些空的或者没有赋值的变量name；
${name:=default}使用指定值来代替空的或者没有赋值的变量name；
${name:?message}如果变量为空或者未赋值，那么就会显示出错误信息并中止脚本的执行同时返回退出码1。
${#name} 给出name的长度
${name%word} 从name的尾部开始删除与word匹配的最小部分，然后返回剩余部分
${name%%word} 从name的尾部开始删除与word匹配的最长部分，然后返回剩余部分
${name#word} 从name的头部开始删除与word匹配的最小部分，然后返回剩余部分
${name##word} 从name的头部开始删除与word匹配的最长部分，然后返回剩余部分

（注，name为变量名，word为要匹配的字符串）
用法三在处理字符串和未知变量时，是很有用的。

2、[] 中括号：
用法一：通配符扩展：
允许匹配方括号中任何一个单个字符
代码:
ls /[eh][to][cm]*

相当于执行 ls /etc /home（若有/eom目录，就相当于会执行ls /etc /home /eom）
注：在mkdir命令下不能扩展
用法二：用于条件判断符号：
[]符号可理解为指向test命令的一个软链接，所以其用法可完全参照test，将test位置替换为[便可。
代码:
if [ "$?" != 0 ] 等价于 if test "$?" != 0
then echo "Executes error"


3、`command` 反引号：
`command`与$(command)的含义相同，都是返回当前执行命令的结果
代码:
#!/bin/sh
for file in $(ls f*.sh);do
    lpr $file
done
exit 0

该例实现了扩展f*.sh给出所有匹配模式的文件的名字。

4、'string' 单引号 和 "string" 双引号
双引号：如果想在定义的变量中加入空格，就必须使用单引号或双引号，
单、双引号的区别在于双引号转义特殊字符而单引号不转义特殊字符
代码:
$ heyyou=home
$ echo '$heyyou'
$ $heyyou （$没有转义）
eg: $ heyyou=home
$ echo "$heyyou"
$ home （很明显，$转义了输出了heyyou变量的值）


5、$# 它的作用是告诉你引用变量的总数量是多少；
代码:
$$ 它的作用是告诉你shell脚本的进程号；
$* 以一个单字符串显示所有的脚本传递的参数。等价于$1 $2 $3.......；
$@ 与$*基本类似（参见序号7），但在数组赋值时有些不同；
$? 前一个命令的退出码；
$- 显示shell使用的当前选项；
$! 最后一个后台运行的进程ID号。


6、$((...))语法：对括号内的表达式求值
代码:
#!/bin/sh
x=0
hile [ "$x" -ne 10 ];do
echo $x
x=$(($x+1))
done
exit 0


7、shell中几种特殊的参数变量的引用
代码:
$1、$2、$3……${10}、${11}、${12}…… ：表示脚本传入的的各个参数，注意当需表示两位数以后的参数时数字要用花括号括起。
$@ 列出所有的参数，各参数用空格隔开
$*: 列出所有的参数，各参数用环境变量IFS的第一个字符隔开


8、命令列表：
AND列表 statement1 && statement2 && statement3 && …:只有在前面所有的命令都执行成功的情况下才执行后一条命令
OR列表 statement1 || statement2 || statement3 || …:允许执行一系列命令直到有一条命令成功为止，其后所有命令将不再被执行
#!/bin/sh
代码:
touch file_one
rm -f file_two
if [ -f file_one ] && echo "hello" && [ -f file_two ] && echo " there"
then
echo "in if"
else
echo "in else"
fi
exit 0

上例的输出为：
代码:
hello
in else

关于AND列表与OR列表，在逻辑判断中很使用，下面就举一个其最常用的例子：
代码:
[ condition ] && command for true || command for false:

当条件为真时，执行commandfor true ,当条件为假时，执行command for false

9、: 冒号：内建空指令，返回值为0
代码:
$ :
$ echo $?
$ 0
while: (该语句结构可实现一个无限循环)


10、; 分号: 在 shell 中，担任"连续指令"功能的符号就是"分号"
代码:
cd ~/backup ; mkdir startup ; cp ~/.* startup/.


11、# 井号：表示符号后面的是注解文字，不会被执行；
代码:
 * 匹配文件名中的任何字符，包括字符串；
？ 匹配文件名中的任何单个字符。
~ 代表使用者的 home 目录


12、/ 倒斜线：
放在指令前，有取消 aliases（别名） 的作用；
放在特殊符号前，则该特殊符号的作用消失；
放在指令的最末端，表示指令连接下一行（使得回车符无效，只起换行作用）

13、! 感叹号：
通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表"不等于"

14、** 次方运算：两个星号在运算时代表 "次方" 的意思
代码:
let "sus=2**3"
ech

** 函数
*** [[http://www.cnblogs.com/xiangzi888/archive/2012/03/27/2420188.html][bash函数使用]]                                                     :blog:

一、bash函数定义及调用

在写c语言的时候，我们使用字符串数组存储命令行参数（argv[]）。同样，在编写Bash脚本的时候，也使用命令行参数。在Bash函数中也可以使用参数，特殊的是，Bash中的函数是没有参数列表的，例如

#+BEGIN_EXAMPLE
    #定义foo() {    statements}#调用foo
#+END_EXAMPLE

这样便完成了一个函数的定义，但是没有任何的形参名称，这是由于Bash中特殊的参数传递方法所致。



二、传参（命令行参数）

当一个函数被调用时，脚本程序的位置参数（$* $@ $#参数个数 $1 $2
$?上一条独立命令运行结果 ）等会被替换为函数的参数。



三、返回值

通常情况下Bash的函数是很少需要返回值的，但是有的时候需要，比如确定一个函数是否被成功执行，然后确定下一步的动作。这样的逻辑必须得到Bash函数的返回值，用以表示函数执行的状态。

#+BEGIN_EXAMPLE
    #!/bin/bash foo(){    echo Jay}result="$(foo)"                  echo $resultexit 0
#+END_EXAMPLE

也可用 return 关键字：

#+BEGIN_EXAMPLE
    #!/bin/bash yesorno(){    echo "is your name $*? "    while true    do        read -p "Enter yes or no: " x        case $x in　　　            y|Y )                return 0;;            n|N )                return 1;;            *   )                echo "answer yes or no"        esac    done }echo "original parameters are $*"if yesorno "$1"then    echo "Hi $1, nice name"else    echo "Never mind"fiexit 0
#+END_EXAMPLE

如果没有在一个函数内使用return命令指定一个返回值，函数返回的就是执行的最后一条命令的推出码。



四、其他

必须在调用一个函数之前先对他进行定义。

可以用 /local /关键字在shell函数中声明局部变量。

** 输入输出
*** read                                                               :read:
**** [[http://www.cnblogs.com/xiangzi888/archive/2012/03/27/2420084.html][bash之read命令]]                                                 :blog:

一、概述

read命令接收标准输入（键盘）的输入，或者其他文件描述符的输入。得到输入后，read命令将数据放入一个标准变量中。

二、使用举例(这里仅列出一些常用的选项)

*基本读取*

#+BEGIN_EXAMPLE
    #!/bin/bash echo -n "Enter your name:"           #参数-n的作用是不换行，echo默认是换行 read  name                           #从键盘输入 echo "hello $name, welcome to my program"   exit 0                               #退出shell程序。
#+END_EXAMPLE

其等效于以下：

#+BEGIN_EXAMPLE
    read -p "Enter your name:" name       #-p参数，允许在read命令行中直接指定一个提示
#+END_EXAMPLE

在上面read后面的变量只有name一个，也可以有多个，这时如果输入多个数据，
则第一个数据给第一个变量，第二个数据给第二个变量。如果输入数据个数过多，
则最后剩下的所有值都给最后一个变量，如果太少输入不会结束。


*在read命令行中也可以不指定变量*

如果不指定变量，那么read命令会将接收到的数据放置在环境变量REPLY中

#+BEGIN_EXAMPLE
    read -p "Enter a number" echo $REPLY
#+END_EXAMPLE


*计时输入*

使用read命令存在着潜在危险。脚本很可能会停下来一直等待用户的输入。如果无论是否输入数据脚本都必须继续执行，那么可以使用
/-t/
选项指定一个计时器，指定read命令等待输入的秒数。当计时满时，read命令返回非零值（0为正常退出状态）;

#+BEGIN_EXAMPLE
    #!/bin/bash if read -t 5 -p "please enter your name:" name then     echo "hello $name, welcome to my script" else     echo "sorry,too slow" fi exit 0
#+END_EXAMPLE


*设置计数输入的字符*

当输入的字符数目达到预定数目时，自动退出，并将输入的数据赋值给变量。

#+BEGIN_EXAMPLE
    #!/bin/bash read -n1 -p "Do you want to continue [Y/N]? " answer case $answer in Y|y)     echo "fine ,continue";; N|n)     echo "ok,good bye";; *)     echo "error choice";; esacexit 0
#+END_EXAMPLE

该例子使用了-n选项，后接数值1，指示read命令只要接受到一个字符就退出。只要按下一个字符进行回答，read命令立即接受输入并将其传给变量。无需按回车键。


*默读（输入不显示在监视器上）*

有时不希望输入的数据显示在监视器上。典型的例子就是输入密码，当然还有很多其他需要隐藏的数据。/-s/
选项能够使read命令中输入的数据不显示在监视器上（实际上，数据是显示的，只是read命令将文本颜色设置成与背景相同的颜色）。

#+BEGIN_EXAMPLE
    #!/bin/bash read  -s  -p "Enter your password: " pass echo "your password is $pass" exit 0
#+END_EXAMPLE



*读文件*

每次调用read命令都会读取文件中的"一行"文本。当文件没有可读的行时，read
命令将以非零状态退出。读取文件的关键是如何将文本中的数据传送给read命令。
最常用的方法是对文件使用cat命令并通过管道将结果直接传送给包含read命令
的while命令。


#+BEGIN_EXAMPLE
    #!/bin/bash count=1cat dat| while read line        #cat 命令的输出作为read命令的输入,read读到的值放在line中 do    echo "$count:$line"    count=$(($count + 1))doneexit 0
#+END_EXAMPLE

** Debug
*** 专用调试器 *bashdb*                                      :debug:bashdb:
+ homepage: http://bashdb.sourceforge.net/


the bash debugger project is a source-code debugger for bash that
follows the gdb command syntax.

1. name
   + bashdb - bash debugger script

2. synopsis
   + bashdb [options] [--] script-name [script options]
   + bashdb [options] -c execution-string
   + bash --debugger [bash-options...] script-name [script options]

3. install
   1) apt
      #+begin_src sh :exports both
      apt-cache search bashdb
      #+end_src

      #+results:
      : bashdb - bash debugger

   2) sourcecode
      + https://sourceforge.net/projects/bashdb/files/bashdb/

*** 调试
**** -x 选项

可以让bash打印出你脚本执行的过程中的所有语句

#+header: :exports code
#+header: :tangle /tmp/bash_debug.sh
#+BEGIN_SRC sh
  #!/bin/bash
  echo "Hello $USER"
  echo "Today is $(date +'%Y-%m-%d')"
#+END_SRC

#+BEGIN_SRC sh :exports code :results output
bash -x /tmp/bash_debug.sh
#+END_SRC

#+BEGIN_EXAMPLE
  + echo 'Hello ben'
  Hello ben
  ++ date +%Y-%m-%d
  + echo 'Today is 2015-04-30'
  Today is 2015-04-30
#+END_EXAMPLE

**** 显示行号
修改变量： *PS4*
#+BEGIN_SRC sh exports code
export PS4='+${BASH_SOURCE}:${LINENO}:${FUNCNAME[0]}: '
bash -x /tmp/bash_debug.sh
#+END_SRC

#+BEGIN_EXAMPLE
+/tmp/bash_debug.sh:3:main: echo 'Hello ben'
Hello ben
++/tmp/bash_debug.sh:4:main: date +%Y-%m-%d
+/tmp/bash_debug.sh:4:main: echo 'Today is 2015-04-30'
Today is 2015-04-30
#+END_EXAMPLE

**** 调试部分脚本
+ 开始： set -x
+ 结束： set +x

#+BEGIN_SRC sh :tangle /tmp/bash_debug.sh
  #!/bin/bash
  echo "helle ${USER}"
  set -x
  echo "Today is $(date +%Y-%m-%d)"
  set +x
#+END_SRC

#+BEGIN_EXAMPLE
  bash /tmp/bash_setup.sh

  helle ben
  ++/tmp/bash_debug.sh:5:main: date +%Y-%m-%d
  +/tmp/bash_debug.sh:5:main: echo 'Today is 2015-04-30'
  Today is 2015-04-30
  +/tmp/bash_debug.sh:6:main: set +x
#+END_EXAMPLE

*** [[http://bashdb.sourceforge.net/bashdb-man.html][bash debugger script]] :man:

**** NAME

bashdb - bash debugger script

--------------

**** SYNOPSIS

*bashdb* [/options/] [--] /script-name/ [/script options/]

*bashdb* [/options/] -c /execution-string/

*bash --debugger* [/bash-options/...] /script-name/ [/script options/]

--------------

**** DESCRIPTION

=bashdb= is a bash script to which arranges for another bash script to
be debugged.

The debugger has a similar command interface as
[[http://sourceware.org/gdb/current/onlinedocs/gdb_toc.html][gdb]].

The way this script arranges debugging to occur is by including (or
actually "source"-ing) some debug-support code and then sourcing the
given script or command string.

One problem with sourcing a debugged script is that the program name
stored in $0 will be =bashdb= rather than the name of the script to be
debugged. The debugged script will appear in a call stack not as the top
item but as the item below =bashdb=. If this is of concern, use the last
form given above, =bash --debugger= /script-name/ [/script-options/].

If you used bashdb script and need to pass options to the script to be
debugged, add =--= before the script name. That will tell bashdb not to
try to process any further options.

See the reference manual [[http://bashdb.sourceforge.net/bashdb.html]]
for how to to call the debugger from inside your program or arrange for
the debugger to get called when your program is sent a signal.

--------------

**** OPTIONS

- *-h | --help* :: Print a usage message on standard error and exit
   with a return code of 100.

- *-A | --annotation /level/* :: Sets to output additional stack and
   status information which allows front-ends such as emacs to track
   what's going on without polling.

   This is needed in for regression testing. Using this option is
   equivalent to issuing:

   #+BEGIN_EXAMPLE
         set annotation LEVEL
   #+END_EXAMPLE

   inside the debugger.

- *-B | --basename* :: In places where a filename appears in debugger
   output give just the basename only. This is needed in for regression
   testing. Using this option is equivalent to issuing:

   #+BEGIN_EXAMPLE
         set basename on
   #+END_EXAMPLE

   inside the debugger.

- *-n | nx* :: Normally the debugger will read debugger commands in
   =~/.bashdbinit= if that file exists before accepting user
   interaction. =.bashdbinit= is analogus to Perl's =.perldb= or GNU
   gdb's =.gdbinit=: a user might want to create such a debugger profile
   to add various user-specific customizations.

   Using the =-n= option this initialization file will not be read. This
   is useful in regression testing or in tracking down a problem with
   one's =.bashdbinit= profile.

- *-c /command-string/* :: Instead of specifying the name of a script
   file, one can give an execution string that is to be debugged. Use
   this option to do that.

   If you invoke the debugger via =bash --debugger=, the filename that
   will appear in source listing or in a call stack trace will be the
   artifical name *BOGUS*.

- *-q | --quiet* :: Do not print introductory version and copyright
   information. This is again useful in regression testing where we
   don't want to include a changeable copyright date in the
   regression-test matching.

- *-x /debugger-cmdfile/* :: Run the debugger commands
   /debugger-cmdfile/ before accepting user input. These commands are
   read however after any =.bashdbinit= commands. Again this is useful
   running regression-testing debug scripts.

- *-L | --library /debugger-library/* :: The debugger needs to source
   or include a number of functions and these reside in a library. If
   this option is not given the default location of library is relative
   to the installed bashdb script: =../lib/bashdb=.

- *-T | --tempdir /temporary-file-directory/* :: The debugger needs to
   make use of some temporary filesystem storage to save persistent
   information across a subshell return or in order to evaluate an
   expression. The default directory is =/tmp= but you can use this
   option to set the directory where debugger temporary files will be
   created.

- *-t | --tty /tty-name/* :: Debugger output usually goes to a terminal
   rather than stdout or stdin which the debugged program may use.
   Determination of the tty or pseudo-tty is normally done
   automatically. However if you want to control where the debugger
   output goes, use this option.

- *-V | --version* :: Show version number and no-warranty and exit with
   return code 1.

- *-X | --trace* :: Similar to "=set -x=" line tracing except that by
   default the location of each line, the bash level, and subshell level
   are printed. You might be able to get something roughly similar if
   you set =PS4= as follows

   #+BEGIN_EXAMPLE
           export PS4='(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]}\n'
   #+END_EXAMPLE

   In contrast however to "=set -x=" tracing, indentation of the
   original program is also preserved in the source output. And if you
   interrupt the program with a break (a =SIGINT= signal), you will go
   into the debugger (assuming your program doesn't trap =SIGINT=).

--------------

**** BUGS

The =bashdb= script and =--debugger= option assume a version of bash
with debugging support. That is you can't debug bash scripts using the
standard-issue version 2.05b bash or earlier versions. In versions after
3.0, debugging should have been enabled when bash was built. (I think
this is usually the case though.) If you try to run the bashdb script on
such as shell, may get the message:

#+BEGIN_EXAMPLE
      Sorry, you need to use a debugger-enabled version of bash.
#+END_EXAMPLE

Debugging startup time can be slow especially on large bash scripts.
Scripts created by GNU autoconf are at thousands of lines line and it is
not uncommon for them to be tens of thousands of lines.

There is a provision to address this problem by including a fast
file-to-array read routine (readarray), but the bashdb package has to be
compiled in a special way which needs access to the bash source code and
objects.

Another reason of the debugger slowness is that the debugger has to
intercept every line and check to see if some action is to be taken for
this and this is all in bash code. A better and faster architecture
would be for the debugger to register a list of conditions or stopping
places inside the bash code itself and have it arrange to call the
debugger only when a condition requiring the debugger arises. Checks
would be faster as this would be done in C code and access to internal
structures would make this more efficient.

** 结构语句
*** if-else                                                            :if:
**** if-else

if/else是通过判断选择执行或者执行部分代码，可以根据变量、文件名、命令
是否执行成功等很多条件进行判断，他的格式如下：

#+BEGIN_EXAMPLE
  if condition
  then
      statements
  [elif condition
      then statements. ..]
  [else
      statements ]
  fi
#+END_EXAMPLE

和C程序不一样， _bash的判断不是通过boolean，而是通过statement，也就是
执行命令后的最终状态（exit status）_ 。所有的Linux命令，无论你是代码是C还
是脚本，执行完，都返回一个整数通知他的调用这，这就是exit status，通常0
表示OK，其他（1-255）表示错误。这只是通常的情况，例如diff，0表示你no
difference，1表示difference，2表示错误。if判断statements的最后一个的
exit status，通常我们只放一个statement，如果为0，表示true，否则表示
false。

执行下一条命令会冲掉原来exit status。可以使用$?来查看上一命令执行的结
果。

**** reference

- http://blog.csdn.net/flowingflying/article/details/5069646

**** [[http://blog.csdn.net/flowingflying/article/details/5069646][Linux Bash Shell学习（九）：流程控制------if/else]]                 :blog:

本文也即《Learning the bash Shell》3rd Edition的第五章Flow
Control之读书笔记，但我们将不限于此。flow
control是任何编程语言中很常用的部分，也包括了bash。在这里，我们将学习他们。

if/else是通过判断选择执行或者执行部分代码，可以根据变量、文件名、命令是否执行成功等很多条件进行判断，他的格式如下：

#+BEGIN_QUOTE
  *if* /condition/
   *then*
     /statements/
   [*elif* /condition/
     *then* /statements./ ..]
   [*else*
     /statements/ ]
   *fi*
#+END_QUOTE

和
C程序不一样，bash的判断不是通过boolean，而是通过statement，也就是执行命令后的最终状态（exit
status）。所有的Linux命令，无论你是代码是C还是脚本，执行完，都返回一个整数通知他的调用这，这就是exit
status，通常0表示OK，其他（1-255）表示错误。这只是通常的情况，例如diff，0表示你no
difference，1表示difference，2表示错误。if判断statements的最后一个的exit
status，通常我们只放一个statement，如果为0，表示true，否则表示false。

执行下一条命令会冲掉原来exit
status。可以使用$?来查看上一命令执行的结果。例如我们希望用一个新的cd命令来替代原来在linux
kernel中已将编译的cd命令，由于function是优先于built-in命令，所以调用时，将调用我们的function。下面有一个例子，function
pushd，在stack中键入cd的dirname路径名，并执行跳到该路径下。

#+BEGIN_QUOTE
  cd ( )
   {

  #由于我们已经定义了具有更高优先级别的function，如果希望调用原来built-in的命令，需要再前面加上builtin。
     *builtin* cd "$@"
     #$?是上一command的返回值，即builtin cd
  "$@"的值，并记录在result里面。
     result=*$?
  *   echo "$OLDPWD --> $PWD"

  #返回result的值。我们需要注意shell中的返回和在其他程序，例如C语言中的返回是不一样的，只代表最后的exit
  statue，而不是所谓的返回值，虽然也用到了return。如何没有最后的reture，例如后面的push_func，exit
  status就是最后执行的command的exit status
     *return*   $result
   }

  push_func( )
   {
     dirname=$1
     #如果dirname为null，退出funcuntion，如cd dirname成功，push the
  directory ，否则显示still in
  $PWD，cd使用function的cd函数，其优先级别高于已在内核编译了的cd
     *if* cd ${dirname:?"missing directory name."}
     *then
  *   mystack="$dirname ${mystack:-$OLDPWD }"
     echo $mystack
     *else*
     echo still in $PWD.
     *fi
  * }

  push_func $1
#+END_QUOTE

/*条件结合*/

和C语言一样，可以进行条件结合，使用&&，||，以及！三种方式，表示“和”，“或”，与”非“，格式如下：if
/statement1/ *&&* /statement2，/ if /statement1/ *||* /statement2/ ，if
*！* /statement1/ 。

exit status不是判断的唯一值，可以使用[...]和[[...]]。

/*字符串比较*/

字符串比较是放置在[...]中，有以下的几种：

- str1 = str2，字符串1匹配字符串2
- str1 != str2，字符串1不匹配字符串2
- str1 > str2，字符串1大于字符串2
- str1 < str2，字符串1小于字符串2
- -n str，字符串不为null，长度大于零
- -z str，字符串为null，长度为零

*需要注意<和>符号和重定向符号相似，为了避免歧义和错误，使用if [ /$a/
/> /$b/ ] 的方式* 。仍然上面的例子，我们增加pop_func来操作stack:

#+BEGIN_QUOTE
    pop_func()
      {
       mystack=${mystack#* }
       #下面请至于[ ...
  ]，即[后面有一个空格，]前面有一空格，另外$mystack用双引号，表示这代表的是一个字符串。注意到then不放在下一行，与if放在用一行，用;来隔开。
       if *[ -n "$mystack" ];* then
       cd ${mystack%% *}
       echo "$PWD", stack is [$mystack]
       else
     echo "stack empty, still in $PWD."
     fi
      }
#+END_QUOTE

例如，我们要求命令带有参数，除了使用{1?"<message"}以外，下面给出更可读的方式：

#+BEGIN_QUOTE
  if [ -z "$1" ]; then
     echo 'usage: c filename [-N]'
     *exit* 1
   fi
#+END_QUOTE

在这里exit表示结束，退出，执行的结果为失败，非零。

/*文件属性比较*/

文件属性比较是另一个常用的条件判断类型。

- *-a*   /file/ ：file 存在
- *-d* /file/ ：file存在并是一个目录
- *-e* /file/ ：file 存在，同- a
- *-f* /file/ ：file
   存在并且是一个常规的文件（不是目录或者其他特殊类型文件）
- *-r* /file/ ：有读的权限
- *-s* /file/ ：文件存在且不为空
- *-w* /file/ ：有写的权限
- *-x* /file/ ：有执行的权限，或者对于目录有search的权限
- *-N* /file/ ：在上次读取后，文件有改动
- *-O* /file/ ：own所属的文件
- *-G* /file/ ：group所属的文件
- /file1/ *// -nt* /file2/ ：file1 比 file2 更新，以最后更新时间为准
- /file1/ *-ot* /file2/ ：file1 比 file2 更旧 ，以最后更新时间为准

这些在[ ... ]中的条件判断是可以多个结合起来，例如if [ condition ] &&
[ condition ]; then，当然也可以if command && [ condition ];
then，不在类推。尤其我们可以进行复制的条件判断。另外还可以使用*-a*
和*-o*
，等同于C语言中的&和|的逻辑计算复符号，他们和&&即||相似。当他们用在condition里面。

在上面push_func的例子中，除了判断是否参数之外，增加判断是否是目录名，如下：

#+BEGIN_QUOTE
    if *[ -n "$dirname" ] &&[ -d "$dirname" ]*
     then
     cd $dirname
     mystack="$dirname ${mystack:-$OLDPWD }"
     echo $mystack
     else
     echo still in $PWD.
     fi
#+END_QUOTE

我们在增加一个判断，当时目录名的时候，在检查是否可以进行查看或操作。使用if
[ -n "$dirname" ] &&[ *-d "$dirname" -a -x "$dirname"*
]，但是这种写法很难阅读，我们需要将两个前后判断括起来，( -d "$dirname" )
-a ( -x "$dirname" )。但是（是个特殊符合，需使用/(的方式，即为：if [ -n
"$dirname" ] &&*[ /( -d "$dirname" /) -a /( -x "$dirname" /) ]* 。

/*整数比较*/

>或者<或者=是用于字符串的比较，如果用于整数比较，使用：

- -lt，小于
- -le，小于等于
- -eq，等于
- -ge，大于等于
- -gt，大于
- -ne，不等于

*** for                                                               :for:
**** [[http://lovelace.blog.51cto.com/1028430/1211373][shell 学习之for语句]]                                            :blog:

一、for语法
for 变量 in 列表；do
    循环体
done
二、常见用法
1、for用来遍历目录

1
2
3
4
5
6
7
8
9
10
#!/bin/bash
#Version:0.1
#Author:lovelace
#pragram:This scripts is print all files in directory
#difine an varibale
DIR="/home/scripts/51cto"
#All files in directory traversal
for f in $(ls $DIR);do
echo $f
done

输出结果为：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
[root@lovelace for]# ./dir.sh
1.sh
2curl.sh
adduer.sh
aliquot.sh
argument.sh
argusum.sh
curl.sh
dd.sh
dirper.sh
info.sh
info.tt
ipcheck.sh
jugement.sh
netcard.sh
sum.sh
test.sh
The
Frist
week
The
Third
week

2、for ((初始条件;终止条件;异动项））
do
   命令区域
done

1
2
3
4
5
6
7
8
9
10
11
12
#!/bin/bash
#Version:0.1
#Author:lovelace
#pragram:This pragram is and the sum from 1 to 100
#define an integer
declare -i i
#loops
for ((i=1;i<=10;i=i+1))
do
let sum+=1
done
echo "The result is:" $sum

输出结果为：
1
2
[root@lovelace for]# ./sorsum.sh
The result is: 10
3、for 无穷循环
    for ((;1;));do
      命令区域
     done


1
2
3
4
5
[root@lovelace for]# cat forover.sh
#!/bin/bash
for ((;1;));do
echo "forever..."
done
输出结果：
1
2
3
4
5
6
7
8
[root@lovelace for]# ./forover.sh
forever...
forever...
forever...
forever...
forever...
forever...
forever...
三、关于break和continue

break、continue 一样可以运用在for while until select这4中循环中，
break :退出循环  提前退出
continue:提前进入下一轮循环 ,continue后面的语句将不再执行
示例（计算1到100内能被3整除的数之和）：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
#!/bin/bash
#Verson:0.1
#Auther:lovelace
#Pragram:This pragram is calculation from 1 to 100 aliquot 3 sum
#
declare -i i=0
declare -i sum=0
#use loop traverse from 1 to 100
while [ $i -lt 100 ];do
let i++
#jugement aliqotu 3 or not
if [ $(($i%3))  -eq 0 ];then
let sum+=i
else
continue
fi
done
#print sum
echo "from 1 to 100 aliquot 3 sum is $sum"
输出结果为：
1
2
[root@lovelace for]# ./three.sh
from 1 to 100 aliquot 3 sum is 1683
四、再次重提如何生成列表
如何生成列表：
1、整数列表
     {1..100}  生存1到100的列表
2、seq
    seq 10 1到10
    seq 5 10 5到10
    seq 5 10 2 返回列表为6 8 10
3、`ls /etc`

生成列表不单单只有我们列出的这些，实际案例上需要灵活运用
示例：（分别显示当前系统上所有默认shell中为bash的用户和默认为nologin的用户）
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
[root@lovelace for]# cat checkbash.sh
#!/bin/bash
#Version:0.1
#Author:lovelace
#pragram:This scripts is check user bash and print it
#取出使用bash的用户个数
bashline=`grep 'bash$' /etc/passwd | wc -l`
#取出使用nologin的用户个数
nologinline=`grep 'nologin$' /etc/passwd | wc -l`
#取出bash用户列表
bashuser=`grep 'bash$' /etc/passwd | cut -d: -f1`
#取出nologin用户列表
nologin=`grep 'nologin$' /etc/passwd | cut -d: -f1`
#遍历使用bash的用户并打印出来
for x in  $bashuser;do
echo "bash users is:$x"
done
#遍历使用nologin的用户并打印出来
for y in  $nologin;do
echo "nologin users is:$y"
done
#结果如下
[root@lovelace for]# ./checkbash.sh
bash users is:root
bash users is:nick
bash users is:kale
bash users is:user2
bash users is:user3
bash users is:user4
bash users is:user5
bash users is:user6
bash users is:user7
bash users is:user8
bash users is:user9
bash users is:user10
bash users is:mark
bash users is:lovelace
bash users is:lovetest
nologin users is:bin
nologin users is:daemon
nologin users is:adm
nologin users is:lp
nologin users is:mail
nologin users is:uucp
nologin users is:operator
nologin users is:games
nologin users is:gopher
nologin users is:ftp
nologin users is:nobody
nologin users is:nscd
nologin users is:vcsa
nologin users is:pcap
nologin users is:ntp
nologin users is:dbus
nologin users is:avahi
nologin users is:rpc
nologin users is:mailnull
nologin users is:smmsp
nologin users is:sshd
nologin users is:oprofile
nologin users is:rpcuser
nologin users is:nfsnobody
nologin users is:xfs
nologin users is:haldaemon
nologin users is:avahi-autoipd
nologin users is:gdm
nologin users is:sabayon
nologin users is:jack

*** case语句                                                           :case:

bash 中的 switch-case 语句。

**** 语法

#+BEGIN_SRC sh
  case EXPRESSION in
  CASE1) COMMAND-LIST;;
  CASE2) COMMAND-LIST;;
  ...
  CASEN) COMMAND-LIST;;
  esac
#+END_SRC

- 每个分支是一个符合 /pattern/ 的表达式。
- 在 COMMAND-LIST 中首先符合的的命令就执行。
- /“|”/ 符号用来分割多个pattern，
- /“)”/ 操作符中断一个pattern。
- 每个分支加上他们的后继命令称作一个 子句 。每个 子句 必须以 /“;;”/ 结尾。
- 每个 case 语句以 /esac/ 语句结束。


**** 例子

#+BEGIN_SRC sh
  #!/bin/bash

  # This script does a very simple test for checking disk space.

  space=`df -h | awk '{print $5}' | grep % | grep -v Use | sort -n | tail -1 | cut -d "%" -f1 -`

  case $space in
  [1-6]*)
    Message="All is quiet."
    ;;
  [7-8]*)
    Message="Start thinking about cleaning out some stuff.  There's a partition that is $space % full."
    ;;
  9[1-8])
    Message="Better hurry with that new disk...  One partition is $space % full."
    ;;
  99)
    Message="I'm drowning here!  There's a partition at $space %!"
    ;;
  ,,*)
    Message="I seem to be running with an nonexitent amount of disk space..."
    ;;
  esac

  echo $Message | mail -s "disk report `date`" anny
#+END_SRC


- 初始脚本通常利用 case 语句来启动，停止和查询系统服务


** 字符串
*** [[http://www.cnblogs.com/frydsh/p/3261012.html][Bash Shell字符串操作小结]]                                    :blog:

1. 取长度

   #+BEGIN_EXAMPLE
       str="abcd"
       expr length $str   # 4
       echo ${#str}       # 4
       expr "$str" : ".*" # 4
   #+END_EXAMPLE

   好像一般使用第二种

2. 查找子串的位置

   #+BEGIN_EXAMPLE
       str="abc"
       expr index $str "a"  # 1
       expr index $str "b"  # 2
       expr index $str "x"  # 0
       expr index $str ""   # 0
   #+END_EXAMPLE

3. 选取子串

   #+BEGIN_EXAMPLE
       str="abcdef"
       expr substr "$str" 1 3  # 从第一个位置开始取3个字符， abc
       expr substr "$str" 2 5  # 从第二个位置开始取5个字符， bcdef
       expr substr "$str" 4 5  # 从第四个位置开始取5个字符， def

       echo ${str:2}           # 从第二个位置开始提取字符串， bcdef
       echo ${str:2:3}         # 从第二个位置开始提取3个字符, bcd
       echo ${str:(-6):5}        # 从倒数第二个位置向左提取字符串, abcde
       echo ${str:(-4):3}      # 从倒数第二个位置向左提取6个字符, cde
   #+END_EXAMPLE

4. 截取子串

   #+BEGIN_EXAMPLE
       str="abbc,def,ghi,abcjkl"
       echo ${str#a*c}     # 输出,def,ghi,abcjkl  一个井号(#) 表示从左边截取掉最短的匹配 (这里把abbc字串去掉）
       echo ${str##a*c}    # 输出jkl，             两个井号(##) 表示从左边截取掉最长的匹配 (这里把abbc,def,ghi,abc字串去掉)
       echo ${str#"a*c"}   # 输出abbc,def,ghi,abcjkl 因为str中没有"a*c"子串
       echo ${str##"a*c"}  # 输出abbc,def,ghi,abcjkl 同理
       echo ${str#*a*c*}   # 空
       echo ${str##*a*c*}  # 空
       echo ${str#d*f)     # 输出abbc,def,ghi,abcjkl,
       echo ${str#*d*f}    # 输出,ghi,abcjkl

       echo ${str%a*l}     # abbc,def,ghi  一个百分号(%)表示从右边截取最短的匹配
       echo ${str%%b*l}    # a             两个百分号表示(%%)表示从右边截取最长的匹配
       echo ${str%a*c}     # abbc,def,ghi,abcjkl
   #+END_EXAMPLE

   可以这样记忆,井号（#）通常用于表示一个数字，它是放在前面的；百分号（%）
   卸载数字的后面;
   或者这样记忆，在键盘布局中，井号(#)总是位于百分号（%）的左边(即前面)

5. 字符串替换

   #+BEGIN_EXAMPLE
       str="apple, tree, apple tree"
       echo ${str/apple/APPLE}   # 替换第一次出现的apple
       echo ${str//apple/APPLE}  # 替换所有apple

       echo ${str/#apple/APPLE}  # 如果字符串str以apple开头，则用APPLE替换它
       echo ${str/%apple/APPLE}  # 如果字符串str以apple结尾，则用APPLE替换它
   #+END_EXAMPLE

6. 比较

   #+BEGIN_EXAMPLE
       [[ "a.txt" == a* ]]        # 逻辑真 (pattern matching)
       [[ "a.txt" =~ .*\.txt ]]   # 逻辑真 (regex matching)
       [[ "abc" == "abc" ]]       # 逻辑真 (string comparision)
       [[ "11" < "2" ]]           # 逻辑真 (string comparision), 按ascii值比较
   #+END_EXAMPLE

7. 连接

   #+BEGIN_EXAMPLE
       s1="hello"
       s2="world"
       echo ${s1}${s2}   # 当然这样写 $s1$s2 也行，但最好加上大括号
   #+END_EXAMPLE

8. 翻转

*** 取长度

#+BEGIN_SRC sh
  str="abcd"
  expr length $str   # method 1
  echo ${#str}       # method 2
  expr "$str" : ".*" # method 3
#+END_SRC

#+RESULTS:
| 4 |
| 4 |
| 4 |

好像一般使用第二种

*** 子串长度

#+BEGIN_SRC sh
  str="abc"
  expr index $str "a"  # 1
  expr index $str "b"  # 2
  expr index $str "x"  # 0
  expr index $str ""   # 0
#+END_SRC

#+RESULTS:

*** 选取子串

#+BEGIN_SRC sh :exports code
  str="abcdef"
  expr substr "$str" 1 3  # 从第一个位置开始取3个字符， abc
  expr substr "$str" 2 5  # 从第二个位置开始取5个字符， bcdef
  expr substr "$str" 4 5  # 从第四个位置开始取5个字符， def

  echo ${str:2}           # 从第二个位置开始提取字符串， bcdef
  echo ${str:2:3}         # 从第二个位置开始提取3个字符, bcd
  echo ${str:(-6):5}        # 从倒数第二个位置向左提取字符串, abcde
  echo ${str:(-4):3}      # 从倒数第二个位置向左提取6个字符, cde
#+END_SRC

#+RESULTS:
| abc   |
| bcdef |
| def   |
| cdef  |
| cde   |
| abcde |
| cde   |

*** 截取/删除子串

#+BEGIN_SRC sh :exports code
  str="abbc,def,ghi,abcjkl"
  echo ${str#a*c}     # 输出,def,ghi,abcjkl  一个井号(#) 表示从左边截取掉最短的匹配 (这里把abbc字串去掉）
  echo ${str##a*c}    # 输出jkl，             两个井号(##) 表示从左边截取掉最长的匹配 (这里把abbc,def,ghi,abc字串去掉)
  echo ${str#"a*c"}   # 输出abbc,def,ghi,abcjkl 因为str中没有"a*c"子串
  echo ${str##"a*c"}  # 输出abbc,def,ghi,abcjkl 同理
  echo ${str#*a*c*}   # 空
  echo ${str##*a*c*}  # 空
  echo ${str#d*f)     # 输出abbc,def,ghi,abcjkl,
  echo ${str#*d*f}    # 输出,ghi,abcjkl

  echo ${str%a*l}     # abbc,def,ghi  一个百分号(%)表示从右边截取最短的匹配
  echo ${str%%b*l}    # a             两个百分号表示(%%)表示从右边截取最长的匹配
  echo ${str%a*c}     # abbc,def,ghi,abcjkl
#+END_SRC

可以这样记忆, 井号（#）通常用于表示一个数字，它是放在前面的；百分
号（%）卸载数字的后面; 或者这样记忆，在键盘布局中，井号(#)总是位于
百分号（%）的左边(即前面)    :-)

*** 串匹配与替换

#+BEGIN_SRC sh :exports code
  str="apple, tree, apple tree"
  echo ${str/apple/APPLE}   # 替换第一次出现的apple
  echo ${str//apple/APPLE}  # 替换所有apple

  echo ${str/#apple/APPLE}  # 如果字符串str以apple开头，则用APPLE替换它
  echo ${str/%apple/APPLE}  # 如果字符串str以apple结尾，则用APPLE替换它
#+END_SRC

*** 比较

#+BEGIN_SRC sh :exports code
  [[ "a.txt" == a* ]]        # 逻辑真 (pattern matching)
  [[ "a.txt" =~ .*\.txt ]]   # 逻辑真 (regex matching)
  [[ "abc" == "abc" ]]       # 逻辑真 (string comparision)
  [[ "11" < "2" ]]           # 逻辑真 (string comparision), 按ascii值比较
#+END_SRC

*** 连接

#+BEGIN_SRC sh :exports code
  s1="hello"
  s2="world"
  echo ${s1}${s2}   # 当然这样写 $s1$s2 也行，但最好加上大括号
#+END_SRC

*** 命令行环境变量
+ http://www.blogbus.com/fbirdzp-logs/37423250.html
+ http://m.blog.csdn.net/blog/u012485637/43668549

通过设置环境变量PS1、PS2、PS3以及PS4来自定义用户命令行的字符显示。如果
要长期永久性修改提示符，可以将修改提示符的命令添加到$HOME/.profile或
$HOME/.bash_profile 或 ￥HOME/.bashrc文件中。

default value:
+ $PS1: =\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$=
+ $PS2: =>=
+ $PS3: None
+ $PS4: =+=

**** PS1 默认提示符
+
  http://www.linuxnix.com/2013/04/linuxunix-shell-ps1-prompt-explained-in-detail.html

可以通过修改Linux下的默认提示符，使其更加实用。
+ =\u=: 用户名
+ =\h=: 主机名
+ =\w=: 当前目录的完整路径
  - 主目录下的时候，只会显示～
+ 在PS1值之后有一个空格。从个人角度来讲，使用这个空格可以增加一定的可
  读性。

+ =\d= – the date in "Weekday Month Date" format (e.g., "Tue May 26")
+ =\e= – an ASCII escape character (033)
+ =\h= – the hostname up to the first .
+ =\H= – the full hostname
+ =\j= – the number of jobs currently run in background
+ =\l= – the basename of the shells terminal device name
+ =\n= – newline
+ =\r= – carriage return
+ =\s= – the name of the shell, the basename of $0 (the portion following the final slash)
+ =\t= – the current time in 24-hour HH:MM:SS format
+ =\T= – the current time in 12-hour HH:MM:SS format
+ =\@= – the current time in 12-hour am/pm format
+ =\A= – the current time in 24-hour HH:MM format
+ =\u= – the username of the current user
+ =\v= – the version of bash (e.g., 4.00)
+ =\V= – the release of bash, version + patch level (e.g., 4.00.0)
+ =\w= – Complete path of current working directory
+ =\W= – the basename of the current working directory
+ =\!= – the history number of this command
+ =\#= – the command number of this command
+ =\$= – if the effective UID is 0, a #, otherwise a $
+ =\nnn= – the character corresponding to the octal number nnn
+ =\\= – a backslash
+ =\[= – begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
+ =\]= – end a sequence of non-printing characters

我的配置：
#+BEGIN_EXAMPLE
export PS1="\W$ "
#+END_EXAMPLE

**** PS2 副提示符变量
一个非常长的命令可以通过在末尾加"=\="使其分行显示。多行命令的默认提示
符是">"。

**** PS3 定制shell脚本的select提示
**** PS4 定制调试模式的提示符
+ $0 显示当前的脚本名
+ $LINENO 显示的当前的行号

** 算术运算
*** [[http://blog.csdn.net/hansel/article/details/8736775][ Bash shell 的算术运算有四种方式]] :blog:

Bash shell 的算术运算有四种方式:

**** 使用 expr 外部程式

加法 r=`expr 4 + 5`
echo $r
注意! '4' '+' '5' 这三者之间要有空白
r=`expr 4 * 5` #错误
乘法 r=`expr 4 \* 5`

**** 使用 $(( ))
r=$(( 4 + 5 ))
echo $r

**** 使用 $[ ]

r=$[ 4 + 5 ]
echo $r

乘法
r=`expr 4 \* 5`
r=$(( 4 * 5 ))
r=$[ 4 * 5 ]
echo $r

除法
r=`expr 40 / 5`
r=$(( 40 / 5 ))
r=$[ 40 / 5 ]
echo $r

减法
r=`expr 40 - 5`
r=$(( 40 - 5 ))
r=$[ 40 - 5 ]
echo $r

求余数
r=$[ 100 % 43 ]
echo $r

乘幂 (如 2 的 3 次方)
r=$(( 2 ** 3 ))
r=$[ 2 ** 3 ]
echo $r
注：expr 没有乘幂

**** 使用let 命令

变量和运算符直接不能有空格，否则要用引号括起。

加法：
n=10
let n=n+1
echo $n #n=11

乘法：
let m=n*10
echo $m

除法：
let r=m/10
echo $r

求余数：
let r=m%7
echo $r

乘幂：
let r=m**2
echo $r

虽然Bash shell 有四种算术运算方法，但并不是每一种都是跨平台的，建议使用expr。
另外，我们在 script 中经常有加1操作，以下四法皆可：
m=$[ m + 1]
m=`expr $m + 1`
m=$(($m + 1))
let m=m+1

** 文件目录                                                            :file:
*** reference

- [[read -r line < file][EN::Bash One-Liners Explained（一）：文件处理]]

*** 清空文件内容

#+BEGIN_SRC sh
> file
#+END_SRC

这一行命令用到了输出重定向操作符>。输出重定向发生时，文件会被打开准备
写入。如果此时文件不存在则先创建，存在则将其大小截取为0。这里我们并没
有重定向写任何内容到文件中，所以文件依然保持为空。

如果你想替换文件的内容，或者创建一个包含指定内容的文件，可以运行下面的
命令：

#+BEGIN_SRC sh
echo "some string" > file
#+END_SRC

*** 追加内容到文件

#+BEGIN_SRC sh
echo "foo bar baz" >> file
#+END_SRC

这一行命令用到了另外一个输出重定向操作符>>，该操作符将内容追加到文件
。同样地，如果文件不存在则先创建它。追加的内容之后，紧跟着换行符。如
果你不想要追加换行符，在执行echo命令时可以指定-n选项：

#+BEGIN_SRC sh
echo -n "foo bar baz" >> file
#+END_SRC

*** 读取文件的首行并赋值给变量

#+BEGIN_SRC sh
read -r line < file
#+END_SRC

这一行命令用到了 Bash 的内置命令read，和输入重定向操作符<。read命令
从标准输入中读取一行，并将内容保存到变量line中。在这里，-r选项保证读
入的内容是原始的内容，意味着反斜杠转义的行为不会发生。输入重定向操作
符< file打开并读取文件file，然后将它作为read命令的标准输入。

记住， _read 命令会删除包含在 /IFS/ 变量中出现的所有字符_

*IFS* 的全称是Internal Field Separator，Bash 根据 IFS 中定义的字符来分
隔单词。

在这里，read命令读入的行被分隔成多个单词。默认情况下，IFS包含空格，制表
符和回车，这意味着开头和结尾的空格和制表符都会被删除。如果你想保留这
些符号，可以通过设置IFS为空来完成：

#+BEGIN_SRC sh
IFS=
read -r line < file
#+END_SRC

IFS 的变化仅会影响当前的命令，这行命令可以保证读入原始的首行内容到变
量line中，同时行首与行尾的空白字符被保留。

另外一种读取文件首行内容，并赋值给变量的方法是:

#+BEGIN_SRC sh
line=$(head -1 file)
#+END_SRC

这里用到了命令替换操作符 $(...)，它运行括号里的命令并且将输出返回。这
个例子中，命令是head -1 file，输出的内容是文件的首行。输入然后通过等
号赋值给变量line。$(...)的等价写法是`...`，所以也可以换成下面这样：

#+BEGIN_SRC sh
line=`head -1 file`
#+END_SRC

不过，在 Bash 中$(...)用法更加推荐，因为它看起来更加整洁，并且容易嵌
套使用。

*** 依次读入文件每一行

#+BEGIN_SRC sh
while read -r line; do
    # do something with $line
done < file
#+END_SRC

这是一种正确的读取文件内容的做法，read命令放在while循环中。当read命
令遇到文件结尾时（EOF），它会返回一个正值，导致循环判断失败终止。

记住，read命令会删除首尾多余的空白字符，所以如果你想保留，请设置 IFS
为空值:

#+BEGIN_SRC sh
while IFS= read -r line; do
    # do something with $line
done < file
#+END_SRC

如果你不想将 "< file" 放在最后，可以通过管道将文件的内容输入到 while
循环中：

#+BEGIN_SRC sh
cat file | while IFS= read -r line; do
    # do something with $line
done
#+END_SRC

*** 随机读取一行并赋值给变量


#+BEGIN_SRC sh
read -r random_line < <(shuf file)
#+END_SRC

Bash 中并没有提供一种直接的方法来随机读取文件的某一行内容，所以这里
需要利用外部程序。在最新的一些 Linux 系统上，GNU Coreutils 包中提供
的 /shuf/ 命令可以满足我们的需求。

这一行命令中用到了进程替换（process substitution）操作符<(...)。进程
替换操作会创建一个匿名的管道文件，并将进程命令的标准输出连接到管道的
写一端。然后 Bash 开始执行进程替换中的命令，然后将整个进程替换的表达
式替换成匿名管道的文件名。

当 Bash 看到<(shuf file)时，它首先打开一个特殊的文件/dev/fd/n，这里
的n是一个空闲的文件描述符，然后执行shuf file命令，将标准输出连接到/
dev/fd/n，并且替换<(shuf file) 为/dev/fd/n，因此实际的命令会变成:


#+BEGIN_SRC sh
read -r random_line < /dev/fd/n
#+END_SRC

结果会读取洗牌后的文件的第一行内容。

另外一种做法是，使用 GNU sort 命令，它提供的-R选项可以随机排序文件：

#+BEGIN_SRC sh
read -r random_line < <(sort -R file
#+END_SRC

或者，同前面一样，将结果赋值给变量：

#+BEGIN_EXAMPLE
$ random_line=$(sort -R file | head -1)
#+END_EXAMPLE

这里，我们首先通过sort -R随机排序文件，然后通过head -1 读取文件的第
一行。

*** 保存文件的大小到变量

#+BEGIN_SRC sh
size=$(wc -c < file)
#+END_SRC

这一行命令中用到了第3点中介绍的命令替换操作$(...)，它运行里面的命令
并将结果获取回来。在这个例子中，命令是wc -c < file，它输出文件的字节
数。这个结果最终会赋值给变量size。

*** 从文件路径中获取文件名

假设，你有一个文件，它的路径为/path/to/file.ext，然后你要从中获取文
件名，在这里是file.ext。你要怎么做？一个好的方法是通过参数展开（
parameter expansion）功能：

#+BEGIN_SRC sh
filename=${path##*/}
#+END_SRC

这一行命令使用了参数展开的语法：${var##pattern} ，它从$var字符串开始
处开始匹配pattern。如果能够匹配成功，将最长匹配的内容删除后再返回。

在这个例子中，匹配的模式是*/，它尝试匹配/path/to/file.ext的开始部分
，正如前面所说，这里是贪婪匹配，所以它能够匹配到最后一个斜杠为止，即
匹配的内容是/path/to/。所以当把匹配的内容删除后，返回的内容就是文件
名file.ext。

*** 从文件路径中获取目录名

和上面一样类似，这次你要从路径/path/to/file.txt中获取目录名/path/to
。你可以继续通过参数展开功能来完成这个任务：

#+BEGIN_SRC
dirname=${path%/*}
#+END_SRC

这次的用法是${var%pattern}，它从$var的结尾处匹配/*。如果能够成功匹配
，将最短匹配的内容删除再返回。

在这个例子中，匹配的模式是/*，它能够匹配/file.ext部分，删除这部分内
容后返回的就是目录名称。

*** 快速拷贝文件

假设你要将文件/path/to/fil拷贝到/path/to/file_copy，一般情况下，大多
数人会这么来写：

#+BEGIN_SRC sh
cp /path/to/file /path/to/file_copy
#+END_SRC


不过，你可以利用括号展开（brace expansion）{...}功能:

#+BEGIN_SRC sh
cp /path/to/file{,_copy}
#+END_SRC


括号展开可以生成任意字符串的组合，在这个例子中，/path/to/file
{,_copy}最终生成/path/to/file /path/to/file_copy。所以上面这行命令最
终发型成: cp /path/to/file /path/to/file_copy

类似地，你可以执行下面的命令快速的移动文件：

#+BEGIN_SRC sh
mv /path/to/file{,_old}
#+END_SRC

这行命令展开后就变成了： mv /path/to/file /path/to/file_old

*** [[http://hw1287789687.iteye.com/blog/1766217][linux shell 遍历指定目录下的所有文件夹]]                           :blog:


在linux 中，如何遍历指定目录下的所有文件夹呢？

要求能搜索结果中包含隐藏文件夹

脚本名：ergodic_folder.sh

脚本内容：

#+BEGIN_EXAMPLE
    #!/bin/sh
    list_alldir(){
        for file2 in `ls -a $1`
        do
            if [ x"$file2" != x"." -a x"$file2" != x".." ];then
                if [ -d "$1/$file2" ];then
                    echo "$1/$file2"
                    list_alldir "$1/$file2"
                fi
            fi
        done
    }

    list_alldir ./test
#+END_EXAMPLE



测试如下：

[root@localhost whuang]# ./ergodic_folder.sh

./test/.abc

./test/.abc/.ccc

./test/bbb

** 逻辑运算                                                          :logic:
*** 逻辑运算符
**** 文件与目录

+ -f  『文件』是否存在
+ -d  『目录』是否存在
+ -b  是否为一个『 block 文件』
+ -c  是否为一个『 character 文件』
+ -S  是否为一个『 socket 标签文件』
+ -L  是否为一个『 symbolic link 的文件』
+ -e  『某个东西』是否存在

**** 程序

+ -G  判断是否由 GID 所执行的程序所拥有
+ -O  判断是否由 UID 所执行的程序所拥有
+ -p  判断是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！）

**** 文件属性

+ -r  判断是否为可读的属性
+ -w  判断是否为可以写入的属性
+ -x  判断是否为可执行的属性
+ -s  判断是否为『非空白文件』
+ -u  判断是否具有『 SUID 』的属性
+ -g  判断是否具有『 SGID 』的属性
+ -k  判断是否具有『 sticky bit 』的属性

**** 两个文件之间的判断与比较

+ -nt  第一个文件比第二个文件新
+ -ot  第一个文件比第二个文件旧
+ -ef  第一个文件与第二个文件为同一个文件（ link 之类的文件）

**** 逻辑的『和(and)』『或(or)』

+ &&  逻辑的 AND 的意思
+ ||  逻辑的 OR 的意思

**** 比较

+ =  等于应用于：整型或字符串比较如果在[] 中，只能是字符串
+ !=  不等于应用于：整型或字符串比较如果在[] 中，只能是字符串
+ <  小于应用于：整型比较在[] 中，不能使用表示字符串
+ >  大于应用于：整型比较在[] 中，不能使用表示字符串
+ -eq  等于应用于：整型比较
+ -ne  不等于应用于：整型比较
+ -lt  小于应用于：整型比较
+ -gt  大于应用于：整型比较
+ -le  小于或等于应用于：整型比较
+ -ge  大于或等于应用于：整型比较
+ -a  双方都成立（and）逻辑表达式 –a 逻辑表达式
+ -o  单方成立（or）逻辑表达式 –o 逻辑表达式
+ -z  空字符串
+ -n  非空字符串

*** 逻辑表达式
**** test

+ 格式： test EXPRESSTION
+ 注：所有字符与逻辑运算符直接使用空格分开，不能连到一起

**** []表达式

- 格式： [ EXPRESSION ]

- _方括号开之后的空格和闭之前的空格是必须有_

- 常见的 >, < 需要加转义字符，表示字符串大小比较，以acill码位置作为比
  较。不直接支持 < >运算符

- 逻辑运算符 || && 它需要用 -a[and] –o[or]表示

**** [[]]表达式

[[]] 运算符只是[]运算符的扩充。能够支持<,>符号运算不需要转义符，它还是

以字符串比较大小。里面支持逻辑运算符：|| &&

*** 逻辑运算

+ &&  与
+ ||  或
+ ！  非

*** [[http://www.cnblogs.com/chengmo/archive/2010/10/01/1839942.html][linux shell 逻辑运算符、逻辑表达式详解]] :blog:

shell的逻辑运算符
涉及有以下几种类型，因此只要适当选择，可以解决我们很多复杂的判断，达到事半功倍效果。


*一、逻辑运算符*

| *逻辑卷标* | *表示意思*                                                              |
| 1.         | *关于档案与目录的侦测逻辑卷标！*                                        |
| -f         | 常用！侦测『档案』是否存在 eg: if [ -f filename ]                       |
| -d         | 常用！侦测『目录』是否存在                                              |
| -b         | 侦测是否为一个『 block 档案』                                           |
| -c         | 侦测是否为一个『 character 档案』                                       |
| -S         | 侦测是否为一个『 socket 标签档案』                                      |
| -L         | 侦测是否为一个『 symbolic link 的档案』                                 |
| -e         | 侦测『某个东西』是否存在！                                              |
| 2.         | *关于程序的逻辑卷标！*                                                  |
| -G         | 侦测是否由 GID 所执行的程序所拥有                                       |
| -O         | 侦测是否由 UID 所执行的程序所拥有                                       |
| -p         | 侦测是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！） |
| 3.         | *关于档案的属性侦测！*                                                  |
| -r         | 侦测是否为可读的属性                                                    |
| -w         | 侦测是否为可以写入的属性                                                |
| -x         | 侦测是否为可执行的属性                                                  |
| -s         | 侦测是否为『非空白档案』                                                |
| -u         | 侦测是否具有『 SUID 』的属性                                            |
| -g         | 侦测是否具有『 SGID 』的属性                                            |
| -k         | 侦测是否具有『 sticky bit 』的属性                                      |
| 4.         | *两个档案之间的判断与比较* ；例如[ test file1 -nt file2 ]               |
| -nt        | 第一个档案比第二个档案新                                                |
| -ot        | 第一个档案比第二个档案旧                                                |
| -ef        | 第一个档案与第二个档案为同一个档案（ link 之类的档案）                  |
| 5.         | 逻辑的『和(and)』『或(or)』                                             |
| &&         | 逻辑的 AND 的意思                                                       |
|            | 逻辑的 OR 的意思                                                        |
|            |                                                                         |
|            |                                                                         |

| 运算符号 | 代表意义                                                  |
| =        | 等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串   |
| !=       | 不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串 |
| <        | 小于 应用于：整型比较 在[] 中，不能使用 表示字符串        |
| >        | 大于 应用于：整型比较 在[] 中，不能使用 表示字符串        |
| -eq      | 等于 应用于：整型比较                                     |
| -ne      | 不等于 应用于：整型比较                                   |
| -lt      | 小于 应用于：整型比较                                     |
| -gt      | 大于 应用于：整型比较                                     |
| -le      | 小于或等于 应用于：整型比较                               |
| -ge      | 大于或等于 应用于：整型比较                               |
| -a       | 双方都成立（and） 逻辑表达式 --a 逻辑表达式               |
| -o       | 单方成立（or） 逻辑表达式 --o 逻辑表达式                  |
| -z       | 空字符串                                                  |
| -n       | 非空字符串                                                |



*二、逻辑表达式*

- *test 命令*

#+BEGIN_QUOTE
  *使用方法：*test EXPRESSION

  如：

  [root@localhost ~]# test 1 = 1 && echo 'ok'
  ok

  [root@localhost ~]# test -d /etc/ && echo 'ok'
  ok

  [root@localhost ~]# test 1 -eq 1 && echo 'ok'
  ok



  [root@localhost ~]# if test 1 = 1 ; then echo 'ok'; fi
  ok
#+END_QUOTE



#+BEGIN_QUOTE
  *注意：所有字符 与逻辑运算符直接用“空格”分开，不能连到一起。*
#+END_QUOTE



- *精简表达式*

#+BEGIN_QUOTE

  -  *[] 表达式*

  [root@localhost ~]# [ 1 -eq 1 ] && echo 'ok'
  ok

  [root@localhost ~]# [ 2 < 1 ] && echo 'ok'
  -bash: 2: No such file or directory


  [root@localhost ~]# [ 2 \< 1 ] && echo 'ok'

  [root@localhost ~]# [ 2 -gt 1 -a 3 -lt 4 ] && echo 'ok'

  ok

  [root@localhost ~]# [ 2 -gt 1 && 3 -lt 4 ] && echo 'ok'
  -bash: [: missing `]'

  注意：在[]
  表达式中，常见的>,<需要加转义字符，表示字符串大小比较，以acill码
  位置作为比较。 不直接支持<>运算符，还有逻辑运算符|| && 它需要用-a[and]
  --o[or]表示
#+END_QUOTE



#+BEGIN_QUOTE




  -  *[[]] 表达式*

  [root@localhost ~]# [ 1 -eq 1 ] && echo 'ok'
  ok

  [root@localhost ~]$ [[ 2 < 3 ]] && echo 'ok'
  ok

  [root@localhost ~]$ [[ 2 < 3 && 4 > 5 ]] && echo 'ok'
  ok
#+END_QUOTE

#+BEGIN_QUOTE
  注意：[[]]
  运算符只是[]运算符的扩充。能够支持<,>符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：||
  &&


#+END_QUOTE



*三、性能比较*

bash的条件表达式中有三个几乎等效的符号和命令：test，[]和[[]]。通常，大家习惯用if
[];then这样的形式。而[[]]的出现，根据ABS所说，是为了兼容><之类的运算符。以下是比较它们性能，发现[[]]是最快的。


$ time (for m in {1..100000}; do test -d .;done;)
real  0m0.658s
user  0m0.558s
sys  0m0.100s


$ time (for m in {1..100000}; do [ -d . ];done;)
real  0m0.609s
user  0m0.524s
sys  0m0.085s


$ time (for m in {1..100000}; do [[ -d . ]];done;)
real  0m0.311s
user  0m0.275s
sys  0m0.036s


不考虑对低版本bash和对sh的兼容的情况下，用[[]]是兼容性强，而且性能比较快，在做条件运算时候，可以使用该运算符。

*** 算术运算比较运算符

bash自身不能比较浮点数

1. *-eq*: 等于

   #+BEGIN_SRC sh
     m=1; n=1;
     if [ $m -eq $n ]
        then
            echo $m equals $n
     else
         echo $m not equals $n
     fi
   #+END_SRC

   #+RESULTS:
   : 1 equals 1


   #+BEGIN_SRC sh
     declare -i m=1
     declare -i n=1

     if [ $m -eq $n ]
        then
            echo "${m} equals ${n}"
     else
         echo $m not equals $n
     fi
   #+END_SRC

   #+RESULTS:
   : 1 equals 1

2. *-ne*: 不等于

   #+BEGIN_SRC sh
   [ 100   -ne $num1 ]
   #+END_SRC

3. *-lt*: 小于

   #+BEGIN_SRC sh
   [ 100   -lt `expr $num1 + $num2` ]
   #+END_SRC

4. *-le*: 小于或等于

   #+BEGIN_SRC sh
   [ 100   -le `expr $num1 \* $num2` ]
   #+END_SRC

5. *-gt*: 大于

   #+BEGIN_SRC sh
   [ 100   -gt `expr $num1 / $num2` ]
   #+END_SRC

6. *-ge*: 大于或等于

   #+BEGIN_SRC sh
   [ 100   -ge `expr $num1 % $num2` ]
   #+END_SRC

*** 字符串比较                                                     :string:

1. *-z string*

   如果 string 长度为零，则为真

   #+BEGIN_SRC sh
   [ -z "`ps aux | grep mysql`" ]
   #+END_SRC

2. *-n string*

   如果 string 长度非零，则为真

   #+BEGIN_SRC sh
   [ -n "$string" ]
   #+END_SRC

   注: $string 一定要放在双引号里面 "$string"，否则使用 -n -z 的结果都
   为真！

3. *string1 != string2*

   如果 string1 与 string2 不同，则为真

   #+BEGIN_SRC sh
   [ "$str1" != "Snail" ]
   #+END_SRC

4. *string1 == string2*

   如果 string1 与 string2 相同，则为真

   #+BEGIN_SRC sh
   [ "$str1" == "$str2" ]
   #+END_SRC

   注：使用 "=" 也可以，在严格的 POSIX 兼容下使用

5. *string1  string2* (?)

   如果 string1 按字典顺序比较大于 string2，则为真

*** 文件比较                                                         :file:

1. *-a filename*

   如果 filename 存在，则为真

   #+BEGIN_SRC sh
   [ -e $HOME/.bashrc ]
   #+END_SRC

2. *-e filename*

   同上

3. *-b filename*

   如果 filename 存在，并且是块文件，则为真

   #+BEGIN_SRC sh
   [ -e /dev/loop0 ]
   #+END_SRC

4. *-c filename*

   如果 filename 存在，并且是字符文件，则为真
   #+BEGIN_EXAMPLE
     [ -e /dev/ttyS0 ]
   #+END_EXAMPLE

5. *-d filename*

   如果 filename 存在，并且为目录，则为真

   #+BEGIN_SRC sh
     [ -d /home/snail ]
   #+END_SRC

6. *-f filename*

   如果 filename 存在，并且为常规文件，则为真

   #+BEGIN_SRC sh
     [ -f /dev/ttyS0 ]
   #+END_SRC

7. *-g filename*

   如果 filename 存在，并且为set-group-id，为真

   #+BEGIN_SRC sh
     [ -f $HOME/ak47 ]
   #+END_SRC

8. *-h filename*

   如果 filename 存在，并且为符号连接，则为真

   #+BEGIN_SRC sh
     [ -h /bin/vi ]
   #+END_SRC

9. *-L filename*

   同上

10. *-k filename*

    如果 filename 存在，并且设置了sticky位，为真

    #+BEGIN_SRC sh
      [ -k /bin/ping ]
    #+END_SRC

11. *-p filename*

    如果 filename 存在，并且为有名管道(FIFO)，真

    #+BEGIN_SRC sh
      [ -p /tmp/pipe ]
    #+END_SRC

12. *-r filename*

    如果 filename 存在，并且可读，则为真

    #+BEGIN_SRC sh
      [ -r /etc/passwd ]
    #+END_SRC

13. *-s filename*

    如果 filename 存在，并且大小不为零，为真

    #+BEGIN_SRC sh
      [ -s ./none-zero ]

    #+END_SRC

14. *-u filename*

    如果 filename 存在，并且为set-user-id，为真

    #+BEGIN_SRC sh
      [ -f $HOME/ak47 ]
    #+END_SRC

15. *-w filename*

    如果 filename 存在，并且可写，则为真

    #+BEGIN_SRC sh
      [ -w /var/log/mail ]
    #+END_SRC

16. *-x filename*

    如果 filename 存在，并且可执行，则为真
    #+BEGIN_EXAMPLE
      [ -x ./start.sh ]
    #+END_EXAMPLE

17. -t fd

    如果文件描述符被打开并指向一个终端，则为真

    #+BEGIN_SRC sh
      [ -t /proc/1/fd/10 ]
    #+END_SRC
    【提示】在 /proc/进程号/fd 下可以找到文件描述符

18. -O filename

    如果 filename 存在，并且被有效用户ID所拥有，则为真

19. -G filename

    如果 filename 存在，并且被有效组ID所拥有，则为真

20. -S filename

    如果 filename 存在，并且为一个socket，则为真

    #+BEGIN_SRC sh
      [ -S /tmp/mysql.sock ]
    #+END_SRC

21. -N filename

    如果 filename 存在，并且在上次读取后被修改过，则为真

22. -o optname

    如果 shell 选项 optname 被开启，则为真

    【提示】使用 set -o 来查看

23. file1 -nt file2

    如果 file1 比 file2 新，或者 file1 存在 file2 不存在，则为真

24. file1 -ot file2

    如果 file1 比 file2 旧，或者 file2 存在 file1 不存在，则为真

25. file1 -ef file2

    如果 file1 和 file2 都指向同样的设备(device)和索引节点号(inode
    numbers)，则为真

    【提示】查看文件的索引节点可以用 ls -i 选项

** 日期时间
*** date

1) 格式： date [opts] [+format]
2) format
   - %H
   - %M
   - %s
   - %y
   - %Y
   - %m
   - %d
   - ...
   - 不加+，表示设定时间，格式为MMDDhhmm[CC][YY][.ss]

*** [[http://blog.sina.com.cn/s/blog_61c006ea0100mgxe.html][shell编程中的date用法]]                                            :blog:


1、date --help

%% 输出%符号 a literal %
 %a 当前域的星期缩写 locale's abbreviated weekday name (Sun..Sat)
 %A 当前域的星期全写 locale's full weekday name, variable length
(Sunday..Saturday)
 %b 当前域的月份缩写 locale's abbreviated month name (Jan..Dec)
 %B 当前域的月份全称 locale's full month name, variable length
(January..December)
 %c 当前域的默认时间格式 locale's date and time (Sat Nov 04 12:02:33 EST
1989)
 %C n百年 century (year divided by 100 and truncated to an integer)
[00-99]
 %d 两位的天 day of month (01..31)
 %D 短时间格式 date (mm/dd/yy)
 %e 短格式天 day of month, blank padded ( 1..31)
 %F 文件时间格式 same as %Y-%m-%d
 %g the 2-digit year corresponding to the %V week number
 %G the 4-digit year corresponding to the %V week number
 %h same as %b
 %H 24小时制的小时 hour (00..23)
 %I 12小时制的小时 hour (01..12)
 %j 一年中的第几天 day of year (001..366)
 %k 短格式24小时制的小时 hour ( 0..23)
 %l 短格式12小时制的小时 hour ( 1..12)
 %m 双位月份 month (01..12)
 %M 双位分钟 minute (00..59)
 %n 换行 a newline
 %N 十亿分之一秒 nanoseconds (000000000..999999999)
 %p 大写的当前域的上下午指示 locale's upper case AM or PM indicator
(blank in many locales)
 %P 小写的当前域的上下午指示 locale's lower case am or pm indicator
(blank in many locales)
 %r 12小时制的时间表示（时:分:秒,双位） time, 12-hour (hh:mm:ss [AP]M)
 %R 24小时制的时间表示 （时:分,双位）time, 24-hour (hh:mm)
 %s 自基础时间 1970-01-01 00:00:00 到当前时刻的秒数 seconds since
`00:00:00 1970-01-01 UTC' (a GNU extension)
 %S 双位秒 second (00..60); the 60 is necessary to accommodate a leap
second
 %t 横向制表位(tab) a horizontal tab
 %T 24小时制时间表示 time, 24-hour (hh:mm:ss)
 %u 数字表示的星期（从星期一开始 1-7）day of week (1..7); 1 represents
Monday
 %U 一年中的第几周星期天为开始 week number of year with Sunday as first
day of week (00..53)
 %V 一年中的第几周星期一为开始 week number of year with Monday as first
day of week (01..53)
 %w 一周中的第几天 星期天为开始 0-6 day of week (0..6); 0 represents
Sunday
 %W 一年中的第几周星期一为开始 week number of year with Monday as first
day of week (00..53)
 %x 本地日期格式 locale's date representation (mm/dd/yy)
 %X 本地时间格式 locale's time representation (%H:%M:%S)
 %y 两位的年 last two digits of year (00..99)
 %Y 年 year (1970...)
 %z RFC-2822 标准时间格式表示的域 RFC-2822 style numeric timezone
(-0500) (a nonstandard extension)
 %Z 时间域 time zone (e.g., EDT), or nothing if no time zone is
determinable

By default, date pads numeric fields with zeroes. GNU date recognizes
 the following modifiers between `%' and a numeric directive.

`-' (hyphen) do not pad the field
 `_' (underscore) pad the field with spaces

--------------------------------------------------------------------------------

2、一些用法

1）#以yymmdd的格式输出43天前的当前时刻

date +%Y%m%d --date='43 days ago'



2）# 测试十亿分之一秒
 date +'%Y%m%d %H:%M:%S.%N';date +'%Y%m%d %H:%M:%S.%N';date +'%Y%m%d
%H:%M:%S.%N';date +'%Y%m%d %H:%M:%S.%N'

3）#创建以当前时间为文件名的目录
 mkdir `date +%Y%m%d`



4）#备份以时间做为文件名的
 tar -cvf ./htdocs`date +%Y%m%d`.tar ./*



5）#显示时间后跳行，再显示目前日期

date +%T%n%Y%m%d



6）#只显示月份与日数

date +%B%d



7）#获取上周日期（day,month,year,hour）

date -d "-1 week" +%Y%m%d 　　



8）#获取24小时前日期

date --date="-24 hour" +%Y%m%d



9）#shell脚本里面赋给变量值

date_now=`date +%s`



10）#计算执行一段sql脚本的运行时间



TIME_BEGIN=$(date '+%s.%N')
 $sqlcli < queries/q1.3.sql 1>> $FILE_RESULT  2>> $FILE_ERROR
 TIME_END=$(date '+%s.%N')
 TIME_RUN=$(awk 'BEGIN{print '$TIME_END' - '$TIME_BEGIN'}')



11）#编写shell脚本计算离自己生日还有多少天？

  read -p "Input your birthday(YYYYmmdd):" date1

m=`date --date="$date1" +%m`  #得到生日的月

d=`date --date="$date1" +%d`  #得到生日的日

date_now=`date +%s`  #得到当前时间的秒值

y=`date +%Y` #得到当前时间的年

birth=`date --date="$y$m$d" +%s`  #得到今年的生日日期的秒值

internal=$(($birth-$date_now))  #计算今日到生日日期的间隔时间

if [ "$internal" -lt "0" ]; then  #判断今天的生日是否已过

birth=`date --date="$(($y+1))$m$d" +%s`  #得到明天的生日日期秒值

internal=$(($birth-$date_now))
#计算今天到下一个生日的间隔时间

fi

echo "There is :$((einternal/60/60/24)) days."
#输出结果，秒换算为天





12）#若是不以加号作为开头，则表示要设定时间，而时间格式为
MMDDhhmm[[CC]YY][.ss]，

其中 MM 为月份，

DD 为日，

hh 为小时，

mm 为分钟，

CC 为年份前两位数字，

YY 为年份后两位数字，

ss 为秒数



13）

#显示目前的格林威治时间，也叫“世界时”。是英国的标准时间，也是世界各地时间的参考标准。中英两国的标准[[http://baike.baidu.com/view/72144.htm][时差]]为8个小时，即英国的当地时间比中国的[[http://baike.baidu.com/view/21267.htm][北京时间]]晚8小时。

date -u
 Thu Sep 28 09:32:04 UTC 2006



14）#修改时间

date -s
 按字符串方式修改时间
 可以只修改日期,不修改时间,输入: date -s 2007-08-03
 只修改时间,输入:date -s 14:15:00
 同时修改日期时间,注意要加双引号,日期与时间之间有一空格,输入:date -s
"2007-08-03 14:15:00"

 修改完后,记得输入:clock -w
 把系统时间写入CMOS

** 编程风格
*** [[https://app.yinxiang.com/shard/s52/nl/11551545/127c59e2-466d-4355-a17a-d2773f179faa/?csrfBusterToken%3DU%253Db04339%253AP%253D%252F%253AE%253D151a5c2ee1b%253AS%253D15929e085232fb21d53ac9a74c115954][bash 编程规范]]                                                   :style:
**** reference
+ [[https://app.yinxiang.com/shard/s52/nl/11551545/127c59e2-466d-4355-a17a-d2773f179faa?title=Shell%20%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC][bash 编码风格]]

*** document & doxygen                                            :doxygen:

http://stackoverflow.com/questions/1190427/shell-documentation-bash-ksh

Q: is there a tool out there similar to Javadoc or POD for shell
scripting?

A:
No, but you can try to abuse of doxygen

/不考虑/

*** [[http://kodango.com/shell-script-style][Shell 编码风格]]                                       :blog:translation:

[[http://wiki.bash-hackers.org/scripting/style][Scripting with style]] 是少见的一篇介绍 Shell 编码风格的文章，相信对大多
数运维人员有用，现在将译文献上。

**** 缩进准则

我一般使用2个空格来缩进（尽管大多人使用4个空格），原因是：

- 输入简单快速；
- 没有输入一个Tab键，避免不同环境下显示的差异问题；
- 缩进的效果已经足够，并且没有浪费太多的空间；

#+BEGIN_QUOTE
  译者注：本人也是使用4个空格，如果你也与本文作者的风格不一样，下面说
  到2个空格的地方请自觉替换成你实际使用的空格数。个人认为，缩进只是一
  个个人的风格，只要不影响可读性即可。
#+END_QUOTE

顺便说一句，尽量不要使用Tab键，它们容易带来麻烦，我只能想到一种情况下
它是有用的：here document中的缩进。

***** 分隔长行

如果需要分隔过长的代码，你可以使用下面的任意一种方法：

1） 使用与命令宽度相同的缩进

#+BEGIN_EXAMPLE
    activate some_very_long_option \
             some_other_option
#+END_EXAMPLE

2） 使用2个空格缩进

#+BEGIN_EXAMPLE
    activate some_very_long_option \
      some_other_option
#+END_EXAMPLE

从个人的角度来说，除非有特别的需要，我更倾向于第一种形式，因为它突出
“上下两行的内容是一起的”这一联系。

***** 分离复合命令

#+BEGIN_QUOTE
  译者注：其实这里的复合命令就是指块语句，例如for/while循环,
  if分支结构等等。
#+END_QUOTE

#+BEGIN_EXAMPLE
    HEAD_KEYWORD parameters; BODY_BEGIN
      BODY_COMMANDS
    BODY_END
#+END_EXAMPLE

我习惯于：

- 将HEAD_KEYWORD和初始化命令或者参数放在第一行；
- 将BODY_BEGIN同样放在第一行；
- 复合命令中的BODY部分以2个空格缩进；
- BODY_END部分独立一行放在最后；

1）if/then/elif/else分支语句

#+BEGIN_EXAMPLE
    if ...; then
      ...
    elif ...; then
      ...
    else
      ...
    fi
#+END_EXAMPLE

2）for循环

#+BEGIN_EXAMPLE
    for f in /etc/*; do
      ...
    done
#+END_EXAMPLE

3） while/until循环

#+BEGIN_EXAMPLE
    while [[ $answer != [YyNn] ]]; do
      ...
    done
#+END_EXAMPLE

4） case分支语句

#+BEGIN_EXAMPLE
    case $input in
      hello)
        echo "You said hello"
      ;;
      bye)
        echo "You said bye"
        if foo; then
          bar
        fi
      ;;
      *)
        echo "You said something weird..."
      ;;
    esac
#+END_EXAMPLE

几点注意的地方：

- 如果不是100%需要，匹配部分左右的括号不需要写（*译者注：例如写成hello)而不是(hello)*）；
- 匹配模式与分支的终止符号;;位于同一缩进级别
- 分支内部的命令多缩进一层；
- 尽管是可选的，这里还是把最后一个分支的终止符号也写上了；

**** 语法和编码指引

***** 晦涩的语法结构

我们都喜欢一些晦涩的语法结构，因为它们很简洁。但是如果不是100%需要用到，尽量不要使用它们，否则大多数人无法理解你的代码。

所以有有时候，我们需要在代码的智能，效率与可读性之间找到一个平衡点。

如果你一定要使用这种语法结构，记得在用的地方写上一小段注释。

#+BEGIN_QUOTE
  译者注：Shell提供的一些语法糖很难理解，但是有非常简洁实用，本人也很喜欢用，这样可以省下一大堆精力，而且用熟了也没有什么难以理解的，但是作者说的也有道理，这一点就仁者见仁，智者见智了
#+END_QUOTE

***** 变量名

因为所有保留的变量名都是大写的，最安全的方法是仅使用小写字母作为变量名，例如读入用户的输入、循环变量等等......：

- 变量名尽量选择小写字母；
- 如果你使用大写的变量名，不要使用保留的变量名（一份不完全的列表参见[[http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08][SUS]]）；
- 如果你使用大写的变量名，最后在变量名前面加一个独特的前缀（例如下面例子中的MY_）；

下面是一个例子：

#+BEGIN_EXAMPLE
    #!/bin/bash

    # the prefix 'MY_'
    MY_LOG_DIRECTORY=/var/adm/

    for file in "$MY_LOG_DIRECTORY"/*; do
      echo "Found Logfile: $file"
    done
#+END_EXAMPLE

***** 变量初始化

正如C语言一样，最好的处理是在变量声明的时候初始化。

用户可以将一个变量以环境变量的形式传递到脚本中。如果你盲目地假定你使用的所有变量都是未初始化的，其它人可以以环境变量的形式劫持一个变量。

#+BEGIN_QUOTE
  译者注：一个例子说明这一点：

  #+BEGIN_EXAMPLE
      $ cat b.sh

      if [ -z "$var" ]; then
          echo "$var is not set"
          var=1
      fi

      echo "Now, var is equals to $var"
      var=2 sh b.sh
      Now, var is equals to 2
  #+END_EXAMPLE
#+END_QUOTE

解决这个问题的方法很简单，将变量初始化：

#+BEGIN_EXAMPLE
    my_input=""
    my_array=()
    my_number=0
#+END_EXAMPLE

***** 参数展开

除非你知道自己做的事情，*请在参数展开的地方使用双引号*

当然，也有一些地方并不需要使用双引号，例如：

- [[ ]]测试表达式内部是不会展开的；
- 在case $WORD in语法中WORD也不会展开的；
- 在变量赋值var=$WORD的地方也是不会展开的

但是在这些地方使用引号并不会出错，如果你习惯于在每个可能展开参数的地方使用引号，你写得代码会很安全。

如果你要传递一个参数作为一个单词列表，你可以不使用引号，例如：

#+BEGIN_EXAMPLE
    list="one two three"

    # you MUST NOT quote $list here
    for word in $list; do
      ...
    done
#+END_EXAMPLE

***** 函数名称

函数名称应该采用小写的形式，并且有一个很好的意义。函数名称应该容易让人理解，比如f1这个名称虽然容易输入但是对调试和其它人阅读代码造成了很大的困难，它说明不了任何东西。好的函数名称可以帮助说明代码，而不需要额外的注释。

一个或多或少有趣的是：如果你无意这样做，不要把函数名称命名为常见的命令名，新手往往比较容易将脚本或者函数名命名成test，这样就和UNIX的test命令冲突了。

除非绝对必要，仅使用字母、数字和下划线作为函数名称。+/bin/ls也是一个合法的Bash函数名称。+

#+BEGIN_QUOTE
  译者注：/bin/ls不是一个合法的函数名称。
#+END_QUOTE

***** 命令替换

正如文章[[http://wiki.bash-hackers.org/syntax/expansion/cmdsubst][the
article about command substitution [Bash Hackers
Wiki]]]中提及的，你应该使用$( .. )形式。

不过，如果可移植性是一个问题，你可能必须使用反引号的形式`...`。

在任何情况，如果其它展开或者单词分隔并不是你期望的，你应该将命令替换用双引号引起来。

***** Eval命令

正如Greg据说的：“If eval is the answer, surely you are asking the wrong
question.”。

避免它，除非绝对必要：

- eval can be your neckshot（可能是你的麻烦？）
- 很有可能有其它的方法来实现你需要的；
- 如果可能，重新思考下脚本的工作过程，当eval的使用不可避免的时候；
- 如果你实在需要使用，小心慎用；

**** 脚本的基本结构

一个脚本的基本结构是这样的：

#+BEGIN_EXAMPLE
    #!SHEBANG

    CONFIGURATION_VARIABLES

    FUNCTION_DEFINITIONS

    MAIN_CODE
#+END_EXAMPLE

***** Shebang

如果可能，请不要忘记shebang。

请小心使用/bin/sh作为shebang，在Linux系统中，/bin/sh就是Bash这是一个错误的观点。

于我而言，shebang有两个目的：

- 说明直接执行时以哪个解释器来执行；
- 明确该脚本应该以哪个解释器来执行；

***** 配置变量

在这里，我将这一类变量------可以被用户更改的------叫做配置变量。

让这类变量容易找到，一般放在脚本的头部，给它们有意义的名称并且加上注释说明。正如上面说的，仅当你知道你为什么这么做的时候，才用大写的变量名形式，否则小写形式更加安全。

***** 函数定义

所有函数定义应该在脚本主要代码执行之前，这样可以给人全局的印象，并且确保所有函数在使用之前它是已知的。

你应该使用可移植性高的函数定义形式，即不带function关键字的形式。

**** 脚本行为和健壮性

- 当脚本检测到问题时尽早退出，以免执行潜在的问题；

- 如果你需要用到的命令可能并没有安装在系统上，在脚本执行的时候最好检
  查命令是否存在并且提醒用户缺少什么；

- 采用有意义的脚本返回值，例如0代码成功，1代码错误或者失败；

**** 其它

***** 输出内容

- if the script is interactive, if it works for you and if you think
   this is a nice feature, you can try to
   [[http://wiki.bash-hackers.org/snipplets/screen_saverestore][save the terminal content and restore it]] after
   execution；（译者注：不理解这一点是什么意思）
- 在屏幕中输出简单易理解的消息；
- 使用颜色或者特别的前缀区分错误和警告信息；
- 输出正常的内容到STDOUT，而输出错误、警告或者诊断的信息到STDERR；
- 在日志文件中输出所有详细的信息；

***** 输入

不要盲目地假设任何事情，如果你希望用户输入一个数字，请在脚本中主动检查
它是否真得是一个数字，检查头部是否包含0，等等。我们都应该知道这一点，
用户仅仅是用户而不是程序员，他们会做他们想要的，而不是程序想要的。

*** [[http://teliute.org/linux/abs-3.9.1/unofficialst.html][非官方的Shell脚本编写风格]]                                        :blog:

**** 习惯性的注释你的代码.

这可以让别人更容易看懂(或者感激)你的代码(译者注: 犯错时,
别人也会靠注释找到你), 而且也更便于维护.

#+BEGIN_EXAMPLE
PASS="$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}"
# 去年你写下这段代码的时候, 你非常了解这段代码的含义, 但现在它对你来说完全是个谜.
# (摘自Antek Sawicki的"pw.sh"脚本.)
#+END_EXAMPLE

***给脚本和函数加上描述性的头信息.

#+BEGIN_EXAMPLE
#!/bin/bash

#************************************************#
#                   xyz.sh                       #
#           written by Bozo Bozeman              #
#                July 05, 2001                   #
#                                                #
#           Clean up project files.              #
#************************************************#

 E_BADDIR=65                       # 没有这个目录.
 projectdir=/home/bozo/projects    # 想要清除的目录.

 # --------------------------------------------------------- #
 # cleanup_pfiles ()                                         #
 # 删除指定目录中的所有文件.                                 #
 # Parameter: $target_directory                              #
 # 返回值: 0表示成功, 失败返回$E_BADDIR.                     #
 # --------------------------------------------------------- #
 cleanup_pfiles ()
 {
   if [ ! -d "$1" ]  # Test if target directory exists.
   then
     echo "$1 is not a directory."
     return $E_BADDIR
   fi

   rm -f "$1"/*
   return 0   # Success.
 }

 cleanup_pfiles $projectdir

 exit 0
#+END_EXAMPLE

在脚本开头添加任何注释之前,
一定要确保/#!/bin/bash/放在脚本第一行的开头.

**** 避免使用"魔法数字"

也就是, 避免"写死的"字符常量. 可以使用有意义的变量名来代替. 这使得脚
本更易于理解, 并且允许在不破坏应用的情况下进行修改和更新.

#+BEGIN_EXAMPLE
1 if [ -f /var/log/messages ]
2 then
3   ...
4 fi
5 # 一年以后, 你决定修改这个脚本, 让它来检查/var/log/syslog.
6 # 到时候你就必须一行一行的手动修改这个脚本,
7 # 并且寄希望于没有遗漏的地方.
8
9 # 更好的办法是:
10 LOGFILE=/var/log/messages  # 只需要改动一行就行了.
11 if [ -f "$LOGFILE" ]
12 then
13   ...
14 fi
#+END_EXAMPLE

**** 给变量和函数起一些有意义的名字

#+BEGIN_EXAMPLE
fl=`ls -al $dirname`                 # 含义模糊.
file_listing=`ls -al $dirname`       # 更好的名字.


MAXVAL=10   # 使用变量来代替脚本常量, 并且在脚本中都是用这个变量.
while [ "$index" -le "$MAXVAL" ]
...


 E_NOTFOUND=75                        #  错误码使用大写,
                                      #+ 并且命名的时候用"E_"作为前缀.
 if [ ! -e "$filename" ]
 then
   echo "File $filename not found."
   exit $E_NOTFOUND
 fi


 MAIL_DIRECTORY=/var/spool/mail/bozo  # 环境变量名使用大写.
 export MAIL_DIRECTORY


 GetAnswer ()                         # 函数名采用大小写混合的方式.
 {
   prompt=$1
   echo -n $prompt
   read answer
   return $answer
 }

 GetAnswer "What is your favorite number? "
 favorite_number=$?
 echo $favorite_number


 _uservariable=23                     # 语法上可以这么起名, 但是不推荐.
 # 用户定义的变量名最好不要以下划线开头.
 # 因为以下划线开头的变量, 一般都保留, 作为系统变量.
#+END_EXAMPLE

**** [[exit-status.html#EXITCOMMANDREF][退出码]]最好也采用具有系统性的或有意义的命名方式.

#+BEGIN_EXAMPLE
E_WRONG_ARGS=65
...
...
exit $E_WRONG_ARGS
#+END_EXAMPLE

也请参考[[exitcodes.html][Appendix D]].

/最后/, 我们建议采用=/usr/include/sysexits.h=中的定义作为退出码,
虽然这些定义主要用于C/C++编程语言.

**** 在脚本调用中使用标准化的参数标志.

最后, 我们建议使用下面的参数集.

#+BEGIN_EXAMPLE
-a      全部: 返回全部信息(包括隐藏的文件信息).
-b      摘要: 缩减版本, 通常用于其它版本. 通常用于其它脚本.
-c      拷贝, 连接, 等等.
-d      日常的: 使用全天的信息,
        而不仅仅是特定用户或特定实例的信息.
-e      扩展/详细描述: (通常不包括隐藏文件信息).
-h      帮助: 详细的使用方法, 附加信息, 讨论, 帮助.
        也请参考-V.
-l      打印出脚本的输出记录.
 -m      手册: 显示基本命令的man页.
 -n      数字: 仅使用数字数据.
 -r      递归: 这个目录中所有的文件(也包含所有子目录).
 -s      安装&文件维护: 这个脚本的配置文件.
 -u      用法: 列出脚本的调用方法.
 -v      详细信息: 只读输出, 或多或少的会做一些格式化.
 -V      版本/许可/版权Copy(right|left)/捐助(邮件列表).
#+END_EXAMPLE

也请参考[[standard-options.html][Section F.1]].

**** 将一个复杂脚本分割成一些简单的模块. 使用合适的函数来实现模块的功能.

**** 如果有更简单的结构可以使用的话, 就不要使用复杂的结构.

#+BEGIN_EXAMPLE
COMMAND
if [ $? -eq 0 ]
...
# 多余, 而且不好理解.

if COMMAND
...
# 更简练(可能会损失一些可读性).
#+END_EXAMPLE                              |

当我阅读UNIX中Bourne shell (/bin/sh)部分的源代码时. 我被震惊了, 有多少
简单的算法被恶心的编码风格弄得令人看不懂, 并且因此变得没用. 我问我自己,
"有人会对这种代码感到骄傲和自豪么?" Landon Noll
** Miscellaneous

*** [[http://blog.jobbole.com/49800/][Bash One-Liners Explained（一）：文件处理]]            :blog:translation:

原文出处：[[http://www.catonmat.net/series/bash-one-liners-explained][Peteris Krumins]]
译文出处：[[http://kodango.com/bash-one-liners-explained-part-one][团子的小窝]]

[[http://www.catonmat.net/series/bash-one-liners-explained][*BashOne-Liners Explained*]] 是一系列介绍 Bash 命令技巧的文章，由国外牛
人 [[http://www.catonmat.net/][Peteris Krumins]] 撰写。凭借扎实的功底和丰富的经验，作者总结了许多快
速解决问题的技巧，并且每一条都只要用简洁的一行Bash 命令就可以完成，同
时每一行命令文中都给出了非常详尽的解释。

Peteris Krumins是一位高产的博主，在他的博客上有很多非常精彩的文章，推
荐大家有机会都可以去好好读一读。例如，大家耳熟能详的
[[http://www.catonmat.net/series/awk-one-liners-explained][Awk
One-Liners
Explained]]、[[http://www.catonmat.net/series/sed-one-liners-explained][Sed
One-Liners Explained]]
等等。后者我也曾经在博客上分享过[[http://kodango.com/sed1line-notes][一篇笔记]]。

回到正题，虽然这一系列文章不难，但是还是可以从中学到很多细节的知识，相
信这些肯定会对许多初学者有所帮助，所以我打算将这一系列翻译成中文，分享
给大家。为了同原文保持一致，这一系列文章最终会分成以下五篇：

1. [[http://blog.jobbole.com/49800/][Bash One-Liners Explained 译文（一）: 文件处理]]；
2. [[http://blog.jobbole.com/49843/][Bash One-Liners Explained   译文（二）: 操作字符串]]；
3. Bash One-Liners Explained 译文（三）: 漫谈重定向；
4. Bash One-Liners Explained 译文（四）: 历史命令；
5. Bash One-Liners Explained 译文（五）: 命令行跳转；

本系列的文章同其它系列一样，最终都可以在连载页面找到，有兴趣的同学可以
随意翻翻，看看有没有一些对你有价值的文章，大家一起交流学习。

**** 清空文件内容

#+BEGIN_EXAMPLE
    $ > file
#+END_EXAMPLE

这一行命令用到了输出重定向操作符=>=。输出重定向发生时，文件会被打开准
备写入。如果此时文件不存在则先创建，存在则将其大小截取为0。这里我们并
没有重定向写任何内容到文件中，所以文件依然保持为空。

如果你想替换文件的内容，或者创建一个包含指定内容的文件，可以运行下面的
命令：

#+BEGIN_EXAMPLE
    $ echo "some string" > file
#+END_EXAMPLE

**** 追加内容到文件

#+BEGIN_EXAMPLE
    $ echo "foo bar baz" >> file
#+END_EXAMPLE

这一行命令用到了另外一个输出重定向操作符=>>=，该操作符将内容追加到文件。
同样地，如果文件不存在则先创建它。追加的内容之后，紧跟着换行符。如果你
不想要追加换行符，在执行=echo=命令时可以指定=-n=选项：

#+BEGIN_EXAMPLE
    $ echo -n "foo bar baz" >> file
#+END_EXAMPLE

**** 读取文件的首行并赋值给变量

#+BEGIN_EXAMPLE
    $ read -r line < file
#+END_EXAMPLE

这一行命令用到了 Bash 的内置命令 =read= ，和输入重定向操作符 =<= 。
=read= 命令从标准输入中读取一行，并将内容保存到变量 =line= 中。在这里，
=-r= 选项保证读入的内容是原始的内容，意味着反斜杠转义的行为不会发生。输入重定向
操作符 =< file= 打开并读取文件 =file= ，然后将它作为=read=命令的标准输入。


记住，=read=命令会删除包含在=IFS=变量中出现的所有字符，IFS 的全称是
Internal Field Separator，Bash 根据 IFS
中定义的字符来分隔单词。在这里，=read=命令读入的行被分隔成多个单词。默认情况下，=IFS=包含空格，制表符和回车，这意味着开头和结尾的空格和制表符都会被删除。如果你想保留这些符号，可以通过设置=IFS=为空来完成：

#+BEGIN_EXAMPLE
    $ IFS= read -r line < file
#+END_EXAMPLE

IFS
的变化仅会影响当前的命令，这行命令可以保证读入原始的首行内容到变量=line=中，同时行首与行尾的空白字符被保留。

另外一种读取文件首行内容，并赋值给变量的方法是:

#+BEGIN_EXAMPLE
    $ line=$(head -1 file)
#+END_EXAMPLE

这里用到了命令替换操作符=$(...)=，它运行括号里的命令并且将输出返回。
这个例子中，命令是=head -1 file=，输出的内容是文件的首行。输入然后通过等号赋值给变量=line=。=$(...)=的等价写法是=`...`=，所以也可以换成下面这样：

#+BEGIN_EXAMPLE
    $ line=`head -1 file`
#+END_EXAMPLE

不过，在 Bash
中=$(...)=用法更加推荐，因为它看起来更加整洁，并且容易嵌套使用。

**** 依次读入文件每一行

#+BEGIN_EXAMPLE
    $ while read -r line; do
        # do something with $line
    done < file
#+END_EXAMPLE

这是一种正确的读取文件内容的做法，=read=命令放在=while=循环中。当=read=命令遇到文件结尾时（EOF），它会返回一个正值，导致循环判断失败终止。

记住，=read=命令会删除首尾多余的空白字符，所以如果你想保留，请设置 IFS
为空值:

#+BEGIN_EXAMPLE
    $ while IFS= read -r line; do
        # do something with $line
    done < file
#+END_EXAMPLE

如果你不想将=< file=放在最后，可以通过管道将文件的内容输入到 while
循环中：

#+BEGIN_EXAMPLE
    $ cat file | while IFS= read -r line; do
        # do something with $line
    done
#+END_EXAMPLE

**** 随机读取一行并赋值给变量

#+BEGIN_EXAMPLE
    $ read -r random_line < <(shuf file)
#+END_EXAMPLE

Bash
中并没有提供一种直接的方法来随机读取文件的某一行内容，所以这里需要利用外部程序。在最新的一些
Linux 系统上，GNU Coreutils 包中提供的=shuf=命令可以满足我们的需求。

这一行命令中用到了进程替换（[[http://tldp.org/LDP/abs/html/process-sub.html][process
substitution]]）操作符=<(...)=。进程替换操作会创建一个匿名的管道文件，并将进程命令的标准输出连接到管道的写一端。然后
Bash
开始执行进程替换中的命令，然后将整个进程替换的表达式替换成匿名管道的文件名。

当 Bash
看到=<(shuf file)=时，它首先打开一个特殊的文件=/dev/fd/n=，这里的=n=是一个空闲的文件描述符，然后执行=shuf file=命令，将标准输出连接到=/dev/fd/n=，并且替换=<(shuf file)=
为=/dev/fd/n=，因此实际的命令会变成:

#+BEGIN_EXAMPLE
    $ read -r random_line < /dev/fd/n
#+END_EXAMPLE

结果会读取洗牌后的文件的第一行内容。

另外一种做法是，使用 GNU sort 命令，它提供的=-R=选项可以随机排序文件：

#+BEGIN_EXAMPLE
    $ read -r random_line < <(sort -R file
#+END_EXAMPLE

或者，同前面一样，将结果赋值给变量：

#+BEGIN_EXAMPLE
    $ random_line=$(sort -R file | head -1)
#+END_EXAMPLE

这里，我们首先通过=sort -R=随机排序文件，然后通过=head -1=
读取文件的第一行。

**** 读取文件首行前三个字段并赋值给变量

#+BEGIN_EXAMPLE
    $ while read -r field1 field2 field3 throwaway; do
        # do something with $field1, $field2, and $field3
    done < file
#+END_EXAMPLE

如果在=read=命令中指定多个变量名，它会将读入的内容分隔成多个字段，然后依次赋值给对应的变量，第一个字段赋值给第一个变量，第二个字段赋值给第二个变量，等等，最后将剩余的所有字段赋值给最后一个变量。这也是为什么，在上面的例子中，我们加了一个=throwaway=变量，否则的话，当文件的一行大于三个字段时，第三个变量的内容会包含所有剩余的字段。

有时候，为了书写方便，可以简单地用=_=来替换=throwaway=变量：

#+BEGIN_EXAMPLE
    $ while read -r field1 field2 field3 _; do
        # do something with $field1, $field2, and $field3
    done < file
#+END_EXAMPLE

又或者，如果你的文件确实只有三个字段，那可以忽略它：

#+BEGIN_EXAMPLE
    $ while read -r field1 field2 field3; do
        # do something with $field1, $field2, and $field3
    done < file
#+END_EXAMPLE

下面是一个例子，假如你想知道一个文件到底包含多少行，多少个单词以及多少个字节。当你执行=wc=命令时，你会得到3个数字加上文件名，文件名在最后：

#+BEGIN_EXAMPLE
    $ cat file-with-5-lines
    x 1
    x 2
    x 3
    x 4
    x 5

    $ wc file-with-5-lines
     5 10 20 file-with-5-lines
#+END_EXAMPLE

所以，这个文件包含5行，10个单词，以及20个字符。我们接下来，可以通过=read=命令将这些信息保存到变量中：

#+BEGIN_EXAMPLE
    $ read lines words chars _ < <(wc file-with-5-lines)

    $ echo $lines
    5
    $ echo $words
    10
    $ echo $chars
    20
#+END_EXAMPLE

类似地，你也可以使用
[[http://linux.die.net/abs-guide/x15683.html][here-strings]]
将字符串分隔并保存到变量中。假设你有一个字符串变量=$info=，内容为="20 packets in 10 seconds"=，然后你想要将从中获取=20=和=10=。在不久之前，我是这样来完成的：

#+BEGIN_EXAMPLE
    $ packets=$(echo $info | awk '{ print $1 }')
    $ time=$(echo $info | awk '{ print $4 }')
#+END_EXAMPLE



然而，得益于=read=命令的强大和对 Bash 的了解，我们可以这样做：

#+BEGIN_EXAMPLE
    $ read packets _ _ time _ <<< "$info"
#+END_EXAMPLE

这里，=<<<= 就是 here-string 的语法，它允许你直接传递字符串给标准输入。

**** 保存文件的大小到变量

#+BEGIN_EXAMPLE
    $ size=$(wc -c < file)
#+END_EXAMPLE

这一行命令中用到了第3点中介绍的命令替换操作=$(...)=，它运行里面的命令并将结果获取回来。在这个例子中，命令是=wc -c < file=，它输出文件的字节数。这个结果最终会赋值给变量=size=。

**** 从文件路径中获取文件名

假设，你有一个文件，它的路径为=/path/to/file.ext=，然后你要从中获取文件名，在这里是=file.ext=。你要怎么做？
一个好的方法是通过参数展开（[[http://tldp.org/LDP/abs/html/parameter-substitution.html][parameter
expansion]]）功能：

#+BEGIN_EXAMPLE
    $ filename=${path##*/}
#+END_EXAMPLE

这一行命令使用了参数展开的语法：=${var##pattern}=，它从=$var=字符串开始处开始匹配=pattern=。如果能够匹配成功，将最长匹配的内容删除后再返回。

在这个例子中，匹配的模式是=*/=，它尝试匹配=/path/to/file.ext=的开始部分，正如前面所说，这里是贪婪匹配，所以它能够匹配到最后一个斜杠为止，即匹配的内容是=/path/to/=。所以当把匹配的内容删除后，返回的内容就是文件名=file.ext=。

**** 从文件路径中获取目录名

和上面一样类似，这次你要从路径=/path/to/file.txt=中获取目录名=/path/to=。你可以继续通过参数展开功能来完成这个任务：

#+BEGIN_EXAMPLE
    $ dirname=${path%/*}
#+END_EXAMPLE

这次的用法是=${var%pattern}=，它从=$var=的结尾处匹配=/*=。如果能够成功匹配，将最短匹配的内容删除再返回。

在这个例子中，匹配的模式是=/*=，它能够匹配=/file.ext=部分，删除这部分内容后返回的就是目录名称。

**** 快速拷贝文件

假设你要将文件=/path/to/fil=拷贝到=/path/to/file_copy=，一般情况下，大多数人会这么来写：

#+BEGIN_EXAMPLE
    $ cp /path/to/file /path/to/file_copy
#+END_EXAMPLE

不过，你可以利用括号展开（[[http://wiki.bash-hackers.org/syntax/expansion/brace][brace
expansion]]）={...}=功能:

#+BEGIN_EXAMPLE
    $ cp /path/to/file{,_copy}
#+END_EXAMPLE

括号展开可以生成任意字符串的组合，在这个例子中，=/path/to/file{,_copy}=最终生成=/path/to/file /path/to/file_copy=。所以上面这行命令最终发型成:

#+BEGIN_EXAMPLE
    $ cp /path/to/file /path/to/file_copy
#+END_EXAMPLE

类似地，你可以执行下面的命令快速的移动文件：

#+BEGIN_EXAMPLE
    $ mv /path/to/file{,_old}
#+END_EXAMPLE

这行命令展开后就变成了：

#+BEGIN_EXAMPLE
    $ mv /path/to/file /path/to/file_old
#+END_EXAMPLE

* LaTeX                                                               :LATEX:
# 需要整理
** fundermental
*** LaTeX简介                                                       :intro:
**** latex简史
***** LaTeX历史
1. 排版系统
   排版软件基本上可以分为两类:
   - 文字处理软件,如Word,所见即所得
   - 格式化排版程序,TeX
2. Tex
   1) What?
      TeX是由著名计算机专家D.E.Knuth(高纳德)研发的特别适合排版科技文献
      和书籍的格式化排版程序.
      TeX内核相当稳定,基本零bug,当前版本号3.141592
   2) 特点
      - TeX由Pascal语言编写
      - 开放源代码
      - 功能强大,几乎可以排版任何格式的文献
      - 对数学公式的排版是最好的
      - 支持命令宏,可扩展
      - 跨平台,可移植
      - 排版结果dvi文件与输出设备无关
      - TeX源码为文本文件
   3) What's LaTeX?
      TeX + 宏包,
      Leslie Lamport于1985年开发
   4) What's LaTex2e?
      优化内核的LaTeX
   5) 文稿产生过程
      + step 1: 编写源码文件
      + step 2: 使用latex命令编译文件
        源文件经过编译后,系统自动生成三个文件:
        - log文件:编译信息
        - aux文件:辅助信息
        - dvi文件::排版之后的格式化文件,设备无关,但包含字库信息
      + step 3: 输出成PS/PDF文件
**** latex的特点
**** latex的缺点
**** TeX,LaTeX,xeTeX与xeLaTeX
[[http://www.linuxidc.com/Linux/2012-05/61546.htm#printBody]]
1. LaTeX, TeX, xeLaTeX,xeTeX的关系
   *LaTeX* 是TeX的一种格式(format),是建立在TeX基础之上的宏语言,也就是说,
   每一个LaTeX命令实际上最后都会被解释转换成几个甚至上百个TeX命令.
   *XeTeX* 是一种使用Unicode的TeX排版引擎,并支持一些现代化字体技术,例如
   OpenType.其作者和维护者是Jonathan Kew,并以X11自由软件许可证发布.它
   原生支持UTF-8编码.XeTeX可以在不进行额外配置的情况下直接使用操作系统
   中安装的字体,因此可以直接利用OpenType,Graphite中的高级特性,例如额外
   的字形,花体,合体,可变的文本粗细等等.
   *XeLaTeX* 是使用LaTeX的排版引擎,命令行下直接使用 /xelatex *.tex/ 就
   会产生对应的PDF文件.
2. LaTeX和"所见即所得"排版工具的比较
   + 优点
     - 提供专业级的排版设计,使你的文档开起来如同印刷好的一样.
     - 可以更方便地排版数学公式
     - 用户仅仅需要掌握少数容易理解的,用来说明文档逻辑结构的命令,而无
       须对实际的页面设计做胡乱的修补.
     - 可以很容易的生成脚注,索引,目录和参考文献等复杂的结构.
     - 有大量的免费的可添加宏集,协助你完成许多基本的LaTeX未直接支持的
       排版任务.
     - LaTeX鼓励作者写作具有良好结构的文章,因为LaTeX就是通过详细地说明
       文章的结构进行排版工作的.
     - TeX作为LaTeX的格式化引擎是免费软件,且具有极高的可移植性,因此,它
       几乎可以在任何硬件平台上运行.
   + 缺点
     - 对于出卖灵魂的人来说,LaTeX不能很好地工作.
     - 尽管在预先定义好的版面中可以调节一些参数,设计全新的版面还是很困
       难的,需要耗费大量的时间.
     - LaTeX不适合于排版非结构化,无序的文档
     - 即使有一个令人振奋的开始,但你也有可能无法完全掌握其精髓.
3.
**** ctex中文套装简介
*** [[http://www.xuebuyuan.com/1673310.html][Latex之安装宏包]]                                  :blog:install:package:

宏包就是Latex发行版（TexLive、MikTex等）的插件功能，通过安装不同的宏包可以获得更多的功能。一般情况下，Latex的发行版都自带了一些宏包（多是[[http://ctan.org/][CTAN]]中的），以便于使用者快速的编译。这些宏包默认安装在texmf/tex/latex/下，这里texmf是“Tex
and MetaFont”的缩写，指代Latex发行版的目录树。以Windows
 7 下MikTex2.9为例，texmf=“D:\Program Files\MiKTeX
2.9\”。宏包的功能可以通过[[http://ctan.org/][CTAN]]的搜索功能查询到。


一个宏包往往包含一个文件或多个文件，这些文件利用Tex命令定义了新的命令，用来改变Latex默认的功能。这些文件主要有两种类型：clas文件，以.cls为后缀；类型文件，以.sty为后缀。其它类型的文件多是辅助文件。当编译一篇tex文档时，如果引用某个缺失的宏包时，编译[[http://www.xuebuyuan.com/][程序]]会报package
missing的错误。当然，这些宏包是可以更新的。一个Latex发行版理论上可以安装任意多的宏包，但是，一篇文档可以使用的宏包数目是受限制的。

     虽然　Latex发行版自带的宏包已经很多，并且自带的Package
Manager也能自动从CTAN上下载和安装宏包。但是，宏包的数量远比CTAN拥有的为多。所以，下面介绍下安装宏包的三种方式：

*1. 傻瓜式安装*


第一种方式比较简单，就是下载.cls或者.sty格式的文件，直接放在编译的目录下与主文件一起运行。这种方式简单易行，但是每次使用都要复制过去，更新也不易，如果使用几十个宏包，会使得编译目录里文件过多。只适合要使用期刊模板的情况。



*2. 自动安装*


目前，多数的Latex发行版都带有宏包管理器，如TexLive的tlmgr，MikTex的Package
Manager。对于TexLive，可以使用如下命令自动安装：

#+BEGIN_EXAMPLE
    tlmgr install <package1> <package2> ...
    tlmgr remove <package1> <package2> ...
#+END_EXAMPLE

对于MikTex，使用 Start -> All Programs -> MikTex ->
Settings(admin)，记得使用管理员模式来更改。



*3. 手动安装*


手动安装相对前两种方式要稍微复杂些。如果你下载的宏包里包含sty等格式的必需文件，说明宏包已经经过编译了，可以直接跳到第三步；如果没有，对于较复杂的包，一般包含五个步骤：

（a）*提取文件*：在下载的宏包里找到后缀名为.ins格式的文件，然后运行“latex
yourfilename.ins”命令或者用Latex发行版打开ins文件进行编译。此步骤可以从dtx格式的文件中提取制定的内容并生成需要的文件。

（b）*创建文档*：接着利用dtx文件创建说明文档，运行命令“latex
yourfilename.dtx”。此步骤可以创建一个dvi格式的说明文档，以说明该宏包的功能。

（c）*安装文件*：此步是最关键的一步，也是容易出错的一步。此步骤的作用是将生成的必需文件，如cls文件和sty文件放到合适的本地位置，以便Latex发行版能够找到。关键是如何定义合适的本地位置呢？在Tex及其衍生物中，所谓合适的本地位置，就是以TDS(Tex
Directory
Structure)规则组织的文件夹及其子文件夹，也就是一个自定义的目录。一般情况，这个自定义的目录最上层的名字为texmf-local或者texmf。在不同的发行版本下，具体也不一样：

- MacTex：Users/username/Library/texmf/.
- Unix-type Systems：~/texmf.
- MikTex：任意名字，但是子目录要满足一定的规则，具体规则在[[http://docs.miktex.org/manual/localadditions.html#id573803][这里]]。

TDS定义了不同类型的文件存放的位置不同。比如sty格式文件，一般放在texmf/tex/latex下不同的文件夹下，文件夹的名字即是宏包的名字。下面的表格中给出了文件存放的规则：

Where to put files from packages

Type

Directory (under =texmf/= or =texmf-local/=)

Description

.afm

fonts/afm//foundry///typeface/

Adobe Font Metrics for Type 1 fonts

.bst

bibtex/bst//packagename/

BibTeX style

.cls

tex/latex/base

Document class file

.dvi

doc

package documentation

.enc

fonts/enc

Font encoding

.fd

tex/latex/mfnfss

Font Definition files for METAFONT fonts

.fd

tex/latex/psnfss

Font Definition files for PostScript Type 1 fonts

.map

fonts/map/

Font mapping files

.mf

fonts/source/public//typeface/

METAFONT outline

.pdf

doc

package documentation

.pfb

fonts/type1//foundry///typeface/

PostScript Type 1 outline

.sty

tex/latex//packagename/

Style file: the normal package content

.tex

doc

TeX source for package documentation

.tex

tex/plain//packagename/

Plain TeX macro files

.tfm

fonts/tfm//foundry///typeface/

TeX Font Metrics for METAFONT and Type 1 fonts

.ttf

fonts/truetype//foundry///typeface/

TrueType font

.vf

fonts/vf//foundry///typeface/

TeX virtual fonts

others

tex/latex//packagename/

other types of file unless instructed otherwise

（d）*更新索引：*最后更新Latex发行版的索引文件，以便Latex发行版能找到新安装的宏包。不同的发行版使用了不同的索引器：

- teTeX, TeX Live, fpTeX：texhash.
- web2c: mktexlsr
- MacTeX: MacTeX appears to do this for you.
- MikTeX: initexmf --update-fndb；或者使用GUI，即Start -> All Programs
   -> MikTex -> Settings(admin)下第一个tab，点击“Refresh
   FNDB”按钮即可。

（e）*更新字体映射图：*如果一个宏包还顺带安装了一些字体，还应该更新字体的映射。详细方法参详[[http://www.tug.org/fonts/fontinstall.html][这里]]。

此外，还有一些老版本的宏包并没有参照TDS格式，因此只能使用前两种方式。



此文参考了Wikibooks[[http://en.wikibooks.org/wiki/LaTeX/Installing_Extra_Packages][Latex]]和[[http://tex.stackexchange.com/][stackexchange]]上的一些讨论。

*** LaTeX基础
**** 源文件的结构
   #+BEGIN_EXAMPLE
     \documeen{class}
        导言
     \begin{document}
        主体正文
     \end{document}
   #+END_EXAMPLE


   LaTeX源文件是一个纯文本文件必须包含导言部分(preamble)和主体部分
   (body).
   导言部分通常是一些命令的集合,它们定义了文稿的整体结构,比如文稿的格
   式,版面的高度和宽度,行距和缩格,页面及页码的形式,页眉页脚旁注的形式
   等.导言至少要包含\document命令,它定义了文稿的类型是书本文章还是其它
   形式.导言的命令具有整体效能.

**** 命令
1. 命令
   1) 由命令前导符"\textbackslash{}"加若干字母组成,字母区分大小写,终止于空格、数字或
      其它非字母符号。
   2) 或由命令前导符“\textbackslash{}”加一个特殊符号
   3) LaTeX命令忽略之后的所有空白. *{}*
   4) 命令参数置于{}中
**** 文类
1. 源文件类型
   #+BEGIN_EXAMPLE
     \document[options]{class}
   #+END_EXAMPLE

   1) 类型class
      - article 文章
      - report  报告
      - book    书本
      - letter  书信
      - slider  幻灯片
   2) 选项options
      参数选项之间使用逗号隔开
      - 10pt, 11pt, 12pt  字体大小,默认10pt
      - a4paper,letterpaper  纸张尺寸
      - fleqn  数学公式左对齐
      - leqno  数学公式标号放在左边
      - titlepaper,notitlepaper  标题后是否另起一页
      - twocolumn  双栏
      - twoside,oneside 双面/单面
      - openright,openany  新的一章从右页开始/左右
**** 宏包
   #+BEGIN_EXAMPLE
     /usepackage[options]{package}
   #+END_EXAMPLE
**** 模式
**** 符号
***** 保留字符
|------+-------------------------------+-------------------------------------------------------|
| 字符 | 说明                          | 输出命令                                              |
|------+-------------------------------+-------------------------------------------------------|
| $    | 进入退出数学模式              | \textbackslash{}$                                     |
| &    | 表格中分割行的列线            | \textbackslash{}&                                     |
| %    | 注释符号                      | \textbackslash{}%                                     |
| #    | #1,...,#9用来定义命令参数个数 | \textbackslash{}#                                     |
| _    | 下标                          | \textbackslash{}_                                     |
| {    | 分组起始                      | \textbackslash{}{                                     |
| }    | 分组结止                      | \textbackslash{}}                                     |
| ~    | 不可断行的空格                | \textbackslash{}~{} or \textbackslash{}textasciitilde |
| ^    | 下标                          | \textbackslash{}^ or \textbackslash{}textasciicircum  |
|------+-------------------------------+-------------------------------------------------------|

**** 长度设置
1. 长度
   在LaTeX中经常用到长度的概念.最简单的长度是一个进制数(可正可负)加上
   一个长度单位.
   常用的长度单位
    |----+------+---------------|
    | mm | 毫米 | 1mm~=1/25in   |
    | cm | 厘米 | 1cm=10mm      |
    | in | 英寸 | 1in=25.4mm    |
    | pt | 点   | 1pt=1/72.27in |
    | bp | 大点 | 1bp=1/72in    |
    | pc | pico | 1pc=12pt      |
    | em |      | 大写字母M高度 |
    | ex |      | 小写字母x高度 |
    |----+------+---------------|
    *\textbackslash{}fill*
    *\textbackslash{}strench{n}*
    *\textbackslash{}newlength{\textbackslash{}cmd}*
    *\textbackslash{}setlength{\textbackslash{}cmd}{长度}*
    *\textbackslash{}addtolength{\textbackslash{}cmd}{长度}*
**** 盒子
**** 计数器
**** 交叉引用
**** 环境
***** 环境语法:
#+BEGIN_EXAMPLE
   \begin{env} some-text \end{env}
#+END_EXAMPLE
e.g.
   - center/flushleft/flushright  居中,左对齐,右对齐
   - quote
   - math
   - itemise  列表
   - tabular  表格
   - figure   图形
   环境支持嵌套
***** 浮动环境
1. 浮动环境
   1) figure 图
   2) table 表
2. 语法
   #+BEGIN_EXAMPLE
     \begin{figure}[位置选项]
     插图命令或绘图环境
     \caption[目录标题内容]{标题内容}
     \end{figure}
   #+END_EXAMPLE
   #+BEGIN_EXAMPLE
     \begin{table}[位置选项]
     \caption[目录标题内容]{标题内容}
     表格环境
     \end{table}
   #+END_EXAMPLE
3. 位置选项
   + h: here
   + t: top
   + b: bottom
   + p: page of float
   + !:
***** DONE TeX 诗歌抄录
- State "DONE"       from "TODO"       [2015-03-02 一 22:41]
- State "TODO"       from ""           [2015-02-28 六 15:33]

诗歌环境 *verse* 也是一种引用环境,其中文本两端也都有相同宽度的缩进.
#+BEGIN_EXAMPLE
  \begin{verse}
  Line 1st \\
  Line 2nd \\
  \end{verse}
#+END_EXAMPLE

\begin{verse}
In me, past, present, future meet,\\
To hold long chiding conference.\\
My lusts usurp the present tense,\\
And strangle Reason in his seat.\\
My loves leap through the future's fence\\
To dance with dream-enfranchised feet.\\
In me the cave-man clasps the seer,\\
And garlanded Apollo goes\\
Chanting to Abraham's dear ear.\\
In me the tiger sniffs the rose.\\
Look in my heart, kind friends, ant tremble.\\
Since there your elements assemble.\\
\end{verse}
***** 抄录环境
1. latex
   #+BEGIN_EXAMPLE
   \begin{verbatim} ... \ end{verbatim}
   \begin{verbatim*} ... \ end{verbatim*}
   #+END_EXAMPLE
   两者的不同之处在于后者将空格显式显示出来
   #+BEGIN_EXAMPLE
   \verb  将较短的一行原封不动的显示出来
   \verb*
   #+END_EXAMPLE
***** 音标
#+BEGIN_SRC latex
\LaTeX 中音标的输入是通过调用\textbf{tipa}宏包实现的.\\
\indent \textbf{\textbackslash usepackage{tipa}}\footnote{该宏包可能与
  其它宏包有所冲突,需适当调整位置}\\
如果是在xeLaTeX 中使用tipa宏包,则需要在导言中加入
\textbf{\textbackslash setmainfont\{Times New Roman\}}或其它能将西文字体设置为
Times New Roman的命令,否则某些音标符号将无法显示.

\begin{tabular}{|l|l|l|l|l|l|}
  \hline
  音标 & \LaTeX 表达式 & 音标 & \LaTeX 表达式 & 音标 & \LaTeX 表达式\\
  \hline
  \i & \textbackslash i & \textdyoghlig & \textbackslash textdyoghlig
                                              & \textscripta &
                                                               \textbackslash textscripta \\
  \ae & \textbackslash ae & \textturnv & \textbackslash textturnv
                                              & \dh & \textbackslash
                                                      dh \\
  \j & \textbackslash j & \textschwa & \textbackslash textschwa &
                                                                  \textepsilon &
                                                                                 \textbackslash textepsilon \\
  \textdzlig & \textbackslash textdzlig & \textscriptg &
                                                         \textbackslash
                                                         textscriptg
                                              & \textopeno &
                                                             \textbackslash textopeno \\
  \textesh & \textbackslash textesh & \texttheta & \textbackslash
                                                   texttheta &
                                                               \textyogh
                                                     & \textbackslash
                                                       textyogh \\
  \textteshlig & \textbackslash textteshlig & \textupsilon &
                                                             \textbackslash
                                                             textupsilon
                                              & \ng & \textbackslash
                                                      ng \\
  \textprimstress(重音) & \textbackslash textprimstress &
                                                          \textsecstress(
                                                          次重
                                                          音) &
                                                                \textbackslash
                                                                textsecstress&
                                                                               \textlengthmark
                                                     & \textbackslash textlengthmark\\
  \hline

\end{tabular}

上表未列出的音标大多可以直接由键盘输入而不需要任何\LaTeX 指令,或者可由
以上音标的\LaTeX 表达式组合拼接而成.

另外,在英文文章也经常出现一些字母上面加两个点的字母,例如
Sch\"o{}dinger(薛定谔),na\"i{}ve等,这也可由\LaTeX 实现.

\begin{tabular}{ll}
  \hline
  \"o & \textbackslash "o \\
  \"i & \textbackslash "i \\
  \"u & \textbackslash "u \\
  \hline
\end{tabular}

\textbf{注}:反斜杠\textbackslash 后面的一定是\textbf{英文标点的双引号}.

以上仅仅是英语普遍使用的音标符号,其它IPA(国际音标符号)的\LaTeX 表达式
请参考tipa宏包的说明文档\textbf{tipaman.pdf(texlive安装目录中包含宏包
  的说明文档,学会搜索使用)}.
#+END_SRC
**** 注释
% 行注释
环境comment,来自vebatim包.
**** 加减乘除
**** 条件判断
**** 注释与提示
**** 颜色
***** 颜色
#+BEGIN_SRC latex
使用颜色可以显著提高论文的表达能力和阅读效果.由于历史原因\LaTeX 本身不具备颜色处理能力,故而需要调用Uwe Kern编写的颜
色宏包\textbf{xcolor},具有以下特性:
\begin{itemize}
\item 支持多种颜色模式
\item 可生成任意颜色
\item 可以对各种文本元素的前景(文字,线条等)和背景分别着色.
\end{itemize}

\begin{enumerate}
\item 颜色模式

  \begin{itemize}
  \item \textbf{灰度模式gray}

    \textbf{[gray]\{0.75\}},\textbf{xcolor}中灰度范围0\~{}1.

  \item \textbf{三基色模式rgb}

    \textbf{[rgb]\{0.75,0.5,0.25\}},基色(red,green,blue)比例范围0\~{}1.

  \item \textbf{三基色模式RGB}

    \textbf{[RGB]\{191,127,64\}},基色范围0\~{}255.

  \item 四分色模式cmyk

    \textbf{[cmyk]\{0,0,1,0.5\}},基色(青色cyan,红紫色magenta,黄色
    yellow,黑色black)比例范围0\~{}1.
  \end{itemize}


\item 颜色宏包的选项
  \begin{itemize}
  \item dvipsnames,调用颜色定义文件dvipsnam.def,其中定义了68种cmyk颜
    色.
  \item svgnames,调用颜色定义文件svgnam.def,其中定义了151种rgb颜色.
  \item x11names,调用颜色定义文件x11nam.def,其中定义了317种rgb颜色.
  \item table,自动调用彩色表格宏包colortbl,并可使用xcolor提供的表格行
    背景颜色命令 \textbackslash rowcolors.
  \end{itemize}


\item 颜色的定义
  常用颜色有:\textcolor{red}{red} \textcolor{green}{green},
  \textcolor{blue},\textcolor{yellow}{yellow},\textcolor{black}{black},\textcolor{gray}{gray}
  等.

  \textbf{\textbackslash{}definecolor\{颜色\}\{模式\}\{定义\}}用于定义
  新的颜色,如\\
  \textbackslash{}definecolor\{mycolor\}\{gray\}\{.65\}


\item 颜色表达式

  \textbf{颜色1!百分比1!颜色2!百分比2!...}按照比例混合颜色.


\item 颜色使用命令

  \begin{itemize}
  \item \textbf{color}

    \textbf{\textbackslash{}color\{颜色\}}和 \textbf{\textbackslash{}color\{模
      式\}\{定义\}}声明颜色命令可改变其后的各种文本元素,如文本,标题,线段,
    表格和数学公式等.


  \item \textbf{textcolor}

    \textbf{\textbackslash{}textcolor\{颜色\}\{对象\}}和 \textbf{\textbackslash{}textcolor[模
      式]\{定义\}\{对象\}}将参数对象(文本,标题,线段,表格,数学公式等)设置为一定
    颜色.

  \item \textbf{colorbox}

    \textbf{\textbackslash{}colorbox\{颜色\}\{对象\}} 和 \textbf{\textbackslash{}colorbox[模
      式]\{定义\}\{对象\}}为对象设置背景颜色.

    \textbf{\textbackslash{}fcolorbox\{边框颜色\}\{背景颜色\}\{对象\}} 和
    \textbf{\textbackslash{}fcolorbox[模式]\{边框颜色定义\}\{背景颜色定义\}\{对象\}},同时
    设置边框颜色.


  \item \textbf{pagecolor}

    \textbf{\textbackslash{}pagecolor\{颜色\}}和 \textbf{\textbackslash{}pagec[模式]\{定义\}}用于
    设置其后的页面背景颜色.

  \item \textbf{normalcolor}

    \textbf{\textbackslash{}normalcolor{}}命令将字体颜色转变为导言最后定义的字体颜
    色.

  \end{itemize}

\end{enumerate}

#+END_SRC
**** \LaTeX 中的长度                                              :length:

1. tex中的长度
   + *mm*    毫米
   + *cm*    厘米
   + *in*    英寸＝2.54cm＝72.27pt
   + *pt*    点(默认)
   + *em*    大写字母m的宽度
   + *ex*    小写字母x的高度

2. 参考
   + [[https://app.yinxiang.com/shard/s52/nl/11551545/2732e9a9-3a82-48d9-8610-796c092ae88b?title=latex%e5%91%bd%e4%bb%a4%e9%80%9f%e6%9f%a5%e6%89%8b%e5%86%8c-fruitfly1026-chinaunix%e5%8d%9a%e5%ae%a2][blog]]

*** 文件后缀                                                         :后缀:
**** 配置文件

|----+------------------------------------|
|.afm| Adobe Type1字体描述文件,ASCII格式。|
|.bak| 备份文件,当源文件.tex存盘时由系统自动创建。|
|.bib| 文献数据库。|
|.cfg| 供类包或宏包调用的配置文件。|
|.cls| 稿件类型文件,可用命令\documentclass调用。|
|.doc| 类包或宏包的说明文件。|
|.dtx| 包含类或宏包及其说明文件的文件,需用同名.ins文件或docstrip工具分解。|
|.fd| 字体定义文件,定义某一字族,用于L A TEX字体寻找。|
|.ins| 同名.dtx的分解文件,用PDFL A TEX编译,可得到sty或cls等类型文件。|
|.map| 字体名称与.tfm文件之间的字体映射文件。|
|.mbs| 主控文件,包含全部文献样式命令,用于生成.bst文献样式文件。|
|.mf| METAFONT字体描述文件,Knuth教授创立的矢量字体。|
|.pfa| Type 1字体文件,ASCII格式,一种高品质矢量字体,越放大越清晰。|
|.pfb| Type 1字体文件,二进制格式。|
|.pk| pk字体,一种点阵字体,用于dvi文件预览等。|
|.pl| 字体属性列表,可读的字体描述文件。|
|.sfd| 子字库定义文件。|
|.sty| 宏包文件,可用命令\usepackage调用。|
|.tex| L A TEX源文件。|
|.tfm| 字体描述文件,设定字体的宽、高和间距等,L A TEX用以规划页面。|
|.ttf| Truetype字体,Windows系统使用的一种全真字体。|
|.vf| TEX虚拟字体|
|.vpl| 虚拟属性列表,可读的虚拟字体文件。|
|----+----------------------------------|

**** 编译文件

|------+---------------------------------------------------------------------|
| .aux | 引用标记记录文件,用于再次编译时生成参考文献和超链接等。             |
| .bbl | 由BibTEX编辑.bib后创建的文献文件,再次编译时带入源文件生成文献列表。 |
| .blg | BibTEX处理过程记录文件。                                            |
| .dbj | 批处理文件,由makebst工具在创建.bst文献样式文件时生成。              |
| .dvi | 由L A TEX对.tex源文件编译后创建的输出文件,含有字库信息。            |
| .glo | 术语标记记录文件,用于再次编译时生成术语表。                         |
| .idx | 索引资料记录文件,可用makeindex排序后创建索引文件.ind。              |
| .ilg | makeindex处理过程记录文件。                                         |
| .ind | makeindex对.idx排序后创建的索引文件,再次编译时带入源文件生成索引。  |
| .lof | 图形标题记录文件,用于再次编译时生成图形目录。                       |
| .log | 编译过程记录文件,记录编译时出现的提示、警告和错误信息。             |
| .lot | 表格标题记录文件,用于再次编译时生成表格目录。                       |
| .pdf | 由PDFL A TEX对.tex或dvipdf对.dvi或pspdf对.ps编译后创建的图形文件。  |
| .ps  | 由dvips对.dvi文件编译后创建的图形文件。                             |
| .toc | 章节标题记录文件,用于再次编译时生成章节目录。                       |
|------+---------------------------------------------------------------------|

** 字体
*** 字体的属性
*** 字体设置命令
*** 字体尺寸命令
*** 局部字体修改
*** 常用字族
*** 字体定义文件
*** 字体属性命令
*** 全文字体修改
*** 中文字体
*** 任意尺寸字体
** 颜色                                                        :definecolor:

*** [[http://blog.sina.com.cn/s/blog_5c13e0f40101coih.html][怎么在Latex文件中对文本加颜色]] :blog:

在编Latex文件的过程中，为了对一些修改后的文本标注出，需要对其加颜色。
刚开始利用书上指导的，要什么【模式】{符号}等，总也弄不出来，发现用最简
单的就可以了。比如：我要对“I love you”加注为红色。首先，在最前面的导
言区输入命令 \usepackage{color}，然后，在需要加注颜色的处输入
{\color{red}{I love you}}，最外面的大括号是只对“I love you”加注红色，
如果没有这个大括号的话，那会对后面所有的文本加颜色。如果要对公式加注颜
色，只需要将文字“I love you”换成公式的命令就可以了，如：要对公式A（x）
加颜色，输入{\color{red}{$A（x）$}}就可以了。

** 标题
*** 论文题名
*** 层次标题
*** 层次标题格式的修改
*** 图表标题
*** 图表标题格式的修改
** 表格
*** 无框线表格环境tabbing
在LaTeX系统中,提供了两种方法将数据以行和列的形式整齐地排列,一种是利用
*tabbing* 环境,另一种是利用 *tabular* 和 *array* 环境.

|------------------------+---------------------------------|
| *\=*                   | 设置第一行TAB站点               |
| *\>*                   | 设置后续行TAB站点               |
| \\                     | 换行                            |
| \textbackslash{}kill   | 替换首行换行符,使该行内容不显示 |
| \textbackslash{}hspace | 设置列宽                        |
| \textbackslash{}'      | 右对齐                          |
|------------------------+---------------------------------|
   tabbing环境可以创建各式各样的表格,如果与盒子结合起来使用也可以创建
   带框的表格,但使用起来十分复杂.LaTeX提供了tabular,tabular*和array环
   境,实现各种有框和无框表格.

*** tabular
   \textbackslash{}begin{tabular}[位置]{列格式}表格行 \textbackslash{}end{tabular}
   \textbackslash{}begin{tabular*}[宽度][位置]{列格式}表格行 \textbackslash{}end{tabular*}
   \textbackslash{}begin{array}[位置]{列格式}表格行 \textbackslash{}end{array}

   + 位置:表格与表格之外文字在垂直方向的对齐方式,t,c,b
   + 列格式
     |--------------+--------------|
     | l            | 左对齐       |
     | c            | 居中对齐     |
     | r            | 右对齐       |
     | p{width}     |              |
     | 单坚线       | 画一条垂直线 |
     | 双坚线       | 画两条垂直线 |
     | @{文本}      | @-表达式     |
     | *{num}{cols} | 重复格式     |
     |--------------+--------------|
   + 表格行
     每一行使用换行符//来结束,每一行的不同列使用&分开
     |----------------------------+--------------------------------|
     | \textbackslash{}hline                     | 插入一条水平线,须置于u两行之间 |
     | \textbackslash{}cline{n-m}                | 第n列到第m列画一条水平线       |
     | \textbackslash{}multicolumn{n}{col}{文本} | 文本占据n列                    |
     | \textbackslash{}vline                     | 画一条与行等高的垂直线         |
     |----------------------------+--------------------------------|
*** 数组宏包array
*** 跨行表格宏包multirow
*** 跨页表格宏包iongtable
*** 多页表格宏包supertabular
*** 可调列宽表格宏包tabularx
*** 表格线宏包booktabs
*** 小数点对齐宏包dcolumn
*** 对角线宏包slashbox
*** 彩色表格宏包colortbl
*** 颜色宏包xcolor的行颜色命令
*** 表格的整体缩放
*** 表格的使用
** 列表
*** 常规列表
*** 排序列表
*** 解说列表
*** 嵌套列表
*** 列表宏包paralist
*** 通用列表环境list
*** 通用列表环境trivlist

** 插图
*** 图形的种类
#+BEGIN_SRC latex
  图形存储的格式很多，一般可以分为两大类：\textbf{位图图形}和\textbf{向量图形}。
  \begin{itemize}
  \item 位图图形：即点阵图形，技术上称栅格图形。相关术语：分辨率，色深，无损/有损压缩。
  \item 向量图形：使用数学公式定义的线段和曲线定义的图形，分辨率无关。
  \end{itemize}
  \textbf{注}：计算机显示器只能用网格显示图像，所以不论位图还是向量图，在屏幕上均以像素的方式显示图形。
  位图和向量图的区别：
  \begin{itemize}
  \item 分辨率相关与否。
  \item 存储空间大小，位图存储的是像素的位置和色深，向量图存储的是各种向量的算法。
  \item 位图适合复杂的图形和照片，向量图适合工程设计图等。
  \end{itemize}

  \LaTeX 直接支持的图形格式：
  \begin{itemize}
  \item \textbf{EPS}
  \item \textbf{PS}
  \item \textbf{JPG}
  \item \textbf{PNG}
  \item \textbf{PDF}
  \end{itemize}
#+END_SRC
*** 图形的插入
A picture is worth thousand words.一图胜千言：一幅图形可以简单明确地表达很多错综复杂、千言万语都难以描述的事物信息。另一方面，有些文字传达的意境和感受是图形难以替代的，如“大漠孤烟直，长河落日圆”。所以，\textbf{一篇优秀的论文应该图文并茂，相得益彰}。

\LaTeX 宏包可以绘制复杂的图形，但不直观。通常会先使用强大的可视绘图工具把图形画好，然后插入到\LaTeX 源文件中。
#+END_SRC
**** graphicx
1. 宏包: graphicx
2. 命令: includegraphics
3. 格式:
   #+BEGIN_EXAMPLE
     \includegraphics[参数1=选项, 参数2=选项,...]{图形文件}
   #+END_EXAMPLE
4. 选项
   1) 外形
      + height
      + weight
      + scale: 负值表示同时旋转180度
      + angle: 正逆
      + origin: 旋转中心
   2) 裁切
      + viewport
      + trim
   3) 开关
      + keepaspectratio
      + clip
      + draft
      + final

**** 图形插入
#+BEGIN_SRC latex
  插图宏包：\textbf{graphicx}。最常用的插图命令是：
  \begin{center}
\begin{verbatim}
\includegraphics[参数选项]{插图}
\end{verbatim}
  \end{center}

  其中，插图包括扩展名。可选参数包括外形参数、裁切参数和布尔参数。
  \begin{itemize}
  \item 由于插图命令既不会结束当前行也不会结束当前段，所以可以把图形插入到某一段落的文本行内。
\begin{verbatim}
这是行内插图\includegraphics{linux-logo.jpg}，不好。
\end{verbatim}
    这是行内插图\includegraphics[scale=0.3]{/home/ben/Picture/logo/linux-logo.jpg}，不好。

  \item 无论是在段落之中还是段落之间，通常应该将插图置于单独一行之中。
\begin{verbatim}
\begin{center}
  \includegraphics{/home/ben/Picture/logo/linux-logo.jpg}
\end{center}
\end{verbatim}
    \begin{center}
      \includegraphics[scale=0.3]{/home/ben/Picture/logo/linux-logo.jpg}
    \end{center}

  \item 论文中每幅都应在其前的正文中明确提及，即每幅插图的序号都应在其前的正文中被引用。因此，插图都是置于图形浮动环境，这样可使用图表标题命令为插图生成带有序号的标题，也可以在该命令中使用交叉引用命令，还可以将插图标题编入插图目录。
\begin{verbatim}
图\ref{fig:1}是JPG格式的图形。
\begin{figure}[!ht]
  \centering
  \includegraphics{/home/ben/Picture/logo/linux-logo.jpg}
  \caption{插图标题}
\end{figure}
\end{verbatim}
    图是JPG格式的图形。
    \begin{figure}[!ht]
      \centering
      \includegraphics[scale=0.3]{/home/ben/Picture/logo/linux-logo.jpg}
      \caption{插图标题\label{fig:1}}
    \end{figure}
  \end{itemize}
#+END_SRC
*** 图文绕排
*** 页面背景
*** 图形处理
*** 浮动体组
*** DONE 数学图形 一份不太简短的LaTeX介绍 P76
- State "DONE"       from "TODO"       [2015-11-06 五 10:02]
basic environment : *picture*.
extension package: *epic*, *eepic*, *pstricks*
Graphical tool: *MetaPost*(a user's manual for metapost)

**** picture
#+BEGIN_EXAMPLE
\setlength{\unitlength}{5cm}
\begin{picture}(x, y)...\end{picture}
\begin{picture}(x, y)(x0, y0)...\end{picture}
#+END_EXAMPLE

- x, y: rectuangular space
- x0, y0: bottom left corner, optional

#+BEGIN_EXAMPLE
\put(x, y){object}
\multiput(x, y)(dx, dy){n}{object}
\qbezier{x1, y1}{x2, y2}{x3, y3}
#+END_EXAMPLE



**** Line segments
#+BEGIN_EXAMPLE
\put(x, y){\line(x1, y1){length}}
#+END_EXAMPLE
- a direction vector
- a length

[[/home/ben/Wally/Journal/Figure/scrot/20724lvg.png]]

**** arrows
#+BEGIN_EXAMPLE
\put(x, y){\vector(x1, y1){length}}
#+END_EXAMPLE

[[/home/ben/Wally/Journal/Figure/scrot/20724Yla.png]]

**** circles
#+BEGIN_EXAMPLE
\put(x, y){\circle{diameter}}
#+END_EXAMPLE
- center: x, y
- diameter: /diameter/
- circle* : filled circle

[[/home/ben/Wally/Journal/Figure/scrot/20724LbU.png]]

**** text and formulas

[[/home/ben/Wally/Journal/Figure/scrot/20724-QO.png]]

**** multiput
#+BEGIN_EXAMPLE
\multiput(x, y)(dx, dy){n}{object}
#+END_EXAMPLE
- starting point
- translation vector
- number
- object

**** oval
#+BEGIN_EXAMPLE
\put(x, y){\oval(w, h)}
\put(x, y){\oval(w, h)[position]}
#+END_EXAMPLE
- center: x, y
- width: w
- height: h
[[/home/ben/Wally/Journal/Figure/scrot/20724y5m.png]]

**** multiple use of Predefined pictures boxes
#+BEGIN_EXAMPLE
\newsavebox{name}
\savebox{name}(with, height)[position]{content}
\put(x, y)\usebox{name}
#+END_EXAMPLE
[[/home/ben/Wally/Journal/Figure/scrot/20724_Dt.png]]

**** quadratic Bezeer Curves

[[/home/ben/Wally/Journal/Figure/scrot/20724MOz.png]]

**** XY-pic
*drawing diagrams*
#+BEGIN_EXAMPLE
\usepackage[options]{xy}
#+END_EXAMPLE

** 正文
*** 摘要
*** 目录
*** 脚注
*** 尾注
*** 边注
#+BEGIN_SRC latex
  边注与脚注功能类似，都是对正文内容解释补充。不同在于位置不同，字体与正文相同，没有序号。

  边注使用命令

  \begin{verbatim}
  \marginpar[左边注释]{右边注释}
  \end{verbatim}


  单页/双页以及双栏排版时的使用和注释位置不同。

  边注的第一行与边注命令所在行平齐，即基线对齐。

  边注宽度有限，应简短明确，比如只是一个符号。

  边注中可以使用图表。

#+END_SRC
*** 索引
*** 术语表

*** 链接
*** 行号
*** 附录
** 编译
*** 编译方法
*** 宏包安装
*** 文件类型说明
*** 错误信息与警告信息
*** 子源文件
#+BEGIN_SRC latex
参考:<LaTeX2e完全学习手册> P419-P421
对于中长篇论文,最好采用\textbf{主源文件与子源文件的模块方式}进行组织管
理.

\textbf{\textbackslash{}include\{子源文件名\}}命令将子源文件调入到主源
文件中.子源文件的扩展名是.tex,在包含命令中可以省略.子源文件不需要导言,
通常是以章命令\textbackslash{}chapter开头的源文件.

\textbf{\textbackslash{}input{文件名}}命令可以将子源文件\textbf{或其它
  文件调入到主源文件中},如果是子源文件则扩展名.tex可以省略,否则文件必
须带有扩展名.

\textbf{\textbackslash{}includeonly\{子源文件1,子源文件2...\}}在导言中
使用,选择子源文件对编译进行控制,即只编译指定子源文件.命令中指定的子源
文件必须在正文中由命令include包含.相比注释掉其它子源文件的方法,使用该
命令支持交叉引用等.

\textbackslash{}include与\textbackslash{}input命令的区别\\
\begin{tabular}{ll}
  \hline
  \textbackslash{}include & \textbackslash{}input\\
  \hline
  只能在正文中使用 & 正文导言均可\\
  新起一页 & 不起新页\\
  编译为子源文件输出.aux & 编译时无.aux文件输出\\
  不能嵌套,但可改用\textbackslash{}input命令 & 可以嵌套,也可以包含
                                               \textbackslash{}include
                                               命令\\
  命令 \textbackslash{}includeonly对其有效 & 无效\\
  只能调用.tex子源文件 & 同时可以调用其它文件\\
  调入子源文件后还要另起新页 & 不起新页\\
  没有找到子源文件,只给出警告信息 & 中止编译,提示错误\\
  \hline
\end{tabular}

通常\textbackslash{}include命令仅用在主源文件正文中调入章或节的子源文
件,\textbackslash{}input命令则比较灵活.
#+END_SRC
**** 长文件的编写

在编写有许多章节的长篇书本或文章时,一个比较好的方法是分别编写各章节并
把它们保存在不同的文件中,然后在LaTeX中调用这些文件.不需要将这些文件分
别编译,LaTeX会将它们放入源文件中一并处理.

#+BEGIN_EXAMPLE
\include{filename}
#+END_EXAMPLE

filename不包含扩展名
LaTeX编译时会另起新页

#+BEGIN_EXAMPLE
\includeonly{filename1,filename2}
#+END_EXAMPLE

该命令必须用在源文件的导言部分.
文件名与逗号之间不能有空格.

#+BEGIN_EXAMPLE
\input{filename}
#+END_EXAMPLE

不另起新页
文件名可以包含扩展名.
*** 命令的脆弱与坚强
*** 宏包冲突
*** 文件合并
*** 编译技巧
** 浮动体
*** 浮动体的控制参数
*** 浮动体的位置调整
*** [[http://blog.sina.com.cn/s/blog_57132a730100phfw.html][定义自己的浮动体]] :blog:

对于浮动体的认识，很多初学者觉得比较困难，主要是平时接触不到这个概念。

浮动体可以比作是一个可以在文章里移动的盒子，不同的盒子里面放的东西略有
差异。为什么移动？这个问题很多朋友询问，说简单点，就是为了排版的美观。
为什么浮动（移动）了就可以排版得美观了。

在使用字处理软件排版时，使用者可以让图形准确出现在放置的位置。但是，因
为这些图形不能被分割开来，所以经常会导致糟糕的分页，将大片的空白留在页
面下方。为得到专家级的排版效果，作者不得不手工调整图形的位置。这种工作
是非常乏味的，尤其是几乎每次修改文档都得这样做一次。

为了既能得到专家级的排版效果，又不必手工做调整图形位置的乏味的工作，
LATEX 提供了一个浮动图形机制来自动将图形放置到合适的位置。这一机制是非
常有效的。不过，它也会给那些习惯于手工调整图形的新手带来麻烦。

---选自《latex插图指南》

另外，它还有其他好处：

1. 在浮动环境中，图片或者表格等等需要浮动的内容可以自动编号。
2. 浮动体内容可以被引用和放入目录中。
3. 排版更加美观。

如何创建一个自己的浮动环境呢？

如下示例：

#+BEGIN_SRC latex
  \documentclass[12pt]{article}
  \usepackage{float}
  \newfloat{Eq}{H}{eqn}
  \begin{document}
  \begin{Eq}
    \begin{equation}
      y=f(x)
    \end{equation}
    \caption{my first equation}
  \end{Eq}
  \begin{Eq}
    \begin{equation}
      y=f(x)
    \end{equation}
    \caption{my second equation}
  \end{Eq}
  \listof{Eq}{list of  equations}
  \end{document}
#+END_SRC

** 版面设计
*** 版面
**** 版面
#+BEGIN_SRC latex
\begin{enumerate}
\item 版面设计

  \LaTeX 版面设计复杂而精细。

版面图示宏包layout中\textbackslash layout命令可在命令处生成当前版面位置及尺寸的示意图。

版面设置宏包geomtry
\begin{verbatim}
  \usepackage[text={140mm,240mm}]{geometry}
\end{verbatim}
\item 多栏排版
  \textbackslash onecolumn 单栏命令
  \textbackslash twocolumn 双栏命令
\item 页眉和页脚
  \LaTeX 系统提供4种版式
  \begin{itemize}
  \item empty 页眉和页脚为空
  \item plain 页眉为空，页脚中间是页码
  \item headings 页眉内容为页码和节标题
  \item myheadings 格式与headings一致，内容自定义
  \end{itemize}
  使用\textbf{\textbackslash pagestyle\{版式\}}设定版式。
  使用\textbf{\textbackslash thispackage\{版式\}}设定当前页版式。
\end{enumerate}
#+END_SRC
*** 文本格式
**** DONE [#B] 上划线怎么输入?
DEADLINE: <2015-03-15 日>
- State "DONE"       from "TODO"       [2015-03-17 二 11:22]
- State "TODO"       from ""           [2015-03-04 三 14:29]
 Date:<2015-02-27 五>
 Link:[[file:~/Tiger/DTL/TODO.org::*]] (Y/N)

 Math Accent
 \begin{math}
 \bar{abv}
 \end{math}

 Note: \textbackslash{}bar 命令仅能在math环境中使用, 而且只支持单个字
  母, 多个字母则居中.

**** 空白
+ *\textbackslash{}hspace{length}*
+ *\textbackslash{}hspace**
+ *\textbackslash{}vspace*
+ *\textbackslash{}vspace**
**** 下划线
#+BEGIN_SRC latex
\begin{itemize}
\item 系统命令\\
 \textbf{\textbackslash underline{文本}} 不能中断。
\item 宏包ulem
  \begin{itemize}
  \item \textbackslash uline{下划线}
  \item \textbackslash uuline{双下划线}
  \item \textbackslash uwave{波浪下划线}
  \item \textbackslash sout{删除线}
  \item \textbackslash xout{删除线}
  \end{itemize}

\item 宏包CJKfntef
  宏包ctex使用选项\textbf{fntef}
  \begin{itemize}
  \item \textbackslash CJKunderdot{点}
  \item \textbackslash CJKunderline{下划线}
  \item \textbackslash CJKunderdblline{双下划线}
  \item \textbackslash CJKunderwave{波浪线}
  \item \textbackslash CJKsout{删除线}
  \item \textbackslash CJKxout{删除线}
  \end{itemize}
  除此之外，CJKfntef提供了六条颜色命令
  \begin{itemize}
  \item \textbackslash CJKundercolor
  \item \textbackslash CJKunderdbllinecolor
  \item \textbackslash CJKunderlinecolor
  \item \textbackslash CJKsoutcolor
  \item \textbackslash CJKxoutcolor
  \item \textbackslash CJKunderwavecolor
  \end{itemize}
  默认圆点和取消线为红色，其它为蓝色。需要在ctex前调用宏包xcolor。
\begin{verbatim}
\renewcommand{\CJKunderline}{\color{color}}
\end{verbatim}
  可重定义颜色。
\end{itemize}
#+END_SRC
*** 多栏排版
*** 版式——页眉与页脚                                            :footprint:
**** [[http://www.ctex.org/documents/latex/graphics/node59.html][在页眉和页脚使用图形]]                                  :blog:fancyhdr:

在页眉和页脚使用图形的一个最容易的方法是使用 fancyhdr（它是旧的
fancyheadings 的增强版本）。 fancyhdr 的用法和宏包说明详见文献 [[[http://www.ctex.org/documents/latex/graphics/node119.html#fancyhdr][12]]]
。在 L^ATEX 文档中，页眉由左、中、右三部分组成。  \fancyhead 命令指
定了页眉的形式和内容，并以 L,C,R  区分左、中、右区域。例如：

#+BEGIN_EXAMPLE
\pagestyle{fancy}
\fancyhead[C]{我的文档}
#+END_EXAMPLE

使得页眉的中间部分印出`` 我的文档''，而

#+BEGIN_EXAMPLE
\pagestyle{fancy}
\fancyhead[L,R]{\textbf{Confidential}}
#+END_EXAMPLE

使得页眉的左右都印出``Confidential''。如果没有指定 L,C,R 中的任何一
个，那么由 \fancyhead 定义的内容将在三个区域中都会印出。相似地，\
fancyfoot 则用来定义页脚的左、中、右三个区域。可以利用 fancyhdr 宏
包中的命令来在页眉和页脚上使用图形。例如，在用第 [[http://www.ctex.org/documents/latex/graphics/node58.html#sec:defps][15.1]] 节的方法将
 EPS 文件 file.eps 分为 file.h 和 file.ps 后，下面的命令

#+BEGIN_EXAMPLE
\documentclass{article}
\usepackage{fancyhdr,graphicx}
\renewcommand{\headheight}{0.6in}% must be large enough for graphic
\renewcommand{\textheight}{7.5in}

% Define PostScript graphics command
\special{header=file.h}

% Save graphics in LaTeX box
\newsavebox{\mygraphic}
\sbox{\mygraphic}{\includegraphics[totalheight=0.5in]{file.ps}}
\pagestyle{fancy}
\fancyhead{} % clear all header fields
\fancyhead[L]{\usebox{\mygraphic}}
\fancyfoot{} % clear all footer fields
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\begin{document}
  ...
\end{document}
#+END_EXAMPLE

将图形放置在每一使用 ``fancy'' 风格页的左上角，并且下面有一条宽为
 0.5pt  的横线。此外，每页的页角的中央放置页码，但它的上方没有横线
。这些设置不会影响 ``plain'' 风格的页面。当使用 [twoside] 排版选项
时，经常希望在奇数页和偶数页设置不同页眉和页脚，这时可使用  O,E 选
项来区分奇数页和偶数页。如果没有给出  O,E 选项，则页眉和页脚的命令
会应用到所有的页面中，无论是奇数页还是偶数页。例如：

#+BEGIN_EXAMPLE
\pagestyle{fancy}
\fancyhead[LE]{我的文章}
\fancyhead[RO]{我的名字}
\fancyfoot[C]{\thepage}
#+END_EXAMPLE

在偶数页的左上角放置我的文章，在奇数页的右上角放置我的名字，页脚的
中央则放置页码。而命令

#+BEGIN_EXAMPLE
\pagestyle{fancy}
\fancyhead[LE,RO]{\usebox{\mygraphic}}
\fancyfoot[C]{\thepage}
#+END_EXAMPLE

使得偶数页的左上角和奇数页的右上角印出图形。 \fancyhead 命令只对那
些页面式样为 ``fancy'' 的页面起作用。即使用 \pagestyle{fancy} 将文
档的页面式样设置为 ``fancy'' 式样，一些页面，如封面，目录和每章的第
一页仍为缺省的 ``plain'' 式样。改变 Plain'' 页面式样的缺省设置可用
\fancypagestyle 命令来实现。例如将下面的命令加到上面的例子中可使得
封面，目录等的页眉上也将会有图形印出。

#+BEGIN_EXAMPLE
\fancypagestyle{plain}{%
  \fancyhead{} % clear all header fields
  \fancyhead[L]{\usebox{\mygraphic}}
  \fancyfoot{} % clear all footer fields
  \fancyfoot[C]{\thepage}
  \renewcommand{\headrulewidth}{0.5pt}
  \renewcommand{\footrulewidth}{0pt}}
#+END_EXAMPLE

当使用 [twoside] 排版选项时，将上面的

#+BEGIN_EXAMPLE
\fancyhead[L]{\usebox{\mygraphic}}
#+END_EXAMPLE

替换为

#+BEGIN_EXAMPLE
\fancyhead[LE,RO]{\usebox{\mygraphic}}
#+END_EXAMPLE

则在每一页的页眉上都放置上图形。

** 命令                                                                :cmd:
*** =\relax=                                                        :relax:
[[https://app.yinxiang.com/shard/s52/nl/11551545/aab18c55-3eab-42d6-ae48-6fb594474634?title=what%20is%20the%20difference%20between%20%5crelax%20and%20%7b%7d%3f][stackexchange: relax and {}]]

[[http://tex.stackexchange.com/questions/96501/what-does-relax-do][stackexchange： what does relax do?]]

it is what's called a *no-op*: it does nothing, and it's used in various
places where you don't want anything done, but the syntax requires
something. tex's rules also dictate that in an =\if= statement, an
undefined macro will compare equal to =\relax=. so it's sort of a
general-purpose nothing.


=\relax= does nothing by itself, it is a safe command to stop
expansion of another command. some examples:

+ (plain tex) =\hskip 5pt\relax=
  in the absence of =\relax=, the =\hskip= will keep looking for plus
  or minus

+ (latex) at the end of a line, =\\ \relax [...]=
  will prevent what is in braces from being interpreted as a dimension
  that would add vertical space

*** \textbackslash{}newenvironment                         :newenvironment:

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\newenvironment{envname}[narg]{def1}{def2}
\end{minted}
#+end_latex

defines a new environment,  optionally with some number of arguments
*narg*. *def1* is executed when the environment is entered and *def2*
is executed when it is exited.

*** \LaTeX 名字命令                                          :renewcommand:
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \renewcommand{\contentsname}{目\qquad 录}
  \renewcommand\listfigurename{插\ 图\ 目\ 录}
  \renewcommand\listtablename{表\ 格\ 目\ 录}
  \renewcommand\bibname{参\ 考\ 文\ 献}
  \renewcommand{\figurename}{图}
  \renewcommand{\tablename}{表}
  \end{minted}
#+end_latex

*** \textbackslash{}setlength                                   :setlength:

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\setlength{\nl}{length}
\end{minted}
#+end_latex

sets value of length command *\textbackslash{}nl* to *length*

+ 参考
  - [[file:~/document/programming/tex/latex%e5%91%bd%e4%bb%a4%e9%80%9f%e6%9f%a5%e6%89%8b%e5%86%8c.pdf::trailer%0d<<%0d/size%20122%0d/info%20116%200%20r%20%0d/root%20115%200%20r%20%0d/prev%20304023%20%0d/id%5b<34f5bfc030aea1e56aea670e2be665ff><c4ee31aa4c02bc5316e5a8813d952c58>%5d%0d>>%0dstartxref%0d308437%0d%25%25eof%0d][latex命令速查手册]]

*** \textbackslash{}newcommand                                 :newcommand:

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\newcommand{\cs}[narg]{def}
\end{minted}
#+end_latex

define a new control sequence *\textbackslash{}cs* with defintion *def*.

optionally,  /narg/ is the number of arguments,  indicated in *def* as
#1,  #2, etc.

+ 参考
  [[file:~/document/programming/tex/latex%e5%91%bd%e4%bb%a4%e9%80%9f%e6%9f%a5%e6%89%8b%e5%86%8c.pdf::trailer%0d<<%0d/size%20122%0d/info%20116%200%20r%20%0d/root%20115%200%20r%20%0d/prev%20304023%20%0d/id%5b<34f5bfc030aea1e56aea670e2be665ff><c4ee31aa4c02bc5316e5a8813d952c58>%5d%0d>>%0dstartxref%0d308437%0d%25%25eof%0d][latex命令速查手册]]
*** \textbackslash{}definecolor                               :definecolor:
*** \textbackslash{}renewcommand                             :renewcommand:

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\renewcommand{\cs}[narg]{def}
\end{minted}
#+end_latex

redefines an existing control sequence *\textbackslash{}cs*  with
definition *def*

optionally,  /narg/ is the number of arguments,  indicated in *def* as
#1, #2, etc.

*** \textbackslash{}parindent                                   :parindent:

*paragraph indent*

horizontal indentation added at the begining of paragraph.

*** \textbackslash{}floatsep                                     :floatsep:

*float seperation*

distance between floats that appear at the top or bottom of a text
page

*** self defined conditions                                         :newif:

you can create new conditionals (as a kind of boolean variables) with
the *\textbackslash{}newif* command. with this self defined conditionals you can
control the output of your code in an elegant way. the best way to
illustrate the use of conditionals is through an example.

two versions of a document must be generated. one version for group a
the other one for the rest of people (i.e. not belonging to group a):

1. we use \textbackslash{}newif to define our conditional
   (i.e. boolean variable).
   #+begin_latex
   \begin{minted}[frame=single, mathescape]{latex}
   \newif\ifgroupa
   \end{minted}
   #+end_latex

2. in the following way we set a value (true or false) for our
   conditional
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{latex}
       \groupatrue % or
       \groupafalse
       that is:

       \<conditionalsname>true
       \<conditionalsname>false
     \end{minted}
   #+end_latex
   depending on which value we want to set in our conditional.

3. now we can use our conditional anywhere after in an if control
   structure.
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{py}
       \ifgroupa
       % here we write the code of the document that is
       % intended for the group a
       \else
       % here we write the code of the document that is
       % intended for the rest of the people
       \fi
     \end{minted}
   #+end_latex

   a full example is:
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{py}
     \newif\ifdirector

     %i set the conditional to false
     \directorfalse

     \ifdirector
      i write something for the director.
     \else
      i write something for common people.
     \fi
     \end{minted}
   #+end_latex

   i write something for common people.

4. 参考
   + [[https://en.wikibooks.org/wiki/latex/plain_tex][wikibook:latex]]

** 数学式                                                 :math:fomula:公式:

在科技论文中经常要用到分式,根式,行列式和微积分方程以及证明,定理等数学
表达式,统称为 *数学式*.TeX 就是因数学式而生,LaTeX 就是为数学式而长,排
版数学式乃是 LaTeX 的最强项,而且是越复杂越能显示出它的优越性.再辅以相
关的数学宏包,尤其是 *amsmath* 公式宏包,将大幅地扩充 LaTeX 的排版功能,
使排版效果更为精美和专业.

*** 数学模式
在 LaTeX 中最常用的模式主要有文本模式和数学模式. *数学模式* 又可分
为 *行内公式(inline math)* 和 *行外公式(display math)*.

**** 行内公式
LaTeX 提供了三种方法编写行内公式
: (1) $ ... $
: (2) \textbackslash{}(... \textbackslash{})
: (3)\textbackslash{}begin{math}...\textbackslash{}end{math}

#+BEGIN_SRC latex
$y^{2}=2px$
\(y^{2}=2px\)
\begin{math} y^{2}=2px \end{math}
#+END_SRC

三种方法的排版结果完全相同,第一种方法比较常用,因为它 *性格坚强*.

如果行内公式较长,系统会在=,>,<等关系符和+,-等二元符处自动换行.

花括号中的数学式无法中断换行,只能完整地从左到右排列,直到凸进右边空.

在换行位置附近若无二元符,行内公式也无法中断.
**** 行间公式
LaTeX 提供三种方法编写行间公式.
#+BEGIN_EXAMPLE
(1) \$\$...\$\$
(2) \textbackslash{}[...\textbackslash{}]
(3) \textbackslash{}begin{displaymath}...\textbackslash{}end{displaymath}
#+END_EXAMPLE

三种方法排版效果相同,第三种使用环境变命令,起止明确.

*注:在数学模式中不能有空行或\par换段命令,否则系统将提示出错*

*** 常用数学宏包
+ 宏包套件ams
+ 公式宏包 *amsmath*
+ 宏包套件amsfonts
+ 宏包套件mh

*** 常用数学宏包
*** 数学符号
**** DONE 加减号怎么输入?
DEADLINE: <2015-03-15 日>
- State "DONE"       from "TODO"       [2015-03-17 二 11:16]
- State "TODO"       from ""           [2015-03-04 三 14:29]
 Date:<2015-02-27 五>

 \textbackslash{}pm

 \pm
注: \textbackslash{}pm 是 LaTeX中的命令, 但从org导出为tex会"变成"
\textbackslash{}textpm, pdf结果一致, 但不明所以.
**** TeX 数学符号列表
参考:

Note: 自己输入
***** Hebrew(希伯来) letter
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669dYH.png}
\end{center}
***** 希腊字母
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669qiN.png}
\end{center}

\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/136693sT.png}
\end{center}
***** LaTeX binary relation(二元关系)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669RBg.png}
\end{center}
***** AMS binary relations(二元关系)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669eLm.png}
\end{center}

\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/136694fy.png}
\end{center}

***** AMS negate binary relation
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669qpB.png}
\end{center}

***** binary operation(二元操作)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/136693zH.png}
\end{center}
+ The first part contains the binary operations in LaTeX.
+ The second part requires the latexsym package
+ The third part contains the AMD addition. They requires the amssymb
  package.
+ The symbol \textbackslash{}And requires the amsmath package
***** Arrows(箭头)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669E-N.png}
\end{center}
+ The top part contains the symbols provided by LaTeX. The last
  command, \textbackslash{}leadsto, requires the latexsym package
+ The middle table contain the AMS arrows. They require the amssymb
  package.
+ The bottom table lists the negated arrow symbols. They require
  amssymb.
***** Miscellaneous symbols
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669RIU.png}
\end{center}
***** Math spacing commands
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669eSa.png}
\end{center}
***** Delilmiters(定界符)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669rcg.png}
\end{center}

\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/136694mm.png}
\end{center}
***** Operators(操作符)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669Fxs.png}
\end{center}

\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669S7y.png}
\end{center}

***** Math accents
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669EFC.png}
\end{center}
***** Math font commands
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669RPI.png}
\end{center}

**** TeX 文本符号列表
***** Spectial text characters(保留字符)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669eZO.png}
\end{center}
***** Text accents
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669rjU.png}
\end{center}
***** Some European characters(欧洲字符)
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/136694ta.png}
\end{center}
***** Extra text symbol
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669F4g.png}
\end{center}
***** Text spacing commands
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669SCn.png}
\end{center}
***** Text font commands
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669fMt.png}
\end{center}
***** Text font size changes
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669sWz.png}
\end{center}
***** AMS text font size changes
\begin{center}
\includegraphics[width=.7\linewidth]{/home/ben/Wally/Journal/Figure/scrot/13669egC.png}
\end{center}

*** 公式环境
*** 矩阵环境
*** 定理环境
*** 交换图
*** 数学字体
*** 精细调整
*** 单边大括号
#+BEGIN_EXAMPLE
  \left\{
      \begin{array}{l}
        r=\alpha(R+\omega) \\
        l=\alpha\cdot R
      \end{array}
    \right.
#+END_EXAMPLE
*注意right后面的句点，不可以缺少。*
*** 公式组与多行公式                                                   :多行公式:
**** 公式组 eqarray
[[/home/ben/Wally/Journal/Figure/scrot/3297vLy.png]]

[[/home/ben/Wally/Journal/Figure/scrot/3297hVB.png]]
**** 多行公式 align

align*不生成公式序号

[[/home/ben/Wally/Journal/Figure/scrot/3297ufH.png]]
*** 梯度                                                                 :梯度:

=\nabla=

** LaTeX拾遗

*** 数学宏包amsmath要在ctex宏包后面包含，否则会出现错误，不知为何

*** Typesetting Mathematical Formulae
**** inline & within a paragraph
1. inline
   + \textbackslash{}(...\textbackslash{})
   + $...$
   + \textbackslash{}begin{math}...\textbackslash{}end{math}
2. within a paragraph
   + \textbackslash{}[...\textbackslash{}]
   + \textbackslash{}begin{displaymath}...\textbackslash{}end{displaymath}
   + \textbackslash{}{equation}...\textbackslash{}{equation}
     + enumerate
     + refer
     #+BEGIN_SRC latex :exports both
     \begin{equation}
     \label{eq:eps}
     \epsilon > 0
     \end{equation}
     From (\ref{eq:eps}), we gather \ldots{}
     From \eqref{eq:eps}, we do the same.
     #+END_SRC
3. difference in typesetting style between equations that are typeset
   and those that are displayed
   + typeset
     #+BEGIN_SRC latex :exports both
       $\lim_{n \to \infty}
       \sum_{k=1}^n \frac{1}{k^2}
       = \frac{\pi^2}{6}$
     #+END_SRC
   + display
     #+BEGIN_SRC latex :exports both
       \begin{displaymath}
         \lim_{n \to \infty}
         \sum_{k=1}^n \frac{1}{k^2}
         = \frac{\pi^2}{6}
       \end{displaymath}
     #+END_SRC

**** difference between /math mode/ and /text mode/
+ Most space and line breaks do not have any significance, as all
  spaces are either logically from the mathematical expressions, or
  have to be specified with special command such as \textbackslash{},,
  \textbackslash{}quad or \textbackslash{}qquad.
+ Empty lines are not allowed. Only one paragraph per formulas
+ Each letter is consider to be the name of a variable and will be
  typeset as such. If you want to typeset normal text with in a
  formular(normal upright and normal spacing) then you have to enter
  the text using the \textbackslash{}textrm{...} commands.
  #+BEGIN_SRC latex :exports both
    \begin{equation}
      \forall x \in \mathbf{R}: \qquad x^{2} \geq 0
    \end{equation}
  #+END_SRC

  #+RESULTS:
  #+BEGIN_LaTeX
  \begin{equation}
    \forall x \in \mathbf{R}: \qquad x^{2} \gep 0
  \end{equation}
  #+END_LaTeX

  #+BEGIN_SRC latex :exports both
    \begin{equation}
      x^{2} \geq 0\qquad \textrm{for all } x \in \mathbf{R}
    \end{equation}
  #+END_SRC

  #+RESULTS:
  #+BEGIN_LaTeX
  \begin{equation}
    x^{2} \geq 0\qquad \textrm{for all} x \in \mathbf{R}
  \end{equation}
  #+END_LaTeX

*** TeX 宏包安装

http://www.xuebuyuan.com/1673310.html

1. 傻瓜式安装

   下载.cls或者.sty格式的文件，直接放在编译的目录下与主文件一起运行。

2. 宏包管理器
   + TeXLive: tlmgr
     + $ tlmgr install <pkg> ...
     + $ tlmgr remove <pkg> ...
   + MikTeX
3. 手动安装

   手动安装相对前两种方式要稍微复杂些。如果你下载的宏包里包含sty等格式
   的必需文件，说明宏包已经经过编译了，可以直接跳到第三步；如果没有，
   对于较复杂的包，一般包含五个步骤：

   1) 提取文件

      在下载的宏包里找到后缀名为.ins格式的文件，然后运行“latex
      yourfilename.ins”命令或者用Latex发行版打开ins文件进行编译。此步
      骤可以从dtx格式的文件中提取制定的内容并生成需要的文件。

   2) 创建文档

      接着利用dtx文件创建说明文档，运行命令“latex yourfilename.dtx”。
      此步骤可以创建一个dvi格式的说明文档，以说明该宏包的功能。

   3) 安装文件
      此步是最关键的一步，也是容易出错的一步。此步骤的作用是将生成的必
      需文件，如cls文件和sty文件放到合适的本地位置，以便Latex发行版能
      够找到。

      在Tex及其衍生物中，所谓合适的本地位置，就是以 *TDS* (Tex
      Directory Structure)规则组织的文件夹及其子文件夹，也就是一个自定
      义的目录。一般情况，这个自定义的目录最上层的名字为texmf-local或
      者texmf。在不同的发行版本下，具体也不一样.

      TDS定义了不同类型的文件存放的位置不同。比如sty格式文件，一般放在
      texmf/tex/latex下不同的文件夹下，文件夹的名字即是宏包的名字。下
      面的表格中给出了文件存放的规则：

      |--------+---------------------------------+---------------------------------------|
      | Type   | Directory (under texmf/         | Description                           |
      |        |  or texmf-local/)               |                                       |
      |--------+---------------------------------+---------------------------------------|
      | .afm   | fonts/afm/foundry/typeface      | Adobe Font Metrics for Type 1 fonts   |
      | .bst   | bibtex/bst/packagename          | BibTeX style                          |
      | .cls   | tex/latex/base                  | Document class file                   |
      | .dvi   | doc                             | package documentation                 |
      | .enc   | fonts/enc                       | Font encoding                         |
      | .fd    | tex/latex/mfnfss                | Font Definition files for METAFONT    |
      | fonts  |                                 |                                       |
      | .fd    | tex/latex/psnfss                | Font Definition files for PostScript  |
      |        |                                 | Type 1 fonts                          |
      | .map   | fonts/map/                      | Font mapping files                    |
      | .mf    | fonts/source/public/typeface    | METAFONT outline                      |
      | .pdf   | doc                             | package documentation                 |
      | .pfb   | fonts/type1/foundry/typeface    | PostScript Type 1 outline             |
      | .sty   | tex/latex/packagename           | Style file: the normal package        |
      |        |                                 | content                               |
      | .tex   | doc                             | TeX source for package documentation  |
      | .tex   | tex/plain/packagename           | Plain TeX macro files                 |
      | .tfm   | fonts/tfm/foundry/typeface      | TeX Font Metrics for METAFONT and     |
      |        |                                 | Type 1 fonts                          |
      | .ttf   | fonts/truetype/foundry/typeface | TrueType font                         |
      | .vf    | fonts/vf/foundry/typeface       | TeX virtual fonts                     |
      | others | tex/latex/packagename           | other types of file unless instructed |
      |        |                                 | otherwise                             |
      |--------+---------------------------------+---------------------------------------|

   4) 更新索引

      最后更新Latex发行版的索引文件，以便Latex发行版能找到新安装的
      宏包。不同的发行版使用了不同的索引器.

   5) 更新字体映射图

      如果一个宏包还顺带安装了一些字体，还应该更新字体的映射[[http://www.tug.org/fonts/fontinstall.html][here]].

*** latex 宏包编写与解包
**** 编写宏包
1. 目的: 广泛传播和正确使用并便于他人修改完善
2. 要求: 包程序应当易于阅读
   1) 在编写宏包时，总要先说明编写的原因、目的和用途，
   2) 然后开始编写具体宏命令程序；
   3) 在一些繁琐复杂的内部命令处，附加详细的注释；
   4) 专门提供给用户使用的命令或环境，都给出使用说明，
   5) 或举例说明使用方法。
3. 最终写成的宏包文件是合三为一的程序说明文件，这种编程方式被称作文学
   化编程.
   + 宏命令程序
   + 程序说明
   + 使用说明
4. 应用
   在实际应用中
   + 有些人出于研究借鉴的目的对这种合成文件很感兴趣
   + 有些人只想看看该宏包的说明
   + 更多的人只关心宏包的使用。
**** 辅助编写的工具宏包
1. *doc*: 编写宏包文件的宏包，它定义了一组宏包文件编辑环境和命令
2. *ltxdoc*: 用于排版 LaTeX 源文件的类型文件包
3. *docstrip*: 文件分解工具，定义了一组文件输入和分类创建命令。
**** 使用
1. 文件后缀说明
   1) *.dtx*: 包含类或宏包及其说明文件的文件，需用同名.ins文件或
      docstrip工具分解。
   2) *.ins*: 同名.dtx的分解文件，用PDFLATEX编译，可得到sty或cls等类型
      文件。
   3) *.sty*: 宏包文件，可用命令 \textbackslash{}usepackage调用。
   4) *.cls*: 稿件类型文件，可用命令 \textbackslash{}documentclass调用。
   5) *.cfg*: 供类包或宏包调用的配置文件
   6) *.bib*: 文献数据库
2. 生成说明文档

   *$ pdf file.dtx*

   运行 PDFLaTeX 编译 iuthesis.dtx，得到 iuthesis.pdf，用 Adobe 打开，
   这是一篇包括 iuthesis 类包程序及其说明的程序说明文件，说明章节和每
   行命令都有分类序号，这既便于程序阅读又不影响日后程序或说明的修改升
   级。有些复杂的程序说明文件还有目录、索引和术语表等，也就是说 LaTeX
   的所有功能都可以在此体现。

3. 仅类包的说明文字

   在dtx文件导言区加入 \textbackslash{}OnlyDescription 命令，再用
   PDFLaTeX 编译dtx文件，得到的pdf文件中就只有该类包的说明文字了。

4. 生成宏包命令程序

   1) 调用 docstrip 工具，分解dtx文件。运行 latex docstrip

   2) 用 PDFLaTeX 对其编译ins文件，就会自动创建类包文件cls文件。

      其实*.ins 安装文件的内容非常简单，主要就两句话.

   3) 说明

      很多大型程序说明文件的源文件.dtx 含有类包程序.cls、宏包程序
      .sty、说明或格式程序.tex 和配置程序.cfg 等多种程序，使用.ins
      安装文件的好处就在于它能够一次性自动地完成对.dtx 文件的分类重建
      工作。本例就同时还分解出 iuthesis.tex，经编译后得到的 PDF 文件中
      只有该类包的说明。

      很多数情况.dtx 和.ins 都是成对出现的；如果找不到.ins，可以打
      开.dtx 文件，根据里面的各种程序界定标记，使用第一种方法手工解包。
      现在有很多.dtx 文件已将.ins 的内容并入其中，这样用 PDFLaTeX 对
      其编译，就会自动同时创建出程序说明文件.pdf 和宏包文件.sty 或类
      包文件.cls 等相关文件。

*** DONE latex2html: LaTeX 转成 Word
DEADLINE: <2015-03-08 日>
- State "DONE"       from "waiting"    [2015-03-09 一 19:45] \\
  掌握基本使用,有待研究细节,参考手册,了解常用控制选项的使用
- State "waiting"    from ""           [2015-02-26 四 15:00] \\
  latex2html安装文件太大,需要返校之后安装.
参考:
+ [[http://zhidao.baidu.com/link?url=81iKOAaTCNYG0-Wej-I2TwGNHmTBytvj7M6GeEpb1KdHWqUE1eqLyQtYcdZqjtnlc97r3bSZyg1ZEAOAsORhuox3q33i3PdbEug-d2AmX6u][百度知道]]
+ [[http://bbs.ctex.org/forum.php?mod=viewthread&tid=7861][ctex latex2html中文]]
+ [[http://www.latex2html.org/][latex2html HOMEPAGE]]

**** why
论文给导师修改又产生了很多麻烦。PDF上直接加Note可读性很差。最好还是能
尽量保持公式、图形、Reference的完整性，然后直接转成Word，然后导师在
Word上用审阅模式修改，我们自己在Latex对应修改。这样导师就不用面对丑陋
的Latex源码了。
**** how
简单的说，我们可以这样做：
1) 我们用Latex书写论文
2) 我们转成Word给导师
3) 导师使用Word的审阅功能，修改论文
4) 我们对照修改的地方直接修改Latex
5) 最后生成修改后的PDF。

以Ubuntu的Linux系统如下：
1. 安装Latex: sudo apt-get install texlive
2. 安装latex2html: sudo apt-get install latex2html
3. 把论文从Latex转换为html: *latex2html -split +0 input.tex*
   (input.tex是我们的论文tex文件)
4. 这时在当前目录下多出一个input目录，大家可以弄到Windows里。（相信大
   家都有一个Linux的远程机器）
5. 这个目录就是所有的html文件，找到index.html，右键用Word打开。
6. 在word里另存为.doc或者docx文件。
7. 把word文档发给导师，等那些让人心惊肉跳的红字和note吧。。。

大功告成，这样比Acrobat Pro转为word文档在格式上更加安全。所有公式、图
片、表格、算法都会被变为图片或者相应格式，在word里显示没有任何问题。

(注意：使用这种办法，要求你的tex可以在latex编译出dvi没有问题，也就是说
使用eps图片的没有问题，但是使用pdf，jpg图片格式的，由于使用pdflatex命
令编译出PDF。这个方法就不行了，需要手动改一下html文件)。

（EPS[fn:1502261439]图片问题，我一般使用ImageMagic去批处理的转jpg，pdf
到eps，然后在tex文件里引用eps图片，这样就规避了无论用pdflatex或者latex
都可以编译出正确的pdf和dvi，那么Latex2html就没有任何问题了）

**** latex2html
***** what
LATEX2HTML is a convertor written in Perl that converts LATEX
documents to HTML. This way e.g. scientific papers - primarily typeset
for printing - can be put on the Web for online viewing.

LATEX2HTML does also a good job in rapid web site deployment. These
pages are generated from a single LATEX source.

It is designed to run on UNIX-like systems (e.g. Linux, Solaris, IRIX,
Dec Unix, HP-UX, AIX) as well as Windows (95, 98, NT)
***** 下载
+ A Perl program
+ translates LATEX into HTML
+ optionally creating separate HTML files corresponding toeach unit
  (e.g., section) of the document.

LATEX2HTML proceeds by interpreting LATEX (to the best of its
abilities). It contains definitions from a wide variety of
classes and packages, and users may add further definitions by
writing Perl scripts that provide information about
class/package commands.
[[http://www.ctan.org/pkg/latex2html/][ctan:latex2html]]
***** 使用
****** 中文问题
直接使用命令行 *latex2html src.tex* 生成的html文档存在中文乱码的问题,
需要进行设置.
latex2html支持中文: CJK 和 Ctex。
+ 在工作目录下建立文件 “.latex2html-init”
+ 在其中写入： *$charset = gb2312*
+ 2. 增加一些编译选项(注:不加也行):
  *latex2html -iso_language CN -html_version 4.0,unicode src.tex*
+ 注意另一个微妙的事情：若你的源文件是在DOS/Windows 所写的，空行可能不
  被识别为段分割。你可以使用 dos2unix把你的源文件处理一下。

*** DONE LaTeX 转成 Word
DEADLINE: <2015-03-08 日>
- State "DONE"       from "waiting"    [2015-03-10 二 00:59]
- State "waiting"    from ""           [2015-02-26 四 15:00] \\
  latex2html安装文件太大,需要返校之后安装.
参考:
+ [[http://zhidao.baidu.com/link?url=81iKOAaTCNYG0-Wej-I2TwGNHmTBytvj7M6GeEpb1KdHWqUE1eqLyQtYcdZqjtnlc97r3bSZyg1ZEAOAsORhuox3q33i3PdbEug-d2AmX6u][百度知道]]
+ [[http://blog.sina.com.cn/s/blog_4d72d6e70100otue.html][latex2html配置windows下]]
+ [[http://www.latex2html.org/][latex2html HOMEPAGE]]

**** why
论文给导师修改又产生了很多麻烦。PDF上直接加Note可读性很差。最好还是能
尽量保持公式、图形、Reference的完整性，然后直接转成Word，然后导师在
Word上用审阅模式修改，我们自己在Latex对应修改。这样导师就不用面对丑陋
的Latex源码了。
**** how
简单的说，我们可以这样做：
1) 我们用Latex书写论文
2) 我们转成Word给导师
3) 导师使用Word的审阅功能，修改论文
4) 我们对照修改的地方直接修改Latex
5) 最后生成修改后的PDF。

以Ubuntu的Linux系统如下：
1. 安装Latex: sudo apt-get install texlive
2. 安装latex2html: sudo apt-get install latex2html
3. 把论文从Latex转换为html: *latex2html -split +0 input.tex*
   (input.tex是我们的论文tex文件)
4. 这时在当前目录下多出一个input目录，大家可以弄到Windows里。（相信大
   家都有一个Linux的远程机器）
5. 这个目录就是所有的html文件，找到index.html，右键用Word打开。
6. 在word里另存为.doc或者docx文件。
7. 把word文档发给导师，等那些让人心惊肉跳的红字和note吧。。。

大功告成，这样比Acrobat Pro转为word文档在格式上更加安全。所有公式、图
片、表格、算法都会被变为图片或者相应格式，在word里显示没有任何问题。

(注意：使用这种办法，要求你的tex可以在latex编译出dvi没有问题，也就是说
使用eps图片的没有问题，但是使用pdf，jpg图片格式的，由于使用pdflatex命
令编译出PDF。这个方法就不行了，需要手动改一下html文件)。

（EPS[fn:1502261439]图片问题，我一般使用ImageMagic去批处理的转jpg，pdf
到eps，然后在tex文件里引用eps图片，这样就规避了无论用pdflatex或者latex
都可以编译出正确的pdf和dvi，那么Latex2html就没有任何问题了）

**** latex2html
***** what
LATEX2HTML is a convertor written in Perl that converts LATEX
documents to HTML. This way e.g. scientific papers - primarily typeset
for printing - can be put on the Web for online viewing.

LATEX2HTML does also a good job in rapid web site deployment. These
pages are generated from a single LATEX source.

It is designed to run on UNIX-like systems (e.g. Linux, Solaris, IRIX,
Dec Unix, HP-UX, AIX) as well as Windows (95, 98, NT) systems.

>>>>>>> f82386b584a83dd6cc85a4bedd2ca78f13409ffc
*** ctan                                                             :ctan:

+ [[http://www.ctan.org/][Ctan homepage]]

CTAN是“Comprehensive TeX Archive Network”的首字缩写，为世界上最主要
的TeX资源集散网站，搜集了关于TeX的各种文件与软件等等。Perl的资源集散网
站CPAN即是基于CTAN的模式诞生与运作。

*** LaTeX PDF 动画                                               :pdf:动画:
+ http://pages.uoregon.edu/noeckel/PDFmovie.html
+ http://bbs.ctex.org/forum.php?mod=viewthread&tid=38009

*** TeX 文件后缀说明
**** 配置文件

|------+----------------------------------------------------------------------|
| .afm | Adobe Type1字体描述文件，ASCII格式。                                 |
|------+----------------------------------------------------------------------|
| .bak | 备份文件，当源文件.tex存盘时由系统自动创建。                         |
|------+----------------------------------------------------------------------|
| .bib | 文献数据库。                                                         |
|------+----------------------------------------------------------------------|
| .cfg | 供类包或宏包调用的配置文件。                                         |
|------+----------------------------------------------------------------------|
| .cls | 稿件类型文件，可用命令\documentclass调用。                           |
|------+----------------------------------------------------------------------|
| .doc | 类包或宏包的说明文件。                                               |
|------+----------------------------------------------------------------------|
| .dtx | 包含类或宏包及其说明文件的文件，需用同名.ins文件或docstrip工具分解。 |
|------+----------------------------------------------------------------------|
| .fd  | 字体定义文件，定义某一字族，用于 \LaTeX 字体寻找。                   |
|------+----------------------------------------------------------------------|
| .ins | 同名.dtx的分解文件，用PDF \LaTeX 编译，可得到sty或cls等类型文件。    |
|------+----------------------------------------------------------------------|
| .map | 字体名称与.tfm文件之间的字体映射文件。                               |
|------+----------------------------------------------------------------------|
| .mbs | 主控文件，包含全部文献样式命令，用于生成.bst文献样式文件。           |
|------+----------------------------------------------------------------------|
| .mf  | METAFONT字体描述文件，Knuth教授创立的矢量字体。                      |
|------+----------------------------------------------------------------------|
| .pfa | Type 1字体文件，ASCII格式，一种高品质矢量字体，越放大越清晰。        |
|------+----------------------------------------------------------------------|
| .pfb | Type 1字体文件，二进制格式。                                         |
|------+----------------------------------------------------------------------|
| .pk  | pk字体，一种点阵字体，用于dvi文件预览等。                            |
|------+----------------------------------------------------------------------|
| .pl  | 字体属性列表，可读的字体描述文件。                                   |
|------+----------------------------------------------------------------------|
| .sfd | 子字库定义文件。                                                     |
|------+----------------------------------------------------------------------|
| .sty | 宏包文件，可用命令 \textbackslash{}usepackage调用。                                 |
|------+----------------------------------------------------------------------|
| .tex | \LaTeX 源文件。                                                      |
|------+----------------------------------------------------------------------|
| .tfm | 字体描述文件，设定字体的宽、高和间距等， \LaTeX 用以规划页面。       |
|------+----------------------------------------------------------------------|
| .ttf | Truetype字体，Windows系统使用的一种全真字体。                        |
|------+----------------------------------------------------------------------|
| .vf  | TEX虚拟字体                                                          |
|------+----------------------------------------------------------------------|
| .vpl | 虚拟属性列表，可读的虚拟字体文件。                                   |
|------+----------------------------------------------------------------------|


**** 在源文件编译过程中创建的文件

|----+---------------------------------------------------------|
|.aux| 引用标记记录文件，用于再次编译时生成参考文献和超链接等。|
|----+---------------------------------------------------------|
|.bbl| .blg 由BibTEX编辑.bib后创建的文献文件，再次编译时带入源文件生成文献列表。|
|----+--------------------------------------------------------------------------|
|BibTEX|处理过程记录文件。|
|------+------------------|
|.dbj| 批处理文件，由makebst工具在创建.bst文献样式文件时生成。|
|----+--------------------------------------------------------|
|.dvi| 由 \LaTeX 对.tex源文件编译后创建的输出文件，含有字库信息。|
|----+-----------------------------------------------------------|
|.glo| 术语标记记录文件，用于再次编译时生成术语表。|
|----+---------------------------------------------|
|.idx| 索引资料记录文件，可用makeindex排序后创建索引文件.ind。|
|----+--------------------------------------------------------|
|.ilg| makeindex处理过程记录文件。|
|----+----------------------------|
|.ind| makeindex对.idx排序后创建的索引文件，再次编译时带入源文件生成索引。|
|----+--------------------------------------------------------------------|
|.lof| 图形标题记录文件，用于再次编译时生成图形目录。|
|----+-----------------------------------------------|
|.log| 编译过程记录文件，记录编译时出现的提示、警告和错误信息。|
|----+---------------------------------------------------------|
|.lot| 表格标题记录文件，用于再次编译时生成表格目录。|
|----+-----------------------------------------------|
|.pdf| 由PDF \LaTeX 对.tex或dvipdf对.dvi或pspdf对.ps编译后创建的图形文件。|
|----+--------------------------------------------------------------------|
|.ps| 由dvips对.dvi文件编译后创建的图形文件。|
|---+----------------------------------------|
|.toc| 章节标题记录文件，用于再次编译时生成章节目录。|
|----+-----------------------------------------------|

*** Can we make a love heart with LaTeX

+
  http://tex.stackexchange.com/questions/139733/can-we-make-a-love-heart-with-latex

[[/home/ben/Wally/Journal//Figure/scrot/2959ite.png]]

** Note
*** tipa宏包是用来排版国际音标的，使用tipa宏包可能会与数学公式有所冲突

** ctex
*** ctex字体 font-not-found winfonts, 不推荐

参考: [[http://albertcn.blog.163.com/blog/static/2094201452013521105128316/#crayon-51c3bb178fb44797891969-7][font-not-found]]

#+BEGIN_EXAMPLE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! fontspec error: "font-not-found"
!
! The font "[SIMKAI.TTF]" cannot be found.
!
! See the fontspec documentation for further information.
!
! For immediate help type H &lt;return&gt;.
!...............................................
#+END_EXAMPLE

解决方案: 修改texlive的ctex包的配置文件：

*/usr/local/texlive/2014/texmf-dist/tex/latex/ctex/fontset/ctex-xecjk-winfonts.def*

** TeXLive                                                         :texlive:
*** [[http://seisman.info/install-texlive-under-linux.html][Linux下安装TeXLive 2015]]                                       :install:
**** [[#id8][依赖包]]

-  安装过程中需要调用Perl的模块 =Digest::MD5= 来检测ISO文件的完整性；
-  升级过程中界面需要调用Perl的模块 =Tk= ；

CentOS:

#+BEGIN_EXAMPLE
    $ sudo yum install perl-Digest-MD5 perl-Tk
#+END_EXAMPLE

Ubuntu:

#+BEGIN_EXAMPLE
    $ sudo apt-get install libdigest-perl-md5-perl perl-tk
#+END_EXAMPLE

**** [[#id9][安装]]

***** [[#id10][下载]]

下载地址：

-  官方镜像:
   [[http://mirrors.ctan.org/systems/texlive/Images/texlive2015.iso]]
-  USTC镜像：
   [[http://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/texlive2015.iso]]

Linux下可以用wget、axel，windows下可以用迅雷，怎么快怎么来。

***** [[#id11][挂载ISO镜像]]

 #+BEGIN_EXAMPLE
     $ su
     # mount -o loop texlive2015.iso  /mnt/
     # cd /mnt
     # ./install-tl
 #+END_EXAMPLE


出现选项后，输入 =I=
直接安装（也可以更改选项）。不出意外的话，5分钟应该就OK了，然后退出root用户。

***** [[#id12][环境变量]]

在当前用户的 =~/.bashrc= 中加入如下语句：

 #+BEGIN_EXAMPLE
     # TeX Live 2015
     export MANPATH=${MANPATH}:/usr/local/texlive/2015/texmf-dist/doc/man
     export INFOPATH=${INFOPATH}:/usr/local/texlive/2015/texmf-dist/doc/info
     export PATH=${PATH}:/usr/local/texlive/2015/bin/x86_64-linux
 #+END_EXAMPLE


***** [[#id13][卸载ISO镜像]]

 #+BEGIN_EXAMPLE
     1
     2
 #+END_EXAMPLE

 #+BEGIN_EXAMPLE
     $ cd
     $ sudo umount /mnt/
 #+END_EXAMPLE

**** [[#id14][更新TeXLive]]

可以使用如下命令更新TeXLive宏包：


 #+BEGIN_EXAMPLE
     $ su
     # 更新TeXLive包管理器tlmgr
     # tlmgr update --self
     # 更新TeXLive的全部包
     # tlmgr update --all
 #+END_EXAMPLE


默认情况下，会自动搜索合适的镜像来更新，也可以使用 =--repository=
选项指定了要使用哪一个CTAN镜像。

比如USTC镜像:

#+BEGIN_EXAMPLE
    # tlmgr update --self --repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet/
    # tlmgr update --all --repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet/
#+END_EXAMPLE

比如阿里云镜像:

#+BEGIN_EXAMPLE
    # tlmgr update --self --repository http://mirrors.aliyun.com/CTAN/systems/texlive/tlnet/
    # tlmgr update --all --repository http://mirrors.aliyun.com/CTAN/systems/texlive/tlnet/
#+END_EXAMPLE

如果希望在图形界面下升级，可以使用如下命令调出tlmgr的中文图形界面：

 #+BEGIN_EXAMPLE
     $ su
     # tlmgr --gui --gui-lang zh_CN
 #+END_EXAMPLE

**** [[#id15][安装额外的字体]]

TeXLive 2015在使用xeLaTeX处理中文时，有自己的默认字体。大多数Linux发行版下，都使用自带的Fandol字体。

如果想要使用Windows字体，可以将字体文件复制到 =~/.fonts=
目录下，并在tex源码中指定字体选项即可。

*.local/share/fonts 文件夹*

**** [[#id16][修订历史]]

-  2013-07-11：初稿；
-  2014-07-06：修改为TeXLive2014，并删除中文字体部分；
-  2015-03-08：新增“安装依赖”；
-  2015-03-15：使用命令行更新包；
-  2015-03-20：指定更新源以及GUI更新；
-  2015-06-13：更新至TeXLive 2015；

So what do you think? Did I miss something? Is any part unclear? Leave
your comments below.

[[http://seisman.info/install-texlive-under-linux.html#disqus_thread][Comments]]

Please enable JavaScript to view the
[[http://disqus.com/?ref_noscript][comments powered by Disqus.]]

[[http://disqus.com][comments powered by Disqus]]

--------------

**** Related Posts:

-  [[http://seisman.info/terms-about-tex.html][与TeX相关的一些名词]]
-  [[http://seisman.info/perl-plenv.html][Perl多版本共存之plenv]]
-  [[http://seisman.info/install-gmt5-under-linux.html][GMT 5.1.2在Linux下的安装]]
-  [[http://seisman.info/mini-template-for-xeCJK.html][使用xeCJK解决中文问题的最小模板]]
-  [[http://seisman.info/install-gmt5-under-windows.html][GMT 5.1.2在Windows下的安装]]

*** [[http://albertcn.blog.163.com/blog/static/2094201452013521105128316/#crayon-51c3bb178fb44797891969-7][texlive的中文问题  ]]                          :blog:

采用ctex支持中文\usepackage{ctex}后，
执行xelatex时出如下错：
Invalid fontname `[SIMKAI.TTF]/ICU', contains '['

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! fontspec error: "font-not-found"
!
! The font "[SIMKAI.TTF]" cannot be found.
!
! See the fontspec documentation for further information.
!
! For immediate help type H &lt;return&gt;.
!...............................................

说明字体[SIMKAI.TTF]找不到。

texlive的ctex包的配置文件：(以mac为例，texlive为texlive2013，其它操作系统和版本类似)
/usr/local/texlive/2013/texmf-dist/tex/latex/ctex/fontset/ctex-xecjk-winfonts.def

解决方法：
1. 将Windows上的字体文件simxxx.ttf等拷贝到mac桌面上，双击安装字体
2. 列出中文字体sudo fc-list  :lang=zh-cn
/Library/Fonts/华文仿宋.ttf: STFangsong:style=常规体,標準體,Ordin?r,Normal,Regular,Normaali,Regolare,レギュラー,???,Regulier,Обычный
/Library/Fonts/楷体.ttc: STKaiti:style=常规体,標準體,Ordin?r,Normal,Regular,Normaali,Regolare,レギュラー,???,Regulier,Обычный
/System/Library/Fonts/STHeiti Medium.ttc: 黑体\-简,黑體\-簡,Heiti SC,黒体\-簡,Heiti\-??:style=中等,中黑,Medium,Halbfett,Normaali,Moyen,Medio,ミディアム,???,Médio,Средний,Normal,Media
/Library/Fonts/Microsoft/STHUPO.TTF: 华文琥珀,STHupo:style=Regular
/Library/Fonts/Microsoft/Kaiti.ttf: 楷体,KaiTi:style=Regular,Normal,oby?ejné,Standard,Κανονικ?,Normaali,Normál,Normale,Standaard,Normalny,Обычный,Normálne,Navadno,Arrunta
/Library/Fonts/楷体.ttc: 楷体\-简,楷體\-簡,Kaiti SC:style=常规体,標準體,Regular
/Library/Fonts/华文黑体.ttf: STHeiti:style=常规体,標準體,Ordin?r,Normal,Regular,Normaali,Regolare,レギュラー,???,Regulier,Обычный
/Library/Fonts/宋体.ttc: 宋体\-简,宋體\-簡,Songti SC:style=细体,細體,Light
/Library/Fonts/华文细黑.ttf: STHeiti:style=细体,細體,Mager,Fein,Light,Ohut,Fin,Leggero,ライト,???,Licht,Tynn,Leve,Светлый,Fina
/Library/Fonts/Hei.ttf: Hei:style=Regular
/Library/Fonts/Microsoft/STXINWEI.ttf: 华文新魏,STXinwei:style=Regular
/Library/Fonts/Kai.ttf: Kai:style=Regular
/Library/Fonts/Microsoft/STXINGKA.ttf: 华文行楷,STXingkai:style=Regular
/Library/Fonts/宋体.ttc: 宋体\-简,宋體\-簡,Songti SC:style=黑体,黑體,Black
/Library/Fonts/楷体.ttc: 楷体\-简,楷體\-簡,Kaiti SC:style=粗体,粗體,Bold
...


3. (可选)生成字体sudo fc-cache -fsv

4.修改texlive的ctex包的配置文件
将[SIMKAI.TTF]替换为第2步骤列出的楷体名字KaiTi即可
原文：
% ctex-xecjk-winfonts.def: Windows 的 xeCJK 字体设置，默认为六种中易字体
% vim:ft=tex

\setCJKmainfont[BoldFont={SimHei},ItalicFont={[SIMKAI.TTF]}]
  {SimSun}
\setCJKsansfont{SimHei}
\setCJKmonofont{[SIMFANG.TTF]}

\setCJKfamilyfont{zhsong}{SimSun}
\setCJKfamilyfont{zhhei}{SimHei}
\setCJKfamilyfont{zhkai}{[SIMKAI.TTF]}
\setCJKfamilyfont{zhfs}{[SIMFANG.TTF]}
% \setCJKfamilyfont{zhli}{LiSu}
% \setCJKfamilyfont{zhyou}{YouYuan}

\newcommand*{\songti}{\CJKfamily{zhsong}} % 宋体
\newcommand*{\heiti}{\CJKfamily{zhhei}}   % 黑体
\newcommand*{\kaishu}{\CJKfamily{zhkai}}  % 楷书
\newcommand*{\fangsong}{\CJKfamily{zhfs}} % 仿宋

修改后：
% ctex-xecjk-winfonts.def: Windows 的 xeCJK 字体设置，默认为六种中易字体
% vim:ft=tex

%\setCJKmainfont[BoldFont={SimHei},ItalicFont={[SIMKAI.TTF]}]
\setCJKmainfont[BoldFont={SimHei},ItalicFont={KaiTi}]
  {SimSun}
\setCJKsansfont{SimHei}
%\setCJKmonofont{[SIMFANG.TTF]}
\setCJKmonofont{FangSong}

\setCJKfamilyfont{zhsong}{SimSun}
\setCJKfamilyfont{zhhei}{SimHei}
%\setCJKfamilyfont{zhkai}{[SIMKAI.TTF]}
\setCJKfamilyfont{zhkai}{KaiTi}
%\setCJKfamilyfont{zhfs}{[SIMFANG.TTF]}
\setCJKfamilyfont{zhfs}{FangSong}
% \setCJKfamilyfont{zhli}{LiSu}
% \setCJKfamilyfont{zhyou}{YouYuan}

\newcommand*{\songti}{\CJKfamily{zhsong}} % 宋体
\newcommand*{\heiti}{\CJKfamily{zhhei}}   % 黑体
\newcommand*{\kaishu}{\CJKfamily{zhkai}}  % 楷书
\newcommand*{\fangsong}{\CJKfamily{zhfs}} % 仿宋

ok，可以支持ctex中文了。

*** 文档位置

1. /usr/local/texlive/2014/texmf-dist/tex/latex/

2. 修改读写权限

   #+BEGIN_EXAMPLE
   sudo chmod -R a+w /usr/local/texlive/2014/texmf-dist/tex/latex/
   #+END_EXAMPLE

*** TeXLive安装与卸载                                           :uninstall:
[[http://tex.stackexchange.com/questions/95483/how-to-remove-everything-related-to-tex-live-for-fresh-install-on-ubunt][卸载]]
[[http://www.tug.org/texlive/acquire.html][org-download]]
[[http://www.cnblogs.com/lienhua34/p/3675027.html][安装]]: 包含中文配置,比较翔实
[[https://wiki.archlinux.org/index.php/TeXLive_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)][texlive-archlinux]]
[[http://www.xuebuyuan.com/1673310.html][宏包安装]]
texlive安装包默认携带了ctex宏包,目录为
/usr/local/texlive/2014/texmf-dist/tex/latex/ctex
默认ctex包使用window字体,因而在Linux中会导致编译失败,所以要对ctex进行
字体配置.
ctex宏包提供三个字体选项:nonfonts, adobefonts和winfonts,默认使用的是
winfonts.如果tex源文件中没有使用其他选项修改字体配置,则需要操作系统安
装有中文Windows操作系统自带的四种TrueType字体:宋体(simsum),黑体
(simhei),仿宋体(simfang),楷体(simkai).
如果使etadobefonts选项,则需要操作系统安装Adobe公司的四种OpenType字
体:Adobe 宋体, Adobe 黑体, Adobe 仿宋, Adobe 楷体.

nonfonts选项使用Ubuntu自带字体.
#+BEGIN_EXAMPLE
%% mylinuxfonts.sty
\ProvidesPackage{mylinuxfonts}
\setCJKmainfont[ItalicFont={AR PL UKai CN}]{AR PL UMing CN} %设置中文默认字体
\setCJKsansfont{WenQuanYi Zen Hei}
\setCJKmonofont{WenQuanYi Zen Hei Mono}
\endinput
#+END_EXAMPLE

*** 字体

[[http://www.cnblogs.com/lienhua34/p/3675027.html][安装]]: 包含中文配置,比较翔实

texlive安装包默认携带了ctex宏包,目录为
/usr/local/texlive/2014/texmf-dist/tex/latex/ctex
默认ctex包使用window字体,因而在Linux中会导致编译失败,所以要对ctex进行
字体配置.
ctex宏包提供三个字体选项:
+ nonfonts
+ adobefonts
+ winfonts, 默认使用winfonts.如果tex源文件中没有使用其他选项修改字体配
  置,则需要操作系统安装有中文Windows操作系统自带的四种TrueType字体:宋
  体(simsum),黑体(simhei),仿宋体(simfang),楷体(simkai).

如果使etadobefonts选项,则需要操作系统安装Adobe公司的四种OpenType字
体:Adobe 宋体, Adobe 黑体, Adobe 仿宋, Adobe 楷体.

nonfonts选项使用Ubuntu自带字体.
e.g.
#+BEGIN_EXAMPLE
\documentclass[nofonts]{ctexart}
\setCJKmainfont[ItalicFont={AR PL UKai CN}]{AR PL UMing CN} %设置中文默认字体
\setCJKsansfont{WenQuanYi Zen Hei}
\setCJKmonofont{WenQuanYi Zen Hei Mono}
\begin{document}
您好, \LaTeX!
你好,中文!
\end{document}
#+END_EXAMPLE

设置成模板文件(todo: )
#+BEGIN_EXAMPLE
%% mylinuxfonts.sty
\ProvidesPackage{mylinuxfonts}
\setCJKmainfont[ItalicFont={AR PL UKai CN}]{AR PL UMing CN} %设置中文默认字体
\setCJKsansfont{WenQuanYi Zen Hei}
\setCJKmonofont{WenQuanYi Zen Hei Mono}
\endinput
#+END_EXAMPLE
*** TeXLive拾遗

#+BEGIN_SRC latex
在texlive安装目录(/usr/local/texlive/2014/)下,有\textbf{doc.html}文档
该文档中包含所有安装包的帮助文档索引.
#+END_SRC

** listing                                                         :listing:
http://blog.sina.com.cn/s/blog_5e16f1770100fw83.html
http://blog.sina.com.cn/s/blog_5e16f1770100nwi5.html

*** 博客教程
listings 是专用于代码排版的 LaTeX 宏包，可对关键词、注释和字符串等使用不同的
字体和颜色或颜色，也可以为代码添加边框、背景等风格。

1. 基本用法

   注意，要使用 listings 宏包提供的语法高亮，需要 xcolor 宏包支持。

2. 边框

   listings宏包为代码边框提供了很多风格，大体可分为带有阴影的边框与圆
   角边框。这里仅仅给出一个阴影边框的示例，至于其它边框风格，可查阅
   listings 宏包文档，里面给出了一些示例。

*** Listings Manual
**** Typesetting listings
1. Code snippets: \textbackslash{}lstinline
2. Displayed code: lstlisting environment
3. Stand alone file: \textbackslash{}lstinputlisting
**** Software license
LaTeX Project Public License
**** Package loading
+ \textbackslash{}usepackage[options]{listings}
+ \textbackslash{}lstloadlanguages{commma-sperated-list-of-languages}
  + language form: [dialect]language
  + examples
    - C++(ANSI, GNU, ISO, Visual)
    - C(ANSI, Handel, Objective, Sharp)
    - bash
    - Octave
    - Pythone

*** lstlisting 选项
+ language=[ANSI]C,               % 程序语言名称
+ basicstyle=\footnotesize,       % 基本字体的字号
+ numbers=left,                   % 行号位置
+ numberstyle=\footnotesize,      % 行号字体的字号
+ stepnumber=2,                   % 行号的显示步长
+ numbersep=5pt,                  % 行号与代码间距
+ showspaces=false,               % 显示空格
+ showstringspaces=false,         % 字符串中显示空格
+ showtabs=false,                 % 显示 TAB
+ frame=single,                   % 显示边框
+ tabsize=2,                      %  TAB 被当作两个空格
+ captionpos=b,                   % 标题位置
+ breaklines=false,               % 自动断行
+ breakatwhitespace=false,        % 断行只在空格处
+ escapeinside={\%*}{*)}          % 添加注释，暂时离开 listings
+ extendedchars=false
+ frame=shadowbox, %把代码用带有阴影的框圈起来
+ commentstyle=\color{red!50!green!50!blue!50},%浅灰色的注释
+ rulesepcolor=\color{red!20!green!20!blue!20},%代码块边框为淡青色
+ keywordstyle=\color{blue!90}\bfseries, %代码关键字的颜色为蓝色，粗体
+ showstringspaces=false,%不显示代码字符串中间的空格标记
+ stringstyle=\ttfamily, % 代码字符串的特殊格式
+ keepspaces=true, %
+ breakindent=22pt, %
+ numbers=left,%左侧显示行号
+ stepnumber=1,%
+ numberstyle=\tiny, %行号字体用小号
+ basicstyle=\footnotesize, %
+ showspaces=false, %
+ flexiblecolumns=true, %
+ breaklines=true, %对过长的代码自动换行
+ breakautoindent=true,%
+ breakindent=4em, %
+ aboveskip=1em, %代码块边框 %% added by
+ fontadjust,
+ captionpos=t,
+ framextopmargin=2pt,framexbottommargin=2pt,abovecaptionskip=-3pt,belowcaptionskip=3pt,
+ xleftmargin=4em,xrightmargin=4em, % 设定listing左右的空白
+ texcl=true  % 设定中文冲突，断行，列模式，数学环境输入，listing数字的样式
+ extendedchars=false,columns=flexible,mathescape=true
+ % numbersep=-1em

*** [[http://blog.sina.com.cn/s/blog_5e16f1770100o9ef.html][Listings宏包定制python源代码输出]]                          :blog:python:

下面我们看看python代码如何制作呢？

我们给出了一个语法文件（[[http://blog.miliauskas.lt/2008/09/python-syntax-highlighting-in-latex.html][选自这里）]]
其效果图如下：

代码如下：

#+BEGIN_SRC latex
  \documentclass{article}
  \usepackage{amsfonts}
  \usepackage{xcolor}
  \usepackage{listings}
  \usepackage{textcomp}
  \usepackage{setspace}
  \usepackage{palatino}

  \renewcommand{\lstlistlistingname}{Code Listings}
  \renewcommand{\lstlistingname}{Code Listing}
  \definecolor{gray}{gray}{0.5}
  \definecolor{green}{rgb}{0,0.5,0}

  \lstnewenvironment{python}[1][]{
    \lstset{
      language=python,
      basicstyle=\ttfamily\small\setstretch{1},
      stringstyle=\color{red},
      showstringspaces=false,
      alsoletter={1234567890},
      otherkeywords={\ , \}, \{},
      keywordstyle=\color{blue},
      emph={access,and,break,class,continue,def,del,elif ,else,%
        except,exec,finally,for,from,global,if,import,in,i s,%
        lambda,not,or,pass,print,raise,return,try,while},
      emphstyle=\color{orange}\bfseries,
      emph={[2]True, False, None, self},
      emphstyle=[2]\color{green},
      emph={[3]from, import, as},
      emphstyle=[3]\color{blue},
      upquote=true,
      morecomment=[s]{"""}{"""},
      commentstyle=\color{gray}\slshape,
      emph={[4]1, 2, 3, 4, 5, 6, 7, 8, 9, 0},
      emphstyle=[4]\color{blue},
      literate=*{:}{{\textcolor{blue}:}}{1}%
      {=}{{\textcolor{blue}=}}{1}%
      {-}{{\textcolor{blue}-}}{1}%
      {+}{{\textcolor{blue}+}}{1}%
      {*}{{\textcolor{blue}*}}{1}%
      {!}{{\textcolor{blue}!}}{1}%
      {(}{{\textcolor{blue}(}}{1}%
      {)}{{\textcolor{blue})}}{1}%
      {[}{{\textcolor{blue}[}}{1}%
      {]}{{\textcolor{blue}]}}{1}%
      {<}{{\textcolor{blue}<}}{1}%
      {>}{{\textcolor{blue}>}}{1},%
      framexleftmargin=1mm, framextopmargin=1mm, frame=shadowbox,
      rulesepcolor=\color{blue},#1
    }}{}
  \begin{document}

  We can see in Code Listing~\ref{ex1} that... And compared to Code
  Listing~\ref{ex2} something else.

  \begin{python}[moreemph={[4]42},caption={Simple python example No.
      1},label=ex1]
    #!/usr/bin/env python3

    class MyClass(MyOtherClass):
    """
    Some Docstring ()
    """
    a = 3
    b5 = -42
    q = (3, 5, j)
    SIGNAL('clicked()'),
    "A String"
  \end{python}

  \begin{python}[moreemph={[4], 46, 48},caption={Simple python example
      No. 2},label=ex2]
    #!/usr/bin/env python
    #-*- coding: utf-8 -*-

    class MyClass(MyOtherClass):
    """
    Some Docstring
    """
    def __init__(self):
    fruitbowl = ["pear", "peach", "banana"]
    for fruit in fruitbowl:
    print fruit
    if fruit is "pear":
    continue
    else:
    pass
    if fruitbowl is not None:
    var = True
    else:
    var = False
    a = 3
    b = -46
    c = 3.48
    someDict = {'one':1, 'two':2, "three":3}
    aTuple = (1, 2, 3, 4, 5)
    string = "one-two=3"
    name = "Username: "
    self.button1.connect(self.button1,
    SIGNAL('clicked()'),
    self.login)
    return
  \end{python}
  \begin{equation}
    a\^2
  \end{equation}
  \lstlistoflistings

  \end{document}

#+END_SRC



这样文档代码太长，可以拆分文件，为pythonlisting.tex +
主文件。语法文件这里下载：

http://cid-3cfe530319707374.office.live.com/self.aspx/ChinaTeX/pythonlisting.tex

那上面代码可以写为：

#+BEGIN_SRC latex
  \documentclass{article}
  \include{pythonlisting}
  \begin{document}
  We can see in Code Listing~\ref{ex1} that... And compared to Code
  Listing~\ref{ex2} something else.

  \begin{python}[moreemph={[4]42},caption={Simple python example No.
      1},label=ex1]
    #!/usr/bin/env python3

    class MyClass(MyOtherClass):
    """
    Some Docstring ()
    """
    a = 3
    b5 = -42
    q = (3, 5, j)
    SIGNAL('clicked()'),
    "A String"
  \end{python}

  \begin{python}[moreemph={[4], 46, 48},caption={Simple python example
      No. 2},label=ex2]
    #!/usr/bin/env python
    #-*- coding: utf-8 -*-

    class MyClass(MyOtherClass):
    """
    Some Docstring
    """
    def __init__(self):
    fruitbowl = ["pear", "peach", "banana"]
    for fruit in fruitbowl:
    print fruit
    if fruit is "pear":
    continue
    else:
    pass
    if fruitbowl is not None:
    var = True
    else:
    var = False
    a = 3
    b = -46
    c = 3.48
    someDict = {'one':1, 'two':2, "three":3}
    aTuple = (1, 2, 3, 4, 5)
    string = "one-two=3"
    name = "Username: "
    self.button1.connect(self.button1,
    SIGNAL('clicked()'),
    self.login)
    return
  \end{python}

  \lstlistoflistings


  \end{document}
#+END_SRC

*** [[http://blog.sina.com.cn/s/blog_5e16f1770100nwi5.html][LaTeX技巧466：如何利用listing宏包制作专业的C++输出代码？]]     :blog:cpp:

代码如下：

#+BEGIN_SRC latex
  \documentclass{article}
   \usepackage{xcolor}
   \renewcommand{\sfdefault}{phv}
   \usepackage{listings}
     \usepackage{courier}
   \lstset{
     basicstyle=\footnotesize\ttfamily, % Standardschrift
     %numbers=left,  % Ort der Zeilennummern
     numberstyle=\tiny,  % Stil der Zeilennummern
     %stepnumber=2,  % Abstand zwischen den
  Zeilennummern
     numbersep=5pt,  % Abstand der Nummern zum Text
     tabsize=2,  % Groesse von Tabs
     extendedchars=true,  %
     breaklines=true,  % Zeilen werden Umgebrochen
     keywordstyle=\color{red},
     frame=b,
     stringstyle=\color{white}\ttfamily, % Farbe der String
     showspaces=false,  % Leerzeichen anzeigen ?
     showtabs=false,  % Tabs anzeigen ?
     xleftmargin=17pt,
     framexleftmargin=17pt,
     framexrightmargin=5pt,
     framexbottommargin=4pt,
     �ckgroundcolor=\color{lightgray},
     showstringspaces=false  % Leerzeichen in Strings anzeigen
  ?
   }
   \renewcommand{\lstlistingname}{CODE}
   \lstloadlanguages{% Check Dokumentation for further languages ...
     %[Visual]Basic
     %Pascal
     %C
     %C++
     %XML
     %HTML
     Java
   }
     \usepackage{caption}
   \DeclareCaptionFont{white}{\color{white}}
   \DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35,
  0.35,0.01}{\parbox{\textwidth}{#1#2#3}}}

  \captionsetup[lstlisting]{format=listing,justification=raggedright,labelfont=white,textfont=white,
  singlelinecheck=false, margin=0pt, font={sf,bf,footnotesize}}
   \begin{document}

  \begin{lstlisting}[label=some-code,caption=Some Code]
   public void here() {
     goes().the().code()
   }
   \end{lstlisting}

  \lstinputlisting[label=samplecode,caption=A sample]{HelloWorld.java}

  \end{document}
#+END_SRC

*** XML                                                               :xml:

listing宏包支持XML高亮显示,  but the definition are preliminary（初步
的， 预备的），所以需要进行进一步的配置
#+BEGIN_EXAMPLE
  \definecolor{gray}{rgb}{0.4,0.4,0.4}
  \definecolor{darkblue}{rgb}{0.0,0.0,0.6}
  \definecolor{cyan}{rgb}{0.0,0.6,0.6}

  \lstdefinelanguage{XML}{
      morestring=[b]",
      morestring=[s]{>}{<},
      morecomment=[s]{<?}{?>},
      stringstyle=\color{black},
      identifierstyle=\color{darkblue},
      keywordstyle=\color{cyan},
      morekeywords={xmlns,version,type}% list your attributes here
      *此处不能有空行*
  }
  \lstnewenvironment{XML}[1][]{
    \lstset{
      language=XML,
      basicstyle=\ttfamily,
      columns=fullflexible,
      showstringspaces=false,
      commentstyle=\color{gray}\upshape *逗号少了*
      framexleftmargin=1mm,
      framextopmargin=1mm,
      frame=shadowbox,
      rulesepcolor=\color{blue},#1, *逗号多了*
    }
  }{}
#+END_EXAMPLE

#+BEGIN_SRC latex
    \begin{XML}
      <person age="22" sex="female">Ann</person>
    \end{XML}

     % \begin{minted}{xml}
     %   <xml>
     %   <person age="22" sex="female">Ann</person>
     %   <\xml>
     % \end{minted}
#+END_SRC




minted宏包也可以
** algorithm2e                                                 :algorithm2e:
*** [[http://blog.csdn.net/zxia1/article/details/8134968][Latex之算法宏包]]                                                  :blog:

Latex中对算法进行排版的宏包有不少，本文简单介绍几个常用的宏包。

*1. listings* ：这个用来对真实的代码排版，不适于伪代码。支持C++，Pascal等10几种语言。该环境中的内容完全与TeX环境隔离，无法直接处理下标，上标等符号。使用时需要以下步骤：
 \usepackage{listings}
 \lstloadlanguages{C++, Pascal}  %可以一次加入多种语言

\lstset{language=C++}  %使用前指定语言

\begin{lstlisting}{}
   code...
 \end{lstlisting}

*2. algorithmic和algorithmics*: 不支持switch-case语句。

*3. newalg*: 支持switch-case，不过似乎比较老了，很久没人维护了。

*4.
algorithmicx*：这个看起来功能最强大，包含了专门针对C语言，Pascal语言，matlab以及伪代码的sty文件，可惜它的C语言环境还在开发中，目前也不支持switch-case语句。

*5. algorithm*: 可以用于伪代码的排版。

*** 宏包： *algorithm2e*
+ 环境： *algorithm*
+ 选项
  - boxed 边框
  - lined 在某一算法的起始与结束之间排印一条垂直线，以标示作用范围
  - linesnumbered 增加行号，不包括注释
  - vlined 同lined
+ 算法环境被定义为浮动环境
  #+BEGIN_EXAMPLE
    \begin{algorithm}[位置]
    算法
    \end{algorithm}
  #+END_EXAMPLE
+ 位置选项
  - 同浮动环境table相同
  - H 强制将算法内容就地放置
  - algorithm* 双栏格式中跨栏编排

*** 命令
**** 基本命令

[[/home/ben/Wally/Journal/Figure/scrot/6757est.png]]

**** 标题命令

[[/home/ben/Wally/Journal/Figure/scrot/6757dAD.png]]

**** 输入输出命令

[[/home/ben/Wally/Journal/Figure/scrot/6757qKJ.png]]

[[/home/ben/Wally/Journal/Figure/scrot/67573UP.png]]

**** 条件命令

[[/home/ben/Wally/Journal/Figure/scrot/6757EfV.png]]

**** 关键词命令

[[/home/ben/Wally/Journal/Figure/scrot/6757Rpb.png]]

*** Example
#+BEGIN_SRC latex
  \begin{algorithm}[ht]
    \KwData{a, b, c, i: integer}
    \Begin{
      clrscr\;
      \For{i:=100 \KwTo 999}{
        c:=i mod 10; \tcp{取个位数}
        b:=(i div 10) mod 10 \;
        a:=i dvi 100\;
        \If{i=a*a*a+b*b*b+c*c*c}{writeln{i:6}}
      }
    }
  \end{algorithm}
#+END_SRC
*** LaTeX algorithm2e if else if else
\textbackslash{}uIf
\textbackslash{}uElseIf
\textbackslash{}Else

[[/home/ben/Wally/Journal/Figure/scrot/15486GUj.png]]
[[/home/ben/Wally/Journal/Figure/scrot/15486Tep.png]]

*** DONE algorithm2e 什么错误
- State "DONE"       from "TODO"       [2015-11-05 四 14:59]

答案： *下划线*,  /algorithm环境中不能下划线？？？/
#+BEGIN_EXAMPLE
  \begin{algorithm}
    \textbf{FIND\_CYLINDERS(scan, jump)}
    \KwIn{scan: 扫描线数组，每个元素对应一个距离信息, jump: 微分的跳动阈
      值}
    \KwOut{cylinders: 特征点结构数组，每个元素对应一个包含索引和距离
      的结构}
    on_cylinder = FALSE
    sum_ray = 0
    sum_index = 0\tcp{索引和}
    sum_depth = 0\tcp{距离和}
    cylinders=[]
    n = 0                         % 特征点个数
    derivate=COMPUTE_DERIVATIVES(scan)
    \For{i=1 \KwTo scan.length}{
      \If{derivative[i] < -jump\tcp{下降沿，开始计数}}{
        sum_ray = 0
        sum_index = 0
        sum_depth = 0
        on_cylinder = TRUE
      }
      \tcp{注意条件分支结构}
      \eIf{derivate[i] > jump AND on_cylinder \tcp{上升沿，结束计数}}{
        n = n+1
        cylinders[i]=struct(sum_index/sum_ray, sum_depth/sum_ray)
      }{
        \If{scan[i] > mindist}{
          sum_ray = sum_ray+1
          sum_index = sum_index+i
          sum_depth = sum_depth+scan[i]
        }
      }
    }
    \Return{cylinders}
  \end{algorithm}
#+END_EXAMPLE

*** DONE algorithm2e escape-math
- State "DONE"       from "TODO"       [2015-12-08 二 13:10]

[[~/Document/Programming/TeX/doc/algorithm2e.pdf][algorithm2e]]

algorithm环境内直接支持 数学模式

非宏开头的行要以 /=\;=/ 结束

在 /数学模式 =$$=/ 下可以使用下划线

** Minted                                                           :minted:
*** DONE Minted宏包配置
- State "DONE"       from "TODO"       [2015-11-08 日 15:46]
*支持许多种语言*

! Package minted Error: You must have `pygmentize' installed to use
this package.
! LaTeX Error: File `journal.pyg' not found.

! Package minted Error: You must invoke LaTeX with the -shell-escape
flag.


暂时不知道原因
可能是某个软件安装或配置问题，也可能是某个宏包没有安装的问题


需要注意的是，运行的时候需要加一个参数即： *-shell-escape*  ，如若是使
用pdflatex编译，即：pdflatex -shell-escape  filename

也就是说, 直接使用Emacs tex-mode 默认的命令会出现错误。

**** AucTeX+Minted
http://stackoverflow.com/questions/3300497/using-minted-source-code-latex-package-with-emacs-auctex

#+BEGIN_SRC emacs-lisp
  ;; not work, not know why
  ;; (add-hook 'TeX-mode-hook
  ;;   (lambda ()
  ;;     (setq TeX-command-extra-options "-shell-escape")
  ;;   )
  ;;   )

  (eval-after-load "tex"
    '(setcdr (assoc "LaTeX" TeX-command-list)
            '("%`%l%(mode) -shell-escape%' %t"
            TeX-run-TeX nil (latex-mode doctex-mode) :help "Run LaTeX")
      )
    )
#+END_SRC

#+begin_latex
\begin{minted}{lisp}
;; not work, not know why
;; (add-hook 'TeX-mode-hook
;;   (lambda ()
;;     (setq TeX-command-extra-options "-shell-escape")
;;   )
;;   )

(eval-after-load "tex"
  '(setcdr (assoc "LaTeX" TeX-command-list)
          '("%`%l%(mode) -shell-escape%' %t"
          TeX-run-TeX nil (latex-mode doctex-mode) :help "Run LaTeX")
    )
  )
\end{minted}
#+end_latex



#+begin_src latex
  \begin{minted}{c}
    #include <stdio.h>

    main(){
      int a = 0;
      printf("Hello,  Minted");
    }

  \end{minted}
#+end_src

**** pygment
homepage: http://pygments.org/

支持的语言： *pygmentize -L lexers*,  >300

+ python(py, python)
+ c(c)
+ cpp(cpp)
+ cmake(cmake)
+ makefile(make, makefile)
+ bash(bash, sh)
+ yaml(yaml)
+ asm(nasm)
+ lisp(newlisp)
+ latex

#+BEGIN_EXAMPLE
  $ pygmentize -L lexers | grep cmake
  ,* cmake:
      CMake (filenames *.cmake, CMakeLists.txt)

  $ pygmentize -L lexers | grep python
  ,* antlr-python:
  ,* python, py, sage:
  ,* python3, py3:

  $ pygmentize -L lexers | grep makefile
  ,* make, makefile, mf, bsdmake:
      Makefile (filenames *.mak, Makefile, makefile, Makefile.*, GNUmakefile)

  $ pygmentize -L lexers | grep bash
  ,* bash, sh, ksh:
      Bash (filenames *.sh, *.ksh, *.bash, *.ebuild, *.eclass, .bashrc, bashrc, .bash_*, bash_*)j

  $ pygmentize -L lexers | grep yaml
  ,* yaml:
      YAML (filenames *.yaml, *.yml)

  $ pygmentize -L lexers | grep asm
      aspx-cs (filenames *.aspx, *.asax, *.ascx, *.ashx, *.asmx, *.axd)
      aspx-vb (filenames *.aspx, *.asax, *.ascx, *.ashx, *.asmx, *.axd)
  ,* nasm:
      NASM (filenames *.asm, *.ASM)
  $ pygmentize -L lexers | grep lisp
  ,* common-lisp, cl:
      Common Lisp (filenames *.cl, *.lisp, *.el)
  ,* newlisp:

  $ pygmentize -L lexers | grep latex
  ,* tex, latex:

#+END_EXAMPLE

*注： 当minted环境设置的语言不是当前所支持的，编译时不会报错，只是编译
的结果为空白PDF*

**** org 配置
#+BEGIN_SRC emacs-lisp
  (setq org-structure-template-alist
        '(("s" "#+BEGIN_SRC ?\n\n#+END_SRC" "<src lang=\"?\">\n\n</src>")
         ("e" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE" "<example>\n?\n</example>")
         ("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE" "<quote>\n?\n</quote>")
         ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE" "<verse>\n?\n</verse>")
         ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM" "<verbatim>\n?\n</verbatim>")
         ("c" "#+BEGIN_CENTER\n?\n#+END_CENTER" "<center>\n?\n</center>")
         ("l" "#+begin_src latex\n?\n#+end_src" )
         ("L" "#+LaTeX: " "<literal style=\"latex\">?</literal>")
         ("h" "#+BEGIN_HTML\n?\n#+END_HTML" "<literal style=\"html\">\n?\n</literal>")
         ("H" "#+HTML: " "<literal style=\"html\">?</literal>")
         ;; ("a" "#+BEGIN_ASCII\n?\n#+END_ASCII" "")
         ("A" "#+ASCII: " "")
         ("i" "#+INDEX: ?" "#+INDEX: ?")
         ("I" "#+INCLUDE: %file ?" "<include file=%file markup=\"?\">")
         ;; ("p" "#+begin_latex\n\\begin{python}\n?\n\\end{python}\n#+end_latex")
         ;; ("c" "#+begin_latex\n\\begin{cpp}\n?\n\\end{cpp}\n#+end_latex")
         ;; ("k" "\\left[?\\right]")
         ;; ("K" "\\left\{?\\right\}")
         ;; ("a" "#+begin_latex\n\\begin{algorithm}\n?\n\\end{algorithm}\n#+end_latex")
         ;; ("x" "#+begin_latex\n\\begin{xml}\n?\n\\end{xml}\n#+end_latex")
         ("m" "#+begin_latex\n\\begin{minted}{?}\n\n\\end{minted}\n#+end_latex")
         )
        )
#+END_SRC

org #+ 块支持嵌套。

*** Minted配置选项
1. mathescape
   [[/home/ben/Wally/Journal/Figure/scrot/5970lUr.png]]
2. gobble
   [[/home/ben/Wally/Journal/Figure/scrot/5970yex.png]]
3. frame
   [[/home/ben/Wally/Journal/Figure/scrot/5970koA.png]]
4. 其它
   [[/home/ben/Wally/Journal/Figure/scrot/5970xyG.png]]

   [[/home/ben/Wally/Journal/Figure/scrot/5970-8M.png]]


#+begin_latex
\begin{minted}[frame=single]{cpp}
hello world.
\end{minted}
#+end_latex

*** minted latex                                                    :latex:
#+BEGIN_EXAMPLE
  $ pygmentize -L lexers | grep latex
  tex, latex:
#+END_EXAMPLE

*** cmake                                                           :cmake:

minted *语言类型统一小写*
#+BEGIN_SRC sh :results output :exports both
pygmentize -L lexers | grep cmake
#+END_SRC

#+RESULTS:
: * cmake:
:     CMake (filenames *.cmake, CMakeLists.txt)

*** Minted float                                                    :float:

**** 使用float定义新的浮动体，失败，可能行
#+begin_example
\newfloat{minted}{h}{minted}


\begin{minted}[frame=single, mathescape]{py}
import os
print 'hello floating minted'
\end{minted}
#+end_example

+*not ok*+

**** 使用listing环境包装minted
[[/home/ben/Wally/Journal/Figure/scrot/18640JOs.png]]
#+begin_example
\begin{listing}
  \begin{minted}[frame=single, mathescape]{py}
  import os
  print 'hello floating minted'
  \end{minted}
\end{listing}
#+end_example

#+begin_latex
\begin{listing}
  \begin{minted}[frame=single, mathescape]{py}
  import os
  print 'hello floating minted'
  \end{minted}
\end{listing}
#+end_latex

*** [[http://www.cnblogs.com/longdouhzt/archive/2012/10/11/2720161.html][ubuntu latex 的 minted 安装]]                                      :blog:


曾几何时，我一直在使用lstlisting宏包高亮代码，鉴于我从来就没在Word里面
享受过这样的功能，我一直感到很满意。直到今天我遇到了minted宏包。使用非
常的简单，例如：

=\begin{minted}{c}printf("Hello World.");\end{minted}=

minted在后台调用的是pygmentize，所以输出的结果非常漂亮，自然也就支持多种主题。minted提供很多可配置的参数，更多选项请参考[[[http://code.google.com/p/minted/downloads/detail?name=minted.pdf][官方文档]]]。

有一点要注意的是编译时需要加上*-shell-escape*参数。

------

*安装*

 minted的project home: http://code.google.com/p/minted/

主要按照上面文档的介绍安装就可以了。。 安装时会要求安装 minted.sty，
这里有一个简单的方法：

[[http://www.cnblogs.com/longdouhzt/archive/2012/10/11/2720045.html]]


安装完minted.sty 就大功告成了～～

--------

*使用*

查看支持的语言： $ pygmentize -L lexers
如 C， NASM *
*

注意用小写 如\begin{minted}{nasm}



几个可能有用的配置：

1. 背景：

#+BEGIN_EXAMPLE
    \definecolor{bg}{rgb}{0.95,0.95,0.95}
    \begin{minted}[bgcolor=bg]{php}
    <?php
    　　echo "Hello, $x";
    ?>
    \end{minted}
#+END_EXAMPLE

2. 行号

linenos  (boolean)
(default: false)
Enables line numbers. In order to customize the display style of line
numbers, you
need to redefine the \theFancyVerbLine macro:


#+BEGIN_EXAMPLE
    \renewcommand{\theFancyVerbLine}{\sffamily
    \textcolor[rgb]{0.5,0.5,1.0}{\scriptsize
    \oldstylenums{\arabic{FancyVerbLine}}}}
    \begin{minted}[linenos,
    firstnumber=11]{python}
    def all(iterable):
    　　for i in iterable:
    　　　　if not i:
    　　　　　　return False
    　　return True
    \end{minted}
#+END_EXAMPLE

*** [[http://blog.csdn.net/u013453604/article/details/45324121][用minted宏包在TeXWorks中插入代码高亮]]                             :blog:

安装texlive时没有用自带的Texworks编辑器的请看这篇文章

（[[http://blog.csdn.net/gogdizzy/article/details/9136239][http://blog.csdn.net/gogdizzy/article/details/9136239]]） 这是WinEdt编辑器下的操作。

一. minted宏包的使用

#+BEGIN_EXAMPLE
    \documentclass[CJK]{cctart}
    \usepackage{minted}
    \begin{document}
    \begin{minted}{c++}
    int main() {
        printf("hello, world");
        return 0;
    }
    \end{minted}
    \end{document}
#+END_EXAMPLE


二.使用过程遇到的报错

1. 安装texlive，选择自带的Texworks编辑器，最近的新版本都自带了minted宏
   包

2. 安装Python，在这里下载（[[https://www.python.org/downloads/][https://www.python.org/downloads/]]）
   并为Python设置好环境变量，这个自行百度，就是把
   D:\Python34\;D:\Python34\Scripts;加到系统环境变量path里面

3. 安装Pygments

   可以看我这个笔记，[[http://blog.csdn.net/u013453604/article/details/45319379][windows下用easy_install安装Pygments]]
    完了之后运行上面给出的代码还得报错，提示说“minted Error: You must
   invoke LaTeX with the =-shell-escape= flag”这时得启用shell escape

4. 启用shell escape

   我是TeXWorks所以很简单，“编辑器”->”首选项”->”排版”在“处理工具”那一栏的右边点加号，新建一个XeLatex+shellescape的配置，可以参照列表里的XeLatex配置，“程序”填xelates.exe，加入三个参数synctexoption，−−shell−escape，
   fullname，点击确定保存。如图所示
   [[http://img.blog.csdn.net/20150428001226422]]
   然后编译的时候选择新建的这个工具，如图
   [[http://img.blog.csdn.net/20150428002055045]]
   如果你的是WinEdt编辑器，请参照这篇启用shell escape

   [[http://blog.csdn.net/gogdizzy/article/details/9136239][http://blog.csdn.net/gogdizzy/article/details/9136239]]）

   也可以参考国外官网论坛的帖子 [[http://tex.stackexchange.com/questions/99475/how-to-invoke-latex-with-the-shell-escape-flag-in-texmakerx][How to invoke latex with the -shell-escape flag in TeXMakerX?]]

5. 注意\begin{minted}{c++} 这句中的c是小写的

6. minted支持300中语言的高亮，Pygments语法高亮工具提供了不同的高亮风格，具体配置见[[http://get-software.net/macros/latex/contrib/minted/minted.pdf][minted参考文档]]

   还有博客 [[http://havee.me/internet/2013-08/support-pygments-in-jekyll.html][Jekyll 中的语法高亮：Pygments]]

二.其他语法高亮方案

1. listings
    listings 是专用于代码排版的
   LaTeX宏包，可对关键词、注释和字符串等使用不同的字体和颜色或颜色，也可以为代码添加边框、背景等风格。
    但是这种方法相对于minted来说稍显麻烦，语法高亮需要自己设置。
    下面给出一份用于排版 C 语言 HelloWorld 程序代码的完整的 LaTeX 文档：

#+BEGIN_EXAMPLE
    \documentclass{ article}
    \usepackage{ listings}
    \begin{ document}
    \begin{ lstlisting}[ language=C]
    int main(int argc, char ** argv)
    {
    printf("Hello world! \n");
    return 0;
    }
    \end{ lstlisting}
    \end{ document}
#+END_EXAMPLE

注意，要使用 listings 宏包提供的语法高亮，需要 xcolor 宏包支持。

*** [[http://www.latexstudio.net/archives/328][LaTeX技巧703：minted包使用环境的搭建]]                             :blog:


pymentize是用来做高亮显示非常好的库，minted恰恰使用这一语法高亮库来实现代码的高亮显示，其效果做得也非常不错。下面介绍其环境的搭建过程。

#+DOWNLOADED: http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/OLUjl.png @ 2016-01-25 16:52:15
 [[~/Wally/Journal/Figure/.org-download/LaTeX                                                               :LATEX:/OLUjl_2016-01-25_16:52:15.png]]

【*安装Python环境*】

首先，安装python，推荐版本2.7，因为python软件包的管理工具setuptools只
支持到2.7版本，python环境安装完毕，在操作系统的path增加环境变量：
C:\Python27\Scripts\;C:\Python27\。新版的python的目录结构稍有变化，用
户根据自己的实际安装路径来配置环境变量。

【*安装软件包工具*】

python环境安装好以后，可以到 [[https://pypi.python.org/pypi/setuptools][https://pypi.python.org/pypi/setuptools]]
下载包管理工具，可以下载.py脚本，也可以下载exe安装文件，下面是.exe安装
文件的安装过程：

#+DOWNLOADED: http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/easy-install1.png @ 2016-01-25 16:52:39
 [[~/Wally/Journal/Figure/.org-download/LaTeX                                                               :LATEX:/easy-install1_2016-01-25_16:52:39.png]]

【*安装pygmentize库*】

安装好setuptool以后，可以利用命令行工具来安装相关的软件和库，这时之前
设置的环境变量就会发挥其作用了。安装过程如下图所示：

输入：easy_install Pygments 即可！

#+DOWNLOADED: http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/easy-install.png @ 2016-01-25 16:52:48
 [[~/Wally/Journal/Figure/.org-download/LaTeX                                                               :LATEX:/easy-install_2016-01-25_16:52:48.png]]

*【安装验证】*

在命令行下使用pygmentize命令来测试安装是否正常。

【*代码测试*】

TeXlive新版已包含了minted宏包，若是您的系统没有安装此包，可以到
[[http://code.google.com/p/minted/][http://code.google.com/p/minted/ ]]或者 [[http://www.ctan.org/tex-archive/macros/latex/contrib/minted/][ctan]] 下载安装。宏包安装完毕，可
以用下面的代码来测试宏包是否可以正常使用。需要注意的是，运行的时候需要
加一个参数即：-shell-escape
，如若是使用pdflatex编译，即：pdflatex -shell-escape  filename

测试代码如下：

TeX
#+BEGIN_SRC latex
  \documentclass{article}
  \usepackage{minted}
  \begin{document}
  \begin{minted}{c}
  int main()
  {
  printf("hello, world");
  return 0;
  }
  \end{minted}
  \end{document}
#+END_SRC

效果图：

#+DOWNLOADED: http://7xnc7f.com1.z0.glb.clouddn.com/wp-content/uploads/2013/03/minted.png @ 2016-01-25 16:54:31
 [[~/Wally/Journal/Figure/.org-download/LaTeX                                                               :LATEX:/minted_2016-01-25_16:54:31.png]]

*** [[http://blog.sina.com.cn/s/blog_5e16f1770102elx0.html][LaTeX排版XML语法高亮显示]]                            :blog:xml:listing:

语法高亮显示的问题，我还是推荐用户使用minted这个包，效果很不错，不过需要大家安装和配置一些东西。

这里给一个minted显示的例子，具体配置参看minted包的说明文档即可。

[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]

代码如下:

#+BEGIN_EXAMPLE
    \documentclass{minimal}
    \usepackage{minted}
    \begin{document}
    \begin{minted}{xml}
      <xml>
      <person age="22" sex="female">Ann</person>
      </xml>
    \end{minted}
    \end{document}
#+END_EXAMPLE

若是有用户不习惯使用这一包，也可以使用listings包来定制显示XML语句，如下：

[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]

代码选自：[[http://tex.stackexchange.com/questions/10255/xml-syntax-highlighting]]

#+BEGIN_EXAMPLE
    \usepackage{listings}

    \usepackage{color}
    \definecolor{gray}{rgb}{0.4,0.4,0.4}
    \definecolor{darkblue}{rgb}{0.0,0.0,0.6}
    \definecolor{cyan}{rgb}{0.0,0.6,0.6}

    \lstset{
      basicstyle=\ttfamily,
      columns=fullflexible,
      showstringspaces=false,
      commentstyle=\color{gray}\upshape
    }

    \lstdefinelanguage{XML}
    {
      morestring=[b]",
      morestring=[s]{>}{<},
      morecomment=[s]{<?}{?>},
      stringstyle=\color{black},
      identifierstyle=\color{darkblue},
      keywordstyle=\color{cyan},
      morekeywords={xmlns,version,type}% list your attributes here
    }
#+END_EXAMPLE

*** DONE example导出PDF加框 minted text
- State "DONE"       from "TODO"       [2015-11-27 五 17:23]
 <2015-11-26 四>
 [[file:~/Wally/Journal/journal.org::*lidar%EF%BC%9A%20ok][lidar： ok]]

1. plain
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{text}
     #+BEGIN_EXAMPLE
           (defun org-xor (a b)
                 "Exclusive or."
                 (if a (not b) b))
     #+END_EXAMPLE
     \end{minted}
   #+end_latex

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{latex}
     \begin{verbatim}
     (defun org-xor (a b)
           "Exclusive or."
           (if a (not b) b))
     \end{verbatim}
     \end{minted}
   #+end_latex

   [[/home/ben/Wally/Journal/Figure/scrot/30792ZiT.png]]

2. -n get lines numbered

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{text}
     ,#+BEGIN_EXAMPLE -n
           (defun org-xor (a b)
                 "Exclusive or."
                 (if a (not b) b))
     ,#+END_EXAMPLE
     \end{minted}
   #+end_latex

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{latex}
     \begin{verbatim}
     1  (defun org-xor (a b)
     2        "Exclusive or."
     3        (if a (not b) b))
     \end{verbatim}
     \end{minted}
   #+end_latex

   [[/home/ben/Wally/Journal/Figure/scrot/30792ZpH.png]]

3. +n contine last example block

4. 使用Example块解决不了, 使用 Minted *text*

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{text}
        #+BEGIN_EXAMPLE -i
           (defun org-xor (a b)
                 "Exclusive or."
                 (if a (not b) b))
        #+END_EXAMPLE
     \end{minted}
   #+end_latex

*** minted 手册                                                    :minted:

**** -shell-escape
**** code
+
+ =\mint[hoptionsi]{hlanguagei}/hcodei/=
+ =\inputminted[hoptionsi]{hlanguagei}{hfilenamei}=
**** using different styles
1. *=\usemintedstyle{NAME}=*
2. *pygmentize -L styles*
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{text}
      $ pygmentize -L styles
     Pygments version 1.6, (c) 2006-2013 by Georg Brandl.

     Styles:
     ~~~~~~~
     ,* monokai:
         This style mimics the Monokai color scheme.
     ,* manni:
         A colorful style, inspired by the terminal highlighting style.
     ,* rrt:
         Minimalistic "rrt" theme, based on Zap and Emacs defaults.
     ,* perldoc:
         Style similar to the style used in the perldoc code blocks.
     ,* borland:
         Style similar to the style used in the borland IDEs.
     ,* colorful:
         A colorful style, inspired by CodeRay.
     ,* default:
         The default style (inspired by Emacs 22).
     ,* murphy:
         Murphy's style from CodeRay.
     ,* vs:

     ,* trac:
         Port of the default trac highlighter design.
     ,* tango:
         The Crunchy default Style inspired from the color palette from the Tango Icon Theme Guidelines.
     ,* fruity:
         Pygments version of the "native" vim theme.
     ,* autumn:
         A colorful style, inspired by the terminal highlighting style.
     ,* bw:

     ,* emacs:
         The default style (inspired by Emacs 22).
     ,* vim:
         Styles somewhat like vim 7.0
     ,* pastie:
         Style similar to the pastie default style.
     ,* friendly:
         A modern style based on the VIM pyte theme.
     ,* native:
         Pygments version of the "native" vim theme.

     \end{minted}
   #+end_latex

**** supported languages

*pygmentize -L lexers*

#+begin_latex
\begin{minted}[frame=left, mathescape]{py}

\end{minted}
#+end_latex

** float                                                             :float:
*** DONE LaTeX 自定义浮动体                                         :float:
- State "DONE"       from "TODO"       [2015-11-23 一 17:23]
CLOCK: [2015-11-23 一 17:01]--[2015-11-23 一 17:23] =>  0:22

1. 宏包： *float*
2. 新的选项: H
3. 命令: *\textbackslash{}* 创建新的浮动体
   =\newfloat{<type>}{<placement>}{<ext>}[<within>]=
** tkiz                                                               :tkiz:
*** LaTeX 绘制算法流程图                            :flowchart:tkiz:流程图:

**** flowchart

*flowchart* 宏包根据 IBM 提出的流程图标准，定义了流程图中最常用的五种标
准形状，包括：

1. PROCESS: 一切函数过程
2. DECESION: 条件判断
3. PREDEFINED　PROCESS：预定义过程
4. STORAGE: 数据存储
5. TERMINAL: 开始，结束


使用 flowchart 和 TikZ 绘制流程图，主要包括两个步骤：

1. _绘制流程图的具体形状_

   该过程主要是利用 flowchart 宏包的预定义形状，根据流程图具体需要实例
   化，即定义形状的大小，高度宽度等信息。定义形状时，有一点需要注意的
   是，在需要使用折线时，需要定义折线的转折点，如示例中的 point1 。

2. _将形状使用线连接，得到流程图_

   这部分比较简单，只要记住线和箭头的表示方法即可

#+BEGIN_SRC latex
   %!TEX program = xelatex

  \documentclass[UTF8]{ctexart}
  \usepackage{tikz,mathpazo}
  \usetikzlibrary{shapes.geometric, arrows}
  \usepackage{flowchart}
  \begin{document}
  \begin{tikzpicture}[font={\sf \small}]
  \def \smbwd{2cm}
  \thispagestyle{empty}

   %定义流程图的具体形状
  \node (start) at (0,0) [draw, terminal,minimum width=\smbwd, minimum height=0.5cm] {开始};      % 定义开始
  \node (getdata) at (0,-1.5) [draw, predproc, align=left,minimum width=\smbwd,minimum height=1cm] {读取数据};        %定义预处理过程，读取数据
  \node (decide) at (0,-3.5) [draw, decision, minimum width=\smbwd, minimum height=1cm] {判断条件};    %定义判断条件
  \node (storage) at (0,-5.5) [draw, storage, minimum width=\smbwd, minimum height=1cm] {数据存储};     %定义数据存储
  \node (process) at (3,-5.5) [draw, process, minimum width=\smbwd, minimum height=1cm] {处理过程};      %定义处理过程
  \coordinate (point1) at (0,-6.75);
  \node (end) at (0,-7.75) [draw, terminal,minimum width=\smbwd,minimum height=0.5cm] {结束};        %定义结束

   %连接定义的形状，绘制流程图--表示垂直线，|表示箭头方向
  \draw[->] (start) -- (getdata);
  \draw[->] (getdata) -- (decide);
  \draw[->] (decide) -| node[above]{是} (process);
  \draw[->] (decide) -- node[above]{否}(storage);
  \draw[->] (process) |- (point1);
  \draw[->] (storage) -- (point1) -- (end);
  \end{tikzpicture}
  \end{document}
#+END_SRC

[[/home/ben/Wally/Journal//Figure/scrot/30928L9H.png]]

**** tkiz

直接使用 TikZ 强大的绘图功能来实现流程图的绘制。

比较两个方法的代码可知，相比使用 flowchart 宏包，直接使用 TikZ 绘制流
程图多了定义基本形状一步。但通过 TikZ 自己定义基本形状，流程图的可定制
性更好，可以根据具体需要，定义多种流程图形状。另外一个使用 flowchart
宏包来绘制，最终还是需要用到 TikZ 语法，也不见得有多简单。

/推荐使用 TikZ 直接绘制流程图/


#+BEGIN_SRC latex
   %!TEX program = xelatex
  \documentclass[UTF8]{ctexart}
  \usepackage{tikz,mathpazo}
  \usetikzlibrary{shapes.geometric, arrows}
  \begin{document}
  \thispagestyle{empty}
   % 流程图定义基本形状
  \tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
  \tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
  \tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
  \tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
  \tikzstyle{arrow} = [thick,->,>=stealth]

  \begin{tikzpicture}[node distance=2cm]
   %定义流程图具体形状
  \node (start) [startstop] {Start};
  \node (in1) [io, below of=start] {Input};
  \node (pro1) [process, below of=in1] {Process 1};
  \node (dec1) [decision, below of=pro1, yshift=-0.5cm] {Decision 1};
  \node (pro2a) [process, below of=dec1, yshift=-0.5cm] {Process 2a};
  \node (pro2b) [process, right of=dec1, xshift=2cm] {Process 2b};
  \node (out1) [io, below of=pro2a] {Output};
  \node (stop) [startstop, below of=out1] {Stop};

   %连接具体形状
  \draw [arrow](start) -- (in1);
  \draw [arrow](in1) -- (pro1);
  \draw [arrow](pro1) -- (dec1);
  \draw [arrow](dec1) -- (pro2a);
  \draw [arrow](dec1) -- (pro2b);
  \draw [arrow](dec1) -- node[anchor=east] {yes} (pro2a);
  \draw [arrow](dec1) -- node[anchor=south] {no} (pro2b);
  \draw [arrow](pro2b) |- (pro1);
  \draw [arrow](pro2a) -- (out1);
  \draw [arrow](out1) -- (stop);
  \end{tikzpicture}
  \end{document}
#+END_SRC

[[/home/wally/Wally/Journal//Figure/scrot/30928YHO.png]]

**** reference

+ http://elegantlatex.org/2014/08/03/latex-flowchart/

** Packages                                                        :package:
*** pdfpages                                                 :pdfpages:pdf:
**** package: pdfpages
*pdfpages* : include multiple pdf pages in latex

**** package options
+ final: insert pages
+ draft: insert PDF filename with a box
+ enable-survey
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\usepackage[final]{pdfpages}
\end{minted}
#+end_latex

**** \textbackslash{}includepdf
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\includepdf[key=val]{filename}
\end{minted}
#+end_latex

***** main Options
1. *pages*
   selects pages to insert, a comma separated list
   e.g. pages={3, {}, 8-11, 15} 空花括号表空白页

2. *nup*
   put multipages  onto each sheet of paper, default 1x1
   e.g nup=4x2

3. landscape


***** Layout options
1. delta
   put some horizontal and vertical *space* between the logical pages.
   default: delat=0 0(seperated by space)

2. offset

3. frame

4. column


**** 参考
+ [[http://tex.stackexchange.com/questions/91440/how-to-include-multiple-pages-in-latex][stackexchange]]
+
  [[file:/usr/local/texlive/2014/texmf-dist/doc/latex/pdfpages/pdfpages.pdf::%25PDF-1.5][latex:pdfpages]]
*** Moderncv                                                     :moderncv:
+ http://www.cnblogs.com/panpei/archive/2013/02/13/2910680.html
+ [[http://www.ctan.org/tex-archive/macros/latex/contrib/moderncv][CTAN::modercv]]

moderncv: a modern curriculum vitae class.

contained in tex live as moderncv

tex: /usr/local/2014/texmf-dist/tex/latex/moderncv
doc: /usr/local/2014/texmf-dist/doc/latex/moderncv

**** error: Font Awesome not found

解决：
#+BEGIN_EXAMPLE
\defaultfontfeatures{Path=/usr/local/texlive/2014/texmf-dist/fonts/opentype/public/fontawesome/}
\usepackage{fontawesome}
#+END_EXAMPLE

或 apt-get install texlive-font-extra

**** error name{}{}有两个参数，而不是一个，中文后者使用空括号即可

*** ulem                                                             :ulem:

- https://www.ctan.org/pkg/ulem

The package provides an =\ul= (underline) command which will break
over line ends; this technique may be used to replace =\em= (both in
that form and as the =\emph= command), so as to make output look as if
it comes from a typewriter. The package also offers =double and
wavy underlining, and striking out= (line through words) and
crossing out (/// over words).

** beamer                                                           :beamer:
*** beamer入门
**** reference

+ [[~/Document/Programming/TeX/Beamer/Beamer快速入门中文教程.chm][Beamer入门教程]]
+ [[https://bitbucket.org/rivanvx/beamer/wiki/Home][homepage]]
+ [[~/Document/Programming/TeX/Beamer/beameruserguide.pdf][Beamer User Guide]]

**** intro                                                         :intro:

1. *beamer* class

   Beamer 是 LaTeX 的一个用于创建幻灯片的文档类, 输出格式默认为PDF.

   \mint{latex}|\documentclass{beamer}|

2. *frame* environment

   在Beamer中, 基本环境是帧(*frame*)环境，即指幻灯片(slide), 其格式为:

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{latex}
     \begin{frame}{frame_title}
       ...
     \end{frame}
     \end{minted}
   #+end_latex

**** Beamer 主题

***** theme

主题可以设置: 常规列表(itemized list)和排序列表(enumerated list)的标记
(marker)或项目符号, 包含日期和幻灯片序号和其它信息的底边导航条等。

\mint{latex}|\usetheme{THEME}|

主题位置： /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes

#+BEGIN_SRC sh :results output :exports both
ls -l /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes
#+END_SRC

#+RESULTS:
: 总用量 20
: drwxr-xr-x 2 root root 4096  4月  3  2015 color
: drwxr-xr-x 2 root root 4096  4月  3  2015 font
: drwxr-xr-x 2 root root 4096  4月  3  2015 inner
: drwxr-xr-x 2 root root 4096  4月  3  2015 outer
: drwxr-xr-x 3 root root 4096  4月  3  2015 theme

***** 主要主题(major theme)

Beamer标准主题按城市名称命名.

#+BEGIN_SRC sh :results output :exports both
ls /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes/theme
#+END_SRC

#+RESULTS:
#+begin_example
beamerthemeAnnArbor.sty
beamerthemeAntibes.sty
beamerthemeBergen.sty
beamerthemeBerkeley.sty
beamerthemeBerlin.sty
beamerthemeBoadilla.sty
beamerthemeboxes.sty
beamerthemeCambridgeUS.sty
beamerthemeCopenhagen.sty
beamerthemeDarmstadt.sty
beamerthemedefault.sty
beamerthemeDresden.sty
beamerthemeEastLansing.sty
beamerthemeFrankfurt.sty
beamerthemeGoettingen.sty
beamerthemeHannover.sty
beamerthemeIlmenau.sty
beamerthemeJuanLesPins.sty
beamerthemeLuebeck.sty
beamerthemeMadrid.sty
beamerthemeMalmoe.sty
beamerthemeMarburg.sty
beamerthemeMontpellier.sty
beamerthemePaloAlto.sty
beamerthemePittsburgh.sty
beamerthemeRochester.sty
beamerthemeSingapore.sty
beamerthemeSzeged.sty
beamerthemeWarsaw.sty
compatibility
#+end_example

***** 次要主题(*minor themes*)

次要主题控制幻灯片外观的某些部分, 可以调用一个或多个次要主题。次要主题
分为四类:

1. 外部主题(*outer themes*):

   控制幻灯片的装饰（decorations），如显示在顶边节（header sections）
   和底边节（footer sections）中的文本和图形。

   #+BEGIN_SRC sh :results output :exports both
     ls /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes/outer
   #+END_SRC

   #+RESULTS:
   : beamerouterthemedefault.sty
   : beamerouterthemeinfolines.sty
   : beamerouterthememiniframes.sty
   : beamerouterthemeshadow.sty
   : beamerouterthemesidebar.sty
   : beamerouterthemesmoothbars.sty
   : beamerouterthemesmoothtree.sty
   : beamerouterthemesplit.sty
   : beamerouterthemetree.sty

   eg. 添加3-D 阴影到某些顶边元素。

   \mint{latex}|\useoutertheme{shadow}|

2. 内部主题(*inner themes*)

   控制幻灯片的装饰的内部区域，如常规列表（itemization lists）的标记/
   弹头，还有放置在定理周围的盒子。

   #+BEGIN_SRC sh :results output :exports both
     ls /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes/inner
   #+END_SRC

   #+RESULTS:
   : beamerinnerthemecircles.sty
   : beamerinnerthemedefault.sty
   : beamerinnerthemeinmargin.sty
   : beamerinnerthemerectangles.sty
   : beamerinnerthemerounded.sty

   \mint{latex}|\useinnertheme{}|
3. 字体主题(*font themes*)

   控制幻灯片不同元素的字形和字体尺寸。

   #+BEGIN_SRC sh :results output :exports both
     ls /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes/font
   #+END_SRC

   #+RESULTS:
   : beamerfontthemedefault.sty
   : beamerfontthemeprofessionalfonts.sty
   : beamerfontthemeserif.sty
   : beamerfontthemestructurebold.sty
   : beamerfontthemestructureitalicserif.sty
   : beamerfontthemestructuresmallcapsserif.sty

   eg. 将文档的 字体更改为衬线体（serif）。（默认为无衬线体。）
   \mint{latex}|\useinnertheme{serif}|

4. 颜色主题(*color themes*)

   控制标题、帧标题、常规列表子弹以及幻灯片其它元素的颜色。

   #+BEGIN_SRC sh :results output :exports both
     ls /usr/local/texlive/2014/texmf-dist/tex/latex/beamer/themes/color
   #+END_SRC

   #+RESULTS:
   #+begin_example
   beamercolorthemealbatross.sty
   beamercolorthemebeaver.sty
   beamercolorthemebeetle.sty
   beamercolorthemecrane.sty
   beamercolorthemedefault.sty
   beamercolorthemedolphin.sty
   beamercolorthemedove.sty
   beamercolorthemefly.sty
   beamercolorthemelily.sty
   beamercolorthememonarca.sty
   beamercolorthemeorchid.sty
   beamercolorthemerose.sty
   beamercolorthemeseagull.sty
   beamercolorthemeseahorse.sty
   beamercolorthemesidebartab.sty
   beamercolorthemespruce.sty
   beamercolorthemestructure.sty
   beamercolorthemewhale.sty
   beamercolorthemewolverine.sty
   #+end_example

   eg. 改变 Beamer 的默认颜色。
   \mint{latex}|\usecolortheme{crane}|

**** 帧工具

***** 结构色
1. 结构色

   Beamer 演示稿的大部分有颜色的部分由结构（structure）提取颜色
   （abstract color）后绘制（draw）。通过更改结构（structure）你可以改
   变 Beamer 稿的全部颜色。

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{latex}
     \documentclass{beamer}
       \usecolortheme[named=Brown]{structure}
       \usetheme[height=7mm]{Rochester}
     \end{minted}
   #+end_latex

   + 结构（structure）会影响多个项目（items），包括子弹（bullets）
     和导航图标。

   + 颜色 “Brown” 只是下列文件中定义的大量颜色名（color names）的一
     个。
     \textbackslash{}documentclass 的 xcolor=dvipsnames 选项将这些颜色
     名带入 Beamer。

     #+BEGIN_SRC sh :results output :exports code
       cat /usr/share/texlive/texmf-dist/tex/latex/graphics/dvipsnam.def
     #+END_SRC

     #+RESULTS:
     #+begin_example
     %%
     %% This is file `dvipsnam.def',
     %% generated with the docstrip utility.
     %%
     %% The original source files were:
     %%
     %% drivers.dtx  (with options: `dvipsnames')
     %%
     %% drivers.dtx Copyright (C) 1994      David Carlisle Sebastian Rahtz
     %%             Copyright (C) 1995 1996 1997 1998 1999 David Carlisle
     %%
     %% This file is part of the Standard LaTeX `Graphics Bundle'.
     %% It may be distributed under the terms of the LaTeX Project Public
     %% License, as described in lppl.txt in the base LaTeX distribution.
     %% Either version 1.3 or, at your option, any later version.
     %%
     \ProvidesFile{dvipsnam.def}
             [1999/02/16 v3.0i Driver-dependant file (DPC,SPQR)]
     \DefineNamedColor{named}{GreenYellow}   {cmyk}{0.15,0,0.69,0}
     \DefineNamedColor{named}{Yellow}        {cmyk}{0,0,1,0}
     \DefineNamedColor{named}{Goldenrod}     {cmyk}{0,0.10,0.84,0}
     \DefineNamedColor{named}{Dandelion}     {cmyk}{0,0.29,0.84,0}
     \DefineNamedColor{named}{Apricot}       {cmyk}{0,0.32,0.52,0}
     \DefineNamedColor{named}{Peach}         {cmyk}{0,0.50,0.70,0}
     \DefineNamedColor{named}{Melon}         {cmyk}{0,0.46,0.50,0}
     \DefineNamedColor{named}{YellowOrange}  {cmyk}{0,0.42,1,0}
     \DefineNamedColor{named}{Orange}        {cmyk}{0,0.61,0.87,0}
     \DefineNamedColor{named}{BurntOrange}   {cmyk}{0,0.51,1,0}
     \DefineNamedColor{named}{Bittersweet}   {cmyk}{0,0.75,1,0.24}
     \DefineNamedColor{named}{RedOrange}     {cmyk}{0,0.77,0.87,0}
     \DefineNamedColor{named}{Mahogany}      {cmyk}{0,0.85,0.87,0.35}
     \DefineNamedColor{named}{Maroon}        {cmyk}{0,0.87,0.68,0.32}
     \DefineNamedColor{named}{BrickRed}      {cmyk}{0,0.89,0.94,0.28}
     \DefineNamedColor{named}{Red}           {cmyk}{0,1,1,0}
     \DefineNamedColor{named}{OrangeRed}     {cmyk}{0,1,0.50,0}
     \DefineNamedColor{named}{RubineRed}     {cmyk}{0,1,0.13,0}
     \DefineNamedColor{named}{WildStrawberry}{cmyk}{0,0.96,0.39,0}
     \DefineNamedColor{named}{Salmon}        {cmyk}{0,0.53,0.38,0}
     \DefineNamedColor{named}{CarnationPink} {cmyk}{0,0.63,0,0}
     \DefineNamedColor{named}{Magenta}       {cmyk}{0,1,0,0}
     \DefineNamedColor{named}{VioletRed}     {cmyk}{0,0.81,0,0}
     \DefineNamedColor{named}{Rhodamine}     {cmyk}{0,0.82,0,0}
     \DefineNamedColor{named}{Mulberry}      {cmyk}{0.34,0.90,0,0.02}
     \DefineNamedColor{named}{RedViolet}     {cmyk}{0.07,0.90,0,0.34}
     \DefineNamedColor{named}{Fuchsia}       {cmyk}{0.47,0.91,0,0.08}
     \DefineNamedColor{named}{Lavender}      {cmyk}{0,0.48,0,0}
     \DefineNamedColor{named}{Thistle}       {cmyk}{0.12,0.59,0,0}
     \DefineNamedColor{named}{Orchid}        {cmyk}{0.32,0.64,0,0}
     \DefineNamedColor{named}{DarkOrchid}    {cmyk}{0.40,0.80,0.20,0}
     \DefineNamedColor{named}{Purple}        {cmyk}{0.45,0.86,0,0}
     \DefineNamedColor{named}{Plum}          {cmyk}{0.50,1,0,0}
     \DefineNamedColor{named}{Violet}        {cmyk}{0.79,0.88,0,0}
     \DefineNamedColor{named}{RoyalPurple}   {cmyk}{0.75,0.90,0,0}
     \DefineNamedColor{named}{BlueViolet}    {cmyk}{0.86,0.91,0,0.04}
     \DefineNamedColor{named}{Periwinkle}    {cmyk}{0.57,0.55,0,0}
     \DefineNamedColor{named}{CadetBlue}     {cmyk}{0.62,0.57,0.23,0}
     \DefineNamedColor{named}{CornflowerBlue}{cmyk}{0.65,0.13,0,0}
     \DefineNamedColor{named}{MidnightBlue}  {cmyk}{0.98,0.13,0,0.43}
     \DefineNamedColor{named}{NavyBlue}      {cmyk}{0.94,0.54,0,0}
     \DefineNamedColor{named}{RoyalBlue}     {cmyk}{1,0.50,0,0}
     \DefineNamedColor{named}{Blue}          {cmyk}{1,1,0,0}
     \DefineNamedColor{named}{Cerulean}      {cmyk}{0.94,0.11,0,0}
     \DefineNamedColor{named}{Cyan}          {cmyk}{1,0,0,0}
     \DefineNamedColor{named}{ProcessBlue}   {cmyk}{0.96,0,0,0}
     \DefineNamedColor{named}{SkyBlue}       {cmyk}{0.62,0,0.12,0}
     \DefineNamedColor{named}{Turquoise}     {cmyk}{0.85,0,0.20,0}
     \DefineNamedColor{named}{TealBlue}      {cmyk}{0.86,0,0.34,0.02}
     \DefineNamedColor{named}{Aquamarine}    {cmyk}{0.82,0,0.30,0}
     \DefineNamedColor{named}{BlueGreen}     {cmyk}{0.85,0,0.33,0}
     \DefineNamedColor{named}{Emerald}       {cmyk}{1,0,0.50,0}
     \DefineNamedColor{named}{JungleGreen}   {cmyk}{0.99,0,0.52,0}
     \DefineNamedColor{named}{SeaGreen}      {cmyk}{0.69,0,0.50,0}
     \DefineNamedColor{named}{Green}         {cmyk}{1,0,1,0}
     \DefineNamedColor{named}{ForestGreen}   {cmyk}{0.91,0,0.88,0.12}
     \DefineNamedColor{named}{PineGreen}     {cmyk}{0.92,0,0.59,0.25}
     \DefineNamedColor{named}{LimeGreen}     {cmyk}{0.50,0,1,0}
     \DefineNamedColor{named}{YellowGreen}   {cmyk}{0.44,0,0.74,0}
     \DefineNamedColor{named}{SpringGreen}   {cmyk}{0.26,0,0.76,0}
     \DefineNamedColor{named}{OliveGreen}    {cmyk}{0.64,0,0.95,0.40}
     \DefineNamedColor{named}{RawSienna}     {cmyk}{0,0.72,1,0.45}
     \DefineNamedColor{named}{Sepia}         {cmyk}{0,0.83,1,0.70}
     \DefineNamedColor{named}{Brown}         {cmyk}{0,0.81,1,0.60}
     \DefineNamedColor{named}{Tan}           {cmyk}{0.14,0.42,0.56,0}
     \DefineNamedColor{named}{Gray}          {cmyk}{0,0,0,0.50}
     \DefineNamedColor{named}{Black}         {cmyk}{0,0,0,1}
     \DefineNamedColor{named}{White}         {cmyk}{0,0,0,0}
     \endinput
     %%
     %% End of file `dvipsnam.def'.
#+end_example

2. 指定RGB
   可以通过指定它们的 RGB 构成来定义你自已的颜色。每一 RGB 构成必需在
   0–255 的范围内。
   #+BEGIN_EXAMPLE
     \documentclass{beamer}
     \usecolortheme[RGB={205,173,0}]{structure}   % 暗金
     \usetheme[height=7mm]{Rochester}
   #+END_EXAMPLE

   + RGB 构成可以是 0–255 范围内的整数，也可以是 0.00–1.00 范围
     内的小数。如果用小数表示，需用小写的 rgb 选项，如：
     rgb={0.2264,0.1561,0.0000}.

3. 直接使用结构色

   通过使用 *\textbackslash{}structure{a colored text}* 命令可以取得有
   趣的动态效果。给定的文本将依据结构色显示出相应的颜色。当改变结构色
   如将蓝色改成金色时，文本的颜色也因此而改变。

***** 条目标记

罗切斯特（Rochester）主题在常规列表（itemized lists）和排序列表
（numerated lists）中用了方形标记（square markers ）。

将方形标记更改为仿三维球形标记。

\mint{latex}|\setbeamertemplate{items}[ball]|

命令 *=\setbeamertemplate{items}=* 的可能选项有：
- ball: 仿三维球形
- circle: 二维（平面）圆圈
- rectangle: 矩形
- default: 三角形

***** 圆角框和阴影

要将围绕定理的盒子改成圆角并添加阴影

\mint{latex}|\setbeamertemplate{blocks}[rounded][shadow=true]|

***** 去掉导航图标

[[/home/ben/Wally/Journal/Figure/scrot/31690oTc.png]]

大部分 Beamer 主题都在幻灯片中放置了一行导航图标（navigation icons）。
（上述幻灯片底部边缘的那些小标记）。我认为这些图标漂亮但没什么用处且会
分散注意力。可以在文档中添加命令使这些导航图标不出现

\mint{latex}|\setbeamertemplate{navigation symbols}{}|

***** 添加底部导航条

底边导航条（footline）是幻灯片底部的狭窄长条，在这里，可以显示作者姓名、
演示稿的标题、幻灯片序号、其它有用的信息。

大部分底边导航条的信息摘自于导言区提供的数据如 =\author= 、=\title= 等。

Beamer 主题博阿迪利亚（Boadilla）和马德里（Madrid）默认情况下提供了这
样一个底边导航条。

可以使用命令

\mint{latex}|\useoutertheme{infolines}|

注意：这是 Beamer 的一个特殊癖性（bug的礼貌说法），即：

*=\useoutertheme{infolines}=* 必需放在
*=\usetheme[height=7mm]{Rochester}=* 之前。如果你搞反了顺序，幻灯片的
标题将被删除。

**** 帧元素

***** 封面

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
    \title[A short proof]{A short proof of Fermat's Last Theorem}
    \subtitle[Errors]{Estimation of numerical errors}
    \author[R. Rostamian]{Rouben Rostamian}
    \institute[UMBC]{
      Department of Mathematics and Statistics\\
      University of Maryland, Baltimore County\\
      Baltimore, Maryland 21250\\[1ex]
      \texttt{rostamian@umbc.edu}
    }
    \date[November 2004]{November 26, 2004}
    \begin{document}
    \begin{frame}[plain]
      \titlepage
    \end{frame}
   \end{document}
  \end{minted}
#+end_latex

1. 封面元素
   + title
   + subtitle
   + author
   + institute
   + data

2. 可选参数

   可选参数为缩写形式(short forms)，用在封面以后幻灯片的页脚处。必选参
   数为全称形式(long forms), 出现在封面上， 如果没有可选参数则也出现在
   后续幻灯片的页脚处。

3. plain限定项

   plain选项用于生成封面(titlepage)。如果没有该限定项，则封面就会装饰
   有页眉和页脚。

   plain可用于任意帧。

   \mint{latex}|\begin{frame}[plain]|

***** 图片

Beamer可以识别 pdf, png 和 jpg 格式的图像。

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\linewidth]{/path/to/image}
  \end{figure}
  \end{minted}
#+end_latex

***** 叠层
也许Beamer最有趣的效果是叠层(overlays), 它可以让幻灯片逐渐显示。在
Beamer中，要达到双层效果很简单，只需要在暂停显示的专访放置命令
*=\pause=* 即可。

=\pause= 命令不受常规列表的约束，可以在幻灯片任意地方使用。

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \begin{frame}{Outline of the talk}

  \begin{itemize}
    \item Introduction
    \pause
    \item Statement of the main theorem
    \pause
    \item Technical lemmata
    \pause
    \item Proof of the main theorem
    \pause
    \item Conclusions
  \end{itemize}

  \end{frame}
  \end{minted}
#+end_latex

***** 超链接导航(Hyperlinks)

****** 导航

目标(target)幻灯片中在 =\begin{frame}= 命令处增加 *[label=LABEL]* 标签
(tag)选项。

源幻灯片中使用命令 *=\hyperlink{LABELF}{here}=* 插入超链接。
\mint{latex}|{LABEL}{COMMENT}|

默认超链接文字显示为普通文本，可以在导言中使用 *hypersetup* 命令设置。

\mint{latex}|\hypersetup{colorlinks=true,linkcolor=red}|

超链接可以使用Beamer按钮.

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \hyperlink{LABEL}{beamerbutton{COMMENT}}
  \hyperlink{LABEL}{\beamergotobutton{COMMENT}}
  \hyperlink{LABEL}{beamerskipbutton{COMMENT}}
  \hyperlink{LABEL}{beamerturnbutton{COMMENT}}
  \end{minted}
#+end_latex

****** 返回到呼叫页

+ Acrobat Reader: M-LEFT
+ Xpdf: b

***** 定理
Beamer预定义了以下几个 LaTeX 环境：
+ theorem
+ corollary (推论)
+ definition
+ example
+ proof

Beamer主题控制着这些环境的呈现(render).

事实上，这些环境是由 amsmath 宏包定义的， Beamer自动加载该宏包。

***** 添加脚注

标准的 LaTeX 命令 *=\footnote=* 可以在幻灯片中添加脚注，但其更适合要打
印的页面而非幻灯片，脚注编号和分隔线(separator line)会放在幻灯片中不适
当的位置。

LaTeX 宏包 *textpos* 可以在页面的任意的预定义的地方放置对象(objects),
可以用来为幻灯片添加脚注类文本(footnote-like).

**** 帧布局
***** 分栏 : colums环境和嵌套的column环境

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  begin{frame}{Splitting a slide into columns}
  The line you are reading goes all the way across the slide.
  From the left margin to the right margin.  Now we are going
  the split the slide into two columns.
  \bigskip
  \begin{columns}
    \begin{column}{0.5\textwidth}
      Here is the first column.  We put an itemized list in it.
      \begin{itemize}
        \item This is an item
        \item This is another item
        \item Yet another item
      \end{itemize}
    \end{column}
    \begin{column}{0.3\textwidth}
      Here is the second column.  We will put a picture in it.
      \centerline{\includegraphics[width=0.7\textwidth]{image2.png}}
    \end{column}
  \end{columns}
  \bigskip
  The line you are reading goes all the way across the slide.
  From the left margin to the right margin.
  \end{frame}
  \end{minted}
#+end_latex

1. Note
   1) 要确保栏的总宽度不能超过幻灯片的宽度，即 *=textwidth=*
   2) 每一栏中，变量 =textwidth= 会被重定义。
   3) 也可以指定分栏的绝对宽度， Beamer幻灯片的尺寸为 *128mm x 96mm*
      \mint{latex}|begin{column}{30mm}|

2. 垂直对齐
   \mint{latex}|\begin{columns}[t]|
   + center-aligned(c): default
   + top-aligned(t): e.g. \textbackslash{}begin{columns}[t]
   + bottom-aligned(a)

3. 图像的垂直对齐

   图像默认以底部作为参照点(reference point).如果想要以顶部为参照点，
   则要使用columns环境的 [T] 选项。

***** 垂直对齐

Beamer 幻灯片的内容是垂直对齐的。

frame环境的选项 t,c,b分别使幻灯片的内容以幻灯片的顶部、中部和底部对齐，
默认为c。
\mint{latex}|\begin{frame}[t]{title}|

也可以给文类beamer增加对齐选项，使其使用于所有幻灯片。
\mint{latex}|\documentclass[t]{beamer}|
***** 缩小以适合
要缩小（squeeze）Beamer 幻灯片中的少量额外材料，你必须为该幻灯片指定一
个缩小因子(shrink-factor)，如下所示：

\mint{latex}|\begin{frame}[shrink=5]{Frame title}|

这将按比例缩小幻灯片的内容至少5% ，如果需要，还能缩小更多，直至内容完
全能被幻灯片所容纳。

为达到最佳效果，你指定的缩小因子应尽可能接近所需的数值。如果你指定的缩
小因子的值不合适，Beamer 将发出警告。调整缩小因子直至警告消失。然而，
幻灯片的水平间隙（horizontal spacing）将不是最佳的。

你不应滥用这个缩小功能——少量的缩小不会引人注意，到处都使用了缩小就会让
人看着不愉快。

可以替代这个缩小功能的是，可以考虑重写幻灯片的内容，或将内容分入两张幻
灯片中。

***** 改变页边距
*Beamer 幻灯片的尺寸是 128mm × 96mm。这个尺寸是固定的不能修改。*

然而，左右两侧的页边距（margins）却可以更改。左右两侧的页边距默认设定是 1cm 。

在下面的例子中，我们将左右两侧的页边距分别更改为 6mm 和 2mm。

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \setbeamersize{text margin left=6mm}
  \setbeamersize{text margin right=2mm}
  \end{minted}
#+end_latex

上述两条命令可以合并成一条，如下所示：

\mint{latex}|\setbeamersize{text margin left=6mm, text margin right=2mm}|

**** 字体

***** 默认字体尺寸

Beamer的默认字体尺寸是 *11 points*. 可以给文类beamer添加选项进而修改默
认字体尺寸，可选的有 8, 9, 10, 11, 12, 14, 17, 20pt.

\mint{latex}|\documentclass[14pt]{beamer}|

***** 默认的文本颜色

Beamer 的普通文本的颜色为白色背景黑色文字。 在导言区使用命令
*=\setbeamercolor=* 可以对文本颜色进行设置。

\mint{latex}|\setbeamercolor{normal text}{fg=purple}|

*fg* 用于设定普通文本(normal text)的前景色(foreground), *bg* 用于设置
普通文本的背景色。

注： 幻灯片的背景色继承于普通文本的背景色， 因此改变普通文本的背景色必
定改变幻灯片的背景色。

普通文本指幻灯片中的主体文本。幻灯片的页眉页脚不是普通文本，由结构
(structure)色控制。

\mint{latex}|\setbeamercolor{structure}{fg=purple}|

***** 结构字体和字体主题

****** 结构字体

Beamer 的结构字体(structure font)确定用于演示稿的结构元素，如页眉、页
脚和其它封面条目的字体。

\mint{latex}|\setbeamerfont{sturcture}{family=\rmfamily shape=\itshape, series=\bfseries}|

****** 字体主题

Beamer提供了字体选项的预定义设置， 它不仅影响结构元素，而且影响普通文
本和数学式。

\mint{latex}|\usefonttheme{serif}|
**** 颜色
Beamer 借助于一个外部工具处理颜色，该外部工具是一个名为 *xcolor* 的宏包。
Beamer 默认加载 xcolor，因而你无需加载它。默认加载 xcolor 宏包后，下列
颜色可用：

[[/home/ben/Wally/Journal/Figure/scrot/19740X3z.png]]


***** dvips宏包命名的颜色

Xcolor 宏包可以读取来自dvipsnam.def 文件的扩展的色名集（extended set
of color names ）。许多 LaTeX 分发版提供了dvipsnam.def 文件。

要在 Beamer 中使用该扩展的色名集，请按以下方式调用 Beamer：

\mint{latex}|\documentclass[xcolor=dvipsnames]{beamer}|

[[/home/ben/Wally/Journal/Figure/scrot/19740WLJ.png]]

***** SVG宏包命名的颜色
Xcolor 能读取来自文件 svgnam.def 的更大的色名集，多 LaTeX 分发版提供了
svgnam.def文件。
p
要在 Beamer 中使用该扩展的色名集，请按以下方式调用 Beamer：

\mint{latex}|\documentclass[xcolor=svgnames]{beamer}|

***** 混合色
xcolor 宏包提供了一个工具，用它可以混合任何色集以得到不同的颜色比例，
就象你在油画中混合颜色一样。

我们指定一个混合色组成为 A!n!B，即颜色A占n%，颜色B占(100-n) %。在
Beamer 中，A!n!B 表达式可以用在预期颜色名的地方。表达式 A!n 是
A!n!white 的简写形式。下面是一些例子。

[[/home/ben/Wally/Journal/Figure/scrot/19740jVP.png]]

***** 自定义颜色
除上述的机制外，就象LaTeX 手册记录的那样，你可以用 =\definecolor= 命令
定义颜色，加载color 宏包后并使 =\definecolor= 可用。

可以通过指定 RGB（Red Green Blue 即红绿蓝）的组成来指定颜色，
RGB组成用 0 到 1 的小数表示，如下所示：
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\definecolor{mygold}{rgb}{0.85, 0.60, 0.00}  % 注意用小写的 rgb
\end{minted}
#+end_latex

另外，RGB 的组成也可以用 0 到 255 之间的整数表示，如下所示：
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\definecolor{mygold}{RGB}{217, 153, 0}       % 注意用大写的 RGB
\end{minted}
#+end_latex


***** 有色文本，高亮和盒子

****** 有色文本
Beamer中的有色文本用的是标准的 LaTeX 命令 *=\textcolor=* 生成的

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\textcolor{blue}{This ia in blue}
\end{minted}
#+end_latex

****** 高亮
*=\colorbox=* 命令指定文本的背景色，即底纹。

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\colorbox{yellow}{This text is highlieghted in yellow}
\end{minted}
#+end_latex

****** 盒子
*=\fcolorbox=* 将文本框起来。
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\fcolorbox{red}{yellow}{A yello box with red borders}
\end{minted}
#+end_latex

+ =\setlength{\fboxrule}{4pt}= 设置框的宽度
+ =\setlength{\fboxsep}{0pt}设置框与被框对象的间隔。

***** 幻灯片背景
Beamer默认的幻灯片背景是白色。

****** 设置为固定的颜色(solid)
设为淡品红色
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\setbeamercolor{normal text}{bg=red!12}
\end{minted}
#+end_latex

****** 渐变色

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\setbeamertemplate{background canvas}[vertical shading][bottom=red!20,top=yellow!30]
\end{minted}
#+end_latex

****** 叠加网格

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\setbeamertemplate{background}[grid][step=5mm,color=blue]
\end{minted}
#+end_latex

****** 使用图像作为背景
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
\setbeamertemplate{background canvas}{\includegraphics
        [width=\paperwidth,height=\paperheight]{alps.jpg}}
\end{minted}
#+end_latex

注意：Beamer 幻灯片的长宽比是 4:3，因此你的背景图片的长宽比最好也是
4:3，否则，在拉伸图片填满幻灯片时，背景图片会变形。

****** 设定单张幻灯片背景
要将背景设置限定在单张幻灯片，请将命令 =\setbeamertemplate{background canvas}{...}= 放在大括号中，
如下所示：

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  { % 大括号限定 \setbeamertemplate 的范围
  \setbeamertemplate{navigation symbols}{}  % 可选地隐藏导航按钮
  \setbeamertemplate{background canvas}{\includegraphics
          [width=\paperwidth,height=\paperheight]{alps.jpg}}
  \begin{frame}[plain]
  ...
  \end{frame}
  } % 结束大括号
  \end{minted}
#+end_latex

****** 注意
精美的背景色、阴景及图像可以使你的幻灯片看上去很漂亮，但也会使人分心。
请在你的演示稿中恰如其分地应用这些设计（devices）。

*** beamer ppt                                                        :ppt:
+
   http://tex.stackexchange.com/questions/21986/export-beamer-slides-to-powerpoint-openoffice-impress-keynote-editable-format
+ http://superuser.com/questions/268244/how-to-convert-pdf-to-ppt-or-odp


"beamer can export to PDF or PS", beamer doesn't export anything. It
is a LaTeX class and LaTeX compiles the document to PDF (pdflatex) or
DVI (latex) which then is mostly converted to PS. There is of course
no powerpointlatex, so you will need to convert the PDF or PS somehow
to a format PP can read, which would be RTF (Rich Text Format) or some
Windows vector format like EMF or WMF. However, I would do it either
with one or the other software. They do not mix well.

**** pdf to ppt
+  [[http://superuser.com/questions/268244/how-to-convert-pdf-to-ppt-or-odp][cnvert pdf to ppt]]

The desired result can also be achieved without proprietary tools. If
you have GhostScript installed, you can convert your PDF presentation
into a set of JPG images using:

#+begin_latex
  \begin{minted}[frame=single, mathescape]{sh}
  gs -dNOPAUSE -dBATCH -dSAFER -dGraphicsAlphaBits=4 -dTextAlphaBits=4 \
     -sDEVICE=jpeg -r300 -sOutputFile='page-%00d.jpg' YOURFILE.pdf
  \end{minted}
#+end_latex

Then, with the plugin for OpenOffice/LibreOffice create a presentation
where each image fills exactly one slide. You can also easily keep the
order of the pages by choosing the plugin option "natural sorting".、

*Edit -> Link -> 断开链接*  否则以链接形式插入。
*** DONE Beamer in orgmode                                     :beamer:org:
- State "DONE"       from "TODO"       [2015-12-02 三 16:02] \\
  用以致学，需要用的时候再学
**** reference

+ [[http://orgmode.org/worg/exporters/beamer/tutorial.html][orgmode tutorial for beamer]]
+ [[http://orgmode.org/manual/Beamer-export.html][orgmode manual: export to beamer]]
+ http://www.latexstudio.net/org-beamer-cn-template/

**** insert template
*C-c C-e #*  insert default template

**** Beamer specific settings
+ #+startup:beamer
+ #+LaTeX_CLASS: beamer
+ #+LaTeX_CLASS_OPTIONS: [bigger]
+ #+BEAMER_FRAME_LEVEL:2
  - Note: Beamer also makes user of LaTeX sectioning to group frames
+ #+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args)
  %4BEAMER_col(Col) %10BEAMER_extra(Extra)
**** a simple slide
#+BEGIN_EXAMPLE
  ,* Introduction
  ,** A simple slide
  This slide consists of some text with a number of bullet points:

  - the first, very @important@, point!
  - the previous point shows the use of the special markup which
    translates to the Beamer specific /alert/ command for highlighting
    text.


  The above list could be numbered or any other type of list and may
  include sub-lists.
#+END_EXAMPLE
**** block
+ M-x org-beamer-mode
+ C-c C-b

#+BEGIN_EXAMPLE
  ,** Two columns

  ,*** A block                                           :B_ignoreheading:BMCOL:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :BEAMER_col: 0.4
      :END:
      - this slide consists of two columns
      - the first (left) column has no heading and consists of text
      - the second (right) column has an image and is enclosed in an
        @example@ block

  ,*** A screenshot                                            :BMCOL:B_example:
      :PROPERTIES:
      :BEAMER_col: 0.6
      :BEAMER_env: example
      :END:
  ,    #+ATTR_LATEX: width=\textwidth
      [[file://../../images/org-beamer/a-simple-slide.png]]
#+END_EXAMPLE

Note
+ B_ignoreheading: ignore heading
+ #+ATTR_LATEX: set atttibute
**** export
C-c C-e l b

** thesis
*** [[http://purpletulipdyc.blog.sohu.com/259698858.html][LaTeX 引用多个参考文献]]                                           :blog:

如果在文章中出现连续引用多个参考文献的情况，希望显示的格式为 [1-9]
在文章的导言区加

#+BEGIN_EXAMPLE
\usepackage{cite}
#+END_EXAMPLE

在文章正文中需要引用参考文献的地方使用：

#+BEGIN_EXAMPLE
\cite{liu2012, wen13,wang2010VTC,shen2008ICC,Alex2007ICC}
#+END_EXAMPLE

*** [[http://blog.163.com/niu_yingli/blog/static/23742385200821110453659/][Latex--将参考文献号设为上标，并加方括号！ ]]                       :blog:

# 使用 BUAA-LATEX 不用考虑这个问题

1. 使用宏包：cite，并选“superscript”选项：

   #+BEGIN_EXAMPLE
   \usepackage[superscript]{cite}
   #+END_EXAMPLE

2. 在引用文献的地方使用“cite”命令：

   #+BEGIN_EXAMPLE
   \cite{Tom}
   #+END_EXAMPLE

   这样，参考文献号将位于上标处，但是没有方括号！

   如果调用宏包“cite”时，不加“superscript”，则参考文献号在方括号里，
   如： =[1]=

3. 打开文件：\texmf\tex\latex\cite\cite.sty
   修改：

   #+BEGIN_EXAMPLE
     176%  Superscript cite, with no optional note.  Check for punctuation first.
     177%
     178\def\@citew#1{\begingroup \leavevmode
     179  \@if@fillglue \lastskip \relax \unskip
     180  \def\@tempa{\@tempcnta\spacefactor
     181     \/% this allows the last word to be hyphenated, and it looks better.
     182     \@citess{\citen{#1}}\spacefactor\@tempcnta
     183     \endgroup \@restore@auxhandle}%
     184  \oc@movep\relax}% check for following punctuation (depending on options)
   #+END_EXAMPLE

   将182号改为：

   #+BEGIN_EXAMPLE
   182     \@citess{\citeleft\citen{#1}\citeright}\spacefactor\@tempcnta
   #+END_EXAMPLE

4. 保存，编译你的Latex文件即可！！！

*** [[http://xb9he.bokee.com/6688578.html][LaTeX 的对参考文献的处理]] :blog:


LaTeX 的对参考文献的处理实在是非常的方便，我用过几次，有些体会，写出来供大家
参考。当然，自己的功力还不够深，有些地方问题一解决就罢手了，没有细究。

    LaTeX 对参考文献的处理有这么一些优点：

1. 可以维护一个 bib 文件，在你的整个研究生涯可以只维护这样一个文件，就象一个数
据库，每个参考文献是一个记录，由一个唯一的 ID （例如下面的 MartinDSP00）描述。
比如我的 myreference.bib 文件里一条典型的文献是这样的：

@article{MartinDSP00,
     author = "A. Martin and M. Przybocki",
     title = "The {NIST} 1999 speaker recognition evaluation --- an overview",

     journal = "Digital Signal Processing",
     volume = "10",
     pages = "1--18",
     year = "2000",}

    其中 {NIST} 中的大括号不会被显示，它的作用是保证将来的生成的参考文献中 NIST
 四个字保持原样，不会被小写。

2. 需要引用文献的时候，在正文里加入：

\bibliographystyle{ieeetr}
\bibliography{myreference}

    就可以用 \cite{} 来引用文献库中的论文了，如 \cite{MartinDSP00}。上面第一行是
控制文献显示格式的，这个后面再讲。此时，myreference.bib 文件在正文 tex 文件的同
一目录下，以保证 LaTeX 可以找到该 bib 文件。

3. 编译正文之后，生成 aux 文件，然后用 bibtex 在当前目录生成 bbl 文件，再编译正
文两次，完整的 dvi 就生成了。这样，LaTeX 保证了所有用 \cite 引用到的文献都已被
列出，并且自动编号。同时，如果没有用 \nocite 命令，LaTeX 还保证所有列出的参考文
献都在正文中得到了引用。

4. 关于 bib 文件
    前面提到 bib 文件的维护问题。我一般不对里面的文献排序，如果文献比较多，需要
查找的话，可以通过查询关键字来实现。bib 文件把 @ 所定义的 entry 之外的所有东西
看作是注释。比如在上面 @article 的例子里，如果我在大括号之外写些东西的话，bibt
ex 是不会关心的，就当它不存在。所以我就把文献的关键字写在这里，将来通过搜索关键
字来查找某些文献。其实也可以搞一个临时的 LaTeX 文件，使用 \nocite{*} 命令，然后
编译成 dvi，这样就得到了一个 bib 文件中所有参考文献的列表，当然是可以按照作者名
字排序的。
    另外，很多 journal（学术期刊）或者 booktitle（国际会议）都是重复的，为了规范
化，可以定义缩写，如

@string(ICASSP = "Proc. of the International Conference on Acoustics, Speech,
and Signal Processing (ICASSP)")

    然后

    @conference{QL.ICA98,
     author = "Qi Li and Biing-Hwang Juang",
     title   = "Speaker Verification Using Verbal Information Verification for A
utomatic Enrollment",
     booktitle = ICASSP,
     year = "1998",}

    这样在执行 bibtex 之后，ICASSP 会被替换成它的全称。

5. bib 中的中文文献
    中文文献和英文的格式不同，并且使用全角的标点符号，有一点难办。我的解决办法是
这样的：

    @misc{Xie.1995,
     note = "谢锦辉，《隐 {Markov} 模型及其在语音处理中的应用》，华中理工大学出
版社，1995年4月",
     key = "Xie",}

    唯一的缺陷是参考文献中最后是以英文的 "." 而不是 "。" 结束的。还好我的中文文
献不多，无伤大雅，否则就手工修改一下 bbl 文件吧。

6. 关于参考文献的显示格式、排序，及其他
    前面提到参考文献的排序问题，以及引用序号是 LaTeX 提供的 ID 还是数字的问题。
其实不止这些，参考文献的显示格式也是可以定制的。参考文献以正文中引用顺序排序，
还是以文献第一作者的 last name 排序，是通过一些 bst 文件来控制的。而使用哪种 b
st 格式，可通过 bibliographystyle 命令控制。LaTeX 默认提供了这么几种格式，如：
plain、alpha、unsrt等。具体意义见相关文档，这些 bst 在 texmf\bibtex\bst\base 可
被找到。
    bst 控制的格式非常细致，除了上面讲过的排序方式等，还有：作者名字是否用缩写，
作者名字放在文献的起始还是结束，文章 title 要不要大小写（即 "Speaker Verificat
ion Using ..." 还是 "Speaker verification using "），title 用什么区分（用不用引
号括起来，用不用斜体等），刊物名字的格式（要不要全部大写，要不要粗体，要不要斜
体，要不要括起来），等等等等。打开 bst 文件看一下就知道，绝对是想要什么形式，就
可以得到什么形式。最关键的是，在文章定稿之后，完全可以用几个命令重新定义参考文
献的格式！

    给个例子：采用 IEEE 给出的 bst 格式（即 ieeetr.bst），声明：

\bibliographystyle{ieeetr}

    就可以使用了。最终格式是这样的（按正文引用顺序排序）：
    [4] D. A. Reynolds, "Comparison of background normalization
        methods for text-independent speaker verication," in
        EUROSPEECH, 1997.

7. 如何定制参考文献的显示格式
    其实 bst 文件有很多，总能找到自己需要的。如果这些还不能满足，可以通过生成自
己的 bst 文件来定制。这有两个方法，第一是手写（反正我是写不出来），第二是通过工
具。custom-bib 是一个定制 bst 文件的包，解压缩后用 LaTeX 编译其中的主 tex 文件
，便会进行交互式的 bst 定制过程，具体过程我就不讲了。把生成的自定义的 bst 放到
 LaTeX 相应目录下，刷新文件名数据库就可以使用了。

** miscellaneous
*** [[http://lanbing510.info/2013/04/05/Latex-Experiences.html][Latex插入Visio绘制的流程图]]            :flowchart:visio:blog_冰蓝:

都知道Visio是画流程图的利器，但插入Latex可能会变得模糊，下面是本人认为
插入最清晰的一种方式。

*一、绘制好Visio图后保存为Pdf*

文件-->页面设置-->页面尺寸选择调整大小以适应绘图，然后发布为Pdf，比如PR1\_Visio.pdf

*二、插入Pdf*

1. 如果要插入到浮动窗口，可以直接利用

   #+BEGIN_SRC latex
       \begin{figure}
       \centering
       \includegraphics[width=\textwidth]{PR1_Visio.pdf}
       \caption{fit}\label{}
       \end{figure}
   #+END_SRC

2. 如果要插入到非浮动区域，可以采用以下办法，为了可以在figure外使用
   \caption，可在导言部分加入：

   #+BEGIN_SRC latex.
       \makeatletter
       \newcommand\figcaption{\def\@captype{figure}\caption}
       \newcommand\tabcaption{\def\@captype{table}\caption}
       \makeatother
   #+END_SRC

   然后直接用下面的插入命令即可。

   #+BEGIN_SRC latex
       \begin{center}
       \includegraphics[width=4cm,height=8cm]{PR1_Visio.pdf}
       \figcaption{系统聚类算法流程图}\label{}
       \end{center}
   #+END_SRC

*** [[http://blog.sina.com.cn/s/blog_4d72d6e70100otue.html][使用Latex2Html (l2h)将Latex转为Html ]]                        :blog:html:

使用Latex写论文时，有一个缺点是不方便协作修改，不能使用类似于word提供的修改跟踪等功能。虽然也有很多开源的工具提供了Latex文件编辑的跟踪功能，但总体都是在Latex源码上进行修改，不方便修改人（特别是当修改人不会使用Latex）使用。我们的原则是，既然是我们请别人修改论文，当然是让修改人轻松点，我们多劳动点了。最简单的办法是将latex转成Word了，然后把word文件交给审稿人了。
将latex转成word有很多方法。最简单最完全工作量也最大的一种是用word重新撰写一遍。当文档包含大量的公式，符号时，重写一遍的工作量是很大的，不太可行。还有一种方法是将latex生成为pdf，然后在pdf上copy text，然后手动粘贴图片。对于公式和符号等，也要重新写一边或者直接粘贴为图片。这种方法还有一个问题是会在原pdf每行末尾增加一个换行，看起来非常不爽。还有一种办法是采用一些latex转word或者rtf的工具，这些工具基本上需要花钱买，而且生成的格式也不是非常完美。
个人觉得将latex转成html，然后在将html粘贴到word中是一个比较好的解决方案。本文介绍如何使用开源工具latex2html(l2h)。之所以整理一下是因为这个工具配起来不是很容易，折腾我一个上午的时间。
前提：
（1）安装Miktex，GS, GSView, Netpbm（for windows, 我用的10.27，有更新的版本）.
（2）安装Perl，如ActivePerl等。
注意：这些文件都要建议安装在C盘，各安装目录名称中不要有空格。MikTex在默认安装的目录中有空格如MikTex 2.5，把空格去掉。之所以这样做是因为Latex2html比较土，不支持路径中的空格。
（3）下载Latex2html，我用的版本是2002
（4）把下载的安装包解压到C盘一个临时目录，如C:\temp
（5）修改文件prefs.pm:
123行：
$prefs('EXTRAPATH')='C:\\TEXUTILS\\GS5.50;C:\\TEXUTILS\\NETPBM\\BIN';
中修改为（1）中各应用程序可执行文件目录，如
$prefs{'EXTRAPATH'} = 'C:\\Texs\\Ghostgum\\gsview;C:\\Texs\\gs\\gs8.53\\bin;C:\\Texs\\GnuWin32\\bin;C:\\Texs\\MiKTeX2.5\\miktex\\bin';
129 行：
$prefs('PREFIX')= 'C:\\TEXUTILS\\L2H';
将改值修改为你打算安装Latex2Html到的目录
（6）运行Config.bat，检查各项是否正确。
（7）运行test.bat，看是否正常执行。正常执行完成后在tests目录下会生成l2htest目录及输出的html文件等。无误后点击install.bat，安装latex2html到（5）中配置的目录
（8）配置Latex2html，修改l2hconf.pm 文件。
line 52
@IMAGE_TYPES = qw(gif png);
line 290
$LOCAL_ICONS = 1;
line 553
$HTML_VERSION = '3.2,math';
line 567
$UNSEGMENT = 1;
line 767
$EXTRA_IMAGE_SCALE = 2;
（9）测试，如运行latex2html.bat c:\t\mytex.tex. 对于论文，通常使用下面命令（可将下面命令做成批处理，放到latex文件目录下）：
C:\Texs\l2h\bin\latex2html -split 0 -lcase_tags -nonavigation -notop_navigation -auto_prefix -noinfo -image_type png -show_section_numbers -noaddress -numbered_footnotes CTRanking_Dou.tex
配置到这里，一个简单的latex文件应该可以转成html了。但我的论文中有大量的figure，当时为了方便，这些figure被我统一放到tex文件下的一个figures目录中了。需要手动将figures目录copy到latex2html生成的目录，如CTRanking_Dou中，同时还需要把对应的cls文件也copy过去。此外，需要把latex生成的附属文件如aux,bib文件等也copy过去。这样才能保证能够正确的生成论文中的图像文件。
到这里基本上就okay了，不过生成的html文件还是有点小问题，如公式对应的图片左边和下边有黑边，subfigure序号有问题（所有subfigure被统一编号，而不是一个figure一编），不过总体说来，还算可以了。毕竟对latex修改完后，直接执行一个命令，一个html文件就生成了。然后copy到word中，就可以交给别人去修改了。
参考资料：http://www.mayer.dial.pipex.com/l2h.htm

*** [[http://zhidao.baidu.com/link?url=81iKOAaTCNYG0-Wej-I2TwGNHmTBytvj7M6GeEpb1KdHWqUE1eqLyQtYcdZqjtnlc97r3bSZyg1ZEAOAsORhuox3q33i3PdbEug-d2AmX6u][如何把Latex自动转为Word]]                                     :blog:word:

论文给导师修改又产生了很多麻烦。PDF上直接加Note可读性很差。最好还是能尽量保持公式、图形、Reference的完整性，然后直接转成
Word，然后导师在Word上用审阅模式修改，我们自己在Latex对应修改。这样导师就不用面对丑陋的Latex源码了。
简单的说，我们可以这样做：
1）我们用Latex书写论文
2）我们转成Word给导师
3）导师使用Word的审阅功能，修改论文
4）我们对照修改的地方直接修改Latex
5）最后生成修改后的PDF。
这样我们方便，导师也方便。具体方式如下：
以Ubuntu的Linux系统如下：
1、安装Latex
sudo apt-get install texlive
2、安装latex2html
sudo apt-get install latex2html
3、把论文从Latex转换为html
latex2html -split +0 input.tex
(input.tex是我们的论文tex文件)
4、这时在当前目录下多出一个input目录，大家可以弄到Windows里。（相信大家都有一个Linux的远程机器）
5、这个目录就是所有的html文件，找到index.html，右键用Word打开。
6、在word里另存为.doc或者docx文件。
7、把word文档发给导师，等那些让人心惊肉跳的红字和note吧。。。
大功告成，这样比Acrobat
Pro转为word文档在格式上更加安全。所有公式、图片、表格、算法都会被变为图片或者相应格式，在word里显示没有任何问题。
(注意：使用这种办法，要求你的tex可以在latex编译出dvi没有问题，也就是说使用eps图片的没有问题，但是使用pdf，jpg图片格式的，由于使用pdflatex命令编译出PDF。这个方法就不行了，需要手动改一下html文件)。
（EPS图片问题，我一般使用ImageMagic去批处理的转jpg，pdf到eps，然后在tex文件里引用eps图片，这样就规避了无论用pdflatex或者latex都可以编译出正确的pdf和dvi，那么Latex2html就没有任何问题了）
* Boost                                                               :boost:
** reference                                                      :homepage:

- [[http://www.boost.org/][Homepage]]
- [[~/Wally/Reference/Textbook/BeyondSTL_AnIntroductionToBoost_Zh.pdf][BeyondSTL_AnIntroductionToBoost_Zh.pdf]]
- [[~/Wally/Reference/Textbook/BeyondTheC++StandardLibrary-AnIntroductionToBoost.pdf][BeyondTheC++StandardLibrary-AnIntroductionToBoost.pdf]]
- [[~/Wally/Reference/Manual/BoostDoc_En.chm][BoostDoc_En.chm]]
- [[~/Wally/Reference/Manual/BoostDoc_Zh.chm][BoostDoc_Zh.chm]]
- [[~/Wally/Reference/Guide/BoostPython.pdf][BoostPython.pdf]]
- [[~/Wally/Reference/Guide/Boost库学习指南.pdf][Boost库学习指南.pdf]]
- [[http://www.boost.org/doc/libs/1_60_0/][Document]]

** TODOs

** intro

*** overview                                                     :overview:

Boost是一套开放源代码的、高度可移植的C++库，在C++社区中被成为“准标准
库”。
_要想成为高手，一定要多读高手编写的代码。_ Boost库的代码相当清晰、注释
合理、明明规范，绝对是适合阅读的规范(STL则不然)。
Boost的内容广泛，包括 *数值计算、泛型编程、元编程、智能指针、类型转换
等*

C++的编程范式（Paradigm）

+ 过程式编程（prodedural programming）
+ 面向对象的编程（oop）
+ 泛型编程（generic programming）

e.g.
- 类型转换 —— Boost.lexical_cast
- 复杂文本处理 —— Boost.Tokenizer, Boost.Regex
- 语法分析 —— Boost.Spirit
- 函数反射和组合 —— Boost.Bind
- 函数式编程 —— Boost.Lambda
- 静态断言 ——　 MPL
- 数学　——　Ｂoost.Math, Boost.Graph, Quaternion, MultiArray, Random, Rational
- Python ——　Boost.Python

*** install                                                       :install:

*** Boost库简介


# from : boost学习指南

Boost是一套开放源代码、高度可移植的C++库.

boost是一个准标准库，相当于STL的延续和扩充，它的设计理念和STL比较接近，
都是 *利用泛型让复用达到最大化* 。不过对比STL，boost更加实用。STL集中
在算法部分，而boost包含了不少工具类，可以完成比较具体的工作。

boost主要包含一下几个大类：
+ 字符串及文本处理
+ 容器
+ 迭代子 (Iterator)
+ 算法
+ 函数对象和高阶编程
+ 泛型编程
+ 模板元编程
+ 预处理元编程
+ 并发编程
+ 数学相关纠错和测试
+ 数据结构
+ 输入/输出
+ 跨语言支持
+ 内存相关
+ 语法分析
+ 杂项

e.g
+ conversion/lexcial_cast: 数值类型和字符串的转换
+ format: 流的printf-like
+ regex: 正则表达式
+ tokenizer
+ array
+ dynamic_bitset
+ graph
+ mulit_array
+ thread(基于Posix线程)
+ static_assert
+ test
+ concept_check
+ any
+ compresed_pair
+ tuple
+ pyhon
+ pool： 内存池
+ smart_ptr: 智能指针
+ date_time(跨平台)
+ timer
+ uitlity

*** howto

*想成为高手，一定要多读高手写的源代码*.Boost库的代码则相当清晰，注释合
理，命名规范，绝对是适合阅读的典范。同时，Boost内容广泛，数值计算、泛
型编程、元编程、平台API

**

** Program options                                         :program_options:

*** reference

- [[http://www.boost.org/doc/libs/1_60_0/doc/html/program_options.html][boost doc]]

*** Get Started





** totar
*** boost学习指南



**** lexical_cast
***** 字符串->数值
1. 标准C库函数
   1) "123" -> (int)123: *atoi*
   2) "123" -> (long)123: *atol*
   3) "123.12" -> (double)123.12: *atod*
   4) "123.12" -> (long double)123.12: *atold*

2. 标准库string

   string -> const char* -> ato*(把陌生的问题转换为熟悉的问题)

3. lexical_cast

   1) 头文件: #include <boost/lexical_cast.hpp>

   2) eg

     #+header: :exports both
     #+header: :tangle /home/ben/Tiger/Journal/src/1503312016.cpp
     #+BEGIN_SRC C++
       #include <iostream>
       #include <boost/lexical_cast.hpp>

       int main(int argc, char *argv[])
       {
         using boost::lexical_cast;
         int a = lexical_cast<int>("123");
         double b = lexical_cast<double>("123.12");
         std::cout << a << std::endl;
         std::cout << b << std::endl;
         return 0;
       }

     #+END_SRC

     #+RESULTS:
     |    123 |
     | 123.12 |

***** 数值->字符串
1. 标准C函数库没有类似atol的提供方法.

2. 使用sprintf
   #+BEGIN_EXAMPLE
   sprintf(s, "%f", 123.12);
   #+END_EXAMPLE

3. lexical_cast

   #+header: :exports both
   #+header: :tangle /home/ben/Tiger/Journal/src/1503312028.cpp
   #+BEGIN_SRC C++
     #include <string>
     #include <boost/lexical_cast.hpp>

     int main(int argc, char *argv[])
     {
       using std::string;
       const double d = 123.123456789;
       string s = boost::lexical_cast<string>(d);
       std::cout << s << std::endl;
       return 0;
     }
   #+END_SRC

   #+RESULTS:
   : 123.123456789

***** 异常
如果转换失败，则会有异常bad_lexical_cast抛出。该异常类是标准异常类
bad_cast的子类

注: org-babel只能捕获标准输出, 异常和错误暂时不支持, 或者说我不知道.

#+header: :exports both
#+header: :tangle /home/ben/Tiger/Journal/src/1503312033.cpp
#+BEGIN_SRC C++
  #include <iostream>
  #include <boost/lexical_cast.hpp>

  int main(int argc, char *argv[])
  {
    using std::cout;
    using std::endl;
    int i;
    try{
      i = boost::lexical_cast<int>("abcd");
    }
    catch(boost::bad_lexical_cast& e){
      cout << e.what() << endl;
      cout << "error in casting" << endl;
      return 1;
    }
    cout << i << endl;
    return 0;
  }

#+END_SRC

#+RESULTS:

ERROR: bad lexical cast: source type value could not be interpreted as
target error in casting.

***** 注意事项
1. 输入数据必须完整转换, 否则会抛出异常.eg.
   #+BEGIN_EXAMPLE
   boost::lexical_cast<int>("123.123").
   #+END_EXAMPLE
2. 浮点数的精度问题

   经验证, 新的版本已经排除了精度限制的bug.

**** 智能指针
***** 简介

智能指针是存储指向动态分配（堆）对象指针的类。除了能够在适当的时间自动删除指向的对
象外，他们的工作机制很像C++的内置指针。智能指针在面对异常的时候格外有用，因为他们
能够确保正确的销毁动态分配的对象。他们也可以用于跟踪被多用户共享的动态分配对象。
事实上，智能指针能够做的还有很多事情，例如处理线程安全，提供写时复制，确保协议，并
且提供远程交互服务。

智能指针的大部分使用是用于生存期控制，阶段控制。它们使用operator->和
operator*来生成原始指针，这样智能指针看上去就像一个普通指针。

***** 分类

+ scoped_ptr: 单个对象的唯一所有权
+ scoped_array: 处理数组
+ shared_ptr: 允许共享对象的所有权
+ shared_array: 允许共享数组所有权

***** TODO shared_ptr

**** TODO Thread

*** DONE 超越C++标准库Boost
- State "DONE"       from "TODO"       [2015-04-24 五 21:20]
**** DONE Boost:Smart_ptr
SCHEDULED: <2015-04-05 日>
- State "DONE"       from "TODO"       [2015-04-13 一 22:16]
***** smart_ptr库

+ shared_prt : 共享所有权(shared ownership)
+ weak_ptr : 共享资源
+ scoped_ptr/scoped_array : 限制作用域 , 异常安全的(expction-safe)
***** when
+ 资源的共享所有权

  共享所有权(shared ownership)指两个或多个对象必须同时使用第三个对象时
  的情况(何时释放？)

+ 编写异常安全的代码

  动态分配的对象，在异常抛出时不会删除该对象。

+ 避免常见的错误，如资源泄漏

***** 智能指针scoped_ptr

****** 头文件
+ boost/scoped_ptr.hpp
+ 不能转移所有权，即不能复制或赋值
+ 轻量级

****** 成员
1. 构造函数
   + explicit scoped_ptr(T* p=0)
   + 类型T不必是完整的，只需要对T进行前声明即可

2. ～scoped_ptr()

3. void reset()
   + 重置

4. T &openrator*() const
   + 返回智能指针存储的指针指向的对象的引用

   + 注： 不允许空的引用

5. T* operator->()const
   + 返回智能指针所存储的指针

   + 空指针会抛出异常

6. T* get() const
   + 返回智能指针所存储的指针，直接操作裸指针(raw pointer)

7. void swap(scoped_ptr& b)
   + 交换

****** 使用
智能指针scoped_ptr的使用方法与普通指针的用法没有多大区别，最重要的一点
是不必再记着在指针上调用delete函数， 也不允许复制。

***** scoped_array

***** shared_ptr

***** shared_array

***** intrucsive_ptr
shared_ptr的侵入式版本， 暂时不看。

***** weak_ptr
shared_ptr的观察者， 不懂。
**** Convention库
+ 提供可理解、可维护以及一致的多态转换(polymorphic convention)
+ 静态向下转换(downcast)使用比static_cast更安全的构造
+ 保持值范围(range-preserving)的数值转换
+ 正确且可重用的词汇转换

***** polymorphic_cast
+ 头文件: "boost/cast.hpp"
+ dynamic_cast的引用(空引用抛出异常)和指针(空指针返回空)的不一致性
+ 针对指针的版本
+ 向下转换(向基类)
+ 交叉转换(crosscast)，即从一个基类到另外一个基类的转换
+ 如果不认为失败的多态指针转换是错误的话，那么就应该使用dynamic_cast

***** polymorphic_downcast
+ "boost/cast.hpp"
+ dynamic_cast效率低，static_cast风险大
+ 发布模式 VS 调试模式

***** numeric_cast
+ "boost/cast.hpp"
+ 整型转换的范围问题
  - C++，转换依赖于实现
  - boost, 抛出bad_numeric_cast异常
+ 无符号整型
  - 任何数值都可以合法地赋值给无符号整型
  - 范围
  - 符号，即负数转换
+ 浮点数
  - double -> float, 精度损失，boost不会抛出异常
  - 浮点 -> 整型， 截断后判断范围

***** lexical_cast
+ "boost/lexical_cast.hpp"
+ 词法转换
+ bad_lexical_cast异常
+ 要求：
  - 源类型是可流输出的(OutputStreamable)
  - 目标类型是可流输入的(InputStreamable)
  - 两者都是可复制构造的(CopyConstructible)

**** DONE Utility
SCHEDULED: <2015-04-08 三>
- State "DONE"       from "TODO"       [2015-04-14 二 14:59]
- State "TODO"       from "TODO"       [2015-04-14 二 14:59]
***** BOOST_STATIC_ASSERT
+ "boost/static_assert.hpp"
+ 编译时断言
+ BOOST_STATIC_ASSERT 宏
+ 类和函数的参数化判断

***** checked_delete
+ "boost/checked_delete.hpp"
+ 在删除动态对象时，必须调用它的析构函数，如果类型是不完整的，即只有声
  明没有定义，那么就有可能没有调用函数，这是一种潜在的危险状态。(编译
  时可能没有警告提示)
+ checked_delete 确保类型是完整的，在编译时提示错误
+ checked_array_delete
+ 没有运行时的额外开销

***** noncopyable
+ "boost/utility.hpp"
+ 作为基类使继承类不可复制或进行赋值
  + 编译器自动提供复制构造函数和赋值运算符
  + 当类拥有不能复制或不能赋值的基类或成员函数时，编译器造成的复制构造
    函数和赋值运算符就会不可用
  + 以私有方式继承(默认)，因为继承关系不明显
+ 原理：基类中定义复制构造函数和赋值运算符为私有访问，因而不可访问
+ 也可以自行以私有方式定义两者，但意图不清晰，而且麻烦
+ Big Three *析构函数，复制构造函数和赋值运算符总要同时出现*

***** addressof
+ "boost/utility.hpp"
+ 重载operator&是可能的，但一定是邪恶的
+ addressof(ptr)

***** enable_if
没看

**** Operator
Boost.Operator允许只定义比较运算符或算术运算符的一个子集，然后可以基于
所提供的运算符自动定义其它的运算符。

Boost.Operator为适用于不同操作的抽象概念提供了显式的命名。基类的合集。

***** Operator库
头文件："boost/operators.hpp"  ---  基类的合集
1. less_than_comparable
   + bool operator<(const T&, const T&) (*)
   + bool operator>(const T&, const T&)
   + bool operator<=(const T&, const T&)
   + bool operator>=(const T&, const T&)

2. equailty_comparable
   + bool operator==(const T&, const T&) (*)
   + bool operator!=(const T&, const T&)

3. addable
   + T operator+(const T&, const T&)
   + T operator+=(const T&)  (*)

4. subtractable
   + T operator-(const T&, const T&)
   + T operator-=(const T&)  (*)

5. orable
   + T operator|(const T&, const T&)
   + T operator|=(const T&, const T&)  (*)

6. andable
   + T operator&(const T&, const T&)
   + T operator&=(const T&, const T&)  (*)

7. incrementable
   + T& operator++(T&)  (*)
   + T& operator++(T&,int)

8. decrementable
   + T& operator--(T&)  (*)
   + T& operator--(T&,int)

9. equivalent
   + bool operator<(const T&, const T&)  (*)
   + bool operator+=(const T&, const T&)

10. 解引用
    1) dereferenceable
       + P operator->() const;
       + R operator*() const;  (*)
    2) indexable
       + R operator[](D) const;
       + R operator+(const T&, D)  (*)

11. 组合

***** 使用： 通过继承基类
#+BEGIN_EXAMPLE
class some_class : boost::equivalent<some_class>
#+END_EXAMPLE
把派生类作为模板传递给基类，称为Barton-Nackmann技巧

**** DONE Regex
SCHEDULED: <2015-04-12 日>
- State "DONE"       from "TODO"       [2015-04-16 四 21:00]

+ 为C++提供正则表达式(regular expression)的支持
+ 提高输入验证(input validation)的健壮性
+ Regex是最著名的C++正则表达式库之一

***** Regex库
+ 头文件: "boost/regex.hpp"
+ 核心类: basic_regex
  + basic_regex(const charT*p, flag_type f)
    + bad_expression / regex_error（异常）
+ regex_math()
+ regex_search()
+ regex_replace

***** 使用

****** 元字符
- .  任意字符
- =\d=  数字 (注意需要转义)
- =\w=  单词字符
- [abc]
- [a-zA-Z]
- * (>=0)
- + (>=1)
- =\s=  空格
- ()
- =\= 后向引用(back reference)

****** 匹配
+ boost::regex_match(str, reg)
+ g++ main.cpp -lboost_regex

****** 查找
+ match_result对象用来报告匹配结果
  + typedef match_result<const char*> cmatch
  + typedef match_result<const wchar_t> wcmatch
  + typedef match_result<std::string::const_iterator> smatch
  + typedef match_result<std::wstring::const_iterator> wmatch
+ bool boost::regex_search(str, match_results, reg)
+ bool boost::regex_search(iter1, iter2, match_result, reg)
  #+BEGIN_EXAMPLE
      std::string::const_iterator it = s.begin();
      std::string::const_iterator end = s.end();

      while(boost::regex_search(it, end, m, reg)){
        m[1].matched ? ++new_counter : ++delete_counter;
        it = m[0].second;  # 每匹配一次，把范围起始点更新为上一次匹配的结束点
      }
  #+END_EXAMPLE

****** 替换
+ boost::regex_replace(str, reg, str_or_占位)
+ $NUM占位， reg中的后向引用序号
+ flag:
  - boost::icase --- ignore case
  - boost::regex::perl --- ?
#+BEGIN_EXAMPLE
    boost::regex reg("(Colo)(u)(r)", boost::regex::icase | boost::regex::perl);
    std::string s = "Colour, colours, color, colourize";

    s = boost::regex_replace(s, reg, "$1$3");
    std::cout << s;
#+END_EXAMPLE

**** any
***** any类
+ "boost/any.hpp"
+ any类允许对任意类型进行类型安全的存储和检测。
+ any所存储类的要求：
  - 可复制构造(CopyCOnstructible)
  - 析构函数不抛出异常：所有析构都应如此
  - 可赋值(Assignable)
+ 成员
  + any()
  + any(const any& oter)
  + template<typename ValueType> any(const ValueType)
  + ~any()
    + 裸指针(raw pointer)应包装在shared_ptr中
  + any swap(any& other)
  + template<typename ValueType> any& operator=(const ValueType& value)
  + bool empty() const
  + const std::type_info& type() const
+ 自由函数
  + 只有在知道
  + template<typename ValueType> ValueType any_cast(const any& operand)
    + 类型不符则抛出异常
  + template<typename ValueType> const ValueType* any_cast(const any* operand)
    + 类型不符返回空指针
    + 如果失败不代表错误时应该使用指针形式的any_cast
  + template<typename ValueType> ValueType* any_cast(any* operand)
+ 异常: bad_any_cast
***** 存储任意类型
使用any类将异构类型存储到容器中是一种最常见的方法。

#+header: :exports both
#+header: :tangle /home/ben/Project/C++/Boost/BeyondSTL/Any/any1.cpp
#+BEGIN_SRC cpp
  #include <iostream>
  #include <string>
  #include <utility>
  #include <vector>
  #include <boost/any.hpp>

  class A{
  public:
    void some_function(){std::cout << "A::some_function()\n";}
  };

  class B{
  public:
    void some_function(){std::cout << "B::some_function()\n";}
  };

  class C{
  public:
    void some_function(){std::cout << "C::some_function()\n";}
  };

  int main(){
    std::cout << "Example of using any. \n\n";

    std::vector<boost::any> store_anything;

    store_anything.push_back(A());
    store_anything.push_back(B());
    store_anything.push_back(C());

    // while we're at it, let's add a few other things as well
    store_anything.push_back(std::string("This is fantastic! "));
    store_anything.push_back(3);
    store_anything.push_back(std::make_pair(true, 7.92));

    void print_any(boost::any& a);

    std::for_each(
      store_anything.begin(),
      store_anything.end(),
      print_any);

  }

  void print_any(boost::any& a){
    if(A* pA=boost::any_cast<A>(&a)){
      pA->some_function();
    }
    else if(B* pB=boost::any_cast<B>(&a)){
      pB->some_function();
    }
    else if (C* pC=boost::any_cast<C>(&a)){
      pC->some_function();
    }
    else{
      try{
        std::cout << boost::any_cast<std::string>(a) << '\n';
      }
      catch(boost::bad_any_cast&){
        std::cout << "Oops!\n";
      }
    }
  }
#+END_SRC

#+RESULTS:
| Example            | of | using      | any. |
|                    |    |            |      |
| A::some_function() |    |            |      |
| B::some_function() |    |            |      |
| C::some_function() |    |            |      |
| This               | is | fantastic! |      |
| Oops!              |    |            |      |
| Oops!              |    |            |      |

***** 属性类
#+header: :exports both
#+header: :tangle /home/ben/Project/C++/Boost/BeyondSTL/Any/any2.cpp
#+BEGIN_SRC cpp
  #include <iostream>
  #include <string>
  #include <vector>
  #include <algorithm>
  #include <boost/any.hpp>

  class property{
    boost::any value_;
    std::string name_;

  public:
    property(const std::string& name, const boost::any& value)
      : name_(name), value_(value){}

    std::string name() const { return name_; }
    boost::any& value() {return value_; }

    friend bool operator< (const property&  lhs, const property& rhs){
      return lhs.name_ < rhs.name_;
    }
  };

  void print_names(const property& p){
    std::cout << p.name() << "\n";
  }

  int main(){
    std::cout << "Example of using any for storing properties.\n";

    std::vector<property> properties;
    properties.push_back(property("B", 30));
    properties.push_back(property("A", std::string("Thirty something")));
    properties.push_back(property("C", 3.1415));

    std::sort(properties.begin(), properties.end());

    std::for_each(properties.begin(), properties.end(), print_names);

    std::cout << "\n";

    std::cout << boost::any_cast<std::string>(properties[0].value()) << std::endl;
    std::cout << boost::any_cast<int>(properties[1].value()) << std::endl;
    std::cout << boost::any_cast<double>(properties[2].value()) << std::endl;
  }
#+END_SRC

#+RESULTS:
| Example | of        | using | any | for | storing | properties. |
| A       |           |       |     |     |         |             |
| B       |           |       |     |     |         |             |
| C       |           |       |     |     |         |             |
|         |           |       |     |     |         |             |
| Thirty  | something |       |     |     |         |             |
| 30      |           |       |     |     |         |             |
| 3.1415  |           |       |     |     |         |             |

Note:
+ for_each
+ 类的构造函数参数为 const boost::any&, 缺少 const 修饰符会导致编译错
  误

***** 在any中存储指针
祼指针(void*)的销毁不需要对祼指针调用delete或delete[],而使用any会保留
存储对象的一份副本，这份副本与any一起销毁。因此，使用any存储指针问题重
重。更好的办法是使用智能指针smart_ptr.

#+header: :exports both
#+header: :tangle /home/ben/Project/C++/Boost/BeyondSTL/Any/any3.cpp
#+BEGIN_SRC cpp
  #include <iostream>
  #include <string>
  #include <algorithm>
  #include <vector>
  #include <boost/any.hpp>
  #include <boost/shared_ptr.hpp>

  class A{
  public:
    virtual ~A(){std::cout << "A::~A()\n";}

    void not_virtual(){std::cout << "A::not_virtual()\n";}
    virtual void is_virtual(){std::cout << "A::is_virtual()\n";}
  };


  class B : public a{
  public:
    void not_virtual(){std::cout << "B::not_virtual()\n";}
    virtual void is_virtual(){std::cout << "B::is_virtual()\n";}
  };

  void foo(boost::any& a){
    std::cout << "\n";
    // Try boost::shared_ptr<A>
    try{
      boost::shared_ptr<A> ptr = boost::any_cast<boost::shared_ptr<A> >(a);
      std::cout << "This any contained a boost::shared_ptr<A>\n";
      ptr->is_virtual();
      ptr->not_virtual();
      return;
    }
    catch(boost::bad_any_cast& e){}

    try{
      boost::shared_ptr<B> ptr = boost::any_cast<boost::shared_ptr<B> >(a);
      std::cout << "This any contained a boost::shared_ptr<B>\n";
      ptr->is_virtual();
      ptr->not_virtual();
      return;
    }
    catch(boost::bad_any_cast& e){}


    std::cout << "The any didn't contain anything that \
                  concerns this function.\n";
  }


  int main(){
    std::cout << "Example of any and shared_ptr\n";

    boost::any a1(boost::shared_ptr<A>(new A));
    boost::any a2(std::string("Just a string"));
    {
      boost::any b1(boost::shared_ptr<A>(new B));
      boost::any b2(boost::shared_ptr<B>(new B));
      std::vector<boost::any> vec;

      vec.push_back(a1);
      vec.push_back(a2);
      vec.push_back(b1);
      vec.push_back(b2);

      std::for_each(vec.begin(), vec.end(), foo);
      std::cout << "\n";
    }
    std::cout << "any's b1 and b2 have been destoryed which means\n""that the shared_ptr' reference counts become zero\n";

  }
#+END_SRC

#+RESULTS:
| Example          | of  | any         | and       | shared_ptr           |        |           |       |           |
|                  |     |             |           |                      |        |           |       |           |
| This             | any | contained   | a         | boost::shared_ptr<A> |        |           |       |           |
| A::is_virtual()  |     |             |           |                      |        |           |       |           |
| A::not_virtual() |     |             |           |                      |        |           |       |           |
|                  |     |             |           |                      |        |           |       |           |
| The              | any | didn't      | contain   | anything             | that   | concerns  | this  | function. |
|                  |     |             |           |                      |        |           |       |           |
| This             | any | contained   | a         | boost::shared_ptr<A> |        |           |       |           |
| B::is_virtual()  |     |             |           |                      |        |           |       |           |
| A::not_virtual() |     |             |           |                      |        |           |       |           |
|                  |     |             |           |                      |        |           |       |           |
| This             | any | contained   | a         | boost::shared_ptr<B> |        |           |       |           |
| B::is_virtual()  |     |             |           |                      |        |           |       |           |
| B::not_virtual() |     |             |           |                      |        |           |       |           |
|                  |     |             |           |                      |        |           |       |           |
| A::~A()          |     |             |           |                      |        |           |       |           |
| A::~A()          |     |             |           |                      |        |           |       |           |
| any's            | b1  | and         | b2        | have                 | been   | destoryed | which | means     |
| that             | the | shared_ptr' | reference | counts               | become | zero      |       |           |
| A::~A()          |     |             |           |                      |        |           |       |           |

**** Tuple
+ C++ 允许返回一个值
+ 可以使用struct和class包装
+ 避免复制大对象,使用指针或引用
+ 使用非const的指针或引用参数
+ --> Tuple
  - <= 10
  - 效率较struct不低

***** Tuple库
1. 头文件
   + "boost/tuple/tuple.hpp" --- 核心部分
   + "boost/tuple/tuple_io.hpp" --- 输入输出
   + "boost/tuple/tuple_comparison.hpp" --- 关系运算
   + 将库分散在不同的头文件可以减少编译时间, 仅包含需要的
2. 成员
   + 构造函数
   + 赋值 =
   + get()函数
3. 自由函数
   + make_tuple()
   + tie()
4. 关系运算符
   + ==
   + !=
   + <等
   + 要求
     - 长度相同
     - 每对元素支持同一个关系运算符

***** 使用
****** 构造
1. 构造函数: 声明类型, 以及提供初始值
   + boost::tuple(int, double, std::string) tru(1, 3.14, "hello")
   + 缺省初始值则使用对应类型的默认构造函数
2. make_pair()自动推断元素类型
   + 默认为非const,非引用类型,即最简单最基本的参数类型
     #+BEGIN_EXAMPLE
       int plain = 42;
       int& ref = plain;
       const int& cref=ref;

       boost::make_tuple(plain)
       boost::make_tuple(ref)
       boost::make_tuple(cref)
     #+END_EXAMPLE
     三者所创建的tuple都将拥有一个int类型的元素
   + boost::ref()使tuple元素成为引用类型
     #+BEGIN_EXAMPLE
       boost::make_tuple(boost::ref(plain));
       boost::make_tuple(boost::ref(ref));
       boost::make_tuple(boost::ref(cref))
     #+END_EXAMPLE
   + boost::cref()使tuple元素成为const引用类型
   + ref和cref本是Tuple库的一部分,后来由于其通用性,将其移出去成为独立
     的库
****** 访问
#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/tuple/tuple1.cpp
  #include <iostream>
  #include <string>

  #include <boost/tuple/tuple.hpp>

  int main(){
    boost::tuple<int, double, std::string>
      triple(42, 3.14, "The amazing tuple!");

    int i = boost::tuples::get<0>(triple);
    double d = triple.get<1>();
    std::string s = boost::get<2>(triple);
    std::cout << i << "," << d << "," << s << std::endl;
  }
#+END_SRC

#+RESULTS:
| 42 | 3.14 | The amazing tuple! |

1. template <int I, class T1, class T2, ..., class TN> RI
   get(tuple<T1, T2, ..., TN>t)
   + 位于命名空间tuples, 后者位于命名空间boost
2. 成员函数
   TIndex& get<int Index>()
3. boost::get()??
****** COMMENT 赋值和构造
+ tuple是可以被赋值和复制构造的
+ 元素数量相同
+ 源tuple的元素必须能被转换成目标tuple的元素
#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/tuple/tuple2.cpp
  #include <iostream>
  #include <string>

  #include <boost/tuple/tuple.hpp>


  class base{
  public:
    virtual ~base(){};
    virtual void test(){
      std::cout << "base::test()\n";
    }
  };

  class derived : public base{
  public:
    virtual void test(){
      std::cout << "derived::test()\n";
    }
  };


  int main(){
    boost::tuple<int, std::string, derived> tup1(-5, "Tuple");
    boost::tuple<int, std::string, base> tup2;

    tup2 = tup1;                  // 元组赋值

    tup2.get<2>().test();
    std::cout << "Interesting value: " << tup2.get<0>() << std::endl;

    boost::tuple<double, std::string, base> tup3(tup2); // 元组复制构造
    tup3.get<0>() = 3.14;                               // 元素赋值
    std::cout << tup3.get<0>() << std::endl;


    // 使用指针保存多态
    derived d;
    boost::tuple<int, std::string, derived*>
      tup4(-5, "Tuples", &d);
    boost::tuple<unsigned int, std::string, base*> tup5;
    tup5 = tup4;
    tup5.get<2>()->test();
    std::cout << tup5.get<0>() << std::endl;

    // 引用不能赋值, 可以通过复制构造传递
    boost::tuple<int, std::string, derived&> tup6(123, "Example", d);
    boost::tuple<unsigned int, std::string, base&> tup7(tup6);
    tup7.get<2>().test();

  }

#+END_SRC

#+RESULTS:
| base::test()    |        |    |
| Interesting     | value: | -5 |
| 3.14            |        |    |
| derived::test() |        |    |
| 4294967291.0    |        |    |
| derived::test() |        |    |

Note:
1. 破坏多态 --> 使用引用或指针
2. 数值转换精度损失或正负溢出 --> 使用boost.Conversion库
3. const Tuple的元素中const类型,因而无法赋值
4. 在tuple最好使用智能指针
****** 比较
+ "boost/tuple/tuple_comparison.hpp"
+ 比较是简化的,即依次比较对应元素, 结果一旦明确便立刻返回
+ 支持的比较包括: ==, !=, <, >, <=, >=
+ 支持比较的一个重要方面就是可以进行排序,这意味着它们可以存储在关联窗
  容器中.
+ 当需要根据tuple中的某一元素进行排序时,可以使用一个简单的泛型方法实现

#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/tuple/tuple3.cpp
  #include <iostream>
  #include <vector>
  #include <boost/tuple/tuple.hpp>
  #include <boost/tuple/tuple_comparison.hpp>

  template <int Index> class element_less{
  public:
    template <typename Tuple>
    bool operator()(const Tuple& lhs, const Tuple& rhs) const {
      return boost::get<Index>(lhs)<boost::get<Index>(rhs);
    }
  };

  int main(){
    typedef boost::tuple<short, int, long, float, double, long double> num_tuple;

    std::vector<num_tuple> vec;
    vec.push_back(num_tuple(6,2));
    vec.push_back(num_tuple(7,1));
    vec.push_back(num_tuple(5));

    std::sort(vec.begin(), vec.end(), element_less<1>());

    std::cout << "After sorting:\n " <<
      vec[0].get<0>() << '\n' <<
      vec[1].get<0>() << '\n' <<
      vec[2].get<0>() << '\n';

  }


#+END_SRC

#+RESULTS:
| After | sorting: |
|     5 |          |
|     7 |          |
|     6 |          |
****** 将tuple元素绑定到变量
Boost.Tuple库的一个便利特性就是可以将tuple"绑定"到变量。绑定者就是重载
的函数模板boost::tie所创建的tuple， 它的所有元素都是非const的引用类型。
因此必须使用左值(lvalue)初始化tie，从而tie的参数也必须是非const的引用
类型。

#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/tuple/tuple4.cpp
  #include <iostream>
  #include <boost/tuple/tuple.hpp>
  #include <boost/math/common_factor.hpp>

  boost::tuple<int, int> gcd_lcm(int val1, int val2){
    return boost::make_tuple(
                             boost::math::gcd(val1, val2),
                             boost::math::lcm(val1, val2));
  }

  int main(){
    // The old way
    boost::tuple<int, int> tup;
    tup = gcd_lcm(12, 18);
    int gcd = tup.get<0>();
    int lcm = tup.get<1>();

    std::cout << "Greatest common divisor: " << gcd << '\n';
    std::cout << "Least common multiple: " << lcm << '\n';

    // The new way
    boost::tie(gcd, lcm) = gcd_lcm(15, 20);

    std::cout << "Greatest common divisor: " << gcd << '\n';
    std::cout << "Least common multiple: " << lcm << '\n';

  }
#+END_SRC

#+RESULTS:
| Greatest | common | divisor:  |  6 |
| Least    | common | multiple: | 36 |
| Greatest | common | divisor:  |  5 |
| Least    | common | multiple: | 60 |

+ tuple中有一个特殊对象 *boost::tuples::ignore* ，它可以忽略一个tuple
  元素的值，进而只绑定感兴趣的元素。
+ tie也适用于std::pair对象

****** tuple的流操作
tuple库支持输入和输出流操作，重载了 >> 和 << 运算符，tuple还有一些操纵
符(manipulator)用于改变输入和输出流操作的默认分隔符。

#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/tuple/tuple5.cpp
  #include <iostream>
  #include <boost/tuple/tuple.hpp>
  #include <boost/tuple/tuple_io.hpp>

  int main(){
    boost::tuple<int, double> tup1;
    boost::tuple<long, long, long> tup2;

    std::cout << "Enter an int and a double as (1 2.3):\n";
    std::cin >> tup1;

    std::cout << "Enter three int as |1.2.3|:\n";
    std::cin >> boost::tuples::set_open('|') >> boost::tuples::set_close('|') >>
      boost::tuples::set_delimiter('.') >> tup2;

    std::cout << "Here they are:\n"
              << tup1 << '\n'
              << boost::tuples::set_open('\"')
              << boost::tuples::set_close('\"')
              << boost::tuples::set_delimiter('-');
    std::cout << tup2 << '\n';

  }
#+END_SRC

#+RESULTS:
| Enter | an    | int  | and | a | double | as | (1 | 2.3): |
| Enter | three | int  | as  |   |  1.2.3 | :  |    |       |
| Here  | they  | are: |     |   |        |    |    |       |
| (0    | 0)    |      |     |   |        |    |    |       |
| 0-0-0 |       |      |     |   |        |    |    |       |

**** DONE Bind
SCHEDULED: <2015-04-19 日>
- State "DONE"       from "TODO"       [2015-04-20 一 11:13]

+ 使用标准库的算法时，常常需要提供一个函数或函数对象，这是一个定制算法
  行为的绝好立法。
+ 标准库的bind1st,bind2nd不够用，且语法混乱
+ 泛型绑定器(generalized binder)是一种lambda表达式，通过函数组合，可以
  在调用点构造一个局部的、未命名的函数
  - 减少代码数量
  - 使代码容易理解
  - 行为的局部化

***** bind库
+ "boost/bind.hpp"
+ Bind库创建绑定到函数(自由函数或成员函数)的函数对象
+ 参数数量可以修改
+ 参数顺序可以重新排列
+ 作为用户不直接使用除了bind函数以外的任何对象
+ 参数占位符(placeholder)_1,_2等位于未命名空间，不需要using等进行声明
+ 最多支持9个占位符

***** 绑定普通函数
+ (boost::bind(&func, placeholder))(arugments)
+ 一个表达式可以多次使用同一个占位符
#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/bind/bind1.cpp
  #include <iostream>
  #include <boost/bind.hpp>

  void nine_arguments(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8, int i9){
    std::cout << i1 << i2 << i3 << i4 << i5
              << i6 << i7 << i8 << i9 << std::endl;
  }

  int main(){
    int i1=1, i2=2, i3=3, i4=4, i5=5, i6=6, i7=7, i8=8, i9=9;
    (boost::bind(&nine_arguments, _9, _2, _1, _6, _3, _8, _4, _5, _7))(i1, i2, i3, i4, i5, i6, i7, i8, i9);
  (boost::bind(&nine_arguments, _1, _1, _1, _6, _3, _8, _4, _5, _7))(i1, i2, i3, i4, i5, i6, i7, i8, i9);
  }

#+END_SRC

#+RESULTS:
| 921638457.0 |
|   111638457 |

***** 调用成员函数
#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/bind/bind2.cpp
  #include <iostream>
  #include <string>
  #include <vector>
  #include <algorithm>
  #include <boost/bind.hpp>
  #include <boost/shared_ptr.hpp>

  class status{
    std::string name_;
    bool ok_;

  public:
    status(const std::string& name):name_(name), ok_(true){}

    void break_it(){
      ok_=false;
    }

    bool is_broken() const{
      return ok_;
    }

    void report() const{
      std::cout << name_ << " is "
                << (ok_ ? "working nominally" : "terribly broken") << std::endl;
    }
  };

  int main(){
    std::vector<status> statuses;
    statuses.push_back(status("status 1"));
    statuses.push_back(status("status 2"));
    statuses.push_back(status("status 3"));
    statuses.push_back(status("statue 4"));

    statuses[1].break_it();
    statuses[2].break_it();

    // 使用for循环+迭代器，冗长，效率低（多次调用status.end()）
    for(std::vector<status>::iterator it=statuses.begin(); it!=statuses.end(); ++it){
      it->report();
    }

    std::cout << std::endl;

    // 使用for_each（包含在头文件algorithm中）
    // 元素是以值的方式存储的，需要使用适配器mem_fun_ref
    std::for_each(statuses.begin(), statuses.end(), std::mem_fun_ref(&status::report));

    std::cout << std::endl;

    // 使用Bind库， _1是必须的
    std::for_each(statuses.begin(), statuses.end(), boost::bind(&status::report, _1));

    std::cout << std::endl;

    // 使用指针方式
    std::vector<status*> p_statuses;
    p_statuses.push_back(new status("status 1"));
    p_statuses.push_back(new status("status 2"));
    p_statuses.push_back(new status("status 3"));
    p_statuses.push_back(new status("status 4"));

    p_statuses[1]->break_it();
    p_statuses[2]->break_it();

    // mem_fun适配器，
    std::for_each(p_statuses.begin(), p_statuses.end(), std::mem_fun(&status::report));

    std::cout << std::endl;

    // 语义一致的Boost.Bind库
    std::for_each(p_statuses.begin(), p_statuses.end(), boost::bind(&status::report, _1));

    std::cout << std::endl;
    // 使用智能指针
    std::vector<boost::shared_ptr<status> > s_statuses;
    s_statuses.push_back(
                         boost::shared_ptr<status>(new status("status 1")));
    s_statuses.push_back(
                         boost::shared_ptr<status>(new status("status 2")));
    s_statuses.push_back(
                         boost::shared_ptr<status>(new status("status 3")));
    s_statuses.push_back(
                         boost::shared_ptr<status>(new status("status 4")));

    s_statuses[1] -> break_it();
    s_statuses[2] -> break_it();

    // 标准库没有提供适用于智能指针的适配器，Boost.Bind则对类型没有要求
    std::for_each(s_statuses.begin(),
                  s_statuses.end(),
                  boost::bind(&status::report, _1));

  }
#+END_SRC

#+RESULTS:
| status | 1 | is | working  | nominally |
| status | 2 | is | terribly | broken    |
| status | 3 | is | terribly | broken    |
| statue | 4 | is | working  | nominally |
|        |   |    |          |           |
| status | 1 | is | working  | nominally |
| status | 2 | is | terribly | broken    |
| status | 3 | is | terribly | broken    |
| statue | 4 | is | working  | nominally |
|        |   |    |          |           |
| status | 1 | is | working  | nominally |
| status | 2 | is | terribly | broken    |
| status | 3 | is | terribly | broken    |
| statue | 4 | is | working  | nominally |
|        |   |    |          |           |
| status | 1 | is | working  | nominally |
| status | 2 | is | terribly | broken    |
| status | 3 | is | terribly | broken    |
| status | 4 | is | working  | nominally |
|        |   |    |          |           |
| status | 1 | is | working  | nominally |
| status | 2 | is | terribly | broken    |
| status | 3 | is | terribly | broken    |
| status | 4 | is | working  | nominally |
|        |   |    |          |           |
| status | 1 | is | working  | nominally |
| status | 2 | is | terribly | broken    |
| status | 3 | is | terribly | broken    |
| status | 4 | is | working  | nominally |

+ Boost.Bind提供了语法一致的函数绑定
+ 类型一致
+ 当绑定到成员函数时，第一个占位符必须是成员函数所在类的一个实例
  + 因而，Bind最多支持8个参数的成员函数，第一个传递对象

#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/bind/bind3.cpp
  #include <iostream>
  #include <string>
  #include <boost/bind.hpp>


  class some_class{
  public:
    typedef void result_type;
    void print_string(const std::string s){
      std::cout << s << std::endl;
    }
  };

  void print_string(const std::string s){
    std::cout << s << std::endl;
  }

  int main(){
    (boost::bind(&print_string,_1))("Hello func");

    some_class sc;
    (boost::bind(&some_class::print_string, _1, _2))(sc, "Hello mem");

    // OR
    (boost::bind(&some_class::print_string, some_class(), _1))("Hello mem");
  }
#+END_SRC

#+RESULTS:
| Hello | func |
| Hello | mem  |
| Hello | mem  |



***** 函数组合
#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/bind/bind5.cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>            // std::count_if, std::find_if
  #include <boost/bind.hpp>

  int main(){
    std::vector<int> ints;
    ints.push_back(7);
    ints.push_back(4);
    ints.push_back(12);
    ints.push_back(10);

    int count = std::count_if(
                              ints.begin(),
                              ints.end(),
                              boost::bind(
                                          std::logical_and<bool>(),
                                          boost::bind(std::greater<int>(), _1, 5),
                                          boost::bind(std::less_equal<int>(), _1, 10)));
    std::cout << count << '\n';

    std::vector<int>::iterator int_it=std::find_if(
                                                   ints.begin(),
                                                   ints.end(),
                                                   boost::bind(std::logical_and<bool>(),
                                                               boost::bind(std::greater<int>(), _1, 5),
                                                               boost::bind(std::less_equal<int>(), _1, 10)));

    if(int_it != ints.end()){
      std::cout << *int_it << '\n';
    }
  }
#+END_SRC

#+RESULTS:
| 2 |
| 7 |

***** 动态排序标准
+ 对容器的元素进行排序时，有时需要创建一个定义排序标准的函数对象，即谓
  语
+ 通过bind可以很容易地 *在调用点(callsite)创建所需的谓语*
  + 容易理解
  + 易维护
#+BEGIN_SRC cpp :exports both :tangle /home/ben/project/c++/boost/beyondstl/bind/bind4.cpp
  #include <iostream>
  #include <string>
  #include <algorithm>
  #include <functional>
  #include <vector>
  #include <boost/bind.hpp>


  class person_info{
    std::string name_;
    std::string surname_;
    unsigned int age_;

  public:
    person_info(
                const std::string& n,
                const std::string& s,
                unsigned int age)
      : name_(n), surname_(s), age_(age){}

    std::string name() const{
      return name_;
    }

    std::string surname() const{
      return surname_;
    }

    unsigned int age() const{
      return age_;
    }

    friend std::ostream& operator<<(std::ostream& os, const person_info& pi){
      os << pi.name() << ' ' << pi.surname() << ' ' << pi.age() << '\n';
      return os;
    }
  };

  // 公共继承自std::binary_function
  class person_info_age_less_than :
    public std::binary_function<person_info, person_info, bool>{
  public:
    bool operator()(
                    const person_info& p1, const person_info& p2){
      return p1.age() < p2.age();
    }
  };

  int main(){
    std::vector<person_info> vec;
    vec.push_back(person_info("Little", "John", 30));
    vec.push_back(person_info("Friar", "Tuck", 50));
    vec.push_back(person_info("Robin", "Hood", 40));

    std::sort(
             vec.begin(),
             vec.end(),
             person_info_age_less_than());

    std::cout << vec[0] << std::endl
              << vec[1] << std::endl;

    std::vector<person_info> vec1;
    vec1.push_back(person_info("Little", "John", 30));
    vec1.push_back(person_info("Friar", "Tuck", 50));
    vec1.push_back(person_info("Robin", "Hood", 40));

    std::sort(vec1.begin(),
              vec1.end(),
              boost::bind<bool>(std::less<unsigned int>(),
                                boost::bind(&person_info::age, _1),
                                boost::bind(&person_info::age, _2)));
    std::cout << vec1[0] << std::endl
              << vec1[1] << std::endl;

  }
#+END_SRC

#+RESULTS:
| Little | John | 30 |
|        |      |    |
| Robin  | Hood | 40 |
|        |      |    |
| Little | John | 30 |
|        |      |    |
| Robin  | Hood | 40 |

1. 绑定逻辑操作
   #+BEGIN_EXAMPLE
   boost::bind<bool>(std::less<unsigned int>(), _1, _2)
   #+END_EXAMPLE
   + 显式地增加返回类型
2. 绑定操作的参数
   #+BEGIN_EXAMPLE
     boost::bind<bool>(std::less<unsigned int>(),
                    boost::bind(&person_info::age, _1),
                    boost::bind(&person_info::age, _2));
   #+END_EXAMPLE

**** DONE Boost:Lambda
- State "DONE"       from "TODO"       [2015-04-22 三 16:47]
+ 在调用点定义未命名函数
+ 函数式编程(functional programming)：通过模板实现
+ 避免代码膨胀和功能分散
+ 几乎所有的标准库算法都有一个接受函数对象的版本，lambda表达式定义简单
  的函数对象
+ 在调用的地方定义函数或函数对象，这样快，容易维护

***** 头文件
+ "boost/lambda/lambda.hpp": 核心库
+ "boost/lambda/if.hpp": 定义了相当于if的lambda以及条件操作符
+ "boost/lambda/loops.hpp": 定义了循环结构
+ "boost/lambda/switch.hpp"
+ "boost/lambda/construct.hpp": new/delete
+ "boost/lambda/casts.hpp"
+ "boost/lambda/exception.hpp"
+ "boost/lambda/algorith.hpp"
+ "boost/lambda/numeric.hpp"

***** 更改占位符名称
+ boost::lambda::placeholderX_type (X = 1, 2, 3)
#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/lambda/lambda4.cpp
  #include <iostream>
  #include <vector>
  #include <string>
  #include <boost/lambda/lambda.hpp>

  boost::lambda::placeholder1_type Arg1;
  boost::lambda::placeholder2_type Arg2;
  boost::lambda::placeholder3_type Arg3;

  template <typename T, typename Opertation>
  void for_all(T& t, Opertation Op){
    std::for_each(t.begin(), t.end(), Op);
  }

  int main(){
    std::vector<std::string> vec;
    vec.push_back("What are");
    vec.push_back("the names");
    vec.push_back("of the");
    vec.push_back("placeholders?");
    for_all(vec, std::cout<< Arg1 << " ");
    std::cout << "\nArg1, Arg2, and Arg3!";
  }
#+END_SRC
***** 简单使用
+ lambda表达式也称匿名函数(unnamed function)
+ 创建lambda表达式时没有关键字，占位符的出现表示这是一个lambda表达式
+ using boost::lambda
#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/lambda/lambda1.cpp
  #include <iostream>
  #include <boost/lambda/lambda.hpp>
  #include <boost/function.hpp>

  int main(){
    using namespace boost::lambda;
    (std::cout << _1 << " " << _3 << " " << _2 << "!\n")("Hello", "friend", "my");
    boost::function<void(int, int, int)> f = std::cout << _1 << "*" << _2 << "+" << _3
                                                       << "=" << _1*_2+_3 << "\n";
    f(1, 2, 3);
    f(3, 2, 1);
  }
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Boost/BeyondSTL/Lambda/lambda2.cpp
  #include <iostream>
  #include <string>
  #include <map>
  #include <algorithm>
  #include <boost/lambda/lambda.hpp>
  #include <boost/lambda/bind.hpp>

  int main(){
    using namespace boost::lambda;
    typedef std::map<int, std::string> type;
    type keys_and_values;
    keys_and_values[2] = "Less than pi";
    keys_and_values[42] = "You tell me";
    keys_and_values[0] = "Nothing if you ask me";

    std::cout << "What's wrong with the following expression?\n";

    std::for_each(
                  keys_and_values.begin(),
                  keys_and_values.end(),
                  std::cout << "key=" << bind(&type::value_type::first, _1)
                  << ", value=" << bind(&type::value_type::second, _1) << '\n');

    std::cout << "\n...and why does this work as expected?\n";
    std::for_each(
                  keys_and_values.begin(),
                  keys_and_values.end(),
                  std::cout << constant("key=") <<
                  bind(&type::value_type::first, _1) << ", value="
                  << bind(&type::value_type::second, _1) << '\n');
    std::cout << '\n';
    (std::cout << "keys_and_values.size()=" << bind(&type::size, _1)
     << "\nKeys_and_values.max_size()=" << bind(&type::max_size, _1))(keys_and_values);
  }
#+END_SRC
+ std::cout << "key="仅仅是个表达式，不是lambda表达式(前面也没有占位符
  来作为operator<<的参数使其成为一个有效的lambda表达式)
+ constant函数创建一个无参函数对象仅保存其参数，然后在调用时返回

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Boost/BeyondSTL/Lambda/lambda3.cpp
  #include <iostream>
  #include <boost/lambda/lambda.hpp>
  #include <boost/lambda/bind.hpp>

  class double_it{
  public:
    int operator()(int i) const{
      return i*2;
    }
  };

  int main(){
    using namespace boost::lambda;
    double_it d;
    int i = 12;
    // If you uncomment the following expression
    // the compiler will complain;
    // it;s just not possible to dedece the return type
    // of the function call operator of double_it
    // (std::cout << _1 << "*2" << (bind(d, _1)))(i);
    (std::cout << _1 << "*2=" << (bind<int>(d, _1)))(i);
    (std::cout << _1 << "*2=" << (ret<int>(bind(d, _1))))(i);
  }
#+END_SRC
+ 绑定自由函数和成员函数的语法一致， 不需要显式表明函数返回类型
+ 当被绑定的是函数对象时，不能推测其返回类型
  + 将返回类型作为参数模板传递给bind,来关闭返回类型推断系统
  + 使用ret括住不能进行自动推断的lambda/bind表达式

***** 给常量和变量命名
+ constant
+ var
+ boost::lambda::constant_type<T>::type
+ boost::lambda::var_type<T>::type

#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/lambda/lambda5.cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <boost/lambda/lambda.hpp>

  template <typename T, typename Opertation>
  void for_all(T& t, Opertation Op){
    std::for_each(t.begin(), t.end(), Op);
  }

  int main(){
    using boost::lambda::constant;
    using boost::lambda::constant_type;

    constant_type<char>::type newline(constant('\n'));
    constant_type<char>::type space(constant(' '));
    boost::lambda::placeholder1_type _;
    std::vector<int> vec;
    vec.push_back(0);
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);
    vec.push_back(4);
    for_all(vec, std::cout << space << _ << newline);
    for_all(vec, std::cout << constant(' ') << _ << constant('\n'));
  }
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Boost/BeyondSTL/Lambda/lambda6.cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <boost/lambda/lambda.hpp>

  template<typename T> class memorizer{
    std::vector<T> vec_;
  public:
    memorizer& operator=(const T& t){
      vec_.push_back(t);
      return *this;
    }
    void clear(){
      vec_.clear();
    }
    void report() const{
      using boost::lambda::_1;
      std::for_each(vec_.begin(),
                    vec_.end(),
                    std::cout << _1 << ",");
    }
  };

  int main(){
    using boost::lambda::var_type;
    using boost::lambda::var;
    using boost::lambda::_1;
    std::vector<int> vec;
    vec.push_back(0);
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);
    vec.push_back(4);
    memorizer<int> m;
    var_type<memorizer<int> >::type mem(var(m));
    std::for_each(vec.begin(), vec.end(), mem=_1);
    m.report();
    m.clear();
    std::for_each(vec.begin(), vec.end(),var(m)=_1);
    m.report();
  }
#+END_SRC
注：
#+BEGIN_EXAMPLE
constant_type<const char (&) [6]>::type hello(constant("hello"));
constant_type<std::string>::type hello(constant("hello"));
#+END_EXAMPLE
char*, const char* 不正确, 应声明为含有六个字符的数组的常量引用
***** ptr_fun mem_fun
+ lambda提供语法一致的函数和成员函数绑定， 无须记住标准库的ptr_fun和
  mem_fun

#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/lambda/lambda7.cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <functional>
  #include <boost/lambda/lambda.hpp>
  #include <boost/lambda/bind.hpp>

  void plain_function(int i){
    std::cout << "void plain_function(" << i << ")\n";
  }

  class some_class{
  public:
    void member_function(int i) const{
      std::cout << "void member_function(" << i << ")\n";
    }
  };


  int main(){
    std::vector<int> vec(3);
    vec[0] = 12;
    vec[1] = 10;
    vec[2] = 7;
    some_class sc;
    some_class* psc=&sc;

    // bind to a free function using ptr_fun
    std::for_each(vec.begin(),
                  vec.end(),
                  std::ptr_fun(plain_function));
    // bind to a member function using mem_fun_ref
    std::for_each(vec.begin(),
                  vec.end(),
 p                 std::bind1st(
                               std::mem_fun_ref(&some_class::member_function), sc));
    // bind to a member function using mem_fun
    std::for_each(vec.begin(),
                  vec.end(),
                  std::bind1st(
                               std::mem_fun(&some_class::member_function), psc));
    using namespace boost::lambda;
    std::for_each(vec.begin(),
                  vec.end(),
                  bind(&plain_function, _1));
    std::for_each(vec.begin(),
                  vec.end(),
                  bind(&some_class::member_function, sc, _1));
    std::for_each(vec.begin(),
                  vec.end(),
                  bind(&some_class::member_function, psc, _1));

  }
#+END_SRC

***** 无须functional的算术操作
+ Boost.Lambda支持C++中所有的算术操作符，因此几乎不再需要为了算术函数
  对象而包含<functional>
#+BEGIN_SRC cpp :exports code :tangle /home/ben/project/c++/boost/beyondstl/lambda/lambda8.cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <functional>
  #include <boost/lambda/lambda.hpp>
  #include <boost/lambda/bind.hpp>

  int main(){
    using namespace boost::lambda;
    std::vector<int> vec(3);
    vec[0]=12;
    vec[1]=10;
    vec[2]=7;

    // Transform using std::bind1st and std::plus
    std::transform(vec.begin(),
                  vec.end(),
                  vec.begin(),
                  std::bind1st(std::plus<int>(), 4));
    // Transform using a lambda expression
    std::transform(vec.begin(),
                   vec.end(),
                   vec.begin(),
                   _1-=4);
  }
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Boost/BeyondSTL/Lambda/lambda9.cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <boost/lambda/lambda.hpp>

  int main(){
    using namespace boost::lambda;
    std::vector<int> vec(3);
    vec[0]=1;
    vec[1]=2;
    vec[2]=3;
    std::for_each(vec.begin(), vec.end(), _1+=10);
    std::for_each(vec.begin(), vec.end(), _1-=10);
    std::for_each(vec.begin(), vec.end(), _1*=10);
    std::for_each(vec.begin(), vec.end(), _1/=2);
    std::for_each(vec.begin(), vec.end(), _1%=3);
  }
#+END_SRC

***** 编写可读的谓词

**** Function
+ 为后续的调用存储函数指针和函数对象

***** Function库
1. "boost/function.hpp"
   + 包含可以拥有0～10个参数的函数原型，相应于function/functionN.hpp

2. 声明
   1) 首先语法(preferred syntax)的声明
      #+BEGIN_EXAMPLE
        boost::function<bool (int)> f;
        boost::function<bool (int, double)> f;
      #+END_EXAMPLE
      + 包括签名和返回类型
      + 语法接近函数声明
   2) 兼容语法的声明
      #+BEGIN_EXAMPLE
        boost::function1<bool, int> f;
        boost::function2<bool, int, double> f;
      #+END_EXAMPLE
      + 有数字后缀
      + 兼容更多的编译器
3. 成员
   1) 构造

   2) 赋值=

   3) bool empty const;

   4) void clear(), 赋值更好

   5) result_type operator()(Arg1 a1, Arg2 a2, ...) const


*****

*** 智能指针
**** boost::shared_ptr                                        :shared_ptr:
shared_prt *引用数智能指针* ： 负责在不使用实例时删除它指向的对象
(pointee)，并且它可以自由地共享它指向的对象。

boost.smart_ptr库中最重要的、最有价值的、最有用的组成部分，最像指针的
“智能指针“。

shared_ptr 包装了 *new* 操作符在 *堆* 上分配的 *动态对象* ，实现的是
*引用计数型的智能指针* ， 可以被自由地拷贝和赋值，在任意地方共享它，当
没有代码使用（引用计算为0）时，它才删除被包装的动态分配的对象。

***** 例1. 简单应用
#+begin_latex
\begin{minted}{cpp}
void test(){
  boost::shared_ptr<int> sp(new int(10));
  assert(sp.unique());
  boost::shared_ptr<int> sp2 = sp;
  assert(sp == sp2 && sp.use_count() == 2);

  *sp2 = 100;
  assert(*sp == 100);
  sp.reset();
  assert(!sp);
}
\end{minted}
#+end_latex

1. assert头文件<cassert>或 <assert.h>

***** 例2. 类
#+begin_latex
\begin{minted}{cpp}
class shared
{
private:
  boost::shared_ptr<int> p;

public:
  shared(boost::shared_ptr<int> p_) : p(p_){}
  void print(){
    std::cout << "count:" << p.use_count()
	      << " v= " << *p << std::endl;
  }
};

void print_func(boost::shared_ptr<int> p){
  std::cout << "count: "<< p.use_count()
	    << " v=" << *p << std::endl;
}

int main(int argc, char *argv[])
{
  test();

  boost::shared_ptr<int> p(new int(1000));
  shared s1(p), s2(p);
  s1.print();
  s2.print();
  *p = 20;
  print_func(p);
  s1.print();

  return 0;
}

\end{minted}
#+end_latex
#+BEGIN_EXAMPLE
count:3 v=1000
count:3 v=1000
count:4 v=20
count:3 v=20
#+END_EXAMPLE

/print_func(p)  why 4?/
/p初始化之后其use_count为2, 又是为何？/

#+begin_latex
\begin{minted}{cpp}
  boost::shared_ptr<int> p(new int(1000));
  std::cout << "count:"<< p.use_count()
	    << " v=" << *p << std::endl;
  assert(p.unique());
  print_func(p);
\end{minted}
#+end_latex

#+BEGIN_EXAMPLE
count:1 v=1000
count:2 v=1000
#+END_EXAMPLE

*问题在于函数参数的传递*

***** 例3. 应用于标准容器

****** 方式1： 将窗口作为shared_ptr管理的对象，e.g. shared_ptr<list<T>>
这样容器可以被安全地共享

****** 方式2： 将shared_ptr作为容器的元素，e.g. vector<shared_ptr<T>>
1. shared_ptr支持拷贝和比较操作，符合标准容器对元素的要求
2. 标准窗口不能容纳auto_ptr，C++标准特别的规定
3. 标准容器不能容纳scoped_ptr，scopted_ptr不能拷贝和比较
4. 标准容器可以容纳原始指针，但这就丧失了标准容器的许多好处，因为标准
   容器无法自动管理类型为指针的元素，必须编写额外的大量代码来保证指针
   最终被正确删除。

#+begin_latex
\begin{minted}{cpp}
  typedef std::vector<boost::shared_ptr<int> > vs;
  vs v(10);
  int i = 0;
  for(vs::iterator pos = v.begin(); pos != v.end(); ++pos){
    (*pos) = boost::make_shared<int>(++i);
    std::cout << *(*pos) << ",";
  }
  std::cout << std::endl;
  boost::shared_ptr<int> pp = v[9];
  *pp = 100;
  std::cout << *v[9] << std::endl;
  return 0;
\end{minted}
#+end_latex

1. typedef：声明boost::shared_ptr<T>变量比较麻烦，所以一般使用typedef
   进行定义别名
2. boost::make_shared()是工厂函数，包含在头文件<boost/make_shared.hpp>
   中
3. *(*pos)可以写成 **pos, 但前者更清晰


**** [[http://blog.csdn.net/sndaxdrs/article/details/6175701][shared_ptr]] :blog:


shared_ptr是一个最像指针的"智能指针"，是boost.smart_ptr库中最有价值、
最重要的组成部分，也是最有用的，Boost库的许多组件--甚至还包括其他一些
领域的智能指针都使用了shared_ptr。抱歉，我实在想不出什么更恰当的词汇来
形容它在软件开发中的重要性。再强调一遍，shared_ptr非常有价值、非常重要、
非常有用。

shared_ptr与scoped_ptr一样包装了new操作符在堆上分配的动态对象，但它实
现的是引用计数型的智能指针，可以被自由地拷贝和赋值，在任意的地方共享它，
当没有代码使用（引用计数为0）它时才删除被包装的动态分配的对象。
shared_ptr也可以安全地放到标准容器中，并弥补了auto_ptr因为转移语义而不
能把指针作为STL容器元素的缺陷。

在C++历史上曾经出现过无数的引用计数型智能指针实现，但没有一个比得上
boost::shared_ptr，在过去、现在和将来，它都是最好的。

*1.  shared_ptr的线程安全性*

shared_ptr 本身不是 100%
线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是，因为
shared_ptr 有两个数据成员，读写操作不能原子化。根据文档，shared_ptr
的线程安全级别和内建类型、标准库容器、string 一样，即：

- 一个 shared_ptr 实体可被多个线程同时读取；
- 两个的 shared_ptr 实体可以被两个线程同时写入，“析构”算写操作；
- 如果要从多个线程读写同一个 shared_ptr 对象，那么需要加锁。

*2.  shared_ptr用法*

*示例一：*

#+BEGIN_SRC cpp
shared_ptr<int> sp(new int(10)); //一个指向整数的shared_ptr
assert(sp.unique()); //现在shared_ptr是指针的唯一持有者
shared_ptr<int> sp2 = sp; //第二个shared_ptr,拷贝构造函数 assert(sp ==
sp2 && sp.use_count() == 2);
//两个shared_ptr相等,指向同一个对象,引用计数为2 *sp2 = 100;
//使用解引用操作符修改被指对象 assert(*sp == 100);
//另一个shared_ptr也同时被修改 sp.reset(); //停止shared_ptr的使用
assert(!sp); //sp不再持有任何指针(空指针)
#+END_SRC



*示例二：*

#+BEGIN_SRC cpp
  class shared //一个拥有shared_ptr的类
  {
    private: shared_ptr<int> p; //shared_ptr成员变量
    //构造函数初始化
     public: shared(shared_ptr<int> p_):p(p_){}

    //输出shared_ptr的引用计数和指向的值
    shared_ptr void print()
   { cout << "count:" <<p.use_count() << "v =" <<*p << endl; }
  };
  //使用shared_ptr作为函数参数 {
  voidprint_func(shared_ptr<int> p)
  //同样输出shared_ptr的引用计数和指向的值 cout << "count:" <<
  p.use_count() << " v=" <<*p << endl; }

  int main() {
    shared_ptr<int> p(new int(100)); shared s1(p), s2(p); //构造两个自定义类 s1.print();
    s2.print(); *p = 20; //修改shared_ptr所指的值 print_func(p);
    s1.print();
  }
#+END_SRC

*3. 应用于标准容器*


有两种方式可以将shared_ptr应用于标准容器（或者容器适配器等其他容器）。

一种用法是将容器作为shared_ptr管理的对象，如shared_ptr<list<T>
>，使容器可以被安全地共享，用法与普通shared_ptr没有区别，我们不再讨论。

另一种用法是将shared_ptr作为容器的元素，如vector<shared_ptr<T>
>，因为shared_ptr支持拷贝语义和比较操作，符合标准容器对元素的要求，所以可以实现在容器中安全地容纳元素的指针而不是拷贝。

标准容器不能容纳auto_ptr，这是C++标准特别规定的（读者永远也不要有这种想法）。标准容器也不能容纳scoped_ptr，因为scoped_ptr不能拷贝和赋值。标准容器可以容纳原始指针，但这就丧失了容器的许多好处，因为标准容器无法自动管理类型为指针的元素，必须编写额外的大量代码来保证指针最终被正确删除，这通常很麻烦很难实现。

存储shared_ptr的容器与存储原始指针的容器功能几乎一样，但shared_ptr为程序员做了指针的管理工作，可以任意使用shared_ptr而不用担心资源泄漏。

下面的代码示范了将shared_ptr应用于标准容器的用法：

#include <boost/make_shared.hpp> int main() { typedef
vector<shared_ptr<int> > vs; //一个持有shared_ptr的标准容器类型 vs
v(10); //声明一个拥有10个元素的容器，元素被初始化为空指针 int i = 0; for
(vs::iterator pos = v.begin(); pos != v.end(); ++pos) { (*pos) =
make_shared<int>(++i); //使用工厂函数赋值 cout << *(*pos) << ", ";
//输出值 } cout << endl; shared_ptr<int> p = v[9]; *p = 100; cout <<
*v[9] << endl; }

这段代码需要注意的是迭代器和operator[]的用法，因为容器内存储的是shared_ptr，我们必须对迭代器pos使用一次解引用操作符*以获得shared_ptr，然后再对shared_ptr使用解引用操作符*才能操作真正的值。*(*pos)也可以直接写成**pos，但前者更清晰，后者很容易让人迷惑。vector的operator[]用法与迭代器类似，也需要使用*获取真正的值。

* STL                                                                   :stl:
** [[http://blog.sina.com.cn/s/blog_674b5aae0100nqpt.html][atoll()函数使用注意事项及分析]] :blog:

atoll是c99标准加入的函数，在编译的时候可能要打开C99标准的编译选项
-std=c99。

另外，必须包含stdlib.h头文件，否则会出错。

☞ C程序代码如下所示：

#include <stdio.h>

#include <stdlib.h> // 声明atoll函数
 int main()
 {
  char tempbuf[]="430007020001";
  long long unit;

 unit=atoll(tempbuf);
    printf("%lld\n", unit);

 return 0;
 }

编译：
 gcc -S -o test.s test.c



☞ 编译器产生的汇编代码是这样的：

Assembly code

 call atoll ;调用atoll。返回值的低32位保存在eax，高32位保存在edx
  addl $16, %esp ; 调整栈指针，与本题无

     movl % eax, -32(%
ebp); 把eax里保存的低32位保存到局部变量unit的低32位

     movl % edx, -28(%
ebp); 把edx里保存的高32位保存到局部变量unit的高32位

☞ 而如果把#include
<stdlib.h>删掉，也就是不声明atoll函数，编译器产生的汇编代码就变成了这样：

Assembly code

 call atoll
  addl $16, %esp

 cltd ; AT&T汇编里的cltd指令相当于cdq指令，作用是把eax的32位整数扩展为64位，高32位用eax的符号位填充保存到edx

       movl % eax, -32(% ebp);

       movl % edx, -28(% ebp);



☞ 从汇编代码可以看出：

有atoll声明的时候，编译器知道atoll的返回值是64位，所以直接把edx:eax里面保存的64位返回值赋值给unit。

而没有atoll声明的时候，编译器认为atoll的返回值是32位，于是多了一条关键的cltd指令。真正调用atoll的时候，atoll也会把返回值保存在edx:eax；但是main里面不知道，通过cltd指令，用eax的扩展把edx里面保存的有用的高32位覆盖掉了。



☞ 不添加和添加输出结果对比：

   不添加头文件时，输出510290401，显然是错误的；

   添加头文件后，输出430007020001，正确。

** algorithm                                                     :algorithm:
*** [[http://www.cnblogs.com/sooner/archive/2012/04/18/2455279.html][C++标准模板库函数sort那点小事]] :blog:sort:

STL里面有个sort函数，可以直接对数组排序，复杂度为n*log2(n)。sort()定义在在头文件<algorithm>中。sort函数是标准模板库的函数，已知开始和结束的地址即可进行排序，可以用于比较任何容器（必须满足随机迭代器），任何元素，任何条件，执行速度一般比qsort要快。另外，sort()是类属函数，可以用于比较任何容器，任何元素，任何条件。具体事例如下：

#+BEGIN_EXAMPLE
    char ch[20]="sdasdacsdasdas";
    cout<<ch<<endl;
    sort(ch,ch+14);
    cout<<ch<<endl;
#+END_EXAMPLE

注意：缺省是升序排序。sort中一个改变排序顺序的例子如下（降序）：

#+BEGIN_EXAMPLE
    #include<iostream>
    #include<algorithm>
    using namespace std;
    bool cmp (const int a, const int b)
    {
        return a > b;
    }
    int main()
    {
        int data[5];
        for(int i = 0; i < 5; i++)
            cin >> data[i];
        sort(data, data + 5, cmp);
        return 0;
    }
#+END_EXAMPLE

 这个函数可以传两个参数或三个参数。第一个参数是要排序的区间首地址，第二个参数是区间尾地址的下一地址。也就是说，排序的区间是[a,b)。简单来说，有一个数组int a[100]，要对从a[0]到a[99]的元素进行排序，只要写sort(a,a+100)就行了，默认的排序方式是升序。如需要对数组t的第0到len-1的元素排序，就写sort(t,t+len);对向量v排序也差不多，sort(v.begin(),v.end());排序的数据类型不局限于整数，只要是定义了小于运算的类型都可以，比如字符串类string。
 如果是没有定义小于运算的数据类型，或者想改变排序的顺序，就要用到第三参数------比较函数。比较函数是一个自己定义的函数，返回值是bool型，它规定了什么样的关系才是“小于”。想把刚才的整数数组按降序排列，可以先定义一个比较函数cmp:

#+BEGIN_EXAMPLE
    bool cmp(int a,int b)
    {
        return a>b;
    }
#+END_EXAMPLE

排序的时候就写sort(a,a+100,cmp);

假设自己定义了一个结构体node:

#+BEGIN_EXAMPLE
    struct node{
        int a;
        int b;
        double c;
    };
#+END_EXAMPLE

有一个node类型的数组node arr[100]，想对它进行排序：先按a值升序排列，如果a值相同，再按b值降序排列，如果b还相同，就按c降序排列。就可以写这样一个比较函数：

以下是代码片段：

#+BEGIN_EXAMPLE
    bool cmp(node x,node y)
    {
         if(x.a!=y.a)  return x.a
         if(x.b!=y.b)  return x.b>y.b;
         return  return x.c>y.c;
    }
#+END_EXAMPLE

 排序时写sort(arr,a+100,cmp);

最后看一个完整的实例，一道题目“文件名排序 ”。
以下是代码片段：

#+BEGIN_EXAMPLE
    #include<iostream>
    #include<algorithm>
    #include<string>
    using namespace std;
    //定义一个结构体来表示文件，a代表文件名，b代表文件类型（要么"File"要么"Dir"）
    struct node{
       string a,b;
    };
    //ASCII码中，所有大写字母排在所有小写字母前面，'A'<'Z'<'a'<'z'
    //而这题要求忽略大小写，所以不能直接用字符串的比较。自定义了一个lt函数，就是less than的意思
    //先把两个字符串全部转化为小写，再比较大小（字典序）
    bool lt(string x,string y)
    {
       int i;
       for(i=0;i<x.length();i++)
          if(x[i]>='A'&&x[i]<='Z')
             x[i]='a'+(x[i]-'A');
       for(i=0;i<y.length();i++)
          if(y[i]>='A'&&y[i]<='Z')
             y[i]='a'+(y[i]-'A');
       return x<y;
    }
    //自定义的比较函数，先按b值升序排列（也就是"Dir"排在"File"前面）
    //如果b值相同，再按a升序排列，用的是刚才定义的lt函数
    bool comp(node x,node y)
    {
       if(x.b!=y.b) return x.b<y.b;
       return lt(x.a,y.a);
    }
    int main()
    {
       node arr[10001];
       int size=0;
       while(cin>>arr[size].a>>arr[size].b)
          size++;
       sort(arr,arr+size,comp);
       for(int i=0;i<size;i++)
          cout<<arr[i].a<<" "<<arr[i].b<<endl;
       return 0;
    }
#+END_EXAMPLE

*** algorithm

- state "tobecontined" from "todo"       [2015-11-04 三 16:09]

the header <algorithm> defines a collection of functions especially
designed to be used on *ranges* of elements.


a range is any sequence of objects that can be accessed through
*iterators* or pointers, such as an array or an instance of some of the
stl containers. notice though, that algorithms operate through
iterators *directly on the values*, not affecting in any way the
structure of any possible container (it never affects the size or
storage allocation of the container).

**** all_of
+ template <class InputIterator, class UnaryPredicate>
  bool all_of(InputIterator first, InputIterator last, UnaryPredicate pred);

+ Test condition on all elements in range

#+begin_latex
\begin{cpp}
void all_of(){
  std::array<int, 8> foo = {3, 5, 7, 11, 13, 15, 17, 19};

  if(std::all_of(foo.begin(), foo.end(), [](int i){return i%2;}))
    std::cout << "All the elements are odd numbers.\n";
}
\end{cpp}
#+end_latex

#include <array>

error: #error This file requires compiler and library support for the
ISO C++ 2011 standard. This support is currently experimental, and
must be enabled with the *-std=c++11 or -std=gnu++11* compiler
options.

**** any_of
+ template <class InputIterator, class UnaryPredicate>
  bool any_of (InputIterator first, InputIterator last, UnaryPredicate pred);

+ Test if any element in range fulfills condition

#+begin_latex
\begin{cpp}
void any_of(){
  std::array<int, 7> foo = {0, 1, -1, 3, -3, 5, -5};

  if(std::any_of(foo.begin(), foo.end(), [](int i){return i<0;}))
    std::cout << "There are negative elements in the range.\n";
}
\end{cpp}
#+end_latex

**** none_of
+ template <class InputIterator, class UnaryPredicate>
  bool none_of (InputIterator first, InputIterator last, UnaryPredicate pred);

+ Test if no elements fulfill condition

**** for_each
+ template <class InputIterator, class Function>
   Function for_each (InputIterator first, InputIterator last, Function fn);

+ Apply function to range

#+begin_latex
\begin{cpp}
void myfunction(int i){
  std::cout << ' ' << i;
}

struct myclass{
  void operator()(int i){std::cout << ' ' << i;}
}myobject;

void for_each(){
  std::vector<int> myvector;
  myvector.push_back(10);
  myvector.push_back(20);
  myvector.push_back(30);

  std::cout << "myvector contains: ";
  for_each(myvector.begin(), myvector.end(), myfunction);
  std::cout << '\n';

  std::cout << "myvector contains: ";
  for_each(myvector.begin(), myvector.end(), myobject);
  std::cout << '\n';
}
\end{cpp}
#+end_latex

**** find
+ template <class InputIterator, class T>
   InputIterator find (InputIterator first, InputIterator last, const T& val);

+ Find value in range

+ Returns an *iterator to the first element* in the range [first,last)
  that compares equal to val. If no such element is found, the
  function returns *last*.

#+begin_latex
\begin{cpp}
void find(){
  // using std::find with array and pointer
  int myints[] = {10, 20, 30, 40};
  int* p;

  p = std::find(myints, myints+4, 30);
  if(p != myints+4)
    std::cout << "Element found in myints:" << *p << std::endl;
  else
    std::cout << "Element not found in myints.\n";

  // using std::find with vector and iterator:
  std::vector<int>myvector(myints, myints+4);
  std::vector<int>::iterator it;

  it = find(myvector.begin(), myvector.end(), 30);
  if( it != myvector.end())
    std::cout << "Element found in myvector" << std::endl;
  else
    std::cout << "Element not found in myvector" << std::endl;

}
\end{cpp}
#+end_latex

** map                                                                 :map:
*** class map
*** constructor
#+begin_latex
\begin{cpp}
bool fncomp(char lhs, char rhs){return lhs<rhs;}

struct classcomp{
  bool operator()(const char& lhs, const char& rhs) const{
    return lhs<rhs;
  }
};

void construct(){
  std::map<char, int> first;

  first['a'] = 10;
  first['b'] = 30;
  first['c'] = 50;
  first['d'] = 70;

  std::map<char, int> second(first.begin(), first.end());

  std::map<char, int> third(second);

  std::map<char, int, classcomp> fourth; // class as Compare

  bool(*fn_pt)(char, char)=fncomp;
  std::map<char, int, bool(*)(char, char)>fifth(fn_pt); // function pointer as Compare
}
\end{cpp}
#+end_latex

*** std::map::at
+ mapped_type& at (const key_type& k);
+ const mapped_type& at (const key_type& k) const;

+ Access element
  - *Returns a reference to the mapped value* of the element
    identified with key k.
  - If k does not match the key of any element in the container, the
    function throws an *out_of_range exception*.

#+begin_latex
\begin{cpp}
void at(){
  std::map<std::string, int> mymap = {
    {"alpha", 0},
    {"beta", 0},
    {"gamma", 0}};


  mymap.at("alpha") = 30;
  mymap.at("beta") = 20;
  mymap.at("gamma") = 10;

  for(auto& x:mymap){
    std::cout < x.first << ":" << x.second << "\n";
  }
}
\end{cpp}
#+end_latex

error: in C++98 ‘mymap’ must be initialized by constructor, not by
‘{...}’   };

error: ISO C++ forbids declaration of ‘x’ with no type [-fpermissive]
   for(auto& x:mymap){

*** std::map::begin/end
Return iterator to begining
#+begin_latex
\begin{cpp}
void begin(){
  std::map<char, int> mymap;
  mymap['a'] = 100;
  mymap['b'] = 200;
  mymap['c'] = 300;

  // show content
  for(std::map<char, int>::iterator it=mymap.begin(); it!=mymap.end(); ++it){
    std::cout << it->first << "=>" << it->second << "\n";
  }
}
\end{cpp}
#+end_latex

*** std::map::cbegin/cend
Return const_iterator to beginning
Note: *C++11*
#+begin_latex
\begin{cpp}
void cbegin(){
  std::map<char, int> mymap;
  mymap['a'] = 100;
  mymap['b'] = 200;
  mymap['c'] = 300;

  // show content
  for(auto it=mymap.cbegin(); it!=mymap.cend(); ++it){
    std::cout << "[" << (*it).first << ":" << (*it).second << "\n";
  }
}
\end{cpp}
#+end_latex

*** std::map::clear
Clear content

*** std::map::empty
Test whether container is empty

#+begin_latex
\begin{cpp}
void empty(){
   std::map<char, int> mymap;
  mymap['a'] = 100;
  mymap['b'] = 200;
  mymap['c'] = 300;

  while(!mymap.empty()){
    std::cout << mymap.begin()->first << "=>" << mymap.begin()->second << '\n';
    mymap.erase(mymap.begin());
  }
}

\end{cpp}
#+end_latex

*** std::map::erase
1) void erase (iterator position);
2) size_type erase (const key_type& k);
3) void erase (iterator first, iterator last);

Erase elements

#+begin_latex
\begin{cpp}
void erase(){
  std::map<char, int> mymap;
  mymap['a'] = 100;
  mymap['b'] = 200;
  mymap['c'] = 300;
  mymap['d'] = 400;
  mymap['e'] = 500;
  mymap['f'] = 600;

  std::map<char,int>::iterator it;

  it = mymap.find('b');
  mymap.erase(it);

  mymap.erase('c');

  it=mymap.find('e');
  mymap.erase(it, mymap.end());

  for(it=mymap.begin(); it!=mymap.end(); ++it){
    std::cout << it->first << "=>" << it->second << "\n";
  }

}
\end{cpp}
#+end_latex

*** std::map::find
1) iterator find (const key_type& k);
2) const_iterator find (const key_type& k) const;
3) Find iterator to element

*** std::map::insert

*** std::map::size
size_type size() const;

*** std::map::count
Count elements with a specific key
Return 1(found) or 0 otherwise

#+begin_latex
\begin{cpp}
void count(){
  std::map<char, int> mymap;
  mymap['a'] = 100;
  mymap['b'] = 200;
  mymap['c'] = 300;

  char c;
  for(c='a'; c<'h'; c++){
    std::cout << c;
    if(mymap.count(c)>0)
      std::cout << " is an element of mymap.\n";
    else
      std::cout << " is not an element of mymap.\n";
  }
}
\end{cpp}
#+end_latex

*** std::map::crbegin/crend
Return const_reverse_iterator to reverse beginning
C++11

*****
* Qt                                                                     :qt:
# to organize
** QT环境变量设置
+ http://blog.sina.com.cn/s/blog_ad91f9bc01018as9.html

#+BEGIN_EXAMPLE
  #QT Settings
  export  QTDIR=QT安装目录
  export   PATH=$QTDIR/bin:$PATH
  export  LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH  # 这个待定
  export   MANPATH=$QTDIR/doc/man:$MANPATH
  #End QT Settings
#+END_EXAMPLE
** Qt API
*** QWidget
1. const QPalette &	QWidget::palette() const
2. void	QWidget::setPalette(const QPalette &)
*** QTextEdit
*** QFontDialog
1. QFont QFontDialog::​getFont(bool * ok, const QFont & initial,
   QWidget * parent = 0, const QString & title = QString(),
   FontDialogOptions options = 0)

   Executes a modal font dialog and returns a font.

   If the user clicks OK, the selected font is returned. If the user
   clicks Cancel, the initial font is returned.

   The dialog is constructed with the given parent and the options
   specified in options. title is shown as the window title of the
   dialog and initial is the initially selected font. If the ok
   parameter is not-null, the value it refers to is set to true if the
   user clicks OK, and set to false if the user clicks Cancel.
*** QPalette
1. const QColor & QPalette::​color(ColorRole role) const

   Returns the color that has been set for the given color role in the
   current ColorGroup.

2. void QPalette::​setColor(ColorRole role, const QColor & color)

   This is an overloaded function.

   Sets the color used for the given color role, in all color groups,
   to the specified solid color.

*** QColorDialog
1. QColor QColorDialog::​getColor(const QColor & initial = Qt::white,
   QWidget * parent = 0, const QString & title = QString(),
   ColorDialogOptions options = 0)    [static]

   Pops up a modal color dialog with the given window title (or
   "Select Color" if none is specified), lets the user choose a color,
   and returns that color. The color is initially set to initial. The
   dialog is a child of parent. It returns an invalid (see
   QColor::isValid()) color if the user cancels the dialog.
*** QErrormessage
1. void QErrorMessage::​showMessage(const QString & message)
2.
*** QFontDialog
*** QFileDialog
1. QString QFileDialog::​getOpenFileName(QWidget * parent = 0, const
   QString & caption = QString(), const QString & dir = QString(),
   const QString & filter = QString(), QString * selectedFilter = 0,
   Options options = 0)

   This is a convenience static function that returns an existing file
   selected by the user. If the user presses Cancel, it returns a null
   string.
*** QInputDialog
1. QString QInputDialog::​getText(QWidget * parent, const QString &
   title, const QString & label, QLineEdit::EchoMode mode =
   QLineEdit::Normal, const QString & text = QString(), bool * ok = 0,
   Qt::WindowFlags flags = 0, Qt::InputMethodHints inputMethodHints =
   Qt::ImhNone)

   Static convenience function to get a string from the user.

   title is the text which is displayed in the title bar of the
   dialog. label is the text which is shown to the user (it should say
   what should be entered). text is the default text which is placed
   in the line edit. mode is the echo mode the line edit will
   use. inputMethodHints is the input method hints that will be used
   in the edit widget if an input method is active.

   If ok is nonnull *a ok will be set to true if the user pressed OK
   and to false if the user pressed Cancel. The dialog's parent is
   parent. The dialog will be modal and uses the specified widget
   flags.

   If the dialog is accepted, this function returns the text in the
   dialog's line edit. If the dialog is rejected, a null QString is
   returned.
*** QPrinter
+ Header:	#include <QPrinter>
+ qmake:	 QT += printsupport
+ Inherits:	QPagedPaintDevice.
*** QPrintDialog
+ Header:	#include <QPrintDialog>
+ qmake:	 QT += printsupport
+ Inherits:	QAbstractPrintDialog.
*** ToTar
1. T qobject_cast(QObject * object)

   Returns the given object cast to type T if the object is of type T
   (or of a subclass); otherwise returns 0. If object is 0 then it
   will also return 0.

   The class T must inherit (directly or indirectly) QObject and be
   declared with the Q_OBJECT macro.

2. QObject * SignalEvent::​sender() const

   Returns the object that emitted the signal.







5. 对话框
   + QColorDialog
   + QErrorMessage

** qmake                                                             :qmake:
*** ABORT [#C] QT qmake
DEADLINE: <2015-03-22 日>

- State "TODO"       from ""           [2015-03-04 三 14:31]
 Date:<2015-02-27 五>

 http://wenku.baidu.com/link?url=2wt6Gds-Rbr0FHV5SwwT5xlFOPbiXASxPAr_8wQbEF2js9VYO-KOJLHY_MawQBYvfJ3p3yQB-xm7moQzi0WAq7fjcwBBS6KBtbdsqxBMoja

** help
http://blog.csdn.net/sf2gis2/article/details/43988461
http://blog.csdn.net/sf2gis2/article/details/43988461

** moc 元对象编译器
+ http://www.eefocus.com/book/09-04/714961276059621.html


moc工具可以看成是一个C++预处理程序，用来扩展C++的特性，比如Qt的信号和
槽的机制，它并不是标准C++的特性，但经过moc的预处理之后，所有信号和槽相
关的代码都被“翻译”成了标准的C++，从而能够被gcc等编译。

1. 在Makefile中使用moc

   我们通常使用Qt提供的qmake工具来自动生成Makefile，这样做的好处是不用
   自己手动去添加很多Qt需要的规则，比如调用moc工具等。

   如果在某些情况下需要手动编写Makefile时，我们可以用下面的规则来调用
   moc:
   #+BEGIN_EXAMPLE
   moc_%.cpp: %.h
   moc $< -o $@
   #+END_EXAMPLE

   根据Makefile的规则，这里的含义是对所有头文件*.h，利用moc进行处理并
   得到moc_*.cpp。生成moc_*.cpp之后不要忘记你还同样需要对它进行编译和
   链接，所以你需要将它加到SOURCES和OBJECTS（可能是其他类似含义的变量）
   中。

2. moc用法详解

   moc支持的如下所示的一些命令行选项：
   + -o file

     将输出写到参数file（不指定的话将写到标准输出）。

   + -f [<file>]

     强制在输出文件中生成#include声明。这个选项在你的头文件没有遵循标准命
     名法则的时候才有用——当头文件的扩展名以H或h开始时，#include声明会自动
     生成，不需要使用-f 选项。文件名<file>为可选项。

   + -i

     不在输出文件中生成#include声明，与-f正好相反。当一个C++文件包含一个
     或多个类声明的时候可能用到。

   + -nw

     不产生任何警告。不建议使用。

   + -p <path>

     在元对象编译器生成的#include声明的文件名称中添加路径<path>/。

   + -I <dir>

     在头文件的包含路径中添加<dir>目录。

   + -E

     不生成元对象相关代码（仅用于预编译）

   + -D<macro>[=<def>]

     定义宏<macro>，或者定义宏<macro>=<def>，后者为可选项

   + -U<macro>

     取消宏<macro>的定义

   + -h

     显示moc的用法和选项

   + -v

     显示moc的版本

3. 忽略代码段
   我们还可以使用”#ifndef Q_MOC_RUN”来告诉moc工具不要处理某些代码。
   比如：
   #+BEGIN_EXAMPLE
   #ifndef Q_MOC_RUN
   ...
   #endif
   #+END_EXAMPLE
   则moc会忽略定义在省略号部分的代码。

   This prevents a MOC error with versions of boost >= 1.48
** Creator                                                         :creator:
*** Qt Creator Emacs Bindings

+ http://hahack.com/wiki/qt-skills.html
+ https://github.com/fberger/emacskeys/blob/master/README.markdown

** assistant                                                     :assistant:

http://qt-project.org/doc/qt-4.8-snapshot/assistant-manual.html
https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0CB4QFjAA&url=http%3A%2F%2Fblog.morpheuz.cc%2F01%2F07%2F2008%2Fqt-assistant-emacs%2F&ei=XKwLVb-hHpDtoASky4GQCQ&usg=AFQjCNEiIgBsGpZWAMByiSqhyJ_4HOu1fA&sig2=9BHnXLzV3e3dZt3tWiALng

*** install                                                       :install:

使用源码安装qt时，assistant没有内容？
+ sudo apt-get install libqtassistantclient qt-assistant-compat qt5-doc qttools5-dev-tools
+ sudo apt-get install --no-install-recommands install

Qt assistant只是一个阅读帮助文档的工具，它可以添加qch格式的帮助文档，
并不是只能添加Qt的帮助文档。

所以如果你需要阅读文档的话就需要先将自己的文档添加到这个工具里面，帮助
文档应该是在Documentation目录下，也就是一些.qch文件，至于怎么添加方法
如下：

打开assistant，选择菜单Edit->preferences，这个时候弹出如下对话框

qt5源码中没有找到qt压缩帮助文档(*.qch)

audo apt-get install qt5-doc
*** [[http://doc-snapshots.qt.io/4.8/assistant-manual.html][The One-Minute Guide to Using Qt Assistant]] :blog:guide:

Once you have installed Qt, /Qt Assistant/ should be ready to run:

- On Windows, /Qt Assistant/ is available as a menu option on the Qt
   menu.
- On Mac OS X, /Qt Assistant/ is installed in the
   /Developer/Applications/Qt directory.
- On Unix/Linux, open a terminal, type =assistant= and press *Enter*.

When you start up /Qt Assistant/, you will be presented with a standard
main window application, with a menu bar and toolbar. Below these, on
the left hand side are navigation windows called /Contents/, /Index/ and
/Bookmarks/. On the right, taking up most of the space, is the
/Documentation/ window. By default, /Qt Assistant/ loads the Qt
reference documentation along with the manuals of other Qt tools, like
/Qt Designer/ or /Qt Linguist/.

/Qt Assistant/ works in a similar way to a Web browser. If you click
hyperlinks (cross-references), the /Documentation/ window will present
the relevant page. You can bookmark pages of particular interest and you
can click the *Previous* and *Next* toolbar buttons to navigate within
the pages you have visited.

Although /Qt Assistant/ can be used just like a Web browser to navigate
through the documentation, /Qt Assistant/ offers a powerful means of
navigation that Web browsers do not provide. /Qt Assistant/ uses an
advanced full text search engine to index all the pages in each
compressed help file so that you can search for particular words and
phrases.

To perform an index search, click the *Index* tab on the Sidebar (or
press *Alt+I*). In the *'Look For'* line edit enter a word; e.g.,
'homedirpath'. As you type, words are found and highlighted in a list
beneath the line edit. If the highlighted text matches what you're
looking for, double click it, (or press *Enter*) and the /Documentation/
window will display the relevant page. You rarely have to type in the
whole word before /Qt Assistant/ finds a match. Note that for some words
there may be more than one possible page that is relevant.

/Qt Assistant/ also provides full text searching for finding specific
words in the documentation. To activate the full text search, either
press *(Alt+S)* or click on the *Search* tab in the /Documentation/
window. Then enter the term you're looking for and hit the *Search*
button. All documents containing the specified term will then be listed
in the list box below.

[[assistant-details.html][Qt Assistant in More Detail]]

© 2015 The Qt Company Ltd. Documentation contributions included herein
are the copyrights of their respective owners.

The documentation provided herein is licensed under the terms of the
[[http://www.gnu.org/licenses/fdl.html][GNU Free Documentation License
version 1.3]] as published by the Free Software Foundation.

** miscellaneous
*** DONE QT BEGIN_NAMESPACE
- State "DONE"       from "TODO"       [2015-02-24 二 19:13]
- State "TODO"       from ""           [2015-02-24 二 19:03]

参考:http://no001.blog.51cto.com/1142339/389798/
**** 使用
#+BEGIN_EXAMPLE
  #ifndef WINDOW_H
  #define WINDOW_H

  #include <QSystemTrayIcon>
  #include <QDialog>

  QT_BEGIN_NAMESPACE
  class QAction;
  class QCheckBox;
  class QComboBox;
  class QGroupBox;
  class QLabel;
  class QLineEdit;
  class QMenu;
  class QPushButton;
  class QSpinBox;
  class QTextEdit;
  QT_END_NAMESPACE

  //! [0]
  class Window : public qdialog
  {
  Q_OBJECT

  public:
  Window();
  ……

  ｝
#+END_EXAMPLE
**** 宏定义
#+BEGIN_EXAMPLE
  #define QT_BEGIN_NAMESPACE namespace QT_NAMESPACE{
  #define QT_END_NAMESPACE }
#+END_EXAMPLE

**** 作用
在头文件中尽量减少引用其它头文件,这样可加快编译速度.
**** 约束
在头文件中仅使用这些类的指针声明,而没有实例化.

*** DONE QT:tr
- State "DONE"       from "TODO"       [2015-02-24 二 19:39]
- State "TODO"       from ""           [2015-02-24 二 19:14]

参考: http://blog.csdn.net/mfc11/article/details/6591134

**** 问题与解决
在论坛中漂，经常遇到有人遇到tr相关的问题。用tr的有两类人：
  + (1)因为发现中文老出问题，然后搜索，发现很多人用tr，于是他也开始用tr
  + (2)另一类人，确实是出于国际化的需要，将需要在界面上显示的文件都用tr
    包起来，这有分两种：
    - (2a) 用tr包住英文(最最推荐的用法，源码英文，然后提供英文到其他
      语言的翻译包)
    - (2b) 用tr包住中文(源码用中文，然后提供中文到其他语言的翻译包)
      [[http://blog.csdn.net/dbzhang800/archive/2011/04/19/6334852.aspx][Qt国际化（源码含中文时）的点滴分析]]

注意哦，如果你正在用tr包裹中文字符，却不属于(2b)，那么，这是个信号：
  + 你在误用tr
  + 你需要的是QString，而不是tr
**** tr函数的作用
tr是用来实现国际化的.

tr是经过多级函数调用才实现翻译操作,因而是有代价的,没有必要的时候最好不
要使用.
**** QString的中文问题
***** 问题
+ QString 采用的unicode，在中文支持上不存在任何问题
+ "我是中文" 这是传统的 const char * 的窄字符串
+ 当将窄字符串赋值到QString时，我们需要告诉它我们的窄串采用的何种编码
  (gbk?、utf-8?)
+ 究竟何种编码主要取决于我们的源代码文件的编码(windows上一般是gbk，其
  他平台一般utf-8)

#+BEGIN_EXAMPLE
  QString s1 = "我是中文";
  QString s2("我是中文");
  QString s3;
  s3 = "我是中文"
#+END_EXAMPLE

+ s1、s2 用的是QString的构造函数QString ( const char * str )
+ s3 用的是QString的赋值操作符 QString & operator=( const char * str)

如果不指定编码，s1,s2,s3将全部都是(国内大多数人所称的)乱码。因为QString
将这些const char *按照latin1来解释的，而不是用户期待的gbk或utf8。

***** 解决
QTextCodec::setCodecForCStrings(QTextCodec::codecForName("GB2312"));
QTextCodec::setCodecForCStrings(QTextCodec::codecForName("UTF-8"))
这两条语句中的一条可以解决问题，至于如何选择，此处不再重复。

**** tr定义
参考文献中解释详实

** error                                                             :error:
*** DONE QT error: collect2: ld returned 1 exit status
- State "DONE"       from "TODO"       [2015-02-24 二 19:43]
- State "TODO"       from ""           [2015-02-24 二 19:40]

参考:http://blog.csdn.net/lincyang/article/details/5779464

Another reason might be that your source is incomplete and calls method
DECLARATIONS that get called but the method IMPLEMENTATIONS are
missing.

Declaration is the stuff that you usually put in a header file (method
signature without body)
Implementation is the signature with body.

简言之,头文件中的声明没有在源文件中实现.

** [[http://blog.csdn.net/mfc11/article/details/6591134][关于qt中的tr（）函数]] :blog:



在论坛中漂，经常遇到有人遇到tr相关的问题。用tr的有两类人：

- (1)因为发现中文老出问题，然后搜索，发现很多人用tr，于是他也开始用tr
- (2)另一类人，确实是出于国际化的需要，将需要在界面上显示的文件都用tr包起来，这有分两种：

   -  (2a)
      用tr包住英文(最最推荐的用法，源码英文，然后提供英文到其他语言的翻译包)
   -  (2b) 用tr包住中文(源码用中文，然后提供中文到其他语言的翻译包)

*注意哦，如果你正在用tr包裹中文字符，却不属于(2b)，那么，这是个信号：*

- 你在误用tr
- 你需要的是QString，而不是tr

*如果你确实属于(2b)，请做好心理准备，你可能还会遇到很多困难,请考虑*[[http://blog.csdn.net/dbzhang800/archive/2011/04/19/6334852.aspx][Qt国际化（源码含中文时）的点滴分析]]*
*

*tr 是做什么的？下面二者的区别是什么？*

#+BEGIN_EXAMPLE
    QString text1 = QObject::tr("hello");
     QString text2 = QString("hello");
#+END_EXAMPLE

tr是用来实现国际化，如果你为这个程序提供了中文翻译包(其中hello被翻译成中文"你好")，那么text1的内容将是中文"你好"；如果你为程序提供且使用日文翻译包，那么text1的内容将是日文。

tr是经过多级函数调用才实现了翻译操作，是有代价的，所以不该用的时候最好不要用。

*** 关注的对象

本文关注的是tr或translate中包含中文字符串的情况：

- =QObject::tr()=

- =QCoreApplication::translate()=

- =QTextCodec::setCodecForTr=

这个问题本多少可说的。因为涉及到的编码问题和[[http://hi.baidu.com/cyclone/blog/item/9d7293130e5a498d6538dbf1.html][QString
与中文问题]]中是完全一样的，只不过一个是用的setCodecForCStrings一个用的是setCodecForTr。

**** 简单回顾QString的中文问题

- QString 采用的unicode，在中文支持上不存在任何问题
- ="我是中文"= 这是传统的 =const char *= 的窄字符串

- 当将窄字符串赋值到QString时，我们需要告诉它我们的窄串采用的何种编码(gbk?、utf-8?)
- 究竟何种编码主要取决于我们的源代码文件的编码(windows上一般是gbk，其他平台一般utf-8)

例子：

#+BEGIN_EXAMPLE
    QString s1 = "我是中文";
    QString s2("我是中文");
    QString s3;
    s3 = "我是中文"
#+END_EXAMPLE

- s1、s2 用的是QString的构造函数=QString ( const char * str )=

- s3
   用的是QString的赋值操作符 =QString & operator= ( const char * str)=

如果不指定编码，s1,s2,s3将全部都是(国内大多数人所称的)乱码。因为QString将这些=const char *=按照latin1来解释的，而不是用户期待的gbk或utf8。

#+BEGIN_EXAMPLE
    QTextCodec::setCodecForCStrings(QTextCodec::codecForName("GB2312"));
    QTextCodec::setCodecForCStrings(QTextCodec::codecForName("UTF-8"))
#+END_EXAMPLE

这两条语句中的一条可以解决问题，至于如何选择，此处不再重复。

*** QObject::tr

说实话，在tr中使用中文不是个好主意。不过既然总有人用（无论是(1)还是(2b)），而且总有人遇到问题，所以还是简单整理一下吧。

相比=QCoreApplication::translate=，大家用tr应该用的很多了，尽管不少人不清楚tr究竟是做什么的=^_^=





#+BEGIN_EXAMPLE
    tr("我是中文");
#+END_EXAMPLE

这调用的是下面这个函数(至少我们可这么认为是)。

#+BEGIN_EXAMPLE
    QString QObject::tr ( const char * sourceText, const char * disambiguation = 0, int n = -1 )
#+END_EXAMPLE

与QString("我是中文")完全一样，你必须告诉tr这个窄字符串是何种编码？你不告诉它，它就用latin1。于是所谓的乱码问题就出来了。

如何告诉tr你写的这几个汉字在磁盘中保存的是何种编码呢？这正是

#+BEGIN_EXAMPLE
    QTextCodec::setCodecForTr(QTextCodec::codecForName("GB2312"));
    QTextCodec::setCodecForTr(QTextCodec::codecForName("UTF-8"));
#+END_EXAMPLE

所做的。这两个选择的原则，由于和前文完全一样，此处也不再重复。

如果你的编码采用的utf8，可以直接使用trUtf8而不必设置setCodecForTr。

如果你只关心乱码问题，到此为止就可以了(下面不再关注编码)。如果想对tr进一步了解，不妨。。继续。。



*** QCoreApplication::translate

我们知道tr是用于实现程序的国际化(或者说多语言翻译)，看Qt相关资料的话，我们知道实现该功能的还有下面这个函数：

#+BEGIN_EXAMPLE
    QString QCoreApplication::translate ( const char * context, const char * sourceText, const char * disambiguation, Encoding encoding, int n )
#+END_EXAMPLE

其实，这个才是真正进行翻译操作的函数，前面我们提到的tr最终是通过调用该函数来实现翻译功能的(稍后我们会看tr是如何调用translate的)。

对tr和这个函数，manual中都有比较详尽的解释。我们这儿简单看一下它的这几个参数：

- context 上下文，一般就是需要翻译的字符串所在的类的名字
- sourceText 需要翻译的字符串。(我们关注的编码其实就是它的编码)
- disambiguation
   消除歧义用的。(比如我们的类内出现两处"close"，一处含义是关闭，另一处含义是亲密的。显然需要让翻译人员知道这点区别)
- encoding 指定编码。它有两个值

   -  CodecForTr 使用setCodecForTr()设置的编码来解释 sourceText

   -  UnicodeUTF8 使用utf8编码来解释 sourceText
   -  其实这两个分别对应tr和trUtf8

- n 处理单复数(对中文来说，不存在这个问题)

*** tr与translate

这两个函数的说明，一个在QObject的manual，另一个在QCoreApplication的manual中。

介绍一下tr与translate的关系。前面提到了，tr调用的是translate。如果仅仅这样一说，没有证据，还真难以让大家相信。好吧，继续

**** tr 在何处定义

你可能说：这不废话吗，manual中写得明白的，它是QObject的静态成员函数。而且还有源码为证：

#+BEGIN_EXAMPLE
    //来自 src/corelib/kernel/qobject.h
    #ifdef qdoc
    static QString tr(const char *sourceText, const char *comment = 0, int n = -1);
    static QString trUtf8(const char *sourceText, const char *comment = 0, int n = -1);
    #endif
#+END_EXAMPLE

嘿嘿，差点就被骗了，发现没：它们被预处理语句包住了。

这说明了什么呢？说明了这段代码*仅仅是*用来生成Qt那漂亮的文档的(qdoc3从代码中抽取信息，生成一系列的html格式的manual)。

啊，也就是说，这是假的。那么真正的定义呢？？在一个大家都很熟悉的地方,猜猜看？

这就是

#+BEGIN_EXAMPLE
    Q_OBJECT
#+END_EXAMPLE

该宏的定义在src/corelib/kernel/qobjectdefs.h中

#+BEGIN_EXAMPLE
    #define Q_OBJECT \
     public: \
     Q_OBJECT_CHECK \
     static const QMetaObject staticMetaObject; \
     Q_OBJECT_GETSTATICMETAOBJECT \
     virtual const QMetaObject *metaObject() const; \
     virtual void *qt_metacast(const char *); \
     QT_TR_FUNCTIONS \
     virtual int qt_metacall(QMetaObject::Call, int, void **); \
     private:
#+END_EXAMPLE



其中的宏QT_TR_FUNCTIONS

#+BEGIN_EXAMPLE
    #  define QT_TR_FUNCTIONS \
     static inline QString tr(const char *s, const char *c = 0) \
     { return staticMetaObject.tr(s, c); } \
     static inline QString trUtf8(const char *s, const char *c = 0) \
     { return staticMetaObject.trUtf8(s, c); } \
     static inline QString tr(const char *s, const char *c, int n) \
     { return staticMetaObject.tr(s, c, n); } \
     static inline QString trUtf8(const char *s, const char *c, int n) \
     { return staticMetaObject.trUtf8(s, c, n); }
#+END_EXAMPLE

现在看到：tr调用的是 staticMetaObject对象的tr函数，staticMetaObject
的定义在moc生成的 xxx.moc 或 moc_xxx.cpp 文件内(你随时可以验证的)。

staticMetaObject 是一个 QMetaObject 类的实例，我们继续看一下该类的源码：

#+BEGIN_EXAMPLE
    /*!
     \internal
    */
     QString QMetaObject::tr(const char *s, const char *c) const
     {
     return QCoreApplication::translate(d.stringdata, s, c, QCoreApplication::CodecForTr);
     }
     /*!
     \internal
    */
    QString QMetaObject::trUtf8(const char *s, const char *c) const
    {
    return QCoreApplication::translate(d.stringdata, s, c, QCoreApplication::UnicodeUTF8);
#+END_EXAMPLE

}

** [[http://blog.sina.com.cn/s/blog_ad91f9bc01018as9.html][QT的安装及环境配置]] :blog:



QT的安装及环境配置

一、windows的下QT的安装及环境配置

（一）从框架安装程序中安装

步骤：

准备：下载QT库，下载指定版本的MINGW，QT IDE

1、下载QT安装文件如：qt-win-opensoure-4.6.4-mingw.exe

2、下载MINGW：mingw 或者 dev-cpp

3、下载QTIDE：QTCreator

3、执行安装MINGW(至少安gcc complier、g++ complier、MinGw Make)

4、执行安装QTIDE:QtCreator

5、安装QT库：qt-win-opensoure-4.5.2-mingw.exe

6、编译QT debug库。QT库安装后有一个QT Build Debug libraries快捷方式。

7、手动配置环境变量(一般在WINDOWS下可略过此步,但最好配置一下)

8、安装完QT库以后，一般会有一个QT command prompt 的快捷方式，它可以

打开一个控制台，并且能够自动设置（使用MinGw编译器编译QT程序所需要的)

环境变量，在这个窗口中，就可以运行qmake以及make命令来编译QT应用程序。

9、QTIDE(QtCreator的配置)，

主要设置：

1) QT版本设置：tools>options>build&run>Qt version

在这里添加QT库的（安装目录下的）qmake

如：C:\Qt\4.6.4\bin\qmake.exe

[[http://photo.blog.sina.com.cn/showpic.html#blogid=ad91f9bc01018as9&url=http://s10.sinaimg.cn/orignal/ad91f9bcxd10bcda20f79][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]



2) 编译器及调试器设置：tools>options>build&run>Tool Chains

首先添加MINGW

在Complier path添加g++目录(mingw安装目录中的)

如：C:\MINGW\bin\g++.exe

[[http://photo.blog.sina.com.cn/showpic.html#blogid=ad91f9bc01018as9&url=http://s8.sinaimg.cn/orignal/ad91f9bcxd10bcef38907][[[http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif]]]]



（二）使用SDK安装

安装完成，设置环境变量及QTIDE设置

（三）使用源代码安装

1、安装MINGW

2、安装QTIDE：QtCreator

3、下载并解压缩QT源代码到指定目录，如：C:\QT\QTSRC

4、编译源代码：如果编译不成功，则设置MINGW环境变量，及加入到PATH中

进入命令窗口

进入解压目录：

//运行configure进行配置生成makefile 这里同时编译debug版本(调试程序用)和

release版（运行程序使用）

C:\QT\QTSRC>configure -debug-and-release

//运行MINGW的make工具(mingw32-make) 进行编译

C:\QT\QTSRC>mingw32-make

编译成功后，便可使用，无需安装。

5、环境变量的设置。

6、Qt Creator的配置





二、X11平台下安装

（一）SDK安装

安装完以后需要配置环境变量。



（二）编译源代码安装

1、下载所需要的版本QT库源代码。

2、解压缩源代码到指定目录

3、切换工作目录到源代码解压缩目录。

4、生成平台相关qmake>makefile

运行./configure（使用绝对路径，或者相对路径），可加参数

(最好先使用make clean将以前有可能已经编译的清除掉)

./configure -prefix=安装目录 //编译完成后，使用make install时，安装到哪个

目录

5、执行make 编译

make [all] //编译debug 与release版，默认只编译release

6、安装QT

make install 默认安装到/usr/local下(如果configure -prefix指定，则安装到指定

目录)

7、设置环境变量

8、验证安装

qmake -v

9、删除本次安装时使用的编译过的文件及配置文件等

make clean

10、可提前安装QTIDE，都完成安装后设置QTIDE的选项(编译器及调试器的

路径设置g++ gdb)

三、环境变量的配置

² WINDOWS平台

1、可以使用我的电脑属性右键设置。永久有效

QTDIR=QT安装目录

MINGW=MINGW安装目录

PATH附加上%QTDIR%\bin;%MINGW%\bin;

QMAKESPEC=win32-g++

2、也可以使用进入DOS窗口，使用CMD命令设置，但只对本窗口有效

设置：进入CMD

C:>set QTDIR=QT安装目录

set MINGW=MINGW安装目录

set PATH=%QTDIR%\BIN;%MINGW%\bin;%PATH%

set QMAKESPEC=win32-g++





² X11平台

1、如果使用的Shell是bash、ksh、zsh、sh

将下列内容写入到~/.bash_profile(或者~/.profile)加入以下内容

#QT Settings

export QTDIR=QT安装目录

export PATH=$QTDIR/bin:$PATH

export LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH

export MANPATH=$QTDIR/doc/man:$MANPATH

#End QT Settings

#为批注。

2、如果使用的Shell是CSH 或者TCSH

将下列代码加入到/etc/csh.login

#QT Settings

setenv PATH QT安装目录/bin:$PATH

#End QT Settings



注1：所有目录，最好不带有空格和中文。gcc是GNU c编译器， g++是GNU c++编译器

注2：默认只编译release(用于运行QT程序)，不编译debug(用于调试QT程序)

解决：

在WINDOWS，

使用QT框架安装完以后，有一个QT Build Debug Libraries快捷方式(进行编译)

指向QT安装目录\bin\qtvars.bat文件

使用QT源代码编译时，指定configure -debug-and-release

在X11下，make时，加上选项 make all



附件：QT安装目录\bin\qtvars.bat文件 DOS下编译Debug Libraries

@echo off

rem

rem This file is generated

rem



echo Setting up a MinGW/Qt only environment...

echo -- QTDIR set to C:\Qt\4.6.4

echo -- PATH set to C:\Qt\4.6.4\bin

echo -- Adding C:\MinGW\\bin to PATH

echo -- Adding %SystemRoot%\System32 to PATH

echo -- QMAKESPEC set to win32-g++



set QTDIR=C:\Qt\4.6.4

set PATH=C:\Qt\4.6.4\bin

set PATH=%PATH%;C:\MinGW\\bin

set PATH=%PATH%;%SystemRoot%\System32

set QMAKESPEC=win32-g++



if not "%1"=="compile_debug" goto END

cd %QTDIR%

echo This will configure and compile qt in debug.

echo The release libraries will not be recompiled.

pause

configure -plugin-sql-sqlite -plugin-sql-odbc -qt-libpng -qt-libjpeg

cd %QTDIR%\src

qmake

mingw32-make debug

:END

** [[http://blog.csdn.net/lincyang/article/details/5779464][关于qt :: error: collect2: ld returned 1 exit status的错误]] :blog:
刚才遇到的这个问题，在网上搜索了一下，

有说之前的程序已经运行了，有说pro文件有问题的，

我找了一会，发现我在头文件中定义了两个slots，

在cPP文件中没有实现。

见nokia论坛

Another reason might be that your source is incomplete and calls method DECLARATIONS that get called but the method IMPLEMENTATIONS are missing.

Declaration is the stuff that you usually put in a header file (method signature without body)
Implementation is the signature with body.

Usually if you look in the linker output, you can find which implementation the linker is missing.

click the "Compile Output" view (Alt+4) to see more detailed info.

这样，我找到了这个低级错误~~~
* OpenGL                                                             :opengl:
** opencv编译时链接错误                                                :ldd:
*问题在于ros的库，覆盖了opencv的库*

*source /opt/ros/indigo/setup.bash* 前
#+begin_example
pkg-config opencv --libs


~ $ cd wally/journal/project/ros/opencv/
/usr/lib/i386-linux-gnu/libopencv_calib3d.so
/usr/lib/i386-linux-gnu/libopencv_contrib.so
/usr/lib/i386-linux-gnu/libopencv_core.so
/usr/lib/i386-linux-gnu/libopencv_features2d.so
/usr/lib/i386-linux-gnu/libopencv_flann.so
/usr/lib/i386-linux-gnu/libopencv_gpu.so
/usr/lib/i386-linux-gnu/libopencv_highgui.so
/usr/lib/i386-linux-gnu/libopencv_imgproc.so
/usr/lib/i386-linux-gnu/libopencv_legacy.so
/usr/lib/i386-linux-gnu/libopencv_ml.so
/usr/lib/i386-linux-gnu/libopencv_objdetect.so
/usr/lib/i386-linux-gnu/libopencv_ocl.so
/usr/lib/i386-linux-gnu/libopencv_photo.so
/usr/lib/i386-linux-gnu/libopencv_stitching.so
/usr/lib/i386-linux-gnu/libopencv_superres.so
/usr/lib/i386-linux-gnu/libopencv_ts.so
/usr/lib/i386-linux-gnu/libopencv_video.so
/usr/lib/i386-linux-gnu/libopencv_videostab.so -lopencv_calib3d
-lopencv_contrib -lopencv_core -lopencv_features2d -lopencv_flann
-lopencv_gpu -lopencv_highgui -lopencv_imgproc -lopencv_legacy
-lopencv_ml -lopencv_objdetect -lopencv_ocl -lopencv_photo
-lopencv_stitching -lopencv_superres -lopencv_ts -lopencv_video
-lopencv_videostab
#+end_example

*source /opt/ros/indigo/setup.bash* 后
#+begin_example
/opt/ros/indigo/lib/libopencv_calib3d.so
/opt/ros/indigo/lib/libopencv_core.so
/opt/ros/indigo/lib/libopencv_features2d.so
/opt/ros/indigo/lib/libopencv_flann.so
/opt/ros/indigo/lib/libopencv_highgui.so
/opt/ros/indigo/lib/libopencv_imgcodecs.so
/opt/ros/indigo/lib/libopencv_imgproc.so
/opt/ros/indigo/lib/libopencv_ml.so
/opt/ros/indigo/lib/libopencv_objdetect.so
/opt/ros/indigo/lib/libopencv_photo.so
/opt/ros/indigo/lib/libopencv_shape.so
/opt/ros/indigo/lib/libopencv_stitching.so
/opt/ros/indigo/lib/libopencv_superres.so
/opt/ros/indigo/lib/libopencv_ts.a
/opt/ros/indigo/lib/libopencv_video.so
/opt/ros/indigo/lib/libopencv_videoio.so
/opt/ros/indigo/lib/libopencv_videostab.so
/opt/ros/indigo/lib/libopencv_viz.so
#+end_example

*** g++
g++编译：  *g++ main.cpp -lopencv_core -lopencv_highgui*
-llibs 一定要在源文件后


*** cmake

CMakeLists.txt
#+BEGIN_EXAMPLE
cmake_minimum_required(VERSION 2.8)
project( DisplayImage )
find_package( OpenCV REQUIRED )
include_directories (${OpenCV_INCLUDE_DIRS})  # 这句官网上没有
add_executable( DisplayImage hello_opencv.cpp )
target_link_libraries( DisplayImage ${OpenCV_LIBS} )
#+END_EXAMPLE
* Make
** CMake                                                             :CMAKE:
*** reference

- [[http://www.cmake.org/][Homepage]]
- [[https://github.com/Kitware/CMake][Github]]

*** fundermental

**** installation from source code                               :install:

https://github.com/Kitware/CMake

#+BEGIN_EXAMPLE
$ ./bootstrap && make && make install
#+END_EXAMPLE

*** CMake手册
**** 指令
***** ADD_DEFINITIONS

向C/C++编译器添加-D定义

eg.
#+BEGIN_EXAMPLE
ADD_DEFINITONS(-DENABLE_DEBUG -DABC)
#+END_EXAMPLE
参数之间使用空格分割.
如果代码中定义了#ifdef ENABLE_DEBUG  #endif, 这块代码就会生效.

其它编译器开关可以通过 *CMAKE_C_FLAGS* 和 *CMAKE_CXX_FLAGS* 变量设
置.


***** ADD_DEPENDENCIES

定义target秘依赖的其它target, 确保编译本target之前,

其它的target已经被构建.

#+BEGIN_EXAMPLE
  ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...)
#+END_EXAMPLE

***** ADD_EXECUTABLE
定义生成的可执行文件名称, 及源文件列表.
可执行文件名与工程名无关, eg. HELLO hello
***** ADD_LIBRARY
+ 格式
  #+BEGIN_EXAMPLE
    ADD_LIBRARY(libname [SHARED | STATIC | MODULE]
                [EXCLUDE_FROM_ALL]
                source1 source2 ...)
  #+END_EXAMPLE
+ 类型:
  + SHARED: 动态库, 后缀 *.so*
  + STATIC: 静态库, 后缀 *.a*
  + MODELE: 在使用dyld的系统中有效, 如果不支持dyld, 则被当作SHARED对待.
***** ADD_SUBDIRECTORY
+ 向工程中添加存放源文件的目录, 并指定中间二进制文件和目标二进制
  文件的存放位置
+ 格式: *ADD_SUBDIRECTORY(source_dir [binary_dir]
  [EXCLUDE_FROM_ALL])*
  + EXCLUDE_FROM_ALL的含义是将这个目录从编译过程
  + 省略binary_dir,则编译结果将存放到build/src目录下, 指定bin后,
    相当于编译时将src重命名为bin, 所有的 *中间结果和目标二进制*
    都将存放在bin中
***** ADD_TEST
ADD_TEST(testname Exename arg1 arg2 ...)
+ testname 自定义的test名称
+ Exebane  可以是构建的目标文件名, 也可以是外部脚本等
+ arg是传递给可执行文件的参数
+ 没有ENABLE_TESTING指令, 任何ADD_TEST都是无效的
+ 生成Makefile后, 可以运行make test来执行测试

***** AUX_ADD_DIRECTOR
AUX_ADD_DIRECTORY(dir VARIBALE)

发现一个目录下的所有的源文件并将列表存储在一个变量中

***** CMAKE_MINIMUM_REQUIRED
CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR])

***** ENABLE_TESTING
ENABLE_TESTING指令用来控制Makefile是否构建test目标, 语法简单不带任
何参数, ENABLE_TESTING(), 一般放在工程的主CMakeLists.txt中.
***** EXEC_PROGRAM
在CMakeLists.txt处理过程中执行命令, 并不会在生成的Makefile中执行.
#+BEGIN_EXAMPLE
  EXEC_PROGRAM(Executable [dir in which to run]
                          [ARGS <arguments to executable]
                          [OUTPUT_VARIBLE <var>]
                          [RETURN_VALUE <var>])
#+END_EXAMPLE

***** FILE 文件操作指令
#+BEGIN_EXAMPLE
  FILE(WRITE filename "message to write"...)
  FILE(APPEND filename "messag to write"...)
  FILE(READ filename variable)
  FILE(GLOB variable [RELATIVE path] [globbing expressions]...)
  FILE(GLOB_RECURSE variable [RELATIVE path]
                    [globbing expressions]...)
  FILE(REMOVE [derectory])
  FILE(REMOVE_RECURSE [directory])
  FILE(MAKE_DIRECTORY [directory])
  FILE(RELATIVE_PATH variable directory file)
  FILE(TO_MAKE_PATH path result)
  FILE(TO_NATIVE_PAHT path result)
#+END_EXAMPLE

***** FIND_LIBARAY
***** FIND_PACKAGE
#+BEGIN_EXAMPLE
  FIND_PACHAGE(<name> [major.minor] [QUIET] [NO_MODULE]
                      [[REQUIRED | COMPONENTS] [compenents...]])
#+END_EXAMPLE

***** FIND_PATH
+ 功能: 用来指定在路径中搜索文件名
+ 语法:
  #+BEGIN_EXAMPLE
    FIND_PATH(myHeader NAMES filename PATHS patsh)
  #+END_EXAMPLE

+ 省略路径则使用CMAKE_INCLUDE_PATH中定义的路径.

+ 注:如果不使用FIND_PAHT,CMAKE_INCLUDE_PATH变量的设置是没有作用的,
  它不会为编译器命令添加参数 -I <CMAKE_INCLUDE_PATH>的.
***** FIND_PATH
FIND_PATH(<VAR> name path1 path2 ...)
***** FIND_PROGRAM
FIND_PROGRAM(<VAR> name path1 path2 ...)
***** GET_TARGET_PROPERTY
+ 格式: GET_TARGET_PROPERTY(VAR target property)
+ e.g.
  #+BEGIN_EXAMPLE
    GET_TARGET_PROPERTY(OUTPUT_VALUE hello_static OUTPUT_NAME)
    MESSAGE(STATUS "This is the hello_static OUTPUT_NAME:"${OUTPUT_VALUE})
  #+END_EXAMPLE
***** INCLUDE
用来载入CMakeLists.txt文件或预定义的cmake模块
#+BEGIN_EXAMPLE
  INCLUDE(file [OPTIONAL])
  INCLUDE(module [OPTIONAL])
#+END_EXAMPLE
+ OPTIONAL参数用来设置文件不存在也不会产生错误
+ 模块将在CMAKE_MODULE_PATH中搜索并载入
+ 载入的内容将在处理到INCLUDE语句时直接执行
***** INCLUDE_DIRECTORIES
+ 引入头文件搜索路径
+ 语法:
  #+BEGIN_EXAMPLE
    INCLUDE_DERECTORIES([AFTER|BEFORE] [SYSTEM]
                        dir1 dir2 ....         )
  #+END_EXAMPLE
+ 路径中包含空格时需要使用双引号括起来
+ 默认追加到当前的头文件搜索路径的后面
  + CMAKE_INCLUDE_DIRECTORIES_BEFORE 设为 on 时, 追加到前
  + 使用 AFTER | BEFORE 参数改变行为
***** INSTALL指令
*INSTALL* 指令用于定义安装规则, 安装的内容可以包括目标二进制, 动态库,
静态库, 目录, 脚本等.

1. INSTALL 目标文件
   格式:
   #+BEGIN_EXAMPLE
     INSTALL(TARGET targets ...
             [[ARCHIVE | LIBRARY | RUNTIME]
                       [DESTINATION <dir>]
                       [PREMISSIONS premissions...]
                       [CONFIGURATIONS [Debug | Release ...]]
                       [COMPONENT <component>]
                       [OPTIONAL]
                       ] [...])
   #+END_EXAMPLE
   + 目标类型:
     + ARCHIVE: 特指静态库
     + LIBRATY: 动态库
     + RUNTIME: 可执行目标二进制文件
   + DESTINATION: 定义安装路径
     + 以"/"开头, 表绝对路径, CMAKE_INSTALL_PREFIX无效
     + 否则表相对路径, 此时安装路径为:
       ${CMAKE_INSTALL_PREFIX}/<DESTINATION>

   #+BEGIN_EXAMPLE
   INSTALL(TARGETS myrun mylib mystaticlib
   RUNTIME DESTINATION bin
   LIBRARY DESTINATION lib
   ARCHIVE DESTINATION libstatic)
   #+END_EXAMPLE

   注: 不需要关心TARGETS具体生成的路径, 只要写上TARGETS的名称就可以
   了.
2. INSTALL 普通文件
   + 格式:
      #+BEGIN_EXAMPLE
        INSTALL(FILES files... DESTINATION <dir>
                [PREMISSION premission ...]
                [CONFIGURATIONS [Debug|Release|...]]
                [COMPONENT <component>]
                [RENAME <name>] [OPTIONAL])
     #+END_EXAMPLE

   + 功能: 安装一般文件, 并可指定访问权限, 文件名是此指令所在路径下
     的相对路径. 默认权限为: OWNER_WRITE, OWNER_READ, GROUP_READ,
     和WORLD_READ, 即644.
3. 非目标文件的可执行程序安装(脚本等)
   + 格式:
     #+BEGIN_EXAMPLE
        INSTALL(PROGRAMS files... DESTINATION <dir>
                [PREMISSION premission ...]
                [CONFIGURATIONS [Debug|Release|...]]
                [COMPONENT <component>]
                [RENAME <name>] [OPTIONAL])
     #+END_EXAMPLE
     和FIFLES使用方法一样, 权限不同, 为755
4. 目录的安装
   #+BEGIN_EXAMPLE
     INSTALL(DIRECTORY dirs... DESTINATION <dir>
             [FILE_PREMISSIONS premissions...]
             [DIRECTORY_PREMISSIONS permissions...]
             [USE_SOURCE_PREMISSIONS]
             [CONFIGURATIONS [Debug|Release|...]]
             [COMPONENT <component>]
             [[PATTERN <pattern> | REGEX <regex>]
              [EXCLUDE] [PREMISSIONS <permissions...]]
             [...])
   #+END_EXAMPLE
   + DIRECTORY后面连接的是所有Source目录的相对路径, abc/ 和 abc 有
     很大区别
   + PATTERN 表示使用正则表达式过滤
   + PREMISSIONS 表示过滤后的文件权限
5. 安装脚本
   #+BEGIN_EXAMPLE
     INSTALL([SCRIPT <file>] [CODE <code>] [...])
   #+END_EXAMPLE
   + SCRIPT 用于安装时调用cmake脚本文件, abc.cmake
   + INSTALL 用于执行CMake指令, 必须使用双引号括起来
     eg.
     #+BEGIN_EXAMPLE
       INSTALL(CODE "MESSAGE(\\"Sample install message\")")
     #+END_EXAMPLE

***** LINK_DIRECTORIES
***** LINK_LIBRARIES
+ 添加共享库
+ 语法:
  + LINK_DIRECTORIES(dir1 dir2 ...)
    添加非标准的共享库的搜索路径.
  + TARGET_LINK_LIBRARIES
    #+BEGIN_EXAMPLE
      TARGET_LINK_LIBRARIES(target library1
                            <debug | optimized> library2
                            ...)
    #+END_EXAMPLE
    为target(可执行文件或共享库等)
+ eg. 链接到动态库
  #+BEGIN_EXAMPLE
    TARGET_LINK_LIBRARIES(main hello)
    # OR
    TARGET_LINK_LIBRARIES(main libhello.so)
  #+END_EXAMPLE
***** MESSAGE

+ 格式: MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR], "message to
  display")
  + SEND_ERROR: 产生错误, 生成过程被跳过
  + STATUS: 输出前缀为"-"的信息
  + FATAL_ERROR: 立即终止所有cmake过程
***** PORJECT
+ 格式: PROJECT(projectname [CXX] [C] [Java])
+ 功能: 指定工程名称, 和工程支持的语言, 语言列表可选, 默认表示支持
  所有.
+ 说明:
  + 隐式定义了两个变量: *projectname_SOURCE_DIR* 和
    *projectname_BINARY_DIR*, 内部编译时, 指向工程目录
  + 预定义 *PROJECT_SOURCE_DIR* 和 *PROJECT_BINARY_DIR*, 分别与上述
    两个变量等价.
***** SET
+ 格式: SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])

***** SET_TARGET_PROPERTIES
+ 语法
  #+BEGIN_EXAMPLE
    SET_TARGET_PROPERTIES(target1 targets ...
                          PROPERTIES prop1 value1
                                     prop2 value2)
  #+END_EXAMPLE
+ 该指令可以用于设置输出的名称, 对于动态库, 还可以 指定其动态库版本
  和API版本.
+ eg. 动态库和静态库同名
  #+BEGIN_EXAMPLE
    SET(LIBHELLO_SRC hello.c)
    SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
    ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
    ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})
    SET_TARGET_PROPERTY(hello_static PROPERTIES OUTPUT_NAME "hello")
  #+END_EXAMPLE
+ eg 版本号
  #+BEGIN_EXAMPLE
  SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)
#+END_EXAMPLE
   + VERSION: 指代动态库版本号
   + SOVERSION: 指代API版本
***** SUBDIR
SUBDIR(dir1 dir2 ...) 一次添加多个子目录, 但已不推荐使用

***** 控制指令
****** IF
   #+BEGIN_EXAMPLE
     IF(expression)
         # THEN section
         COMMAND1(ARGS ...)
         COMMAND2(ARGS ...)
         ...
     ELSE(expression)
         # ELSE sectioono
         COMMAND1(ARGS ...)
         COMMAND2(ARGS ...)
         ...
     ENDIF(expression)
   #+END_EXAMPLE
   凡是出现IF的地方一定要对应有ENDIF, 出现ELSEIF的地方, ENDIF是可选的.

   + IF(var): 变量不是: 空, 0, N, NO, OFF, FALSE, NOTFOUND或
     <var>_NOTFOUND时, 表达式为真
   + IF(NOT var)
   + IF(var1 AND var2)
   + IF(var1 OR var2)
   + IF(COMMAND cmd), 当给定的cmd确实是命令且可以调用时为真
   + IF(EXISTS dir/file) 目录或文件存在时为真
   + IF(fileq1 IS_NEWER_THAN file2)
   + IF(ID_DIRECTORY dirname)
   + IF(variable MATCHES regex)
   + IF(string MATCHED regex)

   + IF(varible LESS number)
   + IF(string LESS number)
   + IF(variable GREATER number)
   + IF(string GREATER number)
   + IF(variable EQUAL number)
   + IF(string EQUAL number)

   + IF(var/str STRLESS/STRGREATER/STREQUAL string)

   + IF(DEFINED variable)

   #+BEGIN_EXAMPLE
     IF(WIN32)
         MESSAGE(STATUS "This is windows")
     ELSE(WIN32)     # 容易造成歧义
         MESSAGE(STATUS "This is not windows")
     END(IF)
   #+END_EXAMPLE

   使用开关: *CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS*
   #+BEGIN_EXAMPLE
     SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)

     IF(WIN32)
     ELSE()
     ENDIF()
   #+END_EXAMPLE

****** WHILE
   #+BEGIN_EXAMPLE
     WHILE(condition)
         COMMAND1(ARGS ...)
         COMMAND2(ARGS ...)
         ...
     ENDWHILE(condition)
   #+END_EXAMPLE

****** FOREACH
   1) 列表
      #+BEGIN_EXAMPLE
        FOREACH(loop_var arg1 arg2 ...)
            COMMAND1(ARGS ...)
            COMMAND2(ARGS ...)
            ....
        ENDFOREACH(loop_var)
      #+END_EXAMPLE
      eg.
      #+BEGIN_EXAMPLE
        AUX_SOURCE_DIRECTORY(. SRC_LIST)
        FOREACH(F ${SRC_LIST})
            MESSAGE(${F})
        ENDFOREACH(F)
      #+END_EXAMPLE

   2) 范围
      #+BEGIN_EXAMPLE
        FOREACH(loop_var RANGE total)
        ENDFOREACH(loop_var)
      #+END_EXAMPLE
      从0到total以1步进

   3) 范围和步进
      #+BEGIN_EXAMPLE
        FOREACH(loop_var RANGE start stop [step])
        ENDFOREACH(loop_var)
      #+END_EXAMPLE

   4) 该指令需要注意的是, 直到遇到了ENDFOREACH指令, 整个语句块才会被真
      正的执行.

**** 变量
***** CMAKE_BINARY_DIR, PROJECT_BINARY_DIR, <projectname>_BINARY_DIR
+ in-source: 工程顶层目录
+ out-of-source: 编译目录
***** CMAKE_CURRENT_BINARY_DIR
+ in-source: CMAKE_CURRENT_SOURCE_DIR
+ out-of--source: target编译目录
+ 注: ADD_SUBDIRECTORY(src bin)可以改变该变量
+ 注:SET(EXECUTABLE_OUTPUT_PATH <path>)不会影响该变量
***** CMAKE_CURRENT_LIST_FILE
输出调用该变量的CMakeLists.txt的完整路径
***** CMAKE_CURRENT_LIST_LINE
输出调用该变量所在的行
***** CMAKE_CURRENT_SOURCE_DIR
当前CMakeLists.txt所在目录
***** CMAKE_INSTALL_PREFIX
CMAKE_INSTALL_PREFIX 的默认定义为 */usr/local*
#+BEGIN_EXAMPLE
  cmake -DCMAKE_INSTALL_PREFIX=/usr
#+END_EXAMPLE
***** CMAKE_MODULE_PATH
定义cmake模块所在路径
   + 杂的工程需要使用模块
   + SET定义
   + 使用INCLUDE指令调用．
***** CMAKE_SOURCE_DIR, PROJECT_SOURCE_DIR, <projectname>_SOURCE_DIR
工程顶层目录
***** EXECUTABLE_OUT_PATH
EXECUTABLE_OUTPUT_PATH指定目标二进制的位置和共享库的位置(不包括编译生
成的中间文件)
#+BEGIN_EXAMPLE
  SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
#+END_EXAMPLE
注: *在哪里ADD_EXECUTABLE, 如果需要改变目标文件存放目录,就在哪里加入上
述定义*

***** LIBRARY_OUTPUT_PATH
LIBRARY_OUTPUT_PATH指定目标二进制的位置和共享库的位置(不包括编译生成的
中间文件)
#+BEGIN_EXAMPLE
  SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
#+END_EXAMPLE
注: *在哪里ADD_LIBRARY, 如果需要改变目标文件存放目录,就在哪里加入上述
定义*

***** PROJECT_NAME
返回PROJECT定义的名称
***** 开头选项
****** CMAKE_ALLOW_LOOSE_CONSTRUCTS
控制IF ELSE书写方式
****** BUILD_SHARE_LIBS
控制默认的库编译方式，　默认为静态库
eg
#+BEGIN_EXAMPLE
 SET(BUILD_SHARED_LIBS on)
#+END_EXAMPLE
****** CMAKE_C_FLAGS
设置C编译选项，也可以使用ADD_DEFINITIONS()添加
****** CMAKE_CXX_FLAGS
设置C++编译选项，也可以使用ADD_DEFINTIONS()添加．
***** 系统信息
****** CMAKE_MAJOR_VERSION
主版本号， *2*.4.6
****** CMAKE_MINOR_VERSION
次版本号， 2. *4*.6
****** CMAKE_PATCH_VERSION
补丁等级， 2.4. *6*
****** CMAKE_SYSTEM
系统名称，如Linux-2.6.22
****** CMAKE_SYSTEM_NAME
不包含版本号
****** CMAKE_SYSTEM_VERSION
系统版本号
****** CMAKE_SYSTEM_PROCESSOR
处理器名称　eg. i686
****** UNIX
类UNIX平台下为TRUE,包括OS X和cygwin
****** WIN32
Win32平台下为TRUE，包括cygwin
**** 环境变量
***** CMAKE_INCLUDE_CURRENT_DIR
自动添加CMAKE_CURRENT_BINARY_DIR和CMAKE_CURRENT_SOURCR_DIR到当前处
理的CMakeLists.txt
***** CMAKE_INCLUDE_DIRECTORY_PROJECT_BEFORE
工程提供的头文件目录始终置于系统头文件之前

***** CMAKE_INCLUDE_PATH
***** CMAKE_LIBRARY_PATH
***** 设置 *SET{ENV{变量名}　值}*
***** 调用: *$ENV{}*
   eg.
   #+BEGIN_EXAMPLE
   MESSAGE(STATUS "HOME dir: $ENV(HOME)")
   #+END_EXAMPLE
*** Quick Guide: CMake Practice                                     :guide:

[[~/Wally/Reference/Guide/CMakePractice.pdf][CMakePractice.pdf]]

**** CMake简介

1. 特点:
   + 开放源代码
   + 跨平台, 生成native编译配置文件
     + Linux/Unix -> makefile
     + MacOX -> xcode
     + Windows -> MSVC
   + 能够管理大型项目, eg. KED4
   + 简化编译过程: cmake+make
   + 高效率
   + 可扩展

2. 问题
   + CMake简单,但不很简单
   + CMake本身就是编程

3. 建议

   + 无项目需求则无必要学习, CMake的学习过程就是实践的过程
   + 小工程则直接编写编写makefile
   + C/C++/Java外不要使用cmake
   + 仅仅使用qt编程, 没有必要使用cmake, qmake更优

**** helloworld
***** CMakeLists.txt
*CMakeLists.txt* 注意大小写.
#+BEGIN_EXAMPLE
PROJECT(HELLO)
SET(SRC main.c)
MESSAGE(STATUS "This is BINARY dir " ${HELLO_BINARY_DIR})
MESSAGE(STATUS "This is SOURCE dir" ${HELLO_SOURCE_DIR})
ADD_EXECUTABLE(hello  ${SRC_LIST})
#+END_EXAMPLE
1. PORJECT
   + 格式: PROJECT(projectname [CXX] [C] [Java])
   + 功能: 指定工程名称, 和工程支持的语言, 语言列表可选, 默认表示支持
     所有.
   + 说明:
     + 隐式定义了两个变量: *projectname_SOURCE_DIR* 和
       *projectname_BINARY_DIR*, 内部编译时, 指向工程目录
     + 预定义 *PROJECT_SOURCE_DIR* 和 *PROJECT_BINARY_DIR*, 分别与上述
       两个变量等价.
2. SET
   + 格式: SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])
3. MESSAGE
   + 格式: MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR], "message to
     display")
     + SEND_ERROR: 产生错误, 生成过程被跳过
     + STATUS: 输出前缀为"-"的信息
     + FATAL_ERROR: 立即终止所有cmake过程
4. ADD_EXECUTABLE
   定义生成的可执行文件名称, 及源文件列表.
   可执行文件名与工程名无关, eg. HELLO hello
5. 变量引用方式
   *${VAR}*

***** 编译
#+BEGIN_EXAMPLE
$ cmake .
$ make VERBOSE=1
#+END_EXAMPLE

***** 基本语法规则
1. 变量使用 ${} 引用, IF控制语句中可直接使用变量名
2. 指令(参数1 参数2 ...)
   + 参数使用括号括起
   + 参数之间使用 *空格 或 分号* 隔开
     eg. ADD_EXECUTABLE(hello main.c; func.c)
3. 指令是大小写无关的, 参数和变量是大小写相关的, *建议全部使用大写指
   令*
4. 文件名可以使用双引号括起, 也可以不用, 只有当文件名中包含空格时才必
   须使用双引号
   + e.g.  SET(SRC_LIST "fu nc.c")
5. 源文件后缀名可以省略, 当然最好不要偷懒.

***** 清理工程
跟经典的autotools系列工具一样: *make clean*

注: make distclean 用于清理构建过程中产生的中间文件, 但CMake不支持.

***** 内部构建 和 外部构建
+ 内部构建(in-source build)
+ 外部构建(out-of-source build): cmake强烈推荐

外部构建对原有工程没有任何影响, 所有动作全部都发生在编译目录中
#+BEGIN_EXAMPLE
$ mdir build
$ cd build
$ cmake ..
#+END_EXAMPLE
通过外部进行工程构建, PROJECT_SOURCE_DIR仍然指代工程目录,
PROJECT_BINARY_DIR指代编译目录build

**** 更好一点的helloworld
***** 没有最好, 只有更好
+ *src* 目录放置源代码
+ *doc* 目录放置工程文档
+ *COPYRIGHT* 和 *README* 文本文件
+ *runhello.sh* 脚本文件, 用以调用hello二进制
+ *bin* 目录放置目标文件
+ 安装文件:
  + 将hello二进制与runhello.sh安装至 */usr/bin*
  + 将doc目录的内容以及COPYRIGHT和READEM安装至
    */usr/share/doc/cmake/t2*

***** helloworld工程
1. 工程目录hello
   + CMakeLists.txt
     #+BEGIN_EXAMPLE
     ADD_SUBDIRECTORY(hello main.c)
     #+END_EXAMPLE
2. src
   + CMakeLists.txt
     #+BEGIN_EXAMPLE
     PORJECT(HELLO)
     ADD_SUBDIRECTORY(src bin)
     #+END_EXAMPLE
   + *ADD_SUBDIRECTORY*
     + 向工程中添加存放源文件的目录, 并指定中间二进制文件和目标二进制
       文件的存放位置
     + 格式: *ADD_SUBDIRECTORY(source_dir [binary_dir]
       [EXCLUDE_FROM_ALL])*
       + EXCLUDE_FROM_ALL的含义是将这个目录从编译过程
       + 省略binary_dir,则编译结果将存放到build/src目录下, 指定bin后,
         相当于编译时将src重命名为bin, 所有的 *中间结果和目标二进制*
         都将存放在bin中
   + SUBDIR
     SUBDIR(dir1 dir2 ...) 一次添加多个子目录, 但已不推荐使用
3. bin
   可以通过指定 *EXECUTABLE_OUTPUT_PATH* 和 *LIBRARY_OUTPUT_PATH* 来最
   终指定目标二进制的位置和共享库的位置(不包括编译生成的中间文件)
   #+BEGIN_EXAMPLE
     SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
     SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
   #+END_EXAMPLE
   *在哪里ADD_EXECUTABLE或ADD_LIBRARY, 如果需要改变目标文件存放目录,就
   在哪里加入上述定义*
4. 安装
   1) 安装方式:
      + 编译代码后使用make install安装
        + 默认安装到/usr/bin
        + 使用 *DESTDIR* 指定: make install DESTDIR=/tmp/test/bin
      + 打包时指定目录安装(Makefile), 稍微复杂的还要定义PREFIX
        #+BEGIN_EXAMPLE
          DESTDIR=
          PREFIX=/usr
          install:
                  mkdir -p $(DESTDIR)/$(PREFIX)/bin
                  install -m 755 hello $(DESTDIR)/$(PREFIX)/bin
        #+END_EXAMPLE
   2) cmake
      + INSTALL指令
        *INSTALL* 指令用于定义安装规则, 安装的内容可以包括目标二进制,
        动态库, 静态库, 目录, 脚本等.
      + 变量 CMAKE_INSTALL_PREFIX
      + cmake -DCMAKE_INSTALL_PREFIX=/usr
   3) INSTALL 目标文件
      格式:
      #+BEGIN_EXAMPLE
        INSTALL(TARGET targets ...
                [[ARCHIVE | LIBRARY | RUNTIME]
                          [DESTINATION <dir>]
                          [PREMISSIONS premissions...]
                          [CONFIGURATIONS [Debug | Release ...]]
                          [COMPONENT <component>]
                          [OPTIONAL]
                          ] [...])
      #+END_EXAMPLE
      + 目标类型:
        + ARCHIVE: 特指静态库
        + LIBRATY: 动态库
        + RUNTIME: 可执行目标二进制文件
      + DESTINATION: 定义安装路径
        + 以"/"开头, 表绝对路径, CMAKE_INSTALL_PREFIX无效
        + 否则表相对路径, 此时安装路径为:
          ${CMAKE_INSTALL_PREFIX}/<DESTINATION>

      #+BEGIN_EXAMPLE
      INSTALL(TARGETS myrun mylib mystaticlib
      RUNTIME DESTINATION bin
      LIBRARY DESTINATION lib
      ARCHIVE DESTINATION libstatic)
      #+END_EXAMPLE

      注: 不需要关心TARGETS具体生成的路径, 只要写上TARGETS的名称就可以
      了.
   4) INSTALL 普通文件
      + 格式:
         #+BEGIN_EXAMPLE
           INSTALL(FILES files... DESTINATION <dir>
                   [PREMISSION premission ...]
                   [CONFIGURATIONS [Debug|Release|...]]
                   [COMPONENT <component>]
                   [RENAME <name>] [OPTIONAL])
        #+END_EXAMPLE

      + 功能: 安装一般文件, 并可指定访问权限, 文件名是此指令所在路径下
        的相对路径. 默认权限为: OWNER_WRITE, OWNER_READ, GROUP_READ,
        和WORLD_READ, 即644.
   5) 非目标文件的可执行程序安装(脚本等)
      + 格式:
        #+BEGIN_EXAMPLE
           INSTALL(PROGRAMS files... DESTINATION <dir>
                   [PREMISSION premission ...]
                   [CONFIGURATIONS [Debug|Release|...]]
                   [COMPONENT <component>]
                   [RENAME <name>] [OPTIONAL])
        #+END_EXAMPLE
        和FIFLES使用方法一样, 权限不同, 为755
   6) 目录的安装
      #+BEGIN_EXAMPLE
        INSTALL(DIRECTORY dirs... DESTINATION <dir>
                [FILE_PREMISSIONS premissions...]
                [DIRECTORY_PREMISSIONS permissions...]
                [USE_SOURCE_PREMISSIONS]
                [CONFIGURATIONS [Debug|Release|...]]
                [COMPONENT <component>]
                [[PATTERN <pattern> | REGEX <regex>]
                 [EXCLUDE] [PREMISSIONS <permissions...]]
                [...])
      #+END_EXAMPLE
      + DIRECTORY后面连接的是所有Source目录的相对路径, abc/ 和 abc 有
        很大区别
      + PATTERN 表示使用正则表达式过滤
      + PREMISSIONS 表示过滤后的文件权限
   7) 安装脚本
      #+BEGIN_EXAMPLE
        INSTALL([SCRIPT <file>] [CODE <code>] [...])
      #+END_EXAMPLE
      + SCRIPT 用于安装时调用cmake脚本文件, abc.cmake
      + INSTALL 用于执行CMake指令, 必须使用双引号括起来
        eg.
        #+BEGIN_EXAMPLE
          INSTALL(CODE "MESSAGE(\\"Sample install message\")")
        #+END_EXAMPLE
5. helloworld
   1) doc/hello.txt
      + 方式1: 在doc目录下建立CMakeLists.txt,并通过ADD_SUBDIRECTORY加
        入到工程中

      + 方式2: 在工程目录的CMakeLists.txt完成
        #+BEGIN_EXAMPLE
          INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake/t2)
        #+END_EXAMPLE
   2) runhello.sh
      #+BEGIN_EXAMPLE
        # 在工程目录的CMakeLists.txt
        INSATLL(PROGRAMS runhello.sh DESTINATION bin)
      #+END_EXAMPLE
   3) COPYRIGHT 和 README
      #+BEGIN_EXAMPLE
        # 在工程目录的CMakeLists.txt
        INSTALL(FIFES COPYRIGHT README DESTINATION share/doc/cmake/t2)
      #+END_EXAMPLE
   4) 安装
      #+BEGIN_EXAMPLE
        $ cmake -DCMAKE_INSTALL_PREFIX=/tmp/t2/usr ..
        $ make
        $ make install
      #+END_EXAMPLE
6. CMAKE_INSTALL_PREFIX 的默认定义为 */usr/local*
**** 静态库和动态链接库
***** 建立共享库
1. 工程CMakeLists.txt
   #+BEGIN_EXAMPLE
     PROJECT(HELLOLIB)
     ADD_SUBDIRECTORY(lib)
   #+END_EXAMPLE
2. lib CMakeLists.txt
   --lib
     \ -- hello.c
     \ -- hello.h
     \ -- CMakeLists.txt
   #+BEGIN_EXAMPLE
     SET(LIBHELLO_SRC hello.c)
     ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
   #+END_EXAMPLE
3. *SET(LIBRARY_OUTPUT_PATH <path>)* 指定链接库位置
4. 生成的库自动添加前缀 *lib* 和 相应后缀, eg. hello -> libhello.so
***** *ADD_LIBRARY*
+ 格式
  #+BEGIN_EXAMPLE
    ADD_LIBRARY(libname [SHARED | STATIC | MODULE]
                [EXCLUDE_FROM_ALL]
                source1 source2 ...)
  #+END_EXAMPLE
+ 类型:
  + SHARED: 动态库, 后缀 *.so*
  + STATIC: 静态库, 后缀 *.a*
  + MODELE: 在使用dyld的系统中有效, 如果不支持dyld, 则被当作SHARED对待.
***** 静态库
1. 静态链接库和动态链接库的名称应该是一致的, 只不过后缀名是 *.a* 罢了.
2. lib CMakeLists.txt
   #+BEGIN_EXAMPLE
     SET(LIBHELLO_SRC hello.c)
     SET(LIBRARY_OUTPUT_PATH .)
     ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
     ADD_LIBRARY(hello STATIC ${LIBHELLO_SRC})
   #+END_EXAMPLE
   注: target名称是唯一的, 生成同名的静态库的动态库不能通过ADD_LIBRARY
   实现.
3. SET_TARGET_PROPERTIES
   + 语法
     #+BEGIN_EXAMPLE
       SET_TARGET_PROPERTIES(target1 targets ...
                             PROPERTIES prop1 value1
                                        prop2 value2)
     #+END_EXAMPLE
   + 该指令可以用于设置输出的名称, 对于动态库, 还可以 指定其动态库版本
     和API版本.
   + CMakeLists.txt
     #+BEGIN_EXAMPLE
       SET(LIBHELLO_SRC hello.c)
       SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
       ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
       ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})
       SET_TARGET_PROPERTY(hello_static PROPERTIES OUTPUT_NAME "hello")
     #+END_EXAMPLE
4. GET_TARGET_PROPERTY
   + 格式: GET_TARGET_PROPERTY(VAR target property)
   + e.g.
     #+BEGIN_EXAMPLE
       GET_TARGET_PROPERTY(OUTPUT_VALUE hello_static OUTPUT_NAME)
       MESSAGE(STATUS "This is the hello_static OUTPUT_NAME:"${OUTPUT_VALUE})
     #+END_EXAMPLE
     注: *warning* Argument not separated from preceding token by
     whitespace.
***** 动态库版本号
按照规则, 动态库是应该包含一个版本号的.
#+BEGIN_EXAMPLE
  libhello.so.1.2
  libhello.so -> libhello.so.1
  libhello.so.1 -> libhello.so.1.2
#+END_EXAMPLE
注: 此处 *->* 表文件link
#+BEGIN_EXAMPLE
  SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)
#+END_EXAMPLE
+ VERSION: 指代动态库版本号
+ SOVERSION: 指代API版本
***** 安装共享库和头文件
我们需要将 *.a, .so.x, 以及头文件* 安装到系统目录中, 才能真正让别人开
发使用
+ hello.a hello.so.1.2 -> <prefix>/lib/
+ hello.h -> <prefix>/include/hello

#+BEGIN_EXAMPLE
  INSTALL(TARGETS hello hello_static
          LIBRARY DESTINATION lib
          ARCHIVE DESTINATION lib)
  INSTALL(FILES hello.h
          DESTINATION include/hello)
#+END_EXAMPLE
**** 如何使用外部共享库和头文件
***** 引入头文件搜索路径
+ make错误: /fatal error: hello.h: 没有那个文件或目录/
+ 命令: *INCLUDE_DIRECTORIES*
+ 语法:
  #+BEGIN_EXAMPLE
    INCLUDE_DERECTORIES([AFTER|BEFORE] [SYSTEM]
                        dir1 dir2 ....         )
  #+END_EXAMPLE
+ 路径中包含空格时需要使用双引号括起来
+ 默认追加到当前的头文件搜索路径的后面
  + CMAKE_INCLUDE_DIRECTORIES_BEFORE 设为 on 时, 追加到前
  + 使用 AFTER | BEFORE 参数改变行为
***** 为target添加共享库
+ make错误: /对‘HelloFunc’未定义的引用/
+ 命令: *LINK_DIRECTORIES* & *TARGET_LINK_LIBRARIES*
+ 语法:
  + LINK_DIRECTORIES(dir1 dir2 ...)
    添加非标准的共享库的搜索路径.
  + TARGET_LINK_LIBRARIES
    #+BEGIN_EXAMPLE
      TARGET_LINK_LIBRARIES(target library1
                            <debug | optimized> library2
                            ...)
    #+END_EXAMPLE
    为target(可执行文件或共享库等)
+ 链接到动态库
  #+BEGIN_EXAMPLE
    TARGET_LINK_LIBRARIES(main hello)
    # OR
    TARGET_LINK_LIBRARIES(main libhello.so)
  #+END_EXAMPLE

  查看链接: *$ ldd src/main*
  #+BEGIN_EXAMPLE
    linux-gate.so.1 =>  (0xb77d3000)
    libhello.so.1 => /usr/lib/libhello.so.1 (0xb779f000)
    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb75f1000)
    /lib/ld-linux.so.2 (0xb77d4000)
  #+END_EXAMPLE

+ 链接到静态库
  #+BEGIN_EXAMPLE
    TARGET_LINK_LIBRARIES(main libhello.a)
  #+END_EXAMPLE
  查看链接: *$ ldd src/main*
  #+BEGIN_EXAMPLE
    linux-gate.so.1 =>  (0xb7711000)
    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7532000)
    /lib/ld-linux.so.2 (0xb7712000)
  #+END_EXAMPLE

***** 特殊的环境变量 *CMAKE_INCLUDE_PATH* 和 *CMAKE_LIBRARY_PATH*
这两个 *是环境变量, 而不是cmake变量*, 使用方法是在bash中使用export设置.
1. 智能版的 INCLUDE_DIRECTORIES
   #+BEGIN_EXAMPLE
     $ export CMAKE_INCLUDE_PATH=/usr/include/hello
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     FIND_PATH(myHeader hello.h)
     IF(myHeader)
     INCLUDE_DIRECTORIES(${myHeader})
     ENDIF(myHeader)
   #+END_EXAMPLE

2. FIND_PATH
   + 功能: 用来指定在路径中搜索文件名
   + 语法:
     #+BEGIN_EXAMPLE
       FIND_PATH(myHeader NAMES filename PATHS patsh)
     #+END_EXAMPLE

     省略路径则使用CMAKE_INCLUDE_PATH中定义的路径.

     注:如果不使用FIND_PAHT,CMAKE_INCLUDE_PATH变量的设置是没有作用的,
     它不会为编译器命令添加参数 -I <CMAKE_INCLUDE_PATH>的.
3. FIND_LIBARAY
   同样, CMAKE_LIBRARY_PATH可以用在FIND_LIBRARY.

   因为这些变量直接为FIND_w指令所使用, 所以其对所有使用FIND_指令的
   cmake的模块都有益.

**** 常用变量和常用环境变量
***** CMake变量引用
${}
***** CMake自定义变量
1. 隐式 eg. PROJECT隐式定义两个变量
2. 显式 *SET* 指令
***** CMake常用变量
1. CMAKE_BINARY_DIR, PROJECT_BINARY_DIR, <projectname>_BINARY_DIR
   + in-source: 工程顶层目录
   + out-of-source: 编译目录
2. CMAKE_SOURCE_DIR, PROJECT_SOURCE_DIR, <projectname>_SOURCE_DIR
   工程顶层目录
3. CMAKE_CURRENT_SOURCE_DIR 当前CMakeLists.txt所在目录
4. CMAKE_CURRENT_BINARY_DIR
   + in-source: CMAKE_CURRENT_SOURCE_DIR
   + out-of--source: target编译目录
   + 注: ADD_SUBDIRECTORY(src bin)可以改变该变量
   + 注:SET(EXECUTABLE_OUTPUT_PATH <path>)不会影响该变量
5. CMAKE_CURRENT_LIST_FILE  输出调用该变量的CMakeLists.txt的完整路径
6. CMAKE_CURRENT_LIST_LINE  输出调用该变量所在的行
7. CMAKE_MODULE_PATH  定义cmake模块所在路径
   + 杂的工程需要使用模块
   + SET定义
   + 使用INCLUDE指令调用．
8. EXECUTABLE_OUTPUT_PATH
9. LIBRARY_OUTPUT_PATH
10. PROJECT_NAME  返回PROJECT定义的名称

***** CMake调用环境变量　
1. 调用: *$ENV{}*
   eg.
   #+BEGIN_EXAMPLE
   MESSAGE(STATUS "HOME dir: $ENV(HOME)")
   #+END_EXAMPLE
2. 设置 *SET{ENV{变量名}　值}*
3. CMAKE_INCLUDE_CURRENT_DIR
   自动添加CMAKE_CURRENT_BINARY_DIR和CMAKE_CURRENT_SOURCR_DIR到当前处
   理的CMakeLists.txt
4. CMAKE_INCLUDE_DIRECTORY_PROJECT_BEFORE
   工程提供的头文件目录始终置于系统头文件之前
5. CMAKE_INCLUDE_PATH
6. CMAKE_LIBRARY_PATH

***** 系统信息
1. CMAKE_MAJOR_VERSION  主版本号， *2*.4.6
2. CMAKE_MINOR_VERSION  次版本号， 2. *4*.6
3. CMAKE_PATCH_VERSION  补丁等级， 2.4. *6*
4. CMAKE_SYSTEM  系统名称，如Linux-2.6.22
5. CMAKE_SYSTEM_NAME 不包含版本号
6. CMAKE_SYSTEM_VERSION 系统版本号
7. CMAKE_SYSTEM_PROCESSOR  处理器名称　eg. i686
8. UNIX 类UNIX平台下为TRUE,包括OS X和cygwin
9. WIN32 Win32平台下为TRUE，包括cygwin

***** 主要开关选项
1. CMAKE_ALLOW_LOOSE_CONSTRUCTS 控制IF ELSE书写方式
2. BUILD_SHARE_LIBS  控制默认的库编译方式，　默认为静态库
   eg
   #+BEGIN_EXAMPLE
   SET(BUILD_SHARED_LIBS on)
   #+END_EXAMPLE
3. CMAKE_C_FLAGS 设置C编译选项，也可以使用ADD_DEFINITIONS()添加
4. CMAKE_CXX_FLAGS  设置C++编译选项，也可以使用ADD_DEFINTIONS()添加．
**** CMake常用指令

*CMake即编程*

***** 基本指令
1. ADD_DEFINITIONS 向C/C++编译器添加-D定义
   eg.
   #+BEGIN_EXAMPLE
   ADD_DEFINITONS(-DENABLE_DEBUG -DABC)
   #+END_EXAMPLE
   参数之间使用空格分割.
   如果代码中定义了#ifdef ENABLE_DEBUG  #endif, 这块代码就会生效.

   其它编译器开关可以通过 *CMAKE_C_FLAGS* 和 *CMAKE_CXX_FLAGS* 变量设
   置.

2. ADD_DEPENDENCIES 定义target秘依赖的其它target, 确保编译本target之前,
   其它的target已经被构建.
   #+BEGIN_EXAMPLE
     ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...)
   #+END_EXAMPLE

3. ADD_EXECUTABLE, ADD_LIBRARY, ADD_SUBDIRECTORY

4. ADD_TEST & ENABLE_TESTING
   ENABLE_TESTING指令用来控制Makefile是否构建test目标, 语法简单不带任
   何参数, ENABLE_TESTING(), 一般放在工程的主CMakeLists.txt中.

   ADD_TEST(testname Exename arg1 arg2 ...)
   + testname 自定义的test名称
   + Exebane  可以是构建的目标文件名, 也可以是外部脚本等
   + arg是传递给可执行文件的参数
   + 没有ENABLE_TESTING指令, 任何ADD_TEST都是无效的
   + 生成Makefile后, 可以运行make test来执行测试
5. AUX_ADD_DIRECTORY(dir VARIBALE)
   发现一个目录下的所有的源文件并将列表存储在一个变量中

6. CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR])

7. EXEC_PROGRAM
   在CMakeLists.txt处理过程中执行命令, 并不会在生成的Makefile中执行.
   #+BEGIN_EXAMPLE
     EXEC_PROGRAM(Executable [dir in which to run]
                             [ARGS <arguments to executable]
                             [OUTPUT_VARIBLE <var>]
                             [RETURN_VALUE <var>])
   #+END_EXAMPLE

8. FILE 文件操作指令
   #+BEGIN_EXAMPLE
     FILE(WRITE filename "message to write"...)
     FILE(APPEND filename "messag to write"...)
     FILE(READ filename variable)
     FILE(GLOB variable [RELATIVE path] [globbing expressions]...)
     FILE(GLOB_RECURSE variable [RELATIVE path]
                       [globbing expressions]...)
     FILE(REMOVE [derectory])
     FILE(REMOVE_RECURSE [directory])
     FILE(MAKE_DIRECTORY [directory])
     FILE(RELATIVE_PATH variable directory file)
     FILE(TO_MAKE_PATH path result)
     FILE(TO_NATIVE_PAHT path result)
   #+END_EXAMPLE

9. INCLUDE
   用来载入CMakeLists.txt文件或预定义的cmake模块
   #+BEGIN_EXAMPLE
     INCLUDE(file [OPTIONAL])
     INCLUDE(module [OPTIONAL])
   #+END_EXAMPLE
   + OPTIONAL参数用来设置文件不存在也不会产生错误
   + 模块将在CMAKE_MODULE_PATH中搜索并载入
   + 载入的内容将在处理到INCLUDE语句时直接执行

***** INSTALL
***** FIND_指令
1. FIND_FILE(<VAR> name1 path1 path2 ...)
   VAR变量代表找到的文件全路径
2. FIND_LIBRARY(<VAR> name path1 path2 ...)
3. FIND_PATH(<VAR> name path1 path2 ...)
4. FIND_PROGRAM(<VAR> name path1 path2 ...)
5. FIND_PACKAGE
   #+BEGIN_EXAMPLE
     FIND_PACHAGE(<name> [major.minor] [QUIET] [NO_MODULE]
                         [[REQUIRED | COMPONENTS] [compenents...]])
   #+END_EXAMPLE

***** COMMENT 控制指令
1. IF
   #+BEGIN_EXAMPLE
     IF(expression)
         # THEN section
         COMMAND1(ARGS ...)
         COMMAND2(ARGS ...)
         ...
     ELSE(expression)
         # ELSE sectioono
         COMMAND1(ARGS ...)
         COMMAND2(ARGS ...)
         ...
     ENDIF(expression)
   #+END_EXAMPLE
   凡是出现IF的地方一定要对应有ENDIF, 出现ELSEIF的地方, ENDIF是可选的.

   + IF(var): 变量不是: 空, 0, N, NO, OFF, FALSE, NOTFOUND或
     <var>_NOTFOUND时, 表达式为真
   + IF(NOT var)
   + IF(var1 AND var2)
   + IF(var1 OR var2)
   + IF(COMMAND cmd), 当给定的cmd确实是命令且可以调用时为真
   + IF(EXISTS dir/file) 目录或文件存在时为真
   + IF(fileq1 IS_NEWER_THAN file2)
   + IF(ID_DIRECTORY dirname)
   + IF(variable MATCHES regex)
   + IF(string MATCHED regex)

   + IF(varible LESS number)
   + IF(string LESS number)
   + IF(variable GREATER number)
   + IF(string GREATER number)
   + IF(variable EQUAL number)
   + IF(string EQUAL number)

   + IF(var/str STRLESS/STRGREATER/STREQUAL string)

   + IF(DEFINED variable)

   #+BEGIN_EXAMPLE
     IF(WIN32)
         MESSAGE(STATUS "This is windows")
     ELSE(WIN32)     # 容易造成歧义
         MESSAGE(STATUS "This is not windows")
     END(IF)
   #+END_EXAMPLE

   使用开关: *CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS*
   #+BEGIN_EXAMPLE
     SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)

     IF(WIN32)
     ELSE()
     ENDIF()
   #+END_EXAMPLE

2. WHILE
   #+BEGIN_EXAMPLE
     WHILE(condition)
         COMMAND1(ARGS ...)
         COMMAND2(ARGS ...)
         ...
     ENDWHILE(condition)
   #+END_EXAMPLE

3. FOREACH
   1) 列表
      #+BEGIN_EXAMPLE
        FOREACH(loop_var arg1 arg2 ...)
            COMMAND1(ARGS ...)
            COMMAND2(ARGS ...)
            ....
        ENDFOREACH(loop_var)
      #+END_EXAMPLE
      eg.
      #+BEGIN_EXAMPLE
        AUX_SOURCE_DIRECTORY(. SRC_LIST)
        FOREACH(F ${SRC_LIST})
            MESSAGE(${F})
        ENDFOREACH(F)
      #+END_EXAMPLE

   2) 范围
      #+BEGIN_EXAMPLE
        FOREACH(loop_var RANGE total)
        ENDFOREACH(loop_var)
      #+END_EXAMPLE
      从0到total以1步进

   3) 范围和步进
      #+BEGIN_EXAMPLE
        FOREACH(loop_var RANGE start stop [step])
        ENDFOREACH(loop_var)
      #+END_EXAMPLE

   4) 该指令需要注意的是, 直到遇到了ENDFOREACH指令, 整个语句块才会被真
      正的执行.

**** 模块的使用和自定义模块

***** 使用CMake提供的FindCURL模块
对于系统预定义的Find<name>.cmake模块, 使用方法如下:
#+BEGIN_EXAMPLE
  FIND_PACKAGE(CURL)
  IF(CURL_FOUND)
      INCLUDE_DIRECTORIES(${CURL_INCLUDE_DIR})
      TARGET_LINK_LIBRARIES(curltest ${CURL_LIBRARY})
      MESSAGE(STATUS "the path to curl lib is"${CURL_INCLUDE_DIR})
  ELSE(CURL_FOUND)
      MESSAGE(FATAL_ERROR "CURL library not found")
  ENDIF(CURL_FOUND)
#+END_EXAMPLE

每一个模块都会定义以下几个变量:
+ <name>_FOUND: 判断模块是否被找到
+ <name>_INCLUDE_DIR / <name>_INCLUDES
+ <name>_LIBRARY / <name>_LIBRARIES

***** 自定义cmake模块
工程目录下cmake文件夹 t6/cmake/FindHELLO.cmake
#+BEGIN_EXAMPLE
  FIND_PATH(HELLO_INCLUDE_PATH hello.h /usr/include/hello /usr/local/include/hello)
  FIND_LIBRARY(HELLO_LIBRARY NAMES hello PATH /usr/lib /usr/local/lib)

  IF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY)
      SET(HELLO_FOUND TRUE)
  ENDIF(HELLO_INCLUDE_DIR AND hello_LIBRARY)

  IF(HELLO_FOUND)
      IF(NOT HELLO_FIND_QUIETLY)
          MESSAGE(STATUS "Found Hello: ${HELLO_LIBRARY})
      ENDIF(NOT HELLO_FIND_QUIETLY)
  ELSE(HELLO_FOUND)
      IF(HELLO_FIND_REQUIRED)
          MESSAGE(fatal_ERROR "Cound not find hello library)
      ENDIF(HELLO_FIND_REQUIRED)
  ENDIF(HELLO_FOUND)
#+END_EXAMPLE

工程主CMakeLists.txt
#+BEGIN_EXAMPLE
  SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
#+END_EXAMPLE
*** index                                                           :index:

*** CCMake                                                         :ccmake:
**** ccmake intro                                                  :intro:

- [[http://blog.csdn.net/arackethis/article/details/42155589][CMake 和 CCMake 的区别]]

CCMake is the GUI for manipulating files generated by / used by the
cmake system.

- ccmake is curses (terminal handling library) interface to CMake.

- cmake is the CLI (Command Line Interface)

** Make                                                               :make:
*** make -jn

多线程编译

用于多cpu的系统编译，n一般是cpu个数的2倍。
** Gcc                                                                 :gcc:
*** DONE [#B] gcc简介
DEADLINE: <2015-03-15 日>
- State "DONE"       from "START"      [2015-03-03 二 21:32]
- State "START"      from "TODO"       [2015-03-03 二 20:40]
- State "TODO"       from ""           [2015-03-01 日 12:30]
 Date:<2015-02-27 五>

**** 简介
GCC 的意思也只是 *GNU C Compiler* 而已。经过了这么多年的发展，GCC 已经不仅
仅能支持 C 语言；它现在还支持 Ada 语言、C++ 语言、Java 语言、Objective C
语言、Pascal 语言、COBOL语言，以及支持函数式编程和逻辑编程的 Mercury 语
言，等等。而 GCC 也不再单只是 GNU C 语言编译器的意思了，而是变成了
*GNU Compiler Collection* 也即是 GNU 编译器家族的意思了。另一方面，说
到 GCC 对于操作系统平台及硬件平台支持，概括起来就是一句话：无所不在。
**** 简单编译
#+BEGIN_EXAMPLE
  #include <stdio.h>
  int main(void)
  {
      printf("Hello World!\n");
      return 0;
  }
#+END_EXAMPLE

编译(一步到位): *$ gcc test.c -o test*

实质上，上述编译过程是分为四个阶段进行的，即
+ 预处理(也称预编译，Preprocessing)
+ 编译(Compilation)
+ 汇编 (Assembly)
+ 连接(Linking)

***** 预处理 -E
*$ gcc -E test.c -o test.i 或 gcc -E test.c*
#+BEGIN_EXAMPLE
  # 1 "test.c"
  # 1 "<command-line>"
  # 1 "/usr/include/stdc-predef.h" 1 3 4
  # 1 "<command-line>" 2
  # 1 "test.c"
  # 1 "/usr/include/stdio.h" 1 3 4
  # 27 "/usr/include/stdio.h" 3 4
  # 1 "/usr/include/features.h" 1 3 4
  # 374 "/usr/include/features.h" 3 4

  ...

  typedef unsigned char __u_char;
  typedef unsigned short int __u_short;
  typedef unsigned int __u_int;
  typedef unsigned long int __u_long;

  ...

  int main(void)
  {
      printf("Hello World!\n");
      return 0;
  }
#+END_EXAMPLE
+ test.i是test.c经过预处理之后的代码, 本列中预处理的结果是把stdio.h文
  件中的内容插入到test.c中.
+ gcc的 *-E* 选项，可以让编译器在预处理后停止，并输出预处理结果。

***** 编译为汇编代码(Compile) -S
*$ gcc -S test.i -o test.s*

+ 预处理之后，可直接对生成的test.i文件编译，生成汇编代码
+ gcc的-S选项，表示在程序编译期间，在生成汇编代码后，停止，-o输出汇编
  代码文件。

***** 汇编(Assembly) -c
*gas汇编器负责将汇编代码编译为目标文件*

*$ gcc -c test.s -o test.o*
***** 连接(Linking)
*$ gcc test.o -o test*

*gcc连接器* 是gas提供的，负责:
+ *将程序的目标文件与所需的所有附加的目标文件连接起来*
+ *最终生成可执行文件*
+ 附加的目标文件包括
  - *静态连接库*
  - *动态连接库*

**** 编译多个文件
通常整个程序是由多个源文件组成的，相应地也就形成了多个编译单元，使用GCC
能够很好地管理这些编译单元。假设有一个由test1.c和 test2.c两个源文件组成
的程序，为了对它们进行编译，并最终生成可执行程序test，可以使用下面这条命
令：

*$ gcc test1.c test2.c -o test*

如果同时处理的文件不止一个，GCC仍然会按照预处理、编译和链接的过程依次进
行。如果深究起来，上面这条命令大致相当于依次执行如下三条命令：

gcc -c test1.c -o test1.o
gcc -c test2.c -o test2.o
gcc test1.o test2.o -o test

**** 检错
***** -pedantic
*$ gcc -pedantic illcode.c -o illcode*

-pedantic编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅
只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，-pedantic选项能
够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有
ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提
出警告。

除了-pedantic之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些
选项大多以-W开头，其中最有价值的当数-Wall了，使用它能够使GCC产生尽可能多
的警告信息。
***** -Wall
*$ gcc -Wall illcode.c -o illcode*

+ *GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误
  的栖身之所。*
+ *一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持
  标准、健壮的特性。*
+ *所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！*

***** -Werror
*$ gcc -Werror test.c -o test*

在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停.

**** 库文件连接
开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助
许多函数库的支持才能够完成相应的功能。

从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、
dll）的集合。

Linux下的大多数函数都
+ 默认将头文件放到/usr/include/目录下，
+ 库文件则放到/usr/lib/目录下；
+ Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以
  及系统文件夹下。

但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的
办法来查找所需要的头文件和库文件。

例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官
网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面
包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件
libmysqlclient.so

其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/
mysql/lib

***** 编译成可执行文件
首先我们要进行编译test.c为目标文件，这个时候需要执行

*$ gcc –c –I /usr/dev/mysql/include test.c –o test.o*

***** 链接
最后我们把所有目标文件链接成可执行文件:

*$ gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test*

Linux下的库文件分为两大类分别是
+ 动态链接库（通常以.so结尾）
+ 静态链接库（通常以.a结尾）
+ 二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译
  时静态加载的。

***** 强制链接时使用静态链接库 -static
默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考
虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态
链接库。

在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和
libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:

*$ gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test*

***** 静态库链接时搜索路径顺序：
1. ld会去找GCC命令中的参数-L
2. 再找gcc的环境变量LIBRARY_PATH
3. 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程
   序内的

***** 动态链接时、执行时搜索路径顺序:
1. 编译目标代码时指定的动态库搜索路径
2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径
3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径
4. 默认的动态库搜索路径/lib
5. 默认的动态库搜索路径/usr/lib

***** 有关环境变量：
+ *LIBRARY_PATH*: 指定程序静态链接库文件搜索路径
+ *LD_LIBRARY_PATH*: 指定程序动态链接库文件搜索路径
*** DONE [#B] gcc头文件
DEADLINE: <2015-03-15 日>
- State "DONE"       from "TODO"       [2015-03-04 三 01:09]
- State "TODO"       from ""           [2015-03-01 日 12:31]
 Date:<2015-02-27 五>

参考:
+ http://blog.sina.com.cn/s/blog_6f4e385c0101ksu0.html

gcc寻找头文件的路径(按照1->2->3的顺序)

1. 在gcc编译源文件的时候，通过参数-I指定头文件的搜索路径
   + 如果指定路径有多个路径时，则按照指定路径的顺序搜索头文件。
   + 命令形式如：“gcc -I  /path/where/theheadfile/in sourcefile.c“
   + 这里源文件的路径可以是绝对路径，也可以是相对路径
2. 通过查找gcc的环境变
   量 *C_INCLUDE_PATH*,  *CPLUS_INCLUDE_PATH*, *OBJC_INCLUDE_PATH* 来
   搜索头文件位置。
3. 再找内定目录搜索，分别是
   + /usr/include
   + /usr/local/include
   + /usr/lib/gcc-lib/i386-linux/2.95.2/include

   最后一行是gcc程序的库文件地址，各个用户的系统上可能不一样。

gcc还有一个参数： *-nostdinc*,它使编译器不再系统缺省的头文件目录里面找
头文件，一般和-I联合使用，明确限定头文件的位置。
在编译驱动模块时，由于非凡的需求必须强制GCC不搜索系统默认路径，也就是
不搜索/usr/include要用参数-nostdinc，还要自己用-I参数来指定内核头文件
路径，这个时候必须在Makefile中指定。
*** g++ C98? C11
*-std=c++11 or -std=gnu++11*
*** [[http://blog.chinaunix.net/uid-21411227-id-1826747.html][gcc及其选项详解]] :blog:

*1.简介：*

gcc是gnu旗舰产品,目前基本上就是和unix捆绑在一起分发的。这个东西功能强大,但是有多达上千个选项,其用户手册也有将近一万行.虽然其中的多数选项平时很少用到.但是不管装软件还是写程序,往往都会用到gcc.下面我就gcc最最常用的几个选项做一个简要的说明,如果你想对gcc有一个全面的了解,比如你想知道在其他非x86平台上gcc是如何工作的话,你可以用命令：man
gcc;

gcc  [-c|-S|-E] [-std=standard]

  [-g] [-pg] [-Olevel]

  [-Wwarn...] [-pedantic]

  [-Idir...] [-Ldir...]

  [-Dmacro[=defn]...] [-Umacro]

  [-foption...] [-mmachine-option...]

  [-o outfile] infile...

-c  编译为目标文件，不连接库

-S  编译为汇编代码

-E   预处理.预处理之后的代码将送往标准输出

-Wwarn... 设置警告,可以设置的警告开关很多,通常用-Wall开启所有的警告

-Olevel  设置优化级别,level可以是0,1,2,3或者s,默认-O0,即不进行优化。.

-Dname=definition...
在命令行上定义宏,有两种方式,-Dname或者-Dname=definition.在命令行上设置宏定义的目的主要是为了在调试的时候设定一些开关,
而在发布的时候再关闭或者打开这些开关即可,当然宏定义也用来对代码进行有选择地编译.另外也还有其他的一些作用.

-Uname  取消宏定义name,作用和上面的正好相反.

-Idir...
把dir加到头文件的搜索路径中,而且gcc会在搜索标准头文件之前先搜索dir.

-llibrary
在连接的时候搜索library库，库是一些archieve文件--其成员是目标文件.如果有文件引用library,library在命令行的位置应该在那个文件之后,因此,*越底层的库越要放在后面.*比如如果你要连接pcap库,那么你就需要使用-lpcap对源文件进行编译.

-Ldir...
把dir加到库文件的搜索路径中,而且gcc会在搜索标准库文件之前先搜索dir.

-pthread
通过pthreads库加入对多线程的支持,这为预处理和连接设置了标志.pthread是POSIX指定的标准线程库.

-std=standard
设置采用的标准,该选项是针对C语言的,比如-std=c99表示编译器遵循C99标准.该选项较少使用.而且有时反而会把你搞糊涂.

-o outfile  指定输出文件的文件名,默认为a.out

-mmachine-option...  指定所用的平台.



---------------------------------------------------------------------------------------

*2.gcc常用选项总结* **

*2.1* *常规选项* **

1、没有任何选项：gcc  helloworld.c

结果会在与helloworld.c相同的目录下产生一个a.out的可执行文件。

*2、-o选项，指定输出文件名：*gcc -o helloworld helloworld.c

-o意思是Output即需要指定输出的可执行文件的名称。这里的名称为helloworld。

*3、-c选项，只编译，不汇编连接：*gcc -c helloworld.c

-c意思就是Compile，产生一个叫helloworld.o的目标文件

4、-S选项，产生汇编源文件：gcc -S helloworld.c

-S意思就是aSsemble，产生一个叫helloworld.s的汇编源文件

5、-E选项，预处理C源文件：gcc -E helloworld.c

-E意思就是prEprocess。输出不是送到一个文件而是标准输出。当然可以对它进行重定向：

gcc -E helloworld.c > helloworld.txt

*2.2* *优化选项* **

1) -O选项，基本优化：gcc -O helloworld.c

-O意思就是Optimize，产生一个经过优化的叫作a.out的可执行文件。也可以同时使用-o选项，以指定输出文件名。如：

gcc -O -o test helloworld.c

即会产生一个叫test的经过优化的可执行文件。

2) -O2选项，最大优化：gcc -O2 helloworld.c

产生一个经过最大优化的叫作a.out的可执行文件。

*2.3* *调试选项* **

*1) -g选项，产生供gdb调试用的可执行文件：gcc -g helloworld.c*

产生一个叫作a.out的可执行文件，大小明显比只用-o选项编译汇编连接后的文件大。

2) -pg选项，产生供gprof剖析用的可执行文件：gcc -pg helloworld.c

产生一个叫作a.out的执行文件，大小明显比用-g选项后产生的文件还大。

------------------------------------------------------------------------------------

*3. Gcc的错误类型及对策* **

 Gcc编译器如果发现源程序中有错误，就无法继续进行，也无法生成最终的可执行文件。为了便于修改，gcc给出错误资讯，我们必须对这些错误资讯逐个进行分析、处理，并修改相应的语言，才能保证源代码的正确编译连接。gcc给出的错误资讯一般可以分为四大类，下面我们分别讨论其产生的原因和对策。

*第一类∶C语法错误* **

*错误资讯∶文件source.c中第n行有语法错误(syntex
errror)。*这种类型的错误，一般都是C语言的语法错误，应该仔细检查源代码文件中第n行及该行之前的程序，有时也需要对该文件所包含的头文件进行检查。有些情况下，一个很简单的语法错误，gcc会给出一大堆错误，我们最主要的是要保持清醒的头脑，不要被其吓倒，必要的时候再参考一下C语言的基本教材。

*第二类∶头文件错误* **

错误资讯∶找不到头文件head.h(Can not find include file
head.h)。这类错误是源代码文件中的包含头文件有问题，可能的原因有头文件名错误、指定的头文件所在目录名错误等，也可能是错误地使用了双引号和尖括号。

*第三类∶档案库错误* **

错误资讯∶连接程序找不到所需的函数库，例如∶

ld: -lm: No such file or directory

这类错误是与目标文件相连接的函数库有错误，可能的原因是函数库名错误、指定的函数库所在目录名称错误等，检查的方法是使用find命令在可能的目录中寻找相应的函数库名，确定档案库及目录的名称并修改程序中及编译选项中的名称。

*第四类∶未定义符号* **

错误资讯∶有未定义的符号(Undefined
symbol)。这类错误是在连接过程中出现的，可能有两种原因∶*一是*使用者自己定义的函数或者全局变量所在源代码文件，没有被编译、连接，或者干脆还没有定义，这需要使用者根据实际情况修改源程序，给出全局变量或者函数的定义体；*二是*未定义的符号是一个标准的库函数，在源程序中使用了该库函数，而连接过程中还没有给定相应的函数库的名称，或者是该档案库的目录名称有问题，这时需要使用档案库维护命令ar检查我们需要的库函数到底位于哪一个函数库中，确定之后，修改gcc连接选项中的-l和-L项。

排除编译、连接过程中的错误，应该说这只是程序设计中最简单、最基本的一个步骤，可以说只是开了个头。这个过程中的错误，只是我们在使用C语言描述一个算法中所产生的错误，是比较容易排除的。我们写一个程序，到编译、连接通过为止，应该说刚刚开始，程序在运行过程中所出现的问题，是算法设计有问题，说得更玄点是对问题的认识和理解不够，还需要更加深入地测试、调试和修改。一个程序，稍为复杂的程序，往往要经过多次的编译、连接和测试、修改。

** Gdb                                                                 :gdb:
*** GDB入门
+ /home/ben/Document/C++/GDB教程详解.pdf

**** 使用GDB
1. 功能
   GDB是GNU开源项目组织发布的一个强大的UNIX下的程序调试工具。
   + 启动程序，并按照自定义的要求随心所欲地运行程序
   + 设置断点
   + 查看程序状态
   + 动态改变程序的执行环境

2. GDB VS 图形界面工具(VC, BCB): 寸有所长，尺有所短

3. 基本命令
   + b, break  --- 设置断点
     + b Line
     + b Func
   + info break --- 查看断点编号
   + r, run --- 从开始处运行程序
   + c, continue --- 继续运行程序
   + n, next --- 下一条语句
   + p Var --- 打印变量
   + bt  --- 查看函数堆栈
   + finish --- 退出函数
   + q --- 退出gdb
   + 支持TAB键补全

4. 使用GDB
   1. 编译时添加调试信息
      + gcc -g hello.c
      + g++ -g hello.cpp
      + 如果没有选项-g， 调试时将看不见函数名、变量名等，取而代之的是
        运行时的内在地址
   2. 启动gdb
      + gdb <program>
      + gdb <program> core(???) : 同时调试一个运行程序和core文件
      + gdb <program> <PID> : 指定程序的进程ID
      + program应该在PATH环境变量中搜索得到。
   3. 开头选项
      + -symbols, -s <file> : 从文件中读取符号表
      + -se file : 从指定文件中读取符号表信息，并用在可执行程序中
      + -core, -c <file> : 调试时core dump的文件
      + -d <directory> : 增加一个源文件的搜索路径， 默认路径为PATH所定
        义的路径
      + -help : 查看帮助
**** GDB中运行UNIX的shell命令
1. shell <command>
   + 默认使用 /bin/sh
   + 在Windows中使用Command.exe或cmd.exe
2. make <make-args>
   + 重新build程序
   + 等价于: shell make <make-args>
**** 在GDB中运行程序
1. 查看源文件
   + 启动GDB后，GDB会在PATH路径和当前目录下搜索<program>的源文件
   + 使用l或list命令查看源代码，以确认GDB是否读到源文件
2. 运行程序
   1) 设置运行参数
      + set args ARGS ...
      + show args
   2) 运行路径
      + path <dir>
      + show paths
      + set environment var[=value]
      + show environment [var]
   3) 工作目录
      + cd <dir>
      + pwd
   4) 程序的输入输出
      + info terminal  # 显示终端模式
      + run > outfile  # 重定向
      + tty /dev/ttyb  # 指定输入输出的终设备

**** 调试已运行的程序
1. 方式1
   1) ps  # 查看程序PID
   2) gdb <program> PID  # 挂接正在运行的程序
2. 方式2
   1) gdb <program>  # 关联源代码
   2) attach PID  # 挂接进程
   3) detach PID  # 取消挂接的进程
**** 暂停/恢复程序运行
***** 暂停方式
+ 断点(BreakPoint)
+ 观察点(WatchPoint)
+ 捕捉点(CatchPoint)
+ 信号(Signal)
+ 线程停止(Thread Stops)
***** 设置断点
1. break <function>
2. break <linenum>
3. break +offset
4. break -offset
5. break filename:function
6. break *address  # 在程序运行和内在地址处
7. break   # 没有参数表示在下一条指令处
8. break if <condition>  # 条件成立时停住
***** 查看断点
+ info breakpoints [n]
+ info break [n]
***** 设置捕捉点(CatchPoint)
设置捕捉点来捕捉程序运行时的一些事件。如：载入共享库或是C++异常

catch <event>
+ throw : C++抛出的异常
+ catch : C++捕捉的异常
+ exec : 调用系统调用exec
+ fork : 调用系统调用fork
+ vfork : 调用系统调用vfork
+ load <libname> : 载入共享库时
+ unload <libname> : 卸载共享库时

tcatch <even>  # 只设置一次捕捉点， 当程序停住后，捕捉点被自动删除
***** 维护停止点
+ clear
+ clear <function>
+ clear <filename:function>
+ clear <linenum>
+ clear <filename:linenum>
+ delete [breakpoints] [range] # 不指定断点号则删除全部， 简写为d
+ disable [breakpoints] [range]  # dis
+ enable [breakpoints] [range]
+ enable [breakpoints] once range  # 停止一次后disable
+ enable [breakpoints] delete range  # 停止一次后删除
***** 停止条件维护
+ break和watch支持if, catch不支持if
+ condition <bnum> <expression>  # 修改断点号的停止条件
+ condition <bnum>  # 清除断点号的停止条件
+ igore <bnum>  <count>  # 忽略停止条件指定次数
***** 为停止点设置运行命令
+ 行自动化调试
+ 格式：
  #+BEGIN_EXAMPLE
    commands [bnum]
    ...command-list...
    end
  #+END_EXAMPLE
+ 例程
  #+BEGIN_EXAMPLE
    break foo if x>0
    comomands
    prinft "x if %d\n", x  # 打印变量值
    continue  # 继续运行程序
    end
  #+END_EXAMPLE
***** 断点菜单
在 C++ 中，可能会重复出现同一个名字的函数若干次（函数重载），在这种情
况下， break<function> 不能告诉 GDB 要停在哪个函数的入口。当然，你可以
使用 break <function(type)> 也就是把函数的参数类型告诉 GDB ，以指定一
个函数。否则的话， GDB 会给你列出一个断点菜单供你选择你所需要的断点。
你只要输入你菜单列表中的编号就可以了
#+BEGIN_EXAMPLE
  (gdb)b String::after
  [0] cancel
  [1] all
  [2] file:String.cc; line number:867
  [3] file:String.cc; line number:860
  [4] file:String.cc; line number:875
  [5] file:String.cc; line number:853
  [6] file:String.cc; line number:846
  [7] file:String.cc; line number:735
  > 2 4 6
  Breakpoint 1 at 0xb26c: file String.cc, line 867.
  Breakpoint 2 at 0xb344: file String.cc, line 875.
  Breakpoint 3 at 0xafcc: file String.cc, line 846.
  Multiple breakpoints were set.
  Use the "delete" command to delete unwanted
   breakpoints.
  (gdb)
#+END_EXAMPLE
***** 恢复运行和单步调试
1. 恢复运行
   + continue [ignore-count]
   + c [ignore-count]
   + gf [ignore-count]
2. 单步踊跃
   + step <count>  # 存在函数调用时进入函数
   + next <count>
   + set step-mode
   + set step-mode on
   + set step-mode off
3. 其它
   + finish  # 运行程序，直到当前函数返回
   + until, u  # 运行程序直到退出循环体
   + stepi, si  # *单步跟踪一条机器指令*
   + nexti, ni
   + display/i $pc  # 单步跟踪后打印程序代码和汇编代码
***** TODO 信号
**** TODO 查看源程序
- State "TODO"       from ""           [2015-04-20 一 19:24]
**** TODO 查看运行时数据
**** TODO 改变程序的执行
**** TODO 在不同语言中使用GDB
*** GDB常用命令                                                       :gdb:
**** 启动/退出

+ gdb [FILE] 或xxx-xxxx-xxxx-xxxx-gdb [FILE]：x表示前缀字符，启动gdb，调试FILE(也可以先不指定文件)。

+ quit 退出gdb。

**** 连接操作

+ target remote ip:port ：远程连接，ip表示主机IP地址或主机名(如localhost)，port表示端口号，即配置脚本中gdb_port指定端口号。

**** 文件操作

+ *file* <FILE> ：载入文件FILE，注意：不会下载到目标板上。
+ *load* [FILE] ：把文件下载到目标板上，如果不指定FILE，则下载之前指定过的(比如file 命令指定的，或是gdb 运行时指定的文件)。

**** 查看源程序

+ *list <FUNCTION>* ： 列出某个函数FUNCTION。
+ *list <LINENUM>* ：以当前源文件的某行LINENUM为中间显示一段源程序。
+ *list*  接着前一次继续显示。
+ *break *<address>* ：在某个地址上设置断点，比如 break *0x84。
+ *list -* ：显示前一次之前的源程序。
+ *list <FILENAME:FUNCTION>或list <FILENAME:LINENUM>* ：显示指定文件的一段程序。
+ *info source* ： 查看当前源程序。
+ *info stack* ：查看堆栈信息。
+ *info args* ： 查看当前的参数。

**** 断点操作

+ *break <FUNCTION>* ：在函数入口设置断点。
+ *break <LINENUM>* ：在当前源文件的某一行上设置断点。
+ *break <FILENAME:LINENUM>* ：在指定源文件的某一行上设置断点。
+ *info br* ：查看断点。
+ *delete <number>* ： 删除断点。
+ *diable <number>* ： 禁止断点。
+ *enable <number>* ：使能断点。

**** 监视点(watch)操作

+ *watch <EXPRESSION>* ：当指定变量被写时，程序被停止。
+ *rwatch <EXPRESSION>* ：当指定变量被读时，程序被停止。

**** 数据操作

+ *print < EXPRESSION >* ：查看数据。
+ *set varible=value* ：设置变量。
+ *x /NFU ADDR* ： 检查内存值。
  - *N* 代表重复数
  - *F* 代表输出格式
    + *x* ：16 进制整数格式
    + *d* ：有符号十进制整数格式
    + *u* ：无符号十进制整数格式
    + *f* ：浮点数格式
  - *U* 代表输出格式* ：
    + *b* ：字节(byte)
    + *h* ：双字节数值
    + *w* ：四字节数值
    + *g* ：八字节数值

  比如“x /4ub 0x0”将会显示0 地址开始到4 个字节。

**** 执行程序

+ *step* ：单步执行，会跟踪进入一个函数。
+ *next* ：单步执行，指令则不会进入函数。
+ *nexti* ：单步执行，执行一条汇编指令。
+ *continue* 继续执行程序，加载程序后也可以用来启动程序

**** 帮助

+ *help [command]* ：列出帮助信息，或是列出某个命令的帮助信息。

**** 其他命令

+ *monitor <command …>* ：调用gdb 服务器软件的命令，比如：“monitor mdw 0x0”就是调用openocd 本身的命令“mdw 0x0”。

*** [[http://blog.chinaunix.net/uid-9525959-id-2001805.html][gdb基本命令总结]]                                                  :blog:

**** 简介

GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。如果你是在
UNIX平台下做软件，你会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。同时GDB也具有例如ddd这样的图形化的调试端。

一般来说，GDB主要完成下面四个方面的功能：

(1)启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。

(2)可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）

(3)当程序被停住时，可以检查此时你的程序中所发生的事。

(4)动态的改变你程序的执行环境。


兴趣是最好的老师，这里先整理总结一下在调试的过程中经常遇到的问题。带着这些问题进行学习和实践可以有助于加深印象。
再往后是本人实践过程中总结的常见命令，如有什么问题或者建议，都可以联系我，谢谢！\^_\^

(1)如何打印变量的值？(print var)

(2)如何打印变量的地址？(print &var)

(3)如何打印地址的数据值？(print *address)

(4)如何查看当前运行的文件和行？(backtrace)

(5)如何查看指定文件的代码？(list file:N)

(6)如何立即执行完当前的函数，但是并不是执行完整个应用程序？(finish)

(7)如果程序是多文件的，怎样定位到指定文件的指定行或者函数？(list file:N)

(8)如果循环次数很多，如何执行完当前的循环？(until)

(9)多线程如何调试？(???)

**** 举例                                                           :example:

*启动gdb

$gdb

这样可以和gdb进行交互了。


*启动gdb，并且分屏显示源代码：

$gdb -tui

这样,使用了'-tui'选项，启动可以直接将屏幕分成两个部分，上面显示源代码，比用list方便多了。这时候使用上下方向键可以查看源代码,想要命令行使用上下键就用[Ctrl]n和[Ctrl]p.


*启动gdb调试指定程序app：

$gdb app

这样就在启动gdb之后直接载入了app可执行程序，需要注意的是，载入的app程序必须在编译的时候有gdb调试选项，例如'gcc
-g app
app.c',注意，如果修改了程序的源代码，但是没有编译，那么在gdb中显示的会是改动后的源代码，但是运行的是改动前的程序，这样会导致跟踪错乱的。


*启动程序之后，再用gdb调试：

$gdb <program> <PID>

这里，<program>是程序的可执行文件名，<PID>是要调试程序的PID.如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。


*启动程序之后，再启动gdb调试：

$gdb <PID>

这里，程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID,<PID>是要调试程序的PID.这样gdb就附加到程序上了，但是现在还没法查看源代码,用file命令指明可执行文件就可以显示源代码了。

**启动gdb之后的交互命令：

交互命令支持[Tab]补全。

*显示帮助信息：

(gdb) help

*载入指定的程序：

(gdb) file app

这样在gdb中载入想要调试的可执行程序app。如果刚开始运行gdb而不是用gdb
app启动的话可以这样载入app程序，当然编译app的时候要加入-g调试选项。

*重新运行调试的程序：

(gdb) run

要想运行准备调试的程序，可使用run命令，在它后面可以跟随发给该程序的任何参数，包括标准输入和标准输出说明符(<和>
)和shell通配符（*、？、[、]）在内。

*修改发送给程序的参数：

(gdb) set args no

这里，假设我使用"r yes"设置程序启动参数为yes，那么这里的set
args会设置参数argv[1]为no。

*显示缺省的参数列表：

(gdb) show args

*列出指定区域(n1到n2之间)的代码：

(gdb) list n1 n2

这样,list可以简写为l,将会显示n1行和n2行之间的代码，如果使用-tui启动gdb，将会在相应的位置显示。如果没有n1和n2参数，那么就会默认显示当前行和之后的10行，再执行又下滚10行。另外，list还可以接函数名。

一般来说在list后面可以跟以下这们的参数：

<linenum>   行号。

<+offset>   当前行号的正偏移量。

<-offset>   当前行号的负偏移量。

<filename:linenum>  哪个文件的哪一行。

<function>  函数名。

<filename:function> 哪个文件中的哪个函数。

<*address>  程序运行时的语句在内存中的地址。

*执行下一步：

(gdb) next

这样，执行一行代码，如果是函数也会跳过函数。这个命令可以简化为n.

*执行N次下一步：

(gdb) next N

*执行上次执行的命令：

(gdb) [Enter]

这里，直接输入回车就会执行上次的命令了。

*单步进入：

(gdb) step

这样，也会执行一行代码，不过如果遇到函数的话就会进入函数的内部，再一行一行的执行。

*执行完当前函数返回到调用它的函数：
(gdb) finish

这里，运行程序，直到当前函数运行完毕返回再停止。例如进入的单步执行如果已经进入了某函数，而想退出该函数返回到它的调用函数中，可使用命令finish.

*指定程序直到退出当前循环体：

(gdb) until

或(gdb) u

这里，发现需要把光标停止在循环的头部，然后输入u这样就自动执行全部的循环了。

*跳转执行程序到第5行：

(gdb) jump 5

这里，可以简写为"j
5"需要注意的是，跳转到第5行执行完毕之后，如果后面没有断点则继续执行，而并不是停在那里了。

另外，跳转不会改变当前的堆栈内容，所以跳到别的函数中就会有奇怪的现象，因此最好跳转在一个函数内部进行,跳转的参数也可以是程序代码行的地址,函数名等等类似list。

*强制返回当前函数:

(gdb) return

这样，将会忽略当前函数还没有执行完毕的语句，强制返回。return后面可以接一个表达式，表达式的返回值就是函数的返回值。

*强制调用函数：

(gdb) call <expr>

这里,<expr>可以是一个函数，这样就会返回函数的返回值，如果函数的返回类型是void那么就不会打印函数的返回值,但是实践发现，函数运行过程中的打印语句还是没有被打印出来。

*强制调用函数2：

(gdb) print <expr>

这里，print和call的功能类似，不同的是，如果函数的返回值是void那么call不会打印返回值，但是print还是会打印出函数的返回值并且存放到历史记录中。

*在当前的文件中某一行（假设为6）设定断点：

(gdb) break 6

*设置条件断点：

(gdb) break 46 if testsize==100

这里，如果testsize==100就在46行处断点。

*检测表达式变化则停住：

(gdb) watch i != 10

这里，i != 10这个表达式一旦变化，则停住。watch <expr>
为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序(也是一种断点)。

*在当前的文件中为某一函数(假设为func)处设定断点：

(gdb) break func

*给指定文件（fileName）的某个行（N）处设置断点：

(gdb) break fileName:N

这里，给某文件中的函数设置断点是同理的。

*显示当前gdb断点信息：

(gdb) info breakpoints

这里，可以简写为info break.会显示当前所有的断点，断点号，断点位置等等。

*删除N号断点：

(gdb) delete N

*删除所有断点：

(gdb) delete

*清除行N上面的所有断点：

(gdb) clear N

*继续运行程序直接运行到下一个断点：

(gdb) continue

这里，如果没有断点就一直运行。

*显示当前调用函数堆栈中的函数：

(gdb) backtrace

命令产生一张列表，包含着从最近的过程开始的所有有效过程和调用这些过程的参数。当然，这里也会显示出当前运行到了哪里(文件，行)。

*查看当前调试程序的语言环境：

(gdb) show language

这里，如果gdb不能识别你所调试的程序，那么默认是c语言。

*查看当前函数的程序语言：

(gdb) info frame

*显示当前的调试源文件：

(gdb) info source

这样会显示当前所在的源代码文件信息,例如文件名称，程序语言等。



*手动设置当前的程序语言为c++:

(gdb) set language c++

这里，如果gdb没有检测出你的程序语言，你可以这样设置。



*查看可以设置的程序语言：

(gdb) set language

这里，使用没有参数的set language可以查看gdb中可以设置的程序语言。



*终止一个正在调试的程序：

(gdb) kill

这里，输入kill就会终止正在调试的程序了。



*print显示变量(var)值：

(gdb) print var

这里，print可以简写为p,print
是gdb的一个功能很强的命令，利用它可以显示被调试的语言中任何有效的表达式。表达式除了包含你程序中的变量外，还可以包含函数调用,复杂数据结构和历史等等。



*用16进制显示(var)值：

(gdb) print /x var

这里可以知道，print可以指定显示的格式，这里用'/x'表示16进制的格式。

可以支持的变量显示格式有：

x  按十六进制格式显示变量。

d  按十进制格式显示变量。

u  按十六进制格式显示无符号整型。

o  按八进制格式显示变量。

t  按二进制格式显示变量。

a  按十六进制格式显示变量。

c  按字符格式显示变量。

f  按浮点数格式显示变量。





*如果a是一个数组，10个元素，如果要显示则：

(gdb) print *a@10

这样，会显示10个元素，无论a是double或者是int的都会正确地显示10个元素。



*修改运行时候的变量值：

(gdb) print x=4

这里，x=4是C/C++的语法，意为把变量x值改为4，如果你当前调试的语言是Pascal，那么你可以使用Pascal的语法：x:=4。



*显示一个变量var的类型：

(gdb) whatis var



*以更详细的方式显示变量var的类型：

(gdb) ptype var

这里，会打印出var的结构定义。

**



**** 其他

*在Qt4.x环境中打印QString msg;的msg变量：

步骤如下：

1)定义一个宏printqstring

define printqstring

    printf "(QString)0x%x (length=%i): \"",&$arg0,$arg0.d->size

    set $i=0

    while $i < $arg0.d->size

        set $c=$arg0.d->data[$i++]

        if $c < 32 || $c > 127

                printf "\\u0x%04x", $c

        else

                printf "%c", (char)$c

        end

    end

    printf "\"\n"

end

2)(gdb) printqstring msg

这里，这个宏可以在gdb中直接定义，据说也可以写到$HOME/.gdbinit,这样每次启动自动加载。


*调试同时指明生成core文件：

$gdb <program> core

用gdb同时调试一个运行程序和core文件，core是程序非法执行后core
dump后产生的文件。当程序非法崩溃的时候会产生一个core文件，然后使用这个命令，会直接定位到发生程序崩溃的位置。注意：有时需要设置系统命令“ulimit
-c unlimited”才能产生core文件。


没有实践过的

*print显示存储块,如显示h后面的10个整数：

print h@10

***
*** [[http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/index.html][使用 GDB 调试多进程程序]]                                      :ibm:blog:

GDB 是 linux 系统上常用的 c/c++ 调试工具，功能十分强大。对于较为复杂的系统，比如多进程系统，如何使用 GDB
调试呢？考虑下面这个三进程系统：


#+DOWNLOADED: http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/threeprocesses.jpg @ 2016-01-26 16:03:20
 [[~/Wally/Journal/Figure/.org-download/使用 GDB 调试多进程程序/threeprocesses_2016-01-26_16:03:20.jpg]]

Proc2 是 Proc1 的子进程，Proc3 又是 Proc2 的子进程。如何使用 GDB 调试
proc2 或者 proc3 呢？

实际上，GDB 没有对多进程程序调试提供直接支持。例如，使用GDB调试某个进
程，如果该进程fork了子进程，GDB会继续调试该进程，子进程会不受干扰地运
行下去。如果你事先在子进程代码里设定了断点，子进程会收到SIGTRAP信号并
终止。那么该如何调试子进程呢？其实我们可以利用GDB的特点或者其他一些辅
助手段来达到目的。此外，GDB 也在较新内核上加入一些多进程调试支持。

接下来我们详细介绍几种方法，分别是 follow-fork-mode 方法，attach
子进程方法和 GDB wrapper 方法。

**** follow-fork-mode

在2.5.60版Linux内核及以后，GDB对使用fork/vfork创建子进程的程序提供了follow-fork-mode选项来支持多进程调试。

follow-fork-mode的用法为：

=set follow-fork-mode [parent|child]=

-  parent: fork之后继续调试父进程，子进程不受影响。
-  child: fork之后调试子进程，父进程不受影响。

因此如果需要调试子进程，在启动gdb后：

#+BEGIN_EXAMPLE
    (gdb) set follow-fork-mode child
#+END_EXAMPLE

并在子进程代码设置断点。

此外还有detach-on-fork参数，指示GDB在fork之后是否断开（detach）某个进程的调试，或者都交由GDB控制：

=set detach-on-fork [on|off]=

-  on: 断开调试follow-fork-mode指定的进程。
-  off:
   gdb将控制父进程和子进程。follow-fork-mode指定的进程将被调试，另一个进程置于暂停（suspended）状态。

注意，最好使用GDB
6.6或以上版本，如果你使用的是GDB6.4，就只有follow-fork-mode模式。

follow-fork-mode/detach-on-fork的使用还是比较简单的，但由于其系统内核/gdb版本限制，我们只能在符合要求的系统上才能使用。而且，由于follow-fork-mode的调试必然是从父进程开始的，对于fork多次，以至于出现孙进程或曾孙进程的系统，例如上图3进程系统，调试起来并不方便。

**** Attach子进程

众所周知，GDB有附着（attach）到正在运行的进程的功能，即attach
<pid>命令。因此我们可以利用该命令attach到子进程然后进行调试。

例如我们要调试某个进程RIM_Oracle_Agent.9i，首先得到该进程的pid

#+BEGIN_EXAMPLE
    [root@tivf09 tianq]# ps -ef|grep RIM_Oracle_Agent.9i
    nobody    6722  6721  0 05:57 ?        00:00:00 RIM_Oracle_Agent.9i
    root      7541 27816  0 06:10 pts/3    00:00:00 grep -i rim_oracle_agent.9i
#+END_EXAMPLE

通过pstree可以看到，这是一个三进程系统，oserv是RIM_Oracle_prog的父进程，RIM_Oracle_prog又是RIM_Oracle_Agent.9i的父进程。

#+BEGIN_EXAMPLE
    [root@tivf09 root]# pstree -H 6722
#+END_EXAMPLE

*通过 pstree 察看进程*


#+DOWNLOADED: http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/pstree.jpg @ 2016-01-26 16:03:54
 [[~/Wally/Journal/Figure/.org-download/使用 GDB 调试多进程程序/pstree_2016-01-26_16:03:54.jpg]]

启动GDB，attach到该进程

*用 GDB 连接进程*


#+DOWNLOADED: http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/attach.jpg @ 2016-01-26 16:04:06
 [[~/Wally/Journal/Figure/.org-download/使用 GDB 调试多进程程序
 /attach_2016-01-26_16:04:06.jpg]]

现在就可以调试了。一个新的问题是，子进程一直在运行，attach上去后都不知道运行到哪里了。有没有办法解决呢？

一个办法是，在要调试的子进程初始代码中，比如main函数开始处，加入一段特殊代码，使子进程在某个条件成立时便循环睡眠等待，attach到进程后在该代码段后设上断点，再把成立的条件取消，使代码可以继续执行下去。

至于这段代码所采用的条件，看你的偏好了。比如我们可以检查一个指定的环境变量的值，或者检查一个特定的文件存不存在。以文件为例，其形式可以如下：

#+BEGIN_EXAMPLE
    void debug_wait(char *tag_file)
    {
        while(1)
        {
            if (tag_file存在)
                睡眠一段时间;
            else
                break;
        }
    }
#+END_EXAMPLE

当attach到进程后，在该段代码之后设上断点，再把该文件删除就OK了。当然你也可以采用其他的条件或形式，只要这个条件可以设置/检测即可。

Attach进程方法还是很方便的，它能够应付各种各样复杂的进程系统，比如孙子/曾孙进程，比如守护进程（daemon
process），唯一需要的就是加入一小段代码。

**** GDB wrapper

很多时候，父进程 fork 出子进程，子进程会紧接着调用
exec族函数来执行新的代码。对于这种情况，我们也可以使用gdb wrapper
方法。它的优点是不用添加额外代码。

其基本原理是以gdb调用待执行代码作为一个新的整体来被exec函数执行，使得待执行代码始终处于gdb的控制中，这样我们自然能够调试该子进程代码。

还是上面那个例子，RIM_Oracle_prog
fork出子进程后将紧接着执行RIM_Oracle_Agent.9i的二进制代码文件。我们将该文件重命名为RIM_Oracle_Agent.9i.binary，并新建一个名为RIM_Oracle_Agent.9i的shell脚本文件，其内容如下：

#+BEGIN_EXAMPLE
    [root@tivf09 bin]# mv RIM_Oracle_Agent.9i RIM_Oracle_Agent.9i.binary
    [root@tivf09 bin]# cat RIM_Oracle_Agent.9i
    #!/bin/sh
    gdb RIM_Oracle_Agent.binary
#+END_EXAMPLE

当fork的子进程执行名为RIM_Oracle_Agent.9i的文件时，gdb会被首先启动，使得要调试的代码处于gdb控制之下。

新的问题来了。子进程是在gdb的控制下了，但还是不能调试：如何与gdb交互呢？我们必须以某种方式启动gdb，以便能在某个窗口/终端与gdb交互。具体来说，可以使用xterm生成这个窗口。

xterm是X
window系统下的模拟终端程序。比如我们在Linux桌面环境GNOME中敲入xterm命令：

*xterm*

#+DOWNLOADED: http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/runxterm.jpg @ 2016-01-26 16:08:45
 [[~/Wally/Journal/Figure/.org-download/使用 GDB 调试多进程程序/runxterm_2016-01-26_16:08:45.jpg]]

就会跳出一个终端窗口：

*终端*

#+DOWNLOADED: http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/xterm.jpg @ 2016-01-26 16:08:30
 [[~/Wally/Journal/Figure/.org-download/使用 GDB 调试多进程程序/xterm_2016-01-26_16:08:30.jpg]]

如果你是在一台远程linux服务器上调试，那么可以使用VNC(Virtual Network
Computing)
viewer从本地机器连接到服务器上使用xterm。在此之前，需要在你的本地机器上安装VNC
viewer，在服务器上安装并启动VNC
server。大多数linux发行版都预装了vnc-server软件包，所以我们可以直接运行vncserver命令。注意，第一次运行vncserver时会提示输入密码，用作VNC
viewer从客户端连接时的密码。可以在VNC
server机器上使用vncpasswd命令修改密码。

#+BEGIN_EXAMPLE
    [root@tivf09 root]# vncserver

    New 'tivf09:1 (root)' desktop is tivf09:1

    Starting applications specified in /root/.vnc/xstartup
    Log file is /root/.vnc/tivf09:1.log

    [root@tivf09 root]#
    [root@tivf09 root]# ps -ef|grep -i vnc
    root     19609     1  0 Jun05 ?        00:08:46 Xvnc :1 -desktop tivf09:1 (root)
      -httpd /usr/share/vnc/classes -auth /root/.Xauthority -geometry 1024x768
      -depth 16 -rfbwait 30000 -rfbauth /root/.vnc/passwd -rfbport 5901 -pn
    root     19627     1  0 Jun05 ?        00:00:00 vncconfig -iconic
    root     12714 10599  0 01:23 pts/0    00:00:00 grep -i vnc
    [root@tivf09 root]#
#+END_EXAMPLE

Vncserver是一个Perl脚本，用来启动Xvnc（X VNC server）。X
client应用，比如xterm，VNC
viewer都是和它通信的。如上所示，我们可以使用的DISPLAY值为tivf09:1。现在就可以从本地机器使用VNC
viewer连接过去：

*VNC viewer：输入服务器*


#+DOWNLOADED: http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/vncviewer1.jpg @ 2016-01-26 16:08:18
 [[~/Wally/Journal/Figure/.org-download/使用 GDB 调试多进程程序/vncviewer1_2016-01-26_16:08:18.jpg]]

输入密码：

*VNC viewer：输入密码*

#+DOWNLOADED: http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/vncviewer2.jpg @ 2016-01-26 16:08:05
 [[~/Wally/Journal/Figure/.org-download/使用 GDB 调试多进程程序/vncviewer2_2016-01-26_16:08:05.jpg]]

登录成功，界面和服务器本地桌面上一样：

*VNC viewer*

#+DOWNLOADED: http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/vncviewer3.jpg @ 2016-01-26 16:07:49
 [[~/Wally/Journal/Figure/.org-download/使用 GDB 调试多进程程序/vncviewer3_2016-01-26_16:07:49.jpg]]

下面我们来修改RIM_Oracle_Agent.9i脚本，使它看起来像下面这样：

#+BEGIN_EXAMPLE
    #!/bin/sh
    export DISPLAY=tivf09:1.0; xterm -e gdb RIM_Oracle_Agent.binary
#+END_EXAMPLE

如果你的程序在exec的时候还传入了参数，可以改成：

#+BEGIN_EXAMPLE
    #!/bin/sh
    export DISPLAY=tivf09:1.0; xterm -e gdb --args RIM_Oracle_Agent.binary $@
#+END_EXAMPLE

最后加上执行权限

#+BEGIN_EXAMPLE
    [root@tivf09 bin]# chmod 755 RIM_Oracle_Agent.9i
#+END_EXAMPLE

现在就可以调试了。运行启动子进程的程序：

#+BEGIN_EXAMPLE
    [root@tivf09 root]# wrimtest -l 9i_linux
    Resource Type  : RIM
    Resource Label : 9i_linux
    Host Name      : tivf09
    User Name      : mdstatus
    Vendor         : Oracle
    Database       : rim
    Database Home  : /data/oracle9i/920
    Server ID      : rim
    Instance Home  :
    Instance Name  :
    Opening Regular Session...
#+END_EXAMPLE

程序停住了。从VNC viewer中可以看到，一个新的gdb
xterm窗口在服务器端打开了

*gdb xterm 窗口*


#+DOWNLOADED: http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/gdbwindow.jpg @ 2016-01-26 16:05:48
 [[~/Wally/Journal/Figure/.org-download/使用 GDB 调试多进程程序/gdbwindow_2016-01-26_16:05:48.jpg]]

#+BEGIN_EXAMPLE
    [root@tivf09 root]# ps -ef|grep gdb
    nobody   24312 24311  0 04:30 ?        00:00:00 xterm -e gdb RIM_Oracle_Agent.binary
    nobody   24314 24312  0 04:30 pts/2    00:00:00 gdb RIM_Oracle_Agent.binary
    root     24326 10599  0 04:30 pts/0    00:00:00 grep gdb
#+END_EXAMPLE

运行的正是要调试的程序。设置好断点，开始调试吧！

注意，下面的错误一般是权限的问题，使用 xhost 命令来修改权限：

*xterm 错误*


#+DOWNLOADED: http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/error.jpg @ 2016-01-26 16:07:34
 [[~/Wally/Journal/Figure/.org-download/使用 GDB 调试多进程程序/error_2016-01-26_16:07:34.jpg]]

#+BEGIN_EXAMPLE
    [root@tivf09 bin]# export DISPLAY=tivf09:1.0
    [root@tivf09 bin]# xhost +
    access control disabled, clients can connect from any host
#+END_EXAMPLE

xhost +
禁止了访问控制，从任何机器都可以连接过来。考虑到安全问题，你也可以使用xhost
+ <你的机器名>。

**** 小结

上述三种方法各有特点和优劣，因此适应于不同的场合和环境：

-  follow-fork-mode方法：方便易用，对系统内核和GDB版本有限制，适合于较为简单的多进程系统
-  attach子进程方法：灵活强大，但需要添加额外代码，适合于各种复杂情况，特别是守护进程
-  GDB wrapper方法：专用于fork+exec模式，不用添加额外代码，但需要X环境支持（xterm/VNC）。

**** 参考资料

-  GDB 官方参考资料：[[http://sourceware.org/gdb/documentation/]]
-  更多 VNC 信息：[[http://www.realvnc.com/]]

* Matlab                                                             :MATLAB:
** fundermental
*** Ubuntu支持                                                     :ubuntu:

+ http://blog.csdn.net/lanbing510/article/details/41698285
+ http://neuro.debian.net/blog/2013/2013-05-31_matlab_64bit_on_32bit.html
+ https://help.ubuntu.com/community/MultiArch
+ http://stackoverflow.com/questions/28039025/how-to-install-64-bit-matlab-in-32-bit-ubuntu


Note:
1) Matlab对32位的支持越来越少
2) 在32位Ubuntu上安装64位软件几乎是不可能的(debian的可能)，没有必要瞎折腾
3) Python可以完全替代Matlab

*** [[http://lanbing510.info/2014/12/03/Linux-Matlab.html][Matlab 安装]]                                                   :install:

1. 从[[http://pan.baidu.com/s/1o6qKdxo#path=%252Fmatlab][这里]]下载Matlab2014的Linux版本及破解文件。

   - note: 两个 rar 文件，只需使用 unrar 解压其中一个即可，会自动解压
     另外一个。

2. 下载完成后将iso文件挂载到Linux进行安装。

   #+BEGIN_EXAMPLE
    sudo mkdir /media/matlab
    mount -o loop [path][filename].iso /media/matlab
    cd /media/matlab
    sudo ./install
   #+END_EXAMPLE

  - ./install 触发的是 GUI 方式，而不是命令行方式

3. 安装过程中使用readme.txt中的序列号。

4. 破解

   1) 安装完成后使用crack下的 license进行激活；

   2) 将crack文件夹下的libmwservices.so copy到 /usr/local/MATLAB/R2014A/bin/glnxa64。

5. 完成安装，命令行下使用sudo matlab即可启动使用。

*** matlab 启动错误                                                 :error:

#+BEGIN_EXAMPLE
  Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar
#+END_EXAMPLE

[[http://askubuntu.com/questions/615644/after-upgrading-ubuntu-14-10-to-15-04-i-am-no-longer-able-to-open-matlab-2013a/617059#617059][Ubuntu fomula]]

This package is responsible for application menu support for Java
swing applications, and seems to be the cause for the segfault.

#+BEGIN_EXAMPLE
sudo apt-get remove jayatana
#+END_EXAMPLE

没有解决问题。

[[http://www.mathworks.com/matlabcentral/answers/50971-matlab-r2012b-java-exception-error-starting-desktop][Mathworks]]

以超级用户身份执行 matlab, 解决问题, 不明所以。

#+BEGIN_EXAMPLE
Same thing happens to me on a macbook. Same exception, exception disappears when starting matlab using sudo.
#+END_EXAMPLE

Most likely you don't have write permissions on your preferences
directory. You can determine the location of the MATLAB preferences
folder by running the PREFDIR command at the MATLAB prompt.

If for some reason you're unable to fix the permissions, you can try
changing the prefs directory location:
http://www.mathworks.com/support/solutions/en/data/1-37KDWN/

In Matlab.
#+BEGIN_EXAMPLE
>> prefdir

ans =

/home/wally/.matlab/R2014a
#+END_EXAMPLE

#+BEGIN_EXAMPLE
   ls -l .matlab/R2014a/
  总用量 1536
  -rw-r--r-- 1 root root     12  1月 15 10:58 cwdhistory.m
  -rw-r--r-- 1 root root    512  1月 15 11:04 History.xml
  -rw-r--r-- 1 root root   6070  1月 15 11:03 MATLABDesktop.xml
  -rw-r--r-- 1 root root   6092  1月 15 10:58 MATLABDesktop.xml.prev
  -rw-r--r-- 1 root root    429  1月 15 10:57 matlab.prf
  -rw-r--r-- 1 root root   8864  1月 15 11:02 matlab.settings
  -rw-r--r-- 1 root root    201  1月 10 14:03 shortcuts_2.xml
  -rw-r--r-- 1 root root 553920  1月 10 14:03 toolbox_cache-8.3.0-2211579006-glnxa64.xml
  -rw-r--r-- 1 root root 970053  1月 15 10:58 toolbox_cache-8.3.0-903067591-glnxa64.xml
#+END_EXAMPLE
所有者为 root 用户。。。


问题找到了。但是不想修改 predir ，因为麻烦。折衷使用超级用户权限运行
matlab

Note: 在终端使用 C-c 结束 Matlab，反应慢，在 GUI 上点击关闭按钮。

** syntax
*** Matlab续行符                                                   :续行符:

续行符，也就是三个点：...

** LaTeX                                                             :latex:
*** [[http://blog.csdn.net/zd0303/article/details/7536967][Matlab中巧用LaTex]]                                                :blog:

Matlab作为数据计算和处理的数学语言(软件)，而LaTex作为出版界的重要排版
语言(软件)，尤其是对数学公式的排版功能特别强。在Matlab中有两种方法使用
LaTeX：1）对Matlab生成的图形标注时，2）Matlab的计算结果转化成LaTeX格式。

**** 对Matlab生成的图形标注

Matlab图形中title、xlabel、ylabel、zlabel、textbox和legend等的
Interpreter属性有三个属性：latex、tex、none。默认为tex。(注：LaTeX是一
套以TeX描述的宏软件。LaTeX有很多预设的模版、样式。它比TeX更为结构化，
如包含了供建立索引、表格、列表等的宏和公用软件。利用这种格式，即使用户
没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，对于生成
复杂表格和数学公式，这一点表现得尤为突出)。

为方便利用LaTeX的命令，需要在把Matlab图形中title、xlabel、ylabel、
zlabel、textbox和legend等的Interpreter属性设定为latex。首先，在Matlab
中使用LaTeX语言的格式有三种：

1. \( LaTeX命令\)
2. $ LaTeX命令$
3. $$ LaTeX命令$$

以Matlab图形中的textbox属性为例，首先在图形中输入一个双重积分，然后输
入一个Schrodinger方程。命令为：

#+BEGIN_SRC matlab
  x=0:0.2:2*pi;

  y=sin(x);
   My_paper_figure(x,y)
   text('Interpreter','latex','String','$\rightarrow\phi +\sin(x)$','Position',[2.2 sin(2)],'FontSize',20);
   %在坐标(2.2,sin(2)处输出-->)
#+END_SRC

输出结果为

[[http://img.my.csdn.net/uploads/201211/02/1351820919_3763.jpg]]

当然也可以使用 \(\) 命令。以此类推也可以对title、xlabel、ylabel、
zlabel和legend等使用LaTeX命令，如：

#+BEGIN_EXAMPLE
xlabel({'∫x0∫ydF(u,v)'},'Interpreter','latex')
#+END_EXAMPLE

至于LaTeX命令使用方法可以参考[[http://www.sciencenet.cn/m/user_content.aspx?id=246649][LaTeX教程]]。

**** 把Matlab的计算结果转化成Latex格式

对于Matlab计算出的符号运算结果，可以通过latex()函数转化成LeTeX命令格式。
由于latex()函数只对符号表达式进行转换，对于数值结果一定要通过sym()函数
转化成符号结果。所以，为防止对数值结果转化出错，可同时使用latex()和
sym()函数：latex(sym(s));

其中s代表符号表达式。

例如：

syms a b c
s=a/b+c

使用latex(s)后转化为LeTeX命令：

{\frac {a}{b}}+c

附：数学符号和希腊字母的命令及其符号

[[http://blog.sciencenet.cn/upload/blog/images/2010/4/20104894349872.JPG]]

**** 把Matlab的分析图片结果转化成Latex使用的.eps格式，以便使用latex进行编辑使用。

可以使用Latex Markup，将M-file转换成 text-file。

cell ->Insert text parkup ->Latex Markup

在编辑完M-file文件后，点击Publish 图标的倒三角号，选择"EditM-File Con
gurations" 窗口.

然后在"Publish settings"的对话框中，选择“Output file format”
中的“latex”选项，点击“Save as”即可。

** File                                                               :file:
*** [[http://www.cnblogs.com/xianghang123/archive/2011/12/06/2277602.html][【Matlab】读取文件各种方法]]                                       :blog:

本技术支持指南主要处理：ASCII, binary, and MAT files.
要得到MATLAB中可用来读写各种文件格式的完全函数列表，可以键入以下命令：
help iofun

*MATLAB中有两种文件I/O程序：high level and low level.*
*High level routines:*
包括现成的函数，可以用来读写特殊格式的数据，并且只需要少量的编程。
*Low level routines:*
可以更加灵活的完成相对特殊的任务，需要较多的额外编程。


High level routines
包括现成的函数，可以用来读写特殊格式的数据，并且只需要少量的编程。



举个例子，如果你有一个包含数值和字母的文本文件（text
file）想导入MATLAB，你可以调用一些low level
routines自己写一个函数，或者是简单的用[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/textread.html][TEXTREAD]]函数。



*使用high level
routines的关键是：文件必须是相似的（homogeneous），*换句话说，文件必须有一致的格式。下面的段落描述一些high
level file I/O routines并给出一些例子帮助理解概念。



*LOAD/SAVE*



主要的high level file I/O routines
是[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/load.html][LOAD]]
和
[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/save.html][SAVE]]函数。LOAD
可以读MAT-file data或者用空格间隔的格式相似的ASCII data.
SAVE可以将MATLAB变量写入MAT-file格式或者空格间隔的ASCII
data。大多数情况下，语法相当简单。下面的例子用到数值由空格间隔的ASCII
file
[[http://www.mathworks.com/support/tech-notes/1600/1602_files/sample_file.txt][sample_file.txt]]
：



1 5 4 16 8

5 43 2 6 8

6 8 4 32 1

90 7 8 7 6

5 9 81 2 3



Example:
用 LOAD and SAVE 读写数据


CODE:

% Load the file to the matrix, M :
M = load('sample_file.txt')

% Add 5 to M :
M = M +5

% Save M to a .mat file called 'sample_file_plus5.mat':
save sample_file_plus5 M

% Save M to an ASCII .txt file called 'sample_file_plus5.txt' :
save sample_file_plus5.txt M -ascii


*UIGETFILE/UIPUTFILE
*



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/uigetfile.html][UIGETFILE]]/[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/uiputfile.html][UIPUTFILE]]是基于图形用户界面（GUI）的。会弹出对话框，列出当前目录的文件和目录，提示你选择一个文件。[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/uigetfile.html][UIGETFILE]]让你选择一个文件来写（类似Windows
‘另存为'选项？）。用[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/uigetfile.html][UIGETFILE]]，可以选择已存在的文件改写，也可以输入新的文件名。两个函数的返回值是所选文件名和路径。



Example:
用 UIGETFILE 从当前目录选择一个 M-file


CODE:

% This command lists all the M-files in the current directory and
% returns the name and path of the selected file

[fname,pname] = uigetfile('*.m','Sample Dialog Box')



注意: UIGETFILE 一次只能选择一个文件。



*UIIMPORT/IMPORTDATA*



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/uiimport.html][UIIMPORT]]是一个功能强大，易于使用的基于GUI的high
level routine，用于读complex data files。文件也必须是homogeneous。



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/importdata.html][IMPORTDATA]]形成[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/uiimport.html][UIIMPORT]]的功能，不打开GUI。可以将IMPORTDATA用于函数或者脚本中，因为在函数或者脚本中基于GUI的文件导入机制并不理想。下面的例子用到包含几行文件头和文本、数值数据的文件[[http://www.mathworks.com/support/tech-notes/1600/1602_files/sample_file2.txt]['sample_file2.txt']]
：



This is a file header.

This is file is an example.

col1 col2 col3 col4

A    1   4    612.000

B    1   4    613.000

C    1   4    614.000

D    1   4    615.000



Example: Using IMPORTDATA to read in a file with headers, text, and
numeric data


CODE:

% This reads in the file 'sample_file2.txt' and creates a
% structure D that contains both data and text data.
% Note the IMPORTDATA command specifies a white space
% as the delimiter of the file, but IMPORTDATA can usually
% detect this on its own

D = importdata('sample_file2.txt','') % 原文有误？
D = importdata('sample_file2.txt')


可以通过访问结构D的数据和文本域，来看结构D中的真实值，例如输入：

data = D.data

text = D.textdata



可以用UIIMPORT读同一个文件并得到同样的结构.



注意: 对于 ASCII data, 你必须检验导入向导正确的识别了列分隔符。



*TEXTREAD/STRREAD*



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/textread.html][TEXTREAD]]
是一个强大的动态high level
routine，设计用来读ASCII格式的文本和/或数值数据文件。[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/strread.html][STRREAD]]除是从字符串而不是文件读以外，类似于[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/textread.html][TEXTREAD]]。



两个函数可以用许多参数来改变其具体的工作方式，他们返回读入指定输出的数据。他们有效的提供给你一个
“两全其美”的方法，因为他们可以用一个命令读入混合的ASCII和数值数据（high
level routines的做法），并且你可以改变他们以匹配你特定的应用（如同low
level routines做到的）。例子：


CODE:
Example 1: Using TEXTREAD to read in an entire file into a cell array


% This command reads in the file fft.m into the cell array, file
file = textread('fft.m','%s','delimiter','\n','whitespace','');




CODE:
Example 2: Using STRREAD to read the words in a line

% This command uses the cell array created in Example 1 to
% read in each word of line 28 in 'file' to a cell array, words

words = strread(file{28},'%s','delimiter','')


CODE:
Example 3: Using TEXTREAD to read in text and numeric data from a file
with headers

% This command skips the 2 header lines at the top of the file
% and reads in each column to the 4 specified outputs

[c1 c2 c3 c4] = textread('sample_file2.txt','%s %s %s
%s','headerlines',2)


CODE:
Example 4: Using TEXTREAD to read in specific rows of text and numeric
data from a file

% This command reads in rows B and C of the file. The 'headerlines'
% property is used to move down to the desired starting row and the
% read operation is performed 2 times

[c1 c2 c3 c4] = textread('sample_file2.txt',...
'%s %s %s %s',2,'headerlines',4)


CODE:
Example 5: Using TEXTREAD to read in only the numeric data from a file
containing text and numbers

% This command reads in only the numeric data in the file. The
% 'headerlines' property is used to move down to the first row
% of interest and the first column of text is ignored with the
% '*' operator

[c2 c3 c4] = textread('sample_file2.txt','%*s %d %d
%f','headerlines',3)


*DLMREAD/DLMWRITE/CSVREAD*



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/dlmread.html][DLMREAD]]
和
[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/dlmwrite.html][DLMWRITE]]函数能够读写分隔的ASCII
data，而不是用low level routines。他们比low level routines容易使用，Low
level routines用几行代码实现的功能可以用DLMREAD/DLMWRITE简化成一行。



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/csvread.html][CSVREAD]]用来读分隔符是逗号的文件，是[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/dlmread.html][DLMREAD]]的特殊情况。当读空格和Tab分隔的电子数据表文件时，[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/dlmread.html][DLMREAD]]特别有用。以[[http://www.mathworks.com/support/tech-notes/1600/1602_files/sample_file.txt]['sample_file.txt']]为例：




CODE:
Example 1: Using DLMREAD to read in a file with headers, text, and
numeric data

% This reads in the file 'sample_file2.txt' and creates a matrix, D,
% with the numeric data this command specifies a white space as the
% delimiter of the file

D = dlmread('sample_file.txt','')


CODE:
Example 2: Using DLMREAD to extract the first 3 columns of the last 3
rows

% This reads in the first 3 columns of the last 3 rows of
% the data file 'sample_file.txt'into the matrix, D_partial.
% 读文件 'sample_file.txt' 前3列后3行，到矩阵D_partial.

D_partial = dlmread('sample_file.txt','',[2 0 4 2])



CODE:
Example 3: Using DLMWRITE to write a comma delimited file

% This creates a file called 'partialD.txt' that consists of
% the first 3 columns of the last 3 rows of data where each
% element is separated by a comma

dlmwrite('partialD.txt',D_partial,',')



注意: 保证DLMREAD and DLMWRITE指定范围的指标从0开始，而不是从1开始。



*WK1READ/WK1WRITE
*



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/wk1read.html][WK1READ]]
用来读Lotus123
电子数据表文件的数据；[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/wk1write.html][WK1WRITE]]用来写矩阵到Lotus123
电子数据表文件。



*XLSREAD*



[[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/xlsread.html][XLSREAD]]用来读Excel的数值和文本数据。





*三. 具体例子分析：
*Matlab网站用两个例子非常详尽地介绍了各个命令的基本用法，实际中，面对手头上的数据，如何选用合适的命令呢？以下结合几个示例给出一些总结，大家举一反三就可以了：

*1. 纯数据（列数相同）：
源文件：*



CODE:
0 3866.162 2198.938 141.140
1 3741.139 2208.475 141.252
2 3866.200 2198.936 141.156
3 3678.048 2199.191 141.230
4 3685.453 2213.726 141.261
5 3728.769 2212.433 141.277
6 3738.785 2214.381 141.256
7 3728.759 2214.261 141.228
8 3748.886 2214.299 141.243
9 3748.935 2212.417 141.253
10 3733.612 2226.653 141.236
11 3733.583 2229.248 141.223
12 3729.229 2229.118 141.186




*解答*：对于这个txt文件，由于各行列数相同，故简单地使用load,importdata均可。


*2.字段名（中、英文字段均可）+数据：*
*源文件：*


CODE:
CH0 CH1 CH2 CH3
0.000123 0.000325 0.000378 0.000598
0.000986 0.000256 0.000245 0.000698


*解答*：由于是记录的形式，因此各行列数必相同（缺少部分列时请自行在文件中补上
Inf 或 NaN），故直接使用 importdata 便可。

*3.注释（含有独立的数字串）+数据（列数相同）：*
*问题*：这个文件有4列,但前6行是文字说明,4列数字是从第8行开始的.现在我想把这个文件的前2列和文字说明提出来组成一个新的dat文件

*源文件：*


CODE:
Group 2 12.02.2006   Limei
Samples of datas: 50000

CH0 CH1 CH2 CH3
0.000123 0.000325   0.000378   0.000598
0.000986 0.000256   0.000245   0.000698


*目标文件：
*

CODE:
Group 2 12.02.2006 Limei
Samples of datas: 50000

CH0 CH1
0.000123 0.000325
0.000986 0.000256


*解答*：由于注释中含有独立的数字串，且注释部分没有明显的格式，
这时候用importdata, load等高级命令直接读取会失败，用 textread, dlmwrite
等格式化命令也不太合适，因此只能使用低级命令进行读取。（当然了，可以跳过注释部分直接用高级命令读取数据，即：[a
b c d] = textread(filename,'%f %f %f %f','headerlines',4);
）。一个简单的、非通用的包含注释的读取方法如下：
-------------------------------------转
---------------------------------------------------------------------------------------

CODE:
clc;clear;
fid = fopen('exp.txt', 'r');
fid_n=fopen('ex.dat','w');
while ~feof(fid)
    tline=fgetl(fid);
    if ~isempty(tline)
     if double(tline(1))>=48 && double(tline(1))<=57 %数值开始
         a=strread(tline);
         a(3:4)=[];
         fprintf(fid_n,'%f %f\n',a);
         clear a;
     elseif double(tline(1))==67   %字母C开始
       [b1,b2,b3,b4]=strread(tline,'%s %s %s %s');
       b=[b1{1},' ',b2{1}];
         fprintf(fid_n,'%s\n',b);
         clear b b1 b2 b3 b4;
     else
         fprintf(fid_n,'%s\n',tline);
     end
    else
     fprintf(fid_n,'%s\n',tline);
    end
end
fclose(fid);
fclose(fid_n);


---------------------------------------------------------------------------------

*4. 注释（不含独立的数字串）+数据（列数相同）：*
*源文件：*

CODE:
你好 abc
欢迎来到 我们
振动论坛
vib.hit.edu.cn
1 11 111 1111
2 22 222 2222
3 33 333 3333
4 44 444 4444
5 55 555 5555


*解答：*直接用 importdata 便可

*注：*有时候注释中含有独立的数字串也可以 importdata
成功，不过得到的结果有可能不正确，建议这时候使用第3种情形的读取方式。

*5. 注释与数据混排：*
对此当然只能自己编程，举例：

*源文件*：

CODE:
1 11 111 1111
你好
2 22 222 2222
欢迎来到
3 33 333 3333
振动论坛
4 44 444 4444
vib.hit.edu.cn
5 55 555 5555


*解答：*
--------------------------------------------转--------------------------------------


CODE:

function [data]=distilldata(infile)
%功能说明：
%将保存数据的原始文件中的数值数据读入到一个data变量中
%使用说明：
% infile------原始数据文件名;
% data=数据变量

tmpfile='tmp2.mat';

fidin=fopen(infile,'r'); % 打开原始数据文件（.list）

fidtmp=fopen(tmpfile,'w'); % 创建保存数据文件（不含说明文字）

while ~feof(fidin) % 判断是否为文件末尾
 tline=fgetl(fidin); % 从文件读入一行文本（不含回车键）
 if ~isempty(tline) % 判断是否空行
    [m,n]=size(tline);
    flag=1;
    for i=1:n %判断一行中有没有字符（＋－.Ee和空格键除外）
     if ~(tline(i)==' '|tline(i)=='-'|tline(i)=='.'|tline(i)=='E'...
        |tline(i)=='e'|tline(i)=='+'...
        |(double(tline(i))>=48&&double(tline(i))<=57))
     flag=0;
     break;
     end
    end
    if flag==1 % 如果是数字行，把此行数据写入文件
     fprintf(fidtmp,'%s\n',tline);
    end
 end
end

fclose(fidin);

fclose(fidtmp);

data=textread(tmpfile);

delete(tmpfile);



---------------------------------------------------------------------------------------------------------
另外，如果要求不高，也可以使用 textread
函数跳过注释部分进行读取，不过前提是需要事先知道文件内容的结构（即哪行是数据、哪行是注释）

*6.各列数据的分离：
源文件：*


CODE:
       0 + 47038.7   1.05 09:26:07 C
       2 + 46477.7   1.03 09:28:38 C
       4 + 44865.7   1.04 09:28:48 C
       6 + 41786.4   1.03 09:28:56 C
       8 + 39896.0   0.97 09:29:03 C
        10 + 37518.4   0.93 09:29:15 C
        12 + 35858.5   0.92 09:29:30 C
        14 + 46105.0   1.03 09:30:21 C
        16 + 46168.6   6.89 09:30:30 C
        18 + 48672.3   4.33 09:30:40 C
        20 + 49565.7   0.49 09:30:48 C
        22 + 49580.7   0.53 09:30:55 C
        24 + 49602.3   0.84 09:31:03 C
        26 + 49582.5   1.51 09:31:11 C
        28 + 49577.0   1.39 09:31:19 C
        30 + 49589.3   0.61 09:31:27 C
        32 + 49578.3   1.06 09:31:29 C
        34 + 49512.5   1.77 09:31:38 C




*解答：*直接用 [a,b,c,d,e,f]=textread(yourfilename,'%d %c %f %f %s %c');
便可


*四. 注意事项：*



1. 请在 matlab
中保持当前路径在该数据文件对应的目录下进行存取，否则，存取时请给出该数据文件的具体路径。




2. 存取时，请给出该数据文件的全称（包括后缀名，读取mat文件时可省略）




3. load data.txt和A=load(‘data.txt')的区别请参阅精华贴：




4. 请根据读写需要来打开文件，即根据你的需要来指定 fopen 的 permission
属性为读或写。如果只用 a 进行写入，就不能用 fread
读取。此时应该写完关闭文件，然后用 r 打开读取，或者直接用 a+
进行同时读写操作。否则，会产生莫名其妙的问题！以下代码是一个错误的例子：




CODE:

filename='e.dat';
fid=fopen(filename,'a');
if fid<0
    error('fopen error');
end
s=[1 2 3 4;5 6 7 8];
fwrite(fid,s,'float32')
[dd ll]=fread(fid,inf,'float32');％把t中的数据全部读出，即s矩阵。
fclose(fid);






此时得到的dd, ll 是错误且无意义的！


*五. 其他相关问题：*

*1. 连续读取多个文件的数据，并存放在一个矩阵中：*
*(1) 首先是如何读取文件名：*
*方法一：
*filename=dir(‘*.jpg');
那么第i个文件的文件名就可以表示为
filename(i).name
文件数量为：length(filename)

*方法二：*
先在Windows的 MSDOS（命令行）中使用以下命令生成一个list.txt文件：



dir path\folder /on /b /s > path\list.txt




举例：dir d:\test /on /b /s > d:\list.txt




然后在 matlab 中使用：




filename = textread(sFileFullName,'%s');




把所有文件名读取到list细胞矩阵中，最后对filename{i}便可得到各文件名。


*(2) 然后是读取文件名的数据并存储：*
假设每个文件对应的数据是m*n的，则：

CODE:
k = length(filename);

Data = zeros(m,n,k);

for ii = 1:k
 Data(:,:,ii) = yourreadstyle(filename{ii});
%yourreadstyle是对应的文件读取方式的函数
end




*2. 连续读取多个文件的数据，并存放在多个矩阵（以文件名命名）中：*
假设每个文件对应的数据是m*n的，则以上述第二种文件名读取方法为例：

CODE:
k = length(filename);
for ii = 1:k
 D = yourreadstyle(filename{ii});
eval([‘Data_', num2str(ii), ‘ = D;']);
end



*3. 文件名命名问题：*
文件名为 abc00001,abc00002,... abc00009,abc00010,...
abc00099,abc00100,...abc00879. 准备把这些文件名给放到一个数组里面去。

*解答：*

CODE:
a=cell(879,1);
for k=1:879
   a{k} = sprintf('%.5d',k);
end


*4.
上述各种文件格式、类型自动识别问题*：可以利用正则表达式来处理，使之通用性较强。例如使用以下代码可以自动处理上面提到了例1到例5各种情形，不过由于存在自动判断，对某些例子（如例1）效率自然要低一点，而对于另外的例子（如例3、例5）效率估计要高一点（少用了一个循环）。


CODE:

function [data]=distilldata_eight(infile)
%功能说明：
%将保存数据的原始文件中的数值数据读入到一个data变量中（自动判断数据行）
%使用说明：
% infile------原始数据文件名;
% data=数据变量

tmpfile='tmp2.mat';

fidin=fopen(infile,'r'); % 打开原始数据文件（.list）

fidtmp=fopen(tmpfile,'w'); % 创建保存数据文件（不含说明文字）

while ~feof(fidin) % 判断是否为文件末尾
 tline=fgetl(fidin); % 从文件读入一行文本（不含回车键）
 if ~isempty(tline) % 判断是否空行
    str = '[\^0-9 | \. | \- | \s | e | E]';
%正则表达式为：该行中是否包含除 - . E e 数字 和 空白字符 外的其他字符
    start = regexp(tline,str, 'once');
    if isempty(start)
     fprintf(fidtmp,'%s\n',tline);
    end
 end
end

fclose(fidin);

fclose(fidtmp);

data=textread(tmpfile);

delete(tmpfile)



*5. 大量数据的读取问题：*
可以考虑使用循环分批读取（特别是在各数据是独立的时候），或者使用稀疏矩阵来实现。另外，也可参考《深入浅出MATLAB
7_X混合编程》一书第一章

*6. 读取整个txt文件的内容（获得文件中的所有字符）：*

CODE:

f = fopen('yourfilename.txt','rt'); % t 属性根据需要可省略
x = fread(f,'*char');
fclose(f);


*7. 把维数不同的矩阵及其变量名保存到一个 txt 文件中，例如 a1 = 123; a2 =
[1 2 3;4 5 6] ，希望得到的 txt 文件如下：*
*

QUOTE:
*
*a1：
123
a2：
1 2 3
4 5 6
*
*


*
如果写入的时候简单一点，则可以采用以下方式，不过读取的时候比较麻烦：

CODE:

a1=123;
a2=[1 2 3;4 5 6];
fid = fopen('myfile.txt', 'wt');
for i=1:2
    fprintf(fid, '%s: \n %s\n', ['a',int2str(i)],
mat2str(eval(['a',int2str(i)])));
end
fclose(fid);


相反，如果写入的时候复杂一点，则读取的时候会简单一点：

CODE:

a1=123;
a2=[1 2 3;4 5 6];
fid = fopen('myfile.txt', 'wt');
for i=1:2
    fprintf(fid, '%s: \n', ['a',int2str(i)]);
    b = eval(['a',int2str(i)]);
    fprintf(fid, [repmat('%d ', 1, size(b,2)), '\n'], b');
end

** index
*** residue                                                       :residue:
[r, p, k] = residue(num, den)
+ r 留数
+ p 级数
+ k 直接数(?)

#+BEGIN_SRC latex
  \begin{displaymath}
    \frac{A(s)}{B(s)}=C(s)+\frac{k}{x-p}
  \end{displaymath}
#+END_SRC

** matlab函数快速参考                                                :index:
*** 常用命令

**** 1.1 管理用命令

| addpath | 增加一条搜索路径     | rmpath   | 删除一条搜索路径         |
| demo    | 运行Matlab演示程序   | type     | 列出.M文件               |
| doc     | 装入超文本文档       | version  | 显示Matlab的版本号       |
| help    | 启动联机帮助         | what     | 列出当前目录下的有关文件 |
| lasterr | 显示最后一条信息     | whatsnew | 显示Matlab的新特性       |
| lookfor | 搜索关键词的帮助     | which    | 造出函数与文件所在的目录 |
| path    | 设置或查询Matlab路径 |          |                          |

**** 1.2 管理变量与工作空间用命令

| clear  | 删除内存中的变量与函数 | pack     | 整理工作空间内存       |
| disp   | 显示矩阵与文本         | save     | 将工作空间中的变量存盘 |
| length | 查询向量的维数         | size     | 查询矩阵的维数         |
| load   | 从文件中装入数据       | who,whos | 列出工作空间中的变量名 |


**** 1.3 文件与操作系统处理命令


| cd     | 改变当前工作目录     | edit       | 编辑.M文件             |
| delete | 删除文件             | matlabroot | 获得Matlab的安装根目录 |
| diary  | 将Matlab运行命令存盘 | tempdir    | 获得系统的缓存目录     |
| dir    | 列出当前目录的内容   | tempname   | 获得一个缓存(temp)文件 |
| !      | 执行操作系统命令     |            |                        |


**** 1.4 窗口控制命令


| echo   | 显示文件中的Matlab中的命令 | more | 控制命令窗口的输出页面 |
| format | 设置输出格式               |      |                        |


**** 1.5启动与退出命令

| matlabrc | 启动主程序       | quit | 退出Matlab环境 |
| startup  | Matlab自启动程序 |      |                |

*** 运算符号与特殊字符附录

**** 2.1运算符号与特殊字符

| +    | 加                                    | ... | 续行标志               |
| -    | 减                                    | ,   | 分行符(该行结果不显示) |
| *    | 矩阵乘                                | ;   | 分行符(该行结果显示)   |
| .*   | 向量乘                                | %   | 注释标志               |
| ^    | 矩阵乘方                              | !   | 操作系统命令提示符     |
| .^   | 向量乘方                              |     | 矩阵转置               |
| kron | 矩阵kron积                            | .   | 向量转置               |
| \    | 矩阵左除                              | =   | 赋值运算               |
| /    | 矩阵右除                              | ==  | 关系运算之相等         |
| .\   | 向量左除                              | ~=  | 关系运算之不等         |
| ./   | 向量右除                              | <   | 关系运算之小于         |
| :    | 向量生成或子阵提取                    | <=  | 关系运算之小于等于     |
| ()   | 下标运算或参数定义                    | >   | 关系运算之大于         |
| []   | 矩阵生成                              | >=  | 关系运算之大于等于     |
| {}   |                                       | &   | 逻辑运算之与           |
| .    | 结构字段获取符                        |     | 逻辑运算之或           |
| .    | 点乘运算,常与其他运算符联合使用(如.\) | ~   | 逻辑运算之非           |
| xor  | 逻辑运算之异成                        |     |                        |


**** 2.2逻辑函数

| all   | 测试向量中所用元素是否为真 | is*(一类函数) | 检测向量状态.其中*表示一个确定的函数(isinf) |
| any   | 测试向量中是否有真元素     | *isa          | 检测对象是否为某一个类的对象                |
| exist | 检验变量或文件是否定义     | logical       | 将数字量转化为逻辑量                        |
| find  | 查找非零元素的下标         |               |                                             |

*** 语言结构与调试

**** 3.1编程语言

| builtin  | 执行Matlab内建的函数       | global  | 定义全局变量             |
| eval     | 执行Matlab语句构成的字符串 | nargchk | 函数输入输出参数个数检验 |
| feval    | 执行字符串指定的文件       | script  | Matlab语句及文件信息     |
| function | Matlab函数定义关键词       |         |                          |


**** 3.2控制流程

| break  | 中断循环执行的语句       | if        | 条件转移语句             |
| case   | 与switch结合实现多路转移 | otherwise | 多路转移中的缺省执行部分 |
| else   | 与if一起使用的转移语句   | return    | 返回调用函数             |
| elseif | 与if一起使用的转移语句   | switch    | 与case结合实现多路转移   |
| end    | 结束控制语句块           | warning   | 显示警告信息             |
| error  | 显示错误信息             | while     | 循环语句                 |
| for    | 循环语句                 |           |                          |


**** 3.3交互输入

| input    | 请求输入     | menu  | 菜单生成 |
| keyboard | 启动键盘管理 | pause | 暂停执行 |


**** 3.4面向对象编程

| class      | 生成对象         | isa        | 判断对象是否属于某一类  |
| double     | 转换成双精度型   | superiorto | 建立类的层次关系        |
| inferiorto | 建立类的层次关系 | unit8      | 转换成8字节的无符号整数 |
| inline     | 建立一个内嵌对象 |            |                         |


**** 附录3.5调试

| dbclear | 清除调试断点         | dbstatus | 列出所有断点情况         |
| dbcont  | 调试继续执行         | dbstep   | 单步执行                 |
| dbdown  | 改变局部工作空间内存 | dbstop   | 设置调试断点             |
| dbmex   | 启动对Mex文件的调试  | sbtype   | 列出带命令行标号的.M文件 |
| dbquit  | 退出调试模式         | dbup     | 改变局部工作空间内容     |
| dbstack | 列出函数调用关系     |          |                          |

*** 4 基本矩阵与矩阵处理

**** 4.1基本矩阵

| eye      | 产生单位阵            | rand  | 产生随机分布矩阵 |
| linspace | 构造线性分布的向量    | randn | 产生正态分布矩阵 |
| logspace | 构造等对数分布的向量  | zeros | 产生零矩阵       |
| ones     | 产生元素全部为1的矩阵 | :     | 产生向量         |


**** 4.2特殊向量与常量

| ans       | 缺省的计算结果变量   | non       | 非数值常量常由0/0或Inf/Inf获得 |
| computer  | 运行Matlab的机器类型 | nargin    | 函数中参数输入个数             |
| eps       | 精度容许误差(无穷小) | nargout   | 函数中输出变量个数             |
| flops     | 浮点运算计数         | pi        | 圆周率                         |
| i         | 复数单元             | realmax   | 最大浮点数值                   |
| inf       | 无穷大               | realmin   | 最小浮点数值                   |
| inputname | 输入参数名           | varargin  | 函数中输入的可选参数           |
| j         | 复数单元             | varargout | 函数中输出的可选参数           |


**** 4.3时间与日期

| calender | 日历                 | eomday  | 计算月末       |
| clock    | 时钟                 | etime   | 所用时间函数   |
| cputime  | 所用的CPU时间        | now     | 当前日期与时间 |
| date     | 日期                 | tic     | 启动秒表计时器 |
| datenum  | 日期(数字串格式)     | toc     | 读取秒表计时器 |
| datestr  | 日期(字符串格式)     | weekday | 星期函数       |
| datevoc  | 日期(年月日分立格式) |         |                |


**** 4.4矩阵处理

| cat    | 向量连接                   | reshape | 改变矩阵行列个数   |
| diag   | 建立对角矩阵或获取对角向量 | rot90   | 将矩阵旋转90度     |
| fliplr | 按左右方向翻转矩阵元素     | tril    | 取矩阵的下三角部分 |
| flipud | 按上下方向翻转矩阵元素     | triu    | 取矩阵的上三角部分 |
| repmat | 复制并排列矩阵函数         |         |                    |

*** 5 特殊矩阵

| compan   | 生成伴随矩阵         | invhilb   | 生成逆hilbert矩阵           |
| gallery  | 生成一些小的测试矩阵 | magic     | 生成magic矩阵               |
| hadamard | 生成hadamard矩阵     | pascal    | 生成pascal矩阵              |
| hankel   | 生成hankel矩阵       | toeplitz  | 生成toeplitz矩阵            |
| hilb     | 生成hilbert矩阵      | wilkinson | 生成wilkinson特征值测试矩阵 |

*** 6 数学函数

**** 6.1三角函数

| sin/asin   | 正弦/反正弦函数         | sec/asec   | 正割/反正割函数         |
| sinh/asinh | 双曲正弦/反双曲正弦函数 | sech/asech | 双曲正割/反双曲正割函数 |
| cos/acos   | 余弦/反余弦函数         | csc/acsc   | 余割/反余割函数         |
| cosh/acosh | 双曲余弦/反双曲余弦函数 | csch/acsch | 双曲余割/反双曲余割函数 |
| tan/atan   | 正切/反正切函数         | cot/acot   | 余切/反余切函数         |
| tanh/atanh | 双曲正切/反双曲正切函数 | coth/acoth | 双曲余切/反双曲余切函数 |
| atan2      | 四个象限内反正切函数    |            |                         |


**** 6.2指数函数

| exp | 指数函数     | log10 | 常用对数函数 |
| log | 自然对数函数 | sqrt  | 平方根函数   |


**** 6.3复数函数

| abs   | 绝对值函数   | imag | 求虚部函数 |
| angle | 角相位函数   | real | 求实部函数 |
| conj  | 共轭复数函数 |      |            |


**** 6.4数值处理

| fix   | 沿零方向取整  | round | 舍入取整     |
| floor | 沿-∞方向取整 | rem   | 求除法的余数 |
| ceil  | 沿+∞方向取整 | sign  | 符号函数     |


**** 6.5其他特殊数学函数

| airy    | airy函数               | erfcx    | 比例互补误差函数 |
| besselh | bessel函数(hankel函数) | erfinv   | 逆误差函数       |
| bessili | 改进的第一类bessel函数 | expint   | 指数积分函数     |
| besselk | 改进的第二类bessel函数 | gamma    | gamma函数        |
| besselj | 第一类bessel函数       | gammainc | 非完全gamma函数  |
| bessely | 第二类bessel函数       | gammaln  | gamma对数函数    |
| beta    | beta函数               | gcd      | 最大公约数       |
| betainc | 非完全的beta函数       | lcm      | 最小公倍数       |
| betaln  | beta对数函数           | log2     | 分割浮点数       |
| elipj   | Jacobi椭圆函数         | legendre | legendre伴随函数 |
| ellipke | 完全椭圆积分           | pow2     | 基2标量浮点数    |
| erf     | 误差函数               | rat      | 有理逼近         |
| erfc    | 互补误差函数           | rats     | 有理输出         |

*** 7 坐标转换

| cart2pol | 笛卡儿坐标到极坐标转换   | pol2cart | 极坐标到笛卡儿坐标转换   |
| cart2sph | 笛卡儿坐标到球面坐标转换 | sph2cart | 球面坐标到笛卡儿坐标转换 |

*** 8 矩阵函数

**** 8.1矩阵分析

| cond | 求矩阵的条件数 | rcond     | LINPACK倒数条件估计 |
| det  | 求矩阵的行列式 | rref      | 矩阵的行阶梯型实现  |
| norm | 求矩阵的范数   | rrefmovie | 消元法解方程演示    |
| null | 右零空间       | subspace  | 子空间              |
| orth | 正交空间       | trace     | 矩阵的迹            |
| rank | 求矩阵的秩     |           |                     |

**** 8.2线性方程

| /,\   | 线性方程求解     | nnls     | 非零最小二乘     |
| chol  | Cholesky分解     | pinv     | 求伪逆矩阵       |
| inv   | 矩阵求逆         | qr       | 矩阵的QR分解     |
| lscov | 最小二乘方差     | qrdelete | QR分解中删除一行 |
| lu    | 矩阵的LU三角分解 | qrinsert | QR分解中插入一行 |

**** 8.3特征值与奇异值

| banlance | 改进特征值精度的均衡变换   | qz      | QZ算法求矩阵特征值         |
| cdf2rdf  | 复块对角阵到实块对角阵转换 | rdf2cdf | 实块对角阵到复块对角阵转换 |
| eig      | 求矩阵的特征值和特征向量   | schur   | Schur分解                  |
| hess     | 求Hessenberg矩阵           | svd     | 奇异值分解                 |
| poly     | 求矩阵的特征多项式         |         |                            |


**** 8.4矩阵函数

| expm | 矩阵指数函数 | logm  | 矩阵对数函数 |
| funm | 矩阵任意函数 | sqrtm | 矩阵平方根   |

*** 9 数据分析与Fourier变换函数

**** 9.1基本运算

| cumprod | 向量累积           | prod     | 对向量中各元素求积   |
| cumsum  | 向量累加           | sort     | 对向量中各元素排序   |
| max     | 求向量中最大元素   | sortrows | 对矩阵中各行排序     |
| min     | 求向量中最小元素   | std      | 求向量中各元素标准差 |
| mean    | 求向量中各元素均值 | sum      | 对向量中各元素求和   |
| median  | 求向量中中间元素   | trapz    | 梯形法求数值积分     |


**** 9.2微分计算

| del2 | 离散Laplace变换 | gradient | 梯度计算 |
| diff | 差分于近视微分  |          |          |


**** 9.3滤波与卷积

| Conv   | 卷给与多项式乘法     | filter  | 一维数字滤波 |
| conv2  | 二维卷积             | filter2 | 二维数字滤波 |
| Deconv | 因式分解与多项式乘法 |         |              |


**** 9.4方差处理

| corrcoef | 相关系数计算 | cov | 协方差计算 |


**** 9.5Fourier变换

| abs      | 绝对值函数           | fftshift | fft与fft2输出重排     |
| angle    | 相角函数             | ifft     | 离散Fourier逆变换     |
| cplxpair | 依共轭复数对重新排序 | ifft2    | 二维离散Fourier逆变换 |
| fft      | 离散Fourier变换      | unwrap   | 相角矫正              |
| fft2     | 二维离散Fourier变换  |          |                       |

*** 10 多项式处理函数

**** 10.1多项式处理

| conv    | 卷机与多项式乘法     | polyfit  | 数据的多项式拟合 |
| deconv  | 因式分解与多项式乘法 | polyval  | 多项式求值       |
| poly    | 求矩阵的特征多项式   | polyvalm | 多项式矩阵求值   |
| polyder | 多项式求导           | residue  | 部分分式展开     |
| polyeig | 多项式特征值         | roots    | 求多项式的根     |


**** 10.2数据插值

| griddata | 数据网络的插值生成 | interpft | 一维插值（FFT方法）    |
| interp1  | 一维插值（查表）   | interpn  | 多维插值（查表）       |
| interp2  | 二维插值（查表）   | meshgrid | 构造三维图形用x，y阵列 |
| interp3  | 三维插值（查表）   | spline   | 三次样条插值           |

*** 非线性数值方法

| dblquad                | 双重积分                 | odeget | 获得微分方程求解的可选参数 |
| fmin                   | 单变量最优化函数         | odeset | 设置微分方程求解的可选参数 |
| fmins                  | 多变量最优化函数         | quad   | 低阶数值积分方法           |
| ode45，ode23，ode113， | 微分方程数值解法         | quad8  | 高阶数值积分方法           |
| ode15s，ode23s         |                          |        |                            |
| odefile                | 对文件定义的微分方程求解 |        |                            |

*** 12 稀疏矩阵函数

**** 12.1基本稀疏矩阵

| spdiags | 稀疏对角矩阵         | sprandn   | 稀疏正态分布随机矩阵 |
| speye   | 稀疏单位矩阵         | sprandsym | 稀疏对称随机矩阵     |
| sprand  | 稀疏均匀分布随机矩阵 |           |                      |


**** 12.2稀疏矩阵转换

| find | 查找非零元素下标       | sparse    | 常规矩阵转换为稀疏矩阵 |
| full | 稀疏矩阵转换为常规矩阵 | spconvert | 由外部格式引入稀疏矩阵 |


**** 12.3处理非零元素

| issparse | 判断元素是否为稀疏矩阵 | nzmax   | 允许的非零元素空间     |
| mmz      | 稀疏矩阵的非零元素个数 | spalloc | 为非零元素定位存储空间 |
| nonzeros | 稀疏矩阵的非零元素     | spfun   | 为非零元素定义处理函数 |


**** 12.4稀疏矩阵可视化

| gplot | 绘制图论图形 | spy | 绘制稀疏矩阵结构 |


**** 12.5排序算法

| colmmd  | 列最小度排序             | randperm | 产生随机置换向量      |
| colperm | 由非零元素的个数排序各列 | symmd    | 对称最小度排序        |
| dmperm  | Dulmage-Mendelsohn分解   | symrcm   | 反向Cuthill-McKee排序 |


**** 12.6范数、条件数

| condest | 估算       |   | * |   | 1范数 | normest | 估算 |   | * |   | 2范数 |
| sprank  | 计算结构秩 |   |   |   |       |         |      |   |   |   |       |

**** 12.7特征值与奇异值

| eigs | 求稀疏矩阵特征值和特征向量 | svds | 稀疏矩阵奇异值分解 |


**** 12.8其他

| spaugment | 最小二乘算法形成 | symbact | 符号因子分解 |
| spparms   | 设置稀疏矩阵参数 |         |              |

*** 13 图形绘制

**** 13.1基本二维图形

| fill   | 填充二维多边形     | polar    | 极坐标图形绘制        |
| loglog | 全对数二维坐标绘制 | semilogx | x轴半对数坐标图形绘制 |
| plot   | 线性坐标图形绘制   | semilogy | y轴半对数坐标图形绘制 |

**** 13.2基本三维图形

| fill3 | 三维多边形填充   | plot3 | 三维线或点型图绘制 |
| mesh  | 三维网格图形绘制 | surf  | 三维表面图形绘制   |


**** 13.3三维颜色控制

| brighten | 图形亮度调整     | hidden  | 网格图的网格线开关设置 |
| caxis    | 坐标轴伪彩色设置 | shading | 设置渲染模式           |
| colormap | 调色板设置       |         |                        |


**** 13.4三维光照模型

| diffuse  | 图象漫射处理 | surf1    | 带光照的三维表面绘制 |
| lighting | 光照模式设置 | surfnorm | 曲面法线             |
| specular | 设置镜面反射 |          |                      |


**** 13.5标准调色板设置

| bone   | 带有蓝色调的灰色的调色板 | hot   | 以黑红黄白为基色的调色板 |
| cool   | 以天蓝粉色为基色的调色板 | hsv   | 色度饱和度亮度调色板     |
| copper | 线性铜色调的调色板       | pink  | 粉色色调的调色板         |
| flag   | 以红白蓝黑为基色的调色板 | prism | 光谱颜色表               |
| gray   | 线性灰度调色板           |       |                          |


**** 13.6三维视点控制

| rotate3d | 设置三维旋转开关 | viewmtx | 求视转换矩阵 |
| view     | 设置视点         |         |              |


**** 13.7坐标轴控制

| axis | 坐标轴标度设置     | hold    | 设置当前图形保护模式   |
| axes | 坐标轴位置设置     | subplot | 将图形窗口分成几个区域 |
| box  | 坐标轴盒状显示     | zoom    | 二维图形缩放           |
| grid | 坐标网格线开关设置 |         |                        |


**** 13.8图形注解

| colorbar | 颜色条设置           | xlabel | 给图形的x轴加文字说明 |
| gtext    | 在鼠标位置加文字说明 | ylabel | 给图形的y轴加文字说明 |
| text     | 在图形上加文字说明   | zlabel | 给图形的z轴加文字说明 |
| title    | 给图形加标题         |        |                       |


**** 13.9拷贝与打印

| print    | 打印图形或将图形存盘 | orient | 设置纸的方向 |
| orintopt | 设置打印机为默认值   |        |              |

*** 14 特殊图形

**** 14.1特殊二维图形

| area     | 区域填充          | feather | 羽状条形图绘制   |
| bar      | 条形图绘制        | fplot   | 给定函数绘制     |
| barh     | 水平条形图绘制    | hist    | 直方图绘制       |
| bar3     | 3维条形图绘制     | pareto  | pareto图绘制     |
| bar3h    | 3维水平条形图绘制 | pie     | 饼状图绘制       |
| comet    | 彗星状轨迹绘制    | stem    | 离散序列图形绘制 |
| errorbar | 误差条形图绘制    | stairs  | 梯形图绘制       |


**** 14.2等高线及其他二维图形

| contour  | 等高线绘制     | pcolor   | 伪色绘制           |
| contourf | 等高线填充绘制 | quiver   | 有向图（箭头）绘制 |
| contour3 | 三维等高线绘制 | voronoil | voronoi图绘制      |
| clabel   | 等高线高程标志 |          |                    |

**** 14.3特殊三维图形

| 函数名  | 功能描述               | 函数名    | 功能描述               |
| comet3  | 三维彗星状轨迹绘制     | slice     | 切片图                 |
| meshc   | 带等高线的三维网格绘制 | surfc     | 带等高线的三维表面绘制 |
| meshz   | 带零平面的三维网格绘制 | trisurf   | 表面图形的三角绘制     |
| stem2   | 杆图绘制               | trimesh   | 网格图形的三角绘制     |
| quiver3 | 三维箭头（有向图）绘制 | waterfall | 瀑布型图形的绘制       |


**** 14.4图象显示与文件I/O

| 函数名   | 功能描述       | 函数名  | 功能描述       |
| brighten | 图形色调亮化   | image   | 图像显示       |
| colorbar | 颜色条设置     | imfinfo | 图形文件信息   |
| colormap | 调色板设置     | imread  | 从文件读取图形 |
| contrast | 灰度对比度设置 | imwrite | 保存图像       |

**** 14.5动画处理

| 函数名   | 功能描述   | 函数名 | 功能描述   |
| capture  | 屏幕抓取   | movie  | 播放动画帧 |
| getframe | 获取动画帧 |        |            |

**** 14.6实体模型

| 函数名   | 功能描述   | 函数名 | 功能描述 |
| cylinder | 圆柱体生成 | sphere | 球体生成 |

*** 15 图形处理
**** 15.1图形窗口生成与控制

| 函数名 | 功能描述         | 函数名  | 功能描述               |
| clf    | 清除当前图形窗口 | gcf     | 获取当前图形的窗口句柄 |
| close  | 关闭图形窗口     | refresh | 图形窗口刷新           |
| figure | 生成图形窗口     | shg     | 显示图形窗口           |

**** 15.2坐标轴建立与控制

| 函数名 | 功能描述         | 函数名  | 功能描述               |
| axes   | 坐标轴标度设置   | gca     | 获得当前坐标轴句柄     |
| axis   | 坐标轴位置设置   | hold    | 设置当前图形保护模式   |
| box    | 坐标轴盒状显示   | ishold  | 返回hold的状态         |
| caxis  | 为彩色坐标轴刻度 | subplot | 将图形窗口分为几个区域 |
| cla    | 清除当前坐标轴   |         |                        |

**** 15.3处理图形对象

| 函数名 | 功能描述     | 函数名     | 功能描述             |
| axes   | 坐标轴生成   | surface    | 表面生成             |
| figure | 图形窗口生成 | text       | 文本生成             |
| image  | 图像生成     | unicontrol | 生成一个用户接口控制 |
| light  | 光源生成     | uimenu     | 菜单生成             |
| line   | 线生成       |            |                      |

**** 15.4图形

| 函数名  | 功能描述                 | 函数名 | 功能描述               |
| copyobj | 图像对象拷贝             | gcbo   | 获得当前回调对象的句柄 |
| delete  | 对象删除                 | gco    | 获得当前对象的句柄     |
| drawnow | 消除未解决的图像对象事件 | get    | 获得对象属性           |
| findobj | 查找对象                 | reset  | 重新设置对象属性       |
| gebf    | 获得当前回调窗口的句柄   | set    | 设置对象属性           |

*** 16 GUI(图形用户接口)
**** 16.1GUI函数

| 函数名           | 功能描述                         | 函数名             | 功能描述     |
| ginput           | 获取鼠标输入                     | uiresume           | 继续执行     |
| selectmoveresize | 对象的选择、移动、大小设置、拷贝 | uiwait             | 中断执行     |
| uicontrol        | 生成图形用户接口对象             | waitgorbutterpress | 等待按钮输入 |
| uimenu           | 生成菜单对象                     | waitfor            | 中断执行     |

**** 16.2GUI设计工具

| 函数名 | 功能描述                       | 函数名   | 功能描述   |
| align  | 坐标轴与用户接口控制的对齐工具 | menuedit | 菜单编辑器 |
| cbedit | 回调函数编辑器                 | propedit | 属性编辑器 |
| guide  | GUI设计工具                    |          |            |

**** 16.3对话框

| 函数名   | 功能描述         | 函数名     | 功能描述             |
| dialog   | 对话框生成       | printdlg   | 打印对话框           |
| axlimdig | 坐标轴设限对话框 | questdlg   | 请求对话框           |
| errordlg | 错误对话框       | uigetfile  | 标准的打开文件对话框 |
| helpdlg  | 帮助对话框       | uiputfile  | 标准的保存文件对话框 |
| inputdlg | 输入对话框       | uisetcolor | 颜色选择对话框       |
| listdlg  | 列表选择对话框   | uisetfont  | 字体选择对话框       |
| msgdlg   | 消息对话框       | waitbar    | 等待条显示           |
| pagedlg  | 页位置对话框     | warndlg    | 警告对话框           |

**** 16.4菜单

| 函数名   | 功能描述       | 函数名   | 功能描述                 |
| makemenu | 生成菜单结构   | umtoggle | 菜单对象选中状态切换     |
| menubar  | 设置菜单条属性 | wimenu   | 生成window菜单项的子菜单 |

**** 16.5组按钮

| 函数名   | 功能描述               | 函数名   | 功能描述             |
| btndown  | 组按钮中的按钮按下     | btnstate | 查询按钮中的按钮状态 |
| btngroup | 组按钮生成             | btnup    | 组按钮中的按钮弹起   |
| btnpress | 组按钮中的按钮按下管理 |          |                      |

**** 16.6自定义窗口属性

| 函数名   | 功能描述           | 函数名   | 功能描述           |
| clruprop | 清除用户自定义属性 | setuprop | 设置用户自定义属性 |
| getuprop | 获取用户自定义属性 |          |                    |

**** 16.7其他应用

| 函数名    | 功能描述           | 函数名    | 功能描述                     |
| allchild  | 获取所有子对象     | popupstr  | 获取弹出式菜单选中项的字符串 |
| edtext    | 坐标轴文本对象编辑 | remapfig  | 改变窗口中对象的位置         |
| findall   | 查找所有对象       | setptr    | 设置窗口指针                 |
| getptr    | 获得窗口指针       | setstatus | 设置窗口中文本传状态         |
| getstatus | 获取窗口中文本状态 |           |                              |

*** 17 声音处理
| 函数名  | 功能描述         | 函数名   | 功能描述    |
| soond   | 将向量转换成声音 | wavread  | 读。wav文件 |
| auread  | 读。au文件       | wavwrite | 写。wav文件 |
| auwrite | 写。au文件       |          |             |

*** 18 字符串处理函数
**** 18.1字符串处理

| 函数名  | 功能描述             | 函数名   | 功能描述   |
| strings | Matlab字符串函数说明 | upper    | 字符串大写 |
| isstr   | 字符串判断           | lower    | 字符串小写 |
| deblank | 删除结尾空格         | isletter | 字母判断   |
| str2mat | 字符串转换成文本     | isspace  | 空子符判断 |
| strcmp  | 字符串比较           | strrep   | 字串查找   |
| findstr | 字串查找             | strtok   | 标记查找   |

**** 18.2字符串与数值转换

| 函数名  | 功能描述       | 函数名  | 功能描述       |
| num2str | 变数值为字符串 | sprintf | 数值的格式输出 |
| str2num | 变字符串为数值 | sscanf  | 数值的格式输入 |
| int2str | 变整数为字符串 |         |                |

**** 18.3进制转换

| 函数名  | 功能描述                         | 函数名  | 功能描述               |
| hex2num | 十六进制到IEEE标准下浮点数的轮换 | hex2dec | 十六进制到十进制的轮换 |
| dec2hex | 十进制到十六进制的轮换           |         |                        |

*** 19 文件输入输出函数
**** 19.1基本文件输入输出

| 函数名  | 功能描述                 | 函数名  | 功能描述               |
| fclose  | 关闭文件                 | feof    | 文件结尾检测           |
| fopen   | 打开文件                 | ferror  | 文件I/O错误查询        |
| fread   | 读二进制流文件           | frewind | 文件指针回绕           |
| fwrite  | 写二进制流文件           | fseek   | 设置文件指针位置       |
| fgetl   | 读文本文件（无行结束符） | ftell   | 获得文件指针位置       |
| fgets   | 读文本文件（含行结束符） | sprintf | 格式化数据转换为字符串 |
| fprintf | 写格式化数据到文件       | sscanf  | 依数据格式化读取字符串 |
| fscanf  | 从文件读格式化数据       |         |                        |

**** 19.2特殊文件输入输出

| 函数名  | 功能描述                  | 函数名     | 功能描述                          |
| imfinfo | 获得图形文件信息          | wklread    | 读一Lotus123WK1数据表             |
| imread  | 图像的文件读取            | wklwrite   | 将一矩阵写入Lotus123WK1数据表文件 |
| imwrite | 图像的文件保存            | xlgetrange | 读Excel表格文件的数据             |
| qrwrite | 保存一段QuickTime电影文件 | xlsetrange | 写Excel文件                       |

*** 20 位操作

| 函数名 | 功能描述             | 函数名   | 功能描述 |
| bitand | 位求与               | bitor    | 位求或   |
| bitcmp | 位求补               | bitset   | 位设置   |
| bitget | 位获取               | bitshift | 位移动   |
| bitmax | 求最大无符号浮点整数 | bitxor   | 位异或   |

*** 21 复杂数据类型
**** 21.1数据类型

| 函数名 | 功能描述       | 函数名 | 功能描述                 |
| cell   | 生成单元数组   | sparse | 生成稀疏数组             |
| char   | 生成字符串     | struct | 生成结构                 |
| double | 转换成双精度型 | uint8  | 转换成无字符号单字节整数 |
| inline | 生成INLINE对象 |        |                          |

**** 21.2结构操作

| 函数名     | 功能描述                 | 函数名      | 功能描述             |
| fieldnames | 获得结构的子段名         | rnfield     | 删除结构子段         |
| getfield   | 获得结构的子段值         | setfield    | 设置结构的子段值     |
| isfield    | 如果子段属于结构则返回真 | struct      | 生成结构数组         |
| isstruct   | 如果是结构则返回真       | struct2cell | 结构到单元数组的转换 |

**** 21.3多维数组操作

| 函数名   | 功能描述             | 函数名   | 功能描述                 |
| cat      | 数组连接             | permute  | 任意改变矩阵维数序列     |
| ipermute | 任意改变矩阵维数序列 | shiftdim | 矩阵维数序列的左移变换   |
| ndims    | 求矩阵维数           | squeeze  | 去除多维数组中的一维向量 |
| ndgrid   | N维数组生成          |          |                          |

**** 21.4单元数组操作

| 函数名      | 功能描述               | 函数名      | 功能描述                 |
| cell        | 单元数组生成           | iscell      | 如果是单元数组则返回真   |
| celldisp    | 显示单元数组内容       | num2cell    | 将数值数组转换为单元数组 |
| cellplot    | 单元数组内容的图形显示 | struct2cell | 将结构数组转换为单元数组 |
| cell2struct | 单元数组转换成结构数组 |             |                          |

**** 21.5面向对象函数

| 函数名     | 功能描述                     | 函数名     | 功能描述             |
| class      | 生成一个对象                 | methods    | 显示所有方法名       |
| isa        | 如果是某一给定类对象则返回真 | struct     | 将对象转换为结构数组 |
| isobject   | 如果是一个对象则返回真       | superiorto | 建立类间的关系检里   |
| inferiorto | 建立类间的关系检里           |            |                      |

*** 22 日期与时间

| 函数名   | 功能描述                     | 函数名  | 功能描述       |
| now      | 以数字形式给出当前日期和时间 | weekday | 星期函数       |
| date     | 以字符转形式给出当前日期     | eomday  | 月末日判断函数 |
| clock    | 以向量形式给出当前日期和时间 | cputime | 所用CPU的时间  |
| datenum  | 日期的数字形式转换           | tic     | 启动秒表计时器 |
| datestr  | 日期的字符串形式转换         | toc     | 读取秒表计时器 |
| datevec  | 日期的向量形式转换           | etime   | 使用时间函数   |
| calendar | 日历函数                     | pause   | 暂停函数       |

*** 23 动态数据交换

| 函数名  | 功能描述       | 函数名   | 功能描述    |
| ddeadv  | 设置DDE连接    | dderep   | 接收数据    |
| ddeexec | 发送要执行的串 | ddeterm  | DDE终止     |
| ddeinit | DDE初始化      | ddeunadv | 释放DDE连接 |
| ddepoke | 发送数据       |          |             |

** miscellaneous
*** MATLAB与VC混合编程                                                 :vc:

1. 使用matcom将m文件编译成C++文件，或可执行二进制文件，或库文件dll
2. COM(Component Object Model)接口方法，不支持脚本，仅支持函数，实现简
   单，通用性强，推荐。
3. 直接调用Matlab的C/C++库
4. 用Matlab自带的Matlab Compiler, 即命令mcc，将m文件编译成动态链接库等。
5. 通过Matlab Engine方式，使用C/S(客户机/服务器)模式，Matlab作为后台服
   务器，C程序作为前台客户机，效率不高。
6. 混合使用以上方法

* Java
* Programming
** Related
*** [[http://www.cnblogs.com/awpatp/archive/2011/02/27/1966380.html][Foo, Bar是什么意思？]]                                     :blog:foo:bar:

有些朋友问：foo, bar是什么意思, 为什么C++书籍中老见到这个词。

我google了一下，
发现没有很好的中文答案。这个问题，在维基百科上有很好的回答。在这里翻译
给大家。


译文：

术语*foobar*, *foo*, *bar*, *baz*
和 *qux* 经常在计算机编程或计算机相关的文档中被用作 [[http://en.wikipedia.org/wiki/Placeholder_name][占位符]] 的名字。当
变量，函数，或命令本身不太重要的时候，*foobar*,
*foo*, *bar*, *baz*
和*qux*就被用来充当这些实体的名字，这样做的目的仅仅是阐述一个概念，说
明一个想法。这些术语本身相对于使用的场景来说没有任何意义。Foobar经常被
单独使用；而当需要多个实体举例的时候，foo，bar，和baz则经常被按顺序使
用。

*** LAMP                                                             :lamp:

LAMP是指一组通常一起使用来运行动态网站或者服务器的自由软件名称首字母缩写：
+ Linux，操作系统
+ Apache，网页服务器
+ MariaDB或MySQL，数据库管理系统（或者数据库服务器）
+ PHP、Perl或Python，脚本语言

*** 编程风格

1. 重视函数的重用性

2. 必须注释函数的功能
   1) 函数注释描述的是想法，而非具体实现，因而更有价值。
   2) 在实际编程中，十分简单的函数是很少见的。
   3) 单个变量并不都需要注释，因为有时变量本身就带有自注释性。

*** 回车与换行

符号    ASCII码      意义
\n        10        换行NL
\r        13        回车CR

回车 \r 本义是光标重新回到本行开头，r的英文return，控制字符可以写成CR，即Carriage Return
换行 \n 本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成LF，即Line Feed

换行好理解，就是跳到下一行嘛

回车嘛

在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。
于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。
这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。
后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。
Unix系统里，每行结尾只有“<换行>”，即“\n”；Windows系统里面，每行结尾是“<换行><回车 >”，即“\n\r”；Mac系统里，每行结尾是“<回车>”(新的OSX的结尾同Unix）。一个直接后果是，Unix/Mac系统下的文件在Windows里打开 的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。

*** 正斜杠与反斜杠
+ 正斜杠，又称左斜杠，符号是 "/"
+ 反斜杠，也称右斜杠，符号是 "\"
+ 巧记： 斜的第一划为正，第二划为反

*** [[http://www.iplaysoft.com/top10-programming-fonts.html][10大最适合编程的字体推荐下载，让代码看起来更美更舒服！]]           :blog:

#+DOWNLOADED: http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/10fonts.jpg @ 2016-01-26 20:18:30
 [[~/Wally/Journal/Figure/.org-download/Tasks/10fonts_2016-01-26_20:18:29.jpg]]


现在有事没事就喜欢写写代码的人越来越多了，对于成天盯着屏幕工作的开发人
员来说，编程代码可能是每天见得最多的东西了。可是绝大部分人都一直使用编
辑器默认的字体，其实，换一套适合自己的[[http://www.iplaysoft.com/top10-programming-fonts.html][编程字体]]不仅能让代码看得更舒服，
甚至还能提高工作效率的！

如果你有想过换一种*编程字体*，却不知道哪里找合适的，那么看看异次元软件
世界为您推荐的[[http://www.iplaysoft.com/top10-programming-fonts.html][10款最适合编程的字体 ]]吧，这些字体能让你的代码瞬间“优雅”起
来！换一种字体，换一番心情嘛。当然，除了编程之外，经常需要编辑英文文档
的朋友同样适用......

**** 前言：


下面字体的排序是作者的主观感受，每个人的喜好都不一样。建议您都试试，按照自己的喜好来选择。另外，还在使用
[[http://www.iplaysoft.com/winxp-sp3-vol.html][Windows XP]]
的同学，如果您希望显示到如截图中清晰的字体效果，则必须安装微软的[[http://dl.iplaysoft.com/files/1090.html][ClearType设置程序]]对清晰度进行设置。

**** 10. Courier

也叫Courier New，这大概是我们最熟悉的[[http://www.iplaysoft.com/top10-programming-fonts.html][字体 ]]了，基本上所有系统都有。很不
幸，很多终端和编辑器都默认使用此种字体，虽然不会影响使用，但它太无趣了。
如果你正在使用这种字体，建议调大一点，并打开系统的

anti-aliasing (抗锯齿) 设置。

#+DOWNLOADED: http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image001.png @ 2016-01-26 20:19:26
 [[~/Wally/Journal/Figure/.org-download/Tasks/clip_image001_2016-01-26_20:19:26.png]]

[[http://dl.iplaysoft.com/files/1079.html][下载 Courier New 字体]]

**** 9. Andale Mono

比Courier稍好，也是常见的默认[[http://www.iplaysoft.com/top10-programming-fonts.html][字体]] 。我感觉字母太宽了，字符间距也比较蠢。

#+DOWNLOADED: http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image002.png @ 2016-01-26 20:19:45
 [[~/Wally/Journal/Figure/.org-download/Tasks/clip_image002_2016-01-26_20:19:45.png]]

[[http://dl.iplaysoft.com/files/1080.html][下载 Andale Mono 字体]]

**** 8. Monaco

Mac的默认字体，好像也只有Mac上有。小字号的时候表现不错，而且再大些也不
寒碜。

#+DOWNLOADED: http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image003.png @ 2016-01-26 20:19:51
 [[~/Wally/Journal/Figure/.org-download/Tasks/clip_image003_2016-01-26_20:19:51.png]]

[[http://dl.iplaysoft.com/files/1081.html][下载 Monaco 字体]]

**** 7. Profont

与Monaco类似的位图字体，你能够在Mac,
Windows和Linux上面使用。小字号的时候表现好。非Mac平台上Monaco的最佳替代。喜欢小字号且不怕眼睛疲劳的同学可以考虑。

#+DOWNLOADED: http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image004.png @ 2016-01-26 20:19:56
 [[~/Wally/Journal/Figure/.org-download/Tasks/clip_image004_2016-01-26_20:19:56.png]]

[[http://dl.iplaysoft.com/files/1082.html][下载 Profont 字体]]

**** 6. Monofur

独特的等宽字体，各种字号下都表现不错，但是需要设置anti-aliasing。怀旧而且喜欢与众不同的人推荐。

#+DOWNLOADED: http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image005.png @ 2016-01-26 20:20:00
 [[~/Wally/Journal/Figure/.org-download/Tasks/clip_image005_2016-01-26_20:20:00.png]]

[[http://dl.iplaysoft.com/files/1083.html][下载 Monofur 字体]]

**** 5. Proggy

干净的等宽字体，好像很受Windows用户欢迎，但在Mac上也不错。使用时，字号可以小一点，无需anti-aliasing。

#+DOWNLOADED: http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image006.png @ 2016-01-26 20:20:04
 [[~/Wally/Journal/Figure/.org-download/Tasks/clip_image006_2016-01-26_20:20:04.png]]

[[http://dl.iplaysoft.com/files/1084.html][下载 Proggy 字体]]

**** 4. Droid Sans Mono

开源 [[http://www.iplaysoft.com/top10-programming-fonts.html][字体 ]]，可以在这里下载，适合手机屏幕。是等宽字体中最突出的一个。可惜0和O区别不大。

#+DOWNLOADED: http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image007.png @ 2016-01-26 20:20:11
 [[~/Wally/Journal/Figure/.org-download/Tasks/clip_image007_2016-01-26_20:20:11.png]]

[[http://dl.iplaysoft.com/files/1085.html][下载 Droid Sans Mono 字体]]

**** 3. Deja Vu Sans Mono

我最喜欢的免费字体系列，以Vera为基础，但是比后者提供更多字符了。适于任何字号，需要anti-aliasing。

#+DOWNLOADED: http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image008.png @ 2016-01-26 20:20:15
 [[~/Wally/Journal/Figure/.org-download/Tasks/clip_image008_2016-01-26_20:20:15.png]]

[[http://dl.iplaysoft.com/files/1086.html][下载 Deja Vu Sans Mono 字体]]

**** 2. Consolas + 中文雅黑混合版

Consolas
是商业字体，专门为微软设计，微软不少产品上都有，所以很可能你的系统上已经有了。需要anti-aliasing。如果不是商业的，我可能就把它放第一了。Consolas仅含英文字母部分，这里提供的是雅黑中文+Consolas英文的混合体，即使代码里有中文注释显示效果也能很好的！

#+DOWNLOADED: http://ips.chotee.com/wp-content/uploads/2010/32cf352b3fcc_C546/clip_image009.png @ 2016-01-26 20:20:21
 [[~/Wally/Journal/Figure/.org-download/Tasks/clip_image009_2016-01-26_20:20:21.png]]

[[http://www.iplaysoft.com/consolas.html][下载 Consolas 雅黑字体]]

**** 1. Inconsolata

我最喜欢的等宽字体，免费。我遇到它之后，很快就把原来的默认字体Deja Vu
Sans
Mono抛弃了。真正适合任何字号的好 [[http://www.iplaysoft.com/top10-programming-fonts.html][字体]] 。感谢它的创造者Raph
Levien！

** Doxygen                                                         :doxygen:

*** reference

-  [[http://www.stack.nl/~dimitri/doxygen/index.html][Homepage]]

*** install                                                       :install:

apt-get

*** guide                                                           :guide:
**** what

Doxygen is the de facto /standard tool/ for generating /documentation/
from annotated C++ sources, but it also supports other popular
programming languages such as C, Objective-C, C#, PHP, Java, Python,
IDL (Corba, Microsoft, and UNO/OpenOffice flavors), Fortran, VHDL,
Tcl, and to some extent D.

**** 特性 & why

+ 文档生成器
+ 多语言
+ 跨平台
+ 输出多种格式
+ 支持多种注释风格
+ 自由软件

**** 工件流程

[[/home/ben/Wally/Journal/Figure/scrot/14780asM.png]]

**** usage

1. 生成文档
   1) 生成配置文件： /doxygen -g <cfg-file>/ 默认名 /Doxyfile/
   2) 修改配置文件
   3) 生成文档: /doxygen [cfg-file]/

2. 生成不含注释的文件: /doxygen -s/

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{text}
   $ doxygen -h
  Doxygen version 1.8.9.1
  Copyright Dimitri van Heesch 1997-2015

  You can use doxygen in a number of ways:

  1) Use doxygen to generate a template configuration file:
      doxygen [-s] -g [configName]

      If - is used for configName doxygen will write to standard output.

  2) Use doxygen to update an old configuration file:
      doxygen [-s] -u [configName]

  3) Use doxygen to generate documentation using an existing configuration file:
      doxygen [configName]

      If - is used for configName doxygen will read from standard input.

  4) Use doxygen to generate a template file controlling the layout of the
     generated documentation:
      doxygen -l [layoutFileName.xml]

  5) Use doxygen to generate a template style sheet file for RTF, HTML or Latex.
      RTF:        doxygen -w rtf styleSheetFile
      HTML:       doxygen -w html headerFile footerFile styleSheetFile [configFile]
      LaTeX:      doxygen -w latex headerFile footerFile styleSheetFile [configFile]

  6) Use doxygen to generate a rtf extensions file
      RTF:   doxygen -e rtf extensionsFile

  If -s is specified the comments of the configuration items in the config file will be omitted.
  If configName is omitted `Doxyfile' will be used as a default.

  -v print version string
  \end{minted}
#+end_latex

**** 配置选项

|------------------------------+--------------------------------------------------|
| PROJECT = my_proj            | 项目名称                                         |
| DOXYGEN_ENCODING = UTF-8     | 文件编码格式, UTF/GB2312                         |
| PROJECT_NUMBER = 1.0         | 文档版本号                                       |
| OUTPUT_DIRECTORY = "doc/"    | 输出目录                                         |
| OUTPUT_LANGUAGE = Chinese    | 程序文档广语言环境                               |
| OPTIMIZED_OUTPUT_FOR_C = YES | C文档, 否则C++                                   |
| TYPEDEF_HIDES_STRUCT = YES   | typedef定义的结构体只按typedef定义的类型名文档化 |
| HIDE_SCOPE_NAMES = YES       | C++中为NO,                                       |
| QUIET = YES                  | 只有警告或错误时才输出提示信息                   |
| INPUT_ENCODING               | 输入文件编码                                     |
| FILE_PATTERNS = *.h          | 只对头文件文档化                                 |
| RECURSIVE = YES              | 递归子目录                                       |
| EXAMPLE_PATH = example/      | 示例程序目录                                     |
| REFERENCED_BY_RELATION = YES | 显示函数调用关系                                 |
| REFERENCE_RELATION = YES     |                                                  |
| REFERENCE_LINK_SOURCE = YES  |                                                  |
| GENERATE_LATEX = NO          | 不生成程序latex文档                              |
| HAVE_DOT = YES               | 允许图例形式显示函数调用关系                     |
| CALL_GRAPH = YES             |                                                  |
| CALLER_GRAPH = YES           |                                                  |
|------------------------------+--------------------------------------------------|

**** 测试

使用默认配置

生成了 html(包含 索引页 /index/) 和 latex(包含 /makefile/ ) 两个子目录

/RECURSIVE/  配置为 YES 递归包含子目录
*** Doxygen注释

1. 文件注释

   文件用途,作者,创建修改日期等. eg.

   [[/home/ben/Wally/Journal/Figure/scrot/14780n2S.png]]

   注释关键字
   + @file
   + @brief
   + @author
   + @data
   + @version
   + ...
   + 关键字后必须有空格
   + 简要描述与详细描述之间隔一个空行

2. 函数注释

   [[/home/ben/Wally/Journal/Figure/scrot/147800AZ.png]]

   [[/home/ben/Wally/Journal/Figure/scrot/14780BLf.png]]

   [[/home/ben/Wally/Journal/Figure/scrot/14780OVl.png]]

   注: @return等关键字与示例之间至少隔一个空行.

3. 结构体注释

   结构体,枚举,联合等注释

   [[/home/ben/Wally/Joural/Figures/scrot/14780bfr.png]]

   [[/home/ben/Wally/Journal/Figure/scrot/14780opx.png]]

*** [[http://blog.csdn.net/czyt1988/article/details/8901191][Doxygen注释风格]]

下载国外的源代码，往往能看到附带的说明文档，文档都有详细的说明，大部分
文档都可以通过doxygen这个跨平台软件生成，doxygen并不能随便读取你的C++
的注释,必须按照一定的规则才能生成，所以在编写代码时，一定要按照标准写
注释，否则会为以后带来许多麻烦。

_c++不推荐c语言式的/* */风格注释_ ，这里，除了文件头使用这种注释外其余
到使用C++风格的注释。

**** 头文件

#+BEGIN_EXAMPLE
  /*!
  ,* \file Ctext.h
  ,* \brief 概述
  ,*
  ,*详细概述
  ,*
  ,* \author 作者名字
  ,* \version 版本号(maj.min，主版本.分版本格式)
  ,* \date 日期
  */
#+END_EXAMPLE

**** 命名空间

#+BEGIN_EXAMPLE
  /// \brief 命名空间的简单概述
  ///
  ///命名空间的详细概述
  namespace text
  {
   ……
  }
#+END_EXAMPLE

**** 类说明

#+BEGIN_EXAMPLE
  /// \brief Ctext的doxygen测试
  ///
  /// 作doxygen测试用
  class Ctext
  {
  }
#+END_EXAMPLE

注：
+ 如果想生成私有成员（doxygen默认不生成私有成员），可以如下设置选择
  Expert标签的Build项，勾选EXTRACT_PRIVATE即可

**** 函数说明

1. 方法1

   #+BEGIN_EXAMPLE
     /// \brief 函数简要说明-测试函数
     /// \param n1 参数1
     /// \param c2 参数2
     /// \return 返回说明
     bool text(int n1,Ctext c2);
   #+END_EXAMPLE

2. 方法2

   #+BEGIN_EXAMPLE
     /// \brief 函数简要说明-测试函数
     ///
     /// 函数详细说明，这里写函数的详细说明信息，说明可以换行
     /// ，如这里所示，同时需要注意的是详细说明和简要说明之间必须空一行
     /// ，详细说明之前不需要任何标识符
     /// \param n1 参数1说明
     /// \param c2 参数2说明
     /// \return 返回说明
     /// \see text
     bool text2(int n1,Ctext c2);
   #+END_EXAMPLE

3. 原则

   + 函数详细注释位于头文件，cpp文件只对函数做简明注释
   + cpp文件不做///的注释，否则会和头文件重叠
   +

**** 变量和枚举

#+BEGIN_EXAMPLE
  int m_a;     ///< 成员变量1m_a说明
  double m_b; ///< 成员变量2m_b说明


  /// \brief 成员变量m_c简要说明
  ///
  /// 成员变量m_c的详细说明，这里可以对变量进行
  ///详细的说明和描述，具体方法和函数的标注是一样的
  float m_c;


  /// \brief xxx枚举变量的简要说明
  ///
  /// xxx枚举变量的详细说明--枚举变量的详细说明和函数的详细说明
  ///的写法是一致的。每个枚举变量下可以进行单独说明
  enum{
          em_1,///< 枚举值1的说明
          em_2,///< 枚举值2的说明
          em_3 ///< 枚举值3的说明
  };
#+END_EXAMPLE

+ 变量注释用///< 对变量进行说明，对于详细信息可以加
  \textbackslash{}brief

+ 如果变量需要详细说明的可已按照m_c的写法写，注意，m_b和m_c之间一定需
  要空行

**** 中文问题

中文有时候是乱码。

对于vs2010的文档，默认是gb2312，可以设置Expert标签的Project项目的
DOXYFILE_ENCODING 为 GB18030 INPUT_ENCODING 为 GB18030

另外Project项目的生成语言（OUTPUT_LANGUAGE）选择Chinese

对于其他的代码文件如果中文乱码，可以用文本编辑器转换代码文本编码为
UTF-8带BOM的（注意这有可能影响代码，所以转换编码时要备份），再进行导出。

*** note                                                             :note:

1. PDF vs HTML

   更喜欢 PDF，可以标注、搜索方便等

2. API vs Source Code

   更喜欢后者！

** 正则表达式                                                       :regexp:
*** [[http://www.jb51.net/tools/zhengze.html][正则表达式入门]]

**** regexp

在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的
需要。正则表达式就是用于描述这些规则的工具。换句话说， *正则表达式就是
记录文本规则的代码*

注:  _通配符不是正则表达式_

/正则表达式引擎/ 通常会提供一个“测试指定的字符串是否匹配一个正则表达式”
的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。

这里的 *匹配是指是字符串里有没有符合表达式规则的部分* 。如果不使用^和$
的话，对于\textbackslash{}d{5,12}而言，使用这样的方法就只能保证字符串
里包含5到12连续位数字，而不是整个字符串就是5到12位数字。

**** 元字符 Metacharacter                           :元字符:metacharacter:

- \b  开头或结尾, 也就是单词的分界

  通常英文的单词是由空格，标点符号或者换行来分隔的，但是 \b 并不匹配这词
  分隔字符中的任何一个，它 *只匹配一个位置*

- .  匹配除换行符外的所有字符

- *  表示前面的内容可以重复任意次,包括零次

- +  表示前面的内容可以重复一次可更多次

- ?  表示前面内容重复一次可零次

- \n  匹配换行符

- \d  匹配一位数字

- {n}  表示前面的内容必须连续匹配n次

- {m,n}  表示前面的内容必须重复不少于m次不多于n次

- \s  匹配任意的空白符,包括空格,制表符,换行符, 中文全角空格

- \w  匹配字母,数字,下划线或汉字

- ^  匹配字符串的开始

  正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的
  意义就变成了匹配行的开始处和结束处。

- $  匹配字符串的结束

- ()  分组

  |----------+--------------+------------------------------------------------|
  | 分组     | (exp)        | 匹配exp,并捕获文本到自动命名的组里             |
  |----------+--------------+------------------------------------------------|
  | 捕获     | (?<name>exp) | 匹配exp,并捕获文本到名称为name的组里，         |
  |          |              | 可以写成(?'name'exp)                           |
  |          | (?:exp)      | 匹配exp,不捕获匹配的文本，也不给此分组分配组号 |
  |----------+--------------+------------------------------------------------|
  | 零宽断言 | (?=exp)      | 匹配exp前面的位置                              |
  |          | (?<=exp)     | 匹配exp后面的位置                              |
  |          | (?!exp)      | 匹配后面跟的不是exp的位置                      |
  |          | (?<!exp)     | 匹配前面不是exp的位置                          |
  |----------+--------------+------------------------------------------------|
  | 注释     | (?#comment)  | 用于提供注释让人阅读                           |
  |----------+--------------+------------------------------------------------|

+ []

+ \W  匹配任意不是字母，数字，下划线，汉字的字符

+ \S  匹配任意不是空白符的字符

+ \D  匹配任意非数字的字符

+ \B  匹配不是单词开头或结束的位置

+ [^x]  匹配除了x以外的任意字符

+ [^aeiou]  匹配除了aeiou这几个字母以外的任意字符*

**** 字符转义

使用 \ 对元字符进行转义, 如 \., \*, \\.

**** 重复

|-------+------------------|
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ?     | 重复零次或一次   |
| {n}   | 重复n次          |
| {n,}  | 重复n次或更多次  |
| {n,m} | 重复n到m次       |
|-------+------------------|

**** 字符合集  方括号括起

+ [aeiou]  匹配元音字母
+ [0-9]    等价于 \d.
+ [a-z0-9Z-Z] 等价于 \w.

**** 分枝条件 |

"|" 把不同的规则分隔开.

#+BEGIN_EXAMPLE
\d{5}-\d{4}|\d{5}
#+END_EXAMPLE

这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9
位数字。

*注:使用分枝条件时，要注意各个条件的顺序。原因是匹配分枝条件时，将会从左到右
地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。*

如果你把它改成 的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。

#+BEGIN_EXAMPLE
\d{5}|\d{5}-\d{4}
#+END_EXAMPLE

**** 分组

我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要
重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可
以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有
介绍)。

eg.

#+BEGIN_EXAMPLE
(\d{1,3}\.){3}\d{1,3}
#+END_EXAMPLE

是一个简单的IP地址匹配表达式。

**** 反义

+ \W  匹配任意不是字母，数字，下划线，汉字的字符
+ \S  匹配任意不是空白符的字符
+ \D  匹配任意非数字的字符
+ \B  匹配不是单词开头或结束的位置
+ [^x]  匹配除了x以外的任意字符
+ [^aeiou]  匹配除了aeiou这几个字母以外的任意字符

eg.

#+BEGIN_EXAMPLE
<a[^>]+>
#+END_EXAMPLE

匹配用尖括号括起来的以a开头的字符串。

**** 向后引用

后向引用用于重复搜索前面某个分组匹配的文本。

*使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获
的内容)可以在表达式或其它程序中作进一步的处理。*

默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括
号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

eg

#+BEGIN_EXAMPLE
\b(\w+)\b\s+\1 \b
#+END_EXAMPLE

可以用来匹配重复的单词，像go go, 或者kitty kitty。

- 分组0对应整个正则表达式

- 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第
  二遍  只给命名组分配---因此所有命名组的组号都大于未命名的组号

- 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．

- 可以自己指定子表达式的组名,使用这样的语法：
  *(?<NAME>\w+)* 或 *(?'NAME'\w+)*

- 要反向引用这个分组捕获的内容，使用 *\k<NAME>*

**** 注释

小括号的另一种用途是用来包含注释

#+BEGIN_EXAMPLE
(?#comment)
#+END_EXAMPLE

**** 选项

+ 忽略模式里的空白符, 这样可以在编写表达式时能任意添加空格
+ 忽略大小写
+ 多行模式/单行模式
+ 示式捕获

**** 贪婪模式

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能
得到匹配的前提下） _匹配尽可能多的字符_ 。这被称为 /贪婪匹配/ 。

有时，我们更需要 /懒惰匹配/ ，也就是匹配尽可能少的字符。

/只要在重复限定符后面加上一个问号 ?/

- *?	重复任意次，但尽可能少重复
- +?	重复1次或更多次，但尽可能少重复
- ??	重复0次或1次，但尽可能少重复
- {n,m}?	重复n到m次，但尽可能少重复
- {n,}?	重复n次以上，但尽可能少重复

#+BEGIN_EXAMPLE
a.*?b
#+END_EXAMPLE

匹配最短的，以a开始，以b结束的字符串。

** process                                                         :process:
*** [[http://www.ibm.com/developerworks/cn/linux/l-ipc/][深刻理解Linux进程间通信（IPC）]] :blog:

一个大型的应用系统，往往需要众多进程协作，进程（Linux进程概念见附1）间
通信的重要性显而易见。本系列文章阐述了Linux环境下的几种主要进程间通信
手段，并针对每个通信手段关键技术环节给出详细实例。为达到阐明问题的目的，
本文还对某些通信手段的内部实现机制进行了分析。

linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的。而对Unix发展做出重大贡献的两大主力AT&T的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心）在进程间通信方面的侧重点有所不同。前者对Unix早期的进程间通信手段进行了系统的改进和扩充，形成了“system
V
IPC”，通信进程局限在单个计算机内；后者则跳过了该限制，形成了基于套接口（socket）的进程间通信机制。Linux则把两者继承了下来，如图示：


其中，最初Unix IPC包括：管道、FIFO、信号；System V IPC包括：System
V消息队列、System V信号灯、System V共享内存区；Posix IPC包括：
Posix消息队列、Posix信号灯、Posix共享内存区。有两点需要简单说明一下：1）由于Unix版本的多样性，电子电气工程协会（IEEE）开发了一个独立的Unix标准，这个新的ANSI
Unix标准被称为计算机环境的可移植性操作系统界面（PSOIX）。现有大部分Unix和流行版本都是遵循POSIX标准的，而Linux从一开始就遵循POSIX标准；2）BSD并不是没有涉足单机内的进程间通信（socket本身就可以用于单机内的进程间通信）。事实上，很多Unix版本的单机IPC留有BSD的痕迹，如4.4BSD支持的匿名内存映射、4.3+BSD对可靠信号语义的实现等等。

图一给出了linux
所支持的各种IPC手段，在本文接下来的讨论中，为了避免概念上的混淆，在尽可能少提及Unix的各个版本的情况下，所有问题的讨论最终都会归结到Linux环境下的进程间通信上来。并且，对于Linux所支持通信手段的不同实现版本（如对于共享内存来说，有Posix共享内存区以及System
V共享内存区两个实现版本），将主要介绍Posix API。

linux下进程间通信的几种主要手段简介：

1. 管道（Pipe）及有名管道（named
   pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
2. 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；
3. 报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system
   V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
5. 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
6. 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System
   V的变种都支持套接字。

下面将对上述通信机制做具体阐述。

附1：参考文献[2]中对linux环境下的进程进行了概括说明：

一般来说，linux下的进程包含以下几个关键要素：

- 有一段可执行程序；
- 有专用的系统堆栈空间；
- 内核中有它的控制块（进程控制块），描述进程所占用的资源，这样，进程才能接受内核的调度；
- 具有独立的存储空间

进程和线程有时候并不完全区分，而往往根据上下文理解其含义。

**** 参考资料

- UNIX环境高级编程，作者：W.Richard
   Stevens，译者：尤晋元等，机械工业出版社。具有丰富的编程实例，以及关键函数伴随Unix的发展历程。
- linux内核源代码情景分析（上、下），毛德操、胡希明著，浙江大学出版社，提供了对linux内核非常好的分析，同时，对一些关键概念的背景进行了详细的说明。
- UNIX网络编程第二卷：进程间通信，作者：W.Richard
   Stevens，译者：杨继张，清华大学出版社。一本比较全面阐述Unix环境下进程间通信的书（没有信号和套接口，套接口在第一卷中）。

*** socket                                                         :socket:
**** [[http://www.cnblogs.com/dolphinX/p/3460545.html][简单理解Socket]]                                                 :blog:

***** 题外话

前几天和朋友聊天，朋友问我怎么最近不写博客了，一个是因为最近在忙着公司使用的一些控件的开发，浏览器兼容性搞死人；但主要是因为这段时间一直在看html5的东西，看到web
socket时觉得很有意思，动手写几个demo，但web
socket需要特定的服务器支持，由于标准制定工作还没完成，所以没有多少主流的服务器支持，自己在网上下载了几个实现，包括php的、C#的、甚至Node.js的，但一个是协议变化比较大，很多代码已经过时了，再就是有一些支持最新的标准，但是我想稍微改造一下，看人家源代码的时候云里雾里，看看别人的代码行数也不多，决定自己实现一个。

悲剧由此开始，虽然哥们儿国内非知名工科大学毕业，但好歹也是科班CS出身，但大学得过且过，什么TCP/IP协议，什么socket了都没概念。为了做出一个简单的支持广播的websocket
server，在网上找了很多相关代码，左抄一句，右抄一句，弄了一个星期竟然还是漏洞百出，调试不起来，只好从头来过了，先补一些基本知识，然后再一步步根据原理实现，今天终于实现了绝大部分功能，由此真的感受到了，搞计算机必须得有理论指导实践，否则只能像个没头苍蝇到处乱撞。

***** TCP/IP

要想理解socket首先得熟悉一下TCP/IP协议族， TCP/IP（Transmission Control
Protocol/Internet
Protocol）即传输控制协议/网间协议，定义了主机如何连入因特网及数据如何再它们之间传输的标准，

从字面意思来看TCP/IP是TCP和IP协议的合称，但实际上TCP/IP协议是指因特网整个TCP/IP协议族。不同于ISO模型的七个分层，TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中

应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等

传输层：TCP，UDP

网络层：IP，ICMP，OSPF，EIGRP，IGMP

数据链路层：SLIP，CSLIP，PPP，MTU

每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的

[[http://images.cnitblog.com/blog/349217/201312/05230830-04807bb739954461a8bfc7513707f253.jpg]]
[[http://images.cnitblog.com/blog/349217/201312/05230857-f49d5855f1e14a23a186737e0bec8a0f.gif]]

估计有兴趣打开此文的同学都对此有一定了解了，加上我也是一知半解，所以就不详细解释，有兴趣同学可以上网上搜一下资料

[[http://zh.wikipedia.org/wiki/TCP/IP][维基百科]][[http://zh.wikipedia.org/wiki/TCP/IP][
]]

[[http://baike.baidu.com/link?url=KJleEWJUBxe3XaxEaTU1lcQrg9qYN7FYzuPhoWVyoPFNk79NIURxAO6HSWC1MfrCU1Dh7QRsNDWOaZ-4bg5HRa][百度百科]]

在TCP/IP协议中两个因特网主机通过两个路由器和对应的层连接。各主机上的应用通过一些数据通道相互执行读取操作

[[http://images.cnitblog.com/blog/349217/201312/05221430-6bd4ce2a2cf7434ca9216c0a5b6a0985.png]]

***** socket

我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。

能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。

[[http://images.cnitblog.com/blog/349217/201312/05225723-2ffa89aad91f46099afa530ef8660b20.jpg]]

socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种"打开---读/写---关闭"模式的实现，服务器和客户端各自维护一个"文件"，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。

***** socket通信流程

socket是"打开---读/写---关闭"模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的

[[http://images.cnitblog.com/blog/349217/201312/05232335-fb19fc7527e944d4845ef40831da4ec2.png]]

服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket

服务器为socket绑定ip地址和端口号

服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开

客户端创建socket

客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket

服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入*阻塞*状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求

客户端连接成功，向服务器发送连接状态信息

服务器accept方法返回，连接成功

客户端向socket写入信息

服务器读取信息

客户端关闭

服务器端关闭

***** 三次握手

在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接

[[http://images.cnitblog.com/blog/349217/201312/05234233-eed6ddcba93c42be8847e98d6da62802.jpg]]

第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号/*Synchronize
Sequence Numbers*/），syn=j，客户端进入SYN_SEND状态等待服务器确认

第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态

第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手

定睛一看，服务器socket与客户端socket建立连接的部分其实就是大名鼎鼎的三次握手

[[http://images.cnitblog.com/blog/349217/201312/05234946-b80841921eae4d2ab983f26ed9023768.png]]

 *socket编程API*

前面提到socket是"打开---读/写---关闭"模式的实现，简单了解一下socket提供了哪些API供应用程序使用，还是以TCP协议为例，看看Unix下的socket
API，其它语言都很类似（PHP甚至名字都几乎一样），这里我就简单解释一下方法作用和参数，具体使用有兴趣同学可以看看博客参考中的链接或者上网搜索

#+BEGIN_EXAMPLE
    int socket(int domain, int type, int protocol);
#+END_EXAMPLE

根据指定的地址族、数据类型和协议来分配一个socket的描述字及其所用的资源。

domain:协议族，常用的有AF_INET、AF_INET6、AF_LOCAL、AF_ROUTE其中AF_INET代表使用ipv4地址

type:socket类型，常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等

protocol:协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等

#+BEGIN_EXAMPLE
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_EXAMPLE

把一个地址族中的特定地址赋给socket

sockfd:socket描述字，也就是socket引用

addr:要绑定给sockfd的协议地址

addrlen:地址的长度

/通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。/

#+BEGIN_EXAMPLE
    int listen(int sockfd, int backlog);
#+END_EXAMPLE

监听socket

sockfd:要监听的socket描述字

backlog:相应socket可以排队的最大连接个数

#+BEGIN_EXAMPLE
    int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_EXAMPLE

连接某个socket

sockfd:客户端的socket描述字

addr:服务器的socket地址

addrlen:socket地址的长度

#+BEGIN_EXAMPLE
    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
#+END_EXAMPLE

 TCP服务器监听到客户端请求之后，调用accept()函数取接收请求

sockfd:服务器的socket描述字

addr:客户端的socket地址

addrlen:socket地址的长度

#+BEGIN_EXAMPLE
    ssize_t read(int fd, void *buf, size_t count);
#+END_EXAMPLE

读取socket内容

fd:socket描述字

buf：缓冲区

count：缓冲区长度

#+BEGIN_EXAMPLE
    ssize_t write(int fd, const void *buf, size_t count);
#+END_EXAMPLE

向socket写入内容，其实就是发送内容

fd:socket描述字

buf：缓冲区

count：缓冲区长度

#+BEGIN_EXAMPLE
    int close(int fd);
#+END_EXAMPLE

socket标记为以关闭
，使相应socket描述字的引用计数-1，当引用计数为0的时候，触发TCP客户端向服务器发送终止连接请求。

***** 参考

[[http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html][Linux
Socket编程（不限Linux）]]

[[http://goodcandle.cnblogs.com/archive/2005/12/10/294652.aspx][揭开Socket编程的面纱
]]

PS.
有同学看完后发现没有demo示例，参考中的示例已经很不错了，我就不班门弄斧了，而且我用C#实现了一个websocket
server，接下来的博客中会有介绍。另外由于刚刚实际接触socket，文中谬误较多，还望大家批评指正，文章内容主要参考上面两个博文，图片全部来源于网络，在百度图片搜索得来，无法注明第一源地址，如有版权问题请站内信联系，第一时间处理。

**** [[http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html][Linux Socket 编程（不限Linux）]]                                 :blog:

“一切皆Socket！”

话虽些许夸张，但是事实也是，现在的网络编程几乎都是用的socket。

------有感于实际编程和开源项目研究。

我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket的基本函数，这些都是本文想介绍的。本文的主要内容如下：

- 1、网络中进程之间如何通信？
- 2、Socket是什么？
- 3、socket的基本操作

   -  3.1、socket()函数
   -  3.2、bind()函数
   -  3.3、listen()、connect()函数
   -  3.4、accept()函数
   -  3.5、read()、write()函数等
   -  3.6、close()函数

- 4、socket中TCP的三次握手建立连接详解
- 5、socket中TCP的四次握手释放连接详解
- 6、一个例子（实践一下）
- 7、留下一个问题，欢迎大家回帖回答！！！

***** 1、网络中进程之间如何通信？

本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：

- 消息传递（管道、FIFO、消息队列）
- 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）
- 共享内存（匿名的和具名的）
- 远程过程调用（Solaris门和Sun RPC）

但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“*ip地址*”可以唯一标识网络中的主机，而传输层的“*协议+端口*”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。

使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX
BSD的套接字（socket）和UNIX System
V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。

***** 2、什么是Socket？

上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open
--> 读写write/read -->
关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。

#+BEGIN_QUOTE
  *** socket一词的起源

  在组网领域的首次使用是在1970年2月12日发布的文献[[http://datatracker.ietf.org/doc/rfc33/][IETF
  RFC33]]中发现的，撰写者为Stephen Carr、Steve Crocker和Vint
  Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”
#+END_QUOTE

***** 3、socket的基本操作

既然socket是“open---write/read---close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。

****** 3.1、socket()函数

#+BEGIN_EXAMPLE
    int socket(int domain, int type, int protocol);
#+END_EXAMPLE

socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而*socket()*用于创建一个socket描述符（socket
descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。

正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：

- domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。
- type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。
- protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。

注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。

当我们调用*socket*创建一个socket时，返回的socket描述字它存在于协议族（address
family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。

****** 3.2、bind()函数

正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。

#+BEGIN_EXAMPLE
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_EXAMPLE

函数的三个参数分别为：

- sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。
- addr：一个const struct sockaddr
   *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：

   #+BEGIN_EXAMPLE
       struct sockaddr_in {
           sa_family_t    sin_family; /* address family: AF_INET */
           in_port_t      sin_port;   /* port in network byte order */
           struct in_addr sin_addr;   /* internet address */
       };

       /* Internet address. */
       struct in_addr {
           uint32_t       s_addr;     /* address in network byte order */
       };
   #+END_EXAMPLE

   ipv6对应的是：

   #+BEGIN_EXAMPLE
       struct sockaddr_in6 {
           sa_family_t     sin6_family;   /* AF_INET6 */
           in_port_t       sin6_port;     /* port number */
           uint32_t        sin6_flowinfo; /* IPv6 flow information */
           struct in6_addr sin6_addr;     /* IPv6 address */
           uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */
       };

       struct in6_addr {
           unsigned char   s6_addr[16];   /* IPv6 address */
       };
   #+END_EXAMPLE

   Unix域对应的是：

   #+BEGIN_EXAMPLE
       #define UNIX_PATH_MAX    108

       struct sockaddr_un {
           sa_family_t sun_family;               /* AF_UNIX */
           char        sun_path[UNIX_PATH_MAX];  /* pathname */
       };
   #+END_EXAMPLE

- addrlen：对应的是地址的长度。

通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。

#+BEGIN_QUOTE
  *** 网络字节序与主机字节序

  *主机字节序*就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：

  　　a)
  Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。

  　　b)
  Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。

  *网络字节序*：4个字节的32
  bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。*由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。*字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。

  所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。
#+END_QUOTE

****** 3.3、listen()、connect()函数

如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。

#+BEGIN_EXAMPLE
    int listen(int sockfd, int backlog);
    int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_EXAMPLE

listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。

connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。

****** 3.4、accept()函数

TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。

#+BEGIN_EXAMPLE
    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
#+END_EXAMPLE

accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct
sockaddr
*的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。

注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。

****** 3.5、read()、write()等函数

万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：

- read()/write()
- recv()/send()
- readv()/writev()
- recvmsg()/sendmsg()
- recvfrom()/sendto()

我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：

#+BEGIN_EXAMPLE
           #include <unistd.h>

           ssize_t read(int fd, void *buf, size_t count);
           ssize_t write(int fd, const void *buf, size_t count);

           #include <sys/types.h>
           #include <sys/socket.h>

           ssize_t send(int sockfd, const void *buf, size_t len, int flags);
           ssize_t recv(int sockfd, void *buf, size_t len, int flags);

           ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                          const struct sockaddr *dest_addr, socklen_t addrlen);
           ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                            struct sockaddr *src_addr, socklen_t *addrlen);

           ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
           ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
#+END_EXAMPLE

read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。

write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。
在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。

其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。

****** 3.6、close()函数

在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。

#+BEGIN_EXAMPLE
    #include <unistd.h>
    int close(int fd);
#+END_EXAMPLE

close一个TCP
socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。

注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。

***** 4、socket中TCP的三次握手建立连接详解

我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：

- 客户端向服务器发送一个SYN J
- 服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1
- 客户端再想服务器发一个确认ACK K+1

只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：

[[http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png][[[http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157476286.png]]]]

图1、socket中发送的TCP三次握手

从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN
J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN
J包，调用accept函数接收请求向客户端发送SYN K ，ACK
J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK
J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK
K+1时，accept返回，至此三次握手完毕，连接建立。

#+BEGIN_QUOTE
  总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。
#+END_QUOTE

***** 5、socket中TCP的四次握手释放连接详解

上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：

[[http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png][[[http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157494693.png]]]]

图2、socket中发送的TCP四次握手

图示过程如下：

- 某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；
- 另一端接收到FIN
   M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；
- 一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN
   N；
- 接收到这个FIN的源发送端TCP对它进行确认。

这样每个方向上都有一个FIN和ACK。

***** 6、一个例子（实践一下）

说了这么多了，动手实践一下。下面编写一个简单的服务器、客户端（使用TCP）------服务器端一直监听本机的6666号端口，如果收到连接请求，将接收请求并接收客户端发来的消息；客户端与服务器端建立连接并发送一条消息。

服务器端代码：

[[http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif]][[http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif]]服务器端

#+BEGIN_EXAMPLE
    #include<stdio.h>#include<stdlib.h>#include<string.h>#include<errno.h>#include<sys/types.h>#include<sys/socket.h>#include<netinet/in.h>#define MAXLINE 4096int main(int argc, char** argv){    int    listenfd, connfd;    struct sockaddr_in     servaddr;    char    buff[4096];    int     n;    if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ){    printf("create socket error: %s(errno: %d)\n",strerror(errno),errno);    exit(0);    }    memset(&servaddr, 0, sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);    servaddr.sin_port = htons(6666);    if( bind(listenfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) == -1){    printf("bind socket error: %s(errno: %d)\n",strerror(errno),errno);    exit(0);    }    if( listen(listenfd, 10) == -1){    printf("listen socket error: %s(errno: %d)\n",strerror(errno),errno);    exit(0);    }    printf("======waiting for client's request======\n");    while(1){    if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1){        printf("accept socket error: %s(errno: %d)",strerror(errno),errno);        continue;    }    n = recv(connfd, buff, MAXLINE, 0);    buff[n] = '\0';    printf("recv msg from client: %s\n", buff);    close(connfd);    }    close(listenfd);}
#+END_EXAMPLE

客户端代码：

[[http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif]][[http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif]]客户端

#+BEGIN_EXAMPLE
    #include<stdio.h>#include<stdlib.h>#include<string.h>#include<errno.h>#include<sys/types.h>#include<sys/socket.h>#include<netinet/in.h>#define MAXLINE 4096int main(int argc, char** argv){    int    sockfd, n;    char    recvline[4096], sendline[4096];    struct sockaddr_in    servaddr;    if( argc != 2){    printf("usage: ./client <ipaddress>\n");    exit(0);    }    if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){    printf("create socket error: %s(errno: %d)\n", strerror(errno),errno);    exit(0);    }    memset(&servaddr, 0, sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_port = htons(6666);    if( inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0){    printf("inet_pton error for %s\n",argv[1]);    exit(0);    }    if( connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0){    printf("connect error: %s(errno: %d)\n",strerror(errno),errno);    exit(0);    }    printf("send msg to server: \n");    fgets(sendline, 4096, stdin);    if( send(sockfd, sendline, strlen(sendline), 0) < 0)    {    printf("send msg error: %s(errno: %d)\n", strerror(errno), errno);    exit(0);    }    close(sockfd);    exit(0);}
#+END_EXAMPLE

当然上面的代码很简单，也有很多缺点，这就只是简单的演示socket的基本函数使用。其实不管有多复杂的网络程序，都使用的这些基本函数。上面的服务器使用的是迭代模式的，即只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力是很弱的，现实中的服务器都需要有并发处理能力！为了需要并发处理，服务器需要fork()一个新的进程或者线程去处理请求等。

***** 7、动动手

留下一个问题，欢迎大家回帖回答！！！是否熟悉Linux下网络编程？如熟悉，编写如下程序完成如下功能：

服务器端：

接收地址192.168.100.2的客户端信息，如信息为“Client
Query”，则打印“Receive Query”

客户端：

向地址192.168.100.168的服务器端顺序发送信息“Client Query test”，“Cleint
Query”，“Client Query Quit”，然后退出。

题目中出现的ip地址可以根据实际情况定。

------本文只是介绍了简单的socket编程。

更为复杂的需要自己继续深入。

******* [[http://www.cnblogs.com/skynet/archive/2010/12/04/1881236.html][（unix
domain
socket）使用udp发送>=128K的消息会报ENOBUFS的错误]]（一个实际socket编程中遇到的问题，希望对你有帮助）

** webkit                                                           :webkit:

- [[https://zh.wikipedia.org/wiki/WebKit][Wikipedia]]
- [[http://baike.baidu.com/link?url=RIYUMJ2DqOQoeh8LEc7kpheik6ryyP4FWbHvUXZyW7f5GtHUbC0q_wsTNHHAsqrizaIAZol1O-cN_o_Gh3lwa_][百度百科]]

WebKit是一种用来 *让网页浏览器绘制网页的排版引擎* 。它被用于Apple Safari。
其分支被用于基于Chromuim的网页浏览器，如：Opera与Google Chrome。

OS X、Windows、GNU/Linux以及其他类Unix系统操作系统，皆支援这个专案.

WebKit的WebCore及JavaScriptCore元件使用GNU宽通用公共许可证，其他元件则
采用BSD许可证


WebKit的火爆也是得益于浏览器和 *WebOS* 的混战，随着Palm WebOS, Chrome
OS, Firefox OS和Ubuntu Mobile相继发布，WebOS逐渐成为Android和IOS之外的
第三世界，而WebKit也随之从浏览器内核晋升为Mobile OS的内核，除了IE和
Firefox之外，市面上叫得上名字的都是基于WebKit发展起来，Chrome, Safari,
Opera, 360......。因此，无论你是从事浏览器还是Mobile的开发，WebKit都是
不二的选择。

平台.

*** [[http://blog.csdn.net/cutesource/article/details/8731841][探索WebKit内核（一）------ 菜鸟起步]]                              :blog:

**** 为什么搞WebKit

现在研究WebKit的人越来越多，俺不能免俗，也加入其中。WebKit的火爆也是得
益于浏览器和WebOS的混战，随着Palm WebOS, Chrome OS, Firefox OS和Ubuntu
Mobile相继发布，WebOS逐渐成为Android和IOS之外的第三世界，而WebKit也随
之从浏览器内核晋升为Mobile OS的内核，除了IE和Firefox之外，市面上叫得上
名字的都是基于WebKit发展起来，Chrome, Safari, Opera, 360......。因此，
无论你是从事浏览器还是Mobile的开发，WebKit都是不二的选择。而我目前是因
为需要在WebOS上提供一个类似与Chrome for android那样可以远程debug的功能，
而接触到WebKit，随着不断深入，也逐渐步入WebKit的开发正轨，也是想把最近
的学习历程记录下来，也是帮助其他朋友进这个大门，WebKit的资料实在不多。

**** 如何起步

我就假定你和我一样，从没接触过WebKit，没写过c/c++，被Java/PHP等傻瓜式
语言惯坏了，对设备底层技术不甚了解，在这种情况下（不可能比这个更糟了），
也是可以在一周左右入这个门槛的。正式开工之前先准备以下几步：


-  学习文章：http://paulirish.com/2013/webkit-for-developers/， 当然也
  有中文版本：http://www.infoq.com/cn/articles/webkit-for-developers，
  弄清楚WebKit的几个概念

-  准备一台CPU和硬盘较好的电脑，CPU是为了应付编译，硬盘是为了应付大规
  模代码的访问（去年7月份买的mac已不够用，特地为此换了SSD）

-  开发平台最好是Xcode，Visual Studio也行，不过可能会遇到很多坎、

-  准备一本C++ Primmer Plus放在手边，研究WebKit同时顺便把C++也给攻克了

-  给予足够的耐心，应付漫长的源码下载和编译

好了，就这么多，可以开工了。关于如何编译和调试等问题，我会在后续文章中详细介绍。

**** 开工之前的扫盲

***** WebKit port

WebKit已发展为类似与Linux这样平台性的框架，已不是单一产品类型的开源项
目。它是一个标准和变异的结合体。下面这张图能很好说明这点：

#+DOWNLOADED: http://img.my.csdn.net/uploads/201303/28/1364458676_4777.png @ 2016-01-27 12:41:58
 [[~/Wally/Journal/Figure/.org-download/webkit/1364458676_4777_2016-01-27_12:41:58.png]]

WebKit提供了像这张图这样的标准架构和WebCore这样的核心库，但灰色的其他部分都是要根据各自平台的不同而进行替换和移植，也就是谈及很多的port，这里谈的平台就是各自设备的运行环境，比如mac
os
x，Android和IOS，因此虽然咱是用WebKit，但可以做的事情还有很多，WebKit只是提供了流程和框架，里面有很多洞需要咱自己去填补的。比如，我现在做的远程调试功能，在WebKit里面已在流程上支持，但具体实现上是需要port的，也就导致了只有chrome
for android和safari for
IOS支持远程调试。开头介绍的文章中已罗列出哪些点是标准已实现的，哪些点是差异化的，从这里面大概就能预计到需要做哪些东西。

***** 学习平台的选择

官方的 WebKit 是以Safari for Mac OSX为基础的，Chromium虽然也是基于
WebKit，但基本上已是另外一套，还有QT和GTK平台，有很多浏览器，比如Opera
和360都选择了基于Chromium，那对于我们这些初学者来说该如何选择学习的起
点呢？我的感觉是， *标准的WebKit门槛低一点，文档要丰富一些，但作为将来
工程的方向，Chromium更受欢迎一些* ，所以，我推荐以官方的WebKit为起点，然后
再延伸到Chromium。后面我会谈开发环境的搭建，基于官方的WebKit，再加上
XCode，会感觉手上很顺滑，不至于像大多数大型开源项目那样在最开始就把你
拒之门外。

**** 开始动手

下面我介绍动手的几个步骤，可以在你无需了解细节的情况下，把环境搭起来，
大多数包括我自己，都还是习惯于代码和环境搭建好情况下，比较有心情和底气
去往下深入，所以耐心地完成下面几步，你就可以在开发环境中启动WebKit，这
里我介绍的是Mac下的情况，但在windows和linux会困难一些，起码我是受阻后
就放弃了：

1. 升级Mac OSX和Xcode至最新版本，我的是Mountain Lion 10.8.3和Xcode 4.6。
   做这个是因为我的一个哥们用的是lion，用的一样的步骤，但启动后一直报
   内存访问错误，升级系统至最新后就解决了。当然，别忘记了xcode command
   line

2. 取得最新代码：svn checkout
   https://svn.webkit.org/repository/webkit/trunk
   当然，这个过程是需要耐心的，特别是下载layout
   test时，为了将来的一马平川，忍忍吧

3. Xcode的菜单File->Workspace Settings->Build->Derived Data
   Location一栏选择Workspace-relative，并输入WebKitBuild->Done\\

4. Xcode的菜单Product->Scheme->Edit Scheme->选择scheme: All
   Source(target WebProcess), Exceutable选择WebProcess.app\\

如果你是下载的是最新代码，环境搭建仅仅只需要以上几步，当你点击Run后，
就可以开始顺利编译，最后会弹出Safari，实际上它的run的是webkit内核，需
要一个Safari来作UI层。WebKit也提供了一个MiniBrowser，这就和Safari没关
系了，启动方法就是在第四步上的Exceutable选择MiniBrowser.app即可。我当
初基于的代码会有些其他的问题，这里就不干扰大家了，如果有遇雷的请把错误
贴出来，我看看遇到过没。

OK，了解基本概念，搭建好了开发和调试环境，我敢相信任何级别菜鸟，都会有
信心往下继续深究了。我的理念就是这样，不管后面有多难，千万不要把开头搞
得太复杂，这样会拒很多人之门外，这也是我为什么推荐最开始用xcode的原因，
WebKit官方已把编译中所有细节都隐藏在xcode的项目设置和脚本中了。后面，
我会基于源码，逐步深入，和大家一起探究WebKit内核的神奇和伟大。

* Tools
** sed                                                                 :sed:
** DONE flex & bison 工具                                   :flex:bison:gnu:
- State "DONE"       from "TODO"       [2015-11-23 一 21:02] \\
  了解即可，不必深入

http://blog.csdn.net/wxdao/article/details/16359365

什么是Flex和Bison？

Flex是一个词法分析器，是unix lex的gnu克隆，作用是把"词"抽象成符号，供
程序识别

Bison则是一个文法分析器（也是unix yacc的gnu克隆），语法就是在这里定义，
是语言设计的核心

这两巨头不但可以应付复杂的语法处理，也可以拿来制作简单的分析器，如配置
文件等

** awk                                                                 :awk:
*** awk入门
+ http://coolshell.cn/articles/9070.html
+ http://www.gnu.org/software/gawk/manual/gawk.html
+ http://zh.wikipedia.org/wiki/Awk
+ http://net.pku.edu.cn/~yhf/tutorial/awk_manual.html

**** what
AWK是一种处理文本文件的语言。它将文件作为记录序列处理。在一般情况下，
文件内容的每行都是一个记录。每行内容都会被分割成一系列的域，因此，我们
可以认为一行的第一个词为第一个域，第二个词为第二个，以此类推。AWK程序
是由一些处理特定模式的语句块构成的。AWK一次可以读取一个输入行。对每个
输入行，AWK解释器会判断它是否符合程序中出现的各个模式，并执行符合的模
式所对应的动作。

gawk是AWK的GNU版本。

**** why
1. 基于文本的样式扫描和处理是我们经常做的工作，awk所做的工作有些象数据
   库，但与数据库不同的是，它处理的是文本文件

2. awk是一个简单的工具，当然这是相对于 其强大的功能来说的

3. awk是一个容易 获得的工具

4. 如果你 要处理与文本样式扫描相关的工作，awk应该是你的第一选择。在这
   里有一个可遵循的一般原则：如果你用普通的shell工具或shell script有困
   难的话，试试awk,如果awk仍不能解决问题，则便用C语言，如果C语言仍然失
   败，则移至C++。

**** awk调用方式
1. 命令行
2. script
   1) akw -f [file.awk]
   2) 命令解释器： #!/bin/awk -f 并赋予可执行权限

**** awk语法
1. 格式： *awk [-F re] [parameter] ['prog'] [-f progfile] [in_file ...]*
2. 参数说明
   + -F re: 允许awj更改字段分隔符
   + parameter: 为不同变量赋值
   + 'prog': awk程序语句段，必须使用单引号括起，以防shell解释
   + -f progfile: 调用并执行progfile程序文件
   + in_file: 输入文件，允许多个，缺省时为标准输入，支持输入输出重定向

**** 记录，字段，内置变量
awk处理的工作与数据库的处理方式有相同之处，其相同处之一就是awk支持对记
录和字段的处理，其中对字段的处理是grep和sed不能实现的，这也是awk优于二
者的原因之一。

在awk中，缺省的情况下总是将文本文件中的一行视为一个 *记录* ，而将一行
中的某一部分作为记录中的一个 *字段* 。

为了操 作这些不同的字段，awk借用shell的方法， *用$1,$2,$3...这样的方式
来顺序地表示行（记录）中的不同字段* 。
特殊地， *awk用$0表示整个 行（记录）* 。

不同的字段之间是用称作 *分隔符* 的字符分隔开的, 系统默认的分隔符是空格。
awk允许在命令行中用 *-F re* 的形式来改变这个分隔符。

事实上，awk用一个 *内置的变量*  *FS* 来记忆这个分隔符。awk中有好几个这
样的内置变量，例如，
+ 记录分隔符变量 *RS*
+ 当前工作的记录数 *NR* 等


e.g. 显示文本文件myfile中第七行到第十五行中以字符%分隔的第一字段，第三
字段和第七字段
#+BEGIN_EXAMPLE
awk -F % 'NR==7，NR==15 {printf $1 $3 $7}'
#+END_EXAMPLE

**** awk内置函数
awk吸收了某些优秀的程序设计语言（例如C）语言的许多优点。这些优点之一就
是内置函数的使用，awk定义并 支持了一系列的内置函数，由于这些函数的使用，
使得awk提供的功能更为完善和强大。

**** 在命令行使用awk
1. 正则匹配
   #+BEGIN_SRC sh :exports code
   awk '/sun/{print}' mydoc # 显示含有"sun"的所有行
   #+END_SRC
   + 显示整个记录是awk的缺省动作，所以可以省略action项
     #+BEGIN_SRC sh :export code
     awk '/sun/' mydoc
     #+END_SRC

   #+BEGIN_SRC sh :exports code
   awk '/[Ss]un/, /[Mm]oon/ {print}' myfile
   #+END_SRC

*** [[http://coolshell.cn/articles/9070.html][AWK 简明教程]]         :blog:

之所以叫AWK是因为其取了三位创始人 [[http://en.wikipedia.org/wiki/Alfred_Aho][Alfred
Aho]]，[[http://en.wikipedia.org/wiki/Peter_J._Weinberger][Peter
Weinberger]], 和 [[http://en.wikipedia.org/wiki/Brian_Kernighan][Brian
Kernighan]] 的Family
Name的首字符。要学AWK，就得提一提AWK的一本相当经典的书《[[http://plan9.bell-labs.com/cm/cs/awkbook/][The
AWK Programming
Language]]》，它在[[http://book.douban.com/subject/1876898/][豆瓣上的评分]]是9.4分！在[[http://www.amazon.cn/mn/detailApp/?asin=020107981X][亚马逊上居然卖1022.30元]]。

我在这里的教程并不想面面俱到，本文和我之前的[[http://coolshell.cn/articles/8460.html][Go语言简介]]一样，全是示例，基本无废话。

*我只想达到两个目的：*

*1）你可以在乘坐公交地铁上下班，或是在坐马桶拉大便时读完（保证是一泡大便的工夫）。*

*2）我只想让这篇博文像一个火辣的脱衣舞女挑起你的兴趣，然后还要你自己去下工夫去撸。*

废话少说，我们开始脱吧（注：这里只是topless）。

***** 起步上台

我从netstat命令中提取了如下信息作为用例：

#+BEGIN_EXAMPLE
    $ cat netstat.txt
    Proto Recv-Q Send-Q Local-Address          Foreign-Address             State
    tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
    tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
    tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
    tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT
    tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED
    tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED
    tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT
    tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
    tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1
    tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED
    tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT
    tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK
    tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED
    tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2
    tcp        0      0 :::22                  :::*                        LISTEN
#+END_EXAMPLE

下面是最简单最常用的awk示例，其输出第1列和第4例，

- 其中单引号中的被大括号括着的就是awk的语句，注意，其只能被单引号包含。
- 其中的$1..$n表示第几例。注：$0表示整个行。

#+BEGIN_EXAMPLE
    $ awk '{print $1, $4}' netstat.txt
    Proto Local-Address
    tcp 0.0.0.0:3306
    tcp 0.0.0.0:80
    tcp 127.0.0.1:9000
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp coolshell.cn:80
    tcp :::22
#+END_EXAMPLE

我们再来看看awk的格式化输出，和C语言的printf没什么两样：

#+BEGIN_EXAMPLE
    $ awk '{printf "%-8s %-8s %-8s %-18s %-22s %-15s\n",$1,$2,$3,$4,$5,$6}' netstat.txt
    Proto    Recv-Q   Send-Q   Local-Address      Foreign-Address        State
    tcp      0        0        0.0.0.0:3306       0.0.0.0:*              LISTEN
    tcp      0        0        0.0.0.0:80         0.0.0.0:*              LISTEN
    tcp      0        0        127.0.0.1:9000     0.0.0.0:*              LISTEN
    tcp      0        0        coolshell.cn:80    124.205.5.146:18245    TIME_WAIT
    tcp      0        0        coolshell.cn:80    61.140.101.185:37538   FIN_WAIT2
    tcp      0        0        coolshell.cn:80    110.194.134.189:1032   ESTABLISHED
    tcp      0        0        coolshell.cn:80    123.169.124.111:49809  ESTABLISHED
    tcp      0        0        coolshell.cn:80    116.234.127.77:11502   FIN_WAIT2
    tcp      0        0        coolshell.cn:80    123.169.124.111:49829  ESTABLISHED
    tcp      0        0        coolshell.cn:80    183.60.215.36:36970    TIME_WAIT
    tcp      0        4166     coolshell.cn:80    61.148.242.38:30901    ESTABLISHED
    tcp      0        1        coolshell.cn:80    124.152.181.209:26825  FIN_WAIT1
    tcp      0        0        coolshell.cn:80    110.194.134.189:4796   ESTABLISHED
    tcp      0        0        coolshell.cn:80    183.60.212.163:51082   TIME_WAIT
    tcp      0        1        coolshell.cn:80    208.115.113.92:50601   LAST_ACK
    tcp      0        0        coolshell.cn:80    123.169.124.111:49840  ESTABLISHED
    tcp      0        0        coolshell.cn:80    117.136.20.85:50025    FIN_WAIT2
    tcp      0        0        :::22              :::*                   LISTEN
#+END_EXAMPLE

***** 脱掉外套

****** 过滤记录

我们再来看看如何过滤记录（下面过滤条件为：第三列的值为0 &&
第6列的值为LISTEN）

#+BEGIN_EXAMPLE
    $ awk '$3==0 && $6=="LISTEN" ' netstat.txt
    tcp        0      0 0.0.0.0:3306               0.0.0.0:*              LISTEN
    tcp        0      0 0.0.0.0:80                 0.0.0.0:*              LISTEN
    tcp        0      0 127.0.0.1:9000             0.0.0.0:*              LISTEN
    tcp        0      0 :::22                      :::*                   LISTEN
#+END_EXAMPLE

其中的“==”为比较运算符。其他比较运算符：!=, >, <, >=, <=

我们来看看各种过滤记录的方式：

#+BEGIN_EXAMPLE
    $ awk ' $3>0 {print $0}' netstat.txt
    Proto Recv-Q Send-Q Local-Address          Foreign-Address             State
    tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
    tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1
    tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK
#+END_EXAMPLE

如果我们需要表头的话，我们可以引入内建变量NR：

#+BEGIN_EXAMPLE
    $ awk '$3==0 && $6=="LISTEN" || NR==1 ' netstat.txt
    Proto Recv-Q Send-Q Local-Address          Foreign-Address             State
    tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
    tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
    tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
    tcp        0      0 :::22                  :::*                        LISTEN
#+END_EXAMPLE

再加上格式化输出：

#+BEGIN_EXAMPLE
    $ awk '$3==0 && $6=="LISTEN" || NR==1 {printf "%-20s %-20s %s\n",$4,$5,$6}' netstat.txt
    Local-Address        Foreign-Address      State
    0.0.0.0:3306         0.0.0.0:*            LISTEN
    0.0.0.0:80           0.0.0.0:*            LISTEN
    127.0.0.1:9000       0.0.0.0:*            LISTEN
    :::22                :::*                 LISTEN
#+END_EXAMPLE

****** *内建变量*

说到了内建变量，我们可以来看看awk的一些内建变量：

| $0                                         | $1~$n                                 | FS                               | NF                                   | NR                                                                              | FNR                                                      | RS                                | OFS                             | ORS                              | FILENAME             |
| 当前记录（这个变量中存放着整个行的内容）   | 当前记录的第n个字段，字段间由FS分隔   | 输入字段分隔符 默认是空格或Tab   | 当前记录中的字段个数，就是有多少列   | 已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。   | 当前记录数，与NR不同的是，这个值会是各个文件自己的行号   | 输入的记录分隔符， 默认为换行符   | 输出字段分隔符， 默认也是空格   | 输出的记录分隔符，默认为换行符   | 当前输入文件的名字   |

怎么使用呢，比如：我们如果要输出行号：

#+BEGIN_EXAMPLE
    $ awk '$3==0 && $6=="ESTABLISHED" || NR==1 {printf "%02s %s %-20s %-20s %s\n",NR, FNR, $4,$5,$6}' netstat.txt
    01 1 Local-Address        Foreign-Address      State
    07 7 coolshell.cn:80      110.194.134.189:1032 ESTABLISHED
    08 8 coolshell.cn:80      123.169.124.111:49809 ESTABLISHED
    10 10 coolshell.cn:80      123.169.124.111:49829 ESTABLISHED
    14 14 coolshell.cn:80      110.194.134.189:4796 ESTABLISHED
    17 17 coolshell.cn:80      123.169.124.111:49840 ESTABLISHED
#+END_EXAMPLE

****** *指定分隔符*

#+BEGIN_EXAMPLE
    $  awk  'BEGIN{FS=":"} {print $1,$3,$6}' /etc/passwd
    root 0 /root
    bin 1 /bin
    daemon 2 /sbin
    adm 3 /var/adm
    lp 4 /var/spool/lpd
    sync 5 /sbin
    shutdown 6 /sbin
    halt 7 /sbin
#+END_EXAMPLE

上面的命令也等价于：（-F的意思就是指定分隔符）

#+BEGIN_EXAMPLE
    $ awk  -F: '{print $1,$3,$6}' /etc/passwd
#+END_EXAMPLE

注：如果你要指定多个分隔符，你可以这样来：

#+BEGIN_EXAMPLE
    awk -F '[;:]'
#+END_EXAMPLE

再来看一个以\t作为分隔符输出的例子（下面使用了/etc/passwd文件，这个文件是以:分隔的）：

#+BEGIN_EXAMPLE
    $ awk  -F: '{print $1,$3,$6}' OFS="\t" /etc/passwd
    root    0       /root
    bin     1       /bin
    daemon  2       /sbin
    adm     3       /var/adm
    lp      4       /var/spool/lpd
    sync    5       /sbin
#+END_EXAMPLE

***** 脱掉衬衫

****** 字符串匹配

我们再来看几个字符串匹配的示例：

#+BEGIN_EXAMPLE
    $ awk '$6 ~ /FIN/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
    1       Local-Address   Foreign-Address State
    6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2
    9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2
    13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1
    18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2

    $ $ awk '$6 ~ /WAIT/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
    1       Local-Address   Foreign-Address State
    5       coolshell.cn:80 124.205.5.146:18245     TIME_WAIT
    6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2
    9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2
    11      coolshell.cn:80 183.60.215.36:36970     TIME_WAIT
    13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1
    15      coolshell.cn:80 183.60.212.163:51082    TIME_WAIT
    18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2
#+END_EXAMPLE

上面的第一个示例匹配FIN状态， 第二个示例匹配WAIT字样的状态。其实 ~
表示模式开始。/ /中是模式。这就是一个正则表达式的匹配。

其实awk可以像grep一样的去匹配第一行，就像这样：

#+BEGIN_EXAMPLE
    $ awk '/LISTEN/' netstat.txt
    tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN
    tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN
    tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN
    tcp        0      0 :::22                   :::*                    LISTEN
#+END_EXAMPLE

我们可以使用 “/FIN|TIME/” 来匹配 FIN 或者 TIME :

#+BEGIN_EXAMPLE
    $ awk '$6 ~ /FIN|TIME/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
    1       Local-Address   Foreign-Address State
    5       coolshell.cn:80 124.205.5.146:18245     TIME_WAIT
    6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2
    9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2
    11      coolshell.cn:80 183.60.215.36:36970     TIME_WAIT
    13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1
    15      coolshell.cn:80 183.60.212.163:51082    TIME_WAIT
    18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2
#+END_EXAMPLE

再来看看模式取反的例子：

#+BEGIN_EXAMPLE
    $ awk '$6 !~ /WAIT/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
    1       Local-Address   Foreign-Address State
    2       0.0.0.0:3306    0.0.0.0:*       LISTEN
    3       0.0.0.0:80      0.0.0.0:*       LISTEN
    4       127.0.0.1:9000  0.0.0.0:*       LISTEN
    7       coolshell.cn:80 110.194.134.189:1032    ESTABLISHED
    8       coolshell.cn:80 123.169.124.111:49809   ESTABLISHED
    10      coolshell.cn:80 123.169.124.111:49829   ESTABLISHED
    12      coolshell.cn:80 61.148.242.38:30901     ESTABLISHED
    14      coolshell.cn:80 110.194.134.189:4796    ESTABLISHED
    16      coolshell.cn:80 208.115.113.92:50601    LAST_ACK
    17      coolshell.cn:80 123.169.124.111:49840   ESTABLISHED
    19      :::22   :::*    LISTEN
#+END_EXAMPLE

或是：

#+BEGIN_EXAMPLE
    awk '!/WAIT/' netstat.txt
#+END_EXAMPLE

*折分文件*

awk拆分文件很简单，使用重定向就好了。下面这个例子，是按第6例分隔文件，相当的简单（其中的NR!=1表示不处理表头）。

#+BEGIN_EXAMPLE
    $ awk 'NR!=1{print > $6}' netstat.txt

    $ ls
    ESTABLISHED  FIN_WAIT1  FIN_WAIT2  LAST_ACK  LISTEN  netstat.txt  TIME_WAIT

    $ cat ESTABLISHED
    tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED
    tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
    tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED

    $ cat FIN_WAIT1
    tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1

    $ cat FIN_WAIT2
    tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2

    $ cat LAST_ACK
    tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK

    $ cat LISTEN
    tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
    tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
    tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
    tcp        0      0 :::22                  :::*                        LISTEN

    $ cat TIME_WAIT
    tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT
    tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT
    tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT
#+END_EXAMPLE

你也可以把指定的列输出到文件：

#+BEGIN_EXAMPLE
    awk 'NR!=1{print $4,$5 > $6}' netstat.txt
#+END_EXAMPLE

再复杂一点：（注意其中的if-else-if语句，可见awk其实是个脚本解释器）

#+BEGIN_EXAMPLE
    $ awk 'NR!=1{if($6 ~ /TIME|ESTABLISHED/) print > "1.txt";
    else if($6 ~ /LISTEN/) print > "2.txt";
    else print > "3.txt" }' netstat.txt

    $ ls ?.txt
    1.txt  2.txt  3.txt

    $ cat 1.txt
    tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT
    tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED
    tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED
    tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT
    tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
    tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED
    tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT
    tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED

    $ cat 2.txt
    tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
    tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
    tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
    tcp        0      0 :::22                  :::*                        LISTEN

    $ cat 3.txt
    tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2
    tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2
    tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1
    tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK
    tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2
#+END_EXAMPLE

****** 统计

下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。

#+BEGIN_EXAMPLE
    $ ls -l  *.cpp *.c *.h | awk '{sum+=$5} END {print sum}'
    2511401
#+END_EXAMPLE

我们再来看一个统计各个connection状态的用法：（我们可以看到一些编程的影子了，大家都是程序员我就不解释了。注意其中的数组的用法）

#+BEGIN_EXAMPLE
    $ awk 'NR!=1{a[$6]++;} END {for (i in a) print i ", " a[i];}' netstat.txt
    TIME_WAIT, 3
    FIN_WAIT1, 1
    ESTABLISHED, 6
    FIN_WAIT2, 3
    LAST_ACK, 1
    LISTEN, 4
#+END_EXAMPLE

再来看看统计每个用户的进程的占了多少内存（注：sum的RSS那一列）

#+BEGIN_EXAMPLE
    $ ps aux | awk 'NR!=1{a[$1]+=$6;} END { for(i in a) print i ", " a[i]"KB";}'
    dbus, 540KB
    mysql, 99928KB
    www, 3264924KB
    root, 63644KB
    hchen, 6020KB
#+END_EXAMPLE

***** 脱掉内衣

****** awk脚本

在上面我们可以看到一个END关键字。END的意思是“处理完所有的行的标识”，即然说到了END就有必要介绍一下BEGIN，这两个关键字意味着执行前和执行后的意思，语法如下：

- BEGIN{ 这里面放的是执行前的语句 }
- END {这里面放的是处理完所有的行后要执行的语句 }
- {这里面放的是处理每一行时要执行的语句}

为了说清楚这个事，我们来看看下面的示例：

假设有这么一个文件（学生成绩表）：

#+BEGIN_EXAMPLE
    $ cat score.txt
    Marry   2143 78 84 77
    Jack    2321 66 78 45
    Tom     2122 48 77 71
    Mike    2537 87 97 95
    Bob     2415 40 57 62
#+END_EXAMPLE

我们的awk脚本如下（我没有写有命令行上是因为命令行上不易读，另外也在介绍另一种用法）：

#+BEGIN_EXAMPLE
    $ cat cal.awk
    #!/bin/awk -f
    #运行前
    BEGIN {
        math = 0
        english = 0
        computer = 0

        printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"
        printf "---------------------------------------------\n"
    }
    #运行中
    {
        math+=$3
        english+=$4
        computer+=$5
        printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5
    }
    #运行后
    END {
        printf "---------------------------------------------\n"
        printf "  TOTAL:%10d %8d %8d \n", math, english, computer
        printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR
    }
#+END_EXAMPLE

我们来看一下执行结果：（也可以这样运行 ./cal.awk score.txt）

#+BEGIN_EXAMPLE
    $ awk -f cal.awk score.txt
    NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL
    ---------------------------------------------
    Marry  2143     78       84       77      239
    Jack   2321     66       78       45      189
    Tom    2122     48       77       71      196
    Mike   2537     87       97       95      279
    Bob    2415     40       57       62      159
    ---------------------------------------------
      TOTAL:       319      393      350
    AVERAGE:     63.80    78.60    70.00
#+END_EXAMPLE

****** 环境变量

即然说到了脚本，我们来看看怎么和环境变量交互：（使用-v参数和ENVIRON，使用ENVIRON的环境变量需要export）

#+BEGIN_EXAMPLE
    $ x=5

    $ y=10
    $ export y

    $ echo $x $y
    5 10

    $ awk -v val=$x '{print $1, $2, $3, $4+val, $5+ENVIRON["y"]}' OFS="\t" score.txt
    Marry   2143    78      89      87
    Jack    2321    66      83      55
    Tom     2122    48      82      81
    Mike    2537    87      102     105
    Bob     2415    40      62      72
#+END_EXAMPLE

***** 几个花活

最后，我们再来看几个小例子：

#+BEGIN_EXAMPLE
    #从file文件中找出长度大于80的行
    awk 'length>80' file

    #按连接数查看客户端IP
    netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr

    #打印99乘法表
    seq 9 | sed 'H;g' | awk -v RS='' '{for(i=1;i<=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")}'
#+END_EXAMPLE

***** 自己撸吧

关于其中的一些知识点可以参看[[http://www.gnu.org/software/gawk/manual/gawk.html][gawk的手册]]：

- 内建变量，参看：[[http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din-Variables]]
- 流控方面，参看：[[http://www.gnu.org/software/gawk/manual/gawk.html#Statements]]
- 内建函数，参看：[[http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din]]
- 正则表达式，参看：[[http://www.gnu.org/software/gawk/manual/gawk.html#Regexp]]

*** [[http://net.pku.edu.cn/~yhf/tutorial/awk_manual.html][Unix awk使用手册]] :blog:

作者的话：

《UNIX AWK使用手册》是我几个月前的作品了，回过头来看，这
篇文章实在是很粗燥，因当时我写作并上传这个作品时实在是太
忙了，没有对文章的质量进行很好的检查，心里老觉得有愧于网
友的厚爱，于是趁闲赶忙重写一遍，虽然不一定会有很大的改观
，但质量是肯定要好一点的，唯如此，我的良心上才好受一点，
呶，下面就是我的修改稿，各位老友请与第一版相比一下，看是
否有所进步！

这次改写仍然保留了原有的风格：正文由浅入深，文后附上了大
量的相关资料，这样做的原因是为了满足各种用户的需求，这在
第一版中已经说过了。这次主要的改变是在内容上，加入了很多
新内容，并增加了示例，以帮助读者理解其中的内容，附录也补
充了许多新的资料。当然读者要真正地掌握awk，仅仅读了本文
是不够的，还必须有上机实习这一步。值得提醒大家的是，awk
有很多版本，并且各个版本之间存在着一些差别，因此，在使用
awk以前最好参考一下你使用的系统的联机帮助。

什么是awk?

你可能对UNIX比较熟悉，但你可能对awk很陌生，这一点也不奇
怪，的确，与其优秀的功能相比，awk还远没达到它应有的知名
度。awk是什么？与其它大多数UNIX命令不同的是，从名字上看
，我们不可能知道awk的功能：它既不是具有独立意义的英文单
词，也不是几个相关单词的缩写。事实上，awk是三个人名的缩
写，他们是：Aho、(Peter)Weinberg和(Brain)Kernighan。正是
这三个人创造了awk---一个优秀的样式扫描与处理工具。

AWK的功能是什么？与sed和grep很相似，awk是一种样式扫描与
处理工具。但其功能却大大强于sed和grep。 awk提供了极其强
大的功能：它几乎可以完成grep和sed所能完成的全部工作，同
时，它还可以可以进行样式装入、流控制、数学运算符、进程控
制语句甚至于内置的变量和函数。它具备了一个完整的语言所应
具有的几乎所有精美特性。实际上，awk的确拥有自己的语言：
awk程序设计语言，awk的三位创建者已将它正式定义为：样式扫
描和处理语言。

为什么使用awk?

即使如此，你也许仍然会问，我为什么要使用awk?

使用awk的第一个理由是基于文本的样式扫描和处理是我们经常
做的工作，awk所做的工作有些象数据库，但与数据库不同的是
，它处理的是文本文件，这些文件没有专门的存储格式，普通的
人们就能编辑、阅读、理解和处理它们。而数据库文件往往具有
特殊的存储格式，这使得它们必须用数据库处理程序来处理它们
。既然这种类似于数据库的处理工作我们经常会遇到，我们就应
当找到处理它们的简便易行的方法，UNIX有很多这方面的工具，
例如sed 、grep、sort以及find等等，awk是其中十分优秀的一
种。

使用awk的第二个理由是awk是一个简单的工具，当然这是相对于
其强大的功能来说的。的确，UNIX有许多优秀的工具，例如UNIX
天然的开发工具C语言及其延续C++就非常的优秀。但相对于它们
来说，awk完成同样的功能要方便和简捷得多。这首先是因为awk
提供了适应多种需要的解决方案：从解决简单问题的awk命令行
到复杂而精巧的awk程序设计语言，这样做的好处是，你可以不
必用复杂的方法去解决本来很简单的问题。例如，你可以用一个
命令行解决简单的问题，而C不行，即使一个再简单的程序，C语
言也必须经过编写、编译的全过程。其次，awk本身是解释执行
的，这就使得awk程序不必经过编译的过程，同时，这也使得它
与shell script程序能够很好的契合。最后，awk本身较C语言简
单，虽然awk吸收了C语言很多优秀的成分，熟悉C语言会对学习
awk有很大的帮助，但 awk本身不须要会使用C语言——一种功能强
大但需要大量时间学习才能掌握其技巧的开发工具。

使用awk的第三个理由是awk是一个容易获得的工具。与C和C++语
言不同，awk只有一个文件(/bin/awk)，而且几乎每个版本的
UNIX都提供各自版本的awk，你完全不必费心去想如何获得awk。
但C语言却不是这样，虽然C语言是UNIX天然的开发工具，但这个
开发工具却是单独发行的，换言之，你必须为你的UNIX版本的C
语言开发工具单独付费（当然使用D版者除外），获得并安装它
，然后你才可以使用它。

基于以上理由，再加上awk强大的功能，我们有理由说，如果你
要处理与文本样式扫描相关的工作，awk应该是你的第一选择。
在这里有一个可遵循的一般原则：如果你用普通的shell工具或
shell script有困难的话，试试awk,如果awk仍不能解决问题，
则便用C语言，如果C语言仍然失败，则移至C++。

awk的调用方式

前面曾经说过，awk提供了适应多种需要的不同解决方案，它们
是：

一、 awk命令行，你可以象使用普通UNIX命令一样使用awk，在
命令行中你也可以使用awk程序设计语言，虽然awk支持多行的录
入，但是录入长长的命令行并保证其正确无误却是一件令人头疼
的事，因此，这种方法一般只用于解决简单的问题。当然，你也
可以在shell script程序中引用awk命令行甚至awk程序脚本。

二、使用-f选项调用awk程序。awk允许将一段awk程序写入一个
文本文件，然后在awk命令行中用-f选项调用并执行这段程序。
具体的方法我们将在后面的awk语法中讲到。

三、利用命令解释器调用awk程序：利用UNIX支持的命令解释器
功能，我们可以将一段awk程序写入文本文件，然后在它的第一
行加上:
#!/bin/awk -f
并赋予这个文本文件以执行的权限。这样做之后，你就可以在命
令行中用类似于下面这样的方式调用并执行这段awk程序了。

$awk脚本文本名待处理文件

awk的语法：

与其它UNIX命令一样，awk拥有自己的语法：

awk [ -F re] [parameter...] ['prog'] [-f progfile]
[in_file...]

参数说明：

-F re:允许awk更改其字段分隔符。

parameter: 该参数帮助为不同的变量赋值。

'prog': awk的程序语句段。这个语句段必须用单拓号：'和'括
起，以防被shell解释。这个程序语句段的标准形式为：

'pattern {action}'

其中pattern参数可以是egrep正则表达式中的任何一个，它可以
使用语法/re/再加上一些样式匹配技巧构成。与sed类似，你也
可以使用","分开两样式以选择某个范围。关于匹配的细节，你
可以参考附录，如果仍不懂的话，找本UNIX书学学grep和sed（
本人是在学习ed时掌握匹配技术的）。 action参数总是被大括
号包围，它由一系统awk语句组成，各语句之间用";"分隔。awk
解释它们，并在pattern给定的样式匹配的记录上执行其操作。
与shell类似，你也可以使用“#”作为注释符，它使“#”到行尾的
内容成为注释，在解释执行时，它们将被忽略。你可以省略
pattern和 action之一，但不能两者同时省略，当省略pattern
时没有样式匹配，表示对所有行（记录）均执行操作，省略
action时执行缺省的操作——在标准输出上显示。

-f progfile:允许awk调用并执行progfile指定有程序文件。
progfile是一个文本文件，他必须符合awk的语法。

in_file:awk的输入文件，awk允许对多个输入文件进行处理。值
得注意的是awk不修改输入文件。如果未指定输入文件，awk将接
受标准输入，并将结果显示在标准输出上。awk支持输入输出重
定向。

awk的记录、字段与内置变量：

前面说过，awk处理的工作与数据库的处理方式有相同之处，其
相同处之一就是awk支持对记录和字段的处理，其中对字段的处
理是grep和sed不能实现的，这也是awk优于二者的原因之一。在
awk中，缺省的情况下总是将文本文件中的一行视为一个记录，
而将一行中的某一部分作为记录中的一个字段。为了操作这些不
同的字段，awk借用shell的方法，用$1,$2,$3...这样的方式来
顺序地表示行（记录）中的不同字段。特殊地，awk用$0表示整
个行（记录）。不同的字段之间是用称作分隔符的字符分隔开的
。系统默认的分隔符是空格。awk允许在命令行中用-F re的形式
来改变这个分隔符。事实上，awk用一个内置的变量FS来记忆这
个分隔符。awk中有好几个这样的内置变量，例如，记录分隔符
变量RS、当前工作的记录数NR等等，本文后面的附表列出了全部
的内置变量。这些内置的变量可以在awk程序中引用或修改，例
如，你可以利用NR变量在模式匹配中指定工作范围，也可以通过
修改记录分隔符RS让一个特殊字符而不是换行符作为记录的分隔
符。

例:显示文本文件myfile中第七行到第十五行中以字符%分隔的第
一字段，第三字段和第七字段：

awk -F % 'NR==7,NR==15 {printf $1 $3 $7}'

awk的内置函数

awk 之所以成为一种优秀的程序设计语言的原因之一是它吸收了
某些优秀的程序设计语言（例如C）语言的许多优点。这些优点
之一就是内置函数的使用，awk定义并支持了一系列的内置函数
，由于这些函数的使用，使得awk提供的功能更为完善和强大，
例如，awk使用了一系列的字符串处理内置函数(这些函数看起来
与C 语言的字符串处理函数相似，其使用方式与C语言中的函数
也相差无几)，正是由于这些内置函数的使用，使awk处理字符串
的功能更加强大。本文后面的附录中列有一般的awk所提供的内
置函数，这些内置函数也许与你的awk版本有些出入，因此，在
使用之前，最好参考一下你的系统中的联机帮助。

作为内置函数的一个例子，我们将在这里介绍awk的printf函数
，这个函数使得awk与c语言的输出相一致。实际上，awk中有许
多引用形式都是从C语言借用过来的。如果你熟悉C语言，你也许
会记得其中的printf函数，它提供的强大格式输出功能曾经带我
们许多的方便。幸运的是，我们在awk中又和它重逢了。awk中
printf几乎与C语言中一模一样，如果你熟悉C语言的话，你完全
可以照C语言的模式使用awk中的printf。因此在这里，我们只给
出一个例子，如果你不熟悉的话，请随便找一本C语言的入门书
翻翻。

例:显示文件myfile中的行号和第3字段：

$awk '{printf"%03d%s\n",NR,$1}' myfile

在命令行使用awk

按照顺序，我们应当讲解awk程序设计的内容了，但在讲解之前
，我们将用一些例子来对前面的知识进行回顾，这些例子都是在
命令行中使用的，由此我们可以知道在命令行中使用awk是多么
的方便。这样做的原因一方面是为下面的内容作铺垫，另一方面
是介绍一些解决简单问题的方法，我们完全没有必要用复杂的方
法来解决简单的问题----既然awk提供了较为简单的方法的话。

例：显示文本文件mydoc匹配（含有）字符串"sun"的所有行。

$awk '/sun/{print}' mydoc

由于显示整个记录（全行）是awk的缺省动作，因此可以省略
action项。

$awk '/sun/' mydoc

例：下面是一个较为复杂的匹配的示例：

$awk '/[Ss]un/,/[Mm]oon/ {print}' myfile

它将显示第一个匹配Sun或sun的行与第一个匹配Moon或moon的行
之间的行，并显示到标准输出上。

例：下面的示例显示了内置变量和内置函数length（）的使用：

$awk 'length($0)>80 {print NR}' myfile

该命令行将显示文本myfile中所有超过80个字符的行号，在这里
，用$0表示整个记录（行），同时，内置变量NR不使用标志符
'$'。

例：作为一个较为实际的例子，我们假设要对UNIX中的用户进行
安全性检查，方法是考察/etc下的passwd文件，检查其中的
passwd字段（第二字段）是否为"*"，如不为"*"，则表示该用户
没有设置密码，显示出这些用户名（第一字段）。我们可以用如
下语句实现：

#awk -F: '$2=="" {printf("%s no password!\n",$1' /etc/
passwd

在这个示例中，passwd文件的字段分隔符是“：”，因此，必须用
-F：来更改默认的字段分隔符，这个示例中也涉及到了内置函数
printf的使用。

awk的变量

如同其它程序设计语言一样，awk允许在程序语言中设置变量，
事实上，提供变量的功能是程序设计语言的其本要求，不提供变
量的程序设计语言本人还从未见过。

awk 提供两种变量，一种是awk内置的变量，这前面我们已经讲
过，需要着重指出的是，与后面提到的其它变量不同的是，在
awk程序中引用内置变量不需要使用标志符"$"（回忆一下前面讲
过的NR的使用）。awk提供的另一种变量是自定义变量。awk允许
用户在awk程序语句中定义并调用自已的变量。当然这种变量不
能与内置变量及其它awk保留字相同，在awk中引用自定义变量必
须在它前面加上标志符"$"。与C语言不同的是，awk中不需要对
变量进行初始化， awk根据其在awk中第一次出现的形式和上下
文确定其具体的数据类型。当变量类型不确定时，awk默认其为
字符串类型。这里有一个技巧：如果你要让你的 awk程序知道你
所使用的变量的明确类型，你应当在在程序中给它赋初值。在后
面的实例中，我们将用到这一技巧。

运算与判断：

作为一种程序设计语言所应具有的特点之一，awk支持多种运算
，这些运算与C语言提供的几本相同：如+、-、*、/、%等等，同
时，awk也支持C语言中类似++、--、+=、-=、=+、=-之类的功能
，这给熟悉C语言的使用者编写awk程序带来了极大的方便。作为
对运算功能的一种扩展，awk还提供了一系列内置的运算函数（
如log、sqr、cos、sin等等）和一些用于对字符串进行操作（运
算）的函数（如length、substr等等）。这些函数的引用大大的
提高了awk的运算功能。

作为对条件转移指令的一部分，关系判断是每种程序设计语言都
具备的功能，awk也不例外。 awk中允许进行多种测试，如常用
的==（等于）、！=（不等于）、>（大于）、<（小于）、>=（
大于等于）、>=（小于等于）等等，同时，作为样式匹配，还提
供了~（匹配于）和！~（不匹配于）判断。

作为对测试的一种扩充，awk也支持用逻辑运算符:!(非)、&&（
与）、||（或）和括号（）进行多重判断，这大大增强了awk的
功能。本文的附录中列出了awk所允许的运算、判断以及操作符
的优先级。

awk的流程控制

流程控制语句是任何程序设计语言都不能缺少的部分。任何好的
语言都有一些执行流程控制的语句。awk提供的完备的流程控制
语句类似于C语言，这给我们编程带来了极大的方便。

1、BEGIN和END:

在awk 中两个特别的表达式，BEGIN和END，这两者都可用于
pattern中（参考前面的awk语法），提供BEGIN和END的作用是给
程序赋予初始状态和在程序结束之后执行一些扫尾的工作。任何
在BEGIN之后列出的操作（在{}内）将在awk开始扫描输入之前执
行，而END之后列出的操作将在扫描完全部的输入之后执行。因
此，通常使用BEGIN来显示变量和预置（初始化）变量，使用END
来输出最终结果。

例：累计销售文件xs中的销售金额（假设销售金额在记录的第三
字段）：

$awk
>'BEGIN { FS=":";print "统计销售金额";total=0}
>{print $3;total=total+$3;}
>END {printf "销售金额总计：%.2f",total}' sx
（注：>是shell提供的第二提示符，如要在shell程序awk语句和
awk语言中换行，则需在行尾加反斜杠\）

在这里，BEGIN预置了内部变量FS（字段分隔符）和自定义变量
total,同时在扫描之前显示出输出行头。而END则在扫描完成后
打印出总合计。

2、流程控制语句
awk提供了完备的流程控制语句，其用法与C语言类似。下面我们
一一加以说明：

2.1、if...else语句:

格式：
if(表达式)
语句1
else
语句2

格式中"语句1"可以是多个语句，如果你为了方便awk判断也方便
你自已阅读，你最好将多个语句用{}括起来。awk分枝结构允许
嵌套，其格式为：

if(表达式1）
{if(表达式2）
语句1
else
语句2
}
语句3
else {if(表达式3)
语句4
else
语句5
}
语句6

当然实际操作过程中你可能不会用到如此复杂的分枝结构，这里
只是为了给出其样式罢了。

2.2、while语句

格式为:

while(表达式)
语句

2.3、do-while语句

格式为:

do
{
语句
}while(条件判断语句）

2.4、for语句

格式为：

for(初始表达式;终止条件;步长表达式)
{语句}

在awk 的 while、do-while和for语句中允许使用
break,continue语句来控制流程走向，也允许使用exit这样的语
句来退出。break 中断当前正在执行的循环并跳到循环外执行下
一条语句。continue从当前位置跳到循环开始处执行。对于exit
的执行有两种情况：当exit语句不在 END中时，任何操作中的
exit命令表现得如同到了文件尾，所有模式或操作执行将停止，
END模式中的操作被执行。而出现在END中的exit将导致程序终止
。

例：为了

awk中的自定义函数

定义和调用用户自己的函数是几乎每个高级语言都具有的功能，
awk也不例外，但原始的awk并不提供函数功能，只有在nawk或较
新的awk版本中才可以增加函数。

函数的使用包含两部分：函数的定义与函数调用。其中函数定义
又包括要执行的代码（函数本身）和从主程序代码传递到该函数
的临时调用。

awk函数的定义方法如下：

function 函数名(参数表){
函数体
}

在gawk中允许将function省略为func，但其它版本的awk不允许
。函数名必须是一个合法的标志符，参数表中可以不提供参数（
但在调用函数时函数名后的一对括号仍然是不可缺少的），也可
以提供一个或多个参数。与C语言相似，awk的参数也是通过值来
传递的。

在awk 中调用函数比较简单，其方法与C语言相似，但awk比C语
言更为灵活，它不执行参数有效性检查。换句话说，在你调用函
数时，可以列出比函数预计（函数定义中规定）的多或少的参数
，多余的参数会被awk所忽略，而不足的参数，awk将它们置为缺
省值0或空字符串，具体置为何值，将取决于参数的使用方式。

awk函数有两种返回方式：隐式返回和显式返回。当awk执行到函
数的结尾时，它自动地返回到调用程序，这是函数是隐式返回的
。如果需要在结束之前退出函数，可以明确地使用返回语句提前
退出。方法是在函数中使用形如：return 返回值格式的语句。

例：下面的例子演示了函数的使用。在这个示例中，定义了一个
名为print_header的函数，该函数调用了两个参数FileName和
PageNum， FileName参数传给函数当前使用的文件名，PageNum
参数是当前页的页号。这个函数的功能是打印（显示）出当前文
件的文件名，和当前页的页号。完成这个功能后，这个函数将返
回下一页的页号。

nawk
>'BEGIN{pageno=1;file=FILENAME
>pageno=print_header(file，pageno)；#调用函数
print_header
>printf("当前页页号是：%d\n",pageno);
>}

>#定义函数print_header
>function print_header(FileName,PageNum){
>printf("%s %d\n",FileName,PageNum); >PageNum++;return
PageNUm;
>}
>}' myfile

执行这个程序将显示如下内容：

myfile 1
当前页页号是：2

awk高级输入输出

1.读取下一条记录：

awk的next语句导致awk读取下一个记录并完成模式匹配，然后立
即执行相应的操作。通常它用匹配的模式执行操作中的代码。
next导致这个记录的任何额外匹配模式被忽略。

2.简单地读取一条记录

awk 的 getline语句用于简单地读取一条记录。如果用户有一个
数据记录类似两个物理记录，那么getline将尤其有用。它完成
一般字段的分离(设置字段变量$0 FNR NF NR)。如果成功则返回
1，失败则返回0（到达文件尾）。如果需简单地读取一个文件，
则可以编写以下代码：

例：示例getline的使用

{while(getline==1)
{
#process the inputted fields
}
}

也可以使getline保存输入数据在一个字段中，而不是通过使用
getline variable的形式处理一般字段。当使用这种方式时，NF
被置成0，FNR和NR被增值。

用户也可以使用getline<"filename"方式从一个给定的文件中输
入数据，而不是从命令行所列内容输入数据。此时，getline将
完成一般字段分离（设置字段变量$0和NF)。如果文件不存在，
返回-1,成功，返回1,返回0表示失败。用户可以从给定文件中读
取数据到一个变量中，也可以用stdin(标准输入设备）或一个包
含这个文件名的变量代替filename。值得注意的是当使用这种方
式时不修改FNR和NR。

另一种使用getline语句的方法是从UNIX命令接受输入，例如下
面的例子:

例：示例从UNIX命令接受输入

{while("who -u"|getline)
{
#process each line from the who command
}
}

当然，也可以使用如下形式:

"command" | getline variable

3.关闭文件:

awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的
close语句。

close("filename")

filename可以是getline打开的文件（也可以是stdin,包含文件
名的变量或者getline使用的确切命令）。或一个输出文件（可
以是stdout，包含文件名的变量或使用管道的确切命令）。

4.输出到一个文件:

awk中允许用如下方式将结果输出到一个文件：

printf("hello word!\n")>"datafile"
或
printf("hello word!\n")>>"datafile"

5.输出到一个命令

awk中允许用如下方式将结果输出到一个命令：

printf("hello word!\n")|"sort-t','"

awk与shell script混合编程

因为awk可以作为一个shell命令使用，因此awk能与shell批处理
程序很好的融合在一起，这给实现awk与shell程序的混合编程提
供了可能。实现混合编程的关键是awk与shell script之间的对
话，换言之，就是awk与shell script之间的信息交流:awk从
shell script中获取所需的信息（通常是变量的值）、在awk中
执行shell命令行、shell script将命令执行的结果送给awk处理
以及shell script读取awk的执行结果等等。

1.awk读取Shell script程序变量

在awk中我们可以通过“'$变量名'”的方式读取sell scrpit程序
中的变量。

例：在下面的示例中，我们将读取sell scrpit程序中的变量
Name，该变量存放的是文本myfile的撰写者，awk将打印出这个
人名。

$cat writename
:
# @(#)
#
.
.
.
Name="张三" nawk 'BEGIN {name="'Name'";\ printf("\t%s\t
撰写者%s\n",FILENAME,name");}\
{...}END{...}' myfile
.
.
.

2.将shell命令的执行结果送给awk处理

作为信息传送的一种方法，我们可以将一条shell命令的结果通
过管道线（|）传递给awk处理：

例：示例awk处理shell命令的执行结果

$who -u | awk '{printf("%s正在执行%s\n",$2,$1)}'

该命令将打印出注册终端正在执行的程序名。

3.shell script程序读awk的执行结果

为了实现shell script程序读取awk执行的结果，我们可以采取
一些特殊的方法，例如我们可以用变量名=`awk语句`的形式将
awk执行的结果存放入一个 shell script变量。当然也可以用管
道线的方法将awk执行结果传递给shell script程序处理。

例：作为传送消息的机制之一，UNIX提供了一个向其所有用户传
送消息的命令wall（意思是write to all写给所有用户），该命
令允许向所有工作中的用户（终端）发送消息。为此，我们可以
通过一段shell批处理程序wall.shell来模拟这一程序（事实上
比较老的版本中wall就是一段shell批处理程序：

$cat wall.shell
:
# @(#) wall.shell:发送消息给每个已注册终端
#
cat >/tmp/$$
#用户录入消息文本 who -u | awk '{print $2}' | while read
tty
do
cat /tmp/$$>$tty
done

在这个程序里，awk接受who -u命令的执行结果，该命令打印出
所有已注册终端的信息，其中第二个字段是已注册终端的设备名
，因此用awk命令析出该设备名，然后用while read tty语句循
环读出这些文件名到变量（shell script变量）tty中，作为信
息传送的终结地址。

4.在awk中执行shell命令行----嵌入函数system()

system()是一个不适合字符或数字类型的嵌入函数，该函数的功
能是处理作为参数传递给它的字符串。system对这个参数的处理
就是将其作为命令处理，也就是说将其当作命令行一样加以执行
。这使得用户在自己的awk程序需要时可以灵活地执行命令或脚
本。

例：下面的程序将使用system嵌入函数打印用户编制好的报表文
件，这个文件存放在名为myreport.txt的文件中。为简约起见，
我们只列出了其END部分：

.
.
.
END {close("myreport.txt");system("lp myreport.txt");}

在这个示例中，我们首先使用close语句关闭了文件
myreport.txt文件，然后使用system嵌入函数将myreport.txt送
入打印机打印。

写到这里，我不得不跟朋友们说再见了，实在地说，这些内容仍
然是awk的初步知识，电脑永远是前进的科学，awk也不例外，本
篇所能做的只是在你前行的漫漫长途中铺平一段小小开端，剩下
的路还得靠你自己去走。老实说，如果本文真能给你前行的路上
带来些许的方便，那本人就知足了！

如对本篇有任何疑问，请E-mail To:Chizlong@yeah.net或到主
页http://chizling.yeah.net中留言。

附录：

1.awk的常规表达式元字符

\ 换码序列
^ 在字符串的开头开始匹配
$ 在字符串的结尾开始匹配
. 与任何单个字符串匹配
[ABC] 与[]内的任一字符匹配
[A-Ca-c] 与A-C及a-c范围内的字符匹配（按字母表顺序）
[^ABC] 与除[]内的所有字符以外的任一字符匹配
Desk|Chair 与Desk和Chair中的任一个匹配
[ABC][DEF] 关联。与A、B、C中的任一字符匹配，且其后要跟D
、E、F中的任一个字符。
 * 与A、B或C中任一个出现0次或多次的字符相匹配
+ 与A、B或C中任何一个出现1次或多次的字符相匹配
？与一个空串或A、B或C在任何一个字符相匹配
（Blue|Black）berry 合并常规表达式，与Blueberry或
Blackberry相匹配

2.awk算术运算符

运算符用途
------------------
x^y x的y次幂
x**y 同上
x%y 计算x/y的余数（求模）
x+y x加y
x-y x减y
x*y x乘y
x/y x除y
-y 负y(y的开关符号);也称一目减
++y y加1后使用y(前置加）
y++ 使用y值后加1（后缀加）
--y y减1后使用y(前置减）
y-- 使用后y减1(后缀减）
x=y 将y的值赋给x
x+=y 将x+y的值赋给x
x-=y 将x-y的值赋给x
x*=y 将x*y的值赋给x
x/=y 将x/y的值赋给x x%=y 将x%y的值赋给x
x^=y 将x^y的值赋给x
x**=y 将x**y的值赋给x

3.awk允许的测试：

操作符含义

x==y x等于y
x!=y x不等于y
x>y x大于y
x>=y x大于或等于y
x<y x小于y
x<=y x小于或等于y?
x~re x匹配正则表达式re?
x!~re x不匹配正则表达式re?

4.awk的操作符(按优先级升序排列)

= 、+=、 -=、 *= 、/= 、 %=
||
&&
> >= < <= == != ~ !~
xy (字符串连结，'x''y'变成"xy"）
+ -
 * / %
++ --

5.awk内置变量（预定义变量）

说明：表中v项表示第一个支持变量的工具（下同）：A=awk，N=
nawk,P=POSIX awk,G=gawk

V 变量含义缺省值
--------------------------------------------------------
N ARGC 命令行参数个数
G ARGIND 当前被处理文件的ARGV标志符
N ARGV 命令行参数数组
G CONVFMT 数字转换格式 %.6g
P ENVIRON UNIX环境变量
N ERRNO UNIX系统错误消息
G FIELDWIDTHS 输入字段宽度的空白分隔字符串
A FILENAME 当前输入文件的名字
P FNR 当前记录数
A FS 输入字段分隔符空格
G IGNORECASE 控制大小写敏感0（大小写敏感）
A NF 当前记录中的字段个数
A NR 已经读出的记录数
A OFMT 数字的输出格式 %.6g
A OFS 输出字段分隔符空格
A ORS 输出的记录分隔符新行
A RS 输入的记录他隔符新行
N RSTART 被匹配函数匹配的字符串首
N RLENGTH 被匹配函数匹配的字符串长度
N SUBSEP 下标分隔符 "\034"

6.awk的内置函数

V 函数用途或返回值
------------------------------------------------
N gsub(reg,string,target) 每次常规表达式reg匹配时替换
target中的string
N index(search,string) 返回string中search串的位置
A length(string) 求串string中的字符个数
N match(string,reg) 返回常规表达式reg匹配的string中的位
置
N printf(format,variable) 格式化输出，按format提供的格式
输出变量variable。
N split(string,store,delim) 根据分界符delim,分解string为
store的数组元素
N sprintf(format,variable) 返回一个包含基于format的格式
化数据，variables是要放到串中的数据
G strftime(format,timestamp) 返回一个基于format的日期或
者时间串，timestmp是systime()函数返回的时间
N sub(reg,string,target) 第一次当常规表达式reg匹配，替换
target串中的字符串
A substr(string,position,len) 返回一个以position开始len
个字符的子串
P totower(string) 返回string中对应的小写字符
P toupper(string) 返回string中对应的大写字符
A atan(x,y) x的余切(弧度)
N cos(x) x的余弦(弧度)
A exp(x) e的x幂
A int(x) x的整数部分
A log(x) x的自然对数值
N rand() 0-1之间的随机数
N sin(x) x的正弦(弧度)
A sqrt(x) x的平方根
A srand(x) 初始化随机数发生器。如果忽略x，则使用system()
G system() 返回自1970年1月1日以来经过的时间（按秒计算）

参考资料

1、《精通UNIX》（《Understanding UNIX》[美]Stan
Kelly-Bootle 著李永峰等译电子工业出版社)
2、《unix使用指南》（第2版）（Using UNIX（Second Edition
）Steve Moritsugu等原著张拥军、韩柯、原小玲等译电子工业
出版社出版、发行）
3、unix 联机手册:sco OpenSrever 5.05版.
4、感谢无名的网路资源提供者，由于你们辛勤而无私的劳动，
INTERNET才如此精彩！

** R                                                                     :r:
*** reference                                                    :homepage:

+ [[https://www.r-project.org/][r homepage]]
+ [[https://www.quora.com/how-can-i-become-a-data-scientist?redirected_qid=59455][quora: how can i become a data scientist? ]]
+ [[http://www.zipfianacademy.com/blog/post/46864003608/a-practical-intro-to-data-science][a practical intro to data science]]
+ [[http://cos.name/][统计之都]]
+ [[http://www.itongji.cn/article/053121432013.html][r资料大全]]
+ [[http://www.biosino.org/r/r-doc/][r文档]]
+ [[http://www.r-bloggers.com/lang/chinese/1224][r精选十二宫]]
+ [[http://www.zhihu.com/question/20388507][r和python的对比]]

*** R语言                                                           :intro:

r is a *language* and *environment* for *statistical computing* and
*graphics*.




有关概率统计、数据分析挖掘、机器学习等等，你不是要成为全才么？！

对于金融量化分析而言，matlab r python这几个里面，感觉r最不好用，python
装个numpy scipy pandas 基本可以替代matlab+r，而matlab在矩阵运算上，科
学计算库上，语法简洁性上r又没法比。。在专门统计领域，基本行业内都是用
sas在跑。

r主要在学术界流行，python(numpy scipy)在工程方便比较实用。

python是个综合语言（这里特指指cpython解释器），numpy scipy是数值计算的
扩展包，pandas是主要用来做数据处理（numpy依赖），sympy做符号计算（类似
mathematica？）

* 标记语言

** XML                                                                 :xml:
*** xmlns
xmlns是XML Namespaces的缩写，中文名称是XML（标准通用标记语言的子集）命
名空间。

使用的规则为，首先定义命名空间xmlns:namespace-prefix="namespaceURI"。
Android中xml中的使用是：xmlns:前缀=http://schemas.android.com/apk/res/
应用程序包路径；然后使用的时候按格式：namespace-prefix（前缀）：属性


如果使用xmlns，则xmlns的定义必须放在最外层开始的的标记中

当命名空间被定义之后，所有带有相同前缀的子元素都会与同一个命名空间相关
联。避免XML解析器对xml解析时的发送名字冲突，这就是使用xmlns的必要性。
当自定义的View有自己的属性的时候，就用到xmlns来定义一个命名空间。
*** xmlns 命名空间机制                                              :xmlns:
xmlns是 *xml namespaces* 的缩写，中文名称是xml（标准通用标记语言的子集）
命名空间。

使用的规则为，首先定义命名空间xmlns:namespace-prefix="namespaceuri"。
android中xml中的使用是：xmlns:前缀=http://schemas.android.com/apk/res/
应用程序包路径；然后使用的时候按格式：namespace-prefix（前缀）：属性

如果使用xmlns，则xmlns的定义必须放在最外层开始的的标记中

*当命名空间被定义之后，所有带有相同前缀的子元素都会与同一个命名空间相
关联, 避免xml解析器对xml解析时的发送名字冲突*

这就是使用xmlns的必要性。
当自定义的view有自己的属性的时候，就用到xmlns来定义一个命名空间。

*** Xpath                                                           :xpath:

**** reference                                                  :homepage:

- [[https://www.w3.org/TR/xpath/][Homepage]]
** Markdown                                                       :markdown:
*** DONE markdown 入门                                           :markdown:
- State "DONE"       from "TODO"       [2015-12-17 四 21:00] \\
  了解基本语法
- State "TODO"       from ""           [2015-12-17 四 19:48] \\
  1. 使用 Markdown 语言写 README
  2. 使用 Markdown 写博客，或者将 Org 转换成 markdown

**** reference

+ [[https://github.com/LearnShare/Learning-Markdown][GitHub: Learning Markdown]]

**** Intro

1. about Markdown
   1) 轻量级标记语言
   2) John Gruber
   3) 使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者
      HTML）文档

2. why markdown

**** hello markdown



#+BEGIN_SRC markdown
  Hello
  ===

  I like [Google](https://www.google.com/)
#+END_SRC

后缀名通常为 .md 或 .markdown

**** Syntax

http://daringfireball.net/projects/markdown/syntax

***** 段落与换行

#+BEGIN_SRC markdown
  段落与换行
  ====

  1\. 段落的前后必须是空行：

  空行指的是行内什么都没有，或者只有空白符（空格或制表符）

  相邻两行文本，如果中间没有空行
  会显示在一行中（换行符被转换为空格）

  2\. 如果需要在段落内加入换行（`<br>`）：

  可以在前一行的末尾加入至少两个空格
  然后换行写其它的文字

  3\. Markdown 中的多数区块都需要在两个空行之间。
#+END_SRC

***** 标题: ==== ---- ####

#+BEGIN_SRC markdown
  标题
  ====

  1. Setext 形式
  ----

  ```markdown
  H1
  ====

  H2
  ----
  ```

  H1
  ====

  H2
  ----

  >`=` 和 `-` 的数量是没有限制的。通常的做法是使其和标题文本的长度相同，这样看起来比较舒服。或者可以像我一样，用四个 `-` 或 `=`。
  >Setext 形式只支持 `h1` 和 `h2` 两种标题。

  2. atx 形式
  ----

  ① 可以用对称的 `#` 包括文本：

  ```markdown
  ####H4####

  #####H5#####
  ```

  ####H4

  #####H5

  ② 也可以只在左边使用 `#`：

  ```markdown
  ####H4

  #####H5
  ```

  ####H4

  #####H5

  ③ 成对的 `#` 左侧和只在左边使用的 `#` 左侧都不可以有任何空白，但其内侧可以使用空白。

  ```markdown
   ###左侧使用了空格###

  #### 内侧使用了空格
  ```

   ###左侧使用了空格###

  #### 内侧使用了空格

  >在这一点上，可能各种 Markdown 的实现会有不同的结果，不过仍然需要我们遵守语法规则。
#+END_SRC

***** 引用: >

#+BEGIN_SRC markdown
  引用
  ====

  1. 引用内容
  ----

  在段落或其他内容前使用 `>` 符号，就可以将这段内容标记为 '引用' 的内容（`<blockquote>`）：

  ```markdown
  >引用内容
  ```

  >引用内容

  2. 多行引用
  ----

  ```markdown
  >多行引用
  >可以在每行前加 `>`
  ```

  >多行引用
  >可以在每行前加 `>`

  ```markdown
  >如果仅在第一行使用 `>`，
  后面相邻的行即使省略 `>`，也会变成引用内容
  ```

  >如果仅在第一行使用 `>`，
  后面相邻的行即使省略 `>`，也会变成引用内容

  ```markdown
  >如果引用内容需要换行，
  >可以在行尾添加两个空格
  >
  >或者在引用内容中加一个空行
  ```

  >如果引用内容需要换行，
  >可以在行尾添加两个空格
  >
  >或者在引用内容中加一个空行

  3. 嵌套引用
  ----

  ```markdown
  >也可以在引用中
  >>使用嵌套的引用
  ```

  >也可以在引用中
  >>使用嵌套的引用

  4. 其他 Markdown
  ----

  ```markdown
  >在引用中可以使用使用其他任何 *Markdown* 语法
  ```

  >在引用中可以使用使用其他任何 *Markdown* 语法
#+END_SRC
***** 列表: 有点类似 org-mode

#+BEGIN_SRC markdown
  列表
  ====

  无序列表
  ----

  ```markdown
  ,* 可以使用 `*` 作为标记
  + 也可以使用 `+`
  - 或者 `-`
  ```

  ,* 可以使用 `*` 作为标记
  + 也可以使用 `+`
  - 或者 `-`

  有序列表
  ----

  ```markdown
  1. 有序列表以数字和 `.` 开始；
  3. 数字的序列并不会影响生成的列表序列；
  4. 但仍然推荐按照自然顺序（1.2.3...）编写。
  ```

  1. 有序列表以数字和 `.` 开始；
  3. 数字的序列并不会影响生成的列表序列；
  4. 但仍然推荐按照自然顺序（1.2.3...）编写。

  嵌套的列表
  ----

  ```markdown
  1. 第一层
    + 1-1
    + 1-2
  2. 无序列表和有序列表可以随意相互嵌套
    1. 2-1
    2. 2-2
  ```

  1. 第一层
    + 1-1
    + 1-2
  2. 无序列表和有序列表可以随意相互嵌套
    1. 2-1
    2. 2-2

  语法和用法
  ----

  1. 无序列表项的开始是：符号 空格；
  2. 有序列表项的开始是：数字 `.` 空格；
  3. 空格至少为一个，多个空格将被解析为一个；
  4. 如果仅需要在行前显示数字和 `.`：

  ```markdown
  05\. 可以使用：数字\. 来取消显示为列表
  ```

  05\. 可以使用：数字\\. 来取消显示为列表

  >`\*` 的语法专门用来显示 Markdown 语法中使用的特殊字符，参考 [字符转义](blackslash-escapes.md)
#+END_SRC

***** 代码：反引号

#+BEGIN_SRC markdown
  代码
  ====

  代码块
  ----

  可以使用缩进来插入代码块：

      <html> // Tab开头
          <title>Markdown</title>
      </html> // 四个空格开头

  代码块前后需要有至少一个空行，且每行代码前需要有至少一个 Tab 或四个空格；

  行内代码
  ----

  也可以通过 \`\`，插入行内代码（\` 是 `Tab` 键上边、数字 `1` 键左侧的那个按键）：

  例如 `<title>Markdown</title>`

  转换规则
  ----

  代码块中的文本（包括 Markdown 语法）都会显示为原始内容，而特殊字符会被转换为 HTML [字符实体](https://zh.wikipedia.org/wiki/XML%E4%B8%8EHTML%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93%E5%BC%95%E7%94%A8%E5%88%97%E8%A1%A8)。
#+END_SRC

***** 分隔线: * - _

#+BEGIN_SRC markdown
  分隔线
  ====

  1\. 可以在一行中使用三个或更多的 `*`、`-` 或 `_` 来添加分隔线（`<hr>`）：

  ```markdown
  ,***
  ------
  ___
  ```

  ,***
  ------
  ___

  2\. 多个字符之间可以有空格（空白符），但不能有其他字符：

  ```markdown
  ,* * *
  - - -
  ```

  ,* * *
  - - -
#+END_SRC

***** 超链接 []() / [][] / <>

#+BEGIN_SRC markdown
  超链接
  ====

  行内式
  ----

  格式为 `[link text](URL 'title text')`。

  ① 普通链接：

  ```markdown
  [Google](http://www.google.com/)
  ```

  [Google](http://www.google.com/)

  ② 指向本地文件的链接：

  ```markdown
  [icon.png](./images/icon.png)
  ```

  [icon.png](./images/icon.png)

  ③ 包含 'title' 的链接:

  ```markdown
  [Google](http://www.google.com/ "Google")
  ```

  [Google](http://www.google.com/ "Google")

  >title 使用 ' 或 " 都是可以的。

  参考式
  ----

  参考式链接的写法相当于行内式拆分成两部分，并通过一个 *识别符* 来连接两部分。参考式能尽量保持文章结构的简单，也方便统一管理 URL。

  ① 首先，定义链接：

  ```markdown
  [Google][link]
  ```

  [Google][link]

  第二个方括号内为链接独有的 *识别符*，可以是字母、数字、空白或标点符号。识别符是 *不区分大小写* 的；

  ② 然后定义链接内容：

  ```markdown
  [link]: http://www.google.com/ "Google"
  ```

  [link]: http://www.google.com/ "Google"

  其格式为：`[识别符]: URL 'title'`。

  >其中，URL可以使用 <\> 包括起来，title 可以使用 ""、''、() 包括（考虑到兼容性，建议使用引号），title 部分也可以换行来写；

  >链接内容的定义可以放在同一个文件的 *任意位置*；

  ③ 也可以省略 *识别符*，使用链接文本作为 *识别符*：

  ```markdown
  [Google][]
  [Google]: http://www.google.com/ "Google"
  ```

  [Google][]
  [Google]: http://www.google.com/ "Google"

  >参考式相对于行内式有一个明显的优点，就是可以在多个不同的位置引用同一个 URL。

  自动链接
  ----

  使用 `<>` 包括的 URL 或邮箱地址会被自动转换为超链接：

  ```markdown
  <http://www.google.com/>

  <123@email.com>
  ```

  <http://www.google.com/>

  <123@email.com>

  该方式适合行内较短的链接，会使用 URL 作为链接文字。邮箱地址会自动编码，以逃避抓取机器人。
#+END_SRC

***** 图像: !LINK

#+BEGIN_SRC markdown
  图像
  ====

  插入图片的语法和插入超链接的语法基本一致，只是在最前面多一个 `!`。也分为行内式和参考式两种。

  行内式
  ----

  ```markdown
  ![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 "GitHub,Social Coding")
  ```

  ![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 "GitHub,Social Coding")

  方括号中的部分是图片的替代文本，括号中的 'title' 部分和链接一样，是可选的。

  参考式
  ----

  ```markdown
  ![GitHub][github]

  [github]: https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 "GitHub,Social Coding"
  ```

  ![GitHub][github]

  [github]: https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 "GitHub,Social Coding"

  指定图片的显示大小
  ----

  Markdown 不支持指定图片的显示大小，不过可以通过直接插入`<img />`标签来指定相关属性：

  ```html
  <img src="https://avatars2.githubusercontent.com/u/3265208?v=3&s=100" alt="GitHub" title="GitHub,Social Coding" width="50" height="50" />
  ```

  <img src="https://avatars2.githubusercontent.com/u/3265208?v=3&s=100" alt="GitHub" title="GitHub,Social Coding" width="50" height="50" />
#+END_SRC

***** 强调: *emph* _emph_

#+BEGIN_SRC markdown
  强调
  ====

  1\. 使用 `* *` 或 `_ _` 包括的文本会被转换为 `<em></em>` ，通常表现为斜体：

  ```markdown
  这是用来 *演示* 的 _文本_
  ```

  这是用来 *演示* 的 _文本_

  2\. 使用 `** **` 或 `__ __` 包括的文本会被转换为 `<strong></strong>`，通常表现为加粗：

  ```markdown
  这是用来 **演示** 的 __文本__
  ```

  这是用来 **演示** 的 __文本__

  3\. 用来包括文本的 `*` 或 `_` 内侧不能有空白，否则 `*` 和 `_` 将不会被转换（不同的实现会有不同的表现）：

  ```markdown
  这是用来 * 演示* 的 _文本 _
  ```

  这是用来 * 演示* 的 _文本 _

  4\. 如果需要在文本中显示成对的 `*` 或 `_`，可以在符号前加入 `\` 即可：

  ```markdown
  这是用来 \*演示\* 的 \_文本\_
  ```

  这是用来 \*演示\* 的 \_文本\_

  5\. `*`、`**`、`_` 和 `__` 都必须 *成对使用* 。
#+END_SRC
***** 字符转义: \

#+BEGIN_SRC markdown
  字符转义
  ====

  反斜线（`\`）用于插入在 Markdown 语法中有特殊作用的字符。

  ```markdown
  这是用来 *演示* 的 _文本_

  这是用来 \*演示\* 的 \_文本\_
  ```

  这是用来 *演示* 的 _文本_

  这是用来 \*演示\* 的 \_文本\_

  这些字符包括：

  ```
  \
  `
  ,*
  _
  {}
  []
  ()
  #
  +
  -
  .
  !
  ```
#+END_SRC

**** 格式转换
Markdown 文档可以方便地转换为 HTML、Word、PDF 等格式的文档。这些转换既
可以通过你正在使用的 Markdown 编辑器完成，也可以通过一些命令行工具（如
Pandoc、Gitbook）来完成，甚至可以用你熟悉的语言编程实现。

***** HTML

#+BEGIN_SRC markdown
  转换为 HTML 文档
  ====

  MdCharm
  ----

  选择 'File', 'Export to...'，勾选 'HTML', 点击 'Browser...' 选择导出目录并输入导出的文件名，点击 'OK'，即可将当前的 Markdown 文档转换为 HTML 文档。

  如果不满意 HTML 文档的样式，可以在设置中自定义 CSS。

  Pandoc
  ----

  参考 [Installing](http://pandoc.org/installing.html) 安装 Pandoc。

  打开命令行，进入文档所在目录：

  ```
  cd /path/to/file/
  ```

  执行下面的命令，将 Markdown 转换为 HTML：

  ```
  pandoc -o hello.html hello.md
  ```

  >默认的转换，只是将 Markdown 内容转换为 HTML 标签，所以只能看到浏览器的默认样式。

  可以执行下面的命令，为导出的 HTML 添加自定义样式：

  ```
  pandoc -o hello.html -c style.css hello.md
  ```

  >`style.css` 仍然是以 `<link>` 的方式关联到 HTML 文档中的，所以在发布的时候需要将 CSS 一同发布出去。
#+END_SRC

***** PDF

#+BEGIN_SRC markdown
  转换为 PDF 文档
  ====

  MdCharm
  ----

  与导出 HTML 文档类似，选择 'File', 'Export to...'，勾选 'PDF', 点击 'Browser...' 选择导出目录并输入导出的文件名，点击 'OK'，即可将当前的 Markdown 文档转换为 PDF 文档。

  如果不满意 PDF 文档的样式，可以在设置中自定义 CSS。

  Pandoc
  ----

  使用 Pandoc 导出 PDF 文档，需要先安装某个 LaTeX 引擎（参考 [Creating a PDF](http://pandoc.org/README.html#creating-a-pdf)）。然后执行命令：

  ```
  pandoc -o hello.pdf hello.md
  ```

  当然，也可以通过 `-c style.css` 来指定样式文件。

  Chrome
  ----

  在将 Markdown [转换为 HTML 文档](html.md) 之后，可以通过 [Chrome 浏览器](https://www.google.com/chrome/) 打开它。选择 '打印'（Ctrl+P），然后更改 '目标打印机' 为 '另存为 PDF'，再进行一些设置后，即可保存为 PDF 文档。

#+END_SRC

***** Word

#+BEGIN_SRC markdown
  转换为 Word 文档
  ====

  复制粘贴
  ----

  在导出为 HTML 文档之后，可以（在浏览器中）手动复制 HTML 页面的内容，然后粘贴到 Word 文档中，保存即可。

  Pandoc
  ----

  执行下面的命令，即可将 Markdown 文档转换为 Word 文档：

  ```
  pandoc -o hello.docx hello.md
  ```
#+END_SRC

**** 小结

markdown 写 HTML

*** note

Markdown 表格与标题之间必须有一个空行， 否则表格无效

** JSON                                                               :json:

*** reference                                                    :homepage:

- [[http://www.json.org/][Homepage]]
- [[http://baike.baidu.com/link?url=j-0La3xvt2GT8PVHKEb1efldJYnaz013ZMJ_1Mm2eWX8QZcXJWewOankm25fS8GYVcuCkLW5oXV6TkKsRgHRzK][百度百科]]

*** intro                                                           :intro:

**** overview                                                   :overview:

***** what

*轻量级的数据交换格式*

#+BEGIN_QUOTE  百度百科
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于
ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了
类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python
等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也
易于机器解析和生成(一般用于提升网络传输速率)。
#+END_QUOTE

#+BEGIN_QUOTE Homepage
JSON (JavaScript Object Notation) is a lightweight data-interchange
format. It is easy for humans to read and write. It is easy for
machines to parse and generate. It is based on a subset of the
JavaScript Programming Language, Standard ECMA-262 3rd Edition -
December 1999. JSON is a text format that is completely language
independent but uses conventions that are familiar to programmers of
the C-family of languages, including C, C++, C#, Java, JavaScript,
Perl, Python, and many others. These properties make JSON an ideal
data-interchange language.
#+END_QUOTE

***** application


**** JSON vs XML

**** [[file:~/Wally/Journal/Note/em.org::*json-mode][Emacs json-mode]]

** HTML                                                               :html:
** PHP                                                                 :php:
*** PHP安装配置
**** Reference

+ [[http://php.net/][Homepage]]
+ [[http://php.net/manual/en/index.php][Manual]]
+ [[https://wiki.php.net/][Wiki]]

**** intro

PHP（全称：PHP：Hypertext Preprocessor，即“PHP：超文本预处理器”）是
一种开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入HTML中使用。

+ 内嵌，动态网页
+ 脚本语言
+ 服务器端技术
+ 开源
+ 跨平台

**** 安装

+ 源码安装： ./configure make make install

*** php5

+ 配置文件: /usr/local/apache/conf/httpd.conf
+ LoadModule php5_module module/libphp5.so  # 不一定一模一样
+ AddType application/x-httpd-php .php .phtml .php3
+ AddType application/x-httpd-php-source .phps

** YAML                                                               :yaml:
** rst
*** [[http://blog.useasp.net/archive/2014/09/05/rst-file-restructuredtext-markup-syntax-quikstart.aspx][reStructuredText(.rst)语法规则快速入门]]                           :blog:

**** intro
这几天写了个 [[http://blog.useasp.net/tags/Python][Python]] 的模块，用Markdown写个个README，传到GitHub，感觉效
果还不错，就难抑冲动，打了个包，也想放到PyPI上，结果放上去，发现README
变成了源代码。一查，才发现PyPI竟然不支持Markdown格式的README文件，好像
支持的README要reStructuredText格式的，对菜鸟的我来说这是个坑啊，好不容
易在Emacs下用Markdown用的有点熟路了，结果发现却不被支持。只好重新看看
reStructuredText的语法了，因此，也就有了此篇reStructuredText语法快速入
门。

先文绉绉的来一段[[http://blog.useasp.net/tags/reStructuredText][ reStructuredText]] 的介绍吧：

reStructuredText是一种轻量级的文本标记语言，直译为：重构建的文本，为
Python中Docutils项目的一部分。其一般保存的文件以.rst为后缀。在必要的时
候，.rst文件可以被转化成PDF或者HTML格式，也可以有Sphinx转化为LaTex,man
等格式，现在被广泛的用于程序的文档撰写。

好了，时间无多，直接正题：

reStructuredText大致分章节，段落，块和列表这几种内容。而在这其中reStructuredText最主要用得到的标记也就是：

- [[#title][标题]]
- [[#paragraph][段落]]
- [[#list][列表]]
- [[#table][表格]]
- [[#block][块（如：代码块）]]
- [[#style][样式]]

**** *标题（Title）*

来看看标题的实例：

#+BEGIN_EXAMPLE
    ===================
    这就是一个标题
    ===================

    ----------------
    这也是一个章节标题
    ----------------
#+END_EXAMPLE

怎么样，看起来不难吧，你只要按这个写法，就能被reStructuredText认识，并被解释为章节标题。reStructuredText可用于作为标题修饰的字符有很多很多：

#+BEGIN_EXAMPLE
    ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~
#+END_EXAMPLE

只要你想，上面的任意一个都可以用来作为标题的修饰符，当然，reStructuredText也是有推荐的，它推荐下面这些字符：

#+BEGIN_EXAMPLE
    = - ` : . ' " ~ ^ _ * + #
#+END_EXAMPLE

这些字符是上面一堆字符中稍微看起来不会那么奇怪的一部分，当然，个人建议不要那么花哨，尽量用这两个中的一个：

#+BEGIN_EXAMPLE
    = -
#+END_EXAMPLE

上面实例的写法也许有点复杂，.rst文件中，你还可以只给出下半部分的字符即可：

#+BEGIN_EXAMPLE
    这个标题和上面的一样
    ===================
#+END_EXAMPLE

TIPS：作为修饰的字符长度要大于等于文字长度。另外，标题是能够嵌套的。

**** *段落（Paragraphs）*

段落一般隶属于某个章节中，是一块左对齐并且没有其他元素体标记的块。在.rst文件中，段落和其他内容的分割是靠空行来完成，如果段落相较于其他的段落有缩进，reStructuredText会解析为引用段落，样式上有些不同。

#+BEGIN_EXAMPLE
    这里是一段reStructuredText的内容，它可以很长很长。。。。最后，末尾留出空行表示是本段落的结束即可。


    这里是另外一段reStructuredText的内容，这段内容和上一段之间，乃至后面的其他内容之间都要留出空行进行分割。

        这个也是段落，当时由于缩进了，会变成引用段落。显示和直接的段落有点不同
#+END_EXAMPLE

**** *列表(List)*

列表在HTML中被分为两种，一个是有序列表（Enumerated
Lists），一种是无序列表（Bullet
Lists），在reStructuredText中，我们也能找到这两种列表，还有一种称为定义列表（Definition
Lists），这和HTML中的DL一样，在.[[http://blog.useasp.net/tags/rst文件][rst文件]]中可以支持嵌套列表。

/无序列表/要求文本块是以下面这些字符开始，并且后面紧跟空格，而后跟列表项的内容，其中列表项比趋势左对齐并且有与列表对应的缩进。

#+BEGIN_EXAMPLE
    * + - • ‣ ⁃
#+END_EXAMPLE

还是那句话，用最常用的几个字符就好，不用那么花哨。下面是示例：

#+BEGIN_EXAMPLE
    - 这里是列表的第一个列表项

    - 这是第二个列表项

    - 这是第三个列表项

      - 这是缩进的第一个列表项
        注意，这里的缩进要和当前列表项的缩进同步。

    - 第一级的第四个列表项

    - 列表项之间要用个空格来分割。
#+END_EXAMPLE

/有序列表/在格式上和无序列表差不多，但是在使用的前缀修饰符上，使用的不是无序列表那种字符，而是可排序的字符，可以识别的有下面这些：

#+BEGIN_EXAMPLE
    arabic numerals: 1, 2, 3, ... (no upper limit).
    uppercase alphabet characters: A, B, C, ..., Z.
    lower-case alphabet characters: a, b, c, ..., z.
    uppercase Roman numerals: I, II, III, IV, ..., MMMMCMXCIX (4999).
    lowercase Roman numerals: i, ii, iii, iv, ..., mmmmcmxcix (4999).
#+END_EXAMPLE

如果你不想使用这些，在你标明第一个条目的序号字符后，第二个开始你还可以使用"#"号来让reStructuredText自动生成需要的序号（Docutils
>= 0.3.8）。

#+BEGIN_EXAMPLE
    1. 第一项
        巴拉巴拉好多内容在这里。。。

    #. 第二项

        a. 第二项的第一小项

        #. 第二项的第二小项

    #. 第三项
#+END_EXAMPLE

 /定义列表/：每个定义列表项里面包含术语（term），分类器（classifiers，可选），
定义（definition）。术语是一行文字或者短语，分类器跟在术语后面，用“ ：
”(空格，冒号，空格）分隔。定义是相对于术语缩进后的一个块。定义中可以包含多个段落或者其他的内容元素。术语和定义之间可以没有空行，但是在定义列表前后必须要有空行的存在。下面是示例：

#+BEGIN_EXAMPLE
    术语1
        术语1的定义

    术语 2
        术语2的定义,这是第一段

        术语2的定义，第二段

    术语 3 : 分类器
        术语3的定义


    术语 4 : 分类器1 : 分类器2
        术语4的定义
#+END_EXAMPLE

 TIPS：在reStructuredText中，还有两种列表，一种是字段列表（Field
Lists），一种是选项列表（Option
Lists）。由于是rst的[[http://blog.useasp.net/tags/语法教程][语法入门教程]]，这里不做深入介绍

**** *表格(Table)*

reStructuredText提供两种表格：网格表格（Grid Tables）， 简单表格（Simple
Tables）。

/ 网格表/中，共使用的符号有：

#+BEGIN_EXAMPLE
    - = | +
#+END_EXAMPLE

“-” 用来分隔行， “=“ 用来分隔表头和表体行，"|"
用来分隔列，而"+"用来表示行和列相交的节点，如下面的例子：

#+BEGIN_EXAMPLE
    +------------------------+------------+----------+----------+
    | Header row, column 1   | Header 2   | Header 3 | Header 4 |
    | (header rows optional) |            |          |          |
    +========================+============+==========+==========+
    | body row 1, column 1   | column 2   | column 3 | column 4 |
    +------------------------+------------+----------+----------+
    | body row 2             | Cells may span columns.          |
    +------------------------+------------+---------------------+
    | body row 3             | Cells may  | - Table cells       |
    +------------------------+ span rows. | - contain           |
    | body row 4             |            | - body elements.    |
    +------------------------+------------+---------------------+

    来自docutils的帮助文档.
#+END_EXAMPLE

 TIPS：表头行是可选的，如果你不需要，就可以不用"="来分割了。



/简单表格/：这种表格比网格表来说简单许多，一般用于简单的数据展示。其用于修饰的字符也仅两个而已：

#+BEGIN_EXAMPLE
    = -
#+END_EXAMPLE

一般用"="就能完成简单表格的绘制，如果有表头，同样需要用"="将它和表体(body)内容分开，否则会被视为无表头数据。

#+BEGIN_EXAMPLE
    基本形式
    ========

    `下面这种是最简单的表格形式，当然你也可以去掉表头展示。`

    =====  =====  =======
      A      B    A and B
    =====  =====  =======
    False  False  False
    True   False  False
    False  True   False
    True   True   True
    =====  =====  =======

    表内嵌入
    ========

    `下面这种简单表内有列表`

    =====  =====
    col 1  col 2
    =====  =====
    1      Second column of row 1.
    2      Second column of row 2.
           Second line of paragraph.
    3      - Second column of row 3.

           - Second item in bullet
             list (row 3, column 2).
    \      Row 4; column 1 will be empty.
    =====  =====

    表头合并
    ========

    `表头进行分类合并`

    =====  =====  ======
       Inputs     Output
    ------------  ------
      A      B    A or B
    =====  =====  ======
    False  False  False A
    True   False  True
    False  True   True
    True   True   True
    =====  =====  ======
#+END_EXAMPLE

 TIPS：列需要和"="左对齐，不然可能会导致出错；如果碰到第一列为空时，需要使用"\"来转义，不然会被视为是上一行的延续；网格表和简单表中，简单表比较适合展现简单的数据，这些数据本身不需要太复杂的展现形式，而一旦碰到需要和并单元格这类的复杂操作，可能网格表会更加适合。

表格中还有更复杂的表格形式，比如：CSV表格，列表表格。这些复杂的格式就留给有兴趣的朋友深入吧。

**** *块（Blocks）*

块在reStructuredText中的表现方式也有好几种，但是最常见的是文字块(Literal
Blocks)。这种块的表达非常简单，就是在前面内容结束之后，用两个冒号" ::
"(空格[Optional]，冒号，冒号）来分割，并在之后紧接着插入空行，而后放入块的内容，块内容要相对之前的内容有缩进。

#+BEGIN_EXAMPLE
    这里是块之前的的内容。。。::

       这里是块的内容。前面有缩进，空行，和::分隔符。
        此处内容会被一直视为块内容

        空行也不能阻断块内容。。

    但是，当内容像这样，不再和块内容一样缩进时，块内容就自动的结束了。
#+END_EXAMPLE

这是块的最简单方式，一般我们编写的代码块就是用这种方式表现（如下），
除此之外，.rst还有引用文字块(Quoted Literal Blocks)，行块（Line
Blocks），块引用（Block Quotes）等。

#+BEGIN_EXAMPLE
    下面是我们的测试代码：

    ::

        for i in [1,2,3,4,5]:
            print i
        # 代码块测试

    很简单的代码块测试。
#+END_EXAMPLE

 更多的块内容，请参阅官方帮助文档。

**** *样式(Style)*

reStructuredText中支持对文本进行样式控制，比如：粗体(Strong)，斜体(Italic)，等宽字体(Monospace)，引用( interpreted
text)。

#+BEGIN_EXAMPLE
    .. Strong Emphasis

    This is **Strong Text**. HTML tag is strong.粗体

    .. Italic, Emphasis

    This is *Emphasis* Text.这个HTML使用em， 斜体

    .. Interpreted Text

    This is `Interpreted Text`. 注意，这个HTML一般用<cite>表示

    .. Inline Literals

    This is ``Inline Literals``. HTML tag is <tt>. 等宽字体.
#+END_EXAMPLE



来点补充，如果你需要在文档中插入超链接，那么你可以像下面这样：

#+BEGIN_EXAMPLE
    我这里是一个 链接_.

    .. _链接: http://blog.useasp.net
#+END_EXAMPLE

这种方式要求定义链接，而后引用链接。而且链接要有空格分隔前面的文字。这种方式略嫌麻烦，你可以用更加简化的方式------个人比较推荐：

#+BEGIN_EXAMPLE
    这里同样是一个 `链接<http://blog.useasp.net>`_，不需要特别设置。
#+END_EXAMPLE

**** TIPS：                                                          :tip:

我们会发现，两个处理连接的时候，都需要在链接文字前面要空格与前面进行分割，这个在英文当中比较好处理，因为单个词之间有空格，而在中文中，字之间没有空格，如果加入空格，在显示时会有空格，影响观感，为此，如果在中文中使用，需要考虑好。

到此为止，reStructuredText这个[[http://blog.useasp.net/tags/标记语言][标记语言]]的基本用法已经展现完毕，进入实战吧，骚年！

**** 参考文献：

1. [[http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html][reStructuredText Markup Specification]] (本文有些例子是来源于此页面)

2. 在线reStructuredText编辑器，[[http://rst.ninjs.org/][编辑器1]]，[[https://www.notex.ch/][编辑器2]]

* script
** lua                                                                 :lua:
*** lua简介
http://zh.wikipedia.org/wiki/Lua

1. what?
   Lua（英语发音：/ˈluːə/）程序设计语言是一个简洁、轻量、可扩展的脚本
   语言，是葡萄牙语中“Lua”（月亮）的意思。

2. Features
   + 轻量
     - Lua体积小、启动速度快
     - 编译后仅仅一百余K
     - 和许多“大而全”的语言不一样，网路通讯、图形界面等都没有默认提
       供。但是Lua可以很容易地被扩展：由宿主语言（通常是C或C++）提供这
       些功能，Lua可以使用它们，就像是本来就内置的功能一样。事实上，现
       在已经有很多成熟的扩展模块可供选用。
   + 使用标准C语言编写
   + 开源： 以源代码形式开放
   + 可嵌入： ，可以很方便的嵌入别的程序里。
   + 多重编程范式：
     - 元特性：它只提供了很小的一个特性集合来满足不同编程范式的需要
     - 可“模拟”继承和类
     - 支持函数式编程
   + 原生支持的数据类型非常之少
     - 数字（缺省是双精度浮点数，可配置）
     - 布尔量
     - 字符串
     - 表
     - 子程序
     - 协程（coroutine）
     - 用户自定义数据
   + 处理表和字符串的效率非常之高，加上元表的支持，开发者可以高效的模
     拟出需要的复杂数据类型（比如集合、数组等）。
   + 个动态弱类型语言
   + 支持增量式垃圾收集策略
   + 有内建的，与操作系统无关的协作式多线程（coroutine）支持
   + Lua可以用于嵌入式硬件
** TCL                                                                 :tcl:
*** TCL & Jim-TCL

+ http://www.tcl.tk/
+ http://jim.tcl.tk

**** what is tcl? （工具命令语言）
Tcl (Tool Command Language) is a very powerful but easy to learn
dynamic programming language, suitable for a very wide range of uses,
including web and desktop applications, networking, administration,
testing and many more. Open source and business-friendly, Tcl is a
mature yet evolving language that is truly cross platform, easily
deployed and highly extensible.

Tk is a graphical user interface toolkit that takes developing desktop
applications to a higher level than conventional approaches. Tk is the
standard GUI not only for Tcl, but for many other dynamic languages,
and can produce rich, native applications that run unchanged across
Windows, Mac OS X, Linux and more.

小结：
1. 一门语言
2. 动态脚本
3. 可扩展
4. 开源
5. 平台独立
6. tk是基于tcl的图形界面开发工具包

补充：
1. TCL念作“踢叩” "tickle"
2. Python的GUI接口

**** jim-tcl

Jim is an opensource small-footprint implementation of the Tcl
programming language. It implements a large subset of Tcl and adds new
features like references with garbage collection, closures, built-in
Object Oriented Programming system, Functional Programming commands,
first-class arrays and UTF-8 support. All this with a binary size of
about 100-200kB (depending upon selected options).

The Jim core is very stable. Jim passes over 3000 unit tests and many
Tcl programs run unmodified. Jim is highly modular with the possiblity
to configure many components as loadable modules, or omitted
entirely. A number of extensions are included with Jim which may be
built as loadable modules.

Jim cross compiles easily and is in use in many embedded
environments. It runs under many operating systems, including Linux,
FreeBSD, QNX, eCos, Windows (cygwin and mingw32).

Jim has built-in command line editing for the interactive shell,
jimsh.

小结：
+ Jim-tcl是tcl语言的实现
+ 开源
+ 在tcl之上增加了许多特性
  - 垃圾回收
  - 面向对象
  - UTF-8
  - 函数式编程
+ 小巧
+ 稳定
+ 跨平台

**** tcl vs jimtcl

Jim-Tcl has far fewer features. Jim-Tcl is several dozens of .C adn .H
files and implements the basic Tcl command set. In contrast: Tcl 8.6
is a 4.2MB .zip ifle contraining 1540 files.

Jim-Tcl面向嵌入编程。

**** 小结
1. TCL是一门编程语言，了解即可，不用深入
2. JIM-TCL是TCL语言的一个实现， *简洁，可以在应用在嵌入式开发中*

* SQL                                                                   :SQL:
** General
*** 数据库概述                                                   :database:
**** 数据存储方式
1. 人工管理
2. 文件系统
3. 数据库系统
**** 数据库范式
即数据库应该遵循的规则，关系数据库的范式
+ 第一范式(1NF)
+ 第二范式(2NF)
+ 第三范式(3NF)
+ BCN范式(BCNF)
**** SQL语言
SQL(Structured Query Language)，结构化查询语言，数据库管理系统通过SQL
语言来管理数据库中的数据。分三部分：
+ 数据定义语言(DDL)
+ 数据操作语言(DML)
+ 数据控制语言(DCL)
**** 为什么要使用MySQL
+ 开源
+ 跨平台
+ 价格优势
+ 功能强大且使用方便
**** 常见的数据库系统
+ 甲骨文的 Oracle
+ IBM 的 DB2
+ 微软的 Access 和 SQL Server
+ 开源的 PostgreSQL
+ MySQL
+ 文件数据库 SQLite
+ 内在数据库 HQL
**** 小结
1. 数据存储方式变革
2. SQL语言3类
3. 常用数据库以及选择
*** 事务的属性
事务（Transaction）具有以下四个标准属性，通常根据首字母缩写为 ACID：

+ *原子性* （Atomicity）：确保工作单位内的所有操作都成功完成，否则，事
  务会在出现故障时终止，之前的操作也会回滚到以前的状态。
+ *一致性* （Consistency)：确保数据库在成功提交的事务上正确地改变状态。
+ *隔离性* （Isolation）：使事务操作相互独立和透明。
+ *持久性* （Durability）：确保已提交事务的结果或效果在系统发生故障的
  情况下仍然存在。

** MySQL                                                             :mysql:
*** MySQL简介
**** MySQL
from wiki:

MySQL,原本是一个开放源代码的关系数据库管理系统，原开发者为瑞典的MySQL
AB公司，该公司于2008年被昇阳微系统（Sun Microsystems）收购。2009年，甲
骨文公司（Oracle）收购昇阳微系统公司，MySQL成为Oracle旗下产品。

MySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，
因此被广泛地应用在Internet上的中小型网站中。随着MySQL的不断成熟，它也
逐渐用于更多大规模网站和应用，比如维基百科、Google和Facebook等网站。非
常流行的开源软件组合LAMP中的“M”指的就是MySQL。

但被甲骨文公司收购后，Oracle大幅调涨MySQL商业版的售价，且甲骨文公司不
再支持另一个自由软件项目OpenSolaris的发展，因此导致自由软件社区们对于
Oracle是否还会持续支持MySQL社区版（MySQL之中唯一的免费版本）有所隐忧，
因此原先一些使用MySQL的开源软件逐渐转向其它的数据库。例如维基百科已于
2013年正式宣布将从MySQL迁移到MariaDB数据库。

**** MariaDB
from wiki:

MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL
授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL
闭源的潜在风险，因此社区采用分支的方式来避开这个风险

MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代
替品。在存储引擎方面，10.0.9版起使用XtraDB（名称代号为Aria）来代替
MySQL的InnoDB。

MariaDB由MySQL的创始人麦克尔·维德纽斯主导开发，他早前曾以10亿美元的价
格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，
MySQL的所有权也落入Oracle的手中。MariaDB名称来自麦克尔·维德纽斯的女儿
玛丽亚（英语：Maria）的名字。

*** mysql安装
+ http://blog.fens.me/linux-mysql-install/
+ http://wiki.ubuntu.org.cn/MySQL%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97

**** 源码安装
+ http://blog.sina.com.cn/s/blog_6d39ac7e0101cq48.html
+ ftp://mirror.switch.ch/mirror/mysql/Downloads/MySQL-5.6/

安装成功，但是make uninstall失败

**** apt安装服务器
+ $ sudo apt-get install mysql-server  # 安装的时候会自动安装client
+ $ sudo apt-get install mysql-<VERSION>-client
+ 测试： $ mysqladmin --version

**** [[http://blog.fens.me/linux-mysql-install/][在Ubuntu中安装MySQL]]                                            :blog:

[[http://blog.fens.me/series-ubuntu/][Ubuntu实用工具系列文章]]，将介绍基于Linux
ubuntu的各种工具软件的配置和使用。有些工具大家早已耳熟能详，有些工具经常用到但确依然陌生。我将记录我在使用操作系统时，安装及配置工具上面的一些方法，把使用心得记录下来也便于自己的以后查找和回忆。

*关于作者：*

- 张丹(Conan), 程序员Java,R,PHP,Javascript
- weibo：@Conan_Z
- blog: [[http://blog.fens.me/][http://blog.fens.me]]
- email: bsspirit@gmail.com

*转载请注明出处：*
 [[http://blog.fens.me/linux-mysql-install/]]

[[http://blog.fens.me/wp-content/uploads/2014/03/ubuntu-mysql-install.png][[[http://blog.fens.me/wp-content/uploads/2014/03/ubuntu-mysql-install.png]]]]

*前言*

安装MySQL是个老话题，我安装MySQL服务器已不下百次了，为了博客文章结构的连贯性，还是再写一篇做为环境基础，同时也给自己一个备忘。

*目录*

1. MySQL在Windows中安装
2. MySQL在Linux Ubuntu中安装
3. 通过命令行客户端访问MySQL
4. 修改MySQL服务器的配置
5. 新建数据库并设置访问账号
6. 改变数据存储位置

***** 1. MySQL在Windows中安装

在Windows系统上安装MySQl数据库是件非常简单的事情，下载压缩包，解压即可。下载地址：[[http://dev.mysql.com/downloads/mysql/]]

- MySQL服务器运行命令：MySQL安装目录/bin/mysqld.exe
- MySQL客户端运行命令：MySQL安装目录/bin/mysql.exe

***** 2. MySQL在Linux Ubuntu中安装

本文使用的Linux是Ubuntu 12.04.2 LTS
64bit的系统，安装MySQL数据库软件包可以通过apt-get实现。

在Linux Ubuntu中安装MySQL数据库

#+BEGIN_EXAMPLE
    #安装MySQL服务器端
    ~ sudo apt-get install mysql-server
#+END_EXAMPLE

安装过程会弹出提示框，输入root用户的密码，我在这里设置密码为mysql。

安装完成后，MySQL服务器会自动启动，我们检查MySQL服务器程序

#+BEGIN_EXAMPLE
    # 检查MySQL服务器系统进程
    ~ ps -aux|grep mysql
    mysql     3205  2.0  0.5 549896 44092 ?        Ssl  20:10   0:00 /usr/sbin/mysqld
    conan     3360  0.0  0.0  11064   928 pts/0    S+   20:10   0:00 grep --color=auto mysql

    # 检查MySQL服务器占用端口
    ~ netstat -nlt|grep 3306
    tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN

    # 通过启动命令检查MySQL服务器状态
    ~ sudo /etc/init.d/mysql status
    Rather than invoking init scripts through /etc/init.d, use the service(8)
    utility, e.g. service mysql status

    Since the script you are attempting to invoke has been converted to an
    Upstart job, you may also use the status(8) utility, e.g. status mysql
    mysql start/running, process 3205

    # 通过系统服务命令检查MySQL服务器状态
    ~ service mysql status
    mysql start/running, process 3205
#+END_EXAMPLE

***** 3. 通过命令行客户端访问MySQL

安装MySQL服务器，会自动地一起安装MySQL命令行客户端程序。

在本机输入mysql命令就可以启动，客户端程序访问MySQL服务器。

#+BEGIN_EXAMPLE
    ~ mysql
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 42
    Server version: 5.5.35-0ubuntu0.12.04.2 (Ubuntu)

    Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    mysql>
#+END_EXAMPLE

使用户名和密码，登陆服务器

#+BEGIN_EXAMPLE
    ~ mysql -uroot -p
    Enter password:
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 37
    Server version: 5.5.35-0ubuntu0.12.04.2 (Ubuntu)

    Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    mysql>
#+END_EXAMPLE

MySQL的一些简单的命令操作。

#+BEGIN_EXAMPLE
    # 查看所有的数据库
    mysql> show databases;
    +--------------------+
    | Database           |
    +--------------------+
    | information_schema |
    | test               |
    +--------------------+
    2 rows in set (0.00 sec)

    # 切换到information_schema库
    mysql> use information_schema
    Reading table information for completion of table and column names
    You can turn off this feature to get a quicker startup with -A

    Database changed

    # 查看information_schema库中所有的表
    mysql> show tables;
    +---------------------------------------+
    | Tables_in_information_schema          |
    +---------------------------------------+
    | CHARACTER_SETS                        |
    | COLLATIONS                            |
    | COLLATION_CHARACTER_SET_APPLICABILITY |
    | COLUMNS                               |
    | COLUMN_PRIVILEGES                     |
    | ENGINES                               |
    | EVENTS                                |
    | FILES                                 |
    | GLOBAL_STATUS                         |
    | GLOBAL_VARIABLES                      |
    | KEY_COLUMN_USAGE                      |
    | PARAMETERS                            |
    | PARTITIONS                            |
    | PLUGINS                               |
    | PROCESSLIST                           |
    | PROFILING                             |
    | REFERENTIAL_CONSTRAINTS               |
    | ROUTINES                              |
    | SCHEMATA                              |
    | SCHEMA_PRIVILEGES                     |
    | SESSION_STATUS                        |
    | SESSION_VARIABLES                     |
    | STATISTICS                            |
    | TABLES                                |
    | TABLESPACES                           |
    | TABLE_CONSTRAINTS                     |
    | TABLE_PRIVILEGES                      |
    | TRIGGERS                              |
    | USER_PRIVILEGES                       |
    | VIEWS                                 |
    | INNODB_BUFFER_PAGE                    |
    | INNODB_TRX                            |
    | INNODB_BUFFER_POOL_STATS              |
    | INNODB_LOCK_WAITS                     |
    | INNODB_CMPMEM                         |
    | INNODB_CMP                            |
    | INNODB_LOCKS                          |
    | INNODB_CMPMEM_RESET                   |
    | INNODB_CMP_RESET                      |
    | INNODB_BUFFER_PAGE_LRU                |
    +---------------------------------------+
    40 rows in set (0.01 sec)

    # 查看数据库的字符集编码
    mysql> show variables like '%char%';
    +--------------------------+----------------------------+
    | Variable_name            | Value                      |
    +--------------------------+----------------------------+
    | character_set_client     | utf8                       |
    | character_set_connection | utf8                       |
    | character_set_database   | utf8                       |
    | character_set_filesystem | binary                     |
    | character_set_results    | utf8                       |
    | character_set_server     | latin1                     |
    | character_set_system     | utf8                       |
    | character_sets_dir       | /usr/share/mysql/charsets/ |
    +--------------------------+----------------------------+
    8 rows in set (0.00 sec)
#+END_EXAMPLE

***** 4. 修改MySQL服务器的配置

接下来，我需要做一些配置，让MySQL符合基本的开发要求。

*4.1 将字符编码设置为UTF-8*

默认情况下，MySQL的字符集是latin1，因此在存储中文的时候，会出现乱码的情况，所以我们需要把字符集统一改成UTF-8。

用vi打开MySQL服务器的配置文件my.cnf

#+BEGIN_EXAMPLE
    ~ sudo vi /etc/mysql/my.cnf

    #在[client]标签下，增加客户端的字符编码
    [client]
    default-character-set=utf8

    #在[mysqld]标签下，增加服务器端的字符编码
    [mysqld]
    character-set-server=utf8
    collation-server=utf8_general_ci
#+END_EXAMPLE

*4.2 让MySQL服务器被远程访问*

默认情况下，MySQL服务器不允许远程访问，只允许本机访问，所以我们需要设置打开远程访问的功能。

用vi打开MySQL服务器的配置文件my.cnf

#+BEGIN_EXAMPLE
    ~ sudo vi /etc/mysql/my.cnf

    #注释bind-address
    #bind-address            = 127.0.0.1
#+END_EXAMPLE

修改后，重启MySQL服务器。

#+BEGIN_EXAMPLE
    ~ sudo /etc/init.d/mysql restart
    Rather than invoking init scripts through /etc/init.d, use the service(8)
    utility, e.g. service mysql restart

    Since the script you are attempting to invoke has been converted to an
    Upstart job, you may also use the stop(8) and then start(8) utilities,
    e.g. stop mysql ; start mysql. The restart(8) utility is also available.
    mysql start/running, process 3577
#+END_EXAMPLE

重新登陆服务器

#+BEGIN_EXAMPLE
    ~ mysql -uroot -p
    Enter password:
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 37
    Server version: 5.5.35-0ubuntu0.12.04.2 (Ubuntu)

    Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    # 再次查看字符串编码
    mysql> show variables like '%char%';
    +--------------------------+----------------------------+
    | Variable_name            | Value                      |
    +--------------------------+----------------------------+
    | character_set_client     | utf8                       |
    | character_set_connection | utf8                       |
    | character_set_database   | utf8                       |
    | character_set_filesystem | binary                     |
    | character_set_results    | utf8                       |
    | character_set_server     | utf8                       |
    | character_set_system     | utf8                       |
    | character_sets_dir       | /usr/share/mysql/charsets/ |
    +--------------------------+----------------------------+
    8 rows in set (0.00 sec)
#+END_EXAMPLE

我们检查MySQL的网络监听端口

#+BEGIN_EXAMPLE
    # 检查MySQL服务器占用端口
    ~ netstat -nlt|grep 3306
      tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN
#+END_EXAMPLE

我们看到从之间的网络监听从 127.0.0.1:3306 变成 0
0.0.0.0:3306，表示MySQL已经允许远程登陆访问。通过root账号远程访问，是非常不安全的操作，因此我们下一步，将新建一个数据库，再新建一个用户进行远程访问。

***** 5. 新建数据库并设置访问账号

通过root账号登陆MySQl服务器

#+BEGIN_EXAMPLE
    ~ mysql -uroot -p
    Enter password:
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 39
    Server version: 5.5.35-0ubuntu0.12.04.2 (Ubuntu)

    Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    # 新建数据库abc
    mysql> CREATE DATABASE abc;

    # 使用数据库abc
    mysql> use abc;
    Database changed

    # 在数据库abc中，新建一张表a1
    mysql> create table a1(id int primary key,name varchar(32) not null);
    Query OK, 0 rows affected (0.05 sec)

    # 新建book用户，密码为book，允许book可以远程访问abc数据库，授权book对abc进行所有数据库
    mysql> GRANT ALL ON abc.* to book@'%' IDENTIFIED BY 'book';
    Query OK, 0 rows affected (0.00 sec)

    #允许book可以本地访问abc数据库，授权book对abc进行所有数据库
    mysql> GRANT ALL ON abc.* to book@localhost IDENTIFIED BY 'book';
    Query OK, 0 rows affected (0.00 sec)
#+END_EXAMPLE

我们在本地使用book用户登陆

#+BEGIN_EXAMPLE
    # 使用book用户登陆
    ~ mysql -ubook -p
    Enter password:
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 40
    Server version: 5.5.35-0ubuntu0.12.04.2 (Ubuntu)

    Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    #进行abc数据库
    mysql> use abc;
    Reading table information for completion of table and column names
    You can turn off this feature to get a quicker startup with -A

    Database changed

    #查看abc数据库的表
    mysql> show tables;
    +---------------+
    | Tables_in_abc |
    +---------------+
    | a1            |
    +---------------+
    1 row in set (0.00 sec)
#+END_EXAMPLE

我们在远程的另一台Linux使用book用户登陆

#+BEGIN_EXAMPLE
    ~ mysql -ubook -p -h 192.168.1.199
    Enter password:
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 41
    Server version: 5.5.35-0ubuntu0.12.04.2 (Ubuntu)

    Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    mysql> use abc
    Reading table information for completion of table and column names
    You can turn off this feature to get a quicker startup with -A

    Database changed
    mysql> show tables;
    +---------------+
    | Tables_in_abc |
    +---------------+
    | a1            |
    +---------------+
    1 row in set (0.00 sec)
#+END_EXAMPLE

***** 5. 改变数据存储位置

有时候我们可能还需要改变MySQL数据存储的位置，一种方法是直接修改配置文件
/etc/mysql/my.cnf，找到datadir属性修改目录。

#+BEGIN_EXAMPLE
    ~ vi /etc/mysql/my.cnf

    [mysqld]
    datadir         = /var/lib/mysql
#+END_EXAMPLE

如果通过这种方法修改，那么其他的调用存储路径的地方，我们也都需要进行修改，比如
用到了/usr/bin/mysql_install_db
命令，文件中ldata的属性也需要修改，关于mysql_install_db
命令的使用可以参考文章，[[http://blog.fens.me/mysql-ibdata1/][[MySQL优化]为MySQL数据文件ibdata1瘦身]]。

还有另一种修改存储位置的方法，就是通过Linux系统的软连(ln
-s)接来做的。当我们新挂载一块硬盘，停止MySQL服务，然后把/var/lib/mysql目录移动到新的硬盘存储，在/var/lib/mysql处建立指定新位置的软连接就行了。

#+BEGIN_EXAMPLE
    # 停止MySQL服务器
    ~ /etc/init.d/mysql stop

    # 挂载硬盘
    ~ mount -t ext4 /dev/vdb1 /vdb1

    # 建立新存储目录
    ~ mkdir /vdb1/data

    # 移动MySQL数据目录到新目录
    ~ mv /var/lib/mysql /vdb1/data/

    # 软连接
    ~ ln -s /vdb1/data/mysql /var/lib/mysql
#+END_EXAMPLE

修改apparmor的别名定义文件

#+BEGIN_EXAMPLE
    ~ vi /etc/apparmor.d/tunables/alias

    alias /var/lib/mysql/ -> /vdb1/data/mysql/,
#+END_EXAMPLE

注：如果没有修改apparmor的配置，MySQL会启动不了，并一直提示是权限的问题。

#+BEGIN_EXAMPLE
    # 重启apparmor服务
    ~ /etc/init.d/apparmor restart

    # 重启MySQL服务器
    ~ /etc/init.d/mysql start
#+END_EXAMPLE

这样就完成了，MySQL数据存储位置修改。

通过上面的操作，我们就把MySQL数据库服务器，在Linux
Ubuntu中的系统安装完成。

*** MySQL基础
**** 什么是MySQL

***** 数据库相关概念
+ 关系
+ 数据库系统
+ 数据表
+ 记录
+ 字段
+ 查询
+ SQL
+ 索引
+ 键

***** MySQL功能
+ 关系数据库系统
+ 客户/服务器体系
+ SQL兼容
+ 子查询
+ 视图
+ Unicode
+ 全文搜索
+ 外键约束
+ GIS
+ ODBC
+ 跨平台/平台独立： Linux, Windows, MacOS
+ 多语言：C/C++, Java, Perl, PHP, Python
+ 速度

***** MySQL不足
+ 数据表锁定
+ 不能热备份
+ 不支持自定义数据结构
+ 对XML支持不好
+ 没有OLAP(online analytical processing)功能
+ GIS支持不完善

**** mysql, mysqladmin和mysqldump
***** mysql
mysql只是用来与MySQL服务器交互的一种客户端程序， 只支持文本模式。

1. 启动
   1) 命令：$ mysql [options] [database]
   2) 选项
      + -u name 或 -usr=name
      + -p 提示输入密码
      + -P 端口
      + -protocol=name
      + -default-character-set
2. 交互式使用mysql
   + 选项--i-am-a-dummy:防止新手失误对数据库造成不可恢复的破坏
   + 命令
     |-----------------------+--------------+----------------------------|
     | \c     | clear        | 放弃正在输入的命令         |
     | \h     | help         | 显示命令清单               |
     | \q     | exit/quit    |                            |
     | \s     | status       |                            |
     | \T f   | tee file     | 把输入输出记载到指定文件中 |
     | \t     | notee        |                            |
     | \u  db | use datebase | 另行指定一个数据库         |
     | \. fn  | source file  | 读取并指定文件的SQL命令，命令必须以分号隔开 |
     |-----------------------+--------------+---------------------------------------------|
     注：
     + 简写形式只能用于行中或行尾，行首需要使用完整形式

3. 使用技巧
   + tab补全
   + 快捷键，与Emacs一致
   + 个人配置文件： ~/.my.cnf
   + 字符集: unicode
4. 处理SQL文件
   #+BEGIN_EXAMPLE
   mysql [options] database < file.sql
   #+END_EXAMPLE
   + .sql后缀不是必要的

***** mysqladmin
系统管理任务

***** mysqldump
创建备份

***** 图形用户界面
+ MySQL Adminstrator
+ MySQL Query Browser

**** MySQL初始化
+ MySQL安装后，默认的root用户密码为空
  - mysqladmin -u root password "xxxxxx"
+ 使用mysql连接到MySQL服务器
  - mysql -u root -p
+ Linux系统启动时启动MySQL，在/etc/rc.local文件添加：(没有验证)
  - /etc/init.d/mysql start
  - 将mysqld二进制文件添加到/etc/init.d/目录中

**** MySQL管理
+ 查看MySQL服务器是否启动： ps -ef | grep mysqld
+ 启动MySQL: $ /usr/bin/safe_mysqld &
+ 关闭MySQL: $ /usr/bin/mysqlmin -u root -p shutdown
+ 添加用户: 在mysql数据库的 *user表* 添加新的用户
  + INSERT INTO user ...
    \begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\linewidth]{/home/ben/Wally/Journal/Figure/scrot/2878erz.png}
    \end{figure}

    - select_priv
    - insert_priv
    - update_priv
    - delete_priv
    - create_priv
    - drop_priv
    - reload_priv
    - shutdown_priv
    - process_priv
    - file_priv
    - grant_priv
    - references_priv
    - index_priv
    - aler_priv

  + GRAND ...
    \begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\linewidth]{/home/ben/Wally/Journal/Figure/scrot/2878Q1C.png}
    \end{figure}

  + 注：MySQL语句以分号作为结束标识

+ 配置文件 */etc/mysql/my.cnf*

+ 常用命令
  - USE <database>
  - SHOW DATABASES
  - SHOW TABLES
  - SHOW COLUMNS FORM <table>
  - SHOW INDEX FROM <table>
  - SHOW TABLE STATUS LIKE <TABLE>\G

**** MySQl PHP 语法
+ PHP MySQL函数以mysql为前缀，eg.
  - mysqli_connect($connect);
  - mysqli_query($connect, "SQL statement");
  - mysql_fetch_array();
  - mysql_connect()
  - mysql_close()

**** MySQL连接
1. 二进制形式： $mysql -u root -p
2. PHP脚本：mysql_connect()
   + 语法： connection mysql_connect(server, user, passwd, new_link, client_flag)
   + server
     - 可选，规定要连接的服务器
     - 可以包括端口号, 如， hostname:port
     - 或本地套接字的路径，/path/to/socket
     - 默认为 localhost:3306
   + user，用户名，可选，默认为服务器进程所有者的用户名
   + passwd,密码，可选，默认为空
   + new_link，可选
   + client_flag， 可选

**** MySQL PHP
+ 启动MySQL服务: /etc/init.d/mysql start
+ 登录MySQL： mysql -u root -p


1. 二进制形式： $mysql -u root -p
2. PHP脚本：mysql_connect()
   + 语法： connection mysql_connect(server, user, passwd, new_link, client_flag)
   + server
     - 可选，规定要连接的服务器
     - 可以包括端口号, 如， hostname:port
     - 或本地套接字的路径，/path/to/socket
     - 默认为 localhost:3306
   + user，用户名，可选，默认为服务器进程所有者的用户名
   + passwd,密码，可选，默认为空
   + new_link，可选
   + client_flag， 可选

#+BEGIN_SRC html :tangle /home/ben/.apache/mysql_conn.php
  <html>
    <head>
      <title>Connecting MySQL Server</title>
    </head>
    <body>
      <?php
        $dbhost = "localhost:3306";
        $dbuser = "root";
        $dbpass = "t910112";
        $conn = mysql_connect($dbhost, $dbuser, $dbpass);
        if(! $conn)
        die('Could not connect:' . mysql_error());
        echo "Connected successfully";
        mysql_close($conn);
      ?>
    </body>
  </html>
#+END_SRC

**** MySQL创建数据库
+ create database <DATABASE>
+ bool mysql_query(sql, connection)

#+BEGIN_SRC html :tangle /home/ben/.apache/mysql_create.php
  <html>
    <head>
      <title>Creating MySQL Database</title>
    </head>
    <body>
      <?php
        $dbhost = "localhost:3306";
        $dbuser = "root";
        $dbpass = "t910112";
        $conn = mysql_connect($dbhost, $dbuser, $dbpass);
        if(! $conn)
            die("Could not connect:" . mysql_error());
        echo 'Connected successfully<br />';
        $sql = "CREATE DATABASE TUTORIAL";
        $retval=mysql_query($sql, $conn);
        if(! $retval)
            die("Could not create database" . mysql_error());
        echo "Datebase TUTORIAL created successfully";
        mysql_close($conn);
      ?>
    </body>
  </html>
#+END_SRC

**** MySQL 删除数据库
+ drop database <DATABASE>
#+BEGIN_SRC html :tangle /home/ben/.apache/mysql_drop.php
  <html>
    <head>
      <title>Creating MySQL Database</title>
    </head>
    <body>
      <?php
        $dbhost = "localhost:3306";
        $dbuser = "root";
        $dbpass = "t910112";
        $conn = mysql_connect($dbhost, $dbuser, $dbpass);
        if(! $conn)
            die("Could not connect:" . mysql_error());
        echo 'Connected successfully<br />';
        $sql = "DROP DATABASE TUTORIAL";
        $retval=mysql_query($sql, $conn);
        if(! $retval)
            die("Could not create database" . mysql_error());
        echo "Datebase TUTORIAL dropped successfully";
        mysql_close($conn);
      ?>
    </body>
  </html>
#+END_SRC

**** MySQL 选择数据库
+ use <DATABASE>
+ bool mysql_select_db(db_name, connection);

#+BEGIN_SRC html :tangle /home/ben/.apache/mysql_select.php
  <html>
    <head>
      <title>Creating MySQL Database</title>
    </head>
    <body>
      <?php
        $dbhost = "localhost:3306";
        $dbuser = "root";
        $dbpass = "t910112";
        $conn = mysql_connect($dbhost, $dbuser, $dbpass);
        if(! $conn)
            die("Could not connect:" . mysql_error());
        echo 'Connected successfully<br />';
        $select = mysql_select_db("mysql");
        if($select)
            echo "succeed!";
        mysql_close($conn);
      ?>
    </body>
  </html>
#+END_SRC
**** MySQL 数据类型
1. 数值类型
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.8\linewidth]{/home/ben/Wally/Journal/Figure/scrot/18694PAw.png}
   \end{figure}

   + SQL标准类型： INTERGER, SMALLINT, DECIMAL, NUMERIC, FLOAT, REAL, DOUBLE
   + 扩展类型：TINYINT, MEDIUMINT, BIGINT

2. 日期和时间
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.8\linewidth]{/home/ben/Wally/Journal/Figure/scrot/18694cK2.png}
   \end{figure}

3. 字符串类型
   \begin{figure}[ht]
   \centering
   \includegraphics[width=0.8\linewidth]{/home/ben/Wally/Journal/Figure/scrot/18694OUF.png}
   \end{figure}

   + CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度
     和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写
     转换。

   + BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字
     符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符
     字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。

   + BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：
     MEDIUMBLOB LONGBLOB TINYBLOB BLOB. 它们只是可容纳值的最大长度不同。

   + 有4种TEXT类型：TINYTEXT TEXT MEDIUMTEXT和LONGTEXT。这些对应4种
     BLOB类型，有相同的最大长度和存储需求。
**** MySQL 创建数据表
+ 创建MySQL数据表需要以下信息
  - 表名
  - 表字段名
  - 定义每个表字段
+ create table TABLE_NAME {COLUMN_NAME, COLUMN_TYPE};
  \begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\linewidth]{/home/ben/Wally/Journal/Figure/scrot/18694beL.png}
  \end{figure}

  - 如果你不想字段为 *NULL* 可以设置字段的属性为 *NOT NULL* ，在操作数
    据库时如果输入该字段的数据为NULL，就会报错
  - *AUTO_INCREMENT* 定义列为自增的属性，一般用于主键，数值会自动加1
  - *PRIMARY KEY* 关键字用于定义列为主键。可以使用多列来定义主键，列间
    以逗号分隔。

+ bool my_query(sql, connection)

#+BEGIN_SRC html :tangle /home/ben/.apache/mysql_create_table.php
  <html>
    <head>
      <title>Creating MySQL Database</title>
    </head>
    <body>
      <?php
        $dbhost = "localhost:3306";
        $dbuser = "root";
        $dbpass = "t910112";
        $conn = mysql_connect($dbhost, $dbuser, $dbpass);
        if(! $conn)
            die("Could not connect:" . mysql_error());
        echo 'Connected successfully<br />';
        $sql = "CREATE DATABASE TUTORIAL";
        $create = mysql_query($sql, $conn);
        if(! $create)
            die("failed to create datebase" . mysql_error());
        $sql = "create table tutorials_tbl(" .
               "tutorial_id INT NOT NULL AUTO_INCREMENT, " .
               "tutorial_title VARCHAR(100) NOT NULL, " .
               "tutorial_author VARCHAR(40) NOT NULL, " .
               "submission_date DATE, " .
               "PRIMARY KEY (tutorial_id)); ";
        mysql_select_db("TUTORIAL");
        $retval = mysql_query($sql, $conn);
        if(! $retval)
            die("Could not create table: " . mysql_error());
        echo "Table created successfully";
        mysql_close($conn);
      ?>
    </body>
  </html>
#+END_SRC
**** MySQL 插入数据
+ MySQL语法
  #+BEGIN_EXAMPLE
    INSERT INTO tabel_NAME (filed1, field2, ..., fieldN)
                           VALUE
                           (value1, value2, ..., valueE);
  #+END_EXAMPLE
  + 如果数据是字符型，必须使用单引号或者双引号，如："value"。
+ bool mysql_query(sql, connection)


** SQLite                                                           :sqlite:
*** SQLite                                                       :tutorial:
**** what
SQLite是一个进程内的库，实现了 *数据库引擎*
+ 自给自足的
+ 零配置的
+ 无服务器的
+ 事务性的

**** why
+ 不需要单独的服务器进程
+ 零配置
+ 以文件形式存储
+ 轻量级，小于400k
+ 自给自足，不需要外部依赖
+ 支持SQL92的大多数查询语言的功能
+ 开源
+ 跨平台

**** SQLite命令

1. 数据定义语言 DDL
   + CREATE
   + ALTER
   + DROP
2. 数据操作语言
   + INSERT
   + UPDATE
   + DELETE
3. 数据查询语言
   + SELECT

**** 安装
1. apt-get
2. source code*

**** 常用命令
+ 以句点开头
+ 不以分号结束

e.g.
- .help
- .show
- .schema

**** SQLite语法
1. 不区分大小写
2. 注释 --开头或者/*COMMENT*/
3. SQL语句以关键字开头，分号结束

**** SQLite数据类型
1. 数据类
2. Affinity类型

**** 创建数据库
#+BEGIN_EXAMPLE
$ sqlite3 testDB.db
>.database  -- 查看数据库信息
>.quit -- 退出
$ sqlite3 testDB.db .dump > test.sql -- 保存到文本文件中
#+END_EXAMPLE

**** 附加数据库
sqlite>ATTATCH DATABASE 'DatabaseName' as 'AliasName';

main和temp是保留名称

**** 分离数据库
sqlite>DETACH DATABASE 'AliasName'

**** 创建表
#+BEGIN_EXAMPLE
CREATE TABLE database_name.table_name(
   column1 datatype  PRIMARY KEY(one or more columns),
   column2 datatype,
   column3 datatype,
   .....
   columnN datatype,
);
#+END_EXAMPLE

e.g.
#+BEGIN_EXAMPLE
sqlite> CREATE TABLE COMPANY(
   ID INT PRIMARY KEY     NOT NULL,  -- NOT NULL 用于约束字段不能为NULL
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);

#+END_EXAMPLE

>.tables -- 列出表
>.schema COMPANY -- 查看表

**** 删除表
>DROP TABLE database_name.table_name;

**** INSERT
#+BEGIN_EXAMPLE
INSERT INTO TABLE_NAME (column1, column2, column3,...columnN) \
VALUES (value1, value2, value3,...valueN);
#+END_EXAMPLE

#+BEGIN_EXAMPLE
INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);
#+END_EXAMPLE

#+BEGIN_EXAMPLE
INSERT INTO first_table_name [(column1, column2, ... columnN)]
   SELECT column1, column2, ...columnN
   FROM second_table_name
   [WHERE condition];
#+END_EXAMPLE

**** SELECT
SELECT column1, column2, columnN FROM table_name;

>.header on
>.mode column
>.width 10, 20, 10 -- 输出设置

*** SQLite

SQLite 是一个自持的（self-contained）、无服务器的、零配置的、事务型的
关系型数据库引擎。因为他很小，所以也可以作为嵌入式数据库内建在你的应用
程序中。SQLite 被应用在 Solaris 10操作系统、Mac OS 操作系统、iPhone 和
Skype 中。QT4 、Python 、 PHP 都默认支持 SQLite ，Firefox Amarok 等流
行的应用程序在内部也使用了 SQLite.

SQLite数据库引擎实现了主要的SQL-92标准，引擎本身只有一个文件，大小不到
300k ，但是并不作为一个独立的进程运行，而是动态或者静态的链接到其他应
用程序中。它生成的数据库文件是一个普通的磁盘文件，可以放置在任何目录下。
SQLite 本身是C语言开发的，开源也跨平台，并且被所有的主流编程语言支持。

1. 基本命令
   1) sqlite3
   2) .help  帮助命令，所有的命令都是以句点开头
   3) .quit/.exit 退出命令
2.

* progress
** GNU Make

#+BEGIN_EXAMPLE
- State "TOBECONTINED" from "TODO"       [2015-11-23 一 14:34]
- State "TODO"       from ""           [2015-11-23 一 14:12] \\
  Make学习之路
#+END_EXAMPLE

*** 项目规化
1. 学习教材： 《GNU Make项目管理》
2. 学习计划： *按章节来* ，教材布局合理，由浅入深，内容均布
   1) 首先无笔记式地阅读书籍，计划平均 *1小时*
      - 不圈不点
      - 不实现程序
      - 遇到不会但不是核心的东西暂时不管
   2) 阅读电子版书籍，计划平均 *1.5小时*
      - 实现源码
      - 做ORG-笔记
      - 将不会但不相关的知识使用 *org-capture* 添加到待为事项中，等有
        时间处理
   3) *小结* 并 规化下一步

*** make 入门
- State "TOBECONTINED" from ""           [2015-11-23 一 17:25]
CLOCK: [2015-11-20 五 18:31]--[2015-11-20 五 19:43] =>  1:12
CLOCK: [2015-11-20 五 10:12]--[2015-11-20 五 11:24] =>  1:12

**** minted for makefile                                          :minted:
#+begin_example
  $ pygmentize -l lexers | grep make
  ,* basemake:
  ,* cmake:
      cmake (filenames *.cmake, cmakelists.txt)
  ,* make, makefile, mf, bsdmake:
      makefile (filenames *.mak, makefile, makefile, makefile.*, gnumakefile)
#+end_example

*make,  makefile,  mf*

**** make VS scripts
相对于脚本，make的优点是：
*你可以把程序中各元素之间的关系告诉make，然后make会根据这些关系和时间
戳判断应该重新进行哪些步骤，以及产生你所需要的程序*

**** 规则(rule)
1) 工作目标(target)
2) 必要条件(prerequisite)
3) 命令(command)

#+begin_latex
  \begin{minted}[frame=single, mathescape]{mf}
  target:prereq1 prereq2
      commands
  \end{minted}
#+end_latex

e.g.
#+begin_latex
\begin{minted}[frame=single, mathescape]{mf}
foo.o: foo.c foo.h
    gcc -c foo.c
\end{minted}
#+end_latex

运行过程中任何错误都会使make终止工作目标的建立并结束运行。

demo1

** 数据库学习

#+BEGIN_EXAMPLE
- State "TODO"       from ""           [2015-11-23 一 14:48] \\
  数据库的学习可能有必要
#+END_EXAMPLE

*** TODO 项目规化 [1/1]

1. [X] 数据库选择: MySQL 还是 SQLite（优点之一，无后台服务，可以应用于嵌入
   式中）
2. [ ]必要性在哪： *没有找到切切实实的应用之前不要开始*
** Qt 学习
*** 项目规化
*** Chapter 1
**** Hello Qt
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/helloqt/helloqt.cpp
  #include <QApplication>
  #include <QLabel>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QLabel* label = new QLabel("Hello Qt!");
    label->show();
    return app.exec();
  }
#+END_SRC

+ 窗口部件(widget)是指用户界面的一个可视化元素，该词源于"window
  gadget"（窗口配件），相当于Window系统术语的”控件”(control)和”容
  器”(container).
+ QApplication对象用于管理整个应用程序所用到的资源，以argc和argv为参
  数，也就是说，Qt支持自己的一些命令行参数。
+ 绝大多数应用程序都会使用一个QMainWindow或一个QDialog作为它的窗口，但
  Qt是如此灵活，以至于任意窗口部件都可以用作窗口。
+ show()方法使部件可见，在创建窗口部件时标签通常都是隐藏的，这样允许先
  进行设置再显示，避免闪烁。
+ app.exec()方法使程序进入事件循环状态，这是一种等待状态，程序会等候用
  户的动作。

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/helloqt2/helloqt.cpp
  #include <QApplication>
  #include <QLabel>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QLabel* label = new QLabel("<h2><i>Hello</i><font color=red>Qt!</font></h2>");

    label->show();
    return app.exec();
  }
#+END_SRC

+ 通过使用一些简单的HTML样式格式，就可以轻松地把Qt应用程序的用户接口变
  得丰富多彩。
**** 建立连接
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/quit/quit.cpp
  #include <QApplication>
  #include <QPushButton>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QPushButton *button = new QPushButton("quit");
    QObject::connect(button, SIGNAL(clicked()), &app, SLOT(quit()));
    button->show();
    return app.exec();
  }

#+END_SRC

**** 窗口部件的布局
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/age/age.cpp
  #include <QApplication>
  #include <QHBoxLayout>
  #include <QSpinBox>
  #include <QSlider>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QWidget* window = new QWidget;
    window->setWindowTitle("Enter your age:");

    QSpinBox* spinBox = new QSpinBox;
    QSlider* slider = new QSlider(Qt::Horizontal);
    spinBox->setRange(0, 130);
    slider->setRange(0, 130);

    QObject::connect(spinBox, SIGNAL(valueChanged(int)),
                     slider, SLOT(setValue(int)));
    QObject::connect(slider, SIGNAL(valueChanged(int)),
                     spinBox, SLOT(setValue(int)));

    QHBoxLayout* layout = new QHBoxLayout;
    layout->addWidget(spinBox);
    layout->addWidget(slider);
    window->setLayout(layout);
    window->show();
    return app.exec();
  }
#+END_SRC

Qt有三个主要的布局管理器：
+ QHBoxLayout
+ QVBoxLayout
+ QGridLayout

**** 窗口部件的风格
Qt应用程序在每个平台上都可以看起来像本地程序一样，Qt是通过所模拟平台的
外观来实现这一点的，而不是针对某个特殊平台的封闭或者一个工具包中的窗口
部件集。
+ Plastique(KDE)
+ Cleanlooks(GNOME)
+ CDE
+ motif
+ Windows(仅能在本地平台上有效，因为需要依赖平台的主题引擎，下同)
+ Windows XP
+ Windows Vista
+ Mac


在X11下，可以在命令行设置程序窗口风格
#+BEGIN_EXAMPLE
./out -style motif
#+END_EXAMPLE

*** 创建对话框
**** 子类化QDialog
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/finddialog.h
  #ifndef FINDDIALOG_H
  #define FINDDIALOG_H

  #include <QDialog>

  class QCheckBox;
  class QLabel;
  class QLineEdit;
  class QPushButton;

  class FindDialog : public QDialog{
    Q_OBJECT

  public:
    FindDialog(QWidget *parent=0);

  signals:
    void findNext(const QString& str, Qt::CaseSensitivity cs);
    void findPrevious(const QString& str, Qt::CaseSensitivity cs);

  private slots:
    void findClicked();
    void enableFindButton(const QString& text);

  private:
    QLabel *label;
    QLineEdit *lineEdit;
    QCheckBox *caseCheckBox;
    QCheckBox *backwardCheckBox;
    QPushButton *findButton;
    QPushButton *closeButton;
  };

  #endif
#+END_SRC

+ 前置声明(forward declaration)告诉C++编译器类的存在，而不用提供类定义
  的所有细节
+ 前置声明的类型在头文件中使用指针声明
+ 编译速度快
+ FindDialog(QWidget *parent=0)为典型的Qt窗口部件构造函数定义方式，
  parent参数指定部件的父窗口，默认为空指针，即没有父对象。
+ 对于所有使用信号和槽的类，在类定义开始处的 Q_OBJECT 宏是必须的。
+ signals部分定义信号，signals实际上是一个宏，C++预处理器会在编译程序
  前将其转换为标准C++代码
+ Qt::CaseSensitivity是枚举类型
  - Qt::CaseSensitive
  - Qt::CaseInsensitive
+ slots部分定义槽，也是宏

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/finddialog.cpp
  #include <QtWidgets>
  #include "finddialog.h"

  FindDialog::FindDialog(QWidget *parent)
    : QDialog(parent)
  {
    label = new QLabel("Find &What:");
    lineEdit = new QLineEdit;
    label->setBuddy(lineEdit);

    caseCheckBox = new QCheckBox("Match &case");
    backwardCheckBox = new QCheckBox("Search &backward");

    findButton = new QPushButton("&Find");
    findButton->setDefault(true);
    findButton->setEnabled(false);

    closeButton = new QPushButton("&Close");

    connect(lineEdit, SIGNAL(textChanged(const QString&)),
            this, SLOT(enableFindButton(const QString&)));
    connect(findButton, SIGNAL(clicked()),
            this, SLOT(findClicked()));
    connect(closeButton, SIGNAL(clicked()),
            this, SLOT(close()));

    QHBoxLayout *topLeftLayout = new QHBoxLayout;
    topLeftLayout->addWidget(label);
    topLeftLayout->addWidget(lineEdit);

    QVBoxLayout *leftLayout = new QVBoxLayout;
    leftLayout->addLayout(topLeftLayout);
    leftLayout->addWidget(caseCheckBox);
    leftLayout->addWidget(backwardCheckBox);

    QVBoxLayout *rightLayout = new QVBoxLayout;
    rightLayout->addWidget(findButton);
    rightLayout->addWidget(closeButton);
    rightLayout->addStretch();

    QHBoxLayout *mainLayout = new QHBoxLayout;
    mainLayout->addLayout(leftLayout);
    mainLayout->addLayout(rightLayout);
    setLayout(mainLayout);

    setWindowTitle("Find");
    setFixedHeight(sizeHint().height());
  }


  void FindDialog::findClicked(){
    QString text = lineEdit->text();
    Qt::CaseSensitivity cs =
      caseCheckBox->isChecked() ? Qt::CaseSensitive
      : Qt::CaseInsensitive;
    if(backwardCheckBox->isChecked()){
      emit findPrevious(text, cs);
    }else{
      emit findNext(text, cs);
    }
  }

  void FindDialog::enableFindButton(const QString &text){
    findButton->setEnabled(!text.isEmpty());
  }

#+END_SRC
+ #include <QtWidgets>包含所有窗口部件，但在一个头文件中包含一个在的头文
  件着实不是一个好的编程习惯。
  + Qt4 $include <QtGui>
+ 构造函数中把parent参数传递给基类的构造函数
+ tr()函数表示翻译，有时是不错的选择
+ &操作符表快捷键(Alt+W)
+ 所谓“伙伴”(buddy)，就是一个窗口部件，它可以在按下标签的快捷键时接
  收焦点(focus).
+ setDefault()设定默认按钮(default button), 即当用户按下Enter键时对应
  的按钮。
+ 通过 QHBoxLaytout,QVBoxLayout,QGridLayout的不同嵌套组合，可以构建出
  相当复杂的对话框。
+ addStrentch方法增加分隔符(伸展器)，用来占据空白区域
+ 当将子布局对象添加到父布局对象，子布局对象就会重新定义自己的父对象。
  它所有的子窗口部件都会重新定义自己的父对象。
+ QWidget::sizeHint()方法返回部件“理想”的尺寸大小
+ 创建窗口对象使用的是new，所以需要调用delete来析构。但这样不是必须的，
  Qt在删除对象时会自动删除所有的子对象
+ emit是Qt扩展的关键字，像其它Qt扩展一样，它也会被C++预处理器转换为标
  准的C++代码

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>

  #include "finddialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    FindDialog *dialog = new FindDialog;
    dialog->show();
    return app.exec();
  }

#+END_SRC

+ 为了使 *moc* 能够正常运行，必须把类定义从实现文件中分离出来并放到头
  文件中
+ 必须对使用了Q_OBJECT宏的类运行moc(qmake),否则会出现不明确的错误信息。
+ 默认的Tab键顺序是创建窗口部件的顺序，可以使用QWidget::setTabOrder()
  方法设置
+ 提供一种合理的Tab键顺序的键盘快捷键可以确保不愿（或者不能）使用鼠标
  的用户能够充分享受应用程序提供的全部功能。完全通过键盘控制应用程序也
  深受快速输入人员的赞赏。

**** 信号和槽
1. 槽
   + 可以是虚函数
   + 可以被重载
   + 可以是公有的，私有的，保护的
   + 可以被其它成员函数直接调用
   + 参数可以是任意类型
   + *槽可以与信号连接*
2. connect(sender, SIGNAL(signal), receiver, SLOT(slot))
   + sender, receiver是指向QObject的指针
   + signal和slot是不带参数的函数名
3. 机制
   + 一个信号可以连接多个槽
     + 发射信号时，会以不确定的顺序一个接一个调用关联的槽
   + 多个信号可以关联一个槽
   + 一个信号可以与另外一个信号关联
     #+BEGIN_EXAMPLE
       connect(lineEdit, SIGNAL(textChanged(const QString&))
               this, SIGNAL(updateRecord(const QString&)))
     #+END_EXAMPLE
   + 连接可以被移除
     + 很少用，当删除对象时，Qt会自动移除和这个对象相关的所有关联。
4. 注意
   + 信号和槽的参数必有有相同的顺序和相同的类型
   + 信号的参数比槽多时，多余参数会为被忽略
   + 不匹配则警告
   + 信号和槽机制是由QObject实现，并不只是局限于图形界面编程

**** Qt的对象系统
moc(meta-object system), 对C++的重要扩展。
+ 信号和槽
+ 内省
**** 快速设计对话框
Qt的设计初衷是为了能够直观并且友好也进行 *手工编码* ，并且对于程序员来
说， 编写C++源代码开发整个Qt应用程序并不稀奇。

QtDesigner提供了Qt的可视化编码方式。

手工编码和使用QtDesigner在创建对话框时的基本步骤是一致的
1. 创建并初始化子窗口部件
2. 把子窗口部件放到布局中
3. 设置Tab键顺序
4. 建立信号的槽的连接
5. 实现对话框自定义的槽

***** 使用QtDesigner设计对话框并保存为 ui 文件
+ filename.ui
+ Qt用户界面编译器(user interface compiler, uic) 将ui文件转换为C++代码
  + $ uic filename.ui
  + ui_filename.h
    + 头文件中包含了Ui::GoToCellDialog的定义(GoTocelldialog为
      QtDesigner设计的窗体的顶层部件的objectName)
    + setupUi()函数用于初始化窗体

****** 直接使用
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>
  #include <QDialog>

  #include "ui_gotocelldialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);

    Ui::GoToCellDialog ui;
    QDialog *dialog = new Dialog;
    ui.setupUi(dialog);
    dialog.show();
    return app.exec();
  }

#+END_SRC

+ 什么也做不了

****** 多继承：最简捷
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/gotocelldialog.h
  #ifndef GOTOCELLDIALOG_H
  #define GOTOCELLDIALOG_H

  #include <QDialog>

  #include "ui_gotocelldialog.h"

  class GoToCellDialog : public QDialog, public Ui::GoToCellDialog{
    Q_OBJECT

  public:
    GoToCellDialog(QWidget *parent=0);

  private slots:
    void on_lineEdit_textChanged();
  };

  #endif
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/gotocelldialog.cpp
  #include <QtWidgets>

  #include "gotocelldialog.h"

  GoToCellDialog::GoToCellDialog(QWidget *parent)
    : QDialog(parent)
  {
    setupUi(this);

    QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");
    lineEdit->setValidator(new QRegExpValidator(regExp, this));

    connect(okButton, SIGNAL(clicked()), this, SLOT(accept()));
    connect(cancelButton, SIGNAL(clicked()), this, SLOT(reject()));
  }

  void GoToCellDialog::on_lineEdit_textChanged(){
    okButton->setEnabled(lineEdit->hasAcceptableInput());
  }
#+END_SRC

+ setUp()还会自动将那些符合on_objectName_signalName()命名惯例的任意槽
  与相应的objectName的signalName()信号连接到一起。
+ Qt提供了三种内置检验器类:
  - QIntValidator
  - QDoubleValidator
  - QRegExpValidator
+ 通过this传递绘QRegExpValidator的构造函数，使它成为窗口的子对象，这样
  就可以不用担心有关删除QRegExpValidator的事情了，当删除它的父对象时，
  会被自动删除。
+ Qt的父子对象机制是在QObject中实现的。很大程度上简化了内在管理的工作，
  降低了内在泄漏的风险。需要明确删除的是那些使用new创建并且没有父对象
  的对象。
+ accept()和reject()槽都可以关闭对话框，前者将QDialog::Accepted置1,后
  者置0.

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>

  #include "gotocelldialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    GoToCellDialog *dialog = new GoToCellDialog;
    dialog->show();
    return app.exec();
  }

#+END_SRC

+ 注：org tangle不会覆盖已存在的文件

**** 改变对话框的形状
+ 扩展对话框(extension dialog)
+ 多页对话框(multi-page dialog)

***** 扩展对话框

Qt Designer允许我们在构成同一窗体的不同部分内的窗口部件之间建立连接。
+ Edit -> Edit Signals/Slots 进入设置连接模式。

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/sortdialog.h
  #ifndef SORTDIALOG_H
  #define SORTDIALOG_H

  #include <QDialog>

  #include "ui_sortdialog.h"

  class SortDialog : public QDialog, public Ui::SortDialog{
    Q_OBJECT

  public:
    SortDialog(QWidget *parent=0);
    void setColumnRange(QChar first, QChar last);
  };

  #endif
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/sortdialog.cpp
  #include <QtWidgets>

  #include "sortdialog.h"

  SortDialog::SortDialog(QWidget *parent)
    : QDialog(parent)
  {
    setupUi(this);

    secondaryGroupBox->hide();
    tertiaryGroupBox->hide();
    layout()->setSizeConstraint(QLayout::SetFixedSize);

    setColumnRange('A', 'Z');
  }

  void SortDialog::setColumnRange(QChar first, QChar last){
    primaryColumnCombo->clear();
    secondaryColumnCombo->clear();
    tertiaryColumnCombo->clear();

    secondaryColumnCombo->addItem("None");
    tertiaryColumnCombo->addItem("None");
    primaryColumnCombo->setMinimumSize(
                                       secondaryColumnCombo->sizeHint());

    QChar ch = first;
    while(ch <= last){
      primaryColumnCombo->addItem(QString(ch));
      secondaryColumnCombo->addItem(QString(ch));
      tertiaryColumnCombo->addItem(QString(ch));
      ch = ch.unicode()+1;
    }
  }
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/main.cpp
  #include <QApplication>

  #include "sortdialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    SortDialog *dialog = new SortDialog;
    dialog->setColumnRange('C', 'F');
    dialog->show();
    return app.exec();
  }

#+END_SRC

***** 多页对话框
+ QTabWidget
+ QListWidget
+ QStackedWidget


**** 动态对话框
+ 动态对话框(dynamic dialog)就是在程序运行时使用的从Qt设计师的.ui文件
  创建而来的那些对话框。
+ 运行时加载，而非先使用uic将ui文件转换为C++代码
+ 使用QUiLoader类载入ui文件
  #+BEGIN_EXAMPLE
    QUiLoader uiLoader;
    QFile file("sortdialog.ui");
    QWidget *sortDialog = uiLoader.load(&file);
    if(sortDialog){
        ...
    }
  #+END_EXAMPLE
+ 使用QObject::findChild<T>()来访问窗体中的各个子窗口部件
  #+BEGIN_EXAMPLE
    QComboBox *primaryColumnCombo =
              sortDialog->findChild<QCombobox *>("primaryColumnCombo");
    if(primaryColumncombo){
        ...
    }
  #+END_EXAMPLE
+ 对于MSVC 6, 须使用全局函数qFindChild()函数代替
+ QUiLoader类放在一个独立的类库中，需要在pro文件中加入 CONFIG += uitools

**** 内置的窗口部件和对话框
1. 按钮
   + QPushButton
   + QToolButton
   + QRadioButton
   + QCheckButton
2. 容器
   + QGroupBox
   + QFrame
3. 多页窗口部件
   + QTabWidget
   + QToobBox
4. 项视图窗口部件
   + QListView(列表/图标)
   + QTreeView
   + QTabView
5. 显示窗口部件
   + QLabel(应用最多，显示普通文本，HTML，图片)
   + QLCDNumber
   + QProgressBar
   + QTextBrowser
6. 输入窗口部件
   + QLineEdit
   + QTextEdit
   + QSpinBox
   + QDoubleSpinBox
   + QComboBox
   + QDateEdit
   + QTimerEdit
   + QDateTimeEdit
   + QScrollBar
   + QSlider
   + QDial
7. 对话框
   + QInputDialog
   + QProgressDialog
   + QMessageBox
   + QErrorMessage
   + QColorDialog
   + QFontDialog
   + QPageSetupDialog
   + QFileDialog
   + QPrintDialog
8. 向导
   + QWizard
9. 富文本引擎
   Qt库含有一个富文本引擎(rich text engine)，用于格式化文本的显示和编
   辑。

* Project
** toolbox

#+include: ~/Wally/Project/toolbox/README.md
#+include: ~/Wally/Project/toolbox/ChangeLog.txt

*** DONE Links to pdf
- State "DONE"       from ""           [2015-12-18 五 09:45] \\
  1) wkhtmltopdf 原生支持多个网页，只要在命令行中依次给出 url 即可，用不
     着写这样麻烦劣质的东西
  2) 使用英文注释，不要使用中文注释
  3) 不要在代码中加入无关的东西，注释中不要添加关于语言的用法，这是笔记
     的事情


#+BEGIN_SRC sh
  #! /bin/bash

  ## 功能
  ##    1. 使用wkhtmltopdf将多个网页转换为pdf
  ##    2. 使用gs合并生成的多个PDF
  ##    3. 使用pdfoutline合并的PDF生成目录

  ## 格式： links2pdf index
  ## 输入： index为文件，包含链接和章节信息
  ##       index每行为一个链接
  ##       line: link---chapter---level


  ## version 0.2 --- 添加注释
  ## version 0.3 --- 类似CMake的外部编译，在目录build下进行

  index=$1
  builddir=links2pdf_build
  mkdir $builddir
  cd $builddir
  cp ../$index .

  > outline                       # 利用重定向生成空文件
  declare -i counter=0            # 限制变量counter的属性为整型，counter用于计算章节数
  declare -i page=1               # page用于跟踪页数
  cat $index | while read -r line
  do
      counter=counter+1           # "整型"变量可以直接进行数值计算， 一般变量需要通过$(())

      # ${} 字符串处理
      link=${line%%\ *}           # %去尾，双%匹配最长，即删除尾部与模式匹配的最大子字符串
      level=${line##*\ }          # #支头，双#匹配最长，即删除头部与模式匹配的最大子字符串
      # range=$((len3-len1-len2-2))       # range???  len<N>??? 明显多余
      link_chapter=${line%\ *}    # %去尾，单%匹配最短，即删除尾部与模式匹配的最小子字符串

      # #去头，单#匹配最短，即删除头部与模式匹配的最小子字符串
      # 前提是link中无空格，章节中可能存在空格
      chapter=${link_chapter#*\ }

      # 9是幻数，含义是小于10的章节索引有前缀0，即01,02... 便于gs排序
      if test ${counter} -gt 9    # test 或 [ condition ]
         then
                 wkhtmltopdf --no-outline $link $counter.pdf; # HTML to PDF
                 Pages=$(pdfinfo $counter.pdf | grep Pages);  # $() 或 反引号`` 执行shell命令并c返回
                 num=${Pages##*\ };
      else
          wkhtmltopdf --no-outline $link 0${counter}.pdf;
          Pages=$(pdfinfo 0${counter}.pdf | grep Pages);
          num=${Pages##*\ };
      fi
      echo "$level $page $chapter" >> outline
      page=$((page+num))          # $(()) 数值运算，变量page已经声明为“整型”，也可以不包裹
  done


  # gs
  gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=out.pdf  *.pdf

  # pdfoutline
  pdfoutline out.pdf outline output.pdf

  # 删除文件
  mv output.pdf ..
  cd ..
  rm -rf $builddir

#+END_SRC

*** Track 规范化 standardize file name                     :filename:stdfn:
- State "Track"      from ""           [2015-12-18 五 10:48] \\
  1. 小结
     + 文件命名要有规范，最好不要仅使用下划线连接几个单词，好丑
     + 不要使用中文注释

  2. TODOs
     + 多个路径参数
     + 参数检查
     + 递归遍历
     + 使用正则替换所有除下划线、数字和字母外的所有特殊字符为下划线

#+INCLUDE: ~/Wally/Project/toolbox/src/stdfn.sh

*** convert pptx to pdf in batch                             :ppt:pptx:pdf:

#+INCLUDE: ~/Wally/Project/toolbox/src/pptx2pdf.sh

*** merge PDFs with outline

#+INCLUDE: ~/Wally/Project/toolbox/src/mergepdfs.sh

*** NEXT remove backfile ended with ~ recursively
- State "NEXT"       from ""           [2015-12-20 日 23:03] \\
  not working well. ls may be the problem

#+INCLUDE: ~/Wally/Project/toolbox/src/debackup.sh

*** NEXT project
- State "NEXT"       from "TODO"       [2015-12-21 一 19:17] \\
  写了简单的 project 脚本，仅生成 .projectile, README.md, ChangeLog.txt
  文件和 test 目录
- State "TODO"       from ""           [2015-12-18 五 11:44] \\
  更简洁些，不要多余的功能

#+INCLUDE: ~/Wally/Project/toolbox/src/project.sh

**** project
#+BEGIN_SRC sh
   #! /bin/sh

  # tagerill_update_project.sh

  # version 1.0
  # This is a bash script to initialize a new project of common sense
  # It mainly finishes the following tasks
  # 1. create a new root directory that named by the first arguments
  # 2. create a README file containing information like timestamps,
  #    author, email, license and so on
  # 3. create a .projectile file for the convinence of Projectile to manage it
  #
  # version 1.1
  # add the function of update a project
  #
  # Usage
  # tagerill_new_project.sh <PROJECT> [COMMENT_STR]
  #
  # TODO
  # [ ] select a rule of naming versions & update the version information


  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "error: wrong number of arguments"
      echo "usage: tagerill_new_project.sh <PROJECT> [COMMENT_STR]"
      exit -1
  fi


  project=$1
  comments=""
  if [ $# -eq 3 ]
  then
      comments=$2
  fi

  # update the project
  if [ -d $project ]
  then
     cd $project
     echo >> README
     echo -n "MODIFICATION:" >> README
     date +%Y/%m/%d-%H:%M >> README
     # TODO： 变更版本信息
     if [ $# -eq 3 ]
     then
         echo "COMMENT: $comments" >> README
     fi
     echo "Project: $project updated."
     exit 0
  fi


  # create a new project
  # root workspace
  mkdir $project

  # README
  cd $project
  touch README
  echo "PROJECT: $project" >> README
  echo "VERSION: v1.0"
  echo -n "TIME: " >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "License: GPL v3.0" >> README

  # .projectile
  touch .projectile

  #
  echo "Project: $project has been created"

  exit 0

#+END_SRC

**** cpp

#+BEGIN_SRC sh
  #! /bin/sh

  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "Usage: cpp_pro.sh PROJECT"
      exit 1
  fi

  project=$1
  mkdir $project
  cd $project
  touch README COPYRIGHT TODO Makefile
  mkdir bin src include lib

  # README
  echo PROJECT: $project >> README
  echo -n TIME: >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "LICENSE: GPL v3.0" >> README

  # TODO
  echo [ ] >> TODO
  echo [ ] >> TODO
  echo [ ] >> TODO
#+END_SRC

**** cmake

#+BEGIN_SRC sh
  #! /bin/bash

  # 参数检查
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "usage: cmake_pro.sh PROJECT"
      exit
  fi

  project=$1
  mkdir $project
  cd $project
  # 目录结构
  mkdir src scripts build lib bin doc

  # 根目录下文件
  touch CMakeLists.txt
  echo "CMAKE_MINIMUM_REQUIRED(VERSION 3.2)" >> CMakeLists.txt
  echo "PROJECT($project)" >> CMakeLists.txt
  echo "ADD_SUBDIRECTORY(src bin)" >> CMakeLists.txt
  echo "ADD_SUBDIRECTORY(scripts)" >> CMakeLists.txt

  touch README COPYRIGHT TODO
  echo "PROJECT: $project" >> README
  echo -n "TIME: " >> README
  date +%Y/%M/%d-%H:%m >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README

  # TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO

  # src
  cd src
  touch CMakeLists.txt

  # scripts
  cd ../scripts
  touch CMakeLists.txt
  echo "# INSTALL(PROGRAMS project DESTINATION bin)" >> CMakeLists.txt
#+END_SRC

**** arduino

#+BEGIN_SRC sh
  #! /bin/bash

  # 参数个数检查
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of argument"
      echo "usage: ardpro PROJECT"
      exit
  fi

  project=$1
  mkdir $project                  # 创建目录
  cd $project
  touch README COPYRIGHT TODO Makefile $project.ino

  # README
  echo PROJECT: $project >> README
  echo -n TIME: >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "LICENSE: GPL v3.0" >> README

  # TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO

  # Makefile
  echo "BOARD_TAG = uno" >> Makefile
  echo "ARDUINO_LIBS = " >> Makefile
  echo "MONITOR_PORT = /dev/ttyACM0" >> Makefile
  echo "include /usr/share/arduino/Arduino.mk" >> Makefile
#+END_SRC

**** bash

#+BEGIN_SRC sh
  #! /bin/bash

  # Function: Create a new bash project
  # Usage: bash_pro.sh
  # Input: Project name
  # Output: Name


  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "Usage: bash_pro.sh PROJECT"
      exit
  fi

  project=$1
  mkdir $project
  cd $project
  touch README LICENSE TODO Makefile      # Files
  mkdir scripts bin               # Contents

  # REAMDE
  echo "Project: $project" >> README
  echo -n "Time: " >> README
  date +%Y/%m/%d-%H:%m >> README
  echo "Author: Wally" >> README
  echo "Email: buaaben@163.com" >> README
#+END_SRC

**** CMakelists.txt

#+BEGIN_SRC cmake
  CMAKE_MINIMUM_REQUIRED(VERSION 3.2)
  PROJECT(bash_pro)
  ADD_SUBDIRECTORY(src bin)
  ADD_SUBDIRECTORY(scripts)

  INSTALL(PROGRAMS bash_pro.sh DESTINATION bin)
#+END_SRC
*** TODO routine


#+INCLUDE: ~/Wally/Project/toolbox/src/routine.sh

TODOs
+ [ ] [[file:~/Wally/Project/toolbox/src/routine.sh::path=$1%20#%20path%20need%20to%20be%20absolute][check path]]




#+BEGIN_SRC sh
  #! /bin/sh

  # 执行git, pdf, clean等日常工作
  # 根据时间和地点完成不同的任务

  home=tiger                      # 用户名
  office=ben
  host=`echo $HOSTNAME`
  ws=$HOME/Wally/Journal  # workspace
  emacs_settings_ws="/home/${host}/.emacs.d"


  time=`date +%H`

  cmd=$1

  # if [ $time -gt $line ]                # in the evening
  # then
  #     if [ $host == $office ]   # at office
  #     then
  #       # clean
  #       touch tmpfile
  #       rm `ls . | grep -E "*~$|*.out$|*.log$|*.toc$|*.aux$|^tmpfile$"`
  #       # git push
  #       git add --ignore-removal .
  #       git commit -m "committed automatically by script at $office `date +%H%M`"
  #       git push origin master

  #       # pdf
  #       journal=journal.pdf
  #       if [ -e $journal ]
  #       then
  #           mv journal.pdf "PDFs/`date +%Y%m%d`.pdf"
  #       fi
  #     elif [ $host == $home ]                   # at home
  #     then
  #       # git pull
  #       git pull
  #       git merge origin/master
  #     fi
  # else                          # in the morning
  #     if [ $host == $office ]
  #     then
  #       # git pull
  #       git pull
  #       git merge origin/home
  #     elif [ $host == $home ]
  #     then
  #       # git push
  #       git add --ignore-removal .
  #       git commit -m "committed automatically by script at $home at `date +%H:%M`"
  #       git push origin home
  #     fi
  # fi


  if [ $cmd = "push" ]
  then
      cd $ws
      git add --ignore-removal .
      git commit -m "committed automatically by script at $home at `date +%H:%M`"
      git push origin master

      if [ $host = $office ]
      then
          cd $emacs_settings_ws
          git add settings.org
          git add elpa/yasnippet-20150323.311/snippets/
          git commit -m "committed automatically by script at $home at `date +%H:%M`"
          git push origin master

          thesis_ws="~/Wally/GraduationProject/Thesis"
          cd $thesis_ws
          git add .
          git commit -m "committed automatically by script at $home at `date +%H:%M`"
      fi
  elif [ $cmd = "pull" ]
  then
      cd $ws
      git pull
  fi


  # 命令行参数为密码
  # if [ $# -eq 1 ]
  # then
  #     passwd=$1
  #     python email_evernote.py $passwd
  # fi

  # dict

#+END_SRC

*** TODO email

#+BEGIN_SRC python
  #! /usr/bin/env python
  # -*- encoding:utf-8 -*-

  import smtplib

  from email import encoders
  from email.header import Header
  from email.mime.text import MIMEText
  from email.mime.multipart import MIMEMultipart
  from email.mime.base import MIMEBase
  from email.utils import parseaddr, formataddr

  import sys, datetime, os

  if len(sys.argv) < 2:
      print "done nothing. If a email needs to be delieved, please confirm and provide the passwd"
      exit(0)

  def _format_addr(s):
      name, addr = parseaddr(s)
      return formataddr((Header(name, 'utf-8').encode(), addr))

  pdf_file = "%s.pdf" % datetime.datetime.now().strftime("%Y%m%d")
  path = "/home/ben/Wally/Journal/PDFs/"
  filename = path + pdf_file

  from_addr = "buaaben@163.com"
  passwd = sys.argv[1]            # 从命令行获取密码
  to_addr = "buaaben.fa289a0@m.yinxiang.com"

  # 构造邮件对象
  msg = MIMEMultipart()
  # 发送地址
  msg['From'] = _format_addr("Ben<%s>" % from_addr)
  # 接收地址
  msg['To'] = _format_addr('Evernote<%s>' % to_addr)
  # 主题
  msg['Subject'] = Header("%s @Tagerill #journal" %
                          datetime.datetime.now().strftime("%Y%m%d"),
                          'utf-8').encode()

  # 时间戳
  now = datetime.datetime.now().strftime('%Y/%m/%d-%H:%M')
  msg.attach(MIMEText('Generated automatically by python script at %s' % now,
                      'plain', 'utf-8'))
  # 正文
  with open("/home/ben/dic.txt", 'r+') as f:
      voc = f.read()
      msg.attach(MIMEText('Vacabularies for today are as following: %s' % voc,
                          'plain', 'utf-8'))
      null = ''
      f.write(null)

  # 附件
  if os.path.exists(filename):
      with open(filename, 'rb') as f:
          mime = MIMEBase('PDF', 'pdf', filename='journal.pdf')
          mime.add_header('Content-Disposition', 'attachment',
                          filename='journal.pdf')
          mime.add_header('Content-ID', '<0>')
          mime.add_header('X-Attachment-Id', '0')

          # 把附件的内容读进来:
          mime.set_payload(f.read())
          # 用Base64编码:
          encoders.encode_base64(mime)
          # 添加到MIMEMultipart:
          msg.attach(mime)

  # 发送邮件
  # stmp_server = None              ####### TODO
  stmp_server = "smtp.163.com"
  port = 25
  server = smtplib.SMTP(stmp_server, 25)
  server.set_debuglevel(1)
  server.login(from_addr, passwd)
  server.sendmail(from_addr, [to_addr], msg.as_string())

#+END_SRC
