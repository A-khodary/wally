* Fundamental                                                         :linux:
** Linux基础
*** Linux特点
+ Linux是一款开放源代码的自由软件
+ 完全兼容POSIX标准
+ 多用户多任务系统
+ 良好的界面，包括文本界面（命令行界面CLI）和图形用户界面（GUI）
+ 支持多种文件系统，包括EXT， EXT2, EXT3, NFS, NTFS等
+ 丰富的网络功能：完善的内置网络是Linux的一大特点，Linux在通信和网络功能方面
  与内核结合紧密，优于其他操作系统
+ 可靠的系统安全。
+ 良好的可移植性

*** Linux版本号
Linux的版本号分为两部分：内核（Kernel）和发行套件（Distribute）版本，
内核版本号一般为x.y.zz-wwww,
+ x.y为Linux的主版本号
+ zz为次版本号
+ www表示发行号。

#+header: :exports both
#+BEGIN_SRC sh
uname -a    # 列出Linux系统版本号
#+END_SRC

#+RESULTS:
: Linux ben 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:18 UTC 2015 i686 i686 i686 GNU/Linux



#+BEGIN_EXAMPLE

#+END_EXAMPLE

*** Linux结构
一个完整的Linux操作系统由Linux内核，shell，文件系统和实用工具组成。
1. 内核是Linux操作系统的心脏。
2. shell是系统的用户界面，提供了用户与内核进行交互操作的借口。
   主流的shell包括
   + Bourne Shell
   + BASH
   + Korn Shell
   + C Shell.
3. 文件结构是文件存放在磁盘等存储设备上的组织方法。
4. 实用工具。

*** linux操作系统分类
1. 根据包管理系统，可分为：
   + RPM包管理: Red Hat
   + Deb包管理，Debian和Ubuntu
2. 根据X Windwo系统，可分为：
   + KDE
   + GNOME

*** Linux 环境变量                                         :newenvironment:

environment variables are a variable key pair stored in the shell's
environment space. here is a list of common environment variables:


|-----------------+--------------------------------------------------------------|
| variable        | description                                                  |
|-----------------+--------------------------------------------------------------|
| histfile        | the name of the file in which command history is saved       |
| histfilesize    | the maximum number of lines contained in the history file    |
| hostname        | the system's host name                                       |
| ld_library_path | it is a colon-separated set of directories                   |
|                 | where libraries should be searched for                       |
| ps1             | your default (first) shell prompt                            |
| user            | current logged in user's name.                               |
| path            | colon separated list of directories to search for binaries.  |
| display         | network name of the x11 display to connect to, if available. |
| shell           | the current shell.                                           |
| term            | the name of the user's terminal.                             |
|                 | used to determine the capabilities of the terminal.          |
| termcap         | database entry of the terminal escape codes                  |
|                 | to perform various terminal functions.                       |
| ostype          | type of operating system.                                    |
| machtype        | the cpu architecture that the system is running on.          |
| editor          | the user's preferred text editor.                            |
| pager           | the user's preferred text pager.                             |
| manpath         | colon separated list of directories                          |
|                 | to search for manual pages.                                  |
|-----------------+--------------------------------------------------------------|

** 文件管理
*** /tmp
http://www.cnblogs.com/hnrainll/archive/2011/06/08/2074976.html


我们知道，在Linux系统中/tmp文件夹里面的文件会被清空，至于多长时间被清
空，如何清空的，可能大家知识的就不多了，所以，今天我们就来剖析一个这两
个问题。
**** Fedora
先来看看tmpwatch这个命令，他的作用就是删除一段时间内不使用的文件
（removes files which haven’t been accessed for a period of time）。
具体的用法就不多说了，有兴趣的自行研究。我们主要看看和这个命令相关的计
划任务文件。

他就是/etc/cron.daily/tmpwatch，我们可以看一下这个文件里面的内容
#+BEGIN_SRC sh :exports code
  #! /bin/sh
  flags=-umc
  /usr/sbin/tmpwatch "$flags" -x /tmp/.X11-unix -x /tmp/.XIM-unix \
          -x /tmp/.font-unix -x /tmp/.ICE-unix -x /tmp/.Test-unix \
          -X '/tmp/hsperfdata_*' 10d /tmp
  /usr/sbin/tmpwatch "$flags" 30d /var/tmp
  for d in /var/{cache/man,catman}/{cat?,X11R6/cat?,local/cat?}; do
      if [ -d "$d" ]; then
          /usr/sbin/tmpwatch "$flags" -f 30d "$d"
      fi
  done
#+END_SRC

这个脚本大家仔细分析一下就明白了，第一行相当于一个标记（参数），第二行
就是针对/tmp目录里面排除的目录，第三行，这是对这个/tmp目录的清理，下面
的是针对其他目录的清理，就不说了。

我们就来看/usr/sbin/tmpwatch "$flags" 30d /var/tmp这一行，关键的是这个
30d，就是30天的意思，这个就决定了30天清理/tmp下不访问的文件。如果说，
你想一天一清理的话，就把这个30d改成1d。这个你懂的……哈哈！

但有个问题需要注意，如果你设置更短的时间来清理的话，比如说是30分钟、10
秒等等，你可以在这个文件中设置，但你会发现重新电脑，他不清理/tmp文件夹
里面的内容，这是为什么呢？这就是tmpwatch他所在的位置决定的，他的上层目
录是/etc/cron.daily/，而这个目录是第天执行一次计划任务，所以说，你设置
了比一天更短的时间，他就不起作用了。这下明白了吧。

所以结论是：在RHEL6中，系统自动清理/tmp文件夹的默认时限是30天

**** 在Debian/Ubuntu系统中
在Ubuntu系统中，在/tmp文件夹里面的内容，每次开机都会被清空，如果不想让
他自动清理的话，只需要更改rcS文件中的TMPTIME的值。

我们看如何来修改: sudo vi /etc/default/rcS

把 TMPTIME=0 修改成 TMPTIME=-1或者是无限大, 改成这样的话，系统在重新启
动的时候就不会清理你的/tmp目录了。

依些类推，如果说要限制多少时间来更改的话，就可以改成相应的数字（本人没
有测试，我是这么理解的）

所以结论是：在Ubuntu中，系统自动清理/tmp文件夹的时限默认每次启动

*** /etc/passwd文件

在Linux /etc/passwd文件中每个用户都有一个对应的记录行，它记录了这个用
户的一些基本属性。系统管理员经常会接触到这个文件的修改以完成对用户的管
理工作。这个文件对所有用户都是可读的。

它的内容类似下面的例子：
#+BEGIN_EXAMPLE
  ＃cat/etc/passwd

  root:x:0:0:Superuser:/:
  daemon:x:1:1:Systemdaemons:/etc:
  bin:x:2:2:Ownerofsystemcommands:/bin:
  sys:x:3:3:Ownerofsystemfiles:/usr/sys:
  adm:x:4:4:Systemaccounting:/usr/adm:
  uucp:x:5:5:UUCPadministrator:/usr/lib/uucp:
  auth:x:7:21:Authenticationadministrator:/tcb/files/auth:
  cron:x:9:16:Crondaemon:/usr/spool/cron:
  listen:x:37:4:Networkdaemon:/usr/net/nls:
  lp:x:71:18:Printeradministrator:/usr/spool/lp:
  sam:x:200:50:Samsan:/usr/sam:/bin/sh
#+END_EXAMPLE
/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，
其格式和具体含义如下：

*用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell*


1. “用户名”是代表用户账号的字符串。通常长度不超过8个字符，并且由大小
   写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。
   为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和
   加号(+)打头。

2. “口令”一些系统中，存放着加密后的用户口令字。虽然这个字段存放的只
   是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可
   读，所以这仍是一个安全隐患。因此，现在许多Linux系统（如SVR4）都使用
   了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而
   在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者
   “*”。

3. “用户标识号”是一个整数，系统内部用它来标识用户。一般情况下它与用
   户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部
   将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及
   不同的登录Shell等。

   通常用户标识号的取值范围是0～65535。0是超级用户root的标识号，1～99
   由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，
   这个界限是500。

4. “组标识号”字段记录的是用户所属的用户组。它对应着/etc/group文件中
   的一条记录。

5. “注释性描述”字段记录着用户的一些个人情况，例如用户的真实姓名、电
   话、地址等，这个字段并没有什么实际的用途。在不同的Linux系统中，这个
   字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的
   注释性描述文字，用做finger命令的输出。

6. “主目录”，也就是用户的起始工作目录，它是用户在登录到系统之后所处
   的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，
   而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、
   执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。

7. 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用
   户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用
   户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。
   常用的有
   + sh(BourneShell)
   + csh(CShell)
   + ksh(KornShell)
   + tcsh(TENEX/TOPS-20typeCShell)
   + bash(BourneAgainShell)

   系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指
   定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。
   用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释
   器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应
   用程序运行结束后，用户就自动退出了系统。有些Linux系统要求只有那些在
   系统中登记了的程序才能出现在这个字段中。

*** 文件服务器
NFS简单，Samba灵活

**** NFS                                                             :nfs:
http://www.cnblogs.com/Charles-Zhang-Blog/archive/2013/02/05/2892879.html

***** intro

*NFS* (/Network FileSystem/ ，网络文件系统)是由SUN公司发展，并于1984年推出
的技术， _用于在不同机器，不同操作系统之间通过网络互相分享各自的文件_
NFS设计之初就是为了在不同的系统间使用，所以它的通讯协议设计与主机及操
作系统无关。

NFS分 /服务器/ 和 /客户机/ ，当使用远端文件时只要用 /mount/ 命令就可把远端NFS服务
器上的文件系统挂载在本地文件系统之下，操作远程文件与操作本地文件没有不
同。NFS服务器所共享文件或目录记录在 */etc/exports* 文件中。

_嵌入式Linux开发中，会经常使用NFS_ ，目标系统通常作为NFS客户机使用，Linux
主机作为NFS服务器。在目标系统上通过NFS，将服务器的NFS共享目录挂载到本
地，可以直接运行服务器上的文件。在调试系统驱动模块以及应用程序，NFS都
是十分必要的，并且Linux还支持 _NFS根文件系统，能直接从远程NFS root启动
系统_ ，这对嵌入式Linux根文件系统裁剪和集成也是十分有必要的。

***** 服务器端

1. 安装nfs: sudo apt-get instal nfs-kernel-server

2. 配置： /etc/exports

   #+BEGIN_EXAMPLE
   目录 IP(选项...)
   #+END_EXAMPLE

3. 启动： sudo service nts-kernel-servel start/stop/restart

****** 选项

+ ro   只读访问
+ rw   读写访问
+ sync   所有数据在请求时写入共享
+ async   nfs在写入数据前可以响应请求
+ secure   nfs通过1024以下的安全TCP/IP端口发送
+ insecure   nfs通过1024以上的端口发送
+ wdelay   如果多个用户要写入nfs目录，则归组写入（默认）
+ no_wdelay   如果多个用户要写入nfs目录，则立即写入，当使用async时，无需此设置
+ hide   在nfs共享目录中不共享其子目录
+ no_hide   共享nfs目录的子目录
+ subtree_check   如果共享/usr/bin之类的子目录时，强制nfs检查父目录的权限（默认）
+ no_subtree_check   不检查父目录权限
+ all_squash   共享文件的UID和GID映射匿名用户anonymous，适合公用目录
+ no_all_squash   保留共享文件的UID和GID（默认）
+ root_squash   root用户的所有请求映射成如anonymous用户一样的权限（默认）
+ no_root_squash   root用户具有根目录的完全管理访问权限
+ anonuid=xxx   指定nfs服务器/etc/passwd文件中匿名用户的UID
+ anongid=xxx   指定nfs服务器/etc/passwd文件中匿名用户的GID

***** 客户端

挂载： sudo mount -t nfs 192.168.1.12:/shared/path /mnt

**** Samba                                                         :samba:
*** FTP:tftpd-hpa
http://wiki.ubuntu.org.cn/Tftpd-hpa

tftpd-hpa 是一个功能增强的TFTP服务器。它提供了很多TFTP的增强功能，它已
经被移植到大多数的现代UNIX系统。

1. 安装
   使用下面的命令来安置 tftpd-hpa 服务器：
   #+BEGIN_EXAMPLE
      $ sudo apt-get install tftpd-hpa
   #+END_EXAMPLE
   注：若server未安装xinetd则在ubuntu9.04中会自动下载openbsd-inetd并安
   装，使用tftp过程中出错很多时候是因xinetd版本问题；
2. 配置
   tftp-hpa 的配置文件为 /etc/default/tftpd-hpa
   #+BEGIN_EXAMPLE
      RUN_DAEMON="yes"
      OPTIONS="-l -c -s /tftpboot"
   #+END_EXAMPLE

   -c为可创建新文件，若无此参数，put命令则可能出现错误提示，此时只能覆
   盖原有文件不能创建新文件；

   无论何种方式配置tftp-server -c参数决定是否能正常写入数据； 这里指定
   tftpd 使用的目录为 /tftpboot，注意要修改目录属性：chmod 777
   tftpboot
3. 启动和停止
   1) 启动
      #+BEGIN_EXAMPLE
         # /etc/init.d/tftpd-hpa start
      #+END_EXAMPLE

   2) 停止
      #+BEGIN_EXAMPLE
         # /etc/init.d/tftpd-hpa stop
      #+END_EXAMPLE

*** MD5
+ http://zh.wikipedia.org/wiki/MD5

MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用
的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），
用于确保信息传输完整一致。MD5由罗纳德·李维斯特设计，于1992年公开，用以
取代MD4算法。

MD5已经广泛使用在为文件传输提供一定的可靠性方面。例如，服务器预先提供
一个MD5校验和，用户下载完文件以后，用MD5算法计算下载文件的MD5校验和，
然后通过检查这两个校验和是否一致，就能判断下载的文件是否出错。

*** mv 无法进行跨设备移动                                              :mv:
#+begin_latex
\begin{minted}{bash}
mv /media/ben/system/test/ ~/audio/
\end{minted}
#+end_latex

mv目录名不能加结尾的斜杠
*mv的source永远不会以/结尾，要么是文件名，要么是目录名。*

*** Linux文件命名名规则
1. 隐藏文件
   以 “.” 字符开头的文件名是隐藏文件。这仅表示，ls 命令不能列出它们，
   用 ls -a 命令就可以了。

2. 大小写敏感
   文件名和命令名是大小写敏感的。文件名“File1”和“ﬁle1”是指两个不同
   的文件名。

3. 文件扩展名
   Linux 没有“文件扩展名”的概念，不像其它一些系统。可以用你喜欢的任
   何名字来给文件起名。文件内容或用途由其它方法来决定。虽然类 Unix 的
   操作系统，不用文件扩展名来决定文件的内容或用途，但是有些应用程序会。

4. 文件命名
   虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅
   限使用“.”，“-”，下划线。 *最重要的是，不要在文件名中使用空格。*
   如果你想表示词与词间的空格，用下划线字符来代替。过些时候，你会感激
   自己这样做。

**** 小结
1. 隐藏文件
2. 大小写敏感
3. 扩展名不必要
4. 不要有空格
*** Linux 文件系统
*在Linux中，没有秘密存在。*

1. /

   根目录，万物起源

2. /bin

   包含 Linux 内核，最初的 RMA 磁盘映像（系统启动时，由驱动程序所需），
   和启动加载程序。

   有趣的文件：
   + /boot/grub/grub.conf or menu.lst，被用来配置启动加载程序。
   + /boot/vmlinuz，Linux 内核。

3. /dev

   这是一个包含设备结点的特殊目录。“一切都是文件”，也使用于设备。在
   这个目录里，内核维护着它支持的设备。

4. /etc

   这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本，在
   系统启动时，这些脚本会运行每个系统服务。这个目录中的任何文件应该是
   可读的文本文件。有意思的文件：虽然/etc 目录中的任何文件都有趣，但这
   里只列出了一些我一直喜欢的文件：
   + /etc/crontab，定义自动运行的任务。
   + /etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。
   + /etc/passwd，包含用户帐号列表。

5. /home

   在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通
   只能在他们自己的目录下创建文件。这个限制保护系统免受错误的用户活动
   破坏。

6. /lib

   包含核心系统程序所需的库文件。这些文件与 Windows 中的动态链接库相似。

7. /lost+found

   每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统，都会
   有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。除非文
   件系统真正的损坏了，那么这个目录会是个空目录。

8. /media

   在现在的 Linux 系统中，/media 目录会包含可移除媒体设备的挂载点，例
   如 USB 驱动器，CD-ROMs 等等。这些设备连接到计算机之后，会自动地挂载
   到这个目录结点下。

9. /mnt

   在早些的 Linux 系统中，/mnt 目录包含可移除设备的挂载点。

10. /opt

    这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能安装在
    系统中的商业软件产品。

11. /proc

    这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的
    文件系统。反而，它是一个由 Linux 内核维护的虚拟文件系统。它所包含
    的文件是内核的窥视孔。这些文件是可读的，它们会告诉你内核是怎样监管
    计算机的。

12. /root

    root 帐户的家目录。

13. /sbin

    这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常
    为超级用户保留。

14. /tmp

    用来存储由各种程序创建的临时文件的地方。一些配置，导致系统每次重新
    启动时，都会清空这个目录。

15. /usr

    在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的
    所有程序和文件。

16. /usr/bin

    /usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程
    序。

17. /usr/lib

    包含由/usr/bin 目录中的程序所用的共享库。

18. /usr/local

    这个/usr/local 目录，是非系统发行版自带，却打算让系统使用的程序的
    安装目录。通常，由源码编译的程序会安装在/usr/local/bin 目录下。新
    安装的 Linux 系统中，会存在这个目录，但却是空目录，直到系统管理员
    放些东西到它里面。

19. /usr/sbin

    包含许多系统管理程序。

20. /usr/share

    /usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。其中
    包括像默认的配置文件，图标，桌面背景，音频文件等等。

21. /usr/share/doc

    大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下，
    我们可以找到按照软件包分类的文档。

22. /var

    除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，
    这是说，它们的内容不会改变。/var 目录是可能需要改动的文件存储的地
    方。各种数据库，假脱机文件，用户邮件等等，都驻扎在这里。

23. /var/log

    这个/var/log 目录包含日志文件，各种系统活动的记录。这些文件非常重
    要，并且应该时时监测它们。其中最重要的一个文件是/var/log/messages。
    注意，为了系统安全，在一些系统中，你必须是超级用户才能查看这些日志
    文件。
*** DONE ls -l 第一个字母 c/d/l的含义                                  :ls:
- State "DONE"       from "TODO"       [2015-11-27 五 17:24]
 <2015-11-26 四>
 [[file:~/Wally/Journal/catkin_ws/src/julie/julie_launch/launch/microstrain.launch::<arg%20name%3D"config"%20value%3D"$(find%20julie_launch)/rviz/imu_only.launch"%20/>][file:~/Wally/Journal/catkin_ws/src/julie/julie_launch/launch/microstrain.launch::<arg
 name="config" value="$(find julie_launch)/rviz/imu_only.launch" />]]

+ 文件类型说明
  +  - 常规文件
  +  d 目录文件
  +  b 块特殊设备
  +  c 字符特殊设备

** 系统管理
*** 用户管理
http://www.chinaunix.net/old_jh/4/438660.html

Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用
户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。
用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们
对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保
护。每个用户账号都拥有一个惟一的用户名和各自的口令。用户在登录时键入正
确的用户名和口令后，就能够进入系统和自己的主目录。

实现用户账号的管理，要完成的工作主要有如下几个方面：
+ 用户账号的添加、删除与修改。
+ 用户口令的管理。
+ 用户组的管理。

**** Linux 用户管理
用户账号的管理工作主要涉及到用户账号的添加、修改和删除。

添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、
主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。
***** 添加用户

添加新的用户账号使用useradd命令，其语法如下：
#+BEGIN_EXAMPLE
useradd 选项 用户名
#+END_EXAMPLE

其中各选项含义如下：

+ -c comment 指定一段注释性描述。

+ -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建
  主目录。

+ -g 用户组 指定用户所属的用户组。

+ -G 用户组，用户组 指定用户所属的附加组。

+ -s Shell文件 指定用户的登录Shell。

+ -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户
  的标识号。

+ 用户名 指定新账号的登录名。


例
#+BEGIN_EXAMPLE
# useradd –d /usr/sam -m sam
#+END_EXAMPLE

此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录
/usr/sam（/usr为默认的用户主目录所在的父目录）。

#+BEGIN_EXAMPLE
# useradd -s /bin/sh -g group –G adm,root gem
#+END_EXAMPLE

此命令新建了一个用户gem，该用户的登录Shell是/bin/sh，它属于group用户组，
同时又属于adm和root用户组，其中group用户组是其主组。
这里可能新建组：#groupadd group及groupadd adm　
　
增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他
系统文件如/etc/shadow, /etc/group等。

Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。

***** 删除用户
如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将
/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。删
除一个已有的用户账号使用userdel命令，其格式如下：

#+BEGIN_EXAMPLE
userdel 选项 用户名
#+END_EXAMPLE

常用的选项是-r，它的作用是把用户的主目录一起删除。

#+BEGIN_EXAMPLE
# userdel sam
#+END_EXAMPLE

此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow,
/etc/group等）的记录，同时删除用户的主目录。

***** 修改账号

修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户
组、登录Shell等。

修改已有用户的信息使用usermod命令，其格式如下：

#+BEGIN_EXAMPLE
usermod 选项 用户名
#+END_EXAMPLE

常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与
useradd命令中的选项一样，可以为用户指定新的资源值。另外，有些系统可以
使用如下选项： -l 新用户名

这个选项指定一个新的账号，即将原来的用户名改为新的用户名。
例如：
#+BEGIN_EXAMPLE
# usermod -s /bin/ksh -d /home/z –g developer sam
#+END_EXAMPLE

此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为
developer。

***** 用户口令管理
用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是
被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。

指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指
定口令，普通用户只能用它修改自己的口令。命令的格式为：

#+BEGIN_EXAMPLE
passwd 选项 用户名
#+END_EXAMPLE

可使用的选项：

+ -l 锁定口令，即禁用账号。

+ -u 口令解锁。

+ -d 使账号无口令。

+ -f 强迫用户下次登录时修改口令。

如果默认用户名，则修改当前用户的口令。

例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：
#+BEGIN_EXAMPLE
$ passwd

Old password:******
New password:*******
Re-enter new password:*******
#+END_EXAMPLE

如果是超级用户，可以用下列形式指定任何用户的口令：
#+BEGIN_EXAMPLE
# passwd sam

New password:*******
Re-enter new password:*******
#+END_EXAMPLE

普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输
入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用
户为用户指定口令时，就不需要知道原口令。

为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，
口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。

为用户指定空口令时，执行下列形式的命令：

#+BEGIN_EXAMPLE
# passwd -d sam
#+END_EXAMPLE

此命令将用户sam的口令删除，这样用户sam下一次登录时，系统就不再询问口令。

passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如：

#+BEGIN_EXAMPLE
# passwd -l sam
#+END_EXAMPLE

**** Linux 用户组管理

***** 增加用户组
增加一个新的用户组使用groupadd命令。其格式如下：
#+BEGIN_EXAMPLE
groupadd 选项 用户组
#+END_EXAMPLE

可以使用的选项有：
+ -g GID 指定新用户组的组标识号（GID）。

+ -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID
  相同。

#+BEGIN_EXAMPLE
# groupadd group1
#+END_EXAMPLE
此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组
标识号的基础上加1。

#+BEGIN_EXAMPLE
#groupadd -g 101 group2
#+END_EXAMPLE

此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。

***** 删除用户组
如果要删除一个已有的用户组，使用groupdel命令，其格式如下：
#+BEGIN_EXAMPLE
groupdel 用户组
#+END_EXAMPLE

#+BEGIN_EXAMPLE
#groupdel group1
#+END_EXAMPLE
此命令从系统中删除组group1。

***** 修改用户组属性
修改用户组的属性使用groupmod命令。其语法如下：
#+BEGIN_EXAMPLE
groupmod 选项 用户组
#+END_EXAMPLE

常用的选项有：
+ -g GID 为用户组指定新的组标识号。

+ -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。

+ -n新用户组 将用户组的名字改为新名字


#+BEGIN_EXAMPLE
# groupmod -g 102 group2
#+END_EXAMPLE
此命令将组group2的组标识号修改为102。

#+BEGIN_EXAMPLE
# groupmod –g 10000 -n group3 group2
#+END_EXAMPLE
此命令将组group2的标识号改为10000，组名修改为group3。

***** 切换用户组
如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有
其他用户组的权限。用户可以在登录后，使用命令newgrp切换到其他用户组，这
个命令的参数就是目的用户组。例如：

#+BEGIN_EXAMPLE
$ newgrp root
#+END_EXAMPLE

这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的
主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管
理工具来完成。

**** 与用户账号相关的系统文件
完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文
件进行修改。与用户和用户组相关的信息都存放在一些系统文件中，这些文件包
括/etc/passwd, /etc/shadow, /etc/group等。下面分别介绍这些文件的内容。

***** /etc/passwd
*/etc/passwd文件是用户管理工作涉及的最重要的一个文件。* Linux系统中的
每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一
些基本属性。这个文件对所有用户都是可读的。它的内容类似下面的例子：

#+BEGIN_EXAMPLE
  ＃ cat /etc/passwd


  root:x:0:0:Superuser:/:

  daemon:x:1:1:System daemons:/etc:

  bin:x:2:2:Owner of system commands:/bin:

  sys:x:3:3:Owner of system files:/usr/sys:

  adm:x:4:4:System accounting:/usr/adm:

  uucp:x:5:5:UUCP administrator:/usr/lib/uucp:

  auth:x:7:21:Authentication administrator:/tcb/files/auth:

  cron:x:9:16:Cron daemon:/usr/spool/cron:

  listen:x:37:4:Network daemon:/usr/net/nls:

  lp:x:71:18:Printer administrator:/usr/spool/lp:

  sam:x:200:50:Sam san:/usr/sam:/bin/sh
#+END_EXAMPLE

从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记
录又被冒号(:)分隔为7个字段，其格式和具体含义如下：

#+BEGIN_EXAMPLE
用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
#+END_EXAMPLE

1) “用户名”是代表用户账号的字符串。通常长度不超过8个字符，并且由大小
   写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。
   为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和
   加号(+)打头。

2) “口令”一些系统中，存放着加密后的用户口令字。。虽然这个字段存放的
   只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都
   可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都
   使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，
   而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者
   “*”。

3) “用户标识号”是一个整数，系统内部用它来标识用户。一般情况下它与用
   户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部
   将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及
   不同的登录Shell等。

   通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99
   由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，
   这个界限是500。

4) “组标识号”字段记录的是用户所属的用户组。它对应着/etc/group文件中
   的一条记录。

5) “注释性描述”字段记录着用户的一些个人情况，例如用户的真实姓名、电
   话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这
   个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意
   的注释性描述文字，用做finger命令的输出。

6) “主目录”，也就是用户的起始工作目录，它是用户在登录到系统之后所处
   的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，
   而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、
   执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。

7) 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用
   户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用
   户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。
   常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell),
   tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。系统
   管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定
   Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。

   用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释
   器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应
   用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些
   在系统中登记了的程序才能出现在这个字段中。

****** 伪用户
系统中有一类用户称为伪用户（psuedo users），这些用户在/etc/passwd文件
中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主
要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下
所示。

|--------+--------------------------|
| 伪用户 | 含义                     |
|--------+--------------------------|
| bin    | 拥有可执行的用户命令文件 |
| sys    | 拥有系统文件             |
| adm    | 拥有帐户文件             |
| uucp   | UUCP使用                 |
| lp     | lp或lpd子系统使用        |
| nobody | NFS使用                  |
|--------+--------------------------|

 拥有帐户文件

除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。

　　

****** 安全增强
由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较
明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高
的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件
是/etc/shadow文件。只有超级用户才拥有该文件读权限，这就保证了用户密码
的安全性。

***** /etc/shadow
*/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据
/etc/passwd中的数据自动产生。*

它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用“:”隔开。
这些字段是：
#+BEGIN_EXAMPLE
登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
#+END_EXAMPLE
1) “登录名”是与/etc/passwd文件中的登录名相一致的用户账号

2) “口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，
   则对应用户没有口令，登录时不需要口令；如果含有不属于集合 {
   ./0-9A-Za-z }中的字符，则对应的用户不能登录。

3) “最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时
   的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时
   间起点是1970年1月1日。

4) “最小时间间隔”指的是两次修改口令之间所需的最小天数。

5) “最大时间间隔”指的是口令保持有效的最大天数。

6) “警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的
   天数。

7) “不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。

8) “失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就
   给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不
   能再用来登录了。

***** /etc/group
*用户组的所有信息都存放在/etc/group文件中。*

将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。每个用
户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。
当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属
的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属于附
加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。用
户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于
/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：

#+BEGIN_EXAMPLE
组名:口令:组标识号:组内用户列表
#+END_EXAMPLE

1) “组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一
   样，组名不应重复。

2) “口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都
   没有口令，即这个字段一般为空，或者是*。

3) “组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。

4) “组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号
   (,)分隔。这个用户组可能是用户的主组，也可能是附加组。

*** Linux启动流程
+ http://wuchong.me/blog/2014/07/14/linux-boot-process/

**** 流程概览
计算机的启动是一个非常复杂的过程，从打开电源到桌面的显示，需要经过一系
列不可或缺的过程，了解这些过程有助于我们更好地理解操作系统，也有助于我
们修复系统可能出现的问题。

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{/home/ben/Tiger/Figures/w3m/201505011524.jpg}
\end{figure}

**** 启动流程
1. BIOS

   当我们按下电源按键后，计算机硬件会自动读取主板上的BIOS（Basic
   Input/Output System）来加载硬件信息以及硬件系统的自我测试。BIOS也是
   一套程序，它知道如何与硬件进行交互。BIOS首先会对硬件进行检查，判断
   计算机硬件是否能满足运行的基本条件，这叫做“硬件自检”（Power-On
   Self-Test，简称 POST）。

   硬件自检后，BIOS 会将控制权交给下一段启动程序。这时，BIOS需要知
   道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要
   有一个外部存储设备的排序，排在前面的设备就是优先转交控制权的设备。
   这种排序叫做”启动顺序”（Boot Sequence）。

   因此，BIOS按照”启动顺序”，把控制权转交给排在第一位的存储设备。

2. MBR

   系统读取位列第一的可启动存储设备。计算机先读取该设备的第一个扇区，
   也就是读取最前面的512个字节。这最前面的512个字节，就叫做”主引导记
   录”（Master boot record，缩写为MBR）。MBR 只有512字节，放不了太多
   东西，它主要告诉计算机从该设备的哪一个分区（partition）来装载引导加
   载程序（boot loader）。Boot Loader 储存有操作系统（OS）的相关信息，
   比如操作系统名称，操作系统内核（kernel）所在位置等。它的主要功能就
   是加载内核到内存中去执行。常用的 boot loader 有 GRUB 和 LILO 。

   那我们经常说到的多操作系统是怎么回事呢？其实每个文件系统（或分区）
   的最前面会保留一个引导扇区（boot selector），这个引导扇区可以安装
   boot loader。这样我们在每个 boot loader 中对应不同的操作系统，在读
   取 MBR 的时候选择我们需要启动的 boot loader 即可。

3. Kernel

   随后，boot loader 会帮助我们加载内核，内核就会开始检测硬件与加载驱
   动程序。没错，内核会以自己的功能重新检测一遍硬件，而不一定会使用
   BIOS 检测到的硬件信息。也就是说，内核此时才开始接管 BIOS 后的工作。

   Kernel 实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，
   主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上
   的任何操作都要通过 kernel 传达给硬件。

4. init process

   在内核加载完毕以后，此时内核会主动调用第一个进程，那就是 /sbin/init，
   它的作用就是初始化系统环境。使用pstree命令会发现init的进程编号（PID）
   是1，也就是说init是第一个运行的程序，其他所有进程都从它衍生，都是它
   的子进程。

   许多程序需要开机启动。它们在Windows叫做”服务”（service），在
   Linux 就叫做”守护进程”（daemon）。

   init 进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合
   需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不
   需要。Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做”运
   行级别”（run level）。也就是说，启动时根据”运行级别”，确定要运行
   哪些程序。

   基本上，依据有无网络与有无 X Window ，Linux 将 run level 划分为7个
   等级（0-6）。其中0是关机，1是单用户模式，6是重启。而 2-5，一般来说
   都是多用户模式。

   + 0：关机级别
   + 1：单用户运行级别，运行rc.sysinit和rc1.d目录下的脚本
   + 2：多用户，但系统不会启动NFS，字符模式，在有些linux系统中，级别2
     为默认模式，具有网络功能，如ubuntu.debian
   + 3：多用户，字符模式，系统启动具有网络功能,redhat常用运行级别
   + 4：用户自定义级别
   + 5：图形界面模式，redhat常用运行级别
   + 6：重启级别
   + S：单用户运行级别，只运行rc.sysinit文件

   Linux 在启动各个服务前会先执行一系列的初始脚本（rc.sysinit）。这些
   脚本执行如下功能：设置计算机名称，时区，检测文件系统，挂载硬盘，清
   空临时文件，设置网络……

   之后会根据运行级别的不同，系统会运行 rc0.d 到 rc6.d 目录中的相应的
   脚本程序，来完成相应的初始化工作和启动相应的服务。rc*.d目录中存放的
   是该运行级别中需要执行的服务脚本的软链接文件（即快捷方式）。

   除此之外，Linux 还会运行一些其他的初始脚本。运行完后，操作系统已经
   完全准备好了，只是，还没有人可以登录！！！init 会给出登录（login）
   对话框，或者是图形化的登录界面。

5. login

   输入用户名密码登录成功后，系统会为用户分配一个用户 ID（UID），和一
   个组 ID（GID）。这两个 ID 就好像身份证一样会一直伴随用户，用于检测
   用户执行程序时的身份验证。

   当用户登录成功后，一个完整的操作系统就展现在用户的面前了。

6. 总结

   1) 加载 BIOS 的硬件信息与硬件自检，并依据设置取得第一个可启动的设备；
   2) 读取并执行第一个启动设备内的MBR的 boot loader；
   3) 依据 boot loader 的设置加载内核，内核会开始检测硬件与加载驱动程序；
   4) 在内核 Kernel 加载完毕后，Kernel 会主动调用 init 进程，而 init
      会取得 run-level 信息；
   5) init 执行 rc.sysinit 初始化系统的操作环境（网络、时区等）；
   6) init 启动 run-level 的各个服务；
   7) 用户登录

*** Linux开机自动挂载Windows分区硬盘                                 :disk:
+ http://www.douban.com/note/170604841/


对于linux系统挂载windows分区是必须的，比如你u盘fat32的或是ntfs的格式的。
当然这个在ubuntu的我我文件管理器 *nautilus* 会自动挂载。对双系统用户你
的windows在默认的情况下就不会被挂载。当然于是你打开音乐播放器放音乐之
前还要打开nautilus 挂载下。如果我的启动是在命令行下，那好也要手动mount
下。

也有一种软件能够让你自动挂载windows  比如 *ntfs-config*  和ivman。
ntfs-config就用过一次。就是有次重装之前，被ntfs-config 搞的 / 分区无法
挂载（当时还不懂改fstab，汗 只好重装）。其实我们只需要手懂配置fstab来
挂载linux分区。

**** fstab
*fstab* 拆开下 *filesystem  table*, 也就是 linux开机过程控制你要挂载的
硬盘分区配置文件

fstab内容格式是这样的:
#+BEGIN_EXAMPLE
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
#+END_EXAMPLE
如，
#+BEGIN_EXAMPLE
UUID=c5dc9d91-c74b-4d1f-a232-d3151fd57157 / ext4 errors=remount-ro 0 1
#+END_EXAMPLE
或
#+BEGIN_EXAMPLE
或者是
/dev/sda3 / ext4 errors=remount-ro 0 1
#+END_EXAMPLE

**** type

对于linux读取 ntfs分区靠的是 *ntfs-3g*, 所以首先检查下ntfs-3g有没有安
装:
#+BEGIN_SRC sh :exports both
dpkg -l | grep ntfs-3g
#+END_SRC

#+RESULTS:
: ii  ntfs-3g                                               1:2013.1.13ar.1-2ubuntu2                            i386         read/write ntfs driver for fuse

#+BEGIN_EXAMPLE
sudo apt-get install ntfs-3g
#+END_EXAMPLE

**** 查看分区在硬件号， 或uuid
看你要挂分区的硬件号或者uuid，一般来说你D盘是/dev/sda5，E盘是/dev/sda6
依次向后。可以先mount看下，看uuid：
#+BEGIN_EXAMPLE
  sudo blkid
  或
  ls -al /dev/disk/by-uuid
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  /dev/sda1: LABEL="System" UUID="7CBAC8EABAC8A1CE" TYPE="ntfs"
  /dev/sda5: LABEL="Application" UUID="90F2CCECF2CCD81C" TYPE="ntfs"
  /dev/sda6: LABEL="Reserch" UUID="604A95194A94ECD2" TYPE="ntfs"
  /dev/sda7: UUID="eae74ff0-45fd-4f09-9388-959b374ecf00" TYPE="ext4"
  /dev/sda8: UUID="f9f56dde-778a-4c8e-8fb0-539f20bffe92" TYPE="swap"
  /dev/sda9: UUID="f2eaee27-0822-4aa6-b3ed-ab043d2f739b" TYPE="ext4"
#+END_EXAMPLE

*建议用uuid*: 因为uuid是一个硬盘分区, 全中国，全世界，全宇宙的唯一标示
符，当然uuid不仅标示硬盘分区还表示其他电脑设备。

**** 步骤
1. 备份

   对fstab 进行备份: =cp /etc/fstab /etc/fstab.bak=,这是一种习惯, 修改
   错的话, cp回来覆盖就行。

2. 设置挂载点
   #+BEGIN_EXAMPLE
   sudo mkdir /media/Reserch
   ...
   #+END_EXAMPLE

3. 配置fstab
   #+BEGIN_EXAMPLE
     UUID="604A95194A94ECD2"  /media/Reserch  ntfs-3g  default  0  0
     或
     /dev/sda6  /media/Reserch ntfs-3g default 0 0
   #+END_EXAMPLE

   第4挂载参数，默人填default就行。如果需要更多的功能可以藏，这么填写
   =defaults,utf8,umask=000,uid=fly,gid=fly=
   + uid 后面的参数是你用户名
   + gid后面的是你的用户组名
   + gid,uid 主要是为了你可能无法将文件删除近回收站
   + umask这个参是防止你不能读写文件
   + utf8 是考虑可能出现的乱码

*** Linux sudo                                                       :sudo:
+ http://www.linux178.com/linux/sudo.html
+ http://askubuntu.com/questions/90726/is-it-possible-to-give-sudo-access-to-only-a-particular-command


1. sudo是什么？

   sudo是一种权限管理机制，管理员可以授权于一些普通用户去执行一些root
   执行的操作，而不需要知道root的密码，它依赖于/etc/sudoers这个文件，
   可以授权于那个用户在那个主机上能够以管理员的身份执行什么样的管理命
   令，而且是有限的。这个文件相当于就是一个授权表。

2. /etc/sudoers 文件的语法

   可以使用 man sudoers 来查看其帮助信息

   由于这个文件是一个授权文件，那么其权限必定是很严格
   #+BEGIN_EXAMPLE
     [root@Linux178 ~]# ll /etc/sudoers
     -r--r----- 1 root root 3381 Feb 23  2012 /etc/sudoers
     [root@Linux178 ~]#

     [root@Linux178 ~]# lsattr /etc/sudoers
     ------------- /etc/sudoers
     [root@Linux178 ~]#
   #+END_EXAMPLE

   看到这个文件的权限是root和root组 只有读的权限，那也就是，编辑这个文
   件是有单独的命令的 *visudo* （这个文件我们最好不要使用vim命令来打开），
   是因为一旦你的语法写错会造成严重的后果，这个工具会替你检查你写的语
   法,这个文件的语法遵循以下格式：

   *who where whom command*

   说白了就是 那个用户在哪个主机以谁的身份执行那些命令，那么这个where,
   是指允许在那台主机ssh连接进来才能执行后面的命令，文件里面默认给root
   用户定义了一条规则， 看例子：

   #+BEGIN_EXAMPLE
     root    ALL=(ALL)       ALL
   #+END_EXAMPLE

   + root root用户
   + ALL 所有的主机上都可以
   + (ALL) 是以谁的身份来执行，ALL就代表root可以任何人的身份来执行命令
   + ALL 所有的命令

   那么整个一条规则就是root用户可以在任何主机以任何人的身份来执行所有
   的命令，也就是不限定。

   再来看一条里面的规则：

   #+BEGIN_EXAMPLE
   %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom
   jerry   192.168.100.0/24=(root) /usr/sbin/useradd
   #+END_EXAMPLE

   + %users 就是代表users这个组里面的所有成员
   + ALL 代表可以这所有的主机上
   + = 后面没有括号，也就是代表默认是以root身份
   + /sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom 可以执行挂载的命令

3. 查看用户可以执行的命令

   已经授权的普通用户可以使用: sudo -l

   来查看自己可以执行那些命令

   要执行命令要在执行命令之前加上 sudo ，然后输入用户自己的密码，这是
   因为要验证，执行命令的用户确实是该用户。

   sudo命令还有这个机制，就是在你正确输入密码并成功执行命令的5分钟内，
   再执行命令是不需要输入密码的，过了5分钟，就需要再次验证该用户的自己
   的密码，当然也可以手动让该期限过期，看下面sudo命令的语法

4. sudo命令语法

   sudo [-bhHpV][-s ][-u <用户>][指令]  或  sudo [-klv]

   参数
   + -b  在后台执行指令。
   + -h  显示帮助。
   + -H  将HOME环境变量设为新身份的HOME环境变量。
   + -k  结束密码的有效期限，也就是下次再执行sudo时便需要输入密码。
   + -l  列出目前用户可执行与无法执行的指令。
   + -p  改变询问密码的提示符号。
   + -s  执行指定的shell。
   + -u <用户>  以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份。
   + -v  延长密码有效期限5分钟。
   + -V  显示版本信息。
   + -S   从标准输入流替代终端来获取密码

5. 场景

   思考这么一个场景，看下面的规则
   #+BEGIN_EXAMPLE
     jerry   192.168.100.0/24=(root) /usr/sbin/useradd
   #+END_EXAMPLE

   这里面我如果想很多台主机上登录并执行命令（但是并不是所有的主机上），
   那这里岂不是要写很多的主机在这里吗？ 你执行useradd命令，但是这只是
   添加，不能为用户指定密码，那岂不是也不行？如果还有执行很多的命令，
   那是不是这里又要写很多的命令？

   答案是否定的

   sudo 是支持 主机别名、用户别名、whom别名（就是以谁的身份）、命令别
   名

   有了别名，规则就变得很清爽，就是把同类的对象放到一个组里面，组名必
   须全部大写

   主机别名 通过 Host_Alias 关键字来定义 例如下面的：
   #+BEGIN_EXAMPLE
     # Host_Alias     FILESERVERS = 192.168.100.0/24, 127.0.0.1
   #+END_EXAMPLE

   用户别名 通过 User_Aliases 关键字来定义，例如下面的：
   #+BEGIN_EXAMPLE
     # User_Alias ADMINS = jsmith, mikem
   #+END_EXAMPLE

   whom别名（就是以谁的身份） 通过 RunAs_Aliases 关键字来定义

   这个通常是root或者是ALL 就不用定义了。

   命令别名 通过 Cmnd_Alias 关键字来定义，例如下面的：
   #+BEGIN_EXAMPLE
     #Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig
   #+END_EXAMPLE

6. 限定执行的命令

   假设你允许一个普通用户执行passwd，那这就危险了，那么它是可以直接修
   改root的密码，这就有背于我们的初衷了，这就需要做限制了，如下设置：
   #+BEGIN_EXAMPLE
   pete    127.0.0.1 = /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root
   #+END_EXAMPLE

   [A-Za-z]* 是一个正则表达式，代表是大小写字母组成的用户名

   这一条就是限制pete这个用户，只能修改以字母组成的用户，而不能修改
   root的密码，! 就是代表不能执行此命令。

   在某个命令之前加!,就代表该用户或组不能执行该命令

7. 设定那些命令执行的时候不需要输入密码

   当然也是可以设置在执行某些命令的时候不用输入密码,例如：
   #+BEGIN_EXAMPLE
     fred           ALL = (DB) NOPASSWD: ALL
   #+END_EXAMPLE

   这就代表这个fred用户执行所有的命令时不需要输入密码

   再如：
   #+BEGIN_EXAMPLE
     tom ALL = (root) PASSWD:/usr/sbin/useradd,/usr/sbin/usermod NOPASSWD:/usr/sbin/gourpadd
   #+END_EXAMPLE

   这一条就是代表tom这个用户在执行uesradd和usermod的时候是需要输入密码，
   而执行gourpadd时不需要

   凡是 PASSWD 后面跟的命令都需要输入密码，而NOPASSWD后面的命令都不需
   要输入密码，前提是sudo记住密码的期限已过。

*** service                                                       :service:
service命令，顾名思义，就是用于管理Linux操作系统中服务的命令。

1. 声明：这个命令不是在所有的linux发行版本中都有。主要是在redhat、
   fedora、mandriva和centos中。

2. 此命令位于/sbin目录下，用file命令查看此命令会发现它是一个脚本命令。

3. 分析脚本可知此命令的作用是去/etc/init.d目录下寻找相应的服务，进行开
   启和关闭等操作。

4. 开启服务：service <SERVICE> start
   + start 表示启动
   + restart 表示重新启动
   + stop 表示关闭
   + reload 表示重新载入配置。

5. 关闭mysql服务器：service mysqld stop

6. 强烈建议大家将service命令替换为/etc/init.d/mysqld stop （因为有一些
   linux的版本不支持service）

7. 管理员权限

*** sysv-rc-conf(ubuntu)
+ http://www.codesky.net/article/201109/133204.html
+ http://sysv-rc-conf.sourceforge.net/
+ http://askubuntu.com/questions/221293/why-is-chkconfig-no-longer-available-in-ubuntu


1. what
   sysv-rc-conf是一个强大的服务管理程序，群众的意见是sysv-rc-conf比
   chkconfig(redhat)好用。

2. INSTALL
   + sudo apt-get install sysv-rc-conf
   +
3. USE

   1) $ sudo sysv-rc-conf

      操作界面十分简洁，你可以用鼠标点击，也可以用键盘方向键定位，用空
      格键选择，用Ctrl+N翻下一页，用Ctrl+P翻上一页，用Q退出。

   2) $ sudo sysv-rc-config --list

   3) $ sudo sysv-rc-config SERVICE on

*** ssh                                                               :ssh:
+ http://zh.wikipedia.org/wiki/Secure_Shell

**** intro
+ 网络传输的安装协议
+ 可靠
+ 快速
+ 版权限制


Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）
所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的
Shell（壳层）提供安全的传输和使用环境。

传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为
它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人
（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充
真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服
务器。

而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利
用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传
输的数据进行加密，也能够防止DNS欺骗和IP欺骗。

SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。
SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个
安全的“通道”。

**** OpenSSH
OpenSSH是SSH的替代软件包，而且是开放源代码且自由的。

*** 模块相关命令
Linux操作系统中模块操作相关命令解释
+ lsmod  查看已经安装好的模块， 也可以查看/proc/modules文件的内容. 实
  际上,lsmod读命令就是通过查看/proc/modules的内容来显示模块信息的.
+ modinfo 显示模块信息
+ modprobe  不需要指定路径，它会到默认路径下寻找模块。模块也存在依赖性
  问题: 比如你要加载msdos.ko, 需要先加载fat.ko. modprobe查看
  /lib/module/version/modules.dep得知模块的依赖关系
+ rmmod 卸载模块，但是内核会认为卸载模块不安全，可以添加命令强制卸载。
+ depmod 检查系统中模块之间的依赖关系，并把依赖关系信息存于
  /lib/modules/2.6.18-1.2798/modules.dep中。 一般加载模块后，要命令行
  下先执行 depmod -a后，在系统加载模块时候会查看modules.dep中模块依赖
  及路径信息，这样子才可以成功加载需要模块。
+ insmod 加载模块，需要指定完整的路径和模块名字。

*** 备份与还原
+ http://tieba.baidu.com/p/1184618169
+ http://www.ibm.com/developerworks/cn/linux/l-roadmap/part8/
+ http://blog.csdn.net/huhui_cs/article/details/8710658


曾经听到很多人抱怨 Linux 下没有 ghost 这样“方便”的备份工具。这是一种
普遍的误解，其实 Linux 下是可以用 ghost for Linux 的，但因为有更好的办
法，所以 ghost 在 Linux 下用得少，知名度不高。

现在以我的系统为例，介绍两种 Linux 下最常见最实用的系统备份方案。我的
系统是 Gentoo Linux，sda1 30GB，挂载为 /，sda2 400GB，挂载为 /home,
sda3 100GB，格式化为 ext4，空闲。


**** dd
dd 是最强劲有力、稳定可靠的备份工具。

备份：当前系统下，
#+BEGIN_EXAMPLE
~ % sudo dd if=/dev/sda1 of=~/gentoo_$(date +"%Y-%m-%d").backup
#+END_EXAMPLE

还原：其它 Linux 系统或者 LiveCD/LiveUSB 下，
#+BEGIN_EXAMPLE
~ % sudo dd if=gentoo_*.backup of=/dev/sda1
#+END_EXAMPLE

如果要改变根分区的位置，比如说把根分区移动到 sda5，那麽还需要调整一下：
#+BEGIN_EXAMPLE
~ % sudo resize2fs -f /dev/sda5
~ % sudo e2fsck -f /dev/sda5
#+END_EXAMPLE

然后修改恢复出来的 /etc/fstab 文件。

请注意 sda5 的容量必须大于 sda1.

dd 备份简单快速，是速度优先的最好选择，但所需要的磁盘空间比较大。

**** tar + xz
tar 用于打包，xz 用于压缩。

备份：当前系统下，
#+BEGIN_EXAMPLE
~ % cd /

/ % sudo tar Jcpvf ~/gentoo_amd64_$(date +"%Y-%m-%d").tar.xz --exclude=./usr/portage/distfiles --exclude=./home --exclude=./lost+found --exclude=./sys --exclude=./proc .
#+END_EXAMPLE

其中，--exclude= 参数列出了不需要备份的目录，可以根据实际情况自行调整。

还原：其它 Linux 系统或者 LiveCD/LiveUSB 下，
#+BEGIN_EXAMPLE
~ % sudo mkfs.ext4 /dev/sda1
~ % sudo mount -v /dev/sda1 /mnt
~ % sudo cd /mnt/
~ % sudo tar xpvf gentoo_amd64_*.tar.xz
~ % sudo mkdir -pv home sys proc usr/portage/distfiles
~ % cd && sudo umount -v /mnt
#+END_EXAMPLE

如果移动了根分区，则需要修改还原出来的 /etc/fstab 文件

tar+xz 压缩打包备份的优点，在于极高的压缩率，可以大大减少备份文件的大
小。我的备份以前的 / 分区有 11G 大小，而备份出来的 .tar.xz 文件，只有
2.1G，压缩比为超过了 5:1. 但这带来一个问题：备份耗时漫长。比如说我这次
11G 的压缩备份就花了 2 小时。幸好还原速度还可以，只需要 8 分钟。此外，
如果你 man 一下 tar，就会发现这种做法其实十分灵活好用。

**** 备份恢复手记
1. 使用dd备份/(/dev/sda7)，备份文件比根目录大将近两倍，不知为何
2. 安装AMD驱动导致Ubuntu进入不了X桌面
3. 理论上删除/etc/X11/xorg.conf即可
4. 使用dd恢复
5. 时间长，等待期间焦急，遂去借书
6. 恢复时间超过半个小时
7. 完成后重启出现问题
8. 强制关机后重启第一次挂载/时出借，手动修复无果，自动修复成功
9. 证明dd备份恢复是可行的
*** 进程间通信(IPC)                                               :process:
+ http://www.ibm.com/developerworks/cn/linux/l-ipc/
+ http://blog.csdn.net/jmy5945hh/article/details/7367532


linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的。而
对Unix发展做出重大贡献的两大主力AT&T的贝尔实验室及BSD（加州大学伯克利
分校的伯克利软件发布中心）在进程间通信方面的侧重点有所不同。前者对Unix
早期的进程间通信手段进行了系统的改进和扩充，形成了“system V IPC”，通
信进程局限在单个计算机内；后者则跳过了该限制，形成了基于套接口（socket）
的进程间通信机制。Linux则把两者继承了下来，如图示：

\begin{figure}[ht]
\centering
\includegraphics[width=0.4\linewidth]{/home/ben/Tiger/Figures/scrot/16597IjP.png}
\end{figure}

一般来说，linux下的进程包含以下几个关键要素：
+ 有一段可执行程序；
+ 有专用的系统堆栈空间；
+ 内核中有它的控制块（进程控制块），描述进程所占用的资源，这样，进程才
  能接受内核的调度；
+ 具有独立的存储空间

Linux 进程间通信方式:

1. *管道（Pipe）及有名管道（named pipe）* ：

   管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限
   制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

2. *信号（Signal）* ：

   信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于
   进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期
   信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction
   （实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对
   外接口，用sigaction函数重新实现了signal函数）；

3. *报文（Message）队列（消息队列）* ：

   消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够
   权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中
   的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以
   及缓冲区大小受限等缺点。

4. *共享内存* ：

   使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其
   他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使
   用，来达到进程间的同步及互斥。

5. *信号量（semaphore）* ：

   主要作为进程间以及同一进程不同线程之间的同步手段。

6.  *套接口（Socket）* ：

    更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由
    Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：
    Linux和System V的变种都支持套接字。

*** UML(UserModeLinux)                                                :uml:
+ http://www.hankjohn.net/weblog/2010/11/12/33731937201010129263187/
+ http://www.usermodelinux.org/


User-mode-linux (UML) 是让一个Linux作为一个独立进程运行在另一个linux上。

UML 是一种在同一时间运行多Linux 的安全方式。每个进程都是独立去其他的，
这非常安全，例如在同一机器上进行多种测试和研发而不互相干扰。如果一些测
试进程损坏并不会影响宿主系统或研发用进程。
*** 查看端口使用情况                                                 :port:
+ http://www.cnblogs.com/benio/archive/2010/09/15/1826728.html
+ http://blog.csdn.net/wudiyi815/article/details/7473097


首先你必须知道，端口不是独立存在的，它是依附于进程的。某个进程开启，那
么它对应的端口就开启了，进程关闭，则该端口也就关闭了。下次若某个进程再
次开启，则相应的端口也再次开启。而不要纯粹的理解为关闭掉某个端口，不过
可以禁用某个端口。


1. 可以通过"netstat -anp" 来查看哪些端口被打开。

   （注：加参数'-n'会将应用程序转为端口显示，即数字格式的地址，如：
   nfs->2049, ftp->21，因此可以开启两个终端，一一对应一下程序所对应的
   端口号）

2. lsof -i:$PORT

   然后可以通过""查看应用该端口的程序（$PORT指对应的端口号）。或者你也
   可以查看文件/etc/services，从里面可以找出端口所对应的服务。

   （注：有些端口通过netstat查不出来，更可靠的方法是"sudo nmap -sT -O
   localhost"）

3. 关闭端口
   1) 通过iptables工具将该端口禁掉，如：
      + "sudo iptables -A INPUT -p tcp --dport $PORT -j DROP"
      + "sudo iptables -A OUTPUT -p tcp --dport $PORT -j DROP"
   2) 关掉对应的应用程序，则端口就自然关闭了，如：
      #+BEGIN_EXAMPLE
      "kill -9 PID" (PID：进程号)
      #+END_EXAMPLE

4. chkconfig

   可通过"chkconfig"查看系统服务的开启状态(Ubuntu另有工具)

*** DONE Linux 周期任务                                      :cron:crontab:
- state "done"       from "todo"       [2015-11-23 一 11:19] \\
  用时长，首先应该充分证阅读资料
clock: [2015-11-23 一 10:46]--[2015-11-23 一 11:19] =>  0:33
clock: [2015-11-23 一 10:24]--[2015-11-23 一 10:38] =>  0:14

**** crontab

1. 命令： *crontab*,  格式： /crontab [-u user] [file | -e | -l | -r]/
   - -u user： 指定用户
   - file: 将文件file作为crontab的任务列表并载入crontab, 缺省则为标准
     输入
   - -e: 编辑
   - -l: 显示
   - -r: 从 */var/spool/cron* 删除某个用户的crontab文件
     #+begin_src sh
     ls /var/spool/cron/
     #+end_src

     #+results:
     : crontabs
   - -i: 删除时显示提示信息

2. crontab文件格式
   #+begin_example
   分 时 日 月 星期 命令
   #+end_example
   + 分: 1～59
   + 时: 0~23
   + 日: 1~31
   + 日期： 0～6
   + 命令： 第六列

**** usage

1. 指定编辑器
   #+begin_latex
   \begin{minted}[frame=single, mathescape]{sh}
   editor=vi; export editor  # in .bashrc
   \end{minted}
   #+end_latex

2. 备份
   #+begin_latex
   \begin{minted}[frame=single, mathescape]{sh}
   crontab -l > ~/mycron
   \end{minted}
   #+end_latex

   #+begin_src sh
   crontab -l
   #+end_src

   no crontab for ben

3. examples
   #+begin_example
     实例1：每1分钟执行一次mycommand
     ,* * * * * mycommand

     实例2：每小时的第3和第15分钟执行
     3,15 * * * * mycommand

     实例3：在上午8点到11点的第3和第15分钟执行
     3,15 8-11 * * * mycommand

     实例4：每隔两天的上午8点到11点的第3和第15分钟执行
     3,15 8-11 */2  *  * mycommand

     实例5：每周一上午8点到11点的第3和第15分钟执行
     3,15 8-11 * * 1 mycommand

     实例6：每晚的21:30重启smb
     30 21 * * * /etc/init.d/smb restart

     实例7：每月1、10、22日的4 : 45重启smb
     45 4 1,10,22 * * /etc/init.d/smb restart

     实例8：每周六、周日的1 : 10重启smb
     10 1 * * 6,0 /etc/init.d/smb restart

     实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb
     0,30 18-23 * * * /etc/init.d/smb restart

     实例10：每星期六的晚上11 : 00 pm重启smb
     0 23 * * 6 /etc/init.d/smb restart

     实例11：每一小时重启smb
     ,* */1 * * * /etc/init.d/smb restart

     实例12：晚上11点到早上7点之间，每隔一小时重启smb
     ,* 23-7/1 * * * /etc/init.d/smb restart

   #+end_example

**** note
1. 每条周期任务增加注释
2. 环境变量与当前环境不一定一致，往往需要设置（在要执行的脚本中）
3. 全局路径
4. 不会立即重启
   #+begin_example
   sudo service cron restart
   #+end_example
5. % 有特殊含义，表换行，需要转义
   #+begin_example
   * * * * * /bin/echo `date "+\%m"` >> /tmp/test_cron
   #+end_example

**** 手记
#+begin_example
  usage:  crontab [-u user] file
          crontab [ -u user ] [ -i ] { -e | -l | -r }
                  (default operation is replace, per 1003.2)
          -e      (edit user's crontab)
          -l      (list user's crontab)
          -r      (delete user's crontab)
          -i      (prompt before deleting user's crontab)

  journal $ crontab -l
  no crontab for ben

  journal $ crontab -u ben
  crontab: usage error: file name must be specified for replace
  usage:  crontab [-u user] file
          crontab [ -u user ] [ -i ] { -e | -l | -r }
                  (default operation is replace, per 1003.2)
          -e      (edit user's crontab)
          -l      (list user's crontab)
          -r      (delete user's crontab)
          -i      (prompt before deleting user's crontab)

  journal $ crontab -u  ben cron
  cron: 没有那个文件或目录

  journal $ crontab cron
  cron: 没有那个文件或目录

  journal $ export editro=vi

  journal $ crontab cron
  cron: 没有那个文件或目录

  journal $ touch cron
  journal $ crontab cron
  journal $ crontab -l
  journal $ crontab -e

  select an editor.  to change later, run 'select-editor'.
    1. /bin/ed
    2. /bin/nano        <---- easiest
    3. /usr/bin/vim.tiny
  choose 1-3 [2]: 3
  crontab: installing new crontab

  journal $ crontab -l
  ,* * * * * date +%m > /tmp/test_cron

  journal $ crontab -e
  crontab: installing new crontab

  journal $ ls /var/spool/cron/crontabs/
  ls: 无法打开目录/var/spool/cron/crontabs/: 权限不够
  journal $ sudo ls /var/spool/cron/crontabs/
  [sudo] password for ben:
  ben
  journal $ sudo cat /var/spool/cron/crontabs/ben
  # do not edit this file - edit the master and reinstall.
  # (/tmp/crontab.zug5cu/crontab installed on mon nov 23 10:57:55 2015)
  # (cron version -- $id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie exp $)
  ,* * * * * /bin/echo `date +%m` >> /tmp/test_cron


  journal $ crontab -l
  ,* * * * * /bin/echo `date +%m` >> /tmp/test_cron
  journal $ /bin/echo `date +%m` >> /tmp/test_cron


  journal $ service cron restart
  stop:未知任务: cron
  start:未知任务: cron

  journal $ sudo service cron restart
  cron stop/waiting
  cron start/running, process 4693

  journal $ crontab -l
  ,* * * * * /bin/echo `date +%m` >> /tmp/test_cron

  journal $ crontab -e
  crontab: installing new crontab

  journal $ crontab -l
  ,* * * * * /bin/echo `date "+%m"` >> /tmp/test_cron

  journal $ crontab -e
  crontab: installing new crontab
  journal $ sudo service cron restart
  cron stop/waiting
  cron start/running, process 4950
  journal $ cat /tmp/test_cron
  00
  06
  12
  13
  journal $ crontab -l
  ,* * * * * /bin/echo `date "+\%m"` >> /tmp/test_cron ### ok

  journal $ crontab -ir
  crontab: really delete ben's crontab? (y/n) y


#+end_example
**** 参考：
+ [[https://app.yinxiang.com/shard/s52/nl/11551545/954d6b3c-3901-41f3-b3bb-22c2e14feaff?title=19.%20crontab%20%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%20%e2%80%94%20linux%20tools%20quick%20tutorial][linux tools quick tutorial: crontab]]

*** 查看CPU个数                                                       :cpu:

*cat /proc/cpuinfo | grep processor*

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{text}
   $ cat /proc/cpuinfo | grep processor
  processor       : 0
  processor       : 1
  processor       : 2
  processor       : 3
  \end{minted}
#+end_latex

** 网络管理
*** Linux 远程登录
**** telnet
**** ssh
*** Linxu 网络服务器
**** apache
*** socket
+ http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html
+ http://www.cnblogs.com/dolphinX/p/3460545.html


柏克莱套接字（英语：Berkeley sockets） ，又称为BSD 套接字(BSD sockets)
是一种应用程序接口（API），包括了一个用C语言写成的应用程序开发库，主要
用于实现进程间通讯，在计算机网络通讯方面被广泛使用。

接口实现用于TCP/IP协议，因此它是维持Internet的基本技术之一。 它是由加
利福尼亚的伯克利大学开发，最初用于Unix系统。 如今，所有的现代操作系统
都有一些源于Berkeley套接字接口的实现，它已成为连接Internet的标准接口。

*** Apache安装配置
+ Wiki: http://zh.wikipedia.org/wiki/Apache_HTTP_Server
+ Homepage: http://httpd.apache.org/
+ CSDN: http://blog.csdn.net/yzzst/article/details/12045801

**** what
Apache HTTP Server（简称Apache）是Apache软件基金会的一个开放源代码的网
页服务器软件，可以在大多数电脑操作系统中运行，由于其跨平台和安全性。被
广泛使用，是最流行的Web服务器软件之一。它快速、可靠并且可通过简单的API
扩充，将Perl／Python等解释器编译到服务器中。

中文：阿帕奇
**** Install
+ 源码安装：./configure make make install
**** 启动与测试
+ /usr/local/apache2/bin/apachectl start
+ /usr/local/apache2/bin/apachectl restart
+ 打开浏览器,在地址栏输入"http://localhost" 出现“It works!”或apache
  图标的漂亮界面，说明apache安装成功！

**** php5
+ 配置文件: /usr/local/apache/conf/httpd.conf
+ LoadModule php5_module module/libphp5.so  # 不一定一模一样
+ AddType application/x-httpd-php .php .phtml .php3
+ AddType application/x-httpd-php-source .phps

**** 问题
1. httpd: Could not reliably determine the server's fully qualified
   domain name
   + http://blog.sina.com.cn/s/blog_4d83777b0100pgal.html

2. sudo 启动

3. 默认目录
   + 配置 *DocumentRoot* 选项以及随后的 <DIRECTORY ...>

** 设备管理
*** udev                                                             :udev:
用于管理 *设备文件*: http://www.cnblogs.com/sopost/archive/2013/01/09/2853200.html
**** Linux 文件 /etc/udev/rules.d/

#+BEGIN_SRC sh :results output
cat /etc/udev/rules.d/README
#+END_SRC

#+RESULTS:
#+begin_example
The files in this directory are read by udev(7) and used when events
are performed by the kernel.  The udev daemon watches this directory
with inotify so that changes to these files are automatically picked
up, for this reason they must be files and not symlinks to another
location as in the case in Debian.

Packages do not generally install rules here, this directory is for
local rules.  If you want to override behaviour of package-supplied
rules, which can be found in /lib/udev/rules.d, you can do one of
two things:

 1) Write your own rules in this directory that assign the name,
    symlinks, permissions, etc. that you want.  Pick a number higher
    than the rules you want to override, and yours will be used.

 2) Copy the file from /lib/udev/rules.d and edit it here; you
    should generally only do this if you want to prevent a program
    from being run.


If the ordering of files in this directory are not important to you,
it's recommended that you simply name your files "descriptive-name.rules"
such that they are processed AFTER all numbered rules in both this
directory and /lib/udev/rules.d and thus override anything set there.
#+end_example

*** 显卡
**** Linux 显卡开源驱动
+ https://help.ubuntu.com/community/RadeonHD

xserver-xorg-video-*
**** Linux AMD 闭源显卡驱动
+ http://forum.ubuntu.org.cn/viewtopic.php?f=42&t=445434


fglrx
**** Linux 双显(dual-monitors) xrandr
+
   http://zeroset.mnim.org/2013/01/07/dual-head-monitor-setup-on-ubuntu-linux-with-xorg-and-radeon/
+ http://my.oschina.net/pureboys/blog/88448



1. Dynamic Configuration

   We will use xrandr to configure a temporary dual-head setup during
   runtime. After connecting the monitor to the laptop, obtain the
   labels the system assigned to the monitors by a
   #+BEGIN_EXAMPLE
   xrandr -q
   #+END_EXAMPLE

   In my case, the output read
   #+BEGIN_EXAMPLE
     Screen 0: minimum 320 x 200, current 1920 x 1848, maximum 8192 x 8192
     LVDS connected 1366x768+0+1080 (normal left inverted right x axis y axis) 0mm x 0mm
        1366x768       60.0*+
        1280x720       59.9
        1152x768       59.8
      (...)
     HDMI-0 connected 1920x1080+0+0 (normal left inverted right x axis y axis) 531mm x 299mm
        1920x1080      60.0*+   50.0
        1600x1200      60.0
        1680x1050      59.9
      (...)
      VGA-0 disconnected (normal left inverted right x axis y axis)
   #+END_EXAMPLE

   The laptop’s internal monitor is called LVDS and the external
   monitor HDMI-0. By another call to xrandr, we activate the
   dual-head setup:
   #+BEGIN_EXAMPLE
     xrandr --output HDMI-0 --primary --left-of LVDS
   #+END_EXAMPLE

   The command line is to be understood literally: The HDMI monitor
   shall be the primary screen (e.g. displaying gnome’s titlebar) and
   shall be positioned left of the laptop’s internal monitor. For
   other placements, see xrandr’s –left-of, –right-of, –above and
   –below options or the very general –pos argument.

2. Permanent Configuration

   For a permanent static configuration of a dual-head setup, we
   create a configuration file for the X server with an editor of your
   choice, */etc/X11/xorg.conf*

   You will need root privileges for this. The contents of xorg.conf
   is as follows:
   #+BEGIN_EXAMPLE
     Section "Device"
             Identifier      "Mobility Radeon HD 5400 Series"
             Driver          "radeon"
             Option          "monitor-LVDS" "monitor_internal"
             Option          "monitor-HDMI-0" "monitor_external"
     EndSection

     Section "Monitor"
             Identifier      "monitor_internal"
             Option          "RightOf" "monitor_external"
     EndSection

     Section "Monitor"
             Identifier      "monitor_external"
             Option          "Primary" "true"
     EndSection
   #+END_EXAMPLE

   In the device section, we specify to use Xorgs’s open source
   radeon driver and setup two aliases for the monitors. Please note
   that the monitor ID is composed of the static prefix monitor- and
   the monitor label as returned by xrandr -q (see above). The
   remaining configuration places the laptop’s internal monitor right
   of the external monitor. The latter is configured to be the primary
   screen

*** 硬盘
**** 挂载
http://zhidao.baidu.com/link?url=sI0Cj1dxjOadRiFkLrHYGRi4LpqtlGYfn9uUfAhIzDIDEKsqzl2TGHPx_LPdY0xpYdqbLAi9n9txnY9V94YcKu_13HTEP8z8n_y4CiQD3V3
1. 查看硬盘信息： sudo fdisk -l
2. 挂载：sudo mount ntfs /dev/sdb /mnt/sdb
3. 卸载： sudo umount sdb

**** 新硬盘
http://blog.csdn.net/chenjiiinliang/article/details/7301999

sda是第一块SCSI硬盘，sdb第二块，以此类推...物理分区使用a、b编号，每个
物理硬盘最多有四个主逻辑分区（或扩展分区），所以自动分区中，扩展分区
sda2下第一个逻辑分区编号从5开始。

1. 加载硬盘
   #+BEGIN_EXAMPLE
   sudo hdparm -I /dev/sdb
   #+END_EXAMPLE

   硬盘硬件安装后，此命令测试linux系统是否能找到挂载的未分区硬盘

2. 创建分区
   #+BEGIN_EXAMPLE
   sudo fdisk /dev/sdb
   #+END_EXAMPLE

   第一次执行sudo fdisk /dev/sdb，出现了Error: Unable to open
   /dev/sdb - unrecogniseddisk label.  提示找不到磁盘标签，可以使用
   parted 进行分区

   #+BEGIN_EXAMPLE
   sudo parted  /dev/sdb
   #+END_EXAMPLE

3. 格式化硬盘
   #+BEGIN_EXAMPLE
   sudo mkfs -t ext3 /dev/sdb1
   #+END_EXAMPLE

   把上面创建的新硬盘分区格式化为ext3格式，这个要等一会才能自动结束。

4. 设置卷标
   #+BEGIN_EXAMPLE
   sudo e2label /dev/sdb1 /backup
   #+END_EXAMPLE

   这里/backup 就是在/dev/sdb1根下起了个名字.

5. 设置挂载点
   #+BEGIN_EXAMPLE
   sudo mkdir /backup                   //在根路径下创建挂载点
   #+END_EXAMPLE

6. 设置开机自动挂载
   #+BEGIN_EXAMPLE
   sudo vim /etc/fstab
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
    <file system> <mount point>   <type>  <options>       <dump>      <pass>
   #+END_EXAMPLE
   + 指代文件系统的设备名。最初，该字段只包含待挂载分区的设备名（如
     /dev/sda1）。现在，除设备名外，还可以包含LABEL或UUID

   + 文件系统挂载点。文件系统包含挂载点下整个目录树结构里的所有数据，
     除非其中某个目录又挂载了另一个文件系统

   + 文件系统类型。下面是多数常见文件系统类型
     （ext3,tmpfs,devpts,sysfs,proc,swap,vfat）

   + mount命令选项。mount选项包括noauto（启动时不挂载该文件系统）和ro
     （只读方式挂载文件系统）等。在该字段里添加用户或属主选项，即可允
     许该用户挂载文件系统。多个选项之间必须用逗号隔开。其他选项的相关
     信息可参看mount命令手册页（-o选项处）

   + 储文件系统？该字段只在用dump备份时才有意义。数字1表示该文件系统需
     要转储，0表示不需要转储

   + 件系统检查？该字段里的数字表示文件系统是否需要用fsck检查。0表示不
     必检查该文件系统，数字1示意该文件系统需要先行检查（用于根文件系
     统）。数字2则表示完成根文件系统检查后，再检查该文件系统

** UNIX哲学
Unix哲学是一套基于Unix操作系统顶级开发者的经验出来的软件开发的准则和哲
学。
+ 程序应该只关注一个目标，并尽可能地把它做好
+ 让程序能够互相协同工作。
+ 应该让程序文本数据流，因为这是一个通用的接口。

* shell                                                               :shell:
** shell
*** find                                                             :find:
**** 基本用法
1. 功能： 用于在目录树下查找文件，并作出相应的处理

2. 命令格式： *find <path> [-options] [-print|-exec-ok]*

3. 命令参数
   + path: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示
     系统根目录。

   + -print： find命令将匹配的文件输出到标准输出。

   + -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令
     的形式为'command' {  } \;，注意{   }和\；之间的空格。

   + -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所
     给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定
     是否执行。

4. 命令选项
   + *-name*   按照文件名查找文件。
   + -perm   按照文件权限来查找文件。
   + -prune  使用这一选项可以使find命令不在当前指定的目录中查找，如果
     同时使用-depth选项，那么-prune将被find命令忽略。

   + -user   按照文件属主来查找文件。
   + -group  按照文件所属的组来查找文件。
   + -mtime -n +n  按照文件的更改时间来查找文件，
     + - n表示文件更改时间距现在n天以内，
     + + n表示文件更改时间距现在n天以前。
   + find命令还有-atime和-ctime 选项，但它们都和-m time选项。

   + -nogroup  查找无有效所属组的文件，即该文件所属的组在/etc/groups中
     不存在。

   + -nouser   查找无有效属主的文件，即该文件的属主在/etc/passwd中不存
     在。

   + -newer file1 ! file2  查找更改时间比文件file1新但比文件file2旧的
     文件。

   + -type  查找某一类型的文件，诸如：
     + b - 块设备文件。
     + d - 目录。
     + c - 字符设备文件。
     + p - 管道文件。
     + l - 符号链接文件。
     + f - 普通文件。

   + -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节
     计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子
     目录中查找。

   + -fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可
     以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件
     系统的信息。

   + -mount：在查找文件时不跨越文件系统mount点。

   + -follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。

   + -cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。

   + -amin n   查找系统中最后n分钟访问的文件
   + -atime n  查找系统中最后n*24小时访问的文件
   + -cmin n   查找系统中最后n分钟被改变文件状态的文件
   + -ctime n  查找系统中最后n*24小时被改变文件状态的文件
   + -mmin n   查找系统中最后n分钟被改变文件数据的文件
   + -mtime n  查找系统中最后n*24小时被改变文件数据的文件

5. 参考
   + [[https://app.yinxiang.com/shard/s52/nl/11551545/e485b74c-eae1-4235-b3be-856404530043?title=%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4%ef%bc%8819%ef%bc%89%ef%bc%9afind%20%e5%91%bd%e4%bb%a4%e6%a6%82%e8%a7%88%20-%20peida%20-%20%e5%8d%9a%e5%ae%a2%e5%9b%ad][每天一个linux命令之find]]

**** [[https://app.yinxiang.com/shard/s52/nl/11551545/66242b51-a72b-482b-9fa9-b75e5dc14d0b][find -exec]]                                                        :find:

-exec  参数后面跟的是command命令， *它的终止是以;为结束标志的* ，所以
这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所
以前面加反斜杠。

{}   花括号代表前面find查找出来的文件名。

使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，
很方便的。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。
大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令
删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。 exec选
项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最
后是一个分号。为了使用exec选项，必须要同时使用print选项。

当使用诸如mv或rm命令时，可以使用-exec选项的安全模式。它将在对每个匹配
到的文件进行操作之前提示你。  *-ok*

1. 实例1：ls -l命令放在find命令的-exec选项中

   #+BEGIN_SRC sh
   find . -type f -exec ls -l {} \;
   #+END_SRC

2. 实例2：在目录中查找更改时间在n日以前的文件并删除它们

   #+BEGIN_SRC sh
   find . -type f -mtime +14 -exec rm {} \;
   #+END_SRC

3. 实例3：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示

   #+BEGIN_SRC sh
   find . -name "*.log" -mtime +5 -ok rm {} \;
   #+END_SRC

4. 实例4：-exec中使用grep命令

   #+BEGIN_SRC sh
   find /etc -name "passwd*" -exec grep "root" {} \;
   #+END_SRC

5. 实例5：查找文件移动到指定目录

   #+BEGIN_SRC sh
   find . -name "*.log" -exec mv {} .. \;
   #+END_SRC

6. 实例6：用exec选项执行cp命令

   #+BEGIN_SRC sh
   find . -name "*.log" -exec cp {} test3 \;p
   #+END_SRC

*** fdisk                                                           :fdisk:
1. 需要特权: sudo
2. sudo fdisk -l
3. sudo fdisk =/dev/sdc=
4. 选项
   + d 删除分区
   + n 添加分区
   + w 写入并退出
   + q 放弃
   + p 查看分区

** 文件目录
*** cd                                                                 :cd:
+ 改变当前工作目录
+ 语法: cd [目录]
+ 说明: 若没有指定目录，则回到用户的主目录
*** ls                                                                 :ls:
+ 显示指定工作目录中的文件和目录信息
+ 格式: ls [选项] [文件目录列表]
+ 选项
  -a    列出目录中的所有文件，包括以.开头的隐藏文件
  -l    列出文件的详细信息
  -1    一行只输出一个文件
+ 文件类型说明
  +  - 常规文件
  +  d    目录文件
  +  b    块特殊设备
  +  c    字符特殊设备
  +  ...

文件类型名后的字符表示文件的权限，权限由三个字符串组成，这三个字符串分别表
示该文件所有者的权限、组中其他人的权限和系统中其他人的权限。每个字符串又分
别有3个字符组成，依次表示对文件的读(r),写(w)和执行(x)的权限。当用户没有对
应权限时，该权限对应的位置使用短线"-"表示。
用长格式查看目录内容时，每行表示一个文件或目录的信息。每行信息一次是：文件
类型与权限，链接数，文件属主，文件大小，建立或修改时间，名字。
*** mkdir                                                           :mkdir:
+ 创建目录
+ 语法: mkdir [选项] 目录
+ 选项
  +  -m    在建立目录时按模式指定目录全乡
  +  -p    系统自动创建目录中不存在的路径名
*** rmdir                                                           :rmdir:
+ 删除目录
+ 语法: rmdir [选项] 目录
+ 选项
  +  -p    在删除指定目录后若父目录为空，则同时删除父目录。
*** mv                                                                 :mv:
+ 移动文件或重命名文件
+ 语法:
  - mv [选项] 源文件 目标文件
  - mv [选项] 源目录 目标目录
  - mv [选项] 文件列表 目录
+ 选项
  -i    交互模式
*** cat                                                               :cat:
+ 显示文本文件内容
+ 格式: cat [选项] [文件列表]
+ 说明: cat命令还可以用于将两个文件连接到一起，并将结果放到另外一个文
  件中（重定向）

*** touch                                                           :touch:
**** touch --help
+ 用法：touch [选项]... 文件...
+ 功能: Update the access and modification times of each FILE to the current
  time.
+ FILE arg
  + A FILE argument that does not exist is *created empty*, unless -c
    or -h is supplied.
  + A FILE argument string of *-* is handled specially and causes
    touch to change the times of *the file associated with standard
    output*.
+ options
  + -a			只更改访问时间
  + -c, --no-create	不创建任何文件
  + -d, --date=字符串	使用指定字符串表示时间而非当前时间
  + -f			(忽略)
  + -m			只更改修改时间
  + -r, --reference=FILE   use this file's times instead of current time
  + -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time
  +     --time=WORD        change the specified time:
                           WORD is access, atime, or use: equivalent to -a
                           WORD is modify or mtime: equivalent to -m

请注意，-d 和-t 选项可接受不同的时间/日期格式。

*** echo                                                             :echo:
1. 引号
   #+begin_src sh :exports both
   echo hello world
   #+end_src

   #+results:
   : hello world

   #+begin_src sh :exports both
   echo "hello world"
   #+end_src

   #+results:
   : hello world

   #+begin_src sh :exports both
   echo 'hello world'
   #+end_src

   #+results:
   : hello world

   #+begin_src sh :exports both
   echo "hello bash's world"
   #+end_src

   #+results:
   : hello bash's world

2. 命令续行
   #+begin_src sh :exports both
   echo hello \
   world
   #+end_src

   #+results:
   : hello world

3. 换行

   #+begin_src sh :exports both
   echo "hello
   world"
   #+end_src

   #+results:
   | hello |
   | world |

   #+begin_src sh :exports both
   echo "hello \
   world"
   #+end_src

   #+results:
   : hello world

   #+begin_src sh :exports both
   echo  "hello"
   echo "world"
   #+end_src

   #+results:
   | hello |
   | world |

4. 行尾默认增加执行与 -n 选项

   #+begin_src sh :exports both
   echo -n "hello"
   echo "world"
   #+end_src

   #+results:
   : helloworld

   #+begin_src sh :exports code
     echo "hello\nworld"
     # hello\nworld
   #+end_src


   注：babel和terminal执行的结果不一样,因为org-babel默认的是sh,而ubuntu
   terminal使用的bash, 两者在使用上存在一定差异

5. -e 选项
   #+begin_src sh :exports both
   echo -e "hello\nworld"
   #+end_src

   #+results:
   | hello |
   | world |

*** cp                                                                 :cp:
+ 复制文件或目录
+ 语法: cp [选项] 源文件或目录 目标文件或目录
+ 选项
  -a    复制目录时保留链接、文件属性，并递归拷贝目录，相当于dpr组合
*** ln                                                                 :ln:

+ 在文件间创建链接
+ 语法: ln [选项] 源文件或目录 [链接名]
+ 选项
  +  -d    硬链接
  +  -s    符号链接

链接有两种，一种是硬链接(hard link),另一种是符号链接(symbolic link)。硬链
接的意思是一个文件可以有多个名称。而符号链接是产生一个特殊的文件，该文件的
内容指向另外一个文件的位置。建立硬链接时，链接文件和被链接文件必须位于同一
文件系统中，并且不能建立指向目录的硬链接。默认情况下，ln产生硬链接。

ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个
位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时
，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只
要在某个固定的目录，放上该文件，然后在 其它的目录下用 *ln* 命令链接
（link）它就可以，不必重复的占用磁盘空间。

**** 命令格式
ln [参数][源文件或目录][目标文件或目录]
**** 命令功能
Linux文件系统中，有所谓的链接(link)，我们可以将其视为 *档案的别名*,而
链接又可分为两种 :
+ *硬链接* (hard link): 一个档案可以有多个名称
  1. 硬链接，以文件副本的形式存在,但不占用实际空间
  2. 不允许给目录创建硬链接
  3. 硬链接只有在同一个文件系统中才能创建
+ *软链接* (symbolic link): 产生一个特殊的档案，该档案的内容是指向另一
  个档案的位置
  1. 以路径的形式存在。类似于Windows操作系统中的快捷方式
  2. 可以 跨文件系统 ，硬链接不可以
  3. 可以对一个不存在的文件名进行链接
  4. 可以 *对目录进行链接*
     - *目录只能创建软链接*
     - *目录创建链接必须用绝对路径* ，相对路径创建会不成功，会提示：符
       号连接的层数过多 这样的错误

注: *硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统*

第一， *ln命令会保持每一处链接文件的同步性* ，也就是说，不论你改动
了哪一处，其它的文件都会发生相同的变化；

第二，软链接就是 *ln –s 源文件 目标文件* ，它只会在你选定的位置上生成
一个文件的镜像，不会占用磁盘空间，硬链接 *ln 源文件 目标文件* ，没有参
数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链
接还是硬链接，文件都保持同步变化。

ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最
后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录
复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是
一个已存在的目录，则会出现错误信息。
**** 命令参数
|----+--------------------------------------|
| -b | 删除，覆盖以前建立的链接             |
| -d | 允许超级用户制作目录的硬链接         |
| -f | 强制执行                             |
| -i | 交互模式，文件存在则提示用户是否覆盖 |
| -n | 把符号链接视为一般目录               |
| -s | 软链接(符号链接)                     |
| -v | 显示详细的处理过程                   |
|----+--------------------------------------|

**** 删除与重建
1. 源文件被删除后，并没有影响硬链接文件；软链接文件在centos系统下不断
   的闪烁，提示源文件已经不存在
2. 重建源文件后，软链接不在闪烁提示，说明已经链接成功，找到了链 接文件
   系统；重建后，硬链接文件并没有受到源文件影响，硬链接文件的内容还是
   保留了删除前源文件的内容，说明硬链接已经失效

*** comm                                                             :comm:
+ 比较有序文件
+ 语法: comm [-123]  file1 file2
*** diff                                                             :diff:
+ 文件内容比较
+ 语法: diff [选项] file1 file2
*** grep                                                             :grep:
+ 查找文件内容
+ 语法: grep [选项] [匹配模式] [文件列表]

grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配
的行打印出来。

grep全称是global regular expression print，表示全局正则表达式版本，它
的使用权限是所有用户。

grep的工作方式是它在一个或多个文件中搜索字符串模板。如果模板包括空格，
则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，
不影响原文件内容。

grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果
模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，
则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。

1. 格式：

   grep [option] pattern file

2. 功能：

   用于过滤/搜索的特定字符，可使用正则表达式能多种命令配合使用。

3. 参数
   + -a   --text     不要忽略二进制的数据。
   + -a<显示行数>   --after-context=<显示行数>     除了显示符合范本样式的那一列之外，并显示该行之后的内容。
   + -b   --byte-offset     在显示符合样式的那一行之前，标示出该行第一个字符的编号。
   + -b<显示行数>   --before-context=<显示行数>     除了显示符合样式的那一行之外，并显示该行之前的内容。
   + -c    --count     计算符合样式的列数。
   + -c<显示行数>    --context=<显示行数>或-<显示行数>     除了显示符合样式的那一行之外，并显示该行之前后的内容。
   + -d <动作>      --directories=<动作>     当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。
   + -e<范本样式>  --regexp=<范本样式>     指定字符串做为查找文件内容的样式。
   + -e      --extended-regexp     将样式为延伸的普通表示法来使用。
   + -f<规则文件>  --file=<规则文件>     指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。
   + -f   --fixed-regexp     将样式视为固定字符串的列表。
   + -g   --basic-regexp     将样式视为普通的表示法来使用。
   + -h   --no-filename     在显示符合样式的那一行之前，不标示该行所属的文件名称。
   + -h   --with-filename     在显示符合样式的那一行之前，表示该行所属的文件名称。
   + -i    --ignore-case     忽略字符大小写的差别。
   + -l    --file-with-matches     列出文件内容符合指定的样式的文件名称。
   + -l   --files-without-match     列出文件内容不符合指定的样式的文件名称。
   + -n   --line-number     在显示符合样式的那一行之前，标示出该行的列数编号。
   + -q   --quiet或--silent     不显示任何信息。
   + -r   --recursive     此参数的效果和指定“-d recurse”参数相同。
   + -s   --no-messages     不显示错误信息。
   + -v   --revert-match     显示不包含匹配文本的所有行。
   + -v   --version     显示版本信息。
   + -w   --word-regexp     只显示全字符合的列。
   + -x    --line-regexp     只显示全列符合的列。
   + -y     此参数的效果和指定“-i”参数相同。

4. 规则表达式
   + ^    锚定行的开始 如：'^grep'匹配所有以grep开头的行。
   + $    锚定行的结束 如：'grep$'匹配所有以grep结尾的行。
   + .    匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。
   + *    匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。
   + .*     一起用代表任意字符。
   + []     匹配一个指定范围内的字符，如'[gg]rep'匹配grep和grep。
   + [^]    匹配一个不在指定范围内的字符，如：'[^a-fh-z]rep'匹配不包含a-r和t-z的一个字母开头，紧跟rep的行。
   + =\(..\)=    标记匹配字符，如'=\(love\)='，love被标记为1。
   + =\<=        锚定单词的开始，如:'=\<grep='匹配包含以grep开头的单词的行。
   + =\>=        锚定单词的结束，如'=grep\>='匹配包含以grep结尾的单词的行。
   + =x\{m\}=    重复字符x，m次，如：'=0\{5\}='匹配包含5个o的行。
   + =x\{m,\}=    重复字符x,至少m次，如：'=o\{5,\}='匹配至少有5个o的行。
   + =x\{m,n\}=    重复字符x，至少m次，不多于n次，如：'=o\{5,10\}='匹配5--10个o的行。
   + =\w=      匹配文字和数字字符，也就是[a-za-z0-9]，如：'=g\w*p='匹配以g后跟零个或多个文字或数字字符，然后是p。
   + =\w=       =\w= 的反置形式，匹配一个或多个非单词字符，如点号句号等。
   + =\b=       单词锁定符，如: '=\bgrep\b='只匹配grep。

5. posix

   为了在不同国家的字符编码中保持一至，*posix(the portable operating
   system interface)* 增加了特殊的字符类，如[:alnum:]是[a-za-z0-9]的另
   一个写法。要把它们放到[]号内才能成为正则表达式，如[a- za-z0-9]或
   =[[:alnum:]]= 。在linux下的grep除fgrep外，都支持posix的字符类。

   + [:alnum:]      文字数字字符
   + [:alpha:]      文字字符
   + [:digit:]      数字字符
   + [:graph:]      非空字符（非空格、控制字符）
   + [:lower:]      小写字符
   + [:cntrl:]      控制字符
   + [:print:]      非空字符（包括空格）
   + [:punct:]      标点符号
   + [:space:]      所有空白字符（新行，空格，制表符）
   + [:upper:]      大写字符
   + [:xdigit:]     十六进制数字（0-9，a-f，a-f）


*** sort                                                             :sort:
+ 对文件中的各行进行排序
+ 语法: sort [选项] 文件
+ 说明: sort命令对指定文件中的所有行进行排序，并将结果显示在标准输出上。
  如果不指定输入文件或者使用“-”，则表示排序的内容来自标准输入。

*** 分割合并文件
+ http://os.51cto.com/art/201104/255359.htm
**** 分割
在Linux下用 *split* 进行文件分割.

1. 文本：指定分割后文件行数

   对与txt文本文件，可以通过指定分割后文件的行数来进行文件分割。
   #+BEGIN_EXAMPLE
     split -l 300 large_file.txt new_file_prefix
   #+END_EXAMPLE

2. 二文件进制：指定分割后文件大小

   对于二进制文件，如可执行文件，pdf，iso等，则不能通过文件行数来进行
   文件分割，此时我们可以指定分割大小来分隔文件。
      #+BEGIN_EXAMPLE
   split -b 10m large_file.bin new_file_prefix
   #+END_EXAMPLE

**** 合并
在Linux下用cat进行文件合并：cat small_files* > large_file

*** zcat                                                             :zcat:
**** zcat --help
+ Usage: /bin/zcat [OPTION]... [FILE]...
+ 功能: Uncompress FILEs to standard output.
+ Options:
  + -f, --force       force; read compressed data even from a terminal
  + -l, --list        list compressed file contents
  + -q, --quiet       suppress all warnings
  + -r, --recursive   operate recursively on directories
  + -S, --suffix=SUF  use suffix SUF on compressed files
  + -t, --test        test compressed file integrity
  + -v, --verbose     verbose mode
  +     --help        display this help and exit
  +     --version     display version information and
+ Note: With no FILE, or when FILE is -, read standard input.

*** mv 无法进行跨设备移动                                              :mv:
#+begin_latex
\begin{minted}{bash}
mv /media/ben/system/test/ ~/audio/
\end{minted}
#+end_latex

mv目录名不能加结尾的斜杠
mv的source永远不会以/结尾，要么是文件名，要么是目录名。

** 磁盘管理
*** du: 查看磁盘文件大小                                                                 :du:

du命令适合用来 /查看文件大小/ 等,要比ls命令强大的多

linux *du* 命令也是查看使用空间的，但是与df命令不同的是linux du命令是
对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的.

1. 命令格式

   *du [选项][文件]*

2. 命令功能：

   *显示每个文件和目录的磁盘使用空间*

3. 命令参数：

   1) -a, -all

      显示目录中个别文件的大小

   2) -b, -bytes

      显示目录或文件大小时，以byte为单位

   3) -c, --total

      除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和

   4) -k, --kilobytes

      以kb(1024bytes)为单位输出。

   5) -m, --megabytes

      以mb为单位输出

   6) /-s/, --summarize

      仅显示总计，只列出最后加总的值。

   7) /-h/, --human-readable

      以k，m，g为单位，提高信息的可读性。

   8) -x, --one-file-xystem

      以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。

   9) -l <符号链接>, --dereference <符号链接>

      显示选项中所指定符号链接的源文件大小。

   10) -S, --separate-dirs

       显示个别目录的大小时，并不含其子目录的大小。

   11) -x<文件>, --exclude-from=<文件>

       在<文件>指定目录或文件。

   12) --exclude=<目录, 文件>

       略过指定的目录或文件。

   13) -d, --dereference-args

       显示指定符号链接的源文件大小。

   14) -h, --si

       与-h参数相同，但是k，m，g是以1000为换算单位。

   15) -l, --count-links

       重复计算硬件链接的文件。

4. 使用实例：

   1) 实例1：显示目录或者文件所占空间 命令：du

      说明：只显示当前目录下面的子目录的目录大小和当前目录的总的大小，

      #+BEGIN_SRC sh :results output
      du ~/Picture
      #+END_SRC

      #+RESULTS:
      #+begin_example
      312	/home/ben/Picture/Wallpapers
      1428	/home/ben/Picture/Weibo/折纸之收纳盒_6_files
      3812	/home/ben/Picture/Weibo
      4932	/home/ben/Picture/WALLE/others
      9828	/home/ben/Picture/WALLE/walle
      16460	/home/ben/Picture/WALLE/W&E
      31224	/home/ben/Picture/WALLE
      6848	/home/ben/Picture/Guita/入门
      8012	/home/ben/Picture/Guita
      5148	/home/ben/Picture/tagerill
      71812	/home/ben/Picture
      #+end_example


      最下面的为当前目录的总大小

   2) 实例2：显示指定文件所占空间

      #+BEGIN_SRC sh
      du ~/.xinitrc
      #+END_SRC

   3) 实例3：查看指定目录的所占空间

      #+BEGIN_SRC sh
      du -sc ~/.ros
      #+END_SRC

      #+RESULTS:
      | 6356 | /home/ben/.ros |
      | 6356 | 总用量         |


   4) 实例4：显示多个文件所占空间  命令：

      #+BEGIN_SRC sh
      du log30.tar.gz log31.tar.gz
      #+END_SRC

   5) 实例5：只显示总和的大小

      #+BEGIN_SRC sh
      du -s
      #+END_SRC

   6) 实例6：方便阅读的格式显示 *注：默认单位为字节*

      #+BEGIN_SRC sh
      du -h test*
      #+END_SRC

   7) 实例7：文件和目录都显示  命令： 输出：

   8) 实例8：显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总
      和
      #+BEGIN_SRC sh
      du -c log30.tar.gz log31.tar.gz
      #+END_SRC

      说明：加上-c选项后，du不仅显示两个目录各自占用磁盘空间的大小，还
      在最后一行统计它们的总和。

   9) 实例9：按照空间大小排序 命令：

      #+BEGIN_SRC sh
      du | sort -nr | more
      #+END_SRC

   10) 实例10：输出当前目录下各个子目录所使用的空间  命令：

       #+BEGIN_SRC sh
       du -h --max-depth=1
       #+END_SRC

*** TODO df：
- State "TODO"       from ""           [2015-12-14 一 19:12]

*** TODO fdisk
- State "TODO"       from ""           [2015-12-14 一 19:11]

*** TODO mkfs
- State "TODO"       from ""           [2015-12-14 一 19:12]


**** mkfs -h
Usage: mkfs [options] [-t type fs-options] device [size]

Options:
 -t, --type=TYPE  file system type, when undefined ext2 is used
     fs-options   parameters to real file system builder
     device       path to a device
     size         number of blocks on the device
 -V, --verbose    explain what is done
                  defining -V more than once will cause a dry-run
 -V, --version    output version information and exit
                  -V as version must be only option
 -h, --help       display this help and exit

**** mkfs.<TAB>

mkfs          mkfs.ext2     mkfs.ext4dev  mkfs.msdos
mkfs.bfs      mkfs.ext3     mkfs.fat      mkfs.ntfs
mkfs.cramfs   mkfs.ext4     mkfs.minix    mkfs.vfat


*** TODO dd                                                           :dd:
- State "TODO"       from ""           [2015-12-14 一 19:12]


**** 刻录镜像文件到U盘

the dd command

#+BEGIN_EXAMPLE
dd if=YOUR IMAGE.iso of=/dev/sdx bs=4M
#+END_EXAMPLE

where
1) if= is the path to the .iso file
2) of= is your flash device.

_Make sure to use /dev/sdx and not /dev/sdx1_. You will need a flash
memory device large enough to accommodate the image.

**** reference

+ [[http://www.zhihu.com/question/20414643][知乎：在linux 下刻录系统镜像到U盘中做 Live CD，那些工具比较方便，具体该怎么做？]]
** 系统管理
*** ps                                                                 :ps:
1. 功能： *process status*, 列出当前进程的快照，即执行ps命令的那个时刻
   的进程。
   + 静态，如果想要动态显示进程，则需使用 *top* 命令

2. linux进程状态
   + 运行 r(runnable)
   + 中断 s(sleeping)
   + 不可中断 d(uninterruptible sleep)
   + 僵死 z(defunct)
   + 停止t(stopped)

3. 格式: ps [参数]

4. 参数
   + a 显示所有进程
   + -a 显示同一终端下的所有进程
   + -a 显示所有进程
   + c 显示进程真实名称
   + -n 反向选择
   + -e 同-a
   + e 显示环境变量
   + f 显示程序之间的关系
   + -h 显示树状结构
   + r 显示当前终端进程
   + t 显示当前终端的所有程序
   + u 指定用户的所有进程
   + -au 详细

   #+header: :exports both
   #+header: :results output
   #+begin_src sh
   ps -ef | grep emacs
   #+end_src

   #+results:
   : ben       3662  2842  1 13:20 pts/0    00:01:33 emacs
   : ben       3889  3662  0 13:20 pts/4    00:00:00 bash /home/ben/.ckws/install/share/emacs/site-lisp/poll-rostopic 8
   : ben       3893  3662  0 13:20 pts/15   00:00:00 bash /home/ben/.ckws/install/share/emacs/site-lisp/poll-rosnode 8
   : ben       4614  3662  0 13:21 ?        00:00:08 /home/ben/.emacs.d/elpa/pdf-tools-20150401.1031/epdfinfo
   : ben      11322 11320  0 15:20 ?        00:00:00 grep emacs
 :ps:
*** shutdown                                                     :shutdown:
+ 关机或重启
+ 语法: shutdown [选项] [时间] [警告信息]
+ 选项
  +  -k    不真正关机，而是发出警告信息
  +  -r    关机后立即重启
  +  -h    关机后不重启
  +  -c    取消一个已经运行的shutdown
+ 说明:   关机命令需要root权限
+ halt    # showdown -h
+ reboot  # 重启

*** apt-get                                                           :apt:
|----------------------------------+------------------------|
| apt-cache search                 | package搜索包          |
| apt-cache show                   | 获取包信息             |
| sudo apt-get install             | 安装包                 |
| sudo apt-get remove              | 删除包                 |
| sudo apt-get remove --purge      | 删除包及配置文件       |
| sudo apt-get auto remove --purge | 删除包及配置文件及依赖 |
| sudo apt-get update              | 更新源                 |
| sudo apt-get upgrade             | 更新已安装的包         |
| apt-cache depends                | 了解包依赖             |
| apt-get source                   | 下载包源代码           |
| sudo  apt-get clean              | 清理存档               |
| sudo apt-get autoclean           | 只清理过时的包         |
| sudo apt-get check               | 检查是否有坏的依赖     |
|----------------------------------+------------------------|

*** dpkg                                                             :dpkg:
|-------------------+------------------------------------|
| dpkg -i <pkg.deb> | 安装debian包裹文件                 |
| dpkg -c <pkg.deb> | 列出包裹内容                       |
| dpkg -i <pkg.deb> | 提取包裹信息                       |
| dpkg -r <pkg>     | 移除已安装包裹                     |
| dpkg -p <pkg>     | 完全清除一个已安装包裹             |
|                   | remove只删除可执行文件和数据,purge |
|                   | 还删除所有的配置文件               |
| dpkg -l <pkg>     | 列出已安装包的文件清单             |
|-------------------+------------------------------------|

*** patch                                                           :patch:
http://linux-wiki.cn/wiki/zh-hans/%e8%a1%a5%e4%b8%81(patch)%e7%9a%84%e5%88%b6%e4%bd%9c%e4%b8%8e%e5%ba%94%e7%94%a8
http://www.lampweb.org/linux/3/18.html

用到的两个命令是diff和patch。

1. diff
   1) 功能：diff可以比较两个东西，并可同时记录下二者的区别。
   2) 语法：*diff 【选项】 源文件（夹） 目的文件（夹）*
   3) 选项：
      + -r  递归。设置后diff会将两个不同版本源代码目录中的所有对应文件全
        部都进行一次比较，包括子目录文件。
      + -n  选项确保补丁文件将正确地处理已经创建或删除文件的情况。
      + -u  输出每个修改前后的3行，也可以用-u5等指定输出更多上下文。
      + -e, -b, -w, -b, --strip-trailing-cr  忽略各种空白，可参见文档，
        按需选用。

2. patch
   1) 功能：patch的作用则是将diff记录的结果（即补丁）应用到相应文件（夹）上。

   2) 语法： *patch -pnum <patchfile>*

   3) 选项
      + -p num  忽略几层文件夹

3. 例子
   1) 对单个文件打补丁
      #+begin_example
        # 产生补丁
        diff -un from-file to-file >to-file.patch

        # 打补丁
        patch -p0 < to-file.patch

        # 取消补丁
        patch -re -p0 < to-file.patch
        对整个文件夹打补丁的情况：

        # 产生补丁
        diff -unr  from-docu  to-docu  >to-docu.patch

        # 打补丁
        cd to-docu
        patch -p1 < to-docu.patch

        # 取消补丁
        patch -r -p1 <to-docu.patch
     #+end_example

   2) 对文件夹打补丁

   3) 注
      + 另外，使用版本控制工具时，可以直接用svn diff或git diff生成补丁
        文件。

      + 值得一提的是，由于应用补丁时的目标代码和生成补丁时的代码未必相
        同，打补丁操作可能失败。补丁失败的文件会以.rej结尾，下面命令可
        以找出所有rej文件： find . -name '*.rej'

*** export                                                         :export:
1. 功能说明：设置或显示环境变量

2. 语法：
   + export [-fnp][变量名称]=[变量设置值]

3. 补充说明：
   + 在shell中执行程序时，shell会提供一组环境变量。
   + export可新增，修改或删除环境变量，供后续执行的程序使用。
   + export的效力仅及于该此登陆操作。

4. 参数：
   + -f 　代表[变量名称]中为函数名称。
   + -n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的
     执行环境中。
   + -p 　列出所有的shell赋予程序的环境变量。

*** info                                                             :info:
*** man                                                               :man:
*** whereis                                                       :whereis:
*** xargs                                                           :xargs:
- state "todo"       from ""           [2015-04-19 日 21:36]
xargs是一条unix和类unix操作系统的常用命令。它的作用是将参数列表转换成
小块分段传递给其他命令，以避免参数列表过长的问题。

*** 字体相关
fc-list
fc-list :lang=zh
fc-cache -fv

*** 前后台
Linux支持前后台任务的切换
+ command&   让进程在后台运行
+ jobs       查看后台运行的进程
+ fg %n      让后台运行的进程n到前台来
+ bg %n      让进程n到后台去
+ kill %n    杀死job
+ C-z        将一个正在前台执行的命令放到后台，并且暂停

*** jobs control
1. jobs    # list all bg jobs
2. fg n    # bring the job with PID n to foreground
3. fg %str   # fg the job with str-matched name
4. fg %?str    # question mark match any part
5. %n    # fg PID n
6. C-z    # suspending a job
7. bg    # move the fg job to bg, C-z first
** 归档解压
*** overview                                                          :tar:
|----------------+-----------------------|
| *.tar          | tar -xvf [filename]   |
| *.gz           | gzip -d [filename]    |
|                | gunzip [filename]     |
| *.tar.gz *.tgz | tar -zxvf [filename]  |
| *.bz2          | bzip2 d [filename]    |
|                | bunzip2 [filename]    |
| *.tar.bz2      | tar -xjvf [filename]  |
| *.Z            | uncompress [filename] |
| *.tar.Z        | tar -xZf [filename]   |
| *.rar          | unrar [filename]      |
| *.zip          | unzip r [filename]    |
|----------------+-----------------------|

http://blog.csdn.net/wangjunjun2008/article/details/21982843

*** tar                                                               :tar:
建立档案文件

1. 语法: *tar [option] tarfile filename*
2. 说明: 文件名必须紧跟在-f参数后,且-f作为参数的最后一项;
3. 选项:
   + -c 建立一个新的档案文件;
   + -f 指定档案文件名
   + -r 往归档文件中追加文件
   + -x 从档案文件中提取文件
   + -v,-vv 显示进度信息
   + -t 列出存档文件的信息(不提取)
   + -c 指定文件提取的目录
   + -a 合并多个tar文件
   + --totals 归档完成后,打印总归档字节数
   + --delete 从归档文件中删除指定的文件
   + --exclude 归档时,排除指定样式的文件
   + -j 生成归档文件时,使用bunzip2格式进行压缩
   + -z 生成归档文件时,使用gzip格式进行压缩
   + --lzma 生成归档文件时,使用lzma格式进行压缩
   + -a 生成归档文件时,根据扩展名自动进行压缩
4. 用法
   1) 打tar包,名称为all.tar
      #+begin_example
        $ tar -cvf all.tar *.text
      #+end_example
   2) 追加文件b.doc
      #+begin_example
        $ tar -rvf all.tar b.doc
      #+end_example
   3) 列出归档文件中的内容
      #+begin_example
        $ tar -tvf all.tar
      #+end_example
   4) 提取归档文件中的全部文件
      #+begin_example
        $ tar -xvf all.tar
        $ tar -xvf all.tar -c /opt/app/tool_dir
      #+end_example
   5) 提取归档文件中的指定文件
      #+begin_example
        $ tar -xvf all.tar file_one file_tw
      #+end_example
   6) 合并两个tar文件
      #+begin_example
        $ tar -af file_one.tar file_two.ta
      #+end_example
   7) 删除指定的文件
      #+begin_example
        $ tar -f all.tar --delete file_one file_tw
      #+end_example
   8) 归档时,排除日志文件
      #+begin_example
        $ tar -cf all.tar * --exclude ”*.log
      #+end_example

*** gzip/gunzip                                                      :gzip:
进行压缩/解压缩

1. 语法:
   + gzip [options] file
   + gunzip [options] file
2. 说明:
   + gzip只能压缩单个文件,如果指定多个文件,则会生成多个单独的压缩文件;
   + gzip会在生成压缩文件后,删除源文件!!!!
   + gunzip会在解压缩完成后,删除源文件!!!
3. 选项
   1) -l,--list 列出压缩文件的属性信息
   2) --fast 指定最低压缩比
   3) --best 指定最高压缩比
   4) -n 指定压缩比(n为数字,且1<=n<=9)
   5) -v 显示进度信息

*** bzip2/bunzip2                                                   :bzip2:
进行压缩/解压缩

1. 语法:
   + *bzip2 file*
   + *pbunzip2 file*
2. 说明: bzip2通常能生成比gzip压缩比更高的文件;默认bzip2会删除源文件,
   可使用-k参数保留源文件;
3. 选项:
   1) -k 保留源文件
   2) -n 指定压缩比(n为数字,且1<=n<=9);

*** zip/unzip                                                         :zip:
进行压缩/解压缩

1. 语法: zip [options] file file dirs
2. 说明: zip压缩/解压缩后,不会删除源文件;
3. 选项:
   1) -r 递归;压缩目录时使用;
   2) -l 列出压缩文件内容
   3) -d 从压缩文件中删除指定文件
   4) -u 更新压缩文件的内容
4. 用法
   1) 压缩文件
      #+begin_example
        $ zip all.zip file
        $ zip all.zip file_one file_two
        $ zip -r all.zip dir_name
      #+end_example
   2) 更新压缩文件
      #+begin_example
        $ zip all.zip -u log.text
      #+end_example
   3) 删除指定的内容
      #+begin_example
        $ zip -d all.zip log.text
      #+end_example
   4) 解压文件
      #+begin_example
        $ unzip all.zip
      #+end_example
   5) 列出压缩文件内容
      #+begin_example
        $ unzip -l all.zip;
      #+end_example

** 网络相关
** 性能优化
*** free                                                      :free:memory:
**** man                                                             :man:

1. NAME: free - _Display amount of free and used memory in the system_

2. SYNOPSIS:  *free [options]*

3. DESCRIPTION

   free  displays the total amount of free and used physical and swap
   memory in the system, as well as the buffers used by the kernel.
   The shared memory column represents either the MemShared value (2.4
   series kernels) or the Shmem value (2.6 series kernels and later)
   taken from the _/proc/meminfo_ file. The value is zero if none of the
   entries is exported by the kernel.

4. OPTIONS

   - -b, --bytes

     Display the amount of memory in bytes.

   - -k, --kilo

     Display the amount of memory in kilobytes.  This is the default.

   - -m, --mega

      Display the amount of memory in megabytes.

   - -g, --giga

     Display the amount of memory in gigabytes.

   - --tera Display the amount of memory in terabytes.

   - -h, --human

     Show all output fields automatically scaled to shortest three
     digit unit and display the units of print out.  Following units
     are used.
     - B = bytes
     - K = kilos
     - M = megas
     - G = gigas
     - T = teras

      If unit is missing, and you have petabyte of RAM or swap, the
      number is in terabytes and columns might not be aligned with
      header.

   - -c, --count count

     Display the result count times.  Requires the -s option.

   - -l, --lohi

**** example

#+BEGIN_SRC sh :results output
free -h
#+END_SRC

#+RESULTS:
:              total       used       free     shared    buffers     cached
: Mem:          3.7G       2.0G       1.6G       4.7M       377M       689M
: -/+ buffers/cache:       1.0G       2.7G
: Swap:         3.8G       1.1G       2.7G

** 权限设置
*** chmod                                                           :chmod:
+ 改变文件或目录权限
+ 语法: chmod [who] [+/-/=] [mode] 文件名
+ 选项who
  +  -u    user, 即文件和目录的所有者
  +  -g    group,与文件属主有相同祖id的用户
  +  -o    others, 其他用户
  +  -a    all,所有用户
+ 选项操作符号
  + 添加权限
  + 取消某个权限
  =    赋予给定权限，并取消其他权限
+ 选项权限
  +  r    可读
  +  w    可写
  +  x    可执行

 文件和目录的权限还可以用八进制数字模式表示， 0表示没有权限，1表示可执
  行权限， 2表示可写权限，4表示可读权限。

*** chown                                                           :chown:
+ 改变文件或目录的属主和属组

** 其它命令
*** tr                                                                 :tr:
1. 功能： 转换或删除字符, 从标准输入设备读取数据，经过字符串转译后，输
   出到标准输出设备。

   可以将 tr 看作为 sed 的（极其）简化的变体：它可以用一个字符来替换另
   一个字符，或者可以完全除去一些字符。您也可以用它来除去重复字符。这
   就是所有 tr 所能够做的。

2. 格式：tr [option] set1 [set2]

3. 选项
   + -c或--complerment   取代所有不属于第一字符集的字符。
   + -d或--delete   删除所有属于第一字符集的字符。
   + -s或--squeeze-repeats   把连续重复的字符以单独一个字符表示。
   + -t或--truncate-set1   这个比较难理解，man上面的解释是：first
     truncate set1 to lengthof set2,经过我的实践发现，将set1的字符依次
     替换成set2中的字符，如果set1中的字符数目超过set2，那么set1多出的
     字符忽略。如果没有-t，那么多出的字符都替换成set2的最后一个字符。

4. 字符范围：指定字符串1或字符串2的内容时，只能使用单字符或字符串范围
   或列表。
   + [a-z] a-z内的字符组成的字符串。
   + [a-z] a-z内的字符组成的字符串。
   + [0-9] 数字串。
   + \textbackslash{}octal 一个三位的八进制数，对应有效的ascii字符。
   + [o*n] 表示字符o重复出现指定次数n。因此[o*2]匹配oo的字符串。
5. 例程
   1) 压缩文件中的重复字符
      #+header: :exports both
      #+begin_src sh
      echo abbccd | tr -s [a-z]
      #+end_src

      #+results:
      : abcd

      注：
      + [a-z]指定字符集合，而非字符串

   2) 去掉多余空行
      #+header: :exports both
      #+header: :results output
      #+begin_src sh
        echo -e "abc\n\nxyz"
        echo
        echo -e "abc\n\n\nxyz" | tr -s ["\n"]  # 或 "[\12]"
      #+end_src

      #+results:
      : abc
      :
      : xyz
      :
      : abc
      : xyz

   3) 删除文件中的^m，并代之以换行
      在linux下，不可避免的会用vim打开一些windows下编辑过的文本文件。
      我们会发现文件的每行结尾都会有一个^m符号，这是因为 dos下的编辑器
      和linux编辑器对文件行末的回车符处理不一致
      + window: \textbackslash{}r\textbackslash{}n
      + linux: \textbackslash{}n

      #+begin_example
      tr -s "[\r]" "[\n]" < input
      #+end_example

   4) 替换冒号
      #+begin_example
      tr -s "[:]" "[,]" < input
      #+end_example

   5) 显示path
      #+header: :exports both
      #+header: :results output
      #+begin_src sh
      echo $path | tr ":" "\n"
      #+end_src

      #+results:
      #+begin_example
      /home/ben/program/phantomjs/bin
      /usr/local/qt-5.4.1/bin
      /usr/home/ben/bin
      /home/ben/.ckws/devel/bin
      /opt/ros/indigo/bin
      /usr/local/texlive/2014/bin/i386-linux
      /home/ben/bin
      /usr/local/sbin
      /usr/local/bin
      /usr/sbin
      /usr/bin
      /sbin
      /bin
      /usr/games
      /usr/local/games
      /usr/local/libexec/emacs/24.4/i686-pc-linux-gnu
      #+end_example

   6) 替换字符集外的所有字符为指定字符
      #+header: :exports both
      #+header: :results output
      #+begin_src sh
      echo -n "abcdefg" | tr -c [ag] "o"
      #+end_src

      #+results:
      : aooooog

   7) 删除指定字符集的所有字符
      #+header: :exports both
      #+header: :results output
      #+begin_src sh
        echo  "foobar" | tr -d "for"
        echo  "foorbar" | tr -d for
        echo  "foorbar" | tr -d [for]
      #+end_src

      #+results:
      : ba
      : ba
      : ba

   8) 转换大小写
      #+header: :exports both
      #+header: :results output
      #+begin_src sh
        echo "abcxyz" | tr a-z a-z
        echo "abcxyz" | tr [a-z] [a-z]
      #+end_src

      #+results:
      : abcxyz
      : abcxyz

   9) 依次替换
      #+header: :exports both
      #+header: :results output
      #+begin_src sh
      echo "foobar" | tr -t fb bf
      #+end_src

      #+results:
      : boofar

** 特殊符号
*** !$
!$是列出并执行你的命令历史里面最近的一条记录，前面加上cd，除非最近的命
令跟目录相关，否则执行不了。

*** wc                                                                 :wc:
+ 统计文件中的字节数、字数和行数。
+ 语法: wx [选项] 文件列表
+ 选项
  +  -c    统计字节数
  +  -l    统计行数
  +  -w    统计字数



*** 复制粘贴技巧（虚拟终端）

记得复制和粘贴技巧！

如果你正在使用鼠标，双击文件名(ls命令列出来的)，来复制它，然后按下鼠标
中键，粘贴文件名到命令行中。

**** 小结
*终端中双击复制中键粘贴*

*** shell cd !$
!$是列出并执行你的命令历史里面最近的一条记录，前面加上cd，除非最近的命
令跟目录相关，否则执行不了。

**** 小结
SHELL特殊符号不用刻意去记。

cd !$ 对我并没有太多用处。

** sed
*** sed入门
**** what
sed（意为流编辑器，源自英语“stream editor”的缩写）是Unix常见的命令行
程序。sed用来把文档或字符串里面的文字经过一系列编辑命令转换为另一种格
式输出。sed通常用来匹配一个或多个正则表达式的文本进行处理。

**** s 匹配与替换
+ *sed 模式 输入文件*
+ *s* 表示替换命令
+ */g* 表示一行上替换所有的匹配
+ sed不会对输入文件的内容进行改变，除非使用重定向
+ 或者使用 *-i* 选项

***** s 命令替换
1. 准备
   #+BEGIN_SRC sh :session sed_session :exports code
     cd /tmp
     > pets.txt
     echo -n "This is my cat," >> pets.txt
     echo  "my cat's name is betty" >> pets.txt
     echo -n "This is my dog," >> pets.txt
     echo "my dog's name is frank" >> pets.txt
     echo -n "This is my fish," >> pets.txt
     echo  "my fish's name is george" >> pets.txt
     echo -n "This is my goat," >> pets.txt
     echo  "my goat's name is adam" >> pets.txt
   #+END_SRC

   #+RESULTS:

   注： org-babel 使用:session参数时要注意命令中的回车可能使执行一直处于
   等待状态。

   #+RESULTS:

   #+BEGIN_SRC sh :exports both :session sed_session :results output
    cat pets.txt
   #+END_SRC

   #+RESULTS:
   : this is my cat,my cat's name is betty
   : This is my dog,my dog's name is frank
   : This is my fish,my fish's name is george
   : This is my goat,my goat's name is adam

2. -s 替换

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed "s/my/your/g" pets.txt
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty
   : This is your dog,your dog's name is frank
   : This is your fish,your fish's name is george
   : This is your goat,your goat's name is adam

3. 写入
   + 重定向
   + -i

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed -i "s/my/your/g" pets.txt
   cat pets.txt
   #+END_SRC

   #+RESULTS:
   :
   : This is your cat,your cat's name is betty
   : This is your dog,your dog's name is frank
   : This is your fish,your fish's name is george
   : This is your goat,your goat's name is adam

4. 行前
   + *^* 表示一行的开头
   + *$* 表示一行的结尾
   + *\<* 表示词首
   + *\>* 表示词尾
   + 以上是正则表达式的最基本的内容

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed "s/^/:/g" pets.txt
   #+END_SRC

   #+RESULTS:
   : :this is your cat,your cat's name is betty
   : :This is your dog,your dog's name is frank
   : :This is your fish,your fish's name is george
   : :This is your goat,your goat's name is adam

   注： 行首#在babel输出可能有问题

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed 's/$/:/g' pets.txt
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty:
   : this is your dog,your dog's name is frank:
   : this is your fish,your fish's name is george:
   : this is your goat,your goat's name is adam:

5. 指定行替换
   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed "3s/your/my/g" pets.txt  # 替换第三行
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty
   : This is your dog,your dog's name is frank
   : This is my fish,my fish's name is george
   : This is your goat,your goat's name is adam

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed "3,6s/your/my/g" pets.txt  # 替换3～6行
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty
   : This is your dog,your dog's name is frank
   : This is my fish,my fish's name is george
   : This is my goat,my goat's name is adam

6. 替换行中的指定匹配项
   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed 's/s/S/1' pets.txt    # 替换匹配的第一项
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty
   : ThiS is your dog,your dog's name is frank
   : ThiS is your fish,your fish's name is george
   : ThiS is your goat,your goat's name is adam

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed "s/s/S/2" pets.txt   # 替换第二项
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty
   : This iS your dog,your dog's name is frank
   : This iS your fish,your fish's name is george
   : This iS your goat,your goat's name is adam

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed 's/s/S/1g' pets.txt    # 替换某一项之后的
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty
   : ThiS iS your dog,your dog'S name iS frank
   : ThiS iS your fiSh,your fiSh'S name iS george
   : ThiS iS your goat,your goat'S name iS adam

***** 多个匹配
+ 使用多个分号将匹配分隔
+ 相当于 *-e* 选项


#+BEGIN_SRC sh :exports both :session sed_session :results output
sed "1s/your/my/g; 2s/name/NAME/g" pets.txt
#+END_SRC

#+RESULTS:
: this is my cat,my cat's name is betty
: This is your dog,your dog's NAME is frank
: This is your fish,your fish's name is george
: This is your goat,your goat's name is adam

#+BEGIN_SRC sh :exports both :session sed_session :results output
sed -e "1s/your/my/g" -e "2s/name/NAME/g" pets.txt
#+END_SRC

#+RESULTS:
: this is my cat,my cat's name is betty
: This is your dog,your dog's NAME is frank
: This is your fish,your fish's name is george
: This is your goat,your goat's name is adam

***** 圆括号匹配，即后向引用
+ [^,] 表示除了,以外的任意字符(正则表达式的基本知识)

#+BEGIN_SRC sh :exports both :session sed_session :results output
sed 's/This is your \([^,]*\),.*is *\(.*\)/\1:\2/g' pets.txt
#+END_SRC

#+RESULTS:
: cat:betty
: dog:frank
: fish:george
: goat:adam

**** 其它命令
+ N
+ a(append)
+ i(insert)
+ c：替换匹配行
+ d: 删除匹配行
+ p: 打印命令

*** TOBECONTINED sed入门                                              :sed:
- State "TOBECONTINED" from "TODO"       [2015-12-06 日 11:09] \\
  了解了Sed的基本用法和正则，深入学习需要有使用的需求
CLOCK: [2015-12-06 日 10:38]--[2015-12-06 日 11:08] =>  0:30
**** reference

+ [[http://www.gnu.org/software/sed/][Homepage]]
+ [[http://www.yiibai.com/sed/][Tutorials]]
+ [[http://www.gnu.org/software/sed/manual/][Manual]]

**** [[https://app.yinxiang.com/shard/s52/nl/11551545/6cbed3d0-87be-4f5b-8a5b-2fd887a946ac/?csrfBusterToken%3DU%253Db04339%253AP%253D%252F%253AE%253D151751b76dd%253AS%253Dac7631de678b37e0893833bb47b6dc2d][Intro]]

sed (stream editor) isn't an interactive text editor. Instead, it is
used to filter text, i.e., it takes text input, performs some
operation (or set of operations) on it, and outputs the modified
text. sed is typically used for extracting part of a file using
pattern matching or substituting multiple occurrences of a string
within a file.

*Sed* 表示 /流编辑器(Stream Editor)/ 的缩写。

这是一个简单但功能强大的工具，分析文本，并无缝地转换它。 SED是在
_1973-1974_ 年由 _贝尔实验室_ 的李E. _McMahon_ 开发。如今，它运行在所
有主要的操作系统。McMahon编写了一个通用的 /面向行的编辑器/ ，它最终成
为sed。sed借用语法和ed编辑许多有用的功能。自成立开始，对 /正则表达式/
有所支持。 _sed接受来自文件以及管道的输入。此外，它也可以接受来自标准
输入的数据流的输入_

sed是自由软件由基金会（ /FSF/ ）维护，它是由GNU/ Linux分发。因此，它通
常被称为GNU sed的。 _对于新手用户，sed语法看起来神秘。但是，一旦熟悉了
它的语法，就可以使用sed的几行脚本解决许多复杂的任务。_

sed典型用途, sed可以有许多不同的方式使用，例如：

- 文本替换
- 选择性打印的文本文件
- 一个就地文本文件的编辑
- 文本文件的非交互式的编辑等等。

**** install & check

1. Linux 发行版本默认安装
2. apt-get
3. [[ftp://ftp.gnu.org/gnu/sed/][source code]]

#+BEGIN_SRC sh :results output :exports both
sed --version
#+END_SRC

#+RESULTS:
#+begin_example
sed (GNU sed) 4.2.2
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Jay Fenlason, Tom Lord, Ken Pizzini,
and Paolo Bonzini.
GNU版sed主页： <http://www.gnu.org/software/sed/>。
使用GNU软件所需帮助文档： <http://www.gnu.org/gethelp/>。
将错误报告通过电子邮件发送到：<bug-sed@gnu.org>.
请务必将单词“sed”放在标题的某处。
#+end_example

**** [[http://www.yiibai.com/sed/sed_workflow.html][工作流程]]

[[/home/ben/Wally/Journal/Figures/scrot/20587gGd.png]]

1. 读取

   sed从输入流(文件，管道，或标准输入)读取，并将其存储在其内部的缓冲模
   式称为缓冲行。

2. 执行

   所有sed命令顺序地对模式缓冲区使用。默认情况下，sed命令都适用于所有
   行(全局)，除非指定行寻址。

3. 显示

   sed发送(修改)的内容到输出数据流。在发送数据后，模式缓冲器是空的。这
   个过程一直重复，直到文件被耗尽。

**** sed --help

用法: sed [选项]... {脚本(如果没有其他脚本)} [输入文件]...

1. -n, --quiet, --silent

   取消自动打印模式空间

2. /-e 脚本, --expression=脚本/

   添加“脚本”到程序的运行列表

3. /-f 脚本文件, --file=脚本文件/

   添加“脚本文件”到程序的运行列表

4. --follow-symlinks

   直接修改文件时跟随软链接

5. -i[SUFFIX], --in-place[=SUFFIX]

   edit files in place (makes backup if SUFFIX supplied)

6. -l N, --line-length=N

   指定“l”命令的换行期望长度

7. --posix

   关闭所有 GNU 扩展

8. -r, --regexp-extended

   在脚本中使用扩展正则表达式

9. -s, --separate

   将输入文件视为各个独立的文件而不是一个长的连续输入

10. -u, --unbuffered

    从输入文件读取最少的数据，更频繁的刷新输出

11. -z, --null-data

    separate lines by NUL characters

12. --help

    打印帮助并退出

13. --version
    输出版本信息并退出

如果没有 -e, --expression, -f 或 --file 选项，那么第一个非选项参数被视为
sed脚本。其他非选项参数被视为输入文件，如果没有输入文件，那么程序将从标准
输入读取数据。

**** [[https://app.yinxiang.com/shard/s52/nl/11551545/d9ac9d7e-5cb9-4c08-8aeb-4a7b738fb7a3/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D15175335524%3AS%3Dfc6c61e88fe18a62fe1fcc29f6b72dd0][基本命令]]

+ d 删除
+ w 写入
+ a 追加
+ c 修改
+ i 插入
+ y 转换
+ l 显示隐藏字符
+ q 退出
+ r 读
+ e 执行外部命令
+ N 操作多行

**** [[https://app.yinxiang.com/shard/s52/nl/11551545/b7e85649-29a4-4e6c-b0a0-b7a8c5a58054/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D1517538ae33%3AS%3Dc5b81f7f21b546d60a3c70485c2d02b7][特殊字符]]

+ = 行号
+ & 替换

**** [[https://app.yinxiang.com/shard/s52/nl/11551545/44b5a4ab-edb8-44f8-bd26-49f01f9a8449/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D151753acd19%3AS%3Db7b51c5421cb557f1e34b51a9886541e][正则表达式]]

1. 标准的正则表达式

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{text}
     + 行开始 (^)
     + 行尾 ($)
     + 单个字符(.)
     + 匹配字符集合 ([])
     + 独有集 ([^])
     + 字符范围 ([-])
     + 零到一次出现 (\?)
     + 一次或多次出现 (\+)
     + 零或多次出现 (*)
     + n个重复 {n}
     + 最少出现n个 {n,}
     + M到N次出现 {m, n}
     \end{minted}
   #+end_latex


2. 转义

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{text}
        + "\"
        + "\n" 新行字符匹配。
        + "\r" 回车匹配。
        + 转义"\dnnn" 匹配一个字符的十进制ASCII码值
        + 转义 "\onnn" 匹配字符的八进制ASCII码值
     \end{minted}
   #+end_latex

3. 正则表达式的 POSIX 类

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{text}
     + [:alnum:] 这意味着按字母和数字字符
     + [:alpha:] 这意味着只有字母字符
     + [:blank:] 这意味着空白字符可以是任何空格或制表符
     + [:digit:] 这意味着只有小数
     + [:lower:] 这意味着只有小写字母
     + [:upper:] 这意味着只有大写字母
     + [:punct:] 它意味着标点符号包括非空格或字母数字字符
     + [:space:] 这意味着空格字符
     \end{minted}
   #+end_latex

4. 元字符

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{text}
     + 单词边界 (\b)
     + 非单词边界(\B)
     + 单空白 (\s)
     + 单非空白 (\S)
     + 单字字符 (\w)
     + 单非单词字符 (\W)
     + 模式空间的开始 (\`)
     \end{minted}
   #+end_latex

**** [[https://app.yinxiang.com/shard/s52/nl/11551545/d6d0e355-984e-43fe-ab58-e1f750d23709/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D15175467fbf%3AS%3Db22c328957943d9b98cf17a0186628ac][管理模式]]

**** [[https://app.yinxiang.com/shard/s52/nl/11551545/77001447-dee9-492c-ad22-3a99ca9e7d3c/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D15175474322%3AS%3Da31c3b6d37564d32ca8abbb68073027b][模式范围]]

**** [[https://app.yinxiang.com/shard/s52/nl/11551545/84ae24db-72e4-423b-9f80-eaef02fa0674/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D15175482ecc%3AS%3D7ae4d46db25e178c91c0e287c68cadc1][模式缓冲区]]

**** [[https://app.yinxiang.com/shard/s52/nl/11551545/dd36224a-3220-4d01-969f-b354cbd42c0c/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D1517549207f%3AS%3Dd2a7e7843f9728e054946c9edfeba5d4][字符串]]

**** [[https://app.yinxiang.com/shard/s52/nl/11551545/1cb3dab6-6c9e-4966-9bfe-f56e36e82223/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D1517549de2e%3AS%3D16a629acaab5e78a8e6c1419f5adf978][分支]]

**** [[https://app.yinxiang.com/shard/s52/nl/11551545/3f5d41e7-0e79-4c69-ad9f-40087ac85eb2/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D151754ad2cf%3AS%3Dee8de982e2e19928a4480d5a3445fa18][循环]]

**** [[https://app.yinxiang.com/shard/s52/nl/11551545/3ecd8012-44c1-4a1c-b997-c9dca09d17fe/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D151754bf96c%3AS%3D90d2cd00d1034b0b046191e363c10e3f][实用功能]] :sed:

* Git                                                                   :git:
** GitFundamental
*** git 分支                                                    :git:linux:
+ 查看分支：git branch
+ 创建分支：git branch <name>
+ 切换分支：git checkout <name>
+ 创建+切换分支：git checkout -b <name>
+ 合并某分支到当前分支：git merge <name>
+ 删除分支：git branch -d <name>

** Git Tutorial                                                   :tutorial:
http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000#main

*** 安装配置
Linux下直接安装。

Windows下使用 [[http://msysgit.github.io/][msysgit]]

安装完成后首先必须对用户名和账户进行配置。
#+BEGIN_EXAMPLE
  git config --global user.name "Your Name"
  git config --global user.email "email@example.com"
#+END_EXAMPLE

*** Git本地使用
*版本库* 又名仓库，英文名 *respository*, 可以简单理解为一个目录，该目
录中的文件可以被Git管理，文件的修改、删除等变化都能被Git跟踪，以便任何
时刻都可以追踪历史，或者在将来某个时刻进行还原。

**** 新建版本库
进入工作目录，使用 *git init* 命令进行版本库的初始化。
#+BEGIN_EXAMPLE
  git init
#+END_EXAMPLE

注: 在Windows系统下，为了避免莫名其妙的问题，请确保路径名不包含中文

初始化后，目录下增加了.git文件夹，该目录用来跟踪管理版本库。

**** 添加文件
注：
+ Git只能跟踪文本文件，二进制文件如图片、视频、MS Word等的变化则没法跟
  踪。
+ 文本文件的编码最好统一使用UTF-8编码。

  使用 *git add* 将文件填加到版本库中。Unix的哲学 *没有消息就是好消息*
  ，该命令执行完成后不会显示消息。
  #+BEGIN_EXAMPLE
    git add <filename>
  #+END_EXAMPLE

**** 提交
使用 *git commit* 将填加的文件提交到版本库。
#+BEGIN_EXAMPLE
  git commint -m <commment>
#+END_EXAMPLE

**** 查看版本变更
*git status* 命令查看当前版本库状态。

*git diff* 命令，查看变更内容。
#+BEGIN_EXAMPLE
  git diff <filename>
#+END_EXAMPLE

确认无误后，使用git add和git commit进行提交。

**** 版本回退
*git log* 查看历史记录。Git的版本号是算法计算的十六进制数字。
#+BEGIN_EXAMPLE
  git log --pretty=oneling    # 在一行中显示历史记录信息。
#+END_EXAMPLE

Git中使用 *HEAD* 表示当前版本，使用 *HEAD^*, \verb$HEAD^^$ 表示历史版本，
*HEAD~100* 表示往上100个版本。
#+BEGIN_EXAMPLE
  git reset --hard HEAD^    # 命令回复到上一版本。
  git reset --hard <version-ID>    #命令回复到特定版本，其中版本号ID可不写全。
  git reflog    # 用来记录git的每一次命令信息。
#+END_EXAMPLE

**** 撤消修改
*git checkout* 命令撤消修改。
#+BEGIN_EXAMPLE
  git checkout -- <filename>
#+END_EXAMPLE

**** 删除文件
*git rm* 从版本库中删除文件中。
#+BEGIN_EXAMPLE
  git rm <filename>
  git checkout -- <filename>    # 可恢复跟踪的被系统删除的文件。
#+END_EXAMPLE

**** 小结
+ git init 新建版本库
+ git add [filename] 添加文件
+ git commit -m [comment] 提交文件
+ git status 查看版本库状态
+ git log 查看版本变更
+ git reset -hard [version] 版本恢复
+ git reflog 命令历史
+ git checkout -- [filename] 撤消修改
+ git rm [filename] 删除文件
*** git远程库
**** 创建远程仓库
远程仓库是git的杀手级应用之一.

1. 第1步: 创建SSH

   *SSH* (Secure SHell), 为一项创建在应用层和传输层基础上的安全协议，
   为计算机上的Shell（壳层）提供安全的传输和使用环境Key

   在用户主目录下，看看有没有 *.ssh* 目录，如果有，再看看这个目录下有
   没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。
   如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：
   #+BEGIN_EXAMPLE
     ssh-keygen -t rsa -C "youremail@example.com"
   #+END_EXAMPLE

   如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和
   id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄
   露出去，id_rsa.pub是公钥，可以放心地告诉任何人。

2. 第2步: 设置GitHub

   登陆GitHub，打开Account settings，SSH Keys页面.然后，点Add SSH Key，
   填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容.

   为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你
   推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了
   你的公钥，就可以确认只有你自己才能推送。

   当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，
   一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电
   脑上往GitHub推送了。

   最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只
   有你自己才能改）。所以，不要把敏感信息放进去。

**** 添加远程库
1. step 1: 登陆GIthub,创建一个新的仓库
2. step 2: 添加本地仓库
   #+BEGIN_EXAMPLE
     git remote add origin https://github.com/USER/REPO.git
   #+END_EXAMPLE
**** 推送本地内容到远程库
*git push*  把本地仓库的所有内容推送到远程库上.
#+BEGIN_EXAMPLE
  git push -u origin master
#+END_EXAMPLE
注: 第一次推送master分支时,加上参数\textbf{-u},Git不但把本地的master分
支内容推送到远程的新的master分支上,还会把本地的master与远程的master分
支关联起来,在以后的推送或者拉取中就可以简化命令.
#+BEGIN_EXAMPLE
  git push origin master
#+END_EXAMPLE

**** 从远程库克隆
#+BEGIN_EXAMPLE
  git clone https://github.com/USER/REPO.git
#+END_EXAMPLE
*** git pull
git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合
并。它的完整格式稍稍有点复杂。

#+BEGIN_EXAMPLE
  git pull <远程主机名> <远程分支名>:<本地分支名>
#+END_EXAMPLE

比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。
#+BEGIN_EXAMPLE
  git pull origin next:master
#+END_EXAMPLE

如果远程分支是与当前分支合并，则冒号后面的部分可以省略。
#+BEGIN_EXAMPLE
  git pull origin next
#+END_EXAMPLE
上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于
先做git fetch，再做git merge。
#+BEGIN_EXAMPLE
  git fetch origin
  git merge origin/next
#+END_EXAMPLE

在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系
(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名
分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分
支。

Git也允许手动建立追踪关系。
#+BEGIN_EXAMPLE
  git branch --set-upstream master origin/next
#+END_EXAMPLE

上面命令指定master分支追踪origin/next分支。

如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。
#+BEGIN_EXAMPLE
  git pull origin
#+END_EXAMPLE

上面命令表示，本地的当前分支自动与对应的origin主机”追踪分
支”(remote-tracking branch)进行合并。

如果当前分支只有一个追踪分支，连远程主机名都可以省略。
#+BEGIN_EXAMPLE
  git pull
#+END_EXAMPLE
上面命令表示，当前分支自动与唯一一个追踪分支进行合并。

如果合并需要采用rebase模式，可以使用–rebase选项。
#+BEGIN_EXAMPLE
  git pull --rebase <远程主机名> <远程分支名>:<本地分支名>
#+END_EXAMPLE

*** git ignore
+ 文件名: *.gitignore*
+ 特性:
  + 包括文件夹名
  + 支持通配符*
  + 按行组织
  + 文件本身应由git管理

*** git branch
**** 分支管理
分支就是平行宇宙,互不干扰,可以在适当的时候进行合并.

SVN也有分支管理功能,但是很慢.Git的分支与众不同,无论是创建,切换和删除分
支,无论版本库的大小,Git都能很快完成.
**** 创建与合并分支
+ 每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。
+ 截止到目前，只有一条时间线，在Git里，这个分支叫 *主分支* ，即master
  分支。
+ 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分
  支的线也越来越长
+ *HEAD严格来说不是指向提交，而是指向master，master才是指向提交的* ，
  所以，HEAD指向的就是当前分支。

  \begin{figure}[ht]
  \centering
  \includegraphics[width=0.5\linewidth]{/home/ben/Tiger/Figures/scrot/5001kAy.png}
  \end{figure}


当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交
，再把HEAD指向dev，就表示当前分支在dev上.Git创建一个分支很快，因为除了
增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化

\begin{figure}[ht]
\centering
\includegraphics[width=0.5\linewidth]{/home/ben/Tiger/Figures/scrot/5001WKB.png}
\end{figure}

不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，
dev指针往前移动一步，而master指针不变：

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{/home/ben/Tiger/Figures/scrot/5001jUH.png}
\end{figure}

假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简
单的方法，就是直接把master指向dev的当前提交，就完成了合并：

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{/home/ben/Tiger/Figures/scrot/5001weN.png}
\end{figure}



合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，
我们就剩下了一条master分支：
\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{/home/ben/Tiger/Figures/scrot/50019oT.png}
\end{figure}

+ *git branch* 列出当前版本库的所有分支,当前分支前面会有一个 * 号.
+ *git checkout -b dev* -b 参数表示创建并切换,等于以下两步:
  + *git branch dev* 创建
  + *git checkout dev* 切换
+ *git merge dev* 用于合并指定分支到当前分支
+ *git branch -d dev* 删除分支, 注:
  + master分支并不是特殊的,可以删除
  + 不能删除当前分支,需切换

**** 解决冲突

当不同分支都有自己的新的提交时,这种情况下,git无法执行"快速
合并",只能试图把个自的修改合并起来,但可能会产生冲突.
\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{/home/ben/Tiger/Figures/scrot/5001KzZ.png}
\end{figure}

#+BEGIN_EXAMPLE
Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容
#+END_EXAMPLE

**** 分支管理策略
通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支
后，会丢掉分支信息。

如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从
分支历史上就可以看出分支信息。
#+BEGIN_EXAMPLE
  git merge --no-ff -m "merge with no-ff" dev
#+END_EXAMPLE
+ *合并dev分支，请注意--no-ff参数，表示禁用Fast forward*
+ 本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去
\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{/home/ben/Tiger/Figures/scrot/5001X9f.png}
\end{figure}


***** 分支策略
在实际开发中，我们应该按照几个基本原则进行分支管理：
+ 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在
  上面干活
+ 干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0
  版本发布时，再把dev分支合并到master上，在master分支发布1.0版本
+ 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不
  时地往dev分支上合并就可以了。

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{/home/ben/Tiger/Figures/scrot/5001kHm.png}
\end{figure}


**** 多人合作
当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应
起来了，并且，远程仓库的默认名称是origin。
使用 *git remote* 查看远程库的信息, *git remote -v* 查看详细信息.
#+BEGIN_EXAMPLE
  git remote -v
#+END_EXAMPLE
***** 推送分支
推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，
这样，Git就会把该分支推送到远程库对应的远程分支上：
#+BEGIN_EXAMPLE
  git push origin master
#+END_EXAMPLE

如果要推送其他分支，比如dev，就改成：
#+BEGIN_EXAMPLE
  git push origin dev
#+END_EXAMPLE

***** 小结
+ 查看远程库信息，使用git remote -v；
+ 本地新建的分支如果不推送到远程，对其他人就是不可见的；
+ 从本地推送分支，使用git push origin branch-name，如果推送失败，先
  用git pull抓取远程的新提交；
+ 在本地创建和远程分支对应的分支，使用git checkout -b branch-name
  origin/branch-name，本地和远程分支的名称最好一致；
+ 建立本地分支和远程分支的关联，使用git branch --set-upstream
  branch-name origin/branch-name；
+ 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。
** github                                                           :github:
*** 搭建博客
参考:
+ http://holbrook.github.io/2013/05/27/jekyll_mysite.html#post-2398
+ http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html


1. 基础
   1) 关于Jekyll

     简单的说,是用Ruby语言实现的一个静态网站生成器,可以将 *Markdown* 编
      辑的文档生成HTML.当然也可以用来生成博客.

   2) 关于github
      Github是程序员的facebook.   github提供的静态网页托管.

      使用github pages写博客的好处有:
      + 自由,随意定制
      + 方便,在github上托管
      + 可控,有版本管理
      + 直接,只需提交,不需要先导出再提交
      + 高效,使用markdown语言能提高写作效率(但是个人觉得不如org-mode)
      + 免费,无限流量,无限空间

   3) 3分钟建立博客

2. 进阶

3. 推广
*** jekyllbootstrap                                :jekyll:jekyllbootstrap:

**** reference

+ [[http://themes.jekyllbootstrap.com/preview/mark-reid/lessons/2011/12/29/jekyll-introduction/][Jekyll Introduction]]
+ [[http://jekyllbootstrap.com/][Jekyllbootstrap]]
+ [[http://jekyllbootstrap.com/usage/jekyll-quick-start.html][Jekyllbootstrap Quickstart]]
+ [[http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html][使用 Github 和 Jekyll 搭建博客]]

**** jekyll quickstart

1. rake post title="Hello World"
2. $ rake page name="about.md"

**** Hello Julie

竹琳好

**** 小结

+ /使用 markdown 语言写/
+ 在使用中学习并不断探索，不要专门学习

*** git push without entering username and password                :weekly:

[[http://stackoverflow.com/questions/6565357/git-push-requires-username-and-password][stackoverflow]]

a common mistake is cloning *using the default (https) instead of
ssh*. you can correct this by going to your repository, clicking the
ssh button left to the url field and updating the url of your origin
remote like this:

#+begin_latex
\begin{minted}[frame=single, mathescape]{sh}
git remote set-url origin ssh://git@github.com:username/repo.git
\end{minted}
#+end_latex

[[using an https remote url has some advantages: it's easier to set up than ssh, and usually works through strict firewalls and proxies. however, it also prompts you to enter your github credentials every time you pull or push a repository.][github help]]

using an https remote url has some advantages: it's easier to set up
than ssh, and usually works through strict firewalls and
proxies. however, it also prompts you to enter your github credentials
every time you pull or push a repository.

[[using an https remote url has some advantages: it's easier to set up than ssh, and usually works through strict firewalls and proxies. however, it also prompts you to enter your github credentials every time you pull or push a repository.][github]]
*caching your github password in git*

** git服务器
http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000


1. 第一步，安装git：
   #+BEGIN_EXAMPLE
   $ sudo apt-get install git
   #+END_EXAMPLE

2. 第二步，创建一个git用户，用来运行git服务：
   #+BEGIN_EXAMPLE
   $ sudo adduser git
   #+END_EXAMPLE

3. 第三步，创建证书登录：

   收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有
   公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。

4. 第四步，初始化Git仓库：

   先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入
   命令：
   #+BEGIN_EXAMPLE
   $ sudo git init --bare sample.git
   #+END_EXAMPLE

   Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹
   是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上
   的Git仓库通常都以.git结尾。然后，把owner改为git：
   #+BEGIN_EXAMPLE
   $ sudo chown -R git:git sample.git
   #+END_EXAMPLE

5. 第五步，禁用shell登录：

   出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑
   /etc/passwd文件完成。找到类似下面的一行：

   #+BEGIN_EXAMPLE
   git:x:1001:1001:,,,:/home/git:/bin/bash
   #+END_EXAMPLE
   改为：
   #+BEGIN_EXAMPLE
   git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
   #+END_EXAMPLE

   这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git
   用户指定的git-shell每次一登录就自动退出。

6. 第六步，克隆远程仓库：
   现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：
   #+BEGIN_EXAMPLE
   $ git clone git@server:/srv/sample.git
   Cloning into 'sample'...
   warning: You appear to have cloned an empty repository.
   #+END_EXAMPLE

   剩下的推送就简单了。

   由本地库推送：
   #+BEGIN_EXAMPLE
   git remote add origin git@192.168.1.12:/path/to/src.git
   #+END_EXAMPLE



7. 其它

   1) 管理公钥

      如果团队很小，把每个人的公钥收集起来放到服务器的
      /home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号
      人，就没法这么玩了，这时，可以用Gitosis来管理公钥。

      这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相
      信找个高水平的Linux管理员问题不大。

   2) 管理权限

      有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系
      统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支
      甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继
      承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），
      所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制
      的目的。Gitolite就是这个工具。

      这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。

   3) 小结
      + 搭建Git服务器非常简单，通常10分钟即可完成；

      + 要方便管理公钥，用Gitosis；

      + 要像SVN那样变态地控制权限，用Gitolite。
** git 恢复指定文件                                                    :git:
*** why

git 恢复不小心修改的文件。

*** [[http://www.cnblogs.com/zhulin/archive/2012/06/09/2542785.html][恢复到指定版本]]

1. 首先查看该文件的历史版本信息： *git log <FILE>*

   #+BEGIN_SRC sh
   git log foo.txt
   #+END_SRC

   记录下需要恢复的commit版本号：如

   #+BEGIN_EXAMPLE
   9aa51d89799716aa68cff3f30c26f8815408e926
   #+END_EXAMPLE

2. 恢复该文件： *git reset <VERSION> <FILE>*

   #+BEGIN_SRC sh
   git reset 9aa51d89799716aa68cff3f30c26f8815408e926 foo.txt
   #+END_SRC

3. 提交git: *git commit*

   #+BEGIN_SRC sh
   git commit -m "revert old file"
   #+END_SRC

*** [[http://blog.csdn.net/awj3584/article/details/26567735][恢复到上一版本]]

恢复到最后一次提交的改动： /git checkout --/

#+BEGIN_SRC sh
git checkout -- <FILE>
#+END_SRC

需要注意的是，如果该文件已经 add 到暂存队列中， 需要先让这个文件 /取消
暂存/ ：

#+BEGIN_SRC sh
git reset HEAD -- <FILE>
#+END_SRC

#+BEGIN_SRC sh
git config --global alias.unstage 'reset HEAD --'
git config --global alias.restore 'checkout --'
#+END_SRC

/匿名命令/ ： 类似 bash 的 alias ，方便记忆

*** 小结

 git将单个文件恢复到历史版本的正确方法如下：

 1. git reset commit_id 文件路径
 2. git checkout -- 文件路径

* Kernel                                                             :kernel:
* Tools
** Chrome                                                           :chrome:
*** Chrome插件
+ http://www.zhihu.com/question/23228162
+ http://www.zhihu.com/question/19594682


+ Chrome是个不错的工具
+ 注意插件是占用内在的，所以不要开启不必要的插件

*** chromium flash

+ http://www.linuxidc.com/Linux/2014-05/101095.htm
+ https://wiki.ubuntu.com/Chromium/Getting-Flash

** Ubuntu                                                           :ubuntu:
*** Ubuntu 文件管理器 书签                                       :bookmark:
c-d
c-b

书签-> 添加

*** .gvfs                                                      :gvfs:gnome:
- State "DONE"       from "TODO"       [2015-12-08 二 13:18]

**** why

#+BEGIN_EXAMPLE
  roslaunch j[rospack] Warning: error while crawling /home/ben:
  boost::filesystem::status: Permission denied: "/home/ben/.gvfs"
#+END_EXAMPLE

**** [[http://www.cnblogs.com/tdyizhen1314/p/4142991.html][error: failed to stat /home/dade/.gvfs: Permission denied]]

表面上看：好像是权限不够，于是准备使用chmod -R 777 .gvfs 修改权限，可
让你惊讶的是，root用户下也不行，给出的报告是：

#+BEGIN_EXAMPLE
chmod：cannot access '.gvfs': Permission denied.
#+END_EXAMPLE

是不是很神奇，我可是root用户呢！于是使用ls -a -l查看文件的属性，如下

#+BEGIN_EXAMPLE
d?????????  ? ?    ?        ?                ? .gvfs
#+END_EXAMPLE

完全不知啊！于是想着能不能把这文件删掉呢？或者删掉后对系统会有影响吗？
而且该怎么删呢，直接使用rm，结果证明直接rm是错误的。

重新更改删除方案，如下：
1) umount .gvfs
2) rm -rf .gvfs

**** [[http://zhidao.baidu.com/share/342cd184f745024170cf0790202febaa.html][gvfs: Gnome Virtual File System]]

GVFS是 /GNOME/ 桌面系统的 /虚拟文件系统/ ，通过GVFS，用户可以很容易的
通过SFTP、FTP、WebDAV、SMB等访问 /远程数据/ ，通过HAL integration、OBEX等
访问本地数据。

GVFS附加资源通过URI语法进行解析，如：smb://server01/gamedata或者
ftp://username:password@ftp.example.net/public_html， 同时，也可以采用
传统方式进行挂载， *通常挂载到~/.gvfs/* ，通过mount来使得旧的应用程序使用
标准POSIX命令和I/O。

GVFS使用FUSE（Filesystem in Userspace），用来取代早期的GnomeVFS。它由
两部分组成：一个由应用程序支持的GIO载入的共享库和GVFS本身（包含一个互
相通信的进程集合与基于D-Bus的GIO模块）

到2010年12月，113个注册GNOME组件中的107个已经移植到GIO（GVFS URI支持）。
目前有一个命令行工具集（包括gvfs-mount，gvfs-less等）来管理VFS资源。

*** fonts                                                            :font:
**** 文泉驿
+ http://wenq.org/wqy2/index.cgi

#+BEGIN_EXAMPLE
  $ apt-cache search wenquanyi

  ,#+results:
  fonts-wqy-microhei - Sans-serif style CJK font derived from Droid
  fonts-wqy-zenhei - "WenQuanYi Zen Hei" A Hei-Ti Style (sans-serif) Chinese font
  xfonts-wqy - WenQuanYi Bitmap Song CJK font for X
#+END_EXAMPLE


文泉驿微米黑就适合了, 不要太折腾.

apt方式安装字体也并没有什么不好.

**** 字体
***** Font
https://wiki.archlinux.org/index.php/Fonts_\%28\%E7\%AE\%80\%E4\%BD\%93\%E4\%B8\%AD\%E6\%96\%87\%29#mw-content-text

1. 计算机字体(*font*),简称字体(font),是包含一套字形和字符的数据文件.

2. 字体类型
   + 点阵字体
   + 矢量字体

   + serif: 衬线字体，适合打印。
   + sans-serif: 无衬线字体，适合电脑屏幕阅读。
   + monospace: 等宽字体
     注:中文显示的方式不同,中文本身拥有的横和相同的高度已然具有平齐效
     果.行距对中文更重要。

3. 常见格式
   + bdf, bdf.gz -- 点阵字体,Bitmap Distribute format位图
   + pcf, pcf.gz -- 点阵字体,Portable Compiled Font可移植
   + psf, psfu, psf.gz, psfu.gz -- 点阵字体, PC Screen Font Unicode
   + pfam, pfb -- 矢量字体
   + ttf -- TrueType
   + otf -- OpenType
   + 排版程序\TeX{}和配套的字体软件Metafont用它们自己的方法渲染字体,后
     缀为*pk, *gf, mf与vf.
4. 字体安装
   将字体移动到文件夹下,然后更新fontconfig的字体缓存
   + 系统: /usr/share/fonts
   + 用户: ~/.local/share/fonts

***** Times New Roman
http://zh.wikipedia.org/wiki/Times_New_Roman

Times New Roman（泰晤士新罗马）可能是最常见且广为人知的衬线字体之一，
在字体设计上属于过渡型衬线体，对后来的字型产生了很深远的影响。另外由于
其中规中矩、四平八稳的经典外观，所以经常被选择为标准字体之一。

《泰晤士报》首次采用了Times New Roman后，这个优秀的字型很快地博得了大
众的青睐，获得了极大的成功。之后尽管泰晤士报已不再使用Times New Roman，
但Times New Roman已成为经典字型之一，迄今仍广泛使用在图书、杂志、报告、
公文、广告、屏幕显示等等。

在电脑方面，现在很多应用程序，还有网页浏览器和文字处理软件都是用它作为
默认字体。

方正公司的方正小标宋、方正宋三字体的英文部分也使用Times New Roman（但
是方正宋三字体中阿拉伯数字使用的是Bodoni MT字体）

*** 输入法                                                      :输入法:input:
**** fcitx                                                         :fcitx:
http://blog.sina.com.cn/s/blog_578fb7710101m90d.html


1. 第一步：缷载ibus
   + sudo apt-get remove ibus
   + 重启ubuntu
2. 第二步：安装fcitx五笔拼音
   + sudo add-apt-repository ppa:wengxt/fcitx-nightly
   + sudo apt-get update
   + sudo apt-get install im-switch fcitx
   + sudo apt-get install fcitx-table-wbpy
   + sudo im-switch -s fcitx
   + im-switch -s fcitx
   + 重启ubuntu
3. 注
   + 使用fcitx五笔拼音，虽然Rime名声很好，但是太折腾.
   + ibus会导致开机启动时交换Ctrl与Cap键失效.
**** ibus                                                           :ibus:

http://wiki.ubuntu.org.cn/IBus

IBus 全称 Intelligent Input Bus是下一代输入法框架（或者说“平台”）。
项目现托管于 Google Code - https://code.google.com/p/ibus/ 此项目包含
了世界多数语言的文字输入需求——由世界多个国家开发者维护。

Ubuntu中文输入法IBUS的安装

第一：安装IBus框架，
#+BEGIN_EXAMPLE
$ sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4
#+END_EXAMPLE
启动IBus框架，在终端输入：
#+BEGIN_EXAMPLE
$ im-switch -s ibus
#+END_EXAMPLE
安装完IBus框架后注销系统，保证更改立即生效。

第三步：安装拼音引擎

有下面几种常用选择：
+ IBus拼音：sudo apt-get install ibus-pinyin
+ IBUS五笔：sudo apt-get install ibus-table-wubi
+ 谷歌拼音输入法：sudo apt-get install ibus-googlepinyin
+ Sun拼音输入法：sudo apt-get install ibus-sunpinyin

第四步：设置IBus框架

#+BEGIN_EXAMPLE
$ ibus-setup
#+END_EXAMPLE

设置IBUS

第五步：通常情况下，IBus图标（一个小键盘）会出现在桌面右上角的任务栏中。
有时候这个图标会自行消失，可使用以下命令，找回消失的IBus图标：
#+BEGIN_EXAMPLE
$ ibus-daemon -drx
#+END_EXAMPLE

**** rime                                                          :rime:中州韵:

参考:
+ HOMEPAGE：https://code.google.com/p/rimeime/wiki/Downloads
+ Wiki：http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%B7%9E%E9%9F%BB%E8%BC%B8%E5%85%A5%E6%B3%95%E5%BC%95%E6%93%8E
+ http://tieba.baidu.com/p/2123383997
+ http://www.douban.com/note/282213725/
+ http://tieba.baidu.com/p/1748128802  切换半角


中州韵输入法引擎（英语：Rime Input Method Engine，又称Rime输入法）是由
佛振编写的开源中文输入法，目前项目网站、源代码均托管在GitHub[注 1]。
基于同一个核心架构，该输入法分为三个发布版：Linux发布版中州韵
（ibus-rime，另有 fcitx-rime）、Windows发布版小狼毫（Weasel）、OS X发
布版鼠须管（Squirrel）。



***** ibus rime
http://tieba.baidu.com/p/3064088726

1. 简要

   将rime输入法平台嵌入到ibus中（完成后会带有明月拼音，仓颉，当然还可
   以自行添加其它的）；然后导入山人全息码的码表到rime中（我已经打磨好
   了）。

2. 扩展
   1) rime

      面象中文的开源输入法。
      + 项目主页：baidu.com https://code.google.com/p/rimeime/
      + 贴吧：http://tieba.baidu.com/f?kw=rime

   2) 山人全息码（形码）

      贴吧：
      http://tieba.baidu.com/f?kw=%C9%BD%C8%CB%C8%AB%CF%A2%C2%EB&fr=itb_favo&fp=favo

3. 安装ibus-rime
   三步走：
   #+BEGIN_EXAMPLE
     sudo add-apt-repository ppa:lotem/rime
     sudo apt-get update
     sudo apt-get install ibus-rime
   #+END_EXAMPLE
   注销；然后进入ibus文字输入设定中将rime加入到活动列表。

*** 交换CasLock和Ctrl键

+ http://askubuntu.com/questions/412576/swap-caps-lock-and-ctrl-in-ubuntu-13-10/412622#412622
+ http://www.2cto.com/os/201306/222522.html


1. gnome-tewak-tool

   Gnome tweak tool is a tool to customize advanced GNOME 3 options.
   #+BEGIN_EXAMPLE
     $ sudo apt-get install gnome-tweak-tool
     $ gnome-tweak-tool
   #+END_EXAMPLE
   注:有时会出bug不起效用,不知为何.

2. xmodmap
   1) 建立一个新文件: ~/.Xmodmap,添加以下内容:
      #+BEGIN_EXAMPLE
        remove Lock = Caps_Lock
        remove Control = Control_L
        keysym Control_L = Caps_Lock
        keysym Caps_Lock = Control_L
        add Lock = Caps_Lock
        add Control = Control_L
      #+END_EXAMPLE

   2) 执行
      #+BEGIN_EXAMPLE
        $ xmodmap ~/.Xmodmap 2>/dev/null
      #+END_EXAMPLE

   3) 如果不想每次启动都手动输入命令，可以把命令写到~/.xinitrc中。
      注: 如果把命令写到~/.bashrc中，每次新开一个终端或tab上述命令都会
      被执行一次，这样键位又换回来了。

3. setxkbmap
   #+BEGIN_EXAMPLE
     $ setxkbmap -option ctrl:swapcaps
   #+END_EXAMPLE
   可以把该命令写在~/.bashrc中,重复执行并不影响.

*** Emacs Keybindings in Gnome
+ http://jblevins.org/log/emacs-keys
+

**** gconf-editor
Once upon a time, Gnome provided a way to enable Emacs-style keyboard
shortcuts for editing text fields through the Keyboard Shortcuts
preferences dialog. These shortcuts are incredibly useful when editing
text in web forms, such as when editing a Wiki. Unfortunately, in
trying to simplify the Gnome interface (for better or worse), this
option has been removed. Luckily (as of Gnome 2.16.1) it can still be
enabled through gconf by running gconf-editor, and changing the
/desktop/gnome/interface/gtk_key_theme key to Emacs.

**** gnome-tweak-tools
key-theme-emacs
**** gconf-2

*** Management
**** 启动项

+ acpi-support 这个是关于电源支持的默认是1,2,3,4,5下启动，我认为你可以
  把它调整到s级别。

+ acpid acpi的守护程序，默认是2－5开启，我认为可以不用管。

+ alsa alsa声音子系统，应该不用开启它。

+ alsa-utils 这个服务似乎取代了alsa，所以开启这个就可以了，我在S级别开
  启它。

+ anacron 这是一个用于执行到时间没有执行的程序的服务，我认为它无所谓，
  所以关了它，这个可以随便。

+ apmd 也是一种电源管理，我认为电脑如果不是很老，它就没有开启的必要了。

+ atd 和anacron类似，我把它关了。

+ bluez-utiles 传说中的蓝牙服务，然后遗憾我没有，所以关了。

+ bootlogd 似乎使用来写log的，安全期间开着他也许比较好。

+ cron 指定时间运行程序的服务，所以开着比较好的。

+ cupsys 打印机服务，所以如果你有，就开启吧。

+ dbus 消息总线系统，非常重要，一定要开。

+ dns-clean 拨号连接用的，如果不用，就关了它。

+ evms 企业卷管理系统，由于我并不明白什么叫做企业卷，所以我关了它。

+ fetchmail 用于邮件守护，我关了它。

+ gdm gnome桌面管理器，我关了它，然后用startx启动gnome。

+ halt 关机用的，不要更改

+ hdparm 这个我刚才有讲，如果没有ide硬盘也就不用开启它了。

+ hotkey-setup 这个是给某些品牌笔记本设计的热键映射，台式机用户请关了
  它

+ hotplug 这个是用于热插拔的，我已经测试过了，在某些电脑上关闭它会使声
  卡无效，请在S级别开启它。

+ hplip hp打印机专用的，应该可以关了它。

+ ifrename 网络接口重命名，好像没用，关了。

+ ifupdown 这个使用来打开网络的，开着它。

+ ifupdown-clean 同上。

+ klogd linux守护程序，接受来自内核和发送信息到syslogd的记录，并记录为
  一个文件，所以请开着它。

+ linux-restricted-modules-common 这个使用来使用受限制的模块的，你可以
  从/lib/linux-restricted-modules下查看，如果没有什么，你可以关掉它。

+ lvm 逻辑卷管理器，如果你没有请关了它。

+ makedev 用来创建设备到/dev/请不要动他。

+ mdamd 管理raid用，如果你没有请关闭它。

+ module-init-tools 从/etc/modules 加在扩展模块的，这个一般开着。

+ networking 增加网络接口和配置dns用，将它开启。

+ ntp-server 与ubuntu时间服务器进行同步的，关了。

+ pcmcia 激活pcmica设备，遗憾我有生以来都没有见过这样的设备，关了它。

+ powernowd 用于管理cpu的客户端程序，如果有变频功能，比如amd的quite'
  cool 那么就开启它吧。

+ ppp 拨号用的，我关了它。

+ ppp-dns 一样，也关了。

+ readahead 预加载服务，让我想起了win的预读，当然他们不同，它会使启动
  变慢3－4妙，所以我关了它。

+ reboot 重启用的，不要动。

+ rmnologin 如果发现nologin，就去除它，在笔记本上不用开启。

+ rsync rsync协议守护，请视情况而定。

+ screen-cleanup 一个清除开机屏幕的脚本，随便。

+ sendsigs 重启和关机时向所有进程发送消息。所以不要管它。

+ single 激活但用户模式，不用管它。

+ stop-bootlogd 从2,3,4,5级别停止bootlogd,不用管它。

+ sudo 这个不用说吧，不用管它。

+ sysklogd 用于记录系统日志信息，不用管它。

+ udev 用户空间dev文件系统，不用管它。

+ udev-mab 同上。

+ umountfs 用来卸载文件卷的，不用管它。

+ urandom 生成随即数的，不知道怎么用，不用管它。

+ usplash 那个漂亮的启动画面，但是我关了它，它也存在，所以想关他需要把
  内核起动参数中的splash一句删掉。

+ vbesave 显卡bios配置工具，不用管它。

+ xorg-common 设置x服务ice socket。不用管它。

**** 修改文件默认打开方式
+ http://blog.csdn.net/hustrains/article/details/8652098
+ http://www.2cto.com/os/201301/182484.html

***** 简单的方法：
右键点击所需要的开的文件，选择“属性” ，“打开方式” 即可以选择默认打
开的程序，这是最简便的设定方法！！

***** 复杂一点的方法：
1. 配置文件
   + /etc/gnome/defaults.list 保存了全局的打开方式
   + /.local/share/applications/mimeapps.list 保存了个人的打开方式

   当两着不一致时，优先采用局部的个人设置，所以建议修改个人配置。

   例如，ubuntu12.04下视频文件默认是用电影播放机打开的，如果你想要改成
   用smplayer来打开的话，可以按照以下步聚来进行：

   1) 进入/etc/gnome目录: cd /etc/gnome

   2) 复制要改变打开方式的那些内容行到mimeapps.list文件

      grep “totem” defaults.list >> ~/.local/share/applications/mimeapps.list

   3) 进入~/.local/share/applications目录: cd ~/.local/share/applications

   4) 编缉mimeapps.list文件: vim mimeapps.list

   5) 在vim中执行替换: %s/totem/smplayer/g #

   6) 保存: :wq

**** 系统全局快捷键
1. 系统设置->键盘->快捷键
2. 小企鹅输入法的全局配置和附加组件

**** Recovery mode
+ http://bbs.csdn.net/topics/360177481
+ http://tieba.baidu.com/p/3006415003?bd_source_light=1563095
+ http://blog.csdn.net/mdx20072419/article/details/8060432


1. 问题1：修改系统文件 /etc/sudoers 错误后导致 sudo命令无法使用

   #+BEGIN_EXAMPLE
     >>> /etc/sudoers: syntax error near line 27 <<<
     sudo: parse error in /etc/sudoers near line 27
     sudo: no valid sudoers sources found, quitting

   #+END_EXAMPLE

2. 解决1: 切换到root用户进行修改
   + su root
   #+BEGIN_EXAMPLE
   en@ben:~$ su root
   密码：
   root@ben:/home/ben#
   #+END_EXAMPLE

3. 问题2：没有配置root密码导致su root认证失败
   + 吃一堑，长一智： 设置root密码
   + sudo passwd root

4. 解决2：在Ubuntu Recovery Mode进行修改
   1) 重启Ubuntu，随即长按shirft进入grub菜单，或等待grub菜单的出现
      \begin{figure}[ht]
      \centering
      \includegraphics[width=0.6\linewidth]{/home/ben/Tiger/Figures/scrot/2731xsR.png}
      \end{figure}

   2) 选择Ubuntu高级选项

   3) 选择recovery mode

   4) 选项root

   5) 修改配置文件

5. 问题3：权限只读？
   + chmod u-w /etc/sudoers
   + chmod 440 /etc/sudoers
   + 错误提示：chomd :changing permissions of 'sudoers' :Read-only
     file system
6. 解决

   解决办法：利用 mount 指令解决 Read-only file system的问题
   #+BEGIN_EXAMPLE
   mount -o remount rw /
   #+END_EXAMPLE

   修改 /etc/sudoers 时，用 sudo visudo 命令修改，就不用先改权限了。修
   改后按Ctrl+x，选择Y，输入文件名，回车；

**** Xinitrc
参考:
+ https://wiki.archlinux.org/index.php/Xinitrc_(\%E7\%AE\%80\%E4\%BD\%93\%E4\%B8\%AD\%E6\%96\%87)
+ https://wiki.archlinux.org/index.php/Xmodmap


~/.xinitrc文件量xinit和startx第一次启动时会读取的脚本.通常在启动X时执
行窗口管理器和其它程序.~/.xinitrc一个主要功能是根据单个用户的设置决定
/usr/bin/startx 或 /usr/bin/xinit程序启动的窗口系统.

xmodmap is a utility for modifying keymaps and pointer button mappings
in Xorg.

**** PPA
Personal Package Archives（个人软件包档案）是Ubuntu Launchpad网站提供
的一项服务，允许个人用户上传软件源代码，通过Launchpad进行编译并发布为2
进制软件包，作为apt/新立得源供其他用户下载和更新。在Launchpad网站上的
每一个用户和团队都可以拥有一个或多个PPA。
**** 系统设置显示不全
+ http://tieba.baidu.com/p/2997221608
+ http://jingyan.baidu.com/album/49711c61527d74fa441b7cad.html


1. 打不开
   + sudo apt-get install ubuntu-desktop

2. 显示不全
   + sudo dpkg --configure -a    # 不解此为何意
   + sudo apt-get install unity-control-center
**** deb安装(dpkg)
http://zh.wikipedia.org/wiki/Deb
***** wiki

deb是Debian软件包格式，文件扩展名为.deb，跟Debian的命名一样，deb也是因
Debra Murdock（Debian创始人Ian Murdock的前妻）而得名。

Debian包是Unixar的标准归档，将包文件信息以及包内容，经过gzip和tar打包
而成。

处理这些包的经典程序是dpkg，经常是通过apt来运作。

通过Alien工具，可以将deb包转换成其他形式的软件包。

***** dpkg
deb是debian linus的安装格式，跟red hat的rpm非常相似，最基本的安装命令
是： *dpkg -i file.deb*

*dpkg* 是Debian Package的简写，是为Debian 专门开发的套件管理系统，方便软
件的安装、更新及移除。所有源自Debian的Linux发行版都使用dpkg，例如
Ubuntu、Knoppix 等。


以下是一些 Dpkg 的普通用法：
1. *dpkg -i <package.deb>*:

   安装一个 Debian 软件包，如你手动下载的文件。

2. *dpkg -c <package.deb>*:

   列出 <package.deb> 的内容。

3. *dpkg -I <package.deb>*:

   从 <package.deb> 中提取包裹信息。

4. *dpkg -r <package>*:

   移除一个已安装的包裹。

5. *dpkg -P <package>*:

   完全清除一个已安装的包裹。和 remove 不同的是，remove 只是删掉数据和
   可执行文件，purge 另外还删除所有的配制文件。

6. *dpkg -L <package>*:

   列出 <package> 安装的所有文件清单。同时请看 dpkg -c 来检查一个 .deb
   文件的内容。

7. *dpkg -s <package>*:

   显示已安装包裹的信息。同时请看 apt-cache 显示 Debian 存档中的包裹信
   息，以及 dpkg -I 来显示从一个 .deb 文件中提取的包裹信息。

8. *dpkg-reconfigure <package>*:

   重新配制一个已经安装的包裹，如果它使用的是 debconf (debconf 为包裹
   安装提供了一个统一的配制界面)。

**** apt-get autoremove
*慎用 apt-get autoremove*

apt-get 提供了一个用于下载和安装软件包的简易命令行界面。
卸载软件包主要有这3个命令

+ remove – 卸载软件包
+ autoremove – 卸载所有自动安装且不再使用的软件包
+ purge – 卸载并清除软件包的配置

apt-get remove的行为我们很好理解，就是删除某个包的同时，删除依赖于它的包
例如： A 依赖于 B, B 依赖于 C
apt-get remove 删除B的同时，将删除A(很好理解，A依赖于B，B被删了，A也就
无法正常运行了)


apt-get autoremove的行为重点是卸载所有自动安装
例如：C 依赖于 B, D 依赖于B, 且D没有被其他手动安装的包依赖
apt-get remove C 将删除C, 同时提示你用apt-get autoremove去清除B,D
apt-get autoremove C 将删除B, C, D aptitude remove C 将删除B, C, D

我的理解: 删除C, 那么B,D 这两个包既是自动安装的,且没有其他手动安装的包
依赖于它们,则可以判定B,D也是没必要的

apt-get purge的行为卸载并清除软件包的配置，很容易理解

*依赖性永远是个噩梦，不要考虑用 apt-get autoremove 卸载自己不熟悉的软
件包*

当你问某某人xx包可以卸载吗？某人说你就用 apt-get autoremove 命令吧，然
后发现卸载后系统挂了，囧…

**** pkgProblemResolver::Resolve 发生故障
E:错误，pkgProblemResolver::Resolve 发生故障，这可能是有软件包被要求保
持现状的缘故

1) sudo rm -f /var/lib/apt/lists/lock  # 可能有用
2) 更换源(经验证)，更换源的方式：
   + 在软件中心更新源设置里修改
   + etc/apt/sources.list ，删除不需要的源

*** 软件管理手记
   http://blog.sina.com.cn/s/blog_67117ae60101csqh.html
   http://www.gnu.org/
   http://mirrors.ustc.edu.cn/gnu/
   设置默认打开程序
**** chrome 软件中心
**** git
   http://git-scm.com/
   http://git-scm.com/book/zh/v***%E***B***B***E***AD%A***%E***AE%***E***A******Git
   源码安装失败， 使用apt
**** emacs
   https://www.gnu.org/software/emacs/

**** Virtualbox apt

virtualbox extension
http://askubuntu.com/questions/528512/virtualbox-extension-pack-for-14-04-1-lts-virtualbox-4-3-10

**** smplayer source code
   http://smplayer.sourceforge.net/

**** octave
   http://mirrors.ustc.edu.cn/gnu/octave/
   https://coderwall.com/p/wo***kw/ubuntu-installing-octave-fortran-***error

**** gmip
   http://www.gimp.org/
   http://www.gimp.org/
   http://download.gimp.org/pub/gimp/v******
   gimp: error while loading shared libraries: libgimpwidgets-******so.*** cannot open shared object file: No such file or directory

**** TODO wine
   https://www.winehq.org/
   sudo apt-get install flex bison

**** cmake
   http://www.cmake.org/
   https://github.com/Kitware/CMake

**** vim
    http://www.vim.org/

**** xmradio
sudo apt-get install libgtk-***dev

xmradio: error while loading shared libraries: libxmradio-core.so:
cannot open shared object file: No such file or directory

No plugins found! Check your VLC installation.

libvlc5; libvlccore5 ; vlc-data; vlc-nox; vlc-plugin-notify;
vlc-plugin-pulse

**** ros apt

**** qt todo source code, no binary
    http://download.qt.io/archive/qt/***************single/

**** texlive
    http://www.cnblogs.com/lienhua***p/***html

**** cvs apt

**** emacs-w***
+ http://blog.csdn.net/superwen_go/article/details/***
+ http://www.cnblogs.com/bamanzi/archive/*********emacs-stardict.html

**** TODO w3m
    + http://sourceforge.net/projects/w***/
    + http://sourceforge.net/p/w***/patches/***
    + http://sourceforge.net/p/w***/patches/


    make error:

    undefined reference to symbol 'XGetWindowAttributes'
   //usr/lib/i***linux-gnu/libX***so.*** error adding symbols: DSO missing from command line
   collect*** error: ld returned ***exit status

   apt

**** TODO sdcv

    make install error:

    CMake Error at cmake_install.cmake:60 (file):
    file INSTALL cannot find
    "/home/ben/Program/sdcv-0.5.0-beta2-Source/locale".

**** TODO stardict
http://stardict-4.sourceforge.net/
http://pan.baidu.com/s/1c01qNM4
http://dl.dbank.com/c0az7kwje9#

make failure, apt used
**** scrot
**** ditaa
    http://ditaa.sourceforge.net/
**** briss
    http://sourceforge.net/projects/briss/
**** gnupg
    https://www.gnupg.org/

**** doxygen
    http://www.stack.nl/~dimitri/doxygen/index.html

**** TODO wkhtmltopdf
https://github.com/TigerDWong/wkhtmltopdf

**** latex2html
https://www.ctan.org/pkg/latex2html?lang=en

**** wkhtmltopdf

源码安装失败，使用apt方式安装

**** xmradio
vlc
sourcecode
** Evernote                                                       :evernote:
*** 整理技巧

1. Evernote PC客户端(Ubuntu Wine) 生成目录，并寻出为HTML
2. Emacs打开HTML文件(w3m-find-file)
3. ORG拷贝 org-w3m-copy
4. 正则替换

#+BEGIN_EXAMPLE
 1. [[evernote:///view/11551545/s52/3002d5ec-ab74-4c3d-871e-7c07514daf80/3002d5ec-ab74-4c3d-871e-7c07514daf80/][string::npos - C++ Reference]]
https://app.yinxiang.com/shard/s52/nl/11551545/3002d5ec-ab74-4c3d-871e-7c07514daf80?title=string%3A%3Anpos%20-%20C%2B%2B%20Reference
#+END_EXAMPLE

*观察规律，正则替换*
#+BEGIN_EXAMPLE
  ^[0-9, ]*\..+view/\(.*\)/\(.*\)/\(.*\)/.*/\]\[\(.*\)\]\]$
  ,***** [[https://app.yinxiang.com/shard/\2/nl/\1/\3?title=\4][\4]]
#+END_EXAMPLE

** Kindle
** PDF                                                                 :pdf:
*** pdftohmtl                                              :html:pdftohtml:
https://github.com/coolwanglu/pdf2htmlEX
*** pptx to pdf                                                       :ppt:

1. pptx -> odt
   *$ libreoffice --headless --convert-to odt demo.pptx*
2. odt -> pdf
   *$ unoconv -f pdf demo.odt*  # 继续使用libreoffice也可以

*** PDF提取矢量图片

Adobe专业版, 没有版权。

Foxit PDF Editor 也可。

可以利用PDF作为中介转换格式emf, wmf(矢量清晰格式)。

用途不多，毕竟图片多为 *位图*
1. 提取LOGO
2. 提取数学图形

*** wkhtmltopdf                                      :wkhtmltopdf:pdf:html:

CLOCK: [2015-11-25 三 09:26]--[2015-11-25 三 09:37] =>  0:11

**** reference
+ [[http://wkhtmltopdf.org/][Homepage]]
+ [[https://github.com/wkhtmltopdf/wkhtmltopdf][GitHub]]
+ [[http://wkhtmltopdf.org/libwkhtmltox/][doxygen]]
+ [[http://stackoverflow.com/questions/10981960/wkhtmltopdf-patched-qt][stackoverflow]]
+ [[http://park.jobdeer.com/discussion/10/wkhtmltopdf%E4%B8%AD%E6%96%87%E5%8F%82%E6%95%B0][wkhtmltopdf选项中文说明]]
+ [[http://wkhtmltopdf.org/usage/wkhtmltopdf.txt][document]]


**** intro

1. what

   wkhtmltopdf and wkhtmltoimage are open source (LGPLv3) command line
   tools to render HTML into PDF and various image formats using the
   QT Webkit rendering engine.

   wkhtmltopdf/wkhtmtoimage 是开源的命令行工具，用于将HMTL渲染成PDF和
   多种图片格式。 它使用Qt Webkit作为渲染引擎。

2. 安装

   有源码，但不推荐以源码方式安装。（没有必要深入研究的东西不要瞎折腾，
   将精力花在更重要的地方）

   *apt-get 方式安装*

3. 使用

   *wkhtmltopdf [GLOBAL OPTION]... [OBJECT]... <output file>*

   + [object] 为输入支持，支持链接(link)形式，也支持文件(html)形式。



**** 选项

+ --allow <path>  允许加载从指定的文件夹中的文件或文件（可重复）
+ --book*  设置一会打印一本书的时候，通常设置的选项
+ --collate  打印多份副本时整理
+ --cookie <name> <value>  设置一个额外的cookie（可重复）
+ --cookie-jar <path>  读取和写入的Cookie，并在提供的cookie jar文件
+ --copies <number>  复印打印成pdf文件数（默认为1）
+ --cover* <url>  使用HTML文件作为封面。它会带页眉和页脚的TOC之前插入
+ --custom-header <name> <value>  设置一个附加的HTTP头（可重复）
+ --debug-javascript  显示的javascript调试输出
+ --default-header*  添加一个缺省的头部，与页面的左边的名称，页面数到右边，例如： --header-left '[webpage]' --header-right '[page]/[toPage]'  --header-line
+ --disable-external-links*  禁止生成链接到远程网页
+ --disable-internal-links*  禁止使用本地链接
+ --disable-javascript  禁止让网页执行JavaScript
+ --disable-pdf-compression*  禁止在PDF对象使用无损压缩
+ --disable-smart-shrinking*  禁止使用WebKit的智能战略收缩，使像素/ DPI比没有不变
+ --disallow-local-file-access  禁止允许转换的本地文件读取其他本地文件，除非explecitily允许用 --allow
+ --dpi <dpi>  显式更改DPI（这对基于X11的系统没有任何影响）
+ --enable-plugins  启用已安装的插件（如Flash
+ --encoding <encoding>  设置默认的文字编码
+ --extended-help  显示更广泛的帮助，详细介绍了不常见的命令开关
+ --forms*  打开HTML表单字段转换为PDF表单域
+ --grayscale  PDF格式将在灰阶产生
+ --help  Display help
+ --htmldoc  输出程序HTML帮助
+ --ignore-load-errors  忽略claimes加载过程中已经遇到了一个错误页面
+ --lowquality  产生低品质的PDF/ PS。有用缩小结果文档的空间
+ --manpage  输出程序手册页
+ --margin-bottom <unitreal>  设置页面下边距 (default 10mm)
+ --margin-left <unitreal>  将左边页边距 (default 10mm)
+ --margin-right <unitreal>  设置页面右边距 (default 10mm)
+ --margin-top <unitreal>  设置页面上边距 (default 10mm)
+ --minimum-font-size <int>  最小字体大小 (default 5)
+ --no-background  不打印背景
+ --orientation <orientation>  设置方向为横向或纵向
+ --page-height <unitreal>  页面高度 (default unit millimeter)
+ --page-offset* <offset>  设置起始页码 (default 1)
+ --page-size <size>  设置纸张大小: A4, Letter, etc.
+ --page-width <unitreal>  页面宽度 (default unit millimeter)
+ --password <password>  HTTP验证密码
+ --post <name> <value>  Add an additional post field (repeatable)
+ --post-file <name> <path>  Post an aditional file (repeatable)
+ --print-media-type*  使用的打印介质类型，而不是屏幕
+ --proxy <proxy>  使用代理
+ --quiet  Be less verbose
+ --read-args-from-stdin  读取标准输入的命令行参数
+ --readme  输出程序自述
+ --redirect-delay <msec>  等待几毫秒为JS-重定向(default 200)
+ --replace* <name> <value>  替换名称,值的页眉和页脚（可重复）
+ --stop-slow-scripts  停止运行缓慢的JavaScripts
+ --title <text>  生成的PDF文件的标题（第一个文档的标题使用，如果没有指定）
+ --toc*  插入的内容的表中的文件的开头
+ --use-xserver*  使用X服务器（一些插件和其他的东西没有X11可能无法正常工作）
+ --user-style-sheet <url>  指定用户的样式表，加载在每一页中
+ --username <username>  HTTP认证的用户名
+ --version  输出版本信息退出
+ --zoom <float>  使用这个缩放因子 (default 1)

*** pdfinfo                                                   :pdfinfo:pdf:

**** reference
+ [[http://linuxcommand.org/man_pages/pdfinfo1.html][Linux command: pdfinfo]]
**** intro
1. NAME

   pdfinfo - Portable Document Format (PDF) document information
   extractor.

2. SYNOPSIS

   *pdfinfo [options] [PDF-file]*

3. DESCRIPTION

   Pdfinfo prints the contents of the ´Info’ dictionary (plus  some
   other  useful information) from a Portable Document Format (PDF)
   file.

   The ´Info’ dictionary contains the following values:
   + title
   + subject
   + keywords
   + author
   + creator
   + producer
   + creation date
   + modification date

   In addition, the following information is printed:
   + tagged (yes/no)
   + page count
   + encrypted flag (yes/no)
   + print and copy permissions (if encrypted)
   + page size
   + file size
   + linearized (yes/no)
   + PDF version
   + metadata (only if requested)

**** 手记

$ pdfinfo --help

#+BEGIN_EXAMPLE
  pdfinfo version 0.24.5
  Copyright 2005-2013 The Poppler Developers - http://poppler.freedesktop.org
  Copyright 1996-2011 Glyph & Cog, LLC
  Usage: pdfinfo [options] <PDF-file>
    -f <int>          : first page to convert
    -l <int>          : last page to convert
    -box              : print the page bounding boxes
    -meta             : print the document metadata (XML)
    -rawdates         : print the undecoded date strings directly from the PDF file
    -enc <string>     : output text encoding name
    -listenc          : list available encodings
    -opw <string>     : owner password (for encrypted files)
    -upw <string>     : user password (for encrypted files)
    -v                : print copyright and version info
    -h                : print usage information
    -help             : print usage information
    --help            : print usage information
    -?                : print usage information
#+END_EXAMPLE


#+BEGIN_SRC sh :results output :exports both
pdfinfo ~/Wally/Journal/journal.pdf
#+END_SRC

#+RESULTS:
#+begin_example
Creator:        Emacs 24.4.1 (Org mode 8.2.10)
Producer:       xdvipdfmx (20140317)
CreationDate:   Wed Nov 25 09:40:33 2015
Tagged:         no
Form:           none
Pages:          3
Encrypted:      no
Page size:      612 x 792 pts (letter)
Page rot:       0
File size:      138622 bytes
Optimized:      no
PDF version:    1.5
#+end_example

*** pdfoutline
*** pdfoutline                                             :pdfoutline:pdf:
**** reference
+ [[http://manpages.ubuntu.com/manpages/hardy/man1/pdfoutline.1.html][ubuntu man]]
+ [[http://sourceforge.net/projects/fntsample/?source=typ_redirect][sourceforge]]

**** intro
1. what

   pdfoutline is a part of *fntsample*, which can add outlines to pdf
   files.

   pdfoutline - *add outlines (aka bookmarks) to PDF files*

   给PDF文件添加大纲/目录

2. 安装
   + $ sudo apt-get install fntsample
   + sourcecodae

3. Usage

   *pdfoutline input.pdf outlines.txt output.pdf*

   pdfoutline accepts no options.

4. DESCRIPTION

   pdfoutline reads input file given as first argument, adds outlines
   from text file given as second argument, and saves result to file
   with  name given as third argument.

   File with outlines information should consist of lines in the following
   format: *<level> <page> Outline text*

   <level> and <page> should be integers.  Each field should be  separated
   by  *exactly one space symbol*.  All values for <level> should be greater
   or equal than that of the first line.  Page numeration starts with 1.

   Outlines file can contain comments that start with # in  first  column.
   Comments and empty lines are ignored.


5. EXAMPLES

   Here is example of outlines data file:
   #+BEGIN_EXAMPLE
     0 1 Document title
     1 1 Chapter 1
     2 1 Chapter 1.1
     2 2 Chapter 1.2
     1 3 Chapter 2
   #+END_EXAMPLE

   Using this file will result in outlines like the following:

   #+BEGIN_EXAMPLE
     +-Chapter 1
     | +-Chapter 1.1
     | +-Chapter 1.2
     +-Chapter 2
   #+END_EXAMPLE

*** gs                                                        :gs:pdf:tool:

**** intro
*ghostscript* : an interpreter for the PostScript language and for
PDF.

*解释器*

**** man
$ gs -help

#+BEGIN_EXAMPLE
  GPL Ghostscript 9.10 (2013-08-30)
  Copyright (C) 2013 Artifex Software, Inc.  All rights reserved.
  Usage: gs [switches] [file1.ps file2.ps ...]
  Most frequently used switches: (you can use # in place of =)
   -dNOPAUSE           no pause after page   | -q       `quiet', fewer messages
   -g<width>x<height>  page size in pixels   | -r<res>  pixels/inch resolution
   -sDEVICE=<devname>  select device         | -dBATCH  exit after last file
   -sOutputFile=<file> select output file: - for stdout, |command for pipe,
                                           embed %d or %ld for page #
  Input formats: PostScript PostScriptLevel1 PostScriptLevel2 PostScriptLevel3 PDF
  Default output device: x11alpha
  ...
#+END_EXAMPLE


**** 转换pdf为ppt                                             :ppt:office:

The desired result can also be achieved without proprietary tools. If
you have GhostScript installed, you can convert your PDF presentation
into a set of JPG images using:

#+BEGIN_EXAMPLE
gs -dNOPAUSE -dBATCH -dSAFER -dGraphicsAlphaBits=4  \
   -dTextAlphaBits=4 -sDEVICE=jpeg -r300 \
   -sOutputFile='page-%00d.jpg' YOURFILE.pdf
#+END_EXAMPLE

Then, with the plugin for OpenOffice/LibreOffice create a presentation
where each image fills exactly one slide. You can also easily keep the
order of the pages by choosing the plugin option "natural sorting".


*Edit -> Link -> 断开链接*  否则以链接形式插入。

***** 小结
1. 使用gs转换为图片
2. 将图片插入LibreOffice中
3. 保存时断开链接

**** Merge PDF

*多个PDF文件的合并gs* :

#+begin_latex
\begin{minted}[frame=single, mathescape]{sh}
gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=out.pdf  *.pdf
\end{minted}
#+end_latex

就会生成一个名为out.pdf的文件.但要保证当前目录下没有out.pdf这个文件.

**** reference

+ [[http://www.ghostscript.com/][Homepage]]
+ [[http://superuser.com/questions/268244/how-to-convert-pdf-to-ppt-or-odp][convert pdf to ppt]]
+ [[http://stackoverflow.com/questions/8158584/ghostscript-to-merge-pdfs-compresses-the-result][stackoverflow: gs to merge PDFs *compresses* the result]]

** 文档工具
*** antiword                                                     :antiword:

参考:
+ [[http://en.wikipedia.org/wiki/Antiword][Wiki]]
+ [[http://www.winfield.demon.nl/][Homepage]]
+ [[http://www.emacswiki.org/emacs/AntiWord][EmacsWiki]]
+ [[http://manpages.ubuntu.com/manpages/gutsy/man1/antiword.1.html][Ubuntu Manpage]]

**** What?
*Antiword* is a free software reader for proprietary Microsoft Word
documents, and is available for most computer platforms. Antiword can
convert the documents from *Microsoft Word version 2, 6, 7, 97, 2000,
2002 and 2003* to *plain text, PostScript, PDF, and XML/DocBook*
(experimental).

Antiword is a free MS Word reader for Linux and RISC OS. There are
ports to FreeBSD, BeOS, OS/2, Mac OS X, Amiga, VMS, NetWare, Plan9,
EPOC, Zaurus PDA, MorphOS, Tru64/OSF, Minix, Solaris and DOS. Antiword
converts the binary files from Word 2, 6, 7, 97, 2000, 2002 and 2003
to plain text and to PostScript TM.
**** NAME
antiword - show the text and images of MS Word documents
**** SYNOPSIS
antiword [ options ] wordfiles
**** DESCRIPTION
Antiword  is  an  application  that displays the text and the images
of Microsoft Word documents.
A wordfile named - stands for a Word document read  from  the
standard input.
Only  documents  made  by  MS Word version 2 and version 6 or later
are supported.
**** OPTIONS
***** -a papersize
Output in Adobe PDF form. Printable on paper  of  the  specified
size:  10x14,  a3, a4, a5, b4, b5, executive, folio, legal, let‐
ter, note, quarto, statement or tabloid.
***** -f
Output in formatted text form. That  means  that  bold  text  is
printed  like *bold*, italics like /italics/ and underlined text
as _underlined_.
***** -h
Give a help message.
***** -i image level
The image level determines how images will be shown.

0: Use non-standard extensions from Ghostscript. This output may
   not print on any PostScript printer, but is useful in case no
   hard copy is needed. It is also useful  when  Ghostscript  is
   used  as  a  filter  to  print  a  PostScript  file to a non-
   PostScript printer.

1: Show no images.

2: PostScript level 2 compatible. (default)

3: PostScript level 3 compatible. (EXPERIMENTAL,  Portable  Net‐
   work Graphics (PNG) images are not printed correctly)
***** -m mapping file
This  file is used to map Unicode characters to your local char‐
acter set.  The default mapping file depends on the locale.

***** -p papersize
Output in PostScript form. Printable on paper of  the  specified
size:  10x14,  a3, a4, a5, b4, b5, executive, folio, legal, let‐
ter, note, quarto, statement or tabloid.
***** -r
Include text removed by the revisioning system.
***** -s
Include text with the so-called "hidden text" attribute.
***** -t
Output in text form. (default)
***** -w width
In text mode this is the line width in characters.  A  value  of
zero puts an entire paragraph on a line, useful when the text is
to used as  input  for  another  wordprocessor.  This  value  is
ignored in PostScript mode.
***** -x document type definition
Output  in XML form. Currently the only document type definition
is db (for DocBook).
***** -L
In PostScript mode: use landscape mode.

**** FILES
***** Mapping files like 8859-1.txt
Antiword looks for its mapping files in  three  directories,  in
the order given:
(1) The directory specified by $ANTIWORDHOME
(2) The directory specified by $HOME/.antiword
(3) Directory /usr/share/antiword
***** The fontnames file
Antiword will look for its fontname file in the same directories
as used for the mapping files.
The fontnames file contains  the  translation  table  from  font
names used by MS Word to font names used by PostScript.

***** NOTE
Antiword cannot tell the difference between a file that does not
exist and a file that cannot be opened for reading.

***** ENVIRONMENT
Antiword uses the environment variable ‘‘ANTIWORDHOME’’  as  the
first directory to look for its files. Antiword uses the environment
variable ‘‘HOME’’ to find the user’s home directory. When in text
mode  it  uses the  variable  ‘‘COLUMNS’’ to set the width of the
output (unless over‐ridden by the -w option).

Antiword uses the environment variables  ‘‘LC_ALL’’,
‘‘LC_CTYPE’’  and ‘‘LANG’’ (in that order) to get the current
locale and uses this infor‐mation to select the default mapping file.

*** chm文档查看                                                       :chm:

+ chmsee  # 没有
+ Kchmviewer
+ /Xchm/    # OK, 中文支持没有问题
+ chmviewer
+ gnochm  # 没有

*** 知网                                                           :知网:caj:
参考:
+ [[http://www.360doc.com/content/12/0925/16/19671_238111948.shtml]]

**** CAJ
+ wine 安装 CAJviewer
+ 在CAJviewer中通过cups打印为pdf,方便在Emacs中浏览
+ 在CAJviewer中另存为txt文档

**** wine安装知网阅读软件

源码安装的wine安装CAJviewer没有问题，使用时出现 unable to create a
MSXML instance错误

可能是缺少微软库依赖。ArchLinux查得 Some applications (e.g. Office
2003/2007) require the MSXML library to parse HTML or XML, in such
cases you need to install
lib32-libxml2. https://wiki.archlinux.org/index.php/Wine

但libxml2已经安装

卸载源码安装的wine，使用apt-get方式安装后，问题解决。

**** caj to pdf

+ http://www.zhihu.com/question/21103230

1. 虚拟打印机转换为pdf或xps格式
2. 少瞎折腾

为什么不直接下载PDF，可以从 *万方* 上直接下载PDF

*** cups-pdf: pdf虚拟打印机
参考:
+ [[http://blog.chinaunix.net/uid-488742-id-2113697.html]]

1. 安装 apt-get install cups-pdf
2. 增加打印机,在系统设置中
3. 配置文件: /etc/cups/cups-pdf.conf
   + 选项out: 输出文件夹
*** calibre                                                       :calibre:
参考:
+ [[http://zh.wikipedia.org/wiki/Calibre][wiki]]

**** What is calibre?
+ 电子书软件套装
+ 可以用来 *组织、存放、以及管理* 电子书
+ 支持大多数的电子书格式
+ 自由开源
+ 支持与许多流行的电子书阅读器进行同步
+ 并可能在DRM[fn:1503151127]的限制下转换电子书的格式。
+ 注: 即使是写在句子的开头也是一律小写

**** ebook-convert
+ 用法: *ebook-convert input_file output_file [options]*
+ 功能: 转换不同格式的电子书。
+ 说明:
  1) input_file 表示输入文件，output_file 表示输出文件, *这两者作为命
     令行参数必须指定到最前面*
  2) 输出的电子书格式可由 output_file 的扩展名得到。同时 output_file
     也可以是一种以 .EXT 为扩展名的特殊格式。在这种情况下，输出文件的
     名称则使用输入文件的名称。注意：文件名不能以连字号作为开头。如果
     output_file 不含扩展名，那么它将被视为一个目录并将会在该目录下生
     成 HTML 格式的“开放式电子书(OEB)”。这些文件会被视为正常文件而被
     输出插件所识别。

*** evince
+ 格式: evince [选项] [文件]   # GNOME文档查看器

*** unoconv                                      :unoconv:pdf:

**** reference
+ [[http://www.cnblogs.com/xkfz007/articles/2182480.html][Linux下Word转换PDF及多个PDF合并]]
+ [[http://dag.wieers.com/home-made/unoconv/][HomePage]]


**** intro
unoconv converts between any document format that OpenOffice
understands. It uses *OpenOffice's UNO bindings* for non-interactive
conversion of documents.

转换文档格式的命令行工具。


Supported document formats include Open Document Format (.odt), MS
Word (.doc), MS Office Open/MS OOXML (.xml), Portable Document Format
(.pdf), HTML, XHTML, RTF, Docbook (.xml), and more.

在Linux中常常涉及到多种文档格式，如doc、txt、html、rtf等等。为了方便文
件传递，就可能需要在各种格式之间进行转换。OpenOffice.Org可以方便的打
开多各文档格式并按需进行转换* ，但要一次处理大量文件或要编写脚本进行转
换时，仅用OpenOffice就难以胜任了。


用unoconv就可以轻松地实现用OpenOffice可以打开的文档的转换.
*unoconv -f pdf myDoc.doc*
进行转换了.以上命令即会生成一个名为 myDoc.pdf 的 pdf 文件。

**** 批量转换

*批量转换需要结合find命令或脚本使用，使用时需注意最好使用C/S模式以加快
速度*
+ unoconv --listener &
+ unoconv -f pdf some-document.odt
+ unoconv -f doc other-document.odt
+ unoconv -f jpg some-image.png
+ unoconv -f xsl some-spreadsheet.csv

**** unocov 转换 word 文档为 PDF                                    :word:

unocov 是OpenOffice的命令行工具，能转换 OpenOffice 能够识别的所有格式

/$ unocov -f pdf file.doc(x)/

1. 效率很高，比使用虚拟打印机功能要快，
2. Ubuntu下字体可能不一致，不过无所谓

** Multimedia
*** 视频格式转换
Winff是ffmpeg的GUI封装。

error: x-terminal-emulator: error: Additional unexpected arguments
found: ['&']

http://ubuntuforums.org/showthread.php?t=1541808

Look in WinFF's edit > preferences > linux > set terminal options
Change it from e to x, or vice versa. Then try it again.
*** 截图工具
+ scrot
+ gnome-screenshot

*** 屏幕录像软件
+ https://linuxtoy.org/archives/top-5-screen-recorder-for-linux.html


+ Istanbul

  使用 Istanbul， 你可以将 Linux 屏幕上的一切操作过程录制下来 。
  Istanbul 既能够按照你的需要录制全屏 、 区域或者窗口 ， 也可以录制声
  音和鼠标指针 ， 最终会生成 Ogg Theora 格式的视频文件 。

+ Wink

  Wink 是录制 Flash 视频演示的极好工具 ， 除支持 Linux 平台外 ， 也能
  够在 Windows 系统上运行 。 你可以使用 Wink 为所录制的文件添加文字说
  明和声音旁白 。

+ Xvidcap

  Xvidcap 支持生成 avi、mpeg、asf、flv、swf、mov 等视频格式 ， 可以应
  用在各种场合 。 录制的区域也可以随意选择 ， 显得非常方便 。

+ Vnc2swf

  Vnc2swf 是继 Wink 外适合在 Linux 中使用的另一个 Flash 录制工具 ， 但
  比 Wink 稍微要难用点 ， 而且也没有 Wink 功能全面 。

+ Recordmydesktop

  Recordmydesktop 功能主要有 ： 可录制全屏 、 窗口 ， 也可以录制选择的
  区域 ； 除了能够录制视频的基本功能之外 ， 还能够录制音频 ； 有一些录
  制的参数可以调整 ； 生成的视频格式为 ogg。 它默认提供 GTK+ 界面 ，
  另外也有一个适合 KDE 桌面环境的 reKordmydesktop。

+ 使用：

  验证使用Recordmydesktop效果可以，同时录制了双屏，满足需求。简单地试
  用了下命令行，没加任何参数。

  有一个原则，即不要在这些并不重要的东西上花费过多的时间。

*** Linux图片工具
1. *eog* (eye of gnome)
   + 在linux的终端命令行下可以用命令打开图片.
   + 格式：eog a.png
   + hompage  http://projects.gnome.org/eog/

2. ImageMagick

   + homepage: http://www.imagemagick.org/

   + ImageMagick

     ImageMagick® is a software suite to create, edit, compose, or
     convert bitmap images. It can read and write images in a variety
     of formats (over 200) including PNG, JPEG, JPEG-2000, GIF, TIFF,
     DPX, EXR, WebP, Postscript, PDF, and SVG. Use ImageMagick to
     resize, flip, mirror, rotate, distort, shear and transform
     images, adjust image colors, apply various special effects, or
     draw text, lines, polygons, ellipses and Bézier curves.

     ImageMagick是一套功能强大、稳定、，用来创建、编辑、合成图片而且免
     费的工具集和开发包。

   + 特点
     + 开源
     + 跨平台

3. GIMP(photoshop)

4. 图像转换

   1) eps -> pdf
      + eps: Encapsulated PostScript
      + $ epstopdf filename.eps
      + epstopdf是一个实用的perl脚本，调用ghostscript执行实际的转换工
        作。

   2) 所有其它形式转换
      + *convert* 命令通常可以转换任意格式的图像，包括eps.
      + convert 是ImageMagick图形处理套件的一部分。
      + e.g.
        #+BEGIN_EXAMPLE
        $ convert filename.tiff filename.pdf
        #+END_EXAMPLE

*** convert

http://www.jincon.com/archives/249/
http://www.jincon.com/archives/248/

*convert* 是 /imagemagick/ 软件包中的一个命令。它可以读取、转换、写入多种格式
的图片。图片切割、颜色替换、各种效果的应用，图片的旋转、组合，文本，直
线，多边形，椭圆，曲线，附加到图片伸展旋转。

**** 选项

1. -resize widthxheight{%} {@} {!} {<} {>} {^}
   1) 默认时，宽度和高度表示要最终需要转换图像的 *最大尺寸* ，同时
      Convert会 *控制图片的宽和高* ，保证图片按比例进行缩放。
   2) 图片无需保持原有比例，可以在宽高后面加上一个感叹号!
   3) 只指定高度，图片会转换成指定的高度值，而宽度会按原始图片比例进行转换
   4) 默认都是使用像素作为单位，也可以使用百分比来形象图片的缩放
   5) 使用 @ 来制定图片的像素个数
      #+BEGIN_EXAMPLE
        convert -resize “10000@” src.jpg dst.jpg

        # 此命令执行后，dst.jpg图片大小为(115×86)，
        # 图片保持原有比例(115×86= 9080 < 10000)。

      #+END_EXAMPLE
   6) 当原始文件大于指定的宽高时，才进行图片放大缩小，可使用>命令后缀
   7) 当原始文件小于指定的宽高时，才进行图片放大转换，可使用<命令后缀。
   8) 使用^命令后缀可以使用宽高中较小的那个值作为尺寸

2. -quality

3. -sample 生成缩略图
**** 示例
#+BEGIN_EXAMPLE
  #! /bin/sh
  for i in `ls *.jpg`;
  do
  convert -resize 50% "$i" "${i%.jpg}.png";
  done
#+END_EXAMPLE

**** 使用convert批量处理图片
imagemagick的命令convert可以完成此任务,其参数-resize用来改变图片尺寸,
可以直接指定像素值,也可以指定缩放百分比。而如果想降低图片的质量,可以用
convert的-quality参数,质量值为0-100之间的数值,数字越大,质量越好,一般指
定70-80,基本上看不出前后的差别。

用下面的命令批量修改图片分辨率为原来的1/4大小,同时保持原图片比例
#+BEGIN_EXAMPLE
$find ./ -regex ‘.*\(jpg\|JPG\)’ -exec convert -resize 50%x50% {} {} \;
#+END_EXAMPLE


用规则表达式把jpg和JPG后缀图片一网打尽,{}代表查找到的文件,这里没有改变
convert前后的文件名,最后是转义的分号表示一个迭代的处理完成。

也可以用以下命令
#+BEGIN_EXAMPLE
$find ./ -name ‘*jpg’ -o -name ‘*JPG’ -exec convert -resize 50%x50% {} {} \;
#+END_EXAMPLE

*** scrot
1. what is scrot
   Scrot is a minimalistic command ine screen capturing application.

   It allows substantial degree of flexibility by specifying
   parameters on command line, including the ability to invoke a
   third-party utility to manipulate the resulting screenshot.

2. Features
   + limit the scope fo capturing
   + set the delay
   + specify the filename template using wildcards
   + create thumbnal
   + specify the quality
   + follow the UNIX philosophy
   + CLT赋予了其远程运行的能力

3. Options
   + -h, --help   help message
   + -v, --version    display version number
   + -b, --border    include window bordre
   + -c, --count    display a countdown timer when used with delay
   + -d, --delay    delay the screen capturing
   + -e command    execute command after taking screenshot
   + -q, --quality    set the quality/compression
   + -s, --select    interactively select a windwo or rectangle with the mouse
   + -t, --thumb percentage    generate a thumbnail of the given ratio

4. -e 参数位标识
   + $f    图像文件名，包括路径
   + $f    图像文件名
   + $s    图像文件大小
   + $p    图像像素
   + $h    图像高度
   + $w    图像宽度
   + $t    图像格式
   + $$    字符$

5. Examples
   #+BEGIN_EXAMPLE
     $ scrot ~/fullscreen.png  # 全屏截图
     $ scrot -s ~/region.png   # 抓取窗口
     $ scrot -cd 10 ~/demo.png # 延时截图
     $ scrot -t 10% ～/thumb.png # 同时生成缩略图
     $ scrot -s ~/todeel.png -e 'gimp $f'  # 完成截图后处理
   #+END_EXAMPLE

*** VGA DVI HDMI
+ http://bbs.mydigit.cn/simple/?t523987.html


目前在高清设备中，主要的接口有DVI、HDMI、VGA接口，其中VGA传输的是模拟
视频信号，DVI传播的是数字视频信号，HDMI可以同时传输数字视频信号和数字
音频信号。在现在的计算机和电视等设备中，我们经常可以看到这三种接口，很
多用户存在疑问，这三种接口之间有什么区别呢?

DVI接口是在1999年推出的接口标准。DVI接口的传输信号采用全数字格式，与之
对应的是采用模拟信号的VGA接口。VGA和DVI的区别，首先VGA模拟信号的传输比
较麻烦，首先是将电脑内的数字信号转换为模拟信号，将信号发送到LCD显示器，
由显示器再将该模拟信号转换为数字信号，形成画面展示在大家面前。正因为如
此，中间的信号丢失严重，虽然可以通过软件的方法修复部分画面，但是随着显
示器的分辨率越高画面就会越模糊。一般模拟信号在超过1280×1024分辨率以上
的情况下就会出现明显的误差，分辨率越高越严重。

VGA接口应用范围非常广泛，是三种接口中最先推出的标准，VGA(Video
Graphics Array)接口，也叫D-Sub接口。虽然液晶显示器可以直接接收数字信号，
但很多低端产品为了与VGA接口显卡相匹配，因而采用VGA接口。VGA接口是一种D
型接口，上面共有15针空，分成三排，每排五个。VGA接口是显卡上应用最为广
泛的接口类型，绝大多数的显卡都带有此种接口。

HDMI (High-Definition Multimedia Interface) ，常被称作高清晰度多媒体接
口，是终结以往影音分离传输的全新接口，其最大传输速度可达5Gb/s，除影像
数据外，更可同时传输高达8声道的音讯信号。这种非压缩式的数字数据传输，
可有效降低数/类转换所造成的信号干扰与衰减。HDMI是首个支持在单线缆上传
输，不经过压缩的全数字高清晰度、多声道音频和智能格式与控制命令数据的数
字接口。HDMI接口由Silicon Image美国晶像公司倡导，联合索尼、日立、松下、
飞利浦、汤姆逊、东芝等八家著名的消费类电子制造商联合成立的工作组共同开
发的。HDMI最早的接口规范HDMI1.0于2002年12月公布，目前的最高版本是于今
年6月发布的HDMI1.3规范。

HDMI源于DVI接口技术，它们主要是以美国晶像公司的TMDS信号传输技术为核心，
这也就是为何HDMI接口和DVI接口能够通过转接头相互转换的原因。美国晶像公
司是HDMI八个发起者中唯一的集成电路设计制造公司，是高速串行数据传输技术
领域的领导厂商。

目前的高端显卡上一般有VGA、DVI、HDMI接口，一般的显示卡VGA、DVI接口；目
前生产的大屏幕LED显示器上有VGA、HDMI接口（如三星24寸），中型LED显示器
有VGA、DVI接口（比如三星21寸），选购连接线前请注意观察显示卡和显示器接
口的匹配，接口型号不同时，可以选择转接线。

*** 双显示器
+ http://blog.chinaunix.net/uid-170694-id-2833685.html
+ http://imtx.me/archives/1695.html
+ http://dpinglee.blog.163.com/blog/static/1440977532010488594461/


1. 配置工具：xrandr

2. 快捷键：
   HOME+NUM 将焦点切换到lauch区对应的应用程序
*** 音乐播放器
1. 笔记本Ubuntu系统安装foobar并配置播放列表, 有悖于纯粹性的原则.
2. rhythmbox和虾米电台就足够了,这些事情上没有花费过多精力的必要

*Foobar最爱*

*** foobar使用                                                     :foobar:
+ wine安装
+ 启动
  - 命令行方式，有问题
  - 链接，有问题
  - *直接在目录下双击图标，没问题* ，可能和启动目录有关

*** Linux 屏幕录像软件

**** [[+ https://linuxtoy.org/archives/top-5-screen-recorder-for-linux.html][工具软件]]

+ Istanbul

  使用 Istanbul， 你可以将 Linux 屏幕上的一切操作过程录制下来 。
  Istanbul 既能够按照你的需要录制全屏 、 区域或者窗口 ， 也可以录制声
  音和鼠标指针 ， 最终会生成 Ogg Theora 格式的视频文件 。

+ Wink

  Wink 是录制 Flash 视频演示的极好工具 ， 除支持 Linux 平台外 ， 也能
  够在 Windows 系统上运行 。 你可以使用 Wink 为所录制的文件添加文字说
  明和声音旁白 。

+ Xvidcap

  Xvidcap 支持生成 avi、mpeg、asf、flv、swf、mov 等视频格式 ， 可以应
  用在各种场合 。 录制的区域也可以随意选择 ， 显得非常方便 。

+ Vnc2swf

  Vnc2swf 是继 Wink 外适合在 Linux 中使用的另一个 Flash 录制工具 ， 但
  比 Wink 稍微要难用点 ， 而且也没有 Wink 功能全面 。

+ *Recordmydesktop*

  Recordmydesktop 功能主要有 ： 可录制全屏 、 窗口 ， 也可以录制选择的
  区域 ； 除了能够录制视频的基本功能之外 ， 还能够录制音频 ； 有一些录
  制的参数可以调整 ； 生成的视频格式为 ogg。 它默认提供 GTK+ 界面 ，
  另外也有一个适合 KDE 桌面环境的 reKordmydesktop。

**** 小结

1. 验证使用Recordmydesktop效果可以，同时录制了双屏，满足需求。简单地试
   用了下命令行，没加任何参数。

2. 有一个原则，即 *不要在这些并不重要的东西上花费过多的时间。*

** 学习工具
*** dia
**** overview
Dia is a program to draw structured diagrams.

特性：
+ 跨平台
+ 开源 GPL

**** Install
+ apt-get(OK)
+ 源码: 不会

Download Page: http://dia-installer.de/download/linux.html


Additional shapes: http://dia-installer.de/shapes/index.html.en

**** 中文输入问题
http://yanue.net/post-117.html

$ sudo vi /usr/bin/dia
然后把dia-gnome --integrated "$@"修改成 dia-gnome  "$@"

重新启动dia，输入法选择系统默认（我的系统输入法是ibus），就可以输入中
文了不过这样一改，工具条变成浮动的了...

**** dia Assorted Geometric Shapes narrow
dia的图形文件类型后缀名为.shape，这是一种XML定义的文件，其中有个tag为
aspectradio, 其属性type可以是fixed和free, 定义了缩放时的行为。

**** 导出问题
导出为PDF时，可能会分块放在几页PDF上，不明所以

png有多种不同格式，前面的一种在处理英文字符时行为古怪

jpeg导出没有问题

**** why
Office Visio是一款优秀而强大的流程图设计工具，不能因为使用Linux而对
Windows产品产生鄙夷，要纯粹，要包容，去掉内心的杂质(心意萌动时便知，此
时是格物致知的最好时刻)。

但要相信，windows能做到的，Linux多数能够做到，而且更加自由（Windows能
做而Linux做不到的，一则是自己能力弱，二则是没有需求）。

**** Linux下流程图设计工具

http://tech.sina.com.cn/s/2012-03-16/14166844479.shtml#artibodyTitle

1. DIA Diagram Editor
   + 功能强大
   + 跨平台
   + 原生支持中文
   + 安装文件小(<20M)
   + 用法繁琐，但综合性能最佳
   + 免费
   + 支持多种格式：EPS，SVG，DXF(Autocad),CGM,WMF,PNG,JPEG,VDX(MS
     Visio).
2. OpenOffice
   开源免费的矢量绘图软件。
3. Graphviz
   + 贝尔实验室
   + 历史久远
   + 所想即所得
   + 使用DOT脚本绘图
   + 功能强大
4. Kivio
   + 开源办公套件KOffice的一部分，用户界面类似Visio，有所增强，允许分割窗口绘制。
   + 支持Python脚本模板创作
   + 与DIA兼容
   + 只面向Linux
**** DIA

参考:
+ http://zh.wikipedia.org/wiki/Dia
+ https://wiki.gnome.org/Apps/Dia
+ http://www.seanet.com/~hgg9140/comp/diatut/all/all.html


1. Dia是什么?
  Dia是开放源代码的流程图,是GNU计划的一部分.

  From DIA homepage:

  Welcome to Dia's new homepage. Dia is a GTK+ based diagram creation
  program for GNU/Linux, MacOS X, Unix, and Windows, and is released
  under the GPL license.

  Dia is roughly inspired by the commercial Windows program 'Visio'
  though more geared towards informal diagrams for casual use. It can
  be used to draw many different kinds of diagrams. It currently has
  special objects to help draw entity relationship diagrams, UML
  diagrams, flowcharts, network diagrams, and many other diagrams. It
  is also possible to add support for new shapes by writing simple XML
  files, using a subset of SVG\footnote{可缩放矢量图形（英语：Scalable
    Vector Graphics，SVG）是基于可扩展标记语言（XML），用于描述二维矢
    量图形的一种图形格式。SVG由W3C制定，是一个开放标准。} to draw the
  shape.

  It can load and save diagrams to a customo XML format,can export
  diagrams to a number of formats including EPS,SVG,XFIG,WMF and
  PNG,and can print diagrams.

2. 基本使用
   + 左对齐    S-M-l
   + 右对齐    S-M-r
   + 水平居中对齐    S-M-c
   + 顶部对齐    S-M-t
   + 底部对齐    S-M-b
   + 垂直居中对齐    S-M-m
   + 水平平均分布    S-M-h
   + 垂直平均分布    S-M-v
   + 相邻的    S-M-a
   + 堆叠    S-M-s
*** fritzing
+ http://fritzing.org/home/
+ http://fritzing.org/learning/tutorials


Fritzing is an open-source hardware initiative that makes electronics
accessible as a creative material for anyone. We offer a software
tool, a community website and services in the spirit of Processing and
Arduino, fostering a creative ecosystem that allows users to document
their prototypes, share them with others, teach electronics in a
classroom, and layout and manufacture professional pcbs.

*** blender
+ https://www.blender.org/
+ http://wiki.ubuntu.org.cn/Blender2.5x-2.6%E5%AE%8C%E5%85%A8%E6%95%99%E7%A8%8B
+ http://www.blendercn.org/
+

**** Blender wiki
+ Wiki: http://zh.wikipedia.org/wiki/Blender
+ Forum: http://blenderartists.org/forum/
+ Homepage: http://www.blender.org/
+ cn: http://www.blendercn.org/


Blender是一套三维绘图及渲染软件。它具有跨平台的特性，支持FreeBSD，IRIX，
GNU/Linux，Microsoft Windows，Mac OS X，Solaris，及SkyOS。但是，目前不
支持中文的文件名与文件夹。

**** introduction
Blender is free and open source software. Free to use for any purpose,
forever.

Blender是一个开放源代码的多平台全能三维动画制作软件，提供从建模、动画、
材质、渲染，到音频处理、视频剪辑等一系列动画影片及游戏制作解决方案。
Blender以python程序语言为内建脚本，支持yafaray渲染器，同时还内建游戏引
擎。

Blender在GNU公共许可协议下已经发布并公开其源代码，GNU General Public
License简称GPL，是一个自由软件许可协议。因此Blender是完全免费的，并且
没有教育版、专业版或商业版之分。Blender创作的艺术品（包含python脚本）
的唯一所有权就是创作者。

选择Blender的好处有：
+ 稳定高效的3D图形图像及动画处理能力，不到80M大小的软件已具备其他同类
  商业软件的强大功能；
+ 支持其他专业影视编辑特效软件的数据导入和传递，为各种软件的相互搭配工
  作创造良好条件；
+ 软件的快速发展和永不间断的更新，开放各种插件扩充接口，具有可期待无限
  潜力的未来；
+ 免费开放源代码，使用者可以自由开发定制所需的特定功能模块，满足个性化
  需求。

**** install
To install Blender, download the appropriate package for your
platform. The Windows version comes with an optional self-extracting
installer, for other operating systems you can simply unpack the
compressed file to the location of your choice.

Provided the Blender binary is in the original extracted directory,
Blender will run straight out of the box. No system libraries or
system preferences are altered.

**** blender, maya, 3dmax
+ http://zhidao.baidu.com/link?url=5Da2b2RnrfMLd4TFQiYDvb-ZXmuMPL9gbRQtrYNpMTG1b6FfzzFj0tTlV4yjiQnEDHjRva1kZ16sWuF6Vif-yK


3DMAX是Autodesk出品的老牌软件，被广泛应用于建筑、动画、影视、广告等领
域，是所有三维软件中使用人数最多的。例如，《2012》里就是以MAX为主制作
的特效。

Maya是Alisa公司出的，因其独特的架构一出道便不同凡响，他比起MAX来更加自
由开放，强大的脚本扩展功能很是吸引那些自由个性的艺术家。例如，《变形金
刚》就是以MAYA为主制作的特效。

Blender，我很惊讶你从哪里知道这款软件的，很多使用三维软件的人也都不知
道这软件。Blender是所有三维软件里唯一的开源软件。何谓开源，就是源代码
完全开放，可任由他人来改动或扩展。Blender又是所有三维软件里唯一的非商
业化软件，就是完全免费啦。由于是自由组织开发的，且严重依赖于编程，所以
目前还不成熟。目前只出品过两部实验片，一部忘了，另一部是《大雄兔》。


3ds MAX (3D Studio Max) 前身是Kinetix基于PC平台DOS系统开发的3D Sudio系
列，简单来说就是界面易于理解，容易上手，作品成型快速。扩展插件众多。
MAX的早期版本主要用于游戏开发和动画制作，较少用于电影特效。随着版本更
新功能增强和第三方渲染器的加入逐渐应用于电影工业。只能运行在Windows平
台。有中文版。价格昂贵（4万￥）。在我国广泛用于游戏开发，平面设计，效
果图制作，广告，影视等领域，好找工作。

MAYA 是 Alias 收购 Wavefront 公司后 进军 影视特效领域开发的重量级软件，
早期版本就内置高级粒子特效，布料模拟、海洋模拟功能，完全符合影视级特效
渲染的严格要求。可运行在Windows,IRIX,Linux等平台。有中文版，价格昂贵。
在我国部分用于游戏开发，广泛应用预动画和影视特效，当然也好找工作。

Blender 最初是荷兰一家动画工作室运行在IRIX上的私有动画软件，后来开源并
免费， 发展迅速，目前1～2个月就一次修订板。 Blender 几乎是全能的， 包
含了3D动画软件应有的一切功能，还有后期处理功能，并且内置游戏引擎，可以
开发实时运行的游戏。

Blender 支持最多的平台 Windows,Linux,Mac,FreeBSD,IRIX,甚至IPAQ PDA上。
已经在世界上掀起学习和使用的热潮，截至目前有1千万人在使用。目前 2.49
有中文版。但2.49是旧界面，2.5系列采用全新界面，暂时没有稳定的中文版，
但要不了多久就会出来。

对于从未接触过3D动画软件的人来说，Blender上手不难。无论是做效果图还是
动画，都不需要编程知识，除非需要深度扩展。在我国目前仅有个别游戏公司用
项目开发，零星用于平面设计、教育等领域。难找工作，但Blender潜力巨大，
正在进入专业领域，  阿里云渲染就只支持Blender 和 MAYA。 Blender已经是
一个伟大的软件！
*** dae
**** .dae
+ 文件类型：Digital Asset Exchange File
+ 扩展名为.dae的文件是一个3D 图像文件。
+ 文件说明：

  3D interchange file format used for exchanging digital assets
  between multiple graphics programs; based on the COLLADA
  (COLLAborative Design Activity) XML schema.

  The COLLADA format was originally developed by Sony and is now
  jointly supported by Sony and the Khronos Group..dae

***** 打开.dae文件
+ Mac OS
  - Autodesk Maya with ColladaMaya plugin
  - DAZ Productions DAZ Studio
  - Luxology modo
  - GLC_Player
　
+ Windows
  - Autodesk AutoCAD
  - Autodesk 3dsMax with ColladaMax plugin
  - Autodesk Maya with ColladaMaya plugin
  - Bentley Systems Microstation
  - DAZ Productions DAZ Studio
  - Luxology modo
　
+ Linux
  - Autodesk Maya with ColladaMaya plugin
  - GLC_Player
  - Blender with Collada Plug-in for Blender

*** 词汇朗读软件和脚本
+ ttsu
+ espeak
  - src: make make install
  - error: cannot find -lportaudio
    - apt-get install libportaudio
  - 语音不好听

+ eguidedog

*** Graphviz
参考:
+ http://www.cnblogs.com/sld666666/archive/2010/06/25/1765510.html
+ https://github.com/ppareit/graphviz-dot-mode

**** 简介
- 画图工具
- 贝尔实验室开发
- "所想即所得"
- 使用dot语言编写绘图脚本
**** Emacs graphviz-dot-mode
|--------+---------------|
| C-c c  | 编译dot源代码 |
| C-c p  | 显示图片      |
|--------+---------------|
**** 基本使用
***** 绘制对象
DOT语言描述三种对象:
+ *Graph(图表)*
+ *Node(结点)*
+ *Edge*
***** Graph分类
+ *Digraph*: 有向图
+ *graph*: 无向图
***** 例子
****** eg 1
#+header: :file /home/ben/tiger/figures/1503281715.pdf
#+header: :exports none
#+header: :tangle /home/ben/Tiger/Journal/src/graphviz_0328-1.dot
#+BEGIN_SRC dot
  digraph G{
      main -> parse -> execute;
      main -> init;
      main -> cleanup;
      execute -> make_string;
      execute -> printf;
      init -> make_string;
      main -> printf;
      execute -> compare;
  }
#+END_SRC

#+RESULTS:
[[file:/home/ben/Tiger/Figures/1503281715.pdf]]

注:
1. listings宏包不支持dot语言, 所以设置exports为none, 而折衷改用EXAMPLE
   包裹源码
2. #+RESULTS在org-mode显示的结果不会导出到 TeX 中.

#+BEGIN_EXAMPLE
  digraph G{
      main -> parse -> execute;
      main -> init;
      main -> cleanup;
      execute -> make_string;
      execute -> printf;
      init -> make_string;
      main -> printf;
      execute -> compare;
  }
#+END_EXAMPLE

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{/home/ben/Tiger/Figures/1503281715.pdf}
\end{figure}

****** eg 2
#+header: :file /home/ben/tiger/figures/1503281920.pdf
#+header: :exports none
#+header: :tangle /home/ben/Tiger/Journal/src/graphviz_0328_2.dot
#+BEGIN_SRC dot
  digraph G{
      size = "4,4";
      main [shape=box];  /*this is a comment*/
      main -> parse [weight=8];
      parse -> execute;
      main -> init [style=dotted];
      main -> cleanup;
      execute -> {make_string; printf}
      init -> make_string;
      main -> printf[style=bold, label="100 times"];
      edge [color=red];
      make_string [label="make a\nstring"];
      node [shape=box, style=filled,color=".7 .3 1.0"];
      execute -> compare;
  }
#+END_SRC

#+RESULTS:
[[file:/home/ben/Tiger/Figures/1503281920.pdf]]



\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{/home/ben/Tiger/Figures/1503281920.pdf}
\end{figure}




   digraph G : 定义graph对象及名称
   {}花括号中定义nodes(结点)，edges(连线)，subgraph(子图)，并设置属性.
   对象名可以是C标识符，数字以及引号括起的C字符串(引号中可以包含标点符
   号和空白符)
   结点名首次出现时,生成该结点;"->"连接结点生成连线.
   通过设定结点和连线的属性,可以调整其在布局中形式.
   属性按对出现:名称-值,置于结点或连线的后面,用方括号括起,括号中使用逗
   号分隔.
   size="4,4", 设定graph尺寸,单位英寸.
   execute->{make_string,; printf}  一对多连接结点使用花括号括起,分号
   间隔.

*** stardict
+ http://stardict-4.sourceforge.net/
+ https://code.google.com/p/stardict-3/
+ http://pan.baidu.com/s/1c01qNM4#path=%252Fhuzheng_life
+ http://wiki.ubuntu.org.cn/index.php?title=Stardict&variant=zh-cn
字典目录： ~/.stardict/dic 或 /usr/share/stardict/dic
*** pandoc                                                         :pandoc:
**** 参考

+ [[http://zh.wikipedia.org/w/index.php?title=Pandoc&redirect=no][Wiki]]
+ [[http://johnmacfarlane.net/pandoc/README.html][Pandoc Homepage]]
+ [[https://github.com/jgm/pandoc][GibHub]]

**** What's Pandoc?

+ *标记语言转换工具*
+ John MacFarlane使用 *Haskell* 开发
+ 领域中的 *瑞士军刀*
+ 命令行工具
+ 可支持多种操作系统
+ GNU GPL, 自由软件。

**** 安装

1. apt

2. source code
   + git clone git://github.com/jgm/pandoc
   + cd pandoc
   + git submodule update --init
   + cabal install --force --enable-tests
   + cabal test

3. 注： Make sure the `$CABALDIR/bin` directory is in your path.
   export PATH=~/.cabal/bin:$PATH

**** 语言格式

1. 可读取的源格式
   + Markdown
   + reStructuredText
   + textile
   + HTML
   + DocBook
   + LaTeX
   + MediaWiki标记语言
   + OPML
   + *Org-Mode*
   + Haddock

2. 可输出的格式
   + HTML格式
     - XHTML
     - HTML5
     - HTML slide
   + 文字处理软件格式
     - docx
     - odt
     - OpenDocument XML
   + 电子书格式
     - EPUB（第2版及第3版）
     - FictionBook2
   + 技术文档格式
     - DocBook
     - GNU TexInfo
     - Groff manpages
     - Haddock
   + 页面布局格式 InDesign ICML
   + 大纲处理标记语言格式：OPML
   + TeX格式
     - LaTeX
     - ConTeXt
     - LaTeX Beamer
   + PDF格式(需要LaTeX支持)
   + 轻量级标记语言格式
     - Markdown
     - reStructuredText
     - textile
     - Org-Mode
     - MediaWiki标记语言
     - AsciiDoc
   + 自定义格式：可使用lua自定义转换规则

**** 使用

Pandoc的基本指令格式是：
#+BEGIN_EXAMPLE
  $ pandoc [options] [input-file] ...
#+END_EXAMPLE

1) 简单的格式转换指令, Pandoc会根据文件的后缀名自动判断格式
   #+BEGIN_EXAMPLE
     $ pandoc -o output.html input.md
   #+END_EXAMPLE
   其中-o ouput.html表示输出文件为output.html，input.md是输入文件。

2) 用户也可以显式地指定输入文件和输出文件格式
   #+BEGIN_EXAMPLE
     $ pandoc -f markdown -t html -o output.html input.md
   #+END_EXAMPLE
   其中-f markdown表示输入文件格式为Markdown，-t html表示输出文件格式
   为HTML。

3) 可以使用url作为输入

4) -f 输入格式

5) -t 输出格式

*** gnuplot
参考:
+ [[http://www.gnuplot.info/][gnuplot homepage]]
+ [[http://www.zhixing123.cn/ubuntu/draw-figures-and-store-using-gnuplot.html][gunplot入门]]

**** 基础篇
在linux命令提示符下运行gnuplot命令启动，输入quit或q或exit退出。
***** plot命令
1. 用线画，线的类型（包括颜色与虚线的类型）是3，线的宽度是2，对函数
   sin(x)作图

   #+header: :file /home/ben/tiger/figures/1503282122.pdf
   #+header: :exports code
   #+BEGIN_SRC gnuplot
     plot sin(x) with line linetype 3 linewidth 2
   #+END_SRC

   #+RESULTS:
   [[file:/home/ben/Tiger/Figures/1503282122.pdf]]

   #+header: :file /home/ben/tiger/figures/1503282134.pdf
   #+header: :exports code
   #+BEGIN_SRC gnuplot
     plot sin(x) with line linetype 3 linewidth 2
   #+END_SRC

   注:在gnuplot中，如果某两个词， 按字母先后顺序，前面某几个字母相同，后
   面的不同，那么只要写到第一个不同的字母就可以了。如with，由于没有其它以
   w开头的词，因此可以用w代替，line也可以用l代替。

2. 用点画，点的类型（包括颜色与点的类型）是3，点的大小是2
   #+BEGIN_EXAMPLE
     plot sin(x) with point pointtype 3 pointsize 2
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     plot sin(x) w p pt 3 ps 2
   #+END_EXAMPLE

3. 同时用点和线画，这里title ‘f(x)’表示图例上标’f(x)’，如果不用则
   用默认选项
   #+BEGIN_EXAMPLE
     plot sin(x) title ‘f(x)’ w lp lt 3 lw 2 pt 3 ps 2
   #+END_EXAMPLE

4. 所有选项均用默认值。如果缺某一项则将用默认值
   #+BEGIN_EXAMPLE
     plot sin(x)
   #+END_EXAMPLE

5. 利用数据文件a.dat中的第二和第三列作图
   如果对数据文件作图，将函数名称换为数据文件名即可，但 *要用单引号引起来*.
   #+BEGIN_EXAMPLE
     plot ‘a.dat’ u 2:3  w l lt 3 lw 2
   #+END_EXAMPLE
***** 同时画多条曲线
两条曲线是用 *逗号隔开*,画多条曲线时，各曲线间均用逗号隔开就可以了。
#+BEGIN_EXAMPLE
  plot sin(x) title ‘sin(x)’ w l lt 1 lw 2, cos(x) title ‘cos(x)’  w l lt 2 lw 2
#+END_EXAMPLE

***** 图例位置
默认位置在右上方。
+ set key left         % 放在左边，有left 和right两个选项
+ set key bottom       % 放在下边，只有这一个选项；默认在上边
+ set key outside      % 放在外边，但只能在右面的外边
+ set key left bottom  % 组合使用,表示左下边
+ set key 0.5,0.6      % 指定精确位置

***** 坐标轴
+ set xlabel ‘x’   %x轴标为‘x’
+ set ylabel ‘y’   %y轴标为’y’
+ set ylabel ‘DOS’ tc lt 3  %其中的tc lt 3表示’DOS’的颜色用第三种颜色。
+ set xtics 1.0    %x轴的主刻度的宽度为1.0，同样可以为y轴定义ytics
+ set mxtics 3    %x轴上每个主刻度中画3个分刻度，同样可以为y轴定义mytics
+ set border 3 lt 3 lw 2 %设为第三种边界，颜色类型为3，线宽为2
  同样可以为上边的x轴（称为x2）和右边y（称为y2）轴进行设置，即x2tics，mx2tics，y2tics，my2tics。
+ set xtics nomirror
+ unset x2tics     %以上两条命令去掉上边x2轴的刻度
+ set ytics nomirror
+ unset y2tics     %以上两条命令去掉右边y轴的刻度

***** 在图中插入文字
#+BEGIN_EXAMPLE
  set label ‘sin(x)’ at 0.5,0.5  %在坐标（0.5,0.5）处加入字符串’sin(x)’。
#+END_EXAMPLE

在输出为.ps或.eps文件时，如果在set term 的语句中加入了enhanced选现，则
可以插入上下标、希腊字母和特殊符号。上下标的插入和latex中的方法是一样
的。

***** 在图中添加直线和箭头
#+BEGIN_EXAMPLE
  set arrow from 0.0,0.0 to 0.6,0.8    %从（0.0,0.0）到（0.6,0.8）画一个箭头
  set arrow from 0.0,0.0 to 0.6,0.8 lt 3 lw 2   % 设置线条颜色和线宽
  set arrow from 0.0,0.0 to 0.6,0.8 nohead  % 利用nohead可以去掉箭头的头部
#+END_EXAMPLE

注意，在gnuplot中，对于插入多个的label和arrow等等，系统会默认按先后顺
序分别对各个label或arrow进行编号，从1开始。如果以后要去掉某个label或
arrow，那么只要用unset命令将相应的去掉即可。如：
#+BEGIN_EXAMPLE
  unset arrow 2
#+END_EXAMPLE

***** 图的大小和位置
#+BEGIN_EXAMPLE
  %长宽均为默认宽度的一半，建议用这个取值，尤其是画成ps或eps图形的时候
  set size 0.5,0.5
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  %设定图的最左下角的那一点在图形面板中的位置。这里图将出现在左上角。
  set origin 0.0,0.5
#+END_EXAMPLE

***** 画三维图splot
#+BEGIN_EXAMPLE
  splot ‘文件名’ u 2:4:5  %以第二和第四列作为x和y坐标，第五列为z坐标。
#+END_EXAMPLE

***** 将图形输出到文件
+ 在gnuplot中，输出文件的格式是由terminal来控制的。
+ 默认的情况下，都是输出到屏幕，即终端模式为X11。
+ 如果想输出到文件，则必须对 terminal进行设置。要了解有那些终端类型，
  可以输入 set terminal后回车，所有支持的终端模式（或文件格式）都列出
  来了。
+ 输出文件的格式用得最多的是ps和eps文件。这在运行画图
  命令 plot或splot前必须先运行如下两条命令：

#+BEGIN_EXAMPLE
  set term post eps color solid enh
  set output ‘a.eps’
#+END_EXAMPLE

其中第一条命令为设置终端模式
+ post即为postscript模式，这是 *输出到ps或eps文件必须有的*
+ eps表示输出为eps文件，没有就输出为ps文件
+ 后面的eps，color，solid以及 enh选项均可以有或没有
  - color表示输出图形为彩色，不用就会保存为黑白的
  - solid表示输出图中的所有线都用实线，不用则除了第一条线为实线外，其
    它的均用不同的虚线
  - 使用enh(enhanced)选项可以在图中插入上 下标、希腊字母和特殊符号，不
    用则不能实现这些功能。

第二条命令对output的设置表示要输出的文件的名字。
*注，运行完这条命令后，还仅仅是定义了输出文件的名字，图还没画到这个文
件里去*
因此运行这两条命令还只是进行了必须的设置。然后运行如下命令
#+BEGIN_EXAMPLE
  gnuplot>plot sin(x) w l
#+END_EXAMPLE
或
#+BEGIN_EXAMPLE
  gnuplot>replot
#+END_EXAMPLE

这时，图形就在上面指定的文件中了。
要输出为其它格式，同样要进行这样的设置，比如要输出为jpg格式，则在运行
画图命令前先运行如下命令：
#+BEGIN_EXAMPLE
  gnuplot>set term jpeg
  gnuplot>set output ‘a.jpg’
#+END_EXAMPLE

如果要由其它模式再返回到输出到屏幕，则运行如下命令：
#+BEGIN_EXAMPLE
  gnuplot>set term X11
#+END_EXAMPLE
**** HALT 提高篇

***** 如何在同一张图里同时画多个图
#+BEGIN_EXAMPLE
  gnuplot>set multiplot   %设置为多图模式
  gnuplot>set origin 0.0,0.5   %设置第一个图的原点的位置
  gnuplot>set size 0.5,0.5  %设置第一个图的大小
  gnuplot>plot “a1.dat”
  gnuplot>set origin 0.5,0.5   %设置第二个图的原点的位置
  gnuplot>set size 0.5,0.5   %设置第二个图的大小
  gnuplot>plot “a2.dat”
  gnuplot>set origin 0.0,0.0   %设置第三个图的原点的位置
  gnuplot>set size 0.5,0.5  %设置第三个图的大小
  gnuplot>plot “a3.dat”
  gnuplot>set origin 0.5,0.0   %设置第四个图的原点的位置
  gnuplot>set size 0.5,0.5  %设置第四个图的大小
  gnuplot>plot “a4.dat”
#+END_EXAMPLE

当然，如果后一个图中的某个量的设置和前一个的相同，那么后一个中的这个量
的设置可以省略。例如上面对第二、第三和第四个图的大小的设置。
+ 前一个图中对某个量的设置也会在后一个图中起作用。
+ 如果要取消在后面图中的作用，必须用命令unset

#+BEGIN_EXAMPLE
  unset label
#+END_EXAMPLE
***** 作二维图时，如何使两边坐标轴的单位长度等长
#+BEGIN_EXAMPLE
  set size square    %使图形是方的
  set size 0.5,0.5    %使图形是你要的大小
  set xrange[-a:a]
  set yrange[-a:a]    %两坐标轴刻度范围一样
  plot ‘a.dat’
#+END_EXAMPLE

**** gunplot mode
**** gunplot org babel
参考:
+ http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-gnuplot.html
+ file:~/Document/Emacs/Org/org-babel-gnuplot.org

***** Requiremens
+ gnuplot
+ gnuplot.el, an Emacs major mode
***** Alternative
*org-plot*
***** Setup
#+BEGIN_EXAMPLE
  ;; active Babel languages
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((gnuplot . t)))
  ;; add additional languages with '((language . t)))
#+END_EXAMPLE
***** Example
****** Function plot
#+tblname: data-table-150328-1
| x | y1 | y2 |
|---+----+----|
| 0 |  3 |  6 |
| 1 |  4 |  7 |
| 2 |  5 |  8 |


#+header: :file /home/ben/tiger/figures/1503282138.pdf
#+header: :exports code
#+header: :tangle /home/ben/Tiger/Journal/src/gnuplot_150328-2.gpt
#+header: :var data=data-table-150328-1
#+BEGIN_SRC gnuplot
  reset

  set title "Putting it all together"

  set xlabel "X"
  set xrange [-8:8]
  set xtics -8,2,8

  set ylabel "Y"
  set yrange [-20:70]
  set utics -20,10,70

  f(x) = x**2
  g(x) = x**3
  h(x) = 10*sqrt(abs(x))

  plot f(x) w lp lw 1, g(x) w p lw 2,h(x)w l lw 3
#+END_SRC

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{/home/ben/Tiger/Figures/1503282138.pdf}
\end{figure}

****** Data table plot
#+tblname: data-table-1503282142
|-----+------------+------------|
|   x |         y1 |         y2 |
|-----+------------+------------|
| 0.1 |      0.425 |      0.375 |
|-----+------------+------------|
| 0.2 |     0.3125 |     0.3375 |
|-----+------------+------------|
| 0.3 | 0.24999993 | 0.28333338 |
|-----+------------+------------|
| 0.4 |      0.275 |    0.28125 |
|-----+------------+------------|
| 0.5 |       0.26 |       0.27 |
|-----+------------+------------|
| 0.6 | 0.25833338 | 0.24999993 |
|-----+------------+------------|
| 0.7 | 0.24642845 | 0.23928553 |
|-----+------------+------------|
| 0.8 |    0.23125 |     0.2375 |
|-----+------------+------------|
| 0.9 | 0.23333323 |  0.2333332 |
|-----+------------+------------|
|   1 |     0.2225 |       0.22 |
|-----+------------+------------|


#+header: :file /home/ben/Tiger/Figures/1503282142.pdf
#+header: :exports code
#+header: :tangle /home/ben/Tiger/Journal/src/gnuplot_1503282142.gpt
#+header: :var data=data-table-1503282142
#+BEGIN_SRC gnuplot
  reset

  set title "Putting it all together"

  set xlabel "X"
  set xrange [0:1]
  set xtics 0,0.1,1

  set ylabel "Y"
  set yrange [0.2:0.5]
  set ytics 0.2,0.05,0.5

  plot data u 1:2 w p lw 2 title "x vs. y1", \
       data u 1:3 w lp lw 1 title "x vs. y2"
#+END_SRC

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{/home/ben/Tiger/Figures/1503282142.pdf}
\end{figure}


***** Header Arguments
  * :var data=data-table
      + When data is to be plotted from a table, it is helpful to use a
        heading right above the table in the form #+tblname=data-table,
        where "data-table" is replaced with some short name to identify the
        table to gnuplot.
  * :exports {code, results, both, none}
      + When the code is run and the document exported (e.g. to HTML or \
        LaTeX PDF), what should appear? Just the code block itself? Only the
        produced output (in this case a plot of some sort)? Both the code
        and the accompanying results? Or nothing?
  * :file foo.{png,eps,etc.}
      + This option specifies where the resulting output should be put. If
        no option is given, a gnuplot window will open with the resultant
        plot. NOTE: Certain plot options may not output properly to gnuplot
        directly and thus must have the :file filename option in the header.
        If the error "Code block produced no output" recurs, try outputting
        to a file instead of directly to gnuplot.
***** gnuplot plot
*Plot* is the heart of gnuplot. It is broken into several section:
1. plot what
   either be a function or data
   + plot sin(x)
   + plot data using x:y
     + using can be abbreviated with simply "u"
     + x:y specify the column numbers x and y

   #+BEGIN_EXAMPLE
   plot sin(x)
   #+END_EXAMPLE
2. Plot how
   customize the look of the table
   + points(p)
   + lines(l)
   + dots(d)
   + impulses(i)
   + linespoints(lp)
   + steps
   + boxes
   #+BEGIN_EXAMPLE
     plot sin(x) with l lw 2
   #+END_EXAMPLE
3. Call it what
   *title TITLE*
   *notitle*

   #+BEGIN_EXAMPLE
     plost data u 1:2 w lines lw 2 title 'Data Set 1'
   #+END_EXAMPLE
***** HALT Above and Beyond
- State "HALT"       from ""           [2015-03-09 一 17:26]

*** [[~/Document/Reference/Manual/LedgerManual.pdf][ledger]]                                                         :ledger:

**** 查阅 Ledger /是否支持加减运算/ ，

手册没有细读。 但通过尝试得出了结果： /可以，但要用括号括起/

*inline math requires parentheses*

#+BEGIN_EXAMPLE
  tmp $ ledger -f foo.ledger balance
  While parsing file "/tmp/foo.ledger", line 6:
  While parsing posting:
    Expsense:Food  12+3
                   ^^^^
  Error: Unexpected char '+' (Note: inline math requires parentheses)

  tmp $ gedit foo.ledger

  tmp $ ledger -f foo.ledger balance
                    22  Assets:Cash
                   -37  Equity:Opening Balances
                    15  Expsense:Food
  --------------------
                     0
#+END_EXAMPLE

**** TODO 阅读手册，整理常用命令，并整合所有的ledger文件

**** Manual
***** file structure
****** At the highest you have five sorts of accouts

+ *Assets*: where money sits
+ *Liabilities*: money you oew
+ *Income*: where money comes from
+ *Expense*: where money goes
+ *Equity*: the real value of your property

****** Beneath these top level

e.g.  Expenses:Food:Hamburgers and Fries

****** Commenting

1. /;/ (usually)
2. four additional
   1) %
   2) #
   3) |
   4) *
***** command                                                       :cmd:
****** Balance Report

*ledger -f account.ledger balance*
*ledger -f account.ledger Assets Liabilites*

****** Register Report

*ledger -f account.ledger register*
*ledger -f account.ledger register Grocereis*
*ledger -f account.ledger register payee "Organic"*

*** ditaa
参考:
+ [[http://blog.csdn.net/cuijianzhongswust/article/details/8296159][CSDN blog]]
+ [[http://emacser.com/emacs-ditaa.htm][emacer中文网]]
+ [[http://ditaa.sourceforge.net/#download][ditaa homepage]]
+ [[http://doc.norang.ca/org-mode.html#playingwithditaa][org brief manual]]

**** ditaa简介
Emacs处理图片
+ LaTeX 的排版与图片功能相当强大,门槛高,使用复杂,主要用在科学论文.
+ graphviz
+ ACSII图

ditaa is a small command-line utility written in Java, that can convert
diagrams drawn using ascii art ('drawings' that contain characters that
resemble lines like | / - ), into proper bitmap graphics.
                                   o
Emacs中有两个mode用于处理ASCII图,picture-mode和 *artist-mode*
        o        o
e.g. 框图
#+BEGIN_EXAMPLE
+----------+ edit +----------+   input +----------+ compile +----------+
| refined  |<-----+ h,cpp    +-------->+ compiler,+-------->+Executable|
|   h,c.p  ..     |          |         | linker   |         |   File   |
+-------. .....   +----+-----+         +----------+         +----------+
                       | input
                       v
                  +----------+
                  | doxygen  |
                  |          |
                  +----+-----+
                       | process
                       v
                  +----------+
                  | Doxgen   |
                  | Document |
                  +----------+
#+END_EXAMPLE

**** Command line
*java -jar ditaa0_9.jar*

选项:
|----+-----------------------+-----------------------------------------------------------------|
| -A | --no-antialias        | turn off anti-aliasing                                          |
| -d | --debug               | Renders the debug grid over the resulting image                 |
| -E | --no-sepatation       | prevent the sepatation of the common edges of shapes            |
| -e | --encoding <ENCODING> | the encoding of the input file                                  |
| -h | --html                | the input is an HTML file                                       |
| -o | --overwrite           | overwrite existing file                                         |
| -r | --round-corners       | cause all corners to be renders as round corners                |
| -s | --scale <SCALE>       | a natural number that determines the size of the rendered image |
| -S | --no-shadows          | turn off the drop-shadow effect                                 |
| -t | --tabs <TABS>         |                                                                 |
| -v | --verbose             | makes ditaa more verbose                                        |
|----+-----------------------+-----------------------------------------------------------------|

e.g. -E --no-seperation


#+header: :file /home/ben/tiger/figures/201502051611.png
#+header: :exports none
#+BEGIN_SRC ditaa
  +---------+
  | cBLU    |
  |         |
  |    +----+
  |    |cPNK|
  +----+----+
#+END_SRC

#+RESULTS:
[[file:/home/ben/Tiger/Figures/201502051611.png]]


#+BEGIN_EXAMPLE
  +---------+
  | cBLU    |
  |         |
  |    +----+
  |    |cPNK|
  +----+----+
#+END_EXAMPLE
\begin{figure}[ht]
\centering
\includegraphics[width=0.4\linewidth]{/home/ben/Tiger/Figures/201502051611.png}
\end{figure}

**** Syntax
***** Round corners
If you use / and \ to connect corners, they are rendered as round
corners.

#+header: :file /home/ben/tiger/figures/201502051558.png
#+header: :exports none
#+BEGIN_SRC ditaa
  /--+
  |  |
  +--/
#+END_SRC

#+RESULTS:
[[file:/home/ben/Tiger/Figures/201502051558.png]]


#+header: :file /home/ben/tiger/figures/201502051558.png
#+header: :exports none
#+BEGIN_SRC ditaa
  /--+
  |  |
  +--/
#+END_SRC

#+RESULTS:
[[file:/home/ben/Tiger/Figures/201502051558.png]]

#+BEGIN_EXAMPLE
  /--+
  |  |
  +--/
#+END_EXAMPLE
\begin{figure}[ht]
\centering
\includegraphics[width=0.4\linewidth]{/home/ben/Tiger/Figures/201502051558.png}
\end{figure}

***** Color
*cXXX* is the syntax of color codes, where XXX is a hex number.XXX
respectively represent the compoment of the red,green and blue(RGB)


#+header: :file /home/ben/tiger/figures/201502051550.png
#+header: :exports none
#+BEGIN_SRC ditaa
  /----+----\
  |c33F+cC02|
  +----+----+
  |c1FF+c1AB|
  \----+----/
#+END_SRC

#+RESULTS:
[[file:/home/ben/Tiger/Figures/201502051550.png]]

#+BEGIN_EXAMPLE
  /----+----\
  |c33F+cC02|
  +----+----+
  |c1FF+c1AB|
  \----+----/
#+END_EXAMPLE
\begin{figure}[ht]
\centering
\includegraphics[width=0.4\linewidth]{/home/ben/Tiger/Figures/201502051550.png}
\end{figure}

There are some human readable color codes provided: cRED, cBLU, cGRE,


#+header: :file /home/ben/tiger/figures/201502051548.png
#+header: :exports none
#+BEGIN_SRC ditaa
  /--------+---------\
  |cRED RED|cBLU BLU |
  +--------+---------+
  |cGRE GRE+cPNK PNK |
  +--------+---------+
  |cBLK BLK+cYEL YEL |
  \--------+---------/
#+END_SRC

#+RESULTS:
[[file:/home/ben/Tiger/Figures/201502051548.png]]

cPNK, cBLK, cYEL.
#+BEGIN_EXAMPLE
  /--------+---------\
  |cRED RED|cBLU BLU |
  +--------+---------+
  |cGRE GRE+cPNK PNK |
  +--------+---------+
  |cBLK BLK+cYEL YEL |
  \--------+---------/
#+END_EXAMPLE

\begin{figure}[ht]
\centering
\includegraphics[width=0.4\linewidth]{/home/ben/Tiger/Figures/201502051548.png}
\end{figure}

If a colored shape contains any text, the color of the text is
adjusted according to the underlying color.

***** Tags
ditaa recognises some tags that change the way a rectangular shape is
rendered. All tags are between { and }.
+ {d} : symbol representing a document
  #+header: :file /home/ben/Tiger/Figures/201502051619.png
  #+header: :exports none
  #+BEGIN_SRC ditaa
    +---+
    |{d}|
    +---+
  #+END_SRC

  #+RESULTS:
  [[file:/home/ben/Tiger/Figures/201502051619.png]]

  #+BEGIN_EXAMPLE
    +---+
    |{d}|
    +---+
  #+END_EXAMPLE
  \begin{figure}[ht]
  \centering
  \includegraphics[width=0.4\linewidth]{/home/ben/Tiger/Figures/201502051619.png}
  \end{figure}

+ {s} : symbol representing a form of storage

  #+header: :file /home/ben/Tiger/Figures/201502051645.png
  #+header: :exports none
  #+BEGIN_SRC ditaa
    +---+
    |{s}|
    +---+
  #+END_SRC

  #+RESULTS:
  [[file:/home/ben/Tiger/Figures/201502051645.png]]


  #+BEGIN_EXAMPLE
    +---+
    |{s}|
    +---+
  #+END_EXAMPLE
  \begin{figure}[ht]
  \centering
  \includegraphics[width=0.4\linewidth]{/home/ben/Tiger/Figures/201502051645.png}
  \end{figure}

+ {io} : symbol representing input/output

  #+header: :file /home/ben/Tiger/Figures/201502051649.png
  #+header: :exports none
  #+BEGIN_SRC ditaa
    +-----+
    | {io}|
    +-----+
  #+END_SRC

  #+RESULTS:
  [[file:/home/ben/Tiger/Figures/201502051649.png]]

  #+BEGIN_EXAMPLE
    +-----+
    | {io}|
    +-----+
  #+END_EXAMPLE
  \begin{figure}[ht]
  \centering
  \includegraphics[width=0.4\linewidth]{/home/ben/Tiger/Figures/201502051649.png}
  \end{figure}

***** Dashed lines
Any lines that contain either at least one = (for horizontal lines) or
at least one : (for vertical lines) are rendered as dashed lines.

#+header: :file /home/ben/Tiger/Figures/201502051655.png
#+header: :exports none
#+BEGIN_SRC ditaa
  ----+ /---\ +---+
      : |   | :   |
      | |   | |{s}|
      v \-=-/ +---+
#+END_SRC

#+RESULTS:
[[file:/home/ben/Tiger/Figures/201502051655.png]]

#+BEGIN_EXAMPLE
  ----+ /---\ +---+
      : |   | :   |
      | |   | |{s}|
      v \-=-/ +---+
#+END_EXAMPLE

\begin{figure}[ht]
\centering
\includegraphics[width=0.4\linewidth]{/home/ben/Tiger/Figures/201502051655.png}
\end{figure}

***** Point markers
If * is encountered on a line (but not at the end of the line), it is
rendered as a special marker, called the point marker.

#+header: :file /home/ben/tiger/figures/201502051700.png
#+header: :exports none
#+BEGIN_SRC ditaa
  ,*----*
  |    |    /--*
  ,*    *    |
  |    | -*-+
  ,*----*
#+END_SRC

#+RESULTS:
[[file:/home/ben/Tiger/Figures/201502051700.png]]

#+BEGIN_EXAMPLE
  ,*----*
  |    |    /--*
  ,*    *    |
  |    | -*-+
  ,*----*
#+END_EXAMPLE
\begin{figure}[ht]
\centering
\includegraphics[width=0.4\linewidth]{/home/ben/Tiger/Figures/201502051700.png}
\end{figure}

***** Text handling
If the pattern 'o XXXX' is encountered, where XXXX is any text, the
'o' is interpreted and rendered as a bullet point.Note that there must
be a space before the 'o' as well as after it.

#+header: :file /home/ben/tiger/figures/201502051705.png
#+header: :exports none
#+BEGIN_SRC ditaa
  /-----------------\
  | Things to do    |
  | cGRE            |
  | o Cut the grass |
  | o Buy jam       |
  | o Fix car       |
  | o Make website  |
  \-----------------/
#+END_SRC

#+RESULTS:
[[file:/home/ben/Tiger/Figures/201502051705.png]]

#+BEGIN_EXAMPLE
  /-----------------\
  | Things to do    |
  | cGRE            |
  | o Cut the grass |
  | o Buy jam       |
  | o Fix car       |
  | o Make website  |
  \-----------------/
#+END_EXAMPLE
\begin{figure}[ht]
\centering
\includegraphics[width=0.4\linewidth]{/home/ben/Tiger/Figures/201502051705.png}
\end{figure}

**** ditaa in org-babel
***** 配置
#+BEGIN_EXAMPLE
(setq org-ditaa-jar-path "~/.emacs.d/pkgs/ditaa/ditaa0_9.jar")
#+END_EXAMPLE
***** 相关变量和函数
*M-x aprospos* 查看匹配某个关键字的任何东西.
|-------------------------------------+----------------------------------------|
| org-babel-default-header-args:ditaa | Default arguments for evaluating ditaa |
| org-babel-ditta-java-cmd            | Java executable to use                 |
| *org-ditaa-jar-path*                | path to the ditaa jar executable       |
| org-ditaa-eps-jar-path              | Path to the DitaaEps.jar executable    |
| org-ditaa-jar-option                | Option for the ditaa jar file          |
|-------------------------------------+----------------------------------------|
| org-babel-execute:ditaa             | Function to execute ditaa              |
|-------------------------------------+----------------------------------------|

**** TODO 中文,babel控制ditaa选项
:file 文件名
:cmdline -r -s 0.5

*** Matlab
http://blog.csdn.net/lanbing510/article/details/41698285
http://www.cnblogs.com/mchina/archive/2013/01/03/2840040.html


1. 从 http://pan.baidu.com/s/1o6qKdxo#path=%252Fmatlab 下载Matlab2014
   的Linux版本及破解文件
2. 下载完成后将iso文件挂载到Linux
   #+BEGIN_EXAMPLE
     sudo mkdir /media/matlab
     mount -o loop [path][filename].iso /media/matlab
     cd /media/matlab
     sudo ./install
   #+END_EXAMPLE

  进行安装
3. 安装过程中使用readme.txt中的序列号
4. 破解
   1) 安装完成后使用crack下的 license进行激活
   2) 将crack文件夹下的libmwservices.so copy到
      /usr/local/MATLAB/R2014A/bin/glnxa64
5. 完成安装，命令行下使用sudo matlab即可启动使用

*** OGRE
+ http://zh.wikipedia.org/wiki/OGRE
+ http://www.ogre3d.org/
+ http://baike.baidu.com/subview/104836/15875123.htm#viewPageContent


OGRE（Object-Oriented Graphics Rendering Engine，面向对象图形渲染引擎）
又叫做OGRE 3D。OGRE是面向场景的、灵活的图像引擎。OGRE仍然在发展中，如
果就功能和商业游戏引擎还有一定差距。

开源

Gazebo使用OGRE作为渲染的引擎。

*** QGIS wiki
+ Wiki: http://zh.wikipedia.org/wiki/QGIS


QGIS（原称Quantum GIS）是一个自由软件的桌面GIS软件。它提供数据的显示、
编辑和分析功能。

QGIS以C++写成，它的GUI使用了Qt库。QGIS允许集成使用C++ 或Python写成的插
件。除了Qt之外，QGIS需要的依赖还包括GEOS和SQLite。同时也推荐安装GDAL、
GRASS GIS、PostGIS和PostgreSQL。

QGIS是一个多平台的应用，可以在多种操作系统上运行，包括Mac OS X、Linux、
UNIX和Microsoft Windows。对于Mac用户，QGIS相对于GRASS GIS的优势在于它
不需要X11窗口系统，而且界面更简洁、快速。Quantum GIS也可以作为GRASS的
图形用户界面使用。相较于商业GIS，Quantum GIS的文件体积更小，需要的内存
和处理能力也更少。因此它可以在旧的硬件上或CPU运算能力被限制的环境下运
行。

QGIS是基于GPL发布的自由软件.

*** dae                                                               :dae:
+ 文件类型：digital asset exchange file
+ 扩展名为.dae的文件是一个3d 图像文件。
+ 文件说明：

  3d interchange file format used for exchanging digital assets
  between multiple graphics programs; based on the collada
  (collaborative design activity) xml schema.

  the collada format was originally developed by sony and is now
  jointly supported by sony and the khronos group..dae

**** 打开.dae文件
+ Mac OS
  - Autodesk Maya with ColladaMaya plugin
  - DAZ Productions DAZ Studio
  - Luxology modo
  - GLC_Player
　
+ Windows
  - Autodesk AutoCAD
  - Autodesk 3dsMax with ColladaMax plugin
  - Autodesk Maya with ColladaMaya plugin
  - Bentley Systems Microstation
  - DAZ Productions DAZ Studio
  - Luxology modo
　
+ Linux
  - Autodesk Maya with ColladaMaya plugin
  - GLC_Player
  - Blender with Collada Plug-in for Blender

*** rst
http://blog.useasp.net/archive/2014/09/05/rst-file-restructuredtext-markup-syntax-quikstart.aspx
http://blog.useasp.net/archive/2014/09/06/the-shortcut-talbe-for-emacs-reStructuredText-mode-rst-mode.aspx

reStructuredText是一种轻量级的文本标记语言，直译为：重构建的文本，为
Python中Docutils项目的一部分。其一般保存的文件以.rst为后缀。在必要的时
候，.rst文件可以被转化成PDF或者HTML格式，也可以有Sphinx转化为LaTex,man
等格式，现在被广泛的用于程序的文档撰写。
**** 小结
1. rst: reStructuredText的缩写
2. 后缀名rst
3. 一种标记语言，和org-mode与markdown相似

*** Linux 知网
**** wine安装知网阅读软件
源码安装的wine安装CAJviewer没有问题，使用时出现 unable to create a
MSXML instance错误

可能是缺少微软库依赖。ArchLinux查得 Some applications (e.g. Office
2003/2007) require the MSXML library to parse HTML or XML, in such
cases you need to install
lib32-libxml2. https://wiki.archlinux.org/index.php/Wine

但libxml2已经安装

卸载源码安装的wine，使用apt-get方式安装后，问题解决。

**** caj to pdf
+ http://www.zhihu.com/question/21103230


1. 虚拟打印机转换为pdf或xps格式
2. 少瞎折腾

为什么不直接下载PDF，可以从 *万方* 上直接下载PDF

*** blender
+ https://www.blender.org/
+ http://wiki.ubuntu.org.cn/Blender2.5x-2.6%E5%AE%8C%E5%85%A8%E6%95%99%E7%A8%8B
+ http://www.blendercn.org/


**** introduction
Blender is free and open source software. Free to use for any purpose,
forever.

Blender是一个开放源代码的多平台全能三维动画制作软件，提供从建模、动画、
材质、渲染，到音频处理、视频剪辑等一系列动画影片及游戏制作解决方案。
Blender以python程序语言为内建脚本，支持yafaray渲染器，同时还内建游戏引
擎。

Blender在GNU公共许可协议下已经发布并公开其源代码，GNU General Public
License简称GPL，是一个自由软件许可协议。因此Blender是完全免费的，并且
没有教育版、专业版或商业版之分。Blender创作的艺术品（包含python脚本）
的唯一所有权就是创作者。

选择Blender的好处有：
+ 稳定高效的3D图形图像及动画处理能力，不到80M大小的软件已具备其他同类
  商业软件的强大功能；
+ 支持其他专业影视编辑特效软件的数据导入和传递，为各种软件的相互搭配工
  作创造良好条件；
+ 软件的快速发展和永不间断的更新，开放各种插件扩充接口，具有可期待无限
  潜力的未来；
+ 免费开放源代码，使用者可以自由开发定制所需的特定功能模块，满足个性化
  需求。

**** install
To install Blender, download the appropriate package for your
platform. The Windows version comes with an optional self-extracting
installer, for other operating systems you can simply unpack the
compressed file to the location of your choice.

Provided the Blender binary is in the original extracted directory,
Blender will run straight out of the box. No system libraries or
system preferences are altered.

**** blender, maya, 3dmax对比                                    :blender:
+ http://zhidao.baidu.com/link?url=5Da2b2RnrfMLd4TFQiYDvb-ZXmuMPL9gbRQtrYNpMTG1b6FfzzFj0tTlV4yjiQnEDHjRva1kZ16sWuF6Vif-yK


3DMAX是Autodesk出品的老牌软件，被广泛应用于建筑、动画、影视、广告等领
域，是所有三维软件中使用人数最多的。例如，《2012》里就是以MAX为主制作
的特效。

Maya是Alisa公司出的，因其独特的架构一出道便不同凡响，他比起MAX来更加自
由开放，强大的脚本扩展功能很是吸引那些自由个性的艺术家。例如，《变形金
刚》就是以MAYA为主制作的特效。

Blender，我很惊讶你从哪里知道这款软件的，很多使用三维软件的人也都不知
道这软件。Blender是所有三维软件里唯一的开源软件。何谓开源，就是源代码
完全开放，可任由他人来改动或扩展。Blender又是所有三维软件里唯一的非商
业化软件，就是完全免费啦。由于是自由组织开发的，且严重依赖于编程，所以
目前还不成熟。目前只出品过两部实验片，一部忘了，另一部是《大雄兔》。


3ds MAX (3D Studio Max) 前身是Kinetix基于PC平台DOS系统开发的3D Sudio系
列，简单来说就是界面易于理解，容易上手，作品成型快速。扩展插件众多。
MAX的早期版本主要用于游戏开发和动画制作，较少用于电影特效。随着版本更
新功能增强和第三方渲染器的加入逐渐应用于电影工业。只能运行在Windows平
台。有中文版。价格昂贵（4万￥）。在我国广泛用于游戏开发，平面设计，效
果图制作，广告，影视等领域，好找工作。

MAYA 是 Alias 收购 Wavefront 公司后 进军 影视特效领域开发的重量级软件，
早期版本就内置高级粒子特效，布料模拟、海洋模拟功能，完全符合影视级特效
渲染的严格要求。可运行在Windows,IRIX,Linux等平台。有中文版，价格昂贵。
在我国部分用于游戏开发，广泛应用预动画和影视特效，当然也好找工作。

Blender 最初是荷兰一家动画工作室运行在IRIX上的私有动画软件，后来开源并
免费， 发展迅速，目前1～2个月就一次修订板。 Blender 几乎是全能的， 包
含了3D动画软件应有的一切功能，还有后期处理功能，并且内置游戏引擎，可以
开发实时运行的游戏。

Blender 支持最多的平台 Windows,Linux,Mac,FreeBSD,IRIX,甚至IPAQ PDA上。
已经在世界上掀起学习和使用的热潮，截至目前有1千万人在使用。目前 2.49
有中文版。但2.49是旧界面，2.5系列采用全新界面，暂时没有稳定的中文版，
但要不了多久就会出来。

对于从未接触过3D动画软件的人来说，Blender上手不难。无论是做效果图还是
动画，都不需要编程知识，除非需要深度扩展。在我国目前仅有个别游戏公司用
项目开发，零星用于平面设计、教育等领域。难找工作，但Blender潜力巨大，
正在进入专业领域，  阿里云渲染就只支持Blender 和 MAYA。 Blender已经是
一个伟大的软件！

** 系统工具
*** terminator
http://54rd.net/html/2015/server_0122/30.html

Terminator比Terminal更加好玩一些，增加了许多特性，而且自定义更加灵活。

*** Cabal                                                           :cabal:
+ https://www.haskell.org/cabal/

Cabal(Common Architecture for Building Applications and Libraries),
Cabal is a system for building and packaging Haskell libraries and
programs. It defines a common interface for package authors and
distributors to easily build their applications in a portable
way. Cabal is part of a larger infrastructure for distributing,
organizing, and cataloging Haskell libraries and programs.

+ INSTALL: sudo apt-get install cabal-install
*** ruby gem                                                     :ruby:gem:
*RubyGems is a sophisticated package manager for Ruby.*

+ Usage:
  - gem -h/--help
  - gem -v/--version
  - gem command [arguments...] [options...]
+ Examples:
  - gem install rake
  - gem list --local
  - gem build package.gemspec
  - gem help install

*** ant                                                               :ant:
+ wiki: http://en.wikipedia.org/wiki/Apache_Ant
+ tutorial: http://ideoplex.com/focus/java#ant
+ official page: http://ant.apache.org/

**** overview
Apache Ant is a Java library and command-line tool that help building
software.

***** what
Apache Ant is a software tool for automating software build
processes.(*like make*) It was a replacement for the *unix make* build
tool, and was created due to a number of problems with the unix make.

***** language
It is similar to Make but is *implemented using the Java language*,
requires the Java platform, and is best suited to building Java
projects.

***** vs make
The most immediately noticeable difference between Ant and Make is
that *Ant uses XML* to describe the build process and its
dependencies, whereas Make uses Makefile format.

By default the XML file is named *build.xml*.
***** license
Ant is an Apache project. It is open source software, and is released
under the *Apache License*.
**** Install
+ source code: need to configure java, so just quit
+ apt
***

*** bzr                                                               :bzr:
+ http://bazaar.canonical.com/en/


Bazaar is a version control system that helps you track project
history over time and to collaborate easily with others. Whether
you're a single developer, a co-located team or a community of
developers scattered across the world, Bazaar scales and adapts to
meet your needs. Part of the GNU Project, Bazaar is free software
sponsored by Canonical.

*** ruby gem(类似pip)                                                 :gem:

*rubygems is a sophisticated package manager for ruby.*

+ usage:
  - gem -h/--help
  - gem -v/--version
  - gem command [arguments...] [options...]
+ examples:
  - gem install rake
  - gem list --local
  - gem build package.gemspec
  - gem help install
*** [[http://www.mono-project.com/][Mono]]                                                             :mono:

Mono is a software platform designed to allow developers to easily
create /cross platform/ applications.

Mono is an /open source/ implementation of Microsoft's /.NET/
Framework based on the ECMA standards for /C#/ and the Common Language
Runtime

*** dropbox                                                       :dropbox:
**** 卸载 dropbox /dpkg/                                    :dropbox:dpkg:

- State "DONE"       from "TODO"       [2015-12-09 三 12:32]

#+BEGIN_EXAMPLE
  bagfile $ dpkg -l | grep dropbox
  rc  dropbox
  ii  nautilus-dropbox

  bagfile $ sudo apt-get remove dropb^C

  bagfile $ dpkg -h
  dpkg：错误：未知选项 -h

  输入 dpkg --help 可获得安装和卸载软件包的有关帮助 [*]；
  使用 apt 或是 aptitude 就能在友好的界面下管理软件包；
  输入 dpkg -Dhelp 可看到 dpkg 除错标志的值的列表；
  输入 dpkg --force-help 可获得所有强制操作选项的列表；
  输入 dpkg-deb --help 可获得有关操作 *.deb 文件的帮助；

  带有 [*] 的选项将会输出较大篇幅的文字 - 可使用管道将其输出连接到 less 或 more ！

  bagfile $ dpkg --help
  用法：dpkg [<选项> ...] <命令>

  ...
    -P|--purge         <package> ... | -a|--pending
  ...
  'apt' 和 'aptitude' 提供了更为便利的软件包管理。

  bagfile $ dpkg --purge dropbox
  dpkg：错误：该操作需要超级用户权限

  bagfile $ sudo dpkg --purge dropbox
  [sudo] password for ben:
  (正在读取数据库 ... 系统当前共安装有 538113 个文件和目录。)
  正在卸载 dropbox (2015.02.12) ...
  正在清除 dropbox (2015.02.12) 的配置文件 ...

  bagfile $ sudo dpkg --purge nautilus-dropbox
  (正在读取数据库 ... 系统当前共安装有 538113 个文件和目录。)
  正在卸载 nautilus-dropbox (1.6.1-1) ...
  Dropbox isn't running!
  dropbox：没有发现操作
  正在清除 nautilus-dropbox (1.6.1-1) 的配置文件 ...
  正在处理用于 hicolor-icon-theme (0.13-1) 的触发器 ...
  正在处理用于 man-db (2.6.7.1-1ubuntu1) 的触发器 ...
  正在处理用于 mime-support (3.54ubuntu1.1) 的触发器 ...
  正在处理用于 gnome-menus (3.10.1-0ubuntu2) 的触发器 ...
  正在处理用于 desktop-file-utils (0.22-1ubuntu1) 的触发器 ...
  正在处理用于 bamfdaemon (0.5.1+14.04.20140409-0ubuntu1) 的触发器 ...
  Rebuilding /usr/share/applications/bamf-2.index...
  bagfile $

#+END_EXAMPLE

*** [[http://gparted.org/][gpart]]ed                                                    :gparted:分区:

GParted is a free partition editor for graphically managing your disk
partitions.

1. 自由软件
2. 无损
3. 支持多文件系统
4. 跨平台


**** reference

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/068691ea-74cb-4746-9e01-aab7c5fea39b/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D151a03fff49%3AS%3Da7cdab468b0fda8aa40c273b7e670af5][使用Gparted]]为Ubuntu分区
+

**** 手记
+ 2015/12/14 Ubuntu下安装XP双系统需要额外两个Windows分区，尝试gparted使用失败，放弃

** 虚拟系统
*** QENU
+ http://wiki.qemu.org/Main_Page
+ http://wiki.qemu.org/Manual
+
   https://wiki.archlinux.org/index.php/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)
+ [[http://www.linuxforu.com/2011/06/qemu-for-embedded-systems-development-part-1/][Using QEMU for Embedded Systems Development, Part 1]]
+ [[http://www.linuxforu.com/2011/07/qemu-for-embedded-systems-development-part-2/][Using QEMU for Embedded Systems Development, Part 2]]
+ [[http://www.linuxforu.com/2011/08/qemu-for-embedded-systems-development-part-3/][Using QEMU for Embedded Systems Development, Part 3 ]]
+ [[http://www.crifan.com/summary_qemu_usage_note/][QEMU使用心得]]
+ http://blog.sina.com.cn/s/blog_4cd90db30100ccxy.html
+ [[http://www.tinylab.org/why-computer-students-learn-linux-open-source-technologies/][为什么计算机的学生要学习 Linux 开源技术]]
+ [[http://www.tinylab.org/using-qemu-simulation-inserts-the-type-system-to-produce-the-whole-process/][利用qemu模拟嵌入式系统制作全过程]]

**** what
QEMU是一款开源的模拟器及虚拟机监管器(Virtual Machine Monitor, VMM)。

QEMU主要提供两种功能给用户使用。
1. 一是作为用户态模拟器，利用动态代码翻译机制来执行不同于主机架构的代
   码。
2. 二是作为虚拟机监管器，模拟全系统，利用其他VMM(Xen, KVM, etc)来使用
   硬件提供的虚拟化支持，创建接近于主机性能的虚拟机。
**** Install
1. 包管理器
   + Debian: apt-get
   + RedHat: yum
2. 源码
   1) 获取源码
      + 官网：http://wiki.qemu.org/Main_Page
      + git: https://github.com/qemu/qemu
   2) 编译安装
      获取源码后，可以根据需求来配置和编译QEMU。
      #+BEGIN_EXAMPLE
        $cd qemu-2.0.0 //如果使用的是git下载的源码，执行cd qemu
        $./configure --enable-kvm --enable-debug --enable-vnc \
        --enable-werror --target-list="x86_64-softmmu"
        $make -j8
        $sudo make install
      #+END_EXAMPLE

      configure脚本用于生成Makefile，其选项可以用
      `./configure --help`查看。这里使用到的选项含义如下：

      + --enable-kvm：编译KVM模块，使QEMU可以利用KVM来访问硬件提供的虚
        拟化服务。
      + --enable-vnc：启用VNC。
      + --enalbe-werror：编译时，将所有的警告当作错误处理。
      + --target-list：选择目标机器的架构。默认是将所有的架构都编译，
        但为了更快的完成编译，指定需要的架构即可。
**** 创建虚拟机
+
  https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/qemu1_%25e4%25bd%25bf%25e7%2594%25a8qemu%25e5%2588%259b%25e5%25bb%25ba%25e8%2599%259a%25e6%258b%259f%25e6%259c%25ba?lang=en


1. 创建虚拟机镜像

   使用qemu-img创建虚拟机镜像。虚拟机镜像用来模拟虚拟机的硬盘，在启动
   虚拟机之前需要创建镜像文件(.img文件)。
   #+BEGIN_EXAMPLE
     $ qemu-img create -f qcow2 fedora.img 10G
   #+END_EXAMPLE
   + -f选项用于指定镜像的格式，qcow2格式是QEMU最常用的镜像格式，采用来写时复制技术来优化性能。
   + file.img是镜像文件的名字
   + 10G是镜像文件大小。

   镜像文件创建完成后，可使用qemu-system-x86来启动x86架构的虚拟机：
   #+BEGIN_EXAMPLE
   $ qemu-system-x86_64 fedora.img `
   #+END_EXAMPLE

2. 使用系统镜像文件安装操作系统
   #+BEGIN_EXAMPLE
     $ qemu-system-x86_64 -m 2048 -enable-kvm fedora.img \
       -cdrom ./Fedora-Live-Desktop-x86_64-20-1.iso
   #+END_EXAMPLE

   + -m 指定虚拟机内存大小，默认单位是MB
   + -enable-kvm使用KVM进行加速
   + -cdrom添加fedora的安装镜像

  可在弹出的窗口中操作虚拟机，安装操作系统，安装完成后重起虚拟机便会从
   硬盘(fedora.img)启动。之后再启动虚拟机只需要执行：
   #+BEGIN_EXAMPLE
     $ qemu-system-x86_64 -m 2048 -enable-kvm fedora.img
   #+END_EXAMPLE

*** virtualbox extension download address
http://download.virtualbox.org/virtualbox/
*** Virtual box usb
VirtualBox 使用宿主机的USB设备需要安装扩展包。根据自己的vbox的版本，到
vbox官网下载对应的扩展包。

之后，打开虚拟系统设置，在“USB设备”标签下，勾选上"启用USB控制器"以及
"2.0控制器"增加对USB2.0 的支持。

vbox 所在的用户组比如要包括当前用户才行。

查看当前用户名：
#+BEGIN_EXAMPLE
  $ whoami
#+END_EXAMPLE

查看vbox 所在的组：
#+BEGIN_EXAMPLE
$ cat /etc/group | grep vbox
vboxusers:x:125
#+END_EXAMPLE

将当前用户加入vbox组：
#+BEGIN_EXAMPLE
$ usermod -a -G vboxusers USER
#+END_EXAMPLE

即可。

此时，重启系统。再次打开虚拟机，果然，USB设备都已经被识别、访问到了。

这些，在“设备”菜单下就可以看到。

*** NAT
在计算机网络中，网络地址转换（英语：Network Address Translation，缩写
为NAT），也叫做网络掩蔽或者IP掩蔽（IP masquerading），是一种在IP封包通
过路由器或防火墙时重写源IP地址或目的IP地址的技术。这种技术被普遍使用在
有多台主机但只通过一个公有IP地址访问因特网的私有网络中。

NAT是作为一种解决IPv4地址短缺以避免保留IP地址困难的方案而流行起来的。
网络地址转换在很多国家都有很广泛的使用。

公网、内网是两种Internet的接入方式。

内网接入方式：上网的计算机得到的IP地址是Inetnet上的保留地址，保留地址有如下3种形式：
+ 10.x.x.x
+ 172.16.x.x至172.31.x.x
+ 192.168.x.x

内网的计算机以NAT（网络地址转换）协议，通过一个公共的网关访问Internet。
内网的计算机可向Internet上的其他计算机发送连接请求，但Internet上其他的
计算机无法向内网的计算机发送连接请求。

公网接入方式：上网的计算机得到的IP地址是Inetnet上的非保留地址。公网的
计算机和Internet上的其他计算机可随意互相访问。

NAT（Network Address Translator）是网络地址转换，它实现内网的IP地址与
公网的地址之间的相互转换，将大量的内网IP地址转换为一个或少量的公网IP地
址，减少对公网IP地址的占用。NAT的最典型应用是：在一个局域网内，只需要
一台计算机连接上Internet，就可以利用NAT共享Internet连接，使局域网内其
他计算机也可以上网。使用NAT协议，局域网内的计算机可以访问Internet上的
计算机，但Internet上的计算机无法访问局域网内的计算机。
*** ant                                                               :ant:
+ wiki: http://en.wikipedia.org/wiki/apache_ant
+ tutorial: http://ideoplex.com/focus/java#ant
+ official page: http://ant.apache.org/

**** overview
Apache Ant is a Java library and command-line tool that help building
software.

***** what
Apache Ant is a software tool for automating software build
processes.(*like make*) It was a replacement for the *unix make* build
tool, and was created due to a number of problems with the unix make.

***** language
It is similar to Make but is *implemented using the Java language*,
requires the Java platform, and is best suited to building Java
projects.

***** vs make
The most immediately noticeable difference between Ant and Make is
that *Ant uses XML* to describe the build process and its
dependencies, whereas Make uses Makefile format.

By default the XML file is named *build.xml*.
***** license
Ant is an Apache project. It is open source software, and is released
under the *Apache License*.
**** Install
+ source code: need to configure java, so just quit
+ apt
