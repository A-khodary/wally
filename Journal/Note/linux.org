* Fundamental                                                         :LINUX:
** Linux基础
*** 特点

+ Linux是一款开放源代码的自由软件
+ 完全兼容POSIX标准
+ 多用户多任务系统
+ 良好的界面，包括文本界面（命令行界面CLI）和图形用户界面（GUI）
+ 支持多种文件系统，包括EXT， EXT2, EXT3, NFS, NTFS等
+ 丰富的网络功能：完善的内置网络是Linux的一大特点，Linux在通信和网络功能方面
  与内核结合紧密，优于其他操作系统
+ 可靠的系统安全。
+ 良好的可移植性

*** 版本号

Linux的版本号分为两部分：内核（Kernel）和发行套件（Distribute）版本，
内核版本号一般为x.y.zz-wwww,

+ x.y为Linux的主版本号
+ zz为次版本号
+ www表示发行号。

#+BEGIN_SRC sh
uname -a    # 列出Linux系统版本号
#+END_SRC

#+RESULTS:
: Linux ben 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:18 UTC 2015 i686 i686 i686 GNU/Linux

*** 结构

一个完整的Linux操作系统由Linux内核，shell，文件系统和实用工具组成。

1. 内核是Linux操作系统的心脏。

2. shell是系统的用户界面，提供了用户与内核进行交互操作的借口。
   主流的shell包括

   + Bourne Shell
   + BASH
   + Korn Shell
   + C Shell.

3. 文件结构是文件存放在磁盘等存储设备上的组织方法。

4. 实用工具。

*** 操作系统分类

1. 根据包管理系统，可分为：
   + RPM包管理: Red Hat
   + Deb包管理，Debian和Ubuntu
2. 根据X Windwo系统，可分为：
   + KDE
   + GNOME

** 环境变量 env                                                        :env:
*** [[http://www.cyberciti.biz/howto/question/general/linux-unix-list-common-environment-variables.php][Linux/UNIX list of common environment variables]] :blog:

Environment variables are a variable key pair stored in the shell's
environment space. Here is a list of common environment variables:

| *Variable*          | *Description*                                                                          |
| HISTFILE            | The name of the file in which command history is saved                                 |
| HISTFILESIZE        | The maximum number of lines contained in the history file                              |
| HOSTNAME            | The system's host name                                                                 |
| LD_LIBRARY_PATH   | It is a colon-separated set of directories where libraries should be searched for      |
| PS1                 | Your default (first) shell prompt                                                      |
| USER                | Current logged in user's name.                                                         |
| PATH                | Colon separated list of directories to search for binaries.                            |
| DISPLAY             | Network name of the X11 display to connect to, if available.                           |
| SHELL               | The current shell.                                                                     |
| TERM                | The name of the user's terminal. Used to determine the capabilities of the terminal.   |
| TERMCAP             | Database entry of the terminal escape codes to perform various terminal functions.     |
| OSTYPE              | Type of operating system.                                                              |
| MACHTYPE            | The CPU architecture that the system is running on.                                    |
| EDITOR              | The user's preferred text editor.                                                      |
| PAGER               | The user's preferred text pager.                                                       |
| MANPATH             | Colon separated list of directories to search for manual pages.                        |

** UNIX哲学
Unix哲学是一套基于Unix操作系统顶级开发者的经验出来的软件开发的准则和哲
学。
+ 程序应该只关注一个目标，并尽可能地把它做好
+ 让程序能够互相协同工作。
+ 应该让程序文本数据流，因为这是一个通用的接口。

** 启动                                                    :boot:
*** [[http://wuchong.me/blog/2014/07/14/linux-boot-process/][Linux基础：启动流程]] :blog:

计算机的启动是一个非常复杂的过程，从打开电源到桌面的显示，需要经过一系
列不可或缺的过程，了解这些过程有助于我们更好地理解操作系统，也有助于我
们修复系统可能出现的问题。

**** 0. 启动流程一览

我们先给出 Linux 启动流程的总览图，然后再每一个模块展开说明。

#+DOWNLOADED: http://ww4.sinaimg.cn/large/81b78497jw1eic3rqn72tj20hf06774l.jpg @ 2016-01-26 20:30:03
 [[~/Wally/Journal/Figure/.org-download/Tasks/81b78497jw1eic3rqn72tj20hf06774l_2016-01-26_20:30:03.jpg]]

**** 1. BIOS

当我们按下电源按键后，计算机硬件会自动读取主板上的BIOS（Basic
Input/Output
System）来加载硬件信息以及硬件系统的自我测试。BIOS也是一套程序，它知道如何与硬件进行交互。BIOS首先会对硬件进行检查，判断计算机硬件是否能满足运行的基本条件，这叫做“硬件自检”（Power-On
Self-Test，简称 POST）。

硬件自检后，BIOS
会将控制权交给下一段启动程序。这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部存储设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot
Sequence）。

因此，BIOS按照”启动顺序”，把控制权转交给排在第一位的存储设备。

**** 2. MBR

系统读取位列第一的可启动存储设备。计算机先读取该设备的第一个扇区，也就是读取最前面的512个字节。这最前面的512个字节，就叫做”主引导记录”（Master
boot record，缩写为MBR）。MBR
只有512字节，放不了太多东西，它主要告诉计算机从该设备的哪一个分区（partition）来装载引导加载程序（boot
loader）。Boot Loader
储存有操作系统（OS）的相关信息，比如操作系统名称，操作系统内核（kernel）所在位置等。它的主要功能就是加载内核到内存中去执行。常用的
boot loader 有 GRUB 和 LILO 。

那我们经常说到的多操作系统是怎么回事呢？其实每个文件系统（或分区）的最前面会保留一个引导扇区（boot
selector），这个引导扇区可以安装 boot loader。这样我们在每个 boot loader
中对应不同的操作系统，在读取 MBR 的时候选择我们需要启动的 boot loader
即可。

**** 3. kernel

随后，boot loader
会帮助我们加载内核，内核就会开始检测硬件与加载驱动程序。没错，内核会以自己的功能重新检测一遍硬件，而不一定会使用
BIOS 检测到的硬件信息。也就是说，内核此时才开始接管 BIOS 后的工作。

Kernel
实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过
kernel 传达给硬件。

**** 4. init process

在内核加载完毕以后，此时内核会主动调用第一个进程，那就是
=/sbin/init=，它的作用就是初始化系统环境。使用=pstree=命令会发现init的进程编号（PID）是1，也就是说init是第一个运行的程序，其他所有进程都从它衍生，都是它的子进程。

许多程序需要开机启动。它们在Windows叫做”服务”（service），在 Linux
就叫做”守护进程”（daemon）。

init
进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动
Apache，用作桌面就不需要。Linux
允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（run
level）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。

基本上，依据有无网络与有无 X Window ，Linux 将 run level
划分为7个等级（0-6）。其中0是关机，1是单用户模式，6是重启。而
2-5，一般来说都是多用户模式。

Linux
在启动各个服务前会先执行一系列的初始脚本（rc.sysinit）。这些脚本执行如下功能：设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络......
之后会根据运行级别的不同，系统会运行 rc0.d 到 rc6.d
目录中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。rc*.d目录中存放的是该运行级别中需要执行的服务脚本的软链接文件（即快捷方式）。

除此之外，Linux
还会运行一些其他的初始脚本。运行完后，操作系统已经完全准备好了，只是，还没有人可以登录！！！init
会给出登录（login）对话框，或者是图形化的登录界面。

**** 5. login

输入用户名密码登录成功后，系统会为用户分配一个用户 ID（UID），和一个组
ID（GID）。这两个 ID
就好像身份证一样会一直伴随用户，用于检测用户执行程序时的身份验证。

当用户登录成功后，一个完整的操作系统就展现在用户的面前了。哈哈！

**** 总结

结合一开始给出的流程图，Linux 的启动流程可以概括为以下几个主要步骤：

1. 加载 BIOS 的硬件信息与硬件自检，并依据设置取得第一个可启动的设备；
2. 读取并执行第一个启动设备内的MBR的 boot loader；
3. 依据 boot loader 的设置加载内核，内核会开始检测硬件与加载驱动程序；
4. 在内核 Kernel 加载完毕后，Kernel 会主动调用 init 进程，而 init 会取得
   run-level 信息；
5. init 执行 rc.sysinit 初始化系统的操作环境（网络、时区等）；
6. init 启动 run-level 的各个服务；
7. 用户登录

要注意在一开始的流程图中 init
虽然只用了一个模块展现出来，但其实在启动过程中 init 占了很大的比重。

**** 参考文献

- [[http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html][Linux 的启动流程]]
- [[http://www.ruanyifeng.com/blog/2013/02/booting.html][计算机是如何启动的？]]
- [[http://www.cnblogs.com/vamei/archive/2012/09/05/2672039.html][Linux开机启动 (bootstrap)]]
- [[http://vbird.dic.ksu.edu.tw/linux_basic/linux_basic.php][鸟哥的Linux私房菜.基础学习篇]]

**
** 文件系统                                                          :LINUX:
*** /tmp                                                              :tmp:

http://www.cnblogs.com/hnrainll/archive/2011/06/08/2074976.html


我们知道，在Linux系统中/tmp文件夹里面的文件会被清空，至于多长时间被清
空，如何清空的，可能大家知识的就不多了，所以，今天我们就来剖析一个这两
个问题。
**** Fedora
先来看看tmpwatch这个命令，他的作用就是删除一段时间内不使用的文件
（removes files which haven’t been accessed for a period of time）。
具体的用法就不多说了，有兴趣的自行研究。我们主要看看和这个命令相关的计
划任务文件。

他就是/etc/cron.daily/tmpwatch，我们可以看一下这个文件里面的内容
#+BEGIN_SRC sh :exports code
  #! /bin/sh
  flags=-umc
  /usr/sbin/tmpwatch "$flags" -x /tmp/.X11-unix -x /tmp/.XIM-unix \
          -x /tmp/.font-unix -x /tmp/.ICE-unix -x /tmp/.Test-unix \
          -X '/tmp/hsperfdata_*' 10d /tmp
  /usr/sbin/tmpwatch "$flags" 30d /var/tmp
  for d in /var/{cache/man,catman}/{cat?,X11R6/cat?,local/cat?}; do
      if [ -d "$d" ]; then
          /usr/sbin/tmpwatch "$flags" -f 30d "$d"
      fi
  done
#+END_SRC

这个脚本大家仔细分析一下就明白了，第一行相当于一个标记（参数），第二行
就是针对/tmp目录里面排除的目录，第三行，这是对这个/tmp目录的清理，下面
的是针对其他目录的清理，就不说了。

我们就来看/usr/sbin/tmpwatch "$flags" 30d /var/tmp这一行，关键的是这个
30d，就是30天的意思，这个就决定了30天清理/tmp下不访问的文件。如果说，
你想一天一清理的话，就把这个30d改成1d。这个你懂的……哈哈！

但有个问题需要注意，如果你设置更短的时间来清理的话，比如说是30分钟、10
秒等等，你可以在这个文件中设置，但你会发现重新电脑，他不清理/tmp文件夹
里面的内容，这是为什么呢？这就是tmpwatch他所在的位置决定的，他的上层目
录是/etc/cron.daily/，而这个目录是第天执行一次计划任务，所以说，你设置
了比一天更短的时间，他就不起作用了。这下明白了吧。

所以结论是：在RHEL6中，系统自动清理/tmp文件夹的默认时限是30天

**** 在Debian/Ubuntu系统中
在Ubuntu系统中，在/tmp文件夹里面的内容，每次开机都会被清空，如果不想让
他自动清理的话，只需要更改rcS文件中的TMPTIME的值。

我们看如何来修改: sudo vi /etc/default/rcS

把 TMPTIME=0 修改成 TMPTIME=-1或者是无限大, 改成这样的话，系统在重新启
动的时候就不会清理你的/tmp目录了。

依些类推，如果说要限制多少时间来更改的话，就可以改成相应的数字（本人没
有测试，我是这么理解的）

所以结论是：在Ubuntu中，系统自动清理/tmp文件夹的时限默认每次启动

*** /etc/passwd文件                                                :passwd:


在Linux /etc/passwd文件中每个用户都有一个对应的记录行，它记录了这个用
户的一些基本属性。系统管理员经常会接触到这个文件的修改以完成对用户的管
理工作。这个文件对所有用户都是可读的。

它的内容类似下面的例子：
#+BEGIN_EXAMPLE
  ＃cat/etc/passwd

  root:x:0:0:Superuser:/:
  daemon:x:1:1:Systemdaemons:/etc:
  bin:x:2:2:Ownerofsystemcommands:/bin:
  sys:x:3:3:Ownerofsystemfiles:/usr/sys:
  adm:x:4:4:Systemaccounting:/usr/adm:
  uucp:x:5:5:UUCPadministrator:/usr/lib/uucp:
  auth:x:7:21:Authenticationadministrator:/tcb/files/auth:
  cron:x:9:16:Crondaemon:/usr/spool/cron:
  listen:x:37:4:Networkdaemon:/usr/net/nls:
  lp:x:71:18:Printeradministrator:/usr/spool/lp:
  sam:x:200:50:Samsan:/usr/sam:/bin/sh
#+END_EXAMPLE
/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，
其格式和具体含义如下：

*用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell*


1. “用户名”是代表用户账号的字符串。通常长度不超过8个字符，并且由大小
   写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。
   为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和
   加号(+)打头。

2. “口令”一些系统中，存放着加密后的用户口令字。虽然这个字段存放的只
   是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可
   读，所以这仍是一个安全隐患。因此，现在许多Linux系统（如SVR4）都使用
   了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而
   在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者
   “*”。

3. “用户标识号”是一个整数，系统内部用它来标识用户。一般情况下它与用
   户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部
   将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及
   不同的登录Shell等。

   通常用户标识号的取值范围是0～65535。0是超级用户root的标识号，1～99
   由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，
   这个界限是500。

4. “组标识号”字段记录的是用户所属的用户组。它对应着/etc/group文件中
   的一条记录。

5. “注释性描述”字段记录着用户的一些个人情况，例如用户的真实姓名、电
   话、地址等，这个字段并没有什么实际的用途。在不同的Linux系统中，这个
   字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的
   注释性描述文字，用做finger命令的输出。

6. “主目录”，也就是用户的起始工作目录，它是用户在登录到系统之后所处
   的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，
   而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、
   执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。

7. 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用
   户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用
   户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。
   常用的有
   + sh(BourneShell)
   + csh(CShell)
   + ksh(KornShell)
   + tcsh(TENEX/TOPS-20typeCShell)
   + bash(BourneAgainShell)

   系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指
   定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。
   用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释
   器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应
   用程序运行结束后，用户就自动退出了系统。有些Linux系统要求只有那些在
   系统中登记了的程序才能出现在这个字段中。

*** 文件服务器
NFS简单，Samba灵活

**** NFS                                                             :nfs:

***** NFS                                                     :wikipedia:
- [[https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F][Wikipedia]]
- [[http://nfs.sourceforge.net/][SouceForge: Linux NFS overview, FAQ, and HOWTO documents]]

***** intro

*NFS* (/Network FileSystem/ ，网络文件系统)是由SUN公司发展，并于1984年推出
的技术， _用于在不同机器，不同操作系统之间通过网络互相分享各自的文件_
NFS设计之初就是为了在不同的系统间使用，所以它的通讯协议设计与主机及操
作系统无关。

NFS分 /服务器/ 和 /客户机/ ，当使用远端文件时只要用 /mount/ 命令就可把远端NFS服务
器上的文件系统挂载在本地文件系统之下，操作远程文件与操作本地文件没有不
同。NFS服务器所共享文件或目录记录在 */etc/exports* 文件中。

_嵌入式Linux开发中，会经常使用NFS_ ，目标系统通常作为NFS客户机使用，Linux
主机作为NFS服务器。在目标系统上通过NFS，将服务器的NFS共享目录挂载到本
地，可以直接运行服务器上的文件。在调试系统驱动模块以及应用程序，NFS都
是十分必要的，并且Linux还支持 _NFS根文件系统，能直接从远程NFS root启动
系统_ ，这对嵌入式Linux根文件系统裁剪和集成也是十分有必要的。

***** 服务器端

1. 安装nfs:

   #+BEGIN_EXAMPLE
   sudo apt-get instal nfs-kernel-server
   #+END_EXAMPLE

2. 配置： */etc/exports*

   #+BEGIN_EXAMPLE
   目录 IP(选项...)
   #+END_EXAMPLE

3. 启动：

   #+BEGIN_EXAMPLE
   sudo service nfs-kernel-servel start/stop/restart
   #+END_EXAMPLE

****** 选项

- ro   只读访问

- rw   读写访问

- sync   所有数据在请求时写入共享

- async   nfs在写入数据前可以响应请求

- secure   nfs通过1024以下的安全TCP/IP端口发送

- insecure   nfs通过1024以上的端口发送

- wdelay   如果多个用户要写入nfs目录，则归组写入（默认）

- no_wdelay   如果多个用户要写入nfs目录，则立即写入，当使用async时，无
  需此设置

- hide   在nfs共享目录中不共享其子目录

- no_hide   共享nfs目录的子目录

- subtree_check   如果共享/usr/bin之类的子目录时，强制nfs检查父目录的
  权限（默认）

- no_subtree_check   不检查父目录权限

- all_squash   共享文件的UID和GID映射匿名用户anonymous，适合公用目录

- no_all_squash   保留共享文件的UID和GID（默认）

- root_squash   root用户的所有请求映射成如anonymous用户一样的权限（默
  认）

- no_root_squash   root用户具有根目录的完全管理访问权限

- anonuid=xxx   指定nfs服务器/etc/passwd文件中匿名用户的UID

- anongid=xxx   指定nfs服务器/etc/passwd文件中匿名用户的GID

***** 客户端

挂载：

#+BEGIN_EXAMPLE
sudo mount -t nfs 192.168.1.12:/shared/path /mnt
#+END_EXAMPLE

***** [[http://www.cnblogs.com/Charles-Zhang-Blog/archive/2013/02/05/2892879.html][ubuntu下搭建nfs服务器]] :blog:

*1.1 *搭建NFS服务器

NFS（Network FileSystem，网络文件系统）是由SUN公司发展，并于1984年推出
的技术，用于在不同机器，不同操作系统之间通过网络互相分享各自的文件。
NFS设计之初就是为了在不同的系统间使用，所以它的通讯协议设计与主机及操
作系统无关。

NFS分服务器和客户机，当使用远端文件时只要用mount命令就可把远端NFS服务
器上的文件系统挂载在本地文件系统之下，操作远程文件与操作本地文件没有不
同。NFS服务器所共享文件或目录记录在/etc/exports文件中。

嵌入式Linux开发中，会经常使用NFS，目标系统通常作为NFS客户机使用，Linux
主机作为NFS服务器。在目标系统上通过NFS，将服务器的NFS共享目录挂载到本
地，可以直接运行服务器上的文件。在调试系统驱动模块以及应用程序，NFS都
是十分必要的，并且Linux还支持NFS根文件系统，能直接从远程NFS root启动系
统，这对嵌入式Linux根文件系统裁剪和集成也是十分有必要的。

安装 nfs-kernel-server：

#+BEGIN_EXAMPLE
ky@ubuntu:~$ sudo apt-get install nfs-kernel-server
#+END_EXAMPLE

设置NFS-Server目录。修改 */etc/exports* 文件，在其中增加NFS服务器目录。
一个NFS服务器可以共享多个NFS目录，在/etc/exports文件中，每个目录的设置
独占一行，编写格式如下：

#+BEGIN_EXAMPLE
NFS共享目录路径 客户机IP或者名称(参数1,参数2,...,参数n)
#+END_EXAMPLE

说明：

- NFS共享目录可以是主机的任何一个目录，为了方便使用，最好将权限设置为
  777。
- 客户机指的是可以访问共享目录的客户机的IP或者主机名，可以是指定的IP或
  者主机名。如果使用IP，可以使用通配符。假如指定IP为192.168.1.x的客户
  机可以访问，可以写成192.168.1.*，如果设置为*，则表示任何客户机都可以
  访问。
- 访问参数可以是一个，也可以是多个，用逗号分开。

|------------------+------------------------------------------------------------------|
| 参数             | 说明                                                             |
|------------------+------------------------------------------------------------------|
| ro               | 只读访问                                                         |
| rw               | 读写访问                                                         |
| sync             | 所有数据在请求时写入共享                                         |
| async            | nfs在写入数据前可以响应请求                                      |
| secure           | nfs通过1024以下的安全TCP/IP端口发送                              |
| insecure         | nfs通过1024以上的端口发送                                        |
| wdelay           | 如果多个用户要写入nfs目录，则归组写入（默认）                    |
| no_wdelay        | 如果多个用户要写入nfs目录，则立即写入，当使用async时，无需此设置 |
| hide             | 在nfs共享目录中不共享其子目录                                    |
| no_hide          | 共享nfs目录的子目录                                              |
| subtree_check    | 如果共享/usr/bin之类的子目录时，强制nfs检查父目录的权限（默认）  |
| no_subtree_check | 不检查父目录权限                                                 |
| all_squash       | 共享文件的UID和GID映射匿名用户anonymous，适合公用目录            |
| no_all_squash    | 保留共享文件的UID和GID（默认）                                   |
| root_squash      | root用户的所有请求映射成如anonymous用户一样的权限（默认）        |
| no_root_squash   | root用户具有根目录的完全管理访问权限                             |
| anonuid=xxx      | 指定nfs服务器/etc/passwd文件中匿名用户的UID                      |
| anongid=xxx      | 指定nfs服务器/etc/passwd文件中匿名用户的GID                      |
|------------------+------------------------------------------------------------------|

假定NFS共享目录是/home/ky/nfs，允许所有客户机访问，/etc/exports文件可写为：

#+BEGIN_EXAMPLE
/home/ky/nfs *(rw,sync,no_subtree_check, no_root_squash)
#+END_EXAMPLE

*逗号后面不能有空格*

启动NFS服务器。启动portmap（如果有必要）和nfs-kernel-server服务：

#+BEGIN_EXAMPLE
$ sudo service portmap start
$ sudo service nfs-kernel-server start
#+END_EXAMPLE

本地验证NFS服务器。将NFS服务器目录挂载到本机另外一个目录下，可以看到挂
载点目录下可以看到NFS服务器目录中的文件。

#+BEGIN_EXAMPLE
sudo mount -t nfs 127.0.0.1:/home/ky/nfs /mnt
#+END_EXAMPLE

用开发板验证NFS服务器是否可用。启动开发板，进入系统，配置好开发板的IP
地址后，用mount命令挂载NFS服务器的NFS目录：

#+BEGIN_EXAMPLE
mount -t nfs 192.168.1.3:/home/ky/nfs /mnt -o nolock
#+END_EXAMPLE

挂载成功后，可以在开发板的/mnt目录下看到NFS服务器上的文件。

说明，使用开发板与虚拟机安装的客户系统进行NFS挂载，需要将虚拟网卡设置
为Bridged模式，并建议使用静态IP地址。

如果在使用中需要增加新的NFS共享目录，直接修改/etc/exports文件即可。修
改该文件后，可以不用重启NFS服务，用 *exportfs* 命令读取/etc/exports文
件，重新共享输出。exportfs命令语法如下：

#+BEGIN_EXAMPLE
exportfs [-aruv]
#+END_EXAMPLE

选项说明：

-a：全部挂载(或卸载) /etc/exports的设置；

-r：重新挂载/etc/exports的设置；

-u：卸载某一个目录；

-v：在输出的时候，把共享目录显示出来。

 如果NFS已经启动，修改了/etc/exports文件，执行如下命令，新的设置即可生效：

ky@ubuntu:~$ *exportfs -ra*

**** samba: Opening Windows to a Wider World                       :samba:
- State "NEXT"       from ""           [2015-12-28 一 19:53] \\
  samba 安装时出现问题，依赖不满足

***** reference

+ [[https://www.samba.org/][Homepage]]

***** check

#+BEGIN_EXAMPLE
   $ dpkg -l | grep samba
  ii  python-samba                                          2:4.1.6+dfsg-1ubuntu2.14.04.7                       i386         Python bindings for Samba
  ii  samba-common                                          2:4.1.6+dfsg-1ubuntu2.14.04.7                       all          common files used by both the Samba server and client
  ii  samba-common-bin                                      2:4.1.6+dfsg-1ubuntu2.14.04.7                       i386         Samba common files used by both the server and the client
  ii  samba-libs:i386                                       2:4.1.6+dfsg-1ubuntu2.14.04.7                       i386         Samba core libraries
#+END_EXAMPLE

***** quick guide

+ https://www.samba.org/samba/docs/man/Samba-Guide/simple.html#id2550864

***** 什么时候需要源码安装

当 debian 包安装出现问题时。

*** MD5
+ http://zh.wikipedia.org/wiki/MD5

MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用
的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），
用于确保信息传输完整一致。MD5由罗纳德·李维斯特设计，于1992年公开，用以
取代MD4算法。

MD5已经广泛使用在为文件传输提供一定的可靠性方面。例如，服务器预先提供
一个MD5校验和，用户下载完文件以后，用MD5算法计算下载文件的MD5校验和，
然后通过检查这两个校验和是否一致，就能判断下载的文件是否出错。

*** 文件命名规则

1. 隐藏文件

   以 “.” 字符开头的文件名是隐藏文件。这仅表示，ls 命令不能列出它们，
   用 ls -a 命令就可以了。

2. 大小写敏感

   文件名和命令名是大小写敏感的。文件名“File1”和“ﬁle1”是指两个不同
   的文件名。

3. 文件扩展名

   Linux 没有“文件扩展名”的概念，不像其它一些系统。可以用你喜欢的任
   何名字来给文件起名。文件内容或用途由其它方法来决定。虽然类 Unix 的
   操作系统，不用文件扩展名来决定文件的内容或用途，但是有些应用程序会。

4. 文件命名

   虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅
   限使用“.”，“-”，下划线。 *最重要的是，不要在文件名中使用空格。*
   如果你想表示词与词间的空格，用下划线字符来代替。过些时候，你会感激
   自己这样做。

**** 小结
1. 隐藏文件
2. 大小写敏感
3. 扩展名不必要
4. 不要有空格
*** 文件目录树

*在Linux中，没有秘密存在。*

1. /

   根目录，万物起源

2. /bin

   包含 Linux 内核，最初的 RMA 磁盘映像（系统启动时，由驱动程序所需），
   和启动加载程序。

   有趣的文件：
   + /boot/grub/grub.conf or menu.lst，被用来配置启动加载程序。
   + /boot/vmlinuz，Linux 内核。

3. /dev

   这是一个包含设备结点的特殊目录。“一切都是文件”，也使用于设备。在
   这个目录里，内核维护着它支持的设备。

4. /etc

   这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本，在
   系统启动时，这些脚本会运行每个系统服务。这个目录中的任何文件应该是
   可读的文本文件。有意思的文件：虽然/etc 目录中的任何文件都有趣，但这
   里只列出了一些我一直喜欢的文件：
   + /etc/crontab，定义自动运行的任务。
   + /etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。
   + /etc/passwd，包含用户帐号列表。

5. /home

   在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通
   只能在他们自己的目录下创建文件。这个限制保护系统免受错误的用户活动
   破坏。

6. /lib

   包含核心系统程序所需的库文件。这些文件与 Windows 中的动态链接库相似。

7. /lost+found

   每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统，都会
   有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。除非文
   件系统真正的损坏了，那么这个目录会是个空目录。

8. /media

   在现在的 Linux 系统中，/media 目录会包含可移除媒体设备的挂载点，例
   如 USB 驱动器，CD-ROMs 等等。这些设备连接到计算机之后，会自动地挂载
   到这个目录结点下。

9. /mnt

   在早些的 Linux 系统中，/mnt 目录包含可移除设备的挂载点。

10. /opt

    这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能安装在
    系统中的商业软件产品。

11. /proc

    这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的
    文件系统。反而，它是一个由 Linux 内核维护的虚拟文件系统。它所包含
    的文件是内核的窥视孔。这些文件是可读的，它们会告诉你内核是怎样监管
    计算机的。

12. /root

    root 帐户的家目录。

13. /sbin

    这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常
    为超级用户保留。

14. /tmp

    用来存储由各种程序创建的临时文件的地方。一些配置，导致系统每次重新
    启动时，都会清空这个目录。

15. /usr

    在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的
    所有程序和文件。

16. /usr/bin

    /usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程
    序。

17. /usr/lib

    包含由/usr/bin 目录中的程序所用的共享库。

18. /usr/local

    这个/usr/local 目录，是非系统发行版自带，却打算让系统使用的程序的
    安装目录。通常，由源码编译的程序会安装在/usr/local/bin 目录下。新
    安装的 Linux 系统中，会存在这个目录，但却是空目录，直到系统管理员
    放些东西到它里面。

19. /usr/sbin

    包含许多系统管理程序。

20. /usr/share

    /usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。其中
    包括像默认的配置文件，图标，桌面背景，音频文件等等。

21. /usr/share/doc

    大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下，
    我们可以找到按照软件包分类的文档。

22. /var

    除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，
    这是说，它们的内容不会改变。/var 目录是可能需要改动的文件存储的地
    方。各种数据库，假脱机文件，用户邮件等等，都驻扎在这里。

23. /var/log

    这个/var/log 目录包含日志文件，各种系统活动的记录。这些文件非常重
    要，并且应该时时监测它们。其中最重要的一个文件是/var/log/messages。
    注意，为了系统安全，在一些系统中，你必须是超级用户才能查看这些日志
    文件。
*** 根目录空间不足

#+BEGIN_EXAMPLE
卷文件系统根目录仅剩余856M的硬盘空间
#+END_EXAMPLE

- 增加主分区容量，可以使用U盘启动ubuntu，然后用gparted调整

- 在分一个区，挂接到/var, /opt, 然后把已有文件copy过去就行  *这是个严
  重的陷阱*

- 系统应该有个叫baobab的图形界面程序，点开看看/分区都有哪些东西占地方
  咯

- apt-get autoclean看看把安装软件下载的缓存清理掉

**** /usr/local 空间不足

/usr/local 挂载的分区大小为20G，完全不够用

移动 /usr/local/MATLAB 并建立软链接后，MATLAB 启动不了

以同样的方式处理 texlive 暂时没有问题

*** [[http://www.ibm.com/developerworks/cn/linux/l-roadmap/part8/][ Windows 到 Linux 之旅: 第 8 部分. 备份与恢复]]             :blog:backup:

/Linux 备份与恢复速成指南/

Linux
是一个稳定而可靠的环境。但是任何计算系统都有无法预料的事件，比如硬件故障。拥有关键配置信息的可靠备份是任何负责任的管理计划的组成部分。在
Linux
中可以通过各种各样的方法来执行备份。所涉及的技术从非常简单的脚本驱动的方法，到精心设计的商业化软件。备份可以保存到远程网络设备、磁带驱动器和其他可移动媒体上。备份可以是基于文件的或基于驱动器映像的。可用的选项很多，您可以混合搭配这些技术，为您的环境设计理想的备份计划。

**** 确定策略

可以采用许多不同的方法来备份系统。欲了解关于这方面的一些信息，您可以阅读本文结尾处
[[#resources][参考资料]] 中列出的“Introduction to Backing Up and
Restoring Data”一文。

所备份的内容很大程度上取决于您备份它们的理由。您是否试图从严重的故障（比如硬盘驱动器问题）中恢复？您是否想归档以便能在需要时恢复旧的文件？您计划从一个冷系统和还原着手，还是从一个预加载的备用系统着手？

--------------

[[#ibm-pcon][回页首]]

**** 确定要备份的内容

在备份和还原系统时，Linux 基于文件的性质成了一个极大的优点。在 Windows
系统中，注册表与系统是非常相关的。配置和软件安装不仅仅是将文件放到系统上。因此，还原系统就需要有能够处理
Windows 这种特性的软件。在 Linux
中，情况就不一样了。配置文件是基于文本的，并且除了直接处理硬件时以外，它们在很大程度上是与系统无关的。硬件驱动程序的现代方法是，使它们以动态加载的模块的形式可用，这样内核就变得更加与系统无关。不同于让备份必须处理操作系统如何安装到系统和硬件上的复杂细节，Linux
备份处理的是文件的打包和解包。

一般情况下，以下这些目录是需要备份的：

- */etc*

   包含所有核心配置文件。这其中包括网络配置、系统名称、防火墙规则、用户、组，以及其他全局系统项。
- */var*
    包含系统守护进程（服务）所使用的信息，包括 DNS 配置、DHCP
   租期、邮件缓冲文件、HTTP 服务器文件、db2 实例配置，等等。
- */home*

   包含所有用户的默认用户主目录。这包括他们的个人设置、已下载的文件和用户不希望失去的其他信息。
- */root*
    是根（root）用户的主目录。
- */opt*
    是安装许多非系统文件的地方。IBM 软件就安装在这里。OpenOffice、JDK
   和其他软件在默认情况下也安装在这里。

有些目录是应该考虑 /不/备份的。

- */proc*

   应该永远不要备份这个目录。它不是一个真实的文件系统，而是运行内核和环境的虚拟化视图。它包括诸如
   /proc/kcore
   这样的文件，这个文件是整个运行内存的虚拟视图。备份这些文件只是在浪费资源。
- */dev*
    包含硬件设备的文件表示。如果计划还原到一个空白的系统，那就可以备份
   /dev。然而，如果计划还原到一个已安装的 Linux 系统，那么备份 /dev
   是没有必要的。

其他目录包含系统文件和已安装的包。在服务器环境中，这其中的许多信息都不是自定义的。大多数自定义都发生在
/etc 和/home 目录中。不过出于完整性的考虑，您可能希望备份它们。

在生产环境中，我希望确保数据不会丢失，因而我会备份除 /proc
目录之外的整个系统。如果最担心用户和配置，我会仅备份 /etc、/var、/home
和 /root 目录。

--------------

[[#ibm-pcon][回页首]]

**** 备份工具

正如前面提到过的， Linux
备份在很大程度上就是打包和解包文件。这允许使用现有的系统实用工具和脚本来执行备份，而不必购买商业化的软件包。在许多情况下，这类备份将是足够的，并且为管理员提供了极大的控制能力。备份脚本可以使用
=cron= 命令来自动化，这个命令控制 Linux 中预定的事件。

***** tar

=tar= 是一个已移植到 Linux 中的经典 UNIX 命令。 =tar= 是 *t*ape
*ar*chive（磁带归档）的缩写，最初设计用于将文件打包到磁带上。如果您下载过
Linux 源代码，或许已经碰到过 tar
文件。这是一个基于文件的命令，它本质上是连续地、首尾相连地堆放文件。

使用 =tar=
可以打包整个目录树，这使得它特别适合用于备份。归档文件可以全部还原，或从中展开单独的文件和目录。备份可以保存到基于文件的设备或磁带设备上。文件可以在还原时重定向，以便将它们重新放到一个与最初保存它们的目录（或系统）不同的目录（或系统）。
=tar= 是与文件系统无关的。它可以使用在 ext2、ext3、 jfs、Reiser
和其他文件系统上。

使用 =tar= 非常类似于使用诸如 PKZip
这样的文件实用工具。只需将它指向一个目的（可以是文件或设备），然后指定您想要打包的文件。您可以通过标准的压缩类型来动态压缩归档文件，或指定一个自己选择的外部压缩程序。要通过
bzip2 压缩或解压缩文件，可使用 = tar -z= 命令。

要使用 = tar= 来把除 /proc 目录之外的整个文件系统备份到 SCSI 磁带设备：

#+BEGIN_EXAMPLE
    tar -cpf /dev/st0 / --exclude=/proc
#+END_EXAMPLE

在上面的例子中， =-c= 开关表示归档文件正在被创建。 =-p=
开关表示我们希望保留文件许可权限，这对良好的备份来说是很关键的。 =-f=
开关指向该归档文件的文件名。在本例中，我们使用的是原始磁带设备
/dev/st0。/
表示我们想要备份的内容。既然我们想要备份整个系统，因此把这个开关指定为根（root）。当把
=tar= 指向一个目录（以 / 结尾）时，它会自动递归。最后，我们排除了 /proc
目录，因为它没有包含需要保存的任何内容。如果单盒磁带容纳不下这个备份，我们需要添加
=-M= 开关（本例中没有显示）以进行多卷备份。

**** 以防万一

不要忘了 Linux 是区分大小写的。例如， =tar=
命令应该总是以小写的形式执行。命令行开关可以是大写、小写或大小写的混合。例如，
=-t= 和 =-T=
执行不同的功能。文件或目录名称可以混合使用大小写，而且就像命令和命令行开关一样，是区分大小写的。

要还原一个或多个文件，可以使用带提取开关（ =-x= ）的 =tar= 命令：

#+BEGIN_EXAMPLE
    tar -xpf /dev/st0 -C /
#+END_EXAMPLE

这里的 =-f= 开关同样指向归档文件， =-p= 开关表明我们想要还原归档的权限。
=-x= 开关表明从归档中提取文件。 =-C /= 表明我们想要让还原从 / 开始。
=tar= 通常还原到运行这个命令的目录。 =-C= 开关使我们的当前目录不再相关。

您可能会经常使用的另外两个 =tar= 命令是 =-t= 和 =-d= 开关。 =-t=
开关列出某个归档文件的内容。 =-d=
开关将归档文件的内容与系统上的当前文件作比较。

为便于操作和编辑，您可以将想要归档的文件和目录放进一个文本文件中，然后在命令行通过
=-T=
开关引用这个文本文件。这些文件和目录可以与命令行上列出的其他目录结合起来。下面的命令行备份
MyFiles 中列出的所有文件和目录、/ 根目录和 /tmp 目录中的所有 iso 文件。

#+BEGIN_EXAMPLE
    tar -cpf /dev/st0 -T MyFiles /root /tmp/*.iso
#+END_EXAMPLE

文件列表只是一个文本文件，其中列出文件或目录。下面是一个例子：

#+BEGIN_EXAMPLE
    /etc


    /var


    /home


    /usr/local


    /opt
#+END_EXAMPLE

请注意 =tar -T= （或 =files-from=
）命令不能接受通配符。文件必须明确地列出。上面的例子展示了一种单独地引用文件的方法。您还可以执行脚本来搜索系统，然后建立一个列表。下面就是这样一个脚本的例子：

#+BEGIN_EXAMPLE
    #!/bin/sh


    cat MyFiles > TempList


    find /usr/share -iname *.png >> TempList


    find /tmp -iname *.iso >> TempList


    tar -cpzMf /dev/st0 -T TempList
#+END_EXAMPLE

上面的脚本首先将 MyFiles 中的所有现有文件列表复制到
TempList。然后它执行两个 =find=
命令来搜索文件系统中匹配某个模式的文件，并将它们附加到
TempList。第一次是搜索 /usr/share 目录树中以 =.png=
结尾的所有文件。第二次是搜索 /tmp 目录树中以 =.iso=
结尾的所有文件。在建立好列表之后， =tar= 然后在文件设备 /dev/st0
（第一个 SCSI 磁带设备）上创建 一个新的归档文件，该文件使用 g *z*ip
格式来压缩，并保留所有文件权限。该归档文件将跨越多个卷。要归档的文件的名称将从
TempList 文件中提取。

还可以使用脚本来执行更精细的操作，比如增量备份。Gerhard Mourani 在他的
/Securing and Optimizing Linux/
一书中给出了一个优秀的脚本，您可在本文结尾处的
[[#resources][参考资料]]中找到关于这本书的信息。

也可以编写脚本来还原文件，虽然还原通常是手动进行的。正如上面提到过的，用于提取文件的
=-x= 开关代替了 =-c=
开关。可以还原整个归档文件，或者还原指定的个别文件或者目录。使用通配符来引用归档文件中的文件是可以的。还可以使用开关来转储和还原。

--------------

[[#ibm-pcon][回页首]]

**** dump 和 restore

=dump= 可以执行类似 =tar= 的功能。然而， =dump=
倾向于考虑文件系统而不是个别的文件。下面是引自 dump
手册文件中的内容：“dump 检查 ext2
文件系统上的文件，并确定哪些文件需要备份。这些文件将出于安全保护而被复制到给定的磁盘、磁带或其他存储媒体上......大于输出媒体容量的转储将被划分到多个卷。在大多数媒体上，容量是通过一直写入直至返回一个
end-of-media 标记来确定的。”

配合 =dump= 的程序是 =restore= ，它用于从转储映像还原文件。

=restore=
命令执行转储的逆向功能。可以首先还原文件系统的完全备份，而后续的增量备份可以在已还原的完全备份之上覆盖。可以从完全或部分备份中还原单独的文件或者目录树。

=dump= 和 =restore=
都能在网络上运行，因此您可以通过远程设备进行备份或还原。 =dump= 和
=restore= 使用磁带驱动器和提供广泛选项的文件设备。然而，两者都仅限用于
ext2 和 ext3 文件系统。如果使用的是 JFS、Reiser
或者其他文件系统，您将需要其他的实用工具，比如 =tar= 。

--------------

[[#ibm-pcon][回页首]]

**** 使用 dump 执行备份

使用 =dump= 执行备份是相当简单的。下面的命令执行一个完全 Linux
备份，它把所有 ext2 和 ext3 文件系统备份到一个 SCSI 磁带设备。

#+BEGIN_EXAMPLE
    dump 0f /dev/nst0 /boot


    dump 0f /dev/nst0 /
#+END_EXAMPLE

在这个例子中，系统中有两个文件系统。一个用于 /boot，另一个用于 */*
，这是常见的配置。它们必须在执行备份时单独地引用。 /dev/nst0 引用第一个
SCSI
磁带驱动器，不过是以非重绕的模式引用。这样确保各个卷在磁带上一个接一个地排列。

=dump= 的一个有趣特性是其内置的增量备份功能。在上面的例子中， *0* 表示 0
级或基本级备份。这是完全系统备份，您要定期执行以保存整个系统。对于后续的备份，您可以使用其他数字（1-9）来代替
0，以改变备份级别。1 级备份会保存自从执行 0
级备份以来更改过的所有文件。2 级备份会保存自从执行 1
级备份以来更改过的所有文件，以此类推。使用 =tar=
和脚本可以执行相同的功能，但要求脚本创建人员提供一种机制来确定上次备份是何时执行的。
=dump=
具有它自己的机制，即它在执行备份时会输出一个更新文件（/etc/dumpupdates）。这个更新文件将在每次执行
0 级备份时被重设。后续级别的备份会保留它们的标记，直至执行另一次 0
级备份。如果您在执行基于磁带的备份， =dump= 会自动跟踪多个卷。

**** 跳过文件

标记将被 =dump= 跳过的文件和目录是可以做到的。实现此目的的命令是
=chattr= ，它改变 ext2 和 ext3 文件系统上的扩展属性。

chattr +d <filename>

上面的命令向文件添加一个标记，让 =dump= 在执行备份时跳过该文件。

--------------

[[#ibm-pcon][回页首]]

**** 使用 restore 来执行还原

要还原使用 =dump= 保存的信息，可以使用 =restore= 命令。像 =tar= 一样，
=dump= 能够列出（ =-t= ）归档文件的内容，并与当前文件作比较（ =-C=
）。使用 =dump=
時必须小心的地方是还原数据。有两种非常不同的还原方法，您必须使用正确的方法才能获得可预测的结果。

***** 重建 (-r)

记住，在设计 =dump=
时考虑得更多的是文件系统，而不是单独的文件。因此，存在两种不同的文件还原风格。要重建一个文件系统，可使用
=-r=
命令行开关。设计重建的目的是为了能在空文件系统上操作，并将它还原为已保存的状态。在执行重建之前，您应该已经创建、格式化和装载（mount）了该文件系统。不应该对包含文件的文件系统执行重建。

下面是使用上面执行的转储来执行完全重建的例子。

#+BEGIN_EXAMPLE
    restore -rf /dev/nst0
#+END_EXAMPLE

上面这个命令需要针对要还原的每个文件系统分别执行。

在需要的时候，可以重复这个过程来添加增量备份。

***** 提取 (-x)

如果需要使用单独的文件而不是使用整个文件系统，您必须使用 =-x=
开关来提取它们。例如，要仅从我们的磁带备份中提取 /etc
目录，可使用以下命令：

#+BEGIN_EXAMPLE
    restore -xf /dev/nst0 /etc
#+END_EXAMPLE

***** 交互式还原 (-i)

=restore= 提供的另外一个特性是交互式模式。使用命令：

#+BEGIN_EXAMPLE
    restore -if /dev/nst0
#+END_EXAMPLE

将把您置于交互式 shell
中，同时还显示了包含在该归档文件中的项。键入“help”将会显示一个命令列表。然后您就可以浏览并选择希望提取的项。务必记住，您提取的任何文件都将进入当前目录。

--------------

[[#ibm-pcon][回页首]]

**** dump 与 tar

=dump= 和 =tar= 都有一批拥护者。两者都各有优点和缺点。如果您运行的是除
ext2 或 ext3 之外的任何文件系统，那么 =dump=
就对您不可用。然而如果不是这种情况，那么只需最少的脚本就能运行 =dump=
，并且 =dump= 还具有可用于帮助还原的交互式模式。

我倾向于使用 =tar=
，因为我喜欢编写脚本来获得额外的控制级别。此外还有用于操作 .tar
文件的多平台工具。

--------------

[[#ibm-pcon][回页首]]

**** 其他工具

在 Linux
中，任何能够复制文件的程序都可以用来执行某种程度的备份。有人就使用
=cpio= 和 =dd= 来执行备份 。 =cpio= 是又一个与 =tar=
差不多的打包实用工具，但使用得不太普遍。 =dd=
是一个文件系统复制实用工具，它产生文件系统的二进制副本。 =dd =
还可用于产生硬盘驱动器的映像，类似于使用诸如 Symantec 的 Ghost
这样的产品。然而， =dd=
不是基于文件的，因此您只能使用它来将数据还原到完全相同的硬盘驱动器分区。

--------------

[[#ibm-pcon][回页首]]

**** 商业化备份产品

可用于 Linux
的商业化备份产品有很多。商业化产品一般提供了便利的界面和报告系统，而在使用诸如
=dump= 和 =tar=
这样的工具时，您必须自食其力。商业化产品很广泛，通常提供大量的特性。使用商业软件包的最大好处是，有一个预先建立的用于处理备份的策略，您可以立即投入工作。商业化的开发人员已经犯了您即将要犯的许多错误，他们的智慧的代价相比于丢失您的宝贵数据来说是廉价的。

***** Tivoli Storage Manager

Tivoli Storage Manager 或许是现在可用于 Linux
的最好的商业化备份和存储管理实用工具。Tivoli Storage Manager
服务器可运行在多种平台上，包括
Linux，而客户机则可以运行在更多种类的平台上。

本质上，Storage Manager
服务器是通过适合于备份该环境的设备来配置的。要参与备份的任何系统都要加载一个与服务器通信的客户机。备份可以按计划执行、通过
Tivoli Storage Manager 客户机界面手动执行，或者使用基于 Web
的界面远程执行。

TSM
基于策略的性质意味着无需经常调整文件列表，就能够为备份行为定义中心规则。此外，IBM
Tivoli Storage Resource Manager
还能够识别、评估、控制和预测企业存储资产的利用情况，能够检测潜在的问题并自动应用自修复调整。更多细节请参见
Tivoli Web 站点（参见 [[#resources][参考资料]]中的链接）。

******* 图 1. Tivoli Storage Manager 菜单

[[tivsm0.jpg]]

然后备份和还原就通过远程设备来处理 *。*

******* 图 2. Tivoli Storage Manager 界面

[[tivsm1.jpg]]

--------------

[[#ibm-pcon][回页首]]

**** 前瞻和回顾

拥有良好备份的第一步是拥有计划。首先知道您需要保存的数据以及需要什么恢复策略，然后使用最适合该策略的工具。

Linux 附带了一些现成的（out of the box）有用备份工具。其中两个最常用的是
=tar= 和 =dump/restore=
。两者都能执行完全系统备份。使用创造性的脚本，您能够设计一个自定义的方案来本地和远程地备份系统。

然而，编写自己的备份脚本可能是一项繁重的任务，对于复杂的企业来说更是如此。诸如
Tivoli Storage Manager
这样的商业化软件降低了学习难度，并允许您立即控制自己的备份，但是您可能必须调整自己的策略来适应这些工具的功能。

*** [[http://tieba.baidu.com/p/1184618169][Linux系统备份的两种办法]]                                   :blog:backup:

经听到很多人抱怨 Linux 下没有 ghost 这样“方便”的备份工具。这是一种普遍的误解，其实 Linux 下是可以用 ghost for Linux 的，但因为有更好的办法，所以 ghost 在 Linux 下用得少，知名度不高。

现在以我的系统为例，介绍两种 Linux 下最常见最实用的系统备份方案。我的系统是 Gentoo Linux，sda1 30GB，挂载为 /，sda2 400GB，挂载为 /home, sda3 100GB，格式化为 ext4，空闲。

**** dd
dd 是最强劲有力、稳定可靠的备份工具。

备份：当前系统下，

~ % sudo dd if=/dev/sda1 of=~/gentoo_$(date +"%Y-%m-%d").backup

还原：其它 Linux 系统或者 LiveCD/LiveUSB 下，

~ % sudo dd if=gentoo_*.backup of=/dev/sda1

如果要改变根分区的位置，比如说把根分区移动到 sda5，那麽还需要调整一下：

~ % sudo resize2fs -f /dev/sda5
~ % sudo e2fsck -f /dev/sda5

然后修改恢复出来的 /etc/fstab 文件。

请注意 sda5 的容量必须大于 sda1.

dd 备份简单快速，是速度优先的最好选择，但所需要的磁盘空间比较大。

**** tar + xz
tar 用于打包，xz 用于压缩。

备份：当前系统下，

~ % cd /

/ % sudo tar Jcpvf ~/gentoo_amd64_$(date +"%Y-%m-%d").tar.xz --exclude=./usr/portage/distfiles --exclude=./home --exclude=./lost+found --exclude=./sys --exclude=./proc .

其中，--exclude= 参数列出了不需要备份的目录，可以根据实际情况自行调整。

还原：其它 Linux 系统或者 LiveCD/LiveUSB 下，

~ % sudo mkfs.ext4 /dev/sda1

~ % sudo mount -v /dev/sda1 /mnt

~ % sudo cd /mnt/

~ % sudo tar xpvf gentoo_amd64_*.tar.xz

~ % sudo mkdir -pv home sys proc usr/portage/distfiles

~ % cd && sudo umount -v /mnt

如果移动了根分区，则需要修改还原出来的 /etc/fstab 文件

tar+xz 压缩打包备份的优点，在于极高的压缩率，可以大大减少备份文件的大小。我的备份以前的 / 分区有 11G 大小，而备份出来的 .tar.xz 文件，只有 2.1G，压缩比为超过了 5:1. 但这带来一个问题：备份耗时漫长。比如说我这次 11G 的压缩备份就花了 2 小时。幸好还原速度还可以，只需要 8 分钟。此外，如果你 man 一下 tar，就会发现这种做法其实十分灵活好用。

我就介绍这两种办法，欢迎纠正和补充。

** 系统管理                                                          :LINUX:
*** 用户管理
http://www.chinaunix.net/old_jh/4/438660.html

Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用
户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。
用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们
对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保
护。每个用户账号都拥有一个惟一的用户名和各自的口令。用户在登录时键入正
确的用户名和口令后，就能够进入系统和自己的主目录。

实现用户账号的管理，要完成的工作主要有如下几个方面：
+ 用户账号的添加、删除与修改。
+ 用户口令的管理。
+ 用户组的管理。

**** Linux 用户管理
用户账号的管理工作主要涉及到用户账号的添加、修改和删除。

添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、
主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。
***** 添加用户

添加新的用户账号使用useradd命令，其语法如下：
#+BEGIN_EXAMPLE
useradd 选项 用户名
#+END_EXAMPLE

其中各选项含义如下：

+ -c comment 指定一段注释性描述。

+ -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建
  主目录。

+ -g 用户组 指定用户所属的用户组。

+ -G 用户组，用户组 指定用户所属的附加组。

+ -s Shell文件 指定用户的登录Shell。

+ -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户
  的标识号。

+ 用户名 指定新账号的登录名。


例
#+BEGIN_EXAMPLE
# useradd –d /usr/sam -m sam
#+END_EXAMPLE

此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录
/usr/sam（/usr为默认的用户主目录所在的父目录）。

#+BEGIN_EXAMPLE
# useradd -s /bin/sh -g group –G adm,root gem
#+END_EXAMPLE

此命令新建了一个用户gem，该用户的登录Shell是/bin/sh，它属于group用户组，
同时又属于adm和root用户组，其中group用户组是其主组。
这里可能新建组：#groupadd group及groupadd adm　
　
增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他
系统文件如/etc/shadow, /etc/group等。

Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。

***** 删除用户
如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将
/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。删
除一个已有的用户账号使用userdel命令，其格式如下：

#+BEGIN_EXAMPLE
userdel 选项 用户名
#+END_EXAMPLE

常用的选项是-r，它的作用是把用户的主目录一起删除。

#+BEGIN_EXAMPLE
# userdel sam
#+END_EXAMPLE

此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow,
/etc/group等）的记录，同时删除用户的主目录。

***** 修改账号

修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户
组、登录Shell等。

修改已有用户的信息使用usermod命令，其格式如下：

#+BEGIN_EXAMPLE
usermod 选项 用户名
#+END_EXAMPLE

常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与
useradd命令中的选项一样，可以为用户指定新的资源值。另外，有些系统可以
使用如下选项： -l 新用户名

这个选项指定一个新的账号，即将原来的用户名改为新的用户名。
例如：
#+BEGIN_EXAMPLE
# usermod -s /bin/ksh -d /home/z –g developer sam
#+END_EXAMPLE

此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为
developer。

***** 用户口令管理
用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是
被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。

指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指
定口令，普通用户只能用它修改自己的口令。命令的格式为：

#+BEGIN_EXAMPLE
passwd 选项 用户名
#+END_EXAMPLE

可使用的选项：

+ -l 锁定口令，即禁用账号。

+ -u 口令解锁。

+ -d 使账号无口令。

+ -f 强迫用户下次登录时修改口令。

如果默认用户名，则修改当前用户的口令。

例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：
#+BEGIN_EXAMPLE
$ passwd

Old password:******
New password:*******
Re-enter new password:*******
#+END_EXAMPLE

如果是超级用户，可以用下列形式指定任何用户的口令：
#+BEGIN_EXAMPLE
# passwd sam

New password:*******
Re-enter new password:*******
#+END_EXAMPLE

普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输
入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用
户为用户指定口令时，就不需要知道原口令。

为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，
口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。

为用户指定空口令时，执行下列形式的命令：

#+BEGIN_EXAMPLE
# passwd -d sam
#+END_EXAMPLE

此命令将用户sam的口令删除，这样用户sam下一次登录时，系统就不再询问口令。

passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如：

#+BEGIN_EXAMPLE
# passwd -l sam
#+END_EXAMPLE

**** Linux 用户组管理

***** 增加用户组
增加一个新的用户组使用groupadd命令。其格式如下：
#+BEGIN_EXAMPLE
groupadd 选项 用户组
#+END_EXAMPLE

可以使用的选项有：
+ -g GID 指定新用户组的组标识号（GID）。

+ -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID
  相同。

#+BEGIN_EXAMPLE
# groupadd group1
#+END_EXAMPLE
此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组
标识号的基础上加1。

#+BEGIN_EXAMPLE
#groupadd -g 101 group2
#+END_EXAMPLE

此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。

***** 删除用户组
如果要删除一个已有的用户组，使用groupdel命令，其格式如下：
#+BEGIN_EXAMPLE
groupdel 用户组
#+END_EXAMPLE

#+BEGIN_EXAMPLE
#groupdel group1
#+END_EXAMPLE
此命令从系统中删除组group1。

***** 修改用户组属性
修改用户组的属性使用groupmod命令。其语法如下：
#+BEGIN_EXAMPLE
groupmod 选项 用户组
#+END_EXAMPLE

常用的选项有：
+ -g GID 为用户组指定新的组标识号。

+ -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。

+ -n新用户组 将用户组的名字改为新名字


#+BEGIN_EXAMPLE
# groupmod -g 102 group2
#+END_EXAMPLE
此命令将组group2的组标识号修改为102。

#+BEGIN_EXAMPLE
# groupmod –g 10000 -n group3 group2
#+END_EXAMPLE
此命令将组group2的标识号改为10000，组名修改为group3。

***** 切换用户组
如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有
其他用户组的权限。用户可以在登录后，使用命令newgrp切换到其他用户组，这
个命令的参数就是目的用户组。例如：

#+BEGIN_EXAMPLE
$ newgrp root
#+END_EXAMPLE

这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的
主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管
理工具来完成。

**** 与用户账号相关的系统文件
完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文
件进行修改。与用户和用户组相关的信息都存放在一些系统文件中，这些文件包
括/etc/passwd, /etc/shadow, /etc/group等。下面分别介绍这些文件的内容。

***** /etc/passwd
*/etc/passwd文件是用户管理工作涉及的最重要的一个文件。* Linux系统中的
每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一
些基本属性。这个文件对所有用户都是可读的。它的内容类似下面的例子：

#+BEGIN_EXAMPLE
  ＃ cat /etc/passwd


  root:x:0:0:Superuser:/:

  daemon:x:1:1:System daemons:/etc:

  bin:x:2:2:Owner of system commands:/bin:

  sys:x:3:3:Owner of system files:/usr/sys:

  adm:x:4:4:System accounting:/usr/adm:

  uucp:x:5:5:UUCP administrator:/usr/lib/uucp:

  auth:x:7:21:Authentication administrator:/tcb/files/auth:

  cron:x:9:16:Cron daemon:/usr/spool/cron:

  listen:x:37:4:Network daemon:/usr/net/nls:

  lp:x:71:18:Printer administrator:/usr/spool/lp:

  sam:x:200:50:Sam san:/usr/sam:/bin/sh
#+END_EXAMPLE

从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记
录又被冒号(:)分隔为7个字段，其格式和具体含义如下：

#+BEGIN_EXAMPLE
用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
#+END_EXAMPLE

1) “用户名”是代表用户账号的字符串。通常长度不超过8个字符，并且由大小
   写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。
   为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和
   加号(+)打头。

2) “口令”一些系统中，存放着加密后的用户口令字。。虽然这个字段存放的
   只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都
   可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都
   使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，
   而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者
   “*”。

3) “用户标识号”是一个整数，系统内部用它来标识用户。一般情况下它与用
   户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部
   将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及
   不同的登录Shell等。

   通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99
   由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，
   这个界限是500。

4) “组标识号”字段记录的是用户所属的用户组。它对应着/etc/group文件中
   的一条记录。

5) “注释性描述”字段记录着用户的一些个人情况，例如用户的真实姓名、电
   话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这
   个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意
   的注释性描述文字，用做finger命令的输出。

6) “主目录”，也就是用户的起始工作目录，它是用户在登录到系统之后所处
   的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，
   而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、
   执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。

7) 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用
   户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用
   户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。
   常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell),
   tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。系统
   管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定
   Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。

   用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释
   器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应
   用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些
   在系统中登记了的程序才能出现在这个字段中。

****** 伪用户
系统中有一类用户称为伪用户（psuedo users），这些用户在/etc/passwd文件
中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主
要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下
所示。

|--------+--------------------------|
| 伪用户 | 含义                     |
|--------+--------------------------|
| bin    | 拥有可执行的用户命令文件 |
| sys    | 拥有系统文件             |
| adm    | 拥有帐户文件             |
| uucp   | UUCP使用                 |
| lp     | lp或lpd子系统使用        |
| nobody | NFS使用                  |
|--------+--------------------------|

 拥有帐户文件

除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。

　　

****** 安全增强
由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较
明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高
的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件
是/etc/shadow文件。只有超级用户才拥有该文件读权限，这就保证了用户密码
的安全性。

***** /etc/shadow
*/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据
/etc/passwd中的数据自动产生。*

它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用“:”隔开。
这些字段是：
#+BEGIN_EXAMPLE
登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
#+END_EXAMPLE
1) “登录名”是与/etc/passwd文件中的登录名相一致的用户账号

2) “口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，
   则对应用户没有口令，登录时不需要口令；如果含有不属于集合 {
   ./0-9A-Za-z }中的字符，则对应的用户不能登录。

3) “最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时
   的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时
   间起点是1970年1月1日。

4) “最小时间间隔”指的是两次修改口令之间所需的最小天数。

5) “最大时间间隔”指的是口令保持有效的最大天数。

6) “警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的
   天数。

7) “不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。

8) “失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就
   给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不
   能再用来登录了。

***** /etc/group
*用户组的所有信息都存放在/etc/group文件中。*

将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。每个用
户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。
当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属
的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属于附
加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。用
户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于
/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：

#+BEGIN_EXAMPLE
组名:口令:组标识号:组内用户列表
#+END_EXAMPLE

1) “组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一
   样，组名不应重复。

2) “口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都
   没有口令，即这个字段一般为空，或者是*。

3) “组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。

4) “组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号
   (,)分隔。这个用户组可能是用户的主组，也可能是附加组。

*** [[http://www.chinaunix.net/old_jh/4/438660.html][Linux的用户和用户组管理]]                                          :blog:
Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。

实现用户账号的管理，要完成的工作主要有如下几个方面：
· 用户账号的添加、删除与修改。
· 用户口令的管理。
· 用户组的管理。


一、Linux系统用户账号的管理

用户账号的管理工作主要涉及到用户账号的添加、修改和删除。

添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。

1、添加新的用户账号使用useradd命令，其语法如下：


useradd 选项 用户名


其中各选项含义如下：

-c comment 指定一段注释性描述。

-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。

-g 用户组 指定用户所属的用户组。

-G 用户组，用户组 指定用户所属的附加组。

-s Shell文件 指定用户的登录Shell。

-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。

用户名 指定新账号的登录名。


2、例子说明

例1：


# useradd –d /usr/sam -m sam


此命令创建了一个用户sam，
其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam（/usr为默认的用户主目录所在的父目录）。


例2：


# useradd -s /bin/sh -g group –G adm,root gem


此命令新建了一个用户gem，该用户的登录Shell是/bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。
这里可能新建组：#groupadd group及groupadd adm　

增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。

Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。


3、删除帐号

如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。删除一个已有的用户账号使用userdel命令，其格式如下：


userdel 选项 用户名


常用的选项是-r，它的作用是把用户的主目录一起删除。

例如：


# userdel sam


此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。


4、修改帐号

修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。

修改已有用户的信息使用usermod命令，其格式如下：


usermod 选项 用户名


常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。另外，有些系统可以使用如下选项：


 -l 新用户名


这个选项指定一个新的账号，即将原来的用户名改为新的用户名。

例如：


# usermod -s /bin/ksh -d /home/z –g developer sam


此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。


5、用户口令的管理

用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。

指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：


passwd 选项 用户名


可使用的选项：

-l 锁定口令，即禁用账号。

-u 口令解锁。

-d 使账号无口令。

-f 强迫用户下次登录时修改口令。

如果默认用户名，则修改当前用户的口令。


例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：

$ passwd

Old password:******

New password:*******

Re-enter new password:*******


如果是超级用户，可以用下列形式指定任何用户的口令：

# passwd sam

New password:*******

Re-enter new password:*******


普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。

为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。

为用户指定空口令时，执行下列形式的命令：


# passwd -d sam


此命令将用户sam的口令删除，这样用户sam下一次登录时，系统就不再询问口令。

passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如：


# passwd -l sam



 wingger 回复于：2004-11-04 13:03:40

二、Linux系统用户组的管理

每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。
用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。

1、增加一个新的用户组使用groupadd命令。其格式如下：

groupadd 选项 用户组

可以使用的选项有：
-g GID 指定新用户组的组标识号（GID）。

-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。

例1：

# groupadd group1

此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。

例2：

#groupadd -g 101 group2

此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。

2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下：

groupdel 用户组

例如：

#groupdel group1

此命令从系统中删除组group1。

3、修改用户组的属性使用groupmod命令。其语法如下：

groupmod 选项 用户组

常用的选项有：
-g GID 为用户组指定新的组标识号。

-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。

-n新用户组 将用户组的名字改为新名字


例1：

# groupmod -g 102 group2

此命令将组group2的组标识号修改为102。

例2：

# groupmod –g 10000 -n group3 group2

此命令将组group2的标识号改为10000，组名修改为group3。

4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：

$ newgrp root

这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。

 wingger 回复于：2004-11-04 13:21:16

三、与用户账号有关的系统文件

完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。下面分别介绍这些文件的内容。

1、/etc/passwd文件是用户管理工作涉及的最重要的一个文件。Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。这个文件对所有用户都是可读的。它的内容类似下面的例子：

＃ cat /etc/passwd



root:x:0:0:Superuser:/:

daemon:x:1:1:System daemons:/etc:

bin:x:2:2:Owner of system commands:/bin:

sys:x:3:3:Owner of system files:/usr/sys:

adm:x:4:4:System accounting:/usr/adm:

uucp:x:5:5:UUCP administrator:/usr/lib/uucp:

auth:x:7:21:Authentication administrator:/tcb/files/auth:

cron:x:9:16:Cron daemon:/usr/spool/cron:

listen:x:37:4:Network daemon:/usr/net/nls:

lp:x:71:18:Printer administrator:/usr/spool/lp:

sam:x:200:50:Sam san:/usr/sam:/bin/sh


从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：


用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell


1）“用户名”是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。

2）“口令”一些系统中，存放着加密后的用户口令字。。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。

3）“用户标识号”是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。

通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。

4）“组标识号”字段记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。

5)“注释性描述”字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。

6)“主目录”，也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。

7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。

用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。


8)系统中有一类用户称为伪用户（psuedo users），这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下所示。

伪  用  户         含     义

 bin                        拥有可执行的用户命令文件

 sys                       拥有系统文件

 adm                     拥有帐户文件

 uucp                    UUCP使用

 lp                         lp或lpd子系统使用

 nobody                 NFS使用

 拥有帐户文件

除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。

由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。只有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。


2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生。它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用“:”隔开。这些字段是：


登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志


1）“登录名”是与/etc/passwd文件中的登录名相一致的用户账号
2）“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。
3）“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。
4）“最小时间间隔”指的是两次修改口令之间所需的最小天数。
5）“最大时间间隔”指的是口令保持有效的最大天数。
6）“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。
7）“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。
8）“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。

下面是/etc/shadow的一个例子：


＃ cat /etc/shadow



root:Dnakfw28zf38w:8764:0:168:7:::

daemon:*::0:0::::

bin:*::0:0::::

sys:*::0:0::::

adm:*::0:0::::

uucp:*::0:0::::

nuucp:*::0:0::::

auth:*::0:0::::

cron:*::0:0::::

listen:*::0:0::::

lp:*::0:0::::

sam:EkdiSECLWPdSa:9740:0:0::::



3、用户组的所有信息都存放在/etc/group文件中。

将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：


组名:口令:组标识号:组内用户列表


1）“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。
2）“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。
3）“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。
4）“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。

/etc/group文件的一个例子如下：

# cat /etc/group

root::0:root

bin::2:root,bin

sys::3:root,uucp

adm::4:root,adm

daemon::5:root,daemon

lp::7:root,lp

users::20:root,sam


 wingger 回复于：2004-11-04 13:31:28

四、添加量用户批

添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：

（1）先编辑一个文本用户文件，每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：

user001::600:100:user:/home/user001:/bin/bash

user002::601:100:user:/home/user002:/bin/bash

user003::602:100:user:/home/user003:/bin/bash

user004::603:100:user:/home/user004:/bin/bash

user005::604:100:user:/home/user005:/bin/bash

user006::605:100:user:/home/user006:/bin/bash


（2）以root身份执行命令/usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户：


# newusers < user.txt


然后可以执行命令vipw或vi /etc/passwd检查/etc/passwd文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。

（3）执行命令/usr/sbin/pwunconv，将/etc/shadow产生的shadow密码解码，然后回写到/etc/passwd中，并将/etc/shadow的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消shadow password功能。


# pwunconv


（4）编辑每个用户的密码对照文件，范例文件passwd.txt内容如下：

user001:密码

user002:密码

user003:密码

user004:密码

user005:密码

user006:密码


（5）以root身份执行命令/usr/sbin/chpasswd，创建用户密码，chpasswd会将经过/usr/bin/passwd命令编码过的密码写入/etc/passwd的密码栏。


# chpasswd < passwd.txt


（6）确定密码经编码写入/etc/passwd的密码栏后，执行命令/usr/sbin/pwconv将密码编码为shadow password，并将结果写入/etc/shadow。


# pwconv


这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。

 wingger 回复于：2004-11-04 13:39:12

五、赋予普通用户特殊权限

在Linux系统中，管理员往往不止一人，若每位管理员都用root身份进行管理工作，根本无法弄清楚谁该做什么。所以最好的方式是：管理员创建一些普通用户，分配一部分系统管理工作给他们。

我们不可以使用su让他们直接变成root，因为这些用户都必须知道root的密码，这种方法很不安全，而且也不符合我们的分工需求。一般的做法是利用权限的设置，依工作性质分类，让特殊身份的用户成为同一个工作组，并设置工作组权限。例如：要wwwadm这位用户负责管理网站数据，一般Apache Web Server的进程httpd的所有者是www，您可以设置用户wwwadm与www为同一工作组，并设置Apache默认存放网页目录/usr/local/httpd/htdocs的工作组权限为可读、可写、可执行，这样属于此工作组的每位用户就可以进行网页的管理了。

但这并不是最好的解决办法，例如管理员想授予一个普通用户关机的权限，这时使用上述的办法就不是很理想。这时您也许会想，我只让这个用户可以以root身份执行shutdown命令就行了。完全没错，可惜在通常的Linux系统中无法实现这一功能，不过已经有了工具可以实现这样的功能——sudo。

sudo通过维护一个特权到用户名映射的数据库将特权分配给不同的用户，这些特权可由数据库中所列的一些不同的命令来识别。为了获得某一特权项，有资格的用户只需简单地在命令行输入sudo与命令名之后，按照提示再次输入口令（用户自己的口令，不是root用户口令）。例如，sudo允许普通用户格式化磁盘，但是却没有赋予其他的root用户特权。

1、sudo工具由文件/etc/sudoers进行配置，该文件包含所有可以访问sudo工具的用户列表并定义了他们的特权。一个典型的/etc/sudoers条目如下：


liming ALL=(ALL) ALL


这个条目使得用户liming作为超级用户访问所有应用程序，如用户liming需要作为超级用户运行命令，他只需简单地在命令前加上前缀sudo。因此，要以root用户的身份执行命令format，liming可以输入如下命令：


# sudo /usr/sbin/useradd sam


注意：命令要写绝对路径，/usr/sbin默认不在普通用户的搜索路径中，或者加入此路径：PATH=$PATH:/usr/sbin;export PATH。另外，不同系统命令的路径不尽相同，可以使用命令“whereis 命令名”来查找其路径。

这时会显示下面的输出结果：

We trust you have received the usual lecture from the local System

Administrator. It usually boils down to these two things:

#1) Respect the privacy of others.

#2) Think before you type.

Password:


如果liming正确地输入了口令，命令useradd将会以root用户身份执行。

注意：配置文件/etc/sudoers必须使用命令 Visudo来编辑。

只要把相应的用户名、主机名和许可的命令列表以标准的格式加入到文件/etc/sudoers，并保存就可以生效，再看一个例子。

2、例子：管理员需要允许gem用户在主机sun上执行reboot和shutdown命令，在/etc/sudoers中加入：


gem sun=/usr/sbin/reboot，/usr/sbin/shutdown


注意：命令一定要使用绝对路径，以避免其他目录的同名命令被执行，从而造成安全隐患。

然后保存退出，gem用户想执行reboot命令时，只要在提示符下运行下列命令：


$ sudo /usr/sbin/reboot


输入正确的密码，就可以重启服务器了。

如果您想对一组用户进行定义，可以在组名前加上%，对其进行设置，如：


%cuug ALL=(ALL) ALL


3、另外，还可以利用别名来简化配置文件。别名类似组的概念，有用户别名、主机别名和命令别名。多个用户可以首先用一个别名来定义，然后在规定他们可以执行什么命令的时候使用别名就可以了，这个配置对所有用户都生效。主机别名和命令别名也是如此。注意使用前先要在/etc/sudoers中定义：User_Alias, Host_Alias, Cmnd_Alias项，在其后面加入相应的名称，也以逗号分隔开就可以了，举例如下：

Host_Alias SERVER=no1

User_Alias ADMINS=liming，gem

Cmnd_Alias SHUTDOWN=/usr/sbin/halt，/usr/sbin/shutdown，/usr/sbin/reboot

ADMINS SERVER=SHUTDOWN


4、再看这个例子：


ADMINS ALL=(ALL) NOPASSWD: ALL


表示允许ADMINS不用口令执行一切操作，其中“NOPASSWD:”项定义了用户执行操作时不需要输入口令。

5、sudo命令还可以加上一些参数，完成一些辅助的功能，如


$ sudo –l


会显示出类似这样的信息：

User liming may run the following commands on this host:

(root) /usr/sbin/reboot


说明root允许用户liming执行/usr/sbin/reboot命令。这个参数可以使用户查看自己目前可以在sudo中执行哪些命令。

6、在命令提示符下键入sudo命令会列出所有参数，其他一些参数如下：

-V 显示版本编号。

-h 显示sudo命令的使用参数。

-v 因为sudo在第一次执行时或是在N分钟内没有执行（N预设为5）会询问密码。这个参数是重新做一次确认，如果超过N分钟，也会问密码。

-k 将会强迫使用者在下一次执行sudo时询问密码（不论有没有超过N分钟）。

-b 将要执行的命令放在背景执行。

-p prompt 可以更改问密码的提示语，其中%u会替换为使用者的账号名称，%h会显示主机名称。

-u username/#uid 不加此参数，代表要以root的身份执行命令，而加了此参数，可以以username的身份执行命令（#uid为该username的UID）。

-s 执行环境变量中的 SHELL 所指定的 Shell ，或是 /etc/passwd 里所指定的 Shell。

-H 将环境变量中的HOME（宿主目录）指定为要变更身份的使用者的宿主目录。（如不加-u参数就是系统管理者root。）


 要以系统管理者身份（或以-u更改为其他人）执行的命令。

*** 软件管理                                                     :software:
**** 曾经源码安装的软件

apache-ant-1.9.4
Arduino
Arduino-Makefile
ARM
arm-linux
ArmLinux
auctex-11.88
avrdudess_20140805
bashdb-4.3-0.91
blender-2.74-linux-glibc211-i686
briss-0.9
build
cedet-1.1
CMake
crosstool-ng
ctags-5.8
DebPack
diashapes-0.3.0
ditaa
doxygen
emacs-24.4
emacs-w3m
espeak-1.48.04-source
fritzing-0.9.2b.linux.i386
Gazebo
gimp-2.8.8
global-6.4
gnupg-2.0.27
gnuplot-5.0.0
httpd-2.4.12
ibus-rime
ignitionrobotics-ign-math-12519225abe4
jimtcl
JLink_Linux_V498e_i386
lantern
latex2html-2012
ledger
mcu8051ide-1.4.10
mew-6.6
mysql-5.6.24
MySQL-python-1.2.4b4
octave-3.8.2
octomap
opencv
openocd-0.9.0
osrf-gazebo-76c670bfa1ea
osrf-sdformat-e720a29dc3df
pcl
phantomjs
php-5.6.8
pip-6.1.1
pyflakes
Pymacs
Python-3.4.3
python-mode
qemu-2.3.0
qt-creator-opensource-src-3.3.2
qt-everywhere-opensource-src-5.4.1
reciteword-0.8.5
sam-ba
samba-4.2.1
scrot
sdcv-0.5.0-beta2-Source
sdformat
SourceCode
sqlite-autoconf-3080900
stardict-3.0.1.2
tinyxml2
unoconv
vim74
w3m-0.5.3
wine-1.6.2
wkhtmltopdf
xmradio

**** 软件源配置                                                   :source:

*/etc/apt/sources.list.d*

#+BEGIN_EXAMPLE
   $ ls /etc/apt/sources.list.d
  dartsim-ppa-trusty.list              libccd-debs-ppa-trusty.list
  dartsim-ppa-trusty.list.save         libccd-debs-ppa-trusty.list.save
  dropbox.list.save                    lotem-rime-trusty.list
  fcitx-team-nightly-trusty.list       lotem-rime-trusty.list.save
  fcitx-team-nightly-trusty.list.save  mc3man-trusty-media-trusty.list
  fcl-debs-ppa-trusty.list             mc3man-trusty-media-trusty.list.save
  fcl-debs-ppa-trusty.list.save        ros-latest.list
  gazebo-latest.list                   ros-latest.list.save
  gazebo-latest.list.save              timxx-xmradio-trusty.list
  gazebo-stable.list                   timxx-xmradio-trusty.list.save
  gazebo-stable.list.save              wengxt-fcitx-nightly-trusty.list
  gophers-go-trusty.list               wengxt-fcitx-nightly-trusty.list.save
  gophers-go-trusty.list.save
#+END_EXAMPLE

*** Linux启动流程
+ http://wuchong.me/blog/2014/07/14/linux-boot-process/

**** 流程概览
计算机的启动是一个非常复杂的过程，从打开电源到桌面的显示，需要经过一系
列不可或缺的过程，了解这些过程有助于我们更好地理解操作系统，也有助于我
们修复系统可能出现的问题。

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{/home/wally/Wally/Journal/Figure/w3m/201505011524.jpg}
\end{figure}

**** 启动流程
1. BIOS

   当我们按下电源按键后，计算机硬件会自动读取主板上的BIOS（Basic
   Input/Output System）来加载硬件信息以及硬件系统的自我测试。BIOS也是
   一套程序，它知道如何与硬件进行交互。BIOS首先会对硬件进行检查，判断
   计算机硬件是否能满足运行的基本条件，这叫做“硬件自检”（Power-On
   Self-Test，简称 POST）。

   硬件自检后，BIOS 会将控制权交给下一段启动程序。这时，BIOS需要知
   道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要
   有一个外部存储设备的排序，排在前面的设备就是优先转交控制权的设备。
   这种排序叫做”启动顺序”（Boot Sequence）。

   因此，BIOS按照”启动顺序”，把控制权转交给排在第一位的存储设备。

2. MBR

   系统读取位列第一的可启动存储设备。计算机先读取该设备的第一个扇区，
   也就是读取最前面的512个字节。这最前面的512个字节，就叫做”主引导记
   录”（Master boot record，缩写为MBR）。MBR 只有512字节，放不了太多
   东西，它主要告诉计算机从该设备的哪一个分区（partition）来装载引导加
   载程序（boot loader）。Boot Loader 储存有操作系统（OS）的相关信息，
   比如操作系统名称，操作系统内核（kernel）所在位置等。它的主要功能就
   是加载内核到内存中去执行。常用的 boot loader 有 GRUB 和 LILO 。

   那我们经常说到的多操作系统是怎么回事呢？其实每个文件系统（或分区）
   的最前面会保留一个引导扇区（boot selector），这个引导扇区可以安装
   boot loader。这样我们在每个 boot loader 中对应不同的操作系统，在读
   取 MBR 的时候选择我们需要启动的 boot loader 即可。

3. Kernel

   随后，boot loader 会帮助我们加载内核，内核就会开始检测硬件与加载驱
   动程序。没错，内核会以自己的功能重新检测一遍硬件，而不一定会使用
   BIOS 检测到的硬件信息。也就是说，内核此时才开始接管 BIOS 后的工作。

   Kernel 实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，
   主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上
   的任何操作都要通过 kernel 传达给硬件。

4. init process

   在内核加载完毕以后，此时内核会主动调用第一个进程，那就是 /sbin/init，
   它的作用就是初始化系统环境。使用pstree命令会发现init的进程编号（PID）
   是1，也就是说init是第一个运行的程序，其他所有进程都从它衍生，都是它
   的子进程。

   许多程序需要开机启动。它们在Windows叫做”服务”（service），在
   Linux 就叫做”守护进程”（daemon）。

   init 进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合
   需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不
   需要。Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做”运
   行级别”（run level）。也就是说，启动时根据”运行级别”，确定要运行
   哪些程序。

   基本上，依据有无网络与有无 X Window ，Linux 将 run level 划分为7个
   等级（0-6）。其中0是关机，1是单用户模式，6是重启。而 2-5，一般来说
   都是多用户模式。

   + 0：关机级别
   + 1：单用户运行级别，运行rc.sysinit和rc1.d目录下的脚本
   + 2：多用户，但系统不会启动NFS，字符模式，在有些linux系统中，级别2
     为默认模式，具有网络功能，如ubuntu.debian
   + 3：多用户，字符模式，系统启动具有网络功能,redhat常用运行级别
   + 4：用户自定义级别
   + 5：图形界面模式，redhat常用运行级别
   + 6：重启级别
   + S：单用户运行级别，只运行rc.sysinit文件

   Linux 在启动各个服务前会先执行一系列的初始脚本（rc.sysinit）。这些
   脚本执行如下功能：设置计算机名称，时区，检测文件系统，挂载硬盘，清
   空临时文件，设置网络……

   之后会根据运行级别的不同，系统会运行 rc0.d 到 rc6.d 目录中的相应的
   脚本程序，来完成相应的初始化工作和启动相应的服务。rc*.d目录中存放的
   是该运行级别中需要执行的服务脚本的软链接文件（即快捷方式）。

   除此之外，Linux 还会运行一些其他的初始脚本。运行完后，操作系统已经
   完全准备好了，只是，还没有人可以登录！！！init 会给出登录（login）
   对话框，或者是图形化的登录界面。

5. login

   输入用户名密码登录成功后，系统会为用户分配一个用户 ID（UID），和一
   个组 ID（GID）。这两个 ID 就好像身份证一样会一直伴随用户，用于检测
   用户执行程序时的身份验证。

   当用户登录成功后，一个完整的操作系统就展现在用户的面前了。

6. 总结

   1) 加载 BIOS 的硬件信息与硬件自检，并依据设置取得第一个可启动的设备；
   2) 读取并执行第一个启动设备内的MBR的 boot loader；
   3) 依据 boot loader 的设置加载内核，内核会开始检测硬件与加载驱动程序；
   4) 在内核 Kernel 加载完毕后，Kernel 会主动调用 init 进程，而 init
      会取得 run-level 信息；
   5) init 执行 rc.sysinit 初始化系统的操作环境（网络、时区等）；
   6) init 启动 run-level 的各个服务；
   7) 用户登录

*** sudo                                                             :sudo:

**** sudo
+ http://www.linux178.com/linux/sudo.html
+ http://askubuntu.com/questions/90726/is-it-possible-to-give-sudo-access-to-only-a-particular-command


1. sudo是什么？

   sudo是一种权限管理机制，管理员可以授权于一些普通用户去执行一些root
   执行的操作，而不需要知道root的密码，它依赖于/etc/sudoers这个文件，
   可以授权于那个用户在那个主机上能够以管理员的身份执行什么样的管理命
   令，而且是有限的。这个文件相当于就是一个授权表。

2. /etc/sudoers 文件的语法

   可以使用 man sudoers 来查看其帮助信息

   由于这个文件是一个授权文件，那么其权限必定是很严格
   #+BEGIN_EXAMPLE
     [root@Linux178 ~]# ll /etc/sudoers
     -r--r----- 1 root root 3381 Feb 23  2012 /etc/sudoers
     [root@Linux178 ~]#

     [root@Linux178 ~]# lsattr /etc/sudoers
     ------------- /etc/sudoers
     [root@Linux178 ~]#
   #+END_EXAMPLE

   看到这个文件的权限是root和root组 只有读的权限，那也就是，编辑这个文
   件是有单独的命令的 *visudo* （这个文件我们最好不要使用vim命令来打开），
   是因为一旦你的语法写错会造成严重的后果，这个工具会替你检查你写的语
   法,这个文件的语法遵循以下格式：

   *who where whom command*

   说白了就是 那个用户在哪个主机以谁的身份执行那些命令，那么这个where,
   是指允许在那台主机ssh连接进来才能执行后面的命令，文件里面默认给root
   用户定义了一条规则， 看例子：

   #+BEGIN_EXAMPLE
     root    ALL=(ALL)       ALL
   #+END_EXAMPLE

   + root root用户
   + ALL 所有的主机上都可以
   + (ALL) 是以谁的身份来执行，ALL就代表root可以任何人的身份来执行命令
   + ALL 所有的命令

   那么整个一条规则就是root用户可以在任何主机以任何人的身份来执行所有
   的命令，也就是不限定。

   再来看一条里面的规则：

   #+BEGIN_EXAMPLE
   %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom
   jerry   192.168.100.0/24=(root) /usr/sbin/useradd
   #+END_EXAMPLE

   + %users 就是代表users这个组里面的所有成员
   + ALL 代表可以这所有的主机上
   + = 后面没有括号，也就是代表默认是以root身份
   + /sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom 可以执行挂载的命令

3. 查看用户可以执行的命令

   已经授权的普通用户可以使用: sudo -l

   来查看自己可以执行那些命令

   要执行命令要在执行命令之前加上 sudo ，然后输入用户自己的密码，这是
   因为要验证，执行命令的用户确实是该用户。

   sudo命令还有这个机制，就是在你正确输入密码并成功执行命令的5分钟内，
   再执行命令是不需要输入密码的，过了5分钟，就需要再次验证该用户的自己
   的密码，当然也可以手动让该期限过期，看下面sudo命令的语法

4. sudo命令语法

   sudo [-bhHpV][-s ][-u <用户>][指令]  或  sudo [-klv]

   参数
   + -b  在后台执行指令。
   + -h  显示帮助。
   + -H  将HOME环境变量设为新身份的HOME环境变量。
   + -k  结束密码的有效期限，也就是下次再执行sudo时便需要输入密码。
   + -l  列出目前用户可执行与无法执行的指令。
   + -p  改变询问密码的提示符号。
   + -s  执行指定的shell。
   + -u <用户>  以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份。
   + -v  延长密码有效期限5分钟。
   + -V  显示版本信息。
   + -S   从标准输入流替代终端来获取密码

5. 场景

   思考这么一个场景，看下面的规则
   #+BEGIN_EXAMPLE
     jerry   192.168.100.0/24=(root) /usr/sbin/useradd
   #+END_EXAMPLE

   这里面我如果想很多台主机上登录并执行命令（但是并不是所有的主机上），
   那这里岂不是要写很多的主机在这里吗？ 你执行useradd命令，但是这只是
   添加，不能为用户指定密码，那岂不是也不行？如果还有执行很多的命令，
   那是不是这里又要写很多的命令？

   答案是否定的

   sudo 是支持 主机别名、用户别名、whom别名（就是以谁的身份）、命令别
   名

   有了别名，规则就变得很清爽，就是把同类的对象放到一个组里面，组名必
   须全部大写

   主机别名 通过 Host_Alias 关键字来定义 例如下面的：
   #+BEGIN_EXAMPLE
     # Host_Alias     FILESERVERS = 192.168.100.0/24, 127.0.0.1
   #+END_EXAMPLE

   用户别名 通过 User_Aliases 关键字来定义，例如下面的：
   #+BEGIN_EXAMPLE
     # User_Alias ADMINS = jsmith, mikem
   #+END_EXAMPLE

   whom别名（就是以谁的身份） 通过 RunAs_Aliases 关键字来定义

   这个通常是root或者是ALL 就不用定义了。

   命令别名 通过 Cmnd_Alias 关键字来定义，例如下面的：
   #+BEGIN_EXAMPLE
     #Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig
   #+END_EXAMPLE

6. 限定执行的命令

   假设你允许一个普通用户执行passwd，那这就危险了，那么它是可以直接修
   改root的密码，这就有背于我们的初衷了，这就需要做限制了，如下设置：
   #+BEGIN_EXAMPLE
   pete    127.0.0.1 = /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root
   #+END_EXAMPLE

   [A-Za-z]* 是一个正则表达式，代表是大小写字母组成的用户名

   这一条就是限制pete这个用户，只能修改以字母组成的用户，而不能修改
   root的密码，! 就是代表不能执行此命令。

   在某个命令之前加!,就代表该用户或组不能执行该命令

7. 设定那些命令执行的时候不需要输入密码

   当然也是可以设置在执行某些命令的时候不用输入密码,例如：
   #+BEGIN_EXAMPLE
     fred           ALL = (DB) NOPASSWD: ALL
   #+END_EXAMPLE

   这就代表这个fred用户执行所有的命令时不需要输入密码

   再如：
   #+BEGIN_EXAMPLE
     tom ALL = (root) PASSWD:/usr/sbin/useradd,/usr/sbin/usermod NOPASSWD:/usr/sbin/gourpadd
   #+END_EXAMPLE

   这一条就是代表tom这个用户在执行uesradd和usermod的时候是需要输入密码，
   而执行gourpadd时不需要

   凡是 PASSWD 后面跟的命令都需要输入密码，而NOPASSWD后面的命令都不需
   要输入密码，前提是sudo记住密码的期限已过。

**** [[http://www.linux178.com/linux/sudo.html][sudo命令详解]]                                                   :blog:

***** 1.sudo是什么？

sudo是一种权限管理机制，管理员可以授权于一些普通用户去执行一些root执行的操作，而不需要知道root的密码，它依赖于/etc/sudoers这个文件，可以授权于那个用户在那个主机上能够以管理员的身份执行什么样的管理命令，而且是有限的。这个文件相当于就是一个授权表。

***** 2./etc/sudoers 文件的语法

可以使用 man sudoers 来查看其帮助信息

由于这个文件是一个授权文件，那么其权限必定是很严格

#+BEGIN_EXAMPLE
    [root@Linux178 ~]# ll /etc/sudoers
    -r--r----- 1 root root 3381 Feb 23  2012 /etc/sudoers
    [root@Linux178 ~]#

    [root@Linux178 ~]# lsattr /etc/sudoers
    ------------- /etc/sudoers
    [root@Linux178 ~]#
#+END_EXAMPLE

看到这个文件的权限是root和root组
只有读的权限，那也就是，编辑这个文件是有单独的命令的
visudo（这个文件我们最好不要使用vim命令来打开），是因为一旦你的语法写错会造成严重的后果，这个工具会替你检查你写的语法,这个文件的语法遵循以下格式：

#+BEGIN_EXAMPLE
    who where whom command
#+END_EXAMPLE

说白了就是
那个用户在哪个主机以谁的身份执行那些命令，那么这个where,是指允许在那台主机ssh连接进来才能执行后面的命令，文件里面默认给root用户定义了一条规则，
看例子：

#+BEGIN_EXAMPLE
    root    ALL=(ALL)       ALL
#+END_EXAMPLE

root root用户
 ALL 所有的主机上都可以
 (ALL) 是以谁的身份来执行，ALL就代表root可以任何人的身份来执行命令
 ALL 所有的命令

那么整个一条规则就是root用户可以在任何主机以任何人的身份来执行所有的命令，也就是不限定。

再来看一条里面的规则：

#+BEGIN_EXAMPLE
    %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom
    jerry   192.168.100.0/24=(root) /usr/sbin/useradd
#+END_EXAMPLE

%users 就是代表users这个组里面的所有成员
 ALL 代表可以这所有的主机上
 = 后面没有括号，也就是代表默认是以root身份
 /sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom 可以执行挂载的命令

***** 3.查看用户可以执行的命令

已经授权的普通用户可以使用

#+BEGIN_EXAMPLE
    sudo -l
#+END_EXAMPLE

来查看自己可以执行那些命令

要执行命令要在执行命令之前加上 sudo
，然后输入用户自己的密码，这是因为要验证，执行命令的用户确实是该用户。

sudo命令还有这个机制，就是在你正确输入密码并成功执行命令的5分钟内，再执行命令是不需要输入密码的，过了5分钟，就需要再次验证该用户的自己的密码，当然也可以手动让该期限过期，看下面sudo命令的语法

***** 4.sudo命令语法

#+BEGIN_EXAMPLE
    sudo [-bhHpV][-s ][-u <用户>][指令]
    或
    sudo [-klv]
    参数
      -b  在后台执行指令。
      -h  显示帮助。
      -H  将HOME环境变量设为新身份的HOME环境变量。
      -k  结束密码的有效期限，也就是下次再执行sudo时便需要输入密码。
      -l  列出目前用户可执行与无法执行的指令。
      -p  改变询问密码的提示符号。
      -s  执行指定的shell。
      -u <用户>  以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份。
      -v  延长密码有效期限5分钟。
      -V  显示版本信息。
      -S   从标准输入流替代终端来获取密码
#+END_EXAMPLE

***** 5.场景

思考这么一个场景，看下面的规则

#+BEGIN_EXAMPLE
    jerry   192.168.100.0/24=(root) /usr/sbin/useradd
#+END_EXAMPLE

这里面我如果想很多台主机上登录并执行命令（但是并不是所有的主机上），那这里岂不是要写很多的主机在这里吗？
你执行useradd命令，但是这只是添加，不能为用户指定密码，那岂不是也不行？如果还有执行很多的命令，那是不是这里又要写很多的命令？

答案是否定的

sudo 是支持 主机别名、用户别名、whom别名（就是以谁的身份）、命令别名

有了别名，规则就变得很清爽，就是把同类的对象放到一个组里面，*组名必须全部大写*

*主机别名* 通过 Host_Alias 关键字来定义 例如下面的：

#+BEGIN_EXAMPLE
    # Host_Alias     FILESERVERS = 192.168.100.0/24, 127.0.0.1
#+END_EXAMPLE

*用户别名* 通过 User_Aliases 关键字来定义，例如下面的：

#+BEGIN_EXAMPLE
    # User_Alias ADMINS = jsmith, mikem
#+END_EXAMPLE

*whom别名*（就是以谁的身份） 通过 RunAs_Aliases 关键字来定义

#+BEGIN_EXAMPLE
    这个通常是root或者是ALL 就不用定义了。
#+END_EXAMPLE

*命令别名* 通过 Cmnd_Alias 关键字来定义，例如下面的：

#+BEGIN_EXAMPLE
    #Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig
#+END_EXAMPLE

***** 6.限定执行的命令

假设你允许一个普通用户执行passwd，那这就危险了，那么它是可以直接修改root的密码，这就有背于我们的初衷了，这就需要做限制了，如下设置：

#+BEGIN_EXAMPLE
    pete    127.0.0.1 = /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root
#+END_EXAMPLE

[A-Za-z]* 是一个正则表达式，代表是大小写字母组成的用户名

这一条就是限制pete这个用户，只能修改以字母组成的用户，而不能修改root的密码，!
就是代表不能执行此命令。

在某个命令之前加!,就代表该用户或组不能执行该命令

***** 7.设定那些命令执行的时候不需要输入密码

当然也是可以设置在执行某些命令的时候不用输入密码,例如：

#+BEGIN_EXAMPLE
    fred           ALL = (DB) NOPASSWD: ALL
#+END_EXAMPLE

这就代表这个fred用户执行所有的命令时不需要输入密码

再如：

#+BEGIN_EXAMPLE
    tom ALL = (root) PASSWD:/usr/sbin/useradd,/usr/sbin/usermod NOPASSWD:/usr/sbin/gourpadd
#+END_EXAMPLE

这一条就是代表tom这个用户在执行uesradd和usermod的时候是需要输入密码，而执行gourpadd时不需要

凡是 PASSWD
后面跟的命令都需要输入密码，而NOPASSWD后面的命令都不需要输入密码，前提是sudo记住密码的期限已过。

**** [[http://tieba.baidu.com/p/3006415003?bd_source_light=1563095][玩ubuntu系统修改sudoers 错误了，没用visudo]]        :blog:visudo:error:

1.错误提示：sudo: no valid sudoers sources found,quitting
解决办法：(1)重启系统，选择(recovery mode/恢复模式)引导项;
(2)在Recovery Menu页面选择root后回车;
(3)设置或者撤销/etc/sudoers文件的权限,命令如下：
chmod u-w /etc/sudoers
chmod 440 /etc/sudoers
2、错误提示：chomd :changing permissions of 'sudoers' :Read-only file system解决办法：利用 mount 指令解决 Read-only file system的问题 mount -o remount rw /
3.修改 /etc/sudoers 时，用 sudo visudo 命令修改，就不用先改权限了。修改后按Ctrl+x，选择Y，输入文件名，回车；

**** [[http://blog.csdn.net/mdx20072419/article/details/8060432][sudo: no valid sudoers sources found, quitting]]           :blog:error:

我的环境实在VMwa 下装了一个Ubuntu，今天在Ubuntu添加了一个用户，

adduser mdx



添加用户成功，可是我在使用sudo安装软件的时候提示：

[[mailto:mdx@ubuntu:/home/farsight$][mdx@ubuntu:/home/farsight$]] sudo
apt-get install ssh
 [sudo] password for mdx:
 mdx is not in the sudoers file.  This incident will be reported.

上网查了一些解决办法，千篇一律：

1>、进入超级用户模式。 2>、添加文件的写权限。也就是输入命令"chmod 0777
/etc/sudoers"。

 3>、编辑/etc/sudoers文件，找到这一行："root ALL=(ALL)
ALL"在这一行下面添加"xxx ALL=(ALL)
ALL"(这里的xxx是你的用户名，我这里是mdx)，然后保存退出。

本以为大功告成，可是再次使用sudo时，又出现了另一个问题：

sudo: /etc/sudoers is mode 0777, should be 0440

sudo: no valid sudoers sources found, quitting



这让给我很纠结，想用sudo去更改权限，sudo还不能用，想su切换到root用户，可是我的root没设密码，还没激活。

参考了一些资料，最终解决，先把解决办法共享一下：

重启Ubuntu，按F12进入Recovery mode

在Recovery Menu选择root

这样就可以使用root用户了，然后把/etc/sudoers属性改回来 "chmod 0440
/etc/sudoers"。

That's OK！

这里你也可以给root设置密码，激活root

*** service                                                       :service:

service命令，顾名思义，就是用于管理Linux操作系统中服务的命令。

1. 声明：这个命令不是在所有的linux发行版本中都有。主要是在redhat、
   fedora、mandriva和centos中。

2. 此命令位于/sbin目录下，用file命令查看此命令会发现它是一个脚本命令。

3. 分析脚本可知此命令的作用是去/etc/init.d目录下寻找相应的服务，进行开
   启和关闭等操作。

4. 开启服务：service <SERVICE> start
   + start 表示启动
   + restart 表示重新启动
   + stop 表示关闭
   + reload 表示重新载入配置。

5. 关闭mysql服务器：service mysqld stop

6. 强烈建议大家将service命令替换为/etc/init.d/mysqld stop （因为有一些
   linux的版本不支持service）

7. 管理员权限

*** sysv-rc-conf(ubuntu)
+ http://www.codesky.net/article/201109/133204.html
+ http://sysv-rc-conf.sourceforge.net/
+ http://askubuntu.com/questions/221293/why-is-chkconfig-no-longer-available-in-ubuntu


1. what
   sysv-rc-conf是一个强大的服务管理程序，群众的意见是sysv-rc-conf比
   chkconfig(redhat)好用。

2. INSTALL
   + sudo apt-get install sysv-rc-conf
   +
3. USE

   1) $ sudo sysv-rc-conf

      操作界面十分简洁，你可以用鼠标点击，也可以用键盘方向键定位，用空
      格键选择，用Ctrl+N翻下一页，用Ctrl+P翻上一页，用Q退出。

   2) $ sudo sysv-rc-config --list

   3) $ sudo sysv-rc-config SERVICE on

*** 模块相关命令
Linux操作系统中模块操作相关命令解释
+ lsmod  查看已经安装好的模块， 也可以查看/proc/modules文件的内容. 实
  际上,lsmod读命令就是通过查看/proc/modules的内容来显示模块信息的.
+ modinfo 显示模块信息
+ modprobe  不需要指定路径，它会到默认路径下寻找模块。模块也存在依赖性
  问题: 比如你要加载msdos.ko, 需要先加载fat.ko. modprobe查看
  /lib/module/version/modules.dep得知模块的依赖关系
+ rmmod 卸载模块，但是内核会认为卸载模块不安全，可以添加命令强制卸载。
+ depmod 检查系统中模块之间的依赖关系，并把依赖关系信息存于
  /lib/modules/2.6.18-1.2798/modules.dep中。 一般加载模块后，要命令行
  下先执行 depmod -a后，在系统加载模块时候会查看modules.dep中模块依赖
  及路径信息，这样子才可以成功加载需要模块。
+ insmod 加载模块，需要指定完整的路径和模块名字。

*** 备份与还原
+ http://tieba.baidu.com/p/1184618169
+ http://www.ibm.com/developerworks/cn/linux/l-roadmap/part8/
+ http://blog.csdn.net/huhui_cs/article/details/8710658


曾经听到很多人抱怨 Linux 下没有 ghost 这样“方便”的备份工具。这是一种
普遍的误解，其实 Linux 下是可以用 ghost for Linux 的，但因为有更好的办
法，所以 ghost 在 Linux 下用得少，知名度不高。

现在以我的系统为例，介绍两种 Linux 下最常见最实用的系统备份方案。我的
系统是 Gentoo Linux，sda1 30GB，挂载为 /，sda2 400GB，挂载为 /home,
sda3 100GB，格式化为 ext4，空闲。


**** dd
dd 是最强劲有力、稳定可靠的备份工具。

备份：当前系统下，
#+BEGIN_EXAMPLE
~ % sudo dd if=/dev/sda1 of=~/gentoo_$(date +"%Y-%m-%d").backup
#+END_EXAMPLE

还原：其它 Linux 系统或者 LiveCD/LiveUSB 下，
#+BEGIN_EXAMPLE
~ % sudo dd if=gentoo_*.backup of=/dev/sda1
#+END_EXAMPLE

如果要改变根分区的位置，比如说把根分区移动到 sda5，那麽还需要调整一下：
#+BEGIN_EXAMPLE
~ % sudo resize2fs -f /dev/sda5
~ % sudo e2fsck -f /dev/sda5
#+END_EXAMPLE

然后修改恢复出来的 /etc/fstab 文件。

请注意 sda5 的容量必须大于 sda1.

dd 备份简单快速，是速度优先的最好选择，但所需要的磁盘空间比较大。

**** tar + xz
tar 用于打包，xz 用于压缩。

备份：当前系统下，
#+BEGIN_EXAMPLE
~ % cd /

/ % sudo tar Jcpvf ~/gentoo_amd64_$(date +"%Y-%m-%d").tar.xz --exclude=./usr/portage/distfiles --exclude=./home --exclude=./lost+found --exclude=./sys --exclude=./proc .
#+END_EXAMPLE

其中，--exclude= 参数列出了不需要备份的目录，可以根据实际情况自行调整。

还原：其它 Linux 系统或者 LiveCD/LiveUSB 下，
#+BEGIN_EXAMPLE
~ % sudo mkfs.ext4 /dev/sda1
~ % sudo mount -v /dev/sda1 /mnt
~ % sudo cd /mnt/
~ % sudo tar xpvf gentoo_amd64_*.tar.xz
~ % sudo mkdir -pv home sys proc usr/portage/distfiles
~ % cd && sudo umount -v /mnt
#+END_EXAMPLE

如果移动了根分区，则需要修改还原出来的 /etc/fstab 文件

tar+xz 压缩打包备份的优点，在于极高的压缩率，可以大大减少备份文件的大
小。我的备份以前的 / 分区有 11G 大小，而备份出来的 .tar.xz 文件，只有
2.1G，压缩比为超过了 5:1. 但这带来一个问题：备份耗时漫长。比如说我这次
11G 的压缩备份就花了 2 小时。幸好还原速度还可以，只需要 8 分钟。此外，
如果你 man 一下 tar，就会发现这种做法其实十分灵活好用。

**** 备份恢复手记
1. 使用dd备份/(/dev/sda7)，备份文件比根目录大将近两倍，不知为何
2. 安装AMD驱动导致Ubuntu进入不了X桌面
3. 理论上删除/etc/X11/xorg.conf即可
4. 使用dd恢复
5. 时间长，等待期间焦急，遂去借书
6. 恢复时间超过半个小时
7. 完成后重启出现问题
8. 强制关机后重启第一次挂载/时出借，手动修复无果，自动修复成功
9. 证明dd备份恢复是可行的
*** 进程间通信(IPC)                                               :process:
+ http://www.ibm.com/developerworks/cn/linux/l-ipc/
+ http://blog.csdn.net/jmy5945hh/article/details/7367532


linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的。而
对Unix发展做出重大贡献的两大主力AT&T的贝尔实验室及BSD（加州大学伯克利
分校的伯克利软件发布中心）在进程间通信方面的侧重点有所不同。前者对Unix
早期的进程间通信手段进行了系统的改进和扩充，形成了“system V IPC”，通
信进程局限在单个计算机内；后者则跳过了该限制，形成了基于套接口（socket）
的进程间通信机制。Linux则把两者继承了下来，如图示：

\begin{figure}[ht]
\centering
\includegraphics[width=0.4\linewidth]{/home/wally/Wally/Journal/Figure/scrot/16597IjP.png}
\end{figure}

一般来说，linux下的进程包含以下几个关键要素：
+ 有一段可执行程序；
+ 有专用的系统堆栈空间；
+ 内核中有它的控制块（进程控制块），描述进程所占用的资源，这样，进程才
  能接受内核的调度；
+ 具有独立的存储空间

Linux 进程间通信方式:

1. *管道（Pipe）及有名管道（named pipe）* ：

   管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限
   制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

2. *信号（Signal）* ：

   信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于
   进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期
   信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction
   （实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对
   外接口，用sigaction函数重新实现了signal函数）；

3. *报文（Message）队列（消息队列）* ：

   消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够
   权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中
   的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以
   及缓冲区大小受限等缺点。

4. *共享内存* ：

   使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其
   他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使
   用，来达到进程间的同步及互斥。

5. *信号量（semaphore）* ：

   主要作为进程间以及同一进程不同线程之间的同步手段。

6.  *套接口（Socket）* ：

    更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由
    Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：
    Linux和System V的变种都支持套接字。

*** UML: User Mode Linux                                              :uml:
+ http://www.hankjohn.net/weblog/2010/11/12/33731937201010129263187/
+ http://www.usermodelinux.org/


User-mode-linux (UML) 是让一个Linux作为一个独立进程运行在另一个linux上。

UML 是一种在同一时间运行多Linux 的安全方式。每个进程都是独立去其他的，
这非常安全，例如在同一机器上进行多种测试和研发而不互相干扰。如果一些测
试进程损坏并不会影响宿主系统或研发用进程。

*** Port                                                             :port:
**** 查看端口使用情况
+ http://www.cnblogs.com/benio/archive/2010/09/15/1826728.html
+ http://blog.csdn.net/wudiyi815/article/details/7473097


首先你必须知道，端口不是独立存在的，它是依附于进程的。某个进程开启，那
么它对应的端口就开启了，进程关闭，则该端口也就关闭了。下次若某个进程再
次开启，则相应的端口也再次开启。而不要纯粹的理解为关闭掉某个端口，不过
可以禁用某个端口。

1. 可以通过"netstat -anp" 来查看哪些端口被打开。

   （注：加参数'-n'会将应用程序转为端口显示，即数字格式的地址，如：
   nfs->2049, ftp->21，因此可以开启两个终端，一一对应一下程序所对应的
   端口号）

2. lsof -i:$PORT

   然后可以通过""查看应用该端口的程序（$PORT指对应的端口号）。或者你也
   可以查看文件/etc/services，从里面可以找出端口所对应的服务。

   （注：有些端口通过netstat查不出来，更可靠的方法是"sudo nmap -sT -O
   localhost"）

3. 关闭端口
   1) 通过iptables工具将该端口禁掉，如：
      + "sudo iptables -A INPUT -p tcp --dport $PORT -j DROP"
      + "sudo iptables -A OUTPUT -p tcp --dport $PORT -j DROP"
   2) 关掉对应的应用程序，则端口就自然关闭了，如：
      #+BEGIN_EXAMPLE
      "kill -9 PID" (PID：进程号)
      #+END_EXAMPLE

4. chkconfig

   可通过"chkconfig"查看系统服务的开启状态(Ubuntu另有工具)

**** [[http://blog.csdn.net/wudiyi815/article/details/7473097][Linux查看端口使用状态、关闭端口方法]]                            :blog:

前提：首先你必须知道，端口不是独立存在的，它是依附于进程的。某个进程开启，那么它对应的端口就开启了，进程关闭，则该端口也就关闭了。下次若某个进程再次开启，则相应的端口也再次开启。而不要纯粹的理解为关闭掉某个端口，不过可以禁用某个端口。

1. 可以通过"netstat -anp" 来查看哪些端口被打开。
（注：加参数'-n'会将应用程序转为端口显示，即数字格式的地址，如：nfs->2049, ftp->21，因此可以开启两个终端，一一对应一下程序所对应的端口号）
2. 然后可以通过"lsof -i:$PORT"查看应用该端口的程序（$PORT指对应的端口号）。或者你也可以查看文件/etc/services，从里面可以找出端口所对应的服务。
（注：有些端口通过netstat查不出来，更可靠的方法是"sudo nmap -sT -O localhost"）
3. 若要关闭某个端口，则可以：
1)通过iptables工具将该端口禁掉，如：
"sudo iptables -A INPUT -p tcp --dport $PORT -j DROP"
"sudo iptables -A OUTPUT -p tcp --dport $PORT -j DROP"
2)或者关掉对应的应用程序，则端口就自然关闭了，如：
"kill -9 PID" (PID：进程号)
如：    通过"netstat -anp | grep ssh"
有显示：    tcp 0 127.0.0.1:2121 0.0.0.0:* LISTEN 7546/ssh
则：    "kill -9 7546"

（可通过"chkconfig"查看系统服务的开启状态）

**** [[http://www.cnblogs.com/benio/archive/2010/09/15/1826728.html][Linux查看程序端口占用情况]]                                      :blog:

今天发现服务器上Tomcat 8080端口起不来，老提示端口已经被占用。

使用命令：

ps -aux | grep tomcat

发现并没有8080端口的Tomcat进程。

使用命令：netstat --apn

查看所有的进程和端口使用情况。发现下面的进程列表，其中最后一栏是PID/Program
name

#+DOWNLOADED: http://www.blogjava.net/images/blogjava_net/hankchen/WindowsLiveWriter/Linux_7E54/clip_image002_thumb.jpg @ 2016-01-26 21:39:01
 [[~/Wally/Journal/Figure/.org-download/Tasks/clip_image002_thumb_2016-01-26_21:39:01.jpg]]]]

发现8080端口被PID为9658的Java进程占用。

进一步使用命令：ps -aux | grep java，或者直接：ps -aux | grep pid 查看

#+DOWNLOADED: http://www.blogjava.net/images/blogjava_net/hankchen/WindowsLiveWriter/Linux_7E54/clip_image004_thumb.jpg @ 2016-01-26 21:39:08
 [[~/Wally/Journal/Figure/.org-download/Tasks/clip_image004_thumb_2016-01-26_21:39:08.jpg]]]]

就可以明确知道8080端口是被哪个程序占用了！然后判断是否使用KILL命令干掉！


方法二：直接使用 netstat   -anp   |   grep portno
即：netstat --apn | grep 8080

*** 周期任务                                                 :cron:crontab:
**** crontab

1. 命令： *crontab*,  格式： /crontab [-u user] [file | -e | -l | -r]/
   - -u user： 指定用户
   - file: 将文件file作为crontab的任务列表并载入crontab, 缺省则为标准
     输入
   - -e: 编辑
   - -l: 显示
   - -r: 从 */var/spool/cron* 删除某个用户的crontab文件
     #+begin_src sh
     ls /var/spool/cron/
     #+end_src

     #+results:
     : crontabs
   - -i: 删除时显示提示信息

2. crontab文件格式
   #+begin_example
   分 时 日 月 星期 命令
   #+end_example
   + 分: 1～59
   + 时: 0~23
   + 日: 1~31
   + 日期： 0～6
   + 命令： 第六列

**** usage

1. 指定编辑器
   #+begin_latex
   \begin{minted}[frame=single, mathescape]{sh}
   editor=vi; export editor  # in .bashrc
   \end{minted}
   #+end_latex

2. 备份
   #+begin_latex
   \begin{minted}[frame=single, mathescape]{sh}
   crontab -l > ~/mycron
   \end{minted}
   #+end_latex

   #+begin_src sh
   crontab -l
   #+end_src

   no crontab for ben

3. examples
   #+begin_example
     实例1：每1分钟执行一次mycommand
     ,* * * * * mycommand

     实例2：每小时的第3和第15分钟执行
     3,15 * * * * mycommand

     实例3：在上午8点到11点的第3和第15分钟执行
     3,15 8-11 * * * mycommand

     实例4：每隔两天的上午8点到11点的第3和第15分钟执行
     3,15 8-11 */2  *  * mycommand

     实例5：每周一上午8点到11点的第3和第15分钟执行
     3,15 8-11 * * 1 mycommand

     实例6：每晚的21:30重启smb
     30 21 * * * /etc/init.d/smb restart

     实例7：每月1、10、22日的4 : 45重启smb
     45 4 1,10,22 * * /etc/init.d/smb restart

     实例8：每周六、周日的1 : 10重启smb
     10 1 * * 6,0 /etc/init.d/smb restart

     实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb
     0,30 18-23 * * * /etc/init.d/smb restart

     实例10：每星期六的晚上11 : 00 pm重启smb
     0 23 * * 6 /etc/init.d/smb restart

     实例11：每一小时重启smb
     ,* */1 * * * /etc/init.d/smb restart

     实例12：晚上11点到早上7点之间，每隔一小时重启smb
     ,* 23-7/1 * * * /etc/init.d/smb restart

   #+end_example

**** note
1. 每条周期任务增加注释
2. 环境变量与当前环境不一定一致，往往需要设置（在要执行的脚本中）
3. 全局路径
4. 不会立即重启
   #+begin_example
   sudo service cron restart
   #+end_example
5. % 有特殊含义，表换行，需要转义
   #+begin_example
   * * * * * /bin/echo `date "+\%m"` >> /tmp/test_cron
   #+end_example

**** 手记
#+begin_example
  usage:  crontab [-u user] file
          crontab [ -u user ] [ -i ] { -e | -l | -r }
                  (default operation is replace, per 1003.2)
          -e      (edit user's crontab)
          -l      (list user's crontab)
          -r      (delete user's crontab)
          -i      (prompt before deleting user's crontab)

  journal $ crontab -l
  no crontab for ben

  journal $ crontab -u ben
  crontab: usage error: file name must be specified for replace
  usage:  crontab [-u user] file
          crontab [ -u user ] [ -i ] { -e | -l | -r }
                  (default operation is replace, per 1003.2)
          -e      (edit user's crontab)
          -l      (list user's crontab)
          -r      (delete user's crontab)
          -i      (prompt before deleting user's crontab)

  journal $ crontab -u  ben cron
  cron: 没有那个文件或目录

  journal $ crontab cron
  cron: 没有那个文件或目录

  journal $ export editro=vi

  journal $ crontab cron
  cron: 没有那个文件或目录

  journal $ touch cron
  journal $ crontab cron
  journal $ crontab -l
  journal $ crontab -e

  select an editor.  to change later, run 'select-editor'.
    1. /bin/ed
    2. /bin/nano        <---- easiest
    3. /usr/bin/vim.tiny
  choose 1-3 [2]: 3
  crontab: installing new crontab

  journal $ crontab -l
  ,* * * * * date +%m > /tmp/test_cron

  journal $ crontab -e
  crontab: installing new crontab

  journal $ ls /var/spool/cron/crontabs/
  ls: 无法打开目录/var/spool/cron/crontabs/: 权限不够
  journal $ sudo ls /var/spool/cron/crontabs/
  [sudo] password for ben:
  ben
  journal $ sudo cat /var/spool/cron/crontabs/ben
  # do not edit this file - edit the master and reinstall.
  # (/tmp/crontab.zug5cu/crontab installed on mon nov 23 10:57:55 2015)
  # (cron version -- $id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie exp $)
  ,* * * * * /bin/echo `date +%m` >> /tmp/test_cron


  journal $ crontab -l
  ,* * * * * /bin/echo `date +%m` >> /tmp/test_cron
  journal $ /bin/echo `date +%m` >> /tmp/test_cron


  journal $ service cron restart
  stop:未知任务: cron
  start:未知任务: cron

  journal $ sudo service cron restart
  cron stop/waiting
  cron start/running, process 4693

  journal $ crontab -l
  ,* * * * * /bin/echo `date +%m` >> /tmp/test_cron

  journal $ crontab -e
  crontab: installing new crontab

  journal $ crontab -l
  ,* * * * * /bin/echo `date "+%m"` >> /tmp/test_cron

  journal $ crontab -e
  crontab: installing new crontab
  journal $ sudo service cron restart
  cron stop/waiting
  cron start/running, process 4950
  journal $ cat /tmp/test_cron
  00
  06
  12
  13
  journal $ crontab -l
  ,* * * * * /bin/echo `date "+\%m"` >> /tmp/test_cron ### ok

  journal $ crontab -ir
  crontab: really delete ben's crontab? (y/n) y


#+end_example
**** 参考：
+ [[https://app.yinxiang.com/shard/s52/nl/11551545/954d6b3c-3901-41f3-b3bb-22c2e14feaff?title=19.%20crontab%20%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%20%e2%80%94%20linux%20tools%20quick%20tutorial][linux tools quick tutorial: crontab]]

*** 查看CPU个数                                                       :cpu:

*cat /proc/cpuinfo | grep processor*

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{text}
   $ cat /proc/cpuinfo | grep processor
  processor       : 0
  processor       : 1
  processor       : 2
  processor       : 3
  \end{minted}
#+end_latex

*** 用户态与核心态
**** [[http://www.cnblogs.com/cxrs/archive/2010/07/21/1782007.html][用户态和核心态]] :blog:

用户态：Ring3运行于用户态的代码则要受到处理器的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段（TSS）中I/O许可位图（I/O
Permission Bitmap）中规定的可访问端口进行直接访问。

 核心态：Ring0
在处理器的存储保护中，核心态，或者特权态（与之相对应的是用户态），是操作系统内核所运行的模式。运行在该模式的代码，可以无限制地对系统存储、外部设备进行访问。



用户态切换到内核态的3种方式

1) 系统调用 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int
80h中断。

2)
异常 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

3)
外围设备的中断 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

具体的切换步骤：

  [1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。

  [2]
使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个

过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一

条指令。

  [3]
将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始

执行中断处理程序，这时就转到了内核态的程序执行了。

  从用户态切换到核心态，要耗掉>100 cycle的CPU时钟

**** [[http://my.oschina.net/liubin/blog/27795?fromerr=tiisuVGO][用户态和内核态的概念区别]] :blog:


*究竟什么是用户态，什么是内核态，这两个基本概念以前一直理解得不是很清楚，根本原因个人觉得是在于因为大部分时候我们在写程序时关注的重点和着眼的角度放在了实现的功能和代码的逻辑性上，先看一个例子：*

*1）例子*

*C代码* **

*1. * *void testfork(){ * **

*2. * *if(0 = = fork()){ * **

*3. * *printf(“create new process success!\n”); * **

*4. * *} * **

*5. * *printf(“testfork ok\n”); * **

*6. * *} *

*void testfork(){*

*if(0 = = fork()){*

*printf(“create new process success!\n”);*

*}*

*printf(“testfork ok\n”);*

*}*

*这段代码很简单，从功能的角度来看，就是实际执行了一个fork()，生成一个新的进程，从逻辑的角度看，就是判断了如果fork()返回的是则打印相关语句，然后函数最后再打印一句表示执行完整个testfork()函数。代码的执行逻辑和功能上看就是如此简单，一共四行代码，从上到下一句一句执行而已，完全看不出来哪里有体现出用户态和进程态的概念。*

*如果说前面两种是静态观察的角度看的话，我们还可以从动态的角度来看这段代码，即它被转换成CPU执行的指令后加载执行的过程，这时这段程序就是一个动态执行的指令序列。而究竟加载了哪些代码，如何加载就是和操作系统密切相关了。*

*2）特权级*

*熟悉Unix/Linux系统的人都知道，fork的工作实际上是以系统调用的方式完成相应功能的，具体的工作是由sys_fork负责实施。其实无论是不是Unix或者Linux，对于任何操作系统来说，创建一个新的进程都是属于核心功能，因为它要做很多底层细致地工作，消耗系统的物理资源，比如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录页表等等，这些显然不能随便让哪个程序就能去做，于是就自然引出特权级别的概念，显然，最关键性的权力必须由高特权级的程序来执行，这样才可以做到集中管理，减少有限资源的访问和使用冲突。*

*特权级显然是非常有效的管理和控制程序执行的手段，因此在硬件上对特权级做了很多支持，就Intel
x86架构的CPU来说一共有0~3四个特权级，级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查，相关的概念有*
*CPL、DPL和RPL，这里不再过多阐述。硬件已经提供了一套特权级使用的相关机制，软件自然就是好好利用的问题，这属于操作系统要做的事情，对于*
*Unix/Linux来说，只使用了级特权级和3级特权级。也就是说在Unix/Linux系统中，一条工作在级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力。*

*3）用户态和内核态*

*现在我们从特权级的调度来理解用户态和内核态就比较好理解了，当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在级特权级上时，就可以称之为运行在内核态。*

*虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，比如上面例子中的testfork()就不能直接调用*
*sys_fork()，因为前者是工作在用户态，属于用户态程序，而sys_fork()是工作在内核态，属于内核态程序。*

*当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，比如testfork()最初运行在用户态进程下，当它调用fork()最终触发*
*sys_fork()的执行时，就切换到了内核态。*

*2.* *用户态和内核态的转换*

*1）用户态切换到内核态的3种方式*

*a.* *系统调用*

*这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int
80h中断。*

*b.* *异常 *

*当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。*

*c.* *外围设备的中断*

*当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。*

*这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。*

*2）具体的切换操作*

*从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：*

*[1]* *从当前进程的描述符中提取其内核栈的ss0及esp0信息。*

*[2]*
*使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个*

*过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一*

*条指令。*

*[3]*
*将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始*

*执行中断处理程序，这时就转到了内核态的程序执行了。*

** 设备管理                                                          :LINUX:
*** udev                                                             :udev:
**** Linux 文件 /etc/udev/rules.d/

#+BEGIN_SRC sh :results output
cat /etc/udev/rules.d/README
#+END_SRC

#+RESULTS:
#+begin_example
The files in this directory are read by udev(7) and used when events
are performed by the kernel.  The udev daemon watches this directory
with inotify so that changes to these files are automatically picked
up, for this reason they must be files and not symlinks to another
location as in the case in Debian.

Packages do not generally install rules here, this directory is for
local rules.  If you want to override behaviour of package-supplied
rules, which can be found in /lib/udev/rules.d, you can do one of
two things:

 1) Write your own rules in this directory that assign the name,
    symlinks, permissions, etc. that you want.  Pick a number higher
    than the rules you want to override, and yours will be used.

 2) Copy the file from /lib/udev/rules.d and edit it here; you
    should generally only do this if you want to prevent a program
    from being run.


If the ordering of files in this directory are not important to you,
it's recommended that you simply name your files "descriptive-name.rules"
such that they are processed AFTER all numbered rules in both this
directory and /lib/udev/rules.d and thus override anything set there.
#+end_example

**** [[http://www.cnblogs.com/sopost/archive/2013/01/09/2853200.html][Linux┊详解udev]]                                                :blog:

如果你使用Linux比较长时间了，那你就知道，在对待设备文件这块，Linux改变
了几次策略。在Linux早期，设备文件仅仅是是一些带有适当的属性集的普通文
件，它由mknod命令创建，文件存放在/dev目录下。后来，采用了devfs,

一个基于内核的动态设备文件系统，他首次出现在2.3.46内核中。Mandrake，
Gentoo等Linux分发版本采用了这种方式。devfs创建

的设备文件是动态的。但是devfs有一些严重的限制，从2.6.13版本后移走了。
目前取代他的便是文本要提到的udev－－一个用户空间程序。

目前很多的Linux分发版本采纳了udev的方式，因为它在Linux设备访问，特别是
那些对设备有极端需求的站点(比如需要控制上千个硬盘)和热插拔设备(比如USB
摄像头和MP3播放器)上解决了几个问题。下面我我们来看看如何管理udev设备。

实际上，对于那些为磁盘，终端设备等准备的标准配置文件而言，你不需要修改
什么。但是，你需要了解udev配置来使用新的或者外来设备，如果不修改配置，

这些设备可能无法访问，或者说Linux可能会采用不恰当的名字，属组或权限来
创建这些设备文件。你可能也想知道如何修改RS－232串口，音频设备等文件的
属组或者权限。这点在实际的Linux实施中是会遇到的。


为什么使用udev

在此之前的设备文件管理方法(静态文件和devfs)有几个缺点：

*不确定的设备映射。特别是那些动态设备，比如USB设备，设备文件到实际设备的映射并不可靠和确定。举一个例子：如果你有两个USB打印机。一个可能称
为/dev/usb/lp0,另外一个便是/dev/usb/lp1。但是到底哪个是哪个并不清楚，lp0,lp1和实际的设备没有一一对应的关系，因为
他可能因为发现设备的顺序，打印机本身关闭等原因而导致这种映射并不确定。理想的方式应该是：两个打印机应该采用基于他们的序列号或者其他标识信息的唯一
设备文件来映射。但是静态文件和devfs都无法做到这点。

*没有足够的主/辅设备号。我们知道，每一个设备文件是有两个8位的数字：一个是主设备号
，另外一个是辅设备号来分配的。这两个8位的数字加上设备类型(块设备或者字符设备)来唯一标识一个设备。不幸的是，关联这些身边的的数字并不足够。

*/dev目录下文件太多。一个系统采用静态设备文件关联的方式，那么这个目录下的文件必然是足够多。而同时你又不知道在你的系统上到底有那些设备文件是激活的。

*命名不够灵活。尽管devfs解决了以前的一些问题，但是它自身又带来了一些问题。其中一个就是命名不够灵活；你别想非常简单的就能修改设备文件的名字。缺省的devfs命令机制本身也很奇怪，他需要修改大量的配置文件和程序。

*内核内存使用，devfs特有的另外一个问题是，作为内核驱动模块，devfs需要消耗大量的内存，特别当系统上有大量的设备时(比如上面我们提到的系统一个上有好几千磁盘时)

udev的目标是想解决上面提到的这些问题，他通采用用户空间(user-space)工具来管理/dev/目录树，他和文件系统分开。知道如何改变缺省配置能让你之大如何定制自己的系统，比如创建设备字符连接，改变设备文件属组，权限等。

udev配置文件

主要的udev配置文件是/etc/udev/udev.conf。这个文件通常很短，他可能只是包含几行#开头的注释，然后有几行选项：

udev_root=“/dev/”
udev_rules=“/etc/udev/rules.d/”
udev_log=“err“

上面的第二行非常重要，因为他表示udev规则存储的目录，这个目录存储的是以.rules结束的文件。每一个文件处理一系列规则来帮助udev分配名字给设备文件以保证能被内核识别。
你的/etc/udev/rules.d下面可能有好几个udev规则文件，这些文件一部分是udev包安装的，另外一部分则是可能是别的硬件或者软件包
生成的。比如在Fedora Core
5系统上，sane-backends包就会安装60-libsane.rules文件，另外initscripts包会安装60-net.rules文
件。这些规则文件的文件名通常是两个数字开头，它表示系统应用该规则的顺序。

规则文件里的规则有一系列的键/值对组成，键/值对之间用逗号(,)分割。每一个键或者是用户匹配键，或者是一个赋值键。匹配键确定规则是否被应用，而赋
值键表示分配某值给该键。这些值将影响udev创建的设备文件。赋值键可以处理一个多值列表。匹配键和赋值键操作符解释见下表：

udev 键/值对操作符

操作符  匹配或赋值  解释
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
==  匹配  相等比较
!=  匹配  不等比较
=  赋值
分配一个特定的值给该键，他可以覆盖之前的赋值。
+=  赋值  追加特定的值给已经存在的键
:=  赋值
分配一个特定的值给该键，后面的规则不可能覆盖它。

这有点类似我们常见的编程语言，比如C语言。只是这里的键一次可以处理多个值。有一些键在udev规则文件里经常出现，这些键的值可以使用通配符(*,?,甚至范围，比如[0-9])，这些常用键列举如下：

常用udev键
键  含义
ACTION
一个时间活动的名字，比如add，当设备增加的时候
KERNEL
在内核里看到的设备名字，比如sd*表示任意SCSI磁盘设备
DEVPATH  内核设备录进，比如/devices/*
SUBSYSTEM  子系统名字，比如sound,net
BUS  总线的名字，比如IDE,USB
DRIVER  设备驱动的名字，比如ide-cdrom
ID  独立于内核名字的设备名字
SYSFS{ value}  sysfs属性值，他可以表示任意
ENV{ key}  环境变量，可以表示任意
PROGRAM
可执行的外部程序，如果程序返回0值，该键则认为为真(true)
RESULT  上一个PROGRAM调用返回的标准输出。
NAME
根据这个规则创建的设备文件的文件名。注意：仅仅第一行的NAME描述是有效的，后面的均忽略。
如果你想使用使用两个以上的名字来访问一个设备的话，可以考虑SYMLINK键。
SYMLINK  根据规则创建的字符连接名
OWNER  设备文件的属组
GROUP  设备文件所在的组。
MODE  设备文件的权限，采用8进制
RUN  为设备而执行的程序列表
LABEL
在配置文件里为内部控制而采用的名字标签(下下面的GOTO服务)
GOTO
跳到匹配的规则（通过LABEL来标识），有点类似程序语言中的GOTO
IMPORT{ type}
导入一个文件或者一个程序执行后而生成的规则集到当前文件
WAIT_FOR_SYSFS
等待一个特定的设备文件的创建。主要是用作时序和依赖问题。
PTIONS  特定的选项： last_rule
对这类设备终端规则执行； ignore_device 忽略当前规则； ignore_remove
忽略接下来的并移走请求。all_partitions 为所有的磁盘分区创建设备文件。

我们给出一个列子来解释如何使用这些键。下面的例子来自Fedora Core
5系统的标准配置文件。



KERNEL=="*", OWNER="root" GROUP="root", MODE="0600"
KERNEL=="tty", NAME="%k", GROUP="tty", MODE="0666",
OPTIONS="last_rule"
KERNEL=="scd[0-9]*", SYMLINK+="cdrom cdrom-%k"
KERNEL=="hd[a-z]", BUS=="ide", SYSFS{removable}=="1",
  SYSFS{device/media}=="cdrom", SYMLINK+="cdrom cdrom-%k"
ACTION=="add", SUBSYSTEM=="scsi_device", RUN+="/sbin/modprobe
sg"上面的例子给出了5个规则，每一个都是KERNEL或者ACTION键开头：

*第一个规则是缺省的，他匹配任意被内核识别到的设备，然后设定这些设备的属组是root，组是root，访问权限模式是0600(-rw-------)。这也是一个安全的缺省设置保证所有的设备在默认情况下只有root可以读写

*第二个规则也是比较典型的规则了。它匹配终端设备(tty)，然后设置新的权限为0600，所在的组是tty。它也设置了一个特别的设备文件名:%K。在这里例子里，%k代表设备的内核名字。那也就意味着内核识别出这些设备是什么名字，就创建什么样的设备文件名。

*第三行开始的KERNEL==”scd[0-9]*”,表示 SCSI CD-ROM 驱动.
它创建一对设备符号连接：cdrom和cdrom-%k。

*第四行，开始的 KERNEL==”hd[a-z]“, 表示ATA
CDROM驱动器。这个规则创建和上面的规则相同的符号连接。ATA
CDROM驱动器需要sysfs值以来区别别的ATA设备，因为SCSI
CDROM可以被内核唯一识别。.

*第五行以 ACTION==”add”开始，它告诉udev增加 /sbin/modprobe sg
到命令列表，当任意SCSI设备增加到系统后，这些命令将执行。其效果就是计算机应该会增加sg内核模块来侦测新的SCSI设备。

当然，上面仅仅是一小部分例子，如果你的系统采用了udev方式，那你应该可以看到更多的规则。如果你想修改设备的权限或者创建信的符号连接，那么你需要熟读这些规则，特别是要仔细注意你修改的那些与之相关的设备。

修改你的udev配置

在修改udev配置之前，我们一定要仔细，通常的考虑是：你最好不要修改系统预置的那些规则，特别不要指定影响非常广泛的配置，比如上面例子中的第一行。不正确的配置可能会导致严重的系统问题或者系统根本就无法这个正确的访问设备。

而我们正确的做法应该是在/etc/udev/rules.d/下创建一个信的规则文件。确定你给出的文件的后缀是rules文件名给出的数字序列应该比
标准配置文件高。比如，你可以创建一个名为99-my-udev.rules的规则文件。在你的规则文件中，你可以指定任何你想修改的配置，比如，假设你
修改修改floppy设备的所在组，还准备创建一个信的符号连接/dev/floppy，那你可以这么写：

KERNEL==”fd[0-9]*“, GROUP=“users“,  SYMLINK+=“floppy“

有些发行版本，比如Fedora，采用了外部脚本来修改某些特定设备的属组，组关系和权限。因此上面的改动可能并不见得生效。如果你遇到了这个问题，你就需要跟踪和修改这个脚本来达到你的目的。或者你可以修改PROGRAM或RUN键的值来做到这点。

某些规则的修改可能需要更深的挖掘。比如，你可能想在一个设备上使用sysfs信息来唯一标识一个设备。这些信息最好通过udevinfo命令来获取。

$ udevinfo --a --p $(udevinfo --q path  --n
/dev/hda)上面的命令两次使用udevinfo：一次是返回sysfs设备路径(他通常和我们看到的Linux设备文件名所在路径－－/dev/hda－－不同)；第
二次才是查询这个设备路径，结果将是非常常的syfs信息汇总。你可以找到最够的信息来唯一标志你的设备，你可以采用适当的替换udev配置文件中的
SYSFS选项。下面的结果就是上面的命令输出



[root@localhost rules.d]# udevinfo -a -p $(udevinfo -q path
-n  /dev/hda1)
Udevinfo starts with the device specified by the devpath and then walks
up the chain of
parent devices. It prints for every device found,all possible attributes
in the udev rules
key format. A rule to match, can be composed by the attributes of the
device and the
attributes from one single parent device.

looking at device '/block/hda/hda1':
KERNEL=="hda1"  SUBSYSTEM=="block"  DRIVER==""
ATTR{stat}=="  1133  2268  2
4"  ATTR{size}=="208782"
ATTR{start}=="63"  ATTR{dev}=="3:1"  looking at parent
device '/block/hda':

KERNELS=="hda"  SUBSYSTEMS=="block"  DRIVERS==""
ATTRS{stat}=="28905 18814 1234781 302540 34087 133247 849708 981336 0
218340 1283968"
ATTRS{size}=="117210240"  ATTRS{removable}=="0"
ATTRS{range}=="64"  ATTRS{dev}=="3:0"

looking at parent device
'/devices/pci0000:00/0000:00:1f.1/ide0/0.0':

KERNELS=="0.0"  SUBSYSTEMS=="ide"  DRIVERS=="ide-disk"
ATTRS{modalias}=="ide:m-disk"  ATTRS{drivename}=="hda"
ATTRS{media}=="disk"
looking at parent device '/devices/pci0000:00/0000:00:1f.1/ide0':

KERNELS=="ide0"  SUBSYSTEMS==""  DRIVERS==""
looking at parent device '/devices/pci0000:00/0000:00:1f.1':
KERNELS=="0000:00:1f.1"  SUBSYSTEMS=="pci"
DRIVERS=="PIIX_IDE"
ATTRS{broken_parity_status}=="0"  ATTRS{enable}=="1"
ATTRS{modalias}=="pci:v00008086d000024CAsv0000144Dsd0000C009bc01sc01i8a"
ATTRS{local_cpus}=="1"  ATTRS{irq}=="11"
ATTRS{class}=="0x01018a"
ATTRS{subsystem_device}=="0xc009"
ATTRS{subsystem_vendor}=="0x144d"
ATTRS{device}=="0x24ca"  ATTRS{vendor}=="0x8086"
looking at parent device '/devices/pci0000:00':

KERNELS=="pci0000:00"  SUBSYSTEMS==""  DRIVERS==""
举一个例子：假设你想修改USB扫描仪的配置。通过一系列的尝试，你已经为这个扫描仪标识了Linux设备文件(每次打开扫描仪时，名字都会变)。你可以使
用上面的命令替换这个正确的Linux设备文件名，然后定位输出的采用SYSFS{idVendor}行和SYSFS{idProduct}行。最后你可
以使用这些信息来为这个扫描仪创建新的选项。

SYSFS{idVendor}=="0686",  SYSFS{idProduct}=="400e",
SYMLINK+="scanner", MODE="0664",
group="scanner"上面的例子表示将扫描仪的组设置为scanner，访问权限设置为0664,同时创建一个/dev/scanner的符号连接。

udev-FAQ

问：udev是什么? 它的目的何在?

答：udev是一种工具，它能够根据系统中的硬件设备的状态动态更新设备文件，包括设备文件的创建，删除等。设备文件通常放在/dev目录下。使用udev后，在/dev目录下就只包含系统中真正存在的设备。

问：udev支持什么内核？

答：udev只支持linux-2.6内核，因为udev严重依赖于sysfs文件系统提供的信息，而sysfs文件系统只在linux-2.6内核中才有。

问：udev是一个内核程序还是用户程序？

答：udev是一个用户程序(user-mode daemon)。

问：udev和devfs有什么差别？

答：udev能够实现所有devfs实现的功能。但udev运行在用户模式中，而devfs运行在内核模式中。据称：devfs具有一些不太容易解决的先天缺陷。

问：udev的配置文件放在哪里？

答：udev是一个用户模式程序。它的配置文件是/etc/udev/udev.conf。这个文件一般缺省有这样几项：

udev_root=”/dev” ; udev产生的设备文件的根目录是/dev
udev_db=”/dev/.udevdb” ; 通过udev产生的设备文件形成的数据库
udev_rules=”/etc/udev/rules.d” ;用于指导udev工作的规则所在目录。
udev_log=”err” ;当出现错误时，用syslog记录错误信息。

问：udev的工作过程是怎样的？

答：由于没有研究过udev的源程序，不敢贸然就说udev的工作过程。我只是通过一些网上的资料和udev的说明文档，大致猜测它的工作过程可能是这样的。

当内核检测到在系统中出现了新设备后，内核会在sysfs文件系统中为该新设备生成一项新的记录，一般sysfs文件系统会被mount到/sys目录中。新记录是以一个或多个文件或目录的方式来表示。每个文件都包含有特定的信息。(信息是如何表述的，还要另外研究？)

udev在系统中是以守护进程的方式udevd在运行，它通过某种途径(到底什么途径，目前还没搞懂。)检测到新设备的出现，通过查找设备对应的sysfs中的记录得到设备的一些信息。

udev会根据/etc/udev/udev.conf文件中的udev_rules指定的目录，逐个检查该目录下的文件，这个目录下的文件都是针对某类或某个设备应该施行什么措施的规则文件。udev读取文件是按照文件名的ASCII字母顺序来读取的，如果udev一旦找到了与新加入的设备匹配的规则，udev就会根据规则定义的措施对新设备进行配置。同时不再读后续的规则文件。

问：udev的规则文件的语法是怎样的？

答：udev的规则文件以行为单位，以”#”开头的行代表注释行。其余的每一行代表一个规则。每个规则分成一个或多个“匹配”和“赋值”部分。“匹配”部分用“匹配“专用的关键字来表示，相应的“赋值”部分用“赋值”专用的关键字来表示。“匹配”关键字包括：ACTION，KERNEL，BUS，SYSFS等等，“赋值”关键字包括：NAME，SYMLINK，OWNER等等。具体详细的描述可以阅读udev的man文档。

下面举个例子来说明一下，有这样一条规则：SUBSYSTEM==”net”, ACTION==”add”,
SYSFS{address}==”00:0d:87:f6:59:f3″, IMPORT=”/sbin/rename_netiface %k
eth0″
这个规则中的“匹配”部分有三项，分别是SUBSYSTEM，ACTION和SYSFS。而”赋值”部分有一项，是IMPORT。这个规则就是说，当系统中出现的新硬件属于net子系统范畴，系统对该硬件采取的动作是加入这个硬件，且这个硬件在SYSFS文件系统中的“address”信息等于“00：0d...”时，对这个硬件在udev层次施行的动作是调用外部程序/sbin/rename_netiface，传递的参数有两个，一个是“%k”，代表内核对该新设备定义的名称。另一个是”eth0“。
从上面这个例子中可以看出，udev的规则的写法比较灵活的，尤其在“匹配”部分中，可以通过诸如”*“,
”?“,[a-c],[1-9]等shell通配符来灵活匹配多个匹配项。具体的语法可以参考udev的man文档。

问：udev怎样做到不管设备连接的顺序而维持一个统一的设备名？

答：实际上，udev是通过对内核产生的设备名增加别名的方式来达到上述目的的。前面说过，udev是用户模式程序，不会更改内核的行为。因此，内核依然会我行我素地产生设备名如sda,sdb等。但是，udev可以根据设备的其他信息如总线（bus），生产商（vendor）等不同来区分不同的设备，并产生设备文件。udev只要为这个设备文件取一个固定的文件名就可以解决这个问题。在后续对设备的操作中，只要引用新的设备名就可以了。但为了保证最大限度的兼容，一般来说，新设备名总是作为一个对内核自动产生的设备名的符号链接（link）来使用的。

例如：内核产生了sda设备名，而根据信息，这个设备对应于是我的内置硬盘，那我就可以制定udev规则，让udev除了产生/dev/sda设备文件外，另外创建一个符号链接叫/dev/internalHD。这样，我在fstab文件中，就可以用/dev/internalHD来代替原来的/dev/sda了。下次，由于某些原因，这个硬盘在内核中变成了sdb设备名了，那也不用着急，udev还会自动产生/dev/internalHD这个链接，并指向正确的/dev/sdb设备。所有其他的文件像fstab等都不用修改。

问：怎样才能找到这些设备信息，并把他们放到udev的规则文件中来匹配呢？

答：这个问题比较难，网上资料不多，我只找到一篇文章来介绍如何写udev的规则。他的基本方法是通过udevinfo这个实用程序来找到那些可以作为规则文件里的匹配项的项目。有这样两种情况可以使用这个工具：

第一种情况是，当你把设备插入系统后，系统为设备产生了设备名（如/dev/sda）。那样的
话，你先用udevinfo -q path
-n/dev/sda，命令会产生一个该设备名对应的在sysfs下的路径，如/block/sda。然后，你再用udevinfo
-a
-p/sys/block/sda，这个命令会显示一堆信息，信息分成很多块。这些信息实际来自于操作系统维护的sysfs链表，不同的块对应不同的路径。你就可以用这些信息来作为udev规则文件中的匹配项。但需要注意的是，同一个规则只能使用同一块中显示的信息，不能跨块书写规则。

第二种情况是，不知道系统产生的设备名，那就只有到/sys目录下去逐个目录查找了，反复用udevinfo　-a
-p/sys/path...这个命令看信息，如果对应的信息是这个设备的，那就恭喜你。否则就再换个目录。当然，在这种情况下，成功的可能性比较小。

问: udev和devfs是什么关系
答:
udev完全在用户态(userspace)工作，利用设备加入或移除时内核所发送的hotplug事件(event)来工作。关于设备的详细信息是由内核输出(export)到位于/sys的sysfs文件系统的。所有的设备命名策略、权限控制和事件处理都是在用户态下完成的。与此相反，devfs是作为内核的一部分工作的。

问:
如果udev不能完成所有devfs的工作的话，为什么把devfs标记为OBSOLETE/removed?

答: 引用 Al Viro (Linux VFS 内核维护者):

-devfs所做的工作被确信可以在用户态来完成。
-devfs被加入内核之时，大家寄望它的质量可以迎头赶上。
-devfs被发现了一些可修复和无法修复的 bug。
-对于可修复的 bug，几个月前就已经被修复了，其维护者认为一切良好。
-对于后者，同样是相当常一段时间以来没有改观了。
-devfs的维护者和作者对它感到失望并且已经停止了对代码的维护工作。

问:
但是当一个并不存在的/dev节点被打开的时候，udev并不能如devfs一样自动加载驱动程序。
答:
的确如此，但Linux的设计是在设备被发现的时候加载模块，而不是当它被访问的时候。

问: 不过等等，我确实希望 udev
可以在不存在的节点被打开的时候自动加载驱动。这是我使用devfs的唯一原因了。给udev
增加这个功能吧。
答: 不，udev 是用来管理/dev 的，不是用来加载内核驱动的。

问: 嗨，求你们了。这不难做到的。
答:
这么个功能对于一个配置正确的计算机是多余的。系统中所有的设备都应该产生hotplug
事件、加载恰当的驱动，而 udev
将会注意到这点并且为它创建对应的设备节点。如果你不想让所有的设备驱动停留在内存之中，应该使用其它东西来管理你的模块(如脚本,
modules.conf, 等等) 这不是udev 的工作。

问: 但是我真的喜欢那个功能，还是加上吧
答:
devfs用的方法导致了大量无用的modprobe尝试，以此程序探测设备是否存在。每个试探性探测都新建一个运行
modprobe 的进程，而几乎所有这些都是无用的。

问: 我喜欢devfs的设备文件命名方式，udev 可以这样命名么?
答: 可以，udev 可以使用 /dev
的命名策略来创建节点。通过一个配置文件，可以把内核缺省的名字映射到 devfs
的名字。可以看看udev 中带的 udev.rules.devfs 文件。注意: devfs
的命名方式是不被建议并且不被官方支持的，因为它所用的简单枚举设备的方式在设备可能被随时加入或删除的情况下确实是一个比较笨的方法。这些编号代给你的将只有麻烦，而并不能用来确定设备。看看那个永久性磁盘
(persistentdisk)
的规则就知道如何在用户态下正确的做这件事，而不是傻傻地列出设备。

问: udev 可以为哪些设备创建节点?
答: 所有在 sysfs 中显示的设备都可以由 udev
来创建节点。如果内核中增加了其它设备的支持，udev
也就自动地可以为它们工作了。现在所有的块设备都在被支持之列，大部分的主字符设备也是被支持的。内核开发者们正致力于让所有的字符设备都被支持。可以到linux-kernel邮件列表上寻找补丁或是查看补丁的状态。

问: udev 是否会去掉匿名设备数量的限制?
答: udev 完全工作于用户态。如果内核支持了更多的匿名设备，udev就会支持。

问: udev 是否会支持符号链接?
答: udev 现在就支持符号链接，每个设备节点拥有多个符号链接也是被支持的。

问: udev如何处理/dev文件系统?
答: 建议使用一个每次启动系统的时候重新创建的 tmpfs 作为 /dev
的文件系统。不过实际上udev并不关心那种文件系统在被使用。

问: 在 init 运行之前，udev 如何处理设备?
答: udev 可以被放入 initramfs
之中，并在每个设备被发现的时候运行。也可以让udev
工作在一个真的根分区被加载之后根据 /sys 的内容创建的初始/dev目录之中。

问: 我是否可以利用 udev 在一个 USB 设备被加载的时候自动加载上这个设备?
答: 技术上讲是可以的，但是 udev 不是用于这个工作的。所有的主流发布版
(distro)都包含了 HAL ([[http://freedesktop.org/wiki/Software_2fhal]])
用于这个工作，它也是专门用于监视设备变更的，并且集成进入了桌面软件。

换个角度说，这可以简单的通过 fstab 来实现:/dev/disk/by-label/PENDRIVE
/media/PENDRIVE vfat user,noauto 0 0
这样，用户可以用如下命令来访问设备:
$mount /media/PENDRIVE
同样不需要管理员权限，但却拥有了设备的全部访问权限。使用永久性磁盘链接(label,
uuid) 将可以指定同一设备，无论其实际上的内核名字是什么。

问: 有什么我需要注意的安全问题么?
答:
当使用动态设备编号的时候，一个给定的主/从设备号可能在不同时间对应不同的设备，如果一个用户拥有对这个节点的访问权限，并且可以创建一个到这个节点的硬链接，他就可以如此得到一个这个设备节点的拷贝。当设备被移除之后，udev
删除了设备节点，但硬链接依然存在。如果这个设备节点之后被重新使用不同的访问权限被创建的时候，其硬链接仍然可以使用先前的访问权限来访问。(同样的问题也存在在使用
PAM 改变访问权限的 login 上。)

简单的解决方案就是通过把 /dev 放在 tmpfs
这样的单独的文件系统之上来防止建立硬链接。

*** 显卡
**** Linux 显卡开源驱动
+ https://help.ubuntu.com/community/RadeonHD

xserver-xorg-video-*
**** Linux AMD 闭源显卡驱动
+ http://forum.ubuntu.org.cn/viewtopic.php?f=42&t=445434


fglrx
**** Linux 双显(dual-monitors) xrandr
+
   http://zeroset.mnim.org/2013/01/07/dual-head-monitor-setup-on-ubuntu-linux-with-xorg-and-radeon/
+ http://my.oschina.net/pureboys/blog/88448



1. Dynamic Configuration

   We will use xrandr to configure a temporary dual-head setup during
   runtime. After connecting the monitor to the laptop, obtain the
   labels the system assigned to the monitors by a
   #+BEGIN_EXAMPLE
   xrandr -q
   #+END_EXAMPLE

   In my case, the output read
   #+BEGIN_EXAMPLE
     Screen 0: minimum 320 x 200, current 1920 x 1848, maximum 8192 x 8192
     LVDS connected 1366x768+0+1080 (normal left inverted right x axis y axis) 0mm x 0mm
        1366x768       60.0*+
        1280x720       59.9
        1152x768       59.8
      (...)
     HDMI-0 connected 1920x1080+0+0 (normal left inverted right x axis y axis) 531mm x 299mm
        1920x1080      60.0*+   50.0
        1600x1200      60.0
        1680x1050      59.9
      (...)
      VGA-0 disconnected (normal left inverted right x axis y axis)
   #+END_EXAMPLE

   The laptop’s internal monitor is called LVDS and the external
   monitor HDMI-0. By another call to xrandr, we activate the
   dual-head setup:
   #+BEGIN_EXAMPLE
     xrandr --output HDMI-0 --primary --left-of LVDS
   #+END_EXAMPLE

   The command line is to be understood literally: The HDMI monitor
   shall be the primary screen (e.g. displaying gnome’s titlebar) and
   shall be positioned left of the laptop’s internal monitor. For
   other placements, see xrandr’s –left-of, –right-of, –above and
   –below options or the very general –pos argument.

2. Permanent Configuration

   For a permanent static configuration of a dual-head setup, we
   create a configuration file for the X server with an editor of your
   choice, */etc/X11/xorg.conf*

   You will need root privileges for this. The contents of xorg.conf
   is as follows:
   #+BEGIN_EXAMPLE
     Section "Device"
             Identifier      "Mobility Radeon HD 5400 Series"
             Driver          "radeon"
             Option          "monitor-LVDS" "monitor_internal"
             Option          "monitor-HDMI-0" "monitor_external"
     EndSection

     Section "Monitor"
             Identifier      "monitor_internal"
             Option          "RightOf" "monitor_external"
     EndSection

     Section "Monitor"
             Identifier      "monitor_external"
             Option          "Primary" "true"
     EndSection
   #+END_EXAMPLE

   In the device section, we specify to use Xorgs’s open source
   radeon driver and setup two aliases for the monitors. Please note
   that the monitor ID is composed of the static prefix monitor- and
   the monitor label as returned by xrandr -q (see above). The
   remaining configuration places the laptop’s internal monitor right
   of the external monitor. The latter is configured to be the primary
   screen

*** 硬盘                                                             :disk:
**** 挂载

http://zhidao.baidu.com/link?url=sI0Cj1dxjOadRiFkLrHYGRi4LpqtlGYfn9uUfAhIzDIDEKsqzl2TGHPx_LPdY0xpYdqbLAi9n9txnY9V94YcKu_13HTEP8z8n_y4CiQD3V3

1. 查看硬盘信息： sudo fdisk -l
2. 挂载：sudo mount ntfs /dev/sdb /mnt/sdb
3. 卸载： sudo umount sdb

**** 新硬盘

http://blog.csdn.net/chenjiiinliang/article/details/7301999

sda是第一块SCSI硬盘，sdb第二块，以此类推...物理分区使用a、b编号，每个
物理硬盘最多有四个主逻辑分区（或扩展分区），所以自动分区中，扩展分区
sda2下第一个逻辑分区编号从5开始。

1. 加载硬盘
   #+BEGIN_EXAMPLE
   sudo hdparm -I /dev/sdb
   #+END_EXAMPLE

   硬盘硬件安装后，此命令测试linux系统是否能找到挂载的未分区硬盘

2. 创建分区
   #+BEGIN_EXAMPLE
   sudo fdisk /dev/sdb
   #+END_EXAMPLE

   第一次执行sudo fdisk /dev/sdb，出现了Error: Unable to open
   /dev/sdb - unrecogniseddisk label.  提示找不到磁盘标签，可以使用
   parted 进行分区

   #+BEGIN_EXAMPLE
   sudo parted  /dev/sdb
   #+END_EXAMPLE

3. 格式化硬盘
   #+BEGIN_EXAMPLE
   sudo mkfs -t ext3 /dev/sdb1
   #+END_EXAMPLE

   把上面创建的新硬盘分区格式化为ext3格式，这个要等一会才能自动结束。

4. 设置卷标
   #+BEGIN_EXAMPLE
   sudo e2label /dev/sdb1 /backup
   #+END_EXAMPLE

   这里/backup 就是在/dev/sdb1根下起了个名字.

5. 设置挂载点
   #+BEGIN_EXAMPLE
   sudo mkdir /backup                   //在根路径下创建挂载点
   #+END_EXAMPLE

6. 设置开机自动挂载
   #+BEGIN_EXAMPLE
   sudo vim /etc/fstab
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
    <file system> <mount point>   <type>  <options>       <dump>      <pass>
   #+END_EXAMPLE
   + 指代文件系统的设备名。最初，该字段只包含待挂载分区的设备名（如
     /dev/sda1）。现在，除设备名外，还可以包含LABEL或UUID

   + 文件系统挂载点。文件系统包含挂载点下整个目录树结构里的所有数据，
     除非其中某个目录又挂载了另一个文件系统

   + 文件系统类型。下面是多数常见文件系统类型
     （ext3,tmpfs,devpts,sysfs,proc,swap,vfat）

   + mount命令选项。mount选项包括noauto（启动时不挂载该文件系统）和ro
     （只读方式挂载文件系统）等。在该字段里添加用户或属主选项，即可允
     许该用户挂载文件系统。多个选项之间必须用逗号隔开。其他选项的相关
     信息可参看mount命令手册页（-o选项处）

   + 储文件系统？该字段只在用dump备份时才有意义。数字1表示该文件系统需
     要转储，0表示不需要转储

   + 件系统检查？该字段里的数字表示文件系统是否需要用fsck检查。0表示不
     必检查该文件系统，数字1示意该文件系统需要先行检查（用于根文件系
     统）。数字2则表示完成根文件系统检查后，再检查该文件系统

**** Linux开机自动挂载Windows分区硬盘

+ http://www.douban.com/note/170604841/


对于linux系统挂载windows分区是必须的，比如你u盘fat32的或是ntfs的格式的。
当然这个在ubuntu的我我文件管理器 *nautilus* 会自动挂载。对双系统用户你
的windows在默认的情况下就不会被挂载。当然于是你打开音乐播放器放音乐之
前还要打开nautilus 挂载下。如果我的启动是在命令行下，那好也要手动mount
下。

也有一种软件能够让你自动挂载windows  比如 *ntfs-config*  和ivman。
ntfs-config就用过一次。就是有次重装之前，被ntfs-config 搞的 / 分区无法
挂载（当时还不懂改fstab，汗 只好重装）。其实我们只需要手懂配置fstab来
挂载linux分区。

***** fstab                                                       :fstab:

*fstab* 拆开下 *filesystem  table*, 也就是 linux开机过程控制你要挂载的
硬盘分区配置文件

fstab内容格式是这样的:
#+BEGIN_EXAMPLE
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
#+END_EXAMPLE
如，
#+BEGIN_EXAMPLE
UUID=c5dc9d91-c74b-4d1f-a232-d3151fd57157 / ext4 errors=remount-ro 0 1
#+END_EXAMPLE
或
#+BEGIN_EXAMPLE
或者是
/dev/sda3 / ext4 errors=remount-ro 0 1
#+END_EXAMPLE

***** type


对于linux读取 ntfs分区靠的是 *ntfs-3g*, 所以首先检查下ntfs-3g有没有安
装:

#+BEGIN_SRC sh :exports both
dpkg -l | grep ntfs-3g
#+END_SRC

#+RESULTS:
: ii  ntfs-3g                                               1:2013.1.13ar.1-2ubuntu2                            i386         read/write ntfs driver for fuse

#+BEGIN_EXAMPLE
sudo apt-get install ntfs-3g
#+END_EXAMPLE

***** 查看分区在硬件号， 或uuid

看你要挂分区的硬件号或者uuid，一般来说你D盘是/dev/sda5，E盘是/dev/sda6
依次向后。可以先mount看下，看uuid：
#+BEGIN_EXAMPLE
  sudo blkid
  或
  ls -al /dev/disk/by-uuid
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  /dev/sda1: LABEL="System" UUID="7CBAC8EABAC8A1CE" TYPE="ntfs"
  /dev/sda5: LABEL="Application" UUID="90F2CCECF2CCD81C" TYPE="ntfs"
  /dev/sda6: LABEL="Reserch" UUID="604A95194A94ECD2" TYPE="ntfs"
  /dev/sda7: UUID="eae74ff0-45fd-4f09-9388-959b374ecf00" TYPE="ext4"
  /dev/sda8: UUID="f9f56dde-778a-4c8e-8fb0-539f20bffe92" TYPE="swap"
  /dev/sda9: UUID="f2eaee27-0822-4aa6-b3ed-ab043d2f739b" TYPE="ext4"
#+END_EXAMPLE

*建议用uuid*: 因为uuid是一个硬盘分区, 全中国，全世界，全宇宙的唯一标示
符，当然uuid不仅标示硬盘分区还表示其他电脑设备。

***** 步骤

1. 备份

   对fstab 进行备份: =cp /etc/fstab /etc/fstab.bak=,这是一种习惯, 修改
   错的话, cp回来覆盖就行。

2. 设置挂载点
   #+BEGIN_EXAMPLE
   sudo mkdir /media/Reserch
   ...
   #+END_EXAMPLE

3. 配置fstab
   #+BEGIN_EXAMPLE
     UUID="604A95194A94ECD2"  /media/Reserch  ntfs-3g  default  0  0
     或
     /dev/sda6  /media/Reserch ntfs-3g default 0 0
   #+END_EXAMPLE

   第4挂载参数，默人填default就行。如果需要更多的功能可以藏，这么填写
   =defaults,utf8,umask=000,uid=fly,gid=fly=
   + uid 后面的参数是你用户名
   + gid后面的是你的用户组名
   + gid,uid 主要是为了你可能无法将文件删除近回收站
   + umask这个参是防止你不能读写文件
   + utf8 是考虑可能出现的乱码


**** [[http://www.linuxidc.com/Linux/2013-06/85747.htm][用GParted-LiveCD进行Ubuntu分区大小的调整]] :blog:gparted:

***** 准备

1. 下载最新版本的gparted镜像文件：点击这里。

2. 将gparted镜像文件刻录成光盘或压制在U盘上制成LiveUSB

3. 虽说是无损调整，但为了安全起见(万一停电咋办？)，建议备份重要数据到
   移动硬盘上

4. 在BIOS中，将启动顺序设置为首先光驱启动(如果是用LiveUSB，应设为
   USB-HDD)

***** 调整分区

1. 将光盘放入光驱(如果是用LiveUSB，插上U盘)，重启电脑

2. 进入gparted启动界面，直接选Defalt settings

3. 第二个界面继续按回车

4. 接下来选语言，输入“26”回车(就是简体中文，尽管汉化不全)

5. 接着提示将要进入X-Windows界面，回车

6. 进入gparted，就会发现和瘟到死的PQ相似的界面，实际操作也是一样的，而
   且也支持瘟到死分区的调整

7. 点击你要腾出空间的分区，弹出右键菜单选择“Resize/Move”

8. 用鼠标托动或数字精确调整要释放的空间大小，若要释放在分区头部拉左侧
   的控制条(输入第一行数值)，若要释放在分区尾部拉右侧的控制条(输入第三
   行数值),调整好之后点“更改大小/移动”按钮。

9. 点击欲扩大容量的分区，弹出右键菜单选择“Resize/Move”

10. 按照第8步的方法操作，只是现在变成扩大分区容量而已

11. 点击“Edit”菜单，选择“Apply All Operations”

12. 再次确认要调整分区容量后，gparted开始调整分区，完成后点“Close”按
    钮

13. 点“gparted”菜单，选“Quit”关闭gparted窗口，再双击左上角的
    “Exit”按钮退出gparted系统

14. 在弹出的窗口中选“Reboot”重启电脑，退出时系统会提示你取出光盘

***** 可能存在的问题

可能会发生swap分区丢失的情况，可在终端中用“free -m”命令查看swap分区
是否激活(是否显示容量)，如果未激活，可用“sudo mkswap /dev/sdaX”命令
(X为swap分区的编号)进行激活，并将激活所得的UUID码替换掉“/etc/fstab”
文件(需要管理员权限)中原来 swap分区的UUID编码，重启后即可自动激活挂载

警告：对swap分区的激活操作及对fstab文件的修改应谨慎，必需仔细核对修改
的值
*** 块设备                                                    :blockdevice:

1. /块设备（blockdevice）/

   是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的，他
   使用缓冲区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或者
   从设备一次性读到缓冲区。

2. /字符设备（Character device）/

   是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字
   符是连续地形成一个数据流。他不具备缓冲区，所以对这种设备的读写是实
   时的。

3. /扇区(Sectors)/

   任何块设备硬件对数据处理的基本单位。通常，1个扇区的大小为512byte。
   （对设备而言）

4. /块(Blocks)/

   由Linux制定对内核或文件系统等数据处理的基本单位。通常，1个块由1个或
   多个扇区组成。（对Linux操作系统而言）

5. /段(Segments)/

   由若干个相邻的块组成。是Linux内存管理机制中一个内存页或者内存页的一
   部分。

页、段、块、扇区之间的关系图如下：

[[/home/wally/Wally/Journal//Figure/scrot/30928yba.png]]

*** Video                                                           :video:
**** usb camera                                           :camera:web_cam:

#+BEGIN_EXAMPLE
   ~ $ fswebcam --no-banner -r 640x480 demo.jpg
  --- Opening /dev/video0...
  Trying source module v4l2...
  /dev/video0 opened.
  No input was specified, using the first.
  --- Capturing frame...
  Captured frame in 0.00 seconds.
  --- Processing captured image...
  Disabling banner.
  Writing JPEG image to 'demo.jpg'.
#+END_EXAMPLE
***** /dev/vedio*

/dev/video0

#+BEGIN_EXAMPLE
$ lsusb
Bus 001 Device 006: ID 1e4e:0102 Cubeternet GL-UPC822 UVC WebCam
#+END_EXAMPLE


***** fswebcam: Small and simple webcam software for *nix      :fswebcam:

- [[http://manpages.ubuntu.com/manpages/lucid/man1/fswebcam.1.html][Ubuntu manpages]]
- [[https://github.com/fsphil/fswebcam][github]]
- [[http://www.firestorm.cx/fswebcam/][Homepage]]
- http://www.bkjia.com/Linuxjc/992291.html

****** man                                                         :man:
******* NAME


fswebcam - Small and simple webcam for *nix.

******* SYNOPSIS


fswebcam [<options>] <filename> [[<options>] <filename> ... ]

******* DESCRIPTION


fswebcam  is  a  small  and  simple webcam app for *nix. It can capture
images  from  a  number  of  different  sources  and   perform   simple
manipulation  on  the  captured image. The image can be saved as one or
more PNG or JPEG files.

The PNG or JPEG image can be sent to stdio using the filename "-".  The
output filename is formatted by strftime.

******* CONFIGURATION

******** Configuration File

Config  files  use the long version of options without the "--" prefix.
Comments start with a # symbol at the beginning of the line.

******** General Options
-?, --help
       Show a usage summary.

-c, --config
       Load  options  from  a  file.  You can load more than one config
       file, and can mix them with command-line arguments.

       Note: This option can not be used from  within  a  configuration
       file.

-q, --quiet
       Hides all messages except errors.

-v, --verbose
       Print extra information during the capture process.

--version
       Print the version number and exit.

-l, --loop <frequency>
       Continually capture images. The time between images is specified
       in seconds.

       Default behaviour is to capture a single image and exit.

       Note: The time to capture the next image is calculated  relative
       to  the epoch, so an image will not be captured immediately when
       the program is first started.

--offset <seconds>
       Sets the offset to use when calculating when the next  image  is
       due in loop mode. Value can be positive or negative.

-b, --background
       Run  in  the background. In this mode stdout and console logging
       are unavailable.

--pid <filename>
       Saves the PID of the background process to the  specified  file.
       Ignored when not using background mode.

--log [file/syslog:]<filename>
       Redirect log messages to a file or syslog. For example

       --log output.log
       --log file:output.log
       --log syslog

--gmt  Use  GMT instead of the local timezone when formatting text with
       strftime.

******** Capture Options
-d, --device [<prefix>:]<device name>
       Set the source or device to use. The source module  is  selected
       automatically unless specified in the prefix.

       Default is /dev/video0.

       Available source modules, in order of preference:

       V4L2 - Capture images from a V4L2 compatible video device.
       V4L1 - Capture images from a V4L1 compatible video device.
       FILE - Capture an image from a JPEG or PNG image file.
       RAW - Reads images straight from a device or file.
       TEST - Draws colour bars.

-i, --input <input number or name>
       Set  the  input  to  use. You may select an input by either it’s
       number or name.

       Default is "0".

--list-inputs
       List available inputs for the selected source or device.

       fswebcam -d v4l2:/dev/video1 --list-inputs

-t, --tuner <tuner number>
       Set the tuner to use.

-f, --frequency <frequency>
       Set the frequency of the selected input or tuner. The value  may
       be read as KHz or MHz depending on the input or tuner.

-p, --palette <name>
       Try  to use the specified image format when capturing the image.

       Default is to select one automatically.

       Supported formats:

       PNG
       JPEG
       MJPEG
       RGB32
       RGB24
       BGR32
       BGR24
       YUYV
       UYVY
       YUV420P
       BAYER
       RGB565
       RGB555
       GREY

-r, --resolution <dimensions>
       Set the image resolution of the source  or  device.  The  actual
       resolution  used  may  differ  if  the  source  or device cannot
       capture at the specified resolution.

       Default is "384x288".

--list-framesizes
       Lists the supported resolutions for the selected source.

--list-framerates
       Lists the supported frame rates  for  the  selected  source  and
       resolution.

-F, --frames <number>
       Set the number of frames to capture. More frames mean less noise
       in the final image, however capture times  will  be  longer  and
       moving objects may appear blurred.

       Default is "1".

-S, --skip <number>
       Set  the number of frames to skip. These frames will be captured
       but won’t be use. Use this option if your camera sends some  bad
       or corrupt frames when it first starts capturing.

       Default is "0".

-D, --delay <delay>
       Inserts  a  delay after the source or device has been opened and
       initialised, and before the capture begins.  Some  devices  need
       this  delay to let the image settle after a setting has changed.
       The delay time is specified in seconds.

-R, --read
       Use read() to capture images. This can be slower but more stable
       with some devices.

       Default  is  to  use mmap(), falling back on read() if mmap() is
       unavailable.

-s, --set <name=value>
       Set a control. These are used by the source modules  to  control
       image or device parameters. Numeric values can be expressed as a
       percentage of there  maximum  range  or  a  literal  value,  for
       example:

       --set brightness=50% --set framerate=5

       Non-numeric controls are also supported:

       --set lights=on

       V4L2  features  a  type  of  control  called  a  ’button’. These
       controls do not take any  value,  but  trigger  an  action.  For
       example:

       --set "Restore Factory Settings"

       Control names and values are not case sensitive.

       Note:  Available  controls  will  vary  depending  in the source
       module  and  devices  used.  For  more   information   see   the
       --list-controls option.

--list-controls
       List  available  controls  and  their  current  values  for  the
       selected source module and device. For example:

       fswebcam -d v4l2:/dev/video2 --list-controls

******** Output Options
These options are performed in the order they  appear  on  the  command
line,  only  effecting  images  output  later  on the command line. For
example:

       fswebcam -r 640x480 output1.jpeg --scale 320x240 output2.jpeg

       Will  create  two  images,  "output1.jpeg"  containing  a   full
       resolution   copy  of  the  captured  image  and  "output2.jpeg"
       containing the same captured image but scaled to half the  size.

--no-banner
       Disable the banner.

--top-banner
       Position the banner at the top of the image.

--bottom-banner
       Position the banner at the bottom of the image.

       This is the default.

--banner-colour <#AARRGGBB>
       Set  the  colour  of  the banner. Uses the web-style hexadecimal
       format (#RRGGBB) to describe the  colour,  and  can  support  an
       alpha channel (#AARRGGBB). Examples:

       "#FF0000" is pure red.
       "#80000000" is semi-transparent black.
       "#FF000000" is invisible (alpha channel is at maximum).
       Default is "#40263A93".

--line-colour <#AARRGGBB>
       Set the colour of the divider line. See --banner-colour for more
       information.

       Default is "#00FF0000".

--text-colour <#AARRGGBB>
       Set the  colour  of  the  text.  See  --banner-colour  for  more
       information.

       Default is "#00FFFFFF".

--font <[file or font name]:[font size]>
       Set  the  font  used  in the banner. If no path is specified the
       path in the GDFONTPATH environment variable is searched for  the
       font.

       If no font size is specified the default of "10" will be used.

       Default is "luxisr:10".

--no-shadow
       Disable the text shadow.

--shadow
       Enable the text shadow.

       This is the default behaviour.

--title <text>
       Set the main text, located in the top left of the banner.

--no-title
       Clear the main text.

--subtitle <text>
       Set  the  sub-title  text,  located  in  the  bottom left of the
       banner.

--no-subtitle
       Clear the sub-title text.

--timestamp <text>
       Set the timestamp text, located in the top right of the  banner.
       This string is formatted by strftime.

       Default is "%Y-%m-%d %H:%M (%Z)".

--no-timestamp
       Clear the timestamp text.

--info <text>
       Set the info text, located in the bottom right of the banner.

--no-info
       Clear the info text.

--underlay <filename>
       Load  a PNG image and overlay it on the image, below the banner.
       The image is aligned to the top left.

       Note: The underlay is only applied when saving an image  and  is
       not modified by any of the image options or effects.

--no-underlay
       Clear the underlay image.

--overlay <filename>
       Load a PNG image and overlay on the image, above the banner. The
       image is aligned to the top left.

       Note: The overlay is only applied when saving an  image  and  is
       not modified by any of the image options or effects.

--no-overlay
       Remove the overlay image.

--jpeg <factor>
       Set JPEG as the output image format. The compression factor is a
       value between 0 and 95, or -1 for automatic.

       This is the default format, with a factor of "-1".

--png <factor>
       Set PNG as the output image format. The compression  factor  can
       be a value between 0 and 9, or -1 for automatic.

--save <filename>
       Saves the image to the specified filename.

       Note:  This isn’t necessary on the command-line where a filename
       alone is enough to save an image.

--revert
       Revert to the  original  captured  image  and  resolution.  This
       undoes all previous effects on the image.

       Note:  This  only reverts the image itself, and not options such
       as font, colours and overlay.

--flip <direction[,direction]>
       Flips the image. Direction can be  (h)orizontal  or  (v)ertical.
       Example:

       --flip h    Flips the image horizontally.
       --flip h,v  Flips the image both horizontally and vertically.

--crop <dimensions[,offset]>
       Crop  the  image.  With  no  offset the cropped area will be the
       center of the image. Example:

       --crop 320x240    Crops the center 320x240 area of the image.
       --crop 10x10,0x0  Crops the 10x10 area at the top left corner of
       the image.

--scale <dimensions>
       Scale the image.

       Example:  "--scale  640x480"  scales  the  image  up  or down to
       640x480.

       Note: The aspect ratio of the image is not maintained.

--rotate <angle>
       Rotate the image in right angles (90, 180 and 270 degrees).

       Note: Rotating the  image  90  or  270  degrees  will  swap  the
       dimensions.

--deinterlace
       Apply a simple deinterlacer to the image.

--invert
       Invert all the colours in the image, creating a negative.

--exec <command>
       Executes  the  specified  command  and  waits for it to complete
       before continuing. The command line is formatted by strftime.

******* SIGNALS

SIGHUP This causes fswebcam to reload it’s configuration.

SIGUSR1
       Causes fswebcam to capture an image immediately without  waiting
       on the timer in loop mode.

****** help                                                       :help:

#+BEGIN_EXAMPLE
   ~ $ fswebcam --help
  Usage: fswebcam [<options>] <filename> [[<options>] <filename> ... ]

   Options:

   -?, --help                   Display this help page and exit.
   -c, --config <filename>      Load configuration from file.
   -q, --quiet                  Hides all messages except for errors.
   -v, --verbose                Displays extra messages while capturing
       --version                Displays the version and exits.
   -l, --loop <seconds>         Run in loop mode.
   -b, --background             Run in the background.
   -o, --output <filename>      Output the log to a file.
   -d, --device <name>          Sets the source to use.
   -i, --input <number/name>    Selects the input to use.
   -t, --tuner <number>         Selects the tuner to use.
   -f, --frequency <number>     Selects the frequency use.
   -p, --palette <name>         Selects the palette format to use.
   -D, --delay <number>         Sets the pre-capture delay time. (seconds)
   -r, --resolution <size>      Sets the capture resolution.
       --fps <framerate>        Sets the capture frame rate.
   -F, --frames <number>        Sets the number of frames to capture.
   -S, --skip <number>          Sets the number of frames to skip.
       --dumpframe <filename>   Dump a raw frame to file.
   -s, --set <name>=<value>     Sets a control value.
       --revert                 Restores original captured image.
       --flip <direction>       Flips the image. (h, v)
       --crop <size>[,<offset>] Crop a part of the image.
       --scale <size>           Scales the image.
       --rotate <angle>         Rotates the image in right angles.
       --deinterlace            Reduces interlace artifacts.
       --invert                 Inverts the images colours.
       --greyscale              Removes colour from the image.
       --swapchannels <c1c2>    Swap channels c1 and c2.
       --no-banner              Hides the banner.
       --top-banner             Puts the banner at the top.
       --bottom-banner          Puts the banner at the bottom. (Default)
       --banner-colour <colour> Sets the banner colour. (#AARRGGBB)
       --line-colour <colour>   Sets the banner line colour.
       --text-colour <colour>   Sets the text colour.
       --font <[name][:size]>   Sets the font and/or size.
       --no-shadow              Disables the text shadow.
       --shadow                 Enables the text shadow.
       --title <text>           Sets the main title. (top left)
       --no-title               Clears the main title.
       --subtitle <text>        Sets the sub-title. (bottom left)
       --no-subtitle            Clears the sub-title.
       --timestamp <format>     Sets the timestamp format. (top right)
       --no-timestamp           Clears the timestamp.
       --gmt                    Use GMT instead of local timezone.
       --info <text>            Sets the info text. (bottom right)
       --no-info                Clears the info text.
       --underlay <PNG image>   Sets the underlay image.
       --no-underlay            Clears the underlay.
       --overlay <PNG image>    Sets the overlay image.
       --no-overlay             Clears the overlay.
       --jpeg <factor>          Outputs a JPEG image. (-1, 0 - 95)
       --png <factor>           Outputs a PNG image. (-1, 0 - 10)
       --save <filename>        Save image to file.
       --exec <command>         Execute a command and wait for it to complete.

#+END_EXAMPLE

***** uvc                                                           :uvc:

USB Video Class (UVC)

*** USB                                                               :usb:
**** [[*lsusb][lsusb]]

*** 串口                                                 :com:serial_port:串口:

**** [[http://blog.csdn.net/laiqun_ai/article/details/8224555][Linux 下查看串口号]]

- 查看串口是否可用，可以对串口发送数据比如对com1口，

  #+BEGIN_EXAMPLE
  echo lyjie126 > /dev/ttyS0
  #+END_EXAMPLE

- 查看串口名称使用

  #+BEGIN_EXAMPLE
  ls -l /dev/ttyS*
  #+END_EXAMPLE

  一般情况下串口的名称全部在dev下面，如果你没有外插串口卡的话默认是dev
  下的ttyS* ,一般ttyS0对应com1，ttyS1对应com2，当然也不一定是必然的；

- 查看串口驱动

  #+BEGIN_EXAMPLE
  cat /proc/tty/drivers/serial
  #+END_EXAMPLE

- 查看串口设备
  #+BEGIN_EXAMPLE
  dmesg | grep ttyS*
  #+END_EXAMPLE


Q: 我新查了一个扩展串口卡，但是不能用，不知道为什么！！！
A: 首先看下说明书，驱动安装好后正常是什么设备号？然后安装驱动，驱动如
果安装成功一般就会有设备号了就可以用了。

Q: 使用dmesg | grep ttyS* 是可以看见新增串口的，分别是ttyS5和ttyS6，中
断号都是20，按照说明安装驱动了也，什么是设备号？
A: 那就是 ttyS5 ttyS6，这个2个设备号就是对应的串口设备号

**** [[http://blog.sina.com.cn/s/blog_74f586a501012cov.html][UART，串口信息的查看（linux）]]

每个UART控制器包含一个波特率发生器，发送器，接收器和控制单元，发送和接
收器包括FIFO和数据移位器，首先数据被写到FIFO中，然后复制到发送移位器中
准备发送，最后数据被发送数据管脚移位发出。数据接收过程是：首先从接收管
脚上面的到数据，然后将数据从移位器中复制到FIFO中。

rs232串口通信接口：当通信距离较近时（<12m），可以使用电缆线直接连接，
若距离较远，需附加调制解调器。

9个脚针的定义：
- CDC数据载波检测，
- RXD接收数据，
- TXD发送数据，
- DTR数据中断准备，
- GND信号地，
- DSR数据设备准备好，
- RTS请求发送，
- CTS清楚发送，
- DELL振铃指示。

linux下查看串口信息

查看串口是否可用，可以对串口发送数据比如对com1口，

#+BEGIN_EXAMPLE
echo lyjie126 > /dev/ttyS0
#+END_EXAMPLE

查看串口名称使用

#+BEGIN_EXAMPLE
ls -l /dev/ttyS*
#+END_EXAMPLE

一般情况下串口的名称全部在dev下面，如果你没有外插串口卡的话默认是dev下
的ttyS*,一般ttyS0对应com1，ttyS1对应com2，当然也不一定是必然的；

查看串口驱动
#+BEGIN_EXAMPLE
cat /proc/tty/drivers/serial
#+END_EXAMPLE

查看串口设备：
#+BEGIN_EXAMPLE
dmesg | grep ttyS*
#+END_EXAMPLE

** 网络管理                                                          :LINUX:
*** Linux 建立无线局域网与如何连接                                   :wlan:

http://ubuntuhandbook.org/index.php/2014/09/3-ways-create-wifi-hotspot-ubuntu/

http://roylez.herokuapp.com/2011/08/11/hostapd.html

*** telnet                                                         :telnet:
*** ssh                                                               :ssh:
**** reference

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/fbdef698-b4b3-4052-b53d-c5e3dfdec29a/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D151d87b4a97%3AS%3D7c50b1d5705c42fc4973a25be63da6f1][EN::九个 SSH 常用命令选项]]

**** intro

SH（全称 /Secure Shell/)是一种 _加密的网络协议_ 。使用该协议的数据将被加密，
如果在传输中间数据泄漏，也可以确保没有人能读取出有用信息。要使用 SSH，
目标机器应该安装 SSH 服务端应用程序，因为 SSH 是基于 _客户-服务_ 模式的。
当你想安全的远程连接到主机，可中间的网络（比如因特网）并不安全，通常这
种情况下就会使用 SSH。

+ 网络传输的安装协议
+ 可靠
+ 快速
+ 版权限制


Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）
所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的
Shell（壳层）提供安全的传输和使用环境。

传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为
它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人
（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充
真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服
务器。

而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利
用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传
输的数据进行加密，也能够防止DNS欺骗和IP欺骗。

SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。
SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个
安全的“通道”。

**** installation

1. 基于 Debian / Ubuntu 的系统

   1) 安装 ssh-client

      #+BEGIN_EXAMPLE
      $ sudo apt-get install openssh-client
      #+END_EXAMPLE

   2) 安装 ssh-server

      #+BEGIN_EXAMPLE
      $ sudo apt-get install openssh-server
      #+END_EXAMPLE

2. 基于 RedHat / CentOS 的系统

   #+BEGIN_EXAMPLE
   # yum install openssh-server openssh-clients
   #+END_EXAMPLE

3. 测试

   #+BEGIN_EXAMPLE
      $ ssh
     usage: ssh [-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]
                [-D [bind_address:]port] [-E log_file] [-e escape_char]
                [-F configfile] [-I pkcs11] [-i identity_file]
                [-L [bind_address:]port:host:hostport] [-l login_name] [-m mac_spec]
                [-O ctl_cmd] [-o option] [-p port]
                [-Q cipher | cipher-auth | mac | kex | key]
                [-R [bind_address:]port:host:hostport] [-S ctl_path] [-W host:port]
                [-w local_tun[:remote_tun]] [user@]hostname [command]
   #+END_EXAMPLE

**** usage

***** 无选项参数运行 SSH

通常使用 SSH 的方式就是不加任何选项参数,仅仅输入 "ssh"。

#+BEGIN_EXAMPLE
$ ssh 192.168.0.103
#+END_EXAMPLE


第一次连接目标主机时，ssh 会让你确认目标主机的真实性。如果你回答的是
NO，SSH 将不会继续连接，只有回答 Yes才会继续。

下一次再登陆此主机时，SSH 就不会提示确认消息了。对此主机的真实验证信息
已经默认保存在每个用户的 /home/user/.ssh 文件里。

***** 指定登陆用户

默认的， _ssh 会尝试用客户机的当前用户作为用户名来连接_ 。

通常，需要提供一个目标主机上存在的用户名。从一开始就要指定用户名的，可
以使用 /-l/ 选项参数。

#+BEGIN_EXAMPLE
$ ssh -l leni 192.168.0.103
#+END_EXAMPLE

也可以这样输入

#+BEGIN_EXAMPLE
$ ssh leni@192.168.0.0103
#+END_EXAMPLE

***** 指定端口

/SSH 默认使用的端口号是 22/

大多现代的 Linux 系统 22 端口都是开放的。如果你运行 ssh 程序而没有指定
端口号，它直接就是通过 22 端口发送请求的。

一些系统管理员会改变 SSH 的默认端口号。让我们试试，现在端口号是
1234.要连上那主机，就要使用 **-p* 选项，后面在加上 SSH 端口号。

#+BEGIN_EXAMPLE
$ ssh 192.168.0.103 -p 1234
#+END_EXAMPLE

要改变端口号，我们需要修改 /etc/ssh/ssh_config 文件，找到此行：

#+BEGIN_EXAMPLE
Port 22
#+END_EXAMPLE

把它换成其他的端口号，比如上面示例的 1234 端口，然后重启 SSH 服务。

***** 对所有数据请求压缩

有了这个选项，所有通过 SSH 发送或接收的数据将会被压缩，并且任然是加密
的。要使用 SSH 的压缩功能，使用 /-C/ 选项。

#+BEGIN_EXAMPLE
$ ssh -C 192.168.0.103
#+END_EXAMPLE

如果你的连网速度很慢的话，比如用 modem 上网，这个选项非常有用。但如果
你使用的是像 LAN 或其它更高级网络的话，压缩反而会降低你的传输速度。可
以使用 -o 选项加上压缩级别参数来控制压缩的级别，但这个选项仅仅只在
SSH-1 下起作用。

***** 指定一个加密算法

SSH 提供了一些可用的加密算法。可以在 */etc/ssh/ssh_config or
~/.ssh/config * 文件中看到（如果存在的话）。


让我们试试比如你想使用 blowfish 算法来加密你的 SSH 会话，那么你只要把
这一行加入你的/etc/ssh/ssh_config or ~/.ssh/config 文件就可以：

#+BEGIN_EXAMPLE
Cipher blowfish
#+END_EXAMPLE

默认的，SSH 会使用 3des 算法。

***** 打开调试模式

因为某些原因，我们想要追踪调试我们建立的 SSH 连接情况。SSH 提供的 -v
选项参数正是为此而设的。

#+BEGIN_EXAMPLE
$ ssh -v 192.168.0.103
#+END_EXAMPLE

***** 绑定源地址

如果你的客户端有多于两个以上的 IP 地址，你就不可能分得清楚在使用哪一个
IP 连接到 SSH 服务器。

为了解决这种情况，我们可以使用 -b 选项来指定一个IP 地址。这个 IP 将会
被使用做建立连接的源地址。

#+BEGIN_EXAMPLE
$ ssh -b 192.168.0.200 -l leni 192.168.0.103
#+END_EXAMPLE

服务端，我们可以使用 netstat 命令来检查到服务的连接是否建立。可以看到
IP 为 192.168.0.200 的连接已经建立。

***** 8. 使用其他配置文件

默认情况下，ssh 会使用位于 /etc/ssh/ssh_config 的配置文件。这个配置
文件作用于系统的所有用户。但你想要为特定的用户指定特殊的设置的话，可以
把配置放入 ~/.ssh/config 文件中。如果此文件不存在，可以手工创建一个。


下面是一个通用 ssh_config 文件配置的例子。这配置文件位于 /home/pungki
目录下。

#+BEGIN_EXAMPLE
  Host 192.168.0.*
  ForwardX11 yes
  PasswordAuthentication yes
  ConnectTimeout 10
  Ciphers aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc
  Protocol 2
  HashKnownHosts yes
#+END_EXAMPLE

要使用指定的配置文件，可以使用 /-F/ 选项。

#+BEGIN_EXAMPLE
$ ssh -F /home/pungki/my_ssh_config 192.168.0.101
#+END_EXAMPLE

***** 使用 SSH X11 Forwarding

某些时候，你可能想把服务端的 X11 应用程序显示到客户端计算机上，SSH 提
供了 -X 选项。但要启用这功能，我们需要做些准备，下面是它的设置：

在服务器端，你需要使 /etc/ssh/ssh_config 文件中的行设置成 ForwardX11
yes 或者 X11Forwad yes，以启用 X11 Forwarding，重启 SSH 服务程序。

然后在客户端，输入 ssh -X user@host:

#+BEGIN_EXAMPLE
$ ssh -X leni@192.168.0.101
#+END_EXAMPLE

一旦登陆，可以输入：

#+BEGIN_EXAMPLE
$ echo $DISPLAY
#+END_EXAMPLE

来检查，你应该可以看到向如下所示的

#+BEGIN_EXAMPLE
localhost:10:0
#+END_EXAMPLE

随后就可以运行应用了，仅仅只能输入应用程序的命令。让我们试试，比如想运
行 xclock 程序，输入：

#+BEGIN_EXAMPLE
$ xclock
#+END_EXAMPLE

它就运行起来了，xclock 确实是运行在远端系统的，但它在你的本地系统里显
示了。

**** ssh server

- [[http://blog.chinaunix.net/uid-22556372-id-1773417.html][ssh 登录出现的几种错误以及解决办法]]

#+BEGIN_EXAMPLE
sudo apt-get install openssh-server
#+END_EXAMPLE

然后确认sshserver是否启动了：

#+BEGIN_EXAMPLE
ps -e |grep ssh
#+END_EXAMPLE

如果看到sshd那说明ssh-server已经启动了。

如果没有则可以这样启动：

#+BEGIN_EXAMPLE
sudo /etc/init.d/ssh start
#+END_EXAMPLE
或 *service*

ssh-server配置文件位于 */etc/ssh/sshd_config* ，在这里可以定义SSH的服
务端口，默认端口是22，你可以自己定义成其他端口号，如222。

然后重启SSH服务：

#+BEGIN_EXAMPLE
sudo /etc/init.d/ssh stop
sudo /etc/init.d/ssh start
#+END_EXAMPLE

然后使用以下方式登陆SSH：

#+BEGIN_EXAMPLE
ssh zhou@192.168.***.** zhou为192.168.***.**机器上的用户，需要输入密码。
#+END_EXAMPLE

断开连接：exit


*** apache                                                         :apache:
**** Apache安装配置
***** Reference
+ Wiki: http://zh.wikipedia.org/wiki/Apache_HTTP_Server
+ Homepage: http://httpd.apache.org/
+ CSDN: http://blog.csdn.net/yzzst/article/details/12045801

***** intro

Apache HTTP Server（简称Apache）是Apache软件基金会的一个开放源代码的网
页服务器软件，可以在大多数电脑操作系统中运行，由于其跨平台和安全性。被
广泛使用，是最流行的Web服务器软件之一。它快速、可靠并且可通过简单的API
扩充，将Perl／Python等解释器编译到服务器中。

中文：阿帕奇

***** Install

+ 源码安装：./configure make make install

***** 启动与测试

#+BEGIN_EXAMPLE
/usr/local/apache2/bin/apachectl start
/usr/local/apache2/bin/apachectl restart
#+END_EXAMPLE

打开浏览器,在地址栏输入 "http://localhost" 出现“It works!”或apache图
标的漂亮界面，说明apache安装成功！

***** 问题

1. httpd: Could not reliably determine the server's fully qualified
   domain name
   + http://blog.sina.com.cn/s/blog_4d83777b0100pgal.html

2. sudo 启动

3. 默认目录

   + 配置 *DocumentRoot* 选项以及随后的 <DIRECTORY ...>

**** [[http://blog.csdn.net/yzzst/article/details/12045801][linux下apache 的安装，php安装过程]]                              :blog:

linux下apache 的安装
1、进入work目录下:cd /usr/local/work
（如没有则自己新建，命令：mkdir /usr/local/work）

2、在work目录下从网站下载apache并解压：
wget http://dev.xiaonei.com/apache-mirror/httpd/httpd-2.0.63.tar.gz
解压：tar zxvf httpd-2.0.63.tar.gz

3、进入httpd-2.0.63目录：cd httpd-2.0.63

4、建立makefile，并将Apache安装到/usr/local/apache2目录下：
./configure -prefix=/usr/local/apache2 -enable-module=so   （/configure前有一个点“.”的）

5、开始编译：make

6、开始安装Apache到work目录中：
make install

7、至此Apache的安装工作完成，可以在每次启动系统时通过如下命令启动或重新启动Apache服务：
/usr/local/apache2/bin/apachectl start
/usr/local/apache2/bin/apachectl restart

8、打开浏览器,在地址栏输入“http://localhost”出现“It works!”或apache图标的漂亮界面，说明apache安装成功！




//////////////PHP 安装////


1.获取安装文件： http://www.php.net/downloads.php   http://cn2.php.net/distributions/php-5.5.4.tar.gz
wget http://cn2.php.net/distributions/php-5.5.4.tar.gz


获取安装php需要的支持文件：http://xmlsoft.org/sources/libxml2-2.9.1.tar.gz
wget http://xmlsoft.org/sources/libxml2-2.9.1.tar.gz


2.安装libxml2


 tar zxvf libxml2-2.9.1.tar.gz
 cd libxml2-2.9.1.
 ./configure --prefix=/usr/local/libxml2
 make
 make install




如果安装成功以后，在/usr/local/libxml2/目录下将生成bin、include、lib、man和share五个目录。在后面安装PHP5源代码包的配置时，会通过在configure命令的选项中加上"--with-libxml-dir=/usr/ local/libxml2"选项，用于指定安装libxml2库文件的位置。






3.安装php5




#tar zvxf php-5.5.4.tar.gz
#cd php-5.5.4
#./configure --prefix=/usr/local/php --with-apxs2=/usr/local/apache2/bin/apxs --with-libxml-dir=/usr/local/libxml2
#make
#make install


4.重新配置apache2让他支持php


配置 httpd.conf 让apache支持PHP：
# vi /usr/local/apache2/conf/httpd.conf


找到 AddType application/x-gzip .gz .tgz 在其下添加如下内容


     AddType application/x-httpd-php .php      (.前面有空格)


AddType application/x-httpd-php-source .phps        (.前面有空格)


然后CPOPY PHP的配置文件
cp php-5.5.4/php.ini.dist /usr/local/php/lib/php.ini


    （如果没有php.ini.dist 则把php.ini-development php.ini-production中的任何一个重命名为php.ini.dist即可。）


修改php.ini文件 增加 register_globals = On


重启apache
service apache restart


5.测试php是否成功安装


写一个php测试页info.php，放到apache2/htdocs中。


<?php


 phpinfo();


?>;


在浏览器中输入：服务器地址/info.php


如果能正常显示出php的信息，则说明Apche+Mysql+PHP安装成功！






今日编译apache时出错：//////////////////////////////////


#./configure --prefix……检查编辑环境时出现：


checking for APR... no
configure: error: APR not found .  Please read the documentation


解决办法：


1.下载所需软件包：


wget http://archive.apache.org/dist/apr/apr-1.4.5.tar.gz
wget http://archive.apache.org/dist/apr/apr-util-1.3.12.tar.gz
wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.10/pcre-8.10.zip
2.编译安装：


yum remove apr-util-devel apr apr-util-mysql apr-docs apr-devel apr-util apr-util-docs
具体步骤如下:


  a:解决apr not found问题>>>>>>


[root@xt test]# tar -zxf apr-1.4.5.tar.gz
[root@xt test]# cd  apr-1.4.5
[root@xt apr-1.4.5]# ./configure --prefix=/usr/local/apr
[root@xt apr-1.4.5]# make && make install

  b:解决APR-util not found问题>>>>


[root@xt test]# tar -zxf apr-util-1.3.12.tar.gz
[root@xt test]# cd apr-util-1.3.12
[root@xt apr-util-1.3.12]# ./configure --prefix=/usr/local/apr-util -with-apr=/usr/local/apr/bin/apr-1-config
[root@xt apr-util-1.3.12]# make && make install


  c:解决pcre问题>>>>>>>>>


[root@xt test]#unzip -o pcre-8.10.zip
[root@xt test]#cd pcre-8.10
[root@xt pcre-8.10]#./configure --prefix=/usr/local/pcre
[root@xt pcre-8.10]#make && make install
4.最后编译Apache时加上：


--with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util/ --with-pcre=/usr/local/pcre
*** socket
+ http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html
+ http://www.cnblogs.com/dolphinX/p/3460545.html


柏克莱套接字（英语：Berkeley sockets） ，又称为BSD 套接字(BSD sockets)
是一种应用程序接口（API），包括了一个用C语言写成的应用程序开发库，主要
用于实现进程间通讯，在计算机网络通讯方面被广泛使用。

接口实现用于TCP/IP协议，因此它是维持Internet的基本技术之一。 它是由加
利福尼亚的伯克利大学开发，最初用于Unix系统。 如今，所有的现代操作系统
都有一些源于Berkeley套接字接口的实现，它已成为连接Internet的标准接口。

*** FTP                                                               :ftp:
**** FTP:tftpd-hpa

http://wiki.ubuntu.org.cn/Tftpd-hpa

tftpd-hpa 是一个功能增强的TFTP服务器。它提供了很多TFTP的增强功能，它已
经被移植到大多数的现代UNIX系统。

1. 安装
   使用下面的命令来安置 tftpd-hpa 服务器：
   #+BEGIN_EXAMPLE
      $ sudo apt-get install tftpd-hpa
   #+END_EXAMPLE
   注：若server未安装xinetd则在ubuntu9.04中会自动下载openbsd-inetd并安
   装，使用tftp过程中出错很多时候是因xinetd版本问题；
2. 配置
   tftp-hpa 的配置文件为 /etc/default/tftpd-hpa
   #+BEGIN_EXAMPLE
      RUN_DAEMON="yes"
      OPTIONS="-l -c -s /tftpboot"
   #+END_EXAMPLE

   -c为可创建新文件，若无此参数，put命令则可能出现错误提示，此时只能覆
   盖原有文件不能创建新文件；

   无论何种方式配置tftp-server -c参数决定是否能正常写入数据； 这里指定
   tftpd 使用的目录为 /tftpboot，注意要修改目录属性：chmod 777
   tftpboot
3. 启动和停止
   1) 启动
      #+BEGIN_EXAMPLE
         # /etc/init.d/tftpd-hpa start
      #+END_EXAMPLE

   2) 停止
      #+BEGIN_EXAMPLE
         # /etc/init.d/tftpd-hpa stop
      #+END_EXAMPLE

** 虚拟化                                                            :vm:kvm:

keywords:  kvm,


- [[https://www.ibm.com/developerworks/cn/linux/theme/virtualization/][IBM:Linux 虚拟化技术]]
- [[https://www.zhihu.com/question/19880359][知乎:Xen KVM 等虚拟化技术在服务器上有哪些应用？
]]- [[http://dockone.io/article/871][Ubuntu创始人 ：Linux容器将完全颠覆虚拟化
]]

*** [[http://os.51cto.com/art/201005/198264_all.htm][六大Linux虚拟化技术]]

Linux虚拟化技术已经不是什么新鲜的技术，对于模拟、平台和操作系统虚拟化，
这三个大家都熟悉的虚拟化技术之外还有其他的虚拟化技术如，CoLinux、用户
模式Linux以及Wine和Cygwin，这些技术都将推动虚拟化技术的发展。

关于Linux虚拟化的优势我们大家已经有所了解。目前使用最多的虚拟化操作系
统还是Windows系列，但是Linux的成长速度是惊人的，大有替代Windows的趋势。

关于Linux虚拟化技术大致上可以分为六个不同的方式。在本文中，我们将讨论
实现Linux虚拟化的这六种方式，以及Linux下的多种虚拟化解决方案。


当我们讨论虚拟化解决方案的时候，常常都要提到具体厂商的具体产品，但是当
我们提及Linux虚拟化解决方案的时候，我们更乐意讨论广泛而多样化的开源生
态系统。Linux支持多种虚拟化平台，并延伸出多种技术，同样也是一个完整方
案的一个元素。


**** 虚拟化—老树开新花

虽然虚拟化现在如此的流行，但虚拟化不是一个新的技术，早在半个世纪之前
IBM就已经开始部署虚拟化。最早虚拟化技术是在IBM M44计算机上进行实验，然
后在IBM System/360大型机产品上开始普及。最早的真正意义上的整体应用虚拟
化的硬件平台是IBM CP-40系统，在上世纪60年代末被用在商业应用上。

虚拟化包含多个层面，比如硬件虚拟化，这种虚拟化从底层的硬件平台直接支持
软件环境；另外一种是操作系统虚拟化，这是Linux的一个亮点。

在硬件层之上，独立于操作系统的一层软件被称之为hypervisor，或者叫做虚拟
机监视器。hypervisor创建了虚拟化平台，而操作系统实例则运行在这个平台上，
这使得硬件平台可以被多个操作系统和应用所共享，从而降低硬件的成本。

运行在hypervisor上面的实体被称为虚拟机，即VM，是用来放置操作系统、应用
和数据元的“容器”。虚拟机中的操作系统和应用程序的数据被存储在虚拟磁盘
中，hypervisor利用虚拟磁盘来启动虚拟化平台。虚拟机被封装为一个文件，这
样比分布式的文件更好管理。


#+DOWNLOADED: http://images.51cto.com/files/uploadimg/20100506/1019430.jpg @ 2016-02-25 10:18:34
 [[~/Wally/Journal/Figure/.org-download/Journal/1019430_2016-02-25_10:18:33.jpg]]
本地虚拟化和主机虚拟化模型


早期的虚拟化模型被称为Type 1，或者叫本地虚拟化（native virtualization），
这种模型下hypervisor直接运行在硬件之上，在hypervisor上面是虚拟机。

后来出现了主机虚拟化（hosted virtualization）模式，被称为Type 2，
hypervisor运行在操作系统之上，在同一平台上允许两个或更多的操作系统共存。

**** Linux虚拟化技术基础

了解了有关虚拟化的一些基本知识后，我们进入正题，来讨论一下Linux虚拟化
的一些知识。首先是模拟（Emulation），是将一个操作系统（Host）的服务转
换并显示成另一个操作系统（Guest）的过程，Host和Guest系统不一定是相同的，
比如，Host系统可能是x86平台，可以提供PowerPC平台的模拟，即使是指令和架
构完全不相同。

另外，hypervisor的模拟器（emulator）可以提供多个平台的模拟，比如下面的
图例，在Host系统上可以仿真出PowerPC和ARM系统。模拟过程并不仅限于Type 2
虚拟化模型，在虚拟化技术中都存在这个过程。


#+DOWNLOADED: http://images.51cto.com/files/uploadimg/20100506/1019431.jpg @ 2016-02-25 10:19:10
 [[~/Wally/Journal/Figure/.org-download/Journal/1019431_2016-02-25_10:19:10.jpg]]
虚拟化模型中的模拟过程

Linux中最流行的两个模拟器（emulator）包括QEMU和Bochs（处理器和平台模拟
器）。这种解决方案的优点是它们是非常“轻便的”，可以支持在不同的Host操
作系统和平台上运行不同的Guest操作系统。而这种解决方案的缺点在于由于要
模拟指令，导致效率比较低。QEMU通过动态编码转换的模拟方式，让内核和内部
用户代码可以被加速。另外，QEMU是一个很好的嵌入式平台开发工具，可以为与
主机相异的CPU开发和测试代码。QEMU还可以被用来其他虚拟化解决方案来进行
设备模拟。

**** 平台虚拟化

更加传统的虚拟化解决方案是平台虚拟化，或者叫做硬件虚拟化，具有两种主要
的形式，完全虚拟化（ full-virtualization）和半虚拟化
（para-virtualization）。

完全虚拟化，虚拟化平台通过hypervisor来承载虚拟机（VM），完全虚拟化的关
键在于这些虚拟机，也就是运行在这些虚拟机里面的操作系统可以在hypervisor
上运行，并且不被修改，这在需要一个真正的虚拟平台时是非常理想的，但这种
模式具有一个缺点。

在完全虚拟化下虚拟机VM会把虚拟平台当作物理平台，工作在虚拟平台上的
Guest操作系统驱动就好像运行在真实的硬件之上。但需要考虑这意味着什么，
Guest操作系统和虚拟平台之间通讯就好像和真实平台一样，在hypervisor里面
存在着另外一个模拟层，模拟硬件平台并转发虚拟机对硬件的访问，就好像虚拟
机直接在使用真实的硬件。这个过程需要大量的处理，会限制Guest系统的I/O性
能。

解决这个问题的一个方法就是让Guest操作系统意识到自身是被虚拟化的，这种
形式被称作半虚拟化（para-virtualization），如下图，在这种模式下，Guest
系统包含了缩短硬件访问过程所需的驱动程序，这让把Guest系统从不必要的工
作中解放出来，来进行更高级别的工作。


#+DOWNLOADED: http://images.51cto.com/files/uploadimg/20100506/1019432.jpg @ 2016-02-25 10:20:05
 [[~/Wally/Journal/Figure/.org-download/Journal/1019432_2016-02-25_10:20:05.jpg]]
两种平台虚拟化方式

虽然完全虚拟化是一个理想的方案，但是通过修改Guest操作系统可以最大限度
的减少处理开销，获得相当大的性能提升。

Linux包含两个重要的解决方案，可以同时实现完全虚拟化和半虚拟化。如
Citrix的Xen是一个流行的解决方案，可以同时执行Type1和Type2型hypervisor，
Amazon的EC2就采用Xen来进行服务器的虚拟化。

另一个重要的hypervisor是Linux Kernel Virtual Machine（KVM），同样都支
持本地虚拟化和主机虚拟化模型。KVM是有特点的，它通过夹在内核模块可以对
Linux内核进行小的修改，从而变成一个全特性的hypervisor。KVM通过应用
virtio可以支持半虚拟化，在Guest系统中包括用于半虚拟化的标准Linux驱动。

KVM也是第一个完全集成在主线内核（mainline kernel）的hypervisor，由Rad
Hat开发，在一些关键领域被采用，比如IBM对云计算的开发和测试中。

需要注意的是无论是完全虚拟化还是半虚拟化，每种解决方案都应用了硬件协助
虚拟化（hardware-assisted virtualization）。目前新的AMD和英特尔CPU都集
成了优化hypervisor的指令集，来增强Guest虚拟机的I/O性能。

**** 操作系统虚拟化

操作系统虚拟化是另外一个重要的虚拟化技术，正如其名，是对操作系统本身进
行虚拟化，而不是平台。在这种方式下，操作系统提供一组用户空间
（User-Space）彼此隔离，而应用被限制在每个用户空间里面，就好像一个独立
的主机。这种形式的虚拟化在虚拟主机环境中非常流行，让多个独立的用户可以
共享一个操作系统。


#+DOWNLOADED: http://images.51cto.com/files/uploadimg/20100506/1019433.jpg @ 2016-02-25 10:20:34
 [[~/Wally/Journal/Figure/.org-download/Journal/1019433_2016-02-25_10:20:34.jpg]]
操作系统虚拟化

操作系统虚拟化依赖于可以创建和隔离用户空间（或者叫做容器或者私有虚拟服
务器）的Linux内核，OS虚拟化最大的好处在于几乎没有任何开销，因为用户只
是简单的共享OS和主机，而不需要通过虚拟机。而缺点在于目前我们采用的OS虚
拟化解决方案缺乏灵活性，不能在任意的操作系统上实施，用户共享主机和操作
系统还需要注意版本。尽管有这些不足，服务器虚拟化还是应用的非常广泛。

Linux包含很多的操作系统解决方案，具有很高的可配置性。比如OpenVZ、
Linux-VServer和FreeVPS是其中三个最流行的，均支持CPU、内存网络、I/O和存
储配额配置，OpenVZ还支持主机之间的在线VPSes迁移。


**** 其他Linux虚拟化技术

在上面的文章中，我们讨论了模拟、平台虚拟化和操作系统虚拟化，这三种是最
常用的虚拟化技术，除此之外，还有很多其他种类的虚拟化技术可以满足我们的
需求，下面我们来看看几种不同于之前谈论范畴的虚拟化技术。

***** CoLinux

CoLinux，或者叫做协作Linux，是一种利用协作虚拟机的虚拟化方式。在
CoLinux模式下，Linux Guest系统运行在微软Windows操作系统之上，共享底层
的硬件资源。CoLinux需要Guest系统（即CoLinux本身）被修改，让它认为自己
运行在其他操作系统之上。CoLinux是一种半虚拟化的方式，是将Windows作为
Host操作系统，并且每个Host系统上只能运行一个CoLinux实例。由于这种限制，
CoLinux被定义为一种特别的虚拟化技术。


#+DOWNLOADED: http://images.51cto.com/files/uploadimg/20100506/1019434.jpg @ 2016-02-25 10:21:04
 [[~/Wally/Journal/Figure/.org-download/Journal/1019434_2016-02-25_10:21:04.jpg]]
CoLinux：特别的半虚拟化架构

***** 用户模式（User-Mode）Linux

用户模式（User-Mode）Linux，即UML，和CoLinux有些类似，但是更加灵活。如
上图右边的架构，UML允许在一个Linux Host系统上运行多个Linux Guest操作系
统，UML也是一种半虚拟化架构，实现更好的性能。UML吸引人的一个方面是可以
支持更高一层的UML，所以运行在Linux Host操作系统上的UML Guest内核可以支
持更高级别的UML Guest系统。

***** Wine和Cygwin

Wine和Cygwin也是有趣的虚拟化解决方案，Wine实际上是“Wine is Not an
Emulator”的缩写，表示“不是一个模拟器”，是在Linux Host操作系统上运行
Windows应用的一种方式。Wine并不是完全的表现为Windows应用的模拟层，而是
一个DLL（动态链接库）层来表示Windows API。


#+DOWNLOADED: http://images.51cto.com/files/uploadimg/20100506/1019435.jpg @ 2016-02-25 10:21:32
 [[~/Wally/Journal/Figure/.org-download/Journal/1019435_2016-02-25_10:21:32.jpg]]
Wine和Cygwin虚拟化方案

Cygwin是与之相反的解决方案，即在Windows上运行Linux应用，这是由Rat Hat
开发，这是一种模拟的Unix环境，允许在Windows平台上开发Unix应用，比如
POSIX以及其他类Unix工具。

**** Linux虚拟化的未来

在虚拟化领域，Linux虚拟化增长的很快速，不仅仅是对核心组件基于Linux的
hypervisor的开发，还包括Linux虚拟化生态系统中的其他部分，包括工具和管
理应用程序的开发。Linux虚拟化能够延伸出多种虚拟化技术，将不断的推动虚
拟化技术的前进发展。

** 驱动
*** [[http://blog.csdn.net/jianchi88/article/details/7212370][Linux设备驱动--块设备（一）之概念和框架]]                    :blog:block:

**** 基本概念

 *块设备（blockdevice）*

--- 是一种具有一定结构的*随机存取*设备，对这种设备的读写是按*块*进行的，他使用*缓冲*区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或者从设备一次性读到缓冲区。

*字符设备（Character device）*

---是一个*顺序的数据流*设备，对这种设备的读写是按*字符*进行的，而且这些字符是连续地形成一个数据流。他不具备缓冲区，所以对这种设备的读写*是实时的*。

*扇区(Sectors)* ：任何块设备硬件对数据处理的基本单位。通常，1个扇区的大小为512byte。（对设备而言）

*块(Blocks)* ：由Linux制定对内核或文件系统等数据处理的基本单位。通常，1个块由1个或多个扇区组成。（对Linux操作系统而言）

*段(Segments)* ：由若干个相邻的块组成。是Linux内存管理机制中一个内存页或者内存页的一部分。

页、段、块、扇区之间的关系图如下：

#+DOWNLOADED: http://hi.csdn.net/attachment/201201/20/0_13270444482t2H.gif @ 2016-01-26 21:24:55
 [[~/Wally/Journal/Figure/.org-download/Tasks/0_13270444482t2H_2016-01-26_21:24:54.gif]]



**** *块设备驱动整体框架*

#+DOWNLOADED: http://hi.csdn.net/attachment/201201/20/0_1327044749MMUm.gif @ 2016-01-26 21:25:00
 [[~/Wally/Journal/Figure/.org-download/Tasks/0_1327044749MMUm_2016-01-26_21:25:00.gif]]

块设备的应用在Linux中是一个完整的子系统。

在Linux中，驱动对块设备的输入或输出(I/O)操作，都会向块设备发出一个请求，在驱动中用*request结构体*描述。但对于一些磁盘设备而言请求的速度很慢，这时候内核就提供一种队列的机制把这些*I/O请求*添加到队列中（即：请求队列），在驱动中用*request_queue结构体*描述。在向块设备提交这些请求前内核会先执行请求的合并和排序预操作，以提高访问的效率，然后再由内核中的*I/O调度程序子系统*来负责提交
I/O 请求，
调度程序将磁盘资源分配给系统中所有挂起的块 I/O 请求，其工作是管理块设备的请求队列，*决定队列中的请求的排列顺序以及什么时候派发请求到设备*。

由通用块层(Generic Block
Layer)负责维持一个I/O请求在上层文件系统与底层物理磁盘之间的关系。在通用块层中，*通常用一个bio结构体来对应一个I/O请求*。

Linux提供了一个*gendisk数据结构体*，用来表示一个独立的磁盘设备或分区，用于对底层物理磁盘进行访问。在gendisk中有一个类似字符设备中file_operations的硬件操作结构指针，是*block_device_operations结构体*。

当多个请求提交给块设备时，执行效率依赖于请求的顺序。如果所有的请求是同一个方向（如：写数据），执行效率是最大的。内核在调用块设备驱动程序例程处理请求之前，先收集I/O请求并将请求排序，然后，*将连续扇区操作的多个请求进行合并以提高执行效率（内核算法会自己做，不用你管）*，对I/O请求排序的算法称为*电梯算法*（elevator
algorithm）。电梯算法在I/O调度层完成。内核提供了不同类型的电梯算法，电梯算法有

1 noop（实现简单的FIFO，基本的直接合并与排序）,
2 anticipatory（延迟I/O请求，进行临界区的优化排序），
3 Deadline（针对anticipatory缺点进行改善，降低延迟时间）,
4 Cfq（均匀分配I/O带宽，公平机制）

PS：其实IO调度层（包括请求合并排序算法）是不需要用户管的，内核已经做好

**** *相关数据结构*

block_device:  描述一个分区或整个磁盘对内核的一个块设备实例
gendisk:   描述一个通用硬盘（generic hard disk）对象。
hd_struct:  描述分区应有的分区信息
bio: 描述块数据传送时怎样完成填充或读取块给driver
request:  描述向内核请求一个列表准备做队列处理。
request_queue:  描述内核申请request资源建立请求链表并填写BIO形成队列。

* shell                                                               :SHELL:
** 系统管理

*** 进程和作业管理
**** ps                                                               :ps:

***** ps

1. 功能： *process status*, 列出当前进程的快照，即执行ps命令的那个时刻
   的进程。
   + 静态，如果想要动态显示进程，则需使用 *top* 命令

2. linux进程状态
   + 运行 r(runnable)
   + 中断 s(sleeping)
   + 不可中断 d(uninterruptible sleep)
   + 僵死 z(defunct)
   + 停止t(stopped)

3. 格式: ps [参数]

4. 参数
   + a 显示所有进程
   + -a 显示同一终端下的所有进程
   + -a 显示所有进程
   + c 显示进程真实名称
   + -n 反向选择
   + -e 同-a
   + e 显示环境变量
   + f 显示程序之间的关系
   + -h 显示树状结构
   + r 显示当前终端进程
   + t 显示当前终端的所有程序
   + u 指定用户的所有进程
   + -au 详细

   #+header: :exports both
   #+header: :results output
   #+begin_src sh
   ps -ef | grep emacs
   #+end_src

   #+results:
   : ben       3662  2842  1 13:20 pts/0    00:01:33 emacs
   : ben       3889  3662  0 13:20 pts/4    00:00:00 bash /home/ben/.ckws/install/share/emacs/site-lisp/poll-rostopic 8
   : ben       3893  3662  0 13:20 pts/15   00:00:00 bash /home/ben/.ckws/install/share/emacs/site-lisp/poll-rosnode 8
   : ben       4614  3662  0 13:21 ?        00:00:08 /home/ben/.emacs.d/elpa/pdf-tools-20150401.1031/epdfinfo
   : ben      11322 11320  0 15:20 ?        00:00:00 grep emacs

***** ps命令

来自: http://man.linuxde.net/ps

*ps命令* 用于报告当前系统的进程状态。可以搭配[[http://man.linuxde.net/kill][ kill ]]指令随时中断、删除
不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令
可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、
哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到
的。

****** 语法

#+BEGIN_EXAMPLE
    ps(选项)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -a：显示所有终端机下执行的程序，除了阶段作业领导者之外。
    a：显示现行终端机下的所有程序，包括其他用户的程序。
    -A：显示所有程序。
    -c：显示CLS和PRI栏位。
    c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。
    -C<指令名称>：指定执行指令的名称，并列出该指令的程序的状况。
    -d：显示所有程序，但不包括阶段作业领导者的程序。
    -e：此选项的效果和指定"A"选项相同。
    e：列出程序时，显示每个程序所使用的环境变量。
    -f：显示UID,PPIP,C与STIME栏位。
    f：用ASCII字符显示树状结构，表达程序间的相互关系。
    -g<群组名称>：此选项的效果和指定"-G"选项相同，当亦能使用阶段作业领导者的名称来指定。
    g：显示现行终端机下的所有程序，包括群组领导者的程序。
    -G<群组识别码>：列出属于该群组的程序的状况，也可使用群组名称来指定。
    h：不显示标题列。
    -H：显示树状结构，表示程序间的相互关系。
    -j或j：采用工作控制的格式显示程序状况。
    -l或l：采用详细的格式来显示程序状况。
    L：列出栏位的相关信息。
    -m或m：显示所有的执行绪。
    n：以数字来表示USER和WCHAN栏位。
    -N：显示所有的程序，除了执行ps指令终端机下的程序之外。
    -p<程序识别码>：指定程序识别码，并列出该程序的状况。
    p<程序识别码>：此选项的效果和指定"-p"选项相同，只在列表格式方面稍有差异。
    r：只列出现行终端机正在执行中的程序。
    -s<阶段作业>：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。
    s：采用程序信号的格式显示程序状况。
    S：列出程序时，包括已中断的子程序资料。
    -t<终端机编号>：指定终端机编号，并列出属于该终端机的程序的状况。
    t<终端机编号>：此选项的效果和指定"-t"选项相同，只在列表格式方面稍有差异。
    -T：显示现行终端机下的所有程序。
    -u<用户识别码>：此选项的效果和指定"-U"选项相同。
    u：以用户为主的格式来显示程序状况。
    -U<用户识别码>：列出属于该用户的程序的状况，也可使用用户名称来指定。
    U<用户名称>：列出属于该用户的程序的状况。
    v：采用虚拟内存的格式显示程序状况。
    -V或V：显示版本信息。
    -w或w：采用宽阔的格式来显示程序状况。　
    x：显示所有程序，不以终端机来区分。
    X：采用旧式的Linux i386登陆格式显示程序状况。
    -y：配合选项"-l"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。
    -<程序识别码>：此选项的效果和指定"p"选项相同。
    --cols<每列字符数>：设置每列的最大字符数。
    --columns<每列字符数>：此选项的效果和指定"--cols"选项相同。
    --cumulative：此选项的效果和指定"S"选项相同。
    --deselect：此选项的效果和指定"-N"选项相同。
    --forest：此选项的效果和指定"f"选项相同。
    --headers：重复显示标题列。
    --help：在线帮助。
    --info：显示排错信息。
    --lines<显示列数>：设置显示画面的列数。
    --no-headers：此选项的效果和指定"h"选项相同，只在列表格式方面稍有差异。
    --group<群组名称>：此选项的效果和指定"-G"选项相同。
    --Group<群组识别码>：此选项的效果和指定"-G"选项相同。
    --pid<程序识别码>：此选项的效果和指定"-p"选项相同。
    --rows<显示列数>：此选项的效果和指定"--lines"选项相同。
    --sid<阶段作业>：此选项的效果和指定"-s"选项相同。
    --tty<终端机编号>：此选项的效果和指定"-t"选项相同。
    --user<用户名称>：此选项的效果和指定"-U"选项相同。
    --User<用户识别码>：此选项的效果和指定"-U"选项相同。
    --version：此选项的效果和指定"-V"选项相同。
    --widty<每列字符数>：此选项的效果和指定"-cols"选项相同。
#+END_EXAMPLE

由于ps命令能够支持的系统类型相当的多，所以选项多的离谱！

**** crontab                                                     :crontab:
***** crontab : 周期性任务                                         :blog:

通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell
script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。
这个命令非常适合周期性的日志分析或数据备份等工作。

****** 命令格式

#+BEGIN_EXAMPLE
crontab [-u user] [ -e | -l | -r ]
#+END_EXAMPLE

****** 命令参数

- -u user :: 用来设定某个用户的crontab服务；

- file :: file是命令文件的名字,表示将file做为crontab的任务列表文件并载
     入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准
     输入（键盘）上键入的命令，并将它们载入crontab。

- -e :: 编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前
     用户的crontab文件。

- -l :: 显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前
     用户的crontab文件内容。

- -r :: 从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用
     户，则默认删除当前用户的crontab文件。

- -i :: 在删除用户的crontab文件时给确认提示。

****** crontab的文件格式

#+BEGIN_EXAMPLE
分 时 日 月 星期 要运行的命令
#+END_EXAMPLE

- 第1列分钟1～59
- 第2列小时1～23（0表示子夜）
- 第3列日1～31
- 第4列月1～12
- 第5列星期0～6（0表示星期天）
- 第6列要运行的命令

****** 常用方法

******* 创建一个新的crontab文件

向cron进程提交一个crontab文件之前，首先要设置环境变量EDITOR。cron进程
根据它来确定使用哪个编辑器编辑crontab文件。99 %的UNIX和LINUX用户都使用
vi，如果你也是这样，那么你就编辑$HOME目录下的.profile文件，在其中加入
这样一行:

#+BEGIN_EXAMPLE
    EDITOR=vi; export EDITOR
#+END_EXAMPLE

然后保存并退出。不妨创建一个名为 <user>cron的文件，其中<user>是用户名，
例如，davecron。在该文件中加入如下的内容。

#+BEGIN_EXAMPLE
    # (put your own initials here)echo the date to the console every
    # 15minutes between 6pm and 6am
    0,15,30,45 18-06 * * * /bin/echo 'date' > /dev/console
#+END_EXAMPLE

保存并退出。注意前面5个域用空格分隔。

在上面的例子中，系统将每隔15分钟向控制台输出一次当前时间。如果系统崩溃
或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有
些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修
改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命
令的参数:

#+BEGIN_EXAMPLE
    $ crontab davecron
#+END_EXAMPLE

现在该文件已经提交给cron进程，它将每隔15分钟运行一次。同时，新创建文件
的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。

******* 列出crontab文件

使用-l参数列出crontab文件:

#+BEGIN_EXAMPLE
    $ crontab -l
    0,15,30,45,18-06 * * * /bin/echo `date` > dev/tty1
#+END_EXAMPLE

可以使用这种方法在$HOME目录中对crontab文件做一备份:

#+BEGIN_EXAMPLE
    $ crontab -l > $HOME/mycron
#+END_EXAMPLE

这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。

******* 编辑crontab文件

如果希望添加、删除或编辑crontab文件中的条目，而EDITOR环境变量又设置为
vi，那么就可以用vi来编辑crontab文件:

#+BEGIN_EXAMPLE
    $ crontab -e
#+END_EXAMPLE

可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些
条目或添加了新的条目，那么在保存该文件时，cron会对其进行必要的完整性检
查。如果其中的某个域出现了超出允许范围的值，它会提示你。

我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：

#+BEGIN_EXAMPLE
    # DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month
    30 3 1,7,14,21,26 * * /bin/find -name 'core' -exec rm {} \;
#+END_EXAMPLE

保存并退出。

注解

最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、
运行时间，更为重要的是，知道这是哪位用户的定时作业。

******* 删除crontab文件

#+BEGIN_EXAMPLE
    $crontab -r
#+END_EXAMPLE

****** 使用实例                                                :example:

******* 实例1：每1分钟执行一次myCommand

#+BEGIN_EXAMPLE
    * * * * * myCommand
#+END_EXAMPLE

******* 实例2：每小时的第3和第15分钟执行

#+BEGIN_EXAMPLE
    3,15 * * * * myCommand
#+END_EXAMPLE

******* 实例3：在上午8点到11点的第3和第15分钟执行

#+BEGIN_EXAMPLE
    3,15 8-11 * * * myCommand
#+END_EXAMPLE

******* 实例4：每隔两天的上午8点到11点的第3和第15分钟执行

#+BEGIN_EXAMPLE
    3,15 8-11 */2  *  * myCommand
#+END_EXAMPLE

******* 实例5：每周一上午8点到11点的第3和第15分钟执行

#+BEGIN_EXAMPLE
    3,15 8-11 * * 1 myCommand
#+END_EXAMPLE

******* 实例6：每晚的21:30重启smb

#+BEGIN_EXAMPLE
    30 21 * * * /etc/init.d/smb restart
#+END_EXAMPLE

******* 实例7：每月1、10、22日的4 : 45重启smb

#+BEGIN_EXAMPLE
    45 4 1,10,22 * * /etc/init.d/smb restart
#+END_EXAMPLE

******* 实例8：每周六、周日的1 : 10重启smb

#+BEGIN_EXAMPLE
    10 1 * * 6,0 /etc/init.d/smb restart
#+END_EXAMPLE

******* 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb

#+BEGIN_EXAMPLE
    0,30 18-23 * * * /etc/init.d/smb restart
#+END_EXAMPLE

******* 实例10：每星期六的晚上11 : 00 pm重启smb

#+BEGIN_EXAMPLE
    0 23 * * 6 /etc/init.d/smb restart
#+END_EXAMPLE

******* 实例11：每一小时重启smb

#+BEGIN_EXAMPLE
    * */1 * * * /etc/init.d/smb restart
#+END_EXAMPLE

******* 实例12：晚上11点到早上7点之间，每隔一小时重启smb

#+BEGIN_EXAMPLE
    * 23-7/1 * * * /etc/init.d/smb restart
#+END_EXAMPLE

****** 使用注意事项                                               :note:

******* 注意环境变量问题

有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。

在crontab文件中定义多个调度任务时，需要特别注环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。

不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：

1. 脚本中涉及文件路径时写全局路径；

2. 脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如:

   #+BEGIN_EXAMPLE
       cat start_cbp.sh
       !/bin/sh
       source /etc/profile
       export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf
       /usr/local/jboss-4.0.5/bin/run.sh -c mev &
   #+END_EXAMPLE

3）当手动执行脚本OK，但是crontab死活不执行时,很可能是环境变量惹的祸，可尝试在crontab中直接引入环境变量解决问题。如:

#+BEGIN_EXAMPLE
    0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh
#+END_EXAMPLE

******* 注意清理系统用户的邮件日志

每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。
例如，可以在crontab文件中设置如下形式，忽略日志输出:

#+BEGIN_EXAMPLE
    0 */3 * * * /usr/local/apache2/apachectl restart >/dev/null 2>&1
#+END_EXAMPLE

“/dev/null
2>&1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。

******* 系统级任务调度与用户级任务调度

系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过”crontab
--uroot
--e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。

******* 其他注意事项

新创建的cron
job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。

当crontab失效时，可以尝试/etc/init.d/crond
restart解决问题。或者查看日志看某个job有没有执行/报错tail -f
/var/log/cron。

千万别乱运行crontab
-r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。

在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date
‘+%Y%m%d'在crontab里是不会执行的，应该换成date ‘+%Y%m%d'。

更新系统时间时区后需要重启cron,在ubuntu中服务名为cron:

#+BEGIN_EXAMPLE
    $service cron restart
#+END_EXAMPLE

ubuntu下启动、停止与重启cron:

#+BEGIN_EXAMPLE
    $sudo /etc/init.d/cron start
    $sudo /etc/init.d/cron stop
    $sudo /etc/init.d/cron restart
#+END_EXAMPLE

***** crontab命令

来自: http://man.linuxde.net/crontab

*crontab命令* 被用来提交和管理用户的需要周期性执行的任务，与windows下
的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动
启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执
行的任务，则自动执行该任务。

****** 语法\\

#+BEGIN_EXAMPLE
    crontab(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -e：编辑该用户的计时器设置；
    -l：列出该用户的计时器设置；
    -r：删除该用户的计时器设置；
    -u<用户名称>：指定要设定计时器的用户名称。
#+END_EXAMPLE

****** 参数\\

crontab文件：指定包含待执行任务的crontab文件。

****** 知识扩展\\

Linux下的任务调度分为两类：*系统任务调度*和*用户任务调度*。

*系统任务调度：*系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在=/etc=目录下有一个crontab文件，这个就是系统任务调度的配置文件。

=/etc/crontab=文件包括下面几行：

#+BEGIN_EXAMPLE
    SHELL=/bin/bash
    PATH=/sbin:/bin:/usr/sbin:/usr/bin
    MAILTO=""HOME=/

    # run-parts
    51 * * * * root run-parts /etc/cron.hourly
    24 7 * * * root run-parts /etc/cron.daily
    22 4 * * 0 root run-parts /etc/cron.weekly
    42 4 1 * * root run-parts /etc/cron.monthly
#+END_EXAMPLE

前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。

*用户任务调度：*用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab文件都被保存在=/var/spool/cron=目录中。其文件名与用户名一致，使用者权限文件如下：

#+BEGIN_EXAMPLE
    /etc/cron.deny     该文件中所列用户不允许使用crontab命令
    /etc/cron.allow    该文件中所列用户允许使用crontab命令
    /var/spool/cron/   所有用户crontab文件存放的目录,以用户名命名
#+END_EXAMPLE

crontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：

#+BEGIN_EXAMPLE
    minute   hour   day   month   week   command     顺序：分 时 日 月 周
#+END_EXAMPLE

其中：

-  minute： 表示分钟，可以是从0到59之间的任何整数。
-  hour：表示小时，可以是从0到23之间的任何整数。
-  day：表示日期，可以是从1到31之间的任何整数。
-  month：表示月份，可以是从1到12之间的任何整数。
-  week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。
-  command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。

在以上各个字段中，还可以使用以下特殊字符：

-  星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。
-  逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”
-  中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”
-  正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。

*crond服务*

#+BEGIN_EXAMPLE
    /sbin/service crond start    //启动服务
    /sbin/service crond stop     //关闭服务
    /sbin/service crond restart  //重启服务
    /sbin/service crond reload   //重新载入配置
#+END_EXAMPLE

查看crontab服务状态：

#+BEGIN_EXAMPLE
    service crond status
#+END_EXAMPLE

手动启动crontab服务：

#+BEGIN_EXAMPLE
    service crond start
#+END_EXAMPLE

查看crontab服务是否已设置为开机启动，执行命令：

#+BEGIN_EXAMPLE
    ntsysv
#+END_EXAMPLE

加入开机自动启动：

#+BEGIN_EXAMPLE
    chkconfig –level 35 crond on
#+END_EXAMPLE

****** 实例\\

每1分钟执行一次command

#+BEGIN_EXAMPLE
    * * * * * command
#+END_EXAMPLE

每小时的第3和第15分钟执行

#+BEGIN_EXAMPLE
    3,15 * * * * command
#+END_EXAMPLE

在上午8点到11点的第3和第15分钟执行

#+BEGIN_EXAMPLE
    3,15 8-11 * * * command
#+END_EXAMPLE

每隔两天的上午8点到11点的第3和第15分钟执行

#+BEGIN_EXAMPLE
    3,15 8-11 */2 * * command
#+END_EXAMPLE

每个星期一的上午8点到11点的第3和第15分钟执行

#+BEGIN_EXAMPLE
    3,15 8-11 * * 1 command
#+END_EXAMPLE

每晚的21:30重启smb 

#+BEGIN_EXAMPLE
    30 21 * * * /etc/init.d/smb restart
#+END_EXAMPLE

每月1、10、22日的4 : 45重启smb 

#+BEGIN_EXAMPLE
    45 4 1,10,22 * * /etc/init.d/smb restart
#+END_EXAMPLE

每周六、周日的1:10重启smb

#+BEGIN_EXAMPLE
    10 1 * * 6,0 /etc/init.d/smb restart
#+END_EXAMPLE

每天18 : 00至23 : 00之间每隔30分钟重启smb 

#+BEGIN_EXAMPLE
    0,30 18-23 * * * /etc/init.d/smb restart
#+END_EXAMPLE

每星期六的晚上11:00 pm重启smb 

#+BEGIN_EXAMPLE
    0 23 * * 6 /etc/init.d/smb restart
#+END_EXAMPLE

每一小时重启smb 

#+BEGIN_EXAMPLE
    * */1 * * * /etc/init.d/smb restart
#+END_EXAMPLE

晚上11点到早上7点之间，每隔一小时重启smb

#+BEGIN_EXAMPLE
    * 23-7/1 * * * /etc/init.d/smb restart
#+END_EXAMPLE

每月的4号与每周一到周三的11点重启smb 

#+BEGIN_EXAMPLE
    0 11 4 * mon-wed /etc/init.d/smb restart
#+END_EXAMPLE

一月一号的4点重启smb

#+BEGIN_EXAMPLE
    0 4 1 jan * /etc/init.d/smb restart
#+END_EXAMPLE

每小时执行=/etc/cron.hourly=目录内的脚本

#+BEGIN_EXAMPLE
    01 * * * * root run-parts /etc/cron.hourly
#+END_EXAMPLE

*** 系统安全

*** 用户和工作组管理
**** passwd                                                       :passwd:
***** sudo passwd root                                      :passwd:root:

可以使用passwd命令来修改用户的密码。passwd命令用于对用户的密码进行管理，
可以设置、修改、删除密码。

用法示例：
修改root用户的密码

#+BEGIN_EXAMPLE
$ sudo passwd root
#+END_EXAMPLE

密码会要求重复输入一次。
***** passwd命令

来自: http://man.linuxde.net/passwd

*passwd命令* 用于设置用户的认证信息，包括用户密码、密码过期时间等。系
统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用
户只能变更自己的密码。

****** 语法\\

#+BEGIN_EXAMPLE
    passwd(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -d：删除密码，仅有系统管理者才能使用；
    -f：强制执行；
    -k：设置只有在密码过期失效后，方能更新；
    -l：锁住密码；
    -s：列出密码的相关信息，仅有系统管理者才能使用；
    -u：解开已上锁的帐号。
#+END_EXAMPLE

****** 参数\\

用户名：需要设置密码的用户名。

****** 知识扩展\\

与用户、组账户信息相关的文件

存放用户信息：

#+BEGIN_EXAMPLE
    /etc/passwd
    /etc/shadow
#+END_EXAMPLE

存放组信息：

#+BEGIN_EXAMPLE
    /etc/group
    /etc/gshadow
#+END_EXAMPLE

用户信息文件分析（每项用=:=隔开）

#+BEGIN_EXAMPLE
    例如：jack:X:503:504:::/home/jack/:/bin/bash
    jack　　//用户名
    X　　//口令、密码
    503　　//用户id（0代表root、普通新建用户从500开始）
    504　　//所在组
    :　　//描述
    /home/jack/　　//用户主目录
    /bin/bash　　//用户缺省Shell
#+END_EXAMPLE

组信息文件分析

#+BEGIN_EXAMPLE
    例如：jack:$!$:???:13801:0:99999:7:*:*:
    jack　　//组名
    $!$　　//被加密的口令
    13801　　//创建日期与今天相隔的天数
    0　　//口令最短位数
    99999　　//用户口令
    7　　//到7天时提醒
    *　　//禁用天数
    *　　//过期天数
#+END_EXAMPLE

****** 实例\\

如果是普通用户执行passwd只能修改自己的密码。如果新建用户后，要为新用户创建密码，则用passwd用户名，注意要以root用户的权限来创建。

#+BEGIN_EXAMPLE
    [root@localhost ~]# passwd linuxde    //更改或创建linuxde用户的密码；
    Changing password for user linuxde.
    New UNIX password:          //请输入新密码；
    Retype new UNIX password:   //再输入一次；
    passwd: all authentication tokens updated successfully. //成功；
#+END_EXAMPLE

普通用户如果想更改自己的密码，直接运行passwd即可，比如当前操作的用户是linuxde。

#+BEGIN_EXAMPLE
    [linuxde@localhost ~]$ passwd
    Changing password for user linuxde. //更改linuxde用户的密码；
    (current) UNIX password:   //请输入当前密码；
    New UNIX password:         //请输入新密码；
    Retype new UNIX password:  //确认新密码；
    passwd: all authentication tokens updated successfully. //更改成功；
#+END_EXAMPLE

比如我们让某个用户不能修改密码，可以用=-l=选项来锁定：

#+BEGIN_EXAMPLE
    [root@localhost ~]# passwd -l linuxde    //锁定用户linuxde不能更改密码；
    Locking password for user linuxde.
    passwd: Success           //锁定成功；

    [linuxde@localhost ~]# su linuxde   //通过su切换到linuxde用户；
    [linuxde@localhost ~]$ passwd      //linuxde来更改密码；
    Changing password for user linuxde.
    Changing password for linuxde
    (current) UNIX password:          //输入linuxde的当前密码；
    passwd: Authentication token manipulation error     //失败，不能更改密码；
#+END_EXAMPLE

再来一例：

#+BEGIN_EXAMPLE
    [root@localhost ~]# passwd -d linuxde  //清除linuxde用户密码；
    Removing password for user linuxde.
    passwd: Success                         //清除成功；

    [root@localhost ~]# passwd -S linuxde    //查询linuxde用户密码状态；
    Empty password.                         //空密码，也就是没有密码；
#+END_EXAMPLE

注意：当我们清除一个用户的密码时，登录时就无需密码，这一点要加以注意。

*** X-Windows

*** SELinux

*** 文件系统管理

*** 系统关机和重启
**** shutdown                                                   :shutdown:

***** shutdown

+ 关机或重启
+ 语法: shutdown [选项] [时间] [警告信息]
+ 选项
  +  -k    不真正关机，而是发出警告信息
  +  -r    关机后立即重启
  +  -h    关机后不重启
  +  -c    取消一个已经运行的shutdown
+ 说明:   关机命令需要root权限
+ halt    # showdown -h
+ reboot  # 重启

***** shutdown命令

来自: http://man.linuxde.net/shutdown

*shutdown命令* 用来系统关机命令。shutdown指令可以关闭所有程序，并依用
户的需要，进行重新开机或关机的动作。

****** 语法

#+BEGIN_EXAMPLE
    shutdown(选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -c：当执行“shutdown -h 11:50”指令时，只要按+键就可以中断关机的指令；
    -f：重新启动时不执行fsck；
    -F：重新启动时执行fsck；
    -h：将系统关机；
    -k：只是送出信息给所有用户，但不会实际关机；
    -n：不调用init程序进行关机，而由shutdown自己进行；
    -r：shutdown之后重新启动；
    -t<秒数>：送出警告信息和删除信息之间要延迟多少秒。
#+END_EXAMPLE

****** 参数

-  [时间]：设置多久时间后执行shutdown指令；
-  [警告信息]：要传送给所有登入用户的信息。

****** 实例

指定现在立即关机：

#+BEGIN_EXAMPLE
    shutdown -h now
#+END_EXAMPLE

指定5分钟后关机，同时送出警告信息给登入用户：

#+BEGIN_EXAMPLE
    shutdown +5 "System will shutdown after 5 minutes"
#+END_EXAMPLE

*** 内核和模块管理
**** uname                                                         :uname:

***** uname命令

http://man.linuxde.net/uname

*uname命令* 用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和
操作系统类型等）。

****** 语法

#+BEGIN_EXAMPLE
    uname(选项)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -a或--all：显示全部的信息；
    -m或--machine：显示电脑类型；
    -n或-nodename：显示在网络上的主机名称；
    -r或--release：显示操作系统的发行编号；
    -s或--sysname：显示操作系统名称；
    -v：显示操作系统的版本；
    --help：显示帮助；
    --version：显示版本信息。
#+END_EXAMPLE

****** 实例

使用uname命令查看全部信息：

#+BEGIN_EXAMPLE
    [root@localhost ~]# uname    #单独使用uname命令时相当于uname -s
    Linux

    [root@localhost ~]# uname -a
    Linux localhost 2.6.18-348.6.1.el5 #1 SMP Tue May 21 15:34:22 EDT 2013 i686 i686 i386 GNU/Linux

    [root@localhost ~]# uname -m
    i686

    [root@localhost ~]# uname -n
    localhost

    [root@localhost ~]# uname -r
    2.6.18-4-686

    [root@localhost ~]# uname -s
    Linux

    [root@localhost ~]# uname -v
    #1 SMP Tue May 21 15:34:22 EDT 2013

    [root@localhost ~]# uname -p
    i686

    [root@localhost ~]# uname -i
    i386

    [root@localhost ~]# uname -o
    GNU/Linux

    [root@localhost ~]# uname --version
    uname (GNU coreutils) 5.97
    Copyright (C) 2006 free Software Foundation, Inc.
    这是自由软件。您可以按照 GNU GPL 协议 <http://www.gnu.org/licenses/gpl.html> 的条款再发布此软件的副本，但我们无法保证相关法律不对这一情形进行限制。

    由 David MacKenzie 编写。
#+END_EXAMPLE

最近更新的命令

-  [[http://man.linuxde.net/lsb_release][lsb_release]]
-  [[http://man.linuxde.net/tcpreplay][tcpreplay]]
-  [[http://man.linuxde.net/strings][strings]]
-  [[http://man.linuxde.net/screen][screen]]
-  [[http://man.linuxde.net/speedtest-cli][speedtest-cli]]
-  [[http://man.linuxde.net/clockdiff][clockdiff]]
-  [[http://man.linuxde.net/ntpdate][ntpdate]]
-  [[http://man.linuxde.net/dnf][dnf]]
-  [[http://man.linuxde.net/nethogs][nethogs]]
-  [[http://man.linuxde.net/hping3][hping3]]
-  [[http://man.linuxde.net/trap][trap]]
-  [[http://man.linuxde.net/let][let]]
-  [[http://man.linuxde.net/ifstat][ifstat]]
-  [[http://man.linuxde.net/blkid][blkid]]
-  [[http://man.linuxde.net/ipcrm][ipcrm]]
-  [[http://man.linuxde.net/openssl][openssl]]
-  [[http://man.linuxde.net/chage][chage]]
-  [[http://man.linuxde.net/dstat][dstat]]
-  [[http://man.linuxde.net/cut][cut]]
-  [[http://man.linuxde.net/ssh-copy-id][ssh-copy-id]]
-  [[http://man.linuxde.net/ssh-agent][ssh-agent]]
-  [[http://man.linuxde.net/ssh-add][ssh-add]]
-  [[http://man.linuxde.net/hexdump][hexdump]]
-  [[http://man.linuxde.net/systemctl][systemctl]]
-  [[http://man.linuxde.net/pfctl][pfctl]]
-  [[http://man.linuxde.net/jwhois][jwhois]]
-  [[http://man.linuxde.net/du][du]]
-  [[http://man.linuxde.net/tar][tar]]
-  [[http://man.linuxde.net/iconv][iconv]]
-  [[http://man.linuxde.net/xclip][xclip]]

****** 相关命令

-  [[http://man.linuxde.net/insmod][insmod]]
-  [[http://man.linuxde.net/get_module][get_module]]
-  [[http://man.linuxde.net/sysctl][sysctl]]
-  [[http://man.linuxde.net/kexec][kexec]]
-  [[http://man.linuxde.net/modprobe][modprobe]]
-  [[http://man.linuxde.net/lsmod][lsmod]]
-  [[http://man.linuxde.net/slabtop][slabtop]]
-  [[http://man.linuxde.net/rmmod][rmmod]]
-  [[http://man.linuxde.net/lsb_release][lsb_release]]
-  [[http://man.linuxde.net/depmod][depmod]]
-  [[http://man.linuxde.net/kernelversion][kernelversion]]
-  [[http://man.linuxde.net/bmodinfo][bmodinfo]]
-  [[http://man.linuxde.net/dmesg][dmesg]]

.

***** help                                                         :help:

#+BEGIN_EXAMPLE
用法：uname [选项]...
输出一组系统信息。如果不跟随选项，则视为只附加-s 选项。

  -a, --all			以如下次序输出所有信息。其中若-p 和
				-i 的探测结果不可知则被省略：
  -s, --kernel-name		输出内核名称
  -n, --nodename		输出网络节点上的主机名
  -r, --kernel-release		输出内核发行号
  -v, --kernel-version		输出内核版本
  -m, --machine		输出主机的硬件架构名称
  -p, --processor		输出处理器类型或"unknown"
  -i, --hardware-platform	输出硬件平台或"unknown"
  -o, --operating-system	输出操作系统名称
      --help		显示此帮助信息并退出
      --version		显示版本信息并退出
#+END_EXAMPLE

***** uname命令

来自: http://man.linuxde.net/uname

*uname命令* 用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和
操作系统类型等）。

****** 语法\\

#+BEGIN_EXAMPLE
    uname(选项)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -a或--all：显示全部的信息；
    -m或--machine：显示电脑类型；
    -n或-nodename：显示在网络上的主机名称；
    -r或--release：显示操作系统的发行编号；
    -s或--sysname：显示操作系统名称；
    -v：显示操作系统的版本；
    --help：显示帮助；
    --version：显示版本信息。
#+END_EXAMPLE

****** 实例\\

使用uname命令查看全部信息：

#+BEGIN_EXAMPLE
    [root@localhost ~]# uname    #单独使用uname命令时相当于uname -s
    Linux

    [root@localhost ~]# uname -a
    Linux localhost 2.6.18-348.6.1.el5 #1 SMP Tue May 21 15:34:22 EDT 2013 i686 i686 i386 GNU/Linux

    [root@localhost ~]# uname -m
    i686

    [root@localhost ~]# uname -n
    localhost

    [root@localhost ~]# uname -r
    2.6.18-4-686

    [root@localhost ~]# uname -s
    Linux

    [root@localhost ~]# uname -v
    #1 SMP Tue May 21 15:34:22 EDT 2013

    [root@localhost ~]# uname -p
    i686

    [root@localhost ~]# uname -i
    i386

    [root@localhost ~]# uname -o
    GNU/Linux

    [root@localhost ~]# uname --version
    uname (GNU coreutils) 5.97
    Copyright (C) 2006 free Software Foundation, Inc.
    这是自由软件。您可以按照 GNU GPL 协议 <http://www.gnu.org/licenses/gpl.html> 的条款再发布此软件的副本，但我们无法保证相关法律不对这一情形进行限制。

    由 David MacKenzie 编写。
#+END_EXAMPLE

** 网络管理

*** 高级网络

*** 网络测试

*** 网络安全

*** 网络应用
**** wget                                                           :wget:
***** [[http://lanbing510.info/2015/12/01/Arm-Environment-Problems.html][使用 wget 下载整个网站]]                            :trick:blog_冰蓝:

发现一个Linux Shell命令总结的很不错的小[[http://www.lampweb.org/linux/][网站]]， 于是用Wget做了本地备份，
方便离线查看。

#+BEGIN_EXAMPLE
  wget --recursive --no-clobber --page-requisites --html-extension
  --convert-links --restrict-file-names=windows
  --domains lampweb.org --no-parent www.lampweb.org/linux/
#+END_EXAMPLE

命令解释：

+ --recursive 递归下载整个站点

+ --no-clobber 不要覆盖已有文件(以防下载被中断而重新开始)

+ --domains lampweb.org 不要下载lampweb.org以外的链接地址

+ --no-parent 不要下载org/linux/目录之外的内容  (*注意最后的正斜杠*)

+ --page-requisites 下载所有页面需要的元素(图像、CSS等等)

+ --html-extention 只下载html相关的文件

+ --convert-links 转换链接地址，从而本地离线可以正常访问

+ --restrict-file-names=windows 修改文件名以使文件也可以在windows下访
  问(某些情况文件名在Linux下合法而在windows下非法)。

***** wget命令

来自: http://man.linuxde.net/wget

*wget命令* 用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下
和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断
的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服
务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文
件非常有用。

****** 语法\\

#+BEGIN_EXAMPLE
    wget(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -a<日志文件>：在指定的日志文件中记录资料的执行过程；
    -A<后缀名>：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；
    -b：进行后台的方式运行wget；
    -B<连接地址>：设置参考的连接地址的基地地址；
    -c：继续执行上次终端的任务；
    -C<标志>：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；
    -d：调试模式运行指令；
    -D<域名列表>：设置顺着的域名列表，域名之间用“，”分隔；
    -e<指令>：作为文件“.wgetrc”中的一部分执行指定的指令；
    -h：显示指令帮助信息；
    -i<文件>：从指定文件获取要下载的URL地址；
    -l<目录列表>：设置顺着的目录列表，多个目录用“，”分隔；
    -L：仅顺着关联的连接；
    -r：递归下载方式；
    -nc：文件存在时，下载文件不覆盖原有文件；
    -nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；
    -q：不显示指令执行过程；
    -nh：不查询主机名称；
    -v：显示详细执行过程；
    -V：显示版本信息；
    --passive-ftp：使用被动模式PASV连接FTP服务器；
    --follow-ftp：从HTML文件中下载FTP连接文件。
#+END_EXAMPLE

****** 参数\\

URL：下载指定的URL地址。

****** 实例\\

*使用wget下载单个文件*

#+BEGIN_EXAMPLE
    wget http://www.linuxde.net/testfile.zip
#+END_EXAMPLE

以下的例子是从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。

*下载并以不同的文件名保存*

#+BEGIN_EXAMPLE
    wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080
#+END_EXAMPLE

wget默认会以最后一个符合=/=的后面的字符来命令，对于动态链接的下载通常文件名会不正确。

错误：下面的例子会下载一个文件并以名称=download.aspx?id=1080=保存:

#+BEGIN_EXAMPLE
    wget http://www.linuxde.net/download?id=1
#+END_EXAMPLE

即使下载的文件是zip格式，它仍然以=download.php?id=1080=命令。

正确：为了解决这个问题，我们可以使用参数=-O=来指定一个文件名：

#+BEGIN_EXAMPLE
    wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080
#+END_EXAMPLE

*wget限速下载*

#+BEGIN_EXAMPLE
    wget --limit-rate=300k http://www.linuxde.net/testfile.zip
#+END_EXAMPLE

当你执行wget的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了。

*使用wget断点续传*

#+BEGIN_EXAMPLE
    wget -c http://www.linuxde.net/testfile.zip
#+END_EXAMPLE

使用=wget -c=重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用=-c=参数。

*使用wget后台下载*

#+BEGIN_EXAMPLE
    wget -b http://www.linuxde.net/testfile.zip

    Continuing in background, pid 1840.
    Output will be written to `wget-log'.
#+END_EXAMPLE

对于下载非常大的文件的时候，我们可以使用参数=-b=进行后台下载，你可以使用以下命令来察看下载进度：

#+BEGIN_EXAMPLE
    tail -f wget-log
#+END_EXAMPLE

*伪装代理名称下载*

#+BEGIN_EXAMPLE
    wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" http://www.linuxde.net/testfile.zip
#+END_EXAMPLE

有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过=--user-agent=参数伪装。

*测试下载链接*

当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加=--spider=参数进行检查。

#+BEGIN_EXAMPLE
    wget --spider URL
#+END_EXAMPLE

如果下载链接正确，将会显示:

#+BEGIN_EXAMPLE
    Spider mode enabled. Check if remote file exists.
    HTTP request sent, awaiting response... 200 OK
    Length: unspecified [text/html]
    Remote file exists and could contain further links,
    but recursion is disabled -- not retrieving.
#+END_EXAMPLE

这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误:

#+BEGIN_EXAMPLE
    wget --spider url
    Spider mode enabled. Check if remote file exists.
    HTTP request sent, awaiting response... 404 Not Found
    Remote file does not exist -- broken link!!!
#+END_EXAMPLE

你可以在以下几种情况下使用=--spider=参数：

-  定时下载之前进行检查
-  间隔检测网站是否可用
-  检查网站页面的死链接

*增加重试次数*

#+BEGIN_EXAMPLE
    wget --tries=40 URL
#+END_EXAMPLE

如果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。如果需要，你可以使用=--tries=增加重试次数。

*下载多个文件*

#+BEGIN_EXAMPLE
    wget -i filelist.txt
#+END_EXAMPLE

首先，保存一份下载链接文件：

#+BEGIN_EXAMPLE
    cat > filelist.txt
    url1
    url2
    url3
    url4
#+END_EXAMPLE

接着使用这个文件和参数=-i=下载。

*镜像网站*

#+BEGIN_EXAMPLE
    wget --mirror -p --convert-links -P ./LOCAL URL
#+END_EXAMPLE

下载整个网站到本地。

-  =--miror=开户镜像下载。
-  =-p=下载所有为了html页面显示正常的文件。
-  =--convert-links=下载后，转换成本地的链接。
-  =-P ./LOCAL=保存所有文件和目录到本地指定目录。

*过滤指定格式下载*

#+BEGIN_EXAMPLE
    wget --reject=gif ur
#+END_EXAMPLE

下载一个网站，但你不希望下载图片，可以使用这条命令。

*把下载信息存入日志文件*

#+BEGIN_EXAMPLE
    wget -o download.log URL
#+END_EXAMPLE

不希望下载信息直接显示在终端而是在一个日志文件，可以使用。

*限制总下载文件大小*

#+BEGIN_EXAMPLE
    wget -Q5m -i filelist.txt
#+END_EXAMPLE

当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。

*下载指定格式文件*

#+BEGIN_EXAMPLE
    wget -r -A.pdf url
#+END_EXAMPLE

可以在以下情况使用该功能：

-  下载一个网站的所有图片。
-  下载一个网站的所有视频。
-  下载一个网站的所有PDF文件。

*FTP下载*

#+BEGIN_EXAMPLE
    wget ftp-url
    wget --ftp-user=USERNAME --ftp-password=PASSWORD url
#+END_EXAMPLE

可以使用wget来完成ftp链接的下载。

使用wget匿名ftp下载：

#+BEGIN_EXAMPLE
    wget ftp-url
#+END_EXAMPLE

使用wget用户名和密码认证的ftp下载：

#+BEGIN_EXAMPLE
    wget --ftp-user=USERNAME --ftp-password=PASSWORD url
#+END_EXAMPLE

*** 网络配置

*** 网络服务器

** 软件|打印|开发|工具

*** 常用工具命令

**** xargs                                                         :xargs:

***** xargs命令

来自: http://man.linuxde.net/xargs

[2016-03-03 四 16:38]
#+BEGIN_SRC org
直接在网页上复制标题, 即有链接, 很便捷
#+END_SRC


*xargs命令* 是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工
具。它擅长将标准输入数据转换成命令行参数，xargs能够处理管道或者stdin并
将其转换成特定命令的命令参数。xargs也可以将单行或多行文本输入转换为其
他格式，例如多行变单行，单行变多行。xargs的默认命令是[[http://man.linuxde.net/echo][echo]]， 空格是默认
定界符。这意味着通过管道传递给xargs的输入将会包含换行和空白，不过通过
xargs的处理，换行和空白将被空格取代。xargs是构建单行命令的重要组件之一。

****** xargs命令用法

xargs用作替换工具，读取输入数据重新格式化后输出。

定义一个测试文件，内有多行文本数据：

#+BEGIN_EXAMPLE
    cat test.txt

    a b c d e f g
    h i j k l m n
    o p q
    r s t
    u v w x y z
#+END_EXAMPLE

多行输入单行输出：

#+BEGIN_EXAMPLE
    cat test.txt | xargs

    a b c d e f g h i j k l m n o p q r s t u v w x y z
#+END_EXAMPLE

*-n选项*多行输出：

#+BEGIN_EXAMPLE
    cat test.txt | xargs -n3

    a b c
    d e f
    g h i
    j k l
    m n o
    p q r
    s t u
    v w x
    y z
#+END_EXAMPLE

*-d选项*可以自定义一个定界符：

#+BEGIN_EXAMPLE
    echo "nameXnameXnameXname" | xargs -dX

    name name name name
#+END_EXAMPLE

结合*-n选项*使用：

#+BEGIN_EXAMPLE
    echo "nameXnameXnameXname" | xargs -dX -n2

    name name
    name name
#+END_EXAMPLE

*读取stdin，将格式化后的参数传递给命令*

假设一个命令为 sk.sh 和一个保存参数的文件arg.txt：

#+BEGIN_EXAMPLE
    #!/bin/bash
    #sk.sh命令内容，打印出所有参数。

    echo $*
#+END_EXAMPLE

arg.txt文件内容：

#+BEGIN_EXAMPLE
    cat arg.txt

    aaa
    bbb
    ccc
#+END_EXAMPLE

xargs的一个*选项-I*，使用-I指定一个替换字符串{}，这个字符串在xargs扩展时会被替换掉，当-I与xargs结合使用，每一个参数命令都会被执行一次：

#+BEGIN_EXAMPLE
    cat arg.txt | xargs -I {} ./sk.sh -p {} -l

    -p aaa -l
    -p bbb -l
    -p ccc -l
#+END_EXAMPLE

复制所有图片文件到 /data/images 目录下：

#+BEGIN_EXAMPLE
    ls *.jpg | xargs -n1 -I cp {} /data/images
#+END_EXAMPLE

*xargs结合[[http://man.linuxde.net/find][find]]使用*

用[[http://man.linuxde.net/rm][rm]]
删除太多的文件时候，可能得到一个错误信息：/bin/rm Argument list too
long. 用xargs去避免这个问题：

#+BEGIN_EXAMPLE
    find . -type f -name "*.log" -print0 | xargs -0 rm -f
#+END_EXAMPLE

xargs -0将\0作为定界符。

统计一个源代码目录中所有[[http://man.linuxde.net/php][php]]文件的行数：

#+BEGIN_EXAMPLE
    find . -type f -name "*.php" -print0 | xargs -0 wc -l
#+END_EXAMPLE

查找所有的jpg 文件，并且压缩它们：

#+BEGIN_EXAMPLE
    find . -type f -name "*.jpg" -print | xargs tar -czvf images.tar.gz
#+END_EXAMPLE

*xargs其他应用*

假如你有一个文件包含了很多你希望下载的URL，你能够使用xargs下载所有链接：

#+BEGIN_EXAMPLE
    cat url-list.txt | xargs wget -c
#+END_EXAMPLE

****** 子Shell（Subshells）

运行一个shell脚本时会启动另一个命令解释器.，就好像你的命令是在命令行提示下被解释的一样，类似于批处理文件里的一系列命令。每个shell脚本有效地运行在父shell(parent
shell)的一个子进程里。这个父shell是指在一个控制终端或在一个xterm窗口中给你命令指示符的进程。

#+BEGIN_EXAMPLE
    cmd1 | ( cmd2; cmd3; cmd4 ) | cmd5
#+END_EXAMPLE

如果cmd2 是[[http://man.linuxde.net/cd][cd]]
/，那么就会改变子Shell的工作目录，这种改变只是局限于子shell内部，cmd5则完全不知道工作目录发生的变化。子shell是嵌在圆括号()内部的命令序列，子Shell内部定义的变量为局部变量。

子shell可用于为一组命令设定临时的环境变量：

#+BEGIN_EXAMPLE
    COMMAND1
    COMMAND2
    COMMAND3
    (
      IFS=:
      PATH=/bin
      unset TERMINFO
      set -C
      shift 5
      COMMAND4
      COMMAND5
      exit 3 # 只是从子shell退出。
    )
    # 父shell不受影响，变量值没有更改。
    COMMAND6
    COMMAND7
#+END_EXAMPLE

**** info                                                           :info:


***** info命令

来自: http://man.linuxde.net/info

*info命令* 是Linux下info格式的帮助指令。

就内容来说，info页面比[[http://man.linuxde.net/man][man]]
page编写得要更好、更容易理解，也更友好，但man
page使用起来确实要更容易得多。一个man
page只有一页，而info页面几乎总是将它们的内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。理解这个命令的窍门就是不仅要学习如何在单独的Info页面中浏览导航，还要学习如何在节点和子节点之间切换。可能刚开始会一时很难在info页面的节点之间移动和找到你要的东西，真是具有讽刺意味：原本以为对于新手来说，某个东西比man命令会更好些，但实际上学习和使用起来更困难。

****** 语法\\

#+BEGIN_EXAMPLE
    info(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -d：添加包含info格式帮助文档的目录；
    -f：指定要读取的info格式的帮助文档；
    -n：指定首先访问的info帮助文件的节点；
    -o：输出被选择的节点内容到指定文件。
#+END_EXAMPLE

****** 参数\\

帮助主题：指定需要获得帮助的主题，可以是指令、函数以及配置文件。

****** 实例\\

在info后面输入命令的名称就可以查看该命令的info帮助文档了：

#+BEGIN_EXAMPLE
    info info
#+END_EXAMPLE

面介绍一下它的几个常用快捷键。

#+BEGIN_EXAMPLE
    ?键：它就会显示info的常用快捷键。
    N键：显示（相对于本节点的）下一节点的文档内容。
    P键：显示（相对于本节点的）前一节点的文档内容。
    U键：进入当前命令所在的主题。
    M键：敲M键后输入命令的名称就可以查看该命令的帮助文档了。
    G键：敲G键后输入主题名称，进入该主题。
    L键：回到上一个访问的页面。
    SPACE键：向前滚动一页。
    BACKUP或DEL键：向后滚动一页。
    Q：退出info。
#+END_EXAMPLE

*命令*

#+BEGIN_EXAMPLE
    ？     显示帮助窗口

    在帮助窗口中：
    Ctrl-x 0          关闭帮助窗口
    Ctrl-x Ctrl-c    关闭整个 Info

    q      退出 info
    n      打开与本 Node 关联的下一个 Node
    p      打开与本 Node 关联的前一个 Node
    u      打开与本 Node 关联的上一个 Node
    l      回到上一次访问的 Node
    m或g   选择一个菜单项（Node 的名字）
           输入指定菜单的名字后按回车，打开指定菜单项关联的 Node
    空格键 下一页（PageDown 也可以，下一页从当前页的最后两行开始算起）
           下一个 Node （若当前页在 Node 文档的末尾）
    Del 键 上一页（PageUp 也可以，上一页从当前页的开始两行开始算起）
           上一个 Node （若当前页 Node 文档的开始）

    b 或 t 或 Home   文档的开始（b 是 begining 的意思）
    e 或 End         文档的末尾（b 是 ending 的意思）
    Ctrl-l    刷新当前页，若当前文档显示情况有问题时
    Ctrl-g    取消所键入的指令
#+END_EXAMPLE

**** man                                                             :man:

***** man命令

来自: http://man.linuxde.net/man

*man命令* 是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、
配置文件帮助和编程帮助等信息。

****** 语法\\

#+BEGIN_EXAMPLE
    man(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -a：在所有的man帮助手册中搜索；
    -f：等价于whatis指令，显示给定关键字的简短描述信息；
    -P：指定内容时使用分页程序；
    -M：指定man手册搜索的路径。
#+END_EXAMPLE

****** 参数\\

-  数字：指定从哪本man手册中搜索帮助；
-  关键字：指定要搜索帮助的关键字。

****** 实例\\

我们输入=man ls=，它会在最左上角显示“LS（1）”，在这里，“LS”表示手册名称，而“（1）”表示该手册位于第一节章，同样，我们输=man ifconfig=它会在最左上角显示“IFCONFIG（8）”。也可以这样输入命令：“man
[章节号] 手册名称”。

man是按照手册的章节号的顺序进行搜索的，比如：

#+BEGIN_EXAMPLE
    man sleep
#+END_EXAMPLE

只会显示sleep命令的手册,如果想查看库函数sleep，就要输入:

#+BEGIN_EXAMPLE
    man 3 sleep
#+END_EXAMPLE

*** 软件包管理
**** apt-get                                                         :apt:apt_get

|----------------------------------+------------------------|
| apt-cache search                 | package搜索包          |
| apt-cache show                   | 获取包信息             |
| sudo apt-get install             | 安装包                 |
| sudo apt-get remove              | 删除包                 |
| sudo apt-get remove --purge      | 删除包及配置文件       |
| sudo apt-get auto remove --purge | 删除包及配置文件及依赖 |
| sudo apt-get update              | 更新源                 |
| sudo apt-get upgrade             | 更新已安装的包         |
| apt-cache depends                | 了解包依赖             |
| apt-get source                   | 下载包源代码           |
| sudo  apt-get clean              | 清理存档               |
| sudo apt-get autoclean           | 只清理过时的包         |
| sudo apt-get check               | 检查是否有坏的依赖     |
|----------------------------------+------------------------|

***** [[http://www.cnblogs.com/bayonetxxx/archive/2010/12/07/1898489.html][sudo apt-get 和dpkg命令大全]] :blog:dpkg:

****** APT的使用（Ubuntu Linux软件包管理工具一）
apt-cache search # ------(package 搜索包)
apt-cache show #------(package 获取包的相关信息，如说明、大小、版本等)
sudo apt-get install # ------(package 安装包)
sudo apt-get install # -----(package - - reinstall 重新安装包)
sudo apt-get -f install # -----(强制安装?#"-f = --fix-missing"当是修复安
装吧...)
sudo apt-get remove #-----(package 删除包)
sudo apt-get remove - - purge # ------(package 删除包，包括删除配置文件
等)
sudo apt-get autoremove --purge # ----(package 删除包及其依赖的软件包+配置文件等（只对6.10有效，强烈推荐）)
sudo apt-get update #------更新源
sudo apt-get upgrade #------更新已安装的包
sudo apt-get dist-upgrade # ---------升级系统
sudo apt-get dselect-upgrade #------使用 dselect 升级
apt-cache depends #-------(package 了解使用依赖)
apt-cache rdepends # ------(package 了解某个具体的依赖?#当是查看该包被哪些包依赖吧...)
sudo apt-get build-dep # ------(package 安装相关的编译环境)
apt-get source #------(package 下载该包的源代码)
sudo apt-get clean && sudo apt-get autoclean # --------清理下载文件的存
档 && 只清理过时的包
sudo apt-get check #-------检查是否有损坏的依赖


apt-get install 的用法
apt-get install <package>
下载 <package> 以及所有倚赖的包裹,同时进行包裹的安装或升级.如果某个包裹被设置了 hold (停止标志,就会被搁在一边(即不会被升级).更多 hold 细节请看下面.

apt-get remove [--purge] <package>
移除 <package> 以及任何倚赖这个包裹的其它包裹.--purge 指明这个包裹应该被完全清除 (purged) ,更多信息请看 dpkg -P .

apt-get update
升级来自 Debian 镜像的包裹列表,如果你想安装当天的任何软件,至少每天运行一次,而且每次修改了
/etc/apt/sources.list 后,必须执行.

apt-get upgrade [-u]
升级所以已经安装的包裹为最新可用版本.不会安装新的或移除老的包裹.如果一个包改变了倚赖关系而需要安装一个新的包裹,那么它将不会被升级,而是标志为 hold .apt-get update 不会升级被标志为 hold 的包裹 (这个也就是 hold 的意思).请看下文如何手动设置包裹为 hold .我建议同时使用 '-u' 选项,因为这样你就能看到哪些包裹将会被升级.

apt-get dist-upgrade [-u]
和 apt-get upgrade 类似,除了 dist-upgrade 会安装和移除包裹来满足倚赖关系.因此具有一定的危险性.

apt-cache search <pattern>
搜索满足 <pattern> 的包裹和描述.

apt-cache show <package>
显示 <package> 的完整的描述.

apt-cache showpkg <package>
显示 <package> 许多细节,以及和其它包裹的关系.

dselect, console-apt, aptitude, gnome-apt,是APT 的几个图形前端(其中一些在使用前得先安装).这里 dselect 无疑是最强大的,也是最古老,最难驾驭.


****** DPKG的 用法（Ubuntu Linux软件包管理工具二）

dpkg -i <package.deb>
安装一个 Debian 包裹文件;如你手动下载的文件.

dpkg -c <package.deb>
列出 <package.deb> 的内容.

dpkg -I <package.deb>
从 <package.deb> 中提取包裹信息.

dpkg -r <package>
移除一个已安装的包裹.

dpkg -P <package>
完全清除一个已安装的包裹.和 remove 不同的是, remove 只是删掉数据和可执行
文件, purge 另外还删除所有的配制文件.

dpkg -L <package>
列出 <package> 安装的所有文件清单.同时请看 dpkg -c 来检查一个 .deb 文件
的内容.

dpkg -s <package>
显示已安装包裹的信息.同时请看 apt-cache 显示 Debian 存档中的包裹信息,以
及 dpkg -I 来显示从一个
.deb 文件中提取的包裹信息.

dpkg-reconfigure <package>
重新配制一个已经安装的包裹,如果它使用的是 debconf (debconf 为包裹安装提
供了一个统一的配制界面).你能够重新配制 debconf 它本身,如你想改变它的前端
或提问的优先权.例如,重新配制 debconf ,使用一个 dialog 前端,简单运行:

dpkg-reconfigure --frontend=dialog debconf (如果你安装时选错了,这里可以
改回来哟

echo "<package> hold" | dpkg --set-selections
设置 <package> 的状态为 hlod (命令行方式)

dpkg --get-selections "<package>"
取的 <package> 的当前状态 (命令行方式)

支持通配符,如:
Debian:~# dpkg --get-selections *wine*

***** apt-get命令

来自: http://man.linuxde.net/apt-get

*apt-get命令* 是DebianLinux发行版中的APT软件包管理工具。所有基于Debian
的发行都使用这个包管理系统。deb包可以把一个应用的文件包在一起，大体就
如同Windows上的安装文件。

****** 语法

#+BEGIN_EXAMPLE
    apt-get(选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -c：指定配置文件。
#+END_EXAMPLE

****** 参数

-  管理指令：对APT软件包的管理操作；
-  软件包：指定要操纵的软件包。

****** 实例

使用apt-get命令的第一步就是引入必需的软件库，Debian的软件库也就是所有Debian软件包的集合，它们存在互联网上的一些公共站点上。把它们的地址加入，apt-get就能搜索到我们想要的软件。/etc/apt/sources.list是存放这些地址列表的配置文件，其格式如下：

#+BEGIN_EXAMPLE
    deb [web或ftp地址] [发行版名字] [main/contrib/non-free]
#+END_EXAMPLE

我们常用的Ubuntu就是一个基于Debian的发行，我们使用apt-get命令获取这个列表，以下是我整理的常用命令：

在修改=/etc/apt/sources.list=或者=/etc/apt/preferences=之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的：

#+BEGIN_EXAMPLE
    apt-get update
#+END_EXAMPLE

安装一个新软件包：

#+BEGIN_EXAMPLE
    apt-get install packagename
#+END_EXAMPLE

卸载一个已安装的软件包（保留配置文件）：

#+BEGIN_EXAMPLE
    apt-get remove packagename
#+END_EXAMPLE

卸载一个已安装的软件包（删除配置文件）：

#+BEGIN_EXAMPLE
    apt-get –purge remove packagename
#+END_EXAMPLE

会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件：

#+BEGIN_EXAMPLE
    apt-get autoclean apt
#+END_EXAMPLE

这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的：

#+BEGIN_EXAMPLE
    apt-get clean
#+END_EXAMPLE

更新所有已安装的软件包：

#+BEGIN_EXAMPLE
    apt-get upgrade
#+END_EXAMPLE

将系统升级到新版本：

#+BEGIN_EXAMPLE
    apt-get dist-upgrade
#+END_EXAMPLE

定期运行这个命令来清除那些已经卸载的软件包的.deb文件。通过这种方式，您可以释放大量的磁盘空间。如果您的需求十分迫切，可以使用=apt-get clean=以释放更多空间。这个命令会将已安装软件包裹的.deb文件一并删除。大多数情况下您不会再用到这些.debs文件，因此如果您为磁盘空间不足
而感到焦头烂额，这个办法也许值得一试：

#+BEGIN_EXAMPLE
    apt-get autoclean
#+END_EXAMPLE

**** dpkg                                                           :dpkg:

|-------------------+------------------------------------|
| dpkg -i <pkg.deb> | 安装debian包裹文件                 |
| dpkg -c <pkg.deb> | 列出包裹内容                       |
| dpkg -i <pkg.deb> | 提取包裹信息                       |
| dpkg -r <pkg>     | 移除已安装包裹                     |
| dpkg -p <pkg>     | 完全清除一个已安装包裹             |
|                   | remove只删除可执行文件和数据,purge |
|                   | 还删除所有的配置文件               |
| dpkg -l <pkg>     | 列出已安装包的文件清单             |
|-------------------+------------------------------------|

***** dpkg error                                                  :error:

https://www.ubuntu.org.cn/viewtopic.php?f=86&t=54689&p=2260127

1. error
   #+BEGIN_EXAMPLE
     ImportError: No module named 'ConfigParser'
     dpkg: 处理软件包 python-markupsafe (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     dpkg: 依赖关系问题使得 python-mako 的配置工作不能继续：
      python-mako 依赖于 python-markupsafe；然而：
       软件包 python-markupsafe 尚未配置。

     dpkg: 处理软件包 python-mako (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 依赖关系问题使得 gobject-introspection 的配置工作不能继续：
      gobject-introspection 依赖于 python-mako；然而：
       软件包 python-mako 尚未配置。

     dpkg: 处理软件包 gobject-introspection (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 依赖关系问题使得 libgirepository1.0-dev 的配置工作不能继续：
      libgirepository1.0-dev 依赖于 gobject-introspection (= 1.42.0-2.2)；然而：
       软件包 gobject-introspection 尚未配置。

     dpkg: 处理软件包 libgirepository1.0-dev (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 依赖关系问题使得 libpeas-dev 的配置工作不能继续：
      libpeas-dev 依赖于 libgirepository1.0因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
                               因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
                   由于已经达到 MaxReports 限制，没有写入 apport 报告。
                                                                       由于已经达到 MaxReports 限制，没有写入 apport 报告。
                                           由于已经达到 MaxReports 限制，没有写入 apport 报告。
               -dev (>= 0.10.1)；然而：
       软件包 libgirepository1.0-dev 尚未配置。

     dpkg: 处理软件包 libpeas-dev (--configure)时出错：
      依赖关系问题 - 仍未被配置
     dpkg: 处理软件包 python-oneconf (--configure)时出错：
      该软件包正处于非常不稳定的状态；
     您最好在配置它之前，先重新安装它
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     dpkg: 处理软件包 python-markupsafe (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     正在设置 python-oneconf (0.3.7.15.04.1) ...
     Traceback (most recent call last):
       File "/usr/bin/pycompile", line 35, in <module>
         from debpython.version import SUPPORTED, debsorted, vrepr, \
       File "/usr/share/python/debpython/version.py", line 24, in <module>
         from ConfigParser import SafeConfigParser
     ImportError: No module named 'ConfigParser'
     dpkg: 处理软件包 python-oneconf (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     dpkg: 依赖关系问题使得 software-center 的配置工作不能继续：
      software-center 依赖于 python-oneconf (>= 0.3) | oneconf (<< 0.3)；然而：
       软件包 python-oneconf 尚未配置。
     系统中 oneconf 的版本为 0.3.7.15.04.1。

     dpkg: 处理软件包 software-center (--configure)时出错：
      依赖关系问题 - 仍未被配置
     正在设置 youtube-dl (2015.02.28-1) ...
     因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。
                                                                         Traceback (most recent call last):
       File "/usr/bin/pycompile", line 35, in <module>
         from debpython.version import SUPPORTED, debsorted, vrepr, \
       File "/usr/share/python/debpython/version.py", line 24, in <module>
         from ConfigParser import SafeConfigParser
     ImportError: No module named 'ConfigParser'
     dpkg: 处理软件包 youtube-dl (--configure)时出错：
      子进程 已安装 post-installation 脚本 返回错误状态 1
     由于已经达到 MaxReports 限制，没有写入 apport 报告。
                                                         在处理时有错误发生：
      python-markupsafe
      python-oneconf
      software-center
      youtube-dl

   #+END_EXAMPLE

2. solution 1

   #+BEGIN_EXAMPLE
   sudo apt-get remove -f
   #+END_EXAMPLE

   无效

3. 终极暴力解法

   删除 */var/lib/dpkg/status* 中有关那个软件的安装信息
   和 */var/lib/dpkg/info* 目录下那个软件包的几个文件
   这个应该是 =终极方法= ，不过， *使用之前注意备份就是了*

   #+BEGIN_EXAMPLE
     wally@ info $ ls | grep youtube-dl
     youtube-dl.conffiles
     youtube-dl.list
     youtube-dl.md5sums
     youtube-dl.postinst
     youtube-dl.prerm
     wally@ info $ sudo find . -name "youtube-dl.*" -exec mv {} {}.20160120.1.bak \;
     wally@ info $ ls | grep youtube-dl
     youtube-dl.conffiles.20160120.1.bak
     youtube-dl.list.20160120.1.bak
     youtube-dl.md5sums.20160120.1.bak
     youtube-dl.postinst.20160120.1.bak
     youtube-dl.prerm.20160120.1.bak
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
      $ sudo apt-get -f install
     正在读取软件包列表... 完成
     正在分析软件包的依赖关系树
     正在读取状态信息... 完成
     下列软件包是自动安装的并且现在不需要了：
       libffi-dev linux-headers-3.19.0-15 linux-headers-3.19.0-15-generic linux-image-3.19.0-15-generic linux-image-extra-3.19.0-15-generic
     使用'apt-get autoremove'来卸载它(它们)。
     升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。
     有 4 个软件包没有被完全安装或卸载。
     解压缩后会消耗掉 0 B 的额外空间。
     正在设置 python-markupsafe (0.23-1) ...
     正在设置 python-oneconf (0.3.7.15.04.1) ...
     正在设置 software-center (13.10-0ubuntu6.1) ...
     正在设置 youtube-dl (2015.02.28-1) ...
   #+END_EXAMPLE

   测试 OK

***** dpkg warnning
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-03-03 四 16:09] \\
  Does not matter
:END:

[[http://www.2cto.com/os/201305/207615.html][误删dpkg的/var/lib/dpkg/info文件夹的解决办法]] 方法可以借鉴, 也许可以解
决问题, 但不用操之过急.这个问题还没有影响到使用.

#+BEGIN_EXAMPLE
  dpkg：警告：无法找到软件包 software-center 的文件名列表文件，现假定该软件包目前没有任何文件被安装在系统里。
  dpkg：警告：无法找到软件包 python-markupsafe 的文件名列表文件，现假定该软件包目前没有任何文件被安装在系统里。
  dpkg：警告：无法找到软件包 youtube-dl 的文件名列表文件，现假定该软件包目前没有任何文件被安装在系统里。
  dpkg：警告：无法找到软件包 python-oneconf 的文件名列表文件，现假定该软件包目前没有任何文件被安装在系统里。
#+END_EXAMPLE

***** dpkg命令

来自: http://man.linuxde.net/dpkg

*dpkg命令* 是Debian Linux系统用来安装、创建和管理软件包的实用工具。

****** 语法

#+BEGIN_EXAMPLE
    dpkg(选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -i：安装软件包；
    -r：删除软件包；
    -P：删除软件包的同时删除其配置文件；
    -L：显示于软件包关联的文件；
    -l：显示已安装软件包列表；
    --unpack：解开软件包；
    -c：显示软件包内文件列表；
    --confiugre：配置软件包。
#+END_EXAMPLE

****** 参数

Deb软件包：指定要操作的.deb软件包。

****** 实例

#+BEGIN_EXAMPLE
    dpkg -i package.deb     #安装包
    dpkg -r package         #删除包
    dpkg -P package         #删除包（包括配置文件）
    dpkg -L package         #列出与该包关联的文件
    dpkg -l package         #显示该包的版本
    dpkg --unpack package.deb  #解开deb包的内容
    dpkg -S keyword            #搜索所属的包内容
    dpkg -l                    #列出当前已安装的包
    dpkg -c package.deb        #列出deb包的内容
    dpkg --configure package   #配置包
#+END_EXAMPLE

**** patch                                                         :patch:

***** [[http://linux-wiki.cn/wiki/zh-hans/%E8%A1%A5%E4%B8%81(patch)%E7%9A%84%E5%88%B6%E4%BD%9C%E4%B8%8E%E5%BA%94%E7%94%A8][补丁(patch)的制作与应用]]

http://www.lampweb.org/linux/3/18.html

用到的两个命令是diff和patch。

1. diff
   1) 功能：diff可以比较两个东西，并可同时记录下二者的区别。
   2) 语法：*diff 【选项】 源文件（夹） 目的文件（夹）*
   3) 选项：
      + -r  递归。设置后diff会将两个不同版本源代码目录中的所有对应文件全
        部都进行一次比较，包括子目录文件。
      + -n  选项确保补丁文件将正确地处理已经创建或删除文件的情况。
      + -u  输出每个修改前后的3行，也可以用-u5等指定输出更多上下文。
      + -e, -b, -w, -b, --strip-trailing-cr  忽略各种空白，可参见文档，
        按需选用。

2. patch
   1) 功能：patch的作用则是将diff记录的结果（即补丁）应用到相应文件（夹）上。

   2) 语法： *patch -pnum <patchfile>*

   3) 选项
      + -p num  忽略几层文件夹

3. 例子
   1) 对单个文件打补丁
      #+begin_example
        # 产生补丁
        diff -un from-file to-file >to-file.patch

        # 打补丁
        patch -p0 < to-file.patch

        # 取消补丁
        patch -re -p0 < to-file.patch
        对整个文件夹打补丁的情况：

        # 产生补丁
        diff -unr  from-docu  to-docu  >to-docu.patch

        # 打补丁
        cd to-docu
        patch -p1 < to-docu.patch

        # 取消补丁
        patch -r -p1 <to-docu.patch
     #+end_example

   2) 对文件夹打补丁

   3) 注
      + 另外，使用版本控制工具时，可以直接用svn diff或git diff生成补丁
        文件。

      + 值得一提的是，由于应用补丁时的目标代码和生成补丁时的代码未必相
        同，打补丁操作可能失败。补丁失败的文件会以.rej结尾，下面命令可
        以找出所有rej文件： find . -name '*.rej'

***** patch命令

来自: http://man.linuxde.net/patch

*patch命令* 被用于为开放源代码软件安装补丁程序。让用户利用设置修补文件
的方式，修改，更新原始文件。如果一次仅修改一个文件，可直接在命令列中下
达指令依序执行。如果配合修补文件的方式则能一次修补大批文件，这也是
Linux系统核心的升级方法之一。

****** 语法

#+BEGIN_EXAMPLE
    patch(选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -b或--backup：备份每一个原始文件；
    -B<备份字首字符串>或--prefix=<备份字首字符串>：设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称；
    -c或--context：把修补数据解译成关联性的差异；
    -d<工作目录>或--directory=<工作目录>：设置工作目录；
    -D<标示符号>或--ifdef=<标示符号>：用指定的符号把改变的地方标示出来；
    -e或--ed：把修补数据解译成ed指令可用的叙述文件；
    -E或--remove-empty-files：若修补过后输出的文件其内容是一片空白，则移除该文件；
    -f或--force：此参数的效果和指定"-t"参数类似，但会假设修补数据的版本为新版本；
    -F<监别列数>或--fuzz<监别列数>：设置监别列数的最大值；
    -g<控制数值>或--get=<控制数值>：设置以RSC或SCCS控制修补作业；
    -i<修补文件>或--input=<修补文件>：读取指定的修补问家你；
    -l或--ignore-whitespace：忽略修补数据与输入数据的跳格，空格字符；
    -n或--normal：把修补数据解译成一般性的差异；
    -N或--forward：忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使 用过；
    -o<输出文件>或--output=<输出文件>：设置输出文件的名称，修补过的文件会以该名称存放；
    -p<剥离层级>或--strip=<剥离层级>：设置欲剥离几层路径名称；
    -f<拒绝文件>或--reject-file=<拒绝文件>：设置保存拒绝修补相关信息的文件名称，预设的文件名称为.rej；
    -R或--reverse：假设修补数据是由新旧文件交换位置而产生；
    -s或--quiet或--silent：不显示指令执行过程，除非发生错误；
    -t或--batch：自动略过错误，不询问任何问题；
    -T或--set-time：此参数的效果和指定"-Z"参数类似，但以本地时间为主；
    -u或--unified：把修补数据解译成一致化的差异；
    -v或--version：显示版本信息；
    -V<备份方式>或--version-control=<备份方式>：用"-b"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用"-z"参数变更，当使用"-V"参数指定不同备份方式时，也会产生不同字尾的备份字符串；
    -Y<备份字首字符串>或--basename-prefix=--<备份字首字符串>：设置文件备份时，附加在文件基本名称开头的字首字符串；
    -z<备份字尾字符串>或--suffix=<备份字尾字符串>：此参数的效果和指定"-B"参数类似，差别在于修补作业使用的路径与文件名若为src/linux/fs/super.c，加上"backup/"字符串后，文件super.c会备份于/src/linux/fs/backup目录里；
    -Z或--set-utc：把修补过的文件更改，存取时间设为UTC；
    --backup-if-mismatch：在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件；
    --binary：以二进制模式读写数据，而不通过标准输出设备；
    --help：在线帮助；
    --nobackup-if-mismatch：在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件；
    --verbose：详细显示指令的执行过程。
#+END_EXAMPLE

****** 参数

-  原文件：指定需要打补丁的原始文件；
-  补丁文件：指定补丁文件。

***** [[http://www.lampweb.org/linux/3/18.html][patch 修补文件（给文件打补丁）]]                               :blog:

*功能*：修补文件。使用补丁文件，对源文件进行更改。更改方式根据参数来设定。
倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行。如果配合修补文件的方式则能一次修补大批文件。

#+BEGIN_EXAMPLE
    语法：patch   [OPTION]   [ORIGFILE]  [PATCHFILE]
#+END_EXAMPLE

输入选项

-p NUM

--strip=NUM

去除相对路径层次的数目

-F LINES

--fuzz LINES

设置监别列数

-l

--ignore-whitespace

忽略修补数据与输入数据的跳格，空格字符

-c

--context

把修补数据解译成关联性的差异

-e

--ed

把修补数据解译成ed指令可用的叙述文件

-n

--normal

把修补数据解译成一般性的差异

-u

--unified

把修补数据解译成一致化的差异

-N

--forward

忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使用过

-R

--reverse

假设修补数据是由新旧文件交换位置而产生

-i PATCHFILE

--input=PATCHFILE

读取指定的修补文件

输出选项

-o FILE

--output=FILE

设置输出文件的名称，修补过的文件会以该名称存放

-r FILE

--reject-file=FILE

Output rejects to FILE

-D NAME

--ifdef=NAME

用指定的符号把改变的地方标示出来

-m

--merge

Merge using conflict markers instead of creating reject files

-E

--remove-empty-files

若修补过后输出的文件其内容是一片空白，则移除该文件

-Z

--set-utc

把修补过的文件更改，存取时间设为UTC

-T

--set-time

此参数的效果和指定"-Z"参数类似，但以本地时间为主



--quoting-style=WORD

使用WORD引述类型显示项目名称,可设定值有literal,shell,shell-always,c,escape

备份和版本控制选项

-b

--backup

备份每一个原始文件



--backup-if-mismatch

在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件



--no-backup-if-mismatch

在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件

-V STYLE

--version-control=STYLE

用"-b"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用"-z"参数变更，
当使用"-V"参数指定不同备份方式时，也会产生不同字尾的备份字符串

-B PREFIX

--prefix=PREFIX

设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称

-Y PREFIX

--basename-prefix=PREFIX

设置文件备份时，附加在文件基本名称开头的字首字符串

-z SUFFIX

--suffix=SUFFIX

此参数的效果和指定"-B"参数类似，差别在于修补作业使用的路径与文件名若为src/linux/fs/super.c，
加上"backup/"字符串后，文件super.c会备份于/src/linux/fs/backup目录里

-g NUM

--get=NUM

设置以RSC或SCCS控制修补作业

其他选项

-t

--batch

自动略过错误，不询问任何问题

-f

--force

此参数的效果和指定"-t"参数类似，但会假设修补数据的版本为新版本

-s

--quiet或--silent

不显示指令执行过程，除非发生错误



--verbose

显示详细的过程信息



--dry-run

实际上不改变任何文件；演示讲会发生什么



--posix

符合POSIX标准

-d DIR

--directory=DIR

先改变工作目录到指定的目录



--reject-format=FORMAT

Create 'context' or 'unified' rejects



--binary

以二进制方式读写数据



--read-only=BEHAVIOR

如何处理只读输入文件：“忽视”，他们是只读的，“警告”（默认），或“失败”



#+BEGIN_QUOTE

  -  patch 命令（默认）使用从标准输入读入的源文件 *< PATCHFILE*
     ，但是使用 -i  /PATCHFILE/ 设置。
  -  源文件包含由 diff 命令产生的差别列表（或者 diff
     列表）。差异列表是比较两个文件和构建关于如何纠正差别的指示信息的结果。
  -  差异列表有三种格式：正常、上下文或者是 ed 编辑器风格。patch
     命令确定差异列表格式，除非被 -c、-e 或 -n 标志否决。
  -  默认，/ORIGFILE/ 被/PATCHFILE/
     替换。若/ORIGFILE/（原始文件）不存在时，/PATCHFILE/（补丁文件）根据差别列表，创建
     /ORIGFILE/ 文件。
  -  指定 -b
     标志时，/ORIGFILE/（原始文件）会备份在自身的文件中，只是在文件名后附加了后缀
     .orig。使用 -o 标志也可以指定输出的目的地。
#+END_QUOTE

patch常用选项：
 -r
是一个递归选项，设置了这个选项，diff会将两个不同版本源代码目录中的所有对应文件全部都进行一次比较，包括子目录文件。
 -N 选项确保补丁文件将正确地处理已经创建或删除文件的情况。
 -u 选项以统一格式创建补丁文件，这种格式比缺省格式更紧凑些。
 -p0 选项从当前目录查找目的文件（夹）(直接使用补丁文件里面指定的路径)
 -p1
选项忽略掉第一层目录，从当前目录查找(去掉补丁文件指定路径最左的第1个'/'及前面所有内容)。
 -E  选项说明如果发现了空文件，那么就删除它
 -R
 选项说明在补丁文件中的“新”文件和“旧”文件现在要调换过来了（实际上就是给新版本打补丁，让它变成老版本）



******* svn生成补丁文件和打补丁文件

#+BEGIN_EXAMPLE
    生成补丁文件：
    svn diff > patchFile  整个工程的变动生成补丁
    或 svn diff file > patchFile  某个文件单独变动的补丁

    svn回滚：
    svn revert FILE   单个文件回滚
    svn revert DIR --depth=infinity   整个目录进行递归回滚

    打patch：
    patch -p0 < test.patch   -p0 选项要从当前目录查找目的文件

    patch -p1 < test.patch  -p1 选项要从当前目录查找目的文件，不包含patch中的最上级目录
    例如两个版本以a,b开头，而a,b并不是真正有效地代码路径，则这时候需要使用"-p1"参数。
    a/src/...
    b/src/...
#+END_EXAMPLE

*** 编程开发
**** expr                                                           :expr:
***** man

#+BEGIN_EXAMPLE
EXPR(1)                                                        User Commands                                                       EXPR(1)

NAME
       expr - evaluate expressions

SYNOPSIS
       expr EXPRESSION
       expr OPTION
...
#+END_EXAMPLE

***** expressions

- ARG1 | ARG2

  ARG1 if it is neither null nor 0, otherwise ARG2

- ARG1 & ARG2

  ARG1 if neither argument is null or 0, otherwise 0

- ARG1 < ARG2

  ARG1 is less than ARG2

- ARG1 <= ARG2

  ARG1 is less than or equal to ARG2

- ARG1 = ARG2

  ARG1 is equal to ARG2

- ARG1 != ARG2

  ARG1 is unequal to ARG2

- ARG1 >= ARG2

  ARG1 is greater than or equal to ARG2

- ARG1 > ARG2

  ARG1 is greater than ARG2

- ARG1 + ARG2

  arithmetic sum of ARG1 and ARG2

- ARG1 - ARG2

  arithmetic difference of ARG1 and ARG2

- ARG1 * ARG2

  arithmetic product of ARG1 and ARG2

- ARG1 / ARG2

  arithmetic quotient of ARG1 divided by ARG2

- ARG1 % ARG2

  arithmetic remainder of ARG1 divided by ARG2

- STRING : REGEXP

  anchored pattern match of REGEXP in STRING

- match STRING REGEXP

  same as STRING : REGEXP

- substr STRING POS LENGTH

  substring of STRING, POS counted from 1

- index STRING CHARS

  index in STRING where any CHARS is found, or 0

- length STRING

  length of STRING

- + TOKEN

  interpret TOKEN as a string, even if it is a keyword like 'match' or
  an operator like '/'

***** 小结

expr 命令用来 *数值运算* .
***** [[/junjieguo/article/details/7293622][bash shell中expr命令下几种的使用]]

expr在linux中是一个功能非常强大的命令。通过学习做一个小小的总结。

1、计算字符串的长度。

我们可以用awk中的length(s)进行计算。我们也可以用echo中的echo
${#string}进行计算，当然也可以expr中的expr length $string
求出字符串的长度。

举例

#+BEGIN_EXAMPLE
    [root@localhost shell]# string="hello,everyone my name is xiaoming"
    [root@localhost shell]# echo ${#string}
    34
    [root@localhost shell]# expr length "$string"
    34
#+END_EXAMPLE

2、expr中的expr index $string

substring索引命令功能在字符串$string上找出substring中字符第一次出现的位置，若找不到则expr
index返回0或1。

举例

#+BEGIN_SRC python
    [root@localhost shell]# string="hello,everyone my name is xiaoming"
    [root@localhost shell]# expr index "$string" my
    11
    [root@localhost shell]# expr index "$string" nihao
    1
#+END_SRC

3、expr中的expr match $string

substring命令在string字符串中匹配substring字符串，然后返回匹配到的substring字符串的长度，若找不到则返回0。

举例

#+BEGIN_SRC python
    [root@localhost shell]# string="hello,everyone my name is xiaoming"
    [root@localhost shell]# expr match "$string" my
    0
    [root@localhost shell]# expr match "$string" hell.*
    34
    [root@localhost shell]# expr match "$string" hell
    4
    [root@localhost shell]# expr match "$string" small
    0
#+END_SRC

4、在shell中可以用{string:position}和{string:position:length}进行对
string字符串中字符的抽取。第一种是从position位置开始抽取直到字符串结束，
第二种是从position位置开始抽取长度为length的子串。而用expr中的expr
substr $string $position $length同样能实现上述功能。

举例

#+BEGIN_SRC python
    root@localhost shell]# string="hello,everyone my name is xiaoming"
    [root@localhost shell]# echo ${string:10}
    yone my name is xiaoming
    [root@localhost shell]# echo ${string:10:5}
    yone
    [root@localhost shell]# echo ${string:10:10}
    yone my na
    [root@localhost shell]# expr substr "$string" 10 5
    ryone
#+END_SRC

注意：echo ${string:10:5}和 expr substr "$string" 10
5的区别在于${string:10:5}以0开始标号而expr substr "$string" 10
5以1开始标号。

5、删除字符串和抽取字符串相似${string#substring}为删除string开头处与
substring匹配的最短字符子串，而${string##substring}为删除string开头处
与substring匹配的最长字符子串。

举例

#+BEGIN_SRC python
    [root@localhost shell]# string="20091111 readnow please"
    [root@localhost shell]# echo ${string#2*1}
    111 readnow please
    [root@localhost shell]# string="20091111 readnow please"
    [root@localhost shell]# echo ${string##2*1}
    readnow please
#+END_SRC

解析：第一个为删除2和1之间最短匹配，第二个为删除2和1之间的最长匹配。

6、替换子串${string/substring/replacement}表示仅替换一次substring相配
字符，而${string//substring//replacement}表示为替换所有的substring相配
的子串。

举例

#+BEGIN_SRC python
    [root@localhost shell]# string="you and you with me"
    [root@localhost shell]# echo ${string/you/me}
    me and you with me
    [root@localhost shell]# string="you and you with me"
    [root@localhost shell]# echo ${string//you/me}
    me and me with me
#+END_SRC

***** reference

- [[https://app.yinxiang.com/shard/s52/nl/11551545/7e9337a8-84d5-407b-b978-415e80ab18e8/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D151c0035574%3AS%3Dcc31c0c9dc82a5abcb9748dd2467a014][EN::bash expr]]
- http://ss64.com/bash/expr.html

***** expr命令

来自: http://man.linuxde.net/expr

*expr命令* 是一款表达式计算工具，使用它完成表达式的求值操作。

expr的常用运算符：

-  加法运算：+
-  减法运算：-
-  乘法运算：\*
-  除法运算：/
-  求摸（取余）运算：%

****** 语法\\

#+BEGIN_EXAMPLE
    expr(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    --help：显示指令的帮助信息；
    --version：显示指令版本信息。
#+END_EXAMPLE

****** 参数\\

表达式：要求值的表达式。

****** 实例\\

#+BEGIN_EXAMPLE
    result=`expr 2 + 3`
    result=$(expr $no1 + 5)
#+END_EXAMPLE

*** 打印

** 文件目录管理

*** 文件查找和比较
**** find                                                           :find:
***** find命令

来自: http://man.linuxde.net/find

*find命令* 用来在指定目录下查找文件。任何位于参数之前的字符串都将被视
为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前
目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。

****** 语法

#+BEGIN_EXAMPLE
    find(选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -amin<分钟>：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；
    -anewer<参考文件或目录>：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；
    -atime<24小时数>：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；
    -cmin<分钟>：查找在指定时间之时被更改过的文件或目录；
    -cnewer<参考文件或目录>查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
    -ctime<24小时数>：查找在指定时间之时被更改的文件或目录，单位以24小时计算；
    -daystart：从本日开始计算时间；
    -depth：从指定目录下最深层的子目录开始查找；
    -expty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；
    -exec<执行指令>：假设find指令的回传值为True，就执行该指令；
    -false：将find指令的回传值皆设为False；
    -fls<列表文件>：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件；
    -follow：排除符号连接；
    -fprint<列表文件>：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件；
    -fprint0<列表文件>：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；
    -fprintf<列表文件><输出格式>：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；
    -fstype<文件系统类型>：只寻找该文件系统类型下的文件或目录；
    -gid<群组识别码>：查找符合指定之群组识别码的文件或目录；
    -group<群组名称>：查找符合指定之群组名称的文件或目录；
    -help或——help：在线帮助；
    -ilname<范本样式>：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；
    -iname<范本样式>：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；
    -inum<inode编号>：查找符合指定的inode编号的文件或目录；
    -ipath<范本样式>：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；
    -iregex<范本样式>：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；
    -links<连接数目>：查找符合指定的硬连接数目的文件或目录；
    -iname<范本样式>：指定字符串作为寻找符号连接的范本样式；
    -ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；
    -maxdepth<目录层级>：设置最大目录层级；
    -mindepth<目录层级>：设置最小目录层级；
    -mmin<分钟>：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；
    -mount：此参数的效果和指定“-xdev”相同；
    -mtime<24小时数>：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；
    -name<范本样式>：指定字符串作为寻找文件或目录的范本样式；
    -newer<参考文件或目录>：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
    -nogroup：找出不属于本地主机群组识别码的文件或目录；
    -noleaf：不去考虑目录至少需拥有两个硬连接存在；
    -nouser：找出不属于本地主机用户识别码的文件或目录；
    -ok<执行指令>：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；
    -path<范本样式>：指定字符串作为寻找目录的范本样式；
    -perm<权限数值>：查找符合指定的权限数值的文件或目录；
    -print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；
    -print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；
    -printf<输出格式>：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；
    -prune：不寻找字符串作为寻找文件或目录的范本样式;
    -regex<范本样式>：指定字符串作为寻找文件或目录的范本样式；
    -size<文件大小>：查找符合指定的文件大小的文件；
    -true：将find指令的回传值皆设为True；
    -typ<文件类型>：只寻找符合指定的文件类型的文件；
    -uid<用户识别码>：查找符合指定的用户识别码的文件或目录；
    -used<日数>：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；
    -user<拥有者名称>：查找符和指定的拥有者名称的文件或目录；
    -version或——version：显示版本信息；
    -xdev：将范围局限在先行的文件系统中；
    -xtype<文件类型>：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。
#+END_EXAMPLE

****** 参数

起始目录：查找文件的起始目录。

****** 实例

******* 根据文件或者正则表达式进行匹配

列出当前目录及子目录下所有文件和文件夹

#+BEGIN_EXAMPLE
    find .
#+END_EXAMPLE

在=/home=目录下查找以.txt结尾的文件名

#+BEGIN_EXAMPLE
    find /home -name "*.txt"
#+END_EXAMPLE

同上，但忽略大小写

#+BEGIN_EXAMPLE
    find /home -iname "*.txt"
#+END_EXAMPLE

当前目录及子目录下查找所有以.txt和.pdf结尾的文件

#+BEGIN_EXAMPLE
    find . \( -name "*.txt" -o -name "*.pdf" \)

    或

    find . -name "*.txt" -o -name "*.pdf"
#+END_EXAMPLE

匹配文件路径或者文件

#+BEGIN_EXAMPLE
    find /usr/ -path "*local*"
#+END_EXAMPLE

基于正则表达式匹配文件路径

#+BEGIN_EXAMPLE
    find . -regex ".*\(\.txt\|\.pdf\)$"
#+END_EXAMPLE

同上，但忽略大小写

#+BEGIN_EXAMPLE
    find . -iregex ".*\(\.txt\|\.pdf\)$"
#+END_EXAMPLE

******* 否定参数

找出/home下不是以.txt结尾的文件

#+BEGIN_EXAMPLE
    find /home ! -name "*.txt"
#+END_EXAMPLE

******* 根据文件类型进行搜索

#+BEGIN_EXAMPLE
    find . -type 类型参数
#+END_EXAMPLE

类型参数列表：

-  *f* 普通文件
-  *l* 符号连接
-  *d* 目录
-  *c* 字符设备
-  *b* 块设备
-  *s* 套接字
-  *p* Fifo

******* 基于目录深度搜索

向下最大深度限制为3

#+BEGIN_EXAMPLE
    find . -maxdepth 3 -type f
#+END_EXAMPLE

搜索出深度距离当前目录至少2个子目录的所有文件

#+BEGIN_EXAMPLE
    find . -mindepth 2 -type f
#+END_EXAMPLE

******* 根据文件时间戳进行搜索

#+BEGIN_EXAMPLE
    find . -type f 时间戳
#+END_EXAMPLE

UNIX/Linux文件系统每个文件都有三种时间戳：

-  *访问时间*（-atime/天，-amin/分钟）：用户最近一次访问时间。
-  *修改时间*（-mtime/天，-mmin/分钟）：文件最后一次修改时间。
-  *变化时间*（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。

搜索最近七天内被访问过的所有文件

#+BEGIN_EXAMPLE
    find . -type f -atime -7
#+END_EXAMPLE

搜索恰好在七天前被访问过的所有文件

#+BEGIN_EXAMPLE
    find . -type f -atime 7
#+END_EXAMPLE

搜索超过七天内被访问过的所有文件

#+BEGIN_EXAMPLE
    find . -type f -atime +7
#+END_EXAMPLE

搜索访问时间超过10分钟的所有文件

#+BEGIN_EXAMPLE
    find . -type f -amin +10
#+END_EXAMPLE

找出比[[http://man.linuxde.net/file][file]].log修改时间更长的所有文件

#+BEGIN_EXAMPLE
    find . -type f -newer file.log
#+END_EXAMPLE

******* 根据文件大小进行匹配

#+BEGIN_EXAMPLE
    find . -type f -size 文件大小单元
#+END_EXAMPLE

文件大小单元：

-  *b* ------ 块（512字节）
-  *c* ------ 字节
-  *[[http://man.linuxde.net/w][w]]* ------ 字（2字节）
-  *k* ------ 千字节
-  *M* ------ 兆字节
-  *G* ------ 吉字节

搜索大于10KB的文件

#+BEGIN_EXAMPLE
    find . -type f -size +10k
#+END_EXAMPLE

搜索小于10KB的文件

#+BEGIN_EXAMPLE
    find . -type f -size -10k
#+END_EXAMPLE

搜索等于10KB的文件

#+BEGIN_EXAMPLE
    find . -type f -size 10k
#+END_EXAMPLE

******* 删除匹配文件

删除当前目录下所有.txt文件

#+BEGIN_EXAMPLE
    find . -type f -name "*.txt" -delete
#+END_EXAMPLE

******* 根据文件权限/所有权进行匹配

当前目录下搜索出权限为777的文件

#+BEGIN_EXAMPLE
    find . -type f -perm 777
#+END_EXAMPLE

找出当前目录下权限不是644的[[http://man.linuxde.net/php][php]]文件

#+BEGIN_EXAMPLE
    find . -type f -name "*.php" ! -perm 644
#+END_EXAMPLE

找出当前目录用户tom拥有的所有文件

#+BEGIN_EXAMPLE
    find . -type f -user tom
#+END_EXAMPLE

找出当前目录用户组sunk拥有的所有文件

#+BEGIN_EXAMPLE
    find . -type f -group sunk
#+END_EXAMPLE

******* 借助=-exec=选项与其他命令结合使用

找出当前目录下所有root的文件，并把所有权更改为用户tom

#+BEGIN_EXAMPLE
    find .-type f -user root -exec chown tom {} \;
#+END_EXAMPLE

上例中，*{}*
用于与*-exec*选项结合使用来匹配所有文件，然后会被替换为相应的文件名。

找出自己家目录下所有的.txt文件并删除

#+BEGIN_EXAMPLE
    find $HOME/. -name "*.txt" -ok rm {} \;
#+END_EXAMPLE

上例中，*-ok*和*-exec*行为一样，不过它会给出提示，是否执行相应的操作。

查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中

#+BEGIN_EXAMPLE
    find . -type f -name "*.txt" -exec cat {} \;> all.txt
#+END_EXAMPLE

将30天前的.log文件移动到old目录中

#+BEGIN_EXAMPLE
    find . -type f -mtime +30 -name "*.log" -exec cp {} old \;
#+END_EXAMPLE

找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来

#+BEGIN_EXAMPLE
    find . -type f -name "*.txt" -exec printf "File: %s\n" {} \;
#+END_EXAMPLE

因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令

#+BEGIN_EXAMPLE
    -exec ./text.sh {} \;
#+END_EXAMPLE

******* 搜索但跳出指定的目录

查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk

#+BEGIN_EXAMPLE
    find . -path "./sk" -prune -o -name "*.txt" -print
#+END_EXAMPLE

******* find其他技巧收集

要列出所有长度为零的文件

#+BEGIN_EXAMPLE
    find . -empty
#+END_EXAMPLE

***** 基本用法
1. 功能： 用于在目录树下查找文件，并作出相应的处理

2. 命令格式： *find <path> [-options] [-print|-exec-ok]*

3. 命令参数
   + path: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示
     系统根目录。

   + -print： find命令将匹配的文件输出到标准输出。

   + -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令
     的形式为'command' {  } \;，注意{   }和\；之间的空格。

   + -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所
     给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定
     是否执行。

4. 命令选项
   + *-name*   按照文件名查找文件。
   + -perm   按照文件权限来查找文件。
   + -prune  使用这一选项可以使find命令不在当前指定的目录中查找，如果
     同时使用-depth选项，那么-prune将被find命令忽略。

   + -user   按照文件属主来查找文件。
   + -group  按照文件所属的组来查找文件。
   + -mtime -n +n  按照文件的更改时间来查找文件，
     + - n表示文件更改时间距现在n天以内，
     + + n表示文件更改时间距现在n天以前。
   + find命令还有-atime和-ctime 选项，但它们都和-m time选项。

   + -nogroup  查找无有效所属组的文件，即该文件所属的组在/etc/groups中
     不存在。

   + -nouser   查找无有效属主的文件，即该文件的属主在/etc/passwd中不存
     在。

   + -newer file1 ! file2  查找更改时间比文件file1新但比文件file2旧的
     文件。

   + -type  查找某一类型的文件，诸如：
     + b - 块设备文件。
     + d - 目录。
     + c - 字符设备文件。
     + p - 管道文件。
     + l - 符号链接文件。
     + f - 普通文件。

   + -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节
     计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子
     目录中查找。

   + -fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可
     以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件
     系统的信息。

   + -mount：在查找文件时不跨越文件系统mount点。

   + -follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。

   + -cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。

   + -amin n   查找系统中最后n分钟访问的文件
   + -atime n  查找系统中最后n*24小时访问的文件
   + -cmin n   查找系统中最后n分钟被改变文件状态的文件
   + -ctime n  查找系统中最后n*24小时被改变文件状态的文件
   + -mmin n   查找系统中最后n分钟被改变文件数据的文件
   + -mtime n  查找系统中最后n*24小时被改变文件数据的文件

5. 参考
   + [[https://app.yinxiang.com/shard/s52/nl/11551545/e485b74c-eae1-4235-b3be-856404530043?title=%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4%ef%bc%8819%ef%bc%89%ef%bc%9afind%20%e5%91%bd%e4%bb%a4%e6%a6%82%e8%a7%88%20-%20peida%20-%20%e5%8d%9a%e5%ae%a2%e5%9b%ad][每天一个linux命令之find]]

***** [[https://app.yinxiang.com/shard/s52/nl/11551545/66242b51-a72b-482b-9fa9-b75e5dc14d0b][find -exec]] :exec:

-exec  参数后面跟的是command命令， *它的终止是以;为结束标志的* ，所以
这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所
以前面加反斜杠。

{}   花括号代表前面find查找出来的文件名。

使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，
很方便的。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。
大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令
删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。 exec选
项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最
后是一个分号。为了使用exec选项，必须要同时使用print选项。

当使用诸如mv或rm命令时，可以使用-exec选项的安全模式。它将在对每个匹配
到的文件进行操作之前提示你。  *-ok*

1. 实例1：ls -l命令放在find命令的-exec选项中

   #+BEGIN_SRC sh
   find . -type f -exec ls -l {} \;
   #+END_SRC

2. 实例2：在目录中查找更改时间在n日以前的文件并删除它们

   #+BEGIN_SRC sh
   find . -type f -mtime +14 -exec rm {} \;
   #+END_SRC

3. 实例3：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示

   #+BEGIN_SRC sh
   find . -name "*.log" -mtime +5 -ok rm {} \;
   #+END_SRC

   *星号通配符需要使用引号括起来，否则会展开*

4. 实例4：-exec中使用grep命令

   #+BEGIN_SRC sh
   find /etc -name "passwd*" -exec grep "root" {} \;
   #+END_SRC

5. 实例5：查找文件移动到指定目录

   #+BEGIN_SRC sh
   find . -name "*.log" -exec mv {} .. \;
   #+END_SRC

6. 实例6：用exec选项执行cp命令

   #+BEGIN_SRC sh
   find . -name "*.log" -exec cp {} test3 \;p
   #+END_SRC

7. 重命名多个文件

   #+BEGIN_EXAMPLE
   find . -name "foo.*" -exec mv {} {}.bak \;
   #+END_EXAMPLE

**** whereis                                                     :whereis:

***** whereis命令

来自: http://man.linuxde.net/whereis

*whereis命令* 用来定位指令的二进制程序、源代码文件和[[http://man.linuxde.net/man][man]]手册页等相关文
件的路径。

whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。

和[[http://man.linuxde.net/find][find]]相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的[[http://man.linuxde.net/locate_slocate][locate]]时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。
但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。

****** 语法\\

#+BEGIN_EXAMPLE
    whereis(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -b：只查找二进制文件；
    -B<目录>：只在设置的目录下查找二进制文件；
    -f：不显示文件名前的路径名称；
    -m：只查找说明文件；
    -M<目录>：只在设置的目录下查找说明文件；
    -s：只查找原始代码文件；
    -S<目录>只在设置的目录下查找原始代码文件；
    -u：查找不包含指定类型的文件。
#+END_EXAMPLE

****** 参数\\

指令名：要查找的二进制程序、源文件和man手册页的指令名。

****** 实例\\

将相关的文件都查找出来

#+BEGIN_EXAMPLE
    [root@localhost ~]# whereis tomcat
    tomcat:

    [root@localhost ~]# whereis svn
    svn: /usr/bin/svn /usr/local/svn /usr/share/man/man1/svn.1.gz
#+END_EXAMPLE

说明：tomcat没安装，找不出来，svn安装找出了很多相关文件

只将二进制文件查找出来 

#+BEGIN_EXAMPLE
    [root@localhost ~]# whereis -b svn
    svn: /usr/bin/svn /usr/local/svn

    [root@localhost ~]# whereis -m svn
    svn: /usr/share/man/man1/svn.1.gz

    [root@localhost ~]# whereis -s svn
    svn:
#+END_EXAMPLE

说明：=whereis -m svn=查出说明文档路径，=whereis -s svn=找source源文件。

*** 文件内容查看

*** 文件处理
**** cat                                                             :cat:

+ 显示文本文件内容
+ 格式: cat [选项] [文件列表]
+ 说明: cat命令还可以用于将两个文件连接到一起，并将结果放到另外一个文
  件中（重定向）

***** cat命令

来自: http://man.linuxde.net/cat

*cat命令* 连接文件并打印到标准输出设备上，cat经常用来显示文件的内容，
类似于下的[[http://man.linuxde.net/type][type]]命令。

注意：当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用[[http://man.linuxde.net/more][more]]等命令分屏显示。为了控制滚屏，可以按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏。按Ctrl+C（中断）键可以终止该命令的执行，并且返回Shell提示符状态。

****** 语法

#+BEGIN_EXAMPLE
    cat(选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -n或-number：有1开始对所有输出的行数编号；
    -b或--number-nonblank：和-n相似，只不过对于空白行不编号；
    -s或--squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行；
    -A：显示不可打印字符，行尾显示“$”；
    -e：等价于"-vE"选项；
    -t：等价于"-vT"选项；
#+END_EXAMPLE

****** 参数

文件列表：指定要连接的文件列表。

****** 实例

设ml和m2是当前目录下的两个文件

#+BEGIN_EXAMPLE
    cat m1 （在屏幕上显示文件ml的内容）
    cat m1 m2 （同时显示文件ml和m2的内容）
    cat m1 m2 > file （将文件ml和m2合并后放入文件file中）
#+END_EXAMPLE

***** [[http://os.51cto.com/art/201104/255359.htm][Linux文件分割与合并：split&cat]] :blog:

Linux下文件分割可以通过split命令来实现，而用cat进行文件合并。而分割可以指定按行数分割和安大小分割两种模式。Linux下文件合并可以通过cat命令来实现，非常简单。

在Linux下用split进行文件分割：

模式一：指定分割后文件行数

对与txt文本文件，可以通过指定分割后文件的行数来进行文件分割。

命令：

split -l 300 large_file.txt new_file_prefix
模式二：指定分割后文件大小

对于可执行文件等二进制文件，则不能通过文件行数来进行文件分割，此时我们可以指定分割大小来分隔文件。

命令：

split -b 10m large_file.bin new_file_prefix
对二进制文件我们同样也可以按文件大小来分隔。

在Linux下用cat进行文件合并：

命令：

cat small_files* > large_file
Linx文件分割命令英文释义：

-, read standard input.

Mandatory arguments to long options are mandatory for short options too.

-a, --suffix-length=N

use suffixes of length N (default 2)

-b, --bytes=SIZE

put SIZE bytes per output file

-C, --line-bytes=SIZE

put at most SIZE bytes of lines per output file

-d, --numeric-suffixes

use numeric suffixes instead of alphabetic

-l, --lines=NUMBER

put NUMBER lines per output file

**** touch                                                         :touch:
***** touch --help
+ 用法：touch [选项]... 文件...
+ 功能: Update the access and modification times of each FILE to the current
  time.
+ FILE arg
  + A FILE argument that does not exist is *created empty*, unless -c
    or -h is supplied.
  + A FILE argument string of *-* is handled specially and causes
    touch to change the times of *the file associated with standard
    output*.
+ options
  + -a			只更改访问时间
  + -c, --no-create	不创建任何文件
  + -d, --date=字符串	使用指定字符串表示时间而非当前时间
  + -f			(忽略)
  + -m			只更改修改时间
  + -r, --reference=FILE   use this file's times instead of current time
  + -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time
  +     --time=WORD        change the specified time:
                           WORD is access, atime, or use: equivalent to -a
                           WORD is modify or mtime: equivalent to -m

请注意，-d 和-t 选项可接受不同的时间/日期格式。
***** touch命令

来自: http://man.linuxde.net/touch

*touch命令* 有两个功能：一是用于把已存在文件的时间标签更新为系统当前的
时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文
件。

****** 语法

#+BEGIN_EXAMPLE
    touch(选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -a：或--time=atime或--time=access或--time=use  只更改存取时间；
    -c：或--no-create  不建立任何文件；
    -d：<时间日期> 使用指定的日期时间，而非现在的时间；
    -f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；
    -m：或--time=mtime或--time=modify  只更该变动时间；
    -r：<参考文件或目录>  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；
    -t：<日期时间>  使用指定的日期时间，而非现在的时间；
    --help：在线帮助；
    --version：显示版本信息。
#+END_EXAMPLE

****** 参数

文件：指定要设置时间属性的文件列表。

****** 实例

#+BEGIN_EXAMPLE
    touch ex2
#+END_EXAMPLE

在当前目录下建立一个空文件ex2，然后，利用=ls -l=命令可以发现文件ex2的大小为0，表示它是空文件。

**** ln                                                               :ln:
***** ln

+ 在文件间创建链接
+ 语法: ln [选项] 源文件或目录 [链接名]
+ 选项
  +  -d    硬链接
  +  -s    符号链接

链接有两种，一种是硬链接(hard link),另一种是符号链接(symbolic link)。硬链
接的意思是一个文件可以有多个名称。而符号链接是产生一个特殊的文件，该文件的
内容指向另外一个文件的位置。建立硬链接时，链接文件和被链接文件必须位于同一
文件系统中，并且不能建立指向目录的硬链接。默认情况下，ln产生硬链接。

ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个
位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时
，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只
要在某个固定的目录，放上该文件，然后在 其它的目录下用 *ln* 命令链接
（link）它就可以，不必重复的占用磁盘空间。

****** 命令格式
ln [参数][源文件或目录][目标文件或目录]
****** 命令功能
Linux文件系统中，有所谓的链接(link)，我们可以将其视为 *档案的别名*,而
链接又可分为两种 :
+ *硬链接* (hard link): 一个档案可以有多个名称
  1. 硬链接，以文件副本的形式存在,但不占用实际空间
  2. 不允许给目录创建硬链接
  3. 硬链接只有在同一个文件系统中才能创建
+ *软链接* (symbolic link): 产生一个特殊的档案，该档案的内容是指向另一
  个档案的位置
  1. 以路径的形式存在。类似于Windows操作系统中的快捷方式
  2. 可以 跨文件系统 ，硬链接不可以
  3. 可以对一个不存在的文件名进行链接
  4. 可以 *对目录进行链接*
     - *目录只能创建软链接*
     - *目录创建链接必须用绝对路径* ，相对路径创建会不成功，会提示：符
       号连接的层数过多 这样的错误

注: *硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统*

第一， *ln命令会保持每一处链接文件的同步性* ，也就是说，不论你改动
了哪一处，其它的文件都会发生相同的变化；

第二，软链接就是 *ln –s 源文件 目标文件* ，它只会在你选定的位置上生成
一个文件的镜像，不会占用磁盘空间，硬链接 *ln 源文件 目标文件* ，没有参
数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链
接还是硬链接，文件都保持同步变化。

ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最
后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录
复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是
一个已存在的目录，则会出现错误信息。
****** 命令参数
|----+--------------------------------------|
| -b | 删除，覆盖以前建立的链接             |
| -d | 允许超级用户制作目录的硬链接         |
| -f | 强制执行                             |
| -i | 交互模式，文件存在则提示用户是否覆盖 |
| -n | 把符号链接视为一般目录               |
| -s | 软链接(符号链接)                     |
| -v | 显示详细的处理过程                   |
|----+--------------------------------------|

****** 删除与重建
1. 源文件被删除后，并没有影响硬链接文件；软链接文件在centos系统下不断
   的闪烁，提示源文件已经不存在
2. 重建源文件后，软链接不在闪烁提示，说明已经链接成功，找到了链 接文件
   系统；重建后，硬链接文件并没有受到源文件影响，硬链接文件的内容还是
   保留了删除前源文件的内容，说明硬链接已经失效

***** ln命令

来自: http://man.linuxde.net/ln

*ln命令* 用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的
连接类型是硬连接。如果要创建符号连接必须使用"-s"选项。

注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。

****** 语法\\

#+BEGIN_EXAMPLE
    ln(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -b或--backup：删除，覆盖目标文件之前的备份；
    -d或-F或——directory：建立目录的硬连接；
    -f或——force：强行建立文件或目录的连接，不论文件或目录是否存在；
    -i或——interactive：覆盖既有文件之前先询问用户；
    -n或--no-dereference：把符号连接的目的目录视为一般文件；
    -s或——symbolic：对源文件建立符号连接，而非硬连接；
    -S<字尾备份字符串>或--suffix=<字尾备份字符串>：用"-b"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它；
    -v或——verbose：显示指令执行过程；
    -V<备份方式>或--version-control=<备份方式>：用“-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用“-S”参数变更，当使用“-V”参数<备份方式>指定不同备份方式时，也会产生不同字尾的备份字符串；
    --help：在线帮助；
    --version：显示版本信息。
#+END_EXAMPLE

****** 参数\\

-  源文件：指定连接的源文件。如果使用=-s=选项创建符号连接，则“源文件”可以是文件或者目录。创建硬连接时，则“源文件”参数只能是文件；
-  目标文件：指定源文件的目标连接文件。

****** 实例\\

将目录=/usr/mengqc/mub1=下的文件m2.c链接到目录=/usr/liu=下的文件a2.c

#+BEGIN_EXAMPLE
    cd /usr/mengqc
    ln /mub1/m2.c /usr/liu/a2.c
#+END_EXAMPLE

在执行ln命令之前，目录=/usr/liu=中不存在a2.c文件。执行ln之后，在=/usr/liu=目录中才有a2.c这一项，表明m2.c和a2.c链接起来（注意，二者在物理上是同一文件），利用=ls -l=命令可以看到链接数的变化。

在目录=/usr/liu=下建立一个符号链接文件abc，使它指向目录=/usr/mengqc/mub1=

#+BEGIN_EXAMPLE
    ln -s /usr/mengqc/mub1 /usr/liu/abc
#+END_EXAMPLE

执行该命令后，=/usr/mengqc/mub1=代表的路径将存放在名为=/usr/liu/abc=的文件中。

****** 扩展知识\\

Linux具有为一个文件起多个名字的功能，称为链接。被链接的文件可以存放在相同的目录下，但是必须有不同的文件名，而不用在硬盘上为同样的数据重复备份。另外，被链接的文件也可以有相同的文件名，但是存放在不同的目录下，这样只要对一个目录下的该文件进行修改，就可以完成对所有目录下同名链接文件的修改。对于某个文件的各链接文件，我们可以给它们指定不同的存取权限，以控制对信息的共享和增强安全性。

文件链接有两种形式，即硬链接和符号链接。

******* 硬链接\\

建立硬链接时，在另外的目录或本目录中增加目标文件的一个目录项，这样，一个文件就登记在多个目录中。如图所示的m2.c文件就在目录mub1和liu中都建立了目录项。

创建硬链接后，己经存在的文件的I节点号（Inode）会被多个目录文件项使用。一个文件的硬链接数可以在目录的长列表格式的第二列中看到，无额外链接的文件的链接数为l。

在默认情况下，ln命令创建硬链接。ln命令会增加链接数，[[http://man.linuxde.net/rm][rm]]命令会减少链接数。一个文件除非链接数为0，否则不会从文件系统中被物理地删除。

对硬链接有如下限制：

-  不能对目录文件做硬链接。
-  不能在不同的文件系统之间做硬链接。就是说，链接文件和被链接文件必须位于同一个文件系统中。

******* 符号链接\\

符号链接也称为软链接，是将一个路径名链接到一个文件。这些文件是一种特别类型的文件。事实上，它只是一个文本文件（如图中的abc文件），其中包含它提供链接的另一个文件的路径名，如图中虚线箭头所示。另一个文件是实际包含所有数据的文件。所有读、写文件内容的命令被用于符号链接时，将沿着链接方向前进来访问实际的文件。

[[http://man.linuxde.net/wp-content/uploads/2013/11/ln.jpg]]

与硬链接不同的是，符号链接确实是一个新文件，当然它具有不同的I节点号；而硬链接并没有建立新文件。

符号链接没有硬链接的限制，可以对目录文件做符号链接，也可以在不同文件系统之间做符号链接。

用=ln -s=命令建立符号链接时，源文件最好用绝对路径名。这样可以在任何工作目录下进行符号链接。而当源文件用相对路径时，如果当前的工作路径与要创建的符号链接文件所在路径不同，就不能进行链接。

符号链接保持了链接与源文件或目录之间的区别：

-  删除源文件或目录，只删除了数据，不会删除链接。一旦以同样文件名创建了源文件，链接将继续指向该文件的新数据。
-  在目录长列表中，符号链接作为一种特殊的文件类型显示出来，其第一个字母是l。
-  符号链接的大小是其链接文件的路径名中的字节数。
-  当用=ln -s=命令列出文件时，可以看到符号链接名后有一个箭头指向源文件或目录，例如=lrwxrwxrwx … 14 jun 20 10:20 /etc/motd->/original_file=其中，表示“文件大小”的数字“14”恰好说明源文件名=original_file=由14个字符构成。

**** dd                                                               :dd:


***** 刻录镜像文件到U盘

the dd command

#+BEGIN_EXAMPLE
dd if=YOUR IMAGE.iso of=/dev/sdx bs=4M
#+END_EXAMPLE

where
1) if= is the path to the .iso file
2) of= is your flash device.

_Make sure to use /dev/sdx and not /dev/sdx1_. You will need a flash
memory device large enough to accommodate the image.

***** reference

+ [[http://www.zhihu.com/question/20414643][知乎：在linux 下刻录系统镜像到U盘中做 Live CD，那些工具比较方便，具体该怎么做？]]

***** dd命令

来自: http://man.linuxde.net/dd

*dd命令* 用于复制文件并对原文件的内容进行转换和格式化处理。dd命令功能
很强大的，对于一些比较底层的问题，使用dd命令往往可以得到出人意料的效果。
用的比较多的还是用dd来备份裸设备。但是不推荐，如果需要备份oracle裸设备，
可以使用rman备份，或使用第三方软件备份，使用dd的话，管理起来不太方便。

建议在有需要的时候使用dd
对物理磁盘操作，如果是文件系统的话还是使用[[http://man.linuxde.net/tar][tar]]
backup
[[http://man.linuxde.net/cpio][cpio]]等其他命令更加方便。另外，使用dd对磁盘操作时，最好使用块设备文件。

****** 语法\\

#+BEGIN_EXAMPLE
    dd(选项)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    bs=<字节数>：将ibs（输入）与欧巴桑（输出）设成指定的字节数；
    cbs=<字节数>：转换时，每次只转换指定的字节数；
    conv=<关键字>：指定文件转换的方式；
    count=<区块数>：仅读取指定的区块数；
    ibs=<字节数>：每次读取的字节数；
    obs=<字节数>：每次输出的字节数；
    of=<文件>：输出到文件；
    seek=<区块数>：一开始输出时，跳过指定的区块数；
    skip=<区块数>：一开始读取时，跳过指定的区块数；
    --help：帮助；
    --version：显示版本信息。
#+END_EXAMPLE

****** 实例\\

*例1：*要把一张软盘的內容复制到另一张软盘上，先将源盘内容制作成img映象文件，然后插入目标空白软盘，将该映象文件写到目标盘上去。 

先插入源盘：

#+BEGIN_EXAMPLE
    dd if=/dev/fd0 of=./temp/temp.img
    2880+0 records in
    2880+0 records out
#+END_EXAMPLE

生成的img文件可以使用WinImage这一类的工具打开并查看。

再插入目标盘：

#+BEGIN_EXAMPLE
    dd if=./temp/temp.img of=/dev/fd0
    2880+0 records in
    2880+0 records out
#+END_EXAMPLE

*例2：*直接将源盘内容复制到目标盘上去，目标盘为已经格式化过的空白软盘。

#+BEGIN_EXAMPLE
    fdformat /dev/fd1
    Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.
    Formatting ... done
    Verifying ... done
#+END_EXAMPLE

上面是格式化目标软盘，使之成为一张空白的没有任何文件系统的软盘。

#+BEGIN_EXAMPLE
    mount /dev/fd0 ./fd0
    mount: block device /dev/fd0 is write-protected, mounting read-only

    ls ./fd0
    boot.msg     initrd.img   options.msg  rescue.msg  splash.lss    vmlinuz
    general.msg  ldlinux.sys  param.msg    snake.msg   syslinux.cfg
#+END_EXAMPLE

上面是挂载源软盘，并查看其中的内容。

#+BEGIN_EXAMPLE
    umount fd0
#+END_EXAMPLE

卸掉源软盘，在使用dd命令的时候，不要挂载任何软盘，已经挂载的要卸掉。

#+BEGIN_EXAMPLE
    dd if=/dev/fd0 of=/dev/fd1
    2880+0 records in
    2880+0 records out
#+END_EXAMPLE

使用dd命令复制源盘内容到目标盘，成功运行后，目标盘将变成和源盘一模一样，文件系统内容也一样。

#+BEGIN_EXAMPLE
    mount /dev/fd1 ./fd1
    ls ./fd1
    boot.msg     initrd.img   options.msg  rescue.msg  splash.lss    vmlinuz
    general.msg  ldlinux.sys  param.msg    snake.msg   syslinux.cfg
#+END_EXAMPLE

挂载目标盘，并查看其中内容，结果和源盘一样。 

*例3：*文件复制功能，将file1复制到file2。 

#+BEGIN_EXAMPLE
    dd if=file1 of=file2
    0+1 records in
    0+1 records out
#+END_EXAMPLE

*例4：*写512字节到文件中

#+BEGIN_EXAMPLE
    dd if=/dev/zero of=./myfile bs=512 count=1

    或(count默认为1)：
    dd if=/dev/zero of=./myfile bs=512

    或(bs默认为512)：
    dd if=/dev/zero of=./myfile count=1

    但这样是不行的，它将一直填充：
    dd if=/dev/zero of=./myfile
#+END_EXAMPLE

使用软盘做钥匙盘在我的记忆中似乎是很遥远的事情了，第一次见到是一套计算机等级考试的软件。如果使用文件的复制的方法把软盘的资料copy到另外一个软盘，那肯定会告诉你这不是一张有效的钥匙盘。那个时候也没有想到比较好的办法。今天又有人拿一个钥匙盘过来，问我能不能破解，我的第一反应就是使用linux的dd命令。

操作过程如下：

1、插入正确的钥匙盘，执行下面的命令

#+BEGIN_EXAMPLE
    dd if=/dev/fd0 of=fd0.img
#+END_EXAMPLE

2、取出钥匙盘，插入你要复制的空白软盘(当然不是空白的也没有什么问题)，执行下面的命令：

#+BEGIN_EXAMPLE
    dd if=fd0.img of=/dev/fd0
#+END_EXAMPLE

ok，取出你的复制的软盘，测试一下，看有没有问题！

**** progress                                                :cv:progress:
***** [[https://linuxtoy.org/archives/cv.html][cv: 显示 cp、mv等命令的进度]]                         :blog:cv:mv:cp:

在 Linux 系统中，大多数命令从来都是信奉“沉默是金”的准则，所以当我们利用
=cp=
复制文件的时候并不能看到所谓的进度条。如果你在意这一点，那么不妨来用用
[[https://github.com/Xfennec/cv][cv]]。

[[https://linuxtoy.org/img/2014/07/cv.png]]

cv 是 Coreutils
Viewer，它能够显示传输数据的进度，包括百分比、大小、以及速率等信息。cv
支持 coreutils 中的基本命令，比如 cp、mv、rm、dd、tar 等等。

cv 的源代码可从 [[https://github.com/Xfennec/cv][GitHub]] 获取，需要自行编译。
***** progress - Coreutils Progress Viewer                       :github:
****** What is it?

This tool can be described as a *Tiny*, Dirty, Linux-and-OSX-Only C
command that looks for coreutils basic commands (cp, mv, dd, tar,
gzip/gunzip, cat, etc.) currently running on your system and displays
the *percentage* of copied data. It can also show *estimated time* and
*throughput*, and provides a "top-like" mode (monitoring).

#+CAPTION: progress screenshot with cp and mv

[[https://raw.github.com/Xfennec/progress/master/capture.png]]
/(After many requests: the colors in the shell come from
[[https://github.com/milkbikis/powerline-shell][powerline-shell]]. Try
it, it's cool.)/

Formerly known as cv (Coreutils Viewer).

****** How do you build it?

#+BEGIN_EXAMPLE
    make && make install
#+END_EXAMPLE

It depends on library ncurses, you may have to install corresponding
packages (may be something like 'libncurses5-dev' or 'ncurses-devel').

****** How do you run it?

Just launch the binary, =progress=.

****** What can I do with it?

A few examples. You can:

-  monitor all current and upcoming instances of coreutils commands in a
   simple window:

   #+BEGIN_EXAMPLE
       watch progress -q
   #+END_EXAMPLE

-  see how your download is progressing:

   #+BEGIN_EXAMPLE
       watch progress -wc firefox
   #+END_EXAMPLE

-  look at your Web server activity:

   #+BEGIN_EXAMPLE
       progress -c httpd
   #+END_EXAMPLE

-  launch and monitor any heavy command using =$!=:

   #+BEGIN_EXAMPLE
       cp bigfile newfile & progress -mp $!
   #+END_EXAMPLE

and much more.

****** How does it work?

It simply scans =/proc= for interesting commands, and then looks at
directories =fd= and =fdinfo= to find opened files and seek positions,
and reports status for the largest file.

It's very light, and compatible with virtually any command.

***** help

progress - Coreutils Viewer
---------------------
Shows progress on file manipulations (cp, mv, dd, ...)

Monitored commands (default):
cp mv dd tar cat rsync grep fgrep egrep cut sort md5sum sha1sum sha224sum sha256sum sha384sum sha512sum adb gzip gunzip bzip2 bunzip2 xz unxz lzma unlzma zcat bzcat lzcat

Usage: progress [-qdwmM] [-W secs] [-c command] [-p pid]
  -q --quiet                 hides all messages
  -d --debug                 shows all warning/error messages
  -w --wait                  estimate I/O throughput and ETA (slower display)
  -W --wait-delay secs       wait 'secs' seconds for I/O estimation (implies -w, default=1.0)
  -m --monitor               loop while monitored processes are still running
  -M --monitor-continuously  like monitor but never stop (similar to watch progress)
  -c --command cmd           monitor only this command name (ex: firefox)
  -p --pid id                monitor only this process ID (ex: `pidof firefox`)
  -i --ignore-file file      do not report process if using file
  -o --open-mode {r|w}       report only files opened for read or write
  -v --version               show program version and exit
  -h --help                  display this help and exit

*** 文件编辑
**** sed                                                             :sed:
***** sed入门
****** what
sed（意为流编辑器，源自英语“stream editor”的缩写）是Unix常见的命令行
程序。sed用来把文档或字符串里面的文字经过一系列编辑命令转换为另一种格
式输出。sed通常用来匹配一个或多个正则表达式的文本进行处理。

****** s 匹配与替换
+ *sed 模式 输入文件*
+ *s* 表示替换命令
+ */g* 表示一行上替换所有的匹配
+ sed不会对输入文件的内容进行改变，除非使用重定向
+ 或者使用 *-i* 选项

******* s 命令替换
1. 准备
   #+BEGIN_SRC sh :session sed_session :exports code
     cd /tmp
     > pets.txt
     echo -n "This is my cat," >> pets.txt
     echo  "my cat's name is betty" >> pets.txt
     echo -n "This is my dog," >> pets.txt
     echo "my dog's name is frank" >> pets.txt
     echo -n "This is my fish," >> pets.txt
     echo  "my fish's name is george" >> pets.txt
     echo -n "This is my goat," >> pets.txt
     echo  "my goat's name is adam" >> pets.txt
   #+END_SRC

   #+RESULTS:

   注： org-babel 使用:session参数时要注意命令中的回车可能使执行一直处于
   等待状态。

   #+RESULTS:

   #+BEGIN_SRC sh :exports both :session sed_session :results output
    cat pets.txt
   #+END_SRC

   #+RESULTS:
   : this is my cat,my cat's name is betty
   : This is my dog,my dog's name is frank
   : This is my fish,my fish's name is george
   : This is my goat,my goat's name is adam

2. -s 替换

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed "s/my/your/g" pets.txt
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty
   : This is your dog,your dog's name is frank
   : This is your fish,your fish's name is george
   : This is your goat,your goat's name is adam

3. 写入
   + 重定向
   + -i

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed -i "s/my/your/g" pets.txt
   cat pets.txt
   #+END_SRC

   #+RESULTS:
   :
   : This is your cat,your cat's name is betty
   : This is your dog,your dog's name is frank
   : This is your fish,your fish's name is george
   : This is your goat,your goat's name is adam

4. 行前
   + *^* 表示一行的开头
   + *$* 表示一行的结尾
   + *\<* 表示词首
   + *\>* 表示词尾
   + 以上是正则表达式的最基本的内容

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed "s/^/:/g" pets.txt
   #+END_SRC

   #+RESULTS:
   : :this is your cat,your cat's name is betty
   : :This is your dog,your dog's name is frank
   : :This is your fish,your fish's name is george
   : :This is your goat,your goat's name is adam

   注： 行首#在babel输出可能有问题

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed 's/$/:/g' pets.txt
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty:
   : this is your dog,your dog's name is frank:
   : this is your fish,your fish's name is george:
   : this is your goat,your goat's name is adam:

5. 指定行替换
   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed "3s/your/my/g" pets.txt  # 替换第三行
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty
   : This is your dog,your dog's name is frank
   : This is my fish,my fish's name is george
   : This is your goat,your goat's name is adam

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed "3,6s/your/my/g" pets.txt  # 替换3～6行
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty
   : This is your dog,your dog's name is frank
   : This is my fish,my fish's name is george
   : This is my goat,my goat's name is adam

6. 替换行中的指定匹配项
   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed 's/s/S/1' pets.txt    # 替换匹配的第一项
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty
   : ThiS is your dog,your dog's name is frank
   : ThiS is your fish,your fish's name is george
   : ThiS is your goat,your goat's name is adam

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed "s/s/S/2" pets.txt   # 替换第二项
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty
   : This iS your dog,your dog's name is frank
   : This iS your fish,your fish's name is george
   : This iS your goat,your goat's name is adam

   #+BEGIN_SRC sh :exports both :session sed_session :results output
   sed 's/s/S/1g' pets.txt    # 替换某一项之后的
   #+END_SRC

   #+RESULTS:
   : this is your cat,your cat's name is betty
   : ThiS iS your dog,your dog'S name iS frank
   : ThiS iS your fiSh,your fiSh'S name iS george
   : ThiS iS your goat,your goat'S name iS adam

******* 多个匹配
+ 使用多个分号将匹配分隔
+ 相当于 *-e* 选项


#+BEGIN_SRC sh :exports both :session sed_session :results output
sed "1s/your/my/g; 2s/name/NAME/g" pets.txt
#+END_SRC

#+RESULTS:
: this is my cat,my cat's name is betty
: This is your dog,your dog's NAME is frank
: This is your fish,your fish's name is george
: This is your goat,your goat's name is adam

#+BEGIN_SRC sh :exports both :session sed_session :results output
sed -e "1s/your/my/g" -e "2s/name/NAME/g" pets.txt
#+END_SRC

#+RESULTS:
: this is my cat,my cat's name is betty
: This is your dog,your dog's NAME is frank
: This is your fish,your fish's name is george
: This is your goat,your goat's name is adam

******* 圆括号匹配，即后向引用
+ [^,] 表示除了,以外的任意字符(正则表达式的基本知识)

#+BEGIN_SRC sh :exports both :session sed_session :results output
sed 's/This is your \([^,]*\),.*is *\(.*\)/\1:\2/g' pets.txt
#+END_SRC

#+RESULTS:
: cat:betty
: dog:frank
: fish:george
: goat:adam

****** 其它命令
+ N
+ a(append)
+ i(insert)
+ c：替换匹配行
+ d: 删除匹配行
+ p: 打印命令

***** sed命令

来自: http://man.linuxde.net/sed

*sed* 是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表
达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为
“模式空间”（pattern
space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有
改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。

****** sed的选项、命令、替换标记\\

*命令格式*

#+BEGIN_EXAMPLE
    sed [options] 'command' file(s)
    sed [options] -f scriptfile file(s)
#+END_EXAMPLE

******* 选项\\

#+BEGIN_EXAMPLE
    -e<script>或--expression=<script>：以选项中的指定的script来处理输入的文本文件；
    -f<script文件>或--file=<script文件>：以选项中指定的script文件来处理输入的文本文件；
    -h或--help：显示帮助；
    -n或--quiet或——silent：仅显示script处理后的结果；
    -V或--version：显示版本信息。
#+END_EXAMPLE

******* 参数\\

文件：指定待处理的文本文件列表。

******* sed命令\\

#+BEGIN_EXAMPLE
    a\ 在当前行下面插入文本。
    i\ 在当前行上面插入文本。
    c\ 把选定的行改为新的文本。
    d 删除，删除选择的行。
    D 删除模板块的第一行。
    s 替换指定字符
    h 拷贝模板块的内容到内存中的缓冲区。
    H 追加模板块的内容到内存中的缓冲区。
    g 获得内存缓冲区的内容，并替代当前模板块中的文本。
    G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。
    l 列表不能打印字符的清单。
    n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。
    N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。
    p 打印模板块的行。
    P(大写) 打印模板块的第一行。
    q 退出Sed。
    b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。
    r file 从file中读行。
    t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
    T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
    w file 写并追加模板块到file末尾。
    W file 写并追加模板块的第一行到file末尾。
    ! 表示后面的命令对所有没有被选定的行发生作用。
    = 打印当前行号码。
    # 把注释扩展到下一个换行符以前。
#+END_EXAMPLE

******* sed替换标记\\

#+BEGIN_EXAMPLE
    g 表示行内全面替换。
    p 表示打印行。
    w 表示把行写入一个文件。
    x 表示互换模板块中的文本和缓冲区中的文本。
    y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）
    \1 子串匹配标记
    & 已匹配字符串标记
#+END_EXAMPLE

******* sed元字符集\\

#+BEGIN_EXAMPLE
    ^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。
    $ 匹配行结束，如：/sed$/匹配所有以sed结尾的行。
    . 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。
    * 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。
    [] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。
    [^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。
    \(..\) 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。
    & 保存搜索字符用来替换其他字符，如s/love/**&**/，love这成**love**。
    \< 匹配单词的开始，如:/\<love/匹配包含以love开头的单词的行。
    \> 匹配单词的结束，如/love\>/匹配包含以love结尾的单词的行。
    x\{m\} 重复字符x，m次，如：/0\{5\}/匹配包含5个0的行。
    x\{m,\} 重复字符x，至少m次，如：/0\{5,\}/匹配至少有5个0的行。
    x\{m,n\} 重复字符x，至少m次，不多于n次，如：/0\{5,10\}/匹配5~10个0的行。
#+END_EXAMPLE

****** sed用法实例\\

******* 替换操作：s命令\\

替换文本中的字符串：

#+BEGIN_EXAMPLE
    sed 's/book/books/' file
#+END_EXAMPLE

*-n选项*和*p命令*一起使用表示只打印那些发生替换的行：

sed -n 's/[[http://man.linuxde.net/test][test]]/TEST/p' file

直接编辑文件*选项-i*，会匹配file文件中每一行的第一个book替换为books：

#+BEGIN_EXAMPLE
    sed -i 's/book/books/g' file
#+END_EXAMPLE

******* 全面替换标记g\\

使用后缀 /g 标记会替换每一行中的所有匹配：

#+BEGIN_EXAMPLE
    sed 's/book/books/g' file
#+END_EXAMPLE

当需要从第N处匹配开始替换时，可以使用 /Ng：

#+BEGIN_EXAMPLE
    echo sksksksksksk | sed 's/sk/SK/2g'
    skSKSKSKSKSK

    echo sksksksksksk | sed 's/sk/SK/3g'
    skskSKSKSKSK

    echo sksksksksksk | sed 's/sk/SK/4g'
    skskskSKSKSK
#+END_EXAMPLE

******* 定界符\\

以上命令中字符 / 在sed中作为定界符使用，也可以使用任意的定界符：

#+BEGIN_EXAMPLE
    sed 's:test:TEXT:g'
    sed 's|test|TEXT|g'
#+END_EXAMPLE

定界符出现在样式内部时，需要进行转义：

#+BEGIN_EXAMPLE
    sed 's/\/bin/\/usr\/local\/bin/g'
#+END_EXAMPLE

******* 删除操作：d命令\\

删除空白行：

#+BEGIN_EXAMPLE
    sed '/^$/d' file
#+END_EXAMPLE

删除文件的第2行：

#+BEGIN_EXAMPLE
    sed '2d' file
#+END_EXAMPLE

删除文件的第2行到末尾所有行：

#+BEGIN_EXAMPLE
    sed '2,$d' file
#+END_EXAMPLE

删除文件最后一行：

#+BEGIN_EXAMPLE
    sed '$d' file
#+END_EXAMPLE

删除文件中所有开头是test的行：

#+BEGIN_EXAMPLE
    sed '/^test/'d file
#+END_EXAMPLE

******* 已匹配字符串标记&\\

正则表达式 \w\+ 匹配每一个单词，使用 [&] 替换它，&
对应于之前所匹配到的单词：

#+BEGIN_EXAMPLE
    echo this is a test line | sed 's/\w\+/[&]/g'
    [this] [is] [a] [test] [line]
#+END_EXAMPLE

所有以192.168.0.1开头的行都会被替换成它自已加localhost：

#+BEGIN_EXAMPLE
    sed 's/^192.168.0.1/&localhost/' file
    192.168.0.1localhost
#+END_EXAMPLE

******* 子串匹配标记\1\\

匹配给定样式的其中一部分：

#+BEGIN_EXAMPLE
    echo this is digit 7 in a number | sed 's/digit \([0-9]\)/\1/'
    this is 7 in a number
#+END_EXAMPLE

命令中 digit 7，被替换成了 7。样式匹配到的子串是 7，\(..\)
用于匹配子串，对于匹配到的第一个子串就标记为
*\1*，依此类推匹配到的第二个结果就是 *\2*，例如：

#+BEGIN_EXAMPLE
    echo aaa BBB | sed 's/\([a-z]\+\) \([A-Z]\+\)/\2 \1/'
    BBB aaa
#+END_EXAMPLE

love被标记为1，所有loveable会被替换成lovers，并打印出来：

#+BEGIN_EXAMPLE
    sed -n 's/\(love\)able/\1rs/p' file
#+END_EXAMPLE

******* 组合多个表达式\\

#+BEGIN_EXAMPLE
    sed '表达式' | sed '表达式'

    等价于：

    sed '表达式; 表达式'
#+END_EXAMPLE

******* 引用\\

sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。

#+BEGIN_EXAMPLE
    test=hello
    echo hello WORLD | sed "s/$test/HELLO"
    HELLO WORLD
#+END_EXAMPLE

******* 选定行的范围：,（逗号）\\

所有在模板test和check所确定的范围内的行都被打印：

#+BEGIN_EXAMPLE
    sed -n '/test/,/check/p' file
#+END_EXAMPLE

打印从第5行开始到第一个包含以test开始的行之间的所有行：

#+BEGIN_EXAMPLE
    sed -n '5,/^test/p' file
#+END_EXAMPLE

对于模板test和west之间的行，每行的末尾用字符串aaa bbb替换：

#+BEGIN_EXAMPLE
    sed '/test/,/west/s/$/aaa bbb/' file
#+END_EXAMPLE

******* 多点编辑：e命令\\

-e选项允许在同一行里执行多条命令：

#+BEGIN_EXAMPLE
    sed -e '1,5d' -e 's/test/check/' file
#+END_EXAMPLE

上面sed表达式的第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。

和 -e 等价的命令是 --expression：

#+BEGIN_EXAMPLE
    sed --expression='s/test/check/' --expression='/love/d' file
#+END_EXAMPLE

******* 从文件读入：r命令\\

file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面：

#+BEGIN_EXAMPLE
    sed '/test/r file' filename
#+END_EXAMPLE

******* 写入文件：w命令  \\

在example中所有包含test的行都被写入file里：

#+BEGIN_EXAMPLE
    sed -n '/test/w file' example
#+END_EXAMPLE

******* 追加（行下）：a\命令\\

将 this is a test line 追加到 以test 开头的行后面：

#+BEGIN_EXAMPLE
    sed '/^test/a\this is a test line' file
#+END_EXAMPLE

在 test.conf 文件第2行之后插入 this is a test line：

#+BEGIN_EXAMPLE
    sed -i '2a\this is a test line' test.conf
#+END_EXAMPLE

******* 插入（行上）：i\命令\\

将 this is a test line 追加到以test开头的行前面：

#+BEGIN_EXAMPLE
    sed '/^test/i\this is a test line' file
#+END_EXAMPLE

在test.conf文件第5行之前插入this is a test line：

#+BEGIN_EXAMPLE
    sed -i '5i\this is a test line' test.conf
#+END_EXAMPLE

******* 下一个：n命令\\

如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续：

#+BEGIN_EXAMPLE
    sed '/test/{ n; s/aa/bb/; }' file
#+END_EXAMPLE

******* 变形：y命令\\

把1~10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令：

#+BEGIN_EXAMPLE
    sed '1,10y/abcde/ABCDE/' file
#+END_EXAMPLE

******* 退出：q命令\\

打印完第10行后，退出sed

#+BEGIN_EXAMPLE
    sed '10q' file
#+END_EXAMPLE

******* 保持和获取：h命令和G命令\\

在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将
打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。

#+BEGIN_EXAMPLE
    sed -e '/test/h' -e '$G' file
#+END_EXAMPLE

在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。

******* 保持和互换：h命令和x命令\\

互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换：

#+BEGIN_EXAMPLE
    sed -e '/test/h' -e '/check/x' file
#+END_EXAMPLE

******* 脚本scriptfile\\

sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。

#+BEGIN_EXAMPLE
    sed [options] -f scriptfile file(s)
#+END_EXAMPLE

******* 打印奇数行或偶数行\\

方法1：

#+BEGIN_EXAMPLE
    sed -n 'p;n' test.txt  #奇数行
    sed -n 'n;p' test.txt  #偶数行
#+END_EXAMPLE

方法2：

#+BEGIN_EXAMPLE
    sed -n '1~2p' test.txt  #奇数行
    sed -n '2~2p' test.txt  #偶数行
#+END_EXAMPLE

******* 打印匹配字符串的下一行\\

#+BEGIN_EXAMPLE
    grep -A 1 SCC URFILE
    sed -n '/SCC/{n;p}' URFILE
    awk '/SCC/{getline; print}' URFILE
#+END_EXAMPLE

***** [[http://sed.sourceforge.net/sed1line_zh-CN.html][SED单行脚本快速参考（Unix 流编辑器）]]

英文标题：USEFUL ONE-LINE SCRIPTS FOR SED (Unix stream editor)
原标题：HANDY ONE-LINERS FOR SED (Unix stream editor)

整理：Eric Pement  - 电邮：pemente[at]northpark[dot]edu         版本5.5
译者：Joe Hong     - 电邮：hq00e[at]126[dot]com

在以下地址可找到本文档的最新（英文）版本：
   http://sed.sourceforge.net/sed1line.txt
   http://www.pement.org/sed/sed1line.txt

其他语言版本：
  中文          - http://sed.sourceforge.net/sed1line_zh-CN.html
  捷克语        - http://sed.sourceforge.net/sed1line_cz.html
  荷语          - http://sed.sourceforge.net/sed1line_nl.html
  法语          - http://sed.sourceforge.net/sed1line_fr.html
  德语          - http://sed.sourceforge.net/sed1line_de.html

  葡语          - http://sed.sourceforge.net/sed1line_pt-BR.html

****** 文本间隔：
--------

 # 在每一行后面增加一空行
 sed G

 # 将原来的所有空行删除并在每一行后面增加一空行。
 # 这样在输出的文本中每一行后面将有且只有一空行。
 sed '/^$/d;G'

 # 在每一行后面增加两行空行
 sed 'G;G'

 # 将第一个脚本所产生的所有空行删除（即删除所有偶数行）
 sed 'n;d'

 # 在匹配式样“regex”的行之前插入一空行
 sed '/regex/{x;p;x;}'

 # 在匹配式样“regex”的行之后插入一空行
 sed '/regex/G'

 # 在匹配式样“regex”的行之前和之后各插入一空行
 sed '/regex/{x;p;x;G;}'

****** 编号
--------

 # 为文件中的每一行进行编号（简单的左对齐方式）。这里使用了“制表符”
 # （tab，见本文末尾关于'\t'的用法的描述）而不是空格来对齐边缘。
 sed = filename | sed 'N;s/\n/\t/'

 # 对文件中的所有行编号（行号在左，文字右端对齐）。
 sed = filename | sed 'N; s/^/     /; s/ *\(.\{6,\}\)\n/\1  /'

 # 对文件中的所有行编号，但只显示非空白行的行号。
 sed '/./=' filename | sed '/./N; s/\n/ /'

 # 计算行数 （模拟 "wc -l"）
 sed -n '$='

****** 文本转换和替代：
--------

 # Unix环境：转换DOS的新行符（CR/LF）为Unix格式。
 sed 's/.$//'                     # 假设所有行以CR/LF结束
 sed 's/^M$//'                    # 在bash/tcsh中，将按Ctrl-M改为按Ctrl-V
 sed 's/\x0D$//'                  # ssed、gsed 3.02.80，及更高版本

 # Unix环境：转换Unix的新行符（LF）为DOS格式。
 sed "s/$/`echo -e \\\r`/"        # 在ksh下所使用的命令
 sed 's/$'"/`echo \\\r`/"         # 在bash下所使用的命令
 sed "s/$/`echo \\\r`/"           # 在zsh下所使用的命令
 sed 's/$/\r/'                    # gsed 3.02.80 及更高版本

 # DOS环境：转换Unix新行符（LF）为DOS格式。
 sed "s/$//"                      # 方法 1
 sed -n p                         # 方法 2

 # DOS环境：转换DOS新行符（CR/LF）为Unix格式。
 # 下面的脚本只对UnxUtils sed 4.0.7 及更高版本有效。要识别UnxUtils版本的
 #  sed可以通过其特有的“--text”选项。你可以使用帮助选项（“--help”）看
 # 其中有无一个“--text”项以此来判断所使用的是否是UnxUtils版本。其它DOS
 # 版本的的sed则无法进行这一转换。但可以用“tr”来实现这一转换。
 sed "s/\r//" infile >outfile     # UnxUtils sed v4.0.7 或更高版本
 tr -d \r <infile >outfile        # GNU tr 1.22 或更高版本

 # 将每一行前导的“空白字符”（空格，制表符）删除
 # 使之左对齐
 sed 's/^[ \t]*//'                # 见本文末尾关于'\t'用法的描述

 # 将每一行拖尾的“空白字符”（空格，制表符）删除
 sed 's/[ \t]*$//'                # 见本文末尾关于'\t'用法的描述

 # 将每一行中的前导和拖尾的空白字符删除
 sed 's/^[ \t]*//;s/[ \t]*$//'

 # 在每一行开头处插入5个空格（使全文向右移动5个字符的位置）
 sed 's/^/     /'

 # 以79个字符为宽度，将所有文本右对齐
 sed -e :a -e 's/^.\{1,78\}$/ &/;ta'  # 78个字符外加最后的一个空格

 # 以79个字符为宽度，使所有文本居中。在方法1中，为了让文本居中每一行的前
 # 头和后头都填充了空格。 在方法2中，在居中文本的过程中只在文本的前面填充
 # 空格，并且最终这些空格将有一半会被删除。此外每一行的后头并未填充空格。
 sed  -e :a -e 's/^.\{1,77\}$/ & /;ta'                     # 方法1
 sed  -e :a -e 's/^.\{1,77\}$/ &/;ta' -e 's/\( *\)\1/\1/'  # 方法2

 # 在每一行中查找字串“foo”，并将找到的“foo”替换为“bar”
 sed 's/foo/bar/'                 # 只替换每一行中的第一个“foo”字串
 sed 's/foo/bar/4'                # 只替换每一行中的第四个“foo”字串
 sed 's/foo/bar/g'                # 将每一行中的所有“foo”都换成“bar”
 sed 's/\(.*\)foo\(.*foo\)/\1bar\2/' # 替换倒数第二个“foo”
 sed 's/\(.*\)foo/\1bar/'            # 替换最后一个“foo”

 # 只在行中出现字串“baz”的情况下将“foo”替换成“bar”
 sed '/baz/s/foo/bar/g'

 # 将“foo”替换成“bar”，并且只在行中未出现字串“baz”的情况下替换
 sed '/baz/!s/foo/bar/g'

 # 不管是“scarlet”“ruby”还是“puce”，一律换成“red”
 sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g'  #对多数的sed都有效
 gsed 's/scarlet\|ruby\|puce/red/g'               # 只对GNU sed有效

 # 倒置所有行，第一行成为最后一行，依次类推（模拟“tac”）。
 # 由于某些原因，使用下面命令时HHsed v1.5会将文件中的空行删除
 sed '1!G;h;$!d'               # 方法1
 sed -n '1!G;h;$p'             # 方法2

 # 将行中的字符逆序排列，第一个字成为最后一字，……（模拟“rev”）
 sed '/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//'

 # 将每两行连接成一行（类似“paste”）
 sed '$!N;s/\n/ /'

 # 如果当前行以反斜杠“\”结束，则将下一行并到当前行末尾
 # 并去掉原来行尾的反斜杠
 sed -e :a -e '/\\$/N; s/\\\n//; ta'

 # 如果当前行以等号开头，将当前行并到上一行末尾
 # 并以单个空格代替原来行头的“=”
 sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D'

 # 为数字字串增加逗号分隔符号，将“1234567”改为“1,234,567”
 gsed ':a;s/\B[0-9]\{3\}\>/,&/;ta'                     # GNU sed
 sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta'  # 其他sed

 # 为带有小数点和负号的数值增加逗号分隔符（GNU sed）
 gsed -r ':a;s/(^|[^0-9.])([0-9]+)([0-9]{3})/\1\2,\3/g;ta'

 # 在每5行后增加一空白行 （在第5，10，15，20，等行后增加一空白行）
 gsed '0~5G'                      # 只对GNU sed有效
 sed 'n;n;n;n;G;'                 # 其他sed

****** 选择性地显示特定行：
--------

 # 显示文件中的前10行 （模拟“head”的行为）
 sed 10q

 # 显示文件中的第一行 （模拟“head -1”命令）
 sed q

 # 显示文件中的最后10行 （模拟“tail”）
 sed -e :a -e '$q;N;11,$D;ba'

 # 显示文件中的最后2行（模拟“tail -2”命令）
 sed '$!N;$!D'

 # 显示文件中的最后一行（模拟“tail -1”）
 sed '$!d'                        # 方法1
 sed -n '$p'                      # 方法2

 # 显示文件中的倒数第二行
 sed -e '$!{h;d;}' -e x              # 当文件中只有一行时，输入空行
 sed -e '1{$q;}' -e '$!{h;d;}' -e x  # 当文件中只有一行时，显示该行
 sed -e '1{$d;}' -e '$!{h;d;}' -e x  # 当文件中只有一行时，不输出

 # 只显示匹配正则表达式的行（模拟“grep”）
 sed -n '/regexp/p'               # 方法1
 sed '/regexp/!d'                 # 方法2

 # 只显示“不”匹配正则表达式的行（模拟“grep -v”）
 sed -n '/regexp/!p'              # 方法1，与前面的命令相对应
 sed '/regexp/d'                  # 方法2，类似的语法

 # 查找“regexp”并将匹配行的上一行显示出来，但并不显示匹配行
 sed -n '/regexp/{g;1!p;};h'

 # 查找“regexp”并将匹配行的下一行显示出来，但并不显示匹配行
 sed -n '/regexp/{n;p;}'

 # 显示包含“regexp”的行及其前后行，并在第一行之前加上“regexp”所
 # 在行的行号 （类似“grep -A1 -B1”）
 sed -n -e '/regexp/{=;x;1!p;g;$!N;p;D;}' -e h

 # 显示包含“AAA”、“BBB”或“CCC”的行（任意次序）
 sed '/AAA/!d; /BBB/!d; /CCC/!d'  # 字串的次序不影响结果

 # 显示包含“AAA”、“BBB”和“CCC”的行（固定次序）
 sed '/AAA.*BBB.*CCC/!d'

 # 显示包含“AAA”“BBB”或“CCC”的行 （模拟“egrep”）
 sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d    # 多数sed
 gsed '/AAA\|BBB\|CCC/!d'                        # 对GNU sed有效

 # 显示包含“AAA”的段落 （段落间以空行分隔）
 # HHsed v1.5 必须在“x;”后加入“G;”，接下来的3个脚本都是这样
 sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;'

 # 显示包含“AAA”“BBB”和“CCC”三个字串的段落 （任意次序）
 sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;/BBB/!d;/CCC/!d'

 # 显示包含“AAA”、“BBB”、“CCC”三者中任一字串的段落 （任意次序）
 sed -e '/./{H;$!d;}' -e 'x;/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d
 gsed '/./{H;$!d;};x;/AAA\|BBB\|CCC/b;d'         # 只对GNU sed有效

 # 显示包含65个或以上字符的行
 sed -n '/^.\{65\}/p'

 # 显示包含65个以下字符的行
 sed -n '/^.\{65\}/!p'            # 方法1，与上面的脚本相对应
 sed '/^.\{65\}/d'                # 方法2，更简便一点的方法

 # 显示部分文本——从包含正则表达式的行开始到最后一行结束
 sed -n '/regexp/,$p'

 # 显示部分文本——指定行号范围（从第8至第12行，含8和12行）
 sed -n '8,12p'                   # 方法1
 sed '8,12!d'                     # 方法2

 # 显示第52行
 sed -n '52p'                     # 方法1
 sed '52!d'                       # 方法2
 sed '52q;d'                      # 方法3, 处理大文件时更有效率

 # 从第3行开始，每7行显示一次
 gsed -n '3~7p'                   # 只对GNU sed有效
 sed -n '3,${p;n;n;n;n;n;n;}'     # 其他sed

 # 显示两个正则表达式之间的文本（包含）
 sed -n '/Iowa/,/Montana/p'       # 区分大小写方式

****** 选择性地删除特定行：
--------

 # 显示通篇文档，除了两个正则表达式之间的内容
 sed '/Iowa/,/Montana/d'

 # 删除文件中相邻的重复行（模拟“uniq”）
 # 只保留重复行中的第一行，其他行删除
 sed '$!N; /^\(.*\)\n\1$/!P; D'

 # 删除文件中的重复行，不管有无相邻。注意hold space所能支持的缓存
 # 大小，或者使用GNU sed。
 sed -n 'G; s/\n/&&/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P'

 # 删除除重复行外的所有行（模拟“uniq -d”）
 sed '$!N; s/^\(.*\)\n\1$/\1/; t; D'

 # 删除文件中开头的10行
 sed '1,10d'

 # 删除文件中的最后一行
 sed '$d'

 # 删除文件中的最后两行
 sed 'N;$!P;$!D;$d'

 # 删除文件中的最后10行
 sed -e :a -e '$d;N;2,10ba' -e 'P;D'   # 方法1
 sed -n -e :a -e '1,10!{P;N;D;};N;ba'  # 方法2

 # 删除8的倍数行
 gsed '0~8d'                           # 只对GNU sed有效
 sed 'n;n;n;n;n;n;n;d;'                # 其他sed

 # 删除匹配式样的行
 sed '/pattern/d'                      # 删除含pattern的行。当然pattern
                                       # 可以换成任何有效的正则表达式

 # 删除文件中的所有空行（与“grep '.' ”效果相同）
 sed '/^$/d'                           # 方法1
 sed '/./!d'                           # 方法2

 # 只保留多个相邻空行的第一行。并且删除文件顶部和尾部的空行。
 # （模拟“cat -s”）
 sed '/./,/^$/!d'        #方法1，删除文件顶部的空行，允许尾部保留一空行
 sed '/^$/N;/\n$/D'      #方法2，允许顶部保留一空行，尾部不留空行

 # 只保留多个相邻空行的前两行。
 sed '/^$/N;/\n$/N;//D'

 # 删除文件顶部的所有空行
 sed '/./,$!d'

 # 删除文件尾部的所有空行
 sed -e :a -e '/^\n*$/{$d;N;ba' -e '}'  # 对所有sed有效
 sed -e :a -e '/^\n*$/N;/\n$/ba'        # 同上，但只对 gsed 3.02.*有效

 # 删除每个段落的最后一行
 sed -n '/^$/{p;h;};/./{x;/./p;}'

****** 特殊应用：
--------

 # 移除手册页（man page）中的nroff标记。在Unix System V或bash shell下使
 # 用'echo'命令时可能需要加上 -e 选项。
 sed "s/.`echo \\\b`//g"    # 外层的双括号是必须的（Unix环境）
 sed 's/.^H//g'             # 在bash或tcsh中, 按 Ctrl-V 再按 Ctrl-H
 sed 's/.\x08//g'           # sed 1.5，GNU sed，ssed所使用的十六进制的表示方法

 # 提取新闻组或 e-mail 的邮件头
 sed '/^$/q'                # 删除第一行空行后的所有内容

 # 提取新闻组或 e-mail 的正文部分
 sed '1,/^$/d'              # 删除第一行空行之前的所有内容

 # 从邮件头提取“Subject”（标题栏字段），并移除开头的“Subject:”字样
 sed '/^Subject: */!d; s///;q'

 # 从邮件头获得回复地址
 sed '/^Reply-To:/q; /^From:/h; /./d;g;q'

 # 获取邮件地址。在上一个脚本所产生的那一行邮件头的基础上进一步的将非电邮
 # 地址的部分剃除。（见上一脚本）
 sed 's/ *(.*)//; s/>.*//; s/.*[:<] *//'

 # 在每一行开头加上一个尖括号和空格（引用信息）
 sed 's/^/> /'

 # 将每一行开头处的尖括号和空格删除（解除引用）
 sed 's/^> //'

 # 移除大部分的HTML标签（包括跨行标签）
 sed -e :a -e 's/<[^>]*>//g;/</N;//ba'

 # 将分成多卷的uuencode文件解码。移除文件头信息，只保留uuencode编码部分。
 # 文件必须以特定顺序传给sed。下面第一种版本的脚本可以直接在命令行下输入；
 # 第二种版本则可以放入一个带执行权限的shell脚本中。（由Rahul Dhesi的一
 # 个脚本修改而来。）
 sed '/^end/,/^begin/d' file1 file2 ... fileX | uudecode   # vers. 1
 sed '/^end/,/^begin/d' "$@" | uudecode                    # vers. 2

 # 将文件中的段落以字母顺序排序。段落间以（一行或多行）空行分隔。GNU sed使用
 # 字元“\v”来表示垂直制表符，这里用它来作为换行符的占位符——当然你也可以
 # 用其他未在文件中使用的字符来代替它。
 sed '/./{H;d;};x;s/\n/={NL}=/g' file | sort | sed '1s/={NL}=//;s/={NL}=/\n/g'
 gsed '/./{H;d};x;y/\n/\v/' file | sort | sed '1s/\v//;y/\v/\n/'

 # 分别压缩每个.TXT文件，压缩后删除原来的文件并将压缩后的.ZIP文件
 # 命名为与原来相同的名字（只是扩展名不同）。（DOS环境：“dir /b”
 # 显示不带路径的文件名）。
 echo @echo off >zipup.bat
 dir /b *.txt | sed "s/^\(.*\)\.TXT/pkzip -mo \1 \1.TXT/" >>zipup.bat


使用SED：Sed接受一个或多个编辑命令，并且每读入一行后就依次应用这些命令。
当读入第一行输入后，sed对其应用所有的命令，然后将结果输出。接着再读入第二
行输入，对其应用所有的命令……并重复这个过程。上一个例子中sed由标准输入设
备（即命令解释器，通常是以管道输入的形式）获得输入。在命令行给出一个或多
个文件名作为参数时，这些文件取代标准输入设备成为sed的输入。sed的输出将被
送到标准输出（显示器）。因此：

 cat filename | sed '10q'         # 使用管道输入
 sed '10q' filename               # 同样效果，但不使用管道输入
 sed '10q' filename > newfile     # 将输出转移（重定向）到磁盘上

要了解sed命令的使用说明，包括如何通过脚本文件（而非从命令行）来使用这些命
令，请参阅《sed & awk》第二版，作者Dale Dougherty和Arnold Robbins
（O'Reilly，1997；http://www.ora.com）， 《UNIX Text Processing》，作者
Dale Dougherty和Tim O'Reilly（Hayden Books，1987）或者是Mike Arst写的教
程——压缩包的名称是“U-SEDIT2.ZIP”（在许多站点上都找得到）。要发掘sed
的潜力，则必须对“正则表达式”有足够的理解。正则表达式的资料可以看
《Mastering Regular Expressions》作者Jeffrey Friedl（O'reilly 1997）。
Unix系统所提供的手册页（“man”）也会有所帮助（试一下这些命令
“man sed”、“man regexp”，或者看“man ed”中关于正则表达式的部分），但
手册提供的信息比较“抽象”——这也是它一直为人所诟病的。不过，它本来就不
是用来教初学者如何使用sed或正则表达式的教材，而只是为那些熟悉这些工具的人
提供的一些文本参考。

括号语法：前面的例子对sed命令基本上都使用单引号（'...'）而非双引号
（"..."）这是因为sed通常是在Unix平台上使用。单引号下，Unix的shell（命令
解释器）不会对美元符（$）和后引号（`...`）进行解释和执行。而在双引号下
美元符会被展开为变量或参数的值，后引号中的命令被执行并以输出的结果代替
后引号中的内容。而在“csh”及其衍生的shell中使用感叹号（!）时需要在其前
面加上转义用的反斜杠（就像这样：\!）以保证上面所使用的例子能正常运行
（包括使用单引号的情况下）。DOS版本的Sed则一律使用双引号（"..."）而不是
引号来圈起命令。

'\t'的用法：为了使本文保持行文简洁，我们在脚本中使用'\t'来表示一个制表
符。但是现在大部分版本的sed还不能识别'\t'的简写方式，因此当在命令行中为
脚本输入制表符时，你应该直接按TAB键来输入制表符而不是输入'\t'。下列的工
具软件都支持'\t'做为一个正则表达式的字元来表示制表符：awk、perl、HHsed、
sedmod以及GNU sed v3.02.80。

不同版本的SED：不同的版本间的sed会有些不同之处，可以想象它们之间在语法上
会有差异。具体而言，它们中大部分不支持在编辑命令中间使用标签（:name）或分
支命令（b,t），除非是放在那些的末尾。这篇文档中我们尽量选用了可移植性较高
的语法，以使大多数版本的sed的用户都能使用这些脚本。不过GNU版本的sed允许使
用更简洁的语法。想像一下当读者看到一个很长的命令时的心情：

   sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d

好消息是GNU sed能让命令更紧凑：

   sed '/AAA/b;/BBB/b;/CCC/b;d'      # 甚至可以写成
   sed '/AAA\|BBB\|CCC/b;d'

此外，请注意虽然许多版本的sed接受象“/one/ s/RE1/RE2/”这种在's'前带有空
格的命令，但这些版本中有些却不接受这样的命令:“/one/! s/RE1/RE2/”。这时
只需要把中间的空格去掉就行了。

速度优化：当由于某种原因（比如输入文件较大、处理器或硬盘较慢等）需要提高
命令执行速度时，可以考虑在替换命令（“s/.../.../”）前面加上地址表达式来
提高速度。举例来说：

   sed 's/foo/bar/g' filename         # 标准替换命令
   sed '/foo/ s/foo/bar/g' filename   # 速度更快
   sed '/foo/ s//bar/g' filename      # 简写形式

当只需要显示文件的前面的部分或需要删除后面的内容时，可以在脚本中使用“q”
命令（退出命令）。在处理大的文件时，这会节省大量时间。因此：

   sed -n '45,50p' filename           # 显示第45到50行
   sed -n '51q;45,50p' filename       # 一样，但快得多

如果你有其他的单行脚本想与大家分享或者你发现了本文档中错误的地方，请发电
子邮件给本文档的作者（Eric Pement）。邮件中请记得提供你所使用的sed版本、
该sed所运行的操作系统及对问题的适当描述。本文所指的单行脚本指命令行的长
度在65个字符或65个以下的sed脚本〔译注1〕。本文档的各种脚本是由以下所列作
者所写或提供：

 Al Aab                               # 建立了“seders”邮件列表
 Edgar Allen                          # 许多方面
 Yiorgos Adamopoulos                  # 许多方面
 Dale Dougherty                       # 《sed & awk》作者
 Carlos Duarte                        # 《do it with sed》作者
 Eric Pement                          # 本文档的作者
 Ken Pizzini                          # GNU sed v3.02 的作者
 S.G. Ravenhall                       # 去html标签脚本

 Greg Ubben                           # 有诸多贡献并提供了许多帮助
-------------------------------------------------------------------------

译注1：大部分情况下，sed脚本无论多长都能写成单行的形式（通过`-e'选项和`;'
号）——只要命令解释器支持，所以这里说的单行脚本除了能写成一行还对长度有
所限制。因为这些单行脚本的意义不在于它们是以单行的形式出现。而是让用户能
方便地在命令行中使用这些紧凑的脚本才是其意义所在。

Valid XHTML 1.0 Strict

*** 目录基本操作
**** cd                                                               :cd:

+ 改变当前工作目录
+ 语法: cd [目录]
+ 说明: 若没有指定目录，则回到用户的主目录

***** cd命令

来自: http://man.linuxde.net/cd

*cd命令* 用来切换工作目录至[[http://man.linuxde.net/dirname][dirname]]。
其中dirName表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的home
directory(也就是刚[[http://man.linuxde.net/login][login]]时所在的目录)。另外， =~= 也表示为home
directory的意思， =.= 则是表示目前所在的目录， =..= 则表示目前目录位置的上一层目录。

****** 语法

#+BEGIN_EXAMPLE
    cd (选项) (参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -p 如果要切换到的目标目录是一个符号连接，直接切换到符号连接指向的目标目录
    -L 如果要切换的目标目录是一个符号的连接，直接切换到字符连接名代表的目录，而非符号连接所指向的目标目录。
    - 当仅实用"-"一个选项时，当前工作目录将被切换到环境变量"OLDPWD"所表示的目录。
#+END_EXAMPLE

****** 实例

#+BEGIN_EXAMPLE
    cd    进入用户主目录；
    cd ~  进入用户主目录；
    cd -  返回进入此目录之前所在的目录；
    cd ..  返回上级目录（若当前目录为“/“，则执行完后还在“/"；".."为上级目录的意思）；
    cd ../..  返回上两级目录；
    cd !$  把上个命令的参数作为cd参数使用。
#+END_EXAMPLE

**** ls                                                               :ls:
***** usage
+ 显示指定工作目录中的文件和目录信息
+ 格式: ls [选项] [文件目录列表]
+ 选项
  -a    列出目录中的所有文件，包括以.开头的隐藏文件
  -l    列出文件的详细信息
  -1    一行只输出一个文件
+ 文件类型说明
  +  - 常规文件
  +  d    目录文件
  +  b    块特殊设备
  +  c    字符特殊设备
  +  ...

文件类型名后的字符表示文件的权限，权限由三个字符串组成，这三个字符串分别表
示该文件所有者的权限、组中其他人的权限和系统中其他人的权限。每个字符串又分
别有3个字符组成，依次表示对文件的读(r),写(w)和执行(x)的权限。当用户没有对
应权限时，该权限对应的位置使用短线"-"表示。
用长格式查看目录内容时，每行表示一个文件或目录的信息。每行信息一次是：文件
类型与权限，链接数，文件属主，文件大小，建立或修改时间，名字。

***** ls -l 第一个字母 c/d/l的含义 文件类型说明

- - 常规文件
- d 目录文件
- b 块特殊设备
- c 字符特殊设备

***** ls命令

来自: http://man.linuxde.net/ls

*ls命令* 用来显示目标列表，在Linux中是使用率较高的命令。ls命令的输出信
息可以进行彩色加亮显示，以分区不同类型的文件。

****** 语法

#+BEGIN_EXAMPLE
    ls（选项）（参数）
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；
    -A：显示除影藏文件“.”和“..”以外的所有文件列表；
    -C：多列显示输出结果。这是默认选项；
    -l：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；
    -F：在每个输出项后追加文件的类型标识符，具体含义：“*”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；
    -b：将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；
    -c：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；
    -d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；
    -f：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；
    -i：显示文件索引节点号（inode）。一个索引节点代表一个文件；
    --file-type：与“-F”选项的功能相同，但是不显示“*”；
    -k：以KB（千字节）为单位显示文件大小；
    -l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；
    -m：用“,”号区隔每个文件和目录的名称；
    -n：以用户识别码和群组识别码替代其名称；
    -r：以文件名反序排列并输出目录内容列表；
    -s：显示文件和目录的大小，以区块为单位；
    -t：用文件和目录的更改时间排序；
    -L：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；
    -R：递归处理，将指定目录下的所有文件及子目录一并处理；
    --full-time：列出完整的日期与时间；
    --color[=WHEN]：使用不同的颜色高亮显示不同类型的。
#+END_EXAMPLE

****** 参数

目录：指定要显示列表的目录，也可以是具体的文件。

****** 实例

显示当前目录下非影藏文件与目录

#+BEGIN_EXAMPLE
    [root@localhost ~]# ls
    anaconda-ks.cfg  install.log  install.log.syslog  satools
#+END_EXAMPLE

显示当前目录下包括影藏文件在内的所有文件列表

#+BEGIN_EXAMPLE
    [root@localhost ~]# ls -a
    .   anaconda-ks.cfg  .bash_logout   .bashrc  install.log         .mysql_history  satools  .tcshrc   .vimrc
    ..  .bash_history    .bash_profile  .cshrc   install.log.syslog  .rnd            .ssh     .viminfo
#+END_EXAMPLE

输出长格式列表

#+BEGIN_EXAMPLE
    [root@localhost ~]# ls -1

    anaconda-ks.cfg
    install.log
    install.log.syslog
    satools
#+END_EXAMPLE

显示文件的inode信息

索引节点（index
inode简称为“inode”）是Linux中一个特殊的概念，具有相同的索引节点号的两个文本本质上是同一个文件（除文件名不同外）。

#+BEGIN_EXAMPLE
    [root@localhost ~]# ls -i -l anaconda-ks.cfg install.log
    2345481 -rw------- 1 root root   859 Jun 11 22:49 anaconda-ks.cfg
    2345474 -rw-r--r-- 1 root root 13837 Jun 11 22:49 install.log
#+END_EXAMPLE

水平输出文件列表

#+BEGIN_EXAMPLE
    [root@localhost /]# ls -m

    bin, boot, data, dev, etc, home, lib, lost+found, media, misc, mnt, opt, proc, root, sbin, selinux, srv, sys, tmp, usr, var
#+END_EXAMPLE

修改最后一次编辑的文件

最近修改的文件显示在最上面。

#+BEGIN_EXAMPLE
    [root@localhost /]# ls -t

    tmp  root  etc  dev  lib  boot  sys  proc  data  home  bin  sbin  usr  var  lost+found  media  mnt  opt  selinux  srv  misc
#+END_EXAMPLE

显示递归文件

#+BEGIN_EXAMPLE
    [root@localhost ~]# ls -R
    .:
    anaconda-ks.cfg  install.log  install.log.syslog  satools

    ./satools:
    black.txt  freemem.sh  iptables.sh  lnmp.sh  mysql  php502_check.sh  ssh_safe.sh
#+END_EXAMPLE

打印文件的UID和GID

#+BEGIN_EXAMPLE
    [root@localhost /]# ls -n

    total 254
    drwxr-xr-x   2 0 0  4096 Jun 12 04:03 bin
    drwxr-xr-x   4 0 0  1024 Jun 15 14:45 boot
    drwxr-xr-x   6 0 0  4096 Jun 12 10:26 data
    drwxr-xr-x  10 0 0  3520 Sep 26 15:38 dev
    drwxr-xr-x  75 0 0  4096 Oct 16 04:02 etc
    drwxr-xr-x   4 0 0  4096 Jun 12 10:26 home
    drwxr-xr-x  14 0 0 12288 Jun 16 04:02 lib
    drwx------   2 0 0 16384 Jun 11 22:46 lost+found
    drwxr-xr-x   2 0 0  4096 May 11  2011 media
    drwxr-xr-x   2 0 0  4096 Nov  8  2010 misc
    drwxr-xr-x   2 0 0  4096 May 11  2011 mnt
    drwxr-xr-x   2 0 0  4096 May 11  2011 opt
    dr-xr-xr-x 232 0 0     0 Jun 15 11:04 proc
    drwxr-x---   4 0 0  4096 Oct 15 14:43 root
    drwxr-xr-x   2 0 0 12288 Jun 12 04:03 sbin
    drwxr-xr-x   2 0 0  4096 May 11  2011 selinux
    drwxr-xr-x   2 0 0  4096 May 11  2011 srv
    drwxr-xr-x  11 0 0     0 Jun 15 11:04 sys
    drwxrwxrwt   3 0 0 98304 Oct 16 08:45 tmp
    drwxr-xr-x  13 0 0  4096 Jun 11 23:38 usr
    drwxr-xr-x  19 0 0  4096 Jun 11 23:38 var
#+END_EXAMPLE

列出文件和文件夹的详细信息

#+BEGIN_EXAMPLE
    [root@localhost /]# ls -l

    total 254
    drwxr-xr-x   2 root root  4096 Jun 12 04:03 bin
    drwxr-xr-x   4 root root  1024 Jun 15 14:45 boot
    drwxr-xr-x   6 root root  4096 Jun 12 10:26 data
    drwxr-xr-x  10 root root  3520 Sep 26 15:38 dev
    drwxr-xr-x  75 root root  4096 Oct 16 04:02 etc
    drwxr-xr-x   4 root root  4096 Jun 12 10:26 home
    drwxr-xr-x  14 root root 12288 Jun 16 04:02 lib
    drwx------   2 root root 16384 Jun 11 22:46 lost+found
    drwxr-xr-x   2 root root  4096 May 11  2011 media
    drwxr-xr-x   2 root root  4096 Nov  8  2010 misc
    drwxr-xr-x   2 root root  4096 May 11  2011 mnt
    drwxr-xr-x   2 root root  4096 May 11  2011 opt
    dr-xr-xr-x 232 root root     0 Jun 15 11:04 proc
    drwxr-x---   4 root root  4096 Oct 15 14:43 root
    drwxr-xr-x   2 root root 12288 Jun 12 04:03 sbin
    drwxr-xr-x   2 root root  4096 May 11  2011 selinux
    drwxr-xr-x   2 root root  4096 May 11  2011 srv
    drwxr-xr-x  11 root root     0 Jun 15 11:04 sys
    drwxrwxrwt   3 root root 98304 Oct 16 08:48 tmp
    drwxr-xr-x  13 root root  4096 Jun 11 23:38 usr
    drwxr-xr-x  19 root root  4096 Jun 11 23:38 var
#+END_EXAMPLE

列出可读文件和文件夹详细信息

#+BEGIN_EXAMPLE
    [root@localhost /]# ls -lh

    total 254K
    drwxr-xr-x   2 root root 4.0K Jun 12 04:03 bin
    drwxr-xr-x   4 root root 1.0K Jun 15 14:45 boot
    drwxr-xr-x   6 root root 4.0K Jun 12 10:26 data
    drwxr-xr-x  10 root root 3.5K Sep 26 15:38 dev
    drwxr-xr-x  75 root root 4.0K Oct 16 04:02 etc
    drwxr-xr-x   4 root root 4.0K Jun 12 10:26 home
    drwxr-xr-x  14 root root  12K Jun 16 04:02 lib
    drwx------   2 root root  16K Jun 11 22:46 lost+found
    drwxr-xr-x   2 root root 4.0K May 11  2011 media
    drwxr-xr-x   2 root root 4.0K Nov  8  2010 misc
    drwxr-xr-x   2 root root 4.0K May 11  2011 mnt
    drwxr-xr-x   2 root root 4.0K May 11  2011 opt
    dr-xr-xr-x 235 root root    0 Jun 15 11:04 proc
    drwxr-x---   4 root root 4.0K Oct 15 14:43 root
    drwxr-xr-x   2 root root  12K Jun 12 04:03 sbin
    drwxr-xr-x   2 root root 4.0K May 11  2011 selinux
    drwxr-xr-x   2 root root 4.0K May 11  2011 srv
    drwxr-xr-x  11 root root    0 Jun 15 11:04 sys
    drwxrwxrwt   3 root root  96K Oct 16 08:49 tmp
    drwxr-xr-x  13 root root 4.0K Jun 11 23:38 usr
    drwxr-xr-x  19 root root 4.0K Jun 11 23:38 var
#+END_EXAMPLE

显示文件夹信息

#+BEGIN_EXAMPLE
    [root@localhost /]# ls -ld /etc/

    drwxr-xr-x 75 root root 4096 Oct 16 04:02 /etc/
#+END_EXAMPLE

按时间列出文件和文件夹详细信息

#+BEGIN_EXAMPLE
    [root@localhost /]# ls -lt

    total 254
    drwxrwxrwt   3 root root 98304 Oct 16 08:53 tmp
    drwxr-xr-x  75 root root  4096 Oct 16 04:02 etc
    drwxr-x---   4 root root  4096 Oct 15 14:43 root
    drwxr-xr-x  10 root root  3520 Sep 26 15:38 dev
    drwxr-xr-x  14 root root 12288 Jun 16 04:02 lib
    drwxr-xr-x   4 root root  1024 Jun 15 14:45 boot
    drwxr-xr-x  11 root root     0 Jun 15 11:04 sys
    dr-xr-xr-x 232 root root     0 Jun 15 11:04 proc
    drwxr-xr-x   6 root root  4096 Jun 12 10:26 data
    drwxr-xr-x   4 root root  4096 Jun 12 10:26 home
    drwxr-xr-x   2 root root  4096 Jun 12 04:03 bin
    drwxr-xr-x   2 root root 12288 Jun 12 04:03 sbin
    drwxr-xr-x  13 root root  4096 Jun 11 23:38 usr
    drwxr-xr-x  19 root root  4096 Jun 11 23:38 var
    drwx------   2 root root 16384 Jun 11 22:46 lost+found
    drwxr-xr-x   2 root root  4096 May 11  2011 media
    drwxr-xr-x   2 root root  4096 May 11  2011 mnt
    drwxr-xr-x   2 root root  4096 May 11  2011 opt
    drwxr-xr-x   2 root root  4096 May 11  2011 selinux
    drwxr-xr-x   2 root root  4096 May 11  2011 srv
    drwxr-xr-x   2 root root  4096 Nov  8  2010 misc
#+END_EXAMPLE

按修改时间列出文件和文件夹详细信息

#+BEGIN_EXAMPLE
    [root@localhost /]# ls -ltr

    total 254
    drwxr-xr-x   2 root root  4096 Nov  8  2010 misc
    drwxr-xr-x   2 root root  4096 May 11  2011 srv
    drwxr-xr-x   2 root root  4096 May 11  2011 selinux
    drwxr-xr-x   2 root root  4096 May 11  2011 opt
    drwxr-xr-x   2 root root  4096 May 11  2011 mnt
    drwxr-xr-x   2 root root  4096 May 11  2011 media
    drwx------   2 root root 16384 Jun 11 22:46 lost+found
    drwxr-xr-x  19 root root  4096 Jun 11 23:38 var
    drwxr-xr-x  13 root root  4096 Jun 11 23:38 usr
    drwxr-xr-x   2 root root 12288 Jun 12 04:03 sbin
    drwxr-xr-x   2 root root  4096 Jun 12 04:03 bin
    drwxr-xr-x   4 root root  4096 Jun 12 10:26 home
    drwxr-xr-x   6 root root  4096 Jun 12 10:26 data
    dr-xr-xr-x 232 root root     0 Jun 15 11:04 proc
    drwxr-xr-x  11 root root     0 Jun 15 11:04 sys
    drwxr-xr-x   4 root root  1024 Jun 15 14:45 boot
    drwxr-xr-x  14 root root 12288 Jun 16 04:02 lib
    drwxr-xr-x  10 root root  3520 Sep 26 15:38 dev
    drwxr-x---   4 root root  4096 Oct 15 14:43 root
    drwxr-xr-x  75 root root  4096 Oct 16 04:02 etc
    drwxrwxrwt   3 root root 98304 Oct 16 08:54 tmp
#+END_EXAMPLE

按照特殊字符对文件进行分类

#+BEGIN_EXAMPLE
    [root@localhost nginx-1.2.1]# ls -F

    auto/  CHANGES  CHANGES.ru  conf/  configure*  contrib/  html/  LICENSE  Makefile  man/  objs/  README  src/
#+END_EXAMPLE

列出文件并标记颜色分类

#+BEGIN_EXAMPLE
    [root@localhost nginx-1.2.1]# ls --color=auto

    auto  CHANGES  CHANGES.ru  conf  configure  contrib  html  LICENSE  Makefile  man  objs  README  src
#+END_EXAMPLE

**** mkdir                                                         :mkdir:

+ 创建目录
+ 语法: mkdir [选项] 目录
+ 选项
  +  -m    在建立目录时按模式指定目录全乡
  +  -p    系统自动创建目录中不存在的路径名

***** mkdir命令

来自: http://man.linuxde.net/mkdir


*mkdir命令* 用来创建目录。该命令创建由[[http://man.linuxde.net/dirname][dirname]] 命名的目录。如果在目录名
的前面没有加任何路径名，则在当前目录下创建由dirname指定的目录；如果给
出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，
应保证新建的目录与它所在目录下的文件没有重名。

注意：在创建文件时，不要把所有的文件都存放在主目录中，可以创建子目录，通过它们来更有效地组织文件。最好采用前后一致的命名方式来区分文件和目录。例如，目录名可以以大写字母开头，这样，在目录列表中目录名就出现在前面。

在一个子目录中应包含类型相似或用途相近的文件。例如，应建立一个子目录，它包含所有的数据库文件，另有一个子目录应包含电子表格文件，还有一个子目录应包含文字处理文档，等等。目录也是文件，它们和普通文件一样遵循相同的命名规则，并且利用全路径可以唯一地指定一个目录。

****** 语法

#+BEGIN_EXAMPLE
    mkdir (选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -Z：设置安全上下文，当使用SELinux时有效；
    -m<目标属性>或--mode<目标属性>建立目录的同时设置目录的权限；
    -p或--parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；
    --version 显示版本信息。
#+END_EXAMPLE

****** 参数

目录：指定要创建的目录列表，多个目录之间用空格隔开。

****** 实例

在目录=/usr/meng=下建立子目录[[http://man.linuxde.net/test][test]]，并且只有文件主有读、写和执行权限，其他人无权访问

#+BEGIN_EXAMPLE
    mkdir -m 700 /usr/meng/test
#+END_EXAMPLE

在当前目录中建立bin和bin下的os_1目录，权限设置为文件主可读、写、执行，同组用户可读和执行，其他用户无权访问

#+BEGIN_EXAMPLE
    mkdir -p-m 750 bin/os_1
#+END_EXAMPLE

**** rmdir                                                         :rmdir:

+ 删除目录
+ 语法: rmdir [选项] 目录
+ 选项
  +  -p    在删除指定目录后若父目录为空，则同时删除父目录。

***** rmdir命令

来自: http://man.linuxde.net/rmdir

*rmdir命令* 用来删除空目录。当目录不再被使用时，或者磁盘空间已到达使用
限定值，就需要删除失去使用价值的目录。利用rmdir命令可以从一个目录中删
除一个或多个空的子目录。该命令从一个目录中删除一个或多个子目录，其中
[[http://man.linuxde.net/dirname][dirname]]佬表示目录名。如果dirname中没有指定路径，则删除当前目录下由
dirname指定的目录；如dirname中包含路径，则删除指定位置的目录。删除目录
时，必须具有对其父目录的写权限。

注意：子目录被删除之前应该是空目录。就是说，该目录中的所有文件必须用[[http://man.linuxde.net/rm][rm]]命令全部，另外，当前工作目录必须在被删除目录之上，不能是被删除目录本身，也不能是被删除目录的子目录。

虽然还可以用带有=-r=选项的rm命令递归删除一个目录中的所有文件和该目录本身，但是这样做存在很大的危险性。

****** 语法

#+BEGIN_EXAMPLE
    rmdir(选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -p或--parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除；
    --ignore-fail-on-non-empty：此选项使rmdir命令忽略由于删除非空目录时导致的错误信息；
    -v或-verboes：显示命令的详细执行过程；
    --help：显示命令的帮助信息；
    --version：显示命令的版本信息。
#+END_EXAMPLE

****** 参数

目录列表：要删除的空目录列表。当删除多个空目录时，目录名之间使用空格隔开。

****** 实例

删除子目录os_1和其父目录bin

#+BEGIN_EXAMPLE
    cd /usr/meng/test
    rmdir -p bin/os_1
#+END_EXAMPLE

**** mv                                                               :mv:
+ 移动文件或重命名文件
+ 语法:
  - mv [选项] 源文件 目标文件
  - mv [选项] 源目录 目标目录
  - mv [选项] 文件列表 目录
+ 选项
  -i    交互模式

***** mv命令

来自: http://man.linuxde.net/mv

*mv命令* 用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录
中。source表示源文件或目录，target表示目标文件或目录。如果将一个文件移
到一个已经存在的目标文件中，则目标文件的内容将被覆盖。

mv命令可以用来将源文件移至一个目标文件中，或将一组文件移至一个目标目录中。源文件被移至目标文件有两种不同的结果：

1. 如果目标文件是到某一目录文件的路径，源文件会被移到此目录下，且文件名不变。
2. 如果目标文件不是目录文件，则源文件名（只能有一个）会变为此目标文件名，并覆盖己存在的同名文件。如果源文件和目标文件在同一个目录下，mv的作用就是改文件名。当目标文件是目录文件时，源文件或目录参数可以有多个，则所有的源文件都会被移至目标文件中。所有移到该目录下的文件都将保留以前的文件名。

注意事项：mv与[[http://man.linuxde.net/cp][cp]] 的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。

****** 语法

#+BEGIN_EXAMPLE
    mv(选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    --backup=<备份模式>：若需覆盖文件，则覆盖前先行备份；
    -b：当文件存在时，覆盖前，为其创建一个备份；
    -f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录；
    -i：交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。
    --strip-trailing-slashes：删除源文件中的斜杠“/”；
    -S<后缀>：为备份文件指定后缀，而不使用默认的后缀；
    --target-directory=<目录>：指定源文件要移动到目标目录；
    -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。
#+END_EXAMPLE

****** 参数

-  源文件：源文件列表。
-  目标文件：如果“目标文件”是文件名则在移动文件的同时，将其改名为“目标文件”；如果“目标文件”是目录名则将源文件移动到“目标文件”下。

****** 实例

将文件ex3改名为new1

#+BEGIN_EXAMPLE
    mv ex3 new1
#+END_EXAMPLE

将目录=/usr/men=中的所有文件移到当前目录（用=.=表示）中：

#+BEGIN_EXAMPLE
    mv /usr/men/* .
#+END_EXAMPLE

**** cp                                                               :cp:

+ 复制文件或目录
+ 语法: cp [选项] 源文件或目录 目标文件或目录
+ 选项
  -a    复制目录时保留链接、文件属性，并递归拷贝目录，相当于dpr组合

***** cp命令

来自: http://man.linuxde.net/cp

*cp命令* 用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它
可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。
cp命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是
一个已经存在的目录，否则将出现错误。

****** 语法

#+BEGIN_EXAMPLE
    cp(选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -a：此参数的效果和同时指定"-dpR"参数相同；
    -d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；
    -f：强行复制文件或目录，不论目标文件或目录是否已存在；
    -i：覆盖既有文件之前先询问用户；
    -l：对源文件建立硬连接，而非复制文件；
    -p：保留源文件或目录的属性；
    -R/r：递归处理，将指定目录下的所有文件与子目录一并处理；
    -s：对源文件建立符号连接，而非复制文件；
    -u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；
    -S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；
    -b：覆盖已存在的文件目标前将目标文件备份；
    -v：详细显示命令执行的操作。
#+END_EXAMPLE

****** 参数

-  源文件：制定源文件列表。默认情况下，cp命令不能复制目录，如果要复制目录，则必须使用=-R=选项；
-  目标文件：指定目标文件。当“源文件”为多个文件时，要求“目标文件”为指定的目录。

****** 实例

如果把一个文件复制到一个目标文件中，而目标文件已经存在，那么，该目标文件的内容将被破坏。此命令中所有参数既可以是绝对路径名，也可以是相对路径名。通常会用到点=.=或点点=..=的形式。例如，下面的命令将指定文件复制到当前目录下：

#+BEGIN_EXAMPLE
    cp ../mary/homework/assign .
#+END_EXAMPLE

所有目标文件指定的目录必须是己经存在的，cp命令不能创建目录。如果没有文件复制的权限，则系统会显示出错信息。

将文件[[http://man.linuxde.net/file][file]]复制到目录=/usr/men/tmp=下，并改名为file1

#+BEGIN_EXAMPLE
    cp file /usr/men/tmp/file1
#+END_EXAMPLE

将目录=/usr/men=下的所有文件及其子目录复制到目录=/usr/zh=中

#+BEGIN_EXAMPLE
    cp -r /usr/men /usr/zh
#+END_EXAMPLE

交互式地将目录=/usr/men=中的以m打头的所有.c文件复制到目录=/usr/zh=中

#+BEGIN_EXAMPLE
    cp -i /usr/men m*.c /usr/zh
#+END_EXAMPLE

我们在Linux下使用cp命令复制文件时候，有时候会需要覆盖一些同名文件，覆盖文件的时候都会有提示：需要不停的按Y来确定执行覆盖。文件数量不多还好，但是要是几百个估计按Y都要吐血了，于是折腾来半天总结了一个方法：

#+BEGIN_EXAMPLE
    cp aaa/* /bbb
    复制目录aaa下所有到/bbb目录下，这时如果/bbb目录下有和aaa同名的文件，需要按Y来确认并且会略过aaa目录下的子目录。

    cp -r aaa/* /bbb
    这次依然需要按Y来确认操作，但是没有忽略子目录。

    cp -r -a aaa/* /bbb
    依然需要按Y来确认操作，并且把aaa目录以及子目录和文件属性也传递到了/bbb。

    \cp -r -a aaa/* /bbb
    成功，没有提示按Y、传递了目录属性、没有略过目录。
#+END_EXAMPLE

*** 文件权限属性设置
**** chmod                                                         :chmod:

+ 改变文件或目录权限
+ 语法: chmod [who] [+/-/=] [mode] 文件名
+ 选项who
  +  -u    user, 即文件和目录的所有者
  +  -g    group,与文件属主有相同祖id的用户
  +  -o    others, 其他用户
  +  -a    all,所有用户
+ 选项操作符号
  + 添加权限
  + 取消某个权限
  =    赋予给定权限，并取消其他权限
+ 选项权限
  +  r    可读
  +  w    可写
  +  x    可执行

 文件和目录的权限还可以用八进制数字模式表示， 0表示没有权限，1表示可执
  行权限， 2表示可写权限，4表示可读权限。

***** chmod命令

来自: http://man.linuxde.net/chmod

*chmod命令* 用来变更文件或目录的权限。在UNIX系统家族里，文件或目录权限
的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用。
用户可以使用chmod指令去变更文件与目录的权限，设置方式采用文字或数字代
号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作
用在被连接的原始文件。

权限范围的表示法如下：

=u= User，即文件或目录的拥有者；\\
 =g= Group，即文件或目录的所属群组；\\
 =o=
Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；\\
 =a= All，即全部的用户，包含拥有者，所属群组以及其他用户；\\
 =r= 读取权限，数字代号为“4”;\\
 =w= 写入权限，数字代号为“2”；\\
 =x= 执行或切换权限，数字代号为“1”；\\
 =-= 不具任何权限，数字代号为“0”；\\
 =s= 特殊功能说明：变更文件或目录的权限。

****** 语法\\

#+BEGIN_EXAMPLE
    chmod(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -c或——changes：效果类似“-v”参数，但仅回报更改的部分；
    -f或--quiet或——silent：不显示错误信息；
    -R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；
    -v或——verbose：显示指令执行过程；
    --reference=<参考文件或目录>：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；
    <权限范围>+<权限设置>：开启权限范围的文件或目录的该选项权限设置；
    <权限范围>-<权限设置>：关闭权限范围的文件或目录的该选项权限设置；
    <权限范围>=<权限设置>：指定权限范围的文件或目录的该选项权限设置；
#+END_EXAMPLE

****** 参数\\

权限模式：指定文件的权限模式；\\
 文件：要改变权限的文件。

****** 知识扩展和实例\\

Linux用
户分为：拥有者、组群(Group)、其他（other），Linux系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及root的相关信
息，
都是记录在=/etc/passwd=文件中。每个人的密码则是记录在=/etc/shadow=文件下。
此外，所有的组群名称记录在=/etc/group=內！

linux文件的用户权限的分析图

[[http://man.linuxde.net/wp-content/uploads/2013/11/chmod.gif]]

例：rwx　rw-　r--

r=读取属性　　//值＝4\\
 w=写入属性　　//值＝2\\
 x=执行属性　　//值＝1

#+BEGIN_EXAMPLE
    chmod u+x,g+w f01　　//为文件f01设置自己可以执行，组员可以写入的权限
    chmod u=rwx,g=rw,o=r f01
    chmod 764 f01
    chmod a+x f01　　//对文件f01的u,g,o都设置可执行属性
#+END_EXAMPLE

文件的属主和属组属性设置

#+BEGIN_EXAMPLE
    chown user:market f01　　//把文件f01给uesr，添加到market组
    ll -d f1  查看目录f1的属性
#+END_EXAMPLE

**** chown                                                         :chown:

+ 改变文件或目录的属主和属组

***** chown命令

来自: http://man.linuxde.net/chown

*chown命令* 改变某个文件或目录的所有者和所属的组，该命令可以向某个用户
授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户
或者是用户D，用户组可以是组名或组[[http://man.linuxde.net/id][id]]。文件名可以使由空格分开的文件列表，
在文件名中可以包含通配符。

只有文件主和超级用户才可以便用该命令。

****** 语法\\

#+BEGIN_EXAMPLE
    chown(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -c或——changes：效果类似“-v”参数，但仅回报更改的部分；
    -f或--quite或——silent：不显示错误信息；
    -h或--no-dereference：只对符号连接的文件作修改，而不更改其他任何相关文件；
    -R或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；
    -v或——version：显示指令执行过程；
    --dereference：效果和“-h”参数相同；
    --help：在线帮助；
    --reference=<参考文件或目录>：把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同；
    --version：显示版本信息。
#+END_EXAMPLE

****** 参数\\

用户：组：指定所有者和所属工作组。当省略“：组”，仅改变文件所有者；\\

文件：指定要改变所有者和工作组的文件列表。支持多个文件和目标，支持shell通配符。

****** 实例\\

将目录=/usr/meng=及其下面的所有文件、子目录的文件主改成 liu：

#+BEGIN_EXAMPLE
    chown -R liu /usr/meng
#+END_EXAMPLE

*** 文件过滤分割与合并
**** comm                                                           :comm:
+ 比较有序文件
+ 语法: comm [-123]  file1 file2

***** comm命令

来自: http://man.linuxde.net/comm

*comm命令* 可以用于两个文件之间的比较，它有一些选项可以用来调整输出，
以便执行交集、求差、以及差集操作。

-  交集：打印出两个文件所共有的行。
-  求差：打印出指定文件所包含的且不相同的行。
-  差集：打印出包含在一个文件中，但不包含在其他指定文件中的行。

****** 语法\\

#+BEGIN_EXAMPLE
    comm(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -1：不显示在第一个文件出现的内容；
    -2：不显示在第二个文件中出现的内容；
    -3：不显示同时在两个文件中都出现的内容。
#+END_EXAMPLE

****** 参数\\

-  文件1：指定要比较的第一个有序文件；
-  文件2：指定要比较的第二个有序文件。

****** 实例\\

#+BEGIN_EXAMPLE
    [root@localhost text]# cat aaa.txt
    aaa
    bbb
    ccc
    ddd
    eee
    111
    222
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [root@localhost text]# cat bbb.txt
    bbb
    ccc
    aaa
    hhh
    ttt
    jjj
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [root@localhost text]# comm aaa.txt bbb.txt
    aaa
                    bbb
                    ccc
            aaa
    ddd
    eee
    111
    222
            hhh
            ttt
            jjj
    第一列  第二列  第三列
#+END_EXAMPLE

输出的第一列只包含在aaa.txt中出现的行，第二列包含在bbb.txt中出现的行，第三列包含在aaa.txt和bbb.txt中相同的行。各列是以制表符（\t）作为定界符。

*交集*

打印两个文件的交集，需要删除第一列和第二列：

#+BEGIN_EXAMPLE
    [root@localhost text]# comm aaa.txt bbb.txt -1 -2
    bbb
    ccc
#+END_EXAMPLE

*求差*

打印出两个文件中不相同的行，需要删除第三列：

#+BEGIN_EXAMPLE
    [root@localhost text]# comm aaa.txt bbb.txt -3 | sed 's/^\t//'
    aaa
    aaa
    ddd
    eee
    111
    222
    hhh
    ttt
    jjj
#+END_EXAMPLE

sed 's/\^\t//' 是将制表符（\t）删除，以便把两列合并成一列。

*差集*

通过删除不需要的列，可以得到aaa.txt和bbb.txt的差集：

aaa.txt的差集

#+BEGIN_EXAMPLE
    [root@localhost text]# comm aaa.txt bbb.txt -2 -3
    aaa
    ddd
    eee
    111
    222
#+END_EXAMPLE

bbb.txt的差集

#+BEGIN_EXAMPLE
    [root@localhost text]# comm aaa.txt bbb.txt -1 -3
    aaa
    hhh
    ttt
    jjj
#+END_EXAMPLE

***** diff                                                         :diff:
+ 文件内容比较
+ 语法: diff [选项] file1 file2
***** grep                                                         :grep:

+ 查找文件内容
+ 语法: grep [选项] [匹配模式] [文件列表]

grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配
的行打印出来。

grep全称是global regular expression print，表示全局正则表达式版本，它
的使用权限是所有用户。

grep的工作方式是它在一个或多个文件中搜索字符串模板。如果模板包括空格，
则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，
不影响原文件内容。

grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果
模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，
则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。

1. 格式：

   grep [option] pattern file

2. 功能：

   用于过滤/搜索的特定字符，可使用正则表达式能多种命令配合使用。

3. 参数
   + -a   --text     不要忽略二进制的数据。
   + -a<显示行数>   --after-context=<显示行数>     除了显示符合范本样式的那一列之外，并显示该行之后的内容。
   + -b   --byte-offset     在显示符合样式的那一行之前，标示出该行第一个字符的编号。
   + -b<显示行数>   --before-context=<显示行数>     除了显示符合样式的那一行之外，并显示该行之前的内容。
   + -c    --count     计算符合样式的列数。
   + -c<显示行数>    --context=<显示行数>或-<显示行数>     除了显示符合样式的那一行之外，并显示该行之前后的内容。
   + -d <动作>      --directories=<动作>     当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。
   + -e<范本样式>  --regexp=<范本样式>     指定字符串做为查找文件内容的样式。
   + -e      --extended-regexp     将样式为延伸的普通表示法来使用。
   + -f<规则文件>  --file=<规则文件>     指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。
   + -f   --fixed-regexp     将样式视为固定字符串的列表。
   + -g   --basic-regexp     将样式视为普通的表示法来使用。
   + -h   --no-filename     在显示符合样式的那一行之前，不标示该行所属的文件名称。
   + -h   --with-filename     在显示符合样式的那一行之前，表示该行所属的文件名称。
   + -i    --ignore-case     忽略字符大小写的差别。
   + -l    --file-with-matches     列出文件内容符合指定的样式的文件名称。
   + -l   --files-without-match     列出文件内容不符合指定的样式的文件名称。
   + -n   --line-number     在显示符合样式的那一行之前，标示出该行的列数编号。
   + -q   --quiet或--silent     不显示任何信息。
   + -r   --recursive     此参数的效果和指定“-d recurse”参数相同。
   + -s   --no-messages     不显示错误信息。
   + -v   --revert-match     显示不包含匹配文本的所有行。
   + -v   --version     显示版本信息。
   + -w   --word-regexp     只显示全字符合的列。
   + -x    --line-regexp     只显示全列符合的列。
   + -y     此参数的效果和指定“-i”参数相同。

4. 规则表达式
   + ^    锚定行的开始 如：'^grep'匹配所有以grep开头的行。
   + $    锚定行的结束 如：'grep$'匹配所有以grep结尾的行。
   + .    匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。
   + *    匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。
   + .*     一起用代表任意字符。
   + []     匹配一个指定范围内的字符，如'[gg]rep'匹配grep和grep。
   + [^]    匹配一个不在指定范围内的字符，如：'[^a-fh-z]rep'匹配不包含a-r和t-z的一个字母开头，紧跟rep的行。
   + =\(..\)=    标记匹配字符，如'=\(love\)='，love被标记为1。
   + =\<=        锚定单词的开始，如:'=\<grep='匹配包含以grep开头的单词的行。
   + =\>=        锚定单词的结束，如'=grep\>='匹配包含以grep结尾的单词的行。
   + =x\{m\}=    重复字符x，m次，如：'=0\{5\}='匹配包含5个o的行。
   + =x\{m,\}=    重复字符x,至少m次，如：'=o\{5,\}='匹配至少有5个o的行。
   + =x\{m,n\}=    重复字符x，至少m次，不多于n次，如：'=o\{5,10\}='匹配5--10个o的行。
   + =\w=      匹配文字和数字字符，也就是[a-za-z0-9]，如：'=g\w*p='匹配以g后跟零个或多个文字或数字字符，然后是p。
   + =\w=       =\w= 的反置形式，匹配一个或多个非单词字符，如点号句号等。
   + =\b=       单词锁定符，如: '=\bgrep\b='只匹配grep。

5. posix

   为了在不同国家的字符编码中保持一至，*posix(the portable operating
   system interface)* 增加了特殊的字符类，如[:alnum:]是[a-za-z0-9]的另
   一个写法。要把它们放到[]号内才能成为正则表达式，如[a- za-z0-9]或
   =[[:alnum:]]= 。在linux下的grep除fgrep外，都支持posix的字符类。

   + [:alnum:]      文字数字字符
   + [:alpha:]      文字字符
   + [:digit:]      数字字符
   + [:graph:]      非空字符（非空格、控制字符）
   + [:lower:]      小写字符
   + [:cntrl:]      控制字符
   + [:print:]      非空字符（包括空格）
   + [:punct:]      标点符号
   + [:space:]      所有空白字符（新行，空格，制表符）
   + [:upper:]      大写字符
   + [:xdigit:]     十六进制数字（0-9，a-f，a-f）

***** sort                                                         :sort:
+ 对文件中的各行进行排序
+ 语法: sort [选项] 文件
+ 说明: sort命令对指定文件中的所有行进行排序，并将结果显示在标准输出上。
  如果不指定输入文件或者使用“-”，则表示排序的内容来自标准输入。

***** split                                                       :split:

在Linux下用 *split* 进行文件分割.

****** 文本：指定分割后文件行数

对与txt文本文件，可以通过指定分割后文件的行数来进行文件分割。

#+BEGIN_EXAMPLE
  split -l 300 large_file.txt new_file_prefix
#+END_EXAMPLE

****** 二文件进制：指定分割后文件大小

对于二进制文件，如可执行文件，pdf，iso等，则不能通过文件行数来进行
文件分割，此时我们可以指定分割大小来分隔文件。

#+BEGIN_EXAMPLE
split -b 10m large_file.bin new_file_prefix
#+END_EXAMPLE

******* 合并

在Linux下用cat进行文件合并：cat small_files* > large_file

******* reference

+ http://os.51cto.com/art/201104/255359.htm

***** zcat                                                         :zcat:
****** zcat --help
+ Usage: /bin/zcat [OPTION]... [FILE]...
+ 功能: Uncompress FILEs to standard output.
+ Options:
  + -f, --force       force; read compressed data even from a terminal
  + -l, --list        list compressed file contents
  + -q, --quiet       suppress all warnings
  + -r, --recursive   operate recursively on directories
  + -S, --suffix=SUF  use suffix SUF on compressed files
  + -t, --test        test compressed file integrity
  + -v, --verbose     verbose mode
  +     --help        display this help and exit
  +     --version     display version information and
+ Note: With no FILE, or when FILE is -, read standard input.

***** mv                                                             :mv:

****** mv 无法进行跨设备移动

#+BEGIN_EXAMPLE
mv /media/ben/system/test/ ~/audio/
#+END_EXAMPLE

mv目录名不能加结尾的斜杠

mv的source永远不会以/结尾，要么是文件名，要么是目录名。

**** tr                                                               :tr:

***** tr
1. 功能： 转换或删除字符, 从标准输入设备读取数据，经过字符串转译后，输
   出到标准输出设备。

   可以将 tr 看作为 sed 的（极其）简化的变体：它可以用一个字符来替换另
   一个字符，或者可以完全除去一些字符。您也可以用它来除去重复字符。这
   就是所有 tr 所能够做的。

2. 格式：tr [option] set1 [set2]

3. 选项
   + -c或--complerment   取代所有不属于第一字符集的字符。
   + -d或--delete   删除所有属于第一字符集的字符。
   + -s或--squeeze-repeats   把连续重复的字符以单独一个字符表示。
   + -t或--truncate-set1   这个比较难理解，man上面的解释是：first
     truncate set1 to lengthof set2,经过我的实践发现，将set1的字符依次
     替换成set2中的字符，如果set1中的字符数目超过set2，那么set1多出的
     字符忽略。如果没有-t，那么多出的字符都替换成set2的最后一个字符。

4. 字符范围：指定字符串1或字符串2的内容时，只能使用单字符或字符串范围
   或列表。
   + [a-z] a-z内的字符组成的字符串。
   + [a-z] a-z内的字符组成的字符串。
   + [0-9] 数字串。
   + \textbackslash{}octal 一个三位的八进制数，对应有效的ascii字符。
   + [o*n] 表示字符o重复出现指定次数n。因此[o*2]匹配oo的字符串。
5. 例程
   1) 压缩文件中的重复字符
      #+header: :exports both
      #+begin_src sh
      echo abbccd | tr -s [a-z]
      #+end_src

      #+results:
      : abcd

      注：
      + [a-z]指定字符集合，而非字符串

   2) 去掉多余空行
      #+header: :exports both
      #+header: :results output
      #+begin_src sh
        echo -e "abc\n\nxyz"
        echo
        echo -e "abc\n\n\nxyz" | tr -s ["\n"]  # 或 "[\12]"
      #+end_src

      #+results:
      : abc
      :
      : xyz
      :
      : abc
      : xyz

   3) 删除文件中的^m，并代之以换行
      在linux下，不可避免的会用vim打开一些windows下编辑过的文本文件。
      我们会发现文件的每行结尾都会有一个^m符号，这是因为 dos下的编辑器
      和linux编辑器对文件行末的回车符处理不一致
      + window: \textbackslash{}r\textbackslash{}n
      + linux: \textbackslash{}n

      #+begin_example
      tr -s "[\r]" "[\n]" < input
      #+end_example

   4) 替换冒号
      #+begin_example
      tr -s "[:]" "[,]" < input
      #+end_example

   5) 显示path
      #+header: :exports both
      #+header: :results output
      #+begin_src sh
      echo $path | tr ":" "\n"
      #+end_src

      #+results:
      #+begin_example
      /home/ben/program/phantomjs/bin
      /usr/local/qt-5.4.1/bin
      /usr/home/ben/bin
      /home/ben/.ckws/devel/bin
      /opt/ros/indigo/bin
      /usr/local/texlive/2014/bin/i386-linux
      /home/ben/bin
      /usr/local/sbin
      /usr/local/bin
      /usr/sbin
      /usr/bin
      /sbin
      /bin
      /usr/games
      /usr/local/games
      /usr/local/libexec/emacs/24.4/i686-pc-linux-gnu
      #+end_example

   6) 替换字符集外的所有字符为指定字符
      #+header: :exports both
      #+header: :results output
      #+begin_src sh
      echo -n "abcdefg" | tr -c [ag] "o"
      #+end_src

      #+results:
      : aooooog

   7) 删除指定字符集的所有字符
      #+header: :exports both
      #+header: :results output
      #+begin_src sh
        echo  "foobar" | tr -d "for"
        echo  "foorbar" | tr -d for
        echo  "foorbar" | tr -d [for]
      #+end_src

      #+results:
      : ba
      : ba
      : ba

   8) 转换大小写
      #+header: :exports both
      #+header: :results output
      #+begin_src sh
        echo "abcxyz" | tr a-z a-z
        echo "abcxyz" | tr [a-z] [a-z]
      #+end_src

      #+results:
      : abcxyz
      : abcxyz

   9) 依次替换
      #+header: :exports both
      #+header: :results output
      #+begin_src sh
      echo "foobar" | tr -t fb bf
      #+end_src

      #+results:
      : boofar

***** tr命令

来自: http://man.linuxde.net/tr

*tr命令* 可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字
符变成另一组字符，经常用来编写优美的单行命令，作用很强大。

****** 语法\\

#+BEGIN_EXAMPLE
    tr(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -c或——complerment：取代所有不属于第一字符集的字符；
    -d或——delete：删除所有属于第一字符集的字符；
    -s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；
    -t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。
#+END_EXAMPLE

****** 参数\\

-  字符集1：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；
-  字符集2：指定要转换成的目标字符集。

****** 实例\\

将输入字符由大写转换为小写：

#+BEGIN_EXAMPLE
    echo "HELLO WORLD" | tr 'A-Z' 'a-z'
    hello world
#+END_EXAMPLE

'A-Z' 和
'a-z'都是集合，集合是可以自己制定的，例如：'ABD-}'、'bB.,'、'a-de-h'、'a-c0-9'都属于集合，集合里可以使用'\n'、'\t'，可以可以使用其他ASCII字符。

使用tr删除字符：

#+BEGIN_EXAMPLE
    echo "hello 123 world 456" | tr -d '0-9'
    hello  world
#+END_EXAMPLE

将制表符转换为空格：

#+BEGIN_EXAMPLE
    cat text | tr '\t' ' '
#+END_EXAMPLE

字符集补集，从输入文本中将不在补集中的所有字符删除：

#+BEGIN_EXAMPLE
    echo aa.,a 1 b#$bb 2 c*/cc 3 ddd 4 | tr -d -c '0-9 \n'
     1  2  3  4
#+END_EXAMPLE

此例中，补集中包含了数字0~9、空格和换行符\n，所以没有被删除，其他字符全部被删除了。

用tr压缩字符，可以压缩输入中重复的字符：

#+BEGIN_EXAMPLE
    echo "thissss is      a text linnnnnnne." | tr -s ' sn'
    this is a text line.
#+END_EXAMPLE

巧妙使用tr做数字相加操作：

#+BEGIN_EXAMPLE
    echo 1 2 3 4 5 6 7 8 9 | xargs -n1 | echo $[ $(tr '\n' '+') 0 ]
#+END_EXAMPLE

删除Windows文件“造成”的'\^M'字符：

#+BEGIN_EXAMPLE
    cat file | tr -s "\r" "\n" > new_file
    或
    cat file | tr -d "\r" > new_file
#+END_EXAMPLE

*tr可以使用的字符类：*

#+BEGIN_EXAMPLE
    [:alnum:]：字母和数字
    [:alpha:]：字母
    [:cntrl:]：控制（非打印）字符
    [:digit:]：数字
    [:graph:]：图形字符
    [:lower:]：小写字母
    [:print:]：可打印字符
    [:punct:]：标点符号
    [:space:]：空白字符
    [:upper:]：大写字母
    [:xdigit:]：十六进制字符
#+END_EXAMPLE

使用方式：

#+BEGIN_EXAMPLE
    tr '[:lower:]' '[:upper:]'
#+END_EXAMPLE

**** wc                                                               :wc:
+ 统计文件中的字节数、字数和行数。
+ 语法: wx [选项] 文件列表
+ 选项
  +  -c    统计字节数
  +  -l    统计行数
  +  -w    统计字数

***** wc命令

来自: http://man.linuxde.net/wc

*wc命令* 用来计算数字。利用wc指令我们可以计算文件的Byte数、字数或是列
数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入
设备读取数据。

****** 语法\\

#+BEGIN_EXAMPLE
    wc(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -c或--bytes或——chars：只显示Bytes数；
    -l或——lines：只显示列数；
    -w或——words：只显示字数。
#+END_EXAMPLE

****** 参数\\

文件：需要统计的文件列表。

**** grep                                                           :grep:
***** [[http://blog.163.com/redzang@yeah/blog/static/64918585201201474716158/][grep、egrep和fgrep命令--Linux文件内容查询命令  ]] :blog:

1.命令功能：

grep命令用来在文本文件中查找指定模式的词或短语，并在标准输出上显示包括
给定字符串模式的所有行；

egrep命令等同于grep -E，可以使用扩展的字符串模式进行搜索；

fgrep命令等同于grep -F，是快速搜索命令，它检索固定字符串，但不识别正则
表达式。

2.一般格式：

grep [选项] [查找模式] [文件名1，文件名2，……]

fgrep [选项] [查找模式] [文件名1，文件名2，……]

egrep [选项] [查找模式] [文件名1，文件名2，……]

3.常用选项：

- E 每个模式作为一个扩展的正则表达式对待。

- F 每个模式作为一组固定字符串对待（以新行分隔），而不作为正则表达式。

- b在输出的每一行前显示包含匹配字符串的行在文件中的字节偏移量。

- c 只显示匹配行的数量。

- i 比较时不区分大小写。

- h 在查找多个文件时，指示grep不要将文件名加入到输出之前。

- l 显示首次匹配串所在的文件名并用换行符将其隔开。当在某文件中多次出现
  匹配串时，不重复显示此文件名。

- n 在输出前加上匹配串所在行的行号（文件首行行号为1）。

- v 只显示不包含匹配串的行。

- x 只显示整行严格匹配的行。

- e expression 指定检索使用的模式。用于防止以“-”开头的模式被解释为命
  令选项。

- f expfile 从expfile文件中获取要搜索的模式，一个模式占一行

4.注意以下方面：

在命令后键入搜索的模式，再键入要搜索的文件。其中，文件名列表中也可以使
用特殊字符，如“*”等，用来生成文件名列表。如果想在搜索的模式中包含有
空格的字符串，可以用单引号把要搜索的模式括起来，用来表明搜索的模式是由
包含空格的字符串组成。否则，Shell将把空格认为是命令行参数的定界符，而
grep命令将把搜索模式中的单词解释为文件名列表中的一部分。在下面的例子中，
grep命令在文件example中搜索模式“text file”。

$ grep ’text file’ example

用户可以在命令行上用Shell特殊字符来生成将要搜索的文件名列表。在下面的
例子中，特殊字符“*”用来生成一个文件名列表，该列表包含当前目录下所有
的文件。该命令将搜索出当前目录下所有文件中与模式匹配的行。

$ grep data *

特殊字符在搜索一组指定的文件时非常有用。例如，如果想搜索所有的C程序源
文件中特定的模式，您可以用“*.c”来指定文件名列表。假设用户的 C程序中
包含一些不必要的转向语句（goto语句），想要找到这些语句，可以用如下的命
令来搜索并显示所有包含goto语句的代码行：

$ grep goto *.c

用户可以在命令行上键入搜索模式，也可以使用-f选项从指定文件中读取要搜索
的模式。在文件中，每个搜索模式占一行。如果经常要搜索一组常见字符串时，
这个功能非常有用。在下面的例子中，用户要在文件exam中搜索字符串
“editor”和“create”，就把要搜索的模式放置在文件mypats中，然后，grep
命令从文件mypats中读取要搜索的模式。

$ cat mypats

editor

create

$ grep -f mypats exam

***** grep命令

来自: http://man.linuxde.net/grep

*grep* （global search regular expression(RE) and print out the
line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。

****** 选项\\

#+BEGIN_EXAMPLE
    -a 不要忽略二进制数据。
    -A<显示列数> 除了显示符合范本样式的那一行之外，并显示该行之后的内容。
    -b 在显示符合范本样式的那一行之外，并显示该行之前的内容。
    -c 计算符合范本样式的列数。
    -C<显示列数>或-<显示列数>  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
    -d<进行动作> 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。
    -e<范本样式> 指定字符串作为查找文件内容的范本样式。
    -E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。
    -f<范本文件> 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。
    -F 将范本样式视为固定字符串的列表。
    -G 将范本样式视为普通的表示法来使用。
    -h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
    -H 在显示符合范本样式的那一列之前，标示该列的文件名称。
    -i 胡列字符大小写的差别。
    -l 列出文件内容符合指定的范本样式的文件名称。
    -L 列出文件内容不符合指定的范本样式的文件名称。
    -n 在显示符合范本样式的那一列之前，标示出该列的编号。
    -q 不显示任何信息。
    -R/-r 此参数的效果和指定“-d recurse”参数相同。
    -s 不显示错误信息。
    -v 反转查找。
    -w 只显示全字符合的列。
    -x 只显示全列符合的列。
    -y 此参数效果跟“-i”相同。
    -o 只输出文件中匹配到的部分。
#+END_EXAMPLE

****** grep命令常见用法\\

在文件中搜索一个单词，命令会返回一个包含*“match_pattern”*的文本行：

#+BEGIN_EXAMPLE
    grep match_pattern file_name
    grep "match_pattern" file_name
#+END_EXAMPLE

在多个文件中查找：

#+BEGIN_EXAMPLE
    grep "match_pattern" file_1 file_2 file_3 ...
#+END_EXAMPLE

输出除之外的所有行 *-v* 选项：

#+BEGIN_EXAMPLE
    grep -v "match_pattern" file_name
#+END_EXAMPLE

标记匹配颜色 *--color=auto* 选项：

#+BEGIN_EXAMPLE
    grep "match_pattern" file_name --color=auto
#+END_EXAMPLE

使用正则表达式 *-E* 选项：

#+BEGIN_EXAMPLE
    grep -E "[1-9]+"
    或
    egrep "[1-9]+"
#+END_EXAMPLE

只输出文件中匹配到的部分 *-o* 选项：

#+BEGIN_EXAMPLE
    echo this is a test line. | grep -o -E "[a-z]+\."
    line.

    echo this is a test line. | egrep -o "[a-z]+\."
    line.
#+END_EXAMPLE

统计文件或者文本中包含匹配字符串的行数 *-c* 选项：

#+BEGIN_EXAMPLE
    grep -c "text" file_name
#+END_EXAMPLE

输出包含匹配字符串的行数 *-n* 选项：

#+BEGIN_EXAMPLE
    grep "text" -n file_name
    或
    cat file_name | grep "text" -n

    #多个文件
    grep "text" -n file_1 file_2
#+END_EXAMPLE

打印样式匹配所位于的字符或字节偏移：

#+BEGIN_EXAMPLE
    echo gun is not unix | grep -b -o "not"
    7:not

    #一行中字符串的字符便宜是从该行的第一个字符开始计算，起始值为0。选项 -b -o 一般总是配合使用。
#+END_EXAMPLE

搜索多个文件并查找匹配文本在哪些文件中：

#+BEGIN_EXAMPLE
    grep -l "text" file1 file2 file3...
#+END_EXAMPLE

******* grep递归搜索文件\\

在多级目录中对文本进行递归搜索：

#+BEGIN_EXAMPLE
    grep "text" . -r -n
    # .表示当前目录。
#+END_EXAMPLE

忽略匹配样式中的字符大小写：

#+BEGIN_EXAMPLE
    echo "hello world" | grep -i "HELLO"
    hello
#+END_EXAMPLE

选项 *-e* 制动多个匹配样式：

#+BEGIN_EXAMPLE
    echo this is a text line | grep -e "is" -e "line" -o
    is
    line

    #也可以使用-f选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。
    cat patfile
    aaa
    bbb

    echo aaa bbb ccc ddd eee | grep -f patfile -o
#+END_EXAMPLE

在grep搜索结果中包括或者排除指定文件：

#+BEGIN_EXAMPLE
    #只在目录中所有的.php和.html文件中递归搜索字符"main()"
    grep "main()" . -r --include *.{php,html}

    #在搜索结果中排除所有README文件
    grep "main()" . -r --exclude "README"

    #在搜索结果中排除filelist文件列表里的文件
    grep "main()" . -r --exclude-from filelist
#+END_EXAMPLE

使用0值字节后缀的grep与[[http://man.linuxde.net/xargs][xargs]]：

#+BEGIN_EXAMPLE
    #测试文件：
    echo "aaa" > file1
    echo "bbb" > file2
    echo "aaa" > file3

    grep "aaa" file* -lZ | xargs -0 rm

    #执行后会删除file1和file3，grep输出用-Z选项来指定以0值字节作为终结符文件名（\0），xargs -0 读取输入并用0值字节终结符分隔文件名，然后删除匹配文件，-Z通常和-l结合使用。
#+END_EXAMPLE

grep静默输出：

#+BEGIN_EXAMPLE
    grep -q "test" filename

    #不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。
#+END_EXAMPLE

打印出匹配文本之前或者之后的行：

#+BEGIN_EXAMPLE
    #显示匹配某个结果之后的3行，使用 -A 选项：
    seq 10 | grep "5" -A 3
    5
    6
    7
    8

    #显示匹配某个结果之前的3行，使用 -B 选项：
    seq 10 | grep "5" -B 3
    2
    3
    4
    5

    #显示匹配某个结果的前三行和后三行，使用 -C 选项：
    seq 10 | grep "5" -C 3
    2
    3
    4
    5
    6
    7
    8

    #如果匹配结果有多个，会用“--”作为各匹配结果之间的分隔符：
    echo -e "a\nb\nc\na\nb\nc" | grep a -A 1
    a
    b
    --
    a
    b
#+END_EXAMPLE

**** ack                                                             :ack:
***** Reference

+ [[http://beyondgrep.com/][Homepage]]
+ [[http://www.the5fire.com/about-ack-grep-in-linux.html][linux下的高效代码搜索工具-ack]]
+ [[http://betterthangrep.com/documentation/][官网文档]]
+ [[http://blueparen.com/node/5][ack作者采访]]
+ [[http://codeseekah.com/2012/03/11/ack-grep-vs-grep/][ack-grep和grep对比]]

***** [[http://www.the5fire.com/about-ack-grep-in-linux.html][linux下的高效代码搜索工具-ack]]
****** 什么是ACK？

  1. [[http://betterthangrep.com]]
  2. ack is a tool like grep, optimized for programmers
  3. is written purely in Perl 5,takes advantage of the power of Perl's
     regular expressions.
  4. 作者在厌烦了不停的写下面的这个查找命令之后，开发了ack这个工具

  #+BEGIN_EXAMPLE
      grep foo $(find . -name '*.pm' | grep -v .svn)
  #+END_EXAMPLE

可以看的出来，ack诞生的目的就是要取代grep，从作者开发的初衷以及它官网
的名字，另外它还有一个“可以替代99%grep的工作”这个口号。

****** 安装

ubuntu下要安装ack-grep，因为在debian系中，ack这个名字被其他的软件占用
了。

#+BEGIN_EXAMPLE
sudo apt-get install ack-grep
#+END_EXAMPLE

****** 特点

大家都说自己的东西好，因此ack官网列出了这工具的5大卖点：

#+BEGIN_QUOTE
  1. 速度非常快,因为它只搜索有意义的东西。
  2. 更友好的搜索，忽略那些不是你源码的东西。
  3. 为源代码搜索而设计，用更少的击键完成任务。
  4. 非常轻便，移植性好。
  5. 免费且开源
#+END_QUOTE

****** better than grep?

先来看下grep的日常用法。

-  grep常用操作 ::

   1. grep -r 'hello_world' # 简单用法
   2. grep '\^hello_world' . # 简单正则
   3. ls -l | grep .py # 管道用法

一些参数：

#+BEGIN_EXAMPLE
-c(统记)/ -i(忽略大小)/ -h(不显示名称)/
-l(只显文件名)/ -n(加行号)/ -v(显示不匹配)
#+END_EXAMPLE

这些命令在linux上的适用频率是相当高的，尤其是你用vim做为IDE的话（当然
这是说在不知道ack之前）。

****** ack功能划分

在记忆的时候大体上可以分为这几个部分：

#+BEGIN_QUOTE

  1. Searching代码搜索
  2. Search output搜索结果处理
  3. File presentation文件展示
  4. File finding文件查找
  5. File inclusion/exclusion文件过滤
#+END_QUOTE

下面对每一项给几个简单实用的例子。

****** Searching

简单的文本搜索，默认是递归的。

#+BEGIN_EXAMPLE
    ack-grep hello
    ack-grep -i hello
    ack-grep -v hello
    ack-grep -w hello
    ack-grep -Q 'hello*'
#+END_EXAMPLE

****** Search File

对搜索结果进行处理，比如只显示一个文件的一个匹配项，或者xxx

#+BEGIN_EXAMPLE
    ack-grep --line=1     # 输出所有文件第二行

    ack-grep -l 'hello'     # 包含的文件名

    ack-grep -L 'print'     # 非包含文件名
#+END_EXAMPLE

****** File presentation

输出的结果是以什么方式展示呢，这个部分有几个参数可以练习下

#+BEGIN_EXAMPLE
    ack-grep hello --pager='less -R'    # 以less形式展示
    ack-grep hello --noheading      # 不在头上显示文件
    ack-grep hello --nocolor        # 不对匹配字符着色
#+END_EXAMPLE

****** File finding

没错，它可以查找文件，以省去你要不断的结合find和grep的麻烦，虽然在
linux的思想是一个工具做好一件事。

#+BEGIN_EXAMPLE
    ack-grep -f hello.py    # 查找全匹配文件
    ack-grep -g hello.py$    # 查找正则匹配文件
    ack-grep -g hello  --sort-files     #查找然后排序
#+END_EXAMPLE

****** File Inclusion/Exclusion

文件过滤，个人觉得这是一个很不错的功能。如果你曾经在搜索项目源码是不小
心命中日志中的某个关键字的话，你会觉得这个有用。

#+BEGIN_EXAMPLE
    ack-grep --python hello #查找所有python文件
    ack-grep -G hello.py$ hello     # 查找匹配正则的文件
#+END_EXAMPLE

****** ack配置

也是一个相当赞的功能，对grep了解不多，不知道grep有没有同样的东西。通过
配置可以把你的个人习惯做为默认配置，比如我是python程序员，那默认我要搜
索的文件大多数必然是.py的文件。每次搜索时都要输入:--python那就太无聊了。

另外还可以自己指定类型，通过--type-set=conf=.conf,指定一个.conf的文件
形式，ack默认提供常见源码的支持。你可以通过:ack-grep--help types查看它
支持多少中类型的源码，绝对有你不知道的语言。

下面是一个简单的配置

#+BEGIN_EXAMPLE
    # 设置排序
    --sort-files
    #设置文件过滤
    --python
    --html
    --js
    --conf
    # 设置显示
    --noheading
    # 定义新的文件类型
    --type-set=conf=.conf
    # 智能识别大小写
    --smart-case
    # 设置以less形式展示，设定less参数
    --pager=less -R -M --shift 5 -i
#+END_EXAMPLE

**** shuf                                                           :shuf:
***** man

#+BEGIN_EXAMPLE
  NAME
         shuf - generate random permutations

  SYNOPSIS
         shuf [OPTION]... [FILE]
         shuf -e [OPTION]... [ARG]...
         shuf -i LO-HI [OPTION]...

  DESCRIPTION
         Write a random permutation of the input lines to standard output.

         Mandatory arguments to long options are mandatory for short options too.

         -e, --echo
                treat each ARG as an input line

         -i, --input-range=LO-HI
                treat each number LO through HI as an input line

         -n, --head-count=COUNT
                output at most COUNT lines

         -o, --output=FILE
                write result to FILE instead of standard output

         --random-source=FILE
                get random bytes from FILE

         -z, --zero-terminated
                end lines with 0 byte, not newline

         --help display this help and exit

         --version
                output version information and exit

         With no FILE, or when FILE is -, read standard input.
#+END_EXAMPLE

***** test

#+BEGIN_EXAMPLE
  Workspace $ cat foo
  1
  2
  3
  4
  5
  6
  7
  Workspace $ cat foo | shuf
  3
  1
  5
  4
  6
  2
  7
  Workspace $ shuf < foo
  3
  1
  5
  4
  7
  6
  2

#+END_EXAMPLE
***** Reference

+
  [[https://app.yinxiang.com/shard/s52/nl/11551545/dd02e6a6-67f9-48d3-819e-784dca74c487/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D151c89d2c9a%3AS%3D5e1c044d9477e6c99541642e17d17afa][EN:: shuf 随机排序文件]]
***** [[http://blog.csdn.net/reyleon/article/details/14000997][shuf 命令： 随机排序文件]] :blog:

有时候我们需要将文本的顺序打乱，也就是随机排序，我以前的做法是写个shell，利用
bash 里的内置变量 $RANDOM 进行排序，然后打印。代码如下：

#+BEGIN_EXAMPLE
while read line;do echo $RANDOM $line; done < file | sort -n | sed 's/[^ ]\+ //'
#+END_EXAMPLE

这里取了个巧而已。虽然也能实现需求，但是如果遇到大文件，本身 shell
的效率是很低的。偶然得知系统本身有一个命令是专职干这事儿的，那就是 shuf
命令，那效率，是杠杠滴啊。简单介绍下：

1. 这个命令属于 coreutils 包，如果系统没有此命令，请 yum install coreutils 进行安装。
2. 它也能够接受标准输入，即管道
   参数：
   -n 最多显示多少行
   -o 将随机排序后的输出写到一个文件中
   更多信息请参考man页。

另外，今天发现用 *sort -R* 也可以随机排序，只是效率比shuf稍微慢一点儿！
man sort 的解释如下：

#+BEGIN_EXAMPLE
-R, --random-sort
sort by random hash of keys
#+END_EXAMPLE

*** 文件压缩与解压
**** tar                                                             :tar:
***** overview
|----------------+-----------------------|
| *.tar          | tar -xvf [filename]   |
| *.gz           | gzip -d [filename]    |
|                | gunzip [filename]     |
| *.tar.gz *.tgz | tar -zxvf [filename]  |
| *.bz2          | bzip2 d [filename]    |
|                | bunzip2 [filename]    |
| *.tar.bz2      | tar -xjvf [filename]  |
| *.Z            | uncompress [filename] |
| *.tar.Z        | tar -xZf [filename]   |
| *.rar          | unrar [filename]      |
| *.zip          | unzip r [filename]    |
|----------------+-----------------------|

http://blog.csdn.net/wangjunjun2008/article/details/21982843

***** tar命令

来自: http://man.linuxde.net/tar

*tar命令* 可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件
创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。
tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利
用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件
或将几个文件组合成为一个文件以便于网络传输是非常有用的。

首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。

为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（[[http://man.linuxde.net/gzip][gzip]] [[http://man.linuxde.net/bzip2][bzip2]]命令）。

****** 语法\\

#+BEGIN_EXAMPLE
    tar(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -A或--catenate：新增文件到以存在的备份文件；
    -B：设置区块大小；
    -c或--create：建立新的备份文件；
    -C <目录>：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。
    -d：记录文件的差别；
    -x或--extract或--get：从备份文件中还原文件；
    -t或--list：列出备份文件的内容；
    -z或--gzip或--ungzip：通过gzip指令处理备份文件；
    -Z或--compress或--uncompress：通过compress指令处理备份文件；
    -f<备份文件>或--file=<备份文件>：指定备份文件；
    -v或--verbose：显示指令执行过程；
    -r：添加文件到已经压缩的文件；
    -u：添加改变了和现有的文件到已经存在的压缩文件；
    -j：支持bzip2解压文件；
    -v：显示操作过程；
    -l：文件系统边界设置；
    -k：保留原有文件不覆盖；
    -m：保留文件不被覆盖；
    -w：确认压缩文件的正确性；
    -p或--same-permissions：用原来的文件权限还原文件；
    -P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；
    -N <日期格式> 或 --newer=<日期时间>：只将较指定日期更新的文件保存到备份文件里；
    --exclude=<范本样式>：排除符合范本样式的文件。
#+END_EXAMPLE

****** 参数\\

文件或目录：指定要打包的文件或目录列表。

****** 实例\\

*将文件全部打包成tar包*：

#+BEGIN_EXAMPLE
    tar -cvf log.tar log2012.log    仅打包，不压缩！
    tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩
    tar -zcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩
#+END_EXAMPLE

在选项=f=之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加=z=选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加=j=选项，则以.tar.bz2来作为tar包名。

*查阅上述tar包内有哪些文件*：

#+BEGIN_EXAMPLE
    tar -ztvf log.tar.gz
#+END_EXAMPLE

由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上=z=这个选项了。

*将tar包解压缩*：

#+BEGIN_EXAMPLE
    tar -zxvf /opt/soft/test/log.tar.gz
#+END_EXAMPLE

在预设的情况下，我们可以将压缩档在任何地方解开的

*只将tar内的部分文件解压出来*：

#+BEGIN_EXAMPLE
    tar -zxvf /opt/soft/test/log30.tar.gz log2013.log
#+END_EXAMPLE

我可以透过=tar -ztvf=来查阅 tar 包内的文件名称，如果单只要一个文件，就可以透过这个方式来解压部分文件！

*文件备份下来，并且保存其权限*：

#+BEGIN_EXAMPLE
    tar -zcvpf log31.tar.gz log2014.log log2015.log log2016.log
#+END_EXAMPLE

这个=-p=的属性是很重要的，尤其是当您要保留原本文件的属性时。

*在文件夹当中，比某个日期新的文件才备份*：

#+BEGIN_EXAMPLE
    tar -N "2012/11/13" -zcvf log17.tar.gz test
#+END_EXAMPLE

*备份文件夹内容是排除部分文件：*

#+BEGIN_EXAMPLE
    tar --exclude scf/service -zcvf scf.tar.gz scf/*
#+END_EXAMPLE

*其实最简单的使用 tar 就只要记忆底下的方式即可：*

#+BEGIN_EXAMPLE
    压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称
    查　询：tar -jtv -f filename.tar.bz2
    解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录
#+END_EXAMPLE

***** [[http://www.cnblogs.com/yejianfei/p/3351626.html][Linux的压缩与解压]]

****** zip格式                                                     :zip:

#+BEGIN_EXAMPLE
    压缩： zip -r [目标文件名].zip [原文件/目录名]
    解压： unzip [原文件名].zip
#+END_EXAMPLE

注：-r参数代表递归

****** tar格式（该格式仅仅打包，不压缩）                           :tar:

#+BEGIN_EXAMPLE
    打包：tar -cvf [目标文件名].tar [原文件名/目录名]
    解包：tar -xvf [原文件名].tar
#+END_EXAMPLE

注：c参数代表create（创建），x参数代表extract（解包），v参数代表
verbose（详细信息），f参数代表filename（文件名），所以f后必须接文件名。

****** tar.gz格式                                                   :gz:

方式一：利用前面已经打包好的tar文件，直接用压缩命令。

#+BEGIN_EXAMPLE
    压缩：gzip [原文件名].tar
    解压：gunzip [原文件名].tar.gz
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -zcvf [目标文件名].tar.gz [原文件名/目录名]
    解压并解包： tar -zxvf [原文件名].tar.gz
#+END_EXAMPLE

注：z代表用gzip算法来压缩/解压。

****** tar.bz2格式                                                 :bz2:

方式一：利用已经打包好的tar文件，直接执行压缩命令：

#+BEGIN_EXAMPLE
    压缩：bzip2 [原文件名].tar
    解压：bunzip2 [原文件名].tar.bz2
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -jcvf [目标文件名].tar.bz2 [原文件名/目录名]
    解压并解包： tar -jxvf [原文件名].tar.bz2
#+END_EXAMPLE

注：小写j代表用bzip2算法来压缩/解压。

****** tar.xz格式                                                   :xz:

方式一：利用已经打包好的tar文件，直接用压缩命令：

#+BEGIN_EXAMPLE
    压缩：xz [原文件名].tar
    解压：unxz [原文件名].tar.xz
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -Jcvf [目标文件名].tar.xz [原文件名/目录名]
    解压并解包： tar -Jxvf [原文件名].tar.xz
#+END_EXAMPLE

注：大写J代表用xz算法来压缩/解压。

****** tar.Z格式（已过时）

方式一：利用已经打包好的tar文件，直接用压缩命令：

#+BEGIN_EXAMPLE
    压缩：compress [原文件名].tar
    解压：uncompress [原文件名].tar.Z
#+END_EXAMPLE

方式二：一次性打包并压缩、解压并解包

#+BEGIN_EXAMPLE
    打包并压缩： tar -Zcvf [目标文件名].tar.Z [原文件名/目录名]
    解压并解包： tar -Zxvf [原文件名].tar.Z
#+END_EXAMPLE

注：大写Z代表用ncompress算法来压缩/解压。另，ncompress是早期Unix系统的压缩格式，但由于ncompress的压缩率太低，现已过时。

****** jar格式                                                     :jar:

#+BEGIN_EXAMPLE
    压缩：jar -cvf [目标文件名].jar [原文件名/目录名]
    解压：jar -xvf [原文件名].jar
#+END_EXAMPLE

注：如果是打包的是Java类库，并且该类库中存在主类，那么需要写一个META-INF/MANIFEST.MF配置文件，内容如下：

#+BEGIN_EXAMPLE
    Manifest-Version: 1.0
    Created-By: 1.6.0_27 (Sun Microsystems Inc.)
    Main-class: the_name_of_the_main_class_should_be_put_here
#+END_EXAMPLE

然后用如下命令打包：

#+BEGIN_EXAMPLE
    jar -cvfm [目标文件名].jar META-INF/MANIFEST.MF [原文件名/目录名]
#+END_EXAMPLE

这样以后就能用“java -jar [文件名].jar”命令直接运行主类中的public static
void main方法了。

****** 7z格式                                                       :7z:

#+BEGIN_EXAMPLE
    压缩：7z a [目标文件名].7z [原文件名/目录名]
    解压：7z x [原文件名].7z
#+END_EXAMPLE

注：这个7z解压命令支持rar格式，即：

#+BEGIN_EXAMPLE
    7z x [原文件名].rar
#+END_EXAMPLE
***** tar                                                           :tar:
建立档案文件

1. 语法: *tar [option] tarfile filename*
2. 说明: 文件名必须紧跟在-f参数后,且-f作为参数的最后一项;
3. 选项:
   + -c 建立一个新的档案文件;
   + -f 指定档案文件名
   + -r 往归档文件中追加文件
   + -x 从档案文件中提取文件
   + -v,-vv 显示进度信息
   + -t 列出存档文件的信息(不提取)
   + -c 指定文件提取的目录
   + -a 合并多个tar文件
   + --totals 归档完成后,打印总归档字节数
   + --delete 从归档文件中删除指定的文件
   + --exclude 归档时,排除指定样式的文件
   + -j 生成归档文件时,使用bunzip2格式进行压缩
   + -z 生成归档文件时,使用gzip格式进行压缩
   + --lzma 生成归档文件时,使用lzma格式进行压缩
   + -a 生成归档文件时,根据扩展名自动进行压缩
4. 用法
   1) 打tar包,名称为all.tar
      #+begin_example
        $ tar -cvf all.tar *.text
      #+end_example
   2) 追加文件b.doc
      #+begin_example
        $ tar -rvf all.tar b.doc
      #+end_example
   3) 列出归档文件中的内容
      #+begin_example
        $ tar -tvf all.tar
      #+end_example
   4) 提取归档文件中的全部文件
      #+begin_example
        $ tar -xvf all.tar
        $ tar -xvf all.tar -c /opt/app/tool_dir
      #+end_example
   5) 提取归档文件中的指定文件
      #+begin_example
        $ tar -xvf all.tar file_one file_tw
      #+end_example
   6) 合并两个tar文件
      #+begin_example
        $ tar -af file_one.tar file_two.ta
      #+end_example
   7) 删除指定的文件
      #+begin_example
        $ tar -f all.tar --delete file_one file_tw
      #+end_example
   8) 归档时,排除日志文件
      #+begin_example
        $ tar -cf all.tar * --exclude ”*.log
      #+end_example

***** [[http://blog.csdn.net/wangjunjun2008/article/details/21982843][tar 建立档案文件]]                                             :blog:

【语法】 tar [option] tarfile filename

【命令说明】

文件名必须紧跟在-f参数后,且作为参数的最后一项;

【参数说明】

-c 建立一个新的档案文件;

-f 指定档案文件名;

-r 往归档文件中追加文件;

-x 从档案文件中提取文件;

-v,-vv 显示进度信息;

-t 列出存档文件的信息(不提取);

-C 指定文件提取的目录;

-A 合并多个tar文件;

--totals 归档完成后,打印总归档字节数;

--delete 从归档文件中删除指定的文件;

--exclude 归档时,排除指定样式的文件;

-j 生成归档文件时,使用bunzip2格式进行压缩;

-z 生成归档文件时,使用gzip格式进行压缩;

--lzma 生成归档文件时,使用lzma格式进行压缩;

-a 生成归档文件时,根据扩展名自动进行压缩;



【一般用法】

#打tar包,名称为all.tar

$ tar -cvf all.tar *.text;

#追加文件b.doc

$ tar -rvf all.tar b.doc;

#列出归档文件中的内容

$ tar -tvf all.tar;

#提取归档文件中的全部文件

$ tar -xvf all.tar;

$ tar -xvf all.tar -C /opt/app/tool_dir;

#提取归档文件中的指定文件

$ tar -xvf all.tar file_one file_two

#合并两个tar文件

$ tar -Af file_one.tar file_two.tar

#删除指定的文件

$ tar -f all.tar --delete file_one file_two

#归档时,排除日志文件

$ tar -cf all.tar * --exclude ”*.log”





*gzip/gunzip 进行压缩/解压缩*

【语法】

gzip [options] file;

gunzip [options] file;

【命令说明】

gzip只能压缩单个文件,如果指定多个文件,则会生成多个单独的压缩文件;

gzip会在生成压缩文件后,删除源文件!!!!

gunzip会在解压缩完成后,删除源文件!!!

【参数说明】

-l,--list 列出压缩文件的属性信息;

--fast 指定最低压缩比;

--best 指定最高压缩比;

-n 指定压缩比(n为数字,且1<=n<=9);

-v 显示进度信息;





*bzip2/bunzip2 进行压缩/解压缩*

【语法】

bzip2 file;

bunzip2 file;

【命令说明】

bzip2通常能生成比gzip压缩比更高的文件;默认bzip2会删除源文件,可使用-k参数保留源文件;

【参数说明】

-k 保留源文件;

-n 指定压缩比(n为数字,且1<=n<=9);





*zip/unzip 进行压缩/解压缩*

【语法】 zip [options] file file dirs

【命令说明】

zip压缩/解压缩后,不会删除源文件;

【参数说明】

-r 递归;压缩目录时使用;

-l 列出压缩文件内容;

-d 从压缩文件中删除指定文件;

-u 更新压缩文件的内容;



【一般用法】

#压缩文件

$ zip all.zip file;

$ zip all.zip file_one file_two;

$ zip -r all.zip dir_name;

#更新压缩文件

$ zip all.zip -u log.text

#删除指定的内容

$ zip -d all.zip log.text;



#解压文件

$ unzip all.zip;

#列出压缩文件内容

$ unzip -l all.zip;
**** gzip/gunzip                                                    :gzip:

进行压缩/解压缩

1. 语法:
   + gzip [options] file
   + gunzip [options] file
2. 说明:
   + gzip只能压缩单个文件,如果指定多个文件,则会生成多个单独的压缩文件;
   + gzip会在生成压缩文件后,删除源文件!!!!
   + gunzip会在解压缩完成后,删除源文件!!!
3. 选项
   1) -l,--list 列出压缩文件的属性信息
   2) --fast 指定最低压缩比
   3) --best 指定最高压缩比
   4) -n 指定压缩比(n为数字,且1<=n<=9)
   5) -v 显示进度信息

***** gzip命令

来自: http://man.linuxde.net/gzip

*gzip命令* 用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，
其名称后面会多处“.gz”扩展名。

gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和[[http://man.linuxde.net/tar][tar]]命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。

****** 语法\\

#+BEGIN_EXAMPLE
    gzip(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -a或——ascii：使用ASCII文字模式；
    -d或--decompress或----uncompress：解开压缩文件；
    -f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；
    -h或——help：在线帮助；
    -l或——list：列出压缩文件的相关信息；
    -L或——license：显示版本与版权信息；
    -n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；
    -N或——name：压缩文件时，保存原来的文件名称及时间戳记；
    -q或——quiet：不显示警告信息；
    -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；
    -S或<压缩字尾字符串>或----suffix<压缩字尾字符串>：更改压缩字尾字符串；
    -t或——test：测试压缩文件是否正确无误；
    -v或——verbose：显示指令执行过程；
    -V或——version：显示版本信息；
    -<压缩效率>：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；
    --best：此参数的效果和指定“-9”参数相同；
    --fast：此参数的效果和指定“-1”参数相同。
#+END_EXAMPLE

****** 参数\\

文件列表：指定要压缩的文件列表。

****** 实例\\

把test6目录下的每个文件压缩成.gz文件

#+BEGIN_EXAMPLE
    gzip *
#+END_EXAMPLE

把上例中每个压缩的文件解压，并列出详细的信息

#+BEGIN_EXAMPLE
    gzip -dv *
#+END_EXAMPLE

详细显示例1中每个压缩的文件的信息，并不解压

#+BEGIN_EXAMPLE
    gzip -l *
#+END_EXAMPLE

压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gz

#+BEGIN_EXAMPLE
    gzip -r log.tar
#+END_EXAMPLE

递归的压缩目录

#+BEGIN_EXAMPLE
    gzip -rv test6
#+END_EXAMPLE

这样，所有test下面的文件都变成了*.gz，目录依然存在只是目录里面的文件相应变成了*.gz.这就是压缩，和打包不同。因为是对目录操作，所以需要加上-r选项，这样也可以对子目录进行递归了。

递归地解压目录

#+BEGIN_EXAMPLE
    gzip -dr test6
#+END_EXAMPLE

**** bzip2/bunzip2                                                 :bzip2:

进行压缩/解压缩

1. 语法:
   + *bzip2 file*
   + *pbunzip2 file*
2. 说明: bzip2通常能生成比gzip压缩比更高的文件;默认bzip2会删除源文件,
   可使用-k参数保留源文件;
3. 选项:
   1) -k 保留源文件
   2) -n 指定压缩比(n为数字,且1<=n<=9);

***** bzip2命令

来自: http://man.linuxde.net/bzip2

*bzip2命令* 用于创建和管理（包括解压缩）“.bz2”格式的压缩包。我们遇见
Linux压缩打包方法有很多种，以下讲解了Linux压缩打包方法中的Linux
bzip2命令的多种范例供大家查看，相信大家看完后会有很多收获。

****** 语法\\

#+BEGIN_EXAMPLE
    bzip2(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -c或——stdout：将压缩与解压缩的结果送到标准输出；
    -d或——decompress：执行解压缩；
    -f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；
    -h或——help：在线帮助；
    -k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；
    -s或——small：降低程序执行时内存的使用量；
    -t或——test：测试.bz2压缩文件的完整性；
    -v或——verbose：压缩或解压缩文件时，显示详细的信息；
    -z或——compress：强制执行压缩；
    -V或——version：显示版本信息；
    --repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；
    --repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。
#+END_EXAMPLE

****** 参数\\

文件：指定要压缩的文件。

****** 实例\\

*压缩指定文件filename:*

#+BEGIN_EXAMPLE
    bzip2 filename
    或
    bzip2 -z filename
#+END_EXAMPLE

这里，压缩的时候不会输出，会将原来的文件filename给删除，替换成filename.bz2.如果以前有filename.bz2则不会替换并提示错误（如果想要替换则指定-f选项，例如=bzip2 -f filename=；如果filename是目录则也提醒错误不做任何操作；如果filename已经是压过的了有bz2后缀就提醒一下，不再压缩，没有bz2后缀会再次压缩。

*解压指定的文件filename.bz2:*

#+BEGIN_EXAMPLE
    bzip2 -d filename.bz2
    或
    bunzip2 filename.bz2
#+END_EXAMPLE

这里，解压的时候没标准输出，会将原来的文件filename.bz2给替换成filename。如果以前有filename则不会替换并提示错误（如果想要替换则指定=-f=选项，例如=bzip2 -df filename.bz2=。

*压缩解压的时候将结果也输出：*

#+BEGIN_EXAMPLE
    $bzip2 -v filename
#+END_EXAMPLE

输入之后，输出如下：

#+BEGIN_EXAMPLE
    filename:  0.119:1, 67.200 bits/byte, -740.00% saved, 5 in, 42 out.
#+END_EXAMPLE

这里，加上=-v=选项就会输出了,只用压缩举例了，解压的时候同理=bzip2 -dv filename.bz2=不再举例了。

*模拟解压实际并不解压：*

#+BEGIN_EXAMPLE
    bzip2 -tv filename.bz2
#+END_EXAMPLE

输入之后，输出如下：

#+BEGIN_EXAMPLE
    filename.bz2: ok
#+END_EXAMPLE

这里，=-t=指定要进行模拟解压，不实际生成结果，也就是说类似检查文件,当然就算目录下面有filename也不会有什么错误输出了，因为它根本不会真的解压文件。为了在屏幕上输出，这里加上=-v=选项了,如果是真的解压=bzip2 -dv filename.bz2=则输出的是把"ok"替换成了"done"。

*压缩解压的时候，除了生成结果文件，将原来的文件也保存:*

#+BEGIN_EXAMPLE
    bzip2 -k filename
#+END_EXAMPLE

这里，加上=-k=就保存原始的文件了，否则原始文件会被结果文件替代。只用压缩举例了，解压的时候同理=$bzip2 -dk filename.bz2=不再举例了。

*解压到标准输出：*

#+BEGIN_EXAMPLE
    bzip2 -dc filename.bz2
#+END_EXAMPLE

输入之后，输出如下：

#+BEGIN_EXAMPLE
    hahahhaahahha
#+END_EXAMPLE

这里，使用=-c=指定到标准输出，输出的是文件filename的内容，不会将filename.bz2删除。

*压缩到标准输出：*

#+BEGIN_EXAMPLE
    bzip2 -c filename
    bzip2: I won't write compressed data to a terminal.
    bzip2: For help, type: `bzip2 --help'.
#+END_EXAMPLE

这里，使用=-c=指定压缩到标准输出不删除原有文件，不同的是，压缩后的文件无法输出到标准输出。

*使用bzip2的时候将所有后面的看作文件(即使文件名以'-'开头)：*

#+BEGIN_EXAMPLE
    bzip2 -- -myfilename
#+END_EXAMPLE

这里主要是为了防止文件名中=-=产生以为是选项的歧义。

**** zip/unzip                                                       :zip:
进行压缩/解压缩

1. 语法: zip [options] file file dirs
2. 说明: zip压缩/解压缩后,不会删除源文件;
3. 选项:
   1) -r 递归;压缩目录时使用;
   2) -l 列出压缩文件内容
   3) -d 从压缩文件中删除指定文件
   4) -u 更新压缩文件的内容
4. 用法
   1) 压缩文件
      #+begin_example
        $ zip all.zip file
        $ zip all.zip file_one file_two
        $ zip -r all.zip dir_name
      #+end_example
   2) 更新压缩文件
      #+begin_example
        $ zip all.zip -u log.text
      #+end_example
   3) 删除指定的内容
      #+begin_example
        $ zip -d all.zip log.text
      #+end_example
   4) 解压文件
      #+begin_example
        $ unzip all.zip
      #+end_example
   5) 列出压缩文件内容
      #+begin_example
        $ unzip -l all.zip;
      #+end_example

***** zip命令

来自: http://man.linuxde.net/zip

*zip命令* 可以用来解压缩文件，或者对文件进行打包操作。zip是个使用广泛
的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件。

****** 语法\\

#+BEGIN_EXAMPLE
    zip(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -A：调整可执行的自动解压缩文件；
    -b<工作目录>：指定暂时存放文件的目录；
    -c：替每个被压缩的文件加上注释；
    -d：从压缩文件内删除指定的文件；
    -D：压缩文件内不建立目录名称；
    -f：此参数的效果和指定“-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中；
    -F：尝试修复已损坏的压缩文件；
    -g：将文件压缩后附加在已有的压缩文件之后，而非另行建立新的压缩文件；
    -h：在线帮助；
    -i<范本样式>：只压缩符合条件的文件；
    -j：只保存文件名称及其内容，而不存放任何目录名称；
    -J：删除压缩文件前面不必要的数据；
    -k：使用MS-DOS兼容格式的文件名称；
    -l：压缩文件时，把LF字符置换成LF+CR字符；
    -ll：压缩文件时，把LF+cp字符置换成LF字符；
    -L：显示版权信息；
    -m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中；
    -n<字尾字符串>：不压缩具有特定字尾字符串的文件；
    -o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同；
    -q：不显示指令执行过程；
    -r：递归处理，将指定目录下的所有文件和子目录一并处理；
    -S：包含系统和隐藏文件；
    -t<日期时间>：把压缩文件的日期设成指定的日期；
    -T：检查备份文件内的每个文件是否正确无误；
    -u：更换较新的文件到压缩文件内；
    -v：显示指令执行过程或显示版本信息；
    -V：保存VMS操作系统的文件属性；
    -w：在文件名称里假如版本编号，本参数仅在VMS操作系统下有效；
    -x<范本样式>：压缩时排除符合条件的文件；
    -X：不保存额外的文件属性；
    -y：直接保存符号连接，而非该链接所指向的文件，本参数仅在UNIX之类的系统下有效；
    -z：替压缩文件加上注释；
    -$：保存第一个被压缩文件所在磁盘的卷册名称；
    -<压缩效率>：压缩效率是一个介于1~9的数值。
#+END_EXAMPLE

****** 参数\\

-  zip压缩包：指定要创建的zip压缩包；
-  文件列表：指定要压缩的文件列表。

****** 实例\\

将=/home/Blinux/html/=这个目录下所有文件和文件夹打包为当前目录下的html.zip：

#+BEGIN_EXAMPLE
    zip -q -r html.zip /home/Blinux/html
#+END_EXAMPLE

上面的命令操作是将绝对地址的文件及文件夹进行压缩，以下给出压缩相对路径目录，比如目前在Bliux这个目录下，执行以下操作可以达到以上同样的效果：

#+BEGIN_EXAMPLE
    zip -q -r html.zip html
#+END_EXAMPLE

比如现在我的html目录下，我操作的zip压缩命令是：

#+BEGIN_EXAMPLE
    zip -q -r html.zip *
#+END_EXAMPLE

*** 文件备份和恢复

*** 文件传输

*** 文件系统管理
**** mkfs                                                           :mkfs:
***** mkfs -h
Usage: mkfs [options] [-t type fs-options] device [size]

Options:
 -t, --type=TYPE  file system type, when undefined ext2 is used
     fs-options   parameters to real file system builder
     device       path to a device
     size         number of blocks on the device
 -V, --verbose    explain what is done
                  defining -V more than once will cause a dry-run
 -V, --version    output version information and exit
                  -V as version must be only option
 -h, --help       display this help and exit

***** mkfs.<TAB>

mkfs          mkfs.ext2     mkfs.ext4dev  mkfs.msdos
mkfs.bfs      mkfs.ext3     mkfs.fat      mkfs.ntfs
mkfs.cramfs   mkfs.ext4     mkfs.minix    mkfs.vfat

***** 手记

1. df

2. umount /dev/sdb4

3. mkfs.ntfs /dev/sdb4

   #+BEGIN_EXAMPLE
     sudo mkfs.ntfs /dev/sdb4
     Cluster size has been automatically set to 4096 bytes.
     Initializing device with zeroes:   8%
   #+END_EXAMPLE

   指定 size 大小，默认太慢。不能中断，除非不想要U盘了！！！

***** mkfs命令

来自: http://man.linuxde.net/mkfs

*mkfs命令* 用于在设备上（通常为硬盘）创建Linux文件系统。mkfs本身并不执
行建立文件系统的工作，而是去调用相关的程序来执行。

****** 语法\\

#+BEGIN_EXAMPLE
    mkfs(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    fs：指定建立文件系统时的参数；
    -t<文件系统类型>：指定要建立何种文件系统；
    -v：显示版本信息与详细的使用方法；
    -V：显示简要的使用方法；
    -c：在制做档案系统前，检查该partition是否有坏轨。
#+END_EXAMPLE

****** 参数\\

-  文件系统：指定要创建的文件系统对应的设备文件名；
-  块数：指定文件系统的磁盘块数。

****** 实例\\

在=/dev/hda5=上建一个msdos的档案系统，同时检查是否有坏轨存在，并且将过程详细列出来：

#+BEGIN_EXAMPLE
    mkfs -V -t msdos -c /dev/hda5

    mkfs -t ext3 /dev/sda6     //将sda6分区格式化为ext3格式
    mkfs -t ext2 /dev/sda7     //将sda7分区格式化为ext2格式
#+END_EXAMPLE

**** mount                                                         :mount:
***** [[http://www.douban.com/note/170604841/][linux 自动挂载 windows分区]] :blog:

个人学习linux日志，高手绕过

对于linux系统挂载windows分区是必须的，比如你u盘 fat32的或是ntfs的格式
的。当然这个在ubuntu的我我文件管理器nautilus	会自动挂载。而对双系统
用户你的windows在默认的情况下就不会被挂载。当然于是你打开音乐播放器放
音乐之前还要打开nautilus 挂载下。如果我的启动是在命令行下 那好也要手动
mount下。也有一种软件能够让你自动挂载windows  比如ntfs-config 和ivman
。ntfs-config就用过一次。就是有次重装之前，被ntfs-config 搞的 / 分区无
法挂载（当时还不懂改fstab，汗 只好重装）。其实我们只需要手懂配置fstab
来挂载linux分区。

fstab 拆开下 filesystem  table 也就是 linux开机过程控制你要挂载的硬盘
分区配置文件（并没说开机后不能用）。关于挂可以参考
http://forum.ubuntu.org.cn/viewtopic.php?f=120&t=257333的内容。

修改fstab内容是这样的    个人学习linux日志，高手绕过

对于linux系统挂载windows分区是必须的，比如你u盘 fat32的或是ntfs的格式
的。当然这个在ubuntu的我我文件管理器nautilus	会自动挂载。而对双系统
用户你的windows在默认的情况下就不会被挂载。当然于是你打开音乐播放器放
音乐之前还要打开nautilus 挂载下。如果我的启动是在命令行下 那好也要手动
mount下。也有一种软件能够让你自动挂载windows  比如ntfs-config 和ivman
。ntfs-config就用过一次。就是有次重装之前，被ntfs-config 搞的 / 分区无
法挂载（当时还不懂改fstab，汗 只好重装）。其实我们只需要手懂配置fstab
来挂载linux分区。

fstab 拆开下 filesystem  table 也就是 linux开机过程控制你要挂载的硬盘
分区配置文件（并没说开机后不能用）。关于挂可以参考
http://forum.ubuntu.org.cn/viewtopic.php?f=120&t=257333的内容。

修改fstab内容是这样的

# <file system> <mount point>   <type>  <options>       <dump>  <pass>

 # / was on /dev/sda3 during installation
UUID=c5dc9d91-c74b-4d1f-a232-d3151fd57157    /               ext4    errors=remount-ro     0       1
或者是
/dev/sda3      /        ext4        errors=remount-ro     0       1
#的后的面的部分是给人看的，即后面的对已来说是只是乱码 ，前面是同过uuid 挂载面的则是 通过 分区编号
我们所要做的修改
首先对于linux读取 ntfs分区靠的是 ntfs-3g 所以首先检查下ntfs-3g 有没有安装   sudo  apt-get
install ntfs-3g （这个 一般都会安装 n年ubuntu 要手动装）ntfs-3g 参看 http://www.linuxsir.org/main/node/281
   其次查看你要挂分区的硬件号 或者uuid   一般来说你D盘是 /dev/sda5， E盘是/dev/sda6  一次向后 实在确定 可以先mount看下 看uuid
 sudo blkid
我的是/dev/sda1: LABEL="C" UUID="34C85D1DC85CDF24" TYPE="ntfs"
/dev/sda2: UUID="f17f1975-e0f7-489c-87a6-7393efa34355" TYPE="ext2"
/dev/sda3: UUID="c5dc9d91-c74b-4d1f-a232-d3151fd57157" TYPE="ext4"
/dev/sda5: LABEL="D" UUID="178D4B66B84A6E29" TYPE="ntfs"
/dev/sda6: LABEL="E" UUID="5E352DAE4AAB4664" TYPE="ntfs"
/dev/sda7: LABEL="F" UUID="D3F7A6DDFEB31F89" TYPE="ntfs"
/dev/sda8: UUID="f670f9ac-f2ae-4485-b8d1-d3b53e099962" TYPE="reiserfs"
/dev/sda9: UUID="37eefbed-32f7-4514-9154-9129747d0066" TYPE="swap"
/dev/sda10: UUID="e27b304b-78c7-4f05-a8c0-b9b73669bc9d" TYPE="ext4
或者 ls -al /dev/disk/by-uuid

建议用uuid。 因为uuid是 一个硬盘分区 全 中国 全世界 全宇宙的唯一标示符 ，当然uuid 不仅标示硬盘分区标示其他电脑设备 具体的 请google
  然后
1.对fstab 进行备份
cp  /etc/fstab  /etc/fstab.bak
这是一种习惯 修改错的话 cp回来覆盖就行了  比如这里 可以 cp /etc/fstab.bak  /etc/fstab  记不住 目录名 这个你可以搞笔记本 稍微记录下，注意多用神键 tab 键 在输入的时候自动补齐
2.设置你的挂载点 就是你要把文件挂载到哪里
比如我想把E盘的挂载到是 /home/fly/wp/E这个目录下
那么 我就先创键这个目录
mkdir   /home/fly/wp/E
也可以顺便多建几个 mkdir /home/fly/wp/C  /home/fly/wp/F  ……
修改
sudo vim fstab
在文件后 添加你要挂载分区的信息
<uuid  或 分区标号>       <挂载点>      <分区格式>       < 挂载参数 >   0  0
比如我要要挂载我的E盘
 那么 就是
UUID="5E352DAE4AAB4664"     /home/fly/wp/E     ntfs-3g      default  0   0
或者是
/dev/sda6         /home/fly/wp/E    ntfs-3g     default  0  0
  其中 第4 挂载参数 默人填 default 就行 如果需要更多的功能可以藏  这么填写  defaults,utf8,umask=000,uid=fly,gid=fly     （uid 后面的参数 是你用户名 gid后面的是你的用户组名，）gid ，uid 主要是为了你可能无法将文件删除近回收站  umask这个参是防止你不能读写文件  文件utf8 是考虑可能出现的乱码 ，
具体看uid和gid 可以参考http://blog.csdn.net/wl_haanel/article/details/4793176
umask 参考 http://www.linuxso.com/command/umask.html
utf8这个假如你的文件都去是乱的话可以改成

***** mount命令

来自: http://man.linuxde.net/mount

*mount命令* 用于加载文件系统到指定的加载点。此命令的最常用于挂载cdrom，
使我们可以访问cdrom中的数据，因为你将光盘插入cdrom中，Linux并不会自动
挂载，必须使用Linux
mount命令来手动完成挂载。

****** 语法\\

#+BEGIN_EXAMPLE
    mount(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -V：显示程序版本；
    -l：显示已加载的文件系统列表；
    -h：显示帮助信息并退出；
    -v：冗长模式，输出指令执行的详细信息；
    -n：加载没有写入文件“/etc/mtab”中的文件系统；
    -r：将文件系统加载为只读模式；
    -a：加载文件“/etc/fstab”中描述的所有文件系统。
#+END_EXAMPLE

****** 参数\\

-  设备文件名：指定要加载的文件系统对应的设备名；
-  加载点：指定加载点目录。

****** 实例\\

#+BEGIN_EXAMPLE
    mount -t auto /dev/cdrom /mnt/cdrom
    mount: mount point /mnt/cdrom does not exist           /mnt/cdrom目录不存在，需要先创建。

    cd /mnt
    -bash: cd: /mnt: No such file or directory

    mkdir -p /mnt/cdrom    创建/mnt/cdrom目录
    ls
    bin   dev  home    lib         media  mnt  proc  sbin     srv  tmp  var
    boot  etc  initrd  lost+found  misc   opt  root  selinux  sys  usr

    mount -t auto /dev/cdrom /mnt/cdrom     挂载cdrom
    mount: block device /dev/cdrom is write-protected, mounting read-only     挂载成功

    ll /mnt/cdrom    查看cdrom里面内容
    total 859
    dr-xr-xr-x  4 root root   2048 Sep  4  2005 CentOS
    -r--r--r--  2 root root   8859 Mar 19  2005 centosdocs-man.css
    -r--r--r--  9 root root  18009 Mar  1  2005 GPL
    dr-xr-xr-x  2 root root 241664 May  7 02:32 headers
    dr-xr-xr-x  4 root root   2048 May  7 02:23 images
    dr-xr-xr-x  2 root root   4096 May  7 02:23 isolinux
    dr-xr-xr-x  2 root root  18432 May  2 18:50 NOTES
    -r--r--r--  2 root root   5443 May  7 01:49 RELEASE-NOTES-en.html
    dr-xr-xr-x  2 root root   2048 May  7 02:34 repodata
    -r--r--r--  9 root root   1795 Mar  1  2005 rpm-GPG-KEY
    -r--r--r--  2 root root   1795 Mar  1  2005 RPM-GPG-KEY-centos4
    -r--r--r--  1 root root 571730 May  7 01:39 yumgroups.xml
#+END_EXAMPLE

** 硬件|监测|内核|shell

*** 硬件管理
**** lsusb                                                         :lsusb:
***** lsusb查看系统中的USB设备

#+BEGIN_EXAMPLE
$ lsusb
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
...
#+END_EXAMPLE

1. BUS 002: 表示第2个 *usb 主控制器* ， 通过命令 *lspci | grpe USB* 查
   看

   #+BEGIN_EXAMPLE
   lspci | grep USB
   00:1a.0 USB controller: Intel Corporation 82801JD/DO (ICH10 Family) USB UHCI Controller #4 (rev 02)
   #+END_EXAMPLE

2. Device 001: 表示系统给USB分配的设备号 (*devnum*)

3. ID 1d6d:0001: 表示USB设备的ID，由芯片制造商设置，可以 *唯一* 标识该
   设备
   1) 1d6d    *usb_device_descriptor.idVendor*
   2) 0001    *usb_device_descriptor.idProduct*

***** [[http://blog.csdn.net/yimiyangguang1314/article/details/6449589][lsusb 输出信息]] :blog:

插入usb鼠标后执行lsusb的输出内容如下:
-----------------------------------------
Bus 005 Device 001: ID 0000:0000
Bus 001 Device 001: ID 0000:0000
Bus 004 Device 001: ID 0000:0000
Bus 003 Device 001: ID 0000:0000
Bus 002 Device 006: ID 15d9:0a37
Bus 002 Device 001: ID 0000:0000

内容解读:
-----------------------------------------
Bus 005
    表示第五个usb主控制器(机器上总共有5个usb主控制器 -- 可以通过命令lspci | grep USB查看)

Device 006
    表示系统给usb鼠标分配的设备号(devnum)，同时也可以看到该鼠标是插入到了第二个usb主控制器
    006        usb_device.devnum
    /sys/devices/pci0000:00/0000:00:1d.1/usb2/2-2/devnum

ID 15d9:0a37
    表示usb设备的ID(这个ID由芯片制造商设置，可以唯一表示该设备)
    15d9    usb_device_descriptor.idVendor
    0a37    usb_device_descriptor.idProduct
    /sys/devices/pci0000:00/0000:00:1d.1/usb2/2-2/idVendor

Bus 002 Device 006: ID 15d9:0a37
Bus 002 Device 001: ID 0000:0000
    表示002号usb主控制器上接入了两个设备:
    一个是usb根Hub -- 001
    一个是usb鼠标   -- 006

说明：

lsusb命令是一个学习USB驱动开发，认识USB设备的助手，推荐大家使用，如果您的开发板中或者产品中没有lsusb命令可以自己移植一个，放到文件系统里面.

***** lsusb命令

来自: http://man.linuxde.net/lsusb

*lsusb命令* 用于显示本机的USB设备列表，以及USB设备的详细信息。

lsusb命令是一个学习USB驱动开发，认识USB设备的助手，推荐大家使用，如果您的开发板中或者产品中没有lsusb命令可以自己移植一个，放到文件系统里面。

****** 语法\\

#+BEGIN_EXAMPLE
    lsusb(选项)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -v：显示USB设备的详细信息；
    -s<总线：设备号>仅显示指定的总线和（或）设备号的设备；
    -d<厂商：产品>：仅显示指定厂商和产品编号的设备；
    -t：以树状结构显示无理USB设备的层次；
    -V：显示命令的版本信息。
#+END_EXAMPLE

****** 实例\\

插入usb鼠标后执行lsusb的输出内容如下:

#+BEGIN_EXAMPLE
    Bus 005 Device 001: id 0000:0000
    Bus 001 Device 001: ID 0000:0000
    Bus 004 Device 001: ID 0000:0000
    Bus 003 Device 001: ID 0000:0000
    Bus 002 Device 006: ID 15d9:0a37
    Bus 002 Device 001: ID 0000:0000
#+END_EXAMPLE

解释：

*Bus 005*

表示第五个usb主控制器(机器上总共有5个usb主控制器 --
可以通过命令[[http://man.linuxde.net/lspci][lspci]] |
[[http://man.linuxde.net/grep][grep]] USB查看)

*Device 006*

表示系统给usb鼠标分配的设备号(devnum)，同时也可以看到该鼠标是插入到了第二个usb主控制器

#+BEGIN_EXAMPLE
    006        usb_device.devnum
    /sys/devices/pci0000:00/0000:00:1d.1/usb2/2-2/devnum
#+END_EXAMPLE

*ID 15d9:0a37*

表示usb设备的ID（这个ID由芯片制造商设置，可以唯一表示该设备）

#+BEGIN_EXAMPLE
    15d9    usb_device_descriptor.idVendor
    0a37    usb_device_descriptor.idProduct
    /sys/devices/pci0000:00/0000:00:1d.1/usb2/2-2/idVendor
#+END_EXAMPLE

*Bus 002 Device 006: ID 15d9:0a37\\
 Bus 002 Device 001: ID 0000:0000*

表示002号usb主控制器上接入了两个设备:

-  一个是usb根Hub -- 001 
-  一个是usb鼠标  -- 006

*** 内核与模块管理

*** 性能监测与优化
**** free                                                    :free:memory:
***** man                                                           :man:

1. NAME: free - _Display amount of free and used memory in the system_

2. SYNOPSIS:  *free [options]*

3. DESCRIPTION

   free  displays the total amount of free and used physical and swap
   memory in the system, as well as the buffers used by the kernel.
   The shared memory column represents either the MemShared value (2.4
   series kernels) or the Shmem value (2.6 series kernels and later)
   taken from the _/proc/meminfo_ file. The value is zero if none of the
   entries is exported by the kernel.

4. OPTIONS

   - -b, --bytes

     Display the amount of memory in bytes.

   - -k, --kilo

     Display the amount of memory in kilobytes.  This is the default.

   - -m, --mega

      Display the amount of memory in megabytes.

   - -g, --giga

     Display the amount of memory in gigabytes.

   - --tera Display the amount of memory in terabytes.

   - -h, --human

     Show all output fields automatically scaled to shortest three
     digit unit and display the units of print out.  Following units
     are used.
     - B = bytes
     - K = kilos
     - M = megas
     - G = gigas
     - T = teras

      If unit is missing, and you have petabyte of RAM or swap, the
      number is in terabytes and columns might not be aligned with
      header.

   - -c, --count count

     Display the result count times.  Requires the -s option.

   - -l, --lohi

***** example

#+BEGIN_SRC sh :results output
free -h
#+END_SRC

#+RESULTS:
:              total       used       free     shared    buffers     cached
: Mem:          3.7G       2.0G       1.6G       4.7M       377M       689M
: -/+ buffers/cache:       1.0G       2.7G
: Swap:         3.8G       1.1G       2.7G

***** free命令

来自: http://man.linuxde.net/free

*free命令* 可以显示当前系统未使用的和已使用的内存数目，还可以显示被内
核使用的内存缓冲区。

****** 语法\\

#+BEGIN_EXAMPLE
    free(选项)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -b：以Byte为单位显示内存使用情况；
    -k：以KB为单位显示内存使用情况；
    -m：以MB为单位显示内存使用情况；
    -o：不显示缓冲区调节列；
    -s<间隔秒数>：持续观察内存使用状况；
    -t：显示内存总和列；
    -V：显示版本信息。
#+END_EXAMPLE

****** 实例\\

#+BEGIN_EXAMPLE
    free -m
                 total       used       free     shared    buffers     cached
    Mem:          2016       1973         42          0        163       1497
    -/+ buffers/cache:        312       1703
    Swap:         4094          0       4094
#+END_EXAMPLE

*第一部分Mem行解释：*

#+BEGIN_EXAMPLE
    total：内存总数；
    used：已经使用的内存数；
    free：空闲的内存数；
    shared：当前已经废弃不用；
    buffers Buffer：缓存内存数；
    cached Page：缓存内存数。
#+END_EXAMPLE

关系：total = used + free

*第二部分(-/+ buffers/cache)解释:*

#+BEGIN_EXAMPLE
    (-buffers/cache) used内存数：第一部分Mem行中的 used – buffers – cached
    (+buffers/cache) free内存数: 第一部分Mem行中的 free + buffers + cached
#+END_EXAMPLE

可见-buffers/cache反映的是被程序实实在在吃掉的内存，而+buffers/cache反映的是可以挪用的内存总数。

第三部分是指交换分区。

*** Shell内建命令

**** export                                                       :export:

***** export
1. 功能说明：设置或显示环境变量

2. 语法：
   + export [-fnp][变量名称]=[变量设置值]

3. 补充说明：
   + 在shell中执行程序时，shell会提供一组环境变量。
   + export可新增，修改或删除环境变量，供后续执行的程序使用。
   + export的效力仅及于该此登陆操作。

4. 参数：
   + -f 　代表[变量名称]中为函数名称。
   + -n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的
     执行环境中。
   + -p 　列出所有的shell赋予程序的环境变量。

***** export命令

来自: http://man.linuxde.net/export


*export命令* 用于将shell变量输出为环境变量，或者将shell函数输出为环境
变量。

一个变量创建时，它不会自动地为在它之后创建的shell进程所知。而命令
export可以向后面的shell传递变量的值。当一个shell脚本调用并执行时，它不
会自动得到原为脚本（调用者）里定义的变量的访问权，除非这些变量已经被显
式地设置为可用。export命令可以用于传递一个或多个变量的值到任何后继脚本。

****** 语法

#+BEGIN_EXAMPLE
    export(选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -f：代表[变量名称]中为函数名称；
    -n：删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中；
    -p：列出所有的shell赋予程序的环境变量。
#+END_EXAMPLE

****** 参数

变量：指定要输出或者删除的环境变量。

****** 实例

一般来说，配置交叉编译工具链的时候需要指定编译工具的路径，此时就需要设置环境变量。查看已经存在的环境变量：

#+BEGIN_EXAMPLE
    [root@localhost ~]# export
    declare -x G_BROKEN_FILENAMES="1"
    declare -x HISTSIZE="1000"
    declare -x HOME="/root"
    declare -x hostname="localhost"
    declare -x INPUTRC="/etc/inputrc"
    declare -x LANG="zh_CN.UTF-8"
    declare -x LESSOPEN="|/usr/bin/lesspipe.sh %s"
    declare -x logname="root"
    declare -x LS_COLORS="no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.cpio=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:"
    declare -x mail="/var/spool/mail/root"
    declare -x OLDPWD
    declare -x PATH="/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin"
    declare -x pwd="/root"
    declare -x SHELL="/bin/bash"
    declare -x SHLVL="1"
    declare -x SSH_CLIENT="192.168.2.111 2705 22"
    declare -x SSH_CONNECTION="192.168.2.111 2705 192.168.2.2 22"
    declare -x SSH_TTY="/dev/pts/0"
    declare -x TERM="linux"
    declare -x USER="root"
#+END_EXAMPLE

**** echo                                                           :echo:

***** usage
1. 引号
   #+begin_src sh :exports both
   echo hello world
   #+end_src

   #+results:
   : hello world

   #+begin_src sh :exports both
   echo "hello world"
   #+end_src

   #+results:
   : hello world

   #+begin_src sh :exports both
   echo 'hello world'
   #+end_src

   #+results:
   : hello world

   #+begin_src sh :exports both
   echo "hello bash's world"
   #+end_src

   #+results:
   : hello bash's world

2. 命令续行
   #+begin_src sh :exports both
   echo hello \
   world
   #+end_src

   #+results:
   : hello world

3. 换行

   #+begin_src sh :exports both
   echo "hello
   world"
   #+end_src

   #+results:
   | hello |
   | world |

   #+begin_src sh :exports both
   echo "hello \
   world"
   #+end_src

   #+results:
   : hello world

   #+begin_src sh :exports both
   echo  "hello"
   echo "world"
   #+end_src

   #+results:
   | hello |
   | world |

4. 行尾默认增加执行与 -n 选项

   #+begin_src sh :exports both
   echo -n "hello"
   echo "world"
   #+end_src

   #+results:
   : helloworld

   #+begin_src sh :exports code
     echo "hello\nworld"
     # hello\nworld
   #+end_src


   注：babel和terminal执行的结果不一样,因为org-babel默认的是sh,而ubuntu
   terminal使用的bash, 两者在使用上存在一定差异

5. -e 选项
   #+begin_src sh :exports both
   echo -e "hello\nworld"
   #+end_src

   #+results:
   | hello |
   | world |

***** echo命令

来自: http://man.linuxde.net/echo

*echo命令* 用于在shell中打印shell变量的值，或者直接输出指定的字符串。
linux的echo命令，在shell编程中极为常用,
在终端下打印变量value的时候也是常常用到的，因此有必要了解下echo的用法echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。

****** 语法

#+BEGIN_EXAMPLE
    echo(选项)(参数)
#+END_EXAMPLE

****** 选项

#+BEGIN_EXAMPLE
    -e：激活转义字符。
#+END_EXAMPLE

使用=-e=选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：

-  \a 发出警告声；
-  \b 删除前一个字符；
-  \c 最后不加上换行符号；
-  \f 换行但光标仍旧停留在原来的位置；
-  \n 换行且光标移至行首；
-  \r 光标移至行首，但不换行；
-  \t 插入tab；
-  \v 与\f相同；
-  \\ 插入\字符；
-  \nnn 插入nnn（八进制）所代表的ASCII字符；

****** 参数

变量：指定要打印的变量。

****** 实例

用echo命令打印带有色彩的文字：

*文字色：*

#+BEGIN_EXAMPLE
    echo -e "\e[1;31mThis is red text\e[0m"
    This is red text
#+END_EXAMPLE

-  =\e[1;31m= 将颜色设置为红色
-  =\e[0m= 将颜色重新置回

颜色码：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37

*背景色*：

#+BEGIN_EXAMPLE
    echo -e "\e[1;42mGreed Background\e[0m"
    Greed Background
#+END_EXAMPLE

颜色码：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47

*文字闪动：*

#+BEGIN_EXAMPLE
    echo -e "\033[37;31;5mMySQL Server Stop...\033[39;49;0m"
#+END_EXAMPLE

红色数字处还有其他数字参数：0 关闭所有属性、1 设置高亮度（加粗）、4
下划线、5 闪烁、7 反显、8 消隐

**** jobs                                                           :jobs:

***** jobs命令

来自: http://man.linuxde.net/jobs

*jobs命令* 用于显示Linux中的任务列表及任务状态，包括后台运行的任务。该
命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行
的，而进程号则是从系统管理员的角度来看的。一个任务可以对应于一个或者多
个进程号。

在Linux系统中执行某些操作时候，有时需要将当前任务暂停调至后台，或有时须将后台暂停的任务重启开启并调至前台，这一序列的操作将会使用到
jobs、[[http://man.linuxde.net/bg][bg]]、和
[[http://man.linuxde.net/fg][fg]] 三个命令以及两个快捷键来完成。

****** 语法\\

#+BEGIN_EXAMPLE
    jobs(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -l：显示进程号；
    -p：仅任务对应的显示进程号；
    -n：显示任务状态的变化；
    -r：仅输出运行状态（running）的任务；
    -s：仅输出停止状态（stoped）的任务。
#+END_EXAMPLE

****** 参数\\

任务标识号：指定要显示的任务识别号。

****** 实例\\

使用jobs命令显示当前系统的任务列表，输入如下命令：

#+BEGIN_EXAMPLE
    jobs -l               #显示当前系统的任务列表
#+END_EXAMPLE

上面的命令执行后，将显示出当前系统下的任务列表信息，具体如下所示：

#+BEGIN_EXAMPLE
    [1] + 1903 运行中          find / -name password &
#+END_EXAMPLE

注意：要得到以上输出信息，必须在执行jobs命令之前执行命令=find / -name password &=。否则，执行jobs命令不会显示任何信息。

其中，输出信息的第一列表示任务编号，第二列表示任务所对应的进程号，第三列表示任务的运行状态，第四列表示启动任务的命令。

**** kill                                                           :kill:

***** kill命令

来自: http://man.linuxde.net/kill

*kill命令* 用来删除执行中的程序或工作。kill可将指定的信息送至程序。预
设的信息为SIGTERM(15),可将指定程序终止。若仍无法终止该程序，可使用
SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用[[http://man.linuxde.net/ps][ps]]指令或job指令
查看。

****** 语法\\

#+BEGIN_EXAMPLE
    kill(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -a：当处理当前进程时，不限制命令名和进程号的对应关系；
    -l <信息编号>：若不加<信息编号>选项，则-l参数会列出全部的信息名称；
    -p：指定kill 命令只打印相关进程的进程号，而不发送任何信号；
    -s <信息名称或编号>：指定要送出的信息；
    -u：指定用户。
#+END_EXAMPLE

****** 参数\\

进程或作业识别号：指定要删除的进程或作业。

****** 实例\\

列出所有信号名称：

#+BEGIN_EXAMPLE
     kill -l
     1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
     5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
     9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
    13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT
    17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
    21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU
    25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH
    29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN
    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4
    39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
    43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12
    47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14
    51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10
    55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6
    59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
    63) SIGRTMAX-1  64) SIGRTMAX
#+END_EXAMPLE

只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略，*下面是常用的信号：*

#+BEGIN_EXAMPLE
    HUP     1    终端断线
    INT     2    中断（同 Ctrl + C）
    QUIT    3    退出（同 Ctrl + \）
    TERM   15    终止
    KILL    9    强制终止
    CONT   18    继续（与STOP相反， fg/bg命令）
    STOP   19    暂停（同 Ctrl + Z）
#+END_EXAMPLE

先用ps查找进程，然后用kill杀掉：

#+BEGIN_EXAMPLE
    ps -ef | grep vim
    root      3268  2884  0 16:21 pts/1    00:00:00 vim install.log
    root      3370  2822  0 16:21 pts/0    00:00:00 grep vim

    kill 3268
    kill 3268
    -bash: kill: (3268) - 没有那个进程
#+END_EXAMPLE

**** fg                                                               :fg:

***** fg命令

来自: http://man.linuxde.net/fg

*fg命令* 用于将后台作业（在后台运行的或者在后台挂起的作业）放到前台终
端运行。与[[http://man.linuxde.net/bg][bg]]命令一样，若后台任务中只有一个，则使用该命令时，可以省略任
务号。

在Linux系统中执行某些操作时候，有时需要将当前任务暂停调至后台，或有时须将后台暂停的任务重启开启并调至前台，这一序列的操作将会使用到
[[http://man.linuxde.net/jobs][jobs]]、bg、和 fg
三个命令以及两个快捷键来完成。

****** 语法\\

#+BEGIN_EXAMPLE
    fg(参数)
#+END_EXAMPLE

****** 参数\\

作业标识：指定要放到前台的作业标识号。

****** 实例\\

使用fg命令将任务号为1的任务从后台执行转换到前台执行，输入如下命令：

#+BEGIN_EXAMPLE
    fg 1          #将任务转换到前台执行
#+END_EXAMPLE

执行上面的命令后，命令行窗口将显示如下信息：

#+BEGIN_EXAMPLE
    find / -name password       #前台执行命令
#+END_EXAMPLE

**** bg                                                               :bg:

***** bg命令

来自: http://man.linuxde.net/bg

*bg命令* 用于将作业放到后台运行，使前台可以执行其他任务。该命令的运行
效果与在指令后面添加符号=&=的效果是相同的，都是将其放到系统后台执行。

在Linux系统中执行某些操作时候，有时需要将当前任务暂停调至后台，或有时须将后台暂停的任务重启开启并调至前台，这一序列的操作将会使用到
[[http://man.linuxde.net/jobs][jobs]]、bg、和
[[http://man.linuxde.net/fg][fg]] 三个命令以及两个快捷键来完成。

****** 语法\\

#+BEGIN_EXAMPLE
    bg(参数)
#+END_EXAMPLE

****** 参数\\

作业标识：指定需要放到后台的作业标识号。

****** 实例\\

使用bg命令将任务号为1的任务放到后台继续执行，输入如下命令：

#+BEGIN_EXAMPLE
    bg 1            #后台执行任务号为1的任务
#+END_EXAMPLE

如果系统中只有一个挂起的任务时，即使不为该命令设置参数"1"，也可以实现这个功能。

注意：实际上，使用bg命令与在指令后面添加符号"&"的效果是一样的。例如，使用=&=将=find / -name password=放到后台执行，输入如下命令：

#+BEGIN_EXAMPLE
    find / -name password &     #后台执行任务
#+END_EXAMPLE

*** 磁盘管理
**** du                                                               :du:
***** du: 查看磁盘文件大小

du命令适合用来 /查看文件大小/ 等,要比ls命令强大的多

linux *du* 命令也是查看使用空间的，但是与df命令不同的是linux du命令是
对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的.

1. 命令格式

   *du [选项][文件]*

2. 命令功能：

   *显示每个文件和目录的磁盘使用空间*

3. 命令参数：

   1) -a, -all

      显示目录中个别文件的大小

   2) -b, -bytes

      显示目录或文件大小时，以byte为单位

   3) -c, --total

      除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和

   4) -k, --kilobytes

      以kb(1024bytes)为单位输出。

   5) -m, --megabytes

      以mb为单位输出

   6) /-s/, --summarize

      仅显示总计，只列出最后加总的值。

   7) /-h/, --human-readable

      以k，m，g为单位，提高信息的可读性。

   8) -x, --one-file-xystem

      以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。

   9) -l <符号链接>, --dereference <符号链接>

      显示选项中所指定符号链接的源文件大小。

   10) -S, --separate-dirs

       显示个别目录的大小时，并不含其子目录的大小。

   11) -x<文件>, --exclude-from=<文件>

       在<文件>指定目录或文件。

   12) --exclude=<目录, 文件>

       略过指定的目录或文件。

   13) -d, --dereference-args

       显示指定符号链接的源文件大小。

   14) -h, --si

       与-h参数相同，但是k，m，g是以1000为换算单位。

   15) -l, --count-links

       重复计算硬件链接的文件。

4. 使用实例：

   1) 实例1：显示目录或者文件所占空间 命令：du

      说明：只显示当前目录下面的子目录的目录大小和当前目录的总的大小，

      #+BEGIN_SRC sh :results output
      du ~/Picture
      #+END_SRC

      #+RESULTS:
      #+begin_example
      312	/home/ben/Picture/Wallpapers
      1428	/home/ben/Picture/Weibo/折纸之收纳盒_6_files
      3812	/home/ben/Picture/Weibo
      4932	/home/ben/Picture/WALLE/others
      9828	/home/ben/Picture/WALLE/walle
      16460	/home/ben/Picture/WALLE/W&E
      31224	/home/ben/Picture/WALLE
      6848	/home/ben/Picture/Guita/入门
      8012	/home/ben/Picture/Guita
      5148	/home/ben/Picture/tagerill
      71812	/home/ben/Picture
      #+end_example


      最下面的为当前目录的总大小

   2) 实例2：显示指定文件所占空间

      #+BEGIN_SRC sh
      du ~/.xinitrc
      #+END_SRC

   3) 实例3：查看指定目录的所占空间

      #+BEGIN_SRC sh
      du -sc ~/.ros
      #+END_SRC

      #+RESULTS:
      | 6356 | /home/ben/.ros |
      | 6356 | 总用量         |


   4) 实例4：显示多个文件所占空间  命令：

      #+BEGIN_SRC sh
      du log30.tar.gz log31.tar.gz
      #+END_SRC

   5) 实例5：只显示总和的大小

      #+BEGIN_SRC sh
      du -s
      #+END_SRC

   6) 实例6：方便阅读的格式显示 *注：默认单位为字节*

      #+BEGIN_SRC sh
      du -h test*
      #+END_SRC

   7) 实例7：文件和目录都显示  命令： 输出：

   8) 实例8：显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总
      和
      #+BEGIN_SRC sh
      du -c log30.tar.gz log31.tar.gz
      #+END_SRC

      说明：加上-c选项后，du不仅显示两个目录各自占用磁盘空间的大小，还
      在最后一行统计它们的总和。

   9) 实例9：按照空间大小排序 命令：

      #+BEGIN_SRC sh
      du | sort -nr | more
      #+END_SRC

   10) 实例10：输出当前目录下各个子目录所使用的空间  命令：

       #+BEGIN_SRC sh
       du -h --max-depth=1
       #+END_SRC
***** du命令

来自: http://man.linuxde.net/du

*du命令* 也是查看使用空间的，但是与[[http://man.linuxde.net/df][df]]命令不同的是Linux
du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的。

****** 语法\\

#+BEGIN_EXAMPLE
    du [选项][文件]
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -a或-all 显示目录中个别文件的大小。
    -b或-bytes 显示目录或文件大小时，以byte为单位。
    -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。
    -k或--kilobytes 以KB(1024bytes)为单位输出。
    -m或--megabytes 以MB为单位输出。
    -s或--summarize 仅显示总计，只列出最后加总的值。
    -h或--human-readable 以K，M，G为单位，提高信息的可读性。
    -x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。
    -L<符号链接>或--dereference<符号链接> 显示选项中所指定符号链接的源文件大小。
    -S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。
    -X<文件>或--exclude-from=<文件> 在<文件>指定目录或文件。
    --exclude=<目录或文件> 略过指定的目录或文件。
    -D或--dereference-args 显示指定符号链接的源文件大小。
    -H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。
    -l或--count-links 重复计算硬件链接的文件。
#+END_EXAMPLE

****** 实例\\

显示目录或者文件所占空间：

#+BEGIN_EXAMPLE
    [root@localhost test]# du
    608 ./test6
    308 ./test4
    4 ./scf/lib
    4 ./scf/service/deploy/product
    4 ./scf/service/deploy/info
    12 ./scf/service/deploy
    16 ./scf/service
    4 ./scf/doc
    4 ./scf/bin
    32 ./scf
    8 ./test3
    1288 .
#+END_EXAMPLE

只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的1288为当前目录的总大小

显示指定文件所占空间：

#+BEGIN_EXAMPLE
    [root@localhost test]# du log2012.log
    300 log2012.log
#+END_EXAMPLE

查看指定目录的所占空间：

#+BEGIN_EXAMPLE
    [root@localhost test]# du scf
    4 scf/lib
    4 scf/service/deploy/product
    4 scf/service/deploy/info
    12 scf/service/deploy
    16 scf/service
    4 scf/doc
    4 scf/bin
    32 scf
#+END_EXAMPLE

显示多个文件所占空间：

#+BEGIN_EXAMPLE
    [root@localhost test]# du log30.tar.gz log31.tar.gz
    4 log30.tar.gz
    4 log31.tar.gz
#+END_EXAMPLE

只显示总和的大小:

#+BEGIN_EXAMPLE
    [root@localhost test]# du -s
    1288 .

    [root@localhost test]# du -s scf
    32 scf

    [root@localhost test]# cd ..
    [root@localhost soft]# du -s test
    1288 test
#+END_EXAMPLE

**** df                                                              :pdf:

***** df命令

来自: http://man.linuxde.net/df

*df命令* 用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以
利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。

****** 语法\\

#+BEGIN_EXAMPLE
    df(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -a或--all：包含全部的文件系统；
    --block-size=<区块大小>：以指定的区块大小来显示区块数目；
    -h或--human-readable：以可读性较高的方式来显示信息；
    -H或--si：与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes；
    -i或--inodes：显示inode的信息；
    -k或--kilobytes：指定区块大小为1024字节；
    -l或--local：仅显示本地端的文件系统；
    -m或--megabytes：指定区块大小为1048576字节；
    --no-sync：在取得磁盘使用信息前，不要执行sync指令，此为预设值；
    -P或--portability：使用POSIX的输出格式；
    --sync：在取得磁盘使用信息前，先执行sync指令；
    -t<文件系统类型>或--type=<文件系统类型>：仅显示指定文件系统类型的磁盘信息；
    -T或--print-type：显示文件系统的类型；
    -x<文件系统类型>或--exclude-type=<文件系统类型>：不要显示指定文件系统类型的磁盘信息；
    --help：显示帮助；
    --version：显示版本信息。
#+END_EXAMPLE

****** 参数\\

文件：指定文件系统上的文件。

****** 实例\\

查看系统磁盘设备，默认是KB为单位：

#+BEGIN_EXAMPLE
    [root@LinServ-1 ~]# df
    文件系统               1K-块        已用     可用 已用% 挂载点
    /dev/sda2            146294492  28244432 110498708  21% /
    /dev/sda1              1019208     62360    904240   7% /boot
    tmpfs                  1032204         0   1032204   0% /dev/shm
    /dev/sdb1            2884284108 218826068 2518944764   8% /data1
#+END_EXAMPLE

使用=-h=选项以KB以上的单位来显示，可读性高：

#+BEGIN_EXAMPLE
    [root@LinServ-1 ~]# df -h
    文件系统              容量  已用 可用 已用% 挂载点
    /dev/sda2             140G   27G  106G  21% /
    /dev/sda1             996M   61M  884M   7% /boot
    tmpfs                1009M     0 1009M   0% /dev/shm
    /dev/sdb1             2.7T  209G  2.4T   8% /data1
#+END_EXAMPLE

查看全部文件系统：

#+BEGIN_EXAMPLE
    [root@LinServ-1 ~]# df -a
    文件系统               1K-块        已用     可用 已用% 挂载点
    /dev/sda2            146294492  28244432 110498708  21% /
    proc                         0         0         0   -  /proc
    sysfs                        0         0         0   -  /sys
    devpts                       0         0         0   -  /dev/pts
    /dev/sda1              1019208     62360    904240   7% /boot
    tmpfs                  1032204         0   1032204   0% /dev/shm
    /dev/sdb1            2884284108 218826068 2518944764   8% /data1
    none                         0         0         0   -  /proc/sys/fs/binfmt_misc
#+END_EXAMPLE

**** fdisk                                                         :fdisk:

1. 需要特权: sudo
2. sudo fdisk -l
3. sudo fdisk =/dev/sdc=
4. 选项
   + d 删除分区
   + n 添加分区
   + w 写入并退出
   + q 放弃
   + p 查看分区

***** fdisk命令

来自: http://man.linuxde.net/fdisk

*fdisk命令* 用于观察硬盘实体使用情况，也可对硬盘分区。它采用传统的问答
式界面，而非类似DOS fdisk的cfdisk互动式操作界面，因此在使用上较为不便，
但功能却丝毫不打折扣。

****** 语法\\

#+BEGIN_EXAMPLE
    fdisk(选项)(参数)
#+END_EXAMPLE

****** 选项\\

#+BEGIN_EXAMPLE
    -b<分区大小>：指定每个分区的大小；
    -l：列出指定的外围设备的分区表状况；
    -s<分区编号>：将指定的分区大小输出到标准输出上，单位为区块；
    -u：搭配"-l"参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址；
    -v：显示版本信息。
#+END_EXAMPLE

****** 参数\\

设备文件：指定要进行分区或者显示分区的硬盘设备文件。

****** 实例\\

首先选择要进行操作的磁盘：

#+BEGIN_EXAMPLE
    [root@localhost ~]# fdisk /dev/sdb
#+END_EXAMPLE

输入=m=列出可以执行的命令：

#+BEGIN_EXAMPLE
    command (m for help): m
    Command action
       a   toggle a bootable flag
       b   edit bsd disklabel
       c   toggle the dos compatibility flag
       d   delete a partition
       l   list known partition types
       m   print this menu
       n   add a new partition
       o   create a new empty DOS partition table
       p   print the partition table
       q   quit without saving changes
       s   create a new empty Sun disklabel
       t   change a partition's system id
       u   change display/entry units
       v   verify the partition table
       w   write table to disk and exit
       x   extra functionality (experts only)
#+END_EXAMPLE

输入=p=列出磁盘目前的分区情况：

#+BEGIN_EXAMPLE
    Command (m for help): p

    Disk /dev/sdb: 3221 MB, 3221225472 bytes
    255 heads, 63 sectors/track, 391 cylinders
    Units = cylinders of 16065 * 512 = 8225280 bytes

       Device Boot      Start         End      Blocks   Id  System
    /dev/sdb1               1           1        8001   8e  Linux LVM
    /dev/sdb2               2          26      200812+  83  Linux
#+END_EXAMPLE

输入=d=然后选择分区，删除现有分区：

#+BEGIN_EXAMPLE
    Command (m for help): d
    Partition number (1-4): 1

    Command (m for help): d
    Selected partition 2
#+END_EXAMPLE

查看分区情况，确认分区已经删除：

#+BEGIN_EXAMPLE
    Command (m for help): print

    Disk /dev/sdb: 3221 MB, 3221225472 bytes
    255 heads, 63 sectors/track, 391 cylinders
    Units = cylinders of 16065 * 512 = 8225280 bytes

       Device Boot      Start         End      Blocks   Id  System

    Command (m for help):
#+END_EXAMPLE

输入=n=建立新的磁盘分区，首先建立两个主磁盘分区：

#+BEGIN_EXAMPLE
    Command (m for help): n
    Command action
       e   extended
       p   primary partition (1-4)
    p    //建立主分区
    Partition number (1-4): 1  //分区号
    First cylinder (1-391, default 1):  //分区起始位置
    Using default value 1
    last cylinder or +size or +sizeM or +sizeK (1-391, default 391): 100  //分区结束位置，单位为扇区

    Command (m for help): n  //再建立一个分区
    Command action
       e   extended
       p   primary partition (1-4)
    p
    Partition number (1-4): 2  //分区号为2
    First cylinder (101-391, default 101):
    Using default value 101
    Last cylinder or +size or +sizeM or +sizeK (101-391, default 391): +200M  //分区结束位置，单位为M
#+END_EXAMPLE

确认分区建立成功：

#+BEGIN_EXAMPLE
    Command (m for help): p

    Disk /dev/sdb: 3221 MB, 3221225472 bytes
    255 heads, 63 sectors/track, 391 cylinders
    Units = cylinders of 16065 * 512 = 8225280 bytes

       Device Boot      Start         End      Blocks   Id  System
    /dev/sdb1               1         100      803218+  83  Linux
    /dev/sdb2             101         125      200812+  83  Linux
#+END_EXAMPLE

再建立一个逻辑分区：

#+BEGIN_EXAMPLE
    Command (m for help): n
    Command action
       e   extended
       p   primary partition (1-4)
    e  //选择扩展分区
    Partition number (1-4): 3
    First cylinder (126-391, default 126):
    Using default value 126
    Last cylinder or +size or +sizeM or +sizeK (126-391, default 391):
    Using default value 391
#+END_EXAMPLE

确认扩展分区建立成功：

#+BEGIN_EXAMPLE
    Command (m for help): p

    Disk /dev/sdb: 3221 MB, 3221225472 bytes
    255 heads, 63 sectors/track, 391 cylinders
    Units = cylinders of 16065 * 512 = 8225280 bytes

       Device Boot      Start         End      Blocks   Id  System
    /dev/sdb1               1         100      803218+  83  Linux
    /dev/sdb2             101         125      200812+  83  Linux
    /dev/sdb3             126         391     2136645    5  Extended
#+END_EXAMPLE

在扩展分区上建立两个逻辑分区：

#+BEGIN_EXAMPLE
    Command (m for help): n
    Command action
       l   logical (5 or over)
       p   primary partition (1-4)
    l //选择逻辑分区
    First cylinder (126-391, default 126):
    Using default value 126
    Last cylinder or +size or +sizeM or +sizeK (126-391, default 391): +400M

    Command (m for help): n
    Command action
       l   logical (5 or over)
       p   primary partition (1-4)
    l
    First cylinder (176-391, default 176):
    Using default value 176
    Last cylinder or +size or +sizeM or +sizeK (176-391, default 391):
    Using default value 391
#+END_EXAMPLE

确认逻辑分区建立成功：

#+BEGIN_EXAMPLE
    Command (m for help): p

    Disk /dev/sdb: 3221 MB, 3221225472 bytes
    255 heads, 63 sectors/track, 391 cylinders
    Units = cylinders of 16065 * 512 = 8225280 bytes

       Device Boot      Start         End      Blocks   Id  System
    /dev/sdb1               1         100      803218+  83  Linux
    /dev/sdb2             101         125      200812+  83  Linux
    /dev/sdb3             126         391     2136645    5  Extended
    /dev/sdb5             126         175      401593+  83  Linux
    /dev/sdb6             176         391     1734988+  83  Linux

    Command (m for help):
#+END_EXAMPLE

从上面的结果我们可以看到，在硬盘sdb我们建立了2个主分区（sdb1，sdb2），1个扩展分区（sdb3），2个逻辑分区（sdb5，sdb6）

注意：主分区和扩展分区的磁盘号位1-4，也就是说最多有4个主分区或者扩展分区，逻辑分区开始的磁盘号为5，因此在这个实验中试没有sdb4的。

最后对分区操作进行保存：

#+BEGIN_EXAMPLE
    Command (m for help): w
    The partition table has been altered!

    Calling ioctl() to re-read partition table.
    Syncing disks.
#+END_EXAMPLE

建立好分区之后我们还需要对分区进行格式化才能在系统中使用磁盘。

在sdb1上建立ext2分区：

#+BEGIN_EXAMPLE
    [root@localhost ~]# mkfs.ext2 /dev/sdb1
    mke2fs 1.39 (29-May-2006)
    Filesystem label=
    OS type: Linux
    Block size=4096 (log=2)
    Fragment size=4096 (log=2)
    100576 inodes, 200804 blocks
    10040 blocks (5.00%) reserved for the super user
    First data block=0
    Maximum filesystem blocks=209715200
    7 block groups
    32768 blocks per group, 32768 fragments per group
    14368 inodes per group
    Superblock backups stored on blocks:
            32768, 98304, 163840

    Writing inode tables: done
    Writing superblocks and filesystem accounting information: done

    This filesystem will be automatically checked every 32 mounts or
    180 days, whichever comes first.  Use tune2fs -c or -i to override.
#+END_EXAMPLE

在sdb6上建立ext3分区：

#+BEGIN_EXAMPLE
    [root@localhost ~]# mkfs.ext3 /dev/sdb6
    mke2fs 1.39 (29-May-2006)
    Filesystem label=
    OS type: Linux
    Block size=4096 (log=2)
    Fragment size=4096 (log=2)
    217280 inodes, 433747 blocks
    21687 blocks (5.00%) reserved for the super user
    First data block=0
    Maximum filesystem blocks=444596224
    14 block groups
    32768 blocks per group, 32768 fragments per group
    15520 inodes per group
    Superblock backups stored on blocks:
            32768, 98304, 163840, 229376, 294912

    Writing inode tables: done
    Creating journal (8192 blocks): done
    Writing superblocks and filesystem accounting information: done

    This filesystem will be automatically checked every 32 mounts or
    180 days, whichever comes first.  Use tune2fs -c or -i to override.
    [root@localhost ~]#
#+END_EXAMPLE

建立两个目录=/oracle=和=/web=，将新建好的两个分区挂载到系统：

#+BEGIN_EXAMPLE
    [root@localhost ~]# mkdir /oracle
    [root@localhost ~]# mkdir /web
    [root@localhost ~]# mount /dev/sdb1 /oracle
    [root@localhost ~]# mount /dev/sdb6 /web
#+END_EXAMPLE

查看分区挂载情况：

#+BEGIN_EXAMPLE
    [root@localhost ~]# df -h
    文件系统              容量  已用 可用 已用% 挂载点
    /dev/mapper/VolGroup00-LogVol00
                          6.7G  2.8G  3.6G  44% /
    /dev/sda1              99M   12M   82M  13% /boot
    tmpfs                 125M     0  125M   0% /dev/shm
    /dev/sdb1             773M  808K  733M   1% /oracle
    /dev/sdb6             1.7G   35M  1.6G   3% /web
#+END_EXAMPLE

如果需要每次开机自动挂载则需要修改=/etc/fstab=文件，加入两行配置：

#+BEGIN_EXAMPLE
    [root@localhost ~]# vim /etc/fstab

    /dev/VolGroup00/LogVol00 /                       ext3    defaults        1 1
    LABEL=/boot             /boot                   ext3    defaults        1 2
    tmpfs                   /dev/shm                tmpfs   defaults        0 0
    devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
    sysfs                   /sys                    sysfs   defaults        0 0
    proc                    /proc                   proc    defaults        0 0
    /dev/VolGroup00/LogVol01 swap                    swap    defaults        0 0
    /dev/sdb1               /oracle                 ext2    defaults        0 0
    /dev/sdb6               /web                    ext3    defaults        0 0
#+END_EXAMPLE

** miscellaneous
*** [[http://www.blogbus.com/fbirdzp-logs/37423250.html][Linux用户命令行字符环境变量]]                              :blog:env:ps1:

   用户登录Linux系统的字符界面后，就会出现"#"或"$"等命令提示符，比如"[root@pxe
   root]# “、"[oracle@db1 ~]$”或是 “-bash-3.00#”等等。

   通过设置环境变量PS1、PS2、PS3以及PS4来自定义用户命令行的字符显示。如果要长期永久性修改提示符，可以将修改提示符的命令添加到$HOME/.profile或$HOME/.bash_profile文件中。

   *1. PS1*

   PS1是主提示符变量,也是默认提示符变量。默认值"\s-\v\$“，显示shell类型和版本。
   基本上通过设置PS1来定义命令行提示字符即可，最常用的需求就是显示登录的用户名、主目录、主机名等等，举个例子如下：

   --------------

   显示用户名，主机名和动态显示当前目录
   -bash-3.00# export PS1="[\u@\h \w]"
   [root@MagicLinux ~]cd /etc
   [root@MagicLinux /etc]

   注意：如果当前目录是用户的HOME目录，则显示＂~＂

   --------------

   PS1变量可以使用的参数值有如下：

   | \d | 代表日期，格式为weekday month date，例如："Mon Aug 1"                    |
   | \H | 完整的主机名称。例如：我的机器名称为：fc4.linux，则这个名称就是fc4.linux |
   | \h | 仅取主机的第一个名字，如上例，则为fc4，.linux则被省略                    |
   | \t | 显示时间为24小时格式，如：HH：MM：SS                                     |
   | \T | 显示时间为12小时格式                                                     |
   | \A | 显示时间为24小时格式：HH：MM                                             |
   | \u | 当前用户的账号名称                                                       |
   | \v | BASH的版本信息                                                           |
   | \w | 完整的工作目录名称。家目录会以 ~代替                                     |
   | \W | 利用basename取得工作目录名称，所以只会列出最后一个目录                   |
   | \# | 下达的第几个命令                                                         |
   | \$ | 提示字符，如果是root时，提示符为：# ，普通用户则为：$                    |
   | \[ | 字符"["                                                                  |
   | \] | 字符"]"                                                                  |
   | \! | 命令行动态统计历史命令次数                                               |

   *2. PS2*

   PS2是副提示符变量，默认值是''> ''。
   PS2一般使用于命令行里较长命令的换行提示信息，比如：

   --------------

   默认设置
   -bash-3.00# rpm -q gcc make binutils openmotif setarch compat-db
   compat-gcc \
   > compat-gcc-c++ compat-libstdc++ compat-libstdc++-devel

   自定义设置
   -bash-3.00# export PS2="PS2 => "
   -bash-3.00# rpm -q gcc make binutils openmotif setarch compat-db
   compat-gcc \
   PS2 => compat-gcc-c++ compat-libstdc++ compat-libstdc++-devel

   --------------

   *3. PS3，PS4*

   这两个环境变量可能用得不多，不研究了。如果有兴趣，可以学习bash里面的简介。

   PS3  The value of this parameter is used as the prompt for the
   select command (see SHELL GRAMMAR above).
   PS4  The value of this parameter is expanded as with PS1 and the
   value is printed before  each  command  bash displays  during an
   execution trace.  The first character of PS4 is replicated multiple
   times, as neces-sary, to indicate multiple levels of indirection.
   The default is ''+ ''.

*** ps1                                                               :ps1:

#+BEGIN_EXAMPLE
export PS1="\u@ \W $ "
#+END_EXAMPLE

**** ps1 shell 提示符

PS1：就是用户平时的提示符。
PS2：第一行没输完，等待第二行输入的提示符。

Linux系统提示符是用系统变量PS1来定义的。一般系统默认的形式是：

#+BEGIN_EXAMPLE
[username@host 工作目录]$
#+END_EXAMPLE

**** 特殊符号

- \d ：代表日期，格式为weekday month date，例如："Mon Aug 1"

- \H ：完整的主机名称。例如：我的机器名称为：fc4.linux，则这个名称就是fc4.linux

- \h ：仅取主机的第一个名字，如上例，则为fc4，.linux则被省略

- \t ：显示时间为24小时格式，如：HH：MM：SS

- \T ：显示时间为12小时格式

- \A ：显示时间为24小时格式：HH：MM

- \u ：当前用户的账号名称

- \v ：BASH的版本信息

- \w ：完整的工作目录名称。家目录会以 ~代替

- \W ：利用basename取得工作目录名称，所以只会列出最后一个目录

- \# ：下达的第几个命令

- \$ ：提示字符，如果是root时，提示符为：# ，普通用户则为：$

**** 颜色

我们可以通过设置PS1变量使提示符成为彩色。在PS1中设置字符序列颜色的格式
为：

#+BEGIN_EXAMPLE
\[\e[F;Bm\]
#+END_EXAMPLE

其中``F''为字体颜色，编号30~37；``B''为背景色，编号40~47。

可通过``\e[0m''关闭颜色输出；特别的，当B为1时，将显示加亮加粗的文字，
详细请看下面的颜色表与代码表。

颜色表

|------+------+--------|
| 前景 | 背景 | 颜色   |
|------+------+--------|
|   30 |   40 | 黑色   |
|   31 |   41 | 紅色   |
|   32 |   42 | 綠色   |
|   33 |   43 | 黃色   |
|   34 |   44 | 藍色   |
|   35 |   45 | 紫紅色 |
|   36 |   46 | 青藍色 |
|   37 |   47 | 白色   |
|------+------+--------|


#+BEGIN_EXAMPLE
PS1="\[\e[32m\][\u@\h \w]$\[\e[m\]"
export PS1
#+END_EXAMPLE

**** reference

+ http://www.cnblogs.com/starspace/archive/2009/02/21/1395382.html

*** bash completion                                            :completion:

#+BEGIN_EXAMPLE
For auto-completion, do not forget to install 'ct-ng.comp' into
your bash completion directory (usually /etc/bash_completion.d)
#+END_EXAMPLE

*/etc/bash_completion.d*

*** [[http://coolshell.cn/articles/7829.html][28个Unix/Linux的命令行神器]]                                       :blog:

下面是 [[http://kkovacs.eu/][Kristóf Kovács]] 收集的28个Unix/Linux下的28个命令行下的工具（[[http://kkovacs.eu/cool-but-obscure-unix-tools][原
文链接]]） ，有一些是大家熟悉的，有一些是非常有用的，有一些是不为人知的。
这些工具都非常不错，希望每个人都知道。
本篇文章还在[[http://news.ycombinator.com/item?id=2567186][Hacker News 上被讨论]]，你可以过去看看。我以作者的原文中加入
了官网链接和一些说明。

**** dstat & sar

iostat, vmstat, ifstat
三合一的工具，用来查看系统性能（我在《[[http://coolshell.cn/articles/7490.html][性能调优攻略]]》中提到过那三个xxstat工具）。

官方网站：[[http://dag.wieers.com/rpm/packages/dstat/]]

你可以这样使用：

#+BEGIN_EXAMPLE
    alias dstat='dstat -cdlmnpsy'
#+END_EXAMPLE

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/dstat_screenshot.png @ 2016-01-25 19:02:39
 [[~/Wally/Journal/Figure/.org-download/Journal/dstat_screenshot_2016-01-25_19:02:39.png]]

**** slurm

查看网络流量的一个工具

官方网站： [[https://computing.llnl.gov/linux/slurm/][Simple LinuxUtility for Resource Management]]

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/slurm_screenshot.png @ 2016-01-25 19:04:12
 [[~/Wally/Journal/Figure/.org-download/Journal/slurm_screenshot_2016-01-25_19:04:12.png]]

**** vim & emacs

真正程序员的代码编辑器。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/vim_screenshot.png @ 2016-01-25 19:04:19
 [[~/Wally/Journal/Figure/.org-download/Journal/vim_screenshot_2016-01-25_19:04:19.png]]

**** screen, dtach, tmux, byobu

你是不是经常需要 SSH 或者 telent 远程登录到 Linux
服务器？你是不是经常为一些长时间运行的任务而头疼，比如系统备份、ftp
传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为他们执行的时间太长了。必须等待它执行完毕，在此期间可不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。

[[http://www.gnu.org/software/screen/][*Screen*]] 是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。
Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在
每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。请参看
IBMDeveloperWorks的这篇文章《[[http://www.ibm.com/developerworks/cn/linux/l-cn-screen/][使用screen 管理你的远程会话]]》

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/gnu_screen_screenshot.png @ 2016-01-25 19:04:38
 [[~/Wally/Journal/Figure/.org-download/Journal/gnu_screen_screenshot_2016-01-25_19:04:38.png]]

[[http://dtach.sourceforge.net/][*dtach*]] 是用来模拟screen的detach的功能的小工具，其可以让你随意地attach
到各种会话上

下图为dtach+dvtm的样子。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/dtach+dvtm.png @ 2016-01-25 19:04:51
 [[~/Wally/Journal/Figure/.org-download/Journal/dtach+dvtm_2016-01-25_19:04:51.png]]

*[[http://tmux.sourceforge.net/][tmux]]* 是一个优秀的终端复用软件，类似[[http://www.gnu.org/software/screen/][ GNU Screen]]，但来自于OpenBSD，采
用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux
后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主
机；当然其功能远不止于此。与screen相比的优点：可以横向和纵向分割窗口，
且窗格可以自由移动和调整大小。可在多个缓冲区进行复制和粘贴，支持跨窗口
搜索；非正常断线后不需重新detach；......

有人说------*与tmux相比，screen简直弱爆了*。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/tmux3.png @ 2016-01-25 19:05:14
 [[~/Wally/Journal/Figure/.org-download/Journal/tmux3_2016-01-25_19:05:14.png]]

[[https://launchpad.net/byobu/][*byobu* ]]是Ubuntu开发的，在Screen的基础上进行包装，使其更加易用的一个工
具。最新的Byobu，已经是基于Tmux作为后端了。可通过“byobu-tmux”这个命
令行前端来接受各种与tmux一模一样的参数来控制它。Byobu的细节做的非常好，
效果图如下：

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/byobu-tmux.jpg @ 2016-01-25 19:05:31
 [[~/Wally/Journal/Figure/.org-download/Journal/byobu-tmux_2016-01-25_19:05:31.jpg]]


**** multitail

MultiTail是个用来实现同时监控多个文档、类似tail命令的功能的软件。他和
tail的区别就是他会在控制台中打开多个窗口，这样使同时监控多个日志文档成
为可能。他还可以看log文件的统计，合并log文件，过滤log文件，分屏，......。


官网：[[http://www.vanheusden.com/multitail/]]

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/multitail_screenshot.png @ 2016-01-25 19:05:43
 [[~/Wally/Journal/Figure/.org-download/Journal/multitail_screenshot_2016-01-25_19:05:43.png]]
**** tpp

终端下的PPT，要是在某某大会上用这个演示PPT，就太TMD的Geek了。

官网：[[http://www.ngolde.de/tpp.html]]

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/tpp_screenshot.png @ 2016-01-25 19:06:04
 [[~/Wally/Journal/Figure/.org-download/Journal/tpp_screenshot_2016-01-25_19:06:04.png]]

**** xargs & parallel

Executes tasks from input (even multithread).

xargs
是一个比较古老的命令，有简单的并行功能，这个不说了。对 于[[http://www.gnu.org/software/parallel/][GNU parallel]] ( [[http://savannah.gnu.org/projects/parallel][online
manpage]] )来说，它不仅能够处理本机上多执行绪，还能分散至远端电脑协助处理。而使用GNU
parallel前，要先确定本机有安装GNU parallel / ssh /
rsync，远端电脑也要安装ssh。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/xargs_screenshot.png @ 2016-01-25 19:06:24
 [[~/Wally/Journal/Figure/.org-download/Journal/xargs_screenshot_2016-01-25_19:06:24.png]]
**** duplicity & rsyncrypto

[[http://duplicity.nongnu.org/][Duplicity ]]是使用rsync算法加密的高效率备份软件，Duplicity支持目录加密生产和格式上传到远程或本地文件服务器。

[[http://rsyncrypto.lingnu.com/index.php/Home_Page][rsyncrypto]] 就是rsync + encryption。对于rsync的算法可参看酷壳的 [[http://coolshell.cn/articles/7425.html][rsync核心算法]]。

Encrypting backup tools.

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/duplicity_screenshot.png @ 2016-01-25 19:06:50
 [[~/Wally/Journal/Figure/.org-download/Journal/duplicity_screenshot_2016-01-25_19:06:50.png]]
**** nethack & slash'em

[[http://www.nethack.org/][NetHack]]（[[http://zh.wikipedia.org/zh/NetHack][Wiki]]） ，20年历史的古老电脑游戏。没有声音，没有漂亮的界面，不
过这个游戏真的很有意思。网上有个家伙说：*如果你一生只做一件事情，那么
玩NetHack*。这句话很惹眼，但也让人觉得这个游戏很复杂不容易上手。其实，
这个游戏很虽然很复杂，却容易上手。虽然玩通关很难，但上手很容易。
NetHack上有许多复杂的规则，”the DevTeam thinks of everything”（开发
团队想到了所有的事情)。各种各样的怪物，各种各样的武器....，有许多
spoilers文件来说明其规则。除了每次开始随机生成的地图，每次玩游戏，你也
都会碰到奇怪的事情:

因为喝了一种药水，变成了机器人;因为踢坏了商店的门被要求高价赔偿;你的狗为你偷来了商店的东西.....
这有点象人生，你不能完全了解这个世界，但你仍然可以选择自己的面对方式。

网上有许多文章所这是最好的电脑游戏或最好的电脑游戏之一。也许是因为它开
放的源代码让人赞赏，古老的历史让人宽容，复杂的规则让人敬畏。虽然它不是
当前流行的游戏，但它比任何一个当前流行的游戏都更有可能再经受20年的考验。

[[http://www.slashem.org][Slash'EM]] 也是一个基于NetHack的经典游戏。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/nethack_screenshot.png @ 2016-01-25 19:07:55
 [[~/Wally/Journal/Figure/.org-download/Journal/nethack_screenshot_2016-01-25_19:07:55.png]]

**** lftp

利用[[http://lftp.yar.ru/][lftp ]]命令行ftp工具进行网站数据的增量备份，镜像，就像使用rsync一样。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/lftp_screenshot.png @ 2016-01-25 19:08:06
 [[~/Wally/Journal/Figure/.org-download/Journal/lftp_screenshot_2016-01-25_19:08:06.png]]

**** ack

[[http://betterthangrep.com/][ack]] 是一个perl脚本，是grep的一个可选替换品。其可以对匹配字符有高亮显示。
是为程序员专门设计的，默认递归搜索，省提供多种文件类型供选。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/ack_screenshot.png @ 2016-01-25 19:08:16
 [[~/Wally/Journal/Figure/.org-download/Journal/ack_screenshot_2016-01-25_19:08:16.png]]
**** calcurse & remind + wyrd

[[http://calcurse.org/][calcurse ]]是一个命令行下的日历和日程软件。[[http://www.roaringpenguin.com/products/remind][remind]] [[http://pessimization.com/software/wyrd/][wyrd ]]也很类似。关于日
历，我不得不提一个[[http://coolshell.cn/articles/3489.html][ Linux的Cycle日历]]，也是一个神器，呵呵。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/calcurse_screenshot.png @ 2016-01-25 19:09:11
 [[~/Wally/Journal/Figure/.org-download/Journal/calcurse_screenshot_2016-01-25_19:09:11.png]]
**** newsbeuter & rsstail

[[http://newsbeuter.org/][newsbeuter ]]和 [[http://www.vanheusden.com/rsstail/][rsstail]] 是命令行下RSS的阅读工具。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/newsbeuter_screenshot.png @ 2016-01-25 19:09:24
 [[~/Wally/Journal/Figure/.org-download/Journal/newsbeuter_screenshot_2016-01-25_19:09:24.png]]
**** powertop

[[http://coolshell.cn/articles/7186.html][做个环保的程序员]]，看看自己的电脑里哪些程序费电。 [[https://01.org/powertop/][PowerTOP]] 是一个让
Intel 平台的笔记本电脑节省电源的 Linux 工具。此工具由 Intel
公司发布。它可以帮助用户找出那些耗电量大的程序，通过修复或者关闭那些应用程序或进程，从而为用户节省电源。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/powertop_screenshot.png @ 2016-01-25 19:09:40
 [[~/Wally/Journal/Figure/.org-download/Journal/powertop_screenshot_2016-01-25_19:09:40.png]]
**** htop & iotop

[[http://htop.sourceforge.net/][htop]] 和 [[http://guichaz.free.fr/iotop/][iotop]]  用来查看进程，内存和IO负载。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/htop_screenshot.png @ 2016-01-25 19:09:49
 [[~/Wally/Journal/Figure/.org-download/Journal/htop_screenshot_2016-01-25_19:09:49.png]]
**** ttyrec & ipbt

[[http://0xcc.net/ttyrec/index.html.en][ttyrec]] 是一个 tty 控制台录制程序，其所录制的数据文件可以使用与之配套的
ttyplay 播放。不管是你在 tty 中的各种操作，还是在 tty 中耳熟能详的软件，
都可进行录制。


[[http://www.chiark.greenend.org.uk/~sgtatham/ipbt/][ipbt]] 是一个用来回放 ttyrec 所录制的控制台输入过程的工具。

与此类似的还有[[http://shelr.tv/][ Shelr]] 和 [[http://sourceforge.net/projects/termrec/][termrec ]]

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/ipbt_screenshot.png @ 2016-01-25 19:10:10
 [[~/Wally/Journal/Figure/.org-download/Journal/ipbt_screenshot_2016-01-25_19:10:10.png]]

**** rsync

通过SSH进行文件同步的经典工具（[[http://coolshell.cn/articles/7425.html][核心算法]]）

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/rsync_screenshot.png @ 2016-01-25 19:10:16
 [[~/Wally/Journal/Figure/.org-download/Journal/rsync_screenshot_2016-01-25_19:10:16.png]]
**** mtr

[[http://www.bitwizard.nl/mtr/][MTR]] -- traceroute 2.0，其是把
traceroute 和 ping 集成在一块的一个小工具 用于诊断网络。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/mtr_screenshot.png @ 2016-01-25 19:10:25
 [[~/Wally/Journal/Figure/.org-download/Journal/mtr_screenshot_2016-01-25_19:10:25.png]]
**** socat & netpipes

[[http://www.dest-unreach.org/socat/][soca t]]是一个多功能的网络工具，名字来由是”Socket CAT”，可以看作是
netcat的N倍加强版。

[[http://web.purplefrog.com/~thoth/netpipes/][netpipes]] 和socat一样，主要是用来在命令行来进行socket操作的命令，这样你
就可以在Shell脚本下行进socket网络通讯了。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/socat_screenshot.png @ 2016-01-25 19:10:36
 [[~/Wally/Journal/Figure/.org-download/Journal/socat_screenshot_2016-01-25_19:10:36.png]]
**** iftop & iptraf

[[http://www.ex-parrot.com/~pdw/iftop/][iftop ]]和 [[http://iptraf.seul.org/][iptraf ]]可以用来查看当前网络链接的一些流量情况。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/iftop_screenshot.png @ 2016-01-25 19:10:49
 [[~/Wally/Journal/Figure/.org-download/Journal/iftop_screenshot_2016-01-25_19:10:49.png]]

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/iptraf-tcpudp.gif @ 2016-01-25 19:10:53
 [[~/Wally/Journal/Figure/.org-download/Journal/iptraf-tcpudp_2016-01-25_19:10:53.gif]]

**** siege & tsung

[[http://www.joedog.org/siege-home/][Siege]] 是一个压力测试和评测工具，设计用于WEB开发这评估应用在压力下的承
受能力：可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所
有请求过程的相应时间，并在一定数量的并发访问下重复进行。

[[http://tsung.erlang-projects.org/][Tsung]] 是一个压力测试工具，可以测试包括HTTP, WebDAV, PostgreSQL, MySQL, LDAP,
and XMPP/Jabber等服务器。针对 HTTP 测试，Tsung 支持 HTTP 1.0/1.1
，包含一个代理模式的会话记录、支持 GET、POST 和 PUT 以及 DELETE
方法，支持 Cookie 和基本的 WWW 认证，同时还支持 SSL。

参看：[[http://coolshell.cn/articles/2589.html][十个免费的Web压力测试工具]]

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/siege_screenshot.png @ 2016-01-25 19:11:10
 [[~/Wally/Journal/Figure/.org-download/Journal/siege_screenshot_2016-01-25_19:11:10.png]]

**** ledger

[[http://ledger-cli.org/][ledger]] 一个命令行下记帐的小工具。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/ledger_screenshot.png @ 2016-01-25 19:11:18
 [[~/Wally/Journal/Figure/.org-download/Journal/ledger_screenshot_2016-01-25_19:11:18.png]]
**** taskwarrior

[[http://taskwarrior.org/projects/show/taskwarrior][TaskWarrior]] 是一个基于命令行的

列表管理工具。主要功能包括：标签、彩色表格输出、报表和图形、大量的命令、底层API、多用户文件锁等功能。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/taskwarrior_screenshot.png @ 2016-01-25 19:11:32
 [[~/Wally/Journal/Figure/.org-download/Journal/taskwarrior_screenshot_2016-01-25_19:11:32.png]]
下图是TaskWarrior 2.0的界面：

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/TaskWarrior2.0.png @ 2016-01-25 19:11:36
 [[~/Wally/Journal/Figure/.org-download/Journal/TaskWarrior2.0_2016-01-25_19:11:36.png]]

**** curl

[[http://curl.haxx.se/][cURL]] 是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它
支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。
cURL还包含了用于程序开发的libcurl。cURL支援的通訊協定有FTP、FTPS、HTTP、
HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、
POP3、SMTP和RTSP。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/curl_screenshot.png @ 2016-01-25 19:11:49
 [[~/Wally/Journal/Figure/.org-download/Journal/curl_screenshot_2016-01-25_19:11:49.png]]
**** rtorrent & aria2

[[http://libtorrent.rakshasa.no/][rTorrent]]
是一个非常简洁、优秀、非常轻量的BT客户端. 它使用了 ncurses 库以 C++
编写, 因此它完全基于文本并在终端中运行. 将 rTorrent 用在安装有 GNU
Screen 和 Secure Shell 的低端系统上作为远程的 BT 客户端是非常理想的。

[[http://aria2.sourceforge.net/][aria2]] 是 Linux
下一个不错的高速下载工具。由于它具有分段下载引擎，所以支持从多个地址或者从一个地址的多个连接来下载同一个文件。这样自然就大大加快了文件的下载速度。aria2
也具有断点续传功能，这使你随时能够恢复已经中断的文件下载。除了支持一般的
http(s) 和 ftp 协议外，aria2 还支持 BitTorrent
协议。这意味着，你也可以使用 aria2 来下载 torrent 文件。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/rtorrent_screenshot.png @ 2016-01-25 19:12:11
 [[~/Wally/Journal/Figure/.org-download/Journal/rtorrent_screenshot_2016-01-25_19:12:11.png]]
**** ttytter & earthquake

[[http://www.floodgap.com/software/ttytter][TTYtter]] 是一个Perl写的命令行上发Twitter的工具，可以进行所有其他平台客
户端能进行的事情，当然，支持中文。脚本控、CLI控、终端控、Perl控的最愛。

[[https://github.com/jugyo/earthquake][Earthquake ]]也是一个命令行上的Twitter客户端。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/ttytter_screenshot.png @ 2016-01-25 19:12:38
 [[~/Wally/Journal/Figure/.org-download/Journal/ttytter_screenshot_2016-01-25_19:12:38.png]]

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/earthquake.jpg @ 2016-01-25 19:12:41
 [[~/Wally/Journal/Figure/.org-download/Journal/earthquake_2016-01-25_19:12:41.jpg]]

**** vifm & ranger

[[http://vifm.sourceforge.net/][Vifm]] 基于ncurses的文件管理器，DOS风格，用键盘操作。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/vifm_screenshot.png @ 2016-01-25 19:12:48
 [[~/Wally/Journal/Figure/.org-download/Journal/vifm_screenshot_2016-01-25_19:12:48.png]]

[[http://savannah.nongnu.org/projects/ranger][Ranger]] 用 Python
完成，默认为使用 Vim 风格的按键绑定，比如
hjkl（上下左右），dd（剪切），yy（复制）等等。功能很全，扩展/可配置性也非常不错。类似MacOS
X下Finder（文件管理器）的多列文件管理方式。支持多标签页。实时预览文本文件和目录。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/ranger.png @ 2016-01-25 19:13:03
 [[~/Wally/Journal/Figure/.org-download/Journal/ranger_2016-01-25_19:13:03.png]]

**** cowsay & sl

[[http://www.nog.net/~tony/warez/cowsay.shtml][cowsay ]] 不说了，如下所示，哈哈哈。还有xcowsay，你可以自己搜一搜。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/cowsay_screenshot.png @ 2016-01-25 19:13:10
 [[~/Wally/Journal/Figure/.org-download/Journal/cowsay_screenshot_2016-01-25_19:13:10.png]]

sl是什么？ls？，呵呵，你会经常把ls
打成sl吗？如果是的话，这个东西可以让你娱乐一下，你会看到一辆火车呼啸而过~~，相当拉风。你可以使用sudo
apt-get install sl 安装。

#+DOWNLOADED: http://coolshell.cn//wp-content/uploads/2012/07/sl.jpg @ 2016-01-25 19:13:32
 [[~/Wally/Journal/Figure/.org-download/Journal/sl_2016-01-25_19:13:32.jpg]]

最后，再介绍一个命令中linuxlogo，你可以使用 sudo apt-get install
linuxlogo来安装，然后，就可以使用linuxlogo -L
来看一下各种Linux的logo了

*** 复制粘贴技巧（虚拟终端）

记得复制和粘贴技巧！

如果你正在使用鼠标，双击文件名(ls命令列出来的)，来复制它，然后按下鼠标
中键，粘贴文件名到命令行中。

**** 小结
*终端中双击复制中键粘贴*

*** shell cd !$
!$是列出并执行你的命令历史里面最近的一条记录，前面加上cd，除非最近的命
令跟目录相关，否则执行不了。

**** 小结
SHELL特殊符号不用刻意去记。

cd !$ 对我并没有太多用处。

*** !$
!$是列出并执行你的命令历史里面最近的一条记录，前面加上cd，除非最近的命
令跟目录相关，否则执行不了。

*** [[http://blog.csdn.net/adaptiver/article/details/7240364][Bash shell中的位置参数$#,$*,$@,$0,$1,$2...及特殊参数$?,$-等的含义]] :blog:symbol:

$# 是传给脚本的参数个数

$@ 是传给脚本的所有参数的列表

$0 是脚本本身的名字

$1是传递给该shell脚本的第一个参数

$2是传递给该shell脚本的第二个参数

在Bash shell中经常会见到一些比较特殊的符号，本人现收集与此，以供查阅：

位置参数：
详见ABS(Advanced Bash
Shell)中文翻译版103页第9章第一节内部变量，当然英文版ABS都一样啦

$0, $1, $2,等等...
位置参数,从命令行传递给脚本,或者是传递给函数.或者赋职给一个变量.
(具体见Example 4-5 和Example 11-15)
$0表示当前执行的进程名,script
本身的名字,或者在正则表达式中表示整行输出

$#
命令行或者是位置参数的个数.(见Example 33-2)
$*
所有的位置参数,被作为一个单词.
注意:"$*"必须被""引用.
$@

与$*同义,但是每个参数都是一个独立的""引用字串,这就意味着参数被完整地传递,

并没有被解释和扩展.这也意味着,每个参数列表中的每个参数都被当成一个独立的单词.
注意:"$@"必须被""引用.



其他的特殊参数
$-
传递给脚本的falg(使用set 命令).参考Example 11-15.
注意:这起初是ksh 的特征,后来被引进到Bash 中,但不幸的是,在Bash
中它看上去也不

能可靠的工作.使用它的一个可能的方法就是让这个脚本进行自我测试(查看是否是交
互的).
$!
在后台运行的最后的工作的PID(进程ID).
$_
保存之前执行的命令的最后一个参数.
$?
命令,函数或者脚本本身的退出状态(见Example 23-7)

用于检查上一个命令,函数或者脚本执行是否正确。（在Linux中，命令退出状态为0表示该命令正确执行，任何非0值表示命令出错。）
$$
脚本自身的进程ID.这个变量经常用来构造一个"unique"的临时文件名.
(参考Example A-13,Example 29-6,Example 12-28 和Example 11-25).
这通常比调用mktemp 来得简单.
注意事项:
[1] 当前运行的脚本的PID 为$$.
[2] "argument"和"parameter"这两个单词经常不加区分的使用.在这整本书中,这两个
单词的意思完全相同.(在翻译的时候就未加区分,统统翻译成参数)

退出和返回
退出状态(exit status)
函数返回一个被称为退出状态的值. 退出状态可以由return 来指定statement,
否则函数的
退出状态是函数最后一个执行命令的退出状态(0 表示成功,非0 表示出错代码).
退出状态
(exit status)可以在脚本中由$? 引用. 这个机制使脚本函数也可以像C
函数一样有一个"
返回值".
return
终止一个函数.return
命令[1]可选地带一个整数参数,这个整数作为函数的"返回值"返回
给调用此函数的脚本,并且这个值也被赋给变量$?.

while true可以写为while :

*** [[http://www.cnblogs.com/linuxer/p/3260328.html][shell Builtin variables（shell内建变量）]]                 :variable:env:

内容来自：abs-guide

*$BASH*

The path to theBashbinary itself

bash$echo $BASH

binbash

*$BASH_ENV*

An environmental variable pointing to a Bash startup file to be read
when a script is invoked

*$BASH_SUBSHELL*

A variable indicating the subshell level. This is a new addition to
Bash, version 3.

See Example 21-1 for usage.

*$BASHPID*

Process IDof the current

*$BASH_VERSINFO[n]*

A 6-element array containing version information about the installed
release of Bash. This is similar

to $BASH_VERSION, below, but a bit more detailed.

#+BEGIN_EXAMPLE
for n in 0 1 2 3 4 5
do
echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
done
# BASH_VERSINFO[0] = 3 # Major version no.
# BASH_VERSINFO[1] = 00 # Minor version no.
# BASH_VERSINFO[2] = 14 # Patch level.
# BASH_VERSINFO[3] = 1 # Build version.
# BASH_VERSINFO[4] = release # Release status.
# BASH_VERSINFO[5] = i386-redhat-linux-gnu # Architecture
#+END_EXAMPLE


*$BASH_VERSION*

The version of Bash installed on the system


*$CDPATH*

A colon-separated list of search paths available to the cd command,
similar in function to the $PATH

variable for binaries. The $CDPATH variable may be set in the local
~.bashrc file.

*$DIRSTACK*

The top value in the directory stack [41] (affected by pushd and popd)

This builtin variable corresponds to the dirs command,
however*dirs*shows the entire contents of the

directory stack.

*$EDITOR*

The default editor invoked by a script, usually *vi* or *emacs*.

*$EUID*

"effective" user ID number

Identification number of whatever identity the current user has
assumed, perhaps by means of su.

The $EUID is not necessarily the same as the $UID.

*$FUNCNAME*

Name of the current function

#+BEGIN_EXAMPLE
xyz23 ()
{
echo "$FUNCNAME now executing." # xyz23 now executing.
}
xyz23
echo "FUNCNAME = $FUNCNAME" # FUNCNAME =
# Null value outside a function.
#+END_EXAMPLE

*$GLOBIGNORE*

A list of filename patterns to be excluded from matching in globbing.

*$GROUPS*

Groups current user belongs to

This is a listing (array) of the group id numbers for current user, as
recorded in etcpasswd and

etcgroup.

#+BEGIN_EXAMPLE
  root#*echo $GROUPS*
  0
  root#*echo ${GROUPS[1]}*
  1
  root#*echo ${GROUPS[5]}*
  6
#+END_EXAMPLE

*$HOME*

Home directory of the user, usually homeusername (see Example 10-7)

*$HOSTNAME*

The hostname command assigns the system host name at bootup in an init
script. However, the

gethostname() function sets the Bash internal variable $HOSTNAME. See
also Example 10-7.

*$HOSTTYPE*

host type

Like $MACHTYPE, identifies the system hardware.

*$IFS*

internal field separator

This variable determines how Bash recognizes fields, or word
boundaries, when it interprets character

strings.

$IFS defaults to whitespace (space, tab, and newline), but may be
changed, for example, to parse a

comma-separated data file. Note that $* uses the first character held
in $IFS.




#+BEGIN_EXAMPLE
  bash$*echo "$IFS"*
  (With $IFS set to default, a blank line displays.)
  bash$*echo "$IFS" | cat -vte*
  \^I$
  $
  (Show whitespace: here a single space, \^I [horizontal tab],
  and newline, and display "$" at end-of-line.)
  bash$*bash -c 'set w x y z; IFS=":-;"; echo "$*"'*
  w:x:y:z
  (Read commands from string and assign any arguments to pos params.)
#+END_EXAMPLE

*$IGNOREEOF*

Ignore EOF: how many end-of-files (control-D) the shell will ignore
before logging out.

*$LC_COLLATE*

Often set in the.bashrcoretcprofilefiles, this variable controls
collation order in filename

expansion and pattern matching. If mishandled,LC_COLLATEcan cause
unexpected results in

filename globbing.

As of version 2.05 of Bash, filename globbing no longer distinguishes
between

lowercase and uppercase letters in a character range between brackets.
For example,*ls*

*[A-M]**would match bothFile1.txtandfile1.txt. To revert to the
customary

behavior of bracket matching, setLC_COLLATEtoCby
an*exportLC_COLLATE=C*inetcprofileandor~.bashrc.

*$LC_CTYPE*

This internal variable controls character interpretation in globbing
and pattern matching.

*$LINENO*

This variable is the line number of the shell script in which this
variable appears. It has significance

only within the script in which it appears, and is chiefly useful for
debugging purposes.


*$MACHTYPE*

machine type

Identifies the system hardware.

*$OLDPWD*

Old working directory ("OLD-Print-Working-Directory", previous
directory you were in).

*$OSTYPE*

operating system type

*$PATH*

Path to binaries, usually usrbin, usrX11R6bin, usrlocalbin,
etc.

*PATH=${PATH}:optbin*appends theoptbindirectory to the current
path. In a script, it

may be expedient to temporarily add a directory to the path in this
way. When the script exits, this

restores the original$PATH(a child process, such as a script, may not
change the environment of the

parent process, the shell).

*$PIPESTATUS*

Array variable holding exit status(es) of last
executedforegroundpipe.

#+BEGIN_EXAMPLE
  echo $PIPESTATUS
  0
  bash$ls -al | bogus_command
  bash: bogus_command: command not found
  bash$
  echo ${PIPESTATUS[1]}
  127
  bash$ls -al | bogus_command
  bash: bogus_command: command not found
  bash$
  echo $?
  127
#+END_EXAMPLE

The members of the $PIPESTATUS array hold the exit status of each
respective command executed

in a pipe. $PIPESTATUS[0] holds the exit status of the first command in
the pipe,

$PIPESTATUS[1] the exit status of the second command, and so on

*$PPID*

The $PPID of a process is the process ID (pid) of its parent process.
[42]

Compare this with the pidof command.

*$PROMPT_COMMAND*

A variable holding a command to be executed just before the primary
prompt, $PS1 is to be

displayed.

*$PS1*

This is the main prompt, seen at the command-line.

*$PS2*

The secondary prompt, seen when additional input is expected. It
displays as ">".

*$PS3*

The tertiary prompt, displayed in a select loop (see Example 11-29).

*$PS4*

The quartenary prompt, shown at the beginning of each line of output
when invoking a script with the

-x option. It displays as "+".

*$PWD*

Working directory (directory you are in at the time)

*$REPLY*

The default value when a variable is not supplied to read. Also
applicable to select menus, but only

supplies the item number of the variable chosen, not the value of the
variable itself.

*$SECONDS*

The number of seconds the script has been running.

*$SHELLOPTS*

The list of enabled shell options, a readonly variable.

*$SHLVL*

Shell level, how deeply Bash is nested. [43] If, at the command-line,
$SHLVL is 1, then in a script it

will increment to 2.

*$TMOUT*

If the$TMOUTenvironmental variable is set to a non-zero value time,
then the shell prompt will

time out after $time seconds. This will cause a logout.

*$UID*

User ID number

Current user's user identification number, as recorded in etcpasswd

This is the current user's real id, even if she has temporarily assumed
another identity through su.

$UID is a readonly variable, not subject to change from the command
line or within a script, and is

the counterpart to the id builtin.

$0, $1, $2, etc.

Positional parameters, passed from command line to script, passed to a
function, or set to a variable

(see Example 4-5 and Example 15-16)

*$#*

Number of command-line arguments [44] or positional parameters (see
Example 36-2)

*$**

All of the positional parameters, seen as a single word

"$*" must be quoted.

*$@*

Same as $*, but each parameter is a quoted string, that is, the
parameters are passed on intact, without

interpretation or expansion. This means, among other things, that each
parameter in the argument list

is seen as a separate word.

The*$@*and*$**parameters differ only when between double quotes.

#+BEGIN_EXAMPLE
  #!binbash
  # If $IFS set, but empty,
  #+ then "$*" and "$@" do not echo positional params as expected.
  mecho () # Echo positional parameters.
  {
  echo "$1,$2,$3";
  }
  IFS="" # Set, but empty.
  set a b c # Positional parameters.
  mecho "$*" # abc,,
  # \^\^
  mecho $* # a,b,c
  mecho $@ # a,b,c
  mecho "$@" # a,b,c
#+END_EXAMPLE

*$-*

Flags passed to script (using set).

*$!*

PID (process ID) of last job run in background

*$_*

Special variable set to final argument of previous command executed

*$?*

Exit status of a command, function, or the script itself (see Example
24-7)

*** 字体相关
fc-list
fc-list :lang=zh
fc-cache -fv

*** 前后台

Linux支持前后台任务的切换
+ command&   让进程在后台运行
+ jobs       查看后台运行的进程
+ fg %n      让后台运行的进程n到前台来
+ bg %n      让进程n到后台去
+ kill %n    杀死job
+ C-z        将一个正在前台执行的命令放到后台，并且暂停

*** jobs control
1. jobs    # list all bg jobs
2. fg n    # bring the job with PID n to foreground
3. fg %str   # fg the job with str-matched name
4. fg %?str    # question mark match any part
5. %n    # fg PID n
6. C-z    # suspending a job
7. bg    # move the fg job to bg, C-z first

* Git                                                                   :GIT:
** Fundamental
*** 安装                                                            :install:

https://github.com/git/git

from INSTALL(file)

#+BEGIN_EXAMPLE
Alternatively you can use autoconf generated ./configure script to
set up install paths (via config.mak.autogen), so you can write instead

        $ make configure ;# as yourself
        $ ./configure --prefix=/usr ;# as yourself
        $ make all doc ;# as yourself
        # make install install-doc install-html;# as root
#+END_EXAMPLE

顺便解决了 magit 因为 git 版本低的 bug

*** 分支                                                                :git:

+ 查看分支：git branch
+ 创建分支：git branch <name>
+ 切换分支：git checkout <name>
+ 创建+切换分支：git checkout -b <name>
+ 合并某分支到当前分支：git merge <name>
+ 删除分支：git branch -d <name>

*** 恢复指定文件                                                        :git:
**** why

git 恢复不小心修改的文件。

**** [[http://www.cnblogs.com/zhulin/archive/2012/06/09/2542785.html][恢复到指定版本]]

1. 首先查看该文件的历史版本信息： *git log <FILE>*

   #+BEGIN_SRC sh
   git log foo.txt
   #+END_SRC

   记录下需要恢复的commit版本号：如

   #+BEGIN_EXAMPLE
   9aa51d89799716aa68cff3f30c26f8815408e926
   #+END_EXAMPLE

2. 恢复该文件： *git reset <VERSION> <FILE>*

   #+BEGIN_SRC sh
   git reset 9aa51d89799716aa68cff3f30c26f8815408e926 foo.txt
   #+END_SRC

3. 提交git: *git commit*

   #+BEGIN_SRC sh
   git commit -m "revert old file"
   #+END_SRC

**** [[http://blog.csdn.net/awj3584/article/details/26567735][恢复到上一版本]]

恢复到最后一次提交的改动： /git checkout --/

#+BEGIN_SRC sh
git checkout -- <FILE>
#+END_SRC

需要注意的是，如果该文件已经 add 到暂存队列中， 需要先让这个文件 /取消
暂存/ ：

#+BEGIN_SRC sh
git reset HEAD -- <FILE>
#+END_SRC

#+BEGIN_SRC sh
git config --global alias.unstage 'reset HEAD --'
git config --global alias.restore 'checkout --'
#+END_SRC

/匿名命令/ ： 类似 bash 的 alias ，方便记忆

**** 小结

 git将单个文件恢复到历史版本的正确方法如下：

 1. git reset commit_id 文件路径
 2. git checkout -- 文件路径

** Tutorial                                                        :tutorial:

http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000#main

*** 安装配置
Linux下直接安装。

Windows下使用 [[http://msysgit.github.io/][msysgit]]

安装完成后首先必须对用户名和账户进行配置。
#+BEGIN_EXAMPLE
  git config --global user.name "Your Name"
  git config --global user.email "email@example.com"
#+END_EXAMPLE

*** Git本地使用
*版本库* 又名仓库，英文名 *respository*, 可以简单理解为一个目录，该目
录中的文件可以被Git管理，文件的修改、删除等变化都能被Git跟踪，以便任何
时刻都可以追踪历史，或者在将来某个时刻进行还原。

**** 新建版本库
进入工作目录，使用 *git init* 命令进行版本库的初始化。
#+BEGIN_EXAMPLE
  git init
#+END_EXAMPLE

注: 在Windows系统下，为了避免莫名其妙的问题，请确保路径名不包含中文

初始化后，目录下增加了.git文件夹，该目录用来跟踪管理版本库。

**** 添加文件
注：
+ Git只能跟踪文本文件，二进制文件如图片、视频、MS Word等的变化则没法跟
  踪。
+ 文本文件的编码最好统一使用UTF-8编码。

  使用 *git add* 将文件填加到版本库中。Unix的哲学 *没有消息就是好消息*
  ，该命令执行完成后不会显示消息。
  #+BEGIN_EXAMPLE
    git add <filename>
  #+END_EXAMPLE

**** 提交
使用 *git commit* 将填加的文件提交到版本库。
#+BEGIN_EXAMPLE
  git commint -m <commment>
#+END_EXAMPLE

**** 查看版本变更
*git status* 命令查看当前版本库状态。

*git diff* 命令，查看变更内容。
#+BEGIN_EXAMPLE
  git diff <filename>
#+END_EXAMPLE

确认无误后，使用git add和git commit进行提交。

**** 版本回退
*git log* 查看历史记录。Git的版本号是算法计算的十六进制数字。
#+BEGIN_EXAMPLE
  git log --pretty=oneling    # 在一行中显示历史记录信息。
#+END_EXAMPLE

Git中使用 *HEAD* 表示当前版本，使用 *HEAD^*, \verb$HEAD^^$ 表示历史版本，
*HEAD~100* 表示往上100个版本。
#+BEGIN_EXAMPLE
  git reset --hard HEAD^    # 命令回复到上一版本。
  git reset --hard <version-ID>    #命令回复到特定版本，其中版本号ID可不写全。
  git reflog    # 用来记录git的每一次命令信息。
#+END_EXAMPLE

**** 撤消修改
*git checkout* 命令撤消修改。
#+BEGIN_EXAMPLE
  git checkout -- <filename>
#+END_EXAMPLE

**** 删除文件
*git rm* 从版本库中删除文件中。
#+BEGIN_EXAMPLE
  git rm <filename>
  git checkout -- <filename>    # 可恢复跟踪的被系统删除的文件。
#+END_EXAMPLE

**** 小结
+ git init 新建版本库
+ git add [filename] 添加文件
+ git commit -m [comment] 提交文件
+ git status 查看版本库状态
+ git log 查看版本变更
+ git reset -hard [version] 版本恢复
+ git reflog 命令历史
+ git checkout -- [filename] 撤消修改
+ git rm [filename] 删除文件
*** git远程库
**** 创建远程仓库
远程仓库是git的杀手级应用之一.

1. 第1步: 创建SSH

   *SSH* (Secure SHell), 为一项创建在应用层和传输层基础上的安全协议，
   为计算机上的Shell（壳层）提供安全的传输和使用环境Key

   在用户主目录下，看看有没有 *.ssh* 目录，如果有，再看看这个目录下有
   没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。
   如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：
   #+BEGIN_EXAMPLE
     ssh-keygen -t rsa -C "youremail@example.com"
   #+END_EXAMPLE

   如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和
   id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄
   露出去，id_rsa.pub是公钥，可以放心地告诉任何人。

2. 第2步: 设置GitHub

   登陆GitHub，打开Account settings，SSH Keys页面.然后，点Add SSH Key，
   填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容.

   为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你
   推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了
   你的公钥，就可以确认只有你自己才能推送。

   当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，
   一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电
   脑上往GitHub推送了。

   最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只
   有你自己才能改）。所以，不要把敏感信息放进去。

**** 添加远程库
1. step 1: 登陆GIthub,创建一个新的仓库
2. step 2: 添加本地仓库
   #+BEGIN_EXAMPLE
     git remote add origin https://github.com/USER/REPO.git
   #+END_EXAMPLE
**** 推送本地内容到远程库
*git push*  把本地仓库的所有内容推送到远程库上.
#+BEGIN_EXAMPLE
  git push -u origin master
#+END_EXAMPLE
注: 第一次推送master分支时,加上参数\textbf{-u},Git不但把本地的master分
支内容推送到远程的新的master分支上,还会把本地的master与远程的master分
支关联起来,在以后的推送或者拉取中就可以简化命令.
#+BEGIN_EXAMPLE
  git push origin master
#+END_EXAMPLE

**** 从远程库克隆
#+BEGIN_EXAMPLE
  git clone https://github.com/USER/REPO.git
#+END_EXAMPLE
*** git pull
git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合
并。它的完整格式稍稍有点复杂。

#+BEGIN_EXAMPLE
  git pull <远程主机名> <远程分支名>:<本地分支名>
#+END_EXAMPLE

比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。
#+BEGIN_EXAMPLE
  git pull origin next:master
#+END_EXAMPLE

如果远程分支是与当前分支合并，则冒号后面的部分可以省略。
#+BEGIN_EXAMPLE
  git pull origin next
#+END_EXAMPLE
上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于
先做git fetch，再做git merge。
#+BEGIN_EXAMPLE
  git fetch origin
  git merge origin/next
#+END_EXAMPLE

在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系
(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名
分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分
支。

Git也允许手动建立追踪关系。
#+BEGIN_EXAMPLE
  git branch --set-upstream master origin/next
#+END_EXAMPLE

上面命令指定master分支追踪origin/next分支。

如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。
#+BEGIN_EXAMPLE
  git pull origin
#+END_EXAMPLE

上面命令表示，本地的当前分支自动与对应的origin主机”追踪分
支”(remote-tracking branch)进行合并。

如果当前分支只有一个追踪分支，连远程主机名都可以省略。
#+BEGIN_EXAMPLE
  git pull
#+END_EXAMPLE
上面命令表示，当前分支自动与唯一一个追踪分支进行合并。

如果合并需要采用rebase模式，可以使用–rebase选项。
#+BEGIN_EXAMPLE
  git pull --rebase <远程主机名> <远程分支名>:<本地分支名>
#+END_EXAMPLE

*** git ignore
+ 文件名: *.gitignore*
+ 特性:
  + 包括文件夹名
  + 支持通配符*
  + 按行组织
  + 文件本身应由git管理

*** git branch
**** 分支管理
分支就是平行宇宙,互不干扰,可以在适当的时候进行合并.

SVN也有分支管理功能,但是很慢.Git的分支与众不同,无论是创建,切换和删除分
支,无论版本库的大小,Git都能很快完成.
**** 创建与合并分支
+ 每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。
+ 截止到目前，只有一条时间线，在Git里，这个分支叫 *主分支* ，即master
  分支。
+ 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分
  支的线也越来越长
+ *HEAD严格来说不是指向提交，而是指向master，master才是指向提交的* ，
  所以，HEAD指向的就是当前分支。

  \begin{figure}[ht]
  \centering
  \includegraphics[width=0.5\linewidth]{/home/wally/Wally/Journal/Figure/scrot/5001kAy.png}
  \end{figure}


当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交
，再把HEAD指向dev，就表示当前分支在dev上.Git创建一个分支很快，因为除了
增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化

\begin{figure}[ht]
\centering
\includegraphics[width=0.5\linewidth]{/home/wally/Wally/Journal/Figure/scrot/5001WKB.png}
\end{figure}

不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，
dev指针往前移动一步，而master指针不变：

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{/home/wally/Wally/Journal/Figure/scrot/5001jUH.png}
\end{figure}

假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简
单的方法，就是直接把master指向dev的当前提交，就完成了合并：

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{/home/wally/Wally/Journal/Figure/scrot/5001weN.png}
\end{figure}



合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，
我们就剩下了一条master分支：
\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{/home/wally/Wally/Journal/Figure/scrot/50019oT.png}
\end{figure}

+ *git branch* 列出当前版本库的所有分支,当前分支前面会有一个 * 号.
+ *git checkout -b dev* -b 参数表示创建并切换,等于以下两步:
  + *git branch dev* 创建
  + *git checkout dev* 切换
+ *git merge dev* 用于合并指定分支到当前分支
+ *git branch -d dev* 删除分支, 注:
  + master分支并不是特殊的,可以删除
  + 不能删除当前分支,需切换

**** 解决冲突

当不同分支都有自己的新的提交时,这种情况下,git无法执行"快速
合并",只能试图把个自的修改合并起来,但可能会产生冲突.
\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{/home/wally/Wally/Journal/Figure/scrot/5001KzZ.png}
\end{figure}

#+BEGIN_EXAMPLE
Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容
#+END_EXAMPLE

**** 分支管理策略
通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支
后，会丢掉分支信息。

如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从
分支历史上就可以看出分支信息。
#+BEGIN_EXAMPLE
  git merge --no-ff -m "merge with no-ff" dev
#+END_EXAMPLE
+ *合并dev分支，请注意--no-ff参数，表示禁用Fast forward*
+ 本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去
\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{/home/wally/Wally/Journal/Figure/scrot/5001X9f.png}
\end{figure}


***** 分支策略
在实际开发中，我们应该按照几个基本原则进行分支管理：
+ 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在
  上面干活
+ 干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0
  版本发布时，再把dev分支合并到master上，在master分支发布1.0版本
+ 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不
  时地往dev分支上合并就可以了。

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{/home/wally/Wally/Journal/Figure/scrot/5001kHm.png}
\end{figure}


**** 多人合作
当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应
起来了，并且，远程仓库的默认名称是origin。
使用 *git remote* 查看远程库的信息, *git remote -v* 查看详细信息.
#+BEGIN_EXAMPLE
  git remote -v
#+END_EXAMPLE
***** 推送分支
推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，
这样，Git就会把该分支推送到远程库对应的远程分支上：
#+BEGIN_EXAMPLE
  git push origin master
#+END_EXAMPLE

如果要推送其他分支，比如dev，就改成：
#+BEGIN_EXAMPLE
  git push origin dev
#+END_EXAMPLE

***** 小结
+ 查看远程库信息，使用git remote -v；
+ 本地新建的分支如果不推送到远程，对其他人就是不可见的；
+ 从本地推送分支，使用git push origin branch-name，如果推送失败，先
  用git pull抓取远程的新提交；
+ 在本地创建和远程分支对应的分支，使用git checkout -b branch-name
  origin/branch-name，本地和远程分支的名称最好一致；
+ 建立本地分支和远程分支的关联，使用git branch --set-upstream
  branch-name origin/branch-name；
+ 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。
** github                                                           :github:
*** 搭建博客
参考:
+ http://holbrook.github.io/2013/05/27/jekyll_mysite.html#post-2398
+ http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html


1. 基础
   1) 关于Jekyll

     简单的说,是用Ruby语言实现的一个静态网站生成器,可以将 *Markdown* 编
      辑的文档生成HTML.当然也可以用来生成博客.

   2) 关于github
      Github是程序员的facebook.   github提供的静态网页托管.

      使用github pages写博客的好处有:
      + 自由,随意定制
      + 方便,在github上托管
      + 可控,有版本管理
      + 直接,只需提交,不需要先导出再提交
      + 高效,使用markdown语言能提高写作效率(但是个人觉得不如org-mode)
      + 免费,无限流量,无限空间

   3) 3分钟建立博客

2. 进阶

3. 推广
*** jekyllbootstrap                                :jekyll:jekyllbootstrap:

**** reference

+ [[http://themes.jekyllbootstrap.com/preview/mark-reid/lessons/2011/12/29/jekyll-introduction/][Jekyll Introduction]]
+ [[http://jekyllbootstrap.com/][Jekyllbootstrap]]
+ [[http://jekyllbootstrap.com/usage/jekyll-quick-start.html][Jekyllbootstrap Quickstart]]
+ [[http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html][使用 Github 和 Jekyll 搭建博客]]

**** jekyll quickstart

1. rake post title="Hello World"
2. $ rake page name="about.md"

**** Hello Julie

竹琳好

**** 小结

+ /使用 markdown 语言写/
+ 在使用中学习并不断探索，不要专门学习

*** git push without entering username and password

[[http://stackoverflow.com/questions/6565357/git-push-requires-username-and-password][stackoverflow]]

a common mistake is cloning *using the default (https) instead of
ssh*. you can correct this by going to your repository, clicking the
ssh button left to the url field and updating the url of your origin
remote like this:

#+begin_latex
\begin{minted}[frame=single, mathescape]{sh}
git remote set-url origin ssh://git@github.com:username/repo.git
\end{minted}
#+end_latex

[[using an https remote url has some advantages: it's easier to set up than ssh, and usually works through strict firewalls and proxies. however, it also prompts you to enter your github credentials every time you pull or push a repository.][github help]]

using an https remote url has some advantages: it's easier to set up
than ssh, and usually works through strict firewalls and
proxies. however, it also prompts you to enter your github credentials
every time you pull or push a repository.

[[using an https remote url has some advantages: it's easier to set up than ssh, and usually works through strict firewalls and proxies. however, it also prompts you to enter your github credentials every time you pull or push a repository.][github]]
*caching your github password in git*

*** [[https://help.github.com/articles/caching-your-github-password-in-git/][Caching your GitHub password in Git]]                              :blog:


If you're [[/articles/which-remote-url-should-i-use][cloning GitHub
repositories using HTTPS]], you can use a /credential helper/ to tell
Git to remember your GitHub username and password every time it talks to
GitHub.

If you clone GitHub repositories using SSH, then you authenticate using
SSH keys instead of a username and password. For help setting up an SSH
connection, see [[/articles/generating-an-ssh-key][Generating an SSH
Key]].

*Tips:*

- You need Git *1.7.10* or newer to use the credential helper.
- If you installed Git using [[http://brew.sh/][Homebrew]], the
   osxkeychain helper may already be installed.

Install the osxkeychain credential helper and tell Git to use it.

1. Find out if the osxkeychain credential helper is already installed by
   trying to run it:

   #+BEGIN_EXAMPLE
       git credential-osxkeychain
       # Test for the cred helper
       Usage: git credential-osxkeychain <get|store|erase>
   #+END_EXAMPLE

2. If the osxkeychain helper isn't installed, download it with curl:

   #+BEGIN_EXAMPLE
       git credential-osxkeychain
       # Test for the cred helper
       git: 'credential-osxkeychain' is not a git command. See 'git --help'.
       curl -s -O \
       https://github-media-downloads.s3.amazonaws.com/osx/git-credential-osxkeychain
       # Download the helper
       chmod u+x git-credential-osxkeychain
       # Fix the permissions on the file so it can be run
   #+END_EXAMPLE

3. Install the helper into the same directory where Git itself is
   installed:

   #+BEGIN_EXAMPLE
       sudo mv git-credential-osxkeychain \
       "$(dirname $(which git))/git-credential-osxkeychain"
       # Move the helper to the path where git is installed
       Password: [enter your password]
   #+END_EXAMPLE

4. Tell Git to use osxkeychain using the global =credential.helper=
   config:

   #+BEGIN_EXAMPLE
       git config --global credential.helper osxkeychain
       # Set git to use the osxkeychain credential helper
   #+END_EXAMPLE

The next time you clone an HTTPS URL that requires a password, you'll be
prompted for your username and password, and to grant access to the OSX
keychain. After you've done this, the username and password are stored
in your keychain and you won't be required to type them in to Git again.

*Tip:* You need Git *1.7.10* or newer to use the credential helper.

The credential helper is included with GitHub Desktop. The app also
provides a Git shell so you won't ever need to install and configure Git
manually. For more information, see
"[[/desktop/guides/getting-started/][Getting Started with GitHub
Desktop]]."

If you prefer working with the command line, you can also install a
native Git shell, such as [[https://msysgit.github.io/][msysgit]]. With
msysgit, running the following in the command line will store your
credentials:

#+BEGIN_EXAMPLE
    git config --global credential.helper wincred
#+END_EXAMPLE

*Tip:* You need Git *1.7.10* or newer to use the credential helper.

Turn on the credential helper so that Git will save your password in
memory for some time. By default, Git will cache your password for 15
minutes.

1. In Terminal, enter the following:

   #+BEGIN_EXAMPLE
       git config --global credential.helper cache
       # Set git to use the credential memory cache
   #+END_EXAMPLE

2. To change the default password cache timeout, enter the following:

   #+BEGIN_EXAMPLE
       git config --global credential.helper 'cache --timeout=3600'
       # Set the cache to timeout after 1 hour (setting is in seconds)
   #+END_EXAMPLE

*Tip:* You need Git *1.7.10* or newer to use the credential helper.

Turn on the credential helper so that Git will save your password in
memory for some time. By default, Git will cache your password for 15
minutes.

1. On the command line, enter the following:

   #+BEGIN_EXAMPLE
       git config --global credential.helper cache
       # Set git to use the credential memory cache
   #+END_EXAMPLE

2. To change the default password cache timeout, enter the following:

   #+BEGIN_EXAMPLE
       git config --global credential.helper 'cache --timeout=3600'
       # Set the cache to timeout after 1 hour (setting is in seconds)
   #+END_EXAMPLE

** git服务器                                                        :server:
*** tutorial

- http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000


1. 第一步，安装git：

   #+BEGIN_EXAMPLE
   $ sudo apt-get install git
   #+END_EXAMPLE

2. 第二步，创建一个git用户，用来运行git服务：

   #+BEGIN_EXAMPLE
   $ sudo adduser git
   #+END_EXAMPLE

3. 第三步，创建证书登录：

   收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有
   公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。

4. 第四步，初始化Git仓库：

   先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入
   命令：
   #+BEGIN_EXAMPLE
   $ sudo git init --bare sample.git
   #+END_EXAMPLE

   Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹
   是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上
   的Git仓库通常都以.git结尾。然后，把owner改为git：

   #+BEGIN_EXAMPLE
   $ sudo chown -R git:git sample.git
   #+END_EXAMPLE

5. 第五步，禁用shell登录：

   出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑
   /etc/passwd文件完成。找到类似下面的一行：

   #+BEGIN_EXAMPLE
   git:x:1001:1001:,,,:/home/git:/bin/bash
   #+END_EXAMPLE
   改为：
   #+BEGIN_EXAMPLE
   git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
   #+END_EXAMPLE

   这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git
   用户指定的git-shell每次一登录就自动退出。

6. 第六步，克隆远程仓库：
   现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：
   #+BEGIN_EXAMPLE
   $ git clone git@server:/srv/sample.git
   Cloning into 'sample'...
   warning: You appear to have cloned an empty repository.
   #+END_EXAMPLE

   剩下的推送就简单了。

   由本地库推送：

   #+BEGIN_EXAMPLE
   git remote add origin git@192.168.1.12:/path/to/src.git
   #+END_EXAMPLE

7. 其它

   1) 管理公钥

      如果团队很小，把每个人的公钥收集起来放到服务器的
      /home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号
      人，就没法这么玩了，这时，可以用Gitosis来管理公钥。

      这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相
      信找个高水平的Linux管理员问题不大。

   2) 管理权限

      有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系
      统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支
      甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继
      承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），
      所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制
      的目的。Gitolite就是这个工具。

      这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。

   3) 小结
      + 搭建Git服务器非常简单，通常10分钟即可完成；

      + 要方便管理公钥，用Gitosis；

      + 要像SVN那样变态地控制权限，用Gitolite。

*** 搭建 Git 服务器

**** why

搭建本地 git 服务器，将 PC 端的文件通过 git 与 Raspberry 共享

**** git server

1. 创建用户 git 并设置权限

2. 新建 git responsity, 以 .git 结尾

   #+BEGIN_EXAMPLE
   sudo git init --bare catkin_ws.git
   sudo chown -R git:git catkin_ws.git
   #+END_EXAMPLE

3. 从其它地方push

   #+BEGIN_EXAMPLE
   git remote add origin git@IP:/path/to/git-responsity.git
   git push origin -u master
   #+END_EXAMPLE

   - IP 可以是 localhost

**** reference

-
  http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000

**** raspberry

默认安装了git

** .gitignore                                                    :gitignore:
*** .gitignore                                            :gitignore:trick:

.gitignore 文件的内容为 "*", 通配所有文件.

只使用 git add -f <FILE> 增加需要跟踪的文件.

这样比逐条添加到 .gitignore 更有针对性.

* Kernel                                                             :KERNEL:

* Computer Science
** Ascii                                                             :ascii:
*** [[http://www.asciima.com/][ASCII码表详解]]                                                    :blog:

#+DOWNLOADED: http://www.asciima.com/img/ascii127-255.jpg @ 2016-01-25 17:01:04
 [[~/Wally/Journal/Figure/.org-download/Journal/ascii127-255_2016-01-25_17:01:04.jpg]]

ASCII码大致可以分作三部分组成。


**** 第一部分：ASCII非打印控制字符表

ASCII表上的数字0--31分配给了控制字符，用于控制像打印机等一些外围设备。
例如，12代表换页/新页功能。此命令指示打印机跳到下一页的开头。（参详
ASCII码表中0-31）

**** 第二部分：ASCII打印字符

数字 32--126
分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。数字127代表
DELETE 命令。（参详ASCII码表中32-127）

*ASCII码表 0-127*

| Bin        | Dec   | Hex   | 缩写/字符                     | 解释           |
| 00000000   | 0     | 00    | NUL(null)                     | 空字符         |
| 00000001   | 1     | 01    | SOH(start of headling)        | 标题开始       |
| 00000010   | 2     | 02    | STX (start of text)           | 正文开始       |
| 00000011   | 3     | 03    | ETX (end of text)             | 正文结束       |
| 00000100   | 4     | 04    | EOT (end of transmission)     | 传输结束       |
| 00000101   | 5     | 05    | ENQ (enquiry)                 | 请求           |
| 00000110   | 6     | 06    | ACK (acknowledge)             | 收到通知       |
| 00000111   | 7     | 07    | BEL (bell)                    | 响铃           |
| 00001000   | 8     | 08    | BS (backspace)                | 退格           |
| 00001001   | 9     | 09    | HT (horizontal tab)           | 水平制表符     |
| 00001010   | 10    | 0A    | LF (NL line feed, new line)   | 换行键         |
| 00001011   | 11    | 0B    | VT (vertical tab)             | 垂直制表符     |
| 00001100   | 12    | 0C    | FF (NP form feed, new page)   | 换页键         |
| 00001101   | 13    | 0D    | CR (carriage return)          | 回车键         |
| 00001110   | 14    | 0E    | SO (shift out)                | 不用切换       |
| 00001111   | 15    | 0F    | SI (shift in)                 | 启用切换       |
| 00010000   | 16    | 10    | DLE (data link escape)        | 数据链路转义   |
| 00010001   | 17    | 11    | DC1 (device control 1)        | 设备控制1      |
| 00010010   | 18    | 12    | DC2 (device control 2)        | 设备控制2      |
| 00010011   | 19    | 13    | DC3 (device control 3)        | 设备控制3      |
| 00010100   | 20    | 14    | DC4 (device control 4)        | 设备控制4      |
| 00010101   | 21    | 15    | NAK (negative acknowledge)    | 拒绝接收       |
| 00010110   | 22    | 16    | SYN (synchronous idle)        | 同步空闲       |
| 00010111   | 23    | 17    | ETB (end of trans. block)     | 传输块结束     |
| 00011000   | 24    | 18    | CAN (cancel)                  | 取消           |
| 00011001   | 25    | 19    | EM (end of medium)            | 介质中断       |
| 00011010   | 26    | 1A    | SUB (substitute)              | 替补           |
| 00011011   | 27    | 1B    | ESC (escape)                  | 溢出           |
| 00011100   | 28    | 1C    | FS (file separator)           | 文件分割符     |
| 00011101   | 29    | 1D    | GS (group separator)          | 分组符         |
| 00011110   | 30    | 1E    | RS (record separator)         | 记录分离符     |
| 00011111   | 31    | 1F    | US (unit separator)           | 单元分隔符     |
| 00100000   | 32    | 20    | (space)                       | 空格           |
| 00100001   | 33    | 21    | !                             |                |
| 00100010   | 34    | 22    | "                             |                |
| 00100011   | 35    | 23    | #                             |                |
| 00100100   | 36    | 24    | $                             |                |
| 00100101   | 37    | 25    | %                             |                |
| 00100110   | 38    | 26    | &                             |                |
| 00100111   | 39    | 27    | '                             |                |
| 00101000   | 40    | 28    | (                             |                |
| 00101001   | 41    | 29    | )                             |                |
| 00101010   | 42    | 2A    | *                             |                |
| 00101011   | 43    | 2B    | +                             |                |
| 00101100   | 44    | 2C    | ,                             |                |
| 00101101   | 45    | 2D    | -                             |                |
| 00101110   | 46    | 2E    | .                             |                |
| 00101111   | 47    | 2F    | /                             |                |
| 00110000   | 48    | 30    | 0                             |                |
| 00110001   | 49    | 31    | 1                             |                |
| 00110010   | 50    | 32    | 2                             |                |
| 00110011   | 51    | 33    | 3                             |                |
| 00110100   | 52    | 34    | 4                             |                |
| 00110101   | 53    | 35    | 5                             |                |
| 00110110   | 54    | 36    | 6                             |                |
| 00110111   | 55    | 37    | 7                             |                |
| 00111000   | 56    | 38    | 8                             |                |
| 00111001   | 57    | 39    | 9                             |                |
| 00111010   | 58    | 3A    | :                             |                |
| 00111011   | 59    | 3B    | ;                             |                |
| 00111100   | 60    | 3C    | <                             |                |
| 00111101   | 61    | 3D    | =                             |                |
| 00111110   | 62    | 3E    | >                             |                |
| 00111111   | 63    | 3F    | ?                             |                |
| 01000000   | 64    | 40    | @                             |                |
| 01000001   | 65    | 41    | A                             |                |
| 01000010   | 66    | 42    | B                             |                |
| 01000011   | 67    | 43    | C                             |                |
| 01000100   | 68    | 44    | D                             |                |
| 01000101   | 69    | 45    | E                             |                |
| 01000110   | 70    | 46    | F                             |                |
| 01000111   | 71    | 47    | G                             |                |
| 01001000   | 72    | 48    | H                             |                |
| 01001001   | 73    | 49    | I                             |                |
| 01001010   | 74    | 4A    | J                             |                |
| 01001011   | 75    | 4B    | K                             |                |
| 01001100   | 76    | 4C    | L                             |                |
| 01001101   | 77    | 4D    | M                             |                |
| 01001110   | 78    | 4E    | N                             |                |
| 01001111   | 79    | 4F    | O                             |                |
| 01010000   | 80    | 50    | P                             |                |
| 01010001   | 81    | 51    | Q                             |                |
| 01010010   | 82    | 52    | R                             |                |
| 01010011   | 83    | 53    | S                             |                |
| 01010100   | 84    | 54    | T                             |                |
| 01010101   | 85    | 55    | U                             |                |
| 01010110   | 86    | 56    | V                             |                |
| 01010111   | 87    | 57    | W                             |                |
| 01011000   | 88    | 58    | X                             |                |
| 01011001   | 89    | 59    | Y                             |                |
| 01011010   | 90    | 5A    | Z                             |                |
| 01011011   | 91    | 5B    | [                             |                |
| 01011100   | 92    | 5C    | \                             |                |
| 01011101   | 93    | 5D    | ]                             |                |
| 01011110   | 94    | 5E    | \^                            |                |
| 01011111   | 95    | 5F    | _                            |                |
| 01100000   | 96    | 60    | `                             |                |
| 01100001   | 97    | 61    | a                             |                |
| 01100010   | 98    | 62    | b                             |                |
| 01100011   | 99    | 63    | c                             |                |
| 01100100   | 100   | 64    | d                             |                |
| 01100101   | 101   | 65    | e                             |                |
| 01100110   | 102   | 66    | f                             |                |
| 01100111   | 103   | 67    | g                             |                |
| 01101000   | 104   | 68    | h                             |                |
| 01101001   | 105   | 69    | i                             |                |
| 01101010   | 106   | 6A    | j                             |                |
| 01101011   | 107   | 6B    | k                             |                |
| 01101100   | 108   | 6C    | l                             |                |
| 01101101   | 109   | 6D    | m                             |                |
| 01101110   | 110   | 6E    | n                             |                |
| 01101111   | 111   | 6F    | o                             |                |
| 01110000   | 112   | 70    | p                             |                |
| 01110001   | 113   | 71    | q                             |                |
| 01110010   | 114   | 72    | r                             |                |
| 01110011   | 115   | 73    | s                             |                |
| 01110100   | 116   | 74    | t                             |                |
| 01110101   | 117   | 75    | u                             |                |
| 01110110   | 118   | 76    | v                             |                |
| 01110111   | 119   | 77    | w                             |                |
| 01111000   | 120   | 78    | x                             |                |
| 01111001   | 121   | 79    | y                             |                |
| 01111010   | 122   | 7A    | z                             |                |
| 01111011   | 123   | 7B    | {                             |                |
| 01111100   | 124   | 7C    | |                             |                |
| 01111101   | 125   | 7D    | }                             |                |
| 01111110   | 126   | 7E    | ~                             |                |
| 01111111   | 127   | 7F    | DEL (delete)                  | 删除           |

**** 第三部分：扩展ASCII打印字符

扩展的ASCII字符满足了对更多字符的需求。扩展的ASCII包含ASCII中已有的128
个字符（数字0--32显示在下图中），又增加了128个字符，总共是256个。即使
有了这些更多的字符，许多语言还是包含无法压缩到256个字符中的符号。因此，
出现了一些ASCII的变体来囊括地区性字符和符号。例如，许多软件程序把ASCII
表（又称作ISO8859-1）用于北美、西欧、澳大利亚和非洲的语言。

** float                                                             :float:
*** [[http://blog.csdn.net/zcczcw/article/details/7362473][float浮点数的二进制存储方式及转换]]                                :blog:

int和float都是4字节32位表示形式。为什么float的范围大于int？

float精度为6～7位。1.66*10\^10的数字结果并不是166 0000 0000
指数越大，误差越大。

这些问题，都是浮点数的存储方式造成的。



    float和double在存储方式上都是遵从IEEE的规范的，float遵从的是IEEE
R32.24 ,而double 遵从的是R64.53。

  无论是单精度还是双精度在存储中都分为三个部分：

1. 符号位(Sign) : 0代表正，1代表为负
2. 指数位（Exponent）:用于存储科学计数法中的指数数据，并且采用移位存储
3. 尾数部分（Mantissa）：尾数部分

其中float的存储方式如下图所示：

#+DOWNLOADED: http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image001[3]_2.gif @ 2016-01-25 17:22:43
 [[~/Wally/Journal/Figure/.org-download/Journal/clip_image001[3]_2_2016-01-25_17:22:43.gif]]

而双精度的存储方式为:

#+DOWNLOADED: http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image001[6]_2.gif @ 2016-01-25 17:22:49
 [[~/Wally/Journal/Figure/.org-download/Journal/clip_image001[6]_2_2016-01-25_17:22:49.gif]]

 *将一个float型转化为内存存储格式的步骤为：*

（1）先将这个实数的绝对值化为二进制格式。

（2）将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边。
（3）从小数点右边第一位开始数出二十三位数字放入第22到第0位。
（4）如果实数是正的，则在第31位放入“0”，否则放入“1”。
（5）如果n是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。

（6）如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。如果n是右移得到的或n=0，则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到第23位。


R32.24和R64.53的存储方式都是用科学计数法来存储数据的，比如8.25用十进制
的科学计数法表示就
为:8.25*[[[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image0021.gif%5D%5B%5B%5Bhttp://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image0021_thumb.gif%5D%5D%5D%5D,%E8%80%8C120.5%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E4%B8%BA:1.205*%5B%5Bhttp://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image0022.gif%5D%5B%5B%5Bhttp://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image0022_thumb.gif%5D%5D%5D%5D,%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B9%E6%9C%AC%E4%B8%8D%E8%AE%A4%E8%AF%86%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%96%E5%8F%AA%E8%AE%A4%E8%AF%860%EF%BC%8C1%EF%BC%8C%E6%89%80%E4%BB%A5%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E4%B8%AD%EF%BC%8C%E9%A6%96%E5%85%88%E8%A6%81%E5%B0%86%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%95%B0%E6%9B%B4%E6%94%B9%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95%E8%A1%A8%E7%A4%BA%EF%BC%8C8.25%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%8F%AF%E8%A1%A8%E7%A4%BA%E4%B8%BA1000.01,120.5%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%BA%EF%BC%9A1110110.1%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95%E8%A1%A8%E7%A4%BA1000.01%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E4%B8%BA1.0001*%5B%5Bhttp://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%255B2%255D_1.gif%5D%5B%5B%5Bhttp://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%255B2%255D_thumb_1.gif%5D%5D%5D%5D,1110110.1%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E4%B8%BA1.1101101*%5B%5Bhttp://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%255B3%255D_1.gif%5D%5B%5B%5Bhttp://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%255B3%255D_thumb_1.gif%5D%5D%5D%5D,%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E6%95%B0%E9%83%BD%E7%9A%84%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95%E8%A1%A8%E7%A4%BA%E9%83%BD%E4%B8%BA1.xxx*%5B%5Bhttp://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%255B1%255D_1.gif%5D%5B%5B%5Bhttp://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%255B1%255D_thumb_1.gif%5D%5D%5D%5D,%E5%B0%BE%E6%95%B0%E9%83%A8%E5%88%86%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E4%B8%BAxxxx,%E7%AC%AC%E4%B8%80%E4%BD%8D%E9%83%BD%E6%98%AF1%E5%98%9B%EF%BC%8C%E5%B9%B2%E5%98%9B%E8%BF%98%E8%A6%81%E8%A1%A8%E7%A4%BA%E5%91%80%EF%BC%9F%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%B0%8F%E6%95%B0%E7%82%B9%E5%89%8D%E9%9D%A2%E7%9A%841%E7%9C%81%E7%95%A5%EF%BC%8C%E6%89%80%E4%BB%A523bit%E7%9A%84%E5%B0%BE%E6%95%B0%E9%83%A8%E5%88%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E7%9A%84%E7%B2%BE%E5%BA%A6%E5%8D%B4%E5%8F%98%E6%88%90%E4%BA%8624bit%EF%BC%8C%E9%81%93%E7%90%86%E5%B0%B1%E6%98%AF%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%8C%E9%82%A324bit%E8%83%BD%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E5%87%A0%E4%BD%8D%E5%91%A2%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%939%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%BA1001%EF%BC%8C%E6%89%80%E4%BB%A54bit%E8%83%BD%E7%B2%BE%E7%A1%AE%E5%8D%81%E8%BF%9B%E5%88%B6%E4%B8%AD%E7%9A%841%E4%BD%8D%E5%B0%8F%E6%95%B0%E7%82%B9%EF%BC%8C24bit%E5%B0%B1%E8%83%BD%E4%BD%BFfloat%E8%83%BD%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E6%E4%BD%8D%EF%BC%8C%E8%80%8C%E5%AF%B9%E4%BA%8E%E6%8C%87%E6%95%B0%E9%83%A8%E5%88%86%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%8C%87%E6%95%B0%E5%8F%AF%E6%AD%A3%E5%8F%AF%E8%B4%9F%EF%BC%8C8%E4%BD%8D%E7%9A%84%E6%8C%87%E6%95%B0%E4%BD%8D%E8%83%BD%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%8C%87%E6%95%B0%E8%8C%83%E5%9B%B4%E5%B0%B1%E5%BA%94%E8%AF%A5%E4%B8%BA:-127-128%E4%BA%86%EF%BC%8C%E6%89%80%E4%BB%A5%E6%8C%87%E6%95%B0%E9%83%A8%E5%88%86%E7%9A%84%E5%AD%98%E5%82%A8%E9%87%87%E7%94%A8%E7%A7%BB%E4%BD%8D%E5%AD%98%E5%82%A8%EF%BC%8C%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%BA%E5%85%83%E6%95%B0%E6%8D%AE+127%EF%BC%8C%E4%B8%8B%E9%9D%A2%E5%B0%B1%E7%9C%8B%E7%9C%8B8.25%E5%92%8C120.5%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F][http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image0021.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image0021_thumb.gif]]]],
而120.5可以表示
为:1.205*[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image0022.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image0022_thumb.gif]]]],
计算机根本不认识十进制的数据，他只认识0，1，所以在计算机存储中，首先要
将上面的数更改为二进制的科学计数法表示，8.25用二进制表示可表示为
1000.01,120.5用二进制表示为：1110110.1用二进制的科学计数法表示1000.01
可以表示为
1.0001*[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B2%5D_1.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B2%5D_thumb_1.gif]]]],1110110.1
可以表示为
1.1101101*[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B3%5D_1.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B3%5D_thumb_1.gif]]]],
任何一个数都的科学计数法表示都为
1.xxx*[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B1%5D_1.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B1%5D_thumb_1.gif]]]],
尾数部分就可以表示为xxxx,第一位都是1嘛，干嘛还要表示呀？可以将小数点前
面的1省略，所以23bit的尾数部分，可以表示的精度却变成了24bit，道理就是
在这里，那24bit能精确到小数点后几位呢，我们知道9的二进制表示为1001，所
以4bit能精确十进制中的1位小数点，24bit就能使float能精确到小数点后6位，
而对于指数部分，因为指数可正可负，8位的指数位能表示的指数范围就应该
为:-127-128了，所以指数部分的存储采用移位存储，存储的数据为元数据+127，
下面就看看8.25和120.5在内存中真正的存储方式]]
。


首先看下8.25，用二进制的科学计数法表示
#+DOWNLOADED: http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002[2]_thumb_1.gif @ 2016-01-25 17:23:29
 [[~/Wally/Journal/Figure/.org-download/Journal/clip_image002[2]_thumb_1_2016-01-25_17:23:29.gif]]]]

按照上面的存储方式，符号位为:0，表示为正，指数位为:3+127=130
,位数部分为,故8.25的存储方式如下图所示:

#+DOWNLOADED: http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002[5].gif @ 2016-01-25 17:23:20
 [[~/Wally/Journal/Figure/.org-download/Journal/clip_image002[5]_2016-01-25_17:23:20.gif]]

而单精度浮点数120.5的存储方式如下图所示:

#+DOWNLOADED: http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002_12.gif @ 2016-01-25 17:23:23
 [[~/Wally/Journal/Figure/.org-download/Journal/clip_image002_12_2016-01-25_17:23:23.gif]]



     *将一个内存存储的float二进制格式转化为十进制的步骤：*

（1）将第22位到第0位的二进制数写出来，在最左边补一位“1”，得到二十四位有效数字。将小数点点在最左边那个“1”的右边。

（2）取出第29到第23位所表示的值n。当30位是“0”时将n各位求反。当30位是“1”时将n增1。

（3）将小数点左移n位（当30位是“0”时）或右移n位（当30位是“1”时），得到一个二进制表示的实数。

（4）将这个二进制实数化为十进制，并根据第31位是“0”还是“1”加上正号或负号即可。

那么如果给出内存中一段数据，并且告诉你是单精度存储的话，你如何知道该数据的十进制数值呢？其实就是对上面的反推过程，比如给出如下内存数据：0100001011101101000000000000，首先我们现将该数据分段，0
10000 0101 110 1101 0000 0000 0000 0000，在内存中的存储就为下图所示：

[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image001_1.gif]]

根据我们的计算方式，可以计算出，这样一组数据表示为:1.1101101*[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B3%5D_1.gif][[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image002%5B3%5D_thumb_1.gif]]]]=120.5

而双精度浮点数的存储和单精度的存储大同小异，不同的是指数部分和尾数部分的位数。所以这里不再详细的介绍双精度的存储方式了，只将120.5的最后存储方式图给出，大家可以仔细想想为何是这样子的

[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image001_2.gif]]

下面我就这个基础知识点来解决一个我们的一个疑惑，请看下面一段程序，注意观察输出结果

  float f = 2.2f;
   double d = (double)f;
   Console.WriteLine(d.ToString("0.0000000000000"));
   f = 2.25f;
   d = (double)f;
   Console.WriteLine(d.ToString("0.0000000000000"));

可能输出的结果让大家疑惑不解，单精度的2.2转换为双精度后，精确到小数点后13位后变为了2.2000000476837，而单精度的2.25转换为双精度后，变为了2.2500000000000，为何2.2在转换后的数值更改了而2.25却没有更改呢？很奇怪吧？其实通过上面关于两种存储结果的介绍，我们已经大概能找到答案。首先我们看看2.25的单精度存储方式，很简单
0 1000 0001 001 0000 0000 0000 0000 0000,而2.25的双精度表示为:0 100 0000
0001 0010 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
0000,这样2.25在进行强制转换的时候，数值是不会变的，而我们再看看2.2呢，2.2用科学计数法表示应该为：将十进制的小数转换为二进制的小数的方法为将小数*2，取整数部分，所以0.282=0.4，所以二进制小数第一位为0.4的整数部分0，0.4×2=0.8，第二位为0,0.8*2=1.6,第三位为1，0.6×2
=
1.2，第四位为1，0.2*2=0.4，第五位为0，这样永远也不可能乘到=1.0，得到的二进制是一个无限循环的排列
00110011001100110011...
,对于单精度数据来说，尾数只能表示24bit的精度，所以2.2的float存储为:

[[http://images.cnblogs.com/cnblogs_com/jillzhang/WindowsLiveWriter/float_A919/clip_image001_7.gif]]

但是这样存储方式，换算成十进制的值，却不会是2.2的，应为十进制在转换为二进制的时候可能会不准确，如2.2，而double类型的数据也存在同样的问题，所以在浮点数表示中会产生些许的误差，在单精度转换为双精度的时候，也会存在误差的问题，对于能够用二进制表示的十进制数据，如2.25，这个误差就会不存在，所以会出现上面比较奇怪的输出结果。



附注：

*小数的二进制表示问题*

 首先我们要搞清楚下面两个问题：

  (1)  十进制整数如何转化为二进制数

  算法很简单。举个例子，11表示成二进制数：

  11/2=5   余  1

  5/2=2  余  1

  2/2=1  余  0

  1/2=0  余  1

  0结束  11二进制表示为(从下往上):1011


这里提一点：只要遇到除以后的结果为0了就结束了，大家想一想，所有的整数除以2是不是一定能够最终得到0。换句话说，所有的整数转变为二进制数的算法会不会无限循环下去呢？绝对不会，*整数永远可以用二进制精确表示 *，但小数就不一定了。

  (2) 十进制小数如何转化为二进制数

  算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数

  0.9*2=1.8  取整数部分  1

  0.8(1.8的小数部分)*2=1.6  取整数部分  1

  0.6*2=1.2  取整数部分  1

  0.2*2=0.4  取整数部分  0

  0.4*2=0.8  取整数部分  0

  0.8*2=1.6   取整数部分  1

  0.6*2=1.2  取整数部分  0

  .........  0.9二进制表示为(从上往下):
1100100100100......


注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，*小数的二进制表示有时是不可能精确的 *。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了"减不尽"的精度丢失问题。

** 数制
*** [[http://www.cnblogs.com/lds85930/archive/2007/09/19/897912.html][二进制、八进制、十进制、十六进制之间转换]] :blog:

**** 十进制与二进制之间的转换

***** 十进制转换为二进制，分为整数部分和小数部分

① 整数部分

方法：除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。下面举例：
例：将十进制的168转换为二进制

得出结果 将十进制的168转换为二进制，（10101000）2
分析:第一步，将168除以2,商84,余数为0。
第二步，将商84除以2，商42余数为0。
第三步，将商42除以2，商21余数为0。
第四步，将商21除以2，商10余数为1。
第五步，将商10除以2，商5余数为0。
第六步，将商5除以2，商2余数为1。
第七步，将商2除以2，商1余数为0。
第八步，将商1除以2，商0余数为1。
第九步，读数，因为最后一位是经过多次除以2才得到的，因此它是最高位，读数字从最后的余数向前读，即10101000

（2） 小数部分

方法：乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，剩下的小数部分又乘以2，一直取到小数部分

为零为止。如果永远不能为零，就同十进制数的四舍五入一样，按照要求保留多
少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向
入一位。换句话说就是0舍1入。读数要从前面的整数读到后面的整数，下面举例：

例1：将0.125换算为二进制

得出结果：将0.125换算为二进制（0.001）2
分析：第一步，将0.125乘以2，得0.25,则整数部分为0,小数部分为0.25;
第二步, 将小数部分0.25乘以2,得0.5,则整数部分为0,小数部分为0.5;
第三步, 将小数部分0.5乘以2,得1.0,则整数部分为1,小数部分为0.0;
第四步,读数,从第一位读起,读到最后一位,即为0.001。


例2,将0.45转换为二进制（保留到小数点第四位）

大家从上面步骤可以看出，当第五次做乘法时候，得到的结果是0.4，那么小数
部分继续乘以2，得0.8，0.8又乘以2的，到1.6这样一直乘下去，最后不可能得
到小数部分为零，因此，这个时候只好学习十进制的方法进行四舍五入了，但是
二进制只有0和1两个，于是就出现0舍1入。这个也是计算机在转换中会产生误差，
但是由于保留位数很多，精度很高，所以可以忽略不计。

那么，我们可以得出结果将0.45转换为二进制约等于0.0111
上面介绍的方法是十进制转换为为二进制的方法，需要大家注意的是：
1） 十进制转换为二进制，需要分成整数和小数两个部分分别转换
2） 当转换整数时，用的除2取余法，而转换小数时候，用的是乘2取整法
3） 注意他们的读数方向

因此，我们从上面的方法，我们可以得出十进制数168.125转换为二进制为10101000.001,或者十进制数转换为二进制数约等于10101000.0111。

***** 二进制转换为十进制 不分整数和小数部分

方法：按权相加法，即将二进制每位上的数乘以权，然后相加之和即是十进制数。例
将二进制数101.101转换为十进制数。

得出结果：（101.101）2=(5.625)10
大家在做二进制转换成十进制需要注意的是
1） 要知道二进制每位的权值
2） 要能求出每位的值


**** 二进制与八进制之间的转换

首先，我们需要了解一个数学关系，即23=8，24=16，而八进制和十六进制是用这

关系衍生而来的，即用三位二进制表示一位八进制，用四位二进制表示一位十六进制数。

接着，记住4个数字8、4、2、1（23=8、22=4、21=2、20=1）。现在我们来练习二进制与八进制之间的转换。

***** 二进制转换为八进制

方法：取三合一法，即从二进制的小数点为分界点，向左（向右）每三位取成一位，接着将这三位二进制按权相加，得到的数就是一位八位二进制数，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的八进制数。如果向左（向右）取三位后，取到最高（最低）位时候，如果无法凑足三位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足三位。例
①将二进制数101110.101转换为八进制

得到结果：将101110.101转换为八进制为56.5

② 将二进制数1101.1转换为八进制

得到结果：将1101.1转换为八进制为15.4

***** 将八进制转换为二进制

方法：取一分三法，即将一位八进制数分解成三位二进制数，用三位二进制按权相加去凑这位八进制数，小数点位置照旧。例：
① 将八进制数67.54转换为二进制

因此，将八进制数67.54转换为二进制数为110111.101100，即110111.1011
大家从上面这道题可以看出，计算八进制转换为二进制
首先，将八进制按照从左到右，每位展开为三位，小数点位置不变
然后，按每位展开为22，21，20（即4、2、1）三位去做凑数，即a×22+ b×21
+c×20=该位上的数（a=1或者a=0，b=1或者b=0，c=1或者c=0）,将abc排列就是该位的二进制数
接着，将每位上转换成二进制数按顺序排列
最后，就得到了八进制转换成二进制的数字。
以上的方法就是二进制与八进制的互换，大家在做题的时候需要注意的是
1） 他们之间的互换是以一位与三位转换，这个有别于二进制与十进制转换
2）
大家在做添0和去0的时候要注意，是在小数点最左边或者小数点的最右边（即整数的最高位和小数的最低位）才能添0或者去0，否则将产生错误

**** 二进制与十六进制的转换

方法：与二进制与八进制转换相似，只不过是一位（十六）与四位（二进制）的转换，下面具体讲解

***** 二进制转换为十六进制

方法：取四合一法，即从二进制的小数点为分界点，向左（向右）每四位取成一位，接着将这四位二进制按权相加，得到的数就是一位十六位二进制数，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的十六进制数。如果向左（向右）取四位后，取到最高（最低）位时候，如果无法凑足四位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足四位。
①例：将二进制11101001.1011转换为十六进制

得到结果：将二进制11101001.1011转换为十六进制为E9.B


② 例：将101011.101转换为十六进制

因此得到结果：将二进制101011.101转换为十六进制为2B.A



***** 将十六进制转换为二进制

方法：取一分四法，即将一位十六进制数分解成四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧。
①将十六进制6E.2转换为二进制数

因此得到结果：将十六进制6E.2转换为二进制为01101110.0010即110110.001

四、八进制与十六进制的转换

方法：一般不能互相直接转换，一般是将八进制（或十六进制）转换为二进制，然后再将二进制转换为十六进制（或八进制），小数点位置不变。那么相应的转换请参照上面二进制与八进制的转换和二进制与十六进制的转


**** 八进制与十进制的转换

***** 进制转换为十进制

方法：按权相加法，即将八进制每位上的数乘以位权，然后相加之和即是十进制数。
例：①将八进制数67.35转换为十进制

***** 十进制转换为八进制

十进制转换成八进制有两种方法：
1）间接法：先将十进制转换成二进制，然后将二进制又转换成八进制

2）直接法：前面我们讲过，八进制是由二进制衍生而来的，因此我们可以采用与十进制转换为二进制相类似的方法，还是整数部分的转换和小数部分的转换，下面来具体讲解一下：
①整数部分

方法：除8取余法，即每次将整数部分除以8，余数为该位权上的数，而商继续除以8，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。
②小数部分

方法：乘8取整法，即将小数部分乘以8，然后取整数部分，剩下的小数部分继续乘以8，然后取整数部分，剩下的小数部分又乘以8，一直取到小数部分为零为止。如果永远不能为零，就同十进制数的四舍五入一样，暂取个名字叫3舍4入。
例：将十进制数796.703125转换为八进制数
解：先将这个数字分为整数部分796和小数部分0.703125
整数部分

小数部分

因此，得到结果十进制796.703125转换八进制为1434.55

上面的方法大家可以验证一下，你可以先将十进制转换，然后在转换为八进制，这样看得到的结果是否一样

**** 十六进制与十进制的转换

十六进制与八进制有很多相似之处，大家可以参照上面八进制与十进制的转换自己试试这两个进制之间的转换。
通过上面对各种进制之间的转换，我们可以将前面的转换图重新完善一下：

** miscellaneous
*** SDK                                                  :blog:sdk:initial:

软件开发工具包（Software Development Kit, SDK）一般是一些被软件工程师
用于为特定的软件包、软件框架、硬件平台、操作系统等创建应用软件的开发工
具的集合。

它或许只是简单的为某个程序设计语言提供应用程序接口的一些文件，但也可能
包括能与某种嵌入式系统通讯的复杂的硬件。一般的工具包括用于调试和其他用
途的实用工具。SDK还经常包括示例代码、支持性的技术注解或者其他的为基本
参考资料澄清疑点的支持文档。

软件工程师通常从目标系统开发者那里获得软件开发包。为了鼓励开发者使用其
系统或者语言，许多SDK是免费提供的。SDK经常可以直接从互联网下载。有时也
被作为营销手段。例如，甲产品或许会免费提供构件SDK以鼓励人们使用它，从
而会吸引更多人由于能免费为其编程而购买其构件。

SDK可能附带了使其不能在不兼容的许可证下开发软件的许可证。例如一个专有
的SDK可能与自由软件开发抵触。而GPL能使SDK与专有软件开发近乎不兼容。
LGPL下的SDK则没有这个问题。

举例
- Microsoft的DirectX SDK
- iOS的iOS软件开发工具包
- Sun Microsystems的Java SDK
- 构件工具包
- 英特尔AMT的SDK
- Google的Android SDK

*** [[http://blog.csdn.net/hairetz/article/details/4141043][堆和栈的区别]] :blog:

**** 预备知识—程序的内存分配
一个由C/C++编译的程序占用的内存分为以下几个部分
- 栈区（stack） ::  由编译器自动分配释放   ，存放函数的参数值，局部变
     量的值等。其操作方式类似于数据结构中的栈。

- 堆区（heap） :: 一般由程序员分配释放，   若程序员不释放，程序结束时
     可能由OS回收   。注意它与数据结构中的堆是两回事，分配方式倒是类似
     于链表，呵呵。

- 全局区（静态区）（static） :: 全局变量和静态变量的存储是放在一块的，
     初始化的全局变量和静态变量在一块区域，   未初始化的全局变量和未初
     始化的静态变量在相邻的另一块区域。   -   程序结束后由系统释放。

- 文字常量区 ::  —常量字符串就是放在这里的。   程序结束后由系统释放

- 程序代码区 :: 存放函数体的二进制代码。

**** 例子程序
这是一个前辈写的，非常详细

//main.cpp
int   a   =   0;   全局初始化区
char   *p1;   全局未初始化区
main()
{
int   b;   栈
char   s[]   =   "abc";   栈
char   *p2;   栈
char   *p3   =   "123456";   123456/0在常量区，p3在栈上。
static   int   c   =0；   全局（静态）初始化区
p1   =   (char   *)malloc(10);
p2   =   (char   *)malloc(20);
分配得来得10和20字节的区域就在堆区。
strcpy(p1,   "123456");   123456/0放在常量区，编译器可能会将它与p3所指向的"123456"
优化成一个地方。
}

**** 堆和栈的理论知识

2.1 申请方式

stack: 由系统自动分配。

例如，声明在函数中一个局部变量   int   b;   系统自动在栈中为b开辟空间

heap: 需要程序员自己申请，并指明大小，在c中malloc函数
如p1   =   (char   *)malloc(10);

在C++中用new运算符
如 p2   =   new   char[10];
但是注意p1、p2本身是在栈中的。


2.2 申请后系统的响应

栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常
提示栈溢出。

堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表
中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的
首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。
另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部
分重新放入空闲链表中。

2.3 申请大小的限制

栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意
思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有
的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将
提示overflow。因此，能从栈获得的空间较小。

堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储
的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小
受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

2.4申请效率的比较：
栈由系统自动分配，速度较快。但程序员是无法控制的。
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是
直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。

2.5堆和栈中的存储内容
栈：   在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可
执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈
的，然后是函数中的局部变量。注意静态变量是不入栈的。
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地
址，也就是主函数中的下一条指令，程序由该点继续运行。
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

2.6存取效率的比较

char   s1[]   =   "aaaaaaaaaaaaaaa";
char   *s2   =   "bbbbbbbbbbbbbbbbb";
aaaaaaaaaaa是在运行时刻赋值的；
而bbbbbbbbbbb是在编译时就确定的；
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。
比如：
#+BEGIN_EXAMPLE
#include
void   main()
{
char   a   =   1;
char   c[]   =   "1234567890";
char   *p   ="1234567890";
a   =   c[1];
a   =   p[1];
return;
}
#+END_EXAMPLE
对应的汇编代码
10:   a   =   c[1];
00401067   8A   4D   F1   mov   cl,byte   ptr   [ebp-0Fh]
0040106A   88   4D   FC   mov   byte   ptr   [ebp-4],cl
11:   a   =   p[1];
0040106D   8B   55   EC   mov   edx,dword   ptr   [ebp-14h]
00401070   8A   42   01   mov   al,byte   ptr   [edx+1]
00401073   88   45   FC   mov   byte   ptr   [ebp-4],al
第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到
edx中，再根据edx读取字符，显然慢了。

**** 小结：

堆和栈的区别可以用如下的比喻来看出：
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就
走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自
由度小。
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由
度大。

*** eps                                                               :eps:

eps文件是封装的PostScript（Encapsulated PostScript）格式。PostScript
语言是Adobe 公司设计用于向任何支持PostScript语言的打印机打印文件的页
面 *描述语言* 。除了它是被优化用于纸张上打印文字和图像之外，它像Basjc 语
言、C语言或任何其它编程语言一样。当你在 PostScript打印机上工作并告诉
文字处理器（或任何其它的应用程序）打印页面时，计算机就会用PostScript
语言编写一个程序描述该页面，并将这个程序传送给打印机。打印机实际上其
中装有一台功能齐全的计算机和PostScript 语言解释器执行这个程序，将图形
画在内存中的虚拟纸张上，然后将其打印到纸上。

**** 小结
EPS是一种 *矢量图片格式*

*** 标签云                                                         :标签云:
**** about

标签云或文字云是关键词的视觉化描述，用于汇总用户生成的标签或一个网站的
文字内容。标签一般是独立的词汇，常常按字母顺序排列，其重要程度又能通过
改变字体大小或颜色来表现，所以标签云可以灵活地依照字序或热门程度来检索
一个标签。

使用 http://worditout.com/  在线生成标签云

**** reference

+ [[https://zh.wikipedia.org/wiki/%e6%a0%87%e7%ad%be%e4%ba%91][wiki]]
+ [[
http://www.zhihu.com/question/21128950][知乎]]
+ http://worditout.com/

**** 小结

标签云： *关键词频率的可视化*
*** 键盘数字键指法

+ 左小: 1
+ 左无: 2
+ 左中: 3
+ 左食: 4,5
+ 右食: 6,7
+ 右中: 8
+ 右无: 9
+ 右小: 0

扩展: 标准指法
1) 左小指: `  1  Q  A  Z
2) 左无名指: 2  W  S  X
3) 左中指: 3  E  D  C
4) 左食指: 4  5  R  T  F  G  V  B
5) 左  右拇指: 空白键
6) 右食指: 6  7  Y  U  H  J  N  M
7) 右中指: 8  I  K  ,
8) 右无名指: 9  O  L  .
9) 右小指: 0  -  =  P  ()  ()  ;  '  /  \

* Tools
** X11                                                                 :x11:
*** xinitrc                                                   :xinitrc:x11:

**** why

从图标图标启动的初始化。

Emacs 安装 magit 时的版本错误提示

#+BEGIN_EXAMPLE
If this comes as a surprise to you, because you do actually have
a newer version installed, then that probably means that the
older version happens to appear earlier on the `$PATH'.  If you
always start Emacs from a shell, then that can be fixed in the
shell's init file.  If you start Emacs by clicking on an icon,
or using some sort of application launcher, then you probably
have to adjust the environment as seen by graphical interface.
For X11 something like ~/.xinitrc should work.
#+END_EXAMPLE

~/.xinitrc

**** xinitrc

~/.xinitrc 文件是 xinit 和它的前端 startx 第一次启动时会读取的脚本。通
常用在启动 X 时执行窗口管理器 和其他程序，例如启动守护进程和设置环境变
量。

#+include: ~/.xinitrc

类似 ~/.bashrc， 在登录 X，即正常情况下开机时读入的初始化文件。

**** 怎么配置暂时不用管

**** reference

+ [[https://wiki.archlinux.org/index.php/Xinitrc_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)][archlinux::xinitrc]]

**** [[https://wiki.archlinux.org/index.php/Xinitrc][xinitrc]]                                                        :blog:

The =~/.xinitrc= file is a shell script read by =xinit= and by its
front-end =startx=. It is mainly used to execute
[[/index.php/Desktop_environment][desktop environments]],
[[/index.php/Window_manager][window managers]] and other programs when
starting the X server (e.g., starting daemons and setting environment
variables). The =xinit= program starts the
[[/index.php/X_Window_System][X Window System]] server and works as
first client program on systems that are not using a
[[/index.php/Display_manager][display manager]].

One of the main functions of =~/.xinitrc= is to dictate which client for
the X Window System is invoked with =startx= or =xinit= programs on a
per-user basis. There exists numerous additional specifications and
commands that may also be added to =~/.xinitrc= as you further customize
your system.

Most DMs also source the similar [[/index.php/Xprofile][xprofile]]
before xinit.

***** Contents

- [[#Installation][1 Installation]]
- [[#Configuration][2 Configuration]]
- [[#Autostart_X_at_login][3 Autostart X at login]]

   -  [[#Automatic_login_to_the_virtual_console][3.1 Automatic login to
      the virtual console]]

- [[#Tips_and_tricks][4 Tips and tricks]]

   -  [[#Override_xinitrc_from_command_line][4.1 Override xinitrc from
      command line]]
   -  [[#Making_a_DE.2FWM_choice][4.2 Making a DE/WM choice]]
   -  [[#Starting_applications_without_a_window_manager][4.3 Starting
      applications without a window manager]]

***** Installation

[[/index.php/Install][Install]]
[[https://www.archlinux.org/packages/?name=xorg-xinit][xorg-xinit]],
which provides both /xinit/ and /startx/.

***** Configuration

If =.xinitrc= is present in a user's home directory, /startx/ and
/xinit/ execute it. Otherwise /startx/ will run the default
=/etc/X11/xinit/xinitrc=.

*Note:* /Xinit/ has its own default behaviour instead of executing the
file. See =man 1 xinit= for details.

This default xinitrc will start a basic environment with
[[/index.php/Twm][Twm]],
[[https://www.archlinux.org/packages/?name=xorg-xclock][xorg-xclock]]
and [[/index.php/Xterm][Xterm]] (assuming that the necessary packages
are installed). Therefore, to start a different window manager or
desktop environment, first create a copy of the default =xinitrc= in
home directory:

#+BEGIN_EXAMPLE
    $ cp /etc/X11/xinit/xinitrc ~/.xinitrc
#+END_EXAMPLE

The reason of doing this (instead of creating one from scratch) is to
preserve some desired default behaviour in the original file, such as
sourcing shell scripts from =/etc/X11/xinit/xinitrc.d=. Scripts in this
directory without =.sh= extension are not sourced:
[[https://bugs.archlinux.org/task/41471][FS#41471]]. As such, replace
=/etc/X11/xinit/xinitrc.d/?*.sh= with =/etc/X11/xinit/xinitrc.d/?*=.
[[https://bbs.archlinux.org/viewtopic.php?pid=1514318#p1514318][[1]]]

Append desired commands and /remove/comment the conflicting lines/.
Remember, lines following =exec= would be ignored. For example, to start
[[/index.php/Openbox#Standalone][openbox]]:

#+BEGIN_EXAMPLE
    ~/.xinitrc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    ...

    if [ -d /etc/X11/xinit/xinitrc.d ] ; then
        for f in /etc/X11/xinit/xinitrc.d/?* ; do
            [ -x "$f" ] && . "$f"
        done
        unset f
    fi

    # twm &
    # xclock -geometry 50x50-1+1 &
    # xterm -geometry 80x50+494+51 &
    # xterm -geometry 80x20+494-0 &
    # exec xterm -geometry 80x66+0+0 -name login

    ## some applications that should be run in the background
    xscreensaver &
    xsetroot -cursor_name left_ptr &

    exec openbox-session
#+END_EXAMPLE

*Note:* At the very least, ensure that the /if block/ in the example
above is present in your =.xinitrc= file to ensure that the scripts in
=/etc/X11/xinit/xinitrc.d= are sourced.

Long-running programs started before the window manager, such as a
screensaver and wallpaper application, must either fork themselves or be
run in the background by appending an =&= sign. Otherwise, the script
would halt and wait for each program to exit before executing the window
manager or desktop environment. Note that some programs should instead
not be forked, to avoid race bugs, as is the case of
[[/index.php/Xrdb][xrdb]]. Prepending =exec= will replace the script
process with the window manager process, so that X does not exit even if
this process forks to the background.

To now run Xorg as a regular user, issue:

#+BEGIN_EXAMPLE
    $ startx
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    $ xinit -- :1 -nolisten tcp vt$XDG_VTNR
#+END_EXAMPLE

Your window manager (or desktop environment) of choice should now start
correctly.

To quit X, run your window manager's exit function (assuming it has
one). If it lacks such functionality, run:

#+BEGIN_EXAMPLE
    $ pkill -15 Xorg
#+END_EXAMPLE

*Note:* /pkill/ will kill all running X instances. To specifically kill
the window manager on the current VT, use:

#+BEGIN_EXAMPLE
    WM_PID=$(xprop -id $(xprop -root _NET_SUPPORTING_WM_CHECK \
    | awk -F'#' '{ print $2 }') _NET_WM_PID \
    | awk -F' = ' '{ print $2 }')

    kill -15 $WM_PID
#+END_EXAMPLE

The program =xprop= is provided by the package
[[https://www.archlinux.org/packages/?name=xorg-xprop][xorg-xprop]] in
the [[/index.php/Official_repositories][official repositories]].

*Note:*

- The above commands run [[/index.php/Xorg][Xorg]] on the same virtual
   terminal the user is logged in to.
   [[http://blog.falconindy.com/articles/back-to-basics-with-x-and-systemd.html][[2]]]
   This maintains an authenticated session with =logind=, and prevents
   bypassing the screen locker by switching terminals.
- You have to specify =vt$XDG_VTNR= as command line option for /xinit/
   in order to
   [[/index.php/General_troubleshooting#Session_permissions][preserve
   session permissions]].
- /xinit/ does not handle multiple sessions when already logged-in into
   a different virtual terminal. For that you must specify the session
   by appending =-- :session_no=. If X is already running, then you
   should start with :1 or more.
- By default, due to permissions on console devices, the X display
   needs to be on the same tty where the login occurred. This is handled
   by the default =/etc/X11/xinit/xserverrc=. See
   [[/index.php/General_troubleshooting#Session_permissions][General
   troubleshooting#Session permissions]] for details.
- If you wish to have the X display on a separate console from the one
   where the server is invoked, you can do so by using the X server
   wrapper provided by =/usr/lib/systemd/systemd-multi-seat-x=. For
   convenience, /startx/ can be set up to use this wrapper by modifying
   your =~/.xserverrc=.
- If you choose to use /xinit/ instead of /startx/, you are responsible
   for passing =-nolisten tcp= and ensuring the session does not break
   by starting X on a different tty.
- If X terminates with error message "SocketCreateListener() failed",
   you may need to delete socket files in =/tmp/.X11-unix=. This may
   happen if you have previously run Xorg as root (e.g. to generate an
   =xorg.conf=, as below).

***** Autostart X at login

*Note:* These solutions run X on the same tty used to login, which is
required in order to maintain the login session.

For [[/index.php/Bash][Bash]], add the following to the bottom of
=~/.bash_profile=. If the file does not exist, copy a skeleton version
from =/etc/skel/.bash_profile=. For [[/index.php/Zsh][Zsh]], add it to
=~/.zlogin= (or =~/.zprofile=) instead.

#+BEGIN_EXAMPLE
    [[ -z $DISPLAY && $XDG_VTNR -eq 1 ]] && exec startx
#+END_EXAMPLE

*Note:*

- You can replace the =-eq 1= comparison with one like =-le 3= (for vt1
   to vt3) if you want to use graphical logins on more than one VT.
- X must always be run on the same tty where the login occurred, to
   preserve the logind session. This is handled by the default
   =/etc/X11/xinit/xserverrc=.
- =xinit= may be faster than =startx=, but needs additional parameter
   such as =-nolisten tcp=.
- If you would like to remain logged in when the X session ends, remove
   =exec=.

See also [[/index.php/Fish#Start_X_at_login][Fish#Start X at login]] and
[[/index.php/Systemd/User#Automatic_login_into_Xorg_without_display_manager][Systemd/User#Automatic
login into Xorg without display manager]].

****** Automatic login to the virtual console

This method can be combined with
[[/index.php/Automatic_login_to_virtual_console][automatic login to
virtual console]].

***** Tips and tricks

****** Override xinitrc from command line

If you have a working =~/.xinitrc=, but just want to try other WM/DE,
you can run it by issuing /startx/ followed by the path to the window
manager:

#+BEGIN_EXAMPLE
    $ startx /full/path/to/window-manager
#+END_EXAMPLE

If the window manager takes arguments, they need to be enquoted to be
recognized as part of the first parameter of /startx/:

#+BEGIN_EXAMPLE
    $ startx "/full/path/to/window-manager --key value"
#+END_EXAMPLE

Note that the full path is *required*. Optionally, you can also override
=/etc/X11/xinit/xserverrc= file (which stores the default X server
options) with custom options by appending them after =--=, e.g.:

#+BEGIN_EXAMPLE
    $ startx /usr/bin/enlightenment -- -nolisten tcp -br +bs -dpi 96 vt$XDG_VTNR
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    $ xinit /usr/bin/enlightenment -- -nolisten tcp -br +bs -dpi 96 vt$XDG_VTNR
#+END_EXAMPLE

See also =man startx=.

*Tip:* This can be used even to start a regular GUI programs but without
any of the window manager features. See also
[[#Starting_applications_without_a_window_manager][#Starting
applications without a window manager]] and
[[/index.php/Running_program_in_separate_X_display][Running program in
separate X display]].

****** Making a DE/WM choice

If you are frequently switching between different DEs/WMs, it is
recommended to either use a [[/index.php/Display_manager][Display
manager]] or add code to =.xinitrc=. The code described next consists of
a simple few lines, which will take the argument and load the desired
desktop environment or window manager.

The following example =~/.xinitrc= shows how to start a particular DE/WM
with an argument:

#+BEGIN_EXAMPLE
    ~/.xinitrc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    ...

    # Here Xfce is kept as default
    session=${1:-xfce}

    case $session in
        awesome           ) exec awesome;;
        bspwm             ) exec bspwm;;
        catwm             ) exec catwm;;
        cinnamon          ) exec cinnamon-session;;
        dwm               ) exec dwm;;
        enlightenment     ) exec enlightenment_start;;
        ede               ) exec startede;;
        fluxbox           ) exec startfluxbox;;
        gnome             ) exec gnome-session;;
        gnome-classic     ) exec gnome-session --session=gnome-classic;;
        i3|i3wm           ) exec i3;;
        icewm             ) exec icewm-session;;
        jwm               ) exec jwm;;
        kde               ) exec startkde;;
        mate              ) exec mate-session;;
        monster|monsterwm ) exec monsterwm;;
        notion            ) exec notion;;
        openbox           ) exec openbox-session;;
        unity             ) exec unity;;
        xfce|xfce4        ) exec startxfce4;;
        xmonad            ) exec xmonad;;
        # No known session, try to run it as command
        *) exec $1;;
    esac
#+END_EXAMPLE

Then copy the =/etc/X11/xinit/xserverrc= file to your home directory:

#+BEGIN_EXAMPLE
    $ cp /etc/X11/xinit/xserverrc ~/.xserverrc
#+END_EXAMPLE

After that, you can easily start a particular DE/WM by passing an
argument, e.g.:

#+BEGIN_EXAMPLE
    $ xinit
    $ xinit gnome
    $ xinit kde
    $ xinit wmaker
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
    $ startx
    $ startx ~/.xinitrc gnome
    $ startx ~/.xinitrc kde
    $ startx ~/.xinitrc wmaker
#+END_EXAMPLE

****** Starting applications without a window manager

It is possible to start only specific applications without a window
manager, although most likely this is only useful with a single
application shown in full-screen mode. For example:

#+BEGIN_EXAMPLE
    ~/.xinitrc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    ...

    exec chromium
#+END_EXAMPLE

With this method you need to set each application window's geometry
through its own configuration files, if possible at all.

*Tip:* This method can be useful to launch graphical games, especially
on systems where excluding the memory or CPU usage of a window manager
or desktop environment, and possible accessory applications, can help
improve the game's execution performance.

See also
[[/index.php/Display_manager#Starting_applications_without_a_window_manager][Display
manager#Starting applications without a window manager]].

*** xsel                                                             :xsel:

Manipulate the X selection

sudo apt-get install xsel

**** option

+ -b, --clipboard       Operate on the CLIPBOARD selection
+ -o, --output          Write the selection to standard output
+ -i, --input           Read standard input into the selection

**** usage

1. 复制内容到剪贴板中

   #+BEGIN_EXAMPLE
   cat file | xsel -i -b
   #+END_EXAMPLE

2. 取出剪贴板内容

   #+BEGIN_EXAMPLE
   xsel -o -b
   #+END_EXAMPLE

*** [[https://wiki.archlinux.org/index.php/Xmodmap][xmodmap]]        :blog:


*Note:* /xmodmap/ settings are reset by /setxkbmap/, which not only
alters the alphanumeric keys to the values given in the map, but also
resets all other keys to the startup default.
[[http://wiki.linuxquestions.org/wiki/Configuring_keyboards][[1]]]

/xmodmap/ is a utility for modifying keymaps and pointer button mappings
in [[/index.php/Xorg][Xorg]].

/xmodmap/ is not directly related to
[[/index.php/X_KeyBoard_extension][X KeyBoard extension]] (XKB), as it
uses different (pre-XKB) ideas on how /keycodes/ are processed within X.
Generally, it is only recommended for the simplest tasks. See
[[/index.php/X_KeyBoard_extension][X KeyBoard extension]] for advanced
layout configuration.

**** Contents

- [[#Introduction][1 Introduction]]
- [[#Installation][2 Installation]]
- [[#Keymap_table][3 Keymap table]]
- [[#Custom_table][4 Custom table]]

   -  [[#Activating_the_custom_table][4.1 Activating the custom table]]
   -  [[#Test_changes][4.2 Test changes]]

- [[#Modifier_keys][5 Modifier keys]]
- [[#Reverse_scrolling][6 Reverse scrolling]]
- [[#Templates][7 Templates]]

   -  [[#Spanish][7.1 Spanish]]
   -  [[#Turn_CapsLock_into_Control.2C_and_LeftControl_into_Hyper][7.2
      Turn CapsLock into Control, and LeftControl into Hyper]]
   -  [[#Switch_every_number_key_N_with_Shift-N_and_vice-versa.2C_for_Croatian_layout][7.3
      Switch every number key N with Shift-N and vice-versa, for
      Croatian layout]]

- [[#See_also][8 See also]]

**** Introduction

There are two types of keyboard values in [[/index.php/Xorg][Xorg]]:
/keycodes/ and /keysyms/.

-  keycode  :: The /keycode/ is the numeric representation received by
   the kernel when a key or a mouse button is pressed.
-  keysym :: The /keysym/ is the value assigned to the /keycode/. For
   example, pressing =A= generates the =keycode 73=, which is mapped to
   the =keysym 0×61=, which matches =A= in the
   [[https://en.wikipedia.org/wiki/ASCII][ASCII table]].
   The /keysyms/ are managed by [[/index.php/Xorg][Xorg]] in a table of
   /keycodes/ defining the /keycode/-/keysym/ relations, which is called
   the [[#Keymap_table][keymap table]]. This can be shown by running
   =xmodmap=.

**** Installation

/xmodmap/ can be [[/index.php/Pacman][installed]] through the
[[https://www.archlinux.org/packages/?name=xorg-xmodmap][xorg-xmodmap]]
package from the [[/index.php/Official_repositories][official
repositories]].

Optionally, install
[[https://www.archlinux.org/packages/?name=xkeycaps][xkeycaps]], which
is a graphical front-end to /xmodmap/.

**** Keymap table

Print the current keymap table formatted into expressions:

#+BEGIN_EXAMPLE
    $ xmodmap -pke
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [...]
    keycode  57 = n N
    [...]
#+END_EXAMPLE

Each /keycode/ is followed by the /keysym/ it is mapped to. The above
example indicates that the /keycode/ =57= is mapped to the lowercase
=n=, while the uppercase =N= is mapped to /keycode/ =57= plus =Shift=.

Each /keysym/ column in the table corresponds to a particular
combination of modifier keys:

1. =Key=
2. =Shift+Key=
3. =mode_switch+Key=
4. =mode_switch+Shift+Key=
5. =AltGr+Key=
6. =AltGr+Shift+Key=

Not all /keysyms/ have to be set, but to assign only a latter /keysym/,
use the =NoSymbol= value.

To see which /keycode/ corresponds to a key, see
[[/index.php/Extra_keyboard_keys#In_Xorg][Extra keyboard keys#In Xorg]]
for details on the /xev/ utility.

*Tip:* There are predefined descriptive /keysyms/ for multimedia keys,
e.g. =XF86AudioMute= or =XF86Mail=. These /keysyms/ can be found in
=/usr/include/X11/XF86keysym.h=. Many multimedia programs are designed
to work with these /keysyms/ out-of-the-box, without the need to
configure any third-party application.

Note that xmodmap is influenced by xkbd settings, so all eight keysym
are available for the us(intl) xkbd layout but not for the default us
(it is missing the ralt_switch symbol defined in level3). To have all 8
keysyms available you should configure the /(intl)/ variant of the
keyboard from xorg.conf or add, using us layout as an example,
=setxkbmap -layout 'us(intl)'= before calling xmodmap.

**** Custom table

To create a key map (i.e. =~/.Xmodmap=):

#+BEGIN_EXAMPLE
    $ xmodmap -pke > ~/.Xmodmap
#+END_EXAMPLE

To test the changes:

#+BEGIN_EXAMPLE
    $ xmodmap ~/.Xmodmap
#+END_EXAMPLE

***** Activating the custom table

With [[/index.php/GDM][GDM]], [[/index.php/XDM][XDM]],
[[/index.php/KDM][KDM]] or [[/index.php/LightDM][LightDM]] there is no
need to source =~/.Xmodmap=. For [[/index.php/Startx][startx]], use:

#+BEGIN_EXAMPLE
    ~/.xinitrc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    if [ -s ~/.Xmodmap ]; then
        xmodmap ~/.Xmodmap
    fi
#+END_EXAMPLE

Alternatively, edit the global startup script =/etc/X11/xinit/xinitrc=.

***** Test changes

To make temporary changes:

#+BEGIN_EXAMPLE
    $ xmodmap -e "keycode  46 = l L l L lstroke Lstroke lstroke"
    $ xmodmap -e "keysym a = e E"
#+END_EXAMPLE

**** Modifier keys

/xmodmap/ can also be used to override
[[https://en.wikipedia.org/wiki/Modifier_key][modifier keys]], e.g. to
swap =Control= and =Super= (the
[[https://en.wikipedia.org/wiki/Windows_key][Windows keys]]).

Before assignment the modifier keys need to be empty. =!= is a comment,
so only the modifiers =Control= and =Mod4= get cleared in the following
example. Then the /keysyms/ =Control_L=, =Control_R=, =Super_L= and
=Super_R= are assigned to the opposite modifier. Assigning both left and
right to the same modifier means that both keys are treated the same
way.

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [...]
    !clear Shift
    !clear Lock
    clear Control
    !clear Mod1
    !clear Mod2
    !clear Mod3
    clear Mod4
    !clear Mod5
    !add Shift   = Shift_L Shift_R
    !add Lock    = Caps_Lock
    add Control = Super_L Super_R
    !add Mod1    = Alt_L Alt_R
    !add Mod2    = Mode_switch
    !add Mod3    =
    add Mod4    = Control_L Control_R
    !add Mod5    =
#+END_EXAMPLE

*Note:* The example assumes that the =Control_L= and =Control_R= keysyms
were assigned to the =Control= modifier, and =Super_L= and =Super_R=
keysyms to the =Mod4= modifier. If you get the following error message
=X Error of failed request:  BadValue (integer parameter out of range for operation)=,
you will need to adapt accordingly. Running =xmodmap= produces a list of
modifiers and keys that are assigned to them.

The following example modifies =CapsLock= to =Control=, and
=Shift+CapsLock= to =CapsLock=:

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    clear lock
    clear control
    add control = Caps_Lock Control_L Control_R
    keycode 66 = Control_L Caps_Lock NoSymbol NoSymbol
#+END_EXAMPLE

**** Reverse scrolling

The
[[http://who-t.blogspot.com/2011/09/natural-scrolling-in-synaptics-driver.html][natural
scrolling]] feature available in OS X Lion (mimicking smartphone or
tablet scrolling) can be
[[https://bbs.archlinux.org/viewtopic.php?id=126258][replicated]] with
/xmodmap/. Since the synaptics driver uses the buttons 4/5/6/7 for
up/down/left/right scrolling, you simply need to swap the order of how
the buttons are declared in =~/.Xmodmap=:

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    pointer = 1 2 3 5 4 7 6 8 9 10 11 12
#+END_EXAMPLE

Then update /xmodmap/:

#+BEGIN_EXAMPLE
    $ xmodmap ~/.Xmodmap
#+END_EXAMPLE

**** Templates

***** Spanish

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    keycode  24 = a A aacute Aacute ae AE ae
    keycode  26 = e E eacute Eacute EuroSign cent EuroSign
    keycode  30 = u U uacute Uacute downarrow uparrow downarrow
    keycode  31 = i I iacute Iacute rightarrow idotless rightarrow
    keycode  32 = o O oacute Oacute oslash Oslash oslash
    keycode  57 = n N ntilde Ntilde n N n
    keycode  58 = comma question comma questiondown dead_acute dead_doubleacute dead_acute
    keycode  61 = exclam section exclamdown section dead_belowdot dead_abovedot dead_belowdot
    !Maps the Mode key to the Alt key
    keycode 64 = Mode_switch
#+END_EXAMPLE

***** Turn CapsLock into Control, and LeftControl into Hyper

Laptop users may prefer having =CapsLock= as =Control=. The =Left Hyper=
key can be used as a modifier.

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    clear      lock
    clear   control
    clear      mod1
    clear      mod2
    clear      mod3
    clear      mod4
    clear      mod5
    keycode      37 = Hyper_L
    keycode      66 = Control_L
    add     control = Control_L Control_R
    add        mod1 = Alt_L Alt_R Meta_L
    add        mod2 = Num_Lock
    add        mod3 = Hyper_L
    add        mod4 = Super_L Super_R
    add        mod5 = Mode_switch ISO_Level3_Shift
#+END_EXAMPLE

***** Switch every number key N with Shift-N and vice-versa, for Croatian
layout

Should work fine for layouts similar to Croatian as well.

#+BEGIN_EXAMPLE
    ~/.Xmodmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    keycode 10 = exclam 1 1 exclam asciitilde dead_tilde asciitilde
    keycode 11 = quotedbl 2 2 quotedbl dead_caron caron dead_caron
    keycode 12 = numbersign 3 3 numbersign asciicircum dead_circumflex asciicircum
    keycode 13 = dollar 4 4 dollar dead_breve breve dead_breve
    keycode 14 = percent 5 5 percent degree dead_abovering degree
    keycode 15 = ampersand 6 6 ampersand dead_ogonek ogonek dead_ogonek
    keycode 16 = slash 7 7 slash grave dead_grave grave
    keycode 17 = parenleft 8 8 parenleft dead_abovedot abovedot dead_abovedot
    keycode 18 = parenright 9 9 parenright dead_acute apostrophe dead_acute
    keycode 19 = equal 0 0 equal dead_doubleacute doubleacute dead_doubleacute
#+END_EXAMPLE

**** See also

- [[http://www.x.org/archive/current/doc/man/man1/xmodmap.1.xhtml][Current
   man page]] at X.Org Foundation
- [[http://cweiske.de/howto/xmodmap/allinone.html][Multimediakeys with
   .Xmodmap HOWTO]] by Christian Weiske
- [[http://dev-loki.blogspot.com/2006/04/mapping-unsupported-keys-with-xmodmap.html][Mapping
   unsupported keys with xmodmap]] by Pascal Bleser
- [[http://wiki.linuxquestions.org/wiki/List_of_Keysyms_Recognised_by_Xmodmap][List
   of Keysyms Recognised by Xmodmap]] on
   [[http://linuxquestions.org][LinuxQuestions]]

** Chrome                                                           :CHROME:
*** 下载文件命名编码

1. why?

   百度云打包下载的压缩文件命名正确，解压后出现乱码

2. 设置 chrome 字体编码

   http://jingyan.baidu.com/article/e52e36154b3ff640c70c515f.html
   http://www.tuicool.com/articles/VjInAf

   扳手-------->Settings（设置）-------->ShowAdvance Settings（显示高
   级设置）-------->Web Content（网页内容）-------->Customizefonts（自
   定义字体）-------->Encoding（编码）

3. 不是 chrome 的问题，是百度云的问题，没解决，不重要

   http://www.zhihu.com/question/28144692

*** [[http://segmentfault.com/a/1190000002438813][Edit with Emacs]]  :blog:

如果你用习惯了Emacs编辑器并经常使用它纂写各种文字和代码的话,
再使用网站内置的文字编辑器是不是会让你发狂呢? 不过还好, 有一款叫做Edit
with Emacs的Chrome插件可以解决,
它可以让Chrome在外部调用Emacs进行文字编辑.

Edit with Emacs for Chrome
[[https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonikaiipfkggjbhkghgicgoh][]][[https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonikaiipfkggjbhkghgicgoh][https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonik...]]
 Edit-Server for Emacs
[[http://github.com/stsquad/emacs_chrome][]][[http://github.com/stsquad/emacs_chrome]]

使用Chrome安装for Chrome的插件,
之后从Github下载Edit-Server到Emacs的插件目录,
然后在Emacs的配置文件中写入:

#+BEGIN_EXAMPLE
    (add-to-list 'load-path "~/.emacs.d/edit-servers")
    (require 'edit-server)
    (when (require 'edit-server nil t)
      (setq edit-server-new-frame nil)
      (edit-server-start))
#+END_EXAMPLE

之后在网站的编辑框下方就会有一个紫色的=edit=小图标,
点击它Chrome就会在外部调用Emacs进行编辑了, 非常方便.

另外Edit with Emacs还有根据网站网址自动转换编辑模式的功能, 比如:

#+BEGIN_EXAMPLE
    lisp(setq edit-server-url-major-mode-alist
          '(("github\\.com" . markdown-mode)
                    ("segmentfault\\.com" . markdown-mode)
                    ))
#+END_EXAMPLE

如此添加之后,
当我们在Github或者Segmentfault网站调用Emacs进行编辑的时候Emacs会自动切换为Markdown-mode.

PS: Edit with Emacs的原理是在Emacs里开启一个服务, 默认监听=9292端口=.
然后Chrome将文字发送给Emacs进行处理,
Emacs保存时在将编辑结果返回给Chrome. 如果Edit with
Emacs在你的电脑上不能正常工作, 那么可以检查下=9292端口=是否被占用.
你可以修改Edit-Server的默认端口, 然后从Chrome插件的选项里做相应修改即可.

*** Chrome: Edit with Emacs                                         :emacs:
+ http://www.emacswiki.org/emacs/Edit_with_Emacs
+ https://github.com/stsquad/emacs_chrome
+ http://segmentfault.com/a/1190000002438813


Edit with Emacs is an extension for Google's Chrome(ium) browser
family that allows you to edit text areas on your browser in a more
full featured editor. It does this in conjunction with an "Edit
Server" which services requests by the browser. T


使用Chrome安装for Chrome的插件, 之后从Github下载Edit-Server到Emacs的插
件目录, 然后在Emacs的配置文件中写入:
#+BEGIN_EXAMPLE
  (add-to-list 'load-path "~/.emacs.d/edit-servers")
  (require 'edit-server)
  (when (require 'edit-server nil t)
    (setq edit-server-new-frame nil)
    (edit-server-start))
#+END_EXAMPLE

之后在网站的编辑框下方就会有一个紫色的edit小图标, 点击它Chrome就会在外
部调用Emacs进行编辑了, 非常方便.
+ 绿色表示工作正常
+ 红色表示异常


另外Edit with Emacs还有根据网站网址自动转换编辑模式的功能, 比如:
#+BEGIN_EXAMPLE
  (setq edit-server-url-major-mode-alist
        '(("github\\.com" . markdown-mode)
                  ("segmentfault\\.com" . markdown-mode)
                  ))
#+END_EXAMPLE

如此添加之后, 当我们在Github或者Segmentfault网站调用Emacs进行编辑的时
候Emacs会自动切换为Markdown-mode.

PS: Edit with Emacs的原理是在Emacs里开启一个服务, 默认监听9292端口. 然
后Chrome将文字发送给Emacs进行处理, Emacs保存时在将编辑结果返回给
Chrome. 如果Edit with Emacs在你的电脑上不能正常工作, 那么可以检查下
9292端口是否被占用. 你可以修改Edit-Server的默认端口, 然后从Chrome插件
的选项里做相应修改即可.

*** NEXT XX-net                                    :xxnet:翻墙:switchomega:
:LOGBOOK:
- State "NEXT"       from ""           [2016-03-03 四 12:09] \\
  掌握了基本使用，接下来需要配置 appid （否则看视频受限制），但不急
:END:

**** Reference
- [[https://github.com/XX-net/XX-Net][GitHub]]
- [[https://github.com/XX-net/XX-Net/wiki/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3][Document]]
- [[https://github.com/FelisCatus/SwitchyOmega][GitHub:SwitchOmega]]

**** 缘由

购买的 VPN 失效，非常影响学习工作，烦心。

使用 Google 镜像，功能有限，而且慢、不稳定。

*** Wikipedia 打印                                        :Wikipedia:print:

1. 使用 XX-net 翻墙时, 只能在谷歌浏览器中实现代理, 像 wkhtmltopdf 则不
   能

2. Wikipedia 页面左边栏中有打印版, 切换后使用 Chrome 的打印功能, PDF
   效果也很好

** Ubuntu                                                           :ubuntu:
*** 桌面环境与桌面管理器                                       :desktop:de:


桌面环境: gnome, kde, lede
桌面管理器: unity, compiz

http://my.oschina.net/aspirs/blog/607710

GNOME、KDE、XFCE 叫做 DE 全称是 Desktop Environment，也就是桌面环境。
也就是一个整体的环境，包括应用程序、窗口管理器登录管理器，桌面程序，设
置界面等等等等。

unity 是一个桌面的界面。提供你看见的那些东西，但窗口的装饰和一些功能控
制的相关东西，他不提供，需要 compiz 来提供。

你要知道 Linux是一大堆程序组成的，桌面环境也是如此，其实你看到的 GNOME
的工具条，KDE 的 K 菜单面板，其实都是程序，你的桌面也一样，是一个程序
运行提供一个全屏幕的处在最底层的显示，窗口和桌面上的各种面板控件都在他
的上一层显示。

窗口管理器，是提供管理窗口显示隐藏，前后和大小的后台程序，这个才是和
X-server 真正进行交互控制的程序（Xorg 是程序，Linux 的是 C/S 结构）。
所以 compiz 这个东西可以实现窗口的特效。因为是由他告诉 X ，窗口大小，
层次关系和形状的，同时他也告诉被他管理的程序，他们的窗口大小，是否焦点，
是否显示隐藏等等的信息。metacity 并不会自己重新绘制窗口外观，只是忠实
的体现窗口本身的样子。compiz 会根据特效的设置，自己重新绘制窗口所在位
置的图像，告诉 Xorg 服务更多的绘制内容，实现诸如变形，半透明，窗口阴影
等等的特效。

你要是想研究桌面，最好去看看 LXDE ，这个东西是极简化的桌面环境，组成很
简单。

在我的理解上一般说来，可以工作的图形桌面，至少有一个会话程序，一个窗口
管理器，一个面板，一个桌面程序。

会话程序就是保证 X 的正常运行（Xinit 运行他，他就会一直保持运行，直到
你选择注销、重启、关机等等），提供启动另外三个或者更多个程序的运行，作
为他们的主进程。

窗口管理器就是管理所有平面上显示的东西，没有他就没有办法管理程序哪个是
当前操作的窗口，哪个窗口在前，哪个在后，窗口大小，是否隐藏，是否关闭退
出。面板就是你看到的哪个显示任务，的东西，没他你就没办法运行程序，提供
用户交互。桌面程序就是背景显示，的相关功能。

当然这 4 个东西不一定都要有，但是就像我前面说的，没有的话，那么对应的
功能就无法提供了。这些程序也可以整合，不一定非要分成4个，但这 4 部分的
功能却是必须要保证的，你可以用各种其他的方式实现。

你可以认为 unity 其实就是这四部分中的面板功能。而不提供窗口管理器的功
能，所以需要compiz或者metacity。

*** Ubuntu 桌面管理器                        :gnome:kde:lxde:unity:desktop:

http://www.ubuntukylin.com/ukylin/forum.php?mod=viewthread&tid=5458
https://linux.cn/article-3258-1.html
https://linux.cn/article-3432-1.html

=注意区分桌面环境与桌面管理器=

窗口管理工具是Linux桌面环境的重要组成部分，它可以直接影响到用户的窗口
外观、行为标示、应用程序运行/关闭等多个常用操作，也影响系统效率。

1. *Gnome*

   GNOME 是一种让使用者容易操作和设定电脑环境的工具，也是Linux发行版中
   运用最多的桌面环境之一。GNOME 包含了 Panel (用来启动此程式和显示目
   前的状态)、桌面 (应用程式和资料放置的地方)、及一系列的标准桌面工具
   和应用程式，并且能让各个应用程式都能正常地运作。不管你之前使用何种
   操作系统，你都能轻易地使用 GNOME 功能强大的图形接口工具。

   【转注】最新gnome-shell 3.x变化很大，体现了现代桌面的特性，当然消耗
   也高！

    [[~/Wally/Journal/Figure/.org-download/Journal/1294108860963_2016-02-24_16:41:53.jpg]]

2. *KDE*

   KDE是一款著名的运行于 Linux、Unix 以及FreeBSD 等操作系统上面自由图
   形工作环境，整个系统采用的都是 TrollTech 公司所开发的 Qt 程序库。它
   对于易用桌面的需求而不断探索，例如在 Mac OS 和微软的 Windows 那样的
   桌面环境。

   【转注】消耗较高！

#+DOWNLOADED: http://upload.newhua.com/1/06/1294108852843.jpg @ 2016-02-24 16:42:38
 [[~/Wally/Journal/Figure/.org-download/Journal/1294108852843_2016-02-24_16:42:38.jpg]]

3. *XFCE*

   XFCE的名气并不如前面两个老大哥响亮，但随着XFCE自身逐渐成熟，现在使
   用xfce作桌面的系统已经越来越多了，国外的Xubuntu GNU/Linux、SAM
   Linux Desktop和国内的lucky8k-veket都将xfce作默认的桌面窗口管理器。
   特点是主要由鼠标设定，而它的设定档对于普通用户是不透明的，上手比较
   简单。

   【转注】消耗较底！轻量级桌面环境。

#+DOWNLOADED: http://upload.newhua.com/a/32/1294108860963.jpg @ 2016-02-24 16:43:11
 [[~/Wally/Journal/Figure/.org-download/Journal/1294108860963_2016-02-24_16:43:11.jpg]]

4. Enlightenment (E17)

   E17是X Window系统下的一个窗口管理器。可单独应用，或者与桌面环境如
   GNOME，KDE等一起应用。Enlightenment经常作为桌面环境的替代品。

#+DOWNLOADED: http://upload.newhua.com/1/06/1294108852843.jpg @ 2016-02-24 16:43:34
 [[~/Wally/Journal/Figure/.org-download/Journal/1294108852843_2016-02-24_16:43:34.jpg]]

5. *LXDE* : LXDE 显然是桌面环境中最轻量级的选择

   LXDE是一个自由的桌面环境，旨在提供一个新的轻量、快速的桌面环境。相
   较于功能强大与伴随而来的膨胀性，LXDE注重于实用性和轻巧性，并且尽力
   降低其所耗系统资源。，各元件可独立运作，使用Openbox作为默认的窗口管
   理器。
   【转注】绝对轻量级DE，消耗最低，建议安装，一方不测！

#+DOWNLOADED: http://upload.newhua.com/d/20/1294108843217.jpg @ 2016-02-24 16:43:48
 [[~/Wally/Journal/Figure/.org-download/Journal/1294108843217_2016-02-24_16:43:48.jpg]]

6. Window Maker

   Window Maker是一款X11窗口管理器，其外观和使用感觉类似NeXTSTEP图像用
   户界面。 主要特点有支持ICCCM、可将软件视窗最小化为单一图示、与Gnome
   配合使用、内置个性化主题等。

#+DOWNLOADED: http://upload.newhua.com/2/b9/1294108835270.jpg @ 2016-02-24 16:44:11
 [[~/Wally/Journal/Figure/.org-download/Journal/1294108835270_2016-02-24_16:44:11.jpg]]

7. Fluxbox

   Fluxbox是一个基于GNU/Linux的轻量级图形操作界面，外观界面没有GNOME和
   KDE那样精美，但由于它的运行对系统资源和配置要求极低，所以它被安装到
   很多较旧的或是对性能要求较高的机器上，其菜单和相关配置被保存于用户
   根目录下的.fluxbox目录里，这样使得它的配置极为便利。

#+DOWNLOADED: http://upload.newhua.com/f/1a/1294108825970.jpg @ 2016-02-24 16:44:26
 [[~/Wally/Journal/Figure/.org-download/Journal/1294108825970_2016-02-24_16:44:26.jpg]]

8. AmiWM

   AmiWm是为Amiga喜爱者设计的window管理器。它模仿Amiga’s Workbench的
   外观，支持多屏幕，能象在Amiga中相同随意拖动屏幕，每个屏幕能有不同的
   背景。

#+DOWNLOADED: http://upload.newhua.com/a/f3/1294108815432.jpg @ 2016-02-24 16:44:36
 [[~/Wally/Journal/Figure/.org-download/Journal/1294108815432_2016-02-24_16:44:36.jpg]]

9. Sawfish

   Sawfish是可扩展的 Linux 窗口管理器，使用基于 Lisp 的扩展语言。所有
   窗口的修饰都是可配置的，并可通过 Lisp 来设置用户接口策略。

#+DOWNLOADED: http://upload.newhua.com/4/e6/1294108804826.jpg @ 2016-02-24 16:44:45
 [[~/Wally/Journal/Figure/.org-download/Journal/1294108804826_2016-02-24_16:44:45.jpg]]

10. IceWM

    IceWM是一个超小型的轻量级窗口管理器，其主要特点是迷你和高速，开发
    者充分考虑了速度、可用性和与系统结合的稳定性。

#+DOWNLOADED: http://upload.newhua.com/4/e6/1294108804826.jpg @ 2016-02-24 16:44:55
 [[~/Wally/Journal/Figure/.org-download/Journal/1294108804826_2016-02-24_16:44:55.jpg]]

*** Ubuntu 14.04 LTS: 定制 Unity                                    :unity:

虽然Unity桌面管理器自从伴随 Ubuntu 11.10首次发布以来表现出了强劲的性能，
并在可用性上迈进了一大步，但是有人对自定义其外观和行为所带的限制感到反
感。我们现在来看看如何自定义Unity，让你重拾自己掌控桌面的感觉。


**** Unity中的可用定制项目

在ubuntu 14.04中，Unity 有一些以前没有的可定制项。登入你的
Unity，进入“设置”并选择“显示”，你将看到以下画面：

#+DOWNLOADED: https://dn-linuxcn.qbox.me/data/attachment/album/201407/19/214927wplpzfzepl17noog.png @ 2016-02-24 16:50:01
 [[~/Wally/Journal/Figure/.org-download/Journal/214927wplpzfzepl17noog_2016-02-24_16:50:01.png]]

Ubuntu 14.04 LTS 显示和 Unity 设置

你看到的大多数项目相比 Ubuntu 11.01
而言都是新的，而且一些相比较上一个版本的 Ubuntu13.10
也是新的。从Ubuntu13.10开始，Ubuntu加入了可以改变菜单栏和标题栏大小的新特性。

Unity中所特有的一个特性是我们能够打开或者关闭的“粘性边缘”功能，它能让你的鼠标停止在多显示器组的每个屏幕的边缘，它使光标暂时停在边缘，仿佛是鼠标卡住了一样，我们可以选择关闭它。（LCTT译注，其实我觉得挺有用的，可以避免无意中切换到其他工作桌面，不要关闭）

在“设置”中选择“外观”选项，可以看到如下画面。

#+DOWNLOADED: https://dn-linuxcn.qbox.me/data/attachment/album/201407/19/214937kbji4e16jdnbnr66.png @ 2016-02-24 16:50:13
 [[~/Wally/Journal/Figure/.org-download/Journal/214937kbji4e16jdnbnr66_2016-02-24_16:50:13.png]]

Ubuntu 14.04 LTS 显示和Unity设置

这里我们可以看到一个人们最渴望在 Unity
启动器栏中包含的功能-能够改变启动器大小。虽然在Ubuntu
11.10及以后的各种版本中可以通过多种方法实现这个特性，但将其放入外观设置中使其显得更加正式。我喜欢它能将启动器图标缩小直至16的功能（我们接下来所要讲到的工具仅能支持最小调至24）。

**** Unity Tweak Tool-强大!

在Unity首次伴随Ubuntu
11.10发布的几天之内这款工具就跟着出现了，只是你得大费周折去自己把它安装好而且在Unity升级时它可能会损坏。

然而现在它被正式添加进了Ubuntu的默认软件仓库并且会在Unity更新时同时更新。它附带大量的定制项，那么我们就来安装它吧：

#+BEGIN_EXAMPLE
    sudo apt-get install unity-tweak-tool
#+END_EXAMPLE

安装好，启动后你将看到如下画面：

#+DOWNLOADED: https://dn-linuxcn.qbox.me/data/attachment/album/201407/19/214940hlc690qq06ts6ceq.png @ 2016-02-24 16:49:45
 [[~/Wally/Journal/Figure/.org-download/Journal/214940hlc690qq06ts6ceq_2016-02-24_16:49:44.png]]

正式的Unity Tweak Tool

这款工具它集大量Unity桌面定制项目于一体。这些定制项大多能通过默认的Unity设置，命令行操作或者是即使是编辑有时候也很难寻找到的配置文件来实现。

我们可以改变启动器栏，网页小程序和面板的行为，可以在Unity菜单中搜索等等。所有的都通过着一个工具来实现。花些时间去挖掘适合你的选项-Unity
Tweak Tool-学习它，和它一起生活，爱上它（如果你使用Unity，这是起码的）

**** 结尾的一些想法

Ubuntu 14.04 LTS 越来越被人们视作Linux上的典型的Desktop，（对不起，
Canonical，你还没有摆脱Linux身份），Linux Desktop不仅可以作为偶尔使用
Linux的那些人（的确有这样的事）的选择，也适用于骨灰级linux专家。

比之前没有工具，功能可以定制，或是通过配置文件修改定制但是有可能被之后
个更新所破坏，现在对于Unity桌面我们就拥有了更多的控制权。Unity桌面性能
强劲可靠，又通过Unity

Tweak Tool加入一些特色元素，使得它的外观也酷极了!!!

请给我们你的想法或者点击链接发表你对Unity桌面的评论，我们将有兴趣知道
你是如何使用Ubuntu 14.04 LTS 的。

*** 查看 Linux 发行版本号                            :kernel:version:uname:

http://yp.oss.org.cn/blog/show_resource.php?resource_id=1058

最近碰到一个问题，在Linux终端下怎么查看当前操作系统是什么，版本是什么。
不同的Linux发行版不完全一样，查了一些资料现在总结如下。有以下命令可以
查看：

*第一种方法： lsb_release*

#+BEGIN_EXAMPLE
# lsb_release -a
#+END_EXAMPLE

#+BEGIN_EXAMPLE
LSB Version:    :core-4.0-ia32:core-4.0-noarch:graphics-4.0-ia32:graphics-4.0-noarch:printing-4.0-ia32:printing-4.0-noarch
Distributor ID:    CentOS
Description:    CentOS release 5.7 (Final)
Release:    5.7
Codename:    Final
#+END_EXAMPLE

/test in ubuntu 15.04/
#+BEGIN_EXAMPLE
  wally@ ~ $ lsb_release -a
  No LSB modules are available.
  Distributor ID: Ubuntu
  Description:    Ubuntu 15.04
  Release:        15.04
  Codename:       vivid
#+END_EXAMPLE

这个命令适用于所有遵守LSB规范的的linux，包括Redhat、SuSE、Debian、
Ubuntu、Centos等发行版。

接下来的命令 *uname* 虽不能查看当前系统名和版本，但可以显示系统核心信
息。

/test/
#+BEGIN_EXAMPLE
wally@ ~ $ uname
Linux
wally@ ~ $ uname -a
Linux wally 3.19.0-49-generic #55-Ubuntu SMP Fri Jan 22 02:10:24 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
#+END_EXAMPLE

*以下二种方法适用于RedHat,CentOS*

#+BEGIN_EXAMPLE
root@MyMail ~ # cat /etc/redhat-release
CentOS release 5.7 (Final)
#+END_EXAMPLE

登录到linux执行rpm -q redhat-release

#+BEGIN_EXAMPLE
#rpm -q redhat-release
或CentOS

root@MyMail ~ # rpm -q centos-release
centos-release-5-7.el5.centos.1
#+END_EXAMPLE

第四种方法：

当前centos 版本与redhat对应的版本的命令

这个命令在centos下并不准确，显示的系统和版本也是Red Hat 3.4.6-10。

#+BEGIN_EXAMPLE
# cat /proc/version
Linux version 2.6.9-78.ELsmp (mockbuild@builder16.centos.org) (gcc version 3.4.6 20060404 (Red Hat 3.4.6-10)) #1 SMP Fri Jul 25 00:04:28 EDT 2008
#+END_EXAMPLE

而此命令在Ubuntu上使用，显示中智能看出是Ubuntu，但看不出版本。

最后一种方法： 系统文件

#+BEGIN_EXAMPLE
#cat /etc/issue
#+END_EXAMPLE

在CentOS下执行显示为：

#+BEGIN_EXAMPLE
CentOS release 5.7 (Final)
Kernel \r on an \m
#+END_EXAMPLE

或在Ubuntu下显示为：

#+BEGIN_EXAMPLE
Ubuntu 11.04 \n \l
#+END_EXAMPLE

/test/

#+BEGIN_EXAMPLE
wally@ ~ $ cat /etc/issue
Ubuntu 15.04 \n \l

#+END_EXAMPLE

可以查看当前正在运行的 Ubuntu 的版本号。

*** Ubuntu Windows 双系统，硬盘安装                        :双系统:install:

**** windows 配置

1. 下载镜像文件
   - Ubuntu 64位(乌班图系统) v12.04.1 官方原版iso镜像：http://www.33lc.com/soft/18055.html
   - Ubuntu(乌班图系统) v12.04.1 官方原版iso镜像： http://www.33lc.com/soft/18053.html

2. 下载并安装easybcd。

   easybcd是一款很优秀的系统引导软件，功能强大，最关键的是傻瓜式一站式
   简易操作，极其适合新手使用!

3. 新建分区

   腾出一个空盘，点击右键格式化之后把它删除(这个盘最好是在硬盘的后面，
   因为Windows系统不能识别Linux系统分区，如果将ubuntu装在D盘，将D盘删
   除并建立Linux系统分区后，原来的E盘就会变成D盘，安装在E盘的软件会出
   现系统注册表路径不对称，要重新安装一遍软件)。网上很多说使用磁盘压缩
   功能以整理出空白分区，这个方法也可行，但这个盘要保证有10G空间以上比
   较稳妥。

4. 安装好easybcd2.1.2后，启动软件

   #+DOWNLOADED: http://www.33lc.com/article/UploadPic/2012-8/20128241427190206.jpg @ 2016-01-10 14:16:48

   [[~/Wally/Journal/Figure/.org-download/Journal/20128241427190206_2016-01-10_14:16:48.jpg]]

   按照上图的序号依次点击“Add New Entry”——“Neo Grub”——“Install”，
   点到“Install”后出面下面的界面，再点“Configure”。

   点击“Configure”按钮后，会出现一个记事本文件，将下面的代码粘贴到文
   件尾部：

   #+BEGIN_EXAMPLE
     title Install Ubuntu 12.04 LTS
     root (hd0,6)
     kernel (hd0,6)/vmlinuz boot=casper iso-scan/filename=/ubuntu-12.04-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8
     initrd (hd0,6)/initrd.lz
   #+END_EXAMPLE

   上图代码中“ubuntu-12.04-desktop-amd64.iso”为你下载的ubuntu 12.04
   系统镜像文件名，这个文件名是可以修改的，但修改的名字一定要与写入的
   代码名字一致，否则将无法引导安装;

   (hd0,6) 表示磁盘分区，hd(0,0), hd(0,1), hd(0,2), hd(0,3)表示主分区，
   (hd0,4)以后的表示逻辑分区，现在我只有一个主分区C盘，则(hd0,0)表示C
   盘，(hd0,4)表示D盘，(hd0,5)表示E盘，(hd0,6)表示F盘，我的镜像就是放
   在F盘里，请把(hd0,6)改成自己对应的分区)

5. 将下载的镜像文件放到(hd0,N)盘的根目录下，并确保文件名与上面写入的代
   码的文件名一致为ubuntu-12.04-desktop-amd64.iso，然后用WinRAR解压缩
   软件将iso打开，将casper文件夹目录下的vmlinuz和 initrd.lz解压并复制
   到(hd0,N)盘根目录下。准备工作至此已全部完成!!!

**** Ubuntu 安装

1. sudo umount /isodevice

2. /usr/local 或 /opt 可以单独挂载一个分区

**** Windows 下删除 Ubuntu 分区导致系统无法启动（引导程序失败）     :grub:

- [[http://zhidao.baidu.com/question/495728786.html?fr=ala&word=grub%20rescue%E5%88%A0%E9%99%A4ubuntu&device=mobile&ssid=0&from=2001a&uid=0&pu=usm@0][百度知道]]

装了ubuntu后，会默认从Ubuntu的Grub菜单引导系统，Win8的MBR被替换为Grub
来引导。

于是，你删除了Ubuntu，也就是删除了Grub的文件。但是，你的引导扇区的启动
参数还是指向了Grub，于是就grun rescue了。。。

*解决方法*

用PE启动，打开WinPM或者DiskGen，找到一个叫重建主引导记录（MBR）的东西，
重建一下就好了，记得把Windows分区设置为活动！

*** 书签                                                         :bookmark:
**** [[http://people.ubuntu.com/~happyaron/ubuntu-docs/precise-html/nautilus-bookmarks-edit.html][编辑文件夹书签]]                                                 :blog:

您的书签列在文件管理器的书签菜单中。

***** 删除书签：

1. 依次单击书签 ▸ 编辑书签。

2. 在编辑书签窗口中，选中要删除的书签，然后单击删除。

3. 单击关闭。

***** 添加书签：

1. 打开要对其添加书签的文件夹(或位置)。

2. 依次单击书签 ▸ 添加书签。

***** 重命名书签：

1. 依次单击书签 ▸ 编辑书签。

2. 在编辑书签窗口中，选中要重命名的书签。

3. 在名称文本框中，为该书签输入新名称。

   重命名书签不会重命名文件夹。如果有指向位置不同的两个不同文件夹的书签，但书签和相应文件夹的名称都相同，则两个书签的名称会相同，而且不能将两者区分开。这种情况下，让书签的名称不同于所指向的文件夹的名称会很有用。

**** Ubuntu 文件管理器 书签                                     :bookmark:
c-d
c-b

书签-> 添加

*** .gvfs                                                      :gvfs:gnome:
- State "DONE"       from "TODO"       [2015-12-08 二 13:18]

**** why

#+BEGIN_EXAMPLE
  roslaunch j[rospack] Warning: error while crawling /home/ben:
  boost::filesystem::status: Permission denied: "/home/ben/.gvfs"
#+END_EXAMPLE

**** [[http://www.cnblogs.com/tdyizhen1314/p/4142991.html][error: failed to stat /home/dade/.gvfs: Permission denied]]

表面上看：好像是权限不够，于是准备使用chmod -R 777 .gvfs 修改权限，可
让你惊讶的是，root用户下也不行，给出的报告是：

#+BEGIN_EXAMPLE
chmod：cannot access '.gvfs': Permission denied.
#+END_EXAMPLE

是不是很神奇，我可是root用户呢！于是使用ls -a -l查看文件的属性，如下

#+BEGIN_EXAMPLE
d?????????  ? ?    ?        ?                ? .gvfs
#+END_EXAMPLE

完全不知啊！于是想着能不能把这文件删掉呢？或者删掉后对系统会有影响吗？
而且该怎么删呢，直接使用rm，结果证明直接rm是错误的。

重新更改删除方案，如下：
1) umount .gvfs
2) rm -rf .gvfs

**** [[http://zhidao.baidu.com/share/342cd184f745024170cf0790202febaa.html][gvfs: Gnome Virtual File System]]

GVFS是 /GNOME/ 桌面系统的 /虚拟文件系统/ ，通过GVFS，用户可以很容易的
通过SFTP、FTP、WebDAV、SMB等访问 /远程数据/ ，通过HAL integration、OBEX等
访问本地数据。

GVFS附加资源通过URI语法进行解析，如：smb://server01/gamedata或者
ftp://username:password@ftp.example.net/public_html， 同时，也可以采用
传统方式进行挂载， *通常挂载到~/.gvfs/* ，通过mount来使得旧的应用程序使用
标准POSIX命令和I/O。

GVFS使用FUSE（Filesystem in Userspace），用来取代早期的GnomeVFS。它由
两部分组成：一个由应用程序支持的GIO载入的共享库和GVFS本身（包含一个互
相通信的进程集合与基于D-Bus的GIO模块）

到2010年12月，113个注册GNOME组件中的107个已经移植到GIO（GVFS URI支持）。
目前有一个命令行工具集（包括gvfs-mount，gvfs-less等）来管理VFS资源。

*** fonts                                                            :font:
**** 文泉驿
+ http://wenq.org/wqy2/index.cgi

#+BEGIN_EXAMPLE
  $ apt-cache search wenquanyi

  ,#+results:
  fonts-wqy-microhei - Sans-serif style CJK font derived from Droid
  fonts-wqy-zenhei - "WenQuanYi Zen Hei" A Hei-Ti Style (sans-serif) Chinese font
  xfonts-wqy - WenQuanYi Bitmap Song CJK font for X
#+END_EXAMPLE


文泉驿微米黑就适合了, 不要太折腾.

apt方式安装字体也并没有什么不好.

**** 字体
***** Font

https://wiki.archlinux.org/index.php/Fonts_\%28\%E7\%AE\%80\%E4\%BD\%93\%E4\%B8\%AD\%E6\%96\%87\%29#mw-content-text

1. 计算机字体(*font*),简称字体(font),是包含一套字形和字符的数据文件.

2. 字体类型
   + 点阵字体
   + 矢量字体

   + serif: 衬线字体，适合打印。
   + sans-serif: 无衬线字体，适合电脑屏幕阅读。
   + monospace: 等宽字体
     注:中文显示的方式不同,中文本身拥有的横和相同的高度已然具有平齐效
     果.行距对中文更重要。

3. 常见格式
   + bdf, bdf.gz -- 点阵字体,Bitmap Distribute format位图
   + pcf, pcf.gz -- 点阵字体,Portable Compiled Font可移植
   + psf, psfu, psf.gz, psfu.gz -- 点阵字体, PC Screen Font Unicode
   + pfam, pfb -- 矢量字体
   + ttf -- TrueType
   + otf -- OpenType
   + 排版程序\TeX{}和配套的字体软件Metafont用它们自己的方法渲染字体,后
     缀为*pk, *gf, mf与vf.

4. 字体安装

   将字体移动到文件夹下,然后更新fontconfig的字体缓存
   + 系统: /usr/share/fonts
   + 用户: ~/.local/share/fonts

***** Times New Roman
http://zh.wikipedia.org/wiki/Times_New_Roman

Times New Roman（泰晤士新罗马）可能是最常见且广为人知的衬线字体之一，
在字体设计上属于过渡型衬线体，对后来的字型产生了很深远的影响。另外由于
其中规中矩、四平八稳的经典外观，所以经常被选择为标准字体之一。

《泰晤士报》首次采用了Times New Roman后，这个优秀的字型很快地博得了大
众的青睐，获得了极大的成功。之后尽管泰晤士报已不再使用Times New Roman，
但Times New Roman已成为经典字型之一，迄今仍广泛使用在图书、杂志、报告、
公文、广告、屏幕显示等等。

在电脑方面，现在很多应用程序，还有网页浏览器和文字处理软件都是用它作为
默认字体。

方正公司的方正小标宋、方正宋三字体的英文部分也使用Times New Roman（但
是方正宋三字体中阿拉伯数字使用的是Bodoni MT字体）

*** fcitx                                                           :fcitx:

**** installation                                                :install:

1. 第一步：缷载ibus
   + sudo apt-get remove ibus
   + 重启ubuntu

2. 第二步：安装fcitx五笔拼音
   + sudo add-apt-repository ppa:wengxt/fcitx-nightly
   + sudo apt-get update
   + sudo apt-get install im-switch fcitx
   + sudo apt-get install fcitx-table-wbpy
   + sudo im-switch -s fcitx
   + im-switch -s fcitx  ( *im-config*)
   + 重启ubuntu

3. 注
   + 使用fcitx五笔拼音，虽然Rime名声很好，但是太折腾.
   + ibus会导致开机启动时交换Ctrl与Cap键失效.

**** fcitx 启动不了                                                :error:

#+BEGIN_EXAMPLE
  $ fcitx &


  (INFO-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/addon.c:151) 加载附加组件配置文件: fcitx-vk.conf
  (WARN-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/addon.c:298) 禁用插件 fcitx-ipc，依赖 fcitx-dbus 无法满足。
  (ERROR-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/frontend.c:565) 无可用前端
  (ERROR-7419 /build/buildd/fcitx-4.2.8.5/src/lib/fcitx/instance.c:437) Exiting.
#+END_EXAMPLE

- 原因： 配置错误
- 解决：删除配置文件

  #+BEGIN_EXAMPLE
     mv ~/.config/fcitx ~/.config/fcitx.bak
  #+END_EXAMPLE

- 暴力解决(不推荐)

  #+BEGIN_EXAMPLE
    $ sudo dpkg -P fcitc*
    $ sudo apt-get install fcitx
  #+END_EXAMPLE

**** ibus                                                           :ibus:

http://wiki.ubuntu.org.cn/IBus

IBus 全称 Intelligent Input Bus是下一代输入法框架（或者说“平台”）。
项目现托管于 Google Code - https://code.google.com/p/ibus/ 此项目包含
了世界多数语言的文字输入需求——由世界多个国家开发者维护。

Ubuntu中文输入法IBUS的安装

第一：安装IBus框架，
#+BEGIN_EXAMPLE
$ sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4
#+END_EXAMPLE
启动IBus框架，在终端输入：
#+BEGIN_EXAMPLE
$ im-switch -s ibus
#+END_EXAMPLE
安装完IBus框架后注销系统，保证更改立即生效。

第三步：安装拼音引擎

有下面几种常用选择：
+ IBus拼音：sudo apt-get install ibus-pinyin
+ IBUS五笔：sudo apt-get install ibus-table-wubi
+ 谷歌拼音输入法：sudo apt-get install ibus-googlepinyin
+ Sun拼音输入法：sudo apt-get install ibus-sunpinyin

第四步：设置IBus框架

#+BEGIN_EXAMPLE
$ ibus-setup
#+END_EXAMPLE

设置IBUS

第五步：通常情况下，IBus图标（一个小键盘）会出现在桌面右上角的任务栏中。
有时候这个图标会自行消失，可使用以下命令，找回消失的IBus图标：
#+BEGIN_EXAMPLE
$ ibus-daemon -drx
#+END_EXAMPLE

**** rime                                                          :rime:中州韵:

参考:
+ HOMEPAGE：https://code.google.com/p/rimeime/wiki/Downloads
+ Wiki：http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%B7%9E%E9%9F%BB%E8%BC%B8%E5%85%A5%E6%B3%95%E5%BC%95%E6%93%8E
+ http://tieba.baidu.com/p/2123383997
+ http://www.douban.com/note/282213725/
+ http://tieba.baidu.com/p/1748128802  切换半角


中州韵输入法引擎（英语：Rime Input Method Engine，又称Rime输入法）是由
佛振编写的开源中文输入法，目前项目网站、源代码均托管在GitHub[注 1]。
基于同一个核心架构，该输入法分为三个发布版：Linux发布版中州韵
（ibus-rime，另有 fcitx-rime）、Windows发布版小狼毫（Weasel）、OS X发
布版鼠须管（Squirrel）。



***** ibus rime
http://tieba.baidu.com/p/3064088726

1. 简要

   将rime输入法平台嵌入到ibus中（完成后会带有明月拼音，仓颉，当然还可
   以自行添加其它的）；然后导入山人全息码的码表到rime中（我已经打磨好
   了）。

2. 扩展
   1) rime

      面象中文的开源输入法。
      + 项目主页：baidu.com https://code.google.com/p/rimeime/
      + 贴吧：http://tieba.baidu.com/f?kw=rime

   2) 山人全息码（形码）

      贴吧：
      http://tieba.baidu.com/f?kw=%C9%BD%C8%CB%C8%AB%CF%A2%C2%EB&fr=itb_favo&fp=favo

3. 安装ibus-rime
   三步走：
   #+BEGIN_EXAMPLE
     sudo add-apt-repository ppa:lotem/rime
     sudo apt-get update
     sudo apt-get install ibus-rime
   #+END_EXAMPLE
   注销；然后进入ibus文字输入设定中将rime加入到活动列表。

**** [[http://blog.sina.com.cn/s/blog_578fb7710101m90d.html][ubuntu安装fcitx五笔拼音输入法 ]]                                 :blog:

根据网络资料整理，参考：
http://gongstring.iteye.com/blog/1392151
http://cyanman.blog.163.com/blog/static/1525020820111196433790/

第一步：缷载ibus
sudo apt-get remove ibus
重启ubuntu

第二步：安装fcitx五笔拼音
sudo add-apt-repository ppa:wengxt/fcitx-nightly
sudo apt-get update
sudo apt-get install im-switch fcitx
sudo apt-get install fcitx-table-wbpy
sudo im-switch -s fcitx
im-switch -s fcitx
重启ubuntu

其它参考：
     1，不希望使用一大堆用不着的输入法，可以关闭它：
        $sudo gedit /usr/share/fcitx/data/tabels.conf
     把里面不要的输入法整段删除，至于双拼可以在下面说的config 里关闭
     2，在打字时要输入,.号经常按不出来，可以这样：
     ~/.fcitx 目录下有一个 config 文件（启动至少一次fcitx 才会自动建立）可以配置翻页键把里面的 ,. 二个删除，不然在出联想时打不出,. 号
     3，不想让它一直显示在那，可以这样：
     ~/.fcitx 目录下有一个 config 文件可以配置 代码:
     主窗口隐藏模式=1
     4，在英文local 下 fcitx 打出的字全方块，可以这样：
     修改上面说的这个config 里的 代码:
     显示字体(中)=字体名
     5，使用ctrl+左shift键可以切换输入方案
     6，其它应用技巧可以到fcitx的主页下载其最新版的使用说明书（pdf文档）。
中文简繁转换：ctrl+shift+f

*** Emacs Keybindings in Gnome
+ http://jblevins.org/log/emacs-keys
+

**** gconf-editor
Once upon a time, Gnome provided a way to enable Emacs-style keyboard
shortcuts for editing text fields through the Keyboard Shortcuts
preferences dialog. These shortcuts are incredibly useful when editing
text in web forms, such as when editing a Wiki. Unfortunately, in
trying to simplify the Gnome interface (for better or worse), this
option has been removed. Luckily (as of Gnome 2.16.1) it can still be
enabled through gconf by running gconf-editor, and changing the
/desktop/gnome/interface/gtk_key_theme key to Emacs.

**** gnome-tweak-tools
key-theme-emacs
**** gconf-2

*** 交换 CapsLock 和 Ctrl 键                                  :capslock:ctrl:
**** reference

- http://tuhdo.github.io/emacs-tutor.html
- http://www.kodiva.com/post/swapping-caps-lock-and-control-keys
-
  http://askubuntu.com/questions/412576/swap-caps-lock-and-ctrl-in-ubuntu-13-10/412622#412622

**** windows: 通过修改注册表

In our opinion this is the best way to swap the control and caps lock
keys in Windows because you don't have to rely on any external program
and the registry edit works 100% perfectly (for the paranoid).

Why should one bother changing the caps lock and control keys, what's
wrong with the control key where it is? After extensive testing, our
conclusion is that - if you use the control key a lot (like in Emacs or
Vim), then you should definitely swap the control and caps lock keys as
it's extremely ergo-dynamic to have the control key in the home row.

1. Click Start -> Run

2. Type: regedit, and click OK

3. Go to: HKEY_LOCAL_MACHINE -> System -> CurrentControlSet -> Control
   -> KeyBoard Layout

   Note: *KeyBoard Layout*, and not KeyBoard Layouts

4. Right-click: Keyboard Layout, and select New -> Binary value

5. Rename: New Value #1 -> Scancode Map

6. Right click: Scancode Map -> Modify
   #+BEGIN_EXAMPLE
     0000  00 00 00 00 00 00 00 00
     0008  03 00 00 00 1d 00 3a 00
     0010  3a 00 1d 00 00 00 00 00
     0018
   #+END_EXAMPLE

7. Close regedit and restart your computer

**** Linux

+ http://askubuntu.com/questions/412576/swap-caps-lock-and-ctrl-in-ubuntu-13-10/412622#412622
+ http://www.2cto.com/os/201306/222522.html


1. gnome-tewak-tool

   Gnome tweak tool is a tool to customize advanced GNOME 3 options.
   #+BEGIN_EXAMPLE
     $ sudo apt-get install gnome-tweak-tool
     $ gnome-tweak-tool
   #+END_EXAMPLE
   注:有时会出bug不起效用,不知为何.

2. xmodmap
   1) 建立一个新文件: ~/.Xmodmap,添加以下内容:
      #+BEGIN_EXAMPLE
        remove Lock = Caps_Lock
        remove Control = Control_L
        keysym Control_L = Caps_Lock
        keysym Caps_Lock = Control_L
        add Lock = Caps_Lock
        add Control = Control_L
      #+END_EXAMPLE

   2) 执行
      #+BEGIN_EXAMPLE
        $ xmodmap ~/.Xmodmap 2>/dev/null
      #+END_EXAMPLE

   3) 如果不想每次启动都手动输入命令，可以把命令写到~/.xinitrc中。
      注: 如果把命令写到~/.bashrc中，每次新开一个终端或tab上述命令都会
      被执行一次，这样键位又换回来了。

   4) note: *fcitx 的某些配置会影响到xmodmap(Ubuntu 15.04)*

3. setxkbmap
   #+BEGIN_EXAMPLE
     $ setxkbmap -option ctrl:swapcaps
   #+END_EXAMPLE
   可以把该命令写在~/.bashrc中,重复执行并不影响.

**** fcitx 切换输入法与 xmodmap 冲突

使用 gnome-tweak 解决

*** [[http://www.2cto.com/os/201306/222522.html][交换ctrl和caps lock]] :blog:

交换ctrl和caps lock

因为ctrl键在笔记本键盘的左下角，对于经常使用ctrl键的人来说是个痛苦的事情。在网上搜了下有几种交换键位的方法，在这里记录一下。

第一种方法是使用xmodmap。建立一个新文件~/.Xmodmap，添加以下内容：

remove Lock = Caps_Lock
remove Control = Control_L
keysym Control_L = Caps_Lock
keysym Caps_Lock = Control_L
add Lock = Caps_Lock
add Control = Control_L
然后执行

xmodmap ~/.Xmodmap 2>/dev/null
就行了。如果不想每次启动都手动输入命令，可以把命令写到~/.xinitrc中。注意如果把命令写到~/.bashrc中，每次新开一个终端或tab上述命令都会被执行一次，这样键位又换回来了。

另一种方法是使用setxkbmap命令。只需执行下面的命令：

setxkbmap -option ctrl:swapcaps
就行了。而且可以把命令放到~/.bashrc中，重复执行并不影响。

(2012.07.02更新)在gnome中可以通过图形界面选项调整。打开 系统 -> 首选项 -> 键盘 -> 布局 -> 选项… -> Ctrl key position，选择”Swap Ctrl and CapsLock”即可。

除了交换ctrl和caps lock外也有和alt互换的，这样就可以用两个拇指分别按ctrl和alt(交换右ctrl和alt)：

remove mod1 = Alt_R
remove Control = Control_R
keysym Control_R = Alt_R
keysym Alt_R = Control_R
add mod1 = Alt_R
add Control = Control_R
为什么会想到要交换ctrl键呢？因为某天在网上闲逛的时候，无意中看到这篇文章，顿时热血沸腾，心想左手vim右手emacs是多么拉风的事情。为了表明自己学习的决心，装上emacs的同时也把相伴5年的vim给卸了。磕磕碰地碰用了几个星期，最深的感触是左手小指太辛苦了，即使是把ctrl和caps lock交换，一天下来小指也是又累又痛，于是又灰溜溜地用回vim了。想学习emacs的朋友如果觉得没有动力的话可以看看上面提到的文章，一直在用vim的或者没用过这两者的也建议尝试一下，说不定你就爱上它了。即使可能被吓退，但是相信会从学习过程中收获不少，例如可以在vim里模拟几个emacs移动定位的快捷键，对于输入法切换或输入括号和引号等成对出现的字符时就很方便：

" emacs-style key bindings
inoremap <C-a> <C-o>^
inoremap <C-b> <left>
inoremap <C-d> <del>
inoremap <C-e> <C-o>$
inoremap <C-f> <right>
inoremap <C-g> <esc>
inoremap <C-k> <C-o>D
inoremap <C-n> <down>
inoremap <C-p> <up>
inoremap <C-t> <esc>xpi
inoremap <C-y> <esc>pa
更夸张一点的还把右ctrl和enter给换了，毕竟在emacs中用ctrl的时候很多，而且enter可以用ctrl-m和ctrl-j代替，这样两只手的小指可以左右开弓。

*** 新得立

*** Management
**** 启动项

+ acpi-support 这个是关于电源支持的默认是1,2,3,4,5下启动，我认为你可以
  把它调整到s级别。

+ acpid acpi的守护程序，默认是2－5开启，我认为可以不用管。

+ alsa alsa声音子系统，应该不用开启它。

+ alsa-utils 这个服务似乎取代了alsa，所以开启这个就可以了，我在S级别开
  启它。

+ anacron 这是一个用于执行到时间没有执行的程序的服务，我认为它无所谓，
  所以关了它，这个可以随便。

+ apmd 也是一种电源管理，我认为电脑如果不是很老，它就没有开启的必要了。

+ atd 和anacron类似，我把它关了。

+ bluez-utiles 传说中的蓝牙服务，然后遗憾我没有，所以关了。

+ bootlogd 似乎使用来写log的，安全期间开着他也许比较好。

+ cron 指定时间运行程序的服务，所以开着比较好的。

+ cupsys 打印机服务，所以如果你有，就开启吧。

+ dbus 消息总线系统，非常重要，一定要开。

+ dns-clean 拨号连接用的，如果不用，就关了它。

+ evms 企业卷管理系统，由于我并不明白什么叫做企业卷，所以我关了它。

+ fetchmail 用于邮件守护，我关了它。

+ gdm gnome桌面管理器，我关了它，然后用startx启动gnome。

+ halt 关机用的，不要更改

+ hdparm 这个我刚才有讲，如果没有ide硬盘也就不用开启它了。

+ hotkey-setup 这个是给某些品牌笔记本设计的热键映射，台式机用户请关了
  它

+ hotplug 这个是用于热插拔的，我已经测试过了，在某些电脑上关闭它会使声
  卡无效，请在S级别开启它。

+ hplip hp打印机专用的，应该可以关了它。

+ ifrename 网络接口重命名，好像没用，关了。

+ ifupdown 这个使用来打开网络的，开着它。

+ ifupdown-clean 同上。

+ klogd linux守护程序，接受来自内核和发送信息到syslogd的记录，并记录为
  一个文件，所以请开着它。

+ linux-restricted-modules-common 这个使用来使用受限制的模块的，你可以
  从/lib/linux-restricted-modules下查看，如果没有什么，你可以关掉它。

+ lvm 逻辑卷管理器，如果你没有请关了它。

+ makedev 用来创建设备到/dev/请不要动他。

+ mdamd 管理raid用，如果你没有请关闭它。

+ module-init-tools 从/etc/modules 加在扩展模块的，这个一般开着。

+ networking 增加网络接口和配置dns用，将它开启。

+ ntp-server 与ubuntu时间服务器进行同步的，关了。

+ pcmcia 激活pcmica设备，遗憾我有生以来都没有见过这样的设备，关了它。

+ powernowd 用于管理cpu的客户端程序，如果有变频功能，比如amd的quite'
  cool 那么就开启它吧。

+ ppp 拨号用的，我关了它。

+ ppp-dns 一样，也关了。

+ readahead 预加载服务，让我想起了win的预读，当然他们不同，它会使启动
  变慢3－4妙，所以我关了它。

+ reboot 重启用的，不要动。

+ rmnologin 如果发现nologin，就去除它，在笔记本上不用开启。

+ rsync rsync协议守护，请视情况而定。

+ screen-cleanup 一个清除开机屏幕的脚本，随便。

+ sendsigs 重启和关机时向所有进程发送消息。所以不要管它。

+ single 激活但用户模式，不用管它。

+ stop-bootlogd 从2,3,4,5级别停止bootlogd,不用管它。

+ sudo 这个不用说吧，不用管它。

+ sysklogd 用于记录系统日志信息，不用管它。

+ udev 用户空间dev文件系统，不用管它。

+ udev-mab 同上。

+ umountfs 用来卸载文件卷的，不用管它。

+ urandom 生成随即数的，不知道怎么用，不用管它。

+ usplash 那个漂亮的启动画面，但是我关了它，它也存在，所以想关他需要把
  内核起动参数中的splash一句删掉。

+ vbesave 显卡bios配置工具，不用管它。

+ xorg-common 设置x服务ice socket。不用管它。

**** 修改文件默认打开方式
+ http://blog.csdn.net/hustrains/article/details/8652098
+ http://www.2cto.com/os/201301/182484.html

***** 简单的方法：
右键点击所需要的开的文件，选择“属性” ，“打开方式” 即可以选择默认打
开的程序，这是最简便的设定方法！！

***** 复杂一点的方法：
1. 配置文件
   + /etc/gnome/defaults.list 保存了全局的打开方式
   + /.local/share/applications/mimeapps.list 保存了个人的打开方式

   当两着不一致时，优先采用局部的个人设置，所以建议修改个人配置。

   例如，ubuntu12.04下视频文件默认是用电影播放机打开的，如果你想要改成
   用smplayer来打开的话，可以按照以下步聚来进行：

   1) 进入/etc/gnome目录: cd /etc/gnome

   2) 复制要改变打开方式的那些内容行到mimeapps.list文件

      grep “totem” defaults.list >> ~/.local/share/applications/mimeapps.list

   3) 进入~/.local/share/applications目录: cd ~/.local/share/applications

   4) 编缉mimeapps.list文件: vim mimeapps.list

   5) 在vim中执行替换: %s/totem/smplayer/g #

   6) 保存: :wq

**** 系统全局快捷键

1. 系统设置->键盘->快捷键
2. 小企鹅输入法的全局配置和附加组件

**** Recovery mode                                              :recovery:

+ http://bbs.csdn.net/topics/360177481
+ http://tieba.baidu.com/p/3006415003?bd_source_light=1563095
+ http://blog.csdn.net/mdx20072419/article/details/8060432


1. 问题1：修改系统文件 /etc/sudoers 错误后导致 sudo命令无法使用

   #+BEGIN_EXAMPLE
     >>> /etc/sudoers: syntax error near line 27 <<<
     sudo: parse error in /etc/sudoers near line 27
     sudo: no valid sudoers sources found, quitting

   #+END_EXAMPLE

2. 解决1: 切换到root用户进行修改
   + su root
   #+BEGIN_EXAMPLE
   en@ben:~$ su root
   密码：
   root@ben:/home/ben#
   #+END_EXAMPLE

3. 问题2：没有配置root密码导致su root认证失败
   + 吃一堑，长一智： 设置root密码
   + sudo passwd root

4. 解决2：在Ubuntu Recovery Mode进行修改
   1) 重启Ubuntu，随即长按shirft进入grub菜单，或等待grub菜单的出现
      \begin{figure}[ht]
      \centering
      \includegraphics[width=0.6\linewidth]{/home/wally/Wally/Journal/Figure/scrot/2731xsR.png}
      \end{figure}

   2) 选择Ubuntu高级选项

   3) 选择recovery mode

   4) 选项root

   5) 修改配置文件

5. 问题3：权限只读？
   + chmod u-w /etc/sudoers
   + chmod 440 /etc/sudoers
   + 错误提示：chomd :changing permissions of 'sudoers' :Read-only
     file system
6. 解决

   解决办法：利用 mount 指令解决 Read-only file system的问题
   #+BEGIN_EXAMPLE
   mount -o remount rw /
   #+END_EXAMPLE

   修改 /etc/sudoers 时，用 sudo visudo 命令修改，就不用先改权限了。修
   改后按Ctrl+x，选择Y，输入文件名，回车；

**** Xinitrc                                             :xwindow:xinitrc:

参考:
+ https://wiki.archlinux.org/index.php/Xinitrc_(\%E7\%AE\%80\%E4\%BD\%93\%E4\%B8\%AD\%E6\%96\%87)
+ https://wiki.archlinux.org/index.php/Xmodmap


~/.xinitrc文件量xinit和startx第一次启动时会读取的脚本.通常在启动X时执
行窗口管理器和其它程序.~/.xinitrc一个主要功能是根据单个用户的设置决定
/usr/bin/startx 或 /usr/bin/xinit程序启动的窗口系统.

xmodmap is a utility for modifying keymaps and pointer button mappings
in Xorg.

**** PPA                                                             :ppa:

Personal Package Archives（个人软件包档案）是Ubuntu Launchpad网站提供
的一项服务，允许个人用户上传软件源代码，通过Launchpad进行编译并发布为2
进制软件包，作为apt/新立得源供其他用户下载和更新。在Launchpad网站上的
每一个用户和团队都可以拥有一个或多个PPA。

**** 系统设置显示不全

+ http://tieba.baidu.com/p/2997221608
+ http://jingyan.baidu.com/album/49711c61527d74fa441b7cad.html


1. 打不开
   + sudo apt-get install ubuntu-desktop

2. 显示不全
   + sudo dpkg --configure -a    # 不解此为何意
   + sudo apt-get install unity-control-center

**** deb安装(dpkg)                                              :deb:dpkg:

http://zh.wikipedia.org/wiki/Deb

***** wiki

deb是Debian软件包格式，文件扩展名为.deb，跟Debian的命名一样，deb也是因
Debra Murdock（Debian创始人Ian Murdock的前妻）而得名。

Debian包是Unixar的标准归档，将包文件信息以及包内容，经过gzip和tar打包
而成。

处理这些包的经典程序是dpkg，经常是通过apt来运作。

通过Alien工具，可以将deb包转换成其他形式的软件包。

***** dpkg
deb是debian linus的安装格式，跟red hat的rpm非常相似，最基本的安装命令
是： *dpkg -i file.deb*

*dpkg* 是Debian Package的简写，是为Debian 专门开发的套件管理系统，方便软
件的安装、更新及移除。所有源自Debian的Linux发行版都使用dpkg，例如
Ubuntu、Knoppix 等。


以下是一些 Dpkg 的普通用法：
1. *dpkg -i <package.deb>*:

   安装一个 Debian 软件包，如你手动下载的文件。

2. *dpkg -c <package.deb>*:

   列出 <package.deb> 的内容。

3. *dpkg -I <package.deb>*:

   从 <package.deb> 中提取包裹信息。

4. *dpkg -r <package>*:

   移除一个已安装的包裹。

5. *dpkg -P <package>*:

   完全清除一个已安装的包裹。和 remove 不同的是，remove 只是删掉数据和
   可执行文件，purge 另外还删除所有的配制文件。

6. *dpkg -L <package>*:

   列出 <package> 安装的所有文件清单。同时请看 dpkg -c 来检查一个 .deb
   文件的内容。

7. *dpkg -s <package>*:

   显示已安装包裹的信息。同时请看 apt-cache 显示 Debian 存档中的包裹信
   息，以及 dpkg -I 来显示从一个 .deb 文件中提取的包裹信息。

8. *dpkg-reconfigure <package>*:

   重新配制一个已经安装的包裹，如果它使用的是 debconf (debconf 为包裹
   安装提供了一个统一的配制界面)。

**** apt-get autoremove                                       :autoremove:

*慎用 apt-get autoremove*

apt-get 提供了一个用于下载和安装软件包的简易命令行界面。
卸载软件包主要有这3个命令

+ remove – 卸载软件包
+ autoremove – 卸载所有自动安装且不再使用的软件包
+ purge – 卸载并清除软件包的配置

apt-get remove的行为我们很好理解，就是删除某个包的同时，删除依赖于它的包
例如： A 依赖于 B, B 依赖于 C
apt-get remove 删除B的同时，将删除A(很好理解，A依赖于B，B被删了，A也就
无法正常运行了)


apt-get autoremove的行为重点是卸载所有自动安装
例如：C 依赖于 B, D 依赖于B, 且D没有被其他手动安装的包依赖
apt-get remove C 将删除C, 同时提示你用apt-get autoremove去清除B,D
apt-get autoremove C 将删除B, C, D aptitude remove C 将删除B, C, D

我的理解: 删除C, 那么B,D 这两个包既是自动安装的,且没有其他手动安装的包
依赖于它们,则可以判定B,D也是没必要的

apt-get purge的行为卸载并清除软件包的配置，很容易理解

*依赖性永远是个噩梦，不要考虑用 apt-get autoremove 卸载自己不熟悉的软
件包*

当你问某某人xx包可以卸载吗？某人说你就用 apt-get autoremove 命令吧，然
后发现卸载后系统挂了，囧…

*** 软件管理手记

**** note

- 不单独在同一条笔记中跟踪所有软件安装，而是在对应软件笔记的子目录下记
  录，同时打上 *install* 的标签。

- 优先使用 *apt-get* 的方式安装软件

- 只有必要的时候才通过源码方式安装软件

- 依赖关系可能复杂的软件使用 *新得立(synaptic)* 安装

**** list

# Note: better to sort

|-------------+----------+-----------------------------|
| software    | method   | link                        |
|-------------+----------+-----------------------------|
| CAJ         | wine     |                             |
| chrome      | apt      |                             |
| CMake       | src      |                             |
| CMake       | src      |                             |
| cvs         | apt      |                             |
| ditaa       | synaptic | 依赖 java                   |
| doxygen     | apt      |                             |
| emacs       | src      | [[http://ergoemacs.org/emacs/building_emacs_on_linux.html][How to Build Emacs on Linux]] |
| foobar      | wine     |                             |
| FoxitReader | wine     |                             |
| gimp        | synaptic | [[http://www.gimp.org/][Homepage]]                    |
| git         | src      | README                      |
| gpg         | default  |                             |
| ledger      | apt      |                             |
| ros         | synaptic |                             |
| scrot       | apt      |                             |
| sdcv        | apt      |                             |
| smplayer    | synaptic | [[http://smplayer.sourceforge.net/][Homepage]]                    |
| stardict    | synaptic |                             |
| texlive     | src      |                             |
| vim         | src      | [[https://github.com/yangyangwithgnu/use_vim_as_ide][Use vim as IDE]]              |
| virtualbox  | synaptic |                             |
| w3m         | apt      |                             |
| wine        | synaptic |                             |
| wkhtmltopdf | apt      |                             |
| xmradio     |          |                             |

**** pkgProblemResolver::Resolve 发生故障

E:错误，pkgProblemResolver::Resolve 发生故障，这可能是有软件包被要求保
持现状的缘故

1) sudo rm -f /var/lib/apt/lists/lock  # 可能有用
2) 更换源(经验证)，更换源的方式：
   + 在软件中心更新源设置里修改
   + etc/apt/sources.list ，删除不需要的源

*** desktop重命名                                                 :desktop:

- http://blog.csdn.net/manmaximus/article/details/3567919

- why: 重命名桌面文件夹，桌面所在文件夹是“桌面”，习惯了用终端进行操
  作，但是在终端打中文比较麻烦

- 配置文件: *~/.config/user-dirs.dirs*

  #+BEGIN_EXAMPLE
    # This file is written by xdg-user-dirs-update
    # If you want to change or add directories, just edit the line you're
    # interested in. All local changes will be retained on the next run
    # Format is XDG_xxx_DIR="$HOME/yyy", where yyy is a shell-escaped
    # homedir-relative path, or XDG_xxx_DIR="/yyy", where /yyy is an
    # absolute path. No other format is supported.
    #
    XDG_DESKTOP_DIR="$HOME/Desktop"
    XDG_DOWNLOAD_DIR="$HOME/Download"
    XDG_TEMPLATES_DIR="$HOME/模板"
    XDG_PUBLICSHARE_DIR="$HOME/Share"
    XDG_DOCUMENTS_DIR="$HOME/Document"
    XDG_MUSIC_DIR="$HOME/Audio"
    XDG_PICTURES_DIR="$HOME/Picture"
    XDG_VIDEOS_DIR="$HOME/Video"
  #+END_EXAMPLE

*** 软件包依赖问题

#+BEGIN_EXAMPLE
您可能需要运行“apt-get -f install”来纠正下列错误：
下列软件包有未满足的依赖关系：
 steam-launcher : 依赖: curl 但是它将不会被安装
E: 有未能满足的依赖关系。请尝试不指明软件包的名字来运行“apt-get -f install”(也可以指定一个解决办法)。

#+END_EXAMPLE

1. 使用 新得立软件管理进行过滤
2. 这种情况下可以考虑使用源码安装

*** [[http://www.linuxidc.com/Linux/2010-05/26118.htm][Ubuntu下硬盘安装Windows 7]]                                :blog:Windows:

此前在Ubuntu下用virtualbox装了份Windows 7，确实比以往的Windows好用许多。
于是花了点时间把机子上原来与Ubuntu并存的Windows XP升级成Windows 7。

**** 所需工具、文件

- Windows 7安装镜像;

  我下载的是  7600.16385.090713-1255_x64fre_client_zh-cn_Retail_Ultimate-GRMCULXFRER_CN_DVD.iso,3.1G

- Grub4Dos

  用于引导Windows安装，后来听说Grub2也行，还要更方便一些，但我没可能再装一遍，以下还是以grub4dos为例;

- EasyBCD

  用于在Windows安装完成后找回启动Ubuntu的菜单.

**** 备份MBR

#+BEGIN_EXAMPLE
$ sudo dd if=/dev/sda of=/backup/mbr.img bs=512 count=1
#+END_EXAMPLE

至关重要。Ubuntu的安装过程会保留Windows启动项，但Windows的安装过程却很
霸道，安装后需导入MBR才能找回Ubuntu启动项。

Windows下无法访问Ubuntu里的文件，所以需要把这个备份文件复制到Windows文
件系统下，或则先用U盘备份。

**** 挂载Windows 7 ISO

#+BEGIN_EXAMPLE
$ sudo mount /iso/7600.16385.090713-1255_x64fre_client_zh-cn_Retail_Ultimate-GRMCULXFRER_CN_DVD.iso /mnt -o loop
#+END_EXAMPLE

即把Windows 7 ISO挂载到/mnt，打开这个目录，把里边的所有文件复制到一个
NTFS分区的根目录下——不能是将用于安装Windows 7的分区，亦即，需要预先准
备两个Windows分区。

我这里因为原本就是Windows与Ubuntu并存，Windows下有C、D、E盘，C盘准备用
来安装Windows 7，以上安装文件就复制到了E盘根目录下。

**** 添加启动菜单

打开载下来的Grub4dos.zip，把其中的grub.exe解压出来。

修改/boot/grub/menu.lst,添加如下几行

#+BEGIN_EXAMPLE
title grub4dos
root (hd0,3)
kernel /home/grub.exe
boot
#+END_EXAMPLE

第二行的0,3需根据实际情况修改，可查看menu.lst里原有的部分，找到Ubuntu
的选项复制成一样的即可。

如我原有启动项第一项是:

#+BEGIN_EXAMPLE
title Ubuntu 9.10, kernel 2.6.31-16-generic
root (hd0,3)
#+END_EXAMPLE

第三行的/home/grub.exe需修改成刚解压出的grub.exe所在路径。

**** 重启安装

重启，在操作系统选单里选择grub4dos，屏幕一闪再度进入操作系统选单，按c
进入命令行grub>，依次输入以下指令：

#+BEGIN_EXAMPLE
grub>find --set-root /bootmgr
grub>chainloader /bootmgr
grub>boot
#+END_EXAMPLE

随即进入Windows 7安装引导界面，一路装下去即可。

**** 恢复MBR

Windows安装完成后，多系统选单不见了，此时需要恢复MBR。我安装前在网上找
到的几篇文章里有指明，可以在Windows下以如下指令恢复：

#+BEGIN_EXAMPLE
echo c:\"linux.lnx"=linux >> boot.ini
#+END_EXAMPLE

遗憾的是Windows 7里好像根本就没有boot.ini，试了一下，此法无效。

无奈只好用下了一份easyBCD，安装之后运行，添加LINUX启动项。C盘下会生成
c:\nst\nst_linux.mbr文件，删除之，把此前备份的mbr.img复制到这个位置，
重命名为nst_linux.mbr。


重启在多系统选单选择linux选项，即可看见原来的Ubuntu多系统选单。进入
Ubuntu之后，再彻底还原MBR。

#+BEGIN_EXAMPLE
$ sudo dd if=/backup/mbr.img of=/dev/sda bs=446 count=1
#+END_EXAMPLE
*** [[https://linux.cn/article-4016-1.html][如何清理 Ubuntu 14.04 的最近打开文件历史列表]]                     :blog:

要从dash搜索删除历史记录，请遵循以下程序。

转到系统设置（System Settings）并打开安全与隐私（Security & Privacy）。

在文件与应用（Files and Applications）标签下，点击清除用户数据（Clear Usage Data）。

你也可以关闭“记录文件与应用使用（Record file and Application usage）
以阻止系统记录你当前使用的文件和应用。

*** [[http://blog.csdn.net/hustrains/article/details/8652098][ubuntu如何设置默认程序打开方式]] :blog:

1   简单的方法：
右键点击所需要的开的文件，选择“属性” ，“打开方式” 即可以选择默认打开的程序，这是最简便的设定方法！！

2  复杂一点的方法：
从总体上讲

/etc/gnome/defaults.list 保存了全局的打开方式

/.local/share/applications/mimeapps.list 保存了个人的打开方式

当两着不一致是，优先采用局部的个人设置。

例如，ubuntu12.04下视频文件默认是用电影播放机打开的，如果你想要改成用smplayer来打开的话，可以按照以下步聚来进行：

1.进入/etc/gnome目录
  命令 ：cd /etc/gnome

2.复制要改变打开方式的那些内容行到mimeapps.list文件
 命令 grep “totem” defaults.list >> ~/.local/share/applications/mimeapps.list

3.进入~/.local/share/applications目录
 命令 cd ~/.local/share/applications

4.编缉mimeapps.list文件
 命令： sudo vim mimeapps.list

5.在vim中执行
 命令：%s/totem/smplayer/g

6.然后执行保存
 命令：wq

7.完成

想要改其它类型的可照此类推，比如我就把音频文件换成了audacious来打开，文本文件用gvim来默认打开。

*** [[http://blog.chinaunix.net/uid-488742-id-2113697.html][Ubuntu中安装PDF虚拟打印机 ]] :blog:

为了保存一些网页文档，通常在WIN下我们都是利用MS Office自带的PDF打印机打印成PDF格式文档。
当然，在无所不能的Ubuntu下，也是有这样的工具的哦。尤其可以解决Linux和WIN下文档不兼容的问题。
用PDF格式互通文件该是非常不错的吧。
1. 安装cups 和cups-pdf
sudo apt-get install cups-pdf
2. 设置cups-pdf 的 backend root 权限
sudo chmod 4755 /usr/lib/cups/backend/cups-pdf
3.通过 系统-系统管理-打印 启动打印机配置向导
4.右键 “新建打印机” 图表-添加 开始添加打印机
5. 使用检测到的打印机 -选择 PDF Printer-前进
6. 制造商 选择 Generic-PostScript -前进
7. 添入打印机的名称。
8.完成。
现在你就可以用虚拟打印机将你需要的文档打印成PDF格式了。
PS:
sudo gedit /etc/cups/cups-pdf.conf
找到Out开头，就可以修改默认保存文件夹了。
其实gedit ，gThumb都能直接打印成PDF文档，但是打印网页什么的，还是安个虚拟打印机比较方便。而且这个只有几十K那么大！
实在是好东西。
还有，打印快捷键是Ctrl＋P

*** Android 手机挂载位置                                          :android:

http://forum.ubuntu.org.cn/viewtopic.php?t=456872

#+BEGIN_QUOTE
现在Ubuntu会自动挂载Android手机， 自动挂载点在：/run/user/用户id/gvfs下
#+END_QUOTE

使用 Emacs 不好操作该挂载点的文件或目录，卡而且有错误, 好像会把文件重
写。

不知为何。
*** Ubuntu 版本升级                                          :版本:version:

- http://www.ithome.com/html/soft/81883.htm

4月17日，开源免费系统Ubuntu 14.04 LTS（代号Trusty Tahr）正式发布下载。
那对于Ubuntu 13.04/13.10用户来说，如何快速升级至Ubuntu 14.04 LTS平台？
是否支持保留当前个人数据？

据国外noobslab网站介绍，Ubuntu任何老版本都可以免费升级至Ubuntu 14.04平
台，整个升级流程也非常便捷，无需下载离线系统镜像安装，只需使用到Ubuntu
的 *软件更新器* 。下面，IT之家也为Ubuntu新老用户整理对应的升级操作步骤，
具体参考如下


*注：升级可能存在各类未知风险，请及时备份本地的数据。*


1、打开Ubuntu左侧面板，搜索并运行软件更新器；

2、打开软件更新器的设置；

3、切换至“其他软件”，禁用或删除当前系统的所有第三方软件源；

4、随后，切换至软件和更新的“更新”页面，将有新版本通知我：更改为适用任何新版本；

5、关闭所有窗口，重新运行Ubuntu软件更新器，立即安装对应的升级更新，即可快速升级至Ubuntu 14.04平台。

*** Ubuntu 内核升级                                                :kernel:

- http://www.ahlinux.com/start/base/21683.html
- http://os.51cto.com/art/201510/493555.htm

*没有必要为啥要升级内核呢? 好像新的特性你能用上似的!(2016/02/23)*

在google一搜“Ubuntu 内核升级”有366000条结果,
我为什么还要写这么一篇呢？因为搜索结果基本都是针对某一个内核写的文章，
我想写的是无论你是哪一个版本（不过我只确定LTS有效）看到以后都有用的文章。

那么在Ubuntu上升级内核( =跨版本升级= ，安全更新不在本文范围内)有哪些方式呢？
下面就容我一一道来：

**** 1, apt-get升级， 难度☆

Ubuntu的LTS版本都会提供新版本的内核，
而不是像RedHat那样把新内核的代码提取出来放到当前发布的内核中保持主版本号不变，
Ubuntu可能是没有那么大人力物力财力？好吧， 闲话少说， 以14.04为例，
首先我们来看看源列表中存在的可安装内核(LTS支持)：

#+BEGIN_EXAMPLE
    $ apt-cache search linux-generic-lts
    linux-generic-lts-quantal - Generic Linux kernel image and headers
    linux-generic-lts-quantal-eol-upgrade - Complete Generic Linux kernel and headers
    linux-generic-lts-raring - Generic Linux kernel image and headers
    linux-generic-lts-raring-eol-upgrade - Complete Generic Linux kernel and headers
    linux-generic-lts-saucy - Generic Linux kernel image and headers
    linux-generic-lts-saucy-eol-upgrade - Complete Generic Linux kernel and headers
    linux-generic-lts-trusty - Generic Linux kernel image and headers
    linux-generic-lts-utopic - Complete Generic Linux kernel and headers
#+END_EXAMPLE

看最下面， 哦，
目前除了随14.04发布的3.13版本的内核还可以选择安装随utopic发布的3.16版本的内核(更低版本的内核我就不说啦，
嗯， 这里是讲升级内核的嘛)， 所以如果想安装3.16的内核就执行

#+BEGIN_EXAMPLE
    sudo apt-get install linux-generic-lts-utopic
#+END_EXAMPLE

好了， 坐等完成， 重启以后就是了。

**** 2, 自行下载安装， 难度☆☆

Ubuntu官方发布到源里的内核优点就是有安全更新( sudo apt-get dist-upgrade
)， 缺点是总不是最新的， 好吧， 我想体验一下最新内核！

首先访问
[[http://kernel.ubuntu.com/%7Ekernel-ppa/mainline/daily/current/][Ubuntu每日内核更新的站点]]
， 下载三个包：

#+BEGIN_EXAMPLE
    mkdir tmp_kernel
    cd tmp_kernel

    # 一个是linux-headers-xxxxx_amd64.deb结构命名的， 如果你是32位机器就选linux-headers-xxxxx_i386.deb， 下同
    wget http://kernel.ubuntu.com/~kernel-ppa/mainline/daily/current/linux-headers-3.19.0-999-generic_3.19.0-999.201501100206_amd64.deb
    # 这个是 linux-headers-xxxxx_all.deb结构命名的
    wget http://kernel.ubuntu.com/~kernel-ppa/mainline/daily/current/linux-headers-3.19.0-999_3.19.0-999.201501100206_all.deb
    # 这个是linux-image-xxxxx-_amd64.deb结构命名的
    wget http://kernel.ubuntu.com/~kernel-ppa/mainline/daily/current/linux-image-3.19.0-999-generic_3.19.0-999.201501100206_amd64.deb
#+END_EXAMPLE

你可能还看到了 * -lowlatency- * 结构命名的内核， 说实话我没用过， 可以
[[http://askubuntu.com/questions/126664/why-to-choose-low-latency-kernel-over-generic-or-realtime-ones][看这里]]
,
大概是像录音设备之类的需要这种低延迟的[[http://www.ahlinux.com/start/kernel/][内核]]？这个内核更费电，
对于我们笔记本或台式机还是用不着的。

下载过来以后执行 dpkg -i *.deb (你要保证该目录下没有其他.deb，
要不然就一起被安装了), 再执行 sudo up[[http://www.ahlinux.com/start/cmd/9059.html][date]]-grub ,
重启就可以了。

**** 3， 自行编译内核, 难度☆☆☆

这种方式适用于需要高度定制内核(或精简内核)的人群，
但是本文目的是作为一篇通用的文章，
所以这种方法就不多说了。下面我针对几个特定内核给出一些链接吧：

*** Linux 修改卷标

- [[http://blog.chinaunix.net/uid-20321915-id-1966428.html][linux 修改分区卷标 ( Partition Label )]]

傻瓜方式 : Windows 格式化时设置卷标名称.(2016/02/23)

**** Fat16/Fat32格式

#安装
$ sudo apt-get install mtools

#新建配置文件
$ cp /etc/mtools.conf ~/.mtoolsrc

#编辑刚复制的”~/.mtoolsrc”文件,在最後一行加入如下命令行：
drive i: file="/dev/sda2" //里面的”/devsda2”应根据实际情况更改为你要
改的盘

#更改命令提示符路径到”i:”盘：
$ mcd i:

#查看”i:”当前的卷标
$ sudo mlabel -s i:

#更改”i:”盘原始卷标为你喜欢的新卷标名：
$ sudo mlabel i: newLabelName

**** NTFS格式

#安装
$ sudo apt-get install ntfsprogs

#修改
sudo ntfslabel /dev/sda1 newLabelName //里面的"/dev/sda1"应根据实际情况修改

**** ext2/ext3格式

使用内置命令

$ sudo e2label /dev/sda1 newLabelName

** Windows                                                         :windows:
*** 关于 Word 文件的转换                                         :word:pdf:

PDF 优于 Word
- 移植性
- 性能

一般参考文档尽量保存为 PDF 格式.

在将 Word 转换为 PDF 的过程中, 如果使用 Linux 下工具, 如
LibreOffice(Unoconv), 可能会造成格式(包括排版和字体)的变动, 这样必要不
如原版的好, 更要命的是, 一些特殊元素的丢失, 这样得不偿失, 尤其是重要的
文档.

所以, *使用 Word 的 转换功能或福晰插件转换 Word 为 PDF*
- 注意是否转换了目录, 这点其实蛮重要的, 自带的好像没有

*** 在 word 中使用 LaTeX 公式                                    :word:latex:
**** [[https://www.zhihu.com/question/20541531][LaTeX vs Word : 所谓优雅，唯技熟尔（知乎）]]

神圣的战争有几种：Emacs vs. Vim，LaTeX vs. Word， CLI vs. GUI。

不过对于我来说，这几种战争都跟我没关系，尤其是LaTeX和Word，我都用。

LaTeX和Word完全不是一个类型的排版工具，但是目的一样：*排版*。

LaTeX是仿照Scribe语言（见
[[//link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Scribe_%2528markup_language%2529][http://en.wikipedia.org/wiki/Scribe\_%28markup\_language%29// ]]）而进行
设计的，而Word在最早的时候是字处理软件，实现的只有基本的一些排版功能，
后来才越做越庞大的。

*所谓优雅，唯技熟尔。* 实际上不熟练LaTeX排出来的数学公式也会很难看的，
而熟悉Word的也可以把Word文档做的不输LaTeX生成的。我自己就伪造像LaTeX生
成的Word文档，当然我最终生成pdf了，这是个值得炫耀的showcase。Word和
LaTeX在大部分的功能上旗鼓相当，只有少部分差距较大。

每当我打开一个Word窗口的时候，我都会在心中吼一句：“又是一个全新的挑
战！”

在我的眼里，这两个工具对于我自己来说，命令行的LaTeX和WYSIWYG的Word的差
异已经不是那么重要了。我的答案没有图。

这里开始介绍Word和LaTeX的一些相同点，重点嘛，在Word上面，顺带介绍一些
TeX的基本命令：

-  文档处理速度。Word在处理文档的时候，小文档可以快速打开，大文档呢，
  含有大量图或者文本的文档处理就相当慢了，有时候会打不开。LaTeX本身不
  是直接预览的，所以大小文档都是一个样，编译速度稳定。这个时候，需要将
  Word文档分割成小文档，见
  [[//link.zhihu.com/?target=http%3A//office.microsoft.com/zh-cn/word-help/combine-or-split-subdocuments-HP005186930.aspx][http://office.microsoft.com/zh-cn/word-help/combine-or-split-subdocuments-HP005186930.aspx]]
  。 而LaTeX呢，用\input或者\include来做是最常用的办法。

-  页面布局：文字方向。Word支持几种方向：水平，垂直，旋转90度，旋转270
  度，对汉字旋转270度。在加上对bidirection的支持，能够实现很多方向。而
  这一点对于一般的排版也就足够了。过时的Omega/Aleph引擎可以支持32种方
  向，不过太多了，Word没必要全部实现。日本的pTeX/e(u)pTeX/upTeX呢，支
  持三种方向：bidirection的支持，\yoto（横），\tate（纵）和\dtou（直排，
  方向向上）。LuaTeX支持四种书写方式：TLT（水平左到右），TRT（水平右到
  左），RTT（垂直上到下，水平右到左）和LTL（垂直上到下，水平左到右）。
  pdfTeX和XeTeX的方向支持：bidirection的支持，水平方向。综合考评，Word
  的文字方向还是够用的，虽然不如Omega这种变态的TeX引擎那么多。*值得说
  的一点*是：Word的中在多方向排版中，对西文和汉字的基线对齐方式是采取
  的方式不如LaTeX便捷，有些字体即使基线对齐字体看着也不是对齐的，LaTeX
  可以很好地指定baseline shift。

-  页面布局：页边距，纸张方向，纸张大小。在Word中对于这几项的设定，很
  容易，看着示意图来进行调整。LaTeX下面对于这些的设定，大多可以使用梅
  木秀雄的geometry包进行调整，而对于KOMA-Script和memoir等专业文档类，
  这些文档类内建了相应的接口。而在TeX底层，调节这些尺寸的命令为：
  \hoffset，\voffset，\vsize，\topskip，\pagegoal，\pagedepth，
  \pageshrink，\pagestretch和\maxdepth。这些TeX命令不仅有不可变化的尺
  寸，如\hoffset，同样也有\pageshrink这样可以变化的尺寸。这些命令保证
  了TeX页面输出的质量。

-  页面布局：水印，页面颜色，页面边框。这几项在Word中设定简单。在LaTeX
  中，这些都需使用第三方宏包来实现，即watermark（水印），pagecolor（页
  面颜色），fancybox（页面边框）。其实这些功能算是花边功能，我自己用的
  不是很多。

-  字体：Bold，Italic，Underline。这几个，Word做的都很直接，尤其是
  Underline这一项比LaTeX下面的uline包等要省事很多。先说说Word的，这几
  项对于西文字体没话说，前两项对于成套的西文字体会自动选择Bold和Italic
  对应的字体，但是对于中文字体来说，这两项被乱用了，中文字体成套的都价
  格不菲，很多人在Win下或者Mac下都使用本地的几个字体，这些字体很少成套，
  这就造成一个问题，你点击Bold或者Italic他不会切换到相应字体，而是采取
  了伪粗和伪Italic的形式，这就难看了，除非必要，请不要乱用这两个按钮。

-  字体：kerning，OpenType。kerning在TeX中是使用\kern来实现的，当你输
  入\LaTeX这个命令的时候，大写字母E与T以及X之间就是有kerning的，更高级
  的设定可以使用microtype包。Word呢，哪有那么二啊，当然有kerning，鼠标
  右击“字体->高级”就能看到了。对于OpenType，也出现在字体的高级选项中，
  支持ligature和相应的数字样式。我猜测一些语言支持的选项自动被使用了，
  比如我在测试部分藏文的时候，正常显示。在现行的TeX引擎中，pdfTeX不支
  持OpenType，需要转换，XeTeX内建了一个支持OpenType的库，而LuaTeX则使
  用fontforge进行字体处理。不过TeX引擎里面的库基本上是开源的，对于某些
  特殊语言的支持不足，我在测试藏文的就发现部分显示不正常（日本学者指出
  大约有30处毛病），同时这些库也导致了XeTeX/LuaTeX程序显得有些臃肿。微
  软的Uniscribe库很稳定，我觉得设计一个调用这个库的引擎会有很好的效果。
  OpenType是解决已知语言排版的一个很好的工具，但是对于一些比较复杂的，
  比如古希腊语以及一些冷门语言，OpenType不是终极解决之道。这些冷门语言
  在TeX/LaTeX中的处理简单许多，日本的文科学者作了很足的功夫（见
  [[//link.zhihu.com/?target=http%3A//www2.tba.t-com.ne.jp/ing/language.html][http://www2.tba.t-com.ne.jp/ing/language.html//]]）。 还有一些西方学者
  用LaTeX来排梵文/巴利文文献。这类冷门的语言，还是珍爱生命，远离Word吧。

-  字体：尺寸。Word对于一个给定的字体可以指定一个尺寸，但是，大小必须
  介于0pt--1584pt之间。而TeX现在的设计，是0pt--2048pt之间。就实用性来
  说，而这这个区别不大。一个值得说的是MM（Multi   Master）字体，这种字
  体有点TrueType Collection，内含不同磅重的字体。好像Word不支持，在
  XeTeX/LuaTeX下面支持良好。这个字体在使用的时候，设定不同的字体尺寸会
  指定到不同磅重的字体上面去。

-  字体：简转繁，繁转简。Word中对应的转换应该是内建的，因为很多字体都
  没有trad和smpl这两个feature，如果是OpenType字体，Word直接调用这两个
  feature来转换会省事些。LaTeX中，可以直接调用这两个feature来进行处理。
  如果实在不行，可以写给perl脚本进行预处理嘛。

-  引用：交叉引用。Word下面的引用工作需要做很多，幸好有个好的GUI进行呈
  现，进行交叉引用不那么麻烦。而LaTeX下面就是基本功能了，不过LaTeX下面
  的引用，除了用来对付文献之外，还可以对付whatsits，这些就属于比较hack
  的东西了，比如，判断一个确定的公式是否在某一页。

-  引用：目录。Word的目录制作，感觉和LaTeX方式一致，就是标记section，
  标记subsection，标记subsubsection等等等。Word需要在一篇文档的相关操
  作的最后进行目录的操作，而LaTeX呢，在你输入\section等命令的时候就可
  以了，再设定一下\tableofcontentsd的位置就可以坐享其成了，LaTeX更新目
  录需要生成两次。

-  邮件合并。Word里面的邮件合并在初学的时候需要操作几次才能够掌握。
  LaTeX下面直接写一个迭代就可以了。说个稍微有意思的东西，在网络编程里
  面写一个接口调用LaTeX来生成一些pdf版本的邮件不是很麻烦的。数据批处理，
  除了用那些pdf库外，用LaTeX也是个好办法，首先是格式可以保证，其次可以
  处理一些汉字字体不能显示的问题，经济。

-  审阅。Word的审阅和pdf的审阅很相似，而这都很直观。这一点，LaTeX本身
  得生成pdf才能做到，也就是说LaTeX源码纯文字的做审阅几乎不可能。一个曲
  线的办法是，使用svn或者git之类的管理工具。

-  段落：首字下沉。这个在Word中调节是很直观的。但是我个人觉得这个用到
  中文中也勉强可以，但是字体不能那么死板。LaTeX下面使用lettrine包就可
  以了，这个包的文档给的示例还是很好看的。再强调一遍，*中文状态下请慎
  用*。

-  段落：river。这个涉及到Word对英文词的断词算法，说实话，没TeX高明。
  LaTeX下可以控制断词来产生river，一些出版社有意使用这种形式。LaTeX下
  不控制就默认对的齐齐的。另外，对于断词算法，还有过一些扩展，比如针对
  一些德语旧书里面的，不是断词而是控制字母之间的距离的扩展。这些扩展在
  现在的TeX中不是很常见。

-  段落：断行禁则，孤行控制。Word的断行禁则可以自己进行设置，指定标点
  神马的。但是标点压缩未见得很好玩，我记得Word下面的一些日文禁则倒是有，
  但是标点压缩很糟糕，导致不能符合JIS标准。在LaTeX下，CCT、CJK和xeCJK
  的标点压缩都是使用宏来实现的，pTeX系列是使用jfm来实现的，LuaTeX-ja是
  使用lua脚本实现的。而禁则的实现，是使用了TeX中的相关penalty。孤行控
  制不用多说了吧，避免单字成行，也是使用了penalty。

-  页眉，页码，页脚。这几项，Word直接插入，但是样式简单单一。而LaTeX需
  要繁琐地指定一些高度。但是从效果上来看，LaTeX可选的样式太多了。页眉
  页脚在LaTeX下面的定制需要使用fancyhdr，如果是KOMA-Script，有内建选项。

-  超链接，书签。Word实现的超链接还OK，但是和pdf中变化多端的超链接来比
  较，是在没有多少出彩之处。LaTeX依靠的是pdf这颗大树。在LaTeX下实现超
  链接和书签，直接使用hyperref就行了。

-  表格。表格这个东西还是Word比较好用，有一次我就用LaTeX连续敲&敲到手
  抽筋。TeX有一个排表格算法，在命令上，可以使用\halign和\valign等命令
  制作表格。LaTeX中制作表格是比较上层的命令，包很多，tabu，tabularx，
  booktabs等。

-  数学排版。可能这是争议比较大的地方，现在的情况是，Word和TeX互相影响
  （我不清楚是否和Lamport在微软有关）。Word2007之后，支持LaTeX语法标记
  的数学输入，并且很重要的是微软给OpenType添加了一个math表，随后XeTeX
  的开发跟进，也支持了微软的这个表，现在LuaTeX也是支持的，在不远的将来，
  TeX的数学排版将直接使用Unicode编码。就基础性的数学排版而言，两者现在
  基本上没区别，除了TeX的数学字体多一些。我做过一个TeX风格的数学字体，
  偏Times风格可以用于Word，现在没时间弄了。TeX的优势是历史比较长，文档
  相当丰富。而Word的数学排版呢，受限于字体和格式，兼容性陷阱谁掉进去都
  不容易爬出来。如果Word能够解决这一点，那就很无敌了。但是Word这个东西
  做到和TeX高度兼容，开发者得付出相当大的努力了。*TeX不是排版之王，好
  的排版效果和坏的排版效果都是人控制的，人造的，当你到一定水平之后，工
  具就是//Das Ding// /für mich/（康德语）*。

-  编程。Word编程：域代码，VBA。TeX编程：TeX宏，perl代码，lua代码，
  python代码。哪个好玩？


写到这里，我觉得我应该写完了，对于排版，都是工具，别一味抬高哪个，别一
味贬低哪个。当一个用户被LaTeX的数学排版吸引的时候，可能会丢掉Word，但
是等你了解LaTeX一些深层次的概念的时候，你会发现Word也不是那么糟糕么，
XD。

对于Word的使用，我给出下列建议：

1. 先输入文字（可使用记事本，Vim，Emacs等完成），输入完成后在统一修改版式，边写边改效率低。
2. 插图的位置选放可以在版式修改之后进行，也可以在修改版式期间进行。
3. 目录什么的，要时常更新。
4. 我没有更多的建议。
**** [[http://texpoint.necula.org/][TeXPoint]]                                                   :texpoint:

[2016-03-03 四 15:43]
#+BEGIN_SRC org
最后更新时间为 2010 年，应该已经很古老了，不用考虑
#+END_SRC

**** [[http://blog.sina.com.cn/s/blog_84024a4a01017ukv.html][使用 mathtype 渲染]]                                         :mathtype:

[2016-03-03 四 15:42]
#+BEGIN_SRC org
这个可以尝试下
#+END_SRC

**** [[https://sourceforge.net/projects/texsword/][TeXsword]]                                                   :texsword:

- [[http://blog.csdn.net/lzuacm/article/details/17287385][Word插入Latex公式的几种方式]]

[2016-03-03 四 15:44]
#+BEGIN_SRC org
SourceForge 项目，最近更新时间为2014/01
#+END_SRC

**** [[http://elevatorlady.ca/][Aurora]]                                                       :aurora:

在MS Word中插入LaTeX数学公式网上一般推荐用Aurora，不过这个软件并不免费，
而且好久没更新了，不兼容最新的MikTex.

[2016-03-03 四 15:46]
#+BEGIN_SRC org
优先尝试这个，只是需要破解。
Word 需要安装 VB 和宏的支持
在 MS 2010 中运行 LaTeX 出错
百度云保存了破解版
#+END_SRC

*** /word/                                                           :word:
**** [[http://emacsblog.org/2007/02/18/emacs-key-bindings-in-ms-word/][Emacs Key Bindings in MS Word]]                            :blog:emacs:

****** February 18th, 2007 by Ryan McGeary ·
[[http://emacsblog.org/2007/02/18/emacs-key-bindings-in-ms-word/#comments][189
Comments]]

Macosxhints.com points us to a way to
[[http://www.macosxhints.com/article.php?story=20070215034801484][enable
emacs key bindings in Microsoft Word]]. Just assign new shortcut keys to
each of these Word commands (instructions below):

| #+BEGIN_EXAMPLE         |
|     StartOfLine : C-a   |
|     EndOfLine   : C-e   |
|     LineUp      : C-p   |
|     LineDown    : C-n   |
|     CharLeft    : C-b   |
|     CharRight   : C-f   |
| #+END_EXAMPLE           |


Please feel free to suggest other emacs equivalent Word commands and
shortcuts in the comments.

***** Word 2004 for Mac

1. Tools > Customize > Customize Keyboard ...
2. Select “All Commands” in the Categories box.

1. Add new shortcut keys for each of the commands above.

***** Word 2002 (XP) for Windows

1. Tools > Customize ...
2. Click the “Keyboard ...” button.
3. Select “All Commands” in the Categories box.

1. Add new shortcut keys for each of the commands above.

/Note: On Windows, =C-p=, =C-n=, and =C-f= will probably conflict with
FilePrint, FileNew, and EditFind, so you may want to remove those
existing shortcut keys first./

**** MS: 参考文献自动生成                                  :word:参考文献:

尾注法方法如下以Word2003为例

1. 光标移到要插入参考文献的地方，菜单中“插入”——“引用”-“脚注和尾
   注”。

2. 对话框中选择“尾注”，编号方式选“自动编号”，所在位置可以选“节的
   结尾”或“文档结尾”。

3. 如“自动编号”后不是阿拉伯数字，选右下角的“选项”，在编号格式中选
   中阿拉伯数字。

4. 确定后在该处就插入了一个上标“1”，而光标自动跳到文章最后，前面就是
   一个上标“1”，这就是输入第一个参考文献的地方。

5. 将文章最后的上标“1”的格式改成正常（记住是改格式，而不是将它删掉重
   新输入，否则参考文献以后就是移动的位置，这个序号也不会变），再在它
   后面输入所插入的参考文献（格式按杂志要求来慢慢输，好像没有什么办法
   简化）。

6. 对着参考文献前面的“1”双击，光标就回到了文章内容中插入参考文献的地
   方，可以继续写文章了。

7. 在下一个要插入参考文献的地方再次按以上方法插入尾注，就会出现一个
   “2”（Word已经自动为你排序了），继续输入所要插入的参考文献。

   标号上的方括号如何加呢？

8. 用的尾注，在菜单中的“编辑”——“替换”中“查找内容”填写 ^e，替换为
   [^&]即可：

9. 用的脚注，在菜单中的“编辑”——“替换”中“查找内容”填写^f，替换为
   [^&]便可以了（这里建议在一篇文章都写完后再将方括号加上会省去很多意
   外的麻烦）

10. 所有文献都引用完后，你会发现在第一篇参考文献前面一条短横线（页面视
    图里才能看到），如果参考文献跨页了，在跨页的地方还有一条长横线，这
    些线无法选中，也无法删除。这是尾注的标志，但一般科技论文格式中都不
    能有这样的线，所以一定要把它们删除。

    还没完，删除横线的方法.

11. 切换到普通视图，菜单中“视图”——“脚注”，这时最下方出现了尾注的编
    辑栏。

12. 在尾注右边的下拉菜单中选择“尾注分隔符”，这时那条短横线出现了，选
    中它，删除.

13. 再在下拉菜单中选择“尾注延续分隔符”，这是那条长横线出现了，选中它，
    删除。

14. 切换回到页面视图，参考文献插入已经完成了。

这时，无论文章如何改动，参考文献都会自动地排好序了。如果删除了，后面的
参考文献也会自动消失，绝不出错。参考文献越多，这种方法的优势就越强大。
**** [[http://hints.macworld.com/article.php?story=20070215034801484][Emacs Keybindings in MS word]]                                   :blog:

Emacs users get addicted to the standard key bindings (which are also
available in Cocoa apps). Microsoft Word doesn't support these by
default, but you can add them through customization. Here are the ones I
find most useful:

- StartOfLine: Control-A
- EndOfLine: Control-E
- LineUp: Control-P
- LineDown: Control-N
- CharLeft: Control-B
- CharRight: Control-F

To set these up in Word, go to Tools » Customize » Customize Keyboard.
From the Categories panel, choose All commands. Find each of the entries
in the above list, select the /Press new shortcut key/ box for each,
then type the shortcut as shown above and click Assign. (Word will tell
you if any of the shortcuts are currently assigned to other commands.)

The icing on the cake is to get Control-K working. You can do this with
a macro. Go to Tools » Macro » Macros. Set the macro name to /CtrlK/,
then click Create. When the macro window appears, add the following
lines just before the =End Sub= line:

#+BEGIN_EXAMPLE
        Selection.EndKey Unit:=wdLine, Extend:=wdExtend    Selection.Cut
#+END_EXAMPLE

Hit the W icon on the toolbar to save the macro and go back to Word. Now
go back to the Tools » Customize » Customize Keyboard window, choose
Macros from the Categories pane, and assign your new macro to Control-K.

**** docx2tex                                                      :latex:

+ http://superuser.com/questions/116289/word-2007-files-on-emacs

Or you can convert them to Latex using docx2tex, which works pretty
well, but loses some formatting. docx2tex isn't packaged up by anyone,
and if you are on Linux, you'll need to install some pretty up-to-date
Mono libraries. Unfortunately, converting back again doesn't work so
well: there are a few fairly limited Latex to RTF converters around.

That's not really the same thing as an existing word-2007-mode, but
the steps could all be automated in Emacs.

*** [[http://www.cam.hi-ho.ne.jp/oishi/indexen.html][XKeymacs]]                                                   :blog:emacs:

XKeymacs is a keyboard utility to realize emacs like-useability on all
windows applications. With XKeymacs you can use emacs keybindings with
any windows application. You can create a keyboard macro and assign any
shortcut key too. You also get bash-like command completion in your DOS
shell. If you do not know Emacs, Xemacs, Mule or Meadow, you probably
want nothing to do with XKeymacs. I began to make XKeymacs because I
wanted to add C-t and C-l to Keymacs. Now that all the functions I want
are available, I think I will burnish XKeymacs by adding new functions
that users want and to fix bugs.
 Supported OS: Windows 95, 98, Me, NT 4.0, 2000, XP, 2003, Vista
(Internet Explorer 5.0 is required on Windows 95, 98 or NT 4.0.)

[[xkeymacs347.zip][xkeymacs347.zip (198,839 bytes)]]
 It includes xkeymacs.exe, xkeymacs.dll, [[readmeen.html][Readme.txt]],
[[readme.html][Readme_J.txt]], [[dot.xkeymacs]],
[[faqen.html][FAQ.txt]], [[faq.html][FAQ_J.txt]],
[[releaseen.html][release.txt]], [[release.html][release_J.txt]],
[[specen.html][spec.txt]] and [[spec.html][spec_J.txt]].


 [[xkeymacssrc347.zip][xkeymacssrc347.zip (181,788 bytes)]]
 It is the [[sourceen.html][source code]] of xkeymacs.exe and
xkeymacs.dll. You can compile them by using Microsoft Visual C++ 6.0.
 - You have to install
[[http://www.microsoft.com/msdownload/platformsdk/sdkupdate/][Microsoft
Platform Software Development Kit (SDK)]] and add include/lib directory
at the top of list on Directory tab in Options dialog of Microsoft
Visual C++ 6.0.

 [[xkeymacs347.msi][xkeymacs347.msi (246,272 bytes)]]
 It is installer of XKeymacs.
 [[xkeymacsins347.zip][xkeymacsins347.zip (218,445 bytes)]]
 It is the source of the installer. You can build them by Microsoft
Visual Studio Installer.

[[http://xkeymacs.sourceforge.net/archive/][Archive of old versions]]

[[xkeymacsen.png]]

[[http://lists.sourceforge.net/lists/listinfo/xkeymacs-support][Mailing
List]]
 Please tell me your impression, question, request, etc. I announce bug
information and new version release news on this ML.

Known Problems (or Specifications?!)

- C-l does not work well with someapplications.
- M-? by the Alt key is ignored with Microsoft Visual C++ or Netscape.
   (It works well if you retry.)
- C-r works as C-s with Internet Explorer if Find dialog does not
   appear.
- C-t, etc. do not work well with command prompt.
- C-k works as C-f on an edit box for a password.
- XKeymacs version 1.16 and later will be occured Invalid Page Fault
   error of Kernel32.dll on Windows 95.
    (But only the dialog pop up, OS and/or applications are never
   ABEND.)
- XKeymacs causes an application error when you shutdown Windows NT.
- XKeymacs conflicts with X-mouse of Tweak UI.
- XKeymacs conflicts with KbdAcc. (Acceleration does not work well in
   some case.)

Notes
 The xkeymacs.exe require the mfc42.dll and the msvcrt.dll. If your
system does not have these files, the xkeymacs.exe pop up an error
message. When an error message is poped up, you must get the mfc42.dll
(ex. from
[[http://www.vector.co.jp/soft/win95/util/se040499.html][here]]) and the
msvcrt.dll and put them in the directry which include the xkeymacs.exe.
*** winodws git hub                                                   :git:
http://blog.csdn.net/wh_19910525/article/details/8128916

1. 下载msysgit
   目前windows版本的git有几种实现，但我们选择msysgit发行版，这是目前做
   得兼容性最好的。

   下载地址：http://code.google.com/p/msysgit/downloads/list

   使用默认配置安装Git。这个不用多说，一路Next就可以，如果对各种选项不
   熟悉，建议使用默认配.

2. ssh
   GitHub选择的默认通信方式是SSH，所以要先在Git里面生成SHH Key，打开
   Git Bash在其中输入如下命令：
   *ssh-keygen -t rsa -C "3sdfsf80@xinlang.com"*

   之后会让你选择是否对存放SSH Key的文件夹进行加密，一般都不需要的。一
   路回车，就OK了。

   在c盘，当前用户文件夹下，有个.ssh 文件夹，在里边 找到 id_rsa.pub文
   件，用记事本打开，复制其中的全部内容。

   登陆你的GitHub账户，依次点击Account Settings > SSH Public Keys >
   Add another public key，把id_rsa.pub中的内容拷贝进去 。

*** [[http://blog.csdn.net/wh_19910525/article/details/8128916][如何在windows下使用git及github仓库管理项目]]            :blog:git:github:


*第一，下载并安装git*


目前windows版本的git有几种实现，但我们选择msysgit发行版，这是目前做得*兼容性最好的*。

下载地址：[[http://code.google.com/p/msysgit/downloads/list]]

使用默认配置安装Git。这个不用多说，一路Next就可以，如果对各种选项不熟悉，建议使用默认配置，没问题的。



*第二，创建github账号*

**** 什么是Git和GitHub

*Git* ---The stupid content tracker,
傻瓜内容跟踪器，是一个由Linux内核开发者Linus为了更好地管理Linux内核开发而创立的*分布式版本控制软件*。

*GitHub* ---
学生做版本控制最讨厌的就是找服务器，配置太麻烦了。*GitHub这个网站为每个用户提供服务器托管其Git代码库，免费空间为300M*。注册GitHub后你就会有0.3G的免费空间，不过*只能创建公开项目*。

**** 为什么不选CVS或SVN

- Git提交/克隆/pull/push的速度更快
- Git的*绝大多数操作都可以在本地完成，不需要频繁连接服务器*。

--------------

**** 注册GitHub账号

- *GitHub网址在[[https://github.com/][这里]]*
- 点击上方导航条的[[https://github.com/plans][Signup and
   Pricing]]即可进入注册界面， 选择注册免费账户

[[http://oncoding.in/wp-content/uploads/2011/10/9cccbccb8c60.jpg][[[http://www.kuqin.com/upimg/allimg/111113/2304132200-1.jpg]]]]



- *GitHub选择的默认通信方式是SSH*，所以要先在Git里面生成SHH
   Key，打开Git Bash在其中输入如下命令：

*ssh-keygen -t rsa -C "3sdfsf80@xinlang.com"*

之后会让你选择是否对存放SSH
Key的文件夹进行加密，一般都不需要的。*一路回车，就OK了。*

- 在c盘，*当前用户*文件夹下，有个.ssh 文件夹，在里边 找到
   id_rsa.pub文件，用记事本打开，复制其中的全部内容。
- 登陆你的GitHub账户，依次点击/Account Settings/ > /SSH Public Keys/ >
   /Add another public key/，把id_rsa.pub中的内容拷贝进去 。
- 至此，基本的设置已经完成了。

成了。

--------------

**** 测试你的Git

- 经过上述配置，*你的Gti应该可以通过SSH连接GitHub服务器了，让我们来测试下*，输入如下命令：

[[http://oncoding.in/wp-content/uploads/2011/10/1.jpg][[[http://www.kuqin.com/upimg/allimg/111113/23041312D-3.jpg]]]]

- 会给你这样的提示：

[[http://oncoding.in/wp-content/uploads/2011/10/2.jpg][[[http://www.kuqin.com/upimg/allimg/111113/230413I29-4.jpg]]]]

- 输入yes，会显示：

[[http://oncoding.in/wp-content/uploads/2011/10/3.jpg][[[http://www.kuqin.com/upimg/allimg/111113/2304135U1-5.jpg]]]]

- 到这里，说明你的SSH运转良好。

如果提示你的密钥不正确，那么你需要重新确认上一步的操作是否完整无误。



*第三，建立本地git仓库*



首先，git要求使用者必须提供自己的身份标识，为此我们需要在git
bash中执行以下命令：

 *git config --global user.name  'aa.Tessst'
 git config --global user.email  fsc@sina.com*

 其次，选择git仓库目录

 我们*假设将git仓库目录放在D盘的OPENSource目录下*，可以通过在git
bash中执行以下命令完成：

 cd /d
 mkdir OPENSource

 注：git bash支持大多linux bash终端命令，你可以自己尝试更多终端操作。



最后，建立项目并初始化git仓库


我们的第一个项目是一个使用Python语言将XML文件转换成Python字典，通过执行以下命令完成此步骤：

 mkdir Python-XML2Dict
 cd Python-XML2Dict
 *git init


执行此操作后，git将在Python-XML2Dict目录下创建一个隐藏目录（.git），这个目录就是git用来管理软件版本的仓库。*


*第四，使用git管理项目*

  此步 和 在linux 上 使用 git 的 方法一样，具体参考 我的 其他 博文！



*第五，将项目提交到github管理，[[http://blog.csdn.net/wh_19910525/article/details/7438183][gitpush]]*

如果 *第二步 测试无错*，那么 经过 以下两步
就可以将本地的文件提交到github仓库了。

1、登录GitHub后，你可以在右上边靠中那里找到一个按钮“creat a New
Repository”，点击过后，*填入项目名称*、说明等
过后就可以创建了，然后会出现一个提示页面，记下类似*
git@github.com:XXX/XXX.git* 的地址，这个就是你这个项目的地址了。



2、

#+BEGIN_EXAMPLE
    1 git remote add origin git@github.com:XXX/XXX.git
    2 git push -u origin master //把本地 master 分支 推送到 服务器的master分支上，如果服务器没有此分支，就 新建 此分支。这也是 在服务器上新建分支的一种方法
#+END_EXAMPLE



这个=git@github.com:XXX/XXX.git=就是上面创建项目是生成的地址。现在打开你的项目网址，你就可以发现你的代码已经展示出来了。



*第六，直接 用 git pull 将项目 从 github 上 同步 下来
*

有两种方法：

*1、当git clone之后，直接git pull它会自动匹配一个正确的remote url*

是因为在config文件中配置了以下内容：

#+BEGIN_EXAMPLE
    1 [branch "master"]
    2     remote = origin
    3     merge = refs/heads/master
#+END_EXAMPLE

表明：

1.git处于master这个branch下时，默认的remote就是origin；

2.当在master这个brach下，使用指定remote和merge的git
pull时，使用默认的remote和merge。



*2、但是对于自己建的项目*，*并没有这块内容，需要自己配置*。

#+BEGIN_EXAMPLE
    1 git remote add -f origin login@git.sv.gnu.org:/srv/git/project.git  //若是 执行过 第五步，那么 这一句 就 不用了
    2 git config branch.master.remote origin  //这一步 设置： 把 master 分支上 的 默认服务器地址 设为 origin指向的地址
    3 git config branch.master.merge refs/heads/master   //这一步 设置：如果当前分支是 master 分支，那么 git pull之后，直接 把 “从 origin 下载 下来的 code合并到 master分支上“

    或者加上--global选项，对于全部项目都使用该配置。
#+END_EXAMPLE



建议：用第二种 方法，因为 如果 是 git clone的 项目，当 执行 git push
时，因为 *在 git  config里 url  是 只读方式*

[remote "origin"]
    fetch = +refs/heads/*:refs/remotes/origin/*
   * url = git://github.com/xxx/xxx.git*
 //*git@github.com:XXX/XXX.git 这才是 读写方式*


---------------------------------



如果提交了敏感信息，比如代码中设置的自己的密码什么的忘删除就上传上去了怎么办？

有两个方法：

1、重新修改本地代码，然后提交到服务器（覆盖），

2、直接登录 github
删除之前的项目。删除项目需要在GitHub网站上右上方找到*admin*按钮，进去后右边最下面有个删除的按钮，这样就可以删除了。



--------------------------



若是一个项目就托管在 GitHub 上。你可以把它的 URL
分享给每位对此项目感兴趣的人。本例的 URL 是
=http://github.com/testinguser/iphone_project=。而在项目页面的摘要部分，你会发现有两个
Git URL 地址，见 右图：

[[http://git-scm.com/figures/18333fig0408-tn.png]]


   右图的 摘要中的公共 URL 和私有 URL

Public Clone URL 是一个公开的，只读的 Git
URL，任何人都可以通过它克隆该项目。可以随意散播这个
URL，比如发布到个人网站之类的地方等等。

Your Clone URL 是一个基于 SSH 协议的可读可写 URL，只有使用与上传的 SSH
公钥对应的密钥来连接时，才能通过它进行读写操作。其他用户访问该项目页面时只能看到之前那个公共的
URL，看不到这个私有的 URL。

*** 捕获系统音频                                               :audio:tool:
- State "DONE"       from "TODO"       [2015-11-13 五 21:01]

FOR: 德语录制

Google *streaming audio recorder*

Wondershare Streaming Audio Recorder，简洁易用

Evernote & BaiduYun（破解）

虚拟机中运行的不能录制真实系统中的音频

*** 参考文献标准格式

**** 参考文献类型

+ 专著［M］
+ 论文集［C］
+ 报纸文章［N］
+ 期刊文章［J］
+ 学位论文［D］
+ 报告［R］
+ 标准［S］
+ 专利［P］
+ 论文集中的析出文献［A］

**** 电子文献类型

+ 数据库［DB］
+ 计算机［CP］
+ 电子公告［EB］

**** 电子文献的载体类型

+ 互联网［OL］
+ 光盘［CD］
+ 磁带［MT］
+ 磁盘［DK］

**** 专著、论文集、学位论文、报告

*［序号］主要责任者.文献题名［文献类型标识］.出版地：出版者，出版年.起止页码（可选）*
［1］刘国钧，陈绍业.图书馆目录［M］.北京：高等教育出版社，1957.15-18.

**** 期刊文章

*［序号］主要责任者.文献题名［J］.刊名，年，卷（期）：起止页码*
［1］何龄修.读南明史［J］.中国史研究，1998,(3):167-173.
［2］OU J P，SOONG T T，et al.Recent advance in research on applications of passive energy dissipation systems［J］.Earthquack Eng,1997,38(3):358-361.

**** 论文集中的析出文献

*［序号］析出文献主要责任者.析出文献题名［A］.原文献主要责任者（可选）.原文献题名［C］.出版地：出版者，出版年.起止页码*
［7］钟文发.非线性规划在可燃毒物配置中的应用［A］.赵炜.运筹学的理论与应用——中国运筹学会第五届大会论文集［C］.西安：西安电子科技大学出版社，1996.468.

**** 报纸文章

*［序号］主要责任者.文献题名［N］.报纸名，出版日期（版次）*
［8］谢希德.创造学习的新思路［N］.人民日报，1998-12-25（10）.

**** 电子文献

*[文献类型/载体类型标识]：[J/OL]网上期刊、[EB/OL]网上电子公告、*
*[M/CD]光盘图书、[DB/OL]网上数据库、[DB/MT]磁带数据库*
［序号］主要责任者.电子文献题名［电子文献及载体类型标识］.电子文献的出版或获得地址，发表更新日期/引用日期
［12］王明亮.关于中国学术期刊标准化数据库系统工程的进展［EB/OL］.http://www.cajcd.edu.cn/pub/wml.html，1998-08-16/1998-10-01.
［8］万锦.中国大学学报文摘（1983-1993）.英文版［DB/CD］.北京：中国大百
*科全书出版社，1996.

*** [[http://www.xp510.com/article/2564.html][关闭Win7 UAC教程]] :blog:uac:

相信每一个刚使用win7的人对于win7 UAC服务特别不舒服。每次操作时，都要等待一会，弹出来一个UAC提示。甚至很多人都开始对这个UAC反感。
 首先我们来讲一下UAC是什么？
UAC是User Account Control的缩写，也叫做用户帐户控制。从Windows Vista开始，微软为提高系统安全而引入的新技术。要求用户在执行，提供权限或管理员
密码，以此来提高系统的安全性。通过在这些操作启动前对其进行验证，UAC 可以帮助防止恶意软件和间谍软件在未经许可的情况下在计算机上进行安装或对计
算机进行更改。
下面我们以系统之家GHOST Win7_SP1纯净旗舰版V3.0为例，给大家讲解一下如何关闭win7 UAC服务。
1.点击windows 7开始按钮，在底下的输入框中输入MSCONFIG。之后，win7系统将弹出“系统配置”对话框。如下图：
\
2.选中“更改UAC设置”，并点击启动。弹出“用户账户控制设置”对话框。如下图：
 \
3.下拉到“从不通知”，然后点击确定，即可。这样，UAC的设置就完成了。
4.注意，关闭UAC要重启电脑才能生效。

好了，今天的教程关闭Win7 UAC到此为止。

*** [[http://lanbing510.info/2015/05/15/Cygwin.html][Windows下Cygwin的使用]]                        :cygwin:apt_cyg:blog_冰蓝:

**** 写在前面

有时候在Windows平台下很想用Linux下的一些小命令，比如diff，grep，sed等
等，打开虚拟机下的Linux太费时又占用很大的计算资源，于是这种情况下选择
了Cygwin。


**** 使用Cygwin安装软件

--------------

Cygwin安装后可用的包并不是特别多，用setup.exe安装起来很不人性话。还好，有apt-cyg，和apt-get
一样强大，有了 *apt-cyg* 安装软件变得so easy。

一、安装apt-cyg

在Cygwin下输入：

#+BEGIN_EXAMPLE
    lynx -source rawgit.com/transcode-open/apt-cyg/master/apt-cyg > apt-cyg
    install apt-cyg /bin
#+END_EXAMPLE

即完成安装。

二、使用

类似于apt-get，比如安装diff包，输入：

#+BEGIN_EXAMPLE
    apt-cyg install diffutils
#+END_EXAMPLE

即可

三、常见问题及解决

安装gcc g++直接apt-cyg install
gcc报错，于是找到setup.ini发现gcc的名字为gcc-core,于是改为apt-cyg
install gcc-core，成功安装；g++也是同样原理，找到名字为gcc-g++，apt-cyg
install gcc-g++成功。

**** 小结

安装完Cygwin及学会如何使用Cygwin安装各种软件包后，就可以尽情的在
Windows平台下享用Linux下各种神一样的工具们了。

*** [[https://app.yinxiang.com/Home.action#n=105bfce9-941a-454c-acc1-26d67434c546&b=f3a3ebdb-638e-4fde-8608-34ae1b790adc&ses=4&sh=1&sds=5&][如何把NH、KDH文件转换为PDF或者WORD文档]]                   :blog:caj:pdf:

在做毕业论文时不可避免的要下载中国期刊网上面的论文，这些文件又需要专门的阅读器，而大家更常用的文档格式是PDF或者WORD文档，不利于个人阅读，虽然CAJ浏览器可以把NH、KDH文件如何转成 txt格式，但是会出现乱码，并且不能转换图片；下面是转换这类文档的个人经验：
1. 转换成PDF文档
首先用高版本的CAJ浏览器打开文档，然后选择打印，在打开的“打印”设置窗口中将“打印机”栏中的“名称”设置为“*** PDF printer”字样，安装不同的PDF 阅读器，前面的单词不同，接下来设置打印属性，向平时打印一样，一般默认，最后点击“确定”，OK，耐心等待文档转换吧。
2. 转换成WORD文档
方法一
1、.若安装有PDF Professional，按照上述方法先转换成PDF文档，再把所得到的文件直接另存为WORD文档(.DOC)。
2.、若你的PDF阅读器不能把文档直接保存为WORD文档,使用第三方软件：PDF WORD 转换软件 如pdf2word和pdf to word
方法二
第一步：首先使用CAJ浏览器打开文档，接下来选择打印，在打开的“打印”设置窗口中将“打印机”栏中的“名称”设置为“Microsoft Office Document Image Writer”，确认后将该NH文件输出为MDI格式的虚拟打印文件。
提示：如果你在“名称”设置的下拉列表中没有找到“Microsoft Office Document Image Writer”项，那证明你在安装Office 2003的时候没有安装该组件，请使用Office 2003安装光盘中的“添加/删除组件”更新安装该组件。

第二步：运行Microsoft Office Document Imaging，并利用它来打开刚才保存的MDI文件，选择“工具→将文本发送到Word”菜单，并在弹出的窗口中勾选“在输出时保持图片版式不变”，确 认后系统提示“必须在执行此操作前重新运行OCR。这可能需要一些时间”，确认即可。

好象CAJ5.0以上版本可以转换为WORD文档,只是不可以转换图象，公式，图表，但是您可以用“复制图位”按钮，以图象方式复制到WORD文档.
CAJ支持另存为TXT，操作在“文件”选项里，但TXT为文本文件，不能保存图片，公式，图表等，可由TXT转为DOC后，通过“复制图位”按钮，以图象方式复制到WORD文档中去。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

方法四：
首先到中国知网（www.cnki.net） 下载CAJViewer阅读器，安装CAJViewer阅读器软件。运行CAJViewer阅读器并点击“文件”打开.CAJ、.NH、.KDH等格式文 件。接下来选择“文件→打印”菜单，在打开的“打印”设置窗口中将“打印机”栏中的“名称”设置为“Microsoft Office Document Image Writer”，确认后将.CAJ、.NH、.KDH等格式文件输出为MDI格式的虚拟打印文件。

（如果 你在“名称”设置的下拉列表中没有找到“Microsoft Office Document Image Writer”项，那证明你在安装Office 2003的时候没有安装该组件，请使用Office 2003安装光盘中的“添加/删除组件”更新安装该组件。）

运行Microsoft Office Document Imaging，并利用它来打开刚才保存的MDI文件，选择“工具→将文本发送到Word”菜单，并在弹出的窗口中勾选“在输出时保持图片版式不变”，确 认后系统提示“必须在执行此操作前重新运行OCR。这可能需要一些时间”，不用管它，点确认即可。
（目前，包括此工具在内的所有软件对PDF转DOC的识别率都不是特别完美，而且转换后会丢失原来的排版格式，所以大家在转换后还需要手工对其进行后期排版和校对工作。）

大功告成！补充一下，PDF格式文件也可以按照上面的方法转换成DOC格式文件。

还有一个方法如下所述：
首先用CAJViewer7.02版本阅读器打开nh文件，在你当前打开页的左上方有个保存为图片的按钮
， 把当前页面保存为图片。然后下载安装一个汉王6.0，安装好后打开。注意，此软件安装好后没有快捷方式，需要按照下面的步骤打开：开始--程序--汉王 ocr6.0--汉王ocr6.0.打开后按照下面的操作就可以识别图片，转换成文字。文件--打开图像--识别--开始识别--输出--到指定格式文 件，保存为txt文件就可以了。现在打开刚刚保存的文件，是不是看见文字转换好了！
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
百度知道的回答
如何将ＮＨ格式文件转为ＷＯＲＤ或文本文件？

我下载了一个ＮＨ格式的文件，现在想对其进行复制其中的一些内容．我从网上搜了一下，有的说先转成ＰＤＦ然后再编辑，也有的说从ＣＡＪ里可以识别后编辑．前一种方法，我从网上未找到相关软件，后一种方法我从ＣＡJ6.0中选中文字，右键文字识别，可识别不出来，一片空白．请大家帮帮忙．谢谢．
呵呵，自己找到答案了，
还是用的ＣＡＪ软件，7.0的，在http://www.cnki.net/software/xzydq.htm
这个网站上下的标准版的，呵呵，在线客服帮的忙．
看到许多人在找PDF转Word的软件，感觉大可不必，其实很多这类软件转换后是变成rtf格式，里边文字变得很小很难看，还得手动调字体，调格式。
    Word自身已经提供了任何文档文件转文字的功能，说白了就是Word自身的OCR工具。PDF、NH、CAJ等常用文档文件都可以通过此方法进行转换。以PDF为例，打开PDF文件后直接选择打印，打印机选择使用Microsoft Office Document Image Writer，这是Office自带的虚拟图像打印工具。确定之后自动存储为mdi文件。它默认会自动启动。此时可以继续另存为图片文件，用其他OCR工具识别，也可以在启动后的界面里直接选择工具－－将文本发送到word，选择一个存储的位置，确认后word会自动进行识别，稍等片刻一篇已经识别好的文本就出现了，并且文本字体十分清楚。相比其他识别工具，word的识别正确率非常高。
    当然，缺点是图片和表格框无法识别，但这也是其他软件的软肋，即便是rtf文件，表格也不那么正规。相比那么多的文本，这也不算什么了吧。
    除此以外，AutoCAD的打印以及其他程序都可以使用此功能

** PDF                                                                 :PDF:
*** pdftohmtl                                              :html:pdftohtml:
https://github.com/coolwanglu/pdf2htmlEX
*** pptx to pdf                                                       :ppt:

1. pptx -> odt
   *$ libreoffice --headless --convert-to odt demo.pptx*
2. odt -> pdf
   *$ unoconv -f pdf demo.odt*  # 继续使用libreoffice也可以

*** PDF提取矢量图片

Adobe专业版, 没有版权。

Foxit PDF Editor 也可。

可以利用PDF作为中介转换格式emf, wmf(矢量清晰格式)。

用途不多，毕竟图片多为 *位图*
1. 提取LOGO
2. 提取数学图形

*** wkhtmltopdf                                      :wkhtmltopdf:html:
**** reference

+ [[http://wkhtmltopdf.org/][Homepage]]
+ [[https://github.com/wkhtmltopdf/wkhtmltopdf][GitHub]]
+ [[http://wkhtmltopdf.org/libwkhtmltox/][doxygen]]
+ [[http://stackoverflow.com/questions/10981960/wkhtmltopdf-patched-qt][stackoverflow]]
+ [[http://park.jobdeer.com/discussion/10/wkhtmltopdf%E4%B8%AD%E6%96%87%E5%8F%82%E6%95%B0][wkhtmltopdf选项中文说明]]
+ [[http://wkhtmltopdf.org/usage/wkhtmltopdf.txt][document]]

**** intro                                                       :install:

1. what

   wkhtmltopdf and wkhtmltoimage are open source (LGPLv3) command line
   tools to render HTML into PDF and various image formats using the
   QT Webkit rendering engine.

   wkhtmltopdf/wkhtmtoimage 是开源的命令行工具，用于将HMTL渲染成PDF和
   多种图片格式。 它使用Qt Webkit作为渲染引擎。

2. 安装

   有源码，但不推荐以源码方式安装。（没有必要深入研究的东西不要瞎折腾，
   将精力花在更重要的地方）

   *apt-get 方式安装*

3. 使用

   *wkhtmltopdf [GLOBAL OPTION]... [OBJECT]... <output file>*

   + [object] 为输入支持，支持链接(link)形式，也支持文件(html)形式。

**** 选项

+ --allow <path>  允许加载从指定的文件夹中的文件或文件（可重复）
+ --book*  设置一会打印一本书的时候，通常设置的选项
+ --collate  打印多份副本时整理
+ --cookie <name> <value>  设置一个额外的cookie（可重复）
+ --cookie-jar <path>  读取和写入的Cookie，并在提供的cookie jar文件
+ --copies <number>  复印打印成pdf文件数（默认为1）
+ --cover* <url>  使用HTML文件作为封面。它会带页眉和页脚的TOC之前插入
+ --custom-header <name> <value>  设置一个附加的HTTP头（可重复）
+ --debug-javascript  显示的javascript调试输出
+ --default-header*  添加一个缺省的头部，与页面的左边的名称，页面数到右边，例如： --header-left '[webpage]' --header-right '[page]/[toPage]'  --header-line
+ --disable-external-links*  禁止生成链接到远程网页
+ --disable-internal-links*  禁止使用本地链接
+ --disable-javascript  禁止让网页执行JavaScript
+ --disable-pdf-compression*  禁止在PDF对象使用无损压缩
+ --disable-smart-shrinking*  禁止使用WebKit的智能战略收缩，使像素/ DPI比没有不变
+ --disallow-local-file-access  禁止允许转换的本地文件读取其他本地文件，除非explecitily允许用 --allow
+ --dpi <dpi>  显式更改DPI（这对基于X11的系统没有任何影响）
+ --enable-plugins  启用已安装的插件（如Flash
+ --encoding <encoding>  设置默认的文字编码
+ --extended-help  显示更广泛的帮助，详细介绍了不常见的命令开关
+ --forms*  打开HTML表单字段转换为PDF表单域
+ --grayscale  PDF格式将在灰阶产生
+ --help  Display help
+ --htmldoc  输出程序HTML帮助
+ --ignore-load-errors  忽略claimes加载过程中已经遇到了一个错误页面
+ --lowquality  产生低品质的PDF/ PS。有用缩小结果文档的空间
+ --manpage  输出程序手册页
+ --margin-bottom <unitreal>  设置页面下边距 (default 10mm)
+ --margin-left <unitreal>  将左边页边距 (default 10mm)
+ --margin-right <unitreal>  设置页面右边距 (default 10mm)
+ --margin-top <unitreal>  设置页面上边距 (default 10mm)
+ --minimum-font-size <int>  最小字体大小 (default 5)
+ --no-background  不打印背景
+ --orientation <orientation>  设置方向为横向或纵向
+ --page-height <unitreal>  页面高度 (default unit millimeter)
+ --page-offset* <offset>  设置起始页码 (default 1)
+ --page-size <size>  设置纸张大小: A4, Letter, etc.
+ --page-width <unitreal>  页面宽度 (default unit millimeter)
+ --password <password>  HTTP验证密码
+ --post <name> <value>  Add an additional post field (repeatable)
+ --post-file <name> <path>  Post an aditional file (repeatable)
+ --print-media-type*  使用的打印介质类型，而不是屏幕
+ --proxy <proxy>  使用代理
+ --quiet  Be less verbose
+ --read-args-from-stdin  读取标准输入的命令行参数
+ --readme  输出程序自述
+ --redirect-delay <msec>  等待几毫秒为JS-重定向(default 200)
+ --replace* <name> <value>  替换名称,值的页眉和页脚（可重复）
+ --stop-slow-scripts  停止运行缓慢的JavaScripts
+ --title <text>  生成的PDF文件的标题（第一个文档的标题使用，如果没有指定）
+ --toc*  插入的内容的表中的文件的开头
+ --use-xserver*  使用X服务器（一些插件和其他的东西没有X11可能无法正常工作）
+ --user-style-sheet <url>  指定用户的样式表，加载在每一页中
+ --username <username>  HTTP认证的用户名
+ --version  输出版本信息退出
+ --zoom <float>  使用这个缩放因子 (default 1)

*** [[http://linuxcommand.org/man_pages/pdfinfo1.html][pdfinfo]]                                                  :blog:pdfinfo:

**** NAME

#+BEGIN_EXAMPLE
           pdfinfo - Portable Document Format (PDF) document information extractor
           (version 3.01)

#+END_EXAMPLE

**** SYNOPSIS

#+BEGIN_EXAMPLE
           pdfinfo [options] [PDF-file]

#+END_EXAMPLE

**** DESCRIPTION

#+BEGIN_EXAMPLE
           Pdfinfo prints the contents of the ´Info’ dictionary (plus  some  other
           useful information) from a Portable Document Format (PDF) file.

           The ´Info’ dictionary contains the following values:

                  title
                  subject
                  keywords
                  author
                  creator
                  producer
                  creation date
                  modification date

           In addition, the following information is printed:

                  tagged (yes/no)
                  page count
                  encrypted flag (yes/no)
                  print and copy permissions (if encrypted)
                  page size
                  file size
                  linearized (yes/no)
                  PDF version
                  metadata (only if requested)

#+END_EXAMPLE

**** CONFIGURATION FILE

#+BEGIN_EXAMPLE
           Pdfinfo  reads a configuration file at startup.  It first tries to find
           the user’s private config file, ~/.xpdfrc.  If that doesn’t  exist,  it
           looks  for  a  system-wide config file, typically /etc/xpdfrc (but this
           location can be changed when pdfinfo is built).  See the xpdfrc(5)  man
           page for details.

#+END_EXAMPLE

**** OPTIONS

#+BEGIN_EXAMPLE
           Many  of  the following options can be set with configuration file com-
           mands.  These are listed in square brackets with the description of the
           corresponding command line option.

           -f number
                  Specifies  the  first  page  to  examine.  If multiple pages are
                  requested using the "-f" and "-l"  options,  the  size  of  each
                  requested  page  (and,  optionally,  the bounding boxes for each
                  requested page) are printed.  Otherwise, only page one is  exam-
                  ined.

           -l number
                  Specifies the last page to examine.

           -box   Prints the page box bounding boxes: MediaBox, CropBox, BleedBox,
                  TrimBox, and ArtBox.

           -meta  Prints document-level metadata.  (This is the "Metadata"  stream
                  from the PDF file’s Catalog object.)

           -enc encoding-name
                  Sets  the  encoding  to  use for text output.  The encoding-name
                  must be defined with the  unicodeMap  command  (see  xpdfrc(5)).
                  This defaults to "Latin1" (which is a built-in encoding).  [con-
                  fig file: textEncoding]

           -opw password
                  Specify the owner password for the  PDF  file.   Providing  this
                  will bypass all security restrictions.

           -upw password
                  Specify the user password for the PDF file.

           -cfg config-file
                  Read config-file in place of ~/.xpdfrc or the system-wide config
                  file.

           -v     Print copyright and version information.

           -h     Print usage information.  (-help and --help are equivalent.)

#+END_EXAMPLE

**** EXIT CODES

#+BEGIN_EXAMPLE
           The Xpdf tools use the following exit codes:

           0      No error.

           1      Error opening a PDF file.

           2      Error opening an output file.

           3      Error related to PDF permissions.

           99     Other error.

#+END_EXAMPLE

**** AUTHOR

#+BEGIN_EXAMPLE
           The pdfinfo software and documentation are copyright 1996-2005 Glyph  &
           Cog, LLC.

#+END_EXAMPLE

**** SEE ALSO

#+BEGIN_EXAMPLE
           xpdf(1),  pdftops(1),  pdftotext(1),  pdffonts(1),  pdftoppm(1), pdfim-
           ages(1), xpdfrc(5)
           http://www.foolabs.com/xpdf/



                                    17 August 2005                      pdfinfo(1)
#+END_EXAMPLE

--------------

Man(1) output converted with
[[http://www.oac.uci.edu/indiv/ehood/man2html.html][man2html]]

*** pdfoutline                                             :pdfoutline:pdf:
**** TODO 中文大纲
**** reference
+ [[http://manpages.ubuntu.com/manpages/hardy/man1/pdfoutline.1.html][ubuntu man]]
+ [[http://sourceforge.net/projects/fntsample/?source=typ_redirect][sourceforge]]

**** intro
1. what

   pdfoutline is a part of *fntsample*, which can add outlines to pdf
   files.

   pdfoutline - *add outlines (aka bookmarks) to PDF files*

   给PDF文件添加大纲/目录

2. 安装
   + $ sudo apt-get install fntsample
   + sourcecodae

3. Usage

   *pdfoutline input.pdf outlines.txt output.pdf*

   pdfoutline accepts no options.

4. DESCRIPTION

   pdfoutline reads input file given as first argument, adds outlines
   from text file given as second argument, and saves result to file
   with  name given as third argument.

   File with outlines information should consist of lines in the following
   format: *<level> <page> Outline text*

   <level> and <page> should be integers.  Each field should be  separated
   by  *exactly one space symbol*.  All values for <level> should be greater
   or equal than that of the first line.  Page numeration starts with 1.

   Outlines file can contain comments that start with # in  first  column.
   Comments and empty lines are ignored.


5. EXAMPLES

   Here is example of outlines data file:
   #+BEGIN_EXAMPLE
     0 1 Document title
     1 1 Chapter 1
     2 1 Chapter 1.1
     2 2 Chapter 1.2
     1 3 Chapter 2
   #+END_EXAMPLE

   Using this file will result in outlines like the following:

   #+BEGIN_EXAMPLE
     +-Chapter 1
     | +-Chapter 1.1
     | +-Chapter 1.2
     +-Chapter 2
   #+END_EXAMPLE

**** [[http://manpages.ubuntu.com/manpages/lucid/man1/pdfoutline.1.html][Ubuntu Manpage: pdfoutline - add outlines (aka bookmarks) to PDF files]] :blog:

***** *NAME*

#+BEGIN_EXAMPLE
           pdfoutline - add outlines (aka bookmarks) to PDF files
#+END_EXAMPLE

***** *SYNOPSIS*

#+BEGIN_EXAMPLE
           pdfoutline input.pdf outlines.txt output.pdf
#+END_EXAMPLE

***** *DESCRIPTION*

#+BEGIN_EXAMPLE
           pdfoutline reads input file given as first argument, adds outlines from
           text file given as second argument, and saves result to file with  name
           given as third argument.

           File with outlines information should consist of lines in the following
           format:
                  <level> <page> Outline text

           <level> and <page> should be integers.  Each field should be  separated
           by  exactly one space symbol.  All values for <level> should be greater
           or equal than that of the first line.  Page numeration starts with 1.

           Outlines file can contain comments that start with # in  first  column.
           Comments and empty lines are ignored.
#+END_EXAMPLE

***** *OPTIONS*

#+BEGIN_EXAMPLE
           pdfoutline accepts no options.
#+END_EXAMPLE

***** *EXAMPLES*

#+BEGIN_EXAMPLE
           Here is example of outlines data file:
                  0 1 Document title
                  1 1 Chapter 1
                  2 1 Chapter 1.1
                  2 2 Chapter 1.2
                  1 3 Chapter 2

           Using this file will result in outlines like the following:
                  Document title
                  +-Chapter 1
                  | +-Chapter 1.1
                  | +-Chapter 1.2
                  +-Chapter 2
#+END_EXAMPLE

***** *AUTHOR*

#+BEGIN_EXAMPLE
           pdfoutline author is Eugeniy Meshcheryakov <eugen@debian.org>
           pdfoutline   is   part   of   fntsample   and  can  be  downoaded  from
           <http://sourceforge.net/projects/fntsample>.

                                      2009-11-17                     pdfoutline(1)
#+END_EXAMPLE

*** gs                                                        :gs:pdf:tool:

**** intro
*ghostscript* : an interpreter for the PostScript language and for
PDF.

*解释器*

**** man
$ gs -help

#+BEGIN_EXAMPLE
  GPL Ghostscript 9.10 (2013-08-30)
  Copyright (C) 2013 Artifex Software, Inc.  All rights reserved.
  Usage: gs [switches] [file1.ps file2.ps ...]
  Most frequently used switches: (you can use # in place of =)
   -dNOPAUSE           no pause after page   | -q       `quiet', fewer messages
   -g<width>x<height>  page size in pixels   | -r<res>  pixels/inch resolution
   -sDEVICE=<devname>  select device         | -dBATCH  exit after last file
   -sOutputFile=<file> select output file: - for stdout, |command for pipe,
                                           embed %d or %ld for page #
  Input formats: PostScript PostScriptLevel1 PostScriptLevel2 PostScriptLevel3 PDF
  Default output device: x11alpha
  ...
#+END_EXAMPLE


**** 转换pdf为ppt                                             :ppt:office:

The desired result can also be achieved without proprietary tools. If
you have GhostScript installed, you can convert your PDF presentation
into a set of JPG images using:

#+BEGIN_EXAMPLE
gs -dNOPAUSE -dBATCH -dSAFER -dGraphicsAlphaBits=4  \
   -dTextAlphaBits=4 -sDEVICE=jpeg -r300 \
   -sOutputFile='page-%00d.jpg' YOURFILE.pdf
#+END_EXAMPLE

Then, with the plugin for OpenOffice/LibreOffice create a presentation
where each image fills exactly one slide. You can also easily keep the
order of the pages by choosing the plugin option "natural sorting".


*Edit -> Link -> 断开链接*  否则以链接形式插入。

***** 小结
1. 使用gs转换为图片
2. 将图片插入LibreOffice中
3. 保存时断开链接

**** Merge PDF

*多个PDF文件的合并gs* :

#+begin_latex
\begin{minted}[frame=single, mathescape]{sh}
gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=out.pdf  *.pdf
\end{minted}
#+end_latex

就会生成一个名为out.pdf的文件.但要保证当前目录下没有out.pdf这个文件.

**** reference

+ [[http://www.ghostscript.com/][Homepage]]
+ [[http://superuser.com/questions/268244/how-to-convert-pdf-to-ppt-or-odp][convert pdf to ppt]]
+ [[http://stackoverflow.com/questions/8158584/ghostscript-to-merge-pdfs-compresses-the-result][stackoverflow: gs to merge PDFs *compresses* the result]]

*** PDFtk: The PDF Toolkit                                          :pdftk:
**** [[http://seisman.info/introduction-to-pdftk.html][PDF合并和分割工具---PDFtk]]
***** [[#id4][简介]]

PDFtk是什么？我觉得官网的一句话解释得很好。

#+BEGIN_QUOTE
  If PDF is electronic paper, then PDFtk is an electronic
  staple-remover, hole-punch, binder, secret-decoder-ring, and
  X-Ray-glasses. PDFtk is a simple tool for doing everyday things with
  PDF documents.
#+END_QUOTE

其官方网站为： [[http://www.pdflabs.com/tools/pdftk-the-pdf-toolkit]]

PDFtk目前分为三个版本：

-  PDFtk Server：命令行工具。支持windows、Linux、Mac。
-  PDFtk Free：图形界面基础免费版；仅限windows用户；功能仅限于PDF合并和分割；
-  PDFtk Pro：图形界面专业收费版；仅限windows用户，可以对PDF文档进行合并、分割、旋转、加水印、加邮戳、加密。

对于Linux用户，唯一的选择是免费的PDFtk Server，其功能与收费PDFtk Pro完
全相同，只是没有GUI而已。作者还是很厚道的。

Linux的各个发行版的官方源中基本都有该软件，直接apt-get或者yum安装即可。

***** [[#id5][功能]]

-  合并PDF；
-  分割PDF页面；
-  旋转PDF文档或页面；
-  PDF解密；（不是破解）
-  PDF加密；
-  用X/FDF填写PDF表格；
-  从PDF表格中生成PDF Data Stencils；
-  加背景水印或前景印章；
-  报告PDF Metrics，书签和元数据；
-  增加/更新PDF书签或元数据；
-  给PDF页面或文档加附件；
-  解压PDF附件；
-  分解PDF文档为多个单页；
-  解压缩和重压缩页面流；
-  修复受损的PDF文档；

这功能完全可以与Adobe Acrobat相媲美了，更重要的是PDFtk支持Linux且完全
免费。（个人用户免费，若用于商业用途需付费）。

***** [[#id6][用法示例]]

具体选项看这里： [[http://www.pdflabs.com/docs/pdftk-man-page/]]

下面给出一些常见的例子。例子原文在：
[[http://www.pdflabs.com/docs/pdftk-cli-examples/]]

****** 合并奇偶
扫描一本书，odd.pdf为书的全部奇数页，even.pdf为书的全部偶数页，下面的
命令可以将两个pdf合并成页码正常的书:

#+BEGIN_EXAMPLE
pdftk A=odd.pdf B=even.pdf shuffle A B output collated.pdf
#+END_EXAMPLE

****** 如果odd.pdf是逆序的:

#+BEGIN_EXAMPLE
pdftk A=odd.pdf B=even.pdf shuffle Aend-1 B output collated.pdf
#+END_EXAMPLE

****** 加密PDF:

#+BEGIN_EXAMPLE
pdftk secured.pdf input_pw foopass output unsecured.pdf
#+END_EXAMPLE

****** PDF 128位加密，保留全部权限:

#+BEGIN_EXAMPLE
pdftk 1.pdf output 1.128.pdf owner_pw foopass
#+END_EXAMPLE

****** PDF 128位加密，保留全部权限，打开文档需输入密码”baz”:

#+BEGIN_EXAMPLE
pdftk 1.pdf output 1.128.pdf owner_pw foo user_pw baz
#+END_EXAMPLE

****** PDF 128位加密，打开文档需输入密码”baz”，保留打印之外的其他权限:

#+BEGIN_EXAMPLE
    pdftk 1.pdf output 1.128.pdf owner_pw foo user_pw baz allow printing
#+END_EXAMPLE

****** 合并in1.pdf和in2.pdf到新PDF中:

#+BEGIN_EXAMPLE
pdftk in1.pdf in2.pdf cat output out1.pdf
#+END_EXAMPLE

****** 或（使用句柄）:

#+BEGIN_EXAMPLE
pdftk A=in1.pdf B=in2.pdf cat A B output out1.pdf
#+END_EXAMPLE

****** 或（使用通配符）:

#+BEGIN_EXAMPLE
pdftk *.pdf cat output combined.pdf
#+END_EXAMPLE

****** 去除in1.pdf中的第13页，并创建out1.pdf:

#+BEGIN_EXAMPLE
pdftk in.pdf cat 1-12 14-end output out1.pdf
#+END_EXAMPLE

****** 或

#+BEGIN_EXAMPLE
pdftk A=in1.pdf cat A1-12 A14-end output out1.pdf
#+END_EXAMPLE

****** 对输出进行40位加密，撤销所有权限，设置owner密码为foopass:

#+BEGIN_EXAMPLE
pdftk 1.pdf 2.pdf cat output 3.pdf encrypt_40bit owner_pw foopass
#+END_EXAMPLE

****** 合并两个文件，其中一个需要被加密。对输出不加密:

#+BEGIN_EXAMPLE
pdftk A=secured.pdf 2.pdf input_pw A=foopass cat output 3.pdf
#+END_EXAMPLE

****** 解压PDF页面流，然后就可以在文本编辑器中编辑PDF文件:

#+BEGIN_EXAMPLE
pdftk doc.pdf output doc.unc.pdf uncompress
#+END_EXAMPLE

****** 压缩PDF:

#+BEGIN_EXAMPLE
pdftk mydoc.pdf output mydoc.clear.pdf compress
#+END_EXAMPLE

****** 修复破损的PDF:

#+BEGIN_EXAMPLE
pdftk broken.pdf output fixed.pdf
#+END_EXAMPLE

****** 将一个PDF文档分割成一页一个文档:

#+BEGIN_EXAMPLE
pdftk in.pdf burst
#+END_EXAMPLE

****** 将一个PDF文档分割成一页一个文档，并加密，允许低质量的打印:

#+BEGIN_EXAMPLE
pdftk in.pdf burst owner_pw foopass allow DegradedPrinting
#+END_EXAMPLE

****** 获取PDF问的元数据和书签信息:

#+BEGIN_EXAMPLE
pdftk in.pdf dump_data output report.txt
#+END_EXAMPLE

****** 将PDF第一页顺时针旋转90度:

#+BEGIN_EXAMPLE
pdftk in.pdf cat 1east 2-end output out.pdf
#+END_EXAMPLE

****** 将整个PDF文档旋转180度:

#+BEGIN_EXAMPLE
pdftk in.pdf cat 1-endsouth output out.pdf
#+END_EXAMPLE

**** 测试

#+BEGIN_EXAMPLE
  Desktop $ pdftk  ~/Wally/Reference/Guide/Doxygen使用教程.pdf shuffle 5-10 output out.pdf
#+END_EXAMPLE

效率极高，应该经常使用
**** 给PDF增加水印

hint: pdftk

**** reference

+ [[https://www.pdflabs.com/][Homepage]]

**** [[http://seisman.info/introduction-to-pdftk.html][PDF合并和分割工具---PDFtk]]                                      :blog:

***** [[#id4][简介]]

PDFtk是什么？我觉得官网的一句话解释得很好。

#+BEGIN_QUOTE
  If PDF is electronic paper, then PDFtk is an electronic
  staple-remover, hole-punch, binder, secret-decoder-ring, and
  X-Ray-glasses. PDFtk is a simple tool for doing everyday things with
  PDF documents.
#+END_QUOTE

其官方网站为： [[http://www.pdflabs.com/tools/pdftk-the-pdf-toolkit]]

PDFtk目前分为三个版本：

- PDFtk Server：命令行工具。支持windows、Linux、Mac。
- PDFtk Free：图形界面基础免费版；仅限windows用户；功能仅限于PDF合并和分割；
- PDFtk Pro：图形界面专业收费版；仅限windows用户，可以对PDF文档进行合并、分割、旋转、加水印、加邮戳、加密。

对于Linux用户，唯一的选择是免费的PDFtk
Server，其功能与收费PDFtk Pro完全相同，只是没有GUI而已。作者还是很厚道的。

Linux的各个发行版的官方源中基本都有该软件，直接apt-get或者yum安装即可。

***** [[#id5][功能]]

- 合并PDF；
- 分割PDF页面；
- 旋转PDF文档或页面；
- PDF解密；（不是破解）
- PDF加密；
- 用X/FDF填写PDF表格；
- 从PDF表格中生成PDF Data Stencils；
- 加背景水印或前景印章；
- 报告PDF Metrics，书签和元数据；
- 增加/更新PDF书签或元数据；
- 给PDF页面或文档加附件；
- 解压PDF附件；
- 分解PDF文档为多个单页；
- 解压缩和重压缩页面流；
- 修复受损的PDF文档；

这功能完全可以与Adobe Acrobat相媲美了，更重要的是PDFtk支持Linux且完全免费。（个人用户免费，若用于商业用途需付费）。

***** [[#id6][用法示例]]                                                  :example:

具体选项看这里： [[http://www.pdflabs.com/docs/pdftk-man-page/]]

下面给出一些常见的例子。例子原文在：
[[http://www.pdflabs.com/docs/pdftk-cli-examples/]]

扫描一本书，odd.pdf为书的全部奇数页，even.pdf为书的全部偶数页，下面的命令可以将两个pdf合并成页码正常的书:

#+BEGIN_EXAMPLE
    pdftk A=odd.pdf B=even.pdf shuffle A B output collated.pdf
#+END_EXAMPLE

如果odd.pdf是逆序的:

#+BEGIN_EXAMPLE
    pdftk A=odd.pdf B=even.pdf shuffle Aend-1 B output collated.pdf
#+END_EXAMPLE

加密PDF:

#+BEGIN_EXAMPLE
    pdftk secured.pdf input_pw foopass output unsecured.pdf
#+END_EXAMPLE

PDF 128位加密，保留全部权限:

#+BEGIN_EXAMPLE
    pdftk 1.pdf output 1.128.pdf owner_pw foopass
#+END_EXAMPLE

PDF 128位加密，保留全部权限，打开文档需输入密码”baz”:

#+BEGIN_EXAMPLE
    pdftk 1.pdf output 1.128.pdf owner_pw foo user_pw baz
#+END_EXAMPLE

PDF 128位加密，打开文档需输入密码”baz”，保留打印之外的其他权限:

#+BEGIN_EXAMPLE
    pdftk 1.pdf output 1.128.pdf owner_pw foo user_pw baz allow printing
#+END_EXAMPLE

合并in1.pdf和in2.pdf到新PDF中:

#+BEGIN_EXAMPLE
    pdftk in1.pdf in2.pdf cat output out1.pdf
#+END_EXAMPLE

或（使用句柄）:

#+BEGIN_EXAMPLE
    pdftk A=in1.pdf B=in2.pdf cat A B output out1.pdf
#+END_EXAMPLE

或（使用通配符）:

#+BEGIN_EXAMPLE
    pdftk *.pdf cat output combined.pdf
#+END_EXAMPLE

去除in1.pdf中的第13页，并创建out1.pdf:

#+BEGIN_EXAMPLE
    pdftk in.pdf cat 1-12 14-end output out1.pdf
#+END_EXAMPLE

或

#+BEGIN_EXAMPLE
    pdftk A=in1.pdf cat A1-12 A14-end output out1.pdf
#+END_EXAMPLE

对输出进行40位加密，撤销所有权限，设置owner密码为foopass:

#+BEGIN_EXAMPLE
    pdftk 1.pdf 2.pdf cat output 3.pdf encrypt_40bit owner_pw foopass
#+END_EXAMPLE

合并两个文件，其中一个需要被加密。对输出不加密:

#+BEGIN_EXAMPLE
    pdftk A=secured.pdf 2.pdf input_pw A=foopass cat output 3.pdf
#+END_EXAMPLE

解压PDF页面流，然后就可以在文本编辑器中编辑PDF文件:

#+BEGIN_EXAMPLE
    pdftk doc.pdf output doc.unc.pdf uncompress
#+END_EXAMPLE

压缩PDF:

#+BEGIN_EXAMPLE
    pdftk mydoc.pdf output mydoc.clear.pdf compress
#+END_EXAMPLE

修复破损的PDF:

#+BEGIN_EXAMPLE
    pdftk broken.pdf output fixed.pdf
#+END_EXAMPLE

将一个PDF文档分割成一页一个文档:

#+BEGIN_EXAMPLE
    pdftk in.pdf burst
#+END_EXAMPLE

将一个PDF文档分割成一页一个文档，并加密，允许低质量的打印:

#+BEGIN_EXAMPLE
    pdftk in.pdf burst owner_pw foopass allow DegradedPrinting
#+END_EXAMPLE

获取PDF问的元数据和书签信息:

#+BEGIN_EXAMPLE
    pdftk in.pdf dump_data output report.txt
#+END_EXAMPLE

将PDF第一页顺时针旋转90度:

#+BEGIN_EXAMPLE
    pdftk in.pdf cat 1east 2-end output out.pdf
#+END_EXAMPLE

将整个PDF文档旋转180度:

#+BEGIN_EXAMPLE
    pdftk in.pdf cat 1-endsouth output out.pdf
#+END_EXAMPLE

*** briss                                                           :briss:

**** reference

- [[http://sourceforge.net/projects/briss/][Homepage]]

**** installation

1. download

2. mv to /opt

3. 建立启动脚本

   #+BEGIN_SRC sh :results output
   cat /opt/briss-0.9/briss
   #+END_SRC

   #+RESULTS:
   : #!/usr/bin/env bash
   :
   : java -jar /opt/briss-0.9/briss-0.9.jar

4. 建立软链

   #+BEGIN_SRC sh :results output
   ls -l /usr/local/bin/briss
   #+END_SRC

   #+RESULTS:
   : lrwxrwxrwx 1 root root 20  1月 12 11:11 /usr/local/bin/briss -> /opt/briss-0.9/briss

*** Foxit Reader                                              :foxitreader:

**** Linux 版安装

1. 官网下载：https://www.foxitsoftware.com/products/pdf-reader/
2. .run 可执行文件，安装至 /opt 下
3. 界面较 Windows 版，简化过多，功能不全，体验不好

*还是使用 wine foxitreader 习惯*

**** Foxit Reader 切换标签页热键

C-<TAB>

*** latex2html                                           :latex:latex2html:

**** reference

- https://www.ctan.org/pkg/latex2html?lang=en
- https://www.ctan.org/tex-archive/support/latex2html
- [[~/Wally/Reference/Manual/LaTeX2HtmlManual.pdf][LaTeX2HtmlManual.pdf]]

**** install                                                     :install:

#+BEGIN_EXAMPLE
$ ./configure & make & sudo make install
#+END_EXAMPLE

*** epstopdf                                                     :epstopdf:

**** reference

- [[https://www.ctan.org/pkg/epstopdf][CTan: epstopdf]]
- [[~/Wally/Reference/Manual/EpstopdfManual.pdf][EpstopdfManual.pdf]]

**** overview

*Convert EPS to 'encapsulated' PDF using Ghostscript.*

Epstopdf is a =Perl script= that converts an EPS file to an
‘encapsulated’ PDF file (a single page file whose media box is the
same as the original EPS’s bounding box). The resulting file suitable
for inclusion by pdfTEX as an image. The script is adapted to run both
on Windows and on Unix-alike systems.

The script makes use of *Ghostscript* for the actual conversion to
PDF. It assumes Ghostscript version 6.51 or later, and (by default)
suppresses its automatic rotation of pages where most of the text is
not horizontal.

LATEX users may make use of the epstopdf package, which will run the
epstopdf script “on the fly”, thus giving the illusion that pdfLATEX
is accepting EPS graphic files.

**** help

#+BEGIN_EXAMPLE
 $ epstopdf --help
epstopdf ($Id: epstopdf.pl 36129 2015-01-24 00:30:11Z karl $) 2.23
Usage: epstopdf [OPTION]... [EPSFILE]

Convert EPS to PDF (or other formats), by default using Ghostscript.
#+END_EXAMPLE

*** [[http://blog.csdn.net/zd0303/article/details/7775657][PDF文档的矢量图提取详解]]                               :blog:eps:矢量图:


在做软件的时候，经常需要用到一些LOGO图片。如何从素材文档中提取出高分辨
率、背景透明的LOGO是我一直关注的问题。对于素材文档是JPG、BMP等点阵格式
的图片，那没有办法，只能老老实实地抠出来。不过很多LOGO图片，一般是PDF
格式或EPS格式的文档的。假如这些文档中的LOGO是以矢量图的形式存在的话，
就可以从这些文档中提取出任意分辨率的LOGO了。本文以ST的LOGO为例，说明提
取的过程。

*1. PDF文档里面的矢量图*

PDF文件很常用，很早就知道，PDF里面的文字一般是用矢量的方式保存的。直到
最近，才发现原来PDF除了能贴点阵图之外，还可以存矢量图（比较孤陋寡闻，
呵呵）。举例说明PDF里面的矢量图。下图是ST公司的某芯片手册PDF文档里面的
LOGO放大到1200%的效果，依然平滑，没有锯齿。很明显，这个LOGO就是矢量图。

#+DOWNLOADED: http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/ST_LOGO.JPG @ 2016-01-25 16:26:04
 [[~/Wally/Journal/Figure/.org-download/Tools/ST_LOGO_2016-01-25_16:26:04.JPG]]


*2. EPS文档*

以前没有怎么接触过EPS文档。前一阵提取一个LOGO，同时有PDF和EPS两种格式，
但是EPS格式的文档用Photoshop却死活打不开。于是没有管它。后来google了一
下，大致了解了一下EPS文档格式：

eps 文件是封装的PostScript（Encapsulated
PostScript）格式。PostScript语言是Adobe
公司设计用于向任何支持PostScript语言的打印机打印文件的页面描述语言。除了它是被优化用于纸张上打印文字和图像之外，它像Basjc
语言、C语言或任何其它编程语言一样。当你在
PostScript打印机上工作并告诉文字处理器（或任何其它的应用程序）打印页面时，计算机就会用PostScript语言编写一个程序描述该页面，并将这个程序传送给打印机。打印机实际上其中装有一台功能齐全的计算机和PostScript
语言解释器执行这个程序，将图形画在内存中的虚拟纸张上，然后将其打印到纸上。

直到今天才无意中发现，原来PDF文档可以导出为EPS格式，然后用Photoshop打开这个EPS文件，就可以获得任意分辨率的图片。下面介绍这个提取过程。

*3. 提取过程详解*

首先要说一下用到的辅助工具：PDF编辑器。因为一般PDF是以页面的形式存在的，如果直接导出到EPS文件，那么在用Photoshop打开EPS文件的时候，由于使用的分辨率很高，会占用大量内存。因此，需要用PDF编辑器把想要的LOGO复制出来，其余的“咔嚓”掉。我使用的PDF编辑器是Foxit
PDF Editor，下面以此为例说明。

*第一步：在Foxit PDF Editor中打开想要提取的PDF文件，选定矢量图，然后复制。*

#+DOWNLOADED: http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/1.JPG @ 2016-01-25 16:26:38
 [[~/Wally/Journal/Figure/.org-download/Tools/1_2016-01-25_16:26:38.JPG]]



*第二步：在Foxit PDFEditor中新建PDF文档，要注意文档页面尽量小，恰好装
下这个图片就好了。这里选择宽80，高60。*

#+DOWNLOADED: http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/2.JPG @ 2016-01-25 16:26:55
 [[~/Wally/Journal/Figure/.org-download/Tools/2_2016-01-25_16:26:55.JPG]]

选择“粘贴”之后，图片就被复制到新建的PDF文档里面了。

#+DOWNLOADED: http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/3.JPG @ 2016-01-25 16:27:03
 [[~/Wally/Journal/Figure/.org-download/Tools/3_2016-01-25_16:27:03.JPG]]


稍微发挥一下技巧，会发现其实复制的内容并不是全都有用的：Ctrl+A全选，将选择的内容移动到灰色区域，发现刚才把多余的白色背景也拷贝了进来。

#+DOWNLOADED: http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/4.JPG @ 2016-01-25 16:27:08
 [[~/Wally/Journal/Figure/.org-download/Tools/4_2016-01-25_16:27:08.JPG]]

单击白色背景区域将其选择，按DEL键删除，变成了这个样子：

#+DOWNLOADED: http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/5.JPG @ 2016-01-25 16:27:17
 [[~/Wally/Journal/Figure/.org-download/Tools/5_2016-01-25_16:27:17.JPG]]

全选图形，将它放回文档的页面区域即可。最后保存该PDF文档。

*第三步：由PDF导出EPS文档。*

使用Acrobat 8 Professional打开刚才生成的PDF文档，选择“文件
(F)”-->“导出(T)”-->“PostScript”-->“内嵌式PostScript”将其导出到
EPS文件（至于什么版本的Acrobat有这个功能，我没有研究过，反正Acrobat 8
Professional可以）。

*第四步：使用Photoshop将EPS矢量图打开。*

这是最后一步，也是体会收获喜悦的一步，因为在这里你可以设置图片为任意大的分辨率。

#+DOWNLOADED: http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/6.JPG @ 2016-01-25 16:27:45
 [[~/Wally/Journal/Figure/.org-download/Tools/6_2016-01-25_16:27:45.JPG]]


点“确定”之后，得到的就是一个背景透明的高分辨率的图片了。补充一下，此时的图片已经是点阵图了，也就是说，如果你在这里放大，就会失真了。

#+DOWNLOADED: http://p.blog.csdn.net/images/p_blog_csdn_net/zoogar/EntryImages/20091204/7.JPG @ 2016-01-25 16:27:49
 [[~/Wally/Journal/Figure/.org-download/Tools/7_2016-01-25_16:27:49.JPG]]

好了，大功告成。这个时候，只需要保存好EPS文件，以后再用到这个图片的时候，用Photoshop打开它，便可以得到任意你想要的分辨率图片了。

*** [[http://seisman.info/merge-multiple-pdfs.html][Linux下合并PDF]]                                             :blog:merge:
**** [[#id5][cpdf]]

[[http://community.coherentpdf.com/][cpdf]]全称是Coherent PDF Command Line Tools，是一个强大的PDF处理工具。
PDF合并只是它的一个功能之一。

#+BEGIN_EXAMPLE
    cpdf input1.pdf input2.pdf -o output.pdf
#+END_EXAMPLE

**** [[#id6][pdfunite]]

=pdfunite= 是 [[http://poppler.freedesktop.org][Poppler]] 提供的一个工具，一般系统都已经安装了Poppler，所
以这个工具在Linux下是很常见的。

#+BEGIN_EXAMPLE
    pdfunite input1.pdf input2.pdf input3.pdf output.pdf
#+END_EXAMPLE

该命令用法简单，没有多余的选项，需要注意的是该命令的最后一个PDF文件为
输出文件名。

**** [[#id7][pdfjam]]

如果你安装了TeXLive，并且安装了 [[http://www.ctan.org/tex-archive/macros/latex/contrib/pdfpages/][pdfpage]] 包，则其中包含了
=pdfjam= 工具。

#+BEGIN_EXAMPLE
    pdfjam input1.pdf input2.pdf input3.pdf -o output.pdf
#+END_EXAMPLE

该命令的选项很多，可以通过 =pdfjam --help= 查看。

=pdfjoin= 是 =pdfjam= 的一个封装，也可以直接使用:

#+BEGIN_EXAMPLE
    pdfjoin a.pdf b.pdf
#+END_EXAMPLE

**** [[#id8][pdftk]]

[[https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/][pdftk]] 是专门用于处理PDF文档的一套工具。在大多数发行版中都可以直接安装
使用。

#+BEGIN_EXAMPLE
    pdftk input1.pdf input2.pdf input3.pdf cat output output.pdf
#+END_EXAMPLE

pdftk的选项很多，用法复杂，可以参考 [[http://seisman.info/introduction-to-pdftk.html][PDF合并和分割工具---PDFtk]] 。

**** [[#id9][gs]]

[[http://www.ghostscript.com][GhostScript ]]不仅可以用于处理PS，也可以用于处理PDF文档。

#+BEGIN_EXAMPLE
    gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=out.pdf in1.pdf in2.pdf
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -dPDFSETTINGS=/prepress -sOutputFile=out.pdf in1.pdf in2.pdf
#+END_EXAMPLE

**** [[#id10][参考]]

- [[https://blog.dbrgn.ch/2013/8/14/merge-multiple-pdfs/]]
- [[http://stackoverflow.com/questions/2507766/merge-convert-multiple-pdf-files-into-one-pdf]]
*** How to reduce PDF file size in Linux                             :blog:


Using a single line of GhostScript command on my Ubuntu’s terminal, I
was able to reduce the size of a  PDF file from 6 MB to approximately
1 MB:

#+BEGIN_EXAMPLE
gs -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -sOutputFile=output.pdf input.pdf
#+END_EXAMPLE

You can also use the following parameters for -dPDFSETTINGS instead of
/screen:

/screen – Lowest quality, lowest size
/ebook – Moderate quality
/printer – Good quality
/prepress – Best quality, highest size

*** [[http://www.cnblogs.com/xkfz007/articles/2182480.html][Linux 中将多个Word文档转换成PDF格式的方法及多个PDF文件的合并]] :blog:word:

在Linux中常常涉及到多种文档格式，如doc、txt、html、rtf等等。为了方便文件传递，就可能需要在各种格式之间进行转换。OpenOffice.Org可以方便的打开多各文档格式并按需进行转换，但要一次处理大量文件或要编写脚本进行转换时，仅用OpenOffice就难以胜任了。
用unoconv就可以轻松地实现用OpenOffice可以打开的文档的转换.
首先下载安装unoconv采用下面任一种方法:
1)到 http://dag.wieers.com/home-made/unoconv/ 下载,再安装.
2) yum install unoconv

然后就可以用命令
unoconv -f pdf myDoc.doc
进行转换了.以上命令即会生成一个名为 myDoc.pdf 的 pdf 文件。

批量转换需要结合find命令或脚本使用，使用时需注意最好使用C/S模式以加快速度：
unoconv --listener &
unoconv -f pdf some-document.odt
unoconv -f doc other-document.odt
unoconv -f jpg some-image.png
unoconv -f xsl some-spreadsheet.csv

多个PDF文件的合并:
gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=out.pdf  *.pdf
就会生成一个名为out.pdf的文件.但要保证当前目录下没有out.pdf这个文件.

** 文档工具
*** antiword                                                     :antiword:

参考:
+ [[http://en.wikipedia.org/wiki/Antiword][Wiki]]
+ [[http://www.winfield.demon.nl/][Homepage]]
+ [[http://www.emacswiki.org/emacs/AntiWord][EmacsWiki]]
+ [[http://manpages.ubuntu.com/manpages/gutsy/man1/antiword.1.html][Ubuntu Manpage]]

**** What?
*Antiword* is a free software reader for proprietary Microsoft Word
documents, and is available for most computer platforms. Antiword can
convert the documents from *Microsoft Word version 2, 6, 7, 97, 2000,
2002 and 2003* to *plain text, PostScript, PDF, and XML/DocBook*
(experimental).

Antiword is a free MS Word reader for Linux and RISC OS. There are
ports to FreeBSD, BeOS, OS/2, Mac OS X, Amiga, VMS, NetWare, Plan9,
EPOC, Zaurus PDA, MorphOS, Tru64/OSF, Minix, Solaris and DOS. Antiword
converts the binary files from Word 2, 6, 7, 97, 2000, 2002 and 2003
to plain text and to PostScript TM.
**** NAME
antiword - show the text and images of MS Word documents
**** SYNOPSIS
antiword [ options ] wordfiles
**** DESCRIPTION
Antiword  is  an  application  that displays the text and the images
of Microsoft Word documents.
A wordfile named - stands for a Word document read  from  the
standard input.
Only  documents  made  by  MS Word version 2 and version 6 or later
are supported.
**** OPTIONS
***** -a papersize
Output in Adobe PDF form. Printable on paper  of  the  specified
size:  10x14,  a3, a4, a5, b4, b5, executive, folio, legal, let‐
ter, note, quarto, statement or tabloid.
***** -f
Output in formatted text form. That  means  that  bold  text  is
printed  like *bold*, italics like /italics/ and underlined text
as _underlined_.
***** -h
Give a help message.
***** -i image level
The image level determines how images will be shown.

0: Use non-standard extensions from Ghostscript. This output may
   not print on any PostScript printer, but is useful in case no
   hard copy is needed. It is also useful  when  Ghostscript  is
   used  as  a  filter  to  print  a  PostScript  file to a non-
   PostScript printer.

1: Show no images.

2: PostScript level 2 compatible. (default)

3: PostScript level 3 compatible. (EXPERIMENTAL,  Portable  Net‐
   work Graphics (PNG) images are not printed correctly)
***** -m mapping file
This  file is used to map Unicode characters to your local char‐
acter set.  The default mapping file depends on the locale.

***** -p papersize
Output in PostScript form. Printable on paper of  the  specified
size:  10x14,  a3, a4, a5, b4, b5, executive, folio, legal, let‐
ter, note, quarto, statement or tabloid.
***** -r
Include text removed by the revisioning system.
***** -s
Include text with the so-called "hidden text" attribute.
***** -t
Output in text form. (default)
***** -w width
In text mode this is the line width in characters.  A  value  of
zero puts an entire paragraph on a line, useful when the text is
to used as  input  for  another  wordprocessor.  This  value  is
ignored in PostScript mode.
***** -x document type definition
Output  in XML form. Currently the only document type definition
is db (for DocBook).
***** -L
In PostScript mode: use landscape mode.

**** FILES
***** Mapping files like 8859-1.txt
Antiword looks for its mapping files in  three  directories,  in
the order given:
(1) The directory specified by $ANTIWORDHOME
(2) The directory specified by $HOME/.antiword
(3) Directory /usr/share/antiword
***** The fontnames file
Antiword will look for its fontname file in the same directories
as used for the mapping files.
The fontnames file contains  the  translation  table  from  font
names used by MS Word to font names used by PostScript.

***** NOTE
Antiword cannot tell the difference between a file that does not
exist and a file that cannot be opened for reading.

***** ENVIRONMENT
Antiword uses the environment variable ‘‘ANTIWORDHOME’’  as  the
first directory to look for its files. Antiword uses the environment
variable ‘‘HOME’’ to find the user’s home directory. When in text
mode  it  uses the  variable  ‘‘COLUMNS’’ to set the width of the
output (unless over‐ridden by the -w option).

Antiword uses the environment variables  ‘‘LC_ALL’’,
‘‘LC_CTYPE’’  and ‘‘LANG’’ (in that order) to get the current
locale and uses this infor‐mation to select the default mapping file.

*** chm文档查看                                                       :chm:

+ chmsee  # 没有
+ Kchmviewer
+ /Xchm/    # OK, 中文支持没有问题
+ chmviewer
+ gnochm  # 没有

*** cups-pdf: pdf虚拟打印机
参考:
+ [[http://blog.chinaunix.net/uid-488742-id-2113697.html]]

1. 安装 apt-get install cups-pdf
2. 增加打印机,在系统设置中
3. 配置文件: /etc/cups/cups-pdf.conf
   + 选项out: 输出文件夹
*** calibre                                                       :calibre:
**** 参考                                             :homepage:wikipedia:

+ [[http://zh.wikipedia.org/wiki/Calibre][Wikipedia]]
+ [[http://calibre-ebook.com/][Homepage]]

**** overview

+ 电子书软件套装

+ 可以用来 *组织、存放、以及管理* 电子书

+ 支持大多数的电子书格式

+ 自由开源

+ 支持与许多流行的电子书阅读器进行同步

+ 并可能在DRM的限制下转换电子书的格式。

+ 注: 即使是写在句子的开头也是一律小写（关于缩写）

**** ebook-convert

+ 用法: *ebook-convert input_file output_file [options]*

+ 功能: 转换不同格式的电子书。

+ 说明:

  1) input_file 表示输入文件，output_file 表示输出文件, *这两者作为命
     令行参数必须指定到最前面*

  2) 输出的电子书格式可由 output_file 的扩展名得到。同时 output_file
     也可以是一种以 .EXT 为扩展名的特殊格式。在这种情况下，输出文件的
     名称则使用输入文件的名称。注意：文件名不能以连字号作为开头。如果
     output_file 不含扩展名，那么它将被视为一个目录并将会在该目录下生
     成 HTML 格式的“开放式电子书(OEB)”。这些文件会被视为正常文件而被
     输出插件所识别。

**** opf                                                             :opf:

*OPF文档是epub电子书的核心文件，且是一个标准的XML文件* ，依据OPF规范，
主要由五个部分组成：

1、<metadata>,元数据信息，由两个子元素组成：

-  <dc-metadata>，其元素构成采用dubline core(DC)的15项核心元素，包括：
-

   -  <title>:题名
   -  <creator>：责任者
   -  <subject>：主题词或关键词
   -  <description>：内容描述
   -  <contributor>：贡献者或其它次要责任者
   -  <date>：日期
   -  <type>：类型
   -  <format>：格式
   -  <identifier>：标识符
   -  <source>：来源
   -  <language>：语种
   -  <relation>：相关信息
   -  <coverage>：履盖范围
   -  <rights>：权限描述

-  <x-metadata>，即扩展元素。如果有些信息在上述元素中无法描述，则在此元素中进行扩展。


2、<manifest>，文件列表，由于列出OEBPS文档及相关的文档，有一个子元素构成，

-  <item id="" href="" media-type="">,该元素由三个属性构成：
-

   -  id:表示文件的ID号
   -  href：文件的相对路径
   -  media-type：文件的媒体类型
   -  例如：<item id="chap01" href="chap01.xhtml"
      media-type="application/xhtml+xml"/>

3、<spinetoc="ncx">，脊骨，其主要功能是提供书籍的线性阅读次序。由一个子元素构成：

-  <itemref idref="">,由一个属性构成：
-

   -  idref:即参照menifest列出的ID
   -  例如：<itemref idref="chap01"/>

4、<guide>,指南,依次列出电子书的特定页面, 例如封面、目录、序言等,
属性值指向文件保存地址。一般情况下，epub电子书可以不用该元素。



5、<tour>,导读。可以根据不同的读者水平或者阅读目的, 按一定次序,
选择电子书中的部分页面组成导读。一般情况下，epub电子书可以不用该元素。

**** Kindle 支持格式                                          :mobi:

http://zhidao.baidu.com/link?url=syKdsMKrYEVQcLNPgAJDXEd1DMyy3WdS_t7CVMKD7QNFWE5tpxj3nYhZbfUFWYwzKXVzC9lZPq1fJg3aY0WbZaafBWM15ZYfK51XM_tB03C

kindle原系统支持azw、pdf、mobi、prc、txt格式。其中mobi、azw和prc格式支
持最为优秀。

**** mobi                                                           :mobi:
**** epub                                                           :epub:

**** 电子书分解

整理书籍时我喜欢单独收藏一本书，而不是合集。有的书通过网络不一定可以找
到，没有拆分合集便利。

初步想法：转换成 word ，在 word 中裁剪，然后再转换回去。
**** 电子书制作                                                    :sigil:

https://www.zhihu.com/question/21266639/answer/17704629


用 *Sigil* 制作epub然后转成calibre吧，用calibre做电子书太难受了。而Sigil则
是专门拿来做电子书的，功能和易用性都要强很多。做出来的epub再用calibre
转一下就好了，只要epub符合标准，转出来的mobi里面封面，章节等信息肯定都
在的。

**** 制作 mobi 文件目录

https://www.zhihu.com/question/21266639/answer/31606582

如果源文档是Word格式的话，直接在Word文档中插入一个目录，Calibre转换出
来的epub就会有目录了。不需要那么麻烦的把doc转成html

适用于 txt 转 mobi

**** [[http://kindlefere.com/post/27.html][mobi, azw, azw3, epub格式有什么区别]]                   :epub:mobi:azw:

刚接触Kindle的小伙伴经常会被mobi、azw、azw3、epub等常见的几个格式搞的
很凌乱，它们都有哪些区别呢？又各有什么优缺点呢？哪个好一些呢？其实
Amazon的电子书格式比这可多多了，完全可以单独写一篇文章来解释，但是太技
术性的也没什么必要，我们只需要知道这几个常见格式的区别就可以了。笔者汇
总了一些资料，为各位小伙伴们通俗地科普一下。

这几种电子书格式从本质上来说都是从HTML文档转换而来，大多数HTML标签和
CSS样式表的特性它们都支持，它们之间的主要区别在于对排版及新特性的支持
与否上，为了更方便清晰的理解，笔者将这几种格式分门别类地为各位小伙伴详
细解释一下：

***** 什么是mobi、azw格式

mobi和azw格式的推手主要是Amazon，这两种电子书格式的发展很大程度上依靠
Amazon这个巨大的内容提供商及其电子书阅读器Kindle的流行普及。它们同属亚
马逊的私有格式，没有本质的区别，可以简单的这样理解，mobi是比较老的一种
格式，而azw只是mobi的另一种形式而已，也可以理解为mobi加了个壳，亚马逊
利用它对电子书做DRM版权保护。

目前市面上的mobi文件大部分是来自两种途径：epub、pdf或者txt转换成的mobi，
从Amazon商店流出来的mobi。前者没什么好说的，后者要么是Amazon官方制作，
要么就是自出版作者通过KDP(Kindle Direct Publishing，作者可以绕过出版社
直接在Amazon上发售电子书)平台发布，通过KDP平台发布时，作者只需要上传
Word文档，其他的事情也是Amazon官方来做，从而保证了，mobi文件的规范程度。

***** 什么是azw3格式

azw3的本质是KF8，是随着2011年Amazon推出Kindle Fire平板时一起推出的。它
填补了Mobi对于复杂排版支持的缺陷，支持很多HTML5（目前尚不支持 HTML5 的
视频和音频标签）和CSS3的语法，这就大大改善了原来mobi或azw内容排版上的
一些缺陷，单纯从读者的角度来讲，是不输epub格式的。目前从Amazon购买的书，
大部分已经是azw3格式了，而以前主流的mobi格式则越来越少，它正逐渐取代
mobi成为Kindle电子书的主流格式。

***** 什么是epub格式

下面是维基百科对epub的一段定义：

#+BEGIN_QUOTE
  EPUB（Electronic
  Publication的缩写，电子出版）是一种电子图书标准，由国际数字出版论坛（IDPF）提出；其中包括3种文件格式标准（文件的附文件名为.epub），这个格式已取代了先前的Open
  eBook开放电子书标准。
#+END_QUOTE

epub格式对于复杂的排版，图表，公式等元素的兼容性比mobi格式好很多，在脚
本，公式，矢量图形的支持方面也强过mobi格式，现阶段epub格式的优势体现在
图文混排、图片嵌入字体等，未来可预测的优势是epub格式对于声音，影像等多
媒体内容互动的支持上。

epub格式是开放标准，所以在开发工具上也会有更大的选择，像Sigil、Calibre、
Jutoh等软件都可以让用户自助制作epub格式电子书，但因为良莠不齐的制作也
导致一个问题：大量的epub文件其实是不符合标准，无法保证在所有支持epub的
硬件和软件上都可以顺利阅读，这就和iOS系统和Android系统的区别有些相似。

***** 亚马逊为什么不采用开放标准的epub格式呢？

为什么亚马逊不选择epub这种竞争对手（如Google、苹果）和图书馆普遍采用的
标准电子书格式呢？亚马逊解释说他们的创新速度很快，采用它们自己的标准格
式，能够将创新成果迅速结合到产品中去。例如，Whispersync技术（该技术通
过无线接入互联网，将电子书阅读进度信息同步到各种阅读器上）以及字号放大
缩小的技术。采用其他格式的电子书阅读器，以后也能把这些功能结合进来。但
是，我们在提高产品性能上动作十分迅速。采用自己的格式是非常有利的，因为
不用等第三方格式跟进之后再动手。

对于我们普通读者来说，其实只需要知道越新的格式其支持的特性多，更能改善、
提升我们的阅读体验就可以了。这样也就不难理解为什么再用Calibre等工具将
azw3转换成mobi后会产生丢失格式的问题了，毕竟新的特性一般都不会被老格式
兼容。
*** evince
+ 格式: evince [选项] [文件]   # GNOME文档查看器

*** unoconv                                      :unoconv:pdf:

**** reference
+ [[http://www.cnblogs.com/xkfz007/articles/2182480.html][Linux下Word转换PDF及多个PDF合并]]
+ [[http://dag.wieers.com/home-made/unoconv/][HomePage]]

**** intro
unoconv converts between any document format that OpenOffice
understands. It uses *OpenOffice's UNO bindings* for non-interactive
conversion of documents.

转换文档格式的命令行工具。


Supported document formats include Open Document Format (.odt), MS
Word (.doc), MS Office Open/MS OOXML (.xml), Portable Document Format
(.pdf), HTML, XHTML, RTF, Docbook (.xml), and more.

在Linux中常常涉及到多种文档格式，如doc、txt、html、rtf等等。为了方便文
件传递，就可能需要在各种格式之间进行转换。OpenOffice.Org可以方便的打
开多各文档格式并按需进行转换* ，但要一次处理大量文件或要编写脚本进行转
换时，仅用OpenOffice就难以胜任了。


用unoconv就可以轻松地实现用OpenOffice可以打开的文档的转换.
*unoconv -f pdf myDoc.doc*
进行转换了.以上命令即会生成一个名为 myDoc.pdf 的 pdf 文件。

**** 批量转换

*批量转换需要结合find命令或脚本使用，使用时需注意最好使用C/S模式以加快
速度*
+ unoconv --listener &
+ unoconv -f pdf some-document.odt
+ unoconv -f doc other-document.odt
+ unoconv -f jpg some-image.png
+ unoconv -f xsl some-spreadsheet.csv

**** unocov 转换 word 文档为 PDF                                    :word:

unocov 是OpenOffice的命令行工具，能转换 OpenOffice 能够识别的所有格式

/$ unocov -f pdf file.doc(x)/

1. 效率很高，比使用虚拟打印机功能要快，
2. Ubuntu下字体可能不一致，不过无所谓

**** [[http://dag.wiee.rs/home-made/unoconv/][Convert between any document format supported by OpenOffice]]

unoconv converts between any document format that OpenOffice
understands. It uses OpenOffice's UNO bindings for non-interactive
conversion of documents.

Supported document formats include Open Document Format (.odt), MS Word (.doc), MS Office Open/MS OOXML (.xml), Portable Document Format
(.pdf), HTML, XHTML, RTF, Docbook (.xml), and more.

***** Features

  * Converts between different document formats that OpenOffice understands
  * OpenOffice can export to about 100 different document formats
  * Can be used for batch processing
  * Combines with asciidoc and docbook2odf/xhtml2odt to create PDF or Word (.doc) files
  * Can apply custom style templates during conversion (to enforce corporate identity)
  * Autostarts OpenOffice for processing if necessary
  * Can be used in a client/server environment to process documents centrally
  * Can influence OpenOffice filters during import and export
  * Supports OpenOffice on Linux, Windows and MacOSX

***** Output formats

OpenOffice (and thus unoconv) support various import and export formats. Not all formats that can be imported can be exported and vice
versa. The below list of formats only lists the export formats.

If you need a list of formats that unoconv can import, please look at the [[http://wiki.services.openoffice.org/wiki/Framework/Article/Filter/FilterList_OOo_3_0][filter list]] from OpenOffice.

****** The following list of document formats are currently available for exporting to:

  bib      - BibTeX [.bib]
  doc      - Microsoft Word 97/2000/XP [.doc]
  doc6     - Microsoft Word 6.0 [.doc]
  doc95    - Microsoft Word 95 [.doc]
  docbook  - DocBook [.xml]
  html     - HTML Document (OpenOffice.org Writer) [.html]
  odt      - Open Document Text [.odt]
  ott      - Open Document Text [.ott]
  ooxml    - Microsoft Office Open XML [.xml]
  pdb      - AportisDoc (Palm) [.pdb]
  pdf      - Portable Document Format [.pdf]
  psw      - Pocket Word [.psw]
  rtf      - Rich Text Format [.rtf]
  latex    - LaTeX 2e [.ltx]
  sdw      - StarWriter 5.0 [.sdw]
  sdw4     - StarWriter 4.0 [.sdw]
  sdw3     - StarWriter 3.0 [.sdw]
  stw      - Open Office.org 1.0 Text Document Template [.stw]
  sxw      - Open Office.org 1.0 Text Document [.sxw]
  text     - Text Encoded [.txt]
  txt      - Plain Text [.txt]
  vor      - StarWriter 5.0 Template [.vor]
  vor4     - StarWriter 4.0 Template [.vor]
  vor3     - StarWriter 3.0 Template [.vor]
  xhtml    - XHTML Document [.html]

****** The following list of graphics formats are currently available for exporting to:

  bmp      - Windows Bitmap [.bmp]
  emf      - Enhanced Metafile [.emf]
  eps      - Encapsulated PostScript [.eps]
  gif      - Graphics Interchange Format [.gif]
  html     - HTML Document (OpenOffice.org Draw) [.html]
  jpg      - Joint Photographic Experts Group [.jpg]
  met      - OS/2 Metafile [.met]
  odd      - OpenDocument Drawing [.odd]
  otg      - OpenDocument Drawing Template [.otg]
  pbm      - Portable Bitmap [.pbm]
  pct      - Mac Pict [.pct]
  pdf      - Portable Document Format [.pdf]
  pgm      - Portable Graymap [.pgm]
  png      - Portable Network Graphic [.png]
  ppm      - Portable Pixelmap [.ppm]
  ras      - Sun Raster Image [.ras]
  std      - OpenOffice.org 1.0 Drawing Template [.std]
  svg      - Scalable Vector Graphics [.svg]
  svm      - StarView Metafile [.svm]
  swf      - Macromedia Flash (SWF) [.swf]
  sxd      - OpenOffice.org 1.0 Drawing [.sxd]
  sxd3     - StarDraw 3.0 [.sxd]
  sxd5     - StarDraw 5.0 [.sxd]
  tiff     - Tagged Image File Format [.tiff]
  vor      - StarDraw 5.0 Template [.vor]
  vor3     - StarDraw 3.0 Template [.vor]
  wmf      - Windows Metafile [.wmf]
  xhtml    - XHTML [.xhtml]
  xpm      - X PixMap [.xpm]

****** The following list of presentation formats are currently available for exporting to:

  bmp      - Windows Bitmap [.bmp]
  emf      - Enhanced Metafile [.emf]
  eps      - Encapsulated PostScript [.eps]
  gif      - Graphics Interchange Format [.gif]
  html     - HTML Document (OpenOffice.org Impress) [.html]
  jpg      - Joint Photographic Experts Group [.jpg]
  met      - OS/2 Metafile [.met]
  odd      - OpenDocument Drawing (Impress) [.odd]
  odg      - OpenOffice.org 1.0 Drawing (OpenOffice.org Impress) [.odg]
  odp      - OpenDocument Presentation [.odp]
  pbm      - Portable Bitmap [.pbm]
  pct      - Mac Pict [.pct]
  pdf      - Portable Document Format [.pdf]
  pgm      - Portable Graymap [.pgm]
  png      - Portable Network Graphic [.png]
  pot      - Microsoft PowerPoint 97/2000/XP Template [.pot]
  ppm      - Portable Pixelmap [.ppm]
  ppt      - Microsoft PowerPoint 97/2000/XP [.ppt]
  pwp      - PlaceWare [.pwp]
  ras      - Sun Raster Image [.ras]
  sda      - StarDraw 5.0 (OpenOffice.org Impress) [.sda]
  sdd      - StarImpress 5.0 [.sdd]
  sdd3     - StarDraw 3.0 (OpenOffice.org Impress) [.sdd]
  sdd4     - StarImpress 4.0 [.sdd]
  sti      - OpenOffice.org 1.0 Presentation Template [.sti]
  stp      - OpenDocument Presentation Template [.stp]
  svg      - Scalable Vector Graphics [.svg]
  svm      - StarView Metafile [.svm]
  swf      - Macromedia Flash (SWF) [.swf]
  sxi      - OpenOffice.org 1.0 Presentation [.sxi]
  tiff     - Tagged Image File Format [.tiff]
  vor      - StarImpress 5.0 Template [.vor]
  vor3     - StarDraw 3.0 Template (OpenOffice.org Impress) [.vor]
  vor4     - StarImpress 4.0 Template [.vor]
  vor5     - StarDraw 5.0 Template (OpenOffice.org Impress) [.vor]
  wmf      - Windows Metafile [.wmf]
  xhtml    - XHTML [.xml]
  xpm      - X PixMap [.xpm]

****** The following list of spreadsheet formats are currently available for exporting to:

  csv      - Text CSV [.csv]
  dbf      - dBase [.dbf]
  dif      - Data Interchange Format [.dif]
  html     - HTML Document (OpenOffice.org Calc) [.html]
  ods      - Open Document Spreadsheet [.ods]
  ooxml    - Microsoft Excel 2003 XML [.xml]
  pdf      - Portable Document Format [.pdf]
  pts      - OpenDocument Spreadsheet Template [.pts]
  pxl      - Pocket Excel [.pxl]
  sdc      - StarCalc 5.0 [.sdc]
  sdc4     - StarCalc 4.0 [.sdc]
  sdc3     - StarCalc 3.0 [.sdc]
  slk      - SYLK [.slk]
  stc      - OpenOffice.org 1.0 Spreadsheet Template [.stc]
  sxc      - OpenOffice.org 1.0 Spreadsheet [.sxc]
  vor3     - StarCalc 3.0 Template [.vor]
  vor4     - StarCalc 4.0 Template [.vor]
  vor      - StarCalc 5.0 Template [.vor]
  xhtml    - XHTML [.xhtml]
  xls      - Microsoft Excel 97/2000/XP [.xls]
  xls5     - Microsoft Excel 5.0 [.xls]
  xls95    - Microsoft Excel 95 [.xls]
  xlt      - Microsoft Excel 97/2000/XP Template [.xlt]
  xlt5     - Microsoft Excel 5.0 Template [.xlt]
  xlt95    - Microsoft Excel 95 Template [.xlt]

***** Screenshot
This may not be your typical set of screenshots, but here is a workflow I use for converting an AsciiDoc (text) formatted résumé into
professional ODT, PDF, HTML and DOC versions:

  [dag@moria cv]$ make odt pdf html doc
  rm -f *.{odt,pdf,html,doc}
  asciidoc -b docbook -d article -o resume.xml resume.txt
  docbook2odf -f --params generate.meta=0 -o resume.tmp.odt resume.xml
  Saved resume.tmp.odt
  unoconv -f odt -t template.ott -o resume.odt resume.tmp.odt
  unoconv -f pdf -t template.ott -o resume.pdf resume.odt
  unoconv -f html -t template.ott -o resume.html resume.odt
  unoconv -f doc -t template.ott -o resume.doc resume.odt

***** The original files are:

  * A recipe: [[http://dag.wiee.rs/cv/Makefile][Makefile]]
  * An AsciiDoc [.txt] file: [[http://dag.wiee.rs/cv/curriculum-vitae-dag-wieers.asciidoc][resume.txt]]
  * An OpenOffice template [.ott] file: [[http://dag.wiee.rs/cv/curriculum-vitae-docbook.ott][template.ott]]

Converted into the following files:

  * Open Document [.odt]: [[http://dag.wiee.rs/cv/curriculum-vitae-dag-wieers.odt][resume.odt]] - converted from TXT using asciidoc and stylesheet
  * PDF [.pdf]: [[http://dag.wiee.rs/cv/curriculum-vitae-dag-wieers.pdf][resume.pdf]] - converted from ODF using unoconv
  * HTML [.html]: [[http://dag.wiee.rs/cv/curriculum-vitae-dag-wieers.html][resume.html]] - converted from ODF using unoconv
  * Word [.doc]: [[http://dag.wiee.rs/cv/curriculum-vitae-dag-wieers.doc][resume.doc]] - converted from ODF using unoconv

***** Requirements
unoconv is written in python. It needs a recent LibreOffice or OpenOffice with UNO bindings.
Bug reports
If you've found a bug, please check the [[http://github.com/dagwieers/unoconv/issues][Github issue-tracker]] for known problems and send me updates if you have more information to provide.
Download
The following packages (in order of appearance) are available.

  * [[http://dag.wieers.com/packages/unoconv/][Red Hat]]
  * [[http://packages.debian.org/unoconv][Debian]]
  * [[https://admin.fedoraproject.org/pkgdb/acls/name/unoconv][Fedora]]
  * [[http://easyurpmi.zarb.org/][Mandriva]]
  * [[http://packages.ubuntu.com/lucid/unoconv][Ubuntu Lucid]]
  * [[https://build.opensuse.org/package/show?package=unoconv&project=openSUSE%253AFactory%253AContrib][OpenSUSE]]

or grab the latest 0.7 tarball at: [[http://dag.wieers.com/home-made/unoconv/unoconv-0.7.tar.gz]]
Mailinglist
There's a mailinglist about unoconv and some other tools at: [[http://lists.repoforge.org/mailman/listinfo/tools]]
Sourcecode
You can have access to the latest changes via Github from:

  * [[https://github.com/dagwieers/unoconv]]
*** convmv                                                :convmv:encoding:

文件名编码转换工具

**** man

CONVMV(1)                                                                                                                                                            CONVMV(1)



NAME
       convmv - converts filenames from one encoding to another

SYNOPSIS
       convmv [options] FILE(S) ... DIRECTORY(S)

OPTIONS
       -f ENCODING
           specify the current encoding of the filename(s) from which should be converted

       -t ENCODING
           specify the encoding to which the filename(s) should be converted

       -i  interactive mode (ask y/n for each action)

       -r  recursively go through directories

*** Pandoc   a universal document converter                        :pandoc:
**** Reference                                 :homepage:wikipedia:github:

+ [[http://zh.wikipedia.org/w/index.php?title=Pandoc&redirect=no][Wikipedia]]
+ [[http://johnmacfarlane.net/pandoc/README.html][Pandoc Homepage]]
+ [[https://github.com/jgm/pandoc][GibHub]]
+ [[http://pandoc.org/README.html][document]]

**** overview                                                   :overview:
***** What's Pandoc?

+ *标记语言转换工具*
+ John MacFarlane使用 *Haskell* 开发
+ 领域中的 *瑞士军刀*
+ 命令行工具
+ 可支持多种操作系统
+ GNU GPL, 自由软件。

***** 语言格式

1. 可读取的源格式
   + Markdown
   + reStructuredText
   + textile
   + HTML
   + DocBook
   + LaTeX
   + MediaWiki标记语言
   + OPML
   + *Org-Mode*
   + Haddock

2. 可输出的格式
   + HTML格式
     - XHTML
     - HTML5
     - HTML slide
   + 文字处理软件格式
     - docx
     - odt
     - OpenDocument XML
   + 电子书格式
     - EPUB（第2版及第3版）
     - FictionBook2
   + 技术文档格式
     - DocBook
     - GNU TexInfo
     - Groff manpages
     - Haddock
   + 页面布局格式 InDesign ICML
   + 大纲处理标记语言格式：OPML
   + TeX格式
     - LaTeX
     - ConTeXt
     - LaTeX Beamer
   + PDF格式(需要LaTeX支持)
   + 轻量级标记语言格式
     - Markdown
     - reStructuredText
     - textile
     - Org-Mode
     - MediaWiki标记语言
     - AsciiDoc
   + 自定义格式：可使用lua自定义转换规则

**** pandoc 安装                                                 :install:

- https://github.com/jgm/pandoc

***** apt-get


****** source code

+ git clone git://github.com/jgm/pandoc
+ cd pandoc
+ git submodule update --init
+ cabal install --force --enable-tests
+ cabal test

注：

- 使用 cabal

- Make sure the `$CABALDIR/bin` directory is in your path.

  #+BEGIN_EXAMPLE
  export PATH=~/.cabal/bin:$PATH
  #+END_EXAMPLE

- *没有必要使用源码方式*

**** quick start

Pandoc的基本指令格式是：
#+BEGIN_EXAMPLE
  $ pandoc [options] [input-file] ...
#+END_EXAMPLE

1) 简单的格式转换指令, Pandoc会根据文件的后缀名自动判断格式
   #+BEGIN_EXAMPLE
     $ pandoc -o output.html input.md
   #+END_EXAMPLE
   其中-o ouput.html表示输出文件为output.html，input.md是输入文件。

2) 用户也可以显式地指定输入文件和输出文件格式
   #+BEGIN_EXAMPLE
     $ pandoc -f markdown -t html -o output.html input.md
   #+END_EXAMPLE
   其中-f markdown表示输入文件格式为Markdown，-t html表示输出文件格式
   为HTML。

3) 可以使用url作为输入

4) -f 输入格式

5) -t 输出格式

*** wordpress                                              :wordpress:blog:

**** reference

- [[https://cn.wordpress.org/][Homepage]]
- [[https://github.com/wordpress/wordpress][Github]]
- [[https://github.com/punchagan/org2blog][org2blog]]

**** [[http://www.trinea.cn/other/choice-between-wordpress-and-github-page/][WordPress VS GitHub Page]]

***** WordPress和github page的选择和搭建

搭建博客时对wordpress和github page进行了简单的对比，最终选择了wp。

这里就简单对比下wp和gp的优缺点及搭建过程简介。主要比较方面包括*搭建复
杂度、对域名空间要求、写博客的便捷程度、开放性（主题、工具插件）、访问
速度、SEO优化、迁移成本

***** ps: 下面介绍中github page使用octopress博客框架

首先如果希望能以独立域名访问，域名的注册是必不可少的，可选择[[http://www.net.cn/domain/][万网]] 或 [[http://www.west263.cn/services/domain/][西部
数码]]等

*a. 搭建复杂度*

wp近乎傻瓜式；github较复杂，需要安装不少软件，而且还可能有莫名的错误，
需随时google解决结果：wp胜出，当然喜欢折腾或是对ruby相当熟悉的话可能差
别不是很明显。


*b. 对域名空间要求*

wp需要自己购买虚拟主机，低配大约在100-200RMB/Y，主机需要有lamp的环境运
行wp，不过现在的linux虚拟主机一般都提供此环境；

github page的一大优点就是不需要虚拟主机，它是可以发布到githubpage上的。

结果：github page免费优势明显

*c. 写博客的便捷程度*

wp需要打开后台，在后台撰写文章，即时写当然是需要联网的。wp的强大插件使
得博客文字样式可以很丰富
githubpage支持本地编写、本地预览，满意后再发布，并且支持markdown语法所
以对于不少程序员可能会比较方便。文本中直接编写极客的感觉*\_*

结果：对于不同人群各有优劣吧


*d. 开放性（主题、工具插件）*

wp的主题和插件是无比丰富的，这是选择wp的一大原因之一，不过插件多同时也
带来了另一个问题就是质量良莠不齐，选择相当麻烦费事，org~，之后会分享自
己装的觉得还不错的插件。

octopress相当来说发展没多久，插件方面没怎么调查，不过主题是标准的程序
员黑，自己改css相当费事

结果：wp胜出

*e、访问速度*

wp的访问速度与虚拟空间地址有关，不过我挂在朋友的购买的国外虚拟空间上速
度感觉也还不错

github的访问速度感觉与其他国外网站比还是较慢的，这几天刚好因为抢票插件
被封

结果：看具体虚拟空间的选择


*f、SEO优化*

wp不少插件提供seo优化功能，但也需要发博客时自己填写不少信息比较麻烦

githubpage搜索引擎优化就不需要自己做了，并且github在google上权重肯定相
当高，所以优势明显

结果：github page胜出

*g、迁移成本*

wp的迁移需要将网站目录迁移、数据库备份后再导入即可octopress的迁移也还
好，就算不利用githubpage的话，自己有一套ruby和nginx的环境的话也是可以
很方便重新部署的

结果：旗鼓相当

我比较在乎开放性（主题、工具插件）、写博客的便捷程度、访问速度、迁移成
本四点。尤其对第一点比较看重，所以选择了wp，不过比较插件真是差点被折腾
死||\_||，在wordpress和github

page的搭建中有自己安装的比较好的插件.

*PS：搭建过程*

wordpress搭建：下载 [[http://cn.wordpress.org/][最新wordpress包]] ，解压上传。直接访问index.php，按
照提示填写数据库信息即可（可以自己将个数据库）。

githubpage博客搭建参考[[http://www.hopes4.me/post/2012-02-29-introduce-octopress-on-github][在github上用octopress搭建博客]]， 关于ruby的安装可
参考 [[http://blog.sina.com.cn/s/blog_6b59aaa701017sff.html][Ruby在windows下的安装]]。

**** [[http://xg1990.com/blog/archives/87][Linux/Ubuntu下Octopress博客搭建过程]]                            :blog:

总算搭好了这个静态博客，之前尝试了Jekyll与Jekyllbootstrap，还是不够给
力，总是出现各种莫名的问题，总结下这个博客的搭建过程(Linux/Ubuntu环境)：

***** 安装前准备

(这部分内容来自
http://gujiaxi.github.com/blog/2012/02/15/how-to-install-octopress-on-ubuntu-11-dot-04-and-deploy-on-github/)

配置前需要=curl=,=git=两个工具，安装之


sudo apt-get install curl git-core

先确保ubuntu源中的 =ruby=, =rubygem= 已经卸载,如果没有，使用 =sudo
apt-get remove= 命令卸载之

安装RVM(Ruby Version Manager)

bash -s stable &lt; &lt;(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer)

将rvm指令变成shell function

echo &#039;[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; .
&quot;$HOME/.rvm/scripts/rvm&quot;&#039;&gt;&gt;~/.bashrc


完毕之后重启终端，运行

type rvm | head -1


应该就能看到=rvm is a function=，说明安装成功

然后，在rvm下安装Ruby 1.9.2, RubyGems

rvm pkg install openssl
rvm pkg install zlib
rvm install 1.9.2
rvm use 1.9.2
rvm rubygems latest

即可

***** 配置octopress

(这部分内容来自 http://gujiaxi.github.com/blog/2012/02/15/how-to-install-octopress-on-ubuntu-11-dot-04-and-deploy-on-github/)

下载octopress

git clone https://github.com/imathis/octopress.git octopress

这里下载到了本地文件夹octopress ，然后依次执行

cd octopress
gem install bundler
bundle install rake install

然后就基本配置好了

添加 \(LaTeX\) 支持

(这部分内容来自 http://luikore.github.com/2011/09/good-things-learned-from-octopress/)

这里有个非常给力的 \(LaTeX\),排出来的公式还能够继续被识别为文字，比那些通过生成png实现的公式强多了

安装插件

gem install kramdown

修改octopress目录下的_config.yml，将其中的

markdown: rdiscount

改为

markdown: kramdown

然后修改octopress/source/_includes/custom/head.html
 向其中添加

&lt;!-- mathjax config similar to math.stackexchange --&gt; &lt;script
type=&quot;text/x-mathjax-config&quot;&gt; MathJax.Hub.Config({ jax:
[&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;], tex2jax: {
inlineMath: [ [&#039;$&#039;, &#039;$&#039;] ], displayMath: [
[&#039;$\$&#039;, &#039;$\$&#039;]], processEscapes: true, skipTags:
[&#039;script&#039;, &#039;noscript&#039;, &#039;style&#039;,
&#039;textarea&#039;, &#039;pre&#039;, &#039;code&#039;] },
messageStyle: &quot;none&quot;, &quot;HTML-CSS&quot;: { preferredFont:
&quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] }
}); &lt;/script&gt; &lt;script
src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;
type=&quot;text/javascript&quot;&gt;&lt;/script&gt;

但是此时右键单击公式会出现bug，解决办法是修改octopress/sass/base/_theme.scss如下所示比如

body - &gt; div + &gt; div#main background: $sidebar-bg border-bottom:
1px solid $page-border-bottom &gt; div background: $main-bg
border-right: 1px solid $sidebar-border

***** 调整样式

最后，我觉得octopress的段距与行高太大了，
修改octopress/source/stylesheets/screen.css，
找到
=p,blockquote,ul,ol{margin-bottom:0.5em}=
与
=body{line-height:1.1em;color:#222}=
修改到合适的值即可

*** zim                                                               :zim:
#  org 的 alternative
**** reference

- [[http://www.zim-wiki.org/index.html][Homepage]]
- [[http://www.cnblogs.com/bamanzi/archive/2012/07/05/zim-org-mode.html][Zim - 普通人的Org-mode]](blog)
- [[http://www.cnblogs.com/bamanzi/p/replace-org-mode-with-zim.html][用Zim替代org-mode？]]

**** [[http://www.zim-wiki.org/index.html][Home]]

#+DOWNLOADED: http://www.zim-wiki.org/images/globe.png @ 2016-01-27 13:53:38
 [[~/Wally/Journal/Figure/.org-download/zim/globe_2016-01-27_13:53:37.png]]

*Zim* is a graphical text editor used to maintain a collection of wiki
pages. Each page can contain links to other pages, simple formatting and
images. Pages are stored in a folder structure, like in an outliner, and
can have attachments. Creating a new page is as easy as linking to a
nonexistent page. All data is stored in plain text files with wiki
formatting. Various plugins provide additional functionality, like a
task list manager, an equation editor, a tray icon, and support for
version control.

*Zim* can be used to:

-  Keep an archive of notes
-  Take notes during meetings or lectures
-  Organize task lists
-  Draft blog entries and emails
-  Do brainstorming

*Zim* handles several types of markup, like headings, bullet lists and
of course *bold*, /italic/ and highlighted. This markup is saved as wiki
text so you can easily edit it with other editors. Because of the
autosave feature you can switch between pages and follow links while
editing without worries.

Although *zim* now exists for over 3 years there is no "1.0" version
yet. This does not mean that the application is particularly un-stable
(although making backups is always good practice) or only usable for
linux gurus. But it does mean that the feature set is not yet complete
(of course everything described in the manual is implemented).

/This website was written in Zim !/

** image                                                       :imagemagick:

*** imagemagick                                                :imagemagick:
**** Linux图片工具                                              :overview:

1. *eog* (eye of gnome)

   + 在linux的终端命令行下可以用命令打开图片.
   + 格式：eog a.png
   + hompage  http://projects.gnome.org/eog/

2. ImageMagick

   + homepage: http://www.imagemagick.org/

   + ImageMagick

     ImageMagick® is a software suite to create, edit, compose, or
     convert bitmap images. It can read and write images in a variety
     of formats (over 200) including PNG, JPEG, JPEG-2000, GIF, TIFF,
     DPX, EXR, WebP, Postscript, PDF, and SVG. Use ImageMagick to
     resize, flip, mirror, rotate, distort, shear and transform
     images, adjust image colors, apply various special effects, or
     draw text, lines, polygons, ellipses and Bézier curves.

     ImageMagick是一套功能强大、稳定、，用来创建、编辑、合成图片而且免
     费的工具集和开发包。

   + 特点
     + 开源
     + 跨平台

3. GIMP(photoshop)

4. 图像转换

   1) eps -> pdf

      + eps: Encapsulated PostScript
      + $ epstopdf filename.eps
      + epstopdf是一个实用的perl脚本，调用ghostscript执行实际的转换工
        作。

   2) 所有其它形式转换

      + *convert* 命令通常可以转换任意格式的图像，包括eps.
      + convert 是ImageMagick图形处理套件的一部分。
      + e.g.
        #+BEGIN_EXAMPLE
        $ convert filename.tiff filename.pdf
        #+END_EXAMPLE

**** convert                                                     :convert:

http://www.jincon.com/archives/249/
http://www.jincon.com/archives/248/

*convert* 是 /imagemagick/ 软件包中的一个命令。它可以读取、转换、写入多种格式
的图片。图片切割、颜色替换、各种效果的应用，图片的旋转、组合，文本，直
线，多边形，椭圆，曲线，附加到图片伸展旋转。

***** 选项

1. -resize widthxheight{%} {@} {!} {<} {>} {^}
   1) 默认时，宽度和高度表示要最终需要转换图像的 *最大尺寸* ，同时
      Convert会 *控制图片的宽和高* ，保证图片按比例进行缩放。
   2) 图片无需保持原有比例，可以在宽高后面加上一个感叹号!
   3) 只指定高度，图片会转换成指定的高度值，而宽度会按原始图片比例进行转换
   4) 默认都是使用像素作为单位，也可以使用百分比来形象图片的缩放
   5) 使用 @ 来制定图片的像素个数
      #+BEGIN_EXAMPLE
        convert -resize “10000@” src.jpg dst.jpg

        # 此命令执行后，dst.jpg图片大小为(115×86)，
        # 图片保持原有比例(115×86= 9080 < 10000)。

      #+END_EXAMPLE
   6) 当原始文件大于指定的宽高时，才进行图片放大缩小，可使用>命令后缀
   7) 当原始文件小于指定的宽高时，才进行图片放大转换，可使用<命令后缀。
   8) 使用^命令后缀可以使用宽高中较小的那个值作为尺寸

2. -quality

3. -sample 生成缩略图
***** 示例
#+BEGIN_EXAMPLE
  #! /bin/sh
  for i in `ls *.jpg`;
  do
  convert -resize 50% "$i" "${i%.jpg}.png";
  done
#+END_EXAMPLE

***** 使用convert批量处理图片
imagemagick的命令convert可以完成此任务,其参数-resize用来改变图片尺寸,
可以直接指定像素值,也可以指定缩放百分比。而如果想降低图片的质量,可以用
convert的-quality参数,质量值为0-100之间的数值,数字越大,质量越好,一般指
定70-80,基本上看不出前后的差别。

用下面的命令批量修改图片分辨率为原来的1/4大小,同时保持原图片比例
#+BEGIN_EXAMPLE
$find ./ -regex ‘.*\(jpg\|JPG\)’ -exec convert -resize 50%x50% {} {} \;
#+END_EXAMPLE


用规则表达式把jpg和JPG后缀图片一网打尽,{}代表查找到的文件,这里没有改变
convert前后的文件名,最后是转义的分号表示一个迭代的处理完成。

也可以用以下命令
#+BEGIN_EXAMPLE
$find ./ -name ‘*jpg’ -o -name ‘*JPG’ -exec convert -resize 50%x50% {} {} \;
#+END_EXAMPLE

**** [[http://www.jincon.com/archives/249/][Linux使用imagemagick的convert命令压缩图片，节省服务器空间]] :blog:convert:

本人管的一台阿里云服务器由于空间的带宽才只有1MB，图片一多，网站打开就
慢，真是蛋疼啊，在不增加带宽的情况只有通过系统让图片更小，这样可以加快
速度了，真是人穷就没办法啊。而且压缩图片还可以节省服务器空间，相必也是
极好极好的。

安装imagemagick

#+BEGIN_EXAMPLE
    sudo apt-get install imagemagick
#+END_EXAMPLE

imagemagick的命令convert可以完成此任务,其参数-resize用来改变图片尺寸,
可以直接指定像素值,也可以指定缩放百分比。而如果想降低图片的质量,可以用
convert的-quality参数,质量值为0-100之间的数值,数字越大,质量越好,一般指
定70-80,基本上看不出前后的差别。

我们首先要获取图片，自然find命令：

#+BEGIN_EXAMPLE
    find ./ -regex '.*\(jpg\|JPG\|png\|jpeg\)' -size +500k
#+END_EXAMPLE

统计下数量可对：

#+BEGIN_EXAMPLE
    find ./ -regex '.*\(jpg\|JPG\|png\|jpeg\)' -size +500k | wc -l
#+END_EXAMPLE

执行convert 压缩：

#+BEGIN_EXAMPLE
    find ./ -regex '.*\(jpg\|JPG\|png\|jpeg\)' -size +500k -exec convert -resize 50%x50% {} {} \;
#+END_EXAMPLE

或者限定大小：

#+BEGIN_EXAMPLE
    find ./ -regex '.*\(jpg\|JPG\|png\|jpeg\)' -size +500k -exec convert -resize 800x800 {} {} \;
#+END_EXAMPLE

convert 是会自动按照最大尺寸等比例进行缩小的。

用规则表达式把jpg和JPG后缀图片一网打尽,{}代表查找到的文件,这里没有改变
convert前后的文件名,最后是转义的分号表示一个迭代的处理完成。

缩小图片质量为50：

#+BEGIN_EXAMPLE
    convert -resize 800x800 -quality 50 1405407568-633.jpg 800.jpg
#+END_EXAMPLE

整合下命令我就不说了，呵呵。。。

加上shell脚本每天定时操作，哈哈，爽 的一塌糊涂。

*** screenshot                                                :screentshot:
**** [[http://os.yesky.com/88/8733088.shtml][Ubuntu系统上轻松截图的几种方法介绍]]                             :blog:

相信大家对于屏幕截图(或称抓图)应该不会陌生，在Windows平台上，我们可以使用许多第三方的专业抓图软件如[[http://mydown.yesky.com/soft/multimedia/capture/446/401446.shtml][SnagIt]]等来实现抓取屏幕图像的功能。在
Ubuntu系统中，实现抓图功能的开源工具很多，用好这些工具可以让我们轻松获取任何所需的屏幕图像。本文介绍基于Ubuntu desktop 8.10(i386)，GNOME集成
桌面环境。

1.使用 [[http://product.yesky.com/keyboard/][键盘]] 快捷键抓图

在GNOME集成桌面环境下，我们可以使用键盘功能键Print Screen或Alt+Print Screen组合键来抓图，前者可以抓取整个屏幕的图像，而后者可以抓取当前
活动窗口的图像。例如抓取整个屏幕的图像，则按下Alt+Print Screen组合键，不一会儿将弹出“保存抓图”对话框(图1)，对话框中显示截图的文件名以及图像
存储的目标路径(这里我们使用默认存储路径)，如点击“复制到剪贴板”按钮则将截图复制到系统剪贴板中，在其他程序中使用时只要“粘贴”过去就可以了;如点
击“保存”按钮则将抓取的屏幕图像保存为文件，文件名由系统自动生成，如Screenshot.png。使用键盘快捷键来抓图，优点是快捷、方便，适用于只需要抓取全
屏或某个活动窗口图像的情况。
                                                                  Ubuntu

2.用gnome-screenshot抓图

GNOME集成桌面环境自带了抓图工具“抓图(gnome-screenshot)”。在菜单“[[http://search.yesky.com/search.do?wd=%25E5%25BA%2594%25E7%2594%25A8][应用]]程序”→“附件”下找到“抓图”项，单击该项则运行“抓图”程序(图2)。“抓图”程
序提供了抓取整个桌面或当前活动窗口图像的功能，可以设定抓取前的延迟时间。另外，抓图程序也支持一些简单的特效，如是否包括[[http://product.yesky.com/mouse/][鼠标]]箭头、窗口边框以及
是否带有阴影效果或方框。

                                                                  Ubuntu

需要指出的是，在GNOME集成桌面环境下，使用功能键Print Screen或组合键Alt+Print Screen来抓取屏幕图像，在后台调用的正是gnome-screenshot程序
。与用键盘快捷键抓图相比，“抓图”程序增加了一些特效功能，适合于对截图有特定需求的用户。

3.用GIMP自带的抓图功能抓图

GIMP是Linux平台上可与[[http://product.yesky.com/imagesoftware/adobe/][Adobe]] Photoshop媲美的图像处理软件，该软件也自带截图的功能。在系统菜单“应用程序→图形”下找到“GIMP图片编辑器”项，单击
该项运行GIMP程序。在打开的GIMP应用程序窗口的菜单“文件→Create”下找到“屏幕抓图”项，单击该项则出现“屏幕抓图”窗口(图3)。

                                                                  Ubuntu

使用GIMP的抓图工具可以抓取整个屏幕或当前活动窗口的图像或屏幕上的选定区域。当用户点击“抓取”按钮后，抓取的图像自动出现在GIMP图像编辑器中，
我们既可以利用GIMP强大的图像编辑功能直接对抓取的图像进行处理，也可以将抓取的图像以某种图像文件格式保存。

4.功能强大的KSnapshot

KSnapshot是KDE集成桌面环境自带的截图工具，不过在GNOME集成桌面环境下也可以安装和使用它。我们可以通过新立得软件包管理器或使用apt-get命令来
安装它。假设使用命令行方式来安装，打开一个GNOME终端窗口，在终端窗口中输入如下命令：

sudo apt-get install ksnapshot

命令执行后，将在线下载并安装KSnapshot。安装完毕后，在菜单“应用程序”→“图像”下找到“KSnapshot”项，点击该项则运行KSnapshot程序(如图4)。
                                                                  Ubuntu

KSnapshot功能非常强大，提供的截图模式有全屏(Full Screen)、光标下的窗体(Window under cursor)、任意区域(Region)和窗体部件(Section of
Window)四种。其中“光标下的窗体”抓取模式可以在不激活要抓取的窗体的情况下，只要将鼠标移动到该窗体的某个区域即可抓取该窗体。

在输出所抓取的图像方面，KSnapshot增加了复制到剪贴板和直接打印的功能。KSnapshot应该算得上是一款较为专业的抓图工具，使用KSnapshot几乎可以
轻松抓取屏幕上的任意图像，笔者推荐大家安装和使用这款软件。

**** scrot                                                         :scrot:
***** reference

+ [[https://en.wikipedia.org/wiki/Scrot][Wikipedia]]
+ [[http://manpages.ubuntu.com/manpages/vivid/man1/scrot.1.html][Ubuntu Manpage]]

***** installation                                              :install:

apt-get

#+BEGIN_EXAMPLE
 sudo apt-get install scrot
#+END_EXAMPLE

***** guide

1. what is scrot
   Scrot is a minimalistic command ine screen capturing application.

   It allows substantial degree of flexibility by specifying
   parameters on command line, including the ability to invoke a
   third-party utility to manipulate the resulting screenshot.

2. Features
   + limit the scope fo capturing
   + set the delay
   + specify the filename template using wildcards
   + create thumbnal
   + specify the quality
   + follow the UNIX philosophy
   + CLT赋予了其远程运行的能力

3. Options
   + -h, --help   help message
   + -v, --version    display version number
   + -b, --border    include window bordre
   + -c, --count    display a countdown timer when used with delay
   + -d, --delay    delay the screen capturing
   + -e command    execute command after taking screenshot
   + -q, --quality    set the quality/compression
   + -s, --select    interactively select a windwo or rectangle with the mouse
   + -t, --thumb percentage    generate a thumbnail of the given ratio

4. -e 参数位标识
   + $f    图像文件名，包括路径
   + $f    图像文件名
   + $s    图像文件大小
   + $p    图像像素
   + $h    图像高度
   + $w    图像宽度
   + $t    图像格式
   + $$    字符$

5. Examples
   #+BEGIN_EXAMPLE
     $ scrot ~/fullscreen.png  # 全屏截图
     $ scrot -s ~/region.png   # 抓取窗口
     $ scrot -cd 10 ~/demo.png # 延时截图
     $ scrot -t 10% ～/thumb.png # 同时生成缩略图
     $ scrot -s ~/todeel.png -e 'gimp $f'  # 完成截图后处理
   #+END_EXAMPLE
***** 截图工具

+ scrot
+ gnome-screenshot

*** VGA DVI HDMI
+ http://bbs.mydigit.cn/simple/?t523987.html


目前在高清设备中，主要的接口有DVI、HDMI、VGA接口，其中VGA传输的是模拟
视频信号，DVI传播的是数字视频信号，HDMI可以同时传输数字视频信号和数字
音频信号。在现在的计算机和电视等设备中，我们经常可以看到这三种接口，很
多用户存在疑问，这三种接口之间有什么区别呢?

DVI接口是在1999年推出的接口标准。DVI接口的传输信号采用全数字格式，与之
对应的是采用模拟信号的VGA接口。VGA和DVI的区别，首先VGA模拟信号的传输比
较麻烦，首先是将电脑内的数字信号转换为模拟信号，将信号发送到LCD显示器，
由显示器再将该模拟信号转换为数字信号，形成画面展示在大家面前。正因为如
此，中间的信号丢失严重，虽然可以通过软件的方法修复部分画面，但是随着显
示器的分辨率越高画面就会越模糊。一般模拟信号在超过1280×1024分辨率以上
的情况下就会出现明显的误差，分辨率越高越严重。

VGA接口应用范围非常广泛，是三种接口中最先推出的标准，VGA(Video
Graphics Array)接口，也叫D-Sub接口。虽然液晶显示器可以直接接收数字信号，
但很多低端产品为了与VGA接口显卡相匹配，因而采用VGA接口。VGA接口是一种D
型接口，上面共有15针空，分成三排，每排五个。VGA接口是显卡上应用最为广
泛的接口类型，绝大多数的显卡都带有此种接口。

HDMI (High-Definition Multimedia Interface) ，常被称作高清晰度多媒体接
口，是终结以往影音分离传输的全新接口，其最大传输速度可达5Gb/s，除影像
数据外，更可同时传输高达8声道的音讯信号。这种非压缩式的数字数据传输，
可有效降低数/类转换所造成的信号干扰与衰减。HDMI是首个支持在单线缆上传
输，不经过压缩的全数字高清晰度、多声道音频和智能格式与控制命令数据的数
字接口。HDMI接口由Silicon Image美国晶像公司倡导，联合索尼、日立、松下、
飞利浦、汤姆逊、东芝等八家著名的消费类电子制造商联合成立的工作组共同开
发的。HDMI最早的接口规范HDMI1.0于2002年12月公布，目前的最高版本是于今
年6月发布的HDMI1.3规范。

HDMI源于DVI接口技术，它们主要是以美国晶像公司的TMDS信号传输技术为核心，
这也就是为何HDMI接口和DVI接口能够通过转接头相互转换的原因。美国晶像公
司是HDMI八个发起者中唯一的集成电路设计制造公司，是高速串行数据传输技术
领域的领导厂商。

目前的高端显卡上一般有VGA、DVI、HDMI接口，一般的显示卡VGA、DVI接口；目
前生产的大屏幕LED显示器上有VGA、HDMI接口（如三星24寸），中型LED显示器
有VGA、DVI接口（比如三星21寸），选购连接线前请注意观察显示卡和显示器接
口的匹配，接口型号不同时，可以选择转接线。

*** 双显示器

+ http://blog.chinaunix.net/uid-170694-id-2833685.html
+ http://imtx.me/archives/1695.html
+ http://dpinglee.blog.163.com/blog/static/1440977532010488594461/


1. 配置工具：xrandr

2. 快捷键：
   HOME+NUM 将焦点切换到lauch区对应的应用程序

** video                                                             :video:
*** 安装YouTube视频下载工具                             :youtube:blog_冰蓝:

[[http://lanbing510.info/2015/11/28/Ubuntu-Softwares.html][冰蓝记录思考的地方：Ubuntu下常用软件的安装使用及常见问题汇总]]

很多实验数据会从YouTube上下载，可以使用 *youtube-dl* 工具。

一、安装

#+BEGIN_EXAMPLE
    sudo apt-get install youtube-dl
#+END_EXAMPLE

二、配置使用

如果你已经翻墙，直接youbute-dl 视频网址 即可。例：

#+BEGIN_EXAMPLE
    youtube-dl http://www.youtube.com/watch?v=ksjfsjfslkjfskfjs
#+END_EXAMPLE

如果没有翻墙，可以使用代理，在~/.bashrc中添加

#+BEGIN_EXAMPLE
    http_proxy=http://xxx.xxx.xxx.xxx:yyyy #xxx yyy分别是代理的IP和端口
    export http_proxy
#+END_EXAMPLE

*** ffmpeg

**** reference                                                  :homepage:

- [[https://www.ffmpeg.org/][Homepage]]
- [[https://www.ffmpeg.org/ffmpeg.html][ffmpeg Document]]

**** intro

A complete, cross-platform solution to record, convert and stream
audio and video.

**** Winff                                                         :winff:

Winff是ffmpeg的GUI封装。

error: x-terminal-emulator: error: Additional unexpected arguments
found: ['&']

http://ubuntuforums.org/showthread.php?t=1541808

Look in WinFF's edit > preferences > linux > set terminal options
Change it from e to x, or vice versa. Then try it again.

**** 强大的视频处理工具---ffmpeg                               :blog_冰蓝:

[[http://lanbing510.info/2015/11/28/Ubuntu-Softwares.html][冰蓝记录思考的地方：Ubuntu下常用软件的安装使用及常见问题汇总]]

***** 安装                                                      :install:

需要提前安装yasm，从网上下载yasm的下载包，解压后进入到目录下安装：

#+BEGIN_EXAMPLE
    ./configure
    sudo make
    sudo make install
#+END_EXAMPLE

安装好yasm后，下载ffpeg安装包，解压，同样的方式进行安装。

***** usage

1. 分离视频音频流

   #+BEGIN_EXAMPLE
       ffmpeg -i input_file -vcodec copy -an output_file_video　　#分离视频流
       ffmpeg -i input_file -acodec copy -vn output_file_audio　　#分离音频流
   #+END_EXAMPLE

2. 视频解复用

   #+BEGIN_EXAMPLE
       ffmpeg –i test.mp4 –vcodec copy –an –f m4v test.264
       ffmpeg –i test.avi –vcodec copy –an –f m4v test.264
   #+END_EXAMPLE

3. 视频转码

   #+BEGIN_EXAMPLE
       ffmpeg –i test.mp4 –vcodec h264 –s 352*278 –an –f m4v test.264  #转码为码流原始文件
       ffmpeg –i test.mp4 –vcodec h264 –bf 0 –g 25 –s 352*278 –an –f m4v test.264 #转码为码流原始文件
       ffmpeg –i test.avi -vcodec mpeg4 –vtag xvid –qsame test_xvid.avi #转码为封装文件 -bf B帧数目控制，-g 关键帧间隔控制，-s 分辨率控制
   #+END_EXAMPLE

4. 视频封装

   #+BEGIN_EXAMPLE
       ffmpeg –i video_file –i audio_file –vcodec copy –acodec copy output_file
   #+END_EXAMPLE

5. 视音频剪切

   #+BEGIN_EXAMPLE
       ffmpeg –i test.avi –r 1 –f image2 image-%3d.jpeg  #提取图片
       ffmpeg -ss 0:1:30 -t 0:0:20 -i input.avi -vcodec copy -acodec copy output.avi #剪切视频 -r 提取图像的频率，-ss 开始时间，-t 持续时间
       ffmpeg -ss 0:1:30 -t 0:0:20 -i inout.mp3 -acodec copy output.mp3 #截取音频的中指定时间的一段
   #+END_EXAMPLE

6. 视频合并

   #+BEGIN_EXAMPLE
       ffmpeg -i "concat:input1.avi|input2.avi|input3.avi" -c copy output.avi
   #+END_EXAMPLE

7. 视频录制

   #+BEGIN_EXAMPLE
       ffmpeg -f vfwcap -r 15 -i 0 output.avi #通过摄像头录制视频
   #+END_EXAMPLE

8. 播放视频

   #+BEGIN_EXAMPLE
       ffplay input.avi
       ffplay -f rawvideo -video_size 1920x1080 input.yuv #YUV序列播放
   #+END_EXAMPLE

9. YUV序列转AVI

   #+BEGIN_EXAMPLE
       ffmpeg –s w*h –pix_fmt yuv420p –i input.yuv –vcodec mpeg4 output.avi
   #+END_EXAMPLE

10. 将图像序列转换为视频

   #+BEGIN_EXAMPLE
       ffmpeg  -f image2 -i prefix%d.jpg output.xxx
   #+END_EXAMPLE

11. 将视频转换为图像序列

   #+BEGIN_EXAMPLE
       ffmpeg -i input.xxx prefix%d.jpg
   #+END_EXAMPLE

更详细的使用命令推荐查看[[https://www.ffmpeg.org/ffmpeg.html][官方文档]]。

*** Recordmydesktop: 屏幕录像                             :recordmydesktop:
**** [[https://linuxtoy.org/archives/top-5-screen-recorder-for-linux.html][Linux 下值得使用的 5 个屏幕录像软件]]                            :blog:

在很多时候，我们需要将在 Linux
桌面上的操作过程录制下来，比如制作屏幕演示、视频教学等。这里将介绍在
Linux 下值得使用的 5 个屏幕录像软件，包括
Istanbul、Wink、Xvidcap、Vnc2swf、Recordmydesktop，希望对有此需求的朋友提供参考。

1. *[[http://linuxtoy.org/archives/istanbul.html][Istanbul]]* 使用
   Istanbul，你可以将 Linux 屏幕上的一切操作过程录制下来。Istanbul
   既能够按照你的需要录制全屏、区域或者窗口，也可以录制声音和鼠标指针，最终会生成
   Ogg Theora 格式的视频文件。

2. *[[http://linuxtoy.org/archives/wink.html][Wink]]* Wink 是录制 Flash
   视频演示的极好工具，除支持 Linux 平台外，也能够在 Windows
   系统上运行。你可以使用 Wink 为所录制的文件添加文字说明和声音旁白。

3. *[[http://linuxtoy.org/archives/xvidcap.html][Xvidcap]]* Xvidcap
   支持生成 avi、mpeg、asf、flv、swf、mov
   等视频格式，可以应用在各种场合。录制的区域也可以随意选择，显得非常
   方便。

4. *[[http://linuxtoy.org/archives/vnc2swf.html][Vnc2swf]]* Vnc2swf 是继
   Wink 外适合在 Linux 中使用的另一个 Flash 录制工具，但比 Wink
   稍微要难用点，而且也没有 Wink 功能全面。

5. *[[http://linuxtoy.org/archives/recordmydesktop.html][Recordmydesktop]]*
   Recordmydesktop
   功能主要有：可录制全屏、窗口，也可以录制选择的区域；除了能够录制视频的基本功能之外，还能够录制音频；有一些录制的参数可以调整；生成的视频格式为
   ogg。它默认提供 GTK+ 界面，另外也有一个适合 KDE 桌面环境的
   [[http://linuxtoy.org/archives/rekordmydesktop.html][reKordmydesktop]]。

**** recordmydesktop

- http://recordmydesktop.sourceforge.net/about.php

**** test

1. 验证使用Recordmydesktop效果可以，同时录制了双屏，满足需求。简单地试
   用了下命令行，没加任何参数。

2. 有一个原则，即 *不要在这些并不重要的东西上花费过多的时间。*

** audio                                                             :audio:
*** foobar                                                         :foobar:
**** 音乐播放器

1. +rhythmbox和虾米电台就足够了,这些事情上没有花费过多精力的必要+

2. +笔记本Ubuntu系统安装foobar并配置播放列表, 有悖于纯粹性的原则.+
   *Foobar最爱*

**** foobar使用

+ wine安装

+ 启动
  - 命令行方式，有问题
  - 链接，有问题
  - *直接在目录下双击图标，没问题* ，可能和启动目录有关

*** xmradio                                                 :xiami:xmradio:

+ https://github.com/timxx/xmradio

**** why

有的时候喜欢随机听自己收藏的歌。

**** installation                                                :install:
***** compile

#+BEGIN_EXAMPLE
cmake .. & make & make install
#+END_EXAMPLE

#+BEGIN_EXAMPLE
-- Checking for module 'libvlc >= 2.0'
--
CMake Error at /usr/local/share/cmake-3.4/Modules/FindPkgConfig.cmake:362 (message):
  A required package was not found
#+END_EXAMPLE

#+BEGIN_EXAMPLE
 $ apt-cache search libvlc
gnome-media-player - A simple media player for GNOME
libvlc-dev - libvlc 的开发文件
libvlc5 - 多媒体播放器和流媒体库
libvlccore-dev - development files for libvlccore
libvlccore8 - base library for VLC and its modules

$ sudo apt-get install libvlc-dev
#+END_EXAMPLE

#+BEGIN_EXAMPLE
-- Checking for module 'libpeas-1.0'
--   No package 'libpeas-1.0' found
#+END_EXAMPLE

#+BEGIN_EXAMPLE
-- Checking for module 'libnotify'
--   No package 'libnotify' found
#+END_EXAMPLE

compile OK

***** running

#+BEGIN_EXAMPLE
xmradio: error while loading shared libraries: libxmradio-core.so:
cannot open shared object file: No such file or directory
#+END_EXAMPLE


#+BEGIN_EXAMPLE
-- Installing: /usr/local/lib/libxmradio-core.so
#+END_EXAMPLE

#+BEGIN_EXAMPLE
$ ldd /usr/local/bin/xmradio | grep core
#+END_EXAMPLE

存在

可能是 64 位机的问题，暂时不再考虑源码编译！

***** ppa

http://ppa.launchpad.net/timxx/xmradio/ubuntu/pool/main/x/xmradio/

#+BEGIN_EXAMPLE
  dpkg: 依赖关系问题使得 xmradio 的配置工作不能继续：
  xmradio 依赖于 libvlccore5；然而：
  未安装软件包 libvlccore5。
  xmradio 依赖于 gnome-icon-theme；然而：
  未安装软件包 gnome-icon-theme。
#+END_EXAMPLE

#+BEGIN_EXAMPLE
[0000000001457bd8] core libvlc error: No plugins found! Check your VLC installation.
段错误 (核心已转储)
#+END_EXAMPLE

PPA 不再更新，包已经破损，也少折腾。

**** 直接使用网页版的虾米电台

http://www.xiami.com/radio/play/type/4/oid/8365731?spm=a1z1s.6626009.0.0.OIQNc1

更好的是 *手机虾米 -> 我的收藏 -> 随机播放*

*** [[http://www.uzzf.com/soft/63096.html][电脑录音软件]]                                                :blog:录音:

Wondershare Streaming Audio Recorder 是一款易于使用的程序，可让您录制
某网站上播放的歌曲或任何网页的背景音乐。本程序通过使用虚拟声卡，能够检
测任何流音频。它可以记录在线音乐商店和在线广播电台的音频信号。即使是受
到 DRM 保护的音乐文件，它也能轻松捕捉到。

您可以编辑和自定义录制好的文件，也可调整采样率和伴音通道等设置。音频文
件可录制成高保真 MP3、WMA 和 WAV 等其他常见音频格式。此外，您还可在便
携式设备上保存文件，如 iPod、iPhone 和 PSP 等。

借助 Wondershare Streaming Audio Recorder，您可随心所欲地录制音乐。

*** cue 文件制作                                                 :cue:无损:

#+BEGIN_EXAMPLE
  PERFORMER "陈奕迅"
  TITLE "一滴眼泪"
  FILE "陈奕迅.-.[一滴眼泪].专辑.(APE).ape" WAVE
    TRACK 01 AUDIO
      TITLE "一滴眼泪"
      PERFORMER "陈奕迅"
      INDEX 01 00:00:00
    TRACK 02 AUDIO
      TITLE "拜访"
      PERFORMER "陈奕迅"
      INDEX 01 05:20:25
  ...
#+END_EXAMPLE

文本文件，十分简单
- 无损文件文件名
- TRACK
  - 开始时间

*好像也没那么简单*

Ubuntu 下使用 Foobar 可能还和 文件编码有关，不是特别明白

**** 世界上唯一的花 CUE 制作

http://www.80nba.com/yinyue/rihanyinle/2016/0107/30535.html （CUE 文件
下载异常）

http://www.verycd.com/topics/2939029/comments/page1

*** 无损专辑文件分解                      :flac:cue:ape:无损：分轨：foobar:

[[http://zhidao.baidu.com/link?url=ctwv8JEeRCgndqT9Uns9eBnpFsYQ8CUPwxtxV7z9tyNxEfYuTPv8bdkM0ELMXc_KtFtDUp4UNqWDqmcq0HbZMa][百度知道]]

要制作FLAC音频文件首先需要FLAC编码器flac.exe，你可以到这里下载：
http://www.onlinedown.net/soft/30853.htm ，下载后把flac.exe文件放到
Foobar文件夹下即可。

用Foobar打开CUE文件，然后在播放列表中选择全部曲目，鼠标右键选择“转
换”→“转换到”，在编码预置中选择FLAC，接下来选择输出目录，确定即可。

Foobar 无以伦比。

学名 ： *分轨*

** web
*** NAT                                        :nat:网络地址转换:公网:内网:

在计算机网络中， *网络地址转换* （英语：Network Address Translation，缩写
为NAT），也叫做网络掩蔽或者IP掩蔽（IP masquerading），是一种在IP封包通
过路由器或防火墙时重写源IP地址或目的IP地址的技术。这种技术被普遍使用在
*有多台主机但只通过一个公有IP地址访问因特网的私有网络中* 。

NAT 是作为一种解决IPv4地址短缺以避免保留IP地址困难的方案而流行起来的。
网络地址转换在很多国家都有很广泛的使用。

公网、内网是两种Internet的接入方式。

内网接入方式：上网的计算机得到的IP地址是Inetnet上的保留地址，保留地址有如下3种形式：
+ 10.x.x.x
+ 172.16.x.x至172.31.x.x
+ 192.168.x.x

_内网的计算机以NAT（网络地址转换）协议，通过一个公共的网关访问Internet。_

=内网的计算机可向Internet上的其他计算机发送连接请求，但Internet上其他
的计算机无法向内网的计算机发送连接请求。=

公网接入方式：上网的计算机得到的IP地址是Inetnet上的非保留地址。公网的
计算机和Internet上的其他计算机可随意互相访问。

NAT（Network Address Translator）是网络地址转换，它实现内网的IP地址与
公网的地址之间的相互转换，将大量的内网IP地址转换为一个或少量的公网IP地
址，减少对公网IP地址的占用。NAT的最典型应用是：在一个局域网内，只需要
一台计算机连接上Internet，就可以利用NAT共享Internet连接，使局域网内其
他计算机也可以上网。使用NAT协议，局域网内的计算机可以访问Internet上的
计算机，但Internet上的计算机无法访问局域网内的计算机。

*** ndiswrapper                                  :ndiswrapper:wifi:ndisgtk:
:NOTE:
简单地尝试了下配置USB无线网卡，没有成功，比较繁琐，而且不见得有必要。2016/02/27
:END:

- [[http://ndiswrapper.sourceforge.net/wiki/index.php/Main_Page][SourceForge]]
- [[https://wiki.archlinux.org/index.php/Wireless_network_configuration_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)][ArchLinux]]
- [[https://help.ubuntu.com/community/WifiDocs/Driver/Ndiswrapper][HowTo]]
- [[https://en.wikipedia.org/wiki/NDISwrapper][WikiPedia]]

ndiswrapper: Linux 使用仅提供 Windows 驱动的无线网卡

如果列表中没有，可能你的设备只提供了 Windows 驱动(比如 Broadcom, 3com
等)。这时需要用 ndiswrapper.Ndiswrapper 可以在 Linux 中使用 Windows 驱
动。兼容性列表在 这里. 需要
Windows 中安装的 .inf 和 .sys 文件。如果有更新的网卡，请通过互联网搜索
型号名称 + 'linux' 以获取更多信息。

There is also a graphical interface for ndiswrapper that you can use
called *ndisgtk*.

*** Linux 无线网手动配置                     :wireless:wifi:wlan:archlinux:

- [[https://wiki.archlinux.org/index.php/Wireless_network_configuration_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)][Wireless network configuration (简体中文)]]

From ArchWiki

配置无线网络一般分两步：第一步是识别硬件、安装正确的驱动程序并进行配置，
安装盘中已经包含驱动，但是通常需要额外安装；第二步是选择一种管理无线连
接的方式。

这篇文章涵盖了这两方面，并提供了无线管理工具的链接地址。

**** 设备驱动

默认的 Arch Linux
内核是*模块化*的，，硬件的设备驱动作为[[/index.php/Kernel_modules][内核模块]]保存在硬盘上。启动时
[[/index.php/Udev][udev]]
会根据硬件加载不同的驱动模块，这就创建了需要的网络接口。

有些无线芯片需要额外的固件，默认安装的
[[https://www.archlinux.org/packages/?name=linux-firmware][linux-firmware]]
提供了很多固件。如果缺失需要的固件，请查看
[[#.E5.AE.89.E8.A3.85_driver.2Ffirmware][#安装 driver/firmware]].

Udev
不是完美的，有些内核模块需要[[/index.php/Kernel_modules#Loading][手动安装]].
有些时候 Udev
会同时加载相互冲突的多个模块，就需要[[/index.php/Kernel_modules#Blacklisting][屏蔽]]
不需要的模块。

***** 检查设备状态

根据设备是 PCI 还是 USB 连接，执行 =lspci -k= 或 =lsusb -v=
检查设备驱动是否已经加载：

#+BEGIN_EXAMPLE
    $ lspci -k
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    06:00.0 Network controller: Intel Corporation WiFi Link 5100
        Subsystem: Intel Corporation WiFi Link 5100 AGN
        Kernel driver in use: iwlwifi
        Kernel modules: iwlwifi
#+END_EXAMPLE

如果是 USB 设备，执行 =dmesg | grep usbcore= 可以看到类似下面的输出
=usbcore: registered new interface driver rtl8187=。

通过 =ip link= 查看无线
([[/index.php/Network_configuration#Device_names][设备名]]，通常是类似
=wlp2s1=) 的设备。启用设备：

#+BEGIN_EXAMPLE
    # ip link set <设备名> up
#+END_EXAMPLE

如果设备加载，接口正常启用，说明不需要安装额外的驱动和固件。

***** 安装 driver/firmware

错误信息=SIOCSIFFLAGS: No such file or directory= 说明需要固件才能工作,

检查内核中的固件信息：

#+BEGIN_EXAMPLE
    $ dmesg | grep firmware
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [   7.148259] iwlwifi 0000:02:00.0: loaded firmware version 39.30.4.1 build 35138 op_mode iwldvm
#+END_EXAMPLE

如果没有类似的输出，先执行命令，例如=iwlwifi=，然后查找对应的错误信息：

#+BEGIN_EXAMPLE
    $ dmesg | grep iwlwifi
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [   12.342694] iwlwifi 0000:02:00.0: irq 44 for MSI/MSI-X
    [   12.353466] iwlwifi 0000:02:00.0: loaded firmware version 39.31.5.1 build 35138 op_mode iwldvm
    [   12.430317] iwlwifi 0000:02:00.0: CONFIG_IWLWIFI_DEBUG disabled
    ...
    [   12.430341] iwlwifi 0000:02:00.0: Detected Intel(R) Corporation WiFi Link 5100 AGN, REV=0x6B
#+END_EXAMPLE

根据获得的信息，在下面网址查找硬件支持：

-  [[https://help.ubuntu.com/community/WifiDocs/WirelessCardsSupported][Ubuntu Wiki]] 维护了一个设备被内核和用户空间驱动支持状况的列表。
-  [[http://linux-wless.passys.nl/][Linux 无线支持页面]] 和 [[http://www.linuxquestions.org/hcl/index.php?cat=10][硬件兼容性列表]](HCL) 也维护了一个内核友好的设备列表。
-  [[http://wireless.kernel.org/en/users/Devices][内核页面]] 也有一个支持的硬件矩阵。

如果列表中没有，可能你的设备只提供了 Windows 驱动(比如 Broadcom, 3com等)。这时需要用
[[http://ndiswrapper.sourceforge.net/wiki/index.php/List][ndiswrapper]].

Ndiswrapper 可以在 Linux 中使用 Windows 驱动。兼容性列表在 [[http://ndiswrapper.sourceforge.net/mediawiki/index.php/List][这里]].
需要 Windows 中安装的 =.inf= 和 =.sys= 文件。如果有更新的网卡，请通过
互联网搜索型号名称 + 'linux'以获取更多信息。

**** 无线网络管理

为了管理已经安装好的无线驱动，并且使无线能正常工作，需要安装一个无线连接管理工具。下面章节将帮助您确定一个最佳管理方法。

过程和需要使用的工具，将依赖于下面几个因素:

-  配置方式，从完全手动执行每一步到软件自动管理、自动启动
-  是否使用加密及加密类型
-  是否需要区分网络配置,是否经常切换不同网络（比如手提电脑）。

无论选的那个方案，最好先尝试手动方法。这将有助于您了解不同步骤的意义，并在出问题时解决之。
如果可以的话（比如说你在管理你自己的无线接入点），尝试连接一个开放的无线网络来检查是否所有的配置都在正常工作。然后再尝试加密的无线接入点，比如WEP（更易于配置）或者WPA。

此表列出可以使用的激活和管理无线网络的方法，按照加密和管理方式分类，给
出了需要的工具。虽然还有其他办法，但这些是最常使用的:



这些工具会自动安装手动配置需要的工具。

***** 手动设置

软件包
[[https://www.archlinux.org/packages/?name=wireless_tools][wireless_tools]]
提供了建立无线连接的基础工具。如果你需要使用 WPA/WPA2 加密，还需要
[[https://www.archlinux.org/packages/?name=wpa_supplicant][wpa_supplicant]]。
这些强大的用户空间终端工具提供了完全的控制手段。

这些例子假设无线设备是 =wlan0=, 请将其替换为正确的设备名。

*注意:*
根据硬件和加密方式的不同，下面一些步骤可以省略。有些设备需要在建立关联时激活接口或扫描访问点，并提供
IP 地址。需要进行一些尝试，例如 WPA/WPA2
用户可以直接到第三步激活无线网络。

和其它网络接口一样，无线设备也是通过
[[https://www.archlinux.org/packages/?name=iproute2][iproute2]]
软件包提供的 ip 命令进行。

基本的工具如下，这些用户空间工具可以对无线连接进行完整控制。

-  [[https://www.archlinux.org/packages/?name=iw][iw]] - 当前的 nl80211
   标准，不是所有的芯片都支持。
-  [[https://www.archlinux.org/packages/?name=wireless_tools][wireless_tools]]
   - 已经过时，但是依然广泛使用。
-  [[https://www.archlinux.org/packages/?name=wpa_supplicant][wpa_supplicant]]
   - 提供 WPA/WPA2 加密支持

下面表格给出了 =iw= 和 =wireless_tools= 命令的对比(更多示例参阅
[[http://wireless.kernel.org/en/users/Documentation/iw/replace-iwconfig][这里]]).

*Note:*

-  示例中使用网络接口 =wlan0= 和热点 =your_essid=.
-  大部分命令需要以 [[/index.php/Users_and_groups][root 权限]]执行，否则会无输出就退出。

| /iw/ 命令                                          | /wireless_tools/ 命令                              | 描述                              |
| iw dev wlan0 link                                  | iwconfig wlan0                                     | 获取连接状态                      |
| iw dev wlan0 scan                                  | iwlist wlan0 scan                                  | 扫描可用热点                      |
| iw dev wlan0 set type ibss                         | iwconfig wlan0 mode ad-hoc                         | 设置操作模式为 /ad-hoc/.          |
| iw dev wlan0 connect /your_essid/                  | iwconfig wlan0 essid /your_essid/                  | 连接到开放网络                    |
| iw dev wlan0 connect /your_essid/ 2432             | iwconfig wlan0 essid /your_essid/ freq 2432M       | 连接到开放网络的一个频道          |
| iw dev wlan0 connect /your_essid/ key 0:/your_key/ | iwconfig wlan0 essid /your_essid/ key /your_key/   | 用16进制加密密码访问 WEP 加密网络 |
| iw dev wlan0 connect /your_essid/ key 0:/your_key/ | iwconfig wlan0 essid /your_essid/ key s:/your_key/ | 用 ASCII 密码访问 WEP 加密网络.   |
| iw dev wlan0 set power_save on                     | iwconfig wlan0 power on                            | 启用省电模式                      |

*注意:*
根据硬件和加密设备的不同，有些步骤可以跳过。一些网卡需要在关联到热点前先激活或扫描热点，需要一些实验才能确定。WPA/WPA2
用户可以按照[[#.E5.85.B3.E8.81.94][#关联]]中的步骤激活网络。

****** 获取有用信息

[[http://wireless.kernel.org/en/users/Documentation/iw][iw 官方文档]]
包含更多示例。

-  获取接口名:

#+BEGIN_EXAMPLE
    $ iw dev
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    phy#0
        Interface wlan0
            ifindex 3
            wdev 0x1
            addr 12:34:56:78:9a:bc
            type managed
            channel 1 (2412 MHz), width: 40 MHz, center1: 2422 MHz
#+END_EXAMPLE

-  检查连接状态，未连接时，可以看到：

#+BEGIN_EXAMPLE
    $ iw dev wlan0 link
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    Not connected.
#+END_EXAMPLE

连接到 AP 后可以看到：

#+BEGIN_EXAMPLE
    $ iw dev wlan0 link
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    Connected to 12:34:56:78:9a:bc (on wlan0)
        SSID: MyESSID
        freq: 2412
        RX: 33016518 bytes (152703 packets)
        TX: 2024638 bytes (11477 packets)
        signal: -53 dBm
        tx bitrate: 150.0 MBit/s MCS 7 40MHz short GI

        bss flags:  short-preamble short-slot-time
        dtim period:    1
        beacon int: 100
#+END_EXAMPLE

-  获取统计数据:

#+BEGIN_EXAMPLE
    $ iw dev wlan0 station dump
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    Station 12:34:56:78:9a:bc (on wlan0)
        inactive time:  1450 ms
        rx bytes:   24668671
        rx packets: 114373
        tx bytes:   1606991
        tx packets: 8557
        tx retries: 623
        tx failed:  1425
        signal:     -52 dBm
        signal avg: -53 dBm
        tx bitrate: 150.0 MBit/s MCS 7 40MHz short GI
        authorized: yes
        authenticated:  yes
        preamble:   long
        WMM/WME:    yes
        MFP:        no
        TDLS peer:  no
#+END_EXAMPLE

****** 激活内核接口

(可能需要) 一些无线网卡在使用
[[https://www.archlinux.org/packages/?name=wireless_tools][wireless_tools]]前需要激活内核接口:

#+BEGIN_EXAMPLE
    # ip link set wlan0 up
#+END_EXAMPLE

如果出现错误 =RTNETLINK answers: Operation not possible due to RF-kill=,
请确保硬件开关已经打开。参阅 [[#Rfkill_caveat][#Rfkill caveat]]。

要验证接口确实打开：

#+BEGIN_EXAMPLE
    # ip link show wlan0
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state DOWN mode DORMANT group default qlen 1000
        link/ether 12:34:56:78:9a:bc brd ff:ff:ff:ff:ff:ff
#+END_EXAMPLE

=<BROADCAST,MULTICAST,UP,LOWER_UP>= 中的=UP= 显示接口已经打开。

****** 查看接入点

#+BEGIN_EXAMPLE
    # iw dev wlan0 scan |less
#+END_EXAMPLE

*注意:* 如果显示 "Interface doesn't support
scanning"，可能是忘了安装固件。有时不以 root 运行 =iwlist=
也会产生这个问题。同样无线网络可能被软禁于，请安装
[[https://www.archlinux.org/packages/?name=rfkill][rfkill]] 并运行
=rfkill list all= 进行检查。

The important points to check:

-  *SSID:* the name of the network.
-  *Signal:* is reported in a wireless power ratio in dbm (e.g. from
   -100 to 0). The closer the negative value gets to zero, the better
   the signal. Observing the reported power on a good quality link and a
   bad one should give an idea about the individual range.
-  *Security:* it is not reported directly, check the line starting with
   =capability=. If there is =Privacy=, for example
   =capability: ESS Privacy ShortSlotTime (0x0411)=, then the network is
   protected somehow.

   -  If you see an =RSN= information block, then the network is
      protected by
      [[https://en.wikipedia.org/wiki/Robust_Security_Network][Robust
      Security Network]] protocol, also known as WPA2.
   -  If you see an =WPA= information block, then the network is
      protected by
      [[https://en.wikipedia.org/wiki/Wi-Fi_Protected_Access][Wi-Fi
      Protected Access]] protocol.
   -  In the =RSN= and =WPA= blocks you may find the following
      information:

      -  *Group cipher:* value in TKIP, CCMP, both, others.
      -  *Pairwise ciphers:* value in TKIP, CCMP, both, others. Not
         necessarily the same value than Group cipher.
      -  *Authentication suites:* value in PSK, 802.1x, others. For home
         router, you'll usually find PSK (/i.e./ passphrase). In
         universities, you are more likely to find 802.1x suite which
         requires login and password. Then you will need to know which
         key management is in use (e.g. EAP), and what encapsulation it
         uses (e.g. PEAP). Find more details at
         [[https://en.wikipedia.org/wiki/Authentication_protocol][Wikipedia:Authentication
         protocol]] and the sub-articles.

   -  If you do not see neither =RSN= nor =WPA= blocks but there is
      =Privacy=, then WEP is used.

****** 操作模式

(可能需要)
设置无线网卡的操作模式，如果连接到漫游网络，需要设置操作模式为 *ibss*

#+BEGIN_EXAMPLE
    # iw wlan0 set type ibss
#+END_EXAMPLE

*注意:*
有些网卡需要先关闭无线接口(=ip link set wlan0 down=)才能修改模式。

****** 关联

根据加密方式不同，需要使用密码将无线设备关联到接入点。

假设要使用的接入点 ESSID 为 =MyEssid=:

-  无加密

#+BEGIN_EXAMPLE
    # iw wlan0 connect MyEssid
#+END_EXAMPLE

-  WEP

使用十六进制或 ASCII 密码(格式是自动识别出来的，因为 WEP
密码长度是固定的):

#+BEGIN_EXAMPLE
    # iw dev wlan0 connect your_essid key 0:your_key
#+END_EXAMPLE

使用十六进制或 ASCII 密码，第三个是默认 (从0计数，共四个):

#+BEGIN_EXAMPLE
    # iw dev wlan0 connect your_essid key d:2:your_key
#+END_EXAMPLE

-  *WPA/WPA2*

#+BEGIN_EXAMPLE
    # wpa_supplicant -i interface -c <(wpa_passphrase your_SSID your_key)
#+END_EXAMPLE

假设设备使用 =wext= 驱动。如果无法工作，可能需要调整选项，参见
[[/index.php/WPA_Supplicant][WPA_Supplicant]]。

如果连接成功，在新终端中执行后续命令或(或者通过 =Ctrl+c= 退出并使用 =-B=
参数在后台再次执行上述命令。[[/index.php/WPA_Supplicant][WPA_Supplicant]]
页面包含更多参数和配置文件的信息。

通过下面命令确认是否连接成功：

#+BEGIN_EXAMPLE
    # iw dev wlan0 link
#+END_EXAMPLE

****** 获取 IP 地址

使用 DHCP：

#+BEGIN_EXAMPLE
    # dhcpcd wlan0
#+END_EXAMPLE

或

#+BEGIN_EXAMPLE
    # dhclient wlan0
#+END_EXAMPLE

静态 IP：

#+BEGIN_EXAMPLE
    # ip addr add 192.168.0.2/24 dev wlan0
    # ip route add default via 192.168.0.1
#+END_EXAMPLE

*Tip:* [[/index.php/Dhcpcd][dhcpcd]] contains a hook (enabled by
default) to automatically launch [[/index.php/WPA_supplicant][WPA
supplicant]] on wireless interfaces. It is started only if a
configuration file at =/etc/wpa_supplicant/wpa_supplicant.conf= exists
and no /wpa_supplicant/ process is listening on that interface. In most
cases, you do not need to create any
[[#Manual_wireless_connection_at_boot_using_systemd_and_dhcpcd][custom
service]], just enable =dhcpcd@interface=.

****** Custom startup scripts/services

Although the manual configuration method will help troubleshoot wireless
problems, you will have to re-type every command each time you reboot.
You can also quickly write a shell script to automate the whole process,
which is still a quite convenient way of managing network connection
while keeping full control over your configuration. You can find some
examples in this section.

******* Manual wireless connection at boot using systemd and dhcpcd

This example uses [[/index.php/Systemd][systemd]] for start up,
[[/index.php/WPA_supplicant][WPA supplicant]] for connecting, and
[[https://www.archlinux.org/packages/?name=dhcpcd][dhcpcd]] for
assigning an IP address.

*Note:* Make sure that
[[https://www.archlinux.org/packages/?name=wpa_supplicant][wpa_supplicant]]
is installed and create =/etc/wpa_supplicant/wpa_supplicant.conf=. See
[[/index.php/WPA_supplicant][WPA supplicant]] for details.

Create a systemd unit, e.g
=/etc/systemd/system/network-wireless@.service=:

#+BEGIN_EXAMPLE
    /etc/systemd/system/network-wireless@.service
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [Unit]
    Description=Wireless network connectivity (%i)
    Wants=network.target
    Before=network.target
    BindsTo=sys-subsystem-net-devices-%i.device
    After=sys-subsystem-net-devices-%i.device

    [Service]
    Type=oneshot
    RemainAfterExit=yes

    ExecStart=/usr/bin/ip link set dev %i up
    ExecStart=/usr/bin/wpa_supplicant -B -i %i -c /etc/wpa_supplicant/wpa_supplicant.conf
    ExecStart=/usr/bin/dhcpcd %i

    ExecStop=/usr/bin/ip link set dev %i down

    [Install]
    WantedBy=multi-user.target
#+END_EXAMPLE

Start and/or enable the unit as described in
[[/index.php/Systemd#Using_units][systemd#Using units]], remember to
pass the name of the interface:

#+BEGIN_EXAMPLE
    # systemctl enable network-wireless@wlan0.service
    # systemctl start network-wireless@wlan0.service
#+END_EXAMPLE

******* Systemd with wpa_supplicant and static IP

*Note:* Make sure that
[[https://www.archlinux.org/packages/?name=wpa_supplicant][wpa_supplicant]]
is installed and create a custom
=/etc/wpa_supplicant/wpa_supplicant.conf=. See
[[/index.php/WPA_supplicant][WPA supplicant]] for details.

First create configuration file for the [[/index.php/Systemd][systemd]]
service, replace =interface= with proper interface name:

#+BEGIN_EXAMPLE
    /etc/conf.d/network-wireless@interface
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    address=192.168.0.10
    netmask=24
    broadcast=192.168.0.255
    gateway=192.168.0.1
#+END_EXAMPLE

Create a systemd unit file:

#+BEGIN_EXAMPLE
    /etc/systemd/system/network-wireless@.service
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [Unit]
    Description=Wireless network connectivity (%i)
    Wants=network.target
    Before=network.target
    BindsTo=sys-subsystem-net-devices-%i.device
    After=sys-subsystem-net-devices-%i.device

    [Service]
    Type=oneshot
    RemainAfterExit=yes
    EnvironmentFile=/etc/conf.d/network-wireless@%i

    ExecStart=/usr/bin/ip link set dev %i up
    ExecStart=/usr/bin/wpa_supplicant -B -i %i -c /etc/wpa_supplicant/wpa_supplicant.conf
    ExecStart=/usr/bin/ip addr add ${address}/${netmask} broadcast ${broadcast} dev %i
    ExecStart=/usr/bin/ip route add default via ${gateway}

    ExecStop=/usr/bin/ip addr flush dev %i
    ExecStop=/usr/bin/ip link set dev %i down

    [Install]
    WantedBy=multi-user.target
#+END_EXAMPLE

Enable the unit and start it, passing the name of the interface:

#+BEGIN_EXAMPLE
    # systemctl enable network-wireless@wlan0.service
    # systemctl start network-wireless@wlan0.service
#+END_EXAMPLE

****** 自动设置

有许多可选方法，但是注意它们是互斥的，不能同时运行两个守护进程。下面是比较表格：

| 连接管理器 | profiles 支持 | 漫游\\ | (自动连接和重连) | [[https://en.wikipedia.org/wiki/point-to-point_protocol][PPP]] 支持\\ | (3G modem) | 官方\\ | GUI | 控制台工具 |

| [[/index.php/Connman][Connman]]        | Yes | Yes | Yes | No  | =connmanctl=         |
| [[/index.php/Netctl][Netctl]]         | Yes | Yes | Yes | No  | =netctl=,=wifi-menu= |
| [[/index.php/NetworkManager][NetworkManager]] | Yes | Yes | Yes | Yes | =nmcli=              |
| [[/index.php/Wicd][Wicd]]           | Yes | Yes | No  | Yes | =wicd-curses=        |

****** Connman

ConnMan is an alternative to NetworkManager and Wicd, designed to be
light on resources making it ideal for netbooks, and other mobile
devices. It is modular in design takes advandage of the dbus API and
provides proper abstraction on top of wpa_supplicant.

See: [[/index.php/Connman][Connman]]

****** Netctl

/netctl/ is a replacement for /netcfg/ designed to work with systemd. It
uses a profile based setup and is capable of detection and connection to
a wide range of network types. This is no harder than using graphical
tools.

See: [[/index.php/Netctl][Netctl]]

******* Wicd

Wicd 是可以同时处理无线和有线网络的管理器。用 Python 和 Gtk
写成，依赖关系比 NetworkManager
少，所以是轻量级桌面的理想选择。位于[[/index.php/Official_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)][官方软件仓库]].

参见: [[/index.php/Wicd][Wicd]]

*Note:* [[/index.php/Wicd][wicd]] may cause excessive dropped
connections with some drivers, while
[[/index.php/NetworkManager][NetworkManager]] might work better.

******* NetworkManager

NetworkManager
是高级网络管理工具，在大部分流行发行版中使用。除了能管理有线链接，NetworkManager还提供了一个易于使用的图形界面程序来选择想要的无线移动链接。

*Note:* GNOME's
[[https://www.archlinux.org/packages/?name=network-manager-applet][network-manager-applet]]
also works under [[/index.php/Xfce][Xfce]] if you install
[[https://aur.archlinux.org/packages/xfce4-xfapplet-plugin/][xfce4-xfapplet-plugin]]^{AUR[[[/index.php/ArchWiki:Requests#Broken_package_links][broken
link]]: archived in
[[http://pkgbuild.com/git/aur-mirror.git/tree/xfce4-xfapplet-plugin][aur-mirror]]]}
(available in the [[/index.php/Arch_User_Repository][AUR]]) first.
Additionally, there are applets available for [[/index.php/KDE][KDE]].

详情请见 [[/index.php/NetworkManager][NetworkManager]]。

******* Wifi Radar

WiFi Radar是 一个Python/PyGTK2
的管理无线配置的程序（*只有*无线）。它能够扫描可用的网络,为选择的网络创建新的配置。

详情请见[[/index.php/Wifi_Radar][Wifi Radar]]。

*** VPN                                                               :vpn:
**** [[http://forum.nydus.co/forum.php?mod=viewthread&tid=4406&extra=page=1][Linux VPN设置教程]]                                          :blog:vpn:

 注：由于桌面环境的不同，方法可能会有所差异
 1.在“系统设置”中找的“网络”
 [[static/image/common/none.gif]]
 *图片1.png* /(105.53 KB, 下载次数: 9)/

 [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1MnxhNmQxMjQxNHwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]

 2014-7-29 11:03 上传

 2.打开“网络”，选择左下角的“+”
 [[static/image/common/none.gif]]
 *图片2.png* /(42.26 KB, 下载次数: 2)/

 [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1M3wzNmRhNGVhNXwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]

 2014-7-29 11:03 上传

 3.点击“+”后选择“VPN”
 [[static/image/common/none.gif]]
 *图片3.png* /(34.09 KB, 下载次数: 1)/

 [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1NHxjMDI2MzMyM3wxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]

 2014-7-29 11:03 上传

 4.选择“PPTP”
 [[static/image/common/none.gif]]
 *图片4.png* /(50.5 KB, 下载次数: 1)/

 [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1NXxiYjRlMTI1Y3wxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]

 2014-7-29 11:04 上传

 5.输入网关、用户名、密码
 [[static/image/common/none.gif]]
 *图片5.png* /(58.87 KB, 下载次数: 1)/

 [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1NnxiMGNjMTZhMnwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]

 2014-7-29 11:04 上传

 6.选择右下角的“高级”
 [[static/image/common/none.gif]]
 *图片6.png* /(43.03 KB, 下载次数: 2)/

 [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1N3wzYjZkYzExMXwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]

 2014-7-29 11:04 上传

 7.取消“EAP”，勾选“使用点到点加密（MPPE）”
 [[static/image/common/none.gif]]
 *图片7.png* /(63.88 KB, 下载次数: 2)/

 [[http://forum.nydus.co/forum.php?mod=attachment&aid=MTA1OHxjZjM2Njk4ZnwxNDUzNTM3ODE3fDB8NDQwNg%3D%3D&nothumb=yes][下载附件]]

 2014-7-29 11:04 上传

 9.在右上角的网络图标找到“VPN”那栏，选择刚刚你配置的VPN的连接的名字，进行连接（注：不是所有的桌面环境都是这样的）

**** [[http://blog.fens.me/ubuntu-vpn-pptp/][在Ubuntu上安装PPTP VPN服务]]                                 :blog:vpn:

此图完整的阐述了身为帝国平民的必备技能之一，VPN服务则是此种技能的技术实现，虚拟专用网络（Virtual Private Network ，简称VPN)指的是在公用网络上建立专用网络的技术。它涵盖了跨共享网络或公共网络的封装、加密和身份验证链接的专用网络的扩展。VPN主要采用了彩隧道技术、加解密技术、密钥管理技术和使用者与设备身份认证技术。
点对点隧道协议（PPTP）是VPN服务的一种最简单的实现协议，其它常见的VPN类型还有：使用IPsec的第2层隧道协议（L2TP/IPsec）、安全套接字隧道协议（SSL VPN）。本文主要讨论PPTP VPN服务在Ubuntu上的安装和配置。

A.使用apt源服务来安装PPTPD服务


sudo apt-get update
sudo apt-get install pptpd
B.安装完成之后编辑pptpd.conf配置文件


sudo vi /etc/pptpd.conf

#确保如下选项的配置
option /etc/ppp/pptpd-option                    #指定PPP选项文件的位置
debug                                           #启用调试模式
localip 192.168.0.1                             #VPN服务器的虚拟ip
remoteip 192.168.0.200-238,192.168.0.245        #分配给VPN客户端的虚拟ip
C.编辑PPP选项配置文件

sudo vi /etc/ppp/pptpd-options

#确保如下选项的配置
name pptpd                      #pptpd服务的名称
refuse-pap                      #拒绝pap身份认证模式
refuse-chap                     #拒绝chap身份认证模式
refuse-mschap                   #拒绝mschap身份认证模式
require-mschap-v2               #允许mschap-v2身份认证模式
require-mppe-128                #允许mppe 128位加密身份认证模式
ms-dns 8.8.8.8                  #使用Google DNS
ms-dns 8.8.4.4                  #使用Google DNS
proxyarp                        #arp代理
debug                           #调试模式
dump                            #服务启动时打印出所有配置信息
lock                            #锁定TTY设备
nobsdcomp                       #禁用BSD压缩模式
logfile /var/log/pptpd.log      #输出日志文件位置
D.编辑用户配置文件来添加用户

sudo vi /etc/ppp/chap-secrets

#格式：用户名   服务类型   密码   分配的ip地址
test    *    1234    *
#第一个*代表服务可以是PPTPD也可以是L2TPD，第二个*代表随机分配ip
E.重启PPTPD服务


sudo service pptpd restart
F.配置网络和路由规则 设置ipv4转发


sudo sed -i 's/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/g' /etc/sysctl.conf
sudo sysctl -p
设置iptables NAT转发

#注意这里eth0代表你的外网网卡，请用ifconfig查看或者咨询网络管理员
sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE
#如果上面的命令报错,那么可以尝试以下的命令，其中xxx.xxx.xxx.xxx代表你的VPS外网ip地址
sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j SNAT --to-source xxx.xxx.xxx.xxx
设置MTU来确保过大的包不会被丢弃（这个可以不做）


sudo iptables -I FORWARD -s 192.168.0.0/24 -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1300
iptables的设置重启之后会取消，所以可以将上面的命令加入到/etc/rc.local来确保每次重启都会执行设置。

G.至此设置全部完成，可以用任意一个客户端机器如MAC、PC或者手机来新建一个VPN连接使用用户test，密码1234进行测试。另外网上提供一种自动安装脚本，可以参见如下操作：


wget -c http://small-script.googlecode.com/files/debian-pptpd.tar.gz
tar -zxf debian-pptpd.tar.gz
sudo sh pptpd.sh
最后，如果想要实现更便利的用户管理，请参见在Ubuntu上安装FreeRADIUS服务。

*** torrent                                                       :torrent:
**** overview

***** [[https://zh.wikipedia.org/wiki/%E7%A7%8D%E5%AD%90%E6%96%87%E4%BB%B6][torrent]] :wikipedia:

[[/wiki/BitTorrent%E5%8D%8F%E8%AE%AE][BitTorrent协议]]的 *种子文件* （[[/wiki/%E8%8B%B1%E8%AF%AD][英语]]：Torrent file）可以保存一组[[/wiki/%E6%96%87%E4%BB%B6][文件]]的元
数据。这种格式的文件被BitTorrent协议所定义。[[/wiki/%E6%89%A9%E5%B1%95%E5%90%8D][扩展名]]一般为“.torrent”。

****** 结构

.torrent种子文件本质上是[[/wiki/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6][文本文件]]，包含Tracker信息和文件信息两部分。
Tracker信息主要是BT下载中需要用到的Tracker服务器的地址和针对Tracker服
务器的设置，文件信息是根据对目标文件的计算生成的，计算结果根据
BitTorrent协议内的[[/wiki/Bencode][Bencode]]规则进行编码。它的主要原理是需要把提供下载的
文件虚拟分成大小相等的块，块大小必须为2k的整数次方（由于是虚拟分块，硬
盘上并不产生各个块文件），并把每个块的索引信息和[[/wiki/Hash][Hash]]验证码写入种子文件
中；所以，种子文件就是被下载文件的“索引”。

种子文件包含以下数据：

-  =announce= - [[/wiki/Tracker][tracker]]的[[/wiki/URL][URL]]
-  =info= - 该条映射到一个字典，该字典的键将取决于共享的一个或多个文件：

   -  =name= - 建议保存到的文件和目录名称
   -  =piece length= -
      每个文件块的字节数。通常为 = 256KB = 262144B
   -  =pieces= -
      每个文件块的[[/wiki/SHA-1][SHA-1]]的整合Hash。因为SHA-1会返回160-bit的Hash，所以
     =pieces=将会得到1个160-bit的整数倍的字符串。和一个=length=（相当
     于只有一个文件正在共享）或=files=（相当于当多个文件被共享）：

   -  =length= - 文件的大小（以字节为单位）
   -  =files= - 一个字典的列表（每个字典对应一个文件）与以下的键：

      -  =path= - 一个对应子目录名的字符串列表，最后一项是实际的文件名称
      -  =length= - 文件的大小（以字节为单位）

****** 作用

根据[[/wiki/BitTorrent%E5%8D%8F%E8%AE%AE][BitTorrent协议]]，文件发布者会根据要发布的文件生成提供一个种子文件。
下载者要下载文件内容，需要先得到相应的种子文件，然后使用[[/wiki/BT%E5%AE%A2%E6%88%B7%E7%AB%AF][BT客户端]]软件进
行下载。

下载时，BT客户端首先解析种子文件得到[[/wiki/Tracker][Tracker]]地址，然后连接Tracker服务器。

下载者每得到一个块，需要算出下载块的Hash验证码与种子文件中的对比，如果
一样则说明块正确，不一样则需要重新下载这个块。这种规定是为了解决下载内
容准确性的问题。

为了解决某些用户“下完就跑”的现象，在非官方BitTorrent协议中还存在一种
[[/wiki/%E8%B6%85%E7%B4%9A%E7%A8%AE%E5%AD%90][超级种子]]的[[/wiki/%E7%AE%97%E6%B3%95][算法]]。

***** magnet wiki                                      :magnet:wikipedia:

*磁力連結* （Magnet URIscheme），是[[/wiki/%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C][对等网络]]中进行信息检索和下载文档的
[[/wiki/%E7%94%B5%E8%84%91%E7%A8%8B%E5%BA%8F][电脑程序]]。和基于“位置”连接的[[/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6][统一资源定位符]]（URL）不同，磁力连结是基于
[[/wiki/%E5%85%83%E6%95%B0%E6%8D%AE][元数据]]（metadata）文件内容，属于[[/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%90%8D%E7%A7%B0][统一资源名称]]（URN）。也就是说，磁力连
结不基于文档的[[/wiki/IP%E5%9C%B0%E5%9D%80][IP地址]]或定位符，而是在[[/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93][分布式数据库]]中，通过[[/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0][散列函数]]值来识
别、[[/wiki/%E6%90%9C%E7%B4%A2][搜索]]来下载文档。因为不依赖一个处于启动状态的主机来下载文档，所以特
别适用没有中心服务器的[[/wiki/%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C][对等网络]]。尽管它符合[[/w/index.php?title=%E5%BC%80%E6%BA%90%E6%A0%87%E5%87%86&action=edit&redlink=1][开源标准]]（[[/wiki/%E8%8B%B1%E8%AF%AD][英语]]：
[[//en.wikipedia.org/wiki/Open_standard][Openstandard]]），却被垄断信息资源和监控用户行为的个人、组织、企业和政府
拒之门外。

****** 历史

这个标准的草稿出现于2002年，是为了对[[/wiki/EDonkey2000][eDonkey2000]]的“[[/wiki/ED2k%E9%93%BE%E6%8E%A5][=ed2k:=]]”和[[/wiki/Freenet][Freenet]]
的“=freenet:=”两个[[/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6][URI]]格式进行“厂商与项目中立化”（vendor-and
project-neutral generalization）而制定的。同时这个标准也尝试紧密地跟进
[[/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B%E4%BB%BB%E5%8A%A1%E7%BB%84][IETF]]官方的URI标准。

****** 内容散列函数的应用

磁力連結最常见的用途是 *基于文件内容的散列函数值来链接到特定文件，生成
一个唯一的文件识别符，类似于[[/wiki/ISBN][ISBN]]。* 不像常规的识别符，内容散列可以被任
意一位持有此文件的人生成，所以并不需要一个中心机构，这使其在[[/wiki/%E6%AA%94%E6%A1%88%E5%88%86%E4%BA%AB][文件共享]]领
域经常被用作搜索条件，因任何人都可以分发一个磁力連結来确保该链接指向的
资源就是他想要的，而和得到该资源的方式无关。（虽然技术上讲，两个不同的
文件可能具有相同的散列值，但实际上这是极不可能发生的）

另一个磁力連結的优势是开放性和跨平台性：一个磁力連結可被运行在几乎所有
平台上的应用程序们使用以下载一个文件。因为磁力連結十分简洁且为纯文本格
式，所以用户可以很方便地将其复制到电子邮件或即时消息中，比如[[/wiki/%E7%A7%8D%E5%AD%90%E6%96%87%E4%BB%B6][种子文件]]。

******* 技术描述

磁力連結由一组参数组成，参数间的顺序没有讲究，其格式与在HTTP链接末尾的查询字符串相同。最常见的参数是"xt"，是"exact
topic"的缩写，通常是一个特定文件的内容散列函数值形成的[[/w/index.php?title=Uniform_Resource_Name&action=edit&redlink=1][URN]]，例如：


=magnet:?xt=urn:sha1:YNCKHTQCWBTRNJIV4WNAE52SJUQCZO5C=

其值是[[/w/index.php?title=Base32&action=edit&redlink=1][Base32]]编码的文件的[[/wiki/SHA-1][SHA-1]]散列。

注意，虽然这个链接指向一个特定文件，但是客户端应用程序仍然必须进行搜索来确定哪里，如果有，能够获取那个文件。

在标准的草稿中其他参数的定义如下:

-  "dn" ("显示名称"）:为了方便，为用户显示文件名称

-  "kt" ("关键字"):更笼统的搜索，指定搜索关键字而不是特定文件

-  "mt" ("文件列表"):一个URI指向一个列表，例如一个项目列表

-  应用程序定义的实验参数，必须以"x."开头

标准还建议同类的多个参数可以在参数名称后面加上".1", ".2"等来使用，例如

=magnet:?xt.1=urn:sha1:YNCKHTQCWBTRNJIV4WNAE52SJUQCZO5C&xt.2=urn:sha1:TXGCZQTH26NL6OUQAJJPFALHG2LTGBC7=

****** 描述

磁力連結可以包括一个或多个参数，之间用'&'隔开。参数的顺序在文件在标准
中没有记录。有一些参数的值对于客户端正确[[/wiki/%E8%A7%A3%E6%9E%90][解析]]磁力連結很重要。

#+BEGIN_EXAMPLE
       magnet:? xl = [字节大小]& dn = [文件名（已编码URL）]& xt = urn: tree: tiger: [ TTH hash（Base32）]
#+END_EXAMPLE

******* 参数

-  dn（显示名称）- 文件名
-  xl（绝对长度）- 文件字节数
-  xt（eXact Topic）- 包含文件散列函数值的[[/wiki/URN][URN]]
-  as（可接受来源） - 在线文件的网络链接
-  xs（绝对资源）- [[/wiki/P2P][P2P]]链接
-  kt（关键字）- 用于搜索的关键字
-  mt（文件列表）- 链接到一个包含磁力連結的元文件 (MAGMA -
   [[http://rakjar.de/gnuticles/MAGMA-Specsv22.txt][MAGnet MAnifest]]）
-  tr（Tracker地址）- BT下载的Tracker URL

****** 示例

*链接到一个0字节长度的文件。*

#+BEGIN_EXAMPLE
    magnet:?xt=urn:ed2k:31D6CFE0D16AE931B73C59D7E0C089C0
    &xl=0&dn=zero_len.fil
    &xt=urn:bitprint:3I42H3S6NNFQ2MSVX7XZKYAYSCX5QBYJ
    .LWPNACQDBZRYXW3VHJVCJ64QBZNGHOHHHZWCLNQ
    &xt=urn:md5:D41D8CD98F00B204E9800998ECF8427E
#+END_EXAMPLE

*mediawiki-1.15.1.tar.gz*

#+BEGIN_EXAMPLE
    magnet:?xt=urn:ed2k:354B15E68FB8F36D7CD88FF94116CDC1
    &xl=10826029&dn=mediawiki-1.15.1.tar.gz
    &xt=urn:tree:tiger:7N5OAMRNGMSSEUE3ORHOKWN4WWIQ5X4EBOOTLJY
    &xt=urn:btih:QHQXPYWMACKDWKP47RRVIV7VOURXFE5Q
    &tr=http%3A%2F%2Ftracker.example.org%2Fannounce.php%3Fuk%3D1111111111%26
    &as=http%3A%2F%2Fdownload.wikimedia.org%2Fmediawiki%2F1.15%2Fmediawiki-1.15.1.tar.gz
    &xs=http%3A%2F%2Fcache.example.org%2FXRX2PEFXOOEJFRVUCX6HMZMKS5TWG4K5
    &xs=dchub://example.org
#+END_EXAMPLE

*url magnet*

#+BEGIN_EXAMPLE
    http://sure-raza.com/magnet:?xl=10826029&
    dn=mediawiki-1.15.1.tar.gz&
    xt=urn:tree:tiger:7N5OAMRNGMSSEUE3ORHOKWN4WWIQ5X4EBOOTLJY
#+END_EXAMPLE

****** 客户端

[[/wiki/%CE%9CTorrent][μ Torrent]]
[[/wiki/BitComet][B itComet]]
[[/wiki/BitSpirit][B itSpirit]]
[[/wiki/%E8%BF%85%E9%9B%B7][迅 雷]]
[[/wiki/Transmission][T ransmission]]
[[/wiki/QBittorrent][q Bittorrent]]
[[/w/index.php?title=NeoLoader&action=edit&redlink=1][N eoLoader]]

此外，支持磁力連結的应用程序还包括[[/wiki/Vuze][Vuze]]、[[/w/index.php?title=BearShare&action=edit&redlink=1][BearShare]]、[[/wiki/DC%2B%2B][DC++]]、[[/wiki/Deluge][Deluge]]、
[[/w/index.php?title=Gtk-gnutella&action=edit&redlink=1][gtk-gnutella]]、[[/w/index.php?title=Kazaa&action=edit&redlink=1][Kazaa]]、[[/wiki/LimeWire][LimeWire]]、[[/wiki/FrostWire][FrostWire]]、[[/w/index.php?title=MP3_Rocket&action=edit&redlink=1][MP3Rocket]]、[[/w/index.php?title=Morpheus_(%E7%94%B5%E8%84%91%E7%A8%8B%E5%BA%8F)&action=edit&redlink=1][Morpheus]]、
[[/wiki/Shareaza][Shareaza]]、[[/wiki/MLdonkey][MLdonkey]]、[[/wiki/AMule][aMule]]、[[/w/index.php?title=KCeasy&action=edit&redlink=1][KCeasy]]和[[/w/index.php?title=TrustyFiles&action=edit&redlink=1][TrustyFiles]]。








***** [[https://alinuxblog.wordpress.com/2010/09/14/top-10-torrent-clients-for-linux/][Top 10 torrent clients for linux]]

****** 1) [[http://deluge-torrent.org/][Deluge]]

#+DOWNLOADED: https://alinuxblog.files.wordpress.com/2010/09/deluge.png @ 2016-01-28 20:51:08
 [[~/Wally/Journal/Figure/.org-download/Top 10 torrent clients for linux/deluge_2016-01-28_20:51:08.png]]

Deluge is a full-featured BitTorrent client written in python, for
Linux, OS X, Unix and Windows. It uses libtorrent in it's backend and
features multiple user-interfaces including: GTK+, web and console. It
has been designed using the client server model with a daemon process
that handles all the bittorrent activity. The Deluge daemon is able to
run on headless machines with the user-interfaces being able to connect
remotely from any platform.

[[[http://deluge-torrent.org/][Homepage]]]
[[[http://dev.deluge-torrent.org/wiki/Download][Download]]]

- *Written in:* Python & C++
- *Library:* libtorrent (Rasterbar version)
- *Last release:* 1.3.0 2010/09/13
- *Interface:* GUI (GTK), Web, CLI, Daemon
- *Encryption:* Yes
- *Mainline DHT:* Yes
- *Magnet link:* Yes
- *Peer Exchange:* Yes
- *UPnP:* Yes
- *NAT:* Yes

- *Local Peer Discovery:* Yes
- *IPv6 support:* Yes
- *Super Seeding:* No
- *Selective downloads:* Yes
- *Search engine:* Yes
- *RSS:* Yes (via plugin)
- *Remote control:* Yes
- *Prioritization:* Yes
- *Proxy:* Yes

****** 2) [[http://ktorrent.org/][KTorrent]]

#+DOWNLOADED: https://alinuxblog.files.wordpress.com/2010/09/ktorrent.png @ 2016-01-28 20:51:57
 [[~/Wally/Journal/Figure/.org-download/Top 10 torrent clients for linux/ktorrent_2016-01-28_20:51:57.png]]
KTorrent is a BitTorrent client written in C++ for KDE using the Qt user
interface toolkit. It can be considered the most powerful BitTorrent
client for KDE. It is the alternative of Deluge for KDE.

[[[http://ktorrent.org/][Homepage]]]
[[[http://ktorrent.org/?q=downloads][Download]]]

- *Written in:* C++
- *Library:* libktorrent
- *Last release:* 4.0.3 2010/08/30
- *Interface:* GUI(Qt),Web,CLI (poor)
- *Encryption:* Yes
- *Mainline DHT:* Yes
- *Magnet link:* Yes
- *Peer Exchange:* Yes
- *UPnP:* Yes
- *NAT:* Yes

- *Local Peer Discovery:* Poor
- *IPv6 support:* Yes
- *Super Seeding:* No
- *Selective downloads:* Yes
- *Search engine:* Yes
- *RSS:* Yes
- *Remote control:* Yes
- *Prioritization:* Yes
- *Proxy:* Yes

****** 3)[[http://www.transmissionbt.com/][Transmission]]

#+DOWNLOADED: https://alinuxblog.files.wordpress.com/2010/09/transmission.png @ 2016-01-28 20:52:23
 [[~/Wally/Journal/Figure/.org-download/Top 10 torrent clients for linux/transmission_2016-01-28_20:52:23.png]]

Transmission is designed to for easy, powerful use. It Just Work and it
only takes a few clicks to configure advanced features like watch
directories, bad peer blocklists, and the web interface. Transmission
has the lowest memory footprint of any major BitTorrent client.

Transmission is also available as a daemon , which is ideal for server
installations without X, nas, etc. It can be controlled by web or
terminal client.

[[[http://www.transmissionbt.com/][Homepage]]]
[[[http://www.transmissionbt.com/download.php][Download]]]

- *Written in:* C++
- *Library:* ---
- *Last release:* 2.04 2010/08/06
- *Interface:* GUI (GTK,Qt,Mac),CLI,Web
- *Encryption:* Yes
- *Mainline DHT:* Yes
- *Magnet link:* Yes
- *Peer Exchange:* Yes
- *UPnP:* Yes
- *NAT:* Yes

- *Local Peer Discovery:* Yes
- *IPv6 support:* Yes
- *Super Seeding:* No
- *Selective downloads:* Yes
- *Search engine:* No
- *RSS:* No
- *Remote control:* Yes
- *Prioritization:* Yes
- *Proxy:* Yes

****** 4) [[http://www.vuze.com/][Vuze (formerly Azureus)]]

#+DOWNLOADED: https://alinuxblog.files.wordpress.com/2010/09/vuze.jpg @ 2016-01-28 20:52:49
 [[~/Wally/Journal/Figure/.org-download/Top 10 torrent clients for linux/vuze_2016-01-28_20:52:49.jpg]]

From Vuze homepage: “the most powerful bittorrent app on earth” . The
true it's that Vuze (formerly Azureus) can be declared as the most
future rich torrent client for Linux. You can search, browse, download,
share torrents and playback HD files. All this with a cost: being a
Java based app, it is a system resource hogger.

[[[http://www.vuze.com/][Homepage]]]
[[[http://hwcdn01.vuze.com/files/Vuze_Installer.tar.bz2][Download]]]

- *Written in: Java*
- *Based on: ---*
- *Last release:* 4.5 2010/08/05
- *Interface:* GUI(Java), CLI(poor), web
- *Encryption:* Yes
- *Mainline DHT:* Yes
- *Magnet link:* Yes
- *Peer Exchange:* Yes
- *UPnP:* Yes
- *NAT:* Yes

- *Local Peer Discovery:* No
- *IPv6 support:* Yes
- *Super Seeding:* Yes
- *Selective downloads:* Yes
- *Search engine:* Yes (best)
- *RSS:* Yes
- *Remote control:* Yes (via plugin)
- *Prioritization:* Yes
- *Proxy:* Yes

****** 5) [[http://qbittorrent.sourceforge.net/][QBitTorrent]]

#+DOWNLOADED: https://alinuxblog.files.wordpress.com/2010/09/qbittortent.jpg @ 2016-01-28 20:53:09
 [[~/Wally/Journal/Figure/.org-download/Top 10 torrent clients for linux/qbittortent_2016-01-28_20:53:09.jpg]]

The qBittorrent project aims to provide a Free Software alternative to
µtorrent.

/UPDATE: My favorite client now. I warmly recommend it./

[[[http://qbittorrent.sourceforge.net/][Homepage]]]
[[[http://qbittorrent.sourceforge.net/download.php][Download]]]

- *Written in: C++*
- *Based on:* libtorrent (Rasterbar)
- *Last release:* 2.4.0 2010/08/24
- *Interface:* GUI(Qt), CLI(poor), Web
- *Encryption:* Yes
- *Mainline DHT:* Yes
- *Magnet link:* Yes
- *Peer Exchange:* Yes
- *UPnP:* Yes
- *NAT:* Yes

- *Local Peer Discovery:* Yes
- *IPv6 support:* Yes
- *Super Seeding:* Yes
- *Selective downloads:* Yes
- *Search engine:* Yes
- *RSS:* Yes
- *Remote control:* Yes
- *Prioritization:* Yes
- *Proxy:* No

****** 6) [[http://bbom.sourceforge.net/][BitStormLite]]

#+DOWNLOADED: https://alinuxblog.files.wordpress.com/2010/09/bitstormlite.jpg @ 2016-01-28 20:53:33
 [[~/Wally/Journal/Figure/.org-download/Top 10 torrent clients for linux/bitstormlite_2016-01-28_20:53:33.jpg]]

BitStormLite is a BitTorrent Client based on c++/gtk+2.0. It is an
alternative to the classical bittorrent client for GNOME. The
difference is that it permits to make selective downloads .

[[http://www.associatedcontent.com/article/739341/bitstorm_lite_a_free_lightweight_bittorrent.html?cat=15][Erichas a very nice article]] about why should someone use this client.

[[[http://bbom.sourceforge.net/][Homepage]]]
[[[http://sourceforge.net/projects/bbom/files/][Download]]]

- *Written in:* C++
- *Library:* ---
- *Last release:* 0.2q 2010/01/17
- *Interface:* GUI(GTK)
- *Encryption:* No
- *Mainline DHT:* No
- *Magnet link:* No
- *Peer Exchange:* No
- *UPnP:* No
- *NAT:* No

- *Local Peer Discovery:* No
- *IPv6 support:* No
- *Super Seeding:* No
- *Selective downloads:* Yes
- *Search engine:* Of course not
- *RSS:* No
- *Remote control:* No
- *Prioritization:* No
- *Proxy:* No

****** 7) [[http://libtorrent.rakshasa.no/][rtorrent]]

#+DOWNLOADED: https://alinuxblog.files.wordpress.com/2010/09/rtorrent.png @ 2016-01-28 20:54:13
 [[~/Wally/Journal/Figure/.org-download/Top 10 torrent clients for linux/rtorrent_2016-01-28_20:54:13.png]]

rTorrent is a text-based ncurses BitTorrent client libTorrentlibrary
written in C++ for *nix, with a focus on high performance and good code.
The library differentiates itself from other implementations by
transfering directly from file pages to the network stack. On
high-bandwidth connections it is able to seed at 3 times the speed of
the official client.

It comes with every feature most of the clients have but, unlike those,
it has very low resource requirements. It's probably the best torrent
client for Linux.   [[[http://libtorrent.rakshasa.no/][Homepage]]]
[[[http://libtorrent.rakshasa.no/wiki/Download][Download]]]

For an excellent article about how to use rtorrent read
[[http://kmandla.wordpress.com/2007/05/02/howto-use-rtorrent-like-a-pro/][kmandla's
post]].

UPDATE: /If you are not comfortable with the command line, you could
use some of the GUI clients created for rtorrent (check/
[[http://code.google.com/p/ntorrent/][/ntoreent/]]/) or a web based
frontend (check/
[[http://filesharefreak.com/2009/08/11/a-comparison-of-three-rtorrent-seedbox-web-frontends/][/this
list/]] /for reference)./

- *Written in:* C++
- *Library:* libtorrent(Rakshasa)
- *Last release:* 0.8 2009/11/30
- *Interface:* CLI
- *Encryption:* Yes
- *Mainline DHT:* Yes
- *Magnet link:* Yes
- *Peer Exchange:* Yes
- *UPnP:* No
- *NAT:* No

- *Local Peer Discovery:* No
- *IPv6 support:* No
- *Super Seeding:* Yes
- *Selective downloads:* Yes
- *Search engine:* No
- *RSS:* Yes (third party)
- *Remote control:* Yes
- *Prioritization:* Yes
- *Proxy:* No

****** 8 ) [[http://www.rahul.net/dholmes/ctorrent/#info][ctorrent]]

CTorrent is a BitTorrent client implemented in C++ to be lightweight and
quick.   [[[http://www.rahul.net/dholmes/ctorrent/][Homepage]]]
[[[http://www.rahul.net/dholmes/ctorrent/#download][Download]]]

-  *Written in:* C++
-  *Library: ---*
-  *Last release:* 3.3.2 2008/06/15
-  *Interface:* CLI
-  *Encryption:* Yes
-  *Mainline DHT:* ?
-  *Magnet link:*Yes
-  *Peer Exchange:* ?
-  *UPnP:*No
-  *NAT:* No
-  *Local Peer Discovery:*No
-  *IPv6 support:*No
-  *Super Seeding:* No
-  *Selective downloads:* Yes
-  *RSS:*No
-  *Remote control:* ?
-  *Prioritization:* ?
-  *Proxy:* No

****** 9) [[http://aria2.sourceforge.net/][aria2]]

#+DOWNLOADED: https://alinuxblog.files.wordpress.com/2010/09/aria.png @ 2016-01-28 20:54:42
 [[~/Wally/Journal/Figure/.org-download/Top 10 torrent clients for linux/aria_2016-01-28_20:54:42.png]]

aria2 is a lightweight multi-protocol & multi-source, cross platform
download utility operated in command-line. It supports HTTP/HTTPS, FTP,
BitTorrent and Metalink.  aria2 has two distinctive features: (1) aria2
can download a file from several URIs(HTTP(S)/FTP/BitTorrent) and (2) If
you give aria2 a list of URIs, aria2 downloads them concurrently. You
don't have to wait for the current download queue to finish one file at
a time anymore. aria2 tries to utilize your maximum download bandwidth
and downloads files quickly.

[[[http://aria2.sourceforge.net/][Homepage]]]
[[[http://sourceforge.net/projects/aria2/files/stable/aria2-1.10.2][Download]]]

| -  *Written in:* C++                   |
| -  *library:* ---                      |
| -  *Last release:* 1.10.2 2010/08/31   |
| -  *Interface:* CLI, Web               |
| -  *Encryption:* Yes                   |
| -  *Mainline DHT:* Yes                 |
| -  *Magnet link:* Yes                  |
| -  *Peer Exchange:* Yes                |
| -  *UPnP:* No                          |
| -  *NAT:* No                           |
|                                        |
| -  *Local Peer Discovery:* Yes         |
| -  *IPv6 support:* Yes (poor)          |
| -  *Super Seeding:* No                 |
| -  *Selective downloads:* Yes          |
| -  *RSS:* No                           |
| -  *Remote control:*Yes                |
| -  *Prioritization:* No                |
| -  *Proxy:* No                         |

****** 10) [[http://www.torrentflux.com/][torrentflux]]

#+DOWNLOADED: https://alinuxblog.files.wordpress.com/2010/09/torrentflux.png @ 2016-01-28 20:54:55
 [[~/Wally/Journal/Figure/.org-download/Top 10 torrent clients for linux/torrentflux_2016-01-28_20:54:55.png]]

TorrentFlux is a web-based system for managing bit torrent file
transfers. It is an open source package (GPL) and developed for Linux,
Unix & BSD platforms on the ubiquitous LAMP stack.

[[[http://www.torrentflux.com/][Homepage]]]
[[[http://www.torrentflux.com/download.php][Download]]]

- *Written in: C++*
- *Library: BitTornado*
- *Last release: 2.4 2008/06/18*
- *Interface: Web*
- *Encryption: Yes*
- *Mainline DHT: No*
- *Magnet link: No*
- *Peer Exchange: No*
- *UPnP: Yes*
- *NAT: No*

- *Local Peer Discovery: No*
- *IPv6 support: No*
- *Super Seeding: Yes*
- *Selective downloads: Yes*
- *Search engine: Yes*
- *RSS: Yes*
- *Remote control: Yes*
- *Prioritization: Yes*
- *Proxy: No*


*And a little bonus:*

****** 11) [[http://oneswarm.cs.washington.edu/][OneSwarm]]

#+DOWNLOADED: https://alinuxblog.files.wordpress.com/2010/09/oneswarm.jpg @ 2016-01-28 20:55:27
 [[~/Wally/Journal/Figure/.org-download/Top 10 torrent clients for linux/oneswarm_2016-01-28_20:55:27.jpg]]

OneSwarm is a new peer-to-peer tool that provides users with explicit
control over their privacy by letting them determine how data is shared.
Instead of sharing data indiscriminately, data shared with OneSwarm can
be made public, it can be shared with friends, shared with some friends
but not others, and so forth. We call this friend-to-friend (F2F) data
sharing.

[[[http://oneswarm.cs.washington.edu/][Homepage]]]
[[[http://oneswarm.cs.washington.edu/download.html][Download]]]

- *Written in:* Java
- *Library:* Azureus
- *Last release:* 10.4 2010/08/17
- *Interface:* GUI(Java),Web
- *Encryption:*Yes
- *Mainline DHT:*Yes
- *Magnet link:*Yes
- *Peer Exchange:* Yes
- *UPnP:* Yes
- *NAT:* Yes

- *Local Peer Discovery:* No
- *IPv6 support:* Yes
- *Super Seeding:* Yes
- *Selective downloads:* Yes
- *Search engine:* No
- *RSS:* No
- *Remote control:* No
- *Prioritization:* Yes
- *Proxy:* No

I'm using /rtorrent/ and sometimes, /Transmission/. What client do you
use? Feel free to comment...

**** [[https://wiki.archlinux.org/index.php/RTorrent#Saving_magnet_links_as_torrent_files_in_watch_folder][rTorrent]] :rtorrent:torrent:magnet:
# From ArchWiki
***** reference

- [[https://github.com/rakshasa/rtorrent][GitHub]]
- [[https://github.com/rakshasa/rtorrent/wiki/User-Guide][User Guide]]

***** Installation

[[/index.php/Install][Install]] the [[https://www.archlinux.org/packages/?name=rtorrent][rtorrent]] package that is available in the [[/index.php/Official_repositories][official repositories]].

Alternatively, install [[https://aur.archlinux.org/packages/rtorrent-git/][rtorrent-git]]^{AUR}

***** Configuration

*Note:* See the rTorrent wiki article on this subject for more
information:
[[http://web.archive.org/web/20140213003955/http://libtorrent.rakshasa.no/wiki/RTorrentCommonTasks][Common Tasks in rTorrent for Dummies]].

Before running rTorrent, find the example configuration file
=/usr/share/doc/rtorrent/rtorrent.rc= and copy it to =~/.rtorrent.rc=:

#+BEGIN_EXAMPLE
    $ cp /usr/share/doc/rtorrent/rtorrent.rc ~/.rtorrent.rc
#+END_EXAMPLE

****** Performance

*Note:* See the rTorrent wiki article on this subject for more
information:
[[http://web.archive.org/web/20140213011439/http://libtorrent.rakshasa.no/wiki/RTorrentPerformanceTuning][Performance Tuning]]

The values for the following options are dependent on the system's
hardware and Internet connection speed. To find the optimal values read:
[[http://torrentfreak.com/optimize-your-BitTorrent-download-speed][Optimize Your BitTorrent Download Speed]]

#+BEGIN_EXAMPLE
  min_peers = 40
  max_peers = 52

  min_peers_seed = 10
  max_peers_seed = 52

  max_uploads = 8

  download_rate = 200
  upload_rate = 28
#+END_EXAMPLE

The =check_hash= option executes a hash check when a torrent download is
complete or rTorrent is started. When starting, it checks for errors in
your completed files.

#+BEGIN_EXAMPLE
    check_hash = yes
#+END_EXAMPLE

****** Create and manage files

The =directory= option will determine where your torrent data will be
saved (could be a relative path):

#+BEGIN_EXAMPLE
    directory = ~/downloaded
#+END_EXAMPLE

The =session= option allows rTorrent to save the progess of your
torrents. It is recommended to create a directory in home directory
(e.g. =mkdir ~/.rtorrent.session=).

#+BEGIN_EXAMPLE
    session = ~/.rtorrent.session
#+END_EXAMPLE

The =schedule= option has rTorrent watch a particular directory for new
torrent files. Saving a torrent file to this directory will
automatically start the download. Remember to create the directory that
will be watched (e.g. =mkdir ~/watch=). Also, be careful when using this
option as rTorrent will move the torrent file to your session folder and
rename it to its hash value.

#+BEGIN_EXAMPLE
    schedule = watch_directory,5,5,load_start=/home/user/watch/*.torrent
    schedule = untied_directory,5,5,stop_untied=
    schedule = tied_directory,5,5,start_tied=
#+END_EXAMPLE

The following =schedule= option is intended to stop rTorrent from
downloading data when disk space is low.

#+BEGIN_EXAMPLE
    schedule = low_diskspace,5,60,close_low_diskspace=100M
#+END_EXAMPLE

****** Port configuration

The =port_range= option sets which port(s) to use for listening. It is
recommended to use a port that is higher than 49152 (see:
[[https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers][List of port numbers]]). Although, rTorrent allows a range of ports, a single
port is recommended.

#+BEGIN_EXAMPLE
    port_range = 49164-49164
#+END_EXAMPLE

Additionally, make sure port forwarding is enabled for the proper
port(s) (see:
[[http://portforward.com/english/routers/port_forwarding/routerindex.htm][PortForward guides]]).

****** Additional settings

The =encryption= option enables or disables encryption. It is very
important to enable this option, not only for yourself, but also for
your peers in the torrent swarm. Some users need to obscure their
bandwidth usage from their ISP. And it does not hurt to enable it even
if you do not need the added security.

#+BEGIN_EXAMPLE
    encryption = allow_incoming,try_outgoing,enable_retry
#+END_EXAMPLE

It is also possible to force all connections to use encryption. However,
be aware that this stricter rule will reduce your client's availability:

#+BEGIN_EXAMPLE
    encryption = require,require_RC4,allow_incoming,try_outgoing
#+END_EXAMPLE

See also
[[https://en.wikipedia.org/wiki/BitTorrent_Protocol_Encryption][Wikipedia:BitTorrent Protocol Encryption]].

This final =dht= option enables
[[https://en.wikipedia.org/wiki/Distributed_hash_table][DHT]] support.
DHT is common among public trackers and will allow the client to acquire
more peers.

#+BEGIN_EXAMPLE
    dht = auto
    dht_port = 6881
    peer_exchange = yes
#+END_EXAMPLE

***** Key bindings

rTorrent relies exclusively on keyboard shortcuts for user input. A
quick reference is available in the table below. A complete guide is
available on the rTorrent wiki (see:
[[https://github.com/rakshasa/rtorrent/wiki/User-Guide][rTorrent User Guide]]).

*Note:* Striking =Ctrl-q= twice in quick succession will make rTorrent
shutdown without waiting to send a stop announce to the connected
trackers.


| Ctrl-q           | Quit application                                                             |
| Ctrl-s           | Start download. Runs hash first unless already done.                         |
| Ctrl-d           | Stop an active download or remove a stopped download                         |
| Ctrl-k           | Stop and close the files of an active download.                              |
| Ctrl-r           | Initiate hash check of torrent. Starts downloading if file is not available. |
| Left             | Returns to the previous screen                                               |
| Right            | Goes to the next screen                                                      |
| Backspace/Return | Adds the specified *.torrent                                                 |
| a                | Increase global upload throttle about 1                                      |
| s                | 5                                                                            |
| d                | 50 KB/s                                                                      |
| A                | Increase global download throttle about 1                                    |
| S                | 5                                                                            |
| D                | 50 KB/s                                                                      |
| z                | Decrease global upload throttle about 1                                      |
| x                | 5                                                                            |
| c                | 50 KB/s                                                                      |
| Z                | Decrease global download throttle about 1                                    |
| X                | 5                                                                            |
| C                | 50 KB/s                                                                      |

****** Redundant mapping

=Ctrl-s= is often used for terminal control to stop screen output while
=Ctrl-q= is used to start it. These mappings may interfere with
rTorrent. Check to see if these terminal options are bound to a mapping:

#+BEGIN_EXAMPLE
    $ stty -a
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    ...
    swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V;
    ...
#+END_EXAMPLE

To remove the mappings, change the terminal characteristics to undefine
the aforementioned special characters (i.e. =stop= and =start=):

#+BEGIN_EXAMPLE
    # stty stop undef
    # stty start undef
#+END_EXAMPLE

To remove these mappings automatically at startup you may add the two
preceding commands to your =~/.bashrc= file.

***** Additional tips

****** systemd service file with tmux or screen

-  With tmux (Restart rtorrent if crashed)

#+BEGIN_EXAMPLE
    /etc/systemd/user/rt.service
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [Unit]
    Description=rTorrent
    After=network.target

    [Service]
    Type=forking
    KillMode=none
    ExecStart=/usr/bin/tmux new-session -s rt -n rtorrent -d rtorrent
    ExecStop=/usr/bin/bash -c "/usr/bin/tmux send-keys -t rt:rtorrent.0 C-q && while pidof rtorrent > /dev/null; do sleep 0.5; echo rtorrent still running...; done"
    WorkingDirectory=%h
    Restart=on-failure

    [Install]
    WantedBy=default.target
#+END_EXAMPLE

-  With tmux running as user rtorrent (Restart rtorrent if crashed)

#+BEGIN_EXAMPLE
    /etc/systemd/system/rtorrent.service
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [Unit]
    Description=rTorrent Daemon
    After=network.target

    [Service]
    Type=forking
    KillMode=none
    User=rtorrent
    ExecStart=/usr/bin/tmux new-session -c /mnt/storage/rtorrent -s rtorrent -n rtorrent -d rtorrent
    ExecStop=/usr/bin/tmux send-keys -t rtorrent C-q && /usr/bin/tmux kill-session -t rtorrent
    WorkingDirectory=/home/rtorrent/
    Restart=on-failure

    [Install]
    WantedBy=multi-user.target
#+END_EXAMPLE

-  With screen

#+BEGIN_EXAMPLE
    /etc/systemd/user/rt.service
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [Unit]
    Description=rTorrent
    After=network.target

    [Service]
    Type=forking
    KillMode=none
    ExecStart=/usr/bin/screen -d -m -fa -S rtorrent /usr/bin/rtorrent
    ExecStop=/usr/bin/killall -w -s 2 /usr/bin/rtorrent
    WorkingDirectory=%h

    [Install]
    WantedBy=default.target
#+END_EXAMPLE

Start at boot time:

#+BEGIN_EXAMPLE
    $ systemctl --user enable rt
#+END_EXAMPLE

Start manually:

#+BEGIN_EXAMPLE
    $ systemctl --user start rt
#+END_EXAMPLE

Stop:

#+BEGIN_EXAMPLE
    $ systemctl --user stop rt
#+END_EXAMPLE

Attach to rtorrent's session:

#+BEGIN_EXAMPLE
    tmux attach -t rt
#+END_EXAMPLE

Detach:

#+BEGIN_EXAMPLE
    Ctrl-b d
#+END_EXAMPLE

****** systemd service file with dtach

[[/index.php/File:Tango-mail-mark-junk.png][[[/images/e/e7/Tango-mail-mark-junk.png]]]]

[[/index.php/File:Tango-mail-mark-junk.png][[[/images/e/e7/Tango-mail-mark-junk.png]]]]

*This article or section needs language, wiki syntax or style
improvements.*

*Reason:* Creating multiple rtorrent sessions this way is far from
perfect, why don't we just assume for simplicity that there is only one
session? This is assumed in
[[#systemd_service_file_with_tmux_or_screen][#systemd service file with
tmux or screen]] anyway. (Discuss in
[[https://wiki.archlinux.org/index.php/Talk:RTorrent][Talk:RTorrent#]])

When running dtach from systemd unit, the =TERM= environment variable
[[/index.php/Systemd/User#Environment_variables][has to be set
explicitly]] for rtorrent to work.

This service file has no restart because the author occasionally takes
the drive in question offline, and rtorrent fails, shall we say,
"suboptimally" when started in this scenario and loses many torrent
specific settings such as the specific directories each torrent is
stored in. In fact the symlinks that kick off rtorrent live on the
relevant drive; if it is unmounted rtorrent cannot start. This use case
of blocking rtorrent from starting is relevant to users who put the
downloaded files on removable media such as NAS, USB or eSATA drives.

#+BEGIN_EXAMPLE
    ~/.config/systemd/user/rtorrent.service
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [Unit]
    Description=rTorrent
    #After=network.target

    [Service]
    # set TERM according to your terminal
    Environment="TERM=xterm"
    #Environment="TERM=linux"
    Type=forking
    KillMode=none
    ExecStart=-/usr/bin/dtach -n /home/sam/run/dtach_fifos/fifo -e "^T" /home/sam/bin/rtr_new -n -o import=/home/sam/.config/rtorrent/new_.rc
       # dtach -n <separate filename for each instance>
       #
       # rtr_new -n to ignore the default .rtorrent.rc
       # rtr_new -o import to load the instance-specific rc
    ExecStop=-/usr/bin/killall -u sam -e -w -s INT /home/sam/bin/rtr_new

    [Install]
    WantedBy=multi-user.target
#+END_EXAMPLE

Note some other issues exposed in this service file other than just
dtach:

=/home/sam/bin/rtr_new= is a symlink to =/usr/bin/rtorrent=

This lets us run several instances and kill each one independently with
a different version of the ExecStop, to wit:

#+BEGIN_EXAMPLE
    ExecStop=-/usr/bin/killall -u sam -e -w -s INT /home/sam/bin/rtr_new
    ExecStop=-/usr/bin/killall -u sam -e -w -s INT /home/sam/bin/rtr_academic
    ExecStop=-/usr/bin/killall -u sam -e -w -s INT /home/sam/bin/rtr_other_stuff
#+END_EXAMPLE

These are each in a different service file, each of which controls one
instance.

Without this step, when running multiple instances a killall solution
would kill all the running rtorrent instances.

If multiple rtorrent instances are not needed and the rtorrent rc file
is in the default location the above service file may be simplified. The
entire file is included but only the ExecStart and ExecStop lines
change.

#+BEGIN_EXAMPLE
    ~/.config/systemd/user/rtorrent.service
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    [Unit]
    Description=rTorrent
    #After=network.target

    [Service]
    # set TERM according to your terminal
    Environment="TERM=xterm"
    #Environment="TERM=linux"
    Type=forking
    KillMode=none
    ExecStart=-/usr/bin/dtach -n /home/sam/run/dtach_fifos/fifo -e "^T" /usr/bin/rtorrent
       # dtach -n <user specified FIFO name> -e <user specified character> /usr/bin/rtorrent
    ExecStop=/usr/bin/killall -w -s INT /usr/bin/rtorrent
       # -e (exact match) and -u (user name) were added above to stop specific processes
       #  and may be omitted here because only one rtorrent will be running

    [Install]
    WantedBy=multi-user.target
#+END_EXAMPLE

The service can be controlled with
[[/index.php/Systemctl_--user][systemctl --user]]. When it is started,
you can attach to the session:

#+BEGIN_EXAMPLE
    $ dtach -a  /home/sam/run/dtach_fifos/fifo -e "^T"
#+END_EXAMPLE

****** Pre-allocation

The rTorrent package in the community repository lacks pre-allocation.
Compiling rTorrent with pre-allocation allows files to be allocated
before downloading the torrent. The major benefit is that it limits and
avoids fragmentation of the filesystem. However, this introduces a delay
during the pre-allocation if the filesystem does not support the
fallocate syscall natively.

Therefore this switch is recommended for xfs, ext4 and btrfs
filesystems, which have native fallocate syscall support. They will see
no delay during preallocation and no fragmented filesystem.
Pre-allocation on others filesystems will cause a delay but will not
fragment the files.

To make pre-allocation available, recompile libTorrent from the
[[/index.php/ABS][ABS]] tree with the following new switch:

#+BEGIN_EXAMPLE
     $ ./configure --prefix=/usr --disable-debug --with-posix-fallocate
#+END_EXAMPLE

To enable it, add the following to your =~/rtorrent.rc=:

#+BEGIN_EXAMPLE
    ~/rtorrent.rc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
      # Preallocate files; reduces defragmentation on filesystems.
      system.file_allocate.set = yes
#+END_EXAMPLE

****** Manage completed files

*Note:*

-  Currently, this part requires either the git version of
   rtorrent/libtorrent or having applied the patch to 0.8.6 that adds
   'equal'.
-  If you are having trouble with this tip, it is probably easier to
   follow
   [[http://web.archive.org/web/20140213003955/http://libtorrent.rakshasa.no/wiki/RTorrentCommonTasks#Movecompletedtorrentstodifferentdirectorydependingonwatchdirectory][this]].

It is possible to have rtorrent sort completed torrent data to specific
folders based on which 'watch' folder you drop the *.torrent into while
continuing to seed. Many examples show how to do this with torrents
downloaded by rtorrent. The problem is when you try to drop in 100% done
torrent data and then have rtorrent check the data and resume, it will
not be sorted.

As a solution, use the following example in your =~/.rtorrent.rc=. Make
sure to change the paths.

#+BEGIN_EXAMPLE
    # location where new torrent data is placed, and where you should place your
    # 'complete' data before you place your *.torrent file into the watch folder
    directory = /home/user/torrents/incomplete

    # schedule a timer event named 'watch_directory_1':
    # 1) triggers 10 seconds after rtorrent starts
    # 2) triggers at 10 second intervals thereafter
    # 3) Upon trigger, attempt to load (and start) new *.torrent files found in /home/user/torrents/watch/
    # 4) set a variable named 'custom1' with the value "/home/user/torrents/complete"
    # NOTE: if you do not want it to automatically start the torrent, change 'load_start' to 'load'
    schedule = watch_directory_1,10,10,"load_start=/home/user/torrents/watch/*.torrent,d.set_custom1=/home/user/torrents/complete"

    # insert a method with the alias 'checkdirs1'
    # 1) returns true if the current path of the torrent data is not equal to the value of custom1
    # 2) otherwise, returns false
    system.method.insert=checkdirs1,simple,"not=\"$equal={d.get_custom1=,d.get_base_path=}\""

    # insert a method with the alias 'movecheck1'
    # 1) returns true if all 3 commands return true ('result of checkdirs1' && 'torrent is 100% done', 'custom1 variable is set')
    # 2) otherwise, returns false
    system.method.insert=movecheck1,simple,"and={checkdirs1=,d.get_complete=,d.get_custom1=}"

    # insert a method with the alias 'movedir1'
    # (a series of commands, separated by ';')
    # 1) "set path of torrent to equal the value of custom1";
    # 2) "mv -u <current data path> <custom1 path>";
    # 3) "clear custom1", "stop the torrent","resume the torrent"
    # 4) stop the torrent
    # 5) start the torrent (to get the torrent to update the 'base path')
    system.method.insert=movedir1,simple,"d.set_directory=$d.get_custom1=;execute=mv,-u,$d.get_base_path=,$d.get_custom1=;d.set_custom1=;d.stop=;d.start="

    # set a key with the name 'move_hashed1' that is triggered by the hash_done event.
    # 1) When hashing of a torrent completes, this custom key will be triggered.
    # 2) when triggered, execute the 'movecheck1' method and check the return value.
    # 3) if the 'movecheck' method returns 'true', execute the 'movedir1' method we inserted above.
    # NOTE-0: *Only* data that has had their hash checked manually with ^R [^R = Control r].
    # Or on a rtorrent restart[which initiates a hash check]. Will the data move; ~/torrents/incomplete => ~/torrents/complete for example.
    # NOTE-1: 'branch' is an 'if' conditional statement: if(movecheck1){movedir1}
    system.method.set_key=event.download.hash_done,move_hashed1,"branch={$movecheck1=,movedir1=}"
#+END_EXAMPLE

You can add additional watch folders and rules should you like to sort
your torrents into special folders.

For example, if you would like the torrents to download in:

#+BEGIN_EXAMPLE
    /home/user/torrents/incomplete
#+END_EXAMPLE

and then sort the torrent data based on which folder you dropped the
*.torrent into:

#+BEGIN_EXAMPLE
    /home/user/torrents/watch => /home/user/torrents/complete
    /home/user/torrents/watch/iso => /home/user/torrents/complete/iso
    /home/user/torrents/watch/music => /home/user/torrents/complete/music
#+END_EXAMPLE

You can have the following in your .rtorrent.rc:

#+BEGIN_EXAMPLE
    directory = /home/user/torrents/incomplete
    schedule = watch_directory_1,10,10,"load_start=/home/user/torrents/watch/*.torrent,d.set_custom1=/home/user/torrents/complete"

    schedule = watch_directory_2,10,10,"load_start=/home/user/torrents/watch/iso/*.torrent,d.set_custom1=/home/user/torrents/complete/iso"

    schedule = watch_directory_3,10,10,"load_start=/home/user/torrents/watch/music/*.torrent,d.set_custom1=/home/user/torrents/complete/music"

    system.method.insert=checkdirs1,simple,"not=\"$equal={d.get_custom1=,d.get_base_path=}\""
    system.method.insert=movecheck1,simple,"and={checkdirs1=,d.get_complete=,d.get_custom1=}"
    system.method.insert=movedir1,simple,"d.set_directory=$d.get_custom1=;execute=mv,-u,$d.get_base_path=,$d.get_custom1=;d.set_custom1=;d.stop=;d.start="
    system.method.set_key=event.download.hash_done,move_hashed1,"branch={$movecheck1=,movedir1=}"
#+END_EXAMPLE

Also see [[http://code.google.com/p/pyroscope/][pyroscope]] especially
the rtcontrol examples. There is an AUR package.

******* Notification with Google Mail

Cell phone providers allow you to "email" your phone:

#+BEGIN_EXAMPLE
    Verizon: 10digitphonenumber@vtext.com
    AT&T: 10digitphonenumber@txt.att.net
    Former AT&T customers: 10digitphonenumber@mmode.com
    Sprint: 10digitphonenumber@messaging.sprintpcs.com
    T-Mobile: 10digitphonenumber@tmomail.net
    Nextel: 10digitphonenumber@messaging.nextel.com
    Cingular: 10digitphonenumber@cingularme.com
    Virgin Mobile: 10digitphonenumber@vmobl.com
    Alltel: 10digitphonenumber@alltelmessage.com OR
    10digitphonenumber@message.alltel.com
    CellularOne: 10digitphonenumber@mobile.celloneusa.com
    Omnipoint: 10digitphonenumber@omnipointpcs.com
    Qwest: 10digitphonenumber@qwestmp.com
    Telus: 10digitphonenumber@msg.telus.com
    Rogers Wireless: 10digitphonenumber@pcs.rogers.com
    Fido: 10digitphonenumber@fido.ca
    Bell Mobility: 10digitphonenumber@txt.bell.ca
    Koodo Mobile: 10digitphonenumber@msg.koodomobile.com
    MTS: 10digitphonenumber@text.mtsmobility.com
    President's Choice: 10digitphonenumber@txt.bell.ca
    Sasktel: 10digitphonenumber@sms.sasktel.com
    Solo: 10digitphonenumber@txt.bell.ca
#+END_EXAMPLE

-  Install mailx which is provided by the
   [[https://www.archlinux.org/packages/?name=s-nail][s-nail]] package
   that is found in the [[/index.php/Official_repositories][official
   repositories]].

-  Clear the =/etc/mail.rc= file and enter:

#+BEGIN_EXAMPLE
    set sendmail="/usr/bin/mailx"
    set smtp=smtp.gmail.com:587
    set smtp-use-starttls
    set ssl-verify=ignore
    set ssl-auth=login
    set smtp-auth-user=USERNAME@gmail.com
    set smtp-auth-password=PASSWORD
#+END_EXAMPLE

Now to send the text, we must pipe a message to the mailx program.

-  Make a Bash script:

#+BEGIN_EXAMPLE
    /path/to/mail.sh
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    echo "$@: Done" | mailx 5551234567@vtext.com
#+END_EXAMPLE

Where the $@ is a variable holding all the arguments passed to our
script.

-  And finally, add the important =~/.rtorrent.rc= line:

#+BEGIN_EXAMPLE
    system.method.set_key = event.download.finished,notify_me,"execute=/path/to/mail.sh,$d.get_name="
#+END_EXAMPLE

Breaking it down:

=notify_me= is the command id, which may be used by other commands, it
can be just about anything you like, so long as it is unique.

=execute== is the rtorrent command, in this case to execute a shell
command.

=/path/to/mail.sh= is the name of our script (or whatever command you
want to execute) followed by a comma separated list of all the
switches/arguments to be passed.

=$d.get_name== 'd' is an alias to whatever download triggered the
command, get\_name is a function which returns the name of our download,
and the '$' tells rTorrent to replace the command with its output before
it calls execute.

The end result? When that torrent, 'All Live Nudibranches', that we
started before leaving for work finishes, we will be texted:

#+BEGIN_EXAMPLE
    All Live Nudibranches: Done
#+END_EXAMPLE

****** Displaying active torrents

The rtorrent does not list the active tab properly by default, add this
line to your =.rtorrent.rc= to show only active torrents

#+BEGIN_EXAMPLE
    schedule = filter_active,30,30,"view_filter = active,\"or={d.get_up_rate=,d.get_down_rate=}\""
#+END_EXAMPLE

Then press =9= in your rTorrent client to see the changes in action.

****** Manually adding trackers to torrents

1. Select torrent to edit from rTorrent console view.
2. Hit =Ctrl+x=.
3. If you had four trackers type following lines one at a time (always
   press =Ctrl+x= first) to add four more for example:

#+BEGIN_EXAMPLE
    d.tracker.insert="5","udp://tracker.publicbt.com:80"
    d.tracker.insert="6","udp://tracker.openbittorrent.com:80"
    d.tracker.insert="7","udp://tracker.istole.it:80"
    d.tracker.insert="8","udp://tracker.ccc.de:80"
#+END_EXAMPLE

***** Troubleshooting

****** CA certificates

To use rTorrent with a tracker that uses HTTPS, do the following as
root:

#+BEGIN_EXAMPLE
    # cd /etc/ssl/certs
    # wget --no-check-certificate https://www.geotrust.com/resources/root_certificates/certificates/Equifax_Secure_Global_eBusiness_CA-1.cer
    # mv Equifax_Secure_Global_eBusiness_CA-1.cer Equifax_Secure_Global_eBusiness_CA-1.pem
    # c_rehash
#+END_EXAMPLE

And from now on run rTorrent with:

#+BEGIN_EXAMPLE
    $ rtorrent -o http_capath=/etc/ssl/certs
#+END_EXAMPLE

If you use GNU Screen, update the =.screenrc= configuration file to
reflect this change:

#+BEGIN_EXAMPLE
    $ screen -t rtorrent rtorrent -o http_capath=/etc/ssl/certs
#+END_EXAMPLE

In rTorrent 0.8.9, set =network.http.ssl_verify_peer.set=0= to
[[https://bbs.archlinux.org/viewtopic.php?pid=981832#p981832][fix the
problem]].

For more information see:
[[https://bbs.archlinux.org/viewtopic.php?pid=331850][rTorrent Error &
CA Certificate]] and
[[https://bbs.archlinux.org/viewtopic.php?id=45800][rTorrent
Certificates Problem]]

****** Locked directories

rTorrent can sometimes lock up after a crash or incorrect shutdown, and
will complain about a lock file.

Per the error message, the file called "*rtorrent.lock*" can be found
within the hidden folder =.rtorrentsession= for your download directory
and manually removed.

****** Event failed: bad return code

This is caused by there being spaces in your system.method.* lines.
Remove the spaces and it will work.

***** Web interface

There are numerous web interfaces and front ends for rTorrent including:

-  [[/index.php/WTorrent][WTorrent]] is a web interface to rtorrent
   programmed in php using Smarty templates and XMLRPC for PHP library.
-  [[http://code.google.com/p/ntorrent/][nTorrent]] is a graphical user
   interface client to rtorrent (a cli torrent client) written in Java.
-  [[https://rtwi.jmk.hu/][rTWi]] is a simple rTorrent web interface
   written in PHP.
-  [[/index.php/Rtgui][Rtgui]] is a web based front end for rTorrent
   written in PHP and uses XML-RPC to communicate with the rTorrent
   client.
-  [[https://github.com/Novik/ruTorrent][rutorrent]] and
   [[http://forums.rutorrent.org/][Forum]] - A web-based front-end with
   an interface very similar to uTorrent which supports many plugins and
   advanced features (see also: [[/index.php/RuTorrent][ruTorrent]] and
   [[https://bbs.archlinux.org/viewtopic.php?pid=897577#p897577][Guide
   on forum]]).

*Note:* rTorrent is currently built using
[[http://xmlrpc-c.sourceforge.net/][XML-RPC for C/C++]], which is
required for some web interfaces (e.g. ruTorrent).

****** XMLRPC interface

If you want to use rtorrent with some web interfaces (e.g. rutorrent)
you need to add the following line to the configuration file:

#+BEGIN_EXAMPLE
    scgi_port = localhost:5000
#+END_EXAMPLE

For more information see:
[[https://github.com/rakshasa/rtorrent/wiki/RPC-Setup-XMLRPC][Using
XMLRPC with rtorrent]]

****** Saving magnet links as torrent files in watch folder

*Note:* Rtorrent natively supports downloading torrents through magnet
links. At the main view (reached by starting Rtorrent and pressing 1),
press enter. At "load.normal>" paste the magnet link and press enter
again. This will start the download.

If you wish to have magnet links automatically added to your watch
folder, here is a script that will do the trick:

#+BEGIN_EXAMPLE
     #!/bin/bash
     watch_folder=~/.rtorrent/watch
     cd $watch_folder
     [[ "$1" =~ xt=urn:btih:([^&/]+) ]] || exit;
     echo "d10:magnet-uri${#1}:${1}e" > "meta-${BASH_REMATCH[1]}.torrent"
#+END_EXAMPLE

(adapted from
[[http://blog.gonzih.org/blog/2012/02/17/how-to-use-magnet-links-with-rtorrent/]]).

Save it, for instance as rtorrent-magnet, give it execution permission,
and place it somewhere under your $PATH. Then in Firefox:

1. Type =about:config= into the Location Bar (address bar) and press
   =Enter=.
2. Right-click: /New > Boolean > Name:
   *network.protocol-handler.expose.magnet* > Value > false/.
3. Next time you click a magnet link you will be asked which application
   to open it with. Select the script we just created and you will be
   done.

If you want xdg-open to handle this, which you need if you are using
chrome instead of firefox, (though gnome and other DE might have their
own programs overriding xdg-open) you need to create the desktop entry
for the rtorrent-magnet script in
=~/.local/share/applications/rtorrent-magnet.desktop= with the following
content:

#+BEGIN_EXAMPLE
     [Desktop Entry]
     Type=Application
     Name=rtorrent-magnet
     Exec=rtorrent-magnet %U
     MimeType=x-scheme-handler/magnet;
     NoDisplay=true
#+END_EXAMPLE

Then all you need to do is to register the mimetype using

#+BEGIN_EXAMPLE
    $ xdg-mime default rtorrent-magnet.desktop x-scheme-handler/magnet
#+END_EXAMPLE

***** Magnet to Torrent

You could also use the
[[https://aur.archlinux.org/packages/magnet2torrent-git/][magnet2torrent-git]]^{AUR}
package which downloads the metadata and creates a torrent file.

How to use:

#+BEGIN_EXAMPLE
    $ magnet2torrent <magnet link> [torrent file]
#+END_EXAMPLE

***** rtorrent-pyro

[[https://aur.archlinux.org/packages/rtorrent-pyro/][rtorrent-pyro]]^{AUR[[[/index.php/ArchWiki:Requests#Broken_package_links][broken link]]: archived in
[[http://pkgbuild.com/git/aur-mirror.git/tree/rtorrent-pyro][aur-mirror]]]}
from the [[/index.php/AUR][AUR]] comes with an extended rtorrent console
interface. It does not contain the pyroscope tools yet though. If you
also need the pyroscope tools see [[#PyroScope]] .

Make sure you add following command to ~/.rtorrent.rc, which makes the
asterisk key * to a shortcut for toggling between extended and collapsed
view within rtorrent's interface:

#+BEGIN_EXAMPLE
    schedule = bind_collapse,0,0,"ui.bind_key=download_list,*,view.collapsed.toggle="
#+END_EXAMPLE

Also set "pyro.extended" to 1 to activate rTorrent-PS features.

#+BEGIN_EXAMPLE
    system.method.insert = pyro.extended, value|const, 1
#+END_EXAMPLE

****** PyroScope

We create a directory for the installation of pyroscope, then download
and update the source code from subversion:

#+BEGIN_EXAMPLE
    mkdir -p ~/.lib
    svn checkout http://pyroscope.googlecode.com/svn/trunk/ ~/.lib/pyroscope
    ~/.lib/pyroscope/update-to-head.sh
#+END_EXAMPLE

Adding pyroscope bin's PATH to .bashrc:

#+BEGIN_EXAMPLE
    export PATH=$PATH:path_to_the_bin      # Example path for pyroscope bin's: /home/user/.lib/pyroscope/bin/
#+END_EXAMPLE

Creating the ~/.pyroscope/config.ini:

#+BEGIN_EXAMPLE
    pyroadmin --create-config
#+END_EXAMPLE

Add this to your ~/.rtorrent.rc. Do not forget to add the path of your
pyroscope bin's dir (see below).

#+BEGIN_EXAMPLE
    system.method.insert = pyro.bin_dir, string|const, write_here_path_to_your_pyroscope_bin_dir     # Example path: /home/user/.lib/pyroscope/bin/
    system.method.insert = pyro.rc_dialect, string|const|simple, "execute_capture=bash,-c,\"test $1 = 0.8.6 && echo -n 0.8.6 || echo -n 0.8.9\",dialect,$system.client_version="
    system.method.insert = pyro.rtorrent_rc, string|const|private, "$cat=~/.pyroscope/rtorrent-,\"$pyro.rc_dialect=\",.rc.default"
    import = $pyro.rtorrent_rc=
#+END_EXAMPLE

Optionally: TORQUE: Daemon watchdog schedule. Must be activated by
touching the "~/.pyroscope/run/pyrotorque" file! You can also just use
rtorrent watch dir or give pyro\_watchdog a try, which comes with
'treewatch' ability, meaning it also watches for torrents recursively
within the given watch path. Further documentation for pyro\_watchdog is
here: [[http://code.google.com/p/pyroscope/wiki/QueueManager][[1]]] To
enable pyro\_watchdog, add this in ~/.rtorrent.rc and further
configurations are in ~/.pyroscope/torque.ini.

#+BEGIN_EXAMPLE
    schedule = pyro_watchdog,30,300,"pyro.watchdog=~/.pyroscope,-v"
#+END_EXAMPLE

Following steps are important. Before using pyroscope tools you have to
set the missing "loaded" times to that of the .torrent file. Run this in
your terminal:

#+BEGIN_EXAMPLE
    rtcontrol '!*"*' loaded=0 -q -sname -o 'echo "$(name)s"\ntest -f "$(metafile)s" && rtxmlrpc -q d.set_custom $(hash)s tm_loaded \$(\
        ls -l --time-style "+%%s" "$(metafile)s" \
        | cut -f6 -d" ")\nrtxmlrpc -q d.save_session $(hash)s' | bash
#+END_EXAMPLE

And now set the missing "completed" times to that of the data file or
directory:

#+BEGIN_EXAMPLE
    rtcontrol '!*"*' completed=0 done=100 path=\! is_ghost=no -q -sname -o 'echo "$(name)s"\ntest -e "$(realpath)s" && rtxmlrpc -q d.set_custom $(hash)s tm_completed \$(\
        ls -ld --time-style "+%%s" "$(realpath)s" \
        | cut -f6 -d" ")\nrtxmlrpc -q d.save_session $(hash)s' | bash
#+END_EXAMPLE

Example usage: Will print out all torrents older than 2 hours:

#+BEGIN_EXAMPLE
    rtcontrol -V completed=+2h -scompleted -ocompleted
#+END_EXAMPLE

Deletes all torrents older than 48 hours:

#+BEGIN_EXAMPLE
    rtcontrol -V completed=+48h -scompleted -ocompleted --cull --yes
#+END_EXAMPLE

***** Emacs 按键风格还是非常喜欢的
**** magnet to torrent                                            :magnet:

- [[https://github.com/danfolkes/Magnet2Torrent][GitHub]]
- http://blog.gonzih.me/blog/2012/02/17/how-to-use-magnet-links-with-rtorrent/

#+BEGIN_EXAMPLE
$ sudo mv Magnet2Torrent /opt/toolkit/
$ sudo ln -s /opt/toolkit/Magnet2Torrent/Magnet_To_Torrent2.py /usr/local/bin/magnet2torrent
#+END_EXAMPLE


Note: Rtorrent natively supports downloading torrents through magnet
links. At the main view (reached by starting Rtorrent and pressing 1),
press enter. At "load.normal>" paste the magnet link and press enter
again. This will start the download.

**** 关于磁力链接的使用

工具不分善恶，人分。
*** 万能钥匙                                                :万能钥匙:wifi:

1. what

   <万能钥匙> 可以 “破译” Wifi 密码，有手机端和电脑端。

   使用起来方便，不需要复杂的折腾。

2. 道德问题

   #+BEGIN_QUOTE
   内置天线的网卡的就不要破了，信号不好，掉线太厉害，而且信号一定要好，
   否则可就痛苦了
   #+END_QUOTE

   [[http://zhidao.baidu.com/link?url=7TRa2Ufl5rdEmpeKwUnlq4yoWSMDmdZtNAmT00j-yS0rRtZY9pnUStzXMt6PdL7T0araclMWdZM3qz9tXB-68T6hPMw7JjEjMUefEU4Fzby][百度知道]]

   类似 *凿壁偷光* , 对“被害者“并无直接的经济损失。但这只是用以安抚
   良心的借口罢了。尽量减少这样做，除非必要的时候。

   #+BEGIN_QUOTE
   目前还没有一款密码不能破解的，如果条件允许，破解密码其实就是小菜
   #+END_QUOTE

   另破解 Wifi 是一件挺酷的事情，做 Hacker 必备。

3. 在 Unbuntu下

   [[http://zhidao.baidu.com/link?url=_eunF0MO2MJFnhm7pARCEzbGc3odnaLGzB3yeDS-t3NJVaT965vaxJvj1Gi1Ku_r0e7qhGWseJwZiNwD50SfZ_ouHlCUEfaG0D6PZ3ajLVq][百度知道]]
   #+BEGIN_QUOTE
   什么是万能钥匙。如果是WiFi万能钥匙在ubuntu是没有的，更何况那东西都
   是小玩具的，完全无法与Nmap和Wireshark相比。
   #+END_QUOTE

   尝试使用 wine

   #+BEGIN_EXAMPLE
   wireless zero configuration 被禁用
   #+END_EXAMPLE

   [[http://baike.baidu.com/link?url=Xm-5vkL7agM4OK_XCu7iPfE4llHmVMn5ZMO1zRwo4zQnbTe2rrOenipGZt4B0uCJbGt_rTJDU7V0ZVSr-66QTK][百度百科]]
   #+BEGIN_QUOTE
   wireless zero configuration -无线网络设置服务，通常称为Windows零配
   置服务。
   #+END_QUOTE

   Windows 上的东西，不再折腾。

   放弃 Linux 下使用 <万能钥匙>, 改用更高级的工具。

*** 网址是否区分大小写                                        :网址:大小写:

[[http://www.zhihu.com/question/19572705/answer/12255483][知乎]]

*网址的基本结构是：[协议]://[域名]/[路径]*

*协议和域名部分不分大小写。路径部分是否区分大小写则不一定，要看具体网站后台是如何实现的。*

比如，如果服务器是直接将路径映射到文件系统中去找，则
不同平台上有不同实现：Mac OS X 默认的文件系统（HFS case-insensitive)
是不分大小写的、Windows 上的 NTFS 也是。而 Linux 系统常用的 ext3/4 则
是需要区分大小写的。所以如果服务器不做额外的操作，则会根据文件系统不同
有不同效果。而像知乎这种应用服务器则又有不同。此时路径并不指向文件系统
的某个文件，而是作为字符串交有应用来处理。比如，知乎使用的 Tornado 服
务器是使用正则表达式来进行匹配路径。正则表达式可以通过不同写法或者标志
符来控制是否区分大小写。继新提到的很多短链接服务区分路径大小写，这是为
了增加字符基数、缩短地址长度做出的取舍。假设只使用数字和字母做路径部分，
如果不区分大小写，则只有 10+26 = 36 个字符可以使用。 5 个字符长的地址
就只能有 36^5 = 60 466 176 种组合。而若区分大小写，则有 10 + 26 + 26 =
62 个字符可用，同样 5 个字符长的地址就有 62^5 = 916 132 832 种组合。短
链接地址为了尽可能短，必须要增大基数，因此选择了区分大小写。如果网址只
是给机器使用的话，可以不用计较是否大小写。但实际上难免会遇到要将网址通
过手工输入到地址栏的情况（比如将印刷的地址抄写到浏览器中访问）。为了易
用性的考虑，在条件允许的情况下应该尽可能的不区分大小写。如果需要区分，
则尽可能要对不同写法的地址进行重定向。知乎在这一点上就做得不是很好，比
如这个问题如果通过 http://www.zhihu.com/Question/19572705 就无法访问。
应该修改 Tornado 服务器的正则表达式设置，使其能匹配大写、混合大小写的
地址，或者自动将混合大小写的地址重定向到
http://www.zhihu.com/question/19572705

** game                                                               :game:
*** dota                                                             :dota:
**** steam                                                         :steam:
***** dota 全屏

http://jingyan.baidu.com/article/e75057f2dca190ebc91a893e.html

全屏问题，选项里设置视频，全屏模式

***** error

http://askubuntu.com/questions/614422/problem-with-installing-steam-on-ubuntu-15-04

#+BEGIN_EXAMPLE
$ steam
Running Steam on ubuntu 15.04 64-bit
STEAM_RUNTIME is enabled automatically
Installing breakpad exception handler for appid(steam)/version(0_client)
libGL error: unable to load driver: r600_dri.so
libGL error: driver pointer missing
libGL error: failed to load driver: r600
libGL error: unable to load driver: swrast_dri.so
libGL error: failed to load driver: swrast
#+END_EXAMPLE

**** Ubuntu 安装 dota2                                  :dota:dota2:steam:

1. Linux 下 dota2 仅支持 64 位，所以别折腾
2. Wine 也搞不定
3. 在 steam 或网页上搜索 Dota 2 需要 VPN，不然会屏蔽 IP
*** nethack                                                  :nethack:game:

**** reference

- [[http://www.nethack.org/][Homepage]]
- [[https://zh.wikipedia.org/wiki/NetHack][Wikipedia]]
- [[http://www.emacswiki.org/emacs/NethackMode][EmacsWiki::Nethack Mode]]
- [[http://www.nethack.org/v343/Guidebook.html][GuideBook]]
- [[~/Wally/Reference/Manual/NethackGuidebook.pdf][NethackGuidebook.pdf]]

**** NetHack wikipedia                                         :wikipedia:

*NetHack* 是一款最初在1987年發佈的[[/wiki/%E5%96%AE%E4%BA%BA%E9%81%8A%E6%88%B2][單人遊戲]]（[[//en.wikipedia.org/wiki/Roguelike][Roguelike]]）。它繼承了Hack（1985年）及更早的Rogue（1980年）。
遊戲名字的「網路」元素是指開發過程是通過[[/wiki/%E4%BA%92%E8%81%94%E7%BD%91][互联网]]合作的。

"Hack"
指的是[[/wiki/%E9%9B%BB%E5%AD%90%E8%A7%92%E8%89%B2%E6%89%AE%E6%BC%94%E9%81%8A%E6%88%B2][角色扮演游戏]]的特点------战斗和探索（[[//en.wikipedia.org/wiki/hack_and_slash][hackand slash]]）。

玩家扮演一个地下城探险者寻找Yendor的项链。

***** 历史

/NetHack/ 是[[/wiki/%E5%BC%80%E6%BA%90][开源]]的也是最古老却仍在活跃开发的游戏，由一群闲散神秘的[[/wiki/%E5%BF%97%E6%84%BF%E8%80%85][志愿
者]](DevTeam)进行[[/wiki/%E9%99%A4%E9%8C%AF][除錯]]及添加新特性。

***** 玩法

玩家需要选择自己所扮演的角色并指定性别、[[/wiki/%E7%A7%8D%E6%97%8F][种族]]、[[/wiki/%E8%81%8C%E4%B8%9A][职业]]和[[/wiki/%E9%98%B5%E8%90%A5][阵营]]，或者选择让系
统随机产生一个角色。游戏者可以扮演经典奇幻角色，比如[[/wiki/%E9%AA%91%E5%A3%AB][骑士]]，[[/wiki/%E9%87%8E%E8%A0%BB%E4%BA%BA][野蛮人]]，[[/wiki/%E5%B7%AB%E5%B8%AB][巫师]]，
[[/wiki/%E6%B8%B8%E4%BE%A0][游侠]]，[[/wiki/%E5%A5%B3%E6%AD%A6%E7%A5%9E][女武神]]，[[/wiki/%E5%83%A7%E4%BE%A3][僧侣]]和[[/wiki/%E6%AD%A6%E5%A3%AB][武士]]，也可以选择一些比较少见的角色，诸如[[/wiki/%E8%80%83%E5%8F%A4%E5%AD%A6%E5%AE%B6][考古学家]]、
[[/wiki/%E9%81%8A%E5%AE%A2][游客]]和[[/w/index.php?title=%E6%B4%9E%E7%A9%B4%E4%BA%BA&action=edit&redlink=1][洞穴人]]。玩家的角色和阵营决定了其在游戏中需要侍奉的[[/wiki/%E7%A5%9E%E9%9D%88][神灵]]。

玩家的目标就是在地下城的最底层，取得Yendor的项链并将其供奉给自己的神灵。
作为回报，角色会成为[[/wiki/%E4%B8%8D%E6%9C%BD][不朽]]的[[/wiki/%E5%8D%8A%E7%A5%9E][半神]]。此外，一系列的支线任务也必须完成，其中
包括各职业所特有的任务。

游戏开始的时候，玩家通常会有一只宠物伴随，一般是[[/wiki/%E7%8C%AB][小猫]]或者[[/wiki/%E5%B0%8F%E7%8B%97][小狗]]，但是骑士
会有一匹[[/wiki/%E9%A9%AC][马]]以及一副[[/wiki/%E9%A6%AC%E9%9E%8D][马鞍]]。

游戏中大部分的怪物都可以用魔法及喂食等方式转化为宠物。

****** 地下城等级

/NetHack/的地下城大约总共有50层，其中大多数都是玩家进入的时候随机生成
的。基本上所有的层都有一个向上或向下的通道（包括楼梯，梯子，陷阱或者其
他形式），一些用走廊连接起来的房间，房间里面可能有祭坛，商店，喷泉，陷
阱，甚至水槽。一些比较特别的层有固定的形式。游戏有几个分支路线，包括一个
[[/wiki/%E6%8E%A8%E7%AE%B1%E5%AD%90][推箱子]]游戏和[[/wiki/%E5%BC%97%E6%8B%89%E5%BE%B7%E4%B8%89%E4%B8%96][弗拉德]]之塔。

****** 物品

/NetHack/包含各式的物品：近程及遠程[[/wiki/%E6%AD%A6%E5%99%A8][武器]]、保護角色的[[/wiki/%E7%9B%94%E7%94%B2][盔甲]]、可供[[/wiki/%E9%96%B1%E8%AE%80][閱讀]]的[[/wiki/%E5%8D%B7%E8%BB%B8][卷軸]]及
[[/wiki/%E9%AD%94%E6%B3%95%E6%9B%B8][魔法書]]、可供[[/wiki/%E9%A3%B2][飲用]]的[[/wiki/%E8%8D%AF%E5%89%82][藥劑]]，以及多樣化的[[/wiki/%E5%B7%A5%E5%85%B7][工具]]。

/NetHack/ 的其中一個特色是充滿著不明的物品，例如玩家只能在一瓶新發現的
藥劑上得到簡單的描述，像是“紫色的藥劑”。玩家能以不同的方式辨別其真正
作用，而最簡單但相當危險的方式，就是直接飲用。

***** 界面

/NetHack/原本没有[[/wiki/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2][图形界面]]。

其他图形界面包括使用[[/wiki/%E7%AD%89%E8%A7%92%E6%8A%95%E5%BD%B1][等角投影]]（即45度视角）的[[/w/index.php?title=Falcon%27s_Eye&action=edit&redlink=1][Falcon's Eye]]和[[/w/index.php?title=Vulture%27s&action=edit&redlink=1][Vulture's Eye]]；[[/w/index.php?title=%E4%B8%89%E7%BB%B4%E6%B8%B2%E6%9F%93&action=edit&redlink=1][三维渲染]]的[[/wiki/Noegnud][noegnud]]还有其他一些。

***** 移植

大部分计算机类似的平台都有这个游戏。任天堂DS、PlayStation
Portable、Tapwave Zodiac、GP2X、Windows Mobile、Nokia
N800、Android Phone、Apple's iPhone 、 iPod touch 以及 iPad。


/[[/w/index.php?title=Slash%27EM&action=edit&redlink=1][Slash'EM]]/ 和/SporkHack/ 作为稳定版活跃的开发。

**** Guide book

** 学习工具
*** Linux CAD                                                 :cad:autocad:

Autocad 要用便用最经典的。实用为主。

**** alternatives

- [[http://www.qcad.org/][QCAD]]
- [[http://sourceforge.net/projects/pythoncad/][PythonCAD]]

**** reference

+ [[https://linuxtoy.org/archives/6-of-the-best-free-linux-cad-software.html][6 款高品质的免费 Linux CAD 应用程序]]
+ [[http://www.techdrivein.com/2011/08/8-best-cad-apps-for-linux.html][8 Best CAD Apps For Linux]]
+ [[http://blog.cometdocs.com/10-great-free-alternatives-to-autocad][10 Great Free Alternatives to AutoCAD]]

*** dia                                                               :dia:
**** [[http://tech.sina.com.cn/s/2012-03-16/14166844479.shtml#artibodyTitle][5款替代微软Visio的开源免费软件]]                                 :blog:

提到流程图和图表设计，自然会想到微软出品的Office Visio，它是一款强大的流程图设计工具。Visio并不在Office标准套装中，需要额外付费购买，这可能会带来某些不便。一方面，并不是所有人都负担得起，另外，如果是应急之需，临时购买恐怕也来不及了。

今天我们介绍几款免费的Visio替代软件，也许你对某些软件的名字感到陌生，现在我们逐一简要了解一下。

1、DIA Diagram Editor

Dia主界面Dia主界面
Dia被我们列在头一名，不仅是因为它功能强大和跨平台特性，也源于它原生支持简体中文界面。与Visio相比，Dia安装包仅不足20MB，可以放在网盘或U盘中随身携带。初用者可能觉得Dia用法比较繁琐而麻烦，但是无法否认，它仍然是综合性能最佳的免费替代方案。

Dia支持导出的流程图格式如下：EPS、SVG、DXF(Autocad格式)、CGM、WMF、PNG、JPEG、VDX(Microsoft Visio格式)。

优点：跨平台，支持简体中文界面

缺点：不易上手

下载：http://down.tech.sina.com.cn/content/41811.html

2、Open Office Draw

Open Office DrawOpen Office Draw
Linux用户对OpenOffice应该不会陌生，它是大名鼎鼎的开源办公套件，同时支持Windows和Mac。做为办公套件中的一部分，OpenOffice DRAW不仅免费提供，而且具备较为出色和相对完整的结构图表绘制功能，其最大绘图尺寸可达300cm x 300cm。绘图时产生的“对象”可以编组、分组、重组等操作，它也有些高级特性，例如支持渲染自定义贴图和模拟灯光效果，并能输出具备真实光感的高品质图形。OpenOffice DRAW支持大部分常见图像格式，我们还可以通过其内置的图形库获得大量免费图形素材。

优点：跨平台，简单易用

缺点：安装包较大

下载简体便携版：http://down.tech.sina.com.cn/content/37788.html

3、Inkscape

Inkscape主界面Inkscape主界面
又一款开源免费的矢量绘图软件，初看界面很像Photoshop，还是比较容易上手的，加上自带简体中文支持，对国人来说更是方便了。Inkscape支持节点编辑，可绘制复杂的路径和位图描摹。Inkscape比较突出的一大特点就是针对SVG的优化支持，它使用W3C标准的SVG文件格式，提供了众多高级特性，包括标记、克隆、Alpha融合、渐变、贴图，编组等等。

优点：跨平台，支持简体中文界面

缺点：流程图设计方面有待加强

下载：http://down.tech.sina.com.cn/content/16418.html

4、Graphviz

Graphviz绘制的复杂流程图Graphviz绘制的复杂流程图
Graphviz是大名鼎鼎的贝尔实验室的几位牛人开发的一个画图工具，历史比较久远了。它的软件设计理念和一般“所见即所得”的画图工具不一样，是“所想即所得”。Graphviz提供了DOT语言来编写绘图脚本。显然，这款软件并不适合一般用户，只适合那些对脚本语言代码较熟练的用户或是开发人员使用。

优点：使用脚本绘图，功能强大，支持SVG

缺点：无用户界面，不适合普通用户

下载：http://down.tech.sina.com.cn/content/53737.html

5、Kivio

Kivio主界面Kivio主界面
Kivio是开源办公套件KOffice的一部分，是一款强大的Linux图表和流程图绘制软件。它可以帮助你快速设计原型、线框图、流程图或是图表。Kivio有着与微软Visio类似的用户界面，但在用户界面上有所增强，允许使用分割窗格进行图形绘制。比较遗憾的是，Kivio目前只面向Linux用户。

其它功能：

支持使用Python脚本模板创作

与Dia模具兼容

优点：操作简单，界面清晰易懂

缺点：无Windows版本

下载：http://down.tech.sina.com.cn/content/35996.html

**** overview
Dia is a program to draw structured diagrams.

特性：
+ 跨平台
+ 开源 GPL

**** Install
+ apt-get(OK)
+ 源码: 不会

Download Page: http://dia-installer.de/download/linux.html


Additional shapes: http://dia-installer.de/shapes/index.html.en

**** 中文输入问题
http://yanue.net/post-117.html

$ sudo vi /usr/bin/dia
然后把dia-gnome --integrated "$@"修改成 dia-gnome  "$@"

重新启动dia，输入法选择系统默认（我的系统输入法是ibus），就可以输入中
文了不过这样一改，工具条变成浮动的了...

**** dia Assorted Geometric Shapes narrow
dia的图形文件类型后缀名为.shape，这是一种XML定义的文件，其中有个tag为
aspectradio, 其属性type可以是fixed和free, 定义了缩放时的行为。

**** 导出问题
导出为PDF时，可能会分块放在几页PDF上，不明所以

png有多种不同格式，前面的一种在处理英文字符时行为古怪

jpeg导出没有问题

**** why
Office Visio是一款优秀而强大的流程图设计工具，不能因为使用Linux而对
Windows产品产生鄙夷，要纯粹，要包容，去掉内心的杂质(心意萌动时便知，此
时是格物致知的最好时刻)。

但要相信，windows能做到的，Linux多数能够做到，而且更加自由（Windows能
做而Linux做不到的，一则是自己能力弱，二则是没有需求）。

**** DIA

参考:
+ http://zh.wikipedia.org/wiki/Dia
+ https://wiki.gnome.org/Apps/Dia
+ http://www.seanet.com/~hgg9140/comp/diatut/all/all.html


1. Dia是什么?
  Dia是开放源代码的流程图,是GNU计划的一部分.

  From DIA homepage:

  Welcome to Dia's new homepage. Dia is a GTK+ based diagram creation
  program for GNU/Linux, MacOS X, Unix, and Windows, and is released
  under the GPL license.

  Dia is roughly inspired by the commercial Windows program 'Visio'
  though more geared towards informal diagrams for casual use. It can
  be used to draw many different kinds of diagrams. It currently has
  special objects to help draw entity relationship diagrams, UML
  diagrams, flowcharts, network diagrams, and many other diagrams. It
  is also possible to add support for new shapes by writing simple XML
  files, using a subset of SVG\footnote{可缩放矢量图形（英语：Scalable
    Vector Graphics，SVG）是基于可扩展标记语言（XML），用于描述二维矢
    量图形的一种图形格式。SVG由W3C制定，是一个开放标准。} to draw the
  shape.

  It can load and save diagrams to a customo XML format,can export
  diagrams to a number of formats including EPS,SVG,XFIG,WMF and
  PNG,and can print diagrams.

2. 基本使用
   + 左对齐    S-M-l
   + 右对齐    S-M-r
   + 水平居中对齐    S-M-c
   + 顶部对齐    S-M-t
   + 底部对齐    S-M-b
   + 垂直居中对齐    S-M-m
   + 水平平均分布    S-M-h
   + 垂直平均分布    S-M-v
   + 相邻的    S-M-a
   + 堆叠    S-M-s
*** fritzing                                                     :fritzing:
+ http://fritzing.org/home/
+ http://fritzing.org/learning/tutorials


Fritzing is an open-source hardware initiative that makes electronics
accessible as a creative material for anyone. We offer a software
tool, a community website and services in the spirit of Processing and
Arduino, fostering a creative ecosystem that allows users to document
their prototypes, share them with others, teach electronics in a
classroom, and layout and manufacture professional pcbs.

*** blender                                                       :blender:
**** reference                                                  :homepage:

- [[https://www.blender.org/manual/zh.cn/getting_started/index.html][Blender 官方入门教材（中文）]]
- [[https://zh.wikibooks.org/zh-cn/Blender_3D%EF%B8%B0%E5%BE%9E%E5%85%A5%E9%96%80%E5%88%B0%E7%B2%BE%E9%80%9A][Blender 3D︰从入门到精通(wikibook)]]
- [[http://wiki.blender.org/][Homepage]]

+ https://www.blender.org/
+ [[http://wiki.ubuntu.org.cn/Blender2.5x-2.6%E5%AE%8C%E5%85%A8%E6%95%99%E7%A8%8B][Ubuntu wiki: Blender 2.5x-2.6 完全教程]]
+ http://www.blendercn.org/

**** Blender wiki
+ Wiki: http://zh.wikipedia.org/wiki/Blender
+ Forum: http://blenderartists.org/forum/
+ Homepage: http://www.blender.org/
+ cn: http://www.blendercn.org/


Blender是一套三维绘图及渲染软件。它具有跨平台的特性，支持FreeBSD，IRIX，
GNU/Linux，Microsoft Windows，Mac OS X，Solaris，及SkyOS。但是，目前不
支持中文的文件名与文件夹。

**** document                                                   :document:

https://www.blender.org/manual/zh.cn/about/install/linux.html

安装 HTML 版的 Blender Referece Manual

比 wget 要好得多

Once the docs have been built, all the html files can be found inside
~/blender_docs/build/html. Try opening build/html/contents.html in
your web browser and read the manual.

**** guide

***** 配置数据路径

https://www.blender.org/manual/zh.cn/getting_started/installing_blender/directorylayout.html

Blender使用了三种不同的文件夹，它们是跟操作系统有关系的。

- 本地 :: 配置和运行时数据位置（只供自己绑定使用）

- 用户 :: 配置文件位置（通常情况下在用户的家文件夹下）

- 系统 :: 系统级安装后的运行时数据位置（可能是只读的）。

系统级安装 *系统* 和 *用户* 文件夹都是需要的。

如果是本地解压Blender的发行版，这些用户配置数据和运行时数据都在一个子
文件夹下面，允许Blender的多个版本共存而且不会有冲突，可以忽略

*用户* 和 *系统* 文件。

注解

注解：你有可能需要确保你的文件管理器中，显示隐藏文件的选项已经被勾选。

****** 基于不同平台的路径

下面是各个系统的默认文件夹位置：

******* Linux

- 本地 ::
  #+BEGIN_EXAMPLE
      ./2.76/
  #+END_EXAMPLE

- 用户 ::
  #+BEGIN_EXAMPLE
      $HOME/.config/blender/2.76/
  #+END_EXAMPLE

  # $ ls .config/blender/2.72/
  # config  scripts

- 系统 ::
  #+BEGIN_EXAMPLE
      /usr/share/blender/2.76/
  #+END_EXAMPLE

注解

该路径./2.76/是相对于Blender可执行文件以及用于自包含官方blender.org构建发布软件包。

注解

The *USER* path will use =$XDG_CONFIG_HOME= if its set:

#+BEGIN_EXAMPLE
    $XDG_CONFIG_HOME/blender/2.76/
#+END_EXAMPLE

******* Mac OSX

-  本地 :: #+BEGIN_EXAMPLE
       ./2.76/
   #+END_EXAMPLE

-  用户 :: #+BEGIN_EXAMPLE
       /Users/$USER/Library/Application Support/Blender/2.76/
   #+END_EXAMPLE

-  系统 :: #+BEGIN_EXAMPLE
       /Library/Application Support/Blender/2.76/
   #+END_EXAMPLE

注解

OSX 存储blender二进制文件，放在 ‘./blender.app/Contents/MacOS/blender
‘，所以数据及配置的本地路径是:

#+BEGIN_EXAMPLE
    ./blender.app/Contents/MacOS/2.76/
#+END_EXAMPLE

******* MS-Windows

-  本地 :: #+BEGIN_EXAMPLE
       .\2.76\.
   #+END_EXAMPLE

-  用户 :: #+BEGIN_EXAMPLE
       C:\Documents and Settings\$USERNAME\AppData\Roaming\Blender Foundation\Blender\2.76\
   #+END_EXAMPLE

-  系统 :: #+BEGIN_EXAMPLE
       C:\Documents and Settings\All Users\AppData\Roaming\Blender Foundation\Blender\2.76\
   #+END_EXAMPLE

****** 路径布局

下面的路径布局是以上的文件夹描述规范。

‘./Config/startup.blend ‘ 可能在哪里 ~/.blender/[[#id1][|例如
BLENDER_VERSION|]]/config/startup.blend。

-  =./autosave/ ...= :: 自动保存混合文件位置。* Windows
   只，临时目录用于其他 systems.*

   搜索顺序: =LOCAL, USER=.

-  =./config/ ...= :: 默认值与会话信息。

   搜索顺序: =LOCAL, USER=.

-  =./config/startup.blend= :: 载入初始文件和用户设置

-  =./config/userpref.blend= :: 载入初始文件和用户设置

-  =./config/bookmarks.txt= :: 在文件选择器中隐藏系统书签

-  =./config/recent-files.txt= :: 在文件管理器中隐藏最近查看的路径

-  =./datafiles/ ...= :: 运行时文件

   搜索顺序: =LOCAL, USER, SYSTEM=.

-  =./datafiles/locale/{language}/= :: 用户界面翻译的静态预编译的语言文件。

-  =./datafiles/icons/*.png= :: Blender用户界面的图标主题。*
   不目前可选的主题 preferences.*

-  =./datafiles/brushicons/*.png= :: 对于每个画笔的图像。

-  =./scripts/ ...= :: Python 脚本的用户界面和工具。

   搜索顺序: =LOCAL, USER, SYSTEM=.

-  =./scripts/addons/*.py= :: Python
   加载项在用户首选项，可以使包括导入/导出格式支持、
   渲染引擎集成和许多方便实用。

-  =./scripts/addons/modules/*.py= :: 模块的加载项的使用 (添加到 Python
   的 sys.path)。

-  =./scripts/addons_contrib/*.py= :: 另一个加载项目录是用于社区维护的插件
   (必须手动创建)。

-  =./scripts/addons_contrib/modules/*.py= :: 对 addons_contrib 的模块
   (添加到 Python 的 sys.path) 的使用。

-  =./scripts/modules/*.py= :: 包含我们的核心 API 和其他脚本到效用函数的
   Python 模块导入 (添加到 Python 的 ‘sys.path ‘)。

-  =./scripts/startup/*.py= :: 在启动时将自动导入的脚本。

-  =./scripts/presets/{preset}/*.py= :: 预设用于存储用户定义设置布、
   呈现格式等。

-  =./scripts/templates/*.py= :: 可以从访问的示例脚本:
   文本空间标题-->--> 脚本模板的文本。

-  =./python/ ...= :: 捆绑的 Python 发行版，不仅是必要的系统安装的
   Python 时缺席或不兼容。

   搜索顺序: =LOCAL, SYSTEM=.

***** 插件--NGENNGT翻译

https://www.blender.org/manual/zh.cn/advanced/scripting/python/add_ons.html

/插件/ 是对扩展Blender功能的脚本的通用术语。在 /用户设置/ 窗口的 /插件/
标签页找到这些脚本，在该标签页下可以搜索、安装、启用和禁用 插件。

****** 搜索

Blender自带一些好用的插件，你可以自行启用。不过你也可以添加你自己的或者从网上找到的有趣插件。


#+DOWNLOADED: https://www.blender.org/manual/zh.cn/_images/user_prefs-addons_tab.png @ 2016-01-18 11:47:34
 [[~/Wally/Journal/Figure/.org-download/Journal/user_prefs-addons_tab_2016-01-18_11:47:33.png]]

用户设置窗口中的插件标签页

[[http://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts][脚本目录]]
提供了Blender自带插件索引，同时也列出了许多外部插件。

****** 启用和禁用

如图所示，勾选或取消勾选插件右侧的复选框即可启用或禁用该插件。


#+DOWNLOADED: https://www.blender.org/manual/zh.cn/_images/Extensions-Python-Addons-EnabledAddOn.jpg @ 2016-01-18 11:47:56
 [[~/Wally/Journal/Figure/.org-download/Journal/Extensions-Python-Addons-EnabledAddOn_2016-01-18_11:47:55.jpg]]

启用插件

启用插件功能可以即时生效。 如果启用后插件未激活， 可以在 [[../../../interface/window_system/console_window.html][/控制台窗口/]]
查看发生的错误。

单击插件左侧的箭头可以查看更多信息，如插件存放位置、描述和文档链接，你
还可以通过“报告Bug”按钮报告该插件的bug。


小技巧

保存插件设置

如果想要插件随Blender打开同时启用，你需要 /保存用户设置/ 。

****** 安装第三方插件

对于网络下载的或你自己的插件，需要单击 /从文件安装.../ 并选择 .zip 或
.py文件安装后，才能在插件列表中显示该插件。

或者你还可以手动安装插件，这在开发自己的插件过程中很有用。

直接将文件移动或链接至 =../scripts/addons= 文件夹(你的Blender文件夹配
置路径).

[[/home/wally/Wally/Journal/Figure/scrot/2380aff.png]]

****** 文件位置

关于Blender目录信息详见 [[../../../getting_started/installing_blender/directorylayout.html][/配置& 数据路径/]]。

你还可以新建个人插件目录，并在 /用户设置/ 中的 /文件/
面板配置该路径。新建一个个人脚本文件夹：

-  新建一个空文件夹 (如'script_addon_2-7x')

-  在该文件夹下添加一个 ‘addons'
   文件夹，只有这样命名Blender才能正确识别。

-  将你的新插件置于该 ‘addons' 文件夹。

-  打开 /用户设置/ 的 /文件/ 面板。

-  在 /脚本/ 路径中选择你的脚本文件夹路径 (如 ‘script_addon_2-7x')。

****** 开发指南

如果你是一个脚本开发人员，你可能对 [[http://wiki.blender.org/index.php/Dev:2.5/Py/Scripts/Guidelines/Addons][插件开发指南]] 感兴趣。

**** introduction

Blender is free and open source software. Free to use for any purpose,
forever.

Blender是一个开放源代码的多平台全能三维动画制作软件，提供从建模、动画、
材质、渲染，到音频处理、视频剪辑等一系列动画影片及游戏制作解决方案。
Blender以python程序语言为内建脚本，支持yafaray渲染器，同时还内建游戏引
擎。

Blender在GNU公共许可协议下已经发布并公开其源代码，GNU General Public
License简称GPL，是一个自由软件许可协议。因此Blender是完全免费的，并且
没有教育版、专业版或商业版之分。Blender创作的艺术品（包含python脚本）
的唯一所有权就是创作者。

选择Blender的好处有：
+ 稳定高效的3D图形图像及动画处理能力，不到80M大小的软件已具备其他同类
  商业软件的强大功能；
+ 支持其他专业影视编辑特效软件的数据导入和传递，为各种软件的相互搭配工
  作创造良好条件；
+ 软件的快速发展和永不间断的更新，开放各种插件扩充接口，具有可期待无限
  潜力的未来；
+ 免费开放源代码，使用者可以自由开发定制所需的特定功能模块，满足个性化
  需求。

**** install
To install Blender, download the appropriate package for your
platform. The Windows version comes with an optional self-extracting
installer, for other operating systems you can simply unpack the
compressed file to the location of your choice.

Provided the Blender binary is in the original extracted directory,
Blender will run straight out of the box. No system libraries or
system preferences are altered.

**** blender, maya, 3dmax
+ http://zhidao.baidu.com/link?url=5Da2b2RnrfMLd4TFQiYDvb-ZXmuMPL9gbRQtrYNpMTG1b6FfzzFj0tTlV4yjiQnEDHjRva1kZ16sWuF6Vif-yK


3DMAX是Autodesk出品的老牌软件，被广泛应用于建筑、动画、影视、广告等领
域，是所有三维软件中使用人数最多的。例如，《2012》里就是以MAX为主制作
的特效。

Maya是Alisa公司出的，因其独特的架构一出道便不同凡响，他比起MAX来更加自
由开放，强大的脚本扩展功能很是吸引那些自由个性的艺术家。例如，《变形金
刚》就是以MAYA为主制作的特效。

Blender，我很惊讶你从哪里知道这款软件的，很多使用三维软件的人也都不知
道这软件。Blender是所有三维软件里唯一的开源软件。何谓开源，就是源代码
完全开放，可任由他人来改动或扩展。Blender又是所有三维软件里唯一的非商
业化软件，就是完全免费啦。由于是自由组织开发的，且严重依赖于编程，所以
目前还不成熟。目前只出品过两部实验片，一部忘了，另一部是《大雄兔》。


3ds MAX (3D Studio Max) 前身是Kinetix基于PC平台DOS系统开发的3D Sudio系
列，简单来说就是界面易于理解，容易上手，作品成型快速。扩展插件众多。
MAX的早期版本主要用于游戏开发和动画制作，较少用于电影特效。随着版本更
新功能增强和第三方渲染器的加入逐渐应用于电影工业。只能运行在Windows平
台。有中文版。价格昂贵（4万￥）。在我国广泛用于游戏开发，平面设计，效
果图制作，广告，影视等领域，好找工作。

MAYA 是 Alias 收购 Wavefront 公司后 进军 影视特效领域开发的重量级软件，
早期版本就内置高级粒子特效，布料模拟、海洋模拟功能，完全符合影视级特效
渲染的严格要求。可运行在Windows,IRIX,Linux等平台。有中文版，价格昂贵。
在我国部分用于游戏开发，广泛应用预动画和影视特效，当然也好找工作。

Blender 最初是荷兰一家动画工作室运行在IRIX上的私有动画软件，后来开源并
免费， 发展迅速，目前1～2个月就一次修订板。 Blender 几乎是全能的， 包
含了3D动画软件应有的一切功能，还有后期处理功能，并且内置游戏引擎，可以
开发实时运行的游戏。

Blender 支持最多的平台 Windows,Linux,Mac,FreeBSD,IRIX,甚至IPAQ PDA上。
已经在世界上掀起学习和使用的热潮，截至目前有1千万人在使用。目前 2.49
有中文版。但2.49是旧界面，2.5系列采用全新界面，暂时没有稳定的中文版，
但要不了多久就会出来。

对于从未接触过3D动画软件的人来说，Blender上手不难。无论是做效果图还是
动画，都不需要编程知识，除非需要深度扩展。在我国目前仅有个别游戏公司用
项目开发，零星用于平面设计、教育等领域。难找工作，但Blender潜力巨大，
正在进入专业领域，  阿里云渲染就只支持Blender 和 MAYA。 Blender已经是
一个伟大的软件！
**** blender dae                                                     :dae:

***** solutions

http://blender.stackexchange.com/questions/160/can-blender-export-to-the-collada-format

****** ppa

https://launchpad.net/~irie/+archive/blender

#+BEGIN_EXAMPLE
  Installing from the PPA:
  Add the PPA: ppa:irie/blender (sudo add-apt-repository ppa:irie/blender)
  Update your sources (Ubuntu Software Center does this automatically, but you will need to do it manually if adding from the command line). (sudo apt-get update)
  Install blender (this package is 2.6x from git) (sudo apt-get install blender)
#+END_EXAMPLE

http://askubuntu.com/questions/169542/how-do-i-install-the-latest-blender-3d-builds-from-a-ppa

#+BEGIN_EXAMPLE
And now that Irie PPA is not updated anymore, to get the latest version (updated weekly), you can use this instead:

sudo add-apt-repository ppa:thomas-schiex/blender
sudo apt-get update
sudo apt-get install blender
#+END_EXAMPLE

****** plugin

http://sourceforge.net/projects/colladablender/

the above link points to a blender 2.49 script. it will not work with recent Blender versions!

****** compile

#+BEGIN_EXAMPLE
 WITH_OPENCOLLADA                 ON
#+END_EXAMPLE

******* git clone

https://developer.blender.org/diffusion/B/

#+BEGIN_EXAMPLE
# read-only access
git clone git://git.blender.org/blender.git

# read/write access
git clone git@git.blender.org:blender.git

cd blender
git submodule update --init --recursive
git submodule foreach git checkout master
git submodule foreach git pull --rebase origin master
#+END_EXAMPLE

******* build

http://wiki.blender.org/index.php/Dev:Doc/Building_Blender

ccmake

#+BEGIN_EXAMPLE
  home/wally/Download/blender/source/blender/imbuf/intern/openexr/openexr_api.cpp
  fatal error: ImfMultiView.h: 没有那个文件或目录
   #include <ImfMultiView.h>
#+END_EXAMPLE

- openexr :: command-line tools and docs for the OpenEXR image format
- openexr-viewers :: viewer for images in the OpenEXR format

apt-get 方式安装相应软件后依然存在错误。


https://github.com/openexr/openexr

装这个更加烦人，编译半天一堆错误。

***** test

#+BEGIN_EXAMPLE
fake_module: addon missing 'bl_info' gives bad performance!: '/usr/share/blender/scripts/addons/colladaExport14.py'
#+END_EXAMPLE

***** plugin

*** dae                                                               :dae:
**** .dae
+ 文件类型：Digital Asset Exchange File
+ 扩展名为.dae的文件是一个3D 图像文件。
+ 文件说明：

  3D interchange file format used for exchanging digital assets
  between multiple graphics programs; based on the COLLADA
  (COLLAborative Design Activity) XML schema.

  The COLLADA format was originally developed by Sony and is now
  jointly supported by Sony and the Khronos Group..dae

***** 打开.dae文件
+ Mac OS
  - Autodesk Maya with ColladaMaya plugin
  - DAZ Productions DAZ Studio
  - Luxology modo
  - GLC_Player
　
+ Windows
  - Autodesk AutoCAD
  - Autodesk 3dsMax with ColladaMax plugin
  - Autodesk Maya with ColladaMaya plugin
  - Bentley Systems Microstation
  - DAZ Productions DAZ Studio
  - Luxology modo
　
+ Linux
  - Autodesk Maya with ColladaMaya plugin
  - GLC_Player
  - Blender with Collada Plug-in for Blender

*** 词汇朗读软件和脚本
+ ttsu
+ espeak
  - src: make make install
  - error: cannot find -lportaudio
    - apt-get install libportaudio
  - 语音不好听

+ eguidedog

*** Graphviz                                                     :graphviz:
参考:
+ http://www.cnblogs.com/sld666666/archive/2010/06/25/1765510.html
+ https://github.com/ppareit/graphviz-dot-mode

**** 简介
- 画图工具
- 贝尔实验室开发
- "所想即所得"
- 使用dot语言编写绘图脚本
**** Emacs graphviz-dot-mode
|--------+---------------|
| C-c c  | 编译dot源代码 |
| C-c p  | 显示图片      |
|--------+---------------|
**** 基本使用
***** 绘制对象
DOT语言描述三种对象:
+ *Graph(图表)*
+ *Node(结点)*
+ *Edge*
***** Graph分类
+ *Digraph*: 有向图
+ *graph*: 无向图
***** 例子
****** eg 1
#+header: :file /home/ben/tiger/figures/1503281715.pdf
#+header: :exports none
#+header: :tangle /home/ben/Tiger/Journal/src/graphviz_0328-1.dot
#+BEGIN_SRC dot
  digraph G{
      main -> parse -> execute;
      main -> init;
      main -> cleanup;
      execute -> make_string;
      execute -> printf;
      init -> make_string;
      main -> printf;
      execute -> compare;
  }
#+END_SRC

#+RESULTS:
[[file:/home/wally/Wally/Journal/Figure/1503281715.pdf]]

注:
1. listings宏包不支持dot语言, 所以设置exports为none, 而折衷改用EXAMPLE
   包裹源码
2. #+RESULTS在org-mode显示的结果不会导出到 TeX 中.

#+BEGIN_EXAMPLE
  digraph G{
      main -> parse -> execute;
      main -> init;
      main -> cleanup;
      execute -> make_string;
      execute -> printf;
      init -> make_string;
      main -> printf;
      execute -> compare;
  }
#+END_EXAMPLE

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{/home/wally/Wally/Journal/Figure/1503281715.pdf}
\end{figure}

****** eg 2
#+header: :file /home/ben/tiger/figures/1503281920.pdf
#+header: :exports none
#+header: :tangle /home/ben/Tiger/Journal/src/graphviz_0328_2.dot
#+BEGIN_SRC dot
  digraph G{
      size = "4,4";
      main [shape=box];  /*this is a comment*/
      main -> parse [weight=8];
      parse -> execute;
      main -> init [style=dotted];
      main -> cleanup;
      execute -> {make_string; printf}
      init -> make_string;
      main -> printf[style=bold, label="100 times"];
      edge [color=red];
      make_string [label="make a\nstring"];
      node [shape=box, style=filled,color=".7 .3 1.0"];
      execute -> compare;
  }
#+END_SRC

#+RESULTS:
[[file:/home/wally/Wally/Journal/Figure/1503281920.pdf]]



\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{/home/wally/Wally/Journal/Figure/1503281920.pdf}
\end{figure}




   digraph G : 定义graph对象及名称
   {}花括号中定义nodes(结点)，edges(连线)，subgraph(子图)，并设置属性.
   对象名可以是C标识符，数字以及引号括起的C字符串(引号中可以包含标点符
   号和空白符)
   结点名首次出现时,生成该结点;"->"连接结点生成连线.
   通过设定结点和连线的属性,可以调整其在布局中形式.
   属性按对出现:名称-值,置于结点或连线的后面,用方括号括起,括号中使用逗
   号分隔.
   size="4,4", 设定graph尺寸,单位英寸.
   execute->{make_string,; printf}  一对多连接结点使用花括号括起,分号
   间隔.

**** [[http://www.cnblogs.com/sld666666/archive/2010/06/25/1765510.html][利用Graphviz画结构图]]                                           :blog:

***** 1. Graphviz介绍

 Graphviz是大名鼎鼎的贝尔实验室的几位牛人开发的一个画图工具。

它的理念和一般的“所见即所得”的画图工具不一样，是“所想即所得”。

Graphviz提供了dot语言来编写绘图脚本。什么？！画个图也需要一个语言！！

不要急，dot语言是非常简单地，只要看了下面几个列子，就能使用了。

***** 2. Graphviz的几个例子

下面的几个例子都来自于官方文档。详情请见：[[http://www.graphviz.org/][Graphviz官网]].

****** 2.1 Fancy graph

#+BEGIN_EXAMPLE
     digraph G{

        size = "4, 4";//图片大小
        main[shape=box];/*形状*/

        main->parse;
        parse->execute;

        main->init[style = dotted];//虚线

        main->cleanup;

        execute->{make_string; printf}//连接两个

        init->make_string;

        edge[color = red]; // 连接线的颜色

        main->printf[style=bold, label="100 times"];//线的 label

        make_string[label = "make a\nstring"]// \n, 这个node的label，注意和上一行的区别

        node[shape = box, style = filled, color = ".7.3 1.0"];//一个node的属性

        execute->compare;
    }
#+END_EXAMPLE

从上面的代码可以看出，dot语言非常简单，就是一个纯描述性的语言而已。

大家可以把上面的代码和下图中的连接对应起来看。


[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/1.png][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/1_thumb.png]]]]

  <图1. Fancy graph>

****** 2.2 Polygon graph

#+BEGIN_EXAMPLE
     digraph G{
        size = "4, 4"
        a->b->c;
        b->d;

        a[shape = polygon, sides = 5, peripheries=3, color = lightblue, style = filled];
        //我的形状是多边形，有五条边，3条边框， 颜色的淡蓝色， 样式为填充
        c[shape = polygon, sides = 4, skew= 0.4, lable = "hello world"];
        //我的形状是4变形， 角的弯曲度0.4, 里面的内容为"hello world"
        d[shape = invtriange];
        //我是三角形
        e[shape = polygon, side = 4, distortion = .7];
        //我是梯形啊
    }
#+END_EXAMPLE





下面是对应的图片：


[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/polygon_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/polygon_thumb.jpg]]]]

#+BEGIN_QUOTE
    <图2. Polygon graph>
#+END_QUOTE

****** 2.3 连接点的方向

  我们可以用“n”,”ne”,”e”,””se”, “sw”,”w”,”nw”,

分别表示冲哪一个方向连接这个节点（图形）-“north, northeast......”

如：

#+BEGIN_EXAMPLE
     digraph G{
        //b->c[tailport = se];
        b->c:se;
    }
#+END_EXAMPLE





#+BEGIN_QUOTE

  [[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/se_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/se_thumb.jpg]]]]

    <图3. Se graph>


#+END_QUOTE

****** 2.4 数据结构图

  数据结构图是我们很容易用到的一类图形，一个简单地数据结构图代码如下：

#+BEGIN_EXAMPLE
     digraph g{
        node [shape = record,height=.1//我定义了我下面的样式;
        node0[label = "<f0> |<f1> G|<f2> "];
        //我是一个node,我有三个属性，第二个的名字为G，其他两个为空
            node1[label = "<f0> |<f1> E|<f2> "];
           node2[label = "<f0> |<f1> B|<f2> "];
           node3[label = "<f0> |<f1> F|<f2> "];
           node4[label = "<f0> |<f1> R|<f2> "];
           node5[label = "<f0> |<f1> H|<f2> "];
           node6[label = "<f0> |<f1> Y|<f2> "];
           node7[label = "<f0> |<f1> A|<f2> "];
           node8[label = "<f0> |<f1> C|<f2> "];

        "node0": f2->"node4":f1;
        //我的第三个属性连到node4的第二个属性
        "node0": f0->"node1":f1;
        "node1": f0->"node2":f1;
        "node1": f2->"node3":f1;
        "node2": f2->"node8":f1;
        "node2": f0->"node7":f1;
        "node4": f2->"node6":f1;
        "node4": f0->"node5":f1;
    }
#+END_EXAMPLE






[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/data_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/data_thumb.jpg]]]]

  <图4. Data graph>

****** 2.5 Hash table graph

#+BEGIN_EXAMPLE
     digraph g {
        nodesep = .05;
        rankdir = LR;

        node[shape = record, width = .1, height = .1];

        node0[label = "<f0> |<f1> |<f2> |<f3> |<f4> |<f5> |<f6> |", height = 2.5];
        //我是一个节点，我有7个属性
        node [width = 1.5];
        node1[label = "{<n> n14 | 719 |<p>}"];
        //我还是一个节点， 也定义了三个属性
        node2[label = "{<n> a1 | 719 |<p>}"];
        node3[label = "{<n> i9 | 512 |<p>}"];
        node4[label = "{<n> e5 | 632 |<p>}"];
        node5[label = "{<n> t20 | 959 |<p>}"];
        node6[label = "{<n> o15 | 794 |<p>}"];
        node7[label = "{<n> s19 | 659 |<p>}"];

        //好了，我开始连接了
        node0:f0->node1:n;
        node0:f1->node2:n;
        node0:f2->node3:n;
        node0:f5->node4:n;
        node0:f6->node5:n;
        node2:p->node6:n;
        node4:p->node7:n;
    }
#+END_EXAMPLE



这是一个简单地哈希表，如下图所示


[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/Hash_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/Hash_thumb.jpg]]]]

  <图5. Hash
table graph>





****** 2.6 Process grahp

下面画一个轻量级的流程图。

#+BEGIN_EXAMPLE
     digraph g {
        subgraph cluster0 {
            //我是一个子图，subgraph定义了我，
            node[style = filled, color = white];
            //我之内的节点都是这种样式
            style = filled;
            //我的样式是填充
            color = lightgrey;
            //我的颜色
            a0->a1->a2->a3;
            label = "prcess #1"
            //我的标题
        }

        subgraph cluster1 {
            //我也是一个子图
            node[style = filled];
            b0->b1->b2->b3;
            label = "process #2";
            color = blue;
        }

        //定义完毕之后，下面还是连接了
        start->a0;
        start->b0;
        a1->b3;
        b2->a3;
        a3->end;
        b3->end;

        start[shape=Mdiamond];
        end[shape=Msquare];
    }
#+END_EXAMPLE







结果输出图形如下：


[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/Process_2.jpg][[[http://images.cnblogs.com/cnblogs_com/sld666666/WindowsLiveWriter/Graphviz_115A4/Process_thumb.jpg]]]]

  <图6. Hash table graph>



***** 3. 小结


相信这几个列子下来，各位看官对graphviz也有了了解了吧，我个人用了一遍下来发现太爽了。

而对于dot语言，作为一个描述性的语言就非常简单了，
只要有编程基础的人，模仿几个列子下来

应该就能应用了。

*** stardict                                                     :stardict:

**** reference
+ [[http://www.stardict.org/][Homepage]]
+ [[http://stardict-4.sourceforge.net/][SourceForge]]
+
+ http://pan.baidu.com/s/1c01qNM4#path=%252Fhuzheng_life
+ http://wiki.ubuntu.org.cn/index.php?title=Stardict&variant=zh-cn



**** installation                                                :install:

#+BEGIN_EXAMPLE
  $ ./configure

  ...
  ./configure: line 4567: intltool-update: command not found
  checking for intltool >= 0.22...  found
  configure: error: Your intltool is too old.  You need intltool 0.22 or later.

  $ apt-cache search intltool
  intltool - Utility scripts for internationalizing XML
  intltool-debian - Help i18n of RFC822 compliant config files
  $ sudo apt-get install intltool
  intltool         intltool-debian
  $ sudo apt-get install intltool
#+END_EXAMPLE

#+BEGIN_EXAMPLE
checking for ENCHANT... no
configure: error: Enchant library not found or too old. Use --disable-spell to build without spell plugin.
$ sudo apt-get install libenchant-dev
#+END_EXAMPLE

#+BEGIN_EXAMPLE
configure: error: Gucharmap library not found or too old. Use --disable-gucharmap to build without gucharmap plugin
$ sudo apt-get install libgucharmap-2-90-de
$ ./configure --disable-gucharmap
#+END_EXAMPLE

#+BEGIN_EXAMPLE
checking festival.h... not found
configure: error: Festival library not found. Use --disable-festival to build without festival plugin.
#+END_EXAMPLE

好烦啊。。。

新得立

**** usage

***** 字典目录

字典目录： */usr/share/stardict/dic*, 可能可以通过某个环境变量进行设置

#+BEGIN_EXAMPLE
警告！没有加载任何词典。
请到星际译王的主页下载一些词典进行安装：
http://stardict.sourceforge.net并且把它们放到/usr/share/stardict/dic。
#+END_EXAMPLE

***** ~/.stardict

包含一些配置文件(*.cfg) 和 history 文件

*** gnuplot                                                       :gnuplot:
参考:
+ [[http://www.gnuplot.info/][gnuplot homepage]]
+ [[http://www.zhixing123.cn/ubuntu/draw-figures-and-store-using-gnuplot.html][gunplot入门]]

**** 基础篇
在linux命令提示符下运行gnuplot命令启动，输入quit或q或exit退出。
***** plot命令
1. 用线画，线的类型（包括颜色与虚线的类型）是3，线的宽度是2，对函数
   sin(x)作图

   #+header: :file /home/ben/tiger/figures/1503282122.pdf
   #+header: :exports code
   #+BEGIN_SRC gnuplot
     plot sin(x) with line linetype 3 linewidth 2
   #+END_SRC

   #+RESULTS:
   [[file:/home/wally/Wally/Journal/Figure/1503282122.pdf]]

   #+header: :file /home/ben/tiger/figures/1503282134.pdf
   #+header: :exports code
   #+BEGIN_SRC gnuplot
     plot sin(x) with line linetype 3 linewidth 2
   #+END_SRC

   注:在gnuplot中，如果某两个词， 按字母先后顺序，前面某几个字母相同，后
   面的不同，那么只要写到第一个不同的字母就可以了。如with，由于没有其它以
   w开头的词，因此可以用w代替，line也可以用l代替。

2. 用点画，点的类型（包括颜色与点的类型）是3，点的大小是2
   #+BEGIN_EXAMPLE
     plot sin(x) with point pointtype 3 pointsize 2
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     plot sin(x) w p pt 3 ps 2
   #+END_EXAMPLE

3. 同时用点和线画，这里title ‘f(x)’表示图例上标’f(x)’，如果不用则
   用默认选项
   #+BEGIN_EXAMPLE
     plot sin(x) title ‘f(x)’ w lp lt 3 lw 2 pt 3 ps 2
   #+END_EXAMPLE

4. 所有选项均用默认值。如果缺某一项则将用默认值
   #+BEGIN_EXAMPLE
     plot sin(x)
   #+END_EXAMPLE

5. 利用数据文件a.dat中的第二和第三列作图
   如果对数据文件作图，将函数名称换为数据文件名即可，但 *要用单引号引起来*.
   #+BEGIN_EXAMPLE
     plot ‘a.dat’ u 2:3  w l lt 3 lw 2
   #+END_EXAMPLE
***** 同时画多条曲线
两条曲线是用 *逗号隔开*,画多条曲线时，各曲线间均用逗号隔开就可以了。
#+BEGIN_EXAMPLE
  plot sin(x) title ‘sin(x)’ w l lt 1 lw 2, cos(x) title ‘cos(x)’  w l lt 2 lw 2
#+END_EXAMPLE

***** 图例位置
默认位置在右上方。
+ set key left         % 放在左边，有left 和right两个选项
+ set key bottom       % 放在下边，只有这一个选项；默认在上边
+ set key outside      % 放在外边，但只能在右面的外边
+ set key left bottom  % 组合使用,表示左下边
+ set key 0.5,0.6      % 指定精确位置

***** 坐标轴
+ set xlabel ‘x’   %x轴标为‘x’
+ set ylabel ‘y’   %y轴标为’y’
+ set ylabel ‘DOS’ tc lt 3  %其中的tc lt 3表示’DOS’的颜色用第三种颜色。
+ set xtics 1.0    %x轴的主刻度的宽度为1.0，同样可以为y轴定义ytics
+ set mxtics 3    %x轴上每个主刻度中画3个分刻度，同样可以为y轴定义mytics
+ set border 3 lt 3 lw 2 %设为第三种边界，颜色类型为3，线宽为2
  同样可以为上边的x轴（称为x2）和右边y（称为y2）轴进行设置，即x2tics，mx2tics，y2tics，my2tics。
+ set xtics nomirror
+ unset x2tics     %以上两条命令去掉上边x2轴的刻度
+ set ytics nomirror
+ unset y2tics     %以上两条命令去掉右边y轴的刻度

***** 在图中插入文字
#+BEGIN_EXAMPLE
  set label ‘sin(x)’ at 0.5,0.5  %在坐标（0.5,0.5）处加入字符串’sin(x)’。
#+END_EXAMPLE

在输出为.ps或.eps文件时，如果在set term 的语句中加入了enhanced选现，则
可以插入上下标、希腊字母和特殊符号。上下标的插入和latex中的方法是一样
的。

***** 在图中添加直线和箭头
#+BEGIN_EXAMPLE
  set arrow from 0.0,0.0 to 0.6,0.8    %从（0.0,0.0）到（0.6,0.8）画一个箭头
  set arrow from 0.0,0.0 to 0.6,0.8 lt 3 lw 2   % 设置线条颜色和线宽
  set arrow from 0.0,0.0 to 0.6,0.8 nohead  % 利用nohead可以去掉箭头的头部
#+END_EXAMPLE

注意，在gnuplot中，对于插入多个的label和arrow等等，系统会默认按先后顺
序分别对各个label或arrow进行编号，从1开始。如果以后要去掉某个label或
arrow，那么只要用unset命令将相应的去掉即可。如：
#+BEGIN_EXAMPLE
  unset arrow 2
#+END_EXAMPLE

***** 图的大小和位置
#+BEGIN_EXAMPLE
  %长宽均为默认宽度的一半，建议用这个取值，尤其是画成ps或eps图形的时候
  set size 0.5,0.5
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  %设定图的最左下角的那一点在图形面板中的位置。这里图将出现在左上角。
  set origin 0.0,0.5
#+END_EXAMPLE

***** 画三维图splot
#+BEGIN_EXAMPLE
  splot ‘文件名’ u 2:4:5  %以第二和第四列作为x和y坐标，第五列为z坐标。
#+END_EXAMPLE

***** 将图形输出到文件
+ 在gnuplot中，输出文件的格式是由terminal来控制的。
+ 默认的情况下，都是输出到屏幕，即终端模式为X11。
+ 如果想输出到文件，则必须对 terminal进行设置。要了解有那些终端类型，
  可以输入 set terminal后回车，所有支持的终端模式（或文件格式）都列出
  来了。
+ 输出文件的格式用得最多的是ps和eps文件。这在运行画图
  命令 plot或splot前必须先运行如下两条命令：

#+BEGIN_EXAMPLE
  set term post eps color solid enh
  set output ‘a.eps’
#+END_EXAMPLE

其中第一条命令为设置终端模式
+ post即为postscript模式，这是 *输出到ps或eps文件必须有的*
+ eps表示输出为eps文件，没有就输出为ps文件
+ 后面的eps，color，solid以及 enh选项均可以有或没有
  - color表示输出图形为彩色，不用就会保存为黑白的
  - solid表示输出图中的所有线都用实线，不用则除了第一条线为实线外，其
    它的均用不同的虚线
  - 使用enh(enhanced)选项可以在图中插入上 下标、希腊字母和特殊符号，不
    用则不能实现这些功能。

第二条命令对output的设置表示要输出的文件的名字。
*注，运行完这条命令后，还仅仅是定义了输出文件的名字，图还没画到这个文
件里去*
因此运行这两条命令还只是进行了必须的设置。然后运行如下命令
#+BEGIN_EXAMPLE
  gnuplot>plot sin(x) w l
#+END_EXAMPLE
或
#+BEGIN_EXAMPLE
  gnuplot>replot
#+END_EXAMPLE

这时，图形就在上面指定的文件中了。
要输出为其它格式，同样要进行这样的设置，比如要输出为jpg格式，则在运行
画图命令前先运行如下命令：
#+BEGIN_EXAMPLE
  gnuplot>set term jpeg
  gnuplot>set output ‘a.jpg’
#+END_EXAMPLE

如果要由其它模式再返回到输出到屏幕，则运行如下命令：
#+BEGIN_EXAMPLE
  gnuplot>set term X11
#+END_EXAMPLE
**** HALT 提高篇

***** 如何在同一张图里同时画多个图
#+BEGIN_EXAMPLE
  gnuplot>set multiplot   %设置为多图模式
  gnuplot>set origin 0.0,0.5   %设置第一个图的原点的位置
  gnuplot>set size 0.5,0.5  %设置第一个图的大小
  gnuplot>plot “a1.dat”
  gnuplot>set origin 0.5,0.5   %设置第二个图的原点的位置
  gnuplot>set size 0.5,0.5   %设置第二个图的大小
  gnuplot>plot “a2.dat”
  gnuplot>set origin 0.0,0.0   %设置第三个图的原点的位置
  gnuplot>set size 0.5,0.5  %设置第三个图的大小
  gnuplot>plot “a3.dat”
  gnuplot>set origin 0.5,0.0   %设置第四个图的原点的位置
  gnuplot>set size 0.5,0.5  %设置第四个图的大小
  gnuplot>plot “a4.dat”
#+END_EXAMPLE

当然，如果后一个图中的某个量的设置和前一个的相同，那么后一个中的这个量
的设置可以省略。例如上面对第二、第三和第四个图的大小的设置。
+ 前一个图中对某个量的设置也会在后一个图中起作用。
+ 如果要取消在后面图中的作用，必须用命令unset

#+BEGIN_EXAMPLE
  unset label
#+END_EXAMPLE
***** 作二维图时，如何使两边坐标轴的单位长度等长
#+BEGIN_EXAMPLE
  set size square    %使图形是方的
  set size 0.5,0.5    %使图形是你要的大小
  set xrange[-a:a]
  set yrange[-a:a]    %两坐标轴刻度范围一样
  plot ‘a.dat’
#+END_EXAMPLE


**** [[http://www.zhixing123.cn/ubuntu/draw-figures-and-store-using-gnuplot.html][gnuplot绘制图像并保存]]                                          :blog:


对于在Linux下工作的人，如果你经常要画一些二维图和简单的三维图的话，那么，gnuplot无疑是一个非常好的选择，不仅图形漂亮，而且操作简单。当然如果需要质量更高的三维图，请用其他的一些专业绘图软件。建议大家学会使用gnuplot。这个小软件通常都是Redhat Linux自带的，但自带的版本是3.7的，建议将其升级到4.0，新版本具有很多新功能。最新版本可以到http://www.gnuplot.info/下载。
一些最基本的操作请大家看说明书。这里总结一下我在使用过程中遇到的一些问题以及解决的办法，目的是让那些以前不会的或不熟练的能快速入门，会画自己想要 的图，因为原来的说明书很长，较难有针对性地很快找到自己想要的信息。这里简单的总结不可能面面俱到，所以大家不要抱怨我写的不全，更全面的了解还是请看 说明书，网上的资料也多的是。其实这也是我们从网上一点一点搜集和摸索出来的。我相信看完后，应该平时最常见的问题基本上都能在这里找到答案。如果大家在 使用过程中摸索到了我没有写到的技巧和体会，或有其它建议，请大家提告诉我，以不断完善这篇总结，谢谢！
一、基础篇
在linux命令提示符下运行gnuplot命令启动，输入quit或q或exit退出。
1、plot命令
gnuplot> plot sin(x) with line linetype 3 linewidth 2 或
gnuplot> plot sin(x) w l lt 3 lw 2    %用线画，线的类型（包括颜色与虚线的类型）是3，线的宽度是2，对函数sin(x)作图
gnuplot> plot sin(x) with point pointtype 3 pointsize 2  或
gnuplot> plot sin(x) w p pt 3 ps 2    %用点画，点的类型（包括颜色与点的类型）是3，点的大小是2
gnuplot> plot sin(x) title ‘f(x)’ w lp lt 3 lw 2 pt 3 ps 2    %同时用点和线画，这里title ‘f(x)’表示图例上标’f(x)’，如果不用则用默认选项
gnuplot> plot sin(x)    %此时所有选项均用默认值。如果缺某一项则将用默认值
gnuplot> plot ‘a.dat’ u 2:3  w l lt 3 lw 2 %利用数据文件a.dat中的第二和第三列作图
顺便提一下，如这里最前面的两个例子所示，在gnuplot中，如果某两个词，按字母先后顺序，前面某几个字母相同，后面的不同，那么只要写到第一个不同的字母就可以了。如with，由于没有其它以w开头的词，因此可以用 w 代替，line也可以用 l 代替。
2、同时画多条曲线
gnuplot> plot sin(x) title ‘sin(x)’ w l lt 1 lw 2, cos(x) title ‘cos(x)’  w l lt 2 lw 2  ％两条曲线是用逗号隔开的。画多条曲线时，各曲线间均用逗号隔开就可以了。
以上例子中是对函数作图，如果对数据文件作图，将函数名称换为数据文件名即可，但要用单引号引起来。
3、关于图例的位置
默认位置在右上方。
gnuplot> set key left  %放在左边，有left 和right两个选项
gnuplot> set key bottom  %放在下边，只有这一个选项；默认在上边
gnuplot> set key outside  %放在外边，但只能在右面的外边
以上三个选项可以进行组合。如：
gnuplot> set key left bottom  %表示左下边
还可以直接用坐标精确表示图例的位置，如
gnuplot> set key 0.5,0.6  %将图例放在0.5,0.6的位置处
4、关于坐标轴
gnuplot> set xlabel ‘x’   %x轴标为‘x’
gnuplot> set ylabel ‘y’   %y轴标为’y’
gnuplot> set ylabel ‘DOS’ tc lt 3  %其中的tc lt 3表示’DOS’的颜色用第三种颜色。
gnuplot> set xtics 1.0    %x轴的主刻度的宽度为1.0，同样可以为y轴定义ytics
gnuplot> set mxtics 3    %x轴上每个主刻度中画3个分刻度，同样可以为y轴定义mytics
gnuplot> set border 3 lt 3 lw 2 %设为第三种边界，颜色类型为3，线宽为2
同样可以为上边的x轴（称为x2）和右边y（称为y2）轴进行设置，即x2tics，mx2tics，y2tics，my2tics。
gnuplot> set xtics nomirror
gnuplot> unset x2tics     %以上两条命令去掉上边x2轴的刻度
gnuplot> set ytics nomirror
gnuplot> unset y2tics     %以上两条命令去掉右边y轴的刻度
5、在图中插入文字
gnuplot> set label ‘sin(x)’ at 0.5,0.5  %在坐标（0.5,0.5）处加入字符串’sin(x)’。
在输出为.ps或.eps文件时，如果在set term 的语句中加入了enhanced选现，则可以插入上下标、希腊字母和特殊符号。上下标的插入和latex中的方法是一样的。
6、在图中添加直线和箭头
gnuplot> set arrow from 0.0,0.0 to 0.6,0.8    %从（0.0,0.0）到（0.6,0.8）画一个箭头
gnuplot> set arrow from 0.0,0.0 to 0.6,0.8 lt 3 lw 2   %这个箭头颜色类型为3，线宽类型为2
gnuplot> set arrow from 0.0,0.0 to 0.6,0.8 nohead lt 3 lw 2  %利用nohead可以去掉箭头的头部，这就是添加直线的方法。
注意，在gnuplot中，对于插入多个的label和arrow等等，系统会默认按先后顺序分别对各个label或arrow进行编号，从1开始。如果以后要去掉某个label或arrow，那么只要用unset命令将相应的去掉即可。如：
gnuplot> unset arrow 2
将去掉第二个箭头。
7、图的大小和位置
gnuplot>set size 0.5,0.5  %长宽均为默认宽度的一半，建议用这个取值，尤其是画成ps或eps图形的时候
gnuplot>set origin 0.0,0.5   %设定图的最左下角的那一点在图形面板中的位置。这里图将出现在左上角。
8、画三维图
gnuplot>splot ‘文件名’ u 2:4:5  %以第二和第四列作为x和y坐标，第五列为z坐标。
9．将图形输出到文件
在gnuplot中，输出文件的格式是由terminal来控制的。默认的情况下，都是输出到屏幕，即终端模式为X11。如果想输出到文件，则必须对 terminal进行设置。要了解有那些终端类型，可以输入 set terminal后回车，所有支持的终端模式（或文件格式）都列出来了。就我来说，输出文件的格式用得最多的是ps和eps文件。这在运行画图命令 plot或splot前必须先运行如下两条命令：
gnuplot>set term post eps color solid enh
gnuplot>set output ‘a.eps’
其中第一条命令为设置终端模式，post即为postscript模式，这是输出到ps或eps文件必须有的。后面的eps，color，solid以及 enh选项均可以有或没有，根据你的需要。eps表示输出为eps文件，没有就输出为ps文件；color表示输出图形为彩色，不用就会保存为黑白 的；solid表示输出图中的所有线都用实线，不用则除了第一条线为实线外，其它的均用不同的虚线；使用enh(enhanced)选项可以在图中插入上 下标、希腊字母和特殊符号，不用则不能实现这些功能。后面的选项可以根据自己的需要选择一个或几个。
第二条命令对output的设置表示要输出的文件的名字。但是请注意，运行完这条命令后，还仅仅是定义了输出文件的名字，实际上，图还没画到这个文件里去。因此运行这两条命令还只是进行了必须的设置。然后运行如下命令
gnuplot>plot sin(x) w l
或
gnuplot>replot（假如前面已经运行过plot或replot命令的话）
这时，图形就在上面指定的文件中了。
要输出为其它格式，同样要进行这样的设置，比如要输出为jpg格式，则在运行画图命令前先运行如下命令：
gnuplot>set term jpeg
gnuplot>set output ‘a.jpg’
如果要由其它模式再返回到输出到屏幕，则运行如下命令：
gnuplot>set term X11
二、提高篇
1、如何在同一张图里同时画多个图
gnuplot>set multiplot   %设置为多图模式
gnuplot>set origin 0.0,0.5   %设置第一个图的原点的位置
gnuplot>set size 0.5,0.5  %设置第一个图的大小
gnuplot>plot “a1.dat”
gnuplot>set origin 0.5,0.5   %设置第二个图的原点的位置
gnuplot>set size 0.5,0.5   %设置第二个图的大小
gnuplot>plot “a2.dat”
gnuplot>set origin 0.0,0.0   %设置第三个图的原点的位置
gnuplot>set size 0.5,0.5  %设置第三个图的大小
gnuplot>plot “a3.dat”
gnuplot>set origin 0.5,0.0   %设置第四个图的原点的位置
gnuplot>set size 0.5,0.5  %设置第四个图的大小
gnuplot>plot “a4.dat”
当然，如果后一个图中的某个量的设置和前一个的相同，那么后一个中的这个量的设置可以省略。例如上面对第二、第三和第四个图的大小的设置。前一个图中对某个量的设置也会在后一个图中起作用。如果要取消在后面图中的作用，必须用如下命令，如取消label，用
gnuplot>unset label
2、作二维图时，如何使两边坐标轴的单位长度等长
gnuplot> set size square    %使图形是方的
gnuplot> set size 0.5,0.5    %使图形是你要的大小
gnuplot> set xrange[-a:a]
gnuplot> set yrange[-a:a]    %两坐标轴刻度范围一样
gnuplot> plot ‘a.dat’
3、如何在同一张图里利用左右两边的y轴分别画图
gnuplot> set xtics nomirror   %去掉上面坐标轴x2的刻度
gnuplot> set ytics nomirror   %去掉右边坐标轴y2的刻度
gnuplot> set x2tics       %让上面坐标轴x2刻度自动产生
gnuplot> set y2tics     %让右边坐标轴y2的刻度自动产生
gnuplot> plot sin(x),cos(x) axes x1y2    %cos(x)用x1y2坐标，axes x1y2表示用x1y2坐标轴
gnuplot> plot sin(x),cos(x) axes x2y2     %cos(x)用x2y2坐标，axes x2y2表示用x2y2坐标轴
gnuplot> set x2range[-20:20]   %设定x2坐标的范围
gnuplot> replot
gnuplot> set xrange[-5:5]  %设定x坐标的范围
gnuplot> replot
gnuplot> set xlabel ‘x’
gnuplot> set x2label ‘t’
gnuplot> set ylabel ‘y’
gnuplot> set y2label ‘s’
gnuplot> replot
gnuplot> set title ‘The figure’
gnuplot> replot
gnuplot> set x2label ‘t’ textcolor lt 3    %textcolor lt 3或tc lt 3设置坐标轴名称的颜色
4、如何插入希腊字母和特殊符号
一般只能在ps和eps图中，且必须指定enhanced选项。在X11终端（即显示器）中无法显示。
gnuplot> set terminal postscript enhanced
然后希腊字母就可以通过{/Symbol a}输入。例如
gnuplot> set label ‘{/Symbol a}’
各种希腊字母与特殊符号的输入方法请见安装包中gnuplot-4.0.0/docs/psdoc目录下的ps_guide.ps文件。
另外还可参见：
http://t16web.lanl.gov/Kawano/gnuplot/label-e.html#4.3
5、gnuplot中如何插入Angstrom（埃）这个符号(A上面一个小圆圈)
脚本中在插入前先加入
gnuplot>set encoding iso_8859_1
这个命令，然后就可以通过“{\305}”加入了。如横坐标要标上“k(1/?)”：
gnuplot>set xlabel ‘k(1/{\305})
如果是multiplot模式，则这个命令必须放在
gnuplot>set multiplot
的前面。
如果后面还要插入别的转义字符，那么还要在插入字符后加入如下命令：
set encoding default
安装包中gnuplot-4.0.0/docs/psdoc/ps_guide.ps文件中的表中的‘E’代表那一列的所有符号都用这个方法输入。
6、gnuplot画等高线图
gnuplot>splot  ‘文件名.dat’  u 1:2:3  w  l   %做三维图
gnuplot>set dgrid3d 100,100 %设置三维图表面的网格的数目
gnuplot>replot
gnuplot>set contour    %设置画等高线
gnuplot>set cntrparam  levels  incremental -0.2,0.01,0.2   %设置等高线的疏密和范围，数据从   -0.2到0.2中间每隔0.01画一条线
gnuplot>unset surface   去掉上面的三维图形
最后用鼠标拽动图形，选择合理的角度即可。或者直接设置(0,0)的视角也可以：
gnuplot>set view 0,0
gnuplot>replot
这里注意，画三维图的数据文件必须是分块的，也就是x每变换一个值，y在其变化范围内变化一周，这样作为一块，然后再取一个x值，y再变化一周，作为下一数据块，等等。块与块之间用一空行格开。
7、如何画漂亮的pm3d图
gnuplot> set pm3d                %设置pm3d模式
gnuplot> set isosamples 50,50       %设置网格点
gnuplot> splot x**2+y**2          ％画三维图
gnuplot> splot x**2+y**2 w pm3d   ％画成pm3d模式，注意比较变化
gnuplot> set view 0,0              ％设置视角，（0，0）将投影到底面上去
gnuplot> splot x**2+y**2 w pm3d   ％重画，注意看变化
gnuplot> unset ztics               %把z轴上的数字给去掉
gnuplot> set isosamples 200,200     ％使网格变细
gnuplot> replot                   ％重画，注意看变化，主要是过渡更光滑
8、利用脚本文件避免重复输入
有时候对某个数据文件做好一张图后，下次可能还要利用这个数据文件作图，但某个或某些设置要作些细微变化。这时候，可以把第一次作图时的命令全部写到一个文件里，如a.plt，下次只要将相应的设置做修改后，用下面的命令就会自动运行文件所有的命令而最后得到你要的图：
gnuplot>load ‘a.plt’
作为一个例子，假设文件名为a.plt，里面的内容为：
set pm3d
set view 0,0
unset ztics
set isosamples 200,200
splot x**2+y**2 w pm3d
set term post color
set output ‘a.ps’
replot
那么启动gnuplot后，只要运行如下命令就可以了：
gnuplot>load ‘a.plt’
如果我们要得到的仅仅是.ps或.eps图，那也可以在linux命令提示符下直接运行如下命令：
[zxh@theory zxh]$gnuplot a.plt
9、在gnuplot模式下运行linux命令
在gnuplot提示符下也可以运行linux命令，但必须在相应的命令前面加上 ! 号。例如，假设很多参量都已经设置好了，但需要对某个数据文件a.dat进行修改后再画图，则可以用如下方式
gnuplot>!vi a.dat
通过这种方式，所有的linux命令都可以在gnuplot环境里运行。
另外，也可以在gnuplot的提示符后输入shell，暂时性退出gnuplot，进入linux环境，做完要做的事情后，运行exit命令，又回到gnuplot环境下。
gnuplot>shell
[zxh@theory zxh]$vi a.f
[zxh@theory zxh]$f77 a.f
[zxh@theory zxh]$a.out    (假设生成a.dat数据文件)
[zxh@theory zxh]$exit
gnuplot>plot ‘a.dat’

*** [[~/Document/Reference/Manual/LedgerManual.pdf][ledger]]                                                         :ledger:

**** 查阅 Ledger /是否支持加减运算/ ，                              :math:

手册没有细读。 但通过尝试得出了结果： /可以，但要用括号括起/

*inline math requires parentheses*

#+BEGIN_EXAMPLE
  tmp $ ledger -f foo.ledger balance
  While parsing file "/tmp/foo.ledger", line 6:
  While parsing posting:
    Expsense:Food  12+3
                   ^^^^
  Error: Unexpected char '+' (Note: inline math requires parentheses)

  tmp $ gedit foo.ledger

  tmp $ ledger -f foo.ledger balance
                    22  Assets:Cash
                   -37  Equity:Opening Balances
                    15  Expsense:Food
  --------------------
                     0
#+END_EXAMPLE

**** Manual
***** file structure
****** At the highest you have five sorts of accouts

+ *Assets*: where money sits
+ *Liabilities*: money you oew
+ *Income*: where money comes from
+ *Expense*: where money goes
+ *Equity*: the real value of your property

****** Beneath these top level

e.g.  Expenses:Food:Hamburgers and Fries

****** Commenting

1. /;/ (usually)
2. four additional
   1) %
   2) #
   3) |
   4) *
***** command                                                       :cmd:
****** Balance Report

*ledger -f account.ledger balance*
*ledger -f account.ledger Assets Liabilites*

****** Register Report

*ledger -f account.ledger register*
*ledger -f account.ledger register Grocereis*
*ledger -f account.ledger register payee "Organic"*

*** ditaa                                                           :ditaa:
**** Referecne

+ [[http://blog.csdn.net/cuijianzhongswust/article/details/8296159][CSDN blog]]
+ [[http://emacser.com/emacs-ditaa.htm][emacer中文网]]
+ [[http://ditaa.sourceforge.net/#download][ditaa homepage]]
+ [[http://doc.norang.ca/org-mode.html#playingwithditaa][org brief manual]]

**** installation                                                :install:

依赖 java, 要安装好多库

#+BEGIN_EXAMPLE
$ sudo apt-get install ditaa
#+END_EXAMPLE

**** ditaa简介

Emacs处理图片

+ LaTeX 的排版与图片功能相当强大,门槛高,使用复杂,主要用在科学论文.
+ graphviz
+ ACSII图

ditaa is a small command-line utility written in Java, that can convert
diagrams drawn using ascii art ('drawings' that contain characters that
resemble lines like | / - ), into proper bitmap graphics.

Emacs中有两个mode用于处理ASCII图,picture-mode和 *artist-mode*

e.g. 框图
#+BEGIN_EXAMPLE
+----------+ edit +----------+   input +----------+ compile +----------+
| refined  |<-----+ h,cpp    +-------->+ compiler,+-------->+Executable|
|   h,c.p  ..     |          |         | linker   |         |   File   |
+-------. .....   +----+-----+         +----------+         +----------+
                       | input
                       v
                  +----------+
                  | doxygen  |
                  |          |
                  +----+-----+
                       | process
                       v
                  +----------+
                  | Doxgen   |
                  | Document |
                  +----------+
#+END_EXAMPLE

**** Command line

*java -jar ditaa0_9.jar*

选项:

|----+-----------------------+-----------------------------------------------------------------|
| -A | --no-antialias        | turn off anti-aliasing                                          |
| -d | --debug               | Renders the debug grid over the resulting image                 |
| -E | --no-sepatation       | prevent the sepatation of the common edges of shapes            |
| -e | --encoding <ENCODING> | the encoding of the input file                                  |
| -h | --html                | the input is an HTML file                                       |
| -o | --overwrite           | overwrite existing file                                         |
| -r | --round-corners       | cause all corners to be renders as round corners                |
| -s | --scale <SCALE>       | a natural number that determines the size of the rendered image |
| -S | --no-shadows          | turn off the drop-shadow effect                                 |
| -t | --tabs <TABS>         |                                                                 |
| -v | --verbose             | makes ditaa more verbose                                        |
|----+-----------------------+-----------------------------------------------------------------|

e.g. -E --no-seperation
#+header: :file ~/Wally/Journal/Figure/ditaa/2012.png
#+header: :exports none
#+BEGIN_SRC ditaa
  +---------+
  | cBLU    |
  |         |
  |    +----+
  |    |cPNK|
  +----+----+
#+END_SRC

#+RESULTS:
[[/home/wally/Wally/Journal/Figure/201502051611.png]]

**** Syntax

***** Round corners

If you use / and \ to connect corners, they are rendered as round
corners.

#+BEGIN_EXAMPLE
  /--+
  |  |
  +--/
#+END_EXAMPLE

/home/wally/Wally/Journal/Figure/201502051558.png

***** Color

*cXXX* is the syntax of color codes, where XXX is a hex number.XXX
respectively represent the compoment of the red,green and blue(RGB)

#+BEGIN_EXAMPLE
  /----+----\
  |c33F+cC02|
  +----+----+
  |c1FF+c1AB|
  \----+----/
#+END_EXAMPLE

/home/wally/Wally/Journal/Figure/201502051550.png


There are some human readable color codes provided: cRED, cBLU,
cGRE,cPNK, cBLK, cYEL.

#+BEGIN_EXAMPLE
  /--------+---------\
  |cRED RED|cBLU BLU |
  +--------+---------+
  |cGRE GRE+cPNK PNK |
  +--------+---------+
  |cBLK BLK+cYEL YEL |
  \--------+---------/
#+END_EXAMPLE

/home/wally/Wally/Journal/Figure/201502051548.png

If a colored shape contains any text, the color of the text is
adjusted according to the underlying color.

***** Tags
ditaa recognises some tags that change the way a rectangular shape is
rendered. All tags are between { and }.

1. {d} : symbol representing a document
   #+header: :file /home/wally/Wally/Journal/Figure/201502051619.png
   #+header: :exports none
   #+BEGIN_SRC ditaa
     +---+
     |{d}|
     +---+
   #+END_SRC

   #+RESULTS:
   [[file:/home/wally/Wally/Journal/Figure/201502051619.png]]

2. {s} : symbol representing a form of storage

   #+header: :file /home/wally/Wally/Journal/Figure/201502051645.png
   #+header: :exports none
   #+BEGIN_SRC ditaa
     +---+
     |{s}|
     +---+
   #+END_SRC

   #+RESULTS:
   [[file:/home/wally/Wally/Journal/Figure/201502051645.png]]

3. {io} : symbol representing input/output

   #+header: :file /home/wally/Wally/Journal/Figure/201502051649.png
   #+header: :exports none
   #+BEGIN_SRC ditaa
     +-----+
     | {io}|
     +-----+
   #+END_SRC

   #+RESULTS:
   [[file:/home/wally/Wally/Journal/Figure/201502051649.png]]

***** Dashed lines

Any lines that contain either at least one = (for horizontal lines) or
at least one : (for vertical lines) are rendered as dashed lines.

#+header: :file /home/wally/Wally/Journal/Figure/201502051655.png
#+header: :exports none
#+BEGIN_SRC ditaa
  ----+ /---\ +---+
      : |   | :   |
      | |   | |{s}|
      v \-=-/ +---+
#+END_SRC

#+RESULTS:
[[file:/home/wally/Wally/Journal/Figure/201502051655.png]]

***** Point markers
If * is encountered on a line (but not at the end of the line), it is
rendered as a special marker, called the point marker.

#+header: :file ~/Wally/Journal/Figure/ditaa/201601112012.png
#+header: :exports none
#+BEGIN_SRC ditaa
  ,*----*
  |    |    /--*
  ,*    *    |
  |    | -*-+
  ,*----*
#+END_SRC

#+RESULTS:
[[file:/home/wally/Wally/Journal/Figure/201502051700.png]]


***** Text handling
If the pattern 'o XXXX' is encountered, where XXXX is any text, the
'o' is interpreted and rendered as a bullet point.Note that there must
be a space before the 'o' as well as after it.

#+header: :file ~/Wally/Journal/Figure/ditaa/201601112014.png
#+header: :exports none
#+BEGIN_SRC ditaa
  /-----------------\
  | Things to do    |
  | cGRE            |
  | o Cut the grass |
  | o Buy jam       |
  | o Fix car       |
  | o Make website  |
  \-----------------/
#+END_SRC

#+RESULTS:
[[file:/home/wally/Wally/Journal/Figure/201502051705.png]]

****  中文,babel控制ditaa选项


:file 文件名
:cmdline -r -s 0.5

**** [[http://yanue.net/post-117.html][dia在Linux(ubuntu)下无法输入中文的解决办法]]                     :blog:

// 发表于 2013-08-29 09:54 -
[[http://yanue.net/post-117.html#comments][// 0条评论]]   // 2966
次浏览   所属分类：[[http://yanue.net/topic/ubuntu.html][Ubuntu]]

我是执行一下命令安装的

#+BEGIN_EXAMPLE
    sudo apt-get install dia
#+END_EXAMPLE

打开软件后发现不能输入中文，网上搜索一圈后找到以下解决方案

#+BEGIN_EXAMPLE
     sudo vi /usr/bin/dia
#+END_EXAMPLE

然后把dia-gnome --integrated "$@"修改成

#+BEGIN_EXAMPLE
     dia-gnome  "$@"
#+END_EXAMPLE

重新启动dia，输入法选择系统默认（我的系统输入法是ibus），就可以输入中文了不过这样一改，工具条变成浮动的了

另外，发现windows下dia，默认也是不能输入中文的，

解决办法倒是简单些：dia的输入法菜单里选择“简单”，就可以输入中文了

xp系统搜狗输入法下测试成功

*** OGRE

+ http://zh.wikipedia.org/wiki/OGRE
+ http://www.ogre3d.org/
+ http://baike.baidu.com/subview/104836/15875123.htm#viewPageContent


OGRE（Object-Oriented Graphics Rendering Engine，面向对象图形渲染引擎）
又叫做OGRE 3D。OGRE是面向场景的、灵活的图像引擎。OGRE仍然在发展中，如
果就功能和商业游戏引擎还有一定差距。

开源

Gazebo使用OGRE作为渲染的引擎。

*** QGIS wiki

+ Wiki: http://zh.wikipedia.org/wiki/QGIS

QGIS（原称Quantum GIS）是一个自由软件的桌面GIS软件。它提供数据的显示、
编辑和分析功能。

QGIS以C++写成，它的GUI使用了Qt库。QGIS允许集成使用C++ 或Python写成的插
件。除了Qt之外，QGIS需要的依赖还包括GEOS和SQLite。同时也推荐安装GDAL、
GRASS GIS、PostGIS和PostgreSQL。

QGIS是一个多平台的应用，可以在多种操作系统上运行，包括Mac OS X、Linux、
UNIX和Microsoft Windows。对于Mac用户，QGIS相对于GRASS GIS的优势在于它
不需要X11窗口系统，而且界面更简洁、快速。Quantum GIS也可以作为GRASS的
图形用户界面使用。相较于商业GIS，Quantum GIS的文件体积更小，需要的内存
和处理能力也更少。因此它可以在旧的硬件上或CPU运算能力被限制的环境下运
行。

QGIS是基于GPL发布的自由软件.

*** rst                                                               :rst:

http://blog.useasp.net/archive/2014/09/05/rst-file-restructuredtext-markup-syntax-quikstart.aspx
http://blog.useasp.net/archive/2014/09/06/the-shortcut-talbe-for-emacs-reStructuredText-mode-rst-mode.aspx

reStructuredText是一种轻量级的文本标记语言，直译为：重构建的文本，为
Python中Docutils项目的一部分。其一般保存的文件以.rst为后缀。在必要的时
候，.rst文件可以被转化成PDF或者HTML格式，也可以有Sphinx转化为LaTex,man
等格式，现在被广泛的用于程序的文档撰写。
**** 小结
1. rst: reStructuredText的缩写
2. 后缀名rst
3. 一种标记语言，和org-mode与markdown相似

*** Linux 知网

**** wine安装知网阅读软件
源码安装的wine安装CAJviewer没有问题，使用时出现 unable to create a
MSXML instance错误

可能是缺少微软库依赖。ArchLinux查得 Some applications (e.g. Office
2003/2007) require the MSXML library to parse HTML or XML, in such
cases you need to install
lib32-libxml2. https://wiki.archlinux.org/index.php/Wine

但libxml2已经安装

卸载源码安装的wine，使用apt-get方式安装后，问题解决。

**** caj to pdf
+ http://www.zhihu.com/question/21103230


1. 虚拟打印机转换为pdf或xps格式
2. 少瞎折腾

为什么不直接下载PDF，可以从 *万方* 上直接下载PDF

*** surfraw                                                :surfraw:google:

*Surfraw* (Shell Users Revolutionary Front Rage Against the Web) is a
free POSIX-compliant (i.e. meant for Linux, FreeBSD etc.)
/command-line shell program/ for _interfacing with a number of
web-based search engines_

**** usages

1. list of elvi

   #+BEGIN_EXAMPLE
   surfraw -elvi
   #+END_EXAMPLE

2. search

   #+BEGIN_EXAMPLE
   sr elviname [options] serach-items
   #+END_EXAMPLE

   会自动打开外部浏览器并跳转至搜索结果。

**** elvi

+ google
+ github
+ youtube
+ wikipedia

**** bookmarks

1. cfg files

   - /etc/surfraw.bookmarks
   - $HOME/.surfraw.bookmarks

2. format:  each bookmark is on a separate line, with the bookmark and
   URL separated by whitespace

   #+BEGIN_EXAMPLE
   ntk http://www.ntk.net/
   #+END_EXAMPLE

3. invoke

   #+BEGIN_EXAMPLE
   sr <bookmark>
   #+END_EXAMPLE

**** configures

- Environment variables
- /etc/surfraw.conf
- $HOME/.surfraw.conf

**** files

Files

- $(libdir)/surfraw  Location of the elvi.
- /etc/surfraw.conf  Default system wide configuration file.
- $HOME/.surfraw.conf  Default per-user config file
- /etc/surfraw.bookmarks  System wide bookmarks file.
- $HOME/.surfraw.bookmarks  Per-user bookmarks file.

**** google

#+BEGIN_EXAMPLE
http://ipv6.google.com/sorry/IndexRedirect?continue=http://www.google.com/search%3Fq%3Dlinux%26num%3D30&q=CGMSECQAiQAAAAAA8DyR__7IkBQYk-biswUiGQDxp4NLyvCCDIQpTbTt9O576MfPHgN86v0
#+END_EXAMPLE

**** reference

+ [[http://surfraw.alioth.debian.org/][Homepage]]
+ [[https://en.wikipedia.org/wiki/Surfraw][Wiki]]

.
**** [[http://surfraw.alioth.debian.org/][sufraw man]]                                     :surfraw:man:homepage:

#+BEGIN_EXAMPLE
               ______  _     _  ______   _______  ______   _______  _  _  _
              / _____)(_)   (_)(_____ \ (_______)(_____ \ (_______)(_)(_)(_)
             ( (____   _     _  _____) ) _____    _____) ) _______  _  _  _
              \____ \ | |   | ||  __  / |  ___)  |  __  / |  ___  || || || |
              _____) )| |___| || |  \ \ | |      | |  \ \ | |   | || || || |
             (______/  \_____/ |_|   |_||_|      |_|   |_||_|   |_| \_____/
             Surfraw - Shell Users' Revolutionary Front Rage Against the Web
#+END_EXAMPLE

***** About Surfraw

Surfraw provides a fast unix command line interface to a variety of
popular WWW search engines and other artifacts of power. It reclaims
google, altavista, babelfish, dejanews, freshmeat, research index,
slashdot and [[#elvilist][many others]] from the false-prophet,
pox-infested heathen lands of html-forms, placing these wonders where
they belong, deep in unix heartland, as god loving extensions to the
shell.

Surfraw abstracts the browser away from input. Doing so lets it get on
with what it's good at. Browsing. Interpretation of linguistic forms is
handed back to the shell, which is what it, and human beings are good
at. Combined with
[[http://wp.netscape.com/newsref/std/x-remote.html][netscape-remote]] or
incremental text browsers, such as [[http://lynx.isc.org][lynx]],
[[http://artax.karlin.mff.cuni.cz/~mikulas/links/][links]] or
[[http://www.w3m.org][w3m]], along with
[[http://freshmeat.net/projects/screen/][screen]] a Surfraw liberateur
is capable of navigating speeds that leave GUI tainted idolaters agape
with fear and wonder.

For example:

#+BEGIN_EXAMPLE
             $ surfraw google -results=100 RMS, GNU, which is sinner, which is sin?
             $ sr wikipedia surfraw
             $ sr austlii -method=phrase dog like
             $ /usr/lib/surfraw/rhyme -method=perfect Julian
#+END_EXAMPLE

--------------

***** Installation

****** Source Tarball

Unpack the source with

=gzip -dc surfraw-2.2.9.tar.gz | tar xvvf -=

Then, change into the =surfraw-2.2.9= directory, and type

=./configure=

=make=

then, as root,

=make install=

This will install surfraw into =/usr/local/=

For more detailed installation instructions, see the [[INSTALL]] file
that is part of the surfraw distribution.

Note that the opensearch elvis depends on the perl libraries
[[http://search.cpan.org/search?query=WWW%3A%3AOpenSearch&mode=all][WWW::OpenSearch]],
[[http://search.cpan.org/search?query=HTML%3A%3AParser&mode=all][HTML::Parser]]
and [[http://search.cpan.org/search?query=LWP&mode=all][LWP
(libwww-perl)]]. If you don't want to install opensearch, use

#+BEGIN_EXAMPLE
    ./configure --disable-opensearch
#+END_EXAMPLE

****** Debian Binary Package

To install the [[http://packages.qa.debian.org/s/surfraw.html][version]]
in your [[http://www.debian.org/][Debian]] distribution, as root, type:

=apt-get install surfraw surfraw-extra=

To install the .deb files directly, as root, type:

=dpkg -i surfraw_2.2.9-1_all.deb  surfraw-extra_2.2.9-1_all.deb=

Note that calling =dpkg= directly does not automatically install
dependencies, and surfraw-extra in particular has many dependencies, so
it is best to stick with =apt-get install= where possible.

****** Debian source package

First you need to ensure you have the necessary packages installed to
successfully build surfraw.

The following commands (run as root) should ensure you have everything
necessary to build surfraw:

= apt-get install build-essential fakeroot apt-get build-dep surfraw=

[[#downloading][Download]] the
[[dist/surfraw_2.2.9-1.dsc][surfraw\_2.2.9-1.dsc]],
[[dist/surfraw_2.2.9-1.diff.gz][surfraw\_2.2.9-1.diff.gz]] and
[[dist/surfraw_2.2.9.orig.tar.gz][surfraw\_2.2.9.orig.tar.gz]] files,
then type:

=dpkg-source -x surfraw_2.2.9-1.dsc=

This will unpack the source into a subdirectory called =surfraw-2.2.9=

Change into this directory, and type:

=fakeroot debian/rules binary=

This should produce files called =surfraw_2.2.9-1_all.deb= and
=surfraw-extra_2.2.9-1_all.deb= in the directory above the surfraw
source directory. To install these files, type as root:

=dpkg -i surfraw_2.2.9-1_all.deb surfraw-extra_2.2.9-1_all.deb=

--------------

***** List of Elvi

Surfraw contains the following web site search scripts (/elvi/)

| *S*                | Search using custom search provider                                                    |
| *W*                | Activate Surfraw defined web-browser                                                   |
| *acronym*          | Look for acronyms definitions (www.acronymfinder.com)                                  |
| *ads*              | Search SAO/NASA Astrophysics Data System                                               |
| *alioth*           | Search Alioth (alioth.debian.org)                                                      |
| *amazon*           | Search the amazon.com bookstore                                                        |
| *archpkg*          | Search Arch Linux Packages (www.archlinux.org/packages/)                               |
| *archwiki*         | Search the Arch Linux Wiki                                                             |
| *arxiv*            | Search arXiv E-Print Archive for articles                                              |
| *ask*              | Question the web using Ask Jeeves (www.ask.com)                                        |
| *aur*              | Search aur.archlinux.org for PKGBUILDs                                                 |
| *austlii*          | Search Australian Law docs (www.austlii.edu.au)                                        |
| *bbcnews*          | Search BBC News (news.bbc.co.uk)                                                       |
| *bing*             | Search the web using Microsoft's Bing (www.bing.com)                                   |
| *bookfinder*       | Search for books using www.bookfinder.com                                              |
| *bugmenot*         | Bypass compulsory web registration with bugmenot.com                                   |
| *bugzilla*         | Search for bugs on Bugzilla bugtrackers                                                |
| *cablesearch*      | search for leaked diplomatic communications                                            |
| *cia*              | Search CIA documents at www.cia.gov                                                    |
| *cisco*            | Search Cisco documentation (www.cisco.com)                                             |
| *cite*             | Search computer science papers (citeseerx.ist.psu.edu)                                 |
| *cliki*            | Search the common lisp wiki                                                            |
| *cnn*              | Search on CNN (cnn.com)                                                                |
| *comlaw*           | Search Australian Law using Comlaw (www.comlaw.gov.au)                                 |
| *ctan*             | Search the Comprehensive TeX Archive Network (ctan.org)                                |
| *currency*         | Convert currencies with the Universal Currency Converter (www.xe.net/ucc)              |
| *cve*              | Search for CAN assignments in CVE                                                      |
| *debbugs*          | Search the debian BTS (bugs.debian.org)                                                |
| *debcodesearch*    | Search debian source code                                                              |
| *debcontents*      | Search contents of debian/ubuntu packages (packages.debian.org/packages.ubuntu.com)    |
| *deblists*         | Search debian mailing lists (lists.debian.org/search.html)                             |
| *deblogs*          | Show changelogs for a package in Debian main (changelogs.debian.net)                   |
| *debpackages*      | Search debian/ubuntu packages (packages.debian.org/packages.ubuntu.com)                |
| *debpkghome*       | Visit the home page for a Debian package                                               |
| *debpts*           | Search the Debian Package Tracking System (packages.qa.debian.org)                     |
| *debsec*           | Search the Debian Security Tracker for CVE ids or package names                        |
| *debvcsbrowse*     | Browse the VCS repository for a Debian package                                         |
| *debwiki*          | Search the Debian Wikis (wiki.debian.org & women.debian.org/wiki)                      |
| *deja*             | Search usenet using Google Groups (groups.google.com)                                  |
| *deli*             | Search Delicious bookmarks                                                             |
| *discogs*          | Search the Discogs database of music information (www.discogs.com)                     |
| *dmoz*             | Search the Open Directory Project web directory (dmoz.org)                             |
| *duckduckgo*       | Securely search the web using duckduckgo (www.duckduckgo.com)                          |
| *ebay*             | Search the Ebay auction site                                                           |
| *etym*             | Look up word origins at www.etymonline.com                                             |
| *excite*           | Search on Excite (www.excite.com)                                                      |
| *f5*               | Search F5 related information (www.f5.com)                                             |
| *finkpkg*          | Search Fink packages (pdb.finkproject.org)                                             |
| *foldoc*           | The Free On-Line Dictionary Of Computing (foldoc.org)                                  |
| *freebsd*          | Search FreeBSD related information (www.freebsd.org)                                   |
| *freedb*           | Search for cd track listings in FreeDB (www.freedb.org)                                |
| *freshmeat*        | Search Freshmeat (www.freshmeat.net)                                                   |
| *fsfdir*           | Search the FSF/UNESCO Free Software Directory (directory.fsf.org)                      |
| *gcache*           | Search the web using Google cache (www.google.com)                                     |
| *genbugs*          | Search the Gentoo bug tracker (bugs.gentoo.org)                                        |
| *genportage*       | Search gentoo-portage.com for packages                                                 |
| *github*           | Search GitHub (https://github.com)                                                     |
| *gmane*            | Search mailing list with gmane (gmane.org)                                             |
| *google*           | Search the web using Google (www.google.com)                                           |
| *gutenberg*        | Search for books on Project Gutenberg (gutenberg.org)                                  |
| *imdb*             | Search the Internet Movie Database (www.imdb.com)                                      |
| *ixquick*          | Search the web using ixquick [HTTPS] (www.ixquick.com)                                 |
| *jamendo*          | Search Jamendo: free music with Creative Commons licenses (www.jamendo.com)            |
| *javasun*          | Search Java API docs (java.sun.com)                                                    |
| *jquery*           | Search the jQuery documentation (api.jquery.com)                                       |
| *l1sp*             | Search lisp documentation                                                              |
| *lastfm*           | Search last.fm                                                                         |
| *leodict*          | Search Leo's German <-> English dictionary (dict.leo.org)                              |
| *lsm*              | Search the Linux Software Map                                                          |
| *macports*         | Search macports packages (macports.org)                                                |
| *mathworld*        | Search Wolfram MathWorld                                                               |
| *mdn*              | Search the mozilla developer network (developer.mozilla.org)                           |
| *mininova*         | Search the mininova bittorent source.                                                  |
| *musicbrainz*      | Search MusicBrainz (musicbrainz.org)                                                   |
| *mysqldoc*         | Search mysql documentation (dev.mysql.com)                                             |
| *netbsd*           | Search NetBSD related information (www.netbsd.org)                                     |
| *ntrs*             | Search the NASA Technical Report Server                                                |
| *openbsd*          | Search OpenBSD related information (www.openbsd.org)                                   |
| *openports*        | search openports for OpenBSD packages                                                  |
| *opensearch*       | Search an OpenSearch-enabled website                                                   |
| *oraclesearch*     | Search Oracle (search.oracle.com)                                                      |
| *pasearch*         | Search the unofficial Penny Arcade archives (pipefour.org/pa)                          |
| *pgdoc*            | Search postgres documentation (www.pgdoc.com)                                          |
| *pgpkeys*          | Search the PGP key database                                                            |
| *phpdoc*           | Search PHP documentation (php.net)                                                     |
| *pin*              | Search Pinboard bookmarks (http://pinboard.in)                                         |
| *piratebay*        | Search The Pirate Bay (http://thepiratebay.org)                                        |
| *priberam*         | Look up word in Priberam online dictionary (www.priberam.pt/dlpo)                      |
| *pubmed*           | Search medical/molbio databases (www.ncbi.nlm.nih.gov)                                 |
| *rae*              | Busca en el diccionario de la Real Academia de la Lengua Española (Spanish Dictionary) |
| *rfc*              | Search RFCs (internet standards documents)                                             |
| *rhyme*            | Search for rhymes et al using Lycos Rhyme (rhyme.lycos.com)                            |
| *rpmsearch*        | Search for RPMs in various distros                                                     |
| *scholar*          | Search Google Scholar (scholar.google.com)                                             |
| *scicom*           | Search Scientific Commons                                                              |
| *scirus*           | Search for science using Scirus (scirus.com)                                           |
| *scpan*            | Search the Comprehensive Perl Archive Network (search.cpan.org)                        |
| *slashdot*         | Search stories on Slashdot (www.slashdot.org)                                          |
| *slinuxdoc*        | Search entries in LDP (www.linuxdoc.org)                                               |
| *sourceforge*      | Search SourceForge (www.sourceforge.net)                                               |
| *springer*         | Search Springer for Books and Articles                                                 |
| *stack*            | Search Stack Overflow                                                                  |
| *stockquote*       | Get a single stock quote (multiple providers)                                          |
| *thesaurus*        | Look up word in Merriam-Webster's Thesaurus (www.m-w.com)                              |
| *translate*        | Translate human languages                                                              |
| *urban*            | Search urbandictionary.com for a definition                                            |
| *w3css*            | Validate a CSS URL with the w3c CSS validator (jigsaw.w3.org/css-validator)            |
| *w3html*           | Validate a web page URL with the w3c validator (validator.w3.org)                      |
| *w3link*           | Check web page links with the w3c linkchecker (validator.w3.org/checklink)             |
| *w3rdf*            | Validate a RDF URL with the w3c RDF validator (validator.w3.org)                       |
| *wayback*          | Search The Internet Archive's Wayback Machine for a URL (archive.org)                  |
| *webster*          | Look up word in Merriam-Webster's Dictionary (www.m-w.com)                             |
| *wetandwild*       | Real time weather information (many sources)                                           |
| *wikipedia*        | Search the free encyclopedia wikipedia                                                 |
| *woffle*           | Search the web using Woffle (localhost:8080)                                           |
| *wolfram*          | Ask questions of the computational knowledge engine                                    |
| *worldwidescience* | Search for science with www.worldwidescience.org                                       |
| *yacy*             | Search YaCy P2P search, including ScienceNet                                           |
| *yahoo*            | Search Yahoo categories (www.yahoo.com)                                                |
| *yandex*           | Search the web using Yandex (yandex.ru)                                                |
| *youtube*          | Search YouTube (www.youtube.com)                                                       |
| *yubnub*           | Use the social command-line for the web (yubnub.org)                                   |

--------------

***** Usage

Surfraw consists of a collection of elvi, each of which knows how to
search a specific web site.

To see the [[#elvilist][list]] of elvi type:

=surfraw -elvi=

Note that sr is an alias for surfraw, so that could equally be:

=sr -elvi=

To search using an elvis use:

=sr elviname= /[options] search terms../

For example, to search google for information on Debian ports, using the
"I'm feeling lucky" option:

=sr google -l debian ports=

Note that putting quotes round arguments works now, so you can do, for
example:

=sr google foo "bar baz" bam=\\

and the quoting is passed on to the search engine.

****** Adding the elvi to your path

If you are a regular user of surfraw, you will probably get sick of
typing =sr= or =surfraw= each time. You can regain the old behaviour of
running the elvi directly by adding the elvi directory (usually
=/usr/lib/surfraw/= or =/usr/local/lib/surfraw/=) to your path, either
manually or using =surfraw-update-path(1)=.

****** Bookmarks

Surfraw now supports bookmarks. To add a bookmark, add it to
=/etc/surfraw.bookmarks= or =$HOME/.surfraw.bookmarks=

The format of the bookmarks file is simple, each bookmark is on a
separate line, with the bookmark and URL separated by whitespace, for
example:

= ntk   http://www.ntk.net/=

To invoke a bookmark, use =surfraw bookmark= or =sr bookmark=, and if an
elvis of that name doesn't exist, it searches for a bookmark of that
name instead.

There are some example bookmarks in =/etc/surfraw.bookmarks=

****** Completion

Surfraw has support for bash completion. If bash completion is enabled
you can use the <TAB> key to complete elvi names, options and arguments.

****** Options

Global options are common to all Surfraw elvi (clients). You can get a
[[#elvilist][list]] of the currently installed elvi by typing
=surfraw -elvi=.

All elvi have useful low calorie help, for example:

#+BEGIN_EXAMPLE
    $ sr rhyme -help
    Usage: rhyme [options] [search words]...
    Description:
      Surfraw search for rhymes and other word correlations using
      Lycos Rhyme (http://rhyme.lycos.com)
    Example:
      $ surfraw rhyme Julian
      $ sr rhyme -method=rel surfer
    Results:
      Hurclean St. Julien.
      surfboarder, bather, natator, swimmer
    Local options:
      -method=                      Type of word correlation to search for
              prefect       |       Perfect rhyme
              syn           |       Synonyms
              hom           |       Homophones
              cons          |       Consonsant rhymes only
              rel           |       Semantically related words
              sub           |       Phrases
              spell         |       Similar spellings
              pic           |       Pictures
              shake         |       Match with Shakespeare archives
              def                   Find wordnet definition
                                    Default: perfect
                                    Environment: SURFRAW_rhyme_method
    Global options:
      -browser=EXECUTABLE           Set browser
                                    Default: mozilla
      -elvi                         List Surfraw mechanisms for conquering evil
      -escape-url-args=yes|no       Apply url escaping to arguments
                                    Default: yes
                                    Environment: SURFRAW_escape_url_args
      -g | -graphical               Get some windowed sin
      -help                         What you're reading now, dude
      -quiet=yes|no                 I can't enjoy it with you talking all the time
                                    Default: no
                                    Environment: SURFRAW_quiet
      -new[=yes|no]                 Start in a new window
                                    Default: no
                                    Environment: SURFRAW_new_window
      -t | -text                    Back to the yellow brick road
      -q | -quote                   Quote arguments with " characters
                                    Default: no
                                    Environment: SURFRAW_quote_args
      -version                      Display Surfraw version (1.0.4)
    Copyright:
      Copyright (c) 2003-2007 The Surfraw-Devel Team
                               <surfraw-devel@lists.alioth.debian.org>
      Copyright (c) 2000-2001 Julian Assange
      Copyright (c) 2001 Australian Institute for Collaborative Research
      Copyright (c) 2000 Melbourne Institute for Advanced Study
      ---
#+END_EXAMPLE

--------------

***** Configuration

Surfraw gets its configuration from three sources, in order:

1. Environment variables
2. =/etc/surfraw.conf=
3. =$HOME/.surfraw.conf=

=/etc/surfraw.conf= and =$HOME/.surfraw.conf= are both fragments of
bourne-shell style shell script.

=/etc/surfraw.conf= should use def and defyn to define variables. These
functions set variables unless they are already set by the environment.
defyn is used for boolean configuration variables, def for all others.
For instance:

#+BEGIN_EXAMPLE
     def     SURFRAW_text_browser   /usr/bin/lynx
     defyn   SURFRAW_graphical      no
#+END_EXAMPLE

=$HOME/.surfraw.conf= should use /sh/-style entries, eg:

#+BEGIN_EXAMPLE
     SURFRAW_text_browser=/usr/bin/lynx
     SURFRAW_graphical=no
#+END_EXAMPLE

This is because you want them to override environment variables
unconditionally.

****** Configuration Variables

Variable

Meaning

Default

SURFRAW\_global\_conf

Location of global configuration file.

/etc/surfraw.conf

SURFRAW\_conf

Location of per-user configuration file.

$HOME/.surfraw.conf

SURFRAW\_graphical

Whether to use a graphical browser.

no

SURFRAW\_text\_browser

Name/path of text browser executable.\\
 e.g. links, lynx, w3m

sensible-browser

SURFRAW\_graphical\_browser

Name/path of graphical browser executable.\\
 e.g mozilla, netscape etc.

sensible-browser

SURFRAW\_text\_browser\_args

Text browser arguments, or "none".

none

SURFRAW\_graphical\_browser\_args

Graphical browser arguments, or "none".

none

SURFRAW\_graphical\_remote

Whether to use =-remote openURL= for graphical browser.

yes

SURFRAW\_new\_window

When using SURFRAW\_graphical\_remote, open a new window?

no

SURFRAW\_screen

Name of screen command to run.

screen

SURFRAW\_screen\_args

Arguments to screen command

SURFRAW\_new\_screen

If surfraw is running under screen(1), start a new screen for each text
browser invocation?

no

SURFRAW\_quiet

I can't enjoy it with you talking all the time.

no

SURFRAW\_quote\_args

Whether to "quote" all the arguments.

no

SURFRAW\_quote\_ifs

Whether to re-quote arguments if they have spaces in, ie so:\\
 =sr google foo "bar baz" bam=\\
 works as expected.

yes

SURFRAW\_results

Default number of results to return (not supported by all elvi).

30

SURFRAW\_escape\_url\_args

Whether to escape =[%"$%&+,/:;<=>?@[\^{|}~']= characters in command line
arguments subsequently used to construct a url.

yes

SURFRAW\_lang

Elvi supporting this will use it to select a default country or
language. It should be set to an ISO 2-letter country code (e.g. /uk/,
/de/, /ca/).

none

SURFRAW\_customsearch\_provider

Provider for searches that use a search engine. Supported: google,
duckduckgo.

duckduckgo

****** Files

=$(libdir)/surfraw=

Location of the elvi.

=/etc/surfraw.conf=

Default system wide configuration file.

=$HOME/.surfraw.conf=

Default per-user config file

=/etc/surfraw.bookmarks=

System wide bookmarks file.

=$HOME/.surfraw.bookmarks=

Per-user bookmarks file.

--------------

***** Development and Support

Surfraw was originally written by Julian Assange. It is now maintained
and improved by a team of programmers based around the
[[mailto:surfraw-devel@lists.alioth.debian.org][surfraw-devel]] mailing
list.

The surfraw project webpage is at
[[http://surfraw.alioth.debian.org/][surfraw.alioth.debian.org]]

To report a bug or request an enhancement (e.g. a new elvi), send email
to
[[mailto:surfraw-devel@lists.alioth.debian.org][surfraw-devel@lists.alioth.debian.org]]

The current development version of surfraw can be obtained from the
surfraw [[http://anonscm.debian.org/gitweb/?p=surfraw/surfraw.git][git
repository]]. To check out the repository:

#+BEGIN_EXAMPLE
    git clone git://anonscm.debian.org/surfraw/surfraw.git
#+END_EXAMPLE
*** llvm                                                       :llvm:clang:
**** llvm/clang 安装

http://llvm.org/docs/CMake.html


CMake 方式， configure/make/make intall 不再支持

#+BEGIN_EXAMPLE
ben@ ~ $ clang --version
clang version 3.8.0 (trunk 256638)
Target: i686-pc-linux-gnu
Thread model: posix
InstalledDir: /usr/local/bin
#+END_EXAMPLE

clang

#+BEGIN_EXAMPLE
Clang is designed to be built as part of an LLVM build. Assuming that the LLVM
source code is located at $LLVM_SRC_ROOT, then the clang source code should be
installed as:

  $LLVM_SRC_ROOT/tools/clang

The directory is not required to be called clang, but doing so will allow the
LLVM build system to automatically recognize it and build it along with LLVM.
#+END_EXAMPLE

**** clang
+ http://clang.llvm.org/

***** what?
+ http://zh.wikipedia.org/wiki/Clang
+ http://zh.wikipedia.org/wiki/LLVM
+
Clang（发音为/ˈklæŋ/类似英文单字clang） 是一个C、C++、Objective-C和
Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后
端。它的目标是提供一个GNU编译器套装（GCC）的替代品。源代码授权是使用类
BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。

LLVM，一个自由软件项目，是一种编译器的基础建设，以C++写成。它是为了任
意一种编程语言写成的程序，利用虚拟技术，创造出编译时期，链结时期，运行
时期以及“闲置时期”的最优化。它最早是以C/C++为实现对象，目前它支持了
包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java bytecode、
Objective-C、Swift、Python、Ruby、Rust、Scala以及C♯.

***** Install
1. apt-get
2. Source code: http://clang.llvm.org/get_started.html

****

*** metapost                                                     :metapost:

**** reference

+ [[http://www.tug.org/metapost.html][Homepage on tug]]
+ [[http://www.ctex.org/documents/shredder/metapost.html][CTex: metapost]]
+ [[http://www.ctex.org/documents/shredder/metapostexample.html][CTex: metapost example]]
+ [[https://zh.wikipedia.org/wiki/MetaPost][Wiki]]pedia:metapost
+ [[~/Wally/Reference/Manual/MetapostManual.pdf][MetapostManual.pdf]]

**** into

MetaPost是一个程序语言和它的编译器的名字，衍生于高德纳的Metafont。
MetaPost擅长 *通过数学描述制作矢量图* ，生成的图片为PostScript格式。它
的语法来自Metafont。

**** matapose in Emacs

- meta-mode :: major mode for editing Metafont or MetaPost sources(built-in)
- [[https://github.com/liyu1981/metapost-mode-][metapost-mode+.el]] ::

#+BEGIN_SRC emacs-lisp
(require 'metapost-mode+)
#+END_SRC

***** metapost-mode+

https://github.com/liyu1981/metapost-mode-

****** Overview

metapost-mode+.el is an extension to old metapost-mode.el in GNU Emacs.
It will add following new features to metapost-mode:

-  Compile the .mp file and preview the results smartly by C-c C-c.
-  Notify user when the compile is failed and jump to error line with
   C-c `.
-  Support metapost with LaTeX labels.

****** System Requirement

-  GNU Emacs 23.2+ (with corresponding version of metapost-mode.el and
   doc-view.el)
-  Workable TeX/LaTeX installation, including ghostscript/epstopdf
-  MacOSX Snow Leopard and Ubuntu are tested, other linux should work.
   Windows is not tested and probably breaks.

****** Get metapost-mode+.el

You can get the lastest version of metapost-mode+.el at github.
Documentation is included in the source, or you can find it with
discussion on emacswiki.

****** Usage

-  Make sure your metapost, gs and epstopdf work. Try "metapost some.mp"
   and "epstopdf some.eps" to check it.
-  Make sure your doc-view.el is newer than the corresponding version
   with GNU Emacs 23.2
-  Add (require ‘metapost-mode+) to your .emacs
-  Open some example in the test dir on github, such as MultiFigure.mp.
-  C-c C-c to see the preview figure

**** usage

1. 文件后缀： *.mp*
2. 编译命令行工具： *mpost* , 生成 eps 文件
3. epstopdf

了解足够，用以致学

*** freemind                                             :freemind:mindmap:

**** [[http://www.douban.com/group/topic/19280450/][思维导图软件]]

思维导图，又叫心智图。它的创始人是”大脑先生”托尼•巴赞（Tony Buzan）。

思维导图是一种将放射性思考具体化的方法。我们知道放射性思考是人类大脑的
自然思考方式，每一种进入大脑的信息，不论是感觉、记忆或是想法——包括文字、
数字、符码、食物、香气、线条、颜色、意象、节奏、音符等，都可以成为一个
思考中心，并由此中心向外发散出成千上万的关节点，每一个关节点代表与中心
主题的一个连结，而每一个连结又可以成为另一个中心主题，再向外发散出成千
上万的关节点，而这些关节的连结可以视为您的记忆，也就是您的个人数据库。

几款高级思维导图软件

1. PersonalBrain http://personalbrain.evget.com/

   目前比较流行的思维导图软件，使用简单方便，有专业版和普通版区别，专
   业版收费，界面很漂亮，蓝色的皮肤有点像宇宙的感觉，每个元素有上级、
   下级、同级3个节点，提供注释、备注等功能。

2. MindMapper http://www.mindmapper.com/

   它严格地遵守托尼巴贡的制图法则，关键字都是放在延伸手臂上。能够提供
   xml的输出 能与微软办公软件沟通，还有最妙的时间线进度。 快捷键是最好
   用的，无需点鼠标就可以建立新节点。

3. ThinkMap SDK http://www.thinkmap.com/

   软件介面非产酷，强大的数据库功能，3d树形网络,有很好的API开发接口。
   就是价格太贵。

4. FreeMind

   FreeMind是一款跨平台的、基于GPL协议的自由软件，用Java编写，是一个用
   来绘制思维导图的软件。其产生的文件格式后缀为.mm 。可用来做笔记，脑
   图记录，脑力激汤等。　

5. Xmind http://www.xmind.net/

   XMind是一款易用性很强的软件，通过XMind可以随时开展头脑风暴，帮助人
   们快速理清思路。XMind 绘制的思维导图、鱼骨图、二维图、树形图、逻辑
   图、组织结构图等以结构化的方式来展示具 LOGO

6. mindmanager http://www.evget.com/zh-CN/product/1069/feature.aspx

   mindmanager由美国Mindjet公司开发，界面可视化，有着直观、友好的用户
   界面和丰富的功能，　可使使用者有序地组织思维、资源和项目进程，同时
   它是高效的项目管理软件，能很好提高项目组的工作效率和小组成员之间的
   协作性。它作为一个组织资源和管理项目的方法，可从思维导图的核心分枝
   派生出各种关联的想法和信息。

**** [[http://xbeta.info/xmind-freemind.htm][XMind vs FreeMind]]   :xmind:

思维导图类软件中，最有影响力的开源免费软件是 FreeMind 和XMind。

FreeMind历史悠久，当属经典；XMind作为后起之秀，大有赶超之势。同作为免费、开源的思维导图解决方案，应如何选择/结合两款软件？

本文的分析基于Windows平台下的 FreeMind 0.90 RC3 和 XMind 3.03，结合笔
者的使用经验，也包括XMind开发者所提供的信息。基本结论是： *总体看，
XMind已超越 FreeMind；个别方面，FreeMind 值得 XMind 学习*

***** XMind 与 FreeMind 的相同/相通之处

- 都是免费、开源、基于 Java。
- 都满足绘制思维导图的基本甚至高级功能。
- 相通之处：XMind 可以导入/导出 FreeMind 格式；反之不能。

***** XMind 与 FreeMind 比较

1. XMind: 更丰富的结构且支持混用

   FreeMind：只支持一种逻辑图（水平）结构。

   XMind：在逻辑图之外，还支持组织结构图（竖直）、树状图（水平+竖直）、
   思维导图（辐射）、鱼骨图、二维图（表格）。不仅如此，还能在一个文档
   中组合使用多种表达形式。实用举例：整个项目管理用逻辑图，人员安排部
   分用组织结构图，风险及应对采用鱼骨图，进度部分用二维图。

2. XMind: 支持自由节点因而支持多图

   FreeMind：只能有一棵树，即：根节点唯一，其他节点必须直接或间接放在
   根节点下。

   XMind：允许在主树之外创建自由节点（应用举例：把“文档作者/创建日期”作
   为自由节点，补充思维导图信息）；由于自由节点也是可以增加子节点的，
   所以可产生第二棵、第N棵新树。

3. FreeMind: 根节点仍可以插入父节点

   需求：在绘完的导图上再加一层。比如，最初建立了“唐诗”导图，现在要
   扩展到“唐宋文学”，即“唐诗”根节点要降至二级节点。

   XMind：顶级的自由节点之间是可以互为子节点的，但原来的根节点（XMind
   称为中心主题）则不能拖到其他节点上。满足上述需求，就要新建文档，以
   “唐宋文学”为根节点，然后导入或粘贴原有内容。\\

    FreeMind：支持根节点上插入“父节点”。

   建议：XMind的“根节点”比FreeMind减少了一份特殊性，即允许其他节点独
   立于此；但仍包留了另一份特殊性，不能成为其他节点的子节点。从使用角
   度，建议取消此限制，即：任何节点本身是一样的，彼此之间为父子关
   系。------或许有技术限制，但节点/层级的平等灵活是XML的精神。

4. XMind 支持附件, FreeMind 全为链接

   FreeMind：可以有超链接到外部文档和图片，也可以显示外部的图片。但这
   些资源都只是.mm文件中的链接url，并非素材本身。即，.mm是纯文本的xml，
   包括 FreeMind的图标也是以ID数字标示。

   XMind：支持上述链接方式，也支持（默认）把该文档及图片引入XMind文件
   作为附件，形成完整的资料包。.xmind 格式与OOo文档一样，实质是 xml＋
   素材的zip包。展开后的内容举例如下：

   #+BEGIN_EXAMPLE
     attachments\
     attachments\4hm2upmpscpth85latqpd49biq.png
     attachments\179ekuhhgn9g866cg5a26b78fh.pdf
     META-INF\
     META-INF\manifest.xml
     Thumbnails\
     Thumbnails\thumbnail.jpg
     content.xml
     meta.xml
     styles.xml
   #+END_EXAMPLE

5. 发布思维导图方面，XMind 要向 FreeMind 学习

   1) 能导出哪些格式

      - XMind 免费版：FreeMind、html、图片（bmp/jpg/gif/png）、纯文本
      - XMind Pro：以上 + MindManager、pdf（普通/思维图）、ppt/doc/rtf
      - FreeMind：各种html、flash、pdf、OpenOffice文档、png/jpg、
        svg/twiki等格式

   2) 我关注的导出格式、比较、说明

      - 静态图片：思维导“图”当然要能导出静态图片，这是最低需求。实在
        不能导出，截屏亦可。只是内容太多超过一屏时，截屏就不太方便了。
        图片可用于网页发布，也可用于其他文档（pdf/office）。格式方面，
        强烈不推荐bmp/jpg，推荐png/gif格式，[[http://blog.sina.com.cn/s/blog_46dac66f010004ox.html][原因见此]]。这方面，XMind与
        FreeMind持平。

      - pdf文档发布：相比图片的优点是，放大后文字仍然清晰。如果内容太
        多，导出一页的pdf发给别人，无论用于打印还是放大查看，都比图片
        的效果好很多。对比结果：XMindPro（未用过）＞ FreeMind（够用）
        ＞ XMind（无）-- 广义html导出：FreeMind 遥遥领先，详细见下。

      - 广义html导出的详细比较

        结论：广义html/flash式导出，目的是在线发布后，仍保留折叠/展开
        动态效果，及链接功能。这方面，FreeMind遥遥领先，远胜 XMind。

        XMind：导出的html包括图片和节点文字。但图与文字无链接；文字层
        级也不能折叠；图片默认为jpg，强烈建议换为png。

        FreeMind：可采用不同技术进行导出，每种导出效果都非常好。
        FreeMind导出html的格式有：

        - html：纯文字方式，节点保留原有格式，层级关系可折叠展开，url链接有效。
        - xhtml（javascript）：效果同上，只是改用js实现。
        - xhtml（可点击map图片）：除了上述文字内容外，还附有图片，并且点击图片的节点可跳转到对应的文字。
        - java applet：功能保留最多的方式。在浏览器中的使用效果近乎在 FreeMind中打开 .mm文件。
        - flash：点击可折叠/展开，链接url有显示但无法点击。

6. FreeMind节点支持html代码

   FreeMind：节点支持html代码，实现文字格式化、换行、分段、图像链接、
   表格。（此外，还支持LaTex代码）

    XMind：不能对部分文字分别设定格式，可以shift+enter换行。

7. XMind 具有更好的可持续性

   FreeMind作为经典开源软件，虽在持续更新中，但新功能进展并不多。而同
   作为开源软件的XMind，不仅因为后发优势拥有了更多功能。并且，作为有商
   业公司支持的开源产品，新功能的开发会更加活跃------这并非迷信商业，
   而是实际情况，包括两个开发团队的成员也有此认识。

    另外，XMind还提供了更强大的Pro版，可以满足个人和企业的更高需求，并
   能提供可靠的技术支持。

8. XMind 更美观，FreeMind 更快速省资源

   无论用户界面还是思维导图文件，XMind 都更加美观。而 FreeMind更加简约，
   占用资源更少，启动和运行速度更快。各取所需即可。

9. 其他差异

   FreeMind 可以导入目录结构，相当于变成了资源管理器；XMind不能。

   在节点输入较多文字的过程中，XMind的输入框会阶梯式不断加大，而
   FreeMind会保持同样大小（只显示最右侧部分）。

   XMind的节点可以添加标签，以进行过滤筛选；而FreeMind可以根据节点文字
   进行过滤显示。

    注意：XMind导入.mm时，无法识别包含html代码的节点。

***** 结论：软件选择建议

大多数人普通用户：XMind。理由：支持逻辑图、二维图等多种表达形式并可混
用，更加美观、支持附件。

*Geek或偏执者：FreeMind。理由：更节约资源，界面更简朴。*

自主网络发布：FreeMind。理由：强大灵活的html导出功能。

不执着于软件，仅执着于最优效果：主用 XMind 辅用FreeMind。即仅在自主网
络发布时另存为FreeMind格式，再用FreeMind导出为html。

**** freemind

+ [[http://freemind.sourceforge.net/wiki/index.php/Main_Page][Homepage]]

***** install                                                   :install:

新得立 version 0.9

beta: 1.1

http://freemind.sourceforge.net/wiki/index.php/Download

http://www.getdeb.net/app/Freemind -> 软件中心

不支持的软件源，安装过程中需要 “修复”。。。

还是源码 -> ant (java 版 make)

#+BEGIN_EXAMPLE
java.io.IOException: Cannot run program "/home/wally/Download/freemind/check_for_duplicate_resources.sh": error=13, 权限不够
#+END_EXAMPLE

sudo 和切换为 root 用户，也不行？

还是 apt-get 方式

***** usage

用起来体验不错。

*** scratch                                                       :scratch:

**** intro                                                         :intro:

Scratch是麻省理工大学媒体实验室终身幼稚园组开发的一套电脑程序开发平台，
旨在让程序设计语言初学者不需先学习语言语法便能设计创作产品。开发者期望
通过学习Scratch，启发和激励用户在愉快的环境下通过实验（如设计交互故事）
去学习程序设计、数学和计算知识，同时获得创造性的思考，系统推理，和协同
工作的体验。

Scratch 开发平台可安装在Mac OS X、Windows、Linux的平台上；自2.0之后，
换用Actionscript编制，Scratch运行于浏览器。Scratch源码开放给非商业性质
用途使用。


#+DOWNLOADED: https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Scratchcat.svg/180px-Scratchcat.svg.png @ 2016-01-18 11:17:22
 [[~/Wally/Journal/Figure/.org-download/Journal/180px-Scratchcat.svg_2016-01-18_11:17:21.png]]

**** keyword                                                     :keyword:

scratch, MIT, 教育软件， 跨平台， 开源

**** reference                                                  :homepage:

- [[https://zh.wikipedia.org/wiki/Scratch%E8%AF%AD%E8%A8%80][Wikipedia: scratch 语言]]
- [[https://scratch.mit.edu/][Homepage]]
- [[http://cacm.acm.org/magazines/2009/11/48421-scratch-programming-for-all/fulltext][Scratch: Programming for All]]

*** godot                                                           :godot:

**** reference                                                  :homepage:

- [[http://www.godotengine.org/projects/godot-engine][Homepage]]
- [[https://github.com/godotengine/godot][Github]]

**** intro                                                         :intro:

Godot is a fully featured, open source, MIT licensed, game engine. It
focuses on having great tools, and a visual oriented workflow that can
export to PC, Mobile and Web platforms with no hassle. The editor,
language and APIs are feature rich, yet simple to learn, allowing you
to become productive in a matter of hours.

[[/home/wally/Wally/Journal/Figure/scrot/32504Cqi.png]]


开源游戏引擎

** 云工具                                                            :cloud:
*** dropbox                                                       :dropbox:
**** dropbox 安装                                                :install:

- 下载(64bit for Ubuntu): https://www.dropbox.com/zh_CN/install?os=lnx

- dpkg install
  #+BEGIN_EXAMPLE
    $ sudo dpkg -i dropbox_2015.10.28_amd64.deb
    正在选中未选择的软件包 dropbox。
    (正在读取数据库 ... 系统当前共安装有 241104 个文件和目录。)
    正准备解包 dropbox_2015.10.28_amd64.deb  ...
    正在解包 dropbox (2015.10.28) ...
    正在设置 dropbox (2015.10.28) ...
    Please restart all running instances of Nautilus, or you will experience problems. i.e. nautilus --quit
    Dropbox installation successfully completed! You can start Dropbox from your applications menu.
    正在处理用于 gnome-menus (3.10.1-0ubuntu5) 的触发器 ...
    正在处理用于 desktop-file-utils (0.22-1ubuntu3) 的触发器 ...
    正在处理用于 bamfdaemon (0.5.1+15.04.20150202-0ubuntu1) 的触发器 ...
    Rebuilding /usr/share/applications/bamf-2.index...
    正在处理用于 mime-support (3.58ubuntu1) 的触发器 ...
    正在处理用于 hicolor-icon-theme (0.14-0ubuntu1) 的触发器 ...
    正在处理用于 man-db (2.7.0.2-5) 的触发器 ...
  #+END_EXAMPLE
**** 卸载 dropbox /dpkg/                                       :uninstall:

#+BEGIN_EXAMPLE
  bagfile $ dpkg -l | grep dropbox
  rc  dropbox
  ii  nautilus-dropbox

  bagfile $ sudo apt-get remove dropb^C

  bagfile $ dpkg -h
  dpkg：错误：未知选项 -h

  输入 dpkg --help 可获得安装和卸载软件包的有关帮助 [*]；
  使用 apt 或是 aptitude 就能在友好的界面下管理软件包；
  输入 dpkg -Dhelp 可看到 dpkg 除错标志的值的列表；
  输入 dpkg --force-help 可获得所有强制操作选项的列表；
  输入 dpkg-deb --help 可获得有关操作 *.deb 文件的帮助；

  带有 [*] 的选项将会输出较大篇幅的文字 - 可使用管道将其输出连接到 less 或 more ！

  bagfile $ dpkg --help
  用法：dpkg [<选项> ...] <命令>

  ...
    -P|--purge         <package> ... | -a|--pending
  ...
  'apt' 和 'aptitude' 提供了更为便利的软件包管理。

  bagfile $ dpkg --purge dropbox
  dpkg：错误：该操作需要超级用户权限

  bagfile $ sudo dpkg --purge dropbox
  [sudo] password for ben:
  (正在读取数据库 ... 系统当前共安装有 538113 个文件和目录。)
  正在卸载 dropbox (2015.02.12) ...
  正在清除 dropbox (2015.02.12) 的配置文件 ...

  bagfile $ sudo dpkg --purge nautilus-dropbox
  (正在读取数据库 ... 系统当前共安装有 538113 个文件和目录。)
  正在卸载 nautilus-dropbox (1.6.1-1) ...
  Dropbox isn't running!
  dropbox：没有发现操作
  正在清除 nautilus-dropbox (1.6.1-1) 的配置文件 ...
  正在处理用于 hicolor-icon-theme (0.13-1) 的触发器 ...
  正在处理用于 man-db (2.6.7.1-1ubuntu1) 的触发器 ...
  正在处理用于 mime-support (3.54ubuntu1.1) 的触发器 ...
  正在处理用于 gnome-menus (3.10.1-0ubuntu2) 的触发器 ...
  正在处理用于 desktop-file-utils (0.22-1ubuntu1) 的触发器 ...
  正在处理用于 bamfdaemon (0.5.1+14.04.20140409-0ubuntu1) 的触发器 ...
  Rebuilding /usr/share/applications/bamf-2.index...
  bagfile $

#+END_EXAMPLE

*** irc                                                               :irc:

[[/home/wally/Wally/Journal/Figure/scrot/30980jYW.png]]

**** what?

- [[http://baike.baidu.com/link?url=jB5JRb4FBbjGCs8fKheTymXOqf6zMaalCSvNR7_lkkrsjRbrgKPKS3a7jLchJcJ2x2OQMt4J4TuYSkzb_kZb2sdoG0dAMnLrVcXd1Nooo7y][百度百科]]

IRC是Internet Relay Chat 的英文缩写，中文一般称为互联网中继聊天。

它是多用户、多频道的讨论系统，许多用户可以在一个频道内就某一话题进行交
谈或私谈，每个用户都有一个不同的昵称。IRC允许任意的因特网用户之间做即
时的交谈。

IRC用户使用特定的用户端聊天软件连接到IRC服务器，通过服务器中继与其他连
接到这一服务器上的用户交流，所以IRC的中文名为“因特网中继聊天”。

**** features

- [[http://www.zhihu.com/question/24851247][知乎：为什么现如今还有人使用 IRC 聊天交流？
]]


- IRC 协议简单，开源实现多，本来就备受开发者青睐；
- 因此，其第三方机器人程序非常众多，开源实现库一抓一大把，任何想做多人同用机器人的开发者，都可以轻易上手，几乎每种语言都有一个实现，不必去望洋兴叹。
- IRC 不用登录，不用注册；但如果你注册了，就可以强制把占用自己唯一ID 的人踢下线。
- IRC 也可以私聊。
- IRC 也有特殊权限。
- IRC 是开源社区会议标准；
- 因此，IRC 在开源社区用得比较多；
- 因此，许多开源世界的技术大牛混在那里。

**** 客户端

- [[http://wiki.ubuntu.org.cn/IRC%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%89%E5%93%AA%E4%BA%9B][Ubuntu Forum: IRC 客户端有哪些]]

***** 网络浏览器

Firefox插件

-  [[https://addons.mozilla.org/en-US/firefox/addon/16][火狐插件ChatZilla]]

***** 网页

-  [[http://webchat.freenode.net/]] Freenode封了Mibbit后自己搞定HTML版本
-  [[https://irc.gitter.im/]] Beta，兼容lynx
-  [[https://kiwiirc.com/client]] 神抛弃老旧Opera后的选择

***** QT

-  [[/Quassel][Quassel]] 配合KDE功能强悍
-  [[https://konversation.kde.org/][Konversation]] KDE的默认客户端
-  [[http://www.kvirc.net/][KVIrc]]

***** GTK

-  [[/IRC@Pidgin][Pidgin]]
-  [[/Xchat][xchat]]

***** CLI

-  [[http://irssi.org/][irssi]] CLI界面IRC工具
-  [[http://www.gnu.org/software/emacs/][ERC]] 神的工具，神的ERC *Emacs IRC*

** 系统工具
*** terminator
http://54rd.net/html/2015/server_0122/30.html

Terminator比Terminal更加好玩一些，增加了许多特性，而且自定义更加灵活。

**** [[http://54rd.net/html/2015/server_0122/30.html][ubuntu分屏终端terminator好用的快捷键]]       :blog:terminal:terminator:

在ubuntu下的默认终端为terminal，但terminator会更好用一些，操作设置会更方便。使用常用快捷键：新增标签页：Ctrl
+ Shift + T 关闭标签页：Ctrl + Shift + W 左右分屏：Ctrl + Shift + E
上下分屏：Ctrl + Shi

在ubuntu下的默认终端为terminal，但terminator会更好用一些，操作设置会更方便。
 安装命令直接使用apt-get安装：


$sudo apt-get install terminator


 安装完成后，可以根据自己喜好修改颜色，可支持横竖切屏，支持多标签。

 [[http://54rd.net/uploadfile/2015/0122/20150122020858396.png]]

 使用常用快捷键：

 新增标签页：Ctrl + Shift + T
 关闭标签页：Ctrl + Shift + W
 左右分屏：Ctrl + Shift + E
 上下分屏：Ctrl + Shift + O
 复制：Ctrl + Shift + C
 粘贴：Ctrl + Shift + V
 清屏幕：Ctrl + Shift + G

*** Cabal                                                           :cabal:

+ https://www.haskell.org/cabal/

Cabal(Common Architecture for Building Applications and Libraries),
Cabal is a system for building and packaging Haskell libraries and
programs. It defines a common interface for package authors and
distributors to easily build their applications in a portable
way. Cabal is part of a larger infrastructure for distributing,
organizing, and cataloging Haskell libraries and programs.

+ INSTALL: sudo apt-get install cabal-install

**** [[https://www.haskell.org/cabal/][The Haskell Cabal]]                                              :blog:

Cabal is a system for building and packaging Haskell libraries and
programs. It defines a common interface for package authors and
distributors to easily build their applications in a portable
way. Cabal is part of a larger infrastructure for distributing,
organizing, and cataloging Haskell libraries and programs.

Specifically, the Cabal describes what a Haskell package is, how these
packages interact with the language, and what Haskell implementations
must to do to support packages. The Cabal also specifies some
infrastructure (code) that makes it easy for tool authors to build and
distribute conforming packages.

The Cabal is only one contribution to the larger goal. In particular,
the Cabal says nothing about more global issues such as how authors
decide where in the module name space their library should live; how
users can find a package they want; how orphan packages find new
owners; and so on.

*** ruby gem                                                     :ruby:gem:
*RubyGems is a sophisticated package manager for Ruby.*

+ Usage:
  - gem -h/--help
  - gem -v/--version
  - gem command [arguments...] [options...]
+ Examples:
  - gem install rake
  - gem list --local
  - gem build package.gemspec
  - gem help install

*** ant                                                               :ant:
+ wiki: http://en.wikipedia.org/wiki/Apache_Ant
+ tutorial: http://ideoplex.com/focus/java#ant
+ official page: http://ant.apache.org/

**** overview

Apache Ant is a Java library and command-line tool that help building
software.

***** what

Apache Ant is a software tool for automating software build
processes.(*like make*) It was a replacement for the *unix make* build
tool, and was created due to a number of problems with the unix make.

***** language

It is similar to Make but is *implemented using the Java language*,
requires the Java platform, and is best suited to building Java
projects.

***** vs make

The most immediately noticeable difference between Ant and Make is
that *Ant uses XML* to describe the build process and its
dependencies, whereas Make uses Makefile format.

By default the XML file is named *build.xml*.

***** license

Ant is an Apache project. It is open source software, and is released
under the *Apache License*.

**** Install
+ source code: need to configure java, so just quit
+ *apt*

*** bzr                                                               :bzr:
+ http://bazaar.canonical.com/en/


Bazaar is a version control system that helps you track project
history over time and to collaborate easily with others. Whether
you're a single developer, a co-located team or a community of
developers scattered across the world, Bazaar scales and adapts to
meet your needs. Part of the GNU Project, Bazaar is free software
sponsored by Canonical.

*** ruby gem(类似pip)                                                 :gem:

*rubygems is a sophisticated package manager for ruby.*

+ usage:
  - gem -h/--help
  - gem -v/--version
  - gem command [arguments...] [options...]
+ examples:
  - gem install rake
  - gem list --local
  - gem build package.gemspec
  - gem help install
*** [[http://www.mono-project.com/][Mono]]                                                             :mono:

Mono is a software platform designed to allow developers to easily
create /cross platform/ applications.

Mono is an /open source/ implementation of Microsoft's /.NET/
Framework based on the ECMA standards for /C#/ and the Common Language
Runtime

*** [[http://gparted.org/][gpart]]ed                                                    :gparted:分区:

GParted is a free partition editor for graphically managing your disk
partitions.

1. 自由软件
2. 无损
3. 支持多文件系统
4. 跨平台


**** reference

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/068691ea-74cb-4746-9e01-aab7c5fea39b/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D151a03fff49%3AS%3Da7cdab468b0fda8aa40c273b7e670af5][使用Gparted]]为Ubuntu分区
+

**** 手记
+ 2015/12/14 Ubuntu下安装XP双系统需要额外两个Windows分区，尝试gparted使用失败，放弃

*** gnupg                                                       :gpg:gnupg:

https://www.gnupg.org/

** wine                                                               :wine:
*** wine

**** reference

- [[https://www.winehq.org/][Homepage]]

*** caj                                                          :知网:caj:


**** install by wine                                             :install:

***** error: unable to create a MSXML instance                    :error:

源码安装的wine安装CAJviewer没有问题，使用时出现 unable to create a
MSXML instance错误

可能是缺少微软库依赖。ArchLinux查得 Some applications (e.g. Office
2003/2007) require the MSXML library to parse HTML or XML, in such
cases you need to install
lib32-libxml2. https://wiki.archlinux.org/index.php/Wine

但libxml2已经安装

卸载源码安装的wine，使用apt-get方式安装后，问题解决。

***** warning: 没有发现 MDAC

[[/home/wally/Wally/Journal/Figure/scrot/27745A7Y.png]]

MDAC

可以忽略。

**** caj to pdf
+ [[http://www.360doc.com/content/12/0925/16/19671_238111948.shtml][360doc: 如何将 NH, KDH 文件转换为 PDF 或者 WORD 文档]]
+ [[http://www.zhihu.com/question/21103230][知乎：caj文件可否完美转换pdf文件使其在Kindle 4/5 上阅读？]]

1. 虚拟打印机转换为pdf或xps格式
2. 少瞎折腾

为什么不直接下载PDF，可以从 *万方* 上直接下载PDF

**** CAJ tricks                                                    :trick:

+ wine 安装 CAJviewer
+ 在CAJviewer中通过cups打印为pdf,方便在Emacs中浏览
+ 在CAJviewer中另存为txt文档

**** wine caj 使用规范

+ 不要添加文字标签笔记，程序会崩溃
+ 使用高亮，表示有参考价值的地方
+ 使用下划线表示可以注意的地方
+ 使用删除线表示需要做为反面教材的地方

*** wine 百度云

不行，别折腾

** virtualbox                                                   :virtualbox:
*** QENU
+ http://wiki.qemu.org/Main_Page
+ http://wiki.qemu.org/Manual
+
   https://wiki.archlinux.org/index.php/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)
+ [[http://www.linuxforu.com/2011/06/qemu-for-embedded-systems-development-part-1/][Using QEMU for Embedded Systems Development, Part 1]]
+ [[http://www.linuxforu.com/2011/07/qemu-for-embedded-systems-development-part-2/][Using QEMU for Embedded Systems Development, Part 2]]
+ [[http://www.linuxforu.com/2011/08/qemu-for-embedded-systems-development-part-3/][Using QEMU for Embedded Systems Development, Part 3 ]]
+ [[http://www.crifan.com/summary_qemu_usage_note/][QEMU使用心得]]
+ http://blog.sina.com.cn/s/blog_4cd90db30100ccxy.html
+ [[http://www.tinylab.org/why-computer-students-learn-linux-open-source-technologies/][为什么计算机的学生要学习 Linux 开源技术]]
+ [[http://www.tinylab.org/using-qemu-simulation-inserts-the-type-system-to-produce-the-whole-process/][利用qemu模拟嵌入式系统制作全过程]]

**** what
QEMU是一款开源的模拟器及虚拟机监管器(Virtual Machine Monitor, VMM)。

QEMU主要提供两种功能给用户使用。
1. 一是作为用户态模拟器，利用动态代码翻译机制来执行不同于主机架构的代
   码。
2. 二是作为虚拟机监管器，模拟全系统，利用其他VMM(Xen, KVM, etc)来使用
   硬件提供的虚拟化支持，创建接近于主机性能的虚拟机。
**** Install
1. 包管理器
   + Debian: apt-get
   + RedHat: yum
2. 源码
   1) 获取源码
      + 官网：http://wiki.qemu.org/Main_Page
      + git: https://github.com/qemu/qemu
   2) 编译安装
      获取源码后，可以根据需求来配置和编译QEMU。
      #+BEGIN_EXAMPLE
        $cd qemu-2.0.0 //如果使用的是git下载的源码，执行cd qemu
        $./configure --enable-kvm --enable-debug --enable-vnc \
        --enable-werror --target-list="x86_64-softmmu"
        $make -j8
        $sudo make install
      #+END_EXAMPLE

      configure脚本用于生成Makefile，其选项可以用
      `./configure --help`查看。这里使用到的选项含义如下：

      + --enable-kvm：编译KVM模块，使QEMU可以利用KVM来访问硬件提供的虚
        拟化服务。
      + --enable-vnc：启用VNC。
      + --enalbe-werror：编译时，将所有的警告当作错误处理。
      + --target-list：选择目标机器的架构。默认是将所有的架构都编译，
        但为了更快的完成编译，指定需要的架构即可。
**** 创建虚拟机
+
  https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/qemu1_%25e4%25bd%25bf%25e7%2594%25a8qemu%25e5%2588%259b%25e5%25bb%25ba%25e8%2599%259a%25e6%258b%259f%25e6%259c%25ba?lang=en


1. 创建虚拟机镜像

   使用qemu-img创建虚拟机镜像。虚拟机镜像用来模拟虚拟机的硬盘，在启动
   虚拟机之前需要创建镜像文件(.img文件)。
   #+BEGIN_EXAMPLE
     $ qemu-img create -f qcow2 fedora.img 10G
   #+END_EXAMPLE
   + -f选项用于指定镜像的格式，qcow2格式是QEMU最常用的镜像格式，采用来写时复制技术来优化性能。
   + file.img是镜像文件的名字
   + 10G是镜像文件大小。

   镜像文件创建完成后，可使用qemu-system-x86来启动x86架构的虚拟机：
   #+BEGIN_EXAMPLE
   $ qemu-system-x86_64 fedora.img `
   #+END_EXAMPLE

2. 使用系统镜像文件安装操作系统
   #+BEGIN_EXAMPLE
     $ qemu-system-x86_64 -m 2048 -enable-kvm fedora.img \
       -cdrom ./Fedora-Live-Desktop-x86_64-20-1.iso
   #+END_EXAMPLE

   + -m 指定虚拟机内存大小，默认单位是MB
   + -enable-kvm使用KVM进行加速
   + -cdrom添加fedora的安装镜像

  可在弹出的窗口中操作虚拟机，安装操作系统，安装完成后重起虚拟机便会从
   硬盘(fedora.img)启动。之后再启动虚拟机只需要执行：
   #+BEGIN_EXAMPLE
     $ qemu-system-x86_64 -m 2048 -enable-kvm fedora.img
   #+END_EXAMPLE

*** virtualbox extension download address

http://download.virtualbox.org/virtualbox/

*** virtual box 屏幕分辨率

安装增强功能


*** VirtualBox USB 支持                                               :usb:

-  [[http://www.cnblogs.com/ericsun/archive/2013/06/10/3130679.html][在Ubuntu12.04 上为Virtualbox 启用USB 设备支持]]


众所周知,VirtualBox使用宿主机的USB设备需要安装扩展包。根据自己的vbox的
版本，到vbox官网下载对应的扩展包。比如我的vbox 是4.1.12的，对应扩展包
地址是：[[http://download.virtualbox.org/virtualbox/4.1.12/Oracle_VM_VirtualBox_Extension_Pack-4.1.12-77245.vbox-extpack][http://download.virtualbox.org/virtualbox-extpack]]

下载完毕后，在“管理”菜单下的“全局设定”里的“扩展”标签下，加入、启
用即可。

如图：

[[http://static.xiazhengxin.name/img/install_vbox_ext_package.png]]

之后，打开虚拟系统设置，在“USB设备”标签下，勾选上"启用USB控制器"以及
"2.0控制器"增加对USB2.0的支持。

如图：
 [[http://static.xiazhengxin.name/img/enable_USB2_controller.png]]

按说这个时候已经搞定了。可是在USB列表里面却没有任何USB设备。这是为什么
呢？谷歌了一下，找到了一篇文章(具体地址已经无法回忆起来了，囧)，解释了
一下原因。

*原来是vbox 所在的用户组比如要包括当前用户才行。*

查看当前用户名：

#+BEGIN_EXAMPLE
sharl@sharl-laptop:~$ whoami
sharl
#+END_EXAMPLE


查看vbox 所在的组：

#+BEGIN_EXAMPLE
sharl@sharl-laptop:~$ cat /etc/group | grep vbox
vboxusers:x:125:sharl
#+END_EXAMPLE

将当前用户加入vbox组：

#+BEGIN_EXAMPLE
usermod -a -G vboxusers sharl
#+END_EXAMPLE

即可。

此时，重启系统。再次打开虚拟机，果然，USB设备都已经被识别、访问到了。
这些，在“设备”菜单下就可以看到。

如图：

[[http://static.xiazhengxin.name/img/add_USB_device_to_vbox_from_list.png]]

添加后，虚拟机系统果然发现了新硬件，按照一般步骤，安装驱动即可正常使用。

*** virtual box dual-monitor                                 :dual_monitor:

**** use second monitor in full-screen mode

[[http://superuser.com/questions/355331/is-there-a-way-to-make-virtualbox-use-a-specific-monitor-when-going-full-screen][Stackoverflow: Is there a way to make VirtualBox use a specific
monitor when going full-screen?]]


When you are in Full Screen mode in the view menu choose "Virtual
Screen 1", "Use Host Screen 2"

While in fullscreen mode, press HostKey + Home to bring up the hidden
menu. Select *View -> Virtual Screen 1 -> Use Host Screen 2*

**** seamless mode

[[http://superuser.com/questions/109485/virtualbox-to-use-dual-monitors][stackoverflow: VirtualBox to use dual monitors]]


VirtualBox 3.2.1 supports *multiple guest monitors*. The documentation
was not clear on how to enable this.

Basic Setup:

1. Power off your virtual machine if it's on.
2. From the main VirtualBox window, select your VM and choose
   Settings.
3. Choose display.
4. Below "Video Memory" is Monitor Count. Slide it to 2, and adjust
   your video memory if VirtualBox complains.
5. Start your guest and perform the standard "Extend the desktop onto
   this display" method based on the Guest OS. (Guest Additions need
   to be installed.)
6. A second "Oracle VM VirtualBox" window will appear with the second
   display. You can resize it however you want.

*Seamless/Fullscreen*

Enter Seamless or Fullscreen. I'll assume your HostKey is the default
RightCtrl.

If the screens are on the wrong displays, hit RightCtrl+Home.

From the View Menu, choose Virtual Display 1 and set it to the Host
display you want. The other displays will shuffle around to
accommodate this. If you have more than 2 virtual displays, repeat
with Virtual Display 2 and so on.

*Headless*

Set the number of monitors with VBoxManage modifyvm "vm name"
--monitorcount X

Enable multiple vrdp connections with VBoxManage modifyvm "VM name"
--vrdpmulticon on

Use VBoxHeadless to launch as normal.

connect to monitor 1 with rdesktop -d \@1 ip-address-of-host and
monitor 2 with rdesktop -d \@2 ip-address-of-host. This is explained
in lomaxx's answer. (You might be able to use @ instead of \@,
depending on your shell)

*** [[http://askubuntu.com/questions/144905/virtualbox-windows-key-pass-through-to-gnome][VirtualBox 解除 win 键占用]]

1. 出发点

   使用 Ubuntu 时要经常使用 Win + Num 组合键在 Emacs，shell, Chrome 等
   窗口之间切换。当切换到虚拟机时，该组合键失效。

   Win+1 EmacS
   Win+2 Shell
   Win+3 Chrome
   Win+4 File
   Win+5 VirtualBox

   补充： 还有 Alt+Tab 键

2. 设置

   #+BEGIN_EXAMPLE
     Open the VirtualBox Manager window, and go to "File" menu,
     "Preferences" (Ctrl-G).
     Under "Input", uncheck the box labeled "Auto Capture
     Keyboard". There is no need to restart the VM if it's running, so
     this can be changed "on the fly".
   #+END_EXAMPLE

   #+DOWNLOADED: file:///home/wally/Desktop/2016-01-20%2015:12:44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png @ 2016-01-20 15:13:10
   [[~/Wally/Journal/Figure/.org-download/Tasks/2016-01-20%2015:12:44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2016-01-20_15:13:10.png]]

   Note: 在 Virtual Box 的管理窗口中，而不是虚拟机窗口中。

3. 测试 OK

** mobilephone
*** 手机 VPN                                                          :vpn:

不用下载客户端，直接使用配置中的VPN

**** [[http://www.jincon.com/archives/248][linux系统下Imagemagick的convert图像处理常用命令详解]]    :blog:convert:

[[http://www.jincon.com/tag/convert/][convert]] 是 [[http://www.jincon.com/tag/imagemagick/][imagemagick]] 软件包中的一个命令。它可以读取、转换、写入多种
格式的图片。图片切割、颜色替换、各种效果的应用，图片的旋转、组合，文本，
直线，多边形，椭圆，曲线，附加到图片伸展旋转。这里介绍几个简单的命令，
具体的用法请参考man手册或者其官方网站。在Ubuntu中用命令


#+BEGIN_EXAMPLE
    sudo apt-get install imagemagick(centos的yum 一下就OK了)
#+END_EXAMPLE



*Convert的resize命令：*

Convert的resize子命令应该是在ImageMagick中使用较多的命令，它实现了图片任意大小的缩放，唯一需要掌握的就是如何使用它的一些参数测试设定值：

此说明文件中所用的原始文件(src.jpg)，宽度：200，高度：150

命令格式： -resize widthxheight{%} {@} {!} {<} {>} {\^}

1.
默认时，宽度和高度表示要最终需要转换图像的最大尺寸，同时Convert会控制图片的宽和高，保证图片按比例进行缩放。

如：convert -resize 600×600 src.jpg dst.jpg

转换后的dst.jpg的图片大小(宽度为600，而高度已经按比例调整为450).

2.如果需要转换成600×600，而图片无需保持原有比例，可以在宽高后面加上一个感叹号!.

如：convert -resize 600×600! src.jpg dst.jpg

3.
只指定高度，图片会转换成指定的高度值，而宽度会按原始图片比例进行转换。

如：convert -resize 400 src.jpg dst.jpg

转换后的dst.jpg的图片大小(宽度为400，而高度已经按比例调整为300)，和例1有点类似。

4. 默认都是使用像素作为单位，也可以使用百分比来形象图片的缩放。

如：convert -resize 50%x100%! src.jpg dst.jpg 或者convert -resize
50%x100% src.jpg dst.jpg

此参数只会按你的比例计算后缩放，不保持原有比例。(结果尺寸为100×150)

5.使用 @ 来制定图片的像素个数。

如：convert -resize “10000@” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(115×86)，图片保持原有比例(115×86= 9080 <
10000)。

6.当原始文件大于指定的宽高时，才进行图片放大缩小，可使用>命令后缀。

如：convert -resize “100×50>” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(67×50)，图片保持原有比例。

如：convert -resize “100×50>!” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(100×50)，图片不保持原有比例。

7.当原始文件小于指定的宽高时，才进行图片放大转换，可使用<命令后缀。

如：convert -resize “100×500<” src.jpg dst.jpg 或者convert -resize
“100×100

此命令执行后，dst.jpg和src.jpg大小相同，因为原始图片宽比100大。

如：convert -resize “600×600<” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(600×450)，图片保持原有比例。

如：convert -resize “600×600

此命令执行后，dst.jpg图片大小为(600×600)，图片不保持原有比例。

8.使用\^命令后缀可以使用宽高中较小的那个值作为尺寸

如：convert -resize “300×300\^” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(400×300)，图片保持原有比例，(300:300 <
200:150，选择高作为最小尺寸)。

如：convert -resize “300×200\^” src.jpg dst.jpg

此命令执行后，dst.jpg图片大小为(300×225)，图片保持原有比例，(300:200 >
200:150，选择宽作为最小尺寸)。

*Convert的quality 命令：*



#+BEGIN_EXAMPLE
    convert -resize -quality 50 1405407568-633.jpg 800.jpg
#+END_EXAMPLE





*Convert的sample命令 生成250x250缩略图：*

convert -sample 250x250 wgy.jpg sample.jpg

另外，你还可以加水印，就不再赘述了。命令行的强大之处还是在于其简洁、快速，更适用于批量处理。

附上一个简单的shell脚本，共大家修改和使用：

#+BEGIN_EXAMPLE
    #! /bin/sh
    for i in `ls *.jpg`;
    do
    convert -resize 50% "$i" "${i%.jpg}.png";
    done
#+END_EXAMPLE

** miscellaneous

*** 关于删除文件与回收站                                           :回收站:

不要让自己的强迫症影响到学习工作, 删除时将文件移至回收站, 而不是直接彻
底删除.
否则, 极有可能造成不可挽回的损失.
可以定期清理回收站.

* miscellaneous

*** openwrt                                                :openwrt:路由器:

- [[https://zh.wikipedia.org/wiki/OpenWrt][Wiki]]
- [[https://openwrt.org/][Homepage]]
- [[http://post.smzdm.com/p/99210/][树莓派&OpenWrt]]


1. what?

   基于 Linux 的开源路由器(应用于嵌入式的 Linux 发行版本)

2. history

   2003年底推出WRT-54G，是一款基于MIPS架构的无线路由器，并且使用
   802.11g标准使得带宽在理论上能够达到54M，在当时是一次巨大的成长。
   WRT-54G操作系统以Linux取代vXworks，哥伦比亚大学法学院教授Eben
   Moglen向Linksys提出开源要求。2003年7月，Linksys迫于压力，开源了
   WRT54G的firmware，不久sveasoft公司开发了Alchemy。从此无线路由器进入
   了可以刷机的时代。

3. application

   - 用于脱机离线下载。
   - VPN服务器。
   - SSH服务器。
   - Shadowsocks配合Pdnsd、Chinadns、Dnscrypt软件智能突破网络审查。
   - 动态DDNS。
   - 单线多拨及带宽叠加。
   - QOS智能限速（从石像鬼中提取）。
   - 远程视频监控。

* Project
